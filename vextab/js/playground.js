(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
(function (process){
/* parser generated by jison 0.4.16 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,6],$V1=[1,7],$V2=[1,8],$V3=[1,9],$V4=[5,11,13,14,15],$V5=[5,11,13,14,15,17,19,21],$V6=[2,17],$V7=[1,14],$V8=[5,11,13,14,15,17,19,21,22],$V9=[1,18],$Va=[1,19],$Vb=[1,20],$Vc=[1,21],$Vd=[1,43],$Ve=[1,32],$Vf=[1,33],$Vg=[1,42],$Vh=[1,41],$Vi=[1,39],$Vj=[1,48],$Vk=[1,55],$Vl=[1,50],$Vm=[1,51],$Vn=[1,52],$Vo=[1,53],$Vp=[1,54],$Vq=[1,56],$Vr=[1,44],$Vs=[1,45],$Vt=[1,46],$Vu=[1,47],$Vv=[1,57],$Vw=[5,11,13,14,15,17,19,21,25],$Vx=[5,11,13,14,15,17,19,21,23,31,32,37,38,45,48,57,61,62,63,64,65,66,70,71,73,75,76],$Vy=[2,79],$Vz=[1,67],$VA=[1,64],$VB=[1,65],$VC=[1,66],$VD=[1,73],$VE=[1,74],$VF=[1,78],$VG=[1,79],$VH=[1,80],$VI=[1,81],$VJ=[41,57,59,61,62,63,64,65,66,67,68,69],$VK=[38,45,48,76],$VL=[41,48,57,59,61,62,63,64,65,66,67,68,69,81],$VM=[5,11,13,14,15,17,19,21,23,31,32,37,38,41,45,48,57,61,62,63,64,65,66,70,71,73,75,76],$VN=[1,101],$VO=[44,46],$VP=[2,63],$VQ=[1,106],$VR=[5,11,13,14,15,17,19,21,23,31,32,37,38,45,48,57,59,61,62,63,64,65,66,70,71,73,75,76],$VS=[5,11,13,14,15,17,19,21,23,31,32,37,38,45,48,57,59,60,61,62,63,64,65,66,70,71,73,75,76],$VT=[25,71],$VU=[41,48,57,59,61,62,63,64,65,66,67,68,69],$VV=[5,11,13,14,15,17,19,21,23,31,32,37,38,44,45,46,48,57,61,62,63,64,65,66,70,71,73,75,76];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"e":3,"maybe_vextab":4,"EOF":5,"vextab":6,"stave":7,"voice":8,"maybe_options":9,"stave_data":10,"OPTIONS":11,"options":12,"TABSTAVE":13,"STAVE":14,"VOICE":15,"stave_additions":16,"TEXT":17,"text":18,"NOTES":19,"notes":20,"SLUR":21,"WORD":22,"=":23,"STR":24,",":25,"lingo":26,"line":27,"chord":28,"time":29,"bar":30,"[":31,"]":32,"tuplets":33,"annotations":34,"command":35,"rest":36,"|":37,":":38,"frets":39,"maybe_decorator":40,"/":41,"string":42,"chord_line":43,".":44,"(":45,")":46,"articulation":47,"NUMBER":48,"abc":49,"_":50,"timed_fret":51,"time_values":52,"maybe_dot":53,"time_unit":54,"maybe_slash":55,"w":56,"h":57,"q":58,"d":59,"S":60,"-":61,"s":62,"t":63,"T":64,"b":65,"p":66,"v":67,"V":68,"u":69,"^":70,"$":71,"annotation_words":72,"!":73,"COMMAND":74,"#":75,"ABC":76,"abc_accidental":77,"accidental_type":78,"@":79,"n":80,"~":81,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",11:"OPTIONS",13:"TABSTAVE",14:"STAVE",15:"VOICE",17:"TEXT",19:"NOTES",21:"SLUR",22:"WORD",23:"=",24:"STR",25:",",31:"[",32:"]",37:"|",38:":",41:"/",44:".",45:"(",46:")",48:"NUMBER",50:"_",56:"w",57:"h",58:"q",59:"d",60:"S",61:"-",62:"s",63:"t",64:"T",65:"b",66:"p",67:"v",68:"V",69:"u",70:"^",71:"$",73:"!",74:"COMMAND",75:"#",76:"ABC",79:"@",80:"n",81:"~"},
productions_: [0,[3,2],[4,0],[4,1],[6,1],[6,2],[7,3],[7,2],[7,2],[8,1],[8,1],[8,1],[10,1],[10,2],[16,2],[16,2],[16,2],[9,0],[9,1],[12,3],[12,4],[18,1],[18,3],[20,1],[20,2],[26,1],[26,1],[26,1],[26,1],[26,1],[26,1],[26,1],[26,1],[26,1],[26,1],[30,1],[30,3],[30,3],[30,3],[30,3],[30,3],[27,4],[43,1],[43,3],[28,4],[28,5],[39,1],[39,1],[39,4],[39,2],[39,4],[51,5],[51,1],[51,5],[51,8],[51,1],[51,4],[29,3],[52,2],[54,1],[54,1],[54,1],[54,1],[53,0],[53,1],[55,0],[55,1],[42,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[47,1],[40,1],[40,1],[40,1],[40,1],[40,0],[33,3],[33,5],[34,3],[72,1],[72,3],[35,3],[36,2],[36,3],[36,4],[49,3],[77,1],[77,2],[77,1],[77,2],[77,1],[77,0],[78,0],[78,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:

      return $$[$0-1];
    
break;
case 2: case 17: case 79:
 this.$ = null 
break;
case 3: case 12: case 18: case 23: case 25: case 26: case 27: case 42: case 59: case 60: case 61: case 62: case 67:
 this.$ = $$[$0] 
break;
case 4: case 83:
 this.$ = [$$[$0]] 
break;
case 5:
 this.$ = [].concat($$[$0-1], $$[$0]) 
break;
case 6:
 this.$ = {
        element: $$[$0-2],
        options: $$[$0-1],
        notes: $$[$0].notes,
        text: $$[$0].text,
        _l: _$[$0-2].first_line,
        _c: _$[$0-2].first_column
      }
    
break;
case 7:
 this.$ = {
        element: $$[$0-1],
        options: $$[$0],
        _l: _$[$0-1].first_line,
        _c: _$[$0-1].first_column
      }
    
break;
case 8:

      this.$ = {
        element: "options",
        params: $$[$0],
        _l: _$[$0-1].first_line,
        _c: _$[$0-1].first_column
      }
    
break;
case 13:

      var text = [].concat($$[$0-1].text, $$[$0].text);
      var notes = [].concat($$[$0-1].notes, $$[$0].notes);
      var slurs = [].concat($$[$0-1].slurs, $$[$0].slurs)
      this.$ = {text: text, notes: notes, slurs: slurs};
    
break;
case 14:
this.$ = {text: $$[$0], notes: [], slurs: []}
break;
case 15:
this.$ = {notes: $$[$0], text: [], slurs: []}
break;
case 16:
this.$ = {slurs: $$[$0], notes: [], text: []}
break;
case 19:
 this.$ = [{
        key: $$[$0-2],
        value: $$[$0],
        _l: _$[$0-2].first_line,
        _c: _$[$0-2].first_column
      }]
    
break;
case 20:
 this.$ = [].concat($$[$0-3], [{
        key: $$[$0-2],
        value: $$[$0],
        _l: _$[$0-2].first_line,
        _c: _$[$0-2].first_column
        }])
    
break;
case 21:
 this.$ = [{text: $$[$0], _l: _$[$0].first_line, _c: _$[$0].first_column}] 
break;
case 22:
 this.$ = [].concat($$[$0-2], {text: $$[$0], _l: _$[$0].first_line, _c: _$[$0].first_column}) 
break;
case 24:
 this.$ = [].concat($$[$0-1], $$[$0])  
break;
case 28:
 this.$ = [{
        command: "bar",
        type: $$[$0],
        _l: _$[$0].first_line,
        _c: _$[$0].first_column
        }]
    
break;
case 29:
 this.$ = [{
        command: "open_beam",
        _l: _$[$0].first_line,
        _c: _$[$0].first_column
      }]
    
break;
case 30:
 this.$ = [{
        command: "close_beam",
        _l: _$[$0].first_line,
        _c: _$[$0].first_column
      }]
    
break;
case 31:
 this.$ = [{
        command: "tuplet",
        params: $$[$0],
        _l: _$[$0].first_line,
        _c: _$[$0].first_column
      }]
    
break;
case 32:
 this.$ = [{
        command: "annotations",
        params: $$[$0],
        _l: _$[$0].first_line,
        _c: _$[$0].first_column
      }]
    
break;
case 33:
 this.$ = [{
        command: "command",
        params: $$[$0],
        _l: _$[$0].first_line,
        _c: _$[$0].first_column
      }]
    
break;
case 34:

    this.$ = [{
        command: "rest",
        params: $$[$0]
      }]
    
break;
case 35:
 this.$ = 'single' 
break;
case 36:
 this.$ = 'double' 
break;
case 37:
 this.$ = 'end' 
break;
case 38:
 this.$ = 'repeat-end' 
break;
case 39:
 this.$ = 'repeat-begin' 
break;
case 40:
 this.$ = 'repeat-both' 
break;
case 41:

      _.extend(_.last($$[$0-3]), {decorator: $$[$0-2]})
      _.each($$[$0-3], function(fret) { fret['string'] = $$[$0] })
      this.$ = $$[$0-3]
    
break;
case 43: case 84:
 this.$ = [].concat($$[$0-2], $$[$0]) 
break;
case 44:
 this.$ = [{chord: $$[$0-2], decorator: $$[$0]}] 
break;
case 45:
 this.$ = [{chord: $$[$0-2], articulation: $$[$0-4], decorator: $$[$0]}] 
break;
case 46:
 this.$ = [{
        fret: $$[$0],
        _l: _$[$0].first_line,
        _c: _$[$0].first_column}]
    
break;
case 47:
 this.$ = [{abc: $$[$0], _l: _$[$0].first_line, _c: _$[$0].first_column}]
break;
case 48:
 this.$ = [{abc: $$[$0-3], octave: $$[$0-2],
             fret: $$[$0], _l: _$[$0-3].first_line, _c: _$[$0-3].first_column}]
break;
case 49:
 this.$ = [_.extend($$[$0], {articulation: $$[$0-1]})] 
break;
case 50:

      _.extend(_.last($$[$0-3]), {decorator: $$[$0-2]})
      _.extend($$[$0], {articulation: $$[$0-1]})
      $$[$0-3].push($$[$0])
      this.$ = $$[$0-3]
    
break;
case 51:
 this.$ = {
      time: $$[$0-3], dot: $$[$0-2], fret: $$[$0],
      _l: _$[$0-4].first_line, _c: _$[$0-4].first_column}
break;
case 52:
 this.$ = {fret: $$[$0], _l: _$[$0].first_line, _c: _$[$0].first_column} 
break;
case 53:
 this.$ = {time: $$[$0-3], dot: $$[$0-2], abc: $$[$0]}
break;
case 54:
 this.$ = {time: $$[$0-6], dot: $$[$0-5], abc: $$[$0-3], octave: $$[$0-2], fret: $$[$0]}
break;
case 55:
 this.$ = {abc: $$[$0], _l: _$[$0].first_line, _c: _$[$0].first_column} 
break;
case 56:
 this.$ = {abc: $$[$0-3], octave: $$[$0-2],
            fret: $$[$0], _l: _$[$0-3].first_line, _c: _$[$0-3].first_column} 
break;
case 57:
 this.$ = {time: $$[$0-1], dot: $$[$0]} 
break;
case 58:
 this.$ = $$[$0-1] + $$[$0] 
break;
case 63:
 this.$ = false 
break;
case 64:
 this.$ = true 
break;
case 65:
 this.$ = '' 
break;
case 66: case 69:
 this.$ = 's' 
break;
case 68:
 this.$ = '-' 
break;
case 70:
 this.$ = 't' 
break;
case 71:
 this.$ = 'T' 
break;
case 72:
 this.$ = 'b' 
break;
case 73:
 this.$ = 'h' 
break;
case 74:
 this.$ = 'p' 
break;
case 75:
 this.$ = 'v' 
break;
case 76:
 this.$ = 'V' 
break;
case 77:
 this.$ = 'u' 
break;
case 78:
 this.$ = 'd' 
break;
case 80:
 this.$ = {tuplet: $$[$0-1]} 
break;
case 81:
 this.$ = {tuplet: $$[$0-3], notes: $$[$0-1]} 
break;
case 82: case 85:
 this.$ = $$[$0-1] 
break;
case 86:
 this.$ = {position: 0} 
break;
case 87:
 this.$ = {position: $$[$0-1]} 
break;
case 88:
 this.$ = {position: $$[$0-1] * -1} 
break;
case 89:
 this.$ = {key: $$[$0-2], accidental: $$[$0-1], accidental_type: $$[$0]} 
break;
case 90:
 this.$ = "#" 
break;
case 91:
 this.$ = "##" 
break;
case 92:
 this.$ = "b" 
break;
case 93:
 this.$ = "bb" 
break;
case 94:
 this.$ = "n" 
break;
case 96:
 this.$ = null; 
break;
case 97:
 this.$ = "c" 
break;
}
},
table: [{3:1,4:2,5:[2,2],6:3,7:4,8:5,11:$V0,13:$V1,14:$V2,15:$V3},{1:[3]},{5:[1,10]},{5:[2,3],7:11,8:5,11:$V0,13:$V1,14:$V2,15:$V3},o($V4,[2,4]),o($V5,$V6,{9:12,12:13,22:$V7}),{12:15,22:$V7},o($V8,[2,9]),o($V8,[2,10]),o($V8,[2,11]),{1:[2,1]},o($V4,[2,5]),o($V4,[2,7],{10:16,16:17,17:$V9,19:$Va,21:$Vb}),o($V5,[2,18],{22:$Vc}),{23:[1,22]},o($V4,[2,8],{22:$Vc}),o($V4,[2,6],{16:23,17:$V9,19:$Va,21:$Vb}),o($V5,[2,12]),{18:24,24:[1,25]},{20:26,23:$Vd,26:27,27:28,28:29,29:30,30:31,31:$Ve,32:$Vf,33:34,34:35,35:36,36:37,37:$Vg,38:$Vh,39:38,45:$Vi,47:40,48:$Vj,49:49,57:$Vk,61:$Vl,62:$Vm,63:$Vn,64:$Vo,65:$Vp,66:$Vq,70:$Vr,71:$Vs,73:$Vt,75:$Vu,76:$Vv},o($V5,$V6,{12:13,9:58,22:$V7}),{23:[1,59]},{22:[1,60]},o($V5,[2,13]),o($V5,[2,14],{25:[1,61]}),o($Vw,[2,21]),o($V5,[2,15],{27:28,28:29,29:30,30:31,33:34,34:35,35:36,36:37,39:38,47:40,49:49,26:62,23:$Vd,31:$Ve,32:$Vf,37:$Vg,38:$Vh,45:$Vi,48:$Vj,57:$Vk,61:$Vl,62:$Vm,63:$Vn,64:$Vo,65:$Vp,66:$Vq,70:$Vr,71:$Vs,73:$Vt,75:$Vu,76:$Vv}),o($Vx,[2,23]),o($Vx,[2,25]),o($Vx,[2,26]),o($Vx,[2,27]),o($Vx,[2,28]),o($Vx,[2,29]),o($Vx,[2,30]),o($Vx,[2,31]),o($Vx,[2,32]),o($Vx,[2,33]),o($Vx,[2,34]),o([41,57,61,62,63,64,65,66],$Vy,{40:63,59:$Vz,67:$VA,68:$VB,69:$VC}),{27:69,39:38,43:68,47:70,48:$Vj,49:49,57:$Vk,61:$Vl,62:$Vm,63:$Vn,64:$Vo,65:$Vp,66:$Vq,76:$Vv},{38:$VD,45:[1,71],48:$VE,49:75,51:72,76:$Vv},{48:$VF,52:76,54:77,56:$VG,57:$VH,58:$VI},o($Vx,[2,35]),{37:[1,82],38:[1,83]},{48:[1,84]},{22:[1,86],72:85},{74:[1,87]},{48:[1,89],61:[1,90],75:[1,88]},o($VJ,[2,46]),o($VJ,[2,47],{48:[1,91]}),o($VK,[2,68]),o($VK,[2,69]),o($VK,[2,70]),o($VK,[2,71]),o($VK,[2,72]),o($VK,[2,73]),o($VK,[2,74]),o($VL,[2,95],{77:92,75:[1,93],79:[1,94],80:[1,95]}),o($V5,[2,16]),{22:[1,96]},o($V8,[2,19]),{24:[1,97]},o($Vx,[2,24]),{41:[1,98],47:99,57:$Vk,61:$Vl,62:$Vm,63:$Vn,64:$Vo,65:$Vp,66:$Vq},o($VM,[2,75]),o($VM,[2,76]),o($VM,[2,77]),o($VM,[2,78]),{44:$VN,46:[1,100]},o($VO,[2,42]),{38:$VD,48:$VE,49:75,51:72,76:$Vv},{27:69,39:38,43:102,47:70,48:$Vj,49:49,57:$Vk,61:$Vl,62:$Vm,63:$Vn,64:$Vo,65:$Vp,66:$Vq,76:$Vv},o($VJ,[2,49]),{48:$VF,52:103,54:77,56:$VG,57:$VH,58:$VI},o($VJ,[2,52]),o($VJ,[2,55],{48:[1,104]}),o($Vx,$VP,{53:105,59:$VQ}),o($VR,[2,65],{55:107,60:[1,108]}),o($VS,[2,59]),o($VS,[2,60]),o($VS,[2,61]),o($VS,[2,62]),{23:[1,110],37:[1,109],38:[1,111]},{37:[1,112],38:[1,113]},{25:[1,115],70:[1,114]},{25:[1,117],71:[1,116]},o($VT,[2,83]),{73:[1,118]},o($Vx,[2,86]),{75:[1,119]},{48:[1,120]},{50:[1,121]},o($VU,[2,96],{78:122,81:[1,123]}),o($VL,[2,90],{75:[1,124]}),o($VL,[2,92],{79:[1,125]}),o($VL,[2,94]),o($V8,[2,20]),o($Vw,[2,22]),{42:126,48:[1,127]},{38:$VD,48:$VE,49:75,51:128,76:$Vv},o($Vx,$Vy,{40:129,59:$Vz,67:$VA,68:$VB,69:$VC}),{27:130,39:38,47:70,48:$Vj,49:49,57:$Vk,61:$Vl,62:$Vm,63:$Vn,64:$Vo,65:$Vp,66:$Vq,76:$Vv},{44:$VN,46:[1,131]},{38:$VP,53:132,59:$VQ},{50:[1,133]},o($Vx,[2,57]),o($Vx,[2,64]),o($VR,[2,58]),o($VR,[2,66]),o($Vx,[2,36]),o($Vx,[2,37]),o($Vx,[2,39]),o($Vx,[2,38]),o($Vx,[2,40]),o($Vx,[2,80]),{48:[1,134]},o($Vx,[2,82]),{22:[1,135]},o($Vx,[2,85]),o($Vx,[2,87]),{75:[1,136]},{48:[1,137]},o($VU,[2,89]),o($VU,[2,97]),o($VL,[2,91]),o($VL,[2,93]),o($VV,[2,41]),o($VV,[2,67]),o($VJ,[2,50]),o($Vx,[2,44]),o($VO,[2,43]),o($Vx,$Vy,{40:138,59:$Vz,67:$VA,68:$VB,69:$VC}),{38:[1,139]},{48:[1,140]},{70:[1,141]},o($VT,[2,84]),o($Vx,[2,88]),o($VJ,[2,48]),o($Vx,[2,45]),{48:[1,142],49:143,76:$Vv},o($VJ,[2,56]),o($Vx,[2,81]),o($VJ,[2,51]),o($VJ,[2,53],{48:[1,144]}),{50:[1,145]},{48:[1,146]},o($VJ,[2,54])],
defaultActions: {10:[2,1]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        function _parseError (msg, hash) {
            this.message = msg;
            this.hash = hash;
        }
        _parseError.prototype = new Error();

        throw new _parseError(str, hash);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

  var _ = require("underscore");
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: this.begin('notes'); return 19; 
break;
case 1: this.begin('options'); return 13; 
break;
case 2: this.begin('options'); return 14; 
break;
case 3: this.begin('options'); return 15; 
break;
case 4: this.begin('options'); return 11; 
break;
case 5: this.begin('text'); return 17; 
break;
case 6: this.begin('options'); return 21; 
break;
case 7:return 22
break;
case 8: this.begin('annotations'); return "$" 
break;
case 9: this.begin('notes'); return "$" 
break;
case 10:return 22
break;
case 11: this.begin('command'); return "!" 
break;
case 12: this.begin('notes'); return "!" 
break;
case 13:return 74
break;
case 14:return 24
break;
case 15:return 41
break;
case 16:return '+'
break;
case 17:return 38
break;
case 18:return 23
break;
case 19:return 45
break;
case 20:return 46
break;
case 21:return 31
break;
case 22:return 32
break;
case 23:return 70
break;
case 24:return 25
break;
case 25:return 37
break;
case 26:return 44
break;
case 27:return 75
break;
case 28:return 79
break;
case 29:return 65
break;
case 30:return 62
break;
case 31:return 57
break;
case 32:return 66
break;
case 33:return 63
break;
case 34:return 64
break;
case 35:return 61
break;
case 36:return 50
break;
case 37:return 67
break;
case 38:return 68
break;
case 39:return 69
break;
case 40:return 59
break;
case 41:return 48
break;
case 42:return 58
break;
case 43:return 56
break;
case 44:return 57
break;
case 45:return 59
break;
case 46:return 60
break;
case 47:return 76
break;
case 48:return 80
break;
case 49:return 81
break;
case 50: this.begin('INITIAL'); 
break;
case 51:/* skip whitespace */
break;
case 52:return 5
break;
case 53:return 'INVALID'
break;
}
},
rules: [/^(?:notes\b)/,/^(?:tabstave\b)/,/^(?:stave\b)/,/^(?:voice\b)/,/^(?:options\b)/,/^(?:text\b)/,/^(?:slur\b)/,/^(?:[^\s=]+)/,/^(?:[$])/,/^(?:[$])/,/^(?:[^,$]+)/,/^(?:[!])/,/^(?:[!])/,/^(?:[^!]+)/,/^(?:[^,\r\n]+)/,/^(?:\/)/,/^(?:\+)/,/^(?::)/,/^(?:=)/,/^(?:\()/,/^(?:\))/,/^(?:\[)/,/^(?:\])/,/^(?:\^)/,/^(?:,)/,/^(?:\|)/,/^(?:\.)/,/^(?:#)/,/^(?:@)/,/^(?:[b])/,/^(?:[s])/,/^(?:[h])/,/^(?:[p])/,/^(?:[t])/,/^(?:[T])/,/^(?:[-])/,/^(?:[_])/,/^(?:[v])/,/^(?:[V])/,/^(?:[u])/,/^(?:[d])/,/^(?:[0-9]+)/,/^(?:[q])/,/^(?:[w])/,/^(?:[h])/,/^(?:[d])/,/^(?:[S])/,/^(?:[A-GXLR])/,/^(?:[n])/,/^(?:[~])/,/^(?:[\r\n]+)/,/^(?:\s+)/,/^(?:$)/,/^(?:.)/],
conditions: {"notes":{"rules":[8,11,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53],"inclusive":true},"text":{"rules":[14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,41,42,43,44,45,50,51,52,53],"inclusive":true},"slur":{"rules":[15,16,17,18,19,20,21,22,23,24,25,26,27,28,50,51,52,53],"inclusive":true},"annotations":{"rules":[9,10,15,16,17,18,19,20,21,22,23,24,25,26,27,28,50,51,52,53],"inclusive":true},"options":{"rules":[7,15,16,17,18,19,20,21,22,23,24,25,26,27,28,50,51,52,53],"inclusive":true},"command":{"rules":[12,13,15,16,17,18,19,20,21,22,23,24,25,26,27,28,50,51,52,53],"inclusive":true},"INITIAL":{"rules":[0,1,2,3,4,5,6,7,15,16,17,18,19,20,21,22,23,24,25,26,27,28,50,51,52,53],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}
}).call(this,require('_process'))

},{"_process":3,"fs":2,"path":6,"underscore":7}],2:[function(require,module,exports){

},{}],3:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],4:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.2.0
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-01-08T20:02Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//"use strict";
var arr = [];

var document = window.document;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	version = "2.2.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		var realStringObj = obj && obj.toString();
		return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
	},

	isPlainObject: function( obj ) {

		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {

			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf( "use strict" ) === 1 ) {
				script = document.createElement( "script" );
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {

				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval

				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

// JSHint would error on this code due to the Symbol not being defined in ES5.
// Defining this global in .jshintrc would create a danger of using the global
// unguarded in another place, it seems safer to just disable JSHint for these
// three lines.
/* jshint ignore: start */
if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}
/* jshint ignore: end */

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.1
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-10-17
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, nidselect, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
					while ( i-- ) {
						groups[i] = nidselect + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( (parent = document.defaultView) && parent.top !== parent ) {
		// Support: IE 11
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				return m ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( (oldCache = uniqueCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		} );

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {

						// Inject the element directly into the jQuery object
						this.length = 1;
						this[ 0 ] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

				// Always skip document fragments
				if ( cur.nodeType < 11 && ( pos ?
					pos.index( cur ) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector( cur, selectors ) ) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this === promise ? newDefer.promise() : this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add( function() {

					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 ||
				( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.progress( updateFunc( i, progressContexts, progressValues ) )
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
} );


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {

	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
} );

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called
		// after the browser event has already occurred.
		// Support: IE9-10 only
		// Older IE sometimes signals "interactive" too soon
		if ( document.readyState === "complete" ||
			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

			// Handle it asynchronously to allow scripts the opportunity to delay ready
			window.setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	register: function( owner, initial ) {
		var value = initial || {};

		// If it is a node unlikely to be stringify-ed or looped over
		// use plain assignment
		if ( owner.nodeType ) {
			owner[ this.expando ] = value;

		// Otherwise secure it in a non-enumerable, non-writable property
		// configurability must be true to allow the property to be
		// deleted with the delete operator
		} else {
			Object.defineProperty( owner, this.expando, {
				value: value,
				writable: true,
				configurable: true
			} );
		}
		return owner[ this.expando ];
	},
	cache: function( owner ) {

		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return an empty object.
		if ( !acceptData( owner ) ) {
			return {};
		}

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ prop ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :
			owner[ this.expando ] && owner[ this.expando ][ key ];
	},
	access: function( owner, key, value ) {
		var stored;

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase( key ) );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key === undefined ) {
			this.register( owner );

		} else {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );

				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;

			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <= 35-45+
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://code.google.com/p/chromium/issues/detail?id=378607
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data, camelKey;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// with the key as-is
				data = dataUser.get( elem, key ) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

				if ( data !== undefined ) {
					return data;
				}

				camelKey = jQuery.camelCase( key );

				// Attempt to get data from the cache
				// with the key camelized
				data = dataUser.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			camelKey = jQuery.camelCase( key );
			this.each( function() {

				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = dataUser.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				dataUser.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
					dataUser.set( this, key, value );
				}
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" ||
			!jQuery.contains( elem.ownerDocument, elem );
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() { return tween.cur(); } :
			function() { return jQuery.css( elem, prop, "" ); },
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([\w:-]+)/ );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE9
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE9-11+
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== "undefined" ?
				context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0-4.3, Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE9
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return this;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Support (at least): Chrome, IE9
		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		//
		// Support: Firefox<=42+
		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
		if ( delegateCount && cur.nodeType &&
			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push( { elem: cur, handlers: matches } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
		"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split( " " ),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
			"screenX screenY toElement" ).split( " " ),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX +
					( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
					( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY +
					( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
					( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://code.google.com/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {
	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

function manipulationTarget( elem, content ) {
	if ( jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android<4.1, PhantomJS<2
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {

	// Keep domManip exposed until 3.0 (gh-2225)
	domManip: domManip,

	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );


var iframe,
	elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */

// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		display = jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
				.appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var documentElement = document.documentElement;



( function() {
	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {
		div.style.cssText =

			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );
	}

	jQuery.extend( support, {
		pixelPosition: function() {

			// This test is executed only once but we still do memoizing
			// since we can use the boxSizingReliable pre-computing.
			// No need to check if the test was already performed, though.
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {

			// Support: Android 4.0-4.3
			// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
			// since that compresses better and they're computed together anyway.
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {

			// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return reliableMarginLeftVal;
		},
		reliableMarginRight: function() {

			// Support: Android 2.3
			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. (#3333)
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// This support function is only executed once so no memoizing is needed.
			var ret,
				marginDiv = div.appendChild( document.createElement( "div" ) );

			// Reset CSS: box-sizing; display; margin; border; padding
			marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" +
				"display:block;margin:0;border:0;padding:0";
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";
			documentElement.appendChild( container );

			ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

			documentElement.removeChild( container );
			div.removeChild( marginDiv );

			return ret;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// http://dev.w3.org/csswg/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Support: IE11 only
	// In IE 11 fullscreen elements inside of an iframe have
	// 100x too small dimensions (gh-1764).
	if ( document.msFullscreenElement && window.top !== window ) {

		// Support: IE11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = Math.round( elem.getBoundingClientRect()[ name ] * 100 );
		}
	}

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = dataPriv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {

			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = dataPriv.access(
					elem,
					"olddisplay",
					defaultDisplay( elem.nodeName )
				);
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				dataPriv.set(
					elem,
					"olddisplay",
					hidden ? display : jQuery.css( elem, "display" )
				);
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
					elem.offsetWidth === 0 ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show
				// and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = dataPriv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done( function() {
				jQuery( elem ).hide();
			} );
		}
		anim.done( function() {
			var prop;

			dataPriv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		} );
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnotwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
		opt.duration : opt.duration in jQuery.fx.speeds ?
			jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	window.clearInterval( timerId );

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {

					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							-1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




var rclass = /[\t\r\n\f]/g;

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnotwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + getClass( elem ) + " " ).replace( rclass, " " )
					.indexOf( className ) > -1
			) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace( rreturn, "" ) :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				// Support: IE<11
				// option.value not trimmed (#14858)
				return jQuery.trim( elem.value );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ?
								!option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true

				// Previously, `originalEvent: {}` was set here, so stopPropagation call
				// would not be triggered on donor event, since in our own
				// jQuery.event.stopPropagation function we had a check for existence of
				// originalEvent.stopPropagation method, so, consequently it would be a noop.
				//
				// But now, this "simulate" function is used only for events
				// for which stopPropagation() is noop, so there is no need for that anymore.
				//
				// For the compat branch though, guard for "click" and "submit"
				// events is still used, but was moved to jQuery.event.stopPropagation function
				// because `originalEvent` should point to the original event for the constancy
				// with other events and for more focused logic
			}
		);

		jQuery.event.trigger( e, null, elem );

		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome, Safari
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// The jqXHR state
			state = 0,

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {

								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE8-11+
			// IE throws exception if url is malformed, e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE8-11+
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );

				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapAll( html.call( this, i ) );
			} );
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function() {
		return this.parent().each( function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		} ).end();
	}
} );


jQuery.expr.filters.hidden = function( elem ) {
	return !jQuery.expr.filters.visible( elem );
};
jQuery.expr.filters.visible = function( elem ) {

	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	// Use OR instead of AND as the element is not visible if either is true
	// See tickets #10406 and #13132
	return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} ) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE9
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE9
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8+
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	// Stop scripts or inline event handlers from being executed immediately
	// by using document.implementation
	context = context || ( support.createHTMLDocument ?
		document.implementation.createHTMLDocument( "" ) :
		document );

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( self, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		box = elem.getBoundingClientRect();
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			// Subtract offsetParent scroll positions
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ) -
				offsetParent.scrollTop();
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true ) -
				offsetParent.scrollLeft();
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari<7-8+, Chrome<37-44+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},
	size: function() {
		return this.length;
	}
} );

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}



var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}

return jQuery;
}));

},{}],5:[function(require,module,exports){
/*!
 * Paper.js v0.9.25 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey
 * http://scratchdisk.com/ & http://jonathanpuckey.com/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Sun Oct 25 11:23:38 2015 +0100
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2013 Juerg Lehni
 * http://scratchdisk.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * http://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = new function(undefined) {

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,

		forEach = [].forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++)
				iter.call(bind, this[i], i, this);
		},

		forIn = function(iter, bind) {
			for (var i in this)
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
		},

		create = Object.create || function(proto) {
			return { __proto__: proto };
		},

		describe = Object.getOwnPropertyDescriptor || function(obj, name) {
			var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
			return get
					? { get: get, set: obj.__lookupSetter__(name),
						enumerable: true, configurable: true }
					: obj.hasOwnProperty(name)
						? { value: obj[name], enumerable: true,
							configurable: true, writable: true }
						: null;
		},

		_define = Object.defineProperty || function(obj, name, desc) {
			if ((desc.get || desc.set) && obj.__defineGetter__) {
				if (desc.get)
					obj.__defineGetter__(name, desc.get);
				if (desc.set)
					obj.__defineSetter__(name, desc.set);
			} else {
				obj[name] = desc.value;
			}
			return obj;
		},

		define = function(obj, name, desc) {
			delete obj[name];
			return _define(obj, name, desc);
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc && !val.base
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res))
					res = { value: res, writable: true };
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function each(obj, iter, bind) {
		if (obj)
			('length' in obj && !obj.getLength
					&& typeof obj.length === 'number'
				? forEach
				: forIn).call(obj, iter, bind = bind || obj);
		return bind;
	}

	function set(obj, props, exclude) {
		for (var key in props)
			if (props.hasOwnProperty(key) && !(exclude && exclude[key]))
				obj[key] = props[key];
		return obj;
	}

	return inject(function Base() {
		for (var i = 0, l = arguments.length; i < l; i++)
			set(this, arguments[i]);
	}, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, true, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor,
				proto;
			for (var i = 0, l = arguments.length; i < l; i++)
				if (ctor = arguments[i].initialize)
					break;
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			proto = ctor.prototype = create(this.prototype);
			define(proto, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this, true);
			if (arguments.length)
				this.inject.apply(ctor, arguments);
			ctor.base = base;
			return ctor;
		}
	}, true).inject({
		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src)
					inject(this, src, src.enumerable, src.beans, src.preserve);
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		set: function(props) {
			return set(this, props);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			each: each,
			create: create,
			define: define,
			describe: describe,
			set: set,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function(a, b) {
				return a !== undefined ? a : b;
			}
		}
	});
};

if (typeof module !== 'undefined')
	module.exports = Base;

Base.inject({
	toString: function() {
		return this._id != null
			?  (this._class || 'Object') + (this._name
				? " '" + this._name + "'"
				: ' @' + this._id)
			: '{ ' + Base.each(this, function(value, key) {
				if (!/^_/.test(key)) {
					var type = typeof value;
					this.push(key + ': ' + (type === 'number'
							? Formatter.instance.number(value)
							: type === 'string' ? "'" + value + "'" : value));
				}
			}, []).join(', ') + ' }';
	},

	getClassName: function() {
		return this._class || '';
	},

	exportJSON: function(options) {
		return Base.exportJSON(this, options);
	},

	toJSON: function() {
		return Base.serialize(this);
	},

	_set: function(props, exclude, dontCheck) {
		if (props && (dontCheck || Base.isPlainObject(props))) {
			var keys = Object.keys(props._filtering || props);
			for (var i = 0, l = keys.length; i < l; i++) {
				var key = keys[i];
				if (!(exclude && exclude[key])) {
					var value = props[key];
					if (value !== undefined)
						this[key] = value;
				}
			}
			return true;
		}
	},

	statics: {

		exports: {
			enumerable: true
		},

		extend: function extend() {
			var res = extend.base.apply(this, arguments),
				name = res.prototype._class;
			if (name && !Base.exports[name])
				Base.exports[name] = res;
			return res;
		},

		equals: function(obj1, obj2) {
			if (obj1 === obj2)
				return true;
			if (obj1 && obj1.equals)
				return obj1.equals(obj2);
			if (obj2 && obj2.equals)
				return obj2.equals(obj1);
			if (obj1 && obj2
					&& typeof obj1 === 'object' && typeof obj2 === 'object') {
				if (Array.isArray(obj1) && Array.isArray(obj2)) {
					var length = obj1.length;
					if (length !== obj2.length)
						return false;
					while (length--) {
						if (!Base.equals(obj1[length], obj2[length]))
							return false;
					}
				} else {
					var keys = Object.keys(obj1),
						length = keys.length;
					if (length !== Object.keys(obj2).length)
						return false;
					while (length--) {
						var key = keys[length];
						if (!(obj2.hasOwnProperty(key)
								&& Base.equals(obj1[key], obj2[key])))
							return false;
					}
				}
				return true;
			}
			return false;
		},

		read: function(list, start, options, length) {
			if (this === Base) {
				var value = this.peek(list, start);
				list.__index++;
				return value;
			}
			var proto = this.prototype,
				readIndex = proto._readIndex,
				index = start || readIndex && list.__index || 0;
			if (!length)
				length = list.length - index;
			var obj = list[index];
			if (obj instanceof this
				|| options && options.readNull && obj == null && length <= 1) {
				if (readIndex)
					list.__index = index + 1;
				return obj && options && options.clone ? obj.clone() : obj;
			}
			obj = Base.create(this.prototype);
			if (readIndex)
				obj.__read = true;
			obj = obj.initialize.apply(obj, index > 0 || length < list.length
				? Array.prototype.slice.call(list, index, index + length)
				: list) || obj;
			if (readIndex) {
				list.__index = index + obj.__read;
				obj.__read = undefined;
			}
			return obj;
		},

		peek: function(list, start) {
			return list[list.__index = start || list.__index || 0];
		},

		remain: function(list) {
			return list.length - (list.__index || 0);
		},

		readAll: function(list, start, options) {
			var res = [],
				entry;
			for (var i = start || 0, l = list.length; i < l; i++) {
				res.push(Array.isArray(entry = list[i])
						? this.read(entry, 0, options)
						: this.read(list, i, options, 1));
			}
			return res;
		},

		readNamed: function(list, name, start, options, length) {
			var value = this.getNamed(list, name),
				hasObject = value !== undefined;
			if (hasObject) {
				var filtered = list._filtered;
				if (!filtered) {
					filtered = list._filtered = Base.create(list[0]);
					filtered._filtering = list[0];
				}
				filtered[name] = undefined;
			}
			return this.read(hasObject ? [value] : list, start, options, length);
		},

		getNamed: function(list, name) {
			var arg = list[0];
			if (list._hasObject === undefined)
				list._hasObject = list.length === 1 && Base.isPlainObject(arg);
			if (list._hasObject)
				return name ? arg[name] : list._filtered || arg;
		},

		hasNamed: function(list, name) {
			return !!this.getNamed(list, name);
		},

		isPlainValue: function(obj, asString) {
			return this.isPlainObject(obj) || Array.isArray(obj)
					|| asString && typeof obj === 'string';
		},

		serialize: function(obj, options, compact, dictionary) {
			options = options || {};

			var root = !dictionary,
				res;
			if (root) {
				options.formatter = new Formatter(options.precision);
				dictionary = {
					length: 0,
					definitions: {},
					references: {},
					add: function(item, create) {
						var id = '#' + item._id,
							ref = this.references[id];
						if (!ref) {
							this.length++;
							var res = create.call(item),
								name = item._class;
							if (name && res[0] !== name)
								res.unshift(name);
							this.definitions[id] = res;
							ref = this.references[id] = [id];
						}
						return ref;
					}
				};
			}
			if (obj && obj._serialize) {
				res = obj._serialize(options, dictionary);
				var name = obj._class;
				if (name && !compact && !res._compact && res[0] !== name)
					res.unshift(name);
			} else if (Array.isArray(obj)) {
				res = [];
				for (var i = 0, l = obj.length; i < l; i++)
					res[i] = Base.serialize(obj[i], options, compact,
							dictionary);
				if (compact)
					res._compact = true;
			} else if (Base.isPlainObject(obj)) {
				res = {};
				var keys = Object.keys(obj);
				for (var i = 0, l = keys.length; i < l; i++) {
					var key = keys[i];
					res[key] = Base.serialize(obj[key], options, compact,
							dictionary);
				}
			} else if (typeof obj === 'number') {
				res = options.formatter.number(obj, options.precision);
			} else {
				res = obj;
			}
			return root && dictionary.length > 0
					? [['dictionary', dictionary.definitions], res]
					: res;
		},

		deserialize: function(json, create, _data, _isDictionary) {
			var res = json,
				isRoot = !_data;
			_data = _data || {};
			if (Array.isArray(json)) {
				var type = json[0],
					isDictionary = type === 'dictionary';
				if (json.length == 1 && /^#/.test(type))
					return _data.dictionary[type];
				type = Base.exports[type];
				res = [];
				if (_isDictionary)
					_data.dictionary = res;
				for (var i = type ? 1 : 0, l = json.length; i < l; i++)
					res.push(Base.deserialize(json[i], create, _data,
							isDictionary));
				if (type) {
					var args = res;
					if (create) {
						res = create(type, args);
					} else {
						res = Base.create(type.prototype);
						type.apply(res, args);
					}
				}
			} else if (Base.isPlainObject(json)) {
				res = {};
				if (_isDictionary)
					_data.dictionary = res;
				for (var key in json)
					res[key] = Base.deserialize(json[key], create, _data);
			}
			return isRoot && json && json.length && json[0][0] === 'dictionary'
					? res[1]
					: res;
		},

		exportJSON: function(obj, options) {
			var json = Base.serialize(obj, options);
			return options && options.asString === false
					? json
					: JSON.stringify(json);
		},

		importJSON: function(json, target) {
			return Base.deserialize(
					typeof json === 'string' ? JSON.parse(json) : json,
					function(type, args) {
						var obj = target && target.constructor === type
								? target
								: Base.create(type.prototype),
							isTarget = obj === target;
						if (args.length === 1 && obj instanceof Item
								&& (isTarget || !(obj instanceof Layer))) {
							var arg = args[0];
							if (Base.isPlainObject(arg))
								arg.insert = false;
						}
						type.apply(obj, args);
						if (isTarget)
							target = null;
						return obj;
					});
		},

		splice: function(list, items, index, remove) {
			var amount = items && items.length,
				append = index === undefined;
			index = append ? list.length : index;
			if (index > list.length)
				index = list.length;
			for (var i = 0; i < amount; i++)
				items[i]._index = index + i;
			if (append) {
				list.push.apply(list, items);
				return [];
			} else {
				var args = [index, remove];
				if (items)
					args.push.apply(args, items);
				var removed = list.splice.apply(list, args);
				for (var i = 0, l = removed.length; i < l; i++)
					removed[i]._index = undefined;
				for (var i = index + amount, l = list.length; i < l; i++)
					list[i]._index = i;
				return removed;
			}
		},

		capitalize: function(str) {
			return str.replace(/\b[a-z]/g, function(match) {
				return match.toUpperCase();
			});
		},

		camelize: function(str) {
			return str.replace(/-(.)/g, function(all, chr) {
				return chr.toUpperCase();
			});
		},

		hyphenate: function(str) {
			return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
		}
	}
});

var Emitter = {
	on: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.on(key, value);
			}, this);
		} else {
			var types = this._eventTypes,
				entry = types && types[type],
				handlers = this._callbacks = this._callbacks || {};
			handlers = handlers[type] = handlers[type] || [];
			if (handlers.indexOf(func) === -1) {
				handlers.push(func);
				if (entry && entry.install && handlers.length === 1)
					entry.install.call(this, type);
			}
		}
		return this;
	},

	off: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.off(key, value);
			}, this);
			return;
		}
		var types = this._eventTypes,
			entry = types && types[type],
			handlers = this._callbacks && this._callbacks[type],
			index;
		if (handlers) {
			if (!func || (index = handlers.indexOf(func)) !== -1
					&& handlers.length === 1) {
				if (entry && entry.uninstall)
					entry.uninstall.call(this, type);
				delete this._callbacks[type];
			} else if (index !== -1) {
				handlers.splice(index, 1);
			}
		}
		return this;
	},

	once: function(type, func) {
		return this.on(type, function() {
			func.apply(this, arguments);
			this.off(type, func);
		});
	},

	emit: function(type, event) {
		var handlers = this._callbacks && this._callbacks[type];
		if (!handlers)
			return false;
		var args = [].slice.call(arguments, 1);
		handlers = handlers.slice();
		for (var i = 0, l = handlers.length; i < l; i++) {
			if (handlers[i].apply(this, args) === false) {
				if (event && event.stop)
					event.stop();
				break;
			}
		}
		return true;
	},

	responds: function(type) {
		return !!(this._callbacks && this._callbacks[type]);
	},

	attach: '#on',
	detach: '#off',
	fire: '#emit',

	_installEvents: function(install) {
		var handlers = this._callbacks,
			key = install ? 'install' : 'uninstall';
		for (var type in handlers) {
			if (handlers[type].length > 0) {
				var types = this._eventTypes,
					entry = types && types[type],
					func = entry && entry[key];
				if (func)
					func.call(this, type);
			}
		}
	},

	statics: {
		inject: function inject(src) {
			var events = src._events;
			if (events) {
				var types = {};
				Base.each(events, function(entry, key) {
					var isString = typeof entry === 'string',
						name = isString ? entry : key,
						part = Base.capitalize(name),
						type = name.substring(2).toLowerCase();
					types[type] = isString ? {} : entry;
					name = '_' + name;
					src['get' + part] = function() {
						return this[name];
					};
					src['set' + part] = function(func) {
						var prev = this[name];
						if (prev)
							this.off(type, prev);
						if (func)
							this.on(type, func);
						this[name] = func;
					};
				});
				src._eventTypes = types;
			}
			return inject.base.apply(this, arguments);
		}
	}
};

var PaperScope = Base.extend({
	_class: 'PaperScope',

	initialize: function PaperScope() {
		paper = this;
		this.settings = new Base({
			applyMatrix: true,
			handleSize: 4,
			hitTolerance: 0
		});
		this.project = null;
		this.projects = [];
		this.tools = [];
		this.palettes = [];
		this._id = PaperScope._id++;
		PaperScope._scopes[this._id] = this;
		var proto = PaperScope.prototype;
		if (!this.support) {
			var ctx = CanvasProvider.getContext(1, 1);
			proto.support = {
				nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
				nativeBlendModes: BlendMode.nativeModes
			};
			CanvasProvider.release(ctx);
		}

		if (!this.browser) {
			var agent = navigator.userAgent.toLowerCase(),
				platform = (/(win)/.exec(agent)
						|| /(mac)/.exec(agent)
						|| /(linux)/.exec(agent)
						|| [])[0],
				browser = proto.browser = { platform: platform };
			if (platform)
				browser[platform] = true;
			agent.replace(
				/(opera|chrome|safari|webkit|firefox|msie|trident|atom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:([.\d]+))?/g,
				function(all, n, v1, v2, rv) {
					if (!browser.chrome) {
						var v = n === 'opera' ? v2 : v1;
						if (n === 'trident') {
							v = rv;
							n = 'msie';
						}
						browser.version = v;
						browser.versionNumber = parseFloat(v);
						browser.name = n;
						browser[n] = true;
					}
				}
			);
			if (browser.chrome)
				delete browser.webkit;
			if (browser.atom)
				delete browser.chrome;
		}
	},

	version: "0.9.25",

	getView: function() {
		return this.project && this.project.getView();
	},

	getPaper: function() {
		return this;
	},

	execute: function(code, url, options) {
		paper.PaperScript.execute(code, this, url, options);
		View.updateFocus();
	},

	install: function(scope) {
		var that = this;
		Base.each(['project', 'view', 'tool'], function(key) {
			Base.define(scope, key, {
				configurable: true,
				get: function() {
					return that[key];
				}
			});
		});
		for (var key in this)
			if (!/^_/.test(key) && this[key])
				scope[key] = this[key];
	},

	setup: function(element) {
		paper = this;
		this.project = new Project(element);
		return this;
	},

	activate: function() {
		paper = this;
	},

	clear: function() {
		for (var i = this.projects.length - 1; i >= 0; i--)
			this.projects[i].remove();
		for (var i = this.tools.length - 1; i >= 0; i--)
			this.tools[i].remove();
		for (var i = this.palettes.length - 1; i >= 0; i--)
			this.palettes[i].remove();
	},

	remove: function() {
		this.clear();
		delete PaperScope._scopes[this._id];
	},

	statics: new function() {
		function handleAttribute(name) {
			name += 'Attribute';
			return function(el, attr) {
				return el[name](attr) || el[name]('data-paper-' + attr);
			};
		}

		return {
			_scopes: {},
			_id: 0,

			get: function(id) {
				return this._scopes[id] || null;
			},

			getAttribute: handleAttribute('get'),
			hasAttribute: handleAttribute('has')
		};
	}
});

var PaperScopeItem = Base.extend(Emitter, {

	initialize: function(activate) {
		this._scope = paper;
		this._index = this._scope[this._list].push(this) - 1;
		if (activate || !this._scope[this._reference])
			this.activate();
	},

	activate: function() {
		if (!this._scope)
			return false;
		var prev = this._scope[this._reference];
		if (prev && prev !== this)
			prev.emit('deactivate');
		this._scope[this._reference] = this;
		this.emit('activate', prev);
		return true;
	},

	isActive: function() {
		return this._scope[this._reference] === this;
	},

	remove: function() {
		if (this._index == null)
			return false;
		Base.splice(this._scope[this._list], null, this._index, 1);
		if (this._scope[this._reference] == this)
			this._scope[this._reference] = null;
		this._scope = null;
		return true;
	}
});

var Formatter = Base.extend({
	initialize: function(precision) {
		this.precision = precision || 5;
		this.multiplier = Math.pow(10, this.precision);
	},

	number: function(val) {
		return Math.round(val * this.multiplier) / this.multiplier;
	},

	pair: function(val1, val2, separator) {
		return this.number(val1) + (separator || ',') + this.number(val2);
	},

	point: function(val, separator) {
		return this.number(val.x) + (separator || ',') + this.number(val.y);
	},

	size: function(val, separator) {
		return this.number(val.width) + (separator || ',')
				+ this.number(val.height);
	},

	rectangle: function(val, separator) {
		return this.point(val, separator) + (separator || ',')
				+ this.size(val, separator);
	}
});

Formatter.instance = new Formatter();

var Numerical = new function() {

	var abscissas = [
		[  0.5773502691896257645091488],
		[0,0.7745966692414833770358531],
		[  0.3399810435848562648026658,0.8611363115940525752239465],
		[0,0.5384693101056830910363144,0.9061798459386639927976269],
		[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
		[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
		[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
		[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
		[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
		[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
		[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
		[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
		[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
		[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
		[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
	];

	var weights = [
		[1],
		[0.8888888888888888888888889,0.5555555555555555555555556],
		[0.6521451548625461426269361,0.3478548451374538573730639],
		[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
		[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
		[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
		[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
		[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
		[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
		[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
		[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
		[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
		[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
		[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
		[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
	];

	var abs = Math.abs,
		sqrt = Math.sqrt,
		pow = Math.pow,
		EPSILON = 1e-12,
		MACHINE_EPSILON = 1.12e-16;

	function clip(value, min, max) {
		return value < min ? min : value > max ? max : value;
	}

	return {
		TOLERANCE: 1e-6,
		EPSILON: EPSILON,
		MACHINE_EPSILON: MACHINE_EPSILON,
		CURVETIME_EPSILON: 4e-7,
		GEOMETRIC_EPSILON: 2e-7,
		WINDING_EPSILON: 2e-7,
		TRIGONOMETRIC_EPSILON: 1e-7,
		CLIPPING_EPSILON: 1e-7,
		KAPPA: 4 * (sqrt(2) - 1) / 3,

		isZero: function(val) {
			return val >= -EPSILON && val <= EPSILON;
		},

		integrate: function(f, a, b, n) {
			var x = abscissas[n - 2],
				w = weights[n - 2],
				A = (b - a) * 0.5,
				B = A + a,
				i = 0,
				m = (n + 1) >> 1,
				sum = n & 1 ? w[i++] * f(B) : 0;
			while (i < m) {
				var Ax = A * x[i];
				sum += w[i++] * (f(B + Ax) + f(B - Ax));
			}
			return A * sum;
		},

		findRoot: function(f, df, x, a, b, n, tolerance) {
			for (var i = 0; i < n; i++) {
				var fx = f(x),
					dx = fx / df(x),
					nx = x - dx;
				if (abs(dx) < tolerance)
					return nx;
				if (fx > 0) {
					b = x;
					x = nx <= a ? (a + b) * 0.5 : nx;
				} else {
					a = x;
					x = nx >= b ? (a + b) * 0.5 : nx;
				}
			}
			return x;
		},

		solveQuadratic: function(a, b, c, roots, min, max) {
			var count = 0,
				eMin = min - EPSILON,
				eMax = max + EPSILON,
				x1, x2 = Infinity,
				B = b,
				D;
			b /= -2;
			D = b * b - a * c;
			if (D !== 0 && abs(D) < MACHINE_EPSILON) {
				var gmC = pow(abs(a * b * c), 1 / 3);
				if (gmC < 1e-8) {
					var mult = pow(10,
							abs(Math.floor(Math.log(gmC) * Math.LOG10E)));
					if (!isFinite(mult))
						mult = 0;
					a *= mult;
					b *= mult;
					c *= mult;
					D = b * b - a * c;
				}
			}
			if (abs(a) < EPSILON) {
				if (abs(B) < EPSILON)
					return abs(c) < EPSILON ? -1 : 0;
				x1 = -c / B;
			} else if (D >= -MACHINE_EPSILON) {
				var Q = D < 0 ? 0 : sqrt(D),
					R = b + (b < 0 ? -Q : Q);
				if (R === 0) {
					x1 = c / a;
					x2 = -x1;
				} else {
					x1 = R / a;
					x2 = c / R;
				}
			}
			if (isFinite(x1) && (min == null || x1 > eMin && x1 < eMax))
				roots[count++] = min == null ? x1 : clip(x1, min, max);
			if (x2 !== x1
					&& isFinite(x2) && (min == null || x2 > eMin && x2 < eMax))
				roots[count++] = min == null ? x2 : clip(x2, min, max);
			return count;
		},

		solveCubic: function(a, b, c, d, roots, min, max) {
			var count = 0,
				x, b1, c2;
			if (abs(a) < EPSILON) {
				a = b;
				b1 = c;
				c2 = d;
				x = Infinity;
			} else if (abs(d) < EPSILON) {
				b1 = b;
				c2 = c;
				x = 0;
			} else {
				var ec = 1 + MACHINE_EPSILON,
					x0, q, qd, t, r, s, tmp;
				x = -(b / a) / 3;
				tmp = a * x,
				b1 = tmp + b,
				c2 = b1 * x + c,
				qd = (tmp + b1) * x + c2,
				q = c2 * x + d;
				t = q /a;
				r = pow(abs(t), 1/3);
				s = t < 0 ? -1 : 1;
				t = -qd / a;
				r = t > 0 ? 1.3247179572 * Math.max(r, sqrt(t)) : r;
				x0 = x - s * r;
				if (x0 !== x) {
					do {
						x = x0;
						tmp = a * x,
						b1 = tmp + b,
						c2 = b1 * x + c,
						qd = (tmp + b1) * x + c2,
						q = c2 * x + d;
						x0 = qd === 0 ? x : x - q / qd / ec;
						if (x0 === x) {
							x = x0;
							break;
						}
					} while (s * x0 > s * x);
					if (abs(a) * x * x > abs(d / x)) {
						c2 = -d / x;
						b1 = (c2 - c) / x;
					}
				}
			}
			var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max);
			if (isFinite(x) && (count === 0 || x !== roots[count - 1])
					&& (min == null || x > min - EPSILON && x < max + EPSILON))
				roots[count++] = min == null ? x : clip(x, min, max);
			return count;
		}
	};
};

var UID = {
	_id: 1,
	_pools: {},

	get: function(ctor) {
		if (ctor) {
			var name = ctor._class,
				pool = this._pools[name];
			if (!pool)
				pool = this._pools[name] = { _id: 1 };
			return pool._id++;
		} else {
			return this._id++;
		}
	}
};

var Point = Base.extend({
	_class: 'Point',
	_readIndex: true,

	initialize: function Point(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasY = typeof arg1 === 'number';
			this.x = arg0;
			this.y = hasY ? arg1 : arg0;
			if (this.__read)
				this.__read = hasY ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.x != null) {
				this.x = arg0.x;
				this.y = arg0.y;
			} else if (arg0.width != null) {
				this.x = arg0.width;
				this.y = arg0.height;
			} else if (arg0.angle != null) {
				this.x = arg0.length;
				this.y = 0;
				this.setAngle(arg0.angle);
			} else {
				this.x = this.y = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	equals: function(point) {
		return this === point || point
				&& (this.x === point.x && this.y === point.y
					|| Array.isArray(point)
						&& this.x === point[0] && this.y === point[1])
				|| false;
	},

	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x), f.number(this.y)];
	},

	getLength: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	setLength: function(length) {
		if (this.isZero()) {
			var angle = this._angle || 0;
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		} else {
			var scale = length / this.getLength();
			if (Numerical.isZero(scale))
				this.getAngle();
			this.set(
				this.x * scale,
				this.y * scale
			);
		}
	},
	getAngle: function() {
		return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
	},

	setAngle: function(angle) {
		this.setAngleInRadians.call(this, angle * Math.PI / 180);
	},

	getAngleInDegrees: '#getAngle',
	setAngleInDegrees: '#setAngle',

	getAngleInRadians: function() {
		if (!arguments.length) {
			return this.isZero()
					? this._angle || 0
					: this._angle = Math.atan2(this.y, this.x);
		} else {
			var point = Point.read(arguments),
				div = this.getLength() * point.getLength();
			if (Numerical.isZero(div)) {
				return NaN;
			} else {
				var a = this.dot(point) / div;
				return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
			}
		}
	},

	setAngleInRadians: function(angle) {
		this._angle = angle;
		if (!this.isZero()) {
			var length = this.getLength();
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		}
	},

	getQuadrant: function() {
		return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
	}
}, {
	beans: false,

	getDirectedAngle: function() {
		var point = Point.read(arguments);
		return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
	},

	getDistance: function() {
		var point = Point.read(arguments),
			x = point.x - this.x,
			y = point.y - this.y,
			d = x * x + y * y,
			squared = Base.read(arguments);
		return squared ? d : Math.sqrt(d);
	},

	normalize: function(length) {
		if (length === undefined)
			length = 1;
		var current = this.getLength(),
			scale = current !== 0 ? length / current : 0,
			point = new Point(this.x * scale, this.y * scale);
		if (scale >= 0)
			point._angle = this._angle;
		return point;
	},

	rotate: function(angle, center) {
		if (angle === 0)
			return this.clone();
		angle = angle * Math.PI / 180;
		var point = center ? this.subtract(center) : this,
			sin = Math.sin(angle),
			cos = Math.cos(angle);
		point = new Point(
			point.x * cos - point.y * sin,
			point.x * sin + point.y * cos
		);
		return center ? point.add(center) : point;
	},

	transform: function(matrix) {
		return matrix ? matrix._transformPoint(this) : this;
	},

	add: function() {
		var point = Point.read(arguments);
		return new Point(this.x + point.x, this.y + point.y);
	},

	subtract: function() {
		var point = Point.read(arguments);
		return new Point(this.x - point.x, this.y - point.y);
	},

	multiply: function() {
		var point = Point.read(arguments);
		return new Point(this.x * point.x, this.y * point.y);
	},

	divide: function() {
		var point = Point.read(arguments);
		return new Point(this.x / point.x, this.y / point.y);
	},

	modulo: function() {
		var point = Point.read(arguments);
		return new Point(this.x % point.x, this.y % point.y);
	},

	negate: function() {
		return new Point(-this.x, -this.y);
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this);
	},

	isClose: function() {
		var point = Point.read(arguments),
			tolerance = Base.read(arguments);
		return this.getDistance(point) < tolerance;
	},

	isCollinear: function() {
		var point = Point.read(arguments);
		return Point.isCollinear(this.x, this.y, point.x, point.y);
	},

	isColinear: '#isCollinear',

	isOrthogonal: function() {
		var point = Point.read(arguments);
		return Point.isOrthogonal(this.x, this.y, point.x, point.y);
	},

	isZero: function() {
		return Numerical.isZero(this.x) && Numerical.isZero(this.y);
	},

	isNaN: function() {
		return isNaN(this.x) || isNaN(this.y);
	},

	dot: function() {
		var point = Point.read(arguments);
		return this.x * point.x + this.y * point.y;
	},

	cross: function() {
		var point = Point.read(arguments);
		return this.x * point.y - this.y * point.x;
	},

	project: function() {
		var point = Point.read(arguments),
			scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
		return new Point(
			point.x * scale,
			point.y * scale
		);
	},

	statics: {
		min: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.min(point1.x, point2.x),
				Math.min(point1.y, point2.y)
			);
		},

		max: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.max(point1.x, point2.x),
				Math.max(point1.y, point2.y)
			);
		},

		random: function() {
			return new Point(Math.random(), Math.random());
		},

		isCollinear: function(x1, y1, x2, y2) {
			return Math.abs(x1 * y2 - y1 * x2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-7;
		},

		isOrthogonal: function(x1, y1, x2, y2) {
			return Math.abs(x1 * x2 + y1 * y2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-7;
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Point(op(this.x), op(this.y));
	};
}, {}));

var LinkedPoint = Point.extend({
	initialize: function Point(x, y, owner, setter) {
		this._x = x;
		this._y = y;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, _dontNotify) {
		this._x = x;
		this._y = y;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner[this._setter](this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner[this._setter](this);
	}
});

var Size = Base.extend({
	_class: 'Size',
	_readIndex: true,

	initialize: function Size(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasHeight = typeof arg1 === 'number';
			this.width = arg0;
			this.height = hasHeight ? arg1 : arg0;
			if (this.__read)
				this.__read = hasHeight ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.width = this.height = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.width = arg0[0];
				this.height = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.width != null) {
				this.width = arg0.width;
				this.height = arg0.height;
			} else if (arg0.x != null) {
				this.width = arg0.x;
				this.height = arg0.y;
			} else {
				this.width = this.height = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},

	equals: function(size) {
		return size === this || size && (this.width === size.width
				&& this.height === size.height
				|| Array.isArray(size) && this.width === size[0]
					&& this.height === size[1]) || false;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.width),
				f.number(this.height)];
	},

	add: function() {
		var size = Size.read(arguments);
		return new Size(this.width + size.width, this.height + size.height);
	},

	subtract: function() {
		var size = Size.read(arguments);
		return new Size(this.width - size.width, this.height - size.height);
	},

	multiply: function() {
		var size = Size.read(arguments);
		return new Size(this.width * size.width, this.height * size.height);
	},

	divide: function() {
		var size = Size.read(arguments);
		return new Size(this.width / size.width, this.height / size.height);
	},

	modulo: function() {
		var size = Size.read(arguments);
		return new Size(this.width % size.width, this.height % size.height);
	},

	negate: function() {
		return new Size(-this.width, -this.height);
	},

	isZero: function() {
		return Numerical.isZero(this.width) && Numerical.isZero(this.height);
	},

	isNaN: function() {
		return isNaN(this.width) || isNaN(this.height);
	},

	statics: {
		min: function(size1, size2) {
			return new Size(
				Math.min(size1.width, size2.width),
				Math.min(size1.height, size2.height));
		},

		max: function(size1, size2) {
			return new Size(
				Math.max(size1.width, size2.width),
				Math.max(size1.height, size2.height));
		},

		random: function() {
			return new Size(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Size(op(this.width), op(this.height));
	};
}, {}));

var LinkedSize = Size.extend({
	initialize: function Size(width, height, owner, setter) {
		this._width = width;
		this._height = height;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(width, height, _dontNotify) {
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getWidth: function() {
		return this._width;
	},

	setWidth: function(width) {
		this._width = width;
		this._owner[this._setter](this);
	},

	getHeight: function() {
		return this._height;
	},

	setHeight: function(height) {
		this._height = height;
		this._owner[this._setter](this);
	}
});

var Rectangle = Base.extend({
	_class: 'Rectangle',
	_readIndex: true,
	beans: true,

	initialize: function Rectangle(arg0, arg1, arg2, arg3) {
		var type = typeof arg0,
			read = 0;
		if (type === 'number') {
			this.x = arg0;
			this.y = arg1;
			this.width = arg2;
			this.height = arg3;
			read = 4;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = this.width = this.height = 0;
			read = arg0 === null ? 1 : 0;
		} else if (arguments.length === 1) {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0[1];
				this.width = arg0[2];
				this.height = arg0[3];
				read = 1;
			} else if (arg0.x !== undefined || arg0.width !== undefined) {
				this.x = arg0.x || 0;
				this.y = arg0.y || 0;
				this.width = arg0.width || 0;
				this.height = arg0.height || 0;
				read = 1;
			} else if (arg0.from === undefined && arg0.to === undefined) {
				this.x = this.y = this.width = this.height = 0;
				this._set(arg0);
				read = 1;
			}
		}
		if (!read) {
			var point = Point.readNamed(arguments, 'from'),
				next = Base.peek(arguments);
			this.x = point.x;
			this.y = point.y;
			if (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {
				var to = Point.readNamed(arguments, 'to');
				this.width = to.x - point.x;
				this.height = to.y - point.y;
				if (this.width < 0) {
					this.x = to.x;
					this.width = -this.width;
				}
				if (this.height < 0) {
					this.y = to.y;
					this.height = -this.height;
				}
			} else {
				var size = Size.read(arguments);
				this.width = size.width;
				this.height = size.height;
			}
			read = arguments.__index;
		}
		if (this.__read)
			this.__read = read;
	},

	set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},

	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},

	equals: function(rect) {
		var rt = Base.isPlainValue(rect)
				? Rectangle.read(arguments)
				: rect;
		return rt === this
				|| rt && this.x === rt.x && this.y === rt.y
					&& this.width === rt.width && this.height === rt.height
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x)
				+ ', y: ' + f.number(this.y)
				+ ', width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height)
				+ ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x),
				f.number(this.y),
				f.number(this.width),
				f.number(this.height)];
	},

	getPoint: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.x, this.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.x = point.x;
		this.y = point.y;
	},

	getSize: function(_dontLink) {
		var ctor = _dontLink ? Size : LinkedSize;
		return new ctor(this.width, this.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (this._fixX)
			this.x += (this.width - size.width) * this._fixX;
		if (this._fixY)
			this.y += (this.height - size.height) * this._fixY;
		this.width = size.width;
		this.height = size.height;
		this._fixW = 1;
		this._fixH = 1;
	},

	getLeft: function() {
		return this.x;
	},

	setLeft: function(left) {
		if (!this._fixW)
			this.width -= left - this.x;
		this.x = left;
		this._fixX = 0;
	},

	getTop: function() {
		return this.y;
	},

	setTop: function(top) {
		if (!this._fixH)
			this.height -= top - this.y;
		this.y = top;
		this._fixY = 0;
	},

	getRight: function() {
		return this.x + this.width;
	},

	setRight: function(right) {
		if (this._fixX !== undefined && this._fixX !== 1)
			this._fixW = 0;
		if (this._fixW)
			this.x = right - this.width;
		else
			this.width = right - this.x;
		this._fixX = 1;
	},

	getBottom: function() {
		return this.y + this.height;
	},

	setBottom: function(bottom) {
		if (this._fixY !== undefined && this._fixY !== 1)
			this._fixH = 0;
		if (this._fixH)
			this.y = bottom - this.height;
		else
			this.height = bottom - this.y;
		this._fixY = 1;
	},

	getCenterX: function() {
		return this.x + this.width * 0.5;
	},

	setCenterX: function(x) {
		this.x = x - this.width * 0.5;
		this._fixX = 0.5;
	},

	getCenterY: function() {
		return this.y + this.height * 0.5;
	},

	setCenterY: function(y) {
		this.y = y - this.height * 0.5;
		this._fixY = 0.5;
	},

	getCenter: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
	},

	setCenter: function() {
		var point = Point.read(arguments);
		this.setCenterX(point.x);
		this.setCenterY(point.y);
		return this;
	},

	getArea: function() {
		return this.width * this.height;
	},

	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},

	contains: function(arg) {
		return arg && arg.width !== undefined
				|| (Array.isArray(arg) ? arg : arguments).length == 4
				? this._containsRectangle(Rectangle.read(arguments))
				: this._containsPoint(Point.read(arguments));
	},

	_containsPoint: function(point) {
		var x = point.x,
			y = point.y;
		return x >= this.x && y >= this.y
				&& x <= this.x + this.width
				&& y <= this.y + this.height;
	},

	_containsRectangle: function(rect) {
		var x = rect.x,
			y = rect.y;
		return x >= this.x && y >= this.y
				&& x + rect.width <= this.x + this.width
				&& y + rect.height <= this.y + this.height;
	},

	intersects: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width > this.x
				&& rect.y + rect.height > this.y
				&& rect.x < this.x + this.width
				&& rect.y < this.y + this.height;
	},

	touches: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width >= this.x
				&& rect.y + rect.height >= this.y
				&& rect.x <= this.x + this.width
				&& rect.y <= this.y + this.height;
	},

	intersect: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.max(this.x, rect.x),
			y1 = Math.max(this.y, rect.y),
			x2 = Math.min(this.x + this.width, rect.x + rect.width),
			y2 = Math.min(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	unite: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.min(this.x, rect.x),
			y1 = Math.min(this.y, rect.y),
			x2 = Math.max(this.x + this.width, rect.x + rect.width),
			y2 = Math.max(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	include: function() {
		var point = Point.read(arguments);
		var x1 = Math.min(this.x, point.x),
			y1 = Math.min(this.y, point.y),
			x2 = Math.max(this.x + this.width, point.x),
			y2 = Math.max(this.y + this.height, point.y);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	expand: function() {
		var amount = Size.read(arguments),
			hor = amount.width,
			ver = amount.height;
		return new Rectangle(this.x - hor / 2, this.y - ver / 2,
				this.width + hor, this.height + ver);
	},

	scale: function(hor, ver) {
		return this.expand(this.width * hor - this.width,
				this.height * (ver === undefined ? hor : ver) - this.height);
	}
}, Base.each([
		['Top', 'Left'], ['Top', 'Right'],
		['Bottom', 'Left'], ['Bottom', 'Right'],
		['Left', 'Center'], ['Top', 'Center'],
		['Right', 'Center'], ['Bottom', 'Center']
	],
	function(parts, index) {
		var part = parts.join('');
		var xFirst = /^[RL]/.test(part);
		if (index >= 4)
			parts[1] += xFirst ? 'Y' : 'X';
		var x = parts[xFirst ? 0 : 1],
			y = parts[xFirst ? 1 : 0],
			getX = 'get' + x,
			getY = 'get' + y,
			setX = 'set' + x,
			setY = 'set' + y,
			get = 'get' + part,
			set = 'set' + part;
		this[get] = function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this[getX](), this[getY](), this, set);
		};
		this[set] = function() {
			var point = Point.read(arguments);
			this[setX](point.x);
			this[setY](point.y);
		};
	}, {
		beans: true
	}
));

var LinkedRectangle = Rectangle.extend({
	initialize: function Rectangle(x, y, width, height, owner, setter) {
		this.set(x, y, width, height, true);
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, width, height, _dontNotify) {
		this._x = x;
		this._y = y;
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	}
},
new function() {
	var proto = Rectangle.prototype;

	return Base.each(['x', 'y', 'width', 'height'], function(key) {
		var part = Base.capitalize(key);
		var internal = '_' + key;
		this['get' + part] = function() {
			return this[internal];
		};

		this['set' + part] = function(value) {
			this[internal] = value;
			if (!this._dontNotify)
				this._owner[this._setter](this);
		};
	}, Base.each(['Point', 'Size', 'Center',
			'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
			'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
			'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
		function(key) {
			var name = 'set' + key;
			this[name] = function() {
				this._dontNotify = true;
				proto[name].apply(this, arguments);
				this._dontNotify = false;
				this._owner[this._setter](this);
			};
		}, {
			isSelected: function() {
				return this._owner._boundsSelected;
			},

			setSelected: function(selected) {
				var owner = this._owner;
				if (owner.setSelected) {
					owner._boundsSelected = selected;
					owner.setSelected(selected || owner._selectedSegmentState > 0);
				}
			}
		})
	);
});

var Matrix = Base.extend({
	_class: 'Matrix',

	initialize: function Matrix(arg) {
		var count = arguments.length,
			ok = true;
		if (count === 6) {
			this.set.apply(this, arguments);
		} else if (count === 1) {
			if (arg instanceof Matrix) {
				this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);
			} else if (Array.isArray(arg)) {
				this.set.apply(this, arg);
			} else {
				ok = false;
			}
		} else if (count === 0) {
			this.reset();
		} else {
			ok = false;
		}
		if (!ok)
			throw new Error('Unsupported matrix parameters');
	},

	set: function(a, c, b, d, tx, ty, _dontNotify) {
		this._a = a;
		this._c = c;
		this._b = b;
		this._d = d;
		this._tx = tx;
		this._ty = ty;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	_serialize: function(options) {
		return Base.serialize(this.getValues(), options);
	},

	_changed: function() {
		var owner = this._owner;
		if (owner) {
			if (owner._applyMatrix) {
				owner.transform(null, true);
			} else {
				owner._changed(9);
			}
		}
	},

	clone: function() {
		return new Matrix(this._a, this._c, this._b, this._d,
				this._tx, this._ty);
	},

	equals: function(mx) {
		return mx === this || mx && this._a === mx._a && this._b === mx._b
				&& this._c === mx._c && this._d === mx._d
				&& this._tx === mx._tx && this._ty === mx._ty
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '[[' + [f.number(this._a), f.number(this._b),
					f.number(this._tx)].join(', ') + '], ['
				+ [f.number(this._c), f.number(this._d),
					f.number(this._ty)].join(', ') + ']]';
	},

	reset: function(_dontNotify) {
		this._a = this._d = 1;
		this._c = this._b = this._tx = this._ty = 0;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	apply: function(recursively, _setApplyMatrix) {
		var owner = this._owner;
		if (owner) {
			owner.transform(null, true, Base.pick(recursively, true),
					_setApplyMatrix);
			return this.isIdentity();
		}
		return false;
	},

	translate: function() {
		var point = Point.read(arguments),
			x = point.x,
			y = point.y;
		this._tx += x * this._a + y * this._b;
		this._ty += x * this._c + y * this._d;
		this._changed();
		return this;
	},

	scale: function() {
		var scale = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		this._a *= scale.x;
		this._c *= scale.x;
		this._b *= scale.y;
		this._d *= scale.y;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	rotate: function(angle ) {
		angle *= Math.PI / 180;
		var center = Point.read(arguments, 1),
			x = center.x,
			y = center.y,
			cos = Math.cos(angle),
			sin = Math.sin(angle),
			tx = x - x * cos + y * sin,
			ty = y - x * sin - y * cos,
			a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = cos * a + sin * b;
		this._b = -sin * a + cos * b;
		this._c = cos * c + sin * d;
		this._d = -sin * c + cos * d;
		this._tx += tx * a + ty * b;
		this._ty += tx * c + ty * d;
		this._changed();
		return this;
	},

	shear: function() {
		var shear = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		var a = this._a,
			c = this._c;
		this._a += shear.y * this._b;
		this._c += shear.y * this._d;
		this._b += shear.x * a;
		this._d += shear.x * c;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	skew: function() {
		var skew = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true }),
			toRadians = Math.PI / 180,
			shear = new Point(Math.tan(skew.x * toRadians),
				Math.tan(skew.y * toRadians));
		return this.shear(shear, center);
	},

	concatenate: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		this._a = a2 * a1 + c2 * b1;
		this._b = b2 * a1 + d2 * b1;
		this._c = a2 * c1 + c2 * d1;
		this._d = b2 * c1 + d2 * d1;
		this._tx += tx2 * a1 + ty2 * b1;
		this._ty += tx2 * c1 + ty2 * d1;
		this._changed();
		return this;
	},

	preConcatenate: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			tx1 = this._tx,
			ty1 = this._ty,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		this._a = a2 * a1 + b2 * c1;
		this._b = a2 * b1 + b2 * d1;
		this._c = c2 * a1 + d2 * c1;
		this._d = c2 * b1 + d2 * d1;
		this._tx = a2 * tx1 + b2 * ty1 + tx2;
		this._ty = c2 * tx1 + d2 * ty1 + ty2;
		this._changed();
		return this;
	},

	chain: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			tx1 = this._tx,
			ty1 = this._ty,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		return new Matrix(
				a2 * a1 + c2 * b1,
				a2 * c1 + c2 * d1,
				b2 * a1 + d2 * b1,
				b2 * c1 + d2 * d1,
				tx1 + tx2 * a1 + ty2 * b1,
				ty1 + tx2 * c1 + ty2 * d1);
	},

	isIdentity: function() {
		return this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1
				&& this._tx === 0 && this._ty === 0;
	},

	orNullIfIdentity: function() {
		return this.isIdentity() ? null : this;
	},

	isInvertible: function() {
		return !!this._getDeterminant();
	},

	isSingular: function() {
		return !this._getDeterminant();
	},

	transform: function( src, dst, count) {
		return arguments.length < 3
			? this._transformPoint(Point.read(arguments))
			: this._transformCoordinates(src, dst, count);
	},

	_transformPoint: function(point, dest, _dontNotify) {
		var x = point.x,
			y = point.y;
		if (!dest)
			dest = new Point();
		return dest.set(
			x * this._a + y * this._b + this._tx,
			x * this._c + y * this._d + this._ty,
			_dontNotify
		);
	},

	_transformCoordinates: function(src, dst, count) {
		var i = 0,
			j = 0,
			max = 2 * count;
		while (i < max) {
			var x = src[i++],
				y = src[i++];
			dst[j++] = x * this._a + y * this._b + this._tx;
			dst[j++] = x * this._c + y * this._d + this._ty;
		}
		return dst;
	},

	_transformCorners: function(rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height,
			coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
		return this._transformCoordinates(coords, coords, 4);
	},

	_transformBounds: function(bounds, dest, _dontNotify) {
		var coords = this._transformCorners(bounds),
			min = coords.slice(0, 2),
			max = min.slice();
		for (var i = 2; i < 8; i++) {
			var val = coords[i],
				j = i & 1;
			if (val < min[j])
				min[j] = val;
			else if (val > max[j])
				max[j] = val;
		}
		if (!dest)
			dest = new Rectangle();
		return dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],
				_dontNotify);
	},

	inverseTransform: function() {
		return this._inverseTransform(Point.read(arguments));
	},

	_getDeterminant: function() {
		var det = this._a * this._d - this._b * this._c;
		return isFinite(det) && !Numerical.isZero(det)
				&& isFinite(this._tx) && isFinite(this._ty)
				? det : null;
	},

	_inverseTransform: function(point, dest, _dontNotify) {
		var det = this._getDeterminant();
		if (!det)
			return null;
		var x = point.x - this._tx,
			y = point.y - this._ty;
		if (!dest)
			dest = new Point();
		return dest.set(
			(x * this._d - y * this._b) / det,
			(y * this._a - x * this._c) / det,
			_dontNotify
		);
	},

	decompose: function() {
		var a = this._a, b = this._b, c = this._c, d = this._d;
		if (Numerical.isZero(a * d - b * c))
			return null;

		var scaleX = Math.sqrt(a * a + b * b);
		a /= scaleX;
		b /= scaleX;

		var shear = a * c + b * d;
		c -= a * shear;
		d -= b * shear;

		var scaleY = Math.sqrt(c * c + d * d);
		c /= scaleY;
		d /= scaleY;
		shear /= scaleY;

		if (a * d < b * c) {
			a = -a;
			b = -b;
			shear = -shear;
			scaleX = -scaleX;
		}

		return {
			scaling: new Point(scaleX, scaleY),
			rotation: -Math.atan2(b, a) * 180 / Math.PI,
			shearing: shear
		};
	},

	getValues: function() {
		return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
	},

	getTranslation: function() {
		return new Point(this._tx, this._ty);
	},

	getScaling: function() {
		return (this.decompose() || {}).scaling;
	},

	getRotation: function() {
		return (this.decompose() || {}).rotation;
	},

	inverted: function() {
		var det = this._getDeterminant();
		return det && new Matrix(
				this._d / det,
				-this._c / det,
				-this._b / det,
				this._a / det,
				(this._b * this._ty - this._d * this._tx) / det,
				(this._c * this._tx - this._a * this._ty) / det);
	},

	shiftless: function() {
		return new Matrix(this._a, this._c, this._b, this._d, 0, 0);
	},

	applyToContext: function(ctx) {
		ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
	}
}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {
	var part = Base.capitalize(name),
		prop = '_' + name;
	this['get' + part] = function() {
		return this[prop];
	};
	this['set' + part] = function(value) {
		this[prop] = value;
		this._changed();
	};
}, {}));

var Line = Base.extend({
	_class: 'Line',

	initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
		var asVector = false;
		if (arguments.length >= 4) {
			this._px = arg0;
			this._py = arg1;
			this._vx = arg2;
			this._vy = arg3;
			asVector = arg4;
		} else {
			this._px = arg0.x;
			this._py = arg0.y;
			this._vx = arg1.x;
			this._vy = arg1.y;
			asVector = arg2;
		}
		if (!asVector) {
			this._vx -= this._px;
			this._vy -= this._py;
		}
	},

	getPoint: function() {
		return new Point(this._px, this._py);
	},

	getVector: function() {
		return new Point(this._vx, this._vy);
	},

	getLength: function() {
		return this.getVector().getLength();
	},

	intersect: function(line, isInfinite) {
		return Line.intersect(
				this._px, this._py, this._vx, this._vy,
				line._px, line._py, line._vx, line._vy,
				true, isInfinite);
	},

	getSide: function(point, isInfinite) {
		return Line.getSide(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true, isInfinite);
	},

	getDistance: function(point) {
		return Math.abs(Line.getSignedDistance(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true));
	},

	isCollinear: function(line) {
		return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
	},

	isOrthogonal: function(line) {
		return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
	},

	statics: {
		intersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,
				isInfinite) {
			if (!asVector) {
				v1x -= p1x;
				v1y -= p1y;
				v2x -= p2x;
				v2y -= p2y;
			}
			var cross = v1x * v2y - v1y * v2x;
			if (!Numerical.isZero(cross)) {
				var dx = p1x - p2x,
					dy = p1y - p2y,
					u1 = (v2x * dy - v2y * dx) / cross,
					u2 = (v1x * dy - v1y * dx) / cross,
					epsilon = 1e-12,
					uMin = -epsilon,
					uMax = 1 + epsilon;
				if (isInfinite
						|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
					if (!isInfinite) {
						u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
					}
					return new Point(
							p1x + u1 * v1x,
							p1y + u1 * v1y);
				}
			}
		},

		getSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var v2x = x - px,
				v2y = y - py,
				ccw = v2x * vy - v2y * vx;
			if (ccw === 0 && !isInfinite) {
				ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
				if (ccw >= 0 && ccw <= 1)
					ccw = 0;
			}
			return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
		},

		getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			return vx === 0 ? vy > 0 ? x - px : px - x
				 : vy === 0 ? vx < 0 ? y - py : py - y
				 : ((x-px) * vy - (y-py) * vx) / Math.sqrt(vx * vx + vy * vy);
		}
	}
});

var Project = PaperScopeItem.extend({
	_class: 'Project',
	_list: 'projects',
	_reference: 'project',

	initialize: function Project(element) {
		PaperScopeItem.call(this, true);
		this.layers = [];
		this._activeLayer = null;
		this.symbols = [];
		this._currentStyle = new Style(null, null, this);
		this._view = View.create(this,
				element || CanvasProvider.getCanvas(1, 1));
		this._selectedItems = {};
		this._selectedItemCount = 0;
		this._updateVersion = 0;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.layers, options, true, dictionary);
	},

	clear: function() {
		for (var i = this.layers.length - 1; i >= 0; i--)
			this.layers[i].remove();
		this.symbols = [];
	},

	isEmpty: function() {
		return this.layers.length === 0;
	},

	remove: function remove() {
		if (!remove.base.call(this))
			return false;
		if (this._view)
			this._view.remove();
		return true;
	},

	getView: function() {
		return this._view;
	},

	getCurrentStyle: function() {
		return this._currentStyle;
	},

	setCurrentStyle: function(style) {
		this._currentStyle.initialize(style);
	},

	getIndex: function() {
		return this._index;
	},

	getOptions: function() {
		return this._scope.settings;
	},

	getActiveLayer: function() {
		return this._activeLayer || new Layer({ project: this });
	},

	getSelectedItems: function() {
		var items = [];
		for (var id in this._selectedItems) {
			var item = this._selectedItems[id];
			if (item.isInserted())
				items.push(item);
		}
		return items;
	},

	insertChild: function(index, item, _preserve) {
		if (item instanceof Layer) {
			item._remove(false, true);
			Base.splice(this.layers, [item], index, 0);
			item._setProject(this, true);
			if (this._changes)
				item._changed(5);
			if (!this._activeLayer)
				this._activeLayer = item;
		} else if (item instanceof Item) {
			(this._activeLayer
				|| this.insertChild(index, new Layer(Item.NO_INSERT)))
					.insertChild(index, item, _preserve);
		} else {
			item = null;
		}
		return item;
	},

	addChild: function(item, _preserve) {
		return this.insertChild(undefined, item, _preserve);
	},

	_updateSelection: function(item) {
		var id = item._id,
			selectedItems = this._selectedItems;
		if (item._selected) {
			if (selectedItems[id] !== item) {
				this._selectedItemCount++;
				selectedItems[id] = item;
			}
		} else if (selectedItems[id] === item) {
			this._selectedItemCount--;
			delete selectedItems[id];
		}
	},

	selectAll: function() {
		var layers = this.layers;
		for (var i = 0, l = layers.length; i < l; i++)
			layers[i].setFullySelected(true);
	},

	deselectAll: function() {
		var selectedItems = this._selectedItems;
		for (var i in selectedItems)
			selectedItems[i].setFullySelected(false);
	},

	hitTest: function() {
		var point = Point.read(arguments),
			options = HitResult.getOptions(Base.read(arguments));
		for (var i = this.layers.length - 1; i >= 0; i--) {
			var res = this.layers[i]._hitTest(point, options);
			if (res) return res;
		}
		return null;
	},

	getItems: function(match) {
		return Item._getItems(this.layers, match);
	},

	getItem: function(match) {
		return Item._getItems(this.layers, match, null, null, true)[0] || null;
	},

	importJSON: function(json) {
		this.activate();
		var layer = this._activeLayer;
		return Base.importJSON(json, layer && layer.isEmpty() && layer);
	},

	draw: function(ctx, matrix, pixelRatio) {
		this._updateVersion++;
		ctx.save();
		matrix.applyToContext(ctx);
		var param = new Base({
			offset: new Point(0, 0),
			pixelRatio: pixelRatio,
			viewMatrix: matrix.isIdentity() ? null : matrix,
			matrices: [new Matrix()],
			updateMatrix: true
		});
		for (var i = 0, layers = this.layers, l = layers.length; i < l; i++)
			layers[i].draw(ctx, param);
		ctx.restore();

		if (this._selectedItemCount > 0) {
			ctx.save();
			ctx.strokeWidth = 1;
			var items = this._selectedItems,
				size = this._scope.settings.handleSize,
				version = this._updateVersion;
			for (var id in items)
				items[id]._drawSelection(ctx, matrix, size, items, version);
			ctx.restore();
		}
	}
});

var Symbol = Base.extend({
	_class: 'Symbol',

	initialize: function Symbol(item, dontCenter) {
		this._id = UID.get();
		this.project = paper.project;
		this.project.symbols.push(this);
		if (item)
			this.setDefinition(item, dontCenter);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._class, this._definition],
					options, false, dictionary);
		});
	},

	_changed: function(flags) {
		if (flags & 8) {
			Item._clearBoundsCache(this);
		}
		if (flags & 1) {
			this.project._needsUpdate = true;
		}
	},

	getDefinition: function() {
		return this._definition;
	},

	setDefinition: function(item, _dontCenter) {
		if (item._parentSymbol)
			item = item.clone();
		if (this._definition)
			this._definition._parentSymbol = null;
		this._definition = item;
		item.remove();
		item.setSelected(false);
		if (!_dontCenter)
			item.setPosition(new Point());
		item._parentSymbol = this;
		this._changed(9);
	},

	place: function(position) {
		return new PlacedSymbol(this, position);
	},

	clone: function() {
		return new Symbol(this._definition.clone(false));
	},

	equals: function(symbol) {
		return symbol === this
				|| symbol && this.definition.equals(symbol.definition)
				|| false;
	}
});

var Item = Base.extend(Emitter, {
	statics: {
		extend: function extend(src) {
			if (src._serializeFields)
				src._serializeFields = new Base(
						this.prototype._serializeFields, src._serializeFields);
			return extend.base.apply(this, arguments);
		},

		NO_INSERT: { insert: false }
	},

	_class: 'Item',
	_applyMatrix: true,
	_canApplyMatrix: true,
	_boundsSelected: false,
	_selectChildren: false,
	_serializeFields: {
		name: null,
		applyMatrix: null,
		matrix: new Matrix(),
		pivot: null,
		locked: false,
		visible: true,
		blendMode: 'normal',
		opacity: 1,
		guide: false,
		selected: false,
		clipMask: false,
		data: {}
	},

	initialize: function Item() {
	},

	_initialize: function(props, point) {
		var hasProps = props && Base.isPlainObject(props),
			internal = hasProps && props.internal === true,
			matrix = this._matrix = new Matrix(),
			project = hasProps && props.project || paper.project;
		if (!internal)
			this._id = UID.get();
		this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;
		if (point)
			matrix.translate(point);
		matrix._owner = this;
		this._style = new Style(project._currentStyle, this, project);
		if (!this._project) {
			if (internal || hasProps && props.insert === false) {
				this._setProject(project);
			} else if (hasProps && props.parent) {
				this.setParent(props.parent);
			} else {
				(project._activeLayer || new Layer()).addChild(this);
			}
		}
		if (hasProps && props !== Item.NO_INSERT)
			this._set(props, { insert: true, project: true, parent: true },
					true);
		return hasProps;
	},

	_events: Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
			'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],
		function(name) {
			this[name] = {
				install: function(type) {
					this.getView()._installEvent(type);
				},

				uninstall: function(type) {
					this.getView()._uninstallEvent(type);
				}
			};
		}, {
			onFrame: {
				install: function() {
					this.getView()._animateItem(this, true);
				},

				uninstall: function() {
					this.getView()._animateItem(this, false);
				}
			},

			onLoad: {}
		}
	),

	_serialize: function(options, dictionary) {
		var props = {},
			that = this;

		function serialize(fields) {
			for (var key in fields) {
				var value = that[key];
				if (!Base.equals(value, key === 'leading'
						? fields.fontSize * 1.2 : fields[key])) {
					props[key] = Base.serialize(value, options,
							key !== 'data', dictionary);
				}
			}
		}

		serialize(this._serializeFields);
		if (!(this instanceof Group))
			serialize(this._style._defaults);
		return [ this._class, props ];
	},

	_changed: function(flags) {
		var symbol = this._parentSymbol,
			cacheParent = this._parent || symbol,
			project = this._project;
		if (flags & 8) {
			this._bounds = this._position = this._decomposed =
					this._globalMatrix = this._currentPath = undefined;
		}
		if (cacheParent
				&& (flags & 40)) {
			Item._clearBoundsCache(cacheParent);
		}
		if (flags & 2) {
			Item._clearBoundsCache(this);
		}
		if (project) {
			if (flags & 1) {
				project._needsUpdate = true;
			}
			if (project._changes) {
				var entry = project._changesById[this._id];
				if (entry) {
					entry.flags |= flags;
				} else {
					entry = { item: this, flags: flags };
					project._changesById[this._id] = entry;
					project._changes.push(entry);
				}
			}
		}
		if (symbol)
			symbol._changed(flags);
	},

	set: function(props) {
		if (props)
			this._set(props);
		return this;
	},

	getId: function() {
		return this._id;
	},

	getName: function() {
		return this._name;
	},

	setName: function(name, unique) {

		if (this._name)
			this._removeNamed();
		if (name === (+name) + '')
			throw new Error(
					'Names consisting only of numbers are not supported.');
		var parent = this._parent;
		if (name && parent) {
			var children = parent._children,
				namedChildren = parent._namedChildren,
				orig = name,
				i = 1;
			while (unique && children[name])
				name = orig + ' ' + (i++);
			(namedChildren[name] = namedChildren[name] || []).push(this);
			children[name] = this;
		}
		this._name = name || undefined;
		this._changed(128);
	},

	getStyle: function() {
		return this._style;
	},

	setStyle: function(style) {
		this.getStyle().set(style);
	}
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
	function(name) {
		var part = Base.capitalize(name),
			name = '_' + name;
		this['get' + part] = function() {
			return this[name];
		};
		this['set' + part] = function(value) {
			if (value != this[name]) {
				this[name] = value;
				this._changed(name === '_locked'
						? 128 : 129);
			}
		};
	},
{}), {
	beans: true,

	_locked: false,

	_visible: true,

	_blendMode: 'normal',

	_opacity: 1,

	_guide: false,

	isSelected: function() {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				if (children[i].isSelected())
					return true;
		}
		return this._selected;
	},

	setSelected: function(selected, noChildren) {
		if (!noChildren && this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setSelected(selected);
		}
		if ((selected = !!selected) ^ this._selected) {
			this._selected = selected;
			this._project._updateSelection(this);
			this._changed(129);
		}
	},

	_selected: false,

	isFullySelected: function() {
		var children = this._children;
		if (children && this._selected) {
			for (var i = 0, l = children.length; i < l; i++)
				if (!children[i].isFullySelected())
					return false;
			return true;
		}
		return this._selected;
	},

	setFullySelected: function(selected) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setFullySelected(selected);
		}
		this.setSelected(selected, true);
	},

	isClipMask: function() {
		return this._clipMask;
	},

	setClipMask: function(clipMask) {
		if (this._clipMask != (clipMask = !!clipMask)) {
			this._clipMask = clipMask;
			if (clipMask) {
				this.setFillColor(null);
				this.setStrokeColor(null);
			}
			this._changed(129);
			if (this._parent)
				this._parent._changed(1024);
		}
	},

	_clipMask: false,

	getData: function() {
		if (!this._data)
			this._data = {};
		return this._data;
	},

	setData: function(data) {
		this._data = data;
	},

	getPosition: function(_dontLink) {
		var position = this._position,
			ctor = _dontLink ? Point : LinkedPoint;
		if (!position) {
			var pivot = this._pivot;
			position = this._position = pivot
					? this._matrix._transformPoint(pivot)
					: this.getBounds().getCenter(true);
		}
		return new ctor(position.x, position.y, this, 'setPosition');
	},

	setPosition: function() {
		this.translate(Point.read(arguments).subtract(this.getPosition(true)));
	},

	getPivot: function(_dontLink) {
		var pivot = this._pivot;
		if (pivot) {
			var ctor = _dontLink ? Point : LinkedPoint;
			pivot = new ctor(pivot.x, pivot.y, this, 'setPivot');
		}
		return pivot;
	},

	setPivot: function() {
		this._pivot = Point.read(arguments, 0, { clone: true, readNull: true });
		this._position = undefined;
	},

	_pivot: null,
}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',
		'internalBounds', 'internalRoughBounds'],
	function(key) {
		var getter = 'get' + Base.capitalize(key),
			match = key.match(/^internal(.*)$/),
			internalGetter = match ? 'get' + match[1] : null;
		this[getter] = function(_matrix) {
			var boundsGetter = this._boundsGetter,
				name = !internalGetter && (typeof boundsGetter === 'string'
						? boundsGetter : boundsGetter && boundsGetter[getter])
						|| getter,
				bounds = this._getCachedBounds(name, _matrix, this,
						internalGetter);
			return key === 'bounds'
					? new LinkedRectangle(bounds.x, bounds.y, bounds.width,
							bounds.height, this, 'setBounds')
					: bounds;
		};
	},
{
	beans: true,

	_getBounds: function(getter, matrix, cacheItem) {
		var children = this._children;
		if (!children || children.length == 0)
			return new Rectangle();
		Item._updateBoundsCache(this, cacheItem);
		var x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			if (child._visible && !child.isEmpty()) {
				var rect = child._getCachedBounds(getter,
						matrix && matrix.chain(child._matrix), cacheItem);
				x1 = Math.min(rect.x, x1);
				y1 = Math.min(rect.y, y1);
				x2 = Math.max(rect.x + rect.width, x2);
				y2 = Math.max(rect.y + rect.height, y2);
			}
		}
		return isFinite(x1)
				? new Rectangle(x1, y1, x2 - x1, y2 - y1)
				: new Rectangle();
	},

	setBounds: function() {
		var rect = Rectangle.read(arguments),
			bounds = this.getBounds(),
			matrix = new Matrix(),
			center = rect.getCenter();
		matrix.translate(center);
		if (rect.width != bounds.width || rect.height != bounds.height) {
			matrix.scale(
					bounds.width != 0 ? rect.width / bounds.width : 1,
					bounds.height != 0 ? rect.height / bounds.height : 1);
		}
		center = bounds.getCenter();
		matrix.translate(-center.x, -center.y);
		this.transform(matrix);
	},

	_getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {
		matrix = matrix && matrix.orNullIfIdentity();
		var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),
			cache = (!matrix || matrix.equals(_matrix)) && getter;
		Item._updateBoundsCache(this._parent || this._parentSymbol, cacheItem);
		if (cache && this._bounds && this._bounds[cache])
			return this._bounds[cache].clone();
		var bounds = this._getBounds(internalGetter || getter,
				matrix || _matrix, cacheItem);
		if (cache) {
			if (!this._bounds)
				this._bounds = {};
			var cached = this._bounds[cache] = bounds.clone();
			cached._internal = !!internalGetter;
		}
		return bounds;
	},

	statics: {
		_updateBoundsCache: function(parent, item) {
			if (parent) {
				var id = item._id,
					ref = parent._boundsCache = parent._boundsCache || {
						ids: {},
						list: []
					};
				if (!ref.ids[id]) {
					ref.list.push(item);
					ref.ids[id] = item;
				}
			}
		},

		_clearBoundsCache: function(item) {
			var cache = item._boundsCache;
			if (cache) {
				item._bounds = item._position = item._boundsCache = undefined;
				for (var i = 0, list = cache.list, l = list.length; i < l; i++){
					var other = list[i];
					if (other !== item) {
						other._bounds = other._position = undefined;
						if (other._boundsCache)
							Item._clearBoundsCache(other);
					}
				}
			}
		}
	}

}), {
	beans: true,

	_decompose: function() {
		return this._decomposed = this._matrix.decompose();
	},

	getRotation: function() {
		var decomposed = this._decomposed || this._decompose();
		return decomposed && decomposed.rotation;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			var decomposed = this._decomposed;
			this.rotate(rotation - current);
			decomposed.rotation = rotation;
			this._decomposed = decomposed;
		}
	},

	getScaling: function(_dontLink) {
		var decomposed = this._decomposed || this._decompose(),
			scaling = decomposed && decomposed.scaling,
			ctor = _dontLink ? Point : LinkedPoint;
		return scaling && new ctor(scaling.x, scaling.y, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling();
		if (current) {
			var scaling = Point.read(arguments, 0, { clone: true }),
				decomposed = this._decomposed;
			this.scale(scaling.x / current.x, scaling.y / current.y);
			decomposed.scaling = scaling;
			this._decomposed = decomposed;
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function() {
		var matrix = this._matrix;
		matrix.initialize.apply(matrix, arguments);
		if (this._applyMatrix) {
			this.transform(null, true);
		} else {
			this._changed(9);
		}
	},

	getGlobalMatrix: function(_dontClone) {
		var matrix = this._globalMatrix,
			updateVersion = this._project._updateVersion;
		if (matrix && matrix._updateVersion !== updateVersion)
			matrix = null;
		if (!matrix) {
			matrix = this._globalMatrix = this._matrix.clone();
			var parent = this._parent;
			if (parent)
				matrix.preConcatenate(parent.getGlobalMatrix(true));
			matrix._updateVersion = updateVersion;
		}
		return _dontClone ? matrix : matrix.clone();
	},

	getApplyMatrix: function() {
		return this._applyMatrix;
	},

	setApplyMatrix: function(apply) {
		if (this._applyMatrix = this._canApplyMatrix && !!apply)
			this.transform(null, true);
	},

	getTransformContent: '#getApplyMatrix',
	setTransformContent: '#setApplyMatrix',
}, {
	getProject: function() {
		return this._project;
	},

	_setProject: function(project, installEvents) {
		if (this._project !== project) {
			if (this._project)
				this._installEvents(false);
			this._project = project;
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._setProject(project);
			installEvents = true;
		}
		if (installEvents)
			this._installEvents(true);
	},

	getView: function() {
		return this._project.getView();
	},

	_installEvents: function _installEvents(install) {
		_installEvents.base.call(this, install);
		var children = this._children;
		for (var i = 0, l = children && children.length; i < l; i++)
			children[i]._installEvents(install);
	},

	getLayer: function() {
		var parent = this;
		while (parent = parent._parent) {
			if (parent instanceof Layer)
				return parent;
		}
		return null;
	},

	getParent: function() {
		return this._parent;
	},

	setParent: function(item) {
		return item.addChild(this);
	},

	getChildren: function() {
		return this._children;
	},

	setChildren: function(items) {
		this.removeChildren();
		this.addChildren(items);
	},

	getFirstChild: function() {
		return this._children && this._children[0] || null;
	},

	getLastChild: function() {
		return this._children && this._children[this._children.length - 1]
				|| null;
	},

	getNextSibling: function() {
		return this._parent && this._parent._children[this._index + 1] || null;
	},

	getPreviousSibling: function() {
		return this._parent && this._parent._children[this._index - 1] || null;
	},

	getIndex: function() {
		return this._index;
	},

	equals: function(item) {
		return item === this || item && this._class === item._class
				&& this._style.equals(item._style)
				&& this._matrix.equals(item._matrix)
				&& this._locked === item._locked
				&& this._visible === item._visible
				&& this._blendMode === item._blendMode
				&& this._opacity === item._opacity
				&& this._clipMask === item._clipMask
				&& this._guide === item._guide
				&& this._equals(item)
				|| false;
	},

	_equals: function(item) {
		return Base.equals(this._children, item._children);
	},

	clone: function(insert) {
		return this._clone(new this.constructor(Item.NO_INSERT), insert);
	},

	_clone: function(copy, insert, includeMatrix) {
		var keys = ['_locked', '_visible', '_blendMode', '_opacity',
				'_clipMask', '_guide'],
			children = this._children;
		copy.setStyle(this._style);
		for (var i = 0, l = children && children.length; i < l; i++) {
			copy.addChild(children[i].clone(false), true);
		}
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];
			if (this.hasOwnProperty(key))
				copy[key] = this[key];
		}
		if (includeMatrix !== false)
			copy._matrix.initialize(this._matrix);
		copy.setApplyMatrix(this._applyMatrix);
		copy.setPivot(this._pivot);
		copy.setSelected(this._selected);
		copy._data = this._data ? Base.clone(this._data) : null;
		if (insert || insert === undefined)
			copy.insertAbove(this);
		if (this._name)
			copy.setName(this._name, true);
		return copy;
	},

	copyTo: function(itemOrProject) {
		return itemOrProject.addChild(this.clone(false));
	},

	rasterize: function(resolution) {
		var bounds = this.getStrokeBounds(),
			scale = (resolution || this.getView().getResolution()) / 72,
			topLeft = bounds.getTopLeft().floor(),
			bottomRight = bounds.getBottomRight().ceil(),
			size = new Size(bottomRight.subtract(topLeft)),
			canvas = CanvasProvider.getCanvas(size.multiply(scale)),
			ctx = canvas.getContext('2d'),
			matrix = new Matrix().scale(scale).translate(topLeft.negate());
		ctx.save();
		matrix.applyToContext(ctx);
		this.draw(ctx, new Base({ matrices: [matrix] }));
		ctx.restore();
		var raster = new Raster(Item.NO_INSERT);
		raster.setCanvas(canvas);
		raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
				.scale(1 / scale));
		raster.insertAbove(this);
		return raster;
	},

	contains: function() {
		return !!this._contains(
				this._matrix._inverseTransform(Point.read(arguments)));
	},

	_contains: function(point) {
		if (this._children) {
			for (var i = this._children.length - 1; i >= 0; i--) {
				if (this._children[i].contains(point))
					return true;
			}
			return false;
		}
		return point.isInside(this.getInternalBounds());
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this.getBounds());
	},

	_asPathItem: function() {
		return new Path.Rectangle({
			rectangle: this.getInternalBounds(),
			matrix: this._matrix,
			insert: false,
		});
	},

	intersects: function(item, _matrix) {
		if (!(item instanceof Item))
			return false;
		return this._asPathItem().getIntersections(item._asPathItem(), null,
				_matrix || item._matrix, true).length > 0;
	},

	hitTest: function() {
		return this._hitTest(
				Point.read(arguments),
				HitResult.getOptions(Base.read(arguments)));
	},

	_hitTest: function(point, options) {
		if (this._locked || !this._visible || this._guide && !options.guides
				|| this.isEmpty())
			return null;

		var matrix = this._matrix,
			parentTotalMatrix = options._totalMatrix,
			view = this.getView(),
			totalMatrix = options._totalMatrix = parentTotalMatrix
					? parentTotalMatrix.chain(matrix)
					: this.getGlobalMatrix().preConcatenate(view._matrix),
			tolerancePadding = options._tolerancePadding = new Size(
						Path._getPenPadding(1, totalMatrix.inverted())
					).multiply(
						Math.max(options.tolerance, 1e-6)
					);
		point = matrix._inverseTransform(point);

		if (!this._children && !this.getInternalRoughBounds()
				.expand(tolerancePadding.multiply(2))._containsPoint(point))
			return null;
		var checkSelf = !(options.guides && !this._guide
				|| options.selected && !this._selected
				|| options.type && options.type !== Base.hyphenate(this._class)
				|| options.class && !(this instanceof options.class)),
			that = this,
			res;

		function checkBounds(type, part) {
			var pt = bounds['get' + part]();
			if (point.subtract(pt).divide(tolerancePadding).length <= 1)
				return new HitResult(type, that,
						{ name: Base.hyphenate(part), point: pt });
		}

		if (checkSelf && (options.center || options.bounds) && this._parent) {
			var bounds = this.getInternalBounds();
			if (options.center)
				res = checkBounds('center', 'Center');
			if (!res && options.bounds) {
				var points = [
					'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
					'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
				];
				for (var i = 0; i < 8 && !res; i++)
					res = checkBounds('bounds', points[i]);
			}
		}

		var children = !res && this._children;
		if (children) {
			var opts = this._getChildHitTestOptions(options);
			for (var i = children.length - 1; i >= 0 && !res; i--)
				res = children[i]._hitTest(point, opts);
		}
		if (!res && checkSelf)
			res = this._hitTestSelf(point, options);
		if (res && res.point)
			res.point = matrix.transform(res.point);
		options._totalMatrix = parentTotalMatrix;
		return res;
	},

	_getChildHitTestOptions: function(options) {
		return options;
	},

	_hitTestSelf: function(point, options) {
		if (options.fill && this.hasFill() && this._contains(point))
			return new HitResult('fill', this);
	},

	matches: function(name, compare) {
		function matchObject(obj1, obj2) {
			for (var i in obj1) {
				if (obj1.hasOwnProperty(i)) {
					var val1 = obj1[i],
						val2 = obj2[i];
					if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
						if (!matchObject(val1, val2))
							return false;
					} else if (!Base.equals(val1, val2)) {
						return false;
					}
				}
			}
			return true;
		}
		var type = typeof name;
		if (type === 'object') {
			for (var key in name) {
				if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
					return false;
			}
		} else if (type === 'function') {
			return name(this);
		} else {
			var value = /^(empty|editable)$/.test(name)
					? this['is' + Base.capitalize(name)]()
					: name === 'type'
						? Base.hyphenate(this._class)
						: this[name];
			if (/^(constructor|class)$/.test(name)) {
				if (!(this instanceof compare))
					return false;
			} else if (compare instanceof RegExp) {
				if (!compare.test(value))
					return false;
			} else if (typeof compare === 'function') {
				if (!compare(value))
					return false;
			} else if (Base.isPlainObject(compare)) {
				if (!matchObject(compare, value))
					return false;
			} else if (!Base.equals(value, compare)) {
				return false;
			}
		}
		return true;
	},

	getItems: function(match) {
		return Item._getItems(this._children, match, this._matrix);
	},

	getItem: function(match) {
		return Item._getItems(this._children, match, this._matrix, null, true)
				[0] || null;
	},

	statics: {
		_getItems: function _getItems(children, match, matrix, param,
				firstOnly) {
			if (!param && typeof match === 'object') {
				var overlapping = match.overlapping,
					inside = match.inside,
					bounds = overlapping || inside,
					rect = bounds && Rectangle.read([bounds]);
				param = {
					items: [],
					inside: !!inside,
					overlapping: !!overlapping,
					rect: rect,
					path: overlapping && new Path.Rectangle({
						rectangle: rect,
						insert: false
					})
				};
				if (bounds)
					match = Base.set({}, match,
							{ inside: true, overlapping: true });
			}
			var items = param && param.items,
				rect = param && param.rect;
			matrix = rect && (matrix || new Matrix());
			for (var i = 0, l = children && children.length; i < l; i++) {
				var child = children[i],
					childMatrix = matrix && matrix.chain(child._matrix),
					add = true;
				if (rect) {
					var bounds = child.getBounds(childMatrix);
					if (!rect.intersects(bounds))
						continue;
					if (!(param.inside && rect.contains(bounds))
							&& !(param.overlapping && (bounds.contains(rect)
								|| param.path.intersects(child, childMatrix))))
						add = false;
				}
				if (add && child.matches(match)) {
					items.push(child);
					if (firstOnly)
						break;
				}
				_getItems(child._children, match,
						childMatrix, param,
						firstOnly);
				if (firstOnly && items.length > 0)
					break;
			}
			return items;
		}
	}
}, {

	importJSON: function(json) {
		var res = Base.importJSON(json, this);
		return res !== this
				? this.addChild(res)
				: res;
	},

	addChild: function(item, _preserve) {
		return this.insertChild(undefined, item, _preserve);
	},

	insertChild: function(index, item, _preserve) {
		var res = item ? this.insertChildren(index, [item], _preserve) : null;
		return res && res[0];
	},

	addChildren: function(items, _preserve) {
		return this.insertChildren(this._children.length, items, _preserve);
	},

	insertChildren: function(index, items, _preserve, _proto) {
		var children = this._children;
		if (children && items && items.length > 0) {
			items = Array.prototype.slice.apply(items);
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i];
				if (_proto && !(item instanceof _proto)) {
					items.splice(i, 1);
				} else {
					var shift = item._parent === this && item._index < index;
					if (item._remove(false, true) && shift)
						index--;
				}
			}
			Base.splice(children, items, index, 0);
			var project = this._project,
				notifySelf = project && project._changes;
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i];
				item._parent = this;
				item._setProject(this._project, true);
				if (item._name)
					item.setName(item._name);
				if (notifySelf)
					this._changed(5);
			}
			this._changed(11);
		} else {
			items = null;
		}
		return items;
	},

	_insertSibling: function(index, item, _preserve) {
		return this._parent
				? this._parent.insertChild(index, item, _preserve)
				: null;
	},

	insertAbove: function(item, _preserve) {
		return item._insertSibling(item._index + 1, this, _preserve);
	},

	insertBelow: function(item, _preserve) {
		return item._insertSibling(item._index, this, _preserve);
	},

	sendToBack: function() {
		return (this._parent || this instanceof Layer && this._project)
				.insertChild(0, this);
	},

	bringToFront: function() {
		return (this._parent || this instanceof Layer && this._project)
				.addChild(this);
	},

	appendTop: '#addChild',

	appendBottom: function(item) {
		return this.insertChild(0, item);
	},

	moveAbove: '#insertAbove',

	moveBelow: '#insertBelow',

	reduce: function() {
		if (this._children && this._children.length === 1) {
			var child = this._children[0].reduce();
			child.insertAbove(this);
			child.setStyle(this._style);
			this.remove();
			return child;
		}
		return this;
	},

	_removeNamed: function() {
		var parent = this._parent;
		if (parent) {
			var children = parent._children,
				namedChildren = parent._namedChildren,
				name = this._name,
				namedArray = namedChildren[name],
				index = namedArray ? namedArray.indexOf(this) : -1;
			if (index !== -1) {
				if (children[name] == this)
					delete children[name];
				namedArray.splice(index, 1);
				if (namedArray.length) {
					children[name] = namedArray[namedArray.length - 1];
				} else {
					delete namedChildren[name];
				}
			}
		}
	},

	_remove: function(notifySelf, notifyParent) {
		var parent = this._parent;
		if (parent) {
			if (this._name)
				this._removeNamed();
			if (this._index != null)
				Base.splice(parent._children, null, this._index, 1);
			this._installEvents(false);
			if (notifySelf) {
				var project = this._project;
				if (project && project._changes)
					this._changed(5);
			}
			if (notifyParent)
				parent._changed(11);
			this._parent = null;
			return true;
		}
		return false;
	},

	remove: function() {
		return this._remove(true, true);
	},

	replaceWith: function(item) {
		var ok = item && item.insertBelow(this);
		if (ok)
			this.remove();
		return ok;
	},

	removeChildren: function(from, to) {
		if (!this._children)
			return null;
		from = from || 0;
		to = Base.pick(to, this._children.length);
		var removed = Base.splice(this._children, null, from, to - from);
		for (var i = removed.length - 1; i >= 0; i--) {
			removed[i]._remove(true, false);
		}
		if (removed.length > 0)
			this._changed(11);
		return removed;
	},

	clear: '#removeChildren',

	reverseChildren: function() {
		if (this._children) {
			this._children.reverse();
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i]._index = i;
			this._changed(11);
		}
	},

	isEmpty: function() {
		return !this._children || this._children.length === 0;
	},

	isEditable: function() {
		var item = this;
		while (item) {
			if (!item._visible || item._locked)
				return false;
			item = item._parent;
		}
		return true;
	},

	hasFill: function() {
		return this.getStyle().hasFill();
	},

	hasStroke: function() {
		return this.getStyle().hasStroke();
	},

	hasShadow: function() {
		return this.getStyle().hasShadow();
	},

	_getOrder: function(item) {
		function getList(item) {
			var list = [];
			do {
				list.unshift(item);
			} while (item = item._parent);
			return list;
		}
		var list1 = getList(this),
			list2 = getList(item);
		for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
			if (list1[i] != list2[i]) {
				return list1[i]._index < list2[i]._index ? 1 : -1;
			}
		}
		return 0;
	},

	hasChildren: function() {
		return this._children && this._children.length > 0;
	},

	isInserted: function() {
		return this._parent ? this._parent.isInserted() : false;
	},

	isAbove: function(item) {
		return this._getOrder(item) === -1;
	},

	isBelow: function(item) {
		return this._getOrder(item) === 1;
	},

	isParent: function(item) {
		return this._parent === item;
	},

	isChild: function(item) {
		return item && item._parent === this;
	},

	isDescendant: function(item) {
		var parent = this;
		while (parent = parent._parent) {
			if (parent == item)
				return true;
		}
		return false;
	},

	isAncestor: function(item) {
		return item ? item.isDescendant(this) : false;
	},

	isSibling: function(item) {
		return this._parent === item._parent;
	},

	isGroupedWith: function(item) {
		var parent = this._parent;
		while (parent) {
			if (parent._parent
				&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
				&& item.isDescendant(parent))
					return true;
			parent = parent._parent;
		}
		return false;
	},

	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	rotate: function(angle ) {
		return this.transform(new Matrix().rotate(angle,
				Point.read(arguments, 1, { readNull: true })
					|| this.getPosition(true)));
	}
}, Base.each(['scale', 'shear', 'skew'], function(name) {
	this[name] = function() {
		var point = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		return this.transform(new Matrix()[name](point,
				center || this.getPosition(true)));
	};
}, {

}), {
	transform: function(matrix, _applyMatrix, _applyRecursively,
			_setApplyMatrix) {
		if (matrix && matrix.isIdentity())
			matrix = null;
		var _matrix = this._matrix,
			applyMatrix = (_applyMatrix || this._applyMatrix)
					&& ((!_matrix.isIdentity() || matrix)
						|| _applyMatrix && _applyRecursively && this._children);
		if (!matrix && !applyMatrix)
			return this;
		if (matrix)
			_matrix.preConcatenate(matrix);
		if (applyMatrix = applyMatrix && this._transformContent(_matrix,
					_applyRecursively, _setApplyMatrix)) {
			var pivot = this._pivot,
				style = this._style,
				fillColor = style.getFillColor(true),
				strokeColor = style.getStrokeColor(true);
			if (pivot)
				_matrix._transformPoint(pivot, pivot, true);
			if (fillColor)
				fillColor.transform(_matrix);
			if (strokeColor)
				strokeColor.transform(_matrix);
			_matrix.reset(true);
			if (_setApplyMatrix && this._canApplyMatrix)
				this._applyMatrix = true;
		}
		var bounds = this._bounds,
			position = this._position;
		this._changed(9);
		var decomp = bounds && matrix && matrix.decompose();
		if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
			for (var key in bounds) {
				var rect = bounds[key];
				if (applyMatrix || !rect._internal)
					matrix._transformBounds(rect, rect);
			}
			var getter = this._boundsGetter,
				rect = bounds[getter && getter.getBounds || getter || 'getBounds'];
			if (rect)
				this._position = rect.getCenter(true);
			this._bounds = bounds;
		} else if (matrix && position) {
			this._position = matrix._transformPoint(position, position);
		}
		return this;
	},

	_transformContent: function(matrix, applyRecursively, setApplyMatrix) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].transform(matrix, true, applyRecursively,
						setApplyMatrix);
			return true;
		}
	},

	globalToLocal: function() {
		return this.getGlobalMatrix(true)._inverseTransform(
				Point.read(arguments));
	},

	localToGlobal: function() {
		return this.getGlobalMatrix(true)._transformPoint(
				Point.read(arguments));
	},

	parentToLocal: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	localToParent: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	fitBounds: function(rectangle, fill) {
		rectangle = Rectangle.read(arguments);
		var bounds = this.getBounds(),
			itemRatio = bounds.height / bounds.width,
			rectRatio = rectangle.height / rectangle.width,
			scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
					? rectangle.width / bounds.width
					: rectangle.height / bounds.height,
			newBounds = new Rectangle(new Point(),
					new Size(bounds.width * scale, bounds.height * scale));
		newBounds.setCenter(rectangle.getCenter());
		this.setBounds(newBounds);
	},

	_setStyles: function(ctx) {
		var style = this._style,
			fillColor = style.getFillColor(),
			strokeColor = style.getStrokeColor(),
			shadowColor = style.getShadowColor();
		if (fillColor)
			ctx.fillStyle = fillColor.toCanvasStyle(ctx);
		if (strokeColor) {
			var strokeWidth = style.getStrokeWidth();
			if (strokeWidth > 0) {
				ctx.strokeStyle = strokeColor.toCanvasStyle(ctx);
				ctx.lineWidth = strokeWidth;
				var strokeJoin = style.getStrokeJoin(),
					strokeCap = style.getStrokeCap(),
					miterLimit = style.getMiterLimit();
				if (strokeJoin)
					ctx.lineJoin = strokeJoin;
				if (strokeCap)
					ctx.lineCap = strokeCap;
				if (miterLimit)
					ctx.miterLimit = miterLimit;
				if (paper.support.nativeDash) {
					var dashArray = style.getDashArray(),
						dashOffset = style.getDashOffset();
					if (dashArray && dashArray.length) {
						if ('setLineDash' in ctx) {
							ctx.setLineDash(dashArray);
							ctx.lineDashOffset = dashOffset;
						} else {
							ctx.mozDash = dashArray;
							ctx.mozDashOffset = dashOffset;
						}
					}
				}
			}
		}
		if (shadowColor) {
			var shadowBlur = style.getShadowBlur();
			if (shadowBlur > 0) {
				ctx.shadowColor = shadowColor.toCanvasStyle(ctx);
				ctx.shadowBlur = shadowBlur;
				var offset = this.getShadowOffset();
				ctx.shadowOffsetX = offset.x;
				ctx.shadowOffsetY = offset.y;
			}
		}
	},

	draw: function(ctx, param, parentStrokeMatrix) {
		var updateVersion = this._updateVersion = this._project._updateVersion;
		if (!this._visible || this._opacity === 0)
			return;
		var matrices = param.matrices,
			viewMatrix = param.viewMatrix,
			matrix = this._matrix,
			globalMatrix = matrices[matrices.length - 1].chain(matrix);
		if (!globalMatrix.isInvertible())
			return;

		function getViewMatrix(matrix) {
			return viewMatrix ? viewMatrix.chain(matrix) : matrix;
		}

		matrices.push(globalMatrix);
		if (param.updateMatrix) {
			globalMatrix._updateVersion = updateVersion;
			this._globalMatrix = globalMatrix;
		}

		var blendMode = this._blendMode,
			opacity = this._opacity,
			normalBlend = blendMode === 'normal',
			nativeBlend = BlendMode.nativeModes[blendMode],
			direct = normalBlend && opacity === 1
					|| param.dontStart
					|| param.clip
					|| (nativeBlend || normalBlend && opacity < 1)
						&& this._canComposite(),
			pixelRatio = param.pixelRatio || 1,
			mainCtx, itemOffset, prevOffset;
		if (!direct) {
			var bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));
			if (!bounds.width || !bounds.height)
				return;
			prevOffset = param.offset;
			itemOffset = param.offset = bounds.getTopLeft().floor();
			mainCtx = ctx;
			ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
					.multiply(pixelRatio));
			if (pixelRatio !== 1)
				ctx.scale(pixelRatio, pixelRatio);
		}
		ctx.save();
		var strokeMatrix = parentStrokeMatrix
				? parentStrokeMatrix.chain(matrix)
				: !this.getStrokeScaling(true) && getViewMatrix(globalMatrix),
			clip = !direct && param.clipItem,
			transform = !strokeMatrix || clip;
		if (direct) {
			ctx.globalAlpha = opacity;
			if (nativeBlend)
				ctx.globalCompositeOperation = blendMode;
		} else if (transform) {
			ctx.translate(-itemOffset.x, -itemOffset.y);
		}
		if (transform)
			(direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);
		if (clip)
			param.clipItem.draw(ctx, param.extend({ clip: true }));
		if (strokeMatrix) {
			ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
			var offset = param.offset;
			if (offset)
				ctx.translate(-offset.x, -offset.y);
		}
		this._draw(ctx, param, strokeMatrix);
		ctx.restore();
		matrices.pop();
		if (param.clip && !param.dontFinish)
			ctx.clip();
		if (!direct) {
			BlendMode.process(blendMode, ctx, mainCtx, opacity,
					itemOffset.subtract(prevOffset).multiply(pixelRatio));
			CanvasProvider.release(ctx);
			param.offset = prevOffset;
		}
	},

	_isUpdated: function(updateVersion) {
		var parent = this._parent;
		if (parent instanceof CompoundPath)
			return parent._isUpdated(updateVersion);
		var updated = this._updateVersion === updateVersion;
		if (!updated && parent && parent._visible
				&& parent._isUpdated(updateVersion)) {
			this._updateVersion = updateVersion;
			updated = true;
		}
		return updated;
	},

	_drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {
		if ((this._drawSelected || this._boundsSelected)
				&& this._isUpdated(updateVersion)) {
			var color = this.getSelectedColor(true)
					|| this.getLayer().getSelectedColor(true),
				mx = matrix.chain(this.getGlobalMatrix(true));
			ctx.strokeStyle = ctx.fillStyle = color
					? color.toCanvasStyle(ctx) : '#009dec';
			if (this._drawSelected)
				this._drawSelected(ctx, mx, selectedItems);
			if (this._boundsSelected) {
				var half = size / 2,
					coords = mx._transformCorners(this.getInternalBounds());
				ctx.beginPath();
				for (var i = 0; i < 8; i++)
					ctx[i === 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
				ctx.closePath();
				ctx.stroke();
				for (var i = 0; i < 8; i++)
					ctx.fillRect(coords[i] - half, coords[++i] - half,
							size, size);
			}
		}
	},

	_canComposite: function() {
		return false;
	}
}, Base.each(['down', 'drag', 'up', 'move'], function(name) {
	this['removeOn' + Base.capitalize(name)] = function() {
		var hash = {};
		hash[name] = true;
		return this.removeOn(hash);
	};
}, {

	removeOn: function(obj) {
		for (var name in obj) {
			if (obj[name]) {
				var key = 'mouse' + name,
					project = this._project,
					sets = project._removeSets = project._removeSets || {};
				sets[key] = sets[key] || {};
				sets[key][this._id] = this;
			}
		}
		return this;
	}
}));

var Group = Item.extend({
	_class: 'Group',
	_selectChildren: true,
	_serializeFields: {
		children: []
	},

	initialize: function Group(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg))
			this.addChildren(Array.isArray(arg) ? arg : arguments);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 1026) {
			this._clipItem = undefined;
		}
	},

	_getClipItem: function() {
		var clipItem = this._clipItem;
		if (clipItem === undefined) {
			clipItem = null;
			for (var i = 0, l = this._children.length; i < l; i++) {
				var child = this._children[i];
				if (child._clipMask) {
					clipItem = child;
					break;
				}
			}
			this._clipItem = clipItem;
		}
		return clipItem;
	},

	isClipped: function() {
		return !!this._getClipItem();
	},

	setClipped: function(clipped) {
		var child = this.getFirstChild();
		if (child)
			child.setClipMask(clipped);
	},

	_draw: function(ctx, param) {
		var clip = param.clip,
			clipItem = !clip && this._getClipItem(),
			draw = true;
		param = param.extend({ clipItem: clipItem, clip: false });
		if (clip) {
			if (this._currentPath) {
				ctx.currentPath = this._currentPath;
				draw = false;
			} else {
				ctx.beginPath();
				param.dontStart = param.dontFinish = true;
			}
		} else if (clipItem) {
			clipItem.draw(ctx, param.extend({ clip: true }));
		}
		if (draw) {
			for (var i = 0, l = this._children.length; i < l; i++) {
				var item = this._children[i];
				if (item !== clipItem)
					item.draw(ctx, param);
			}
		}
		if (clip) {
			this._currentPath = ctx.currentPath;
		}
	}
});

var Layer = Group.extend({
	_class: 'Layer',

	initialize: function Layer(arg) {
		var props = Base.isPlainObject(arg)
				? new Base(arg)
				: { children: Array.isArray(arg) ? arg : arguments },
			insert = props.insert;
		props.insert = false;
		Group.call(this, props);
		if (insert || insert === undefined) {
			this._project.addChild(this);
			this.activate();
		}
	},

	_remove: function _remove(notifySelf, notifyParent) {
		if (this._parent)
			return _remove.base.call(this, notifySelf, notifyParent);
		if (this._index != null) {
			var project = this._project;
			if (project._activeLayer === this)
				project._activeLayer = this.getNextSibling()
						|| this.getPreviousSibling();
			Base.splice(project.layers, null, this._index, 1);
			this._installEvents(false);
			if (notifySelf && project._changes)
				this._changed(5);
			if (notifyParent) {
				project._needsUpdate = true;
			}
			return true;
		}
		return false;
	},

	getNextSibling: function getNextSibling() {
		return this._parent ? getNextSibling.base.call(this)
				: this._project.layers[this._index + 1] || null;
	},

	getPreviousSibling: function getPreviousSibling() {
		return this._parent ? getPreviousSibling.base.call(this)
				: this._project.layers[this._index - 1] || null;
	},

	isInserted: function isInserted() {
		return this._parent ? isInserted.base.call(this) : this._index != null;
	},

	activate: function() {
		this._project._activeLayer = this;
	},

	_insertSibling: function _insertSibling(index, item, _preserve) {
		return !this._parent
				? this._project.insertChild(index, item, _preserve)
				: _insertSibling.base.call(this, index, item, _preserve);
	}
});

var Shape = Item.extend({
	_class: 'Shape',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsSelected: true,
	_serializeFields: {
		type: null,
		size: null,
		radius: null
	},

	initialize: function Shape(props) {
		this._initialize(props);
	},

	_equals: function(item) {
		return this._type === item._type
			&& this._size.equals(item._size)
			&& Base.equals(this._radius, item._radius);
	},

	clone: function(insert) {
		var copy = new Shape(Item.NO_INSERT);
		copy.setType(this._type);
		copy.setSize(this._size);
		copy.setRadius(this._radius);
		return this._clone(copy, insert);
	},

	getType: function() {
		return this._type;
	},

	setType: function(type) {
		this._type = type;
	},

	getShape: '#getType',
	setShape: '#setType',

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size) {
			this._size = size.clone();
		} else if (!this._size.equals(size)) {
			var type = this._type,
				width = size.width,
				height = size.height;
			if (type === 'rectangle') {
				var radius = Size.min(this._radius, size.divide(2));
				this._radius.set(radius.width, radius.height);
			} else if (type === 'circle') {
				width = height = (width + height) / 2;
				this._radius = width / 2;
			} else if (type === 'ellipse') {
				this._radius.set(width / 2, height / 2);
			}
			this._size.set(width, height);
			this._changed(9);
		}
	},

	getRadius: function() {
		var rad = this._radius;
		return this._type === 'circle'
				? rad
				: new LinkedSize(rad.width, rad.height, this, 'setRadius');
	},

	setRadius: function(radius) {
		var type = this._type;
		if (type === 'circle') {
			if (radius === this._radius)
				return;
			var size = radius * 2;
			this._radius = radius;
			this._size.set(size, size);
		} else {
			radius = Size.read(arguments);
			if (!this._radius) {
				this._radius = radius.clone();
			} else {
				if (this._radius.equals(radius))
					return;
				this._radius.set(radius.width, radius.height);
				if (type === 'rectangle') {
					var size = Size.max(this._size, radius.multiply(2));
					this._size.set(size.width, size.height);
				} else if (type === 'ellipse') {
					this._size.set(radius.width * 2, radius.height * 2);
				}
			}
		}
		this._changed(9);
	},

	isEmpty: function() {
		return false;
	},

	toPath: function(insert) {
		var path = this._clone(new Path[Base.capitalize(this._type)]({
			center: new Point(),
			size: this._size,
			radius: this._radius,
			insert: false
		}), insert);
		if (paper.settings.applyMatrix)
			path.setApplyMatrix(true);
		return path;
	},

	_draw: function(ctx, param, strokeMatrix) {
		var style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			dontPaint = param.dontFinish || param.clip,
			untransformed = !strokeMatrix;
		if (hasFill || hasStroke || dontPaint) {
			var type = this._type,
				radius = this._radius,
				isCircle = type === 'circle';
			if (!param.dontStart)
				ctx.beginPath();
			if (untransformed && isCircle) {
				ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
			} else {
				var rx = isCircle ? radius : radius.width,
					ry = isCircle ? radius : radius.height,
					size = this._size,
					width = size.width,
					height = size.height;
				if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
					ctx.rect(-width / 2, -height / 2, width, height);
				} else {
					var x = width / 2,
						y = height / 2,
						kappa = 1 - 0.5522847498307936,
						cx = rx * kappa,
						cy = ry * kappa,
						c = [
							-x, -y + ry,
							-x, -y + cy,
							-x + cx, -y,
							-x + rx, -y,
							x - rx, -y,
							x - cx, -y,
							x, -y + cy,
							x, -y + ry,
							x, y - ry,
							x, y - cy,
							x - cx, y,
							x - rx, y,
							-x + rx, y,
							-x + cx, y,
							-x, y - cy,
							-x, y - ry
						];
					if (strokeMatrix)
						strokeMatrix.transform(c, c, 32);
					ctx.moveTo(c[0], c[1]);
					ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
					if (x !== rx)
						ctx.lineTo(c[8], c[9]);
					ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
					if (y !== ry)
						ctx.lineTo(c[16], c[17]);
					ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
					if (x !== rx)
						ctx.lineTo(c[24], c[25]);
					ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
				}
			}
			ctx.closePath();
		}
		if (!dontPaint && (hasFill || hasStroke)) {
			this._setStyles(ctx);
			if (hasFill) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.stroke();
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		if (getter !== 'getBounds' && this.hasStroke())
			rect = rect.expand(this.getStrokeWidth());
		return matrix ? matrix._transformBounds(rect) : rect;
	}
},
new function() {
	function getCornerCenter(that, point, expand) {
		var radius = that._radius;
		if (!radius.isZero()) {
			var halfSize = that._size.divide(2);
			for (var i = 0; i < 4; i++) {
				var dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),
					corner = dir.multiply(halfSize),
					center = corner.subtract(dir.multiply(radius)),
					rect = new Rectangle(corner, center);
				if ((expand ? rect.expand(expand) : rect).contains(point))
					return center;
			}
		}
	}

	function getEllipseRadius(point, radius) {
		var angle = point.getAngleInRadians(),
			width = radius.width * 2,
			height = radius.height * 2,
			x = width * Math.sin(angle),
			y = height * Math.cos(angle);
		return width * height / (2 * Math.sqrt(x * x + y * y));
	}

	return {
		_contains: function _contains(point) {
			if (this._type === 'rectangle') {
				var center = getCornerCenter(this, point);
				return center
						? point.subtract(center).divide(this._radius)
							.getLength() <= 1
						: _contains.base.call(this, point);
			} else {
				return point.divide(this.size).getLength() <= 0.5;
			}
		},

		_hitTestSelf: function _hitTestSelf(point, options) {
			var hit = false;
			if (this.hasStroke()) {
				var type = this._type,
					radius = this._radius,
					strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
				if (type === 'rectangle') {
					var center = getCornerCenter(this, point, strokeWidth);
					if (center) {
						var pt = point.subtract(center);
						hit = 2 * Math.abs(pt.getLength()
								- getEllipseRadius(pt, radius)) <= strokeWidth;
					} else {
						var rect = new Rectangle(this._size).setCenter(0, 0),
							outer = rect.expand(strokeWidth),
							inner = rect.expand(-strokeWidth);
						hit = outer._containsPoint(point)
								&& !inner._containsPoint(point);
					}
				} else {
					if (type === 'ellipse')
						radius = getEllipseRadius(point, radius);
					hit = 2 * Math.abs(point.getLength() - radius)
							<= strokeWidth;
				}
			}
			return hit
					? new HitResult('stroke', this)
					: _hitTestSelf.base.apply(this, arguments);
		}
	};
}, {

statics: new function() {
	function createShape(type, point, size, radius, args) {
		var item = new Shape(Base.getNamed(args));
		item._type = type;
		item._size = size;
		item._radius = radius;
		return item.translate(point);
	}

	return {
		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createShape('circle', center, new Size(radius * 2), radius,
					arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.min(Size.readNamed(arguments, 'radius'),
						rect.getSize(true).divide(2));
			return createShape('rectangle', rect.getCenter(true),
					rect.getSize(true), radius, arguments);
		},

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments),
				radius = ellipse.radius;
			return createShape('ellipse', ellipse.center, radius.multiply(2),
					radius, arguments);
		},

		_readEllipse: function(args) {
			var center,
				radius;
			if (Base.hasNamed(args, 'radius')) {
				center = Point.readNamed(args, 'center');
				radius = Size.readNamed(args, 'radius');
			} else {
				var rect = Rectangle.readNamed(args, 'rectangle');
				center = rect.getCenter(true);
				radius = rect.getSize(true).divide(2);
			}
			return { center: center, radius: radius };
		}
	};
}});

var Raster = Item.extend({
	_class: 'Raster',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: 'getBounds',
	_boundsSelected: true,
	_serializeFields: {
		crossOrigin: null,
		source: null
	},

	initialize: function Raster(object, position) {
		if (!this._initialize(object,
				position !== undefined && Point.read(arguments, 1))) {
			if (typeof object === 'string') {
				this.setSource(object);
			} else {
				this.setImage(object);
			}
		}
		if (!this._size) {
			this._size = new Size();
			this._loaded = false;
		}
	},

	_equals: function(item) {
		return this.getSource() === item.getSource();
	},

	clone: function(insert) {
		var copy = new Raster(Item.NO_INSERT),
			image = this._image,
			canvas = this._canvas;
		if (image) {
			copy.setImage(image);
		} else if (canvas) {
			var copyCanvas = CanvasProvider.getCanvas(this._size);
			copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
			copy.setImage(copyCanvas);
		}
		copy._crossOrigin = this._crossOrigin;
		return this._clone(copy, insert);
	},

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size ? size.width : 0, size ? size.height : 0,
				this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!size.equals(this._size)) {
			if (size.width > 0 && size.height > 0) {
				var element = this.getElement();
				this.setImage(CanvasProvider.getCanvas(size));
				if (element)
					this.getContext(true).drawImage(element, 0, 0,
							size.width, size.height);
			} else {
				if (this._canvas)
					CanvasProvider.release(this._canvas);
				this._size = size.clone();
			}
		}
	},

	getWidth: function() {
		return this._size ? this._size.width : 0;
	},

	setWidth: function(width) {
		this.setSize(width, this.getHeight());
	},

	getHeight: function() {
		return this._size ? this._size.height : 0;
	},

	setHeight: function(height) {
		this.setSize(this.getWidth(), height);
	},

	isEmpty: function() {
		var size = this._size;
		return !size || size.width === 0 && size.height === 0;
	},

	getResolution: function() {
		var matrix = this._matrix,
			orig = new Point(0, 0).transform(matrix),
			u = new Point(1, 0).transform(matrix).subtract(orig),
			v = new Point(0, 1).transform(matrix).subtract(orig);
		return new Size(
			72 / u.getLength(),
			72 / v.getLength()
		);
	},

	getPpi: '#getResolution',

	getImage: function() {
		return this._image;
	},

	setImage: function(image) {
		if (this._canvas)
			CanvasProvider.release(this._canvas);
		if (image && image.getContext) {
			this._image = null;
			this._canvas = image;
			this._loaded = true;
		} else {
			this._image = image;
			this._canvas = null;
			this._loaded = image && image.complete;
		}
		this._size = new Size(
				image ? image.naturalWidth || image.width : 0,
				image ? image.naturalHeight || image.height : 0);
		this._context = null;
		this._changed(521);
	},

	getCanvas: function() {
		if (!this._canvas) {
			var ctx = CanvasProvider.getContext(this._size);
			try {
				if (this._image)
					ctx.drawImage(this._image, 0, 0);
				this._canvas = ctx.canvas;
			} catch (e) {
				CanvasProvider.release(ctx);
			}
		}
		return this._canvas;
	},

	setCanvas: '#setImage',

	getContext: function(modify) {
		if (!this._context)
			this._context = this.getCanvas().getContext('2d');
		if (modify) {
			this._image = null;
			this._changed(513);
		}
		return this._context;
	},

	setContext: function(context) {
		this._context = context;
	},

	getSource: function() {
		return this._image && this._image.src || this.toDataURL();
	},

	setSource: function(src) {
		var that = this,
			crossOrigin = this._crossOrigin,
			image;

		function loaded() {
			var view = that.getView();
			if (view) {
				paper = view._scope;
				that.setImage(image);
				that.emit('load');
				view.update();
			}
		}

		image = document.getElementById(src) || new Image();
		if (crossOrigin)
			image.crossOrigin = crossOrigin;
		if (image.naturalWidth && image.naturalHeight) {
			setTimeout(loaded, 0);
		} else {
			DomEvent.add(image, { load: loaded });
			if (!image.src)
				image.src = src;
		}
		this.setImage(image);
	},

	getCrossOrigin: function() {
		return this._image && this._image.crossOrigin || this._crossOrigin || '';
	},

	setCrossOrigin: function(crossOrigin) {
		this._crossOrigin = crossOrigin;
		if (this._image)
			this._image.crossOrigin = crossOrigin;
	},

	getElement: function() {
		return this._canvas || this._loaded && this._image;
	}
}, {
	beans: false,

	getSubCanvas: function() {
		var rect = Rectangle.read(arguments),
			ctx = CanvasProvider.getContext(rect.getSize());
		ctx.drawImage(this.getCanvas(), rect.x, rect.y,
				rect.width, rect.height, 0, 0, rect.width, rect.height);
		return ctx.canvas;
	},

	getSubRaster: function() {
		var rect = Rectangle.read(arguments),
			raster = new Raster(Item.NO_INSERT);
		raster.setImage(this.getSubCanvas(rect));
		raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
		raster._matrix.preConcatenate(this._matrix);
		raster.insertAbove(this);
		return raster;
	},

	toDataURL: function() {
		var src = this._image && this._image.src;
		if (/^data:/.test(src))
			return src;
		var canvas = this.getCanvas();
		return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
	},

	drawImage: function(image ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).drawImage(image, point.x, point.y);
	},

	getAverageColor: function(object) {
		var bounds, path;
		if (!object) {
			bounds = this.getBounds();
		} else if (object instanceof PathItem) {
			path = object;
			bounds = object.getBounds();
		} else if (object.width) {
			bounds = new Rectangle(object);
		} else if (object.x) {
			bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
		}
		var sampleSize = 32,
			width = Math.min(bounds.width, sampleSize),
			height = Math.min(bounds.height, sampleSize);
		var ctx = Raster._sampleContext;
		if (!ctx) {
			ctx = Raster._sampleContext = CanvasProvider.getContext(
					new Size(sampleSize));
		} else {
			ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
		}
		ctx.save();
		var matrix = new Matrix()
				.scale(width / bounds.width, height / bounds.height)
				.translate(-bounds.x, -bounds.y);
		matrix.applyToContext(ctx);
		if (path)
			path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
		this._matrix.applyToContext(ctx);
		var element = this.getElement(),
			size = this._size;
		if (element)
			ctx.drawImage(element, -size.width / 2, -size.height / 2);
		ctx.restore();
		var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
				Math.ceil(height)).data,
			channels = [0, 0, 0],
			total = 0;
		for (var i = 0, l = pixels.length; i < l; i += 4) {
			var alpha = pixels[i + 3];
			total += alpha;
			alpha /= 255;
			channels[0] += pixels[i] * alpha;
			channels[1] += pixels[i + 1] * alpha;
			channels[2] += pixels[i + 2] * alpha;
		}
		for (var i = 0; i < 3; i++)
			channels[i] /= total;
		return total ? Color.read(channels) : null;
	},

	getPixel: function() {
		var point = Point.read(arguments);
		var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
		return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
				data[3] / 255);
	},

	setPixel: function() {
		var point = Point.read(arguments),
			color = Color.read(arguments),
			components = color._convert('rgb'),
			alpha = color._alpha,
			ctx = this.getContext(true),
			imageData = ctx.createImageData(1, 1),
			data = imageData.data;
		data[0] = components[0] * 255;
		data[1] = components[1] * 255;
		data[2] = components[2] * 255;
		data[3] = alpha != null ? alpha * 255 : 255;
		ctx.putImageData(imageData, point.x, point.y);
	},

	createImageData: function() {
		var size = Size.read(arguments);
		return this.getContext().createImageData(size.width, size.height);
	},

	getImageData: function() {
		var rect = Rectangle.read(arguments);
		if (rect.isEmpty())
			rect = new Rectangle(this._size);
		return this.getContext().getImageData(rect.x, rect.y,
				rect.width, rect.height);
	},

	setImageData: function(data ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).putImageData(data, point.x, point.y);
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		return matrix ? matrix._transformBounds(rect) : rect;
	},

	_hitTestSelf: function(point) {
		if (this._contains(point)) {
			var that = this;
			return new HitResult('pixel', that, {
				offset: point.add(that._size.divide(2)).round(),
				color: {
					get: function() {
						return that.getPixel(this.offset);
					}
				}
			});
		}
	},

	_draw: function(ctx) {
		var element = this.getElement();
		if (element) {
			ctx.globalAlpha = this._opacity;
			ctx.drawImage(element,
					-this._size.width / 2, -this._size.height / 2);
		}
	},

	_canComposite: function() {
		return true;
	}
});

var PlacedSymbol = Item.extend({
	_class: 'PlacedSymbol',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: { getBounds: 'getStrokeBounds' },
	_boundsSelected: true,
	_serializeFields: {
		symbol: null
	},

	initialize: function PlacedSymbol(arg0, arg1) {
		if (!this._initialize(arg0,
				arg1 !== undefined && Point.read(arguments, 1)))
			this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));
	},

	_equals: function(item) {
		return this._symbol === item._symbol;
	},

	getSymbol: function() {
		return this._symbol;
	},

	setSymbol: function(symbol) {
		this._symbol = symbol;
		this._changed(9);
	},

	clone: function(insert) {
		var copy = new PlacedSymbol(Item.NO_INSERT);
		copy.setSymbol(this._symbol);
		return this._clone(copy, insert);
	},

	isEmpty: function() {
		return this._symbol._definition.isEmpty();
	},

	_getBounds: function(getter, matrix, cacheItem) {
		var definition = this.symbol._definition;
		return definition._getCachedBounds(getter,
				matrix && matrix.chain(definition._matrix), cacheItem);
	},

	_hitTestSelf: function(point, options) {
		var res = this._symbol._definition._hitTest(point, options);
		if (res)
			res.item = this;
		return res;
	},

	_draw: function(ctx, param) {
		this.symbol._definition.draw(ctx, param);
	}

});

var HitResult = Base.extend({
	_class: 'HitResult',

	initialize: function HitResult(type, item, values) {
		this.type = type;
		this.item = item;
		if (values) {
			values.enumerable = true;
			this.inject(values);
		}
	},

	statics: {
		getOptions: function(options) {
			return new Base({
				type: null,
				tolerance: paper.settings.hitTolerance,
				fill: !options,
				stroke: !options,
				segments: !options,
				handles: false,
				ends: false,
				center: false,
				bounds: false,
				guides: false,
				selected: false
			}, options);
		}
	}
});

var Segment = Base.extend({
	_class: 'Segment',
	beans: true,

	initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
		var count = arguments.length,
			point, handleIn, handleOut;
		if (count === 0) {
		} else if (count === 1) {
			if ('point' in arg0) {
				point = arg0.point;
				handleIn = arg0.handleIn;
				handleOut = arg0.handleOut;
			} else {
				point = arg0;
			}
		} else if (count === 2 && typeof arg0 === 'number') {
			point = arguments;
		} else if (count <= 3) {
			point = arg0;
			handleIn = arg1;
			handleOut = arg2;
		} else {
			point = arg0 !== undefined ? [ arg0, arg1 ] : null;
			handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
			handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
		}
		new SegmentPoint(point, this, '_point');
		new SegmentPoint(handleIn, this, '_handleIn');
		new SegmentPoint(handleOut, this, '_handleOut');
	},

	_serialize: function(options) {
		return Base.serialize(this.hasHandles()
				? [this._point, this._handleIn, this._handleOut]
				: this._point,
				options, true);
	},

	_changed: function(point) {
		var path = this._path;
		if (!path)
			return;
		var curves = path._curves,
			index = this._index,
			curve;
		if (curves) {
			if ((!point || point === this._point || point === this._handleIn)
					&& (curve = index > 0 ? curves[index - 1] : path._closed
						? curves[curves.length - 1] : null))
				curve._changed();
			if ((!point || point === this._point || point === this._handleOut)
					&& (curve = curves[index]))
				curve._changed();
		}
		path._changed(25);
	},

	getPoint: function() {
		return this._point;
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this._point.set(point.x, point.y);
	},

	getHandleIn: function() {
		return this._handleIn;
	},

	setHandleIn: function() {
		var point = Point.read(arguments);
		this._handleIn.set(point.x, point.y);
	},

	getHandleOut: function() {
		return this._handleOut;
	},

	setHandleOut: function() {
		var point = Point.read(arguments);
		this._handleOut.set(point.x, point.y);
	},

	hasHandles: function() {
		return !this._handleIn.isZero() || !this._handleOut.isZero();
	},

	clearHandles: function() {
		this._handleIn.set(0, 0);
		this._handleOut.set(0, 0);
	},

	_selectionState: 0,

	isSelected: function(_point) {
		var state = this._selectionState;
		return !_point ? !!(state & 7)
			: _point === this._point ? !!(state & 4)
			: _point === this._handleIn ? !!(state & 1)
			: _point === this._handleOut ? !!(state & 2)
			: false;
	},

	setSelected: function(selected, _point) {
		var path = this._path,
			selected = !!selected,
			state = this._selectionState,
			oldState = state,
			flag = !_point ? 7
					: _point === this._point ? 4
					: _point === this._handleIn ? 1
					: _point === this._handleOut ? 2
					: 0;
		if (selected) {
			state |= flag;
		} else {
			state &= ~flag;
		}
		this._selectionState = state;
		if (path && state !== oldState) {
			path._updateSelection(this, oldState, state);
			path._changed(129);
		}
	},

	getIndex: function() {
		return this._index !== undefined ? this._index : null;
	},

	getPath: function() {
		return this._path || null;
	},

	getCurve: function() {
		var path = this._path,
			index = this._index;
		if (path) {
			if (index > 0 && !path._closed
					&& index === path._segments.length - 1)
				index--;
			return path.getCurves()[index] || null;
		}
		return null;
	},

	getLocation: function() {
		var curve = this.getCurve();
		return curve
				? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
				: null;
	},

	getNext: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index + 1]
				|| this._path._closed && segments[0]) || null;
	},

	getPrevious: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index - 1]
				|| this._path._closed && segments[segments.length - 1]) || null;
	},

	isFirst: function() {
		return this._index === 0;
	},

	isLast: function() {
		var path = this._path;
		return path && this._index === path._segments.length - 1 || false;
	},

	reverse: function() {
		var handleIn = this._handleIn,
			handleOut = this._handleOut,
			inX = handleIn._x,
			inY = handleIn._y;
		handleIn.set(handleOut._x, handleOut._y);
		handleOut.set(inX, inY);
	},

	reversed: function() {
		return new Segment(this._point, this._handleOut, this._handleIn);
	},

	remove: function() {
		return this._path ? !!this._path.removeSegment(this._index) : false;
	},

	clone: function() {
		return new Segment(this._point, this._handleIn, this._handleOut);
	},

	equals: function(segment) {
		return segment === this || segment && this._class === segment._class
				&& this._point.equals(segment._point)
				&& this._handleIn.equals(segment._handleIn)
				&& this._handleOut.equals(segment._handleOut)
				|| false;
	},

	toString: function() {
		var parts = [ 'point: ' + this._point ];
		if (!this._handleIn.isZero())
			parts.push('handleIn: ' + this._handleIn);
		if (!this._handleOut.isZero())
			parts.push('handleOut: ' + this._handleOut);
		return '{ ' + parts.join(', ') + ' }';
	},

	transform: function(matrix) {
		this._transformCoordinates(matrix, new Array(6), true);
		this._changed();
	},

	_transformCoordinates: function(matrix, coords, change) {
		var point = this._point,
			handleIn = !change || !this._handleIn.isZero()
					? this._handleIn : null,
			handleOut = !change || !this._handleOut.isZero()
					? this._handleOut : null,
			x = point._x,
			y = point._y,
			i = 2;
		coords[0] = x;
		coords[1] = y;
		if (handleIn) {
			coords[i++] = handleIn._x + x;
			coords[i++] = handleIn._y + y;
		}
		if (handleOut) {
			coords[i++] = handleOut._x + x;
			coords[i++] = handleOut._y + y;
		}
		if (matrix) {
			matrix._transformCoordinates(coords, coords, i / 2);
			x = coords[0];
			y = coords[1];
			if (change) {
				point._x = x;
				point._y = y;
				i  = 2;
				if (handleIn) {
					handleIn._x = coords[i++] - x;
					handleIn._y = coords[i++] - y;
				}
				if (handleOut) {
					handleOut._x = coords[i++] - x;
					handleOut._y = coords[i++] - y;
				}
			} else {
				if (!handleIn) {
					coords[i++] = x;
					coords[i++] = y;
				}
				if (!handleOut) {
					coords[i++] = x;
					coords[i++] = y;
				}
			}
		}
		return coords;
	}
});

var SegmentPoint = Point.extend({
	initialize: function SegmentPoint(point, owner, key) {
		var x, y, selected;
		if (!point) {
			x = y = 0;
		} else if ((x = point[0]) !== undefined) {
			y = point[1];
		} else {
			var pt = point;
			if ((x = pt.x) === undefined) {
				pt = Point.read(arguments);
				x = pt.x;
			}
			y = pt.y;
			selected = pt.selected;
		}
		this._x = x;
		this._y = y;
		this._owner = owner;
		owner[key] = this;
		if (selected)
			this.setSelected(true);
	},

	set: function(x, y) {
		this._x = x;
		this._y = y;
		this._owner._changed(this);
		return this;
	},

	_serialize: function(options) {
		var f = options.formatter,
			x = f.number(this._x),
			y = f.number(this._y);
		return this.isSelected()
				? { x: x, y: y, selected: true }
				: [x, y];
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner._changed(this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner._changed(this);
	},

	isZero: function() {
		return Numerical.isZero(this._x) && Numerical.isZero(this._y);
	},

	setSelected: function(selected) {
		this._owner.setSelected(selected, this);
	},

	isSelected: function() {
		return this._owner.isSelected(this);
	}
});

var Curve = Base.extend({
	_class: 'Curve',

	initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
		var count = arguments.length,
			seg1, seg2,
			point1, point2,
			handle1, handle2;
		if (count === 3) {
			this._path = arg0;
			seg1 = arg1;
			seg2 = arg2;
		} else if (count === 0) {
			seg1 = new Segment();
			seg2 = new Segment();
		} else if (count === 1) {
			if ('segment1' in arg0) {
				seg1 = new Segment(arg0.segment1);
				seg2 = new Segment(arg0.segment2);
			} else if ('point1' in arg0) {
				point1 = arg0.point1;
				handle1 = arg0.handle1;
				handle2 = arg0.handle2;
				point2 = arg0.point2;
			} else if (Array.isArray(arg0)) {
				point1 = [arg0[0], arg0[1]];
				point2 = [arg0[6], arg0[7]];
				handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
				handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
			}
		} else if (count === 2) {
			seg1 = new Segment(arg0);
			seg2 = new Segment(arg1);
		} else if (count === 4) {
			point1 = arg0;
			handle1 = arg1;
			handle2 = arg2;
			point2 = arg3;
		} else if (count === 8) {
			point1 = [arg0, arg1];
			point2 = [arg6, arg7];
			handle1 = [arg2 - arg0, arg3 - arg1];
			handle2 = [arg4 - arg6, arg5 - arg7];
		}
		this._segment1 = seg1 || new Segment(point1, null, handle1);
		this._segment2 = seg2 || new Segment(point2, handle2, null);
	},

	_serialize: function(options) {
		return Base.serialize(this.hasHandles()
				? [this.getPoint1(), this.getHandle1(), this.getHandle2(),
					this.getPoint2()]
				: [this.getPoint1(), this.getPoint2()],
				options, true);
	},

	_changed: function() {
		this._length = this._bounds = undefined;
	},

	clone: function() {
		return new Curve(this._segment1, this._segment2);
	},

	toString: function() {
		var parts = [ 'point1: ' + this._segment1._point ];
		if (!this._segment1._handleOut.isZero())
			parts.push('handle1: ' + this._segment1._handleOut);
		if (!this._segment2._handleIn.isZero())
			parts.push('handle2: ' + this._segment2._handleIn);
		parts.push('point2: ' + this._segment2._point);
		return '{ ' + parts.join(', ') + ' }';
	},

	remove: function() {
		var removed = false;
		if (this._path) {
			var segment2 = this._segment2,
				handleOut = segment2._handleOut;
			removed = segment2.remove();
			if (removed)
				this._segment1._handleOut.set(handleOut.x, handleOut.y);
		}
		return removed;
	},

	getPoint1: function() {
		return this._segment1._point;
	},

	setPoint1: function() {
		var point = Point.read(arguments);
		this._segment1._point.set(point.x, point.y);
	},

	getPoint2: function() {
		return this._segment2._point;
	},

	setPoint2: function() {
		var point = Point.read(arguments);
		this._segment2._point.set(point.x, point.y);
	},

	getHandle1: function() {
		return this._segment1._handleOut;
	},

	setHandle1: function() {
		var point = Point.read(arguments);
		this._segment1._handleOut.set(point.x, point.y);
	},

	getHandle2: function() {
		return this._segment2._handleIn;
	},

	setHandle2: function() {
		var point = Point.read(arguments);
		this._segment2._handleIn.set(point.x, point.y);
	},

	getSegment1: function() {
		return this._segment1;
	},

	getSegment2: function() {
		return this._segment2;
	},

	getPath: function() {
		return this._path;
	},

	getIndex: function() {
		return this._segment1._index;
	},

	getNext: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index + 1]
				|| this._path._closed && curves[0]) || null;
	},

	getPrevious: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index - 1]
				|| this._path._closed && curves[curves.length - 1]) || null;
	},

	isFirst: function() {
		return this._segment1._index === 0;
	},

	isLast: function() {
		var path = this._path;
		return path && this._segment1._index === path._curves.length - 1
				|| false;
	},

	isSelected: function() {
		return this.getPoint1().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getPoint2().isSelected();
	},

	setSelected: function(selected) {
		this.getPoint1().setSelected(selected);
		this.getHandle1().setSelected(selected);
		this.getHandle2().setSelected(selected);
		this.getPoint2().setSelected(selected);
	},

	getValues: function(matrix) {
		return Curve.getValues(this._segment1, this._segment2, matrix);
	},

	getPoints: function() {
		var coords = this.getValues(),
			points = [];
		for (var i = 0; i < 8; i += 2)
			points.push(new Point(coords[i], coords[i + 1]));
		return points;
	},

	getLength: function() {
		if (this._length == null)
			this._length = Curve.getLength(this.getValues(), 0, 1);
		return this._length;
	},

	getArea: function() {
		return Curve.getArea(this.getValues());
	},

	getLine: function() {
		return new Line(this._segment1._point, this._segment2._point);
	},

	getPart: function(from, to) {
		return new Curve(Curve.getPart(this.getValues(), from, to));
	},

	getPartLength: function(from, to) {
		return Curve.getLength(this.getValues(), from, to);
	},

	getIntersections: function(curve) {
		return Curve._getIntersections(this.getValues(),
				curve && curve !== this ? curve.getValues() : null,
				this, curve, [], {});
	},

	_getParameter: function(offset, isParameter) {
		return isParameter
				? offset
				: offset && offset.curve === this
					? offset.parameter
					: offset === undefined && isParameter === undefined
						? 0.5
						: this.getParameterAt(offset, 0);
	},

	divide: function(offset, isParameter, _setHandles) {
		var parameter = this._getParameter(offset, isParameter),
			tMin = 4e-7,
			tMax = 1 - tMin,
			res = null;
		if (parameter >= tMin && parameter <= tMax) {
			var parts = Curve.subdivide(this.getValues(), parameter),
				left = parts[0],
				right = parts[1],
				setHandles = _setHandles || this.hasHandles(),
				segment1 = this._segment1,
				segment2 = this._segment2,
				path = this._path;
			if (setHandles) {
				segment1._handleOut.set(left[2] - left[0],
						left[3] - left[1]);
				segment2._handleIn.set(right[4] - right[6],
						right[5] - right[7]);
			}
			var x = left[6], y = left[7],
				segment = new Segment(new Point(x, y),
						setHandles && new Point(left[4] - x, left[5] - y),
						setHandles && new Point(right[2] - x, right[3] - y));
			if (path) {
				path.insert(segment1._index + 1, segment);
				res = this.getNext();
			} else {
				this._segment2 = segment;
				res = new Curve(segment, segment2);
			}
		}
		return res;
	},

	split: function(offset, isParameter) {
		return this._path
			? this._path.split(this._segment1._index,
					this._getParameter(offset, isParameter))
			: null;
	},

	reversed: function() {
		return new Curve(this._segment2.reversed(), this._segment1.reversed());
	},

	clearHandles: function() {
		this._segment1._handleOut.set(0, 0);
		this._segment2._handleIn.set(0, 0);
	},

statics: {
	getValues: function(segment1, segment2, matrix) {
		var p1 = segment1._point,
			h1 = segment1._handleOut,
			h2 = segment2._handleIn,
			p2 = segment2._point,
			values = [
				p1._x, p1._y,
				p1._x + h1._x, p1._y + h1._y,
				p2._x + h2._x, p2._y + h2._y,
				p2._x, p2._y
			];
		if (matrix)
			matrix._transformCoordinates(values, values, 4);
		return values;
	},

	subdivide: function(v, t) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		if (t === undefined)
			t = 0.5;
		var u = 1 - t,
			p3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,
			p4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,
			p5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,
			p6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,
			p7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,
			p8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;
		return [
			[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y],
			[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y]
		];
	},

	solveCubic: function (v, coord, val, roots, min, max) {
		var p1 = v[coord],
			c1 = v[coord + 2],
			c2 = v[coord + 4],
			p2 = v[coord + 6],
			c = 3 * (c1 - p1),
			b = 3 * (c2 - c1) - c,
			a = p2 - p1 - c - b;
		return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);
	},

	getParameterOf: function(v, point) {
		var p1 = new Point(v[0], v[1]),
			p2 = new Point(v[6], v[7]),
			epsilon = 1e-12,
			t = point.isClose(p1, epsilon) ? 0
			  : point.isClose(p2, epsilon) ? 1
			  : null;
		if (t !== null)
			return t;
		var coords = [point.x, point.y],
			roots = [],
			geomEpsilon = 2e-7;
		for (var c = 0; c < 2; c++) {
			var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);
			for (var i = 0; i < count; i++) {
				t = roots[i];
				if (point.isClose(Curve.getPoint(v, t), geomEpsilon))
					return t;
			}
		}
		return point.isClose(p1, geomEpsilon) ? 0
			 : point.isClose(p2, geomEpsilon) ? 1
			 : null;
	},

	getNearestParameter: function(v, point) {
		if (Curve.isStraight(v)) {
			var p1x = v[0], p1y = v[1],
				p2x = v[6], p2y = v[7],
				vx = p2x - p1x, vy = p2y - p1y,
				det = vx * vx + vy * vy;
			if (det === 0)
				return 0;
			var u = ((point.x - p1x) * vx + (point.y - p1y) * vy) / det;
			return u < 1e-12 ? 0
				 : u > 0.999999999999 ? 1
				 : Curve.getParameterOf(v,
					new Point(p1x + u * vx, p1y + u * vy));
		}

		var count = 100,
			minDist = Infinity,
			minT = 0;

		function refine(t) {
			if (t >= 0 && t <= 1) {
				var dist = point.getDistance(Curve.getPoint(v, t), true);
				if (dist < minDist) {
					minDist = dist;
					minT = t;
					return true;
				}
			}
		}

		for (var i = 0; i <= count; i++)
			refine(i / count);

		var step = 1 / (count * 2);
		while (step > 4e-7) {
			if (!refine(minT - step) && !refine(minT + step))
				step /= 2;
		}
		return minT;
	},

	getPart: function(v, from, to) {
		var flip = from > to;
		if (flip) {
			var tmp = from;
			from = to;
			to = tmp;
		}
		if (from > 0)
			v = Curve.subdivide(v, from)[1];
		if (to < 1)
			v = Curve.subdivide(v, (to - from) / (1 - from))[0];
		return flip
				? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]
				: v;
	},

	hasHandles: function(v) {
		var isZero = Numerical.isZero;
		return !(isZero(v[0] - v[2]) && isZero(v[1] - v[3])
				&& isZero(v[4] - v[6]) && isZero(v[5] - v[7]));
	},

	isFlatEnough: function(v, tolerance) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			ux = 3 * c1x - 2 * p1x - p2x,
			uy = 3 * c1y - 2 * p1y - p2y,
			vx = 3 * c2x - 2 * p2x - p1x,
			vy = 3 * c2y - 2 * p2y - p1y;
		return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
				< 10 * tolerance * tolerance;
	},

	getArea: function(v) {
		var p1x = v[0], p1y = v[1],
			p2x = v[6], p2y = v[7],
			h1x = (v[2] + p1x) / 2,
			h1y = (v[3] + p1y) / 2,
			h2x = (v[4] + v[6]) / 2,
			h2y = (v[5] + v[7]) / 2;
		return 6 * ((p1x - h1x) * (h1y + p1y)
				  + (h1x - h2x) * (h2y + h1y)
				  + (h2x - p2x) * (p2y + h2y)) / 10;
	},

	getBounds: function(v) {
		var min = v.slice(0, 2),
			max = min.slice(),
			roots = [0, 0];
		for (var i = 0; i < 2; i++)
			Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
					i, 0, min, max, roots);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
		function add(value, padding) {
			var left = value - padding,
				right = value + padding;
			if (left < min[coord])
				min[coord] = left;
			if (right > max[coord])
				max[coord] = right;
		}
		var a = 3 * (v1 - v2) - v0 + v3,
			b = 2 * (v0 + v2) - 4 * v1,
			c = v1 - v0,
			count = Numerical.solveQuadratic(a, b, c, roots),
			tMin = 4e-7,
			tMax = 1 - tMin;
		add(v3, 0);
		for (var i = 0; i < count; i++) {
			var t = roots[i],
				u = 1 - t;
			if (tMin < t && t < tMax)
				add(u * u * u * v0
					+ 3 * u * u * t * v1
					+ 3 * u * t * t * v2
					+ t * t * t * v3,
					padding);
		}
	}
}}, Base.each(
	['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],
	function(name) {
		this[name] = function() {
			if (!this._bounds)
				this._bounds = {};
			var bounds = this._bounds[name];
			if (!bounds) {
				var path = this._path;
				bounds = this._bounds[name] = Path[name](
						[this._segment1, this._segment2], false,
						path && path.getStyle());
			}
			return bounds.clone();
		};
	},
{

}), Base.each({
	isStraight: function(l, h1, h2) {
		if (h1.isZero() && h2.isZero()) {
			return true;
		} else if (l.isZero()) {
			return false;
		} else if (h1.isCollinear(l) && h2.isCollinear(l)) {
			var div = l.dot(l),
				p1 = l.dot(h1) / div,
				p2 = l.dot(h2) / div;
			return p1 >= 0 && p1 <= 1 && p2 <= 0 && p2 >= -1;
		}
		return false;
	},

	isLinear: function(l, h1, h2) {
		var third = l.divide(3);
		return h1.equals(third) && h2.negate().equals(third);
	}
}, function(test, name) {
	this[name] = function() {
		var seg1 = this._segment1,
			seg2 = this._segment2;
		return test(seg2._point.subtract(seg1._point),
				seg1._handleOut, seg2._handleIn);
	};

	this.statics[name] = function(v) {
		var p1x = v[0], p1y = v[1],
			p2x = v[6], p2y = v[7];
		return test(new Point(p2x - p1x, p2y - p1y),
				new Point(v[2] - p1x, v[3] - p1y),
				new Point(v[4] - p2x, v[5] - p2y));
	};
}, {
	statics: {},

	hasHandles: function() {
		return !this._segment1._handleOut.isZero()
				|| !this._segment2._handleIn.isZero();
	},

	isCollinear: function(curve) {
		return curve && this.isStraight() && curve.isStraight()
				&& this.getLine().isCollinear(curve.getLine());
	},

	isHorizontal: function() {
		return this.isStraight() && Math.abs(this.getTangentAt(0.5, true).y)
				< 1e-7;
	},

	isVertical: function() {
		return this.isStraight() && Math.abs(this.getTangentAt(0.5, true).x)
				< 1e-7;
	}
}), {
	beans: false,

	getParameterAt: function(offset, start) {
		return Curve.getParameterAt(this.getValues(), offset, start);
	},

	getParameterOf: function() {
		return Curve.getParameterOf(this.getValues(), Point.read(arguments));
	},

	getLocationAt: function(offset, isParameter) {
		var t = isParameter ? offset : this.getParameterAt(offset);
		return t != null && t >= 0 && t <= 1
				? new CurveLocation(this, t)
				: null;
	},

	getLocationOf: function() {
		return this.getLocationAt(this.getParameterOf(Point.read(arguments)),
				true);
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			values = this.getValues(),
			t = Curve.getNearestParameter(values, point),
			pt = Curve.getPoint(values, t);
		return new CurveLocation(this, t, pt, null, point.getDistance(pt));
	},

	getNearestPoint: function() {
		return this.getNearestLocation.apply(this, arguments).getPoint();
	}

},
new function() {
	var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',
		'getWeightedNormal', 'getCurvature'];
	return Base.each(methods,
	function(name) {
		this[name + 'At'] = function(offset, isParameter) {
			var values = this.getValues();
			return Curve[name](values, isParameter ? offset
					: Curve.getParameterAt(values, offset, 0));
		};
	}, {
		statics: {
			evaluateMethods: methods
		}
	})
},
new function() {

	function getLengthIntegrand(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],

			ax = 9 * (c1x - c2x) + 3 * (p2x - p1x),
			bx = 6 * (p1x + c2x) - 12 * c1x,
			cx = 3 * (c1x - p1x),

			ay = 9 * (c1y - c2y) + 3 * (p2y - p1y),
			by = 6 * (p1y + c2y) - 12 * c1y,
			cy = 3 * (c1y - p1y);

		return function(t) {
			var dx = (ax * t + bx) * t + cx,
				dy = (ay * t + by) * t + cy;
			return Math.sqrt(dx * dx + dy * dy);
		};
	}

	function getIterations(a, b) {
		return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
	}

	function evaluate(v, t, type, normalized) {
		if (t == null || t < 0 || t > 1)
			return null;
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			tMin = 4e-7,
			tMax = 1 - tMin,
			x, y;

		if (type === 0 && (t < tMin || t > tMax)) {
			var isZero = t < tMin;
			x = isZero ? p1x : p2x;
			y = isZero ? p1y : p2y;
		} else {
			var cx = 3 * (c1x - p1x),
				bx = 3 * (c2x - c1x) - cx,
				ax = p2x - p1x - cx - bx,

				cy = 3 * (c1y - p1y),
				by = 3 * (c2y - c1y) - cy,
				ay = p2y - p1y - cy - by;
			if (type === 0) {
				x = ((ax * t + bx) * t + cx) * t + p1x;
				y = ((ay * t + by) * t + cy) * t + p1y;
			} else {
				if (t < tMin) {
					x = cx;
					y = cy;
				} else if (t > tMax) {
					x = 3 * (p2x - c2x);
					y = 3 * (p2y - c2y);
				} else {
					x = (3 * ax * t + 2 * bx) * t + cx;
					y = (3 * ay * t + 2 * by) * t + cy;
				}
				if (normalized) {
					if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
						x = c2x - c1x;
						y = c2y - c1y;
					}
					var len = Math.sqrt(x * x + y * y);
					if (len) {
						x /= len;
						y /= len;
					}
				}
				if (type === 3) {
					var x2 = 6 * ax * t + 2 * bx,
						y2 = 6 * ay * t + 2 * by,
						d = Math.pow(x * x + y * y, 3 / 2);
					x = d !== 0 ? (x * y2 - y * x2) / d : 0;
					y = 0;
				}
			}
		}
		return type === 2 ? new Point(y, -x) : new Point(x, y);
	}

	return { statics: {

		getLength: function(v, a, b) {
			if (a === undefined)
				a = 0;
			if (b === undefined)
				b = 1;
			if (a === 0 && b === 1 && Curve.isStraight(v)) {
				var dx = v[6] - v[0],
					dy = v[7] - v[1];
				return Math.sqrt(dx * dx + dy * dy);
			}
			var ds = getLengthIntegrand(v);
			return Numerical.integrate(ds, a, b, getIterations(a, b));
		},

		getParameterAt: function(v, offset, start) {
			if (start === undefined)
				start = offset < 0 ? 1 : 0
			if (offset === 0)
				return start;
			var abs = Math.abs,
				forward = offset > 0,
				a = forward ? start : 0,
				b = forward ? 1 : start,
				ds = getLengthIntegrand(v),
				rangeLength = Numerical.integrate(ds, a, b,
						getIterations(a, b));
			if (abs(offset - rangeLength) < 1e-12) {
				return forward ? b : a;
			} else if (abs(offset) > rangeLength) {
				return null;
			}
			var guess = offset / rangeLength,
				length = 0;
			function f(t) {
				length += Numerical.integrate(ds, start, t,
						getIterations(start, t));
				start = t;
				return length - offset;
			}
			return Numerical.findRoot(f, ds, start + guess, a, b, 32,
					1e-12);
		},

		getPoint: function(v, t) {
			return evaluate(v, t, 0, false);
		},

		getTangent: function(v, t) {
			return evaluate(v, t, 1, true);
		},

		getWeightedTangent: function(v, t) {
			return evaluate(v, t, 1, false);
		},

		getNormal: function(v, t) {
			return evaluate(v, t, 2, true);
		},

		getWeightedNormal: function(v, t) {
			return evaluate(v, t, 2, false);
		},

		getCurvature: function(v, t) {
			return evaluate(v, t, 3, false).x;
		}
	}};
},
new function() {

	function addLocation(locations, param, v1, c1, t1, p1, v2, c2, t2, p2,
			overlap) {
		var startConnected = param.startConnected,
			endConnected = param.endConnected,
			tMin = 4e-7,
			tMax = 1 - tMin;
		if (t1 == null)
			t1 = Curve.getParameterOf(v1, p1);
		if (t1 !== null && t1 >= (startConnected ? tMin : 0) &&
			t1 <= (endConnected ? tMax : 1)) {
			if (t2 == null)
				t2 = Curve.getParameterOf(v2, p2);
			if (t2 !== null && t2 >= (endConnected ? tMin : 0) &&
				t2 <= (startConnected ? tMax : 1)) {
				var renormalize = param.renormalize;
				if (renormalize) {
					var res = renormalize(t1, t2);
					t1 = res[0];
					t2 = res[1];
				}
				var loc1 = new CurveLocation(c1, t1,
						p1 || Curve.getPoint(v1, t1), overlap),
					loc2 = new CurveLocation(c2, t2,
						p2 || Curve.getPoint(v2, t2), overlap),
					flip = loc1.getPath() === loc2.getPath()
						&& loc1.getIndex() > loc2.getIndex(),
					loc = flip ? loc2 : loc1,
					include = param.include;
				loc1._intersection = loc2;
				loc2._intersection = loc1;
				if (!include || include(loc)) {
					CurveLocation.insert(locations, loc, true);
				}
			}
		}
	}

	function addCurveIntersections(v1, v2, c1, c2, locations, param,
			tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
		if (++recursion >= 24)
			return;
		var q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
			getSignedDistance = Line.getSignedDistance,
			d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
			d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
			factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
			dMin = factor * Math.min(0, d1, d2),
			dMax = factor * Math.max(0, d1, d2),
			dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
			dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
			dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
			dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
			hull = getConvexHull(dp0, dp1, dp2, dp3),
			top = hull[0],
			bottom = hull[1],
			tMinClip,
			tMaxClip;
		if ((tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null ||
			(tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),
				dMin, dMax)) == null)
			return;
		v1 = Curve.getPart(v1, tMinClip, tMaxClip);
		var tDiff = tMaxClip - tMinClip,
			tMinNew = tMin + (tMax - tMin) * tMinClip,
			tMaxNew = tMin + (tMax - tMin) * tMaxClip;
		if (oldTDiff > 0.5 && tDiff > 0.5) {
			if (tMaxNew - tMinNew > uMax - uMin) {
				var parts = Curve.subdivide(v1, 0.5),
					t = tMinNew + (tMaxNew - tMinNew) / 2;
				addCurveIntersections(
					v2, parts[0], c2, c1, locations, param,
					uMin, uMax, tMinNew, t, tDiff, !reverse, recursion);
				addCurveIntersections(
					v2, parts[1], c2, c1, locations, param,
					uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);
			} else {
				var parts = Curve.subdivide(v2, 0.5),
					t = uMin + (uMax - uMin) / 2;
				addCurveIntersections(
					parts[0], v1, c2, c1, locations, param,
					uMin, t, tMinNew, tMaxNew, tDiff, !reverse, recursion);
				addCurveIntersections(
					parts[1], v1, c2, c1, locations, param,
					t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
			}
		} else if (Math.max(uMax - uMin, tMaxNew - tMinNew)
				< 1e-7) {
			var t1 = tMinNew + (tMaxNew - tMinNew) / 2,
				t2 = uMin + (uMax - uMin) / 2;
			v1 = c1.getValues();
			v2 = c2.getValues();
			addLocation(locations, param,
				reverse ? v2 : v1, reverse ? c2 : c1, reverse ? t2 : t1, null,
				reverse ? v1 : v2, reverse ? c1 : c2, reverse ? t1 : t2, null);
		} else if (tDiff > 1e-12) {
			addCurveIntersections(v2, v1, c2, c1, locations, param,
					uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
		}
	}

	function getConvexHull(dq0, dq1, dq2, dq3) {
		var p0 = [ 0, dq0 ],
			p1 = [ 1 / 3, dq1 ],
			p2 = [ 2 / 3, dq2 ],
			p3 = [ 1, dq3 ],
			dist1 = dq1 - (2 * dq0 + dq3) / 3,
			dist2 = dq2 - (dq0 + 2 * dq3) / 3,
			hull;
		if (dist1 * dist2 < 0) {
			hull = [[p0, p1, p3], [p0, p2, p3]];
		} else {
			var distRatio = dist1 / dist2;
			hull = [
				distRatio >= 2 ? [p0, p1, p3]
				: distRatio <= .5 ? [p0, p2, p3]
				: [p0, p1, p2, p3],
				[p0, p3]
			];
		}
		return (dist1 || dist2) < 0 ? hull.reverse() : hull;
	}

	function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
		if (hullTop[0][1] < dMin) {
			return clipConvexHullPart(hullTop, true, dMin);
		} else if (hullBottom[0][1] > dMax) {
			return clipConvexHullPart(hullBottom, false, dMax);
		} else {
			return hullTop[0][0];
		}
	}

	function clipConvexHullPart(part, top, threshold) {
		var px = part[0][0],
			py = part[0][1];
		for (var i = 1, l = part.length; i < l; i++) {
			var qx = part[i][0],
				qy = part[i][1];
			if (top ? qy >= threshold : qy <= threshold) {
				return qy === threshold ? qx
						: px + (threshold - py) * (qx - px) / (qy - py);
			}
			px = qx;
			py = qy;
		}
		return null;
	}

	function addCurveLineIntersections(v1, v2, c1, c2, locations, param) {
		var flip = Curve.isStraight(v1),
			vc = flip ? v2 : v1,
			vl = flip ? v1 : v2,
			lx1 = vl[0], ly1 = vl[1],
			lx2 = vl[6], ly2 = vl[7],
			ldx = lx2 - lx1,
			ldy = ly2 - ly1,
			angle = Math.atan2(-ldy, ldx),
			sin = Math.sin(angle),
			cos = Math.cos(angle),
			rvc = [];
		for(var i = 0; i < 8; i += 2) {
			var x = vc[i] - lx1,
				y = vc[i + 1] - ly1;
			rvc.push(
				x * cos - y * sin,
				x * sin + y * cos);
		}
		var roots = [],
			count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);
		for (var i = 0; i < count; i++) {
			var tc = roots[i],
				pc = Curve.getPoint(vc, tc),
				tl = Curve.getParameterOf(vl, pc);
			if (tl !== null) {
				var pl = Curve.getPoint(vl, tl),
					t1 = flip ? tl : tc,
					t2 = flip ? tc : tl;
				if (!param.endConnected || t2 > Numerical.CURVETIME_EPSILON) {
					addLocation(locations, param,
							v1, c1, t1, flip ? pl : pc,
							v2, c2, t2, flip ? pc : pl);
				}
			}
		}
	}

	function addLineIntersection(v1, v2, c1, c2, locations, param) {
		var pt = Line.intersect(
				v1[0], v1[1], v1[6], v1[7],
				v2[0], v2[1], v2[6], v2[7]);
		if (pt) {
			addLocation(locations, param, v1, c1, null, pt, v2, c2, null, pt);
		}
	}

	return { statics: {
		_getIntersections: function(v1, v2, c1, c2, locations, param) {
			if (!v2) {
				return Curve._getSelfIntersection(v1, c1, locations, param);
			}
			var c1p1x = v1[0], c1p1y = v1[1],
				c1p2x = v1[6], c1p2y = v1[7],
				c2p1x = v2[0], c2p1y = v2[1],
				c2p2x = v2[6], c2p2y = v2[7],
				c1s1x = (3 * v1[2] + c1p1x) / 4,
				c1s1y = (3 * v1[3] + c1p1y) / 4,
				c1s2x = (3 * v1[4] + c1p2x) / 4,
				c1s2y = (3 * v1[5] + c1p2y) / 4,
				c2s1x = (3 * v2[2] + c2p1x) / 4,
				c2s1y = (3 * v2[3] + c2p1y) / 4,
				c2s2x = (3 * v2[4] + c2p2x) / 4,
				c2s2y = (3 * v2[5] + c2p2y) / 4,
				min = Math.min,
				max = Math.max;
			if (!(	max(c1p1x, c1s1x, c1s2x, c1p2x) >=
					min(c2p1x, c2s1x, c2s2x, c2p2x) &&
					min(c1p1x, c1s1x, c1s2x, c1p2x) <=
					max(c2p1x, c2s1x, c2s2x, c2p2x) &&
					max(c1p1y, c1s1y, c1s2y, c1p2y) >=
					min(c2p1y, c2s1y, c2s2y, c2p2y) &&
					min(c1p1y, c1s1y, c1s2y, c1p2y) <=
					max(c2p1y, c2s1y, c2s2y, c2p2y)))
				return locations;
			if (!param.startConnected && !param.endConnected) {
				var overlaps = Curve.getOverlaps(v1, v2);
				if (overlaps) {
					for (var i = 0; i < 2; i++) {
						var overlap = overlaps[i];
						addLocation(locations, param,
							v1, c1, overlap[0], null,
							v2, c2, overlap[1], null, true);
					}
					return locations;
				}
			}

			var straight1 = Curve.isStraight(v1),
				straight2 = Curve.isStraight(v2),
				straight = straight1 && straight2,
				epsilon = 1e-12,
				before = locations.length;
			(straight
				? addLineIntersection
				: straight1 || straight2
					? addCurveLineIntersections
					: addCurveIntersections)(
						v1, v2, c1, c2, locations, param,
						0, 1, 0, 1, 0, false, 0);
			if (straight && locations.length > before)
				return locations;
			var c1p1 = new Point(c1p1x, c1p1y),
				c1p2 = new Point(c1p2x, c1p2y),
				c2p1 = new Point(c2p1x, c2p1y),
				c2p2 = new Point(c2p2x, c2p2y);
			if (c1p1.isClose(c2p1, epsilon))
				addLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 0, c2p1);
			if (!param.startConnected && c1p1.isClose(c2p2, epsilon))
				addLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 1, c2p2);
			if (!param.endConnected && c1p2.isClose(c2p1, epsilon))
				addLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 0, c2p1);
			if (c1p2.isClose(c2p2, epsilon))
				addLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 1, c2p2);
			return locations;
		},

		_getSelfIntersection: function(v1, c1, locations, param) {
			var p1x = v1[0], p1y = v1[1],
				h1x = v1[2], h1y = v1[3],
				h2x = v1[4], h2y = v1[5],
				p2x = v1[6], p2y = v1[7];
			var line = new Line(p1x, p1y, p2x, p2y, false),
				side1 = line.getSide(new Point(h1x, h1y), true),
				side2 = line.getSide(new Point(h2x, h2y), true);
			if (side1 === side2) {
				var edgeSum = (p1x - h2x) * (h1y - p2y)
							+ (h1x - p2x) * (h2y - p1y);
				if (edgeSum * side1 > 0)
					return locations;
			}
			var ax = p2x - 3 * h2x + 3 * h1x - p1x,
				bx = h2x - 2 * h1x + p1x,
				cx = h1x - p1x,
				ay = p2y - 3 * h2y + 3 * h1y - p1y,
				by = h2y - 2 * h1y + p1y,
				cy = h1y - p1y,
				ac = ay * cx - ax * cy,
				ab = ay * bx - ax * by,
				bc = by * cx - bx * cy;
			if (ac * ac - 4 * ab * bc < 0) {
				var roots = [],
					tSplit,
					count = Numerical.solveCubic(
							ax * ax	 + ay * ay,
							3 * (ax * bx + ay * by),
							2 * (bx * bx + by * by) + ax * cx + ay * cy,
							bx * cx + by * cy,
							roots, 0, 1);
				if (count > 0) {
					for (var i = 0, maxCurvature = 0; i < count; i++) {
						var curvature = Math.abs(
								c1.getCurvatureAt(roots[i], true));
						if (curvature > maxCurvature) {
							maxCurvature = curvature;
							tSplit = roots[i];
						}
					}
					var parts = Curve.subdivide(v1, tSplit);
					param.endConnected = true;
					param.renormalize = function(t1, t2) {
						return [t1 * tSplit, t2 * (1 - tSplit) + tSplit];
					};
					Curve._getIntersections(parts[0], parts[1], c1, c1,
							locations, param);
				}
			}
			return locations;
		},

		getOverlaps: function(v1, v2) {
			var abs = Math.abs,
				timeEpsilon = 4e-7,
				geomEpsilon = 2e-7,
				straight1 = Curve.isStraight(v1),
				straight2 = Curve.isStraight(v2),
				straight =	straight1 && straight2;

			function getLineLengthSquared(v) {
				var x = v[6] - v[0],
					y = v[7] - v[1];
				return x * x + y * y;
			}

			if (straight) {
				var flip = getLineLengthSquared(v1) < getLineLengthSquared(v2),
					l1 = flip ? v2 : v1,
					l2 = flip ? v1 : v2,
					line = new Line(l1[0], l1[1], l1[6], l1[7]);
				if (line.getDistance(new Point(l2[0], l2[1])) > geomEpsilon ||
					line.getDistance(new Point(l2[6], l2[7])) > geomEpsilon)
					return null;
			} else if (straight1 ^ straight2) {
				return null;
			}

			var v = [v1, v2],
				pairs = [];
			for (var i = 0, t1 = 0;
					i < 2 && pairs.length < 2;
					i += t1 === 0 ? 0 : 1, t1 = t1 ^ 1) {
				var t2 = Curve.getParameterOf(v[i ^ 1], new Point(
						v[i][t1 === 0 ? 0 : 6],
						v[i][t1 === 0 ? 1 : 7]));
				if (t2 != null) {
					var pair = i === 0 ? [t1, t2] : [t2, t1];
					if (pairs.length === 0 ||
						abs(pair[0] - pairs[0][0]) > timeEpsilon &&
						abs(pair[1] - pairs[0][1]) > timeEpsilon)
						pairs.push(pair);
				}
				if (i === 1 && pairs.length === 0)
					break;
			}
			if (pairs.length !== 2) {
				pairs = null;
			} else if (!straight) {
				var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
					o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
				if (abs(o2[2] - o1[2]) > geomEpsilon ||
					abs(o2[3] - o1[3]) > geomEpsilon ||
					abs(o2[4] - o1[4]) > geomEpsilon ||
					abs(o2[5] - o1[5]) > geomEpsilon)
					pairs = null;
			}
			return pairs;
		}
	}};
});

var CurveLocation = Base.extend({
	_class: 'CurveLocation',
	beans: true,

	initialize: function CurveLocation(curve, parameter, point,
			_overlap, _distance) {
		if (parameter > 0.9999996) {
			var next = curve.getNext();
			if (next) {
				parameter = 0;
				curve = next;
			}
		}
		this._id = UID.get(CurveLocation);
		this._setCurve(curve);
		this._parameter = parameter;
		this._point = point || curve.getPointAt(parameter, true);
		this._overlap = _overlap;
		this._distance = _distance;
		this._intersection = this._next = this._prev = null;
	},

	_setCurve: function(curve) {
		var path = curve._path;
		this._version = path ? path._version : 0;
		this._curve = curve;
		this._segment = null;
		this._segment1 = curve._segment1;
		this._segment2 = curve._segment2;
	},

	_setSegment: function(segment) {
		this._setCurve(segment.getCurve());
		this._segment = segment;
		this._parameter = segment === this._segment1 ? 0 : 1;
		this._point = segment._point.clone();
	},

	getSegment: function() {
		var curve = this.getCurve(),
			segment = this._segment;
		if (!segment) {
			var parameter = this.getParameter();
			if (parameter === 0) {
				segment = curve._segment1;
			} else if (parameter === 1) {
				segment = curve._segment2;
			} else if (parameter != null) {
				segment = curve.getPartLength(0, parameter)
					< curve.getPartLength(parameter, 1)
						? curve._segment1
						: curve._segment2;
			}
			this._segment = segment;
		}
		return segment;
	},

	getCurve: function() {
		var curve = this._curve,
			path = curve && curve._path,
			that = this;
		if (path && path._version !== this._version) {
			curve = this._parameter = this._curve = this._offset = null;
		}

		function trySegment(segment) {
			var curve = segment && segment.getCurve();
			if (curve && (that._parameter = curve.getParameterOf(that._point))
					!= null) {
				that._setCurve(curve);
				that._segment = segment;
				return curve;
			}
		}

		return curve
			|| trySegment(this._segment)
			|| trySegment(this._segment1)
			|| trySegment(this._segment2.getPrevious());
	},

	getPath: function() {
		var curve = this.getCurve();
		return curve && curve._path;
	},

	getIndex: function() {
		var curve = this.getCurve();
		return curve && curve.getIndex();
	},

	getParameter: function() {
		var curve = this.getCurve(),
			parameter = this._parameter;
		return curve && parameter == null
			? this._parameter = curve.getParameterOf(this._point)
			: parameter;
	},

	getPoint: function() {
		return this._point;
	},

	getOffset: function() {
		var offset = this._offset;
		if (offset == null) {
			offset = 0;
			var path = this.getPath(),
				index = this.getIndex();
			if (path && index != null) {
				var curves = path.getCurves();
				for (var i = 0; i < index; i++)
					offset += curves[i].getLength();
			}
			this._offset = offset += this.getCurveOffset();
		}
		return offset;
	},

	getCurveOffset: function() {
		var curve = this.getCurve(),
			parameter = this.getParameter();
		return parameter != null && curve && curve.getPartLength(0, parameter);
	},

	getIntersection: function() {
		return this._intersection;
	},

	getDistance: function() {
		return this._distance;
	},

	divide: function() {
		var curve = this.getCurve(),
			res = null;
		if (curve) {
			res = curve.divide(this.getParameter(), true);
			if (res)
				this._setSegment(res._segment1);
		}
		return res;
	},

	split: function() {
		var curve = this.getCurve();
		return curve ? curve.split(this.getParameter(), true) : null;
	},

	equals: function(loc, _ignoreOther) {
		var res = this === loc,
			epsilon = 2e-7;
		if (!res && loc instanceof CurveLocation
				&& this.getPath() === loc.getPath()
				&& this.getPoint().isClose(loc.getPoint(), epsilon)) {
			var c1 = this.getCurve(),
				c2 = loc.getCurve(),
				abs = Math.abs,
				diff = abs(
					((c1.isLast() && c2.isFirst() ? -1 : c1.getIndex())
							+ this.getParameter()) -
					((c2.isLast() && c1.isFirst() ? -1 : c2.getIndex())
							+ loc.getParameter()));
			res = (diff < 4e-7
				|| ((diff = abs(this.getOffset() - loc.getOffset())) < epsilon
					|| abs(this.getPath().getLength() - diff) < epsilon))
				&& (_ignoreOther
					|| (!this._intersection && !loc._intersection
						|| this._intersection && this._intersection.equals(
								loc._intersection, true)));
		}
		return res;
	},

	toString: function() {
		var parts = [],
			point = this.getPoint(),
			f = Formatter.instance;
		if (point)
			parts.push('point: ' + point);
		var index = this.getIndex();
		if (index != null)
			parts.push('index: ' + index);
		var parameter = this.getParameter();
		if (parameter != null)
			parts.push('parameter: ' + f.number(parameter));
		if (this._distance != null)
			parts.push('distance: ' + f.number(this._distance));
		return '{ ' + parts.join(', ') + ' }';
	},

	isTouching: function() {
		var inter = this._intersection;
		if (inter && this.getTangent().isCollinear(inter.getTangent())) {
			var curve1 = this.getCurve(),
				curve2 = inter.getCurve();
			return !(curve1.isStraight() && curve2.isStraight()
					&& curve1.getLine().intersect(curve2.getLine()));
		}
		return false;
	},

	isCrossing: function() {
		var inter = this._intersection;
		if (!inter)
			return false;
		var t1 = this.getParameter(),
			t2 = inter.getParameter(),
			tMin = 4e-7,
			tMax = 1 - tMin;
		if (t1 >= tMin && t1 <= tMax || t2 >= tMin && t2 <= tMax)
			return !this.isTouching();
		var c2 = this.getCurve(),
			c1 = c2.getPrevious(),
			c4 = inter.getCurve(),
			c3 = c4.getPrevious(),
			PI = Math.PI;
		if (!c1 || !c3)
			return false;

		function isInRange(angle, min, max) {
			return min < max
				? angle > min && angle < max
				: angle > min && angle <= PI || angle >= -PI && angle < max;
		}

		var a1 = c1.getTangentAt(tMax, true).negate().getAngleInRadians(),
			a2 = c2.getTangentAt(tMin, true).getAngleInRadians(),
			a3 = c3.getTangentAt(tMax, true).negate().getAngleInRadians(),
			a4 = c4.getTangentAt(tMin, true).getAngleInRadians();

		return (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2))
			&& (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1));
	},

	isOverlap: function() {
		return !!this._overlap;
	}
}, Base.each(Curve.evaluateMethods, function(name) {
	var get = name + 'At';
	this[name] = function() {
		var parameter = this.getParameter(),
			curve = this.getCurve();
		return parameter != null && curve && curve[get](parameter, true);
	};
}, {
	preserve: true
}),
new function() {

	function insert(locations, loc, merge) {
		var length = locations.length,
			l = 0,
			r = length - 1;

		function search(index, dir) {
			for (var i = index + dir; i >= -1 && i <= length; i += dir) {
				var loc2 = locations[((i % length) + length) % length];
				if (!loc.getPoint().isClose(loc2.getPoint(),
						2e-7))
					break;
				if (loc.equals(loc2))
					return loc2;
			}
			return null;
		}

		while (l <= r) {
			var m = (l + r) >>> 1,
				loc2 = locations[m],
				found;
			if (merge && (found = loc.equals(loc2) ? loc2
					: (search(m, -1) || search(m, 1)))) {
				if (loc._overlap) {
					found._overlap = found._intersection._overlap = true;
				}
				return found;
			}
		var path1 = loc.getPath(),
			path2 = loc2.getPath(),
			diff = path1 === path2
				? (loc.getIndex() + loc.getParameter())
				- (loc2.getIndex() + loc2.getParameter())
				: path1._id - path2._id;
			if (diff < 0) {
				r = m - 1;
			} else {
				l = m + 1;
			}
		}
		locations.splice(l, 0, loc);
		return loc;
	}

	return { statics: {
		insert: insert,

		expand: function(locations) {
			var expanded = locations.slice();
			for (var i = 0, l = locations.length; i < l; i++) {
				insert(expanded, locations[i]._intersection, false);
			}
			return expanded;
		}
	}};
});

var PathItem = Item.extend({
	_class: 'PathItem',

	initialize: function PathItem() {
	},

	getIntersections: function(path, include, _matrix, _returnFirst) {
		var self = this === path || !path,
			matrix1 = this._matrix.orNullIfIdentity(),
			matrix2 = self ? matrix1
				: (_matrix || path._matrix).orNullIfIdentity();
		if (!self && !this.getBounds(matrix1).touches(path.getBounds(matrix2)))
			return [];
		var curves1 = this.getCurves(),
			curves2 = self ? curves1 : path.getCurves(),
			length1 = curves1.length,
			length2 = self ? length1 : curves2.length,
			values2 = [],
			arrays = [],
			locations,
			path;
		for (var i = 0; i < length2; i++)
			values2[i] = curves2[i].getValues(matrix2);
		for (var i = 0; i < length1; i++) {
			var curve1 = curves1[i],
				values1 = self ? values2[i] : curve1.getValues(matrix1),
				path1 = curve1.getPath();
			if (path1 !== path) {
				path = path1;
				locations = [];
				arrays.push(locations);
			}
			if (self) {
				Curve._getSelfIntersection(values1, curve1, locations, {
					include: include,
					startConnected: length1 === 1 &&
							curve1.getPoint1().equals(curve1.getPoint2())
				});
			}
			for (var j = self ? i + 1 : 0; j < length2; j++) {
				if (_returnFirst && locations.length)
					return locations;
				var curve2 = curves2[j];
				Curve._getIntersections(
					values1, values2[j], curve1, curve2, locations,
					{
						include: include,
						startConnected: self && curve1.getPrevious() === curve2,
						endConnected: self && curve1.getNext() === curve2
					}
				);
			}
		}
		locations = [];
		for (var i = 0, l = arrays.length; i < l; i++) {
			locations.push.apply(locations, arrays[i]);
		}
		return locations;
	},

	getCrossings: function(path) {
		return this.getIntersections(path, function(inter) {
			return inter.isCrossing();
		});
	},

	_asPathItem: function() {
		return this;
	},

	setPathData: function(data) {

		var parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
			coords,
			relative = false,
			previous,
			control,
			current = new Point(),
			start = new Point();

		function getCoord(index, coord) {
			var val = +coords[index];
			if (relative)
				val += current[coord];
			return val;
		}

		function getPoint(index) {
			return new Point(
				getCoord(index, 'x'),
				getCoord(index + 1, 'y')
			);
		}

		this.clear();

		for (var i = 0, l = parts && parts.length; i < l; i++) {
			var part = parts[i],
				command = part[0],
				lower = command.toLowerCase();
			coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
			var length = coords && coords.length;
			relative = command === lower;
			if (previous === 'z' && !/[mz]/.test(lower))
				this.moveTo(current = start);
			switch (lower) {
			case 'm':
			case 'l':
				var move = lower === 'm';
				for (var j = 0; j < length; j += 2)
					this[j === 0 && move ? 'moveTo' : 'lineTo'](
							current = getPoint(j));
				control = current;
				if (move)
					start = current;
				break;
			case 'h':
			case 'v':
				var coord = lower === 'h' ? 'x' : 'y';
				for (var j = 0; j < length; j++) {
					current[coord] = getCoord(j, coord);
					this.lineTo(current);
				}
				control = current;
				break;
			case 'c':
				for (var j = 0; j < length; j += 6) {
					this.cubicCurveTo(
							getPoint(j),
							control = getPoint(j + 2),
							current = getPoint(j + 4));
				}
				break;
			case 's':
				for (var j = 0; j < length; j += 4) {
					this.cubicCurveTo(
							/[cs]/.test(previous)
									? current.multiply(2).subtract(control)
									: current,
							control = getPoint(j),
							current = getPoint(j + 2));
					previous = lower;
				}
				break;
			case 'q':
				for (var j = 0; j < length; j += 4) {
					this.quadraticCurveTo(
							control = getPoint(j),
							current = getPoint(j + 2));
				}
				break;
			case 't':
				for (var j = 0; j < length; j += 2) {
					this.quadraticCurveTo(
							control = (/[qt]/.test(previous)
									? current.multiply(2).subtract(control)
									: current),
							current = getPoint(j));
					previous = lower;
				}
				break;
			case 'a':
				for (var j = 0; j < length; j += 7) {
					this.arcTo(current = getPoint(j + 5),
							new Size(+coords[j], +coords[j + 1]),
							+coords[j + 2], +coords[j + 4], +coords[j + 3]);
				}
				break;
			case 'z':
				this.closePath(true);
				break;
			}
			previous = lower;
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_contains: function(point) {
		var winding = this._getWinding(point, false, true);
		return !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);
	}

});

var Path = PathItem.extend({
	_class: 'Path',
	_serializeFields: {
		segments: [],
		closed: false
	},

	initialize: function Path(arg) {
		this._closed = false;
		this._segments = [];
		this._version = 0;
		var segments = Array.isArray(arg)
			? typeof arg[0] === 'object'
				? arg
				: arguments
			: arg && (arg.size === undefined && (arg.x !== undefined
					|| arg.point !== undefined))
				? arguments
				: null;
		if (segments && segments.length > 0) {
			this.setSegments(segments);
		} else {
			this._curves = undefined;
			this._selectedSegmentState = 0;
			if (!segments && typeof arg === 'string') {
				this.setPathData(arg);
				arg = null;
			}
		}
		this._initialize(!segments && arg);
	},

	_equals: function(item) {
		return this._closed === item._closed
				&& Base.equals(this._segments, item._segments);
	},

	clone: function(insert) {
		var copy = new Path(Item.NO_INSERT);
		copy.setSegments(this._segments);
		copy._closed = this._closed;
		if (this._clockwise !== undefined)
			copy._clockwise = this._clockwise;
		return this._clone(copy, insert);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 8) {
			var parent = this._parent;
			if (parent)
				parent._currentPath = undefined;
			this._length = this._area = this._clockwise = this._monoCurves =
					undefined;
			if (flags & 16) {
				this._version++;
			} else if (this._curves) {
			   for (var i = 0, l = this._curves.length; i < l; i++)
					this._curves[i]._changed();
			}
		} else if (flags & 32) {
			this._bounds = undefined;
		}
	},

	getStyle: function() {
		var parent = this._parent;
		return (parent instanceof CompoundPath ? parent : this)._style;
	},

	getSegments: function() {
		return this._segments;
	},

	setSegments: function(segments) {
		var fullySelected = this.isFullySelected();
		this._segments.length = 0;
		this._selectedSegmentState = 0;
		this._curves = undefined;
		if (segments && segments.length > 0)
			this._add(Segment.readAll(segments));
		if (fullySelected)
			this.setFullySelected(true);
	},

	getFirstSegment: function() {
		return this._segments[0];
	},

	getLastSegment: function() {
		return this._segments[this._segments.length - 1];
	},

	getCurves: function() {
		var curves = this._curves,
			segments = this._segments;
		if (!curves) {
			var length = this._countCurves();
			curves = this._curves = new Array(length);
			for (var i = 0; i < length; i++)
				curves[i] = new Curve(this, segments[i],
					segments[i + 1] || segments[0]);
		}
		return curves;
	},

	getFirstCurve: function() {
		return this.getCurves()[0];
	},

	getLastCurve: function() {
		var curves = this.getCurves();
		return curves[curves.length - 1];
	},

	isClosed: function() {
		return this._closed;
	},

	setClosed: function(closed) {
		if (this._closed != (closed = !!closed)) {
			this._closed = closed;
			if (this._curves) {
				var length = this._curves.length = this._countCurves();
				if (closed)
					this._curves[length - 1] = new Curve(this,
						this._segments[length - 1], this._segments[0]);
			}
			this._changed(25);
		}
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var segments = this._segments,
			length = segments.length,
			f = new Formatter(_precision),
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY,
			parts = [];

		function addSegment(segment, skipLine) {
			segment._transformCoordinates(_matrix, coords, false);
			curX = coords[0];
			curY = coords[1];
			if (first) {
				parts.push('M' + f.pair(curX, curY));
				first = false;
			} else {
				inX = coords[2];
				inY = coords[3];
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					if (!skipLine)
						parts.push('l' + f.pair(curX - prevX, curY - prevY));
				} else {
					parts.push('c' + f.pair(outX - prevX, outY - prevY)
							+ ' ' + f.pair(inX - prevX, inY - prevY)
							+ ' ' + f.pair(curX - prevX, curY - prevY));
				}
			}
			prevX = curX;
			prevY = curY;
			outX = coords[4];
			outY = coords[5];
		}

		if (length === 0)
			return '';

		for (var i = 0; i < length; i++)
			addSegment(segments[i]);
		if (this._closed && length > 0) {
			addSegment(segments[0], true);
			parts.push('z');
		}
		return parts.join('');
	}
}, {

	isEmpty: function() {
		return this._segments.length === 0;
	},

	_transformContent: function(matrix) {
		var coords = new Array(6);
		for (var i = 0, l = this._segments.length; i < l; i++)
			this._segments[i]._transformCoordinates(matrix, coords, true);
		return true;
	},

	_add: function(segs, index) {
		var segments = this._segments,
			curves = this._curves,
			amount = segs.length,
			append = index == null,
			index = append ? segments.length : index;
		for (var i = 0; i < amount; i++) {
			var segment = segs[i];
			if (segment._path)
				segment = segs[i] = segment.clone();
			segment._path = this;
			segment._index = index + i;
			if (segment._selectionState)
				this._updateSelection(segment, 0, segment._selectionState);
		}
		if (append) {
			segments.push.apply(segments, segs);
		} else {
			segments.splice.apply(segments, [index, 0].concat(segs));
			for (var i = index + amount, l = segments.length; i < l; i++)
				segments[i]._index = i;
		}
		if (curves) {
			var total = this._countCurves(),
				from = index + amount - 1 === total ? index - 1 : index,
				start = from,
				to = Math.min(from + amount, total);
			if (segs._curves) {
				curves.splice.apply(curves, [from, 0].concat(segs._curves));
				start += segs._curves.length;
			}
			for (var i = start; i < to; i++)
				curves.splice(i, 0, new Curve(this, null, null));
			this._adjustCurves(from, to);
		}
		this._changed(25);
		return segs;
	},

	_adjustCurves: function(from, to) {
		var segments = this._segments,
			curves = this._curves,
			curve;
		for (var i = from; i < to; i++) {
			curve = curves[i];
			curve._path = this;
			curve._segment1 = segments[i];
			curve._segment2 = segments[i + 1] || segments[0];
			curve._changed();
		}
		if (curve = curves[this._closed && from === 0 ? segments.length - 1
				: from - 1]) {
			curve._segment2 = segments[from] || segments[0];
			curve._changed();
		}
		if (curve = curves[to]) {
			curve._segment1 = segments[to];
			curve._changed();
		}
	},

	_countCurves: function() {
		var length = this._segments.length;
		return !this._closed && length > 0 ? length - 1 : length;
	},

	add: function(segment1 ) {
		return arguments.length > 1 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments))
			: this._add([ Segment.read(arguments) ])[0];
	},

	insert: function(index, segment1 ) {
		return arguments.length > 2 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments, 1), index)
			: this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegment: function() {
		return this._add([ Segment.read(arguments) ])[0];
	},

	insertSegment: function(index ) {
		return this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegments: function(segments) {
		return this._add(Segment.readAll(segments));
	},

	insertSegments: function(index, segments) {
		return this._add(Segment.readAll(segments), index);
	},

	removeSegment: function(index) {
		return this.removeSegments(index, index + 1)[0] || null;
	},

	removeSegments: function(from, to, _includeCurves) {
		from = from || 0;
		to = Base.pick(to, this._segments.length);
		var segments = this._segments,
			curves = this._curves,
			count = segments.length,
			removed = segments.splice(from, to - from),
			amount = removed.length;
		if (!amount)
			return removed;
		for (var i = 0; i < amount; i++) {
			var segment = removed[i];
			if (segment._selectionState)
				this._updateSelection(segment, segment._selectionState, 0);
			segment._index = segment._path = null;
		}
		for (var i = from, l = segments.length; i < l; i++)
			segments[i]._index = i;
		if (curves) {
			var index = from > 0 && to === count + (this._closed ? 1 : 0)
					? from - 1
					: from,
				curves = curves.splice(index, amount);
			if (_includeCurves)
				removed._curves = curves.slice(1);
			this._adjustCurves(index, index);
		}
		this._changed(25);
		return removed;
	},

	clear: '#removeSegments',

	hasHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++) {
			if (segments[i].hasHandles())
				return true;
		}
		return false;
	},

	clearHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++)
			segments[i].clearHandles();
	},

	getLength: function() {
		if (this._length == null) {
			var curves = this.getCurves(),
				length = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				length += curves[i].getLength();
			this._length = length;
		}
		return this._length;
	},

	getArea: function() {
		if (this._area == null) {
			var segments = this._segments,
				count = segments.length,
				last = count - 1,
				area = 0;
			for (var i = 0, l = this._closed ? count : last; i < l; i++) {
				area += Curve.getArea(Curve.getValues(
						segments[i], segments[i < last ? i + 1 : 0]));
			}
			this._area = area;
		}
		return this._area;
	},

	isClockwise: function() {
		if (this._clockwise !== undefined)
			return this._clockwise;
		return this.getArea() >= 0;
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() != (clockwise = !!clockwise))
			this.reverse();
		this._clockwise = clockwise;
	},

	isFullySelected: function() {
		var length = this._segments.length;
		return this._selected && length > 0 && this._selectedSegmentState
				=== length * 7;
	},

	setFullySelected: function(selected) {
		if (selected)
			this._selectSegments(true);
		this.setSelected(selected);
	},

	setSelected: function setSelected(selected) {
		if (!selected)
			this._selectSegments(false);
		setSelected.base.call(this, selected);
	},

	_selectSegments: function(selected) {
		var length = this._segments.length;
		this._selectedSegmentState = selected
				? length * 7 : 0;
		for (var i = 0; i < length; i++)
			this._segments[i]._selectionState = selected
					? 7 : 0;
	},

	_updateSelection: function(segment, oldState, newState) {
		segment._selectionState = newState;
		var total = this._selectedSegmentState += newState - oldState;
		if (total > 0)
			this.setSelected(true);
	},

	flatten: function(maxDistance) {
		var iterator = new PathIterator(this, 64, 0.1),
			pos = 0,
			step = iterator.length / Math.ceil(iterator.length / maxDistance),
			end = iterator.length + (this._closed ? -step : step) / 2;
		var segments = [];
		while (pos <= end) {
			segments.push(new Segment(iterator.getPointAt(pos)));
			pos += step;
		}
		this.setSegments(segments);
	},

	reduce: function() {
		var curves = this.getCurves();
		for (var i = curves.length - 1; i >= 0; i--) {
			var curve = curves[i];
			if (!curve.hasHandles() && (curve.getLength() === 0
					|| curve.isCollinear(curve.getNext())))
				curve.remove();
		}
		return this;
	},

	simplify: function(tolerance) {
		if (this._segments.length > 2) {
			var fitter = new PathFitter(this, tolerance || 2.5);
			this.setSegments(fitter.fit());
		}
	},

	split: function(index, parameter) {
		if (parameter === null)
			return null;
		if (arguments.length === 1) {
			var arg = index;
			if (typeof arg === 'number')
				arg = this.getLocationAt(arg);
			if (!arg)
				return null
			index = arg.index;
			parameter = arg.parameter;
		}
		var tMin = 4e-7,
			tMax = 1 - tMin;
		if (parameter >= tMax) {
			index++;
			parameter--;
		}
		var curves = this.getCurves();
		if (index >= 0 && index < curves.length) {
			if (parameter >= tMin) {
				curves[index++].divide(parameter, true);
			}
			var segs = this.removeSegments(index, this._segments.length, true),
				path;
			if (this._closed) {
				this.setClosed(false);
				path = this;
			} else {
				path = new Path(Item.NO_INSERT);
				path.insertAbove(this, true);
				this._clone(path);
			}
			path._add(segs, 0);
			this.addSegment(segs[0]);
			return path;
		}
		return null;
	},

	reverse: function() {
		this._segments.reverse();
		for (var i = 0, l = this._segments.length; i < l; i++) {
			var segment = this._segments[i];
			var handleIn = segment._handleIn;
			segment._handleIn = segment._handleOut;
			segment._handleOut = handleIn;
			segment._index = i;
		}
		this._curves = null;
		if (this._clockwise !== undefined)
			this._clockwise = !this._clockwise;
		this._changed(9);
	},

	join: function(path) {
		if (path) {
			var segments = path._segments,
				last1 = this.getLastSegment(),
				last2 = path.getLastSegment();
			if (!last2)
				return this;
			if (last1 && last1._point.equals(last2._point))
				path.reverse();
			var first2 = path.getFirstSegment();
			if (last1 && last1._point.equals(first2._point)) {
				last1.setHandleOut(first2._handleOut);
				this._add(segments.slice(1));
			} else {
				var first1 = this.getFirstSegment();
				if (first1 && first1._point.equals(first2._point))
					path.reverse();
				last2 = path.getLastSegment();
				if (first1 && first1._point.equals(last2._point)) {
					first1.setHandleIn(last2._handleIn);
					this._add(segments.slice(0, segments.length - 1), 0);
				} else {
					this._add(segments.slice());
				}
			}
			if (path._closed)
				this._add([segments[0]]);
			path.remove();
		}
		var first = this.getFirstSegment(),
			last = this.getLastSegment();
		if (first !== last && first._point.equals(last._point)) {
			first.setHandleIn(last._handleIn);
			last.remove();
			this.setClosed(true);
		}
		return this;
	},

	toShape: function(insert) {
		if (!this._closed)
			return null;

		var segments = this._segments,
			type,
			size,
			radius,
			topCenter;

		function isCollinear(i, j) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				seg3 = segments[j],
				seg4 = seg3.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg3._handleOut.isZero() && seg4._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isCollinear(
						seg4._point.subtract(seg3._point));
		}

		function isOrthogonal(i) {
			var seg2 = segments[i],
				seg1 = seg2.getPrevious(),
				seg3 = seg2.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg2._handleOut.isZero() && seg3._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isOrthogonal(
						seg3._point.subtract(seg2._point));
		}

		function isArc(i) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				handle1 = seg1._handleOut,
				handle2 = seg2._handleIn,
				kappa = 0.5522847498307936;
			if (handle1.isOrthogonal(handle2)) {
				var pt1 = seg1._point,
					pt2 = seg2._point,
					corner = new Line(pt1, handle1, true).intersect(
							new Line(pt2, handle2, true), true);
				return corner && Numerical.isZero(handle1.getLength() /
						corner.subtract(pt1).getLength() - kappa)
					&& Numerical.isZero(handle2.getLength() /
						corner.subtract(pt2).getLength() - kappa);
			}
			return false;
		}

		function getDistance(i, j) {
			return segments[i]._point.getDistance(segments[j]._point);
		}

		if (!this.hasHandles() && segments.length === 4
				&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(0, 3), getDistance(0, 1));
			topCenter = segments[1]._point.add(segments[2]._point).divide(2);
		} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
				&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(1, 6), getDistance(0, 3));
			radius = size.subtract(new Size(getDistance(0, 7),
					getDistance(1, 2))).divide(2);
			topCenter = segments[3]._point.add(segments[4]._point).divide(2);
		} else if (segments.length === 4
				&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
			if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
				type = Shape.Circle;
				radius = getDistance(0, 2) / 2;
			} else {
				type = Shape.Ellipse;
				radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
			}
			topCenter = segments[1]._point;
		}

		if (type) {
			var center = this.getPosition(true),
				shape = this._clone(new type({
					center: center,
					size: size,
					radius: radius,
					insert: false
				}), insert, false);
			shape.rotate(topCenter.subtract(center).getAngle() + 90);
			return shape;
		}
		return null;
	},

	_hitTestSelf: function(point, options) {
		var that = this,
			style = this.getStyle(),
			segments = this._segments,
			numSegments = segments.length,
			closed = this._closed,
			tolerancePadding = options._tolerancePadding,
			strokePadding = tolerancePadding,
			join, cap, miterLimit,
			area, loc, res,
			hitStroke = options.stroke && style.hasStroke(),
			hitFill = options.fill && style.hasFill(),
			hitCurves = options.curves,
			radius = hitStroke
					? style.getStrokeWidth() / 2
					: hitFill && options.tolerance > 0 || hitCurves
						? 0 : null;
		if (radius !== null) {
			if (radius > 0) {
				join = style.getStrokeJoin();
				cap = style.getStrokeCap();
				miterLimit = radius * style.getMiterLimit();
				strokePadding = tolerancePadding.add(new Point(radius, radius));
			} else {
				join = cap = 'round';
			}
		}

		function isCloseEnough(pt, padding) {
			return point.subtract(pt).divide(padding).length <= 1;
		}

		function checkSegmentPoint(seg, pt, name) {
			if (!options.selected || pt.isSelected()) {
				var anchor = seg._point;
				if (pt !== anchor)
					pt = pt.add(anchor);
				if (isCloseEnough(pt, strokePadding)) {
					return new HitResult(name, that, {
						segment: seg,
						point: pt
					});
				}
			}
		}

		function checkSegmentPoints(seg, ends) {
			return (ends || options.segments)
				&& checkSegmentPoint(seg, seg._point, 'segment')
				|| (!ends && options.handles) && (
					checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
					checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
		}

		function addToArea(point) {
			area.add(point);
		}

		function checkSegmentStroke(segment) {
			if (join !== 'round' || cap !== 'round') {
				area = new Path({ internal: true, closed: true });
				if (closed || segment._index > 0
						&& segment._index < numSegments - 1) {
					if (join !== 'round' && (segment._handleIn.isZero()
							|| segment._handleOut.isZero()))
						Path._addBevelJoin(segment, join, radius, miterLimit,
								addToArea, true);
				} else if (cap !== 'round') {
					Path._addSquareCap(segment, cap, radius, addToArea, true);
				}
				if (!area.isEmpty()) {
					var loc;
					return area.contains(point)
						|| (loc = area.getNearestLocation(point))
							&& isCloseEnough(loc.getPoint(), tolerancePadding);
				}
			}
			return isCloseEnough(segment._point, strokePadding);
		}

		if (options.ends && !options.segments && !closed) {
			if (res = checkSegmentPoints(segments[0], true)
					|| checkSegmentPoints(segments[numSegments - 1], true))
				return res;
		} else if (options.segments || options.handles) {
			for (var i = 0; i < numSegments; i++)
				if (res = checkSegmentPoints(segments[i]))
					return res;
		}
		if (radius !== null) {
			loc = this.getNearestLocation(point);
			if (loc) {
				var parameter = loc.getParameter();
				if (parameter === 0 || parameter === 1 && numSegments > 1) {
					if (!checkSegmentStroke(loc.getSegment()))
						loc = null;
				} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
					loc = null;
				}
			}
			if (!loc && join === 'miter' && numSegments > 1) {
				for (var i = 0; i < numSegments; i++) {
					var segment = segments[i];
					if (point.getDistance(segment._point) <= miterLimit
							&& checkSegmentStroke(segment)) {
						loc = segment.getLocation();
						break;
					}
				}
			}
		}
		return !loc && hitFill && this._contains(point)
				|| loc && !hitStroke && !hitCurves
					? new HitResult('fill', this)
					: loc
						? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
							location: loc,
							point: loc.getPoint()
						})
						: null;
	}

}, Base.each(Curve.evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset, isParameter) {
			var loc = this.getLocationAt(offset, isParameter);
			return loc && loc[name]();
		};
	},
{
	beans: false,

	getLocationOf: function() {
		var point = Point.read(arguments),
			curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getLocationOf(point);
			if (loc)
				return loc;
		}
		return null;
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getLocationAt: function(offset, isParameter) {
		var curves = this.getCurves(),
			length = 0;
		if (isParameter) {
			var index = ~~offset,
				curve = curves[index];
			return curve ? curve.getLocationAt(offset - index, true) : null;
		}
		for (var i = 0, l = curves.length; i < l; i++) {
			var start = length,
				curve = curves[i];
			length += curve.getLength();
			if (length > offset) {
				return curve.getLocationAt(offset - start);
			}
		}
		if (curves.length > 0 && offset <= this.getLength())
			return new CurveLocation(curves[curves.length - 1], 1);
		return null;
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			curves = this.getCurves(),
			minDist = Infinity,
			minLoc = null;
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getNearestLocation(point);
			if (loc._distance < minDist) {
				minDist = loc._distance;
				minLoc = loc;
			}
		}
		return minLoc;
	},

	getNearestPoint: function() {
		return this.getNearestLocation.apply(this, arguments).getPoint();
	}
}),
new function() {

	function drawHandles(ctx, segments, matrix, size) {
		var half = size / 2;

		function drawHandle(index) {
			var hX = coords[index],
				hY = coords[index + 1];
			if (pX != hX || pY != hY) {
				ctx.beginPath();
				ctx.moveTo(pX, pY);
				ctx.lineTo(hX, hY);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
				ctx.fill();
			}
		}

		var coords = new Array(6);
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			var state = segment._selectionState,
				pX = coords[0],
				pY = coords[1];
			if (state & 1)
				drawHandle(2);
			if (state & 2)
				drawHandle(4);
			ctx.fillRect(pX - half, pY - half, size, size);
			if (!(state & 4)) {
				var fillStyle = ctx.fillStyle;
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
				ctx.fillStyle = fillStyle;
			}
		}
	}

	function drawSegments(ctx, path, matrix) {
		var segments = path._segments,
			length = segments.length,
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY;

		function drawSegment(segment) {
			if (matrix) {
				segment._transformCoordinates(matrix, coords, false);
				curX = coords[0];
				curY = coords[1];
			} else {
				var point = segment._point;
				curX = point._x;
				curY = point._y;
			}
			if (first) {
				ctx.moveTo(curX, curY);
				first = false;
			} else {
				if (matrix) {
					inX = coords[2];
					inY = coords[3];
				} else {
					var handle = segment._handleIn;
					inX = curX + handle._x;
					inY = curY + handle._y;
				}
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					ctx.lineTo(curX, curY);
				} else {
					ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
				}
			}
			prevX = curX;
			prevY = curY;
			if (matrix) {
				outX = coords[4];
				outY = coords[5];
			} else {
				var handle = segment._handleOut;
				outX = prevX + handle._x;
				outY = prevY + handle._y;
			}
		}

		for (var i = 0; i < length; i++)
			drawSegment(segments[i]);
		if (path._closed && length > 0)
			drawSegment(segments[0]);
	}

	return {
		_draw: function(ctx, param, strokeMatrix) {
			var dontStart = param.dontStart,
				dontPaint = param.dontFinish || param.clip,
				style = this.getStyle(),
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dashArray = style.getDashArray(),
				dashLength = !paper.support.nativeDash && hasStroke
						&& dashArray && dashArray.length;

			if (!dontStart)
				ctx.beginPath();

			if (!dontStart && this._currentPath) {
				ctx.currentPath = this._currentPath;
			} else if (hasFill || hasStroke && !dashLength || dontPaint) {
				drawSegments(ctx, this, strokeMatrix);
				if (this._closed)
					ctx.closePath();
				if (!dontStart)
					this._currentPath = ctx.currentPath;
			}

			function getOffset(i) {
				return dashArray[((i % dashLength) + dashLength) % dashLength];
			}

			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx);
				if (hasFill) {
					ctx.fill(style.getWindingRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke) {
					if (dashLength) {
						if (!dontStart)
							ctx.beginPath();
						var iterator = new PathIterator(this, 32, 0.25,
								strokeMatrix),
							length = iterator.length,
							from = -style.getDashOffset(), to,
							i = 0;
						from = from % length;
						while (from > 0) {
							from -= getOffset(i--) + getOffset(i--);
						}
						while (from < length) {
							to = from + getOffset(i++);
							if (from > 0 || to > 0)
								iterator.drawPart(ctx,
										Math.max(from, 0), Math.max(to, 0));
							from = to + getOffset(i++);
						}
					}
					ctx.stroke();
				}
			}
		},

		_drawSelected: function(ctx, matrix) {
			ctx.beginPath();
			drawSegments(ctx, this, matrix);
			ctx.stroke();
			drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
		}
	};
},
new function() {
	function getFirstControlPoints(rhs) {
		var n = rhs.length,
			x = [],
			tmp = [],
			b = 2;
		x[0] = rhs[0] / b;
		for (var i = 1; i < n; i++) {
			tmp[i] = 1 / b;
			b = (i < n - 1 ? 4 : 2) - tmp[i];
			x[i] = (rhs[i] - x[i - 1]) / b;
		}
		for (var i = 1; i < n; i++) {
			x[n - i - 1] -= tmp[n - i] * x[n - i];
		}
		return x;
	}

	return {
		smooth: function() {
			var segments = this._segments,
				size = segments.length,
				closed = this._closed,
				n = size,
				overlap = 0;
			if (size <= 2)
				return;
			if (closed) {
				overlap = Math.min(size, 4);
				n += Math.min(size, overlap) * 2;
			}
			var knots = [];
			for (var i = 0; i < size; i++)
				knots[i + overlap] = segments[i]._point;
			if (closed) {
				for (var i = 0; i < overlap; i++) {
					knots[i] = segments[i + size - overlap]._point;
					knots[i + size + overlap] = segments[i]._point;
				}
			} else {
				n--;
			}
			var rhs = [];

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
			rhs[0] = knots[0]._x + 2 * knots[1]._x;
			rhs[n - 1] = 3 * knots[n - 1]._x;
			var x = getFirstControlPoints(rhs);

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
			rhs[0] = knots[0]._y + 2 * knots[1]._y;
			rhs[n - 1] = 3 * knots[n - 1]._y;
			var y = getFirstControlPoints(rhs);

			if (closed) {
				for (var i = 0, j = size; i < overlap; i++, j++) {
					var f1 = i / overlap,
						f2 = 1 - f1,
						ie = i + overlap,
						je = j + overlap;
					x[j] = x[i] * f1 + x[j] * f2;
					y[j] = y[i] * f1 + y[j] * f2;
					x[je] = x[ie] * f2 + x[je] * f1;
					y[je] = y[ie] * f2 + y[je] * f1;
				}
				n--;
			}
			var handleIn = null;
			for (var i = overlap; i <= n - overlap; i++) {
				var segment = segments[i - overlap];
				if (handleIn)
					segment.setHandleIn(handleIn.subtract(segment._point));
				if (i < n) {
					segment.setHandleOut(
							new Point(x[i], y[i]).subtract(segment._point));
					handleIn = i < n - 1
							? new Point(
								2 * knots[i + 1]._x - x[i + 1],
								2 * knots[i + 1]._y - y[i + 1])
							: new Point(
								(knots[n]._x + x[n - 1]) / 2,
								(knots[n]._y + y[n - 1]) / 2);
				}
			}
			if (closed && handleIn) {
				var segment = this._segments[0];
				segment.setHandleIn(handleIn.subtract(segment._point));
			}
		}
	};
},
new function() {
	function getCurrentSegment(that) {
		var segments = that._segments;
		if (segments.length === 0)
			throw new Error('Use a moveTo() command first');
		return segments[segments.length - 1];
	}

	return {
		moveTo: function() {
			var segments = this._segments;
			if (segments.length === 1)
				this.removeSegment(0);
			if (!segments.length)
				this._add([ new Segment(Point.read(arguments)) ]);
		},

		moveBy: function() {
			throw new Error('moveBy() is unsupported on Path items.');
		},

		lineTo: function() {
			this._add([ new Segment(Point.read(arguments)) ]);
		},

		cubicCurveTo: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this);
			current.setHandleOut(handle1.subtract(current._point));
			this._add([ new Segment(to, handle2.subtract(to)) ]);
		},

		quadraticCurveTo: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(
				handle.add(current.subtract(handle).multiply(1 / 3)),
				handle.add(to.subtract(handle).multiply(1 / 3)),
				to
			);
		},

		curveTo: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				t = Base.pick(Base.read(arguments), 0.5),
				t1 = 1 - t,
				current = getCurrentSegment(this)._point,
				handle = through.subtract(current.multiply(t1 * t1))
					.subtract(to.multiply(t * t)).divide(2 * t * t1);
			if (handle.isNaN())
				throw new Error(
					'Cannot put a curve through points with parameter = ' + t);
			this.quadraticCurveTo(handle, to);
		},

		arcTo: function() {
			var current = getCurrentSegment(this),
				from = current._point,
				to = Point.read(arguments),
				through,
				peek = Base.peek(arguments),
				clockwise = Base.pick(peek, true),
				center, extent, vector, matrix;
			if (typeof clockwise === 'boolean') {
				var middle = from.add(to).divide(2),
				through = middle.add(middle.subtract(from).rotate(
						clockwise ? -90 : 90));
			} else if (Base.remain(arguments) <= 2) {
				through = to;
				to = Point.read(arguments);
			} else {
				var radius = Size.read(arguments);
				if (radius.isZero())
					return this.lineTo(to);
				var rotation = Base.read(arguments),
					clockwise = !!Base.read(arguments),
					large = !!Base.read(arguments),
					middle = from.add(to).divide(2),
					pt = from.subtract(middle).rotate(-rotation),
					x = pt.x,
					y = pt.y,
					abs = Math.abs,
					rx = abs(radius.width),
					ry = abs(radius.height),
					rxSq = rx * rx,
					rySq = ry * ry,
					xSq =  x * x,
					ySq =  y * y;
				var factor = Math.sqrt(xSq / rxSq + ySq / rySq);
				if (factor > 1) {
					rx *= factor;
					ry *= factor;
					rxSq = rx * rx;
					rySq = ry * ry;
				}
				factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
						(rxSq * ySq + rySq * xSq);
				if (abs(factor) < 1e-12)
					factor = 0;
				if (factor < 0)
					throw new Error(
							'Cannot create an arc with the given arguments');
				center = new Point(rx * y / ry, -ry * x / rx)
						.multiply((large === clockwise ? -1 : 1)
							* Math.sqrt(factor))
						.rotate(rotation).add(middle);
				matrix = new Matrix().translate(center).rotate(rotation)
						.scale(rx, ry);
				vector = matrix._inverseTransform(from);
				extent = vector.getDirectedAngle(matrix._inverseTransform(to));
				if (!clockwise && extent > 0)
					extent -= 360;
				else if (clockwise && extent < 0)
					extent += 360;
			}
			if (through) {
				var l1 = new Line(from.add(through).divide(2),
							through.subtract(from).rotate(90), true),
					l2 = new Line(through.add(to).divide(2),
							to.subtract(through).rotate(90), true),
					line = new Line(from, to),
					throughSide = line.getSide(through);
				center = l1.intersect(l2, true);
				if (!center) {
					if (!throughSide)
						return this.lineTo(to);
					throw new Error(
							'Cannot create an arc with the given arguments');
				}
				vector = from.subtract(center);
				extent = vector.getDirectedAngle(to.subtract(center));
				var centerSide = line.getSide(center);
				if (centerSide === 0) {
					extent = throughSide * Math.abs(extent);
				} else if (throughSide === centerSide) {
					extent += extent < 0 ? 360 : -360;
				}
			}
			var ext = Math.abs(extent),
				count = ext >= 360 ? 4 : Math.ceil(ext / 90),
				inc = extent / count,
				half = inc * Math.PI / 360,
				z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
				segments = [];
			for (var i = 0; i <= count; i++) {
				var pt = to,
					out = null;
				if (i < count) {
					out = vector.rotate(90).multiply(z);
					if (matrix) {
						pt = matrix._transformPoint(vector);
						out = matrix._transformPoint(vector.add(out))
								.subtract(pt);
					} else {
						pt = center.add(vector);
					}
				}
				if (i === 0) {
					current.setHandleOut(out);
				} else {
					var _in = vector.rotate(-90).multiply(z);
					if (matrix) {
						_in = matrix._transformPoint(vector.add(_in))
								.subtract(pt);
					}
					segments.push(new Segment(pt, _in, out));
				}
				vector = vector.rotate(inc);
			}
			this._add(segments);
		},

		lineBy: function() {
			var to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.lineTo(current.add(to));
		},

		curveBy: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				parameter = Base.read(arguments),
				current = getCurrentSegment(this)._point;
			this.curveTo(current.add(through), current.add(to), parameter);
		},

		cubicCurveBy: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(current.add(handle1), current.add(handle2),
					current.add(to));
		},

		quadraticCurveBy: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.quadraticCurveTo(current.add(handle), current.add(to));
		},

		arcBy: function() {
			var current = getCurrentSegment(this)._point,
				point = current.add(Point.read(arguments)),
				clockwise = Base.pick(Base.peek(arguments), true);
			if (typeof clockwise === 'boolean') {
				this.arcTo(point, clockwise);
			} else {
				this.arcTo(point, current.add(Point.read(arguments)));
			}
		},

		closePath: function(join) {
			this.setClosed(true);
			if (join)
				this.join();
		}
	};
}, {

	_getBounds: function(getter, matrix) {
		return Path[getter](this._segments, this._closed, this.getStyle(),
				matrix);
	},

statics: {
	getBounds: function(segments, closed, style, matrix, strokePadding) {
		var first = segments[0];
		if (!first)
			return new Rectangle();
		var coords = new Array(6),
			prevCoords = first._transformCoordinates(matrix, new Array(6), false),
			min = prevCoords.slice(0, 2),
			max = min.slice(),
			roots = new Array(2);

		function processSegment(segment) {
			segment._transformCoordinates(matrix, coords, false);
			for (var i = 0; i < 2; i++) {
				Curve._addBounds(
					prevCoords[i],
					prevCoords[i + 4],
					coords[i + 2],
					coords[i],
					i, strokePadding ? strokePadding[i] : 0, min, max, roots);
			}
			var tmp = prevCoords;
			prevCoords = coords;
			coords = tmp;
		}

		for (var i = 1, l = segments.length; i < l; i++)
			processSegment(segments[i]);
		if (closed)
			processSegment(first);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	getStrokeBounds: function(segments, closed, style, matrix) {
		if (!style.hasStroke())
			return Path.getBounds(segments, closed, style, matrix);
		var length = segments.length - (closed ? 0 : 1),
			radius = style.getStrokeWidth() / 2,
			padding = Path._getPenPadding(radius, matrix),
			bounds = Path.getBounds(segments, closed, style, matrix, padding),
			join = style.getStrokeJoin(),
			cap = style.getStrokeCap(),
			miterLimit = radius * style.getMiterLimit();
		var joinBounds = new Rectangle(new Size(padding).multiply(2));

		function add(point) {
			bounds = bounds.include(matrix
				? matrix._transformPoint(point, point) : point);
		}

		function addRound(segment) {
			bounds = bounds.unite(joinBounds.setCenter(matrix
				? matrix._transformPoint(segment._point) : segment._point));
		}

		function addJoin(segment, join) {
			var handleIn = segment._handleIn,
				handleOut = segment._handleOut;
			if (join === 'round' || !handleIn.isZero() && !handleOut.isZero()
					&& handleIn.isCollinear(handleOut)) {
				addRound(segment);
			} else {
				Path._addBevelJoin(segment, join, radius, miterLimit, add);
			}
		}

		function addCap(segment, cap) {
			if (cap === 'round') {
				addRound(segment);
			} else {
				Path._addSquareCap(segment, cap, radius, add);
			}
		}

		for (var i = 1; i < length; i++)
			addJoin(segments[i], join);
		if (closed) {
			addJoin(segments[0], join);
		} else if (length > 0) {
			addCap(segments[0], cap);
			addCap(segments[segments.length - 1], cap);
		}
		return bounds;
	},

	_getPenPadding: function(radius, matrix) {
		if (!matrix)
			return [radius, radius];
		var mx = matrix.shiftless(),
			hor = mx.transform(new Point(radius, 0)),
			ver = mx.transform(new Point(0, radius)),
			phi = hor.getAngleInRadians(),
			a = hor.getLength(),
			b = ver.getLength();
		var sin = Math.sin(phi),
			cos = Math.cos(phi),
			tan = Math.tan(phi),
			tx = -Math.atan(b * tan / a),
			ty = Math.atan(b / (tan * a));
		return [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),
				Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
	},

	_addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {
		var curve2 = segment.getCurve(),
			curve1 = curve2.getPrevious(),
			point = curve2.getPointAt(0, true),
			normal1 = curve1.getNormalAt(1, true),
			normal2 = curve2.getNormalAt(0, true),
			step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
		normal1.setLength(step);
		normal2.setLength(step);
		if (area) {
			addPoint(point);
			addPoint(point.add(normal1));
		}
		if (join === 'miter') {
			var corner = new Line(
					point.add(normal1),
					new Point(-normal1.y, normal1.x), true
				).intersect(new Line(
					point.add(normal2),
					new Point(-normal2.y, normal2.x), true
				), true);
			if (corner && point.getDistance(corner) <= miterLimit) {
				addPoint(corner);
				if (!area)
					return;
			}
		}
		if (!area)
			addPoint(point.add(normal1));
		addPoint(point.add(normal2));
	},

	_addSquareCap: function(segment, cap, radius, addPoint, area) {
		var point = segment._point,
			loc = segment.getLocation(),
			normal = loc.getNormal().multiply(radius);
		if (area) {
			addPoint(point.subtract(normal));
			addPoint(point.add(normal));
		}
		if (cap === 'square')
			point = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));
		addPoint(point.add(normal));
		addPoint(point.subtract(normal));
	},

	getHandleBounds: function(segments, closed, style, matrix, strokePadding,
			joinPadding) {
		var coords = new Array(6),
			x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			for (var j = 0; j < 6; j += 2) {
				var padding = j === 0 ? joinPadding : strokePadding,
					paddingX = padding ? padding[0] : 0,
					paddingY = padding ? padding[1] : 0,
					x = coords[j],
					y = coords[j + 1],
					xn = x - paddingX,
					xx = x + paddingX,
					yn = y - paddingY,
					yx = y + paddingY;
				if (xn < x1) x1 = xn;
				if (xx > x2) x2 = xx;
				if (yn < y1) y1 = yn;
				if (yx > y2) y2 = yx;
			}
		}
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	getRoughBounds: function(segments, closed, style, matrix) {
		var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,
			joinRadius = strokeRadius;
		if (strokeRadius > 0) {
			if (style.getStrokeJoin() === 'miter')
				joinRadius = strokeRadius * style.getMiterLimit();
			if (style.getStrokeCap() === 'square')
				joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));
		}
		return Path.getHandleBounds(segments, closed, style, matrix,
				Path._getPenPadding(strokeRadius, matrix),
				Path._getPenPadding(joinRadius, matrix));
	}
}});

Path.inject({ statics: new function() {

	var kappa = 0.5522847498307936,
		ellipseSegments = [
			new Segment([-1, 0], [0, kappa ], [0, -kappa]),
			new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
			new Segment([1, 0], [0, -kappa], [0, kappa ]),
			new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
		];

	function createPath(segments, closed, args) {
		var props = Base.getNamed(args),
			path = new Path(props && props.insert === false && Item.NO_INSERT);
		path._add(segments);
		path._closed = closed;
		return path.set(props);
	}

	function createEllipse(center, radius, args) {
		var segments = new Array(4);
		for (var i = 0; i < 4; i++) {
			var segment = ellipseSegments[i];
			segments[i] = new Segment(
				segment._point.multiply(radius).add(center),
				segment._handleIn.multiply(radius),
				segment._handleOut.multiply(radius)
			);
		}
		return createPath(segments, true, args);
	}

	return {
		Line: function() {
			return createPath([
				new Segment(Point.readNamed(arguments, 'from')),
				new Segment(Point.readNamed(arguments, 'to'))
			], false, arguments);
		},

		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createEllipse(center, new Size(radius), arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.readNamed(arguments, 'radius', 0,
						{ readNull: true }),
				bl = rect.getBottomLeft(true),
				tl = rect.getTopLeft(true),
				tr = rect.getTopRight(true),
				br = rect.getBottomRight(true),
				segments;
			if (!radius || radius.isZero()) {
				segments = [
					new Segment(bl),
					new Segment(tl),
					new Segment(tr),
					new Segment(br)
				];
			} else {
				radius = Size.min(radius, rect.getSize(true).divide(2));
				var rx = radius.width,
					ry = radius.height,
					hx = rx * kappa,
					hy = ry * kappa;
				segments = [
					new Segment(bl.add(rx, 0), null, [-hx, 0]),
					new Segment(bl.subtract(0, ry), [0, hy]),
					new Segment(tl.add(0, ry), null, [0, -hy]),
					new Segment(tl.add(rx, 0), [-hx, 0], null),
					new Segment(tr.subtract(rx, 0), null, [hx, 0]),
					new Segment(tr.add(0, ry), [0, -hy], null),
					new Segment(br.subtract(0, ry), null, [0, hy]),
					new Segment(br.subtract(rx, 0), [hx, 0])
				];
			}
			return createPath(segments, true, arguments);
		},

		RoundRectangle: '#Rectangle',

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments);
			return createEllipse(ellipse.center, ellipse.radius, arguments);
		},

		Oval: '#Ellipse',

		Arc: function() {
			var from = Point.readNamed(arguments, 'from'),
				through = Point.readNamed(arguments, 'through'),
				to = Point.readNamed(arguments, 'to'),
				props = Base.getNamed(arguments),
				path = new Path(props && props.insert === false
						&& Item.NO_INSERT);
			path.moveTo(from);
			path.arcTo(through, to);
			return path.set(props);
		},

		RegularPolygon: function() {
			var center = Point.readNamed(arguments, 'center'),
				sides = Base.readNamed(arguments, 'sides'),
				radius = Base.readNamed(arguments, 'radius'),
				step = 360 / sides,
				three = !(sides % 3),
				vector = new Point(0, three ? -radius : radius),
				offset = three ? -1 : 0.5,
				segments = new Array(sides);
			for (var i = 0; i < sides; i++)
				segments[i] = new Segment(center.add(
					vector.rotate((i + offset) * step)));
			return createPath(segments, true, arguments);
		},

		Star: function() {
			var center = Point.readNamed(arguments, 'center'),
				points = Base.readNamed(arguments, 'points') * 2,
				radius1 = Base.readNamed(arguments, 'radius1'),
				radius2 = Base.readNamed(arguments, 'radius2'),
				step = 360 / points,
				vector = new Point(0, -1),
				segments = new Array(points);
			for (var i = 0; i < points; i++)
				segments[i] = new Segment(center.add(vector.rotate(step * i)
						.multiply(i % 2 ? radius2 : radius1)));
			return createPath(segments, true, arguments);
		}
	};
}});

var CompoundPath = PathItem.extend({
	_class: 'CompoundPath',
	_serializeFields: {
		children: []
	},

	initialize: function CompoundPath(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg)) {
			if (typeof arg === 'string') {
				this.setPathData(arg);
			} else {
				this.addChildren(Array.isArray(arg) ? arg : arguments);
			}
		}
	},

	insertChildren: function insertChildren(index, items, _preserve) {
		for (var i = items.length - 1; i >= 0; i--) {
			var item = items[i];
			if (item instanceof CompoundPath) {
				items.splice.apply(items, [i, 1].concat(item.removeChildren()));
				item.remove();
			}
		}
		items = insertChildren.base.call(this, index, items, _preserve, Path);
		for (var i = 0, l = !_preserve && items && items.length; i < l; i++) {
			var item = items[i];
			if (item._clockwise === undefined)
				item.setClockwise(item._index === 0);
		}
		return items;
	},

	reverse: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++)
			children[i].reverse();
	},

	smooth: function() {
		for (var i = 0, l = this._children.length; i < l; i++)
			this._children[i].smooth();
	},

	reduce: function reduce() {
		var children = this._children;
		for (var i = children.length - 1; i >= 0; i--) {
			var path = children[i].reduce();
			if (path.isEmpty())
				children.splice(i, 1);
		}
		if (children.length === 0) {
			var path = new Path(Item.NO_INSERT);
			path.insertAbove(this);
			path.setStyle(this._style);
			this.remove();
			return path;
		}
		return reduce.base.call(this);
	},

	isClockwise: function() {
		var child = this.getFirstChild();
		return child && child.isClockwise();
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() !== !!clockwise)
			this.reverse();
	},

	getFirstSegment: function() {
		var first = this.getFirstChild();
		return first && first.getFirstSegment();
	},

	getLastSegment: function() {
		var last = this.getLastChild();
		return last && last.getLastSegment();
	},

	getCurves: function() {
		var children = this._children,
			curves = [];
		for (var i = 0, l = children.length; i < l; i++)
			curves.push.apply(curves, children[i].getCurves());
		return curves;
	},

	getFirstCurve: function() {
		var first = this.getFirstChild();
		return first && first.getFirstCurve();
	},

	getLastCurve: function() {
		var last = this.getLastChild();
		return last && last.getFirstCurve();
	},

	getArea: function() {
		var children = this._children,
			area = 0;
		for (var i = 0, l = children.length; i < l; i++)
			area += children[i].getArea();
		return area;
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var children = this._children,
			paths = [];
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			paths.push(child.getPathData(_matrix && !mx.isIdentity()
					? _matrix.chain(mx) : _matrix, _precision));
		}
		return paths.join(' ');
	}
}, {
	_getChildHitTestOptions: function(options) {
		return options.class === Path || options.type === 'path'
				? options
				: new Base(options, { fill: false });
	},

	_draw: function(ctx, param, strokeMatrix) {
		var children = this._children;
		if (children.length === 0)
			return;

		if (this._currentPath) {
			ctx.currentPath = this._currentPath;
		} else {
			param = param.extend({ dontStart: true, dontFinish: true });
			ctx.beginPath();
			for (var i = 0, l = children.length; i < l; i++)
				children[i].draw(ctx, param, strokeMatrix);
			this._currentPath = ctx.currentPath;
		}

		if (!param.clip) {
			this._setStyles(ctx);
			var style = this._style;
			if (style.hasFill()) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.stroke();
		}
	},

	_drawSelected: function(ctx, matrix, selectedItems) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			if (!selectedItems[child._id])
				child._drawSelected(ctx, mx.isIdentity() ? matrix
						: matrix.chain(mx));
		}
	}
},
new function() {
	function getCurrentPath(that, check) {
		var children = that._children;
		if (check && children.length === 0)
			throw new Error('Use a moveTo() command first');
		return children[children.length - 1];
	}

	var fields = {
		moveTo: function() {
			var current = getCurrentPath(this),
				path = current && current.isEmpty() ? current
						: new Path(Item.NO_INSERT);
			if (path !== current)
				this.addChild(path);
			path.moveTo.apply(path, arguments);
		},

		moveBy: function() {
			var current = getCurrentPath(this, true),
				last = current && current.getLastSegment(),
				point = Point.read(arguments);
			this.moveTo(last ? point.add(last._point) : point);
		},

		closePath: function(join) {
			getCurrentPath(this, true).closePath(join);
		}
	};

	Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',
			'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],
			function(key) {
				fields[key] = function() {
					var path = getCurrentPath(this, true);
					path[key].apply(path, arguments);
				};
			}
	);

	return fields;
});

PathItem.inject(new function() {
	var operators = {
		unite: function(w) {
			return w === 1 || w === 0;
		},

		intersect: function(w) {
			return w === 2;
		},

		subtract: function(w) {
			return w === 1;
		},

		exclude: function(w) {
			return w === 1;
		}
	};

	function preparePath(path, resolve) {
		var res = path.clone(false).reduce().transform(null, true, true);
		return resolve ? res.resolveCrossings().reorient() : res;
	}

	function finishBoolean(ctor, paths, path1, path2, reduce) {
		var result = new ctor(Item.NO_INSERT);
		result.addChildren(paths, true);
		if (reduce)
			result = result.reduce();
		result.insertAbove(path2 && path1.isSibling(path2)
				&& path1.getIndex() < path2.getIndex()
					? path2 : path1);
		result.setStyle(path1._style);
		return result;
	}

	function computeBoolean(path1, path2, operation) {
		if (!path1._children && !path1._closed)
			return computeOpenBoolean(path1, path2, operation);
		var _path1 = preparePath(path1, true),
			_path2 = path2 && path1 !== path2 && preparePath(path2, true);
		if (_path2 && /^(subtract|exclude)$/.test(operation)
				^ (_path2.isClockwise() !== _path1.isClockwise()))
			_path2.reverse();
		var intersections = CurveLocation.expand(
			_path1.getIntersections(_path2, function(inter) {
				return _path2 && inter.isOverlap() || inter.isCrossing();
			})
		);
		divideLocations(intersections);

		var segments = [],
			monoCurves = [];

		function collect(paths) {
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				segments.push.apply(segments, path._segments);
				monoCurves.push.apply(monoCurves, path._getMonoCurves());
			}
		}

		collect(_path1._children || [_path1]);
		if (_path2)
			collect(_path2._children || [_path2]);
		for (var i = 0, l = intersections.length; i < l; i++) {
			propagateWinding(intersections[i]._segment, _path1, _path2,
					monoCurves, operation);
		}
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			if (segment._winding == null) {
				propagateWinding(segment, _path1, _path2, monoCurves,
						operation);
			}
		}
		return finishBoolean(CompoundPath, tracePaths(segments, operation),
				path1, path2, true);
	}

	function computeOpenBoolean(path1, path2, operation) {
		if (!path2 || !path2._children && !path2._closed
				|| !/^(subtract|intersect)$/.test(operation))
			return null;
		var _path1 = preparePath(path1, false),
			_path2 = preparePath(path2, false),
			intersections = _path1.getIntersections(_path2, function(inter) {
				return inter.isOverlap() || inter.isCrossing();
			}),
			sub = operation === 'subtract',
			paths = [];

		function addPath(path) {
			if (_path2.contains(path.getPointAt(path.getLength() / 2)) ^ sub) {
				paths.unshift(path);
				return true;
			}
		}

		for (var i = intersections.length - 1; i >= 0; i--) {
			var path = intersections[i].split();
			if (path) {
				if (addPath(path))
					path.getFirstSegment().setHandleIn(0, 0);
				_path1.getLastSegment().setHandleOut(0, 0);
			}
		}
		addPath(_path1);
		return finishBoolean(Group, paths, path1, path2);
	}

	function linkIntersections(from, to) {
		var prev = from;
		while (prev) {
			if (prev === to)
				return;
			prev = prev._prev;
		}
		while (from._next && from._next !== to)
			from = from._next;
		if (!from._next) {
			while (to._prev)
				to = to._prev;
			from._next = to;
			to._prev = from;
		}
	}

	function divideLocations(locations) {
		var tMin = 4e-7,
			tMax = 1 - tMin,
			noHandles = false,
			clearSegments = [],
			prevCurve,
			prevT;

		for (var i = locations.length - 1; i >= 0; i--) {
			var loc = locations[i],
				curve = loc._curve,
				t = loc._parameter,
				origT = t;
			if (curve !== prevCurve) {
				noHandles = !curve.hasHandles();
			} else if (prevT > 0) {
				t /= prevT;
			}
			var segment;
			if (t < tMin) {
				segment = curve._segment1;
			} else if (t > tMax) {
				segment = curve._segment2;
			} else {
				segment = curve.divide(t, true, true)._segment1;
				if (noHandles)
					clearSegments.push(segment);
			}
			loc._setSegment(segment);
			var inter = segment._intersection,
				dest = loc._intersection;
			if (inter) {
				linkIntersections(inter, dest);
				var other = inter;
				while (other) {
					linkIntersections(other._intersection, inter);
					other = other._next;
				}
			} else {
				segment._intersection = dest;
			}
			prevCurve = curve;
			prevT = origT;
		}
		for (var i = 0, l = clearSegments.length; i < l; i++) {
			clearSegments[i].clearHandles();
		}
	}

	function getWinding(point, curves, horizontal, testContains) {
		var epsilon = 2e-7,
			tMin = 4e-7,
			tMax = 1 - tMin,
			px = point.x,
			py = point.y,
			windLeft = 0,
			windRight = 0,
			roots = [],
			abs = Math.abs;
		if (horizontal) {
			var yTop = -Infinity,
				yBottom = Infinity,
				yBefore = py - epsilon,
				yAfter = py + epsilon;
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if (Curve.solveCubic(values, 0, px, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--) {
						var y = Curve.getPoint(values, roots[j]).y;
						if (y < yBefore && y > yTop) {
							yTop = y;
						} else if (y > yAfter && y < yBottom) {
							yBottom = y;
						}
					}
				}
			}
			yTop = (yTop + py) / 2;
			yBottom = (yBottom + py) / 2;
			if (yTop > -Infinity)
				windLeft = getWinding(new Point(px, yTop), curves, false,
						testContains);
			if (yBottom < Infinity)
				windRight = getWinding(new Point(px, yBottom), curves, false,
						testContains);
		} else {
			var xBefore = px - epsilon,
				xAfter = px + epsilon;
			var startCounted = false,
				prevCurve,
				prevT;
			for (var i = 0, l = curves.length; i < l; i++) {
				var curve = curves[i],
					values = curve.values,
					winding = curve.winding;
				if (winding && (winding === 1
						&& py >= values[1] && py <= values[7]
						|| py >= values[7] && py <= values[1])
					&& Curve.solveCubic(values, 1, py, roots, 0, 1) === 1) {
					var t = roots[0];
					if (!(
						t > tMax && startCounted && curve.next !== curves[i + 1]
						|| t < tMin && prevT > tMax
							&& curve.previous === prevCurve)) {
						var x = Curve.getPoint(values, t).x,
							slope = Curve.getTangent(values, t).y,
							counted = false;
						if (Numerical.isZero(slope) && !Curve.isStraight(values)
								|| t < tMin && slope * Curve.getTangent(
									curve.previous.values, 1).y < 0
								|| t > tMax && slope * Curve.getTangent(
									curve.next.values, 0).y < 0) {
							if (testContains && x >= xBefore && x <= xAfter) {
								++windLeft;
								++windRight;
								counted = true;
							}
						} else if (x <= xBefore) {
							windLeft += winding;
							counted = true;
						} else if (x >= xAfter) {
							windRight += winding;
							counted = true;
						}
						if (curve.previous !== curves[i - 1])
							startCounted = t < tMin && counted;
					}
					prevCurve = curve;
					prevT = t;
				}
			}
		}
		return Math.max(abs(windLeft), abs(windRight));
	}

	function propagateWinding(segment, path1, path2, monoCurves, operation) {
		var epsilon = 2e-7,
			chain = [],
			start = segment,
			totalLength = 0,
			windingSum = 0;
		do {
			var curve = segment.getCurve(),
				length = curve.getLength();
			chain.push({ segment: segment, curve: curve, length: length });
			totalLength += length;
			segment = segment.getNext();
		} while (segment && !segment._intersection && segment !== start);
		for (var i = 0; i < 3; i++) {
			var length = totalLength * (i + 1) / 4;
			for (var k = 0, m = chain.length; k < m; k++) {
				var node = chain[k],
					curveLength = node.length;
				if (length <= curveLength) {
					if (length < epsilon || curveLength - length < epsilon)
						length = curveLength / 2;
					var curve = node.curve,
						path = curve._path,
						parent = path._parent,
						pt = curve.getPointAt(length),
						hor = curve.isHorizontal();
					if (parent instanceof CompoundPath)
						path = parent;
					windingSum += operation === 'subtract' && path2
						&& (path === path1 && path2._getWinding(pt, hor)
						|| path === path2 && !path1._getWinding(pt, hor))
						? 0
						: getWinding(pt, monoCurves, hor);
					break;
				}
				length -= curveLength;
			}
		}
		var winding = Math.round(windingSum / 3);
		for (var j = chain.length - 1; j >= 0; j--)
			chain[j].segment._winding = winding;
	}

	function tracePaths(segments, operation) {
		var paths = [],
			start,
			otherStart,
			operator = operators[operation],
			overlapWinding = {
				unite: { 1: 2 },
				intersect: { 2: 1 }
			}[operation];

		function isValid(seg, adjusted) {
			if (seg._visited)
				return false;
			if (!operator)
				return true;
			var winding = seg._winding,
				inter = seg._intersection;
			if (inter && adjusted && overlapWinding && inter.isOverlap())
				winding = overlapWinding[winding] || winding;
			return operator(winding);
		}

		function isStart(seg) {
			return seg === start || seg === otherStart;
		}

		function findBestIntersection(inter, strict) {
			if (!inter._next)
				return inter;
			while (inter) {
				var seg = inter._segment,
					nextSeg = seg.getNext(),
					nextInter = nextSeg._intersection;
				if (isStart(nextSeg)
					|| !seg._visited && !nextSeg._visited
					&& (!operator
						|| (!strict || isValid(seg))
						&& (!(strict && nextInter && nextInter.isOverlap())
							&& isValid(nextSeg)
							|| !strict && nextInter
							&& isValid(nextInter._segment))
					))
					return inter;
				inter = inter._next;
			}
			return null;
		}

		function findStartSegment(inter, next) {
			while (inter) {
				var seg = inter._segment;
				if (isStart(seg))
					return seg;
				inter = inter[next ? '_next' : '_prev'];
			}
		}

		for (var i = 0, l = segments.length; i < l; i++) {
			var seg = segments[i],
				path = null,
				finished = false;
			if (!isValid(seg, true))
				continue;
			start = otherStart = null;
			while (!finished) {
				var inter = seg._intersection,
					handleIn = path && seg._handleIn;
				inter = inter && (findBestIntersection(inter, true)
						|| findBestIntersection(inter, false)) || inter;
				var other = inter && inter._segment;
				if (other && isValid(other))
					seg = other;
				if (seg._visited) {
					finished = isStart(seg);
					if (!finished && inter) {
						var found = findStartSegment(inter, true)
							|| findStartSegment(inter, false);
						if (found) {
							seg = found;
							finished = true;
						}
					}
					break;
				}
				if (!path) {
					path = new Path(Item.NO_INSERT);
					start = seg;
					otherStart = other;
				}
				path.add(new Segment(seg._point, handleIn, seg._handleOut));
				seg._visited = true;
				seg = seg.getNext();
				finished = isStart(seg);
			}
			if (finished) {
				path.firstSegment.setHandleIn(seg._handleIn);
				path.setClosed(true);
			} else if (path) {
				console.error('Boolean operation resulted in open path',
						'segments =', path._segments.length,
						'length =', path.getLength());
				path = null;
			}
			if (path && (path._segments.length > 8
					|| !Numerical.isZero(path.getArea()))) {
				paths.push(path);
				path = null;
			}
		}
		return paths;
	}

	return {
		_getWinding: function(point, horizontal, testContains) {
			return getWinding(point, this._getMonoCurves(),
					horizontal, testContains);
		},

		unite: function(path) {
			return computeBoolean(this, path, 'unite');
		},

		intersect: function(path) {
			return computeBoolean(this, path, 'intersect');
		},

		subtract: function(path) {
			return computeBoolean(this, path, 'subtract');
		},

		exclude: function(path) {
			return computeBoolean(this, path, 'exclude');
		},

		divide: function(path) {
			return finishBoolean(Group,
					[this.subtract(path), this.intersect(path)],
					this, path, true);
		},

		resolveCrossings: function() {
			var crossings = this.getCrossings();
			if (!crossings.length)
				return this;
			divideLocations(CurveLocation.expand(crossings));
			var paths = this._children || [this],
				segments = [];
			for (var i = 0, l = paths.length; i < l; i++) {
				segments.push.apply(segments, paths[i]._segments);
			}
			return finishBoolean(CompoundPath, tracePaths(segments),
					this, null, false);
		}
	};
});

Path.inject({
	_getMonoCurves: function() {
		var monoCurves = this._monoCurves,
			prevCurve;

		function insertCurve(v) {
			var y0 = v[1],
				y1 = v[7],
				curve = {
					values: v,
					winding: y0 === y1
						? 0
						: y0 > y1
							? -1
							: 1,
					previous: prevCurve,
					next: null
				};
			if (prevCurve)
				prevCurve.next = curve;
			monoCurves.push(curve);
			prevCurve = curve;
		}

		function handleCurve(v) {
			if (Curve.getLength(v) === 0)
				return;
			var y0 = v[1],
				y1 = v[3],
				y2 = v[5],
				y3 = v[7];
			if (Curve.isStraight(v)) {
				insertCurve(v);
			} else {
				var a = 3 * (y1 - y2) - y0 + y3,
					b = 2 * (y0 + y2) - 4 * y1,
					c = y1 - y0,
					tMin = 4e-7,
					tMax = 1 - tMin,
					roots = [],
					n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);
				if (n === 0) {
					insertCurve(v);
				} else {
					roots.sort();
					var t = roots[0],
						parts = Curve.subdivide(v, t);
					insertCurve(parts[0]);
					if (n > 1) {
						t = (roots[1] - t) / (1 - t);
						parts = Curve.subdivide(parts[1], t);
						insertCurve(parts[0]);
					}
					insertCurve(parts[1]);
				}
			}
		}

		if (!monoCurves) {
			monoCurves = this._monoCurves = [];
			var curves = this.getCurves(),
				segments = this._segments;
			for (var i = 0, l = curves.length; i < l; i++)
				handleCurve(curves[i].getValues());
			if (!this._closed && segments.length > 1) {
				var p1 = segments[segments.length - 1]._point,
					p2 = segments[0]._point,
					p1x = p1._x, p1y = p1._y,
					p2x = p2._x, p2y = p2._y;
				handleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);
			}
			if (monoCurves.length > 0) {
				var first = monoCurves[0],
					last = monoCurves[monoCurves.length - 1];
				first.previous = last;
				last.next = first;
			}
		}
		return monoCurves;
	},

	getInteriorPoint: function() {
		var bounds = this.getBounds(),
			point = bounds.getCenter(true);
		if (!this.contains(point)) {
			var curves = this._getMonoCurves(),
				roots = [],
				y = point.y,
				xIntercepts = [];
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if ((curves[i].winding === 1
						&& y >= values[1] && y <= values[7]
						|| y >= values[7] && y <= values[1])
						&& Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--)
						xIntercepts.push(Curve.getPoint(values, roots[j]).x);
				}
				if (xIntercepts.length > 1)
					break;
			}
			point.x = (xIntercepts[0] + xIntercepts[1]) / 2;
		}
		return point;
	},

	reorient: function() {
		this.setClockwise(true);
		return this;
	}
});

CompoundPath.inject({
	_getMonoCurves: function() {
		var children = this._children,
			monoCurves = [];
		for (var i = 0, l = children.length; i < l; i++)
			monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
		return monoCurves;
	},

	reorient: function() {
		var children = this.removeChildren().sort(function(a, b) {
			return b.getBounds().getArea() - a.getBounds().getArea();
		});
		if (children.length > 0) {
			this.addChildren(children);
			var clockwise = children[0].isClockwise();
			for (var i = 1, l = children.length; i < l; i++) {
				var point = children[i].getInteriorPoint(),
					counters = 0;
				for (var j = i - 1; j >= 0; j--) {
					if (children[j].contains(point))
						counters++;
				}
				children[i].setClockwise(counters % 2 === 0 && clockwise);
			}
		}
		return this;
	}
});

var PathIterator = Base.extend({
	_class: 'PathIterator',

	initialize: function(path, maxRecursion, tolerance, matrix) {
		var curves = [],
			parts = [],
			length = 0,
			minDifference = 1 / (maxRecursion || 32),
			segments = path._segments,
			segment1 = segments[0],
			segment2;

		function addCurve(segment1, segment2) {
			var curve = Curve.getValues(segment1, segment2, matrix);
			curves.push(curve);
			computeParts(curve, segment1._index, 0, 1);
		}

		function computeParts(curve, index, minT, maxT) {
			if ((maxT - minT) > minDifference
					&& !Curve.isFlatEnough(curve, tolerance || 0.25)) {
				var split = Curve.subdivide(curve, 0.5),
					halfT = (minT + maxT) / 2;
				computeParts(split[0], index, minT, halfT);
				computeParts(split[1], index, halfT, maxT);
			} else {
				var x = curve[6] - curve[0],
					y = curve[7] - curve[1],
					dist = Math.sqrt(x * x + y * y);
				if (dist > 1e-6) {
					length += dist;
					parts.push({
						offset: length,
						value: maxT,
						index: index
					});
				}
			}
		}

		for (var i = 1, l = segments.length; i < l; i++) {
			segment2 = segments[i];
			addCurve(segment1, segment2);
			segment1 = segment2;
		}
		if (path._closed)
			addCurve(segment2, segments[0]);

		this.curves = curves;
		this.parts = parts;
		this.length = length;
		this.index = 0;
	},

	getParameterAt: function(offset) {
		var i, j = this.index;
		for (;;) {
			i = j;
			if (j == 0 || this.parts[--j].offset < offset)
				break;
		}
		for (var l = this.parts.length; i < l; i++) {
			var part = this.parts[i];
			if (part.offset >= offset) {
				this.index = i;
				var prev = this.parts[i - 1];
				var prevVal = prev && prev.index == part.index ? prev.value : 0,
					prevLen = prev ? prev.offset : 0;
				return {
					value: prevVal + (part.value - prevVal)
						* (offset - prevLen) / (part.offset - prevLen),
					index: part.index
				};
			}
		}
		var part = this.parts[this.parts.length - 1];
		return {
			value: 1,
			index: part.index
		};
	},

	drawPart: function(ctx, from, to) {
		from = this.getParameterAt(from);
		to = this.getParameterAt(to);
		for (var i = from.index; i <= to.index; i++) {
			var curve = Curve.getPart(this.curves[i],
					i == from.index ? from.value : 0,
					i == to.index ? to.value : 1);
			if (i == from.index)
				ctx.moveTo(curve[0], curve[1]);
			ctx.bezierCurveTo.apply(ctx, curve.slice(2));
		}
	}
}, Base.each(Curve.evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset, weighted) {
			var param = this.getParameterAt(offset);
			return Curve[name](this.curves[param.index], param.value, weighted);
		};
	}, {})
);

var PathFitter = Base.extend({
	initialize: function(path, error) {
		var points = this.points = [],
			segments = path._segments,
			prev;
		for (var i = 0, l = segments.length; i < l; i++) {
			var point = segments[i].point.clone();
			if (!prev || !prev.equals(point)) {
				points.push(point);
				prev = point;
			}
		}

		if (path._closed) {
			this.closed = true;
			points.unshift(points[points.length - 1]);
			points.push(points[1]);
		}

		this.error = error;
	},

	fit: function() {
		var points = this.points,
			length = points.length,
			segments = this.segments = length > 0
					? [new Segment(points[0])] : [];
		if (length > 1)
			this.fitCubic(0, length - 1,
				points[1].subtract(points[0]).normalize(),
				points[length - 2].subtract(points[length - 1]).normalize());

		if (this.closed) {
			segments.shift();
			segments.pop();
		}

		return segments;
	},

	fitCubic: function(first, last, tan1, tan2) {
		if (last - first == 1) {
			var pt1 = this.points[first],
				pt2 = this.points[last],
				dist = pt1.getDistance(pt2) / 3;
			this.addCurve([pt1, pt1.add(tan1.normalize(dist)),
					pt2.add(tan2.normalize(dist)), pt2]);
			return;
		}
		var uPrime = this.chordLengthParameterize(first, last),
			maxError = Math.max(this.error, this.error * this.error),
			split,
			parametersInOrder = true;
		for (var i = 0; i <= 4; i++) {
			var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
			var max = this.findMaxError(first, last, curve, uPrime);
			if (max.error < this.error && parametersInOrder) {
				this.addCurve(curve);
				return;
			}
			split = max.index;
			if (max.error >= maxError)
				break;
			parametersInOrder = this.reparameterize(first, last, uPrime, curve);
			maxError = max.error;
		}
		var V1 = this.points[split - 1].subtract(this.points[split]),
			V2 = this.points[split].subtract(this.points[split + 1]),
			tanCenter = V1.add(V2).divide(2).normalize();
		this.fitCubic(first, split, tan1, tanCenter);
		this.fitCubic(split, last, tanCenter.negate(), tan2);
	},

	addCurve: function(curve) {
		var prev = this.segments[this.segments.length - 1];
		prev.setHandleOut(curve[1].subtract(curve[0]));
		this.segments.push(
				new Segment(curve[3], curve[2].subtract(curve[3])));
	},

	generateBezier: function(first, last, uPrime, tan1, tan2) {
		var epsilon = 1e-12,
			pt1 = this.points[first],
			pt2 = this.points[last],
			C = [[0, 0], [0, 0]],
			X = [0, 0];

		for (var i = 0, l = last - first + 1; i < l; i++) {
			var u = uPrime[i],
				t = 1 - u,
				b = 3 * u * t,
				b0 = t * t * t,
				b1 = b * t,
				b2 = b * u,
				b3 = u * u * u,
				a1 = tan1.normalize(b1),
				a2 = tan2.normalize(b2),
				tmp = this.points[first + i]
					.subtract(pt1.multiply(b0 + b1))
					.subtract(pt2.multiply(b2 + b3));
			C[0][0] += a1.dot(a1);
			C[0][1] += a1.dot(a2);
			C[1][0] = C[0][1];
			C[1][1] += a2.dot(a2);
			X[0] += a1.dot(tmp);
			X[1] += a2.dot(tmp);
		}

		var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
			alpha1, alpha2;
		if (Math.abs(detC0C1) > epsilon) {
			var detC0X	= C[0][0] * X[1]	- C[1][0] * X[0],
				detXC1	= X[0]	  * C[1][1] - X[1]	  * C[0][1];
			alpha1 = detXC1 / detC0C1;
			alpha2 = detC0X / detC0C1;
		} else {
			var c0 = C[0][0] + C[0][1],
				c1 = C[1][0] + C[1][1];
			if (Math.abs(c0) > epsilon) {
				alpha1 = alpha2 = X[0] / c0;
			} else if (Math.abs(c1) > epsilon) {
				alpha1 = alpha2 = X[1] / c1;
			} else {
				alpha1 = alpha2 = 0;
			}
		}

		var segLength = pt2.getDistance(pt1),
			eps = epsilon * segLength,
			handle1,
			handle2;
		if (alpha1 < eps || alpha2 < eps) {
			alpha1 = alpha2 = segLength / 3;
		} else {
			var line = pt2.subtract(pt1);
			handle1 = tan1.normalize(alpha1);
			handle2 = tan2.normalize(alpha2);
			if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
				alpha1 = alpha2 = segLength / 3;
				handle1 = handle2 = null;
			}
		}

		return [pt1, pt1.add(handle1 || tan1.normalize(alpha1)),
				pt2.add(handle2 || tan2.normalize(alpha2)), pt2];
	},

	reparameterize: function(first, last, u, curve) {
		for (var i = first; i <= last; i++) {
			u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
		}
		for (var i = 1, l = u.length; i < l; i++) {
			if (u[i] <= u[i - 1])
				return false;
		}
		return true;
	},

	findRoot: function(curve, point, u) {
		var curve1 = [],
			curve2 = [];
		for (var i = 0; i <= 2; i++) {
			curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
		}
		for (var i = 0; i <= 1; i++) {
			curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
		}
		var pt = this.evaluate(3, curve, u),
			pt1 = this.evaluate(2, curve1, u),
			pt2 = this.evaluate(1, curve2, u),
			diff = pt.subtract(point),
			df = pt1.dot(pt1) + diff.dot(pt2);
		if (Math.abs(df) < 1e-6)
			return u;
		return u - diff.dot(pt1) / df;
	},

	evaluate: function(degree, curve, t) {
		var tmp = curve.slice();
		for (var i = 1; i <= degree; i++) {
			for (var j = 0; j <= degree - i; j++) {
				tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
			}
		}
		return tmp[0];
	},

	chordLengthParameterize: function(first, last) {
		var u = [0];
		for (var i = first + 1; i <= last; i++) {
			u[i - first] = u[i - first - 1]
					+ this.points[i].getDistance(this.points[i - 1]);
		}
		for (var i = 1, m = last - first; i <= m; i++) {
			u[i] /= u[m];
		}
		return u;
	},

	findMaxError: function(first, last, curve, u) {
		var index = Math.floor((last - first + 1) / 2),
			maxDist = 0;
		for (var i = first + 1; i < last; i++) {
			var P = this.evaluate(3, curve, u[i - first]);
			var v = P.subtract(this.points[i]);
			var dist = v.x * v.x + v.y * v.y;
			if (dist >= maxDist) {
				maxDist = dist;
				index = i;
			}
		}
		return {
			error: maxDist,
			index: index
		};
	}
});

var TextItem = Item.extend({
	_class: 'TextItem',
	_boundsSelected: true,
	_applyMatrix: false,
	_canApplyMatrix: false,
	_serializeFields: {
		content: null
	},
	_boundsGetter: 'getBounds',

	initialize: function TextItem(arg) {
		this._content = '';
		this._lines = [];
		var hasProps = arg && Base.isPlainObject(arg)
				&& arg.x === undefined && arg.y === undefined;
		this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
	},

	_equals: function(item) {
		return this._content === item._content;
	},

	_clone: function _clone(copy, insert, includeMatrix) {
		copy.setContent(this._content);
		return _clone.base.call(this, copy, insert, includeMatrix);
	},

	getContent: function() {
		return this._content;
	},

	setContent: function(content) {
		this._content = '' + content;
		this._lines = this._content.split(/\r\n|\n|\r/mg);
		this._changed(265);
	},

	isEmpty: function() {
		return !this._content;
	},

	getCharacterStyle: '#getStyle',
	setCharacterStyle: '#setStyle',

	getParagraphStyle: '#getStyle',
	setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
	_class: 'PointText',

	initialize: function PointText() {
		TextItem.apply(this, arguments);
	},

	clone: function(insert) {
		return this._clone(new PointText(Item.NO_INSERT), insert);
	},

	getPoint: function() {
		var point = this._matrix.getTranslation();
		return new LinkedPoint(point.x, point.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.translate(point.subtract(this._matrix.getTranslation()));
	},

	_draw: function(ctx) {
		if (!this._content)
			return;
		this._setStyles(ctx);
		var style = this._style,
			lines = this._lines,
			leading = style.getLeading(),
			shadowColor = ctx.shadowColor;
		ctx.font = style.getFontStyle();
		ctx.textAlign = style.getJustification();
		for (var i = 0, l = lines.length; i < l; i++) {
			ctx.shadowColor = shadowColor;
			var line = lines[i];
			if (style.hasFill()) {
				ctx.fillText(line, 0, 0);
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.strokeText(line, 0, 0);
			ctx.translate(0, leading);
		}
	},

	_getBounds: function(getter, matrix) {
		var style = this._style,
			lines = this._lines,
			numLines = lines.length,
			justification = style.getJustification(),
			leading = style.getLeading(),
			width = this.getView().getTextWidth(style.getFontStyle(), lines),
			x = 0;
		if (justification !== 'left')
			x -= width / (justification === 'center' ? 2: 1);
		var bounds = new Rectangle(x,
					numLines ? - 0.75 * leading : 0,
					width, numLines * leading);
		return matrix ? matrix._transformBounds(bounds, bounds) : bounds;
	}
});

var Color = Base.extend(new function() {
	var types = {
		gray: ['gray'],
		rgb: ['red', 'green', 'blue'],
		hsb: ['hue', 'saturation', 'brightness'],
		hsl: ['hue', 'saturation', 'lightness'],
		gradient: ['gradient', 'origin', 'destination', 'highlight']
	};

	var componentParsers = {},
		colorCache = {},
		colorCtx;

	function fromCSS(string) {
		var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/),
			components;
		if (match) {
			components = [0, 0, 0];
			for (var i = 0; i < 3; i++) {
				var value = match[i + 1];
				components[i] = parseInt(value.length == 1
						? value + value : value, 16) / 255;
			}
		} else if (match = string.match(/^rgba?\((.*)\)$/)) {
			components = match[1].split(',');
			for (var i = 0, l = components.length; i < l; i++) {
				var value = +components[i];
				components[i] = i < 3 ? value / 255 : value;
			}
		} else {
			var cached = colorCache[string];
			if (!cached) {
				if (!colorCtx) {
					colorCtx = CanvasProvider.getContext(1, 1);
					colorCtx.globalCompositeOperation = 'copy';
				}
				colorCtx.fillStyle = 'rgba(0,0,0,0)';
				colorCtx.fillStyle = string;
				colorCtx.fillRect(0, 0, 1, 1);
				var data = colorCtx.getImageData(0, 0, 1, 1).data;
				cached = colorCache[string] = [
					data[0] / 255,
					data[1] / 255,
					data[2] / 255
				];
			}
			components = cached.slice();
		}
		return components;
	}

	var hsbIndices = [
		[0, 3, 1],
		[2, 0, 1],
		[1, 0, 3],
		[1, 2, 0],
		[3, 1, 0],
		[0, 1, 2]
	];

	var converters = {
		'rgb-hsb': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				h = delta === 0 ? 0
					:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:			 (r - g) / delta + 4) * 60;
			return [h, max === 0 ? 0 : delta / max, max];
		},

		'hsb-rgb': function(h, s, b) {
			h = (((h / 60) % 6) + 6) % 6;
			var i = Math.floor(h),
				f = h - i,
				i = hsbIndices[i],
				v = [
					b,
					b * (1 - s),
					b * (1 - s * f),
					b * (1 - s * (1 - f))
				];
			return [v[i[0]], v[i[1]], v[i[2]]];
		},

		'rgb-hsl': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				achromatic = delta === 0,
				h = achromatic ? 0
					:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:			 (r - g) / delta + 4) * 60,
				l = (max + min) / 2,
				s = achromatic ? 0 : l < 0.5
						? delta / (max + min)
						: delta / (2 - max - min);
			return [h, s, l];
		},

		'hsl-rgb': function(h, s, l) {
			h = (((h / 360) % 1) + 1) % 1;
			if (s === 0)
				return [l, l, l];
			var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
				t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
				t1 = 2 * l - t2,
				c = [];
			for (var i = 0; i < 3; i++) {
				var t3 = t3s[i];
				if (t3 < 0) t3 += 1;
				if (t3 > 1) t3 -= 1;
				c[i] = 6 * t3 < 1
					? t1 + (t2 - t1) * 6 * t3
					: 2 * t3 < 1
						? t2
						: 3 * t3 < 2
							? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
							: t1;
			}
			return c;
		},

		'rgb-gray': function(r, g, b) {
			return [r * 0.2989 + g * 0.587 + b * 0.114];
		},

		'gray-rgb': function(g) {
			return [g, g, g];
		},

		'gray-hsb': function(g) {
			return [0, 0, g];
		},

		'gray-hsl': function(g) {
			return [0, 0, g];
		},

		'gradient-rgb': function() {
			return [];
		},

		'rgb-gradient': function() {
			return [];
		}

	};

	return Base.each(types, function(properties, type) {
		componentParsers[type] = [];
		Base.each(properties, function(name, index) {
			var part = Base.capitalize(name),
				hasOverlap = /^(hue|saturation)$/.test(name),
				parser = componentParsers[type][index] = name === 'gradient'
					? function(value) {
						var current = this._components[0];
						value = Gradient.read(Array.isArray(value) ? value
								: arguments, 0, { readNull: true });
						if (current !== value) {
							if (current)
								current._removeOwner(this);
							if (value)
								value._addOwner(this);
						}
						return value;
					}
					: type === 'gradient'
						? function() {
							return Point.read(arguments, 0, {
									readNull: name === 'highlight',
									clone: true
							});
						}
						: function(value) {
							return value == null || isNaN(value) ? 0 : value;
						};

			this['get' + part] = function() {
				return this._type === type
					|| hasOverlap && /^hs[bl]$/.test(this._type)
						? this._components[index]
						: this._convert(type)[index];
			};

			this['set' + part] = function(value) {
				if (this._type !== type
						&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
					this._components = this._convert(type);
					this._properties = types[type];
					this._type = type;
				}
				this._components[index] = parser.call(this, value);
				this._changed();
			};
		}, this);
	}, {
		_class: 'Color',
		_readIndex: true,

		initialize: function Color(arg) {
			var slice = Array.prototype.slice,
				args = arguments,
				read = 0,
				type,
				components,
				alpha,
				values;
			if (Array.isArray(arg)) {
				args = arg;
				arg = args[0];
			}
			var argType = arg != null && typeof arg;
			if (argType === 'string' && arg in types) {
				type = arg;
				arg = args[1];
				if (Array.isArray(arg)) {
					components = arg;
					alpha = args[2];
				} else {
					if (this.__read)
						read = 1;
					args = slice.call(args, 1);
					argType = typeof arg;
				}
			}
			if (!components) {
				values = argType === 'number'
						? args
						: argType === 'object' && arg.length != null
							? arg
							: null;
				if (values) {
					if (!type)
						type = values.length >= 3
								? 'rgb'
								: 'gray';
					var length = types[type].length;
					alpha = values[length];
					if (this.__read)
						read += values === arguments
							? length + (alpha != null ? 1 : 0)
							: 1;
					if (values.length > length)
						values = slice.call(values, 0, length);
				} else if (argType === 'string') {
					type = 'rgb';
					components = fromCSS(arg);
					if (components.length === 4) {
						alpha = components[3];
						components.length--;
					}
				} else if (argType === 'object') {
					if (arg.constructor === Color) {
						type = arg._type;
						components = arg._components.slice();
						alpha = arg._alpha;
						if (type === 'gradient') {
							for (var i = 1, l = components.length; i < l; i++) {
								var point = components[i];
								if (point)
									components[i] = point.clone();
							}
						}
					} else if (arg.constructor === Gradient) {
						type = 'gradient';
						values = args;
					} else {
						type = 'hue' in arg
							? 'lightness' in arg
								? 'hsl'
								: 'hsb'
							: 'gradient' in arg || 'stops' in arg
									|| 'radial' in arg
								? 'gradient'
								: 'gray' in arg
									? 'gray'
									: 'rgb';
						var properties = types[type],
							parsers = componentParsers[type];
						this._components = components = [];
						for (var i = 0, l = properties.length; i < l; i++) {
							var value = arg[properties[i]];
							if (value == null && i === 0 && type === 'gradient'
									&& 'stops' in arg) {
								value = {
									stops: arg.stops,
									radial: arg.radial
								};
							}
							value = parsers[i].call(this, value);
							if (value != null)
								components[i] = value;
						}
						alpha = arg.alpha;
					}
				}
				if (this.__read && type)
					read = 1;
			}
			this._type = type || 'rgb';
			this._id = UID.get(Color);
			if (!components) {
				this._components = components = [];
				var parsers = componentParsers[this._type];
				for (var i = 0, l = parsers.length; i < l; i++) {
					var value = parsers[i].call(this, values && values[i]);
					if (value != null)
						components[i] = value;
				}
			}
			this._components = components;
			this._properties = types[this._type];
			this._alpha = alpha;
			if (this.__read)
				this.__read = read;
		},

		_serialize: function(options, dictionary) {
			var components = this.getComponents();
			return Base.serialize(
					/^(gray|rgb)$/.test(this._type)
						? components
						: [this._type].concat(components),
					options, true, dictionary);
		},

		_changed: function() {
			this._canvasStyle = null;
			if (this._owner)
				this._owner._changed(65);
		},

		_convert: function(type) {
			var converter;
			return this._type === type
					? this._components.slice()
					: (converter = converters[this._type + '-' + type])
						? converter.apply(this, this._components)
						: converters['rgb-' + type].apply(this,
							converters[this._type + '-rgb'].apply(this,
								this._components));
		},

		convert: function(type) {
			return new Color(type, this._convert(type), this._alpha);
		},

		getType: function() {
			return this._type;
		},

		setType: function(type) {
			this._components = this._convert(type);
			this._properties = types[type];
			this._type = type;
		},

		getComponents: function() {
			var components = this._components.slice();
			if (this._alpha != null)
				components.push(this._alpha);
			return components;
		},

		getAlpha: function() {
			return this._alpha != null ? this._alpha : 1;
		},

		setAlpha: function(alpha) {
			this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
			this._changed();
		},

		hasAlpha: function() {
			return this._alpha != null;
		},

		equals: function(color) {
			var col = Base.isPlainValue(color, true)
					? Color.read(arguments)
					: color;
			return col === this || col && this._class === col._class
					&& this._type === col._type
					&& this._alpha === col._alpha
					&& Base.equals(this._components, col._components)
					|| false;
		},

		toString: function() {
			var properties = this._properties,
				parts = [],
				isGradient = this._type === 'gradient',
				f = Formatter.instance;
			for (var i = 0, l = properties.length; i < l; i++) {
				var value = this._components[i];
				if (value != null)
					parts.push(properties[i] + ': '
							+ (isGradient ? value : f.number(value)));
			}
			if (this._alpha != null)
				parts.push('alpha: ' + f.number(this._alpha));
			return '{ ' + parts.join(', ') + ' }';
		},

		toCSS: function(hex) {
			var components = this._convert('rgb'),
				alpha = hex || this._alpha == null ? 1 : this._alpha;
			function convert(val) {
				return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
			}
			components = [
				convert(components[0]),
				convert(components[1]),
				convert(components[2])
			];
			if (alpha < 1)
				components.push(alpha < 0 ? 0 : alpha);
			return hex
					? '#' + ((1 << 24) + (components[0] << 16)
						+ (components[1] << 8)
						+ components[2]).toString(16).slice(1)
					: (components.length == 4 ? 'rgba(' : 'rgb(')
						+ components.join(',') + ')';
		},

		toCanvasStyle: function(ctx) {
			if (this._canvasStyle)
				return this._canvasStyle;
			if (this._type !== 'gradient')
				return this._canvasStyle = this.toCSS();
			var components = this._components,
				gradient = components[0],
				stops = gradient._stops,
				origin = components[1],
				destination = components[2],
				canvasGradient;
			if (gradient._radial) {
				var radius = destination.getDistance(origin),
					highlight = components[3];
				if (highlight) {
					var vector = highlight.subtract(origin);
					if (vector.getLength() > radius)
						highlight = origin.add(vector.normalize(radius - 0.1));
				}
				var start = highlight || origin;
				canvasGradient = ctx.createRadialGradient(start.x, start.y,
						0, origin.x, origin.y, radius);
			} else {
				canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
						destination.x, destination.y);
			}
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i];
				canvasGradient.addColorStop(stop._rampPoint,
						stop._color.toCanvasStyle());
			}
			return this._canvasStyle = canvasGradient;
		},

		transform: function(matrix) {
			if (this._type === 'gradient') {
				var components = this._components;
				for (var i = 1, l = components.length; i < l; i++) {
					var point = components[i];
					matrix._transformPoint(point, point, true);
				}
				this._changed();
			}
		},

		statics: {
			_types: types,

			random: function() {
				var random = Math.random;
				return new Color(random(), random(), random());
			}
		}
	});
},
new function() {
	var operators = {
		add: function(a, b) {
			return a + b;
		},

		subtract: function(a, b) {
			return a - b;
		},

		multiply: function(a, b) {
			return a * b;
		},

		divide: function(a, b) {
			return a / b;
		}
	};

	return Base.each(operators, function(operator, name) {
		this[name] = function(color) {
			color = Color.read(arguments);
			var type = this._type,
				components1 = this._components,
				components2 = color._convert(type);
			for (var i = 0, l = components1.length; i < l; i++)
				components2[i] = operator(components1[i], components2[i]);
			return new Color(type, components2,
					this._alpha != null
							? operator(this._alpha, color.getAlpha())
							: null);
		};
	}, {
	});
});

var Gradient = Base.extend({
	_class: 'Gradient',

	initialize: function Gradient(stops, radial) {
		this._id = UID.get();
		if (stops && this._set(stops))
			stops = radial = null;
		if (!this._stops)
			this.setStops(stops || ['white', 'black']);
		if (this._radial == null)
			this.setRadial(typeof radial === 'string' && radial === 'radial'
					|| radial || false);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._stops, this._radial],
					options, true, dictionary);
		});
	},

	_changed: function() {
		for (var i = 0, l = this._owners && this._owners.length; i < l; i++)
			this._owners[i]._changed();
	},

	_addOwner: function(color) {
		if (!this._owners)
			this._owners = [];
		this._owners.push(color);
	},

	_removeOwner: function(color) {
		var index = this._owners ? this._owners.indexOf(color) : -1;
		if (index != -1) {
			this._owners.splice(index, 1);
			if (this._owners.length === 0)
				this._owners = undefined;
		}
	},

	clone: function() {
		var stops = [];
		for (var i = 0, l = this._stops.length; i < l; i++)
			stops[i] = this._stops[i].clone();
		return new Gradient(stops, this._radial);
	},

	getStops: function() {
		return this._stops;
	},

	setStops: function(stops) {
		if (this.stops) {
			for (var i = 0, l = this._stops.length; i < l; i++)
				this._stops[i]._owner = undefined;
		}
		if (stops.length < 2)
			throw new Error(
					'Gradient stop list needs to contain at least two stops.');
		this._stops = GradientStop.readAll(stops, 0, { clone: true });
		for (var i = 0, l = this._stops.length; i < l; i++) {
			var stop = this._stops[i];
			stop._owner = this;
			if (stop._defaultRamp)
				stop.setRampPoint(i / (l - 1));
		}
		this._changed();
	},

	getRadial: function() {
		return this._radial;
	},

	setRadial: function(radial) {
		this._radial = radial;
		this._changed();
	},

	equals: function(gradient) {
		if (gradient === this)
			return true;
		if (gradient && this._class === gradient._class
				&& this._stops.length === gradient._stops.length) {
			for (var i = 0, l = this._stops.length; i < l; i++) {
				if (!this._stops[i].equals(gradient._stops[i]))
					return false;
			}
			return true;
		}
		return false;
	}
});

var GradientStop = Base.extend({
	_class: 'GradientStop',

	initialize: function GradientStop(arg0, arg1) {
		if (arg0) {
			var color, rampPoint;
			if (arg1 === undefined && Array.isArray(arg0)) {
				color = arg0[0];
				rampPoint = arg0[1];
			} else if (arg0.color) {
				color = arg0.color;
				rampPoint = arg0.rampPoint;
			} else {
				color = arg0;
				rampPoint = arg1;
			}
			this.setColor(color);
			this.setRampPoint(rampPoint);
		}
	},

	clone: function() {
		return new GradientStop(this._color.clone(), this._rampPoint);
	},

	_serialize: function(options, dictionary) {
		return Base.serialize([this._color, this._rampPoint], options, true,
				dictionary);
	},

	_changed: function() {
		if (this._owner)
			this._owner._changed(65);
	},

	getRampPoint: function() {
		return this._rampPoint;
	},

	setRampPoint: function(rampPoint) {
		this._defaultRamp = rampPoint == null;
		this._rampPoint = rampPoint || 0;
		this._changed();
	},

	getColor: function() {
		return this._color;
	},

	setColor: function(color) {
		this._color = Color.read(arguments);
		if (this._color === color)
			this._color = color.clone();
		this._color._owner = this;
		this._changed();
	},

	equals: function(stop) {
		return stop === this || stop && this._class === stop._class
				&& this._color.equals(stop._color)
				&& this._rampPoint == stop._rampPoint
				|| false;
	}
});

var Style = Base.extend(new function() {
	var defaults = {
		fillColor: undefined,
		strokeColor: undefined,
		strokeWidth: 1,
		strokeCap: 'butt',
		strokeJoin: 'miter',
		strokeScaling: true,
		miterLimit: 10,
		dashOffset: 0,
		dashArray: [],
		windingRule: 'nonzero',
		shadowColor: undefined,
		shadowBlur: 0,
		shadowOffset: new Point(),
		selectedColor: undefined,
		fontFamily: 'sans-serif',
		fontWeight: 'normal',
		fontSize: 12,
		font: 'sans-serif',
		leading: null,
		justification: 'left'
	};

	var flags = {
		strokeWidth: 97,
		strokeCap: 97,
		strokeJoin: 97,
		strokeScaling: 105,
		miterLimit: 97,
		fontFamily: 9,
		fontWeight: 9,
		fontSize: 9,
		font: 9,
		leading: 9,
		justification: 9
	};

	var item = { beans: true },
		fields = {
			_defaults: defaults,
			_textDefaults: new Base(defaults, {
				fillColor: new Color()
			}),
			beans: true
		};

	Base.each(defaults, function(value, key) {
		var isColor = /Color$/.test(key),
			isPoint = key === 'shadowOffset',
			part = Base.capitalize(key),
			flag = flags[key],
			set = 'set' + part,
			get = 'get' + part;

		fields[set] = function(value) {
			var owner = this._owner,
				children = owner && owner._children;
			if (children && children.length > 0
					&& !(owner instanceof CompoundPath)) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i]._style[set](value);
			} else {
				var old = this._values[key];
				if (old !== value) {
					if (isColor) {
						if (old)
							old._owner = undefined;
						if (value && value.constructor === Color) {
							if (value._owner)
								value = value.clone();
							value._owner = owner;
						}
					}
					this._values[key] = value;
					if (owner)
						owner._changed(flag || 65);
				}
			}
		};

		fields[get] = function(_dontMerge) {
			var owner = this._owner,
				children = owner && owner._children,
				value;
			if (!children || children.length === 0 || _dontMerge
					|| owner instanceof CompoundPath) {
				var value = this._values[key];
				if (value === undefined) {
					value = this._defaults[key];
					if (value && value.clone)
						value = value.clone();
				} else {
					var ctor = isColor ? Color : isPoint ? Point : null;
					if (ctor && !(value && value.constructor === ctor)) {
						this._values[key] = value = ctor.read([value], 0,
								{ readNull: true, clone: true });
						if (value && isColor)
							value._owner = owner;
					}
				}
				return value;
			}
			for (var i = 0, l = children.length; i < l; i++) {
				var childValue = children[i]._style[get]();
				if (i === 0) {
					value = childValue;
				} else if (!Base.equals(value, childValue)) {
					return undefined;
				}
			}
			return value;
		};

		item[get] = function(_dontMerge) {
			return this._style[get](_dontMerge);
		};

		item[set] = function(value) {
			this._style[set](value);
		};
	});

	Item.inject(item);
	return fields;
}, {
	_class: 'Style',

	initialize: function Style(style, _owner, _project) {
		this._values = {};
		this._owner = _owner;
		this._project = _owner && _owner._project || _project || paper.project;
		if (_owner instanceof TextItem)
			this._defaults = this._textDefaults;
		if (style)
			this.set(style);
	},

	set: function(style) {
		var isStyle = style instanceof Style,
			values = isStyle ? style._values : style;
		if (values) {
			for (var key in values) {
				if (key in this._defaults) {
					var value = values[key];
					this[key] = value && isStyle && value.clone
							? value.clone() : value;
				}
			}
		}
	},

	equals: function(style) {
		return style === this || style && this._class === style._class
				&& Base.equals(this._values, style._values)
				|| false;
	},

	hasFill: function() {
		return !!this.getFillColor();
	},

	hasStroke: function() {
		return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
	},

	hasShadow: function() {
		return !!this.getShadowColor() && this.getShadowBlur() > 0;
	},

	getView: function() {
		return this._project.getView();
	},

	getFontStyle: function() {
		var fontSize = this.getFontSize();
		return this.getFontWeight()
				+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
				+ this.getFontFamily();
	},

	getFont: '#getFontFamily',
	setFont: '#setFontFamily',

	getLeading: function getLeading() {
		var leading = getLeading.base.call(this),
			fontSize = this.getFontSize();
		if (/pt|em|%|px/.test(fontSize))
			fontSize = this.getView().getPixelSize(fontSize);
		return leading != null ? leading : fontSize * 1.2;
	}

});

var DomElement = new function() {
	function handlePrefix(el, name, set, value) {
		var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
			suffix = name[0].toUpperCase() + name.substring(1);
		for (var i = 0; i < 6; i++) {
			var prefix = prefixes[i],
				key = prefix ? prefix + suffix : name;
			if (key in el) {
				if (set) {
					el[key] = value;
				} else {
					return el[key];
				}
				break;
			}
		}
	}

	return {
		getStyles: function(el) {
			var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
				view = doc && doc.defaultView;
			return view && view.getComputedStyle(el, '');
		},

		getBounds: function(el, viewport) {
			var doc = el.ownerDocument,
				body = doc.body,
				html = doc.documentElement,
				rect;
			try {
				rect = el.getBoundingClientRect();
			} catch (e) {
				rect = { left: 0, top: 0, width: 0, height: 0 };
			}
			var x = rect.left - (html.clientLeft || body.clientLeft || 0),
				y = rect.top - (html.clientTop || body.clientTop || 0);
			if (!viewport) {
				var view = doc.defaultView;
				x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
				y += view.pageYOffset || html.scrollTop || body.scrollTop;
			}
			return new Rectangle(x, y, rect.width, rect.height);
		},

		getViewportBounds: function(el) {
			var doc = el.ownerDocument,
				view = doc.defaultView,
				html = doc.documentElement;
			return new Rectangle(0, 0,
				view.innerWidth || html.clientWidth,
				view.innerHeight || html.clientHeight
			);
		},

		getOffset: function(el, viewport) {
			return DomElement.getBounds(el, viewport).getPoint();
		},

		getSize: function(el) {
			return DomElement.getBounds(el, true).getSize();
		},

		isInvisible: function(el) {
			return DomElement.getSize(el).equals(new Size(0, 0));
		},

		isInView: function(el) {
			return !DomElement.isInvisible(el)
					&& DomElement.getViewportBounds(el).intersects(
						DomElement.getBounds(el, true));
		},

		getPrefixed: function(el, name) {
			return handlePrefix(el, name);
		},

		setPrefixed: function(el, name, value) {
			if (typeof name === 'object') {
				for (var key in name)
					handlePrefix(el, key, true, name[key]);
			} else {
				handlePrefix(el, name, true, value);
			}
		}
	};
};

var DomEvent = {
	add: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.addEventListener(parts[i], func, false);
		}
	},

	remove: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.removeEventListener(parts[i], func, false);
		}
	},

	getPoint: function(event) {
		var pos = event.targetTouches
				? event.targetTouches.length
					? event.targetTouches[0]
					: event.changedTouches[0]
				: event;
		return new Point(
			pos.pageX || pos.clientX + document.documentElement.scrollLeft,
			pos.pageY || pos.clientY + document.documentElement.scrollTop
		);
	},

	getTarget: function(event) {
		return event.target || event.srcElement;
	},

	getRelatedTarget: function(event) {
		return event.relatedTarget || event.toElement;
	},

	getOffset: function(event, target) {
		return DomEvent.getPoint(event).subtract(DomElement.getOffset(
				target || DomEvent.getTarget(event)));
	},

	stop: function(event) {
		event.stopPropagation();
		event.preventDefault();
	}
};

DomEvent.requestAnimationFrame = new function() {
	var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
		requested = false,
		callbacks = [],
		focused = true,
		timer;

	DomEvent.add(window, {
		focus: function() {
			focused = true;
		},
		blur: function() {
			focused = false;
		}
	});

	function handleCallbacks() {
		for (var i = callbacks.length - 1; i >= 0; i--) {
			var entry = callbacks[i],
				func = entry[0],
				el = entry[1];
			if (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true'
					|| focused) && DomElement.isInView(el)) {
				callbacks.splice(i, 1);
				func();
			}
		}
		if (nativeRequest) {
			if (callbacks.length) {
				nativeRequest(handleCallbacks);
			} else {
				requested = false;
			}
		}
	}

	return function(callback, element) {
		callbacks.push([callback, element]);
		if (nativeRequest) {
			if (!requested) {
				nativeRequest(handleCallbacks);
				requested = true;
			}
		} else if (!timer) {
			timer = setInterval(handleCallbacks, 1000 / 60);
		}
	};
};

var View = Base.extend(Emitter, {
	_class: 'View',

	initialize: function View(project, element) {
		this._project = project;
		this._scope = project._scope;
		this._element = element;
		var size;
		if (!this._pixelRatio)
			this._pixelRatio = window.devicePixelRatio || 1;
		this._id = element.getAttribute('id');
		if (this._id == null)
			element.setAttribute('id', this._id = 'view-' + View._id++);
		DomEvent.add(element, this._viewEvents);
		var none = 'none';
		DomElement.setPrefixed(element.style, {
			userSelect: none,
			touchAction: none,
			touchCallout: none,
			contentZooming: none,
			userDrag: none,
			tapHighlightColor: 'rgba(0,0,0,0)'
		});

		function getSize(name) {
			return element[name] || parseInt(element.getAttribute(name), 10);
		};

		function getCanvasSize() {
			var size = DomElement.getSize(element);
			return size.isNaN() || size.isZero()
					? new Size(getSize('width'), getSize('height'))
					: size;
		};

		if (PaperScope.hasAttribute(element, 'resize')) {
			var that = this;
			DomEvent.add(window, this._windowEvents = {
				resize: function() {
					that.setViewSize(getCanvasSize());
				}
			});
		}
		this._setViewSize(size = getCanvasSize());
		if (PaperScope.hasAttribute(element, 'stats')
				&& typeof Stats !== 'undefined') {
			this._stats = new Stats();
			var stats = this._stats.domElement,
				style = stats.style,
				offset = DomElement.getOffset(element);
			style.position = 'absolute';
			style.left = offset.x + 'px';
			style.top = offset.y + 'px';
			document.body.appendChild(stats);
		}
		View._views.push(this);
		View._viewsById[this._id] = this;
		this._viewSize = size;
		(this._matrix = new Matrix())._owner = this;
		this._zoom = 1;
		if (!View._focused)
			View._focused = this;
		this._frameItems = {};
		this._frameItemCount = 0;
	},

	remove: function() {
		if (!this._project)
			return false;
		if (View._focused === this)
			View._focused = null;
		View._views.splice(View._views.indexOf(this), 1);
		delete View._viewsById[this._id];
		if (this._project._view === this)
			this._project._view = null;
		DomEvent.remove(this._element, this._viewEvents);
		DomEvent.remove(window, this._windowEvents);
		this._element = this._project = null;
		this.off('frame');
		this._animate = false;
		this._frameItems = {};
		return true;
	},

	_events: Base.each(['onResize', 'onMouseDown', 'onMouseUp', 'onMouseMove'],
		function(name) {
			this[name] = {
				install: function(type) {
					this._installEvent(type);
				},

				uninstall: function(type) {
					this._uninstallEvent(type);
				}
			};
		}, {
			onFrame: {
				install: function() {
					this.play();
				},

				uninstall: function() {
					this.pause();
				}
			}
		}
	),

	_animate: false,
	_time: 0,
	_count: 0,

	_requestFrame: function() {
		var that = this;
		DomEvent.requestAnimationFrame(function() {
			that._requested = false;
			if (!that._animate)
				return;
			that._requestFrame();
			that._handleFrame();
		}, this._element);
		this._requested = true;
	},

	_handleFrame: function() {
		paper = this._scope;
		var now = Date.now() / 1000,
			delta = this._before ? now - this._before : 0;
		this._before = now;
		this._handlingFrame = true;
		this.emit('frame', new Base({
			delta: delta,
			time: this._time += delta,
			count: this._count++
		}));
		if (this._stats)
			this._stats.update();
		this._handlingFrame = false;
		this.update();
	},

	_animateItem: function(item, animate) {
		var items = this._frameItems;
		if (animate) {
			items[item._id] = {
				item: item,
				time: 0,
				count: 0
			};
			if (++this._frameItemCount === 1)
				this.on('frame', this._handleFrameItems);
		} else {
			delete items[item._id];
			if (--this._frameItemCount === 0) {
				this.off('frame', this._handleFrameItems);
			}
		}
	},

	_handleFrameItems: function(event) {
		for (var i in this._frameItems) {
			var entry = this._frameItems[i];
			entry.item.emit('frame', new Base(event, {
				time: entry.time += event.delta,
				count: entry.count++
			}));
		}
	},

	_update: function() {
		this._project._needsUpdate = true;
		if (this._handlingFrame)
			return;
		if (this._animate) {
			this._handleFrame();
		} else {
			this.update();
		}
	},

	_changed: function(flags) {
		if (flags & 1)
			this._project._needsUpdate = true;
	},

	_transform: function(matrix) {
		this._matrix.concatenate(matrix);
		this._bounds = null;
		this._update();
	},

	getElement: function() {
		return this._element;
	},

	getPixelRatio: function() {
		return this._pixelRatio;
	},

	getResolution: function() {
		return this._pixelRatio * 72;
	},

	getViewSize: function() {
		var size = this._viewSize;
		return new LinkedSize(size.width, size.height, this, 'setViewSize');
	},

	setViewSize: function() {
		var size = Size.read(arguments),
			delta = size.subtract(this._viewSize);
		if (delta.isZero())
			return;
		this._viewSize.set(size.width, size.height);
		this._setViewSize(size);
		this._bounds = null;
		this.emit('resize', {
			size: size,
			delta: delta
		});
		this._update();
	},

	_setViewSize: function(size) {
		var element = this._element;
		element.width = size.width;
		element.height = size.height;
	},

	getBounds: function() {
		if (!this._bounds)
			this._bounds = this._matrix.inverted()._transformBounds(
					new Rectangle(new Point(), this._viewSize));
		return this._bounds;
	},

	getSize: function() {
		return this.getBounds().getSize();
	},

	getCenter: function() {
		return this.getBounds().getCenter();
	},

	setCenter: function() {
		var center = Point.read(arguments);
		this.scrollBy(center.subtract(this.getCenter()));
	},

	getZoom: function() {
		return this._zoom;
	},

	setZoom: function(zoom) {
		this._transform(new Matrix().scale(zoom / this._zoom,
			this.getCenter()));
		this._zoom = zoom;
	},

	isVisible: function() {
		return DomElement.isInView(this._element);
	},

	scrollBy: function() {
		this._transform(new Matrix().translate(Point.read(arguments).negate()));
	},

	play: function() {
		this._animate = true;
		if (!this._requested)
			this._requestFrame();
	},

	pause: function() {
		this._animate = false;
	},

	draw: function() {
		this.update();
	},

	projectToView: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	viewToProject: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	}

}, {
	statics: {
		_views: [],
		_viewsById: {},
		_id: 0,

		create: function(project, element) {
			if (typeof element === 'string')
				element = document.getElementById(element);
			return new CanvasView(project, element);
		}
	}
},
new function() {
	var tool,
		prevFocus,
		tempFocus,
		dragging = false;

	function getView(event) {
		var target = DomEvent.getTarget(event);
		return target.getAttribute && View._viewsById[target.getAttribute('id')];
	}

	function viewToProject(view, event) {
		return view.viewToProject(DomEvent.getOffset(event, view._element));
	}

	function updateFocus() {
		if (!View._focused || !View._focused.isVisible()) {
			for (var i = 0, l = View._views.length; i < l; i++) {
				var view = View._views[i];
				if (view && view.isVisible()) {
					View._focused = tempFocus = view;
					break;
				}
			}
		}
	}

	function handleMouseMove(view, point, event) {
		view._handleEvent('mousemove', point, event);
		var tool = view._scope.tool;
		if (tool) {
			tool._handleEvent(dragging && tool.responds('mousedrag')
					? 'mousedrag' : 'mousemove', point, event);
		}
		view.update();
		return tool;
	}

	var navigator = window.navigator,
		mousedown, mousemove, mouseup;
	if (navigator.pointerEnabled || navigator.msPointerEnabled) {
		mousedown = 'pointerdown MSPointerDown';
		mousemove = 'pointermove MSPointerMove';
		mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
	} else {
		mousedown = 'touchstart';
		mousemove = 'touchmove';
		mouseup = 'touchend touchcancel';
		if (!('ontouchstart' in window && navigator.userAgent.match(
				/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
			mousedown += ' mousedown';
			mousemove += ' mousemove';
			mouseup += ' mouseup';
		}
	}

	var viewEvents = {
		'selectstart dragstart': function(event) {
			if (dragging)
				event.preventDefault();
		}
	};

	var docEvents = {
		mouseout: function(event) {
			var view = View._focused,
				target = DomEvent.getRelatedTarget(event);
			if (view && (!target || target.nodeName === 'HTML'))
				handleMouseMove(view, viewToProject(view, event), event);
		},

		scroll: updateFocus
	};

	viewEvents[mousedown] = function(event) {
		var view = View._focused = getView(event),
			point = viewToProject(view, event);
		dragging = true;
		view._handleEvent('mousedown', point, event);
		if (tool = view._scope.tool)
			tool._handleEvent('mousedown', point, event);
		view.update();
	};

	docEvents[mousemove] = function(event) {
		var view = View._focused;
		if (!dragging) {
			var target = getView(event);
			if (target) {
				if (view !== target)
					handleMouseMove(view, viewToProject(view, event), event);
				prevFocus = view;
				view = View._focused = tempFocus = target;
			} else if (tempFocus && tempFocus === view) {
				view = View._focused = prevFocus;
				updateFocus();
			}
		}
		if (view) {
			var point = viewToProject(view, event);
			if (dragging || view.getBounds().contains(point))
				tool = handleMouseMove(view, point, event);
		}
	};

	docEvents[mouseup] = function(event) {
		var view = View._focused;
		if (!view || !dragging)
			return;
		var point = viewToProject(view, event);
		dragging = false;
		view._handleEvent('mouseup', point, event);
		if (tool)
			tool._handleEvent('mouseup', point, event);
		view.update();
	};

	DomEvent.add(document, docEvents);

	DomEvent.add(window, {
		load: updateFocus
	});

	var mouseFlags = {
		mousedown: {
			mousedown: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mouseup: {
			mouseup: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mousemove: {
			mousedrag: 1,
			mousemove: 1,
			mouseenter: 1,
			mouseleave: 1
		}
	};

	return {
		_viewEvents: viewEvents,

		_handleEvent: function() {},

		_installEvent: function(type) {
			var counters = this._eventCounters;
			if (counters) {
				for (var key in mouseFlags) {
					counters[key] = (counters[key] || 0)
							+ (mouseFlags[key][type] || 0);
				}
			}
		},

		_uninstallEvent: function(type) {
			var counters = this._eventCounters;
			if (counters) {
				for (var key in mouseFlags)
					counters[key] -= mouseFlags[key][type] || 0;
			}
		},

		statics: {
			updateFocus: updateFocus
		}
	};
});

var CanvasView = View.extend({
	_class: 'CanvasView',

	initialize: function CanvasView(project, canvas) {
		if (!(canvas instanceof HTMLCanvasElement)) {
			var size = Size.read(arguments, 1);
			if (size.isZero())
				throw new Error(
						'Cannot create CanvasView with the provided argument: '
						+ [].slice.call(arguments, 1));
			canvas = CanvasProvider.getCanvas(size);
		}
		this._context = canvas.getContext('2d');
		this._eventCounters = {};
		this._pixelRatio = 1;
		if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
			var deviceRatio = window.devicePixelRatio || 1,
				backingStoreRatio = DomElement.getPrefixed(this._context,
						'backingStorePixelRatio') || 1;
			this._pixelRatio = deviceRatio / backingStoreRatio;
		}
		View.call(this, project, canvas);
	},

	_setViewSize: function(size) {
		var element = this._element,
			pixelRatio = this._pixelRatio,
			width = size.width,
			height = size.height;
		element.width = width * pixelRatio;
		element.height = height * pixelRatio;
		if (pixelRatio !== 1) {
			if (!PaperScope.hasAttribute(element, 'resize')) {
				var style = element.style;
				style.width = width + 'px';
				style.height = height + 'px';
			}
			this._context.scale(pixelRatio, pixelRatio);
		}
	},

	getPixelSize: function(size) {
		var browser = paper.browser,
			pixels;
		if (browser && browser.firefox) {
			var parent = this._element.parentNode,
				temp = document.createElement('div');
			temp.style.fontSize = size;
			parent.appendChild(temp);
			pixels = parseFloat(DomElement.getStyles(temp).fontSize);
			parent.removeChild(temp);
		} else {
			var ctx = this._context,
				prevFont = ctx.font;
			ctx.font = size + ' serif';
			pixels = parseFloat(ctx.font);
			ctx.font = prevFont;
		}
		return pixels;
	},

	getTextWidth: function(font, lines) {
		var ctx = this._context,
			prevFont = ctx.font,
			width = 0;
		ctx.font = font;
		for (var i = 0, l = lines.length; i < l; i++)
			width = Math.max(width, ctx.measureText(lines[i]).width);
		ctx.font = prevFont;
		return width;
	},

	update: function(force) {
		var project = this._project;
		if (!project || !force && !project._needsUpdate)
			return false;
		var ctx = this._context,
			size = this._viewSize;
		ctx.clearRect(0, 0, size.width + 1, size.height + 1);
		project.draw(ctx, this._matrix, this._pixelRatio);
		project._needsUpdate = false;
		return true;
	}
},
new function() {
	var downPoint,
		lastPoint,
		overPoint,
		downItem,
		lastItem,
		overItem,
		dragItem,
		dblClick,
		clickTime;

	function callEvent(view, type, event, point, target, lastPoint) {
		var item = target,
			mouseEvent;

		function call(obj) {
			if (obj.responds(type)) {
				if (!mouseEvent) {
					mouseEvent = new MouseEvent(type, event, point, target,
							lastPoint ? point.subtract(lastPoint) : null);
				}
				if (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {
					event.preventDefault();
					return true;
				}
			}
		}

		while (item) {
			if (call(item))
				return true;
			item = item.getParent();
		}
		if (call(view))
			return true;
		return false;
	}

	return {
		_handleEvent: function(type, point, event) {
			if (!this._eventCounters[type])
				return;
			var project = this._project,
				hit = project.hitTest(point, {
					tolerance: 0,
					fill: true,
					stroke: true
				}),
				item = hit && hit.item,
				stopped = false;
			switch (type) {
			case 'mousedown':
				stopped = callEvent(this, type, event, point, item);
				dblClick = lastItem == item && (Date.now() - clickTime < 300);
				downItem = lastItem = item;
				downPoint = lastPoint = overPoint = point;
				dragItem = !stopped && item;
				while (dragItem && !dragItem.responds('mousedrag'))
					dragItem = dragItem._parent;
				break;
			case 'mouseup':
				stopped = callEvent(this, type, event, point, item, downPoint);
				if (dragItem) {
					if (lastPoint && !lastPoint.equals(point))
						callEvent(this, 'mousedrag', event, point, dragItem,
								lastPoint);
					if (item !== dragItem) {
						overPoint = point;
						callEvent(this, 'mousemove', event, point, item,
								overPoint);
					}
				}
				if (!stopped && item && item === downItem) {
					clickTime = Date.now();
					callEvent(this, dblClick && downItem.responds('doubleclick')
							? 'doubleclick' : 'click', event, downPoint, item);
					dblClick = false;
				}
				downItem = dragItem = null;
				break;
			case 'mousemove':
				if (dragItem)
					stopped = callEvent(this, 'mousedrag', event, point,
							dragItem, lastPoint);
				if (!stopped) {
					if (item !== overItem)
						overPoint = point;
					stopped = callEvent(this, type, event, point, item,
							overPoint);
				}
				lastPoint = overPoint = point;
				if (item !== overItem) {
					callEvent(this, 'mouseleave', event, point, overItem);
					overItem = item;
					callEvent(this, 'mouseenter', event, point, item);
				}
				break;
			}
			return stopped;
		}
	};
});

var Event = Base.extend({
	_class: 'Event',

	initialize: function Event(event) {
		this.event = event;
	},

	isPrevented: false,
	isStopped: false,

	preventDefault: function() {
		this.isPrevented = true;
		this.event.preventDefault();
	},

	stopPropagation: function() {
		this.isStopped = true;
		this.event.stopPropagation();
	},

	stop: function() {
		this.stopPropagation();
		this.preventDefault();
	},

	getModifiers: function() {
		return Key.modifiers;
	}
});

var KeyEvent = Event.extend({
	_class: 'KeyEvent',

	initialize: function KeyEvent(down, key, character, event) {
		Event.call(this, event);
		this.type = down ? 'keydown' : 'keyup';
		this.key = key;
		this.character = character;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', key: '" + this.key
				+ "', character: '" + this.character
				+ "', modifiers: " + this.getModifiers()
				+ " }";
	}
});

var Key = new function() {

	var specialKeys = {
		8: 'backspace',
		9: 'tab',
		13: 'enter',
		16: 'shift',
		17: 'control',
		18: 'option',
		19: 'pause',
		20: 'caps-lock',
		27: 'escape',
		32: 'space',
		35: 'end',
		36: 'home',
		37: 'left',
		38: 'up',
		39: 'right',
		40: 'down',
		46: 'delete',
		91: 'command',
		93: 'command',
		224: 'command'
	},

	specialChars = {
		9: true,
		13: true,
		32: true
	},

	modifiers = new Base({
		shift: false,
		control: false,
		option: false,
		command: false,
		capsLock: false,
		space: false
	}),

	charCodeMap = {},
	keyMap = {},
	commandFixMap,
	downCode;

	function handleKey(down, keyCode, charCode, event) {
		var character = charCode ? String.fromCharCode(charCode) : '',
			specialKey = specialKeys[keyCode],
			key = specialKey || character.toLowerCase(),
			type = down ? 'keydown' : 'keyup',
			view = View._focused,
			scope = view && view.isVisible() && view._scope,
			tool = scope && scope.tool,
			name;
		keyMap[key] = down;
		if (down) {
			charCodeMap[keyCode] = charCode;
		} else {
			delete charCodeMap[keyCode];
		}
		if (specialKey && (name = Base.camelize(specialKey)) in modifiers) {
			modifiers[name] = down;
			var browser = paper.browser;
			if (name === 'command' && browser && browser.mac) {
				if (down) {
					commandFixMap = {};
				} else {
					for (var code in commandFixMap) {
						if (code in charCodeMap)
							handleKey(false, code, commandFixMap[code], event);
					}
					commandFixMap = null;
				}
			}
		} else if (down && commandFixMap) {
			commandFixMap[keyCode] = charCode;
		}
		if (tool && tool.responds(type)) {
			paper = scope;
			tool.emit(type, new KeyEvent(down, key, character, event));
			if (view)
				view.update();
		}
	}

	DomEvent.add(document, {
		keydown: function(event) {
			var code = event.which || event.keyCode;
			if (code in specialKeys || modifiers.command) {
				handleKey(true, code,
						code in specialChars || modifiers.command ? code : 0,
						event);
			} else {
				downCode = code;
			}
		},

		keypress: function(event) {
			if (downCode != null) {
				handleKey(true, downCode, event.which || event.keyCode, event);
				downCode = null;
			}
		},

		keyup: function(event) {
			var code = event.which || event.keyCode;
			if (code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	DomEvent.add(window, {
		blur: function(event) {
			for (var code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	return {
		modifiers: modifiers,

		isDown: function(key) {
			return !!keyMap[key];
		}
	};
};

var MouseEvent = Event.extend({
	_class: 'MouseEvent',

	initialize: function MouseEvent(type, event, point, target, delta) {
		Event.call(this, event);
		this.type = type;
		this.point = point;
		this.target = target;
		this.delta = delta;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', point: " + this.point
				+ ', target: ' + this.target
				+ (this.delta ? ', delta: ' + this.delta : '')
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var ToolEvent = Event.extend({
	_class: 'ToolEvent',
	_item: null,

	initialize: function ToolEvent(tool, type, event) {
		this.tool = tool;
		this.type = type;
		this.event = event;
	},

	_choosePoint: function(point, toolPoint) {
		return point ? point : toolPoint ? toolPoint.clone() : null;
	},

	getPoint: function() {
		return this._choosePoint(this._point, this.tool._point);
	},

	setPoint: function(point) {
		this._point = point;
	},

	getLastPoint: function() {
		return this._choosePoint(this._lastPoint, this.tool._lastPoint);
	},

	setLastPoint: function(lastPoint) {
		this._lastPoint = lastPoint;
	},

	getDownPoint: function() {
		return this._choosePoint(this._downPoint, this.tool._downPoint);
	},

	setDownPoint: function(downPoint) {
		this._downPoint = downPoint;
	},

	getMiddlePoint: function() {
		if (!this._middlePoint && this.tool._lastPoint) {
			return this.tool._point.add(this.tool._lastPoint).divide(2);
		}
		return this._middlePoint;
	},

	setMiddlePoint: function(middlePoint) {
		this._middlePoint = middlePoint;
	},

	getDelta: function() {
		return !this._delta && this.tool._lastPoint
				? this.tool._point.subtract(this.tool._lastPoint)
				: this._delta;
	},

	setDelta: function(delta) {
		this._delta = delta;
	},

	getCount: function() {
		return /^mouse(down|up)$/.test(this.type)
				? this.tool._downCount
				: this.tool._count;
	},

	setCount: function(count) {
		this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
			= count;
	},

	getItem: function() {
		if (!this._item) {
			var result = this.tool._scope.project.hitTest(this.getPoint());
			if (result) {
				var item = result.item,
					parent = item._parent;
				while (/^(Group|CompoundPath)$/.test(parent._class)) {
					item = parent;
					parent = parent._parent;
				}
				this._item = item;
			}
		}
		return this._item;
	},

	setItem: function(item) {
		this._item = item;
	},

	toString: function() {
		return '{ type: ' + this.type
				+ ', point: ' + this.getPoint()
				+ ', count: ' + this.getCount()
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var Tool = PaperScopeItem.extend({
	_class: 'Tool',
	_list: 'tools',
	_reference: 'tool',
	_events: [ 'onActivate', 'onDeactivate', 'onEditOptions',
			'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
			'onKeyDown', 'onKeyUp' ],

	initialize: function Tool(props) {
		PaperScopeItem.call(this);
		this._firstMove = true;
		this._count = 0;
		this._downCount = 0;
		this._set(props);
	},

	getMinDistance: function() {
		return this._minDistance;
	},

	setMinDistance: function(minDistance) {
		this._minDistance = minDistance;
		if (minDistance != null && this._maxDistance != null
				&& minDistance > this._maxDistance) {
			this._maxDistance = minDistance;
		}
	},

	getMaxDistance: function() {
		return this._maxDistance;
	},

	setMaxDistance: function(maxDistance) {
		this._maxDistance = maxDistance;
		if (this._minDistance != null && maxDistance != null
				&& maxDistance < this._minDistance) {
			this._minDistance = maxDistance;
		}
	},

	getFixedDistance: function() {
		return this._minDistance == this._maxDistance
			? this._minDistance : null;
	},

	setFixedDistance: function(distance) {
		this._minDistance = this._maxDistance = distance;
	},

	_updateEvent: function(type, point, minDistance, maxDistance, start,
			needsChange, matchMaxDistance) {
		if (!start) {
			if (minDistance != null || maxDistance != null) {
				var minDist = minDistance != null ? minDistance : 0,
					vector = point.subtract(this._point),
					distance = vector.getLength();
				if (distance < minDist)
					return false;
				if (maxDistance != null && maxDistance != 0) {
					if (distance > maxDistance) {
						point = this._point.add(vector.normalize(maxDistance));
					} else if (matchMaxDistance) {
						return false;
					}
				}
			}
			if (needsChange && point.equals(this._point))
				return false;
		}
		this._lastPoint = start && type == 'mousemove' ? point : this._point;
		this._point = point;
		switch (type) {
		case 'mousedown':
			this._lastPoint = this._downPoint;
			this._downPoint = this._point;
			this._downCount++;
			break;
		case 'mouseup':
			this._lastPoint = this._downPoint;
			break;
		}
		this._count = start ? 0 : this._count + 1;
		return true;
	},

	_fireEvent: function(type, event) {
		var sets = paper.project._removeSets;
		if (sets) {
			if (type === 'mouseup')
				sets.mousedrag = null;
			var set = sets[type];
			if (set) {
				for (var id in set) {
					var item = set[id];
					for (var key in sets) {
						var other = sets[key];
						if (other && other != set)
							delete other[item._id];
					}
					item.remove();
				}
				sets[type] = null;
			}
		}
		return this.responds(type)
				&& this.emit(type, new ToolEvent(this, type, event));
	},

	_handleEvent: function(type, point, event) {
		paper = this._scope;
		var called = false;
		switch (type) {
		case 'mousedown':
			this._updateEvent(type, point, null, null, true, false, false);
			called = this._fireEvent(type, event);
			break;
		case 'mousedrag':
			var needsChange = false,
				matchMaxDistance = false;
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, false, needsChange, matchMaxDistance)) {
				called = this._fireEvent(type, event) || called;
				needsChange = true;
				matchMaxDistance = true;
			}
			break;
		case 'mouseup':
			if (!point.equals(this._point)
					&& this._updateEvent('mousedrag', point, this.minDistance,
							this.maxDistance, false, false, false)) {
				called = this._fireEvent('mousedrag', event);
			}
			this._updateEvent(type, point, null, this.maxDistance, false,
					false, false);
			called = this._fireEvent(type, event) || called;
			this._updateEvent(type, point, null, null, true, false, false);
			this._firstMove = true;
			break;
		case 'mousemove':
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, this._firstMove, true, false)) {
				called = this._fireEvent(type, event) || called;
				this._firstMove = false;
			}
			break;
		}
		if (called)
			event.preventDefault();
		return called;
	}

});

var Http = {
	request: function(method, url, callback, async) {
		async = (async === undefined) ? true : async;
		var xhr = new (window.ActiveXObject || XMLHttpRequest)(
					'Microsoft.XMLHTTP');
		xhr.open(method.toUpperCase(), url, async);
		if ('overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain');
		xhr.onreadystatechange = function() {
			if (xhr.readyState === 4) {
				var status = xhr.status;
				if (status === 0 || status === 200) {
					callback.call(xhr, xhr.responseText);
				} else {
					throw new Error('Could not load ' + url + ' (Error '
							+ status + ')');
				}
			}
		};
		return xhr.send(null);
	}
};

var CanvasProvider = {
	canvases: [],

	getCanvas: function(width, height) {
		var canvas,
			clear = true;
		if (typeof width === 'object') {
			height = width.height;
			width = width.width;
		}
		if (this.canvases.length) {
			canvas = this.canvases.pop();
		} else {
			canvas = document.createElement('canvas');
		}
		var ctx = canvas.getContext('2d');
		if (canvas.width === width && canvas.height === height) {
			if (clear)
				ctx.clearRect(0, 0, width + 1, height + 1);
		} else {
			canvas.width = width;
			canvas.height = height;
		}
		ctx.save();
		return canvas;
	},

	getContext: function(width, height) {
		return this.getCanvas(width, height).getContext('2d');
	},

	release: function(obj) {
		var canvas = obj.canvas ? obj.canvas : obj;
		canvas.getContext('2d').restore();
		this.canvases.push(canvas);
	}
};

var BlendMode = new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		sr, sg, sb, sa,
		br, bg, bb, ba,
		dr, dg, db;

	function getLum(r, g, b) {
		return 0.2989 * r + 0.587 * g + 0.114 * b;
	}

	function setLum(r, g, b, l) {
		var d = l - getLum(r, g, b);
		dr = r + d;
		dg = g + d;
		db = b + d;
		var l = getLum(dr, dg, db),
			mn = min(dr, dg, db),
			mx = max(dr, dg, db);
		if (mn < 0) {
			var lmn = l - mn;
			dr = l + (dr - l) * l / lmn;
			dg = l + (dg - l) * l / lmn;
			db = l + (db - l) * l / lmn;
		}
		if (mx > 255) {
			var ln = 255 - l,
				mxl = mx - l;
			dr = l + (dr - l) * ln / mxl;
			dg = l + (dg - l) * ln / mxl;
			db = l + (db - l) * ln / mxl;
		}
	}

	function getSat(r, g, b) {
		return max(r, g, b) - min(r, g, b);
	}

	function setSat(r, g, b, s) {
		var col = [r, g, b],
			mx = max(r, g, b),
			mn = min(r, g, b),
			md;
		mn = mn === r ? 0 : mn === g ? 1 : 2;
		mx = mx === r ? 0 : mx === g ? 1 : 2;
		md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
		if (col[mx] > col[mn]) {
			col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
			col[mx] = s;
		} else {
			col[md] = col[mx] = 0;
		}
		col[mn] = 0;
		dr = col[0];
		dg = col[1];
		db = col[2];
	}

	var modes = {
		multiply: function() {
			dr = br * sr / 255;
			dg = bg * sg / 255;
			db = bb * sb / 255;
		},

		screen: function() {
			dr = br + sr - (br * sr / 255);
			dg = bg + sg - (bg * sg / 255);
			db = bb + sb - (bb * sb / 255);
		},

		overlay: function() {
			dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
			dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
			db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
		},

		'soft-light': function() {
			var t = sr * br / 255;
			dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
			t = sg * bg / 255;
			dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
			t = sb * bb / 255;
			db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
		},

		'hard-light': function() {
			dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
			dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
			db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
		},

		'color-dodge': function() {
			dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
			dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
			db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
		},

		'color-burn': function() {
			dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
			dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
			db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
		},

		darken: function() {
			dr = br < sr ? br : sr;
			dg = bg < sg ? bg : sg;
			db = bb < sb ? bb : sb;
		},

		lighten: function() {
			dr = br > sr ? br : sr;
			dg = bg > sg ? bg : sg;
			db = bb > sb ? bb : sb;
		},

		difference: function() {
			dr = br - sr;
			if (dr < 0)
				dr = -dr;
			dg = bg - sg;
			if (dg < 0)
				dg = -dg;
			db = bb - sb;
			if (db < 0)
				db = -db;
		},

		exclusion: function() {
			dr = br + sr * (255 - br - br) / 255;
			dg = bg + sg * (255 - bg - bg) / 255;
			db = bb + sb * (255 - bb - bb) / 255;
		},

		hue: function() {
			setSat(sr, sg, sb, getSat(br, bg, bb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		saturation: function() {
			setSat(br, bg, bb, getSat(sr, sg, sb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		luminosity: function() {
			setLum(br, bg, bb, getLum(sr, sg, sb));
		},

		color: function() {
			setLum(sr, sg, sb, getLum(br, bg, bb));
		},

		add: function() {
			dr = min(br + sr, 255);
			dg = min(bg + sg, 255);
			db = min(bb + sb, 255);
		},

		subtract: function() {
			dr = max(br - sr, 0);
			dg = max(bg - sg, 0);
			db = max(bb - sb, 0);
		},

		average: function() {
			dr = (br + sr) / 2;
			dg = (bg + sg) / 2;
			db = (bb + sb) / 2;
		},

		negation: function() {
			dr = 255 - abs(255 - sr - br);
			dg = 255 - abs(255 - sg - bg);
			db = 255 - abs(255 - sb - bb);
		}
	};

	var nativeModes = this.nativeModes = Base.each([
		'source-over', 'source-in', 'source-out', 'source-atop',
		'destination-over', 'destination-in', 'destination-out',
		'destination-atop', 'lighter', 'darker', 'copy', 'xor'
	], function(mode) {
		this[mode] = true;
	}, {});

	var ctx = CanvasProvider.getContext(1, 1);
	Base.each(modes, function(func, mode) {
		var darken = mode === 'darken',
			ok = false;
		ctx.save();
		try {
			ctx.fillStyle = darken ? '#300' : '#a00';
			ctx.fillRect(0, 0, 1, 1);
			ctx.globalCompositeOperation = mode;
			if (ctx.globalCompositeOperation === mode) {
				ctx.fillStyle = darken ? '#a00' : '#300';
				ctx.fillRect(0, 0, 1, 1);
				ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
			}
		} catch (e) {}
		ctx.restore();
		nativeModes[mode] = ok;
	});
	CanvasProvider.release(ctx);

	this.process = function(mode, srcContext, dstContext, alpha, offset) {
		var srcCanvas = srcContext.canvas,
			normal = mode === 'normal';
		if (normal || nativeModes[mode]) {
			dstContext.save();
			dstContext.setTransform(1, 0, 0, 1, 0, 0);
			dstContext.globalAlpha = alpha;
			if (!normal)
				dstContext.globalCompositeOperation = mode;
			dstContext.drawImage(srcCanvas, offset.x, offset.y);
			dstContext.restore();
		} else {
			var process = modes[mode];
			if (!process)
				return;
			var dstData = dstContext.getImageData(offset.x, offset.y,
					srcCanvas.width, srcCanvas.height),
				dst = dstData.data,
				src = srcContext.getImageData(0, 0,
					srcCanvas.width, srcCanvas.height).data;
			for (var i = 0, l = dst.length; i < l; i += 4) {
				sr = src[i];
				br = dst[i];
				sg = src[i + 1];
				bg = dst[i + 1];
				sb = src[i + 2];
				bb = dst[i + 2];
				sa = src[i + 3];
				ba = dst[i + 3];
				process();
				var a1 = sa * alpha / 255,
					a2 = 1 - a1;
				dst[i] = a1 * dr + a2 * br;
				dst[i + 1] = a1 * dg + a2 * bg;
				dst[i + 2] = a1 * db + a2 * bb;
				dst[i + 3] = sa * alpha + a2 * ba;
			}
			dstContext.putImageData(dstData, offset.x, offset.y);
		}
	};
};

var SVGStyles = Base.each({
	fillColor: ['fill', 'color'],
	strokeColor: ['stroke', 'color'],
	strokeWidth: ['stroke-width', 'number'],
	strokeCap: ['stroke-linecap', 'string'],
	strokeJoin: ['stroke-linejoin', 'string'],
	strokeScaling: ['vector-effect', 'lookup', {
		true: 'none',
		false: 'non-scaling-stroke'
	}, function(item, value) {
		return !value
				&& (item instanceof PathItem
					|| item instanceof Shape
					|| item instanceof TextItem);
	}],
	miterLimit: ['stroke-miterlimit', 'number'],
	dashArray: ['stroke-dasharray', 'array'],
	dashOffset: ['stroke-dashoffset', 'number'],
	fontFamily: ['font-family', 'string'],
	fontWeight: ['font-weight', 'string'],
	fontSize: ['font-size', 'number'],
	justification: ['text-anchor', 'lookup', {
		left: 'start',
		center: 'middle',
		right: 'end'
	}],
	opacity: ['opacity', 'number'],
	blendMode: ['mix-blend-mode', 'string']
}, function(entry, key) {
	var part = Base.capitalize(key),
		lookup = entry[2];
	this[key] = {
		type: entry[1],
		property: key,
		attribute: entry[0],
		toSVG: lookup,
		fromSVG: lookup && Base.each(lookup, function(value, name) {
			this[value] = name;
		}, {}),
		exportFilter: entry[3],
		get: 'get' + part,
		set: 'set' + part
	};
}, {});

var SVGNamespaces = {
	href: 'http://www.w3.org/1999/xlink',
	xlink: 'http://www.w3.org/2000/xmlns'
};

new function() {
	var formatter;

	function setAttributes(node, attrs) {
		for (var key in attrs) {
			var val = attrs[key],
				namespace = SVGNamespaces[key];
			if (typeof val === 'number')
				val = formatter.number(val);
			if (namespace) {
				node.setAttributeNS(namespace, key, val);
			} else {
				node.setAttribute(key, val);
			}
		}
		return node;
	}

	function createElement(tag, attrs) {
		return setAttributes(
			document.createElementNS('http://www.w3.org/2000/svg', tag), attrs);
	}

	function getTransform(matrix, coordinates, center) {
		var attrs = new Base(),
			trans = matrix.getTranslation();
		if (coordinates) {
			matrix = matrix.shiftless();
			var point = matrix._inverseTransform(trans);
			attrs[center ? 'cx' : 'x'] = point.x;
			attrs[center ? 'cy' : 'y'] = point.y;
			trans = null;
		}
		if (!matrix.isIdentity()) {
			var decomposed = matrix.decompose();
			if (decomposed && !decomposed.shearing) {
				var parts = [],
					angle = decomposed.rotation,
					scale = decomposed.scaling;
				if (trans && !trans.isZero())
					parts.push('translate(' + formatter.point(trans) + ')');
				if (!Numerical.isZero(scale.x - 1)
						|| !Numerical.isZero(scale.y - 1))
					parts.push('scale(' + formatter.point(scale) +')');
				if (angle)
					parts.push('rotate(' + formatter.number(angle) + ')');
				attrs.transform = parts.join(' ');
			} else {
				attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
			}
		}
		return attrs;
	}

	function exportGroup(item, options) {
		var attrs = getTransform(item._matrix),
			children = item._children;
		var node = createElement('g', attrs);
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			var childNode = exportSVG(child, options);
			if (childNode) {
				if (child.isClipMask()) {
					var clip = createElement('clipPath');
					clip.appendChild(childNode);
					setDefinition(child, clip, 'clip');
					setAttributes(node, {
						'clip-path': 'url(#' + clip.id + ')'
					});
				} else {
					node.appendChild(childNode);
				}
			}
		}
		return node;
	}

	function exportRaster(item, options) {
		var attrs = getTransform(item._matrix, true),
			size = item.getSize(),
			image = item.getImage();
		attrs.x -= size.width / 2;
		attrs.y -= size.height / 2;
		attrs.width = size.width;
		attrs.height = size.height;
		attrs.href = options.embedImages === false && image && image.src
				|| item.toDataURL();
		return createElement('image', attrs);
	}

	function exportPath(item, options) {
		var matchShapes = options.matchShapes;
		if (matchShapes) {
			var shape = item.toShape(false);
			if (shape)
				return exportShape(shape, options);
		}
		var segments = item._segments,
			type,
			attrs = getTransform(item._matrix);
		if (segments.length === 0)
			return null;
		if (matchShapes && !item.hasHandles()) {
			if (segments.length >= 3) {
				type = item._closed ? 'polygon' : 'polyline';
				var parts = [];
				for(var i = 0, l = segments.length; i < l; i++)
					parts.push(formatter.point(segments[i]._point));
				attrs.points = parts.join(' ');
			} else {
				type = 'line';
				var first = segments[0]._point,
					last = segments[segments.length - 1]._point;
				attrs.set({
					x1: first.x,
					y1: first.y,
					x2: last.x,
					y2: last.y
				});
			}
		} else {
			type = 'path';
			attrs.d = item.getPathData(null, options.precision);
		}
		return createElement(type, attrs);
	}

	function exportShape(item) {
		var type = item._type,
			radius = item._radius,
			attrs = getTransform(item._matrix, true, type !== 'rectangle');
		if (type === 'rectangle') {
			type = 'rect';
			var size = item._size,
				width = size.width,
				height = size.height;
			attrs.x -= width / 2;
			attrs.y -= height / 2;
			attrs.width = width;
			attrs.height = height;
			if (radius.isZero())
				radius = null;
		}
		if (radius) {
			if (type === 'circle') {
				attrs.r = radius;
			} else {
				attrs.rx = radius.width;
				attrs.ry = radius.height;
			}
		}
		return createElement(type, attrs);
	}

	function exportCompoundPath(item, options) {
		var attrs = getTransform(item._matrix);
		var data = item.getPathData(null, options.precision);
		if (data)
			attrs.d = data;
		return createElement('path', attrs);
	}

	function exportPlacedSymbol(item, options) {
		var attrs = getTransform(item._matrix, true),
			symbol = item.getSymbol(),
			symbolNode = getDefinition(symbol, 'symbol'),
			definition = symbol.getDefinition(),
			bounds = definition.getBounds();
		if (!symbolNode) {
			symbolNode = createElement('symbol', {
				viewBox: formatter.rectangle(bounds)
			});
			symbolNode.appendChild(exportSVG(definition, options));
			setDefinition(symbol, symbolNode, 'symbol');
		}
		attrs.href = '#' + symbolNode.id;
		attrs.x += bounds.x;
		attrs.y += bounds.y;
		attrs.width = formatter.number(bounds.width);
		attrs.height = formatter.number(bounds.height);
		attrs.overflow = 'visible';
		return createElement('use', attrs);
	}

	function exportGradient(color) {
		var gradientNode = getDefinition(color, 'color');
		if (!gradientNode) {
			var gradient = color.getGradient(),
				radial = gradient._radial,
				origin = color.getOrigin().transform(),
				destination = color.getDestination().transform(),
				attrs;
			if (radial) {
				attrs = {
					cx: origin.x,
					cy: origin.y,
					r: origin.getDistance(destination)
				};
				var highlight = color.getHighlight();
				if (highlight) {
					highlight = highlight.transform();
					attrs.fx = highlight.x;
					attrs.fy = highlight.y;
				}
			} else {
				attrs = {
					x1: origin.x,
					y1: origin.y,
					x2: destination.x,
					y2: destination.y
				};
			}
			attrs.gradientUnits = 'userSpaceOnUse';
			gradientNode = createElement(
					(radial ? 'radial' : 'linear') + 'Gradient', attrs);
			var stops = gradient._stops;
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					stopColor = stop._color,
					alpha = stopColor.getAlpha();
				attrs = {
					offset: stop._rampPoint,
					'stop-color': stopColor.toCSS(true)
				};
				if (alpha < 1)
					attrs['stop-opacity'] = alpha;
				gradientNode.appendChild(createElement('stop', attrs));
			}
			setDefinition(color, gradientNode, 'color');
		}
		return 'url(#' + gradientNode.id + ')';
	}

	function exportText(item) {
		var node = createElement('text', getTransform(item._matrix, true));
		node.textContent = item._content;
		return node;
	}

	var exporters = {
		Group: exportGroup,
		Layer: exportGroup,
		Raster: exportRaster,
		Path: exportPath,
		Shape: exportShape,
		CompoundPath: exportCompoundPath,
		PlacedSymbol: exportPlacedSymbol,
		PointText: exportText
	};

	function applyStyle(item, node, isRoot) {
		var attrs = {},
			parent = !isRoot && item.getParent();

		if (item._name != null)
			attrs.id = item._name;

		Base.each(SVGStyles, function(entry) {
			var get = entry.get,
				type = entry.type,
				value = item[get]();
			if (entry.exportFilter
					? entry.exportFilter(item, value)
					: !parent || !Base.equals(parent[get](), value)) {
				if (type === 'color' && value != null) {
					var alpha = value.getAlpha();
					if (alpha < 1)
						attrs[entry.attribute + '-opacity'] = alpha;
				}
				attrs[entry.attribute] = value == null
					? 'none'
					: type === 'number'
						? formatter.number(value)
						: type === 'color'
							? value.gradient
								? exportGradient(value, item)
								: value.toCSS(true)
							: type === 'array'
								? value.join(',')
								: type === 'lookup'
									? entry.toSVG[value]
									: value;
			}
		});

		if (attrs.opacity === 1)
			delete attrs.opacity;

		if (!item._visible)
			attrs.visibility = 'hidden';

		return setAttributes(node, attrs);
	}

	var definitions;
	function getDefinition(item, type) {
		if (!definitions)
			definitions = { ids: {}, svgs: {} };
		return item && definitions.svgs[type + '-' + item._id];
	}

	function setDefinition(item, node, type) {
		if (!definitions)
			getDefinition();
		var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
		node.id = type + '-' + id;
		definitions.svgs[type + '-' + item._id] = node;
	}

	function exportDefinitions(node, options) {
		var svg = node,
			defs = null;
		if (definitions) {
			svg = node.nodeName.toLowerCase() === 'svg' && node;
			for (var i in definitions.svgs) {
				if (!defs) {
					if (!svg) {
						svg = createElement('svg');
						svg.appendChild(node);
					}
					defs = svg.insertBefore(createElement('defs'),
							svg.firstChild);
				}
				defs.appendChild(definitions.svgs[i]);
			}
			definitions = null;
		}
		return options.asString
				? new XMLSerializer().serializeToString(svg)
				: svg;
	}

	function exportSVG(item, options, isRoot) {
		var exporter = exporters[item._class],
			node = exporter && exporter(item, options);
		if (node) {
			var onExport = options.onExport;
			if (onExport)
				node = onExport(item, node, options) || node;
			var data = JSON.stringify(item._data);
			if (data && data !== '{}' && data !== 'null')
				node.setAttribute('data-paper-data', data);
		}
		return node && applyStyle(item, node, isRoot);
	}

	function setOptions(options) {
		if (!options)
			options = {};
		formatter = new Formatter(options.precision);
		return options;
	}

	Item.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			return exportDefinitions(exportSVG(this, options, true), options);
		}
	});

	Project.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			var layers = this.layers,
				view = this.getView(),
				size = view.getViewSize(),
				node = createElement('svg', {
					x: 0,
					y: 0,
					width: size.width,
					height: size.height,
					version: '1.1',
					xmlns: 'http://www.w3.org/2000/svg',
					'xmlns:xlink': 'http://www.w3.org/1999/xlink'
				}),
				parent = node,
				matrix = view._matrix;
			if (!matrix.isIdentity())
				parent = node.appendChild(
						createElement('g', getTransform(matrix)));
			for (var i = 0, l = layers.length; i < l; i++)
				parent.appendChild(exportSVG(layers[i], options, true));
			return exportDefinitions(node, options);
		}
	});
};

new function() {

	function getValue(node, name, isString, allowNull) {
		var namespace = SVGNamespaces[name],
			value = namespace
				? node.getAttributeNS(namespace, name)
				: node.getAttribute(name);
		if (value === 'null')
			value = null;
		return value == null
				? allowNull
					? null
					: isString
						? ''
						: 0
				: isString
					? value
					: parseFloat(value);
	}

	function getPoint(node, x, y, allowNull) {
		x = getValue(node, x, false, allowNull);
		y = getValue(node, y, false, allowNull);
		return allowNull && (x == null || y == null) ? null
				: new Point(x, y);
	}

	function getSize(node, w, h, allowNull) {
		w = getValue(node, w, false, allowNull);
		h = getValue(node, h, false, allowNull);
		return allowNull && (w == null || h == null) ? null
				: new Size(w, h);
	}

	function convertValue(value, type, lookup) {
		return value === 'none'
				? null
				: type === 'number'
					? parseFloat(value)
					: type === 'array'
						? value ? value.split(/[\s,]+/g).map(parseFloat) : []
						: type === 'color'
							? getDefinition(value) || value
							: type === 'lookup'
								? lookup[value]
								: value;
	}

	function importGroup(node, type, options, isRoot) {
		var nodes = node.childNodes,
			isClip = type === 'clippath',
			item = new Group(),
			project = item._project,
			currentStyle = project._currentStyle,
			children = [];
		if (!isClip) {
			item = applyAttributes(item, node, isRoot);
			project._currentStyle = item._style.clone();
		}
		if (isRoot) {
			var defs = node.querySelectorAll('defs');
			for (var i = 0, l = defs.length; i < l; i++) {
				importSVG(defs[i], options, false);
			}
		}
		for (var i = 0, l = nodes.length; i < l; i++) {
			var childNode = nodes[i],
				child;
			if (childNode.nodeType === 1
					&& childNode.nodeName.toLowerCase() !== 'defs'
					&& (child = importSVG(childNode, options, false))
					&& !(child instanceof Symbol))
				children.push(child);
		}
		item.addChildren(children);
		if (isClip)
			item = applyAttributes(item.reduce(), node, isRoot);
		project._currentStyle = currentStyle;
		if (isClip || type === 'defs') {
			item.remove();
			item = null;
		}
		return item;
	}

	function importPoly(node, type) {
		var coords = node.getAttribute('points').match(
					/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
			points = [];
		for (var i = 0, l = coords.length; i < l; i += 2)
			points.push(new Point(
					parseFloat(coords[i]),
					parseFloat(coords[i + 1])));
		var path = new Path(points);
		if (type === 'polygon')
			path.closePath();
		return path;
	}

	function importPath(node) {
		var data = node.getAttribute('d'),
			param = { pathData: data };
		return (data.match(/m/gi) || []).length > 1 || /z\S+/i.test(data)
				? new CompoundPath(param)
				: new Path(param);
	}

	function importGradient(node, type) {
		var id = (getValue(node, 'href', true) || '').substring(1),
			isRadial = type === 'radialgradient',
			gradient;
		if (id) {
			gradient = definitions[id].getGradient();
		} else {
			var nodes = node.childNodes,
				stops = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					stops.push(applyAttributes(new GradientStop(), child));
			}
			gradient = new Gradient(stops, isRadial);
		}
		var origin, destination, highlight;
		if (isRadial) {
			origin = getPoint(node, 'cx', 'cy');
			destination = origin.add(getValue(node, 'r'), 0);
			highlight = getPoint(node, 'fx', 'fy', true);
		} else {
			origin = getPoint(node, 'x1', 'y1');
			destination = getPoint(node, 'x2', 'y2');
		}
		applyAttributes(
			new Color(gradient, origin, destination, highlight), node);
		return null;
	}

	var importers = {
		'#document': function (node, type, options, isRoot) {
			var nodes = node.childNodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1) {
					var next = child.nextSibling;
					document.body.appendChild(child);
					var item = importSVG(child, options, isRoot);
					if (next) {
						node.insertBefore(child, next);
					} else {
						node.appendChild(child);
					}
					return item;
				}
			}
		},
		g: importGroup,
		svg: importGroup,
		clippath: importGroup,
		polygon: importPoly,
		polyline: importPoly,
		path: importPath,
		lineargradient: importGradient,
		radialgradient: importGradient,

		image: function (node) {
			var raster = new Raster(getValue(node, 'href', true));
			raster.on('load', function() {
				var size = getSize(node, 'width', 'height');
				this.setSize(size);
				var center = this._matrix._transformPoint(
						getPoint(node, 'x', 'y').add(size.divide(2)));
				this.translate(center);
			});
			return raster;
		},

		symbol: function(node, type, options, isRoot) {
			return new Symbol(importGroup(node, type, options, isRoot), true);
		},

		defs: importGroup,

		use: function(node) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				definition = definitions[id],
				point = getPoint(node, 'x', 'y');
			return definition
					? definition instanceof Symbol
						? definition.place(point)
						: definition.clone().translate(point)
					: null;
		},

		circle: function(node) {
			return new Shape.Circle(getPoint(node, 'cx', 'cy'),
					getValue(node, 'r'));
		},

		ellipse: function(node) {
			return new Shape.Ellipse({
				center: getPoint(node, 'cx', 'cy'),
				radius: getSize(node, 'rx', 'ry')
			});
		},

		rect: function(node) {
			var point = getPoint(node, 'x', 'y'),
				size = getSize(node, 'width', 'height'),
				radius = getSize(node, 'rx', 'ry');
			return new Shape.Rectangle(new Rectangle(point, size), radius);
		},

		line: function(node) {
			return new Path.Line(getPoint(node, 'x1', 'y1'),
					getPoint(node, 'x2', 'y2'));
		},

		text: function(node) {
			var text = new PointText(getPoint(node, 'x', 'y')
					.add(getPoint(node, 'dx', 'dy')));
			text.setContent(node.textContent.trim() || '');
			return text;
		}
	};

	function applyTransform(item, value, name, node) {
		var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
			matrix = new Matrix();
		for (var i = 0, l = transforms.length; i < l; i++) {
			var transform = transforms[i];
			if (!transform)
				break;
			var parts = transform.split(/\(\s*/),
				command = parts[0],
				v = parts[1].split(/[\s,]+/g);
			for (var j = 0, m = v.length; j < m; j++)
				v[j] = parseFloat(v[j]);
			switch (command) {
			case 'matrix':
				matrix.concatenate(
						new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
				break;
			case 'rotate':
				matrix.rotate(v[0], v[1], v[2]);
				break;
			case 'translate':
				matrix.translate(v[0], v[1]);
				break;
			case 'scale':
				matrix.scale(v);
				break;
			case 'skewX':
				matrix.skew(v[0], 0);
				break;
			case 'skewY':
				matrix.skew(0, v[0]);
				break;
			}
		}
		item.transform(matrix);
	}

	function applyOpacity(item, value, name) {
		var color = item[name === 'fill-opacity' ? 'getFillColor'
				: 'getStrokeColor']();
		if (color)
			color.setAlpha(parseFloat(value));
	}

	var attributes = Base.set(Base.each(SVGStyles, function(entry) {
		this[entry.attribute] = function(item, value) {
			item[entry.set](convertValue(value, entry.type, entry.fromSVG));
			if (entry.type === 'color' && item instanceof Shape) {
				var color = item[entry.get]();
				if (color)
					color.transform(new Matrix().translate(
							item.getPosition(true).negate()));
			}
		};
	}, {}), {
		id: function(item, value) {
			definitions[value] = item;
			if (item.setName)
				item.setName(value);
		},

		'clip-path': function(item, value) {
			var clip = getDefinition(value);
			if (clip) {
				clip = clip.clone();
				clip.setClipMask(true);
				if (item instanceof Group) {
					item.insertChild(0, clip);
				} else {
					return new Group(clip, item);
				}
			}
		},

		gradientTransform: applyTransform,
		transform: applyTransform,

		'fill-opacity': applyOpacity,
		'stroke-opacity': applyOpacity,

		visibility: function(item, value) {
			item.setVisible(value === 'visible');
		},

		display: function(item, value) {
			item.setVisible(value !== null);
		},

		'stop-color': function(item, value) {
			if (item.setColor)
				item.setColor(value);
		},

		'stop-opacity': function(item, value) {
			if (item._color)
				item._color.setAlpha(parseFloat(value));
		},

		offset: function(item, value) {
			var percentage = value.match(/(.*)%$/);
			item.setRampPoint(percentage
					? percentage[1] / 100
					: parseFloat(value));
		},

		viewBox: function(item, value, name, node, styles) {
			var rect = new Rectangle(convertValue(value, 'array')),
				size = getSize(node, 'width', 'height', true);
			if (item instanceof Group) {
				var scale = size ? rect.getSize().divide(size) : 1,
					matrix = new Matrix().translate(rect.getPoint()).scale(scale);
				item.transform(matrix.inverted());
			} else if (item instanceof Symbol) {
				if (size)
					rect.setSize(size);
				var clip = getAttribute(node, 'overflow', styles) != 'visible',
					group = item._definition;
				if (clip && !rect.contains(group.getBounds())) {
					clip = new Shape.Rectangle(rect).transform(group._matrix);
					clip.setClipMask(true);
					group.addChild(clip);
				}
			}
		}
	});

	function getAttribute(node, name, styles) {
		var attr = node.attributes[name],
			value = attr && attr.value;
		if (!value) {
			var style = Base.camelize(name);
			value = node.style[style];
			if (!value && styles.node[style] !== styles.parent[style])
				value = styles.node[style];
		}
		return !value
				? undefined
				: value === 'none'
					? null
					: value;
	}

	function applyAttributes(item, node, isRoot) {
		var styles = {
			node: DomElement.getStyles(node) || {},
			parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
		};
		Base.each(attributes, function(apply, name) {
			var value = getAttribute(node, name, styles);
			if (value !== undefined)
				item = Base.pick(apply(item, value, name, node, styles), item);
		});
		return item;
	}

	var definitions = {};
	function getDefinition(value) {
		var match = value && value.match(/\((?:#|)([^)']+)/);
		return match && definitions[match[1]];
	}

	function importSVG(source, options, isRoot) {
		if (!source)
			return null;
		if (!options) {
			options = {};
		} else if (typeof options === 'function') {
			options = { onLoad: options };
		}

		var node = source,
			scope = paper;

		function onLoadCallback(svg) {
			paper = scope;
			var item = importSVG(svg, options, isRoot),
				onLoad = options.onLoad,
				view = scope.project && scope.getView();
			if (onLoad)
				onLoad.call(this, item);
			view.update();
		}

		if (isRoot) {
			if (typeof source === 'string' && !/^.*</.test(source)) {
				node = document.getElementById(source);
				if (node) {
					source = null;
				} else {
					return Http.request('get', source, onLoadCallback);
				}
			} else if (typeof File !== 'undefined' && source instanceof File) {
				var reader = new FileReader();
				reader.onload = function() {
					onLoadCallback(reader.result);
				};
				return reader.readAsText(source);
			}
		}

		if (typeof source === 'string')
			node = new DOMParser().parseFromString(source, 'image/svg+xml');
		if (!node.nodeName)
			throw new Error('Unsupported SVG source: ' + source);
		var type = node.nodeName.toLowerCase(),
			importer = importers[type],
			item,
			data = node.getAttribute && node.getAttribute('data-paper-data'),
			settings = scope.settings,
			applyMatrix = settings.applyMatrix;
		settings.applyMatrix = false;
		item = importer && importer(node, type, options, isRoot) || null;
		settings.applyMatrix = applyMatrix;
		if (item) {
			if (type !== '#document' && !(item instanceof Group))
				item = applyAttributes(item, node, isRoot);
			var onImport = options.onImport;
			if (onImport)
				item = onImport(node, item, options) || item;
			if (options.expandShapes && item instanceof Shape) {
				item.remove();
				item = item.toPath();
			}
			if (data)
				item._data = JSON.parse(data);
		}
		if (isRoot) {
			definitions = {};
			if (item && Base.pick(options.applyMatrix, applyMatrix))
				item.matrix.apply(true, true);
		}
		return item;
	}

	Item.inject({
		importSVG: function(node, options) {
			return this.addChild(importSVG(node, options, true));
		}
	});

	Project.inject({
		importSVG: function(node, options) {
			this.activate();
			return importSVG(node, options, true);
		}
	});
};

Base.exports.PaperScript = (function() {
	var exports, define,
		scope = this;
!function(e,r){return"object"==typeof exports&&"object"==typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):(r(e.acorn||(e.acorn={})),void 0)}(this,function(e){"use strict";function r(e){fr=e||{};for(var r in mr)Object.prototype.hasOwnProperty.call(fr,r)||(fr[r]=mr[r]);hr=fr.sourceFile||null}function t(e,r){var t=vr(dr,e);r+=" ("+t.line+":"+t.column+")";var n=new SyntaxError(r);throw n.pos=e,n.loc=t,n.raisedAt=br,n}function n(e){function r(e){if(1==e.length)return t+="return str === "+JSON.stringify(e[0])+";";t+="switch(str){";for(var r=0;r<e.length;++r)t+="case "+JSON.stringify(e[r])+":";t+="return true}return false;"}e=e.split(" ");var t="",n=[];e:for(var a=0;a<e.length;++a){for(var o=0;o<n.length;++o)if(n[o][0].length==e[a].length){n[o].push(e[a]);continue e}n.push([e[a]])}if(n.length>3){n.sort(function(e,r){return r.length-e.length}),t+="switch(str.length){";for(var a=0;a<n.length;++a){var i=n[a];t+="case "+i[0].length+":",r(i)}t+="}"}else r(e);return new Function("str",t)}function a(){this.line=Ar,this.column=br-Sr}function o(){Ar=1,br=Sr=0,Er=!0,u()}function i(e,r){gr=br,fr.locations&&(kr=new a),wr=e,u(),Cr=r,Er=e.beforeExpr}function s(){var e=fr.onComment&&fr.locations&&new a,r=br,n=dr.indexOf("*/",br+=2);if(-1===n&&t(br-2,"Unterminated comment"),br=n+2,fr.locations){Kt.lastIndex=r;for(var o;(o=Kt.exec(dr))&&o.index<br;)++Ar,Sr=o.index+o[0].length}fr.onComment&&fr.onComment(!0,dr.slice(r+2,n),r,br,e,fr.locations&&new a)}function c(){for(var e=br,r=fr.onComment&&fr.locations&&new a,t=dr.charCodeAt(br+=2);pr>br&&10!==t&&13!==t&&8232!==t&&8233!==t;)++br,t=dr.charCodeAt(br);fr.onComment&&fr.onComment(!1,dr.slice(e+2,br),e,br,r,fr.locations&&new a)}function u(){for(;pr>br;){var e=dr.charCodeAt(br);if(32===e)++br;else if(13===e){++br;var r=dr.charCodeAt(br);10===r&&++br,fr.locations&&(++Ar,Sr=br)}else if(10===e||8232===e||8233===e)++br,fr.locations&&(++Ar,Sr=br);else if(e>8&&14>e)++br;else if(47===e){var r=dr.charCodeAt(br+1);if(42===r)s();else{if(47!==r)break;c()}}else if(160===e)++br;else{if(!(e>=5760&&Jt.test(String.fromCharCode(e))))break;++br}}}function l(){var e=dr.charCodeAt(br+1);return e>=48&&57>=e?E(!0):(++br,i(xt))}function f(){var e=dr.charCodeAt(br+1);return Er?(++br,k()):61===e?x(Et,2):x(wt,1)}function d(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Dt,1)}function p(e){var r=dr.charCodeAt(br+1);return r===e?x(124===e?Lt:Ut,2):61===r?x(Et,2):x(124===e?Rt:Tt,1)}function h(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Vt,1)}function m(e){var r=dr.charCodeAt(br+1);return r===e?45==r&&62==dr.charCodeAt(br+2)&&Gt.test(dr.slice(Lr,br))?(br+=3,c(),u(),g()):x(St,2):61===r?x(Et,2):x(At,1)}function v(e){var r=dr.charCodeAt(br+1),t=1;return r===e?(t=62===e&&62===dr.charCodeAt(br+2)?3:2,61===dr.charCodeAt(br+t)?x(Et,t+1):x(jt,t)):33==r&&60==e&&45==dr.charCodeAt(br+2)&&45==dr.charCodeAt(br+3)?(br+=4,c(),u(),g()):(61===r&&(t=61===dr.charCodeAt(br+2)?3:2),x(Ot,t))}function b(e){var r=dr.charCodeAt(br+1);return 61===r?x(qt,61===dr.charCodeAt(br+2)?3:2):x(61===e?Ct:It,1)}function y(e){switch(e){case 46:return l();case 40:return++br,i(mt);case 41:return++br,i(vt);case 59:return++br,i(yt);case 44:return++br,i(bt);case 91:return++br,i(ft);case 93:return++br,i(dt);case 123:return++br,i(pt);case 125:return++br,i(ht);case 58:return++br,i(gt);case 63:return++br,i(kt);case 48:var r=dr.charCodeAt(br+1);if(120===r||88===r)return C();case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return E(!1);case 34:case 39:return A(e);case 47:return f(e);case 37:case 42:return d();case 124:case 38:return p(e);case 94:return h();case 43:case 45:return m(e);case 60:case 62:return v(e);case 61:case 33:return b(e);case 126:return x(It,1)}return!1}function g(e){if(e?br=yr+1:yr=br,fr.locations&&(xr=new a),e)return k();if(br>=pr)return i(Br);var r=dr.charCodeAt(br);if(Qt(r)||92===r)return L();var n=y(r);if(n===!1){var o=String.fromCharCode(r);if("\\"===o||$t.test(o))return L();t(br,"Unexpected character '"+o+"'")}return n}function x(e,r){var t=dr.slice(br,br+r);br+=r,i(e,t)}function k(){for(var e,r,n="",a=br;;){br>=pr&&t(a,"Unterminated regular expression");var o=dr.charAt(br);if(Gt.test(o)&&t(a,"Unterminated regular expression"),e)e=!1;else{if("["===o)r=!0;else if("]"===o&&r)r=!1;else if("/"===o&&!r)break;e="\\"===o}++br}var n=dr.slice(a,br);++br;var s=I();return s&&!/^[gmsiy]*$/.test(s)&&t(a,"Invalid regexp flag"),i(jr,new RegExp(n,s))}function w(e,r){for(var t=br,n=0,a=0,o=null==r?1/0:r;o>a;++a){var i,s=dr.charCodeAt(br);if(i=s>=97?s-97+10:s>=65?s-65+10:s>=48&&57>=s?s-48:1/0,i>=e)break;++br,n=n*e+i}return br===t||null!=r&&br-t!==r?null:n}function C(){br+=2;var e=w(16);return null==e&&t(yr+2,"Expected hexadecimal number"),Qt(dr.charCodeAt(br))&&t(br,"Identifier directly after number"),i(Or,e)}function E(e){var r=br,n=!1,a=48===dr.charCodeAt(br);e||null!==w(10)||t(r,"Invalid number"),46===dr.charCodeAt(br)&&(++br,w(10),n=!0);var o=dr.charCodeAt(br);(69===o||101===o)&&(o=dr.charCodeAt(++br),(43===o||45===o)&&++br,null===w(10)&&t(r,"Invalid number"),n=!0),Qt(dr.charCodeAt(br))&&t(br,"Identifier directly after number");var s,c=dr.slice(r,br);return n?s=parseFloat(c):a&&1!==c.length?/[89]/.test(c)||Tr?t(r,"Invalid number"):s=parseInt(c,8):s=parseInt(c,10),i(Or,s)}function A(e){br++;for(var r="";;){br>=pr&&t(yr,"Unterminated string constant");var n=dr.charCodeAt(br);if(n===e)return++br,i(Dr,r);if(92===n){n=dr.charCodeAt(++br);var a=/^[0-7]+/.exec(dr.slice(br,br+3));for(a&&(a=a[0]);a&&parseInt(a,8)>255;)a=a.slice(0,a.length-1);if("0"===a&&(a=null),++br,a)Tr&&t(br-2,"Octal literal in strict mode"),r+=String.fromCharCode(parseInt(a,8)),br+=a.length-1;else switch(n){case 110:r+="\n";break;case 114:r+="\r";break;case 120:r+=String.fromCharCode(S(2));break;case 117:r+=String.fromCharCode(S(4));break;case 85:r+=String.fromCharCode(S(8));break;case 116:r+="	";break;case 98:r+="\b";break;case 118:r+="";break;case 102:r+="\f";break;case 48:r+="\0";break;case 13:10===dr.charCodeAt(br)&&++br;case 10:fr.locations&&(Sr=br,++Ar);break;default:r+=String.fromCharCode(n)}}else(13===n||10===n||8232===n||8233===n)&&t(yr,"Unterminated string constant"),r+=String.fromCharCode(n),++br}}function S(e){var r=w(16,e);return null===r&&t(yr,"Bad character escape sequence"),r}function I(){Bt=!1;for(var e,r=!0,n=br;;){var a=dr.charCodeAt(br);if(Yt(a))Bt&&(e+=dr.charAt(br)),++br;else{if(92!==a)break;Bt||(e=dr.slice(n,br)),Bt=!0,117!=dr.charCodeAt(++br)&&t(br,"Expecting Unicode escape sequence \\uXXXX"),++br;var o=S(4),i=String.fromCharCode(o);i||t(br-1,"Invalid Unicode escape"),(r?Qt(o):Yt(o))||t(br-4,"Invalid Unicode escape"),e+=i}r=!1}return Bt?e:dr.slice(n,br)}function L(){var e=I(),r=Fr;return Bt||(Wt(e)?r=lt[e]:(fr.forbidReserved&&(3===fr.ecmaVersion?Mt:zt)(e)||Tr&&Xt(e))&&t(yr,"The keyword '"+e+"' is reserved")),i(r,e)}function U(){Ir=yr,Lr=gr,Ur=kr,g()}function R(e){if(Tr=e,br=Lr,fr.locations)for(;Sr>br;)Sr=dr.lastIndexOf("\n",Sr-2)+1,--Ar;u(),g()}function V(){this.type=null,this.start=yr,this.end=null}function T(){this.start=xr,this.end=null,null!==hr&&(this.source=hr)}function q(){var e=new V;return fr.locations&&(e.loc=new T),fr.ranges&&(e.range=[yr,0]),e}function O(e){var r=new V;return r.start=e.start,fr.locations&&(r.loc=new T,r.loc.start=e.loc.start),fr.ranges&&(r.range=[e.range[0],0]),r}function j(e,r){return e.type=r,e.end=Lr,fr.locations&&(e.loc.end=Ur),fr.ranges&&(e.range[1]=Lr),e}function D(e){return fr.ecmaVersion>=5&&"ExpressionStatement"===e.type&&"Literal"===e.expression.type&&"use strict"===e.expression.value}function F(e){return wr===e?(U(),!0):void 0}function B(){return!fr.strictSemicolons&&(wr===Br||wr===ht||Gt.test(dr.slice(Lr,yr)))}function M(){F(yt)||B()||X()}function z(e){wr===e?U():X()}function X(){t(yr,"Unexpected token")}function N(e){"Identifier"!==e.type&&"MemberExpression"!==e.type&&t(e.start,"Assigning to rvalue"),Tr&&"Identifier"===e.type&&Nt(e.name)&&t(e.start,"Assigning to "+e.name+" in strict mode")}function W(e){Ir=Lr=br,fr.locations&&(Ur=new a),Rr=Tr=null,Vr=[],g();var r=e||q(),t=!0;for(e||(r.body=[]);wr!==Br;){var n=J();r.body.push(n),t&&D(n)&&R(!0),t=!1}return j(r,"Program")}function J(){(wr===wt||wr===Et&&"/="==Cr)&&g(!0);var e=wr,r=q();switch(e){case Mr:case Nr:U();var n=e===Mr;F(yt)||B()?r.label=null:wr!==Fr?X():(r.label=lr(),M());for(var a=0;a<Vr.length;++a){var o=Vr[a];if(null==r.label||o.name===r.label.name){if(null!=o.kind&&(n||"loop"===o.kind))break;if(r.label&&n)break}}return a===Vr.length&&t(r.start,"Unsyntactic "+e.keyword),j(r,n?"BreakStatement":"ContinueStatement");case Wr:return U(),M(),j(r,"DebuggerStatement");case Pr:return U(),Vr.push(Zt),r.body=J(),Vr.pop(),z(tt),r.test=P(),M(),j(r,"DoWhileStatement");case _r:if(U(),Vr.push(Zt),z(mt),wr===yt)return $(r,null);if(wr===rt){var i=q();return U(),G(i,!0),j(i,"VariableDeclaration"),1===i.declarations.length&&F(ut)?_(r,i):$(r,i)}var i=K(!1,!0);return F(ut)?(N(i),_(r,i)):$(r,i);case Gr:return U(),cr(r,!0);case Kr:return U(),r.test=P(),r.consequent=J(),r.alternate=F(Hr)?J():null,j(r,"IfStatement");case Qr:return Rr||t(yr,"'return' outside of function"),U(),F(yt)||B()?r.argument=null:(r.argument=K(),M()),j(r,"ReturnStatement");case Yr:U(),r.discriminant=P(),r.cases=[],z(pt),Vr.push(en);for(var s,c;wr!=ht;)if(wr===zr||wr===Jr){var u=wr===zr;s&&j(s,"SwitchCase"),r.cases.push(s=q()),s.consequent=[],U(),u?s.test=K():(c&&t(Ir,"Multiple default clauses"),c=!0,s.test=null),z(gt)}else s||X(),s.consequent.push(J());return s&&j(s,"SwitchCase"),U(),Vr.pop(),j(r,"SwitchStatement");case Zr:return U(),Gt.test(dr.slice(Lr,yr))&&t(Lr,"Illegal newline after throw"),r.argument=K(),M(),j(r,"ThrowStatement");case et:if(U(),r.block=H(),r.handler=null,wr===Xr){var l=q();U(),z(mt),l.param=lr(),Tr&&Nt(l.param.name)&&t(l.param.start,"Binding "+l.param.name+" in strict mode"),z(vt),l.guard=null,l.body=H(),r.handler=j(l,"CatchClause")}return r.guardedHandlers=qr,r.finalizer=F($r)?H():null,r.handler||r.finalizer||t(r.start,"Missing catch or finally clause"),j(r,"TryStatement");case rt:return U(),G(r),M(),j(r,"VariableDeclaration");case tt:return U(),r.test=P(),Vr.push(Zt),r.body=J(),Vr.pop(),j(r,"WhileStatement");case nt:return Tr&&t(yr,"'with' in strict mode"),U(),r.object=P(),r.body=J(),j(r,"WithStatement");case pt:return H();case yt:return U(),j(r,"EmptyStatement");default:var f=Cr,d=K();if(e===Fr&&"Identifier"===d.type&&F(gt)){for(var a=0;a<Vr.length;++a)Vr[a].name===f&&t(d.start,"Label '"+f+"' is already declared");var p=wr.isLoop?"loop":wr===Yr?"switch":null;return Vr.push({name:f,kind:p}),r.body=J(),Vr.pop(),r.label=d,j(r,"LabeledStatement")}return r.expression=d,M(),j(r,"ExpressionStatement")}}function P(){z(mt);var e=K();return z(vt),e}function H(e){var r,t=q(),n=!0,a=!1;for(t.body=[],z(pt);!F(ht);){var o=J();t.body.push(o),n&&e&&D(o)&&(r=a,R(a=!0)),n=!1}return a&&!r&&R(!1),j(t,"BlockStatement")}function $(e,r){return e.init=r,z(yt),e.test=wr===yt?null:K(),z(yt),e.update=wr===vt?null:K(),z(vt),e.body=J(),Vr.pop(),j(e,"ForStatement")}function _(e,r){return e.left=r,e.right=K(),z(vt),e.body=J(),Vr.pop(),j(e,"ForInStatement")}function G(e,r){for(e.declarations=[],e.kind="var";;){var n=q();if(n.id=lr(),Tr&&Nt(n.id.name)&&t(n.id.start,"Binding "+n.id.name+" in strict mode"),n.init=F(Ct)?K(!0,r):null,e.declarations.push(j(n,"VariableDeclarator")),!F(bt))break}return e}function K(e,r){var t=Q(r);if(!e&&wr===bt){var n=O(t);for(n.expressions=[t];F(bt);)n.expressions.push(Q(r));return j(n,"SequenceExpression")}return t}function Q(e){var r=Y(e);if(wr.isAssign){var t=O(r);return t.operator=Cr,t.left=r,U(),t.right=Q(e),N(r),j(t,"AssignmentExpression")}return r}function Y(e){var r=Z(e);if(F(kt)){var t=O(r);return t.test=r,t.consequent=K(!0),z(gt),t.alternate=K(!0,e),j(t,"ConditionalExpression")}return r}function Z(e){return er(rr(),-1,e)}function er(e,r,t){var n=wr.binop;if(null!=n&&(!t||wr!==ut)&&n>r){var a=O(e);a.left=e,a.operator=Cr,U(),a.right=er(rr(),n,t);var o=j(a,/&&|\|\|/.test(a.operator)?"LogicalExpression":"BinaryExpression");return er(o,r,t)}return e}function rr(){if(wr.prefix){var e=q(),r=wr.isUpdate;return e.operator=Cr,e.prefix=!0,Er=!0,U(),e.argument=rr(),r?N(e.argument):Tr&&"delete"===e.operator&&"Identifier"===e.argument.type&&t(e.start,"Deleting local variable in strict mode"),j(e,r?"UpdateExpression":"UnaryExpression")}for(var n=tr();wr.postfix&&!B();){var e=O(n);e.operator=Cr,e.prefix=!1,e.argument=n,N(n),U(),n=j(e,"UpdateExpression")}return n}function tr(){return nr(ar())}function nr(e,r){if(F(xt)){var t=O(e);return t.object=e,t.property=lr(!0),t.computed=!1,nr(j(t,"MemberExpression"),r)}if(F(ft)){var t=O(e);return t.object=e,t.property=K(),t.computed=!0,z(dt),nr(j(t,"MemberExpression"),r)}if(!r&&F(mt)){var t=O(e);return t.callee=e,t.arguments=ur(vt,!1),nr(j(t,"CallExpression"),r)}return e}function ar(){switch(wr){case ot:var e=q();return U(),j(e,"ThisExpression");case Fr:return lr();case Or:case Dr:case jr:var e=q();return e.value=Cr,e.raw=dr.slice(yr,gr),U(),j(e,"Literal");case it:case st:case ct:var e=q();return e.value=wr.atomValue,e.raw=wr.keyword,U(),j(e,"Literal");case mt:var r=xr,t=yr;U();var n=K();return n.start=t,n.end=gr,fr.locations&&(n.loc.start=r,n.loc.end=kr),fr.ranges&&(n.range=[t,gr]),z(vt),n;case ft:var e=q();return U(),e.elements=ur(dt,!0,!0),j(e,"ArrayExpression");case pt:return ir();case Gr:var e=q();return U(),cr(e,!1);case at:return or();default:X()}}function or(){var e=q();return U(),e.callee=nr(ar(),!0),e.arguments=F(mt)?ur(vt,!1):qr,j(e,"NewExpression")}function ir(){var e=q(),r=!0,n=!1;for(e.properties=[],U();!F(ht);){if(r)r=!1;else if(z(bt),fr.allowTrailingCommas&&F(ht))break;var a,o={key:sr()},i=!1;if(F(gt)?(o.value=K(!0),a=o.kind="init"):fr.ecmaVersion>=5&&"Identifier"===o.key.type&&("get"===o.key.name||"set"===o.key.name)?(i=n=!0,a=o.kind=o.key.name,o.key=sr(),wr!==mt&&X(),o.value=cr(q(),!1)):X(),"Identifier"===o.key.type&&(Tr||n))for(var s=0;s<e.properties.length;++s){var c=e.properties[s];if(c.key.name===o.key.name){var u=a==c.kind||i&&"init"===c.kind||"init"===a&&("get"===c.kind||"set"===c.kind);u&&!Tr&&"init"===a&&"init"===c.kind&&(u=!1),u&&t(o.key.start,"Redefinition of property")}}e.properties.push(o)}return j(e,"ObjectExpression")}function sr(){return wr===Or||wr===Dr?ar():lr(!0)}function cr(e,r){wr===Fr?e.id=lr():r?X():e.id=null,e.params=[];var n=!0;for(z(mt);!F(vt);)n?n=!1:z(bt),e.params.push(lr());var a=Rr,o=Vr;if(Rr=!0,Vr=[],e.body=H(!0),Rr=a,Vr=o,Tr||e.body.body.length&&D(e.body.body[0]))for(var i=e.id?-1:0;i<e.params.length;++i){var s=0>i?e.id:e.params[i];if((Xt(s.name)||Nt(s.name))&&t(s.start,"Defining '"+s.name+"' in strict mode"),i>=0)for(var c=0;i>c;++c)s.name===e.params[c].name&&t(s.start,"Argument name clash in strict mode")}return j(e,r?"FunctionDeclaration":"FunctionExpression")}function ur(e,r,t){for(var n=[],a=!0;!F(e);){if(a)a=!1;else if(z(bt),r&&fr.allowTrailingCommas&&F(e))break;t&&wr===bt?n.push(null):n.push(K(!0))}return n}function lr(e){var r=q();return r.name=wr===Fr?Cr:e&&!fr.forbidReserved&&wr.keyword||X(),Er=!1,U(),j(r,"Identifier")}e.version="0.4.0";var fr,dr,pr,hr;e.parse=function(e,t){return dr=String(e),pr=dr.length,r(t),o(),W(fr.program)};var mr=e.defaultOptions={ecmaVersion:5,strictSemicolons:!1,allowTrailingCommas:!0,forbidReserved:!1,locations:!1,onComment:null,ranges:!1,program:null,sourceFile:null},vr=e.getLineInfo=function(e,r){for(var t=1,n=0;;){Kt.lastIndex=n;var a=Kt.exec(e);if(!(a&&a.index<r))break;++t,n=a.index+a[0].length}return{line:t,column:r-n}};e.tokenize=function(e,t){function n(e){return g(e),a.start=yr,a.end=gr,a.startLoc=xr,a.endLoc=kr,a.type=wr,a.value=Cr,a}dr=String(e),pr=dr.length,r(t),o();var a={};return n.jumpTo=function(e,r){if(br=e,fr.locations){Ar=1,Sr=Kt.lastIndex=0;for(var t;(t=Kt.exec(dr))&&t.index<e;)++Ar,Sr=t.index+t[0].length}Er=r,u()},n};var br,yr,gr,xr,kr,wr,Cr,Er,Ar,Sr,Ir,Lr,Ur,Rr,Vr,Tr,qr=[],Or={type:"num"},jr={type:"regexp"},Dr={type:"string"},Fr={type:"name"},Br={type:"eof"},Mr={keyword:"break"},zr={keyword:"case",beforeExpr:!0},Xr={keyword:"catch"},Nr={keyword:"continue"},Wr={keyword:"debugger"},Jr={keyword:"default"},Pr={keyword:"do",isLoop:!0},Hr={keyword:"else",beforeExpr:!0},$r={keyword:"finally"},_r={keyword:"for",isLoop:!0},Gr={keyword:"function"},Kr={keyword:"if"},Qr={keyword:"return",beforeExpr:!0},Yr={keyword:"switch"},Zr={keyword:"throw",beforeExpr:!0},et={keyword:"try"},rt={keyword:"var"},tt={keyword:"while",isLoop:!0},nt={keyword:"with"},at={keyword:"new",beforeExpr:!0},ot={keyword:"this"},it={keyword:"null",atomValue:null},st={keyword:"true",atomValue:!0},ct={keyword:"false",atomValue:!1},ut={keyword:"in",binop:7,beforeExpr:!0},lt={"break":Mr,"case":zr,"catch":Xr,"continue":Nr,"debugger":Wr,"default":Jr,"do":Pr,"else":Hr,"finally":$r,"for":_r,"function":Gr,"if":Kr,"return":Qr,"switch":Yr,"throw":Zr,"try":et,"var":rt,"while":tt,"with":nt,"null":it,"true":st,"false":ct,"new":at,"in":ut,"instanceof":{keyword:"instanceof",binop:7,beforeExpr:!0},"this":ot,"typeof":{keyword:"typeof",prefix:!0,beforeExpr:!0},"void":{keyword:"void",prefix:!0,beforeExpr:!0},"delete":{keyword:"delete",prefix:!0,beforeExpr:!0}},ft={type:"[",beforeExpr:!0},dt={type:"]"},pt={type:"{",beforeExpr:!0},ht={type:"}"},mt={type:"(",beforeExpr:!0},vt={type:")"},bt={type:",",beforeExpr:!0},yt={type:";",beforeExpr:!0},gt={type:":",beforeExpr:!0},xt={type:"."},kt={type:"?",beforeExpr:!0},wt={binop:10,beforeExpr:!0},Ct={isAssign:!0,beforeExpr:!0},Et={isAssign:!0,beforeExpr:!0},At={binop:9,prefix:!0,beforeExpr:!0},St={postfix:!0,prefix:!0,isUpdate:!0},It={prefix:!0,beforeExpr:!0},Lt={binop:1,beforeExpr:!0},Ut={binop:2,beforeExpr:!0},Rt={binop:3,beforeExpr:!0},Vt={binop:4,beforeExpr:!0},Tt={binop:5,beforeExpr:!0},qt={binop:6,beforeExpr:!0},Ot={binop:7,beforeExpr:!0},jt={binop:8,beforeExpr:!0},Dt={binop:10,beforeExpr:!0};e.tokTypes={bracketL:ft,bracketR:dt,braceL:pt,braceR:ht,parenL:mt,parenR:vt,comma:bt,semi:yt,colon:gt,dot:xt,question:kt,slash:wt,eq:Ct,name:Fr,eof:Br,num:Or,regexp:jr,string:Dr};for(var Ft in lt)e.tokTypes["_"+Ft]=lt[Ft];var Bt,Mt=n("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),zt=n("class enum extends super const export import"),Xt=n("implements interface let package private protected public static yield"),Nt=n("eval arguments"),Wt=n("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"),Jt=/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/,Pt="\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc",Ht="\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f",$t=new RegExp("["+Pt+"]"),_t=new RegExp("["+Pt+Ht+"]"),Gt=/[\n\r\u2028\u2029]/,Kt=/\r\n|[\n\r\u2028\u2029]/g,Qt=e.isIdentifierStart=function(e){return 65>e?36===e:91>e?!0:97>e?95===e:123>e?!0:e>=170&&$t.test(String.fromCharCode(e))},Yt=e.isIdentifierChar=function(e){return 48>e?36===e:58>e?!0:65>e?!1:91>e?!0:97>e?95===e:123>e?!0:e>=170&&_t.test(String.fromCharCode(e))},Zt={kind:"loop"},en={kind:"switch"}});

	var binaryOperators = {
		'+': '__add',
		'-': '__subtract',
		'*': '__multiply',
		'/': '__divide',
		'%': '__modulo',
		'==': 'equals',
		'!=': 'equals'
	};

	var unaryOperators = {
		'-': '__negate',
		'+': null
	};

	var fields = Base.each(
		['add', 'subtract', 'multiply', 'divide', 'modulo', 'negate'],
		function(name) {
			this['__' + name] = '#' + name;
		},
		{}
	);
	Point.inject(fields);
	Size.inject(fields);
	Color.inject(fields);

	function __$__(left, operator, right) {
		var handler = binaryOperators[operator];
		if (left && left[handler]) {
			var res = left[handler](right);
			return operator === '!=' ? !res : res;
		}
		switch (operator) {
		case '+': return left + right;
		case '-': return left - right;
		case '*': return left * right;
		case '/': return left / right;
		case '%': return left % right;
		case '==': return left == right;
		case '!=': return left != right;
		}
	}

	function $__(operator, value) {
		var handler = unaryOperators[operator];
		if (handler && value && value[handler])
			return value[handler]();
		switch (operator) {
		case '+': return +value;
		case '-': return -value;
		}
	}

	function parse(code, options) {
		return scope.acorn.parse(code, options);
	}

	function compile(code, url, options) {
		if (!code)
			return '';
		options = options || {};
		url = url || '';

		var insertions = [];

		function getOffset(offset) {
			for (var i = 0, l = insertions.length; i < l; i++) {
				var insertion = insertions[i];
				if (insertion[0] >= offset)
					break;
				offset += insertion[1];
			}
			return offset;
		}

		function getCode(node) {
			return code.substring(getOffset(node.range[0]),
					getOffset(node.range[1]));
		}

		function getBetween(left, right) {
			return code.substring(getOffset(left.range[1]),
					getOffset(right.range[0]));
		}

		function replaceCode(node, str) {
			var start = getOffset(node.range[0]),
				end = getOffset(node.range[1]),
				insert = 0;
			for (var i = insertions.length - 1; i >= 0; i--) {
				if (start > insertions[i][0]) {
					insert = i + 1;
					break;
				}
			}
			insertions.splice(insert, 0, [start, str.length - end + start]);
			code = code.substring(0, start) + str + code.substring(end);
		}

		function walkAST(node, parent) {
			if (!node)
				return;
			for (var key in node) {
				if (key === 'range' || key === 'loc')
					continue;
				var value = node[key];
				if (Array.isArray(value)) {
					for (var i = 0, l = value.length; i < l; i++)
						walkAST(value[i], node);
				} else if (value && typeof value === 'object') {
					walkAST(value, node);
				}
			}
			switch (node.type) {
			case 'UnaryExpression':
				if (node.operator in unaryOperators
						&& node.argument.type !== 'Literal') {
					var arg = getCode(node.argument);
					replaceCode(node, '$__("' + node.operator + '", '
							+ arg + ')');
				}
				break;
			case 'BinaryExpression':
				if (node.operator in binaryOperators
						&& node.left.type !== 'Literal') {
					var left = getCode(node.left),
						right = getCode(node.right),
						between = getBetween(node.left, node.right),
						operator = node.operator;
					replaceCode(node, '__$__(' + left + ','
							+ between.replace(new RegExp('\\' + operator),
								'"' + operator + '"')
							+ ', ' + right + ')');
				}
				break;
			case 'UpdateExpression':
			case 'AssignmentExpression':
				var parentType = parent && parent.type;
				if (!(
						parentType === 'ForStatement'
						|| parentType === 'BinaryExpression'
							&& /^[=!<>]/.test(parent.operator)
						|| parentType === 'MemberExpression' && parent.computed
				)) {
					if (node.type === 'UpdateExpression') {
						var arg = getCode(node.argument),
							exp = '__$__(' + arg + ', "' + node.operator[0]
									+ '", 1)',
							str = arg + ' = ' + exp;
						if (!node.prefix
								&& (parentType === 'AssignmentExpression'
									|| parentType === 'VariableDeclarator')) {
							if (getCode(parent.left || parent.id) === arg)
								str = exp;
							str = arg + '; ' + str;
						}
						replaceCode(node, str);
					} else {
						if (/^.=$/.test(node.operator)
								&& node.left.type !== 'Literal') {
							var left = getCode(node.left),
								right = getCode(node.right);
							replaceCode(node, left + ' = __$__(' + left + ', "'
									+ node.operator[0] + '", ' + right + ')');
						}
					}
				}
				break;
			}
		}
		var sourceMap = null,
			browser = paper.browser,
			version = browser.versionNumber,
			lineBreaks = /\r\n|\n|\r/mg;
		if (browser.chrome && version >= 30
				|| browser.webkit && version >= 537.76
				|| browser.firefox && version >= 23) {
			var offset = 0;
			if (window.location.href.indexOf(url) === 0) {
				var html = document.getElementsByTagName('html')[0].innerHTML;
				offset = html.substr(0, html.indexOf(code) + 1).match(
						lineBreaks).length + 1;
			}
			var mappings = ['AAAA'];
			mappings.length = (code.match(lineBreaks) || []).length + 1 + offset;
			sourceMap = {
				version: 3,
				file: url,
				names:[],
				mappings: mappings.join(';AACA'),
				sourceRoot: '',
				sources: [url]
			};
			var source = options.source || !url && code;
			if (source)
				sourceMap.sourcesContent = [source];
		}
		walkAST(parse(code, { ranges: true }));
		if (sourceMap) {
			code = new Array(offset + 1).join('\n') + code
					+ "\n//# sourceMappingURL=data:application/json;base64,"
					+ (btoa(unescape(encodeURIComponent(
						JSON.stringify(sourceMap)))))
					+ "\n//# sourceURL=" + (url || 'paperscript');
		}
		return code;
	}

	function execute(code, scope, url, options) {
		paper = scope;
		var view = scope.getView(),
			tool = /\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code)
					? new Tool()
					: null,
			toolHandlers = tool ? tool._events : [],
			handlers = ['onFrame', 'onResize'].concat(toolHandlers),
			params = [],
			args = [],
			func;
		code = compile(code, url, options);
		function expose(scope, hidden) {
			for (var key in scope) {
				if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)'
						+ key.replace(/\$/g, '\\$') + '\\b').test(code)) {
					params.push(key);
					args.push(scope[key]);
				}
			}
		}
		expose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },
				true);
		expose(scope);
		handlers = Base.each(handlers, function(key) {
			if (new RegExp('\\s+' + key + '\\b').test(code)) {
				params.push(key);
				this.push(key + ': ' + key);
			}
		}, []).join(', ');
		if (handlers)
			code += '\nreturn { ' + handlers + ' };';
		var browser = paper.browser;
		if (browser.chrome || browser.firefox) {
			var script = document.createElement('script'),
				head = document.head || document.getElementsByTagName('head')[0];
			if (browser.firefox)
				code = '\n' + code;
			script.appendChild(document.createTextNode(
				'paper._execute = function(' + params + ') {' + code + '\n}'
			));
			head.appendChild(script);
			func = paper._execute;
			delete paper._execute;
			head.removeChild(script);
		} else {
			func = Function(params, code);
		}
		var res = func.apply(scope, args) || {};
		Base.each(toolHandlers, function(key) {
			var value = res[key];
			if (value)
				tool[key] = value;
		});
		if (view) {
			if (res.onResize)
				view.setOnResize(res.onResize);
			view.emit('resize', {
				size: view.size,
				delta: new Point()
			});
			if (res.onFrame)
				view.setOnFrame(res.onFrame);
			view.update();
		}
	}

	function loadScript(script) {
		if (/^text\/(?:x-|)paperscript$/.test(script.type)
				&& PaperScope.getAttribute(script, 'ignore') !== 'true') {
			var canvasId = PaperScope.getAttribute(script, 'canvas'),
				canvas = document.getElementById(canvasId),
				src = script.src || script.getAttribute('data-src'),
				async = PaperScope.hasAttribute(script, 'async'),
				scopeAttribute = 'data-paper-scope';
			if (!canvas)
				throw new Error('Unable to find canvas with id "'
						+ canvasId + '"');
			var scope = PaperScope.get(canvas.getAttribute(scopeAttribute))
						|| new PaperScope().setup(canvas);
			canvas.setAttribute(scopeAttribute, scope._id);
			if (src) {
				Http.request('get', src, function(code) {
					execute(code, scope, src);
				}, async);
			} else {
				execute(script.innerHTML, scope, script.baseURI);
			}
			script.setAttribute('data-paper-ignore', 'true');
			return scope;
		}
	}

	function loadAll() {
		Base.each(document.getElementsByTagName('script'), loadScript);
	}

	function load(script) {
		return script ? loadScript(script) : loadAll();
	}

	if (document.readyState === 'complete') {
		setTimeout(loadAll);
	} else {
		DomEvent.add(window, { load: loadAll });
	}

	return {
		compile: compile,
		execute: execute,
		load: load,
		parse: parse
	};

}).call(this);

paper = new (PaperScope.inject(Base.exports, {
	enumerable: true,
	Base: Base,
	Numerical: Numerical,
	Key: Key
}))();

if (typeof define === 'function' && define.amd) {
	define('paper', paper);
} else if (typeof module === 'object' && module) {
	module.exports = paper;
}

return paper;
};

},{}],6:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":3}],7:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result — either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],8:[function(require,module,exports){
/**
 * VexFlow 1.2.36 built on 2015-10-15.
 * Copyright (c) 2010 Mohit Muthanna Cheppudira <mohit@muthanna.com>
 *
 * http://www.vexflow.com  http://github.com/0xfe/vexflow
 */
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements utility methods used by the rest of the VexFlow
// codebase.
//
// ## JSHint Settings
//
/* global window: false */
/* global document: false */

if (typeof Vex === 'undefined') {
  /* global Vex: true */
  Vex = function() {};
}

// Default log function sends all arguments to console.
Vex.L = function(block, args) {
  if (!args) return;
  var line = Array.prototype.slice.call(args).join(" ");
  window.console.log(block + ": " + line);
};

// Default runtime exception.
Vex.RuntimeError = function(code, message) {
  this.code = code;
  this.message = message;
};

Vex.RuntimeError.prototype.toString = function() {
  return "RuntimeError: " + this.message;
};

// Shortcut method for `RuntimeError`.
Vex.RERR = Vex.RuntimeError;

// Merge `destination` hash with `source` hash, overwriting like keys
// in `source` if necessary.
Vex.Merge = function(destination, source) {
  for (var property in source)
    destination[property] = source[property];
  return destination;
};

// DEPRECATED. Use `Math.*`.
Vex.Min = Math.min;
Vex.Max = Math.max;
Vex.forEach = function(a, fn) {
  for (var i=0; i<a.length; i++) {
    fn(a[i],i);
  }
};

// Round number to nearest fractional value (`.5`, `.25`, etc.)
Vex.RoundN = function(x, n) {
  return (x % n) >= (n/2) ?
    parseInt(x / n, 10) * n + n : parseInt(x / n, 10) * n;
};

// Locate the mid point between stave lines. Returns a fractional line if a space.
Vex.MidLine = function(a, b) {
  var mid_line = b + (a - b) / 2;
  if (mid_line % 2 > 0) {
    mid_line = Vex.RoundN(mid_line * 10, 5) / 10;
  }
  return mid_line;
};

// Take `arr` and return a new list consisting of the sorted, unique,
// contents of arr. Does not modify `arr`.
Vex.SortAndUnique = function(arr, cmp, eq) {
  if (arr.length > 1) {
    var newArr = [];
    var last;
    arr.sort(cmp);

    for (var i = 0; i < arr.length; ++i) {
      if (i === 0 || !eq(arr[i], last)) {
        newArr.push(arr[i]);
      }
      last = arr[i];
    }

    return newArr;
  } else {
    return arr;
  }
};

// Check if array `a` contains `obj`.
Vex.Contains = function(a, obj) {
  var i = a.length;
  while (i--) {
    if (a[i] === obj) {
      return true;
    }
  }
  return false;
};

// Get the 2D Canvas context from DOM element `canvas_sel`.
Vex.getCanvasContext = function(canvas_sel) {
  if (!canvas_sel)
    throw new Vex.RERR("BadArgument", "Invalid canvas selector: " + canvas_sel);

  var canvas = document.getElementById(canvas_sel);
  if (!(canvas && canvas.getContext)) {
    throw new Vex.RERR("UnsupportedBrowserError",
        "This browser does not support HTML5 Canvas");
  }

  return canvas.getContext('2d');
};

// Draw a tiny dot marker on the specified canvas. A great debugging aid.
//
// `ctx`: Canvas context.
// `x`, `y`: Dot coordinates.
Vex.drawDot = function(ctx, x, y, color) {
  var c = color || "#f55";
  ctx.save();
  ctx.setFillStyle(c);

  //draw a circle
  ctx.beginPath();
  ctx.arc(x, y, 3, 0, Math.PI*2, true);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
};

// Benchmark. Run function `f` once and report time elapsed shifted by `s` milliseconds.
Vex.BM = function(s, f) {
  var start_time = new Date().getTime();
  f();
  var elapsed = new Date().getTime() - start_time;
  Vex.L(s + elapsed + "ms");
};

// Basic classical inheritance helper. Usage:
// ```
// // Vex.Inherit(Child, Parent, {
// //   getName: function() {return this.name;},
// //   setName: function(name) {this.name = name}
// // });
// //
// // Returns 'Child'.
// ```
Vex.Inherit = (function () {
  var F = function () {};
  // `C` is Child. `P` is parent. `O` is an object to
  // to extend `C` with.
  return function (C, P, O) {
    F.prototype = P.prototype;
    C.prototype = new F();
    C.superclass = P.prototype;
    C.prototype.constructor = C;
    Vex.Merge(C.prototype, O);
    return C;
  };
}());

// Get stack trace.
Vex.StackTrace = function() {
  var err = new Error();
  return err.stack;
};

// Dump warning to console.
Vex.W = function() {
  var line = Array.prototype.slice.call(arguments).join(" ");
  window.console.log("Warning: ", line, Vex.StackTrace());
};

// Used by various classes (e.g., SVGContext) to provide a
// unique prefix to element names (or other keys in shared namespaces).
Vex.Prefix = function(text) {
  return Vex.Prefix.prefix + text;
};
Vex.Prefix.prefix = "vf-";

// UMD to export Vex.
//
/* global require: false */
/* global define: false */
/* global module: false */
if (typeof require == "function") {
  try {
    module.exports = Vex;
  } catch (e) {}
} else if (typeof define == "function" && define.amd) {
  define("Vex", [], function(){ return Vex; });
} else {
  (this || window)["Vex"] = Vex;
}

/**
 * Vex Flow - Mohit Muthanna <mohit@muthanna.com>
 */

/**
 * New namespace.
 */

if (typeof Vex.Flow === 'undefined') {
  Vex.Flow = {
    /**
     * The resolution used for all the rhythm timing in this
     * library.
     *
     * @const
     * @type {number}
     */
    RESOLUTION: 16384,

    /* Kerning (DEPRECATED) */
    IsKerned: true
  };
}

// Fraction class that represents a rational number
// @author zz85
// @author incompleteopus (modifications)

Vex.Flow.Fraction = (function() {
  function Fraction(numerator, denominator) {
    this.set(numerator, denominator);
  }

  /**
   * GCD: Find greatest common divisor using Euclidean algorithm
   */
  Fraction.GCD = function(a, b) {
    if (typeof a !== "number" || typeof b !== "number") {
      throw new Vex.RERR("BadArgument", "Invalid numbers: " + a + ", " + b);
    }

    var t;

    while (b !== 0) {
      t = b;
      b = a % b;
      a = t;
    }

    return a;
  };

  /**
   * LCM: Lowest common multiple
   */
  Fraction.LCM = function(a, b) {
    return ((a * b) / Fraction.GCD(a, b));
  };

  /**
   * LCMM: Lowest common multiple for more than two numbers
   */
  Fraction.LCMM = function(args) {
    if (args.length === 0) {
      return 0;
    } else if (args.length == 1) {
      return args[0];
    } else if (args.length == 2) {
      return Vex.Flow.Fraction.LCM(args[0], args[1]);
    } else {
      var arg0 = args[0];
      args.shift();
      return Fraction.LCM(arg0, Vex.Flow.Fraction.LCMM(args));
    }
  };

  Fraction.prototype = {
    set: function(numerator, denominator) {
      this.numerator = numerator === undefined ? 1 : numerator;
      this.denominator = denominator === undefined ? 1 : denominator;
      return this;
    },

    value: function() {
      return this.numerator / this.denominator;
    },

    simplify: function() {
      var u = this.numerator;
      var d = this.denominator;

      var gcd = Vex.Flow.Fraction.GCD(u, d);
      u /= gcd;
      d /= gcd;

      if (d < 0) {
        d = -d;
        u = -u;
      }
      return this.set(u, d);
    },

    add: function(param1, param2) {
      var otherNumerator;
      var otherDenominator;

      if (param1 instanceof Vex.Flow.Fraction) {
        otherNumerator = param1.numerator;
        otherDenominator = param1.denominator;
      } else {
        if (param1 !== undefined) {
          otherNumerator = param1;
        } else {
          otherNumerator = 0;
        }

        if (param2 !== undefined) {
          otherDenominator = param2;
        } else {
          otherDenominator = 1;
        }
      }

      var lcm = Vex.Flow.Fraction.LCM(this.denominator, otherDenominator);
      var a = lcm / this.denominator;
      var b = lcm / otherDenominator;

      var u = this.numerator * a + otherNumerator * b;
      return this.set(u, lcm);
    },

    subtract: function(param1, param2) {
      var otherNumerator;
      var otherDenominator;

      if (param1 instanceof Vex.Flow.Fraction) {
        otherNumerator = param1.numerator;
        otherDenominator = param1.denominator;
      } else {
        if (param1 !== undefined) {
          otherNumerator = param1;
        } else {
          otherNumerator = 0;
        }

        if (param2 !== undefined) {
          otherDenominator = param2;
        } else {
          otherDenominator = 1;
        }
      }

      var lcm = Vex.Flow.Fraction.LCM(this.denominator, otherDenominator);
      var a = lcm / this.denominator;
      var b = lcm / otherDenominator;

      var u = this.numerator * a - otherNumerator * b;
      return this.set(u, lcm);
    },

    multiply: function(param1, param2) {
      var otherNumerator;
      var otherDenominator;

      if (param1 instanceof Vex.Flow.Fraction) {
        otherNumerator = param1.numerator;
        otherDenominator = param1.denominator;
      } else {
        if (param1 !== undefined) {
          otherNumerator = param1;
        } else {
          otherNumerator = 1;
        }

        if (param2 !== undefined) {
          otherDenominator = param2;
        } else {
          otherDenominator = 1;
        }
      }

      return this.set(this.numerator * otherNumerator, this.denominator * otherDenominator);
    },

    divide: function(param1, param2) {
      var otherNumerator;
      var otherDenominator;

      if (param1 instanceof Vex.Flow.Fraction) {
        otherNumerator = param1.numerator;
        otherDenominator = param1.denominator;
      } else {
        if (param1 !== undefined) {
          otherNumerator = param1;
        } else {
          otherNumerator = 1;
        }

        if (param2 !== undefined) {
          otherDenominator = param2;
        } else {
          otherDenominator = 1;
        }
      }

      return this.set(this.numerator * otherDenominator, this.denominator * otherNumerator);
    },


    // Simplifies both sides and checks if they are equal.
    equals: function(compare) {
      var a = Vex.Flow.Fraction.__compareA.copy(compare).simplify();
      var b = Vex.Flow.Fraction.__compareB.copy(this).simplify();

      return (a.numerator === b.numerator) && (a.denominator === b.denominator);
    },
    
    // Greater than operator.
    greaterThan: function(compare) {
      var a = Vex.Flow.Fraction.__compareB.copy(this);
      a.subtract(compare);
      return (a.numerator > 0);
    },
    
    // Greater than or equals operator.
    greaterThanEquals: function(compare) {
      var a = Vex.Flow.Fraction.__compareB.copy(this);
      a.subtract(compare);
      return (a.numerator >= 0);
    },

    // Less than operator.
    lessThan: function(compare) {
      return !(this.greaterThanEquals(compare));  
    },

    // Less than or equals operator.
    lessThanEquals: function(compare) {
      return !(this.greaterThan(compare));  
    },

    // Creates a new copy with this current values.
    clone: function() {
      return new Vex.Flow.Fraction(this.numerator, this.denominator);
    },

    // Copies value of another Fraction into itself.
    copy: function(copy) {
      return this.set(copy.numerator, copy.denominator);
    },

    // Returns the integer component eg. (4/2) == 2
    quotient: function() {
      return Math.floor(this.numerator / this.denominator);
    },

    // Returns the fraction component when reduced to a mixed number
    fraction: function() {
      return this.numerator % this.denominator;
    },

    // Returns the absolute value
    abs: function() {
      this.denominator = Math.abs(this.denominator);
      this.numerator = Math.abs(this.numerator);
      return this;
    },

    // Returns a raw string representation
    toString: function() {
      return this.numerator + '/' + this.denominator;
    },

    // Returns a simplified string respresentation
    toSimplifiedString: function() {
      return Vex.Flow.Fraction.__tmp.copy(this).simplify().toString();
    },

    // Returns string representation in mixed form
    toMixedString: function() {
      var s = '';
      var q = this.quotient();
      var f = Vex.Flow.Fraction.__tmp.copy(this);

      if (q < 0) {
        f.abs().fraction();
      } else {
        f.fraction();
      }

      if (q !== 0) {
        s += q;

        if (f.numerator !== 0) {
          s += ' ' + f.toSimplifiedString();
        }
      } else {
        if (f.numerator === 0) {
          s = '0';
        } else {
          s = f.toSimplifiedString();
        }
      }

      return s;
    },

    // Parses a fraction string
    parse: function(str) {
      var i = str.split('/');
      var n = parseInt(i[0], 10);
      var d = (i[1]) ? parseInt(i[1], 10) : 1;

      return this.set(n, d);
    }
  };

  // Temporary cached objects
  Fraction.__compareA = new Fraction();
  Fraction.__compareB = new Fraction();
  Fraction.__tmp = new Fraction();

  return Fraction;
}());


// Vex Flow Notation
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Muthanna 2010
//
// Requires vex.js.

Vex.Flow.STEM_WIDTH = 1.5;
Vex.Flow.STEM_HEIGHT = 32;
Vex.Flow.STAVE_LINE_THICKNESS = 2;

Vex.Flow.clefProperties = function(clef) {
  if (!clef) throw new Vex.RERR("BadArgument", "Invalid clef: " + clef);

  var props = Vex.Flow.clefProperties.values[clef];
  if (!props) throw new Vex.RERR("BadArgument", "Invalid clef: " + clef);

  return props;
};

Vex.Flow.clefProperties.values = {
  'treble':  { line_shift: 0 },
  'bass':    { line_shift: 6 },
  'tenor':   { line_shift: 4 },
  'alto':    { line_shift: 3 },
  'soprano': { line_shift: 1 },
  'percussion': { line_shift: 0 },
  'mezzo-soprano': { line_shift: 2 },
  'baritone-c': { line_shift: 5 },
  'baritone-f': { line_shift: 5 },
  'subbass': { line_shift: 7 },
  'french': { line_shift: -1 }
};

/*
  Take a note in the format "Key/Octave" (e.g., "C/5") and return properties.

  The last argument, params, is a struct the currently can contain one option,
  octave_shift for clef ottavation (0 = default; 1 = 8va; -1 = 8vb, etc.).
*/
Vex.Flow.keyProperties = function(key, clef, params) {
  if (clef === undefined) {
    clef = 'treble';
  }
  var options = {
    octave_shift: 0
  };
  if (typeof params == "object") {
    Vex.Merge(options, params);
  }

  var pieces = key.split("/");

  if (pieces.length < 2) {
    throw new Vex.RERR("BadArguments",
        "Key must have note + octave and an optional glyph: " + key);
  }

  var k = pieces[0].toUpperCase();
  var value = Vex.Flow.keyProperties.note_values[k];
  if (!value) throw new Vex.RERR("BadArguments", "Invalid key name: " + k);
  if (value.octave) pieces[1] = value.octave;

  var o = parseInt(pieces[1]);

  // Octave_shift is the shift to compensate for clef 8va/8vb.
  o += -1 * options.octave_shift;

  var base_index = (o * 7) - (4 * 7);
  var line = (base_index + value.index) / 2;
  line += Vex.Flow.clefProperties(clef).line_shift;

  var stroke = 0;

  if (line <= 0 && (((line * 2) % 2) === 0)) stroke = 1;  // stroke up
  if (line >= 6 && (((line * 2) % 2) === 0)) stroke = -1; // stroke down

  // Integer value for note arithmetic.
  var int_value = (typeof(value.int_val)!='undefined') ? (o * 12) +
    value.int_val : null;

  /* Check if the user specified a glyph. */
  var code = value.code;
  var shift_right = value.shift_right;
  if ((pieces.length > 2) && (pieces[2])) {
    var glyph_name = pieces[2].toUpperCase();
    var note_glyph = Vex.Flow.keyProperties.note_glyph[glyph_name];
    if (note_glyph) {
      code = note_glyph.code;
      shift_right = note_glyph.shift_right;
    }
  }

  return {
    key: k,
    octave: o,
    line: line,
    int_value: int_value,
    accidental: value.accidental,
    code: code,
    stroke: stroke,
    shift_right: shift_right,
    displaced: false
  };
};

Vex.Flow.keyProperties.note_values = {
  'C':  { index: 0, int_val: 0, accidental: null },
  'CN': { index: 0, int_val: 0, accidental: "n" },
  'C#': { index: 0, int_val: 1, accidental: "#" },
  'C##': { index: 0, int_val: 2, accidental: "##" },
  'CB': { index: 0, int_val: -1, accidental: "b" },
  'CBB': { index: 0, int_val: -2, accidental: "bb" },
  'D':  { index: 1, int_val: 2, accidental: null },
  'DN': { index: 1, int_val: 2, accidental: "n" },
  'D#': { index: 1, int_val: 3, accidental: "#" },
  'D##': { index: 1, int_val: 4, accidental: "##" },
  'DB': { index: 1, int_val: 1, accidental: "b" },
  'DBB': { index: 1, int_val: 0, accidental: "bb" },
  'E':  { index: 2, int_val: 4, accidental: null },
  'EN': { index: 2, int_val: 4, accidental: "n" },
  'E#': { index: 2, int_val: 5, accidental: "#" },
  'E##': { index: 2, int_val: 6, accidental: "##" },
  'EB': { index: 2, int_val: 3, accidental: "b" },
  'EBB': { index: 2, int_val: 2, accidental: "bb" },
  'F':  { index: 3, int_val: 5, accidental: null },
  'FN': { index: 3, int_val: 5, accidental: "n" },
  'F#': { index: 3, int_val: 6, accidental: "#" },
  'F##': { index: 3, int_val: 7, accidental: "##" },
  'FB': { index: 3, int_val: 4, accidental: "b" },
  'FBB': { index: 3, int_val: 3, accidental: "bb" },
  'G':  { index: 4, int_val: 7, accidental: null },
  'GN': { index: 4, int_val: 7, accidental: "n" },
  'G#': { index: 4, int_val: 8, accidental: "#" },
  'G##': { index: 4, int_val: 9, accidental: "##" },
  'GB': { index: 4, int_val: 6, accidental: "b" },
  'GBB': { index: 4, int_val: 5, accidental: "bb" },
  'A':  { index: 5, int_val: 9, accidental: null },
  'AN': { index: 5, int_val: 9, accidental: "n" },
  'A#': { index: 5, int_val: 10, accidental: "#" },
  'A##': { index: 5, int_val: 11, accidental: "##" },
  'AB': { index: 5, int_val: 8, accidental: "b" },
  'ABB': { index: 5, int_val: 7, accidental: "bb" },
  'B':  { index: 6, int_val: 11, accidental: null },
  'BN': { index: 6, int_val: 11, accidental: "n" },
  'B#': { index: 6, int_val: 12, accidental: "#" },
  'B##': { index: 6, int_val: 13, accidental: "##" },
  'BB': { index: 6, int_val: 10, accidental: "b" },
  'BBB': { index: 6, int_val: 9, accidental: "bb" },
  'R': { index: 6, int_val: 9, rest: true }, // Rest
  'X':  {
    index: 6,
    accidental: "",
    octave: 4,
    code: "v3e",
    shift_right: 5.5
  }
};

Vex.Flow.keyProperties.note_glyph = {
  /* Diamond */
  'D0':  { code: "v27", shift_right: -0.5 },
  'D1':  { code: "v2d", shift_right: -0.5 },
  'D2':  { code: "v22", shift_right: -0.5 },
  'D3':  { code: "v70", shift_right: -0.5 },

  /* Triangle */
  'T0':  { code: "v49", shift_right: -2 },
  'T1':  { code: "v93", shift_right: 0.5 },
  'T2':  { code: "v40", shift_right: 0.5 },
  'T3':  { code: "v7d", shift_right: 0.5 },

  /* Cross */
  'X0':  { code: "v92", shift_right: -2 },
  'X1':  { code: "v95", shift_right: -0.5 },
  'X2':  { code: "v7f", shift_right: 0.5 },
  'X3':  { code: "v3b", shift_right: -2 }
};

Vex.Flow.integerToNote = function(integer) {
  if (typeof(integer) == "undefined")
    throw new Vex.RERR("BadArguments", "Undefined integer for integerToNote");

  if (integer < -2)
    throw new Vex.RERR("BadArguments",
        "integerToNote requires integer > -2: " + integer);

  var noteValue = Vex.Flow.integerToNote.table[integer];
  if (!noteValue)
    throw new Vex.RERR("BadArguments", "Unknown note value for integer: " +
        integer);

  return noteValue;
};

Vex.Flow.integerToNote.table = {
  0: "C",
  1: "C#",
  2: "D",
  3: "D#",
  4: "E",
  5: "F",
  6: "F#",
  7: "G",
  8: "G#",
  9: "A",
  10: "A#",
  11: "B"
};


Vex.Flow.tabToGlyph = function(fret) {
  var glyph = null;
  var width = 0;
  var shift_y = 0;

  if (fret.toString().toUpperCase() == "X") {
    glyph = "v7f";
    width = 7;
    shift_y = -4.5;
  } else {
    width = Vex.Flow.textWidth(fret.toString());
  }

  return {
    text: fret,
    code: glyph,
    width: width,
    shift_y: shift_y
  };
};

Vex.Flow.textWidth = function(text) {
  return 6 * text.toString().length;
};

Vex.Flow.articulationCodes = function(artic) {
  return Vex.Flow.articulationCodes.articulations[artic];
};

Vex.Flow.articulationCodes.articulations = {
  "a.": {   // Staccato
    code: "v23",
    width: 4,
    shift_right: -2,
    shift_up: 8,
    shift_down: 0,
    between_lines: true
  },
  "av": {   // Staccatissimo
    code: "v28",
    width: 4,
    shift_right: 0,
    shift_up: 11,
    shift_down: 5,
    between_lines: true
  },
  "a>": {   // Accent
    code: "v42",
    width: 10,
    shift_right: 5,
    shift_up: 8,
    shift_down: 1,
    between_lines: true
  },
  "a-": {   // Tenuto
    code: "v25",
    width: 9,
    shift_right: -4,
    shift_up: 17,
    shift_down: 10,
    between_lines: true
  },
  "a^": {   // Marcato
    code: "va",
    width: 8,
    shift_right: 0,
    shift_up: -4,
    shift_down: -2,
    between_lines: false
  },
  "a+": {   // Left hand pizzicato
    code: "v8b",
    width: 9,
    shift_right: -4,
    shift_up: 12,
    shift_down: 12,
    between_lines: false
  },
  "ao": {   // Snap pizzicato
    code: "v94",
    width: 8,
    shift_right: 0,
    shift_up: -4,
    shift_down: 6,
    between_lines: false
  },
  "ah": {   // Natural harmonic or open note
    code: "vb9",
    width: 7,
    shift_right: 0,
    shift_up: -4,
    shift_down: 4,
    between_lines: false
  },
  "a@a": {   // Fermata above staff
    code: "v43",
    width: 25,
    shift_right: 0,
    shift_up: 8,
    shift_down: 10,
    between_lines: false
  },
  "a@u": {   // Fermata below staff
    code: "v5b",
    width: 25,
    shift_right: 0,
    shift_up: 0,
    shift_down: -4,
    between_lines: false
  },
  "a|": {   // Bow up - up stroke
    code: "v75",
    width: 8,
    shift_right: 0,
    shift_up: 8,
    shift_down: 10,
    between_lines: false
  },
  "am": {   // Bow down - down stroke
    code: "v97",
    width: 13,
    shift_right: 0,
    shift_up: 10,
    shift_down: 12,
    between_lines: false
  },
  "a,": {   // Choked
    code: "vb3",
    width: 6,
    shift_right: 8,
    shift_up: -4,
    shift_down: 4,
    between_lines: false
  }
};

Vex.Flow.accidentalCodes = function(acc) {
  return Vex.Flow.accidentalCodes.accidentals[acc];
};

Vex.Flow.accidentalCodes.accidentals = {
  "#": {
    code: "v18",
    width: 10,
    gracenote_width: 4.5,
    shift_right: 0,
    shift_down: 0
  },
  "##": {
    code: "v7f",
    width: 13,
    gracenote_width: 6,
    shift_right: -1,
    shift_down: 0
  },
  "b": {
    code: "v44",
    width: 8,
    gracenote_width: 4.5,
    shift_right: 0,
    shift_down: 0
  },
  "bb": {
    code: "v26",
    width: 14,
    gracenote_width: 8,
    shift_right: -3,
    shift_down: 0
  },
  "n": {
    code: "v4e",
    width: 8,
    gracenote_width: 4.5,
    shift_right: 0,
    shift_down: 0
  },
  "{": {   // Left paren for cautionary accidentals
    code: "v9c",
    width: 5,
    shift_right: 2,
    shift_down: 0
  },
  "}": {   // Right paren for cautionary accidentals
    code: "v84",
    width: 5,
    shift_right: 0,
    shift_down: 0
  },
  "db": {
    code: "v9e",
    width: 16,
    shift_right: 0,
    shift_down: 0
  },
  "d": {
    code: "vab",
    width: 10,
    shift_right: 0,
    shift_down: 0
  },
  "bbs": {
    code: "v90",
    width: 13,
    shift_right: 0,
    shift_down: 0
  },
  "++": {
    code: "v51",
    width: 13,
    shift_right: 0,
    shift_down: 0
  },
  "+": {
    code: "v78",
    width: 8,
    shift_right: 0,
    shift_down: 0
  }
};

Vex.Flow.accidentalColumnsTable = {
  1 : { a : [1], b : [1]},
  2 : { a : [1, 2] },
  3 : { a : [1, 3, 2], b : [1, 2, 1], second_on_bottom : [1, 2, 3] },
  4 : { a : [1, 3, 4, 2], b : [1, 2, 3, 1], spaced_out_tetrachord : [1, 2, 1, 2] },
  5 : { a : [1, 3, 5, 4, 2], b : [1, 2, 4, 3, 1],
        spaced_out_pentachord : [1, 2, 3, 2, 1],
        very_spaced_out_pentachord : [1, 2, 1, 2, 1] },
  6 : { a : [1, 3, 5, 6, 4, 2], b : [1, 2, 4, 5, 3, 1],
        spaced_out_hexachord : [1, 3, 2, 1, 3, 2],
        very_spaced_out_hexachord : [1, 2, 1, 2, 1, 2] }
};

Vex.Flow.ornamentCodes = function(acc) {
  return Vex.Flow.ornamentCodes.ornaments[acc];
};

Vex.Flow.ornamentCodes.ornaments = {
  "mordent": {
    code: "v1e",
    shift_right: 1,
    shift_up: 0,
    shift_down: 5,
    width: 14,
  },
  "mordent_inverted": {
    code: "v45",
    shift_right: 1,
    shift_up: 0,
    shift_down: 5,
    width: 14,
  },
  "turn": {
    code: "v72",
    shift_right: 1,
    shift_up: 0,
    shift_down: 5,
    width: 20,
  },
  "turn_inverted": {
    code: "v33",
    shift_right: 1,
    shift_up: 0,
    shift_down: 6,
    width: 20,
  },
  "tr": {
    code: "v1f",
    shift_right: 0,
    shift_up: 5,
    shift_down: 15,
    width: 10,
  },
  "upprall": {
    code: "v60",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "downprall": {
    code: "vb4",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "prallup": {
    code: "v6d",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "pralldown": {
    code: "v2c",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "upmordent": {
    code: "v29",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "downmordent": {
    code: "v68",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "lineprall": {
    code: "v20",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "prallprall": {
    code: "v86",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  }
};

Vex.Flow.keySignature = function(spec) {
  var keySpec = Vex.Flow.keySignature.keySpecs[spec];

  if (!keySpec) {
    throw new Vex.RERR("BadKeySignature",
        "Bad key signature spec: '" + spec + "'");
  }

  if (!keySpec.acc) {
    return [];
  }

  var notes = Vex.Flow.keySignature.accidentalList(keySpec.acc);

  var acc_list = [];
  for (var i = 0; i < keySpec.num; ++i) {
    var line = notes[i];
    acc_list.push({type: keySpec.acc, line: line});
  }

  return acc_list;
};

Vex.Flow.keySignature.keySpecs = {
  "C": {acc: null, num: 0},
  "Am": {acc: null, num: 0},
  "F": {acc: "b", num: 1},
  "Dm": {acc: "b", num: 1},
  "Bb": {acc: "b", num: 2},
  "Gm": {acc: "b", num: 2},
  "Eb": {acc: "b", num: 3},
  "Cm": {acc: "b", num: 3},
  "Ab": {acc: "b", num: 4},
  "Fm": {acc: "b", num: 4},
  "Db": {acc: "b", num: 5},
  "Bbm": {acc: "b", num: 5},
  "Gb": {acc: "b", num: 6},
  "Ebm": {acc: "b", num: 6},
  "Cb": {acc: "b", num: 7},
  "Abm": {acc: "b", num: 7},
  "G": {acc: "#", num: 1},
  "Em": {acc: "#", num: 1},
  "D": {acc: "#", num: 2},
  "Bm": {acc: "#", num: 2},
  "A": {acc: "#", num: 3},
  "F#m": {acc: "#", num: 3},
  "E": {acc: "#", num: 4},
  "C#m": {acc: "#", num: 4},
  "B": {acc: "#", num: 5},
  "G#m": {acc: "#", num: 5},
  "F#": {acc: "#", num: 6},
  "D#m": {acc: "#", num: 6},
  "C#": {acc: "#", num: 7},
  "A#m": {acc: "#", num: 7}
};

Vex.Flow.unicode = {
  // Unicode accidentals
  "sharp": String.fromCharCode(parseInt('266F', 16)),
  "flat" : String.fromCharCode(parseInt('266D', 16)),
  "natural": String.fromCharCode(parseInt('266E', 16)),
  // Major Chord
  "triangle": String.fromCharCode(parseInt('25B3', 16)),
  // half-diminished
  "o-with-slash": String.fromCharCode(parseInt('00F8', 16)),
   // Diminished
  "degrees": String.fromCharCode(parseInt('00B0', 16)),
  "circle": String.fromCharCode(parseInt('25CB', 16))
};

Vex.Flow.keySignature.accidentalList = function(acc) {
  if (acc == "b") {
    return [2, 0.5, 2.5, 1, 3, 1.5, 3.5];
  }
  else if (acc == "#") {
    return [0, 1.5, -0.5, 1, 2.5, 0.5, 2]; }
};

Vex.Flow.parseNoteDurationString = function(durationString) {
  if (typeof(durationString) !== "string") {
    return null;
  }

  var regexp = /(\d*\/?\d+|[a-z])(d*)([nrhms]|$)/;

  var result = regexp.exec(durationString);
  if (!result) {
    return null;
  }

  var duration = result[1];
  var dots = result[2].length;
  var type = result[3];

  if (type.length === 0) {
    type = "n";
  }

  return {
    duration: duration,
    dots: dots,
    type: type
  };
};

Vex.Flow.parseNoteData = function(noteData) {
  var duration = noteData.duration;

  // Preserve backwards-compatibility
  var durationStringData = Vex.Flow.parseNoteDurationString(duration);
  if (!durationStringData) {
    return null;
  }

  var ticks = Vex.Flow.durationToTicks(durationStringData.duration);
  if (ticks == null) {
    return null;
  }

  var type = noteData.type;

  if (type) {
    if (!(type === "n" || type === "r" || type === "h" ||
          type === "m" || type === "s")) {
      return null;
    }
  } else {
    type = durationStringData.type;
    if (!type) {
      type = "n";
    }
  }

  var dots = 0;
  if (noteData.dots) {
    dots = noteData.dots;
  } else {
    dots = durationStringData.dots;
  }

  if (typeof(dots) !== "number") {
    return null;
  }

  var currentTicks = ticks;

  for (var i = 0; i < dots; i++) {
    if (currentTicks <= 1) {
      return null;
    }

    currentTicks = currentTicks / 2;
    ticks += currentTicks;
  }

  return {
    duration: durationStringData.duration,
    type: type,
    dots: dots,
    ticks: ticks
  };
};

// Used to convert duration aliases to the number based duration.
// If the input isn't an alias, simply return the input.
//
// example: 'q' -> '4', '8' -> '8'
Vex.Flow.sanitizeDuration = function(duration) {
  var alias = Vex.Flow.durationAliases[duration];
  if (alias !== undefined) {
    duration = alias;
  }

  if (Vex.Flow.durationToTicks.durations[duration] === undefined) {
    throw new Vex.RERR('BadArguments',
      'The provided duration is not valid');
  }

  return duration;
};

// Convert the `duration` to an fraction
Vex.Flow.durationToFraction = function(duration) {
  return new Vex.Flow.Fraction().parse(Vex.Flow.sanitizeDuration(duration));
};

// Convert the `duration` to an number
Vex.Flow.durationToNumber = function(duration) {
  return Vex.Flow.durationToFraction(duration).value();
};

// Convert the `duration` to total ticks
Vex.Flow.durationToTicks = function(duration) {
  duration = Vex.Flow.sanitizeDuration(duration);

  var ticks = Vex.Flow.durationToTicks.durations[duration];
  if (ticks === undefined) {
    return null;
  }

  return ticks;
};

Vex.Flow.durationToTicks.durations = {
  "1/2":  Vex.Flow.RESOLUTION * 2,
  "1":    Vex.Flow.RESOLUTION / 1,
  "2":    Vex.Flow.RESOLUTION / 2,
  "4":    Vex.Flow.RESOLUTION / 4,
  "8":    Vex.Flow.RESOLUTION / 8,
  "16":   Vex.Flow.RESOLUTION / 16,
  "32":   Vex.Flow.RESOLUTION / 32,
  "64":   Vex.Flow.RESOLUTION / 64,
  "128":  Vex.Flow.RESOLUTION / 128,
  "256":  Vex.Flow.RESOLUTION / 256
};

Vex.Flow.durationAliases = {
  "w": "1",
  "h": "2",
  "q": "4",

  // This is the default duration used to render bars (BarNote). Bars no longer
  // consume ticks, so this should be a no-op.
  //
  // TODO(0xfe): This needs to be cleaned up.
  "b": "256"
};

Vex.Flow.durationToGlyph = function(duration, type) {
  duration = Vex.Flow.sanitizeDuration(duration);

  var code = Vex.Flow.durationToGlyph.duration_codes[duration];
  if (code === undefined) {
    return null;
  }

  if (!type) {
    type = "n";
  }

  var glyphTypeProperties = code.type[type];
  if (glyphTypeProperties === undefined) {
    return null;
  }

  return Vex.Merge(Vex.Merge({}, code.common), glyphTypeProperties);
};

Vex.Flow.durationToGlyph.duration_codes = {
  "1/2": {
    common: {
      head_width: 22,
      stem: false,
      stem_offset: 0,
      flag: false,
      stem_up_extension: -Vex.Flow.STEM_HEIGHT,
      stem_down_extension: -Vex.Flow.STEM_HEIGHT,
      gracenote_stem_up_extension: -Vex.Flow.STEM_HEIGHT,
      gracenote_stem_down_extension: -Vex.Flow.STEM_HEIGHT,
      tabnote_stem_up_extension: -Vex.Flow.STEM_HEIGHT,
      tabnote_stem_down_extension: -Vex.Flow.STEM_HEIGHT,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Breve note
        code_head: "v53"
      },
      "h": { // Breve note harmonic
        code_head: "v59"
      },
      "m": { // Breve note muted -
        code_head: "vf",
        stem_offset: 0
      },
      "r": { // Breve rest
        code_head: "v31",
        head_width: 24,
        rest: true,
        position: "B/5",
        dot_shiftY: 0.5
      },
      "s": { // Breve note slash -
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "1": {
    common: {
      head_width: 16,
      stem: false,
      stem_offset: 0,
      flag: false,
      stem_up_extension: -Vex.Flow.STEM_HEIGHT,
      stem_down_extension: -Vex.Flow.STEM_HEIGHT,
      gracenote_stem_up_extension: -Vex.Flow.STEM_HEIGHT,
      gracenote_stem_down_extension: -Vex.Flow.STEM_HEIGHT,
      tabnote_stem_up_extension: -Vex.Flow.STEM_HEIGHT,
      tabnote_stem_down_extension: -Vex.Flow.STEM_HEIGHT,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Whole note
        code_head: "v1d"
      },
      "h": { // Whole note harmonic
        code_head: "v46"
      },
      "m": { // Whole note muted
        code_head: "v92",
        stem_offset: -3
      },
      "r": { // Whole rest
        code_head: "v5c",
        head_width: 12,
        rest: true,
        position: "D/5",
        dot_shiftY: 0.5
      },
      "s": { // Whole note slash
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "2": {
    common: {
      head_width: 10,
      stem: true,
      stem_offset: 0,
      flag: false,
      stem_up_extension: 0,
      stem_down_extension: 0,
      gracenote_stem_up_extension: -14,
      gracenote_stem_down_extension: -14,
      tabnote_stem_up_extension: 0,
      tabnote_stem_down_extension: 0,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Half note
        code_head: "v81"
      },
      "h": { // Half note harmonic
        code_head: "v2d"
      },
      "m": { // Half note muted
        code_head: "v95",
        stem_offset: -3
      },
      "r": { // Half rest
        code_head: "vc",
        head_width: 12,
        stem: false,
        rest: true,
        position: "B/4",
        dot_shiftY: -0.5
      },
      "s": { // Half note slash
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "4": {
    common: {
      head_width: 10,
      stem: true,
      stem_offset: 0,
      flag: false,
      stem_up_extension: 0,
      stem_down_extension: 0,
      gracenote_stem_up_extension: -14,
      gracenote_stem_down_extension: -14,
      tabnote_stem_up_extension: 0,
      tabnote_stem_down_extension: 0,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Quarter note
        code_head: "vb"
      },
      "h": { // Quarter harmonic
        code_head: "v22"
      },
      "m": { // Quarter muted
        code_head: "v3e",
        stem_offset: -3
      },
      "r": { // Quarter rest
        code_head: "v7c",
        head_width: 8,
        stem: false,
        rest: true,
        position: "B/4",
        dot_shiftY: -0.5,
        line_above: 1.5,
        line_below: 1.5
      },
      "s": { // Quarter slash
         // Drawn with canvas primitives
         head_width: 15,
         position: "B/4"
      }
    }
  },
  "8": {
    common: {
      head_width: 10,
      stem: true,
      stem_offset: 0,
      flag: true,
      beam_count: 1,
      code_flag_upstem: "v54",
      code_flag_downstem: "v9a",
      stem_up_extension: 0,
      stem_down_extension: 0,
      gracenote_stem_up_extension: -14,
      gracenote_stem_down_extension: -14,
      tabnote_stem_up_extension: 0,
      tabnote_stem_down_extension: 0,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Eighth note
        code_head: "vb"
      },
      "h": { // Eighth note harmonic
        code_head: "v22"
      },
      "m": { // Eighth note muted
        code_head: "v3e"
      },
      "r": { // Eighth rest
        code_head: "va5",
        stem: false,
        flag: false,
        rest: true,
        position: "B/4",
        dot_shiftY: -0.5,
        line_above: 1.0,
        line_below: 1.0
      },
      "s": { // Eight slash
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "16": {
    common: {
      beam_count: 2,
      head_width: 10,
      stem: true,
      stem_offset: 0,
      flag: true,
      code_flag_upstem: "v3f",
      code_flag_downstem: "v8f",
      stem_up_extension: 4,
      stem_down_extension: 0,
      gracenote_stem_up_extension: -14,
      gracenote_stem_down_extension: -14,
      tabnote_stem_up_extension: 0,
      tabnote_stem_down_extension: 0,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Sixteenth note
        code_head: "vb"
      },
      "h": { // Sixteenth note harmonic
        code_head: "v22"
      },
      "m": { // Sixteenth note muted
        code_head: "v3e"
      },
      "r": { // Sixteenth rest
        code_head: "v3c",
        head_width: 13,
        stem: false,
        flag: false,
        rest: true,
        position: "B/4",
        dot_shiftY: -0.5,
        line_above: 1.0,
        line_below: 2.0
      },
      "s": { // Sixteenth slash
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "32": {
    common: {
      beam_count: 3,
      head_width: 10,
      stem: true,
      stem_offset: 0,
      flag: true,
      code_flag_upstem: "v47",
      code_flag_downstem: "v2a",
      stem_up_extension: 13,
      stem_down_extension: 9,
      gracenote_stem_up_extension: -12,
      gracenote_stem_down_extension: -12,
      tabnote_stem_up_extension: 9,
      tabnote_stem_down_extension: 5,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Thirty-second note
        code_head: "vb"
      },
      "h": { // Thirty-second harmonic
        code_head: "v22"
      },
      "m": { // Thirty-second muted
        code_head: "v3e"
      },
      "r": { // Thirty-second rest
        code_head: "v55",
        head_width: 16,
        stem: false,
        flag: false,
        rest: true,
        position: "B/4",
        dot_shiftY: -1.5,
        line_above: 2.0,
        line_below: 2.0
      },
      "s": { // Thirty-second slash
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "64": {
    common: {
      beam_count: 4,
      head_width: 10,
      stem: true,
      stem_offset: 0,
      flag: true,
      code_flag_upstem: "va9",
      code_flag_downstem: "v58",
      stem_up_extension: 17,
      stem_down_extension: 13,
      gracenote_stem_up_extension: -10,
      gracenote_stem_down_extension: -10,
      tabnote_stem_up_extension: 13,
      tabnote_stem_down_extension: 9,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Sixty-fourth note
        code_head: "vb"
      },
      "h": { // Sixty-fourth harmonic
        code_head: "v22"
      },
      "m": { // Sixty-fourth muted
        code_head: "v3e"
      },
      "r": { // Sixty-fourth rest
        code_head: "v38",
        head_width: 18,
        stem: false,
        flag: false,
        rest: true,
        position: "B/4",
        dot_shiftY: -1.5,
        line_above: 2.0,
        line_below: 3.0
      },
      "s": { // Sixty-fourth slash
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "128": {
      common: {
          beam_count: 5,
          head_width: 10,
          stem: true,
          stem_offset:0,
          flag: true,
          code_flag_upstem: "v9b",
          code_flag_downstem: "v30",
          stem_up_extension: 26,
          stem_down_extension: 22,
          gracenote_stem_up_extension: -8,
          gracenote_stem_down_extension: -8,
          tabnote_stem_up_extension: 22,
          tabnote_stem_down_extension: 18,
          dot_shiftY: 0,
          line_above: 0,
          line_below: 0
      },
      type: {
          "n": {  // Hundred-twenty-eight note
              code_head: "vb"
          },
          "h": { // Hundred-twenty-eight harmonic
              code_head: "v22"
          },
          "m": { // Hundred-twenty-eight muted
              code_head: "v3e"
          },
          "r": {  // Hundred-twenty-eight rest
              code_head: "vaa",
              head_width: 20,
              stem: false,
              flag: false,
              rest: true,
              position: "B/4",
              dot_shiftY: 1.5,
              line_above: 3.0,
              line_below: 3.0
          },
          "s": { // Hundred-twenty-eight rest
              // Drawn with canvas primitives
              head_width: 15,
              position: "B/4"
          }
      }
  }
};

// Some defaults
Vex.Flow.TIME4_4 = {
  num_beats: 4,
  beat_value: 4,
  resolution: Vex.Flow.RESOLUTION
};

Vex.Flow.Font = {"glyphs":{"v0":{"x_min":0,"x_max":514.5,"ha":525,"o":"m 236 648 b 246 648 238 648 242 648 b 288 646 261 648 283 648 b 472 513 364 634 428 587 b 514 347 502 464 514 413 b 462 163 514 272 499 217 b 257 44 409 83 333 44 b 50 163 181 44 103 83 b 0 347 14 217 0 272 b 40 513 0 413 12 464 b 236 648 87 591 155 638 m 277 614 b 253 616 273 616 261 616 b 242 616 247 616 243 616 b 170 499 193 609 181 589 b 159 348 163 446 159 398 b 166 222 159 308 161 266 b 201 91 174 138 183 106 b 257 76 215 81 235 76 b 311 91 277 76 299 81 b 347 222 330 106 338 138 b 353 348 352 266 353 308 b 344 499 353 398 351 446 b 277 614 333 587 322 606 m 257 -1 l 258 -1 l 255 -1 l 257 -1 m 257 673 l 258 673 l 255 673 l 257 673 "},"v1":{"x_min":-1.359375,"x_max":344.359375,"ha":351,"o":"m 126 637 l 129 638 l 198 638 l 266 638 l 269 635 b 274 631 272 634 273 632 l 277 627 l 277 395 b 279 156 277 230 277 161 b 329 88 281 123 295 106 b 344 69 341 81 344 79 b 337 55 344 62 343 59 l 333 54 l 197 54 l 61 54 l 58 55 b 50 69 53 59 50 62 b 65 88 50 79 53 81 b 80 97 72 91 74 93 b 117 156 103 113 112 129 b 117 345 117 161 117 222 l 117 528 l 100 503 l 38 406 b 14 383 24 384 23 383 b -1 398 5 383 -1 390 b 4 415 -1 403 1 409 b 16 437 5 416 10 426 l 72 539 l 100 596 b 121 632 119 631 119 631 b 126 637 122 634 125 635 m 171 -1 l 172 -1 l 170 -1 l 171 -1 m 171 673 l 172 673 l 170 673 l 171 673 "},"v2":{"x_min":-1.359375,"x_max":458.6875,"ha":468,"o":"m 197 648 b 216 648 201 648 208 648 b 258 646 232 648 253 648 b 419 546 333 637 393 599 b 432 489 428 528 432 509 b 356 342 432 440 405 384 b 235 278 322 313 288 295 b 69 170 166 256 107 217 b 69 169 69 170 69 169 b 69 169 69 169 69 169 b 74 173 69 169 72 170 b 209 222 112 204 163 222 b 310 195 247 222 274 215 b 371 179 332 184 352 179 b 396 181 379 179 387 179 b 428 202 409 184 423 194 b 442 212 431 209 436 212 b 458 197 450 212 458 206 b 441 148 458 190 449 165 b 299 44 409 84 353 44 b 288 45 295 44 292 44 b 250 61 274 45 268 49 b 122 99 212 86 164 99 b 73 91 104 99 88 97 b 28 63 53 84 34 72 b 14 54 25 56 20 54 b 1 62 9 54 4 56 l -1 65 l -1 79 b 0 99 -1 91 0 95 b 2 113 1 102 2 108 b 164 309 20 197 81 272 b 285 470 232 341 277 398 b 287 487 287 476 287 481 b 171 595 287 551 239 595 b 155 595 166 595 160 595 b 142 592 145 594 142 594 b 145 589 142 592 142 591 b 179 527 168 576 179 551 b 132 455 179 496 163 467 b 104 451 122 452 112 451 b 27 530 62 451 27 487 b 29 555 27 538 27 546 b 197 648 44 601 115 639 m 228 -1 l 230 -1 l 227 -1 l 228 -1 m 228 673 l 230 673 l 227 673 l 228 673 "},"v3":{"x_min":-1.359375,"x_max":409.6875,"ha":418,"o":"m 174 648 b 191 648 176 648 183 648 b 225 648 204 648 220 648 b 402 523 317 638 389 588 b 404 503 404 517 404 510 b 402 484 404 495 404 488 b 264 373 389 437 334 394 b 257 370 259 371 257 371 b 257 370 257 370 257 370 b 264 369 258 370 261 369 b 409 202 359 334 409 267 b 318 72 409 152 381 104 b 200 43 281 52 240 43 b 23 113 134 43 69 68 b 0 169 6 129 0 149 b 77 249 0 210 29 249 l 77 249 b 152 174 125 249 152 212 b 103 102 152 145 137 116 b 103 102 103 102 103 102 b 147 94 103 101 132 95 b 153 94 149 94 151 94 b 265 206 219 94 265 141 b 264 226 265 213 265 219 b 147 355 253 299 204 353 b 126 371 133 356 126 362 b 147 388 126 383 132 388 b 254 474 196 391 238 424 b 259 502 258 484 259 494 b 182 592 259 544 228 582 b 156 595 175 595 166 595 b 115 592 142 595 129 594 l 111 591 l 115 588 b 152 524 141 574 152 549 b 92 449 152 491 130 458 b 76 448 87 448 81 448 b -1 530 32 448 -1 488 b 20 581 -1 548 5 566 b 174 648 55 619 108 641 m 204 -1 l 205 -1 l 202 -1 l 204 -1 m 204 673 l 205 673 l 202 673 l 204 673 "},"v4":{"x_min":0,"x_max":468.21875,"ha":478,"o":"m 174 637 b 232 638 175 638 189 638 b 277 638 245 638 259 638 l 378 638 l 381 635 b 389 623 386 632 389 627 b 382 609 389 617 386 613 b 366 589 381 606 372 598 l 313 528 l 245 451 l 209 410 l 155 348 l 84 267 b 59 240 72 252 59 240 b 59 240 59 240 59 240 b 151 238 59 238 68 238 l 242 238 l 242 303 b 243 371 242 369 242 370 b 289 426 245 374 254 385 l 303 441 l 317 456 l 338 483 l 360 506 l 371 520 b 386 527 375 526 381 527 b 400 519 392 527 397 524 b 401 440 401 516 401 514 b 401 377 401 423 401 402 l 401 238 l 426 238 b 453 237 449 238 450 238 b 465 217 461 234 465 226 b 460 202 465 212 464 206 b 426 197 454 197 453 197 l 401 197 l 401 180 b 451 88 402 129 412 109 b 468 69 465 81 468 79 b 461 55 468 62 466 59 l 458 54 l 321 54 l 185 54 l 182 55 b 175 69 176 59 175 62 b 191 88 175 79 176 81 b 240 180 230 109 240 129 l 240 197 l 125 197 b 73 195 104 195 87 195 b 8 197 10 195 9 197 b 0 212 2 199 0 205 b 0 212 0 212 0 212 b 20 242 0 219 0 219 b 163 610 104 344 163 492 b 174 637 163 628 166 634 m 234 -1 l 235 -1 l 232 -1 l 234 -1 m 234 673 l 235 673 l 232 673 l 234 673 "},"v5":{"x_min":0,"x_max":409.6875,"ha":418,"o":"m 47 637 b 53 638 49 638 50 638 b 69 634 55 638 61 637 b 210 610 114 619 161 610 b 363 634 259 610 311 619 b 382 638 372 637 378 638 b 392 634 386 638 389 637 b 397 623 396 630 397 627 b 393 610 397 620 396 616 b 298 505 368 552 338 520 b 212 494 277 498 246 494 b 65 517 163 494 106 502 b 61 517 62 517 61 517 b 61 517 61 517 61 517 b 51 408 61 517 51 412 b 51 408 51 408 51 408 b 51 408 51 408 51 408 b 61 412 53 408 55 409 b 125 434 80 421 103 430 b 185 441 145 440 166 441 b 409 244 310 441 409 353 b 401 191 409 227 406 209 b 197 43 375 105 287 43 b 159 47 183 43 171 44 b 23 123 112 56 61 86 b 0 180 6 140 0 159 b 76 260 0 220 31 260 b 92 259 81 260 87 259 b 152 183 132 251 152 216 b 100 112 152 152 134 122 b 95 111 98 112 95 111 b 95 111 95 111 95 111 b 129 98 95 109 119 101 b 148 97 136 97 141 97 b 264 235 206 97 261 158 b 265 248 265 240 265 244 b 210 398 265 312 243 373 b 179 408 201 406 194 408 b 174 408 178 408 176 408 b 53 369 130 408 88 394 b 34 359 39 359 38 359 b 17 374 24 359 17 365 b 39 628 17 384 38 625 b 47 637 40 631 43 635 m 204 -1 l 205 -1 l 202 -1 l 204 -1 m 204 673 l 205 673 l 202 673 l 204 673 "},"v6":{"x_min":0,"x_max":475.03125,"ha":485,"o":"m 255 648 b 274 648 259 648 266 648 b 314 646 288 648 307 648 b 450 555 374 637 438 594 b 454 530 453 546 454 538 b 375 451 454 485 416 451 b 328 467 359 451 343 455 b 300 526 310 483 300 503 b 352 598 300 557 319 589 b 356 599 355 598 356 599 b 352 602 356 599 355 601 b 288 616 330 612 308 616 b 210 584 257 616 230 605 b 164 433 189 559 174 508 b 160 374 163 415 160 381 b 160 374 160 374 160 374 b 160 374 160 374 160 374 b 168 377 160 374 164 376 b 258 395 200 390 228 395 b 366 367 294 395 328 387 b 475 223 436 333 475 283 b 472 197 475 215 473 206 b 349 65 462 141 419 95 b 259 43 317 51 288 43 b 167 69 230 43 200 52 b 4 290 80 113 20 195 b 0 349 1 309 0 328 b 20 467 0 391 6 433 b 255 648 58 563 155 637 m 269 363 b 257 363 265 363 261 363 b 210 345 236 363 220 356 b 186 226 196 324 186 272 b 187 198 186 216 186 206 b 213 95 191 151 202 112 b 257 76 221 83 238 76 b 270 77 261 76 266 76 b 321 156 299 81 310 99 b 329 229 326 183 329 206 b 321 301 329 252 326 274 b 269 363 311 342 298 359 m 236 -1 l 238 -1 l 235 -1 l 236 -1 m 236 673 l 238 673 l 235 673 l 236 673 "},"v7":{"x_min":0,"x_max":442.359375,"ha":451,"o":"m 147 648 b 166 649 153 649 160 649 b 313 598 217 649 273 630 b 340 587 323 588 328 587 l 341 587 b 412 628 367 587 390 601 b 427 638 416 635 421 638 b 439 632 431 638 435 637 b 442 623 441 630 442 628 b 430 569 442 616 439 603 b 352 369 408 492 377 410 b 300 259 325 324 313 298 b 273 84 283 205 273 140 b 265 55 273 65 272 59 l 261 54 l 181 54 l 99 54 l 96 55 b 91 61 95 56 92 59 l 89 63 l 89 77 b 147 263 89 133 111 202 b 261 401 176 313 212 355 b 378 541 315 449 349 489 l 382 548 l 375 544 b 240 495 333 512 285 495 b 129 535 198 495 160 509 b 84 560 108 552 95 560 b 76 559 81 560 78 560 b 31 487 59 555 43 530 b 14 470 27 473 24 470 b 1 477 8 470 4 471 l 0 480 l 0 553 l 0 627 l 1 630 b 16 638 4 635 9 638 b 23 635 17 638 20 637 b 49 626 36 626 39 626 b 96 638 59 626 80 630 b 104 639 99 638 102 639 b 117 644 107 641 112 642 b 147 648 125 645 137 648 m 220 -1 l 221 -1 l 219 -1 l 220 -1 m 220 673 l 221 673 l 219 673 l 220 673 "},"v8":{"x_min":0,"x_max":488.640625,"ha":499,"o":"m 217 648 b 245 649 225 648 235 649 b 453 516 343 649 430 595 b 458 478 455 503 458 491 b 412 370 458 440 441 398 b 411 369 412 369 411 369 b 415 365 411 367 412 367 b 488 231 462 331 488 281 b 472 165 488 208 483 186 b 243 43 434 86 338 43 b 63 104 178 43 112 62 b 0 233 20 140 0 186 b 73 365 0 283 24 331 l 77 369 l 72 374 b 29 476 42 406 29 441 b 217 648 29 557 103 635 m 258 605 b 242 606 253 605 247 606 b 157 552 198 606 157 580 b 160 541 157 548 159 544 b 319 413 176 503 242 452 l 337 403 l 338 406 b 359 476 352 428 359 452 b 258 605 359 537 318 595 m 138 326 b 130 330 134 328 130 330 b 130 330 130 330 130 330 b 107 305 127 330 112 313 b 84 231 91 281 84 256 b 243 86 84 156 151 86 b 249 87 245 86 246 87 b 347 156 303 88 347 120 b 344 172 347 162 345 167 b 156 319 325 227 257 281 b 138 326 151 322 144 324 m 243 -1 l 245 -1 l 242 -1 l 243 -1 m 243 673 l 245 673 l 242 673 l 243 673 "},"v9":{"x_min":0,"x_max":475.03125,"ha":485,"o":"m 191 646 b 212 649 198 648 205 649 b 255 644 227 649 243 646 b 458 448 348 616 428 539 b 475 342 469 415 475 378 b 460 244 475 308 469 274 b 193 44 421 124 303 44 b 91 69 157 44 122 51 b 19 161 43 97 19 126 b 21 181 19 167 20 174 b 98 241 32 220 65 241 b 170 186 129 241 160 223 b 172 166 171 179 172 173 b 121 94 172 134 152 102 b 117 93 118 94 117 93 b 121 90 117 93 118 91 b 185 76 142 80 164 76 b 270 119 220 76 251 91 b 308 259 287 145 300 194 b 313 317 310 277 313 310 b 313 317 313 317 313 317 b 313 317 313 317 313 317 b 304 315 313 317 308 316 b 216 295 273 302 245 295 b 145 308 193 295 170 299 b 19 398 88 327 42 360 b 0 469 5 420 0 444 b 24 551 0 496 8 526 b 191 646 54 596 125 637 m 227 614 b 215 616 224 616 220 616 b 202 614 210 616 206 616 b 152 535 174 610 163 592 b 144 463 147 509 144 485 b 152 391 144 440 147 417 b 216 328 163 344 179 328 b 280 391 253 328 269 344 b 288 463 285 417 288 440 b 280 535 288 485 285 509 b 227 614 269 594 258 610 m 236 -1 l 238 -1 l 235 -1 l 236 -1 m 236 673 l 238 673 l 235 673 l 236 673 "},"va":{"x_min":-149.71875,"x_max":148.359375,"ha":151,"o":"m -8 -1 b -1 0 -5 -1 -4 0 b 16 -11 5 0 13 -4 b 83 -186 17 -12 47 -90 l 148 -358 l 148 -363 b 127 -385 148 -376 138 -385 b 112 -378 122 -385 118 -383 b 54 -226 110 -374 114 -385 b 0 -81 24 -147 0 -81 b -55 -226 -1 -81 -25 -147 b -114 -378 -115 -385 -111 -374 b -129 -385 -119 -383 -123 -385 b -149 -363 -140 -385 -149 -376 l -149 -358 l -84 -186 b -19 -11 -49 -90 -19 -12 b -8 -1 -17 -8 -12 -4 "},"vb":{"x_min":0,"x_max":428.75,"ha":438,"o":"m 262 186 b 273 186 266 186 272 186 b 274 186 273 186 274 186 b 285 186 274 186 280 186 b 428 48 375 181 428 122 b 386 -68 428 12 416 -29 b 155 -187 329 -145 236 -187 b 12 -111 92 -187 38 -162 b 0 -51 4 -91 0 -72 b 262 186 0 58 122 179 "},"vc":{"x_min":0,"x_max":447.8125,"ha":457,"o":"m 0 86 l 0 173 l 223 173 l 447 173 l 447 86 l 447 0 l 223 0 l 0 0 l 0 86 "},"vf":{"x_min":0,"x_max":370.21875,"ha":378,"o":"m 0 0 l 0 277 l 61 277 l 122 277 l 122 0 l 122 -278 l 61 -278 l 0 -278 l 0 0 m 246 -1 l 246 277 l 308 277 l 370 277 l 370 -1 l 370 -278 l 308 -278 l 246 -278 l 246 -1 "},"v10":{"x_min":0,"x_max":559.421875,"ha":571,"o":"m 5 127 b 14 127 6 127 9 127 b 51 126 25 127 43 127 b 175 98 93 122 138 112 l 186 94 b 279 51 210 86 255 65 b 285 47 280 51 283 48 b 319 27 291 44 311 31 l 326 22 b 359 0 332 19 352 4 l 367 -6 b 371 -9 368 -6 370 -8 l 379 -15 b 387 -22 383 -18 386 -20 l 398 -30 l 411 -40 l 417 -47 l 427 -55 l 434 -61 b 441 -66 436 -62 439 -65 l 446 -72 l 453 -77 l 462 -87 b 558 -188 490 -113 549 -176 b 559 -195 559 -191 559 -194 b 548 -205 559 -201 555 -205 b 541 -204 547 -205 544 -205 b 534 -198 539 -201 536 -199 l 525 -191 b 481 -162 518 -187 490 -167 b 472 -155 477 -159 472 -156 b 468 -152 470 -155 469 -154 b 461 -149 466 -152 464 -151 b 428 -130 454 -145 441 -137 b 371 -99 413 -122 372 -99 b 363 -95 371 -99 367 -98 b 353 -91 357 -94 353 -91 b 348 -90 353 -91 352 -91 b 332 -81 343 -87 341 -86 b 27 -12 230 -37 127 -13 b 0 -5 4 -11 2 -11 b 0 58 0 -2 0 27 b 0 122 0 88 0 120 b 5 127 1 124 4 126 "},"v11":{"x_min":-155.171875,"x_max":153.8125,"ha":157,"o":"m -137 353 b -130 353 -136 353 -133 353 b -112 349 -125 353 -119 352 b -100 342 -110 347 -104 344 b 0 317 -69 326 -35 317 b 111 349 38 317 76 328 b 129 353 117 352 123 353 b 153 327 142 353 153 344 b 144 302 153 320 153 317 b 27 6 93 226 50 113 b 21 -13 24 -11 24 -11 b 0 -26 17 -22 8 -26 b -24 -12 -9 -26 -19 -22 b -28 5 -24 -9 -27 -2 b -145 302 -53 117 -95 224 b -155 327 -155 317 -155 320 b -137 353 -155 340 -148 349 "},"v18":{"x_min":0,"x_max":323.9375,"ha":331,"o":"m 217 535 b 225 537 220 537 221 537 b 245 524 235 537 242 533 l 246 521 l 247 390 l 247 258 l 273 265 b 306 270 288 269 299 270 b 322 259 315 270 319 267 b 323 208 323 256 323 233 b 322 158 323 184 323 159 b 288 140 318 148 315 147 b 247 130 254 131 247 130 b 247 65 247 130 247 104 b 247 20 247 51 247 36 l 247 -88 l 273 -81 b 306 -76 289 -77 299 -76 b 318 -81 311 -76 315 -77 b 323 -123 323 -87 323 -86 l 323 -138 l 323 -154 b 318 -195 323 -191 323 -190 b 269 -210 314 -199 315 -199 b 249 -216 259 -213 250 -216 l 247 -216 l 247 -349 l 246 -483 l 245 -487 b 225 -499 242 -495 234 -499 b 206 -487 219 -499 210 -495 l 205 -483 l 205 -355 l 205 -227 l 204 -227 l 181 -233 l 138 -244 b 117 -249 127 -247 117 -249 b 115 -385 115 -249 115 -256 l 115 -523 l 114 -526 b 95 -538 110 -534 102 -538 b 74 -526 87 -538 78 -534 l 73 -523 l 73 -391 b 72 -260 73 -269 73 -260 b 72 -260 72 -260 72 -260 b 19 -273 61 -263 23 -273 b 0 -260 10 -273 4 -267 b 0 -209 0 -256 0 -256 l 0 -162 l 1 -158 b 61 -134 5 -148 5 -148 l 73 -131 l 73 -22 b 72 86 73 79 73 86 b 72 86 72 86 72 86 b 19 74 61 83 23 74 b 0 86 10 74 4 79 b 0 137 0 90 0 90 l 0 184 l 1 188 b 61 212 5 198 5 198 l 73 215 l 73 348 l 73 481 l 74 485 b 95 498 78 492 87 498 b 103 495 98 498 100 496 b 114 485 107 494 111 489 l 115 481 l 115 353 l 115 226 l 121 226 b 159 235 123 227 141 231 l 198 247 l 205 248 l 205 384 l 205 521 l 206 524 b 217 535 209 528 212 533 m 205 9 b 205 119 205 70 205 119 l 205 119 b 182 113 204 119 194 116 l 138 102 b 117 97 127 99 117 97 b 115 -12 115 97 115 91 l 115 -122 l 121 -120 b 159 -111 123 -119 141 -115 l 198 -101 l 205 -98 l 205 9 "},"v1b":{"x_min":0,"x_max":559.421875,"ha":571,"o":"m 544 204 b 548 204 545 204 547 204 b 559 194 555 204 559 199 b 559 190 559 192 559 191 b 530 156 559 188 556 184 b 462 86 510 134 481 104 b 453 76 458 81 454 77 l 446 70 l 441 65 b 434 59 439 63 436 61 l 427 54 b 409 37 426 51 416 44 b 392 23 398 29 394 26 b 387 19 389 22 387 20 b 379 13 386 19 383 16 l 371 8 l 367 5 l 359 -1 l 337 -16 b 285 -48 319 -29 298 -41 l 279 -52 b 186 -95 255 -66 210 -87 l 175 -99 b 23 -129 127 -117 68 -129 b 17 -129 20 -129 19 -129 b 1 -123 2 -129 2 -129 b 0 -49 0 -122 0 -83 b 0 4 0 -22 0 1 b 27 11 2 9 4 9 b 185 31 78 12 145 20 b 198 34 186 31 193 33 b 314 73 234 44 277 58 b 349 88 328 79 340 84 b 353 90 352 90 353 90 b 363 94 353 90 357 93 b 371 98 367 97 371 98 b 428 129 372 98 413 120 b 461 148 441 136 454 144 b 468 151 464 149 466 151 b 472 154 469 152 470 154 b 481 161 473 155 477 158 b 525 190 490 166 518 186 l 534 197 b 540 201 536 198 539 199 b 544 204 541 202 544 204 "},"v1d":{"x_min":0,"x_max":619.3125,"ha":632,"o":"m 274 184 b 307 186 285 186 296 186 b 616 22 465 186 597 116 b 619 -1 617 13 619 5 b 308 -187 619 -104 483 -187 b 0 -1 133 -187 0 -102 b 5 36 0 11 1 23 b 274 184 29 115 141 176 m 289 161 b 272 162 284 162 277 162 b 171 41 209 162 171 108 b 205 -73 171 5 182 -34 b 345 -163 243 -133 298 -163 b 436 -98 385 -163 420 -142 b 446 -43 443 -80 446 -62 b 289 161 446 47 377 147 "},"v1e":{"x_min":-402.890625,"x_max":401.53125,"ha":410,"o":"m -219 173 b -213 174 -217 174 -215 174 b -202 173 -209 174 -205 173 b -114 86 -200 172 -179 151 b -28 0 -66 37 -28 0 b 40 84 -28 0 2 37 b 117 174 111 173 110 172 b 122 174 118 174 119 174 b 132 173 125 174 129 173 b 295 11 134 172 171 134 l 307 -1 l 336 34 b 374 76 366 72 368 74 b 381 77 375 77 378 77 b 401 56 392 77 401 68 b 400 48 401 54 401 51 b 223 -172 397 41 230 -166 b 210 -176 220 -174 215 -176 b 201 -174 206 -176 204 -176 b 112 -87 198 -173 178 -152 b 27 0 65 -38 27 0 b -42 -86 27 0 -4 -38 b -118 -174 -112 -174 -111 -173 b -123 -176 -119 -176 -121 -176 b -133 -174 -126 -176 -130 -174 b -296 -12 -136 -173 -172 -137 l -308 0 l -337 -34 b -375 -77 -367 -73 -370 -76 b -382 -79 -377 -79 -379 -79 b -402 -58 -393 -79 -402 -69 b -401 -49 -402 -55 -402 -52 b -224 172 -398 -43 -228 167 b -219 173 -223 172 -220 173 "},"v1f":{"x_min":-340.28125,"x_max":338.921875,"ha":346,"o":"m -32 520 b -29 521 -31 520 -31 521 b -23 519 -27 521 -24 520 b -20 513 -21 517 -20 516 b -21 506 -20 512 -20 509 b -31 474 -23 502 -27 488 l -53 402 l -66 352 l -68 349 l -57 349 b -32 351 -51 349 -40 351 b 123 370 19 352 74 359 b 137 371 127 370 133 371 b 170 356 152 371 164 366 b 171 355 170 355 170 355 b 216 366 174 355 183 358 b 280 378 268 377 266 377 b 287 378 283 378 284 378 b 332 349 307 378 322 369 b 338 319 336 341 338 330 b 332 301 338 310 336 302 b 242 280 329 299 246 280 b 242 280 242 280 242 280 b 235 288 236 280 235 283 b 235 292 235 290 235 291 b 236 302 236 297 236 299 b 220 337 236 316 230 330 l 216 340 l 210 335 b 159 276 189 322 172 301 b 118 149 152 265 156 274 b 81 34 84 36 85 36 b -8 13 78 33 -4 13 b -8 13 -8 13 -8 13 b -14 20 -12 15 -14 15 b -8 44 -14 24 -12 31 b -2 66 -5 55 -2 65 b -2 66 -2 66 -2 66 l -2 66 b -43 41 -2 66 -21 55 b -114 4 -98 8 -98 8 b -144 0 -123 0 -134 0 b -242 99 -197 0 -242 43 b -242 109 -242 102 -242 105 b -212 219 -240 122 -242 116 b -185 312 -197 270 -185 312 l -185 312 b -189 312 -185 312 -186 312 b -259 312 -200 312 -227 312 b -321 310 -291 312 -310 310 b -334 312 -330 310 -334 312 b -340 319 -338 313 -340 316 b -336 326 -340 322 -338 324 b -291 337 -334 326 -314 331 l -247 347 l -210 348 b -172 348 -190 348 -172 348 b -168 363 -172 348 -171 355 b -145 442 -151 424 -145 441 b -133 452 -144 444 -140 446 l -77 489 b -32 520 -53 506 -32 520 m 57 334 b 53 335 55 335 54 335 b 44 334 50 335 49 335 b -70 316 8 326 -28 320 b -78 309 -78 316 -78 316 b -108 202 -80 305 -88 274 b -141 81 -136 112 -141 93 b -140 74 -141 79 -141 77 b -117 49 -137 59 -127 49 b -107 52 -114 49 -110 51 b 16 127 -106 54 14 126 b 42 217 16 127 42 215 b 49 241 42 222 44 229 b 73 320 53 251 73 317 b 57 334 73 327 65 333 "},"v20":{"x_min":-571.671875,"x_max":570.3125,"ha":582,"o":"m -559 351 b -551 352 -556 352 -553 352 b -530 338 -543 352 -533 348 b -529 169 -530 337 -529 291 l -529 1 l -507 27 l -441 112 b -382 174 -394 169 -390 174 b -378 174 -381 174 -379 174 b -281 86 -370 174 -375 179 b -196 0 -234 37 -196 0 b -126 84 -196 0 -164 37 b -50 174 -55 173 -57 172 b -44 174 -49 174 -47 174 b -35 173 -42 174 -38 173 b 53 86 -32 172 -12 151 b 138 0 100 37 138 0 b 208 84 140 0 170 37 b 284 174 279 173 279 172 b 289 174 285 174 288 174 b 300 173 294 174 298 173 b 462 11 303 172 340 134 l 475 -1 l 503 34 b 541 76 534 72 536 74 b 548 77 544 77 545 77 b 570 56 560 77 570 68 b 567 48 570 54 568 51 b 392 -172 564 41 397 -166 b 378 -176 387 -174 382 -176 b 368 -174 375 -176 371 -176 b 280 -87 367 -173 347 -152 b 194 0 234 -38 194 0 b 126 -86 194 0 163 -38 b 49 -174 54 -174 55 -173 b 44 -176 47 -176 46 -176 b 34 -174 40 -176 36 -174 b -54 -87 31 -173 10 -152 b -140 0 -102 -38 -140 0 b -209 -86 -140 0 -171 -38 b -285 -174 -280 -174 -279 -173 b -291 -176 -287 -176 -288 -176 b -300 -174 -294 -176 -298 -174 b -464 -11 -303 -173 -374 -102 l -476 0 l -506 -37 b -539 -76 -528 -65 -537 -74 b -551 -80 -543 -79 -547 -80 b -570 -68 -558 -80 -566 -76 l -571 -65 l -571 136 b -570 340 -571 331 -571 337 b -559 351 -568 344 -564 348 "},"v22":{"x_min":0,"x_max":432.828125,"ha":442,"o":"m 209 186 b 213 187 210 187 212 187 b 216 187 215 187 216 187 b 224 174 216 186 220 180 b 420 -1 269 105 338 43 b 432 -12 431 -8 432 -9 b 421 -23 432 -15 432 -16 b 228 -180 345 -70 264 -137 b 219 -188 221 -188 221 -188 l 219 -188 b 208 -177 215 -188 215 -188 b 10 1 163 -106 93 -44 b 0 11 0 6 0 8 b 10 22 0 13 0 15 b 202 179 87 69 167 136 b 209 186 206 183 209 186 "},"v23":{"x_min":0,"x_max":133.390625,"ha":136,"o":"m 54 66 b 65 68 58 68 61 68 b 122 37 88 68 110 56 b 133 -1 130 26 133 12 b 104 -58 133 -23 123 -44 b 66 -69 92 -65 78 -69 b 10 -38 44 -69 23 -58 b 0 -1 2 -27 0 -13 b 54 66 0 30 20 61 "},"v25":{"x_min":0,"x_max":318.5,"ha":325,"o":"m 20 376 b 167 377 23 377 96 377 b 296 376 231 377 294 377 b 318 347 311 371 318 359 b 296 316 318 333 311 320 b 159 315 294 315 227 315 b 21 316 91 315 24 315 b 0 345 6 320 0 333 b 20 376 0 359 6 371 "},"v26":{"x_min":-21.78125,"x_max":483.1875,"ha":493,"o":"m -8 631 b -1 632 -6 632 -4 632 b 19 620 8 632 16 628 b 20 383 20 616 20 616 l 20 148 l 21 151 b 140 199 59 183 102 199 b 206 179 164 199 187 192 l 210 176 l 210 396 l 210 617 l 212 621 b 231 632 216 628 223 632 b 250 620 239 632 247 628 b 251 383 251 616 251 616 l 251 148 l 254 151 b 370 199 291 183 332 199 b 415 191 385 199 400 197 b 483 84 458 176 483 134 b 461 0 483 58 476 29 b 332 -142 439 -40 411 -72 l 255 -215 b 231 -229 240 -229 239 -229 b 216 -223 224 -229 220 -227 b 210 -158 210 -217 210 -223 b 210 -120 210 -148 210 -136 l 210 -29 l 205 -34 b 100 -142 182 -65 159 -88 l 23 -215 b -1 -229 9 -229 6 -229 b -20 -216 -9 -229 -17 -224 l -21 -212 l -21 201 l -21 616 l -20 620 b -8 631 -17 624 -13 630 m 110 131 b 96 133 106 133 100 133 b 89 133 93 133 91 133 b 24 87 63 129 40 113 l 20 80 l 20 -37 l 20 -156 l 23 -152 b 144 81 96 -72 144 20 l 144 83 b 110 131 144 113 134 126 m 341 131 b 328 133 337 133 332 133 b 322 133 326 133 323 133 b 257 87 296 129 273 113 l 251 80 l 251 -37 l 251 -156 l 255 -152 b 375 81 328 -72 375 20 l 375 83 b 341 131 375 113 367 126 "},"v27":{"x_min":0,"x_max":432.828125,"ha":442,"o":"m 208 184 b 213 187 209 186 212 187 b 224 176 217 187 221 183 b 245 147 225 172 235 159 b 419 -1 288 90 347 38 b 431 -8 424 -4 431 -8 b 432 -12 432 -9 432 -11 b 430 -18 432 -13 432 -16 b 364 -61 424 -20 383 -47 b 225 -183 307 -102 250 -152 b 223 -187 224 -184 223 -187 b 220 -188 221 -188 220 -188 b 208 -176 216 -188 210 -184 b 187 -148 205 -173 197 -159 b 12 0 144 -90 84 -38 b 0 11 4 5 0 8 b 16 24 0 13 4 18 b 183 158 83 69 141 115 b 208 184 194 169 198 173 m 183 105 b 176 113 181 109 176 113 b 172 109 176 113 175 112 b 92 45 149 90 117 62 l 88 41 l 102 31 b 247 -105 160 -6 210 -55 l 254 -115 l 257 -112 l 269 -102 b 340 -45 287 -87 319 -61 l 344 -43 l 330 -33 b 183 105 272 6 221 54 "},"v28":{"x_min":-73.5,"x_max":72.140625,"ha":74,"o":"m -72 252 l -73 254 l 0 254 l 72 254 l 70 252 b 0 -1 70 248 0 -1 b -72 252 -1 -1 -72 248 "},"v29":{"x_min":-590.71875,"x_max":589.359375,"ha":601,"o":"m 175 273 b 182 274 178 273 181 274 b 202 262 190 274 198 269 b 204 158 204 259 204 259 l 204 56 l 250 112 b 303 174 296 172 298 172 b 308 174 304 174 307 174 b 318 173 313 174 317 173 b 481 11 322 172 357 134 l 494 -1 l 522 34 b 560 76 553 72 555 74 b 567 77 563 77 564 77 b 589 56 579 77 589 68 b 586 48 589 54 588 51 b 411 -172 583 41 416 -166 b 397 -176 406 -174 401 -176 b 387 -174 393 -176 390 -176 b 299 -87 386 -173 366 -152 b 213 0 253 -38 213 0 b 208 -6 213 0 210 -2 l 204 -12 l 204 -147 b 204 -210 204 -173 204 -194 b 198 -292 204 -297 204 -287 b 183 -299 194 -297 189 -299 b 164 -287 175 -299 167 -295 b 163 -174 163 -284 163 -284 l 161 -63 l 119 -117 b 65 -176 76 -170 73 -176 b 61 -176 63 -176 62 -176 b -35 -87 51 -174 57 -180 b -121 0 -83 -38 -121 0 b -190 -86 -122 0 -152 -38 b -266 -174 -261 -174 -259 -173 b -272 -176 -268 -176 -270 -176 b -281 -174 -276 -176 -280 -174 b -371 -86 -284 -173 -304 -152 b -457 0 -417 -38 -457 0 l -457 0 b -477 -26 -457 0 -470 -16 b -548 -227 -524 -88 -548 -161 b -536 -303 -548 -254 -544 -280 b -533 -317 -534 -309 -533 -313 b -553 -338 -533 -330 -541 -338 b -577 -315 -566 -338 -571 -333 b -590 -227 -586 -287 -590 -258 b -518 -9 -590 -154 -564 -77 b -465 56 -509 2 -504 8 l -402 134 b -363 174 -374 170 -371 174 b -359 174 -362 174 -360 174 b -262 86 -351 174 -356 179 b -176 0 -216 37 -176 0 b -107 84 -176 0 -145 37 b -31 174 -36 173 -38 172 b -25 174 -29 174 -28 174 b -16 173 -23 174 -19 173 b 147 11 -13 172 35 123 l 157 -1 l 160 1 l 163 4 l 163 130 b 164 260 163 256 163 258 b 175 273 166 266 170 270 "},"v2a":{"x_min":-21.78125,"x_max":366.140625,"ha":374,"o":"m 276 1378 b 284 1379 279 1379 281 1379 b 306 1360 292 1379 298 1374 b 352 1247 326 1326 343 1286 b 366 1139 362 1213 366 1175 b 347 1009 366 1093 359 1049 l 344 1002 l 347 992 b 352 971 348 986 351 977 b 366 863 362 936 366 899 b 347 732 366 818 359 773 l 344 725 l 347 716 b 352 695 348 710 351 700 b 366 588 362 659 366 623 b 223 262 366 464 314 345 b 189 233 212 252 212 252 b 35 76 126 183 73 129 b -1 16 20 56 2 27 b -19 4 -4 9 -12 4 l -21 4 l -21 137 l -21 270 l -17 270 b 186 344 59 281 134 308 b 319 606 270 399 319 499 b 317 650 319 620 319 635 l 315 659 l 314 655 b 223 537 288 607 258 570 b 189 509 212 528 212 528 b 35 352 126 459 73 405 b -1 292 20 333 2 303 b -19 280 -4 285 -12 280 l -21 280 l -21 413 l -21 546 l -17 546 b 186 620 59 557 134 584 b 319 882 270 675 319 775 b 317 925 319 896 319 911 l 315 935 l 314 931 b 223 813 288 884 258 846 b 189 785 212 805 212 805 b 35 628 126 735 73 681 b -1 569 20 609 2 580 b -19 556 -4 562 -12 556 l -21 556 l -21 689 l -21 823 l -17 823 b 202 907 68 835 152 867 b 319 1157 280 968 319 1061 b 270 1338 319 1218 303 1281 b 262 1358 264 1349 262 1353 b 262 1364 262 1360 262 1363 b 276 1378 265 1371 269 1376 "},"v2c":{"x_min":-597.53125,"x_max":596.171875,"ha":608,"o":"m -413 173 b -408 174 -412 174 -409 174 b -397 173 -404 174 -400 173 b -308 86 -394 172 -374 151 b -223 0 -261 37 -223 0 b -153 84 -223 0 -191 37 b -77 174 -83 173 -84 172 b -72 174 -76 174 -74 174 b -62 173 -68 174 -63 173 b 25 86 -59 172 -39 151 b 112 0 73 37 111 0 b 181 84 112 0 144 37 b 257 174 251 173 251 172 b 262 174 258 174 261 174 b 273 173 266 174 270 173 b 436 9 276 172 347 101 l 447 -1 l 477 36 b 522 79 511 79 513 79 l 522 79 b 552 51 533 79 539 73 b 596 -112 582 6 596 -51 b 567 -262 596 -161 586 -213 b 539 -322 558 -287 544 -316 b 524 -327 534 -326 529 -327 b 504 -315 515 -327 507 -323 b 503 -308 503 -312 503 -309 b 511 -285 503 -302 504 -297 b 555 -113 540 -227 555 -169 b 544 -34 555 -86 551 -59 b 522 19 540 -16 530 8 l 521 22 l 481 -26 l 405 -122 b 353 -176 366 -172 362 -176 b 349 -176 352 -176 351 -176 b 253 -87 341 -176 347 -180 b 167 0 206 -38 167 0 b 99 -86 167 0 136 -38 b 21 -174 27 -174 28 -173 b 17 -176 20 -176 19 -176 b 6 -174 13 -176 9 -174 b -81 -87 4 -173 -14 -152 b -167 0 -129 -38 -167 0 b -236 -86 -167 0 -198 -38 b -313 -174 -307 -174 -306 -173 b -318 -176 -314 -176 -315 -176 b -328 -174 -321 -176 -325 -174 b -491 -12 -330 -173 -367 -137 l -503 0 l -530 -34 b -570 -77 -562 -73 -564 -76 b -577 -79 -571 -79 -574 -79 b -597 -58 -588 -79 -597 -69 b -596 -49 -597 -55 -597 -52 b -417 172 -593 -43 -423 167 b -413 173 -417 172 -415 173 "},"v2d":{"x_min":0,"x_max":438.28125,"ha":447,"o":"m 212 190 b 219 191 213 191 216 191 b 236 176 225 191 228 190 b 419 18 277 105 341 49 b 436 5 431 13 434 11 b 438 -1 438 4 438 1 b 424 -16 438 -8 432 -13 b 356 -49 409 -20 379 -36 b 234 -180 306 -83 258 -133 b 219 -192 230 -188 224 -192 b 200 -176 213 -192 206 -187 b 9 -15 157 -102 89 -45 b 0 0 2 -12 0 -6 b 16 18 0 9 2 12 b 200 176 93 48 159 104 b 212 190 205 186 208 188 m 239 113 b 236 117 238 116 238 117 b 230 108 235 117 234 115 b 92 -15 196 58 140 8 b 88 -18 91 -16 88 -18 b 92 -20 88 -18 91 -19 b 198 -116 130 -43 166 -74 b 200 -117 200 -117 200 -117 b 201 -117 200 -117 201 -117 b 264 -43 212 -98 242 -62 b 345 15 288 -19 321 4 b 348 18 347 16 348 16 b 344 20 348 18 347 19 b 239 113 307 41 266 79 "},"v2f":{"x_min":-1.359375,"x_max":680.5625,"ha":694,"o":"m 597 1042 b 604 1042 600 1042 602 1042 b 642 1002 627 1042 642 1022 b 619 966 642 988 635 974 b 439 927 574 942 503 927 l 426 927 l 426 921 b 430 838 428 893 430 866 b 345 480 430 696 398 560 b 179 391 307 423 249 391 b 156 392 171 391 164 392 b 138 394 149 394 142 394 b 103 434 115 396 103 416 b 129 471 103 451 111 466 b 141 474 133 473 137 474 b 172 459 153 474 164 469 b 181 455 175 456 176 455 b 187 456 182 455 185 455 b 253 520 212 460 234 483 b 315 836 294 605 315 714 b 311 928 315 867 314 898 b 302 945 310 943 311 942 b 245 953 283 950 262 953 b 130 891 193 953 149 931 b 84 860 119 870 102 860 b 36 905 61 860 39 877 b 36 910 36 907 36 909 b 80 970 36 931 50 949 b 249 1017 125 1000 187 1017 b 322 1009 273 1017 299 1014 l 341 1003 b 436 991 372 995 406 991 b 577 1031 495 991 545 1004 b 597 1042 583 1038 590 1041 m 416 360 b 424 360 419 360 421 360 b 481 309 454 360 479 338 b 503 145 484 280 495 199 b 585 -185 525 16 555 -106 b 630 -245 596 -213 613 -237 l 634 -247 l 638 -245 b 647 -244 641 -245 645 -244 b 680 -278 666 -244 680 -262 b 664 -308 680 -290 675 -301 b 638 -312 658 -310 650 -312 b 613 -309 631 -312 623 -310 b 477 -201 555 -303 502 -260 b 417 -2 460 -159 434 -72 b 416 5 417 1 416 5 b 416 5 416 5 416 5 b 411 -5 415 5 413 0 b 359 -97 397 -33 377 -70 b 353 -106 355 -102 353 -105 b 359 -112 353 -108 355 -109 b 409 -130 375 -123 390 -129 b 426 -134 420 -130 421 -131 b 431 -147 428 -137 431 -141 b 420 -162 431 -152 427 -159 b 382 -169 409 -166 396 -169 b 323 -155 363 -169 341 -165 l 317 -152 l 314 -155 b 62 -303 240 -240 148 -295 b 36 -305 55 -305 44 -305 b 23 -303 29 -305 24 -305 b -1 -273 6 -299 -1 -287 b 31 -240 -1 -256 10 -240 b 36 -240 32 -240 34 -240 b 42 -241 38 -241 39 -241 b 134 -204 63 -241 99 -226 b 367 288 265 -115 357 81 b 375 330 368 313 370 320 b 416 360 383 347 400 358 m 360 -359 b 379 -359 363 -359 371 -359 b 424 -360 396 -359 416 -359 b 646 -502 536 -373 624 -430 b 649 -527 649 -510 649 -519 b 530 -673 649 -578 604 -635 l 521 -677 l 529 -681 b 653 -811 592 -714 637 -762 b 660 -853 658 -827 660 -839 b 645 -911 660 -873 656 -892 b 426 -1021 608 -981 519 -1021 b 283 -989 377 -1021 328 -1011 b 235 -949 249 -972 239 -964 b 234 -936 234 -946 234 -941 b 234 -928 234 -934 234 -931 l 235 -925 l 234 -927 l 225 -934 b 87 -982 186 -966 138 -982 b 80 -982 85 -982 83 -982 b 55 -981 70 -981 58 -981 b 17 -943 32 -981 17 -964 b 54 -904 17 -921 35 -904 b 78 -914 62 -904 72 -909 l 83 -918 l 88 -918 b 190 -831 122 -918 166 -881 b 269 -506 242 -727 269 -612 b 268 -462 269 -492 269 -477 b 266 -449 266 -458 266 -452 b 265 -444 266 -445 266 -444 b 257 -446 264 -444 261 -445 b 132 -545 196 -470 152 -505 b 88 -573 122 -563 104 -573 b 39 -523 63 -573 39 -553 b 63 -476 39 -505 44 -494 b 360 -359 136 -408 235 -369 m 419 -424 b 393 -423 411 -423 406 -423 l 375 -423 l 377 -426 b 379 -439 377 -427 378 -434 b 383 -510 382 -463 383 -487 b 314 -811 383 -609 360 -710 b 266 -893 296 -850 285 -870 b 264 -898 265 -896 264 -898 l 264 -898 b 264 -898 264 -898 264 -898 b 268 -898 264 -898 266 -898 b 273 -898 270 -898 272 -898 b 300 -909 283 -898 291 -900 b 426 -957 340 -941 385 -957 b 476 -949 443 -957 460 -954 b 547 -853 522 -931 547 -893 b 485 -745 547 -816 526 -775 b 397 -707 460 -727 432 -714 b 366 -675 375 -703 366 -692 b 396 -642 366 -657 377 -645 b 530 -557 455 -637 511 -601 b 536 -527 534 -548 536 -537 b 419 -424 536 -480 490 -437 "},"v30":{"x_min":-21.78125,"x_max":367.5,"ha":375,"o":"m 276 1900 b 284 1901 279 1900 281 1901 b 306 1883 291 1901 298 1896 b 367 1686 347 1825 367 1757 b 343 1558 367 1643 359 1600 l 338 1549 l 343 1537 b 367 1411 359 1497 367 1454 b 343 1282 367 1367 359 1324 l 338 1272 l 343 1261 b 367 1135 359 1221 367 1178 b 343 1007 367 1090 359 1047 l 338 996 l 343 985 b 367 859 359 945 367 902 b 343 731 367 814 359 771 l 338 720 l 343 709 b 367 582 359 667 367 626 b 289 362 367 503 340 426 b 239 312 276 345 259 330 b 29 77 152 237 76 152 b -1 18 14 54 2 30 b -19 4 -4 11 -12 4 l -21 4 l -21 133 l -20 260 l -13 262 b 98 299 17 269 62 284 b 111 305 103 302 110 305 b 167 334 123 310 156 327 b 319 595 264 391 319 491 b 313 659 319 616 318 638 b 310 667 311 664 311 667 b 307 663 310 667 308 666 b 240 588 289 637 269 614 b 16 331 141 505 62 413 b -1 294 8 316 1 302 b -19 280 -4 287 -12 280 l -21 280 l -21 408 l -20 537 l -13 538 b 98 576 17 545 62 560 b 111 581 103 578 110 581 b 167 610 123 587 156 603 b 319 871 264 667 319 767 b 313 935 319 892 318 913 b 310 942 311 941 311 942 b 307 939 310 942 308 941 b 240 864 289 913 269 889 b 16 607 141 781 62 689 b -1 570 8 592 1 578 b -19 556 -4 563 -12 556 l -21 556 l -21 684 l -20 813 l -13 814 b 98 852 17 821 62 836 b 111 857 103 855 110 857 b 167 886 123 863 156 880 b 319 1147 264 943 319 1043 b 313 1211 319 1168 318 1189 b 310 1218 311 1217 311 1218 b 307 1215 310 1218 308 1217 b 240 1140 289 1188 269 1165 b 16 884 141 1057 62 966 b -1 846 8 868 1 855 b -19 832 -4 839 -12 832 l -21 832 l -21 960 l -20 1089 l -13 1090 b 98 1128 17 1097 62 1111 b 111 1134 103 1131 110 1134 b 167 1163 123 1139 156 1156 b 319 1424 264 1220 319 1320 b 313 1486 319 1444 318 1465 b 310 1494 311 1493 311 1494 b 307 1492 310 1494 308 1493 b 240 1417 289 1464 269 1442 b 16 1160 141 1333 62 1242 b -1 1121 8 1145 1 1131 b -19 1109 -4 1115 -12 1109 l -21 1109 l -21 1236 l -20 1365 l -13 1367 b 98 1404 17 1374 62 1388 b 111 1410 103 1407 110 1410 b 250 1508 172 1437 215 1467 b 319 1701 296 1564 319 1633 b 270 1859 319 1757 303 1814 b 262 1882 265 1868 262 1875 b 276 1900 262 1890 266 1896 "},"v31":{"x_min":0,"x_max":386.5625,"ha":394,"o":"m 0 173 l 0 347 l 193 347 l 386 347 l 386 173 l 386 0 l 193 0 l 0 0 l 0 173 "},"v33":{"x_min":-423.3125,"x_max":421.9375,"ha":431,"o":"m -10 276 b -2 277 -8 277 -5 277 b 17 265 5 277 13 273 b 19 163 19 260 19 260 l 19 68 l 39 45 b 277 -95 122 -34 200 -81 b 289 -97 281 -97 285 -97 b 378 0 332 -97 371 -54 b 378 11 378 4 378 6 b 302 83 378 55 345 83 b 242 66 283 83 262 77 b 208 56 231 59 219 56 b 148 120 175 56 148 81 b 200 186 148 151 164 172 b 261 198 220 194 240 198 b 420 45 341 198 411 137 b 421 22 421 37 421 29 b 257 -198 421 -86 347 -188 b 242 -198 251 -198 247 -198 b 20 -105 181 -198 95 -163 l 19 -104 l 19 -183 b 19 -216 19 -195 19 -206 b 12 -273 19 -272 17 -267 b -2 -278 8 -277 2 -278 b -21 -266 -10 -278 -19 -274 b -23 -165 -23 -263 -23 -262 l -23 -69 l -44 -47 b -250 86 -117 23 -183 66 b -295 94 -270 93 -284 94 b -315 91 -302 94 -308 94 b -381 5 -356 81 -381 43 b -355 -56 -381 -16 -372 -40 b -299 -81 -338 -73 -319 -81 b -246 -68 -283 -81 -265 -77 b -212 -58 -234 -61 -223 -58 b -168 -77 -196 -58 -179 -65 b -151 -122 -156 -90 -151 -105 b -179 -174 -151 -141 -160 -162 b -239 -195 -194 -184 -217 -192 b -257 -197 -245 -195 -250 -197 b -423 -5 -349 -197 -423 -113 b -423 0 -423 -4 -423 -1 b -277 194 -420 97 -362 173 b -247 197 -268 197 -258 197 b -24 104 -185 197 -100 162 l -23 102 l -23 181 b -21 265 -23 260 -23 260 b -10 276 -20 269 -14 274 "},"v34":{"x_min":0,"x_max":622.03125,"ha":635,"o":"m 398 417 b 406 419 401 419 404 419 b 427 398 417 419 427 409 b 427 391 427 395 427 392 b 34 -274 424 385 38 -272 b 20 -280 29 -278 25 -280 b 0 -259 9 -280 0 -270 b 0 -252 0 -256 0 -254 b 393 413 2 -247 389 410 b 398 417 394 415 397 416 m 592 417 b 600 419 594 419 597 419 b 622 398 611 419 622 409 b 620 391 622 395 620 392 b 227 -274 617 385 231 -272 b 213 -280 223 -278 219 -280 b 193 -259 202 -280 193 -270 b 194 -252 193 -256 193 -254 b 586 413 196 -247 582 410 b 592 417 588 415 590 416 "},"v36":{"x_min":-1.359375,"x_max":1064.390625,"ha":1086,"o":"m 296 692 b 314 694 302 694 307 694 b 386 685 337 694 366 689 b 548 498 480 660 548 580 b 548 481 548 492 548 487 b 455 395 541 426 499 395 b 370 462 420 395 383 417 b 362 496 364 477 362 488 b 377 514 362 509 367 514 b 393 501 386 514 390 510 b 432 474 397 484 413 474 b 470 487 445 474 458 478 b 491 530 484 496 491 510 b 490 544 491 534 491 539 b 333 660 479 606 411 657 l 323 662 l 315 646 b 269 524 285 591 269 556 b 321 431 269 492 287 466 b 349 395 338 413 343 408 b 363 342 359 378 363 362 b 359 312 363 333 362 322 b 285 158 348 266 318 206 b 281 152 283 155 281 152 b 281 152 281 152 281 152 b 287 154 283 152 284 152 b 318 155 298 154 308 155 b 461 98 371 155 419 136 l 464 97 l 483 112 b 503 129 494 120 503 127 b 504 130 503 129 504 129 b 503 138 504 131 503 134 b 500 180 500 152 500 166 b 553 326 500 238 518 288 b 604 366 560 331 592 358 b 649 381 617 376 632 381 b 696 362 665 381 681 374 b 724 302 714 347 724 324 b 695 238 724 278 714 255 b 660 210 691 234 662 212 b 579 148 658 209 582 151 b 579 148 579 148 579 148 b 596 106 579 144 589 119 b 622 77 604 88 609 83 b 657 69 632 72 645 69 b 748 112 688 69 721 84 b 755 123 754 117 755 120 b 755 127 755 124 755 126 b 751 165 752 137 751 151 b 758 219 751 183 754 202 b 894 387 774 290 820 347 b 896 390 896 388 896 388 b 891 398 896 391 895 392 b 622 560 827 477 730 535 b 600 580 605 564 600 569 b 617 596 600 591 607 596 b 628 595 622 596 624 596 b 1057 248 846 552 1020 412 b 1064 191 1061 229 1064 209 b 922 0 1064 94 1005 9 b 902 -1 916 -1 909 -1 b 774 76 847 -1 800 26 b 769 83 770 81 770 83 b 769 81 769 83 769 83 b 627 -1 733 29 677 -1 b 548 27 597 -1 570 8 b 515 88 537 37 525 61 l 513 95 l 510 93 l 453 45 b 390 0 396 0 396 0 b 390 0 390 0 390 0 b 374 15 381 0 377 4 b 268 105 359 69 314 105 b 250 104 262 105 257 105 l 243 102 l 234 90 b 155 1 201 49 159 2 b 147 -1 152 0 149 -1 b 130 15 138 -1 130 6 b 132 20 130 18 132 19 b 136 31 133 22 134 27 b 220 131 149 74 178 109 b 231 137 225 134 230 136 b 302 278 280 202 302 244 b 265 335 302 299 295 309 b 209 442 234 363 213 402 b 209 455 209 446 209 451 b 279 648 209 502 232 564 l 285 659 l 283 659 b 176 627 238 653 210 645 b 57 477 111 594 66 538 b 55 459 55 471 55 464 b 72 409 55 437 61 415 b 93 403 78 405 87 403 b 152 467 123 403 151 431 b 168 488 153 483 157 488 b 185 462 181 488 185 483 l 185 460 b 137 344 183 409 168 369 b 78 322 119 328 98 322 b 13 360 50 322 25 335 b -1 426 4 380 -1 402 b 89 610 -1 488 32 559 b 296 692 147 659 210 685 m 926 348 b 921 353 924 351 922 353 b 914 348 920 353 918 351 b 823 167 857 306 823 237 b 828 124 823 154 826 138 b 890 31 837 79 862 40 b 896 31 892 31 894 31 b 956 104 916 31 940 59 b 970 191 965 129 970 159 b 966 241 970 208 969 224 b 926 348 959 277 945 313 m 627 326 b 619 326 624 326 622 326 b 598 316 611 326 604 323 b 568 215 579 288 568 255 b 568 208 568 213 568 210 b 571 183 570 195 570 184 l 571 183 b 594 201 571 183 582 191 l 634 231 b 660 259 653 247 656 248 b 664 278 662 266 664 272 b 627 326 664 299 649 320 "},"v38":{"x_min":-1.359375,"x_max":651.96875,"ha":665,"o":"m 389 644 b 405 645 394 645 400 645 b 504 566 450 645 492 613 b 507 541 506 557 507 549 b 480 471 507 514 498 489 l 477 467 l 483 470 b 609 591 539 485 586 531 b 613 601 611 595 613 599 b 631 609 619 607 624 609 b 651 588 641 609 651 602 b 200 -946 651 584 204 -941 b 182 -957 197 -953 190 -957 b 163 -945 174 -957 166 -953 b 161 -939 161 -942 161 -942 b 217 -743 161 -931 170 -904 b 272 -555 247 -639 272 -555 b 272 -555 272 -555 272 -555 b 264 -560 272 -555 268 -557 b 140 -603 227 -589 182 -603 b 36 -567 102 -603 65 -592 b -1 -487 12 -548 -1 -517 b 17 -427 -1 -466 5 -445 b 103 -380 38 -395 70 -380 b 191 -433 137 -380 172 -398 b 205 -484 201 -448 205 -466 b 178 -553 205 -509 196 -535 l 175 -557 l 182 -555 b 307 -435 236 -539 284 -494 b 372 -213 308 -430 372 -215 b 372 -213 372 -213 372 -213 b 364 -219 372 -213 368 -216 b 240 -262 328 -247 283 -262 b 137 -226 202 -262 166 -249 b 99 -145 112 -206 99 -176 b 118 -84 99 -124 106 -104 b 204 -38 138 -54 171 -38 b 292 -91 238 -38 273 -56 b 306 -141 302 -106 306 -124 b 279 -212 306 -167 296 -194 l 276 -215 l 281 -213 b 408 -93 336 -198 385 -151 b 473 129 409 -88 473 127 b 473 129 473 129 473 129 b 465 122 473 129 469 126 b 341 80 428 94 383 80 b 236 115 303 80 266 91 b 200 195 213 136 200 165 b 217 256 200 217 206 238 b 304 303 239 287 272 303 b 393 249 338 303 374 285 b 406 199 402 234 406 217 b 379 129 406 173 397 148 l 377 126 l 382 127 b 509 248 436 142 485 190 b 574 470 510 254 574 469 b 574 470 574 470 574 470 b 566 464 574 470 570 467 b 442 421 529 435 484 421 b 337 458 404 421 367 433 b 300 537 313 478 300 508 b 389 644 300 585 334 635 "},"v3b":{"x_min":0,"x_max":484.5625,"ha":494,"o":"m 228 245 b 239 247 234 247 239 247 b 243 247 240 247 242 247 b 303 238 257 247 287 242 b 484 -2 417 208 484 104 b 412 -177 484 -65 461 -127 b 243 -248 363 -226 303 -248 b 6 -63 138 -248 36 -180 b 0 -1 1 -41 0 -20 b 228 245 0 127 98 240 m 255 181 b 240 183 247 183 245 183 b 232 181 238 183 235 183 b 142 152 200 180 168 170 l 138 149 l 190 97 l 242 44 l 294 97 l 345 149 l 340 152 b 255 181 315 169 284 180 m 147 -54 l 197 -1 l 147 51 l 95 104 l 91 99 b 62 -1 72 70 62 34 b 66 -43 62 -15 63 -29 b 91 -101 72 -63 80 -84 l 95 -106 l 147 -54 m 393 99 b 389 104 390 102 389 104 b 337 51 389 104 366 80 l 285 -1 l 337 -54 l 389 -106 l 393 -101 b 421 -1 412 -72 421 -36 b 393 99 421 34 412 69 m 294 -98 b 242 -45 265 -69 242 -45 b 190 -98 242 -45 219 -69 l 138 -151 l 142 -154 b 242 -184 172 -174 206 -184 b 340 -154 276 -184 311 -174 l 345 -151 l 294 -98 "},"v3c":{"x_min":0,"x_max":450.53125,"ha":460,"o":"m 189 302 b 204 303 193 302 198 303 b 303 224 250 303 292 270 b 306 199 304 216 306 208 b 279 129 306 173 296 147 l 276 126 l 281 127 b 408 249 337 142 385 190 b 412 259 409 254 412 258 b 430 267 417 265 423 267 b 450 247 441 267 450 259 b 200 -605 450 242 204 -599 b 182 -616 197 -612 190 -616 b 163 -602 174 -616 166 -610 b 161 -598 161 -601 161 -601 b 217 -402 161 -589 170 -562 b 272 -213 247 -298 272 -213 b 272 -213 272 -213 272 -213 b 264 -219 272 -213 268 -216 b 140 -262 227 -247 182 -262 b 36 -226 102 -262 65 -249 b 0 -145 12 -206 0 -176 b 17 -84 0 -124 5 -104 b 103 -38 38 -54 70 -38 b 191 -91 137 -38 172 -56 b 205 -141 201 -106 205 -124 b 178 -212 205 -167 196 -194 l 175 -215 l 182 -213 b 307 -93 236 -198 284 -151 b 372 129 308 -88 372 127 b 372 129 372 129 372 129 b 364 122 372 129 368 126 b 240 80 328 94 283 80 b 137 115 202 80 166 91 b 99 194 111 136 99 165 b 189 302 99 244 133 292 "},"v3e":{"x_min":0,"x_max":406.96875,"ha":415,"o":"m 21 183 b 28 183 24 183 25 183 b 42 181 34 183 39 183 b 127 108 47 179 47 179 b 202 41 168 72 202 41 b 279 108 204 41 238 72 b 357 177 321 145 356 176 b 375 183 363 181 370 183 b 406 151 392 183 406 169 b 404 137 406 147 405 141 b 322 62 401 131 398 129 b 251 0 284 27 251 0 b 322 -63 251 -1 284 -29 b 404 -138 398 -130 401 -133 b 406 -152 405 -142 406 -148 b 375 -184 406 -170 392 -184 b 357 -179 370 -184 363 -183 b 279 -109 356 -177 321 -147 b 202 -43 238 -73 204 -43 b 127 -109 202 -43 168 -73 b 49 -179 85 -147 50 -177 b 31 -184 43 -183 36 -184 b 0 -152 13 -184 0 -170 b 2 -138 0 -148 0 -142 b 83 -63 5 -133 8 -130 b 155 0 122 -29 155 -1 b 83 62 155 0 122 27 b 8 129 43 97 10 127 b 0 151 2 136 0 144 b 21 183 0 165 8 177 "},"v3f":{"x_min":-24.5,"x_max":317.140625,"ha":324,"o":"m -24 -147 l -24 -5 l -20 -5 b -1 -19 -12 -5 -4 -11 b 58 -123 6 -43 31 -86 b 196 -278 93 -173 134 -219 b 317 -570 274 -356 317 -460 b 294 -713 317 -617 308 -666 l 289 -724 l 294 -735 b 317 -873 308 -780 317 -827 b 235 -1132 317 -963 288 -1054 b 209 -1165 228 -1140 224 -1146 b 189 -1177 204 -1172 196 -1177 b 171 -1164 182 -1177 175 -1172 b 168 -1154 170 -1161 168 -1159 b 181 -1132 168 -1149 172 -1142 b 269 -891 238 -1064 269 -975 b 269 -881 269 -886 269 -884 b 262 -814 269 -857 265 -827 b 258 -800 261 -811 259 -806 b 142 -628 240 -731 198 -667 b -8 -589 112 -606 47 -589 b -20 -589 -13 -589 -19 -589 l -24 -589 l -24 -449 l -24 -308 l -20 -308 b -1 -322 -12 -308 -4 -313 b 58 -424 6 -345 31 -388 b 194 -580 93 -476 136 -523 b 259 -660 221 -606 245 -635 b 261 -663 259 -662 261 -663 b 264 -656 262 -663 262 -660 b 269 -587 268 -632 269 -610 b 264 -521 269 -566 268 -544 b 262 -512 264 -517 262 -513 b 258 -498 261 -509 259 -503 b 142 -326 240 -428 198 -365 b -8 -287 112 -303 47 -288 b -20 -287 -13 -287 -19 -287 l -24 -287 l -24 -147 "},"v40":{"x_min":-1.359375,"x_max":436.921875,"ha":446,"o":"m 213 205 b 217 205 215 205 216 205 b 234 194 224 205 234 199 b 236 187 234 194 235 190 l 245 167 l 261 129 l 270 106 b 355 -61 294 54 329 -13 b 420 -163 381 -105 402 -138 b 436 -188 435 -184 436 -184 b 436 -191 436 -190 436 -190 b 421 -206 436 -201 431 -206 l 421 -206 l 416 -206 l 405 -201 b 217 -158 347 -172 283 -158 b 31 -201 153 -158 88 -172 l 20 -206 l 14 -206 l 14 -206 b 0 -191 5 -206 0 -201 b -1 -188 0 -190 -1 -190 b 14 -163 -1 -186 0 -184 b 95 -34 36 -136 72 -77 b 166 106 119 8 148 68 l 175 129 l 183 148 l 200 188 b 213 205 205 199 208 202 "},"v41":{"x_min":-1.359375,"x_max":556.6875,"ha":568,"o":"m 294 322 b 318 323 299 322 308 323 b 360 320 334 323 352 322 b 526 217 430 310 490 273 b 543 166 537 202 543 184 b 447 70 543 117 503 70 b 445 70 447 70 446 70 b 359 159 394 72 359 113 b 368 201 359 173 362 187 b 442 245 382 229 412 245 b 455 244 446 245 451 245 b 460 244 458 244 460 244 b 460 244 460 244 460 244 b 454 248 460 244 458 245 b 325 291 417 276 372 291 b 285 287 313 291 299 290 b 144 -2 183 269 144 190 b 281 -290 144 -208 179 -280 b 304 -291 289 -291 298 -291 b 524 -105 412 -291 506 -212 b 541 -84 526 -88 530 -84 b 556 -101 551 -84 556 -90 b 549 -138 556 -111 553 -122 b 334 -322 521 -237 435 -310 b 302 -324 323 -323 313 -324 b 13 -101 172 -324 54 -234 b -1 -1 4 -68 -1 -34 b 294 322 -1 161 121 303 "},"v42":{"x_min":-348.4375,"x_max":24.5,"ha":25,"o":"m -330 155 b -322 156 -329 156 -326 156 b -315 156 -319 156 -317 156 b -298 147 -311 155 -308 154 b -19 30 -224 98 -122 55 l 2 26 b 24 -1 17 22 24 13 b 2 -27 24 -15 17 -23 l -19 -31 b -298 -148 -122 -56 -224 -99 b -322 -158 -313 -158 -315 -158 b -348 -131 -338 -158 -348 -145 b -344 -117 -348 -127 -347 -122 b -328 -104 -341 -112 -338 -111 b -127 -8 -269 -65 -202 -33 b -106 0 -115 -4 -106 -1 b -127 6 -106 0 -115 2 b -328 102 -202 31 -269 63 b -344 116 -338 109 -341 111 b -348 130 -347 120 -348 124 b -330 155 -348 141 -341 152 "},"v43":{"x_min":-442.359375,"x_max":441,"ha":450,"o":"m -31 487 b -1 488 -21 488 -10 488 b 434 104 216 488 397 330 b 441 27 438 79 441 47 b 439 12 441 20 439 15 b 419 0 435 4 427 0 b 404 5 413 0 408 1 b 398 30 400 11 398 13 b 0 351 390 213 213 351 b -59 348 -20 351 -39 349 b -400 30 -251 324 -393 191 b -405 5 -400 13 -401 11 b -420 0 -409 1 -415 0 b -441 12 -428 0 -436 4 b -442 27 -441 15 -442 20 b -435 104 -442 47 -439 79 b -31 487 -401 316 -235 474 m -13 131 b -1 133 -9 133 -5 133 b 51 105 19 133 39 123 b 61 70 58 95 61 83 b 51 34 61 58 58 45 b -1 6 39 16 19 6 b -46 27 -17 6 -34 13 b -62 69 -57 38 -62 54 b -13 131 -62 98 -44 124 "},"v44":{"x_min":-21.78125,"x_max":251.8125,"ha":257,"o":"m -8 631 b -1 632 -6 632 -4 632 b 19 620 8 632 16 628 b 20 383 20 616 20 616 l 20 148 l 21 151 b 137 199 59 183 99 199 b 182 191 152 199 167 197 b 251 84 227 176 251 134 b 228 0 251 58 243 29 b 100 -142 206 -40 178 -72 l 23 -215 b 0 -229 9 -229 6 -229 b -20 -216 -9 -229 -17 -224 l -21 -212 l -21 201 l -21 616 l -20 620 b -8 631 -17 624 -13 630 m 110 131 b 96 133 106 133 100 133 b 89 133 93 133 91 133 b 24 87 63 129 40 113 l 20 80 l 20 -37 l 20 -156 l 23 -152 b 144 81 96 -72 144 20 l 144 83 b 110 131 144 113 134 126 "},"v45":{"x_min":-402.890625,"x_max":401.53125,"ha":410,"o":"m -10 273 b -4 274 -9 273 -6 274 b 16 262 4 274 12 269 b 17 158 17 259 17 259 l 17 56 l 62 112 b 117 174 110 172 110 172 b 122 174 118 174 119 174 b 132 173 125 174 129 173 b 295 11 134 172 171 134 l 307 -1 l 336 34 b 374 76 366 72 368 74 b 381 77 375 77 378 77 b 401 56 392 77 401 68 b 400 48 401 54 401 51 b 223 -172 397 41 230 -166 b 210 -176 220 -174 215 -176 b 201 -174 206 -176 204 -176 b 112 -87 198 -173 178 -152 b 27 0 65 -38 27 0 b 21 -6 27 0 24 -2 l 17 -12 l 17 -147 b 17 -210 17 -173 17 -194 b 10 -292 17 -297 16 -287 b -2 -299 6 -297 2 -299 b -21 -287 -10 -299 -19 -295 b -24 -174 -23 -284 -23 -284 l -24 -63 l -66 -117 b -121 -176 -110 -170 -114 -176 b -125 -176 -122 -176 -123 -176 b -296 -12 -134 -174 -125 -184 l -308 0 l -337 -34 b -375 -77 -367 -73 -370 -76 b -382 -79 -377 -79 -379 -79 b -402 -58 -393 -79 -402 -69 b -401 -49 -402 -55 -402 -52 b -224 170 -398 -43 -231 165 b -212 174 -221 173 -216 174 b -202 173 -208 174 -205 174 b -39 11 -200 172 -151 122 l -28 -1 l -25 1 l -24 4 l -24 130 b -23 260 -24 256 -24 258 b -10 273 -20 266 -16 270 "},"v46":{"x_min":0,"x_max":627.46875,"ha":640,"o":"m 306 190 b 314 191 308 191 311 191 b 326 184 318 191 322 190 l 336 173 b 510 52 377 127 442 80 b 515 49 513 51 515 49 b 611 16 537 40 579 24 b 627 0 624 13 627 9 b 607 -18 627 -11 624 -13 b 330 -181 490 -49 389 -109 b 314 -192 323 -190 319 -192 b 306 -191 311 -192 308 -192 b 294 -177 302 -188 302 -188 b 257 -140 287 -170 265 -148 b 19 -18 193 -84 114 -44 b 0 0 2 -13 0 -11 b 16 16 0 9 2 13 b 110 49 47 24 89 40 b 117 52 111 49 114 51 b 145 65 126 56 130 58 b 281 163 200 93 245 124 b 300 186 288 170 291 174 b 306 190 300 187 303 188 m 317 137 b 313 142 315 141 314 142 b 308 137 313 142 311 141 b 161 4 276 84 220 33 b 155 0 159 1 155 0 b 163 -4 155 0 159 -2 b 308 -138 220 -34 276 -84 b 313 -142 311 -141 313 -142 b 317 -138 314 -142 315 -141 b 464 -4 351 -84 406 -34 b 470 0 468 -2 470 0 b 464 4 470 0 468 1 b 317 137 406 33 351 84 "},"v47":{"x_min":-24.5,"x_max":315.78125,"ha":322,"o":"m -24 -145 l -24 -5 l -20 -5 b 1 -26 -10 -5 -6 -9 b 175 -241 31 -86 96 -166 b 314 -548 259 -323 304 -420 b 315 -589 315 -555 315 -571 b 314 -630 315 -606 315 -623 b 298 -730 311 -664 306 -699 l 295 -742 l 296 -748 b 314 -850 304 -778 311 -813 b 315 -892 315 -857 315 -874 b 314 -932 315 -909 315 -925 b 298 -1032 311 -967 306 -1002 l 295 -1045 l 296 -1050 b 314 -1153 304 -1081 311 -1115 b 315 -1193 315 -1160 315 -1177 b 314 -1235 315 -1211 315 -1228 b 217 -1526 306 -1338 270 -1444 b 201 -1533 213 -1532 208 -1533 b 182 -1522 193 -1533 185 -1529 b 179 -1514 181 -1518 179 -1517 b 189 -1489 179 -1508 182 -1501 b 266 -1217 240 -1403 266 -1308 b 262 -1156 266 -1196 265 -1177 b 110 -907 247 -1043 190 -950 b 0 -889 87 -895 50 -889 l -1 -889 l -24 -889 l -24 -749 l -24 -610 l -20 -610 b 1 -631 -10 -610 -6 -614 b 175 -846 31 -691 96 -771 b 259 -956 213 -884 236 -914 b 265 -966 262 -961 264 -966 b 265 -966 265 -966 265 -966 b 265 -953 265 -964 265 -959 b 266 -920 266 -943 266 -932 b 262 -853 266 -898 265 -873 b 110 -605 247 -741 190 -648 b 0 -587 87 -592 50 -587 l -1 -587 l -24 -587 l -24 -448 l -24 -308 l -20 -308 b 1 -328 -10 -308 -6 -312 b 175 -544 31 -388 96 -469 b 259 -655 213 -581 236 -612 b 265 -663 262 -659 264 -663 b 265 -663 265 -663 265 -663 b 265 -650 265 -663 265 -657 b 266 -617 266 -641 266 -630 b 262 -551 266 -595 265 -570 b 110 -303 247 -438 190 -345 b 0 -284 87 -290 50 -284 l -1 -284 l -24 -284 l -24 -145 "},"v49":{"x_min":0,"x_max":630.203125,"ha":643,"o":"m 308 204 b 314 205 310 205 313 205 b 326 201 319 205 323 204 b 355 154 328 199 338 180 b 401 83 362 142 392 95 l 409 72 b 431 41 412 66 424 49 b 619 -174 498 -51 570 -134 b 630 -192 626 -180 630 -186 b 626 -202 630 -195 628 -199 b 616 -206 623 -205 620 -206 b 552 -188 608 -206 592 -202 b 310 -155 488 -169 392 -155 b 268 -156 295 -155 281 -155 b 77 -188 197 -161 126 -173 b 13 -206 35 -202 20 -206 b 9 -206 12 -206 10 -206 b 0 -191 2 -202 0 -197 b 8 -176 0 -186 2 -180 b 204 49 58 -136 138 -43 l 220 72 l 227 83 b 295 188 245 108 281 166 b 308 204 299 197 304 202 m 315 147 b 314 147 315 147 314 147 b 314 147 314 147 314 147 b 306 129 314 145 310 138 l 296 105 b 281 72 292 97 284 77 l 274 56 b 181 -123 247 -4 212 -72 l 174 -134 l 176 -133 b 314 -123 215 -127 272 -123 b 451 -133 356 -123 413 -127 l 454 -134 l 449 -123 b 353 56 417 -72 381 -4 l 347 72 b 332 105 344 77 336 97 l 322 129 b 315 147 318 138 315 145 "},"v4a":{"x_min":70.78125,"x_max":378.390625,"ha":315,"o":"m 246 373 b 254 373 249 373 251 373 b 372 324 303 373 360 351 b 378 302 377 317 378 309 b 338 251 378 278 362 255 b 328 249 334 249 332 249 b 283 294 303 249 283 270 b 288 315 283 301 284 308 b 289 319 289 317 289 319 b 289 319 289 319 289 319 b 283 320 289 320 287 320 b 270 322 279 322 274 322 b 206 288 242 322 215 308 b 206 283 206 287 206 285 b 257 223 206 267 230 238 b 284 206 272 213 277 210 b 351 90 328 173 351 130 b 340 47 351 74 348 59 b 205 -30 314 -2 264 -30 b 182 -29 198 -30 190 -30 b 84 15 147 -24 103 -5 b 70 48 74 24 70 36 b 108 99 70 70 85 94 b 121 102 112 101 117 102 b 167 56 147 102 167 80 b 159 31 167 48 164 40 l 156 26 l 157 26 b 190 20 167 22 178 20 b 220 26 201 20 212 22 b 258 65 243 34 258 51 b 257 70 258 66 258 69 b 204 126 249 94 234 109 b 114 258 148 158 114 209 b 125 302 114 273 118 288 b 246 373 147 342 193 370 "},"v4b":{"x_min":0,"x_max":503.609375,"ha":514,"o":"m 274 430 b 277 430 276 430 277 430 b 310 394 296 430 310 415 b 308 383 310 391 308 387 b 306 367 307 381 307 374 b 236 120 298 305 272 210 b 40 -273 189 -5 125 -134 b 20 -287 35 -283 27 -287 b 5 -281 14 -287 9 -285 b 0 -267 1 -277 0 -273 b 9 -242 0 -262 2 -255 b 246 395 137 -12 232 242 b 274 430 249 416 257 427 m 468 430 b 472 430 469 430 470 430 b 503 394 490 430 503 415 b 502 383 503 391 503 387 b 499 367 502 381 500 374 b 431 120 491 305 465 210 b 234 -273 382 -5 318 -134 b 213 -287 228 -283 220 -287 b 198 -281 208 -287 202 -285 b 193 -267 194 -277 193 -273 b 202 -242 193 -262 196 -255 b 439 395 330 -12 426 242 b 468 430 442 416 451 427 "},"v4d":{"x_min":-311.6875,"x_max":310.328125,"ha":317,"o":"m -9 388 b -2 390 -8 390 -5 390 b 5 388 1 390 4 390 b 19 378 10 387 16 383 b 23 333 23 371 23 371 b 24 298 23 299 24 298 b 81 276 34 298 65 285 b 213 91 145 240 190 177 b 224 24 217 76 224 36 b 257 24 224 24 235 24 b 299 19 292 24 292 24 b 310 -1 306 15 310 6 b 299 -23 310 -11 306 -19 b 257 -27 292 -27 292 -27 b 224 -29 235 -27 224 -29 b 213 -95 224 -40 217 -80 b 81 -280 190 -181 145 -244 b 24 -301 65 -290 34 -301 b 23 -335 24 -301 23 -303 l 23 -340 b 17 -381 23 -374 23 -374 b -1 -391 13 -388 5 -391 b -21 -381 -9 -391 -17 -388 b -27 -340 -27 -374 -27 -374 l -27 -335 b -28 -301 -27 -303 -27 -301 b -85 -280 -38 -301 -69 -290 b -217 -95 -149 -244 -194 -181 b -228 -29 -221 -80 -228 -40 b -259 -27 -228 -29 -238 -27 b -300 -23 -294 -27 -294 -27 b -311 -2 -307 -19 -311 -11 b -294 23 -311 8 -304 19 b -259 24 -291 23 -284 24 b -228 24 -239 24 -228 24 b -217 91 -228 36 -221 76 b -85 276 -194 177 -149 240 b -28 298 -69 285 -38 298 b -27 333 -27 298 -27 299 b -27 371 -27 362 -27 369 b -9 388 -24 378 -17 385 m -27 136 b -28 247 -27 197 -28 247 b -61 216 -31 247 -53 226 b -123 33 -95 172 -121 98 l -125 24 l -76 24 l -27 24 l -27 136 m 29 242 b 24 247 27 245 24 247 b 23 136 24 247 23 197 l 23 24 l 72 24 l 121 24 l 119 33 b 29 242 115 116 77 206 m -27 -140 l -27 -27 l -76 -27 l -125 -27 l -123 -36 b -61 -220 -121 -102 -95 -176 b -28 -251 -53 -230 -31 -251 b -27 -140 -28 -251 -27 -201 m 119 -36 l 121 -27 l 72 -27 l 23 -27 l 23 -140 b 24 -251 23 -201 24 -251 b 57 -220 27 -251 49 -230 b 119 -36 91 -176 117 -102 "},"v4e":{"x_min":0,"x_max":239.5625,"ha":244,"o":"m 10 460 b 20 462 13 462 14 462 b 39 449 28 462 35 458 l 40 446 l 40 326 b 40 205 40 259 40 205 b 127 227 40 205 80 215 b 220 249 196 244 213 249 b 227 247 224 249 225 248 b 238 237 231 245 235 241 l 239 233 l 239 -106 l 239 -448 l 238 -451 b 219 -463 234 -459 225 -463 b 198 -451 210 -463 202 -459 l 197 -448 l 197 -324 b 197 -201 197 -248 197 -201 b 110 -223 196 -201 157 -210 b 17 -245 42 -240 24 -245 b 10 -242 13 -245 13 -244 b 0 -233 6 -241 2 -237 l 0 -230 l 0 108 l 0 446 l 0 449 b 10 460 2 453 6 458 m 197 22 b 197 70 197 41 197 58 b 196 116 197 113 197 116 l 196 116 b 118 97 196 116 160 106 l 40 77 l 40 -18 b 40 -112 40 -69 40 -112 l 119 -93 l 197 -73 l 197 22 "},"v51":{"x_min":-1.359375,"x_max":455.96875,"ha":465,"o":"m 352 541 b 357 542 353 542 355 542 b 377 530 364 542 372 537 l 378 526 l 378 394 l 379 262 l 404 266 b 436 270 420 269 430 270 b 450 265 443 270 446 269 b 455 220 455 259 455 260 l 455 208 l 455 161 l 454 156 b 411 140 449 147 447 147 b 378 133 393 137 379 134 b 378 68 378 133 378 106 b 378 22 378 54 378 38 l 379 -87 l 404 -83 b 436 -79 420 -80 430 -79 b 450 -84 443 -79 446 -80 b 455 -129 455 -90 455 -88 l 455 -141 l 455 -188 l 454 -192 b 413 -209 449 -202 447 -202 b 382 -215 398 -212 383 -215 l 378 -215 l 378 -345 l 378 -380 b 375 -485 378 -484 378 -480 b 357 -494 371 -491 364 -494 b 340 -485 351 -494 344 -491 b 336 -383 337 -480 336 -484 l 336 -349 l 336 -223 l 334 -223 b 291 -231 334 -223 314 -227 l 247 -240 l 247 -371 l 246 -503 l 245 -506 b 225 -519 242 -514 234 -519 b 206 -506 219 -519 210 -514 l 205 -503 l 205 -376 l 205 -248 l 160 -256 l 115 -265 l 115 -396 l 115 -527 l 114 -531 b 95 -544 110 -539 102 -544 b 76 -531 87 -544 78 -539 l 73 -527 l 73 -399 b 73 -273 73 -330 73 -273 b 49 -277 73 -273 61 -274 b 17 -281 32 -280 24 -281 b 4 -276 10 -281 8 -280 b -1 -234 0 -269 -1 -272 b 0 -219 -1 -229 0 -224 l 0 -170 l 1 -167 b 10 -158 2 -163 6 -159 b 49 -149 13 -156 16 -155 l 73 -145 l 73 -34 b 73 76 73 26 73 76 b 49 72 73 76 61 74 b 17 68 32 69 24 68 b 4 73 10 68 8 69 b -1 115 0 80 -1 77 b 0 130 -1 120 0 124 l 0 179 l 1 181 b 10 191 2 186 6 190 b 49 199 13 192 16 194 l 73 204 l 73 338 b 73 374 73 352 73 365 b 77 483 73 484 73 477 b 95 492 81 489 88 492 b 111 483 100 492 107 489 b 115 378 115 477 115 483 l 115 342 b 117 212 115 223 115 212 b 204 229 117 212 200 227 l 205 229 l 205 365 l 205 502 l 206 505 b 225 517 210 513 219 517 b 245 505 234 517 242 513 l 246 502 l 247 369 l 247 237 l 249 237 b 336 254 253 238 336 254 b 337 390 336 254 337 302 l 337 526 l 338 530 b 352 541 341 535 347 539 m 336 15 b 336 126 336 102 336 126 l 336 126 b 291 117 336 126 315 122 l 247 109 l 247 -1 l 247 -112 l 249 -112 b 336 -95 253 -111 336 -95 b 336 15 336 -95 336 -56 m 205 -120 b 205 -55 205 -120 205 -93 b 205 -9 205 -41 205 -24 l 205 101 l 160 93 l 115 84 l 115 -26 b 115 -83 115 -49 115 -69 b 117 -137 115 -133 115 -137 b 205 -120 118 -137 204 -120 "},"v52":{"x_min":-10.890625,"x_max":298.078125,"ha":294,"o":"m 138 473 b 142 474 140 473 141 474 b 164 459 148 474 153 470 b 191 402 183 442 191 423 b 181 353 191 388 187 371 b 178 349 179 352 178 349 b 179 348 178 348 179 348 b 185 349 181 348 182 348 b 255 376 210 355 234 363 b 272 381 264 381 266 381 b 298 355 287 381 298 370 b 288 330 298 348 298 345 b 171 34 238 254 194 141 b 166 13 168 16 168 16 b 144 1 161 5 152 1 b 121 15 134 1 125 5 b 115 33 119 18 117 24 b 0 330 91 145 49 252 b -10 355 -9 345 -10 348 b 13 381 -10 371 0 381 b 31 376 19 381 25 380 b 132 345 61 358 103 345 l 136 345 l 137 355 b 145 378 138 359 142 370 b 152 415 149 394 152 405 b 137 452 152 427 148 438 b 133 464 134 458 133 460 b 138 473 133 467 134 470 "},"v53":{"x_min":0,"x_max":902.421875,"ha":921,"o":"m 17 240 b 24 241 19 241 21 241 b 32 240 28 241 31 241 b 46 229 38 238 43 234 b 50 88 50 223 50 237 b 50 -1 50 63 50 34 b 50 -90 50 -36 50 -65 b 46 -231 50 -238 50 -224 b 25 -242 42 -238 34 -242 b 0 -224 14 -242 4 -235 b 0 2 0 -222 0 -108 b 0 223 0 112 0 220 b 17 240 2 230 9 237 m 110 240 b 118 241 111 241 114 241 b 126 240 121 241 123 241 b 142 223 133 237 140 230 b 144 123 144 220 144 205 b 144 29 144 45 144 29 b 144 29 144 29 144 29 b 393 183 166 106 264 167 b 450 186 412 184 431 186 b 756 29 600 186 732 120 b 756 29 756 29 756 29 b 758 123 758 29 758 45 b 760 227 758 226 758 223 b 784 241 766 237 774 241 b 804 229 792 241 800 237 b 809 88 808 223 809 237 l 809 -1 l 809 -90 b 804 -231 809 -238 808 -224 b 784 -242 800 -238 792 -242 b 762 -231 775 -242 766 -238 b 758 -124 756 -224 758 -231 b 756 -30 758 -47 758 -30 b 756 -30 756 -30 756 -30 b 509 -184 736 -108 637 -169 b 450 -187 488 -187 469 -187 b 144 -30 300 -187 168 -122 b 144 -30 144 -30 144 -30 b 144 -124 144 -30 144 -47 b 140 -231 144 -231 144 -224 b 118 -242 134 -238 126 -242 b 92 -224 107 -242 96 -235 b 92 2 92 -222 92 -108 b 92 223 92 112 92 220 b 110 240 95 230 102 237 m 432 161 b 413 162 426 162 420 162 b 313 41 351 162 313 109 b 347 -73 313 5 323 -34 b 487 -163 385 -133 439 -163 b 578 -97 526 -163 562 -142 b 588 -43 585 -80 588 -62 b 432 161 588 47 518 147 m 868 240 b 876 241 869 241 872 241 b 884 240 879 241 882 241 b 898 229 890 238 894 234 b 902 88 902 223 902 237 l 902 -1 l 902 -90 b 898 -231 902 -238 902 -224 b 876 -242 892 -238 884 -242 b 852 -224 865 -242 854 -235 b 850 2 850 -222 850 -108 b 852 223 850 112 850 220 b 868 240 853 230 860 237 "},"v54":{"x_min":-24.5,"x_max":317.140625,"ha":324,"o":"m -24 -161 l -24 -5 l -20 -5 b 0 -24 -9 -5 -2 -12 b 171 -315 21 -124 84 -233 b 317 -660 268 -406 317 -531 b 187 -1014 317 -782 274 -909 b 161 -1034 172 -1034 171 -1034 b 141 -1013 149 -1034 141 -1025 b 152 -991 141 -1004 142 -1002 b 266 -682 228 -899 266 -788 b 174 -430 266 -588 236 -498 b -23 -317 136 -388 66 -348 b -24 -161 -23 -316 -24 -285 "},"v55":{"x_min":0,"x_max":551.25,"ha":563,"o":"m 289 644 b 304 645 294 645 299 645 b 404 566 349 645 392 613 b 406 541 405 557 406 549 b 379 471 406 514 397 489 l 377 467 l 382 470 b 509 591 438 485 485 531 b 513 601 510 595 513 599 b 530 609 518 607 524 609 b 551 588 540 609 551 602 b 200 -605 551 584 204 -599 b 182 -616 197 -612 190 -616 b 163 -602 174 -616 166 -610 b 161 -598 161 -601 161 -601 b 217 -402 161 -589 170 -562 b 272 -213 247 -298 272 -213 b 272 -213 272 -213 272 -213 b 264 -219 272 -213 268 -216 b 140 -262 227 -247 182 -262 b 36 -226 102 -262 65 -249 b 0 -145 12 -206 0 -176 b 17 -84 0 -124 5 -104 b 103 -38 38 -54 70 -38 b 191 -91 137 -38 172 -56 b 205 -141 201 -106 205 -124 b 178 -212 205 -167 196 -194 l 175 -215 l 182 -213 b 307 -93 236 -198 284 -151 b 372 129 308 -88 372 127 b 372 129 372 129 372 129 b 364 122 372 129 368 126 b 240 80 328 94 283 80 b 137 115 202 80 166 91 b 99 195 112 136 99 165 b 118 256 99 217 106 238 b 204 303 138 287 171 303 b 292 249 238 303 273 285 b 306 199 302 234 306 217 b 279 129 306 173 296 148 l 276 126 l 281 127 b 408 248 336 142 385 190 b 473 470 409 254 473 469 b 473 470 473 470 473 470 b 465 464 473 470 469 467 b 341 421 428 435 383 421 b 236 458 303 421 266 433 b 200 537 212 478 200 508 b 289 644 200 585 234 635 "},"v58":{"x_min":-21.78125,"x_max":367.5,"ha":375,"o":"m 259 1553 b 265 1553 261 1553 264 1553 b 288 1540 272 1553 277 1550 b 367 1351 340 1493 367 1424 b 336 1221 367 1308 357 1263 l 332 1211 l 333 1208 b 367 1077 356 1170 367 1124 b 336 945 367 1032 357 986 l 332 935 l 333 932 b 367 800 356 893 367 848 b 336 669 367 756 357 710 l 332 659 l 333 656 b 367 523 356 617 367 571 b 345 412 367 485 360 446 b 231 273 322 356 284 310 b -1 19 121 195 27 93 b -17 4 -4 11 -10 5 l -21 4 l -21 134 l -21 265 l -17 265 b 133 291 20 265 96 278 b 318 537 245 328 318 433 b 307 603 318 559 315 582 b 303 614 304 612 304 614 b 298 609 302 614 300 613 b 231 549 281 589 258 567 b -1 295 121 471 27 369 b -17 280 -4 287 -10 281 l -21 280 l -21 410 l -21 541 l -17 541 b 133 567 20 541 96 555 b 318 813 245 605 318 709 b 307 880 318 835 315 859 b 303 891 304 888 304 891 b 298 885 302 891 300 888 b 231 825 281 866 258 843 b -1 571 121 748 27 645 b -17 556 -4 563 -10 557 l -21 556 l -21 687 l -21 817 l -17 817 b 133 843 20 817 96 830 b 318 1089 245 881 318 985 b 307 1156 318 1111 315 1134 b 303 1167 304 1164 304 1167 b 298 1161 302 1167 300 1164 b 231 1102 281 1140 258 1120 b -1 848 121 1024 27 921 b -17 832 -4 839 -10 834 l -21 832 l -21 963 l -21 1093 l -17 1093 b 114 1113 12 1093 78 1103 b 313 1314 215 1142 289 1218 b 318 1364 317 1331 318 1347 b 255 1511 318 1422 295 1478 b 243 1532 247 1519 243 1525 b 259 1553 243 1540 250 1550 "},"v59":{"x_min":0,"x_max":464.140625,"ha":474,"o":"m 0 0 l 0 347 l 76 347 l 153 347 l 153 0 l 153 -348 l 76 -348 l 0 -348 l 0 0 m 308 -1 l 308 347 l 386 347 l 464 347 l 464 -1 l 464 -348 l 386 -348 l 308 -348 l 308 -1 "},"v5a":{"x_min":-171.5,"x_max":170.140625,"ha":174,"o":"m -6 566 b 0 567 -5 567 -2 567 b 14 556 6 567 12 563 b 92 285 14 555 50 433 b 170 13 166 33 170 19 b 168 13 170 13 170 13 b 161 1 168 8 167 4 l 159 0 l 122 0 l 84 0 l 81 1 b 21 195 76 5 78 -5 b -32 381 -8 297 -32 381 b -87 197 -32 381 -57 298 b -141 8 -115 94 -140 9 b -155 0 -142 2 -149 0 b -171 15 -163 0 -171 5 b -14 556 -171 18 -24 528 b -6 566 -14 560 -10 564 "},"v5b":{"x_min":-441,"x_max":439.640625,"ha":449,"o":"m -428 -2 b -421 0 -427 -1 -424 0 b -406 -6 -416 0 -409 -2 b -400 -31 -401 -12 -400 -15 b -1 -352 -392 -215 -215 -352 b 58 -349 19 -352 38 -351 b 398 -31 250 -326 392 -192 b 404 -6 398 -15 400 -12 b 419 -1 408 -2 413 -1 b 439 -13 427 -1 435 -5 b 439 -29 439 -16 439 -22 b 434 -105 439 -48 438 -80 b 0 -489 397 -333 213 -489 b -68 -484 -23 -489 -44 -488 b -441 -36 -280 -452 -436 -263 b -441 -30 -441 -34 -441 -31 b -428 -2 -441 -11 -439 -5 m -13 -9 b -1 -8 -9 -8 -5 -8 b 50 -36 19 -8 39 -19 b 61 -72 57 -47 61 -59 b 50 -106 61 -84 57 -97 b -1 -134 39 -124 19 -134 b -46 -115 -17 -134 -34 -129 b -62 -72 -57 -102 -62 -87 b -13 -9 -62 -44 -44 -16 "},"v5c":{"x_min":0,"x_max":447.8125,"ha":457,"o":"m 0 -87 l 0 0 l 223 0 l 447 0 l 447 -87 l 447 -174 l 223 -174 l 0 -174 l 0 -87 "},"v5d":{"x_min":-1.359375,"x_max":592.078125,"ha":604,"o":"m 280 692 b 295 694 283 692 289 694 b 310 692 300 694 307 692 b 357 630 340 684 357 657 b 336 580 357 612 351 594 b 311 538 321 566 311 549 b 352 492 311 512 330 492 b 366 495 357 492 362 492 b 397 553 390 503 397 517 b 415 603 397 576 402 591 b 460 623 427 617 443 623 b 509 599 479 623 498 614 b 522 559 518 587 522 573 b 494 506 522 538 513 519 b 451 495 481 498 473 496 b 415 488 432 495 426 494 b 394 449 404 483 394 464 b 394 448 394 448 394 448 l 394 440 l 397 433 b 428 409 404 420 413 413 b 438 408 431 408 435 408 b 479 431 450 408 462 415 b 528 455 495 448 510 455 b 548 452 534 455 541 453 b 592 391 577 442 592 416 b 549 331 592 365 577 340 b 528 327 541 328 534 327 b 479 351 510 327 495 335 b 438 374 464 367 450 374 b 417 369 431 374 424 373 b 394 333 402 360 394 348 b 400 312 394 326 396 319 b 451 287 408 294 420 288 b 513 258 484 285 499 278 b 522 223 519 247 522 234 b 461 159 522 190 496 159 b 449 161 457 159 453 159 b 397 229 416 167 397 191 b 366 288 397 265 390 278 b 352 290 362 290 357 290 b 315 262 336 290 321 280 b 311 245 313 256 311 251 b 334 204 311 233 318 220 b 355 170 348 190 351 184 b 357 152 356 166 357 159 b 355 136 357 147 356 140 b 295 88 345 104 321 88 b 232 152 264 88 232 112 b 255 204 232 174 238 186 b 279 244 273 222 279 231 l 279 245 b 238 290 279 270 259 290 b 224 288 234 290 228 290 b 193 229 200 278 193 265 b 141 161 193 191 174 167 b 129 159 137 159 133 159 b 68 223 93 159 68 190 b 77 258 68 234 70 247 b 138 287 91 278 106 285 b 185 302 166 287 175 291 b 196 333 193 312 196 323 b 174 369 196 347 187 360 b 152 374 166 373 159 374 b 111 351 140 374 126 367 b 62 327 95 335 80 327 b 51 328 58 327 54 327 b -1 391 16 334 -1 363 b 53 455 -1 420 17 449 b 62 455 57 455 59 455 b 111 431 80 455 95 448 b 152 408 127 415 140 408 b 161 409 155 408 159 408 b 193 433 176 413 186 420 l 196 440 l 196 448 b 196 451 196 449 196 449 b 190 471 196 459 194 463 b 137 495 182 489 167 495 l 134 495 l 134 495 b 68 560 95 495 68 521 b 129 623 68 596 95 623 b 144 621 134 623 138 623 b 193 553 175 614 193 589 b 224 495 193 517 200 503 b 238 492 228 492 234 492 b 279 538 259 492 279 512 b 254 580 279 549 269 566 b 232 630 239 594 232 612 b 280 692 232 657 250 684 m 307 456 b 295 458 303 458 299 458 b 230 391 258 458 230 426 b 236 360 230 381 231 371 b 295 324 249 337 272 324 b 353 360 318 324 341 337 b 360 391 357 370 360 381 b 307 456 360 421 340 451 "},"v60":{"x_min":-590.71875,"x_max":589.359375,"ha":601,"o":"m -367 173 b -362 174 -366 174 -364 174 b -351 173 -357 174 -353 173 b -262 86 -348 172 -328 151 b -176 0 -216 37 -176 0 b -107 84 -176 0 -145 37 b -31 174 -36 173 -38 172 b -25 174 -29 174 -28 174 b -16 173 -23 174 -19 173 b 72 86 -13 172 6 151 b 157 0 119 37 157 0 b 227 84 159 0 189 37 b 303 174 298 173 296 172 b 308 174 304 174 307 174 b 318 173 313 174 317 173 b 481 11 322 172 357 134 l 494 -1 l 522 34 b 560 76 553 72 555 74 b 567 77 563 77 564 77 b 589 56 579 77 589 68 b 586 48 589 54 588 51 b 411 -172 583 41 416 -166 b 397 -176 406 -174 401 -176 b 387 -174 393 -176 390 -176 b 299 -87 386 -173 366 -152 b 213 0 253 -38 213 0 b 144 -86 213 0 182 -38 b 68 -174 73 -174 74 -173 b 62 -176 66 -176 65 -176 b 53 -174 59 -176 55 -174 b -35 -87 50 -173 29 -152 b -121 0 -83 -38 -121 0 b -190 -86 -122 0 -152 -38 b -266 -174 -261 -174 -259 -173 b -272 -176 -268 -176 -270 -176 b -281 -174 -276 -176 -280 -174 b -371 -86 -284 -173 -304 -152 b -457 0 -417 -38 -457 0 l -457 0 b -477 -26 -457 0 -470 -16 b -548 -227 -524 -88 -548 -161 b -536 -303 -548 -254 -544 -280 b -533 -317 -534 -309 -533 -313 b -553 -338 -533 -330 -541 -338 b -577 -315 -566 -338 -571 -333 b -590 -227 -586 -287 -590 -258 b -518 -9 -590 -154 -564 -77 b -465 56 -509 2 -504 8 l -402 134 b -367 173 -375 169 -372 172 "},"v62":{"x_min":46.28125,"x_max":669.671875,"ha":563,"o":"m 183 376 b 189 376 185 376 187 376 b 212 374 197 376 208 376 b 265 337 234 369 253 355 b 274 317 268 331 273 320 b 274 316 274 317 274 316 b 280 323 276 316 276 319 b 311 358 288 337 299 348 b 319 366 315 360 318 365 b 356 376 326 373 340 376 b 382 371 364 376 374 374 b 428 337 400 366 417 352 b 436 317 431 331 436 320 b 438 316 436 317 436 316 b 442 323 438 316 439 319 b 475 358 451 337 462 348 b 483 366 477 360 481 365 b 518 376 488 373 503 376 b 544 373 528 376 536 376 b 604 285 579 360 604 326 b 597 249 604 273 601 258 b 543 63 596 247 544 70 b 541 54 543 61 541 55 b 540 44 540 51 540 47 b 552 23 540 33 545 23 b 552 23 552 23 552 23 b 647 126 586 29 627 72 b 658 138 651 136 653 138 b 660 138 660 138 660 138 b 669 129 666 137 669 136 b 654 88 669 122 665 109 b 562 -12 631 43 602 9 l 549 -19 b 521 -27 540 -24 530 -27 b 447 30 490 -27 458 -4 b 443 58 445 38 443 48 b 450 93 443 72 446 84 b 504 278 453 97 504 272 b 507 288 506 283 506 287 b 509 298 507 292 509 295 b 491 326 509 310 502 320 b 487 327 490 327 488 327 b 479 324 484 327 483 326 b 441 270 462 316 443 288 b 435 249 441 265 436 254 b 398 127 434 248 419 195 b 362 4 379 61 362 5 b 328 -1 359 -1 362 -1 b 314 -1 323 -1 319 -1 b 302 -1 310 -1 306 -1 b 266 4 266 -1 269 -1 b 265 6 265 5 265 5 b 303 144 265 13 272 34 b 343 278 325 216 343 276 b 344 288 343 281 344 285 b 345 298 345 291 345 295 b 330 326 345 310 340 320 b 323 327 328 327 325 327 b 317 324 322 327 321 326 b 279 270 300 316 281 288 b 273 249 279 265 274 254 b 236 127 272 248 255 195 b 200 4 216 61 200 5 b 164 -1 197 -1 198 -1 b 151 -1 161 -1 156 -1 b 140 -1 147 -1 142 -1 b 103 4 104 -1 106 -1 b 103 6 103 5 103 5 b 141 144 103 13 108 34 b 181 278 161 216 179 276 b 182 288 181 281 181 285 b 183 298 182 291 183 295 b 168 324 183 310 178 320 b 160 327 166 326 163 327 b 141 320 156 327 151 324 b 69 230 112 305 85 272 b 57 215 65 217 62 215 b 55 215 57 215 55 215 b 46 224 49 215 46 217 b 59 260 46 231 50 242 b 151 363 81 306 112 341 b 161 369 155 365 160 367 b 183 376 166 371 174 374 "},"v68":{"x_min":-597.53125,"x_max":596.171875,"ha":608,"o":"m -533 324 b -525 327 -530 326 -528 327 b -504 305 -514 327 -504 317 b -504 305 -504 305 -504 305 b -513 284 -504 299 -504 299 b -556 112 -541 226 -556 167 b -545 33 -556 84 -552 58 b -524 -20 -541 15 -532 -9 l -522 -23 l -491 15 l -413 111 b -355 174 -367 169 -363 174 b -351 174 -353 174 -352 174 b -254 86 -343 174 -348 179 b -168 -1 -208 37 -168 -1 b -100 84 -168 -1 -137 37 b -23 173 -28 173 -29 172 b -19 174 -21 174 -20 174 b -8 173 -14 174 -10 173 b 155 11 -5 172 43 123 l 166 -1 l 168 1 l 170 4 l 170 130 b 171 260 170 256 170 258 b 191 274 175 269 183 274 b 205 267 196 274 201 272 b 212 158 212 262 210 273 l 212 56 l 257 112 b 311 173 304 172 304 172 b 317 174 313 174 314 174 b 326 173 319 174 323 173 b 490 11 329 172 366 134 l 502 -1 l 530 34 b 568 76 560 72 563 74 b 575 77 570 77 573 77 b 596 56 586 77 596 68 b 594 48 596 54 596 51 b 417 -172 592 41 424 -166 b 405 -176 415 -174 409 -176 b 396 -174 401 -176 398 -176 b 307 -87 393 -173 372 -152 b 221 -1 259 -38 221 -1 b 216 -6 221 -1 219 -2 l 212 -12 l 212 -147 b 212 -210 212 -173 212 -194 b 205 -292 212 -297 210 -287 b 191 -299 201 -297 196 -299 b 172 -287 183 -299 175 -295 b 170 -174 171 -284 171 -284 l 170 -63 l 127 -117 b 73 -176 84 -170 80 -176 b 68 -176 72 -176 70 -176 b -27 -87 59 -174 65 -180 b -114 0 -74 -38 -112 0 b -182 -86 -114 0 -145 -38 b -258 -174 -253 -174 -253 -173 b -264 -176 -259 -176 -262 -176 b -274 -174 -268 -176 -272 -174 b -438 -11 -277 -173 -348 -102 l -449 0 l -479 -37 b -524 -80 -513 -80 -514 -80 l -524 -80 b -553 -52 -534 -80 -540 -74 b -597 109 -583 -8 -597 48 b -560 280 -597 165 -585 224 b -533 324 -548 310 -540 322 "},"v6c":{"x_min":-1.359375,"x_max":193.28125,"ha":197,"o":"m 78 233 b 87 233 81 233 84 233 b 187 140 132 233 174 195 b 193 102 190 127 193 115 b 43 -113 193 22 136 -62 b 27 -119 36 -116 31 -119 b 19 -108 21 -119 19 -115 b 29 -97 19 -102 20 -101 b 102 13 73 -72 102 -27 b 92 51 102 26 98 40 l 91 54 l 84 54 b 8 104 53 54 21 74 b -1 142 1 116 -1 130 b 78 233 -1 187 31 227 "},"v6d":{"x_min":-590.71875,"x_max":589.359375,"ha":601,"o":"m 544 335 b 553 337 548 337 551 337 b 575 313 563 337 570 330 b 589 226 583 285 589 256 b 517 8 589 152 563 76 b 464 -58 507 -4 503 -9 l 401 -136 b 362 -176 372 -172 370 -176 b 357 -176 360 -176 359 -176 b 261 -87 349 -174 355 -180 b 175 0 215 -38 175 0 b 106 -86 175 0 144 -38 b 29 -174 35 -174 36 -173 b 24 -176 28 -176 27 -176 b 14 -174 21 -176 17 -174 b -73 -87 12 -173 -8 -152 b -159 0 -121 -38 -159 0 b -228 -86 -160 0 -190 -38 b -304 -174 -299 -174 -298 -173 b -310 -176 -306 -176 -308 -176 b -319 -174 -314 -176 -318 -174 b -483 -12 -323 -173 -359 -137 l -495 0 l -524 -34 b -562 -77 -553 -73 -556 -76 b -568 -79 -564 -79 -566 -79 b -590 -58 -581 -79 -590 -69 b -588 -49 -590 -55 -589 -52 b -412 170 -585 -43 -417 165 b -398 174 -408 173 -402 174 b -389 173 -394 174 -392 174 b -300 86 -387 172 -366 151 b -215 -1 -254 37 -215 -1 b -145 84 -215 -1 -183 37 b -69 173 -74 173 -76 172 b -63 174 -68 174 -66 174 b -54 173 -61 174 -57 173 b 34 86 -51 172 -31 151 b 119 -1 81 37 119 -1 b 189 84 121 -1 151 37 b 265 173 259 173 258 172 b 270 174 266 174 269 174 b 280 173 274 174 279 173 b 370 84 283 172 303 151 b 455 -1 416 37 455 -1 l 455 -1 b 476 24 455 -1 469 15 b 547 226 522 87 547 159 b 534 302 547 252 543 278 b 532 317 533 308 532 313 b 544 335 532 326 536 333 "},"v6f":{"x_min":-80.3125,"x_max":78.9375,"ha":81,"o":"m 63 191 b 69 192 65 192 66 192 b 77 188 72 192 76 191 b 78 183 78 187 78 186 b 74 158 78 179 77 172 l 66 115 b 9 -161 49 30 10 -158 b -10 -187 6 -172 -1 -181 b -34 -194 -17 -191 -25 -194 b -80 -147 -58 -194 -80 -174 b -80 -141 -80 -144 -80 -142 b 9 70 -80 -134 -73 -117 l 49 163 b 63 191 59 188 61 190 "},"v70":{"x_min":0,"x_max":436.921875,"ha":446,"o":"m 213 190 b 217 191 215 191 216 191 b 231 184 223 191 228 188 b 249 154 240 167 246 159 b 419 18 292 91 348 45 b 436 -1 435 11 436 8 b 424 -16 436 -9 434 -13 b 308 -87 394 -26 340 -59 b 231 -186 276 -117 257 -142 b 219 -192 228 -191 225 -192 b 198 -174 209 -192 208 -191 b 47 -33 161 -113 110 -63 b 10 -16 34 -26 17 -19 b 0 -1 2 -13 0 -9 b 17 18 0 8 1 11 b 198 173 95 48 156 101 b 213 190 206 187 208 188 "},"v72":{"x_min":-423.3125,"x_max":421.9375,"ha":431,"o":"m -262 197 b -247 197 -257 197 -253 197 b -118 162 -210 197 -163 184 b 40 45 -61 134 -13 98 b 277 -95 119 -33 200 -81 b 289 -97 281 -97 285 -97 b 378 0 332 -97 371 -55 b 378 11 378 4 378 6 b 302 83 378 55 345 83 b 242 66 283 83 262 77 b 208 56 231 59 219 56 b 148 120 175 56 148 81 b 201 186 148 151 164 172 b 261 198 220 194 240 198 b 420 45 341 198 411 136 b 421 22 421 37 421 29 b 245 -199 421 -93 338 -199 b 238 -198 243 -199 240 -199 b -44 -47 148 -194 50 -141 b -250 86 -114 22 -183 66 b -295 94 -270 91 -283 94 b -315 91 -302 94 -307 94 b -381 4 -356 81 -381 43 b -355 -56 -381 -18 -372 -40 b -298 -81 -338 -73 -319 -81 b -246 -68 -283 -81 -265 -77 b -212 -58 -234 -61 -223 -58 b -178 -69 -200 -58 -189 -62 b -151 -122 -160 -81 -151 -101 b -171 -167 -151 -138 -157 -155 b -239 -195 -185 -181 -213 -192 b -257 -197 -245 -197 -250 -197 b -423 -5 -352 -197 -423 -109 b -412 65 -423 16 -419 40 b -262 197 -389 137 -329 188 "},"v74":{"x_min":-206.890625,"x_max":428.75,"ha":438,"o":"m 389 -351 b 394 -351 390 -351 393 -351 b 428 -385 413 -351 428 -367 b 428 -394 428 -388 428 -391 b 394 -428 426 -406 421 -410 l 332 -473 l 269 -516 l 205 -560 l 141 -603 l 77 -648 l 13 -692 l -50 -737 l -114 -780 l -145 -802 b -171 -813 -157 -810 -163 -813 b -175 -813 -172 -813 -174 -813 b -206 -777 -194 -811 -206 -795 b -202 -760 -206 -771 -205 -766 b -87 -675 -197 -752 -206 -757 l -34 -639 l 83 -557 l 145 -514 l 209 -470 l 272 -427 b 389 -351 375 -356 381 -352 "},"v75":{"x_min":-149.71875,"x_max":148.359375,"ha":151,"o":"m -137 381 b -130 383 -134 383 -133 383 b -111 371 -122 383 -114 378 b -55 224 -110 370 -85 305 b 0 80 -25 145 -1 80 b 54 224 0 80 24 145 b 112 377 114 384 110 373 b 127 384 118 381 122 384 b 148 362 138 384 148 374 l 148 356 l 83 183 b 16 9 47 88 17 11 b -1 0 12 2 5 0 b -14 5 -5 0 -10 1 b -84 183 -19 9 -13 -6 l -149 356 l -149 362 b -137 381 -149 371 -145 378 "},"v78":{"x_min":0,"x_max":193.28125,"ha":197,"o":"m 85 514 b 95 517 88 517 89 517 b 114 505 103 517 110 513 l 115 502 l 115 376 b 115 249 115 306 115 249 b 141 258 117 249 127 252 l 167 266 l 172 266 b 190 254 181 265 187 262 l 193 251 l 193 202 l 193 188 b 187 147 193 149 191 152 b 147 130 183 142 182 141 l 115 119 l 115 9 b 115 -99 115 -51 115 -99 b 141 -91 115 -99 127 -95 b 171 -81 166 -81 167 -81 l 171 -81 b 191 -94 181 -81 189 -87 b 193 -142 191 -97 193 -120 b 191 -195 193 -167 191 -194 b 125 -227 187 -205 187 -204 l 115 -230 l 115 -366 l 115 -503 l 114 -506 b 95 -519 110 -514 102 -519 b 74 -506 87 -519 78 -514 l 73 -503 l 73 -374 b 73 -245 73 -260 73 -245 b 73 -245 73 -245 73 -245 b 55 -252 72 -245 63 -249 l 32 -260 b 19 -263 27 -262 23 -263 b 4 -256 13 -263 8 -260 b 0 -215 0 -251 0 -254 b 0 -199 0 -210 0 -206 l 0 -152 l 1 -149 b 8 -140 2 -145 5 -141 b 42 -127 9 -140 24 -133 l 73 -116 l 73 -5 b 73 23 73 4 73 15 b 73 105 73 70 73 105 b 49 97 73 105 61 101 b 17 88 32 91 23 88 b 4 95 10 88 8 91 b 0 137 0 101 0 98 b 0 151 0 141 0 145 l 0 199 l 1 202 b 43 224 5 212 5 212 l 73 234 l 73 367 l 73 502 l 74 505 b 85 514 77 509 81 513 "},"v79":{"x_min":-1.359375,"x_max":899.703125,"ha":918,"o":"m 307 349 b 332 351 315 351 323 351 b 443 340 367 351 408 347 b 741 47 607 306 720 195 b 744 0 743 31 744 16 b 660 -303 744 -90 713 -206 b 28 -755 534 -531 304 -695 b 14 -756 23 -755 19 -756 b -1 -741 4 -756 -1 -750 b 21 -720 -1 -731 1 -728 b 567 -56 337 -601 548 -344 b 568 -11 568 -41 568 -24 b 442 285 568 129 525 233 b 325 319 406 308 367 319 b 93 177 232 319 137 266 b 84 154 91 170 84 155 b 84 154 84 154 84 154 b 88 156 84 154 85 155 b 159 177 110 170 134 177 b 257 134 194 177 231 162 b 294 41 281 108 294 73 b 171 -97 294 -24 246 -90 b 156 -98 166 -97 161 -98 b 6 74 73 -98 6 -22 b 6 80 6 76 6 79 b 307 349 10 223 141 340 m 839 215 b 845 216 841 216 842 216 b 862 213 852 216 860 215 b 899 163 887 206 899 184 b 872 117 899 145 890 127 b 847 111 865 112 856 111 b 808 130 833 111 818 117 b 796 162 800 140 796 151 b 839 215 796 187 812 212 m 839 -112 b 845 -112 841 -112 842 -112 b 862 -115 852 -112 860 -113 b 899 -165 887 -122 899 -144 b 872 -210 899 -183 890 -201 b 847 -217 865 -215 856 -217 b 808 -198 833 -217 818 -210 b 796 -165 800 -188 796 -177 b 839 -112 796 -140 812 -116 "},"v7c":{"x_min":0,"x_max":300.8125,"ha":307,"o":"m 49 505 b 53 506 50 505 51 506 b 70 496 58 506 62 503 b 81 485 73 492 78 488 l 96 473 l 111 459 l 122 449 l 134 438 l 182 396 l 255 330 b 292 291 292 298 292 298 l 292 290 l 292 284 l 283 270 b 209 36 234 197 209 113 b 288 -170 209 -44 235 -119 b 299 -184 295 -179 299 -181 b 300 -191 300 -187 300 -188 b 285 -206 300 -199 294 -206 b 280 -206 283 -206 281 -206 b 247 -201 270 -202 259 -201 b 176 -222 223 -201 197 -208 b 114 -340 136 -249 114 -292 b 172 -471 114 -384 134 -433 b 185 -492 182 -481 185 -487 b 181 -502 185 -496 183 -499 b 171 -508 176 -505 174 -508 b 152 -498 166 -508 160 -503 b 0 -284 65 -428 12 -352 b 0 -260 0 -278 0 -270 b 1 -238 0 -252 0 -242 b 148 -140 16 -177 73 -140 b 209 -148 167 -140 189 -142 b 215 -149 212 -148 215 -149 b 215 -149 215 -149 215 -149 l 215 -149 b 201 -136 215 -148 209 -142 l 157 -97 l 96 -41 b 17 34 21 24 17 29 b 17 37 17 36 17 36 b 17 38 17 37 17 38 b 25 56 17 44 17 44 b 110 298 81 131 110 219 b 46 474 110 367 88 431 b 38 491 40 480 38 487 b 49 505 38 498 42 502 "},"v7d":{"x_min":-1.359375,"x_max":436.921875,"ha":446,"o":"m 213 205 b 217 205 215 205 216 205 b 234 194 224 205 234 199 b 236 187 234 194 235 190 l 245 167 l 261 129 l 270 106 b 355 -61 294 54 329 -13 b 420 -163 381 -105 402 -138 b 436 -188 435 -184 436 -184 b 436 -191 436 -190 436 -190 b 421 -206 436 -201 431 -206 l 421 -206 l 416 -206 l 405 -201 b 217 -158 347 -172 283 -158 b 31 -201 153 -158 88 -172 l 20 -206 l 14 -206 l 14 -206 b 0 -191 5 -206 0 -201 b -1 -188 0 -190 -1 -190 b 14 -163 -1 -186 0 -184 b 95 -34 36 -136 72 -77 b 166 106 119 8 148 68 l 175 129 l 183 148 l 200 188 b 213 205 205 199 208 202 "},"v7f":{"x_min":0,"x_max":367.5,"ha":375,"o":"m 0 124 l 0 187 l 61 187 l 122 187 l 122 138 l 122 91 l 153 61 l 183 30 l 213 61 l 243 91 l 243 138 l 243 187 l 306 187 l 367 187 l 367 124 l 367 61 l 321 61 l 274 61 l 243 30 l 213 0 l 243 -31 l 274 -62 l 321 -62 l 367 -62 l 367 -124 l 367 -188 l 306 -188 l 243 -188 l 243 -140 l 243 -93 l 213 -62 l 183 -31 l 153 -62 l 122 -93 l 122 -140 l 122 -188 l 61 -188 l 0 -188 l 0 -124 l 0 -62 l 46 -62 l 92 -62 l 123 -31 l 153 0 l 123 30 l 92 61 l 46 61 l 0 61 l 0 124 "},"v80":{"x_min":29.9375,"x_max":420.578125,"ha":371,"o":"m 115 345 b 221 347 117 345 166 347 b 411 345 306 347 409 345 b 420 330 416 342 420 335 b 415 319 420 326 419 321 b 178 118 397 303 179 118 b 178 117 178 118 178 117 b 181 117 178 117 178 117 b 189 117 182 117 185 117 b 193 117 190 117 191 117 b 247 98 215 117 232 111 b 296 75 266 83 280 76 b 302 75 299 75 300 75 b 322 91 311 75 315 79 b 322 91 322 91 322 91 b 322 91 322 91 322 91 b 319 91 322 91 321 91 b 313 90 318 90 315 90 b 283 107 300 90 288 97 b 277 126 279 114 277 121 b 319 167 277 149 295 167 b 319 167 319 167 319 167 b 362 118 347 167 362 147 b 355 82 362 108 359 96 b 311 33 349 65 340 55 b 224 1 284 12 253 1 b 194 5 213 1 204 2 b 168 18 183 8 178 11 b 110 36 151 30 130 36 b 57 15 88 36 68 29 b 47 11 54 12 51 11 b 31 20 40 11 34 13 b 29 26 31 22 29 25 b 68 66 29 36 39 45 b 285 250 73 71 281 248 b 285 250 285 250 285 250 b 231 252 285 252 261 252 b 137 250 190 252 141 250 b 93 227 122 248 110 241 b 78 220 88 222 83 220 b 66 227 74 220 70 222 b 63 234 65 229 63 231 b 85 291 63 241 69 252 b 115 345 108 342 108 344 "},"v81":{"x_min":0,"x_max":428.75,"ha":438,"o":"m 262 186 b 273 186 266 186 272 186 b 274 186 273 186 274 186 b 285 186 274 186 280 186 b 428 48 375 181 428 122 b 386 -68 428 12 416 -29 b 155 -187 329 -145 236 -187 b 12 -111 92 -187 38 -162 b 0 -51 4 -91 0 -72 b 262 186 0 58 122 179 m 366 131 b 352 134 362 133 357 134 b 219 81 321 134 269 115 b 47 -111 126 23 50 -62 b 47 -112 47 -111 47 -112 b 77 -136 47 -129 58 -136 b 264 -45 118 -136 194 -101 b 382 109 336 12 382 76 b 366 131 382 120 377 129 "},"v83":{"x_min":-1.359375,"x_max":847.96875,"ha":865,"o":"m 488 1499 b 495 1500 490 1500 492 1500 b 541 1465 507 1500 521 1490 b 679 1078 622 1372 679 1210 b 677 1050 679 1068 677 1060 b 477 642 668 893 604 764 l 443 609 l 431 596 l 431 592 l 438 562 l 449 508 l 460 458 b 481 355 475 390 481 355 b 481 355 481 355 481 355 b 490 356 481 355 485 355 b 528 358 495 356 511 358 b 558 356 540 358 552 356 b 839 95 699 338 808 237 b 847 22 845 72 847 47 b 631 -303 847 -113 766 -242 b 620 -309 623 -308 620 -309 l 620 -310 b 631 -359 620 -310 626 -333 l 646 -435 l 660 -496 b 672 -588 668 -535 672 -563 b 664 -653 672 -610 669 -630 b 383 -875 630 -792 509 -875 b 201 -810 321 -875 257 -855 b 129 -680 151 -768 129 -730 b 274 -530 129 -592 200 -530 b 351 -553 300 -530 326 -538 b 412 -669 393 -582 412 -626 b 287 -805 412 -735 366 -800 l 279 -805 l 285 -809 b 383 -830 318 -823 351 -830 b 586 -718 464 -830 540 -789 b 626 -584 612 -678 626 -631 b 619 -528 626 -566 623 -548 b 612 -495 619 -526 616 -510 b 577 -324 590 -387 577 -324 b 577 -324 577 -324 577 -324 b 568 -326 575 -324 571 -324 b 528 -334 558 -328 537 -333 b 465 -338 506 -337 485 -338 b 24 -11 269 -338 87 -206 b -1 145 8 41 -1 93 b 96 442 -1 249 32 351 b 322 714 166 541 236 626 l 352 745 l 345 782 l 332 843 l 315 921 b 303 984 310 950 304 978 b 295 1082 298 1017 295 1049 b 413 1426 295 1208 336 1329 b 488 1499 436 1456 477 1496 m 549 1301 b 541 1301 547 1301 544 1301 b 411 1207 500 1301 447 1263 b 355 1004 374 1152 355 1079 b 359 942 355 984 356 963 b 371 881 362 927 363 917 l 385 818 b 392 782 389 799 392 784 l 392 782 b 434 828 393 782 424 816 b 607 1165 534 941 594 1060 b 608 1193 608 1175 608 1183 b 597 1270 608 1224 604 1254 b 549 1301 589 1286 571 1299 m 398 528 b 393 555 396 542 393 553 b 392 555 393 555 393 555 b 317 470 390 555 347 505 b 190 298 266 408 212 334 b 127 70 148 227 127 148 b 155 -77 127 19 137 -30 b 468 -303 209 -216 333 -303 b 519 -299 484 -303 502 -302 b 568 -284 541 -295 568 -287 l 568 -284 b 563 -263 568 -284 566 -274 l 534 -120 l 511 -13 l 496 61 l 480 133 b 469 187 472 176 469 187 b 468 188 469 187 469 188 b 416 162 462 188 430 172 b 337 13 364 126 337 69 b 413 -124 337 -40 363 -93 b 428 -144 424 -131 428 -137 b 428 -149 428 -145 428 -148 b 409 -166 426 -161 419 -166 b 394 -162 405 -166 400 -165 b 240 77 302 -122 240 -27 l 240 77 b 430 342 240 197 315 301 l 436 344 l 426 394 l 398 528 m 548 194 b 526 195 540 195 532 195 b 519 195 524 195 521 195 l 514 195 l 518 177 l 539 79 l 552 15 l 566 -48 l 594 -187 l 605 -240 b 612 -266 609 -254 611 -266 b 612 -266 612 -266 612 -266 b 641 -248 613 -266 630 -256 b 744 -98 692 -212 730 -156 b 751 -40 749 -79 751 -59 b 548 194 751 76 665 181 "},"v84":{"x_min":25.859375,"x_max":164.6875,"ha":168,"o":"m 34 369 b 40 370 35 370 38 370 b 59 353 49 370 50 367 b 164 40 122 254 155 158 b 164 0 164 33 164 16 b 164 -40 164 -16 164 -34 b 59 -353 155 -158 122 -254 b 40 -371 53 -366 47 -371 b 34 -370 38 -371 36 -370 b 25 -358 28 -367 25 -363 b 31 -337 25 -352 27 -347 b 92 0 72 -234 92 -117 b 31 335 92 116 72 233 b 25 356 27 345 25 352 b 34 369 25 363 28 366 "},"v86":{"x_min":-571.671875,"x_max":570.3125,"ha":582,"o":"m -386 173 b -381 174 -385 174 -383 174 b -370 173 -377 174 -372 173 b -281 86 -367 172 -347 151 b -196 0 -235 37 -196 0 b -126 84 -196 0 -164 37 b -50 174 -55 173 -57 172 b -44 174 -49 174 -47 174 b -35 173 -42 174 -38 173 b 53 86 -32 172 -12 151 b 138 0 100 37 138 0 b 208 84 140 0 170 37 b 284 174 279 173 277 172 b 289 174 285 174 288 174 b 299 173 294 174 298 173 b 462 11 303 172 338 134 l 475 -1 l 503 34 b 541 76 534 72 536 74 b 548 77 544 77 545 77 b 570 56 560 77 570 68 b 567 48 570 54 568 51 b 392 -172 564 41 397 -166 b 378 -176 387 -174 382 -176 b 368 -174 374 -176 371 -176 b 280 -87 367 -173 345 -152 b 194 0 234 -38 194 0 b 125 -86 194 0 163 -38 b 49 -174 54 -174 55 -173 b 43 -176 47 -176 46 -176 b 34 -174 40 -176 36 -174 b -54 -87 31 -173 10 -152 b -140 0 -102 -38 -140 0 b -209 -86 -141 0 -171 -38 b -285 -174 -280 -174 -279 -173 b -291 -176 -287 -176 -289 -176 b -300 -174 -295 -176 -299 -174 b -464 -12 -304 -173 -340 -137 l -476 0 l -504 -34 b -543 -77 -534 -73 -537 -76 b -549 -79 -545 -79 -547 -79 b -571 -58 -562 -79 -571 -69 b -568 -49 -571 -55 -570 -52 b -392 172 -566 -43 -396 167 b -386 173 -390 172 -387 173 "},"v8a":{"x_min":-170.140625,"x_max":168.78125,"ha":172,"o":"m -160 567 b -122 567 -159 567 -149 567 l -87 567 l -84 566 b -74 553 -78 563 -77 560 b -20 366 -73 551 -49 466 b 31 186 8 267 31 186 b 85 371 31 186 55 269 b 140 559 114 473 138 557 b 153 567 141 564 148 567 b 168 559 159 567 166 564 b 168 555 168 557 168 557 b 92 281 168 548 159 513 b 14 13 50 134 14 13 b 0 0 14 6 6 0 b -17 15 -8 0 -17 8 b -93 283 -17 15 -51 136 b -170 552 -166 533 -170 548 b -170 553 -170 552 -170 552 b -160 567 -170 560 -167 564 "},"v8b":{"x_min":0,"x_max":319.859375,"ha":326,"o":"m 149 508 b 159 509 152 509 155 509 b 186 494 170 509 181 503 b 190 440 190 487 190 488 l 190 430 l 190 377 l 242 377 l 251 377 b 303 373 298 377 296 377 b 319 345 314 367 319 356 b 304 319 319 335 314 324 b 250 315 296 315 299 315 l 242 315 l 190 315 l 190 262 l 190 252 b 186 198 190 204 190 205 b 159 183 179 188 170 183 b 132 198 148 183 138 188 b 127 252 127 205 127 204 l 127 262 l 127 315 l 76 315 l 68 315 b 14 319 20 315 21 315 b 0 347 4 324 0 335 b 14 373 0 356 4 367 b 68 377 21 377 20 377 l 76 377 l 127 377 l 127 430 l 127 440 b 132 494 127 488 127 487 b 149 508 136 501 142 505 "},"v8c":{"x_min":-330.75,"x_max":329.390625,"ha":336,"o":"m -133 483 b -117 484 -127 484 -122 484 b 31 373 -51 484 9 440 b 35 348 34 365 35 356 b -25 285 35 313 10 285 b -87 331 -55 285 -76 302 b -167 402 -100 376 -133 402 b -191 398 -175 402 -183 401 b -227 341 -215 388 -227 369 b -225 320 -227 334 -227 327 b -13 74 -209 230 -125 133 b 6 65 -4 70 5 66 l 9 63 l 10 65 b 117 231 12 68 40 112 l 189 341 l 242 424 b 268 460 262 456 264 458 b 283 464 273 463 277 464 b 308 438 296 464 308 453 l 308 437 b 287 396 308 430 308 428 l 95 98 l 59 43 l 58 41 l 65 37 b 253 -156 151 -8 217 -77 b 281 -285 272 -199 281 -244 b 148 -481 281 -381 231 -463 b 115 -485 137 -484 126 -485 b -32 -376 51 -485 -9 -442 b -36 -349 -35 -366 -36 -358 b 25 -287 -36 -315 -12 -287 b 85 -333 54 -287 74 -302 b 166 -403 99 -377 133 -403 b 190 -399 174 -403 182 -402 b 225 -342 215 -390 225 -370 b 224 -322 225 -335 225 -328 b 12 -76 208 -231 125 -134 b -8 -66 2 -72 -6 -68 l -10 -65 l -12 -66 b -118 -231 -13 -68 -42 -113 l -190 -342 l -243 -426 b -269 -462 -264 -458 -265 -458 b -284 -466 -274 -464 -279 -466 b -310 -440 -298 -466 -310 -455 l -310 -438 b -288 -398 -310 -430 -308 -430 l -96 -99 l -59 -44 l -59 -43 l -66 -38 b -281 284 -198 33 -281 158 l -281 284 b -133 483 -281 392 -220 474 m 254 177 b 266 179 258 177 262 179 b 319 149 287 179 307 167 b 329 115 326 140 329 127 b 319 79 329 102 326 90 b 268 51 307 61 287 51 b 221 72 250 51 234 58 b 205 115 210 84 205 99 b 254 177 205 142 223 170 m -281 -54 b -269 -52 -277 -52 -273 -52 b -223 -73 -253 -52 -235 -59 b -206 -116 -212 -84 -206 -101 b -216 -151 -206 -129 -209 -141 b -269 -179 -228 -170 -249 -179 b -314 -159 -285 -179 -302 -173 b -330 -116 -325 -147 -330 -131 b -281 -54 -330 -88 -313 -61 "},"v8f":{"x_min":-21.78125,"x_max":362.0625,"ha":369,"o":"m 302 1031 b 308 1032 304 1032 307 1032 b 330 1016 318 1032 325 1027 b 362 867 351 970 362 920 b 340 738 362 824 353 780 l 336 727 l 340 717 b 362 591 355 677 362 634 b 257 323 362 496 325 401 b 204 272 243 306 227 290 b 20 56 129 206 66 133 b -1 18 12 44 0 22 b -19 4 -4 9 -12 4 l -21 4 l -21 140 l -21 276 l -12 277 b 167 333 61 288 127 309 b 319 598 262 388 319 491 b 311 664 319 620 317 642 l 310 673 l 304 664 b 204 548 279 620 250 587 b 20 333 129 483 66 409 b -1 292 12 320 0 298 b -19 280 -4 285 -12 280 l -21 280 l -21 416 l -21 552 l -12 553 b 167 609 61 564 127 585 b 319 874 264 666 319 770 b 294 992 319 914 311 954 b 288 1011 288 1004 288 1007 b 302 1031 288 1021 294 1028 "},"v90":{"x_min":-171.5,"x_max":483.1875,"ha":493,"o":"m -8 631 b -1 632 -6 632 -4 632 b 19 620 8 632 16 628 b 20 495 20 616 20 616 b 20 373 20 427 20 373 b 115 410 20 373 63 390 l 210 448 l 210 531 b 212 620 210 614 210 616 b 231 632 215 628 223 632 b 246 627 236 632 242 631 b 251 541 251 620 251 628 l 251 463 l 315 489 b 387 514 368 509 381 514 b 393 513 390 514 392 514 b 406 494 402 510 406 502 b 397 476 406 487 404 480 b 323 446 396 474 363 462 l 251 417 l 251 283 l 251 148 l 254 151 b 370 199 291 183 332 199 b 415 191 385 199 400 197 b 483 84 458 176 483 134 b 461 0 483 58 476 29 b 332 -142 439 -40 411 -72 l 255 -215 b 231 -229 240 -229 239 -229 b 216 -223 224 -229 220 -227 b 210 -158 210 -217 210 -223 b 210 -120 210 -148 210 -136 l 210 -29 l 205 -34 b 100 -142 182 -65 159 -88 l 23 -215 b -1 -229 9 -229 6 -229 b -19 -217 -9 -229 -16 -224 l -20 -215 l -21 48 l -21 310 l -83 287 b -152 262 -133 266 -145 262 b -157 263 -153 262 -155 262 b -171 283 -166 266 -171 274 b -161 301 -171 290 -167 297 b -91 328 -160 302 -129 315 l -21 356 l -21 487 l -20 617 l -19 621 b -8 631 -17 626 -12 630 m 210 288 b 210 401 210 351 210 401 b 114 365 209 401 167 384 l 20 327 l 20 238 l 20 148 l 21 151 b 140 199 59 183 102 199 b 206 180 164 199 187 192 l 209 177 b 209 177 209 177 209 177 b 210 288 210 177 210 199 m 110 131 b 96 133 106 133 100 133 b 89 133 93 133 91 133 b 24 87 63 129 40 113 l 20 80 l 20 -37 l 20 -156 l 23 -152 b 144 81 96 -72 144 20 l 144 83 b 110 131 144 113 134 126 m 341 131 b 328 133 337 133 332 133 b 322 133 326 133 323 133 b 257 87 296 129 273 113 l 251 80 l 251 -37 l 251 -156 l 255 -152 b 375 81 328 -72 375 20 l 375 83 b 341 131 375 113 367 126 "},"v92":{"x_min":0,"x_max":598.890625,"ha":611,"o":"m 62 181 b 77 183 66 183 72 183 b 91 181 83 183 88 183 b 202 131 100 180 106 177 l 299 87 l 394 131 b 517 183 499 181 502 183 b 519 183 517 183 518 183 b 598 104 567 183 598 144 b 577 49 598 84 592 65 b 518 15 567 38 563 37 b 484 0 499 6 484 0 b 518 -16 484 -1 499 -8 b 577 -51 563 -38 567 -40 b 598 -105 592 -66 598 -86 b 519 -184 598 -145 567 -184 b 517 -184 518 -184 517 -184 b 394 -133 502 -184 499 -183 l 299 -88 l 202 -133 b 81 -184 99 -183 95 -184 b 77 -184 80 -184 78 -184 b 0 -105 29 -184 0 -145 b 20 -51 0 -86 5 -66 b 80 -16 29 -40 34 -38 b 114 -1 98 -8 114 -1 b 80 15 114 0 98 6 b 20 49 34 37 29 38 b 0 104 6 65 0 84 b 62 181 0 140 23 174 m 88 134 b 74 136 85 134 80 136 b 68 134 72 136 69 136 b 46 104 54 130 46 117 b 55 81 46 95 49 88 b 149 34 59 76 53 80 b 224 -1 190 15 224 0 b 144 -38 224 -1 187 -18 b 54 -84 59 -79 58 -79 b 46 -105 49 -90 46 -98 b 76 -137 46 -122 58 -137 b 78 -137 77 -137 77 -137 b 194 -86 87 -137 76 -141 b 298 -36 250 -58 298 -36 b 298 -36 298 -36 298 -36 b 402 -84 299 -36 345 -58 b 518 -137 522 -141 510 -137 b 521 -137 519 -137 519 -137 b 551 -105 539 -137 551 -122 b 541 -83 551 -98 548 -90 b 447 -36 537 -77 544 -81 b 374 -1 406 -16 374 -1 b 447 34 374 0 406 15 b 541 81 544 80 537 76 b 551 104 548 88 551 97 b 521 136 551 120 539 136 b 518 136 519 136 519 136 b 517 136 518 136 517 136 l 517 136 b 402 83 511 136 511 136 b 298 34 345 56 299 34 b 298 34 298 34 298 34 b 194 84 298 34 250 56 b 88 134 137 111 89 133 "},"v93":{"x_min":0,"x_max":438.28125,"ha":447,"o":"m 212 205 b 219 205 213 205 216 205 b 239 183 228 205 231 204 b 421 -163 298 40 363 -83 b 438 -191 434 -180 438 -186 b 436 -197 438 -192 438 -195 b 424 -206 434 -204 431 -206 b 406 -201 420 -206 415 -205 b 216 -156 347 -172 281 -156 b 23 -205 148 -156 80 -173 b 14 -206 20 -206 17 -206 b 0 -191 6 -206 0 -201 b 6 -176 0 -187 1 -183 b 202 192 63 -104 142 45 b 212 205 205 199 208 202 m 264 48 l 249 81 l 243 94 l 242 91 b 89 -126 208 36 137 -66 b 81 -138 85 -133 81 -138 b 81 -138 81 -138 81 -138 b 81 -138 81 -138 81 -138 b 95 -133 81 -138 87 -136 b 280 -94 156 -108 221 -94 b 334 -98 299 -94 317 -95 b 343 -99 338 -99 343 -99 b 343 -99 343 -99 343 -99 b 338 -94 343 -99 341 -97 b 264 48 318 -58 287 1 "},"v94":{"x_min":-149.71875,"x_max":148.359375,"ha":151,"o":"m -9 215 b 0 217 -6 217 -4 217 b 19 205 8 217 14 213 b 20 142 20 202 20 201 l 20 84 l 23 84 b 144 -27 81 74 129 30 b 148 -66 147 -40 148 -54 b 36 -213 148 -134 103 -197 b 0 -219 24 -217 12 -219 b -145 -104 -68 -219 -129 -173 b -149 -68 -148 -91 -149 -79 b -24 84 -149 6 -98 74 l -21 84 l -21 142 b -19 205 -20 201 -20 202 b -9 215 -17 209 -13 213 m -21 -15 b -23 41 -21 37 -21 41 b -23 41 -23 41 -23 41 b -76 11 -35 40 -62 26 b -108 -65 -98 -11 -108 -38 b -1 -176 -108 -122 -65 -176 b 107 -65 63 -176 107 -122 b 74 11 107 -38 96 -11 b 20 41 61 26 32 41 b 20 -15 20 41 20 15 b 19 -74 20 -72 20 -72 b 0 -87 14 -83 6 -87 b -19 -74 -8 -87 -16 -83 b -21 -15 -20 -72 -20 -72 "},"v95":{"x_min":0,"x_max":406.96875,"ha":415,"o":"m 55 181 b 70 183 61 183 66 183 b 111 170 85 183 99 179 b 160 130 115 167 137 149 l 202 95 l 245 130 b 319 181 299 176 302 179 b 334 183 325 183 330 183 b 406 109 375 183 406 148 b 401 81 406 99 405 91 b 348 24 394 65 390 59 b 318 -1 332 11 318 0 b 348 -26 318 -1 332 -12 b 401 -83 390 -61 394 -66 b 406 -111 405 -93 406 -101 b 334 -184 406 -149 375 -184 b 319 -183 330 -184 325 -184 b 245 -131 302 -180 299 -177 l 202 -97 l 160 -131 b 85 -183 107 -177 103 -180 b 70 -184 80 -184 76 -184 b 0 -111 31 -184 0 -149 b 4 -83 0 -101 1 -93 b 58 -26 10 -66 16 -61 b 88 -1 74 -12 88 -1 b 58 24 88 0 74 11 b 10 69 23 54 17 59 b 0 109 2 81 0 95 b 55 181 0 142 21 173 m 83 133 b 72 136 78 136 76 136 b 57 131 66 136 61 134 b 46 109 49 126 46 117 b 50 93 46 104 47 98 b 107 45 51 91 77 70 b 160 0 137 20 160 0 b 107 -47 160 -1 137 -22 b 50 -94 77 -72 51 -93 b 46 -111 47 -99 46 -105 b 59 -134 46 -120 50 -130 b 72 -137 62 -136 68 -137 b 83 -136 76 -137 80 -136 b 144 -84 84 -134 107 -116 b 202 -36 176 -58 202 -36 b 261 -84 202 -36 230 -58 b 323 -136 299 -116 321 -134 b 334 -137 326 -136 330 -137 b 345 -134 338 -137 343 -136 b 360 -111 355 -130 360 -120 b 355 -94 360 -105 359 -99 b 299 -47 353 -93 329 -72 b 245 0 269 -22 245 -1 b 299 45 245 0 269 20 b 355 93 329 70 353 91 b 360 109 359 98 360 104 b 345 133 360 119 355 129 b 334 136 343 134 338 136 b 323 134 330 136 326 134 b 261 83 321 133 299 115 b 202 34 230 56 202 34 b 144 83 202 34 176 56 b 83 133 106 115 84 133 "},"v97":{"x_min":-228.671875,"x_max":227.3125,"ha":232,"o":"m -217 487 l -213 488 l 0 488 l 212 488 l 216 487 b 225 476 220 484 224 480 l 227 473 l 227 244 l 227 15 l 225 12 b 206 0 223 4 215 0 b 197 1 204 0 200 0 b 187 12 193 4 189 6 l 186 15 l 186 138 l 186 262 l -1 262 l -187 262 l -187 138 l -187 15 l -189 12 b -208 0 -193 4 -200 0 b -227 12 -216 0 -223 4 l -228 15 l -228 244 l -228 473 l -227 476 b -217 487 -225 480 -221 484 "},"v9a":{"x_min":-21.78125,"x_max":367.5,"ha":375,"o":"m 230 1031 b 238 1032 232 1032 235 1032 b 259 1014 245 1032 251 1027 b 367 662 330 906 367 782 b 364 602 367 641 367 621 b 232 317 352 488 304 384 b 57 120 155 245 103 187 b -1 18 31 84 6 40 b -19 4 -4 11 -12 4 l -21 4 l -21 159 l -21 315 l -16 315 b 96 335 10 315 62 324 b 315 695 227 380 315 527 b 313 738 315 709 314 724 b 224 991 304 825 273 916 b 216 1013 219 999 216 1007 b 230 1031 216 1021 220 1028 "},"v9b":{"x_min":-24.5,"x_max":313.0625,"ha":319,"o":"m -24 -133 l -24 -5 l -20 -5 b -1 -19 -12 -5 -4 -11 b 142 -213 13 -61 74 -144 b 258 -376 196 -269 230 -315 b 313 -605 295 -449 313 -528 b 292 -742 313 -652 306 -699 b 288 -752 289 -748 288 -752 b 288 -752 288 -752 288 -752 b 292 -764 289 -753 291 -757 b 313 -907 306 -811 313 -860 b 292 -1045 313 -954 306 -1002 b 288 -1054 289 -1050 288 -1054 b 288 -1054 288 -1054 288 -1054 b 292 -1067 289 -1054 291 -1060 b 313 -1210 306 -1113 313 -1161 b 292 -1346 313 -1257 306 -1304 b 288 -1357 289 -1353 288 -1357 b 288 -1357 288 -1357 288 -1357 b 292 -1368 289 -1357 291 -1363 b 313 -1512 306 -1415 313 -1464 b 292 -1648 313 -1560 306 -1605 b 288 -1660 289 -1654 288 -1660 b 288 -1660 288 -1660 288 -1660 b 292 -1671 289 -1660 291 -1665 b 313 -1814 306 -1719 313 -1766 b 250 -2040 313 -1897 291 -1977 b 232 -2062 238 -2057 236 -2059 b 221 -2065 230 -2063 225 -2065 b 200 -2045 210 -2065 201 -2057 b 200 -2043 200 -2044 200 -2044 b 208 -2026 200 -2037 202 -2034 b 269 -1826 249 -1966 269 -1897 b 153 -1544 269 -1726 230 -1625 b -9 -1472 115 -1506 58 -1481 b -21 -1471 -14 -1471 -19 -1471 l -24 -1471 l -24 -1343 l -24 -1215 l -20 -1215 b -1 -1229 -12 -1215 -4 -1221 b 142 -1424 13 -1270 74 -1353 b 257 -1582 196 -1478 228 -1524 b 264 -1594 261 -1589 264 -1594 l 264 -1594 b 265 -1582 264 -1594 264 -1589 b 270 -1525 268 -1562 270 -1544 b 153 -1243 270 -1424 228 -1321 b -9 -1170 115 -1203 58 -1178 b -21 -1168 -14 -1170 -19 -1168 l -24 -1168 l -24 -1041 l -24 -913 l -20 -913 b -1 -927 -12 -913 -4 -918 b 142 -1121 13 -967 74 -1050 b 257 -1281 196 -1175 228 -1221 b 264 -1292 261 -1286 264 -1292 l 264 -1292 b 265 -1279 264 -1292 264 -1286 b 270 -1222 268 -1261 270 -1242 b 153 -941 270 -1121 228 -1018 b -9 -867 115 -900 58 -875 b -21 -866 -14 -867 -19 -866 l -24 -866 l -24 -738 l -24 -610 l -20 -610 b -1 -624 -12 -610 -4 -616 b 142 -818 13 -664 74 -749 b 257 -978 196 -873 228 -918 b 264 -989 261 -984 264 -989 l 264 -989 b 265 -977 264 -989 264 -984 b 270 -920 268 -959 270 -939 b 153 -638 270 -818 228 -716 b -9 -564 115 -598 58 -573 b -21 -563 -14 -564 -19 -563 l -24 -563 l -24 -435 l -24 -308 l -20 -308 b -1 -322 -12 -308 -4 -313 b 142 -516 13 -363 74 -446 b 257 -675 196 -571 228 -616 b 264 -687 261 -681 264 -687 l 264 -687 b 265 -674 264 -687 264 -681 b 270 -617 268 -656 270 -637 b 153 -335 270 -516 228 -413 b -9 -262 115 -295 58 -270 b -21 -260 -14 -262 -19 -260 l -24 -260 l -24 -133 "},"v9c":{"x_min":-166.0625,"x_max":-25.859375,"ha":0,"o":"m -49 369 b -42 370 -46 369 -44 370 b -27 360 -36 370 -29 366 b -25 355 -27 359 -25 358 b -32 335 -25 351 -28 347 b -92 52 -66 248 -87 159 b -93 -1 -93 43 -93 20 b -92 -54 -93 -23 -93 -45 b -32 -337 -85 -162 -66 -251 b -25 -355 -27 -349 -25 -352 b -42 -371 -25 -365 -32 -371 b -61 -353 -50 -371 -51 -369 b -163 -63 -119 -262 -153 -165 b -166 -1 -166 -37 -166 -31 b -163 62 -166 30 -166 36 b -61 352 -153 163 -119 260 b -49 369 -54 365 -51 366 "},"v9e":{"x_min":0,"x_max":607.0625,"ha":619,"o":"m 243 631 b 250 632 246 632 249 632 b 270 620 259 632 268 628 l 272 616 l 272 201 l 272 -212 l 270 -216 b 251 -229 268 -224 259 -229 b 227 -215 243 -229 240 -229 l 151 -142 b 32 -16 81 -80 53 -49 b 0 84 9 18 0 52 b 111 199 0 149 42 199 b 137 197 119 199 127 198 b 228 151 168 191 197 177 l 231 148 l 231 383 b 232 620 231 616 231 616 b 243 631 234 624 238 630 m 168 131 b 152 133 163 133 157 133 b 107 102 130 133 111 120 b 106 86 107 97 106 91 b 111 41 106 73 108 56 b 227 -152 125 -13 171 -90 l 231 -156 l 231 -37 l 231 80 l 225 87 b 168 131 210 111 190 126 m 347 631 b 353 632 348 632 351 632 b 374 620 363 632 371 628 b 375 383 375 616 375 616 l 375 148 l 377 151 b 492 199 415 183 454 199 b 537 191 507 199 522 197 b 607 84 582 176 607 134 b 583 0 607 58 598 29 b 455 -142 562 -40 533 -72 l 378 -215 b 355 -229 364 -229 362 -229 b 334 -216 345 -229 337 -224 l 333 -212 l 333 201 l 333 616 l 334 620 b 347 631 337 624 341 630 m 465 131 b 451 133 461 133 455 133 b 445 133 449 133 446 133 b 379 87 419 129 396 113 l 375 80 l 375 -37 l 375 -156 l 378 -152 b 499 81 451 -72 499 20 l 499 83 b 465 131 499 113 490 126 "},"va3":{"x_min":58.53125,"x_max":228.671875,"ha":294,"o":"m 138 371 b 142 373 140 371 141 373 b 178 342 149 373 156 366 b 228 251 217 297 228 278 b 228 244 228 248 228 247 b 176 147 227 212 212 184 b 123 73 152 122 132 93 b 121 62 122 70 121 66 b 145 13 121 48 129 31 b 153 -2 151 6 153 1 b 149 -9 153 -5 152 -6 b 144 -11 148 -11 145 -11 b 129 -1 140 -11 136 -8 b 61 87 89 37 68 68 b 58 113 59 95 58 105 b 110 215 58 144 74 177 b 163 287 134 240 155 269 b 166 299 166 291 166 295 b 141 348 166 313 157 330 b 133 360 134 356 133 358 b 133 363 133 362 133 362 b 138 371 133 367 136 370 "},"va5":{"x_min":0,"x_max":349.8125,"ha":357,"o":"m 88 302 b 103 303 93 302 98 303 b 202 224 149 303 191 270 b 205 199 204 216 205 208 b 178 129 205 173 196 147 l 175 126 l 182 127 b 307 249 236 142 284 190 b 313 259 308 254 311 258 b 329 267 317 265 323 267 b 349 247 340 267 349 259 b 201 -263 349 242 204 -258 b 182 -273 197 -270 190 -273 b 163 -260 174 -273 166 -269 b 161 -256 161 -259 161 -258 b 217 -59 161 -248 170 -220 b 272 129 247 43 272 127 b 272 129 272 129 272 129 b 264 122 272 129 268 126 b 140 80 227 94 183 80 b 36 115 102 80 65 91 b 0 194 10 136 0 165 b 88 302 0 244 32 292 "},"va9":{"x_min":-24.5,"x_max":314.421875,"ha":321,"o":"m -24 -145 l -24 -5 l -20 -5 b 0 -23 -9 -5 -2 -12 b 27 -87 4 -38 14 -66 b 138 -220 53 -136 88 -177 b 235 -328 179 -255 208 -288 b 314 -592 287 -409 314 -501 b 292 -732 314 -639 307 -687 l 289 -742 l 294 -756 b 314 -896 307 -802 314 -849 b 292 -1035 314 -943 307 -991 l 289 -1045 l 294 -1057 b 314 -1197 307 -1104 314 -1152 b 292 -1338 314 -1246 307 -1292 l 289 -1347 l 294 -1360 b 314 -1500 307 -1407 314 -1454 b 273 -1689 314 -1565 300 -1628 b 250 -1712 265 -1710 261 -1712 b 228 -1691 236 -1712 228 -1704 l 228 -1685 l 234 -1675 b 270 -1507 258 -1621 270 -1564 b 98 -1193 270 -1381 209 -1261 b 40 -1174 76 -1179 58 -1174 b -10 -1189 24 -1174 8 -1178 b -20 -1192 -14 -1192 -16 -1192 l -24 -1192 l -24 -1052 l -24 -913 l -20 -913 b 0 -931 -9 -913 -2 -920 b 27 -995 4 -946 14 -974 b 138 -1128 53 -1043 88 -1085 b 257 -1275 190 -1172 228 -1220 b 262 -1283 259 -1279 262 -1283 l 262 -1283 b 269 -1249 264 -1282 268 -1260 b 270 -1206 270 -1233 270 -1220 b 98 -891 270 -1075 206 -957 b 40 -871 76 -877 58 -871 b -10 -886 24 -871 8 -875 b -20 -889 -14 -889 -16 -889 l -24 -889 l -24 -749 l -24 -610 l -20 -610 b 0 -628 -9 -610 -2 -617 b 27 -692 4 -644 14 -671 b 138 -825 53 -741 88 -782 b 257 -973 190 -870 228 -917 b 262 -981 259 -977 262 -981 l 262 -981 b 269 -946 264 -979 268 -957 b 270 -903 270 -931 270 -917 b 98 -588 270 -774 206 -655 b 40 -569 76 -574 58 -569 b -10 -584 24 -569 8 -574 b -20 -587 -14 -587 -16 -587 l -24 -587 l -24 -448 l -24 -308 l -20 -308 b 0 -326 -9 -308 -2 -315 b 27 -390 4 -341 14 -369 b 138 -523 53 -438 88 -480 b 257 -670 190 -567 228 -614 b 262 -678 259 -674 262 -678 b 262 -678 262 -678 262 -678 b 269 -644 264 -677 268 -656 b 270 -601 270 -628 270 -614 b 98 -285 270 -471 206 -352 b 40 -266 76 -273 58 -266 b -10 -281 24 -266 8 -272 b -20 -284 -14 -284 -16 -284 l -24 -284 l -24 -145 "},"vaa":{"x_min":-1.359375,"x_max":752.703125,"ha":768,"o":"m 490 985 b 504 986 495 986 500 986 b 604 907 551 986 593 954 b 607 884 607 900 607 892 b 581 813 607 857 597 831 l 578 810 l 583 811 b 710 932 638 827 687 873 b 714 943 711 936 713 942 b 730 952 720 949 725 952 b 752 931 741 952 752 943 b 200 -946 752 927 204 -941 b 182 -957 197 -953 190 -957 b 163 -945 174 -957 166 -953 b 161 -939 161 -942 161 -942 b 217 -743 161 -931 170 -904 b 272 -555 247 -639 272 -555 b 272 -555 272 -555 272 -555 b 264 -560 272 -555 268 -557 b 140 -603 227 -589 182 -603 b 36 -567 102 -603 65 -592 b -1 -487 12 -548 -1 -517 b 17 -427 -1 -466 5 -445 b 103 -380 38 -395 70 -380 b 191 -433 137 -380 172 -398 b 205 -484 201 -448 205 -466 b 178 -553 205 -509 196 -535 l 175 -557 l 182 -555 b 307 -435 236 -539 284 -494 b 372 -213 308 -430 372 -215 b 372 -213 372 -213 372 -213 b 364 -219 372 -213 368 -216 b 240 -262 328 -247 283 -262 b 137 -226 202 -262 166 -249 b 99 -145 112 -206 99 -176 b 118 -84 99 -124 106 -104 b 204 -38 138 -54 171 -38 b 292 -91 238 -38 273 -56 b 306 -141 302 -106 306 -124 b 279 -212 306 -167 296 -194 l 276 -215 l 281 -213 b 408 -93 336 -198 385 -151 b 473 129 409 -88 473 127 b 473 129 473 129 473 129 b 465 122 473 129 469 126 b 341 80 428 94 383 80 b 236 115 303 80 266 91 b 200 195 213 136 200 165 b 217 256 200 217 206 238 b 304 303 239 287 272 303 b 393 249 338 303 374 285 b 406 199 402 234 406 217 b 379 129 406 173 397 148 l 377 126 l 382 127 b 509 248 436 142 485 190 b 574 470 510 254 574 469 b 574 470 574 470 574 470 b 566 464 574 470 570 467 b 442 421 529 435 484 421 b 337 458 404 421 367 433 b 300 538 314 477 300 508 b 318 598 300 559 306 580 b 404 645 340 630 372 645 b 494 592 439 645 475 627 b 507 541 502 577 507 559 b 480 471 507 516 498 489 l 477 467 l 483 470 b 608 589 537 485 586 531 b 675 811 611 595 675 810 b 675 811 675 811 675 811 b 666 806 675 811 671 809 b 543 763 628 777 585 763 b 438 799 504 763 468 775 b 401 878 412 820 401 849 b 490 985 401 928 434 977 "},"vab":{"x_min":0,"x_max":272.21875,"ha":278,"o":"m 243 631 b 250 632 246 632 249 632 b 270 620 259 632 268 628 l 272 616 l 272 201 l 272 -212 l 270 -216 b 251 -229 268 -224 259 -229 b 227 -215 243 -229 240 -229 l 151 -142 b 32 -16 81 -80 53 -49 b 0 84 9 18 0 52 b 111 199 0 149 42 199 b 137 197 119 199 127 198 b 228 151 168 191 197 177 l 231 148 l 231 383 b 232 620 231 616 231 616 b 243 631 234 624 238 630 m 168 131 b 152 133 163 133 157 133 b 107 102 130 133 111 120 b 106 86 107 97 106 91 b 111 41 106 73 108 56 b 227 -152 125 -13 171 -90 l 231 -156 l 231 -37 l 231 80 l 225 87 b 168 131 210 111 190 126 "},"vad":{"x_min":0,"x_max":873.828125,"ha":892,"o":"m 0 0 l 0 703 l 81 703 l 164 703 l 164 0 l 164 -705 l 81 -705 l 0 -705 l 0 0 m 225 0 l 225 703 l 246 703 l 268 703 l 268 366 l 268 30 l 274 36 b 314 79 284 44 302 63 b 413 302 357 137 392 213 b 432 327 419 324 421 327 b 449 306 443 327 447 322 b 611 115 457 195 529 115 b 651 122 624 115 638 117 b 728 316 705 140 724 188 b 729 388 728 342 729 366 b 671 635 729 533 711 602 b 581 662 649 652 616 662 b 477 637 545 662 510 653 l 475 635 l 477 634 b 503 627 488 632 495 631 b 545 556 532 612 545 584 b 491 480 545 524 526 491 b 465 474 481 476 473 474 b 379 563 417 474 379 516 b 389 602 379 576 382 588 b 541 691 409 641 479 681 b 582 694 555 692 568 694 b 865 462 714 694 834 598 b 873 392 871 440 873 416 b 865 317 873 367 871 341 b 639 84 839 194 748 101 b 612 83 630 83 620 83 b 511 116 577 83 543 94 b 504 120 509 119 506 120 b 504 120 504 120 504 120 b 469 59 504 120 488 93 l 432 -1 l 469 -61 b 504 -122 488 -94 504 -122 b 504 -122 504 -122 504 -122 b 511 -117 506 -122 509 -120 b 612 -84 543 -95 577 -84 b 665 -91 630 -84 647 -87 b 869 -338 771 -122 850 -216 b 873 -392 872 -356 873 -374 b 798 -595 873 -469 847 -539 b 581 -695 741 -662 660 -695 b 406 -626 517 -695 454 -671 b 381 -563 389 -607 381 -585 b 465 -477 381 -519 413 -477 b 545 -559 514 -477 545 -519 b 503 -628 545 -587 532 -613 b 477 -635 495 -632 488 -634 l 475 -637 l 477 -638 b 581 -663 510 -655 545 -663 b 671 -637 616 -663 649 -653 b 729 -391 711 -603 729 -534 b 728 -317 729 -367 728 -344 b 623 -117 722 -173 698 -124 b 611 -116 619 -116 615 -116 b 449 -308 528 -116 457 -198 b 432 -328 447 -323 443 -328 b 413 -303 421 -328 419 -326 b 314 -80 392 -215 357 -138 b 274 -37 302 -65 284 -45 l 268 -31 l 268 -367 l 268 -705 l 246 -705 l 225 -705 l 225 0 "},"vb1":{"x_min":78.9375,"x_max":485.921875,"ha":417,"o":"m 362 378 b 378 380 367 380 372 380 b 472 348 415 380 453 367 b 485 315 481 338 485 327 b 462 273 485 298 477 281 b 439 267 454 269 446 267 b 398 290 424 267 409 274 b 344 319 385 309 364 319 b 281 269 315 319 289 301 b 279 262 280 266 279 262 b 276 256 279 260 277 258 b 274 249 276 254 274 251 b 238 127 273 248 257 192 b 201 4 217 61 201 5 b 166 -1 198 -1 200 -1 b 153 -1 163 -1 157 -1 b 141 -1 148 -1 144 -1 b 104 4 106 -1 107 -1 b 104 6 104 5 104 5 b 142 144 104 13 110 34 b 182 278 164 219 181 276 b 183 288 182 281 182 285 b 185 302 185 292 185 298 b 164 330 185 317 176 328 b 159 330 163 330 161 330 b 102 302 140 330 119 320 b 91 294 95 295 93 294 b 88 294 91 294 89 294 b 78 303 83 294 78 298 b 81 312 78 306 78 309 b 200 373 106 347 160 373 b 215 371 205 373 209 371 b 266 335 235 367 254 353 b 269 331 268 333 269 331 b 269 331 269 331 269 331 b 273 335 269 331 270 334 b 362 378 298 359 330 376 "},"vb3":{"x_min":0,"x_max":227.3125,"ha":232,"o":"m 91 213 b 100 215 93 215 96 215 b 227 58 167 215 224 144 b 227 52 227 56 227 54 b 61 -201 227 -43 164 -138 b 29 -216 44 -212 36 -216 b 23 -210 27 -216 24 -213 b 21 -205 21 -208 21 -206 b 34 -192 21 -201 25 -197 b 122 -55 89 -161 122 -106 b 104 6 122 -33 117 -12 l 103 9 l 96 9 b 4 79 57 9 17 38 b 0 112 1 90 0 101 b 91 213 0 163 36 209 "},"vb4":{"x_min":-597.53125,"x_max":596.171875,"ha":608,"o":"m -533 324 b -525 327 -530 326 -528 327 b -504 305 -514 327 -504 317 b -504 305 -504 305 -504 305 b -513 284 -504 299 -504 299 b -556 112 -541 226 -556 167 b -545 33 -556 84 -552 58 b -524 -20 -541 15 -532 -9 l -522 -23 l -491 15 l -413 111 b -355 174 -367 169 -363 174 b -351 174 -353 174 -352 174 b -254 86 -343 174 -348 179 b -168 -1 -208 37 -168 -1 b -100 84 -168 -1 -137 37 b -23 173 -28 173 -29 172 b -19 174 -21 174 -20 174 b -8 173 -14 174 -10 173 b 80 86 -5 172 13 151 b 166 -1 127 37 166 -1 b 235 84 166 -1 197 37 b 311 173 306 173 304 172 b 317 174 313 174 314 174 b 326 173 319 174 323 173 b 490 11 329 172 366 134 l 502 -1 l 530 34 b 568 76 560 72 563 74 b 575 77 570 77 573 77 b 596 56 586 77 596 68 b 594 48 596 54 596 51 b 417 -172 592 41 424 -166 b 405 -176 415 -174 409 -176 b 396 -174 401 -176 398 -176 b 307 -87 393 -173 372 -152 b 221 -1 259 -38 221 -1 b 152 -86 221 -1 190 -38 b 76 -176 81 -174 83 -173 b 70 -176 74 -176 73 -176 b 61 -174 66 -176 62 -174 b -27 -87 58 -173 38 -152 b -114 -1 -74 -38 -112 -1 b -182 -86 -114 -1 -145 -38 b -258 -176 -253 -174 -253 -173 b -264 -176 -259 -176 -262 -176 b -274 -174 -268 -176 -272 -174 b -438 -11 -277 -173 -348 -102 l -449 0 l -479 -37 b -524 -80 -513 -80 -514 -80 l -524 -80 b -553 -52 -534 -80 -540 -74 b -597 109 -583 -8 -597 48 b -560 280 -597 165 -585 224 b -533 324 -548 310 -540 322 "},"vb6":{"x_min":0,"x_max":556.6875,"ha":568,"o":"m 289 545 b 298 546 292 545 295 546 b 318 533 306 546 315 541 b 319 428 319 530 319 528 l 319 327 l 334 327 b 526 223 412 326 485 285 b 543 172 537 206 543 190 b 447 76 543 122 503 76 b 445 76 446 76 446 76 b 359 165 394 77 359 119 b 368 205 359 179 362 192 b 441 251 382 233 412 251 b 455 249 446 251 451 251 b 460 248 458 249 460 248 b 460 248 460 248 460 248 b 454 254 460 249 458 251 b 334 295 419 280 378 294 l 319 295 l 319 4 l 319 -287 l 321 -285 b 328 -285 322 -285 325 -285 b 524 -99 424 -277 507 -198 b 541 -79 526 -84 530 -79 b 556 -97 551 -79 556 -84 b 548 -133 556 -105 553 -117 b 334 -317 521 -233 434 -306 b 322 -319 329 -317 323 -317 l 319 -319 l 319 -424 b 319 -471 319 -444 319 -459 b 313 -541 319 -544 318 -535 b 298 -548 308 -545 303 -548 b 279 -534 289 -548 281 -542 b 277 -424 277 -531 277 -530 l 277 -317 l 273 -317 b 13 -95 153 -305 51 -217 b 0 2 4 -62 0 -29 b 182 295 0 126 66 238 b 274 324 210 309 249 320 l 277 324 l 277 427 b 279 533 277 528 277 530 b 289 545 281 538 285 542 m 277 2 b 277 291 277 161 277 291 b 268 288 277 291 273 290 b 144 1 179 265 144 184 b 276 -284 144 -199 175 -267 l 277 -285 l 277 2 "},"vb9":{"x_min":-122.5,"x_max":121.140625,"ha":124,"o":"m -16 145 b 0 147 -10 147 -5 147 b 121 -1 66 147 121 77 b 114 -49 121 -16 118 -33 b -1 -148 95 -112 47 -148 b -85 -106 -31 -148 -61 -134 b -122 -1 -110 -76 -122 -38 b -16 145 -122 68 -81 134 m 12 111 b 0 113 8 113 4 113 b -68 22 -29 113 -61 73 b -70 0 -69 15 -70 6 b -13 -113 -70 -49 -47 -98 b -1 -115 -9 -115 -5 -115 b 63 -40 24 -115 53 -83 b 68 -1 66 -27 68 -15 b 12 111 68 48 46 97 "},"vba":{"x_min":-118.421875,"x_max":597.53125,"ha":381,"o":"m 460 574 b 464 574 461 574 462 574 b 488 574 470 574 481 574 b 500 573 491 574 498 574 b 594 503 543 570 588 538 b 597 488 596 498 597 494 b 528 417 597 449 564 417 b 502 423 519 417 510 419 b 465 481 477 434 465 458 b 488 528 465 499 472 516 b 490 530 490 530 490 530 b 490 530 490 530 490 530 b 468 517 488 530 475 523 b 349 340 419 485 377 420 b 347 330 348 334 347 330 b 383 328 347 328 363 328 b 428 326 423 328 424 328 b 442 302 438 320 442 312 b 430 281 442 294 438 285 b 385 276 424 277 426 276 l 377 276 l 332 276 l 330 269 b 178 -117 303 126 250 -9 b 1 -249 129 -194 69 -237 b -20 -251 -6 -251 -13 -251 b -114 -187 -65 -251 -100 -227 b -118 -156 -117 -177 -118 -166 b -51 -84 -118 -116 -91 -84 b -31 -87 -46 -84 -39 -86 b 16 -152 0 -95 16 -124 b -12 -205 16 -173 8 -194 b -16 -208 -14 -206 -16 -208 b -14 -208 -16 -208 -14 -208 b -9 -206 -14 -208 -12 -208 b 74 -124 23 -197 54 -166 b 172 224 98 -79 125 22 b 185 276 178 252 183 274 b 185 276 185 276 185 276 b 141 276 185 276 181 276 b 91 280 96 276 96 276 b 77 302 83 285 77 294 b 91 326 77 312 83 320 b 148 328 95 328 96 328 l 198 330 l 202 341 b 460 574 249 473 351 566 "},"vbf":{"x_min":-53.078125,"x_max":513.140625,"ha":485,"o":"m 185 383 b 196 384 187 383 191 384 b 277 334 230 384 259 365 b 288 301 281 324 288 306 b 288 297 288 298 288 297 b 294 302 289 297 291 299 b 394 370 323 338 367 367 b 404 371 398 370 401 371 b 510 272 453 371 498 328 b 513 237 513 262 513 251 b 507 172 513 217 511 192 b 326 -34 487 59 412 -26 b 314 -36 322 -36 318 -36 b 274 -24 298 -36 283 -31 l 265 -16 b 224 44 246 -1 232 20 b 223 49 224 47 223 49 b 223 49 223 49 223 49 b 149 -197 221 48 149 -194 b 149 -198 149 -197 149 -198 b 170 -210 149 -202 155 -205 b 187 -215 174 -210 175 -212 b 204 -231 201 -219 204 -222 b 197 -245 204 -240 202 -242 l 194 -248 l 76 -248 l -42 -248 l -46 -245 b -53 -231 -51 -242 -53 -240 b -35 -215 -53 -222 -49 -217 b -13 -210 -21 -212 -20 -212 b -6 -208 -10 -209 -8 -208 b 0 -206 -6 -208 -2 -206 b 25 -188 13 -201 21 -195 b 163 280 28 -183 163 276 b 166 291 163 283 164 287 b 167 302 167 295 167 299 b 155 324 167 315 161 324 b 155 324 155 324 155 324 b 65 230 125 322 85 280 b 53 215 61 217 58 215 b 51 215 53 215 51 215 b 42 224 46 215 42 217 b 57 263 42 231 47 244 b 140 360 77 305 104 337 b 152 370 144 365 149 369 b 185 383 157 376 172 381 m 374 306 b 366 308 371 308 368 308 b 300 273 348 308 321 294 b 284 254 288 262 287 259 b 280 242 283 249 281 245 b 257 169 279 240 270 213 l 236 98 l 236 93 b 251 48 238 77 243 61 b 279 27 258 37 272 27 b 281 27 279 27 280 27 b 291 31 281 27 287 30 b 396 170 334 52 378 109 b 406 247 402 197 406 224 b 401 277 406 259 405 270 b 374 306 397 290 383 303 "},"vc3":{"x_min":-10.890625,"x_max":299.4375,"ha":294,"o":"m 136 460 b 142 462 137 462 140 462 b 166 449 152 462 161 456 b 171 428 168 446 168 445 b 288 131 194 322 238 209 b 298 115 295 120 296 117 b 299 106 298 112 299 109 b 273 81 299 91 287 81 b 255 86 268 81 261 83 b 155 116 225 104 183 116 l 152 116 l 149 108 b 141 83 148 102 144 91 b 134 48 137 69 134 58 b 149 9 134 34 140 24 b 153 -1 152 5 153 1 b 149 -9 153 -5 152 -6 b 144 -11 148 -11 147 -11 b 122 2 138 -11 133 -6 b 95 61 104 20 95 38 b 107 108 95 74 99 90 b 108 113 107 111 108 112 b 107 113 108 113 108 113 b 102 113 106 113 104 113 b 31 86 76 108 53 98 b 14 80 24 81 20 80 b -10 106 0 80 -10 91 b 0 131 -10 115 -9 116 b 115 430 49 209 91 317 b 136 460 119 451 123 456 "}},"cssFontWeight":"normal","ascender":1903,"underlinePosition":-125,"cssFontStyle":"normal","boundingBox":{"yMin":-2065.375,"xMin":-695.53125,"yMax":1901.578125,"xMax":1159.671875},"resolution":1000,"descender":-2066,"familyName":"VexFlow-18","lineHeight":4093,"underlineThickness":50};
// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Muthanna 2010
//
// Requires a glyph font to be loaded and Vex.Flow.Font to be set.

/**
 * A quick and dirty static glyph renderer. Renders glyphs from the default
 * font defined in Vex.Flow.Font.
 *
 * @param {!Object} ctx The canvas context.
 * @param {number} x_pos X coordinate.
 * @param {number} y_pos Y coordinate.
 * @param {number} point The point size to use.
 * @param {string} val The glyph code in Vex.Flow.Font.
 * @param {boolean} nocache If set, disables caching of font outline.
 */
Vex.Flow.renderGlyph = function(ctx, x_pos, y_pos, point, val, nocache) {
  var scale = point * 72.0 / (Vex.Flow.Font.resolution * 100.0);
  var metrics = Vex.Flow.Glyph.loadMetrics(Vex.Flow.Font, val, !nocache);
  Vex.Flow.Glyph.renderOutline(ctx, metrics.outline, scale, x_pos, y_pos);
};

/**
 * @constructor
 */
Vex.Flow.Glyph = (function() {
  function Glyph(code, point, options) {
    this.code = code;
    this.point = point;
    this.context = null;
    this.options = {
      cache: true,
      font: Vex.Flow.Font
    };

    this.width = null;
    this.metrics = null;
    this.x_shift = 0;
    this.y_shift = 0;

    if (options) this.setOptions(options); else this.reset();
  }

  Glyph.prototype = {
    setOptions: function(options) {
      Vex.Merge(this.options, options);
      this.reset();
    },

    setStave: function(stave) { this.stave = stave; return this; },
    setXShift: function(x_shift) { this.x_shift = x_shift; return this; },
    setYShift: function(y_shift) { this.y_shift = y_shift; return this; },
    setContext: function(context) { this.context = context; return this; },
    getContext: function() { return this.context; },

    reset: function() {
      this.metrics = Vex.Flow.Glyph.loadMetrics(this.options.font, this.code,
          this.options.cache);
      this.scale = this.point * 72 / (this.options.font.resolution * 100);
    },

    setWidth: function(width) {
      this.width =  width;
      return this;
    },

    getMetrics: function() {
      if (!this.metrics) throw new Vex.RuntimeError("BadGlyph", "Glyph " +
          this.code + " is not initialized.");
      return {
        x_min: this.metrics.x_min * this.scale,
        x_max: this.metrics.x_max * this.scale,
        width: this.width || (this.metrics.x_max - this.metrics.x_min) * this.scale,
        height: this.metrics.ha * this.scale
      };
    },

    render: function(ctx, x_pos, y_pos) {
      if (!this.metrics) throw new Vex.RuntimeError("BadGlyph", "Glyph " +
          this.code + " is not initialized.");

      var outline = this.metrics.outline;
      var scale = this.scale;

      Glyph.renderOutline(ctx, outline, scale, x_pos, y_pos);
    },

    renderToStave: function(x) {
      if (!this.metrics) throw new Vex.RuntimeError("BadGlyph", "Glyph " +
          this.code + " is not initialized.");
      if (!this.stave) throw new Vex.RuntimeError("GlyphError", "No valid stave");
      if (!this.context) throw new Vex.RERR("GlyphError", "No valid context");

      var outline = this.metrics.outline;
      var scale = this.scale;

      Glyph.renderOutline(this.context, outline, scale,
          x + this.x_shift, this.stave.getYForGlyphs() + this.y_shift);
    }
  };

  /* Static methods used to implement loading / unloading of glyphs */
  Glyph.loadMetrics = function(font, code, cache) {
    var glyph = font.glyphs[code];
    if (!glyph) throw new Vex.RuntimeError("BadGlyph", "Glyph " + code +
        " does not exist in font.");

    var x_min = glyph.x_min;
    var x_max = glyph.x_max;
    var ha = glyph.ha;

    var outline;

    if (glyph.o) {
      if (cache) {
        if (glyph.cached_outline) {
          outline = glyph.cached_outline;
        } else {
          outline = glyph.o.split(' ');
          glyph.cached_outline = outline;
        }
      } else {
        if (glyph.cached_outline) delete glyph.cached_outline;
        outline = glyph.o.split(' ');
      }

      return {
        x_min: x_min,
        x_max: x_max,
        ha: ha,
        outline: outline
      };
    } else {
      throw new Vex.RuntimeError("BadGlyph", "Glyph " + this.code +
          " has no outline defined.");
    }
  };

  Glyph.renderOutline = function(ctx, outline, scale, x_pos, y_pos) {
    var outlineLength = outline.length;

    ctx.beginPath();

    ctx.moveTo(x_pos, y_pos);

    for (var i = 0; i < outlineLength; ) {
      var action = outline[i++];

      switch(action) {
        case 'm':
          ctx.moveTo(x_pos + outline[i++] * scale,
                     y_pos + outline[i++] * -scale);
          break;
        case 'l':
          ctx.lineTo(x_pos + outline[i++] * scale,
                     y_pos + outline[i++] * -scale);
          break;

        case 'q':
          var cpx = x_pos + outline[i++] * scale;
          var cpy = y_pos + outline[i++] * -scale;

          ctx.quadraticCurveTo(
              x_pos + outline[i++] * scale,
              y_pos + outline[i++] * -scale, cpx, cpy);
          break;

        case 'b':
          var x = x_pos + outline[i++] * scale;
          var y = y_pos + outline[i++] * -scale;

          ctx.bezierCurveTo(
              x_pos + outline[i++] * scale, y_pos + outline[i++] * -scale,
              x_pos + outline[i++] * scale, y_pos + outline[i++] * -scale,
              x, y);
          break;
      }
    }
    ctx.fill();
  };

  return Glyph;
}());

// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Cheppudira 2010

/** @constructor */
Vex.Flow.Stave = (function() {
  function Stave(x, y, width, options) {
    if (arguments.length > 0) this.init(x, y, width, options);
  }

  var THICKNESS = (Vex.Flow.STAVE_LINE_THICKNESS > 1 ?
        Vex.Flow.STAVE_LINE_THICKNESS : 0);
  Stave.prototype = {
    init: function(x, y, width, options) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.glyph_start_x = x + 5;
      this.glyph_end_x = x + width;
      this.start_x = this.glyph_start_x;
      this.end_x = this.glyph_end_x;
      this.context = null;
      this.glyphs = [];
      this.end_glyphs = [];
      this.modifiers = [];  // non-glyph stave items (barlines, coda, segno, etc.)
      this.measure = 0;
      this.clef = "treble";
      this.font = {
        family: "sans-serif",
        size: 8,
        weight: ""
      };
      this.options = {
        vertical_bar_width: 10,       // Width around vertical bar end-marker
        glyph_spacing_px: 10,
        num_lines: 5,
        fill_style: "#999999",
        spacing_between_lines_px: 10, // in pixels
        space_above_staff_ln: 4,      // in staff lines
        space_below_staff_ln: 4,      // in staff lines
        top_text_position: 1          // in staff lines
      };
      this.bounds = {x: this.x, y: this.y, w: this.width, h: 0};
      Vex.Merge(this.options, options);

      this.resetLines();

      this.modifiers.push(
          new Vex.Flow.Barline(Vex.Flow.Barline.type.SINGLE, this.x)); // beg bar
      this.modifiers.push(
          new Vex.Flow.Barline(Vex.Flow.Barline.type.SINGLE,
          this.x + this.width)); // end bar
    },

    resetLines: function() {
      this.options.line_config = [];
      for (var i = 0; i < this.options.num_lines; i++) {
        this.options.line_config.push({visible: true});
      }
      this.height = (this.options.num_lines + this.options.space_above_staff_ln) *
         this.options.spacing_between_lines_px;
      this.options.bottom_text_position = this.options.num_lines + 1;
    },

    setNoteStartX: function(x) { this.start_x = x; return this; },
    getNoteStartX: function() {
      var start_x = this.start_x;

      // Add additional space if left barline is REPEAT_BEGIN and there are other
      // start modifiers than barlines
      if (this.modifiers[0].barline == Vex.Flow.Barline.type.REPEAT_BEGIN &&
          this.modifiers.length > 2) {
        start_x += 20;
      }

      return start_x;
    },

    getNoteEndX: function() { return this.end_x; },
    getTieStartX: function() { return this.start_x; },
    getTieEndX: function() { return this.x + this.width; },
    setContext: function(context) {
      this.context = context;
	for(var i=0; i<this.glyphs.length; i++){
          if(typeof(this.glyphs[i].setContext) === "function"){
	    this.glyphs[i].setContext(context);
          }
	}
      return this;
    },
    getContext: function() { return this.context; },
    getX: function() { return this.x; },
    getNumLines: function() { return this.options.num_lines; },
    setNumLines: function(lines) {
      this.options.num_lines = parseInt(lines, 10);
      this.resetLines();
      return this;
    },
    setY: function(y) { this.y = y; return this; },

    setX: function(x){
      var shift = x - this.x;
      this.x = x;
      this.glyph_start_x += shift;
      this.glyph_end_x += shift;
      this.start_x += shift;
      this.end_x += shift;
      for(var i=0; i<this.modifiers.length; i++) {
      	var mod = this.modifiers[i];
        if (mod.x !== undefined) {
          mod.x += shift;
      	}
      }
      return this;
    },

    setWidth: function(width) {
      this.width = width;
      this.glyph_end_x = this.x + width;
      this.end_x = this.glyph_end_x;

      // reset the x position of the end barline (TODO(0xfe): This makes no sense)
      // this.modifiers[1].setX(this.end_x);
      return this;
    },

    getWidth: function() {
      return this.width;
    },

    setMeasure: function(measure) { this.measure = measure; return this; },

      // Bar Line functions
    setBegBarType: function(type) {
      // Only valid bar types at beginning of stave is none, single or begin repeat
      if (type == Vex.Flow.Barline.type.SINGLE ||
          type == Vex.Flow.Barline.type.REPEAT_BEGIN ||
          type == Vex.Flow.Barline.type.NONE) {
          this.modifiers[0] = new Vex.Flow.Barline(type, this.x);
      }
      return this;
    },

    setEndBarType: function(type) {
      // Repeat end not valid at end of stave
      if (type != Vex.Flow.Barline.type.REPEAT_BEGIN)
        this.modifiers[1] = new Vex.Flow.Barline(type, this.x + this.width);
      return this;
    },

    /**
     * Gets the pixels to shift from the beginning of the stave
     * following the modifier at the provided index
     * @param  {Number} index The index from which to determine the shift
     * @return {Number}       The amount of pixels shifted
     */
    getModifierXShift: function(index) {
      if (typeof index === 'undefined') index = this.glyphs.length -1;
      if (typeof index !== 'number') new Vex.RERR("InvalidIndex",
        "Must be of number type");

      var x = this.glyph_start_x;
      var bar_x_shift = 0;

      for (var i = 0; i < index + 1; ++i) {
        var glyph = this.glyphs[i];
        x += glyph.getMetrics().width;
        bar_x_shift += glyph.getMetrics().width;
      }

      // Add padding after clef, time sig, key sig
      if (bar_x_shift > 0) bar_x_shift += this.options.vertical_bar_width + 10;

      return bar_x_shift;
    },

    // Coda & Segno Symbol functions
    setRepetitionTypeLeft: function(type, y) {
      this.modifiers.push(new Vex.Flow.Repetition(type, this.x, y));
      return this;
    },

    setRepetitionTypeRight: function(type, y) {
      this.modifiers.push(new Vex.Flow.Repetition(type, this.x, y) );
      return this;
    },

    // Volta functions
    setVoltaType: function(type, number_t, y) {
      this.modifiers.push(new Vex.Flow.Volta(type, number_t, this.x, y));
      return this;
    },

    // Section functions
    setSection: function(section, y) {
      this.modifiers.push(new Vex.Flow.StaveSection(section, this.x, y));
      return this;
    },

    // Tempo functions
    setTempo: function(tempo, y) {
      this.modifiers.push(new Vex.Flow.StaveTempo(tempo, this.x, y));
      return this;
    },

    // Text functions
    setText: function(text, position, options) {
      this.modifiers.push(new Vex.Flow.StaveText(text, position, options));
      return this;
    },

    getHeight: function() {
      return this.height;
    },

    getSpacingBetweenLines: function() {
      return this.options.spacing_between_lines_px;
    },

    getBoundingBox: function() {
      return new Vex.Flow.BoundingBox(this.x, this.y, this.width, this.getBottomY() - this.y);
      // body...
    },

    getBottomY: function() {
      var options = this.options;
      var spacing = options.spacing_between_lines_px;
      var score_bottom = this.getYForLine(options.num_lines) +
         (options.space_below_staff_ln * spacing);

      return score_bottom;
    },

    getBottomLineY: function() {
      return this.getYForLine(this.options.num_lines);
    },

    getYForLine: function(line) {
      var options = this.options;
      var spacing = options.spacing_between_lines_px;
      var headroom = options.space_above_staff_ln;

      var y = this.y + ((line * spacing) + (headroom * spacing)) -
        (THICKNESS / 2);

      return y;
    },

    getYForTopText: function(line) {
      var l = line || 0;
      return this.getYForLine(-l - this.options.top_text_position);
    },

    getYForBottomText: function(line) {
      var l = line || 0;
      return this.getYForLine(this.options.bottom_text_position + l);
    },

    getYForNote: function(line) {
      var options = this.options;
      var spacing = options.spacing_between_lines_px;
      var headroom = options.space_above_staff_ln;
      var y = this.y + (headroom * spacing) + (5 * spacing) - (line * spacing);

      return y;
    },

    getYForGlyphs: function() {
      return this.getYForLine(3);
    },

    addGlyph: function(glyph) {
      glyph.setStave(this);
      this.glyphs.push(glyph);
      this.start_x += glyph.getMetrics().width;
      return this;
    },

    addEndGlyph: function(glyph) {
      glyph.setStave(this);
      this.end_glyphs.push(glyph);
      this.end_x -= glyph.getMetrics().width;
      return this;
    },

    addModifier: function(modifier) {
      this.modifiers.push(modifier);
      modifier.addToStave(this, (this.glyphs.length === 0));
      return this;
    },

    addEndModifier: function(modifier) {
      this.modifiers.push(modifier);
      modifier.addToStaveEnd(this, (this.end_glyphs.length === 0));
      return this;
    },

    addKeySignature: function(keySpec) {
      this.addModifier(new Vex.Flow.KeySignature(keySpec));
      return this;
    },

    addClef: function(clef, size, annotation) {
      this.clef = clef;
      this.addModifier(new Vex.Flow.Clef(clef, size, annotation));
      return this;
    },

    addEndClef: function(clef, size, annotation) {
      this.addEndModifier(new Vex.Flow.Clef(clef, size, annotation));
      return this;
    },

    addTimeSignature: function(timeSpec, customPadding) {
      this.addModifier(new Vex.Flow.TimeSignature(timeSpec, customPadding));
      return this;
    },

    addEndTimeSignature: function(timeSpec, customPadding) {
      this.addEndModifier(new Vex.Flow.TimeSignature(timeSpec, customPadding));
    },

    addTrebleGlyph: function() {
      this.clef = "treble";
      this.addGlyph(new Vex.Flow.Glyph("v83", 40));
      return this;
    },

    /**
     * All drawing functions below need the context to be set.
     */
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var num_lines = this.options.num_lines;
      var width = this.width;
      var x = this.x;
      var y;
      var glyph;

      // Render lines
      for (var line=0; line < num_lines; line++) {
        y = this.getYForLine(line);

        this.context.save();
        this.context.setFillStyle(this.options.fill_style);
        this.context.setStrokeStyle(this.options.fill_style);
        if (this.options.line_config[line].visible) {
          this.context.fillRect(x, y, width, Vex.Flow.STAVE_LINE_THICKNESS);
        }
        this.context.restore();
      }

      // Render glyphs
      x = this.glyph_start_x;
      for (var i = 0; i < this.glyphs.length; ++i) {
        glyph = this.glyphs[i];
        if (!glyph.getContext()) {
          glyph.setContext(this.context);
        }
        glyph.renderToStave(x);
        x += glyph.getMetrics().width;
      }

      // Render end glyphs
      x = this.glyph_end_x;
      for (i = 0; i < this.end_glyphs.length; ++i) {
        glyph = this.end_glyphs[i];
        if (!glyph.getContext()) {
          glyph.setContext(this.context);
        }
        x -= glyph.getMetrics().width;
        glyph.renderToStave(x);
      }

      // Draw the modifiers (bar lines, coda, segno, repeat brackets, etc.)
      for (i = 0; i < this.modifiers.length; i++) {
        // Only draw modifier if it has a draw function
        if (typeof this.modifiers[i].draw == "function")
          this.modifiers[i].draw(this, this.getModifierXShift());
      }

      // Render measure numbers
      if (this.measure > 0) {
        this.context.save();
        this.context.setFont(this.font.family, this.font.size, this.font.weight);
        var text_width = this.context.measureText("" + this.measure).width;
        y = this.getYForTopText(0) + 3;
        this.context.fillText("" + this.measure, this.x - text_width / 2, y);
        this.context.restore();
      }

      return this;
    },

    // Draw Simple barlines for backward compatability
    // Do not delete - draws the beginning bar of the stave
    drawVertical: function(x, isDouble) {
      this.drawVerticalFixed(this.x + x, isDouble);
    },

    drawVerticalFixed: function(x, isDouble) {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var top_line = this.getYForLine(0);
      var bottom_line = this.getYForLine(this.options.num_lines - 1);
      if (isDouble)
        this.context.fillRect(x - 3, top_line, 1, bottom_line - top_line + 1);
      this.context.fillRect(x, top_line, 1, bottom_line - top_line + 1);
    },

    drawVerticalBar: function(x) {
      this.drawVerticalBarFixed(this.x + x, false);
    },

    drawVerticalBarFixed: function(x) {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var top_line = this.getYForLine(0);
      var bottom_line = this.getYForLine(this.options.num_lines - 1);
      this.context.fillRect(x, top_line, 1, bottom_line - top_line + 1);
    },

    /**
     * Get the current configuration for the Stave.
     * @return {Array} An array of configuration objects.
     */
    getConfigForLines: function() {
      return this.options.line_config;
    },

    /**
     * Configure properties of the lines in the Stave
     * @param line_number The index of the line to configure.
     * @param line_config An configuration object for the specified line.
     * @throws Vex.RERR "StaveConfigError" When the specified line number is out of
     *   range of the number of lines specified in the constructor.
     */
    setConfigForLine: function(line_number, line_config) {
      if (line_number >= this.options.num_lines || line_number < 0) {
        throw new Vex.RERR("StaveConfigError",
          "The line number must be within the range of the number of lines in the Stave.");
      }
      if (!line_config.hasOwnProperty('visible')) {
        throw new Vex.RERR("StaveConfigError",
          "The line configuration object is missing the 'visible' property.");
      }
      if (typeof(line_config.visible) !== 'boolean') {
        throw new Vex.RERR("StaveConfigError",
          "The line configuration objects 'visible' property must be true or false.");
      }

      this.options.line_config[line_number] = line_config;

      return this;
    },

    /**
     * Set the staff line configuration array for all of the lines at once.
     * @param lines_configuration An array of line configuration objects.  These objects
     *   are of the same format as the single one passed in to setLineConfiguration().
     *   The caller can set null for any line config entry if it is desired that the default be used
     * @throws Vex.RERR "StaveConfigError" When the lines_configuration array does not have
     *   exactly the same number of elements as the num_lines configuration object set in
     *   the constructor.
     */
    setConfigForLines: function(lines_configuration) {
      if (lines_configuration.length !== this.options.num_lines) {
        throw new Vex.RERR("StaveConfigError",
          "The length of the lines configuration array must match the number of lines in the Stave");
      }

      // Make sure the defaults are present in case an incomplete set of
      //  configuration options were supplied.
      for (var line_config in lines_configuration) {
        // Allow 'null' to be used if the caller just wants the default for a particular node.
        if (!lines_configuration[line_config]) {
          lines_configuration[line_config] = this.options.line_config[line_config];
        }
        Vex.Merge(this.options.line_config[line_config], lines_configuration[line_config]);
      }

      this.options.line_config = lines_configuration;

      return this;
    }
  };

  return Stave;
}());

// Vex Flow Notation
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Muthanna 2010
//
// Requires vex.js.

/** @constructor */
Vex.Flow.StaveConnector = (function() {
  function StaveConnector(top_stave, bottom_stave) {
    this.init(top_stave, bottom_stave);
  }

  // SINGLE_LEFT and SINGLE are the same value for compatibility
  // with older versions of vexflow which didn't have right sided
  // stave connectors
  StaveConnector.type = {
    SINGLE_RIGHT : 0,
    SINGLE_LEFT : 1,
    SINGLE: 1,
    DOUBLE: 2,
    BRACE: 3,
    BRACKET: 4,
    BOLD_DOUBLE_LEFT: 5,
    BOLD_DOUBLE_RIGHT: 6,
    THIN_DOUBLE: 7
  };

  StaveConnector.prototype = {
    init: function(top_stave, bottom_stave) {
      this.thickness = Vex.Flow.STAVE_LINE_THICKNESS;
      this.width = 3;
      this.top_stave = top_stave;
      this.bottom_stave = bottom_stave;
      this.type = StaveConnector.type.DOUBLE;
      this.x_shift = 0; // Mainly used to offset Bold Double Left to align with offset Repeat Begin bars
    },

    setContext: function(ctx) {
      this.ctx = ctx;
      return this;
    },

    setType: function(type) {
      if (type >= StaveConnector.type.SINGLE_RIGHT &&
          type <= StaveConnector.type.THIN_DOUBLE)
        this.type = type;
      return this;
    },

    setText: function(text, text_options) {
      this.text = text;
      this.text_options = {
        shift_x: 0,
        shift_y: 0
      };
      Vex.Merge(this.text_options, text_options);

      this.font = {
        family: "times",
        size: 16,
        weight: "normal"
      };
      return this;
    },

    setFont: function(font) {
      Vex.Merge(this.font, font);
    },

    setXShift: function(x_shift){
      if (typeof x_shift !== 'number') {
        throw Vex.RERR("InvalidType", "x_shift must be a Number");
      }

      this.x_shift = x_shift;
      return this;
    },

    draw: function() {
      if (!this.ctx) throw new Vex.RERR(
          "NoContext", "Can't draw without a context.");
      var topY = this.top_stave.getYForLine(0);
      var botY = this.bottom_stave.getYForLine(this.bottom_stave.getNumLines() - 1) +
        this.thickness;
      var width = this.width;
      var topX = this.top_stave.getX();

      var isRightSidedConnector = (
        this.type === StaveConnector.type.SINGLE_RIGHT ||
        this.type === StaveConnector.type.BOLD_DOUBLE_RIGHT ||
        this.type === StaveConnector.type.THIN_DOUBLE
      );

      if (isRightSidedConnector){
        topX = this.top_stave.getX() + this.top_stave.width;
      }

      var attachment_height = botY - topY;
      switch (this.type) {
        case StaveConnector.type.SINGLE:
          width = 1;
          break;
        case StaveConnector.type.SINGLE_LEFT:
          width = 1;
          break;
        case StaveConnector.type.SINGLE_RIGHT:
          width = 1;
          break;
        case StaveConnector.type.DOUBLE:
          topX -= (this.width + 2);
          break;
        case StaveConnector.type.BRACE:
          width = 12;
          // May need additional code to draw brace
          var x1 = this.top_stave.getX() - 2;
          var y1 = topY;
          var x3 = x1;
          var y3 = botY;
          var x2 = x1 - width;
          var y2 = y1 + attachment_height/2.0;
          var cpx1 = x2 - (0.90 * width);
          var cpy1 = y1 + (0.2 * attachment_height);
          var cpx2 = x1 + (1.10 * width);
          var cpy2 = y2 - (0.135 * attachment_height);
          var cpx3 = cpx2;
          var cpy3 = y2 + (0.135 * attachment_height);
          var cpx4 = cpx1;
          var cpy4 = y3 - (0.2 * attachment_height);
          var cpx5 = x2 - width;
          var cpy5 = cpy4;
          var cpx6 = x1 + (0.40 * width);
          var cpy6 = y2 + (0.135 * attachment_height);
          var cpx7 = cpx6;
          var cpy7 = y2 - (0.135 * attachment_height);
          var cpx8 = cpx5;
          var cpy8 = cpy1;
          this.ctx.beginPath();
          this.ctx.moveTo(x1, y1);
          this.ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
          this.ctx.bezierCurveTo(cpx3, cpy3, cpx4, cpy4, x3, y3);
          this.ctx.bezierCurveTo(cpx5, cpy5, cpx6, cpy6, x2, y2);
          this.ctx.bezierCurveTo(cpx7, cpy7, cpx8, cpy8, x1, y1);
          this.ctx.fill();
          this.ctx.stroke();
          break;
        case StaveConnector.type.BRACKET:
          topY -= 4;
          botY += 4;
          attachment_height = botY - topY;
          Vex.Flow.renderGlyph(this.ctx, topX - 5, topY - 3, 40, "v1b", true);
          Vex.Flow.renderGlyph(this.ctx, topX - 5, botY + 3, 40, "v10", true);
          topX -= (this.width + 2);
          break;
        case StaveConnector.type.BOLD_DOUBLE_LEFT:
          drawBoldDoubleLine(this.ctx, this.type, topX + this.x_shift, topY, botY);
          break;
        case StaveConnector.type.BOLD_DOUBLE_RIGHT:
          drawBoldDoubleLine(this.ctx, this.type, topX, topY, botY);
          break;
        case StaveConnector.type.THIN_DOUBLE:
          width = 1;
          break;
      }

      if (this.type !== StaveConnector.type.BRACE &&
        this.type !== StaveConnector.type.BOLD_DOUBLE_LEFT &&
        this.type !== StaveConnector.type.BOLD_DOUBLE_RIGHT) {
        this.ctx.fillRect(topX , topY, width, attachment_height);
      }

      // If the connector is a thin double barline, draw the paralell line
      if (this.type === StaveConnector.type.THIN_DOUBLE) {
        this.ctx.fillRect(topX - 3, topY, width, attachment_height);
      }

      // Add stave connector text
      if (this.text !== undefined) {
        this.ctx.save();
        this.ctx.lineWidth = 2;
        this.ctx.setFont(this.font.family, this.font.size, this.font.weight);
        var text_width = this.ctx.measureText("" + this.text).width;

        var x = this.top_stave.getX() - text_width - 24 + this.text_options.shift_x;
        var y = (this.top_stave.getYForLine(0) + this.bottom_stave.getBottomLineY()) / 2 +
          this.text_options.shift_y;

        this.ctx.fillText("" + this.text, x, y + 4);
        this.ctx.restore();
      }
    }
  };

  function drawBoldDoubleLine(ctx, type, topX, topY, botY){
    if (type !== StaveConnector.type.BOLD_DOUBLE_LEFT &&
        type !== StaveConnector.type.BOLD_DOUBLE_RIGHT) {
      throw Vex.RERR("InvalidConnector",
        "A REPEAT_BEGIN or REPEAT_END type must be provided.");
    }

    var x_shift = 3;
    var variableWidth = 3.5; // Width for avoiding anti-aliasing width issues
    var thickLineOffset = 2; // For aesthetics

    if (type === StaveConnector.type.BOLD_DOUBLE_RIGHT) {
      x_shift = -5; // Flips the side of the thin line
      variableWidth = 3;
    }

    // Thin line
    ctx.fillRect(topX + x_shift, topY, 1, botY - topY);
    // Thick line
    ctx.fillRect(topX - thickLineOffset, topY, variableWidth, botY - topY);
  }

  return StaveConnector;
}());
// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Cheppudira 2010

/** @constructor */
Vex.Flow.TabStave = (function() {
  function TabStave(x, y, width, options) {
    if (arguments.length > 0) this.init(x, y, width, options);
  }

  Vex.Inherit(TabStave, Vex.Flow.Stave, {
    init: function(x, y, width, options) {
      var tab_options = {
        spacing_between_lines_px: 13,
        num_lines: 6,
        top_text_position: 1
      };

      Vex.Merge(tab_options, options);
      TabStave.superclass.init.call(this, x, y, width, tab_options);
    },

    getYForGlyphs: function() {
      return this.getYForLine(2.5);
    },

    addTabGlyph: function() {
      var glyphScale;
      var glyphOffset;

      switch(this.options.num_lines) {
        case 8:
          glyphScale = 55;
          glyphOffset = 14;
          break;
        case 7:
          glyphScale = 47;
          glyphOffset = 8;
          break;
        case 6:
          glyphScale = 40;
          glyphOffset = 1;
          break;
        case 5:
          glyphScale = 30;
          glyphOffset = -6;
          break;
        case 4:
          glyphScale = 23;
          glyphOffset = -12;
          break;
      }

      var tabGlyph = new Vex.Flow.Glyph("v2f", glyphScale);
      tabGlyph.y_shift = glyphOffset;
      this.addGlyph(tabGlyph);
      return this;
    }
  });

  return TabStave;
}());
// Vex Flow
// Copyright Mohit Cheppudira <mohit@muthanna.com>
//
// A formatter for abstract tickable objects, such as notes, chords,
// tabs, etc.

/** @constructor */
Vex.Flow.TickContext = (function() {
  function TickContext() {
    this.init();
  }

  TickContext.prototype = {
    init: function() {
      this.currentTick = new Vex.Flow.Fraction(0, 1);
      this.maxTicks = new Vex.Flow.Fraction(0, 1);
      this.minTicks = null;
      this.width = 0;
      this.padding = 3;     // padding on each side (width += padding * 2)
      this.pixelsUsed = 0;
      this.x = 0;
      this.tickables = [];   // Notes, tabs, chords, lyrics.
      this.notePx = 0;       // width of widest note in this context
      this.extraLeftPx = 0;  // Extra left pixels for modifers & displace notes
      this.extraRightPx = 0; // Extra right pixels for modifers & displace notes
      this.align_center = false;

      this.tContexts = [];   // Parent array of tick contexts

      // Ignore this tick context for formatting and justification
      this.ignore_ticks = true;
      this.preFormatted = false;
      this.postFormatted = false;
      this.context = null; // Rendering context
    },

    setContext: function(context) { this.context = context; return this; },
    getContext: function() { return this.context; },
    shouldIgnoreTicks: function() { return this.ignore_ticks; },
    getWidth: function() { return this.width + (this.padding * 2); },
    getX: function() { return this.x; },
    setX: function(x) { this.x = x; return this; },
    getPixelsUsed: function() { return this.pixelsUsed; },
    setPixelsUsed: function(pixelsUsed) { this.pixelsUsed = pixelsUsed; return this; },
    setPadding: function(padding) { this.padding = padding; return this; },
    getMaxTicks: function() { return this.maxTicks; },
    getMinTicks: function() { return this.minTicks; },
    getTickables: function() { return this.tickables; },

    getCenterAlignedTickables: function() {
      return this.tickables.filter(function(tickable) {
        return tickable.isCenterAligned();
      });
    },

    // Get widths context, note and left/right modifiers for formatting
    getMetrics: function() {
      return { width: this.width, notePx: this.notePx,
               extraLeftPx: this.extraLeftPx, extraRightPx: this.extraRightPx };
    },

    getCurrentTick: function() { return this.currentTick; },
    setCurrentTick: function(tick) {
      this.currentTick = tick;
      this.preFormatted = false;
    },

    // Get left & right pixels used for modifiers
    getExtraPx: function() {
      var left_shift = 0;
      var right_shift = 0;
      var extraLeftPx = 0;
      var extraRightPx = 0;
      for (var i = 0; i < this.tickables.length; i++) {
        extraLeftPx = Math.max(this.tickables[i].extraLeftPx, extraLeftPx);
        extraRightPx = Math.max(this.tickables[i].extraRightPx, extraRightPx);
        var mContext = this.tickables[i].modifierContext;
        if (mContext && mContext != null) {
          left_shift = Math.max( left_shift, mContext.state.left_shift);
          right_shift = Math.max( right_shift, mContext.state.right_shift);
        }
      }
      return { left: left_shift, right: right_shift,
               extraLeft: extraLeftPx, extraRight: extraRightPx };
    },

    addTickable: function(tickable) {
      if (!tickable) {
        throw new Vex.RERR("BadArgument", "Invalid tickable added.");
      }

      if (!tickable.shouldIgnoreTicks()) {
        this.ignore_ticks = false;

        var ticks = tickable.getTicks();

        if (ticks.greaterThan(this.maxTicks)) {
          this.maxTicks = ticks.clone();
        }

        if (this.minTicks == null) {
          this.minTicks = ticks.clone();
        } else if (ticks.lessThan(this.minTicks)) {
          this.minTicks = ticks.clone();
        }
      }

      tickable.setTickContext(this);
      this.tickables.push(tickable);
      this.preFormatted = false;
      return this;
    },

    preFormat: function() {
      if (this.preFormatted) return;

      for (var i = 0; i < this.tickables.length; ++i) {
        var tickable = this.tickables[i];
        tickable.preFormat();
        var metrics = tickable.getMetrics();

        // Maintain max extra pixels from all tickables in the context
        this.extraLeftPx = Math.max(this.extraLeftPx,
                                    metrics.extraLeftPx + metrics.modLeftPx);
        this.extraRightPx = Math.max(this.extraRightPx,
                                     metrics.extraRightPx + metrics.modRightPx);

        // Maintain the widest note for all tickables in the context
        this.notePx = Math.max(this.notePx, metrics.noteWidth);

        // Recalculate the tick context total width
        this.width = this.notePx +
                     this.extraLeftPx +
                     this.extraRightPx;
      }

      return this;
    },

    postFormat: function() {
      if (this.postFormatted) return this;
      this.postFormatted = true;
      return this;
    }
  };

  TickContext.getNextContext = function(tContext) {
    var contexts = tContext.tContexts;
    var index = contexts.indexOf(tContext);

    return contexts[index+1];
  };

  return TickContext;
}());

// Vex Flow
// Copyright Mohit Cheppudira <mohit@muthanna.com>
//
// The tickable interface. Tickables are things that sit on a score and
// have a duration, i.e., they occupy space in the musical rendering dimension.

/** @constructor */
Vex.Flow.Tickable = (function() {
  function Tickable() {
    this.init();
  }

  Tickable.prototype = {
    init: function() {
      this.intrinsicTicks = 0;
      this.tickMultiplier = new Vex.Flow.Fraction(1, 1);
      this.ticks = new Vex.Flow.Fraction(0, 1);
      this.width = 0;
      this.x_shift = 0; // Shift from tick context
      this.voice = null;
      this.tickContext = null;
      this.modifierContext = null;
      this.modifiers = [];
      this.preFormatted = false;
      this.postFormatted = false;
      this.tuplet = null;

      // For interactivity
      this.id = null;
      this.elem = null;

      this.align_center = false;
      this.center_x_shift = 0; // Shift from tick context if center aligned

      // This flag tells the formatter to ignore this tickable during
      // formatting and justification. It is set by tickables such as BarNote.
      this.ignore_ticks = false;
      this.context = null;
    },

    setContext: function(context) { this.context = context; },

    // Set the DOM ID of the element. Must be called before draw(). TODO: Update
    // ID of element if has already been rendered.
    setId: function(id) { this.id = id; },
    getId: function() { return this.id; },
    getElem: function() { return this.elem; },
    getBoundingBox: function() { return null; },
    getTicks: function() { return this.ticks; },
    shouldIgnoreTicks: function() { return this.ignore_ticks; },
    getWidth: function() { return this.width; },
    setXShift: function(x) { this.x_shift = x; },
    getCenterXShift: function() {
      if (this.isCenterAligned()) {
        return this.center_x_shift;
      }

      return 0;
    },

    isCenterAligned: function() { return this.align_center; },
    setCenterAlignment: function(align_center) {
      this.align_center = align_center;
      return this;
    },

    // Every tickable must be associated with a voice. This allows formatters
    // and preFormatter to associate them with the right modifierContexts.
    getVoice: function() {
      if (!this.voice) throw new Vex.RERR("NoVoice", "Tickable has no voice.");
      return this.voice;
    },
    setVoice: function(voice) { this.voice = voice; },

    getTuplet: function() { return this.tuplet; },
    setTuplet: function(tuplet) {
      // Detach from previous tuplet
      var noteCount, beatsOccupied;

      if (this.tuplet) {
        noteCount = this.tuplet.getNoteCount();
        beatsOccupied = this.tuplet.getBeatsOccupied();

        // Revert old multiplier
        this.applyTickMultiplier(noteCount, beatsOccupied);
      }

      // Attach to new tuplet
      if (tuplet) {
        noteCount = tuplet.getNoteCount();
        beatsOccupied = tuplet.getBeatsOccupied();

        this.applyTickMultiplier(beatsOccupied, noteCount);
      }

      this.tuplet = tuplet;

      return this;
    },

    /** optional, if tickable has modifiers **/
    addToModifierContext: function(mc) {
      this.modifierContext = mc;
      // Add modifiers to modifier context (if any)
      this.preFormatted = false;
    },

    /** optional, if tickable has modifiers **/
    addModifier: function(mod) {
      this.modifiers.push(mod);
      this.preFormatted = false;
      return this;
    },

    setTickContext: function(tc) {
      this.tickContext = tc;
      this.preFormatted = false;
    },

    preFormat: function() {
      if (this.preFormatted) return;

      this.width = 0;
      if (this.modifierContext) {
        this.modifierContext.preFormat();
        this.width += this.modifierContext.getWidth();
      }
    },
    postFormat: function() {
      if (this.postFormatted) return;
      this.postFormatted = true;
      return this;
    },
    getIntrinsicTicks: function() {
      return this.intrinsicTicks;
    },
    setIntrinsicTicks: function(intrinsicTicks) {
      this.intrinsicTicks = intrinsicTicks;
      this.ticks = this.tickMultiplier.clone().multiply(this.intrinsicTicks);
    },
    getTickMultiplier: function() {
      return this.tickMultiplier;
    },
    applyTickMultiplier: function(numerator, denominator) {
      this.tickMultiplier.multiply(numerator, denominator);
      this.ticks = this.tickMultiplier.clone().multiply(this.intrinsicTicks);
    },
    setDuration: function(duration) {
      var ticks = duration.numerator * (Vex.Flow.RESOLUTION / duration.denominator);
      this.ticks = this.tickMultiplier.clone().multiply(ticks);
      this.intrinsicTicks = this.ticks.value();
    }
  };

  return Tickable;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements an abstract interface for notes and chords that
// are rendered on a stave. Notes have some common properties: All of them
// have a value (e.g., pitch, fret, etc.) and a duration (quarter, half, etc.)
//
// Some notes have stems, heads, dots, etc. Most notational elements that
// surround a note are called *modifiers*, and every note has an associated
// array of them. All notes also have a rendering context and belong to a stave.

Vex.Flow.Note = (function() {
  // To create a new note you need to provide a `note_struct`, which consists
  // of the following fields:
  //
  // `type`: The note type (e.g., `r` for rest, `s` for slash notes, etc.)
  // `dots`: The number of dots, which affects the duration.
  // `duration`: The time length (e.g., `q` for quarter, `h` for half, `8` for eighth etc.)
  //
  // The range of values for these parameters are available in `src/tables.js`.
  function Note(note_struct) {
    if (arguments.length > 0) this.init(note_struct);
  }
  Note.CATEGORY = "note";

  // Debug helper. Displays various note metrics for the given
  // note.
  Note.plotMetrics = function(ctx, note, yPos) {
    var metrics = note.getMetrics();
    var w = metrics.width;
    var xStart = note.getAbsoluteX() - metrics.modLeftPx - metrics.extraLeftPx;
    var xPre1 = note.getAbsoluteX() - metrics.extraLeftPx;
    var xAbs = note.getAbsoluteX();
    var xPost1 = note.getAbsoluteX() + metrics.noteWidth;
    var xPost2 = note.getAbsoluteX() + metrics.noteWidth + metrics.extraRightPx;
    var xEnd = note.getAbsoluteX() + metrics.noteWidth + metrics.extraRightPx + metrics.modRightPx;

    var xWidth = xEnd - xStart;
    ctx.save();
    ctx.setFont("Arial", 8, "");
    ctx.fillText(Math.round(xWidth) + "px", xStart + note.getXShift(), yPos);

    var y = (yPos + 7);
    function stroke(x1, x2, color) {
      ctx.beginPath();
      ctx.setStrokeStyle(color);
      ctx.setFillStyle(color);
      ctx.setLineWidth(3);
      ctx.moveTo(x1 + note.getXShift(), y);
      ctx.lineTo(x2 + note.getXShift(), y);
      ctx.stroke();
    }

    stroke(xStart, xPre1, "red");
    stroke(xPre1, xAbs, "#999");
    stroke(xAbs, xPost1, "green");
    stroke(xPost1, xPost2, "#999");
    stroke(xPost2, xEnd, "red");
    stroke(xStart - note.getXShift(), xStart, "#DDD"); // Shift
    Vex.drawDot(ctx, xAbs + note.getXShift(), y, "blue");
    ctx.restore();
  };

  // ## Prototype Methods
  //
  // Every note is a tickable, i.e., it can be mutated by the `Formatter` class for
  // positioning and layout.
  Vex.Inherit(Note, Vex.Flow.Tickable, {
    // See constructor above for how to create a note.
    init: function(note_struct) {
      Note.superclass.init.call(this);

      if (!note_struct) {
        throw new Vex.RuntimeError("BadArguments",
            "Note must have valid initialization data to identify " +
            "duration and type.");
      }

      // Parse `note_struct` and get note properties.
      var initData = Vex.Flow.parseNoteData(note_struct);
      if (!initData) {
        throw new Vex.RuntimeError("BadArguments",
            "Invalid note initialization object: " + JSON.stringify(note_struct));
      }

      // Set note properties from parameters.
      this.duration = initData.duration;
      this.dots = initData.dots;
      this.noteType = initData.type;

      if (note_struct.duration_override) {
        // Custom duration
        this.setDuration(note_struct.duration_override);
      } else {
        // Default duration
        this.setIntrinsicTicks(initData.ticks);
      }

      this.modifiers = [];

      // Get the glyph code for this note from the font.
      this.glyph = Vex.Flow.durationToGlyph(this.duration, this.noteType);

      if (this.positions &&
          (typeof(this.positions) != "object" || !this.positions.length)) {
        throw new Vex.RuntimeError(
          "BadArguments", "Note keys must be array type.");
      }

      // Note to play for audio players.
      this.playNote = null;

      // Positioning contexts used by the Formatter.
      this.tickContext = null;    // The current tick context.
      this.modifierContext = null;
      this.ignore_ticks = false;

      // Positioning variables
      this.width = 0;             // Width in pixels calculated after preFormat
      this.extraLeftPx = 0;       // Extra room on left for offset note head
      this.extraRightPx = 0;      // Extra room on right for offset note head
      this.x_shift = 0;           // X shift from tick context X
      this.left_modPx = 0;        // Max width of left modifiers
      this.right_modPx = 0;       // Max width of right modifiers
      this.voice = null;          // The voice that this note is in
      this.preFormatted = false;  // Is this note preFormatted?
      this.ys = [];               // list of y coordinates for each note
                                  // we need to hold on to these for ties and beams.

      if (note_struct.align_center) {
        this.setCenterAlignment(note_struct.align_center);
      }

      // The render surface.
      this.context = null;
      this.stave = null;
      this.render_options = {
        annotation_spacing: 5,
        stave_padding: 12
      };
    },

    // Get and set the play note, which is arbitrary data that can be used by an
    // audio player.
    getPlayNote: function() { return this.playNote; },
    setPlayNote: function(note) { this.playNote = note; return this; },

    // Don't play notes by default, call them rests. This is also used by things like
    // beams and dots for positioning.
    isRest: function() { return false; },

    // TODO(0xfe): Why is this method here?
    addStroke: function(index, stroke) {
      stroke.setNote(this);
      stroke.setIndex(index);
      this.modifiers.push(stroke);
      this.setPreFormatted(false);
      return this;
    },

    // Get and set the target stave.
    getStave: function() { return this.stave; },
    setStave: function(stave) {
      this.stave = stave;
      this.setYs([stave.getYForLine(0)]); // Update Y values if the stave is changed.
      this.context = this.stave.context;
      return this;
    },


    // `Note` is not really a modifier, but is used in
    // a `ModifierContext`.
    getCategory: function() { return this.constructor.CATEGORY; },

    // Set the rendering context for the note.
    setContext: function(context) { this.context = context; return this; },

    // Get and set spacing to the left and right of the notes.
    getExtraLeftPx: function() { return this.extraLeftPx; },
    getExtraRightPx: function() { return this.extraRightPx; },
    setExtraLeftPx: function(x) { this.extraLeftPx = x; return this; },
    setExtraRightPx: function(x) { this.extraRightPx = x; return this; },

    // Returns true if this note has no duration (e.g., bar notes, spacers, etc.)
    shouldIgnoreTicks: function() { return this.ignore_ticks; },

    // Get the stave line number for the note.
    getLineNumber: function() { return 0; },

    // Get the stave line number for rest.
    getLineForRest: function() { return 0; },

    // Get the glyph associated with this note.
    getGlyph: function() { return this.glyph; },

    // Set and get Y positions for this note. Each Y value is associated with
    // an individual pitch/key within the note/chord.
    setYs: function(ys) { this.ys = ys; return this; },
    getYs: function() {
      if (this.ys.length === 0) throw new Vex.RERR("NoYValues",
          "No Y-values calculated for this note.");
      return this.ys;
    },

    // Get the Y position of the space above the stave onto which text can
    // be rendered.
    getYForTopText: function(text_line) {
      if (!this.stave) throw new Vex.RERR("NoStave",
          "No stave attached to this note.");
      return this.stave.getYForTopText(text_line);
    },

    // Get a `BoundingBox` for this note.
    getBoundingBox: function() { return null; },

    // Returns the voice that this note belongs in.
    getVoice: function() {
      if (!this.voice) throw new Vex.RERR("NoVoice", "Note has no voice.");
      return this.voice;
    },

    // Attach this note to `voice`.
    setVoice: function(voice) {
      this.voice = voice;
      this.preFormatted = false;
      return this;
    },

    // Get and set the `TickContext` for this note.
    getTickContext: function() { return this.tickContext; },
    setTickContext: function(tc) {
      this.tickContext = tc;
      this.preFormatted = false;
      return this;
    },

    // Accessors for the note type.
    getDuration: function() { return this.duration; },
    isDotted: function() { return (this.dots > 0); },
    hasStem: function() { return false; },
    getDots: function() { return this.dots; },
    getNoteType: function() { return this.noteType; },
    setBeam: function() { return this; }, // ignore parameters

    // Attach this note to a modifier context.
    setModifierContext: function(mc) { this.modifierContext = mc; return this; },

    // Attach a modifier to this note.
    addModifier: function(modifier, index) {
      modifier.setNote(this);
      modifier.setIndex(index || 0);
      this.modifiers.push(modifier);
      this.setPreFormatted(false);
      return this;
    },

    // Get the coordinates for where modifiers begin.
    getModifierStartXY: function() {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call GetModifierStartXY on an unformatted note");
      return {x: this.getAbsoluteX(), y: this.ys[0]};
    },

    // Get bounds and metrics for this note.
    //
    // Returns a struct with fields:
    // `width`: The total width of the note (including modifiers.)
    // `noteWidth`: The width of the note head only.
    // `left_shift`: The horizontal displacement of the note.
    // `modLeftPx`: Start `X` for left modifiers.
    // `modRightPx`: Start `X` for right modifiers.
    // `extraLeftPx`: Extra space on left of note.
    // `extraRightPx`: Extra space on right of note.
    getMetrics: function() {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call getMetrics on an unformatted note.");
      var modLeftPx = 0;
      var modRightPx = 0;
      if (this.modifierContext != null) {
        modLeftPx = this.modifierContext.state.left_shift;
        modRightPx = this.modifierContext.state.right_shift;
      }

      var width = this.getWidth();
      return { width: width,
               noteWidth: width -
                          modLeftPx - modRightPx -
                          this.extraLeftPx - this.extraRightPx,
               left_shift: this.x_shift, // TODO(0xfe): Make style consistent


               // Modifiers, accidentals etc.
               modLeftPx: modLeftPx,
               modRightPx: modRightPx,

               // Displaced note head on left or right.
               extraLeftPx: this.extraLeftPx,
               extraRightPx: this.extraRightPx };
    },

    // Get and set width of note. Used by the formatter for positioning.
    setWidth: function(width) { this.width = width; },
    getWidth: function() {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call GetWidth on an unformatted note.");
      return this.width +
        (this.modifierContext ?  this.modifierContext.getWidth() : 0);
    },

    // Displace note by `x` pixels. Used by the formatter.
    setXShift: function(x) { this.x_shift = x; return this; },
    getXShift: function() { return this.x_shift; },

    // Get `X` position of this tick context.
    getX: function() {
      if (!this.tickContext) throw new Vex.RERR("NoTickContext",
          "Note needs a TickContext assigned for an X-Value");
      return this.tickContext.getX() + this.x_shift;
    },

    // Get the absolute `X` position of this note's tick context. This
    // excludes x_shift, so you'll need to factor it in if you're
    // looking for the post-formatted x-position.
    getAbsoluteX: function() {
      if (!this.tickContext) throw new Vex.RERR("NoTickContext",
          "Note needs a TickContext assigned for an X-Value");

      // Position note to left edge of tick context.
      var x = this.tickContext.getX();
      if (this.stave) {
        x += this.stave.getNoteStartX() + this.render_options.stave_padding;
      }

      if (this.isCenterAligned()){
        x += this.getCenterXShift();
      }

      return x;
    },

    setPreFormatted: function(value) {
      this.preFormatted = value;

      // Maintain the width of left and right modifiers in pixels.
      if (this.preFormatted) {
        var extra = this.tickContext.getExtraPx();
        this.left_modPx = Math.max(this.left_modPx, extra.left);
        this.right_modPx = Math.max(this.right_modPx, extra.right);
      }
    }
  });

  return Note;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements `NoteHeads`. `NoteHeads` are typically not manipulated
// directly, but used internally in `StaveNote`.
//
// See `tests/notehead_tests.js` for usage examples.
Vex.Flow.NoteHead = (function() {
  var NoteHead = function(head_options) {
    if (arguments.length > 0) this.init(head_options);
  };

  // To enable logging for this class. Set `Vex.Flow.NoteHead.DEBUG` to `true`.
  function L() { if (NoteHead.DEBUG) Vex.L("Vex.Flow.NoteHead", arguments); }


  // Draw slashnote head manually. No glyph exists for this.
  //
  // Parameters:
  // * `ctx`: the Canvas context
  // * `duration`: the duration of the note. ex: "4"
  // * `x`: the x coordinate to draw at
  // * `y`: the y coordinate to draw at
  // * `stem_direction`: the direction of the stem
  function drawSlashNoteHead(ctx, duration, x, y, stem_direction) {
    var width = 15 + (Vex.Flow.STEM_WIDTH / 2);
    ctx.save();
    ctx.setLineWidth(Vex.Flow.STEM_WIDTH);

    var fill = false;

    if (Vex.Flow.durationToNumber(duration) > 2) {
      fill = true;
    }

    if (!fill) x -= (Vex.Flow.STEM_WIDTH / 2) * stem_direction;

    ctx.beginPath();
    ctx.moveTo(x, y + 11);
    ctx.lineTo(x, y + 1);
    ctx.lineTo(x + width, y - 10);
    ctx.lineTo(x + width, y);
    ctx.lineTo(x, y + 11);
    ctx.closePath();

    if (fill) {
       ctx.fill();
    } else {
       ctx.stroke();
    }

    if (Vex.Flow.durationToFraction(duration).equals(0.5)) {
      var breve_lines = [-3, -1, width + 1, width + 3];
      for(var i=0; i<breve_lines.length; i++){
          ctx.beginPath();
          ctx.moveTo(x + breve_lines[i], y - 10);
          ctx.lineTo(x + breve_lines[i], y + 11);
          ctx.stroke();
      }
    }

    ctx.restore();
  }

  // ## Prototype Methods
  Vex.Inherit(NoteHead, Vex.Flow.Note, {
    init: function(head_options) {
      NoteHead.superclass.init.call(this, head_options);
      this.index = head_options.index;
      this.x = head_options.x || 0;
      this.y = head_options.y || 0;
      this.note_type = head_options.note_type;
      this.duration = head_options.duration;
      this.displaced = head_options.displaced || false;
      this.stem_direction = head_options.stem_direction || Vex.Flow.StaveNote.STEM_UP;
      this.line = head_options.line;

      // Get glyph code based on duration and note type. This could be
      // regular notes, rests, or other custom codes.
      this.glyph = Vex.Flow.durationToGlyph(this.duration, this.note_type);
      if (!this.glyph) {
        throw new Vex.RuntimeError("BadArguments",
            "No glyph found for duration '" + this.duration +
            "' and type '" + this.note_type + "'");
      }

      this.glyph_code = this.glyph.code_head;
      this.x_shift = head_options.x_shift;
      if (head_options.custom_glyph_code) {
        this.custom_glyph = true;
        this.glyph_code = head_options.custom_glyph_code;
      }

      this.context = null;
      this.style = head_options.style;
      this.slashed = head_options.slashed;

      Vex.Merge(this.render_options, {
        glyph_font_scale: 35, // font size for note heads
        stroke_px: 3         // number of stroke px to the left and right of head
      });

      if (head_options.glyph_font_scale) {
        this.render_options.glyph_font_scale = head_options.glyph_font_scale;
      }

      this.setWidth(this.glyph.head_width);
    },

    // Get the `ModifierContext` category
    getCategory: function() { return "notehead"; },

    // Set the Cavnas context for drawing
    setContext: function(context) { this.context = context; return this;},

    // Get the width of the notehead
    getWidth: function() { return this.width; },

    // Determine if the notehead is displaced
    isDisplaced: function() { return this.displaced === true; },

    // Get/set the notehead's style
    //
    // `style` is an `object` with the following properties: `shadowColor`,
    // `shadowBlur`, `fillStyle`, `strokeStyle`
    getStyle: function() { return this.style; },
    setStyle: function(style) { this.style = style; return this; },

    // Get the glyph data
    getGlyph: function(){ return this.glyph; },

    // Set the X coordinate
    setX: function(x){ this.x = x; return this; },

    // get/set the Y coordinate
    getY: function() { return this.y; },
    setY: function(y) { this.y = y;  return this; },

    // Get/set the stave line the notehead is placed on
    getLine: function() { return this.line; },
    setLine: function(line) { this.line = line; return this; },

    // Get the canvas `x` coordinate position of the notehead.
    getAbsoluteX: function() {
      var getAbsoluteX = NoteHead.superclass.getAbsoluteX;

      // If the note has not been preformatted, then get the static x value
      // Otherwise, it's been formatted and we should use it's x value relative
      // to its tick context
      var x = !this.preFormatted ? this.x : getAbsoluteX.call(this);

      return x + (this.displaced ? this.width * this.stem_direction : 0);
    },

    // Get the `BoundingBox` for the `NoteHead`
    getBoundingBox: function() {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call getBoundingBox on an unformatted note.");

      var spacing = this.stave.getSpacingBetweenLines();
      var half_spacing = spacing/2;
      var min_y = this.y - half_spacing;

      return new Vex.Flow.BoundingBox(this.getAbsoluteX(), min_y, this.width, spacing);
    },

    // Apply current style to Canvas `context`
    applyStyle: function(context) {
      var style = this.getStyle();
      if (style.shadowColor) context.setShadowColor(style.shadowColor);
      if (style.shadowBlur) context.setShadowBlur(style.shadowBlur);
      if (style.fillStyle) context.setFillStyle(style.fillStyle);
      if (style.strokeStyle) context.setStrokeStyle(style.strokeStyle);
      return this;
    },

    // Set notehead to a provided `stave`
    setStave: function(stave){
      var line = this.getLine();

      this.stave = stave;
      this.setY(stave.getYForNote(line));
      this.context = this.stave.context;
      return this;
    },

    // Pre-render formatting
    preFormat: function() {
      if (this.preFormatted) return this;

      var glyph = this.getGlyph();
      var width = glyph.head_width + this.extraLeftPx + this.extraRightPx;

      this.setWidth(width);
      this.setPreFormatted(true);
      return this;
    },

    // Draw the notehead
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      var ctx = this.context;
      var head_x = this.getAbsoluteX();
      var y = this.y;

      L("Drawing note head '", this.note_type, this.duration, "' at", head_x, y);

      // Begin and end positions for head.
      var stem_direction = this.stem_direction;
      var glyph_font_scale = this.render_options.glyph_font_scale;

      var line = this.line;

      // If note above/below the staff, draw the small staff
      if (line <= 0 || line >= 6) {
        var line_y = y;
        var floor = Math.floor(line);
        if (line < 0 && floor - line == -0.5)
          line_y -= 5;
        else if (line > 6 &&  floor - line == -0.5)
          line_y += 5;
        if (this.note_type != 'r') {
          ctx.fillRect(
            head_x - this.render_options.stroke_px, line_y,
            (this.getGlyph().head_width) +
            (this.render_options.stroke_px * 2), 1);
        }
      }

      if (this.note_type == "s") {
        drawSlashNoteHead(ctx, this.duration,
          head_x, y, stem_direction);
      } else {
        if (this.style) {
          ctx.save();
          this.applyStyle(ctx);
          Vex.Flow.renderGlyph(ctx, head_x, y, glyph_font_scale, this.glyph_code);
          ctx.restore();
        } else {
          Vex.Flow.renderGlyph(ctx, head_x, y, glyph_font_scale, this.glyph_code);
        }
      }
    }
  });

  return NoteHead;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements the `Stem` object. Generally this object is handled
// by its parent `StemmableNote`.
//
Vex.Flow.Stem = (function() {
  var Stem = function(options) {
    if (arguments.length > 0) this.init(options);
  };

  // To enable logging for this class. Set `Vex.Flow.Stem.DEBUG` to `true`.
  function L() { if (Stem.DEBUG) Vex.L("Vex.Flow.Stem", arguments); }

  // Stem directions
  Stem.UP = 1;
  Stem.DOWN = -1;

  // Theme
  Stem.WIDTH = Vex.Flow.STEM_WIDTH;
  Stem.HEIGHT = Vex.Flow.STEM_HEIGHT;

  // ## Prototype Methods
  Stem.prototype = {
    init: function(options) {
      // Default notehead x bounds
      this.x_begin = options.x_begin || 0;
      this.x_end = options.x_end || 0;

      // Y bounds for top/bottom most notehead
      this.y_top = options.y_top || 0;
      this.y_bottom = options.y_bottom || 0;

      // Stem base extension
      this.y_extend = options.y_extend || 0;
      // Stem top extension
      this.stem_extension = options.stem_extension || 0;

      // Direction of the stem
      this.stem_direction = options.stem_direction || 0;

      // Flag to override all draw calls
      this.hide = false;
    },

    // Set the x bounds for the default notehead
    setNoteHeadXBounds: function(x_begin, x_end) {
      this.x_begin = x_begin;
      this.x_end = x_end;
      return this;
    },

    // Set the direction of the stem in relation to the noteheads
    setDirection: function(direction){ this.stem_direction = direction; },

    // Set the extension for the stem, generally for flags or beams
    setExtension: function(ext) { this.stem_extension = ext; },

    // The the y bounds for the top and bottom noteheads
    setYBounds: function(y_top, y_bottom) {
      this.y_top = y_top;
      this.y_bottom = y_bottom;
    },

    // The category of the object
    getCategory: function() { return "stem"; },

    // Set the canvas context to render on
    setContext: function(context) { this.context = context; return this;},

    // Gets the entire height for the stem
    getHeight: function() {
      return ((this.y_bottom - this.y_top) * this.stem_direction) +
             ((Stem.HEIGHT + this.stem_extension) * this.stem_direction);
    },

    getBoundingBox: function() {
      throw new Vex.RERR("NotImplemented", "getBoundingBox() not implemented.");
    },

    // Get the y coordinates for the very base of the stem to the top of
    // the extension
    getExtents: function() {
      var ys = [this.y_top, this.y_bottom];

      var top_pixel = this.y_top;
      var base_pixel = this.y_bottom;
      var stem_height = Stem.HEIGHT + this.stem_extension;

      for (var i = 0; i < ys.length; ++i) {
        var stem_top = ys[i] + (stem_height * -this.stem_direction);

        if (this.stem_direction == Stem.DOWN) {
          top_pixel = Math.max(top_pixel, stem_top);
          base_pixel = Math.min(base_pixel, ys[i]);
        } else {
          top_pixel = Math.min(top_pixel, stem_top);
          base_pixel = Math.max(base_pixel, ys[i]);
        }
      }

      return { topY: top_pixel, baseY: base_pixel };
    },

    // set the draw style of a stem:
    setStyle: function(style) { this.style = style; return this; },
    getStyle: function() { return this.style; },

    // Apply current style to Canvas `context`
    applyStyle: function(context) {
      var style = this.getStyle();
      if(style) {
        if (style.shadowColor) context.setShadowColor(style.shadowColor);
        if (style.shadowBlur) context.setShadowBlur(style.shadowBlur);
        if (style.strokeStyle) context.setStrokeStyle(style.strokeStyle);
      }
      return this;
    },

    // Render the stem onto the canvas
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      if (this.hide) return;

      var ctx = this.context;
      var stem_x, stem_y;
      var stem_direction = this.stem_direction;

      if (stem_direction == Stem.DOWN) {
        // Down stems are rendered to the left of the head.
        stem_x = this.x_begin + (Stem.WIDTH / 2);
        stem_y = this.y_top + 2;
      } else {
        // Up stems are rendered to the right of the head.
        stem_x = this.x_end + (Stem.WIDTH / 2);
        stem_y = this.y_bottom - 2;
      }

      stem_y += this.y_extend * stem_direction;

      L("Rendering stem - ", "Top Y: ", this.y_top, "Bottom Y: ", this.y_bottom);

      // Draw the stem
      ctx.save();
      this.applyStyle(ctx);
      ctx.beginPath();
      ctx.setLineWidth(Stem.WIDTH);
      ctx.moveTo(stem_x, stem_y);
      ctx.lineTo(stem_x, stem_y - this.getHeight());
      ctx.stroke();
      ctx.restore();
    }
  };

  return Stem;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// `StemmableNote` is an abstract interface for notes with optional stems.
// Examples of stemmable notes are `StaveNote` and `TabNote`
Vex.Flow.StemmableNote = (function(){
  var StemmableNote = function(note_struct) {
    if (arguments.length > 0) this.init(note_struct);
  };

  // To enable logging for this class. Set `Vex.Flow.StemmableNote.DEBUG` to `true`.
  function L() { if (StemmableNote.DEBUG) Vex.L("Vex.Flow.StemmableNote", arguments); }

  var Stem = Vex.Flow.Stem;

  Vex.Inherit(StemmableNote, Vex.Flow.Note, {
    init: function(note_struct){
      StemmableNote.superclass.init.call(this, note_struct);

      this.stem = null;
      this.stem_extension_override = null;
      this.beam = null;

    },

    // Get and set the note's `Stem`
    getStem: function() {return this.stem; },
    setStem: function(stem) { this.stem = stem; return this; },

    // Builds and sets a new stem
    buildStem: function() {
      var stem = new Stem();
      this.setStem(stem);
      return this;
    },

    // Get the full length of stem
    getStemLength: function() {
      return Stem.HEIGHT + this.getStemExtension();
    },

    // Get the number of beams for this duration
    getBeamCount: function(){
      var glyph = this.getGlyph();

      if (glyph) {
        return glyph.beam_count;
      } else {
        return 0;
      }
    },

    // Get the minimum length of stem
    getStemMinumumLength: function() {
      var frac = Vex.Flow.durationToFraction(this.duration);
      var length = (frac.value() <= 1) ? 0 : 20;
      // if note is flagged, cannot shorten beam
      switch (this.duration) {
       case "8":
         if (this.beam == null) length = 35;
         break;
       case "16":
         if (this.beam == null)
           length = 35;
         else
           length = 25;
         break;
       case "32":
         if (this.beam == null)
           length = 45;
         else
           length = 35;
         break;
       case "64":
         if (this.beam == null)
           length = 50;
         else
           length = 40;
         break;
       case "128":
         if (this.beam == null)
           length = 55;
         else
           length = 45;
      }
      return length;
    },

    // Get/set the direction of the stem
    getStemDirection: function() { return this.stem_direction; },
    setStemDirection: function(direction) {
      if (!direction) direction = Stem.UP;
      if (direction != Stem.UP &&
          direction != Stem.DOWN) {
        throw new Vex.RERR("BadArgument", "Invalid stem direction: " +
            direction);
      }

      this.stem_direction = direction;
      if (this.stem) {
        this.stem.setDirection(direction);
        this.stem.setExtension(this.getStemExtension());
      }

      this.beam = null;
      if (this.preFormatted) {
        this.preFormat();
      }
      return this;
    },

    // Get the `x` coordinate of the stem
    getStemX: function() {
      var x_begin = this.getAbsoluteX() + this.x_shift;
      var x_end = this.getAbsoluteX() + this.x_shift + this.glyph.head_width;

      var stem_x = this.stem_direction == Stem.DOWN ?
        x_begin : x_end;

      stem_x -= ((Stem.WIDTH / 2) * this.stem_direction);

      return stem_x;
    },

    // Get the `x` coordinate for the center of the glyph.
    // Used for `TabNote` stems and stemlets over rests
    getCenterGlyphX: function(){
      return this.getAbsoluteX() + this.x_shift + (this.glyph.head_width / 2);
    },

    // Get the stem extension for the current duration
    getStemExtension: function(){
      var glyph = this.getGlyph();

      if (this.stem_extension_override != null) {
        return this.stem_extension_override;
      }

      if (glyph) {
        return this.getStemDirection() === 1 ? glyph.stem_up_extension :
          glyph.stem_down_extension;
      }

      return 0;
    },

    // Set the stem length to a specific. Will override the default length.
    setStemLength: function(height) {
      this.stem_extension_override = (height - Stem.HEIGHT);
      return this;
    },

    // Get the top and bottom `y` values of the stem.
    getStemExtents: function() {
      if (!this.ys || this.ys.length === 0) throw new Vex.RERR("NoYValues",
          "Can't get top stem Y when note has no Y values.");

      var top_pixel = this.ys[0];
      var base_pixel = this.ys[0];
      var stem_height = Stem.HEIGHT + this.getStemExtension();

      for (var i = 0; i < this.ys.length; ++i) {
        var stem_top = this.ys[i] + (stem_height * -this.stem_direction);

        if (this.stem_direction == Stem.DOWN) {
          top_pixel = Math.max(top_pixel, stem_top);
          base_pixel = Math.min(base_pixel, this.ys[i]);
        } else {
          top_pixel = Math.min(top_pixel, stem_top);
          base_pixel = Math.max(base_pixel, this.ys[i]);
        }

        if(this.noteType == "s" || this.noteType == 'x') {
          top_pixel -= this.stem_direction * 7;
          base_pixel -= this.stem_direction * 7;
        }
      }

      L("Stem extents: ", top_pixel, base_pixel);
      return { topY: top_pixel, baseY: base_pixel };
    },

    // Sets the current note's beam
    setBeam: function(beam) { this.beam = beam; return this; },

    // Get the `y` value for the top/bottom modifiers at a specific `text_line`
    getYForTopText: function(text_line) {
      var extents = this.getStemExtents();
      if (this.hasStem()) {
        return Vex.Min(this.stave.getYForTopText(text_line),
            extents.topY - (this.render_options.annotation_spacing * (text_line + 1)));
      } else {
        return this.stave.getYForTopText(text_line);
      }
    },

    getYForBottomText: function(text_line) {
      var extents = this.getStemExtents();
      if (this.hasStem()) {
        return Vex.Max(this.stave.getYForTopText(text_line),
          extents.baseY + (this.render_options.annotation_spacing * (text_line)));
      } else {
        return this.stave.getYForBottomText(text_line);
      }
    },

    hasFlag: function() {
      return Vex.Flow.durationToGlyph(this.duration).flag;
    },

    // Post format the note
    postFormat: function() {
      if (this.beam) {
        this.beam.postFormat();
      }
      this.postFormatted = true;
      return this;
    },

    // Render the stem onto the canvas
    drawStem: function(stem_struct){
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      this.setStem(new Stem(stem_struct));
      this.stem.setContext(this.context).draw();
    }
  });

  return StemmableNote;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements notes for standard notation. This consists of one or
// more `NoteHeads`, an optional stem, and an optional flag.
//
// *Throughout these comments, a "note" refers to the entire `StaveNote`,
// and a "key" refers to a specific pitch/notehead within a note.*
//
// See `tests/stavenote_tests.js` for usage examples.
Vex.Flow.StaveNote = (function() {
  var StaveNote = function(note_struct) {
    if (arguments.length > 0) this.init(note_struct);
  };
  StaveNote.CATEGORY = "stavenotes";

  // To enable logging for this class. Set `Vex.Flow.StaveNote.DEBUG` to `true`.
  function L() { if (StaveNote.DEBUG) Vex.L("Vex.Flow.StaveNote", arguments); }

  var Stem = Vex.Flow.Stem;
  var NoteHead = Vex.Flow.NoteHead;

  // Stem directions
  StaveNote.STEM_UP = Stem.UP;
  StaveNote.STEM_DOWN = Stem.DOWN;

  // Helper methods for rest positioning in ModifierContext.
  var shiftRestVertical = function(rest, note, dir) {
    var delta = (note.isrest ? 0.0 : 1.0) * dir;

    rest.line += delta;
    rest.max_line += delta;
    rest.min_line += delta;
    rest.note.setKeyLine(0, rest.note.getKeyLine(0) + (delta));
  };

  // Called from formatNotes :: center a rest between two notes
  var centerRest = function(rest, noteU, noteL) {
    var delta = rest.line - Vex.MidLine(noteU.min_line, noteL.max_line);
    rest.note.setKeyLine(0, rest.note.getKeyLine(0) - delta);
    rest.line -= delta;
    rest.max_line -= delta;
    rest.min_line -= delta;
  };

  // ## Static Methods
  //
  // Format notes inside a ModifierContext.
  StaveNote.format = function(notes, state) {
    if (!notes || notes.length < 2) return false;

    if (notes[0].getStave() != null) return StaveNote.formatByY(notes, state);

    var notes_list= [];

    for (var i = 0; i < notes.length; i++) {
      var props = notes[i].getKeyProps();
      var line = props[0].line;
      var minL = props[props.length -1].line;
      var stem_dir = notes[i].getStemDirection();
      var stem_max = notes[i].getStemLength() / 10;
      var stem_min = notes[i].getStemMinumumLength() / 10;

      var maxL;
      if (notes[i].isRest()) {
        maxL = line + notes[i].glyph.line_above;
        minL = line - notes[i].glyph.line_below;
      } else {
        maxL = stem_dir == 1 ? props[props.length -1].line + stem_max
             : props[props.length -1].line;
        minL = stem_dir == 1 ? props[0].line
             : props[0].line - stem_max;
      }
      notes_list.push(
        {line: props[0].line,         // note/rest base line
         max_line: maxL,              // note/rest upper bounds line
         min_line: minL,              // note/rest lower bounds line
         isrest: notes[i].isRest(),
         stem_dir: stem_dir,
         stem_max: stem_max,          // Maximum (default) note stem length;
         stem_min: stem_min,          // minimum note stem length
         voice_shift: notes[i].getVoiceShiftWidth(),
         is_displaced: notes[i].isDisplaced(),   // note manually displaced
         note: notes[i]});
    }

    var voices = notes_list.length;

    var noteU = notes_list[0];
    var noteM = voices > 2 ? notes_list[1] : null;
    var noteL = voices > 2 ? notes_list[2] : notes_list[1];

    // for two voice backward compatibility, ensure upper voice is stems up
    // for three voices, the voices must be in order (upper, middle, lower)
    if (voices == 2 && noteU.stem_dir == -1 && noteL.stem_dir == 1) {
      noteU = notes_list[1];
      noteL = notes_list[0];
    }

    var voice_x_shift = Math.max(noteU.voice_shift, noteL.voice_shift);
    var x_shift = 0;
    var stem_delta;

    // Test for two voice note intersection
    if (voices == 2) {
      var line_spacing = noteU.stem_dir == noteL.stem_dir ? 0.0 : 0.5;
      // if top voice is a middle voice, check stem intersection with lower voice
      if (noteU.stem_dir == noteL.stem_dir &&
          noteU.min_line <= noteL.max_line) {
        if (!noteU.isrest) {
          stem_delta = Math.abs(noteU.line - (noteL.max_line + 0.5));
          stem_delta = Math.max(stem_delta, noteU.stem_min);
          noteU.min_line = noteU.line - stem_delta;
          noteU.note.setStemLength(stem_delta * 10);
        }
      }
      if (noteU.min_line <= noteL.max_line + line_spacing) {
        if (noteU.isrest) {
          // shift rest up
          shiftRestVertical(noteU, noteL, 1);
        } else if (noteL.isrest) {
          // shift rest down
          shiftRestVertical(noteL, noteU, -1);
        } else {
          x_shift = voice_x_shift;
          if (noteU.stem_dir == noteL.stem_dir)
            // upper voice is middle voice, so shift it right
            noteU.note.setXShift(x_shift + 3);
          else
            // shift lower voice right
            noteL.note.setXShift(x_shift);
        }
      }

      // format complete
      return true;
    }

    // Check middle voice stem intersection with lower voice
    if (noteM != null && noteM.min_line < noteL.max_line + 0.5) {
      if (!noteM.isrest) {
        stem_delta = Math.abs(noteM.line - (noteL.max_line + 0.5));
        stem_delta = Math.max(stem_delta, noteM.stem_min);
        noteM.min_line = noteM.line - stem_delta;
        noteM.note.setStemLength(stem_delta * 10);
      }
    }

    // For three voices, test if rests can be repositioned
    //
    // Special case 1 :: middle voice rest between two notes
    //
    if (noteM.isrest && !noteU.isrest && !noteL.isrest) {
      if (noteU.min_line <= noteM.max_line ||
          noteM.min_line <= noteL.max_line) {
         var rest_height = noteM.max_line - noteM.min_line;
         var space = noteU.min_line - noteL.max_line;
         if (rest_height < space)
           // center middle voice rest between the upper and lower voices
           centerRest(noteM, noteU, noteL);
         else {
           x_shift = voice_x_shift + 3;    // shift middle rest right
           noteM.note.setXShift(x_shift);
         }
         // format complete
         return true;
      }
    }

    // Special case 2 :: all voices are rests
    if (noteU.isrest && noteM.isrest && noteL.isrest) {
      // Shift upper voice rest up
      shiftRestVertical(noteU, noteM, 1);
      // Shift lower voice rest down
      shiftRestVertical(noteL, noteM, -1);
      // format complete
      return true;
    }

    // Test if any other rests can be repositioned
    if (noteM.isrest && noteU.isrest && noteM.min_line <= noteL.max_line)
      // Shift middle voice rest up
      shiftRestVertical(noteM, noteL, 1);
    if (noteM.isrest && noteL.isrest && noteU.min_line <= noteM.max_line)
      // Shift middle voice rest down
      shiftRestVertical(noteM, noteU, -1);
    if (noteU.isrest && noteU.min_line <= noteM.max_line)
      // shift upper voice rest up;
      shiftRestVertical(noteU, noteM, 1);
    if (noteL.isrest && noteM.min_line <= noteL.max_line)
      // shift lower voice rest down
      shiftRestVertical(noteL, noteM, -1);

    // If middle voice intersects upper or lower voice
    if ((!noteU.isrest && !noteM.isrest && noteU.min_line <= noteM.max_line + 0.5) ||
        (!noteM.isrest && !noteL.isrest && noteM.min_line <= noteL.max_line)) {
      x_shift = voice_x_shift + 3;      // shift middle note right
      noteM.note.setXShift(x_shift);
    }

    return true;
  };

  StaveNote.formatByY = function(notes, state) {
    // NOTE: this function does not support more than two voices per stave
    //       use with care.
    var hasStave = true;
    var i;

    for (i = 0; i < notes.length; i++) {
      hasStave = hasStave && notes[i].getStave() != null;
    }

    if (!hasStave) throw new Vex.RERR("Stave Missing",
      "All notes must have a stave - Vex.Flow.ModifierContext.formatMultiVoice!");

    var x_shift = 0;

    for (i = 0; i < notes.length - 1; i++) {
      var top_note = notes[i];
      var bottom_note = notes[i + 1];

      if (top_note.getStemDirection() == Vex.Flow.StaveNote.STEM_DOWN) {
        top_note = notes[i + 1];
        bottom_note = notes[i];
      }

      var top_keys = top_note.getKeyProps();
      var bottom_keys = bottom_note.getKeyProps();

      var topY = top_note.getStave().getYForLine(top_keys[0].line);
      var bottomY = bottom_note.getStave().getYForLine(bottom_keys[bottom_keys.length - 1].line);

      var line_space = top_note.getStave().options.spacing_between_lines_px;
      if (Math.abs(topY - bottomY) == line_space / 2) {
        x_shift = top_note.getVoiceShiftWidth();
        bottom_note.setXShift(x_shift);
      }
    }

    state.right_shift += x_shift;
  };

  StaveNote.postFormat = function(notes) {
    if (!notes) return false;

    notes.forEach(function(note) {
      note.postFormat();
    });

    return true;
  };

  // ## Prototype Methods
  //
  Vex.Inherit(StaveNote, Vex.Flow.StemmableNote, {
    init: function(note_struct) {
      StaveNote.superclass.init.call(this, note_struct);

      this.keys = note_struct.keys;
      this.clef = note_struct.clef;
      this.octave_shift = note_struct.octave_shift;
      this.beam = null;

      // Pull note rendering properties
      this.glyph = Vex.Flow.durationToGlyph(this.duration, this.noteType);
      if (!this.glyph) {
        throw new Vex.RuntimeError("BadArguments",
            "Invalid note initialization data (No glyph found): " +
            JSON.stringify(note_struct));
      }

      // if true, displace note to right
      this.displaced = false;
      this.dot_shiftY = 0;
      // per-pitch properties
      this.keyProps = [];
      // for displaced ledger lines
      this.use_default_head_x = false;

      // Drawing
      this.note_heads = [];
      this.modifiers = [];

      Vex.Merge(this.render_options, {
        // font size for note heads and rests
        glyph_font_scale: 35,
        // number of stroke px to the left and right of head
        stroke_px: 3
      });

      this.calculateKeyProps();

      this.buildStem();

      // Set the stem direction
      if (note_struct.auto_stem) {
        this.autoStem();
      } else {
        this.setStemDirection(note_struct.stem_direction);
      }

      this.buildNoteHeads();

      // Calculate left/right padding
      this.calcExtraPx();
    },

    // Builds a `Stem` for the note
    buildStem: function() {
      var glyph = this.getGlyph();

      var y_extend = 0;
      if (glyph.code_head == "v95" || glyph.code_head == "v3e") {
         y_extend = -4;
      }

      var stem = new Stem({
        y_extend: y_extend
      });

      if (this.isRest()) {
        stem.hide = true;
      }

      this.setStem(stem);
    },

    // Builds a `NoteHead` for each key in the note
    buildNoteHeads: function() {
      var stem_direction = this.getStemDirection();

      var keys = this.getKeys();

      var last_line = null;
      var line_diff = null;
      var displaced = false;

      // Draw notes from bottom to top.
      var start_i = 0;
      var end_i = keys.length;
      var step_i = 1;

      // For down-stem notes, we draw from top to bottom.
      if (stem_direction === Stem.DOWN) {
        start_i = keys.length - 1;
        end_i = -1;
        step_i = -1;
      }

      for (var i = start_i; i != end_i; i += step_i) {
        var note_props = this.keyProps[i];

        var line = note_props.line;

        // Keep track of last line with a note head, so that consecutive heads
        // are correctly displaced.
        if (last_line === null) {
          last_line = line;
        } else {
          line_diff = Math.abs(last_line - line);
          if (line_diff === 0 || line_diff === 0.5) {
            displaced = !displaced;
          } else {
            displaced = false;
            this.use_default_head_x = true;
          }
        }
        last_line = line;

        var note_head = new NoteHead({
          duration: this.duration,
          note_type: this.noteType,
          displaced: displaced,
          stem_direction: stem_direction,
          custom_glyph_code: note_props.code,
          glyph_font_scale: this.render_options.glyph_font_scale,
          x_shift: note_props.shift_right,
          line: note_props.line
        });

        this.note_heads[i] = note_head;
      }
    },

    // Automatically sets the stem direction based on the keys in the note
    autoStem: function() {
      var auto_stem_direction;

      // Figure out optimal stem direction based on given notes
      this.min_line = this.keyProps[0].line;
      this.max_line = this.keyProps[this.keyProps.length - 1].line;
      var decider = (this.min_line + this.max_line) / 2;

      if (decider < 3) {
        auto_stem_direction = 1;
      } else {
        auto_stem_direction = -1;
      }

      this.setStemDirection(auto_stem_direction);
    },

    // Calculates and stores the properties for each key in the note
    calculateKeyProps: function() {
      var last_line = null;
      for (var i = 0; i < this.keys.length; ++i) {
        var key = this.keys[i];

        // All rests use the same position on the line.
        // if (this.glyph.rest) key = this.glyph.position;
        if (this.glyph.rest) this.glyph.position = key;
        var options = { octave_shift: this.octave_shift || 0 };
        var props = Vex.Flow.keyProperties(key, this.clef, options);
        if (!props) {
          throw new Vex.RuntimeError("BadArguments",
              "Invalid key for note properties: " + key);
        }

        // Override line placement for default rests
        if (props.key === "R") {
          if (this.duration === "1" || this.duration === "w") {
            props.line = 4;
          } else {
            props.line = 3;
          }
        }

        // Calculate displacement of this note
        var line = props.line;
        if (last_line === null) {
          last_line = line;
        } else {
          if (Math.abs(last_line - line) == 0.5) {
            this.displaced = true;
            props.displaced = true;

            // Have to mark the previous note as
            // displaced as well, for modifier placement
            if (this.keyProps.length > 0) {
                this.keyProps[i-1].displaced = true;
            }
          }
        }

        last_line = line;
        this.keyProps.push(props);
      }

      // Sort the notes from lowest line to highest line
      var sorted = true;
      var lastLine = -1000;
      var that = this;
      this.keyProps.forEach(function(key) {
        if (key.line < lastLine) {
          Vex.W("Unsorted keys in note will be sorted. " +
            "See https://github.com/0xfe/vexflow/issues/104 for details.");
        }
        lastLine = key.line;
      });
      this.keyProps.sort(function(a, b) { return a.line - b.line; });
    },

    // Get the `BoundingBox` for the entire note
    getBoundingBox: function() {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call getBoundingBox on an unformatted note.");

      var metrics = this.getMetrics();

      var w = metrics.width;
      var x = this.getAbsoluteX() - metrics.modLeftPx - metrics.extraLeftPx;

      var min_y = 0;
      var max_y = 0;
      var half_line_spacing = this.getStave().getSpacingBetweenLines() / 2;
      var line_spacing = half_line_spacing * 2;

      if (this.isRest()) {
        var y = this.ys[0];
        var frac = Vex.Flow.durationToFraction(this.duration);
        if (frac.equals(1) || frac.equals(2)) {
          min_y = y - half_line_spacing;
          max_y = y + half_line_spacing;
        } else {
          min_y = y - (this.glyph.line_above * line_spacing);
          max_y = y + (this.glyph.line_below * line_spacing);
        }
      } else if (this.glyph.stem) {
        var ys = this.getStemExtents();
        ys.baseY += half_line_spacing * this.stem_direction;
        min_y = Vex.Min(ys.topY, ys.baseY);
        max_y = Vex.Max(ys.topY, ys.baseY);
      } else {
        min_y = null;
        max_y = null;

        for (var i=0; i < this.ys.length; ++i) {
          var yy = this.ys[i];
          if (i === 0) {
            min_y = yy;
            max_y = yy;
          } else {
            min_y = Vex.Min(yy, min_y);
            max_y = Vex.Max(yy, max_y);
          }
          min_y -= half_line_spacing;
          max_y += half_line_spacing;
        }
      }

      return new Vex.Flow.BoundingBox(x, min_y, w, max_y - min_y);
    },

    // Gets the line number of the top or bottom note in the chord.
    // If `is_top_note` is `true` then get the top note
    getLineNumber: function(is_top_note) {
      if(!this.keyProps.length) throw new Vex.RERR("NoKeyProps",
          "Can't get bottom note line, because note is not initialized properly.");
      var result_line = this.keyProps[0].line;

      // No precondition assumed for sortedness of keyProps array
      for (var i=0; i<this.keyProps.length; i++) {
        var this_line = this.keyProps[i].line;
        if (is_top_note) {
          if (this_line > result_line) result_line = this_line;
        } else {
          if (this_line < result_line) result_line = this_line;
        }
      }

      return result_line;
    },

    // Determine if current note is a rest
    isRest: function() { return this.glyph.rest; },

    // Determine if the current note is a chord
    isChord: function() { return !this.isRest() && this.keys.length > 1; },

    // Determine if the `StaveNote` has a stem
    hasStem: function() { return this.glyph.stem; },

    // Get the `y` coordinate for text placed on the top/bottom of a
    // note at a desired `text_line`
    getYForTopText: function(text_line) {
      var extents = this.getStemExtents();
      return Vex.Min(this.stave.getYForTopText(text_line),
          extents.topY - (this.render_options.annotation_spacing * (text_line + 1)));
    },
    getYForBottomText: function(text_line) {
      var extents = this.getStemExtents();
      return Vex.Max(this.stave.getYForTopText(text_line),
          extents.baseY + (this.render_options.annotation_spacing * (text_line)));
    },

    // Sets the current note to the provided `stave`. This applies
    // `y` values to the `NoteHeads`.
    setStave: function(stave) {
      var superclass = Vex.Flow.StaveNote.superclass;
      superclass.setStave.call(this, stave);

      var ys = this.note_heads.map(function(note_head) {
        note_head.setStave(stave);
        return note_head.getY();
      });

      this.setYs(ys);

      var bounds = this.getNoteHeadBounds();
	    if (this.hasStem()) {
        this.stem.setYBounds(bounds.y_top, bounds.y_bottom);
      }

      return this;
    },

    // Get the pitches in the note
    getKeys: function() { return this.keys; },

    // Get the properties for all the keys in the note
    getKeyProps: function() {
      return this.keyProps;
    },

    // Check if note is shifted to the right
    isDisplaced: function() {
      return this.displaced;
    },

    // Sets whether shift note to the right. `displaced` is a `boolean`
    setNoteDisplaced: function(displaced) {
      this.displaced = displaced;
      return this;
    },

    // Get the starting `x` coordinate for a `StaveTie`
    getTieRightX: function() {
      var tieStartX = this.getAbsoluteX();
      tieStartX += this.glyph.head_width + this.x_shift + this.extraRightPx;
      if (this.modifierContext) tieStartX += this.modifierContext.getExtraRightPx();
      return tieStartX;
    },

    // Get the ending `x` coordinate for a `StaveTie`
    getTieLeftX: function() {
      var tieEndX = this.getAbsoluteX();
      tieEndX += this.x_shift - this.extraLeftPx;
      return tieEndX;
    },

    // Get the stave line on which to place a rest
    getLineForRest: function() {
      var rest_line = this.keyProps[0].line;
      if (this.keyProps.length > 1) {
        var last_line  = this.keyProps[this.keyProps.length - 1].line;
        var top = Vex.Max(rest_line, last_line);
        var bot = Vex.Min(rest_line, last_line);
        rest_line = Vex.MidLine(top, bot);
      }

      return rest_line;
    },

    // Get the default `x` and `y` coordinates for the provided `position`
    // and key `index`
    getModifierStartXY: function(position, index) {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call GetModifierStartXY on an unformatted note");

      if (this.ys.length === 0) throw new Vex.RERR("NoYValues",
          "No Y-Values calculated for this note.");

      var x = 0;
      if (position == Vex.Flow.Modifier.Position.LEFT) {
        // extra_left_px
        x = -1 * 2;
      } else if (position == Vex.Flow.Modifier.Position.RIGHT) {
        // extra_right_px
        x = this.glyph.head_width + this.x_shift + 2;
      } else if (position == Vex.Flow.Modifier.Position.BELOW ||
                 position == Vex.Flow.Modifier.Position.ABOVE) {
        x = this.glyph.head_width / 2;
      }

      return { x: this.getAbsoluteX() + x, y: this.ys[index] };
    },

    // Sets the style of the complete StaveNote, including all keys
    // and the stem.
    setStyle: function(style) {
      this.note_heads.forEach(function(notehead) {
        notehead.setStyle(style);
      }, this);
      this.stem.setStyle(style);
    },

    // Sets the notehead at `index` to the provided coloring `style`.
    //
    // `style` is an `object` with the following properties: `shadowColor`,
    // `shadowBlur`, `fillStyle`, `strokeStyle`
    setKeyStyle: function(index, style) {
      this.note_heads[index].setStyle(style);
      return this;
    },

    setKeyLine: function(index, line) {
      this.keyProps[index].line = line;
      this.note_heads[index].setLine(line);
      return this;
    },

    getKeyLine: function(index) {
      return this.keyProps[index].line;
    },

    // Add self to modifier context. `mContext` is the `ModifierContext`
    // to be added to.
    addToModifierContext: function(mContext) {
      this.setModifierContext(mContext);
      for (var i = 0; i < this.modifiers.length; ++i) {
        this.modifierContext.addModifier(this.modifiers[i]);
      }
      this.modifierContext.addModifier(this);
      this.setPreFormatted(false);
      return this;
    },

    // Generic function to add modifiers to a note
    //
    // Parameters:
    // * `index`: The index of the key that we're modifying
    // * `modifier`: The modifier to add
    addModifier: function(index, modifier) {
      modifier.setNote(this);
      modifier.setIndex(index);
      this.modifiers.push(modifier);
      this.setPreFormatted(false);
      return this;
    },

    // Helper function to add an accidental to a key
    addAccidental: function(index, accidental) {
      return this.addModifier(index, accidental);
    },

    // Helper function to add an articulation to a key
    addArticulation: function(index, articulation) {
      return this.addModifier(index, articulation);
    },

    // Helper function to add an annotation to a key
    addAnnotation: function(index, annotation) {
      return this.addModifier(index, annotation);
    },

    // Helper function to add a dot on a specific key
    addDot: function(index) {
      var dot = new Vex.Flow.Dot();
      dot.setDotShiftY(this.glyph.dot_shiftY);
      this.dots++;
      return this.addModifier(index, dot);
    },

    // Convenience method to add dot to all keys in note
    addDotToAll: function() {
      for (var i = 0; i < this.keys.length; ++i)
        this.addDot(i);
      return this;
    },

    // Get all accidentals in the `ModifierContext`
    getAccidentals: function() {
      return this.modifierContext.getModifiers("accidentals");
    },

    // Get all dots in the `ModifierContext`
    getDots: function() {
      return this.modifierContext.getModifiers("dots");
    },

    // Get the width of the note if it is displaced. Used for `Voice`
    // formatting
    getVoiceShiftWidth: function() {
      // TODO: may need to accomodate for dot here.
      return this.glyph.head_width * (this.displaced ? 2 : 1);
    },

    // Calculates and sets the extra pixels to the left or right
    // if the note is displaced.
    calcExtraPx: function() {
      this.setExtraLeftPx((this.displaced && this.stem_direction == -1) ?
          this.glyph.head_width : 0);

      // For upstems with flags, the extra space is unnecessary, since it's taken
      // up by the flag.
      this.setExtraRightPx((!this.hasFlag() && this.displaced && this.stem_direction == 1) ?
          this.glyph.head_width : 0);
    },

    // Pre-render formatting
    preFormat: function() {
      if (this.preFormatted) return;
      if (this.modifierContext) this.modifierContext.preFormat();

      var width = this.glyph.head_width + this.extraLeftPx + this.extraRightPx;

      // For upward flagged notes, the width of the flag needs to be added
      if (this.glyph.flag && this.beam === null && this.stem_direction == 1) {
        width += this.glyph.head_width;
      }

      this.setWidth(width);
      this.setPreFormatted(true);
    },

    // Gets the staff line and y value for the highest and lowest noteheads
    getNoteHeadBounds: function() {
      // Top and bottom Y values for stem.
      var y_top = null;
      var y_bottom = null;

      var highest_line = this.stave.getNumLines();
      var lowest_line = 1;

      this.note_heads.forEach(function(note_head) {
        var line = note_head.getLine();
        var y = note_head.getY();

        if (y_top === null || y < y_top)  {
          y_top = y;
        }

        if (y_bottom === null || y > y_bottom) {
          y_bottom = y;
        }

        highest_line = line > highest_line ? line : highest_line;
        lowest_line = line < lowest_line ? line : lowest_line;

      }, this);

      return {
        y_top: y_top,
        y_bottom: y_bottom,
        highest_line: highest_line,
        lowest_line: lowest_line
      };
    },

    // Get the starting `x` coordinate for the noteheads
    getNoteHeadBeginX: function(){
      return this.getAbsoluteX() + this.x_shift;
    },

    // Get the ending `x` coordinate for the noteheads
    getNoteHeadEndX: function(){
      var x_begin = this.getNoteHeadBeginX();
      return x_begin + this.glyph.head_width - (Vex.Flow.STEM_WIDTH / 2);
    },

    // Draw the ledger lines between the stave and the highest/lowest keys
    drawLedgerLines: function(){
      if (this.isRest()) { return; }
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      var ctx = this.context;

      var bounds = this.getNoteHeadBounds();
      var highest_line = bounds.highest_line;
      var lowest_line = bounds.lowest_line;
      var head_x = this.note_heads[0].getAbsoluteX();

      var that = this;
      function stroke(y) {
        if (that.use_default_head_x === true)  {
          head_x = that.getAbsoluteX() + that.x_shift;
        }
        var x = head_x - that.render_options.stroke_px;
        var length = ((head_x + that.glyph.head_width) - head_x) +
          (that.render_options.stroke_px * 2);

        ctx.fillRect(x, y, length, 1);
      }

      var line; // iterator
      for (line = 6; line <= highest_line; ++line) {
        stroke(this.stave.getYForNote(line));
      }

      for (line = 0; line >= lowest_line; --line) {
        stroke(this.stave.getYForNote(line));
      }
    },

    // Draw all key modifiers
    drawModifiers: function(){
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      var ctx = this.context;
      ctx.openGroup("modifiers");
      for (var i = 0; i < this.modifiers.length; i++) {
        var mod = this.modifiers[i];
        var note_head = this.note_heads[mod.getIndex()];
        var key_style = note_head.getStyle();
        if(key_style) {
            ctx.save();
            note_head.applyStyle(ctx);
        }
        mod.setContext(ctx);
        mod.draw();
        if(key_style) {
            ctx.restore();
        }
      }
      ctx.closeGroup();
    },

    // Draw the flag for the note
    drawFlag: function(){
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      var ctx = this.context;
      var glyph = this.getGlyph();
      var render_flag = this.beam === null;
      var bounds = this.getNoteHeadBounds();

      var x_begin = this.getNoteHeadBeginX();
      var x_end = this.getNoteHeadEndX();

      if (glyph.flag && render_flag) {
        var note_stem_height = this.stem.getHeight();
        var flag_x, flag_y, flag_code;

        if (this.getStemDirection() === Stem.DOWN) {
          // Down stems have flags on the left.
          flag_x = x_begin + 1;
          flag_y = bounds.y_top - note_stem_height + 2;
          flag_code = glyph.code_flag_downstem;

        } else {
          // Up stems have flags on the left.
          flag_x = x_end + 1;
          flag_y = bounds.y_bottom - note_stem_height - 2;
          flag_code = glyph.code_flag_upstem;
        }

        // Draw the Flag
        this.context.openGroup("flag", null, {pointerBBox: true});
        Vex.Flow.renderGlyph(ctx, flag_x, flag_y,
            this.render_options.glyph_font_scale, flag_code);
        this.context.closeGroup();
      }
    },

    // Draw the NoteHeads
    drawNoteHeads: function(){
      var that = this;
      this.note_heads.forEach(function(note_head) {
        that.context.openGroup("notehead", null, {pointerBBox: true});
        note_head.setContext(that.context).draw();
        that.context.closeGroup();
      }, this);
    },

    // Render the stem onto the canvas
    drawStem: function(stem_struct){
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      if (stem_struct) {
        this.setStem(new Stem(stem_struct));
      }

      this.context.openGroup("stem", null, {pointerBBox: true});
      this.stem.setContext(this.context).draw();
      this.context.closeGroup();
    },

    // Draws all the `StaveNote` parts. This is the main drawing method.
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      if (!this.stave) throw new Vex.RERR("NoStave",
          "Can't draw without a stave.");
      if (this.ys.length === 0) throw new Vex.RERR("NoYValues",
          "Can't draw note without Y values.");

      var x_begin = this.getNoteHeadBeginX();
      var x_end = this.getNoteHeadEndX();

      var render_stem = this.hasStem() && !this.beam;

      // Format note head x positions
      this.note_heads.forEach(function(note_head) {
        note_head.setX(x_begin);
      }, this);

      // Format stem x positions
      this.stem.setNoteHeadXBounds(x_begin, x_end);

      L("Rendering ", this.isChord() ? "chord :" : "note :", this.keys);

      // Draw each part of the note
      this.drawLedgerLines();

      this.elem = this.context.openGroup("stavenote", this.id);
      this.context.openGroup("note", null, {pointerBBox: true});
        if (render_stem) this.drawStem();
        this.drawNoteHeads();
        this.drawFlag();
      this.context.closeGroup();
      this.drawModifiers();
      this.context.closeGroup();
    }
  });

  return StaveNote;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// The file implements notes for Tablature notation. This consists of one or
// more fret positions, and can either be drawn with or without stems.
//
// See `tests/tabnote_tests.js` for usage examples
Vex.Flow.TabNote = (function() {
  function TabNote(tab_struct, draw_stem) {
    if (arguments.length > 0) this.init(tab_struct, draw_stem);
  }

  var Stem = Vex.Flow.Stem;

  // ## Prototype Methods
  Vex.Inherit(TabNote, Vex.Flow.StemmableNote, {
    // Initialize the TabNote with a `tab_struct` full of properties
    // and whether to `draw_stem` when rendering the note
    init: function(tab_struct, draw_stem) {
      var superclass = Vex.Flow.TabNote.superclass;
      superclass.init.call(this, tab_struct);

      this.ghost = false; // Renders parenthesis around notes
      // Note properties
      //
      // The fret positions in the note. An array of `{ str: X, fret: X }`
      this.positions = tab_struct.positions;

      // Render Options
      Vex.Merge(this.render_options, {
        // font size for note heads and rests
        glyph_font_scale: 30,
        // Flag to draw a stem
        draw_stem: draw_stem,
        // Flag to draw dot modifiers
        draw_dots: draw_stem,
        // Flag to extend the main stem through the stave and fret positions
        draw_stem_through_stave: false
      });

      this.glyph =
        Vex.Flow.durationToGlyph(this.duration, this.noteType);
      if (!this.glyph) {
        throw new Vex.RuntimeError("BadArguments",
            "Invalid note initialization data (No glyph found): " +
            JSON.stringify(tab_struct));
      }

      this.buildStem();

      if (tab_struct.stem_direction){
        this.setStemDirection(tab_struct.stem_direction);
      } else {
        this.setStemDirection(Stem.UP);
      }

      // Renders parenthesis around notes
      this.ghost = false;
      this.updateWidth();
    },

    // The ModifierContext category
    getCategory: function() { return "tabnotes"; },

    // Set as ghost `TabNote`, surrounds the fret positions with parenthesis.
    // Often used for indicating frets that are being bent to
    setGhost: function(ghost) {
      this.ghost = ghost;
      this.updateWidth();
      return this;
    },

    // Determine if the note has a stem
    hasStem: function() { return this.render_options.draw_stem; },

    // Get the default stem extension for the note
    getStemExtension: function(){
      var glyph = this.getGlyph();

      if (this.stem_extension_override != null) {
        return this.stem_extension_override;
      }

      if (glyph) {
        return this.getStemDirection() === 1 ? glyph.tabnote_stem_up_extension :
          glyph.tabnote_stem_down_extension;
      }

      return 0;
    },

    // Add a dot to the note
    addDot: function() {
      var dot = new Vex.Flow.Dot();
      this.dots++;
      return this.addModifier(dot, 0);
    },

    // Calculate and store the width of the note
    updateWidth: function() {
      this.glyphs = [];
      this.width = 0;
      for (var i = 0; i < this.positions.length; ++i) {
        var fret = this.positions[i].fret;
        if (this.ghost) fret = "(" + fret + ")";
        var glyph = Vex.Flow.tabToGlyph(fret);
        this.glyphs.push(glyph);
        this.width = (glyph.width > this.width) ? glyph.width : this.width;
      }
    },

    // Set the `stave` to the note
    setStave: function(stave) {
      var superclass = Vex.Flow.TabNote.superclass;
      superclass.setStave.call(this, stave);
      this.context = stave.context;
      this.width = 0;

      // Calculate the fret number width based on font used
      var i;
      if (this.context) {
        for (i = 0; i < this.glyphs.length; ++i) {
          var text = "" + this.glyphs[i].text;
          if (text.toUpperCase() != "X")
            this.glyphs[i].width = this.context.measureText(text).width;
          this.width = (this.glyphs[i].width > this.width) ?
            this.glyphs[i].width : this.width;
        }
      }

      var ys = [];

      // Setup y coordinates for score.
      for (i = 0; i < this.positions.length; ++i) {
        var line = this.positions[i].str;
        ys.push(this.stave.getYForLine(line - 1));
      }

      return this.setYs(ys);
    },

    // Get the fret positions for the note
    getPositions: function() { return this.positions; },

    // Add self to the provided modifier context `mc`
    addToModifierContext: function(mc) {
      this.setModifierContext(mc);
      for (var i = 0; i < this.modifiers.length; ++i) {
        this.modifierContext.addModifier(this.modifiers[i]);
      }
      this.modifierContext.addModifier(this);
      this.preFormatted = false;
      return this;
    },

    // Get the `x` coordinate to the right of the note
    getTieRightX: function() {
      var tieStartX = this.getAbsoluteX();
      var note_glyph_width = this.glyph.head_width;
      tieStartX += (note_glyph_width / 2);
      tieStartX += ((-this.width / 2) + this.width + 2);

      return tieStartX;
    },

    // Get the `x` coordinate to the left of the note
    getTieLeftX: function() {
      var tieEndX = this.getAbsoluteX();
      var note_glyph_width = this.glyph.head_width;
      tieEndX += (note_glyph_width / 2);
      tieEndX -= ((this.width / 2) + 2);

      return tieEndX;
    },

    // Get the default `x` and `y` coordinates for a modifier at a specific
    // `position` at a fret position `index`
    getModifierStartXY: function(position, index) {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call GetModifierStartXY on an unformatted note");

      if (this.ys.length === 0) throw new Vex.RERR("NoYValues",
          "No Y-Values calculated for this note.");

      var x = 0;
      if (position == Vex.Flow.Modifier.Position.LEFT) {
        x = -1 * 2;  // extra_left_px
      } else if (position == Vex.Flow.Modifier.Position.RIGHT) {
        x = this.width + 2; // extra_right_px
      } else if (position == Vex.Flow.Modifier.Position.BELOW ||
                 position == Vex.Flow.Modifier.Position.ABOVE) {
          var note_glyph_width = this.glyph.head_width;
          x = note_glyph_width / 2;
      }

      return {x: this.getAbsoluteX() + x, y: this.ys[index]};
    },

    // Get the default line for rest
    getLineForRest: function() { return this.positions[0].str; },

    // Pre-render formatting
    preFormat: function() {
      if (this.preFormatted) return;
      if (this.modifierContext) this.modifierContext.preFormat();
      // width is already set during init()
      this.setPreFormatted(true);
    },

    // Get the x position for the stem
    getStemX: function() { return this.getCenterGlyphX(); },

    // Get the y position for the stem
    getStemY: function(){
      var num_lines = this.stave.getNumLines();

      // The decimal staff line amounts provide optimal spacing between the
      // fret number and the stem
      var stemUpLine = -0.5;
      var stemDownLine = num_lines - 0.5;
      var stemStartLine = Stem.UP === this.stem_direction ? stemUpLine : stemDownLine;

      return this.stave.getYForLine(stemStartLine);
    },

    // Get the stem extents for the tabnote
    getStemExtents: function() {
      var stem_base_y = this.getStemY();
      var stem_top_y = stem_base_y + (Stem.HEIGHT * -this.stem_direction);

      return { topY: stem_top_y , baseY: stem_base_y};
    },

    // Draw the fal onto the context
    drawFlag: function() {
      var render_stem = this.beam == null && this.render_options.draw_stem;
      var render_flag = this.beam == null && render_stem;

      // Now it's the flag's turn.
      if (this.glyph.flag && render_flag) {
        var flag_x = this.getStemX() + 1 ;
        var flag_y = this.getStemY() - (this.stem.getHeight());
        var flag_code;

        if (this.stem_direction == Stem.DOWN) {
          // Down stems have flags on the left.
          flag_code = this.glyph.code_flag_downstem;
        } else {
          // Up stems have flags on the left.
          flag_code = this.glyph.code_flag_upstem;
        }

        // Draw the Flag
        Vex.Flow.renderGlyph(this.context, flag_x, flag_y,
            this.render_options.glyph_font_scale, flag_code);
      }
    },

    // Render the modifiers onto the context
    drawModifiers: function() {
      // Draw the modifiers
      this.modifiers.forEach(function(modifier) {
        // Only draw the dots if enabled
        if (modifier.getCategory() === 'dots' && !this.render_options.draw_dots) return;

        modifier.setContext(this.context);
        modifier.draw();
      }, this);
    },

    // Render the stem extension through the fret positions
    drawStemThrough: function() {
      var stem_x = this.getStemX();
      var stem_y = this.getStemY();
      var ctx = this.context;

      var stem_through = this.render_options.draw_stem_through_stave;
      var draw_stem = this.render_options.draw_stem;
      if (draw_stem && stem_through) {
        var total_lines = this.stave.getNumLines();
        var strings_used = this.positions.map(function(position) {
          return position.str;
        });

        var unused_strings = getUnusedStringGroups(total_lines, strings_used);
        var stem_lines = getPartialStemLines(stem_y, unused_strings,
                              this.getStave(), this.getStemDirection());

        // Fine tune x position to match default stem
        if (!this.beam || this.getStemDirection() === 1) {
          stem_x += (Stem.WIDTH / 2);
        }

        ctx.save();
        ctx.setLineWidth(Stem.WIDTH);
        stem_lines.forEach(function(bounds) {
          if (bounds.length === 0) return;

          ctx.beginPath();
          ctx.moveTo(stem_x, bounds[0]);
          ctx.lineTo(stem_x, bounds[bounds.length - 1]);
          ctx.stroke();
          ctx.closePath();
        });
        ctx.restore();
      }
    },

    // Render the fret positions onto the context
    drawPositions: function() {
      var ctx = this.context;
      var x = this.getAbsoluteX();
      var ys = this.ys;
      var y;

      for (var i = 0; i < this.positions.length; ++i) {
        y = ys[i];

        var glyph = this.glyphs[i];

        // Center the fret text beneath the notation note head
        var note_glyph_width = this.glyph.head_width;
        var tab_x = x + (note_glyph_width / 2) - (glyph.width / 2);

        ctx.clearRect(tab_x - 2, y - 3, glyph.width + 4, 6);

        if (glyph.code) {
          Vex.Flow.renderGlyph(ctx, tab_x, y + 5 + glyph.shift_y,
              this.render_options.glyph_font_scale, glyph.code);
        } else {
          var text = glyph.text.toString();
          ctx.fillText(text, tab_x, y + 5);
        }
      }
    },

    // The main rendering function for the entire note
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      if (!this.stave) throw new Vex.RERR("NoStave", "Can't draw without a stave.");
      if (this.ys.length === 0) throw new Vex.RERR("NoYValues",
          "Can't draw note without Y values.");

      var render_stem = this.beam == null && this.render_options.draw_stem;

      this.drawPositions();
      this.drawStemThrough();

      var stem_x = this.getStemX();
      var stem_y = this.getStemY();
      if (render_stem) {
        this.drawStem({
          x_begin: stem_x,
          x_end: stem_x,
          y_top: stem_y,
          y_bottom: stem_y,
          y_extend: 0,
          stem_extension: this.getStemExtension(),
          stem_direction: this.stem_direction
        });
      }

      this.drawFlag();
      this.drawModifiers();
    }
  });

  // ## Private Helpers
  //
  // Gets the unused strings grouped together if consecutive.
  //
  // Parameters:
  // * num_lines - The number of lines
  // * strings_used - An array of numbers representing which strings have fret positions
  function getUnusedStringGroups(num_lines, strings_used) {
    var stem_through = [];
    var group = [];
    for (var string = 1; string <= num_lines ; string++) {
      var is_used = strings_used.indexOf(string) > -1;

      if (!is_used) {
        group.push(string);
      } else {
        stem_through.push(group);
        group = [];
      }
    }
    if (group.length > 0) stem_through.push(group);

    return stem_through;
  }

  // Gets groups of points that outline the partial stem lines
  // between fret positions
  //
  // Parameters:
  // * stem_Y - The `y` coordinate the stem is located on
  // * unused_strings - An array of groups of unused strings
  // * stave - The stave to use for reference
  // * stem_direction - The direction of the stem
  function getPartialStemLines (stem_y, unused_strings, stave, stem_direction) {
    var up_stem = stem_direction !== 1;
    var down_stem = stem_direction !== -1;

    var line_spacing = stave.getSpacingBetweenLines();
    var total_lines = stave.getNumLines();

    var stem_lines = [];

    unused_strings.forEach(function(strings) {
      var containsLastString = strings.indexOf(total_lines) > -1;
      var containsFirstString =  strings.indexOf(1) > -1;

      if ((up_stem && containsFirstString) ||
         (down_stem && containsLastString)) {
        return;
      }

      // If there's only one string in the group, push a duplicate value.
      // We do this because we need 2 strings to convert into upper/lower y
      // values.
      if (strings.length === 1) {
        strings.push(strings[0]);
      }

      var line_ys = [];
      // Iterate through each group string and store it's y position
      strings.forEach(function(string, index, strings) {
        var isTopBound = string === 1;
        var isBottomBound = string === total_lines;

        // Get the y value for the appropriate staff line,
        // we adjust for a 0 index array, since string numbers are index 1
        var y = stave.getYForLine(string - 1);

        // Unless the string is the first or last, add padding to each side
        // of the line
        if (index === 0 && !isTopBound) {
          y -= line_spacing/2 - 1;
        } else if (index === strings.length - 1 && !isBottomBound){
          y += line_spacing/2 - 1;
        }

        // Store the y value
        line_ys.push(y);

        // Store a subsequent y value connecting this group to the main
        // stem above/below the stave if it's the top/bottom string
        if (stem_direction === 1 && isTopBound) {
          line_ys.push(stem_y - 2);
        } else if (stem_direction === -1 && isBottomBound) {
          line_ys.push(stem_y + 2);
        }
      });

      // Add the sorted y values to the
      stem_lines.push(line_ys.sort(function(a, b) {
        return a - b;
      }));
    });

    return stem_lines;
  }

  return TabNote;
}());

// Vex Flow Notation
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Muthanna 2010
//
// Requires vex.js.

/** @constructor */
Vex.Flow.GhostNote = (function() {
  function GhostNote(duration) {
    if (arguments.length > 0) this.init(duration);
  }

  Vex.Inherit(GhostNote, Vex.Flow.StemmableNote, {
    init: function(parameter) {
      // Sanity check
      if (!parameter) {
        throw new Vex.RuntimeError("BadArguments",
            "Ghost note must have valid initialization data to identify " +
            "duration.");
      }

      var note_struct;

      // Preserve backwards-compatibility
      if (typeof(parameter) === "string") {
        note_struct = { duration: parameter };
      } else if (typeof(parameter) === "object") {
        note_struct = parameter;
      } else {
        throw new Vex.RuntimeError("BadArguments",
            "Ghost note must have valid initialization data to identify " +
            "duration.");
      }

      GhostNote.superclass.init.call(this, note_struct);

      // Note properties
      this.setWidth(0);
    },

    isRest: function() { return true; },

    setStave: function(stave) { GhostNote.superclass.setStave.call(this, stave); },

    addToModifierContext: function()
      { /* intentionally overridden */ return this; },

    preFormat: function() {
      this.setPreFormatted(true);
      return this;
    },

    draw: function() {
      if (!this.stave) throw new Vex.RERR("NoStave", "Can't draw without a stave.");

      // Draw the modifiers
      for (var i = 0; i < this.modifiers.length; ++i) {
        var modifier = this.modifiers[i];
        modifier.setContext(this.context);
        modifier.draw();
      }
    }
  });

  return GhostNote;
}());

// Vex Flow Notation
// Copyright Mohit Muthanna 2010
//
// Author Taehoon Moon 2014

/** @constructor */
Vex.Flow.ClefNote = (function() {
  function ClefNote(clef, size, annotation) { this.init(clef, size, annotation); }

  Vex.Inherit(ClefNote, Vex.Flow.Note, {
    init: function(clef, size, annotation) {
      ClefNote.superclass.init.call(this, {duration: "b"});
      
      this.setClef(clef, size, annotation);

      // Note properties
      this.ignore_ticks = true;
    },

    setClef: function(clef, size, annotation) {
      this.clef_obj = new Vex.Flow.Clef(clef, size, annotation);
      this.clef = this.clef_obj.clef;
      this.glyph = new Vex.Flow.Glyph(this.clef.code, this.clef.point);
      this.setWidth(this.glyph.getMetrics().width);
      return this;
    },

    getClef: function() {
      return this.clef;
    },

    setContext: function(context){
      this.context = context;
      this.glyph.setContext(this.context);
      return this;
    },

    setStave: function(stave) {
      var superclass = Vex.Flow.ClefNote.superclass;
      superclass.setStave.call(this, stave);
    },

    getBoundingBox: function() {
      return new Vex.Flow.BoundingBox(0, 0, 0, 0);
    },

    addToModifierContext: function() {
      /* overridden to ignore */
      return this;
    },

    getCategory: function() {
      return "clefnote";
    },

    preFormat: function() {
      this.setPreFormatted(true);
      return this;
    },

    draw: function() {
      if (!this.stave) throw new Vex.RERR("NoStave", "Can't draw without a stave.");
      
      if (!this.glyph.getContext()) {
        this.glyph.setContext(this.context);
      }
      var abs_x = this.getAbsoluteX();

      this.glyph.setStave(this.stave);
      this.glyph.setYShift(
        this.stave.getYForLine(this.clef.line) - this.stave.getYForGlyphs());
      this.glyph.renderToStave(abs_x);
      
      // If the Vex.Flow.Clef has an annotation, such as 8va, draw it.
      if (this.clef_obj.annotation !== undefined) {
        var attachment = new Vex.Flow.Glyph(this.clef_obj.annotation.code, this.clef_obj.annotation.point);
        if (!attachment.getContext()) {
            attachment.setContext(this.context);
        }
        attachment.setStave(this.stave);
        attachment.setYShift(
          this.stave.getYForLine(this.clef_obj.annotation.line) - this.stave.getYForGlyphs());
        attachment.setXShift(this.clef_obj.annotation.x_shift);
        attachment.renderToStave(abs_x);
      }
      
    }
  });

  return ClefNote;
}());

// Vex Flow Notation
// Copyright Mohit Muthanna 2010
//
// Author Taehoon Moon 2014

/** @constructor */
Vex.Flow.TimeSigNote = (function() {
  function TimeSigNote(timeSpec, customPadding) {
    if (arguments.length > 0) this.init(timeSpec, customPadding);
  }

  Vex.Inherit(TimeSigNote, Vex.Flow.Note, {
    init: function(timeSpec, customPadding) {
      TimeSigNote.superclass.init.call(this, {duration: "b"});

      var timeSignature = new Vex.Flow.TimeSignature(timeSpec, customPadding);
      this.timeSig = timeSignature.getTimeSig();
      this.setWidth(this.timeSig.glyph.getMetrics().width);

      // Note properties
      this.ignore_ticks = true;
    },

    setStave: function(stave) {
      var superclass = Vex.Flow.TimeSigNote.superclass;
      superclass.setStave.call(this, stave);
    },

    getBoundingBox: function() {
      return new Vex.Flow.BoundingBox(0, 0, 0, 0);
    },

    addToModifierContext: function() {
      /* overridden to ignore */
      return this;
    },

    preFormat: function() {
      this.setPreFormatted(true);
      return this;
    },

    draw: function() {
      if (!this.stave) throw new Vex.RERR("NoStave", "Can't draw without a stave.");
      
      if (!this.timeSig.glyph.getContext()) {
        this.timeSig.glyph.setContext(this.context);
      }

      this.timeSig.glyph.setStave(this.stave);
      this.timeSig.glyph.setYShift(
        this.stave.getYForLine(this.timeSig.line) - this.stave.getYForGlyphs());
      this.timeSig.glyph.renderToStave(this.getAbsoluteX());
    }
  });

  return TimeSigNote;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements `Beams` that span over a set of `StemmableNotes`.
//
// Requires: vex.js, vexmusic.js, note.js
Vex.Flow.Beam = (function() {
  function Beam(notes, auto_stem) {
    if (arguments.length > 0) this.init(notes, auto_stem);
  }

  var Stem = Vex.Flow.Stem;

  // ## Prototype Methods
  Beam.prototype = {
    init: function(notes, auto_stem) {
      if (!notes || notes == []) {
        throw new Vex.RuntimeError("BadArguments", "No notes provided for beam.");
      }

      if (notes.length == 1) {
        throw new Vex.RuntimeError("BadArguments", "Too few notes for beam.");
      }

      // Validate beam line, direction and ticks.
      this.ticks = notes[0].getIntrinsicTicks();

      if (this.ticks >= Vex.Flow.durationToTicks("4")) {
        throw new Vex.RuntimeError("BadArguments",
            "Beams can only be applied to notes shorter than a quarter note.");
      }

      var i; // shared iterator
      var note;

      this.stem_direction = Stem.UP;

      for (i = 0; i < notes.length; ++i) {
        note = notes[i];
        if (note.hasStem()) {
          this.stem_direction = note.getStemDirection();
          break;
        }
      }

      var stem_direction = this.stem_direction;
      // Figure out optimal stem direction based on given notes
      if (auto_stem && notes[0].getCategory() === 'stavenotes')  {
        stem_direction = calculateStemDirection(notes);
      } else if (auto_stem && notes[0].getCategory() === 'tabnotes') {
        // Auto Stem TabNotes
        var stem_weight = notes.reduce(function(memo, note) {
          return memo + note.stem_direction;
        }, 0);

        stem_direction = stem_weight > -1 ? Stem.UP : Stem.DOWN;
      }

      // Apply stem directions and attach beam to notes
      for (i = 0; i < notes.length; ++i) {
        note = notes[i];
        if (auto_stem) {
          note.setStemDirection(stem_direction);
          this.stem_direction = stem_direction;
        }
        note.setBeam(this);
      }

      this.postFormatted = false;
      this.notes = notes;
      this.beam_count = this.getBeamCount();
      this.break_on_indices = [];
      this.render_options = {
        beam_width: 5,
        max_slope: 0.25,
        min_slope: -0.25,
        slope_iterations: 20,
        slope_cost: 100,
        show_stemlets: false,
        stemlet_extension: 7,
        partial_beam_length: 10,
        flat_beams: false,
        min_flat_beam_offset: 15
      };
    },

    // The the rendering `context`
    setContext: function(context) { this.context = context; return this; },

    // Get the notes in this beam
    getNotes: function() { return this.notes; },

    // Get the max number of beams in the set of notes
    getBeamCount: function(){
      var beamCounts =  this.notes.map(function(note) {
        return note.getGlyph().beam_count;
      });

      var maxBeamCount =  beamCounts.reduce(function(max, beamCount) {
          return beamCount > max ? beamCount : max;
      });

      return maxBeamCount;
    },

    // Set which note `indices` to break the secondary beam at
    breakSecondaryAt: function(indices) {
      this.break_on_indices = indices;
      return this;
    },

    // Return the y coordinate for linear function
    getSlopeY: function(x, first_x_px, first_y_px, slope) {
      return first_y_px + ((x - first_x_px) * slope);
    },

    // Calculate the best possible slope for the provided notes
    calculateSlope: function() {
      var first_note = this.notes[0];
      var first_y_px = first_note.getStemExtents().topY;
      var first_x_px = first_note.getStemX();

      var inc = (this.render_options.max_slope - this.render_options.min_slope) /
          this.render_options.slope_iterations;
      var min_cost = Number.MAX_VALUE;
      var best_slope = 0;
      var y_shift = 0;

      // iterate through slope values to find best weighted fit
      for (var slope = this.render_options.min_slope;
           slope <= this.render_options.max_slope;
           slope += inc) {
        var total_stem_extension = 0;
        var y_shift_tmp = 0;

        // iterate through notes, calculating y shift and stem extension
        for (var i = 1; i < this.notes.length; ++i) {
          var note = this.notes[i];

          var x_px = note.getStemX();
          var y_px = note.getStemExtents().topY;
          var slope_y_px = this.getSlopeY(x_px, first_x_px, first_y_px, slope) + y_shift_tmp;

          // beam needs to be shifted up to accommodate note
          if (y_px * this.stem_direction < slope_y_px * this.stem_direction) {
            var diff =  Math.abs(y_px - slope_y_px);
            y_shift_tmp += diff * -this.stem_direction;
            total_stem_extension += (diff * i);
          } else { // beam overshoots note, account for the difference
            total_stem_extension += (y_px - slope_y_px) * this.stem_direction;
          }

        }

        var last_note = this.notes[this.notes.length - 1];
        var first_last_slope = ((last_note.getStemExtents().topY - first_y_px) /
                (last_note.getStemX() - first_x_px));
        // most engraving books suggest aiming for a slope about half the angle of the
        // difference between the first and last notes' stem length;
        var ideal_slope = first_last_slope / 2;
        var distance_from_ideal = Math.abs(ideal_slope - slope);

        // This tries to align most beams to something closer to the ideal_slope, but
        // doesn't go crazy. To disable, set this.render_options.slope_cost = 0
        var cost = this.render_options.slope_cost * distance_from_ideal +
            Math.abs(total_stem_extension);

        // update state when a more ideal slope is found
        if (cost < min_cost) {
          min_cost = cost;
          best_slope = slope;
          y_shift = y_shift_tmp;
        }
      }

      this.slope = best_slope;
      this.y_shift = y_shift;
    },

    // Calculate a slope and y-shift for flat beams
    calculateFlatSlope: function() {

      // If a flat beam offset has not yet been supplied or calculated,
      // generate one based on the notes in this particular note group
      var total = 0;
      var extreme_y = 0;  // Store the highest or lowest note here
      var extreme_beam_count = 0;  // The beam count of the extreme note
      var current_extreme = 0;
      for (var i = 0; i < this.notes.length; i++) {

        // Total up all of the offsets so we can average them out later
        var note = this.notes[i];
        var top_y = note.getStemExtents().topY;
        total += top_y;

        // Store the highest (stems-up) or lowest (stems-down) note so the
        //  offset can be adjusted in case the average isn't enough
        if (this.stem_direction === Stem.DOWN && current_extreme < top_y) {
          current_extreme = top_y;
          extreme_y = note.getNoteHeadBounds().y_bottom;
          extreme_beam_count = note.getBeamCount();
        } else if (this.stem_direction === Stem.UP && (current_extreme === 0 || current_extreme > top_y)) {
          current_extreme = top_y;
          extreme_y = note.getNoteHeadBounds().y_top;
          extreme_beam_count = note.getBeamCount();
        }
      }

      // Average the offsets to try and come up with a reasonable one that
      //  works for all of the notes in the beam group.
      var offset = total / this.notes.length;

      // In case the average isn't long enough, add or subtract some more
      //  based on the highest or lowest note (again, based on the stem
      //  direction). This also takes into account the added height due to
      //  the width of the beams.
      var beam_width = this.render_options.beam_width * 1.5;
      var extreme_test = this.render_options.min_flat_beam_offset + (extreme_beam_count * beam_width);
      var new_offset = extreme_y + (extreme_test * -this.stem_direction);
      if (this.stem_direction === Stem.DOWN && offset < new_offset) {
        offset = extreme_y + extreme_test;
      } else if (this.stem_direction === Stem.UP && offset > new_offset) {
        offset = extreme_y - extreme_test;
      }
      if (!this.render_options.flat_beam_offset) {

        // Set the offset for the group based on the calculations above.
        this.render_options.flat_beam_offset = offset;
      } else if (this.stem_direction === Stem.DOWN && offset > this.render_options.flat_beam_offset) {
        this.render_options.flat_beam_offset = offset;
      } else if (this.stem_direction === Stem.UP && offset < this.render_options.flat_beam_offset) {
        this.render_options.flat_beam_offset = offset;
      }

      // for flat beams, the slope and y_shift are simply 0
      this.slope = 0;
      this.y_shift = 0;
    },

    // Create new stems for the notes in the beam, so that each stem
    // extends into the beams.
    applyStemExtensions: function(){
      var first_note = this.notes[0];
      var first_y_px = first_note.getStemExtents().topY;

      // If rendering flat beams, and an offset exists, set the y-coordinate to
      //  the offset so the stems all end at the beam offset.
      if (this.render_options.flat_beams && this.render_options.flat_beam_offset) {
        first_y_px = this.render_options.flat_beam_offset;
      }
      var first_x_px = first_note.getStemX();

      for (var i = 0; i < this.notes.length; ++i) {
        var note = this.notes[i];

        var x_px = note.getStemX();
        var y_extents = note.getStemExtents();
        var base_y_px = y_extents.baseY;
        var top_y_px = y_extents.topY;

        // If flat beams, set the top of the stem to the offset, rather than
        //  relying on the topY value from above.
        if (this.render_options.flat_beams) {
          top_y_px = first_y_px;
        }

        // For harmonic note heads, shorten stem length by 3 pixels
        base_y_px += this.stem_direction * note.glyph.stem_offset;

        // Don't go all the way to the top (for thicker stems)
        var y_displacement = Vex.Flow.STEM_WIDTH;

        if (!note.hasStem()) {
          if (note.isRest() && this.render_options.show_stemlets) {
            var centerGlyphX = note.getCenterGlyphX();

            var width = this.render_options.beam_width;
            var total_width = ((this.beam_count - 1)* width * 1.5) + width;

            var stemlet_height = (total_width - y_displacement +
              this.render_options.stemlet_extension);

            var beam_y = this.getSlopeY(centerGlyphX, first_x_px,
                            first_y_px, this.slope) + this.y_shift;
            var start_y = beam_y + (Vex.Flow.Stem.HEIGHT * this.stem_direction);
            var end_y = beam_y + (stemlet_height * this.stem_direction);

            // Draw Stemlet
            note.setStem(new Vex.Flow.Stem({
              x_begin: centerGlyphX,
              x_end: centerGlyphX,
              y_bottom: this.stem_direction === Stem.UP ? end_y : start_y,
              y_top: this.stem_direction === Stem.UP ? start_y : end_y,
              y_extend: y_displacement,
              stem_extension: -1, // To avoid protruding through the beam
              stem_direction: this.stem_direction
            }));
          }

          continue;
        }

        var slope_y = this.getSlopeY(x_px, first_x_px, first_y_px,
                        this.slope) + this.y_shift;

        note.setStem(new Vex.Flow.Stem({
          x_begin: x_px - (Vex.Flow.STEM_WIDTH/2),
          x_end: x_px,
          y_top: this.stem_direction === Stem.UP ? top_y_px : base_y_px,
          y_bottom: this.stem_direction === Stem.UP ? base_y_px :  top_y_px,
          y_extend: y_displacement,
          stem_extension: Math.abs(top_y_px - slope_y) - Stem.HEIGHT - 1,
          stem_direction: this.stem_direction
        }));
      }
    },

    // Get the x coordinates for the beam lines of specific `duration`
    getBeamLines: function(duration) {
      var beam_lines = [];
      var beam_started = false;
      var current_beam = null;
      var partial_beam_length = this.render_options.partial_beam_length;
      var previous_should_break = false;
      var tick_tally = 0;
      for (var i = 0; i < this.notes.length; ++i) {
        var note = this.notes[i];

        // See if we need to break secondary beams on this note.
        var ticks = note.getIntrinsicTicks();
        tick_tally += ticks;
        var should_break = false;

        // 8th note beams are always drawn.
        if (parseInt(duration) >= 8) {

          // First, check to see if any indices were set up through breakSecondaryAt()
          should_break = this.break_on_indices.indexOf(i) !== -1;

          // If the secondary breaks were auto-configured in the render options,
          //  handle that as well.
          if (this.render_options.secondary_break_ticks && tick_tally >= this.render_options.secondary_break_ticks) {
            tick_tally = 0;
            should_break = true;
          }
        }
        var note_gets_beam = ticks < Vex.Flow.durationToTicks(duration);
        var stem_x = note.isRest() ? note.getCenterGlyphX() : note.getStemX();

        // Check to see if the next note in the group will get a beam at this
        //  level. This will help to inform the partial beam logic below.
        var next_note = this.notes[i + 1];
        var beam_next = next_note && next_note.getIntrinsicTicks() < Vex.Flow.durationToTicks(duration);
        if (note_gets_beam) {

          // This note gets a beam at the current level
          if (beam_started) {

            // We're currently in the middle of a beam. Just continue it on to
            //  the stem X of the current note.
            current_beam = beam_lines[beam_lines.length - 1];
            current_beam.end = stem_x;

            // If a secondary beam break is set up, end the beam right now.
            if (should_break) {
              beam_started = false;
              if (next_note && !beam_next && current_beam.end === null) {

                // This note gets a beam,.but the next one does not. This means
                //  we need a partial pointing right.
                current_beam.end = current_beam.start - partial_beam_length;
              }
            }
          } else {

            // No beam started yet. Start a new one.
            current_beam = { start: stem_x, end: null };
            beam_started = true;
            if (!beam_next) {

              // The next note doesn't get a beam. Draw a partial.
              if((previous_should_break || i === 0) && next_note) {

                // This is the first note (but not the last one), or it is
                //  following a secondary break. Draw a partial to the right.
                current_beam.end = current_beam.start + partial_beam_length;
              } else {

                // By default, draw a partial to the left.
                current_beam.end = current_beam.start - partial_beam_length;
              }
            } else if (should_break) {

              // This note should have a secondary break after it. Even though
              //  we just started a beam, it needs to end immediately.
              current_beam.end = current_beam.start - partial_beam_length;
              beam_started = false;
            }
            beam_lines.push(current_beam);
          }
        } else {

          // The current note does not get a beam.
          beam_started = false;
        }

        // Store the secondary break flag to inform the partial beam logic in
        //  the next iteration of the loop.
        previous_should_break = should_break;
      }

      // Add a partial beam pointing left if this is the last note in the group
      var last_beam = beam_lines[beam_lines.length - 1];
      if (last_beam && last_beam.end === null) {
        last_beam.end = last_beam.start - partial_beam_length;
      }
      return beam_lines;
    },

    // Render the stems for each notes
    drawStems: function() {
      this.notes.forEach(function(note) {
        if (note.getStem()) {
          note.getStem().setContext(this.context).draw();
        }
      }, this);
    },

    // Render the beam lines
    drawBeamLines: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      var valid_beam_durations = ["4", "8", "16", "32", "64"];

      var first_note = this.notes[0];
      var last_note = this.notes[this.notes.length - 1];

      var first_y_px = first_note.getStemExtents().topY;
      var last_y_px = last_note.getStemExtents().topY;

      // For flat beams, set the first and last Y to the offset, rather than
      //  using the note's stem extents.
      if (this.render_options.flat_beams && this.render_options.flat_beam_offset) {
        first_y_px = this.render_options.flat_beam_offset;
        last_y_px = this.render_options.flat_beam_offset;
      }

      var first_x_px = first_note.getStemX();

      var beam_width = this.render_options.beam_width * this.stem_direction;

      // Draw the beams.
      for (var i = 0; i < valid_beam_durations.length; ++i) {
        var duration = valid_beam_durations[i];
        var beam_lines = this.getBeamLines(duration);

        for (var j = 0; j < beam_lines.length; ++j) {
          var beam_line = beam_lines[j];
          var first_x = beam_line.start - (this.stem_direction == Stem.DOWN ? Vex.Flow.STEM_WIDTH/2:0);
          var first_y = this.getSlopeY(first_x, first_x_px, first_y_px, this.slope);

          var last_x = beam_line.end +
            (this.stem_direction == 1 ? (Vex.Flow.STEM_WIDTH/3):(-Vex.Flow.STEM_WIDTH/3));
          var last_y = this.getSlopeY(last_x, first_x_px, first_y_px, this.slope);

          this.context.beginPath();
          this.context.moveTo(first_x, first_y + this.y_shift);
          this.context.lineTo(first_x, first_y + beam_width + this.y_shift);
          this.context.lineTo(last_x + 1, last_y + beam_width + this.y_shift);
          this.context.lineTo(last_x + 1, last_y + this.y_shift);
          this.context.closePath();
          this.context.fill();
        }

        first_y_px += beam_width * 1.5;
        last_y_px += beam_width * 1.5;
      }
    },

    // Pre-format the beam
    preFormat: function() { return this; },

    // Post-format the beam. This can only be called after
    // the notes in the beam have both `x` and `y` values. ie: they've
    // been formatted and have staves
    postFormat: function() {
      if (this.postFormatted) return;

      // Calculate a smart slope if we're not forcing the beams to be flat.
      if(this.render_options.flat_beams) {
        this.calculateFlatSlope();
      } else {
        this.calculateSlope();
      }
      this.applyStemExtensions();

      this.postFormatted = true;
    },

    // Render the beam to the canvas context
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      if (this.unbeamable) return;

      if (!this.postFormatted) {
        this.postFormat();
      }

      this.drawStems();
      this.drawBeamLines();

      return true;
    }
  };

  function calculateStemDirection(notes) {
    var lineSum = 0;
    notes.forEach(function(note) {
      if (note.keyProps) {
        note.keyProps.forEach(function(keyProp){
          lineSum += (keyProp.line - 3);
        });
      }
    });

    if (lineSum >= 0)
      return Stem.DOWN;
    return Stem.UP;
  }

  // ## Static Methods
  //
  // Gets the default beam groups for a provided time signature.
  // Attempts to guess if the time signature is not found in table.
  // Currently this is fairly naive.
  Beam.getDefaultBeamGroups = function(time_sig){
    if (!time_sig || time_sig == "c") time_sig = "4/4";

    var defaults = {
      '1/2' :  ['1/2'],
      '2/2' :  ['1/2'],
      '3/2' :  ['1/2'],
      '4/2' :  ['1/2'],

      '1/4' :  ['1/4'],
      '2/4' :  ['1/4'],
      '3/4' :  ['1/4'],
      '4/4' :  ['1/4'],

      '1/8' :  ['1/8'],
      '2/8' :  ['2/8'],
      '3/8' :  ['3/8'],
      '4/8' :  ['2/8'],

      '1/16' : ['1/16'],
      '2/16' : ['2/16'],
      '3/16' : ['3/16'],
      '4/16' : ['2/16']
    };

    var Fraction = Vex.Flow.Fraction;
    var groups = defaults[time_sig];

    if (!groups) {
      // If no beam groups found, naively determine
      // the beam groupings from the time signature
      var beatTotal = parseInt(time_sig.split('/')[0], 10);
      var beatValue = parseInt(time_sig.split('/')[1], 10);

      var tripleMeter = beatTotal % 3 === 0;

      if (tripleMeter) {
        return [new Fraction(3, beatValue)];
      } else if (beatValue > 4) {
        return [new Fraction(2, beatValue)];
      } else if (beatValue <= 4) {
        return [new Fraction(1, beatValue)];
      }
    } else {
      return groups.map(function(group) {
        return new Fraction().parse(group);
      });
    }
  };

  // A helper function to automatically build basic beams for a voice. For more
  // complex auto-beaming use `Beam.generateBeams()`.
  //
  // Parameters:
  // * `voice` - The voice to generate the beams for
  // * `stem_direction` - A stem direction to apply to the entire voice
  // * `groups` - An array of `Fraction` representing beat groupings for the beam
  Beam.applyAndGetBeams = function(voice, stem_direction, groups) {
    return Beam.generateBeams(voice.getTickables(), {
      groups: groups,
      stem_direction: stem_direction
    });
  };

  // A helper function to autimatically build beams for a voice with
  // configuration options.
  //
  // Example configuration object:
  //
  // ```
  // config = {
  //   groups: [new Vex.Flow.Fraction(2, 8)],
  //   stem_direction: -1,
  //   beam_rests: true,
  //   beam_middle_only: true,
  //   show_stemlets: false
  // };
  // ```
  //
  // Parameters:
  // * `notes` - An array of notes to create the beams for
  // * `config` - The configuration object
  //    * `groups` - Array of `Fractions` that represent the beat structure to beam the notes
  //    * `stem_direction` - Set to apply the same direction to all notes
  //    * `beam_rests` - Set to `true` to include rests in the beams
  //    * `beam_middle_only` - Set to `true` to only beam rests in the middle of the beat
  //    * `show_stemlets` - Set to `true` to draw stemlets for rests
  //    * `maintain_stem_directions` - Set to `true` to not apply new stem directions
  //
  Beam.generateBeams = function(notes, config) {

    if (!config) config = {};

    if (!config.groups || !config.groups.length) {
      config.groups = [new Vex.Flow.Fraction(2, 8)];
    }

    // Convert beam groups to tick amounts
    var tickGroups = config.groups.map(function(group) {
      if (!group.multiply) {
        throw new Vex.RuntimeError("InvalidBeamGroups",
          "The beam groups must be an array of Vex.Flow.Fractions");
      }
      return group.clone().multiply(Vex.Flow.RESOLUTION, 1);
    });

    var unprocessedNotes = notes;
    var currentTickGroup = 0;
    var noteGroups       = [];
    var currentGroup     = [];

    function getTotalTicks(vf_notes){
      return vf_notes.reduce(function(memo,note){
        return note.getTicks().clone().add(memo);
      }, new Vex.Flow.Fraction(0, 1));
    }

    function nextTickGroup() {
      if (tickGroups.length - 1 > currentTickGroup) {
        currentTickGroup += 1;
      } else {
        currentTickGroup = 0;
      }
    }

    function createGroups(){
      var nextGroup = [];

      unprocessedNotes.forEach(function(unprocessedNote){
        nextGroup    = [];
        if (unprocessedNote.shouldIgnoreTicks()) {
          noteGroups.push(currentGroup);
          currentGroup = nextGroup;
          return; // Ignore untickables (like bar notes)
        }

        currentGroup.push(unprocessedNote);
        var ticksPerGroup = tickGroups[currentTickGroup].clone();
        var totalTicks = getTotalTicks(currentGroup);

        // Double the amount of ticks in a group, if it's an unbeamable tuplet
        var unbeamable = Vex.Flow.durationToNumber(unprocessedNote.duration) < 8;
        if (unbeamable && unprocessedNote.tuplet) {
          ticksPerGroup.numerator *= 2;
        }

        // If the note that was just added overflows the group tick total
        if (totalTicks.greaterThan(ticksPerGroup)) {
          // If the overflow note can be beamed, start the next group
          // with it. Unbeamable notes leave the group overflowed.
          if (!unbeamable) {
            nextGroup.push(currentGroup.pop());
          }
          noteGroups.push(currentGroup);
          currentGroup = nextGroup;
          nextTickGroup();
        } else if (totalTicks.equals(ticksPerGroup)) {
          noteGroups.push(currentGroup);
          currentGroup = nextGroup;
          nextTickGroup();
        }
      });

      // Adds any remainder notes
      if (currentGroup.length > 0)
        noteGroups.push(currentGroup);
    }

    function getBeamGroups() {
      return noteGroups.filter(function(group){
          if (group.length > 1) {
            var beamable = true;
            group.forEach(function(note) {
              if (note.getIntrinsicTicks() >= Vex.Flow.durationToTicks("4")) {
                beamable = false;
              }
            });
            return beamable;
          }
          return false;
      });
    }

    // Splits up groups by Rest
    function sanitizeGroups() {
      var sanitizedGroups = [];
      noteGroups.forEach(function(group) {
        var tempGroup = [];
        group.forEach(function(note, index, group) {
          var isFirstOrLast = index === 0 || index === group.length - 1;
          var prevNote = group[index-1];

          var breaksOnEachRest = !config.beam_rests && note.isRest();
          var breaksOnFirstOrLastRest = (config.beam_rests &&
            config.beam_middle_only && note.isRest() && isFirstOrLast);

          var breakOnStemChange = false;
          if (config.maintain_stem_directions && prevNote &&
              !note.isRest() && !prevNote.isRest()) {
            var prevDirection = prevNote.getStemDirection();
            var currentDirection = note.getStemDirection();
            breakOnStemChange = currentDirection !== prevDirection;
          }

          var isUnbeamableDuration = parseInt(note.duration, 10) < 8;

          // Determine if the group should be broken at this note
          var shouldBreak = breaksOnEachRest || breaksOnFirstOrLastRest ||
                            breakOnStemChange || isUnbeamableDuration;

          if (shouldBreak) {
            // Add current group
            if (tempGroup.length > 0) {
              sanitizedGroups.push(tempGroup);
            }

            // Start a new group. Include the current note if the group
            // was broken up by stem direction, as that note needs to start
            // the next group of notes
            tempGroup = breakOnStemChange ? [note] : [];
          } else {
            // Add note to group
            tempGroup.push(note);
          }
        });

        // If there is a remaining group, add it as well
        if (tempGroup.length > 0) {
          sanitizedGroups.push(tempGroup);
        }
      });

      noteGroups = sanitizedGroups;
    }

    function formatStems() {
      noteGroups.forEach(function(group){
        var stemDirection;
        if (config.maintain_stem_directions) {
          var note = findFirstNote(group);
          stemDirection = note ? note.getStemDirection() : Stem.UP;
        } else {
          if (config.stem_direction){
            stemDirection = config.stem_direction;
          } else {
            stemDirection = calculateStemDirection(group);
          }
        }
        applyStemDirection(group, stemDirection);
      });
    }

    function findFirstNote(group) {
      for (var i = 0; i < group.length; i++) {
        var note = group[i];
        if (!note.isRest()) {
          return note;
        }
      }

      return false;
    }

    function applyStemDirection(group, direction) {
      group.forEach(function(note){
        note.setStemDirection(direction);
      });
    }

    function getTupletGroups() {
      return noteGroups.filter(function(group){
        if (group[0]) return group[0].tuplet;
      });
    }


    // Using closures to store the variables throughout the various functions
    // IMO Keeps it this process lot cleaner - but not super consistent with
    // the rest of the API's style - Silverwolf90 (Cyril)
    createGroups();
    sanitizeGroups();
    formatStems();

    // Get the notes to be beamed
    var beamedNoteGroups = getBeamGroups();

    // Get the tuplets in order to format them accurately
    var tupletGroups = getTupletGroups();

    // Create a Vex.Flow.Beam from each group of notes to be beamed
    var beams = [];
    beamedNoteGroups.forEach(function(group){
      var beam = new Vex.Flow.Beam(group);

      if (config.show_stemlets) {
        beam.render_options.show_stemlets = true;
      }
      if (config.secondary_breaks) {
        beam.render_options.secondary_break_ticks = Vex.Flow.durationToTicks(config.secondary_breaks);
      }
      if (config.flat_beams === true) {
        beam.render_options.flat_beams = true;
        beam.render_options.flat_beam_offset = config.flat_beam_offset;
      }
      beams.push(beam);
    });

    // Reformat tuplets
    tupletGroups.forEach(function(group){
      var firstNote = group[0];
      for (var i=0; i<group.length; ++i) {
        if (group[i].hasStem()) {
          firstNote = group[i];
          break;
        }
      }

      var tuplet = firstNote.tuplet;

      if (firstNote.beam) tuplet.setBracketed(false);
      if (firstNote.stem_direction == Stem.DOWN) {
        tuplet.setTupletLocation(Vex.Flow.Tuplet.LOCATION_BOTTOM);
      }
    });

    return beams;
  };

  return Beam;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements the main Voice class. It's mainly a container
// object to group `Tickables` for formatting.
Vex.Flow.Voice = (function() {
  function Voice(time) {
    if (arguments.length > 0) this.init(time);
  }

  // Modes allow the addition of ticks in three different ways:
  //
  // STRICT: This is the default. Ticks must fill the voice.
  // SOFT:   Ticks can be added without restrictions.
  // FULL:   Ticks do not need to fill the voice, but can't exceed the maximum
  //         tick length.
  Voice.Mode = {
    STRICT: 1,
    SOFT:   2,
    FULL:   3
  };

  // ## Prototype Methods
  Voice.prototype = {
    init: function(time) {
      this.time = Vex.Merge({
        num_beats: 4,
        beat_value: 4,
        resolution: Vex.Flow.RESOLUTION
      }, time);

      // Recalculate total ticks.
      this.totalTicks = new Vex.Flow.Fraction(
        this.time.num_beats * (this.time.resolution / this.time.beat_value), 1);

      this.resolutionMultiplier = 1;

      // Set defaults
      this.tickables = [];
      this.ticksUsed = new Vex.Flow.Fraction(0, 1);
      this.smallestTickCount = this.totalTicks.clone();
      this.largestTickWidth = 0;
      this.stave = null;
      this.boundingBox = null;
      // Do we care about strictly timed notes
      this.mode = Vex.Flow.Voice.Mode.STRICT;

      // This must belong to a VoiceGroup
      this.voiceGroup = null;
    },

    // Get the total ticks in the voice
    getTotalTicks: function() { return this.totalTicks; },

    // Get the total ticks used in the voice by all the tickables
    getTicksUsed: function() { return this.ticksUsed; },

    // Get the largest width of all the tickables
    getLargestTickWidth: function() { return this.largestTickWidth; },

    // Get the tick count for the shortest tickable
    getSmallestTickCount: function() { return this.smallestTickCount; },

    // Get the tickables in the voice
    getTickables: function() { return this.tickables; },

    // Get/set the voice mode, use a value from `Voice.Mode`
    getMode: function() { return this.mode; },
    setMode: function(mode) { this.mode = mode; return this; },

    // Get the resolution multiplier for the voice
    getResolutionMultiplier: function() { return this.resolutionMultiplier; },

    // Get the actual tick resolution for the voice
    getActualResolution: function() { return this.resolutionMultiplier * this.time.resolution; },

    // Set the voice's stave
    setStave: function(stave) {
      this.stave = stave;
      this.boundingBox = null; // Reset bounding box so we can reformat
      return this;
    },

    // Get the bounding box for the voice
    getBoundingBox: function() {
      var stave, boundingBox, bb, i;

      if (!this.boundingBox) {
        if (!this.stave) throw Vex.RERR("NoStave", "Can't get bounding box without stave.");
        stave = this.stave;
        boundingBox = null;

        for (i = 0; i < this.tickables.length; ++i) {
          this.tickables[i].setStave(stave);

          bb = this.tickables[i].getBoundingBox();
          if (!bb) continue;

          boundingBox = boundingBox ? boundingBox.mergeWith(bb) : bb;
        }

        this.boundingBox = boundingBox;
      }
      return this.boundingBox;
    },

    // Every tickable must be associated with a voiceGroup. This allows formatters
    // and preformatters to associate them with the right modifierContexts.
    getVoiceGroup: function() {
      if (!this.voiceGroup)
        throw new Vex.RERR("NoVoiceGroup", "No voice group for voice.");
      return this.voiceGroup;
    },

    // Set the voice group
    setVoiceGroup: function(g) { this.voiceGroup = g; return this; },

    // Set the voice mode to strict or soft 
    setStrict: function(strict) {
      this.mode = strict ? Vex.Flow.Voice.Mode.STRICT : Vex.Flow.Voice.Mode.SOFT;
      return this;
    },

    // Determine if the voice is complete according to the voice mode
    isComplete: function() {
      if (this.mode == Vex.Flow.Voice.Mode.STRICT ||
          this.mode == Vex.Flow.Voice.Mode.FULL) {
        return this.ticksUsed.equals(this.totalTicks);
      } else {
        return true;
      }
    },

    // Add a tickable to the voice
    addTickable: function(tickable) {
      if (!tickable.shouldIgnoreTicks()) {
        var ticks = tickable.getTicks();

        // Update the total ticks for this line.
        this.ticksUsed.add(ticks);

        if ((this.mode == Vex.Flow.Voice.Mode.STRICT ||
             this.mode == Vex.Flow.Voice.Mode.FULL) &&
             this.ticksUsed.greaterThan(this.totalTicks)) {
          this.totalTicks.subtract(ticks);
          throw new Vex.RERR("BadArgument", "Too many ticks.");
        }

        // Track the smallest tickable for formatting.
        if (ticks.lessThan(this.smallestTickCount)) {
          this.smallestTickCount = ticks.clone();
        }

        this.resolutionMultiplier = this.ticksUsed.denominator;

        // Expand total ticks using denominator from ticks used.
        this.totalTicks.add(0, this.ticksUsed.denominator);
      }

      // Add the tickable to the line.
      this.tickables.push(tickable);
      tickable.setVoice(this);
      return this;
    },

    // Add an array of tickables to the voice.
    addTickables: function(tickables) {
      for (var i = 0; i < tickables.length; ++i) {
        this.addTickable(tickables[i]);
      }

      return this;
    },

    // Preformats the voice by applying the voice's stave to each note.
    preFormat: function(){
      if (this.preFormatted) return;

      this.tickables.forEach(function(tickable) {
        if (!tickable.getStave()) {
          tickable.setStave(this.stave);
        }
      }, this);

      this.preFormatted = true;
      return this;
    },

    // Render the voice onto the canvas `context` and an optional `stave`.
    // If `stave` is omitted, it is expected that the notes have staves
    // already set.
    draw: function(context, stave) {
      var boundingBox = null;
      for (var i = 0; i < this.tickables.length; ++i) {
        var tickable = this.tickables[i];

        // Set the stave if provided
        if (stave) tickable.setStave(stave);

        if (!tickable.getStave()) {
          throw new Vex.RuntimeError("MissingStave",
            "The voice cannot draw tickables without staves.");
        }

        if (i === 0) boundingBox = tickable.getBoundingBox();

        if (i > 0 && boundingBox) {
          var tickable_bb = tickable.getBoundingBox();
          if (tickable_bb) boundingBox.mergeWith(tickable_bb);
        }

       tickable.setContext(context);
       tickable.draw();
      }

      this.boundingBox = boundingBox;
    }
  };

  return Voice;
}());
// Vex Music Notation
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Muthanna 2010

/** @constructor */
Vex.Flow.VoiceGroup = (function() {
  function VoiceGroup() {
    this.init();
  }

  VoiceGroup.prototype = {
    init: function() {
      this.voices = [];
      this.modifierContexts = [];
    },

    // Every tickable must be associated with a voiceGroup. This allows formatters
    // and preformatters to associate them with the right modifierContexts.
    getVoices: function() { return this.voices; },
    getModifierContexts: function() { return this.modifierContexts; },

    addVoice: function(voice) {
      if (!voice) throw new Vex.RERR("BadArguments", "Voice cannot be null.");
      this.voices.push(voice);
      voice.setVoiceGroup(this);
    }
  };

  return VoiceGroup;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// `Modifier` is an abstract interface for notational elements that modify
// a `Note`. Examples of modifiers are `Accidental`, `Annotation`, `Stroke`, etc.
//
// For a `Modifier` instance to be positioned correctly, it must be part of
// a `ModifierContext`. All modifiers in the same context are rendered relative to
// one another.
//
// Typically, all modifiers to a note are part of the same `ModifierContext` instance. Also,
// in multi-voice staves, all modifiers to notes on the same `tick` are part of the same
// `ModifierContext`. This ensures that multiple voices don't trample all over each other.

Vex.Flow.Modifier = (function() {
  function Modifier() {
    this.constructor = Modifier;
    this.init();
  }
  Modifier.CATEGORY = "none";

    // To enable logging for this class. Set `Vex.Flow.Modifier.DEBUG` to `true`.
  function L() { if (Modifier.DEBUG) Vex.L("Vex.Flow.Modifier", arguments); }

  // Modifiers can be positioned almost anywhere, relative to a note.
  Modifier.Position = {
    LEFT: 1,
    RIGHT: 2,
    ABOVE: 3,
    BELOW: 4
  };

  // ## Prototype Methods
  Modifier.prototype = {

    // The constructor sets initial widths and constants.
    init: function() {
      this.width = 0;
      this.context = null;

      // Modifiers are attached to a note and an index. An index is a
      // specific head in a chord.
      this.note = null;
      this.index = null;

      // The `text_line` is reserved space above or below a stave.
      this.text_line = 0;
      this.position = Modifier.Position.LEFT;
      this.modifier_context = null;
      this.x_shift = 0;
      this.y_shift = 0;
      this.spacingFromNextModifier = 0;
      L("Created new modifier");
    },

    // Every modifier has a category. The `ModifierContext` uses this to determine
    // the type and order of the modifiers.
    getCategory: function() { return this.constructor.CATEGORY; },

    // Get and set modifier widths.
    getWidth: function() { return this.width; },
    setWidth: function(width) { this.width = width; return this; },

    // Get and set attached note (`StaveNote`, `TabNote`, etc.)
    getNote: function() { return this.note; },
    setNote: function(note) { this.note = note; return this; },

    // Get and set note index, which is a specific note in a chord.
    getIndex: function() { return this.index; },
    setIndex: function(index) { this.index = index; return this; },

    // Get and set rendering context.
    getContext: function() { return this.context; },
    setContext: function(context) { this.context = context; return this; },

    // Every modifier must be part of a `ModifierContext`.
    getModifierContext: function() { return this.modifier_context; },
    setModifierContext: function(c) { this.modifier_context = c; return this; },

    // Get and set articulation position.
    getPosition: function() { return this.position; },
    setPosition: function(position) { this.position = position; return this; },

    // Set the `text_line` for the modifier.
    setTextLine: function(line) { this.text_line = line; return this; },

    // Shift modifier down `y` pixels. Negative values shift up.
    setYShift: function(y) { this.y_shift = y; return this; },

    setSpacingFromNextModifier: function(x) {
      this.spacingFromNextModifier = x;
    },

    getSpacingFromNextModifier: function() {return this.spacingFromNextModifier; },

    // Shift modifier `x` pixels in the direction of the modifier. Negative values
    // shift reverse.
    setXShift: function(x) {
      this.x_shift = 0;
      if (this.position == Modifier.Position.LEFT) {
        this.x_shift -= x;
      } else {
        this.x_shift += x;
      }
    },
    getXShift: function() {return this.x_shift;},

    // Render the modifier onto the canvas.
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      throw new Vex.RERR("MethodNotImplemented",
          "Draw() not implemented for this modifier.");
    }
  };

  return Modifier;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This class implements various types of modifiers to notes (e.g. bends,
// fingering positions etc.)

Vex.Flow.ModifierContext = (function() {
  function ModifierContext() {
    // Current modifiers
    this.modifiers = {};

    // Formatting data.
    this.preFormatted = false;
    this.postFormatted = false;
    this.width = 0;
    this.spacing = 0;
    this.state = {
      left_shift: 0,
      right_shift: 0,
      text_line: 0,
      top_text_line: 0
    };

    // Add new modifiers to this array. The ordering is significant -- lower
    // modifiers are formatted and rendered before higher ones.
    this.PREFORMAT = [
      Vex.Flow.StaveNote,
      Vex.Flow.Dot,
      Vex.Flow.FretHandFinger,
      Vex.Flow.Accidental,
      Vex.Flow.GraceNoteGroup,
      Vex.Flow.Stroke,
      Vex.Flow.StringNumber,
      Vex.Flow.Articulation,
      Vex.Flow.Ornament,
      Vex.Flow.Annotation,
      Vex.Flow.Bend,
      Vex.Flow.Vibrato
    ];

    // If post-formatting is required for an element, add it to this array.
    this.POSTFORMAT = [ Vex.Flow.StaveNote ];
  }

  // To enable logging for this class. Set `Vex.Flow.ModifierContext.DEBUG` to `true`.
  function L() { if (ModifierContext.DEBUG) Vex.L("Vex.Flow.ModifierContext", arguments); }

  ModifierContext.prototype = {
    addModifier: function(modifier) {
      var type = modifier.getCategory();
      if (!this.modifiers[type]) this.modifiers[type] = [];
      this.modifiers[type].push(modifier);
      modifier.setModifierContext(this);
      this.preFormatted = false;
      return this;
    },

    getModifiers: function(type) { return this.modifiers[type]; },
    getWidth: function() { return this.width; },
    getExtraLeftPx: function() { return this.state.left_shift; },
    getExtraRightPx: function() { return this.state.right_shift; },
    getState: function() { return this.state; },

    getMetrics: function() {
      if (!this.formatted) throw new Vex.RERR("UnformattedModifier",
          "Unformatted modifier has no metrics.");

      return {
        width: this.state.left_shift + this.state.right_shift + this.spacing,
        spacing: this.spacing,
        extra_left_px: this.state.left_shift,
        extra_right_px: this.state.right_shift
      };
    },

    preFormat: function() {
      if (this.preFormatted) return;
      this.PREFORMAT.forEach(function(modifier) {
        L("Preformatting ModifierContext: ", modifier.CATEGORY);
        modifier.format(this.getModifiers(modifier.CATEGORY), this.state, this);
      }, this);

      // Update width of this modifier context
      this.width = this.state.left_shift + this.state.right_shift;
      this.preFormatted = true;
    },

    postFormat: function() {
      if (this.postFormatted) return;
      this.POSTFORMAT.forEach(function(modifier) {
        L("Postformatting ModifierContext: ", modifier.CATEGORY);
        modifier.postFormat(this.getModifiers(modifier.CATEGORY), this);
      }, this);
    }
  };

  return ModifierContext;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// @author Mohit Cheppudira
// @author Greg Ristow (modifications)
//
// ## Description
//
// This file implements accidentals as modifiers that can be attached to
// notes. Support is included for both western and microtonal accidentals.
//
// See `tests/accidental_tests.js` for usage examples.

Vex.Flow.Accidental = (function(){
  function Accidental(type) {
    if (arguments.length > 0) this.init(type);
  }
  Accidental.CATEGORY = "accidentals";

  // To enable logging for this class. Set `Vex.Flow.Accidental.DEBUG` to `true`.
  function L() { if (Accidental.DEBUG) Vex.L("Vex.Flow.Accidental", arguments); }

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods
  //
  // Arrange accidentals inside a ModifierContext.
  Accidental.format = function(accidentals, state) {
    var left_shift = state.left_shift;
    var accidental_spacing = 2;

    // If there are no accidentals, we needn't format their positions
    if (!accidentals || accidentals.length === 0) return false;

    var acc_list = [];
    var hasStave = false;
    var prev_note = null;
    var shiftL = 0;

    // First determine the accidentals' Y positions from the note.keys
    var i, acc, props_tmp;
    for (i = 0; i < accidentals.length; ++i) {
      acc = accidentals[i];
      var note = acc.getNote();
      var stave = note.getStave();
      var props = note.getKeyProps()[acc.getIndex()];
      if (note != prev_note) {
         // Iterate through all notes to get the displaced pixels
         for (var n = 0; n < note.keys.length; ++n) {
            props_tmp = note.getKeyProps()[n];
            shiftL = (props_tmp.displaced ? note.getExtraLeftPx() : shiftL);
          }
          prev_note = note;
      }
      if (stave !== null) {
        hasStave = true;
        var line_space = stave.options.spacing_between_lines_px;
        var y = stave.getYForLine(props.line);
        var acc_line = Math.round(y / line_space * 2)/2;
        acc_list.push({ y: y, line: acc_line, shift: shiftL, acc: acc, lineSpace: line_space });
      } else {
        acc_list.push({ line: props.line, shift: shiftL, acc: acc });
      }
    }

    // Sort accidentals by line number.
    acc_list.sort(function(a, b) { return (b.line - a.line); });

    // Create an array of unique line numbers (line_list) from acc_list
    var line_list = []; // an array of unique line numbers
    var acc_shift = 0; // amount by which all accidentals must be shifted right or left for stem flipping, notehead shifting concerns.
    var previous_line = null;

    for(i = 0; i<acc_list.length; i++) {
      acc = acc_list[i];

      // if this is the first line, or a new line, add a line_list
      if( (previous_line === null) || (previous_line != acc.line) ) {
        line_list.push({line : acc.line, flat_line : true, dbl_sharp_line: true, num_acc : 0, width : 0});
      }
      // if this accidental is not a flat, the accidental needs 3.0 lines lower
      // clearance instead of 2.5 lines for b or bb.
      if( (acc.acc.type != "b") && (acc.acc.type !="bb") ) {
        line_list[line_list.length - 1].flat_line = false;
      }
      // if this accidental is not a double sharp, the accidental needs 3.0 lines above
      if( acc.acc.type != "##")
        line_list[line_list.length - 1].dbl_sharp_line = false;

      // Track how many accidentals are on this line:
      line_list[line_list.length - 1].num_acc++;

      // Track the total x_offset needed for this line which will be needed
      // for formatting lines w/ multiple accidentals:

      //width = accidental width + universal spacing between accidentals
      line_list[line_list.length - 1].width += acc.acc.getWidth() + accidental_spacing;

      // if this acc_shift is larger, use it to keep first column accidentals in the same line
      acc_shift = ( (acc.shift > acc_shift) ? acc.shift : acc_shift);

      previous_line = acc.line;
    }

    // ### Place Accidentals in Columns
    //
    // Default to a classic triangular layout (middle accidental farthest left),
    // but follow exceptions as outlined in G. Read's _Music Notation_ and
    // Elaine Gould's _Behind Bars_.
    //
    // Additionally, this implements different vertical colission rules for
    // flats (only need 2.5 lines clearance below) and double sharps (only
    // need 2.5 lines of clearance above or below).
    //
    // Classic layouts and exception patterns are found in the 'tables.js'
    // in 'Vex.Flow.accidentalColumnsTable'
    //
    // Beyond 6 vertical accidentals, default to the parallel ascending lines approach,
    // using as few columns as possible for the verticle structure.
    //
    // TODO (?): Allow column to be specified for an accidental at run-time?

    var total_columns = 0;

    // establish the boundaries for a group of notes with clashing accidentals:
    for(i = 0; i<line_list.length; i++) {
      var no_further_conflicts = false;
      var group_start = i;
      var group_end = i;

      group_check_while : while( (group_end+1 < line_list.length) && (!no_further_conflicts) ) {
        // if this note conflicts with the next:
        if(this.checkCollision(line_list[group_end], line_list[group_end + 1])) {
        // include the next note in the group:
          group_end++;
        }
        else no_further_conflicts = true;
      }

      // Set columns for the lines in this group:
      var group_length = group_end - group_start + 1;

      // Set the accidental column for each line of the group
      var end_case = (this.checkCollision(line_list[group_start], line_list[group_end])) ? "a" : "b";


        var checkCollision = this.checkCollision;
        switch(group_length) {
          case 3:
            if( (end_case == "a") &&
                (line_list[group_start+1].line - line_list[group_start+2].line == 0.5) &&
                (line_list[group_start].line - line_list[group_start + 1].line != 0.5) )
              end_case = "second_on_bottom";
              break;
          case 4:
            if( (!checkCollision(line_list[group_start], line_list[group_start+2])) &&
                (!checkCollision(line_list[group_start+1], line_list[group_start+3])) )
              end_case = "spaced_out_tetrachord";
              break;
          case 5:
            if( (end_case == "b") &&
                (!checkCollision(line_list[group_start+1], line_list[group_start+3])) )
              end_case = "spaced_out_pentachord";
            if( (end_case == "spaced_out_pentachord") &&
                (!checkCollision(line_list[group_start], line_list[group_start+2])) &&
                (!checkCollision(line_list[group_start+2], line_list[group_start+4])) )
              end_case = "very_spaced_out_pentachord";
              break;
          case 6:
            if( (!checkCollision(line_list[group_start], line_list[group_start+3])) &&
                (!checkCollision(line_list[group_start+1], line_list[group_start+4])) &&
                (!checkCollision(line_list[group_start+2], line_list[group_start+5])) )
              end_case = "spaced_out_hexachord";
            if( (!checkCollision(line_list[group_start], line_list[group_start+2])) &&
                (!checkCollision(line_list[group_start+2], line_list[group_start+4])) &&
                (!checkCollision(line_list[group_start+1], line_list[group_start+3])) &&
                (!checkCollision(line_list[group_start+3], line_list[group_start+5])) )
              end_case = "very_spaced_out_hexachord";
              break;
        }

      var group_member;
      var column;
      // If the group contains more than seven members, use ascending parallel lines
      // of accidentals, using as few columns as possible while avoiding collisions.
      if (group_length>=7) {
        // First, determine how many columns to use:
        var pattern_length = 2;
        var colission_detected = true;
        while(colission_detected === true) {
          colission_detected = false;
          colission_detecter : for(var line = 0; line + pattern_length < line_list.length; line++) {
            if(this.checkCollision(line_list[line], line_list[line+pattern_length])) {
              colission_detected = true;
              pattern_length++;
              break colission_detecter;
            }
          }
        }
        // Then, assign a column to each line of accidentals
        for(group_member = i; group_member <= group_end; group_member++) {
          column = ((group_member-i) % pattern_length) + 1;
          line_list[group_member].column = column;
          total_columns = (total_columns > column) ? total_columns : column;
        }

      // Otherwise, if the group contains fewer than seven members, use the layouts from
      // the accidentalsColumnsTable housed in tables.js.
      } else {
        for(group_member = i; group_member <= group_end; group_member++) {
          column = Vex.Flow.accidentalColumnsTable[group_length][end_case][group_member-i];
          line_list[group_member].column = column;
          total_columns = (total_columns > column) ? total_columns : column;
        }
      }

      // Increment i to the last note that was set, so that if a lower set of notes
      // does not conflict at all with this group, it can have its own classic shape.
      i = group_end;
    }

    // ### Convert Columns to x_offsets
    //
    // This keeps columns aligned, even if they have different accidentals within them
    // which sometimes results in a larger x_offset than is an accidental might need
    // to preserve the symmetry of the accidental shape.
    //
    // Neither A.C. Vinci nor G. Read address this, and it typically only happens in
    // music with complex chord clusters.
    //
    // TODO (?): Optionally allow closer compression of accidentals, instead of forcing
    // parallel columns.

    // track each column's max width, which will be used as initial shift of later columns:
    var column_widths = [];
    var column_x_offsets = [];
    for(i=0; i<=total_columns; i++) {
      column_widths[i] = 0;
      column_x_offsets[i] = 0;
    }

    column_widths[0] = acc_shift + left_shift;
    column_x_offsets[0] = acc_shift + left_shift;

    // Fill column_widths with widest needed x-space;
    // this is what keeps the columns parallel.
    line_list.forEach(function(line) {
      if(line.width > column_widths[line.column]) column_widths[line.column] = line.width;
    });

    for(i=1; i<column_widths.length; i++) {
      // this column's offset = this column's width + previous column's offset
      column_x_offsets[i] = column_widths[i] + column_x_offsets[i-1];
    }

    var total_shift = column_x_offsets[column_x_offsets.length-1];
    // Set the x_shift for each accidental according to column offsets:
    var acc_count = 0;
    line_list.forEach(function(line) {
      var line_width = 0;
      var last_acc_on_line = acc_count + line.num_acc;
      // handle all of the accidentals on a given line:
      for(acc_count; acc_count<last_acc_on_line; acc_count++) {
        var x_shift = (column_x_offsets[line.column-1] + line_width);
        acc_list[acc_count].acc.setXShift(x_shift);
        // keep track of the width of accidentals we've added so far, so that when
        // we loop, we add space for them.
        line_width += acc_list[acc_count].acc.getWidth() + accidental_spacing;
        L("Line, acc_count, shift: ", line.line, acc_count, x_shift);
      }
    });

    // update the overall layout with the full width of the accidental shapes:
    state.left_shift += total_shift;
  };

  // Helper function to determine whether two lines of accidentals collide vertically
  Accidental.checkCollision = function(line_1, line_2) {
    var clearance = line_2.line - line_1.line;
    var clearance_required = 3;
    // But less clearance is required for certain accidentals: b, bb and ##.
    if(clearance>0) { // then line 2 is on top
      clearance_required = (line_2.flat_line || line_2.dbl_sharp_line) ? 2.5 : 3.0;
      if(line_1.dbl_sharp_line) clearance -= 0.5;
    } else { // line 1 is on top
      clearance_required = (line_1.flat_line || line_1.dbl_sharp_line) ? 2.5 : 3.0;
      if(line_2.dbl_sharp_line) clearance -= 0.5;
    }
    var colission = (Math.abs(clearance) < clearance_required);
    L("Line_1, Line_2, Collision: ", line_1.line, line_2.line, colission);
    return(colission);
  };

  // ## Prototype Methods
  //
  // An `Accidental` inherits from `Modifier`, and is formatted within a
  // `ModifierContext`.
  Vex.Inherit(Accidental, Modifier, {
    // Create accidental. `type` can be a value from the
    // `Vex.Flow.accidentalCodes.accidentals` table in `tables.js`. For
    // example: `#`, `##`, `b`, `n`, etc.
    init: function(type) {
      Accidental.superclass.init.call(this);
      L("New accidental: ", type);

      this.note = null;
      // The `index` points to a specific note in a chord.
      this.index = null;
      this.type = type;
      this.position = Modifier.Position.LEFT;

      this.render_options = {
        // Font size for glyphs
        font_scale: 38,

        // Length of stroke across heads above or below the stave.
        stroke_px: 3
      };

      this.accidental = Vex.Flow.accidentalCodes(this.type);
      if (!this.accidental) throw new Vex.RERR("ArgumentError", "Unknown accidental type: " + type);

      // Cautionary accidentals have parentheses around them
      this.cautionary = false;
      this.paren_left = null;
      this.paren_right = null;

      // Initial width is set from table.
      this.setWidth(this.accidental.width);
    },

    // Attach this accidental to `note`, which must be a `StaveNote`.
    setNote: function(note){
      if (!note) throw new Vex.RERR("ArgumentError", "Bad note value: " + note);
      this.note = note;

      // Accidentals attached to grace notes are rendered smaller.
      if (this.note.getCategory() === 'gracenotes') {
        this.render_options.font_scale = 25;
        this.setWidth(this.accidental.gracenote_width);
      }
    },

    // If called, draws parenthesis around accidental.
    setAsCautionary: function() {
      this.cautionary = true;
      this.render_options.font_scale = 28;
      this.paren_left = Vex.Flow.accidentalCodes("{");
      this.paren_right = Vex.Flow.accidentalCodes("}");
      var width_adjust = (this.type == "##" || this.type == "bb") ? 6 : 4;

      // Make sure `width` accomodates for parentheses.
      this.setWidth(this.paren_left.width + this.accidental.width + this.paren_right.width - width_adjust);
      return this;
    },

    // Render accidental onto canvas.
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw accidental without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw accidental without a note and index.");

      // Figure out the start `x` and `y` coordinates for this note and index.
      var start = this.note.getModifierStartXY(this.position, this.index);
      var acc_x = ((start.x + this.x_shift) - this.width);
      var acc_y = start.y + this.y_shift;
      L("Rendering: ", this.type, acc_x, acc_y);

      if (!this.cautionary) {
        // Render the accidental alone.
        Vex.Flow.renderGlyph(this.context, acc_x, acc_y,
                             this.render_options.font_scale, this.accidental.code);
      } else {
        // Render the accidental in parentheses.
        acc_x += 3;
        Vex.Flow.renderGlyph(this.context, acc_x, acc_y,
                             this.render_options.font_scale, this.paren_left.code);
        acc_x += 2;
        Vex.Flow.renderGlyph(this.context, acc_x, acc_y,
                             this.render_options.font_scale, this.accidental.code);
        acc_x += this.accidental.width - 2;
        if (this.type == "##" || this.type == "bb") acc_x -= 2;
        Vex.Flow.renderGlyph(this.context, acc_x, acc_y,
                             this.render_options.font_scale, this.paren_right.code);
      }
    }
  });

  // ## Static Methods
  //
  // Use this method to automatically apply accidentals to a set of `voices`.
  // The accidentals will be remembered between all the voices provided.
  // Optionally, you can also provide an initial `keySignature`.
  Accidental.applyAccidentals = function(voices, keySignature) {
    var tickPositions = [];
    var tickNoteMap = {};

    // Sort the tickables in each voice by their tick position in the voice
    voices.forEach(function(voice) {
      var tickPosition = new Vex.Flow.Fraction(0, 1);
      var notes = voice.getTickables();
      notes.forEach(function(note) {
        var notesAtPosition = tickNoteMap[tickPosition.value()];

        if (!notesAtPosition) {
          tickPositions.push(tickPosition.value());
          tickNoteMap[tickPosition.value()] = [note];
        } else {
          notesAtPosition.push(note);
        }

        tickPosition.add(note.getTicks());
      });
    });

    var music = new Vex.Flow.Music();

    // Default key signature is C major
    if (!keySignature) keySignature = "C";

    // Get the scale map, which represents the current state of each pitch
    var scaleMap = music.createScaleMap(keySignature);

    tickPositions.forEach(function(tick) {
      var notes = tickNoteMap[tick];

      // Array to store all pitches that modified accidental states
      // at this tick position
      var modifiedPitches = [];

      notes.forEach(function(note) {
          if (note.isRest()) return;

          // Go through each key and determine if an accidental should be
          // applied
          note.keys.forEach(function(keyString, keyIndex) {
              var key = music.getNoteParts(keyString.split('/')[0]);

              // Force a natural for every key without an accidental
              var accidentalString = key.accidental || "n";
              var pitch = key.root + accidentalString;

              // Determine if the current pitch has the same accidental
              // as the scale state
              var sameAccidental = scaleMap[key.root] === pitch;

              // Determine if an identical pitch in the chord already
              // modified the accidental state
              var previouslyModified = modifiedPitches.indexOf(pitch) > -1;

              // Add the accidental to the StaveNote
              if (!sameAccidental || (sameAccidental && previouslyModified)) {
                  // Modify the scale map so that the root pitch has an
                  // updated state
                  scaleMap[key.root] = pitch;

                  // Create the accidental
                  var accidental = new Vex.Flow.Accidental(accidentalString);

                  // Attach the accidental to the StaveNote
                  note.addAccidental(keyIndex, accidental);

                  // Add the pitch to list of pitches that modified accidentals
                  modifiedPitches.push(pitch);
              }
          });
      });
    });
  };

  return Accidental;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements dot modifiers for notes.

/**
 * @constructor
 */
Vex.Flow.Dot = (function() {
  function Dot() {
    this.init();
  }

  Dot.CATEGORY = "dots";

  var Modifier = Vex.Flow.Modifier;

  // Arrange dots inside a ModifierContext.
  Dot.format = function(dots, state) {
    var right_shift = state.right_shift;
    var dot_spacing = 1;

    if (!dots || dots.length === 0) return false;

    var i, dot, note, shift;
    var dot_list = [];
    for (i = 0; i < dots.length; ++i) {
      dot = dots[i];
      note = dot.getNote();

      var props;
      // Only StaveNote has .getKeyProps()
      if (typeof note.getKeyProps === 'function') {
        props = note.getKeyProps()[dot.getIndex()];
        shift = (props.displaced ? note.getExtraRightPx() : 0);
      } else { // Else it's a TabNote
        props = { line: 0.5 }; // Shim key props for dot placement
        shift = 0;
      }

      dot_list.push({ line: props.line, shift: shift, note: note, dot: dot });
    }

    // Sort dots by line number.
    dot_list.sort(function(a, b) { return (b.line - a.line); });

    var dot_shift = right_shift;
    var x_width = 0;
    var last_line = null;
    var last_note = null;
    var prev_dotted_space = null;
    var half_shiftY = 0;

    for (i = 0; i < dot_list.length; ++i) {
      dot = dot_list[i].dot;
      note = dot_list[i].note;
      shift = dot_list[i].shift;
      var line = dot_list[i].line;

      // Reset the position of the dot every line.
      if (line != last_line || note != last_note) {
        dot_shift = shift;
      }

      if (!note.isRest() && line != last_line) {
        if (Math.abs(line % 1) == 0.5) {
          // note is on a space, so no dot shift
          half_shiftY = 0;
        } else if (!note.isRest()) {
          // note is on a line, so shift dot to space above the line
          half_shiftY = 0.5;
          if (last_note != null &&
              !last_note.isRest() && last_line - line == 0.5) {
            // previous note on a space, so shift dot to space below the line
            half_shiftY = -0.5;
          } else if (line + half_shiftY == prev_dotted_space) {
            // previous space is dotted, so shift dot to space below the line
             half_shiftY = -0.5;
          }
        }
      }

      // convert half_shiftY to a multiplier for dots.draw()
      dot.dot_shiftY = (-half_shiftY);
      prev_dotted_space = line + half_shiftY;

      dot.setXShift(dot_shift);
      dot_shift += dot.getWidth() + dot_spacing; // spacing
      x_width = (dot_shift > x_width) ? dot_shift : x_width;
      last_line = line;
      last_note = note;
    }

    // Update state.
    state.right_shift += x_width;
  };

  Vex.Inherit(Dot, Modifier, {
    init: function() {
      Dot.superclass.init.call(this);

      this.note = null;
      this.index = null;
      this.position = Modifier.Position.RIGHT;

      this.radius = 2;
      this.setWidth(5);
      this.dot_shiftY = 0;
    },

    setNote: function(note){
      this.note = note;

      if (this.note.getCategory() === 'gracenotes') {
        this.radius *= 0.50;
        this.setWidth(3);
      }
    },

    setDotShiftY: function(y) { this.dot_shiftY = y; return this; },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw dot without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw dot without a note and index.");

      var line_space = this.note.stave.options.spacing_between_lines_px;

      var start = this.note.getModifierStartXY(this.position, this.index);

      // Set the starting y coordinate to the base of the stem for TabNotes
      if (this.note.getCategory() === 'tabnotes') {
        start.y = this.note.getStemExtents().baseY;
      }

      var dot_x = (start.x + this.x_shift) + this.width - this.radius;
      var dot_y = start.y + this.y_shift + (this.dot_shiftY * line_space);
      var ctx = this.context;

      ctx.beginPath();
      ctx.arc(dot_x, dot_y, this.radius, 0, Math.PI * 2, false);
      ctx.fill();
    }
  });

  return Dot;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements the formatting and layout algorithms that are used
// to position notes in a voice. The algorithm can align multiple voices both
// within a stave, and across multiple staves.
//
// To do this, the formatter breaks up voices into a grid of rational-valued
// `ticks`, to which each note is assigned. Then, minimum widths are assigned
// to each tick based on the widths of the notes and modifiers in that tick. This
// establishes the smallest amount of space required for each tick.
//
// Finally, the formatter distributes the left over space proportionally to
// all the ticks, setting the `x` values of the notes in each tick.
//
// See `tests/formatter_tests.js` for usage examples. The helper functions included
// here (`FormatAndDraw`, `FormatAndDrawTab`) also serve as useful usage examples.

Vex.Flow.Formatter = (function() {
  function Formatter() {
    // Minimum width required to render all the notes in the voices.
    this.minTotalWidth = 0;

    // This is set to `true` after `minTotalWidth` is calculated.
    this.hasMinTotalWidth = false;

    // The suggested amount of space for each tick.
    this.pixelsPerTick = 0;

    // Total number of ticks in the voice.
    this.totalTicks = new Vex.Flow.Fraction(0, 1);

    // Arrays of tick and modifier contexts.
    this.tContexts = null;
    this.mContexts = null;
  }

  // To enable logging for this class. Set `Vex.Flow.Formatter.DEBUG` to `true`.
  function L() { if (Formatter.DEBUG) Vex.L("Vex.Flow.Formatter", arguments); }

  // ## Private Helpers
  //
  // Helper function to locate the next non-rest note(s).
  function lookAhead(notes, rest_line, i, compare) {
    // If no valid next note group, next_rest_line is same as current.
    var next_rest_line = rest_line;

    // Get the rest line for next valid non-rest note group.
    i++;
    while (i < notes.length) {
      if (!notes[i].isRest() && !notes[i].shouldIgnoreTicks()) {
        next_rest_line = notes[i].getLineForRest();
        break;
      }
      i++;
    }

    // Locate the mid point between two lines.
    if (compare && rest_line != next_rest_line) {
      var top = Vex.Max(rest_line, next_rest_line);
      var bot = Vex.Min(rest_line, next_rest_line);
      next_rest_line = Vex.MidLine(top, bot);
    }
    return next_rest_line;
  }

  // Take an array of `voices` and place aligned tickables in the same context. Returns
  // a mapping from `tick` to `context_type`, a list of `tick`s, and the resolution
  // multiplier.
  //
  // Params:
  // * `voices`: Array of `Voice` instances.
  // * `context_type`: A context class (e.g., `ModifierContext`, `TickContext`)
  // * `add_fn`: Function to add tickable to context.
  function createContexts(voices, context_type, add_fn) {
    if (!voices || !voices.length) throw new Vex.RERR("BadArgument",
        "No voices to format");

    // Initialize tick maps.
    var totalTicks = voices[0].getTotalTicks();
    var tickToContextMap = {};
    var tickList = [];
    var contexts = [];

    var resolutionMultiplier = 1;

    // Find out highest common multiple of resolution multipliers.
    // The purpose of this is to find out a common denominator
    // for all fractional tick values in all tickables of all voices,
    // so that the values can be expanded and the numerator used
    // as an integer tick value.
    var i; // shared iterator
    var voice;
    for (i = 0; i < voices.length; ++i) {
      voice = voices[i];
      if (!(voice.getTotalTicks().equals(totalTicks))) {
        throw new Vex.RERR("TickMismatch",
            "Voices should have same total note duration in ticks.");
      }

      if (voice.getMode() == Vex.Flow.Voice.Mode.STRICT && !voice.isComplete())
        throw new Vex.RERR("IncompleteVoice",
          "Voice does not have enough notes.");

      var lcm = Vex.Flow.Fraction.LCM(resolutionMultiplier,
          voice.getResolutionMultiplier());
      if (resolutionMultiplier < lcm) {
        resolutionMultiplier = lcm;
      }
    }

    // For each voice, extract notes and create a context for every
    // new tick that hasn't been seen before.
    for (i = 0; i < voices.length; ++i) {
      voice = voices[i];

      var tickables = voice.getTickables();

      // Use resolution multiplier as denominator to expand ticks
      // to suitable integer values, so that no additional expansion
      // of fractional tick values is needed.
      var ticksUsed = new Vex.Flow.Fraction(0, resolutionMultiplier);

      for (var j = 0; j < tickables.length; ++j) {
        var tickable = tickables[j];
        var integerTicks = ticksUsed.numerator;

        // If we have no tick context for this tick, create one.
        if (!tickToContextMap[integerTicks]) {
          var newContext = new context_type();
          contexts.push(newContext);
          tickToContextMap[integerTicks] = newContext;
        }

        // Add this tickable to the TickContext.
        add_fn(tickable, tickToContextMap[integerTicks]);

        // Maintain a sorted list of tick contexts.
        tickList.push(integerTicks);
        ticksUsed.add(tickable.getTicks());
      }
    }

    return {
      map: tickToContextMap,
      array: contexts,
      list: Vex.SortAndUnique(tickList, function(a, b) { return a - b; },
          function(a, b) { return a === b; } ),
      resolutionMultiplier: resolutionMultiplier
    };
  }


  // ## Static Methods
  //
  // Helper function to format and draw a single voice. Returns a bounding
  // box for the notation.
  //
  // Parameters:
  // * `ctx` - The rendering context
  // * `stave` - The stave to which to draw (`Stave` or `TabStave`)
  // * `notes` - Array of `Note` instances (`StaveNote`, `TextNote`, `TabNote`, etc.)
  // * `params` - One of below:
  //    * Setting `autobeam` only `(context, stave, notes, true)` or `(ctx, stave, notes, {autobeam: true})`
  //    * Setting `align_rests` a struct is needed `(context, stave, notes, {align_rests: true})`
  //    * Setting both a struct is needed `(context, stave, notes, {autobeam: true, align_rests: true})`
  //
  // `autobeam` automatically generates beams for the notes.
  // `align_rests` aligns rests with nearby notes.
  Formatter.FormatAndDraw = function(ctx, stave, notes, params) {
    var opts = {
      auto_beam: false,
      align_rests: false
    };

    if (typeof params == "object") {
      Vex.Merge(opts, params);
    } else if (typeof params == "boolean") {
      opts.auto_beam = params;
    }

    // Start by creating a voice and adding all the notes to it.
    var voice = new Vex.Flow.Voice(Vex.Flow.TIME4_4).
      setMode(Vex.Flow.Voice.Mode.SOFT);
    voice.addTickables(notes);

    // Then create beams, if requested.
    var beams = null;
    if (opts.auto_beam) {
      beams = Vex.Flow.Beam.applyAndGetBeams(voice);
    }

    // Instantiate a `Formatter` and format the notes.
    new Formatter().
      joinVoices([voice], {align_rests: opts.align_rests}).
      formatToStave([voice], stave, {align_rests: opts.align_rests});

    // Render the voice and beams to the stave.
    voice.setStave(stave);
    voice.draw(ctx, stave);
    if (beams != null) {
      for (var i=0; i<beams.length; ++i) {
        beams[i].setContext(ctx).draw();
      }
    }

    // Return the bounding box of the voice.
    return voice.getBoundingBox();
  };

  // Helper function to format and draw aligned tab and stave notes in two
  // separate staves.
  //
  // Parameters:
  // * `ctx` - The rendering context
  // * `tabstave` - A `TabStave` instance on which to render `TabNote`s.
  // * `stave` - A `Stave` instance on which to render `Note`s.
  // * `notes` - Array of `Note` instances for the stave (`StaveNote`, `BarNote`, etc.)
  // * `tabnotes` - Array of `Note` instances for the tab stave (`TabNote`, `BarNote`, etc.)
  // * `autobeam` - Automatically generate beams.
  // * `params` - A configuration object:
  //    * `autobeam` automatically generates beams for the notes.
  //    * `align_rests` aligns rests with nearby notes.
  Formatter.FormatAndDrawTab = function(ctx,
      tabstave, stave, tabnotes, notes, autobeam, params) {
    var opts = {
      auto_beam: autobeam,
      align_rests: false
    };

    if (typeof params == "object") {
      Vex.Merge(opts, params);
    } else if (typeof params == "boolean") {
      opts.auto_beam = params;
    }

    // Create a `4/4` voice for `notes`.
    var notevoice = new Vex.Flow.Voice(Vex.Flow.TIME4_4).
      setMode(Vex.Flow.Voice.Mode.SOFT);
    notevoice.addTickables(notes);

    // Create a `4/4` voice for `tabnotes`.
    var tabvoice = new Vex.Flow.Voice(Vex.Flow.TIME4_4).
      setMode(Vex.Flow.Voice.Mode.SOFT);
    tabvoice.addTickables(tabnotes);

    // Generate beams if requested.
    var beams = null;
    if (opts.auto_beam) {
      beams = Vex.Flow.Beam.applyAndGetBeams(notevoice);
    }


    // Instantiate a `Formatter` and align tab and stave notes.
    new Formatter().
      joinVoices([notevoice], {align_rests: opts.align_rests}).
      joinVoices([tabvoice]).
      formatToStave([notevoice,tabvoice], stave, {align_rests: opts.align_rests});

    // Render voices and beams to staves.
    notevoice.draw(ctx, stave);
    tabvoice.draw(ctx, tabstave);
    if (beams != null) {
      for (var i=0; i<beams.length; ++i) {
        beams[i].setContext(ctx).draw();
      }
    }

    // Draw a connector between tab and note staves.
    (new Vex.Flow.StaveConnector(stave, tabstave)).setContext(ctx).draw();
  };

  // Auto position rests based on previous/next note positions.
  //
  // Params:
  // * `notes`: An array of notes.
  // * `align_all_notes`: If set to false, only aligns non-beamed notes.
  // * `align_tuplets`: If set to false, ignores tuplets.
  Formatter.AlignRestsToNotes = function(notes, align_all_notes, align_tuplets) {
    for (var i = 0; i < notes.length; ++i) {
      if (notes[i] instanceof Vex.Flow.StaveNote && notes[i].isRest()) {
        var note = notes[i];

        if (note.tuplet && !align_tuplets) continue;

        // If activated rests not on default can be rendered as specified.
        var position = note.getGlyph().position.toUpperCase();
        if (position != "R/4" && position != "B/4") {
          continue;
        }

        if (align_all_notes || note.beam != null) {
          // Align rests with previous/next notes.
          var props = note.getKeyProps()[0];
          if (i === 0) {
            props.line = lookAhead(notes, props.line, i, false);
            note.setKeyLine(0, props.line);
          } else if (i > 0 && i < notes.length) {
            // If previous note is a rest, use its line number.
            var rest_line;
            if (notes[i-1].isRest()) {
              rest_line = notes[i-1].getKeyProps()[0].line;
              props.line = rest_line;
            } else {
              rest_line = notes[i-1].getLineForRest();
              // Get the rest line for next valid non-rest note group.
              props.line = lookAhead(notes, rest_line, i, true);
            }
            note.setKeyLine(0, props.line);
          }
        }
      }
    }

    return this;
  };

  // ## Prototype Methods
  Formatter.prototype = {
    // Find all the rests in each of the `voices` and align them
    // to neighboring notes. If `align_all_notes` is `false`, then only
    // align non-beamed notes.
    alignRests: function(voices, align_all_notes) {
      if (!voices || !voices.length) throw new Vex.RERR("BadArgument",
          "No voices to format rests");
      for (var i = 0; i < voices.length; i++) {
        new Formatter.AlignRestsToNotes(voices[i].tickables, align_all_notes);
      }
    },

    // Calculate the minimum width required to align and format `voices`.
    preCalculateMinTotalWidth: function(voices) {
      // Cache results.
      if (this.hasMinTotalWidth) return;

      // Create tick contexts if not already created.
      if (!this.tContexts) {
        if (!voices) {
          throw new Vex.RERR("BadArgument",
                             "'voices' required to run preCalculateMinTotalWidth");
        }
        this.createTickContexts(voices);
      }

      var contexts = this.tContexts;
      var contextList = contexts.list;
      var contextMap = contexts.map;

      this.minTotalWidth = 0;

      // Go through each tick context and calculate total width.
      for (var i = 0; i < contextList.length; ++i) {
        var context = contextMap[contextList[i]];

        // `preFormat` gets them to descend down to their tickables and modifier
        // contexts, and calculate their widths.
        context.preFormat();
        this.minTotalWidth += context.getWidth();
      }

      this.hasMinTotalWidth = true;

      return this.minTotalWidth;
    },

    // Get minimum width required to render all voices. Either `format` or
    // `preCalculateMinTotalWidth` must be called before this method.
    getMinTotalWidth: function() {
      if (!this.hasMinTotalWidth) {
        throw new Vex.RERR("NoMinTotalWidth",
            "Need to call 'preCalculateMinTotalWidth' or 'preFormat' before" +
            " calling 'getMinTotalWidth'");
      }

      return this.minTotalWidth;
    },

    // Create `ModifierContext`s for each tick in `voices`.
    createModifierContexts: function(voices) {
      var contexts = createContexts(voices,
          Vex.Flow.ModifierContext,
          function(tickable, context) {
            tickable.addToModifierContext(context);
          });
      this.mContexts = contexts;
      return contexts;
    },

    // Create `TickContext`s for each tick in `voices`. Also calculate the
    // total number of ticks in voices.
    createTickContexts: function(voices) {
      var contexts = createContexts(voices,
          Vex.Flow.TickContext,
          function(tickable, context) { context.addTickable(tickable); });

      contexts.array.forEach(function(context) {
        context.tContexts = contexts.array;
      });

      this.totalTicks = voices[0].getTicksUsed().clone();
      this.tContexts = contexts;
      return contexts;
    },

    // This is the core formatter logic. Format voices and justify them
    // to `justifyWidth` pixels. `rendering_context` is required to justify elements
    // that can't retreive widths without a canvas. This method sets the `x` positions
    // of all the tickables/notes in the formatter.
    preFormat: function(justifyWidth, rendering_context, voices, stave) {
      // Initialize context maps.
      var contexts = this.tContexts;
      var contextList = contexts.list;
      var contextMap = contexts.map;

      // If voices and a stave were provided, set the Stave for each voice
      // and preFormat to apply Y values to the notes;
      if (voices && stave) {
        voices.forEach(function(voice) {
          voice.setStave(stave);
          voice.preFormat();
        });
      }

      // Figure out how many pixels to allocate per tick.
      if (!justifyWidth) {
        justifyWidth = 0;
        this.pixelsPerTick = 0;
      } else {
        this.pixelsPerTick = justifyWidth / (this.totalTicks.value() * contexts.resolutionMultiplier);
      }

      // Now distribute the ticks to each tick context, and assign them their
      // own X positions.
      var x = 0;
      var center_x = justifyWidth / 2;
      var white_space = 0; // White space to right of previous note
      var tick_space = 0;  // Pixels from prev note x-pos to curent note x-pos
      var prev_tick = 0;
      var prev_width = 0;
      var lastMetrics = null;
      var initial_justify_width = justifyWidth;
      this.minTotalWidth = 0;

      var i, tick, context;

      // Pass 1: Give each note maximum width requested by context.
      for (i = 0; i < contextList.length; ++i) {
        tick = contextList[i];
        context = contextMap[tick];
        if (rendering_context) context.setContext(rendering_context);

        // Make sure that all tickables in this context have calculated their
        // space requirements.
        context.preFormat();

        var thisMetrics = context.getMetrics();
        var width = context.getWidth();
        this.minTotalWidth += width;
        var min_x = 0;
        var pixels_used = width;

        // Calculate space between last note and next note.
        tick_space = Math.min((tick - prev_tick) * this.pixelsPerTick, pixels_used);

        // Shift next note up `tick_space` pixels.
        var set_x = x + tick_space;

        // Calculate the minimum next note position to allow for right modifiers.
        if (lastMetrics != null) {
          min_x = x + prev_width - lastMetrics.extraLeftPx;
        }

        // Determine the space required for the previous tick.
        // The `shouldIgnoreTicks` bool is true for elements in the stave
        // that don't consume ticks (bar lines, key and time signatures, etc.)
        set_x = context.shouldIgnoreTicks() ?
            (min_x + context.getWidth()) : Math.max(set_x, min_x);

        if (context.shouldIgnoreTicks() && justifyWidth) {
            // This note stole room... recalculate with new justification width.
            justifyWidth -= context.getWidth();
            this.pixelsPerTick = justifyWidth /
              (this.totalTicks.value() * contexts.resolutionMultiplier);
        }

        // Determine pixels needed for left modifiers.
        var left_px = thisMetrics.extraLeftPx;

        // Determine white space to right of previous tick (from right modifiers.)
        if (lastMetrics != null) {
          white_space = (set_x - x) - (prev_width -
                                       lastMetrics.extraLeftPx);
        }

        // Deduct pixels from white space quota.
        if (i > 0) {
          if (white_space > 0) {
            if (white_space >= left_px) {
              // Have enough white space for left modifiers - no offset needed.
              left_px = 0;
            } else {
              // Decrease left modifier offset by amount of white space.
              left_px -= white_space;
            }
          }
        }

        // Adjust the tick x position with the left modifier offset.
        set_x += left_px;

        // Set the `x` value for the context, which sets the `x` value for all
        // tickables in this context.
        context.setX(set_x);
        context.setPixelsUsed(pixels_used);  // ??? Remove this if nothing breaks

        lastMetrics = thisMetrics;
        prev_width = width;
        prev_tick = tick;
        x = set_x;
      }

      this.hasMinTotalWidth = true;
      if (justifyWidth > 0) {
        // Pass 2: Take leftover width, and distribute it to proportionately to
        // all notes.
        var remaining_x = initial_justify_width - (x + prev_width);
        var leftover_pixels_per_tick = remaining_x / (this.totalTicks.value() * contexts.resolutionMultiplier);
        var accumulated_space = 0;
        prev_tick = 0;

        for (i = 0; i < contextList.length; ++i) {
          tick = contextList[i];
          context = contextMap[tick];
          tick_space = (tick - prev_tick) * leftover_pixels_per_tick;
          accumulated_space = accumulated_space + tick_space;
          context.setX(context.getX() + accumulated_space);
          prev_tick = tick;

          // Move center aligned tickables to middle
          var centeredTickables = context.getCenterAlignedTickables();

          /*jshint -W083 */
          centeredTickables.forEach(function(tickable) {
            tickable.center_x_shift = center_x - context.getX();
          });
        }
      }
    },

    // This is the top-level call for all formatting logic completed
    // after `x` *and* `y` values have been computed for the notes
    // in the voices.
    postFormat: function() {
      // Postformat modifier contexts
      this.mContexts.list.forEach(function(mContext) {
        this.mContexts.map[mContext].postFormat();
      }, this);

      // Postformat tick contexts
      this.tContexts.list.forEach(function(tContext) {
        this.tContexts.map[tContext].postFormat();
      }, this);

      return this;
    },

    // Take all `voices` and create `ModifierContext`s out of them. This tells
    // the formatters that the voices belong on a single stave.
    joinVoices: function(voices) {
      this.createModifierContexts(voices);
      this.hasMinTotalWidth = false;
      return this;
    },

    // Align rests in voices, justify the contexts, and position the notes
    // so voices are aligned and ready to render onto the stave. This method
    // mutates the `x` positions of all tickables in `voices`.
    //
    // Voices are full justified to fit in `justifyWidth` pixels.
    //
    // Set `options.context` to the rendering context. Set `options.align_rests`
    // to true to enable rest alignment.
    format: function(voices, justifyWidth, options) {
      var opts = {
        align_rests: false,
        context: null,
        stave: null
      };

      Vex.Merge(opts, options);
      this.alignRests(voices, opts.align_rests);
      this.createTickContexts(voices);
      this.preFormat(justifyWidth, opts.context, voices, opts.stave);

      // Only postFormat if a stave was supplied for y value formatting
      if (opts.stave) this.postFormat();

      return this;
    },

    // This method is just like `format` except that the `justifyWidth` is inferred
    // from the `stave`.
    formatToStave: function(voices, stave, options) {
      var justifyWidth = stave.getNoteEndX() - stave.getNoteStartX() - 10;
      L("Formatting voices to width: ", justifyWidth);
      var opts = {context: stave.getContext()};
      Vex.Merge(opts, options);
      return this.format(voices, justifyWidth, opts);
    }
  };

  return Formatter;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements varies types of ties between contiguous notes. The
// ties include: regular ties, hammer ons, pull offs, and slides.

/**
 * Create a new tie from the specified notes. The notes must
 * be part of the same line, and have the same duration (in ticks).
 *
 * @constructor
 * @param {!Object} context The canvas context.
 * @param {!Object} notes The notes to tie up.
 * @param {!Object} Options
 */
Vex.Flow.StaveTie = (function() {
  function StaveTie(notes, text) {
    if (arguments.length > 0) this.init(notes, text);
  }

  StaveTie.prototype = {
    init: function(notes, text) {
      /**
       * Notes is a struct that has:
       *
       *  {
       *    first_note: Note,
       *    last_note: Note,
       *    first_indices: [n1, n2, n3],
       *    last_indices: [n1, n2, n3]
       *  }
       *
       **/
      this.notes = notes;
      this.context = null;
      this.text = text;

      this.render_options = {
          cp1: 8,      // Curve control point 1
          cp2: 12,      // Curve control point 2
          text_shift_x: 0,
          first_x_shift: 0,
          last_x_shift: 0,
          y_shift: 7,
          tie_spacing: 0,
          font: { family: "Arial", size: 10, style: "" }
        };

      this.font = this.render_options.font;
      this.setNotes(notes);
    },

    setContext: function(context) { this.context = context; return this; },
    setFont: function(font) { this.font = font; return this; },

    /**
     * Set the notes to attach this tie to.
     *
     * @param {!Object} notes The notes to tie up.
     */
    setNotes: function(notes) {
      if (!notes.first_note && !notes.last_note)
        throw new Vex.RuntimeError("BadArguments",
            "Tie needs to have either first_note or last_note set.");

      if (!notes.first_indices) notes.first_indices = [0];
      if (!notes.last_indices) notes.last_indices = [0];

      if (notes.first_indices.length != notes.last_indices.length)
        throw new Vex.RuntimeError("BadArguments", "Tied notes must have similar" +
          " index sizes");

      // Success. Lets grab 'em notes.
      this.first_note = notes.first_note;
      this.first_indices = notes.first_indices;
      this.last_note = notes.last_note;
      this.last_indices = notes.last_indices;
      return this;
    },

    /**
     * @return {boolean} Returns true if this is a partial bar.
     */
    isPartial: function() {
      return (!this.first_note || !this.last_note);
    },

    renderTie: function(params) {
      if (params.first_ys.length === 0 || params.last_ys.length === 0)
        throw new Vex.RERR("BadArguments", "No Y-values to render");

      var ctx = this.context;
      var cp1 = this.render_options.cp1;
      var cp2 = this.render_options.cp2;

      if (Math.abs(params.last_x_px - params.first_x_px) < 10) {
        cp1 = 2; cp2 = 8;
      }

      var first_x_shift = this.render_options.first_x_shift;
      var last_x_shift = this.render_options.last_x_shift;
      var y_shift = this.render_options.y_shift * params.direction;

      for (var i = 0; i < this.first_indices.length; ++i) {
        var cp_x = ((params.last_x_px + last_x_shift) +
                    (params.first_x_px + first_x_shift)) / 2;
        var first_y_px = params.first_ys[this.first_indices[i]] + y_shift;
        var last_y_px = params.last_ys[this.last_indices[i]] + y_shift;

        if (isNaN(first_y_px) || isNaN(last_y_px))
          throw new Vex.RERR("BadArguments", "Bad indices for tie rendering.");

        var top_cp_y = ((first_y_px + last_y_px) / 2) + (cp1 * params.direction);
        var bottom_cp_y = ((first_y_px + last_y_px) / 2) + (cp2 * params.direction);

        ctx.beginPath();
        ctx.moveTo(params.first_x_px + first_x_shift, first_y_px);
        ctx.quadraticCurveTo(cp_x, top_cp_y,
                             params.last_x_px + last_x_shift, last_y_px);
        ctx.quadraticCurveTo(cp_x, bottom_cp_y,
                             params.first_x_px + first_x_shift, first_y_px);

        ctx.closePath();
        ctx.fill();
      }
    },

    renderText: function(first_x_px, last_x_px) {
      if (!this.text) return;
      var center_x = (first_x_px + last_x_px) / 2;
      center_x -= this.context.measureText(this.text).width / 2;

      this.context.save();
      this.context.setFont(this.font.family, this.font.size, this.font.style);
      this.context.fillText(
          this.text, center_x + this.render_options.text_shift_x,
          (this.first_note || this.last_note).getStave().getYForTopText() - 1);
      this.context.restore();
    },

    draw: function() {
      if (!this.context)
        throw new Vex.RERR("NoContext", "No context to render tie.");
      var first_note = this.first_note;
      var last_note = this.last_note;
      var first_x_px, last_x_px, first_ys, last_ys, stem_direction;

      if (first_note) {
        first_x_px = first_note.getTieRightX() + this.render_options.tie_spacing;
        stem_direction = first_note.getStemDirection();
        first_ys = first_note.getYs();
      } else {
        first_x_px = last_note.getStave().getTieStartX();
        first_ys = last_note.getYs();
        this.first_indices = this.last_indices;
      }

      if (last_note) {
        last_x_px = last_note.getTieLeftX() + this.render_options.tie_spacing;
        stem_direction = last_note.getStemDirection();
        last_ys = last_note.getYs();
      } else {
        last_x_px = first_note.getStave().getTieEndX();
        last_ys = first_note.getYs();
        this.last_indices = this.first_indices;
      }

      this.renderTie({
        first_x_px: first_x_px,
        last_x_px: last_x_px,
        first_ys: first_ys,
        last_ys: last_ys,
        direction: stem_direction
      });

      this.renderText(first_x_px, last_x_px);
      return true;
    }
  };

  return StaveTie;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements varies types of ties between contiguous notes. The
// ties include: regular ties, hammer ons, pull offs, and slides.

/**
 * Create a new tie from the specified notes. The notes must
 * be part of the same line, and have the same duration (in ticks).
 *
 * @constructor
 * @param {!Object} context The canvas context.
 * @param {!Object} notes The notes to tie up.
 * @param {!Object} Options
 */
Vex.Flow.TabTie = (function() {
  function TabTie(notes, text) {
    if (arguments.length > 0) this.init(notes, text);
  }

  TabTie.createHammeron = function(notes) {
    return new TabTie(notes, "H");
  };

  TabTie.createPulloff = function(notes) {
    return new TabTie(notes, "P");
  };

  Vex.Inherit(TabTie, Vex.Flow.StaveTie, {
    init: function(notes, text) {
      /**
       * Notes is a struct that has:
       *
       *  {
       *    first_note: Note,
       *    last_note: Note,
       *    first_indices: [n1, n2, n3],
       *    last_indices: [n1, n2, n3]
       *  }
       *
       **/
      TabTie.superclass.init.call(this, notes, text);
      this.render_options.cp1 = 9;
      this.render_options.cp2 = 11;
      this.render_options.y_shift = 3;

      this.setNotes(notes);
    },

    draw: function() {
      if (!this.context)
        throw new Vex.RERR("NoContext", "No context to render tie.");
      var first_note = this.first_note;
      var last_note = this.last_note;
      var first_x_px, last_x_px, first_ys, last_ys;

      if (first_note) {
        first_x_px = first_note.getTieRightX() + this.render_options.tie_spacing;
        first_ys = first_note.getYs();
      } else {
        first_x_px = last_note.getStave().getTieStartX();
        first_ys = last_note.getYs();
        this.first_indices = this.last_indices;
      }

      if (last_note) {
        last_x_px = last_note.getTieLeftX() + this.render_options.tie_spacing;
        last_ys = last_note.getYs();
      } else {
        last_x_px = first_note.getStave().getTieEndX();
        last_ys = first_note.getYs();
        this.last_indices = this.first_indices;
      }

      this.renderTie({
        first_x_px: first_x_px,
        last_x_px: last_x_px,
        first_ys: first_ys,
        last_ys: last_ys,
        direction: -1           // Tab tie's are always face up.
      });

      this.renderText(first_x_px, last_x_px);
      return true;
    }
  });

  return TabTie;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements varies types of ties between contiguous notes. The
// ties include: regular ties, hammer ons, pull offs, and slides.

/**
 * Create a new tie from the specified notes. The notes must
 * be part of the same line, and have the same duration (in ticks).
 *
 * @constructor
 * @param {!Object} context The canvas context.
 * @param {!Object} notes The notes to tie up.
 * @param {!Object} Options
 */
Vex.Flow.TabSlide = (function() {
  function TabSlide(notes, direction) {
    if (arguments.length > 0) this.init(notes, direction);
  }

  TabSlide.SLIDE_UP = 1;
  TabSlide.SLIDE_DOWN = -1;

  TabSlide.createSlideUp = function(notes) {
    return new TabSlide(notes, TabSlide.SLIDE_UP);
  };

  TabSlide.createSlideDown = function(notes) {
    return new TabSlide(notes, TabSlide.SLIDE_DOWN);
  };

  Vex.Inherit(TabSlide, Vex.Flow.TabTie, {
    init: function(notes, direction) {
      /**
       * Notes is a struct that has:
       *
       *  {
       *    first_note: Note,
       *    last_note: Note,
       *    first_indices: [n1, n2, n3],
       *    last_indices: [n1, n2, n3]
       *  }
       *
       **/
      TabSlide.superclass.init.call(this, notes, "sl.");
      if (!direction) {
        var first_fret = notes.first_note.getPositions()[0].fret;
        var last_fret = notes.last_note.getPositions()[0].fret;

        direction = ((parseInt(first_fret, 10) > parseInt(last_fret, 10)) ?
          TabSlide.SLIDE_DOWN : TabSlide.SLIDE_UP);
      }

      this.slide_direction = direction;
      this.render_options.cp1 = 11;
      this.render_options.cp2 = 14;
      this.render_options.y_shift = 0.5;

      this.setFont({font: "Times", size: 10, style: "bold italic"});
      this.setNotes(notes);
    },

    renderTie: function(params) {
      if (params.first_ys.length === 0 || params.last_ys.length === 0)
        throw new Vex.RERR("BadArguments", "No Y-values to render");

      var ctx = this.context;
      var first_x_px = params.first_x_px;
      var first_ys = params.first_ys;
      var last_x_px = params.last_x_px;

      var direction = this.slide_direction;
      if (direction != TabSlide.SLIDE_UP &&
          direction != TabSlide.SLIDE_DOWN) {
        throw new Vex.RERR("BadSlide", "Invalid slide direction");
      }

      for (var i = 0; i < this.first_indices.length; ++i) {
        var slide_y = first_ys[this.first_indices[i]] +
          this.render_options.y_shift;

        if (isNaN(slide_y))
          throw new Vex.RERR("BadArguments", "Bad indices for slide rendering.");

        ctx.beginPath();
        ctx.moveTo(first_x_px, slide_y + (3 * direction));
        ctx.lineTo(last_x_px, slide_y - (3 * direction));
        ctx.closePath();
        ctx.stroke();
      }
    }
  });

  return TabSlide;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements tablature bends.

/**
   @param text Text for bend ("Full", "Half", etc.) (DEPRECATED)
   @param release If true, render a release. (DEPRECATED)
   @param phrase If set, ignore "text" and "release", and use the more
                 sophisticated phrase specified.

   Example of a phrase:

     [{
       type: UP,
       text: "whole"
       width: 8;
     },
     {
       type: DOWN,
       text: "whole"
       width: 8;
     },
     {
       type: UP,
       text: "half"
       width: 8;
     },
     {
       type: UP,
       text: "whole"
       width: 8;
     },
     {
       type: DOWN,
       text: "1 1/2"
       width: 8;
     }]
 */
Vex.Flow.Bend = (function() {
  function Bend(text, release, phrase) {
    if (arguments.length > 0) this.init(text, release, phrase);
  }
  Bend.CATEGORY = "bends";

  Bend.UP = 0;
  Bend.DOWN = 1;

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods
  // Arrange bends in `ModifierContext`
  Bend.format = function(bends, state) {
    if (!bends || bends.length === 0) return false;

    var last_width = 0;
    // Bends are always on top.
    var text_line = state.top_text_line;

    // Format Bends
    for (var i = 0; i < bends.length; ++i) {
      var bend = bends[i];
      bend.setXShift(last_width);
      last_width = bend.getWidth();
      bend.setTextLine(text_line);
    }

    state.right_shift += last_width;
    state.top_text_line += 1;
    return true;
  };

  // ## Prototype Methods
  Vex.Inherit(Bend, Modifier, {
    init: function(text, release, phrase) {
      var superclass = Vex.Flow.Bend.superclass;
      superclass.init.call(this);

      this.text = text;
      this.x_shift = 0;
      this.release = release || false;
      this.font = "10pt Arial";
      this.render_options = {
        line_width: 1.5,
        line_style: "#777777",
        bend_width: 8,
        release_width: 8
      };

      if (phrase) {
        this.phrase = phrase;
      } else {
        // Backward compatibility
        this.phrase = [{type: Bend.UP, text: this.text}];
        if (this.release) this.phrase.push({type: Bend.DOWN, text: ""});
      }

      this.updateWidth();
    },

    setXShift: function(value) {
      this.x_shift = value;
      this.updateWidth();
    },

    setFont: function(font) { this.font = font; return this; },

    getText: function() { return this.text; },

    updateWidth: function() {
      var that = this;

      function measure_text(text) {
        var text_width;
        if (that.context) {
          text_width = that.context.measureText(text).width;
        } else {
          text_width = Vex.Flow.textWidth(text);
        }

        return text_width;
      }

      var total_width = 0;
      for (var i=0; i<this.phrase.length; ++i) {
        var bend = this.phrase[i];
        if ('width' in bend) {
          total_width += bend.width;
        } else {
          var additional_width = (bend.type == Bend.UP) ?
            this.render_options.bend_width : this.render_options.release_width;

          bend.width = Vex.Max(additional_width, measure_text(bend.text)) + 3;
          bend.draw_width = bend.width / 2;
          total_width += bend.width;
        }
      }

      this.setWidth(total_width + this.x_shift);
      return this;
    },

    draw: function() {
        if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw bend without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoNoteForBend",
        "Can't draw bend without a note or index.");

      var start = this.note.getModifierStartXY(Modifier.Position.RIGHT,
          this.index);
      start.x += 3;
      start.y += 0.5;
      var x_shift = this.x_shift;

      var ctx = this.context;
      var bend_height = this.note.getStave().getYForTopText(this.text_line) + 3;
      var annotation_y = this.note.getStave().getYForTopText(this.text_line) - 1;
      var that = this;

      function renderBend(x, y, width, height) {
        var cp_x = x + width;
        var cp_y = y;

        ctx.save();
        ctx.beginPath();
        ctx.setLineWidth(that.render_options.line_width);
        ctx.setStrokeStyle(that.render_options.line_style);
        ctx.setFillStyle(that.render_options.line_style);
        ctx.moveTo(x, y);
        ctx.quadraticCurveTo(cp_x, cp_y, x + width, height);
        ctx.stroke();
        ctx.restore();
      }

      function renderRelease(x, y, width, height) {
        ctx.save();
        ctx.beginPath();
        ctx.setLineWidth(that.render_options.line_width);
        ctx.setStrokeStyle(that.render_options.line_style);
        ctx.setFillStyle(that.render_options.line_style);
        ctx.moveTo(x, height);
        ctx.quadraticCurveTo(
            x + width, height,
            x + width, y);
        ctx.stroke();
        ctx.restore();
      }

      function renderArrowHead(x, y, direction) {
        var width = 4;
        var dir = direction || 1;

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - width, y + width * dir);
        ctx.lineTo(x + width, y + width * dir);
        ctx.closePath();
        ctx.fill();
      }

      function renderText(x, text) {
        ctx.save();
        ctx.setRawFont(that.font);
        var render_x = x - (ctx.measureText(text).width / 2);
        ctx.fillText(text, render_x, annotation_y);
        ctx.restore();
      }

      var last_bend = null;
      var last_drawn_width = 0;
      for (var i=0; i<this.phrase.length; ++i) {
        var bend = this.phrase[i];
        if (i === 0) bend.draw_width += x_shift;

        last_drawn_width = bend.draw_width + (last_bend?last_bend.draw_width:0) - (i==1?x_shift:0);
        if (bend.type == Bend.UP) {
          if (last_bend && last_bend.type == Bend.UP) {
            renderArrowHead(start.x, bend_height);
          }

          renderBend(start.x, start.y, last_drawn_width, bend_height);
        }

        if (bend.type == Bend.DOWN) {
          if (last_bend && last_bend.type == Bend.UP) {
            renderRelease(start.x, start.y, last_drawn_width, bend_height);
          }

          if (last_bend && last_bend.type == Bend.DOWN) {
            renderArrowHead(start.x, start.y, -1);
            renderRelease(start.x, start.y, last_drawn_width, bend_height);
          }

          if (last_bend == null) {
            last_drawn_width = bend.draw_width;
            renderRelease(start.x, start.y, last_drawn_width, bend_height);
          }
        }

        renderText(start.x + last_drawn_width, bend.text);
        last_bend = bend;
        last_bend.x = start.x;

        start.x += last_drawn_width;
      }

      // Final arrowhead and text
      if (last_bend.type == Bend.UP) {
        renderArrowHead(last_bend.x + last_drawn_width, bend_height);
      } else if (last_bend.type == Bend.DOWN) {
        renderArrowHead(last_bend.x + last_drawn_width, start.y, -1);
      }
    }
  });

  return Bend;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This class implements vibratos.

Vex.Flow.Vibrato = (function() {
  function Vibrato() { this.init(); }
  Vibrato.CATEGORY = "vibratos";

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods
  // Arrange vibratos inside a `ModifierContext`.
  Vibrato.format = function(vibratos, state, context) {
    if (!vibratos || vibratos.length === 0) return false;

    // Vibratos are always on top.
    var text_line = state.top_text_line;
    var width = 0;
    var shift = state.right_shift - 7;

    // If there's a bend, drop the text line
    var bends = context.getModifiers(Vex.Flow.Bend.CATEGORY);
    if (bends && bends.length > 0) {
      text_line--;
    }

    // Format Vibratos
    for (var i = 0; i < vibratos.length; ++i) {
      var vibrato = vibratos[i];
      vibrato.setXShift(shift);
      vibrato.setTextLine(text_line);
      width += vibrato.getWidth();
      shift += width;
    }

    state.right_shift += width;
    state.top_text_line += 1;
    return true;
  };

  // ## Prototype Methods
  Vex.Inherit(Vibrato, Modifier, {
    init: function() {
      var superclass = Vex.Flow.Vibrato.superclass;
      superclass.init.call(this);

      this.harsh = false;
      this.position = Vex.Flow.Modifier.Position.RIGHT;
      this.render_options = {
        vibrato_width: 20,
        wave_height: 6,
        wave_width: 4,
        wave_girth: 2
      };

      this.setVibratoWidth(this.render_options.vibrato_width);
    },

    setHarsh: function(harsh) { this.harsh = harsh; return this; },
    setVibratoWidth: function(width) {
      this.vibrato_width = width;
      this.setWidth(this.vibrato_width);
      return this;
    },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw vibrato without a context.");
      if (!this.note) throw new Vex.RERR("NoNoteForVibrato",
        "Can't draw vibrato without an attached note.");

      var start = this.note.getModifierStartXY(Vex.Flow.Modifier.Position.RIGHT,
          this.index);

      var ctx = this.context;
      var that = this;
      var vibrato_width = this.vibrato_width;

      function renderVibrato(x, y) {
        var wave_width = that.render_options.wave_width;
        var wave_girth = that.render_options.wave_girth;
        var wave_height = that.render_options.wave_height;
        var num_waves = vibrato_width / wave_width;

        ctx.beginPath();

        var i;
        if (that.harsh) {
          ctx.moveTo(x, y + wave_girth + 1);
          for (i = 0; i < num_waves / 2; ++i) {
            ctx.lineTo(x + wave_width, y - (wave_height / 2));
            x += wave_width;
            ctx.lineTo(x + wave_width, y + (wave_height / 2));
            x += wave_width;
          }
          for (i = 0; i < num_waves / 2; ++i) {
            ctx.lineTo(x - wave_width, (y - (wave_height / 2)) + wave_girth + 1);
            x -= wave_width;
            ctx.lineTo(x - wave_width, (y + (wave_height / 2)) + wave_girth + 1);
            x -= wave_width;
          }
          ctx.fill();
        } else {
          ctx.moveTo(x, y + wave_girth);
          for (i = 0; i < num_waves / 2; ++i) {
            ctx.quadraticCurveTo(x + (wave_width / 2), y - (wave_height / 2),
              x + wave_width, y);
            x += wave_width;
            ctx.quadraticCurveTo(x + (wave_width / 2), y + (wave_height / 2),
              x + wave_width, y);
            x += wave_width;
          }

          for (i = 0; i < num_waves / 2; ++i) {
            ctx.quadraticCurveTo(
                x - (wave_width / 2),
                (y + (wave_height / 2)) + wave_girth,
                x - wave_width, y + wave_girth);
            x -= wave_width;
            ctx.quadraticCurveTo(
                x - (wave_width / 2),
                (y - (wave_height / 2)) + wave_girth,
                x - wave_width, y + wave_girth);
            x -= wave_width;
          }
          ctx.fill();
        }
      }

      var vx = start.x + this.x_shift;
      var vy = this.note.getYForTopText(this.text_line) + 2;

      renderVibrato(vx, vy);
    }
  });

  return Vibrato;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements text annotations as modifiers that can be attached to
// notes.
//
// See `tests/annotation_tests.js` for usage examples.

Vex.Flow.Annotation = (function() {
  function Annotation(text) {
    if (arguments.length > 0) this.init(text);
  }

  Annotation.CATEGORY = "annotations";
  var Modifier = Vex.Flow.Modifier;

  // To enable logging for this class. Set `Vex.Flow.Annotation.DEBUG` to `true`.
  function L() { if (Annotation.DEBUG) Vex.L("Vex.Flow.Annotation", arguments); }

  // Text annotations can be positioned and justified relative to the note.
  Annotation.Justify = {
    LEFT: 1,
    CENTER: 2,
    RIGHT: 3,
    CENTER_STEM: 4
  };

  Annotation.VerticalJustify = {
    TOP: 1,
    CENTER: 2,
    BOTTOM: 3,
    CENTER_STEM: 4
  };

  // Arrange annotations within a `ModifierContext`
  Annotation.format = function(annotations, state) {
    if (!annotations || annotations.length === 0) return false;

    var width = 0;
    for (var i = 0; i < annotations.length; ++i) {
      var annotation = annotations[i];
      width = Math.max(annotation.getWidth(), width);
      if (annotation.getPosition() === Modifier.Position.ABOVE) {
        annotation.setTextLine(state.top_text_line);
        state.top_text_line++;
      } else {
        annotation.setTextLine(state.text_line);
        state.text_line++;
      }
    }

    state.left_shift += width / 2;
    state.right_shift += width / 2;
    return true;
  };

  // ## Prototype Methods
  //
  // Annotations inherit from `Modifier` and is positioned correctly when
  // in a `ModifierContext`.
  Vex.Inherit(Annotation, Modifier, {
    // Create a new `Annotation` with the string `text`.
    init: function(text) {
      Annotation.superclass.init.call(this);

      this.note = null;
      this.index = null;
      this.text = text;
      this.justification = Annotation.Justify.CENTER;
      this.vert_justification = Annotation.VerticalJustify.TOP;
      this.font = {
        family: "Arial",
        size: 10,
        weight: ""
      };

      // The default width is calculated from the text.
      this.setWidth(Vex.Flow.textWidth(text));
    },

    // Set font family, size, and weight. E.g., `Arial`, `10pt`, `Bold`.
    setFont: function(family, size, weight) {
      this.font = { family: family, size: size, weight: weight };
      return this;
    },

    // Set vertical position of text (above or below stave). `just` must be
    // a value in `Annotation.VerticalJustify`.
    setVerticalJustification: function(just) {
      this.vert_justification = just;
      return this;
    },

    // Get and set horizontal justification. `justification` is a value in
    // `Annotation.Justify`.
    getJustification: function() { return this.justification; },
    setJustification: function(justification) {
      this.justification = justification; return this; },

    // Render text beside the note.
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw text annotation without a context.");
      if (!this.note) throw new Vex.RERR("NoNoteForAnnotation",
        "Can't draw text annotation without an attached note.");

      var start = this.note.getModifierStartXY(Modifier.Position.ABOVE,
          this.index);

      // We're changing context parameters. Save current state.
      this.context.save();
      this.context.setFont(this.font.family, this.font.size, this.font.weight);
      var text_width = this.context.measureText(this.text).width;

      // Estimate text height to be the same as the width of an 'm'.
      //
      // This is a hack to work around the inability to measure text height
      // in HTML5 Canvas (and SVG).
      var text_height = this.context.measureText("m").width;
      var x, y;

      if (this.justification == Annotation.Justify.LEFT) {
        x = start.x;
      } else if (this.justification == Annotation.Justify.RIGHT) {
        x = start.x - text_width;
      } else if (this.justification == Annotation.Justify.CENTER) {
        x = start.x - text_width / 2;
      } else /* CENTER_STEM */ {
        x = this.note.getStemX() - text_width / 2;
      }

      var stem_ext, spacing;
      var has_stem = this.note.hasStem();
      var stave = this.note.getStave();

      // The position of the text varies based on whether or not the note
      // has a stem.
      if (has_stem) {
        stem_ext = this.note.getStem().getExtents();
        spacing = stave.getSpacingBetweenLines();
      }

      if (this.vert_justification == Annotation.VerticalJustify.BOTTOM) {
        y = stave.getYForBottomText(this.text_line);
        if (has_stem) {
          var stem_base = (this.note.getStemDirection() === 1 ? stem_ext.baseY : stem_ext.topY);
          y = Math.max(y, stem_base + (spacing * (this.text_line + 2)));
        }
      } else if (this.vert_justification ==
                 Annotation.VerticalJustify.CENTER) {
        var yt = this.note.getYForTopText(this.text_line) - 1;
        var yb = stave.getYForBottomText(this.text_line);
        y = yt + ( yb - yt ) / 2 + text_height / 2;
      } else if (this.vert_justification ==
                 Annotation.VerticalJustify.TOP) {
        y = Math.min(stave.getYForTopText(this.text_line), this.note.getYs()[0] - 10);
        if (has_stem) {
          y = Math.min(y, (stem_ext.topY - 5) - (spacing * this.text_line));
        }
      } else /* CENTER_STEM */{
        var extents = this.note.getStemExtents();
        y = extents.topY + (extents.baseY - extents.topY) / 2 +
          text_height / 2;
      }

      L("Rendering annotation: ", this.text, x, y);
      this.context.fillText(this.text, x, y);
      this.context.restore();
    }
  });

  return Annotation;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// Author: Larry Kuhns.
//
// ## Description
//
// This file implements articulations and accents as modifiers that can be
// attached to notes. The complete list of articulations is available in
// `tables.js` under `Vex.Flow.articulationCodes`.
//
// See `tests/articulation_tests.js` for usage examples.

Vex.Flow.Articulation = (function() {
  function Articulation(type) {
    if (arguments.length > 0) this.init(type);
  }
  Articulation.CATEGORY = "articulations";

  // To enable logging for this class. Set `Vex.Flow.Articulation.DEBUG` to `true`.
  function L() { if (Articulation.DEBUG) Vex.L("Vex.Flow.Articulation", arguments); }

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods
  // Arrange articulations inside `ModifierContext`
  Articulation.format = function(articulations, state) {
    if (!articulations || articulations.length === 0) return false;

    var width = 0;
    for (var i = 0; i < articulations.length; ++i) {
      var increment = 1;
      var articulation = articulations[i];
      width = Math.max(articulation.getWidth(), width);

      var type = Vex.Flow.articulationCodes(articulation.type);

      if (!type.between_lines) increment += 1.5;

      if (articulation.getPosition() === Modifier.Position.ABOVE) {
        articulation.setTextLine(state.top_text_line);
        state.top_text_line += increment;
      } else {
        articulation.setTextLine(state.text_line);
        state.text_line += increment;
      }
    }

    state.left_shift += width / 2;
    state.right_shift += width / 2;
    return true;
  };

  // ## Prototype Methods
  Vex.Inherit(Articulation, Modifier, {
    // Create a new articulation of type `type`, which is an entry in
    // `Vex.Flow.articulationCodes` in `tables.js`.
    init: function(type) {
      Articulation.superclass.init.call(this);

      this.note = null;
      this.index = null;
      this.type = type;
      this.position = Modifier.Position.BELOW;

      this.render_options = {
        font_scale: 38
      };

      this.articulation = Vex.Flow.articulationCodes(this.type);
      if (!this.articulation) throw new Vex.RERR("ArgumentError",
         "Articulation not found: '" + this.type + "'");

      // Default width comes from articulation table.
      this.setWidth(this.articulation.width);
    },

    // Render articulation in position next to note.
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw Articulation without a context.");
      if (!(this.note && (this.index !== null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw Articulation without a note and index.");

      var stem_direction = this.note.getStemDirection();
      var stave = this.note.getStave();

      var is_on_head = (this.position === Modifier.Position.ABOVE &&
                        stem_direction === Vex.Flow.StaveNote.STEM_DOWN) ||
                       (this.position === Modifier.Position.BELOW &&
                        stem_direction === Vex.Flow.StaveNote.STEM_UP);

      var needsLineAdjustment = function(articulation, note_line, line_spacing) {
        var offset_direction = (articulation.position === Modifier.Position.ABOVE) ? 1 : -1;
        var duration = articulation.getNote().getDuration();
        if(!is_on_head && Vex.Flow.durationToNumber(duration) <= 1){
          // Add stem length, unless it's on a whole note.
          note_line += offset_direction * 3.5;
        }

        var articulation_line = note_line + (offset_direction * line_spacing);

        if(articulation_line >= 1 &&
           articulation_line <= 5 &&
           articulation_line % 1 === 0){
          return true;
        }

        return false;
      };

      // Articulations are centered over/under the note head.
      var start = this.note.getModifierStartXY(this.position, this.index);
      var glyph_y = start.y;
      var shiftY = 0;
      var line_spacing = 1;
      var spacing = stave.getSpacingBetweenLines();
      var is_tabnote = this.note.getCategory() === 'tabnotes';
      var stem_ext = this.note.getStem().getExtents();

      var top = stem_ext.topY;
      var bottom = stem_ext.baseY;

      if (stem_direction === Vex.Flow.StaveNote.STEM_DOWN) {
        top = stem_ext.baseY;
        bottom = stem_ext.topY;
      }

      // TabNotes don't have stems attached to them. Tab stems are rendered
      // outside the stave.
      if (is_tabnote) {
        if (this.note.hasStem()){
          if (stem_direction === Vex.Flow.StaveNote.STEM_UP) {
            bottom = stave.getYForBottomText(this.text_line - 2);
          } else if (stem_direction === Vex.Flow.StaveNote.STEM_DOWN ) {
            top = stave.getYForTopText(this.text_line - 1.5);
          }
        } else { // Without a stem
          top = stave.getYForTopText(this.text_line - 1);
          bottom = stave.getYForBottomText(this.text_line - 2);
        }
      }

      var is_above = (this.position === Modifier.Position.ABOVE) ? true : false;
      var note_line = this.note.getLineNumber(is_above);

      // Beamed stems are longer than quarter note stems.
      if (!is_on_head && this.note.beam) line_spacing += 0.5;

      // If articulation will overlap a line, reposition it.
      if (needsLineAdjustment(this, note_line, line_spacing)) line_spacing += 0.5;

      var glyph_y_between_lines;
      if (this.position === Modifier.Position.ABOVE) {
        shiftY = this.articulation.shift_up;
        glyph_y_between_lines = (top - 7) - (spacing * (this.text_line + line_spacing));

        if (this.articulation.between_lines) {
          glyph_y = glyph_y_between_lines;
        } else {
          glyph_y = Math.min(stave.getYForTopText(this.text_line) - 3, glyph_y_between_lines);
        }
      } else {
        shiftY = this.articulation.shift_down - 10;

        glyph_y_between_lines = bottom + 10 + spacing * (this.text_line + line_spacing);
        if (this.articulation.between_lines) {
          glyph_y = glyph_y_between_lines;
        } else {
          glyph_y = Math.max(stave.getYForBottomText(this.text_line), glyph_y_between_lines);
        }
      }

      var glyph_x = start.x + this.articulation.shift_right;
      glyph_y += shiftY + this.y_shift;

      L("Rendering articulation: ", this.articulation, glyph_x, glyph_y);
      Vex.Flow.renderGlyph(this.context, glyph_x, glyph_y,
                           this.render_options.font_scale, this.articulation.code);
    }
  });

  return Articulation;
}());
// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements varies types of tunings for tablature.

/**
 * @constructor
 */
Vex.Flow.Tuning = (function() {
  function Tuning(tuningString) {
    this.init(tuningString);
  }

  Tuning.names = {
    "standard": "E/5,B/4,G/4,D/4,A/3,E/3",
    "dagdad": "D/5,A/4,G/4,D/4,A/3,D/3",
    "dropd": "E/5,B/4,G/4,D/4,A/3,D/3",
    "eb": "Eb/5,Bb/4,Gb/4,Db/4,Ab/3,Db/3",
    "standardBanjo": "D/5,B/4,G/4,D/4,G/5"
  };

  Tuning.prototype = {
    init: function(tuningString) {
      // Default to standard tuning.
      this.setTuning(tuningString || "E/5,B/4,G/4,D/4,A/3,E/3,B/2,E/2");
    },

    noteToInteger: function(noteString) {
      return Vex.Flow.keyProperties(noteString).int_value;
    },

    setTuning: function(noteString) {
      if (Vex.Flow.Tuning.names[noteString])
        noteString = Vex.Flow.Tuning.names[noteString];

      this.tuningString = noteString;
      this.tuningValues = [];
      this.numStrings = 0;

      var keys = noteString.split(/\s*,\s*/);
      if (keys.length === 0)
        throw new Vex.RERR("BadArguments", "Invalid tuning string: " + noteString);

      this.numStrings = keys.length;
      for (var i = 0; i < this.numStrings; ++i) {
        this.tuningValues[i] = this.noteToInteger(keys[i]);
      }
    },

    getValueForString: function(stringNum) {
      var s = parseInt(stringNum, 10);
      if (s < 1 || s > this.numStrings)
        throw new Vex.RERR("BadArguments", "String number must be between 1 and " +
            this.numStrings + ": " + stringNum);

      return this.tuningValues[s - 1];
    },

    getValueForFret: function(fretNum, stringNum) {
      var stringValue = this.getValueForString(stringNum);
      var f = parseInt(fretNum, 10);

      if (f < 0) {
        throw new Vex.RERR("BadArguments", "Fret number must be 0 or higher: " +
            fretNum);
      }

      return stringValue + f;
    },

    getNoteForFret: function(fretNum, stringNum) {
      var noteValue = this.getValueForFret(fretNum, stringNum);

      var octave = Math.floor(noteValue / 12);
      var value = noteValue % 12;

      return Vex.Flow.integerToNote(value) + "/" + octave;
    }
  };

  return Tuning;
}());

// VexFlow - Music Engraving for HTML5
//
// A base class for stave modifiers (e.g. clefs, key signatures)
//


/**
 * @constructor
 */
Vex.Flow.StaveModifier = (function() {
  function StaveModifier() {
    this.init();
  }

  StaveModifier.prototype = {
    init: function() {
      this.padding = 10;
    },

    getCategory: function() {return "";},
    makeSpacer: function(padding) {
      return {
        getContext: function() {return true;},
        setStave: function() {},
        renderToStave: function() {},
        getMetrics: function() {
          return {width: padding};
        }
      };
    },

    placeGlyphOnLine: function(glyph, stave, line) {
      glyph.setYShift(stave.getYForLine(line) - stave.getYForGlyphs());
    },

    setPadding: function(padding) {
      this.padding = padding;
    },

    addToStave: function(stave, firstGlyph) {
      if (!firstGlyph) {
        stave.addGlyph(this.makeSpacer(this.padding));
      }

      this.addModifier(stave);
      return this;
    },

    addToStaveEnd: function(stave, firstGlyph) {
      if (!firstGlyph) {
        stave.addEndGlyph(this.makeSpacer(this.padding));
      }
      else {
        stave.addEndGlyph(this.makeSpacer(2));
      }

      this.addEndModifier(stave);
      return this;
    },

    addModifier: function() {
      throw new Vex.RERR("MethodNotImplemented",
          "addModifier() not implemented for this stave modifier.");
    },

    addEndModifier: function() {
      throw new Vex.RERR("MethodNotImplemented",
          "addEndModifier() not implemented for this stave modifier.");
    }
  };

  return StaveModifier;
}());


// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// Author: Cyril Silverman
//
// ## Description
//
// This file implements key signatures. A key signature sits on a stave
// and indicates the notes with implicit accidentals.
Vex.Flow.KeySignature = (function() {
  function KeySignature(keySpec) {
    if (arguments.length > 0) this.init(keySpec);
  }

  // Space between natural and following accidental depending
  // on vertical position
  KeySignature.accidentalSpacing = {
    '#': {
      above: 6,
      below: 4
    },
    'b': {
      above: 4,
      below: 7
    },
    'n': {
      above: 3,
      below: -1
    }
  };

  // ## Prototype Methods
  Vex.Inherit(KeySignature, Vex.Flow.StaveModifier, {
    // Create a new Key Signature based on a `key_spec`
    init: function(key_spec) {
      KeySignature.superclass.init();

      this.glyphFontScale = 38; // TODO(0xFE): Should this match StaveNote?
      this.accList = Vex.Flow.keySignature(key_spec);
    },

    // Add an accidental glyph to the `stave`. `acc` is the data of the
    // accidental to add. If the `next` accidental is also provided, extra
    // width will be added to the initial accidental for optimal spacing.
    addAccToStave: function(stave, acc, next) {
      var glyph_data = Vex.Flow.accidentalCodes(acc.type);
      var glyph = new Vex.Flow.Glyph(glyph_data.code, this.glyphFontScale);

      // Determine spacing between current accidental and the next accidental
      var extra_width = 0;
      if (acc.type === "n" && next) {
        var above = next.line >= acc.line;
        var space = KeySignature.accidentalSpacing[next.type];
        extra_width = above ? space.above : space.below;
      }

      // Set the width and place the glyph on the stave
      glyph.setWidth(glyph_data.width + extra_width);
      this.placeGlyphOnLine(glyph, stave, acc.line);
      stave.addGlyph(glyph);
    },

    // Cancel out a key signature provided in the `spec` parameter. This will
    // place appropriate natural accidentals before the key signature.
    cancelKey: function(spec) {
      // Get the accidental list for the cancelled key signature
      var cancel_accList = Vex.Flow.keySignature(spec);

      // If the cancelled key has a different accidental type, ie: # vs b
      var different_types = this.accList.length > 0 &&
                            cancel_accList[0].type !== this.accList[0].type;

      // Determine how many naturals needed to add
      var naturals = 0;
      if (different_types) {
        naturals = cancel_accList.length;
      } else {
        naturals = cancel_accList.length - this.accList.length;
      }

      // Return if no naturals needed
      if (naturals < 1) return;

      // Get the line position for each natural
      var cancelled = [];
      for (var i = 0; i < naturals; i++) {
        var index = i;
        if (!different_types) {
          index = cancel_accList.length - naturals + i;
        }

        var acc = cancel_accList[index];
        cancelled.push({type: "n", line: acc.line});
      }

      // Combine naturals with main accidental list for the key signature
      this.accList = cancelled.concat(this.accList);

      return this;
    },

    // Add the key signature to the `stave`. You probably want to use the 
    // helper method `.addToStave()` instead
    addModifier: function(stave) {
      this.convertAccLines(stave.clef, this.accList[0].type);
      for (var i = 0; i < this.accList.length; ++i) {
        this.addAccToStave(stave, this.accList[i], this.accList[i+1]);
      }
    },

    // Add the key signature to the `stave`, if it's the not the `firstGlyph`
    // a spacer will be added as well.
    addToStave: function(stave, firstGlyph) {
      if (this.accList.length === 0)
        return this;

      if (!firstGlyph) {
        stave.addGlyph(this.makeSpacer(this.padding));
      }

      this.addModifier(stave);
      return this;
    },

    // Apply the accidental staff line placement based on the `clef` and
    // the  accidental `type` for the key signature ('# or 'b').
    convertAccLines: function(clef, type) {
      var offset = 0.0; // if clef === "treble"
      var customLines; // when clef doesn't follow treble key sig shape

      switch (clef) {
        // Treble & Subbass both have offsets of 0, so are not included.
        case "soprano":
          if(type === "#") customLines = [2.5,0.5,2,0,1.5,-0.5,1];
          else offset = -1;
          break;
        case "mezzo-soprano":
          if(type === "b") customLines = [0,2,0.5,2.5,1,3,1.5];
          else offset = 1.5;
          break;
        case "alto":
          offset = 0.5;
          break;
        case "tenor":
          if(type === "#") customLines = [3, 1, 2.5, 0.5, 2, 0, 1.5];
          else offset = -0.5;
          break;
        case "baritone-f":
        case "baritone-c":
          if(type === "b") customLines = [0.5,2.5,1,3,1.5,3.5,2];
          else offset = 2;
          break;
        case "bass":
        case "french":
          offset = 1;
          break;
      }

      // If there's a special case, assign those lines/spaces:
      var i;
      if (typeof customLines !== "undefined") {
        for (i = 0; i < this.accList.length; ++i) {
          this.accList[i].line = customLines[i];
        }
      } else if (offset !== 0) {
        for (i = 0; i < this.accList.length; ++i) {
          this.accList[i].line += offset;
        }
      }
    }
  });

  return KeySignature;
}());
// Vex Flow Notation
// Implements time signatures glyphs for staffs
// See tables.js for the internal time signatures
// representation
//

/**
 * @param {string} timeSpec time signature, i.e. "4/4"
 * @param {number} [customPadding] custom padding when using multi-stave/multi-instrument setting
 * to align key/time signature (in pixels), optional
 * @constructor
 */
Vex.Flow.TimeSignature = (function() {
  function TimeSignature(timeSpec, customPadding) {
    if (arguments.length > 0) this.init(timeSpec, customPadding);
  }

  TimeSignature.glyphs = {
    "C": {
      code: "v41",
      point: 40,
      line: 2
    },
    "C|": {
      code: "vb6",
      point: 40,
      line: 2
    }
  };

  Vex.Inherit(TimeSignature, Vex.Flow.StaveModifier, {
    init: function(timeSpec, customPadding) {
      TimeSignature.superclass.init();
       var padding = customPadding || 15;

      this.setPadding(padding);
      this.point = 40;
      this.topLine = 2;
      this.bottomLine = 4;
      this.timeSig = this.parseTimeSpec(timeSpec);
    },

    parseTimeSpec: function(timeSpec) {
      if (timeSpec == "C" || timeSpec == "C|") {
        var glyphInfo = TimeSignature.glyphs[timeSpec];
        return {num: false, line: glyphInfo.line,
          glyph: new Vex.Flow.Glyph(glyphInfo.code, glyphInfo.point)};
      }

      var topNums = [];
      var i, c;
      for (i = 0; i < timeSpec.length; ++i) {
        c = timeSpec.charAt(i);
        if (c == "/") {
          break;
        }
        else if (/[0-9]/.test(c)) {
          topNums.push(c);
        }
        else {
          throw new Vex.RERR("BadTimeSignature",
              "Invalid time spec: " + timeSpec);
        }
      }

      if (i === 0) {
        throw new Vex.RERR("BadTimeSignature",
              "Invalid time spec: " + timeSpec);
      }

      // skip the "/"
      ++i;

      if (i == timeSpec.length) {
        throw new Vex.RERR("BadTimeSignature",
              "Invalid time spec: " + timeSpec);
      }


      var botNums = [];
      for (; i < timeSpec.length; ++i) {
        c = timeSpec.charAt(i);
        if (/[0-9]/.test(c)) {
          botNums.push(c);
        }
        else {
          throw new Vex.RERR("BadTimeSignature",
              "Invalid time spec: " + timeSpec);
        }
      }


      return {num: true, glyph: this.makeTimeSignatureGlyph(topNums, botNums)};
    },

    makeTimeSignatureGlyph: function(topNums, botNums) {
      var glyph = new Vex.Flow.Glyph("v0", this.point);
      glyph["topGlyphs"] = [];
      glyph["botGlyphs"] = [];

      var topWidth = 0;
      var i, num;
      for (i = 0; i < topNums.length; ++i) {
        num = topNums[i];
        var topGlyph = new Vex.Flow.Glyph("v" + num, this.point);

        glyph.topGlyphs.push(topGlyph);
        topWidth += topGlyph.getMetrics().width;
      }

      var botWidth = 0;
      for (i = 0; i < botNums.length; ++i) {
        num = botNums[i];
        var botGlyph = new Vex.Flow.Glyph("v" + num, this.point);

        glyph.botGlyphs.push(botGlyph);
        botWidth += botGlyph.getMetrics().width;
      }

      var width = (topWidth > botWidth ? topWidth : botWidth);
      var xMin = glyph.getMetrics().x_min;

      glyph.getMetrics = function() {
        return {
          x_min: xMin,
          x_max: xMin + width,
          width: width
        };
      };

      var topStartX = (width - topWidth) / 2.0;
      var botStartX = (width - botWidth) / 2.0;

      var that = this;
      glyph.renderToStave = function(x) {
        var start_x = x + topStartX;
        var i, g;
        for (i = 0; i < this.topGlyphs.length; ++i) {
          g = this.topGlyphs[i];
          Vex.Flow.Glyph.renderOutline(this.context, g.metrics.outline,
              g.scale, start_x + g.x_shift, this.stave.getYForLine(that.topLine) + 1);
          start_x += g.getMetrics().width;
        }

        start_x = x + botStartX;
        for (i = 0; i < this.botGlyphs.length; ++i) {
          g = this.botGlyphs[i];
          that.placeGlyphOnLine(g, this.stave, g.line);
          Vex.Flow.Glyph.renderOutline(this.context, g.metrics.outline,
              g.scale, start_x + g.x_shift, this.stave.getYForLine(that.bottomLine) + 1);
          start_x += g.getMetrics().width;
        }
      };

      return glyph;
    },

    getTimeSig: function() {
      return this.timeSig;
    },

    addModifier: function(stave) {
      if (!this.timeSig.num) {
        this.placeGlyphOnLine(this.timeSig.glyph, stave, this.timeSig.line);
      }
      stave.addGlyph(this.timeSig.glyph);
    },

    addEndModifier: function(stave) {
      if (!this.timeSig.num) {
        this.placeGlyphOnLine(this.timeSig.glyph, stave, this.timeSig.line);
      }
      stave.addEndGlyph(this.timeSig.glyph);
    }
  });

  return TimeSignature;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna Cheppudira 2013.
// Co-author: Benjamin W. Bohl
//
// ## Description
//
// This file implements various types of clefs that can be rendered on a stave.
//
// See `tests/clef_tests.js` for usage examples.

Vex.Flow.Clef = (function() {
  function Clef(clef, size, annotation) {
    if (arguments.length > 0) this.init(clef, size, annotation);
  }

  // To enable logging for this class, set `Vex.Flow.Clef.DEBUG` to `true`.
  function L() { if (Vex.Flow.Clef.DEBUG) Vex.L("Vex.Flow.Clef", arguments); }

  // Every clef name is associated with a glyph code from the font file
  // and a default stave line number.
  Clef.types = {
    "treble": {
      code: "v83",
      line: 3
    },
    "bass": {
      code: "v79",
      line: 1
    },
    "alto": {
      code: "vad",
      line: 2
    },
    "tenor": {
      code: "vad",
      line: 1
    },
    "percussion": {
      code: "v59",
      line: 2
    },
    "soprano": {
      code: "vad",
      line: 4
    },
    "mezzo-soprano": {
      code: "vad",
      line: 3
    },
    "baritone-c": {
      code: "vad",
      line: 0
    },
    "baritone-f": {
      code: "v79",
      line: 2
    },
    "subbass": {
      code: "v79",
      line: 0
    },
    "french": {
      code: "v83",
      line: 4
    },
  };
  // Sizes affect the point-size of the clef.
  Clef.sizes = {
    "default": 40,
    "small": 32
  };

  // Annotations attach to clefs -- such as "8" for octave up or down.
  Clef.annotations = {
    "8va": {
      code: "v8",
      sizes: {
        "default": {
          point: 20,
          attachments: {
            "treble": {
              line: -1.2,
              x_shift: 11
            }
          }
        },
        "small": {
          point: 18,
          attachments: {
            "treble": {
              line: -0.4,
              x_shift: 8
            }
          }
        }
      }
    },
    "8vb": {
      code: "v8",
      sizes: {
        "default": {
          point: 20,
          attachments: {
            "treble": {
              line: 6.3,
              x_shift: 10
            },
            "bass": {
              line: 4,
              x_shift: 1
            }
          }
        },
        "small": {
          point: 18,
          attachments: {
            "treble": {
              line: 5.8,
              x_shift: 6
            },
            "bass": {
              line: 3.5,
              x_shift: 0.5
            }
          }
        }
      }
    },
  };
  // ## Prototype Methods
  Vex.Inherit(Clef, Vex.Flow.StaveModifier, {
    // Create a new clef. The parameter `clef` must be a key from
    // `Clef.types`.
    init: function(clef, size, annotation) {
      var superclass = Vex.Flow.Clef.superclass;
      superclass.init.call(this);

      this.clef = Vex.Flow.Clef.types[clef];
      if (size === undefined) {
        this.size = "default";
      } else {
        this.size = size;
      }
      this.clef.point = Vex.Flow.Clef.sizes[this.size];

      // If an annotation, such as 8va, is specified, add it to the Clef object.
      if (annotation !== undefined) {
        var anno_dict = Vex.Flow.Clef.annotations[annotation];
        this.annotation = {
          code: anno_dict.code,
          point: anno_dict.sizes[this.size].point,
          line: anno_dict.sizes[this.size].attachments[clef].line,
          x_shift: anno_dict.sizes[this.size].attachments[clef].x_shift
        };
      }
      L("Creating clef:", clef);
    },

    // Add this clef to the start of the given `stave`.
    addModifier: function(stave) {
      var glyph = new Vex.Flow.Glyph(this.clef.code, this.clef.point);
      this.placeGlyphOnLine(glyph, stave, this.clef.line);
      if (this.annotation !== undefined) {
        var attachment = new Vex.Flow.Glyph(this.annotation.code, this.annotation.point);
        attachment.metrics.x_max = 0;
        attachment.setXShift(this.annotation.x_shift);
        this.placeGlyphOnLine(attachment, stave, this.annotation.line);
        stave.addGlyph(attachment);
      }
      stave.addGlyph(glyph);
    },

    // Add this clef to the end of the given `stave`.
    addEndModifier: function(stave) {
      var glyph = new Vex.Flow.Glyph(this.clef.code, this.clef.point);
      this.placeGlyphOnLine(glyph, stave, this.clef.line);
      stave.addEndGlyph(glyph);
      if (this.annotation !== undefined) {
        var attachment = new Vex.Flow.Glyph(this.annotation.code, this.annotation.point);
        attachment.metrics.x_max = 0;
        attachment.setXShift(this.annotation.x_shift);
        this.placeGlyphOnLine(attachment, stave, this.annotation.line);
        stave.addEndGlyph(attachment);
      }
    }
  });

  return Clef;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements some standard music theory routines.
//
// requires: vex.js   (Vex)
// requires: flow.js  (Vex.Flow)

/**
 * @constructor
 */
Vex.Flow.Music = (function() {
  function Music() {
    this.init();
  }

  Music.NUM_TONES = 12;
  Music.roots = [ "c", "d", "e", "f", "g", "a", "b" ];
  Music.root_values = [ 0, 2, 4, 5, 7, 9, 11 ];
  Music.root_indices = {
    "c": 0,
    "d": 1,
    "e": 2,
    "f": 3,
    "g": 4,
    "a": 5,
    "b": 6
  };

  Music.canonical_notes = [
    "c", "c#", "d", "d#",
    "e", "f", "f#", "g",
    "g#", "a", "a#", "b"
  ];

  Music.diatonic_intervals = [
    "unison", "m2", "M2", "m3", "M3",
    "p4", "dim5", "p5", "m6", "M6",
    "b7", "M7", "octave"
  ];

  Music.diatonic_accidentals = {
    "unison": {note: 0, accidental: 0},
    "m2":     {note: 1, accidental: -1},
    "M2":     {note: 1, accidental: 0},
    "m3":     {note: 2, accidental: -1},
    "M3":     {note: 2, accidental: 0},
    "p4":     {note: 3, accidental: 0},
    "dim5":   {note: 4, accidental: -1},
    "p5":     {note: 4, accidental: 0},
    "m6":     {note: 5, accidental: -1},
    "M6":     {note: 5, accidental: 0},
    "b7":     {note: 6, accidental: -1},
    "M7":     {note: 6, accidental: 0},
    "octave": {note: 7, accidental: 0}
  };

  Music.intervals = {
    "u":  0, "unison": 0,
    "m2": 1, "b2": 1, "min2": 1, "S": 1, "H": 1,
    "2": 2, "M2": 2, "maj2": 2, "T": 2, "W": 2,
    "m3": 3, "b3": 3, "min3": 3,
    "M3": 4, "3": 4, "maj3": 4,
    "4":  5, "p4":  5,
    "#4": 6, "b5": 6, "aug4": 6, "dim5": 6,
    "5":  7, "p5":  7,
    "#5": 8, "b6": 8, "aug5": 8,
    "6":  9, "M6":  9, "maj6": 9,
    "b7": 10, "m7": 10, "min7": 10, "dom7": 10,
    "M7": 11, "maj7": 11,
    "8": 12, "octave": 12
  };

  Music.scales = {
    major: [2, 2, 1, 2, 2, 2, 1],
    dorian: [2, 1, 2, 2, 2, 1, 2],
    mixolydian: [2, 2, 1, 2, 2, 1, 2],
    minor: [2, 1, 2, 2, 1, 2, 2]
  };

  Music.accidentals = [ "bb", "b", "n", "#", "##" ];

  Music.noteValues = {
    'c':   { root_index: 0, int_val: 0 },
    'cn':  { root_index: 0, int_val: 0 },
    'c#':  { root_index: 0, int_val: 1 },
    'c##': { root_index: 0, int_val: 2 },
    'cb':  { root_index: 0, int_val: 11 },
    'cbb': { root_index: 0, int_val: 10 },
    'd':   { root_index: 1, int_val: 2 },
    'dn':  { root_index: 1, int_val: 2 },
    'd#':  { root_index: 1, int_val: 3 },
    'd##': { root_index: 1, int_val: 4 },
    'db':  { root_index: 1, int_val: 1 },
    'dbb': { root_index: 1, int_val: 0 },
    'e':   { root_index: 2, int_val: 4 },
    'en':  { root_index: 2, int_val: 4 },
    'e#':  { root_index: 2, int_val: 5 },
    'e##': { root_index: 2, int_val: 6 },
    'eb':  { root_index: 2, int_val: 3 },
    'ebb': { root_index: 2, int_val: 2 },
    'f':   { root_index: 3, int_val: 5 },
    'fn':  { root_index: 3, int_val: 5 },
    'f#':  { root_index: 3, int_val: 6 },
    'f##': { root_index: 3, int_val: 7 },
    'fb':  { root_index: 3, int_val: 4 },
    'fbb': { root_index: 3, int_val: 3 },
    'g':   { root_index: 4, int_val: 7 },
    'gn':  { root_index: 4, int_val: 7 },
    'g#':  { root_index: 4, int_val: 8 },
    'g##': { root_index: 4, int_val: 9 },
    'gb':  { root_index: 4, int_val: 6 },
    'gbb': { root_index: 4, int_val: 5 },
    'a':   { root_index: 5, int_val: 9 },
    'an':  { root_index: 5, int_val: 9 },
    'a#':  { root_index: 5, int_val: 10 },
    'a##': { root_index: 5, int_val: 11 },
    'ab':  { root_index: 5, int_val: 8 },
    'abb': { root_index: 5, int_val: 7 },
    'b':   { root_index: 6, int_val: 11 },
    'bn':  { root_index: 6, int_val: 11 },
    'b#':  { root_index: 6, int_val: 0 },
    'b##': { root_index: 6, int_val: 1 },
    'bb':  { root_index: 6, int_val: 10 },
    'bbb': { root_index: 6, int_val: 9 }
  };

  Music.prototype = {
    init: function() {},

    isValidNoteValue: function(note) {
      if (note == null || note < 0 || note >= Vex.Flow.Music.NUM_TONES)
        return false;
      return true;
    },

    isValidIntervalValue: function(interval) {
      return this.isValidNoteValue(interval);
    },

    getNoteParts: function(noteString) {
      if (!noteString || noteString.length < 1)
        throw new Vex.RERR("BadArguments", "Invalid note name: " + noteString);

      if (noteString.length > 3)
        throw new Vex.RERR("BadArguments", "Invalid note name: " + noteString);

      var note = noteString.toLowerCase();

      var regex = /^([cdefgab])(b|bb|n|#|##)?$/;
      var match = regex.exec(note);

      if (match != null) {
        var root = match[1];
        var accidental = match[2];

        return {
          'root': root,
          'accidental': accidental
        };
      } else {
        throw new Vex.RERR("BadArguments", "Invalid note name: " + noteString);
      }
    },

    getKeyParts: function(keyString) {
      if (!keyString || keyString.length < 1)
        throw new Vex.RERR("BadArguments", "Invalid key: " + keyString);

      var key = keyString.toLowerCase();

      // Support Major, Minor, Melodic Minor, and Harmonic Minor key types.
      var regex = /^([cdefgab])(b|#)?(mel|harm|m|M)?$/;
      var match = regex.exec(key);

      if (match != null) {
        var root = match[1];
        var accidental = match[2];
        var type = match[3];

        // Unspecified type implies major
        if (!type) type = "M";

        return {
          'root': root,
          'accidental': accidental,
          'type': type
        };
      } else {
        throw new Vex.RERR("BadArguments", "Invalid key: " + keyString);
      }
    },

    getNoteValue: function(noteString) {
      var value = Music.noteValues[noteString];
      if (value == null)
        throw new Vex.RERR("BadArguments", "Invalid note name: " + noteString);

      return value.int_val;
    },

    getIntervalValue: function(intervalString) {
      var value = Music.intervals[intervalString];
      if (value == null)
        throw new Vex.RERR("BadArguments",
                           "Invalid interval name: " + intervalString);

      return value;
    },

    getCanonicalNoteName: function(noteValue) {
      if (!this.isValidNoteValue(noteValue))
        throw new Vex.RERR("BadArguments",
                           "Invalid note value: " + noteValue);

      return Music.canonical_notes[noteValue];
    },

    getCanonicalIntervalName: function(intervalValue) {
      if (!this.isValidIntervalValue(intervalValue))
        throw new Vex.RERR("BadArguments",
                           "Invalid interval value: " + intervalValue);

      return Music.diatonic_intervals[intervalValue];
    },

    /* Given a note, interval, and interval direction, product the
     * relative note.
     */
    getRelativeNoteValue: function(noteValue, intervalValue, direction) {
      if (direction == null) direction = 1;
      if (direction != 1 && direction != -1)
        throw new Vex.RERR("BadArguments", "Invalid direction: " + direction);

      var sum = (noteValue + (direction * intervalValue)) % Music.NUM_TONES;
      if (sum < 0) sum += Music.NUM_TONES;

      return sum;
    },

    getRelativeNoteName: function(root, noteValue) {
      var parts = this.getNoteParts(root);
      var rootValue = this.getNoteValue(parts.root);
      var interval = noteValue - rootValue;

      if (Math.abs(interval) > Music.NUM_TONES - 3) {
        var multiplier = 1;
        if (interval > 0 ) multiplier = -1;

        // Possibly wrap around. (Add +1 for modulo operator)
        var reverse_interval = (((noteValue + 1) + (rootValue + 1)) %
          Music.NUM_TONES) * multiplier;

        if (Math.abs(reverse_interval) > 2) {
          throw new Vex.RERR("BadArguments", "Notes not related: " + root + ", " +
                            noteValue);
        } else {
          interval = reverse_interval;
        }
      }

      if (Math.abs(interval) > 2)
          throw new Vex.RERR("BadArguments", "Notes not related: " + root + ", " +
                            noteValue);

      var relativeNoteName = parts.root;
      var i;
      if (interval > 0) {
        for (i = 1; i <= interval; ++i)
          relativeNoteName += "#";
      } else if (interval < 0) {
        for (i = -1; i >= interval; --i)
          relativeNoteName += "b";
      }

      return relativeNoteName;
    },

    /* Return scale tones, given intervals. Each successive interval is
     * relative to the previous one, e.g., Major Scale:
     *
     *   TTSTTTS = [2,2,1,2,2,2,1]
     *
     * When used with key = 0, returns C scale (which is isomorphic to
     * interval list).
     */
    getScaleTones: function(key, intervals) {
      var tones = [];
      tones.push(key);

      var nextNote = key;
      for (var i = 0; i < intervals.length; ++i) {
        nextNote = this.getRelativeNoteValue(nextNote,
                                             intervals[i]);
        if (nextNote != key) tones.push(nextNote);
      }

      return tones;
    },

    /* Returns the interval of a note, given a diatonic scale.
     *
     * E.g., Given the scale C, and the note E, returns M3
     */
    getIntervalBetween: function(note1, note2, direction) {
      if (direction == null) direction = 1;
      if (direction != 1 && direction != -1)
        throw new Vex.RERR("BadArguments", "Invalid direction: " + direction);
      if (!this.isValidNoteValue(note1) || !this.isValidNoteValue(note2))
        throw new Vex.RERR("BadArguments",
                           "Invalid notes: " + note1 + ", " + note2);

      var difference;
      if (direction == 1)
        difference = note2 - note1;
      else
        difference = note1 - note2;

      if (difference < 0) difference += Music.NUM_TONES;
      return difference;
    },

    // Create a scale map that represents the pitch state for a
    // `keySignature`. For example, passing a `G` to `keySignature` would 
    // return a scale map with every note naturalized except for `F` which
    // has an `F#` state.
    createScaleMap: function(keySignature) {
      var keySigParts = this.getKeyParts(keySignature);
      var scaleName = Vex.Flow.KeyManager.scales[keySigParts.type];

      var keySigString = keySigParts.root;
      if (keySigParts.accidental) keySigString += keySigParts.accidental;

      if (!scaleName) throw new Vex.RERR("BadArguments", "Unsupported key type: " + keySignature);

      var scale = this.getScaleTones(this.getNoteValue(keySigString), scaleName);
      var noteLocation = Vex.Flow.Music.root_indices[keySigParts.root];

      var scaleMap = {};
      for (var i = 0; i < Vex.Flow.Music.roots.length; ++i) {
        var index = (noteLocation + i) % Vex.Flow.Music.roots.length;
        var rootName = Vex.Flow.Music.roots[index];
        var noteName = this.getRelativeNoteName(rootName, scale[i]);

        if (noteName.length === 1) {
          noteName += "n";
        }

        scaleMap[rootName] = noteName;
      }

      return scaleMap;
    }

  };

  return Music;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements diatonic key management.
//
// requires: vex.js   (Vex)
// requires: flow.js  (Vex.Flow)
// requires: music.js (Vex.Flow.Music)

/**
 * @constructor
 */
Vex.Flow.KeyManager = (function() {
  function KeyManager(key) {
    this.init(key);
  }

  KeyManager.scales = {
    "M": Vex.Flow.Music.scales.major,
    "m": Vex.Flow.Music.scales.minor
  };

  KeyManager.prototype = {
    init: function(key) {
      this.music = new Vex.Flow.Music();
      this.setKey(key);
    },

    setKey: function(key) {
      this.key = key;
      this.reset();
      return this;
    },

    getKey: function() { return this.key; },

    reset: function() {
      this.keyParts = this.music.getKeyParts(this.key);

      this.keyString = this.keyParts.root;
      if (this.keyParts.accidental) this.keyString += this.keyParts.accidental;

      var is_supported_type = KeyManager.scales[this.keyParts.type];
      if (!is_supported_type)
        throw new Vex.RERR("BadArguments", "Unsupported key type: " + this.key);

      this.scale = this.music.getScaleTones(
          this.music.getNoteValue(this.keyString),
          Vex.Flow.KeyManager.scales[this.keyParts.type]);

      this.scaleMap = {};
      this.scaleMapByValue = {};
      this.originalScaleMapByValue = {};

      var noteLocation = Vex.Flow.Music.root_indices[this.keyParts.root];

      for (var i = 0; i < Vex.Flow.Music.roots.length; ++i) {
        var index = (noteLocation + i) % Vex.Flow.Music.roots.length;
        var rootName = Vex.Flow.Music.roots[index];

        var noteName = this.music.getRelativeNoteName(rootName, this.scale[i]);
        this.scaleMap[rootName] = noteName;
        this.scaleMapByValue[this.scale[i]] = noteName;
        this.originalScaleMapByValue[this.scale[i]] = noteName;
      }

      return this;
    },

    getAccidental: function(key) {
      var root = this.music.getKeyParts(key).root;
      var parts = this.music.getNoteParts(this.scaleMap[root]);

      return {
        note: this.scaleMap[root],
        accidental: parts.accidental
      };
    },

    selectNote: function(note) {
      note = note.toLowerCase();
      var parts = this.music.getNoteParts(note);

      // First look for matching note in our altered scale
      var scaleNote = this.scaleMap[parts.root];
      var modparts = this.music.getNoteParts(scaleNote);

      if (scaleNote == note) return {
        "note": scaleNote,
        "accidental": parts.accidental,
        "change": false
      };

      // Then search for a note of equivalent value in our altered scale
      var valueNote = this.scaleMapByValue[this.music.getNoteValue(note)];
      if (valueNote != null) {
        return {
          "note": valueNote,
          "accidental": this.music.getNoteParts(valueNote).accidental,
          "change": false
        };
      }

      // Then search for a note of equivalent value in the original scale
      var originalValueNote = this.originalScaleMapByValue[
        this.music.getNoteValue(note)];
      if (originalValueNote != null) {
        this.scaleMap[modparts.root] = originalValueNote;
        delete this.scaleMapByValue[this.music.getNoteValue(scaleNote)];
        this.scaleMapByValue[this.music.getNoteValue(note)] = originalValueNote;
        return {
          "note": originalValueNote,
          "accidental": this.music.getNoteParts(originalValueNote).accidental,
          "change": true
        };
      }

      // Then try to unmodify a currently modified note.
      if (modparts.root == note) {
        delete this.scaleMapByValue[
          this.music.getNoteValue(this.scaleMap[parts.root])];
        this.scaleMapByValue[this.music.getNoteValue(modparts.root)] =
          modparts.root;
        this.scaleMap[modparts.root] = modparts.root;
        return {
          "note": modparts.root,
          "accidental": null,
          "change": true
        };
      }

      // Last resort -- shitshoot
      delete this.scaleMapByValue[
        this.music.getNoteValue(this.scaleMap[parts.root])];
      this.scaleMapByValue[this.music.getNoteValue(note)] = note;

      delete this.scaleMap[modparts.root];
      this.scaleMap[modparts.root] = note;

      return {
        "note": note,
        "accidental": parts.accidental,
        "change": true
      };
    }
  };

  return KeyManager;
}());

// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// Support for different rendering contexts: Canvas, Raphael
//
// Copyright Mohit Cheppudira 2010

/* global document: false */

Vex.Flow.Renderer = (function() {
  function Renderer(sel, backend) {
    if (arguments.length > 0) this.init(sel, backend);
  }

  Renderer.Backends = {
    CANVAS: 1,
    RAPHAEL: 2,
    SVG: 3,
    VML: 4
  };

  //End of line types
  Renderer.LineEndType = {
      NONE: 1,        // No leg
      UP: 2,          // Upward leg
      DOWN: 3         // Downward leg
  };

  // Set this to true if you're using VexFlow inside a runtime
  // that does not allow modifiying canvas objects. There is a small
  // performance degradation due to the extra indirection.
  Renderer.USE_CANVAS_PROXY = false;
  Renderer.lastContext = null;

  Renderer.buildContext = function(sel,
      backend, width, height, background) {

    var renderer = new Renderer(sel, backend);
    if (width && height) { renderer.resize(width, height); }

    if (!background) background = "#FFF";
    var ctx = renderer.getContext();
    ctx.setBackgroundFillStyle(background);
    Renderer.lastContext = ctx;
    return ctx;
  };

  Renderer.getCanvasContext = function(sel, width, height, background) {
    return Renderer.buildContext(sel, Renderer.Backends.CANVAS,
        width, height, background);
  };

  Renderer.getRaphaelContext = function(sel, width, height, background) {
    return Renderer.buildContext(sel, Renderer.Backends.RAPHAEL,
        width, height, background);
  };

  Renderer.getSVGContext = function(sel, width, height, background) {
    return Renderer.buildContext(sel, Renderer.Backends.SVG,
        width, height, background);
  };


  Renderer.bolsterCanvasContext = function(ctx) {
    if (Renderer.USE_CANVAS_PROXY) {
      return new Vex.Flow.CanvasContext(ctx);
    }

    var methods = ["clear", "setFont", "setRawFont", "setFillStyle", "setBackgroundFillStyle",
                   "setStrokeStyle", "setShadowColor", "setShadowBlur", "setLineWidth",
                   "setLineCap", "setLineDash", "openGroup", "closeGroup", "getGroup"];
    ctx.vexFlowCanvasContext = ctx;

    for (var i in methods) {
      var method = methods[i];
      ctx[method] = Vex.Flow.CanvasContext.prototype[method];
    }

    return ctx;
  };

  //Draw a dashed line (horizontal, vertical or diagonal
  //dashPattern = [3,3] draws a 3 pixel dash followed by a three pixel space.
  //setting the second number to 0 draws a solid line.
  Renderer.drawDashedLine = function(context, fromX, fromY, toX, toY, dashPattern) {
    context.beginPath();

    var dx = toX - fromX;
    var dy = toY - fromY;
    var angle = Math.atan2(dy, dx);
    var x = fromX;
    var y = fromY;
    context.moveTo(fromX, fromY);
    var idx = 0;
    var draw = true;
    while (!((dx < 0 ? x <= toX : x >= toX) && (dy < 0 ? y <= toY : y >= toY))) {
      var dashLength = dashPattern[idx++ % dashPattern.length];
      var nx = x + (Math.cos(angle) * dashLength);
      x = dx < 0 ? Math.max(toX, nx) : Math.min(toX, nx);
      var ny = y + (Math.sin(angle) * dashLength);
      y = dy < 0 ? Math.max(toY, ny) : Math.min(toY, ny);
      if (draw) {
        context.lineTo(x, y);
      } else {
        context.moveTo(x, y);
      }
        draw = !draw;
    }

    context.closePath();
    context.stroke();
  };

  Renderer.prototype = {
    init: function(sel, backend) {
      // Verify selector
      this.sel = sel;
      if (!this.sel) throw new Vex.RERR("BadArgument",
          "Invalid selector for renderer.");

      // Get element from selector
      this.element = document.getElementById(sel);
      if (!this.element) this.element = sel;

      // Verify backend and create context
      this.ctx = null;
      this.paper = null;
      this.backend = backend;
      if (this.backend == Renderer.Backends.CANVAS) {
        // Create context.
        if (!this.element.getContext) throw new Vex.RERR("BadElement",
          "Can't get canvas context from element: " + sel);
        this.ctx = Renderer.bolsterCanvasContext(
            this.element.getContext('2d'));

      } else if (this.backend == Renderer.Backends.RAPHAEL) {
        this.ctx = new Vex.Flow.RaphaelContext(this.element);

      } else if (this.backend == Renderer.Backends.SVG) {
        this.ctx = new Vex.Flow.SVGContext(this.element);

      } else {
        throw new Vex.RERR("InvalidBackend",
          "No support for backend: " + this.backend);
      }
    },

    resize: function(width, height) {
      if (this.backend == Renderer.Backends.CANVAS) {
        if (!this.element.getContext) throw new Vex.RERR("BadElement",
          "Can't get canvas context from element: " + this.sel);
        this.element.width = width;
        this.element.height = height;
        this.ctx = Renderer.bolsterCanvasContext(
            this.element.getContext('2d'));
      } else {
        this.ctx.resize(width, height);
      }

      return this;
    },

    getContext: function() { return this.ctx; }
  };

  return Renderer;
}());



// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// A rendering context for the Raphael backend.
//
// Copyright Mohit Cheppudira 2010

// ## Warning: Deprecated for SVGContext
// Except in instances where SVG support for IE < 9.0 is
// needed, SVGContext is recommended.

/** @constructor */
Vex.Flow.RaphaelContext = (function() {
  function RaphaelContext(element) {
    if (arguments.length > 0) this.init(element);
  }

  RaphaelContext.prototype = {
    init: function(element) {
      this.element = element;
      this.paper = Raphael(element);
      this.path = "";
      this.pen = {x: 0, y: 0};
      this.lineWidth = 1.0;
      this.state = {
        scale: { x: 1, y: 1 },
        font_family: "Arial",
        font_size: 8,
        font_weight: 800
      };

      this.attributes = {
        "stroke-width": 0.3,
        "fill": "black",
        "stroke": "black",
        "font": "10pt Arial"
      };

      this.background_attributes = {
        "stroke-width": 0,
        "fill": "white",
        "stroke": "white",
        "font": "10pt Arial"
      };

      this.shadow_attributes = {
        width: 0,
        color: "black"
      };

      this.state_stack= [];
    },

    // Containers not implemented
    openGroup: function(cls, id, attrs) {},
    closeGroup: function() {},
    add: function(elem) {},

    setFont: function(family, size, weight) {
      this.state.font_family = family;
      this.state.font_size = size;
      this.state.font_weight = weight;
      this.attributes.font = (this.state.font_weight || "") + " " +
        (this.state.font_size * this.state.scale.x) + "pt " +
        this.state.font_family;
      return this;
    },

    setRawFont: function(font) {
      this.attributes.font = font;
      return this;
    },

    setFillStyle: function(style) {
      this.attributes.fill = style;
      return this;
    },

    setBackgroundFillStyle: function(style) {
      this.background_attributes.fill = style;
      this.background_attributes.stroke = style;
      return this;
    },

    setStrokeStyle: function(style) {
      this.attributes.stroke = style;
      return this;
    },

    setShadowColor: function(style) {
      this.shadow_attributes.color = style;
      return this;
    },

    setShadowBlur: function(blur) {
      this.shadow_attributes.width = blur;
      return this;
    },

    setLineWidth: function(width) {
      this.attributes["stroke-width"] = width;
      this.lineWidth = width;
    },

    // Empty because there is no equivalent in SVG
    setLineDash: function() { return this; },
    setLineCap: function() { return this; },

    scale: function(x, y) {
      this.state.scale = { x: x, y: y };
      // The scale() method is deprecated as of Raphael.JS 2.0, and
      // can no longer be used as an option in an Element.attr() call.
      // It is preserved here for users running earlier versions of
      // Raphael.JS, though it has no effect on the SVG output in
      // Raphael 2 and higher.
      this.attributes.transform = "S" + x + "," + y + ",0,0";
      this.attributes.scale = x + "," + y + ",0,0";
      this.attributes.font = this.state.font_size * this.state.scale.x + "pt " +
        this.state.font_family;
      this.background_attributes.transform = "S" + x + "," + y + ",0,0";
      this.background_attributes.font = this.state.font_size *
        this.state.scale.x + "pt " +
        this.state.font_family;
      return this;
    },

    clear: function() { this.paper.clear(); },

    resize: function(width, height) {
      this.element.style.width = width;
      this.paper.setSize(width, height);
      return this;
    },

    // Sets the SVG `viewBox` property, which results in auto scaling images when its container
    // is resized.
    //
    // Usage: `ctx.setViewBox("0 0 600 400")`
    setViewBox: function(viewBox) {
      this.paper.canvas.setAttribute('viewBox', viewBox);
    },

    rect: function(x, y, width, height) {
      if (height < 0) {
        y += height;
        height = -height;
      }

      this.paper.rect(x, y, width - 0.5, height - 0.5).
        attr(this.attributes).
        attr("fill", "none").
        attr("stroke-width", this.lineWidth);
      return this;
    },

    fillRect: function(x, y, width, height) {
      if (height < 0) {
        y += height;
        height = -height;
      }

      this.paper.rect(x, y, width - 0.5, height - 0.5).
        attr(this.attributes);
      return this;
    },

    clearRect: function(x, y, width, height) {
      if (height < 0) {
        y += height;
        height = -height;
      }

      this.paper.rect(x, y, width - 0.5, height - 0.5).
        attr(this.background_attributes);
      return this;
    },

    beginPath: function() {
      this.path = "";
      this.pen.x = 0;
      this.pen.y = 0;
      return this;
    },

    moveTo: function(x, y) {
      this.path += "M" + x + "," + y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    lineTo: function(x, y) {
      this.path += "L" + x + "," + y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
      this.path += "C" +
        x1 + "," +
        y1 + "," +
        x2 + "," +
        y2 + "," +
        x + "," +
        y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    quadraticCurveTo: function(x1, y1, x, y) {
      this.path += "Q" +
        x1 + "," +
        y1 + "," +
        x + "," +
        y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    // This is an attempt (hack) to simulate the HTML5 canvas
    // arc method.
    arc: function(x, y, radius, startAngle, endAngle, antiClockwise) {
      function normalizeAngle(angle) {
        while (angle < 0) {
          angle += Math.PI * 2;
        }

        while (angle > Math.PI * 2) {
          angle -= Math.PI * 2;
        }
        return angle;
      }

      startAngle = normalizeAngle(startAngle);
      endAngle = normalizeAngle(endAngle);

      if (startAngle > endAngle) {
          var tmp = startAngle;
          startAngle = endAngle;
          endAngle = tmp;
          antiClockwise = !antiClockwise;
      }

      var delta = endAngle - startAngle;

      if (delta > Math.PI) {
          this.arcHelper(x, y, radius, startAngle, startAngle + delta / 2,
                         antiClockwise);
          this.arcHelper(x, y, radius, startAngle + delta / 2, endAngle,
                         antiClockwise);
      }
      else {
          this.arcHelper(x, y, radius, startAngle, endAngle, antiClockwise);
      }
      return this;
    },

    arcHelper: function(x, y, radius, startAngle, endAngle, antiClockwise) {
      var x1 = x + radius * Math.cos(startAngle);
      var y1 = y + radius * Math.sin(startAngle);

      var x2 = x + radius * Math.cos(endAngle);
      var y2 = y + radius * Math.sin(endAngle);

      var largeArcFlag = 0;
      var sweepFlag = 0;
      if (antiClockwise) {
        sweepFlag = 1;
        if (endAngle - startAngle < Math.PI)
          largeArcFlag = 1;
      }
      else if (endAngle - startAngle > Math.PI) {
          largeArcFlag = 1;
      }

      this.path += "M" + x1 + "," + y1 + "," + "A" +
        radius + "," + radius + "," + "0," + largeArcFlag + "," + sweepFlag + "," +
        x2 + "," + y2 + "M" + this.pen.x + "," + this.pen.y;
    },

    // Adapted from the source for Raphael's Element.glow
    glow: function() {
      var out = this.paper.set();
      if (this.shadow_attributes.width > 0) {
        var sa = this.shadow_attributes;
        var num_paths = sa.width / 2;
        for (var i = 1; i <= num_paths; i++) {
          out.push(this.paper.path(this.path).attr({
            stroke: sa.color,
            "stroke-linejoin": "round",
            "stroke-linecap": "round",
            "stroke-width": +(sa.width / num_paths * i).toFixed(3),
            opacity: +((sa.opacity || 0.3) / num_paths).toFixed(3),
            // See note in this.scale(): In Raphael the scale() method
            // is deprecated and removed as of Raphael 2.0 and replaced
            // by the transform() method.  It is preserved here for
            // users with earlier versions of Raphael, but has no effect
            // on the output SVG in Raphael 2.0+.
            transform: this.attributes.transform,
            scale: this.attributes.scale
          }));
        }
      }
      return out;
    },

    fill: function() {
      var elem = this.paper.path(this.path).
        attr(this.attributes).
        attr("stroke-width", 0);
      this.glow(elem);
      return this;
    },

    stroke: function() {
      // The first line of code below is, unfortunately, a bit of a hack:
      // Raphael's transform() scaling does not scale the stroke-width, so
      // in order to scale a stroke, we have to manually scale the
      // stroke-width.
      //
      // This works well so long as the X & Y states for this.scale() are
      // relatively similar.  However, if they are very different, we
      // would expect horizontal and vertical lines to have different
      // stroke-widths.
      //
      // In the future, if we want to support very divergent values for
      // horizontal and vertical scaling, we may want to consider
      // implementing SVG scaling with properties of the SVG viewBox &
      // viewPort and removing it entirely from the Element.attr() calls.
      // This would more closely parallel the approach taken in
      // canvascontext.js as well.

      var strokeWidth = this.lineWidth * (this.state.scale.x + this.state.scale.y)/2;
      var elem = this.paper.path(this.path).
        attr(this.attributes).
        attr("fill", "none").
        attr("stroke-width", strokeWidth);
      this.glow(elem);
      return this;
    },

    closePath: function() {
      this.path += "Z";
      return this;
    },

    measureText: function(text) {
      var txt = this.paper.text(0, 0, text).
        attr(this.attributes).
        attr("fill", "none").
        attr("stroke", "none");
      var bounds = txt.getBBox();
      txt.remove();

      return {
        width: bounds.width,
        height: bounds.height
      };
    },

    fillText: function(text, x, y) {
      this.paper.text(x + (this.measureText(text).width / 2),
          (y - (this.state.font_size / (2.25 * this.state.scale.y))), text).
        attr(this.attributes);
      return this;
    },

    save: function() {
      // TODO(mmuthanna): State needs to be deep-copied.
      this.state_stack.push({
        state: {
          font_family: this.state.font_family
        },
        attributes: {
          font: this.attributes.font,
          fill: this.attributes.fill,
          stroke: this.attributes.stroke,
          "stroke-width": this.attributes["stroke-width"]
        },
        shadow_attributes: {
          width: this.shadow_attributes.width,
          color: this.shadow_attributes.color
        }
      });
      return this;
    },

    restore: function() {
      // TODO(0xfe): State needs to be deep-restored.
      var state = this.state_stack.pop();
      this.state.font_family = state.state.font_family;
      this.attributes.font = state.attributes.font;
      this.attributes.fill = state.attributes.fill;
      this.attributes.stroke = state.attributes.stroke;
      this.attributes["stroke-width"] = state.attributes["stroke-width"];
      this.shadow_attributes.width = state.shadow_attributes.width;
      this.shadow_attributes.color = state.shadow_attributes.color;
      return this;
    }
  };

  return RaphaelContext;
}());

// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// A rendering context for SVG.
//
// Copyright Mohit Muthanna 2015
// @author Gregory Ristow (2015)

/** @constructor */
Vex.Flow.SVGContext = (function() {
  function SVGContext(element) {
    if (arguments.length > 0) this.init(element);
  }

  // The measureTextCache is used in Javascript runtimes where
  // there is no proper DOM support for SVG bounding boxes. This
  // is currently only useful in the NodeJS visual regression tests.
  SVGContext.measureTextCache = {};

  // If enabled, will start collecting and indexing getBBox data by
  // font name, size, weight, and style. This should be disabled by
  // default (or you will find yourself slowly leaking RAM.)
  SVGContext.collectMeasurements = false;

  // If enabled, will warn if there are new getBBox requests that are
  // not in the cache. This is enabled in the VexFlow tests, and if you
  // see a warning on the console, you will need to enable collectMeasurements
  // above, then update measureTextCache with the new values. See
  // tests/measure_text_cache.js for instructions on how to do this.
  SVGContext.validateMeasurement = false;

  SVGContext.addPrefix = Vex.Prefix;

  SVGContext.prototype = {
    init: function(element) {
      // element is the parent DOM object
      this.element = element;
      // Create the SVG in the SVG namespace:
      this.svgNS = "http://www.w3.org/2000/svg";
      var svg = this.create("svg");
      // Add it to the canvas:
      this.element.appendChild(svg);

      // Point to it:
      this.svg = svg;
      this.groups = [this.svg]; // Create the group stack
      this.parent = this.svg;

      this.path = "";
      this.pen = {x: 0, y: 0};
      this.lineWidth = 1.0;
      this.state = {
        scale: { x: 1, y: 1 },
        "font-family": "Arial",
        "font-size": "8pt",
        "font-weight": "normal"
      };

      this.attributes = {
        "stroke-width": 0.3,
        "fill": "black",
        "stroke": "black",
        "font-family": "Arial",
        "font-size" : "10pt",
        "font-weight" : "normal",
        "font-style" : "normal"
      };

      this.background_attributes = {
        "stroke-width": 0,
        "fill": "white",
        "stroke": "white",
        "font-family": "Arial",
        "font-size" : "10pt",
        "font-weight": "normal",
        "font-style": "normal"
      };

      this.shadow_attributes = {
        width: 0,
        color: "black"
      };

      this.state_stack= [];

      // Test for Internet Explorer
      this.iePolyfill();
    },

    create: function(svgElementType) {
      return document.createElementNS(this.svgNS, svgElementType);
    },

    // Allow grouping elements in containers for interactivity.
    openGroup: function(cls, id, attrs) {
      var group = this.create("g");
      this.groups.push(group);
      this.parent.appendChild(group);
      this.parent = group;
      if (cls) group.setAttribute("class", SVGContext.addPrefix(cls));
      if (id) group.setAttribute("id", SVGContext.addPrefix(id));

      if (attrs && attrs.pointerBBox) {
        group.setAttribute("pointer-events", "bounding-box");
      }
      return group;
    },

    closeGroup: function() {
      var group = this.groups.pop();
      this.parent = this.groups[this.groups.length - 1];
    },

    add: function(elem) {
      this.parent.appendChild(elem);
    },

    // Tests if the browser is Internet Explorer; if it is,
    // we do some tricks to improve text layout.  See the
    // note at ieMeasureTextFix() for details.
    iePolyfill: function() {
      if (typeof(navigator) !== "undefined") {
        this.ie = (  /MSIE 9/i.test(navigator.userAgent) ||
                            /MSIE 10/i.test(navigator.userAgent) ||
                            /rv:11\.0/i.test(navigator.userAgent) ||
                            /Trident/i.test(navigator.userAgent) );
      }
    },

    // ### Styling & State Methods:

    setFont: function(family, size, weight) {
      // Unlike canvas, in SVG italic is handled by font-style,
      // not weight. So: we search the weight argument and
      // apply bold and italic to weight and style respectively.
      var bold = false;
      var italic = false;
      var style = "normal";
      // Weight might also be a number (200, 400, etc...) so we
      // test its type to be sure we have access to String methods.
      if( typeof weight == "string" ) {
          // look for "italic" in the weight:
          if(weight.indexOf("italic") !== -1) {
            weight = weight.replace(/italic/g, "");
            italic = true;
          }
          // look for "bold" in weight
          if(weight.indexOf("bold") !== -1) {
            weight = weight.replace(/bold/g, "");
            bold = true;
          }
          // remove any remaining spaces
          weight = weight.replace(/ /g, "");
      }
      weight = bold ? "bold" : weight;
      weight = (typeof weight === "undefined" || weight === "") ? "normal" : weight;

      style = italic ? "italic" : style;

      var fontAttributes = {
        "font-family": family,
        "font-size": size + "pt",
        "font-weight": weight,
        "font-style" : style
      };

      // Store the font size so that if the browser is Internet
      // Explorer we can fix its calculations of text width.
      this.fontSize = Number(size);

      Vex.Merge(this.attributes, fontAttributes);
      Vex.Merge(this.state, fontAttributes);

      return this;
    },

    setRawFont: function(font) {
      font=font.trim();
      // Assumes size first, splits on space -- which is presently
      // how all existing modules are calling this.
      var fontArray = font.split(" ");

      this.attributes["font-family"] = fontArray[1];
      this.state["font-family"] = fontArray[1];

      this.attributes["font-size"] = fontArray[0];
      this.state["font-size"] = fontArray[0];

      // Saves fontSize for IE polyfill
      this.fontSize = Number(fontArray[0].match(/\d+/));
      return this;
    },

    setFillStyle: function(style) {
      this.attributes.fill = style;
      return this;
    },

    setBackgroundFillStyle: function(style) {
      this.background_attributes.fill = style;
      this.background_attributes.stroke = style;
      return this;
    },

    setStrokeStyle: function(style) {
      this.attributes.stroke = style;
      return this;
    },

    setShadowColor: function(style) {
      this.shadow_attributes.color = style;
      return this;
    },

    setShadowBlur: function(blur) {
      this.shadow_attributes.width = blur;
      return this;
    },

    setLineWidth: function(width) {
      this.attributes["stroke-width"] = width;
      this.lineWidth = width;
    },

    setLineDash: function(lineDash) {
      this.attributes["stroke-linedash"] = lineDash;
      return this;
    },

    setLineCap: function(lineCap) {
      this.attributes["stroke-linecap"] = lineCap;
      return this;
    },

    // ### Sizing & Scaling Methods:

    // TODO (GCR): See note at scale() -- seperate our internal
    // conception of pixel-based width/height from the style.width
    // and style.height properties eventually to allow users to
    // apply responsive sizing attributes to the SVG.
    resize: function(width, height) {
      this.width = width;
      this.height = height;
      this.element.style.width = width;
      var attributes = {
        width : width,
        height : height
      };
      this.applyAttributes(this.svg, attributes);
      return this;
    },

    scale: function(x, y) {
      // uses viewBox to scale
      // TODO (GCR): we may at some point want to distinguish the
      // style.width / style.height properties that are applied to
      // the SVG object from our internal conception of the SVG
      // width/height.  This would allow us to create automatically
      // scaling SVG's that filled their containers, for instance.
      //
      // As this isn't implemented in Canvas or Raphael contexts,
      // I've left as is for now, but in using the viewBox to
      // handle internal scaling, am trying to make it possible
      // for us to eventually move in that direction.

      this.state.scale = { x: x, y: y };
      var visibleWidth = this.width / x;
      var visibleHeight = this.height / y;
      this.setViewBox(0,0, visibleWidth, visibleHeight);

      return this;
    },

    setViewBox: function(xMin, yMin, width, height) {
      // Override for "x y w h" style:
      if(arguments.length == 1) this.svg.setAttribute("viewBox", viewBox);
      else {
        var viewBoxString = xMin + " " + yMin + " " + width + " " + height;
        this.svg.setAttribute("viewBox", viewBoxString);
      }
    },

    // ### Drawing helper methods:

    applyAttributes: function(element, attributes) {
      for(var propertyName in attributes) {
        element.setAttributeNS(null, propertyName, attributes[propertyName]);
      }
      return element;
    },

    flipRectangle: function(args) {
      // Avoid invalid negative height attributes by
      // flipping a rectangle w/ negative height on its head.
      // Since args is the actual arguments object from
      // one of the rectangle functions, we don't need to
      // return it.

      // Add negative height to Y
      args[1] += args[3];
      // Make the negative height positive.
      args[3] = -args[3];
    },

    // ### Shape & Path Methods:

    clear: function() {
      // Clear the SVG by removing all inner children.

      // (This approach is usually slightly more efficient
      // than removing the old SVG & adding a new one to
      // the container element, since it does not cause the
      // container to resize twice.  Also, the resize
      // triggered by removing the entire SVG can trigger
      // a touchcancel event when the element resizes away
      // from a touch point.)

      while (this.svg.lastChild) {
        this.svg.removeChild(this.svg.lastChild);
      }

      // Replace the viewbox attribute we just removed:
      this.scale(this.state.scale.x, this.state.scale.y);
    },

    // ## Rectangles:

    rect: function(x, y, width, height, attributes) {
      // Avoid invalid negative height attribs by
      // flipping the rectangle on its head:
      if (height < 0) this.flipRectangle(arguments);

      // Create the rect & style it:
      var rect = this.create("rect");
      if(typeof attributes === "undefined") attributes = {
        fill: "none",
        "stroke-width": this.lineWidth,
        stroke: "black"
      };
      Vex.Merge(attributes, {
        x: x,
        y: y,
        width: width,
        height: height
      });

      this.applyAttributes(rect, attributes);

      this.add(rect);
      return this;
    },

    fillRect: function(x, y, width, height) {
      if(height < 0) this.flipRectangle(arguments);

      this.rect(x, y, width - 0.5, height - 0.5, this.attributes);
      return this;
    },

    clearRect: function(x, y, width, height) {
      // TODO(GCR): Improve implementation of this...
      // Currently it draws a box of the background color, rather
      // than creating alpha through lower z-levels.
      //
      // See the implementation of this in SVGKit:
      // http://sourceforge.net/projects/svgkit/
      // as a starting point.
      //
      // Adding a large number of transform paths (as we would
      // have to do) could be a real performance hit.  Since
      // tabNote seems to be the only module that makes use of this
      // it may be worth creating a seperate tabStave that would
      // draw lines around locations of tablature fingering.
      //

      if (height < 0) this.flipRectangle(arguments);

      this.rect(x, y, width - 0.5, height - 0.5, this.background_attributes);
      return this;
    },

    // ## Paths:

    beginPath: function() {
      this.path = "";
      this.pen.x = 0;
      this.pen.y = 0;
      return this;
    },

    moveTo: function(x, y) {
      this.path += "M" + x + " " + y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    lineTo: function(x, y) {
      this.path += "L" + x + " " + y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
      this.path += "C" +
        x1 + " " +
        y1 + "," +
        x2 + " " +
        y2 + "," +
        x + " " +
        y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    quadraticCurveTo: function(x1, y1, x, y) {
      this.path += "Q" +
        x1 + " " +
        y1 + "," +
        x + " " +
        y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    // This is an attempt (hack) to simulate the HTML5 canvas
    // arc method.
    arc: function(x, y, radius, startAngle, endAngle, antiClockwise) {
      function normalizeAngle(angle) {
        while (angle < 0) {
          angle += Math.PI * 2;
        }

        while (angle > Math.PI * 2) {
          angle -= Math.PI * 2;
        }
        return angle;
      }

      startAngle = normalizeAngle(startAngle);
      endAngle = normalizeAngle(endAngle);

      if (startAngle > endAngle) {
          var tmp = startAngle;
          startAngle = endAngle;
          endAngle = tmp;
          antiClockwise = !antiClockwise;
      }

      var delta = endAngle - startAngle;

      if (delta > Math.PI) {
          this.arcHelper(x, y, radius, startAngle, startAngle + delta / 2,
                         antiClockwise);
          this.arcHelper(x, y, radius, startAngle + delta / 2, endAngle,
                         antiClockwise);
      }
      else {
          this.arcHelper(x, y, radius, startAngle, endAngle, antiClockwise);
      }
      return this;
    },

    arcHelper: function(x, y, radius, startAngle, endAngle, antiClockwise) {
      var x1 = x + radius * Math.cos(startAngle);
      var y1 = y + radius * Math.sin(startAngle);

      var x2 = x + radius * Math.cos(endAngle);
      var y2 = y + radius * Math.sin(endAngle);

      var largeArcFlag = 0;
      var sweepFlag = 0;
      if (antiClockwise) {
        sweepFlag = 1;
        if (endAngle - startAngle < Math.PI)
          largeArcFlag = 1;
      }
      else if (endAngle - startAngle > Math.PI) {
          largeArcFlag = 1;
      }

      this.path += "M" + x1 + " " + y1 + " " + "A" +
        radius + " " + radius + " " + "0 " + largeArcFlag + " " + sweepFlag + " " +
        x2 + " " + y2 + "M" + this.pen.x + " " + this.pen.y;

    },

    closePath: function() {
      this.path += "Z";

      return this;
    },

    // Adapted from the source for Raphael's Element.glow
    glow: function() {
      // Calculate the width & paths of the glow:
      if (this.shadow_attributes.width > 0) {
        var sa = this.shadow_attributes;
        var num_paths = sa.width / 2;
        // Stroke at varying widths to create effect of gaussian blur:
        for (var i = 1; i <= num_paths; i++) {
          var attributes = {
            stroke: sa.color,
            "stroke-linejoin": "round",
            "stroke-linecap": "round",
            "stroke-width": +((sa.width *0.4) / num_paths * i).toFixed(3),
            opacity: +((sa.opacity || 0.3) / num_paths).toFixed(3),
          };

          var path = this.create("path");
          attributes.d = this.path;
          this.applyAttributes(path, attributes);
          this.add(path);
        }
      }
      return this;
    },

    fill: function(attributes) {
      // If our current path is set to glow, make it glow
      this.glow();

      var path = this.create("path");
      if(typeof attributes === "undefined") {
        attributes = {};
        Vex.Merge(attributes, this.attributes);
        attributes.stroke = "none";
      }

      attributes.d = this.path;

      this.applyAttributes(path, attributes);
      this.add(path);
      return this;
    },

    stroke: function() {
      // If our current path is set to glow, make it glow.
      this.glow();

      var path = this.create("path");
      var attributes = {};
      Vex.Merge(attributes, this.attributes);
      attributes.fill = "none";
      attributes["stroke-width"] = this.lineWidth;
      attributes.d = this.path;

      this.applyAttributes(path, attributes);
      this.add(path);
      return this;
    },

    // ## Text Methods:
    measureText: function(text) {
      var index = text + this.attributes["font-style"] + this.attributes["font-family"] +
                  this.attributes["font-weight"] + this.attributes["font-size"];

      var txt = this.create("text");
      if (typeof(txt.getBBox) === "function") {
        txt.textContent = text;
        this.applyAttributes(txt, this.attributes);

        // Temporarily add it to the document for measurement.
        this.svg.appendChild(txt);

        var bbox = txt.getBBox();
        if( this.ie &&
            text !== "" &&
            this.attributes["font-style"] == "italic") bbox = this.ieMeasureTextFix(bbox, text);
        this.svg.removeChild(txt);

        // For runtimes that do not have full support of bounding boxes, collect
        // some data which can be used later to extrapolate them.
        if (SVGContext.collectMeasurements) {
          SVGContext.measureTextCache[index] = {
            x: bbox.x,
            y: bbox.y,
            width: bbox.width,
            height: bbox.height
          };
        }
        if (SVGContext.validateMeasurements) {
          if (!(index in SVGContext.measureTextCache)) {
            Vex.W("measureTextCache is stale. Please update tests/measure_text_cache.js: ", index);
          }
        }
        return bbox;
      } else {
        // Inside NodeJS or other runtimes that don't support getBBox. This
        // is currently only useful for the NodeJS visual regression tests.
        return SVGContext.measureTextCache[index];
      }
    },

    ieMeasureTextFix: function(bbox, text) {
    // Internet Explorer over-pads text in italics,
    // resulting in giant width estimates for measureText.
    // To fix this, we use this formula, tested against
    // ie 11:
    // overestimate (in pixels) = FontSize(in pt) * 1.196 + 1.96
    // And then subtract the overestimate from calculated width.

      var fontSize = Number(this.fontSize);
      var m = 1.196;
      var b = 1.9598;
      var widthCorrection = (m * fontSize) + b;
      var width = bbox.width - widthCorrection;
      var height = bbox.height - 1.5;

      // Get non-protected copy:
      var box = {
        x : bbox.x,
        y : bbox.y,
        width : width,
        height : height
      };

      return box;
    },

    fillText: function(text, x, y) {
      var attributes = {};
      Vex.Merge(attributes, this.attributes);
      attributes.stroke = "none";
      attributes.x = x;
      attributes.y = y;

      var txt = this.create("text");
      txt.textContent = text;
      this.applyAttributes(txt, attributes);
      this.add(txt);
    },

    save: function() {
      // TODO(mmuthanna): State needs to be deep-copied.
      this.state_stack.push({
        state: {
          "font-family": this.state["font-family"],
          "font-weight": this.state["font-weight"],
          "font-style": this.state["font-style"],
          "font-size": this.state["font-size"]
        },
        attributes: {
          "font-family": this.attributes["font-family"],
          "font-weight": this.attributes["font-weight"],
          "font-style": this.attributes["font-style"],
          "font-size": this.attributes["font-size"],
          fill: this.attributes.fill,
          stroke: this.attributes.stroke,
          "stroke-width": this.attributes["stroke-width"]
        },
        shadow_attributes: {
          width: this.shadow_attributes.width,
          color: this.shadow_attributes.color
        }
      });
      return this;
    },

    restore: function() {
      // TODO(0xfe): State needs to be deep-restored.
      var state = this.state_stack.pop();
      this.state["font-family"] = state.state["font-family"];
      this.state["font-weight"] = state.state["font-weight"];
      this.state["font-style"] = state.state["font-style"];
      this.state["font-size"] = state.state["font-size"];

      this.attributes["font-family"] = state.attributes["font-family"];
      this.attributes["font-weight"] = state.attributes["font-weight"];
      this.attributes["font-style"] = state.attributes["font-style"];
      this.attributes["font-size"] = state.attributes["font-size"];

      this.attributes.fill = state.attributes.fill;
      this.attributes.stroke = state.attributes.stroke;
      this.attributes["stroke-width"] = state.attributes["stroke-width"];
      this.shadow_attributes.width = state.shadow_attributes.width;
      this.shadow_attributes.color = state.shadow_attributes.color;
      return this;
    }
  };

  return SVGContext;
}());

// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// A rendering context for the Raphael backend.
//
// Copyright Mohit Cheppudira 2010

/** @constructor */
Vex.Flow.CanvasContext = (function() {
  function CanvasContext(context) {
    if (arguments.length > 0) this.init(context);
  }

  CanvasContext.WIDTH = 600;
  CanvasContext.HEIGHT = 400;

  CanvasContext.prototype = {
    init: function(context) {
      // Use a name that is unlikely to clash with a canvas context
      // property
      this.vexFlowCanvasContext = context;
      if (!context.canvas) {
        this.canvas = {
          width: CanvasContext.WIDTH,
          height: CanvasContext.HEIGHT
        };
      } else {
        this.canvas = context.canvas;
      }
    },

    clear: function() {
      this.vexFlowCanvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },

    // Containers not implemented
    openGroup: function(cls, id, attrs) {},
    closeGroup: function() {},
    add: function(elem) {},

    setFont: function(family, size, weight) {
      this.vexFlowCanvasContext.font = (weight || "") + " " + size + "pt " + family;
      return this;
    },

    setRawFont: function(font) {
      this.vexFlowCanvasContext.font = font;
      return this;
    },

    setFillStyle: function(style) {
      this.vexFlowCanvasContext.fillStyle = style;
      return this;
    },

    setBackgroundFillStyle: function(style) {
      this.background_fillStyle = style;
      return this;
    },

    setStrokeStyle: function(style) {
      this.vexFlowCanvasContext.strokeStyle = style;
      return this;
    },

    setShadowColor: function(style) {
      this.vexFlowCanvasContext.shadowColor = style;
      return this;
    },

    setShadowBlur: function(blur) {
      this.vexFlowCanvasContext.shadowBlur = blur;
      return this;
    },

    setLineWidth: function(width) {
      this.vexFlowCanvasContext.lineWidth = width;
      return this;
    },

    setLineCap: function(cap_type) {
      this.vexFlowCanvasContext.lineCap = cap_type;
      return this;
    },

    setLineDash: function(dash) {
      this.vexFlowCanvasContext.lineDash = dash;
    },

    scale: function(x, y) {
      return this.vexFlowCanvasContext.scale(parseFloat(x), parseFloat(y));
    },

    resize: function(width, height) {
      return this.vexFlowCanvasContext.resize(
          parseInt(width, 10), parseInt(height, 10));
    },

    rect: function(x, y, width, height) {
      return this.vexFlowCanvasContext.rect(x, y, width, height);
    },

    fillRect: function(x, y, width, height) {
      return this.vexFlowCanvasContext.fillRect(x, y, width, height);
    },

    clearRect: function(x, y, width, height) {
      return this.vexFlowCanvasContext.clearRect(x, y, width, height);
    },

    beginPath: function() {
      return this.vexFlowCanvasContext.beginPath();
    },

    moveTo: function(x, y) {
      return this.vexFlowCanvasContext.moveTo(x, y);
    },

    lineTo: function(x, y) {
      return this.vexFlowCanvasContext.lineTo(x, y);
    },

    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
      return this.vexFlowCanvasContext.bezierCurveTo(x1, y1, x2, y2, x, y);
    },

    quadraticCurveTo: function(x1, y1, x, y) {
      return this.vexFlowCanvasContext.quadraticCurveTo(x1, y1, x, y);
    },

    // This is an attempt (hack) to simulate the HTML5 canvas
    // arc method.
    arc: function(x, y, radius, startAngle, endAngle, antiClockwise) {
      return this.vexFlowCanvasContext.arc(x, y, radius, startAngle, endAngle, antiClockwise);
    },

    // Adapted from the source for Raphael's Element.glow
    glow: function() {
      return this.vexFlowCanvasContext.glow();
    },

    fill: function() {
      return this.vexFlowCanvasContext.fill();
    },

    stroke: function() {
      return this.vexFlowCanvasContext.stroke();
    },

    closePath: function() {
      return this.vexFlowCanvasContext.closePath();
    },

    measureText: function(text) {
      return this.vexFlowCanvasContext.measureText(text);
    },

    fillText: function(text, x, y) {
      return this.vexFlowCanvasContext.fillText(text, x, y);
    },

    save: function() {
      return this.vexFlowCanvasContext.save();
    },

    restore: function() {
      return this.vexFlowCanvasContext.restore();
    }
  };

  return CanvasContext;
}());

// Vex Flow Notation
// Author Larry Kuhns 2011
// Implements barlines (single, double, repeat, end)
//
// Requires vex.js.

/**
 * @constructor
 */
Vex.Flow.Barline = (function() {
  function Barline(type, x) {
    if (arguments.length > 0) this.init(type, x);
  }

  Barline.type = {
    SINGLE: 1,
    DOUBLE: 2,
    END: 3,
    REPEAT_BEGIN: 4,
    REPEAT_END: 5,
    REPEAT_BOTH: 6,
    NONE: 7
  };

  Vex.Inherit(Barline, Vex.Flow.StaveModifier, {
    init: function(type, x) {
      Barline.superclass.init.call(this);
      this.thickness = Vex.Flow.STAVE_LINE_THICKNESS;
      this.barline = type;
      this.x = x;    // Left most x for the stave
    },

    getCategory: function() { return "barlines"; },
    setX: function(x) { this.x = x; return this; },

    // Draw barlines
    draw: function(stave, x_shift) {
      x_shift = typeof x_shift !== 'number' ? 0 : x_shift;

      switch (this.barline) {
        case Barline.type.SINGLE:
          this.drawVerticalBar(stave, this.x, false);
          break;
        case Barline.type.DOUBLE:
          this.drawVerticalBar(stave, this.x, true);
          break;
        case Barline.type.END:
          this.drawVerticalEndBar(stave, this.x);
          break;
        case Barline.type.REPEAT_BEGIN:
          // If the barline is shifted over (in front of clef/time/key)
          // Draw vertical bar at the beginning.
          if (x_shift > 0) {
            this.drawVerticalBar(stave, this.x);
          }
          this.drawRepeatBar(stave, this.x + x_shift, true);
          break;
        case Barline.type.REPEAT_END:
          this.drawRepeatBar(stave, this.x, false);
          break;
        case Barline.type.REPEAT_BOTH:
          this.drawRepeatBar(stave, this.x, false);
          this.drawRepeatBar(stave, this.x, true);
          break;
        default:
          // Default is NONE, so nothing to draw
          break;
      }
    },

    drawVerticalBar: function(stave, x, double_bar) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");
      var topY = stave.getYForLine(0);
      var botY = stave.getYForLine(stave.getNumLines() - 1) + this.thickness;
      if (double_bar)
        stave.context.fillRect(x - 3, topY, 1, botY - topY);
      stave.context.fillRect(x, topY, 1, botY - topY);
    },

    drawVerticalEndBar: function(stave, x) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var topY = stave.getYForLine(0);
      var botY = stave.getYForLine(stave.getNumLines() - 1) + this.thickness;
      stave.context.fillRect(x - 5, topY, 1, botY - topY);
      stave.context.fillRect(x - 2, topY, 3, botY - topY);
    },

    drawRepeatBar: function(stave, x, begin) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var topY = stave.getYForLine(0);
      var botY = stave.getYForLine(stave.getNumLines() - 1) + this.thickness;
      var x_shift = 3;

      if (!begin) {
        x_shift = -5;
      }

      stave.context.fillRect(x + x_shift, topY, 1, botY - topY);
      stave.context.fillRect(x - 2, topY, 3, botY - topY);

      var dot_radius = 2;

      // Shift dots left or right
      if (begin) {
        x_shift += 4;
      } else {
        x_shift -= 4;
      }

      var dot_x = (x + x_shift) + (dot_radius / 2);

      // calculate the y offset based on number of stave lines
      var y_offset = (stave.getNumLines() - 1) *
        stave.getSpacingBetweenLines();
      y_offset = (y_offset / 2) -
                 (stave.getSpacingBetweenLines() / 2);
      var dot_y = topY + y_offset + (dot_radius / 2);

      // draw the top repeat dot
      stave.context.beginPath();
      stave.context.arc(dot_x, dot_y, dot_radius, 0, Math.PI * 2, false);
      stave.context.fill();

      //draw the bottom repeat dot
      dot_y += stave.getSpacingBetweenLines();
      stave.context.beginPath();
      stave.context.arc(dot_x, dot_y, dot_radius, 0, Math.PI * 2, false);
      stave.context.fill();
    }
  });

  return Barline;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
// This class by Raffaele Viglianti, 2012 http://itisnotsound.wordpress.com/
//
// This class implements hairpins between notes.
// Hairpins can be either Crescendo or Descrescendo.

/**
 * Create a new hairpin from the specified notes.
 *
 * @constructor
 * @param {!Object} notes The notes to tie up.
 * @param {!Object} type The type of hairpin
 */
Vex.Flow.StaveHairpin = (function() {
  function StaveHairpin(notes, type) {
    if (arguments.length > 0) this.init(notes, type);
  }

  StaveHairpin.type = {
    CRESC: 1,
    DECRESC: 2
  };

  /* Helper function to convert ticks into pixels.
   * Requires a Formatter with voices joined and formatted (to
   * get pixels per tick)
   *
   * options is struct that has:
   *
   *  {
   *   height: px,
   *   y_shift: px, //vertical offset
   *   left_shift_ticks: 0, //left horizontal offset expressed in ticks
   *   right_shift_ticks: 0 // right horizontal offset expressed in ticks
   *  }
   *
   **/
  StaveHairpin.FormatByTicksAndDraw = function(ctx, formatter, notes, type, position, options) {
    var ppt = formatter.pixelsPerTick;

    if (ppt == null){
      throw new Vex.RuntimeError("BadArguments",
          "A valid Formatter must be provide to draw offsets by ticks.");}

    var l_shift_px = ppt * options.left_shift_ticks;
    var r_shift_px = ppt * options.right_shift_ticks;

    var hairpin_options = {
      height: options.height,
      y_shift:options.y_shift,
      left_shift_px:l_shift_px,
      right_shift_px:r_shift_px};

    new StaveHairpin({
      first_note: notes.first_note,
      last_note: notes.last_note
    }, type)
      .setContext(ctx)
      .setRenderOptions(hairpin_options)
      .setPosition(position)
      .draw();
  };

  StaveHairpin.prototype = {
    init: function(notes, type) {
      /**
       * Notes is a struct that has:
       *
       *  {
       *    first_note: Note,
       *    last_note: Note,
       *  }
       *
       **/

      this.notes = notes;
      this.hairpin = type;
      this.position = Vex.Flow.Modifier.Position.BELOW;

      this.context = null;

      this.render_options = {
          height: 10,
          y_shift: 0, //vertical offset
          left_shift_px: 0, //left horizontal offset
          right_shift_px: 0 // right horizontal offset
        };

      this.setNotes(notes);
    },

    setContext: function(context) { this.context = context; return this; },

    setPosition: function(position) {
      if (position == Vex.Flow.Modifier.Position.ABOVE ||
          position == Vex.Flow.Modifier.Position.BELOW)
        this.position = position;
      return this;
    },

    setRenderOptions: function(options) {
      if (options.height != null &&
          options.y_shift != null &&
          options.left_shift_px != null &&
          options.right_shift_px != null){
        this.render_options = options;
      }
      return this;
    },

    /**
     * Set the notes to attach this hairpin to.
     *
     * @param {!Object} notes The start and end notes.
     */
    setNotes: function(notes) {
      if (!notes.first_note && !notes.last_note)
        throw new Vex.RuntimeError("BadArguments",
            "Hairpin needs to have either first_note or last_note set.");

      // Success. Lets grab 'em notes.
      this.first_note = notes.first_note;
      this.last_note = notes.last_note;
      return this;
    },

    renderHairpin: function(params) {
      var ctx = this.context;
      var dis = this.render_options.y_shift + 20;
      var y_shift = params.first_y;

      if (this.position == Vex.Flow.Modifier.Position.ABOVE) {
        dis = -dis +30;
        y_shift = params.first_y - params.staff_height;
      }

      var l_shift = this.render_options.left_shift_px;
      var r_shift = this.render_options.right_shift_px;

      switch (this.hairpin) {
        case StaveHairpin.type.CRESC:
          ctx.moveTo(params.last_x + r_shift, y_shift + dis);
          ctx.lineTo(params.first_x + l_shift, y_shift +(this.render_options.height/2) + dis);
          ctx.lineTo(params.last_x + r_shift, y_shift + this.render_options.height + dis);
          break;
        case StaveHairpin.type.DECRESC:
          ctx.moveTo(params.first_x + l_shift, y_shift + dis);
          ctx.lineTo(params.last_x + r_shift, y_shift +(this.render_options.height/2) + dis);
          ctx.lineTo(params.first_x + l_shift, y_shift + this.render_options.height + dis);
          break;
        default:
          // Default is NONE, so nothing to draw
          break;
      }

      ctx.stroke();
    },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw Hairpin without a context.");

      var first_note = this.first_note;
      var last_note = this.last_note;

      var start = first_note.getModifierStartXY(this.position, 0);
      var end = last_note.getModifierStartXY(this.position, 0);

      this.renderHairpin({
        first_x: start.x,
        last_x: end.x,
        first_y: first_note.getStave().y + first_note.getStave().height,
        last_y: last_note.getStave().y + last_note.getStave().height,
        staff_height: first_note.getStave().height
      });
     return true;
    }
  };
  return StaveHairpin;
}());


// Vex Flow Notation
// Author Larry Kuhns 2011
// Implements voltas (repeat brackets)
//
// Requires vex.js.

Vex.Flow.Volta = (function() {
  function Volta(type, number, x, y_shift) {
    if (arguments.length > 0) this.init(type, number, x, y_shift);
  }

  Volta.type = {
    NONE: 1,
    BEGIN: 2,
    MID: 3,
    END: 4,
    BEGIN_END: 5
  };

  Vex.Inherit(Volta, Vex.Flow.StaveModifier, {
    init: function(type, number, x, y_shift) {
      Volta.superclass.init.call(this);

      this.volta = type;
      this.x = x;
      this.y_shift = y_shift;
      this.number = number;
      this.font = {
        family: "sans-serif",
        size: 9,
        weight: "bold"
      };
    },

    getCategory: function() { return "voltas"; },
    setShiftY: function(y) { this.y_shift = y; return this; },

    draw: function(stave, x) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
        "Can't draw stave without canvas context.");
      var ctx = stave.context;
      var width = stave.width;
      var top_y = stave.getYForTopText(stave.options.num_lines) + this.y_shift;
      var vert_height = 1.5 * stave.options.spacing_between_lines_px;
      switch(this.volta) {
        case Vex.Flow.Volta.type.BEGIN:
          ctx.fillRect(this.x + x, top_y, 1, vert_height);
          break;
        case Vex.Flow.Volta.type.END:
          width -= 5;
          ctx.fillRect(this.x + x + width, top_y, 1, vert_height);
          break;
        case Vex.Flow.Volta.type.BEGIN_END:
          width -= 3;
          ctx.fillRect(this.x + x, top_y, 1, vert_height);
          ctx.fillRect(this.x + x + width, top_y, 1, vert_height);
          break;
      }
        // If the beginning of a volta, draw measure number
      if (this.volta == Volta.type.BEGIN ||
          this.volta == Volta.type.BEGIN_END) {
        ctx.save();
        ctx.setFont(this.font.family, this.font.size, this.font.weight);
        ctx.fillText(this.number, this.x + x + 5, top_y + 15);
        ctx.restore();
      }
      ctx.fillRect(this.x + x, top_y, width, 1);
      return this;
    }
  });

  return Volta;
}());
// Vex Flow Notation
// Author Larry Kuhns 2011
// Implements Repetitions (Coda, signo, D.C., etc.)
//
// Requires vex.js.

Vex.Flow.Repetition = (function() {
  function Repetition(type, x, y_shift) {
    if (arguments.length > 0) this.init(type, x, y_shift);
  }

  Repetition.type = {
    NONE: 1,         // no coda or segno
    CODA_LEFT: 2,    // coda at beginning of stave
    CODA_RIGHT: 3,   // coda at end of stave
    SEGNO_LEFT: 4,   // segno at beginning of stave
    SEGNO_RIGHT: 5,  // segno at end of stave
    DC: 6,           // D.C. at end of stave
    DC_AL_CODA: 7,   // D.C. al coda at end of stave
    DC_AL_FINE: 8,   // D.C. al Fine end of stave
    DS: 9,           // D.S. at end of stave
    DS_AL_CODA: 10,  // D.S. al coda at end of stave
    DS_AL_FINE: 11,  // D.S. al Fine at end of stave
    FINE: 12         // Fine at end of stave
  };

  Vex.Inherit(Repetition, Vex.Flow.StaveModifier, {
    init: function(type, x, y_shift) {
      Repetition.superclass.init.call(this);

      this.symbol_type = type;
      this.x = x;
      this.x_shift = 0;
      this.y_shift = y_shift;
      this.font = {
        family: "times",
        size: 12,
        weight: "bold italic"
      };
    },

    getCategory: function() { return "repetitions"; },
    setShiftX: function(x) { this.x_shift = x; return this; },
    setShiftY: function(y) { this.y_shift = y; return this; },

    draw: function(stave, x) {
      switch (this.symbol_type) {
        case Repetition.type.CODA_RIGHT:
          this.drawCodaFixed(stave, x + stave.width);
          break;
        case Repetition.type.CODA_LEFT:
          this.drawSymbolText(stave, x, "Coda", true);
          break;
        case Repetition.type.SEGNO_LEFT:
          this.drawSignoFixed(stave, x);
          break;
        case Repetition.type.SEGNO_RIGHT:
          this.drawSignoFixed(stave, x + stave.width);
          break;
        case Repetition.type.DC:
          this.drawSymbolText(stave, x, "D.C.", false);
          break;
        case Repetition.type.DC_AL_CODA:
          this.drawSymbolText(stave, x, "D.C. al", true);
          break;
        case Repetition.type.DC_AL_FINE:
          this.drawSymbolText(stave, x, "D.C. al Fine", false);
          break;
        case Repetition.type.DS:
          this.drawSymbolText(stave, x, "D.S.", false);
          break;
        case Repetition.type.DS_AL_CODA:
          this.drawSymbolText(stave, x, "D.S. al", true);
          break;
        case Repetition.type.DS_AL_FINE:
          this.drawSymbolText(stave, x, "D.S. al Fine", false);
          break;
        case Repetition.type.FINE:
          this.drawSymbolText(stave, x, "Fine", false);
          break;
        default:
          break;
      }

      return this;
    },

    drawCodaFixed: function(stave, x) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var y = stave.getYForTopText(stave.options.num_lines) + this.y_shift;
      Vex.Flow.renderGlyph(stave.context, this.x + x + this.x_shift,
                           y + 25, 40, "v4d", true);
      return this;
    },

    drawSignoFixed: function(stave, x) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");
      var y = stave.getYForTopText(stave.options.num_lines) + this.y_shift;
      Vex.Flow.renderGlyph(stave.context, this.x + x + this.x_shift,
                           y + 25, 30, "v8c", true);
      return this;
    },

    drawSymbolText: function(stave, x, text, draw_coda) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var ctx = stave.context;
      ctx.save();
      ctx.setFont(this.font.family, this.font.size, this.font.weight);
        // Default to right symbol
      var text_x = 0 + this.x_shift;
      var symbol_x = x + this.x_shift;
      if (this.symbol_type == Vex.Flow.Repetition.type.CODA_LEFT) {
          // Offset Coda text to right of stave beginning
        text_x = this.x + stave.options.vertical_bar_width;
        symbol_x = text_x + ctx.measureText(text).width + 12;
      } else {
          // Offset Signo text to left stave end
        symbol_x = this.x + x + stave.width - 5 + this.x_shift;
        text_x = symbol_x - + ctx.measureText(text).width - 12;
      }
      var y = stave.getYForTopText(stave.options.num_lines) + this.y_shift;
      if (draw_coda) {
        Vex.Flow.renderGlyph(ctx, symbol_x, y, 40, "v4d", true);
      }

      ctx.fillText(text, text_x, y + 5);
      ctx.restore();

      return this;
    }
  });

  return Repetition;
}());
// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
// Author Larry Kuhns 2011
// Implements stave section names.

/**
 * @constructor
 */
Vex.Flow.StaveSection = (function() {
  function StaveSection(section, x, shift_y) {
    if (arguments.length > 0) this.init(section, x, shift_y);
  }

  var Modifier = Vex.Flow.Modifier;
  Vex.Inherit(StaveSection, Modifier, {
    init: function(section, x, shift_y) {
      StaveSection.superclass.init.call(this);

      this.setWidth(16);
      this.section = section;
      this.position = Modifier.Position.ABOVE;
      this.x = x;
      this.shift_x = 0;
      this.shift_y = shift_y;
      this.font = {
        family: "sans-serif",
        size: 12,
        weight: "bold"
      };
    },

    getCategory: function() { return "stavesection"; },
    setStaveSection: function(section) { this.section = section; return this; },
    setShiftX: function(x) { this.shift_x = x; return this; },
    setShiftY: function(y) { this.shift_y = y; return this; },

    draw: function(stave, shift_x) {
      if (!stave.context) throw new Vex.RERR("NoContext",
        "Can't draw stave section without a context.");

      var ctx = stave.context;

      ctx.save();
      ctx.lineWidth = 2;
      ctx.setFont(this.font.family, this.font.size, this.font.weight);
      var text_width = ctx.measureText("" + this.section).width;
      var width = text_width + 6;  // add left & right padding
      if (width < 18) width = 18;
      var height = 20;
        //  Seems to be a good default y
      var y = stave.getYForTopText(3) + this.shift_y;
      var x = this.x + shift_x;
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.rect(x, y, width, height);
      ctx.stroke();
      x += (width - text_width) / 2;
      ctx.fillText("" + this.section, x, y + 16);
      ctx.restore();
      return this;
    }
  });

  return StaveSection;
}());
// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
// Author Radosaw Eichler 2012
// Implements tempo marker.

/**
 * @constructor
 * @param {Object} tempo Tempo parameters: { name, duration, dots, bpm }
 */
Vex.Flow.StaveTempo = (function() {
  function StaveTempo(tempo, x, shift_y) {
    if (arguments.length > 0) this.init(tempo, x, shift_y);
  }

  Vex.Inherit(StaveTempo, Vex.Flow.StaveModifier, {
    init: function(tempo, x, shift_y) {
      StaveTempo.superclass.init.call(this);

      this.tempo = tempo;
      this.position = Vex.Flow.Modifier.Position.ABOVE;
      this.x = x;
      this.shift_x = 10;
      this.shift_y = shift_y;
      this.font = {
        family: "times",
        size: 14,
        weight: "bold"
      };
      this.render_options = {
        glyph_font_scale: 30  // font size for note
      };
    },

    getCategory: function() { return "stavetempo"; },
    setTempo: function(tempo) { this.tempo = tempo; return this; },
    setShiftX: function(x) { this.shift_x = x; return this; },
    setShiftY: function(y) { this.shift_y = y; return this; },

    draw: function(stave, shift_x) {
      if (!stave.context) throw new Vex.RERR("NoContext",
        "Can't draw stave tempo without a context.");

      var options = this.render_options;
      var scale = options.glyph_font_scale / 38;
      var name = this.tempo.name;
      var duration = this.tempo.duration;
      var dots = this.tempo.dots;
      var bpm = this.tempo.bpm;
      var font = this.font;
      var ctx = stave.context;
      var x = this.x + this.shift_x + shift_x;
      var y = stave.getYForTopText(1) + this.shift_y;

      ctx.save();

      if (name) {
        ctx.setFont(font.family, font.size, font.weight);
        ctx.fillText(name, x, y);
        x += ctx.measureText(name).width;
      }

      if (duration && bpm) {
        ctx.setFont(font.family, font.size, 'normal');

        if (name) {
          x += ctx.measureText(" ").width;
          ctx.fillText("(", x, y);
          x += ctx.measureText("(").width;
        }

        var code = Vex.Flow.durationToGlyph(duration);

        x += 3 * scale;
        Vex.Flow.renderGlyph(ctx, x, y, options.glyph_font_scale, code.code_head);
        x += code.head_width * scale;

        // Draw stem and flags
        if (code.stem) {
          var stem_height = 30;

          if (code.beam_count) stem_height += 3 * (code.beam_count - 1);

          stem_height *= scale;

          var y_top = y - stem_height;
          ctx.fillRect(x, y_top, scale, stem_height);

          if (code.flag) {
            Vex.Flow.renderGlyph(ctx, x + scale, y_top, options.glyph_font_scale,
                                 code.code_flag_upstem);

            if (!dots) x += 6 * scale;
          }
        }

        // Draw dot
        for (var i = 0; i < dots; i++) {
          x += 6 * scale;
          ctx.beginPath();
          ctx.arc(x, y + 2 * scale, 2 * scale, 0, Math.PI * 2, false);
          ctx.fill();
        }

        ctx.fillText(" = " + bpm + (name ? ")" : ""), x + 3 * scale, y);
      }

      ctx.restore();
      return this;
    }
  });

  return StaveTempo;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// Author Taehoon Moon 2014

/**
 * @constructor
 */
Vex.Flow.StaveText = (function() {
  function StaveText(text, position, options) {
    if (arguments.length > 0) this.init(text, position, options);
  }

  var Modifier = Vex.Flow.Modifier;
  Vex.Inherit(StaveText, Modifier, {
    init: function(text, position, options) {
      StaveText.superclass.init.call(this);

      this.setWidth(16);
      this.text = text;
      this.position = position;
      this.options = {
        shift_x: 0,
        shift_y: 0,
        justification: Vex.Flow.TextNote.Justification.CENTER
      };
      Vex.Merge(this.options, options);

      this.font = {
        family: "times",
        size: 16,
        weight: "normal"
      };
    },

    getCategory: function() { return "stavetext"; },
    setStaveText: function(text) { this.text = text; return this; },
    setShiftX: function(x) { this.shift_x = x; return this; },
    setShiftY: function(y) { this.shift_y = y; return this; },

    setFont: function(font) {
      Vex.Merge(this.font, font);
    },

    setText: function(text) {
      this.text = text;
    },

    draw: function(stave) {
      if (!stave.context) throw new Vex.RERR("NoContext",
        "Can't draw stave text without a context.");

      var ctx = stave.context;

      ctx.save();
      ctx.lineWidth = 2;
      ctx.setFont(this.font.family, this.font.size, this.font.weight);
      var text_width = ctx.measureText("" + this.text).width;

      var x, y;
      var Modifier = Vex.Flow.Modifier;
      switch(this.position) {
        case Modifier.Position.LEFT:
        case Modifier.Position.RIGHT:
          y = (stave.getYForLine(0) + stave.getBottomLineY()) / 2 + this.options.shift_y;
          if(this.position == Modifier.Position.LEFT) {
            x = stave.getX() - text_width - 24 + this.options.shift_x;
          }
          else {
            x = stave.getX() + stave.getWidth() + 24 + this.options.shift_x;
          }
          break;
        case Modifier.Position.ABOVE:
        case Modifier.Position.BELOW:
          var Justification = Vex.Flow.TextNote.Justification;
          x = stave.getX() + this.options.shift_x;
          if(this.options.justification == Justification.CENTER) {
            x += stave.getWidth() / 2 - text_width / 2;
          }
          else if(this.options.justification == Justification.RIGHT) {
            x += stave.getWidth() - text_width;
          }
          
          if(this.position == Modifier.Position.ABOVE) {
            y = stave.getYForTopText(2) + this.options.shift_y;
          }
          else {
            y = stave.getYForBottomText(2) + this.options.shift_y;
          }
          break;
        default:
          throw new Vex.RERR("InvalidPosition",
            "Value Must be in Modifier.Position.");
      }

      ctx.fillText("" + this.text, x, y + 4);
      ctx.restore();
      return this;
    }
  });

  return StaveText;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// A `BarNote` is used to render bar lines (from `barline.js`). `BarNote`s can
// be added to a voice and rendered in the middle of a stave. Since it has no
// duration, it consumes no `tick`s, and is dealt with appropriately by the formatter.
//
// See `tests/barnote_tests.js` for usage examples.

Vex.Flow.BarNote = (function() {
  function BarNote() { this.init(); }

  // To enable logging for this class. Set `Vex.Flow.BarNote.DEBUG` to `true`.
  function L() { if (BarNote.DEBUG) Vex.L("Vex.Flow.BarNote", arguments); }

  // ## Prototype Methods
  Vex.Inherit(BarNote, Vex.Flow.Note, {
    init: function() {
      BarNote.superclass.init.call(this, {duration: "b"});

      var TYPE = Vex.Flow.Barline.type;
      this.metrics = {
        widths: {}
      };

      // Defined this way to prevent lint errors.
      this.metrics.widths[TYPE.SINGLE] = 8;
      this.metrics.widths[TYPE.DOUBLE] = 12;
      this.metrics.widths[TYPE.END] = 15;
      this.metrics.widths[TYPE.REPEAT_BEGIN] = 14;
      this.metrics.widths[TYPE.REPEAT_END] = 14;
      this.metrics.widths[TYPE.REPEAT_BOTH] = 18;
      this.metrics.widths[TYPE.NONE] = 0;

      // Tell the formatter that bar notes have no duration.
      this.ignore_ticks = true;
      this.type = TYPE.SINGLE;

      // Set width to width of relevant `Barline`.
      this.setWidth(this.metrics.widths[this.type]);
    },

    // Get and set the type of Bar note. `type` must be one of `Vex.Flow.Barline.type`.
    getType: function() { return this.type; },
    setType: function(type) {
      this.type = type;
      this.setWidth(this.metrics.widths[this.type]);
      return this;
    },

    getBoundingBox: function() {
      return new Vex.Flow.BoundingBox(0, 0, 0, 0);
    },

    addToModifierContext: function() {
      /* overridden to ignore */
      return this;
    },

    preFormat: function() {
      /* overridden to ignore */
      this.setPreFormatted(true);
      return this;
    },

    // Render note to stave.
    draw: function() {
      if (!this.stave) throw new Vex.RERR("NoStave", "Can't draw without a stave.");
      L("Rendering bar line at: ", this.getAbsoluteX());
      var barline = new Vex.Flow.Barline(this.type, this.getAbsoluteX());
      barline.draw(this.stave);
    }
  });

  return BarNote;
}());

// VexFlow - Music Engraving for HTML5
// Author: Mike Corrigan <corrigan@gmail.com>
//
// This class implements tremolo notation.

/**
 * @constructor
 */
Vex.Flow.Tremolo = (function() {
  function Tremolo(num) {
    if (arguments.length > 0) this.init(num);
  }

  var Modifier = Vex.Flow.Modifier;
  Vex.Inherit(Tremolo, Modifier, {
    init: function(num) {
      Tremolo.superclass.init.call(this);

      this.num = num;
      this.note = null;
      this.index = null;
      this.position = Modifier.Position.CENTER;
      this.code = "v74";
      this.shift_right = -2;
      this.y_spacing = 4;

      this.render_options = {
        font_scale: 35,
        stroke_px: 3,
        stroke_spacing: 10
      };

      this.font = {
        family: "Arial",
        size: 16,
        weight: ""
      };
    },

    getCategory: function() { return "tremolo"; },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw Tremolo without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw Tremolo without a note and index.");

      var start = this.note.getModifierStartXY(this.position, this.index);
      var x = start.x;
      var y = start.y;

      x += this.shift_right;
      for (var i = 0; i < this.num; ++i) {
        Vex.Flow.renderGlyph(this.context, x, y,
                             this.render_options.font_scale, this.code);
        y += this.y_spacing;
      }
    }
  });

  return Tremolo;
}());

/**
 * Create a new tuplet from the specified notes. The notes must
 * be part of the same line, and have the same duration (in ticks).
 *
 * @constructor
 * @param {Array.<Vex.Flow.StaveNote>} A set of notes.
 */
Vex.Flow.Tuplet = (function() {
  function Tuplet(notes, options) {
    if (arguments.length > 0) this.init(notes, options);
  }

  Tuplet.LOCATION_TOP = 1;
  Tuplet.LOCATION_BOTTOM = -1;

  Tuplet.prototype = {
    init: function(notes, options) {
      if (!notes || notes == []) {
        throw new Vex.RuntimeError("BadArguments", "No notes provided for tuplet.");
      }

      if (notes.length == 1) {
        throw new Vex.RuntimeError("BadArguments", "Too few notes for tuplet.");
      }

      this.options = Vex.Merge({}, options);
      this.notes = notes;
      this.num_notes = 'num_notes' in this.options ?
        this.options.num_notes : notes.length;
      this.beats_occupied = 'beats_occupied' in this.options ?
        this.options.beats_occupied : 2;
      this.bracketed = (notes[0].beam == null);
      this.ratioed = false;
      this.point = 28;
      this.y_pos = 16;
      this.x_pos = 100;
      this.width = 200;
      this.location = Tuplet.LOCATION_TOP;

      Vex.Flow.Formatter.AlignRestsToNotes(notes, true, true);
      this.resolveGlyphs();
      this.attach();
    },

    attach: function () {
      for (var i = 0; i < this.notes.length; i++) {
        var note = this.notes[i];
        note.setTuplet(this);
      }
    },

    detach: function () {
      for (var i = 0; i < this.notes.length; i++) {
        var note = this.notes[i];
        note.setTuplet(null);
      }
    },

    setContext: function(context) {
      this.context = context;
      return this;
    },

    /**
     * Set whether or not the bracket is drawn.
     */
    setBracketed: function(bracketed) {
      this.bracketed = bracketed ? true : false;
      return this;
    },

    /**
     * Set whether or not the ratio is shown.
     */
    setRatioed: function(ratioed) {
      this.ratioed = ratioed ? true : false;
      return this;
    },

    /**
     * Set the tuplet to be displayed either on the top or bottom of the stave
     */
    setTupletLocation: function(location) {
      if (!location) location = Tuplet.LOCATION_TOP;
      else if (location != Tuplet.LOCATION_TOP &&
          location != Tuplet.LOCATION_BOTTOM) {
        throw new Vex.RERR("BadArgument", "Invalid tuplet location: " + location);
      }

      this.location = location;
      return this;
    },

    getNotes: function() {
      return this.notes;
    },

    getNoteCount: function() {
      return this.num_notes;
    },

    getBeatsOccupied: function() {
      return this.beats_occupied;
    },

    setBeatsOccupied: function(beats) {
      this.detach();
      this.beats_occupied = beats;
      this.resolveGlyphs();
      this.attach();
    },

    resolveGlyphs: function() {
      this.num_glyphs = [];
      var n = this.num_notes;
      while (n >= 1) {
        this.num_glyphs.push(new Vex.Flow.Glyph("v" + (n % 10), this.point));
        n = parseInt(n / 10, 10);
      }

      this.denom_glyphs = [];
      n = this.beats_occupied;
      while (n >= 1) {
        this.denom_glyphs.push(new Vex.Flow.Glyph("v" + (n % 10), this.point));
        n = parseInt(n / 10, 10);
      }
    },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      // determine x value of left bound of tuplet
      var first_note = this.notes[0];
      var last_note = this.notes[this.notes.length - 1];

      if (!this.bracketed) {
        this.x_pos = first_note.getStemX();
        this.width = last_note.getStemX() - this.x_pos;
      }
      else {
        this.x_pos = first_note.getTieLeftX() - 5;
        this.width = last_note.getTieRightX() - this.x_pos + 5;
      }

      // determine y value for tuplet
      var i;
      if (this.location == Tuplet.LOCATION_TOP) {
        this.y_pos = first_note.getStave().getYForLine(0) - 15;
        //this.y_pos = first_note.getStemExtents().topY - 10;

        for (i=0; i<this.notes.length; ++i) {
          var top_y = this.notes[i].getStemDirection() === Vex.Flow.Stem.UP ?
              this.notes[i].getStemExtents().topY - 10
            : this.notes[i].getStemExtents().baseY - 20;
          if (top_y < this.y_pos)
            this.y_pos = top_y;
        }
      }
      else {
        this.y_pos = first_note.getStave().getYForLine(4) + 20;

        for (i=0; i<this.notes.length; ++i) {
          var bottom_y = this.notes[i].getStemDirection() === Vex.Flow.Stem.UP ?
              this.notes[i].getStemExtents().baseY + 20
            : this.notes[i].getStemExtents().topY + 10;
          if (bottom_y > this.y_pos)
            this.y_pos = bottom_y;
        }
      }

      // calculate total width of tuplet notation
      var width = 0;
      var glyph;
      for (glyph in this.num_glyphs) {
        width += this.num_glyphs[glyph].getMetrics().width;
      }
      if (this.ratioed) {
        for (glyph in this.denom_glyphs) {
          width += this.denom_glyphs[glyph].getMetrics().width;
        }
        width += this.point * 0.32;
      }

      var notation_center_x = this.x_pos + (this.width/2);
      var notation_start_x = notation_center_x - (width/2);

      // draw bracket if the tuplet is not beamed
      if (this.bracketed) {
        var line_width = this.width/2 - width/2 - 5;

        // only draw the bracket if it has positive length
        if (line_width > 0) {
          this.context.fillRect(this.x_pos, this.y_pos,line_width, 1);
          this.context.fillRect(this.x_pos + this.width / 2 + width / 2 + 5,
                                this.y_pos,line_width, 1);
          this.context.fillRect(this.x_pos,
              this.y_pos + (this.location == Tuplet.LOCATION_BOTTOM),
              1, this.location * 10);
          this.context.fillRect(this.x_pos + this.width,
              this.y_pos + (this.location == Tuplet.LOCATION_BOTTOM),
              1, this.location * 10);
        }
      }

      // draw numerator glyphs
      var x_offset = 0;
      var size = this.num_glyphs.length;
      for (glyph in this.num_glyphs) {
        this.num_glyphs[size-glyph-1].render(
            this.context, notation_start_x + x_offset,
            this.y_pos + (this.point/3) - 2);
        x_offset += this.num_glyphs[size-glyph-1].getMetrics().width;
      }

      // display colon and denominator if the ratio is to be shown
      if (this.ratioed) {
        var colon_x = notation_start_x + x_offset + this.point*0.16;
        var colon_radius = this.point * 0.06;
        this.context.beginPath();
        this.context.arc(colon_x, this.y_pos - this.point*0.08,
                         colon_radius, 0, Math.PI*2, true);
        this.context.closePath();
        this.context.fill();
        this.context.beginPath();
        this.context.arc(colon_x, this.y_pos + this.point*0.12,
                         colon_radius, 0, Math.PI*2, true);
        this.context.closePath();
        this.context.fill();
        x_offset += this.point*0.32;
        size = this.denom_glyphs.length;
        for (glyph in this.denom_glyphs) {
          this.denom_glyphs[size-glyph-1].render(
              this.context, notation_start_x + x_offset,
              this.y_pos + (this.point/3) - 2);
          x_offset += this.denom_glyphs[size-glyph-1].getMetrics().width;
        }
      }
    }
  };

  return Tuplet;
}());

// Vex Music Notation
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Muthanna 2010

// Bounding boxes for interactive notation

/** @constructor */
Vex.Flow.BoundingBox = (function() {
  function BoundingBox(x, y, w, h) { this.init(x, y, w, h); }
  BoundingBox.copy = function(that) {
    return new BoundingBox(that.x, that.y, that.w, that.h); };

  BoundingBox.prototype = {
    init: function(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
    },

    getX: function() { return this.x; },
    getY: function() { return this.y; },
    getW: function() { return this.w; },
    getH: function() { return this.h; },

    setX: function(x) { this.x = x; return this; },
    setY: function(y) { this.y = y; return this; },
    setW: function(w) { this.w = w; return this; },
    setH: function(h) { this.h = h; return this; },

    move: function(x, y) { this.x += x; this.y += y; },
    clone: function() { return BoundingBox.copy(this); },

    // Merge my box with given box. Creates a bigger bounding box unless
    // the given box is contained in this one.
    mergeWith: function(boundingBox, ctx) {
      var that = boundingBox;

      var new_x = this.x < that.x ? this.x : that.x;
      var new_y = this.y < that.y ? this.y : that.y;
      var new_w = (this.x + this.w) < (that.x + that.w) ? (that.x + that.w) - this.x : (this.x + this.w) - Vex.Min(this.x, that.x);
      var new_h = (this.y + this.h) < (that.y + that.h) ? (that.y + that.h) - this.y : (this.y + this.h) - Vex.Min(this.y, that.y);

      this.x = new_x;
      this.y = new_y;
      this.w = new_w;
      this.h = new_h;

      if (ctx) this.draw(ctx);
      return this;
    },

    draw: function(ctx, x, y) {
      if (!x) x = 0;
      if (!y) y = 0;
      ctx.rect(this.x + x, this.y + y, this.w, this.h);
      ctx.stroke();
    }
  };

  return BoundingBox;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// `TextNote` is a notation element that is positioned in time. Generally 
// meant for objects that sit above/below the staff and inline with each other.
// Examples of this would be such as dynamics, lyrics, chord changes, etc.
Vex.Flow.TextNote = (function() {
  function TextNote(text_struct) {
    if (arguments.length > 0) this.init(text_struct);
  }

  TextNote.Justification = {
    LEFT: 1,
    CENTER: 2,
    RIGHT: 3
  };

  // Glyph data
  TextNote.GLYPHS = {
    "segno": {
      code: "v8c",
      point: 40,
      x_shift: 0,
      y_shift: -10
      // width: 10 // optional
    },
    "tr": {
      code: "v1f",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "mordent_upper": {
      code: "v1e",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "mordent_lower": {
      code: "v45",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "f": {
      code: "vba",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "p": {
      code: "vbf",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "m": {
      code: "v62",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "s": {
      code: "v4a",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "z": {
      code: "v80",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "coda": {
      code: "v4d",
      point: 40,
      x_shift: 0,
      y_shift: -8
      // width: 10 // optional
    },
    "pedal_open": {
      code: "v36",
      point:40,
      x_shift:0,
      y_shift:0
    },
    "pedal_close": {
      code: "v5d",
      point:40,
      x_shift:0,
      y_shift:3
    },
    "caesura_straight": {
      code: "v34",
      point:40,
      x_shift:0,
      y_shift:2
    },
    "caesura_curved": {
      code: "v4b",
      point:40,
      x_shift:0,
      y_shift:2
    },
    "breath": {
      code: "v6c",
      point:40,
      x_shift:0,
      y_shift:0
    },
    "tick": {
      code: "v6f",
      point:50,
      x_shift:0,
      y_shift:0
    },
    "turn": {
      code: "v72",
      point:40,
      x_shift:0,
      y_shift:0
    },
    "turn_inverted": {
      code: "v33",
      point:40,
      x_shift:0,
      y_shift:0
    },

    // DEPRECATED - please use "mordent_upper" or "mordent_lower"
    "mordent": {
      code: "v1e",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
  };

  // ## Prototype Methods
  Vex.Inherit(TextNote, Vex.Flow.Note, {
    init: function(text_struct) {
      TextNote.superclass.init.call(this, text_struct);

      // Note properties
      this.text = text_struct.text;
      this.superscript = text_struct.superscript;
      this.subscript = text_struct.subscript;
      this.glyph_type = text_struct.glyph;
      this.glyph = null;
      this.font = {
        family: "Arial",
        size: 12,
        weight: ""
      };

      // Set font
      if (text_struct.font) this.font = text_struct.font;

      // Determine and set initial note width. Note that the text width is 
      // an approximation and isn't very accurate. The only way to accurately
      // measure the length of text is with `canvasContext.measureText()`
      if (this.glyph_type) {
        var struct = TextNote.GLYPHS[this.glyph_type];
        if (!struct) throw new Vex.RERR("Invalid glyph type: " + this.glyph_type);

        this.glyph = new Vex.Flow.Glyph(struct.code, struct.point, {cache: false});

        if (struct.width)
          this.setWidth(struct.width);
        else
          this.setWidth(this.glyph.getMetrics().width);

        this.glyph_struct = struct;
      } else {
        this.setWidth(Vex.Flow.textWidth(this.text));
      }
      this.line = text_struct.line || 0;
      this.smooth = text_struct.smooth || false;
      this.ignore_ticks = text_struct.ignore_ticks || false;
      this.justification = TextNote.Justification.LEFT;
    },

    // Set the horizontal justification of the TextNote
    setJustification: function(just) {
      this.justification = just;
      return this;
    },

    // Set the Stave line on which the note should be placed
    setLine: function(line) {
      this.line = line;
      return this;
    },

    // Pre-render formatting
    preFormat: function() {
      if (!this.context) throw new Vex.RERR("NoRenderContext",
          "Can't measure text without rendering context.");
      if (this.preFormatted) return;

      if (this.smooth) {
        this.setWidth(0);
      } else {
        if (this.glyph) {
          // Width already set.
        } else {
          this.setWidth(this.context.measureText(this.text).width);
        }
      }

      if (this.justification == TextNote.Justification.CENTER) {
        this.extraLeftPx = this.width / 2;
      } else if (this.justification == TextNote.Justification.RIGHT) {
        this.extraLeftPx = this.width;
      }

      this.setPreFormatted(true);
    },

    // Renders the TextNote
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      if (!this.stave) throw new Vex.RERR("NoStave", "Can't draw without a stave.");

      var ctx = this.context;
      var x = this.getAbsoluteX();
      if (this.justification == TextNote.Justification.CENTER) {
        x -= this.getWidth() / 2;
      } else if (this.justification == TextNote.Justification.RIGHT) {
        x -= this.getWidth();
      }

      var y;
      if (this.glyph) {
        y = this.stave.getYForLine(this.line + (-3));
        this.glyph.render(this.context,
                          x + this.glyph_struct.x_shift,
                          y + this.glyph_struct.y_shift);
      } else {
        y = this.stave.getYForLine(this.line + (-3));
        ctx.save();
        ctx.setFont(this.font.family, this.font.size, this.font.weight);
        ctx.fillText(this.text, x, y);

        // Width of the letter M gives us the approximate height of the text
        var height = ctx.measureText("M").width;
        // Get accurate width of text
        var width = ctx.measureText(this.text).width;

        // Write superscript
        if (this.superscript) {
          ctx.setFont(this.font.family, this.font.size / 1.3, this.font.weight);
          ctx.fillText(this.superscript, x + width + 2, y - (height/2.2));
        }

        // Write subscript
        if (this.subscript) {
          ctx.setFont(this.font.family, this.font.size / 1.3, this.font.weight);
          ctx.fillText(this.subscript, x + width + 2, y + (height/2.2) - 1);
        }

        ctx.restore();
      }
    }
  });

  return TextNote;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
// Author Larry Kuhns 2013
// Class to draws string numbers into the notation.

/**
 * @constructor
 */
Vex.Flow.FretHandFinger = (function() {
  function FretHandFinger(number) {
    if (arguments.length > 0) this.init(number);
  }
  FretHandFinger.CATEGORY = "frethandfinger";

  var Modifier = Vex.Flow.Modifier;

  // Arrange fingerings inside a ModifierContext.
  FretHandFinger.format = function(nums, state) {
    var left_shift = state.left_shift;
    var right_shift = state.right_shift;
    var num_spacing = 1;

    if (!nums || nums.length === 0) return false;

    var nums_list = [];
    var prev_note = null;
    var shift_left = 0;
    var shift_right = 0;

    var i, num, note, pos, props_tmp;
    for (i = 0; i < nums.length; ++i) {
      num = nums[i];
      note = num.getNote();
      pos = num.getPosition();
      var props = note.getKeyProps()[num.getIndex()];
      if (note != prev_note) {
        for (var n = 0; n < note.keys.length; ++n) {
          props_tmp = note.getKeyProps()[n];
          if (left_shift === 0)
            shift_left = (props_tmp.displaced ? note.getExtraLeftPx() : shift_left);
          if (right_shift === 0)
            shift_right = (props_tmp.displaced ? note.getExtraRightPx() : shift_right);
        }
        prev_note = note;
      }

      nums_list.push({ line: props.line, pos: pos, shiftL: shift_left, shiftR: shift_right, note: note, num: num });
    }

    // Sort fingernumbers by line number.
    nums_list.sort(function(a, b) { return (b.line - a.line); });

    var num_shiftL = 0;
    var num_shiftR = 0;
    var x_widthL = 0;
    var x_widthR = 0;
    var last_line = null;
    var last_note = null;

    for (i = 0; i < nums_list.length; ++i) {
      var num_shift = 0;
      note = nums_list[i].note;
      pos = nums_list[i].pos;
      num = nums_list[i].num;
      var line = nums_list[i].line;
      var shiftL = nums_list[i].shiftL;
      var shiftR = nums_list[i].shiftR;

      // Reset the position of the string number every line.
      if (line != last_line || note != last_note) {
        num_shiftL = left_shift + shiftL;
        num_shiftR = right_shift + shiftR;
      }

      var num_width = num.getWidth() + num_spacing;
      if (pos == Vex.Flow.Modifier.Position.LEFT) {
        num.setXShift(left_shift + num_shiftL);
        num_shift = left_shift + num_width; // spacing
        x_widthL = (num_shift > x_widthL) ? num_shift : x_widthL;
      } else if (pos == Vex.Flow.Modifier.Position.RIGHT) {
        num.setXShift(num_shiftR);
        num_shift = shift_right + num_width; // spacing
        x_widthR = (num_shift > x_widthR) ? num_shift : x_widthR;
      }
      last_line = line;
      last_note = note;
    }

    state.left_shift += x_widthL;
    state.right_shift += x_widthR;
  };

  Vex.Inherit(FretHandFinger, Modifier, {
    init: function(number) {
      var superclass = Vex.Flow.FretHandFinger.superclass;
      superclass.init.call(this);

      this.note = null;
      this.index = null;
      this.finger = number;
      this.width = 7;
      this.position = Modifier.Position.LEFT;  // Default position above stem or note head
      this.x_shift = 0;
      this.y_shift = 0;
      this.x_offset = 0;       // Horizontal offset from default
      this.y_offset = 0;       // Vertical offset from default
      this.font = {
        family: "sans-serif",
        size: 9,
        weight: "bold"
      };
    },

    getNote: function() { return this.note; },
    setNote: function(note) { this.note = note; return this; },
    getIndex: function() { return this.index; },
    setIndex: function(index) { this.index = index; return this; },
    getPosition: function() { return this.position; },
    setPosition: function(position) {
      if (position >= Modifier.Position.LEFT &&
          position <= Modifier.Position.BELOW)
        this.position = position;
      return this;
    },
    setFretHandFinger: function(number) { this.finger = number; return this; },
    setOffsetX: function(x) { this.x_offset = x; return this; },
    setOffsetY: function(y) { this.y_offset = y; return this; },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw string number without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw string number without a note and index.");

      var ctx = this.context;
      var start = this.note.getModifierStartXY(this.position, this.index);
      var dot_x = (start.x + this.x_shift + this.x_offset);
      var dot_y = start.y + this.y_shift + this.y_offset + 5;

      switch (this.position) {
        case Modifier.Position.ABOVE:
          dot_x -= 4;
          dot_y -= 12;
          break;
        case Modifier.Position.BELOW:
          dot_x -= 2;
          dot_y += 10;
          break;
        case Modifier.Position.LEFT:
          dot_x -= this.width;
          break;
        case Modifier.Position.RIGHT:
          dot_x += 1;
          break;
      }

      ctx.save();
      ctx.setFont(this.font.family, this.font.size, this.font.weight);
      ctx.fillText("" + this.finger, dot_x, dot_y);

      ctx.restore();
    }
  });

  return FretHandFinger;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// Author: Larry Kuhns
//
// ## Description
//
// This file implements the `StringNumber` class which renders string
// number annotations beside notes.

Vex.Flow.StringNumber = (function() {
  function StringNumber(number) {
    if (arguments.length > 0) this.init(number);
  }
  StringNumber.CATEGORY = "stringnumber";

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods
  // Arrange string numbers inside a `ModifierContext`
  StringNumber.format = function(nums, state) {
    var left_shift = state.left_shift;
    var right_shift = state.right_shift;
    var num_spacing = 1;

    if (!nums || nums.length === 0) return this;

    var nums_list = [];
    var prev_note = null;
    var shift_left = 0;
    var shift_right = 0;

    var i, num, note, pos, props_tmp;
    for (i = 0; i < nums.length; ++i) {
      num = nums[i];
      note = num.getNote();

      for (i = 0; i < nums.length; ++i) {
        num = nums[i];
        note = num.getNote();
        pos = num.getPosition();
        var props = note.getKeyProps()[num.getIndex()];

        if (note != prev_note) {
          for (var n = 0; n < note.keys.length; ++n) {
            props_tmp = note.getKeyProps()[n];
            if (left_shift === 0)
              shift_left = (props_tmp.displaced ? note.getExtraLeftPx() : shift_left);
            if (right_shift === 0)
              shift_right = (props_tmp.displaced ? note.getExtraRightPx() : shift_right);
          }
          prev_note = note;
        }

        nums_list.push({ line: props.line, pos: pos, shiftL: shift_left, shiftR: shift_right, note: note, num: num });
      }
    }

    // Sort string numbers by line number.
    nums_list.sort(function(a, b) { return (b.line - a.line); });

    var num_shiftL = 0;
    var num_shiftR = 0;
    var x_widthL = 0;
    var x_widthR = 0;
    var last_line = null;
    var last_note = null;
    for (i = 0; i < nums_list.length; ++i) {
      var num_shift = 0;
      note = nums_list[i].note;
      pos = nums_list[i].pos;
      num = nums_list[i].num;
      var line = nums_list[i].line;
      var shiftL = nums_list[i].shiftL;
      var shiftR = nums_list[i].shiftR;

      // Reset the position of the string number every line.
      if (line != last_line || note != last_note) {
        num_shiftL = left_shift + shiftL;
        num_shiftR = right_shift + shiftR;
      }

      var num_width = num.getWidth() + num_spacing;
      if (pos == Vex.Flow.Modifier.Position.LEFT) {
        num.setXShift(left_shift);
        num_shift = shift_left + num_width; // spacing
        x_widthL = (num_shift > x_widthL) ? num_shift : x_widthL;
      } else if (pos == Vex.Flow.Modifier.Position.RIGHT) {
        num.setXShift(num_shiftR);
        num_shift += num_width; // spacing
        x_widthR = (num_shift > x_widthR) ? num_shift : x_widthR;
      }
      last_line = line;
      last_note = note;
    }

    state.left_shift += x_widthL;
    state.right_shift += x_widthR;
    return true;
  };

  // ## Prototype Methods
  Vex.Inherit(StringNumber, Modifier, {
    init: function(number) {
      StringNumber.superclass.init.call(this);

      this.note = null;
      this.last_note = null;
      this.index = null;
      this.string_number = number;
      this.setWidth(20);                                 // ???
      this.position = Modifier.Position.ABOVE;  // Default position above stem or note head
      this.x_shift = 0;
      this.y_shift = 0;
      this.x_offset = 0;                               // Horizontal offset from default
      this.y_offset = 0;                               // Vertical offset from default
      this.dashed = true;                              // true - draw dashed extension  false - no extension
      this.leg = Vex.Flow.Renderer.LineEndType.NONE;   // draw upward/downward leg at the of extension line
      this.radius = 8;
      this.font = {
        family: "sans-serif",
        size: 10,
        weight: "bold"
      };
    },

    getNote: function() { return this.note; },
    setNote: function(note) { this.note = note; return this; },
    getIndex: function() { return this.index; },
    setIndex: function(index) { this.index = index; return this; },

    setLineEndType: function(leg) {
      if (leg >= Vex.Flow.Renderer.LineEndType.NONE &&
          leg <= Vex.Flow.Renderer.LineEndType.DOWN)
        this.leg = leg;
      return this;
    },

    getPosition: function() { return this.position; },
    setPosition: function(position) {
      if (position >= Modifier.Position.LEFT &&
          position <= Modifier.Position.BELOW)
        this.position = position;
      return this;
    },

    setStringNumber: function(number) { this.string_number = number; return this; },
    setOffsetX: function(x) { this.x_offset = x; return this; },
    setOffsetY: function(y) { this.y_offset = y; return this; },
    setLastNote: function(note) { this.last_note = note; return this; },
    setDashed: function(dashed) { this.dashed = dashed; return this; },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw string number without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw string number without a note and index.");

      var ctx = this.context;
      var line_space = this.note.stave.options.spacing_between_lines_px;

      var start = this.note.getModifierStartXY(this.position, this.index);
      var dot_x = (start.x + this.x_shift + this.x_offset);
      var dot_y = start.y + this.y_shift + this.y_offset;

      switch (this.position) {
        case Modifier.Position.ABOVE:
        case Modifier.Position.BELOW:
          var stem_ext = this.note.getStemExtents();
          var top = stem_ext.topY;
          var bottom = stem_ext.baseY + 2;

          if (this.note.stem_direction == Vex.Flow.StaveNote.STEM_DOWN) {
            top = stem_ext.baseY;
            bottom = stem_ext.topY - 2;
          }

          if (this.position == Modifier.Position.ABOVE) {
            dot_y = this.note.hasStem() ? top - (line_space * 1.75)
                                        : start.y - (line_space * 1.75);
        } else {
            dot_y = this.note.hasStem() ? bottom + (line_space * 1.5)
                                        : start.y + (line_space * 1.75);
          }

          dot_y += this.y_shift + this.y_offset;

          break;
        case Modifier.Position.LEFT:
          dot_x -= (this.radius / 2) + 5;
          break;
        case Modifier.Position.RIGHT:
          dot_x += (this.radius / 2) + 6;
          break;
      }

      ctx.save();
      ctx.beginPath();
      ctx.arc(dot_x, dot_y, this.radius, 0, Math.PI * 2, false);
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.setFont(this.font.family, this.font.size, this.font.weight);
      var x = dot_x - ctx.measureText(this.string_number).width / 2;
      ctx.fillText("" + this.string_number, x, dot_y + 4.5);

      if (this.last_note != null) {
        var end = this.last_note.getStemX() - this.note.getX() + 5;
        ctx.strokeStyle="#000000";
        ctx.lineCap = "round";
        ctx.lineWidth = 0.6;
        if (this.dashed)
          Vex.Flow.Renderer.drawDashedLine(ctx, dot_x + 10, dot_y, dot_x + end, dot_y, [3,3]);
        else
          Vex.Flow.Renderer.drawDashedLine(ctx, dot_x + 10, dot_y, dot_x + end, dot_y, [3,0]);

        var len, pattern;
        switch (this.leg) {
          case Vex.Flow.Renderer.LineEndType.UP:
            len = -10;
            pattern = this.dashed ? [3,3] : [3,0];
            Vex.Flow.Renderer.drawDashedLine(ctx, dot_x + end, dot_y, dot_x + end, dot_y + len, pattern);
            break;
          case Vex.Flow.Renderer.LineEndType.DOWN:
            len = 10;
            pattern = this.dashed ? [3,3] : [3,0];
            Vex.Flow.Renderer.drawDashedLine(ctx, dot_x + end, dot_y, dot_x + end, dot_y + len, pattern);
            break;
        }
      }

      ctx.restore();
    }
  });

  return StringNumber;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// Author: Larry Kuhns
//
// ## Description
//
// This file implements the `Stroke` class which renders chord strokes
// that can be arpeggiated, brushed, rasquedo, etc.

Vex.Flow.Stroke = (function() {
  function Stroke(type, options) {
    if (arguments.length > 0) this.init(type, options);
  }
  Stroke.CATEGORY = "strokes";

  Stroke.Type = {
    BRUSH_DOWN: 1,
    BRUSH_UP: 2,
    ROLL_DOWN: 3,        // Arpegiated chord
    ROLL_UP: 4,          // Arpegiated chord
    RASQUEDO_DOWN: 5,
    RASQUEDO_UP: 6
  };

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods

  // Arrange strokes inside `ModifierContext`
  Stroke.format = function(strokes, state) {
    var left_shift = state.left_shift;
    var stroke_spacing = 0;

    if (!strokes || strokes.length === 0) return this;

    var str_list = [];
    var i, str, shift;
    for (i = 0; i < strokes.length; ++i) {
      str = strokes[i];
      var note = str.getNote();
      var props;
      if (note instanceof Vex.Flow.StaveNote) {
        props = note.getKeyProps()[str.getIndex()];
        shift = (props.displaced ? note.getExtraLeftPx() : 0);
        str_list.push({ line: props.line, shift: shift, str: str });
      } else {
        props = note.getPositions()[str.getIndex()];
        str_list.push({ line: props.str, shift: 0, str: str });
      }
    }

    var str_shift = left_shift;
    var x_shift = 0;

    // There can only be one stroke .. if more than one, they overlay each other
    for (i = 0; i < str_list.length; ++i) {
      str = str_list[i].str;
      shift = str_list[i].shift;

      str.setXShift(str_shift + shift);
      x_shift = Math.max(str.getWidth() + stroke_spacing, x_shift);
    }

    state.left_shift += x_shift;
    return true;
  };

  // ## Prototype Methods
  Vex.Inherit(Stroke, Modifier, {
    init: function(type, options) {
      Stroke.superclass.init.call(this);

      this.note = null;
      this.options = Vex.Merge({}, options);

      // multi voice - span stroke across all voices if true
      this.all_voices = 'all_voices' in this.options ?
        this.options.all_voices : true;

      // multi voice - end note of stroke, set in draw()
      this.note_end = null;
      this.index = null;
      this.type = type;
      this.position = Modifier.Position.LEFT;

      this.render_options = {
        font_scale: 38,
        stroke_px: 3,
        stroke_spacing: 10
      };

      this.font = {
       family: "serif",
       size: 10,
       weight: "bold italic"
     };

      this.setXShift(0);
      this.setWidth(10);
    },

    getPosition: function() { return this.position; },
    addEndNote: function(note) { this.note_end = note; return this; },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw stroke without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw stroke without a note and index.");
      var start = this.note.getModifierStartXY(this.position, this.index);
      var ys = this.note.getYs();
      var topY = start.y;
      var botY = start.y;
      var x = start.x - 5;
      var line_space = this.note.stave.options.spacing_between_lines_px;

      var notes = this.getModifierContext().getModifiers(this.note.getCategory());
      var i;
      for (i = 0; i < notes.length; i++) {
        ys = notes[i].getYs();
        for (var n = 0; n < ys.length; n++) {
          if (this.note == notes[i] || this.all_voices) {
            topY = Vex.Min(topY, ys[n]);
            botY = Vex.Max(botY, ys[n]);
          }
        }
      }

      var arrow, arrow_shift_x, arrow_y, text_shift_x, text_y;
      switch (this.type) {
        case Stroke.Type.BRUSH_DOWN:
          arrow = "vc3";
          arrow_shift_x = -3;
          arrow_y = topY - (line_space / 2) + 10;
          botY += (line_space / 2);
          break;
        case Stroke.Type.BRUSH_UP:
          arrow = "v11";
          arrow_shift_x = 0.5;
          arrow_y = botY + (line_space / 2);
          topY -= (line_space / 2);
          break;
        case Stroke.Type.ROLL_DOWN:
        case Stroke.Type.RASQUEDO_DOWN:
          arrow = "vc3";
          arrow_shift_x = -3;
          text_shift_x = this.x_shift + arrow_shift_x - 2;
          if (this.note instanceof Vex.Flow.StaveNote) {
            topY += 1.5 * line_space;
            if ((botY - topY) % 2 !== 0) {
              botY += 0.5 * line_space;
            } else {
              botY += line_space;
            }
            arrow_y = topY - line_space;
            text_y = botY + line_space + 2;
          } else {
            topY += 1.5 * line_space;
            botY += line_space;
            arrow_y = topY - 0.75 * line_space;
            text_y = botY + 0.25 * line_space;
          }
          break;
        case Stroke.Type.ROLL_UP:
        case Stroke.Type.RASQUEDO_UP:
          arrow = "v52";
          arrow_shift_x = -4;
          text_shift_x = this.x_shift + arrow_shift_x - 1;
          if (this.note instanceof Vex.Flow.StaveNote) {
            arrow_y = line_space / 2;
            topY += 0.5 * line_space;
            if ((botY - topY) % 2 === 0) {
              botY += line_space / 2;
            }
            arrow_y = botY + 0.5 * line_space;
            text_y = topY - 1.25 * line_space;
          } else {
            topY += 0.25 * line_space;
            botY += 0.5 * line_space;
            arrow_y = botY + 0.25 * line_space;
            text_y = topY - line_space;
          }
          break;
      }

      // Draw the stroke
      if (this.type == Stroke.Type.BRUSH_DOWN ||
          this.type == Stroke.Type.BRUSH_UP) {
        this.context.fillRect(x + this.x_shift, topY, 1, botY - topY);
      } else {
        if (this.note instanceof Vex.Flow.StaveNote) {
          for (i = topY; i <= botY; i += line_space) {
            Vex.Flow.renderGlyph(this.context, x + this.x_shift - 4,
                                 i,
                                 this.render_options.font_scale, "va3");
          }
        } else {
          for (i = topY; i <= botY; i+= 10) {
            Vex.Flow.renderGlyph(this.context, x + this.x_shift - 4,
                                 i,
                                 this.render_options.font_scale, "va3");
          }
          if (this.type == Vex.Flow.Stroke.Type.RASQUEDO_DOWN)
            text_y = i + 0.25 * line_space;
        }
      }

      // Draw the arrow head
      Vex.Flow.renderGlyph(this.context, x + this.x_shift + arrow_shift_x, arrow_y,
                           this.render_options.font_scale, arrow);

      // Draw the rasquedo "R"
      if (this.type == Stroke.Type.RASQUEDO_DOWN ||
          this.type == Stroke.Type.RASQUEDO_UP) {
        this.context.save();
        this.context.setFont(this.font.family, this.font.size, this.font.weight);
        this.context.fillText("R", x + text_shift_x, text_y);
        this.context.restore();
      }
    }
  });

  return Stroke;
}());
// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements curves (for slurs)

Vex.Flow.Curve = (function() {
  // from: Start note
  // to: End note
  // options:
  //    cps: List of control points
  //    x_shift: pixels to shift
  //    y_shift: pixels to shift
  function Curve(from, to, options) {
    if (arguments.length > 0) this.init(from, to, options);
  }

  Curve.Position = {
    NEAR_HEAD: 1,
    NEAR_TOP: 2
  };

  Curve.DEBUG = true;

  Curve.prototype = {
    init: function(from, to, options) {
      this.render_options = {
        spacing: 2,
        thickness: 2,
        x_shift: 0,
        y_shift: 10,
        position: Curve.Position.NEAR_HEAD,
        invert: false,
        cps: [{x: 0, y: 10}, {x: 0, y: 10}]
      };

      Vex.Merge(this.render_options, options);
      this.setNotes(from, to);
    },

    setContext: function(context) { this.context = context; return this; },
    setNotes: function(from, to) {
      if (!from && !to)
        throw new Vex.RuntimeError("BadArguments",
            "Curve needs to have either first_note or last_note set.");

      this.from = from;
      this.to = to;
      return this;
    },

    /**
     * @return {boolean} Returns true if this is a partial bar.
     */
    isPartial: function() {
      return (!this.from || !this.to);
    },

    renderCurve: function(params) {
      var ctx = this.context;
      var cps = this.render_options.cps;

      var x_shift = this.render_options.x_shift;
      var y_shift = this.render_options.y_shift * params.direction;

      var first_x = params.first_x + x_shift;
      var first_y = params.first_y + y_shift;
      var last_x = params.last_x - x_shift;
      var last_y = params.last_y + y_shift;
      var thickness = this.render_options.thickness;

      var cp_spacing = (last_x - first_x) / (cps.length + 2);

      ctx.beginPath();
      ctx.moveTo(first_x, first_y);
      ctx.bezierCurveTo(first_x + cp_spacing + cps[0].x,
                        first_y + (cps[0].y * params.direction),
                        last_x - cp_spacing + cps[1].x,
                        last_y + (cps[1].y * params.direction),
                        last_x, last_y);
      ctx.bezierCurveTo(last_x - cp_spacing + cps[1].x,
                        last_y + ((cps[1].y + thickness) * params.direction),
                        first_x + cp_spacing + cps[0].x,
                        first_y + ((cps[0].y + thickness) * params.direction),
                        first_x, first_y);
      ctx.stroke();
      ctx.closePath();
      ctx.fill();
    },

    draw: function() {
      if (!this.context)
        throw new Vex.RERR("NoContext", "No context to render tie.");
      var first_note = this.from;
      var last_note = this.to;
      var first_x, last_x, first_y, last_y, stem_direction;

      var metric = "baseY";
      var end_metric = "baseY";
      var position = this.render_options.position;
      var position_end = this.render_options.position_end;

      if (position === Curve.Position.NEAR_TOP) {
        metric = "topY";
        end_metric = "topY";
      }

      if (position_end == Curve.Position.NEAR_HEAD) {
        end_metric = "baseY";
      } else if (position_end == Curve.Position.NEAR_TOP) {
        end_metric = "topY";
      }

      if (first_note) {
        first_x = first_note.getTieRightX();
        stem_direction = first_note.getStemDirection();
        first_y = first_note.getStemExtents()[metric];
      } else {
        first_x = last_note.getStave().getTieStartX();
        first_y = last_note.getStemExtents()[metric];
      }

      if (last_note) {
        last_x = last_note.getTieLeftX();
        stem_direction = last_note.getStemDirection();
        last_y = last_note.getStemExtents()[end_metric];
      } else {
        last_x = first_note.getStave().getTieEndX();
        last_y = first_note.getStemExtents()[end_metric];
      }

      this.renderCurve({
        first_x: first_x,
        last_x: last_x,
        first_y: first_y,
        last_y: last_y,
        direction: stem_direction *
          (this.render_options.invert === true ? -1 : 1)
      });
      return true;
    }
  };

  return Curve;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements `StaveLine` which are simply lines that connect
// two notes. This object is highly configurable, see the `render_options`.
// A simple line is often used for notating glissando articulations, but you
// can format a `StaveLine` with arrows or colors for more pedagogical
// purposes, such as diagrams.
Vex.Flow.StaveLine = (function() {
  function StaveLine(notes) {
    if (arguments.length > 0) this.init(notes);
  }

  // Text Positioning
  StaveLine.TextVerticalPosition = {
    TOP: 1,
    BOTTOM: 2
  };

  StaveLine.TextJustification = {
    LEFT: 1,
    CENTER: 2,
    RIGHT: 3
  };

  // ## Prototype Methods
  StaveLine.prototype = {
    // Initialize the StaveLine with the given `notes`.
    //
    // `notes` is a struct that has:
    //
    //  ```
    //  {
    //    first_note: Note,
    //    last_note: Note,
    //    first_indices: [n1, n2, n3],
    //    last_indices: [n1, n2, n3]
    //  }
    //  ```
    init: function(notes) {
      this.notes = notes;
      this.context = null;

      this.text = "";

      this.font = {
        family: "Arial",
        size: 10,
        weight: ""
      };

      this.render_options = {
        // Space to add to the left or the right
        padding_left: 4,
        padding_right: 3,

        // The width of the line in pixels
        line_width: 1,
        // An array of line/space lengths. Unsupported with Raphael (SVG)
        line_dash: null,
        // Can draw rounded line end, instead of a square. Unsupported with Raphael (SVG)
        rounded_end: true,
        // The color of the line and arrowheads
        color: null,

        // Flags to draw arrows on each end of the line
        draw_start_arrow: false,
        draw_end_arrow: false,

        // The length of the arrowhead sides
        arrowhead_length: 10,
        // The angle of the arrowhead
        arrowhead_angle: Math.PI / 8,

        // The position of the text
        text_position_vertical: StaveLine.TextVerticalPosition.TOP,
        text_justification: StaveLine.TextJustification.CENTER
      };

      this.setNotes(notes);
    },

    // Set the rendering context
    setContext: function(context) { this.context = context; return this; },
    // Set the font for the `StaveLine` text
    setFont: function(font) { this.font = font; return this; },
    // The the annotation for the `StaveLine`
    setText: function(text) { this.text = text; return this; },

    // Set the notes for the `StaveLine`
    setNotes: function(notes) {
      if (!notes.first_note && !notes.last_note)
        throw new Vex.RuntimeError("BadArguments",
            "Notes needs to have either first_note or last_note set.");

      if (!notes.first_indices) notes.first_indices = [0];
      if (!notes.last_indices) notes.last_indices = [0];

      if (notes.first_indices.length != notes.last_indices.length)
        throw new Vex.RuntimeError("BadArguments", "Connected notes must have similar" +
          " index sizes");

      // Success. Lets grab 'em notes.
      this.first_note = notes.first_note;
      this.first_indices = notes.first_indices;
      this.last_note = notes.last_note;
      this.last_indices = notes.last_indices;
      return this;
    },

    // Apply the style of the `StaveLine` to the context
    applyLineStyle: function() {
      if (!this.context) {
        throw new Vex.RERR("NoContext","No context to apply the styling to");
      }

      var render_options = this.render_options;
      var ctx = this.context;

      if (render_options.line_dash) {
        ctx.setLineDash(render_options.line_dash);
      }

      if (render_options.line_width) {
        ctx.setLineWidth(render_options.line_width);
      }

      if (render_options.rounded_end) {
        ctx.setLineCap("round");
      } else {
        ctx.setLineCap("square");
      }
    },

    // Apply the text styling to the context
    applyFontStyle: function() {
      if (!this.context) {
        throw new Vex.RERR("NoContext","No context to apply the styling to");
      }

      var ctx = this.context;

      if (this.font) {
        ctx.setFont(this.font.family, this.font.size, this.font.weight);
      }

      if (this.render_options.color) {
        ctx.setStrokeStyle(this.render_options.color);
        ctx.setFillStyle(this.render_options.color);
      }
    },

    // Renders the `StaveLine` on the context
    draw: function() {
      if (!this.context) {
        throw new Vex.RERR("NoContext", "No context to render StaveLine.");
      }

      var ctx = this.context;
      var first_note = this.first_note;
      var last_note = this.last_note;
      var render_options = this.render_options;

      ctx.save();
      this.applyLineStyle();

      // Cycle through each set of indices and draw lines
      var start_position;
      var end_position;
      this.first_indices.forEach(function(first_index, i) {
        var last_index = this.last_indices[i];

        // Get initial coordinates for the start/end of the line
        start_position = first_note.getModifierStartXY(2, first_index);
        end_position = last_note.getModifierStartXY(1, last_index);
        var upwards_slope = start_position.y > end_position.y;

        // Adjust `x` coordinates for modifiers
        start_position.x += first_note.getMetrics().modRightPx +
                            render_options.padding_left;
        end_position.x -= last_note.getMetrics().modLeftPx +
                          render_options.padding_right;


        // Adjust first `x` coordinates for displacements
        var notehead_width = first_note.getGlyph().head_width;
        var first_displaced = first_note.getKeyProps()[first_index].displaced;
        if (first_displaced && first_note.getStemDirection() === 1) {
          start_position.x += notehead_width + render_options.padding_left;
        }

        // Adjust last `x` coordinates for displacements
        var last_displaced = last_note.getKeyProps()[last_index].displaced;
        if (last_displaced && last_note.getStemDirection() === -1) {
          end_position.x -= notehead_width + render_options.padding_right;
        }

        // Adjust y position better if it's not coming from the center of the note
        start_position.y += upwards_slope ? -3 : 1;
        end_position.y += upwards_slope ? 2 : 0;

        drawArrowLine(ctx, start_position, end_position, this.render_options);

      }, this);

      ctx.restore();

      // Determine the x coordinate where to start the text
      var text_width = ctx.measureText(this.text).width;
      var justification = render_options.text_justification;
      var x = 0;
      if (justification === StaveLine.TextJustification.LEFT) {
        x = start_position.x;
      } else if (justification === StaveLine.TextJustification.CENTER) {
        var delta_x = (end_position.x - start_position.x);
        var center_x = (delta_x / 2 ) + start_position.x;
        x = center_x - (text_width / 2);
      } else if (justification === StaveLine.TextJustification.RIGHT) {
        x = end_position.x  -  text_width;
      }

      // Determine the y value to start the text
      var y;
      var vertical_position = render_options.text_position_vertical;
      if (vertical_position === StaveLine.TextVerticalPosition.TOP) {
        y = first_note.getStave().getYForTopText();
      } else if (vertical_position === StaveLine.TextVerticalPosition.BOTTOM) {
        y = first_note.getStave().getYForBottomText();
      }

      // Draw the text
      ctx.save();
      this.applyFontStyle();
      ctx.fillText(this.text, x, y);
      ctx.restore();

      return this;
    }
  };

  // ## Private Helpers
  // 
  // Attribution: Arrow rendering implementations based off of
  // Patrick Horgan's article, "Drawing lines and arcs with 
  // arrow heads on  HTML5 Canvas"
  // 
  // Draw an arrow head that connects between 3 coordinates
  function drawArrowHead(ctx, x0, y0, x1, y1, x2, y2) {
    // all cases do this.
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.lineTo(x0, y0);
    ctx.closePath();

    ctx.fill();
  }

  // Helper function to draw a line with arrow heads
  function drawArrowLine(ctx, point1, point2, config) {
    var both_arrows = config.draw_start_arrow && config.draw_end_arrow;

    var x1 = point1.x;
    var y1 = point1.y;
    var x2 = point2.x;
    var y2 = point2.y;

    // For ends with arrow we actually want to stop before we get to the arrow
    // so that wide lines won't put a flat end on the arrow.
    var distance = Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
    var ratio = (distance - config.arrowhead_length/3) / distance;
    var end_x, end_y, start_x, start_y;
    if (config.draw_end_arrow || both_arrows) {
      end_x = Math.round(x1 + (x2 - x1) * ratio);
      end_y = Math.round(y1 + (y2 - y1) * ratio);
    } else {
      end_x = x2;
      end_y = y2;
    }

    if (config.draw_start_arrow || both_arrows) {
      start_x = x1 + (x2 - x1) * (1 - ratio);
      start_y = y1 + (y2 - y1) * (1 - ratio);
    } else {
      start_x = x1;
      start_y = y1;
    }

    if (config.color) {
      ctx.setStrokeStyle(config.color);
      ctx.setFillStyle(config.color);
    }

    // Draw the shaft of the arrow
    ctx.beginPath();
    ctx.moveTo(start_x, start_y);
    ctx.lineTo(end_x,end_y);
    ctx.stroke();
    ctx.closePath();

    // calculate the angle of the line
    var line_angle = Math.atan2(y2 - y1, x2 - x1);
    // h is the line length of a side of the arrow head
    var h = Math.abs(config.arrowhead_length / Math.cos(config.arrowhead_angle));

    var angle1, angle2;
    var top_x, top_y;
    var bottom_x, bottom_y;

    if (config.draw_end_arrow || both_arrows) {
      angle1 = line_angle + Math.PI + config.arrowhead_angle;
      top_x = x2 + Math.cos(angle1) * h;
      top_y = y2 + Math.sin(angle1) * h;

      angle2 = line_angle + Math.PI - config.arrowhead_angle;
      bottom_x = x2 + Math.cos(angle2) * h;
      bottom_y = y2 + Math.sin(angle2) * h;

      drawArrowHead(ctx, top_x, top_y, x2, y2, bottom_x, bottom_y);
    }

    if (config.draw_start_arrow || both_arrows) {
      angle1 = line_angle + config.arrowhead_angle;
      top_x = x1 + Math.cos(angle1) * h;
      top_y = y1 + Math.sin(angle1) * h;

      angle2 = line_angle - config.arrowhead_angle;
      bottom_x = x1 + Math.cos(angle2) * h;
      bottom_y = y1 + Math.sin(angle2) * h;

      drawArrowHead(ctx, top_x, top_y, x1, y1, bottom_x, bottom_y);
    }
  }

  return StaveLine;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements the `Crescendo` object which draws crescendos and
// decrescendo dynamics markings. A `Crescendo` is initialized with a
// duration and formatted as part of a `Voice` like any other `Note`
// type in VexFlow. This object would most likely be formatted in a Voice
// with `TextNotes` - which are used to represent other dynamics markings.
Vex.Flow.Crescendo = (function() {
  function Crescendo(note_struct) {
    if (arguments.length > 0) this.init(note_struct);
  }

  // To enable logging for this class. Set `Vex.Flow.Crescendo.DEBUG` to `true`.
  function L() { if (Crescendo.DEBUG) Vex.L("Vex.Flow.Crescendo", arguments); }

  // Private helper to draw the hairpin
  function renderHairpin(ctx, params) {
    var begin_x = params.begin_x;
    var end_x = params.end_x;
    var y = params.y;
    var half_height =  params.height / 2;

    ctx.beginPath();

    if (params.reverse) {
        ctx.moveTo(begin_x, y - half_height);
        ctx.lineTo(end_x,  y);
        ctx.lineTo(begin_x, y + half_height);
    } else {
        ctx.moveTo(end_x,  y - half_height);
        ctx.lineTo(begin_x, y);
        ctx.lineTo(end_x,  y + half_height);
    }

    ctx.stroke();
    ctx.closePath();
  }

  // ## Prototype Methods
  Vex.Inherit(Crescendo, Vex.Flow.Note, {
    // Initialize the crescendo's properties
    init: function(note_struct) {
      Crescendo.superclass.init.call(this, note_struct);

      // Whether the object is a decrescendo
      this.decrescendo = false;

      // The staff line to be placed on
      this.line = note_struct.line || 0;

      // The height at the open end of the cresc/decresc
      this.height = 15;

      Vex.Merge(this.render_options, {
        // Extensions to the length of the crescendo on either side
        extend_left: 0,
        extend_right: 0,
        // Vertical shift
        y_shift: 0
      });
    },

    // Set the line to center the element on
    setLine: function(line) { this.line = line; return this; },

    // Set the full height at the open end
    setHeight: function(height) { this.height = height; return this; },

    // Set whether the sign should be a descresendo by passing a bool
    // to `decresc`
    setDecrescendo: function(decresc) {
      this.decrescendo = decresc;
      return this;
    },

    // Preformat the note
    preFormat: function() { this.preFormatted = true; return this; },

    // Render the Crescendo object onto the canvas
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw Hairpin without a context.");

      var tick_context = this.getTickContext();
      var next_context = Vex.Flow.TickContext.getNextContext(tick_context);

      var begin_x = this.getAbsoluteX();
      var end_x;
      if (next_context) {
        end_x = next_context.getX();
      } else {
        end_x = this.stave.x + this.stave.width;
      }

      var y = this.stave.getYForLine(this.line + (-3)) + 1;

      L("Drawing ",  this.decrescendo ? "decrescendo " : "crescendo ",
        this.height, "x", begin_x - end_x);

      renderHairpin(this.context, {
        begin_x: begin_x - this.render_options.extend_left,
        end_x: end_x + this.render_options.extend_right,
        y: y + this.render_options.y_shift,
        height: this.height,
        reverse: this.decrescendo
      });
    }
  });

  return Crescendo;
})();
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// Author: Cyril Silverman
//
// ## Description
//
// This file implements ornaments as modifiers that can be
// attached to notes. The complete list of ornaments is available in
// `tables.js` under `Vex.Flow.ornamentCodes`.
//
// See `tests/ornament_tests.js` for usage examples.

Vex.Flow.Ornament = (function() {
  function Ornament(type) {
    if (arguments.length > 0) this.init(type);
  }
  Ornament.CATEGORY = "ornaments";

  // Accidental position modifications for each glyph
  var acc_mods = {
    "n": {
      shift_x: 1,
      shift_y_upper:0,
      shift_y_lower:0,
      height: 17
    },
    "#": {
      shift_x: 0,
      shift_y_upper: -2,
      shift_y_lower: -2,
      height: 20
    },
    "b": {
      shift_x: 1,
      shift_y_upper: 0,
      shift_y_lower: 3,
      height: 18
    },
    "##": {
      shift_x: 0,
      shift_y_upper: 0,
      shift_y_lower: 0,
      height: 12,
    },
    "bb": {
      shift_x: 0,
      shift_y_upper: 0,
      shift_y_lower: 4,
      height: 17
    },
    "db": {
      shift_x: -3,
      shift_y_upper: 0,
      shift_y_lower: 4,
      height: 17
    },
    "bbs": {
      shift_x: 0,
      shift_y_upper: 0,
      shift_y_lower: 4,
      height: 17
    },
    "d": {
      shift_x: 0,
      shift_y_upper: 0,
      shift_y_lower: 0,
      height: 17
    },
    "++": {
      shift_x: -2,
      shift_y_upper: -6,
      shift_y_lower: -3,
      height: 22
    },
    "+": {
      shift_x: 1,
      shift_y_upper: -4,
      shift_y_lower: -2,
      height: 20
    }
  };

  // To enable logging for this class. Set `Vex.Flow.Ornament.DEBUG` to `true`.
  function L() { if (Ornament.DEBUG) Vex.L("Vex.Flow.Ornament", arguments); }

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods
  // Arrange ornaments inside `ModifierContext`
  Ornament.format = function(ornaments, state) {
   if (!ornaments || ornaments.length === 0) return false;

    var width = 0;
    for (var i = 0; i < ornaments.length; ++i) {
      var ornament = ornaments[i];
      var increment = 1;
      width = Math.max(ornament.getWidth(), width);

      var type = Vex.Flow.ornamentCodes(ornament.type);

      if (!type.between_lines) increment += 1.5;

      if (ornament.getPosition() === Modifier.Position.ABOVE) {
        ornament.setTextLine(state.top_text_line);
        state.top_text_line += increment;
      } else {
        ornament.setTextLine(state.text_line);
        state.text_line += increment;
      }
    }

    state.left_shift += width / 2;
    state.right_shift += width / 2;
    return true;
  };

  // ## Prototype Methods
  Vex.Inherit(Ornament, Modifier, {
    // Create a new ornament of type `type`, which is an entry in
    // `Vex.Flow.ornamentCodes` in `tables.js`.
    init: function(type) {
      Ornament.superclass.init.call(this);

      this.note = null;
      this.index = null;
      this.type = type;
      this.position = Modifier.Position.ABOVE;
      this.delayed = false;

      this.accidental_upper = "";
      this.accidental_lower = "";

      this.render_options = {
        font_scale: 38
      };

      this.ornament = Vex.Flow.ornamentCodes(this.type);
      if (!this.ornament) throw new Vex.RERR("ArgumentError",
         "Ornament not found: '" + this.type + "'");

      // Default width comes from ornament table.
      this.setWidth(this.ornament.width);
    },

    // Set whether the ornament is to be delayed
    setDelayed: function(delayed) { this.delayed = delayed; return this; },

    // Set the upper accidental for the ornament
    setUpperAccidental: function(acc) {
      this.accidental_upper = acc;
      return this;
    },

    // Set the lower accidental for the ornament
    setLowerAccidental: function(acc) {
      this.accidental_lower = acc;
      return this;
    },

    // Render ornament in position next to note.
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw Ornament without a context.");
      if (!(this.note && (this.index !== null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw Ornament without a note and index.");

      var ctx = this.context;
      var stem_direction = this.note.getStemDirection();
      var stave = this.note.getStave();

      // Get stem extents
      var stem_ext = this.note.getStem().getExtents();
      var top, bottom;
      if (stem_direction === Vex.Flow.StaveNote.STEM_DOWN) {
        top = stem_ext.baseY;
        bottom = stem_ext.topY;
      } else {
        top = stem_ext.topY;
        bottom = stem_ext.baseY;
      }

      // TabNotes don't have stems attached to them. Tab stems are rendered
      // outside the stave.
      var is_tabnote = this.note.getCategory() === 'tabnotes';
      if (is_tabnote) {
        if (this.note.hasStem()){
          if (stem_direction === Vex.Flow.StaveNote.STEM_UP) {
            bottom = stave.getYForBottomText(this.text_line - 2);
          } else if (stem_direction === Vex.Flow.StaveNote.STEM_DOWN ) {
            top = stave.getYForTopText(this.text_line - 1.5);
          }
        } else { // Without a stem
          top = stave.getYForTopText(this.text_line - 1);
          bottom = stave.getYForBottomText(this.text_line - 2);
        }
      }

      var is_on_head = stem_direction === Vex.Flow.StaveNote.STEM_DOWN;
      var spacing = stave.getSpacingBetweenLines();
      var line_spacing = 1;

      // Beamed stems are longer than quarter note stems, adjust accordingly
      if (!is_on_head && this.note.beam) {
        line_spacing += 0.5;
      }

      var total_spacing = spacing * (this.text_line + line_spacing);
      var glyph_y_between_lines = (top - 7) - total_spacing;

      // Get initial coordinates for the modifier position
      var start = this.note.getModifierStartXY(this.position, this.index);
      var glyph_x = start.x + this.ornament.shift_right;
      var glyph_y = Math.min(stave.getYForTopText(this.text_line) - 3, glyph_y_between_lines);
      glyph_y += this.ornament.shift_up + this.y_shift;

      // Ajdust x position if ornament is delayed
      if (this.delayed) {
        glyph_x += this.ornament.width;
        var next_context = Vex.Flow.TickContext.getNextContext(this.note.getTickContext());
        if (next_context) {
          glyph_x += (next_context.getX() - glyph_x) * 0.5;
        } else {
          glyph_x += (stave.x + stave.width - glyph_x) * 0.5;
        }
      }

      var ornament = this;
      function drawAccidental(ctx, code, upper) {
        var accidental = Vex.Flow.accidentalCodes(code);

        var acc_x = glyph_x - 3;
        var acc_y = glyph_y + 2;

        // Special adjustments for trill glyph
        if (upper) {
          acc_y -= mods ? mods.height : 18;
          acc_y +=  ornament.type === "tr" ? -8 : 0;
        } else {
          acc_y +=  ornament.type === "tr" ? -6 : 0;
        }

        // Fine tune position of accidental glyph
        var mods = acc_mods[code];
        if (mods) {
          acc_x += mods.shift_x;
          acc_y += upper ? mods.shift_y_upper : mods.shift_y_lower;
        }

        // Render the glyph
        var scale = ornament.render_options.font_scale/1.3;
        Vex.Flow.renderGlyph(ctx, acc_x, acc_y, scale, accidental.code);

        // If rendered a bottom accidental, increase the y value by the
        // accidental height so that the ornament's glyph is shifted up
        if (!upper) {
          glyph_y -= mods ? mods.height : 18;
        }
      }

      // Draw lower accidental for ornament
      if (this.accidental_lower) {
        drawAccidental(ctx, this.accidental_lower, false, glyph_x, glyph_y);
      }

      L("Rendering ornament: ", this.ornament, glyph_x, glyph_y);
      Vex.Flow.renderGlyph(ctx, glyph_x, glyph_y,
                           this.render_options.font_scale, this.ornament.code);

      // Draw upper accidental for ornament
      if (this.accidental_upper) {
        drawAccidental(ctx, this.accidental_upper, true, glyph_x, glyph_y);
      }

    }
  });

  return Ornament;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements different types of pedal markings. These notation
// elements indicate to the performer when to depress and release the a pedal.
//
// In order to create "Sostenuto", and "una corda" markings, you must set
// custom text for the release/depress pedal markings.
Vex.Flow.PedalMarking = (function() {
  function PedalMarking(type) {
    if (arguments.length > 0) this.init(type);
  }

  // To enable logging for this class. Set `Vex.Flow.PedalMarking.DEBUG` to `true`.
  function L() { if (PedalMarking.DEBUG) Vex.L("Vex.Flow.PedalMarking", arguments); }

  // Glyph data
  PedalMarking.GLYPHS = {
    "pedal_depress": {
      code: "v36",
      x_shift:-10,
      y_shift:0
    },
    "pedal_release": {
      code: "v5d",
      x_shift:-2,
      y_shift:3
    },
  };

  PedalMarking.Styles = {
    TEXT: 1,
    BRACKET: 2,
    MIXED: 3
  };


  // ## Public helpers
  //
  // Create a sustain pedal marking. Returns the defaults PedalMarking.
  // Which uses the traditional "Ped" and "*"" markings.
  PedalMarking.createSustain = function(notes) {
    var pedal = new PedalMarking(notes);
    return pedal;
  };

  // Create a sostenuto pedal marking
  PedalMarking.createSostenuto = function(notes) {
    var pedal = new PedalMarking(notes);
    pedal.setStyle(PedalMarking.Styles.MIXED);
    pedal.setCustomText("Sost. Ped.");
    return pedal;
  };

  // Create an una corda pedal marking
  PedalMarking.createUnaCorda = function(notes){
    var pedal = new PedalMarking(notes);
    pedal.setStyle(PedalMarking.Styles.TEXT);
    pedal.setCustomText("una corda", "tre corda");
    return pedal;
  };

  // ## Prototype Methods
  PedalMarking.prototype =  {
    init: function(notes) {
      this.notes = notes;
      this.style = Vex.Flow.PedalMarking.TEXT;
      this.line = 0;

      // Custom text for the release/depress markings
      this.custom_depress_text = "";
      this.custom_release_text = "";

      this.font = {
        family: "Times New Roman",
        size: 12,
        weight: "italic bold"
      };

      this.render_options = {
        bracket_height: 10,
        text_margin_right: 6,
        bracket_line_width: 1,
        glyph_point_size: 40,
        color: "black"
      };
    },

    // Set custom text for the `depress`/`release` pedal markings. No text is
    // set if the parameter is falsy.
    setCustomText: function(depress, release) {
      this.custom_depress_text = depress || "";
      this.custom_release_text = release || "";
      return this;
    },

    // Set the pedal marking style
    setStyle: function(style){
      if (style < 1 && style > 3)  {
        throw new Vex.RERR("InvalidParameter",
          "The style must be one found in PedalMarking.Styles");
      }

      this.style = style;
      return this;
    },

    // Set the staff line to render the markings on
    setLine: function(line) { this.line = line; return this; },

    // Set the rendering context
    setContext: function(context) { this.context = context; return this; },

    // Draw the bracket based pedal markings
    drawBracketed: function() {
      var ctx = this.context;
      var is_pedal_depressed = false;
      var prev_x;
      var prev_y;
      var pedal = this;

      // Iterate through each note
      this.notes.forEach(function(note, index, notes) {
        // Each note triggers the opposite pedal action
        is_pedal_depressed = !is_pedal_depressed;

        // Get the initial coordinates for the note
        var x = note.getAbsoluteX();
        var y = note.getStave().getYForBottomText(pedal.line + 3);

        // Throw if current note is positioned before the previous note
        if (x < prev_x) throw new Vex.RERR('InvalidConfiguration',
          'The notes provided must be in order of ascending x positions');

        // Determine if the previous or next note are the same
        // as the current note. We need to keep track of this for
        // when adjustments are made for the release+depress action
        var next_is_same = notes[index+1] === note;
        var prev_is_same = notes[index-1] === note;

        var x_shift = 0;
        if (is_pedal_depressed) {
          // Adjustment for release+depress
          x_shift =  prev_is_same ? 5 : 0;

          if (pedal.style === PedalMarking.Styles.MIXED && !prev_is_same) {
            // For MIXED style, start with text instead of bracket
            if (pedal.custom_depress_text) {
              // If we have custom text, use instead of the default "Ped" glyph
              var text_width = ctx.measureText(pedal.custom_depress_text).width;
              ctx.fillText(pedal.custom_depress_text, x - (text_width/2), y);
              x_shift = (text_width / 2) + pedal.render_options.text_margin_right;
            } else {
              // Render the Ped glyph in position
              drawPedalGlyph('pedal_depress', ctx, x, y, pedal.render_options.glyph_point_size);
              x_shift = 20 + pedal.render_options.text_margin_right;
            }
          } else {
            // Draw start bracket
            ctx.beginPath();
            ctx.moveTo(x, y - pedal.render_options.bracket_height);
            ctx.lineTo(x + x_shift, y);
            ctx.stroke();
            ctx.closePath();
          }
        } else {
          // Adjustment for release+depress
          x_shift = next_is_same ? -5 : 0;

          // Draw end bracket
          ctx.beginPath();
          ctx.moveTo(prev_x, prev_y);
          ctx.lineTo(x + x_shift, y);
          ctx.lineTo(x, y - pedal.render_options.bracket_height);
          ctx.stroke();
          ctx.closePath();
        }

        // Store previous coordinates
        prev_x = x + x_shift;
        prev_y = y;
      });
    },

    // Draw the text based pedal markings. This defaults to the traditional
    // "Ped" and "*"" symbols if no custom text has been provided.
    drawText: function() {
      var ctx = this.context;
      var is_pedal_depressed = false;
      var pedal = this;

      // The glyph point size
      var point = pedal.render_options.glyph_point_size;

      // Iterate through each note, placing glyphs or custom text accordingly
      this.notes.forEach(function(note) {
        is_pedal_depressed = !is_pedal_depressed;
        var stave = note.getStave();
        var x = note.getAbsoluteX();
        var y = stave.getYForBottomText(pedal.line + 3);

        var text_width = 0;
        if (is_pedal_depressed) {
          if (pedal.custom_depress_text) {
            text_width = ctx.measureText(pedal.custom_depress_text).width;
            ctx.fillText(pedal.custom_depress_text, x - (text_width/2), y);
          } else {
            drawPedalGlyph("pedal_depress", ctx, x, y, point);
          }
        } else {
          if (pedal.custom_release_text) {
            text_width = ctx.measureText(pedal.custom_release_text).width;
            ctx.fillText(pedal.custom_release_text, x - (text_width/2), y);
          } else {
            drawPedalGlyph("pedal_release", ctx, x, y, point);
          }
        }
      });
    },

    // Render the pedal marking in position on the rendering context 
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw PedalMarking without a context.");
      var ctx = this.context;

      ctx.save();
      ctx.setStrokeStyle(this.render_options.color);
      ctx.setFillStyle(this.render_options.color);
      ctx.setFont(this.font.family, this.font.size, this.font.weight);

      L("Rendering Pedal Marking");

      if (this.style === PedalMarking.Styles.BRACKET ||
          this.style === PedalMarking.Styles.MIXED) {
        ctx.setLineWidth(this.render_options.bracket_line_width);
        this.drawBracketed();
      } else if (this.style === Vex.Flow.PedalMarking.Styles.TEXT) {
        this.drawText();
      }

      ctx.restore();
    }
  };

  // ## Private Helper
  // 
  // Draws a pedal glyph with the provided `name` on a rendering `context` 
  // at the coordinates `x` and `y. Takes into account the glyph data
  // coordinate shifts.
  function drawPedalGlyph(name, context, x, y, point) {
    var glyph_data = PedalMarking.GLYPHS[name];
    var glyph = new Vex.Flow.Glyph(glyph_data.code, point);
    glyph.render(context, x + glyph_data.x_shift, y + glyph_data.y_shift);
  }

  return PedalMarking;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// Author: Cyril Silverman
//
// ## Description
//
// This file implement `TextBrackets` which extend between two notes.
// The octave transposition markings (8va, 8vb, 15va, 15vb) can be created
// using this class.
//
Vex.Flow.TextBracket = (function() {
  function TextBracket(bracket_data) {
    if (arguments.length > 0) this.init(bracket_data);
  }

  // To enable logging for this class. Set `Vex.Flow.TextBracket.DEBUG` to `true`.
  function L() { if (TextBracket.DEBUG) Vex.L("Vex.Flow.TextBracket", arguments); }

  TextBracket.Positions = {
    TOP: 1,
    BOTTOM: -1
  };

  // ## Prototype Methods
  TextBracket.prototype =  {
    init: function(bracket_data) {
      this.start = bracket_data.start;
      this.stop = bracket_data.stop;

      this.text = bracket_data.text || "";
      this.superscript = bracket_data.superscript || "";

      this.position = bracket_data.position || TextBracket.Positions.TOP;
      this.line = 1;

      this.font = {
        family: "Serif",
        size: 15,
        weight: "italic"
      };

      this.render_options = {
        dashed: true,
        dash: [5],
        color: "black",
        line_width: 1,
        show_bracket: true,
        bracket_height: 8,

        // In the BOTTOM position, the bracket line can extend
        // under the superscript.
        underline_superscript: true
      };
    },

    // Apply the text backet styling to the provided `context`
    applyStyle: function(context) {
      // Apply style for the octave bracket
      context.setFont(this.font.family, this.font.size, this.font.weight);
      context.setStrokeStyle(this.render_options.color);
      context.setFillStyle(this.render_options.color);
      context.setLineWidth(this.render_options.line_width);

      return this;
    },

    // Set whether the bracket line should be `dashed`. You can also
    // optionally set the `dash` pattern by passing in an array of numbers
    setDashed: function(dashed, dash) {
      this.render_options.dashed = dashed;
      if (dash) this.render_options.dash = dash;
      return this;
    },

    // Set the font for the text
    setFont: function(font) { this.font = font; return this; },
    // Set the rendering `context` for the octave bracket
    setContext: function(context) { this.context = context; return this; },
    // Set the staff line to render the bracket on
    setLine: function(line) { this.line = line; return this; },

    // Draw the octave bracket on the rendering context
    draw: function() {
      var ctx = this.context;

      var y = 0;
      switch(this.position) {
        case TextBracket.Positions.TOP:
          y =  this.start.getStave().getYForTopText(this.line);
          break;
        case TextBracket.Positions.BOTTOM:
          y =  this.start.getStave().getYForBottomText(this.line);
          break;
      }

      // Get the preliminary start and stop coordintates for the bracket
      var start = { x: this.start.getAbsoluteX(), y: y};
      var stop = { x: this.stop.getAbsoluteX(), y: y };

      L("Rendering TextBracket: start:", start, "stop:", stop, "y:", y);

      var bracket_height = this.render_options.bracket_height * this.position;

      ctx.save();
      this.applyStyle(ctx);

      // Draw text
      ctx.fillText(this.text, start.x, start.y);

      // Get the width and height for the octave number
      var main_width = ctx.measureText(this.text).width;
      var main_height = ctx.measureText("M").width;

      // Calculate the y position for the super script
      var super_y = start.y - (main_height/2.5);

      // Draw the superscript
      ctx.setFont(this.font.family, this.font.size / 1.4, this.font.weight);
      ctx.fillText(this.superscript, start.x + main_width + 1, super_y);


      // Determine width and height of the superscript
      var superscript_width = ctx.measureText(this.superscript).width;
      var super_height = ctx.measureText("M").width;

      // Setup initial coordinates for the bracket line
      var start_x = start.x;
      var line_y = super_y;
      var end_x = stop.x + this.stop.getGlyph().head_width;

      // Adjust x and y coordinates based on position
      if (this.position === TextBracket.Positions.TOP) {
        start_x += main_width + superscript_width + 5;
        line_y -= super_height/2.7;
      } else if (this.position === TextBracket.Positions.BOTTOM) {
        line_y += super_height/2.7;
        start_x += main_width + 2;

        if (!this.render_options.underline_superscript) {
          start_x += superscript_width;
        }
      }

      if (this.render_options.dashed) {
        // Main line
        Vex.Flow.Renderer.drawDashedLine(ctx, start_x, line_y, end_x, line_y,
          this.render_options.dash);
        // Ending Bracket
        if (this.render_options.show_bracket) {
          Vex.Flow.Renderer.drawDashedLine(ctx, end_x, line_y + (1 * this.position),
            end_x, line_y + bracket_height, this.render_options.dash);
        }
      } else {
        ctx.beginPath();
        ctx.moveTo(start_x, line_y);
        // Main line
        ctx.lineTo(end_x, line_y);
        if (this.render_options.show_bracket) {
          // Ending bracket
          ctx.lineTo(end_x, line_y + bracket_height);
        }
        ctx.stroke();
        ctx.closePath();
      }

      ctx.restore();
    }
  };

  return TextBracket;
})();
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements the `TextDynamics` which renders traditional
// text dynamics markings, **ie: p, f, sfz, rfz, ppp**
//
// You can render any dynamics string that contains a combination of
// the following letters:  P, M, F, Z, R, S
Vex.Flow.TextDynamics = (function(){
  function TextDynamics(text_struct) {
    if (arguments.length > 0) this.init(text_struct);
  }

  // To enable logging for this class. Set `Vex.Flow.TextDynamics.DEBUG` to `true`.
  function L() { if (TextDynamics.DEBUG) Vex.L("Vex.Flow.TextDynamics", arguments); }

  // The glyph data for each dynamics letter
  TextDynamics.GLYPHS = {
    "f": {
      code: "vba",
      width: 12
    },
    "p": {
      code: "vbf",
      width: 14
    },
    "m": {
      code: "v62",
      width: 17
    },
    "s": {
      code: "v4a",
      width: 10
    },
    "z": {
      code: "v80",
      width: 12
    },
    "r": {
      code: "vb1",
      width: 12
    }
  };

  // ## Prototype Methods
  //
  // A `TextDynamics` object inherits from `Note` so that it can be formatted
  // within a `Voice`.
  Vex.Inherit(TextDynamics, Vex.Flow.Note, {
    // Create the dynamics marking. `text_struct` is an object
    // that contains a `duration` property and a `sequence` of
    // letters that represents the letters to render
    init: function(text_struct) {
      TextDynamics.superclass.init.call(this, text_struct);

      this.sequence = text_struct.text.toLowerCase();
      this.line = text_struct.line || 0;
      this.glyphs = [];

      Vex.Merge(this.render_options, {
        glyph_font_size: 40
      });

      L("New Dynamics Text: ", this.sequence);
    },

    // Set the Stave line on which the note should be placed
    setLine: function(line) { this.line = line;  return this; },

    // Preformat the dynamics text
    preFormat: function() {
      var total_width = 0;
      // Iterate through each letter
      this.sequence.split('').forEach(function(letter) {
        // Get the glyph data for the letter
        var glyph_data = TextDynamics.GLYPHS[letter];
        if (!glyph_data) throw new Vex.RERR("Invalid dynamics character: " + letter);

        var size =  this.render_options.glyph_font_size;
        var glyph = new Vex.Flow.Glyph(glyph_data.code, size);

        // Add the glyph
        this.glyphs.push(glyph);

        total_width += glyph_data.width;
      }, this);

      // Store the width of the text
      this.setWidth(total_width);
      this.preFormatted = true;
      return this;
    },

    // Draw the dynamics text on the rendering context
    draw: function() {
      var x = this.getAbsoluteX();
      var y = this.stave.getYForLine(this.line + (-3));

      L("Rendering Dynamics: ", this.sequence);

      var letter_x = x;
      this.glyphs.forEach(function(glyph, index) {
        var current_letter = this.sequence[index];
        glyph.render(this.context, letter_x, y);
        letter_x += TextDynamics.GLYPHS[current_letter].width;
      }, this);
    }
  });

  return TextDynamics;
})();
Vex.Flow.GraceNote = (function() {
  var GraceNote = function(note_struct) {
    if (arguments.length > 0) this.init(note_struct);
  };

  Vex.Inherit(GraceNote, Vex.Flow.StaveNote, {
    init: function(note_struct) {
      GraceNote.superclass.init.call(this, note_struct);

      this.render_options.glyph_font_scale = 22;
      this.render_options.stem_height = 20;
      this.render_options.stroke_px = 2;
      this.glyph.head_width = 6;

      this.slash = note_struct.slash;
      this.slur = true;

      this.buildNoteHeads();

      this.width = 3;
    },

    getStemExtension: function(){
      var glyph = this.getGlyph();

      if (this.stem_extension_override != null) {
        return this.stem_extension_override;
      }

      if (glyph) {
        return this.getStemDirection() === 1 ? glyph.gracenote_stem_up_extension :
          glyph.gracenote_stem_down_extension;
      }

      return 0;
    },

    getCategory: function() { return 'gracenotes'; },

    draw: function(){
      GraceNote.superclass.draw.call(this);
      var ctx = this.context;
      var stem_direction = this.getStemDirection();

      if (this.slash) {
        ctx.beginPath();

        var x = this.getAbsoluteX();
        var y = this.getYs()[0] - (this.stem.getHeight() / 2.8);
        if (stem_direction === 1) {
          x += 1;
          ctx.moveTo(x, y);
          ctx.lineTo(x + 13, y - 9);
        } else if (stem_direction === -1) {
          x -= 4;
          y += 1;
          ctx.moveTo(x, y);
          ctx.lineTo(x + 13, y + 9);
        }

        ctx.closePath();
        ctx.stroke();
      }
    }
  });

  return GraceNote;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements `GraceNoteGroup` which is used to format and
// render grace notes.

Vex.Flow.GraceNoteGroup = (function(){
  function GraceNoteGroup(grace_notes, config) {
    if (arguments.length > 0) this.init(grace_notes, config);
  }

  GraceNoteGroup.CATEGORY = "gracenotegroups";

  // To enable logging for this class. Set `Vex.Flow.GraceNoteGroup.DEBUG` to `true`.
  function L() { if (GraceNoteGroup.DEBUG) Vex.L("Vex.Flow.GraceNoteGroup", arguments); }

  // Arrange groups inside a `ModifierContext`
  GraceNoteGroup.format = function(gracenote_groups, state) {
    var gracenote_spacing = 4;

    if (!gracenote_groups || gracenote_groups.length === 0) return false;

    var group_list = [];
    var hasStave = false;
    var prev_note = null;
    var shiftL = 0;

    var i, gracenote_group, props_tmp;
    for (i = 0; i < gracenote_groups.length; ++i) {
      gracenote_group = gracenote_groups[i];
      var note = gracenote_group.getNote();
      var stave = note.getStave();
      if (note != prev_note) {
         // Iterate through all notes to get the displaced pixels
         for (var n = 0; n < note.keys.length; ++n) {
            props_tmp = note.getKeyProps()[n];
            shiftL = (props_tmp.displaced ? note.getExtraLeftPx() : shiftL);
          }
          prev_note = note;
      }
      if (stave != null) {
        hasStave = true;
        group_list.push({shift: shiftL, gracenote_group: gracenote_group});
      } else {
        group_list.push({shift: shiftL, gracenote_group: gracenote_group });
      }
    }

    // If first note left shift in case it is displaced
    var group_shift = group_list[0].shift;
    var formatWidth;
    for (i = 0; i < group_list.length; ++i) {
      gracenote_group = group_list[i].gracenote_group;
      gracenote_group.preFormat();
      formatWidth = gracenote_group.getWidth() + gracenote_spacing;
      group_shift = Math.max(formatWidth, group_shift);
    }

    for (i = 0; i < group_list.length; ++i) {
      gracenote_group = group_list[i].gracenote_group;
      formatWidth = gracenote_group.getWidth() + gracenote_spacing;
      gracenote_group.setSpacingFromNextModifier(group_shift - Math.min(formatWidth, group_shift));
    }

    state.left_shift += group_shift;
    return true;
  };

  // ## Prototype Methods
  //
  // `GraceNoteGroup` inherits from `Modifier` and is placed inside a
  // `ModifierContext`.
  Vex.Inherit(GraceNoteGroup, Vex.Flow.Modifier, {
    init: function(grace_notes, show_slur) {
      var superclass = GraceNoteGroup.superclass;
      superclass.init.call(this);

      this.note = null;
      this.index = null;
      this.position = Vex.Flow.Modifier.Position.LEFT;
      this.grace_notes = grace_notes;
      this.width = 0;

      this.preFormatted = false;

      this.show_slur = show_slur;
      this.slur = null;

      this.formatter = new Vex.Flow.Formatter();
      this.voice = new Vex.Flow.Voice({
        num_beats: 4,
        beat_value: 4,
        resolution: Vex.Flow.RESOLUTION
      }).setStrict(false);

      this.voice.addTickables(this.grace_notes);

      return this;
    },

    preFormat: function(){
      if (this.preFormatted) return;

      this.formatter.joinVoices([this.voice]).format([this.voice], 0);
      this.setWidth(this.formatter.getMinTotalWidth());
      this.preFormatted = true;
    },

    beamNotes: function(){
      if (this.grace_notes.length > 1) {
        var beam = new Vex.Flow.Beam(this.grace_notes);

        beam.render_options.beam_width = 3;
        beam.render_options.partial_beam_length = 4;

        this.beam = beam;
      }

      return this;
    },

    setNote: function(note) {
      this.note = note;
    },
    setWidth: function(width){
      this.width = width;
    },
    getWidth: function(){
      return this.width;
    },
    draw: function() {
      if (!this.context)  {
        throw new Vex.RuntimeError("NoContext",
          "Can't draw Grace note without a context.");
      }

      var note = this.getNote();

      L("Drawing grace note group for:", note);

      if (!(note && (this.index !== null))) {
        throw new Vex.RuntimeError("NoAttachedNote",
          "Can't draw grace note without a parent note and parent note index.");
      }

      var that = this;
      function alignGraceNotesWithNote(grace_notes, note, groupWidth) {
        // Shift over the tick contexts of each note
        // So that th aligned with the note
        var tickContext = note.getTickContext();
        var extraPx = tickContext.getExtraPx();
        var x = tickContext.getX() - extraPx.left - extraPx.extraLeft + that.getSpacingFromNextModifier();
        grace_notes.forEach(function(graceNote) {
            var tick_context = graceNote.getTickContext();
            var x_offset = tick_context.getX();
            graceNote.setStave(note.stave);
            tick_context.setX(x + x_offset);
        });
      }

      alignGraceNotesWithNote(this.grace_notes, note, this.width);

      // Draw notes
      this.grace_notes.forEach(function(graceNote) {
        graceNote.setContext(this.context).draw();
      }, this);

      // Draw beam
      if (this.beam) {
        this.beam.setContext(this.context).draw();
      }

      if (this.show_slur) {
        // Create and draw slur
        this.slur = new Vex.Flow.StaveTie({
          last_note: this.grace_notes[0],
          first_note: note,
          first_indices: [0],
          last_indices: [0]
        });

        this.slur.render_options.cp2 = 12;
        this.slur.setContext(this.context).draw();
      }
    }
  });

return GraceNoteGroup;
}());

},{}],9:[function(require,module,exports){
var Artist, Vex, _,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Vex = require('vexflow');

_ = require('underscore');

Artist = (function() {
  var L, formatAndRender, getFingering, getScoreArticulationParts, getStrokeParts, makeBend, makeDuration, parseBool;

  Artist.DEBUG = false;

  L = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (Artist.DEBUG) {
      return typeof console !== "undefined" && console !== null ? console.log.apply(console, ["(Vex.Flow.Artist)"].concat(slice.call(args))) : void 0;
    }
  };

  Artist.NOLOGO = false;

  function Artist(x, y, width1, options) {
    this.x = x;
    this.y = y;
    this.width = width1;
    this.options = {
      font_face: "Arial",
      font_size: 10,
      font_style: null,
      bottom_spacing: 20 + (Artist.NOLOGO ? 0 : 10),
      tab_stave_lower_spacing: 10,
      note_stave_lower_spacing: 0,
      scale: 1.0
    };
    if (options != null) {
      _.extend(this.options, options);
    }
    this.reset();
  }

  Artist.prototype.reset = function() {
    this.tuning = new Vex.Flow.Tuning();
    this.key_manager = new Vex.Flow.KeyManager("C");
    this.music_api = new Vex.Flow.Music();
    this.customizations = {
      "font-size": this.options.font_size,
      "font-face": this.options.font_face,
      "font-style": this.options.font_style,
      "annotation-position": "bottom",
      "scale": this.options.scale,
      "width": this.width,
      "stave-distance": 0,
      "space": 0,
      "player": "false",
      "tempo": 120,
      "instrument": "acoustic_grand_piano",
      "accidentals": "standard",
      "tab-stems": "false",
      "tab-stem-direction": "up",
      "beam-rests": "true",
      "beam-stemlets": "true",
      "beam-middle-only": "false",
      "connector-space": 0
    };
    this.staves = [];
    this.tab_articulations = [];
    this.stave_articulations = [];
    this.player_voices = [];
    this.last_y = this.y;
    this.current_duration = "q";
    this.current_clef = "treble";
    this.current_bends = {};
    this.current_octave_shift = 0;
    this.bend_start_index = null;
    this.bend_start_strings = null;
    this.rendered = false;
    return this.renderer_context = null;
  };

  Artist.prototype.attachPlayer = function(player) {
    if (!this.player) {
      console.log("Attaching player");
      return this.player = player;
    }
  };

  Artist.prototype.setOptions = function(options) {
    var k, v, valid_options;
    L("setOptions: ", options);
    valid_options = _.keys(this.customizations);
    for (k in options) {
      v = options[k];
      if (indexOf.call(valid_options, k) >= 0) {
        this.customizations[k] = v;
      } else {
        throw new Vex.RERR("ArtistError", "Invalid option '" + k + "'");
      }
    }
    this.last_y += parseInt(this.customizations.space, 10);
    if (this.customizations.player === "true") {
      return this.last_y += 1;
    }
  };

  Artist.prototype.getPlayerData = function() {
    return {
      voices: this.player_voices,
      context: this.renderer_context,
      scale: this.customizations.scale
    };
  };

  parseBool = function(str) {
    return str === "true";
  };

  formatAndRender = function(ctx, tab, score, text_notes, customizations, options) {
    var align_rests, beam_config, beams, format_stave, format_voices, formatter, i, j, l, len, len1, len2, m, multi_voice, notes, ref, ref1, score_stave, score_voices, stem_direction, tab_stave, tab_voices, text_stave, text_voices, voice;
    if (tab != null) {
      tab_stave = tab.stave;
    }
    if (score != null) {
      score_stave = score.stave;
    }
    tab_voices = [];
    score_voices = [];
    text_voices = [];
    beams = [];
    format_stave = null;
    text_stave = null;
    beam_config = {
      beam_rests: parseBool(customizations["beam-rests"]),
      show_stemlets: parseBool(customizations["beam-stemlets"]),
      beam_middle_only: parseBool(customizations["beam-middle-only"]),
      groups: options.beam_groups
    };
    if (tab != null) {
      multi_voice = tab.voices.length > 1 ? true : false;
      ref = tab.voices;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        notes = ref[i];
        if (_.isEmpty(notes)) {
          continue;
        }
        _.each(notes, function(note) {
          return note.setStave(tab_stave);
        });
        voice = new Vex.Flow.Voice(Vex.Flow.TIME4_4).setMode(Vex.Flow.Voice.Mode.SOFT);
        voice.addTickables(notes);
        tab_voices.push(voice);
        if (customizations["tab-stems"] === "true") {
          if (multi_voice) {
            beam_config.stem_direction = i === 0 ? 1 : -1;
          } else {
            beam_config.stem_direction = customizations["tab-stem-direction"] === "down" ? -1 : 1;
          }
          beam_config.beam_rests = false;
          beams = beams.concat(Vex.Flow.Beam.generateBeams(voice.getTickables(), beam_config));
        }
      }
      format_stave = tab_stave;
      text_stave = tab_stave;
    }
    beam_config.beam_rests = parseBool(customizations["beam-rests"]);
    if (score != null) {
      multi_voice = score.voices.length > 1 ? true : false;
      ref1 = score.voices;
      for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
        notes = ref1[i];
        if (_.isEmpty(notes)) {
          continue;
        }
        stem_direction = i === 0 ? 1 : -1;
        _.each(notes, function(note) {
          return note.setStave(score_stave);
        });
        voice = new Vex.Flow.Voice(Vex.Flow.TIME4_4).setMode(Vex.Flow.Voice.Mode.SOFT);
        voice.addTickables(notes);
        score_voices.push(voice);
        if (multi_voice) {
          beam_config.stem_direction = stem_direction;
          beams = beams.concat(Vex.Flow.Beam.generateBeams(notes, beam_config));
        } else {
          beam_config.stem_direction = null;
          beams = beams.concat(Vex.Flow.Beam.generateBeams(notes, beam_config));
        }
      }
      format_stave = score_stave;
      text_stave = score_stave;
    }
    for (m = 0, len2 = text_notes.length; m < len2; m++) {
      notes = text_notes[m];
      if (_.isEmpty(notes)) {
        continue;
      }
      _.each(notes, function(voice) {
        return voice.setStave(text_stave);
      });
      voice = new Vex.Flow.Voice(Vex.Flow.TIME4_4).setMode(Vex.Flow.Voice.Mode.SOFT);
      voice.addTickables(notes);
      text_voices.push(voice);
    }
    if (format_stave != null) {
      format_voices = [];
      formatter = new Vex.Flow.Formatter();
      align_rests = false;
      if (tab != null) {
        if (!_.isEmpty(tab_voices)) {
          formatter.joinVoices(tab_voices);
        }
        format_voices = tab_voices;
      }
      if (score != null) {
        if (!_.isEmpty(score_voices)) {
          formatter.joinVoices(score_voices);
        }
        format_voices = format_voices.concat(score_voices);
        if (score_voices.length > 1) {
          align_rests = true;
        }
      }
      if (!_.isEmpty(text_notes) && !_.isEmpty(text_voices)) {
        formatter.joinVoices(text_voices);
        format_voices = format_voices.concat(text_voices);
      }
      if (!_.isEmpty(format_voices)) {
        formatter.formatToStave(format_voices, format_stave, {
          align_rests: align_rests
        });
      }
      if (tab != null) {
        _.each(tab_voices, function(voice) {
          return voice.draw(ctx, tab_stave);
        });
      }
      if (score != null) {
        _.each(score_voices, function(voice) {
          return voice.draw(ctx, score_stave);
        });
      }
      _.each(beams, function(beam) {
        return beam.setContext(ctx).draw();
      });
      if (!_.isEmpty(text_notes)) {
        _.each(text_voices, function(voice) {
          return voice.draw(ctx, text_stave);
        });
      }
      if ((tab != null) && (score != null)) {
        (new Vex.Flow.StaveConnector(score.stave, tab.stave)).setContext(ctx).draw();
      }
      if (score != null) {
        return score_voices;
      } else {
        return tab_voices;
      }
    }
  };

  Artist.prototype.render = function(renderer) {
    var LOGO, articulation, ctx, j, l, len, len1, len2, m, ref, ref1, ref2, setBar, stave, voices, width;
    L("Render: ", this.options);
    this.closeBends();
    renderer.resize(this.customizations.width * this.customizations.scale, (this.last_y + this.options.bottom_spacing) * this.customizations.scale);
    ctx = renderer.getContext();
    ctx.scale(this.customizations.scale, this.customizations.scale);
    ctx.clear();
    ctx.setFont(this.options.font_face, this.options.font_size, "");
    this.renderer_context = ctx;
    setBar = function(stave, notes) {
      var last_note;
      last_note = _.last(notes);
      if (last_note instanceof Vex.Flow.BarNote) {
        notes.pop();
        return stave.setEndBarType(last_note.getType());
      }
    };
    ref = this.staves;
    for (j = 0, len = ref.length; j < len; j++) {
      stave = ref[j];
      L("Rendering staves.");
      if (stave.tab != null) {
        setBar(stave.tab, stave.tab_notes);
      }
      if (stave.note != null) {
        setBar(stave.note, stave.note_notes);
      }
      if (stave.tab != null) {
        stave.tab.setContext(ctx).draw();
      }
      if (stave.note != null) {
        stave.note.setContext(ctx).draw();
      }
      stave.tab_voices.push(stave.tab_notes);
      stave.note_voices.push(stave.note_notes);
      voices = formatAndRender(ctx, stave.tab != null ? {
        stave: stave.tab,
        voices: stave.tab_voices
      } : null, stave.note != null ? {
        stave: stave.note,
        voices: stave.note_voices
      } : null, stave.text_voices, this.customizations, {
        beam_groups: stave.beam_groups
      });
      this.player_voices.push(voices);
    }
    L("Rendering tab articulations.");
    ref1 = this.tab_articulations;
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      articulation = ref1[l];
      articulation.setContext(ctx).draw();
    }
    L("Rendering note articulations.");
    ref2 = this.stave_articulations;
    for (m = 0, len2 = ref2.length; m < len2; m++) {
      articulation = ref2[m];
      articulation.setContext(ctx).draw();
    }
    if (this.player != null) {
      if (this.customizations.player === "true") {
        this.player.setTempo(parseInt(this.customizations.tempo, 10));
        this.player.setInstrument(this.customizations.instrument);
        this.player.render();
      } else {
        this.player.removeControls();
      }
    }
    this.rendered = true;
    if (!Artist.NOLOGO) {
      LOGO = "vexflow.com";
      width = ctx.measureText(LOGO).width;
      ctx.save();
      ctx.setFont("Times", 10, "italic");
      ctx.fillText(LOGO, (this.customizations.width - width) / 2, this.last_y + 25);
      return ctx.restore();
    }
  };

  Artist.prototype.isRendered = function() {
    return this.rendered;
  };

  Artist.prototype.draw = function(renderer) {
    return this.render(renderer);
  };

  Artist.prototype.getNoteForFret = function(fret, string) {
    var accidental, new_note, new_octave, new_root, old_root, selected_note, spec, spec_props;
    spec = this.tuning.getNoteForFret(fret, string);
    spec_props = Vex.Flow.keyProperties(spec);
    selected_note = this.key_manager.selectNote(spec_props.key);
    accidental = null;
    switch (this.customizations.accidentals) {
      case "standard":
        if (selected_note.change) {
          accidental = selected_note.accidental != null ? selected_note.accidental : "n";
        }
        break;
      case "cautionary":
        if (selected_note.change) {
          accidental = selected_note.accidental != null ? selected_note.accidental : "n";
        } else {
          accidental = selected_note.accidental != null ? selected_note.accidental + "_c" : void 0;
        }
        break;
      default:
        throw new Vex.RERR("ArtistError", "Invalid value for option 'accidentals': " + this.customizations.accidentals);
    }
    new_note = selected_note.note;
    new_octave = spec_props.octave;
    old_root = this.music_api.getNoteParts(spec_props.key).root;
    new_root = this.music_api.getNoteParts(selected_note.note).root;
    if (new_root === "b" && old_root === "c") {
      new_octave--;
    } else if (new_root === "c" && old_root === "b") {
      new_octave++;
    }
    return [new_note, new_octave, accidental];
  };

  Artist.prototype.getNoteForABC = function(abc, string) {
    var accidental, key, octave;
    key = abc.key;
    octave = string;
    accidental = abc.accidental;
    if (abc.accidental_type != null) {
      accidental += "_" + abc.accidental_type;
    }
    return [key, octave, accidental];
  };

  Artist.prototype.addStaveNote = function(note_params) {
    var acc, index, j, len, new_accidental, params, parts, ref, stave_note, stave_notes;
    params = {
      is_rest: false,
      play_note: null
    };
    _.extend(params, note_params);
    stave_notes = _.last(this.staves).note_notes;
    stave_note = new Vex.Flow.StaveNote({
      keys: params.spec,
      duration: this.current_duration + (params.is_rest ? "r" : ""),
      clef: params.is_rest ? "treble" : this.current_clef,
      auto_stem: params.is_rest ? false : true
    });
    ref = params.accidentals;
    for (index = j = 0, len = ref.length; j < len; index = ++j) {
      acc = ref[index];
      if (acc != null) {
        parts = acc.split("_");
        new_accidental = new Vex.Flow.Accidental(parts[0]);
        if (parts.length > 1 && parts[1] === "c") {
          new_accidental.setAsCautionary();
        }
        stave_note.addAccidental(index, new_accidental);
      }
    }
    if (this.current_duration[this.current_duration.length - 1] === "d") {
      stave_note.addDotToAll();
    }
    if (params.play_note != null) {
      stave_note.setPlayNote(params.play_note);
    }
    return stave_notes.push(stave_note);
  };

  Artist.prototype.addTabNote = function(spec, play_note) {
    var new_tab_note, tab_notes;
    if (play_note == null) {
      play_note = null;
    }
    tab_notes = _.last(this.staves).tab_notes;
    new_tab_note = new Vex.Flow.TabNote({
      positions: spec,
      duration: this.current_duration
    }, this.customizations["tab-stems"] === "true");
    if (play_note != null) {
      new_tab_note.setPlayNote(play_note);
    }
    tab_notes.push(new_tab_note);
    if (this.current_duration[this.current_duration.length - 1] === "d") {
      return new_tab_note.addDot();
    }
  };

  makeDuration = function(time, dot) {
    return time + (dot ? "d" : "");
  };

  Artist.prototype.setDuration = function(time, dot) {
    var t;
    if (dot == null) {
      dot = false;
    }
    t = time.split(/\s+/);
    L("setDuration: ", t[0], dot);
    return this.current_duration = makeDuration(t[0], dot);
  };

  Artist.prototype.addBar = function(type) {
    var TYPE, bar_note, stave;
    L("addBar: ", type);
    this.closeBends();
    this.key_manager.reset();
    stave = _.last(this.staves);
    TYPE = Vex.Flow.Barline.type;
    type = (function() {
      switch (type) {
        case "single":
          return TYPE.SINGLE;
        case "double":
          return TYPE.DOUBLE;
        case "end":
          return TYPE.END;
        case "repeat-begin":
          return TYPE.REPEAT_BEGIN;
        case "repeat-end":
          return TYPE.REPEAT_END;
        case "repeat-both":
          return TYPE.REPEAT_BOTH;
        default:
          return TYPE.SINGLE;
      }
    })();
    bar_note = new Vex.Flow.BarNote().setType(type);
    stave.tab_notes.push(bar_note);
    if (stave.note != null) {
      return stave.note_notes.push(bar_note);
    }
  };

  makeBend = function(from_fret, to_fret) {
    var direction, text;
    direction = Vex.Flow.Bend.UP;
    text = "";
    if (parseInt(from_fret, 10) > parseInt(to_fret, 10)) {
      direction = Vex.Flow.Bend.DOWN;
    } else {
      text = (function() {
        switch (Math.abs(to_fret - from_fret)) {
          case 1:
            return "1/2";
          case 2:
            return "Full";
          case 3:
            return "1 1/2";
          default:
            return "Bend to " + to_fret;
        }
      })();
    }
    return {
      type: direction,
      text: text
    };
  };

  Artist.prototype.openBends = function(first_note, last_note, first_indices, last_indices) {
    var base, first_frets, from_fret, i, index, j, last_frets, last_index, len, results, start_indices, start_note, tab_notes, to_fret;
    L("openBends", first_note, last_note, first_indices, last_indices);
    tab_notes = _.last(this.staves).tab_notes;
    start_note = first_note;
    start_indices = first_indices;
    if (_.isEmpty(this.current_bends)) {
      this.bend_start_index = tab_notes.length - 2;
      this.bend_start_strings = first_indices;
    } else {
      start_note = tab_notes[this.bend_start_index];
      start_indices = this.bend_start_strings;
    }
    first_frets = start_note.getPositions();
    last_frets = last_note.getPositions();
    results = [];
    for (i = j = 0, len = start_indices.length; j < len; i = ++j) {
      index = start_indices[i];
      last_index = last_indices[i];
      from_fret = first_note.getPositions()[first_indices[i]];
      to_fret = last_frets[last_index];
      if ((base = this.current_bends)[index] == null) {
        base[index] = [];
      }
      results.push(this.current_bends[index].push(makeBend(from_fret.fret, to_fret.fret)));
    }
    return results;
  };

  Artist.prototype.closeBends = function(offset) {
    var bend, j, k, l, len, len1, phrase, ref, ref1, tab_note, tab_notes, v;
    if (offset == null) {
      offset = 1;
    }
    if (this.bend_start_index == null) {
      return;
    }
    L("closeBends(" + offset + ")");
    tab_notes = _.last(this.staves).tab_notes;
    ref = this.current_bends;
    for (k in ref) {
      v = ref[k];
      phrase = [];
      for (j = 0, len = v.length; j < len; j++) {
        bend = v[j];
        phrase.push(bend);
      }
      tab_notes[this.bend_start_index].addModifier(new Vex.Flow.Bend(null, null, phrase), k);
    }
    ref1 = tab_notes.slice(this.bend_start_index + 1, +((tab_notes.length - 2) + offset) + 1 || 9e9);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      tab_note = ref1[l];
      tab_note.setGhost(true);
    }
    this.current_bends = {};
    return this.bend_start_index = null;
  };

  Artist.prototype.makeTuplets = function(tuplets, notes) {
    var modifier, stave_notes, tab_modifier, tab_notes;
    L("makeTuplets", tuplets, notes);
    if (notes == null) {
      notes = tuplets;
    }
    if (!_.last(this.staves).note) {
      return;
    }
    stave_notes = _.last(this.staves).note_notes;
    tab_notes = _.last(this.staves).tab_notes;
    if (stave_notes.length < notes) {
      throw new Vex.RERR("ArtistError", "Not enough notes for tuplet");
    }
    modifier = new Vex.Flow.Tuplet(stave_notes.slice(stave_notes.length - notes), {
      num_notes: tuplets
    });
    this.stave_articulations.push(modifier);
    tab_modifier = new Vex.Flow.Tuplet(tab_notes.slice(tab_notes.length - notes), {
      num_notes: tuplets
    });
    if (this.customizations["tab-stems"] === "true") {
      return this.tab_articulations.push(tab_modifier);
    }
  };

  getFingering = function(text) {
    return text.match(/^\.fingering\/([^.]+)\./);
  };

  Artist.prototype.makeFingering = function(text) {
    var POS, badFingering, finger, fingering, fingers, j, len, modifier, note_number, number, p, parts, pieces, position;
    parts = getFingering(text);
    POS = Vex.Flow.Modifier.Position;
    fingers = [];
    fingering = [];
    if (parts != null) {
      fingers = (function() {
        var j, len, ref, results;
        ref = parts[1].split(/-/);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          p = ref[j];
          results.push(p.trim());
        }
        return results;
      })();
    } else {
      return null;
    }
    badFingering = function() {
      return new Vex.RERR("ArtistError", "Bad fingering: " + parts[1]);
    };
    for (j = 0, len = fingers.length; j < len; j++) {
      finger = fingers[j];
      pieces = finger.match(/(\d+):([ablr]):([fs]):([^-.]+)/);
      if (pieces == null) {
        throw badFingering();
      }
      note_number = parseInt(pieces[1], 10) - 1;
      position = POS.RIGHT;
      switch (pieces[2]) {
        case "l":
          position = POS.LEFT;
          break;
        case "r":
          position = POS.RIGHT;
          break;
        case "a":
          position = POS.ABOVE;
          break;
        case "b":
          position = POS.BELOW;
      }
      modifier = null;
      number = pieces[4];
      switch (pieces[3]) {
        case "s":
          modifier = new Vex.Flow.StringNumber(number).setPosition(position);
          break;
        case "f":
          modifier = new Vex.Flow.FretHandFinger(number).setPosition(position);
      }
      fingering.push({
        num: note_number,
        modifier: modifier
      });
    }
    return fingering;
  };

  getStrokeParts = function(text) {
    return text.match(/^\.stroke\/([^.]+)\./);
  };

  Artist.prototype.makeStroke = function(text) {
    var TYPE, parts, type;
    parts = getStrokeParts(text);
    TYPE = Vex.Flow.Stroke.Type;
    type = null;
    if (parts != null) {
      switch (parts[1]) {
        case "bu":
          type = TYPE.BRUSH_UP;
          break;
        case "bd":
          type = TYPE.BRUSH_DOWN;
          break;
        case "ru":
          type = TYPE.ROLL_UP;
          break;
        case "rd":
          type = TYPE.ROLL_DOWN;
          break;
        case "qu":
          type = TYPE.RASQUEDO_UP;
          break;
        case "qd":
          type = TYPE.RASQUEDO_DOWN;
          break;
        default:
          throw new Vex.RERR("ArtistError", "Invalid stroke type: " + parts[1]);
      }
      return new Vex.Flow.Stroke(type);
    } else {
      return null;
    }
  };

  getScoreArticulationParts = function(text) {
    return text.match(/^\.(a[^\/]*)\/(t|b)[^.]*\./);
  };

  Artist.prototype.makeScoreArticulation = function(text) {
    var POSTYPE, parts, pos, position, type;
    parts = getScoreArticulationParts(text);
    if (parts != null) {
      type = parts[1];
      position = parts[2];
      POSTYPE = Vex.Flow.Modifier.Position;
      pos = position === "t" ? POSTYPE.ABOVE : POSTYPE.BELOW;
      return new Vex.Flow.Articulation(type).setPosition(pos);
    } else {
      return null;
    }
  };

  Artist.prototype.makeAnnotation = function(text) {
    var VJUST, aposition, default_vjust, font_face, font_size, font_style, just, makeIt, parts;
    font_face = this.customizations["font-face"];
    font_size = this.customizations["font-size"];
    font_style = this.customizations["font-style"];
    aposition = this.customizations["annotation-position"];
    VJUST = Vex.Flow.Annotation.VerticalJustify;
    default_vjust = aposition === "top" ? VJUST.TOP : VJUST.BOTTOM;
    makeIt = function(text, just) {
      if (just == null) {
        just = default_vjust;
      }
      return new Vex.Flow.Annotation(text).setFont(font_face, font_size, font_style).setVerticalJustification(just);
    };
    parts = text.match(/^\.([^-]*)-([^-]*)-([^.]*)\.(.*)/);
    if (parts != null) {
      font_face = parts[1];
      font_size = parts[2];
      font_style = parts[3];
      text = parts[4];
      if (text) {
        return makeIt(text);
      } else {
        return null;
      }
    }
    parts = text.match(/^\.([^.]*)\.(.*)/);
    if (parts != null) {
      just = default_vjust;
      text = parts[2];
      switch (parts[1]) {
        case "big":
          font_style = "bold";
          font_size = "14";
          break;
        case "italic":
        case "italics":
          font_face = "Times";
          font_style = "italic";
          break;
        case "medium":
          font_size = "12";
          break;
        case "top":
          just = VJUST.TOP;
          this.customizations["annotation-position"] = "top";
          break;
        case "bottom":
          just = VJUST.BOTTOM;
          this.customizations["annotation-position"] = "bottom";
      }
      if (text) {
        return makeIt(text, just);
      } else {
        return null;
      }
    }
    return makeIt(text);
  };

  Artist.prototype.addAnnotations = function(annotations) {
    var annotation, e, error, fingering, fingerings, i, j, l, len, len1, len2, m, note, ref, ref1, ref2, results, score_articulation, stave, stave_notes, stroke, tab_note, tab_notes;
    stave = _.last(this.staves);
    stave_notes = stave.note_notes;
    tab_notes = stave.tab_notes;
    if (annotations.length > tab_notes.length) {
      throw new Vex.RERR("ArtistError", "More annotations than note elements");
    }
    if (stave.tab) {
      ref = tab_notes.slice(tab_notes.length - annotations.length);
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        tab_note = ref[i];
        if (getScoreArticulationParts(annotations[i])) {
          score_articulation = this.makeScoreArticulation(annotations[i]);
          tab_note.addModifier(score_articulation, 0);
        } else if (getStrokeParts(annotations[i])) {
          stroke = this.makeStroke(annotations[i]);
          tab_note.addModifier(stroke, 0);
        } else {
          annotation = this.makeAnnotation(annotations[i]);
          if (annotation) {
            tab_note.addModifier(this.makeAnnotation(annotations[i]), 0);
          }
        }
      }
    } else {
      ref1 = stave_notes.slice(stave_notes.length - annotations.length);
      for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
        note = ref1[i];
        if (!getScoreArticulationParts(annotations[i])) {
          annotation = this.makeAnnotation(annotations[i]);
          if (annotation) {
            note.addAnnotation(0, this.makeAnnotation(annotations[i]));
          }
        }
      }
    }
    if (stave.note) {
      ref2 = stave_notes.slice(stave_notes.length - annotations.length);
      results = [];
      for (i = m = 0, len2 = ref2.length; m < len2; i = ++m) {
        note = ref2[i];
        score_articulation = this.makeScoreArticulation(annotations[i]);
        if (score_articulation != null) {
          note.addArticulation(0, score_articulation);
        }
        stroke = this.makeStroke(annotations[i]);
        if (stroke != null) {
          note.addStroke(0, stroke);
        }
        fingerings = this.makeFingering(annotations[i]);
        if (fingerings != null) {
          try {
            results.push((function() {
              var len3, o, results1;
              results1 = [];
              for (o = 0, len3 = fingerings.length; o < len3; o++) {
                fingering = fingerings[o];
                results1.push(note.addModifier(fingering.num, fingering.modifier));
              }
              return results1;
            })());
          } catch (error) {
            e = error;
            throw new Vex.RERR("ArtistError", "Bad note number in fingering: " + annotations[i]);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };

  Artist.prototype.addTabArticulation = function(type, first_note, last_note, first_indices, last_indices) {
    var articulation;
    L("addTabArticulations: ", type, first_note, last_note, first_indices, last_indices);
    if (type === "t") {
      last_note.addModifier(new Vex.Flow.Annotation("T").setVerticalJustification(Vex.Flow.Annotation.VerticalJustify.BOTTOM));
    }
    if (_.isEmpty(first_indices) && _.isEmpty(last_indices)) {
      return;
    }
    articulation = null;
    if (type === "s") {
      articulation = new Vex.Flow.TabSlide({
        first_note: first_note,
        last_note: last_note,
        first_indices: first_indices,
        last_indices: last_indices
      });
    }
    if (type === "h" || type === "p") {
      articulation = new Vex.Flow.TabTie({
        first_note: first_note,
        last_note: last_note,
        first_indices: first_indices,
        last_indices: last_indices
      }, type.toUpperCase());
    }
    if (type === "T" || type === "t") {
      articulation = new Vex.Flow.TabTie({
        first_note: first_note,
        last_note: last_note,
        first_indices: first_indices,
        last_indices: last_indices
      }, " ");
    }
    if (type === "b") {
      this.openBends(first_note, last_note, first_indices, last_indices);
    }
    if (articulation != null) {
      return this.tab_articulations.push(articulation);
    }
  };

  Artist.prototype.addStaveArticulation = function(type, first_note, last_note, first_indices, last_indices) {
    var articulation;
    L("addStaveArticulations: ", type, first_note, last_note, first_indices, last_indices);
    articulation = null;
    if (type === "b" || type === "s" || type === "h" || type === "p" || type === "t" || type === "T") {
      articulation = new Vex.Flow.StaveTie({
        first_note: first_note,
        last_note: last_note,
        first_indices: first_indices,
        last_indices: last_indices
      });
    }
    if (articulation != null) {
      return this.stave_articulations.push(articulation);
    }
  };

  Artist.prototype.getPreviousNoteIndex = function() {
    var index, note, tab_notes;
    tab_notes = _.last(this.staves).tab_notes;
    index = 2;
    while (index <= tab_notes.length) {
      note = tab_notes[tab_notes.length - index];
      if (note instanceof Vex.Flow.TabNote) {
        return tab_notes.length - index;
      }
      index++;
    }
    return -1;
  };

  Artist.prototype.addDecorator = function(decorator) {
    var modifier, ref, score_modifier, score_notes, stave, tab_notes;
    L("addDecorator: ", decorator);
    if (decorator == null) {
      return;
    }
    stave = _.last(this.staves);
    tab_notes = stave.tab_notes;
    score_notes = stave.note_notes;
    modifier = null;
    score_modifier = null;
    if (decorator === "v") {
      modifier = new Vex.Flow.Vibrato();
    }
    if (decorator === "V") {
      modifier = new Vex.Flow.Vibrato().setHarsh(true);
    }
    if (decorator === "u") {
      modifier = new Vex.Flow.Articulation("a|").setPosition(Vex.Flow.Modifier.Position.BOTTOM);
      score_modifier = new Vex.Flow.Articulation("a|").setPosition(Vex.Flow.Modifier.Position.BOTTOM);
    }
    if (decorator === "d") {
      modifier = new Vex.Flow.Articulation("am").setPosition(Vex.Flow.Modifier.Position.BOTTOM);
      score_modifier = new Vex.Flow.Articulation("am").setPosition(Vex.Flow.Modifier.Position.BOTTOM);
    }
    if (modifier != null) {
      _.last(tab_notes).addModifier(modifier, 0);
    }
    if (score_modifier != null) {
      return (ref = _.last(score_notes)) != null ? ref.addArticulation(0, score_modifier) : void 0;
    }
  };

  Artist.prototype.addArticulations = function(articulations) {
    var art, current_indices, current_tab_note, has_bends, i, indices, j, len, n, pos, prev_index, prev_indices, prev_tab_note, ref, stave, stave_notes, tab_notes, this_strings, valid_articulation, valid_strings;
    L("addArticulations: ", articulations);
    stave = _.last(this.staves);
    tab_notes = stave.tab_notes;
    stave_notes = stave.note_notes;
    if (_.isEmpty(tab_notes) || _.isEmpty(articulations)) {
      this.closeBends(0);
      return;
    }
    current_tab_note = _.last(tab_notes);
    has_bends = false;
    ref = ["b", "s", "h", "p", "t", "T", "v", "V"];
    for (j = 0, len = ref.length; j < len; j++) {
      valid_articulation = ref[j];
      indices = (function() {
        var l, len1, results;
        results = [];
        for (i = l = 0, len1 = articulations.length; l < len1; i = ++l) {
          art = articulations[i];
          if ((art != null) && art === valid_articulation) {
            results.push(i);
          }
        }
        return results;
      })();
      if (_.isEmpty(indices)) {
        continue;
      }
      if (valid_articulation === "b") {
        has_bends = true;
      }
      prev_index = this.getPreviousNoteIndex();
      if (prev_index === -1) {
        prev_tab_note = null;
        prev_indices = null;
      } else {
        prev_tab_note = tab_notes[prev_index];
        this_strings = (function() {
          var l, len1, ref1, results;
          ref1 = current_tab_note.getPositions();
          results = [];
          for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
            n = ref1[i];
            if (indexOf.call(indices, i) >= 0) {
              results.push(n.str);
            }
          }
          return results;
        })();
        valid_strings = (function() {
          var l, len1, ref1, ref2, results;
          ref1 = prev_tab_note.getPositions();
          results = [];
          for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
            pos = ref1[i];
            if (ref2 = pos.str, indexOf.call(this_strings, ref2) >= 0) {
              results.push(pos.str);
            }
          }
          return results;
        })();
        prev_indices = (function() {
          var l, len1, ref1, ref2, results;
          ref1 = prev_tab_note.getPositions();
          results = [];
          for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
            n = ref1[i];
            if (ref2 = n.str, indexOf.call(valid_strings, ref2) >= 0) {
              results.push(i);
            }
          }
          return results;
        })();
        current_indices = (function() {
          var l, len1, ref1, ref2, results;
          ref1 = current_tab_note.getPositions();
          results = [];
          for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
            n = ref1[i];
            if (ref2 = n.str, indexOf.call(valid_strings, ref2) >= 0) {
              results.push(i);
            }
          }
          return results;
        })();
      }
      if (stave.tab != null) {
        this.addTabArticulation(valid_articulation, prev_tab_note, current_tab_note, prev_indices, current_indices);
      }
      if (stave.note != null) {
        this.addStaveArticulation(valid_articulation, stave_notes[prev_index], _.last(stave_notes), prev_indices, current_indices);
      }
    }
    if (!has_bends) {
      return this.closeBends(0);
    }
  };

  Artist.prototype.addRest = function(params) {
    var position, tab_note, tab_notes;
    L("addRest: ", params);
    this.closeBends();
    if (params["position"] === 0) {
      this.addStaveNote({
        spec: ["r/4"],
        accidentals: [],
        is_rest: true
      });
    } else {
      position = this.tuning.getNoteForFret((parseInt(params["position"], 10) + 5) * 2, 6);
      this.addStaveNote({
        spec: [position],
        accidentals: [],
        is_rest: true
      });
    }
    tab_notes = _.last(this.staves).tab_notes;
    if (this.customizations["tab-stems"] === "true") {
      tab_note = new Vex.Flow.StaveNote({
        keys: [position || "r/4"],
        duration: this.current_duration + "r",
        clef: "treble",
        auto_stem: false
      });
      if (this.current_duration[this.current_duration.length - 1] === "d") {
        tab_note.addDot(0);
      }
      return tab_notes.push(tab_note);
    } else {
      return tab_notes.push(new Vex.Flow.GhostNote(this.current_duration));
    }
  };

  Artist.prototype.addChord = function(chord, chord_articulation, chord_decorator) {
    var acc, accidental, accidentals, art, articulations, current_duration, current_position, current_string, decorators, durations, i, j, l, len, len1, m, new_note, new_octave, note, num, num_notes, octave, play_note, play_notes, play_octave, ref, ref1, ref2, ref3, saved_duration, spec, specs, stave, tab_specs;
    if (_.isEmpty(chord)) {
      return;
    }
    L("addChord: ", chord);
    stave = _.last(this.staves);
    specs = [];
    play_notes = [];
    accidentals = [];
    articulations = [];
    decorators = [];
    tab_specs = [];
    durations = [];
    num_notes = 0;
    current_string = _.first(chord).string;
    current_position = 0;
    for (j = 0, len = chord.length; j < len; j++) {
      note = chord[j];
      num_notes++;
      if ((note.abc != null) || note.string !== current_string) {
        current_position = 0;
        current_string = note.string;
      }
      if (specs[current_position] == null) {
        specs[current_position] = [];
        play_notes[current_position] = [];
        accidentals[current_position] = [];
        tab_specs[current_position] = [];
        articulations[current_position] = [];
        decorators[current_position] = [];
      }
      ref = [null, null, null], new_note = ref[0], new_octave = ref[1], accidental = ref[2];
      play_note = null;
      if (note.abc != null) {
        octave = note.octave != null ? note.octave : note.string;
        ref1 = this.getNoteForABC(note.abc, octave), new_note = ref1[0], new_octave = ref1[1], accidental = ref1[2];
        if (accidental != null) {
          acc = accidental.split("_")[0];
        } else {
          acc = "";
        }
        play_note = "" + new_note + acc;
        if (note.fret == null) {
          note.fret = 'X';
        }
      } else if (note.fret != null) {
        ref2 = this.getNoteForFret(note.fret, note.string), new_note = ref2[0], new_octave = ref2[1], accidental = ref2[2];
        play_note = this.tuning.getNoteForFret(note.fret, note.string).split("/")[0];
      } else {
        throw new Vex.RERR("ArtistError", "No note specified");
      }
      play_octave = parseInt(new_octave, 10) + this.current_octave_shift;
      current_duration = note.time != null ? {
        time: note.time,
        dot: note.dot
      } : null;
      specs[current_position].push(new_note + "/" + new_octave);
      play_notes[current_position].push(play_note + "/" + play_octave);
      accidentals[current_position].push(accidental);
      tab_specs[current_position].push({
        fret: note.fret,
        str: note.string
      });
      if (note.articulation != null) {
        articulations[current_position].push(note.articulation);
      }
      durations[current_position] = current_duration;
      if (note.decorator != null) {
        decorators[current_position] = note.decorator;
      }
      current_position++;
    }
    for (i = l = 0, len1 = specs.length; l < len1; i = ++l) {
      spec = specs[i];
      saved_duration = this.current_duration;
      if (durations[i] != null) {
        this.setDuration(durations[i].time, durations[i].dot);
      }
      this.addTabNote(tab_specs[i], play_notes[i]);
      if (stave.note != null) {
        this.addStaveNote({
          spec: spec,
          accidentals: accidentals[i],
          play_note: play_notes[i]
        });
      }
      this.addArticulations(articulations[i]);
      if (decorators[i] != null) {
        this.addDecorator(decorators[i]);
      }
    }
    if (chord_articulation != null) {
      art = [];
      for (num = m = 1, ref3 = num_notes; 1 <= ref3 ? m <= ref3 : m >= ref3; num = 1 <= ref3 ? ++m : --m) {
        art.push(chord_articulation);
      }
      this.addArticulations(art);
    }
    if (chord_decorator != null) {
      return this.addDecorator(chord_decorator);
    }
  };

  Artist.prototype.addNote = function(note) {
    return this.addChord([note]);
  };

  Artist.prototype.addTextVoice = function() {
    return _.last(this.staves).text_voices.push([]);
  };

  Artist.prototype.setTextFont = function(font) {
    var parts;
    if (font != null) {
      parts = font.match(/([^-]*)-([^-]*)-([^.]*)/);
      if (parts != null) {
        this.customizations["font-face"] = parts[1];
        this.customizations["font-size"] = parseInt(parts[2], 10);
        return this.customizations["font-style"] = parts[3];
      }
    }
  };

  Artist.prototype.addTextNote = function(text, position, justification, smooth, ignore_ticks) {
    var duration, font_face, font_size, font_style, just, note, struct, voices;
    if (position == null) {
      position = 0;
    }
    if (justification == null) {
      justification = "center";
    }
    if (smooth == null) {
      smooth = true;
    }
    if (ignore_ticks == null) {
      ignore_ticks = false;
    }
    voices = _.last(this.staves).text_voices;
    if (_.isEmpty(voices)) {
      throw new Vex.RERR("ArtistError", "Can't add text note without text voice");
    }
    font_face = this.customizations["font-face"];
    font_size = this.customizations["font-size"];
    font_style = this.customizations["font-style"];
    just = (function() {
      switch (justification) {
        case "center":
          return Vex.Flow.TextNote.Justification.CENTER;
        case "left":
          return Vex.Flow.TextNote.Justification.LEFT;
        case "right":
          return Vex.Flow.TextNote.Justification.RIGHT;
        default:
          return Vex.Flow.TextNote.Justification.CENTER;
      }
    })();
    duration = ignore_ticks ? "b" : this.current_duration;
    struct = {
      text: text,
      duration: duration,
      smooth: smooth,
      ignore_ticks: ignore_ticks,
      font: {
        family: font_face,
        size: font_size,
        weight: font_style
      }
    };
    if (text[0] === "#") {
      struct.glyph = text.slice(1);
    }
    note = new Vex.Flow.TextNote(struct).setLine(position).setJustification(just);
    return _.last(voices).push(note);
  };

  Artist.prototype.addVoice = function(options) {
    var stave;
    this.closeBends();
    stave = _.last(this.staves);
    if (stave == null) {
      return this.addStave(options);
    }
    if (!_.isEmpty(stave.tab_notes)) {
      stave.tab_voices.push(stave.tab_notes);
      stave.tab_notes = [];
    }
    if (!_.isEmpty(stave.note_notes)) {
      stave.note_voices.push(stave.note_notes);
      return stave.note_notes = [];
    }
  };

  Artist.prototype.addStave = function(element, options) {
    var beam_groups, note_stave, opts, start_x, tab_stave, tabstave_start_x;
    opts = {
      tuning: "standard",
      clef: "treble",
      key: "C",
      notation: element === "tabstave" ? "false" : "true",
      tablature: element === "stave" ? "false" : "true",
      strings: 6
    };
    _.extend(opts, options);
    L("addStave: ", element, opts);
    tab_stave = null;
    note_stave = null;
    start_x = this.x + this.customizations["connector-space"];
    tabstave_start_x = 40;
    if (opts.notation === "true") {
      note_stave = new Vex.Flow.Stave(start_x, this.last_y, this.customizations.width - 20);
      if (opts.clef !== "none") {
        note_stave.addClef(opts.clef);
      }
      note_stave.addKeySignature(opts.key);
      if (opts.time != null) {
        note_stave.addTimeSignature(opts.time);
      }
      this.last_y += note_stave.getHeight() + this.options.note_stave_lower_spacing + parseInt(this.customizations["stave-distance"], 10);
      tabstave_start_x = note_stave.getNoteStartX();
      this.current_clef = opts.clef === "none" ? "treble" : opts.clef;
    }
    if (opts.tablature === "true") {
      tab_stave = new Vex.Flow.TabStave(start_x, this.last_y, this.customizations.width - 20).setNumLines(opts.strings);
      if (opts.clef !== "none") {
        tab_stave.addTabGlyph();
      }
      tab_stave.setNoteStartX(tabstave_start_x);
      this.last_y += tab_stave.getHeight() + this.options.tab_stave_lower_spacing;
    }
    this.closeBends();
    beam_groups = Vex.Flow.Beam.getDefaultBeamGroups(opts.time);
    this.staves.push({
      tab: tab_stave,
      note: note_stave,
      tab_voices: [],
      note_voices: [],
      tab_notes: [],
      note_notes: [],
      text_voices: [],
      beam_groups: beam_groups
    });
    this.tuning.setTuning(opts.tuning);
    this.key_manager.setKey(opts.key);
  };

  Artist.prototype.runCommand = function(line, _l, _c) {
    var words;
    if (_l == null) {
      _l = 0;
    }
    if (_c == null) {
      _c = 0;
    }
    L("runCommand: ", line);
    words = line.split(/\s+/);
    switch (words[0]) {
      case "octave-shift":
        this.current_octave_shift = parseInt(words[1], 10);
        return L("Octave shift: ", this.current_octave_shift);
      default:
        throw new Vex.RERR("ArtistError", "Invalid command '" + words[0] + "' at line " + _l + " column " + _c);
    }
  };

  return Artist;

})();

module.exports = Artist;


},{"underscore":7,"vexflow":8}],10:[function(require,module,exports){
var Artist, Player, Vex, VexTab;

Vex = require('vexflow');

Artist = require('./artist.coffee');

VexTab = require('./vextab.coffee');

Player = require('./player.coffee');

module.exports = {
  Artist: Artist,
  VexTab: VexTab,
  Vex: Vex,
  Player: Player
};


},{"./artist.coffee":9,"./player.coffee":11,"./vextab.coffee":12,"vexflow":8}],11:[function(require,module,exports){
var $, Vex, _, paper,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Vex = require('vexflow');

_ = require('underscore');

$ = require('jquery');

paper = require('paper');

Vex.Flow.Player = (function() {
  var Fraction, INSTRUMENTS, L, RESOLUTION, drawDot, getOverlay, noteValues;

  Player.DEBUG = false;

  Player.INSTRUMENTS_LOADED = {};

  L = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (Vex.Flow.Player.DEBUG) {
      return typeof console !== "undefined" && console !== null ? console.log.apply(console, ["(Vex.Flow.Player)"].concat(slice.call(args))) : void 0;
    }
  };

  Fraction = Vex.Flow.Fraction;

  RESOLUTION = Vex.Flow.RESOLUTION;

  noteValues = Vex.Flow.Music.noteValues;

  drawDot = Vex.drawDot;

  INSTRUMENTS = {
    "acoustic_grand_piano": 0,
    "acoustic_guitar_nylon": 24,
    "acoustic_guitar_steel": 25,
    "electric_guitar_jazz": 26,
    "distortion_guitar": 30,
    "electric_bass_finger": 33,
    "electric_bass_pick": 34,
    "trumpet": 56,
    "brass_section": 61,
    "soprano_sax": 64,
    "alto_sax": 65,
    "tenor_sax": 66,
    "baritone_sax": 67,
    "flute": 73,
    "synth_drum": 118
  };

  function Player(artist1, options) {
    this.artist = artist1;
    L("Initializing player: ", options);
    this.options = {
      instrument: "acoustic_grand_piano",
      tempo: 120,
      show_controls: true,
      soundfont_url: "../soundfont/",
      overlay_class: "vextab-player"
    };
    if (options != null) {
      _.extend(this.options, options);
    }
    L("Using soundfonts in: " + this.options.soundfont_url);
    this.interval_id = null;
    this.paper = null;
    this.reset();
  }

  Player.prototype.setArtist = function(artist) {
    this.artist = artist;
    return this.reset();
  };

  Player.prototype.setTempo = function(tempo) {
    L("New tempo: ", tempo);
    this.options.tempo = tempo;
    return this.reset();
  };

  Player.prototype.setInstrument = function(instrument) {
    L("New instrument: ", instrument);
    if (indexOf.call(_.keys(INSTRUMENTS), instrument) < 0) {
      throw new Vex.RERR("PlayerError", "Invalid instrument: " + instrument);
    }
    this.options.instrument = instrument;
    return this.reset();
  };

  Player.prototype.reset = function() {
    this.artist.attachPlayer(this);
    this.tick_notes = {};
    this.all_ticks = [];
    this.tpm = this.options.tempo * (RESOLUTION / 4);
    this.refresh_rate = 25;
    this.ticks_per_refresh = this.tpm / (60 * (1000 / this.refresh_rate));
    this.total_ticks = 0;
    if (this.marker != null) {
      this.marker.remove();
      this.marker = null;
    }
    return this.stop();
  };

  getOverlay = function(context, scale, overlay_class) {
    var canvas, ctx, height, overlay, ps, width;
    canvas = context.canvas;
    height = canvas.height;
    width = canvas.width;
    overlay = $('<canvas>');
    overlay.css("position", "absolute");
    overlay.css("left", 0);
    overlay.css("top", 0);
    overlay.addClass(overlay_class);
    $(canvas).after(overlay);
    ctx = Vex.Flow.Renderer.getCanvasContext(overlay.get(0), width, height);
    ctx.scale(scale, scale);
    ps = new paper.PaperScope();
    ps.setup(overlay.get(0));
    return {
      paper: ps,
      canvas: overlay.get(0)
    };
  };

  Player.prototype.removeControls = function() {
    if (this.play_button != null) {
      this.play_button.remove();
    }
    if (this.stop_button != null) {
      this.stop_button.remove();
    }
    if (this.paper != null) {
      return this.paper.view.draw();
    }
  };

  Player.prototype.render = function() {
    var abs_tick, data, i, j, k, key, l, len, len1, len2, max_voice_tick, note, overlay, ref, staves, total_ticks, total_voice_ticks, voice, voice_group;
    this.reset();
    data = this.artist.getPlayerData();
    this.scale = data.scale;
    if (!this.paper) {
      overlay = getOverlay(data.context, data.scale, this.options.overlay_class);
      this.paper = overlay.paper;
    }
    this.marker = new this.paper.Path.Rectangle(0, 0, 13, 85);
    this.loading_message = new this.paper.PointText(35, 12);
    if (this.options.show_controls) {
      this.play_button = new this.paper.Path.RegularPolygon(new this.paper.Point(25, 10), 3, 7, 7);
      this.play_button.fillColor = '#396';
      this.play_button.opacity = 0.8;
      this.play_button.rotate(90);
      this.play_button.onMouseUp = (function(_this) {
        return function(event) {
          return _this.play();
        };
      })(this);
      this.stop_button = new this.paper.Path.Rectangle(3, 3, 10, 10);
      this.stop_button.fillColor = '#396';
      this.stop_button.opacity = 0.8;
      this.stop_button.onMouseUp = (function(_this) {
        return function(event) {
          return _this.stop();
        };
      })(this);
    }
    this.paper.view.draw();
    staves = data.voices;
    total_ticks = new Fraction(0, 1);
    for (j = 0, len = staves.length; j < len; j++) {
      voice_group = staves[j];
      max_voice_tick = new Fraction(0, 1);
      for (i = k = 0, len1 = voice_group.length; k < len1; i = ++k) {
        voice = voice_group[i];
        total_voice_ticks = new Fraction(0, 1);
        ref = voice.getTickables();
        for (l = 0, len2 = ref.length; l < len2; l++) {
          note = ref[l];
          if (!note.shouldIgnoreTicks()) {
            abs_tick = total_ticks.clone();
            abs_tick.add(total_voice_ticks);
            abs_tick.simplify();
            key = abs_tick.toString();
            if (_.has(this.tick_notes, key)) {
              this.tick_notes[key].notes.push(note);
            } else {
              this.tick_notes[key] = {
                tick: abs_tick,
                value: abs_tick.value(),
                notes: [note]
              };
            }
            total_voice_ticks.add(note.getTicks());
          }
        }
        if (total_voice_ticks.value() > max_voice_tick.value()) {
          max_voice_tick.copy(total_voice_ticks);
        }
      }
      total_ticks.add(max_voice_tick);
    }
    this.all_ticks = _.sortBy(_.values(this.tick_notes), function(tick) {
      return tick.value;
    });
    this.total_ticks = _.last(this.all_ticks);
    return L(this.all_ticks);
  };

  Player.prototype.updateMarker = function(x, y) {
    this.marker.fillColor = '#369';
    this.marker.opacity = 0.2;
    this.marker.setPosition(new this.paper.Point(x * this.scale, y * this.scale));
    return this.paper.view.draw();
  };

  Player.prototype.playNote = function(notes) {
    var duration, j, key, keys, len, midi_note, note, note_value, octave, results, x, y;
    L("(" + this.current_ticks + ") playNote: ", notes);
    results = [];
    for (j = 0, len = notes.length; j < len; j++) {
      note = notes[j];
      x = note.getAbsoluteX() + 4;
      y = note.getStave().getYForLine(2);
      if (this.paper != null) {
        this.updateMarker(x, y);
      }
      if (note.isRest()) {
        continue;
      }
      keys = note.getPlayNote();
      duration = note.getTicks().value() / (this.tpm / 60);
      results.push((function() {
        var k, len1, ref, results1;
        results1 = [];
        for (k = 0, len1 = keys.length; k < len1; k++) {
          key = keys[k];
          ref = key.split("/"), note = ref[0], octave = ref[1];
          note = note.trim().toLowerCase();
          note_value = noteValues[note];
          if (note_value == null) {
            continue;
          }
          midi_note = (24 + (octave * 12)) + noteValues[note].int_val;
          MIDI.noteOn(0, midi_note, 127, 0);
          results1.push(MIDI.noteOff(0, midi_note, duration));
        }
        return results1;
      })());
    }
    return results;
  };

  Player.prototype.refresh = function() {
    if (this.done) {
      this.stop();
      return;
    }
    this.current_ticks += this.ticks_per_refresh;
    if (this.current_ticks >= this.next_event_tick && this.all_ticks.length > 0) {
      this.playNote(this.all_ticks[this.next_index].notes);
      this.next_index++;
      if (this.next_index >= this.all_ticks.length) {
        return this.done = true;
      } else {
        return this.next_event_tick = this.all_ticks[this.next_index].tick.value();
      }
    }
  };

  Player.prototype.stop = function() {
    L("Stop");
    if (this.interval_id != null) {
      window.clearInterval(this.interval_id);
    }
    if (this.play_button != null) {
      this.play_button.fillColor = '#396';
    }
    if (this.paper != null) {
      this.paper.view.draw();
    }
    this.interval_id = null;
    this.current_ticks = 0;
    this.next_event_tick = 0;
    this.next_index = 0;
    return this.done = false;
  };

  Player.prototype.start = function() {
    this.stop();
    L("Start");
    if (this.play_button != null) {
      this.play_button.fillColor = '#a36';
    }
    MIDI.programChange(0, INSTRUMENTS[this.options.instrument]);
    this.render();
    return this.interval_id = window.setInterval(((function(_this) {
      return function() {
        return _this.refresh();
      };
    })(this)), this.refresh_rate);
  };

  Player.prototype.play = function() {
    L("Play: ", this.refresh_rate, this.ticks_per_refresh);
    if (Vex.Flow.Player.INSTRUMENTS_LOADED[this.options.instrument] && !this.loading) {
      return this.start();
    } else {
      L("Loading instruments...");
      this.loading_message.content = "Loading instruments...";
      this.loading_message.fillColor = "green";
      this.loading = true;
      this.paper.view.draw();
      return MIDI.loadPlugin({
        soundfontUrl: this.options.soundfont_url,
        instruments: [this.options.instrument],
        callback: (function(_this) {
          return function() {
            console.log("loadPlugin is succcesfully calling back.");
            Vex.Flow.Player.INSTRUMENTS_LOADED[_this.options.instrument] = true;
            _this.loading = false;
            _this.loading_message.content = "";
            return _this.start();
          };
        })(this)
      });
    }
  };

  return Player;

})();

module.exports = Vex.Flow.Player;


},{"jquery":4,"paper":5,"underscore":7,"vexflow":8}],12:[function(require,module,exports){
var Vex, VexTab, _, parser,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Vex = require('vexflow');

_ = require('underscore');

parser = require('../build/vextab-jison.js');

VexTab = (function() {
  var L, newError;

  VexTab.DEBUG = false;

  L = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (VexTab.DEBUG) {
      return typeof console !== "undefined" && console !== null ? console.log.apply(console, ["(Vex.Flow.VexTab)"].concat(slice.call(args))) : void 0;
    }
  };

  newError = function(object, msg) {
    return new Vex.RERR("ParseError", msg + " in line " + object._l + " column " + object._c);
  };

  function VexTab(artist) {
    this.artist = artist;
    this.reset();
  }

  VexTab.prototype.reset = function() {
    this.valid = false;
    return this.elements = false;
  };

  VexTab.prototype.isValid = function() {
    return this.valid;
  };

  VexTab.prototype.getArtist = function() {
    return this.artist;
  };

  VexTab.prototype.parseStaveOptions = function(options) {
    var clefs, e, error, error1, error2, i, len, notation_option, num_strings, option, params, ref, ref1, ref2, voices;
    params = {};
    if (options == null) {
      return params;
    }
    notation_option = null;
    for (i = 0, len = options.length; i < len; i++) {
      option = options[i];
      error = function(msg) {
        return newError(option, msg);
      };
      params[option.key] = option.value;
      switch (option.key) {
        case "notation":
        case "tablature":
          notation_option = option;
          if ((ref = option.value) !== "true" && ref !== "false") {
            throw error("'" + option.key + "' must be 'true' or 'false'");
          }
          break;
        case "key":
          if (!_.has(Vex.Flow.keySignature.keySpecs, option.value)) {
            throw error("Invalid key signature '" + option.value + "'");
          }
          break;
        case "clef":
          clefs = ["treble", "bass", "tenor", "alto", "percussion", "none"];
          if (ref1 = option.value, indexOf.call(clefs, ref1) < 0) {
            throw error("'clef' must be one of " + (clefs.join(', ')));
          }
          break;
        case "voice":
          voices = ["top", "bottom", "new"];
          if (ref2 = option.value, indexOf.call(voices, ref2) < 0) {
            throw error("'voice' must be one of " + (voices.join(', ')));
          }
          break;
        case "time":
          try {
            new Vex.Flow.TimeSignature(option.value);
          } catch (error1) {
            e = error1;
            throw error("Invalid time signature: '" + option.value + "'");
          }
          break;
        case "tuning":
          try {
            new Vex.Flow.Tuning(option.value);
          } catch (error2) {
            e = error2;
            throw error("Invalid tuning: '" + option.value + "'");
          }
          break;
        case "strings":
          num_strings = parseInt(option.value);
          if (num_strings < 4 || num_strings > 8) {
            throw error("Invalid number of strings: " + num_strings);
          }
          break;
        default:
          throw error("Invalid option '" + option.key + "'");
      }
    }
    if (params.notation === "false" && params.tablature === "false") {
      throw newError(notation_option, "Both 'notation' and 'tablature' can't be invisible");
    }
    return params;
  };

  VexTab.prototype.parseCommand = function(element) {
    if (element.command === "bar") {
      this.artist.addBar(element.type);
    }
    if (element.command === "tuplet") {
      this.artist.makeTuplets(element.params.tuplet, element.params.notes);
    }
    if (element.command === "annotations") {
      this.artist.addAnnotations(element.params);
    }
    if (element.command === "rest") {
      this.artist.addRest(element.params);
    }
    if (element.command === "command") {
      return this.artist.runCommand(element.params, element._l, element._c);
    }
  };

  VexTab.prototype.parseChord = function(element) {
    L("parseChord:", element);
    return this.artist.addChord(_.map(element.chord, function(note) {
      return _.pick(note, 'time', 'dot', 'fret', 'abc', 'octave', 'string', 'articulation', 'decorator');
    }), element.articulation, element.decorator);
  };

  VexTab.prototype.parseFret = function(note) {
    return this.artist.addNote(_.pick(note, 'time', 'dot', 'fret', 'string', 'articulation', 'decorator'));
  };

  VexTab.prototype.parseABC = function(note) {
    return this.artist.addNote(_.pick(note, 'time', 'dot', 'fret', 'abc', 'octave', 'string', 'articulation', 'decorator'));
  };

  VexTab.prototype.parseStaveElements = function(notes) {
    var element, i, len, results;
    L("parseStaveElements:", notes);
    results = [];
    for (i = 0, len = notes.length; i < len; i++) {
      element = notes[i];
      if (element.time) {
        this.artist.setDuration(element.time, element.dot);
      }
      if (element.command) {
        this.parseCommand(element);
      }
      if (element.chord) {
        this.parseChord(element);
      }
      if (element.abc) {
        results.push(this.parseABC(element));
      } else if (element.fret) {
        results.push(this.parseFret(element));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  VexTab.prototype.parseStaveText = function(text_line) {
    var bartext, command, createNote, font, i, justification, len, position, results, smooth, str, text;
    if (!_.isEmpty(text_line)) {
      this.artist.addTextVoice();
    }
    position = 0;
    justification = "center";
    smooth = true;
    font = null;
    bartext = (function(_this) {
      return function() {
        return _this.artist.addTextNote("", 0, justification, false, true);
      };
    })(this);
    createNote = (function(_this) {
      return function(text) {
        var e, error1, ignore_ticks;
        ignore_ticks = false;
        if (text[0] === "|") {
          ignore_ticks = true;
          text = text.slice(1);
        }
        try {
          return _this.artist.addTextNote(text, position, justification, smooth, ignore_ticks);
        } catch (error1) {
          e = error1;
          throw newError(str, "Bad text or duration. Did you forget a comma?" + e);
        }
      };
    })(this);
    results = [];
    for (i = 0, len = text_line.length; i < len; i++) {
      str = text_line[i];
      text = str.text.trim();
      if (text.match(/\.font=.*/)) {
        font = text.slice(6);
        results.push(this.artist.setTextFont(font));
      } else if (text[0] === ":") {
        results.push(this.artist.setDuration(text));
      } else if (text[0] === ".") {
        command = text.slice(1);
        switch (command) {
          case "center":
          case "left":
          case "right":
            results.push(justification = command);
            break;
          case "strict":
            results.push(smooth = false);
            break;
          case "smooth":
            results.push(smooth = true);
            break;
          case "bar":
          case "|":
            results.push(bartext());
            break;
          default:
            results.push(position = parseInt(text.slice(1), 10));
        }
      } else if (text === "|") {
        results.push(bartext());
      } else if (text.slice(0, 2) === "++") {
        results.push(this.artist.addTextVoice());
      } else {
        results.push(createNote(text));
      }
    }
    return results;
  };

  VexTab.prototype.generate = function() {
    var e, error1, i, j, len, len1, option, options, ref, ref1, results, stave;
    ref = this.elements;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      stave = ref[i];
      switch (stave.element) {
        case "stave":
        case "tabstave":
          this.artist.addStave(stave.element, this.parseStaveOptions(stave.options));
          if (stave.notes != null) {
            this.parseStaveElements(stave.notes);
          }
          if (stave.text != null) {
            results.push(this.parseStaveText(stave.text));
          } else {
            results.push(void 0);
          }
          break;
        case "voice":
          this.artist.addVoice(this.parseStaveOptions(stave.options));
          if (stave.notes != null) {
            this.parseStaveElements(stave.notes);
          }
          if (stave.text != null) {
            results.push(this.parseStaveText(stave.text));
          } else {
            results.push(void 0);
          }
          break;
        case "options":
          options = {};
          ref1 = stave.params;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            option = ref1[j];
            options[option.key] = option.value;
          }
          try {
            results.push(this.artist.setOptions(options));
          } catch (error1) {
            e = error1;
            throw newError(stave, e.message);
          }
          break;
        default:
          throw newError(stave, "Invalid keyword '" + stave.element + "'");
      }
    }
    return results;
  };

  VexTab.prototype.parse = function(code) {
    var line, stripped_code;
    parser.parseError = function(message, hash) {
      L("VexTab parse error: ", message, hash);
      message = "Unexpected text '" + hash.text + "' at line " + hash.loc.first_line + " column " + hash.loc.first_column + ".";
      throw new Vex.RERR("ParseError", message);
    };
    if (code == null) {
      throw new Vex.RERR("ParseError", "No code");
    }
    L("Parsing:\n" + code);
    stripped_code = (function() {
      var i, len, ref, results;
      ref = code.split(/\r\n|\r|\n/);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        line = ref[i];
        results.push(line.trim());
      }
      return results;
    })();
    this.elements = parser.parse(stripped_code.join("\n"));
    if (this.elements) {
      this.generate();
      this.valid = true;
    }
    return this.elements;
  };

  return VexTab;

})();

module.exports = VexTab;


},{"../build/vextab-jison.js":1,"underscore":7,"vexflow":8}],13:[function(require,module,exports){
// Load VexTab module.
vextab = require("vextab");
$ = require("jquery");
_ = require("underscore");

$(function() {
  VexTab = vextab.VexTab;
  Artist = vextab.Artist;
  Renderer = vextab.Vex.Flow.Renderer;
  Player = vextab.Player;

  Artist.DEBUG = false;
  VexTab.DEBUG = false;
  Player.DEBUG = true;

  // Create VexFlow Renderer from canvas element with id #boo
  renderer = new Renderer($('#boo')[0], Renderer.Backends.CANVAS);

  // Initialize VexTab artist and parser.
  artist = new Artist(10, 10, 600, {scale: 0.8});
  player = new Player(artist);
  vextab = new VexTab(artist);

  function render() {
    try {
      vextab.reset();
      artist.reset();
//      player.reset();
      vextab.parse($("#blah").val());
      artist.render(renderer);
      $("#error").text("");
    } catch (e) {
      console.log(e);
      $("#error").html(e.message.replace(/[\n]/g, '<br/>'));
    }
  }

  $("#blah").keyup(_.throttle(render, 250));
  render();
});

},{"jquery":4,"underscore":7,"vextab":10}]},{},[13])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJidWlsZC92ZXh0YWItamlzb24uanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJub2RlX21vZHVsZXMvcGFwZXIvZGlzdC9wYXBlci1mdWxsLmpzIiwibm9kZV9tb2R1bGVzL3BhdGgtYnJvd3NlcmlmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy91bmRlcnNjb3JlL3VuZGVyc2NvcmUuanMiLCJub2RlX21vZHVsZXMvdmV4Zmxvdy9yZWxlYXNlcy92ZXhmbG93LWRlYnVnLmpzIiwiL1VzZXJzL3NwZW5jZXJoaXRjaGNvY2svY29kZS92ZXh0YWIvc3JjL2FydGlzdC5jb2ZmZWUiLCIvVXNlcnMvc3BlbmNlcmhpdGNoY29jay9jb2RlL3ZleHRhYi9zcmMvbWFpbi5jb2ZmZWUiLCIvVXNlcnMvc3BlbmNlcmhpdGNoY29jay9jb2RlL3ZleHRhYi9zcmMvcGxheWVyLmNvZmZlZSIsIi9Vc2Vycy9zcGVuY2VyaGl0Y2hjb2NrL2NvZGUvdmV4dGFiL3NyYy92ZXh0YWIuY29mZmVlIiwidGVzdHMvcGxheWdyb3VuZC5qcyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQ3JnQ0E7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMzRkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdm1UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeDRhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNWdEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2wvZUEsSUFBQSxjQUFBO0VBQUE7OztBQUFBLEdBQUEsR0FBTSxPQUFBLENBQVEsU0FBUjs7QUFDTixDQUFBLEdBQUksT0FBQSxDQUFRLFlBQVI7O0FBRUU7QUFDSixNQUFBOztFQUFBLE1BQUMsQ0FBQSxLQUFELEdBQVM7O0VBQ1QsQ0FBQSxHQUFJLFNBQUE7QUFBYSxRQUFBO0lBQVo7SUFBWSxJQUE4QyxNQUFNLENBQUMsS0FBckQ7a0VBQUEsT0FBTyxDQUFFLEdBQVQsZ0JBQWEsQ0FBQSxtQkFBcUIsU0FBQSxXQUFBLElBQUEsQ0FBQSxDQUFsQyxXQUFBOztFQUFiOztFQUVKLE1BQUMsQ0FBQSxNQUFELEdBQVU7O0VBRUcsZ0JBQUMsQ0FBRCxFQUFLLENBQUwsRUFBUyxNQUFULEVBQWlCLE9BQWpCO0lBQUMsSUFBQyxDQUFBLElBQUQ7SUFBSSxJQUFDLENBQUEsSUFBRDtJQUFJLElBQUMsQ0FBQSxRQUFEO0lBQ3BCLElBQUMsQ0FBQSxPQUFELEdBQ0U7TUFBQSxTQUFBLEVBQVcsT0FBWDtNQUNBLFNBQUEsRUFBVyxFQURYO01BRUEsVUFBQSxFQUFZLElBRlo7TUFHQSxjQUFBLEVBQWdCLEVBQUEsR0FBSyxDQUFJLE1BQU0sQ0FBQyxNQUFWLEdBQXNCLENBQXRCLEdBQTZCLEVBQTlCLENBSHJCO01BSUEsdUJBQUEsRUFBeUIsRUFKekI7TUFLQSx3QkFBQSxFQUEwQixDQUwxQjtNQU1BLEtBQUEsRUFBTyxHQU5QOztJQU9GLElBQStCLGVBQS9CO01BQUEsQ0FBQyxDQUFDLE1BQUYsQ0FBUyxJQUFDLENBQUEsT0FBVixFQUFtQixPQUFuQixFQUFBOztJQUNBLElBQUMsQ0FBQSxLQUFELENBQUE7RUFWVzs7bUJBWWIsS0FBQSxHQUFPLFNBQUE7SUFDTCxJQUFDLENBQUEsTUFBRCxHQUFjLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFULENBQUE7SUFDZCxJQUFDLENBQUEsV0FBRCxHQUFtQixJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVCxDQUFvQixHQUFwQjtJQUNuQixJQUFDLENBQUEsU0FBRCxHQUFpQixJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBVCxDQUFBO0lBR2pCLElBQUMsQ0FBQSxjQUFELEdBQ0U7TUFBQSxXQUFBLEVBQWEsSUFBQyxDQUFBLE9BQU8sQ0FBQyxTQUF0QjtNQUNBLFdBQUEsRUFBYSxJQUFDLENBQUEsT0FBTyxDQUFDLFNBRHRCO01BRUEsWUFBQSxFQUFjLElBQUMsQ0FBQSxPQUFPLENBQUMsVUFGdkI7TUFHQSxxQkFBQSxFQUF1QixRQUh2QjtNQUlBLE9BQUEsRUFBUyxJQUFDLENBQUEsT0FBTyxDQUFDLEtBSmxCO01BS0EsT0FBQSxFQUFTLElBQUMsQ0FBQSxLQUxWO01BTUEsZ0JBQUEsRUFBa0IsQ0FObEI7TUFPQSxPQUFBLEVBQVMsQ0FQVDtNQVFBLFFBQUEsRUFBVSxPQVJWO01BU0EsT0FBQSxFQUFTLEdBVFQ7TUFVQSxZQUFBLEVBQWMsc0JBVmQ7TUFXQSxhQUFBLEVBQWUsVUFYZjtNQVlBLFdBQUEsRUFBYSxPQVpiO01BYUEsb0JBQUEsRUFBc0IsSUFidEI7TUFjQSxZQUFBLEVBQWMsTUFkZDtNQWVBLGVBQUEsRUFBaUIsTUFmakI7TUFnQkEsa0JBQUEsRUFBb0IsT0FoQnBCO01BaUJBLGlCQUFBLEVBQW1CLENBakJuQjs7SUFvQkYsSUFBQyxDQUFBLE1BQUQsR0FBVTtJQUNWLElBQUMsQ0FBQSxpQkFBRCxHQUFxQjtJQUNyQixJQUFDLENBQUEsbUJBQUQsR0FBdUI7SUFHdkIsSUFBQyxDQUFBLGFBQUQsR0FBaUI7SUFHakIsSUFBQyxDQUFBLE1BQUQsR0FBVSxJQUFDLENBQUE7SUFDWCxJQUFDLENBQUEsZ0JBQUQsR0FBb0I7SUFDcEIsSUFBQyxDQUFBLFlBQUQsR0FBZ0I7SUFDaEIsSUFBQyxDQUFBLGFBQUQsR0FBaUI7SUFDakIsSUFBQyxDQUFBLG9CQUFELEdBQXdCO0lBQ3hCLElBQUMsQ0FBQSxnQkFBRCxHQUFvQjtJQUNwQixJQUFDLENBQUEsa0JBQUQsR0FBc0I7SUFDdEIsSUFBQyxDQUFBLFFBQUQsR0FBWTtXQUNaLElBQUMsQ0FBQSxnQkFBRCxHQUFvQjtFQTNDZjs7bUJBNkNQLFlBQUEsR0FBYyxTQUFDLE1BQUQ7SUFDWixJQUFHLENBQUMsSUFBQyxDQUFBLE1BQUw7TUFDRSxPQUFPLENBQUMsR0FBUixDQUFZLGtCQUFaO2FBQ0EsSUFBQyxDQUFBLE1BQUQsR0FBVSxPQUZaOztFQURZOzttQkFLZCxVQUFBLEdBQVksU0FBQyxPQUFEO0FBQ1YsUUFBQTtJQUFBLENBQUEsQ0FBRSxjQUFGLEVBQWtCLE9BQWxCO0lBRUEsYUFBQSxHQUFnQixDQUFDLENBQUMsSUFBRixDQUFPLElBQUMsQ0FBQSxjQUFSO0FBQ2hCLFNBQUEsWUFBQTs7TUFDRSxJQUFHLGFBQUssYUFBTCxFQUFBLENBQUEsTUFBSDtRQUNFLElBQUMsQ0FBQSxjQUFlLENBQUEsQ0FBQSxDQUFoQixHQUFxQixFQUR2QjtPQUFBLE1BQUE7QUFHRSxjQUFVLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxhQUFULEVBQXdCLGtCQUFBLEdBQW1CLENBQW5CLEdBQXFCLEdBQTdDLEVBSFo7O0FBREY7SUFNQSxJQUFDLENBQUEsTUFBRCxJQUFXLFFBQUEsQ0FBUyxJQUFDLENBQUEsY0FBYyxDQUFDLEtBQXpCLEVBQWdDLEVBQWhDO0lBQ1gsSUFBZ0IsSUFBQyxDQUFBLGNBQWMsQ0FBQyxNQUFoQixLQUEwQixNQUExQzthQUFBLElBQUMsQ0FBQSxNQUFELElBQVcsRUFBWDs7RUFYVTs7bUJBYVosYUFBQSxHQUFlLFNBQUE7V0FDYjtNQUFBLE1BQUEsRUFBUSxJQUFDLENBQUEsYUFBVDtNQUNBLE9BQUEsRUFBUyxJQUFDLENBQUEsZ0JBRFY7TUFFQSxLQUFBLEVBQU8sSUFBQyxDQUFBLGNBQWMsQ0FBQyxLQUZ2Qjs7RUFEYTs7RUFLZixTQUFBLEdBQVksU0FBQyxHQUFEO0FBQ1YsV0FBUSxHQUFBLEtBQU87RUFETDs7RUFHWixlQUFBLEdBQWtCLFNBQUMsR0FBRCxFQUFNLEdBQU4sRUFBVyxLQUFYLEVBQWtCLFVBQWxCLEVBQThCLGNBQTlCLEVBQThDLE9BQTlDO0FBQ2hCLFFBQUE7SUFBQSxJQUF5QixXQUF6QjtNQUFBLFNBQUEsR0FBWSxHQUFHLENBQUMsTUFBaEI7O0lBQ0EsSUFBNkIsYUFBN0I7TUFBQSxXQUFBLEdBQWMsS0FBSyxDQUFDLE1BQXBCOztJQUVBLFVBQUEsR0FBYTtJQUNiLFlBQUEsR0FBZTtJQUNmLFdBQUEsR0FBYztJQUNkLEtBQUEsR0FBUTtJQUNSLFlBQUEsR0FBZTtJQUNmLFVBQUEsR0FBYTtJQUViLFdBQUEsR0FDRTtNQUFBLFVBQUEsRUFBWSxTQUFBLENBQVUsY0FBZSxDQUFBLFlBQUEsQ0FBekIsQ0FBWjtNQUNBLGFBQUEsRUFBZSxTQUFBLENBQVUsY0FBZSxDQUFBLGVBQUEsQ0FBekIsQ0FEZjtNQUVBLGdCQUFBLEVBQWtCLFNBQUEsQ0FBVSxjQUFlLENBQUEsa0JBQUEsQ0FBekIsQ0FGbEI7TUFHQSxNQUFBLEVBQVEsT0FBTyxDQUFDLFdBSGhCOztJQUtGLElBQUcsV0FBSDtNQUNFLFdBQUEsR0FBa0IsR0FBRyxDQUFDLE1BQU0sQ0FBQyxNQUFYLEdBQW9CLENBQXhCLEdBQWdDLElBQWhDLEdBQTBDO0FBQ3hEO0FBQUEsV0FBQSw2Q0FBQTs7UUFDRSxJQUFZLENBQUMsQ0FBQyxPQUFGLENBQVUsS0FBVixDQUFaO0FBQUEsbUJBQUE7O1FBQ0EsQ0FBQyxDQUFDLElBQUYsQ0FBTyxLQUFQLEVBQWMsU0FBQyxJQUFEO2lCQUFVLElBQUksQ0FBQyxRQUFMLENBQWMsU0FBZDtRQUFWLENBQWQ7UUFDQSxLQUFBLEdBQVksSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQVQsQ0FBZSxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQXhCLENBQWdDLENBQzFDLE9BRFUsQ0FDRixHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFEbEI7UUFFWixLQUFLLENBQUMsWUFBTixDQUFtQixLQUFuQjtRQUNBLFVBQVUsQ0FBQyxJQUFYLENBQWdCLEtBQWhCO1FBRUEsSUFBRyxjQUFlLENBQUEsV0FBQSxDQUFmLEtBQStCLE1BQWxDO1VBQ0UsSUFBRyxXQUFIO1lBQ0UsV0FBVyxDQUFDLGNBQVosR0FBZ0MsQ0FBQSxLQUFLLENBQVIsR0FBZSxDQUFmLEdBQXNCLENBQUMsRUFEdEQ7V0FBQSxNQUFBO1lBR0UsV0FBVyxDQUFDLGNBQVosR0FBZ0MsY0FBZSxDQUFBLG9CQUFBLENBQWYsS0FBd0MsTUFBM0MsR0FBdUQsQ0FBQyxDQUF4RCxHQUErRCxFQUg5Rjs7VUFLQSxXQUFXLENBQUMsVUFBWixHQUF5QjtVQUN6QixLQUFBLEdBQVEsS0FBSyxDQUFDLE1BQU4sQ0FBYSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFkLENBQTRCLEtBQUssQ0FBQyxZQUFOLENBQUEsQ0FBNUIsRUFBa0QsV0FBbEQsQ0FBYixFQVBWOztBQVJGO01BaUJBLFlBQUEsR0FBZTtNQUNmLFVBQUEsR0FBYSxVQXBCZjs7SUFzQkEsV0FBVyxDQUFDLFVBQVosR0FBeUIsU0FBQSxDQUFVLGNBQWUsQ0FBQSxZQUFBLENBQXpCO0lBRXpCLElBQUcsYUFBSDtNQUNFLFdBQUEsR0FBa0IsS0FBSyxDQUFDLE1BQU0sQ0FBQyxNQUFiLEdBQXNCLENBQTFCLEdBQWtDLElBQWxDLEdBQTRDO0FBQzFEO0FBQUEsV0FBQSxnREFBQTs7UUFDRSxJQUFZLENBQUMsQ0FBQyxPQUFGLENBQVUsS0FBVixDQUFaO0FBQUEsbUJBQUE7O1FBQ0EsY0FBQSxHQUFvQixDQUFBLEtBQUssQ0FBUixHQUFlLENBQWYsR0FBc0IsQ0FBQztRQUN4QyxDQUFDLENBQUMsSUFBRixDQUFPLEtBQVAsRUFBYyxTQUFDLElBQUQ7aUJBQVUsSUFBSSxDQUFDLFFBQUwsQ0FBYyxXQUFkO1FBQVYsQ0FBZDtRQUVBLEtBQUEsR0FBWSxJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBVCxDQUFlLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBeEIsQ0FBZ0MsQ0FDMUMsT0FEVSxDQUNGLEdBQUcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLElBQUksQ0FBQyxJQURsQjtRQUVaLEtBQUssQ0FBQyxZQUFOLENBQW1CLEtBQW5CO1FBQ0EsWUFBWSxDQUFDLElBQWIsQ0FBa0IsS0FBbEI7UUFDQSxJQUFHLFdBQUg7VUFDRSxXQUFXLENBQUMsY0FBWixHQUE2QjtVQUM3QixLQUFBLEdBQVEsS0FBSyxDQUFDLE1BQU4sQ0FBYSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFkLENBQTRCLEtBQTVCLEVBQW1DLFdBQW5DLENBQWIsRUFGVjtTQUFBLE1BQUE7VUFJRSxXQUFXLENBQUMsY0FBWixHQUE2QjtVQUM3QixLQUFBLEdBQVEsS0FBSyxDQUFDLE1BQU4sQ0FBYSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxhQUFkLENBQTRCLEtBQTVCLEVBQW1DLFdBQW5DLENBQWIsRUFMVjs7QUFURjtNQWdCQSxZQUFBLEdBQWU7TUFDZixVQUFBLEdBQWEsWUFuQmY7O0FBcUJBLFNBQUEsOENBQUE7O01BQ0UsSUFBWSxDQUFDLENBQUMsT0FBRixDQUFVLEtBQVYsQ0FBWjtBQUFBLGlCQUFBOztNQUNBLENBQUMsQ0FBQyxJQUFGLENBQU8sS0FBUCxFQUFjLFNBQUMsS0FBRDtlQUFXLEtBQUssQ0FBQyxRQUFOLENBQWUsVUFBZjtNQUFYLENBQWQ7TUFDQSxLQUFBLEdBQVksSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQVQsQ0FBZSxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQXhCLENBQWdDLENBQ3hDLE9BRFEsQ0FDQSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFEcEI7TUFFWixLQUFLLENBQUMsWUFBTixDQUFtQixLQUFuQjtNQUNBLFdBQVcsQ0FBQyxJQUFaLENBQWlCLEtBQWpCO0FBTkY7SUFRQSxJQUFHLG9CQUFIO01BQ0UsYUFBQSxHQUFnQjtNQUNoQixTQUFBLEdBQWdCLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFULENBQUE7TUFDaEIsV0FBQSxHQUFjO01BRWQsSUFBRyxXQUFIO1FBQ0UsSUFBQSxDQUF3QyxDQUFDLENBQUMsT0FBRixDQUFVLFVBQVYsQ0FBeEM7VUFBQSxTQUFTLENBQUMsVUFBVixDQUFxQixVQUFyQixFQUFBOztRQUNBLGFBQUEsR0FBZ0IsV0FGbEI7O01BSUEsSUFBRyxhQUFIO1FBQ0UsSUFBQSxDQUEwQyxDQUFDLENBQUMsT0FBRixDQUFVLFlBQVYsQ0FBMUM7VUFBQSxTQUFTLENBQUMsVUFBVixDQUFxQixZQUFyQixFQUFBOztRQUNBLGFBQUEsR0FBZ0IsYUFBYSxDQUFDLE1BQWQsQ0FBcUIsWUFBckI7UUFDaEIsSUFBc0IsWUFBWSxDQUFDLE1BQWIsR0FBc0IsQ0FBNUM7VUFBQSxXQUFBLEdBQWMsS0FBZDtTQUhGOztNQUtBLElBQUcsQ0FBSSxDQUFDLENBQUMsT0FBRixDQUFVLFVBQVYsQ0FBSixJQUE4QixDQUFJLENBQUMsQ0FBQyxPQUFGLENBQVUsV0FBVixDQUFyQztRQUNFLFNBQVMsQ0FBQyxVQUFWLENBQXFCLFdBQXJCO1FBQ0EsYUFBQSxHQUFnQixhQUFhLENBQUMsTUFBZCxDQUFxQixXQUFyQixFQUZsQjs7TUFJQSxJQUFBLENBQXdGLENBQUMsQ0FBQyxPQUFGLENBQVUsYUFBVixDQUF4RjtRQUFBLFNBQVMsQ0FBQyxhQUFWLENBQXdCLGFBQXhCLEVBQXVDLFlBQXZDLEVBQXFEO1VBQUMsV0FBQSxFQUFhLFdBQWQ7U0FBckQsRUFBQTs7TUFFQSxJQUE2RCxXQUE3RDtRQUFBLENBQUMsQ0FBQyxJQUFGLENBQU8sVUFBUCxFQUFtQixTQUFDLEtBQUQ7aUJBQVcsS0FBSyxDQUFDLElBQU4sQ0FBVyxHQUFYLEVBQWdCLFNBQWhCO1FBQVgsQ0FBbkIsRUFBQTs7TUFDQSxJQUFpRSxhQUFqRTtRQUFBLENBQUMsQ0FBQyxJQUFGLENBQU8sWUFBUCxFQUFxQixTQUFDLEtBQUQ7aUJBQVcsS0FBSyxDQUFDLElBQU4sQ0FBVyxHQUFYLEVBQWdCLFdBQWhCO1FBQVgsQ0FBckIsRUFBQTs7TUFDQSxDQUFDLENBQUMsSUFBRixDQUFPLEtBQVAsRUFBYyxTQUFDLElBQUQ7ZUFBVSxJQUFJLENBQUMsVUFBTCxDQUFnQixHQUFoQixDQUFvQixDQUFDLElBQXJCLENBQUE7TUFBVixDQUFkO01BQ0EsSUFBK0QsQ0FBSSxDQUFDLENBQUMsT0FBRixDQUFVLFVBQVYsQ0FBbkU7UUFBQSxDQUFDLENBQUMsSUFBRixDQUFPLFdBQVAsRUFBb0IsU0FBQyxLQUFEO2lCQUFXLEtBQUssQ0FBQyxJQUFOLENBQVcsR0FBWCxFQUFnQixVQUFoQjtRQUFYLENBQXBCLEVBQUE7O01BRUEsSUFBRyxhQUFBLElBQVMsZUFBWjtRQUNFLENBQUssSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLGNBQVQsQ0FBd0IsS0FBSyxDQUFDLEtBQTlCLEVBQXFDLEdBQUcsQ0FBQyxLQUF6QyxDQUFMLENBQXFELENBQUMsVUFBdEQsQ0FBaUUsR0FBakUsQ0FBcUUsQ0FBQyxJQUF0RSxDQUFBLEVBREY7O01BR0EsSUFBRyxhQUFIO2VBQWUsYUFBZjtPQUFBLE1BQUE7ZUFBaUMsV0FBakM7T0E1QkY7O0VBdEVnQjs7bUJBb0dsQixNQUFBLEdBQVEsU0FBQyxRQUFEO0FBQ04sUUFBQTtJQUFBLENBQUEsQ0FBRSxVQUFGLEVBQWMsSUFBQyxDQUFBLE9BQWY7SUFDQSxJQUFDLENBQUEsVUFBRCxDQUFBO0lBQ0EsUUFBUSxDQUFDLE1BQVQsQ0FBZ0IsSUFBQyxDQUFBLGNBQWMsQ0FBQyxLQUFoQixHQUF3QixJQUFDLENBQUEsY0FBYyxDQUFDLEtBQXhELEVBQ0ksQ0FBQyxJQUFDLENBQUEsTUFBRCxHQUFVLElBQUMsQ0FBQSxPQUFPLENBQUMsY0FBcEIsQ0FBQSxHQUFzQyxJQUFDLENBQUEsY0FBYyxDQUFDLEtBRDFEO0lBRUEsR0FBQSxHQUFNLFFBQVEsQ0FBQyxVQUFULENBQUE7SUFDTixHQUFHLENBQUMsS0FBSixDQUFVLElBQUMsQ0FBQSxjQUFjLENBQUMsS0FBMUIsRUFBaUMsSUFBQyxDQUFBLGNBQWMsQ0FBQyxLQUFqRDtJQUNBLEdBQUcsQ0FBQyxLQUFKLENBQUE7SUFDQSxHQUFHLENBQUMsT0FBSixDQUFZLElBQUMsQ0FBQSxPQUFPLENBQUMsU0FBckIsRUFBZ0MsSUFBQyxDQUFBLE9BQU8sQ0FBQyxTQUF6QyxFQUFvRCxFQUFwRDtJQUVBLElBQUMsQ0FBQSxnQkFBRCxHQUFvQjtJQUVwQixNQUFBLEdBQVMsU0FBQyxLQUFELEVBQVEsS0FBUjtBQUNQLFVBQUE7TUFBQSxTQUFBLEdBQVksQ0FBQyxDQUFDLElBQUYsQ0FBTyxLQUFQO01BQ1osSUFBRyxTQUFBLFlBQXFCLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBakM7UUFDRSxLQUFLLENBQUMsR0FBTixDQUFBO2VBQ0EsS0FBSyxDQUFDLGFBQU4sQ0FBb0IsU0FBUyxDQUFDLE9BQVYsQ0FBQSxDQUFwQixFQUZGOztJQUZPO0FBTVQ7QUFBQSxTQUFBLHFDQUFBOztNQUNFLENBQUEsQ0FBRSxtQkFBRjtNQUVBLElBQXNDLGlCQUF0QztRQUFBLE1BQUEsQ0FBTyxLQUFLLENBQUMsR0FBYixFQUFrQixLQUFLLENBQUMsU0FBeEIsRUFBQTs7TUFDQSxJQUF3QyxrQkFBeEM7UUFBQSxNQUFBLENBQU8sS0FBSyxDQUFDLElBQWIsRUFBbUIsS0FBSyxDQUFDLFVBQXpCLEVBQUE7O01BRUEsSUFBb0MsaUJBQXBDO1FBQUEsS0FBSyxDQUFDLEdBQUcsQ0FBQyxVQUFWLENBQXFCLEdBQXJCLENBQXlCLENBQUMsSUFBMUIsQ0FBQSxFQUFBOztNQUNBLElBQXFDLGtCQUFyQztRQUFBLEtBQUssQ0FBQyxJQUFJLENBQUMsVUFBWCxDQUFzQixHQUF0QixDQUEwQixDQUFDLElBQTNCLENBQUEsRUFBQTs7TUFFQSxLQUFLLENBQUMsVUFBVSxDQUFDLElBQWpCLENBQXNCLEtBQUssQ0FBQyxTQUE1QjtNQUNBLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBbEIsQ0FBdUIsS0FBSyxDQUFDLFVBQTdCO01BRUEsTUFBQSxHQUFTLGVBQUEsQ0FBZ0IsR0FBaEIsRUFDVSxpQkFBSCxHQUFtQjtRQUFDLEtBQUEsRUFBTyxLQUFLLENBQUMsR0FBZDtRQUFtQixNQUFBLEVBQVEsS0FBSyxDQUFDLFVBQWpDO09BQW5CLEdBQXFFLElBRDVFLEVBRVUsa0JBQUgsR0FBb0I7UUFBQyxLQUFBLEVBQU8sS0FBSyxDQUFDLElBQWQ7UUFBb0IsTUFBQSxFQUFRLEtBQUssQ0FBQyxXQUFsQztPQUFwQixHQUF3RSxJQUYvRSxFQUdPLEtBQUssQ0FBQyxXQUhiLEVBSU8sSUFBQyxDQUFBLGNBSlIsRUFLTztRQUFDLFdBQUEsRUFBYSxLQUFLLENBQUMsV0FBcEI7T0FMUDtNQU9ULElBQUMsQ0FBQSxhQUFhLENBQUMsSUFBZixDQUFvQixNQUFwQjtBQW5CRjtJQXFCQSxDQUFBLENBQUUsOEJBQUY7QUFDQTtBQUFBLFNBQUEsd0NBQUE7O01BQ0UsWUFBWSxDQUFDLFVBQWIsQ0FBd0IsR0FBeEIsQ0FBNEIsQ0FBQyxJQUE3QixDQUFBO0FBREY7SUFHQSxDQUFBLENBQUUsK0JBQUY7QUFDQTtBQUFBLFNBQUEsd0NBQUE7O01BQ0UsWUFBWSxDQUFDLFVBQWIsQ0FBd0IsR0FBeEIsQ0FBNEIsQ0FBQyxJQUE3QixDQUFBO0FBREY7SUFHQSxJQUFHLG1CQUFIO01BQ0UsSUFBRyxJQUFDLENBQUEsY0FBYyxDQUFDLE1BQWhCLEtBQTBCLE1BQTdCO1FBQ0UsSUFBQyxDQUFBLE1BQU0sQ0FBQyxRQUFSLENBQWlCLFFBQUEsQ0FBUyxJQUFDLENBQUEsY0FBYyxDQUFDLEtBQXpCLEVBQWdDLEVBQWhDLENBQWpCO1FBQ0EsSUFBQyxDQUFBLE1BQU0sQ0FBQyxhQUFSLENBQXNCLElBQUMsQ0FBQSxjQUFjLENBQUMsVUFBdEM7UUFDQSxJQUFDLENBQUEsTUFBTSxDQUFDLE1BQVIsQ0FBQSxFQUhGO09BQUEsTUFBQTtRQUtFLElBQUMsQ0FBQSxNQUFNLENBQUMsY0FBUixDQUFBLEVBTEY7T0FERjs7SUFPQSxJQUFDLENBQUEsUUFBRCxHQUFZO0lBRVosSUFBQSxDQUFPLE1BQU0sQ0FBQyxNQUFkO01BQ0UsSUFBQSxHQUFPO01BQ1AsS0FBQSxHQUFRLEdBQUcsQ0FBQyxXQUFKLENBQWdCLElBQWhCLENBQXFCLENBQUM7TUFDOUIsR0FBRyxDQUFDLElBQUosQ0FBQTtNQUNBLEdBQUcsQ0FBQyxPQUFKLENBQVksT0FBWixFQUFxQixFQUFyQixFQUF5QixRQUF6QjtNQUNBLEdBQUcsQ0FBQyxRQUFKLENBQWEsSUFBYixFQUFtQixDQUFDLElBQUMsQ0FBQSxjQUFjLENBQUMsS0FBaEIsR0FBd0IsS0FBekIsQ0FBQSxHQUFrQyxDQUFyRCxFQUF3RCxJQUFDLENBQUEsTUFBRCxHQUFVLEVBQWxFO2FBQ0EsR0FBRyxDQUFDLE9BQUosQ0FBQSxFQU5GOztFQXhETTs7bUJBZ0VSLFVBQUEsR0FBWSxTQUFBO1dBQUcsSUFBQyxDQUFBO0VBQUo7O21CQUVaLElBQUEsR0FBTSxTQUFDLFFBQUQ7V0FBYyxJQUFDLENBQUEsTUFBRCxDQUFRLFFBQVI7RUFBZDs7bUJBTU4sY0FBQSxHQUFnQixTQUFDLElBQUQsRUFBTyxNQUFQO0FBQ2QsUUFBQTtJQUFBLElBQUEsR0FBTyxJQUFDLENBQUEsTUFBTSxDQUFDLGNBQVIsQ0FBdUIsSUFBdkIsRUFBNkIsTUFBN0I7SUFDUCxVQUFBLEdBQWEsR0FBRyxDQUFDLElBQUksQ0FBQyxhQUFULENBQXVCLElBQXZCO0lBRWIsYUFBQSxHQUFnQixJQUFDLENBQUEsV0FBVyxDQUFDLFVBQWIsQ0FBd0IsVUFBVSxDQUFDLEdBQW5DO0lBQ2hCLFVBQUEsR0FBYTtBQUdiLFlBQU8sSUFBQyxDQUFBLGNBQWMsQ0FBQyxXQUF2QjtBQUFBLFdBQ08sVUFEUDtRQUVJLElBQUcsYUFBYSxDQUFDLE1BQWpCO1VBQ0UsVUFBQSxHQUFnQixnQ0FBSCxHQUFrQyxhQUFhLENBQUMsVUFBaEQsR0FBZ0UsSUFEL0U7O0FBREc7QUFEUCxXQUlPLFlBSlA7UUFLSSxJQUFHLGFBQWEsQ0FBQyxNQUFqQjtVQUNFLFVBQUEsR0FBZ0IsZ0NBQUgsR0FBa0MsYUFBYSxDQUFDLFVBQWhELEdBQWdFLElBRC9FO1NBQUEsTUFBQTtVQUdFLFVBQUEsR0FBZ0IsZ0NBQUgsR0FBa0MsYUFBYSxDQUFDLFVBQWQsR0FBMkIsSUFBN0QsR0FBQSxPQUhmOztBQURHO0FBSlA7QUFVSSxjQUFVLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxhQUFULEVBQXdCLDBDQUFBLEdBQTJDLElBQUMsQ0FBQSxjQUFjLENBQUMsV0FBbkY7QUFWZDtJQVlBLFFBQUEsR0FBVyxhQUFhLENBQUM7SUFDekIsVUFBQSxHQUFhLFVBQVUsQ0FBQztJQUd4QixRQUFBLEdBQVcsSUFBQyxDQUFBLFNBQVMsQ0FBQyxZQUFYLENBQXdCLFVBQVUsQ0FBQyxHQUFuQyxDQUF1QyxDQUFDO0lBQ25ELFFBQUEsR0FBVyxJQUFDLENBQUEsU0FBUyxDQUFDLFlBQVgsQ0FBd0IsYUFBYSxDQUFDLElBQXRDLENBQTJDLENBQUM7SUFJdkQsSUFBRyxRQUFBLEtBQVksR0FBWixJQUFvQixRQUFBLEtBQVksR0FBbkM7TUFDRSxVQUFBLEdBREY7S0FBQSxNQUVLLElBQUcsUUFBQSxLQUFZLEdBQVosSUFBb0IsUUFBQSxLQUFZLEdBQW5DO01BQ0gsVUFBQSxHQURHOztBQUdMLFdBQU8sQ0FBQyxRQUFELEVBQVcsVUFBWCxFQUF1QixVQUF2QjtFQWxDTzs7bUJBb0NoQixhQUFBLEdBQWUsU0FBQyxHQUFELEVBQU0sTUFBTjtBQUNiLFFBQUE7SUFBQSxHQUFBLEdBQU0sR0FBRyxDQUFDO0lBQ1YsTUFBQSxHQUFTO0lBQ1QsVUFBQSxHQUFhLEdBQUcsQ0FBQztJQUNqQixJQUEyQywyQkFBM0M7TUFBQSxVQUFBLElBQWMsR0FBQSxHQUFJLEdBQUcsQ0FBQyxnQkFBdEI7O0FBQ0EsV0FBTyxDQUFDLEdBQUQsRUFBTSxNQUFOLEVBQWMsVUFBZDtFQUxNOzttQkFPZixZQUFBLEdBQWMsU0FBQyxXQUFEO0FBQ1osUUFBQTtJQUFBLE1BQUEsR0FDRTtNQUFBLE9BQUEsRUFBUyxLQUFUO01BQ0EsU0FBQSxFQUFXLElBRFg7O0lBR0YsQ0FBQyxDQUFDLE1BQUYsQ0FBUyxNQUFULEVBQWlCLFdBQWpCO0lBQ0EsV0FBQSxHQUFjLENBQUMsQ0FBQyxJQUFGLENBQU8sSUFBQyxDQUFBLE1BQVIsQ0FBZSxDQUFDO0lBQzlCLFVBQUEsR0FBaUIsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVQsQ0FBbUI7TUFDbEMsSUFBQSxFQUFNLE1BQU0sQ0FBQyxJQURxQjtNQUVsQyxRQUFBLEVBQVUsSUFBQyxDQUFBLGdCQUFELEdBQW9CLENBQUksTUFBTSxDQUFDLE9BQVYsR0FBdUIsR0FBdkIsR0FBZ0MsRUFBakMsQ0FGSTtNQUdsQyxJQUFBLEVBQVMsTUFBTSxDQUFDLE9BQVYsR0FBdUIsUUFBdkIsR0FBcUMsSUFBQyxDQUFBLFlBSFY7TUFJbEMsU0FBQSxFQUFjLE1BQU0sQ0FBQyxPQUFWLEdBQXVCLEtBQXZCLEdBQWtDLElBSlg7S0FBbkI7QUFNakI7QUFBQSxTQUFBLHFEQUFBOztNQUNFLElBQUcsV0FBSDtRQUNFLEtBQUEsR0FBUSxHQUFHLENBQUMsS0FBSixDQUFVLEdBQVY7UUFDUixjQUFBLEdBQXFCLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFULENBQW9CLEtBQU0sQ0FBQSxDQUFBLENBQTFCO1FBRXJCLElBQUcsS0FBSyxDQUFDLE1BQU4sR0FBZSxDQUFmLElBQXFCLEtBQU0sQ0FBQSxDQUFBLENBQU4sS0FBWSxHQUFwQztVQUNFLGNBQWMsQ0FBQyxlQUFmLENBQUEsRUFERjs7UUFHQSxVQUFVLENBQUMsYUFBWCxDQUF5QixLQUF6QixFQUFnQyxjQUFoQyxFQVBGOztBQURGO0lBVUEsSUFBRyxJQUFDLENBQUEsZ0JBQWlCLENBQUEsSUFBQyxDQUFBLGdCQUFnQixDQUFDLE1BQWxCLEdBQTJCLENBQTNCLENBQWxCLEtBQW1ELEdBQXREO01BQ0UsVUFBVSxDQUFDLFdBQVgsQ0FBQSxFQURGOztJQUdBLElBQTRDLHdCQUE1QztNQUFBLFVBQVUsQ0FBQyxXQUFYLENBQXVCLE1BQU0sQ0FBQyxTQUE5QixFQUFBOztXQUNBLFdBQVcsQ0FBQyxJQUFaLENBQWlCLFVBQWpCO0VBM0JZOzttQkE2QmQsVUFBQSxHQUFZLFNBQUMsSUFBRCxFQUFPLFNBQVA7QUFDVixRQUFBOztNQURpQixZQUFVOztJQUMzQixTQUFBLEdBQVksQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsTUFBUixDQUFlLENBQUM7SUFDNUIsWUFBQSxHQUFtQixJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBVCxDQUFpQjtNQUNsQyxTQUFBLEVBQVcsSUFEdUI7TUFFbEMsUUFBQSxFQUFVLElBQUMsQ0FBQSxnQkFGdUI7S0FBakIsRUFHYixJQUFDLENBQUEsY0FBZSxDQUFBLFdBQUEsQ0FBaEIsS0FBZ0MsTUFIbkI7SUFLbkIsSUFBdUMsaUJBQXZDO01BQUEsWUFBWSxDQUFDLFdBQWIsQ0FBeUIsU0FBekIsRUFBQTs7SUFDQSxTQUFTLENBQUMsSUFBVixDQUFlLFlBQWY7SUFFQSxJQUFHLElBQUMsQ0FBQSxnQkFBaUIsQ0FBQSxJQUFDLENBQUEsZ0JBQWdCLENBQUMsTUFBbEIsR0FBMkIsQ0FBM0IsQ0FBbEIsS0FBbUQsR0FBdEQ7YUFDRSxZQUFZLENBQUMsTUFBYixDQUFBLEVBREY7O0VBVlU7O0VBYVosWUFBQSxHQUFlLFNBQUMsSUFBRCxFQUFPLEdBQVA7V0FBZSxJQUFBLEdBQU8sQ0FBSSxHQUFILEdBQVksR0FBWixHQUFxQixFQUF0QjtFQUF0Qjs7bUJBQ2YsV0FBQSxHQUFhLFNBQUMsSUFBRCxFQUFPLEdBQVA7QUFDWCxRQUFBOztNQURrQixNQUFJOztJQUN0QixDQUFBLEdBQUksSUFBSSxDQUFDLEtBQUwsQ0FBVyxLQUFYO0lBQ0osQ0FBQSxDQUFFLGVBQUYsRUFBbUIsQ0FBRSxDQUFBLENBQUEsQ0FBckIsRUFBeUIsR0FBekI7V0FDQSxJQUFDLENBQUEsZ0JBQUQsR0FBb0IsWUFBQSxDQUFhLENBQUUsQ0FBQSxDQUFBLENBQWYsRUFBbUIsR0FBbkI7RUFIVDs7bUJBS2IsTUFBQSxHQUFRLFNBQUMsSUFBRDtBQUNOLFFBQUE7SUFBQSxDQUFBLENBQUUsVUFBRixFQUFjLElBQWQ7SUFDQSxJQUFDLENBQUEsVUFBRCxDQUFBO0lBQ0EsSUFBQyxDQUFBLFdBQVcsQ0FBQyxLQUFiLENBQUE7SUFDQSxLQUFBLEdBQVEsQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsTUFBUjtJQUVSLElBQUEsR0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN4QixJQUFBO0FBQU8sY0FBTyxJQUFQO0FBQUEsYUFDQSxRQURBO2lCQUVILElBQUksQ0FBQztBQUZGLGFBR0EsUUFIQTtpQkFJSCxJQUFJLENBQUM7QUFKRixhQUtBLEtBTEE7aUJBTUgsSUFBSSxDQUFDO0FBTkYsYUFPQSxjQVBBO2lCQVFILElBQUksQ0FBQztBQVJGLGFBU0EsWUFUQTtpQkFVSCxJQUFJLENBQUM7QUFWRixhQVdBLGFBWEE7aUJBWUgsSUFBSSxDQUFDO0FBWkY7aUJBY0gsSUFBSSxDQUFDO0FBZEY7O0lBZ0JQLFFBQUEsR0FBZSxJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBVCxDQUFBLENBQWtCLENBQUMsT0FBbkIsQ0FBMkIsSUFBM0I7SUFDZixLQUFLLENBQUMsU0FBUyxDQUFDLElBQWhCLENBQXFCLFFBQXJCO0lBQ0EsSUFBbUMsa0JBQW5DO2FBQUEsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFqQixDQUFzQixRQUF0QixFQUFBOztFQXpCTTs7RUEyQlIsUUFBQSxHQUFXLFNBQUMsU0FBRCxFQUFZLE9BQVo7QUFDVCxRQUFBO0lBQUEsU0FBQSxHQUFZLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQzFCLElBQUEsR0FBTztJQUVQLElBQUcsUUFBQSxDQUFTLFNBQVQsRUFBb0IsRUFBcEIsQ0FBQSxHQUEwQixRQUFBLENBQVMsT0FBVCxFQUFrQixFQUFsQixDQUE3QjtNQUNFLFNBQUEsR0FBWSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUQ1QjtLQUFBLE1BQUE7TUFHRSxJQUFBO0FBQU8sZ0JBQU8sSUFBSSxDQUFDLEdBQUwsQ0FBUyxPQUFBLEdBQVUsU0FBbkIsQ0FBUDtBQUFBLGVBQ0EsQ0FEQTttQkFDTztBQURQLGVBRUEsQ0FGQTttQkFFTztBQUZQLGVBR0EsQ0FIQTttQkFHTztBQUhQO21CQUlBLFVBQUEsR0FBVztBQUpYO1dBSFQ7O0FBU0EsV0FBTztNQUFDLElBQUEsRUFBTSxTQUFQO01BQWtCLElBQUEsRUFBTSxJQUF4Qjs7RUFiRTs7bUJBZVgsU0FBQSxHQUFXLFNBQUMsVUFBRCxFQUFhLFNBQWIsRUFBd0IsYUFBeEIsRUFBdUMsWUFBdkM7QUFDVCxRQUFBO0lBQUEsQ0FBQSxDQUFFLFdBQUYsRUFBZSxVQUFmLEVBQTJCLFNBQTNCLEVBQXNDLGFBQXRDLEVBQXFELFlBQXJEO0lBQ0EsU0FBQSxHQUFZLENBQUMsQ0FBQyxJQUFGLENBQU8sSUFBQyxDQUFBLE1BQVIsQ0FBZSxDQUFDO0lBRTVCLFVBQUEsR0FBYTtJQUNiLGFBQUEsR0FBZ0I7SUFDaEIsSUFBRyxDQUFDLENBQUMsT0FBRixDQUFVLElBQUMsQ0FBQSxhQUFYLENBQUg7TUFDRSxJQUFDLENBQUEsZ0JBQUQsR0FBb0IsU0FBUyxDQUFDLE1BQVYsR0FBbUI7TUFDdkMsSUFBQyxDQUFBLGtCQUFELEdBQXNCLGNBRnhCO0tBQUEsTUFBQTtNQUlFLFVBQUEsR0FBYSxTQUFVLENBQUEsSUFBQyxDQUFBLGdCQUFEO01BQ3ZCLGFBQUEsR0FBZ0IsSUFBQyxDQUFBLG1CQUxuQjs7SUFPQSxXQUFBLEdBQWMsVUFBVSxDQUFDLFlBQVgsQ0FBQTtJQUNkLFVBQUEsR0FBYSxTQUFTLENBQUMsWUFBVixDQUFBO0FBQ2I7U0FBQSx1REFBQTs7TUFDRSxVQUFBLEdBQWEsWUFBYSxDQUFBLENBQUE7TUFDMUIsU0FBQSxHQUFZLFVBQVUsQ0FBQyxZQUFYLENBQUEsQ0FBMEIsQ0FBQSxhQUFjLENBQUEsQ0FBQSxDQUFkO01BQ3RDLE9BQUEsR0FBVSxVQUFXLENBQUEsVUFBQTs7WUFDTixDQUFBLEtBQUEsSUFBVTs7bUJBQ3pCLElBQUMsQ0FBQSxhQUFjLENBQUEsS0FBQSxDQUFNLENBQUMsSUFBdEIsQ0FBMkIsUUFBQSxDQUFTLFNBQVMsQ0FBQyxJQUFuQixFQUF5QixPQUFPLENBQUMsSUFBakMsQ0FBM0I7QUFMRjs7RUFmUzs7bUJBdUJYLFVBQUEsR0FBWSxTQUFDLE1BQUQ7QUFDVixRQUFBOztNQURXLFNBQU87O0lBQ2xCLElBQWMsNkJBQWQ7QUFBQSxhQUFBOztJQUNBLENBQUEsQ0FBRSxhQUFBLEdBQWMsTUFBZCxHQUFxQixHQUF2QjtJQUNBLFNBQUEsR0FBWSxDQUFDLENBQUMsSUFBRixDQUFPLElBQUMsQ0FBQSxNQUFSLENBQWUsQ0FBQztBQUM1QjtBQUFBLFNBQUEsUUFBQTs7TUFDRSxNQUFBLEdBQVM7QUFDVCxXQUFBLG1DQUFBOztRQUNFLE1BQU0sQ0FBQyxJQUFQLENBQVksSUFBWjtBQURGO01BRUEsU0FBVSxDQUFBLElBQUMsQ0FBQSxnQkFBRCxDQUFrQixDQUFDLFdBQTdCLENBQ00sSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQVQsQ0FBYyxJQUFkLEVBQW9CLElBQXBCLEVBQTBCLE1BQTFCLENBRE4sRUFDeUMsQ0FEekM7QUFKRjtBQVFBO0FBQUEsU0FBQSx3Q0FBQTs7TUFDRSxRQUFRLENBQUMsUUFBVCxDQUFrQixJQUFsQjtBQURGO0lBR0EsSUFBQyxDQUFBLGFBQUQsR0FBaUI7V0FDakIsSUFBQyxDQUFBLGdCQUFELEdBQW9CO0VBaEJWOzttQkFrQlosV0FBQSxHQUFhLFNBQUMsT0FBRCxFQUFVLEtBQVY7QUFDWCxRQUFBO0lBQUEsQ0FBQSxDQUFFLGFBQUYsRUFBaUIsT0FBakIsRUFBMEIsS0FBMUI7O01BQ0EsUUFBUzs7SUFDVCxJQUFBLENBQWMsQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsTUFBUixDQUFlLENBQUMsSUFBOUI7QUFBQSxhQUFBOztJQUNBLFdBQUEsR0FBYyxDQUFDLENBQUMsSUFBRixDQUFPLElBQUMsQ0FBQSxNQUFSLENBQWUsQ0FBQztJQUM5QixTQUFBLEdBQVksQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsTUFBUixDQUFlLENBQUM7SUFFNUIsSUFBb0UsV0FBVyxDQUFDLE1BQVosR0FBcUIsS0FBekY7QUFBQSxZQUFVLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxhQUFULEVBQXdCLDZCQUF4QixFQUFWOztJQUNBLFFBQUEsR0FBZSxJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBVCxDQUFnQixXQUFZLGtDQUE1QixFQUEyRDtNQUFDLFNBQUEsRUFBVyxPQUFaO0tBQTNEO0lBQ2YsSUFBQyxDQUFBLG1CQUFtQixDQUFDLElBQXJCLENBQTBCLFFBQTFCO0lBS0EsWUFBQSxHQUFtQixJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBVCxDQUFnQixTQUFVLGdDQUExQixFQUF1RDtNQUFDLFNBQUEsRUFBVyxPQUFaO0tBQXZEO0lBQ25CLElBQUcsSUFBQyxDQUFBLGNBQWUsQ0FBQSxXQUFBLENBQWhCLEtBQWdDLE1BQW5DO2FBQ0UsSUFBQyxDQUFBLGlCQUFpQixDQUFDLElBQW5CLENBQXdCLFlBQXhCLEVBREY7O0VBZlc7O0VBa0JiLFlBQUEsR0FBZSxTQUFDLElBQUQ7V0FBVSxJQUFJLENBQUMsS0FBTCxDQUFXLHlCQUFYO0VBQVY7O21CQUNmLGFBQUEsR0FBZSxTQUFDLElBQUQ7QUFDYixRQUFBO0lBQUEsS0FBQSxHQUFRLFlBQUEsQ0FBYSxJQUFiO0lBQ1IsR0FBQSxHQUFNLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDO0lBQ3hCLE9BQUEsR0FBVTtJQUNWLFNBQUEsR0FBWTtJQUVaLElBQUcsYUFBSDtNQUNFLE9BQUE7O0FBQVc7QUFBQTthQUFBLHFDQUFBOzt1QkFBQSxDQUFDLENBQUMsSUFBRixDQUFBO0FBQUE7O1dBRGI7S0FBQSxNQUFBO0FBR0UsYUFBTyxLQUhUOztJQUtBLFlBQUEsR0FBZSxTQUFBO2FBQU8sSUFBQSxHQUFHLENBQUMsSUFBSixDQUFTLGFBQVQsRUFBd0IsaUJBQUEsR0FBa0IsS0FBTSxDQUFBLENBQUEsQ0FBaEQ7SUFBUDtBQUVmLFNBQUEseUNBQUE7O01BQ0UsTUFBQSxHQUFTLE1BQU0sQ0FBQyxLQUFQLENBQWEsZ0NBQWI7TUFDVCxJQUE0QixjQUE1QjtBQUFBLGNBQU0sWUFBQSxDQUFBLEVBQU47O01BRUEsV0FBQSxHQUFjLFFBQUEsQ0FBUyxNQUFPLENBQUEsQ0FBQSxDQUFoQixFQUFvQixFQUFwQixDQUFBLEdBQTBCO01BQ3hDLFFBQUEsR0FBVyxHQUFHLENBQUM7QUFDZixjQUFPLE1BQU8sQ0FBQSxDQUFBLENBQWQ7QUFBQSxhQUNPLEdBRFA7VUFFSSxRQUFBLEdBQVcsR0FBRyxDQUFDO0FBRFo7QUFEUCxhQUdPLEdBSFA7VUFJSSxRQUFBLEdBQVcsR0FBRyxDQUFDO0FBRFo7QUFIUCxhQUtPLEdBTFA7VUFNSSxRQUFBLEdBQVcsR0FBRyxDQUFDO0FBRFo7QUFMUCxhQU9PLEdBUFA7VUFRSSxRQUFBLEdBQVcsR0FBRyxDQUFDO0FBUm5CO01BVUEsUUFBQSxHQUFXO01BQ1gsTUFBQSxHQUFTLE1BQU8sQ0FBQSxDQUFBO0FBQ2hCLGNBQU8sTUFBTyxDQUFBLENBQUEsQ0FBZDtBQUFBLGFBQ08sR0FEUDtVQUVJLFFBQUEsR0FBZSxJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBVCxDQUFzQixNQUF0QixDQUE2QixDQUFDLFdBQTlCLENBQTBDLFFBQTFDO0FBRFo7QUFEUCxhQUdPLEdBSFA7VUFJSSxRQUFBLEdBQWUsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLGNBQVQsQ0FBd0IsTUFBeEIsQ0FBK0IsQ0FBQyxXQUFoQyxDQUE0QyxRQUE1QztBQUpuQjtNQU1BLFNBQVMsQ0FBQyxJQUFWLENBQWU7UUFBQyxHQUFBLEVBQUssV0FBTjtRQUFtQixRQUFBLEVBQVUsUUFBN0I7T0FBZjtBQXhCRjtBQTBCQSxXQUFPO0VBdkNNOztFQXlDZixjQUFBLEdBQWlCLFNBQUMsSUFBRDtXQUFVLElBQUksQ0FBQyxLQUFMLENBQVcsc0JBQVg7RUFBVjs7bUJBQ2pCLFVBQUEsR0FBWSxTQUFDLElBQUQ7QUFDVixRQUFBO0lBQUEsS0FBQSxHQUFRLGNBQUEsQ0FBZSxJQUFmO0lBQ1IsSUFBQSxHQUFPLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDO0lBQ3ZCLElBQUEsR0FBTztJQUVQLElBQUcsYUFBSDtBQUNFLGNBQU8sS0FBTSxDQUFBLENBQUEsQ0FBYjtBQUFBLGFBQ08sSUFEUDtVQUVJLElBQUEsR0FBTyxJQUFJLENBQUM7QUFEVDtBQURQLGFBR08sSUFIUDtVQUlJLElBQUEsR0FBTyxJQUFJLENBQUM7QUFEVDtBQUhQLGFBS08sSUFMUDtVQU1JLElBQUEsR0FBTyxJQUFJLENBQUM7QUFEVDtBQUxQLGFBT08sSUFQUDtVQVFJLElBQUEsR0FBTyxJQUFJLENBQUM7QUFEVDtBQVBQLGFBU08sSUFUUDtVQVVJLElBQUEsR0FBTyxJQUFJLENBQUM7QUFEVDtBQVRQLGFBV08sSUFYUDtVQVlJLElBQUEsR0FBTyxJQUFJLENBQUM7QUFEVDtBQVhQO0FBY0ksZ0JBQVUsSUFBQSxHQUFHLENBQUMsSUFBSixDQUFTLGFBQVQsRUFBd0IsdUJBQUEsR0FBd0IsS0FBTSxDQUFBLENBQUEsQ0FBdEQ7QUFkZDtBQWVBLGFBQVcsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQVQsQ0FBZ0IsSUFBaEIsRUFoQmI7S0FBQSxNQUFBO0FBa0JFLGFBQU8sS0FsQlQ7O0VBTFU7O0VBeUJaLHlCQUFBLEdBQTRCLFNBQUMsSUFBRDtXQUFVLElBQUksQ0FBQyxLQUFMLENBQVcsNEJBQVg7RUFBVjs7bUJBQzVCLHFCQUFBLEdBQXVCLFNBQUMsSUFBRDtBQUNyQixRQUFBO0lBQUEsS0FBQSxHQUFRLHlCQUFBLENBQTBCLElBQTFCO0lBQ1IsSUFBRyxhQUFIO01BQ0UsSUFBQSxHQUFPLEtBQU0sQ0FBQSxDQUFBO01BQ2IsUUFBQSxHQUFXLEtBQU0sQ0FBQSxDQUFBO01BRWpCLE9BQUEsR0FBVSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztNQUM1QixHQUFBLEdBQVMsUUFBQSxLQUFZLEdBQWYsR0FBd0IsT0FBTyxDQUFDLEtBQWhDLEdBQTJDLE9BQU8sQ0FBQztBQUN6RCxhQUFXLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFULENBQXNCLElBQXRCLENBQTJCLENBQUMsV0FBNUIsQ0FBd0MsR0FBeEMsRUFOYjtLQUFBLE1BQUE7QUFPSyxhQUFPLEtBUFo7O0VBRnFCOzttQkFXdkIsY0FBQSxHQUFnQixTQUFDLElBQUQ7QUFDZCxRQUFBO0lBQUEsU0FBQSxHQUFZLElBQUMsQ0FBQSxjQUFlLENBQUEsV0FBQTtJQUM1QixTQUFBLEdBQVksSUFBQyxDQUFBLGNBQWUsQ0FBQSxXQUFBO0lBQzVCLFVBQUEsR0FBYSxJQUFDLENBQUEsY0FBZSxDQUFBLFlBQUE7SUFDN0IsU0FBQSxHQUFZLElBQUMsQ0FBQSxjQUFlLENBQUEscUJBQUE7SUFFNUIsS0FBQSxHQUFRLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVSxDQUFDO0lBQzVCLGFBQUEsR0FBbUIsU0FBQSxLQUFhLEtBQWhCLEdBQTJCLEtBQUssQ0FBQyxHQUFqQyxHQUEwQyxLQUFLLENBQUM7SUFFaEUsTUFBQSxHQUFTLFNBQUMsSUFBRCxFQUFPLElBQVA7O1FBQU8sT0FBSzs7YUFDZixJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVCxDQUFvQixJQUFwQixDQUF5QixDQUMzQixPQURFLENBQ00sU0FETixFQUNpQixTQURqQixFQUM0QixVQUQ1QixDQUN1QyxDQUN6Qyx3QkFGRSxDQUV1QixJQUZ2QjtJQURHO0lBS1QsS0FBQSxHQUFRLElBQUksQ0FBQyxLQUFMLENBQVcsa0NBQVg7SUFDUixJQUFHLGFBQUg7TUFDRSxTQUFBLEdBQVksS0FBTSxDQUFBLENBQUE7TUFDbEIsU0FBQSxHQUFZLEtBQU0sQ0FBQSxDQUFBO01BQ2xCLFVBQUEsR0FBYSxLQUFNLENBQUEsQ0FBQTtNQUNuQixJQUFBLEdBQU8sS0FBTSxDQUFBLENBQUE7TUFDTixJQUFHLElBQUg7ZUFBYSxNQUFBLENBQU8sSUFBUCxFQUFiO09BQUEsTUFBQTtlQUErQixLQUEvQjtPQUxUOztJQU9BLEtBQUEsR0FBUSxJQUFJLENBQUMsS0FBTCxDQUFXLGtCQUFYO0lBQ1IsSUFBRyxhQUFIO01BQ0UsSUFBQSxHQUFPO01BQ1AsSUFBQSxHQUFPLEtBQU0sQ0FBQSxDQUFBO0FBQ2IsY0FBTyxLQUFNLENBQUEsQ0FBQSxDQUFiO0FBQUEsYUFDTyxLQURQO1VBRUksVUFBQSxHQUFhO1VBQ2IsU0FBQSxHQUFZO0FBRlQ7QUFEUCxhQUlPLFFBSlA7QUFBQSxhQUlpQixTQUpqQjtVQUtJLFNBQUEsR0FBWTtVQUNaLFVBQUEsR0FBYTtBQUZBO0FBSmpCLGFBT08sUUFQUDtVQVFJLFNBQUEsR0FBWTtBQURUO0FBUFAsYUFTTyxLQVRQO1VBVUksSUFBQSxHQUFPLEtBQUssQ0FBQztVQUNiLElBQUMsQ0FBQSxjQUFlLENBQUEscUJBQUEsQ0FBaEIsR0FBeUM7QUFGdEM7QUFUUCxhQVlPLFFBWlA7VUFhSSxJQUFBLEdBQU8sS0FBSyxDQUFDO1VBQ2IsSUFBQyxDQUFBLGNBQWUsQ0FBQSxxQkFBQSxDQUFoQixHQUF5QztBQWQ3QztNQWVPLElBQUcsSUFBSDtlQUFhLE1BQUEsQ0FBTyxJQUFQLEVBQWEsSUFBYixFQUFiO09BQUEsTUFBQTtlQUFxQyxLQUFyQztPQWxCVDs7QUFvQkEsV0FBTyxNQUFBLENBQU8sSUFBUDtFQTNDTzs7bUJBNkNoQixjQUFBLEdBQWdCLFNBQUMsV0FBRDtBQUNkLFFBQUE7SUFBQSxLQUFBLEdBQVEsQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsTUFBUjtJQUNSLFdBQUEsR0FBYyxLQUFLLENBQUM7SUFDcEIsU0FBQSxHQUFZLEtBQUssQ0FBQztJQUVsQixJQUFHLFdBQVcsQ0FBQyxNQUFaLEdBQXFCLFNBQVMsQ0FBQyxNQUFsQztBQUNFLFlBQVUsSUFBQSxHQUFHLENBQUMsSUFBSixDQUFTLGFBQVQsRUFBd0IscUNBQXhCLEVBRFo7O0lBSUEsSUFBRyxLQUFLLENBQUMsR0FBVDtBQUNFO0FBQUEsV0FBQSw2Q0FBQTs7UUFDRSxJQUFHLHlCQUFBLENBQTBCLFdBQVksQ0FBQSxDQUFBLENBQXRDLENBQUg7VUFDRSxrQkFBQSxHQUFxQixJQUFDLENBQUEscUJBQUQsQ0FBdUIsV0FBWSxDQUFBLENBQUEsQ0FBbkM7VUFDckIsUUFBUSxDQUFDLFdBQVQsQ0FBcUIsa0JBQXJCLEVBQXlDLENBQXpDLEVBRkY7U0FBQSxNQUdLLElBQUcsY0FBQSxDQUFlLFdBQVksQ0FBQSxDQUFBLENBQTNCLENBQUg7VUFDSCxNQUFBLEdBQVMsSUFBQyxDQUFBLFVBQUQsQ0FBWSxXQUFZLENBQUEsQ0FBQSxDQUF4QjtVQUNULFFBQVEsQ0FBQyxXQUFULENBQXFCLE1BQXJCLEVBQTZCLENBQTdCLEVBRkc7U0FBQSxNQUFBO1VBSUgsVUFBQSxHQUFhLElBQUMsQ0FBQSxjQUFELENBQWdCLFdBQVksQ0FBQSxDQUFBLENBQTVCO1VBQ2IsSUFBNEQsVUFBNUQ7WUFBQSxRQUFRLENBQUMsV0FBVCxDQUFxQixJQUFDLENBQUEsY0FBRCxDQUFnQixXQUFZLENBQUEsQ0FBQSxDQUE1QixDQUFyQixFQUFzRCxDQUF0RCxFQUFBO1dBTEc7O0FBSlAsT0FERjtLQUFBLE1BQUE7QUFZRTtBQUFBLFdBQUEsZ0RBQUE7O1FBQ0UsSUFBQSxDQUFPLHlCQUFBLENBQTBCLFdBQVksQ0FBQSxDQUFBLENBQXRDLENBQVA7VUFDRSxVQUFBLEdBQWEsSUFBQyxDQUFBLGNBQUQsQ0FBZ0IsV0FBWSxDQUFBLENBQUEsQ0FBNUI7VUFDYixJQUEwRCxVQUExRDtZQUFBLElBQUksQ0FBQyxhQUFMLENBQW1CLENBQW5CLEVBQXNCLElBQUMsQ0FBQSxjQUFELENBQWdCLFdBQVksQ0FBQSxDQUFBLENBQTVCLENBQXRCLEVBQUE7V0FGRjs7QUFERixPQVpGOztJQWtCQSxJQUFHLEtBQUssQ0FBQyxJQUFUO0FBQ0U7QUFBQTtXQUFBLGdEQUFBOztRQUNFLGtCQUFBLEdBQXFCLElBQUMsQ0FBQSxxQkFBRCxDQUF1QixXQUFZLENBQUEsQ0FBQSxDQUFuQztRQUNyQixJQUErQywwQkFBL0M7VUFBQSxJQUFJLENBQUMsZUFBTCxDQUFxQixDQUFyQixFQUF3QixrQkFBeEIsRUFBQTs7UUFFQSxNQUFBLEdBQVMsSUFBQyxDQUFBLFVBQUQsQ0FBWSxXQUFZLENBQUEsQ0FBQSxDQUF4QjtRQUNULElBQTZCLGNBQTdCO1VBQUEsSUFBSSxDQUFDLFNBQUwsQ0FBZSxDQUFmLEVBQWtCLE1BQWxCLEVBQUE7O1FBRUEsVUFBQSxHQUFhLElBQUMsQ0FBQSxhQUFELENBQWUsV0FBWSxDQUFBLENBQUEsQ0FBM0I7UUFDYixJQUFHLGtCQUFIO0FBQ0U7OztBQUNHO21CQUFBLDhDQUFBOzs4QkFBQSxJQUFJLENBQUMsV0FBTCxDQUFpQixTQUFTLENBQUMsR0FBM0IsRUFBZ0MsU0FBUyxDQUFDLFFBQTFDO0FBQUE7O2tCQURIO1dBQUEsYUFBQTtZQUVNO0FBQ0osa0JBQVUsSUFBQSxHQUFHLENBQUMsSUFBSixDQUFTLGFBQVQsRUFBd0IsZ0NBQUEsR0FBaUMsV0FBWSxDQUFBLENBQUEsQ0FBckUsRUFIWjtXQURGO1NBQUEsTUFBQTsrQkFBQTs7QUFSRjtxQkFERjs7RUEzQmM7O21CQTBDaEIsa0JBQUEsR0FBb0IsU0FBQyxJQUFELEVBQU8sVUFBUCxFQUFtQixTQUFuQixFQUE4QixhQUE5QixFQUE2QyxZQUE3QztBQUNsQixRQUFBO0lBQUEsQ0FBQSxDQUFFLHVCQUFGLEVBQTJCLElBQTNCLEVBQWlDLFVBQWpDLEVBQTZDLFNBQTdDLEVBQXdELGFBQXhELEVBQXVFLFlBQXZFO0lBRUEsSUFBRyxJQUFBLEtBQVEsR0FBWDtNQUNFLFNBQVMsQ0FBQyxXQUFWLENBQ00sSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVQsQ0FBb0IsR0FBcEIsQ0FBd0IsQ0FDMUIsd0JBREUsQ0FDdUIsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFVLENBQUMsZUFBZSxDQUFDLE1BRDNELENBRE4sRUFERjs7SUFLQSxJQUFHLENBQUMsQ0FBQyxPQUFGLENBQVUsYUFBVixDQUFBLElBQTZCLENBQUMsQ0FBQyxPQUFGLENBQVUsWUFBVixDQUFoQztBQUE2RCxhQUE3RDs7SUFFQSxZQUFBLEdBQWU7SUFFZixJQUFHLElBQUEsS0FBUSxHQUFYO01BQ0UsWUFBQSxHQUFtQixJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBVCxDQUFrQjtRQUNuQyxVQUFBLEVBQVksVUFEdUI7UUFFbkMsU0FBQSxFQUFXLFNBRndCO1FBR25DLGFBQUEsRUFBZSxhQUhvQjtRQUluQyxZQUFBLEVBQWMsWUFKcUI7T0FBbEIsRUFEckI7O0lBUUEsSUFBRyxJQUFBLEtBQVMsR0FBVCxJQUFBLElBQUEsS0FBYyxHQUFqQjtNQUNFLFlBQUEsR0FBbUIsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQVQsQ0FBZ0I7UUFDakMsVUFBQSxFQUFZLFVBRHFCO1FBRWpDLFNBQUEsRUFBVyxTQUZzQjtRQUdqQyxhQUFBLEVBQWUsYUFIa0I7UUFJakMsWUFBQSxFQUFjLFlBSm1CO09BQWhCLEVBS2QsSUFBSSxDQUFDLFdBQUwsQ0FBQSxDQUxjLEVBRHJCOztJQVFBLElBQUcsSUFBQSxLQUFTLEdBQVQsSUFBQSxJQUFBLEtBQWMsR0FBakI7TUFDRSxZQUFBLEdBQW1CLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFULENBQWdCO1FBQ2pDLFVBQUEsRUFBWSxVQURxQjtRQUVqQyxTQUFBLEVBQVcsU0FGc0I7UUFHakMsYUFBQSxFQUFlLGFBSGtCO1FBSWpDLFlBQUEsRUFBYyxZQUptQjtPQUFoQixFQUtkLEdBTGMsRUFEckI7O0lBUUEsSUFBRyxJQUFBLEtBQVEsR0FBWDtNQUNFLElBQUMsQ0FBQSxTQUFELENBQVcsVUFBWCxFQUF1QixTQUF2QixFQUFrQyxhQUFsQyxFQUFpRCxZQUFqRCxFQURGOztJQUdBLElBQXdDLG9CQUF4QzthQUFBLElBQUMsQ0FBQSxpQkFBaUIsQ0FBQyxJQUFuQixDQUF3QixZQUF4QixFQUFBOztFQXZDa0I7O21CQXlDcEIsb0JBQUEsR0FBc0IsU0FBQyxJQUFELEVBQU8sVUFBUCxFQUFtQixTQUFuQixFQUE4QixhQUE5QixFQUE2QyxZQUE3QztBQUNwQixRQUFBO0lBQUEsQ0FBQSxDQUFFLHlCQUFGLEVBQTZCLElBQTdCLEVBQW1DLFVBQW5DLEVBQStDLFNBQS9DLEVBQTBELGFBQTFELEVBQXlFLFlBQXpFO0lBQ0EsWUFBQSxHQUFlO0lBQ2YsSUFBRyxJQUFBLEtBQVMsR0FBVCxJQUFBLElBQUEsS0FBYyxHQUFkLElBQUEsSUFBQSxLQUFtQixHQUFuQixJQUFBLElBQUEsS0FBd0IsR0FBeEIsSUFBQSxJQUFBLEtBQTZCLEdBQTdCLElBQUEsSUFBQSxLQUFrQyxHQUFyQztNQUNFLFlBQUEsR0FBbUIsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVQsQ0FBa0I7UUFDbkMsVUFBQSxFQUFZLFVBRHVCO1FBRW5DLFNBQUEsRUFBVyxTQUZ3QjtRQUduQyxhQUFBLEVBQWUsYUFIb0I7UUFJbkMsWUFBQSxFQUFjLFlBSnFCO09BQWxCLEVBRHJCOztJQVFBLElBQTBDLG9CQUExQzthQUFBLElBQUMsQ0FBQSxtQkFBbUIsQ0FBQyxJQUFyQixDQUEwQixZQUExQixFQUFBOztFQVhvQjs7bUJBY3RCLG9CQUFBLEdBQXNCLFNBQUE7QUFDcEIsUUFBQTtJQUFBLFNBQUEsR0FBWSxDQUFDLENBQUMsSUFBRixDQUFPLElBQUMsQ0FBQSxNQUFSLENBQWUsQ0FBQztJQUM1QixLQUFBLEdBQVE7QUFDUixXQUFNLEtBQUEsSUFBUyxTQUFTLENBQUMsTUFBekI7TUFDRSxJQUFBLEdBQU8sU0FBVSxDQUFBLFNBQVMsQ0FBQyxNQUFWLEdBQW1CLEtBQW5CO01BQ2pCLElBQXFDLElBQUEsWUFBZ0IsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUE5RDtBQUFBLGVBQVEsU0FBUyxDQUFDLE1BQVYsR0FBbUIsTUFBM0I7O01BQ0EsS0FBQTtJQUhGO0FBS0EsV0FBTyxDQUFDO0VBUlk7O21CQVV0QixZQUFBLEdBQWMsU0FBQyxTQUFEO0FBQ1osUUFBQTtJQUFBLENBQUEsQ0FBRSxnQkFBRixFQUFvQixTQUFwQjtJQUNBLElBQWMsaUJBQWQ7QUFBQSxhQUFBOztJQUVBLEtBQUEsR0FBUSxDQUFDLENBQUMsSUFBRixDQUFPLElBQUMsQ0FBQSxNQUFSO0lBQ1IsU0FBQSxHQUFZLEtBQUssQ0FBQztJQUNsQixXQUFBLEdBQWMsS0FBSyxDQUFDO0lBQ3BCLFFBQUEsR0FBVztJQUNYLGNBQUEsR0FBaUI7SUFFakIsSUFBRyxTQUFBLEtBQWEsR0FBaEI7TUFDRSxRQUFBLEdBQWUsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQVQsQ0FBQSxFQURqQjs7SUFFQSxJQUFHLFNBQUEsS0FBYSxHQUFoQjtNQUNFLFFBQUEsR0FBZSxJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBVCxDQUFBLENBQWtCLENBQUMsUUFBbkIsQ0FBNEIsSUFBNUIsRUFEakI7O0lBRUEsSUFBRyxTQUFBLEtBQWEsR0FBaEI7TUFDRSxRQUFBLEdBQWUsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVQsQ0FBc0IsSUFBdEIsQ0FBMkIsQ0FBQyxXQUE1QixDQUF3QyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBbkU7TUFDZixjQUFBLEdBQXFCLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFULENBQXNCLElBQXRCLENBQTJCLENBQUMsV0FBNUIsQ0FBd0MsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQW5FLEVBRnZCOztJQUdBLElBQUcsU0FBQSxLQUFhLEdBQWhCO01BQ0UsUUFBQSxHQUFlLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFULENBQXNCLElBQXRCLENBQTJCLENBQUMsV0FBNUIsQ0FBd0MsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQW5FO01BQ2YsY0FBQSxHQUFxQixJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBVCxDQUFzQixJQUF0QixDQUEyQixDQUFDLFdBQTVCLENBQXdDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxNQUFuRSxFQUZ2Qjs7SUFJQSxJQUE4QyxnQkFBOUM7TUFBQSxDQUFDLENBQUMsSUFBRixDQUFPLFNBQVAsQ0FBaUIsQ0FBQyxXQUFsQixDQUE4QixRQUE5QixFQUF3QyxDQUF4QyxFQUFBOztJQUNBLElBQTJELHNCQUEzRDtzREFBbUIsQ0FBRSxlQUFyQixDQUFxQyxDQUFyQyxFQUF3QyxjQUF4QyxXQUFBOztFQXRCWTs7bUJBeUJkLGdCQUFBLEdBQWtCLFNBQUMsYUFBRDtBQUNoQixRQUFBO0lBQUEsQ0FBQSxDQUFFLG9CQUFGLEVBQXdCLGFBQXhCO0lBQ0EsS0FBQSxHQUFRLENBQUMsQ0FBQyxJQUFGLENBQU8sSUFBQyxDQUFBLE1BQVI7SUFDUixTQUFBLEdBQVksS0FBSyxDQUFDO0lBQ2xCLFdBQUEsR0FBYyxLQUFLLENBQUM7SUFDcEIsSUFBRyxDQUFDLENBQUMsT0FBRixDQUFVLFNBQVYsQ0FBQSxJQUF3QixDQUFDLENBQUMsT0FBRixDQUFVLGFBQVYsQ0FBM0I7TUFDRSxJQUFDLENBQUEsVUFBRCxDQUFZLENBQVo7QUFDQSxhQUZGOztJQUlBLGdCQUFBLEdBQW1CLENBQUMsQ0FBQyxJQUFGLENBQU8sU0FBUDtJQUVuQixTQUFBLEdBQVk7QUFDWjtBQUFBLFNBQUEscUNBQUE7O01BQ0UsT0FBQTs7QUFBVzthQUFBLHlEQUFBOztjQUFtQyxhQUFBLElBQVMsR0FBQSxLQUFPO3lCQUFuRDs7QUFBQTs7O01BQ1gsSUFBRyxDQUFDLENBQUMsT0FBRixDQUFVLE9BQVYsQ0FBSDtBQUEyQixpQkFBM0I7O01BRUEsSUFBRyxrQkFBQSxLQUFzQixHQUF6QjtRQUFrQyxTQUFBLEdBQVksS0FBOUM7O01BQ0EsVUFBQSxHQUFhLElBQUMsQ0FBQSxvQkFBRCxDQUFBO01BQ2IsSUFBRyxVQUFBLEtBQWMsQ0FBQyxDQUFsQjtRQUNFLGFBQUEsR0FBZ0I7UUFDaEIsWUFBQSxHQUFlLEtBRmpCO09BQUEsTUFBQTtRQUlFLGFBQUEsR0FBZ0IsU0FBVSxDQUFBLFVBQUE7UUFFMUIsWUFBQTs7QUFBZ0I7QUFBQTtlQUFBLGdEQUFBOztnQkFBdUQsYUFBSyxPQUFMLEVBQUEsQ0FBQTsyQkFBdkQsQ0FBQyxDQUFDOztBQUFGOzs7UUFHaEIsYUFBQTs7QUFBaUI7QUFBQTtlQUFBLGdEQUFBOzt1QkFBd0QsR0FBRyxDQUFDLEdBQUosRUFBQSxhQUFXLFlBQVgsRUFBQSxJQUFBOzJCQUF4RCxHQUFHLENBQUM7O0FBQUo7OztRQUdqQixZQUFBOztBQUFnQjtBQUFBO2VBQUEsZ0RBQUE7O3VCQUFnRCxDQUFDLENBQUMsR0FBRixFQUFBLGFBQVMsYUFBVCxFQUFBLElBQUE7MkJBQWhEOztBQUFBOzs7UUFHaEIsZUFBQTs7QUFBbUI7QUFBQTtlQUFBLGdEQUFBOzt1QkFBbUQsQ0FBQyxDQUFDLEdBQUYsRUFBQSxhQUFTLGFBQVQsRUFBQSxJQUFBOzJCQUFuRDs7QUFBQTs7YUFmckI7O01BaUJBLElBQUcsaUJBQUg7UUFDRSxJQUFDLENBQUEsa0JBQUQsQ0FBb0Isa0JBQXBCLEVBQ0UsYUFERixFQUNpQixnQkFEakIsRUFDbUMsWUFEbkMsRUFDaUQsZUFEakQsRUFERjs7TUFJQSxJQUFHLGtCQUFIO1FBQ0UsSUFBQyxDQUFBLG9CQUFELENBQXNCLGtCQUF0QixFQUNFLFdBQVksQ0FBQSxVQUFBLENBRGQsRUFDMkIsQ0FBQyxDQUFDLElBQUYsQ0FBTyxXQUFQLENBRDNCLEVBRUUsWUFGRixFQUVnQixlQUZoQixFQURGOztBQTNCRjtJQWdDQSxJQUFBLENBQXNCLFNBQXRCO2FBQUEsSUFBQyxDQUFBLFVBQUQsQ0FBWSxDQUFaLEVBQUE7O0VBNUNnQjs7bUJBOENsQixPQUFBLEdBQVMsU0FBQyxNQUFEO0FBQ1AsUUFBQTtJQUFBLENBQUEsQ0FBRSxXQUFGLEVBQWUsTUFBZjtJQUNBLElBQUMsQ0FBQSxVQUFELENBQUE7SUFFQSxJQUFHLE1BQU8sQ0FBQSxVQUFBLENBQVAsS0FBc0IsQ0FBekI7TUFDRSxJQUFDLENBQUEsWUFBRCxDQUNFO1FBQUEsSUFBQSxFQUFNLENBQUMsS0FBRCxDQUFOO1FBQ0EsV0FBQSxFQUFhLEVBRGI7UUFFQSxPQUFBLEVBQVMsSUFGVDtPQURGLEVBREY7S0FBQSxNQUFBO01BTUUsUUFBQSxHQUFXLElBQUMsQ0FBQSxNQUFNLENBQUMsY0FBUixDQUF1QixDQUFDLFFBQUEsQ0FBUyxNQUFPLENBQUEsVUFBQSxDQUFoQixFQUE2QixFQUE3QixDQUFBLEdBQW1DLENBQXBDLENBQUEsR0FBeUMsQ0FBaEUsRUFBbUUsQ0FBbkU7TUFDWCxJQUFDLENBQUEsWUFBRCxDQUNFO1FBQUEsSUFBQSxFQUFNLENBQUMsUUFBRCxDQUFOO1FBQ0EsV0FBQSxFQUFhLEVBRGI7UUFFQSxPQUFBLEVBQVMsSUFGVDtPQURGLEVBUEY7O0lBWUEsU0FBQSxHQUFZLENBQUMsQ0FBQyxJQUFGLENBQU8sSUFBQyxDQUFBLE1BQVIsQ0FBZSxDQUFDO0lBQzVCLElBQUcsSUFBQyxDQUFBLGNBQWUsQ0FBQSxXQUFBLENBQWhCLEtBQWdDLE1BQW5DO01BQ0UsUUFBQSxHQUFlLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFULENBQW1CO1FBQ2hDLElBQUEsRUFBTSxDQUFDLFFBQUEsSUFBWSxLQUFiLENBRDBCO1FBRWhDLFFBQUEsRUFBVSxJQUFDLENBQUEsZ0JBQUQsR0FBb0IsR0FGRTtRQUdoQyxJQUFBLEVBQU0sUUFIMEI7UUFJaEMsU0FBQSxFQUFXLEtBSnFCO09BQW5CO01BTWYsSUFBRyxJQUFDLENBQUEsZ0JBQWlCLENBQUEsSUFBQyxDQUFBLGdCQUFnQixDQUFDLE1BQWxCLEdBQTJCLENBQTNCLENBQWxCLEtBQW1ELEdBQXREO1FBQ0UsUUFBUSxDQUFDLE1BQVQsQ0FBZ0IsQ0FBaEIsRUFERjs7YUFFQSxTQUFTLENBQUMsSUFBVixDQUFlLFFBQWYsRUFURjtLQUFBLE1BQUE7YUFXRSxTQUFTLENBQUMsSUFBVixDQUFtQixJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBVCxDQUFtQixJQUFDLENBQUEsZ0JBQXBCLENBQW5CLEVBWEY7O0VBakJPOzttQkE4QlQsUUFBQSxHQUFVLFNBQUMsS0FBRCxFQUFRLGtCQUFSLEVBQTRCLGVBQTVCO0FBQ1IsUUFBQTtJQUFBLElBQVUsQ0FBQyxDQUFDLE9BQUYsQ0FBVSxLQUFWLENBQVY7QUFBQSxhQUFBOztJQUNBLENBQUEsQ0FBRSxZQUFGLEVBQWdCLEtBQWhCO0lBQ0EsS0FBQSxHQUFRLENBQUMsQ0FBQyxJQUFGLENBQU8sSUFBQyxDQUFBLE1BQVI7SUFFUixLQUFBLEdBQVE7SUFDUixVQUFBLEdBQWE7SUFDYixXQUFBLEdBQWM7SUFDZCxhQUFBLEdBQWdCO0lBQ2hCLFVBQUEsR0FBYTtJQUNiLFNBQUEsR0FBWTtJQUNaLFNBQUEsR0FBWTtJQUNaLFNBQUEsR0FBWTtJQUtaLGNBQUEsR0FBaUIsQ0FBQyxDQUFDLEtBQUYsQ0FBUSxLQUFSLENBQWMsQ0FBQztJQUNoQyxnQkFBQSxHQUFtQjtBQUVuQixTQUFBLHVDQUFBOztNQUNFLFNBQUE7TUFDQSxJQUFHLGtCQUFBLElBQWEsSUFBSSxDQUFDLE1BQUwsS0FBZSxjQUEvQjtRQUNFLGdCQUFBLEdBQW1CO1FBQ25CLGNBQUEsR0FBaUIsSUFBSSxDQUFDLE9BRnhCOztNQUlBLElBQU8sK0JBQVA7UUFHRSxLQUFNLENBQUEsZ0JBQUEsQ0FBTixHQUEwQjtRQUMxQixVQUFXLENBQUEsZ0JBQUEsQ0FBWCxHQUErQjtRQUMvQixXQUFZLENBQUEsZ0JBQUEsQ0FBWixHQUFnQztRQUNoQyxTQUFVLENBQUEsZ0JBQUEsQ0FBVixHQUE4QjtRQUM5QixhQUFjLENBQUEsZ0JBQUEsQ0FBZCxHQUFrQztRQUNsQyxVQUFXLENBQUEsZ0JBQUEsQ0FBWCxHQUErQixHQVJqQzs7TUFVQSxNQUFxQyxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixDQUFyQyxFQUFDLGlCQUFELEVBQVcsbUJBQVgsRUFBdUI7TUFFdkIsU0FBQSxHQUFZO01BRVosSUFBRyxnQkFBSDtRQUNFLE1BQUEsR0FBWSxtQkFBSCxHQUFxQixJQUFJLENBQUMsTUFBMUIsR0FBc0MsSUFBSSxDQUFDO1FBQ3BELE9BQXFDLElBQUMsQ0FBQSxhQUFELENBQWUsSUFBSSxDQUFDLEdBQXBCLEVBQXlCLE1BQXpCLENBQXJDLEVBQUMsa0JBQUQsRUFBVyxvQkFBWCxFQUF1QjtRQUN2QixJQUFHLGtCQUFIO1VBQ0UsR0FBQSxHQUFNLFVBQVUsQ0FBQyxLQUFYLENBQWlCLEdBQWpCLENBQXNCLENBQUEsQ0FBQSxFQUQ5QjtTQUFBLE1BQUE7VUFHRSxHQUFBLEdBQU0sR0FIUjs7UUFLQSxTQUFBLEdBQVksRUFBQSxHQUFHLFFBQUgsR0FBYztRQUMxQixJQUF1QixpQkFBdkI7VUFBQSxJQUFJLENBQUMsSUFBTCxHQUFZLElBQVo7U0FURjtPQUFBLE1BVUssSUFBRyxpQkFBSDtRQUNILE9BQXFDLElBQUMsQ0FBQSxjQUFELENBQWdCLElBQUksQ0FBQyxJQUFyQixFQUEyQixJQUFJLENBQUMsTUFBaEMsQ0FBckMsRUFBQyxrQkFBRCxFQUFXLG9CQUFYLEVBQXVCO1FBQ3ZCLFNBQUEsR0FBWSxJQUFDLENBQUEsTUFBTSxDQUFDLGNBQVIsQ0FBdUIsSUFBSSxDQUFDLElBQTVCLEVBQWtDLElBQUksQ0FBQyxNQUF2QyxDQUE4QyxDQUFDLEtBQS9DLENBQXFELEdBQXJELENBQTBELENBQUEsQ0FBQSxFQUZuRTtPQUFBLE1BQUE7QUFJSCxjQUFVLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxhQUFULEVBQXdCLG1CQUF4QixFQUpQOztNQU1MLFdBQUEsR0FBYyxRQUFBLENBQVMsVUFBVCxFQUFxQixFQUFyQixDQUFBLEdBQTJCLElBQUMsQ0FBQTtNQUUxQyxnQkFBQSxHQUFzQixpQkFBSCxHQUFtQjtRQUFDLElBQUEsRUFBTSxJQUFJLENBQUMsSUFBWjtRQUFrQixHQUFBLEVBQUssSUFBSSxDQUFDLEdBQTVCO09BQW5CLEdBQXlEO01BQzVFLEtBQU0sQ0FBQSxnQkFBQSxDQUFpQixDQUFDLElBQXhCLENBQWdDLFFBQUQsR0FBVSxHQUFWLEdBQWEsVUFBNUM7TUFDQSxVQUFXLENBQUEsZ0JBQUEsQ0FBaUIsQ0FBQyxJQUE3QixDQUFxQyxTQUFELEdBQVcsR0FBWCxHQUFjLFdBQWxEO01BQ0EsV0FBWSxDQUFBLGdCQUFBLENBQWlCLENBQUMsSUFBOUIsQ0FBbUMsVUFBbkM7TUFDQSxTQUFVLENBQUEsZ0JBQUEsQ0FBaUIsQ0FBQyxJQUE1QixDQUFpQztRQUFDLElBQUEsRUFBTSxJQUFJLENBQUMsSUFBWjtRQUFrQixHQUFBLEVBQUssSUFBSSxDQUFDLE1BQTVCO09BQWpDO01BQ0EsSUFBMEQseUJBQTFEO1FBQUEsYUFBYyxDQUFBLGdCQUFBLENBQWlCLENBQUMsSUFBaEMsQ0FBcUMsSUFBSSxDQUFDLFlBQTFDLEVBQUE7O01BQ0EsU0FBVSxDQUFBLGdCQUFBLENBQVYsR0FBOEI7TUFDOUIsSUFBaUQsc0JBQWpEO1FBQUEsVUFBVyxDQUFBLGdCQUFBLENBQVgsR0FBK0IsSUFBSSxDQUFDLFVBQXBDOztNQUVBLGdCQUFBO0FBL0NGO0FBaURBLFNBQUEsaURBQUE7O01BQ0UsY0FBQSxHQUFpQixJQUFDLENBQUE7TUFDbEIsSUFBcUQsb0JBQXJEO1FBQUEsSUFBQyxDQUFBLFdBQUQsQ0FBYSxTQUFVLENBQUEsQ0FBQSxDQUFFLENBQUMsSUFBMUIsRUFBZ0MsU0FBVSxDQUFBLENBQUEsQ0FBRSxDQUFDLEdBQTdDLEVBQUE7O01BQ0EsSUFBQyxDQUFBLFVBQUQsQ0FBWSxTQUFVLENBQUEsQ0FBQSxDQUF0QixFQUEwQixVQUFXLENBQUEsQ0FBQSxDQUFyQztNQUNBLElBQXFGLGtCQUFyRjtRQUFBLElBQUMsQ0FBQSxZQUFELENBQWM7VUFBQyxJQUFBLEVBQU0sSUFBUDtVQUFhLFdBQUEsRUFBYSxXQUFZLENBQUEsQ0FBQSxDQUF0QztVQUEwQyxTQUFBLEVBQVcsVUFBVyxDQUFBLENBQUEsQ0FBaEU7U0FBZCxFQUFBOztNQUNBLElBQUMsQ0FBQSxnQkFBRCxDQUFrQixhQUFjLENBQUEsQ0FBQSxDQUFoQztNQUNBLElBQStCLHFCQUEvQjtRQUFBLElBQUMsQ0FBQSxZQUFELENBQWMsVUFBVyxDQUFBLENBQUEsQ0FBekIsRUFBQTs7QUFORjtJQVFBLElBQUcsMEJBQUg7TUFDRSxHQUFBLEdBQU07QUFDTixXQUF1Qyw2RkFBdkM7UUFBQSxHQUFHLENBQUMsSUFBSixDQUFTLGtCQUFUO0FBQUE7TUFDQSxJQUFDLENBQUEsZ0JBQUQsQ0FBa0IsR0FBbEIsRUFIRjs7SUFLQSxJQUFpQyx1QkFBakM7YUFBQSxJQUFDLENBQUEsWUFBRCxDQUFjLGVBQWQsRUFBQTs7RUFsRlE7O21CQW9GVixPQUFBLEdBQVMsU0FBQyxJQUFEO1dBQ1AsSUFBQyxDQUFBLFFBQUQsQ0FBVSxDQUFDLElBQUQsQ0FBVjtFQURPOzttQkFHVCxZQUFBLEdBQWMsU0FBQTtXQUNaLENBQUMsQ0FBQyxJQUFGLENBQU8sSUFBQyxDQUFBLE1BQVIsQ0FBZSxDQUFDLFdBQVcsQ0FBQyxJQUE1QixDQUFpQyxFQUFqQztFQURZOzttQkFHZCxXQUFBLEdBQWEsU0FBQyxJQUFEO0FBQ1gsUUFBQTtJQUFBLElBQUcsWUFBSDtNQUNFLEtBQUEsR0FBUSxJQUFJLENBQUMsS0FBTCxDQUFXLHlCQUFYO01BQ1IsSUFBRyxhQUFIO1FBQ0UsSUFBQyxDQUFBLGNBQWUsQ0FBQSxXQUFBLENBQWhCLEdBQStCLEtBQU0sQ0FBQSxDQUFBO1FBQ3JDLElBQUMsQ0FBQSxjQUFlLENBQUEsV0FBQSxDQUFoQixHQUErQixRQUFBLENBQVMsS0FBTSxDQUFBLENBQUEsQ0FBZixFQUFtQixFQUFuQjtlQUMvQixJQUFDLENBQUEsY0FBZSxDQUFBLFlBQUEsQ0FBaEIsR0FBZ0MsS0FBTSxDQUFBLENBQUEsRUFIeEM7T0FGRjs7RUFEVzs7bUJBUWIsV0FBQSxHQUFhLFNBQUMsSUFBRCxFQUFPLFFBQVAsRUFBbUIsYUFBbkIsRUFBMkMsTUFBM0MsRUFBd0QsWUFBeEQ7QUFDWCxRQUFBOztNQURrQixXQUFTOzs7TUFBRyxnQkFBYzs7O01BQVUsU0FBTzs7O01BQU0sZUFBYTs7SUFDaEYsTUFBQSxHQUFTLENBQUMsQ0FBQyxJQUFGLENBQU8sSUFBQyxDQUFBLE1BQVIsQ0FBZSxDQUFDO0lBQ3pCLElBQStFLENBQUMsQ0FBQyxPQUFGLENBQVUsTUFBVixDQUEvRTtBQUFBLFlBQVUsSUFBQSxHQUFHLENBQUMsSUFBSixDQUFTLGFBQVQsRUFBd0Isd0NBQXhCLEVBQVY7O0lBRUEsU0FBQSxHQUFZLElBQUMsQ0FBQSxjQUFlLENBQUEsV0FBQTtJQUM1QixTQUFBLEdBQVksSUFBQyxDQUFBLGNBQWUsQ0FBQSxXQUFBO0lBQzVCLFVBQUEsR0FBYSxJQUFDLENBQUEsY0FBZSxDQUFBLFlBQUE7SUFFN0IsSUFBQTtBQUFPLGNBQU8sYUFBUDtBQUFBLGFBQ0EsUUFEQTtpQkFFSCxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUM7QUFGN0IsYUFHQSxNQUhBO2lCQUlILEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQztBQUo3QixhQUtBLE9BTEE7aUJBTUgsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDO0FBTjdCO2lCQVFILEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQztBQVI3Qjs7SUFVUCxRQUFBLEdBQWMsWUFBSCxHQUFxQixHQUFyQixHQUE4QixJQUFDLENBQUE7SUFFMUMsTUFBQSxHQUNFO01BQUEsSUFBQSxFQUFNLElBQU47TUFDQSxRQUFBLEVBQVUsUUFEVjtNQUVBLE1BQUEsRUFBUSxNQUZSO01BR0EsWUFBQSxFQUFjLFlBSGQ7TUFJQSxJQUFBLEVBQ0U7UUFBQSxNQUFBLEVBQVEsU0FBUjtRQUNBLElBQUEsRUFBTSxTQUROO1FBRUEsTUFBQSxFQUFRLFVBRlI7T0FMRjs7SUFTRixJQUFHLElBQUssQ0FBQSxDQUFBLENBQUwsS0FBVyxHQUFkO01BQ0UsTUFBTSxDQUFDLEtBQVAsR0FBZSxJQUFLLFVBRHRCOztJQUdBLElBQUEsR0FBVyxJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBVCxDQUFrQixNQUFsQixDQUF5QixDQUNsQyxPQURTLENBQ0QsUUFEQyxDQUNRLENBQUMsZ0JBRFQsQ0FDMEIsSUFEMUI7V0FHWCxDQUFDLENBQUMsSUFBRixDQUFPLE1BQVAsQ0FBYyxDQUFDLElBQWYsQ0FBb0IsSUFBcEI7RUFwQ1c7O21CQXNDYixRQUFBLEdBQVUsU0FBQyxPQUFEO0FBQ1IsUUFBQTtJQUFBLElBQUMsQ0FBQSxVQUFELENBQUE7SUFDQSxLQUFBLEdBQVEsQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsTUFBUjtJQUNSLElBQWlDLGFBQWpDO0FBQUEsYUFBTyxJQUFDLENBQUEsUUFBRCxDQUFVLE9BQVYsRUFBUDs7SUFFQSxJQUFBLENBQU8sQ0FBQyxDQUFDLE9BQUYsQ0FBVSxLQUFLLENBQUMsU0FBaEIsQ0FBUDtNQUNFLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBakIsQ0FBc0IsS0FBSyxDQUFDLFNBQTVCO01BQ0EsS0FBSyxDQUFDLFNBQU4sR0FBa0IsR0FGcEI7O0lBSUEsSUFBQSxDQUFPLENBQUMsQ0FBQyxPQUFGLENBQVUsS0FBSyxDQUFDLFVBQWhCLENBQVA7TUFDRSxLQUFLLENBQUMsV0FBVyxDQUFDLElBQWxCLENBQXVCLEtBQUssQ0FBQyxVQUE3QjthQUNBLEtBQUssQ0FBQyxVQUFOLEdBQW1CLEdBRnJCOztFQVRROzttQkFhVixRQUFBLEdBQVUsU0FBQyxPQUFELEVBQVUsT0FBVjtBQUNSLFFBQUE7SUFBQSxJQUFBLEdBQ0U7TUFBQSxNQUFBLEVBQVEsVUFBUjtNQUNBLElBQUEsRUFBTSxRQUROO01BRUEsR0FBQSxFQUFLLEdBRkw7TUFHQSxRQUFBLEVBQWEsT0FBQSxLQUFXLFVBQWQsR0FBOEIsT0FBOUIsR0FBMkMsTUFIckQ7TUFJQSxTQUFBLEVBQWMsT0FBQSxLQUFXLE9BQWQsR0FBMkIsT0FBM0IsR0FBd0MsTUFKbkQ7TUFLQSxPQUFBLEVBQVMsQ0FMVDs7SUFPRixDQUFDLENBQUMsTUFBRixDQUFTLElBQVQsRUFBZSxPQUFmO0lBQ0EsQ0FBQSxDQUFFLFlBQUYsRUFBZ0IsT0FBaEIsRUFBeUIsSUFBekI7SUFFQSxTQUFBLEdBQVk7SUFDWixVQUFBLEdBQWE7SUFHYixPQUFBLEdBQVUsSUFBQyxDQUFBLENBQUQsR0FBSyxJQUFDLENBQUEsY0FBZSxDQUFBLGlCQUFBO0lBQy9CLGdCQUFBLEdBQW1CO0lBRW5CLElBQUcsSUFBSSxDQUFDLFFBQUwsS0FBaUIsTUFBcEI7TUFDRSxVQUFBLEdBQWlCLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFULENBQWUsT0FBZixFQUF3QixJQUFDLENBQUEsTUFBekIsRUFBaUMsSUFBQyxDQUFBLGNBQWMsQ0FBQyxLQUFoQixHQUF3QixFQUF6RDtNQUNqQixJQUFpQyxJQUFJLENBQUMsSUFBTCxLQUFlLE1BQWhEO1FBQUEsVUFBVSxDQUFDLE9BQVgsQ0FBbUIsSUFBSSxDQUFDLElBQXhCLEVBQUE7O01BQ0EsVUFBVSxDQUFDLGVBQVgsQ0FBMkIsSUFBSSxDQUFDLEdBQWhDO01BQ0EsSUFBMEMsaUJBQTFDO1FBQUEsVUFBVSxDQUFDLGdCQUFYLENBQTRCLElBQUksQ0FBQyxJQUFqQyxFQUFBOztNQUVBLElBQUMsQ0FBQSxNQUFELElBQVcsVUFBVSxDQUFDLFNBQVgsQ0FBQSxDQUFBLEdBQ0EsSUFBQyxDQUFBLE9BQU8sQ0FBQyx3QkFEVCxHQUVBLFFBQUEsQ0FBUyxJQUFDLENBQUEsY0FBZSxDQUFBLGdCQUFBLENBQXpCLEVBQTRDLEVBQTVDO01BQ1gsZ0JBQUEsR0FBbUIsVUFBVSxDQUFDLGFBQVgsQ0FBQTtNQUNuQixJQUFDLENBQUEsWUFBRCxHQUFtQixJQUFJLENBQUMsSUFBTCxLQUFhLE1BQWhCLEdBQTRCLFFBQTVCLEdBQTBDLElBQUksQ0FBQyxLQVZqRTs7SUFZQSxJQUFHLElBQUksQ0FBQyxTQUFMLEtBQWtCLE1BQXJCO01BQ0UsU0FBQSxHQUFnQixJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBVCxDQUFrQixPQUFsQixFQUEyQixJQUFDLENBQUEsTUFBNUIsRUFBb0MsSUFBQyxDQUFBLGNBQWMsQ0FBQyxLQUFoQixHQUF3QixFQUE1RCxDQUNkLENBQUMsV0FEYSxDQUNELElBQUksQ0FBQyxPQURKO01BRWhCLElBQTJCLElBQUksQ0FBQyxJQUFMLEtBQWUsTUFBMUM7UUFBQSxTQUFTLENBQUMsV0FBVixDQUFBLEVBQUE7O01BQ0EsU0FBUyxDQUFDLGFBQVYsQ0FBd0IsZ0JBQXhCO01BQ0EsSUFBQyxDQUFBLE1BQUQsSUFBVyxTQUFTLENBQUMsU0FBVixDQUFBLENBQUEsR0FBd0IsSUFBQyxDQUFBLE9BQU8sQ0FBQyx3QkFMOUM7O0lBT0EsSUFBQyxDQUFBLFVBQUQsQ0FBQTtJQUNBLFdBQUEsR0FBYyxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxvQkFBZCxDQUFtQyxJQUFJLENBQUMsSUFBeEM7SUFDZCxJQUFDLENBQUEsTUFBTSxDQUFDLElBQVIsQ0FBYTtNQUNYLEdBQUEsRUFBSyxTQURNO01BRVgsSUFBQSxFQUFNLFVBRks7TUFHWCxVQUFBLEVBQVksRUFIRDtNQUlYLFdBQUEsRUFBYSxFQUpGO01BS1gsU0FBQSxFQUFXLEVBTEE7TUFNWCxVQUFBLEVBQVksRUFORDtNQU9YLFdBQUEsRUFBYSxFQVBGO01BUVgsV0FBQSxFQUFhLFdBUkY7S0FBYjtJQVdBLElBQUMsQ0FBQSxNQUFNLENBQUMsU0FBUixDQUFrQixJQUFJLENBQUMsTUFBdkI7SUFDQSxJQUFDLENBQUEsV0FBVyxDQUFDLE1BQWIsQ0FBb0IsSUFBSSxDQUFDLEdBQXpCO0VBcERROzttQkF3RFYsVUFBQSxHQUFZLFNBQUMsSUFBRCxFQUFPLEVBQVAsRUFBYSxFQUFiO0FBQ1YsUUFBQTs7TUFEaUIsS0FBRzs7O01BQUcsS0FBRzs7SUFDMUIsQ0FBQSxDQUFFLGNBQUYsRUFBa0IsSUFBbEI7SUFDQSxLQUFBLEdBQVEsSUFBSSxDQUFDLEtBQUwsQ0FBVyxLQUFYO0FBQ1IsWUFBTyxLQUFNLENBQUEsQ0FBQSxDQUFiO0FBQUEsV0FDTyxjQURQO1FBRUksSUFBQyxDQUFBLG9CQUFELEdBQXdCLFFBQUEsQ0FBUyxLQUFNLENBQUEsQ0FBQSxDQUFmLEVBQW1CLEVBQW5CO2VBQ3hCLENBQUEsQ0FBRSxnQkFBRixFQUFvQixJQUFDLENBQUEsb0JBQXJCO0FBSEo7QUFLSSxjQUFVLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxhQUFULEVBQXdCLG1CQUFBLEdBQW9CLEtBQU0sQ0FBQSxDQUFBLENBQTFCLEdBQTZCLFlBQTdCLEdBQXlDLEVBQXpDLEdBQTRDLFVBQTVDLEdBQXNELEVBQTlFO0FBTGQ7RUFIVTs7Ozs7O0FBVWQsTUFBTSxDQUFDLE9BQVAsR0FBaUI7Ozs7QUNuL0JqQixJQUFBOztBQUFBLEdBQUEsR0FBTSxPQUFBLENBQVEsU0FBUjs7QUFDTixNQUFBLEdBQVMsT0FBQSxDQUFRLGlCQUFSOztBQUNULE1BQUEsR0FBUyxPQUFBLENBQVEsaUJBQVI7O0FBQ1QsTUFBQSxHQUFTLE9BQUEsQ0FBUSxpQkFBUjs7QUFFVCxNQUFNLENBQUMsT0FBUCxHQUFpQjtFQUNmLE1BQUEsRUFBUSxNQURPO0VBRWYsTUFBQSxFQUFRLE1BRk87RUFHZixHQUFBLEVBQUssR0FIVTtFQUlmLE1BQUEsRUFBUSxNQUpPOzs7OztBQ0NqQixJQUFBLGdCQUFBO0VBQUE7OztBQUFBLEdBQUEsR0FBTSxPQUFBLENBQVEsU0FBUjs7QUFDTixDQUFBLEdBQUksT0FBQSxDQUFRLFlBQVI7O0FBQ0osQ0FBQSxHQUFJLE9BQUEsQ0FBUSxRQUFSOztBQUNKLEtBQUEsR0FBUSxPQUFBLENBQVEsT0FBUjs7QUFFRixHQUFHLENBQUMsSUFBSSxDQUFDO0FBQ2IsTUFBQTs7RUFBQSxNQUFDLENBQUEsS0FBRCxHQUFTOztFQUNULE1BQUMsQ0FBQSxrQkFBRCxHQUFzQjs7RUFDdEIsQ0FBQSxHQUFJLFNBQUE7QUFBYSxRQUFBO0lBQVo7SUFBWSxJQUE4QyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUE5RDtrRUFBQSxPQUFPLENBQUUsR0FBVCxnQkFBYSxDQUFBLG1CQUFxQixTQUFBLFdBQUEsSUFBQSxDQUFBLENBQWxDLFdBQUE7O0VBQWI7O0VBRUosUUFBQSxHQUFXLEdBQUcsQ0FBQyxJQUFJLENBQUM7O0VBQ3BCLFVBQUEsR0FBYSxHQUFHLENBQUMsSUFBSSxDQUFDOztFQUN0QixVQUFBLEdBQWEsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7O0VBQzVCLE9BQUEsR0FBVSxHQUFHLENBQUM7O0VBRWQsV0FBQSxHQUFjO0lBQ1osc0JBQUEsRUFBd0IsQ0FEWjtJQUVaLHVCQUFBLEVBQXlCLEVBRmI7SUFHWix1QkFBQSxFQUF5QixFQUhiO0lBSVosc0JBQUEsRUFBd0IsRUFKWjtJQUtaLG1CQUFBLEVBQXFCLEVBTFQ7SUFNWixzQkFBQSxFQUF3QixFQU5aO0lBT1osb0JBQUEsRUFBc0IsRUFQVjtJQVFaLFNBQUEsRUFBVyxFQVJDO0lBU1osZUFBQSxFQUFpQixFQVRMO0lBVVosYUFBQSxFQUFlLEVBVkg7SUFXWixVQUFBLEVBQVksRUFYQTtJQVlaLFdBQUEsRUFBYSxFQVpEO0lBYVosY0FBQSxFQUFnQixFQWJKO0lBY1osT0FBQSxFQUFTLEVBZEc7SUFlWixZQUFBLEVBQWMsR0FmRjs7O0VBa0JELGdCQUFDLE9BQUQsRUFBVSxPQUFWO0lBQUMsSUFBQyxDQUFBLFNBQUQ7SUFDWixDQUFBLENBQUUsdUJBQUYsRUFBMkIsT0FBM0I7SUFDQSxJQUFDLENBQUEsT0FBRCxHQUNFO01BQUEsVUFBQSxFQUFZLHNCQUFaO01BQ0EsS0FBQSxFQUFPLEdBRFA7TUFFQSxhQUFBLEVBQWUsSUFGZjtNQUdBLGFBQUEsRUFBZSxlQUhmO01BSUEsYUFBQSxFQUFlLGVBSmY7O0lBTUYsSUFBK0IsZUFBL0I7TUFBQSxDQUFDLENBQUMsTUFBRixDQUFTLElBQUMsQ0FBQSxPQUFWLEVBQW1CLE9BQW5CLEVBQUE7O0lBQ0EsQ0FBQSxDQUFFLHVCQUFBLEdBQXdCLElBQUMsQ0FBQSxPQUFPLENBQUMsYUFBbkM7SUFDQSxJQUFDLENBQUEsV0FBRCxHQUFlO0lBQ2YsSUFBQyxDQUFBLEtBQUQsR0FBUztJQUNULElBQUMsQ0FBQSxLQUFELENBQUE7RUFiVzs7bUJBZWIsU0FBQSxHQUFXLFNBQUMsTUFBRDtJQUNULElBQUMsQ0FBQSxNQUFELEdBQVU7V0FDVixJQUFDLENBQUEsS0FBRCxDQUFBO0VBRlM7O21CQUlYLFFBQUEsR0FBVSxTQUFDLEtBQUQ7SUFDUixDQUFBLENBQUUsYUFBRixFQUFpQixLQUFqQjtJQUNBLElBQUMsQ0FBQSxPQUFPLENBQUMsS0FBVCxHQUFpQjtXQUNqQixJQUFDLENBQUEsS0FBRCxDQUFBO0VBSFE7O21CQUtWLGFBQUEsR0FBZSxTQUFDLFVBQUQ7SUFDYixDQUFBLENBQUUsa0JBQUYsRUFBc0IsVUFBdEI7SUFDQSxJQUFHLGFBQWtCLENBQUMsQ0FBQyxJQUFGLENBQU8sV0FBUCxDQUFsQixFQUFBLFVBQUEsS0FBSDtBQUNFLFlBQVUsSUFBQSxHQUFHLENBQUMsSUFBSixDQUFTLGFBQVQsRUFBd0Isc0JBQUEsR0FBeUIsVUFBakQsRUFEWjs7SUFFQSxJQUFDLENBQUEsT0FBTyxDQUFDLFVBQVQsR0FBc0I7V0FDdEIsSUFBQyxDQUFBLEtBQUQsQ0FBQTtFQUxhOzttQkFPZixLQUFBLEdBQU8sU0FBQTtJQUNMLElBQUMsQ0FBQSxNQUFNLENBQUMsWUFBUixDQUFxQixJQUFyQjtJQUNBLElBQUMsQ0FBQSxVQUFELEdBQWM7SUFDZCxJQUFDLENBQUEsU0FBRCxHQUFhO0lBQ2IsSUFBQyxDQUFBLEdBQUQsR0FBTyxJQUFDLENBQUEsT0FBTyxDQUFDLEtBQVQsR0FBaUIsQ0FBQyxVQUFBLEdBQWEsQ0FBZDtJQUN4QixJQUFDLENBQUEsWUFBRCxHQUFnQjtJQUNoQixJQUFDLENBQUEsaUJBQUQsR0FBcUIsSUFBQyxDQUFBLEdBQUQsR0FBTyxDQUFDLEVBQUEsR0FBSyxDQUFDLElBQUEsR0FBSyxJQUFDLENBQUEsWUFBUCxDQUFOO0lBQzVCLElBQUMsQ0FBQSxXQUFELEdBQWU7SUFDZixJQUFHLG1CQUFIO01BQ0UsSUFBQyxDQUFBLE1BQU0sQ0FBQyxNQUFSLENBQUE7TUFDQSxJQUFDLENBQUEsTUFBRCxHQUFVLEtBRlo7O1dBR0EsSUFBQyxDQUFBLElBQUQsQ0FBQTtFQVhLOztFQWFQLFVBQUEsR0FBYSxTQUFDLE9BQUQsRUFBVSxLQUFWLEVBQWlCLGFBQWpCO0FBQ1gsUUFBQTtJQUFBLE1BQUEsR0FBUyxPQUFPLENBQUM7SUFDakIsTUFBQSxHQUFTLE1BQU0sQ0FBQztJQUNoQixLQUFBLEdBQVEsTUFBTSxDQUFDO0lBRWYsT0FBQSxHQUFVLENBQUEsQ0FBRSxVQUFGO0lBQ1YsT0FBTyxDQUFDLEdBQVIsQ0FBWSxVQUFaLEVBQXdCLFVBQXhCO0lBQ0EsT0FBTyxDQUFDLEdBQVIsQ0FBWSxNQUFaLEVBQW9CLENBQXBCO0lBQ0EsT0FBTyxDQUFDLEdBQVIsQ0FBWSxLQUFaLEVBQW1CLENBQW5CO0lBQ0EsT0FBTyxDQUFDLFFBQVIsQ0FBaUIsYUFBakI7SUFFQSxDQUFBLENBQUUsTUFBRixDQUFTLENBQUMsS0FBVixDQUFnQixPQUFoQjtJQUNBLEdBQUEsR0FBTSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBbEIsQ0FBbUMsT0FBTyxDQUFDLEdBQVIsQ0FBWSxDQUFaLENBQW5DLEVBQW1ELEtBQW5ELEVBQTBELE1BQTFEO0lBQ04sR0FBRyxDQUFDLEtBQUosQ0FBVSxLQUFWLEVBQWlCLEtBQWpCO0lBRUEsRUFBQSxHQUFTLElBQUEsS0FBSyxDQUFDLFVBQU4sQ0FBQTtJQUNULEVBQUUsQ0FBQyxLQUFILENBQVMsT0FBTyxDQUFDLEdBQVIsQ0FBWSxDQUFaLENBQVQ7QUFFQSxXQUFPO01BQ0wsS0FBQSxFQUFPLEVBREY7TUFFTCxNQUFBLEVBQVEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxDQUFaLENBRkg7O0VBbEJJOzttQkF1QmIsY0FBQSxHQUFnQixTQUFBO0lBQ2QsSUFBeUIsd0JBQXpCO01BQUEsSUFBQyxDQUFBLFdBQVcsQ0FBQyxNQUFiLENBQUEsRUFBQTs7SUFDQSxJQUF5Qix3QkFBekI7TUFBQSxJQUFDLENBQUEsV0FBVyxDQUFDLE1BQWIsQ0FBQSxFQUFBOztJQUNBLElBQXNCLGtCQUF0QjthQUFBLElBQUMsQ0FBQSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQVosQ0FBQSxFQUFBOztFQUhjOzttQkFLaEIsTUFBQSxHQUFRLFNBQUE7QUFDTixRQUFBO0lBQUEsSUFBQyxDQUFBLEtBQUQsQ0FBQTtJQUNBLElBQUEsR0FBTyxJQUFDLENBQUEsTUFBTSxDQUFDLGFBQVIsQ0FBQTtJQUNQLElBQUMsQ0FBQSxLQUFELEdBQVMsSUFBSSxDQUFDO0lBRWQsSUFBRyxDQUFJLElBQUMsQ0FBQSxLQUFSO01BQ0UsT0FBQSxHQUFVLFVBQUEsQ0FBVyxJQUFJLENBQUMsT0FBaEIsRUFBeUIsSUFBSSxDQUFDLEtBQTlCLEVBQXFDLElBQUMsQ0FBQSxPQUFPLENBQUMsYUFBOUM7TUFDVixJQUFDLENBQUEsS0FBRCxHQUFTLE9BQU8sQ0FBQyxNQUZuQjs7SUFJQSxJQUFDLENBQUEsTUFBRCxHQUFjLElBQUEsSUFBQyxDQUFBLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBWixDQUFzQixDQUF0QixFQUF3QixDQUF4QixFQUEwQixFQUExQixFQUE2QixFQUE3QjtJQUNkLElBQUMsQ0FBQSxlQUFELEdBQXVCLElBQUEsSUFBQyxDQUFBLEtBQUssQ0FBQyxTQUFQLENBQWlCLEVBQWpCLEVBQXFCLEVBQXJCO0lBRXZCLElBQUcsSUFBQyxDQUFBLE9BQU8sQ0FBQyxhQUFaO01BQ0UsSUFBQyxDQUFBLFdBQUQsR0FBbUIsSUFBQSxJQUFDLENBQUEsS0FBSyxDQUFDLElBQUksQ0FBQyxjQUFaLENBQStCLElBQUEsSUFBQyxDQUFBLEtBQUssQ0FBQyxLQUFQLENBQWEsRUFBYixFQUFnQixFQUFoQixDQUEvQixFQUFvRCxDQUFwRCxFQUF1RCxDQUF2RCxFQUEwRCxDQUExRDtNQUNuQixJQUFDLENBQUEsV0FBVyxDQUFDLFNBQWIsR0FBeUI7TUFDekIsSUFBQyxDQUFBLFdBQVcsQ0FBQyxPQUFiLEdBQXVCO01BQ3ZCLElBQUMsQ0FBQSxXQUFXLENBQUMsTUFBYixDQUFvQixFQUFwQjtNQUNBLElBQUMsQ0FBQSxXQUFXLENBQUMsU0FBYixHQUF5QixDQUFBLFNBQUEsS0FBQTtlQUFBLFNBQUMsS0FBRDtpQkFDdkIsS0FBQyxDQUFBLElBQUQsQ0FBQTtRQUR1QjtNQUFBLENBQUEsQ0FBQSxDQUFBLElBQUE7TUFHekIsSUFBQyxDQUFBLFdBQUQsR0FBbUIsSUFBQSxJQUFDLENBQUEsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFaLENBQXNCLENBQXRCLEVBQXdCLENBQXhCLEVBQTBCLEVBQTFCLEVBQTZCLEVBQTdCO01BQ25CLElBQUMsQ0FBQSxXQUFXLENBQUMsU0FBYixHQUF5QjtNQUN6QixJQUFDLENBQUEsV0FBVyxDQUFDLE9BQWIsR0FBdUI7TUFDdkIsSUFBQyxDQUFBLFdBQVcsQ0FBQyxTQUFiLEdBQXlCLENBQUEsU0FBQSxLQUFBO2VBQUEsU0FBQyxLQUFEO2lCQUN2QixLQUFDLENBQUEsSUFBRCxDQUFBO1FBRHVCO01BQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxFQVgzQjs7SUFjQSxJQUFDLENBQUEsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFaLENBQUE7SUFDQSxNQUFBLEdBQVMsSUFBSSxDQUFDO0lBRWQsV0FBQSxHQUFrQixJQUFBLFFBQUEsQ0FBUyxDQUFULEVBQVksQ0FBWjtBQUNsQixTQUFBLHdDQUFBOztNQUNFLGNBQUEsR0FBcUIsSUFBQSxRQUFBLENBQVMsQ0FBVCxFQUFZLENBQVo7QUFDckIsV0FBQSx1REFBQTs7UUFDRSxpQkFBQSxHQUF3QixJQUFBLFFBQUEsQ0FBUyxDQUFULEVBQVksQ0FBWjtBQUV4QjtBQUFBLGFBQUEsdUNBQUE7O1VBQ0UsSUFBQSxDQUFPLElBQUksQ0FBQyxpQkFBTCxDQUFBLENBQVA7WUFDRSxRQUFBLEdBQVcsV0FBVyxDQUFDLEtBQVosQ0FBQTtZQUNYLFFBQVEsQ0FBQyxHQUFULENBQWEsaUJBQWI7WUFDQSxRQUFRLENBQUMsUUFBVCxDQUFBO1lBQ0EsR0FBQSxHQUFNLFFBQVEsQ0FBQyxRQUFULENBQUE7WUFFTixJQUFHLENBQUMsQ0FBQyxHQUFGLENBQU0sSUFBQyxDQUFBLFVBQVAsRUFBbUIsR0FBbkIsQ0FBSDtjQUNFLElBQUMsQ0FBQSxVQUFXLENBQUEsR0FBQSxDQUFJLENBQUMsS0FBSyxDQUFDLElBQXZCLENBQTRCLElBQTVCLEVBREY7YUFBQSxNQUFBO2NBR0UsSUFBQyxDQUFBLFVBQVcsQ0FBQSxHQUFBLENBQVosR0FDRTtnQkFBQSxJQUFBLEVBQU0sUUFBTjtnQkFDQSxLQUFBLEVBQU8sUUFBUSxDQUFDLEtBQVQsQ0FBQSxDQURQO2dCQUVBLEtBQUEsRUFBTyxDQUFDLElBQUQsQ0FGUDtnQkFKSjs7WUFRQSxpQkFBaUIsQ0FBQyxHQUFsQixDQUFzQixJQUFJLENBQUMsUUFBTCxDQUFBLENBQXRCLEVBZEY7O0FBREY7UUFpQkEsSUFBRyxpQkFBaUIsQ0FBQyxLQUFsQixDQUFBLENBQUEsR0FBNEIsY0FBYyxDQUFDLEtBQWYsQ0FBQSxDQUEvQjtVQUNFLGNBQWMsQ0FBQyxJQUFmLENBQW9CLGlCQUFwQixFQURGOztBQXBCRjtNQXVCQSxXQUFXLENBQUMsR0FBWixDQUFnQixjQUFoQjtBQXpCRjtJQTJCQSxJQUFDLENBQUEsU0FBRCxHQUFhLENBQUMsQ0FBQyxNQUFGLENBQVMsQ0FBQyxDQUFDLE1BQUYsQ0FBUyxJQUFDLENBQUEsVUFBVixDQUFULEVBQWdDLFNBQUMsSUFBRDthQUFVLElBQUksQ0FBQztJQUFmLENBQWhDO0lBQ2IsSUFBQyxDQUFBLFdBQUQsR0FBZSxDQUFDLENBQUMsSUFBRixDQUFPLElBQUMsQ0FBQSxTQUFSO1dBQ2YsQ0FBQSxDQUFFLElBQUMsQ0FBQSxTQUFIO0VBM0RNOzttQkE2RFIsWUFBQSxHQUFjLFNBQUMsQ0FBRCxFQUFJLENBQUo7SUFDWixJQUFDLENBQUEsTUFBTSxDQUFDLFNBQVIsR0FBb0I7SUFDcEIsSUFBQyxDQUFBLE1BQU0sQ0FBQyxPQUFSLEdBQWtCO0lBQ2xCLElBQUMsQ0FBQSxNQUFNLENBQUMsV0FBUixDQUF3QixJQUFBLElBQUMsQ0FBQSxLQUFLLENBQUMsS0FBUCxDQUFhLENBQUEsR0FBSSxJQUFDLENBQUEsS0FBbEIsRUFBeUIsQ0FBQSxHQUFJLElBQUMsQ0FBQSxLQUE5QixDQUF4QjtXQUNBLElBQUMsQ0FBQSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQVosQ0FBQTtFQUpZOzttQkFNZCxRQUFBLEdBQVUsU0FBQyxLQUFEO0FBQ1IsUUFBQTtJQUFBLENBQUEsQ0FBRSxHQUFBLEdBQUksSUFBQyxDQUFBLGFBQUwsR0FBbUIsY0FBckIsRUFBb0MsS0FBcEM7QUFFQTtTQUFBLHVDQUFBOztNQUNFLENBQUEsR0FBSSxJQUFJLENBQUMsWUFBTCxDQUFBLENBQUEsR0FBc0I7TUFDMUIsQ0FBQSxHQUFJLElBQUksQ0FBQyxRQUFMLENBQUEsQ0FBZSxDQUFDLFdBQWhCLENBQTRCLENBQTVCO01BQ0osSUFBdUIsa0JBQXZCO1FBQUEsSUFBQyxDQUFBLFlBQUQsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLEVBQUE7O01BQ0EsSUFBWSxJQUFJLENBQUMsTUFBTCxDQUFBLENBQVo7QUFBQSxpQkFBQTs7TUFFQSxJQUFBLEdBQU8sSUFBSSxDQUFDLFdBQUwsQ0FBQTtNQUNQLFFBQUEsR0FBVyxJQUFJLENBQUMsUUFBTCxDQUFBLENBQWUsQ0FBQyxLQUFoQixDQUFBLENBQUEsR0FBMEIsQ0FBQyxJQUFDLENBQUEsR0FBRCxHQUFLLEVBQU47OztBQUNyQzthQUFBLHdDQUFBOztVQUNFLE1BQWlCLEdBQUcsQ0FBQyxLQUFKLENBQVUsR0FBVixDQUFqQixFQUFDLGFBQUQsRUFBTztVQUNQLElBQUEsR0FBTyxJQUFJLENBQUMsSUFBTCxDQUFBLENBQVcsQ0FBQyxXQUFaLENBQUE7VUFDUCxVQUFBLEdBQWEsVUFBVyxDQUFBLElBQUE7VUFDeEIsSUFBZ0Isa0JBQWhCO0FBQUEscUJBQUE7O1VBRUEsU0FBQSxHQUFZLENBQUMsRUFBQSxHQUFLLENBQUMsTUFBQSxHQUFTLEVBQVYsQ0FBTixDQUFBLEdBQXVCLFVBQVcsQ0FBQSxJQUFBLENBQUssQ0FBQztVQUNwRCxJQUFJLENBQUMsTUFBTCxDQUFZLENBQVosRUFBZSxTQUFmLEVBQTBCLEdBQTFCLEVBQStCLENBQS9CO3dCQUNBLElBQUksQ0FBQyxPQUFMLENBQWEsQ0FBYixFQUFnQixTQUFoQixFQUEyQixRQUEzQjtBQVJGOzs7QUFSRjs7RUFIUTs7bUJBcUJWLE9BQUEsR0FBUyxTQUFBO0lBQ1AsSUFBRyxJQUFDLENBQUEsSUFBSjtNQUNFLElBQUMsQ0FBQSxJQUFELENBQUE7QUFDQSxhQUZGOztJQUlBLElBQUMsQ0FBQSxhQUFELElBQWtCLElBQUMsQ0FBQTtJQUVuQixJQUFHLElBQUMsQ0FBQSxhQUFELElBQWtCLElBQUMsQ0FBQSxlQUFuQixJQUF1QyxJQUFDLENBQUEsU0FBUyxDQUFDLE1BQVgsR0FBb0IsQ0FBOUQ7TUFDRSxJQUFDLENBQUEsUUFBRCxDQUFVLElBQUMsQ0FBQSxTQUFVLENBQUEsSUFBQyxDQUFBLFVBQUQsQ0FBWSxDQUFDLEtBQWxDO01BQ0EsSUFBQyxDQUFBLFVBQUQ7TUFDQSxJQUFHLElBQUMsQ0FBQSxVQUFELElBQWUsSUFBQyxDQUFBLFNBQVMsQ0FBQyxNQUE3QjtlQUNFLElBQUMsQ0FBQSxJQUFELEdBQVEsS0FEVjtPQUFBLE1BQUE7ZUFHRSxJQUFDLENBQUEsZUFBRCxHQUFtQixJQUFDLENBQUEsU0FBVSxDQUFBLElBQUMsQ0FBQSxVQUFELENBQVksQ0FBQyxJQUFJLENBQUMsS0FBN0IsQ0FBQSxFQUhyQjtPQUhGOztFQVBPOzttQkFlVCxJQUFBLEdBQU0sU0FBQTtJQUNKLENBQUEsQ0FBRSxNQUFGO0lBQ0EsSUFBc0Msd0JBQXRDO01BQUEsTUFBTSxDQUFDLGFBQVAsQ0FBcUIsSUFBQyxDQUFBLFdBQXRCLEVBQUE7O0lBQ0EsSUFBbUMsd0JBQW5DO01BQUEsSUFBQyxDQUFBLFdBQVcsQ0FBQyxTQUFiLEdBQXlCLE9BQXpCOztJQUNBLElBQXNCLGtCQUF0QjtNQUFBLElBQUMsQ0FBQSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQVosQ0FBQSxFQUFBOztJQUNBLElBQUMsQ0FBQSxXQUFELEdBQWU7SUFDZixJQUFDLENBQUEsYUFBRCxHQUFpQjtJQUNqQixJQUFDLENBQUEsZUFBRCxHQUFtQjtJQUNuQixJQUFDLENBQUEsVUFBRCxHQUFjO1dBQ2QsSUFBQyxDQUFBLElBQUQsR0FBUTtFQVRKOzttQkFXTixLQUFBLEdBQU8sU0FBQTtJQUNMLElBQUMsQ0FBQSxJQUFELENBQUE7SUFDQSxDQUFBLENBQUUsT0FBRjtJQUNBLElBQW1DLHdCQUFuQztNQUFBLElBQUMsQ0FBQSxXQUFXLENBQUMsU0FBYixHQUF5QixPQUF6Qjs7SUFDQSxJQUFJLENBQUMsYUFBTCxDQUFtQixDQUFuQixFQUFzQixXQUFZLENBQUEsSUFBQyxDQUFBLE9BQU8sQ0FBQyxVQUFULENBQWxDO0lBQ0EsSUFBQyxDQUFBLE1BQUQsQ0FBQTtXQUNBLElBQUMsQ0FBQSxXQUFELEdBQWUsTUFBTSxDQUFDLFdBQVAsQ0FBbUIsQ0FBQyxDQUFBLFNBQUEsS0FBQTthQUFBLFNBQUE7ZUFBTSxLQUFDLENBQUEsT0FBRCxDQUFBO01BQU47SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUQsQ0FBbkIsRUFBdUMsSUFBQyxDQUFBLFlBQXhDO0VBTlY7O21CQVFQLElBQUEsR0FBTSxTQUFBO0lBQ0osQ0FBQSxDQUFFLFFBQUYsRUFBWSxJQUFDLENBQUEsWUFBYixFQUEyQixJQUFDLENBQUEsaUJBQTVCO0lBQ0EsSUFBRyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBbUIsQ0FBQSxJQUFDLENBQUEsT0FBTyxDQUFDLFVBQVQsQ0FBbkMsSUFBNEQsQ0FBSSxJQUFDLENBQUEsT0FBcEU7YUFDRSxJQUFDLENBQUEsS0FBRCxDQUFBLEVBREY7S0FBQSxNQUFBO01BR0UsQ0FBQSxDQUFFLHdCQUFGO01BQ0EsSUFBQyxDQUFBLGVBQWUsQ0FBQyxPQUFqQixHQUEyQjtNQUMzQixJQUFDLENBQUEsZUFBZSxDQUFDLFNBQWpCLEdBQTZCO01BQzdCLElBQUMsQ0FBQSxPQUFELEdBQVc7TUFDWCxJQUFDLENBQUEsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFaLENBQUE7YUFFQSxJQUFJLENBQUMsVUFBTCxDQUNFO1FBQUEsWUFBQSxFQUFjLElBQUMsQ0FBQSxPQUFPLENBQUMsYUFBdkI7UUFDQSxXQUFBLEVBQWEsQ0FBQyxJQUFDLENBQUEsT0FBTyxDQUFDLFVBQVYsQ0FEYjtRQUVBLFFBQUEsRUFBVSxDQUFBLFNBQUEsS0FBQTtpQkFBQSxTQUFBO1lBQ1IsT0FBTyxDQUFDLEdBQVIsQ0FBWSwwQ0FBWjtZQUNBLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFtQixDQUFBLEtBQUMsQ0FBQSxPQUFPLENBQUMsVUFBVCxDQUFuQyxHQUEwRDtZQUMxRCxLQUFDLENBQUEsT0FBRCxHQUFXO1lBQ1gsS0FBQyxDQUFBLGVBQWUsQ0FBQyxPQUFqQixHQUEyQjttQkFDM0IsS0FBQyxDQUFBLEtBQUQsQ0FBQTtVQUxRO1FBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUZWO09BREYsRUFURjs7RUFGSTs7Ozs7O0FBcUJSLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLEdBQUcsQ0FBQyxJQUFJLENBQUM7Ozs7QUN0UDFCLElBQUEsc0JBQUE7RUFBQTs7O0FBQUEsR0FBQSxHQUFNLE9BQUEsQ0FBUSxTQUFSOztBQUNOLENBQUEsR0FBSSxPQUFBLENBQVEsWUFBUjs7QUFDSixNQUFBLEdBQVMsT0FBQSxDQUFRLDBCQUFSOztBQUVIO0FBQ0osTUFBQTs7RUFBQSxNQUFDLENBQUEsS0FBRCxHQUFTOztFQUNULENBQUEsR0FBSSxTQUFBO0FBQWEsUUFBQTtJQUFaO0lBQVksSUFBOEMsTUFBTSxDQUFDLEtBQXJEO2tFQUFBLE9BQU8sQ0FBRSxHQUFULGdCQUFhLENBQUEsbUJBQXFCLFNBQUEsV0FBQSxJQUFBLENBQUEsQ0FBbEMsV0FBQTs7RUFBYjs7RUFHSixRQUFBLEdBQVcsU0FBQyxNQUFELEVBQVMsR0FBVDtXQUNMLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxZQUFULEVBQ1ksR0FBRCxHQUFLLFdBQUwsR0FBZ0IsTUFBTSxDQUFDLEVBQXZCLEdBQTBCLFVBQTFCLEdBQW9DLE1BQU0sQ0FBQyxFQUR0RDtFQURLOztFQUtFLGdCQUFDLE1BQUQ7SUFBQyxJQUFDLENBQUEsU0FBRDtJQUNaLElBQUMsQ0FBQSxLQUFELENBQUE7RUFEVzs7bUJBR2IsS0FBQSxHQUFPLFNBQUE7SUFDTCxJQUFDLENBQUEsS0FBRCxHQUFTO1dBQ1QsSUFBQyxDQUFBLFFBQUQsR0FBWTtFQUZQOzttQkFJUCxPQUFBLEdBQVMsU0FBQTtXQUFHLElBQUMsQ0FBQTtFQUFKOzttQkFFVCxTQUFBLEdBQVcsU0FBQTtBQUFHLFdBQU8sSUFBQyxDQUFBO0VBQVg7O21CQUVYLGlCQUFBLEdBQW1CLFNBQUMsT0FBRDtBQUNqQixRQUFBO0lBQUEsTUFBQSxHQUFTO0lBQ1QsSUFBcUIsZUFBckI7QUFBQSxhQUFPLE9BQVA7O0lBRUEsZUFBQSxHQUFrQjtBQUNsQixTQUFBLHlDQUFBOztNQUNFLEtBQUEsR0FBUSxTQUFDLEdBQUQ7ZUFBUyxRQUFBLENBQVMsTUFBVCxFQUFpQixHQUFqQjtNQUFUO01BQ1IsTUFBTyxDQUFBLE1BQU0sQ0FBQyxHQUFQLENBQVAsR0FBcUIsTUFBTSxDQUFDO0FBQzVCLGNBQU8sTUFBTSxDQUFDLEdBQWQ7QUFBQSxhQUNPLFVBRFA7QUFBQSxhQUNtQixXQURuQjtVQUVJLGVBQUEsR0FBa0I7VUFDbEIsV0FBNEQsTUFBTSxDQUFDLE1BQVAsS0FBcUIsTUFBckIsSUFBQSxHQUFBLEtBQTZCLE9BQXpGO0FBQUEsa0JBQU0sS0FBQSxDQUFNLEdBQUEsR0FBSSxNQUFNLENBQUMsR0FBWCxHQUFlLDZCQUFyQixFQUFOOztBQUZlO0FBRG5CLGFBSU8sS0FKUDtVQUtJLElBQUEsQ0FBOEQsQ0FBQyxDQUFDLEdBQUYsQ0FBTSxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUE1QixFQUFzQyxNQUFNLENBQUMsS0FBN0MsQ0FBOUQ7QUFBQSxrQkFBTSxLQUFBLENBQU0seUJBQUEsR0FBMEIsTUFBTSxDQUFDLEtBQWpDLEdBQXVDLEdBQTdDLEVBQU47O0FBREc7QUFKUCxhQU1PLE1BTlA7VUFPSSxLQUFBLEdBQVEsQ0FBQyxRQUFELEVBQVcsTUFBWCxFQUFtQixPQUFuQixFQUE0QixNQUE1QixFQUFvQyxZQUFwQyxFQUFrRCxNQUFsRDtVQUNSLFdBQTRELE1BQU0sQ0FBQyxLQUFQLEVBQUEsYUFBb0IsS0FBcEIsRUFBQSxJQUFBLEtBQTVEO0FBQUEsa0JBQU0sS0FBQSxDQUFNLHdCQUFBLEdBQXdCLENBQUMsS0FBSyxDQUFDLElBQU4sQ0FBVyxJQUFYLENBQUQsQ0FBOUIsRUFBTjs7QUFGRztBQU5QLGFBU08sT0FUUDtVQVVJLE1BQUEsR0FBUyxDQUFDLEtBQUQsRUFBUSxRQUFSLEVBQWtCLEtBQWxCO1VBQ1QsV0FBOEQsTUFBTSxDQUFDLEtBQVAsRUFBQSxhQUFvQixNQUFwQixFQUFBLElBQUEsS0FBOUQ7QUFBQSxrQkFBTSxLQUFBLENBQU0seUJBQUEsR0FBeUIsQ0FBQyxNQUFNLENBQUMsSUFBUCxDQUFZLElBQVosQ0FBRCxDQUEvQixFQUFOOztBQUZHO0FBVFAsYUFZTyxNQVpQO0FBYUk7WUFDTSxJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBVCxDQUF1QixNQUFNLENBQUMsS0FBOUIsRUFETjtXQUFBLGNBQUE7WUFFTTtBQUNKLGtCQUFNLEtBQUEsQ0FBTSwyQkFBQSxHQUE0QixNQUFNLENBQUMsS0FBbkMsR0FBeUMsR0FBL0MsRUFIUjs7QUFERztBQVpQLGFBaUJPLFFBakJQO0FBa0JJO1lBQ00sSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQVQsQ0FBZ0IsTUFBTSxDQUFDLEtBQXZCLEVBRE47V0FBQSxjQUFBO1lBRU07QUFDSixrQkFBTSxLQUFBLENBQU0sbUJBQUEsR0FBb0IsTUFBTSxDQUFDLEtBQTNCLEdBQWlDLEdBQXZDLEVBSFI7O0FBREc7QUFqQlAsYUFzQk8sU0F0QlA7VUF1QkksV0FBQSxHQUFjLFFBQUEsQ0FBUyxNQUFNLENBQUMsS0FBaEI7VUFDZCxJQUE2RCxXQUFBLEdBQWMsQ0FBZCxJQUFtQixXQUFBLEdBQWMsQ0FBOUY7QUFBQSxrQkFBTSxLQUFBLENBQU0sNkJBQUEsR0FBOEIsV0FBcEMsRUFBTjs7QUFGRztBQXRCUDtBQTBCSSxnQkFBTSxLQUFBLENBQU0sa0JBQUEsR0FBbUIsTUFBTSxDQUFDLEdBQTFCLEdBQThCLEdBQXBDO0FBMUJWO0FBSEY7SUErQkEsSUFBRyxNQUFNLENBQUMsUUFBUCxLQUFtQixPQUFuQixJQUErQixNQUFNLENBQUMsU0FBUCxLQUFvQixPQUF0RDtBQUNFLFlBQU0sUUFBQSxDQUFTLGVBQVQsRUFBMEIsb0RBQTFCLEVBRFI7O0FBR0EsV0FBTztFQXZDVTs7bUJBeUNuQixZQUFBLEdBQWMsU0FBQyxPQUFEO0lBQ1osSUFBRyxPQUFPLENBQUMsT0FBUixLQUFtQixLQUF0QjtNQUNFLElBQUMsQ0FBQSxNQUFNLENBQUMsTUFBUixDQUFlLE9BQU8sQ0FBQyxJQUF2QixFQURGOztJQUdBLElBQUcsT0FBTyxDQUFDLE9BQVIsS0FBbUIsUUFBdEI7TUFDRSxJQUFDLENBQUEsTUFBTSxDQUFDLFdBQVIsQ0FBb0IsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFuQyxFQUEyQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQTFELEVBREY7O0lBR0EsSUFBRyxPQUFPLENBQUMsT0FBUixLQUFtQixhQUF0QjtNQUNFLElBQUMsQ0FBQSxNQUFNLENBQUMsY0FBUixDQUF1QixPQUFPLENBQUMsTUFBL0IsRUFERjs7SUFHQSxJQUFHLE9BQU8sQ0FBQyxPQUFSLEtBQW1CLE1BQXRCO01BQ0UsSUFBQyxDQUFBLE1BQU0sQ0FBQyxPQUFSLENBQWdCLE9BQU8sQ0FBQyxNQUF4QixFQURGOztJQUdBLElBQUcsT0FBTyxDQUFDLE9BQVIsS0FBbUIsU0FBdEI7YUFDRSxJQUFDLENBQUEsTUFBTSxDQUFDLFVBQVIsQ0FBbUIsT0FBTyxDQUFDLE1BQTNCLEVBQW1DLE9BQU8sQ0FBQyxFQUEzQyxFQUErQyxPQUFPLENBQUMsRUFBdkQsRUFERjs7RUFiWTs7bUJBZ0JkLFVBQUEsR0FBWSxTQUFDLE9BQUQ7SUFDVixDQUFBLENBQUUsYUFBRixFQUFpQixPQUFqQjtXQUNBLElBQUMsQ0FBQSxNQUFNLENBQUMsUUFBUixDQUNFLENBQUMsQ0FBQyxHQUFGLENBQU0sT0FBTyxDQUFDLEtBQWQsRUFDTSxTQUFDLElBQUQ7YUFBUyxDQUFDLENBQUMsSUFBRixDQUFPLElBQVAsRUFBYSxNQUFiLEVBQXFCLEtBQXJCLEVBQTRCLE1BQTVCLEVBQW9DLEtBQXBDLEVBQTJDLFFBQTNDLEVBQXFELFFBQXJELEVBQStELGNBQS9ELEVBQStFLFdBQS9FO0lBQVQsQ0FETixDQURGLEVBR0UsT0FBTyxDQUFDLFlBSFYsRUFHd0IsT0FBTyxDQUFDLFNBSGhDO0VBRlU7O21CQU9aLFNBQUEsR0FBVyxTQUFDLElBQUQ7V0FDVCxJQUFDLENBQUEsTUFBTSxDQUFDLE9BQVIsQ0FBZ0IsQ0FBQyxDQUFDLElBQUYsQ0FDZCxJQURjLEVBQ1IsTUFEUSxFQUNBLEtBREEsRUFDTyxNQURQLEVBQ2UsUUFEZixFQUN5QixjQUR6QixFQUN5QyxXQUR6QyxDQUFoQjtFQURTOzttQkFJWCxRQUFBLEdBQVUsU0FBQyxJQUFEO1dBQ1IsSUFBQyxDQUFBLE1BQU0sQ0FBQyxPQUFSLENBQWdCLENBQUMsQ0FBQyxJQUFGLENBQ2QsSUFEYyxFQUNSLE1BRFEsRUFDQSxLQURBLEVBQ08sTUFEUCxFQUNlLEtBRGYsRUFDc0IsUUFEdEIsRUFDZ0MsUUFEaEMsRUFDMEMsY0FEMUMsRUFDMEQsV0FEMUQsQ0FBaEI7RUFEUTs7bUJBSVYsa0JBQUEsR0FBb0IsU0FBQyxLQUFEO0FBQ2xCLFFBQUE7SUFBQSxDQUFBLENBQUUscUJBQUYsRUFBeUIsS0FBekI7QUFDQTtTQUFBLHVDQUFBOztNQUNFLElBQUcsT0FBTyxDQUFDLElBQVg7UUFDRSxJQUFDLENBQUEsTUFBTSxDQUFDLFdBQVIsQ0FBb0IsT0FBTyxDQUFDLElBQTVCLEVBQWtDLE9BQU8sQ0FBQyxHQUExQyxFQURGOztNQUdBLElBQUcsT0FBTyxDQUFDLE9BQVg7UUFDRSxJQUFDLENBQUEsWUFBRCxDQUFjLE9BQWQsRUFERjs7TUFHQSxJQUFHLE9BQU8sQ0FBQyxLQUFYO1FBQ0UsSUFBQyxDQUFBLFVBQUQsQ0FBWSxPQUFaLEVBREY7O01BR0EsSUFBRyxPQUFPLENBQUMsR0FBWDtxQkFDRSxJQUFDLENBQUEsUUFBRCxDQUFVLE9BQVYsR0FERjtPQUFBLE1BRUssSUFBRyxPQUFPLENBQUMsSUFBWDtxQkFDSCxJQUFDLENBQUEsU0FBRCxDQUFXLE9BQVgsR0FERztPQUFBLE1BQUE7NkJBQUE7O0FBWlA7O0VBRmtCOzttQkFpQnBCLGNBQUEsR0FBZ0IsU0FBQyxTQUFEO0FBQ2QsUUFBQTtJQUFBLElBQUEsQ0FBOEIsQ0FBQyxDQUFDLE9BQUYsQ0FBVSxTQUFWLENBQTlCO01BQUEsSUFBQyxDQUFBLE1BQU0sQ0FBQyxZQUFSLENBQUEsRUFBQTs7SUFFQSxRQUFBLEdBQVc7SUFDWCxhQUFBLEdBQWdCO0lBQ2hCLE1BQUEsR0FBUztJQUNULElBQUEsR0FBTztJQUVQLE9BQUEsR0FBVSxDQUFBLFNBQUEsS0FBQTthQUFBLFNBQUE7ZUFBRyxLQUFDLENBQUEsTUFBTSxDQUFDLFdBQVIsQ0FBb0IsRUFBcEIsRUFBd0IsQ0FBeEIsRUFBMkIsYUFBM0IsRUFBMEMsS0FBMUMsRUFBaUQsSUFBakQ7TUFBSDtJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUE7SUFDVixVQUFBLEdBQWEsQ0FBQSxTQUFBLEtBQUE7YUFBQSxTQUFDLElBQUQ7QUFDWCxZQUFBO1FBQUEsWUFBQSxHQUFlO1FBQ2YsSUFBRyxJQUFLLENBQUEsQ0FBQSxDQUFMLEtBQVcsR0FBZDtVQUNFLFlBQUEsR0FBZTtVQUNmLElBQUEsR0FBTyxJQUFLLFVBRmQ7O0FBSUE7aUJBQ0UsS0FBQyxDQUFBLE1BQU0sQ0FBQyxXQUFSLENBQW9CLElBQXBCLEVBQTBCLFFBQTFCLEVBQW9DLGFBQXBDLEVBQW1ELE1BQW5ELEVBQTJELFlBQTNELEVBREY7U0FBQSxjQUFBO1VBRU07QUFDSixnQkFBTSxRQUFBLENBQVMsR0FBVCxFQUFjLCtDQUFBLEdBQWtELENBQWhFLEVBSFI7O01BTlc7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBO0FBV2I7U0FBQSwyQ0FBQTs7TUFDRSxJQUFBLEdBQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFULENBQUE7TUFDUCxJQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsV0FBWCxDQUFIO1FBQ0UsSUFBQSxHQUFPLElBQUs7cUJBQ1osSUFBQyxDQUFBLE1BQU0sQ0FBQyxXQUFSLENBQW9CLElBQXBCLEdBRkY7T0FBQSxNQUdLLElBQUcsSUFBSyxDQUFBLENBQUEsQ0FBTCxLQUFXLEdBQWQ7cUJBQ0gsSUFBQyxDQUFBLE1BQU0sQ0FBQyxXQUFSLENBQW9CLElBQXBCLEdBREc7T0FBQSxNQUVBLElBQUcsSUFBSyxDQUFBLENBQUEsQ0FBTCxLQUFXLEdBQWQ7UUFDSCxPQUFBLEdBQVUsSUFBSztBQUNmLGdCQUFPLE9BQVA7QUFBQSxlQUNPLFFBRFA7QUFBQSxlQUNpQixNQURqQjtBQUFBLGVBQ3lCLE9BRHpCO3lCQUVJLGFBQUEsR0FBZ0I7QUFESztBQUR6QixlQUdPLFFBSFA7eUJBSUksTUFBQSxHQUFTO0FBRE47QUFIUCxlQUtPLFFBTFA7eUJBTUksTUFBQSxHQUFTO0FBRE47QUFMUCxlQU9PLEtBUFA7QUFBQSxlQU9jLEdBUGQ7eUJBUUksT0FBQSxDQUFBO0FBRFU7QUFQZDt5QkFVSSxRQUFBLEdBQVcsUUFBQSxDQUFTLElBQUssU0FBZCxFQUFvQixFQUFwQjtBQVZmLFNBRkc7T0FBQSxNQWFBLElBQUcsSUFBQSxLQUFRLEdBQVg7cUJBQ0gsT0FBQSxDQUFBLEdBREc7T0FBQSxNQUVBLElBQUcsSUFBSyxZQUFMLEtBQWMsSUFBakI7cUJBQ0gsSUFBQyxDQUFBLE1BQU0sQ0FBQyxZQUFSLENBQUEsR0FERztPQUFBLE1BQUE7cUJBR0gsVUFBQSxDQUFXLElBQVgsR0FIRzs7QUF0QlA7O0VBcEJjOzttQkErQ2hCLFFBQUEsR0FBVSxTQUFBO0FBQ1IsUUFBQTtBQUFBO0FBQUE7U0FBQSxxQ0FBQTs7QUFDRSxjQUFPLEtBQUssQ0FBQyxPQUFiO0FBQUEsYUFDTyxPQURQO0FBQUEsYUFDZ0IsVUFEaEI7VUFFSSxJQUFDLENBQUEsTUFBTSxDQUFDLFFBQVIsQ0FBaUIsS0FBSyxDQUFDLE9BQXZCLEVBQWdDLElBQUMsQ0FBQSxpQkFBRCxDQUFtQixLQUFLLENBQUMsT0FBekIsQ0FBaEM7VUFDQSxJQUFvQyxtQkFBcEM7WUFBQSxJQUFDLENBQUEsa0JBQUQsQ0FBb0IsS0FBSyxDQUFDLEtBQTFCLEVBQUE7O1VBQ0EsSUFBK0Isa0JBQS9CO3lCQUFBLElBQUMsQ0FBQSxjQUFELENBQWdCLEtBQUssQ0FBQyxJQUF0QixHQUFBO1dBQUEsTUFBQTtpQ0FBQTs7QUFIWTtBQURoQixhQUtPLE9BTFA7VUFNSSxJQUFDLENBQUEsTUFBTSxDQUFDLFFBQVIsQ0FBaUIsSUFBQyxDQUFBLGlCQUFELENBQW1CLEtBQUssQ0FBQyxPQUF6QixDQUFqQjtVQUNBLElBQW9DLG1CQUFwQztZQUFBLElBQUMsQ0FBQSxrQkFBRCxDQUFvQixLQUFLLENBQUMsS0FBMUIsRUFBQTs7VUFDQSxJQUErQixrQkFBL0I7eUJBQUEsSUFBQyxDQUFBLGNBQUQsQ0FBZ0IsS0FBSyxDQUFDLElBQXRCLEdBQUE7V0FBQSxNQUFBO2lDQUFBOztBQUhHO0FBTFAsYUFTTyxTQVRQO1VBVUksT0FBQSxHQUFVO0FBQ1Y7QUFBQSxlQUFBLHdDQUFBOztZQUNFLE9BQVEsQ0FBQSxNQUFNLENBQUMsR0FBUCxDQUFSLEdBQXNCLE1BQU0sQ0FBQztBQUQvQjtBQUVBO3lCQUNFLElBQUMsQ0FBQSxNQUFNLENBQUMsVUFBUixDQUFtQixPQUFuQixHQURGO1dBQUEsY0FBQTtZQUVNO0FBQ0osa0JBQU0sUUFBQSxDQUFTLEtBQVQsRUFBZ0IsQ0FBQyxDQUFDLE9BQWxCLEVBSFI7O0FBSkc7QUFUUDtBQWtCSSxnQkFBTSxRQUFBLENBQVMsS0FBVCxFQUFnQixtQkFBQSxHQUFvQixLQUFLLENBQUMsT0FBMUIsR0FBa0MsR0FBbEQ7QUFsQlY7QUFERjs7RUFEUTs7bUJBc0JWLEtBQUEsR0FBTyxTQUFDLElBQUQ7QUFDTCxRQUFBO0lBQUEsTUFBTSxDQUFDLFVBQVAsR0FBb0IsU0FBQyxPQUFELEVBQVUsSUFBVjtNQUNsQixDQUFBLENBQUUsc0JBQUYsRUFBMEIsT0FBMUIsRUFBbUMsSUFBbkM7TUFDQSxPQUFBLEdBQVUsbUJBQUEsR0FBb0IsSUFBSSxDQUFDLElBQXpCLEdBQThCLFlBQTlCLEdBQTBDLElBQUksQ0FBQyxHQUFHLENBQUMsVUFBbkQsR0FBOEQsVUFBOUQsR0FBd0UsSUFBSSxDQUFDLEdBQUcsQ0FBQyxZQUFqRixHQUE4RjtBQUN4RyxZQUFVLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxZQUFULEVBQXVCLE9BQXZCO0lBSFE7SUFLcEIsSUFBbUQsWUFBbkQ7QUFBQSxZQUFVLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxZQUFULEVBQXVCLFNBQXZCLEVBQVY7O0lBRUEsQ0FBQSxDQUFFLFlBQUEsR0FBYSxJQUFmO0lBR0EsYUFBQTs7QUFBaUI7QUFBQTtXQUFBLHFDQUFBOztxQkFBQSxJQUFJLENBQUMsSUFBTCxDQUFBO0FBQUE7OztJQUNqQixJQUFDLENBQUEsUUFBRCxHQUFZLE1BQU0sQ0FBQyxLQUFQLENBQWEsYUFBYSxDQUFDLElBQWQsQ0FBbUIsSUFBbkIsQ0FBYjtJQUNaLElBQUcsSUFBQyxDQUFBLFFBQUo7TUFDRSxJQUFDLENBQUEsUUFBRCxDQUFBO01BQ0EsSUFBQyxDQUFBLEtBQUQsR0FBUyxLQUZYOztBQUlBLFdBQU8sSUFBQyxDQUFBO0VBakJIOzs7Ozs7QUFtQlQsTUFBTSxDQUFDLE9BQVAsR0FBaUI7Ozs7QUNsTmpCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwiLyogcGFyc2VyIGdlbmVyYXRlZCBieSBqaXNvbiAwLjQuMTYgKi9cbi8qXG4gIFJldHVybnMgYSBQYXJzZXIgb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuXG4gIFBhcnNlcjoge1xuICAgIHl5OiB7fVxuICB9XG5cbiAgUGFyc2VyLnByb3RvdHlwZToge1xuICAgIHl5OiB7fSxcbiAgICB0cmFjZTogZnVuY3Rpb24oKSxcbiAgICBzeW1ib2xzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IG51bWJlcn0sXG4gICAgdGVybWluYWxzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gbmFtZX0sXG4gICAgcHJvZHVjdGlvbnNfOiBbLi4uXSxcbiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSwgJCQsIF8kKSxcbiAgICB0YWJsZTogWy4uLl0sXG4gICAgZGVmYXVsdEFjdGlvbnM6IHsuLi59LFxuICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCksXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0KSxcblxuICAgIGxleGVyOiB7XG4gICAgICAgIEVPRjogMSxcbiAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSxcbiAgICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0KSxcbiAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLFxuICAgICAgICBtb3JlOiBmdW5jdGlvbigpLFxuICAgICAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAgICAgICAgcGFzdElucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICBzaG93UG9zaXRpb246IGZ1bmN0aW9uKCksXG4gICAgICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4X21hdGNoX2FycmF5LCBydWxlX2luZGV4KSxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSxcbiAgICAgICAgbGV4OiBmdW5jdGlvbigpLFxuICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gICAgICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uKCksXG4gICAgICAgIHRvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcmFuZ2VzOiBib29sZWFuICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IHRva2VuIGxvY2F0aW9uIGluZm8gd2lsbCBpbmNsdWRlIGEgLnJhbmdlW10gbWVtYmVyKVxuICAgICAgICAgICAgZmxleDogYm9vbGVhbiAgICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IGZsZXgtbGlrZSBsZXhpbmcgYmVoYXZpb3VyIHdoZXJlIHRoZSBydWxlcyBhcmUgdGVzdGVkIGV4aGF1c3RpdmVseSB0byBmaW5kIHRoZSBsb25nZXN0IG1hdGNoKVxuICAgICAgICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuICAob3B0aW9uYWw6IHRydWUgPT0+IGxleGVyIHJlZ2V4ZXMgYXJlIHRlc3RlZCBpbiBvcmRlciBhbmQgZm9yIGVhY2ggbWF0Y2hpbmcgcmVnZXggdGhlIGFjdGlvbiBjb2RlIGlzIGludm9rZWQ7IHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUpXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24oeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQpLFxuICAgICAgICBydWxlczogWy4uLl0sXG4gICAgICAgIGNvbmRpdGlvbnM6IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBzZXR9LFxuICAgIH1cbiAgfVxuXG5cbiAgdG9rZW4gbG9jYXRpb24gaW5mbyAoQCQsIF8kLCBldGMuKToge1xuICAgIGZpcnN0X2xpbmU6IG4sXG4gICAgbGFzdF9saW5lOiBuLFxuICAgIGZpcnN0X2NvbHVtbjogbixcbiAgICBsYXN0X2NvbHVtbjogbixcbiAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl0gICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgcmVndWxhciB6ZXJvLWJhc2VkKVxuICB9XG5cblxuICB0aGUgcGFyc2VFcnJvciBmdW5jdGlvbiByZWNlaXZlcyBhICdoYXNoJyBvYmplY3Qgd2l0aCB0aGVzZSBtZW1iZXJzIGZvciBsZXhlciBhbmQgcGFyc2VyIGVycm9yczoge1xuICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KVxuICAgIHRva2VuOiAgICAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuLCBpZiBhbnkpXG4gICAgbGluZTogICAgICAgICh5eWxpbmVubylcbiAgfVxuICB3aGlsZSBwYXJzZXIgKGdyYW1tYXIpIGVycm9ycyB3aWxsIGFsc28gcHJvdmlkZSB0aGVzZSBtZW1iZXJzLCBpLmUuIHBhcnNlciBlcnJvcnMgZGVsaXZlciBhIHN1cGVyc2V0IG9mIGF0dHJpYnV0ZXM6IHtcbiAgICBsb2M6ICAgICAgICAgKHl5bGxvYylcbiAgICBleHBlY3RlZDogICAgKHN0cmluZyBkZXNjcmliaW5nIHRoZSBzZXQgb2YgZXhwZWN0ZWQgdG9rZW5zKVxuICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgaGFzIGEgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcilcbiAgfVxuKi9cbnZhciBwYXJzZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBvPWZ1bmN0aW9uKGssdixvLGwpe2ZvcihvPW98fHt9LGw9ay5sZW5ndGg7bC0tO29ba1tsXV09dik7cmV0dXJuIG99LCRWMD1bMSw2XSwkVjE9WzEsN10sJFYyPVsxLDhdLCRWMz1bMSw5XSwkVjQ9WzUsMTEsMTMsMTQsMTVdLCRWNT1bNSwxMSwxMywxNCwxNSwxNywxOSwyMV0sJFY2PVsyLDE3XSwkVjc9WzEsMTRdLCRWOD1bNSwxMSwxMywxNCwxNSwxNywxOSwyMSwyMl0sJFY5PVsxLDE4XSwkVmE9WzEsMTldLCRWYj1bMSwyMF0sJFZjPVsxLDIxXSwkVmQ9WzEsNDNdLCRWZT1bMSwzMl0sJFZmPVsxLDMzXSwkVmc9WzEsNDJdLCRWaD1bMSw0MV0sJFZpPVsxLDM5XSwkVmo9WzEsNDhdLCRWaz1bMSw1NV0sJFZsPVsxLDUwXSwkVm09WzEsNTFdLCRWbj1bMSw1Ml0sJFZvPVsxLDUzXSwkVnA9WzEsNTRdLCRWcT1bMSw1Nl0sJFZyPVsxLDQ0XSwkVnM9WzEsNDVdLCRWdD1bMSw0Nl0sJFZ1PVsxLDQ3XSwkVnY9WzEsNTddLCRWdz1bNSwxMSwxMywxNCwxNSwxNywxOSwyMSwyNV0sJFZ4PVs1LDExLDEzLDE0LDE1LDE3LDE5LDIxLDIzLDMxLDMyLDM3LDM4LDQ1LDQ4LDU3LDYxLDYyLDYzLDY0LDY1LDY2LDcwLDcxLDczLDc1LDc2XSwkVnk9WzIsNzldLCRWej1bMSw2N10sJFZBPVsxLDY0XSwkVkI9WzEsNjVdLCRWQz1bMSw2Nl0sJFZEPVsxLDczXSwkVkU9WzEsNzRdLCRWRj1bMSw3OF0sJFZHPVsxLDc5XSwkVkg9WzEsODBdLCRWST1bMSw4MV0sJFZKPVs0MSw1Nyw1OSw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OV0sJFZLPVszOCw0NSw0OCw3Nl0sJFZMPVs0MSw0OCw1Nyw1OSw2MSw2Miw2Myw2NCw2NSw2Niw2Nyw2OCw2OSw4MV0sJFZNPVs1LDExLDEzLDE0LDE1LDE3LDE5LDIxLDIzLDMxLDMyLDM3LDM4LDQxLDQ1LDQ4LDU3LDYxLDYyLDYzLDY0LDY1LDY2LDcwLDcxLDczLDc1LDc2XSwkVk49WzEsMTAxXSwkVk89WzQ0LDQ2XSwkVlA9WzIsNjNdLCRWUT1bMSwxMDZdLCRWUj1bNSwxMSwxMywxNCwxNSwxNywxOSwyMSwyMywzMSwzMiwzNywzOCw0NSw0OCw1Nyw1OSw2MSw2Miw2Myw2NCw2NSw2Niw3MCw3MSw3Myw3NSw3Nl0sJFZTPVs1LDExLDEzLDE0LDE1LDE3LDE5LDIxLDIzLDMxLDMyLDM3LDM4LDQ1LDQ4LDU3LDU5LDYwLDYxLDYyLDYzLDY0LDY1LDY2LDcwLDcxLDczLDc1LDc2XSwkVlQ9WzI1LDcxXSwkVlU9WzQxLDQ4LDU3LDU5LDYxLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5XSwkVlY9WzUsMTEsMTMsMTQsMTUsMTcsMTksMjEsMjMsMzEsMzIsMzcsMzgsNDQsNDUsNDYsNDgsNTcsNjEsNjIsNjMsNjQsNjUsNjYsNzAsNzEsNzMsNzUsNzZdO1xudmFyIHBhcnNlciA9IHt0cmFjZTogZnVuY3Rpb24gdHJhY2UoKSB7IH0sXG55eToge30sXG5zeW1ib2xzXzoge1wiZXJyb3JcIjoyLFwiZVwiOjMsXCJtYXliZV92ZXh0YWJcIjo0LFwiRU9GXCI6NSxcInZleHRhYlwiOjYsXCJzdGF2ZVwiOjcsXCJ2b2ljZVwiOjgsXCJtYXliZV9vcHRpb25zXCI6OSxcInN0YXZlX2RhdGFcIjoxMCxcIk9QVElPTlNcIjoxMSxcIm9wdGlvbnNcIjoxMixcIlRBQlNUQVZFXCI6MTMsXCJTVEFWRVwiOjE0LFwiVk9JQ0VcIjoxNSxcInN0YXZlX2FkZGl0aW9uc1wiOjE2LFwiVEVYVFwiOjE3LFwidGV4dFwiOjE4LFwiTk9URVNcIjoxOSxcIm5vdGVzXCI6MjAsXCJTTFVSXCI6MjEsXCJXT1JEXCI6MjIsXCI9XCI6MjMsXCJTVFJcIjoyNCxcIixcIjoyNSxcImxpbmdvXCI6MjYsXCJsaW5lXCI6MjcsXCJjaG9yZFwiOjI4LFwidGltZVwiOjI5LFwiYmFyXCI6MzAsXCJbXCI6MzEsXCJdXCI6MzIsXCJ0dXBsZXRzXCI6MzMsXCJhbm5vdGF0aW9uc1wiOjM0LFwiY29tbWFuZFwiOjM1LFwicmVzdFwiOjM2LFwifFwiOjM3LFwiOlwiOjM4LFwiZnJldHNcIjozOSxcIm1heWJlX2RlY29yYXRvclwiOjQwLFwiL1wiOjQxLFwic3RyaW5nXCI6NDIsXCJjaG9yZF9saW5lXCI6NDMsXCIuXCI6NDQsXCIoXCI6NDUsXCIpXCI6NDYsXCJhcnRpY3VsYXRpb25cIjo0NyxcIk5VTUJFUlwiOjQ4LFwiYWJjXCI6NDksXCJfXCI6NTAsXCJ0aW1lZF9mcmV0XCI6NTEsXCJ0aW1lX3ZhbHVlc1wiOjUyLFwibWF5YmVfZG90XCI6NTMsXCJ0aW1lX3VuaXRcIjo1NCxcIm1heWJlX3NsYXNoXCI6NTUsXCJ3XCI6NTYsXCJoXCI6NTcsXCJxXCI6NTgsXCJkXCI6NTksXCJTXCI6NjAsXCItXCI6NjEsXCJzXCI6NjIsXCJ0XCI6NjMsXCJUXCI6NjQsXCJiXCI6NjUsXCJwXCI6NjYsXCJ2XCI6NjcsXCJWXCI6NjgsXCJ1XCI6NjksXCJeXCI6NzAsXCIkXCI6NzEsXCJhbm5vdGF0aW9uX3dvcmRzXCI6NzIsXCIhXCI6NzMsXCJDT01NQU5EXCI6NzQsXCIjXCI6NzUsXCJBQkNcIjo3NixcImFiY19hY2NpZGVudGFsXCI6NzcsXCJhY2NpZGVudGFsX3R5cGVcIjo3OCxcIkBcIjo3OSxcIm5cIjo4MCxcIn5cIjo4MSxcIiRhY2NlcHRcIjowLFwiJGVuZFwiOjF9LFxudGVybWluYWxzXzogezI6XCJlcnJvclwiLDU6XCJFT0ZcIiwxMTpcIk9QVElPTlNcIiwxMzpcIlRBQlNUQVZFXCIsMTQ6XCJTVEFWRVwiLDE1OlwiVk9JQ0VcIiwxNzpcIlRFWFRcIiwxOTpcIk5PVEVTXCIsMjE6XCJTTFVSXCIsMjI6XCJXT1JEXCIsMjM6XCI9XCIsMjQ6XCJTVFJcIiwyNTpcIixcIiwzMTpcIltcIiwzMjpcIl1cIiwzNzpcInxcIiwzODpcIjpcIiw0MTpcIi9cIiw0NDpcIi5cIiw0NTpcIihcIiw0NjpcIilcIiw0ODpcIk5VTUJFUlwiLDUwOlwiX1wiLDU2Olwid1wiLDU3OlwiaFwiLDU4OlwicVwiLDU5OlwiZFwiLDYwOlwiU1wiLDYxOlwiLVwiLDYyOlwic1wiLDYzOlwidFwiLDY0OlwiVFwiLDY1OlwiYlwiLDY2OlwicFwiLDY3OlwidlwiLDY4OlwiVlwiLDY5OlwidVwiLDcwOlwiXlwiLDcxOlwiJFwiLDczOlwiIVwiLDc0OlwiQ09NTUFORFwiLDc1OlwiI1wiLDc2OlwiQUJDXCIsNzk6XCJAXCIsODA6XCJuXCIsODE6XCJ+XCJ9LFxucHJvZHVjdGlvbnNfOiBbMCxbMywyXSxbNCwwXSxbNCwxXSxbNiwxXSxbNiwyXSxbNywzXSxbNywyXSxbNywyXSxbOCwxXSxbOCwxXSxbOCwxXSxbMTAsMV0sWzEwLDJdLFsxNiwyXSxbMTYsMl0sWzE2LDJdLFs5LDBdLFs5LDFdLFsxMiwzXSxbMTIsNF0sWzE4LDFdLFsxOCwzXSxbMjAsMV0sWzIwLDJdLFsyNiwxXSxbMjYsMV0sWzI2LDFdLFsyNiwxXSxbMjYsMV0sWzI2LDFdLFsyNiwxXSxbMjYsMV0sWzI2LDFdLFsyNiwxXSxbMzAsMV0sWzMwLDNdLFszMCwzXSxbMzAsM10sWzMwLDNdLFszMCwzXSxbMjcsNF0sWzQzLDFdLFs0MywzXSxbMjgsNF0sWzI4LDVdLFszOSwxXSxbMzksMV0sWzM5LDRdLFszOSwyXSxbMzksNF0sWzUxLDVdLFs1MSwxXSxbNTEsNV0sWzUxLDhdLFs1MSwxXSxbNTEsNF0sWzI5LDNdLFs1MiwyXSxbNTQsMV0sWzU0LDFdLFs1NCwxXSxbNTQsMV0sWzUzLDBdLFs1MywxXSxbNTUsMF0sWzU1LDFdLFs0MiwxXSxbNDcsMV0sWzQ3LDFdLFs0NywxXSxbNDcsMV0sWzQ3LDFdLFs0NywxXSxbNDcsMV0sWzQwLDFdLFs0MCwxXSxbNDAsMV0sWzQwLDFdLFs0MCwwXSxbMzMsM10sWzMzLDVdLFszNCwzXSxbNzIsMV0sWzcyLDNdLFszNSwzXSxbMzYsMl0sWzM2LDNdLFszNiw0XSxbNDksM10sWzc3LDFdLFs3NywyXSxbNzcsMV0sWzc3LDJdLFs3NywxXSxbNzcsMF0sWzc4LDBdLFs3OCwxXV0sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSAvKiBhY3Rpb25bMV0gKi8sICQkIC8qIHZzdGFjayAqLywgXyQgLyogbHN0YWNrICovKSB7XG4vKiB0aGlzID09IHl5dmFsICovXG5cbnZhciAkMCA9ICQkLmxlbmd0aCAtIDE7XG5zd2l0Y2ggKHl5c3RhdGUpIHtcbmNhc2UgMTpcblxuICAgICAgcmV0dXJuICQkWyQwLTFdO1xuICAgIFxuYnJlYWs7XG5jYXNlIDI6IGNhc2UgMTc6IGNhc2UgNzk6XG4gdGhpcy4kID0gbnVsbCBcbmJyZWFrO1xuY2FzZSAzOiBjYXNlIDEyOiBjYXNlIDE4OiBjYXNlIDIzOiBjYXNlIDI1OiBjYXNlIDI2OiBjYXNlIDI3OiBjYXNlIDQyOiBjYXNlIDU5OiBjYXNlIDYwOiBjYXNlIDYxOiBjYXNlIDYyOiBjYXNlIDY3OlxuIHRoaXMuJCA9ICQkWyQwXSBcbmJyZWFrO1xuY2FzZSA0OiBjYXNlIDgzOlxuIHRoaXMuJCA9IFskJFskMF1dIFxuYnJlYWs7XG5jYXNlIDU6XG4gdGhpcy4kID0gW10uY29uY2F0KCQkWyQwLTFdLCAkJFskMF0pIFxuYnJlYWs7XG5jYXNlIDY6XG4gdGhpcy4kID0ge1xuICAgICAgICBlbGVtZW50OiAkJFskMC0yXSxcbiAgICAgICAgb3B0aW9uczogJCRbJDAtMV0sXG4gICAgICAgIG5vdGVzOiAkJFskMF0ubm90ZXMsXG4gICAgICAgIHRleHQ6ICQkWyQwXS50ZXh0LFxuICAgICAgICBfbDogXyRbJDAtMl0uZmlyc3RfbGluZSxcbiAgICAgICAgX2M6IF8kWyQwLTJdLmZpcnN0X2NvbHVtblxuICAgICAgfVxuICAgIFxuYnJlYWs7XG5jYXNlIDc6XG4gdGhpcy4kID0ge1xuICAgICAgICBlbGVtZW50OiAkJFskMC0xXSxcbiAgICAgICAgb3B0aW9uczogJCRbJDBdLFxuICAgICAgICBfbDogXyRbJDAtMV0uZmlyc3RfbGluZSxcbiAgICAgICAgX2M6IF8kWyQwLTFdLmZpcnN0X2NvbHVtblxuICAgICAgfVxuICAgIFxuYnJlYWs7XG5jYXNlIDg6XG5cbiAgICAgIHRoaXMuJCA9IHtcbiAgICAgICAgZWxlbWVudDogXCJvcHRpb25zXCIsXG4gICAgICAgIHBhcmFtczogJCRbJDBdLFxuICAgICAgICBfbDogXyRbJDAtMV0uZmlyc3RfbGluZSxcbiAgICAgICAgX2M6IF8kWyQwLTFdLmZpcnN0X2NvbHVtblxuICAgICAgfVxuICAgIFxuYnJlYWs7XG5jYXNlIDEzOlxuXG4gICAgICB2YXIgdGV4dCA9IFtdLmNvbmNhdCgkJFskMC0xXS50ZXh0LCAkJFskMF0udGV4dCk7XG4gICAgICB2YXIgbm90ZXMgPSBbXS5jb25jYXQoJCRbJDAtMV0ubm90ZXMsICQkWyQwXS5ub3Rlcyk7XG4gICAgICB2YXIgc2x1cnMgPSBbXS5jb25jYXQoJCRbJDAtMV0uc2x1cnMsICQkWyQwXS5zbHVycylcbiAgICAgIHRoaXMuJCA9IHt0ZXh0OiB0ZXh0LCBub3Rlczogbm90ZXMsIHNsdXJzOiBzbHVyc307XG4gICAgXG5icmVhaztcbmNhc2UgMTQ6XG50aGlzLiQgPSB7dGV4dDogJCRbJDBdLCBub3RlczogW10sIHNsdXJzOiBbXX1cbmJyZWFrO1xuY2FzZSAxNTpcbnRoaXMuJCA9IHtub3RlczogJCRbJDBdLCB0ZXh0OiBbXSwgc2x1cnM6IFtdfVxuYnJlYWs7XG5jYXNlIDE2OlxudGhpcy4kID0ge3NsdXJzOiAkJFskMF0sIG5vdGVzOiBbXSwgdGV4dDogW119XG5icmVhaztcbmNhc2UgMTk6XG4gdGhpcy4kID0gW3tcbiAgICAgICAga2V5OiAkJFskMC0yXSxcbiAgICAgICAgdmFsdWU6ICQkWyQwXSxcbiAgICAgICAgX2w6IF8kWyQwLTJdLmZpcnN0X2xpbmUsXG4gICAgICAgIF9jOiBfJFskMC0yXS5maXJzdF9jb2x1bW5cbiAgICAgIH1dXG4gICAgXG5icmVhaztcbmNhc2UgMjA6XG4gdGhpcy4kID0gW10uY29uY2F0KCQkWyQwLTNdLCBbe1xuICAgICAgICBrZXk6ICQkWyQwLTJdLFxuICAgICAgICB2YWx1ZTogJCRbJDBdLFxuICAgICAgICBfbDogXyRbJDAtMl0uZmlyc3RfbGluZSxcbiAgICAgICAgX2M6IF8kWyQwLTJdLmZpcnN0X2NvbHVtblxuICAgICAgICB9XSlcbiAgICBcbmJyZWFrO1xuY2FzZSAyMTpcbiB0aGlzLiQgPSBbe3RleHQ6ICQkWyQwXSwgX2w6IF8kWyQwXS5maXJzdF9saW5lLCBfYzogXyRbJDBdLmZpcnN0X2NvbHVtbn1dIFxuYnJlYWs7XG5jYXNlIDIyOlxuIHRoaXMuJCA9IFtdLmNvbmNhdCgkJFskMC0yXSwge3RleHQ6ICQkWyQwXSwgX2w6IF8kWyQwXS5maXJzdF9saW5lLCBfYzogXyRbJDBdLmZpcnN0X2NvbHVtbn0pIFxuYnJlYWs7XG5jYXNlIDI0OlxuIHRoaXMuJCA9IFtdLmNvbmNhdCgkJFskMC0xXSwgJCRbJDBdKSAgXG5icmVhaztcbmNhc2UgMjg6XG4gdGhpcy4kID0gW3tcbiAgICAgICAgY29tbWFuZDogXCJiYXJcIixcbiAgICAgICAgdHlwZTogJCRbJDBdLFxuICAgICAgICBfbDogXyRbJDBdLmZpcnN0X2xpbmUsXG4gICAgICAgIF9jOiBfJFskMF0uZmlyc3RfY29sdW1uXG4gICAgICAgIH1dXG4gICAgXG5icmVhaztcbmNhc2UgMjk6XG4gdGhpcy4kID0gW3tcbiAgICAgICAgY29tbWFuZDogXCJvcGVuX2JlYW1cIixcbiAgICAgICAgX2w6IF8kWyQwXS5maXJzdF9saW5lLFxuICAgICAgICBfYzogXyRbJDBdLmZpcnN0X2NvbHVtblxuICAgICAgfV1cbiAgICBcbmJyZWFrO1xuY2FzZSAzMDpcbiB0aGlzLiQgPSBbe1xuICAgICAgICBjb21tYW5kOiBcImNsb3NlX2JlYW1cIixcbiAgICAgICAgX2w6IF8kWyQwXS5maXJzdF9saW5lLFxuICAgICAgICBfYzogXyRbJDBdLmZpcnN0X2NvbHVtblxuICAgICAgfV1cbiAgICBcbmJyZWFrO1xuY2FzZSAzMTpcbiB0aGlzLiQgPSBbe1xuICAgICAgICBjb21tYW5kOiBcInR1cGxldFwiLFxuICAgICAgICBwYXJhbXM6ICQkWyQwXSxcbiAgICAgICAgX2w6IF8kWyQwXS5maXJzdF9saW5lLFxuICAgICAgICBfYzogXyRbJDBdLmZpcnN0X2NvbHVtblxuICAgICAgfV1cbiAgICBcbmJyZWFrO1xuY2FzZSAzMjpcbiB0aGlzLiQgPSBbe1xuICAgICAgICBjb21tYW5kOiBcImFubm90YXRpb25zXCIsXG4gICAgICAgIHBhcmFtczogJCRbJDBdLFxuICAgICAgICBfbDogXyRbJDBdLmZpcnN0X2xpbmUsXG4gICAgICAgIF9jOiBfJFskMF0uZmlyc3RfY29sdW1uXG4gICAgICB9XVxuICAgIFxuYnJlYWs7XG5jYXNlIDMzOlxuIHRoaXMuJCA9IFt7XG4gICAgICAgIGNvbW1hbmQ6IFwiY29tbWFuZFwiLFxuICAgICAgICBwYXJhbXM6ICQkWyQwXSxcbiAgICAgICAgX2w6IF8kWyQwXS5maXJzdF9saW5lLFxuICAgICAgICBfYzogXyRbJDBdLmZpcnN0X2NvbHVtblxuICAgICAgfV1cbiAgICBcbmJyZWFrO1xuY2FzZSAzNDpcblxuICAgIHRoaXMuJCA9IFt7XG4gICAgICAgIGNvbW1hbmQ6IFwicmVzdFwiLFxuICAgICAgICBwYXJhbXM6ICQkWyQwXVxuICAgICAgfV1cbiAgICBcbmJyZWFrO1xuY2FzZSAzNTpcbiB0aGlzLiQgPSAnc2luZ2xlJyBcbmJyZWFrO1xuY2FzZSAzNjpcbiB0aGlzLiQgPSAnZG91YmxlJyBcbmJyZWFrO1xuY2FzZSAzNzpcbiB0aGlzLiQgPSAnZW5kJyBcbmJyZWFrO1xuY2FzZSAzODpcbiB0aGlzLiQgPSAncmVwZWF0LWVuZCcgXG5icmVhaztcbmNhc2UgMzk6XG4gdGhpcy4kID0gJ3JlcGVhdC1iZWdpbicgXG5icmVhaztcbmNhc2UgNDA6XG4gdGhpcy4kID0gJ3JlcGVhdC1ib3RoJyBcbmJyZWFrO1xuY2FzZSA0MTpcblxuICAgICAgXy5leHRlbmQoXy5sYXN0KCQkWyQwLTNdKSwge2RlY29yYXRvcjogJCRbJDAtMl19KVxuICAgICAgXy5lYWNoKCQkWyQwLTNdLCBmdW5jdGlvbihmcmV0KSB7IGZyZXRbJ3N0cmluZyddID0gJCRbJDBdIH0pXG4gICAgICB0aGlzLiQgPSAkJFskMC0zXVxuICAgIFxuYnJlYWs7XG5jYXNlIDQzOiBjYXNlIDg0OlxuIHRoaXMuJCA9IFtdLmNvbmNhdCgkJFskMC0yXSwgJCRbJDBdKSBcbmJyZWFrO1xuY2FzZSA0NDpcbiB0aGlzLiQgPSBbe2Nob3JkOiAkJFskMC0yXSwgZGVjb3JhdG9yOiAkJFskMF19XSBcbmJyZWFrO1xuY2FzZSA0NTpcbiB0aGlzLiQgPSBbe2Nob3JkOiAkJFskMC0yXSwgYXJ0aWN1bGF0aW9uOiAkJFskMC00XSwgZGVjb3JhdG9yOiAkJFskMF19XSBcbmJyZWFrO1xuY2FzZSA0NjpcbiB0aGlzLiQgPSBbe1xuICAgICAgICBmcmV0OiAkJFskMF0sXG4gICAgICAgIF9sOiBfJFskMF0uZmlyc3RfbGluZSxcbiAgICAgICAgX2M6IF8kWyQwXS5maXJzdF9jb2x1bW59XVxuICAgIFxuYnJlYWs7XG5jYXNlIDQ3OlxuIHRoaXMuJCA9IFt7YWJjOiAkJFskMF0sIF9sOiBfJFskMF0uZmlyc3RfbGluZSwgX2M6IF8kWyQwXS5maXJzdF9jb2x1bW59XVxuYnJlYWs7XG5jYXNlIDQ4OlxuIHRoaXMuJCA9IFt7YWJjOiAkJFskMC0zXSwgb2N0YXZlOiAkJFskMC0yXSxcbiAgICAgICAgICAgICBmcmV0OiAkJFskMF0sIF9sOiBfJFskMC0zXS5maXJzdF9saW5lLCBfYzogXyRbJDAtM10uZmlyc3RfY29sdW1ufV1cbmJyZWFrO1xuY2FzZSA0OTpcbiB0aGlzLiQgPSBbXy5leHRlbmQoJCRbJDBdLCB7YXJ0aWN1bGF0aW9uOiAkJFskMC0xXX0pXSBcbmJyZWFrO1xuY2FzZSA1MDpcblxuICAgICAgXy5leHRlbmQoXy5sYXN0KCQkWyQwLTNdKSwge2RlY29yYXRvcjogJCRbJDAtMl19KVxuICAgICAgXy5leHRlbmQoJCRbJDBdLCB7YXJ0aWN1bGF0aW9uOiAkJFskMC0xXX0pXG4gICAgICAkJFskMC0zXS5wdXNoKCQkWyQwXSlcbiAgICAgIHRoaXMuJCA9ICQkWyQwLTNdXG4gICAgXG5icmVhaztcbmNhc2UgNTE6XG4gdGhpcy4kID0ge1xuICAgICAgdGltZTogJCRbJDAtM10sIGRvdDogJCRbJDAtMl0sIGZyZXQ6ICQkWyQwXSxcbiAgICAgIF9sOiBfJFskMC00XS5maXJzdF9saW5lLCBfYzogXyRbJDAtNF0uZmlyc3RfY29sdW1ufVxuYnJlYWs7XG5jYXNlIDUyOlxuIHRoaXMuJCA9IHtmcmV0OiAkJFskMF0sIF9sOiBfJFskMF0uZmlyc3RfbGluZSwgX2M6IF8kWyQwXS5maXJzdF9jb2x1bW59IFxuYnJlYWs7XG5jYXNlIDUzOlxuIHRoaXMuJCA9IHt0aW1lOiAkJFskMC0zXSwgZG90OiAkJFskMC0yXSwgYWJjOiAkJFskMF19XG5icmVhaztcbmNhc2UgNTQ6XG4gdGhpcy4kID0ge3RpbWU6ICQkWyQwLTZdLCBkb3Q6ICQkWyQwLTVdLCBhYmM6ICQkWyQwLTNdLCBvY3RhdmU6ICQkWyQwLTJdLCBmcmV0OiAkJFskMF19XG5icmVhaztcbmNhc2UgNTU6XG4gdGhpcy4kID0ge2FiYzogJCRbJDBdLCBfbDogXyRbJDBdLmZpcnN0X2xpbmUsIF9jOiBfJFskMF0uZmlyc3RfY29sdW1ufSBcbmJyZWFrO1xuY2FzZSA1NjpcbiB0aGlzLiQgPSB7YWJjOiAkJFskMC0zXSwgb2N0YXZlOiAkJFskMC0yXSxcbiAgICAgICAgICAgIGZyZXQ6ICQkWyQwXSwgX2w6IF8kWyQwLTNdLmZpcnN0X2xpbmUsIF9jOiBfJFskMC0zXS5maXJzdF9jb2x1bW59IFxuYnJlYWs7XG5jYXNlIDU3OlxuIHRoaXMuJCA9IHt0aW1lOiAkJFskMC0xXSwgZG90OiAkJFskMF19IFxuYnJlYWs7XG5jYXNlIDU4OlxuIHRoaXMuJCA9ICQkWyQwLTFdICsgJCRbJDBdIFxuYnJlYWs7XG5jYXNlIDYzOlxuIHRoaXMuJCA9IGZhbHNlIFxuYnJlYWs7XG5jYXNlIDY0OlxuIHRoaXMuJCA9IHRydWUgXG5icmVhaztcbmNhc2UgNjU6XG4gdGhpcy4kID0gJycgXG5icmVhaztcbmNhc2UgNjY6IGNhc2UgNjk6XG4gdGhpcy4kID0gJ3MnIFxuYnJlYWs7XG5jYXNlIDY4OlxuIHRoaXMuJCA9ICctJyBcbmJyZWFrO1xuY2FzZSA3MDpcbiB0aGlzLiQgPSAndCcgXG5icmVhaztcbmNhc2UgNzE6XG4gdGhpcy4kID0gJ1QnIFxuYnJlYWs7XG5jYXNlIDcyOlxuIHRoaXMuJCA9ICdiJyBcbmJyZWFrO1xuY2FzZSA3MzpcbiB0aGlzLiQgPSAnaCcgXG5icmVhaztcbmNhc2UgNzQ6XG4gdGhpcy4kID0gJ3AnIFxuYnJlYWs7XG5jYXNlIDc1OlxuIHRoaXMuJCA9ICd2JyBcbmJyZWFrO1xuY2FzZSA3NjpcbiB0aGlzLiQgPSAnVicgXG5icmVhaztcbmNhc2UgNzc6XG4gdGhpcy4kID0gJ3UnIFxuYnJlYWs7XG5jYXNlIDc4OlxuIHRoaXMuJCA9ICdkJyBcbmJyZWFrO1xuY2FzZSA4MDpcbiB0aGlzLiQgPSB7dHVwbGV0OiAkJFskMC0xXX0gXG5icmVhaztcbmNhc2UgODE6XG4gdGhpcy4kID0ge3R1cGxldDogJCRbJDAtM10sIG5vdGVzOiAkJFskMC0xXX0gXG5icmVhaztcbmNhc2UgODI6IGNhc2UgODU6XG4gdGhpcy4kID0gJCRbJDAtMV0gXG5icmVhaztcbmNhc2UgODY6XG4gdGhpcy4kID0ge3Bvc2l0aW9uOiAwfSBcbmJyZWFrO1xuY2FzZSA4NzpcbiB0aGlzLiQgPSB7cG9zaXRpb246ICQkWyQwLTFdfSBcbmJyZWFrO1xuY2FzZSA4ODpcbiB0aGlzLiQgPSB7cG9zaXRpb246ICQkWyQwLTFdICogLTF9IFxuYnJlYWs7XG5jYXNlIDg5OlxuIHRoaXMuJCA9IHtrZXk6ICQkWyQwLTJdLCBhY2NpZGVudGFsOiAkJFskMC0xXSwgYWNjaWRlbnRhbF90eXBlOiAkJFskMF19IFxuYnJlYWs7XG5jYXNlIDkwOlxuIHRoaXMuJCA9IFwiI1wiIFxuYnJlYWs7XG5jYXNlIDkxOlxuIHRoaXMuJCA9IFwiIyNcIiBcbmJyZWFrO1xuY2FzZSA5MjpcbiB0aGlzLiQgPSBcImJcIiBcbmJyZWFrO1xuY2FzZSA5MzpcbiB0aGlzLiQgPSBcImJiXCIgXG5icmVhaztcbmNhc2UgOTQ6XG4gdGhpcy4kID0gXCJuXCIgXG5icmVhaztcbmNhc2UgOTY6XG4gdGhpcy4kID0gbnVsbDsgXG5icmVhaztcbmNhc2UgOTc6XG4gdGhpcy4kID0gXCJjXCIgXG5icmVhaztcbn1cbn0sXG50YWJsZTogW3szOjEsNDoyLDU6WzIsMl0sNjozLDc6NCw4OjUsMTE6JFYwLDEzOiRWMSwxNDokVjIsMTU6JFYzfSx7MTpbM119LHs1OlsxLDEwXX0sezU6WzIsM10sNzoxMSw4OjUsMTE6JFYwLDEzOiRWMSwxNDokVjIsMTU6JFYzfSxvKCRWNCxbMiw0XSksbygkVjUsJFY2LHs5OjEyLDEyOjEzLDIyOiRWN30pLHsxMjoxNSwyMjokVjd9LG8oJFY4LFsyLDldKSxvKCRWOCxbMiwxMF0pLG8oJFY4LFsyLDExXSksezE6WzIsMV19LG8oJFY0LFsyLDVdKSxvKCRWNCxbMiw3XSx7MTA6MTYsMTY6MTcsMTc6JFY5LDE5OiRWYSwyMTokVmJ9KSxvKCRWNSxbMiwxOF0sezIyOiRWY30pLHsyMzpbMSwyMl19LG8oJFY0LFsyLDhdLHsyMjokVmN9KSxvKCRWNCxbMiw2XSx7MTY6MjMsMTc6JFY5LDE5OiRWYSwyMTokVmJ9KSxvKCRWNSxbMiwxMl0pLHsxODoyNCwyNDpbMSwyNV19LHsyMDoyNiwyMzokVmQsMjY6MjcsMjc6MjgsMjg6MjksMjk6MzAsMzA6MzEsMzE6JFZlLDMyOiRWZiwzMzozNCwzNDozNSwzNTozNiwzNjozNywzNzokVmcsMzg6JFZoLDM5OjM4LDQ1OiRWaSw0Nzo0MCw0ODokVmosNDk6NDksNTc6JFZrLDYxOiRWbCw2MjokVm0sNjM6JFZuLDY0OiRWbyw2NTokVnAsNjY6JFZxLDcwOiRWciw3MTokVnMsNzM6JFZ0LDc1OiRWdSw3NjokVnZ9LG8oJFY1LCRWNix7MTI6MTMsOTo1OCwyMjokVjd9KSx7MjM6WzEsNTldfSx7MjI6WzEsNjBdfSxvKCRWNSxbMiwxM10pLG8oJFY1LFsyLDE0XSx7MjU6WzEsNjFdfSksbygkVncsWzIsMjFdKSxvKCRWNSxbMiwxNV0sezI3OjI4LDI4OjI5LDI5OjMwLDMwOjMxLDMzOjM0LDM0OjM1LDM1OjM2LDM2OjM3LDM5OjM4LDQ3OjQwLDQ5OjQ5LDI2OjYyLDIzOiRWZCwzMTokVmUsMzI6JFZmLDM3OiRWZywzODokVmgsNDU6JFZpLDQ4OiRWaiw1NzokVmssNjE6JFZsLDYyOiRWbSw2MzokVm4sNjQ6JFZvLDY1OiRWcCw2NjokVnEsNzA6JFZyLDcxOiRWcyw3MzokVnQsNzU6JFZ1LDc2OiRWdn0pLG8oJFZ4LFsyLDIzXSksbygkVngsWzIsMjVdKSxvKCRWeCxbMiwyNl0pLG8oJFZ4LFsyLDI3XSksbygkVngsWzIsMjhdKSxvKCRWeCxbMiwyOV0pLG8oJFZ4LFsyLDMwXSksbygkVngsWzIsMzFdKSxvKCRWeCxbMiwzMl0pLG8oJFZ4LFsyLDMzXSksbygkVngsWzIsMzRdKSxvKFs0MSw1Nyw2MSw2Miw2Myw2NCw2NSw2Nl0sJFZ5LHs0MDo2Myw1OTokVnosNjc6JFZBLDY4OiRWQiw2OTokVkN9KSx7Mjc6NjksMzk6MzgsNDM6NjgsNDc6NzAsNDg6JFZqLDQ5OjQ5LDU3OiRWayw2MTokVmwsNjI6JFZtLDYzOiRWbiw2NDokVm8sNjU6JFZwLDY2OiRWcSw3NjokVnZ9LHszODokVkQsNDU6WzEsNzFdLDQ4OiRWRSw0OTo3NSw1MTo3Miw3NjokVnZ9LHs0ODokVkYsNTI6NzYsNTQ6NzcsNTY6JFZHLDU3OiRWSCw1ODokVkl9LG8oJFZ4LFsyLDM1XSksezM3OlsxLDgyXSwzODpbMSw4M119LHs0ODpbMSw4NF19LHsyMjpbMSw4Nl0sNzI6ODV9LHs3NDpbMSw4N119LHs0ODpbMSw4OV0sNjE6WzEsOTBdLDc1OlsxLDg4XX0sbygkVkosWzIsNDZdKSxvKCRWSixbMiw0N10sezQ4OlsxLDkxXX0pLG8oJFZLLFsyLDY4XSksbygkVkssWzIsNjldKSxvKCRWSyxbMiw3MF0pLG8oJFZLLFsyLDcxXSksbygkVkssWzIsNzJdKSxvKCRWSyxbMiw3M10pLG8oJFZLLFsyLDc0XSksbygkVkwsWzIsOTVdLHs3Nzo5Miw3NTpbMSw5M10sNzk6WzEsOTRdLDgwOlsxLDk1XX0pLG8oJFY1LFsyLDE2XSksezIyOlsxLDk2XX0sbygkVjgsWzIsMTldKSx7MjQ6WzEsOTddfSxvKCRWeCxbMiwyNF0pLHs0MTpbMSw5OF0sNDc6OTksNTc6JFZrLDYxOiRWbCw2MjokVm0sNjM6JFZuLDY0OiRWbyw2NTokVnAsNjY6JFZxfSxvKCRWTSxbMiw3NV0pLG8oJFZNLFsyLDc2XSksbygkVk0sWzIsNzddKSxvKCRWTSxbMiw3OF0pLHs0NDokVk4sNDY6WzEsMTAwXX0sbygkVk8sWzIsNDJdKSx7Mzg6JFZELDQ4OiRWRSw0OTo3NSw1MTo3Miw3NjokVnZ9LHsyNzo2OSwzOTozOCw0MzoxMDIsNDc6NzAsNDg6JFZqLDQ5OjQ5LDU3OiRWayw2MTokVmwsNjI6JFZtLDYzOiRWbiw2NDokVm8sNjU6JFZwLDY2OiRWcSw3NjokVnZ9LG8oJFZKLFsyLDQ5XSksezQ4OiRWRiw1MjoxMDMsNTQ6NzcsNTY6JFZHLDU3OiRWSCw1ODokVkl9LG8oJFZKLFsyLDUyXSksbygkVkosWzIsNTVdLHs0ODpbMSwxMDRdfSksbygkVngsJFZQLHs1MzoxMDUsNTk6JFZRfSksbygkVlIsWzIsNjVdLHs1NToxMDcsNjA6WzEsMTA4XX0pLG8oJFZTLFsyLDU5XSksbygkVlMsWzIsNjBdKSxvKCRWUyxbMiw2MV0pLG8oJFZTLFsyLDYyXSksezIzOlsxLDExMF0sMzc6WzEsMTA5XSwzODpbMSwxMTFdfSx7Mzc6WzEsMTEyXSwzODpbMSwxMTNdfSx7MjU6WzEsMTE1XSw3MDpbMSwxMTRdfSx7MjU6WzEsMTE3XSw3MTpbMSwxMTZdfSxvKCRWVCxbMiw4M10pLHs3MzpbMSwxMThdfSxvKCRWeCxbMiw4Nl0pLHs3NTpbMSwxMTldfSx7NDg6WzEsMTIwXX0sezUwOlsxLDEyMV19LG8oJFZVLFsyLDk2XSx7Nzg6MTIyLDgxOlsxLDEyM119KSxvKCRWTCxbMiw5MF0sezc1OlsxLDEyNF19KSxvKCRWTCxbMiw5Ml0sezc5OlsxLDEyNV19KSxvKCRWTCxbMiw5NF0pLG8oJFY4LFsyLDIwXSksbygkVncsWzIsMjJdKSx7NDI6MTI2LDQ4OlsxLDEyN119LHszODokVkQsNDg6JFZFLDQ5Ojc1LDUxOjEyOCw3NjokVnZ9LG8oJFZ4LCRWeSx7NDA6MTI5LDU5OiRWeiw2NzokVkEsNjg6JFZCLDY5OiRWQ30pLHsyNzoxMzAsMzk6MzgsNDc6NzAsNDg6JFZqLDQ5OjQ5LDU3OiRWayw2MTokVmwsNjI6JFZtLDYzOiRWbiw2NDokVm8sNjU6JFZwLDY2OiRWcSw3NjokVnZ9LHs0NDokVk4sNDY6WzEsMTMxXX0sezM4OiRWUCw1MzoxMzIsNTk6JFZRfSx7NTA6WzEsMTMzXX0sbygkVngsWzIsNTddKSxvKCRWeCxbMiw2NF0pLG8oJFZSLFsyLDU4XSksbygkVlIsWzIsNjZdKSxvKCRWeCxbMiwzNl0pLG8oJFZ4LFsyLDM3XSksbygkVngsWzIsMzldKSxvKCRWeCxbMiwzOF0pLG8oJFZ4LFsyLDQwXSksbygkVngsWzIsODBdKSx7NDg6WzEsMTM0XX0sbygkVngsWzIsODJdKSx7MjI6WzEsMTM1XX0sbygkVngsWzIsODVdKSxvKCRWeCxbMiw4N10pLHs3NTpbMSwxMzZdfSx7NDg6WzEsMTM3XX0sbygkVlUsWzIsODldKSxvKCRWVSxbMiw5N10pLG8oJFZMLFsyLDkxXSksbygkVkwsWzIsOTNdKSxvKCRWVixbMiw0MV0pLG8oJFZWLFsyLDY3XSksbygkVkosWzIsNTBdKSxvKCRWeCxbMiw0NF0pLG8oJFZPLFsyLDQzXSksbygkVngsJFZ5LHs0MDoxMzgsNTk6JFZ6LDY3OiRWQSw2ODokVkIsNjk6JFZDfSksezM4OlsxLDEzOV19LHs0ODpbMSwxNDBdfSx7NzA6WzEsMTQxXX0sbygkVlQsWzIsODRdKSxvKCRWeCxbMiw4OF0pLG8oJFZKLFsyLDQ4XSksbygkVngsWzIsNDVdKSx7NDg6WzEsMTQyXSw0OToxNDMsNzY6JFZ2fSxvKCRWSixbMiw1Nl0pLG8oJFZ4LFsyLDgxXSksbygkVkosWzIsNTFdKSxvKCRWSixbMiw1M10sezQ4OlsxLDE0NF19KSx7NTA6WzEsMTQ1XX0sezQ4OlsxLDE0Nl19LG8oJFZKLFsyLDU0XSldLFxuZGVmYXVsdEFjdGlvbnM6IHsxMDpbMiwxXX0sXG5wYXJzZUVycm9yOiBmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgIGlmIChoYXNoLnJlY292ZXJhYmxlKSB7XG4gICAgICAgIHRoaXMudHJhY2Uoc3RyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBmdW5jdGlvbiBfcGFyc2VFcnJvciAobXNnLCBoYXNoKSB7XG4gICAgICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtc2c7XG4gICAgICAgICAgICB0aGlzLmhhc2ggPSBoYXNoO1xuICAgICAgICB9XG4gICAgICAgIF9wYXJzZUVycm9yLnByb3RvdHlwZSA9IG5ldyBFcnJvcigpO1xuXG4gICAgICAgIHRocm93IG5ldyBfcGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgIH1cbn0sXG5wYXJzZTogZnVuY3Rpb24gcGFyc2UoaW5wdXQpIHtcbiAgICB2YXIgc2VsZiA9IHRoaXMsIHN0YWNrID0gWzBdLCB0c3RhY2sgPSBbXSwgdnN0YWNrID0gW251bGxdLCBsc3RhY2sgPSBbXSwgdGFibGUgPSB0aGlzLnRhYmxlLCB5eXRleHQgPSAnJywgeXlsaW5lbm8gPSAwLCB5eWxlbmcgPSAwLCByZWNvdmVyaW5nID0gMCwgVEVSUk9SID0gMiwgRU9GID0gMTtcbiAgICB2YXIgYXJncyA9IGxzdGFjay5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGxleGVyID0gT2JqZWN0LmNyZWF0ZSh0aGlzLmxleGVyKTtcbiAgICB2YXIgc2hhcmVkU3RhdGUgPSB7IHl5OiB7fSB9O1xuICAgIGZvciAodmFyIGsgaW4gdGhpcy55eSkge1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHRoaXMueXksIGspKSB7XG4gICAgICAgICAgICBzaGFyZWRTdGF0ZS55eVtrXSA9IHRoaXMueXlba107XG4gICAgICAgIH1cbiAgICB9XG4gICAgbGV4ZXIuc2V0SW5wdXQoaW5wdXQsIHNoYXJlZFN0YXRlLnl5KTtcbiAgICBzaGFyZWRTdGF0ZS55eS5sZXhlciA9IGxleGVyO1xuICAgIHNoYXJlZFN0YXRlLnl5LnBhcnNlciA9IHRoaXM7XG4gICAgaWYgKHR5cGVvZiBsZXhlci55eWxsb2MgPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgbGV4ZXIueXlsbG9jID0ge307XG4gICAgfVxuICAgIHZhciB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICBsc3RhY2sucHVzaCh5eWxvYyk7XG4gICAgdmFyIHJhbmdlcyA9IGxleGVyLm9wdGlvbnMgJiYgbGV4ZXIub3B0aW9ucy5yYW5nZXM7XG4gICAgaWYgKHR5cGVvZiBzaGFyZWRTdGF0ZS55eS5wYXJzZUVycm9yID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIHRoaXMucGFyc2VFcnJvciA9IHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3I7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpLnBhcnNlRXJyb3I7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvcFN0YWNrKG4pIHtcbiAgICAgICAgc3RhY2subGVuZ3RoID0gc3RhY2subGVuZ3RoIC0gMiAqIG47XG4gICAgICAgIHZzdGFjay5sZW5ndGggPSB2c3RhY2subGVuZ3RoIC0gbjtcbiAgICAgICAgbHN0YWNrLmxlbmd0aCA9IGxzdGFjay5sZW5ndGggLSBuO1xuICAgIH1cbiAgICBfdG9rZW5fc3RhY2s6XG4gICAgICAgIHZhciBsZXggPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgdG9rZW47XG4gICAgICAgICAgICB0b2tlbiA9IGxleGVyLmxleCgpIHx8IEVPRjtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW4gIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICAgICAgdG9rZW4gPSBzZWxmLnN5bWJvbHNfW3Rva2VuXSB8fCB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgfTtcbiAgICB2YXIgc3ltYm9sLCBwcmVFcnJvclN5bWJvbCwgc3RhdGUsIGFjdGlvbiwgYSwgciwgeXl2YWwgPSB7fSwgcCwgbGVuLCBuZXdTdGF0ZSwgZXhwZWN0ZWQ7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgc3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgICAgaWYgKHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdKSB7XG4gICAgICAgICAgICBhY3Rpb24gPSB0aGlzLmRlZmF1bHRBY3Rpb25zW3N0YXRlXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGlmIChzeW1ib2wgPT09IG51bGwgfHwgdHlwZW9mIHN5bWJvbCA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHN5bWJvbCA9IGxleCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYWN0aW9uID0gdGFibGVbc3RhdGVdICYmIHRhYmxlW3N0YXRlXVtzeW1ib2xdO1xuICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgYWN0aW9uID09PSAndW5kZWZpbmVkJyB8fCAhYWN0aW9uLmxlbmd0aCB8fCAhYWN0aW9uWzBdKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyclN0ciA9ICcnO1xuICAgICAgICAgICAgICAgIGV4cGVjdGVkID0gW107XG4gICAgICAgICAgICAgICAgZm9yIChwIGluIHRhYmxlW3N0YXRlXSkge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy50ZXJtaW5hbHNfW3BdICYmIHAgPiBURVJST1IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkLnB1c2goJ1xcJycgKyB0aGlzLnRlcm1pbmFsc19bcF0gKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGxleGVyLnNob3dQb3NpdGlvbikge1xuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3Igb24gbGluZSAnICsgKHl5bGluZW5vICsgMSkgKyAnOlxcbicgKyBsZXhlci5zaG93UG9zaXRpb24oKSArICdcXG5FeHBlY3RpbmcgJyArIGV4cGVjdGVkLmpvaW4oJywgJykgKyAnLCBnb3QgXFwnJyArICh0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wpICsgJ1xcJyc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZXJyU3RyID0gJ1BhcnNlIGVycm9yIG9uIGxpbmUgJyArICh5eWxpbmVubyArIDEpICsgJzogVW5leHBlY3RlZCAnICsgKHN5bWJvbCA9PSBFT0YgPyAnZW5kIG9mIGlucHV0JyA6ICdcXCcnICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyAnXFwnJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucGFyc2VFcnJvcihlcnJTdHIsIHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogbGV4ZXIubWF0Y2gsXG4gICAgICAgICAgICAgICAgICAgIHRva2VuOiB0aGlzLnRlcm1pbmFsc19bc3ltYm9sXSB8fCBzeW1ib2wsXG4gICAgICAgICAgICAgICAgICAgIGxpbmU6IGxleGVyLnl5bGluZW5vLFxuICAgICAgICAgICAgICAgICAgICBsb2M6IHl5bG9jLFxuICAgICAgICAgICAgICAgICAgICBleHBlY3RlZDogZXhwZWN0ZWRcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgaWYgKGFjdGlvblswXSBpbnN0YW5jZW9mIEFycmF5ICYmIGFjdGlvbi5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BhcnNlIEVycm9yOiBtdWx0aXBsZSBhY3Rpb25zIHBvc3NpYmxlIGF0IHN0YXRlOiAnICsgc3RhdGUgKyAnLCB0b2tlbjogJyArIHN5bWJvbCk7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChhY3Rpb25bMF0pIHtcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgc3RhY2sucHVzaChzeW1ib2wpO1xuICAgICAgICAgICAgdnN0YWNrLnB1c2gobGV4ZXIueXl0ZXh0KTtcbiAgICAgICAgICAgIGxzdGFjay5wdXNoKGxleGVyLnl5bGxvYyk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKGFjdGlvblsxXSk7XG4gICAgICAgICAgICBzeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgaWYgKCFwcmVFcnJvclN5bWJvbCkge1xuICAgICAgICAgICAgICAgIHl5bGVuZyA9IGxleGVyLnl5bGVuZztcbiAgICAgICAgICAgICAgICB5eXRleHQgPSBsZXhlci55eXRleHQ7XG4gICAgICAgICAgICAgICAgeXlsaW5lbm8gPSBsZXhlci55eWxpbmVubztcbiAgICAgICAgICAgICAgICB5eWxvYyA9IGxleGVyLnl5bGxvYztcbiAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcmluZyA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcmluZy0tO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gcHJlRXJyb3JTeW1ib2w7XG4gICAgICAgICAgICAgICAgcHJlRXJyb3JTeW1ib2wgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMjpcbiAgICAgICAgICAgIGxlbiA9IHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMV07XG4gICAgICAgICAgICB5eXZhbC4kID0gdnN0YWNrW3ZzdGFjay5sZW5ndGggLSBsZW5dO1xuICAgICAgICAgICAgeXl2YWwuXyQgPSB7XG4gICAgICAgICAgICAgICAgZmlyc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5maXJzdF9saW5lLFxuICAgICAgICAgICAgICAgIGxhc3RfbGluZTogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2xpbmUsXG4gICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICBsYXN0X2NvbHVtbjogbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5sYXN0X2NvbHVtblxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChyYW5nZXMpIHtcbiAgICAgICAgICAgICAgICB5eXZhbC5fJC5yYW5nZSA9IFtcbiAgICAgICAgICAgICAgICAgICAgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAobGVuIHx8IDEpXS5yYW5nZVswXSxcbiAgICAgICAgICAgICAgICAgICAgbHN0YWNrW2xzdGFjay5sZW5ndGggLSAxXS5yYW5nZVsxXVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByID0gdGhpcy5wZXJmb3JtQWN0aW9uLmFwcGx5KHl5dmFsLCBbXG4gICAgICAgICAgICAgICAgeXl0ZXh0LFxuICAgICAgICAgICAgICAgIHl5bGVuZyxcbiAgICAgICAgICAgICAgICB5eWxpbmVubyxcbiAgICAgICAgICAgICAgICBzaGFyZWRTdGF0ZS55eSxcbiAgICAgICAgICAgICAgICBhY3Rpb25bMV0sXG4gICAgICAgICAgICAgICAgdnN0YWNrLFxuICAgICAgICAgICAgICAgIGxzdGFja1xuICAgICAgICAgICAgXS5jb25jYXQoYXJncykpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiByICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgICAgIHJldHVybiByO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGxlbikge1xuICAgICAgICAgICAgICAgIHN0YWNrID0gc3RhY2suc2xpY2UoMCwgLTEgKiBsZW4gKiAyKTtcbiAgICAgICAgICAgICAgICB2c3RhY2sgPSB2c3RhY2suc2xpY2UoMCwgLTEgKiBsZW4pO1xuICAgICAgICAgICAgICAgIGxzdGFjayA9IGxzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdGFjay5wdXNoKHRoaXMucHJvZHVjdGlvbnNfW2FjdGlvblsxXV1bMF0pO1xuICAgICAgICAgICAgdnN0YWNrLnB1c2goeXl2YWwuJCk7XG4gICAgICAgICAgICBsc3RhY2sucHVzaCh5eXZhbC5fJCk7XG4gICAgICAgICAgICBuZXdTdGF0ZSA9IHRhYmxlW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDJdXVtzdGFja1tzdGFjay5sZW5ndGggLSAxXV07XG4gICAgICAgICAgICBzdGFjay5wdXNoKG5ld1N0YXRlKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDM6XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn19O1xuXG4gIHZhciBfID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG4vKiBnZW5lcmF0ZWQgYnkgamlzb24tbGV4IDAuMy40ICovXG52YXIgbGV4ZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBsZXhlciA9ICh7XG5cbkVPRjoxLFxuXG5wYXJzZUVycm9yOmZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgICAgIGlmICh0aGlzLnl5LnBhcnNlcikge1xuICAgICAgICAgICAgdGhpcy55eS5wYXJzZXIucGFyc2VFcnJvcihzdHIsIGhhc2gpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHN0cik7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXNldHMgdGhlIGxleGVyLCBzZXRzIG5ldyBpbnB1dFxuc2V0SW5wdXQ6ZnVuY3Rpb24gKGlucHV0LCB5eSkge1xuICAgICAgICB0aGlzLnl5ID0geXkgfHwgdGhpcy55eSB8fCB7fTtcbiAgICAgICAgdGhpcy5faW5wdXQgPSBpbnB1dDtcbiAgICAgICAgdGhpcy5fbW9yZSA9IHRoaXMuX2JhY2t0cmFjayA9IHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB0aGlzLnl5bGluZW5vID0gdGhpcy55eWxlbmcgPSAwO1xuICAgICAgICB0aGlzLnl5dGV4dCA9IHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjayA9IFsnSU5JVElBTCddO1xuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IDAsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IDEsXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogMFxuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbMCwwXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9mZnNldCA9IDA7XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIGNvbnN1bWVzIGFuZCByZXR1cm5zIG9uZSBjaGFyIGZyb20gdGhlIGlucHV0XG5pbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBjaCA9IHRoaXMuX2lucHV0WzBdO1xuICAgICAgICB0aGlzLnl5dGV4dCArPSBjaDtcbiAgICAgICAgdGhpcy55eWxlbmcrKztcbiAgICAgICAgdGhpcy5vZmZzZXQrKztcbiAgICAgICAgdGhpcy5tYXRjaCArPSBjaDtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IGNoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubysrO1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9saW5lKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbisrO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZVsxXSsrO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5faW5wdXQgPSB0aGlzLl9pbnB1dC5zbGljZSgxKTtcbiAgICAgICAgcmV0dXJuIGNoO1xuICAgIH0sXG5cbi8vIHVuc2hpZnRzIG9uZSBjaGFyIChvciBhIHN0cmluZykgaW50byB0aGUgaW5wdXRcbnVucHV0OmZ1bmN0aW9uIChjaCkge1xuICAgICAgICB2YXIgbGVuID0gY2gubGVuZ3RoO1xuICAgICAgICB2YXIgbGluZXMgPSBjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gY2ggKyB0aGlzLl9pbnB1dDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLnl5dGV4dC5zdWJzdHIoMCwgdGhpcy55eXRleHQubGVuZ3RoIC0gbGVuKTtcbiAgICAgICAgLy90aGlzLnl5bGVuZyAtPSBsZW47XG4gICAgICAgIHRoaXMub2Zmc2V0IC09IGxlbjtcbiAgICAgICAgdmFyIG9sZExpbmVzID0gdGhpcy5tYXRjaC5zcGxpdCgvKD86XFxyXFxuP3xcXG4pL2cpO1xuICAgICAgICB0aGlzLm1hdGNoID0gdGhpcy5tYXRjaC5zdWJzdHIoMCwgdGhpcy5tYXRjaC5sZW5ndGggLSAxKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkID0gdGhpcy5tYXRjaGVkLnN1YnN0cigwLCB0aGlzLm1hdGNoZWQubGVuZ3RoIC0gMSk7XG5cbiAgICAgICAgaWYgKGxpbmVzLmxlbmd0aCAtIDEpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8gLT0gbGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgciA9IHRoaXMueXlsbG9jLnJhbmdlO1xuXG4gICAgICAgIHRoaXMueXlsbG9jID0ge1xuICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/XG4gICAgICAgICAgICAgICAgKGxpbmVzLmxlbmd0aCA9PT0gb2xkTGluZXMubGVuZ3RoID8gdGhpcy55eWxsb2MuZmlyc3RfY29sdW1uIDogMClcbiAgICAgICAgICAgICAgICAgKyBvbGRMaW5lc1tvbGRMaW5lcy5sZW5ndGggLSBsaW5lcy5sZW5ndGhdLmxlbmd0aCAtIGxpbmVzWzBdLmxlbmd0aCA6XG4gICAgICAgICAgICAgIHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiAtIGxlblxuICAgICAgICB9O1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFtyWzBdLCByWzBdICsgdGhpcy55eWxlbmcgLSBsZW5dO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgY2FjaGVzIG1hdGNoZWQgdGV4dCBhbmQgYXBwZW5kcyBpdCBvbiBuZXh0IGFjdGlvblxubW9yZTpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0cnVlO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBXaGVuIGNhbGxlZCBmcm9tIGFjdGlvbiwgc2lnbmFscyB0aGUgbGV4ZXIgdGhhdCB0aGlzIHJ1bGUgZmFpbHMgdG8gbWF0Y2ggdGhlIGlucHV0LCBzbyB0aGUgbmV4dCBtYXRjaGluZyBydWxlIChyZWdleCkgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxucmVqZWN0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBZb3UgY2FuIG9ubHkgaW52b2tlIHJlamVjdCgpIGluIHRoZSBsZXhlciB3aGVuIHRoZSBsZXhlciBpcyBvZiB0aGUgYmFja3RyYWNraW5nIHBlcnN1YXNpb24gKG9wdGlvbnMuYmFja3RyYWNrX2xleGVyID0gdHJ1ZSkuXFxuJyArIHRoaXMuc2hvd1Bvc2l0aW9uKCksIHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBcIlwiLFxuICAgICAgICAgICAgICAgIHRva2VuOiBudWxsLFxuICAgICAgICAgICAgICAgIGxpbmU6IHRoaXMueXlsaW5lbm9cbiAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gcmV0YWluIGZpcnN0IG4gY2hhcmFjdGVycyBvZiB0aGUgbWF0Y2hcbmxlc3M6ZnVuY3Rpb24gKG4pIHtcbiAgICAgICAgdGhpcy51bnB1dCh0aGlzLm1hdGNoLnNsaWNlKG4pKTtcbiAgICB9LFxuXG4vLyBkaXNwbGF5cyBhbHJlYWR5IG1hdGNoZWQgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG5wYXN0SW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGFzdCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIHRoaXMubWF0Y2gubGVuZ3RoKTtcbiAgICAgICAgcmV0dXJuIChwYXN0Lmxlbmd0aCA+IDIwID8gJy4uLic6JycpICsgcGFzdC5zdWJzdHIoLTIwKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgdXBjb21pbmcgaW5wdXQsIGkuZS4gZm9yIGVycm9yIG1lc3NhZ2VzXG51cGNvbWluZ0lucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIG5leHQgPSB0aGlzLm1hdGNoO1xuICAgICAgICBpZiAobmV4dC5sZW5ndGggPCAyMCkge1xuICAgICAgICAgICAgbmV4dCArPSB0aGlzLl9pbnB1dC5zdWJzdHIoMCwgMjAtbmV4dC5sZW5ndGgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAobmV4dC5zdWJzdHIoMCwyMCkgKyAobmV4dC5sZW5ndGggPiAyMCA/ICcuLi4nIDogJycpKS5yZXBsYWNlKC9cXG4vZywgXCJcIik7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgdGhlIGNoYXJhY3RlciBwb3NpdGlvbiB3aGVyZSB0aGUgbGV4aW5nIGVycm9yIG9jY3VycmVkLCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xuc2hvd1Bvc2l0aW9uOmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHByZSA9IHRoaXMucGFzdElucHV0KCk7XG4gICAgICAgIHZhciBjID0gbmV3IEFycmF5KHByZS5sZW5ndGggKyAxKS5qb2luKFwiLVwiKTtcbiAgICAgICAgcmV0dXJuIHByZSArIHRoaXMudXBjb21pbmdJbnB1dCgpICsgXCJcXG5cIiArIGMgKyBcIl5cIjtcbiAgICB9LFxuXG4vLyB0ZXN0IHRoZSBsZXhlZCB0b2tlbjogcmV0dXJuIEZBTFNFIHdoZW4gbm90IGEgbWF0Y2gsIG90aGVyd2lzZSByZXR1cm4gdG9rZW5cbnRlc3RfbWF0Y2g6ZnVuY3Rpb24gKG1hdGNoLCBpbmRleGVkX3J1bGUpIHtcbiAgICAgICAgdmFyIHRva2VuLFxuICAgICAgICAgICAgbGluZXMsXG4gICAgICAgICAgICBiYWNrdXA7XG5cbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgIC8vIHNhdmUgY29udGV4dFxuICAgICAgICAgICAgYmFja3VwID0ge1xuICAgICAgICAgICAgICAgIHl5bGluZW5vOiB0aGlzLnl5bGluZW5vLFxuICAgICAgICAgICAgICAgIHl5bGxvYzoge1xuICAgICAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5maXJzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMubGFzdF9saW5lLFxuICAgICAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbixcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICB5eXRleHQ6IHRoaXMueXl0ZXh0LFxuICAgICAgICAgICAgICAgIG1hdGNoOiB0aGlzLm1hdGNoLFxuICAgICAgICAgICAgICAgIG1hdGNoZXM6IHRoaXMubWF0Y2hlcyxcbiAgICAgICAgICAgICAgICBtYXRjaGVkOiB0aGlzLm1hdGNoZWQsXG4gICAgICAgICAgICAgICAgeXlsZW5nOiB0aGlzLnl5bGVuZyxcbiAgICAgICAgICAgICAgICBvZmZzZXQ6IHRoaXMub2Zmc2V0LFxuICAgICAgICAgICAgICAgIF9tb3JlOiB0aGlzLl9tb3JlLFxuICAgICAgICAgICAgICAgIF9pbnB1dDogdGhpcy5faW5wdXQsXG4gICAgICAgICAgICAgICAgeXk6IHRoaXMueXksXG4gICAgICAgICAgICAgICAgY29uZGl0aW9uU3RhY2s6IHRoaXMuY29uZGl0aW9uU3RhY2suc2xpY2UoMCksXG4gICAgICAgICAgICAgICAgZG9uZTogdGhpcy5kb25lXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgICAgICBiYWNrdXAueXlsbG9jLnJhbmdlID0gdGhpcy55eWxsb2MucmFuZ2Uuc2xpY2UoMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBsaW5lcyA9IG1hdGNoWzBdLm1hdGNoKC8oPzpcXHJcXG4/fFxcbikuKi9nKTtcbiAgICAgICAgaWYgKGxpbmVzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vICs9IGxpbmVzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmxhc3RfbGluZSxcbiAgICAgICAgICAgIGxhc3RfbGluZTogdGhpcy55eWxpbmVubyArIDEsXG4gICAgICAgICAgICBmaXJzdF9jb2x1bW46IHRoaXMueXlsbG9jLmxhc3RfY29sdW1uLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IGxpbmVzID9cbiAgICAgICAgICAgICAgICAgICAgICAgICBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5sZW5ndGggLSBsaW5lc1tsaW5lcy5sZW5ndGggLSAxXS5tYXRjaCgvXFxyP1xcbj8vKVswXS5sZW5ndGggOlxuICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfY29sdW1uICsgbWF0Y2hbMF0ubGVuZ3RoXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMueXl0ZXh0ICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoICs9IG1hdGNoWzBdO1xuICAgICAgICB0aGlzLm1hdGNoZXMgPSBtYXRjaDtcbiAgICAgICAgdGhpcy55eWxlbmcgPSB0aGlzLnl5dGV4dC5sZW5ndGg7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGxvYy5yYW5nZSA9IFt0aGlzLm9mZnNldCwgdGhpcy5vZmZzZXQgKz0gdGhpcy55eWxlbmddO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21vcmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy5fYmFja3RyYWNrID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UobWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgdGhpcy5tYXRjaGVkICs9IG1hdGNoWzBdO1xuICAgICAgICB0b2tlbiA9IHRoaXMucGVyZm9ybUFjdGlvbi5jYWxsKHRoaXMsIHRoaXMueXksIHRoaXMsIGluZGV4ZWRfcnVsZSwgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKTtcbiAgICAgICAgaWYgKHRoaXMuZG9uZSAmJiB0aGlzLl9pbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAvLyByZWNvdmVyIGNvbnRleHRcbiAgICAgICAgICAgIGZvciAodmFyIGsgaW4gYmFja3VwKSB7XG4gICAgICAgICAgICAgICAgdGhpc1trXSA9IGJhY2t1cFtrXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBmYWxzZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIHRoZSBuZXh0IHJ1bGUgc2hvdWxkIGJlIHRlc3RlZCBpbnN0ZWFkLlxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9LFxuXG4vLyByZXR1cm4gbmV4dCBtYXRjaCBpbiBpbnB1dFxubmV4dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLmRvbmUpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXRoaXMuX2lucHV0KSB7XG4gICAgICAgICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHRva2VuLFxuICAgICAgICAgICAgbWF0Y2gsXG4gICAgICAgICAgICB0ZW1wTWF0Y2gsXG4gICAgICAgICAgICBpbmRleDtcbiAgICAgICAgaWYgKCF0aGlzLl9tb3JlKSB7XG4gICAgICAgICAgICB0aGlzLnl5dGV4dCA9ICcnO1xuICAgICAgICAgICAgdGhpcy5tYXRjaCA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIHZhciBydWxlcyA9IHRoaXMuX2N1cnJlbnRSdWxlcygpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZW1wTWF0Y2ggPSB0aGlzLl9pbnB1dC5tYXRjaCh0aGlzLnJ1bGVzW3J1bGVzW2ldXSk7XG4gICAgICAgICAgICBpZiAodGVtcE1hdGNoICYmICghbWF0Y2ggfHwgdGVtcE1hdGNoWzBdLmxlbmd0aCA+IG1hdGNoWzBdLmxlbmd0aCkpIHtcbiAgICAgICAgICAgICAgICBtYXRjaCA9IHRlbXBNYXRjaDtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5iYWNrdHJhY2tfbGV4ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdG9rZW4gPSB0aGlzLnRlc3RfbWF0Y2godGVtcE1hdGNoLCBydWxlc1tpXSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLl9iYWNrdHJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1hdGNoID0gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTsgLy8gcnVsZSBhY3Rpb24gY2FsbGVkIHJlamVjdCgpIGltcGx5aW5nIGEgcnVsZSBNSVNtYXRjaC5cbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoIXRoaXMub3B0aW9ucy5mbGV4KSB7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKG1hdGNoLCBydWxlc1tpbmRleF0pO1xuICAgICAgICAgICAgaWYgKHRva2VuICE9PSBmYWxzZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0b2tlbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGVsc2U6IHRoaXMgaXMgYSBsZXhlciBydWxlIHdoaWNoIGNvbnN1bWVzIGlucHV0IHdpdGhvdXQgcHJvZHVjaW5nIGEgdG9rZW4gKGUuZy4gd2hpdGVzcGFjZSlcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5faW5wdXQgPT09IFwiXCIpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLkVPRjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcnNlRXJyb3IoJ0xleGljYWwgZXJyb3Igb24gbGluZSAnICsgKHRoaXMueXlsaW5lbm8gKyAxKSArICcuIFVucmVjb2duaXplZCB0ZXh0LlxcbicgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJldHVybiBuZXh0IG1hdGNoIHRoYXQgaGFzIGEgdG9rZW5cbmxleDpmdW5jdGlvbiBsZXgoKSB7XG4gICAgICAgIHZhciByID0gdGhpcy5uZXh0KCk7XG4gICAgICAgIGlmIChyKSB7XG4gICAgICAgICAgICByZXR1cm4gcjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmxleCgpO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gYWN0aXZhdGVzIGEgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSAocHVzaGVzIHRoZSBuZXcgbGV4ZXIgY29uZGl0aW9uIHN0YXRlIG9udG8gdGhlIGNvbmRpdGlvbiBzdGFjaylcbmJlZ2luOmZ1bmN0aW9uIGJlZ2luKGNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmNvbmRpdGlvblN0YWNrLnB1c2goY29uZGl0aW9uKTtcbiAgICB9LFxuXG4vLyBwb3AgdGhlIHByZXZpb3VzbHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvZmYgdGhlIGNvbmRpdGlvbiBzdGFja1xucG9wU3RhdGU6ZnVuY3Rpb24gcG9wU3RhdGUoKSB7XG4gICAgICAgIHZhciBuID0gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxO1xuICAgICAgICBpZiAobiA+IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLnBvcCgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uU3RhY2tbMF07XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyBwcm9kdWNlIHRoZSBsZXhlciBydWxlIHNldCB3aGljaCBpcyBhY3RpdmUgZm9yIHRoZSBjdXJyZW50bHkgYWN0aXZlIGxleGVyIGNvbmRpdGlvbiBzdGF0ZVxuX2N1cnJlbnRSdWxlczpmdW5jdGlvbiBfY3VycmVudFJ1bGVzKCkge1xuICAgICAgICBpZiAodGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggJiYgdGhpcy5jb25kaXRpb25TdGFja1t0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDFdKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW3RoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXV0ucnVsZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25zW1wiSU5JVElBTFwiXS5ydWxlcztcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIHJldHVybiB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGU7IHdoZW4gYW4gaW5kZXggYXJndW1lbnQgaXMgcHJvdmlkZWQgaXQgcHJvZHVjZXMgdGhlIE4tdGggcHJldmlvdXMgY29uZGl0aW9uIHN0YXRlLCBpZiBhdmFpbGFibGVcbnRvcFN0YXRlOmZ1bmN0aW9uIHRvcFN0YXRlKG4pIHtcbiAgICAgICAgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMSAtIE1hdGguYWJzKG4gfHwgMCk7XG4gICAgICAgIGlmIChuID49IDApIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrW25dO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIFwiSU5JVElBTFwiO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gYWxpYXMgZm9yIGJlZ2luKGNvbmRpdGlvbilcbnB1c2hTdGF0ZTpmdW5jdGlvbiBwdXNoU3RhdGUoY29uZGl0aW9uKSB7XG4gICAgICAgIHRoaXMuYmVnaW4oY29uZGl0aW9uKTtcbiAgICB9LFxuXG4vLyByZXR1cm4gdGhlIG51bWJlciBvZiBzdGF0ZXMgY3VycmVudGx5IG9uIHRoZSBzdGFja1xuc3RhdGVTdGFja1NpemU6ZnVuY3Rpb24gc3RhdGVTdGFja1NpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aDtcbiAgICB9LFxub3B0aW9uczoge30sXG5wZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXkseXlfLCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMsWVlfU1RBUlQpIHtcbnZhciBZWVNUQVRFPVlZX1NUQVJUO1xuc3dpdGNoKCRhdm9pZGluZ19uYW1lX2NvbGxpc2lvbnMpIHtcbmNhc2UgMDogdGhpcy5iZWdpbignbm90ZXMnKTsgcmV0dXJuIDE5OyBcbmJyZWFrO1xuY2FzZSAxOiB0aGlzLmJlZ2luKCdvcHRpb25zJyk7IHJldHVybiAxMzsgXG5icmVhaztcbmNhc2UgMjogdGhpcy5iZWdpbignb3B0aW9ucycpOyByZXR1cm4gMTQ7IFxuYnJlYWs7XG5jYXNlIDM6IHRoaXMuYmVnaW4oJ29wdGlvbnMnKTsgcmV0dXJuIDE1OyBcbmJyZWFrO1xuY2FzZSA0OiB0aGlzLmJlZ2luKCdvcHRpb25zJyk7IHJldHVybiAxMTsgXG5icmVhaztcbmNhc2UgNTogdGhpcy5iZWdpbigndGV4dCcpOyByZXR1cm4gMTc7IFxuYnJlYWs7XG5jYXNlIDY6IHRoaXMuYmVnaW4oJ29wdGlvbnMnKTsgcmV0dXJuIDIxOyBcbmJyZWFrO1xuY2FzZSA3OnJldHVybiAyMlxuYnJlYWs7XG5jYXNlIDg6IHRoaXMuYmVnaW4oJ2Fubm90YXRpb25zJyk7IHJldHVybiBcIiRcIiBcbmJyZWFrO1xuY2FzZSA5OiB0aGlzLmJlZ2luKCdub3RlcycpOyByZXR1cm4gXCIkXCIgXG5icmVhaztcbmNhc2UgMTA6cmV0dXJuIDIyXG5icmVhaztcbmNhc2UgMTE6IHRoaXMuYmVnaW4oJ2NvbW1hbmQnKTsgcmV0dXJuIFwiIVwiIFxuYnJlYWs7XG5jYXNlIDEyOiB0aGlzLmJlZ2luKCdub3RlcycpOyByZXR1cm4gXCIhXCIgXG5icmVhaztcbmNhc2UgMTM6cmV0dXJuIDc0XG5icmVhaztcbmNhc2UgMTQ6cmV0dXJuIDI0XG5icmVhaztcbmNhc2UgMTU6cmV0dXJuIDQxXG5icmVhaztcbmNhc2UgMTY6cmV0dXJuICcrJ1xuYnJlYWs7XG5jYXNlIDE3OnJldHVybiAzOFxuYnJlYWs7XG5jYXNlIDE4OnJldHVybiAyM1xuYnJlYWs7XG5jYXNlIDE5OnJldHVybiA0NVxuYnJlYWs7XG5jYXNlIDIwOnJldHVybiA0NlxuYnJlYWs7XG5jYXNlIDIxOnJldHVybiAzMVxuYnJlYWs7XG5jYXNlIDIyOnJldHVybiAzMlxuYnJlYWs7XG5jYXNlIDIzOnJldHVybiA3MFxuYnJlYWs7XG5jYXNlIDI0OnJldHVybiAyNVxuYnJlYWs7XG5jYXNlIDI1OnJldHVybiAzN1xuYnJlYWs7XG5jYXNlIDI2OnJldHVybiA0NFxuYnJlYWs7XG5jYXNlIDI3OnJldHVybiA3NVxuYnJlYWs7XG5jYXNlIDI4OnJldHVybiA3OVxuYnJlYWs7XG5jYXNlIDI5OnJldHVybiA2NVxuYnJlYWs7XG5jYXNlIDMwOnJldHVybiA2MlxuYnJlYWs7XG5jYXNlIDMxOnJldHVybiA1N1xuYnJlYWs7XG5jYXNlIDMyOnJldHVybiA2NlxuYnJlYWs7XG5jYXNlIDMzOnJldHVybiA2M1xuYnJlYWs7XG5jYXNlIDM0OnJldHVybiA2NFxuYnJlYWs7XG5jYXNlIDM1OnJldHVybiA2MVxuYnJlYWs7XG5jYXNlIDM2OnJldHVybiA1MFxuYnJlYWs7XG5jYXNlIDM3OnJldHVybiA2N1xuYnJlYWs7XG5jYXNlIDM4OnJldHVybiA2OFxuYnJlYWs7XG5jYXNlIDM5OnJldHVybiA2OVxuYnJlYWs7XG5jYXNlIDQwOnJldHVybiA1OVxuYnJlYWs7XG5jYXNlIDQxOnJldHVybiA0OFxuYnJlYWs7XG5jYXNlIDQyOnJldHVybiA1OFxuYnJlYWs7XG5jYXNlIDQzOnJldHVybiA1NlxuYnJlYWs7XG5jYXNlIDQ0OnJldHVybiA1N1xuYnJlYWs7XG5jYXNlIDQ1OnJldHVybiA1OVxuYnJlYWs7XG5jYXNlIDQ2OnJldHVybiA2MFxuYnJlYWs7XG5jYXNlIDQ3OnJldHVybiA3NlxuYnJlYWs7XG5jYXNlIDQ4OnJldHVybiA4MFxuYnJlYWs7XG5jYXNlIDQ5OnJldHVybiA4MVxuYnJlYWs7XG5jYXNlIDUwOiB0aGlzLmJlZ2luKCdJTklUSUFMJyk7IFxuYnJlYWs7XG5jYXNlIDUxOi8qIHNraXAgd2hpdGVzcGFjZSAqL1xuYnJlYWs7XG5jYXNlIDUyOnJldHVybiA1XG5icmVhaztcbmNhc2UgNTM6cmV0dXJuICdJTlZBTElEJ1xuYnJlYWs7XG59XG59LFxucnVsZXM6IFsvXig/Om5vdGVzXFxiKS8sL14oPzp0YWJzdGF2ZVxcYikvLC9eKD86c3RhdmVcXGIpLywvXig/OnZvaWNlXFxiKS8sL14oPzpvcHRpb25zXFxiKS8sL14oPzp0ZXh0XFxiKS8sL14oPzpzbHVyXFxiKS8sL14oPzpbXlxccz1dKykvLC9eKD86WyRdKS8sL14oPzpbJF0pLywvXig/OlteLCRdKykvLC9eKD86WyFdKS8sL14oPzpbIV0pLywvXig/OlteIV0rKS8sL14oPzpbXixcXHJcXG5dKykvLC9eKD86XFwvKS8sL14oPzpcXCspLywvXig/OjopLywvXig/Oj0pLywvXig/OlxcKCkvLC9eKD86XFwpKS8sL14oPzpcXFspLywvXig/OlxcXSkvLC9eKD86XFxeKS8sL14oPzosKS8sL14oPzpcXHwpLywvXig/OlxcLikvLC9eKD86IykvLC9eKD86QCkvLC9eKD86W2JdKS8sL14oPzpbc10pLywvXig/OltoXSkvLC9eKD86W3BdKS8sL14oPzpbdF0pLywvXig/OltUXSkvLC9eKD86Wy1dKS8sL14oPzpbX10pLywvXig/Olt2XSkvLC9eKD86W1ZdKS8sL14oPzpbdV0pLywvXig/OltkXSkvLC9eKD86WzAtOV0rKS8sL14oPzpbcV0pLywvXig/Olt3XSkvLC9eKD86W2hdKS8sL14oPzpbZF0pLywvXig/OltTXSkvLC9eKD86W0EtR1hMUl0pLywvXig/OltuXSkvLC9eKD86W35dKS8sL14oPzpbXFxyXFxuXSspLywvXig/OlxccyspLywvXig/OiQpLywvXig/Oi4pL10sXG5jb25kaXRpb25zOiB7XCJub3Rlc1wiOntcInJ1bGVzXCI6WzgsMTEsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTNdLFwiaW5jbHVzaXZlXCI6dHJ1ZX0sXCJ0ZXh0XCI6e1wicnVsZXNcIjpbMTQsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsNDEsNDIsNDMsNDQsNDUsNTAsNTEsNTIsNTNdLFwiaW5jbHVzaXZlXCI6dHJ1ZX0sXCJzbHVyXCI6e1wicnVsZXNcIjpbMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsNTAsNTEsNTIsNTNdLFwiaW5jbHVzaXZlXCI6dHJ1ZX0sXCJhbm5vdGF0aW9uc1wiOntcInJ1bGVzXCI6WzksMTAsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsNTAsNTEsNTIsNTNdLFwiaW5jbHVzaXZlXCI6dHJ1ZX0sXCJvcHRpb25zXCI6e1wicnVsZXNcIjpbNywxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCw1MCw1MSw1Miw1M10sXCJpbmNsdXNpdmVcIjp0cnVlfSxcImNvbW1hbmRcIjp7XCJydWxlc1wiOlsxMiwxMywxNSwxNiwxNywxOCwxOSwyMCwyMSwyMiwyMywyNCwyNSwyNiwyNywyOCw1MCw1MSw1Miw1M10sXCJpbmNsdXNpdmVcIjp0cnVlfSxcIklOSVRJQUxcIjp7XCJydWxlc1wiOlswLDEsMiwzLDQsNSw2LDcsMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsNTAsNTEsNTIsNTNdLFwiaW5jbHVzaXZlXCI6dHJ1ZX19XG59KTtcbnJldHVybiBsZXhlcjtcbn0pKCk7XG5wYXJzZXIubGV4ZXIgPSBsZXhlcjtcbmZ1bmN0aW9uIFBhcnNlciAoKSB7XG4gIHRoaXMueXkgPSB7fTtcbn1cblBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7cGFyc2VyLlBhcnNlciA9IFBhcnNlcjtcbnJldHVybiBuZXcgUGFyc2VyO1xufSkoKTtcblxuXG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG5leHBvcnRzLlBhcnNlciA9IHBhcnNlci5QYXJzZXI7XG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyLnBhcnNlLmFwcGx5KHBhcnNlciwgYXJndW1lbnRzKTsgfTtcbmV4cG9ydHMubWFpbiA9IGZ1bmN0aW9uIGNvbW1vbmpzTWFpbihhcmdzKSB7XG4gICAgaWYgKCFhcmdzWzFdKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2FnZTogJythcmdzWzBdKycgRklMRScpO1xuICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSByZXF1aXJlKCdmcycpLnJlYWRGaWxlU3luYyhyZXF1aXJlKCdwYXRoJykubm9ybWFsaXplKGFyZ3NbMV0pLCBcInV0ZjhcIik7XG4gICAgcmV0dXJuIGV4cG9ydHMucGFyc2VyLnBhcnNlKHNvdXJjZSk7XG59O1xuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHJlcXVpcmUubWFpbiA9PT0gbW9kdWxlKSB7XG4gIGV4cG9ydHMubWFpbihwcm9jZXNzLmFyZ3Yuc2xpY2UoMSkpO1xufVxufSIsbnVsbCwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjIuMi4wXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDEtMDhUMjA6MDJaXG4gKi9cblxuKGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gU3VwcG9ydDogRmlyZWZveCAxOCtcbi8vIENhbid0IGJlIGluIHN0cmljdCBtb2RlLCBzZXZlcmFsIGxpYnMgaW5jbHVkaW5nIEFTUC5ORVQgdHJhY2Vcbi8vIHRoZSBzdGFjayB2aWEgYXJndW1lbnRzLmNhbGxlci5jYWxsZWUgYW5kIEZpcmVmb3ggZGllcyBpZlxuLy8geW91IHRyeSB0byB0cmFjZSB0aHJvdWdoIFwidXNlIHN0cmljdFwiIGNhbGwgY2hhaW5zLiAoIzEzMzM1KVxuLy9cInVzZSBzdHJpY3RcIjtcbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIyLjIuMFwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbXFxkYS16XSkvZ2ksXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiXCIsXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gIT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdFx0c2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0Ly8gYWRkaW5nIDEgY29ycmVjdHMgbG9zcyBvZiBwcmVjaXNpb24gZnJvbSBwYXJzZUZsb2F0ICgjMTUxMDApXG5cdFx0dmFyIHJlYWxTdHJpbmdPYmogPSBvYmogJiYgb2JqLnRvU3RyaW5nKCk7XG5cdFx0cmV0dXJuICFqUXVlcnkuaXNBcnJheSggb2JqICkgJiYgKCByZWFsU3RyaW5nT2JqIC0gcGFyc2VGbG9hdCggcmVhbFN0cmluZ09iaiApICsgMSApID49IDA7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIE5vdCBwbGFpbiBvYmplY3RzOlxuXHRcdC8vIC0gQW55IG9iamVjdCBvciB2YWx1ZSB3aG9zZSBpbnRlcm5hbCBbW0NsYXNzXV0gcHJvcGVydHkgaXMgbm90IFwiW29iamVjdCBPYmplY3RdXCJcblx0XHQvLyAtIERPTSBub2Rlc1xuXHRcdC8vIC0gd2luZG93XG5cdFx0aWYgKCBqUXVlcnkudHlwZSggb2JqICkgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCBvYmouY29uc3RydWN0b3IgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgcmV0dXJuZWQgYWxyZWFkeSwgd2UncmUgY29uZmlkZW50IHRoYXRcblx0XHQvLyB8b2JqfCBpcyBhIHBsYWluIG9iamVjdCwgY3JlYXRlZCBieSB7fSBvciBjb25zdHJ1Y3RlZCB3aXRoIG5ldyBPYmplY3Rcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMCwgaU9TPDYgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0dmFyIHNjcmlwdCxcblx0XHRcdGluZGlyZWN0ID0gZXZhbDtcblxuXHRcdGNvZGUgPSBqUXVlcnkudHJpbSggY29kZSApO1xuXG5cdFx0aWYgKCBjb2RlICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgY29kZSBpbmNsdWRlcyBhIHZhbGlkLCBwcm9sb2d1ZSBwb3NpdGlvblxuXHRcdFx0Ly8gc3RyaWN0IG1vZGUgcHJhZ21hLCBleGVjdXRlIGNvZGUgYnkgaW5qZWN0aW5nIGFcblx0XHRcdC8vIHNjcmlwdCB0YWcgaW50byB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpZiAoIGNvZGUuaW5kZXhPZiggXCJ1c2Ugc3RyaWN0XCIgKSA9PT0gMSApIHtcblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXHRcdFx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGF2b2lkIHRoZSBET00gbm9kZSBjcmVhdGlvbiwgaW5zZXJ0aW9uXG5cdFx0XHRcdC8vIGFuZCByZW1vdmFsIGJ5IHVzaW5nIGFuIGluZGlyZWN0IGdsb2JhbCBldmFsXG5cblx0XHRcdFx0aW5kaXJlY3QoIGNvZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbi8vIEpTSGludCB3b3VsZCBlcnJvciBvbiB0aGlzIGNvZGUgZHVlIHRvIHRoZSBTeW1ib2wgbm90IGJlaW5nIGRlZmluZWQgaW4gRVM1LlxuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmpzaGludHJjIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8ganVzdCBkaXNhYmxlIEpTSGludCBmb3IgdGhlc2Vcbi8vIHRocmVlIGxpbmVzLlxuLyoganNoaW50IGlnbm9yZTogc3RhcnQgKi9cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cbi8qIGpzaGludCBpZ25vcmU6IGVuZCAqL1xuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogaU9TIDguMiAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4yLjFcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTUtMTAtMTdcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcblx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXHRyZXNjYXBlID0gLyd8XFxcXC9nLFxuXG5cdC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBuaWRzZWxlY3QsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdG5pZHNlbGVjdCA9IHJpZGVudGlmaWVyLnRlc3QoIG5pZCApID8gXCIjXCIgKyBuaWQgOiBcIltpZD0nXCIgKyBuaWQgKyBcIiddXCI7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBuaWRzZWxlY3QgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGRpdiBhbmQgZXhwZWN0cyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGRpdiApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZGl2LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZGl2ICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdCggfmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICkgLVxuXHRcdFx0KCB+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKTtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgcGFyZW50LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCAocGFyZW50ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHBhcmVudC50b3AgIT09IHBhcmVudCApIHtcblx0XHQvLyBTdXBwb3J0OiBJRSAxMVxuXHRcdGlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggcGFyZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0cGFyZW50LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZGl2LmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmluZCBhbmQgZmlsdGVyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gbSA/IFsgbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2liaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRkaXYucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGRpdiwgXCJkaXZcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGRpdiwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRcImRpc2FibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGRpciBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgZGlyIF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0c3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYxICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRyZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFtcXHctXSspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvICk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0fSApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0cmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID9cblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW10gOlxuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0XHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG5cdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQmxhY2tiZXJyeSA0LjZcblx0XHRcdFx0XHQvLyBnRUJJRCByZXR1cm5zIG5vZGVzIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKCM2OTYzKVxuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHBvcyA9IHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCApIDpcblx0XHRcdFx0MDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCBwb3MgP1xuXHRcdFx0XHRcdHBvcy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3R3aGl0ZSA9ICggL1xcUysvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGxpc3RlbmVyIGxpc3QsIGZpbmFsIHN0YXRlXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCBcInJlamVjdGVkXCIgXSxcblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgaSBdICkgJiYgZm5zWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzID09PSBwcm9taXNlID8gbmV3RGVmZXIucHJvbWlzZSgpIDogdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRwcm9taXNlLnBpcGUgPSBwcm9taXNlLnRoZW47XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cblx0XHRcdC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG5cdFx0XHRcdH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcblxuXHRcdFx0Ly8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8XG5cdFx0XHRcdCggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZC5cblx0XHRcdC8vIElmIHJlc29sdmVWYWx1ZXMgY29uc2lzdCBvZiBvbmx5IGEgc2luZ2xlIERlZmVycmVkLCBqdXN0IHVzZSB0aGF0LlxuXHRcdFx0ZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBVcGRhdGUgZnVuY3Rpb24gZm9yIGJvdGggcmVzb2x2ZSBhbmQgcHJvZ3Jlc3MgdmFsdWVzXG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGksIGNvbnRleHRzLCB2YWx1ZXMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0Y29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0dmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XG5cblx0XHQvLyBBZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXG5cdFx0aWYgKCBsZW5ndGggPiAxICkge1xuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKClcblx0XHRcdFx0XHRcdC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC0tcmVtYWluaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxuXHRcdGlmICggIXJlbWFpbmluZyApIHtcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0O1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0Ly8gQWRkIHRoZSBjYWxsYmFja1xuXHRqUXVlcnkucmVhZHkucHJvbWlzZSgpLmRvbmUoIGZuICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXG5cdFx0Ly8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXG5cdFx0aWYgKCBqUXVlcnkuZm4udHJpZ2dlckhhbmRsZXIgKSB7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlckhhbmRsZXIoIFwicmVhZHlcIiApO1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLm9mZiggXCJyZWFkeVwiICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8qKlxuICogVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG5qUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdGlmICggIXJlYWR5TGlzdCApIHtcblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcblx0XHQvLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHQvLyBTdXBwb3J0OiBJRTktMTAgb25seVxuXHRcdC8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuXHRcdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdFx0XHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHRcdFx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xufTtcblxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XG5qUXVlcnkucmVhZHkucHJvbWlzZSgpO1xuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2hhaW5hYmxlID9cblx0XHRlbGVtcyA6XG5cblx0XHQvLyBHZXRzXG5cdFx0YnVsayA/XG5cdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcblx0XHRcdGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHQvKiBqc2hpbnQgLVcwMTggKi9cblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdHJlZ2lzdGVyOiBmdW5jdGlvbiggb3duZXIsIGluaXRpYWwgKSB7XG5cdFx0dmFyIHZhbHVlID0gaW5pdGlhbCB8fCB7fTtcblxuXHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlIHByb3BlcnR5XG5cdFx0Ly8gY29uZmlndXJhYmlsaXR5IG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHQvLyBkZWxldGVkIHdpdGggdGhlIGRlbGV0ZSBvcGVyYXRvclxuXHRcdH0gZWxzZSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdH0sXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdGlmICggIWFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgZGF0YSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBwcm9wIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBrZXkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHN0b3JlZDtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0c3RvcmVkID0gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblxuXHRcdFx0cmV0dXJuIHN0b3JlZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0c3RvcmVkIDogdGhpcy5nZXQoIG93bmVyLCBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSwgbmFtZSwgY2FtZWwsXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5yZWdpc3Rlciggb3duZXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuXHRcdFx0XHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuXHRcdFx0XHRuYW1lID0ga2V5LmNvbmNhdCgga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW1lbCA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIFRyeSB0aGUgc3RyaW5nIGFzIGEga2V5IGJlZm9yZSBhbnkgbWFuaXB1bGF0aW9uXG5cdFx0XHRcdGlmICgga2V5IGluIGNhY2hlICkge1xuXHRcdFx0XHRcdG5hbWUgPSBbIGtleSwgY2FtZWwgXTtcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRcdG5hbWUgPSBjYW1lbDtcblx0XHRcdFx0XHRuYW1lID0gbmFtZSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0XHRbIG5hbWUgXSA6ICggbmFtZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIG5hbWVbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PSAzNS00NStcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3XG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMStcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhLCBjYW1lbEtleTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGFzLWlzXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApIHx8XG5cblx0XHRcdFx0XHQvLyBUcnkgdG8gZmluZCBkYXNoZWQga2V5IGlmIGl0IGV4aXN0cyAoZ2gtMjc3OSlcblx0XHRcdFx0XHQvLyBUaGlzIGlzIGZvciAyLjIueCBvbmx5XG5cdFx0XHRcdFx0ZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCkgKTtcblxuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbWVsS2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgY2FtZWxpemVkXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGNhbWVsS2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGNhbWVsS2V5LCB1bmRlZmluZWQgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBGaXJzdCwgYXR0ZW1wdCB0byBzdG9yZSBhIGNvcHkgb3IgcmVmZXJlbmNlIG9mIGFueVxuXHRcdFx0XHQvLyBkYXRhIHRoYXQgbWlnaHQndmUgYmVlbiBzdG9yZSB3aXRoIGEgY2FtZWxDYXNlZCBrZXkuXG5cdFx0XHRcdHZhciBkYXRhID0gZGF0YVVzZXIuZ2V0KCB0aGlzLCBjYW1lbEtleSApO1xuXG5cdFx0XHRcdC8vIEZvciBIVE1MNSBkYXRhLSogYXR0cmlidXRlIGludGVyb3AsIHdlIGhhdmUgdG9cblx0XHRcdFx0Ly8gc3RvcmUgcHJvcGVydHkgbmFtZXMgd2l0aCBkYXNoZXMgaW4gYSBjYW1lbENhc2UgZm9ybS5cblx0XHRcdFx0Ly8gVGhpcyBtaWdodCBub3QgYXBwbHkgdG8gYWxsIHByb3BlcnRpZXMuLi4qXG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywgY2FtZWxLZXksIHZhbHVlICk7XG5cblx0XHRcdFx0Ly8gKi4uLiBJbiB0aGUgY2FzZSBvZiBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgX2FjdHVhbGx5X1xuXHRcdFx0XHQvLyBoYXZlIGRhc2hlcywgd2UgbmVlZCB0byBhbHNvIHN0b3JlIGEgY29weSBvZiB0aGF0XG5cdFx0XHRcdC8vIHVuY2hhbmdlZCBwcm9wZXJ0eS5cblx0XHRcdFx0aWYgKCBrZXkuaW5kZXhPZiggXCItXCIgKSA+IC0xICYmIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHQhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHdlZW4uY3VyKCk7IH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7IH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFtcXHc6LV0rKS8gKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldCA9IHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdFtdO1xuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxuXHRcdHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMSwgUGhhbnRvbUpTPDJcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMC00LjMsIFNhZmFyaTw9NS4xXG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmk8PTUuMSwgQW5kcm9pZDw0LjJcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUU5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgbWF0Y2hlcywgc2VsLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gU3VwcG9ydCAoYXQgbGVhc3QpOiBDaHJvbWUsIElFOVxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxuXHRcdC8vXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDw9NDIrXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgaW4gRkYgYnV0IGRvbid0IGJsb2NrIElFIHJhZGlvIGV2ZW50cyAoIzM4NjEsIGdoLTIzNDMpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJlxuXHRcdFx0KCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgfHwgaXNOYU4oIGV2ZW50LmJ1dHRvbiApIHx8IGV2ZW50LmJ1dHRvbiA8IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAoIGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gW107XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZXMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHQvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxuXHRwcm9wczogKCBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGRldGFpbCBldmVudFBoYXNlIFwiICtcblx0XHRcIm1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIiApLnNwbGl0KCBcIiBcIiApLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdCggXCIgXCIgKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9IG9yaWdpbmFsLmNoYXJDb2RlICE9IG51bGwgPyBvcmlnaW5hbC5jaGFyQ29kZSA6IG9yaWdpbmFsLmtleUNvZGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0bW91c2VIb29rczoge1xuXHRcdHByb3BzOiAoIFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBcIiArXG5cdFx0XHRcInNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblx0XHRcdHZhciBldmVudERvYywgZG9jLCBib2R5LFxuXHRcdFx0XHRidXR0b24gPSBvcmlnaW5hbC5idXR0b247XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcblx0XHRcdGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0Ym9keSA9IGV2ZW50RG9jLmJvZHk7XG5cblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcblx0XHRcdFx0ZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCwgY29weSxcblx0XHRcdHR5cGUgPSBldmVudC50eXBlLFxuXHRcdFx0b3JpZ2luYWxFdmVudCA9IGV2ZW50LFxuXHRcdFx0Zml4SG9vayA9IHRoaXMuZml4SG9va3NbIHR5cGUgXTtcblxuXHRcdGlmICggIWZpeEhvb2sgKSB7XG5cdFx0XHR0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cblx0XHRcdFx0cm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcblx0XHRcdFx0cmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxuXHRcdFx0XHR7fTtcblx0XHR9XG5cdFx0Y29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcblxuXHRcdGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0aSA9IGNvcHkubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0cHJvcCA9IGNvcHlbIGkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQ29yZG92YSAyLjUgKFdlYktpdCkgKCMxMzI1NSlcblx0XHQvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3Rcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wKywgQ2hyb21lPDI4XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6LV0rKVtePl0qKVxcLz4vZ2ksXG5cblx0Ly8gU3VwcG9ydDogSUUgMTAtMTEsIEVkZ2UgMTAyNDArXG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0gMzUtNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gS2VlcCBkb21NYW5pcCBleHBvc2VkIHVudGlsIDMuMCAoZ2gtMjIyNSlcblx0ZG9tTWFuaXA6IGRvbU1hbmlwLFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcblxuXG52YXIgaWZyYW1lLFxuXHRlbGVtZGlzcGxheSA9IHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3hcblx0XHQvLyBXZSBoYXZlIHRvIHByZS1kZWZpbmUgdGhlc2UgdmFsdWVzIGZvciBGRiAoIzEwMjI3KVxuXHRcdEhUTUw6IFwiYmxvY2tcIixcblx0XHRCT0RZOiBcImJsb2NrXCJcblx0fTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcbiAqL1xuXG4vLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxuZnVuY3Rpb24gYWN0dWFsRGlzcGxheSggbmFtZSwgZG9jICkge1xuXHR2YXIgZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxuXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW1bIDAgXSwgXCJkaXNwbGF5XCIgKTtcblxuXHQvLyBXZSBkb24ndCBoYXZlIGFueSBkYXRhIHN0b3JlZCBvbiB0aGUgZWxlbWVudCxcblx0Ly8gc28gdXNlIFwiZGV0YWNoXCIgbWV0aG9kIGFzIGZhc3Qgd2F5IHRvIGdldCByaWQgb2YgdGhlIGVsZW1lbnRcblx0ZWxlbS5kZXRhY2goKTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuLyoqXG4gKiBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcblx0dmFyIGRvYyA9IGRvY3VtZW50LFxuXHRcdGRpc3BsYXkgPSBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTtcblxuXHRpZiAoICFkaXNwbGF5ICkge1xuXHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cblx0XHQvLyBJZiB0aGUgc2ltcGxlIHdheSBmYWlscywgcmVhZCBmcm9tIGluc2lkZSBhbiBpZnJhbWVcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiIHx8ICFkaXNwbGF5ICkge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcblx0XHRcdGlmcmFtZSA9ICggaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSApXG5cdFx0XHRcdC5hcHBlbmRUbyggZG9jLmRvY3VtZW50RWxlbWVudCApO1xuXG5cdFx0XHQvLyBBbHdheXMgd3JpdGUgYSBuZXcgSFRNTCBza2VsZXRvbiBzbyBXZWJraXQgYW5kIEZpcmVmb3ggZG9uJ3QgY2hva2Ugb24gcmV1c2Vcblx0XHRcdGRvYyA9IGlmcmFtZVsgMCBdLmNvbnRlbnREb2N1bWVudDtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUVcblx0XHRcdGRvYy53cml0ZSgpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cblx0XHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cdFx0XHRpZnJhbWUuZGV0YWNoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XG5cdFx0ZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXHR9XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHR9XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBUaGlzIHRlc3QgaXMgZXhlY3V0ZWQgb25seSBvbmNlIGJ1dCB3ZSBzdGlsbCBkbyBtZW1vaXppbmdcblx0XHRcdC8vIHNpbmNlIHdlIGNhbiB1c2UgdGhlIGJveFNpemluZ1JlbGlhYmxlIHByZS1jb21wdXRpbmcuXG5cdFx0XHQvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0ZXN0IHdhcyBhbHJlYWR5IHBlcmZvcm1lZCwgdGhvdWdoLlxuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wLTQuM1xuXHRcdFx0Ly8gV2UncmUgY2hlY2tpbmcgZm9yIGJveFNpemluZ1JlbGlhYmxlVmFsIGhlcmUgaW5zdGVhZCBvZiBwaXhlbE1hcmdpblJpZ2h0VmFsXG5cdFx0XHQvLyBzaW5jZSB0aGF0IGNvbXByZXNzZXMgYmV0dGVyIGFuZCB0aGV5J3JlIGNvbXB1dGVkIHRvZ2V0aGVyIGFueXdheS5cblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IG9ubHksIEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gMzdcblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gKCMzMzMzKVxuXHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHQvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRtYXJnaW5EaXYgPSBkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHQvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyOyBwYWRkaW5nXG5cdFx0XHRtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFwiZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcIjtcblx0XHRcdG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0ZGl2LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcblx0XHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHRcdHJldCA9ICFwYXJzZUZsb2F0KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2ICkubWFyZ2luUmlnaHQgKTtcblxuXHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0XHRcdGRpdi5yZW1vdmVDaGlsZCggbWFyZ2luRGl2ICk7XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxNYXJnaW5SaWdodCgpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJPXCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cblx0XHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0XHQ0IDpcblxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHR2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFMTEgb25seVxuXHQvLyBJbiBJRSAxMSBmdWxsc2NyZWVuIGVsZW1lbnRzIGluc2lkZSBvZiBhbiBpZnJhbWUgaGF2ZVxuXHQvLyAxMDB4IHRvbyBzbWFsbCBkaW1lbnNpb25zIChnaC0xNzY0KS5cblx0aWYgKCBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50ICYmIHdpbmRvdy50b3AgIT09IHdpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFMTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0aWYgKCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0dmFsID0gTWF0aC5yb3VuZCggZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVsgbmFtZSBdICogMTAwICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblxuXHRcdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0aWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdFx0dmFsID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xuXHRcdFx0Ly8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuXHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICYmIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIG92ZXJyaWRkZW4gd2l0aCBkaXNwbGF5OiBub25lXG5cdFx0XHQvLyBpbiBhIHN0eWxlc2hlZXQgdG8gd2hhdGV2ZXIgdGhlIGRlZmF1bHQgYnJvd3NlciBzdHlsZSBpc1xuXHRcdFx0Ly8gZm9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW4oIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuYWNjZXNzKFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XCJvbGRkaXNwbGF5XCIsXG5cdFx0XHRcdFx0ZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xuXG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiIHx8ICFoaWRkZW4gKSB7XG5cdFx0XHRcdGRhdGFQcml2LnNldChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFwib2xkZGlzcGxheVwiLFxuXHRcdFx0XHRcdGhpZGRlbiA/IGRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3Bcblx0Ly8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmICggIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gdmFsdWVzWyBpbmRleCBdIHx8IFwiXCIgOiBcIm5vbmVcIjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXHRcdFx0XHRcdGVsZW0ub2Zmc2V0V2lkdGggPT09IDAgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5SaWdodCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiBzd2FwKCBlbGVtLCB7IFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiIH0sXG5cdFx0XHRcdGN1ckNTUywgWyBlbGVtLCBcIm1hcmdpblJpZ2h0XCIgXSApO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBDb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0LyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgdHdlZW4sIGhvb2tzLCBvbGRmaXJlLCBkaXNwbGF5LCBjaGVja0Rpc3BsYXksXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBIYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEhlaWdodC93aWR0aCBvdmVyZmxvdyBwYXNzXG5cdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiaGVpZ2h0XCIgaW4gcHJvcHMgfHwgXCJ3aWR0aFwiIGluIHByb3BzICkgKSB7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBub3RoaW5nIHNuZWFrcyBvdXRcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFOS0xMCBkbyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHQvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cblx0XHRcdGRhdGFQcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheTtcblxuXHRcdGlmICggY2hlY2tEaXNwbGF5ID09PSBcImlubGluZVwiICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gc2hvdy9oaWRlIHBhc3Ncblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy5leGVjKCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBkYXRhU2hvdyBsZWZ0IG92ZXIgZnJvbSBhIHN0b3BwZWQgaGlkZSBvciBzaG93XG5cdFx0XHRcdC8vIGFuZCB3ZSBhcmUgZ29pbmcgdG8gcHJvY2VlZCB3aXRoIHNob3csIHdlIHNob3VsZCBwcmV0ZW5kIHRvIGJlIGhpZGRlblxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblxuXHRcdC8vIEFueSBub24tZnggdmFsdWUgc3RvcHMgdXMgZnJvbSByZXN0b3JpbmcgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlzcGxheSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblxuXHRpZiAoICFqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHt9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgc3RhdGUgaWYgaXRzIHRvZ2dsZSAtIGVuYWJsZXMgLnN0b3AoKS50b2dnbGUoKSB0byBcInJldmVyc2VcIlxuXHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHR9XG5cdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRqUXVlcnkoIGVsZW0gKS5zaG93KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwcm9wO1xuXG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0dHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblxuXHRcdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdFx0dHdlZW4uZW5kID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdFx0dHdlZW4uc3RhcnQgPSBwcm9wID09PSBcIndpZHRoXCIgfHwgcHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdC8vIElmIHRoaXMgaXMgYSBub29wIGxpa2UgLmhpZGUoKS5oaWRlKCksIHJlc3RvcmUgYW4gb3ZlcndyaXR0ZW4gZGlzcGxheSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCAoIGRpc3BsYXkgPT09IFwibm9uZVwiID8gZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXkgKSA9PT0gXCJpbmxpbmVcIiApIHtcblx0XHRzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0alF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/XG5cdFx0b3B0LmR1cmF0aW9uIDogb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgP1xuXHRcdFx0alF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggIXRpbWVySWQgKSB7XG5cdFx0dGltZXJJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHR3aW5kb3cuY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBpT1M8PTUuMSwgQW5kcm9pZDw9NC4yK1xuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8PTIuM1xuXHQvLyBPcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZSBpbmNvcnJlY3RseSBtYXJrZWQgYXMgZGlzYWJsZWRcblx0c2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcblx0c3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGF0dHJpYnV0ZXMgYXJlIGxvd2VyY2FzZVxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsIHByb3BOYW1lLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcblx0XHRcdFx0aWYgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0XHRcdC8vIFNldCBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHRvIGZhbHNlXG5cdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIG5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGFiaW5kZXggP1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKSA6XG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIGN1clZhbHVlICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIGdldENsYXNzKCBlbGVtICkgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApIDpcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8MTFcblx0XHRcdFx0Ly8gb3B0aW9uLnZhbHVlIG5vdCB0cmltbWVkICgjMTQ4NTgpXG5cdFx0XHRcdHJldHVybiBqUXVlcnkudHJpbSggZWxlbS52YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIgfHwgaW5kZXggPCAwLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cblx0XHRcdFx0XHRcdG1heCA6XG5cdFx0XHRcdFx0XHRvbmUgPyBpbmRleCA6IDA7XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCggc3VwcG9ydC5vcHREaXNhYmxlZCA/XG5cdFx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCA6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09PSBudWxsICkgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cblx0XHRcdFx0Ly8gUHJldmlvdXNseSwgYG9yaWdpbmFsRXZlbnQ6IHt9YCB3YXMgc2V0IGhlcmUsIHNvIHN0b3BQcm9wYWdhdGlvbiBjYWxsXG5cdFx0XHRcdC8vIHdvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgb24gZG9ub3IgZXZlbnQsIHNpbmNlIGluIG91ciBvd25cblx0XHRcdFx0Ly8galF1ZXJ5LmV2ZW50LnN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvbiB3ZSBoYWQgYSBjaGVjayBmb3IgZXhpc3RlbmNlIG9mXG5cdFx0XHRcdC8vIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uIG1ldGhvZCwgc28sIGNvbnNlcXVlbnRseSBpdCB3b3VsZCBiZSBhIG5vb3AuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIEJ1dCBub3csIHRoaXMgXCJzaW11bGF0ZVwiIGZ1bmN0aW9uIGlzIHVzZWQgb25seSBmb3IgZXZlbnRzXG5cdFx0XHRcdC8vIGZvciB3aGljaCBzdG9wUHJvcGFnYXRpb24oKSBpcyBub29wLCBzbyB0aGVyZSBpcyBubyBuZWVkIGZvciB0aGF0IGFueW1vcmUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIEZvciB0aGUgY29tcGF0IGJyYW5jaCB0aG91Z2gsIGd1YXJkIGZvciBcImNsaWNrXCIgYW5kIFwic3VibWl0XCJcblx0XHRcdFx0Ly8gZXZlbnRzIGlzIHN0aWxsIHVzZWQsIGJ1dCB3YXMgbW92ZWQgdG8galF1ZXJ5LmV2ZW50LnN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvblxuXHRcdFx0XHQvLyBiZWNhdXNlIGBvcmlnaW5hbEV2ZW50YCBzaG91bGQgcG9pbnQgdG8gdGhlIG9yaWdpbmFsIGV2ZW50IGZvciB0aGUgY29uc3RhbmN5XG5cdFx0XHRcdC8vIHdpdGggb3RoZXIgZXZlbnRzIGFuZCBmb3IgbW9yZSBmb2N1c2VkIGxvZ2ljXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUsIFNhZmFyaVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuLy8gV29ya2Fyb3VuZCBmYWlsdXJlIHRvIHN0cmluZy1jYXN0IG51bGwgaW5wdXRcbmpRdWVyeS5wYXJzZUpTT04gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKyBcIlwiICk7XG59O1xuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcblx0XHRcdHN0YXRlID0gMCxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcblx0XHRqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcblx0XHRqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cblx0XHQvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgtMTErXG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIGlmIHVybCBpcyBtYWxmb3JtZWQsIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU4LTExK1xuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdGNhY2hlVVJMID0gcy51cmw7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gKCBzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhICk7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBDYWxsZWQgb25jZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcblx0XHRcdHN0YXRlID0gMjtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0gKS5lbmQoKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0Ly8gU3VwcG9ydDogT3BlcmEgPD0gMTIuMTJcblx0Ly8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xuXHQvLyBVc2UgT1IgaW5zdGVhZCBvZiBBTkQgYXMgdGhlIGVsZW1lbnQgaXMgbm90IHZpc2libGUgaWYgZWl0aGVyIGlzIHRydWVcblx0Ly8gU2VlIHRpY2tldHMgIzEwNDA2IGFuZCAjMTMxMzJcblx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPiAwIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0ID4gMCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoID4gMDtcbn07XG5cblxuXG5cbnZhciByMjAgPSAvJTIwL2csXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgPyB2YWx1ZSgpIDogKCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncyAmJiBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0eyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFOSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCtcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRjb250ZXh0ID0gY29udGV4dCB8fCAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID9cblx0XHRkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKSA6XG5cdFx0ZG9jdW1lbnQgKTtcblxuXHR2YXIgcGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICksXG5cdFx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxudmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7XG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdGlmICggdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCApIHtcblx0XHRyZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0galF1ZXJ5LnRyaW0oIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHNlbGYsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRpZiAoICFkb2MgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBNYWtlIHN1cmUgaXQncyBub3QgYSBkaXNjb25uZWN0ZWQgRE9NIG5vZGVcblx0XHRpZiAoICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcblx0XHRcdHJldHVybiBib3g7XG5cdFx0fVxuXG5cdFx0Ym94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IGJveC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdGxlZnQ6IGJveC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0fTtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSxcblx0XHQvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdC8vIFN1YnRyYWN0IG9mZnNldFBhcmVudCBzY3JvbGwgcG9zaXRpb25zXG5cdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKSAtXG5cdFx0XHRcdG9mZnNldFBhcmVudC5zY3JvbGxUb3AoKTtcblx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICkgLVxuXHRcdFx0XHRvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdCgpO1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmk8Ny04KywgQ2hyb21lPDM3LTQ0K1xuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MjgwXG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIEFzIG9mIDUvOC8yMDEyIHRoaXMgd2lsbCB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBmb3IgTW9iaWxlIFNhZmFyaSwgYnV0IHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlLCBudWxsICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH0sXG5cdHNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxlbmd0aDtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uYW5kU2VsZiA9IGpRdWVyeS5mbi5hZGRCYWNrO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cbnJldHVybiBqUXVlcnk7XG59KSk7XG4iLCIvKiFcbiAqIFBhcGVyLmpzIHYwLjkuMjUgLSBUaGUgU3dpc3MgQXJteSBLbmlmZSBvZiBWZWN0b3IgR3JhcGhpY3MgU2NyaXB0aW5nLlxuICogaHR0cDovL3BhcGVyanMub3JnL1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAxMSAtIDIwMTQsIEp1ZXJnIExlaG5pICYgSm9uYXRoYW4gUHVja2V5XG4gKiBodHRwOi8vc2NyYXRjaGRpc2suY29tLyAmIGh0dHA6Ly9qb25hdGhhbnB1Y2tleS5jb20vXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLiBTZWUgTElDRU5TRSBmaWxlIGZvciBkZXRhaWxzLlxuICpcbiAqIEFsbCByaWdodHMgcmVzZXJ2ZWQuXG4gKlxuICogRGF0ZTogU3VuIE9jdCAyNSAxMToyMzozOCAyMDE1ICswMTAwXG4gKlxuICoqKlxuICpcbiAqIFN0cmFwcy5qcyAtIENsYXNzIGluaGVyaXRhbmNlIGxpYnJhcnkgd2l0aCBzdXBwb3J0IGZvciBiZWFuLXN0eWxlIGFjY2Vzc29yc1xuICpcbiAqIENvcHlyaWdodCAoYykgMjAwNiAtIDIwMTMgSnVlcmcgTGVobmlcbiAqIGh0dHA6Ly9zY3JhdGNoZGlzay5jb20vXG4gKlxuICogRGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuICpcbiAqKipcbiAqXG4gKiBBY29ybi5qc1xuICogaHR0cDovL21hcmlqbmhhdmVyYmVrZS5ubC9hY29ybi9cbiAqXG4gKiBBY29ybiBpcyBhIHRpbnksIGZhc3QgSmF2YVNjcmlwdCBwYXJzZXIgd3JpdHRlbiBpbiBKYXZhU2NyaXB0LFxuICogY3JlYXRlZCBieSBNYXJpam4gSGF2ZXJiZWtlIGFuZCByZWxlYXNlZCB1bmRlciBhbiBNSVQgbGljZW5zZS5cbiAqXG4gKi9cblxudmFyIHBhcGVyID0gbmV3IGZ1bmN0aW9uKHVuZGVmaW5lZCkge1xuXG52YXIgQmFzZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGhpZGRlbiA9IC9eKHN0YXRpY3N8ZW51bWVyYWJsZXxiZWFuc3xwcmVzZXJ2ZSkkLyxcblxuXHRcdGZvckVhY2ggPSBbXS5mb3JFYWNoIHx8IGZ1bmN0aW9uKGl0ZXIsIGJpbmQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGl0ZXIuY2FsbChiaW5kLCB0aGlzW2ldLCBpLCB0aGlzKTtcblx0XHR9LFxuXG5cdFx0Zm9ySW4gPSBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRmb3IgKHZhciBpIGluIHRoaXMpXG5cdFx0XHRcdGlmICh0aGlzLmhhc093blByb3BlcnR5KGkpKVxuXHRcdFx0XHRcdGl0ZXIuY2FsbChiaW5kLCB0aGlzW2ldLCBpLCB0aGlzKTtcblx0XHR9LFxuXG5cdFx0Y3JlYXRlID0gT2JqZWN0LmNyZWF0ZSB8fCBmdW5jdGlvbihwcm90bykge1xuXHRcdFx0cmV0dXJuIHsgX19wcm90b19fOiBwcm90byB9O1xuXHRcdH0sXG5cblx0XHRkZXNjcmliZSA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgfHwgZnVuY3Rpb24ob2JqLCBuYW1lKSB7XG5cdFx0XHR2YXIgZ2V0ID0gb2JqLl9fbG9va3VwR2V0dGVyX18gJiYgb2JqLl9fbG9va3VwR2V0dGVyX18obmFtZSk7XG5cdFx0XHRyZXR1cm4gZ2V0XG5cdFx0XHRcdFx0PyB7IGdldDogZ2V0LCBzZXQ6IG9iai5fX2xvb2t1cFNldHRlcl9fKG5hbWUpLFxuXHRcdFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH1cblx0XHRcdFx0XHQ6IG9iai5oYXNPd25Qcm9wZXJ0eShuYW1lKVxuXHRcdFx0XHRcdFx0PyB7IHZhbHVlOiBvYmpbbmFtZV0sIGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSwgd3JpdGFibGU6IHRydWUgfVxuXHRcdFx0XHRcdFx0OiBudWxsO1xuXHRcdH0sXG5cblx0XHRfZGVmaW5lID0gT2JqZWN0LmRlZmluZVByb3BlcnR5IHx8IGZ1bmN0aW9uKG9iaiwgbmFtZSwgZGVzYykge1xuXHRcdFx0aWYgKChkZXNjLmdldCB8fCBkZXNjLnNldCkgJiYgb2JqLl9fZGVmaW5lR2V0dGVyX18pIHtcblx0XHRcdFx0aWYgKGRlc2MuZ2V0KVxuXHRcdFx0XHRcdG9iai5fX2RlZmluZUdldHRlcl9fKG5hbWUsIGRlc2MuZ2V0KTtcblx0XHRcdFx0aWYgKGRlc2Muc2V0KVxuXHRcdFx0XHRcdG9iai5fX2RlZmluZVNldHRlcl9fKG5hbWUsIGRlc2Muc2V0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9ialtuYW1lXSA9IGRlc2MudmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0sXG5cblx0XHRkZWZpbmUgPSBmdW5jdGlvbihvYmosIG5hbWUsIGRlc2MpIHtcblx0XHRcdGRlbGV0ZSBvYmpbbmFtZV07XG5cdFx0XHRyZXR1cm4gX2RlZmluZShvYmosIG5hbWUsIGRlc2MpO1xuXHRcdH07XG5cblx0ZnVuY3Rpb24gaW5qZWN0KGRlc3QsIHNyYywgZW51bWVyYWJsZSwgYmVhbnMsIHByZXNlcnZlKSB7XG5cdFx0dmFyIGJlYW5zTmFtZXMgPSB7fTtcblxuXHRcdGZ1bmN0aW9uIGZpZWxkKG5hbWUsIHZhbCkge1xuXHRcdFx0dmFsID0gdmFsIHx8ICh2YWwgPSBkZXNjcmliZShzcmMsIG5hbWUpKVxuXHRcdFx0XHRcdCYmICh2YWwuZ2V0ID8gdmFsIDogdmFsLnZhbHVlKTtcblx0XHRcdGlmICh0eXBlb2YgdmFsID09PSAnc3RyaW5nJyAmJiB2YWxbMF0gPT09ICcjJylcblx0XHRcdFx0dmFsID0gZGVzdFt2YWwuc3Vic3RyaW5nKDEpXSB8fCB2YWw7XG5cdFx0XHR2YXIgaXNGdW5jID0gdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJyxcblx0XHRcdFx0cmVzID0gdmFsLFxuXHRcdFx0XHRwcmV2ID0gcHJlc2VydmUgfHwgaXNGdW5jICYmICF2YWwuYmFzZVxuXHRcdFx0XHRcdFx0PyAodmFsICYmIHZhbC5nZXQgPyBuYW1lIGluIGRlc3QgOiBkZXN0W25hbWVdKVxuXHRcdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0XHRiZWFuO1xuXHRcdFx0aWYgKCFwcmVzZXJ2ZSB8fCAhcHJldikge1xuXHRcdFx0XHRpZiAoaXNGdW5jICYmIHByZXYpXG5cdFx0XHRcdFx0dmFsLmJhc2UgPSBwcmV2O1xuXHRcdFx0XHRpZiAoaXNGdW5jICYmIGJlYW5zICE9PSBmYWxzZVxuXHRcdFx0XHRcdFx0JiYgKGJlYW4gPSBuYW1lLm1hdGNoKC9eKFtnc11ldHxpcykoKFtBLVpdKSguKikpJC8pKSlcblx0XHRcdFx0XHRiZWFuc05hbWVzW2JlYW5bM10udG9Mb3dlckNhc2UoKSArIGJlYW5bNF1dID0gYmVhblsyXTtcblx0XHRcdFx0aWYgKCFyZXMgfHwgaXNGdW5jIHx8ICFyZXMuZ2V0IHx8IHR5cGVvZiByZXMuZ2V0ICE9PSAnZnVuY3Rpb24nXG5cdFx0XHRcdFx0XHR8fCAhQmFzZS5pc1BsYWluT2JqZWN0KHJlcykpXG5cdFx0XHRcdFx0cmVzID0geyB2YWx1ZTogcmVzLCB3cml0YWJsZTogdHJ1ZSB9O1xuXHRcdFx0XHRpZiAoKGRlc2NyaWJlKGRlc3QsIG5hbWUpXG5cdFx0XHRcdFx0XHR8fCB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KS5jb25maWd1cmFibGUpIHtcblx0XHRcdFx0XHRyZXMuY29uZmlndXJhYmxlID0gdHJ1ZTtcblx0XHRcdFx0XHRyZXMuZW51bWVyYWJsZSA9IGVudW1lcmFibGU7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVmaW5lKGRlc3QsIG5hbWUsIHJlcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzcmMpIHtcblx0XHRcdGZvciAodmFyIG5hbWUgaW4gc3JjKSB7XG5cdFx0XHRcdGlmIChzcmMuaGFzT3duUHJvcGVydHkobmFtZSkgJiYgIWhpZGRlbi50ZXN0KG5hbWUpKVxuXHRcdFx0XHRcdGZpZWxkKG5hbWUpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgbmFtZSBpbiBiZWFuc05hbWVzKSB7XG5cdFx0XHRcdHZhciBwYXJ0ID0gYmVhbnNOYW1lc1tuYW1lXSxcblx0XHRcdFx0XHRzZXQgPSBkZXN0WydzZXQnICsgcGFydF0sXG5cdFx0XHRcdFx0Z2V0ID0gZGVzdFsnZ2V0JyArIHBhcnRdIHx8IHNldCAmJiBkZXN0WydpcycgKyBwYXJ0XTtcblx0XHRcdFx0aWYgKGdldCAmJiAoYmVhbnMgPT09IHRydWUgfHwgZ2V0Lmxlbmd0aCA9PT0gMCkpXG5cdFx0XHRcdFx0ZmllbGQobmFtZSwgeyBnZXQ6IGdldCwgc2V0OiBzZXQgfSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBkZXN0O1xuXHR9XG5cblx0ZnVuY3Rpb24gZWFjaChvYmosIGl0ZXIsIGJpbmQpIHtcblx0XHRpZiAob2JqKVxuXHRcdFx0KCdsZW5ndGgnIGluIG9iaiAmJiAhb2JqLmdldExlbmd0aFxuXHRcdFx0XHRcdCYmIHR5cGVvZiBvYmoubGVuZ3RoID09PSAnbnVtYmVyJ1xuXHRcdFx0XHQ/IGZvckVhY2hcblx0XHRcdFx0OiBmb3JJbikuY2FsbChvYmosIGl0ZXIsIGJpbmQgPSBiaW5kIHx8IG9iaik7XG5cdFx0cmV0dXJuIGJpbmQ7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXQob2JqLCBwcm9wcywgZXhjbHVkZSkge1xuXHRcdGZvciAodmFyIGtleSBpbiBwcm9wcylcblx0XHRcdGlmIChwcm9wcy5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICEoZXhjbHVkZSAmJiBleGNsdWRlW2tleV0pKVxuXHRcdFx0XHRvYmpba2V5XSA9IHByb3BzW2tleV07XG5cdFx0cmV0dXJuIG9iajtcblx0fVxuXG5cdHJldHVybiBpbmplY3QoZnVuY3Rpb24gQmFzZSgpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzZXQodGhpcywgYXJndW1lbnRzW2ldKTtcblx0fSwge1xuXHRcdGluamVjdDogZnVuY3Rpb24oc3JjKSB7XG5cdFx0XHRpZiAoc3JjKSB7XG5cdFx0XHRcdHZhciBzdGF0aWNzID0gc3JjLnN0YXRpY3MgPT09IHRydWUgPyBzcmMgOiBzcmMuc3RhdGljcyxcblx0XHRcdFx0XHRiZWFucyA9IHNyYy5iZWFucyxcblx0XHRcdFx0XHRwcmVzZXJ2ZSA9IHNyYy5wcmVzZXJ2ZTtcblx0XHRcdFx0aWYgKHN0YXRpY3MgIT09IHNyYylcblx0XHRcdFx0XHRpbmplY3QodGhpcy5wcm90b3R5cGUsIHNyYywgc3JjLmVudW1lcmFibGUsIGJlYW5zLCBwcmVzZXJ2ZSk7XG5cdFx0XHRcdGluamVjdCh0aGlzLCBzdGF0aWNzLCB0cnVlLCBiZWFucywgcHJlc2VydmUpO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLmluamVjdChhcmd1bWVudHNbaV0pO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgYmFzZSA9IHRoaXMsXG5cdFx0XHRcdGN0b3IsXG5cdFx0XHRcdHByb3RvO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoY3RvciA9IGFyZ3VtZW50c1tpXS5pbml0aWFsaXplKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y3RvciA9IGN0b3IgfHwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdH07XG5cdFx0XHRwcm90byA9IGN0b3IucHJvdG90eXBlID0gY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcblx0XHRcdGRlZmluZShwcm90bywgJ2NvbnN0cnVjdG9yJyxcblx0XHRcdFx0XHR7IHZhbHVlOiBjdG9yLCB3cml0YWJsZTogdHJ1ZSwgY29uZmlndXJhYmxlOiB0cnVlIH0pO1xuXHRcdFx0aW5qZWN0KGN0b3IsIHRoaXMsIHRydWUpO1xuXHRcdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuaW5qZWN0LmFwcGx5KGN0b3IsIGFyZ3VtZW50cyk7XG5cdFx0XHRjdG9yLmJhc2UgPSBiYXNlO1xuXHRcdFx0cmV0dXJuIGN0b3I7XG5cdFx0fVxuXHR9LCB0cnVlKS5pbmplY3Qoe1xuXHRcdGluamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHNyYyA9IGFyZ3VtZW50c1tpXTtcblx0XHRcdFx0aWYgKHNyYylcblx0XHRcdFx0XHRpbmplY3QodGhpcywgc3JjLCBzcmMuZW51bWVyYWJsZSwgc3JjLmJlYW5zLCBzcmMucHJlc2VydmUpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fSxcblxuXHRcdGV4dGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVzID0gY3JlYXRlKHRoaXMpO1xuXHRcdFx0cmV0dXJuIHJlcy5pbmplY3QuYXBwbHkocmVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRlYWNoOiBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRyZXR1cm4gZWFjaCh0aGlzLCBpdGVyLCBiaW5kKTtcblx0XHR9LFxuXG5cdFx0c2V0OiBmdW5jdGlvbihwcm9wcykge1xuXHRcdFx0cmV0dXJuIHNldCh0aGlzLCBwcm9wcyk7XG5cdFx0fSxcblxuXHRcdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBuZXcgdGhpcy5jb25zdHJ1Y3Rvcih0aGlzKTtcblx0XHR9LFxuXG5cdFx0c3RhdGljczoge1xuXHRcdFx0ZWFjaDogZWFjaCxcblx0XHRcdGNyZWF0ZTogY3JlYXRlLFxuXHRcdFx0ZGVmaW5lOiBkZWZpbmUsXG5cdFx0XHRkZXNjcmliZTogZGVzY3JpYmUsXG5cdFx0XHRzZXQ6IHNldCxcblxuXHRcdFx0Y2xvbmU6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHRyZXR1cm4gc2V0KG5ldyBvYmouY29uc3RydWN0b3IoKSwgb2JqKTtcblx0XHRcdH0sXG5cblx0XHRcdGlzUGxhaW5PYmplY3Q6IGZ1bmN0aW9uKG9iaikge1xuXHRcdFx0XHR2YXIgY3RvciA9IG9iaiAhPSBudWxsICYmIG9iai5jb25zdHJ1Y3Rvcjtcblx0XHRcdFx0cmV0dXJuIGN0b3IgJiYgKGN0b3IgPT09IE9iamVjdCB8fCBjdG9yID09PSBCYXNlXG5cdFx0XHRcdFx0XHR8fCBjdG9yLm5hbWUgPT09ICdPYmplY3QnKTtcblx0XHRcdH0sXG5cblx0XHRcdHBpY2s6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdFx0cmV0dXJuIGEgIT09IHVuZGVmaW5lZCA/IGEgOiBiO1xuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG59O1xuXG5pZiAodHlwZW9mIG1vZHVsZSAhPT0gJ3VuZGVmaW5lZCcpXG5cdG1vZHVsZS5leHBvcnRzID0gQmFzZTtcblxuQmFzZS5pbmplY3Qoe1xuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkICE9IG51bGxcblx0XHRcdD8gICh0aGlzLl9jbGFzcyB8fCAnT2JqZWN0JykgKyAodGhpcy5fbmFtZVxuXHRcdFx0XHQ/IFwiICdcIiArIHRoaXMuX25hbWUgKyBcIidcIlxuXHRcdFx0XHQ6ICcgQCcgKyB0aGlzLl9pZClcblx0XHRcdDogJ3sgJyArIEJhc2UuZWFjaCh0aGlzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdGlmICghL15fLy50ZXN0KGtleSkpIHtcblx0XHRcdFx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblx0XHRcdFx0XHR0aGlzLnB1c2goa2V5ICsgJzogJyArICh0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0XHQ/IEZvcm1hdHRlci5pbnN0YW5jZS5udW1iZXIodmFsdWUpXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ3N0cmluZycgPyBcIidcIiArIHZhbHVlICsgXCInXCIgOiB2YWx1ZSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LCBbXSkuam9pbignLCAnKSArICcgfSc7XG5cdH0sXG5cblx0Z2V0Q2xhc3NOYW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xhc3MgfHwgJyc7XG5cdH0sXG5cblx0ZXhwb3J0SlNPTjogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLmV4cG9ydEpTT04odGhpcywgb3B0aW9ucyk7XG5cdH0sXG5cblx0dG9KU09OOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcyk7XG5cdH0sXG5cblx0X3NldDogZnVuY3Rpb24ocHJvcHMsIGV4Y2x1ZGUsIGRvbnRDaGVjaykge1xuXHRcdGlmIChwcm9wcyAmJiAoZG9udENoZWNrIHx8IEJhc2UuaXNQbGFpbk9iamVjdChwcm9wcykpKSB7XG5cdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKHByb3BzLl9maWx0ZXJpbmcgfHwgcHJvcHMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0aWYgKCEoZXhjbHVkZSAmJiBleGNsdWRlW2tleV0pKSB7XG5cdFx0XHRcdFx0dmFyIHZhbHVlID0gcHJvcHNba2V5XTtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0XHRcdHRoaXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXG5cdFx0ZXhwb3J0czoge1xuXHRcdFx0ZW51bWVyYWJsZTogdHJ1ZVxuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uIGV4dGVuZCgpIHtcblx0XHRcdHZhciByZXMgPSBleHRlbmQuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpLFxuXHRcdFx0XHRuYW1lID0gcmVzLnByb3RvdHlwZS5fY2xhc3M7XG5cdFx0XHRpZiAobmFtZSAmJiAhQmFzZS5leHBvcnRzW25hbWVdKVxuXHRcdFx0XHRCYXNlLmV4cG9ydHNbbmFtZV0gPSByZXM7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uKG9iajEsIG9iajIpIHtcblx0XHRcdGlmIChvYmoxID09PSBvYmoyKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdGlmIChvYmoxICYmIG9iajEuZXF1YWxzKVxuXHRcdFx0XHRyZXR1cm4gb2JqMS5lcXVhbHMob2JqMik7XG5cdFx0XHRpZiAob2JqMiAmJiBvYmoyLmVxdWFscylcblx0XHRcdFx0cmV0dXJuIG9iajIuZXF1YWxzKG9iajEpO1xuXHRcdFx0aWYgKG9iajEgJiYgb2JqMlxuXHRcdFx0XHRcdCYmIHR5cGVvZiBvYmoxID09PSAnb2JqZWN0JyAmJiB0eXBlb2Ygb2JqMiA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkob2JqMSkgJiYgQXJyYXkuaXNBcnJheShvYmoyKSkge1xuXHRcdFx0XHRcdHZhciBsZW5ndGggPSBvYmoxLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAobGVuZ3RoICE9PSBvYmoyLmxlbmd0aClcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR3aGlsZSAobGVuZ3RoLS0pIHtcblx0XHRcdFx0XHRcdGlmICghQmFzZS5lcXVhbHMob2JqMVtsZW5ndGhdLCBvYmoyW2xlbmd0aF0pKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqMSksXG5cdFx0XHRcdFx0XHRsZW5ndGggPSBrZXlzLmxlbmd0aDtcblx0XHRcdFx0XHRpZiAobGVuZ3RoICE9PSBPYmplY3Qua2V5cyhvYmoyKS5sZW5ndGgpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRcdFx0XHR2YXIga2V5ID0ga2V5c1tsZW5ndGhdO1xuXHRcdFx0XHRcdFx0aWYgKCEob2JqMi5oYXNPd25Qcm9wZXJ0eShrZXkpXG5cdFx0XHRcdFx0XHRcdFx0JiYgQmFzZS5lcXVhbHMob2JqMVtrZXldLCBvYmoyW2tleV0pKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9LFxuXG5cdFx0cmVhZDogZnVuY3Rpb24obGlzdCwgc3RhcnQsIG9wdGlvbnMsIGxlbmd0aCkge1xuXHRcdFx0aWYgKHRoaXMgPT09IEJhc2UpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5wZWVrKGxpc3QsIHN0YXJ0KTtcblx0XHRcdFx0bGlzdC5fX2luZGV4Kys7XG5cdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdH1cblx0XHRcdHZhciBwcm90byA9IHRoaXMucHJvdG90eXBlLFxuXHRcdFx0XHRyZWFkSW5kZXggPSBwcm90by5fcmVhZEluZGV4LFxuXHRcdFx0XHRpbmRleCA9IHN0YXJ0IHx8IHJlYWRJbmRleCAmJiBsaXN0Ll9faW5kZXggfHwgMDtcblx0XHRcdGlmICghbGVuZ3RoKVxuXHRcdFx0XHRsZW5ndGggPSBsaXN0Lmxlbmd0aCAtIGluZGV4O1xuXHRcdFx0dmFyIG9iaiA9IGxpc3RbaW5kZXhdO1xuXHRcdFx0aWYgKG9iaiBpbnN0YW5jZW9mIHRoaXNcblx0XHRcdFx0fHwgb3B0aW9ucyAmJiBvcHRpb25zLnJlYWROdWxsICYmIG9iaiA9PSBudWxsICYmIGxlbmd0aCA8PSAxKSB7XG5cdFx0XHRcdGlmIChyZWFkSW5kZXgpXG5cdFx0XHRcdFx0bGlzdC5fX2luZGV4ID0gaW5kZXggKyAxO1xuXHRcdFx0XHRyZXR1cm4gb2JqICYmIG9wdGlvbnMgJiYgb3B0aW9ucy5jbG9uZSA/IG9iai5jbG9uZSgpIDogb2JqO1xuXHRcdFx0fVxuXHRcdFx0b2JqID0gQmFzZS5jcmVhdGUodGhpcy5wcm90b3R5cGUpO1xuXHRcdFx0aWYgKHJlYWRJbmRleClcblx0XHRcdFx0b2JqLl9fcmVhZCA9IHRydWU7XG5cdFx0XHRvYmogPSBvYmouaW5pdGlhbGl6ZS5hcHBseShvYmosIGluZGV4ID4gMCB8fCBsZW5ndGggPCBsaXN0Lmxlbmd0aFxuXHRcdFx0XHQ/IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGxpc3QsIGluZGV4LCBpbmRleCArIGxlbmd0aClcblx0XHRcdFx0OiBsaXN0KSB8fCBvYmo7XG5cdFx0XHRpZiAocmVhZEluZGV4KSB7XG5cdFx0XHRcdGxpc3QuX19pbmRleCA9IGluZGV4ICsgb2JqLl9fcmVhZDtcblx0XHRcdFx0b2JqLl9fcmVhZCA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvYmo7XG5cdFx0fSxcblxuXHRcdHBlZWs6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0KSB7XG5cdFx0XHRyZXR1cm4gbGlzdFtsaXN0Ll9faW5kZXggPSBzdGFydCB8fCBsaXN0Ll9faW5kZXggfHwgMF07XG5cdFx0fSxcblxuXHRcdHJlbWFpbjogZnVuY3Rpb24obGlzdCkge1xuXHRcdFx0cmV0dXJuIGxpc3QubGVuZ3RoIC0gKGxpc3QuX19pbmRleCB8fCAwKTtcblx0XHR9LFxuXG5cdFx0cmVhZEFsbDogZnVuY3Rpb24obGlzdCwgc3RhcnQsIG9wdGlvbnMpIHtcblx0XHRcdHZhciByZXMgPSBbXSxcblx0XHRcdFx0ZW50cnk7XG5cdFx0XHRmb3IgKHZhciBpID0gc3RhcnQgfHwgMCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHJlcy5wdXNoKEFycmF5LmlzQXJyYXkoZW50cnkgPSBsaXN0W2ldKVxuXHRcdFx0XHRcdFx0PyB0aGlzLnJlYWQoZW50cnksIDAsIG9wdGlvbnMpXG5cdFx0XHRcdFx0XHQ6IHRoaXMucmVhZChsaXN0LCBpLCBvcHRpb25zLCAxKSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cblx0XHRyZWFkTmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUsIHN0YXJ0LCBvcHRpb25zLCBsZW5ndGgpIHtcblx0XHRcdHZhciB2YWx1ZSA9IHRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSksXG5cdFx0XHRcdGhhc09iamVjdCA9IHZhbHVlICE9PSB1bmRlZmluZWQ7XG5cdFx0XHRpZiAoaGFzT2JqZWN0KSB7XG5cdFx0XHRcdHZhciBmaWx0ZXJlZCA9IGxpc3QuX2ZpbHRlcmVkO1xuXHRcdFx0XHRpZiAoIWZpbHRlcmVkKSB7XG5cdFx0XHRcdFx0ZmlsdGVyZWQgPSBsaXN0Ll9maWx0ZXJlZCA9IEJhc2UuY3JlYXRlKGxpc3RbMF0pO1xuXHRcdFx0XHRcdGZpbHRlcmVkLl9maWx0ZXJpbmcgPSBsaXN0WzBdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZpbHRlcmVkW25hbWVdID0gdW5kZWZpbmVkO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMucmVhZChoYXNPYmplY3QgPyBbdmFsdWVdIDogbGlzdCwgc3RhcnQsIG9wdGlvbnMsIGxlbmd0aCk7XG5cdFx0fSxcblxuXHRcdGdldE5hbWVkOiBmdW5jdGlvbihsaXN0LCBuYW1lKSB7XG5cdFx0XHR2YXIgYXJnID0gbGlzdFswXTtcblx0XHRcdGlmIChsaXN0Ll9oYXNPYmplY3QgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0bGlzdC5faGFzT2JqZWN0ID0gbGlzdC5sZW5ndGggPT09IDEgJiYgQmFzZS5pc1BsYWluT2JqZWN0KGFyZyk7XG5cdFx0XHRpZiAobGlzdC5faGFzT2JqZWN0KVxuXHRcdFx0XHRyZXR1cm4gbmFtZSA/IGFyZ1tuYW1lXSA6IGxpc3QuX2ZpbHRlcmVkIHx8IGFyZztcblx0XHR9LFxuXG5cdFx0aGFzTmFtZWQ6IGZ1bmN0aW9uKGxpc3QsIG5hbWUpIHtcblx0XHRcdHJldHVybiAhIXRoaXMuZ2V0TmFtZWQobGlzdCwgbmFtZSk7XG5cdFx0fSxcblxuXHRcdGlzUGxhaW5WYWx1ZTogZnVuY3Rpb24ob2JqLCBhc1N0cmluZykge1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNQbGFpbk9iamVjdChvYmopIHx8IEFycmF5LmlzQXJyYXkob2JqKVxuXHRcdFx0XHRcdHx8IGFzU3RyaW5nICYmIHR5cGVvZiBvYmogPT09ICdzdHJpbmcnO1xuXHRcdH0sXG5cblx0XHRzZXJpYWxpemU6IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucywgY29tcGFjdCwgZGljdGlvbmFyeSkge1xuXHRcdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHRcdHZhciByb290ID0gIWRpY3Rpb25hcnksXG5cdFx0XHRcdHJlcztcblx0XHRcdGlmIChyb290KSB7XG5cdFx0XHRcdG9wdGlvbnMuZm9ybWF0dGVyID0gbmV3IEZvcm1hdHRlcihvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0XHRcdGRpY3Rpb25hcnkgPSB7XG5cdFx0XHRcdFx0bGVuZ3RoOiAwLFxuXHRcdFx0XHRcdGRlZmluaXRpb25zOiB7fSxcblx0XHRcdFx0XHRyZWZlcmVuY2VzOiB7fSxcblx0XHRcdFx0XHRhZGQ6IGZ1bmN0aW9uKGl0ZW0sIGNyZWF0ZSkge1xuXHRcdFx0XHRcdFx0dmFyIGlkID0gJyMnICsgaXRlbS5faWQsXG5cdFx0XHRcdFx0XHRcdHJlZiA9IHRoaXMucmVmZXJlbmNlc1tpZF07XG5cdFx0XHRcdFx0XHRpZiAoIXJlZikge1xuXHRcdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCsrO1xuXHRcdFx0XHRcdFx0XHR2YXIgcmVzID0gY3JlYXRlLmNhbGwoaXRlbSksXG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGl0ZW0uX2NsYXNzO1xuXHRcdFx0XHRcdFx0XHRpZiAobmFtZSAmJiByZXNbMF0gIT09IG5hbWUpXG5cdFx0XHRcdFx0XHRcdFx0cmVzLnVuc2hpZnQobmFtZSk7XG5cdFx0XHRcdFx0XHRcdHRoaXMuZGVmaW5pdGlvbnNbaWRdID0gcmVzO1xuXHRcdFx0XHRcdFx0XHRyZWYgPSB0aGlzLnJlZmVyZW5jZXNbaWRdID0gW2lkXTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiByZWY7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0aWYgKG9iaiAmJiBvYmouX3NlcmlhbGl6ZSkge1xuXHRcdFx0XHRyZXMgPSBvYmouX3NlcmlhbGl6ZShvcHRpb25zLCBkaWN0aW9uYXJ5KTtcblx0XHRcdFx0dmFyIG5hbWUgPSBvYmouX2NsYXNzO1xuXHRcdFx0XHRpZiAobmFtZSAmJiAhY29tcGFjdCAmJiAhcmVzLl9jb21wYWN0ICYmIHJlc1swXSAhPT0gbmFtZSlcblx0XHRcdFx0XHRyZXMudW5zaGlmdChuYW1lKTtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShvYmopKSB7XG5cdFx0XHRcdHJlcyA9IFtdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cmVzW2ldID0gQmFzZS5zZXJpYWxpemUob2JqW2ldLCBvcHRpb25zLCBjb21wYWN0LFxuXHRcdFx0XHRcdFx0XHRkaWN0aW9uYXJ5KTtcblx0XHRcdFx0aWYgKGNvbXBhY3QpXG5cdFx0XHRcdFx0cmVzLl9jb21wYWN0ID0gdHJ1ZTtcblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KG9iaikpIHtcblx0XHRcdFx0cmVzID0ge307XG5cdFx0XHRcdHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0XHRcdHJlc1trZXldID0gQmFzZS5zZXJpYWxpemUob2JqW2tleV0sIG9wdGlvbnMsIGNvbXBhY3QsXG5cdFx0XHRcdFx0XHRcdGRpY3Rpb25hcnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInKSB7XG5cdFx0XHRcdHJlcyA9IG9wdGlvbnMuZm9ybWF0dGVyLm51bWJlcihvYmosIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHJlcyA9IG9iajtcblx0XHRcdH1cblx0XHRcdHJldHVybiByb290ICYmIGRpY3Rpb25hcnkubGVuZ3RoID4gMFxuXHRcdFx0XHRcdD8gW1snZGljdGlvbmFyeScsIGRpY3Rpb25hcnkuZGVmaW5pdGlvbnNdLCByZXNdXG5cdFx0XHRcdFx0OiByZXM7XG5cdFx0fSxcblxuXHRcdGRlc2VyaWFsaXplOiBmdW5jdGlvbihqc29uLCBjcmVhdGUsIF9kYXRhLCBfaXNEaWN0aW9uYXJ5KSB7XG5cdFx0XHR2YXIgcmVzID0ganNvbixcblx0XHRcdFx0aXNSb290ID0gIV9kYXRhO1xuXHRcdFx0X2RhdGEgPSBfZGF0YSB8fCB7fTtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGpzb24pKSB7XG5cdFx0XHRcdHZhciB0eXBlID0ganNvblswXSxcblx0XHRcdFx0XHRpc0RpY3Rpb25hcnkgPSB0eXBlID09PSAnZGljdGlvbmFyeSc7XG5cdFx0XHRcdGlmIChqc29uLmxlbmd0aCA9PSAxICYmIC9eIy8udGVzdCh0eXBlKSlcblx0XHRcdFx0XHRyZXR1cm4gX2RhdGEuZGljdGlvbmFyeVt0eXBlXTtcblx0XHRcdFx0dHlwZSA9IEJhc2UuZXhwb3J0c1t0eXBlXTtcblx0XHRcdFx0cmVzID0gW107XG5cdFx0XHRcdGlmIChfaXNEaWN0aW9uYXJ5KVxuXHRcdFx0XHRcdF9kYXRhLmRpY3Rpb25hcnkgPSByZXM7XG5cdFx0XHRcdGZvciAodmFyIGkgPSB0eXBlID8gMSA6IDAsIGwgPSBqc29uLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRyZXMucHVzaChCYXNlLmRlc2VyaWFsaXplKGpzb25baV0sIGNyZWF0ZSwgX2RhdGEsXG5cdFx0XHRcdFx0XHRcdGlzRGljdGlvbmFyeSkpO1xuXHRcdFx0XHRpZiAodHlwZSkge1xuXHRcdFx0XHRcdHZhciBhcmdzID0gcmVzO1xuXHRcdFx0XHRcdGlmIChjcmVhdGUpIHtcblx0XHRcdFx0XHRcdHJlcyA9IGNyZWF0ZSh0eXBlLCBhcmdzKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cmVzID0gQmFzZS5jcmVhdGUodHlwZS5wcm90b3R5cGUpO1xuXHRcdFx0XHRcdFx0dHlwZS5hcHBseShyZXMsIGFyZ3MpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3QoanNvbikpIHtcblx0XHRcdFx0cmVzID0ge307XG5cdFx0XHRcdGlmIChfaXNEaWN0aW9uYXJ5KVxuXHRcdFx0XHRcdF9kYXRhLmRpY3Rpb25hcnkgPSByZXM7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBqc29uKVxuXHRcdFx0XHRcdHJlc1trZXldID0gQmFzZS5kZXNlcmlhbGl6ZShqc29uW2tleV0sIGNyZWF0ZSwgX2RhdGEpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGlzUm9vdCAmJiBqc29uICYmIGpzb24ubGVuZ3RoICYmIGpzb25bMF1bMF0gPT09ICdkaWN0aW9uYXJ5J1xuXHRcdFx0XHRcdD8gcmVzWzFdXG5cdFx0XHRcdFx0OiByZXM7XG5cdFx0fSxcblxuXHRcdGV4cG9ydEpTT046IGZ1bmN0aW9uKG9iaiwgb3B0aW9ucykge1xuXHRcdFx0dmFyIGpzb24gPSBCYXNlLnNlcmlhbGl6ZShvYmosIG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIG9wdGlvbnMgJiYgb3B0aW9ucy5hc1N0cmluZyA9PT0gZmFsc2Vcblx0XHRcdFx0XHQ/IGpzb25cblx0XHRcdFx0XHQ6IEpTT04uc3RyaW5naWZ5KGpzb24pO1xuXHRcdH0sXG5cblx0XHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uLCB0YXJnZXQpIHtcblx0XHRcdHJldHVybiBCYXNlLmRlc2VyaWFsaXplKFxuXHRcdFx0XHRcdHR5cGVvZiBqc29uID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UoanNvbikgOiBqc29uLFxuXHRcdFx0XHRcdGZ1bmN0aW9uKHR5cGUsIGFyZ3MpIHtcblx0XHRcdFx0XHRcdHZhciBvYmogPSB0YXJnZXQgJiYgdGFyZ2V0LmNvbnN0cnVjdG9yID09PSB0eXBlXG5cdFx0XHRcdFx0XHRcdFx0PyB0YXJnZXRcblx0XHRcdFx0XHRcdFx0XHQ6IEJhc2UuY3JlYXRlKHR5cGUucHJvdG90eXBlKSxcblx0XHRcdFx0XHRcdFx0aXNUYXJnZXQgPSBvYmogPT09IHRhcmdldDtcblx0XHRcdFx0XHRcdGlmIChhcmdzLmxlbmd0aCA9PT0gMSAmJiBvYmogaW5zdGFuY2VvZiBJdGVtXG5cdFx0XHRcdFx0XHRcdFx0JiYgKGlzVGFyZ2V0IHx8ICEob2JqIGluc3RhbmNlb2YgTGF5ZXIpKSkge1xuXHRcdFx0XHRcdFx0XHR2YXIgYXJnID0gYXJnc1swXTtcblx0XHRcdFx0XHRcdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdChhcmcpKVxuXHRcdFx0XHRcdFx0XHRcdGFyZy5pbnNlcnQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHR5cGUuYXBwbHkob2JqLCBhcmdzKTtcblx0XHRcdFx0XHRcdGlmIChpc1RhcmdldClcblx0XHRcdFx0XHRcdFx0dGFyZ2V0ID0gbnVsbDtcblx0XHRcdFx0XHRcdHJldHVybiBvYmo7XG5cdFx0XHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHNwbGljZTogZnVuY3Rpb24obGlzdCwgaXRlbXMsIGluZGV4LCByZW1vdmUpIHtcblx0XHRcdHZhciBhbW91bnQgPSBpdGVtcyAmJiBpdGVtcy5sZW5ndGgsXG5cdFx0XHRcdGFwcGVuZCA9IGluZGV4ID09PSB1bmRlZmluZWQ7XG5cdFx0XHRpbmRleCA9IGFwcGVuZCA/IGxpc3QubGVuZ3RoIDogaW5kZXg7XG5cdFx0XHRpZiAoaW5kZXggPiBsaXN0Lmxlbmd0aClcblx0XHRcdFx0aW5kZXggPSBsaXN0Lmxlbmd0aDtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspXG5cdFx0XHRcdGl0ZW1zW2ldLl9pbmRleCA9IGluZGV4ICsgaTtcblx0XHRcdGlmIChhcHBlbmQpIHtcblx0XHRcdFx0bGlzdC5wdXNoLmFwcGx5KGxpc3QsIGl0ZW1zKTtcblx0XHRcdFx0cmV0dXJuIFtdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGFyZ3MgPSBbaW5kZXgsIHJlbW92ZV07XG5cdFx0XHRcdGlmIChpdGVtcylcblx0XHRcdFx0XHRhcmdzLnB1c2guYXBwbHkoYXJncywgaXRlbXMpO1xuXHRcdFx0XHR2YXIgcmVtb3ZlZCA9IGxpc3Quc3BsaWNlLmFwcGx5KGxpc3QsIGFyZ3MpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHJlbW92ZWQubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHJlbW92ZWRbaV0uX2luZGV4ID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRsaXN0W2ldLl9pbmRleCA9IGk7XG5cdFx0XHRcdHJldHVybiByZW1vdmVkO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjYXBpdGFsaXplOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvXFxiW2Etel0vZywgZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRcdFx0cmV0dXJuIG1hdGNoLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0Y2FtZWxpemU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8tKC4pL2csIGZ1bmN0aW9uKGFsbCwgY2hyKSB7XG5cdFx0XHRcdHJldHVybiBjaHIudG9VcHBlckNhc2UoKTtcblx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRoeXBoZW5hdGU6IGZ1bmN0aW9uKHN0cikge1xuXHRcdFx0cmV0dXJuIHN0ci5yZXBsYWNlKC8oW2Etel0pKFtBLVpdKS9nLCAnJDEtJDInKS50b0xvd2VyQ2FzZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBFbWl0dGVyID0ge1xuXHRvbjogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdEJhc2UuZWFjaCh0eXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdHRoaXMub24oa2V5LCB2YWx1ZSk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHR5cGVzID0gdGhpcy5fZXZlbnRUeXBlcyxcblx0XHRcdFx0ZW50cnkgPSB0eXBlcyAmJiB0eXBlc1t0eXBlXSxcblx0XHRcdFx0aGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgPSB0aGlzLl9jYWxsYmFja3MgfHwge307XG5cdFx0XHRoYW5kbGVycyA9IGhhbmRsZXJzW3R5cGVdID0gaGFuZGxlcnNbdHlwZV0gfHwgW107XG5cdFx0XHRpZiAoaGFuZGxlcnMuaW5kZXhPZihmdW5jKSA9PT0gLTEpIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaChmdW5jKTtcblx0XHRcdFx0aWYgKGVudHJ5ICYmIGVudHJ5Lmluc3RhbGwgJiYgaGFuZGxlcnMubGVuZ3RoID09PSAxKVxuXHRcdFx0XHRcdGVudHJ5Lmluc3RhbGwuY2FsbCh0aGlzLCB0eXBlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0b2ZmOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG5cdFx0aWYgKHR5cGVvZiB0eXBlICE9PSAnc3RyaW5nJykge1xuXHRcdFx0QmFzZS5lYWNoKHR5cGUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHRcdFx0dGhpcy5vZmYoa2V5LCB2YWx1ZSk7XG5cdFx0XHR9LCB0aGlzKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHR5cGVzID0gdGhpcy5fZXZlbnRUeXBlcyxcblx0XHRcdGVudHJ5ID0gdHlwZXMgJiYgdHlwZXNbdHlwZV0sXG5cdFx0XHRoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV0sXG5cdFx0XHRpbmRleDtcblx0XHRpZiAoaGFuZGxlcnMpIHtcblx0XHRcdGlmICghZnVuYyB8fCAoaW5kZXggPSBoYW5kbGVycy5pbmRleE9mKGZ1bmMpKSAhPT0gLTFcblx0XHRcdFx0XHQmJiBoYW5kbGVycy5sZW5ndGggPT09IDEpIHtcblx0XHRcdFx0aWYgKGVudHJ5ICYmIGVudHJ5LnVuaW5zdGFsbClcblx0XHRcdFx0XHRlbnRyeS51bmluc3RhbGwuY2FsbCh0aGlzLCB0eXBlKTtcblx0XHRcdFx0ZGVsZXRlIHRoaXMuX2NhbGxiYWNrc1t0eXBlXTtcblx0XHRcdH0gZWxzZSBpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdG9uY2U6IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRyZXR1cm4gdGhpcy5vbih0eXBlLCBmdW5jdGlvbigpIHtcblx0XHRcdGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRcdHRoaXMub2ZmKHR5cGUsIGZ1bmMpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdGVtaXQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50KSB7XG5cdFx0dmFyIGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXTtcblx0XHRpZiAoIWhhbmRsZXJzKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBhcmdzID0gW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuXHRcdGhhbmRsZXJzID0gaGFuZGxlcnMuc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGhhbmRsZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGhhbmRsZXJzW2ldLmFwcGx5KHRoaXMsIGFyZ3MpID09PSBmYWxzZSkge1xuXHRcdFx0XHRpZiAoZXZlbnQgJiYgZXZlbnQuc3RvcClcblx0XHRcdFx0XHRldmVudC5zdG9wKCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRyZXNwb25kczogZnVuY3Rpb24odHlwZSkge1xuXHRcdHJldHVybiAhISh0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdKTtcblx0fSxcblxuXHRhdHRhY2g6ICcjb24nLFxuXHRkZXRhY2g6ICcjb2ZmJyxcblx0ZmlyZTogJyNlbWl0JyxcblxuXHRfaW5zdGFsbEV2ZW50czogZnVuY3Rpb24oaW5zdGFsbCkge1xuXHRcdHZhciBoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyxcblx0XHRcdGtleSA9IGluc3RhbGwgPyAnaW5zdGFsbCcgOiAndW5pbnN0YWxsJztcblx0XHRmb3IgKHZhciB0eXBlIGluIGhhbmRsZXJzKSB7XG5cdFx0XHRpZiAoaGFuZGxlcnNbdHlwZV0ubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR2YXIgdHlwZXMgPSB0aGlzLl9ldmVudFR5cGVzLFxuXHRcdFx0XHRcdGVudHJ5ID0gdHlwZXMgJiYgdHlwZXNbdHlwZV0sXG5cdFx0XHRcdFx0ZnVuYyA9IGVudHJ5ICYmIGVudHJ5W2tleV07XG5cdFx0XHRcdGlmIChmdW5jKVxuXHRcdFx0XHRcdGZ1bmMuY2FsbCh0aGlzLCB0eXBlKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdGluamVjdDogZnVuY3Rpb24gaW5qZWN0KHNyYykge1xuXHRcdFx0dmFyIGV2ZW50cyA9IHNyYy5fZXZlbnRzO1xuXHRcdFx0aWYgKGV2ZW50cykge1xuXHRcdFx0XHR2YXIgdHlwZXMgPSB7fTtcblx0XHRcdFx0QmFzZS5lYWNoKGV2ZW50cywgZnVuY3Rpb24oZW50cnksIGtleSkge1xuXHRcdFx0XHRcdHZhciBpc1N0cmluZyA9IHR5cGVvZiBlbnRyeSA9PT0gJ3N0cmluZycsXG5cdFx0XHRcdFx0XHRuYW1lID0gaXNTdHJpbmcgPyBlbnRyeSA6IGtleSxcblx0XHRcdFx0XHRcdHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRcdFx0XHR0eXBlID0gbmFtZS5zdWJzdHJpbmcoMikudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHR0eXBlc1t0eXBlXSA9IGlzU3RyaW5nID8ge30gOiBlbnRyeTtcblx0XHRcdFx0XHRuYW1lID0gJ18nICsgbmFtZTtcblx0XHRcdFx0XHRzcmNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoaXNbbmFtZV07XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRzcmNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKGZ1bmMpIHtcblx0XHRcdFx0XHRcdHZhciBwcmV2ID0gdGhpc1tuYW1lXTtcblx0XHRcdFx0XHRcdGlmIChwcmV2KVxuXHRcdFx0XHRcdFx0XHR0aGlzLm9mZih0eXBlLCBwcmV2KTtcblx0XHRcdFx0XHRcdGlmIChmdW5jKVxuXHRcdFx0XHRcdFx0XHR0aGlzLm9uKHR5cGUsIGZ1bmMpO1xuXHRcdFx0XHRcdFx0dGhpc1tuYW1lXSA9IGZ1bmM7XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0fSk7XG5cdFx0XHRcdHNyYy5fZXZlbnRUeXBlcyA9IHR5cGVzO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGluamVjdC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9XG59O1xuXG52YXIgUGFwZXJTY29wZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGFwZXJTY29wZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUGFwZXJTY29wZSgpIHtcblx0XHRwYXBlciA9IHRoaXM7XG5cdFx0dGhpcy5zZXR0aW5ncyA9IG5ldyBCYXNlKHtcblx0XHRcdGFwcGx5TWF0cml4OiB0cnVlLFxuXHRcdFx0aGFuZGxlU2l6ZTogNCxcblx0XHRcdGhpdFRvbGVyYW5jZTogMFxuXHRcdH0pO1xuXHRcdHRoaXMucHJvamVjdCA9IG51bGw7XG5cdFx0dGhpcy5wcm9qZWN0cyA9IFtdO1xuXHRcdHRoaXMudG9vbHMgPSBbXTtcblx0XHR0aGlzLnBhbGV0dGVzID0gW107XG5cdFx0dGhpcy5faWQgPSBQYXBlclNjb3BlLl9pZCsrO1xuXHRcdFBhcGVyU2NvcGUuX3Njb3Blc1t0aGlzLl9pZF0gPSB0aGlzO1xuXHRcdHZhciBwcm90byA9IFBhcGVyU2NvcGUucHJvdG90eXBlO1xuXHRcdGlmICghdGhpcy5zdXBwb3J0KSB7XG5cdFx0XHR2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcblx0XHRcdHByb3RvLnN1cHBvcnQgPSB7XG5cdFx0XHRcdG5hdGl2ZURhc2g6ICdzZXRMaW5lRGFzaCcgaW4gY3R4IHx8ICdtb3pEYXNoJyBpbiBjdHgsXG5cdFx0XHRcdG5hdGl2ZUJsZW5kTW9kZXM6IEJsZW5kTW9kZS5uYXRpdmVNb2Rlc1xuXHRcdFx0fTtcblx0XHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblx0XHR9XG5cblx0XHRpZiAoIXRoaXMuYnJvd3Nlcikge1xuXHRcdFx0dmFyIGFnZW50ID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0XHRwbGF0Zm9ybSA9ICgvKHdpbikvLmV4ZWMoYWdlbnQpXG5cdFx0XHRcdFx0XHR8fCAvKG1hYykvLmV4ZWMoYWdlbnQpXG5cdFx0XHRcdFx0XHR8fCAvKGxpbnV4KS8uZXhlYyhhZ2VudClcblx0XHRcdFx0XHRcdHx8IFtdKVswXSxcblx0XHRcdFx0YnJvd3NlciA9IHByb3RvLmJyb3dzZXIgPSB7IHBsYXRmb3JtOiBwbGF0Zm9ybSB9O1xuXHRcdFx0aWYgKHBsYXRmb3JtKVxuXHRcdFx0XHRicm93c2VyW3BsYXRmb3JtXSA9IHRydWU7XG5cdFx0XHRhZ2VudC5yZXBsYWNlKFxuXHRcdFx0XHQvKG9wZXJhfGNocm9tZXxzYWZhcml8d2Via2l0fGZpcmVmb3h8bXNpZXx0cmlkZW50fGF0b20pXFwvP1xccyooWy5cXGRdKykoPzouKnZlcnNpb25cXC8oWy5cXGRdKykpPyg/Oi4qcnZcXDooWy5cXGRdKykpPy9nLFxuXHRcdFx0XHRmdW5jdGlvbihhbGwsIG4sIHYxLCB2MiwgcnYpIHtcblx0XHRcdFx0XHRpZiAoIWJyb3dzZXIuY2hyb21lKSB7XG5cdFx0XHRcdFx0XHR2YXIgdiA9IG4gPT09ICdvcGVyYScgPyB2MiA6IHYxO1xuXHRcdFx0XHRcdFx0aWYgKG4gPT09ICd0cmlkZW50Jykge1xuXHRcdFx0XHRcdFx0XHR2ID0gcnY7XG5cdFx0XHRcdFx0XHRcdG4gPSAnbXNpZSc7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRicm93c2VyLnZlcnNpb24gPSB2O1xuXHRcdFx0XHRcdFx0YnJvd3Nlci52ZXJzaW9uTnVtYmVyID0gcGFyc2VGbG9hdCh2KTtcblx0XHRcdFx0XHRcdGJyb3dzZXIubmFtZSA9IG47XG5cdFx0XHRcdFx0XHRicm93c2VyW25dID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdCk7XG5cdFx0XHRpZiAoYnJvd3Nlci5jaHJvbWUpXG5cdFx0XHRcdGRlbGV0ZSBicm93c2VyLndlYmtpdDtcblx0XHRcdGlmIChicm93c2VyLmF0b20pXG5cdFx0XHRcdGRlbGV0ZSBicm93c2VyLmNocm9tZTtcblx0XHR9XG5cdH0sXG5cblx0dmVyc2lvbjogXCIwLjkuMjVcIixcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wcm9qZWN0ICYmIHRoaXMucHJvamVjdC5nZXRWaWV3KCk7XG5cdH0sXG5cblx0Z2V0UGFwZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGV4ZWN1dGU6IGZ1bmN0aW9uKGNvZGUsIHVybCwgb3B0aW9ucykge1xuXHRcdHBhcGVyLlBhcGVyU2NyaXB0LmV4ZWN1dGUoY29kZSwgdGhpcywgdXJsLCBvcHRpb25zKTtcblx0XHRWaWV3LnVwZGF0ZUZvY3VzKCk7XG5cdH0sXG5cblx0aW5zdGFsbDogZnVuY3Rpb24oc2NvcGUpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0QmFzZS5lYWNoKFsncHJvamVjdCcsICd2aWV3JywgJ3Rvb2wnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRCYXNlLmRlZmluZShzY29wZSwga2V5LCB7XG5cdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZSxcblx0XHRcdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhhdFtrZXldO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9KTtcblx0XHRmb3IgKHZhciBrZXkgaW4gdGhpcylcblx0XHRcdGlmICghL15fLy50ZXN0KGtleSkgJiYgdGhpc1trZXldKVxuXHRcdFx0XHRzY29wZVtrZXldID0gdGhpc1trZXldO1xuXHR9LFxuXG5cdHNldHVwOiBmdW5jdGlvbihlbGVtZW50KSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHRcdHRoaXMucHJvamVjdCA9IG5ldyBQcm9qZWN0KGVsZW1lbnQpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXM7XG5cdH0sXG5cblx0Y2xlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLnByb2plY3RzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dGhpcy5wcm9qZWN0c1tpXS5yZW1vdmUoKTtcblx0XHRmb3IgKHZhciBpID0gdGhpcy50b29scy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMudG9vbHNbaV0ucmVtb3ZlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMucGFsZXR0ZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0aGlzLnBhbGV0dGVzW2ldLnJlbW92ZSgpO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5jbGVhcigpO1xuXHRcdGRlbGV0ZSBQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdO1xuXHR9LFxuXG5cdHN0YXRpY3M6IG5ldyBmdW5jdGlvbigpIHtcblx0XHRmdW5jdGlvbiBoYW5kbGVBdHRyaWJ1dGUobmFtZSkge1xuXHRcdFx0bmFtZSArPSAnQXR0cmlidXRlJztcblx0XHRcdHJldHVybiBmdW5jdGlvbihlbCwgYXR0cikge1xuXHRcdFx0XHRyZXR1cm4gZWxbbmFtZV0oYXR0cikgfHwgZWxbbmFtZV0oJ2RhdGEtcGFwZXItJyArIGF0dHIpO1xuXHRcdFx0fTtcblx0XHR9XG5cblx0XHRyZXR1cm4ge1xuXHRcdFx0X3Njb3Blczoge30sXG5cdFx0XHRfaWQ6IDAsXG5cblx0XHRcdGdldDogZnVuY3Rpb24oaWQpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3Njb3Blc1tpZF0gfHwgbnVsbDtcblx0XHRcdH0sXG5cblx0XHRcdGdldEF0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdnZXQnKSxcblx0XHRcdGhhc0F0dHJpYnV0ZTogaGFuZGxlQXR0cmlidXRlKCdoYXMnKVxuXHRcdH07XG5cdH1cbn0pO1xuXG52YXIgUGFwZXJTY29wZUl0ZW0gPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24oYWN0aXZhdGUpIHtcblx0XHR0aGlzLl9zY29wZSA9IHBhcGVyO1xuXHRcdHRoaXMuX2luZGV4ID0gdGhpcy5fc2NvcGVbdGhpcy5fbGlzdF0ucHVzaCh0aGlzKSAtIDE7XG5cdFx0aWYgKGFjdGl2YXRlIHx8ICF0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdKVxuXHRcdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3Njb3BlKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciBwcmV2ID0gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXTtcblx0XHRpZiAocHJldiAmJiBwcmV2ICE9PSB0aGlzKVxuXHRcdFx0cHJldi5lbWl0KCdkZWFjdGl2YXRlJyk7XG5cdFx0dGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9IHRoaXM7XG5cdFx0dGhpcy5lbWl0KCdhY3RpdmF0ZScsIHByZXYpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGlzQWN0aXZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSA9PT0gdGhpcztcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9pbmRleCA9PSBudWxsKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdEJhc2Uuc3BsaWNlKHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLCBudWxsLCB0aGlzLl9pbmRleCwgMSk7XG5cdFx0aWYgKHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT0gdGhpcylcblx0XHRcdHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSBudWxsO1xuXHRcdHRoaXMuX3Njb3BlID0gbnVsbDtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSk7XG5cbnZhciBGb3JtYXR0ZXIgPSBCYXNlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHByZWNpc2lvbikge1xuXHRcdHRoaXMucHJlY2lzaW9uID0gcHJlY2lzaW9uIHx8IDU7XG5cdFx0dGhpcy5tdWx0aXBsaWVyID0gTWF0aC5wb3coMTAsIHRoaXMucHJlY2lzaW9uKTtcblx0fSxcblxuXHRudW1iZXI6IGZ1bmN0aW9uKHZhbCkge1xuXHRcdHJldHVybiBNYXRoLnJvdW5kKHZhbCAqIHRoaXMubXVsdGlwbGllcikgLyB0aGlzLm11bHRpcGxpZXI7XG5cdH0sXG5cblx0cGFpcjogZnVuY3Rpb24odmFsMSwgdmFsMiwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbDEpICsgKHNlcGFyYXRvciB8fCAnLCcpICsgdGhpcy5udW1iZXIodmFsMik7XG5cdH0sXG5cblx0cG9pbnQ6IGZ1bmN0aW9uKHZhbCwgc2VwYXJhdG9yKSB7XG5cdFx0cmV0dXJuIHRoaXMubnVtYmVyKHZhbC54KSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMubnVtYmVyKHZhbC55KTtcblx0fSxcblxuXHRzaXplOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwud2lkdGgpICsgKHNlcGFyYXRvciB8fCAnLCcpXG5cdFx0XHRcdCsgdGhpcy5udW1iZXIodmFsLmhlaWdodCk7XG5cdH0sXG5cblx0cmVjdGFuZ2xlOiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLnBvaW50KHZhbCwgc2VwYXJhdG9yKSArIChzZXBhcmF0b3IgfHwgJywnKVxuXHRcdFx0XHQrIHRoaXMuc2l6ZSh2YWwsIHNlcGFyYXRvcik7XG5cdH1cbn0pO1xuXG5Gb3JtYXR0ZXIuaW5zdGFuY2UgPSBuZXcgRm9ybWF0dGVyKCk7XG5cbnZhciBOdW1lcmljYWwgPSBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGFic2Npc3NhcyA9IFtcblx0XHRbICAwLjU3NzM1MDI2OTE4OTYyNTc2NDUwOTE0ODhdLFxuXHRcdFswLDAuNzc0NTk2NjY5MjQxNDgzMzc3MDM1ODUzMV0sXG5cdFx0WyAgMC4zMzk5ODEwNDM1ODQ4NTYyNjQ4MDI2NjU4LDAuODYxMTM2MzExNTk0MDUyNTc1MjIzOTQ2NV0sXG5cdFx0WzAsMC41Mzg0NjkzMTAxMDU2ODMwOTEwMzYzMTQ0LDAuOTA2MTc5ODQ1OTM4NjYzOTkyNzk3NjI2OV0sXG5cdFx0WyAgMC4yMzg2MTkxODYwODMxOTY5MDg2MzA1MDE3LDAuNjYxMjA5Mzg2NDY2MjY0NTEzNjYxMzk5NiwwLjkzMjQ2OTUxNDIwMzE1MjAyNzgxMjMwMTZdLFxuXHRcdFswLDAuNDA1ODQ1MTUxMzc3Mzk3MTY2OTA2NjA2NCwwLjc0MTUzMTE4NTU5OTM5NDQzOTg2Mzg2NDgsMC45NDkxMDc5MTIzNDI3NTg1MjQ1MjYxODk3XSxcblx0XHRbICAwLjE4MzQzNDY0MjQ5NTY0OTgwNDkzOTQ3NjEsMC41MjU1MzI0MDk5MTYzMjg5ODU4MTc3MzkwLDAuNzk2NjY2NDc3NDEzNjI2NzM5NTkxNTUzOSwwLjk2MDI4OTg1NjQ5NzUzNjIzMTY4MzU2MDldLFxuXHRcdFswLDAuMzI0MjUzNDIzNDAzODA4OTI5MDM4NTM4MCwwLjYxMzM3MTQzMjcwMDU5MDM5NzMwODcwMjAsMC44MzYwMzExMDczMjY2MzU3OTQyOTk0Mjk4LDAuOTY4MTYwMjM5NTA3NjI2MDg5ODM1NTc2Ml0sXG5cdFx0WyAgMC4xNDg4NzQzMzg5ODE2MzEyMTA4ODQ4MjYwLDAuNDMzMzk1Mzk0MTI5MjQ3MTkwNzk5MjY1OSwwLjY3OTQwOTU2ODI5OTAyNDQwNjIzNDMyNzQsMC44NjUwNjMzNjY2ODg5ODQ1MTA3MzIwOTY3LDAuOTczOTA2NTI4NTE3MTcxNzIwMDc3OTY0MF0sXG5cdFx0WzAsMC4yNjk1NDMxNTU5NTIzNDQ5NzIzMzE1MzIwLDAuNTE5MDk2MTI5MjA2ODExODE1OTI1NzI1NywwLjczMDE1MjAwNTU3NDA0OTMyNDA5MzQxNjMsMC44ODcwNjI1OTk3NjgwOTUyOTkwNzUxNTc4LDAuOTc4MjI4NjU4MTQ2MDU2OTkyODAzOTM4MF0sXG5cdFx0WyAgMC4xMjUyMzM0MDg1MTE0Njg5MTU0NzI0NDE0LDAuMzY3ODMxNDk4OTk4MTgwMTkzNzUyNjkxNSwwLjU4NzMxNzk1NDI4NjYxNzQ0NzI5NjcwMjQsMC43Njk5MDI2NzQxOTQzMDQ2ODcwMzY4OTM4LDAuOTA0MTE3MjU2MzcwNDc0ODU2Njc4NDY1OSwwLjk4MTU2MDYzNDI0NjcxOTI1MDY5MDU0OTFdLFxuXHRcdFswLDAuMjMwNDU4MzE1OTU1MTM0Nzk0MDY1NTI4MSwwLjQ0ODQ5Mjc1MTAzNjQ0Njg1Mjg3NzkxMjksMC42NDIzNDkzMzk0NDAzNDAyMjA2NDM5ODQ2LDAuODAxNTc4MDkwNzMzMzA5OTEyNzk0MjA2NSwwLjkxNzU5ODM5OTIyMjk3Nzk2NTIwNjU0NzgsMC45ODQxODMwNTQ3MTg1ODgxNDk0NzI4Mjk0XSxcblx0XHRbICAwLjEwODA1NDk0ODcwNzM0MzY2MjA2NjI0NDcsMC4zMTkxMTIzNjg5Mjc4ODk3NjA0MzU2NzE4LDAuNTE1MjQ4NjM2MzU4MTU0MDkxOTY1MjkwNywwLjY4NzI5MjkwNDgxMTY4NTQ3MDE0ODAxOTgsMC44MjcyMDEzMTUwNjk3NjQ5OTMxODk3OTQ3LDAuOTI4NDM0ODgzNjYzNTczNTE3MzM2MzkxMSwwLjk4NjI4MzgwODY5NjgxMjMzODg0MTU5NzNdLFxuXHRcdFswLDAuMjAxMTk0MDkzOTk3NDM0NTIyMzAwNjI4MywwLjM5NDE1MTM0NzA3NzU2MzM2OTg5NzIwNzQsMC41NzA5NzIxNzI2MDg1Mzg4NDc1MzcyMjY3LDAuNzI0NDE3NzMxMzYwMTcwMDQ3NDE2MTg2MSwwLjg0ODIwNjU4MzQxMDQyNzIxNjIwMDY0ODMsMC45MzcyNzMzOTI0MDA3MDU5MDQzMDc3NTg5LDAuOTg3OTkyNTE4MDIwNDg1NDI4NDg5NTY1N10sXG5cdFx0WyAgMC4wOTUwMTI1MDk4Mzc2Mzc0NDAxODUzMTkzLDAuMjgxNjAzNTUwNzc5MjU4OTEzMjMwNDYwNSwwLjQ1ODAxNjc3NzY1NzIyNzM4NjM0MjQxOTQsMC42MTc4NzYyNDQ0MDI2NDM3NDg0NDY2NzE4LDAuNzU1NDA0NDA4MzU1MDAzMDMzODk1MTAxMiwwLjg2NTYzMTIwMjM4NzgzMTc0Mzg4MDQ2NzksMC45NDQ1NzUwMjMwNzMyMzI1NzYwNzc5ODg0LDAuOTg5NDAwOTM0OTkxNjQ5OTMyNTk2MTU0Ml1cblx0XTtcblxuXHR2YXIgd2VpZ2h0cyA9IFtcblx0XHRbMV0sXG5cdFx0WzAuODg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwwLjU1NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTZdLFxuXHRcdFswLjY1MjE0NTE1NDg2MjU0NjE0MjYyNjkzNjEsMC4zNDc4NTQ4NDUxMzc0NTM4NTczNzMwNjM5XSxcblx0XHRbMC41Njg4ODg4ODg4ODg4ODg4ODg4ODg4ODg5LDAuNDc4NjI4NjcwNDk5MzY2NDY4MDQxMjkxNSwwLjIzNjkyNjg4NTA1NjE4OTA4NzUxNDI2NDBdLFxuXHRcdFswLjQ2NzkxMzkzNDU3MjY5MTA0NzM4OTg3MDMsMC4zNjA3NjE1NzMwNDgxMzg2MDc1Njk4MzM1LDAuMTcxMzI0NDkyMzc5MTcwMzQ1MDQwMjk2MV0sXG5cdFx0WzAuNDE3OTU5MTgzNjczNDY5Mzg3NzU1MTAyMCwwLjM4MTgzMDA1MDUwNTExODk0NDk1MDM2OTgsMC4yNzk3MDUzOTE0ODkyNzY2Njc5MDE0Njc4LDAuMTI5NDg0OTY2MTY4ODY5NjkzMjcwNjExNF0sXG5cdFx0WzAuMzYyNjgzNzgzMzc4MzYxOTgyOTY1MTUwNCwwLjMxMzcwNjY0NTg3Nzg4NzI4NzMzNzk2MjIsMC4yMjIzODEwMzQ0NTMzNzQ0NzA1NDQzNTYwLDAuMTAxMjI4NTM2MjkwMzc2MjU5MTUyNTMxNF0sXG5cdFx0WzAuMzMwMjM5MzU1MDAxMjU5NzYzMTY0NTI1MSwwLjMxMjM0NzA3NzA0MDAwMjg0MDA2ODYzMDQsMC4yNjA2MTA2OTY0MDI5MzU0NjIzMTg3NDI5LDAuMTgwNjQ4MTYwNjk0ODU3NDA0MDU4NDcyMCwwLjA4MTI3NDM4ODM2MTU3NDQxMTk3MTg5MjJdLFxuXHRcdFswLjI5NTUyNDIyNDcxNDc1Mjg3MDE3Mzg5MzAsMC4yNjkyNjY3MTkzMDk5OTYzNTUwOTEyMjY5LDAuMjE5MDg2MzYyNTE1OTgyMDQzOTk1NTM0OSwwLjE0OTQ1MTM0OTE1MDU4MDU5MzE0NTc3NjMsMC4wNjY2NzEzNDQzMDg2ODgxMzc1OTM1Njg4XSxcblx0XHRbMC4yNzI5MjUwODY3Nzc5MDA2MzA3MTQ0ODM1LDAuMjYyODA0NTQ0NTEwMjQ2NjYyMTgwNjg4OSwwLjIzMzE5Mzc2NDU5MTk5MDQ3OTkxODUyMzcsMC4xODYyOTAyMTA5Mjc3MzQyNTE0MjYwOTc2LDAuMTI1NTgwMzY5NDY0OTA0NjI0NjM0Njk0MywwLjA1NTY2ODU2NzExNjE3MzY2NjQ4Mjc1MzddLFxuXHRcdFswLjI0OTE0NzA0NTgxMzQwMjc4NTAwMDU2MjQsMC4yMzM0OTI1MzY1MzgzNTQ4MDg3NjA4NDk5LDAuMjAzMTY3NDI2NzIzMDY1OTIxNzQ5MDY0NSwwLjE2MDA3ODMyODU0MzM0NjIyNjMzNDY1MjUsMC4xMDY5MzkzMjU5OTUzMTg0MzA5NjAyNTQ3LDAuMDQ3MTc1MzM2Mzg2NTExODI3MTk0NjE2MF0sXG5cdFx0WzAuMjMyNTUxNTUzMjMwODczOTEwMTk0NTg5NSwwLjIyNjI4MzE4MDI2Mjg5NzIzODQxMjA5MDIsMC4yMDc4MTYwNDc1MzY4ODg1MDIzMTI1MjMyLDAuMTc4MTQ1OTgwNzYxOTQ1NzM4MjgwMDQ2NywwLjEzODg3MzUxMDIxOTc4NzIzODQ2MzYwMTgsMC4wOTIxMjE0OTk4Mzc3Mjg0NDc5MTQ0MjE4LDAuMDQwNDg0MDA0NzY1MzE1ODc5NTIwMDIxNl0sXG5cdFx0WzAuMjE1MjYzODUzNDYzMTU3NzkwMTk1ODc2NCwwLjIwNTE5ODQ2MzcyMTI5NTYwMzk2NTkyNDEsMC4xODU1MzgzOTc0Nzc5Mzc4MTM3NDE3MTY2LDAuMTU3MjAzMTY3MTU4MTkzNTM0NTY5NjAxOSwwLjEyMTUxODU3MDY4NzkwMzE4NDY4OTQxNDgsMC4wODAxNTgwODcxNTk3NjAyMDk4MDU2MzMzLDAuMDM1MTE5NDYwMzMxNzUxODYzMDMxODMyOV0sXG5cdFx0WzAuMjAyNTc4MjQxOTI1NTYxMjcyODgwNjIwMiwwLjE5ODQzMTQ4NTMyNzExMTU3NjQ1NjExODMsMC4xODYxNjEwMDAwMTU1NjIyMTEwMjY4MDA2LDAuMTY2MjY5MjA1ODE2OTkzOTMzNTUzMjAwOSwwLjEzOTU3MDY3NzkyNjE1NDMxNDQ0NzgwNDgsMC4xMDcxNTkyMjA0NjcxNzE5MzUwMTE4Njk1LDAuMDcwMzY2MDQ3NDg4MTA4MTI0NzA5MjY3NCwwLjAzMDc1MzI0MTk5NjExNzI2ODM1NDYyODRdLFxuXHRcdFswLjE4OTQ1MDYxMDQ1NTA2ODQ5NjI4NTM5NjcsMC4xODI2MDM0MTUwNDQ5MjM1ODg4NjY3NjM3LDAuMTY5MTU2NTE5Mzk1MDAyNTM4MTg5MzEyMSwwLjE0OTU5NTk4ODgxNjU3NjczMjA4MTUwMTcsMC4xMjQ2Mjg5NzEyNTU1MzM4NzIwNTI0NzYzLDAuMDk1MTU4NTExNjgyNDkyNzg0ODA5OTI1MSwwLjA2MjI1MzUyMzkzODY0Nzg5Mjg2Mjg0MzgsMC4wMjcxNTI0NTk0MTE3NTQwOTQ4NTE3ODA2XVxuXHRdO1xuXG5cdHZhciBhYnMgPSBNYXRoLmFicyxcblx0XHRzcXJ0ID0gTWF0aC5zcXJ0LFxuXHRcdHBvdyA9IE1hdGgucG93LFxuXHRcdEVQU0lMT04gPSAxZS0xMixcblx0XHRNQUNISU5FX0VQU0lMT04gPSAxLjEyZS0xNjtcblxuXHRmdW5jdGlvbiBjbGlwKHZhbHVlLCBtaW4sIG1heCkge1xuXHRcdHJldHVybiB2YWx1ZSA8IG1pbiA/IG1pbiA6IHZhbHVlID4gbWF4ID8gbWF4IDogdmFsdWU7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdFRPTEVSQU5DRTogMWUtNixcblx0XHRFUFNJTE9OOiBFUFNJTE9OLFxuXHRcdE1BQ0hJTkVfRVBTSUxPTjogTUFDSElORV9FUFNJTE9OLFxuXHRcdENVUlZFVElNRV9FUFNJTE9OOiA0ZS03LFxuXHRcdEdFT01FVFJJQ19FUFNJTE9OOiAyZS03LFxuXHRcdFdJTkRJTkdfRVBTSUxPTjogMmUtNyxcblx0XHRUUklHT05PTUVUUklDX0VQU0lMT046IDFlLTcsXG5cdFx0Q0xJUFBJTkdfRVBTSUxPTjogMWUtNyxcblx0XHRLQVBQQTogNCAqIChzcXJ0KDIpIC0gMSkgLyAzLFxuXG5cdFx0aXNaZXJvOiBmdW5jdGlvbih2YWwpIHtcblx0XHRcdHJldHVybiB2YWwgPj0gLUVQU0lMT04gJiYgdmFsIDw9IEVQU0lMT047XG5cdFx0fSxcblxuXHRcdGludGVncmF0ZTogZnVuY3Rpb24oZiwgYSwgYiwgbikge1xuXHRcdFx0dmFyIHggPSBhYnNjaXNzYXNbbiAtIDJdLFxuXHRcdFx0XHR3ID0gd2VpZ2h0c1tuIC0gMl0sXG5cdFx0XHRcdEEgPSAoYiAtIGEpICogMC41LFxuXHRcdFx0XHRCID0gQSArIGEsXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHRtID0gKG4gKyAxKSA+PiAxLFxuXHRcdFx0XHRzdW0gPSBuICYgMSA/IHdbaSsrXSAqIGYoQikgOiAwO1xuXHRcdFx0d2hpbGUgKGkgPCBtKSB7XG5cdFx0XHRcdHZhciBBeCA9IEEgKiB4W2ldO1xuXHRcdFx0XHRzdW0gKz0gd1tpKytdICogKGYoQiArIEF4KSArIGYoQiAtIEF4KSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gQSAqIHN1bTtcblx0XHR9LFxuXG5cdFx0ZmluZFJvb3Q6IGZ1bmN0aW9uKGYsIGRmLCB4LCBhLCBiLCBuLCB0b2xlcmFuY2UpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHRcdHZhciBmeCA9IGYoeCksXG5cdFx0XHRcdFx0ZHggPSBmeCAvIGRmKHgpLFxuXHRcdFx0XHRcdG54ID0geCAtIGR4O1xuXHRcdFx0XHRpZiAoYWJzKGR4KSA8IHRvbGVyYW5jZSlcblx0XHRcdFx0XHRyZXR1cm4gbng7XG5cdFx0XHRcdGlmIChmeCA+IDApIHtcblx0XHRcdFx0XHRiID0geDtcblx0XHRcdFx0XHR4ID0gbnggPD0gYSA/IChhICsgYikgKiAwLjUgOiBueDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRhID0geDtcblx0XHRcdFx0XHR4ID0gbnggPj0gYiA/IChhICsgYikgKiAwLjUgOiBueDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHg7XG5cdFx0fSxcblxuXHRcdHNvbHZlUXVhZHJhdGljOiBmdW5jdGlvbihhLCBiLCBjLCByb290cywgbWluLCBtYXgpIHtcblx0XHRcdHZhciBjb3VudCA9IDAsXG5cdFx0XHRcdGVNaW4gPSBtaW4gLSBFUFNJTE9OLFxuXHRcdFx0XHRlTWF4ID0gbWF4ICsgRVBTSUxPTixcblx0XHRcdFx0eDEsIHgyID0gSW5maW5pdHksXG5cdFx0XHRcdEIgPSBiLFxuXHRcdFx0XHREO1xuXHRcdFx0YiAvPSAtMjtcblx0XHRcdEQgPSBiICogYiAtIGEgKiBjO1xuXHRcdFx0aWYgKEQgIT09IDAgJiYgYWJzKEQpIDwgTUFDSElORV9FUFNJTE9OKSB7XG5cdFx0XHRcdHZhciBnbUMgPSBwb3coYWJzKGEgKiBiICogYyksIDEgLyAzKTtcblx0XHRcdFx0aWYgKGdtQyA8IDFlLTgpIHtcblx0XHRcdFx0XHR2YXIgbXVsdCA9IHBvdygxMCxcblx0XHRcdFx0XHRcdFx0YWJzKE1hdGguZmxvb3IoTWF0aC5sb2coZ21DKSAqIE1hdGguTE9HMTBFKSkpO1xuXHRcdFx0XHRcdGlmICghaXNGaW5pdGUobXVsdCkpXG5cdFx0XHRcdFx0XHRtdWx0ID0gMDtcblx0XHRcdFx0XHRhICo9IG11bHQ7XG5cdFx0XHRcdFx0YiAqPSBtdWx0O1xuXHRcdFx0XHRcdGMgKj0gbXVsdDtcblx0XHRcdFx0XHREID0gYiAqIGIgLSBhICogYztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGFicyhhKSA8IEVQU0lMT04pIHtcblx0XHRcdFx0aWYgKGFicyhCKSA8IEVQU0lMT04pXG5cdFx0XHRcdFx0cmV0dXJuIGFicyhjKSA8IEVQU0lMT04gPyAtMSA6IDA7XG5cdFx0XHRcdHgxID0gLWMgLyBCO1xuXHRcdFx0fSBlbHNlIGlmIChEID49IC1NQUNISU5FX0VQU0lMT04pIHtcblx0XHRcdFx0dmFyIFEgPSBEIDwgMCA/IDAgOiBzcXJ0KEQpLFxuXHRcdFx0XHRcdFIgPSBiICsgKGIgPCAwID8gLVEgOiBRKTtcblx0XHRcdFx0aWYgKFIgPT09IDApIHtcblx0XHRcdFx0XHR4MSA9IGMgLyBhO1xuXHRcdFx0XHRcdHgyID0gLXgxO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHgxID0gUiAvIGE7XG5cdFx0XHRcdFx0eDIgPSBjIC8gUjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKGlzRmluaXRlKHgxKSAmJiAobWluID09IG51bGwgfHwgeDEgPiBlTWluICYmIHgxIDwgZU1heCkpXG5cdFx0XHRcdHJvb3RzW2NvdW50KytdID0gbWluID09IG51bGwgPyB4MSA6IGNsaXAoeDEsIG1pbiwgbWF4KTtcblx0XHRcdGlmICh4MiAhPT0geDFcblx0XHRcdFx0XHQmJiBpc0Zpbml0ZSh4MikgJiYgKG1pbiA9PSBudWxsIHx8IHgyID4gZU1pbiAmJiB4MiA8IGVNYXgpKVxuXHRcdFx0XHRyb290c1tjb3VudCsrXSA9IG1pbiA9PSBudWxsID8geDIgOiBjbGlwKHgyLCBtaW4sIG1heCk7XG5cdFx0XHRyZXR1cm4gY291bnQ7XG5cdFx0fSxcblxuXHRcdHNvbHZlQ3ViaWM6IGZ1bmN0aW9uKGEsIGIsIGMsIGQsIHJvb3RzLCBtaW4sIG1heCkge1xuXHRcdFx0dmFyIGNvdW50ID0gMCxcblx0XHRcdFx0eCwgYjEsIGMyO1xuXHRcdFx0aWYgKGFicyhhKSA8IEVQU0lMT04pIHtcblx0XHRcdFx0YSA9IGI7XG5cdFx0XHRcdGIxID0gYztcblx0XHRcdFx0YzIgPSBkO1xuXHRcdFx0XHR4ID0gSW5maW5pdHk7XG5cdFx0XHR9IGVsc2UgaWYgKGFicyhkKSA8IEVQU0lMT04pIHtcblx0XHRcdFx0YjEgPSBiO1xuXHRcdFx0XHRjMiA9IGM7XG5cdFx0XHRcdHggPSAwO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIGVjID0gMSArIE1BQ0hJTkVfRVBTSUxPTixcblx0XHRcdFx0XHR4MCwgcSwgcWQsIHQsIHIsIHMsIHRtcDtcblx0XHRcdFx0eCA9IC0oYiAvIGEpIC8gMztcblx0XHRcdFx0dG1wID0gYSAqIHgsXG5cdFx0XHRcdGIxID0gdG1wICsgYixcblx0XHRcdFx0YzIgPSBiMSAqIHggKyBjLFxuXHRcdFx0XHRxZCA9ICh0bXAgKyBiMSkgKiB4ICsgYzIsXG5cdFx0XHRcdHEgPSBjMiAqIHggKyBkO1xuXHRcdFx0XHR0ID0gcSAvYTtcblx0XHRcdFx0ciA9IHBvdyhhYnModCksIDEvMyk7XG5cdFx0XHRcdHMgPSB0IDwgMCA/IC0xIDogMTtcblx0XHRcdFx0dCA9IC1xZCAvIGE7XG5cdFx0XHRcdHIgPSB0ID4gMCA/IDEuMzI0NzE3OTU3MiAqIE1hdGgubWF4KHIsIHNxcnQodCkpIDogcjtcblx0XHRcdFx0eDAgPSB4IC0gcyAqIHI7XG5cdFx0XHRcdGlmICh4MCAhPT0geCkge1xuXHRcdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRcdHggPSB4MDtcblx0XHRcdFx0XHRcdHRtcCA9IGEgKiB4LFxuXHRcdFx0XHRcdFx0YjEgPSB0bXAgKyBiLFxuXHRcdFx0XHRcdFx0YzIgPSBiMSAqIHggKyBjLFxuXHRcdFx0XHRcdFx0cWQgPSAodG1wICsgYjEpICogeCArIGMyLFxuXHRcdFx0XHRcdFx0cSA9IGMyICogeCArIGQ7XG5cdFx0XHRcdFx0XHR4MCA9IHFkID09PSAwID8geCA6IHggLSBxIC8gcWQgLyBlYztcblx0XHRcdFx0XHRcdGlmICh4MCA9PT0geCkge1xuXHRcdFx0XHRcdFx0XHR4ID0geDA7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gd2hpbGUgKHMgKiB4MCA+IHMgKiB4KTtcblx0XHRcdFx0XHRpZiAoYWJzKGEpICogeCAqIHggPiBhYnMoZCAvIHgpKSB7XG5cdFx0XHRcdFx0XHRjMiA9IC1kIC8geDtcblx0XHRcdFx0XHRcdGIxID0gKGMyIC0gYykgLyB4O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dmFyIGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIxLCBjMiwgcm9vdHMsIG1pbiwgbWF4KTtcblx0XHRcdGlmIChpc0Zpbml0ZSh4KSAmJiAoY291bnQgPT09IDAgfHwgeCAhPT0gcm9vdHNbY291bnQgLSAxXSlcblx0XHRcdFx0XHQmJiAobWluID09IG51bGwgfHwgeCA+IG1pbiAtIEVQU0lMT04gJiYgeCA8IG1heCArIEVQU0lMT04pKVxuXHRcdFx0XHRyb290c1tjb3VudCsrXSA9IG1pbiA9PSBudWxsID8geCA6IGNsaXAoeCwgbWluLCBtYXgpO1xuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBVSUQgPSB7XG5cdF9pZDogMSxcblx0X3Bvb2xzOiB7fSxcblxuXHRnZXQ6IGZ1bmN0aW9uKGN0b3IpIHtcblx0XHRpZiAoY3Rvcikge1xuXHRcdFx0dmFyIG5hbWUgPSBjdG9yLl9jbGFzcyxcblx0XHRcdFx0cG9vbCA9IHRoaXMuX3Bvb2xzW25hbWVdO1xuXHRcdFx0aWYgKCFwb29sKVxuXHRcdFx0XHRwb29sID0gdGhpcy5fcG9vbHNbbmFtZV0gPSB7IF9pZDogMSB9O1xuXHRcdFx0cmV0dXJuIHBvb2wuX2lkKys7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJldHVybiB0aGlzLl9pZCsrO1xuXHRcdH1cblx0fVxufTtcblxudmFyIFBvaW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQb2ludCcsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoYXJnMCwgYXJnMSkge1xuXHRcdHZhciB0eXBlID0gdHlwZW9mIGFyZzA7XG5cdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHR2YXIgaGFzWSA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblx0XHRcdHRoaXMueCA9IGFyZzA7XG5cdFx0XHR0aGlzLnkgPSBoYXNZID8gYXJnMSA6IGFyZzA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gaGFzWSA/IDIgOiAxO1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy54ID0gdGhpcy55ID0gMDtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzBbMF07XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAubGVuZ3RoID4gMSA/IGFyZzBbMV0gOiBhcmcwWzBdO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwLng7XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAueTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC53aWR0aCAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzAud2lkdGg7XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAuaGVpZ2h0O1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmFuZ2xlICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC5sZW5ndGg7XG5cdFx0XHRcdHRoaXMueSA9IDA7XG5cdFx0XHRcdHRoaXMuc2V0QW5nbGUoYXJnMC5hbmdsZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnggPSB0aGlzLnkgPSAwO1xuXHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0dGhpcy5fX3JlYWQgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IDE7XG5cdFx0fVxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMueCA9IHg7XG5cdFx0dGhpcy55ID0geTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0cmV0dXJuIHRoaXMgPT09IHBvaW50IHx8IHBvaW50XG5cdFx0XHRcdCYmICh0aGlzLnggPT09IHBvaW50LnggJiYgdGhpcy55ID09PSBwb2ludC55XG5cdFx0XHRcdFx0fHwgQXJyYXkuaXNBcnJheShwb2ludClcblx0XHRcdFx0XHRcdCYmIHRoaXMueCA9PT0gcG9pbnRbMF0gJiYgdGhpcy55ID09PSBwb2ludFsxXSlcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54LCB0aGlzLnkpO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgeDogJyArIGYubnVtYmVyKHRoaXMueCkgKyAnLCB5OiAnICsgZi5udW1iZXIodGhpcy55KSArICcgfSc7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXI7XG5cdFx0cmV0dXJuIFtmLm51bWJlcih0aGlzLngpLCBmLm51bWJlcih0aGlzLnkpXTtcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBNYXRoLnNxcnQodGhpcy54ICogdGhpcy54ICsgdGhpcy55ICogdGhpcy55KTtcblx0fSxcblxuXHRzZXRMZW5ndGg6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdGlmICh0aGlzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgYW5nbGUgPSB0aGlzLl9hbmdsZSB8fCAwO1xuXHRcdFx0dGhpcy5zZXQoXG5cdFx0XHRcdE1hdGguY29zKGFuZ2xlKSAqIGxlbmd0aCxcblx0XHRcdFx0TWF0aC5zaW4oYW5nbGUpICogbGVuZ3RoXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgc2NhbGUgPSBsZW5ndGggLyB0aGlzLmdldExlbmd0aCgpO1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oc2NhbGUpKVxuXHRcdFx0XHR0aGlzLmdldEFuZ2xlKCk7XG5cdFx0XHR0aGlzLnNldChcblx0XHRcdFx0dGhpcy54ICogc2NhbGUsXG5cdFx0XHRcdHRoaXMueSAqIHNjYWxlXG5cdFx0XHQpO1xuXHRcdH1cblx0fSxcblx0Z2V0QW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEFuZ2xlSW5SYWRpYW5zLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgKiAxODAgLyBNYXRoLlBJO1xuXHR9LFxuXG5cdHNldEFuZ2xlOiBmdW5jdGlvbihhbmdsZSkge1xuXHRcdHRoaXMuc2V0QW5nbGVJblJhZGlhbnMuY2FsbCh0aGlzLCBhbmdsZSAqIE1hdGguUEkgLyAxODApO1xuXHR9LFxuXG5cdGdldEFuZ2xlSW5EZWdyZWVzOiAnI2dldEFuZ2xlJyxcblx0c2V0QW5nbGVJbkRlZ3JlZXM6ICcjc2V0QW5nbGUnLFxuXG5cdGdldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9hbmdsZSB8fCAwXG5cdFx0XHRcdFx0OiB0aGlzLl9hbmdsZSA9IE1hdGguYXRhbjIodGhpcy55LCB0aGlzLngpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGRpdiA9IHRoaXMuZ2V0TGVuZ3RoKCkgKiBwb2ludC5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGRpdikpIHtcblx0XHRcdFx0cmV0dXJuIE5hTjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhID0gdGhpcy5kb3QocG9pbnQpIC8gZGl2O1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5hY29zKGEgPCAtMSA/IC0xIDogYSA+IDEgPyAxIDogYSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHNldEFuZ2xlSW5SYWRpYW5zOiBmdW5jdGlvbihhbmdsZSkge1xuXHRcdHRoaXMuX2FuZ2xlID0gYW5nbGU7XG5cdFx0aWYgKCF0aGlzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRcdHRoaXMuc2V0KFxuXHRcdFx0XHRNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsXG5cdFx0XHRcdE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aFxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UXVhZHJhbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggPj0gMCA/IHRoaXMueSA+PSAwID8gMSA6IDQgOiB0aGlzLnkgPj0gMCA/IDIgOiAzO1xuXHR9XG59LCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXREaXJlY3RlZEFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIE1hdGguYXRhbjIodGhpcy5jcm9zcyhwb2ludCksIHRoaXMuZG90KHBvaW50KSkgKiAxODAgLyBNYXRoLlBJO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4ID0gcG9pbnQueCAtIHRoaXMueCxcblx0XHRcdHkgPSBwb2ludC55IC0gdGhpcy55LFxuXHRcdFx0ZCA9IHggKiB4ICsgeSAqIHksXG5cdFx0XHRzcXVhcmVkID0gQmFzZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHNxdWFyZWQgPyBkIDogTWF0aC5zcXJ0KGQpO1xuXHR9LFxuXG5cdG5vcm1hbGl6ZTogZnVuY3Rpb24obGVuZ3RoKSB7XG5cdFx0aWYgKGxlbmd0aCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0bGVuZ3RoID0gMTtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0TGVuZ3RoKCksXG5cdFx0XHRzY2FsZSA9IGN1cnJlbnQgIT09IDAgPyBsZW5ndGggLyBjdXJyZW50IDogMCxcblx0XHRcdHBvaW50ID0gbmV3IFBvaW50KHRoaXMueCAqIHNjYWxlLCB0aGlzLnkgKiBzY2FsZSk7XG5cdFx0aWYgKHNjYWxlID49IDApXG5cdFx0XHRwb2ludC5fYW5nbGUgPSB0aGlzLl9hbmdsZTtcblx0XHRyZXR1cm4gcG9pbnQ7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSwgY2VudGVyKSB7XG5cdFx0aWYgKGFuZ2xlID09PSAwKVxuXHRcdFx0cmV0dXJuIHRoaXMuY2xvbmUoKTtcblx0XHRhbmdsZSA9IGFuZ2xlICogTWF0aC5QSSAvIDE4MDtcblx0XHR2YXIgcG9pbnQgPSBjZW50ZXIgPyB0aGlzLnN1YnRyYWN0KGNlbnRlcikgOiB0aGlzLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHBvaW50ID0gbmV3IFBvaW50KFxuXHRcdFx0cG9pbnQueCAqIGNvcyAtIHBvaW50LnkgKiBzaW4sXG5cdFx0XHRwb2ludC54ICogc2luICsgcG9pbnQueSAqIGNvc1xuXHRcdCk7XG5cdFx0cmV0dXJuIGNlbnRlciA/IHBvaW50LmFkZChjZW50ZXIpIDogcG9pbnQ7XG5cdH0sXG5cblx0dHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh0aGlzKSA6IHRoaXM7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKyBwb2ludC54LCB0aGlzLnkgKyBwb2ludC55KTtcblx0fSxcblxuXHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC0gcG9pbnQueCwgdGhpcy55IC0gcG9pbnQueSk7XG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAqIHBvaW50LngsIHRoaXMueSAqIHBvaW50LnkpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54IC8gcG9pbnQueCwgdGhpcy55IC8gcG9pbnQueSk7XG5cdH0sXG5cblx0bW9kdWxvOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggJSBwb2ludC54LCB0aGlzLnkgJSBwb2ludC55KTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQoLXRoaXMueCwgLXRoaXMueSk7XG5cdH0sXG5cblx0aXNJbnNpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLmNvbnRhaW5zKHRoaXMpO1xuXHR9LFxuXG5cdGlzQ2xvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHRvbGVyYW5jZSA9IEJhc2UucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiB0aGlzLmdldERpc3RhbmNlKHBvaW50KSA8IHRvbGVyYW5jZTtcblx0fSxcblxuXHRpc0NvbGxpbmVhcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBQb2ludC5pc0NvbGxpbmVhcih0aGlzLngsIHRoaXMueSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0aXNDb2xpbmVhcjogJyNpc0NvbGxpbmVhcicsXG5cblx0aXNPcnRob2dvbmFsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIFBvaW50LmlzT3J0aG9nb25hbCh0aGlzLngsIHRoaXMueSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0aXNaZXJvOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTnVtZXJpY2FsLmlzWmVybyh0aGlzLngpICYmIE51bWVyaWNhbC5pc1plcm8odGhpcy55KTtcblx0fSxcblxuXHRpc05hTjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGlzTmFOKHRoaXMueCkgfHwgaXNOYU4odGhpcy55KTtcblx0fSxcblxuXHRkb3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcy54ICogcG9pbnQueCArIHRoaXMueSAqIHBvaW50Lnk7XG5cdH0sXG5cblx0Y3Jvc3M6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcy54ICogcG9pbnQueSAtIHRoaXMueSAqIHBvaW50Lng7XG5cdH0sXG5cblx0cHJvamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0c2NhbGUgPSBwb2ludC5pc1plcm8oKSA/IDAgOiB0aGlzLmRvdChwb2ludCkgLyBwb2ludC5kb3QocG9pbnQpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRwb2ludC54ICogc2NhbGUsXG5cdFx0XHRwb2ludC55ICogc2NhbGVcblx0XHQpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRtaW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvaW50MSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cG9pbnQyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0TWF0aC5taW4ocG9pbnQxLngsIHBvaW50Mi54KSxcblx0XHRcdFx0TWF0aC5taW4ocG9pbnQxLnksIHBvaW50Mi55KVxuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0bWF4OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwb2ludDEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHBvaW50MiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdE1hdGgubWF4KHBvaW50MS54LCBwb2ludDIueCksXG5cdFx0XHRcdE1hdGgubWF4KHBvaW50MS55LCBwb2ludDIueSlcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xuXHRcdH0sXG5cblx0XHRpc0NvbGxpbmVhcjogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcblx0XHRcdHJldHVybiBNYXRoLmFicyh4MSAqIHkyIC0geTEgKiB4Milcblx0XHRcdFx0XHQ8PSBNYXRoLnNxcnQoKHgxICogeDEgKyB5MSAqIHkxKSAqICh4MiAqIHgyICsgeTIgKiB5MikpXG5cdFx0XHRcdFx0XHQqIDFlLTc7XG5cdFx0fSxcblxuXHRcdGlzT3J0aG9nb25hbDogZnVuY3Rpb24oeDEsIHkxLCB4MiwgeTIpIHtcblx0XHRcdHJldHVybiBNYXRoLmFicyh4MSAqIHgyICsgeTEgKiB5Milcblx0XHRcdFx0XHQ8PSBNYXRoLnNxcnQoKHgxICogeDEgKyB5MSAqIHkxKSAqICh4MiAqIHgyICsgeTIgKiB5MikpXG5cdFx0XHRcdFx0XHQqIDFlLTc7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBvcCA9IE1hdGhbbmFtZV07XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KG9wKHRoaXMueCksIG9wKHRoaXMueSkpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmtlZFBvaW50ID0gUG9pbnQuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnQoeCwgeSwgb3duZXIsIHNldHRlcikge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feDtcblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbih4KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fSxcblxuXHRnZXRZOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feTtcblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbih5KSB7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fVxufSk7XG5cbnZhciBTaXplID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTaXplJyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaXplKGFyZzAsIGFyZzEpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGhhc0hlaWdodCA9IHR5cGVvZiBhcmcxID09PSAnbnVtYmVyJztcblx0XHRcdHRoaXMud2lkdGggPSBhcmcwO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBoYXNIZWlnaHQgPyBhcmcxIDogYXJnMDtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSBoYXNIZWlnaHQgPyAyIDogMTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMFswXTtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLmxlbmd0aCA+IDEgPyBhcmcwWzFdIDogYXJnMFswXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC53aWR0aCAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwLndpZHRoO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAuaGVpZ2h0O1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMC54O1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAueTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0XHR0aGlzLl9fcmVhZCA9IDA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gMTtcblx0XHR9XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHJldHVybiBzaXplID09PSB0aGlzIHx8IHNpemUgJiYgKHRoaXMud2lkdGggPT09IHNpemUud2lkdGhcblx0XHRcdFx0JiYgdGhpcy5oZWlnaHQgPT09IHNpemUuaGVpZ2h0XG5cdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkoc2l6ZSkgJiYgdGhpcy53aWR0aCA9PT0gc2l6ZVswXVxuXHRcdFx0XHRcdCYmIHRoaXMuaGVpZ2h0ID09PSBzaXplWzFdKSB8fCBmYWxzZTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcblx0XHRcdFx0KyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodCkgKyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy53aWR0aCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoICsgc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgKyBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggLSBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAtIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRtdWx0aXBseTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAqIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICogc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAvIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0IC8gc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG1vZHVsbzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCAlIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICUgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdG5lZ2F0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKC10aGlzLndpZHRoLCAtdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy53aWR0aCkgJiYgTnVtZXJpY2FsLmlzWmVybyh0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0aXNOYU46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBpc05hTih0aGlzLndpZHRoKSB8fCBpc05hTih0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdG1pbjogZnVuY3Rpb24oc2l6ZTEsIHNpemUyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHRcdE1hdGgubWluKHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG5cdFx0XHRcdE1hdGgubWluKHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG5cdFx0fSxcblxuXHRcdG1heDogZnVuY3Rpb24oc2l6ZTEsIHNpemUyKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHRcdE1hdGgubWF4KHNpemUxLndpZHRoLCBzaXplMi53aWR0aCksXG5cdFx0XHRcdE1hdGgubWF4KHNpemUxLmhlaWdodCwgc2l6ZTIuaGVpZ2h0KSk7XG5cdFx0fSxcblxuXHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNpemUoTWF0aC5yYW5kb20oKSwgTWF0aC5yYW5kb20oKSk7XG5cdFx0fVxuXHR9XG59LCBCYXNlLmVhY2goWydyb3VuZCcsICdjZWlsJywgJ2Zsb29yJywgJ2FicyddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBvcCA9IE1hdGhbbmFtZV07XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNpemUob3AodGhpcy53aWR0aCksIG9wKHRoaXMuaGVpZ2h0KSk7XG5cdH07XG59LCB7fSkpO1xuXG52YXIgTGlua2VkU2l6ZSA9IFNpemUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2l6ZSh3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHR0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fd2lkdGg7XG5cdH0sXG5cblx0c2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9LFxuXG5cdGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hlaWdodDtcblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHR9XG59KTtcblxudmFyIFJlY3RhbmdsZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUmVjdGFuZ2xlJyxcblx0X3JlYWRJbmRleDogdHJ1ZSxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwLFxuXHRcdFx0cmVhZCA9IDA7XG5cdFx0aWYgKHR5cGUgPT09ICdudW1iZXInKSB7XG5cdFx0XHR0aGlzLnggPSBhcmcwO1xuXHRcdFx0dGhpcy55ID0gYXJnMTtcblx0XHRcdHRoaXMud2lkdGggPSBhcmcyO1xuXHRcdFx0dGhpcy5oZWlnaHQgPSBhcmczO1xuXHRcdFx0cmVhZCA9IDQ7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLnggPSB0aGlzLnkgPSB0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuXHRcdFx0cmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2UgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzBbMF07XG5cdFx0XHRcdHRoaXMueSA9IGFyZzBbMV07XG5cdFx0XHRcdHRoaXMud2lkdGggPSBhcmcwWzJdO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzBbM107XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLnggIT09IHVuZGVmaW5lZCB8fCBhcmcwLndpZHRoICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC54IHx8IDA7XG5cdFx0XHRcdHRoaXMueSA9IGFyZzAueSB8fCAwO1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMC53aWR0aCB8fCAwO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IGFyZzAuaGVpZ2h0IHx8IDA7XG5cdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmZyb20gPT09IHVuZGVmaW5lZCAmJiBhcmcwLnRvID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0dGhpcy54ID0gdGhpcy55ID0gdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0XHRcdFx0dGhpcy5fc2V0KGFyZzApO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFyZWFkKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnZnJvbScpLFxuXHRcdFx0XHRuZXh0ID0gQmFzZS5wZWVrKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLnggPSBwb2ludC54O1xuXHRcdFx0dGhpcy55ID0gcG9pbnQueTtcblx0XHRcdGlmIChuZXh0ICYmIG5leHQueCAhPT0gdW5kZWZpbmVkIHx8IEJhc2UuaGFzTmFtZWQoYXJndW1lbnRzLCAndG8nKSkge1xuXHRcdFx0XHR2YXIgdG8gPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKTtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHRvLnggLSBwb2ludC54O1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IHRvLnkgLSBwb2ludC55O1xuXHRcdFx0XHRpZiAodGhpcy53aWR0aCA8IDApIHtcblx0XHRcdFx0XHR0aGlzLnggPSB0by54O1xuXHRcdFx0XHRcdHRoaXMud2lkdGggPSAtdGhpcy53aWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5oZWlnaHQgPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy55ID0gdG8ueTtcblx0XHRcdFx0XHR0aGlzLmhlaWdodCA9IC10aGlzLmhlaWdodDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdFx0dGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0XHRyZWFkID0gYXJndW1lbnRzLl9faW5kZXg7XG5cdFx0fVxuXHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdHRoaXMuX19yZWFkID0gcmVhZDtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0dGhpcy53aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuaGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLngsIHRoaXMueSwgdGhpcy53aWR0aCwgdGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciBydCA9IEJhc2UuaXNQbGFpblZhbHVlKHJlY3QpXG5cdFx0XHRcdD8gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKVxuXHRcdFx0XHQ6IHJlY3Q7XG5cdFx0cmV0dXJuIHJ0ID09PSB0aGlzXG5cdFx0XHRcdHx8IHJ0ICYmIHRoaXMueCA9PT0gcnQueCAmJiB0aGlzLnkgPT09IHJ0Lnlcblx0XHRcdFx0XHQmJiB0aGlzLndpZHRoID09PSBydC53aWR0aCAmJiB0aGlzLmhlaWdodCA9PT0gcnQuaGVpZ2h0XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRyZXR1cm4gJ3sgeDogJyArIGYubnVtYmVyKHRoaXMueClcblx0XHRcdFx0KyAnLCB5OiAnICsgZi5udW1iZXIodGhpcy55KVxuXHRcdFx0XHQrICcsIHdpZHRoOiAnICsgZi5udW1iZXIodGhpcy53aWR0aClcblx0XHRcdFx0KyAnLCBoZWlnaHQ6ICcgKyBmLm51bWJlcih0aGlzLmhlaWdodClcblx0XHRcdFx0KyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy54KSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy55KSxcblx0XHRcdFx0Zi5udW1iZXIodGhpcy53aWR0aCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMuaGVpZ2h0KV07XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy54LCB0aGlzLnksIHRoaXMsICdzZXRQb2ludCcpO1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy54ID0gcG9pbnQueDtcblx0XHR0aGlzLnkgPSBwb2ludC55O1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gU2l6ZSA6IExpbmtlZFNpemU7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0LCB0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHRoaXMuX2ZpeFgpXG5cdFx0XHR0aGlzLnggKz0gKHRoaXMud2lkdGggLSBzaXplLndpZHRoKSAqIHRoaXMuX2ZpeFg7XG5cdFx0aWYgKHRoaXMuX2ZpeFkpXG5cdFx0XHR0aGlzLnkgKz0gKHRoaXMuaGVpZ2h0IC0gc2l6ZS5oZWlnaHQpICogdGhpcy5fZml4WTtcblx0XHR0aGlzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdHRoaXMuX2ZpeFcgPSAxO1xuXHRcdHRoaXMuX2ZpeEggPSAxO1xuXHR9LFxuXG5cdGdldExlZnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLng7XG5cdH0sXG5cblx0c2V0TGVmdDogZnVuY3Rpb24obGVmdCkge1xuXHRcdGlmICghdGhpcy5fZml4Vylcblx0XHRcdHRoaXMud2lkdGggLT0gbGVmdCAtIHRoaXMueDtcblx0XHR0aGlzLnggPSBsZWZ0O1xuXHRcdHRoaXMuX2ZpeFggPSAwO1xuXHR9LFxuXG5cdGdldFRvcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueTtcblx0fSxcblxuXHRzZXRUb3A6IGZ1bmN0aW9uKHRvcCkge1xuXHRcdGlmICghdGhpcy5fZml4SClcblx0XHRcdHRoaXMuaGVpZ2h0IC09IHRvcCAtIHRoaXMueTtcblx0XHR0aGlzLnkgPSB0b3A7XG5cdFx0dGhpcy5fZml4WSA9IDA7XG5cdH0sXG5cblx0Z2V0UmlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoO1xuXHR9LFxuXG5cdHNldFJpZ2h0OiBmdW5jdGlvbihyaWdodCkge1xuXHRcdGlmICh0aGlzLl9maXhYICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZml4WCAhPT0gMSlcblx0XHRcdHRoaXMuX2ZpeFcgPSAwO1xuXHRcdGlmICh0aGlzLl9maXhXKVxuXHRcdFx0dGhpcy54ID0gcmlnaHQgLSB0aGlzLndpZHRoO1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMud2lkdGggPSByaWdodCAtIHRoaXMueDtcblx0XHR0aGlzLl9maXhYID0gMTtcblx0fSxcblxuXHRnZXRCb3R0b206IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRzZXRCb3R0b206IGZ1bmN0aW9uKGJvdHRvbSkge1xuXHRcdGlmICh0aGlzLl9maXhZICE9PSB1bmRlZmluZWQgJiYgdGhpcy5fZml4WSAhPT0gMSlcblx0XHRcdHRoaXMuX2ZpeEggPSAwO1xuXHRcdGlmICh0aGlzLl9maXhIKVxuXHRcdFx0dGhpcy55ID0gYm90dG9tIC0gdGhpcy5oZWlnaHQ7XG5cdFx0ZWxzZVxuXHRcdFx0dGhpcy5oZWlnaHQgPSBib3R0b20gLSB0aGlzLnk7XG5cdFx0dGhpcy5fZml4WSA9IDE7XG5cdH0sXG5cblx0Z2V0Q2VudGVyWDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGggKiAwLjU7XG5cdH0sXG5cblx0c2V0Q2VudGVyWDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMueCA9IHggLSB0aGlzLndpZHRoICogMC41O1xuXHRcdHRoaXMuX2ZpeFggPSAwLjU7XG5cdH0sXG5cblx0Z2V0Q2VudGVyWTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMueSArIHRoaXMuaGVpZ2h0ICogMC41O1xuXHR9LFxuXG5cdHNldENlbnRlclk6IGZ1bmN0aW9uKHkpIHtcblx0XHR0aGlzLnkgPSB5IC0gdGhpcy5oZWlnaHQgKiAwLjU7XG5cdFx0dGhpcy5fZml4WSA9IDAuNTtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gbmV3IGN0b3IodGhpcy5nZXRDZW50ZXJYKCksIHRoaXMuZ2V0Q2VudGVyWSgpLCB0aGlzLCAnc2V0Q2VudGVyJyk7XG5cdH0sXG5cblx0c2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5zZXRDZW50ZXJYKHBvaW50LngpO1xuXHRcdHRoaXMuc2V0Q2VudGVyWShwb2ludC55KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy53aWR0aCAqIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLndpZHRoID09PSAwIHx8IHRoaXMuaGVpZ2h0ID09PSAwO1xuXHR9LFxuXG5cdGNvbnRhaW5zOiBmdW5jdGlvbihhcmcpIHtcblx0XHRyZXR1cm4gYXJnICYmIGFyZy53aWR0aCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdHx8IChBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpLmxlbmd0aCA9PSA0XG5cdFx0XHRcdD8gdGhpcy5fY29udGFpbnNSZWN0YW5nbGUoUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSlcblx0XHRcdFx0OiB0aGlzLl9jb250YWluc1BvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zUG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0cmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiB5IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdF9jb250YWluc1JlY3RhbmdsZTogZnVuY3Rpb24ocmVjdCkge1xuXHRcdHZhciB4ID0gcmVjdC54LFxuXHRcdFx0eSA9IHJlY3QueTtcblx0XHRyZXR1cm4geCA+PSB0aGlzLnggJiYgeSA+PSB0aGlzLnlcblx0XHRcdFx0JiYgeCArIHJlY3Qud2lkdGggPD0gdGhpcy54ICsgdGhpcy53aWR0aFxuXHRcdFx0XHQmJiB5ICsgcmVjdC5oZWlnaHQgPD0gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0aW50ZXJzZWN0czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiByZWN0LnggKyByZWN0LndpZHRoID4gdGhpcy54XG5cdFx0XHRcdCYmIHJlY3QueSArIHJlY3QuaGVpZ2h0ID4gdGhpcy55XG5cdFx0XHRcdCYmIHJlY3QueCA8IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgcmVjdC55IDwgdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0dG91Y2hlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiByZWN0LnggKyByZWN0LndpZHRoID49IHRoaXMueFxuXHRcdFx0XHQmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+PSB0aGlzLnlcblx0XHRcdFx0JiYgcmVjdC54IDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgcmVjdC55IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGludGVyc2VjdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1heCh0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWF4KHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5taW4odGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWluKHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHR1bml0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eDEgPSBNYXRoLm1pbih0aGlzLngsIHJlY3QueCksXG5cdFx0XHR5MSA9IE1hdGgubWluKHRoaXMueSwgcmVjdC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcmVjdC54ICsgcmVjdC53aWR0aCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCByZWN0LnkgKyByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHRpbmNsdWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIHgxID0gTWF0aC5taW4odGhpcy54LCBwb2ludC54KSxcblx0XHRcdHkxID0gTWF0aC5taW4odGhpcy55LCBwb2ludC55KSxcblx0XHRcdHgyID0gTWF0aC5tYXgodGhpcy54ICsgdGhpcy53aWR0aCwgcG9pbnQueCksXG5cdFx0XHR5MiA9IE1hdGgubWF4KHRoaXMueSArIHRoaXMuaGVpZ2h0LCBwb2ludC55KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGV4cGFuZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGFtb3VudCA9IFNpemUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0aG9yID0gYW1vdW50LndpZHRoLFxuXHRcdFx0dmVyID0gYW1vdW50LmhlaWdodDtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh0aGlzLnggLSBob3IgLyAyLCB0aGlzLnkgLSB2ZXIgLyAyLFxuXHRcdFx0XHR0aGlzLndpZHRoICsgaG9yLCB0aGlzLmhlaWdodCArIHZlcik7XG5cdH0sXG5cblx0c2NhbGU6IGZ1bmN0aW9uKGhvciwgdmVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuZXhwYW5kKHRoaXMud2lkdGggKiBob3IgLSB0aGlzLndpZHRoLFxuXHRcdFx0XHR0aGlzLmhlaWdodCAqICh2ZXIgPT09IHVuZGVmaW5lZCA/IGhvciA6IHZlcikgLSB0aGlzLmhlaWdodCk7XG5cdH1cbn0sIEJhc2UuZWFjaChbXG5cdFx0WydUb3AnLCAnTGVmdCddLCBbJ1RvcCcsICdSaWdodCddLFxuXHRcdFsnQm90dG9tJywgJ0xlZnQnXSwgWydCb3R0b20nLCAnUmlnaHQnXSxcblx0XHRbJ0xlZnQnLCAnQ2VudGVyJ10sIFsnVG9wJywgJ0NlbnRlciddLFxuXHRcdFsnUmlnaHQnLCAnQ2VudGVyJ10sIFsnQm90dG9tJywgJ0NlbnRlciddXG5cdF0sXG5cdGZ1bmN0aW9uKHBhcnRzLCBpbmRleCkge1xuXHRcdHZhciBwYXJ0ID0gcGFydHMuam9pbignJyk7XG5cdFx0dmFyIHhGaXJzdCA9IC9eW1JMXS8udGVzdChwYXJ0KTtcblx0XHRpZiAoaW5kZXggPj0gNClcblx0XHRcdHBhcnRzWzFdICs9IHhGaXJzdCA/ICdZJyA6ICdYJztcblx0XHR2YXIgeCA9IHBhcnRzW3hGaXJzdCA/IDAgOiAxXSxcblx0XHRcdHkgPSBwYXJ0c1t4Rmlyc3QgPyAxIDogMF0sXG5cdFx0XHRnZXRYID0gJ2dldCcgKyB4LFxuXHRcdFx0Z2V0WSA9ICdnZXQnICsgeSxcblx0XHRcdHNldFggPSAnc2V0JyArIHgsXG5cdFx0XHRzZXRZID0gJ3NldCcgKyB5LFxuXHRcdFx0Z2V0ID0gJ2dldCcgKyBwYXJ0LFxuXHRcdFx0c2V0ID0gJ3NldCcgKyBwYXJ0O1xuXHRcdHRoaXNbZ2V0XSA9IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXNbZ2V0WF0oKSwgdGhpc1tnZXRZXSgpLCB0aGlzLCBzZXQpO1xuXHRcdH07XG5cdFx0dGhpc1tzZXRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzW3NldFhdKHBvaW50LngpO1xuXHRcdFx0dGhpc1tzZXRZXShwb2ludC55KTtcblx0XHR9O1xuXHR9LCB7XG5cdFx0YmVhbnM6IHRydWVcblx0fVxuKSk7XG5cbnZhciBMaW5rZWRSZWN0YW5nbGUgPSBSZWN0YW5nbGUuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmVjdGFuZ2xlKHgsIHksIHdpZHRoLCBoZWlnaHQsIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLnNldCh4LCB5LCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fd2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBwcm90byA9IFJlY3RhbmdsZS5wcm90b3R5cGU7XG5cblx0cmV0dXJuIEJhc2UuZWFjaChbJ3gnLCAneScsICd3aWR0aCcsICdoZWlnaHQnXSwgZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KTtcblx0XHR2YXIgaW50ZXJuYWwgPSAnXycgKyBrZXk7XG5cdFx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpc1tpbnRlcm5hbF07XG5cdFx0fTtcblxuXHRcdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR0aGlzW2ludGVybmFsXSA9IHZhbHVlO1xuXHRcdFx0aWYgKCF0aGlzLl9kb250Tm90aWZ5KVxuXHRcdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdH07XG5cdH0sIEJhc2UuZWFjaChbJ1BvaW50JywgJ1NpemUnLCAnQ2VudGVyJyxcblx0XHRcdCdMZWZ0JywgJ1RvcCcsICdSaWdodCcsICdCb3R0b20nLCAnQ2VudGVyWCcsICdDZW50ZXJZJyxcblx0XHRcdCdUb3BMZWZ0JywgJ1RvcFJpZ2h0JywgJ0JvdHRvbUxlZnQnLCAnQm90dG9tUmlnaHQnLFxuXHRcdFx0J0xlZnRDZW50ZXInLCAnVG9wQ2VudGVyJywgJ1JpZ2h0Q2VudGVyJywgJ0JvdHRvbUNlbnRlciddLFxuXHRcdGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0dmFyIG5hbWUgPSAnc2V0JyArIGtleTtcblx0XHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0dGhpcy5fZG9udE5vdGlmeSA9IHRydWU7XG5cdFx0XHRcdHByb3RvW25hbWVdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdHRoaXMuX2RvbnROb3RpZnkgPSBmYWxzZTtcblx0XHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRcdH07XG5cdFx0fSwge1xuXHRcdFx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9vd25lci5fYm91bmRzU2VsZWN0ZWQ7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cdFx0XHRcdGlmIChvd25lci5zZXRTZWxlY3RlZCkge1xuXHRcdFx0XHRcdG93bmVyLl9ib3VuZHNTZWxlY3RlZCA9IHNlbGVjdGVkO1xuXHRcdFx0XHRcdG93bmVyLnNldFNlbGVjdGVkKHNlbGVjdGVkIHx8IG93bmVyLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA+IDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSlcblx0KTtcbn0pO1xuXG52YXIgTWF0cml4ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdNYXRyaXgnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIE1hdHJpeChhcmcpIHtcblx0XHR2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0b2sgPSB0cnVlO1xuXHRcdGlmIChjb3VudCA9PT0gNikge1xuXHRcdFx0dGhpcy5zZXQuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG5cdFx0XHRpZiAoYXJnIGluc3RhbmNlb2YgTWF0cml4KSB7XG5cdFx0XHRcdHRoaXMuc2V0KGFyZy5fYSwgYXJnLl9jLCBhcmcuX2IsIGFyZy5fZCwgYXJnLl90eCwgYXJnLl90eSk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHR0aGlzLnNldC5hcHBseSh0aGlzLCBhcmcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0b2sgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAwKSB7XG5cdFx0XHR0aGlzLnJlc2V0KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9rID0gZmFsc2U7XG5cdFx0fVxuXHRcdGlmICghb2spXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1Vuc3VwcG9ydGVkIG1hdHJpeCBwYXJhbWV0ZXJzJyk7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbihhLCBjLCBiLCBkLCB0eCwgdHksIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5fYSA9IGE7XG5cdFx0dGhpcy5fYyA9IGM7XG5cdFx0dGhpcy5fYiA9IGI7XG5cdFx0dGhpcy5fZCA9IGQ7XG5cdFx0dGhpcy5fdHggPSB0eDtcblx0XHR0aGlzLl90eSA9IHR5O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmdldFZhbHVlcygpLCBvcHRpb25zKTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cdFx0aWYgKG93bmVyKSB7XG5cdFx0XHRpZiAob3duZXIuX2FwcGx5TWF0cml4KSB7XG5cdFx0XHRcdG93bmVyLnRyYW5zZm9ybShudWxsLCB0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG93bmVyLl9jaGFuZ2VkKDkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgodGhpcy5fYSwgdGhpcy5fYywgdGhpcy5fYiwgdGhpcy5fZCxcblx0XHRcdFx0dGhpcy5fdHgsIHRoaXMuX3R5KTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKG14KSB7XG5cdFx0cmV0dXJuIG14ID09PSB0aGlzIHx8IG14ICYmIHRoaXMuX2EgPT09IG14Ll9hICYmIHRoaXMuX2IgPT09IG14Ll9iXG5cdFx0XHRcdCYmIHRoaXMuX2MgPT09IG14Ll9jICYmIHRoaXMuX2QgPT09IG14Ll9kXG5cdFx0XHRcdCYmIHRoaXMuX3R4ID09PSBteC5fdHggJiYgdGhpcy5fdHkgPT09IG14Ll90eVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICdbWycgKyBbZi5udW1iZXIodGhpcy5fYSksIGYubnVtYmVyKHRoaXMuX2IpLFxuXHRcdFx0XHRcdGYubnVtYmVyKHRoaXMuX3R4KV0uam9pbignLCAnKSArICddLCBbJ1xuXHRcdFx0XHQrIFtmLm51bWJlcih0aGlzLl9jKSwgZi5udW1iZXIodGhpcy5fZCksXG5cdFx0XHRcdFx0Zi5udW1iZXIodGhpcy5fdHkpXS5qb2luKCcsICcpICsgJ11dJztcblx0fSxcblxuXHRyZXNldDogZnVuY3Rpb24oX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl9hID0gdGhpcy5fZCA9IDE7XG5cdFx0dGhpcy5fYyA9IHRoaXMuX2IgPSB0aGlzLl90eCA9IHRoaXMuX3R5ID0gMDtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdGFwcGx5OiBmdW5jdGlvbihyZWN1cnNpdmVseSwgX3NldEFwcGx5TWF0cml4KSB7XG5cdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXI7XG5cdFx0aWYgKG93bmVyKSB7XG5cdFx0XHRvd25lci50cmFuc2Zvcm0obnVsbCwgdHJ1ZSwgQmFzZS5waWNrKHJlY3Vyc2l2ZWx5LCB0cnVlKSxcblx0XHRcdFx0XHRfc2V0QXBwbHlNYXRyaXgpO1xuXHRcdFx0cmV0dXJuIHRoaXMuaXNJZGVudGl0eSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0dHJhbnNsYXRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdHRoaXMuX3R4ICs9IHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2I7XG5cdFx0dGhpcy5fdHkgKz0geCAqIHRoaXMuX2MgKyB5ICogdGhpcy5fZDtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2NhbGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzY2FsZSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdHRoaXMuX2EgKj0gc2NhbGUueDtcblx0XHR0aGlzLl9jICo9IHNjYWxlLng7XG5cdFx0dGhpcy5fYiAqPSBzY2FsZS55O1xuXHRcdHRoaXMuX2QgKj0gc2NhbGUueTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyLm5lZ2F0ZSgpKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cm90YXRlOiBmdW5jdGlvbihhbmdsZSApIHtcblx0XHRhbmdsZSAqPSBNYXRoLlBJIC8gMTgwO1xuXHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSksXG5cdFx0XHR4ID0gY2VudGVyLngsXG5cdFx0XHR5ID0gY2VudGVyLnksXG5cdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG5cdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHR0eCA9IHggLSB4ICogY29zICsgeSAqIHNpbixcblx0XHRcdHR5ID0geSAtIHggKiBzaW4gLSB5ICogY29zLFxuXHRcdFx0YSA9IHRoaXMuX2EsXG5cdFx0XHRiID0gdGhpcy5fYixcblx0XHRcdGMgPSB0aGlzLl9jLFxuXHRcdFx0ZCA9IHRoaXMuX2Q7XG5cdFx0dGhpcy5fYSA9IGNvcyAqIGEgKyBzaW4gKiBiO1xuXHRcdHRoaXMuX2IgPSAtc2luICogYSArIGNvcyAqIGI7XG5cdFx0dGhpcy5fYyA9IGNvcyAqIGMgKyBzaW4gKiBkO1xuXHRcdHRoaXMuX2QgPSAtc2luICogYyArIGNvcyAqIGQ7XG5cdFx0dGhpcy5fdHggKz0gdHggKiBhICsgdHkgKiBiO1xuXHRcdHRoaXMuX3R5ICs9IHR4ICogYyArIHR5ICogZDtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2hlYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaGVhciA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdHZhciBhID0gdGhpcy5fYSxcblx0XHRcdGMgPSB0aGlzLl9jO1xuXHRcdHRoaXMuX2EgKz0gc2hlYXIueSAqIHRoaXMuX2I7XG5cdFx0dGhpcy5fYyArPSBzaGVhci55ICogdGhpcy5fZDtcblx0XHR0aGlzLl9iICs9IHNoZWFyLnggKiBhO1xuXHRcdHRoaXMuX2QgKz0gc2hlYXIueCAqIGM7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlci5uZWdhdGUoKSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNrZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBza2V3ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgcmVhZE51bGw6IHRydWUgfSksXG5cdFx0XHR0b1JhZGlhbnMgPSBNYXRoLlBJIC8gMTgwLFxuXHRcdFx0c2hlYXIgPSBuZXcgUG9pbnQoTWF0aC50YW4oc2tldy54ICogdG9SYWRpYW5zKSxcblx0XHRcdFx0TWF0aC50YW4oc2tldy55ICogdG9SYWRpYW5zKSk7XG5cdFx0cmV0dXJuIHRoaXMuc2hlYXIoc2hlYXIsIGNlbnRlcik7XG5cdH0sXG5cblx0Y29uY2F0ZW5hdGU6IGZ1bmN0aW9uKG14KSB7XG5cdFx0dmFyIGExID0gdGhpcy5fYSxcblx0XHRcdGIxID0gdGhpcy5fYixcblx0XHRcdGMxID0gdGhpcy5fYyxcblx0XHRcdGQxID0gdGhpcy5fZCxcblx0XHRcdGEyID0gbXguX2EsXG5cdFx0XHRiMiA9IG14Ll9iLFxuXHRcdFx0YzIgPSBteC5fYyxcblx0XHRcdGQyID0gbXguX2QsXG5cdFx0XHR0eDIgPSBteC5fdHgsXG5cdFx0XHR0eTIgPSBteC5fdHk7XG5cdFx0dGhpcy5fYSA9IGEyICogYTEgKyBjMiAqIGIxO1xuXHRcdHRoaXMuX2IgPSBiMiAqIGExICsgZDIgKiBiMTtcblx0XHR0aGlzLl9jID0gYTIgKiBjMSArIGMyICogZDE7XG5cdFx0dGhpcy5fZCA9IGIyICogYzEgKyBkMiAqIGQxO1xuXHRcdHRoaXMuX3R4ICs9IHR4MiAqIGExICsgdHkyICogYjE7XG5cdFx0dGhpcy5fdHkgKz0gdHgyICogYzEgKyB0eTIgKiBkMTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0cHJlQ29uY2F0ZW5hdGU6IGZ1bmN0aW9uKG14KSB7XG5cdFx0dmFyIGExID0gdGhpcy5fYSxcblx0XHRcdGIxID0gdGhpcy5fYixcblx0XHRcdGMxID0gdGhpcy5fYyxcblx0XHRcdGQxID0gdGhpcy5fZCxcblx0XHRcdHR4MSA9IHRoaXMuX3R4LFxuXHRcdFx0dHkxID0gdGhpcy5fdHksXG5cdFx0XHRhMiA9IG14Ll9hLFxuXHRcdFx0YjIgPSBteC5fYixcblx0XHRcdGMyID0gbXguX2MsXG5cdFx0XHRkMiA9IG14Ll9kLFxuXHRcdFx0dHgyID0gbXguX3R4LFxuXHRcdFx0dHkyID0gbXguX3R5O1xuXHRcdHRoaXMuX2EgPSBhMiAqIGExICsgYjIgKiBjMTtcblx0XHR0aGlzLl9iID0gYTIgKiBiMSArIGIyICogZDE7XG5cdFx0dGhpcy5fYyA9IGMyICogYTEgKyBkMiAqIGMxO1xuXHRcdHRoaXMuX2QgPSBjMiAqIGIxICsgZDIgKiBkMTtcblx0XHR0aGlzLl90eCA9IGEyICogdHgxICsgYjIgKiB0eTEgKyB0eDI7XG5cdFx0dGhpcy5fdHkgPSBjMiAqIHR4MSArIGQyICogdHkxICsgdHkyO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjaGFpbjogZnVuY3Rpb24obXgpIHtcblx0XHR2YXIgYTEgPSB0aGlzLl9hLFxuXHRcdFx0YjEgPSB0aGlzLl9iLFxuXHRcdFx0YzEgPSB0aGlzLl9jLFxuXHRcdFx0ZDEgPSB0aGlzLl9kLFxuXHRcdFx0dHgxID0gdGhpcy5fdHgsXG5cdFx0XHR0eTEgPSB0aGlzLl90eSxcblx0XHRcdGEyID0gbXguX2EsXG5cdFx0XHRiMiA9IG14Ll9iLFxuXHRcdFx0YzIgPSBteC5fYyxcblx0XHRcdGQyID0gbXguX2QsXG5cdFx0XHR0eDIgPSBteC5fdHgsXG5cdFx0XHR0eTIgPSBteC5fdHk7XG5cdFx0cmV0dXJuIG5ldyBNYXRyaXgoXG5cdFx0XHRcdGEyICogYTEgKyBjMiAqIGIxLFxuXHRcdFx0XHRhMiAqIGMxICsgYzIgKiBkMSxcblx0XHRcdFx0YjIgKiBhMSArIGQyICogYjEsXG5cdFx0XHRcdGIyICogYzEgKyBkMiAqIGQxLFxuXHRcdFx0XHR0eDEgKyB0eDIgKiBhMSArIHR5MiAqIGIxLFxuXHRcdFx0XHR0eTEgKyB0eDIgKiBjMSArIHR5MiAqIGQxKTtcblx0fSxcblxuXHRpc0lkZW50aXR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYSA9PT0gMSAmJiB0aGlzLl9jID09PSAwICYmIHRoaXMuX2IgPT09IDAgJiYgdGhpcy5fZCA9PT0gMVxuXHRcdFx0XHQmJiB0aGlzLl90eCA9PT0gMCAmJiB0aGlzLl90eSA9PT0gMDtcblx0fSxcblxuXHRvck51bGxJZklkZW50aXR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pc0lkZW50aXR5KCkgPyBudWxsIDogdGhpcztcblx0fSxcblxuXHRpc0ludmVydGlibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2dldERldGVybWluYW50KCk7XG5cdH0sXG5cblx0aXNTaW5ndWxhcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9nZXREZXRlcm1pbmFudCgpO1xuXHR9LFxuXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24oIHNyYywgZHN0LCBjb3VudCkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgM1xuXHRcdFx0PyB0aGlzLl90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpXG5cdFx0XHQ6IHRoaXMuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKHNyYywgZHN0LCBjb3VudCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybVBvaW50OiBmdW5jdGlvbihwb2ludCwgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgeCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueTtcblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFBvaW50KCk7XG5cdFx0cmV0dXJuIGRlc3Quc2V0KFxuXHRcdFx0eCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYiArIHRoaXMuX3R4LFxuXHRcdFx0eCAqIHRoaXMuX2MgKyB5ICogdGhpcy5fZCArIHRoaXMuX3R5LFxuXHRcdFx0X2RvbnROb3RpZnlcblx0XHQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db29yZGluYXRlczogZnVuY3Rpb24oc3JjLCBkc3QsIGNvdW50KSB7XG5cdFx0dmFyIGkgPSAwLFxuXHRcdFx0aiA9IDAsXG5cdFx0XHRtYXggPSAyICogY291bnQ7XG5cdFx0d2hpbGUgKGkgPCBtYXgpIHtcblx0XHRcdHZhciB4ID0gc3JjW2krK10sXG5cdFx0XHRcdHkgPSBzcmNbaSsrXTtcblx0XHRcdGRzdFtqKytdID0geCAqIHRoaXMuX2EgKyB5ICogdGhpcy5fYiArIHRoaXMuX3R4O1xuXHRcdFx0ZHN0W2orK10gPSB4ICogdGhpcy5fYyArIHkgKiB0aGlzLl9kICsgdGhpcy5fdHk7XG5cdFx0fVxuXHRcdHJldHVybiBkc3Q7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvcm5lcnM6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgeDEgPSByZWN0LngsXG5cdFx0XHR5MSA9IHJlY3QueSxcblx0XHRcdHgyID0geDEgKyByZWN0LndpZHRoLFxuXHRcdFx0eTIgPSB5MSArIHJlY3QuaGVpZ2h0LFxuXHRcdFx0Y29vcmRzID0gWyB4MSwgeTEsIHgyLCB5MSwgeDIsIHkyLCB4MSwgeTIgXTtcblx0XHRyZXR1cm4gdGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCBjb29yZHMsIDQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Cb3VuZHM6IGZ1bmN0aW9uKGJvdW5kcywgZGVzdCwgX2RvbnROb3RpZnkpIHtcblx0XHR2YXIgY29vcmRzID0gdGhpcy5fdHJhbnNmb3JtQ29ybmVycyhib3VuZHMpLFxuXHRcdFx0bWluID0gY29vcmRzLnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDI7IGkgPCA4OyBpKyspIHtcblx0XHRcdHZhciB2YWwgPSBjb29yZHNbaV0sXG5cdFx0XHRcdGogPSBpICYgMTtcblx0XHRcdGlmICh2YWwgPCBtaW5bal0pXG5cdFx0XHRcdG1pbltqXSA9IHZhbDtcblx0XHRcdGVsc2UgaWYgKHZhbCA+IG1heFtqXSlcblx0XHRcdFx0bWF4W2pdID0gdmFsO1xuXHRcdH1cblx0XHRpZiAoIWRlc3QpXG5cdFx0XHRkZXN0ID0gbmV3IFJlY3RhbmdsZSgpO1xuXHRcdHJldHVybiBkZXN0LnNldChtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0sXG5cdFx0XHRcdF9kb250Tm90aWZ5KTtcblx0fSxcblxuXHRpbnZlcnNlVHJhbnNmb3JtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdF9nZXREZXRlcm1pbmFudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRldCA9IHRoaXMuX2EgKiB0aGlzLl9kIC0gdGhpcy5fYiAqIHRoaXMuX2M7XG5cdFx0cmV0dXJuIGlzRmluaXRlKGRldCkgJiYgIU51bWVyaWNhbC5pc1plcm8oZGV0KVxuXHRcdFx0XHQmJiBpc0Zpbml0ZSh0aGlzLl90eCkgJiYgaXNGaW5pdGUodGhpcy5fdHkpXG5cdFx0XHRcdD8gZGV0IDogbnVsbDtcblx0fSxcblxuXHRfaW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24ocG9pbnQsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIGRldCA9IHRoaXMuX2dldERldGVybWluYW50KCk7XG5cdFx0aWYgKCFkZXQpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR2YXIgeCA9IHBvaW50LnggLSB0aGlzLl90eCxcblx0XHRcdHkgPSBwb2ludC55IC0gdGhpcy5fdHk7XG5cdFx0aWYgKCFkZXN0KVxuXHRcdFx0ZGVzdCA9IG5ldyBQb2ludCgpO1xuXHRcdHJldHVybiBkZXN0LnNldChcblx0XHRcdCh4ICogdGhpcy5fZCAtIHkgKiB0aGlzLl9iKSAvIGRldCxcblx0XHRcdCh5ICogdGhpcy5fYSAtIHggKiB0aGlzLl9jKSAvIGRldCxcblx0XHRcdF9kb250Tm90aWZ5XG5cdFx0KTtcblx0fSxcblxuXHRkZWNvbXBvc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhID0gdGhpcy5fYSwgYiA9IHRoaXMuX2IsIGMgPSB0aGlzLl9jLCBkID0gdGhpcy5fZDtcblx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhhICogZCAtIGIgKiBjKSlcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0dmFyIHNjYWxlWCA9IE1hdGguc3FydChhICogYSArIGIgKiBiKTtcblx0XHRhIC89IHNjYWxlWDtcblx0XHRiIC89IHNjYWxlWDtcblxuXHRcdHZhciBzaGVhciA9IGEgKiBjICsgYiAqIGQ7XG5cdFx0YyAtPSBhICogc2hlYXI7XG5cdFx0ZCAtPSBiICogc2hlYXI7XG5cblx0XHR2YXIgc2NhbGVZID0gTWF0aC5zcXJ0KGMgKiBjICsgZCAqIGQpO1xuXHRcdGMgLz0gc2NhbGVZO1xuXHRcdGQgLz0gc2NhbGVZO1xuXHRcdHNoZWFyIC89IHNjYWxlWTtcblxuXHRcdGlmIChhICogZCA8IGIgKiBjKSB7XG5cdFx0XHRhID0gLWE7XG5cdFx0XHRiID0gLWI7XG5cdFx0XHRzaGVhciA9IC1zaGVhcjtcblx0XHRcdHNjYWxlWCA9IC1zY2FsZVg7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdHNjYWxpbmc6IG5ldyBQb2ludChzY2FsZVgsIHNjYWxlWSksXG5cdFx0XHRyb3RhdGlvbjogLU1hdGguYXRhbjIoYiwgYSkgKiAxODAgLyBNYXRoLlBJLFxuXHRcdFx0c2hlYXJpbmc6IHNoZWFyXG5cdFx0fTtcblx0fSxcblxuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBbIHRoaXMuX2EsIHRoaXMuX2MsIHRoaXMuX2IsIHRoaXMuX2QsIHRoaXMuX3R4LCB0aGlzLl90eSBdO1xuXHR9LFxuXG5cdGdldFRyYW5zbGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMuX3R4LCB0aGlzLl90eSk7XG5cdH0sXG5cblx0Z2V0U2NhbGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRlY29tcG9zZSgpIHx8IHt9KS5zY2FsaW5nO1xuXHR9LFxuXG5cdGdldFJvdGF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuZGVjb21wb3NlKCkgfHwge30pLnJvdGF0aW9uO1xuXHR9LFxuXG5cdGludmVydGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZGV0ID0gdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0XHRyZXR1cm4gZGV0ICYmIG5ldyBNYXRyaXgoXG5cdFx0XHRcdHRoaXMuX2QgLyBkZXQsXG5cdFx0XHRcdC10aGlzLl9jIC8gZGV0LFxuXHRcdFx0XHQtdGhpcy5fYiAvIGRldCxcblx0XHRcdFx0dGhpcy5fYSAvIGRldCxcblx0XHRcdFx0KHRoaXMuX2IgKiB0aGlzLl90eSAtIHRoaXMuX2QgKiB0aGlzLl90eCkgLyBkZXQsXG5cdFx0XHRcdCh0aGlzLl9jICogdGhpcy5fdHggLSB0aGlzLl9hICogdGhpcy5fdHkpIC8gZGV0KTtcblx0fSxcblxuXHRzaGlmdGxlc3M6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgTWF0cml4KHRoaXMuX2EsIHRoaXMuX2MsIHRoaXMuX2IsIHRoaXMuX2QsIDAsIDApO1xuXHR9LFxuXG5cdGFwcGx5VG9Db250ZXh0OiBmdW5jdGlvbihjdHgpIHtcblx0XHRjdHgudHJhbnNmb3JtKHRoaXMuX2EsIHRoaXMuX2MsIHRoaXMuX2IsIHRoaXMuX2QsIHRoaXMuX3R4LCB0aGlzLl90eSk7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2EnLCAnYycsICdiJywgJ2QnLCAndHgnLCAndHknXSwgZnVuY3Rpb24obmFtZSkge1xuXHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRwcm9wID0gJ18nICsgbmFtZTtcblx0dGhpc1snZ2V0JyArIHBhcnRdID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXNbcHJvcF07XG5cdH07XG5cdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0dGhpc1twcm9wXSA9IHZhbHVlO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBMaW5lID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdMaW5lJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBMaW5lKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQpIHtcblx0XHR2YXIgYXNWZWN0b3IgPSBmYWxzZTtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA+PSA0KSB7XG5cdFx0XHR0aGlzLl9weCA9IGFyZzA7XG5cdFx0XHR0aGlzLl9weSA9IGFyZzE7XG5cdFx0XHR0aGlzLl92eCA9IGFyZzI7XG5cdFx0XHR0aGlzLl92eSA9IGFyZzM7XG5cdFx0XHRhc1ZlY3RvciA9IGFyZzQ7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX3B4ID0gYXJnMC54O1xuXHRcdFx0dGhpcy5fcHkgPSBhcmcwLnk7XG5cdFx0XHR0aGlzLl92eCA9IGFyZzEueDtcblx0XHRcdHRoaXMuX3Z5ID0gYXJnMS55O1xuXHRcdFx0YXNWZWN0b3IgPSBhcmcyO1xuXHRcdH1cblx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHR0aGlzLl92eCAtPSB0aGlzLl9weDtcblx0XHRcdHRoaXMuX3Z5IC09IHRoaXMuX3B5O1xuXHRcdH1cblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLl9weCwgdGhpcy5fcHkpO1xuXHR9LFxuXG5cdGdldFZlY3RvcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLl92eCwgdGhpcy5fdnkpO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0VmVjdG9yKCkuZ2V0TGVuZ3RoKCk7XG5cdH0sXG5cblx0aW50ZXJzZWN0OiBmdW5jdGlvbihsaW5lLCBpc0luZmluaXRlKSB7XG5cdFx0cmV0dXJuIExpbmUuaW50ZXJzZWN0KFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0bGluZS5fcHgsIGxpbmUuX3B5LCBsaW5lLl92eCwgbGluZS5fdnksXG5cdFx0XHRcdHRydWUsIGlzSW5maW5pdGUpO1xuXHR9LFxuXG5cdGdldFNpZGU6IGZ1bmN0aW9uKHBvaW50LCBpc0luZmluaXRlKSB7XG5cdFx0cmV0dXJuIExpbmUuZ2V0U2lkZShcblx0XHRcdFx0dGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksXG5cdFx0XHRcdHBvaW50LngsIHBvaW50LnksIHRydWUsIGlzSW5maW5pdGUpO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiBNYXRoLmFicyhMaW5lLmdldFNpZ25lZERpc3RhbmNlKFxuXHRcdFx0XHR0aGlzLl9weCwgdGhpcy5fcHksIHRoaXMuX3Z4LCB0aGlzLl92eSxcblx0XHRcdFx0cG9pbnQueCwgcG9pbnQueSwgdHJ1ZSkpO1xuXHR9LFxuXG5cdGlzQ29sbGluZWFyOiBmdW5jdGlvbihsaW5lKSB7XG5cdFx0cmV0dXJuIFBvaW50LmlzQ29sbGluZWFyKHRoaXMuX3Z4LCB0aGlzLl92eSwgbGluZS5fdngsIGxpbmUuX3Z5KTtcblx0fSxcblxuXHRpc09ydGhvZ29uYWw6IGZ1bmN0aW9uKGxpbmUpIHtcblx0XHRyZXR1cm4gUG9pbnQuaXNPcnRob2dvbmFsKHRoaXMuX3Z4LCB0aGlzLl92eSwgbGluZS5fdngsIGxpbmUuX3Z5KTtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0aW50ZXJzZWN0OiBmdW5jdGlvbihwMXgsIHAxeSwgdjF4LCB2MXksIHAyeCwgcDJ5LCB2MngsIHYyeSwgYXNWZWN0b3IsXG5cdFx0XHRcdGlzSW5maW5pdGUpIHtcblx0XHRcdGlmICghYXNWZWN0b3IpIHtcblx0XHRcdFx0djF4IC09IHAxeDtcblx0XHRcdFx0djF5IC09IHAxeTtcblx0XHRcdFx0djJ4IC09IHAyeDtcblx0XHRcdFx0djJ5IC09IHAyeTtcblx0XHRcdH1cblx0XHRcdHZhciBjcm9zcyA9IHYxeCAqIHYyeSAtIHYxeSAqIHYyeDtcblx0XHRcdGlmICghTnVtZXJpY2FsLmlzWmVybyhjcm9zcykpIHtcblx0XHRcdFx0dmFyIGR4ID0gcDF4IC0gcDJ4LFxuXHRcdFx0XHRcdGR5ID0gcDF5IC0gcDJ5LFxuXHRcdFx0XHRcdHUxID0gKHYyeCAqIGR5IC0gdjJ5ICogZHgpIC8gY3Jvc3MsXG5cdFx0XHRcdFx0dTIgPSAodjF4ICogZHkgLSB2MXkgKiBkeCkgLyBjcm9zcyxcblx0XHRcdFx0XHRlcHNpbG9uID0gMWUtMTIsXG5cdFx0XHRcdFx0dU1pbiA9IC1lcHNpbG9uLFxuXHRcdFx0XHRcdHVNYXggPSAxICsgZXBzaWxvbjtcblx0XHRcdFx0aWYgKGlzSW5maW5pdGVcblx0XHRcdFx0XHRcdHx8IHVNaW4gPCB1MSAmJiB1MSA8IHVNYXggJiYgdU1pbiA8IHUyICYmIHUyIDwgdU1heCkge1xuXHRcdFx0XHRcdGlmICghaXNJbmZpbml0ZSkge1xuXHRcdFx0XHRcdFx0dTEgPSB1MSA8PSAwID8gMCA6IHUxID49IDEgPyAxIDogdTE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdFx0XHRcdHAxeCArIHUxICogdjF4LFxuXHRcdFx0XHRcdFx0XHRwMXkgKyB1MSAqIHYxeSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z2V0U2lkZTogZnVuY3Rpb24ocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yLCBpc0luZmluaXRlKSB7XG5cdFx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHRcdHZ4IC09IHB4O1xuXHRcdFx0XHR2eSAtPSBweTtcblx0XHRcdH1cblx0XHRcdHZhciB2MnggPSB4IC0gcHgsXG5cdFx0XHRcdHYyeSA9IHkgLSBweSxcblx0XHRcdFx0Y2N3ID0gdjJ4ICogdnkgLSB2MnkgKiB2eDtcblx0XHRcdGlmIChjY3cgPT09IDAgJiYgIWlzSW5maW5pdGUpIHtcblx0XHRcdFx0Y2N3ID0gKHYyeCAqIHZ4ICsgdjJ4ICogdngpIC8gKHZ4ICogdnggKyB2eSAqIHZ5KTtcblx0XHRcdFx0aWYgKGNjdyA+PSAwICYmIGNjdyA8PSAxKVxuXHRcdFx0XHRcdGNjdyA9IDA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY2N3IDwgMCA/IC0xIDogY2N3ID4gMCA/IDEgOiAwO1xuXHRcdH0sXG5cblx0XHRnZXRTaWduZWREaXN0YW5jZTogZnVuY3Rpb24ocHgsIHB5LCB2eCwgdnksIHgsIHksIGFzVmVjdG9yKSB7XG5cdFx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHRcdHZ4IC09IHB4O1xuXHRcdFx0XHR2eSAtPSBweTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB2eCA9PT0gMCA/IHZ5ID4gMCA/IHggLSBweCA6IHB4IC0geFxuXHRcdFx0XHQgOiB2eSA9PT0gMCA/IHZ4IDwgMCA/IHkgLSBweSA6IHB5IC0geVxuXHRcdFx0XHQgOiAoKHgtcHgpICogdnkgLSAoeS1weSkgKiB2eCkgLyBNYXRoLnNxcnQodnggKiB2eCArIHZ5ICogdnkpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBQcm9qZWN0ID0gUGFwZXJTY29wZUl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUHJvamVjdCcsXG5cdF9saXN0OiAncHJvamVjdHMnLFxuXHRfcmVmZXJlbmNlOiAncHJvamVjdCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUHJvamVjdChlbGVtZW50KSB7XG5cdFx0UGFwZXJTY29wZUl0ZW0uY2FsbCh0aGlzLCB0cnVlKTtcblx0XHR0aGlzLmxheWVycyA9IFtdO1xuXHRcdHRoaXMuX2FjdGl2ZUxheWVyID0gbnVsbDtcblx0XHR0aGlzLnN5bWJvbHMgPSBbXTtcblx0XHR0aGlzLl9jdXJyZW50U3R5bGUgPSBuZXcgU3R5bGUobnVsbCwgbnVsbCwgdGhpcyk7XG5cdFx0dGhpcy5fdmlldyA9IFZpZXcuY3JlYXRlKHRoaXMsXG5cdFx0XHRcdGVsZW1lbnQgfHwgQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKDEsIDEpKTtcblx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1zID0ge307XG5cdFx0dGhpcy5fc2VsZWN0ZWRJdGVtQ291bnQgPSAwO1xuXHRcdHRoaXMuX3VwZGF0ZVZlcnNpb24gPSAwO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5sYXllcnMsIG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBpID0gdGhpcy5sYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0aGlzLmxheWVyc1tpXS5yZW1vdmUoKTtcblx0XHR0aGlzLnN5bWJvbHMgPSBbXTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5sYXllcnMubGVuZ3RoID09PSAwO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge1xuXHRcdGlmICghcmVtb3ZlLmJhc2UuY2FsbCh0aGlzKSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRpZiAodGhpcy5fdmlldylcblx0XHRcdHRoaXMuX3ZpZXcucmVtb3ZlKCk7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3ZpZXc7XG5cdH0sXG5cblx0Z2V0Q3VycmVudFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY3VycmVudFN0eWxlO1xuXHR9LFxuXG5cdHNldEN1cnJlbnRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHR0aGlzLl9jdXJyZW50U3R5bGUuaW5pdGlhbGl6ZShzdHlsZSk7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fSxcblxuXHRnZXRPcHRpb25zOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2NvcGUuc2V0dGluZ3M7XG5cdH0sXG5cblx0Z2V0QWN0aXZlTGF5ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hY3RpdmVMYXllciB8fCBuZXcgTGF5ZXIoeyBwcm9qZWN0OiB0aGlzIH0pO1xuXHR9LFxuXG5cdGdldFNlbGVjdGVkSXRlbXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpdGVtcyA9IFtdO1xuXHRcdGZvciAodmFyIGlkIGluIHRoaXMuX3NlbGVjdGVkSXRlbXMpIHtcblx0XHRcdHZhciBpdGVtID0gdGhpcy5fc2VsZWN0ZWRJdGVtc1tpZF07XG5cdFx0XHRpZiAoaXRlbS5pc0luc2VydGVkKCkpXG5cdFx0XHRcdGl0ZW1zLnB1c2goaXRlbSk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRpbnNlcnRDaGlsZDogZnVuY3Rpb24oaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdGlmIChpdGVtIGluc3RhbmNlb2YgTGF5ZXIpIHtcblx0XHRcdGl0ZW0uX3JlbW92ZShmYWxzZSwgdHJ1ZSk7XG5cdFx0XHRCYXNlLnNwbGljZSh0aGlzLmxheWVycywgW2l0ZW1dLCBpbmRleCwgMCk7XG5cdFx0XHRpdGVtLl9zZXRQcm9qZWN0KHRoaXMsIHRydWUpO1xuXHRcdFx0aWYgKHRoaXMuX2NoYW5nZXMpXG5cdFx0XHRcdGl0ZW0uX2NoYW5nZWQoNSk7XG5cdFx0XHRpZiAoIXRoaXMuX2FjdGl2ZUxheWVyKVxuXHRcdFx0XHR0aGlzLl9hY3RpdmVMYXllciA9IGl0ZW07XG5cdFx0fSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgSXRlbSkge1xuXHRcdFx0KHRoaXMuX2FjdGl2ZUxheWVyXG5cdFx0XHRcdHx8IHRoaXMuaW5zZXJ0Q2hpbGQoaW5kZXgsIG5ldyBMYXllcihJdGVtLk5PX0lOU0VSVCkpKVxuXHRcdFx0XHRcdC5pbnNlcnRDaGlsZChpbmRleCwgaXRlbSwgX3ByZXNlcnZlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXRlbSA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtO1xuXHR9LFxuXG5cdGFkZENoaWxkOiBmdW5jdGlvbihpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZCh1bmRlZmluZWQsIGl0ZW0sIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0X3VwZGF0ZVNlbGVjdGlvbjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBpZCA9IGl0ZW0uX2lkLFxuXHRcdFx0c2VsZWN0ZWRJdGVtcyA9IHRoaXMuX3NlbGVjdGVkSXRlbXM7XG5cdFx0aWYgKGl0ZW0uX3NlbGVjdGVkKSB7XG5cdFx0XHRpZiAoc2VsZWN0ZWRJdGVtc1tpZF0gIT09IGl0ZW0pIHtcblx0XHRcdFx0dGhpcy5fc2VsZWN0ZWRJdGVtQ291bnQrKztcblx0XHRcdFx0c2VsZWN0ZWRJdGVtc1tpZF0gPSBpdGVtO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoc2VsZWN0ZWRJdGVtc1tpZF0gPT09IGl0ZW0pIHtcblx0XHRcdHRoaXMuX3NlbGVjdGVkSXRlbUNvdW50LS07XG5cdFx0XHRkZWxldGUgc2VsZWN0ZWRJdGVtc1tpZF07XG5cdFx0fVxuXHR9LFxuXG5cdHNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxheWVycyA9IHRoaXMubGF5ZXJzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGxheWVyc1tpXS5zZXRGdWxseVNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdGRlc2VsZWN0QWxsOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VsZWN0ZWRJdGVtcyA9IHRoaXMuX3NlbGVjdGVkSXRlbXM7XG5cdFx0Zm9yICh2YXIgaSBpbiBzZWxlY3RlZEl0ZW1zKVxuXHRcdFx0c2VsZWN0ZWRJdGVtc1tpXS5zZXRGdWxseVNlbGVjdGVkKGZhbHNlKTtcblx0fSxcblxuXHRoaXRUZXN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRvcHRpb25zID0gSGl0UmVzdWx0LmdldE9wdGlvbnMoQmFzZS5yZWFkKGFyZ3VtZW50cykpO1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLmxheWVycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIHJlcyA9IHRoaXMubGF5ZXJzW2ldLl9oaXRUZXN0KHBvaW50LCBvcHRpb25zKTtcblx0XHRcdGlmIChyZXMpIHJldHVybiByZXM7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldEl0ZW1zOiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLmxheWVycywgbWF0Y2gpO1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMubGF5ZXJzLCBtYXRjaCwgbnVsbCwgbnVsbCwgdHJ1ZSlbMF0gfHwgbnVsbDtcblx0fSxcblxuXHRpbXBvcnRKU09OOiBmdW5jdGlvbihqc29uKSB7XG5cdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHRcdHZhciBsYXllciA9IHRoaXMuX2FjdGl2ZUxheWVyO1xuXHRcdHJldHVybiBCYXNlLmltcG9ydEpTT04oanNvbiwgbGF5ZXIgJiYgbGF5ZXIuaXNFbXB0eSgpICYmIGxheWVyKTtcblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbihjdHgsIG1hdHJpeCwgcGl4ZWxSYXRpbykge1xuXHRcdHRoaXMuX3VwZGF0ZVZlcnNpb24rKztcblx0XHRjdHguc2F2ZSgpO1xuXHRcdG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdHZhciBwYXJhbSA9IG5ldyBCYXNlKHtcblx0XHRcdG9mZnNldDogbmV3IFBvaW50KDAsIDApLFxuXHRcdFx0cGl4ZWxSYXRpbzogcGl4ZWxSYXRpbyxcblx0XHRcdHZpZXdNYXRyaXg6IG1hdHJpeC5pc0lkZW50aXR5KCkgPyBudWxsIDogbWF0cml4LFxuXHRcdFx0bWF0cmljZXM6IFtuZXcgTWF0cml4KCldLFxuXHRcdFx0dXBkYXRlTWF0cml4OiB0cnVlXG5cdFx0fSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGxheWVycyA9IHRoaXMubGF5ZXJzLCBsID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGxheWVyc1tpXS5kcmF3KGN0eCwgcGFyYW0pO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cblx0XHRpZiAodGhpcy5fc2VsZWN0ZWRJdGVtQ291bnQgPiAwKSB7XG5cdFx0XHRjdHguc2F2ZSgpO1xuXHRcdFx0Y3R4LnN0cm9rZVdpZHRoID0gMTtcblx0XHRcdHZhciBpdGVtcyA9IHRoaXMuX3NlbGVjdGVkSXRlbXMsXG5cdFx0XHRcdHNpemUgPSB0aGlzLl9zY29wZS5zZXR0aW5ncy5oYW5kbGVTaXplLFxuXHRcdFx0XHR2ZXJzaW9uID0gdGhpcy5fdXBkYXRlVmVyc2lvbjtcblx0XHRcdGZvciAodmFyIGlkIGluIGl0ZW1zKVxuXHRcdFx0XHRpdGVtc1tpZF0uX2RyYXdTZWxlY3Rpb24oY3R4LCBtYXRyaXgsIHNpemUsIGl0ZW1zLCB2ZXJzaW9uKTtcblx0XHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIFN5bWJvbCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU3ltYm9sJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTeW1ib2woaXRlbSwgZG9udENlbnRlcikge1xuXHRcdHRoaXMuX2lkID0gVUlELmdldCgpO1xuXHRcdHRoaXMucHJvamVjdCA9IHBhcGVyLnByb2plY3Q7XG5cdFx0dGhpcy5wcm9qZWN0LnN5bWJvbHMucHVzaCh0aGlzKTtcblx0XHRpZiAoaXRlbSlcblx0XHRcdHRoaXMuc2V0RGVmaW5pdGlvbihpdGVtLCBkb250Q2VudGVyKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIGRpY3Rpb25hcnkuYWRkKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9jbGFzcywgdGhpcy5fZGVmaW5pdGlvbl0sXG5cdFx0XHRcdFx0b3B0aW9ucywgZmFsc2UsIGRpY3Rpb25hcnkpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdGlmIChmbGFncyAmIDgpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUodGhpcyk7XG5cdFx0fVxuXHRcdGlmIChmbGFncyAmIDEpIHtcblx0XHRcdHRoaXMucHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRnZXREZWZpbml0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVmaW5pdGlvbjtcblx0fSxcblxuXHRzZXREZWZpbml0aW9uOiBmdW5jdGlvbihpdGVtLCBfZG9udENlbnRlcikge1xuXHRcdGlmIChpdGVtLl9wYXJlbnRTeW1ib2wpXG5cdFx0XHRpdGVtID0gaXRlbS5jbG9uZSgpO1xuXHRcdGlmICh0aGlzLl9kZWZpbml0aW9uKVxuXHRcdFx0dGhpcy5fZGVmaW5pdGlvbi5fcGFyZW50U3ltYm9sID0gbnVsbDtcblx0XHR0aGlzLl9kZWZpbml0aW9uID0gaXRlbTtcblx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdGl0ZW0uc2V0U2VsZWN0ZWQoZmFsc2UpO1xuXHRcdGlmICghX2RvbnRDZW50ZXIpXG5cdFx0XHRpdGVtLnNldFBvc2l0aW9uKG5ldyBQb2ludCgpKTtcblx0XHRpdGVtLl9wYXJlbnRTeW1ib2wgPSB0aGlzO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0cGxhY2U6IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG5cdFx0cmV0dXJuIG5ldyBQbGFjZWRTeW1ib2wodGhpcywgcG9zaXRpb24pO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFN5bWJvbCh0aGlzLl9kZWZpbml0aW9uLmNsb25lKGZhbHNlKSk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzeW1ib2wpIHtcblx0XHRyZXR1cm4gc3ltYm9sID09PSB0aGlzXG5cdFx0XHRcdHx8IHN5bWJvbCAmJiB0aGlzLmRlZmluaXRpb24uZXF1YWxzKHN5bWJvbC5kZWZpbml0aW9uKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fVxufSk7XG5cbnZhciBJdGVtID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXHRzdGF0aWNzOiB7XG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoc3JjKSB7XG5cdFx0XHRpZiAoc3JjLl9zZXJpYWxpemVGaWVsZHMpXG5cdFx0XHRcdHNyYy5fc2VyaWFsaXplRmllbGRzID0gbmV3IEJhc2UoXG5cdFx0XHRcdFx0XHR0aGlzLnByb3RvdHlwZS5fc2VyaWFsaXplRmllbGRzLCBzcmMuX3NlcmlhbGl6ZUZpZWxkcyk7XG5cdFx0XHRyZXR1cm4gZXh0ZW5kLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Tk9fSU5TRVJUOiB7IGluc2VydDogZmFsc2UgfVxuXHR9LFxuXG5cdF9jbGFzczogJ0l0ZW0nLFxuXHRfYXBwbHlNYXRyaXg6IHRydWUsXG5cdF9jYW5BcHBseU1hdHJpeDogdHJ1ZSxcblx0X2JvdW5kc1NlbGVjdGVkOiBmYWxzZSxcblx0X3NlbGVjdENoaWxkcmVuOiBmYWxzZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdG5hbWU6IG51bGwsXG5cdFx0YXBwbHlNYXRyaXg6IG51bGwsXG5cdFx0bWF0cml4OiBuZXcgTWF0cml4KCksXG5cdFx0cGl2b3Q6IG51bGwsXG5cdFx0bG9ja2VkOiBmYWxzZSxcblx0XHR2aXNpYmxlOiB0cnVlLFxuXHRcdGJsZW5kTW9kZTogJ25vcm1hbCcsXG5cdFx0b3BhY2l0eTogMSxcblx0XHRndWlkZTogZmFsc2UsXG5cdFx0c2VsZWN0ZWQ6IGZhbHNlLFxuXHRcdGNsaXBNYXNrOiBmYWxzZSxcblx0XHRkYXRhOiB7fVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEl0ZW0oKSB7XG5cdH0sXG5cblx0X2luaXRpYWxpemU6IGZ1bmN0aW9uKHByb3BzLCBwb2ludCkge1xuXHRcdHZhciBoYXNQcm9wcyA9IHByb3BzICYmIEJhc2UuaXNQbGFpbk9iamVjdChwcm9wcyksXG5cdFx0XHRpbnRlcm5hbCA9IGhhc1Byb3BzICYmIHByb3BzLmludGVybmFsID09PSB0cnVlLFxuXHRcdFx0bWF0cml4ID0gdGhpcy5fbWF0cml4ID0gbmV3IE1hdHJpeCgpLFxuXHRcdFx0cHJvamVjdCA9IGhhc1Byb3BzICYmIHByb3BzLnByb2plY3QgfHwgcGFwZXIucHJvamVjdDtcblx0XHRpZiAoIWludGVybmFsKVxuXHRcdFx0dGhpcy5faWQgPSBVSUQuZ2V0KCk7XG5cdFx0dGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiBwYXBlci5zZXR0aW5ncy5hcHBseU1hdHJpeDtcblx0XHRpZiAocG9pbnQpXG5cdFx0XHRtYXRyaXgudHJhbnNsYXRlKHBvaW50KTtcblx0XHRtYXRyaXguX293bmVyID0gdGhpcztcblx0XHR0aGlzLl9zdHlsZSA9IG5ldyBTdHlsZShwcm9qZWN0Ll9jdXJyZW50U3R5bGUsIHRoaXMsIHByb2plY3QpO1xuXHRcdGlmICghdGhpcy5fcHJvamVjdCkge1xuXHRcdFx0aWYgKGludGVybmFsIHx8IGhhc1Byb3BzICYmIHByb3BzLmluc2VydCA9PT0gZmFsc2UpIHtcblx0XHRcdFx0dGhpcy5fc2V0UHJvamVjdChwcm9qZWN0KTtcblx0XHRcdH0gZWxzZSBpZiAoaGFzUHJvcHMgJiYgcHJvcHMucGFyZW50KSB7XG5cdFx0XHRcdHRoaXMuc2V0UGFyZW50KHByb3BzLnBhcmVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHQocHJvamVjdC5fYWN0aXZlTGF5ZXIgfHwgbmV3IExheWVyKCkpLmFkZENoaWxkKHRoaXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoaGFzUHJvcHMgJiYgcHJvcHMgIT09IEl0ZW0uTk9fSU5TRVJUKVxuXHRcdFx0dGhpcy5fc2V0KHByb3BzLCB7IGluc2VydDogdHJ1ZSwgcHJvamVjdDogdHJ1ZSwgcGFyZW50OiB0cnVlIH0sXG5cdFx0XHRcdFx0dHJ1ZSk7XG5cdFx0cmV0dXJuIGhhc1Byb3BzO1xuXHR9LFxuXG5cdF9ldmVudHM6IEJhc2UuZWFjaChbJ29uTW91c2VEb3duJywgJ29uTW91c2VVcCcsICdvbk1vdXNlRHJhZycsICdvbkNsaWNrJyxcblx0XHRcdCdvbkRvdWJsZUNsaWNrJywgJ29uTW91c2VNb3ZlJywgJ29uTW91c2VFbnRlcicsICdvbk1vdXNlTGVhdmUnXSxcblx0XHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR0aGlzW25hbWVdID0ge1xuXHRcdFx0XHRpbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdFx0dGhpcy5nZXRWaWV3KCkuX2luc3RhbGxFdmVudCh0eXBlKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1bmluc3RhbGw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0XHR0aGlzLmdldFZpZXcoKS5fdW5pbnN0YWxsRXZlbnQodHlwZSk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fSwge1xuXHRcdFx0b25GcmFtZToge1xuXHRcdFx0XHRpbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLmdldFZpZXcoKS5fYW5pbWF0ZUl0ZW0odGhpcywgdHJ1ZSk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLmdldFZpZXcoKS5fYW5pbWF0ZUl0ZW0odGhpcywgZmFsc2UpO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRvbkxvYWQ6IHt9XG5cdFx0fVxuXHQpLFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHR2YXIgcHJvcHMgPSB7fSxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXG5cdFx0ZnVuY3Rpb24gc2VyaWFsaXplKGZpZWxkcykge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGZpZWxkcykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGF0W2tleV07XG5cdFx0XHRcdGlmICghQmFzZS5lcXVhbHModmFsdWUsIGtleSA9PT0gJ2xlYWRpbmcnXG5cdFx0XHRcdFx0XHQ/IGZpZWxkcy5mb250U2l6ZSAqIDEuMiA6IGZpZWxkc1trZXldKSkge1xuXHRcdFx0XHRcdHByb3BzW2tleV0gPSBCYXNlLnNlcmlhbGl6ZSh2YWx1ZSwgb3B0aW9ucyxcblx0XHRcdFx0XHRcdFx0a2V5ICE9PSAnZGF0YScsIGRpY3Rpb25hcnkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0c2VyaWFsaXplKHRoaXMuX3NlcmlhbGl6ZUZpZWxkcyk7XG5cdFx0aWYgKCEodGhpcyBpbnN0YW5jZW9mIEdyb3VwKSlcblx0XHRcdHNlcmlhbGl6ZSh0aGlzLl9zdHlsZS5fZGVmYXVsdHMpO1xuXHRcdHJldHVybiBbIHRoaXMuX2NsYXNzLCBwcm9wcyBdO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdHZhciBzeW1ib2wgPSB0aGlzLl9wYXJlbnRTeW1ib2wsXG5cdFx0XHRjYWNoZVBhcmVudCA9IHRoaXMuX3BhcmVudCB8fCBzeW1ib2wsXG5cdFx0XHRwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSB0aGlzLl9wb3NpdGlvbiA9IHRoaXMuX2RlY29tcG9zZWQgPVxuXHRcdFx0XHRcdHRoaXMuX2dsb2JhbE1hdHJpeCA9IHRoaXMuX2N1cnJlbnRQYXRoID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoY2FjaGVQYXJlbnRcblx0XHRcdFx0JiYgKGZsYWdzICYgNDApKSB7XG5cdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKGNhY2hlUGFyZW50KTtcblx0XHR9XG5cdFx0aWYgKGZsYWdzICYgMikge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZSh0aGlzKTtcblx0XHR9XG5cdFx0aWYgKHByb2plY3QpIHtcblx0XHRcdGlmIChmbGFncyAmIDEpIHtcblx0XHRcdFx0cHJvamVjdC5fbmVlZHNVcGRhdGUgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHByb2plY3QuX2NoYW5nZXMpIHtcblx0XHRcdFx0dmFyIGVudHJ5ID0gcHJvamVjdC5fY2hhbmdlc0J5SWRbdGhpcy5faWRdO1xuXHRcdFx0XHRpZiAoZW50cnkpIHtcblx0XHRcdFx0XHRlbnRyeS5mbGFncyB8PSBmbGFncztcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRlbnRyeSA9IHsgaXRlbTogdGhpcywgZmxhZ3M6IGZsYWdzIH07XG5cdFx0XHRcdFx0cHJvamVjdC5fY2hhbmdlc0J5SWRbdGhpcy5faWRdID0gZW50cnk7XG5cdFx0XHRcdFx0cHJvamVjdC5fY2hhbmdlcy5wdXNoKGVudHJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc3ltYm9sKVxuXHRcdFx0c3ltYm9sLl9jaGFuZ2VkKGZsYWdzKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHByb3BzKSB7XG5cdFx0aWYgKHByb3BzKVxuXHRcdFx0dGhpcy5fc2V0KHByb3BzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRJZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2lkO1xuXHR9LFxuXG5cdGdldE5hbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9uYW1lO1xuXHR9LFxuXG5cdHNldE5hbWU6IGZ1bmN0aW9uKG5hbWUsIHVuaXF1ZSkge1xuXG5cdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHR0aGlzLl9yZW1vdmVOYW1lZCgpO1xuXHRcdGlmIChuYW1lID09PSAoK25hbWUpICsgJycpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J05hbWVzIGNvbnNpc3Rpbmcgb25seSBvZiBudW1iZXJzIGFyZSBub3Qgc3VwcG9ydGVkLicpO1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKG5hbWUgJiYgcGFyZW50KSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSBwYXJlbnQuX2NoaWxkcmVuLFxuXHRcdFx0XHRuYW1lZENoaWxkcmVuID0gcGFyZW50Ll9uYW1lZENoaWxkcmVuLFxuXHRcdFx0XHRvcmlnID0gbmFtZSxcblx0XHRcdFx0aSA9IDE7XG5cdFx0XHR3aGlsZSAodW5pcXVlICYmIGNoaWxkcmVuW25hbWVdKVxuXHRcdFx0XHRuYW1lID0gb3JpZyArICcgJyArIChpKyspO1xuXHRcdFx0KG5hbWVkQ2hpbGRyZW5bbmFtZV0gPSBuYW1lZENoaWxkcmVuW25hbWVdIHx8IFtdKS5wdXNoKHRoaXMpO1xuXHRcdFx0Y2hpbGRyZW5bbmFtZV0gPSB0aGlzO1xuXHRcdH1cblx0XHR0aGlzLl9uYW1lID0gbmFtZSB8fCB1bmRlZmluZWQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgxMjgpO1xuXHR9LFxuXG5cdGdldFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3R5bGU7XG5cdH0sXG5cblx0c2V0U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dGhpcy5nZXRTdHlsZSgpLnNldChzdHlsZSk7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2xvY2tlZCcsICd2aXNpYmxlJywgJ2JsZW5kTW9kZScsICdvcGFjaXR5JywgJ2d1aWRlJ10sXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShuYW1lKSxcblx0XHRcdG5hbWUgPSAnXycgKyBuYW1lO1xuXHRcdHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbbmFtZV07XG5cdFx0fTtcblx0XHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0aWYgKHZhbHVlICE9IHRoaXNbbmFtZV0pIHtcblx0XHRcdFx0dGhpc1tuYW1lXSA9IHZhbHVlO1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKG5hbWUgPT09ICdfbG9ja2VkJ1xuXHRcdFx0XHRcdFx0PyAxMjggOiAxMjkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sXG57fSksIHtcblx0YmVhbnM6IHRydWUsXG5cblx0X2xvY2tlZDogZmFsc2UsXG5cblx0X3Zpc2libGU6IHRydWUsXG5cblx0X2JsZW5kTW9kZTogJ25vcm1hbCcsXG5cblx0X29wYWNpdHk6IDEsXG5cblx0X2d1aWRlOiBmYWxzZSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fc2VsZWN0Q2hpbGRyZW4pIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGlmIChjaGlsZHJlbltpXS5pc1NlbGVjdGVkKCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZDtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIG5vQ2hpbGRyZW4pIHtcblx0XHRpZiAoIW5vQ2hpbGRyZW4gJiYgdGhpcy5fc2VsZWN0Q2hpbGRyZW4pIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR9XG5cdFx0aWYgKChzZWxlY3RlZCA9ICEhc2VsZWN0ZWQpIF4gdGhpcy5fc2VsZWN0ZWQpIHtcblx0XHRcdHRoaXMuX3NlbGVjdGVkID0gc2VsZWN0ZWQ7XG5cdFx0XHR0aGlzLl9wcm9qZWN0Ll91cGRhdGVTZWxlY3Rpb24odGhpcyk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDEyOSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9zZWxlY3RlZDogZmFsc2UsXG5cblx0aXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4gJiYgdGhpcy5fc2VsZWN0ZWQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoIWNoaWxkcmVuW2ldLmlzRnVsbHlTZWxlY3RlZCgpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG5cdH0sXG5cblx0c2V0RnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRGdWxseVNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR9XG5cdFx0dGhpcy5zZXRTZWxlY3RlZChzZWxlY3RlZCwgdHJ1ZSk7XG5cdH0sXG5cblx0aXNDbGlwTWFzazogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NsaXBNYXNrO1xuXHR9LFxuXG5cdHNldENsaXBNYXNrOiBmdW5jdGlvbihjbGlwTWFzaykge1xuXHRcdGlmICh0aGlzLl9jbGlwTWFzayAhPSAoY2xpcE1hc2sgPSAhIWNsaXBNYXNrKSkge1xuXHRcdFx0dGhpcy5fY2xpcE1hc2sgPSBjbGlwTWFzaztcblx0XHRcdGlmIChjbGlwTWFzaykge1xuXHRcdFx0XHR0aGlzLnNldEZpbGxDb2xvcihudWxsKTtcblx0XHRcdFx0dGhpcy5zZXRTdHJva2VDb2xvcihudWxsKTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX2NoYW5nZWQoMTI5KTtcblx0XHRcdGlmICh0aGlzLl9wYXJlbnQpXG5cdFx0XHRcdHRoaXMuX3BhcmVudC5fY2hhbmdlZCgxMDI0KTtcblx0XHR9XG5cdH0sXG5cblx0X2NsaXBNYXNrOiBmYWxzZSxcblxuXHRnZXREYXRhOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2RhdGEpXG5cdFx0XHR0aGlzLl9kYXRhID0ge307XG5cdFx0cmV0dXJuIHRoaXMuX2RhdGE7XG5cdH0sXG5cblx0c2V0RGF0YTogZnVuY3Rpb24oZGF0YSkge1xuXHRcdHRoaXMuX2RhdGEgPSBkYXRhO1xuXHR9LFxuXG5cdGdldFBvc2l0aW9uOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgcG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbixcblx0XHRcdGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdGlmICghcG9zaXRpb24pIHtcblx0XHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuXHRcdFx0cG9zaXRpb24gPSB0aGlzLl9wb3NpdGlvbiA9IHBpdm90XG5cdFx0XHRcdFx0PyB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KHBpdm90KVxuXHRcdFx0XHRcdDogdGhpcy5nZXRCb3VuZHMoKS5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBuZXcgY3Rvcihwb3NpdGlvbi54LCBwb3NpdGlvbi55LCB0aGlzLCAnc2V0UG9zaXRpb24nKTtcblx0fSxcblxuXHRzZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy50cmFuc2xhdGUoUG9pbnQucmVhZChhcmd1bWVudHMpLnN1YnRyYWN0KHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSkpKTtcblx0fSxcblxuXHRnZXRQaXZvdDogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIHBpdm90ID0gdGhpcy5fcGl2b3Q7XG5cdFx0aWYgKHBpdm90KSB7XG5cdFx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0XHRwaXZvdCA9IG5ldyBjdG9yKHBpdm90LngsIHBpdm90LnksIHRoaXMsICdzZXRQaXZvdCcpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGl2b3Q7XG5cdH0sXG5cblx0c2V0UGl2b3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Bpdm90ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgY2xvbmU6IHRydWUsIHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdHRoaXMuX3Bvc2l0aW9uID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdF9waXZvdDogbnVsbCxcbn0sIEJhc2UuZWFjaChbJ2JvdW5kcycsICdzdHJva2VCb3VuZHMnLCAnaGFuZGxlQm91bmRzJywgJ3JvdWdoQm91bmRzJyxcblx0XHQnaW50ZXJuYWxCb3VuZHMnLCAnaW50ZXJuYWxSb3VnaEJvdW5kcyddLFxuXHRmdW5jdGlvbihrZXkpIHtcblx0XHR2YXIgZ2V0dGVyID0gJ2dldCcgKyBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRcdG1hdGNoID0ga2V5Lm1hdGNoKC9eaW50ZXJuYWwoLiopJC8pLFxuXHRcdFx0aW50ZXJuYWxHZXR0ZXIgPSBtYXRjaCA/ICdnZXQnICsgbWF0Y2hbMV0gOiBudWxsO1xuXHRcdHRoaXNbZ2V0dGVyXSA9IGZ1bmN0aW9uKF9tYXRyaXgpIHtcblx0XHRcdHZhciBib3VuZHNHZXR0ZXIgPSB0aGlzLl9ib3VuZHNHZXR0ZXIsXG5cdFx0XHRcdG5hbWUgPSAhaW50ZXJuYWxHZXR0ZXIgJiYgKHR5cGVvZiBib3VuZHNHZXR0ZXIgPT09ICdzdHJpbmcnXG5cdFx0XHRcdFx0XHQ/IGJvdW5kc0dldHRlciA6IGJvdW5kc0dldHRlciAmJiBib3VuZHNHZXR0ZXJbZ2V0dGVyXSlcblx0XHRcdFx0XHRcdHx8IGdldHRlcixcblx0XHRcdFx0Ym91bmRzID0gdGhpcy5fZ2V0Q2FjaGVkQm91bmRzKG5hbWUsIF9tYXRyaXgsIHRoaXMsXG5cdFx0XHRcdFx0XHRpbnRlcm5hbEdldHRlcik7XG5cdFx0XHRyZXR1cm4ga2V5ID09PSAnYm91bmRzJ1xuXHRcdFx0XHRcdD8gbmV3IExpbmtlZFJlY3RhbmdsZShib3VuZHMueCwgYm91bmRzLnksIGJvdW5kcy53aWR0aCxcblx0XHRcdFx0XHRcdFx0Ym91bmRzLmhlaWdodCwgdGhpcywgJ3NldEJvdW5kcycpXG5cdFx0XHRcdFx0OiBib3VuZHM7XG5cdFx0fTtcblx0fSxcbntcblx0YmVhbnM6IHRydWUsXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgsIGNhY2hlSXRlbSkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmICghY2hpbGRyZW4gfHwgY2hpbGRyZW4ubGVuZ3RoID09IDApXG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSgpO1xuXHRcdEl0ZW0uX3VwZGF0ZUJvdW5kc0NhY2hlKHRoaXMsIGNhY2hlSXRlbSk7XG5cdFx0dmFyIHgxID0gSW5maW5pdHksXG5cdFx0XHR4MiA9IC14MSxcblx0XHRcdHkxID0geDEsXG5cdFx0XHR5MiA9IHgyO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXTtcblx0XHRcdGlmIChjaGlsZC5fdmlzaWJsZSAmJiAhY2hpbGQuaXNFbXB0eSgpKSB7XG5cdFx0XHRcdHZhciByZWN0ID0gY2hpbGQuX2dldENhY2hlZEJvdW5kcyhnZXR0ZXIsXG5cdFx0XHRcdFx0XHRtYXRyaXggJiYgbWF0cml4LmNoYWluKGNoaWxkLl9tYXRyaXgpLCBjYWNoZUl0ZW0pO1xuXHRcdFx0XHR4MSA9IE1hdGgubWluKHJlY3QueCwgeDEpO1xuXHRcdFx0XHR5MSA9IE1hdGgubWluKHJlY3QueSwgeTEpO1xuXHRcdFx0XHR4MiA9IE1hdGgubWF4KHJlY3QueCArIHJlY3Qud2lkdGgsIHgyKTtcblx0XHRcdFx0eTIgPSBNYXRoLm1heChyZWN0LnkgKyByZWN0LmhlaWdodCwgeTIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gaXNGaW5pdGUoeDEpXG5cdFx0XHRcdD8gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpXG5cdFx0XHRcdDogbmV3IFJlY3RhbmdsZSgpO1xuXHR9LFxuXG5cdHNldEJvdW5kczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Ym91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKSxcblx0XHRcdGNlbnRlciA9IHJlY3QuZ2V0Q2VudGVyKCk7XG5cdFx0bWF0cml4LnRyYW5zbGF0ZShjZW50ZXIpO1xuXHRcdGlmIChyZWN0LndpZHRoICE9IGJvdW5kcy53aWR0aCB8fCByZWN0LmhlaWdodCAhPSBib3VuZHMuaGVpZ2h0KSB7XG5cdFx0XHRtYXRyaXguc2NhbGUoXG5cdFx0XHRcdFx0Ym91bmRzLndpZHRoICE9IDAgPyByZWN0LndpZHRoIC8gYm91bmRzLndpZHRoIDogMSxcblx0XHRcdFx0XHRib3VuZHMuaGVpZ2h0ICE9IDAgPyByZWN0LmhlaWdodCAvIGJvdW5kcy5oZWlnaHQgOiAxKTtcblx0XHR9XG5cdFx0Y2VudGVyID0gYm91bmRzLmdldENlbnRlcigpO1xuXHRcdG1hdHJpeC50cmFuc2xhdGUoLWNlbnRlci54LCAtY2VudGVyLnkpO1xuXHRcdHRoaXMudHJhbnNmb3JtKG1hdHJpeCk7XG5cdH0sXG5cblx0X2dldENhY2hlZEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgsIGNhY2hlSXRlbSwgaW50ZXJuYWxHZXR0ZXIpIHtcblx0XHRtYXRyaXggPSBtYXRyaXggJiYgbWF0cml4Lm9yTnVsbElmSWRlbnRpdHkoKTtcblx0XHR2YXIgX21hdHJpeCA9IGludGVybmFsR2V0dGVyID8gbnVsbCA6IHRoaXMuX21hdHJpeC5vck51bGxJZklkZW50aXR5KCksXG5cdFx0XHRjYWNoZSA9ICghbWF0cml4IHx8IG1hdHJpeC5lcXVhbHMoX21hdHJpeCkpICYmIGdldHRlcjtcblx0XHRJdGVtLl91cGRhdGVCb3VuZHNDYWNoZSh0aGlzLl9wYXJlbnQgfHwgdGhpcy5fcGFyZW50U3ltYm9sLCBjYWNoZUl0ZW0pO1xuXHRcdGlmIChjYWNoZSAmJiB0aGlzLl9ib3VuZHMgJiYgdGhpcy5fYm91bmRzW2NhY2hlXSlcblx0XHRcdHJldHVybiB0aGlzLl9ib3VuZHNbY2FjaGVdLmNsb25lKCk7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2dldEJvdW5kcyhpbnRlcm5hbEdldHRlciB8fCBnZXR0ZXIsXG5cdFx0XHRcdG1hdHJpeCB8fCBfbWF0cml4LCBjYWNoZUl0ZW0pO1xuXHRcdGlmIChjYWNoZSkge1xuXHRcdFx0aWYgKCF0aGlzLl9ib3VuZHMpXG5cdFx0XHRcdHRoaXMuX2JvdW5kcyA9IHt9O1xuXHRcdFx0dmFyIGNhY2hlZCA9IHRoaXMuX2JvdW5kc1tjYWNoZV0gPSBib3VuZHMuY2xvbmUoKTtcblx0XHRcdGNhY2hlZC5faW50ZXJuYWwgPSAhIWludGVybmFsR2V0dGVyO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRfdXBkYXRlQm91bmRzQ2FjaGU6IGZ1bmN0aW9uKHBhcmVudCwgaXRlbSkge1xuXHRcdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0XHR2YXIgaWQgPSBpdGVtLl9pZCxcblx0XHRcdFx0XHRyZWYgPSBwYXJlbnQuX2JvdW5kc0NhY2hlID0gcGFyZW50Ll9ib3VuZHNDYWNoZSB8fCB7XG5cdFx0XHRcdFx0XHRpZHM6IHt9LFxuXHRcdFx0XHRcdFx0bGlzdDogW11cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoIXJlZi5pZHNbaWRdKSB7XG5cdFx0XHRcdFx0cmVmLmxpc3QucHVzaChpdGVtKTtcblx0XHRcdFx0XHRyZWYuaWRzW2lkXSA9IGl0ZW07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2NsZWFyQm91bmRzQ2FjaGU6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRcdHZhciBjYWNoZSA9IGl0ZW0uX2JvdW5kc0NhY2hlO1xuXHRcdFx0aWYgKGNhY2hlKSB7XG5cdFx0XHRcdGl0ZW0uX2JvdW5kcyA9IGl0ZW0uX3Bvc2l0aW9uID0gaXRlbS5fYm91bmRzQ2FjaGUgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsaXN0ID0gY2FjaGUubGlzdCwgbCA9IGxpc3QubGVuZ3RoOyBpIDwgbDsgaSsrKXtcblx0XHRcdFx0XHR2YXIgb3RoZXIgPSBsaXN0W2ldO1xuXHRcdFx0XHRcdGlmIChvdGhlciAhPT0gaXRlbSkge1xuXHRcdFx0XHRcdFx0b3RoZXIuX2JvdW5kcyA9IG90aGVyLl9wb3NpdGlvbiA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGlmIChvdGhlci5fYm91bmRzQ2FjaGUpXG5cdFx0XHRcdFx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUob3RoZXIpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG59KSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRfZGVjb21wb3NlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGVjb21wb3NlZCA9IHRoaXMuX21hdHJpeC5kZWNvbXBvc2UoKTtcblx0fSxcblxuXHRnZXRSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkIHx8IHRoaXMuX2RlY29tcG9zZSgpO1xuXHRcdHJldHVybiBkZWNvbXBvc2VkICYmIGRlY29tcG9zZWQucm90YXRpb247XG5cdH0sXG5cblx0c2V0Um90YXRpb246IGZ1bmN0aW9uKHJvdGF0aW9uKSB7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldFJvdGF0aW9uKCk7XG5cdFx0aWYgKGN1cnJlbnQgIT0gbnVsbCAmJiByb3RhdGlvbiAhPSBudWxsKSB7XG5cdFx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQ7XG5cdFx0XHR0aGlzLnJvdGF0ZShyb3RhdGlvbiAtIGN1cnJlbnQpO1xuXHRcdFx0ZGVjb21wb3NlZC5yb3RhdGlvbiA9IHJvdGF0aW9uO1xuXHRcdFx0dGhpcy5fZGVjb21wb3NlZCA9IGRlY29tcG9zZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFNjYWxpbmc6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZCB8fCB0aGlzLl9kZWNvbXBvc2UoKSxcblx0XHRcdHNjYWxpbmcgPSBkZWNvbXBvc2VkICYmIGRlY29tcG9zZWQuc2NhbGluZyxcblx0XHRcdGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdHJldHVybiBzY2FsaW5nICYmIG5ldyBjdG9yKHNjYWxpbmcueCwgc2NhbGluZy55LCB0aGlzLCAnc2V0U2NhbGluZycpO1xuXHR9LFxuXG5cdHNldFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRTY2FsaW5nKCk7XG5cdFx0aWYgKGN1cnJlbnQpIHtcblx0XHRcdHZhciBzY2FsaW5nID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHsgY2xvbmU6IHRydWUgfSksXG5cdFx0XHRcdGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkO1xuXHRcdFx0dGhpcy5zY2FsZShzY2FsaW5nLnggLyBjdXJyZW50LngsIHNjYWxpbmcueSAvIGN1cnJlbnQueSk7XG5cdFx0XHRkZWNvbXBvc2VkLnNjYWxpbmcgPSBzY2FsaW5nO1xuXHRcdFx0dGhpcy5fZGVjb21wb3NlZCA9IGRlY29tcG9zZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGdldE1hdHJpeDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeDtcblx0fSxcblxuXHRzZXRNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXg7XG5cdFx0bWF0cml4LmluaXRpYWxpemUuYXBwbHkobWF0cml4LCBhcmd1bWVudHMpO1xuXHRcdGlmICh0aGlzLl9hcHBseU1hdHJpeCkge1xuXHRcdFx0dGhpcy50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEdsb2JhbE1hdHJpeDogZnVuY3Rpb24oX2RvbnRDbG9uZSkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9nbG9iYWxNYXRyaXgsXG5cdFx0XHR1cGRhdGVWZXJzaW9uID0gdGhpcy5fcHJvamVjdC5fdXBkYXRlVmVyc2lvbjtcblx0XHRpZiAobWF0cml4ICYmIG1hdHJpeC5fdXBkYXRlVmVyc2lvbiAhPT0gdXBkYXRlVmVyc2lvbilcblx0XHRcdG1hdHJpeCA9IG51bGw7XG5cdFx0aWYgKCFtYXRyaXgpIHtcblx0XHRcdG1hdHJpeCA9IHRoaXMuX2dsb2JhbE1hdHJpeCA9IHRoaXMuX21hdHJpeC5jbG9uZSgpO1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRcdGlmIChwYXJlbnQpXG5cdFx0XHRcdG1hdHJpeC5wcmVDb25jYXRlbmF0ZShwYXJlbnQuZ2V0R2xvYmFsTWF0cml4KHRydWUpKTtcblx0XHRcdG1hdHJpeC5fdXBkYXRlVmVyc2lvbiA9IHVwZGF0ZVZlcnNpb247XG5cdFx0fVxuXHRcdHJldHVybiBfZG9udENsb25lID8gbWF0cml4IDogbWF0cml4LmNsb25lKCk7XG5cdH0sXG5cblx0Z2V0QXBwbHlNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9hcHBseU1hdHJpeDtcblx0fSxcblxuXHRzZXRBcHBseU1hdHJpeDogZnVuY3Rpb24oYXBwbHkpIHtcblx0XHRpZiAodGhpcy5fYXBwbHlNYXRyaXggPSB0aGlzLl9jYW5BcHBseU1hdHJpeCAmJiAhIWFwcGx5KVxuXHRcdFx0dGhpcy50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG5cdH0sXG5cblx0Z2V0VHJhbnNmb3JtQ29udGVudDogJyNnZXRBcHBseU1hdHJpeCcsXG5cdHNldFRyYW5zZm9ybUNvbnRlbnQ6ICcjc2V0QXBwbHlNYXRyaXgnLFxufSwge1xuXHRnZXRQcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdDtcblx0fSxcblxuXHRfc2V0UHJvamVjdDogZnVuY3Rpb24ocHJvamVjdCwgaW5zdGFsbEV2ZW50cykge1xuXHRcdGlmICh0aGlzLl9wcm9qZWN0ICE9PSBwcm9qZWN0KSB7XG5cdFx0XHRpZiAodGhpcy5fcHJvamVjdClcblx0XHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHR0aGlzLl9wcm9qZWN0ID0gcHJvamVjdDtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLl9zZXRQcm9qZWN0KHByb2plY3QpO1xuXHRcdFx0aW5zdGFsbEV2ZW50cyA9IHRydWU7XG5cdFx0fVxuXHRcdGlmIChpbnN0YWxsRXZlbnRzKVxuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyh0cnVlKTtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdC5nZXRWaWV3KCk7XG5cdH0sXG5cblx0X2luc3RhbGxFdmVudHM6IGZ1bmN0aW9uIF9pbnN0YWxsRXZlbnRzKGluc3RhbGwpIHtcblx0XHRfaW5zdGFsbEV2ZW50cy5iYXNlLmNhbGwodGhpcywgaW5zdGFsbCk7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRjaGlsZHJlbltpXS5faW5zdGFsbEV2ZW50cyhpbnN0YWxsKTtcblx0fSxcblxuXHRnZXRMYXllcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXM7XG5cdFx0d2hpbGUgKHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50IGluc3RhbmNlb2YgTGF5ZXIpXG5cdFx0XHRcdHJldHVybiBwYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldFBhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudDtcblx0fSxcblxuXHRzZXRQYXJlbnQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbS5hZGRDaGlsZCh0aGlzKTtcblx0fSxcblxuXHRnZXRDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuO1xuXHR9LFxuXG5cdHNldENoaWxkcmVuOiBmdW5jdGlvbihpdGVtcykge1xuXHRcdHRoaXMucmVtb3ZlQ2hpbGRyZW4oKTtcblx0XHR0aGlzLmFkZENoaWxkcmVuKGl0ZW1zKTtcblx0fSxcblxuXHRnZXRGaXJzdENoaWxkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW5bMF0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRMYXN0Q2hpbGQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlblt0aGlzLl9jaGlsZHJlbi5sZW5ndGggLSAxXVxuXHRcdFx0XHR8fCBudWxsO1xuXHR9LFxuXG5cdGdldE5leHRTaWJsaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ICYmIHRoaXMuX3BhcmVudC5fY2hpbGRyZW5bdGhpcy5faW5kZXggKyAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzU2libGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuW3RoaXMuX2luZGV4IC0gMV0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4O1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtID09PSB0aGlzIHx8IGl0ZW0gJiYgdGhpcy5fY2xhc3MgPT09IGl0ZW0uX2NsYXNzXG5cdFx0XHRcdCYmIHRoaXMuX3N0eWxlLmVxdWFscyhpdGVtLl9zdHlsZSlcblx0XHRcdFx0JiYgdGhpcy5fbWF0cml4LmVxdWFscyhpdGVtLl9tYXRyaXgpXG5cdFx0XHRcdCYmIHRoaXMuX2xvY2tlZCA9PT0gaXRlbS5fbG9ja2VkXG5cdFx0XHRcdCYmIHRoaXMuX3Zpc2libGUgPT09IGl0ZW0uX3Zpc2libGVcblx0XHRcdFx0JiYgdGhpcy5fYmxlbmRNb2RlID09PSBpdGVtLl9ibGVuZE1vZGVcblx0XHRcdFx0JiYgdGhpcy5fb3BhY2l0eSA9PT0gaXRlbS5fb3BhY2l0eVxuXHRcdFx0XHQmJiB0aGlzLl9jbGlwTWFzayA9PT0gaXRlbS5fY2xpcE1hc2tcblx0XHRcdFx0JiYgdGhpcy5fZ3VpZGUgPT09IGl0ZW0uX2d1aWRlXG5cdFx0XHRcdCYmIHRoaXMuX2VxdWFscyhpdGVtKVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIEJhc2UuZXF1YWxzKHRoaXMuX2NoaWxkcmVuLCBpdGVtLl9jaGlsZHJlbik7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShuZXcgdGhpcy5jb25zdHJ1Y3RvcihJdGVtLk5PX0lOU0VSVCksIGluc2VydCk7XG5cdH0sXG5cblx0X2Nsb25lOiBmdW5jdGlvbihjb3B5LCBpbnNlcnQsIGluY2x1ZGVNYXRyaXgpIHtcblx0XHR2YXIga2V5cyA9IFsnX2xvY2tlZCcsICdfdmlzaWJsZScsICdfYmxlbmRNb2RlJywgJ19vcGFjaXR5Jyxcblx0XHRcdFx0J19jbGlwTWFzaycsICdfZ3VpZGUnXSxcblx0XHRcdGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Y29weS5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGNvcHkuYWRkQ2hpbGQoY2hpbGRyZW5baV0uY2xvbmUoZmFsc2UpLCB0cnVlKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBrZXlzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShrZXkpKVxuXHRcdFx0XHRjb3B5W2tleV0gPSB0aGlzW2tleV07XG5cdFx0fVxuXHRcdGlmIChpbmNsdWRlTWF0cml4ICE9PSBmYWxzZSlcblx0XHRcdGNvcHkuX21hdHJpeC5pbml0aWFsaXplKHRoaXMuX21hdHJpeCk7XG5cdFx0Y29weS5zZXRBcHBseU1hdHJpeCh0aGlzLl9hcHBseU1hdHJpeCk7XG5cdFx0Y29weS5zZXRQaXZvdCh0aGlzLl9waXZvdCk7XG5cdFx0Y29weS5zZXRTZWxlY3RlZCh0aGlzLl9zZWxlY3RlZCk7XG5cdFx0Y29weS5fZGF0YSA9IHRoaXMuX2RhdGEgPyBCYXNlLmNsb25lKHRoaXMuX2RhdGEpIDogbnVsbDtcblx0XHRpZiAoaW5zZXJ0IHx8IGluc2VydCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0Y29weS5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRpZiAodGhpcy5fbmFtZSlcblx0XHRcdGNvcHkuc2V0TmFtZSh0aGlzLl9uYW1lLCB0cnVlKTtcblx0XHRyZXR1cm4gY29weTtcblx0fSxcblxuXHRjb3B5VG86IGZ1bmN0aW9uKGl0ZW1PclByb2plY3QpIHtcblx0XHRyZXR1cm4gaXRlbU9yUHJvamVjdC5hZGRDaGlsZCh0aGlzLmNsb25lKGZhbHNlKSk7XG5cdH0sXG5cblx0cmFzdGVyaXplOiBmdW5jdGlvbihyZXNvbHV0aW9uKSB7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0U3Ryb2tlQm91bmRzKCksXG5cdFx0XHRzY2FsZSA9IChyZXNvbHV0aW9uIHx8IHRoaXMuZ2V0VmlldygpLmdldFJlc29sdXRpb24oKSkgLyA3Mixcblx0XHRcdHRvcExlZnQgPSBib3VuZHMuZ2V0VG9wTGVmdCgpLmZsb29yKCksXG5cdFx0XHRib3R0b21SaWdodCA9IGJvdW5kcy5nZXRCb3R0b21SaWdodCgpLmNlaWwoKSxcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShib3R0b21SaWdodC5zdWJ0cmFjdCh0b3BMZWZ0KSksXG5cdFx0XHRjYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZS5tdWx0aXBseShzY2FsZSkpLFxuXHRcdFx0Y3R4ID0gY2FudmFzLmdldENvbnRleHQoJzJkJyksXG5cdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkuc2NhbGUoc2NhbGUpLnRyYW5zbGF0ZSh0b3BMZWZ0Lm5lZ2F0ZSgpKTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdG1hdHJpeC5hcHBseVRvQ29udGV4dChjdHgpO1xuXHRcdHRoaXMuZHJhdyhjdHgsIG5ldyBCYXNlKHsgbWF0cmljZXM6IFttYXRyaXhdIH0pKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdHZhciByYXN0ZXIgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRyYXN0ZXIuc2V0Q2FudmFzKGNhbnZhcyk7XG5cdFx0cmFzdGVyLnRyYW5zZm9ybShuZXcgTWF0cml4KCkudHJhbnNsYXRlKHRvcExlZnQuYWRkKHNpemUuZGl2aWRlKDIpKSlcblx0XHRcdFx0LnNjYWxlKDEgLyBzY2FsZSkpO1xuXHRcdHJhc3Rlci5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRyZXR1cm4gcmFzdGVyO1xuXHR9LFxuXG5cdGNvbnRhaW5zOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9jb250YWlucyhcblx0XHRcdFx0dGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpO1xuXHR9LFxuXG5cdF9jb250YWluczogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRpZiAodGhpcy5fY2hpbGRyZW4pIHtcblx0XHRcdGZvciAodmFyIGkgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAodGhpcy5fY2hpbGRyZW5baV0uY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gcG9pbnQuaXNJbnNpZGUodGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpKTtcblx0fSxcblxuXHRpc0luc2lkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykuY29udGFpbnModGhpcy5nZXRCb3VuZHMoKSk7XG5cdH0sXG5cblx0X2FzUGF0aEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUGF0aC5SZWN0YW5nbGUoe1xuXHRcdFx0cmVjdGFuZ2xlOiB0aGlzLmdldEludGVybmFsQm91bmRzKCksXG5cdFx0XHRtYXRyaXg6IHRoaXMuX21hdHJpeCxcblx0XHRcdGluc2VydDogZmFsc2UsXG5cdFx0fSk7XG5cdH0sXG5cblx0aW50ZXJzZWN0czogZnVuY3Rpb24oaXRlbSwgX21hdHJpeCkge1xuXHRcdGlmICghKGl0ZW0gaW5zdGFuY2VvZiBJdGVtKSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRyZXR1cm4gdGhpcy5fYXNQYXRoSXRlbSgpLmdldEludGVyc2VjdGlvbnMoaXRlbS5fYXNQYXRoSXRlbSgpLCBudWxsLFxuXHRcdFx0XHRfbWF0cml4IHx8IGl0ZW0uX21hdHJpeCwgdHJ1ZSkubGVuZ3RoID4gMDtcblx0fSxcblxuXHRoaXRUZXN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faGl0VGVzdChcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRIaXRSZXN1bHQuZ2V0T3B0aW9ucyhCYXNlLnJlYWQoYXJndW1lbnRzKSkpO1xuXHR9LFxuXG5cdF9oaXRUZXN0OiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuXHRcdGlmICh0aGlzLl9sb2NrZWQgfHwgIXRoaXMuX3Zpc2libGUgfHwgdGhpcy5fZ3VpZGUgJiYgIW9wdGlvbnMuZ3VpZGVzXG5cdFx0XHRcdHx8IHRoaXMuaXNFbXB0eSgpKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0cGFyZW50VG90YWxNYXRyaXggPSBvcHRpb25zLl90b3RhbE1hdHJpeCxcblx0XHRcdHZpZXcgPSB0aGlzLmdldFZpZXcoKSxcblx0XHRcdHRvdGFsTWF0cml4ID0gb3B0aW9ucy5fdG90YWxNYXRyaXggPSBwYXJlbnRUb3RhbE1hdHJpeFxuXHRcdFx0XHRcdD8gcGFyZW50VG90YWxNYXRyaXguY2hhaW4obWF0cml4KVxuXHRcdFx0XHRcdDogdGhpcy5nZXRHbG9iYWxNYXRyaXgoKS5wcmVDb25jYXRlbmF0ZSh2aWV3Ll9tYXRyaXgpLFxuXHRcdFx0dG9sZXJhbmNlUGFkZGluZyA9IG9wdGlvbnMuX3RvbGVyYW5jZVBhZGRpbmcgPSBuZXcgU2l6ZShcblx0XHRcdFx0XHRcdFBhdGguX2dldFBlblBhZGRpbmcoMSwgdG90YWxNYXRyaXguaW52ZXJ0ZWQoKSlcblx0XHRcdFx0XHQpLm11bHRpcGx5KFxuXHRcdFx0XHRcdFx0TWF0aC5tYXgob3B0aW9ucy50b2xlcmFuY2UsIDFlLTYpXG5cdFx0XHRcdFx0KTtcblx0XHRwb2ludCA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShwb2ludCk7XG5cblx0XHRpZiAoIXRoaXMuX2NoaWxkcmVuICYmICF0aGlzLmdldEludGVybmFsUm91Z2hCb3VuZHMoKVxuXHRcdFx0XHQuZXhwYW5kKHRvbGVyYW5jZVBhZGRpbmcubXVsdGlwbHkoMikpLl9jb250YWluc1BvaW50KHBvaW50KSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdHZhciBjaGVja1NlbGYgPSAhKG9wdGlvbnMuZ3VpZGVzICYmICF0aGlzLl9ndWlkZVxuXHRcdFx0XHR8fCBvcHRpb25zLnNlbGVjdGVkICYmICF0aGlzLl9zZWxlY3RlZFxuXHRcdFx0XHR8fCBvcHRpb25zLnR5cGUgJiYgb3B0aW9ucy50eXBlICE9PSBCYXNlLmh5cGhlbmF0ZSh0aGlzLl9jbGFzcylcblx0XHRcdFx0fHwgb3B0aW9ucy5jbGFzcyAmJiAhKHRoaXMgaW5zdGFuY2VvZiBvcHRpb25zLmNsYXNzKSksXG5cdFx0XHR0aGF0ID0gdGhpcyxcblx0XHRcdHJlcztcblxuXHRcdGZ1bmN0aW9uIGNoZWNrQm91bmRzKHR5cGUsIHBhcnQpIHtcblx0XHRcdHZhciBwdCA9IGJvdW5kc1snZ2V0JyArIHBhcnRdKCk7XG5cdFx0XHRpZiAocG9pbnQuc3VidHJhY3QocHQpLmRpdmlkZSh0b2xlcmFuY2VQYWRkaW5nKS5sZW5ndGggPD0gMSlcblx0XHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQodHlwZSwgdGhhdCxcblx0XHRcdFx0XHRcdHsgbmFtZTogQmFzZS5oeXBoZW5hdGUocGFydCksIHBvaW50OiBwdCB9KTtcblx0XHR9XG5cblx0XHRpZiAoY2hlY2tTZWxmICYmIChvcHRpb25zLmNlbnRlciB8fCBvcHRpb25zLmJvdW5kcykgJiYgdGhpcy5fcGFyZW50KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpO1xuXHRcdFx0aWYgKG9wdGlvbnMuY2VudGVyKVxuXHRcdFx0XHRyZXMgPSBjaGVja0JvdW5kcygnY2VudGVyJywgJ0NlbnRlcicpO1xuXHRcdFx0aWYgKCFyZXMgJiYgb3B0aW9ucy5ib3VuZHMpIHtcblx0XHRcdFx0dmFyIHBvaW50cyA9IFtcblx0XHRcdFx0XHQnVG9wTGVmdCcsICdUb3BSaWdodCcsICdCb3R0b21MZWZ0JywgJ0JvdHRvbVJpZ2h0Jyxcblx0XHRcdFx0XHQnTGVmdENlbnRlcicsICdUb3BDZW50ZXInLCAnUmlnaHRDZW50ZXInLCAnQm90dG9tQ2VudGVyJ1xuXHRcdFx0XHRdO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDggJiYgIXJlczsgaSsrKVxuXHRcdFx0XHRcdHJlcyA9IGNoZWNrQm91bmRzKCdib3VuZHMnLCBwb2ludHNbaV0pO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBjaGlsZHJlbiA9ICFyZXMgJiYgdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHR2YXIgb3B0cyA9IHRoaXMuX2dldENoaWxkSGl0VGVzdE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHRmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwICYmICFyZXM7IGktLSlcblx0XHRcdFx0cmVzID0gY2hpbGRyZW5baV0uX2hpdFRlc3QocG9pbnQsIG9wdHMpO1xuXHRcdH1cblx0XHRpZiAoIXJlcyAmJiBjaGVja1NlbGYpXG5cdFx0XHRyZXMgPSB0aGlzLl9oaXRUZXN0U2VsZihwb2ludCwgb3B0aW9ucyk7XG5cdFx0aWYgKHJlcyAmJiByZXMucG9pbnQpXG5cdFx0XHRyZXMucG9pbnQgPSBtYXRyaXgudHJhbnNmb3JtKHJlcy5wb2ludCk7XG5cdFx0b3B0aW9ucy5fdG90YWxNYXRyaXggPSBwYXJlbnRUb3RhbE1hdHJpeDtcblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdF9nZXRDaGlsZEhpdFRlc3RPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIG9wdGlvbnM7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuXHRcdGlmIChvcHRpb25zLmZpbGwgJiYgdGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5fY29udGFpbnMocG9pbnQpKVxuXHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQoJ2ZpbGwnLCB0aGlzKTtcblx0fSxcblxuXHRtYXRjaGVzOiBmdW5jdGlvbihuYW1lLCBjb21wYXJlKSB7XG5cdFx0ZnVuY3Rpb24gbWF0Y2hPYmplY3Qob2JqMSwgb2JqMikge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiBvYmoxKSB7XG5cdFx0XHRcdGlmIChvYmoxLmhhc093blByb3BlcnR5KGkpKSB7XG5cdFx0XHRcdFx0dmFyIHZhbDEgPSBvYmoxW2ldLFxuXHRcdFx0XHRcdFx0dmFsMiA9IG9iajJbaV07XG5cdFx0XHRcdFx0aWYgKEJhc2UuaXNQbGFpbk9iamVjdCh2YWwxKSAmJiBCYXNlLmlzUGxhaW5PYmplY3QodmFsMikpIHtcblx0XHRcdFx0XHRcdGlmICghbWF0Y2hPYmplY3QodmFsMSwgdmFsMikpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWwxLCB2YWwyKSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHZhciB0eXBlID0gdHlwZW9mIG5hbWU7XG5cdFx0aWYgKHR5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gbmFtZSkge1xuXHRcdFx0XHRpZiAobmFtZS5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICF0aGlzLm1hdGNoZXMoa2V5LCBuYW1lW2tleV0pKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdHJldHVybiBuYW1lKHRoaXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgdmFsdWUgPSAvXihlbXB0eXxlZGl0YWJsZSkkLy50ZXN0KG5hbWUpXG5cdFx0XHRcdFx0PyB0aGlzWydpcycgKyBCYXNlLmNhcGl0YWxpemUobmFtZSldKClcblx0XHRcdFx0XHQ6IG5hbWUgPT09ICd0eXBlJ1xuXHRcdFx0XHRcdFx0PyBCYXNlLmh5cGhlbmF0ZSh0aGlzLl9jbGFzcylcblx0XHRcdFx0XHRcdDogdGhpc1tuYW1lXTtcblx0XHRcdGlmICgvXihjb25zdHJ1Y3RvcnxjbGFzcykkLy50ZXN0KG5hbWUpKSB7XG5cdFx0XHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBjb21wYXJlKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKGNvbXBhcmUgaW5zdGFuY2VvZiBSZWdFeHApIHtcblx0XHRcdFx0aWYgKCFjb21wYXJlLnRlc3QodmFsdWUpKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIGNvbXBhcmUgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0aWYgKCFjb21wYXJlKHZhbHVlKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChjb21wYXJlKSkge1xuXHRcdFx0XHRpZiAoIW1hdGNoT2JqZWN0KGNvbXBhcmUsIHZhbHVlKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWx1ZSwgY29tcGFyZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRnZXRJdGVtczogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5fY2hpbGRyZW4sIG1hdGNoLCB0aGlzLl9tYXRyaXgpO1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMuX2NoaWxkcmVuLCBtYXRjaCwgdGhpcy5fbWF0cml4LCBudWxsLCB0cnVlKVxuXHRcdFx0XHRbMF0gfHwgbnVsbDtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0X2dldEl0ZW1zOiBmdW5jdGlvbiBfZ2V0SXRlbXMoY2hpbGRyZW4sIG1hdGNoLCBtYXRyaXgsIHBhcmFtLFxuXHRcdFx0XHRmaXJzdE9ubHkpIHtcblx0XHRcdGlmICghcGFyYW0gJiYgdHlwZW9mIG1hdGNoID09PSAnb2JqZWN0Jykge1xuXHRcdFx0XHR2YXIgb3ZlcmxhcHBpbmcgPSBtYXRjaC5vdmVybGFwcGluZyxcblx0XHRcdFx0XHRpbnNpZGUgPSBtYXRjaC5pbnNpZGUsXG5cdFx0XHRcdFx0Ym91bmRzID0gb3ZlcmxhcHBpbmcgfHwgaW5zaWRlLFxuXHRcdFx0XHRcdHJlY3QgPSBib3VuZHMgJiYgUmVjdGFuZ2xlLnJlYWQoW2JvdW5kc10pO1xuXHRcdFx0XHRwYXJhbSA9IHtcblx0XHRcdFx0XHRpdGVtczogW10sXG5cdFx0XHRcdFx0aW5zaWRlOiAhIWluc2lkZSxcblx0XHRcdFx0XHRvdmVybGFwcGluZzogISFvdmVybGFwcGluZyxcblx0XHRcdFx0XHRyZWN0OiByZWN0LFxuXHRcdFx0XHRcdHBhdGg6IG92ZXJsYXBwaW5nICYmIG5ldyBQYXRoLlJlY3RhbmdsZSh7XG5cdFx0XHRcdFx0XHRyZWN0YW5nbGU6IHJlY3QsXG5cdFx0XHRcdFx0XHRpbnNlcnQ6IGZhbHNlXG5cdFx0XHRcdFx0fSlcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKGJvdW5kcylcblx0XHRcdFx0XHRtYXRjaCA9IEJhc2Uuc2V0KHt9LCBtYXRjaCxcblx0XHRcdFx0XHRcdFx0eyBpbnNpZGU6IHRydWUsIG92ZXJsYXBwaW5nOiB0cnVlIH0pO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGl0ZW1zID0gcGFyYW0gJiYgcGFyYW0uaXRlbXMsXG5cdFx0XHRcdHJlY3QgPSBwYXJhbSAmJiBwYXJhbS5yZWN0O1xuXHRcdFx0bWF0cml4ID0gcmVjdCAmJiAobWF0cml4IHx8IG5ldyBNYXRyaXgoKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSBjaGlsZHJlbltpXSxcblx0XHRcdFx0XHRjaGlsZE1hdHJpeCA9IG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oY2hpbGQuX21hdHJpeCksXG5cdFx0XHRcdFx0YWRkID0gdHJ1ZTtcblx0XHRcdFx0aWYgKHJlY3QpIHtcblx0XHRcdFx0XHR2YXIgYm91bmRzID0gY2hpbGQuZ2V0Qm91bmRzKGNoaWxkTWF0cml4KTtcblx0XHRcdFx0XHRpZiAoIXJlY3QuaW50ZXJzZWN0cyhib3VuZHMpKVxuXHRcdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdFx0aWYgKCEocGFyYW0uaW5zaWRlICYmIHJlY3QuY29udGFpbnMoYm91bmRzKSlcblx0XHRcdFx0XHRcdFx0JiYgIShwYXJhbS5vdmVybGFwcGluZyAmJiAoYm91bmRzLmNvbnRhaW5zKHJlY3QpXG5cdFx0XHRcdFx0XHRcdFx0fHwgcGFyYW0ucGF0aC5pbnRlcnNlY3RzKGNoaWxkLCBjaGlsZE1hdHJpeCkpKSlcblx0XHRcdFx0XHRcdGFkZCA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChhZGQgJiYgY2hpbGQubWF0Y2hlcyhtYXRjaCkpIHtcblx0XHRcdFx0XHRpdGVtcy5wdXNoKGNoaWxkKTtcblx0XHRcdFx0XHRpZiAoZmlyc3RPbmx5KVxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0X2dldEl0ZW1zKGNoaWxkLl9jaGlsZHJlbiwgbWF0Y2gsXG5cdFx0XHRcdFx0XHRjaGlsZE1hdHJpeCwgcGFyYW0sXG5cdFx0XHRcdFx0XHRmaXJzdE9ubHkpO1xuXHRcdFx0XHRpZiAoZmlyc3RPbmx5ICYmIGl0ZW1zLmxlbmd0aCA+IDApXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gaXRlbXM7XG5cdFx0fVxuXHR9XG59LCB7XG5cblx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbikge1xuXHRcdHZhciByZXMgPSBCYXNlLmltcG9ydEpTT04oanNvbiwgdGhpcyk7XG5cdFx0cmV0dXJuIHJlcyAhPT0gdGhpc1xuXHRcdFx0XHQ/IHRoaXMuYWRkQ2hpbGQocmVzKVxuXHRcdFx0XHQ6IHJlcztcblx0fSxcblxuXHRhZGRDaGlsZDogZnVuY3Rpb24oaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQodW5kZWZpbmVkLCBpdGVtLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdGluc2VydENoaWxkOiBmdW5jdGlvbihpbmRleCwgaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0dmFyIHJlcyA9IGl0ZW0gPyB0aGlzLmluc2VydENoaWxkcmVuKGluZGV4LCBbaXRlbV0sIF9wcmVzZXJ2ZSkgOiBudWxsO1xuXHRcdHJldHVybiByZXMgJiYgcmVzWzBdO1xuXHR9LFxuXG5cdGFkZENoaWxkcmVuOiBmdW5jdGlvbihpdGVtcywgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGRyZW4odGhpcy5fY2hpbGRyZW4ubGVuZ3RoLCBpdGVtcywgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRpbnNlcnRDaGlsZHJlbjogZnVuY3Rpb24oaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUsIF9wcm90bykge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbiAmJiBpdGVtcyAmJiBpdGVtcy5sZW5ndGggPiAwKSB7XG5cdFx0XHRpdGVtcyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5hcHBseShpdGVtcyk7XG5cdFx0XHRmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRcdFx0aWYgKF9wcm90byAmJiAhKGl0ZW0gaW5zdGFuY2VvZiBfcHJvdG8pKSB7XG5cdFx0XHRcdFx0aXRlbXMuc3BsaWNlKGksIDEpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBzaGlmdCA9IGl0ZW0uX3BhcmVudCA9PT0gdGhpcyAmJiBpdGVtLl9pbmRleCA8IGluZGV4O1xuXHRcdFx0XHRcdGlmIChpdGVtLl9yZW1vdmUoZmFsc2UsIHRydWUpICYmIHNoaWZ0KVxuXHRcdFx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0QmFzZS5zcGxpY2UoY2hpbGRyZW4sIGl0ZW1zLCBpbmRleCwgMCk7XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdG5vdGlmeVNlbGYgPSBwcm9qZWN0ICYmIHByb2plY3QuX2NoYW5nZXM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0XHRpdGVtLl9wYXJlbnQgPSB0aGlzO1xuXHRcdFx0XHRpdGVtLl9zZXRQcm9qZWN0KHRoaXMuX3Byb2plY3QsIHRydWUpO1xuXHRcdFx0XHRpZiAoaXRlbS5fbmFtZSlcblx0XHRcdFx0XHRpdGVtLnNldE5hbWUoaXRlbS5fbmFtZSk7XG5cdFx0XHRcdGlmIChub3RpZnlTZWxmKVxuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZWQoNSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aXRlbXMgPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH0sXG5cblx0X2luc2VydFNpYmxpbmc6IGZ1bmN0aW9uKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50XG5cdFx0XHRcdD8gdGhpcy5fcGFyZW50Lmluc2VydENoaWxkKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpXG5cdFx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRpbnNlcnRBYm92ZTogZnVuY3Rpb24oaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIGl0ZW0uX2luc2VydFNpYmxpbmcoaXRlbS5faW5kZXggKyAxLCB0aGlzLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdGluc2VydEJlbG93OiBmdW5jdGlvbihpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gaXRlbS5faW5zZXJ0U2libGluZyhpdGVtLl9pbmRleCwgdGhpcywgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRzZW5kVG9CYWNrOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gKHRoaXMuX3BhcmVudCB8fCB0aGlzIGluc3RhbmNlb2YgTGF5ZXIgJiYgdGhpcy5fcHJvamVjdClcblx0XHRcdFx0Lmluc2VydENoaWxkKDAsIHRoaXMpO1xuXHR9LFxuXG5cdGJyaW5nVG9Gcm9udDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9wYXJlbnQgfHwgdGhpcyBpbnN0YW5jZW9mIExheWVyICYmIHRoaXMuX3Byb2plY3QpXG5cdFx0XHRcdC5hZGRDaGlsZCh0aGlzKTtcblx0fSxcblxuXHRhcHBlbmRUb3A6ICcjYWRkQ2hpbGQnLFxuXG5cdGFwcGVuZEJvdHRvbTogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKDAsIGl0ZW0pO1xuXHR9LFxuXG5cdG1vdmVBYm92ZTogJyNpbnNlcnRBYm92ZScsXG5cblx0bW92ZUJlbG93OiAnI2luc2VydEJlbG93JyxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbiAmJiB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPT09IDEpIHtcblx0XHRcdHZhciBjaGlsZCA9IHRoaXMuX2NoaWxkcmVuWzBdLnJlZHVjZSgpO1xuXHRcdFx0Y2hpbGQuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0XHRjaGlsZC5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdFx0cmV0dXJuIGNoaWxkO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfcmVtb3ZlTmFtZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbixcblx0XHRcdFx0bmFtZWRDaGlsZHJlbiA9IHBhcmVudC5fbmFtZWRDaGlsZHJlbixcblx0XHRcdFx0bmFtZSA9IHRoaXMuX25hbWUsXG5cdFx0XHRcdG5hbWVkQXJyYXkgPSBuYW1lZENoaWxkcmVuW25hbWVdLFxuXHRcdFx0XHRpbmRleCA9IG5hbWVkQXJyYXkgPyBuYW1lZEFycmF5LmluZGV4T2YodGhpcykgOiAtMTtcblx0XHRcdGlmIChpbmRleCAhPT0gLTEpIHtcblx0XHRcdFx0aWYgKGNoaWxkcmVuW25hbWVdID09IHRoaXMpXG5cdFx0XHRcdFx0ZGVsZXRlIGNoaWxkcmVuW25hbWVdO1xuXHRcdFx0XHRuYW1lZEFycmF5LnNwbGljZShpbmRleCwgMSk7XG5cdFx0XHRcdGlmIChuYW1lZEFycmF5Lmxlbmd0aCkge1xuXHRcdFx0XHRcdGNoaWxkcmVuW25hbWVdID0gbmFtZWRBcnJheVtuYW1lZEFycmF5Lmxlbmd0aCAtIDFdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGRlbGV0ZSBuYW1lZENoaWxkcmVuW25hbWVdO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9yZW1vdmU6IGZ1bmN0aW9uKG5vdGlmeVNlbGYsIG5vdGlmeVBhcmVudCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCkge1xuXHRcdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHRcdHRoaXMuX3JlbW92ZU5hbWVkKCk7XG5cdFx0XHRpZiAodGhpcy5faW5kZXggIT0gbnVsbClcblx0XHRcdFx0QmFzZS5zcGxpY2UocGFyZW50Ll9jaGlsZHJlbiwgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHRpZiAobm90aWZ5U2VsZikge1xuXHRcdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0XHRcdGlmIChwcm9qZWN0ICYmIHByb2plY3QuX2NoYW5nZXMpXG5cdFx0XHRcdFx0dGhpcy5fY2hhbmdlZCg1KTtcblx0XHRcdH1cblx0XHRcdGlmIChub3RpZnlQYXJlbnQpXG5cdFx0XHRcdHBhcmVudC5fY2hhbmdlZCgxMSk7XG5cdFx0XHR0aGlzLl9wYXJlbnQgPSBudWxsO1xuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yZW1vdmUodHJ1ZSwgdHJ1ZSk7XG5cdH0sXG5cblx0cmVwbGFjZVdpdGg6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgb2sgPSBpdGVtICYmIGl0ZW0uaW5zZXJ0QmVsb3codGhpcyk7XG5cdFx0aWYgKG9rKVxuXHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHRyZXR1cm4gb2s7XG5cdH0sXG5cblx0cmVtb3ZlQ2hpbGRyZW46IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0aWYgKCF0aGlzLl9jaGlsZHJlbilcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGZyb20gPSBmcm9tIHx8IDA7XG5cdFx0dG8gPSBCYXNlLnBpY2sodG8sIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCk7XG5cdFx0dmFyIHJlbW92ZWQgPSBCYXNlLnNwbGljZSh0aGlzLl9jaGlsZHJlbiwgbnVsbCwgZnJvbSwgdG8gLSBmcm9tKTtcblx0XHRmb3IgKHZhciBpID0gcmVtb3ZlZC5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0cmVtb3ZlZFtpXS5fcmVtb3ZlKHRydWUsIGZhbHNlKTtcblx0XHR9XG5cdFx0aWYgKHJlbW92ZWQubGVuZ3RoID4gMClcblx0XHRcdHRoaXMuX2NoYW5nZWQoMTEpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZUNoaWxkcmVuJyxcblxuXHRyZXZlcnNlQ2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jaGlsZHJlbikge1xuXHRcdFx0dGhpcy5fY2hpbGRyZW4ucmV2ZXJzZSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX2NoaWxkcmVuW2ldLl9pbmRleCA9IGk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHR9XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jaGlsZHJlbiB8fCB0aGlzLl9jaGlsZHJlbi5sZW5ndGggPT09IDA7XG5cdH0sXG5cblx0aXNFZGl0YWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGl0ZW0gPSB0aGlzO1xuXHRcdHdoaWxlIChpdGVtKSB7XG5cdFx0XHRpZiAoIWl0ZW0uX3Zpc2libGUgfHwgaXRlbS5fbG9ja2VkKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRpdGVtID0gaXRlbS5fcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRoYXNGaWxsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc0ZpbGwoKTtcblx0fSxcblxuXHRoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFN0eWxlKCkuaGFzU3Ryb2tlKCk7XG5cdH0sXG5cblx0aGFzU2hhZG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc1NoYWRvdygpO1xuXHR9LFxuXG5cdF9nZXRPcmRlcjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdGZ1bmN0aW9uIGdldExpc3QoaXRlbSkge1xuXHRcdFx0dmFyIGxpc3QgPSBbXTtcblx0XHRcdGRvIHtcblx0XHRcdFx0bGlzdC51bnNoaWZ0KGl0ZW0pO1xuXHRcdFx0fSB3aGlsZSAoaXRlbSA9IGl0ZW0uX3BhcmVudCk7XG5cdFx0XHRyZXR1cm4gbGlzdDtcblx0XHR9XG5cdFx0dmFyIGxpc3QxID0gZ2V0TGlzdCh0aGlzKSxcblx0XHRcdGxpc3QyID0gZ2V0TGlzdChpdGVtKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IE1hdGgubWluKGxpc3QxLmxlbmd0aCwgbGlzdDIubGVuZ3RoKTsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKGxpc3QxW2ldICE9IGxpc3QyW2ldKSB7XG5cdFx0XHRcdHJldHVybiBsaXN0MVtpXS5faW5kZXggPCBsaXN0MltpXS5faW5kZXggPyAxIDogLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdGhhc0NoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID4gMDtcblx0fSxcblxuXHRpc0luc2VydGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gdGhpcy5fcGFyZW50LmlzSW5zZXJ0ZWQoKSA6IGZhbHNlO1xuXHR9LFxuXG5cdGlzQWJvdmU6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IC0xO1xuXHR9LFxuXG5cdGlzQmVsb3c6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fZ2V0T3JkZXIoaXRlbSkgPT09IDE7XG5cdH0sXG5cblx0aXNQYXJlbnQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID09PSBpdGVtO1xuXHR9LFxuXG5cdGlzQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSAmJiBpdGVtLl9wYXJlbnQgPT09IHRoaXM7XG5cdH0sXG5cblx0aXNEZXNjZW5kYW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXM7XG5cdFx0d2hpbGUgKHBhcmVudCA9IHBhcmVudC5fcGFyZW50KSB7XG5cdFx0XHRpZiAocGFyZW50ID09IGl0ZW0pXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aXNBbmNlc3RvcjogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBpdGVtID8gaXRlbS5pc0Rlc2NlbmRhbnQodGhpcykgOiBmYWxzZTtcblx0fSxcblxuXHRpc1NpYmxpbmc6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID09PSBpdGVtLl9wYXJlbnQ7XG5cdH0sXG5cblx0aXNHcm91cGVkV2l0aDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0d2hpbGUgKHBhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudC5fcGFyZW50XG5cdFx0XHRcdCYmIC9eKEdyb3VwfExheWVyfENvbXBvdW5kUGF0aCkkLy50ZXN0KHBhcmVudC5fY2xhc3MpXG5cdFx0XHRcdCYmIGl0ZW0uaXNEZXNjZW5kYW50KHBhcmVudCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRwYXJlbnQgPSBwYXJlbnQuX3BhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG14ID0gbmV3IE1hdHJpeCgpO1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybShteC50cmFuc2xhdGUuYXBwbHkobXgsIGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS5yb3RhdGUoYW5nbGUsXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJndW1lbnRzLCAxLCB7IHJlYWROdWxsOiB0cnVlIH0pXG5cdFx0XHRcdFx0fHwgdGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuXHR9XG59LCBCYXNlLmVhY2goWydzY2FsZScsICdzaGVhcicsICdza2V3J10sIGZ1bmN0aW9uKG5hbWUpIHtcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybShuZXcgTWF0cml4KClbbmFtZV0ocG9pbnQsXG5cdFx0XHRcdGNlbnRlciB8fCB0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH07XG59LCB7XG5cbn0pLCB7XG5cdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4LCBfYXBwbHlNYXRyaXgsIF9hcHBseVJlY3Vyc2l2ZWx5LFxuXHRcdFx0X3NldEFwcGx5TWF0cml4KSB7XG5cdFx0aWYgKG1hdHJpeCAmJiBtYXRyaXguaXNJZGVudGl0eSgpKVxuXHRcdFx0bWF0cml4ID0gbnVsbDtcblx0XHR2YXIgX21hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdGFwcGx5TWF0cml4ID0gKF9hcHBseU1hdHJpeCB8fCB0aGlzLl9hcHBseU1hdHJpeClcblx0XHRcdFx0XHQmJiAoKCFfbWF0cml4LmlzSWRlbnRpdHkoKSB8fCBtYXRyaXgpXG5cdFx0XHRcdFx0XHR8fCBfYXBwbHlNYXRyaXggJiYgX2FwcGx5UmVjdXJzaXZlbHkgJiYgdGhpcy5fY2hpbGRyZW4pO1xuXHRcdGlmICghbWF0cml4ICYmICFhcHBseU1hdHJpeClcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdGlmIChtYXRyaXgpXG5cdFx0XHRfbWF0cml4LnByZUNvbmNhdGVuYXRlKG1hdHJpeCk7XG5cdFx0aWYgKGFwcGx5TWF0cml4ID0gYXBwbHlNYXRyaXggJiYgdGhpcy5fdHJhbnNmb3JtQ29udGVudChfbWF0cml4LFxuXHRcdFx0XHRcdF9hcHBseVJlY3Vyc2l2ZWx5LCBfc2V0QXBwbHlNYXRyaXgpKSB7XG5cdFx0XHR2YXIgcGl2b3QgPSB0aGlzLl9waXZvdCxcblx0XHRcdFx0c3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdFx0ZmlsbENvbG9yID0gc3R5bGUuZ2V0RmlsbENvbG9yKHRydWUpLFxuXHRcdFx0XHRzdHJva2VDb2xvciA9IHN0eWxlLmdldFN0cm9rZUNvbG9yKHRydWUpO1xuXHRcdFx0aWYgKHBpdm90KVxuXHRcdFx0XHRfbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwaXZvdCwgcGl2b3QsIHRydWUpO1xuXHRcdFx0aWYgKGZpbGxDb2xvcilcblx0XHRcdFx0ZmlsbENvbG9yLnRyYW5zZm9ybShfbWF0cml4KTtcblx0XHRcdGlmIChzdHJva2VDb2xvcilcblx0XHRcdFx0c3Ryb2tlQ29sb3IudHJhbnNmb3JtKF9tYXRyaXgpO1xuXHRcdFx0X21hdHJpeC5yZXNldCh0cnVlKTtcblx0XHRcdGlmIChfc2V0QXBwbHlNYXRyaXggJiYgdGhpcy5fY2FuQXBwbHlNYXRyaXgpXG5cdFx0XHRcdHRoaXMuX2FwcGx5TWF0cml4ID0gdHJ1ZTtcblx0XHR9XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kcyxcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb247XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0XHR2YXIgZGVjb21wID0gYm91bmRzICYmIG1hdHJpeCAmJiBtYXRyaXguZGVjb21wb3NlKCk7XG5cdFx0aWYgKGRlY29tcCAmJiAhZGVjb21wLnNoZWFyaW5nICYmIGRlY29tcC5yb3RhdGlvbiAlIDkwID09PSAwKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gYm91bmRzKSB7XG5cdFx0XHRcdHZhciByZWN0ID0gYm91bmRzW2tleV07XG5cdFx0XHRcdGlmIChhcHBseU1hdHJpeCB8fCAhcmVjdC5faW50ZXJuYWwpXG5cdFx0XHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCwgcmVjdCk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZ2V0dGVyID0gdGhpcy5fYm91bmRzR2V0dGVyLFxuXHRcdFx0XHRyZWN0ID0gYm91bmRzW2dldHRlciAmJiBnZXR0ZXIuZ2V0Qm91bmRzIHx8IGdldHRlciB8fCAnZ2V0Qm91bmRzJ107XG5cdFx0XHRpZiAocmVjdClcblx0XHRcdFx0dGhpcy5fcG9zaXRpb24gPSByZWN0LmdldENlbnRlcih0cnVlKTtcblx0XHRcdHRoaXMuX2JvdW5kcyA9IGJvdW5kcztcblx0XHR9IGVsc2UgaWYgKG1hdHJpeCAmJiBwb3NpdGlvbikge1xuXHRcdFx0dGhpcy5fcG9zaXRpb24gPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvc2l0aW9uLCBwb3NpdGlvbik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db250ZW50OiBmdW5jdGlvbihtYXRyaXgsIGFwcGx5UmVjdXJzaXZlbHksIHNldEFwcGx5TWF0cml4KSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0udHJhbnNmb3JtKG1hdHJpeCwgdHJ1ZSwgYXBwbHlSZWN1cnNpdmVseSxcblx0XHRcdFx0XHRcdHNldEFwcGx5TWF0cml4KTtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0fSxcblxuXHRnbG9iYWxUb0xvY2FsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkuX2ludmVyc2VUcmFuc2Zvcm0oXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0bG9jYWxUb0dsb2JhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpLl90cmFuc2Zvcm1Qb2ludChcblx0XHRcdFx0UG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRwYXJlbnRUb0xvY2FsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0bG9jYWxUb1BhcmVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRmaXRCb3VuZHM6IGZ1bmN0aW9uKHJlY3RhbmdsZSwgZmlsbCkge1xuXHRcdHJlY3RhbmdsZSA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG5cdFx0XHRpdGVtUmF0aW8gPSBib3VuZHMuaGVpZ2h0IC8gYm91bmRzLndpZHRoLFxuXHRcdFx0cmVjdFJhdGlvID0gcmVjdGFuZ2xlLmhlaWdodCAvIHJlY3RhbmdsZS53aWR0aCxcblx0XHRcdHNjYWxlID0gKGZpbGwgPyBpdGVtUmF0aW8gPiByZWN0UmF0aW8gOiBpdGVtUmF0aW8gPCByZWN0UmF0aW8pXG5cdFx0XHRcdFx0PyByZWN0YW5nbGUud2lkdGggLyBib3VuZHMud2lkdGhcblx0XHRcdFx0XHQ6IHJlY3RhbmdsZS5oZWlnaHQgLyBib3VuZHMuaGVpZ2h0LFxuXHRcdFx0bmV3Qm91bmRzID0gbmV3IFJlY3RhbmdsZShuZXcgUG9pbnQoKSxcblx0XHRcdFx0XHRuZXcgU2l6ZShib3VuZHMud2lkdGggKiBzY2FsZSwgYm91bmRzLmhlaWdodCAqIHNjYWxlKSk7XG5cdFx0bmV3Qm91bmRzLnNldENlbnRlcihyZWN0YW5nbGUuZ2V0Q2VudGVyKCkpO1xuXHRcdHRoaXMuc2V0Qm91bmRzKG5ld0JvdW5kcyk7XG5cdH0sXG5cblx0X3NldFN0eWxlczogZnVuY3Rpb24oY3R4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRmaWxsQ29sb3IgPSBzdHlsZS5nZXRGaWxsQ29sb3IoKSxcblx0XHRcdHN0cm9rZUNvbG9yID0gc3R5bGUuZ2V0U3Ryb2tlQ29sb3IoKSxcblx0XHRcdHNoYWRvd0NvbG9yID0gc3R5bGUuZ2V0U2hhZG93Q29sb3IoKTtcblx0XHRpZiAoZmlsbENvbG9yKVxuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZpbGxDb2xvci50b0NhbnZhc1N0eWxlKGN0eCk7XG5cdFx0aWYgKHN0cm9rZUNvbG9yKSB7XG5cdFx0XHR2YXIgc3Ryb2tlV2lkdGggPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpO1xuXHRcdFx0aWYgKHN0cm9rZVdpZHRoID4gMCkge1xuXHRcdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBzdHJva2VDb2xvci50b0NhbnZhc1N0eWxlKGN0eCk7XG5cdFx0XHRcdGN0eC5saW5lV2lkdGggPSBzdHJva2VXaWR0aDtcblx0XHRcdFx0dmFyIHN0cm9rZUpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCksXG5cdFx0XHRcdFx0c3Ryb2tlQ2FwID0gc3R5bGUuZ2V0U3Ryb2tlQ2FwKCksXG5cdFx0XHRcdFx0bWl0ZXJMaW1pdCA9IHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdFx0aWYgKHN0cm9rZUpvaW4pXG5cdFx0XHRcdFx0Y3R4LmxpbmVKb2luID0gc3Ryb2tlSm9pbjtcblx0XHRcdFx0aWYgKHN0cm9rZUNhcClcblx0XHRcdFx0XHRjdHgubGluZUNhcCA9IHN0cm9rZUNhcDtcblx0XHRcdFx0aWYgKG1pdGVyTGltaXQpXG5cdFx0XHRcdFx0Y3R4Lm1pdGVyTGltaXQgPSBtaXRlckxpbWl0O1xuXHRcdFx0XHRpZiAocGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoKSB7XG5cdFx0XHRcdFx0dmFyIGRhc2hBcnJheSA9IHN0eWxlLmdldERhc2hBcnJheSgpLFxuXHRcdFx0XHRcdFx0ZGFzaE9mZnNldCA9IHN0eWxlLmdldERhc2hPZmZzZXQoKTtcblx0XHRcdFx0XHRpZiAoZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGgpIHtcblx0XHRcdFx0XHRcdGlmICgnc2V0TGluZURhc2gnIGluIGN0eCkge1xuXHRcdFx0XHRcdFx0XHRjdHguc2V0TGluZURhc2goZGFzaEFycmF5KTtcblx0XHRcdFx0XHRcdFx0Y3R4LmxpbmVEYXNoT2Zmc2V0ID0gZGFzaE9mZnNldDtcblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGN0eC5tb3pEYXNoID0gZGFzaEFycmF5O1xuXHRcdFx0XHRcdFx0XHRjdHgubW96RGFzaE9mZnNldCA9IGRhc2hPZmZzZXQ7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChzaGFkb3dDb2xvcikge1xuXHRcdFx0dmFyIHNoYWRvd0JsdXIgPSBzdHlsZS5nZXRTaGFkb3dCbHVyKCk7XG5cdFx0XHRpZiAoc2hhZG93Qmx1ciA+IDApIHtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gc2hhZG93Q29sb3IudG9DYW52YXNTdHlsZShjdHgpO1xuXHRcdFx0XHRjdHguc2hhZG93Qmx1ciA9IHNoYWRvd0JsdXI7XG5cdFx0XHRcdHZhciBvZmZzZXQgPSB0aGlzLmdldFNoYWRvd09mZnNldCgpO1xuXHRcdFx0XHRjdHguc2hhZG93T2Zmc2V0WCA9IG9mZnNldC54O1xuXHRcdFx0XHRjdHguc2hhZG93T2Zmc2V0WSA9IG9mZnNldC55O1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRkcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCBwYXJlbnRTdHJva2VNYXRyaXgpIHtcblx0XHR2YXIgdXBkYXRlVmVyc2lvbiA9IHRoaXMuX3VwZGF0ZVZlcnNpb24gPSB0aGlzLl9wcm9qZWN0Ll91cGRhdGVWZXJzaW9uO1xuXHRcdGlmICghdGhpcy5fdmlzaWJsZSB8fCB0aGlzLl9vcGFjaXR5ID09PSAwKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBtYXRyaWNlcyA9IHBhcmFtLm1hdHJpY2VzLFxuXHRcdFx0dmlld01hdHJpeCA9IHBhcmFtLnZpZXdNYXRyaXgsXG5cdFx0XHRtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRnbG9iYWxNYXRyaXggPSBtYXRyaWNlc1ttYXRyaWNlcy5sZW5ndGggLSAxXS5jaGFpbihtYXRyaXgpO1xuXHRcdGlmICghZ2xvYmFsTWF0cml4LmlzSW52ZXJ0aWJsZSgpKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Vmlld01hdHJpeChtYXRyaXgpIHtcblx0XHRcdHJldHVybiB2aWV3TWF0cml4ID8gdmlld01hdHJpeC5jaGFpbihtYXRyaXgpIDogbWF0cml4O1xuXHRcdH1cblxuXHRcdG1hdHJpY2VzLnB1c2goZ2xvYmFsTWF0cml4KTtcblx0XHRpZiAocGFyYW0udXBkYXRlTWF0cml4KSB7XG5cdFx0XHRnbG9iYWxNYXRyaXguX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuXHRcdFx0dGhpcy5fZ2xvYmFsTWF0cml4ID0gZ2xvYmFsTWF0cml4O1xuXHRcdH1cblxuXHRcdHZhciBibGVuZE1vZGUgPSB0aGlzLl9ibGVuZE1vZGUsXG5cdFx0XHRvcGFjaXR5ID0gdGhpcy5fb3BhY2l0eSxcblx0XHRcdG5vcm1hbEJsZW5kID0gYmxlbmRNb2RlID09PSAnbm9ybWFsJyxcblx0XHRcdG5hdGl2ZUJsZW5kID0gQmxlbmRNb2RlLm5hdGl2ZU1vZGVzW2JsZW5kTW9kZV0sXG5cdFx0XHRkaXJlY3QgPSBub3JtYWxCbGVuZCAmJiBvcGFjaXR5ID09PSAxXG5cdFx0XHRcdFx0fHwgcGFyYW0uZG9udFN0YXJ0XG5cdFx0XHRcdFx0fHwgcGFyYW0uY2xpcFxuXHRcdFx0XHRcdHx8IChuYXRpdmVCbGVuZCB8fCBub3JtYWxCbGVuZCAmJiBvcGFjaXR5IDwgMSlcblx0XHRcdFx0XHRcdCYmIHRoaXMuX2NhbkNvbXBvc2l0ZSgpLFxuXHRcdFx0cGl4ZWxSYXRpbyA9IHBhcmFtLnBpeGVsUmF0aW8gfHwgMSxcblx0XHRcdG1haW5DdHgsIGl0ZW1PZmZzZXQsIHByZXZPZmZzZXQ7XG5cdFx0aWYgKCFkaXJlY3QpIHtcblx0XHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFN0cm9rZUJvdW5kcyhnZXRWaWV3TWF0cml4KGdsb2JhbE1hdHJpeCkpO1xuXHRcdFx0aWYgKCFib3VuZHMud2lkdGggfHwgIWJvdW5kcy5oZWlnaHQpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHByZXZPZmZzZXQgPSBwYXJhbS5vZmZzZXQ7XG5cdFx0XHRpdGVtT2Zmc2V0ID0gcGFyYW0ub2Zmc2V0ID0gYm91bmRzLmdldFRvcExlZnQoKS5mbG9vcigpO1xuXHRcdFx0bWFpbkN0eCA9IGN0eDtcblx0XHRcdGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoYm91bmRzLmdldFNpemUoKS5jZWlsKCkuYWRkKDEpXG5cdFx0XHRcdFx0Lm11bHRpcGx5KHBpeGVsUmF0aW8pKTtcblx0XHRcdGlmIChwaXhlbFJhdGlvICE9PSAxKVxuXHRcdFx0XHRjdHguc2NhbGUocGl4ZWxSYXRpbywgcGl4ZWxSYXRpbyk7XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0dmFyIHN0cm9rZU1hdHJpeCA9IHBhcmVudFN0cm9rZU1hdHJpeFxuXHRcdFx0XHQ/IHBhcmVudFN0cm9rZU1hdHJpeC5jaGFpbihtYXRyaXgpXG5cdFx0XHRcdDogIXRoaXMuZ2V0U3Ryb2tlU2NhbGluZyh0cnVlKSAmJiBnZXRWaWV3TWF0cml4KGdsb2JhbE1hdHJpeCksXG5cdFx0XHRjbGlwID0gIWRpcmVjdCAmJiBwYXJhbS5jbGlwSXRlbSxcblx0XHRcdHRyYW5zZm9ybSA9ICFzdHJva2VNYXRyaXggfHwgY2xpcDtcblx0XHRpZiAoZGlyZWN0KSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSBvcGFjaXR5O1xuXHRcdFx0aWYgKG5hdGl2ZUJsZW5kKVxuXHRcdFx0XHRjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gYmxlbmRNb2RlO1xuXHRcdH0gZWxzZSBpZiAodHJhbnNmb3JtKSB7XG5cdFx0XHRjdHgudHJhbnNsYXRlKC1pdGVtT2Zmc2V0LngsIC1pdGVtT2Zmc2V0LnkpO1xuXHRcdH1cblx0XHRpZiAodHJhbnNmb3JtKVxuXHRcdFx0KGRpcmVjdCA/IG1hdHJpeCA6IGdldFZpZXdNYXRyaXgoZ2xvYmFsTWF0cml4KSkuYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRpZiAoY2xpcClcblx0XHRcdHBhcmFtLmNsaXBJdGVtLmRyYXcoY3R4LCBwYXJhbS5leHRlbmQoeyBjbGlwOiB0cnVlIH0pKTtcblx0XHRpZiAoc3Ryb2tlTWF0cml4KSB7XG5cdFx0XHRjdHguc2V0VHJhbnNmb3JtKHBpeGVsUmF0aW8sIDAsIDAsIHBpeGVsUmF0aW8sIDAsIDApO1xuXHRcdFx0dmFyIG9mZnNldCA9IHBhcmFtLm9mZnNldDtcblx0XHRcdGlmIChvZmZzZXQpXG5cdFx0XHRcdGN0eC50cmFuc2xhdGUoLW9mZnNldC54LCAtb2Zmc2V0LnkpO1xuXHRcdH1cblx0XHR0aGlzLl9kcmF3KGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHRtYXRyaWNlcy5wb3AoKTtcblx0XHRpZiAocGFyYW0uY2xpcCAmJiAhcGFyYW0uZG9udEZpbmlzaClcblx0XHRcdGN0eC5jbGlwKCk7XG5cdFx0aWYgKCFkaXJlY3QpIHtcblx0XHRcdEJsZW5kTW9kZS5wcm9jZXNzKGJsZW5kTW9kZSwgY3R4LCBtYWluQ3R4LCBvcGFjaXR5LFxuXHRcdFx0XHRcdGl0ZW1PZmZzZXQuc3VidHJhY3QocHJldk9mZnNldCkubXVsdGlwbHkocGl4ZWxSYXRpbykpO1xuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZShjdHgpO1xuXHRcdFx0cGFyYW0ub2Zmc2V0ID0gcHJldk9mZnNldDtcblx0XHR9XG5cdH0sXG5cblx0X2lzVXBkYXRlZDogZnVuY3Rpb24odXBkYXRlVmVyc2lvbikge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aClcblx0XHRcdHJldHVybiBwYXJlbnQuX2lzVXBkYXRlZCh1cGRhdGVWZXJzaW9uKTtcblx0XHR2YXIgdXBkYXRlZCA9IHRoaXMuX3VwZGF0ZVZlcnNpb24gPT09IHVwZGF0ZVZlcnNpb247XG5cdFx0aWYgKCF1cGRhdGVkICYmIHBhcmVudCAmJiBwYXJlbnQuX3Zpc2libGVcblx0XHRcdFx0JiYgcGFyZW50Ll9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbikpIHtcblx0XHRcdHRoaXMuX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuXHRcdFx0dXBkYXRlZCA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiB1cGRhdGVkO1xuXHR9LFxuXG5cdF9kcmF3U2VsZWN0aW9uOiBmdW5jdGlvbihjdHgsIG1hdHJpeCwgc2l6ZSwgc2VsZWN0ZWRJdGVtcywgdXBkYXRlVmVyc2lvbikge1xuXHRcdGlmICgodGhpcy5fZHJhd1NlbGVjdGVkIHx8IHRoaXMuX2JvdW5kc1NlbGVjdGVkKVxuXHRcdFx0XHQmJiB0aGlzLl9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbikpIHtcblx0XHRcdHZhciBjb2xvciA9IHRoaXMuZ2V0U2VsZWN0ZWRDb2xvcih0cnVlKVxuXHRcdFx0XHRcdHx8IHRoaXMuZ2V0TGF5ZXIoKS5nZXRTZWxlY3RlZENvbG9yKHRydWUpLFxuXHRcdFx0XHRteCA9IG1hdHJpeC5jaGFpbih0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKSk7XG5cdFx0XHRjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gY29sb3Jcblx0XHRcdFx0XHQ/IGNvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KSA6ICcjMDA5ZGVjJztcblx0XHRcdGlmICh0aGlzLl9kcmF3U2VsZWN0ZWQpXG5cdFx0XHRcdHRoaXMuX2RyYXdTZWxlY3RlZChjdHgsIG14LCBzZWxlY3RlZEl0ZW1zKTtcblx0XHRcdGlmICh0aGlzLl9ib3VuZHNTZWxlY3RlZCkge1xuXHRcdFx0XHR2YXIgaGFsZiA9IHNpemUgLyAyLFxuXHRcdFx0XHRcdGNvb3JkcyA9IG14Ll90cmFuc2Zvcm1Db3JuZXJzKHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpKyspXG5cdFx0XHRcdFx0Y3R4W2kgPT09IDAgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShjb29yZHNbaV0sIGNvb3Jkc1srK2ldKTtcblx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKVxuXHRcdFx0XHRcdGN0eC5maWxsUmVjdChjb29yZHNbaV0gLSBoYWxmLCBjb29yZHNbKytpXSAtIGhhbGYsXG5cdFx0XHRcdFx0XHRcdHNpemUsIHNpemUpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0sIEJhc2UuZWFjaChbJ2Rvd24nLCAnZHJhZycsICd1cCcsICdtb3ZlJ10sIGZ1bmN0aW9uKG5hbWUpIHtcblx0dGhpc1sncmVtb3ZlT24nICsgQmFzZS5jYXBpdGFsaXplKG5hbWUpXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYXNoID0ge307XG5cdFx0aGFzaFtuYW1lXSA9IHRydWU7XG5cdFx0cmV0dXJuIHRoaXMucmVtb3ZlT24oaGFzaCk7XG5cdH07XG59LCB7XG5cblx0cmVtb3ZlT246IGZ1bmN0aW9uKG9iaikge1xuXHRcdGZvciAodmFyIG5hbWUgaW4gb2JqKSB7XG5cdFx0XHRpZiAob2JqW25hbWVdKSB7XG5cdFx0XHRcdHZhciBrZXkgPSAnbW91c2UnICsgbmFtZSxcblx0XHRcdFx0XHRwcm9qZWN0ID0gdGhpcy5fcHJvamVjdCxcblx0XHRcdFx0XHRzZXRzID0gcHJvamVjdC5fcmVtb3ZlU2V0cyA9IHByb2plY3QuX3JlbW92ZVNldHMgfHwge307XG5cdFx0XHRcdHNldHNba2V5XSA9IHNldHNba2V5XSB8fCB7fTtcblx0XHRcdFx0c2V0c1trZXldW3RoaXMuX2lkXSA9IHRoaXM7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KSk7XG5cbnZhciBHcm91cCA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnR3JvdXAnLFxuXHRfc2VsZWN0Q2hpbGRyZW46IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjaGlsZHJlbjogW11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBHcm91cChhcmcpIHtcblx0XHR0aGlzLl9jaGlsZHJlbiA9IFtdO1xuXHRcdHRoaXMuX25hbWVkQ2hpbGRyZW4gPSB7fTtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnKSlcblx0XHRcdHRoaXMuYWRkQ2hpbGRyZW4oQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24gX2NoYW5nZWQoZmxhZ3MpIHtcblx0XHRfY2hhbmdlZC5iYXNlLmNhbGwodGhpcywgZmxhZ3MpO1xuXHRcdGlmIChmbGFncyAmIDEwMjYpIHtcblx0XHRcdHRoaXMuX2NsaXBJdGVtID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRfZ2V0Q2xpcEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjbGlwSXRlbSA9IHRoaXMuX2NsaXBJdGVtO1xuXHRcdGlmIChjbGlwSXRlbSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRjbGlwSXRlbSA9IG51bGw7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2NoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlbltpXTtcblx0XHRcdFx0aWYgKGNoaWxkLl9jbGlwTWFzaykge1xuXHRcdFx0XHRcdGNsaXBJdGVtID0gY2hpbGQ7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2NsaXBJdGVtID0gY2xpcEl0ZW07XG5cdFx0fVxuXHRcdHJldHVybiBjbGlwSXRlbTtcblx0fSxcblxuXHRpc0NsaXBwZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuX2dldENsaXBJdGVtKCk7XG5cdH0sXG5cblx0c2V0Q2xpcHBlZDogZnVuY3Rpb24oY2xpcHBlZCkge1xuXHRcdHZhciBjaGlsZCA9IHRoaXMuZ2V0Rmlyc3RDaGlsZCgpO1xuXHRcdGlmIChjaGlsZClcblx0XHRcdGNoaWxkLnNldENsaXBNYXNrKGNsaXBwZWQpO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtKSB7XG5cdFx0dmFyIGNsaXAgPSBwYXJhbS5jbGlwLFxuXHRcdFx0Y2xpcEl0ZW0gPSAhY2xpcCAmJiB0aGlzLl9nZXRDbGlwSXRlbSgpLFxuXHRcdFx0ZHJhdyA9IHRydWU7XG5cdFx0cGFyYW0gPSBwYXJhbS5leHRlbmQoeyBjbGlwSXRlbTogY2xpcEl0ZW0sIGNsaXA6IGZhbHNlIH0pO1xuXHRcdGlmIChjbGlwKSB7XG5cdFx0XHRpZiAodGhpcy5fY3VycmVudFBhdGgpIHtcblx0XHRcdFx0Y3R4LmN1cnJlbnRQYXRoID0gdGhpcy5fY3VycmVudFBhdGg7XG5cdFx0XHRcdGRyYXcgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0cGFyYW0uZG9udFN0YXJ0ID0gcGFyYW0uZG9udEZpbmlzaCA9IHRydWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjbGlwSXRlbSkge1xuXHRcdFx0Y2xpcEl0ZW0uZHJhdyhjdHgsIHBhcmFtLmV4dGVuZCh7IGNsaXA6IHRydWUgfSkpO1xuXHRcdH1cblx0XHRpZiAoZHJhdykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSB0aGlzLl9jaGlsZHJlbltpXTtcblx0XHRcdFx0aWYgKGl0ZW0gIT09IGNsaXBJdGVtKVxuXHRcdFx0XHRcdGl0ZW0uZHJhdyhjdHgsIHBhcmFtKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGNsaXApIHtcblx0XHRcdHRoaXMuX2N1cnJlbnRQYXRoID0gY3R4LmN1cnJlbnRQYXRoO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBMYXllciA9IEdyb3VwLmV4dGVuZCh7XG5cdF9jbGFzczogJ0xheWVyJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBMYXllcihhcmcpIHtcblx0XHR2YXIgcHJvcHMgPSBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKVxuXHRcdFx0XHQ/IG5ldyBCYXNlKGFyZylcblx0XHRcdFx0OiB7IGNoaWxkcmVuOiBBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMgfSxcblx0XHRcdGluc2VydCA9IHByb3BzLmluc2VydDtcblx0XHRwcm9wcy5pbnNlcnQgPSBmYWxzZTtcblx0XHRHcm91cC5jYWxsKHRoaXMsIHByb3BzKTtcblx0XHRpZiAoaW5zZXJ0IHx8IGluc2VydCA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHR0aGlzLl9wcm9qZWN0LmFkZENoaWxkKHRoaXMpO1xuXHRcdFx0dGhpcy5hY3RpdmF0ZSgpO1xuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlOiBmdW5jdGlvbiBfcmVtb3ZlKG5vdGlmeVNlbGYsIG5vdGlmeVBhcmVudCkge1xuXHRcdGlmICh0aGlzLl9wYXJlbnQpXG5cdFx0XHRyZXR1cm4gX3JlbW92ZS5iYXNlLmNhbGwodGhpcywgbm90aWZ5U2VsZiwgbm90aWZ5UGFyZW50KTtcblx0XHRpZiAodGhpcy5faW5kZXggIT0gbnVsbCkge1xuXHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdFx0aWYgKHByb2plY3QuX2FjdGl2ZUxheWVyID09PSB0aGlzKVxuXHRcdFx0XHRwcm9qZWN0Ll9hY3RpdmVMYXllciA9IHRoaXMuZ2V0TmV4dFNpYmxpbmcoKVxuXHRcdFx0XHRcdFx0fHwgdGhpcy5nZXRQcmV2aW91c1NpYmxpbmcoKTtcblx0XHRcdEJhc2Uuc3BsaWNlKHByb2plY3QubGF5ZXJzLCBudWxsLCB0aGlzLl9pbmRleCwgMSk7XG5cdFx0XHR0aGlzLl9pbnN0YWxsRXZlbnRzKGZhbHNlKTtcblx0XHRcdGlmIChub3RpZnlTZWxmICYmIHByb2plY3QuX2NoYW5nZXMpXG5cdFx0XHRcdHRoaXMuX2NoYW5nZWQoNSk7XG5cdFx0XHRpZiAobm90aWZ5UGFyZW50KSB7XG5cdFx0XHRcdHByb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0Z2V0TmV4dFNpYmxpbmc6IGZ1bmN0aW9uIGdldE5leHRTaWJsaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyBnZXROZXh0U2libGluZy5iYXNlLmNhbGwodGhpcylcblx0XHRcdFx0OiB0aGlzLl9wcm9qZWN0LmxheWVyc1t0aGlzLl9pbmRleCArIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXNTaWJsaW5nOiBmdW5jdGlvbiBnZXRQcmV2aW91c1NpYmxpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IGdldFByZXZpb3VzU2libGluZy5iYXNlLmNhbGwodGhpcylcblx0XHRcdFx0OiB0aGlzLl9wcm9qZWN0LmxheWVyc1t0aGlzLl9pbmRleCAtIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0aXNJbnNlcnRlZDogZnVuY3Rpb24gaXNJbnNlcnRlZCgpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gaXNJbnNlcnRlZC5iYXNlLmNhbGwodGhpcykgOiB0aGlzLl9pbmRleCAhPSBudWxsO1xuXHR9LFxuXG5cdGFjdGl2YXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wcm9qZWN0Ll9hY3RpdmVMYXllciA9IHRoaXM7XG5cdH0sXG5cblx0X2luc2VydFNpYmxpbmc6IGZ1bmN0aW9uIF9pbnNlcnRTaWJsaW5nKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRyZXR1cm4gIXRoaXMuX3BhcmVudFxuXHRcdFx0XHQ/IHRoaXMuX3Byb2plY3QuaW5zZXJ0Q2hpbGQoaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSlcblx0XHRcdFx0OiBfaW5zZXJ0U2libGluZy5iYXNlLmNhbGwodGhpcywgaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSk7XG5cdH1cbn0pO1xuXG52YXIgU2hhcGUgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1NoYXBlJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0dHlwZTogbnVsbCxcblx0XHRzaXplOiBudWxsLFxuXHRcdHJhZGl1czogbnVsbFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNoYXBlKHByb3BzKSB7XG5cdFx0dGhpcy5faW5pdGlhbGl6ZShwcm9wcyk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl90eXBlID09PSBpdGVtLl90eXBlXG5cdFx0XHQmJiB0aGlzLl9zaXplLmVxdWFscyhpdGVtLl9zaXplKVxuXHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fcmFkaXVzLCBpdGVtLl9yYWRpdXMpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgY29weSA9IG5ldyBTaGFwZShJdGVtLk5PX0lOU0VSVCk7XG5cdFx0Y29weS5zZXRUeXBlKHRoaXMuX3R5cGUpO1xuXHRcdGNvcHkuc2V0U2l6ZSh0aGlzLl9zaXplKTtcblx0XHRjb3B5LnNldFJhZGl1cyh0aGlzLl9yYWRpdXMpO1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHR9LFxuXG5cdHNldFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0fSxcblxuXHRnZXRTaGFwZTogJyNnZXRUeXBlJyxcblx0c2V0U2hhcGU6ICcjc2V0VHlwZScsXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdGhpcywgJ3NldFNpemUnKTtcblx0fSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICghdGhpcy5fc2l6ZSkge1xuXHRcdFx0dGhpcy5fc2l6ZSA9IHNpemUuY2xvbmUoKTtcblx0XHR9IGVsc2UgaWYgKCF0aGlzLl9zaXplLmVxdWFscyhzaXplKSkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHR3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRcdGhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0aWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdHZhciByYWRpdXMgPSBTaXplLm1pbih0aGlzLl9yYWRpdXMsIHNpemUuZGl2aWRlKDIpKTtcblx0XHRcdFx0dGhpcy5fcmFkaXVzLnNldChyYWRpdXMud2lkdGgsIHJhZGl1cy5oZWlnaHQpO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0XHR3aWR0aCA9IGhlaWdodCA9ICh3aWR0aCArIGhlaWdodCkgLyAyO1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMgPSB3aWR0aCAvIDI7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdlbGxpcHNlJykge1xuXHRcdFx0XHR0aGlzLl9yYWRpdXMuc2V0KHdpZHRoIC8gMiwgaGVpZ2h0IC8gMik7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zaXplLnNldCh3aWR0aCwgaGVpZ2h0KTtcblx0XHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFJhZGl1czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJhZCA9IHRoaXMuX3JhZGl1cztcblx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gJ2NpcmNsZSdcblx0XHRcdFx0PyByYWRcblx0XHRcdFx0OiBuZXcgTGlua2VkU2l6ZShyYWQud2lkdGgsIHJhZC5oZWlnaHQsIHRoaXMsICdzZXRSYWRpdXMnKTtcblx0fSxcblxuXHRzZXRSYWRpdXM6IGZ1bmN0aW9uKHJhZGl1cykge1xuXHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZTtcblx0XHRpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdGlmIChyYWRpdXMgPT09IHRoaXMuX3JhZGl1cylcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIHNpemUgPSByYWRpdXMgKiAyO1xuXHRcdFx0dGhpcy5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdFx0dGhpcy5fc2l6ZS5zZXQoc2l6ZSwgc2l6ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHJhZGl1cyA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0aWYgKCF0aGlzLl9yYWRpdXMpIHtcblx0XHRcdFx0dGhpcy5fcmFkaXVzID0gcmFkaXVzLmNsb25lKCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy5fcmFkaXVzLmVxdWFscyhyYWRpdXMpKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0dGhpcy5fcmFkaXVzLnNldChyYWRpdXMud2lkdGgsIHJhZGl1cy5oZWlnaHQpO1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdFx0XHR2YXIgc2l6ZSA9IFNpemUubWF4KHRoaXMuX3NpemUsIHJhZGl1cy5tdWx0aXBseSgyKSk7XG5cdFx0XHRcdFx0dGhpcy5fc2l6ZS5zZXQoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICdlbGxpcHNlJykge1xuXHRcdFx0XHRcdHRoaXMuX3NpemUuc2V0KHJhZGl1cy53aWR0aCAqIDIsIHJhZGl1cy5oZWlnaHQgKiAyKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHR0b1BhdGg6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fY2xvbmUobmV3IFBhdGhbQmFzZS5jYXBpdGFsaXplKHRoaXMuX3R5cGUpXSh7XG5cdFx0XHRjZW50ZXI6IG5ldyBQb2ludCgpLFxuXHRcdFx0c2l6ZTogdGhpcy5fc2l6ZSxcblx0XHRcdHJhZGl1czogdGhpcy5fcmFkaXVzLFxuXHRcdFx0aW5zZXJ0OiBmYWxzZVxuXHRcdH0pLCBpbnNlcnQpO1xuXHRcdGlmIChwYXBlci5zZXR0aW5ncy5hcHBseU1hdHJpeClcblx0XHRcdHBhdGguc2V0QXBwbHlNYXRyaXgodHJ1ZSk7XG5cdFx0cmV0dXJuIHBhdGg7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCkge1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0aGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKSxcblx0XHRcdGhhc1N0cm9rZSA9IHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0ZG9udFBhaW50ID0gcGFyYW0uZG9udEZpbmlzaCB8fCBwYXJhbS5jbGlwLFxuXHRcdFx0dW50cmFuc2Zvcm1lZCA9ICFzdHJva2VNYXRyaXg7XG5cdFx0aWYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlIHx8IGRvbnRQYWludCkge1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHRyYWRpdXMgPSB0aGlzLl9yYWRpdXMsXG5cdFx0XHRcdGlzQ2lyY2xlID0gdHlwZSA9PT0gJ2NpcmNsZSc7XG5cdFx0XHRpZiAoIXBhcmFtLmRvbnRTdGFydClcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0aWYgKHVudHJhbnNmb3JtZWQgJiYgaXNDaXJjbGUpIHtcblx0XHRcdFx0Y3R4LmFyYygwLCAwLCByYWRpdXMsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByeCA9IGlzQ2lyY2xlID8gcmFkaXVzIDogcmFkaXVzLndpZHRoLFxuXHRcdFx0XHRcdHJ5ID0gaXNDaXJjbGUgPyByYWRpdXMgOiByYWRpdXMuaGVpZ2h0LFxuXHRcdFx0XHRcdHNpemUgPSB0aGlzLl9zaXplLFxuXHRcdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdFx0aWYgKHVudHJhbnNmb3JtZWQgJiYgdHlwZSA9PT0gJ3JlY3RhbmdsZScgJiYgcnggPT09IDAgJiYgcnkgPT09IDApIHtcblx0XHRcdFx0XHRjdHgucmVjdCgtd2lkdGggLyAyLCAtaGVpZ2h0IC8gMiwgd2lkdGgsIGhlaWdodCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dmFyIHggPSB3aWR0aCAvIDIsXG5cdFx0XHRcdFx0XHR5ID0gaGVpZ2h0IC8gMixcblx0XHRcdFx0XHRcdGthcHBhID0gMSAtIDAuNTUyMjg0NzQ5ODMwNzkzNixcblx0XHRcdFx0XHRcdGN4ID0gcnggKiBrYXBwYSxcblx0XHRcdFx0XHRcdGN5ID0gcnkgKiBrYXBwYSxcblx0XHRcdFx0XHRcdGMgPSBbXG5cdFx0XHRcdFx0XHRcdC14LCAteSArIHJ5LFxuXHRcdFx0XHRcdFx0XHQteCwgLXkgKyBjeSxcblx0XHRcdFx0XHRcdFx0LXggKyBjeCwgLXksXG5cdFx0XHRcdFx0XHRcdC14ICsgcngsIC15LFxuXHRcdFx0XHRcdFx0XHR4IC0gcngsIC15LFxuXHRcdFx0XHRcdFx0XHR4IC0gY3gsIC15LFxuXHRcdFx0XHRcdFx0XHR4LCAteSArIGN5LFxuXHRcdFx0XHRcdFx0XHR4LCAteSArIHJ5LFxuXHRcdFx0XHRcdFx0XHR4LCB5IC0gcnksXG5cdFx0XHRcdFx0XHRcdHgsIHkgLSBjeSxcblx0XHRcdFx0XHRcdFx0eCAtIGN4LCB5LFxuXHRcdFx0XHRcdFx0XHR4IC0gcngsIHksXG5cdFx0XHRcdFx0XHRcdC14ICsgcngsIHksXG5cdFx0XHRcdFx0XHRcdC14ICsgY3gsIHksXG5cdFx0XHRcdFx0XHRcdC14LCB5IC0gY3ksXG5cdFx0XHRcdFx0XHRcdC14LCB5IC0gcnlcblx0XHRcdFx0XHRcdF07XG5cdFx0XHRcdFx0aWYgKHN0cm9rZU1hdHJpeClcblx0XHRcdFx0XHRcdHN0cm9rZU1hdHJpeC50cmFuc2Zvcm0oYywgYywgMzIpO1xuXHRcdFx0XHRcdGN0eC5tb3ZlVG8oY1swXSwgY1sxXSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1syXSwgY1szXSwgY1s0XSwgY1s1XSwgY1s2XSwgY1s3XSk7XG5cdFx0XHRcdFx0aWYgKHggIT09IHJ4KVxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhjWzhdLCBjWzldKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzEwXSwgY1sxMV0sIGNbMTJdLCBjWzEzXSwgY1sxNF0sIGNbMTVdKTtcblx0XHRcdFx0XHRpZiAoeSAhPT0gcnkpXG5cdFx0XHRcdFx0XHRjdHgubGluZVRvKGNbMTZdLCBjWzE3XSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1sxOF0sIGNbMTldLCBjWzIwXSwgY1syMV0sIGNbMjJdLCBjWzIzXSk7XG5cdFx0XHRcdFx0aWYgKHggIT09IHJ4KVxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhjWzI0XSwgY1syNV0pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMjZdLCBjWzI3XSwgY1syOF0sIGNbMjldLCBjWzMwXSwgY1szMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0fVxuXHRcdGlmICghZG9udFBhaW50ICYmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSkpIHtcblx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgpO1xuXHRcdFx0aWYgKGhhc0ZpbGwpIHtcblx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdH1cblx0XHRcdGlmIChoYXNTdHJva2UpXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgpIHtcblx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApO1xuXHRcdGlmIChnZXR0ZXIgIT09ICdnZXRCb3VuZHMnICYmIHRoaXMuaGFzU3Ryb2tlKCkpXG5cdFx0XHRyZWN0ID0gcmVjdC5leHBhbmQodGhpcy5nZXRTdHJva2VXaWR0aCgpKTtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCkgOiByZWN0O1xuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBnZXRDb3JuZXJDZW50ZXIodGhhdCwgcG9pbnQsIGV4cGFuZCkge1xuXHRcdHZhciByYWRpdXMgPSB0aGF0Ll9yYWRpdXM7XG5cdFx0aWYgKCFyYWRpdXMuaXNaZXJvKCkpIHtcblx0XHRcdHZhciBoYWxmU2l6ZSA9IHRoYXQuX3NpemUuZGl2aWRlKDIpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0XHRcdFx0dmFyIGRpciA9IG5ldyBQb2ludChpICYgMSA/IDEgOiAtMSwgaSA+IDEgPyAxIDogLTEpLFxuXHRcdFx0XHRcdGNvcm5lciA9IGRpci5tdWx0aXBseShoYWxmU2l6ZSksXG5cdFx0XHRcdFx0Y2VudGVyID0gY29ybmVyLnN1YnRyYWN0KGRpci5tdWx0aXBseShyYWRpdXMpKSxcblx0XHRcdFx0XHRyZWN0ID0gbmV3IFJlY3RhbmdsZShjb3JuZXIsIGNlbnRlcik7XG5cdFx0XHRcdGlmICgoZXhwYW5kID8gcmVjdC5leHBhbmQoZXhwYW5kKSA6IHJlY3QpLmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0XHRyZXR1cm4gY2VudGVyO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldEVsbGlwc2VSYWRpdXMocG9pbnQsIHJhZGl1cykge1xuXHRcdHZhciBhbmdsZSA9IHBvaW50LmdldEFuZ2xlSW5SYWRpYW5zKCksXG5cdFx0XHR3aWR0aCA9IHJhZGl1cy53aWR0aCAqIDIsXG5cdFx0XHRoZWlnaHQgPSByYWRpdXMuaGVpZ2h0ICogMixcblx0XHRcdHggPSB3aWR0aCAqIE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdHkgPSBoZWlnaHQgKiBNYXRoLmNvcyhhbmdsZSk7XG5cdFx0cmV0dXJuIHdpZHRoICogaGVpZ2h0IC8gKDIgKiBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSkpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfY29udGFpbnM6IGZ1bmN0aW9uIF9jb250YWlucyhwb2ludCkge1xuXHRcdFx0aWYgKHRoaXMuX3R5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdHZhciBjZW50ZXIgPSBnZXRDb3JuZXJDZW50ZXIodGhpcywgcG9pbnQpO1xuXHRcdFx0XHRyZXR1cm4gY2VudGVyXG5cdFx0XHRcdFx0XHQ/IHBvaW50LnN1YnRyYWN0KGNlbnRlcikuZGl2aWRlKHRoaXMuX3JhZGl1cylcblx0XHRcdFx0XHRcdFx0LmdldExlbmd0aCgpIDw9IDFcblx0XHRcdFx0XHRcdDogX2NvbnRhaW5zLmJhc2UuY2FsbCh0aGlzLCBwb2ludCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gcG9pbnQuZGl2aWRlKHRoaXMuc2l6ZSkuZ2V0TGVuZ3RoKCkgPD0gMC41O1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uIF9oaXRUZXN0U2VsZihwb2ludCwgb3B0aW9ucykge1xuXHRcdFx0dmFyIGhpdCA9IGZhbHNlO1xuXHRcdFx0aWYgKHRoaXMuaGFzU3Ryb2tlKCkpIHtcblx0XHRcdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHRcdHJhZGl1cyA9IHRoaXMuX3JhZGl1cyxcblx0XHRcdFx0XHRzdHJva2VXaWR0aCA9IHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSArIDIgKiBvcHRpb25zLnRvbGVyYW5jZTtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdFx0dmFyIGNlbnRlciA9IGdldENvcm5lckNlbnRlcih0aGlzLCBwb2ludCwgc3Ryb2tlV2lkdGgpO1xuXHRcdFx0XHRcdGlmIChjZW50ZXIpIHtcblx0XHRcdFx0XHRcdHZhciBwdCA9IHBvaW50LnN1YnRyYWN0KGNlbnRlcik7XG5cdFx0XHRcdFx0XHRoaXQgPSAyICogTWF0aC5hYnMocHQuZ2V0TGVuZ3RoKClcblx0XHRcdFx0XHRcdFx0XHQtIGdldEVsbGlwc2VSYWRpdXMocHQsIHJhZGl1cykpIDw9IHN0cm9rZVdpZHRoO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSkuc2V0Q2VudGVyKDAsIDApLFxuXHRcdFx0XHRcdFx0XHRvdXRlciA9IHJlY3QuZXhwYW5kKHN0cm9rZVdpZHRoKSxcblx0XHRcdFx0XHRcdFx0aW5uZXIgPSByZWN0LmV4cGFuZCgtc3Ryb2tlV2lkdGgpO1xuXHRcdFx0XHRcdFx0aGl0ID0gb3V0ZXIuX2NvbnRhaW5zUG9pbnQocG9pbnQpXG5cdFx0XHRcdFx0XHRcdFx0JiYgIWlubmVyLl9jb250YWluc1BvaW50KHBvaW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHR5cGUgPT09ICdlbGxpcHNlJylcblx0XHRcdFx0XHRcdHJhZGl1cyA9IGdldEVsbGlwc2VSYWRpdXMocG9pbnQsIHJhZGl1cyk7XG5cdFx0XHRcdFx0aGl0ID0gMiAqIE1hdGguYWJzKHBvaW50LmdldExlbmd0aCgpIC0gcmFkaXVzKVxuXHRcdFx0XHRcdFx0XHQ8PSBzdHJva2VXaWR0aDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGhpdFxuXHRcdFx0XHRcdD8gbmV3IEhpdFJlc3VsdCgnc3Ryb2tlJywgdGhpcylcblx0XHRcdFx0XHQ6IF9oaXRUZXN0U2VsZi5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fVxuXHR9O1xufSwge1xuXG5zdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGNyZWF0ZVNoYXBlKHR5cGUsIHBvaW50LCBzaXplLCByYWRpdXMsIGFyZ3MpIHtcblx0XHR2YXIgaXRlbSA9IG5ldyBTaGFwZShCYXNlLmdldE5hbWVkKGFyZ3MpKTtcblx0XHRpdGVtLl90eXBlID0gdHlwZTtcblx0XHRpdGVtLl9zaXplID0gc2l6ZTtcblx0XHRpdGVtLl9yYWRpdXMgPSByYWRpdXM7XG5cdFx0cmV0dXJuIGl0ZW0udHJhbnNsYXRlKHBvaW50KTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Q2lyY2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdjaXJjbGUnLCBjZW50ZXIsIG5ldyBTaXplKHJhZGl1cyAqIDIpLCByYWRpdXMsXG5cdFx0XHRcdFx0YXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0UmVjdGFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmd1bWVudHMsICdyZWN0YW5nbGUnKSxcblx0XHRcdFx0cmFkaXVzID0gU2l6ZS5taW4oU2l6ZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJyksXG5cdFx0XHRcdFx0XHRyZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpKTtcblx0XHRcdHJldHVybiBjcmVhdGVTaGFwZSgncmVjdGFuZ2xlJywgcmVjdC5nZXRDZW50ZXIodHJ1ZSksXG5cdFx0XHRcdFx0cmVjdC5nZXRTaXplKHRydWUpLCByYWRpdXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdEVsbGlwc2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsbGlwc2UgPSBTaGFwZS5fcmVhZEVsbGlwc2UoYXJndW1lbnRzKSxcblx0XHRcdFx0cmFkaXVzID0gZWxsaXBzZS5yYWRpdXM7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ2VsbGlwc2UnLCBlbGxpcHNlLmNlbnRlciwgcmFkaXVzLm11bHRpcGx5KDIpLFxuXHRcdFx0XHRcdHJhZGl1cywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0X3JlYWRFbGxpcHNlOiBmdW5jdGlvbihhcmdzKSB7XG5cdFx0XHR2YXIgY2VudGVyLFxuXHRcdFx0XHRyYWRpdXM7XG5cdFx0XHRpZiAoQmFzZS5oYXNOYW1lZChhcmdzLCAncmFkaXVzJykpIHtcblx0XHRcdFx0Y2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3MsICdjZW50ZXInKTtcblx0XHRcdFx0cmFkaXVzID0gU2l6ZS5yZWFkTmFtZWQoYXJncywgJ3JhZGl1cycpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3MsICdyZWN0YW5nbGUnKTtcblx0XHRcdFx0Y2VudGVyID0gcmVjdC5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0XHRcdHJhZGl1cyA9IHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMik7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4geyBjZW50ZXI6IGNlbnRlciwgcmFkaXVzOiByYWRpdXMgfTtcblx0XHR9XG5cdH07XG59fSk7XG5cbnZhciBSYXN0ZXIgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1Jhc3RlcicsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9ib3VuZHNHZXR0ZXI6ICdnZXRCb3VuZHMnLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjcm9zc09yaWdpbjogbnVsbCxcblx0XHRzb3VyY2U6IG51bGxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBSYXN0ZXIob2JqZWN0LCBwb3NpdGlvbikge1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShvYmplY3QsXG5cdFx0XHRcdHBvc2l0aW9uICE9PSB1bmRlZmluZWQgJiYgUG9pbnQucmVhZChhcmd1bWVudHMsIDEpKSkge1xuXHRcdFx0aWYgKHR5cGVvZiBvYmplY3QgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0U291cmNlKG9iamVjdCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLnNldEltYWdlKG9iamVjdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghdGhpcy5fc2l6ZSkge1xuXHRcdFx0dGhpcy5fc2l6ZSA9IG5ldyBTaXplKCk7XG5cdFx0XHR0aGlzLl9sb2FkZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLmdldFNvdXJjZSgpID09PSBpdGVtLmdldFNvdXJjZSgpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgY29weSA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpLFxuXHRcdFx0aW1hZ2UgPSB0aGlzLl9pbWFnZSxcblx0XHRcdGNhbnZhcyA9IHRoaXMuX2NhbnZhcztcblx0XHRpZiAoaW1hZ2UpIHtcblx0XHRcdGNvcHkuc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdH0gZWxzZSBpZiAoY2FudmFzKSB7XG5cdFx0XHR2YXIgY29weUNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyh0aGlzLl9zaXplKTtcblx0XHRcdGNvcHlDYW52YXMuZ2V0Q29udGV4dCgnMmQnKS5kcmF3SW1hZ2UoY2FudmFzLCAwLCAwKTtcblx0XHRcdGNvcHkuc2V0SW1hZ2UoY29weUNhbnZhcyk7XG5cdFx0fVxuXHRcdGNvcHkuX2Nyb3NzT3JpZ2luID0gdGhpcy5fY3Jvc3NPcmlnaW47XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplID8gc2l6ZS53aWR0aCA6IDAsIHNpemUgPyBzaXplLmhlaWdodCA6IDAsXG5cdFx0XHRcdHRoaXMsICdzZXRTaXplJyk7XG5cdH0sXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAoIXNpemUuZXF1YWxzKHRoaXMuX3NpemUpKSB7XG5cdFx0XHRpZiAoc2l6ZS53aWR0aCA+IDAgJiYgc2l6ZS5oZWlnaHQgPiAwKSB7XG5cdFx0XHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG5cdFx0XHRcdHRoaXMuc2V0SW1hZ2UoQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUpKTtcblx0XHRcdFx0aWYgKGVsZW1lbnQpXG5cdFx0XHRcdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLmRyYXdJbWFnZShlbGVtZW50LCAwLCAwLFxuXHRcdFx0XHRcdFx0XHRzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAodGhpcy5fY2FudmFzKVxuXHRcdFx0XHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UodGhpcy5fY2FudmFzKTtcblx0XHRcdFx0dGhpcy5fc2l6ZSA9IHNpemUuY2xvbmUoKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Z2V0V2lkdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaXplID8gdGhpcy5fc2l6ZS53aWR0aCA6IDA7XG5cdH0sXG5cblx0c2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG5cdFx0dGhpcy5zZXRTaXplKHdpZHRoLCB0aGlzLmdldEhlaWdodCgpKTtcblx0fSxcblxuXHRnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zaXplID8gdGhpcy5fc2l6ZS5oZWlnaHQgOiAwO1xuXHR9LFxuXG5cdHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7XG5cdFx0dGhpcy5zZXRTaXplKHRoaXMuZ2V0V2lkdGgoKSwgaGVpZ2h0KTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0cmV0dXJuICFzaXplIHx8IHNpemUud2lkdGggPT09IDAgJiYgc2l6ZS5oZWlnaHQgPT09IDA7XG5cdH0sXG5cblx0Z2V0UmVzb2x1dGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdG9yaWcgPSBuZXcgUG9pbnQoMCwgMCkudHJhbnNmb3JtKG1hdHJpeCksXG5cdFx0XHR1ID0gbmV3IFBvaW50KDEsIDApLnRyYW5zZm9ybShtYXRyaXgpLnN1YnRyYWN0KG9yaWcpLFxuXHRcdFx0diA9IG5ldyBQb2ludCgwLCAxKS50cmFuc2Zvcm0obWF0cml4KS5zdWJ0cmFjdChvcmlnKTtcblx0XHRyZXR1cm4gbmV3IFNpemUoXG5cdFx0XHQ3MiAvIHUuZ2V0TGVuZ3RoKCksXG5cdFx0XHQ3MiAvIHYuZ2V0TGVuZ3RoKClcblx0XHQpO1xuXHR9LFxuXG5cdGdldFBwaTogJyNnZXRSZXNvbHV0aW9uJyxcblxuXHRnZXRJbWFnZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlO1xuXHR9LFxuXG5cdHNldEltYWdlOiBmdW5jdGlvbihpbWFnZSkge1xuXHRcdGlmICh0aGlzLl9jYW52YXMpXG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKHRoaXMuX2NhbnZhcyk7XG5cdFx0aWYgKGltYWdlICYmIGltYWdlLmdldENvbnRleHQpIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHRcdHRoaXMuX2NhbnZhcyA9IGltYWdlO1xuXHRcdFx0dGhpcy5fbG9hZGVkID0gdHJ1ZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy5faW1hZ2UgPSBpbWFnZTtcblx0XHRcdHRoaXMuX2NhbnZhcyA9IG51bGw7XG5cdFx0XHR0aGlzLl9sb2FkZWQgPSBpbWFnZSAmJiBpbWFnZS5jb21wbGV0ZTtcblx0XHR9XG5cdFx0dGhpcy5fc2l6ZSA9IG5ldyBTaXplKFxuXHRcdFx0XHRpbWFnZSA/IGltYWdlLm5hdHVyYWxXaWR0aCB8fCBpbWFnZS53aWR0aCA6IDAsXG5cdFx0XHRcdGltYWdlID8gaW1hZ2UubmF0dXJhbEhlaWdodCB8fCBpbWFnZS5oZWlnaHQgOiAwKTtcblx0XHR0aGlzLl9jb250ZXh0ID0gbnVsbDtcblx0XHR0aGlzLl9jaGFuZ2VkKDUyMSk7XG5cdH0sXG5cblx0Z2V0Q2FudmFzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2NhbnZhcykge1xuXHRcdFx0dmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQodGhpcy5fc2l6ZSk7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRpZiAodGhpcy5faW1hZ2UpXG5cdFx0XHRcdFx0Y3R4LmRyYXdJbWFnZSh0aGlzLl9pbWFnZSwgMCwgMCk7XG5cdFx0XHRcdHRoaXMuX2NhbnZhcyA9IGN0eC5jYW52YXM7XG5cdFx0XHR9IGNhdGNoIChlKSB7XG5cdFx0XHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2NhbnZhcztcblx0fSxcblxuXHRzZXRDYW52YXM6ICcjc2V0SW1hZ2UnLFxuXG5cdGdldENvbnRleHQ6IGZ1bmN0aW9uKG1vZGlmeSkge1xuXHRcdGlmICghdGhpcy5fY29udGV4dClcblx0XHRcdHRoaXMuX2NvbnRleHQgPSB0aGlzLmdldENhbnZhcygpLmdldENvbnRleHQoJzJkJyk7XG5cdFx0aWYgKG1vZGlmeSkge1xuXHRcdFx0dGhpcy5faW1hZ2UgPSBudWxsO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCg1MTMpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fY29udGV4dDtcblx0fSxcblxuXHRzZXRDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7XG5cdFx0dGhpcy5fY29udGV4dCA9IGNvbnRleHQ7XG5cdH0sXG5cblx0Z2V0U291cmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2UgJiYgdGhpcy5faW1hZ2Uuc3JjIHx8IHRoaXMudG9EYXRhVVJMKCk7XG5cdH0sXG5cblx0c2V0U291cmNlOiBmdW5jdGlvbihzcmMpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRjcm9zc09yaWdpbiA9IHRoaXMuX2Nyb3NzT3JpZ2luLFxuXHRcdFx0aW1hZ2U7XG5cblx0XHRmdW5jdGlvbiBsb2FkZWQoKSB7XG5cdFx0XHR2YXIgdmlldyA9IHRoYXQuZ2V0VmlldygpO1xuXHRcdFx0aWYgKHZpZXcpIHtcblx0XHRcdFx0cGFwZXIgPSB2aWV3Ll9zY29wZTtcblx0XHRcdFx0dGhhdC5zZXRJbWFnZShpbWFnZSk7XG5cdFx0XHRcdHRoYXQuZW1pdCgnbG9hZCcpO1xuXHRcdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGltYWdlID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoc3JjKSB8fCBuZXcgSW1hZ2UoKTtcblx0XHRpZiAoY3Jvc3NPcmlnaW4pXG5cdFx0XHRpbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXHRcdGlmIChpbWFnZS5uYXR1cmFsV2lkdGggJiYgaW1hZ2UubmF0dXJhbEhlaWdodCkge1xuXHRcdFx0c2V0VGltZW91dChsb2FkZWQsIDApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHREb21FdmVudC5hZGQoaW1hZ2UsIHsgbG9hZDogbG9hZGVkIH0pO1xuXHRcdFx0aWYgKCFpbWFnZS5zcmMpXG5cdFx0XHRcdGltYWdlLnNyYyA9IHNyYztcblx0XHR9XG5cdFx0dGhpcy5zZXRJbWFnZShpbWFnZSk7XG5cdH0sXG5cblx0Z2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZSAmJiB0aGlzLl9pbWFnZS5jcm9zc09yaWdpbiB8fCB0aGlzLl9jcm9zc09yaWdpbiB8fCAnJztcblx0fSxcblxuXHRzZXRDcm9zc09yaWdpbjogZnVuY3Rpb24oY3Jvc3NPcmlnaW4pIHtcblx0XHR0aGlzLl9jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXHRcdGlmICh0aGlzLl9pbWFnZSlcblx0XHRcdHRoaXMuX2ltYWdlLmNyb3NzT3JpZ2luID0gY3Jvc3NPcmlnaW47XG5cdH0sXG5cblx0Z2V0RWxlbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NhbnZhcyB8fCB0aGlzLl9sb2FkZWQgJiYgdGhpcy5faW1hZ2U7XG5cdH1cbn0sIHtcblx0YmVhbnM6IGZhbHNlLFxuXG5cdGdldFN1YkNhbnZhczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChyZWN0LmdldFNpemUoKSk7XG5cdFx0Y3R4LmRyYXdJbWFnZSh0aGlzLmdldENhbnZhcygpLCByZWN0LngsIHJlY3QueSxcblx0XHRcdFx0cmVjdC53aWR0aCwgcmVjdC5oZWlnaHQsIDAsIDAsIHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0KTtcblx0XHRyZXR1cm4gY3R4LmNhbnZhcztcblx0fSxcblxuXHRnZXRTdWJSYXN0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHJhc3RlciA9IG5ldyBSYXN0ZXIoSXRlbS5OT19JTlNFUlQpO1xuXHRcdHJhc3Rlci5zZXRJbWFnZSh0aGlzLmdldFN1YkNhbnZhcyhyZWN0KSk7XG5cdFx0cmFzdGVyLnRyYW5zbGF0ZShyZWN0LmdldENlbnRlcigpLnN1YnRyYWN0KHRoaXMuZ2V0U2l6ZSgpLmRpdmlkZSgyKSkpO1xuXHRcdHJhc3Rlci5fbWF0cml4LnByZUNvbmNhdGVuYXRlKHRoaXMuX21hdHJpeCk7XG5cdFx0cmFzdGVyLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdHJldHVybiByYXN0ZXI7XG5cdH0sXG5cblx0dG9EYXRhVVJMOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3JjID0gdGhpcy5faW1hZ2UgJiYgdGhpcy5faW1hZ2Uuc3JjO1xuXHRcdGlmICgvXmRhdGE6Ly50ZXN0KHNyYykpXG5cdFx0XHRyZXR1cm4gc3JjO1xuXHRcdHZhciBjYW52YXMgPSB0aGlzLmdldENhbnZhcygpO1xuXHRcdHJldHVybiBjYW52YXMgPyBjYW52YXMudG9EYXRhVVJMLmFwcGx5KGNhbnZhcywgYXJndW1lbnRzKSA6IG51bGw7XG5cdH0sXG5cblx0ZHJhd0ltYWdlOiBmdW5jdGlvbihpbWFnZSApIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLmRyYXdJbWFnZShpbWFnZSwgcG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0QXZlcmFnZUNvbG9yOiBmdW5jdGlvbihvYmplY3QpIHtcblx0XHR2YXIgYm91bmRzLCBwYXRoO1xuXHRcdGlmICghb2JqZWN0KSB7XG5cdFx0XHRib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpO1xuXHRcdH0gZWxzZSBpZiAob2JqZWN0IGluc3RhbmNlb2YgUGF0aEl0ZW0pIHtcblx0XHRcdHBhdGggPSBvYmplY3Q7XG5cdFx0XHRib3VuZHMgPSBvYmplY3QuZ2V0Qm91bmRzKCk7XG5cdFx0fSBlbHNlIGlmIChvYmplY3Qud2lkdGgpIHtcblx0XHRcdGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUob2JqZWN0KTtcblx0XHR9IGVsc2UgaWYgKG9iamVjdC54KSB7XG5cdFx0XHRib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG9iamVjdC54IC0gMC41LCBvYmplY3QueSAtIDAuNSwgMSwgMSk7XG5cdFx0fVxuXHRcdHZhciBzYW1wbGVTaXplID0gMzIsXG5cdFx0XHR3aWR0aCA9IE1hdGgubWluKGJvdW5kcy53aWR0aCwgc2FtcGxlU2l6ZSksXG5cdFx0XHRoZWlnaHQgPSBNYXRoLm1pbihib3VuZHMuaGVpZ2h0LCBzYW1wbGVTaXplKTtcblx0XHR2YXIgY3R4ID0gUmFzdGVyLl9zYW1wbGVDb250ZXh0O1xuXHRcdGlmICghY3R4KSB7XG5cdFx0XHRjdHggPSBSYXN0ZXIuX3NhbXBsZUNvbnRleHQgPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KFxuXHRcdFx0XHRcdG5ldyBTaXplKHNhbXBsZVNpemUpKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBzYW1wbGVTaXplICsgMSwgc2FtcGxlU2l6ZSArIDEpO1xuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdHZhciBtYXRyaXggPSBuZXcgTWF0cml4KClcblx0XHRcdFx0LnNjYWxlKHdpZHRoIC8gYm91bmRzLndpZHRoLCBoZWlnaHQgLyBib3VuZHMuaGVpZ2h0KVxuXHRcdFx0XHQudHJhbnNsYXRlKC1ib3VuZHMueCwgLWJvdW5kcy55KTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHRpZiAocGF0aClcblx0XHRcdHBhdGguZHJhdyhjdHgsIG5ldyBCYXNlKHsgY2xpcDogdHJ1ZSwgbWF0cmljZXM6IFttYXRyaXhdIH0pKTtcblx0XHR0aGlzLl9tYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpLFxuXHRcdFx0c2l6ZSA9IHRoaXMuX3NpemU7XG5cdFx0aWYgKGVsZW1lbnQpXG5cdFx0XHRjdHguZHJhd0ltYWdlKGVsZW1lbnQsIC1zaXplLndpZHRoIC8gMiwgLXNpemUuaGVpZ2h0IC8gMik7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR2YXIgcGl4ZWxzID0gY3R4LmdldEltYWdlRGF0YSgwLjUsIDAuNSwgTWF0aC5jZWlsKHdpZHRoKSxcblx0XHRcdFx0TWF0aC5jZWlsKGhlaWdodCkpLmRhdGEsXG5cdFx0XHRjaGFubmVscyA9IFswLCAwLCAwXSxcblx0XHRcdHRvdGFsID0gMDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBpeGVscy5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcblx0XHRcdHZhciBhbHBoYSA9IHBpeGVsc1tpICsgM107XG5cdFx0XHR0b3RhbCArPSBhbHBoYTtcblx0XHRcdGFscGhhIC89IDI1NTtcblx0XHRcdGNoYW5uZWxzWzBdICs9IHBpeGVsc1tpXSAqIGFscGhhO1xuXHRcdFx0Y2hhbm5lbHNbMV0gKz0gcGl4ZWxzW2kgKyAxXSAqIGFscGhhO1xuXHRcdFx0Y2hhbm5lbHNbMl0gKz0gcGl4ZWxzW2kgKyAyXSAqIGFscGhhO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKylcblx0XHRcdGNoYW5uZWxzW2ldIC89IHRvdGFsO1xuXHRcdHJldHVybiB0b3RhbCA/IENvbG9yLnJlYWQoY2hhbm5lbHMpIDogbnVsbDtcblx0fSxcblxuXHRnZXRQaXhlbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHZhciBkYXRhID0gdGhpcy5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKHBvaW50LngsIHBvaW50LnksIDEsIDEpLmRhdGE7XG5cdFx0cmV0dXJuIG5ldyBDb2xvcigncmdiJywgW2RhdGFbMF0gLyAyNTUsIGRhdGFbMV0gLyAyNTUsIGRhdGFbMl0gLyAyNTVdLFxuXHRcdFx0XHRkYXRhWzNdIC8gMjU1KTtcblx0fSxcblxuXHRzZXRQaXhlbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjb21wb25lbnRzID0gY29sb3IuX2NvbnZlcnQoJ3JnYicpLFxuXHRcdFx0YWxwaGEgPSBjb2xvci5fYWxwaGEsXG5cdFx0XHRjdHggPSB0aGlzLmdldENvbnRleHQodHJ1ZSksXG5cdFx0XHRpbWFnZURhdGEgPSBjdHguY3JlYXRlSW1hZ2VEYXRhKDEsIDEpLFxuXHRcdFx0ZGF0YSA9IGltYWdlRGF0YS5kYXRhO1xuXHRcdGRhdGFbMF0gPSBjb21wb25lbnRzWzBdICogMjU1O1xuXHRcdGRhdGFbMV0gPSBjb21wb25lbnRzWzFdICogMjU1O1xuXHRcdGRhdGFbMl0gPSBjb21wb25lbnRzWzJdICogMjU1O1xuXHRcdGRhdGFbM10gPSBhbHBoYSAhPSBudWxsID8gYWxwaGEgKiAyNTUgOiAyNTU7XG5cdFx0Y3R4LnB1dEltYWdlRGF0YShpbWFnZURhdGEsIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGNyZWF0ZUltYWdlRGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRDb250ZXh0KCkuY3JlYXRlSW1hZ2VEYXRhKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRnZXRJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAocmVjdC5pc0VtcHR5KCkpXG5cdFx0XHRyZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKTtcblx0XHRyZXR1cm4gdGhpcy5nZXRDb250ZXh0KCkuZ2V0SW1hZ2VEYXRhKHJlY3QueCwgcmVjdC55LFxuXHRcdFx0XHRyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdH0sXG5cblx0c2V0SW1hZ2VEYXRhOiBmdW5jdGlvbihkYXRhICkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKTtcblx0XHR0aGlzLmdldENvbnRleHQodHJ1ZSkucHV0SW1hZ2VEYXRhKGRhdGEsIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4KSB7XG5cdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKTtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMocmVjdCkgOiByZWN0O1xuXHR9LFxuXG5cdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRpZiAodGhpcy5fY29udGFpbnMocG9pbnQpKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdCgncGl4ZWwnLCB0aGF0LCB7XG5cdFx0XHRcdG9mZnNldDogcG9pbnQuYWRkKHRoYXQuX3NpemUuZGl2aWRlKDIpKS5yb3VuZCgpLFxuXHRcdFx0XHRjb2xvcjoge1xuXHRcdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhhdC5nZXRQaXhlbCh0aGlzLm9mZnNldCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5nZXRFbGVtZW50KCk7XG5cdFx0aWYgKGVsZW1lbnQpIHtcblx0XHRcdGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuX29wYWNpdHk7XG5cdFx0XHRjdHguZHJhd0ltYWdlKGVsZW1lbnQsXG5cdFx0XHRcdFx0LXRoaXMuX3NpemUud2lkdGggLyAyLCAtdGhpcy5fc2l6ZS5oZWlnaHQgLyAyKTtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG52YXIgUGxhY2VkU3ltYm9sID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQbGFjZWRTeW1ib2wnLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzR2V0dGVyOiB7IGdldEJvdW5kczogJ2dldFN0cm9rZUJvdW5kcycgfSxcblx0X2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0c3ltYm9sOiBudWxsXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUGxhY2VkU3ltYm9sKGFyZzAsIGFyZzEpIHtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUoYXJnMCxcblx0XHRcdFx0YXJnMSAhPT0gdW5kZWZpbmVkICYmIFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSkpXG5cdFx0XHR0aGlzLnNldFN5bWJvbChhcmcwIGluc3RhbmNlb2YgU3ltYm9sID8gYXJnMCA6IG5ldyBTeW1ib2woYXJnMCkpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fc3ltYm9sID09PSBpdGVtLl9zeW1ib2w7XG5cdH0sXG5cblx0Z2V0U3ltYm9sOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3ltYm9sO1xuXHR9LFxuXG5cdHNldFN5bWJvbDogZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0dGhpcy5fc3ltYm9sID0gc3ltYm9sO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFBsYWNlZFN5bWJvbChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0Y29weS5zZXRTeW1ib2wodGhpcy5fc3ltYm9sKTtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUoY29weSwgaW5zZXJ0KTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3ltYm9sLl9kZWZpbml0aW9uLmlzRW1wdHkoKTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCwgY2FjaGVJdGVtKSB7XG5cdFx0dmFyIGRlZmluaXRpb24gPSB0aGlzLnN5bWJvbC5fZGVmaW5pdGlvbjtcblx0XHRyZXR1cm4gZGVmaW5pdGlvbi5fZ2V0Q2FjaGVkQm91bmRzKGdldHRlcixcblx0XHRcdFx0bWF0cml4ICYmIG1hdHJpeC5jaGFpbihkZWZpbml0aW9uLl9tYXRyaXgpLCBjYWNoZUl0ZW0pO1xuXHR9LFxuXG5cdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMpIHtcblx0XHR2YXIgcmVzID0gdGhpcy5fc3ltYm9sLl9kZWZpbml0aW9uLl9oaXRUZXN0KHBvaW50LCBvcHRpb25zKTtcblx0XHRpZiAocmVzKVxuXHRcdFx0cmVzLml0ZW0gPSB0aGlzO1xuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0pIHtcblx0XHR0aGlzLnN5bWJvbC5fZGVmaW5pdGlvbi5kcmF3KGN0eCwgcGFyYW0pO1xuXHR9XG5cbn0pO1xuXG52YXIgSGl0UmVzdWx0ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdIaXRSZXN1bHQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEhpdFJlc3VsdCh0eXBlLCBpdGVtLCB2YWx1ZXMpIHtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMuaXRlbSA9IGl0ZW07XG5cdFx0aWYgKHZhbHVlcykge1xuXHRcdFx0dmFsdWVzLmVudW1lcmFibGUgPSB0cnVlO1xuXHRcdFx0dGhpcy5pbmplY3QodmFsdWVzKTtcblx0XHR9XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdGdldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiBuZXcgQmFzZSh7XG5cdFx0XHRcdHR5cGU6IG51bGwsXG5cdFx0XHRcdHRvbGVyYW5jZTogcGFwZXIuc2V0dGluZ3MuaGl0VG9sZXJhbmNlLFxuXHRcdFx0XHRmaWxsOiAhb3B0aW9ucyxcblx0XHRcdFx0c3Ryb2tlOiAhb3B0aW9ucyxcblx0XHRcdFx0c2VnbWVudHM6ICFvcHRpb25zLFxuXHRcdFx0XHRoYW5kbGVzOiBmYWxzZSxcblx0XHRcdFx0ZW5kczogZmFsc2UsXG5cdFx0XHRcdGNlbnRlcjogZmFsc2UsXG5cdFx0XHRcdGJvdW5kczogZmFsc2UsXG5cdFx0XHRcdGd1aWRlczogZmFsc2UsXG5cdFx0XHRcdHNlbGVjdGVkOiBmYWxzZVxuXHRcdFx0fSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9XG59KTtcblxudmFyIFNlZ21lbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1NlZ21lbnQnLFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTZWdtZW50KGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUpIHtcblx0XHR2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0cG9pbnQsIGhhbmRsZUluLCBoYW5kbGVPdXQ7XG5cdFx0aWYgKGNvdW50ID09PSAwKSB7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuXHRcdFx0aWYgKCdwb2ludCcgaW4gYXJnMCkge1xuXHRcdFx0XHRwb2ludCA9IGFyZzAucG9pbnQ7XG5cdFx0XHRcdGhhbmRsZUluID0gYXJnMC5oYW5kbGVJbjtcblx0XHRcdFx0aGFuZGxlT3V0ID0gYXJnMC5oYW5kbGVPdXQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwb2ludCA9IGFyZzA7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMiAmJiB0eXBlb2YgYXJnMCA9PT0gJ251bWJlcicpIHtcblx0XHRcdHBvaW50ID0gYXJndW1lbnRzO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPD0gMykge1xuXHRcdFx0cG9pbnQgPSBhcmcwO1xuXHRcdFx0aGFuZGxlSW4gPSBhcmcxO1xuXHRcdFx0aGFuZGxlT3V0ID0gYXJnMjtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cG9pbnQgPSBhcmcwICE9PSB1bmRlZmluZWQgPyBbIGFyZzAsIGFyZzEgXSA6IG51bGw7XG5cdFx0XHRoYW5kbGVJbiA9IGFyZzIgIT09IHVuZGVmaW5lZCA/IFsgYXJnMiwgYXJnMyBdIDogbnVsbDtcblx0XHRcdGhhbmRsZU91dCA9IGFyZzQgIT09IHVuZGVmaW5lZCA/IFsgYXJnNCwgYXJnNSBdIDogbnVsbDtcblx0XHR9XG5cdFx0bmV3IFNlZ21lbnRQb2ludChwb2ludCwgdGhpcywgJ19wb2ludCcpO1xuXHRcdG5ldyBTZWdtZW50UG9pbnQoaGFuZGxlSW4sIHRoaXMsICdfaGFuZGxlSW4nKTtcblx0XHRuZXcgU2VnbWVudFBvaW50KGhhbmRsZU91dCwgdGhpcywgJ19oYW5kbGVPdXQnKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMuaGFzSGFuZGxlcygpXG5cdFx0XHRcdD8gW3RoaXMuX3BvaW50LCB0aGlzLl9oYW5kbGVJbiwgdGhpcy5faGFuZGxlT3V0XVxuXHRcdFx0XHQ6IHRoaXMuX3BvaW50LFxuXHRcdFx0XHRvcHRpb25zLCB0cnVlKTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGg7XG5cdFx0aWYgKCFwYXRoKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBjdXJ2ZXMgPSBwYXRoLl9jdXJ2ZXMsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4LFxuXHRcdFx0Y3VydmU7XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0aWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVJbilcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBpbmRleCA+IDAgPyBjdXJ2ZXNbaW5kZXggLSAxXSA6IHBhdGguX2Nsb3NlZFxuXHRcdFx0XHRcdFx0PyBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdIDogbnVsbCkpXG5cdFx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0XHRpZiAoKCFwb2ludCB8fCBwb2ludCA9PT0gdGhpcy5fcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX2hhbmRsZU91dClcblx0XHRcdFx0XHQmJiAoY3VydmUgPSBjdXJ2ZXNbaW5kZXhdKSlcblx0XHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0cGF0aC5fY2hhbmdlZCgyNSk7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3BvaW50LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGVJbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZUluO1xuXHR9LFxuXG5cdHNldEhhbmRsZUluOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5faGFuZGxlSW4uc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZU91dDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hhbmRsZU91dDtcblx0fSxcblxuXHRzZXRIYW5kbGVPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9oYW5kbGVPdXQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5faGFuZGxlSW4uaXNaZXJvKCkgfHwgIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKTtcblx0fSxcblxuXHRjbGVhckhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX2hhbmRsZUluLnNldCgwLCAwKTtcblx0XHR0aGlzLl9oYW5kbGVPdXQuc2V0KDAsIDApO1xuXHR9LFxuXG5cdF9zZWxlY3Rpb25TdGF0ZTogMCxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbihfcG9pbnQpIHtcblx0XHR2YXIgc3RhdGUgPSB0aGlzLl9zZWxlY3Rpb25TdGF0ZTtcblx0XHRyZXR1cm4gIV9wb2ludCA/ICEhKHN0YXRlICYgNylcblx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9wb2ludCA/ICEhKHN0YXRlICYgNClcblx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9oYW5kbGVJbiA/ICEhKHN0YXRlICYgMSlcblx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9oYW5kbGVPdXQgPyAhIShzdGF0ZSAmIDIpXG5cdFx0XHQ6IGZhbHNlO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCwgX3BvaW50KSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoLFxuXHRcdFx0c2VsZWN0ZWQgPSAhIXNlbGVjdGVkLFxuXHRcdFx0c3RhdGUgPSB0aGlzLl9zZWxlY3Rpb25TdGF0ZSxcblx0XHRcdG9sZFN0YXRlID0gc3RhdGUsXG5cdFx0XHRmbGFnID0gIV9wb2ludCA/IDdcblx0XHRcdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5fcG9pbnQgPyA0XG5cdFx0XHRcdFx0OiBfcG9pbnQgPT09IHRoaXMuX2hhbmRsZUluID8gMVxuXHRcdFx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9oYW5kbGVPdXQgPyAyXG5cdFx0XHRcdFx0OiAwO1xuXHRcdGlmIChzZWxlY3RlZCkge1xuXHRcdFx0c3RhdGUgfD0gZmxhZztcblx0XHR9IGVsc2Uge1xuXHRcdFx0c3RhdGUgJj0gfmZsYWc7XG5cdFx0fVxuXHRcdHRoaXMuX3NlbGVjdGlvblN0YXRlID0gc3RhdGU7XG5cdFx0aWYgKHBhdGggJiYgc3RhdGUgIT09IG9sZFN0YXRlKSB7XG5cdFx0XHRwYXRoLl91cGRhdGVTZWxlY3Rpb24odGhpcywgb2xkU3RhdGUsIHN0YXRlKTtcblx0XHRcdHBhdGguX2NoYW5nZWQoMTI5KTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleCAhPT0gdW5kZWZpbmVkID8gdGhpcy5faW5kZXggOiBudWxsO1xuXHR9LFxuXG5cdGdldFBhdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aCxcblx0XHRcdGluZGV4ID0gdGhpcy5faW5kZXg7XG5cdFx0aWYgKHBhdGgpIHtcblx0XHRcdGlmIChpbmRleCA+IDAgJiYgIXBhdGguX2Nsb3NlZFxuXHRcdFx0XHRcdCYmIGluZGV4ID09PSBwYXRoLl9zZWdtZW50cy5sZW5ndGggLSAxKVxuXHRcdFx0XHRpbmRleC0tO1xuXHRcdFx0cmV0dXJuIHBhdGguZ2V0Q3VydmVzKClbaW5kZXhdIHx8IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIGN1cnZlXG5cdFx0XHRcdD8gbmV3IEN1cnZlTG9jYXRpb24oY3VydmUsIHRoaXMgPT09IGN1cnZlLl9zZWdtZW50MSA/IDAgOiAxKVxuXHRcdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0Z2V0TmV4dDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9zZWdtZW50cztcblx0XHRyZXR1cm4gc2VnbWVudHMgJiYgKHNlZ21lbnRzW3RoaXMuX2luZGV4ICsgMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIHNlZ21lbnRzWzBdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX3NlZ21lbnRzO1xuXHRcdHJldHVybiBzZWdtZW50cyAmJiAoc2VnbWVudHNbdGhpcy5faW5kZXggLSAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0pIHx8IG51bGw7XG5cdH0sXG5cblx0aXNGaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2luZGV4ID09PSAwO1xuXHR9LFxuXG5cdGlzTGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdHJldHVybiBwYXRoICYmIHRoaXMuX2luZGV4ID09PSBwYXRoLl9zZWdtZW50cy5sZW5ndGggLSAxIHx8IGZhbHNlO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBoYW5kbGVJbiA9IHRoaXMuX2hhbmRsZUluLFxuXHRcdFx0aGFuZGxlT3V0ID0gdGhpcy5faGFuZGxlT3V0LFxuXHRcdFx0aW5YID0gaGFuZGxlSW4uX3gsXG5cdFx0XHRpblkgPSBoYW5kbGVJbi5feTtcblx0XHRoYW5kbGVJbi5zZXQoaGFuZGxlT3V0Ll94LCBoYW5kbGVPdXQuX3kpO1xuXHRcdGhhbmRsZU91dC5zZXQoaW5YLCBpblkpO1xuXHR9LFxuXG5cdHJldmVyc2VkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFNlZ21lbnQodGhpcy5fcG9pbnQsIHRoaXMuX2hhbmRsZU91dCwgdGhpcy5faGFuZGxlSW4pO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGggPyAhIXRoaXMuX3BhdGgucmVtb3ZlU2VnbWVudCh0aGlzLl9pbmRleCkgOiBmYWxzZTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTZWdtZW50KHRoaXMuX3BvaW50LCB0aGlzLl9oYW5kbGVJbiwgdGhpcy5faGFuZGxlT3V0KTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHNlZ21lbnQpIHtcblx0XHRyZXR1cm4gc2VnbWVudCA9PT0gdGhpcyB8fCBzZWdtZW50ICYmIHRoaXMuX2NsYXNzID09PSBzZWdtZW50Ll9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9wb2ludC5lcXVhbHMoc2VnbWVudC5fcG9pbnQpXG5cdFx0XHRcdCYmIHRoaXMuX2hhbmRsZUluLmVxdWFscyhzZWdtZW50Ll9oYW5kbGVJbilcblx0XHRcdFx0JiYgdGhpcy5faGFuZGxlT3V0LmVxdWFscyhzZWdtZW50Ll9oYW5kbGVPdXQpXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFydHMgPSBbICdwb2ludDogJyArIHRoaXMuX3BvaW50IF07XG5cdFx0aWYgKCF0aGlzLl9oYW5kbGVJbi5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZUluOiAnICsgdGhpcy5faGFuZGxlSW4pO1xuXHRcdGlmICghdGhpcy5faGFuZGxlT3V0LmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlT3V0OiAnICsgdGhpcy5faGFuZGxlT3V0KTtcblx0XHRyZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuXHR9LFxuXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dGhpcy5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBuZXcgQXJyYXkoNiksIHRydWUpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKG1hdHJpeCwgY29vcmRzLCBjaGFuZ2UpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9wb2ludCxcblx0XHRcdGhhbmRsZUluID0gIWNoYW5nZSB8fCAhdGhpcy5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQ/IHRoaXMuX2hhbmRsZUluIDogbnVsbCxcblx0XHRcdGhhbmRsZU91dCA9ICFjaGFuZ2UgfHwgIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5faGFuZGxlT3V0IDogbnVsbCxcblx0XHRcdHggPSBwb2ludC5feCxcblx0XHRcdHkgPSBwb2ludC5feSxcblx0XHRcdGkgPSAyO1xuXHRcdGNvb3Jkc1swXSA9IHg7XG5cdFx0Y29vcmRzWzFdID0geTtcblx0XHRpZiAoaGFuZGxlSW4pIHtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlSW4uX3ggKyB4O1xuXHRcdFx0Y29vcmRzW2krK10gPSBoYW5kbGVJbi5feSArIHk7XG5cdFx0fVxuXHRcdGlmIChoYW5kbGVPdXQpIHtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlT3V0Ll94ICsgeDtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlT3V0Ll95ICsgeTtcblx0XHR9XG5cdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0bWF0cml4Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhjb29yZHMsIGNvb3JkcywgaSAvIDIpO1xuXHRcdFx0eCA9IGNvb3Jkc1swXTtcblx0XHRcdHkgPSBjb29yZHNbMV07XG5cdFx0XHRpZiAoY2hhbmdlKSB7XG5cdFx0XHRcdHBvaW50Ll94ID0geDtcblx0XHRcdFx0cG9pbnQuX3kgPSB5O1xuXHRcdFx0XHRpICA9IDI7XG5cdFx0XHRcdGlmIChoYW5kbGVJbikge1xuXHRcdFx0XHRcdGhhbmRsZUluLl94ID0gY29vcmRzW2krK10gLSB4O1xuXHRcdFx0XHRcdGhhbmRsZUluLl95ID0gY29vcmRzW2krK10gLSB5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoYW5kbGVPdXQpIHtcblx0XHRcdFx0XHRoYW5kbGVPdXQuX3ggPSBjb29yZHNbaSsrXSAtIHg7XG5cdFx0XHRcdFx0aGFuZGxlT3V0Ll95ID0gY29vcmRzW2krK10gLSB5O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAoIWhhbmRsZUluKSB7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB4O1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIWhhbmRsZU91dCkge1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geDtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNvb3Jkcztcblx0fVxufSk7XG5cbnZhciBTZWdtZW50UG9pbnQgPSBQb2ludC5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTZWdtZW50UG9pbnQocG9pbnQsIG93bmVyLCBrZXkpIHtcblx0XHR2YXIgeCwgeSwgc2VsZWN0ZWQ7XG5cdFx0aWYgKCFwb2ludCkge1xuXHRcdFx0eCA9IHkgPSAwO1xuXHRcdH0gZWxzZSBpZiAoKHggPSBwb2ludFswXSkgIT09IHVuZGVmaW5lZCkge1xuXHRcdFx0eSA9IHBvaW50WzFdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcHQgPSBwb2ludDtcblx0XHRcdGlmICgoeCA9IHB0LngpID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0cHQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdHggPSBwdC54O1xuXHRcdFx0fVxuXHRcdFx0eSA9IHB0Lnk7XG5cdFx0XHRzZWxlY3RlZCA9IHB0LnNlbGVjdGVkO1xuXHRcdH1cblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdG93bmVyW2tleV0gPSB0aGlzO1xuXHRcdGlmIChzZWxlY3RlZClcblx0XHRcdHRoaXMuc2V0U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih4LCB5KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQodGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHZhciBmID0gb3B0aW9ucy5mb3JtYXR0ZXIsXG5cdFx0XHR4ID0gZi5udW1iZXIodGhpcy5feCksXG5cdFx0XHR5ID0gZi5udW1iZXIodGhpcy5feSk7XG5cdFx0cmV0dXJuIHRoaXMuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdD8geyB4OiB4LCB5OiB5LCBzZWxlY3RlZDogdHJ1ZSB9XG5cdFx0XHRcdDogW3gsIHldO1xuXHR9LFxuXG5cdGdldFg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl94O1xuXHR9LFxuXG5cdHNldFg6IGZ1bmN0aW9uKHgpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl9vd25lci5fY2hhbmdlZCh0aGlzKTtcblx0fSxcblxuXHRnZXRZOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feTtcblx0fSxcblxuXHRzZXRZOiBmdW5jdGlvbih5KSB7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQodGhpcyk7XG5cdH0sXG5cblx0aXNaZXJvOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTnVtZXJpY2FsLmlzWmVybyh0aGlzLl94KSAmJiBOdW1lcmljYWwuaXNaZXJvKHRoaXMuX3kpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHRoaXMuX293bmVyLnNldFNlbGVjdGVkKHNlbGVjdGVkLCB0aGlzKTtcblx0fSxcblxuXHRpc1NlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fb3duZXIuaXNTZWxlY3RlZCh0aGlzKTtcblx0fVxufSk7XG5cbnZhciBDdXJ2ZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ3VydmUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlKGFyZzAsIGFyZzEsIGFyZzIsIGFyZzMsIGFyZzQsIGFyZzUsIGFyZzYsIGFyZzcpIHtcblx0XHR2YXIgY291bnQgPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdFx0c2VnMSwgc2VnMixcblx0XHRcdHBvaW50MSwgcG9pbnQyLFxuXHRcdFx0aGFuZGxlMSwgaGFuZGxlMjtcblx0XHRpZiAoY291bnQgPT09IDMpIHtcblx0XHRcdHRoaXMuX3BhdGggPSBhcmcwO1xuXHRcdFx0c2VnMSA9IGFyZzE7XG5cdFx0XHRzZWcyID0gYXJnMjtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAwKSB7XG5cdFx0XHRzZWcxID0gbmV3IFNlZ21lbnQoKTtcblx0XHRcdHNlZzIgPSBuZXcgU2VnbWVudCgpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcblx0XHRcdGlmICgnc2VnbWVudDEnIGluIGFyZzApIHtcblx0XHRcdFx0c2VnMSA9IG5ldyBTZWdtZW50KGFyZzAuc2VnbWVudDEpO1xuXHRcdFx0XHRzZWcyID0gbmV3IFNlZ21lbnQoYXJnMC5zZWdtZW50Mik7XG5cdFx0XHR9IGVsc2UgaWYgKCdwb2ludDEnIGluIGFyZzApIHtcblx0XHRcdFx0cG9pbnQxID0gYXJnMC5wb2ludDE7XG5cdFx0XHRcdGhhbmRsZTEgPSBhcmcwLmhhbmRsZTE7XG5cdFx0XHRcdGhhbmRsZTIgPSBhcmcwLmhhbmRsZTI7XG5cdFx0XHRcdHBvaW50MiA9IGFyZzAucG9pbnQyO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdHBvaW50MSA9IFthcmcwWzBdLCBhcmcwWzFdXTtcblx0XHRcdFx0cG9pbnQyID0gW2FyZzBbNl0sIGFyZzBbN11dO1xuXHRcdFx0XHRoYW5kbGUxID0gW2FyZzBbMl0gLSBhcmcwWzBdLCBhcmcwWzNdIC0gYXJnMFsxXV07XG5cdFx0XHRcdGhhbmRsZTIgPSBbYXJnMFs0XSAtIGFyZzBbNl0sIGFyZzBbNV0gLSBhcmcwWzddXTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAyKSB7XG5cdFx0XHRzZWcxID0gbmV3IFNlZ21lbnQoYXJnMCk7XG5cdFx0XHRzZWcyID0gbmV3IFNlZ21lbnQoYXJnMSk7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gNCkge1xuXHRcdFx0cG9pbnQxID0gYXJnMDtcblx0XHRcdGhhbmRsZTEgPSBhcmcxO1xuXHRcdFx0aGFuZGxlMiA9IGFyZzI7XG5cdFx0XHRwb2ludDIgPSBhcmczO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDgpIHtcblx0XHRcdHBvaW50MSA9IFthcmcwLCBhcmcxXTtcblx0XHRcdHBvaW50MiA9IFthcmc2LCBhcmc3XTtcblx0XHRcdGhhbmRsZTEgPSBbYXJnMiAtIGFyZzAsIGFyZzMgLSBhcmcxXTtcblx0XHRcdGhhbmRsZTIgPSBbYXJnNCAtIGFyZzYsIGFyZzUgLSBhcmc3XTtcblx0XHR9XG5cdFx0dGhpcy5fc2VnbWVudDEgPSBzZWcxIHx8IG5ldyBTZWdtZW50KHBvaW50MSwgbnVsbCwgaGFuZGxlMSk7XG5cdFx0dGhpcy5fc2VnbWVudDIgPSBzZWcyIHx8IG5ldyBTZWdtZW50KHBvaW50MiwgaGFuZGxlMiwgbnVsbCk7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmhhc0hhbmRsZXMoKVxuXHRcdFx0XHQ/IFt0aGlzLmdldFBvaW50MSgpLCB0aGlzLmdldEhhbmRsZTEoKSwgdGhpcy5nZXRIYW5kbGUyKCksXG5cdFx0XHRcdFx0dGhpcy5nZXRQb2ludDIoKV1cblx0XHRcdFx0OiBbdGhpcy5nZXRQb2ludDEoKSwgdGhpcy5nZXRQb2ludDIoKV0sXG5cdFx0XHRcdG9wdGlvbnMsIHRydWUpO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9sZW5ndGggPSB0aGlzLl9ib3VuZHMgPSB1bmRlZmluZWQ7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgQ3VydmUodGhpcy5fc2VnbWVudDEsIHRoaXMuX3NlZ21lbnQyKTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcnRzID0gWyAncG9pbnQxOiAnICsgdGhpcy5fc2VnbWVudDEuX3BvaW50IF07XG5cdFx0aWYgKCF0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlMTogJyArIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQpO1xuXHRcdGlmICghdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLmlzWmVybygpKVxuXHRcdFx0cGFydHMucHVzaCgnaGFuZGxlMjogJyArIHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbik7XG5cdFx0cGFydHMucHVzaCgncG9pbnQyOiAnICsgdGhpcy5fc2VnbWVudDIuX3BvaW50KTtcblx0XHRyZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHJlbW92ZWQgPSBmYWxzZTtcblx0XHRpZiAodGhpcy5fcGF0aCkge1xuXHRcdFx0dmFyIHNlZ21lbnQyID0gdGhpcy5fc2VnbWVudDIsXG5cdFx0XHRcdGhhbmRsZU91dCA9IHNlZ21lbnQyLl9oYW5kbGVPdXQ7XG5cdFx0XHRyZW1vdmVkID0gc2VnbWVudDIucmVtb3ZlKCk7XG5cdFx0XHRpZiAocmVtb3ZlZClcblx0XHRcdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQoaGFuZGxlT3V0LngsIGhhbmRsZU91dC55KTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdH0sXG5cblx0Z2V0UG9pbnQxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX3BvaW50O1xuXHR9LFxuXG5cdHNldFBvaW50MTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NlZ21lbnQxLl9wb2ludC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0UG9pbnQyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDIuX3BvaW50O1xuXHR9LFxuXG5cdHNldFBvaW50MjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NlZ21lbnQyLl9wb2ludC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlMTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQ7XG5cdH0sXG5cblx0c2V0SGFuZGxlMTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZTI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW47XG5cdH0sXG5cblx0c2V0SGFuZGxlMjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0U2VnbWVudDE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MTtcblx0fSxcblxuXHRnZXRTZWdtZW50MjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQyO1xuXHR9LFxuXG5cdGdldFBhdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX2luZGV4O1xuXHR9LFxuXG5cdGdldE5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX2N1cnZlcztcblx0XHRyZXR1cm4gY3VydmVzICYmIChjdXJ2ZXNbdGhpcy5fc2VnbWVudDEuX2luZGV4ICsgMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIGN1cnZlc1swXSkgfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fY3VydmVzO1xuXHRcdHJldHVybiBjdXJ2ZXMgJiYgKGN1cnZlc1t0aGlzLl9zZWdtZW50MS5faW5kZXggLSAxXVxuXHRcdFx0XHR8fCB0aGlzLl9wYXRoLl9jbG9zZWQgJiYgY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSkgfHwgbnVsbDtcblx0fSxcblxuXHRpc0ZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDEuX2luZGV4ID09PSAwO1xuXHR9LFxuXG5cdGlzTGFzdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdHJldHVybiBwYXRoICYmIHRoaXMuX3NlZ21lbnQxLl9pbmRleCA9PT0gcGF0aC5fY3VydmVzLmxlbmd0aCAtIDFcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0UG9pbnQxKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0SGFuZGxlMigpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldEhhbmRsZTIoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRQb2ludDIoKS5pc1NlbGVjdGVkKCk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dGhpcy5nZXRQb2ludDEoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRIYW5kbGUxKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0SGFuZGxlMigpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldFBvaW50MigpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0fSxcblxuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRWYWx1ZXModGhpcy5fc2VnbWVudDEsIHRoaXMuX3NlZ21lbnQyLCBtYXRyaXgpO1xuXHR9LFxuXG5cdGdldFBvaW50czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNvb3JkcyA9IHRoaXMuZ2V0VmFsdWVzKCksXG5cdFx0XHRwb2ludHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkgKz0gMilcblx0XHRcdHBvaW50cy5wdXNoKG5ldyBQb2ludChjb29yZHNbaV0sIGNvb3Jkc1tpICsgMV0pKTtcblx0XHRyZXR1cm4gcG9pbnRzO1xuXHR9LFxuXG5cdGdldExlbmd0aDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2xlbmd0aCA9PSBudWxsKVxuXHRcdFx0dGhpcy5fbGVuZ3RoID0gQ3VydmUuZ2V0TGVuZ3RoKHRoaXMuZ2V0VmFsdWVzKCksIDAsIDEpO1xuXHRcdHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldEFyZWEodGhpcy5nZXRWYWx1ZXMoKSk7XG5cdH0sXG5cblx0Z2V0TGluZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBMaW5lKHRoaXMuX3NlZ21lbnQxLl9wb2ludCwgdGhpcy5fc2VnbWVudDIuX3BvaW50KTtcblx0fSxcblxuXHRnZXRQYXJ0OiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdHJldHVybiBuZXcgQ3VydmUoQ3VydmUuZ2V0UGFydCh0aGlzLmdldFZhbHVlcygpLCBmcm9tLCB0bykpO1xuXHR9LFxuXG5cdGdldFBhcnRMZW5ndGg6IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldExlbmd0aCh0aGlzLmdldFZhbHVlcygpLCBmcm9tLCB0byk7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uczogZnVuY3Rpb24oY3VydmUpIHtcblx0XHRyZXR1cm4gQ3VydmUuX2dldEludGVyc2VjdGlvbnModGhpcy5nZXRWYWx1ZXMoKSxcblx0XHRcdFx0Y3VydmUgJiYgY3VydmUgIT09IHRoaXMgPyBjdXJ2ZS5nZXRWYWx1ZXMoKSA6IG51bGwsXG5cdFx0XHRcdHRoaXMsIGN1cnZlLCBbXSwge30pO1xuXHR9LFxuXG5cdF9nZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHRyZXR1cm4gaXNQYXJhbWV0ZXJcblx0XHRcdFx0PyBvZmZzZXRcblx0XHRcdFx0OiBvZmZzZXQgJiYgb2Zmc2V0LmN1cnZlID09PSB0aGlzXG5cdFx0XHRcdFx0PyBvZmZzZXQucGFyYW1ldGVyXG5cdFx0XHRcdFx0OiBvZmZzZXQgPT09IHVuZGVmaW5lZCAmJiBpc1BhcmFtZXRlciA9PT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0XHQ/IDAuNVxuXHRcdFx0XHRcdFx0OiB0aGlzLmdldFBhcmFtZXRlckF0KG9mZnNldCwgMCk7XG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyLCBfc2V0SGFuZGxlcykge1xuXHRcdHZhciBwYXJhbWV0ZXIgPSB0aGlzLl9nZXRQYXJhbWV0ZXIob2Zmc2V0LCBpc1BhcmFtZXRlciksXG5cdFx0XHR0TWluID0gNGUtNyxcblx0XHRcdHRNYXggPSAxIC0gdE1pbixcblx0XHRcdHJlcyA9IG51bGw7XG5cdFx0aWYgKHBhcmFtZXRlciA+PSB0TWluICYmIHBhcmFtZXRlciA8PSB0TWF4KSB7XG5cdFx0XHR2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodGhpcy5nZXRWYWx1ZXMoKSwgcGFyYW1ldGVyKSxcblx0XHRcdFx0bGVmdCA9IHBhcnRzWzBdLFxuXHRcdFx0XHRyaWdodCA9IHBhcnRzWzFdLFxuXHRcdFx0XHRzZXRIYW5kbGVzID0gX3NldEhhbmRsZXMgfHwgdGhpcy5oYXNIYW5kbGVzKCksXG5cdFx0XHRcdHNlZ21lbnQxID0gdGhpcy5fc2VnbWVudDEsXG5cdFx0XHRcdHNlZ21lbnQyID0gdGhpcy5fc2VnbWVudDIsXG5cdFx0XHRcdHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdFx0aWYgKHNldEhhbmRsZXMpIHtcblx0XHRcdFx0c2VnbWVudDEuX2hhbmRsZU91dC5zZXQobGVmdFsyXSAtIGxlZnRbMF0sXG5cdFx0XHRcdFx0XHRsZWZ0WzNdIC0gbGVmdFsxXSk7XG5cdFx0XHRcdHNlZ21lbnQyLl9oYW5kbGVJbi5zZXQocmlnaHRbNF0gLSByaWdodFs2XSxcblx0XHRcdFx0XHRcdHJpZ2h0WzVdIC0gcmlnaHRbN10pO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHggPSBsZWZ0WzZdLCB5ID0gbGVmdFs3XSxcblx0XHRcdFx0c2VnbWVudCA9IG5ldyBTZWdtZW50KG5ldyBQb2ludCh4LCB5KSxcblx0XHRcdFx0XHRcdHNldEhhbmRsZXMgJiYgbmV3IFBvaW50KGxlZnRbNF0gLSB4LCBsZWZ0WzVdIC0geSksXG5cdFx0XHRcdFx0XHRzZXRIYW5kbGVzICYmIG5ldyBQb2ludChyaWdodFsyXSAtIHgsIHJpZ2h0WzNdIC0geSkpO1xuXHRcdFx0aWYgKHBhdGgpIHtcblx0XHRcdFx0cGF0aC5pbnNlcnQoc2VnbWVudDEuX2luZGV4ICsgMSwgc2VnbWVudCk7XG5cdFx0XHRcdHJlcyA9IHRoaXMuZ2V0TmV4dCgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5fc2VnbWVudDIgPSBzZWdtZW50O1xuXHRcdFx0XHRyZXMgPSBuZXcgQ3VydmUoc2VnbWVudCwgc2VnbWVudDIpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdHNwbGl0OiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhdGhcblx0XHRcdD8gdGhpcy5fcGF0aC5zcGxpdCh0aGlzLl9zZWdtZW50MS5faW5kZXgsXG5cdFx0XHRcdFx0dGhpcy5fZ2V0UGFyYW1ldGVyKG9mZnNldCwgaXNQYXJhbWV0ZXIpKVxuXHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdHJldmVyc2VkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQyLnJldmVyc2VkKCksIHRoaXMuX3NlZ21lbnQxLnJldmVyc2VkKCkpO1xuXHR9LFxuXG5cdGNsZWFySGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5zZXQoMCwgMCk7XG5cdFx0dGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLnNldCgwLCAwKTtcblx0fSxcblxuc3RhdGljczoge1xuXHRnZXRWYWx1ZXM6IGZ1bmN0aW9uKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4KSB7XG5cdFx0dmFyIHAxID0gc2VnbWVudDEuX3BvaW50LFxuXHRcdFx0aDEgPSBzZWdtZW50MS5faGFuZGxlT3V0LFxuXHRcdFx0aDIgPSBzZWdtZW50Mi5faGFuZGxlSW4sXG5cdFx0XHRwMiA9IHNlZ21lbnQyLl9wb2ludCxcblx0XHRcdHZhbHVlcyA9IFtcblx0XHRcdFx0cDEuX3gsIHAxLl95LFxuXHRcdFx0XHRwMS5feCArIGgxLl94LCBwMS5feSArIGgxLl95LFxuXHRcdFx0XHRwMi5feCArIGgyLl94LCBwMi5feSArIGgyLl95LFxuXHRcdFx0XHRwMi5feCwgcDIuX3lcblx0XHRcdF07XG5cdFx0aWYgKG1hdHJpeClcblx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXModmFsdWVzLCB2YWx1ZXMsIDQpO1xuXHRcdHJldHVybiB2YWx1ZXM7XG5cdH0sXG5cblx0c3ViZGl2aWRlOiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN107XG5cdFx0aWYgKHQgPT09IHVuZGVmaW5lZClcblx0XHRcdHQgPSAwLjU7XG5cdFx0dmFyIHUgPSAxIC0gdCxcblx0XHRcdHAzeCA9IHUgKiBwMXggKyB0ICogYzF4LCBwM3kgPSB1ICogcDF5ICsgdCAqIGMxeSxcblx0XHRcdHA0eCA9IHUgKiBjMXggKyB0ICogYzJ4LCBwNHkgPSB1ICogYzF5ICsgdCAqIGMyeSxcblx0XHRcdHA1eCA9IHUgKiBjMnggKyB0ICogcDJ4LCBwNXkgPSB1ICogYzJ5ICsgdCAqIHAyeSxcblx0XHRcdHA2eCA9IHUgKiBwM3ggKyB0ICogcDR4LCBwNnkgPSB1ICogcDN5ICsgdCAqIHA0eSxcblx0XHRcdHA3eCA9IHUgKiBwNHggKyB0ICogcDV4LCBwN3kgPSB1ICogcDR5ICsgdCAqIHA1eSxcblx0XHRcdHA4eCA9IHUgKiBwNnggKyB0ICogcDd4LCBwOHkgPSB1ICogcDZ5ICsgdCAqIHA3eTtcblx0XHRyZXR1cm4gW1xuXHRcdFx0W3AxeCwgcDF5LCBwM3gsIHAzeSwgcDZ4LCBwNnksIHA4eCwgcDh5XSxcblx0XHRcdFtwOHgsIHA4eSwgcDd4LCBwN3ksIHA1eCwgcDV5LCBwMngsIHAyeV1cblx0XHRdO1xuXHR9LFxuXG5cdHNvbHZlQ3ViaWM6IGZ1bmN0aW9uICh2LCBjb29yZCwgdmFsLCByb290cywgbWluLCBtYXgpIHtcblx0XHR2YXIgcDEgPSB2W2Nvb3JkXSxcblx0XHRcdGMxID0gdltjb29yZCArIDJdLFxuXHRcdFx0YzIgPSB2W2Nvb3JkICsgNF0sXG5cdFx0XHRwMiA9IHZbY29vcmQgKyA2XSxcblx0XHRcdGMgPSAzICogKGMxIC0gcDEpLFxuXHRcdFx0YiA9IDMgKiAoYzIgLSBjMSkgLSBjLFxuXHRcdFx0YSA9IHAyIC0gcDEgLSBjIC0gYjtcblx0XHRyZXR1cm4gTnVtZXJpY2FsLnNvbHZlQ3ViaWMoYSwgYiwgYywgcDEgLSB2YWwsIHJvb3RzLCBtaW4sIG1heCk7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyT2Y6IGZ1bmN0aW9uKHYsIHBvaW50KSB7XG5cdFx0dmFyIHAxID0gbmV3IFBvaW50KHZbMF0sIHZbMV0pLFxuXHRcdFx0cDIgPSBuZXcgUG9pbnQodls2XSwgdls3XSksXG5cdFx0XHRlcHNpbG9uID0gMWUtMTIsXG5cdFx0XHR0ID0gcG9pbnQuaXNDbG9zZShwMSwgZXBzaWxvbikgPyAwXG5cdFx0XHQgIDogcG9pbnQuaXNDbG9zZShwMiwgZXBzaWxvbikgPyAxXG5cdFx0XHQgIDogbnVsbDtcblx0XHRpZiAodCAhPT0gbnVsbClcblx0XHRcdHJldHVybiB0O1xuXHRcdHZhciBjb29yZHMgPSBbcG9pbnQueCwgcG9pbnQueV0sXG5cdFx0XHRyb290cyA9IFtdLFxuXHRcdFx0Z2VvbUVwc2lsb24gPSAyZS03O1xuXHRcdGZvciAodmFyIGMgPSAwOyBjIDwgMjsgYysrKSB7XG5cdFx0XHR2YXIgY291bnQgPSBDdXJ2ZS5zb2x2ZUN1YmljKHYsIGMsIGNvb3Jkc1tjXSwgcm9vdHMsIDAsIDEpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHRcdHQgPSByb290c1tpXTtcblx0XHRcdFx0aWYgKHBvaW50LmlzQ2xvc2UoQ3VydmUuZ2V0UG9pbnQodiwgdCksIGdlb21FcHNpbG9uKSlcblx0XHRcdFx0XHRyZXR1cm4gdDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50LmlzQ2xvc2UocDEsIGdlb21FcHNpbG9uKSA/IDBcblx0XHRcdCA6IHBvaW50LmlzQ2xvc2UocDIsIGdlb21FcHNpbG9uKSA/IDFcblx0XHRcdCA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdFBhcmFtZXRlcjogZnVuY3Rpb24odiwgcG9pbnQpIHtcblx0XHRpZiAoQ3VydmUuaXNTdHJhaWdodCh2KSkge1xuXHRcdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cdFx0XHRcdHZ4ID0gcDJ4IC0gcDF4LCB2eSA9IHAyeSAtIHAxeSxcblx0XHRcdFx0ZGV0ID0gdnggKiB2eCArIHZ5ICogdnk7XG5cdFx0XHRpZiAoZGV0ID09PSAwKVxuXHRcdFx0XHRyZXR1cm4gMDtcblx0XHRcdHZhciB1ID0gKChwb2ludC54IC0gcDF4KSAqIHZ4ICsgKHBvaW50LnkgLSBwMXkpICogdnkpIC8gZGV0O1xuXHRcdFx0cmV0dXJuIHUgPCAxZS0xMiA/IDBcblx0XHRcdFx0IDogdSA+IDAuOTk5OTk5OTk5OTk5ID8gMVxuXHRcdFx0XHQgOiBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih2LFxuXHRcdFx0XHRcdG5ldyBQb2ludChwMXggKyB1ICogdngsIHAxeSArIHUgKiB2eSkpO1xuXHRcdH1cblxuXHRcdHZhciBjb3VudCA9IDEwMCxcblx0XHRcdG1pbkRpc3QgPSBJbmZpbml0eSxcblx0XHRcdG1pblQgPSAwO1xuXG5cdFx0ZnVuY3Rpb24gcmVmaW5lKHQpIHtcblx0XHRcdGlmICh0ID49IDAgJiYgdCA8PSAxKSB7XG5cdFx0XHRcdHZhciBkaXN0ID0gcG9pbnQuZ2V0RGlzdGFuY2UoQ3VydmUuZ2V0UG9pbnQodiwgdCksIHRydWUpO1xuXHRcdFx0XHRpZiAoZGlzdCA8IG1pbkRpc3QpIHtcblx0XHRcdFx0XHRtaW5EaXN0ID0gZGlzdDtcblx0XHRcdFx0XHRtaW5UID0gdDtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspXG5cdFx0XHRyZWZpbmUoaSAvIGNvdW50KTtcblxuXHRcdHZhciBzdGVwID0gMSAvIChjb3VudCAqIDIpO1xuXHRcdHdoaWxlIChzdGVwID4gNGUtNykge1xuXHRcdFx0aWYgKCFyZWZpbmUobWluVCAtIHN0ZXApICYmICFyZWZpbmUobWluVCArIHN0ZXApKVxuXHRcdFx0XHRzdGVwIC89IDI7XG5cdFx0fVxuXHRcdHJldHVybiBtaW5UO1xuXHR9LFxuXG5cdGdldFBhcnQ6IGZ1bmN0aW9uKHYsIGZyb20sIHRvKSB7XG5cdFx0dmFyIGZsaXAgPSBmcm9tID4gdG87XG5cdFx0aWYgKGZsaXApIHtcblx0XHRcdHZhciB0bXAgPSBmcm9tO1xuXHRcdFx0ZnJvbSA9IHRvO1xuXHRcdFx0dG8gPSB0bXA7XG5cdFx0fVxuXHRcdGlmIChmcm9tID4gMClcblx0XHRcdHYgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgZnJvbSlbMV07XG5cdFx0aWYgKHRvIDwgMSlcblx0XHRcdHYgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgKHRvIC0gZnJvbSkgLyAoMSAtIGZyb20pKVswXTtcblx0XHRyZXR1cm4gZmxpcFxuXHRcdFx0XHQ/IFt2WzZdLCB2WzddLCB2WzRdLCB2WzVdLCB2WzJdLCB2WzNdLCB2WzBdLCB2WzFdXVxuXHRcdFx0XHQ6IHY7XG5cdH0sXG5cblx0aGFzSGFuZGxlczogZnVuY3Rpb24odikge1xuXHRcdHZhciBpc1plcm8gPSBOdW1lcmljYWwuaXNaZXJvO1xuXHRcdHJldHVybiAhKGlzWmVybyh2WzBdIC0gdlsyXSkgJiYgaXNaZXJvKHZbMV0gLSB2WzNdKVxuXHRcdFx0XHQmJiBpc1plcm8odls0XSAtIHZbNl0pICYmIGlzWmVybyh2WzVdIC0gdls3XSkpO1xuXHR9LFxuXG5cdGlzRmxhdEVub3VnaDogZnVuY3Rpb24odiwgdG9sZXJhbmNlKSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cdFx0XHR1eCA9IDMgKiBjMXggLSAyICogcDF4IC0gcDJ4LFxuXHRcdFx0dXkgPSAzICogYzF5IC0gMiAqIHAxeSAtIHAyeSxcblx0XHRcdHZ4ID0gMyAqIGMyeCAtIDIgKiBwMnggLSBwMXgsXG5cdFx0XHR2eSA9IDMgKiBjMnkgLSAyICogcDJ5IC0gcDF5O1xuXHRcdHJldHVybiBNYXRoLm1heCh1eCAqIHV4LCB2eCAqIHZ4KSArIE1hdGgubWF4KHV5ICogdXksIHZ5ICogdnkpXG5cdFx0XHRcdDwgMTAgKiB0b2xlcmFuY2UgKiB0b2xlcmFuY2U7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24odikge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcblx0XHRcdGgxeCA9ICh2WzJdICsgcDF4KSAvIDIsXG5cdFx0XHRoMXkgPSAodlszXSArIHAxeSkgLyAyLFxuXHRcdFx0aDJ4ID0gKHZbNF0gKyB2WzZdKSAvIDIsXG5cdFx0XHRoMnkgPSAodls1XSArIHZbN10pIC8gMjtcblx0XHRyZXR1cm4gNiAqICgocDF4IC0gaDF4KSAqIChoMXkgKyBwMXkpXG5cdFx0XHRcdCAgKyAoaDF4IC0gaDJ4KSAqIChoMnkgKyBoMXkpXG5cdFx0XHRcdCAgKyAoaDJ4IC0gcDJ4KSAqIChwMnkgKyBoMnkpKSAvIDEwO1xuXHR9LFxuXG5cdGdldEJvdW5kczogZnVuY3Rpb24odikge1xuXHRcdHZhciBtaW4gPSB2LnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCksXG5cdFx0XHRyb290cyA9IFswLCAwXTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKylcblx0XHRcdEN1cnZlLl9hZGRCb3VuZHModltpXSwgdltpICsgMl0sIHZbaSArIDRdLCB2W2kgKyA2XSxcblx0XHRcdFx0XHRpLCAwLCBtaW4sIG1heCwgcm9vdHMpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKG1pblswXSwgbWluWzFdLCBtYXhbMF0gLSBtaW5bMF0sIG1heFsxXSAtIG1pblsxXSk7XG5cdH0sXG5cblx0X2FkZEJvdW5kczogZnVuY3Rpb24odjAsIHYxLCB2MiwgdjMsIGNvb3JkLCBwYWRkaW5nLCBtaW4sIG1heCwgcm9vdHMpIHtcblx0XHRmdW5jdGlvbiBhZGQodmFsdWUsIHBhZGRpbmcpIHtcblx0XHRcdHZhciBsZWZ0ID0gdmFsdWUgLSBwYWRkaW5nLFxuXHRcdFx0XHRyaWdodCA9IHZhbHVlICsgcGFkZGluZztcblx0XHRcdGlmIChsZWZ0IDwgbWluW2Nvb3JkXSlcblx0XHRcdFx0bWluW2Nvb3JkXSA9IGxlZnQ7XG5cdFx0XHRpZiAocmlnaHQgPiBtYXhbY29vcmRdKVxuXHRcdFx0XHRtYXhbY29vcmRdID0gcmlnaHQ7XG5cdFx0fVxuXHRcdHZhciBhID0gMyAqICh2MSAtIHYyKSAtIHYwICsgdjMsXG5cdFx0XHRiID0gMiAqICh2MCArIHYyKSAtIDQgKiB2MSxcblx0XHRcdGMgPSB2MSAtIHYwLFxuXHRcdFx0Y291bnQgPSBOdW1lcmljYWwuc29sdmVRdWFkcmF0aWMoYSwgYiwgYywgcm9vdHMpLFxuXHRcdFx0dE1pbiA9IDRlLTcsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0YWRkKHYzLCAwKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdHZhciB0ID0gcm9vdHNbaV0sXG5cdFx0XHRcdHUgPSAxIC0gdDtcblx0XHRcdGlmICh0TWluIDwgdCAmJiB0IDwgdE1heClcblx0XHRcdFx0YWRkKHUgKiB1ICogdSAqIHYwXG5cdFx0XHRcdFx0KyAzICogdSAqIHUgKiB0ICogdjFcblx0XHRcdFx0XHQrIDMgKiB1ICogdCAqIHQgKiB2MlxuXHRcdFx0XHRcdCsgdCAqIHQgKiB0ICogdjMsXG5cdFx0XHRcdFx0cGFkZGluZyk7XG5cdFx0fVxuXHR9XG59fSwgQmFzZS5lYWNoKFxuXHRbJ2dldEJvdW5kcycsICdnZXRTdHJva2VCb3VuZHMnLCAnZ2V0SGFuZGxlQm91bmRzJywgJ2dldFJvdWdoQm91bmRzJ10sXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdFx0dGhpcy5fYm91bmRzID0ge307XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdO1xuXHRcdFx0aWYgKCFib3VuZHMpIHtcblx0XHRcdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdFx0XHRib3VuZHMgPSB0aGlzLl9ib3VuZHNbbmFtZV0gPSBQYXRoW25hbWVdKFxuXHRcdFx0XHRcdFx0W3RoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50Ml0sIGZhbHNlLFxuXHRcdFx0XHRcdFx0cGF0aCAmJiBwYXRoLmdldFN0eWxlKCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJvdW5kcy5jbG9uZSgpO1xuXHRcdH07XG5cdH0sXG57XG5cbn0pLCBCYXNlLmVhY2goe1xuXHRpc1N0cmFpZ2h0OiBmdW5jdGlvbihsLCBoMSwgaDIpIHtcblx0XHRpZiAoaDEuaXNaZXJvKCkgJiYgaDIuaXNaZXJvKCkpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH0gZWxzZSBpZiAobC5pc1plcm8oKSkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH0gZWxzZSBpZiAoaDEuaXNDb2xsaW5lYXIobCkgJiYgaDIuaXNDb2xsaW5lYXIobCkpIHtcblx0XHRcdHZhciBkaXYgPSBsLmRvdChsKSxcblx0XHRcdFx0cDEgPSBsLmRvdChoMSkgLyBkaXYsXG5cdFx0XHRcdHAyID0gbC5kb3QoaDIpIC8gZGl2O1xuXHRcdFx0cmV0dXJuIHAxID49IDAgJiYgcDEgPD0gMSAmJiBwMiA8PSAwICYmIHAyID49IC0xO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0aXNMaW5lYXI6IGZ1bmN0aW9uKGwsIGgxLCBoMikge1xuXHRcdHZhciB0aGlyZCA9IGwuZGl2aWRlKDMpO1xuXHRcdHJldHVybiBoMS5lcXVhbHModGhpcmQpICYmIGgyLm5lZ2F0ZSgpLmVxdWFscyh0aGlyZCk7XG5cdH1cbn0sIGZ1bmN0aW9uKHRlc3QsIG5hbWUpIHtcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWcxID0gdGhpcy5fc2VnbWVudDEsXG5cdFx0XHRzZWcyID0gdGhpcy5fc2VnbWVudDI7XG5cdFx0cmV0dXJuIHRlc3Qoc2VnMi5fcG9pbnQuc3VidHJhY3Qoc2VnMS5fcG9pbnQpLFxuXHRcdFx0XHRzZWcxLl9oYW5kbGVPdXQsIHNlZzIuX2hhbmRsZUluKTtcblx0fTtcblxuXHR0aGlzLnN0YXRpY3NbbmFtZV0gPSBmdW5jdGlvbih2KSB7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddO1xuXHRcdHJldHVybiB0ZXN0KG5ldyBQb2ludChwMnggLSBwMXgsIHAyeSAtIHAxeSksXG5cdFx0XHRcdG5ldyBQb2ludCh2WzJdIC0gcDF4LCB2WzNdIC0gcDF5KSxcblx0XHRcdFx0bmV3IFBvaW50KHZbNF0gLSBwMngsIHZbNV0gLSBwMnkpKTtcblx0fTtcbn0sIHtcblx0c3RhdGljczoge30sXG5cblx0aGFzSGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LmlzWmVybygpXG5cdFx0XHRcdHx8ICF0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uaXNaZXJvKCk7XG5cdH0sXG5cblx0aXNDb2xsaW5lYXI6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0cmV0dXJuIGN1cnZlICYmIHRoaXMuaXNTdHJhaWdodCgpICYmIGN1cnZlLmlzU3RyYWlnaHQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldExpbmUoKS5pc0NvbGxpbmVhcihjdXJ2ZS5nZXRMaW5lKCkpO1xuXHR9LFxuXG5cdGlzSG9yaXpvbnRhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNTdHJhaWdodCgpICYmIE1hdGguYWJzKHRoaXMuZ2V0VGFuZ2VudEF0KDAuNSwgdHJ1ZSkueSlcblx0XHRcdFx0PCAxZS03O1xuXHR9LFxuXG5cdGlzVmVydGljYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlzU3RyYWlnaHQoKSAmJiBNYXRoLmFicyh0aGlzLmdldFRhbmdlbnRBdCgwLjUsIHRydWUpLngpXG5cdFx0XHRcdDwgMWUtNztcblx0fVxufSksIHtcblx0YmVhbnM6IGZhbHNlLFxuXG5cdGdldFBhcmFtZXRlckF0OiBmdW5jdGlvbihvZmZzZXQsIHN0YXJ0KSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldFBhcmFtZXRlckF0KHRoaXMuZ2V0VmFsdWVzKCksIG9mZnNldCwgc3RhcnQpO1xuXHR9LFxuXG5cdGdldFBhcmFtZXRlck9mOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0UGFyYW1ldGVyT2YodGhpcy5nZXRWYWx1ZXMoKSwgUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRnZXRMb2NhdGlvbkF0OiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0dmFyIHQgPSBpc1BhcmFtZXRlciA/IG9mZnNldCA6IHRoaXMuZ2V0UGFyYW1ldGVyQXQob2Zmc2V0KTtcblx0XHRyZXR1cm4gdCAhPSBudWxsICYmIHQgPj0gMCAmJiB0IDw9IDFcblx0XHRcdFx0PyBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCB0KVxuXHRcdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25PZjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TG9jYXRpb25BdCh0aGlzLmdldFBhcmFtZXRlck9mKFBvaW50LnJlYWQoYXJndW1lbnRzKSksXG5cdFx0XHRcdHRydWUpO1xuXHR9LFxuXG5cdGdldE9mZnNldE9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRPZmZzZXQoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpLFxuXHRcdFx0dCA9IEN1cnZlLmdldE5lYXJlc3RQYXJhbWV0ZXIodmFsdWVzLCBwb2ludCksXG5cdFx0XHRwdCA9IEN1cnZlLmdldFBvaW50KHZhbHVlcywgdCk7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZUxvY2F0aW9uKHRoaXMsIHQsIHB0LCBudWxsLCBwb2ludC5nZXREaXN0YW5jZShwdCkpO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZ2V0UG9pbnQoKTtcblx0fVxuXG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgbWV0aG9kcyA9IFsnZ2V0UG9pbnQnLCAnZ2V0VGFuZ2VudCcsICdnZXROb3JtYWwnLCAnZ2V0V2VpZ2h0ZWRUYW5nZW50Jyxcblx0XHQnZ2V0V2VpZ2h0ZWROb3JtYWwnLCAnZ2V0Q3VydmF0dXJlJ107XG5cdHJldHVybiBCYXNlLmVhY2gobWV0aG9kcyxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdFx0dmFyIHZhbHVlcyA9IHRoaXMuZ2V0VmFsdWVzKCk7XG5cdFx0XHRyZXR1cm4gQ3VydmVbbmFtZV0odmFsdWVzLCBpc1BhcmFtZXRlciA/IG9mZnNldFxuXHRcdFx0XHRcdDogQ3VydmUuZ2V0UGFyYW1ldGVyQXQodmFsdWVzLCBvZmZzZXQsIDApKTtcblx0XHR9O1xuXHR9LCB7XG5cdFx0c3RhdGljczoge1xuXHRcdFx0ZXZhbHVhdGVNZXRob2RzOiBtZXRob2RzXG5cdFx0fVxuXHR9KVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBnZXRMZW5ndGhJbnRlZ3JhbmQodikge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddLFxuXG5cdFx0XHRheCA9IDkgKiAoYzF4IC0gYzJ4KSArIDMgKiAocDJ4IC0gcDF4KSxcblx0XHRcdGJ4ID0gNiAqIChwMXggKyBjMngpIC0gMTIgKiBjMXgsXG5cdFx0XHRjeCA9IDMgKiAoYzF4IC0gcDF4KSxcblxuXHRcdFx0YXkgPSA5ICogKGMxeSAtIGMyeSkgKyAzICogKHAyeSAtIHAxeSksXG5cdFx0XHRieSA9IDYgKiAocDF5ICsgYzJ5KSAtIDEyICogYzF5LFxuXHRcdFx0Y3kgPSAzICogKGMxeSAtIHAxeSk7XG5cblx0XHRyZXR1cm4gZnVuY3Rpb24odCkge1xuXHRcdFx0dmFyIGR4ID0gKGF4ICogdCArIGJ4KSAqIHQgKyBjeCxcblx0XHRcdFx0ZHkgPSAoYXkgKiB0ICsgYnkpICogdCArIGN5O1xuXHRcdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0fTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldEl0ZXJhdGlvbnMoYSwgYikge1xuXHRcdHJldHVybiBNYXRoLm1heCgyLCBNYXRoLm1pbigxNiwgTWF0aC5jZWlsKE1hdGguYWJzKGIgLSBhKSAqIDMyKSkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXZhbHVhdGUodiwgdCwgdHlwZSwgbm9ybWFsaXplZCkge1xuXHRcdGlmICh0ID09IG51bGwgfHwgdCA8IDAgfHwgdCA+IDEpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcblx0XHRcdHRNaW4gPSA0ZS03LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluLFxuXHRcdFx0eCwgeTtcblxuXHRcdGlmICh0eXBlID09PSAwICYmICh0IDwgdE1pbiB8fCB0ID4gdE1heCkpIHtcblx0XHRcdHZhciBpc1plcm8gPSB0IDwgdE1pbjtcblx0XHRcdHggPSBpc1plcm8gPyBwMXggOiBwMng7XG5cdFx0XHR5ID0gaXNaZXJvID8gcDF5IDogcDJ5O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY3ggPSAzICogKGMxeCAtIHAxeCksXG5cdFx0XHRcdGJ4ID0gMyAqIChjMnggLSBjMXgpIC0gY3gsXG5cdFx0XHRcdGF4ID0gcDJ4IC0gcDF4IC0gY3ggLSBieCxcblxuXHRcdFx0XHRjeSA9IDMgKiAoYzF5IC0gcDF5KSxcblx0XHRcdFx0YnkgPSAzICogKGMyeSAtIGMxeSkgLSBjeSxcblx0XHRcdFx0YXkgPSBwMnkgLSBwMXkgLSBjeSAtIGJ5O1xuXHRcdFx0aWYgKHR5cGUgPT09IDApIHtcblx0XHRcdFx0eCA9ICgoYXggKiB0ICsgYngpICogdCArIGN4KSAqIHQgKyBwMXg7XG5cdFx0XHRcdHkgPSAoKGF5ICogdCArIGJ5KSAqIHQgKyBjeSkgKiB0ICsgcDF5O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHQgPCB0TWluKSB7XG5cdFx0XHRcdFx0eCA9IGN4O1xuXHRcdFx0XHRcdHkgPSBjeTtcblx0XHRcdFx0fSBlbHNlIGlmICh0ID4gdE1heCkge1xuXHRcdFx0XHRcdHggPSAzICogKHAyeCAtIGMyeCk7XG5cdFx0XHRcdFx0eSA9IDMgKiAocDJ5IC0gYzJ5KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4ID0gKDMgKiBheCAqIHQgKyAyICogYngpICogdCArIGN4O1xuXHRcdFx0XHRcdHkgPSAoMyAqIGF5ICogdCArIDIgKiBieSkgKiB0ICsgY3k7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKG5vcm1hbGl6ZWQpIHtcblx0XHRcdFx0XHRpZiAoeCA9PT0gMCAmJiB5ID09PSAwICYmICh0IDwgdE1pbiB8fCB0ID4gdE1heCkpIHtcblx0XHRcdFx0XHRcdHggPSBjMnggLSBjMXg7XG5cdFx0XHRcdFx0XHR5ID0gYzJ5IC0gYzF5O1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgbGVuID0gTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpO1xuXHRcdFx0XHRcdGlmIChsZW4pIHtcblx0XHRcdFx0XHRcdHggLz0gbGVuO1xuXHRcdFx0XHRcdFx0eSAvPSBsZW47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0eXBlID09PSAzKSB7XG5cdFx0XHRcdFx0dmFyIHgyID0gNiAqIGF4ICogdCArIDIgKiBieCxcblx0XHRcdFx0XHRcdHkyID0gNiAqIGF5ICogdCArIDIgKiBieSxcblx0XHRcdFx0XHRcdGQgPSBNYXRoLnBvdyh4ICogeCArIHkgKiB5LCAzIC8gMik7XG5cdFx0XHRcdFx0eCA9IGQgIT09IDAgPyAoeCAqIHkyIC0geSAqIHgyKSAvIGQgOiAwO1xuXHRcdFx0XHRcdHkgPSAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0eXBlID09PSAyID8gbmV3IFBvaW50KHksIC14KSA6IG5ldyBQb2ludCh4LCB5KTtcblx0fVxuXG5cdHJldHVybiB7IHN0YXRpY3M6IHtcblxuXHRcdGdldExlbmd0aDogZnVuY3Rpb24odiwgYSwgYikge1xuXHRcdFx0aWYgKGEgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0YSA9IDA7XG5cdFx0XHRpZiAoYiA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRiID0gMTtcblx0XHRcdGlmIChhID09PSAwICYmIGIgPT09IDEgJiYgQ3VydmUuaXNTdHJhaWdodCh2KSkge1xuXHRcdFx0XHR2YXIgZHggPSB2WzZdIC0gdlswXSxcblx0XHRcdFx0XHRkeSA9IHZbN10gLSB2WzFdO1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5zcXJ0KGR4ICogZHggKyBkeSAqIGR5KTtcblx0XHRcdH1cblx0XHRcdHZhciBkcyA9IGdldExlbmd0aEludGVncmFuZCh2KTtcblx0XHRcdHJldHVybiBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBhLCBiLCBnZXRJdGVyYXRpb25zKGEsIGIpKTtcblx0XHR9LFxuXG5cdFx0Z2V0UGFyYW1ldGVyQXQ6IGZ1bmN0aW9uKHYsIG9mZnNldCwgc3RhcnQpIHtcblx0XHRcdGlmIChzdGFydCA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRzdGFydCA9IG9mZnNldCA8IDAgPyAxIDogMFxuXHRcdFx0aWYgKG9mZnNldCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIHN0YXJ0O1xuXHRcdFx0dmFyIGFicyA9IE1hdGguYWJzLFxuXHRcdFx0XHRmb3J3YXJkID0gb2Zmc2V0ID4gMCxcblx0XHRcdFx0YSA9IGZvcndhcmQgPyBzdGFydCA6IDAsXG5cdFx0XHRcdGIgPSBmb3J3YXJkID8gMSA6IHN0YXJ0LFxuXHRcdFx0XHRkcyA9IGdldExlbmd0aEludGVncmFuZCh2KSxcblx0XHRcdFx0cmFuZ2VMZW5ndGggPSBOdW1lcmljYWwuaW50ZWdyYXRlKGRzLCBhLCBiLFxuXHRcdFx0XHRcdFx0Z2V0SXRlcmF0aW9ucyhhLCBiKSk7XG5cdFx0XHRpZiAoYWJzKG9mZnNldCAtIHJhbmdlTGVuZ3RoKSA8IDFlLTEyKSB7XG5cdFx0XHRcdHJldHVybiBmb3J3YXJkID8gYiA6IGE7XG5cdFx0XHR9IGVsc2UgaWYgKGFicyhvZmZzZXQpID4gcmFuZ2VMZW5ndGgpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZ3Vlc3MgPSBvZmZzZXQgLyByYW5nZUxlbmd0aCxcblx0XHRcdFx0bGVuZ3RoID0gMDtcblx0XHRcdGZ1bmN0aW9uIGYodCkge1xuXHRcdFx0XHRsZW5ndGggKz0gTnVtZXJpY2FsLmludGVncmF0ZShkcywgc3RhcnQsIHQsXG5cdFx0XHRcdFx0XHRnZXRJdGVyYXRpb25zKHN0YXJ0LCB0KSk7XG5cdFx0XHRcdHN0YXJ0ID0gdDtcblx0XHRcdFx0cmV0dXJuIGxlbmd0aCAtIG9mZnNldDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBOdW1lcmljYWwuZmluZFJvb3QoZiwgZHMsIHN0YXJ0ICsgZ3Vlc3MsIGEsIGIsIDMyLFxuXHRcdFx0XHRcdDFlLTEyKTtcblx0XHR9LFxuXG5cdFx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAwLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGdldFRhbmdlbnQ6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAxLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0Z2V0V2VpZ2h0ZWRUYW5nZW50OiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0XHRyZXR1cm4gZXZhbHVhdGUodiwgdCwgMSwgZmFsc2UpO1xuXHRcdH0sXG5cblx0XHRnZXROb3JtYWw6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAyLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0Z2V0V2VpZ2h0ZWROb3JtYWw6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAyLCBmYWxzZSk7XG5cdFx0fSxcblxuXHRcdGdldEN1cnZhdHVyZTogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDMsIGZhbHNlKS54O1xuXHRcdH1cblx0fX07XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGFkZExvY2F0aW9uKGxvY2F0aW9ucywgcGFyYW0sIHYxLCBjMSwgdDEsIHAxLCB2MiwgYzIsIHQyLCBwMixcblx0XHRcdG92ZXJsYXApIHtcblx0XHR2YXIgc3RhcnRDb25uZWN0ZWQgPSBwYXJhbS5zdGFydENvbm5lY3RlZCxcblx0XHRcdGVuZENvbm5lY3RlZCA9IHBhcmFtLmVuZENvbm5lY3RlZCxcblx0XHRcdHRNaW4gPSA0ZS03LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdGlmICh0MSA9PSBudWxsKVxuXHRcdFx0dDEgPSBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih2MSwgcDEpO1xuXHRcdGlmICh0MSAhPT0gbnVsbCAmJiB0MSA+PSAoc3RhcnRDb25uZWN0ZWQgPyB0TWluIDogMCkgJiZcblx0XHRcdHQxIDw9IChlbmRDb25uZWN0ZWQgPyB0TWF4IDogMSkpIHtcblx0XHRcdGlmICh0MiA9PSBudWxsKVxuXHRcdFx0XHR0MiA9IEN1cnZlLmdldFBhcmFtZXRlck9mKHYyLCBwMik7XG5cdFx0XHRpZiAodDIgIT09IG51bGwgJiYgdDIgPj0gKGVuZENvbm5lY3RlZCA/IHRNaW4gOiAwKSAmJlxuXHRcdFx0XHR0MiA8PSAoc3RhcnRDb25uZWN0ZWQgPyB0TWF4IDogMSkpIHtcblx0XHRcdFx0dmFyIHJlbm9ybWFsaXplID0gcGFyYW0ucmVub3JtYWxpemU7XG5cdFx0XHRcdGlmIChyZW5vcm1hbGl6ZSkge1xuXHRcdFx0XHRcdHZhciByZXMgPSByZW5vcm1hbGl6ZSh0MSwgdDIpO1xuXHRcdFx0XHRcdHQxID0gcmVzWzBdO1xuXHRcdFx0XHRcdHQyID0gcmVzWzFdO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBsb2MxID0gbmV3IEN1cnZlTG9jYXRpb24oYzEsIHQxLFxuXHRcdFx0XHRcdFx0cDEgfHwgQ3VydmUuZ2V0UG9pbnQodjEsIHQxKSwgb3ZlcmxhcCksXG5cdFx0XHRcdFx0bG9jMiA9IG5ldyBDdXJ2ZUxvY2F0aW9uKGMyLCB0Mixcblx0XHRcdFx0XHRcdHAyIHx8IEN1cnZlLmdldFBvaW50KHYyLCB0MiksIG92ZXJsYXApLFxuXHRcdFx0XHRcdGZsaXAgPSBsb2MxLmdldFBhdGgoKSA9PT0gbG9jMi5nZXRQYXRoKClcblx0XHRcdFx0XHRcdCYmIGxvYzEuZ2V0SW5kZXgoKSA+IGxvYzIuZ2V0SW5kZXgoKSxcblx0XHRcdFx0XHRsb2MgPSBmbGlwID8gbG9jMiA6IGxvYzEsXG5cdFx0XHRcdFx0aW5jbHVkZSA9IHBhcmFtLmluY2x1ZGU7XG5cdFx0XHRcdGxvYzEuX2ludGVyc2VjdGlvbiA9IGxvYzI7XG5cdFx0XHRcdGxvYzIuX2ludGVyc2VjdGlvbiA9IGxvYzE7XG5cdFx0XHRcdGlmICghaW5jbHVkZSB8fCBpbmNsdWRlKGxvYykpIHtcblx0XHRcdFx0XHRDdXJ2ZUxvY2F0aW9uLmluc2VydChsb2NhdGlvbnMsIGxvYywgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDdXJ2ZUludGVyc2VjdGlvbnModjEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgcGFyYW0sXG5cdFx0XHR0TWluLCB0TWF4LCB1TWluLCB1TWF4LCBvbGRURGlmZiwgcmV2ZXJzZSwgcmVjdXJzaW9uKSB7XG5cdFx0aWYgKCsrcmVjdXJzaW9uID49IDI0KVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBxMHggPSB2MlswXSwgcTB5ID0gdjJbMV0sIHEzeCA9IHYyWzZdLCBxM3kgPSB2Mls3XSxcblx0XHRcdGdldFNpZ25lZERpc3RhbmNlID0gTGluZS5nZXRTaWduZWREaXN0YW5jZSxcblx0XHRcdGQxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MlsyXSwgdjJbM10pLFxuXHRcdFx0ZDIgPSBnZXRTaWduZWREaXN0YW5jZShxMHgsIHEweSwgcTN4LCBxM3ksIHYyWzRdLCB2Mls1XSksXG5cdFx0XHRmYWN0b3IgPSBkMSAqIGQyID4gMCA/IDMgLyA0IDogNCAvIDksXG5cdFx0XHRkTWluID0gZmFjdG9yICogTWF0aC5taW4oMCwgZDEsIGQyKSxcblx0XHRcdGRNYXggPSBmYWN0b3IgKiBNYXRoLm1heCgwLCBkMSwgZDIpLFxuXHRcdFx0ZHAwID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVswXSwgdjFbMV0pLFxuXHRcdFx0ZHAxID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVsyXSwgdjFbM10pLFxuXHRcdFx0ZHAyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs0XSwgdjFbNV0pLFxuXHRcdFx0ZHAzID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2MVs2XSwgdjFbN10pLFxuXHRcdFx0aHVsbCA9IGdldENvbnZleEh1bGwoZHAwLCBkcDEsIGRwMiwgZHAzKSxcblx0XHRcdHRvcCA9IGh1bGxbMF0sXG5cdFx0XHRib3R0b20gPSBodWxsWzFdLFxuXHRcdFx0dE1pbkNsaXAsXG5cdFx0XHR0TWF4Q2xpcDtcblx0XHRpZiAoKHRNaW5DbGlwID0gY2xpcENvbnZleEh1bGwodG9wLCBib3R0b20sIGRNaW4sIGRNYXgpKSA9PSBudWxsIHx8XG5cdFx0XHQodE1heENsaXAgPSBjbGlwQ29udmV4SHVsbCh0b3AucmV2ZXJzZSgpLCBib3R0b20ucmV2ZXJzZSgpLFxuXHRcdFx0XHRkTWluLCBkTWF4KSkgPT0gbnVsbClcblx0XHRcdHJldHVybjtcblx0XHR2MSA9IEN1cnZlLmdldFBhcnQodjEsIHRNaW5DbGlwLCB0TWF4Q2xpcCk7XG5cdFx0dmFyIHREaWZmID0gdE1heENsaXAgLSB0TWluQ2xpcCxcblx0XHRcdHRNaW5OZXcgPSB0TWluICsgKHRNYXggLSB0TWluKSAqIHRNaW5DbGlwLFxuXHRcdFx0dE1heE5ldyA9IHRNaW4gKyAodE1heCAtIHRNaW4pICogdE1heENsaXA7XG5cdFx0aWYgKG9sZFREaWZmID4gMC41ICYmIHREaWZmID4gMC41KSB7XG5cdFx0XHRpZiAodE1heE5ldyAtIHRNaW5OZXcgPiB1TWF4IC0gdU1pbikge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodjEsIDAuNSksXG5cdFx0XHRcdFx0dCA9IHRNaW5OZXcgKyAodE1heE5ldyAtIHRNaW5OZXcpIC8gMjtcblx0XHRcdFx0YWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdHYyLCBwYXJ0c1swXSwgYzIsIGMxLCBsb2NhdGlvbnMsIHBhcmFtLFxuXHRcdFx0XHRcdHVNaW4sIHVNYXgsIHRNaW5OZXcsIHQsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcblx0XHRcdFx0YWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdHYyLCBwYXJ0c1sxXSwgYzIsIGMxLCBsb2NhdGlvbnMsIHBhcmFtLFxuXHRcdFx0XHRcdHVNaW4sIHVNYXgsIHQsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MiwgMC41KSxcblx0XHRcdFx0XHR0ID0gdU1pbiArICh1TWF4IC0gdU1pbikgLyAyO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0cGFydHNbMF0sIHYxLCBjMiwgYzEsIGxvY2F0aW9ucywgcGFyYW0sXG5cdFx0XHRcdFx0dU1pbiwgdCwgdE1pbk5ldywgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCByZWN1cnNpb24pO1xuXHRcdFx0XHRhZGRDdXJ2ZUludGVyc2VjdGlvbnMoXG5cdFx0XHRcdFx0cGFydHNbMV0sIHYxLCBjMiwgYzEsIGxvY2F0aW9ucywgcGFyYW0sXG5cdFx0XHRcdFx0dCwgdU1heCwgdE1pbk5ldywgdE1heE5ldywgdERpZmYsICFyZXZlcnNlLCByZWN1cnNpb24pO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoTWF0aC5tYXgodU1heCAtIHVNaW4sIHRNYXhOZXcgLSB0TWluTmV3KVxuXHRcdFx0XHQ8IDFlLTcpIHtcblx0XHRcdHZhciB0MSA9IHRNaW5OZXcgKyAodE1heE5ldyAtIHRNaW5OZXcpIC8gMixcblx0XHRcdFx0dDIgPSB1TWluICsgKHVNYXggLSB1TWluKSAvIDI7XG5cdFx0XHR2MSA9IGMxLmdldFZhbHVlcygpO1xuXHRcdFx0djIgPSBjMi5nZXRWYWx1ZXMoKTtcblx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgcGFyYW0sXG5cdFx0XHRcdHJldmVyc2UgPyB2MiA6IHYxLCByZXZlcnNlID8gYzIgOiBjMSwgcmV2ZXJzZSA/IHQyIDogdDEsIG51bGwsXG5cdFx0XHRcdHJldmVyc2UgPyB2MSA6IHYyLCByZXZlcnNlID8gYzEgOiBjMiwgcmV2ZXJzZSA/IHQxIDogdDIsIG51bGwpO1xuXHRcdH0gZWxzZSBpZiAodERpZmYgPiAxZS0xMikge1xuXHRcdFx0YWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYyLCB2MSwgYzIsIGMxLCBsb2NhdGlvbnMsIHBhcmFtLFxuXHRcdFx0XHRcdHVNaW4sIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRDb252ZXhIdWxsKGRxMCwgZHExLCBkcTIsIGRxMykge1xuXHRcdHZhciBwMCA9IFsgMCwgZHEwIF0sXG5cdFx0XHRwMSA9IFsgMSAvIDMsIGRxMSBdLFxuXHRcdFx0cDIgPSBbIDIgLyAzLCBkcTIgXSxcblx0XHRcdHAzID0gWyAxLCBkcTMgXSxcblx0XHRcdGRpc3QxID0gZHExIC0gKDIgKiBkcTAgKyBkcTMpIC8gMyxcblx0XHRcdGRpc3QyID0gZHEyIC0gKGRxMCArIDIgKiBkcTMpIC8gMyxcblx0XHRcdGh1bGw7XG5cdFx0aWYgKGRpc3QxICogZGlzdDIgPCAwKSB7XG5cdFx0XHRodWxsID0gW1twMCwgcDEsIHAzXSwgW3AwLCBwMiwgcDNdXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGRpc3RSYXRpbyA9IGRpc3QxIC8gZGlzdDI7XG5cdFx0XHRodWxsID0gW1xuXHRcdFx0XHRkaXN0UmF0aW8gPj0gMiA/IFtwMCwgcDEsIHAzXVxuXHRcdFx0XHQ6IGRpc3RSYXRpbyA8PSAuNSA/IFtwMCwgcDIsIHAzXVxuXHRcdFx0XHQ6IFtwMCwgcDEsIHAyLCBwM10sXG5cdFx0XHRcdFtwMCwgcDNdXG5cdFx0XHRdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGRpc3QxIHx8IGRpc3QyKSA8IDAgPyBodWxsLnJldmVyc2UoKSA6IGh1bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBjbGlwQ29udmV4SHVsbChodWxsVG9wLCBodWxsQm90dG9tLCBkTWluLCBkTWF4KSB7XG5cdFx0aWYgKGh1bGxUb3BbMF1bMV0gPCBkTWluKSB7XG5cdFx0XHRyZXR1cm4gY2xpcENvbnZleEh1bGxQYXJ0KGh1bGxUb3AsIHRydWUsIGRNaW4pO1xuXHRcdH0gZWxzZSBpZiAoaHVsbEJvdHRvbVswXVsxXSA+IGRNYXgpIHtcblx0XHRcdHJldHVybiBjbGlwQ29udmV4SHVsbFBhcnQoaHVsbEJvdHRvbSwgZmFsc2UsIGRNYXgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gaHVsbFRvcFswXVswXTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBjbGlwQ29udmV4SHVsbFBhcnQocGFydCwgdG9wLCB0aHJlc2hvbGQpIHtcblx0XHR2YXIgcHggPSBwYXJ0WzBdWzBdLFxuXHRcdFx0cHkgPSBwYXJ0WzBdWzFdO1xuXHRcdGZvciAodmFyIGkgPSAxLCBsID0gcGFydC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBxeCA9IHBhcnRbaV1bMF0sXG5cdFx0XHRcdHF5ID0gcGFydFtpXVsxXTtcblx0XHRcdGlmICh0b3AgPyBxeSA+PSB0aHJlc2hvbGQgOiBxeSA8PSB0aHJlc2hvbGQpIHtcblx0XHRcdFx0cmV0dXJuIHF5ID09PSB0aHJlc2hvbGQgPyBxeFxuXHRcdFx0XHRcdFx0OiBweCArICh0aHJlc2hvbGQgLSBweSkgKiAocXggLSBweCkgLyAocXkgLSBweSk7XG5cdFx0XHR9XG5cdFx0XHRweCA9IHF4O1xuXHRcdFx0cHkgPSBxeTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIHBhcmFtKSB7XG5cdFx0dmFyIGZsaXAgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYxKSxcblx0XHRcdHZjID0gZmxpcCA/IHYyIDogdjEsXG5cdFx0XHR2bCA9IGZsaXAgPyB2MSA6IHYyLFxuXHRcdFx0bHgxID0gdmxbMF0sIGx5MSA9IHZsWzFdLFxuXHRcdFx0bHgyID0gdmxbNl0sIGx5MiA9IHZsWzddLFxuXHRcdFx0bGR4ID0gbHgyIC0gbHgxLFxuXHRcdFx0bGR5ID0gbHkyIC0gbHkxLFxuXHRcdFx0YW5nbGUgPSBNYXRoLmF0YW4yKC1sZHksIGxkeCksXG5cdFx0XHRzaW4gPSBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHRjb3MgPSBNYXRoLmNvcyhhbmdsZSksXG5cdFx0XHRydmMgPSBbXTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgODsgaSArPSAyKSB7XG5cdFx0XHR2YXIgeCA9IHZjW2ldIC0gbHgxLFxuXHRcdFx0XHR5ID0gdmNbaSArIDFdIC0gbHkxO1xuXHRcdFx0cnZjLnB1c2goXG5cdFx0XHRcdHggKiBjb3MgLSB5ICogc2luLFxuXHRcdFx0XHR4ICogc2luICsgeSAqIGNvcyk7XG5cdFx0fVxuXHRcdHZhciByb290cyA9IFtdLFxuXHRcdFx0Y291bnQgPSBDdXJ2ZS5zb2x2ZUN1YmljKHJ2YywgMSwgMCwgcm9vdHMsIDAsIDEpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0dmFyIHRjID0gcm9vdHNbaV0sXG5cdFx0XHRcdHBjID0gQ3VydmUuZ2V0UG9pbnQodmMsIHRjKSxcblx0XHRcdFx0dGwgPSBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih2bCwgcGMpO1xuXHRcdFx0aWYgKHRsICE9PSBudWxsKSB7XG5cdFx0XHRcdHZhciBwbCA9IEN1cnZlLmdldFBvaW50KHZsLCB0bCksXG5cdFx0XHRcdFx0dDEgPSBmbGlwID8gdGwgOiB0Yyxcblx0XHRcdFx0XHR0MiA9IGZsaXAgPyB0YyA6IHRsO1xuXHRcdFx0XHRpZiAoIXBhcmFtLmVuZENvbm5lY3RlZCB8fCB0MiA+IE51bWVyaWNhbC5DVVJWRVRJTUVfRVBTSUxPTikge1xuXHRcdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgcGFyYW0sXG5cdFx0XHRcdFx0XHRcdHYxLCBjMSwgdDEsIGZsaXAgPyBwbCA6IHBjLFxuXHRcdFx0XHRcdFx0XHR2MiwgYzIsIHQyLCBmbGlwID8gcGMgOiBwbCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBhZGRMaW5lSW50ZXJzZWN0aW9uKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIHBhcmFtKSB7XG5cdFx0dmFyIHB0ID0gTGluZS5pbnRlcnNlY3QoXG5cdFx0XHRcdHYxWzBdLCB2MVsxXSwgdjFbNl0sIHYxWzddLFxuXHRcdFx0XHR2MlswXSwgdjJbMV0sIHYyWzZdLCB2Mls3XSk7XG5cdFx0aWYgKHB0KSB7XG5cdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIHBhcmFtLCB2MSwgYzEsIG51bGwsIHB0LCB2MiwgYzIsIG51bGwsIHB0KTtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0aWNzOiB7XG5cdFx0X2dldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIHBhcmFtKSB7XG5cdFx0XHRpZiAoIXYyKSB7XG5cdFx0XHRcdHJldHVybiBDdXJ2ZS5fZ2V0U2VsZkludGVyc2VjdGlvbih2MSwgYzEsIGxvY2F0aW9ucywgcGFyYW0pO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGMxcDF4ID0gdjFbMF0sIGMxcDF5ID0gdjFbMV0sXG5cdFx0XHRcdGMxcDJ4ID0gdjFbNl0sIGMxcDJ5ID0gdjFbN10sXG5cdFx0XHRcdGMycDF4ID0gdjJbMF0sIGMycDF5ID0gdjJbMV0sXG5cdFx0XHRcdGMycDJ4ID0gdjJbNl0sIGMycDJ5ID0gdjJbN10sXG5cdFx0XHRcdGMxczF4ID0gKDMgKiB2MVsyXSArIGMxcDF4KSAvIDQsXG5cdFx0XHRcdGMxczF5ID0gKDMgKiB2MVszXSArIGMxcDF5KSAvIDQsXG5cdFx0XHRcdGMxczJ4ID0gKDMgKiB2MVs0XSArIGMxcDJ4KSAvIDQsXG5cdFx0XHRcdGMxczJ5ID0gKDMgKiB2MVs1XSArIGMxcDJ5KSAvIDQsXG5cdFx0XHRcdGMyczF4ID0gKDMgKiB2MlsyXSArIGMycDF4KSAvIDQsXG5cdFx0XHRcdGMyczF5ID0gKDMgKiB2MlszXSArIGMycDF5KSAvIDQsXG5cdFx0XHRcdGMyczJ4ID0gKDMgKiB2Mls0XSArIGMycDJ4KSAvIDQsXG5cdFx0XHRcdGMyczJ5ID0gKDMgKiB2Mls1XSArIGMycDJ5KSAvIDQsXG5cdFx0XHRcdG1pbiA9IE1hdGgubWluLFxuXHRcdFx0XHRtYXggPSBNYXRoLm1heDtcblx0XHRcdGlmICghKFx0bWF4KGMxcDF4LCBjMXMxeCwgYzFzMngsIGMxcDJ4KSA+PVxuXHRcdFx0XHRcdG1pbihjMnAxeCwgYzJzMXgsIGMyczJ4LCBjMnAyeCkgJiZcblx0XHRcdFx0XHRtaW4oYzFwMXgsIGMxczF4LCBjMXMyeCwgYzFwMngpIDw9XG5cdFx0XHRcdFx0bWF4KGMycDF4LCBjMnMxeCwgYzJzMngsIGMycDJ4KSAmJlxuXHRcdFx0XHRcdG1heChjMXAxeSwgYzFzMXksIGMxczJ5LCBjMXAyeSkgPj1cblx0XHRcdFx0XHRtaW4oYzJwMXksIGMyczF5LCBjMnMyeSwgYzJwMnkpICYmXG5cdFx0XHRcdFx0bWluKGMxcDF5LCBjMXMxeSwgYzFzMnksIGMxcDJ5KSA8PVxuXHRcdFx0XHRcdG1heChjMnAxeSwgYzJzMXksIGMyczJ5LCBjMnAyeSkpKVxuXHRcdFx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHRcdFx0aWYgKCFwYXJhbS5zdGFydENvbm5lY3RlZCAmJiAhcGFyYW0uZW5kQ29ubmVjdGVkKSB7XG5cdFx0XHRcdHZhciBvdmVybGFwcyA9IEN1cnZlLmdldE92ZXJsYXBzKHYxLCB2Mik7XG5cdFx0XHRcdGlmIChvdmVybGFwcykge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG5cdFx0XHRcdFx0XHR2YXIgb3ZlcmxhcCA9IG92ZXJsYXBzW2ldO1xuXHRcdFx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBwYXJhbSxcblx0XHRcdFx0XHRcdFx0djEsIGMxLCBvdmVybGFwWzBdLCBudWxsLFxuXHRcdFx0XHRcdFx0XHR2MiwgYzIsIG92ZXJsYXBbMV0sIG51bGwsIHRydWUpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdHZhciBzdHJhaWdodDEgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYxKSxcblx0XHRcdFx0c3RyYWlnaHQyID0gQ3VydmUuaXNTdHJhaWdodCh2MiksXG5cdFx0XHRcdHN0cmFpZ2h0ID0gc3RyYWlnaHQxICYmIHN0cmFpZ2h0Mixcblx0XHRcdFx0ZXBzaWxvbiA9IDFlLTEyLFxuXHRcdFx0XHRiZWZvcmUgPSBsb2NhdGlvbnMubGVuZ3RoO1xuXHRcdFx0KHN0cmFpZ2h0XG5cdFx0XHRcdD8gYWRkTGluZUludGVyc2VjdGlvblxuXHRcdFx0XHQ6IHN0cmFpZ2h0MSB8fCBzdHJhaWdodDJcblx0XHRcdFx0XHQ/IGFkZEN1cnZlTGluZUludGVyc2VjdGlvbnNcblx0XHRcdFx0XHQ6IGFkZEN1cnZlSW50ZXJzZWN0aW9ucykoXG5cdFx0XHRcdFx0XHR2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBwYXJhbSxcblx0XHRcdFx0XHRcdDAsIDEsIDAsIDEsIDAsIGZhbHNlLCAwKTtcblx0XHRcdGlmIChzdHJhaWdodCAmJiBsb2NhdGlvbnMubGVuZ3RoID4gYmVmb3JlKVxuXHRcdFx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHRcdFx0dmFyIGMxcDEgPSBuZXcgUG9pbnQoYzFwMXgsIGMxcDF5KSxcblx0XHRcdFx0YzFwMiA9IG5ldyBQb2ludChjMXAyeCwgYzFwMnkpLFxuXHRcdFx0XHRjMnAxID0gbmV3IFBvaW50KGMycDF4LCBjMnAxeSksXG5cdFx0XHRcdGMycDIgPSBuZXcgUG9pbnQoYzJwMngsIGMycDJ5KTtcblx0XHRcdGlmIChjMXAxLmlzQ2xvc2UoYzJwMSwgZXBzaWxvbikpXG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgcGFyYW0sIHYxLCBjMSwgMCwgYzFwMSwgdjIsIGMyLCAwLCBjMnAxKTtcblx0XHRcdGlmICghcGFyYW0uc3RhcnRDb25uZWN0ZWQgJiYgYzFwMS5pc0Nsb3NlKGMycDIsIGVwc2lsb24pKVxuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIHBhcmFtLCB2MSwgYzEsIDAsIGMxcDEsIHYyLCBjMiwgMSwgYzJwMik7XG5cdFx0XHRpZiAoIXBhcmFtLmVuZENvbm5lY3RlZCAmJiBjMXAyLmlzQ2xvc2UoYzJwMSwgZXBzaWxvbikpXG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgcGFyYW0sIHYxLCBjMSwgMSwgYzFwMiwgdjIsIGMyLCAwLCBjMnAxKTtcblx0XHRcdGlmIChjMXAyLmlzQ2xvc2UoYzJwMiwgZXBzaWxvbikpXG5cdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgcGFyYW0sIHYxLCBjMSwgMSwgYzFwMiwgdjIsIGMyLCAxLCBjMnAyKTtcblx0XHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdFx0fSxcblxuXHRcdF9nZXRTZWxmSW50ZXJzZWN0aW9uOiBmdW5jdGlvbih2MSwgYzEsIGxvY2F0aW9ucywgcGFyYW0pIHtcblx0XHRcdHZhciBwMXggPSB2MVswXSwgcDF5ID0gdjFbMV0sXG5cdFx0XHRcdGgxeCA9IHYxWzJdLCBoMXkgPSB2MVszXSxcblx0XHRcdFx0aDJ4ID0gdjFbNF0sIGgyeSA9IHYxWzVdLFxuXHRcdFx0XHRwMnggPSB2MVs2XSwgcDJ5ID0gdjFbN107XG5cdFx0XHR2YXIgbGluZSA9IG5ldyBMaW5lKHAxeCwgcDF5LCBwMngsIHAyeSwgZmFsc2UpLFxuXHRcdFx0XHRzaWRlMSA9IGxpbmUuZ2V0U2lkZShuZXcgUG9pbnQoaDF4LCBoMXkpLCB0cnVlKSxcblx0XHRcdFx0c2lkZTIgPSBsaW5lLmdldFNpZGUobmV3IFBvaW50KGgyeCwgaDJ5KSwgdHJ1ZSk7XG5cdFx0XHRpZiAoc2lkZTEgPT09IHNpZGUyKSB7XG5cdFx0XHRcdHZhciBlZGdlU3VtID0gKHAxeCAtIGgyeCkgKiAoaDF5IC0gcDJ5KVxuXHRcdFx0XHRcdFx0XHQrIChoMXggLSBwMngpICogKGgyeSAtIHAxeSk7XG5cdFx0XHRcdGlmIChlZGdlU3VtICogc2lkZTEgPiAwKVxuXHRcdFx0XHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdFx0XHR9XG5cdFx0XHR2YXIgYXggPSBwMnggLSAzICogaDJ4ICsgMyAqIGgxeCAtIHAxeCxcblx0XHRcdFx0YnggPSBoMnggLSAyICogaDF4ICsgcDF4LFxuXHRcdFx0XHRjeCA9IGgxeCAtIHAxeCxcblx0XHRcdFx0YXkgPSBwMnkgLSAzICogaDJ5ICsgMyAqIGgxeSAtIHAxeSxcblx0XHRcdFx0YnkgPSBoMnkgLSAyICogaDF5ICsgcDF5LFxuXHRcdFx0XHRjeSA9IGgxeSAtIHAxeSxcblx0XHRcdFx0YWMgPSBheSAqIGN4IC0gYXggKiBjeSxcblx0XHRcdFx0YWIgPSBheSAqIGJ4IC0gYXggKiBieSxcblx0XHRcdFx0YmMgPSBieSAqIGN4IC0gYnggKiBjeTtcblx0XHRcdGlmIChhYyAqIGFjIC0gNCAqIGFiICogYmMgPCAwKSB7XG5cdFx0XHRcdHZhciByb290cyA9IFtdLFxuXHRcdFx0XHRcdHRTcGxpdCxcblx0XHRcdFx0XHRjb3VudCA9IE51bWVyaWNhbC5zb2x2ZUN1YmljKFxuXHRcdFx0XHRcdFx0XHRheCAqIGF4XHQgKyBheSAqIGF5LFxuXHRcdFx0XHRcdFx0XHQzICogKGF4ICogYnggKyBheSAqIGJ5KSxcblx0XHRcdFx0XHRcdFx0MiAqIChieCAqIGJ4ICsgYnkgKiBieSkgKyBheCAqIGN4ICsgYXkgKiBjeSxcblx0XHRcdFx0XHRcdFx0YnggKiBjeCArIGJ5ICogY3ksXG5cdFx0XHRcdFx0XHRcdHJvb3RzLCAwLCAxKTtcblx0XHRcdFx0aWYgKGNvdW50ID4gMCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBtYXhDdXJ2YXR1cmUgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIGN1cnZhdHVyZSA9IE1hdGguYWJzKFxuXHRcdFx0XHRcdFx0XHRcdGMxLmdldEN1cnZhdHVyZUF0KHJvb3RzW2ldLCB0cnVlKSk7XG5cdFx0XHRcdFx0XHRpZiAoY3VydmF0dXJlID4gbWF4Q3VydmF0dXJlKSB7XG5cdFx0XHRcdFx0XHRcdG1heEN1cnZhdHVyZSA9IGN1cnZhdHVyZTtcblx0XHRcdFx0XHRcdFx0dFNwbGl0ID0gcm9vdHNbaV07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHZhciBwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2MSwgdFNwbGl0KTtcblx0XHRcdFx0XHRwYXJhbS5lbmRDb25uZWN0ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdHBhcmFtLnJlbm9ybWFsaXplID0gZnVuY3Rpb24odDEsIHQyKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gW3QxICogdFNwbGl0LCB0MiAqICgxIC0gdFNwbGl0KSArIHRTcGxpdF07XG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRDdXJ2ZS5fZ2V0SW50ZXJzZWN0aW9ucyhwYXJ0c1swXSwgcGFydHNbMV0sIGMxLCBjMSxcblx0XHRcdFx0XHRcdFx0bG9jYXRpb25zLCBwYXJhbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdFx0fSxcblxuXHRcdGdldE92ZXJsYXBzOiBmdW5jdGlvbih2MSwgdjIpIHtcblx0XHRcdHZhciBhYnMgPSBNYXRoLmFicyxcblx0XHRcdFx0dGltZUVwc2lsb24gPSA0ZS03LFxuXHRcdFx0XHRnZW9tRXBzaWxvbiA9IDJlLTcsXG5cdFx0XHRcdHN0cmFpZ2h0MSA9IEN1cnZlLmlzU3RyYWlnaHQodjEpLFxuXHRcdFx0XHRzdHJhaWdodDIgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYyKSxcblx0XHRcdFx0c3RyYWlnaHQgPVx0c3RyYWlnaHQxICYmIHN0cmFpZ2h0MjtcblxuXHRcdFx0ZnVuY3Rpb24gZ2V0TGluZUxlbmd0aFNxdWFyZWQodikge1xuXHRcdFx0XHR2YXIgeCA9IHZbNl0gLSB2WzBdLFxuXHRcdFx0XHRcdHkgPSB2WzddIC0gdlsxXTtcblx0XHRcdFx0cmV0dXJuIHggKiB4ICsgeSAqIHk7XG5cdFx0XHR9XG5cblx0XHRcdGlmIChzdHJhaWdodCkge1xuXHRcdFx0XHR2YXIgZmxpcCA9IGdldExpbmVMZW5ndGhTcXVhcmVkKHYxKSA8IGdldExpbmVMZW5ndGhTcXVhcmVkKHYyKSxcblx0XHRcdFx0XHRsMSA9IGZsaXAgPyB2MiA6IHYxLFxuXHRcdFx0XHRcdGwyID0gZmxpcCA/IHYxIDogdjIsXG5cdFx0XHRcdFx0bGluZSA9IG5ldyBMaW5lKGwxWzBdLCBsMVsxXSwgbDFbNl0sIGwxWzddKTtcblx0XHRcdFx0aWYgKGxpbmUuZ2V0RGlzdGFuY2UobmV3IFBvaW50KGwyWzBdLCBsMlsxXSkpID4gZ2VvbUVwc2lsb24gfHxcblx0XHRcdFx0XHRsaW5lLmdldERpc3RhbmNlKG5ldyBQb2ludChsMls2XSwgbDJbN10pKSA+IGdlb21FcHNpbG9uKVxuXHRcdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fSBlbHNlIGlmIChzdHJhaWdodDEgXiBzdHJhaWdodDIpIHtcblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cblx0XHRcdHZhciB2ID0gW3YxLCB2Ml0sXG5cdFx0XHRcdHBhaXJzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgdDEgPSAwO1xuXHRcdFx0XHRcdGkgPCAyICYmIHBhaXJzLmxlbmd0aCA8IDI7XG5cdFx0XHRcdFx0aSArPSB0MSA9PT0gMCA/IDAgOiAxLCB0MSA9IHQxIF4gMSkge1xuXHRcdFx0XHR2YXIgdDIgPSBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih2W2kgXiAxXSwgbmV3IFBvaW50KFxuXHRcdFx0XHRcdFx0dltpXVt0MSA9PT0gMCA/IDAgOiA2XSxcblx0XHRcdFx0XHRcdHZbaV1bdDEgPT09IDAgPyAxIDogN10pKTtcblx0XHRcdFx0aWYgKHQyICE9IG51bGwpIHtcblx0XHRcdFx0XHR2YXIgcGFpciA9IGkgPT09IDAgPyBbdDEsIHQyXSA6IFt0MiwgdDFdO1xuXHRcdFx0XHRcdGlmIChwYWlycy5sZW5ndGggPT09IDAgfHxcblx0XHRcdFx0XHRcdGFicyhwYWlyWzBdIC0gcGFpcnNbMF1bMF0pID4gdGltZUVwc2lsb24gJiZcblx0XHRcdFx0XHRcdGFicyhwYWlyWzFdIC0gcGFpcnNbMF1bMV0pID4gdGltZUVwc2lsb24pXG5cdFx0XHRcdFx0XHRwYWlycy5wdXNoKHBhaXIpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpID09PSAxICYmIHBhaXJzLmxlbmd0aCA9PT0gMClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmIChwYWlycy5sZW5ndGggIT09IDIpIHtcblx0XHRcdFx0cGFpcnMgPSBudWxsO1xuXHRcdFx0fSBlbHNlIGlmICghc3RyYWlnaHQpIHtcblx0XHRcdFx0dmFyIG8xID0gQ3VydmUuZ2V0UGFydCh2MSwgcGFpcnNbMF1bMF0sIHBhaXJzWzFdWzBdKSxcblx0XHRcdFx0XHRvMiA9IEN1cnZlLmdldFBhcnQodjIsIHBhaXJzWzBdWzFdLCBwYWlyc1sxXVsxXSk7XG5cdFx0XHRcdGlmIChhYnMobzJbMl0gLSBvMVsyXSkgPiBnZW9tRXBzaWxvbiB8fFxuXHRcdFx0XHRcdGFicyhvMlszXSAtIG8xWzNdKSA+IGdlb21FcHNpbG9uIHx8XG5cdFx0XHRcdFx0YWJzKG8yWzRdIC0gbzFbNF0pID4gZ2VvbUVwc2lsb24gfHxcblx0XHRcdFx0XHRhYnMobzJbNV0gLSBvMVs1XSkgPiBnZW9tRXBzaWxvbilcblx0XHRcdFx0XHRwYWlycyA9IG51bGw7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcGFpcnM7XG5cdFx0fVxuXHR9fTtcbn0pO1xuXG52YXIgQ3VydmVMb2NhdGlvbiA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnQ3VydmVMb2NhdGlvbicsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEN1cnZlTG9jYXRpb24oY3VydmUsIHBhcmFtZXRlciwgcG9pbnQsXG5cdFx0XHRfb3ZlcmxhcCwgX2Rpc3RhbmNlKSB7XG5cdFx0aWYgKHBhcmFtZXRlciA+IDAuOTk5OTk5Nikge1xuXHRcdFx0dmFyIG5leHQgPSBjdXJ2ZS5nZXROZXh0KCk7XG5cdFx0XHRpZiAobmV4dCkge1xuXHRcdFx0XHRwYXJhbWV0ZXIgPSAwO1xuXHRcdFx0XHRjdXJ2ZSA9IG5leHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHRoaXMuX2lkID0gVUlELmdldChDdXJ2ZUxvY2F0aW9uKTtcblx0XHR0aGlzLl9zZXRDdXJ2ZShjdXJ2ZSk7XG5cdFx0dGhpcy5fcGFyYW1ldGVyID0gcGFyYW1ldGVyO1xuXHRcdHRoaXMuX3BvaW50ID0gcG9pbnQgfHwgY3VydmUuZ2V0UG9pbnRBdChwYXJhbWV0ZXIsIHRydWUpO1xuXHRcdHRoaXMuX292ZXJsYXAgPSBfb3ZlcmxhcDtcblx0XHR0aGlzLl9kaXN0YW5jZSA9IF9kaXN0YW5jZTtcblx0XHR0aGlzLl9pbnRlcnNlY3Rpb24gPSB0aGlzLl9uZXh0ID0gdGhpcy5fcHJldiA9IG51bGw7XG5cdH0sXG5cblx0X3NldEN1cnZlOiBmdW5jdGlvbihjdXJ2ZSkge1xuXHRcdHZhciBwYXRoID0gY3VydmUuX3BhdGg7XG5cdFx0dGhpcy5fdmVyc2lvbiA9IHBhdGggPyBwYXRoLl92ZXJzaW9uIDogMDtcblx0XHR0aGlzLl9jdXJ2ZSA9IGN1cnZlO1xuXHRcdHRoaXMuX3NlZ21lbnQgPSBudWxsO1xuXHRcdHRoaXMuX3NlZ21lbnQxID0gY3VydmUuX3NlZ21lbnQxO1xuXHRcdHRoaXMuX3NlZ21lbnQyID0gY3VydmUuX3NlZ21lbnQyO1xuXHR9LFxuXG5cdF9zZXRTZWdtZW50OiBmdW5jdGlvbihzZWdtZW50KSB7XG5cdFx0dGhpcy5fc2V0Q3VydmUoc2VnbWVudC5nZXRDdXJ2ZSgpKTtcblx0XHR0aGlzLl9zZWdtZW50ID0gc2VnbWVudDtcblx0XHR0aGlzLl9wYXJhbWV0ZXIgPSBzZWdtZW50ID09PSB0aGlzLl9zZWdtZW50MSA/IDAgOiAxO1xuXHRcdHRoaXMuX3BvaW50ID0gc2VnbWVudC5fcG9pbnQuY2xvbmUoKTtcblx0fSxcblxuXHRnZXRTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRzZWdtZW50ID0gdGhpcy5fc2VnbWVudDtcblx0XHRpZiAoIXNlZ21lbnQpIHtcblx0XHRcdHZhciBwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpO1xuXHRcdFx0aWYgKHBhcmFtZXRlciA9PT0gMCkge1xuXHRcdFx0XHRzZWdtZW50ID0gY3VydmUuX3NlZ21lbnQxO1xuXHRcdFx0fSBlbHNlIGlmIChwYXJhbWV0ZXIgPT09IDEpIHtcblx0XHRcdFx0c2VnbWVudCA9IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH0gZWxzZSBpZiAocGFyYW1ldGVyICE9IG51bGwpIHtcblx0XHRcdFx0c2VnbWVudCA9IGN1cnZlLmdldFBhcnRMZW5ndGgoMCwgcGFyYW1ldGVyKVxuXHRcdFx0XHRcdDwgY3VydmUuZ2V0UGFydExlbmd0aChwYXJhbWV0ZXIsIDEpXG5cdFx0XHRcdFx0XHQ/IGN1cnZlLl9zZWdtZW50MVxuXHRcdFx0XHRcdFx0OiBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9zZWdtZW50ID0gc2VnbWVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHNlZ21lbnQ7XG5cdH0sXG5cblx0Z2V0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuX2N1cnZlLFxuXHRcdFx0cGF0aCA9IGN1cnZlICYmIGN1cnZlLl9wYXRoLFxuXHRcdFx0dGhhdCA9IHRoaXM7XG5cdFx0aWYgKHBhdGggJiYgcGF0aC5fdmVyc2lvbiAhPT0gdGhpcy5fdmVyc2lvbikge1xuXHRcdFx0Y3VydmUgPSB0aGlzLl9wYXJhbWV0ZXIgPSB0aGlzLl9jdXJ2ZSA9IHRoaXMuX29mZnNldCA9IG51bGw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gdHJ5U2VnbWVudChzZWdtZW50KSB7XG5cdFx0XHR2YXIgY3VydmUgPSBzZWdtZW50ICYmIHNlZ21lbnQuZ2V0Q3VydmUoKTtcblx0XHRcdGlmIChjdXJ2ZSAmJiAodGhhdC5fcGFyYW1ldGVyID0gY3VydmUuZ2V0UGFyYW1ldGVyT2YodGhhdC5fcG9pbnQpKVxuXHRcdFx0XHRcdCE9IG51bGwpIHtcblx0XHRcdFx0dGhhdC5fc2V0Q3VydmUoY3VydmUpO1xuXHRcdFx0XHR0aGF0Ll9zZWdtZW50ID0gc2VnbWVudDtcblx0XHRcdFx0cmV0dXJuIGN1cnZlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBjdXJ2ZVxuXHRcdFx0fHwgdHJ5U2VnbWVudCh0aGlzLl9zZWdtZW50KVxuXHRcdFx0fHwgdHJ5U2VnbWVudCh0aGlzLl9zZWdtZW50MSlcblx0XHRcdHx8IHRyeVNlZ21lbnQodGhpcy5fc2VnbWVudDIuZ2V0UHJldmlvdXMoKSk7XG5cdH0sXG5cblx0Z2V0UGF0aDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5fcGF0aDtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBjdXJ2ZS5nZXRJbmRleCgpO1xuXHR9LFxuXG5cdGdldFBhcmFtZXRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0cGFyYW1ldGVyID0gdGhpcy5fcGFyYW1ldGVyO1xuXHRcdHJldHVybiBjdXJ2ZSAmJiBwYXJhbWV0ZXIgPT0gbnVsbFxuXHRcdFx0PyB0aGlzLl9wYXJhbWV0ZXIgPSBjdXJ2ZS5nZXRQYXJhbWV0ZXJPZih0aGlzLl9wb2ludClcblx0XHRcdDogcGFyYW1ldGVyO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9pbnQ7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5fb2Zmc2V0O1xuXHRcdGlmIChvZmZzZXQgPT0gbnVsbCkge1xuXHRcdFx0b2Zmc2V0ID0gMDtcblx0XHRcdHZhciBwYXRoID0gdGhpcy5nZXRQYXRoKCksXG5cdFx0XHRcdGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXHRcdFx0aWYgKHBhdGggJiYgaW5kZXggIT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgY3VydmVzID0gcGF0aC5nZXRDdXJ2ZXMoKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBpbmRleDsgaSsrKVxuXHRcdFx0XHRcdG9mZnNldCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9vZmZzZXQgPSBvZmZzZXQgKz0gdGhpcy5nZXRDdXJ2ZU9mZnNldCgpO1xuXHRcdH1cblx0XHRyZXR1cm4gb2Zmc2V0O1xuXHR9LFxuXG5cdGdldEN1cnZlT2Zmc2V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpO1xuXHRcdHJldHVybiBwYXJhbWV0ZXIgIT0gbnVsbCAmJiBjdXJ2ZSAmJiBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHBhcmFtZXRlcik7XG5cdH0sXG5cblx0Z2V0SW50ZXJzZWN0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW50ZXJzZWN0aW9uO1xuXHR9LFxuXG5cdGdldERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZGlzdGFuY2U7XG5cdH0sXG5cblx0ZGl2aWRlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRyZXMgPSBudWxsO1xuXHRcdGlmIChjdXJ2ZSkge1xuXHRcdFx0cmVzID0gY3VydmUuZGl2aWRlKHRoaXMuZ2V0UGFyYW1ldGVyKCksIHRydWUpO1xuXHRcdFx0aWYgKHJlcylcblx0XHRcdFx0dGhpcy5fc2V0U2VnbWVudChyZXMuX3NlZ21lbnQxKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZSA/IGN1cnZlLnNwbGl0KHRoaXMuZ2V0UGFyYW1ldGVyKCksIHRydWUpIDogbnVsbDtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGxvYywgX2lnbm9yZU90aGVyKSB7XG5cdFx0dmFyIHJlcyA9IHRoaXMgPT09IGxvYyxcblx0XHRcdGVwc2lsb24gPSAyZS03O1xuXHRcdGlmICghcmVzICYmIGxvYyBpbnN0YW5jZW9mIEN1cnZlTG9jYXRpb25cblx0XHRcdFx0JiYgdGhpcy5nZXRQYXRoKCkgPT09IGxvYy5nZXRQYXRoKClcblx0XHRcdFx0JiYgdGhpcy5nZXRQb2ludCgpLmlzQ2xvc2UobG9jLmdldFBvaW50KCksIGVwc2lsb24pKSB7XG5cdFx0XHR2YXIgYzEgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdGMyID0gbG9jLmdldEN1cnZlKCksXG5cdFx0XHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdFx0XHRkaWZmID0gYWJzKFxuXHRcdFx0XHRcdCgoYzEuaXNMYXN0KCkgJiYgYzIuaXNGaXJzdCgpID8gLTEgOiBjMS5nZXRJbmRleCgpKVxuXHRcdFx0XHRcdFx0XHQrIHRoaXMuZ2V0UGFyYW1ldGVyKCkpIC1cblx0XHRcdFx0XHQoKGMyLmlzTGFzdCgpICYmIGMxLmlzRmlyc3QoKSA/IC0xIDogYzIuZ2V0SW5kZXgoKSlcblx0XHRcdFx0XHRcdFx0KyBsb2MuZ2V0UGFyYW1ldGVyKCkpKTtcblx0XHRcdHJlcyA9IChkaWZmIDwgNGUtN1xuXHRcdFx0XHR8fCAoKGRpZmYgPSBhYnModGhpcy5nZXRPZmZzZXQoKSAtIGxvYy5nZXRPZmZzZXQoKSkpIDwgZXBzaWxvblxuXHRcdFx0XHRcdHx8IGFicyh0aGlzLmdldFBhdGgoKS5nZXRMZW5ndGgoKSAtIGRpZmYpIDwgZXBzaWxvbikpXG5cdFx0XHRcdCYmIChfaWdub3JlT3RoZXJcblx0XHRcdFx0XHR8fCAoIXRoaXMuX2ludGVyc2VjdGlvbiAmJiAhbG9jLl9pbnRlcnNlY3Rpb25cblx0XHRcdFx0XHRcdHx8IHRoaXMuX2ludGVyc2VjdGlvbiAmJiB0aGlzLl9pbnRlcnNlY3Rpb24uZXF1YWxzKFxuXHRcdFx0XHRcdFx0XHRcdGxvYy5faW50ZXJzZWN0aW9uLCB0cnVlKSkpO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFydHMgPSBbXSxcblx0XHRcdHBvaW50ID0gdGhpcy5nZXRQb2ludCgpLFxuXHRcdFx0ZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRpZiAocG9pbnQpXG5cdFx0XHRwYXJ0cy5wdXNoKCdwb2ludDogJyArIHBvaW50KTtcblx0XHR2YXIgaW5kZXggPSB0aGlzLmdldEluZGV4KCk7XG5cdFx0aWYgKGluZGV4ICE9IG51bGwpXG5cdFx0XHRwYXJ0cy5wdXNoKCdpbmRleDogJyArIGluZGV4KTtcblx0XHR2YXIgcGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXIoKTtcblx0XHRpZiAocGFyYW1ldGVyICE9IG51bGwpXG5cdFx0XHRwYXJ0cy5wdXNoKCdwYXJhbWV0ZXI6ICcgKyBmLm51bWJlcihwYXJhbWV0ZXIpKTtcblx0XHRpZiAodGhpcy5fZGlzdGFuY2UgIT0gbnVsbClcblx0XHRcdHBhcnRzLnB1c2goJ2Rpc3RhbmNlOiAnICsgZi5udW1iZXIodGhpcy5fZGlzdGFuY2UpKTtcblx0XHRyZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuXHR9LFxuXG5cdGlzVG91Y2hpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbnRlciA9IHRoaXMuX2ludGVyc2VjdGlvbjtcblx0XHRpZiAoaW50ZXIgJiYgdGhpcy5nZXRUYW5nZW50KCkuaXNDb2xsaW5lYXIoaW50ZXIuZ2V0VGFuZ2VudCgpKSkge1xuXHRcdFx0dmFyIGN1cnZlMSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdFx0Y3VydmUyID0gaW50ZXIuZ2V0Q3VydmUoKTtcblx0XHRcdHJldHVybiAhKGN1cnZlMS5pc1N0cmFpZ2h0KCkgJiYgY3VydmUyLmlzU3RyYWlnaHQoKVxuXHRcdFx0XHRcdCYmIGN1cnZlMS5nZXRMaW5lKCkuaW50ZXJzZWN0KGN1cnZlMi5nZXRMaW5lKCkpKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGlzQ3Jvc3Npbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpbnRlciA9IHRoaXMuX2ludGVyc2VjdGlvbjtcblx0XHRpZiAoIWludGVyKVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdHZhciB0MSA9IHRoaXMuZ2V0UGFyYW1ldGVyKCksXG5cdFx0XHR0MiA9IGludGVyLmdldFBhcmFtZXRlcigpLFxuXHRcdFx0dE1pbiA9IDRlLTcsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0aWYgKHQxID49IHRNaW4gJiYgdDEgPD0gdE1heCB8fCB0MiA+PSB0TWluICYmIHQyIDw9IHRNYXgpXG5cdFx0XHRyZXR1cm4gIXRoaXMuaXNUb3VjaGluZygpO1xuXHRcdHZhciBjMiA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdGMxID0gYzIuZ2V0UHJldmlvdXMoKSxcblx0XHRcdGM0ID0gaW50ZXIuZ2V0Q3VydmUoKSxcblx0XHRcdGMzID0gYzQuZ2V0UHJldmlvdXMoKSxcblx0XHRcdFBJID0gTWF0aC5QSTtcblx0XHRpZiAoIWMxIHx8ICFjMylcblx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdGZ1bmN0aW9uIGlzSW5SYW5nZShhbmdsZSwgbWluLCBtYXgpIHtcblx0XHRcdHJldHVybiBtaW4gPCBtYXhcblx0XHRcdFx0PyBhbmdsZSA+IG1pbiAmJiBhbmdsZSA8IG1heFxuXHRcdFx0XHQ6IGFuZ2xlID4gbWluICYmIGFuZ2xlIDw9IFBJIHx8IGFuZ2xlID49IC1QSSAmJiBhbmdsZSA8IG1heDtcblx0XHR9XG5cblx0XHR2YXIgYTEgPSBjMS5nZXRUYW5nZW50QXQodE1heCwgdHJ1ZSkubmVnYXRlKCkuZ2V0QW5nbGVJblJhZGlhbnMoKSxcblx0XHRcdGEyID0gYzIuZ2V0VGFuZ2VudEF0KHRNaW4sIHRydWUpLmdldEFuZ2xlSW5SYWRpYW5zKCksXG5cdFx0XHRhMyA9IGMzLmdldFRhbmdlbnRBdCh0TWF4LCB0cnVlKS5uZWdhdGUoKS5nZXRBbmdsZUluUmFkaWFucygpLFxuXHRcdFx0YTQgPSBjNC5nZXRUYW5nZW50QXQodE1pbiwgdHJ1ZSkuZ2V0QW5nbGVJblJhZGlhbnMoKTtcblxuXHRcdHJldHVybiAoaXNJblJhbmdlKGEzLCBhMSwgYTIpIF4gaXNJblJhbmdlKGE0LCBhMSwgYTIpKVxuXHRcdFx0JiYgKGlzSW5SYW5nZShhMywgYTIsIGExKSBeIGlzSW5SYW5nZShhNCwgYTIsIGExKSk7XG5cdH0sXG5cblx0aXNPdmVybGFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9vdmVybGFwO1xuXHR9XG59LCBCYXNlLmVhY2goQ3VydmUuZXZhbHVhdGVNZXRob2RzLCBmdW5jdGlvbihuYW1lKSB7XG5cdHZhciBnZXQgPSBuYW1lICsgJ0F0Jztcblx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJhbWV0ZXIgPSB0aGlzLmdldFBhcmFtZXRlcigpLFxuXHRcdFx0Y3VydmUgPSB0aGlzLmdldEN1cnZlKCk7XG5cdFx0cmV0dXJuIHBhcmFtZXRlciAhPSBudWxsICYmIGN1cnZlICYmIGN1cnZlW2dldF0ocGFyYW1ldGVyLCB0cnVlKTtcblx0fTtcbn0sIHtcblx0cHJlc2VydmU6IHRydWVcbn0pLFxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGluc2VydChsb2NhdGlvbnMsIGxvYywgbWVyZ2UpIHtcblx0XHR2YXIgbGVuZ3RoID0gbG9jYXRpb25zLmxlbmd0aCxcblx0XHRcdGwgPSAwLFxuXHRcdFx0ciA9IGxlbmd0aCAtIDE7XG5cblx0XHRmdW5jdGlvbiBzZWFyY2goaW5kZXgsIGRpcikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IGluZGV4ICsgZGlyOyBpID49IC0xICYmIGkgPD0gbGVuZ3RoOyBpICs9IGRpcikge1xuXHRcdFx0XHR2YXIgbG9jMiA9IGxvY2F0aW9uc1soKGkgJSBsZW5ndGgpICsgbGVuZ3RoKSAlIGxlbmd0aF07XG5cdFx0XHRcdGlmICghbG9jLmdldFBvaW50KCkuaXNDbG9zZShsb2MyLmdldFBvaW50KCksXG5cdFx0XHRcdFx0XHQyZS03KSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0aWYgKGxvYy5lcXVhbHMobG9jMikpXG5cdFx0XHRcdFx0cmV0dXJuIGxvYzI7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHR3aGlsZSAobCA8PSByKSB7XG5cdFx0XHR2YXIgbSA9IChsICsgcikgPj4+IDEsXG5cdFx0XHRcdGxvYzIgPSBsb2NhdGlvbnNbbV0sXG5cdFx0XHRcdGZvdW5kO1xuXHRcdFx0aWYgKG1lcmdlICYmIChmb3VuZCA9IGxvYy5lcXVhbHMobG9jMikgPyBsb2MyXG5cdFx0XHRcdFx0OiAoc2VhcmNoKG0sIC0xKSB8fCBzZWFyY2gobSwgMSkpKSkge1xuXHRcdFx0XHRpZiAobG9jLl9vdmVybGFwKSB7XG5cdFx0XHRcdFx0Zm91bmQuX292ZXJsYXAgPSBmb3VuZC5faW50ZXJzZWN0aW9uLl9vdmVybGFwID0gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gZm91bmQ7XG5cdFx0XHR9XG5cdFx0dmFyIHBhdGgxID0gbG9jLmdldFBhdGgoKSxcblx0XHRcdHBhdGgyID0gbG9jMi5nZXRQYXRoKCksXG5cdFx0XHRkaWZmID0gcGF0aDEgPT09IHBhdGgyXG5cdFx0XHRcdD8gKGxvYy5nZXRJbmRleCgpICsgbG9jLmdldFBhcmFtZXRlcigpKVxuXHRcdFx0XHQtIChsb2MyLmdldEluZGV4KCkgKyBsb2MyLmdldFBhcmFtZXRlcigpKVxuXHRcdFx0XHQ6IHBhdGgxLl9pZCAtIHBhdGgyLl9pZDtcblx0XHRcdGlmIChkaWZmIDwgMCkge1xuXHRcdFx0XHRyID0gbSAtIDE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRsID0gbSArIDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGxvY2F0aW9ucy5zcGxpY2UobCwgMCwgbG9jKTtcblx0XHRyZXR1cm4gbG9jO1xuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGljczoge1xuXHRcdGluc2VydDogaW5zZXJ0LFxuXG5cdFx0ZXhwYW5kOiBmdW5jdGlvbihsb2NhdGlvbnMpIHtcblx0XHRcdHZhciBleHBhbmRlZCA9IGxvY2F0aW9ucy5zbGljZSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsb2NhdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGluc2VydChleHBhbmRlZCwgbG9jYXRpb25zW2ldLl9pbnRlcnNlY3Rpb24sIGZhbHNlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH19O1xufSk7XG5cbnZhciBQYXRoSXRlbSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aEl0ZW0nLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGhJdGVtKCkge1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKHBhdGgsIGluY2x1ZGUsIF9tYXRyaXgsIF9yZXR1cm5GaXJzdCkge1xuXHRcdHZhciBzZWxmID0gdGhpcyA9PT0gcGF0aCB8fCAhcGF0aCxcblx0XHRcdG1hdHJpeDEgPSB0aGlzLl9tYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpLFxuXHRcdFx0bWF0cml4MiA9IHNlbGYgPyBtYXRyaXgxXG5cdFx0XHRcdDogKF9tYXRyaXggfHwgcGF0aC5fbWF0cml4KS5vck51bGxJZklkZW50aXR5KCk7XG5cdFx0aWYgKCFzZWxmICYmICF0aGlzLmdldEJvdW5kcyhtYXRyaXgxKS50b3VjaGVzKHBhdGguZ2V0Qm91bmRzKG1hdHJpeDIpKSlcblx0XHRcdHJldHVybiBbXTtcblx0XHR2YXIgY3VydmVzMSA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRjdXJ2ZXMyID0gc2VsZiA/IGN1cnZlczEgOiBwYXRoLmdldEN1cnZlcygpLFxuXHRcdFx0bGVuZ3RoMSA9IGN1cnZlczEubGVuZ3RoLFxuXHRcdFx0bGVuZ3RoMiA9IHNlbGYgPyBsZW5ndGgxIDogY3VydmVzMi5sZW5ndGgsXG5cdFx0XHR2YWx1ZXMyID0gW10sXG5cdFx0XHRhcnJheXMgPSBbXSxcblx0XHRcdGxvY2F0aW9ucyxcblx0XHRcdHBhdGg7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgyOyBpKyspXG5cdFx0XHR2YWx1ZXMyW2ldID0gY3VydmVzMltpXS5nZXRWYWx1ZXMobWF0cml4Mik7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGgxOyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZTEgPSBjdXJ2ZXMxW2ldLFxuXHRcdFx0XHR2YWx1ZXMxID0gc2VsZiA/IHZhbHVlczJbaV0gOiBjdXJ2ZTEuZ2V0VmFsdWVzKG1hdHJpeDEpLFxuXHRcdFx0XHRwYXRoMSA9IGN1cnZlMS5nZXRQYXRoKCk7XG5cdFx0XHRpZiAocGF0aDEgIT09IHBhdGgpIHtcblx0XHRcdFx0cGF0aCA9IHBhdGgxO1xuXHRcdFx0XHRsb2NhdGlvbnMgPSBbXTtcblx0XHRcdFx0YXJyYXlzLnB1c2gobG9jYXRpb25zKTtcblx0XHRcdH1cblx0XHRcdGlmIChzZWxmKSB7XG5cdFx0XHRcdEN1cnZlLl9nZXRTZWxmSW50ZXJzZWN0aW9uKHZhbHVlczEsIGN1cnZlMSwgbG9jYXRpb25zLCB7XG5cdFx0XHRcdFx0aW5jbHVkZTogaW5jbHVkZSxcblx0XHRcdFx0XHRzdGFydENvbm5lY3RlZDogbGVuZ3RoMSA9PT0gMSAmJlxuXHRcdFx0XHRcdFx0XHRjdXJ2ZTEuZ2V0UG9pbnQxKCkuZXF1YWxzKGN1cnZlMS5nZXRQb2ludDIoKSlcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBqID0gc2VsZiA/IGkgKyAxIDogMDsgaiA8IGxlbmd0aDI7IGorKykge1xuXHRcdFx0XHRpZiAoX3JldHVybkZpcnN0ICYmIGxvY2F0aW9ucy5sZW5ndGgpXG5cdFx0XHRcdFx0cmV0dXJuIGxvY2F0aW9ucztcblx0XHRcdFx0dmFyIGN1cnZlMiA9IGN1cnZlczJbal07XG5cdFx0XHRcdEN1cnZlLl9nZXRJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdHZhbHVlczEsIHZhbHVlczJbal0sIGN1cnZlMSwgY3VydmUyLCBsb2NhdGlvbnMsXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aW5jbHVkZTogaW5jbHVkZSxcblx0XHRcdFx0XHRcdHN0YXJ0Q29ubmVjdGVkOiBzZWxmICYmIGN1cnZlMS5nZXRQcmV2aW91cygpID09PSBjdXJ2ZTIsXG5cdFx0XHRcdFx0XHRlbmRDb25uZWN0ZWQ6IHNlbGYgJiYgY3VydmUxLmdldE5leHQoKSA9PT0gY3VydmUyXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsb2NhdGlvbnMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGFycmF5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGxvY2F0aW9ucy5wdXNoLmFwcGx5KGxvY2F0aW9ucywgYXJyYXlzW2ldKTtcblx0XHR9XG5cdFx0cmV0dXJuIGxvY2F0aW9ucztcblx0fSxcblxuXHRnZXRDcm9zc2luZ3M6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRJbnRlcnNlY3Rpb25zKHBhdGgsIGZ1bmN0aW9uKGludGVyKSB7XG5cdFx0XHRyZXR1cm4gaW50ZXIuaXNDcm9zc2luZygpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9hc1BhdGhJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzZXRQYXRoRGF0YTogZnVuY3Rpb24oZGF0YSkge1xuXG5cdFx0dmFyIHBhcnRzID0gZGF0YS5tYXRjaCgvW21saHZjc3F0YXpdW15tbGh2Y3NxdGF6XSovaWcpLFxuXHRcdFx0Y29vcmRzLFxuXHRcdFx0cmVsYXRpdmUgPSBmYWxzZSxcblx0XHRcdHByZXZpb3VzLFxuXHRcdFx0Y29udHJvbCxcblx0XHRcdGN1cnJlbnQgPSBuZXcgUG9pbnQoKSxcblx0XHRcdHN0YXJ0ID0gbmV3IFBvaW50KCk7XG5cblx0XHRmdW5jdGlvbiBnZXRDb29yZChpbmRleCwgY29vcmQpIHtcblx0XHRcdHZhciB2YWwgPSArY29vcmRzW2luZGV4XTtcblx0XHRcdGlmIChyZWxhdGl2ZSlcblx0XHRcdFx0dmFsICs9IGN1cnJlbnRbY29vcmRdO1xuXHRcdFx0cmV0dXJuIHZhbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRQb2ludChpbmRleCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChcblx0XHRcdFx0Z2V0Q29vcmQoaW5kZXgsICd4JyksXG5cdFx0XHRcdGdldENvb3JkKGluZGV4ICsgMSwgJ3knKVxuXHRcdFx0KTtcblx0XHR9XG5cblx0XHR0aGlzLmNsZWFyKCk7XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzICYmIHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHBhcnQgPSBwYXJ0c1tpXSxcblx0XHRcdFx0Y29tbWFuZCA9IHBhcnRbMF0sXG5cdFx0XHRcdGxvd2VyID0gY29tbWFuZC50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0Y29vcmRzID0gcGFydC5tYXRjaCgvWystXT8oPzpcXGQqXFwuXFxkK3xcXGQrXFwuPykoPzpbZUVdWystXT9cXGQrKT8vZyk7XG5cdFx0XHR2YXIgbGVuZ3RoID0gY29vcmRzICYmIGNvb3Jkcy5sZW5ndGg7XG5cdFx0XHRyZWxhdGl2ZSA9IGNvbW1hbmQgPT09IGxvd2VyO1xuXHRcdFx0aWYgKHByZXZpb3VzID09PSAneicgJiYgIS9bbXpdLy50ZXN0KGxvd2VyKSlcblx0XHRcdFx0dGhpcy5tb3ZlVG8oY3VycmVudCA9IHN0YXJ0KTtcblx0XHRcdHN3aXRjaCAobG93ZXIpIHtcblx0XHRcdGNhc2UgJ20nOlxuXHRcdFx0Y2FzZSAnbCc6XG5cdFx0XHRcdHZhciBtb3ZlID0gbG93ZXIgPT09ICdtJztcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMilcblx0XHRcdFx0XHR0aGlzW2ogPT09IDAgJiYgbW92ZSA/ICdtb3ZlVG8nIDogJ2xpbmVUbyddKFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaikpO1xuXHRcdFx0XHRjb250cm9sID0gY3VycmVudDtcblx0XHRcdFx0aWYgKG1vdmUpXG5cdFx0XHRcdFx0c3RhcnQgPSBjdXJyZW50O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ2gnOlxuXHRcdFx0Y2FzZSAndic6XG5cdFx0XHRcdHZhciBjb29yZCA9IGxvd2VyID09PSAnaCcgPyAneCcgOiAneSc7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0XHRjdXJyZW50W2Nvb3JkXSA9IGdldENvb3JkKGosIGNvb3JkKTtcblx0XHRcdFx0XHR0aGlzLmxpbmVUbyhjdXJyZW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRjb250cm9sID0gY3VycmVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdjJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNikge1xuXHRcdFx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGogKyAyKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyA0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdzJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNCkge1xuXHRcdFx0XHRcdHRoaXMuY3ViaWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHQvW2NzXS8udGVzdChwcmV2aW91cylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VycmVudC5tdWx0aXBseSgyKS5zdWJ0cmFjdChjb250cm9sKVxuXHRcdFx0XHRcdFx0XHRcdFx0OiBjdXJyZW50LFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gZ2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgMikpO1xuXHRcdFx0XHRcdHByZXZpb3VzID0gbG93ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdxJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNCkge1xuXHRcdFx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDIpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3QnOlxuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaiArPSAyKSB7XG5cdFx0XHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKFxuXHRcdFx0XHRcdFx0XHRjb250cm9sID0gKC9bcXRdLy50ZXN0KHByZXZpb3VzKVxuXHRcdFx0XHRcdFx0XHRcdFx0PyBjdXJyZW50Lm11bHRpcGx5KDIpLnN1YnRyYWN0KGNvbnRyb2wpXG5cdFx0XHRcdFx0XHRcdFx0XHQ6IGN1cnJlbnQpLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaikpO1xuXHRcdFx0XHRcdHByZXZpb3VzID0gbG93ZXI7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdhJzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gNykge1xuXHRcdFx0XHRcdHRoaXMuYXJjVG8oY3VycmVudCA9IGdldFBvaW50KGogKyA1KSxcblx0XHRcdFx0XHRcdFx0bmV3IFNpemUoK2Nvb3Jkc1tqXSwgK2Nvb3Jkc1tqICsgMV0pLFxuXHRcdFx0XHRcdFx0XHQrY29vcmRzW2ogKyAyXSwgK2Nvb3Jkc1tqICsgNF0sICtjb29yZHNbaiArIDNdKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3onOlxuXHRcdFx0XHR0aGlzLmNsb3NlUGF0aCh0cnVlKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdH1cblx0fSxcblxuXHRfY2FuQ29tcG9zaXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISh0aGlzLmhhc0ZpbGwoKSAmJiB0aGlzLmhhc1N0cm9rZSgpKTtcblx0fSxcblxuXHRfY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIHdpbmRpbmcgPSB0aGlzLl9nZXRXaW5kaW5nKHBvaW50LCBmYWxzZSwgdHJ1ZSk7XG5cdFx0cmV0dXJuICEhKHRoaXMuZ2V0V2luZGluZ1J1bGUoKSA9PT0gJ2V2ZW5vZGQnID8gd2luZGluZyAmIDEgOiB3aW5kaW5nKTtcblx0fVxuXG59KTtcblxudmFyIFBhdGggPSBQYXRoSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXRoJyxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHNlZ21lbnRzOiBbXSxcblx0XHRjbG9zZWQ6IGZhbHNlXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUGF0aChhcmcpIHtcblx0XHR0aGlzLl9jbG9zZWQgPSBmYWxzZTtcblx0XHR0aGlzLl9zZWdtZW50cyA9IFtdO1xuXHRcdHRoaXMuX3ZlcnNpb24gPSAwO1xuXHRcdHZhciBzZWdtZW50cyA9IEFycmF5LmlzQXJyYXkoYXJnKVxuXHRcdFx0PyB0eXBlb2YgYXJnWzBdID09PSAnb2JqZWN0J1xuXHRcdFx0XHQ/IGFyZ1xuXHRcdFx0XHQ6IGFyZ3VtZW50c1xuXHRcdFx0OiBhcmcgJiYgKGFyZy5zaXplID09PSB1bmRlZmluZWQgJiYgKGFyZy54ICE9PSB1bmRlZmluZWRcblx0XHRcdFx0XHR8fCBhcmcucG9pbnQgIT09IHVuZGVmaW5lZCkpXG5cdFx0XHRcdD8gYXJndW1lbnRzXG5cdFx0XHRcdDogbnVsbDtcblx0XHRpZiAoc2VnbWVudHMgJiYgc2VnbWVudHMubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2N1cnZlcyA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlID0gMDtcblx0XHRcdGlmICghc2VnbWVudHMgJiYgdHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhpcy5zZXRQYXRoRGF0YShhcmcpO1xuXHRcdFx0XHRhcmcgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9pbml0aWFsaXplKCFzZWdtZW50cyAmJiBhcmcpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvc2VkID09PSBpdGVtLl9jbG9zZWRcblx0XHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fc2VnbWVudHMsIGl0ZW0uX3NlZ21lbnRzKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0Y29weS5zZXRTZWdtZW50cyh0aGlzLl9zZWdtZW50cyk7XG5cdFx0Y29weS5fY2xvc2VkID0gdGhpcy5fY2xvc2VkO1xuXHRcdGlmICh0aGlzLl9jbG9ja3dpc2UgIT09IHVuZGVmaW5lZClcblx0XHRcdGNvcHkuX2Nsb2Nrd2lzZSA9IHRoaXMuX2Nsb2Nrd2lzZTtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUoY29weSwgaW5zZXJ0KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24gX2NoYW5nZWQoZmxhZ3MpIHtcblx0XHRfY2hhbmdlZC5iYXNlLmNhbGwodGhpcywgZmxhZ3MpO1xuXHRcdGlmIChmbGFncyAmIDgpIHtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0XHRpZiAocGFyZW50KVxuXHRcdFx0XHRwYXJlbnQuX2N1cnJlbnRQYXRoID0gdW5kZWZpbmVkO1xuXHRcdFx0dGhpcy5fbGVuZ3RoID0gdGhpcy5fYXJlYSA9IHRoaXMuX2Nsb2Nrd2lzZSA9IHRoaXMuX21vbm9DdXJ2ZXMgPVxuXHRcdFx0XHRcdHVuZGVmaW5lZDtcblx0XHRcdGlmIChmbGFncyAmIDE2KSB7XG5cdFx0XHRcdHRoaXMuX3ZlcnNpb24rKztcblx0XHRcdH0gZWxzZSBpZiAodGhpcy5fY3VydmVzKSB7XG5cdFx0XHQgICBmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2N1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0dGhpcy5fY3VydmVzW2ldLl9jaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChmbGFncyAmIDMyKSB7XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdHJldHVybiAocGFyZW50IGluc3RhbmNlb2YgQ29tcG91bmRQYXRoID8gcGFyZW50IDogdGhpcykuX3N0eWxlO1xuXHR9LFxuXG5cdGdldFNlZ21lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHM7XG5cdH0sXG5cblx0c2V0U2VnbWVudHM6IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG5cdFx0dmFyIGZ1bGx5U2VsZWN0ZWQgPSB0aGlzLmlzRnVsbHlTZWxlY3RlZCgpO1xuXHRcdHRoaXMuX3NlZ21lbnRzLmxlbmd0aCA9IDA7XG5cdFx0dGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgPSAwO1xuXHRcdHRoaXMuX2N1cnZlcyA9IHVuZGVmaW5lZDtcblx0XHRpZiAoc2VnbWVudHMgJiYgc2VnbWVudHMubGVuZ3RoID4gMClcblx0XHRcdHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoc2VnbWVudHMpKTtcblx0XHRpZiAoZnVsbHlTZWxlY3RlZClcblx0XHRcdHRoaXMuc2V0RnVsbHlTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRnZXRGaXJzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50c1swXTtcblx0fSxcblxuXHRnZXRMYXN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzW3RoaXMuX3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuXHR9LFxuXG5cdGdldEN1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0aWYgKCFjdXJ2ZXMpIHtcblx0XHRcdHZhciBsZW5ndGggPSB0aGlzLl9jb3VudEN1cnZlcygpO1xuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzID0gbmV3IEFycmF5KGxlbmd0aCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0XHRjdXJ2ZXNbaV0gPSBuZXcgQ3VydmUodGhpcywgc2VnbWVudHNbaV0sXG5cdFx0XHRcdFx0c2VnbWVudHNbaSArIDFdIHx8IHNlZ21lbnRzWzBdKTtcblx0XHR9XG5cdFx0cmV0dXJuIGN1cnZlcztcblx0fSxcblxuXHRnZXRGaXJzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDdXJ2ZXMoKVswXTtcblx0fSxcblxuXHRnZXRMYXN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdHJldHVybiBjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdO1xuXHR9LFxuXG5cdGlzQ2xvc2VkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvc2VkO1xuXHR9LFxuXG5cdHNldENsb3NlZDogZnVuY3Rpb24oY2xvc2VkKSB7XG5cdFx0aWYgKHRoaXMuX2Nsb3NlZCAhPSAoY2xvc2VkID0gISFjbG9zZWQpKSB7XG5cdFx0XHR0aGlzLl9jbG9zZWQgPSBjbG9zZWQ7XG5cdFx0XHRpZiAodGhpcy5fY3VydmVzKSB7XG5cdFx0XHRcdHZhciBsZW5ndGggPSB0aGlzLl9jdXJ2ZXMubGVuZ3RoID0gdGhpcy5fY291bnRDdXJ2ZXMoKTtcblx0XHRcdFx0aWYgKGNsb3NlZClcblx0XHRcdFx0XHR0aGlzLl9jdXJ2ZXNbbGVuZ3RoIC0gMV0gPSBuZXcgQ3VydmUodGhpcyxcblx0XHRcdFx0XHRcdHRoaXMuX3NlZ21lbnRzW2xlbmd0aCAtIDFdLCB0aGlzLl9zZWdtZW50c1swXSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDI1KTtcblx0XHR9XG5cdH1cbn0sIHtcblx0YmVhbnM6IHRydWUsXG5cblx0Z2V0UGF0aERhdGE6IGZ1bmN0aW9uKF9tYXRyaXgsIF9wcmVjaXNpb24pIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGYgPSBuZXcgRm9ybWF0dGVyKF9wcmVjaXNpb24pLFxuXHRcdFx0Y29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0Zmlyc3QgPSB0cnVlLFxuXHRcdFx0Y3VyWCwgY3VyWSxcblx0XHRcdHByZXZYLCBwcmV2WSxcblx0XHRcdGluWCwgaW5ZLFxuXHRcdFx0b3V0WCwgb3V0WSxcblx0XHRcdHBhcnRzID0gW107XG5cblx0XHRmdW5jdGlvbiBhZGRTZWdtZW50KHNlZ21lbnQsIHNraXBMaW5lKSB7XG5cdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhfbWF0cml4LCBjb29yZHMsIGZhbHNlKTtcblx0XHRcdGN1clggPSBjb29yZHNbMF07XG5cdFx0XHRjdXJZID0gY29vcmRzWzFdO1xuXHRcdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRcdHBhcnRzLnB1c2goJ00nICsgZi5wYWlyKGN1clgsIGN1clkpKTtcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGluWCA9IGNvb3Jkc1syXTtcblx0XHRcdFx0aW5ZID0gY29vcmRzWzNdO1xuXHRcdFx0XHRpZiAoaW5YID09PSBjdXJYICYmIGluWSA9PT0gY3VyWVxuXHRcdFx0XHRcdFx0JiYgb3V0WCA9PT0gcHJldlggJiYgb3V0WSA9PT0gcHJldlkpIHtcblx0XHRcdFx0XHRpZiAoIXNraXBMaW5lKVxuXHRcdFx0XHRcdFx0cGFydHMucHVzaCgnbCcgKyBmLnBhaXIoY3VyWCAtIHByZXZYLCBjdXJZIC0gcHJldlkpKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdjJyArIGYucGFpcihvdXRYIC0gcHJldlgsIG91dFkgLSBwcmV2WSlcblx0XHRcdFx0XHRcdFx0KyAnICcgKyBmLnBhaXIoaW5YIC0gcHJldlgsIGluWSAtIHByZXZZKVxuXHRcdFx0XHRcdFx0XHQrICcgJyArIGYucGFpcihjdXJYIC0gcHJldlgsIGN1clkgLSBwcmV2WSkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwcmV2WCA9IGN1clg7XG5cdFx0XHRwcmV2WSA9IGN1clk7XG5cdFx0XHRvdXRYID0gY29vcmRzWzRdO1xuXHRcdFx0b3V0WSA9IGNvb3Jkc1s1XTtcblx0XHR9XG5cblx0XHRpZiAobGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuICcnO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdGFkZFNlZ21lbnQoc2VnbWVudHNbaV0pO1xuXHRcdGlmICh0aGlzLl9jbG9zZWQgJiYgbGVuZ3RoID4gMCkge1xuXHRcdFx0YWRkU2VnbWVudChzZWdtZW50c1swXSwgdHJ1ZSk7XG5cdFx0XHRwYXJ0cy5wdXNoKCd6Jyk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXJ0cy5qb2luKCcnKTtcblx0fVxufSwge1xuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50cy5sZW5ndGggPT09IDA7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvbnRlbnQ6IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNik7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR0aGlzLl9zZWdtZW50c1tpXS5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIHRydWUpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9hZGQ6IGZ1bmN0aW9uKHNlZ3MsIGluZGV4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRhbW91bnQgPSBzZWdzLmxlbmd0aCxcblx0XHRcdGFwcGVuZCA9IGluZGV4ID09IG51bGwsXG5cdFx0XHRpbmRleCA9IGFwcGVuZCA/IHNlZ21lbnRzLmxlbmd0aCA6IGluZGV4O1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2Vnc1tpXTtcblx0XHRcdGlmIChzZWdtZW50Ll9wYXRoKVxuXHRcdFx0XHRzZWdtZW50ID0gc2Vnc1tpXSA9IHNlZ21lbnQuY2xvbmUoKTtcblx0XHRcdHNlZ21lbnQuX3BhdGggPSB0aGlzO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBpbmRleCArIGk7XG5cdFx0XHRpZiAoc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUpXG5cdFx0XHRcdHRoaXMuX3VwZGF0ZVNlbGVjdGlvbihzZWdtZW50LCAwLCBzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSk7XG5cdFx0fVxuXHRcdGlmIChhcHBlbmQpIHtcblx0XHRcdHNlZ21lbnRzLnB1c2guYXBwbHkoc2VnbWVudHMsIHNlZ3MpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzZWdtZW50cy5zcGxpY2UuYXBwbHkoc2VnbWVudHMsIFtpbmRleCwgMF0uY29uY2F0KHNlZ3MpKTtcblx0XHRcdGZvciAodmFyIGkgPSBpbmRleCArIGFtb3VudCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0c2VnbWVudHNbaV0uX2luZGV4ID0gaTtcblx0XHR9XG5cdFx0aWYgKGN1cnZlcykge1xuXHRcdFx0dmFyIHRvdGFsID0gdGhpcy5fY291bnRDdXJ2ZXMoKSxcblx0XHRcdFx0ZnJvbSA9IGluZGV4ICsgYW1vdW50IC0gMSA9PT0gdG90YWwgPyBpbmRleCAtIDEgOiBpbmRleCxcblx0XHRcdFx0c3RhcnQgPSBmcm9tLFxuXHRcdFx0XHR0byA9IE1hdGgubWluKGZyb20gKyBhbW91bnQsIHRvdGFsKTtcblx0XHRcdGlmIChzZWdzLl9jdXJ2ZXMpIHtcblx0XHRcdFx0Y3VydmVzLnNwbGljZS5hcHBseShjdXJ2ZXMsIFtmcm9tLCAwXS5jb25jYXQoc2Vncy5fY3VydmVzKSk7XG5cdFx0XHRcdHN0YXJ0ICs9IHNlZ3MuX2N1cnZlcy5sZW5ndGg7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gc3RhcnQ7IGkgPCB0bzsgaSsrKVxuXHRcdFx0XHRjdXJ2ZXMuc3BsaWNlKGksIDAsIG5ldyBDdXJ2ZSh0aGlzLCBudWxsLCBudWxsKSk7XG5cdFx0XHR0aGlzLl9hZGp1c3RDdXJ2ZXMoZnJvbSwgdG8pO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKDI1KTtcblx0XHRyZXR1cm4gc2Vncztcblx0fSxcblxuXHRfYWRqdXN0Q3VydmVzOiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0Y3VydmU7XG5cdFx0Zm9yICh2YXIgaSA9IGZyb207IGkgPCB0bzsgaSsrKSB7XG5cdFx0XHRjdXJ2ZSA9IGN1cnZlc1tpXTtcblx0XHRcdGN1cnZlLl9wYXRoID0gdGhpcztcblx0XHRcdGN1cnZlLl9zZWdtZW50MSA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQyID0gc2VnbWVudHNbaSArIDFdIHx8IHNlZ21lbnRzWzBdO1xuXHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0aWYgKGN1cnZlID0gY3VydmVzW3RoaXMuX2Nsb3NlZCAmJiBmcm9tID09PSAwID8gc2VnbWVudHMubGVuZ3RoIC0gMVxuXHRcdFx0XHQ6IGZyb20gLSAxXSkge1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQyID0gc2VnbWVudHNbZnJvbV0gfHwgc2VnbWVudHNbMF07XG5cdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0XHRpZiAoY3VydmUgPSBjdXJ2ZXNbdG9dKSB7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1t0b107XG5cdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdH1cblx0fSxcblxuXHRfY291bnRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsZW5ndGggPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7XG5cdFx0cmV0dXJuICF0aGlzLl9jbG9zZWQgJiYgbGVuZ3RoID4gMCA/IGxlbmd0aCAtIDEgOiBsZW5ndGg7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbihzZWdtZW50MSApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgdHlwZW9mIHNlZ21lbnQxICE9PSAnbnVtYmVyJ1xuXHRcdFx0PyB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKGFyZ3VtZW50cykpXG5cdFx0XHQ6IHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMpIF0pWzBdO1xuXHR9LFxuXG5cdGluc2VydDogZnVuY3Rpb24oaW5kZXgsIHNlZ21lbnQxICkge1xuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiB0eXBlb2Ygc2VnbWVudDEgIT09ICdudW1iZXInXG5cdFx0XHQ/IHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoYXJndW1lbnRzLCAxKSwgaW5kZXgpXG5cdFx0XHQ6IHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMsIDEpIF0sIGluZGV4KVswXTtcblx0fSxcblxuXHRhZGRTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFsgU2VnbWVudC5yZWFkKGFyZ3VtZW50cykgXSlbMF07XG5cdH0sXG5cblx0aW5zZXJ0U2VnbWVudDogZnVuY3Rpb24oaW5kZXggKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMsIDEpIF0sIGluZGV4KVswXTtcblx0fSxcblxuXHRhZGRTZWdtZW50czogZnVuY3Rpb24oc2VnbWVudHMpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChzZWdtZW50cykpO1xuXHR9LFxuXG5cdGluc2VydFNlZ21lbnRzOiBmdW5jdGlvbihpbmRleCwgc2VnbWVudHMpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChzZWdtZW50cyksIGluZGV4KTtcblx0fSxcblxuXHRyZW1vdmVTZWdtZW50OiBmdW5jdGlvbihpbmRleCkge1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZVNlZ21lbnRzKGluZGV4LCBpbmRleCArIDEpWzBdIHx8IG51bGw7XG5cdH0sXG5cblx0cmVtb3ZlU2VnbWVudHM6IGZ1bmN0aW9uKGZyb20sIHRvLCBfaW5jbHVkZUN1cnZlcykge1xuXHRcdGZyb20gPSBmcm9tIHx8IDA7XG5cdFx0dG8gPSBCYXNlLnBpY2sodG8sIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCk7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRjb3VudCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdHJlbW92ZWQgPSBzZWdtZW50cy5zcGxpY2UoZnJvbSwgdG8gLSBmcm9tKSxcblx0XHRcdGFtb3VudCA9IHJlbW92ZWQubGVuZ3RoO1xuXHRcdGlmICghYW1vdW50KVxuXHRcdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBhbW91bnQ7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSByZW1vdmVkW2ldO1xuXHRcdFx0aWYgKHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlKVxuXHRcdFx0XHR0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUsIDApO1xuXHRcdFx0c2VnbWVudC5faW5kZXggPSBzZWdtZW50Ll9wYXRoID0gbnVsbDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IGZyb20sIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzZWdtZW50c1tpXS5faW5kZXggPSBpO1xuXHRcdGlmIChjdXJ2ZXMpIHtcblx0XHRcdHZhciBpbmRleCA9IGZyb20gPiAwICYmIHRvID09PSBjb3VudCArICh0aGlzLl9jbG9zZWQgPyAxIDogMClcblx0XHRcdFx0XHQ/IGZyb20gLSAxXG5cdFx0XHRcdFx0OiBmcm9tLFxuXHRcdFx0XHRjdXJ2ZXMgPSBjdXJ2ZXMuc3BsaWNlKGluZGV4LCBhbW91bnQpO1xuXHRcdFx0aWYgKF9pbmNsdWRlQ3VydmVzKVxuXHRcdFx0XHRyZW1vdmVkLl9jdXJ2ZXMgPSBjdXJ2ZXMuc2xpY2UoMSk7XG5cdFx0XHR0aGlzLl9hZGp1c3RDdXJ2ZXMoaW5kZXgsIGluZGV4KTtcblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCgyNSk7XG5cdFx0cmV0dXJuIHJlbW92ZWQ7XG5cdH0sXG5cblx0Y2xlYXI6ICcjcmVtb3ZlU2VnbWVudHMnLFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAoc2VnbWVudHNbaV0uaGFzSGFuZGxlcygpKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGNsZWFySGFuZGxlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRzZWdtZW50c1tpXS5jbGVhckhhbmRsZXMoKTtcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9sZW5ndGggPT0gbnVsbCkge1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGxlbmd0aCArPSBjdXJ2ZXNbaV0uZ2V0TGVuZ3RoKCk7XG5cdFx0XHR0aGlzLl9sZW5ndGggPSBsZW5ndGg7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9sZW5ndGg7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX2FyZWEgPT0gbnVsbCkge1xuXHRcdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRcdGNvdW50ID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0XHRsYXN0ID0gY291bnQgLSAxLFxuXHRcdFx0XHRhcmVhID0gMDtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2xvc2VkID8gY291bnQgOiBsYXN0OyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGFyZWEgKz0gQ3VydmUuZ2V0QXJlYShDdXJ2ZS5nZXRWYWx1ZXMoXG5cdFx0XHRcdFx0XHRzZWdtZW50c1tpXSwgc2VnbWVudHNbaSA8IGxhc3QgPyBpICsgMSA6IDBdKSk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hcmVhID0gYXJlYTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2FyZWE7XG5cdH0sXG5cblx0aXNDbG9ja3dpc2U6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9jbG9ja3dpc2UgIT09IHVuZGVmaW5lZClcblx0XHRcdHJldHVybiB0aGlzLl9jbG9ja3dpc2U7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0QXJlYSgpID49IDA7XG5cdH0sXG5cblx0c2V0Q2xvY2t3aXNlOiBmdW5jdGlvbihjbG9ja3dpc2UpIHtcblx0XHRpZiAodGhpcy5pc0Nsb2Nrd2lzZSgpICE9IChjbG9ja3dpc2UgPSAhIWNsb2Nrd2lzZSkpXG5cdFx0XHR0aGlzLnJldmVyc2UoKTtcblx0XHR0aGlzLl9jbG9ja3dpc2UgPSBjbG9ja3dpc2U7XG5cdH0sXG5cblx0aXNGdWxseVNlbGVjdGVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHJldHVybiB0aGlzLl9zZWxlY3RlZCAmJiBsZW5ndGggPiAwICYmIHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlXG5cdFx0XHRcdD09PSBsZW5ndGggKiA3O1xuXHR9LFxuXG5cdHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0aWYgKHNlbGVjdGVkKVxuXHRcdFx0dGhpcy5fc2VsZWN0U2VnbWVudHModHJ1ZSk7XG5cdFx0dGhpcy5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uIHNldFNlbGVjdGVkKHNlbGVjdGVkKSB7XG5cdFx0aWYgKCFzZWxlY3RlZClcblx0XHRcdHRoaXMuX3NlbGVjdFNlZ21lbnRzKGZhbHNlKTtcblx0XHRzZXRTZWxlY3RlZC5iYXNlLmNhbGwodGhpcywgc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdF9zZWxlY3RTZWdtZW50czogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlID0gc2VsZWN0ZWRcblx0XHRcdFx0PyBsZW5ndGggKiA3IDogMDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0dGhpcy5fc2VnbWVudHNbaV0uX3NlbGVjdGlvblN0YXRlID0gc2VsZWN0ZWRcblx0XHRcdFx0XHQ/IDcgOiAwO1xuXHR9LFxuXG5cdF91cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uKHNlZ21lbnQsIG9sZFN0YXRlLCBuZXdTdGF0ZSkge1xuXHRcdHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlID0gbmV3U3RhdGU7XG5cdFx0dmFyIHRvdGFsID0gdGhpcy5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgKz0gbmV3U3RhdGUgLSBvbGRTdGF0ZTtcblx0XHRpZiAodG90YWwgPiAwKVxuXHRcdFx0dGhpcy5zZXRTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRmbGF0dGVuOiBmdW5jdGlvbihtYXhEaXN0YW5jZSkge1xuXHRcdHZhciBpdGVyYXRvciA9IG5ldyBQYXRoSXRlcmF0b3IodGhpcywgNjQsIDAuMSksXG5cdFx0XHRwb3MgPSAwLFxuXHRcdFx0c3RlcCA9IGl0ZXJhdG9yLmxlbmd0aCAvIE1hdGguY2VpbChpdGVyYXRvci5sZW5ndGggLyBtYXhEaXN0YW5jZSksXG5cdFx0XHRlbmQgPSBpdGVyYXRvci5sZW5ndGggKyAodGhpcy5fY2xvc2VkID8gLXN0ZXAgOiBzdGVwKSAvIDI7XG5cdFx0dmFyIHNlZ21lbnRzID0gW107XG5cdFx0d2hpbGUgKHBvcyA8PSBlbmQpIHtcblx0XHRcdHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQoaXRlcmF0b3IuZ2V0UG9pbnRBdChwb3MpKSk7XG5cdFx0XHRwb3MgKz0gc3RlcDtcblx0XHR9XG5cdFx0dGhpcy5zZXRTZWdtZW50cyhzZWdtZW50cyk7XG5cdH0sXG5cblx0cmVkdWNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRmb3IgKHZhciBpID0gY3VydmVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgY3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRpZiAoIWN1cnZlLmhhc0hhbmRsZXMoKSAmJiAoY3VydmUuZ2V0TGVuZ3RoKCkgPT09IDBcblx0XHRcdFx0XHR8fCBjdXJ2ZS5pc0NvbGxpbmVhcihjdXJ2ZS5nZXROZXh0KCkpKSlcblx0XHRcdFx0Y3VydmUucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNpbXBsaWZ5OiBmdW5jdGlvbih0b2xlcmFuY2UpIHtcblx0XHRpZiAodGhpcy5fc2VnbWVudHMubGVuZ3RoID4gMikge1xuXHRcdFx0dmFyIGZpdHRlciA9IG5ldyBQYXRoRml0dGVyKHRoaXMsIHRvbGVyYW5jZSB8fCAyLjUpO1xuXHRcdFx0dGhpcy5zZXRTZWdtZW50cyhmaXR0ZXIuZml0KCkpO1xuXHRcdH1cblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24oaW5kZXgsIHBhcmFtZXRlcikge1xuXHRcdGlmIChwYXJhbWV0ZXIgPT09IG51bGwpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRpZiAoYXJndW1lbnRzLmxlbmd0aCA9PT0gMSkge1xuXHRcdFx0dmFyIGFyZyA9IGluZGV4O1xuXHRcdFx0aWYgKHR5cGVvZiBhcmcgPT09ICdudW1iZXInKVxuXHRcdFx0XHRhcmcgPSB0aGlzLmdldExvY2F0aW9uQXQoYXJnKTtcblx0XHRcdGlmICghYXJnKVxuXHRcdFx0XHRyZXR1cm4gbnVsbFxuXHRcdFx0aW5kZXggPSBhcmcuaW5kZXg7XG5cdFx0XHRwYXJhbWV0ZXIgPSBhcmcucGFyYW1ldGVyO1xuXHRcdH1cblx0XHR2YXIgdE1pbiA9IDRlLTcsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW47XG5cdFx0aWYgKHBhcmFtZXRlciA+PSB0TWF4KSB7XG5cdFx0XHRpbmRleCsrO1xuXHRcdFx0cGFyYW1ldGVyLS07XG5cdFx0fVxuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGlmIChpbmRleCA+PSAwICYmIGluZGV4IDwgY3VydmVzLmxlbmd0aCkge1xuXHRcdFx0aWYgKHBhcmFtZXRlciA+PSB0TWluKSB7XG5cdFx0XHRcdGN1cnZlc1tpbmRleCsrXS5kaXZpZGUocGFyYW1ldGVyLCB0cnVlKTtcblx0XHRcdH1cblx0XHRcdHZhciBzZWdzID0gdGhpcy5yZW1vdmVTZWdtZW50cyhpbmRleCwgdGhpcy5fc2VnbWVudHMubGVuZ3RoLCB0cnVlKSxcblx0XHRcdFx0cGF0aDtcblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpIHtcblx0XHRcdFx0dGhpcy5zZXRDbG9zZWQoZmFsc2UpO1xuXHRcdFx0XHRwYXRoID0gdGhpcztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRcdHBhdGguaW5zZXJ0QWJvdmUodGhpcywgdHJ1ZSk7XG5cdFx0XHRcdHRoaXMuX2Nsb25lKHBhdGgpO1xuXHRcdFx0fVxuXHRcdFx0cGF0aC5fYWRkKHNlZ3MsIDApO1xuXHRcdFx0dGhpcy5hZGRTZWdtZW50KHNlZ3NbMF0pO1xuXHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnRzLnJldmVyc2UoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSB0aGlzLl9zZWdtZW50c1tpXTtcblx0XHRcdHZhciBoYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZUluO1xuXHRcdFx0c2VnbWVudC5faGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRzZWdtZW50Ll9oYW5kbGVPdXQgPSBoYW5kbGVJbjtcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gaTtcblx0XHR9XG5cdFx0dGhpcy5fY3VydmVzID0gbnVsbDtcblx0XHRpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG5cdFx0XHR0aGlzLl9jbG9ja3dpc2UgPSAhdGhpcy5fY2xvY2t3aXNlO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdH0sXG5cblx0am9pbjogZnVuY3Rpb24ocGF0aCkge1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHR2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdFx0bGFzdDEgPSB0aGlzLmdldExhc3RTZWdtZW50KCksXG5cdFx0XHRcdGxhc3QyID0gcGF0aC5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdFx0aWYgKCFsYXN0Milcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRpZiAobGFzdDEgJiYgbGFzdDEuX3BvaW50LmVxdWFscyhsYXN0Mi5fcG9pbnQpKVxuXHRcdFx0XHRwYXRoLnJldmVyc2UoKTtcblx0XHRcdHZhciBmaXJzdDIgPSBwYXRoLmdldEZpcnN0U2VnbWVudCgpO1xuXHRcdFx0aWYgKGxhc3QxICYmIGxhc3QxLl9wb2ludC5lcXVhbHMoZmlyc3QyLl9wb2ludCkpIHtcblx0XHRcdFx0bGFzdDEuc2V0SGFuZGxlT3V0KGZpcnN0Mi5faGFuZGxlT3V0KTtcblx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDEpKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBmaXJzdDEgPSB0aGlzLmdldEZpcnN0U2VnbWVudCgpO1xuXHRcdFx0XHRpZiAoZmlyc3QxICYmIGZpcnN0MS5fcG9pbnQuZXF1YWxzKGZpcnN0Mi5fcG9pbnQpKVxuXHRcdFx0XHRcdHBhdGgucmV2ZXJzZSgpO1xuXHRcdFx0XHRsYXN0MiA9IHBhdGguZ2V0TGFzdFNlZ21lbnQoKTtcblx0XHRcdFx0aWYgKGZpcnN0MSAmJiBmaXJzdDEuX3BvaW50LmVxdWFscyhsYXN0Mi5fcG9pbnQpKSB7XG5cdFx0XHRcdFx0Zmlyc3QxLnNldEhhbmRsZUluKGxhc3QyLl9oYW5kbGVJbik7XG5cdFx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKDAsIHNlZ21lbnRzLmxlbmd0aCAtIDEpLCAwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMuc2xpY2UoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChwYXRoLl9jbG9zZWQpXG5cdFx0XHRcdHRoaXMuX2FkZChbc2VnbWVudHNbMF1dKTtcblx0XHRcdHBhdGgucmVtb3ZlKCk7XG5cdFx0fVxuXHRcdHZhciBmaXJzdCA9IHRoaXMuZ2V0Rmlyc3RTZWdtZW50KCksXG5cdFx0XHRsYXN0ID0gdGhpcy5nZXRMYXN0U2VnbWVudCgpO1xuXHRcdGlmIChmaXJzdCAhPT0gbGFzdCAmJiBmaXJzdC5fcG9pbnQuZXF1YWxzKGxhc3QuX3BvaW50KSkge1xuXHRcdFx0Zmlyc3Quc2V0SGFuZGxlSW4obGFzdC5faGFuZGxlSW4pO1xuXHRcdFx0bGFzdC5yZW1vdmUoKTtcblx0XHRcdHRoaXMuc2V0Q2xvc2VkKHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b1NoYXBlOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHRpZiAoIXRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHR0eXBlLFxuXHRcdFx0c2l6ZSxcblx0XHRcdHJhZGl1cyxcblx0XHRcdHRvcENlbnRlcjtcblxuXHRcdGZ1bmN0aW9uIGlzQ29sbGluZWFyKGksIGopIHtcblx0XHRcdHZhciBzZWcxID0gc2VnbWVudHNbaV0sXG5cdFx0XHRcdHNlZzIgPSBzZWcxLmdldE5leHQoKSxcblx0XHRcdFx0c2VnMyA9IHNlZ21lbnRzW2pdLFxuXHRcdFx0XHRzZWc0ID0gc2VnMy5nZXROZXh0KCk7XG5cdFx0XHRyZXR1cm4gc2VnMS5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzIuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0JiYgc2VnMy5faGFuZGxlT3V0LmlzWmVybygpICYmIHNlZzQuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0JiYgc2VnMi5fcG9pbnQuc3VidHJhY3Qoc2VnMS5fcG9pbnQpLmlzQ29sbGluZWFyKFxuXHRcdFx0XHRcdFx0c2VnNC5fcG9pbnQuc3VidHJhY3Qoc2VnMy5fcG9pbnQpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc09ydGhvZ29uYWwoaSkge1xuXHRcdFx0dmFyIHNlZzIgPSBzZWdtZW50c1tpXSxcblx0XHRcdFx0c2VnMSA9IHNlZzIuZ2V0UHJldmlvdXMoKSxcblx0XHRcdFx0c2VnMyA9IHNlZzIuZ2V0TmV4dCgpO1xuXHRcdFx0cmV0dXJuIHNlZzEuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWcyLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdCYmIHNlZzIuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWczLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdCYmIHNlZzIuX3BvaW50LnN1YnRyYWN0KHNlZzEuX3BvaW50KS5pc09ydGhvZ29uYWwoXG5cdFx0XHRcdFx0XHRzZWczLl9wb2ludC5zdWJ0cmFjdChzZWcyLl9wb2ludCkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGlzQXJjKGkpIHtcblx0XHRcdHZhciBzZWcxID0gc2VnbWVudHNbaV0sXG5cdFx0XHRcdHNlZzIgPSBzZWcxLmdldE5leHQoKSxcblx0XHRcdFx0aGFuZGxlMSA9IHNlZzEuX2hhbmRsZU91dCxcblx0XHRcdFx0aGFuZGxlMiA9IHNlZzIuX2hhbmRsZUluLFxuXHRcdFx0XHRrYXBwYSA9IDAuNTUyMjg0NzQ5ODMwNzkzNjtcblx0XHRcdGlmIChoYW5kbGUxLmlzT3J0aG9nb25hbChoYW5kbGUyKSkge1xuXHRcdFx0XHR2YXIgcHQxID0gc2VnMS5fcG9pbnQsXG5cdFx0XHRcdFx0cHQyID0gc2VnMi5fcG9pbnQsXG5cdFx0XHRcdFx0Y29ybmVyID0gbmV3IExpbmUocHQxLCBoYW5kbGUxLCB0cnVlKS5pbnRlcnNlY3QoXG5cdFx0XHRcdFx0XHRcdG5ldyBMaW5lKHB0MiwgaGFuZGxlMiwgdHJ1ZSksIHRydWUpO1xuXHRcdFx0XHRyZXR1cm4gY29ybmVyICYmIE51bWVyaWNhbC5pc1plcm8oaGFuZGxlMS5nZXRMZW5ndGgoKSAvXG5cdFx0XHRcdFx0XHRjb3JuZXIuc3VidHJhY3QocHQxKS5nZXRMZW5ndGgoKSAtIGthcHBhKVxuXHRcdFx0XHRcdCYmIE51bWVyaWNhbC5pc1plcm8oaGFuZGxlMi5nZXRMZW5ndGgoKSAvXG5cdFx0XHRcdFx0XHRjb3JuZXIuc3VidHJhY3QocHQyKS5nZXRMZW5ndGgoKSAtIGthcHBhKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXREaXN0YW5jZShpLCBqKSB7XG5cdFx0XHRyZXR1cm4gc2VnbWVudHNbaV0uX3BvaW50LmdldERpc3RhbmNlKHNlZ21lbnRzW2pdLl9wb2ludCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmhhc0hhbmRsZXMoKSAmJiBzZWdtZW50cy5sZW5ndGggPT09IDRcblx0XHRcdFx0JiYgaXNDb2xsaW5lYXIoMCwgMikgJiYgaXNDb2xsaW5lYXIoMSwgMykgJiYgaXNPcnRob2dvbmFsKDEpKSB7XG5cdFx0XHR0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDMpLCBnZXREaXN0YW5jZSgwLCAxKSk7XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1sxXS5fcG9pbnQuYWRkKHNlZ21lbnRzWzJdLl9wb2ludCkuZGl2aWRlKDIpO1xuXHRcdH0gZWxzZSBpZiAoc2VnbWVudHMubGVuZ3RoID09PSA4ICYmIGlzQXJjKDApICYmIGlzQXJjKDIpICYmIGlzQXJjKDQpXG5cdFx0XHRcdCYmIGlzQXJjKDYpICYmIGlzQ29sbGluZWFyKDEsIDUpICYmIGlzQ29sbGluZWFyKDMsIDcpKSB7XG5cdFx0XHR0eXBlID0gU2hhcGUuUmVjdGFuZ2xlO1xuXHRcdFx0c2l6ZSA9IG5ldyBTaXplKGdldERpc3RhbmNlKDEsIDYpLCBnZXREaXN0YW5jZSgwLCAzKSk7XG5cdFx0XHRyYWRpdXMgPSBzaXplLnN1YnRyYWN0KG5ldyBTaXplKGdldERpc3RhbmNlKDAsIDcpLFxuXHRcdFx0XHRcdGdldERpc3RhbmNlKDEsIDIpKSkuZGl2aWRlKDIpO1xuXHRcdFx0dG9wQ2VudGVyID0gc2VnbWVudHNbM10uX3BvaW50LmFkZChzZWdtZW50c1s0XS5fcG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gNFxuXHRcdFx0XHQmJiBpc0FyYygwKSAmJiBpc0FyYygxKSAmJiBpc0FyYygyKSAmJiBpc0FyYygzKSkge1xuXHRcdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oZ2V0RGlzdGFuY2UoMCwgMikgLSBnZXREaXN0YW5jZSgxLCAzKSkpIHtcblx0XHRcdFx0dHlwZSA9IFNoYXBlLkNpcmNsZTtcblx0XHRcdFx0cmFkaXVzID0gZ2V0RGlzdGFuY2UoMCwgMikgLyAyO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHlwZSA9IFNoYXBlLkVsbGlwc2U7XG5cdFx0XHRcdHJhZGl1cyA9IG5ldyBTaXplKGdldERpc3RhbmNlKDIsIDApIC8gMiwgZ2V0RGlzdGFuY2UoMywgMSkgLyAyKTtcblx0XHRcdH1cblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzFdLl9wb2ludDtcblx0XHR9XG5cblx0XHRpZiAodHlwZSkge1xuXHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSksXG5cdFx0XHRcdHNoYXBlID0gdGhpcy5fY2xvbmUobmV3IHR5cGUoe1xuXHRcdFx0XHRcdGNlbnRlcjogY2VudGVyLFxuXHRcdFx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRcdFx0cmFkaXVzOiByYWRpdXMsXG5cdFx0XHRcdFx0aW5zZXJ0OiBmYWxzZVxuXHRcdFx0XHR9KSwgaW5zZXJ0LCBmYWxzZSk7XG5cdFx0XHRzaGFwZS5yb3RhdGUodG9wQ2VudGVyLnN1YnRyYWN0KGNlbnRlcikuZ2V0QW5nbGUoKSArIDkwKTtcblx0XHRcdHJldHVybiBzaGFwZTtcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbihwb2ludCwgb3B0aW9ucykge1xuXHRcdHZhciB0aGF0ID0gdGhpcyxcblx0XHRcdHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0c2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdG51bVNlZ21lbnRzID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0Y2xvc2VkID0gdGhpcy5fY2xvc2VkLFxuXHRcdFx0dG9sZXJhbmNlUGFkZGluZyA9IG9wdGlvbnMuX3RvbGVyYW5jZVBhZGRpbmcsXG5cdFx0XHRzdHJva2VQYWRkaW5nID0gdG9sZXJhbmNlUGFkZGluZyxcblx0XHRcdGpvaW4sIGNhcCwgbWl0ZXJMaW1pdCxcblx0XHRcdGFyZWEsIGxvYywgcmVzLFxuXHRcdFx0aGl0U3Ryb2tlID0gb3B0aW9ucy5zdHJva2UgJiYgc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRoaXRGaWxsID0gb3B0aW9ucy5maWxsICYmIHN0eWxlLmhhc0ZpbGwoKSxcblx0XHRcdGhpdEN1cnZlcyA9IG9wdGlvbnMuY3VydmVzLFxuXHRcdFx0cmFkaXVzID0gaGl0U3Ryb2tlXG5cdFx0XHRcdFx0PyBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMlxuXHRcdFx0XHRcdDogaGl0RmlsbCAmJiBvcHRpb25zLnRvbGVyYW5jZSA+IDAgfHwgaGl0Q3VydmVzXG5cdFx0XHRcdFx0XHQ/IDAgOiBudWxsO1xuXHRcdGlmIChyYWRpdXMgIT09IG51bGwpIHtcblx0XHRcdGlmIChyYWRpdXMgPiAwKSB7XG5cdFx0XHRcdGpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCk7XG5cdFx0XHRcdGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpO1xuXHRcdFx0XHRtaXRlckxpbWl0ID0gcmFkaXVzICogc3R5bGUuZ2V0TWl0ZXJMaW1pdCgpO1xuXHRcdFx0XHRzdHJva2VQYWRkaW5nID0gdG9sZXJhbmNlUGFkZGluZy5hZGQobmV3IFBvaW50KHJhZGl1cywgcmFkaXVzKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRqb2luID0gY2FwID0gJ3JvdW5kJztcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0Nsb3NlRW5vdWdoKHB0LCBwYWRkaW5nKSB7XG5cdFx0XHRyZXR1cm4gcG9pbnQuc3VidHJhY3QocHQpLmRpdmlkZShwYWRkaW5nKS5sZW5ndGggPD0gMTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRQb2ludChzZWcsIHB0LCBuYW1lKSB7XG5cdFx0XHRpZiAoIW9wdGlvbnMuc2VsZWN0ZWQgfHwgcHQuaXNTZWxlY3RlZCgpKSB7XG5cdFx0XHRcdHZhciBhbmNob3IgPSBzZWcuX3BvaW50O1xuXHRcdFx0XHRpZiAocHQgIT09IGFuY2hvcilcblx0XHRcdFx0XHRwdCA9IHB0LmFkZChhbmNob3IpO1xuXHRcdFx0XHRpZiAoaXNDbG9zZUVub3VnaChwdCwgc3Ryb2tlUGFkZGluZykpIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEhpdFJlc3VsdChuYW1lLCB0aGF0LCB7XG5cdFx0XHRcdFx0XHRzZWdtZW50OiBzZWcsXG5cdFx0XHRcdFx0XHRwb2ludDogcHRcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFBvaW50cyhzZWcsIGVuZHMpIHtcblx0XHRcdHJldHVybiAoZW5kcyB8fCBvcHRpb25zLnNlZ21lbnRzKVxuXHRcdFx0XHQmJiBjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5fcG9pbnQsICdzZWdtZW50Jylcblx0XHRcdFx0fHwgKCFlbmRzICYmIG9wdGlvbnMuaGFuZGxlcykgJiYgKFxuXHRcdFx0XHRcdGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9oYW5kbGVJbiwgJ2hhbmRsZS1pbicpIHx8XG5cdFx0XHRcdFx0Y2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX2hhbmRsZU91dCwgJ2hhbmRsZS1vdXQnKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkVG9BcmVhKHBvaW50KSB7XG5cdFx0XHRhcmVhLmFkZChwb2ludCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50U3Ryb2tlKHNlZ21lbnQpIHtcblx0XHRcdGlmIChqb2luICE9PSAncm91bmQnIHx8IGNhcCAhPT0gJ3JvdW5kJykge1xuXHRcdFx0XHRhcmVhID0gbmV3IFBhdGgoeyBpbnRlcm5hbDogdHJ1ZSwgY2xvc2VkOiB0cnVlIH0pO1xuXHRcdFx0XHRpZiAoY2xvc2VkIHx8IHNlZ21lbnQuX2luZGV4ID4gMFxuXHRcdFx0XHRcdFx0JiYgc2VnbWVudC5faW5kZXggPCBudW1TZWdtZW50cyAtIDEpIHtcblx0XHRcdFx0XHRpZiAoam9pbiAhPT0gJ3JvdW5kJyAmJiAoc2VnbWVudC5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHRcdFx0fHwgc2VnbWVudC5faGFuZGxlT3V0LmlzWmVybygpKSlcblx0XHRcdFx0XHRcdFBhdGguX2FkZEJldmVsSm9pbihzZWdtZW50LCBqb2luLCByYWRpdXMsIG1pdGVyTGltaXQsXG5cdFx0XHRcdFx0XHRcdFx0YWRkVG9BcmVhLCB0cnVlKTtcblx0XHRcdFx0fSBlbHNlIGlmIChjYXAgIT09ICdyb3VuZCcpIHtcblx0XHRcdFx0XHRQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCByYWRpdXMsIGFkZFRvQXJlYSwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFhcmVhLmlzRW1wdHkoKSkge1xuXHRcdFx0XHRcdHZhciBsb2M7XG5cdFx0XHRcdFx0cmV0dXJuIGFyZWEuY29udGFpbnMocG9pbnQpXG5cdFx0XHRcdFx0XHR8fCAobG9jID0gYXJlYS5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpKVxuXHRcdFx0XHRcdFx0XHQmJiBpc0Nsb3NlRW5vdWdoKGxvYy5nZXRQb2ludCgpLCB0b2xlcmFuY2VQYWRkaW5nKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGlzQ2xvc2VFbm91Z2goc2VnbWVudC5fcG9pbnQsIHN0cm9rZVBhZGRpbmcpO1xuXHRcdH1cblxuXHRcdGlmIChvcHRpb25zLmVuZHMgJiYgIW9wdGlvbnMuc2VnbWVudHMgJiYgIWNsb3NlZCkge1xuXHRcdFx0aWYgKHJlcyA9IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1swXSwgdHJ1ZSlcblx0XHRcdFx0XHR8fCBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbbnVtU2VnbWVudHMgLSAxXSwgdHJ1ZSkpXG5cdFx0XHRcdHJldHVybiByZXM7XG5cdFx0fSBlbHNlIGlmIChvcHRpb25zLnNlZ21lbnRzIHx8IG9wdGlvbnMuaGFuZGxlcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKVxuXHRcdFx0XHRpZiAocmVzID0gY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzW2ldKSlcblx0XHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH1cblx0XHRpZiAocmFkaXVzICE9PSBudWxsKSB7XG5cdFx0XHRsb2MgPSB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbihwb2ludCk7XG5cdFx0XHRpZiAobG9jKSB7XG5cdFx0XHRcdHZhciBwYXJhbWV0ZXIgPSBsb2MuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0XHRcdGlmIChwYXJhbWV0ZXIgPT09IDAgfHwgcGFyYW1ldGVyID09PSAxICYmIG51bVNlZ21lbnRzID4gMSkge1xuXHRcdFx0XHRcdGlmICghY2hlY2tTZWdtZW50U3Ryb2tlKGxvYy5nZXRTZWdtZW50KCkpKVxuXHRcdFx0XHRcdFx0bG9jID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIGlmICghaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgc3Ryb2tlUGFkZGluZykpIHtcblx0XHRcdFx0XHRsb2MgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoIWxvYyAmJiBqb2luID09PSAnbWl0ZXInICYmIG51bVNlZ21lbnRzID4gMSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG51bVNlZ21lbnRzOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0XHRcdGlmIChwb2ludC5nZXREaXN0YW5jZShzZWdtZW50Ll9wb2ludCkgPD0gbWl0ZXJMaW1pdFxuXHRcdFx0XHRcdFx0XHQmJiBjaGVja1NlZ21lbnRTdHJva2Uoc2VnbWVudCkpIHtcblx0XHRcdFx0XHRcdGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKTtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gIWxvYyAmJiBoaXRGaWxsICYmIHRoaXMuX2NvbnRhaW5zKHBvaW50KVxuXHRcdFx0XHR8fCBsb2MgJiYgIWhpdFN0cm9rZSAmJiAhaGl0Q3VydmVzXG5cdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KCdmaWxsJywgdGhpcylcblx0XHRcdFx0XHQ6IGxvY1xuXHRcdFx0XHRcdFx0PyBuZXcgSGl0UmVzdWx0KGhpdFN0cm9rZSA/ICdzdHJva2UnIDogJ2N1cnZlJywgdGhpcywge1xuXHRcdFx0XHRcdFx0XHRsb2NhdGlvbjogbG9jLFxuXHRcdFx0XHRcdFx0XHRwb2ludDogbG9jLmdldFBvaW50KClcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQ6IG51bGw7XG5cdH1cblxufSwgQmFzZS5lYWNoKEN1cnZlLmV2YWx1YXRlTWV0aG9kcyxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25BdChvZmZzZXQsIGlzUGFyYW1ldGVyKTtcblx0XHRcdHJldHVybiBsb2MgJiYgbG9jW25hbWVdKCk7XG5cdFx0fTtcblx0fSxcbntcblx0YmVhbnM6IGZhbHNlLFxuXG5cdGdldExvY2F0aW9uT2Y6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgbG9jID0gY3VydmVzW2ldLmdldExvY2F0aW9uT2YocG9pbnQpO1xuXHRcdFx0aWYgKGxvYylcblx0XHRcdFx0cmV0dXJuIGxvYztcblx0XHR9XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0T2Y6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uT2YuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbG9jID8gbG9jLmdldE9mZnNldCgpIDogbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbkF0OiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRsZW5ndGggPSAwO1xuXHRcdGlmIChpc1BhcmFtZXRlcikge1xuXHRcdFx0dmFyIGluZGV4ID0gfn5vZmZzZXQsXG5cdFx0XHRcdGN1cnZlID0gY3VydmVzW2luZGV4XTtcblx0XHRcdHJldHVybiBjdXJ2ZSA/IGN1cnZlLmdldExvY2F0aW9uQXQob2Zmc2V0IC0gaW5kZXgsIHRydWUpIDogbnVsbDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc3RhcnQgPSBsZW5ndGgsXG5cdFx0XHRcdGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0bGVuZ3RoICs9IGN1cnZlLmdldExlbmd0aCgpO1xuXHRcdFx0aWYgKGxlbmd0aCA+IG9mZnNldCkge1xuXHRcdFx0XHRyZXR1cm4gY3VydmUuZ2V0TG9jYXRpb25BdChvZmZzZXQgLSBzdGFydCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZXMubGVuZ3RoID4gMCAmJiBvZmZzZXQgPD0gdGhpcy5nZXRMZW5ndGgoKSlcblx0XHRcdHJldHVybiBuZXcgQ3VydmVMb2NhdGlvbihjdXJ2ZXNbY3VydmVzLmxlbmd0aCAtIDFdLCAxKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXROZWFyZXN0TG9jYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRtaW5EaXN0ID0gSW5maW5pdHksXG5cdFx0XHRtaW5Mb2MgPSBudWxsO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGxvYyA9IGN1cnZlc1tpXS5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpO1xuXHRcdFx0aWYgKGxvYy5fZGlzdGFuY2UgPCBtaW5EaXN0KSB7XG5cdFx0XHRcdG1pbkRpc3QgPSBsb2MuX2Rpc3RhbmNlO1xuXHRcdFx0XHRtaW5Mb2MgPSBsb2M7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtaW5Mb2M7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24uYXBwbHkodGhpcywgYXJndW1lbnRzKS5nZXRQb2ludCgpO1xuXHR9XG59KSxcbm5ldyBmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBkcmF3SGFuZGxlcyhjdHgsIHNlZ21lbnRzLCBtYXRyaXgsIHNpemUpIHtcblx0XHR2YXIgaGFsZiA9IHNpemUgLyAyO1xuXG5cdFx0ZnVuY3Rpb24gZHJhd0hhbmRsZShpbmRleCkge1xuXHRcdFx0dmFyIGhYID0gY29vcmRzW2luZGV4XSxcblx0XHRcdFx0aFkgPSBjb29yZHNbaW5kZXggKyAxXTtcblx0XHRcdGlmIChwWCAhPSBoWCB8fCBwWSAhPSBoWSkge1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5tb3ZlVG8ocFgsIHBZKTtcblx0XHRcdFx0Y3R4LmxpbmVUbyhoWCwgaFkpO1xuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0Y3R4LmFyYyhoWCwgaFksIGhhbGYsIDAsIE1hdGguUEkgKiAyLCB0cnVlKTtcblx0XHRcdFx0Y3R4LmZpbGwoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcblx0XHRcdHZhciBzdGF0ZSA9IHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlLFxuXHRcdFx0XHRwWCA9IGNvb3Jkc1swXSxcblx0XHRcdFx0cFkgPSBjb29yZHNbMV07XG5cdFx0XHRpZiAoc3RhdGUgJiAxKVxuXHRcdFx0XHRkcmF3SGFuZGxlKDIpO1xuXHRcdFx0aWYgKHN0YXRlICYgMilcblx0XHRcdFx0ZHJhd0hhbmRsZSg0KTtcblx0XHRcdGN0eC5maWxsUmVjdChwWCAtIGhhbGYsIHBZIC0gaGFsZiwgc2l6ZSwgc2l6ZSk7XG5cdFx0XHRpZiAoIShzdGF0ZSAmIDQpKSB7XG5cdFx0XHRcdHZhciBmaWxsU3R5bGUgPSBjdHguZmlsbFN0eWxlO1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gJyNmZmZmZmYnO1xuXHRcdFx0XHRjdHguZmlsbFJlY3QocFggLSBoYWxmICsgMSwgcFkgLSBoYWxmICsgMSwgc2l6ZSAtIDIsIHNpemUgLSAyKTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGZpbGxTdHlsZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkcmF3U2VnbWVudHMoY3R4LCBwYXRoLCBtYXRyaXgpIHtcblx0XHR2YXIgc2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdGZpcnN0ID0gdHJ1ZSxcblx0XHRcdGN1clgsIGN1clksXG5cdFx0XHRwcmV2WCwgcHJldlksXG5cdFx0XHRpblgsIGluWSxcblx0XHRcdG91dFgsIG91dFk7XG5cblx0XHRmdW5jdGlvbiBkcmF3U2VnbWVudChzZWdtZW50KSB7XG5cdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRcdGN1clggPSBjb29yZHNbMF07XG5cdFx0XHRcdGN1clkgPSBjb29yZHNbMV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludDtcblx0XHRcdFx0Y3VyWCA9IHBvaW50Ll94O1xuXHRcdFx0XHRjdXJZID0gcG9pbnQuX3k7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZmlyc3QpIHtcblx0XHRcdFx0Y3R4Lm1vdmVUbyhjdXJYLCBjdXJZKTtcblx0XHRcdFx0Zmlyc3QgPSBmYWxzZTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdFx0aW5ZID0gY29vcmRzWzNdO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVJbjtcblx0XHRcdFx0XHRpblggPSBjdXJYICsgaGFuZGxlLl94O1xuXHRcdFx0XHRcdGluWSA9IGN1clkgKyBoYW5kbGUuX3k7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0Y3R4LmxpbmVUbyhjdXJYLCBjdXJZKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhvdXRYLCBvdXRZLCBpblgsIGluWSwgY3VyWCwgY3VyWSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHByZXZYID0gY3VyWDtcblx0XHRcdHByZXZZID0gY3VyWTtcblx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0b3V0WCA9IGNvb3Jkc1s0XTtcblx0XHRcdFx0b3V0WSA9IGNvb3Jkc1s1XTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBoYW5kbGUgPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRcdG91dFggPSBwcmV2WCArIGhhbmRsZS5feDtcblx0XHRcdFx0b3V0WSA9IHByZXZZICsgaGFuZGxlLl95O1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRkcmF3U2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKHBhdGguX2Nsb3NlZCAmJiBsZW5ndGggPiAwKVxuXHRcdFx0ZHJhd1NlZ21lbnQoc2VnbWVudHNbMF0pO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgc3Ryb2tlTWF0cml4KSB7XG5cdFx0XHR2YXIgZG9udFN0YXJ0ID0gcGFyYW0uZG9udFN0YXJ0LFxuXHRcdFx0XHRkb250UGFpbnQgPSBwYXJhbS5kb250RmluaXNoIHx8IHBhcmFtLmNsaXAsXG5cdFx0XHRcdHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0XHRoYXNGaWxsID0gc3R5bGUuaGFzRmlsbCgpLFxuXHRcdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdFx0ZGFzaEFycmF5ID0gc3R5bGUuZ2V0RGFzaEFycmF5KCksXG5cdFx0XHRcdGRhc2hMZW5ndGggPSAhcGFwZXIuc3VwcG9ydC5uYXRpdmVEYXNoICYmIGhhc1N0cm9rZVxuXHRcdFx0XHRcdFx0JiYgZGFzaEFycmF5ICYmIGRhc2hBcnJheS5sZW5ndGg7XG5cblx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cblx0XHRcdGlmICghZG9udFN0YXJ0ICYmIHRoaXMuX2N1cnJlbnRQYXRoKSB7XG5cdFx0XHRcdGN0eC5jdXJyZW50UGF0aCA9IHRoaXMuX2N1cnJlbnRQYXRoO1xuXHRcdFx0fSBlbHNlIGlmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSAmJiAhZGFzaExlbmd0aCB8fCBkb250UGFpbnQpIHtcblx0XHRcdFx0ZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgc3Ryb2tlTWF0cml4KTtcblx0XHRcdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdFx0XHRjdHguY2xvc2VQYXRoKCk7XG5cdFx0XHRcdGlmICghZG9udFN0YXJ0KVxuXHRcdFx0XHRcdHRoaXMuX2N1cnJlbnRQYXRoID0gY3R4LmN1cnJlbnRQYXRoO1xuXHRcdFx0fVxuXG5cdFx0XHRmdW5jdGlvbiBnZXRPZmZzZXQoaSkge1xuXHRcdFx0XHRyZXR1cm4gZGFzaEFycmF5WygoaSAlIGRhc2hMZW5ndGgpICsgZGFzaExlbmd0aCkgJSBkYXNoTGVuZ3RoXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCFkb250UGFpbnQgJiYgKGhhc0ZpbGwgfHwgaGFzU3Ryb2tlKSkge1xuXHRcdFx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4KTtcblx0XHRcdFx0aWYgKGhhc0ZpbGwpIHtcblx0XHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRXaW5kaW5nUnVsZSgpKTtcblx0XHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGhhc1N0cm9rZSkge1xuXHRcdFx0XHRcdGlmIChkYXNoTGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRcdFx0dmFyIGl0ZXJhdG9yID0gbmV3IFBhdGhJdGVyYXRvcih0aGlzLCAzMiwgMC4yNSxcblx0XHRcdFx0XHRcdFx0XHRzdHJva2VNYXRyaXgpLFxuXHRcdFx0XHRcdFx0XHRsZW5ndGggPSBpdGVyYXRvci5sZW5ndGgsXG5cdFx0XHRcdFx0XHRcdGZyb20gPSAtc3R5bGUuZ2V0RGFzaE9mZnNldCgpLCB0byxcblx0XHRcdFx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdFx0XHRmcm9tID0gZnJvbSAlIGxlbmd0aDtcblx0XHRcdFx0XHRcdHdoaWxlIChmcm9tID4gMCkge1xuXHRcdFx0XHRcdFx0XHRmcm9tIC09IGdldE9mZnNldChpLS0pICsgZ2V0T2Zmc2V0KGktLSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR3aGlsZSAoZnJvbSA8IGxlbmd0aCkge1xuXHRcdFx0XHRcdFx0XHR0byA9IGZyb20gKyBnZXRPZmZzZXQoaSsrKTtcblx0XHRcdFx0XHRcdFx0aWYgKGZyb20gPiAwIHx8IHRvID4gMClcblx0XHRcdFx0XHRcdFx0XHRpdGVyYXRvci5kcmF3UGFydChjdHgsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdE1hdGgubWF4KGZyb20sIDApLCBNYXRoLm1heCh0bywgMCkpO1xuXHRcdFx0XHRcdFx0XHRmcm9tID0gdG8gKyBnZXRPZmZzZXQoaSsrKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9kcmF3U2VsZWN0ZWQ6IGZ1bmN0aW9uKGN0eCwgbWF0cml4KSB7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRkcmF3U2VnbWVudHMoY3R4LCB0aGlzLCBtYXRyaXgpO1xuXHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0ZHJhd0hhbmRsZXMoY3R4LCB0aGlzLl9zZWdtZW50cywgbWF0cml4LCBwYXBlci5zZXR0aW5ncy5oYW5kbGVTaXplKTtcblx0XHR9XG5cdH07XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBnZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKSB7XG5cdFx0dmFyIG4gPSByaHMubGVuZ3RoLFxuXHRcdFx0eCA9IFtdLFxuXHRcdFx0dG1wID0gW10sXG5cdFx0XHRiID0gMjtcblx0XHR4WzBdID0gcmhzWzBdIC8gYjtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8IG47IGkrKykge1xuXHRcdFx0dG1wW2ldID0gMSAvIGI7XG5cdFx0XHRiID0gKGkgPCBuIC0gMSA/IDQgOiAyKSAtIHRtcFtpXTtcblx0XHRcdHhbaV0gPSAocmhzW2ldIC0geFtpIC0gMV0pIC8gYjtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcblx0XHRcdHhbbiAtIGkgLSAxXSAtPSB0bXBbbiAtIGldICogeFtuIC0gaV07XG5cdFx0fVxuXHRcdHJldHVybiB4O1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRzbW9vdGg6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRcdHNpemUgPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRcdGNsb3NlZCA9IHRoaXMuX2Nsb3NlZCxcblx0XHRcdFx0biA9IHNpemUsXG5cdFx0XHRcdG92ZXJsYXAgPSAwO1xuXHRcdFx0aWYgKHNpemUgPD0gMilcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRvdmVybGFwID0gTWF0aC5taW4oc2l6ZSwgNCk7XG5cdFx0XHRcdG4gKz0gTWF0aC5taW4oc2l6ZSwgb3ZlcmxhcCkgKiAyO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGtub3RzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IHNpemU7IGkrKylcblx0XHRcdFx0a25vdHNbaSArIG92ZXJsYXBdID0gc2VnbWVudHNbaV0uX3BvaW50O1xuXHRcdFx0aWYgKGNsb3NlZCkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG92ZXJsYXA7IGkrKykge1xuXHRcdFx0XHRcdGtub3RzW2ldID0gc2VnbWVudHNbaSArIHNpemUgLSBvdmVybGFwXS5fcG9pbnQ7XG5cdFx0XHRcdFx0a25vdHNbaSArIHNpemUgKyBvdmVybGFwXSA9IHNlZ21lbnRzW2ldLl9wb2ludDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bi0tO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHJocyA9IFtdO1xuXG5cdFx0XHRmb3IgKHZhciBpID0gMTsgaSA8IG4gLSAxOyBpKyspXG5cdFx0XHRcdHJoc1tpXSA9IDQgKiBrbm90c1tpXS5feCArIDIgKiBrbm90c1tpICsgMV0uX3g7XG5cdFx0XHRyaHNbMF0gPSBrbm90c1swXS5feCArIDIgKiBrbm90c1sxXS5feDtcblx0XHRcdHJoc1tuIC0gMV0gPSAzICoga25vdHNbbiAtIDFdLl94O1xuXHRcdFx0dmFyIHggPSBnZXRGaXJzdENvbnRyb2xQb2ludHMocmhzKTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBuIC0gMTsgaSsrKVxuXHRcdFx0XHRyaHNbaV0gPSA0ICoga25vdHNbaV0uX3kgKyAyICoga25vdHNbaSArIDFdLl95O1xuXHRcdFx0cmhzWzBdID0ga25vdHNbMF0uX3kgKyAyICoga25vdHNbMV0uX3k7XG5cdFx0XHRyaHNbbiAtIDFdID0gMyAqIGtub3RzW24gLSAxXS5feTtcblx0XHRcdHZhciB5ID0gZ2V0Rmlyc3RDb250cm9sUG9pbnRzKHJocyk7XG5cblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGogPSBzaXplOyBpIDwgb3ZlcmxhcDsgaSsrLCBqKyspIHtcblx0XHRcdFx0XHR2YXIgZjEgPSBpIC8gb3ZlcmxhcCxcblx0XHRcdFx0XHRcdGYyID0gMSAtIGYxLFxuXHRcdFx0XHRcdFx0aWUgPSBpICsgb3ZlcmxhcCxcblx0XHRcdFx0XHRcdGplID0gaiArIG92ZXJsYXA7XG5cdFx0XHRcdFx0eFtqXSA9IHhbaV0gKiBmMSArIHhbal0gKiBmMjtcblx0XHRcdFx0XHR5W2pdID0geVtpXSAqIGYxICsgeVtqXSAqIGYyO1xuXHRcdFx0XHRcdHhbamVdID0geFtpZV0gKiBmMiArIHhbamVdICogZjE7XG5cdFx0XHRcdFx0eVtqZV0gPSB5W2llXSAqIGYyICsgeVtqZV0gKiBmMTtcblx0XHRcdFx0fVxuXHRcdFx0XHRuLS07XG5cdFx0XHR9XG5cdFx0XHR2YXIgaGFuZGxlSW4gPSBudWxsO1xuXHRcdFx0Zm9yICh2YXIgaSA9IG92ZXJsYXA7IGkgPD0gbiAtIG92ZXJsYXA7IGkrKykge1xuXHRcdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2kgLSBvdmVybGFwXTtcblx0XHRcdFx0aWYgKGhhbmRsZUluKVxuXHRcdFx0XHRcdHNlZ21lbnQuc2V0SGFuZGxlSW4oaGFuZGxlSW4uc3VidHJhY3Qoc2VnbWVudC5fcG9pbnQpKTtcblx0XHRcdFx0aWYgKGkgPCBuKSB7XG5cdFx0XHRcdFx0c2VnbWVudC5zZXRIYW5kbGVPdXQoXG5cdFx0XHRcdFx0XHRcdG5ldyBQb2ludCh4W2ldLCB5W2ldKS5zdWJ0cmFjdChzZWdtZW50Ll9wb2ludCkpO1xuXHRcdFx0XHRcdGhhbmRsZUluID0gaSA8IG4gLSAxXG5cdFx0XHRcdFx0XHRcdD8gbmV3IFBvaW50KFxuXHRcdFx0XHRcdFx0XHRcdDIgKiBrbm90c1tpICsgMV0uX3ggLSB4W2kgKyAxXSxcblx0XHRcdFx0XHRcdFx0XHQyICoga25vdHNbaSArIDFdLl95IC0geVtpICsgMV0pXG5cdFx0XHRcdFx0XHRcdDogbmV3IFBvaW50KFxuXHRcdFx0XHRcdFx0XHRcdChrbm90c1tuXS5feCArIHhbbiAtIDFdKSAvIDIsXG5cdFx0XHRcdFx0XHRcdFx0KGtub3RzW25dLl95ICsgeVtuIC0gMV0pIC8gMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChjbG9zZWQgJiYgaGFuZGxlSW4pIHtcblx0XHRcdFx0dmFyIHNlZ21lbnQgPSB0aGlzLl9zZWdtZW50c1swXTtcblx0XHRcdFx0c2VnbWVudC5zZXRIYW5kbGVJbihoYW5kbGVJbi5zdWJ0cmFjdChzZWdtZW50Ll9wb2ludCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0fTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRTZWdtZW50KHRoYXQpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGF0Ll9zZWdtZW50cztcblx0XHRpZiAoc2VnbWVudHMubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVc2UgYSBtb3ZlVG8oKSBjb21tYW5kIGZpcnN0Jyk7XG5cdFx0cmV0dXJuIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRtb3ZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0XHRpZiAoc2VnbWVudHMubGVuZ3RoID09PSAxKVxuXHRcdFx0XHR0aGlzLnJlbW92ZVNlZ21lbnQoMCk7XG5cdFx0XHRpZiAoIXNlZ21lbnRzLmxlbmd0aClcblx0XHRcdFx0dGhpcy5fYWRkKFsgbmV3IFNlZ21lbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKSBdKTtcblx0XHR9LFxuXG5cdFx0bW92ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHRocm93IG5ldyBFcnJvcignbW92ZUJ5KCkgaXMgdW5zdXBwb3J0ZWQgb24gUGF0aCBpdGVtcy4nKTtcblx0XHR9LFxuXG5cdFx0bGluZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSkgXSk7XG5cdFx0fSxcblxuXHRcdGN1YmljQ3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlMSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0aGFuZGxlMiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKTtcblx0XHRcdGN1cnJlbnQuc2V0SGFuZGxlT3V0KGhhbmRsZTEuc3VidHJhY3QoY3VycmVudC5fcG9pbnQpKTtcblx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KHRvLCBoYW5kbGUyLnN1YnRyYWN0KHRvKSkgXSk7XG5cdFx0fSxcblxuXHRcdHF1YWRyYXRpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0aGFuZGxlLmFkZChjdXJyZW50LnN1YnRyYWN0KGhhbmRsZSkubXVsdGlwbHkoMSAvIDMpKSxcblx0XHRcdFx0aGFuZGxlLmFkZCh0by5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksXG5cdFx0XHRcdHRvXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRjdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0aHJvdWdoID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dCA9IEJhc2UucGljayhCYXNlLnJlYWQoYXJndW1lbnRzKSwgMC41KSxcblx0XHRcdFx0dDEgPSAxIC0gdCxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludCxcblx0XHRcdFx0aGFuZGxlID0gdGhyb3VnaC5zdWJ0cmFjdChjdXJyZW50Lm11bHRpcGx5KHQxICogdDEpKVxuXHRcdFx0XHRcdC5zdWJ0cmFjdCh0by5tdWx0aXBseSh0ICogdCkpLmRpdmlkZSgyICogdCAqIHQxKTtcblx0XHRcdGlmIChoYW5kbGUuaXNOYU4oKSlcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdDYW5ub3QgcHV0IGEgY3VydmUgdGhyb3VnaCBwb2ludHMgd2l0aCBwYXJhbWV0ZXIgPSAnICsgdCk7XG5cdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oaGFuZGxlLCB0byk7XG5cdFx0fSxcblxuXHRcdGFyY1RvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyksXG5cdFx0XHRcdGZyb20gPSBjdXJyZW50Ll9wb2ludCxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRocm91Z2gsXG5cdFx0XHRcdHBlZWsgPSBCYXNlLnBlZWsoYXJndW1lbnRzKSxcblx0XHRcdFx0Y2xvY2t3aXNlID0gQmFzZS5waWNrKHBlZWssIHRydWUpLFxuXHRcdFx0XHRjZW50ZXIsIGV4dGVudCwgdmVjdG9yLCBtYXRyaXg7XG5cdFx0XHRpZiAodHlwZW9mIGNsb2Nrd2lzZSA9PT0gJ2Jvb2xlYW4nKSB7XG5cdFx0XHRcdHZhciBtaWRkbGUgPSBmcm9tLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHR0aHJvdWdoID0gbWlkZGxlLmFkZChtaWRkbGUuc3VidHJhY3QoZnJvbSkucm90YXRlKFxuXHRcdFx0XHRcdFx0Y2xvY2t3aXNlID8gLTkwIDogOTApKTtcblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5yZW1haW4oYXJndW1lbnRzKSA8PSAyKSB7XG5cdFx0XHRcdHRocm91Z2ggPSB0bztcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcmFkaXVzID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdGlmIChyYWRpdXMuaXNaZXJvKCkpXG5cdFx0XHRcdFx0cmV0dXJuIHRoaXMubGluZVRvKHRvKTtcblx0XHRcdFx0dmFyIHJvdGF0aW9uID0gQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0Y2xvY2t3aXNlID0gISFCYXNlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0XHRsYXJnZSA9ICEhQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0bWlkZGxlID0gZnJvbS5hZGQodG8pLmRpdmlkZSgyKSxcblx0XHRcdFx0XHRwdCA9IGZyb20uc3VidHJhY3QobWlkZGxlKS5yb3RhdGUoLXJvdGF0aW9uKSxcblx0XHRcdFx0XHR4ID0gcHQueCxcblx0XHRcdFx0XHR5ID0gcHQueSxcblx0XHRcdFx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRcdFx0XHRyeCA9IGFicyhyYWRpdXMud2lkdGgpLFxuXHRcdFx0XHRcdHJ5ID0gYWJzKHJhZGl1cy5oZWlnaHQpLFxuXHRcdFx0XHRcdHJ4U3EgPSByeCAqIHJ4LFxuXHRcdFx0XHRcdHJ5U3EgPSByeSAqIHJ5LFxuXHRcdFx0XHRcdHhTcSA9ICB4ICogeCxcblx0XHRcdFx0XHR5U3EgPSAgeSAqIHk7XG5cdFx0XHRcdHZhciBmYWN0b3IgPSBNYXRoLnNxcnQoeFNxIC8gcnhTcSArIHlTcSAvIHJ5U3EpO1xuXHRcdFx0XHRpZiAoZmFjdG9yID4gMSkge1xuXHRcdFx0XHRcdHJ4ICo9IGZhY3Rvcjtcblx0XHRcdFx0XHRyeSAqPSBmYWN0b3I7XG5cdFx0XHRcdFx0cnhTcSA9IHJ4ICogcng7XG5cdFx0XHRcdFx0cnlTcSA9IHJ5ICogcnk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZmFjdG9yID0gKHJ4U3EgKiByeVNxIC0gcnhTcSAqIHlTcSAtIHJ5U3EgKiB4U3EpIC9cblx0XHRcdFx0XHRcdChyeFNxICogeVNxICsgcnlTcSAqIHhTcSk7XG5cdFx0XHRcdGlmIChhYnMoZmFjdG9yKSA8IDFlLTEyKVxuXHRcdFx0XHRcdGZhY3RvciA9IDA7XG5cdFx0XHRcdGlmIChmYWN0b3IgPCAwKVxuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuXHRcdFx0XHRjZW50ZXIgPSBuZXcgUG9pbnQocnggKiB5IC8gcnksIC1yeSAqIHggLyByeClcblx0XHRcdFx0XHRcdC5tdWx0aXBseSgobGFyZ2UgPT09IGNsb2Nrd2lzZSA/IC0xIDogMSlcblx0XHRcdFx0XHRcdFx0KiBNYXRoLnNxcnQoZmFjdG9yKSlcblx0XHRcdFx0XHRcdC5yb3RhdGUocm90YXRpb24pLmFkZChtaWRkbGUpO1xuXHRcdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCkudHJhbnNsYXRlKGNlbnRlcikucm90YXRlKHJvdGF0aW9uKVxuXHRcdFx0XHRcdFx0LnNjYWxlKHJ4LCByeSk7XG5cdFx0XHRcdHZlY3RvciA9IG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShmcm9tKTtcblx0XHRcdFx0ZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUobWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHRvKSk7XG5cdFx0XHRcdGlmICghY2xvY2t3aXNlICYmIGV4dGVudCA+IDApXG5cdFx0XHRcdFx0ZXh0ZW50IC09IDM2MDtcblx0XHRcdFx0ZWxzZSBpZiAoY2xvY2t3aXNlICYmIGV4dGVudCA8IDApXG5cdFx0XHRcdFx0ZXh0ZW50ICs9IDM2MDtcblx0XHRcdH1cblx0XHRcdGlmICh0aHJvdWdoKSB7XG5cdFx0XHRcdHZhciBsMSA9IG5ldyBMaW5lKGZyb20uYWRkKHRocm91Z2gpLmRpdmlkZSgyKSxcblx0XHRcdFx0XHRcdFx0dGhyb3VnaC5zdWJ0cmFjdChmcm9tKS5yb3RhdGUoOTApLCB0cnVlKSxcblx0XHRcdFx0XHRsMiA9IG5ldyBMaW5lKHRocm91Z2guYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0XHRcdHRvLnN1YnRyYWN0KHRocm91Z2gpLnJvdGF0ZSg5MCksIHRydWUpLFxuXHRcdFx0XHRcdGxpbmUgPSBuZXcgTGluZShmcm9tLCB0byksXG5cdFx0XHRcdFx0dGhyb3VnaFNpZGUgPSBsaW5lLmdldFNpZGUodGhyb3VnaCk7XG5cdFx0XHRcdGNlbnRlciA9IGwxLmludGVyc2VjdChsMiwgdHJ1ZSk7XG5cdFx0XHRcdGlmICghY2VudGVyKSB7XG5cdFx0XHRcdFx0aWYgKCF0aHJvdWdoU2lkZSlcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzLmxpbmVUbyh0byk7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdFx0XHQnQ2Fubm90IGNyZWF0ZSBhbiBhcmMgd2l0aCB0aGUgZ2l2ZW4gYXJndW1lbnRzJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmVjdG9yID0gZnJvbS5zdWJ0cmFjdChjZW50ZXIpO1xuXHRcdFx0XHRleHRlbnQgPSB2ZWN0b3IuZ2V0RGlyZWN0ZWRBbmdsZSh0by5zdWJ0cmFjdChjZW50ZXIpKTtcblx0XHRcdFx0dmFyIGNlbnRlclNpZGUgPSBsaW5lLmdldFNpZGUoY2VudGVyKTtcblx0XHRcdFx0aWYgKGNlbnRlclNpZGUgPT09IDApIHtcblx0XHRcdFx0XHRleHRlbnQgPSB0aHJvdWdoU2lkZSAqIE1hdGguYWJzKGV4dGVudCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAodGhyb3VnaFNpZGUgPT09IGNlbnRlclNpZGUpIHtcblx0XHRcdFx0XHRleHRlbnQgKz0gZXh0ZW50IDwgMCA/IDM2MCA6IC0zNjA7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhciBleHQgPSBNYXRoLmFicyhleHRlbnQpLFxuXHRcdFx0XHRjb3VudCA9IGV4dCA+PSAzNjAgPyA0IDogTWF0aC5jZWlsKGV4dCAvIDkwKSxcblx0XHRcdFx0aW5jID0gZXh0ZW50IC8gY291bnQsXG5cdFx0XHRcdGhhbGYgPSBpbmMgKiBNYXRoLlBJIC8gMzYwLFxuXHRcdFx0XHR6ID0gNCAvIDMgKiBNYXRoLnNpbihoYWxmKSAvICgxICsgTWF0aC5jb3MoaGFsZikpLFxuXHRcdFx0XHRzZWdtZW50cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gY291bnQ7IGkrKykge1xuXHRcdFx0XHR2YXIgcHQgPSB0byxcblx0XHRcdFx0XHRvdXQgPSBudWxsO1xuXHRcdFx0XHRpZiAoaSA8IGNvdW50KSB7XG5cdFx0XHRcdFx0b3V0ID0gdmVjdG9yLnJvdGF0ZSg5MCkubXVsdGlwbHkoeik7XG5cdFx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdFx0cHQgPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvcik7XG5cdFx0XHRcdFx0XHRvdXQgPSBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHZlY3Rvci5hZGQob3V0KSlcblx0XHRcdFx0XHRcdFx0XHQuc3VidHJhY3QocHQpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRwdCA9IGNlbnRlci5hZGQodmVjdG9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKGkgPT09IDApIHtcblx0XHRcdFx0XHRjdXJyZW50LnNldEhhbmRsZU91dChvdXQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBfaW4gPSB2ZWN0b3Iucm90YXRlKC05MCkubXVsdGlwbHkoeik7XG5cdFx0XHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRcdFx0X2luID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IuYWRkKF9pbikpXG5cdFx0XHRcdFx0XHRcdFx0LnN1YnRyYWN0KHB0KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0c2VnbWVudHMucHVzaChuZXcgU2VnbWVudChwdCwgX2luLCBvdXQpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2ZWN0b3IgPSB2ZWN0b3Iucm90YXRlKGluYyk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9hZGQoc2VnbWVudHMpO1xuXHRcdH0sXG5cblx0XHRsaW5lQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5saW5lVG8oY3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0Y3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHBhcmFtZXRlciA9IEJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdXJ2ZVRvKGN1cnJlbnQuYWRkKHRocm91Z2gpLCBjdXJyZW50LmFkZCh0byksIHBhcmFtZXRlcik7XG5cdFx0fSxcblxuXHRcdGN1YmljQ3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlMSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0aGFuZGxlMiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUxKSwgY3VycmVudC5hZGQoaGFuZGxlMiksXG5cdFx0XHRcdFx0Y3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0cXVhZHJhdGljQ3VydmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaGFuZGxlID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhjdXJyZW50LmFkZChoYW5kbGUpLCBjdXJyZW50LmFkZCh0bykpO1xuXHRcdH0sXG5cblx0XHRhcmNCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludCxcblx0XHRcdFx0cG9pbnQgPSBjdXJyZW50LmFkZChQb2ludC5yZWFkKGFyZ3VtZW50cykpLFxuXHRcdFx0XHRjbG9ja3dpc2UgPSBCYXNlLnBpY2soQmFzZS5wZWVrKGFyZ3VtZW50cyksIHRydWUpO1xuXHRcdFx0aWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR0aGlzLmFyY1RvKHBvaW50LCBjbG9ja3dpc2UpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hcmNUbyhwb2ludCwgY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmd1bWVudHMpKSk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGNsb3NlUGF0aDogZnVuY3Rpb24oam9pbikge1xuXHRcdFx0dGhpcy5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0XHRpZiAoam9pbilcblx0XHRcdFx0dGhpcy5qb2luKCk7XG5cdFx0fVxuXHR9O1xufSwge1xuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4KSB7XG5cdFx0cmV0dXJuIFBhdGhbZ2V0dGVyXSh0aGlzLl9zZWdtZW50cywgdGhpcy5fY2xvc2VkLCB0aGlzLmdldFN0eWxlKCksXG5cdFx0XHRcdG1hdHJpeCk7XG5cdH0sXG5cbnN0YXRpY3M6IHtcblx0Z2V0Qm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LCBzdHJva2VQYWRkaW5nKSB7XG5cdFx0dmFyIGZpcnN0ID0gc2VnbWVudHNbMF07XG5cdFx0aWYgKCFmaXJzdClcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKCk7XG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdHByZXZDb29yZHMgPSBmaXJzdC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBuZXcgQXJyYXkoNiksIGZhbHNlKSxcblx0XHRcdG1pbiA9IHByZXZDb29yZHMuc2xpY2UoMCwgMiksXG5cdFx0XHRtYXggPSBtaW4uc2xpY2UoKSxcblx0XHRcdHJvb3RzID0gbmV3IEFycmF5KDIpO1xuXG5cdFx0ZnVuY3Rpb24gcHJvY2Vzc1NlZ21lbnQoc2VnbWVudCkge1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMjsgaSsrKSB7XG5cdFx0XHRcdEN1cnZlLl9hZGRCb3VuZHMoXG5cdFx0XHRcdFx0cHJldkNvb3Jkc1tpXSxcblx0XHRcdFx0XHRwcmV2Q29vcmRzW2kgKyA0XSxcblx0XHRcdFx0XHRjb29yZHNbaSArIDJdLFxuXHRcdFx0XHRcdGNvb3Jkc1tpXSxcblx0XHRcdFx0XHRpLCBzdHJva2VQYWRkaW5nID8gc3Ryb2tlUGFkZGluZ1tpXSA6IDAsIG1pbiwgbWF4LCByb290cyk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdG1wID0gcHJldkNvb3Jkcztcblx0XHRcdHByZXZDb29yZHMgPSBjb29yZHM7XG5cdFx0XHRjb29yZHMgPSB0bXA7XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRwcm9jZXNzU2VnbWVudChzZWdtZW50c1tpXSk7XG5cdFx0aWYgKGNsb3NlZClcblx0XHRcdHByb2Nlc3NTZWdtZW50KGZpcnN0KTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZShtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuXHR9LFxuXG5cdGdldFN0cm9rZUJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCkge1xuXHRcdGlmICghc3R5bGUuaGFzU3Ryb2tlKCkpXG5cdFx0XHRyZXR1cm4gUGF0aC5nZXRCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCk7XG5cdFx0dmFyIGxlbmd0aCA9IHNlZ21lbnRzLmxlbmd0aCAtIChjbG9zZWQgPyAwIDogMSksXG5cdFx0XHRyYWRpdXMgPSBzdHlsZS5nZXRTdHJva2VXaWR0aCgpIC8gMixcblx0XHRcdHBhZGRpbmcgPSBQYXRoLl9nZXRQZW5QYWRkaW5nKHJhZGl1cywgbWF0cml4KSxcblx0XHRcdGJvdW5kcyA9IFBhdGguZ2V0Qm91bmRzKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsIHBhZGRpbmcpLFxuXHRcdFx0am9pbiA9IHN0eWxlLmdldFN0cm9rZUpvaW4oKSxcblx0XHRcdGNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuXHRcdFx0bWl0ZXJMaW1pdCA9IHJhZGl1cyAqIHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHR2YXIgam9pbkJvdW5kcyA9IG5ldyBSZWN0YW5nbGUobmV3IFNpemUocGFkZGluZykubXVsdGlwbHkoMikpO1xuXG5cdFx0ZnVuY3Rpb24gYWRkKHBvaW50KSB7XG5cdFx0XHRib3VuZHMgPSBib3VuZHMuaW5jbHVkZShtYXRyaXhcblx0XHRcdFx0PyBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvaW50LCBwb2ludCkgOiBwb2ludCk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkUm91bmQoc2VnbWVudCkge1xuXHRcdFx0Ym91bmRzID0gYm91bmRzLnVuaXRlKGpvaW5Cb3VuZHMuc2V0Q2VudGVyKG1hdHJpeFxuXHRcdFx0XHQ/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQoc2VnbWVudC5fcG9pbnQpIDogc2VnbWVudC5fcG9pbnQpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRKb2luKHNlZ21lbnQsIGpvaW4pIHtcblx0XHRcdHZhciBoYW5kbGVJbiA9IHNlZ21lbnQuX2hhbmRsZUluLFxuXHRcdFx0XHRoYW5kbGVPdXQgPSBzZWdtZW50Ll9oYW5kbGVPdXQ7XG5cdFx0XHRpZiAoam9pbiA9PT0gJ3JvdW5kJyB8fCAhaGFuZGxlSW4uaXNaZXJvKCkgJiYgIWhhbmRsZU91dC5pc1plcm8oKVxuXHRcdFx0XHRcdCYmIGhhbmRsZUluLmlzQ29sbGluZWFyKGhhbmRsZU91dCkpIHtcblx0XHRcdFx0YWRkUm91bmQoc2VnbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LCBhZGQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZENhcChzZWdtZW50LCBjYXApIHtcblx0XHRcdGlmIChjYXAgPT09ICdyb3VuZCcpIHtcblx0XHRcdFx0YWRkUm91bmQoc2VnbWVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRQYXRoLl9hZGRTcXVhcmVDYXAoc2VnbWVudCwgY2FwLCByYWRpdXMsIGFkZCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdGFkZEpvaW4oc2VnbWVudHNbaV0sIGpvaW4pO1xuXHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdGFkZEpvaW4oc2VnbWVudHNbMF0sIGpvaW4pO1xuXHRcdH0gZWxzZSBpZiAobGVuZ3RoID4gMCkge1xuXHRcdFx0YWRkQ2FwKHNlZ21lbnRzWzBdLCBjYXApO1xuXHRcdFx0YWRkQ2FwKHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLCBjYXApO1xuXHRcdH1cblx0XHRyZXR1cm4gYm91bmRzO1xuXHR9LFxuXG5cdF9nZXRQZW5QYWRkaW5nOiBmdW5jdGlvbihyYWRpdXMsIG1hdHJpeCkge1xuXHRcdGlmICghbWF0cml4KVxuXHRcdFx0cmV0dXJuIFtyYWRpdXMsIHJhZGl1c107XG5cdFx0dmFyIG14ID0gbWF0cml4LnNoaWZ0bGVzcygpLFxuXHRcdFx0aG9yID0gbXgudHJhbnNmb3JtKG5ldyBQb2ludChyYWRpdXMsIDApKSxcblx0XHRcdHZlciA9IG14LnRyYW5zZm9ybShuZXcgUG9pbnQoMCwgcmFkaXVzKSksXG5cdFx0XHRwaGkgPSBob3IuZ2V0QW5nbGVJblJhZGlhbnMoKSxcblx0XHRcdGEgPSBob3IuZ2V0TGVuZ3RoKCksXG5cdFx0XHRiID0gdmVyLmdldExlbmd0aCgpO1xuXHRcdHZhciBzaW4gPSBNYXRoLnNpbihwaGkpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MocGhpKSxcblx0XHRcdHRhbiA9IE1hdGgudGFuKHBoaSksXG5cdFx0XHR0eCA9IC1NYXRoLmF0YW4oYiAqIHRhbiAvIGEpLFxuXHRcdFx0dHkgPSBNYXRoLmF0YW4oYiAvICh0YW4gKiBhKSk7XG5cdFx0cmV0dXJuIFtNYXRoLmFicyhhICogTWF0aC5jb3ModHgpICogY29zIC0gYiAqIE1hdGguc2luKHR4KSAqIHNpbiksXG5cdFx0XHRcdE1hdGguYWJzKGIgKiBNYXRoLnNpbih0eSkgKiBjb3MgKyBhICogTWF0aC5jb3ModHkpICogc2luKV07XG5cdH0sXG5cblx0X2FkZEJldmVsSm9pbjogZnVuY3Rpb24oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LCBhZGRQb2ludCwgYXJlYSkge1xuXHRcdHZhciBjdXJ2ZTIgPSBzZWdtZW50LmdldEN1cnZlKCksXG5cdFx0XHRjdXJ2ZTEgPSBjdXJ2ZTIuZ2V0UHJldmlvdXMoKSxcblx0XHRcdHBvaW50ID0gY3VydmUyLmdldFBvaW50QXQoMCwgdHJ1ZSksXG5cdFx0XHRub3JtYWwxID0gY3VydmUxLmdldE5vcm1hbEF0KDEsIHRydWUpLFxuXHRcdFx0bm9ybWFsMiA9IGN1cnZlMi5nZXROb3JtYWxBdCgwLCB0cnVlKSxcblx0XHRcdHN0ZXAgPSBub3JtYWwxLmdldERpcmVjdGVkQW5nbGUobm9ybWFsMikgPCAwID8gLXJhZGl1cyA6IHJhZGl1cztcblx0XHRub3JtYWwxLnNldExlbmd0aChzdGVwKTtcblx0XHRub3JtYWwyLnNldExlbmd0aChzdGVwKTtcblx0XHRpZiAoYXJlYSkge1xuXHRcdFx0YWRkUG9pbnQocG9pbnQpO1xuXHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDEpKTtcblx0XHR9XG5cdFx0aWYgKGpvaW4gPT09ICdtaXRlcicpIHtcblx0XHRcdHZhciBjb3JuZXIgPSBuZXcgTGluZShcblx0XHRcdFx0XHRwb2ludC5hZGQobm9ybWFsMSksXG5cdFx0XHRcdFx0bmV3IFBvaW50KC1ub3JtYWwxLnksIG5vcm1hbDEueCksIHRydWVcblx0XHRcdFx0KS5pbnRlcnNlY3QobmV3IExpbmUoXG5cdFx0XHRcdFx0cG9pbnQuYWRkKG5vcm1hbDIpLFxuXHRcdFx0XHRcdG5ldyBQb2ludCgtbm9ybWFsMi55LCBub3JtYWwyLngpLCB0cnVlXG5cdFx0XHRcdCksIHRydWUpO1xuXHRcdFx0aWYgKGNvcm5lciAmJiBwb2ludC5nZXREaXN0YW5jZShjb3JuZXIpIDw9IG1pdGVyTGltaXQpIHtcblx0XHRcdFx0YWRkUG9pbnQoY29ybmVyKTtcblx0XHRcdFx0aWYgKCFhcmVhKVxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFhcmVhKVxuXHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDEpKTtcblx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsMikpO1xuXHR9LFxuXG5cdF9hZGRTcXVhcmVDYXA6IGZ1bmN0aW9uKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBhZGRQb2ludCwgYXJlYSkge1xuXHRcdHZhciBwb2ludCA9IHNlZ21lbnQuX3BvaW50LFxuXHRcdFx0bG9jID0gc2VnbWVudC5nZXRMb2NhdGlvbigpLFxuXHRcdFx0bm9ybWFsID0gbG9jLmdldE5vcm1hbCgpLm11bHRpcGx5KHJhZGl1cyk7XG5cdFx0aWYgKGFyZWEpIHtcblx0XHRcdGFkZFBvaW50KHBvaW50LnN1YnRyYWN0KG5vcm1hbCkpO1xuXHRcdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbCkpO1xuXHRcdH1cblx0XHRpZiAoY2FwID09PSAnc3F1YXJlJylcblx0XHRcdHBvaW50ID0gcG9pbnQuYWRkKG5vcm1hbC5yb3RhdGUobG9jLmdldFBhcmFtZXRlcigpID09PSAwID8gLTkwIDogOTApKTtcblx0XHRhZGRQb2ludChwb2ludC5hZGQobm9ybWFsKSk7XG5cdFx0YWRkUG9pbnQocG9pbnQuc3VidHJhY3Qobm9ybWFsKSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LCBzdHJva2VQYWRkaW5nLFxuXHRcdFx0am9pblBhZGRpbmcpIHtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpLFxuXHRcdFx0eDEgPSBJbmZpbml0eSxcblx0XHRcdHgyID0gLXgxLFxuXHRcdFx0eTEgPSB4MSxcblx0XHRcdHkyID0geDI7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCA2OyBqICs9IDIpIHtcblx0XHRcdFx0dmFyIHBhZGRpbmcgPSBqID09PSAwID8gam9pblBhZGRpbmcgOiBzdHJva2VQYWRkaW5nLFxuXHRcdFx0XHRcdHBhZGRpbmdYID0gcGFkZGluZyA/IHBhZGRpbmdbMF0gOiAwLFxuXHRcdFx0XHRcdHBhZGRpbmdZID0gcGFkZGluZyA/IHBhZGRpbmdbMV0gOiAwLFxuXHRcdFx0XHRcdHggPSBjb29yZHNbal0sXG5cdFx0XHRcdFx0eSA9IGNvb3Jkc1tqICsgMV0sXG5cdFx0XHRcdFx0eG4gPSB4IC0gcGFkZGluZ1gsXG5cdFx0XHRcdFx0eHggPSB4ICsgcGFkZGluZ1gsXG5cdFx0XHRcdFx0eW4gPSB5IC0gcGFkZGluZ1ksXG5cdFx0XHRcdFx0eXggPSB5ICsgcGFkZGluZ1k7XG5cdFx0XHRcdGlmICh4biA8IHgxKSB4MSA9IHhuO1xuXHRcdFx0XHRpZiAoeHggPiB4MikgeDIgPSB4eDtcblx0XHRcdFx0aWYgKHluIDwgeTEpIHkxID0geW47XG5cdFx0XHRcdGlmICh5eCA+IHkyKSB5MiA9IHl4O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4MSwgeTEsIHgyIC0geDEsIHkyIC0geTEpO1xuXHR9LFxuXG5cdGdldFJvdWdoQm91bmRzOiBmdW5jdGlvbihzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4KSB7XG5cdFx0dmFyIHN0cm9rZVJhZGl1cyA9IHN0eWxlLmhhc1N0cm9rZSgpID8gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDIgOiAwLFxuXHRcdFx0am9pblJhZGl1cyA9IHN0cm9rZVJhZGl1cztcblx0XHRpZiAoc3Ryb2tlUmFkaXVzID4gMCkge1xuXHRcdFx0aWYgKHN0eWxlLmdldFN0cm9rZUpvaW4oKSA9PT0gJ21pdGVyJylcblx0XHRcdFx0am9pblJhZGl1cyA9IHN0cm9rZVJhZGl1cyAqIHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdGlmIChzdHlsZS5nZXRTdHJva2VDYXAoKSA9PT0gJ3NxdWFyZScpXG5cdFx0XHRcdGpvaW5SYWRpdXMgPSBNYXRoLm1heChqb2luUmFkaXVzLCBzdHJva2VSYWRpdXMgKiBNYXRoLnNxcnQoMikpO1xuXHRcdH1cblx0XHRyZXR1cm4gUGF0aC5nZXRIYW5kbGVCb3VuZHMoc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCxcblx0XHRcdFx0UGF0aC5fZ2V0UGVuUGFkZGluZyhzdHJva2VSYWRpdXMsIG1hdHJpeCksXG5cdFx0XHRcdFBhdGguX2dldFBlblBhZGRpbmcoam9pblJhZGl1cywgbWF0cml4KSk7XG5cdH1cbn19KTtcblxuUGF0aC5pbmplY3QoeyBzdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIGthcHBhID0gMC41NTIyODQ3NDk4MzA3OTM2LFxuXHRcdGVsbGlwc2VTZWdtZW50cyA9IFtcblx0XHRcdG5ldyBTZWdtZW50KFstMSwgMF0sIFswLCBrYXBwYSBdLCBbMCwgLWthcHBhXSksXG5cdFx0XHRuZXcgU2VnbWVudChbMCwgLTFdLCBbLWthcHBhLCAwXSwgW2thcHBhLCAwIF0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzEsIDBdLCBbMCwgLWthcHBhXSwgWzAsIGthcHBhIF0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzAsIDFdLCBba2FwcGEsIDAgXSwgWy1rYXBwYSwgMF0pXG5cdFx0XTtcblxuXHRmdW5jdGlvbiBjcmVhdGVQYXRoKHNlZ21lbnRzLCBjbG9zZWQsIGFyZ3MpIHtcblx0XHR2YXIgcHJvcHMgPSBCYXNlLmdldE5hbWVkKGFyZ3MpLFxuXHRcdFx0cGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PT0gZmFsc2UgJiYgSXRlbS5OT19JTlNFUlQpO1xuXHRcdHBhdGguX2FkZChzZWdtZW50cyk7XG5cdFx0cGF0aC5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdHJldHVybiBwYXRoLnNldChwcm9wcyk7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFbGxpcHNlKGNlbnRlciwgcmFkaXVzLCBhcmdzKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gbmV3IEFycmF5KDQpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IGVsbGlwc2VTZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoXG5cdFx0XHRcdHNlZ21lbnQuX3BvaW50Lm11bHRpcGx5KHJhZGl1cykuYWRkKGNlbnRlciksXG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZUluLm11bHRpcGx5KHJhZGl1cyksXG5cdFx0XHRcdHNlZ21lbnQuX2hhbmRsZU91dC5tdWx0aXBseShyYWRpdXMpXG5cdFx0XHQpO1xuXHRcdH1cblx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJncyk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdExpbmU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoW1xuXHRcdFx0XHRuZXcgU2VnbWVudChQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnZnJvbScpKSxcblx0XHRcdFx0bmV3IFNlZ21lbnQoUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJykpXG5cdFx0XHRdLCBmYWxzZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Q2lyY2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZUVsbGlwc2UoY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMpLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRSZWN0YW5nbGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlY3QgPSBSZWN0YW5nbGUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JlY3RhbmdsZScpLFxuXHRcdFx0XHRyYWRpdXMgPSBTaXplLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnLCAwLFxuXHRcdFx0XHRcdFx0eyByZWFkTnVsbDogdHJ1ZSB9KSxcblx0XHRcdFx0YmwgPSByZWN0LmdldEJvdHRvbUxlZnQodHJ1ZSksXG5cdFx0XHRcdHRsID0gcmVjdC5nZXRUb3BMZWZ0KHRydWUpLFxuXHRcdFx0XHR0ciA9IHJlY3QuZ2V0VG9wUmlnaHQodHJ1ZSksXG5cdFx0XHRcdGJyID0gcmVjdC5nZXRCb3R0b21SaWdodCh0cnVlKSxcblx0XHRcdFx0c2VnbWVudHM7XG5cdFx0XHRpZiAoIXJhZGl1cyB8fCByYWRpdXMuaXNaZXJvKCkpIHtcblx0XHRcdFx0c2VnbWVudHMgPSBbXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ciksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIpXG5cdFx0XHRcdF07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyYWRpdXMgPSBTaXplLm1pbihyYWRpdXMsIHJlY3QuZ2V0U2l6ZSh0cnVlKS5kaXZpZGUoMikpO1xuXHRcdFx0XHR2YXIgcnggPSByYWRpdXMud2lkdGgsXG5cdFx0XHRcdFx0cnkgPSByYWRpdXMuaGVpZ2h0LFxuXHRcdFx0XHRcdGh4ID0gcnggKiBrYXBwYSxcblx0XHRcdFx0XHRoeSA9IHJ5ICoga2FwcGE7XG5cdFx0XHRcdHNlZ21lbnRzID0gW1xuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsLmFkZChyeCwgMCksIG51bGwsIFstaHgsIDBdKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibC5zdWJ0cmFjdCgwLCByeSksIFswLCBoeV0pLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRsLmFkZCgwLCByeSksIG51bGwsIFswLCAtaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0bC5hZGQocngsIDApLCBbLWh4LCAwXSwgbnVsbCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodHIuc3VidHJhY3QocngsIDApLCBudWxsLCBbaHgsIDBdKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0ci5hZGQoMCwgcnkpLCBbMCwgLWh5XSwgbnVsbCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIuc3VidHJhY3QoMCwgcnkpLCBudWxsLCBbMCwgaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudChici5zdWJ0cmFjdChyeCwgMCksIFtoeCwgMF0pXG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0Um91bmRSZWN0YW5nbGU6ICcjUmVjdGFuZ2xlJyxcblxuXHRcdEVsbGlwc2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGVsbGlwc2UgPSBTaGFwZS5fcmVhZEVsbGlwc2UoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBjcmVhdGVFbGxpcHNlKGVsbGlwc2UuY2VudGVyLCBlbGxpcHNlLnJhZGl1cywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0T3ZhbDogJyNFbGxpcHNlJyxcblxuXHRcdEFyYzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgZnJvbSA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdmcm9tJyksXG5cdFx0XHRcdHRocm91Z2ggPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndGhyb3VnaCcpLFxuXHRcdFx0XHR0byA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0bycpLFxuXHRcdFx0XHRwcm9wcyA9IEJhc2UuZ2V0TmFtZWQoYXJndW1lbnRzKSxcblx0XHRcdFx0cGF0aCA9IG5ldyBQYXRoKHByb3BzICYmIHByb3BzLmluc2VydCA9PT0gZmFsc2Vcblx0XHRcdFx0XHRcdCYmIEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdHBhdGgubW92ZVRvKGZyb20pO1xuXHRcdFx0cGF0aC5hcmNUbyh0aHJvdWdoLCB0byk7XG5cdFx0XHRyZXR1cm4gcGF0aC5zZXQocHJvcHMpO1xuXHRcdH0sXG5cblx0XHRSZWd1bGFyUG9seWdvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRzaWRlcyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3NpZGVzJyksXG5cdFx0XHRcdHJhZGl1cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpLFxuXHRcdFx0XHRzdGVwID0gMzYwIC8gc2lkZXMsXG5cdFx0XHRcdHRocmVlID0gIShzaWRlcyAlIDMpLFxuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgUG9pbnQoMCwgdGhyZWUgPyAtcmFkaXVzIDogcmFkaXVzKSxcblx0XHRcdFx0b2Zmc2V0ID0gdGhyZWUgPyAtMSA6IDAuNSxcblx0XHRcdFx0c2VnbWVudHMgPSBuZXcgQXJyYXkoc2lkZXMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzaWRlczsgaSsrKVxuXHRcdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KGNlbnRlci5hZGQoXG5cdFx0XHRcdFx0dmVjdG9yLnJvdGF0ZSgoaSArIG9mZnNldCkgKiBzdGVwKSkpO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFN0YXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0cG9pbnRzID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncG9pbnRzJykgKiAyLFxuXHRcdFx0XHRyYWRpdXMxID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzMScpLFxuXHRcdFx0XHRyYWRpdXMyID0gQmFzZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzMicpLFxuXHRcdFx0XHRzdGVwID0gMzYwIC8gcG9pbnRzLFxuXHRcdFx0XHR2ZWN0b3IgPSBuZXcgUG9pbnQoMCwgLTEpLFxuXHRcdFx0XHRzZWdtZW50cyA9IG5ldyBBcnJheShwb2ludHMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHM7IGkrKylcblx0XHRcdFx0c2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChjZW50ZXIuYWRkKHZlY3Rvci5yb3RhdGUoc3RlcCAqIGkpXG5cdFx0XHRcdFx0XHQubXVsdGlwbHkoaSAlIDIgPyByYWRpdXMyIDogcmFkaXVzMSkpKTtcblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fTtcbn19KTtcblxudmFyIENvbXBvdW5kUGF0aCA9IFBhdGhJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ0NvbXBvdW5kUGF0aCcsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjaGlsZHJlbjogW11cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDb21wb3VuZFBhdGgoYXJnKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpIHtcblx0XHRcdGlmICh0eXBlb2YgYXJnID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFBhdGhEYXRhKGFyZyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGluc2VydENoaWxkcmVuOiBmdW5jdGlvbiBpbnNlcnRDaGlsZHJlbihpbmRleCwgaXRlbXMsIF9wcmVzZXJ2ZSkge1xuXHRcdGZvciAodmFyIGkgPSBpdGVtcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSB7XG5cdFx0XHRcdGl0ZW1zLnNwbGljZS5hcHBseShpdGVtcywgW2ksIDFdLmNvbmNhdChpdGVtLnJlbW92ZUNoaWxkcmVuKCkpKTtcblx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aXRlbXMgPSBpbnNlcnRDaGlsZHJlbi5iYXNlLmNhbGwodGhpcywgaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUsIFBhdGgpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gIV9wcmVzZXJ2ZSAmJiBpdGVtcyAmJiBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRpZiAoaXRlbS5fY2xvY2t3aXNlID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGl0ZW0uc2V0Q2xvY2t3aXNlKGl0ZW0uX2luZGV4ID09PSAwKTtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdHJldmVyc2U6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y2hpbGRyZW5baV0ucmV2ZXJzZSgpO1xuXHR9LFxuXG5cdHNtb290aDogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHR0aGlzLl9jaGlsZHJlbltpXS5zbW9vdGgoKTtcblx0fSxcblxuXHRyZWR1Y2U6IGZ1bmN0aW9uIHJlZHVjZSgpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBwYXRoID0gY2hpbGRyZW5baV0ucmVkdWNlKCk7XG5cdFx0XHRpZiAocGF0aC5pc0VtcHR5KCkpXG5cdFx0XHRcdGNoaWxkcmVuLnNwbGljZShpLCAxKTtcblx0XHR9XG5cdFx0aWYgKGNoaWxkcmVuLmxlbmd0aCA9PT0gMCkge1xuXHRcdFx0dmFyIHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRwYXRoLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdFx0cGF0aC5zZXRTdHlsZSh0aGlzLl9zdHlsZSk7XG5cdFx0XHR0aGlzLnJlbW92ZSgpO1xuXHRcdFx0cmV0dXJuIHBhdGg7XG5cdFx0fVxuXHRcdHJldHVybiByZWR1Y2UuYmFzZS5jYWxsKHRoaXMpO1xuXHR9LFxuXG5cdGlzQ2xvY2t3aXNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gY2hpbGQgJiYgY2hpbGQuaXNDbG9ja3dpc2UoKTtcblx0fSxcblxuXHRzZXRDbG9ja3dpc2U6IGZ1bmN0aW9uKGNsb2Nrd2lzZSkge1xuXHRcdGlmICh0aGlzLmlzQ2xvY2t3aXNlKCkgIT09ICEhY2xvY2t3aXNlKVxuXHRcdFx0dGhpcy5yZXZlcnNlKCk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gZmlyc3QgJiYgZmlyc3QuZ2V0Rmlyc3RTZWdtZW50KCk7XG5cdH0sXG5cblx0Z2V0TGFzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gbGFzdCAmJiBsYXN0LmdldExhc3RTZWdtZW50KCk7XG5cdH0sXG5cblx0Z2V0Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGN1cnZlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y3VydmVzLnB1c2guYXBwbHkoY3VydmVzLCBjaGlsZHJlbltpXS5nZXRDdXJ2ZXMoKSk7XG5cdFx0cmV0dXJuIGN1cnZlcztcblx0fSxcblxuXHRnZXRGaXJzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gZmlyc3QgJiYgZmlyc3QuZ2V0Rmlyc3RDdXJ2ZSgpO1xuXHR9LFxuXG5cdGdldExhc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxhc3QgPSB0aGlzLmdldExhc3RDaGlsZCgpO1xuXHRcdHJldHVybiBsYXN0ICYmIGxhc3QuZ2V0Rmlyc3RDdXJ2ZSgpO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0YXJlYSA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRhcmVhICs9IGNoaWxkcmVuW2ldLmdldEFyZWEoKTtcblx0XHRyZXR1cm4gYXJlYTtcblx0fVxufSwge1xuXHRiZWFuczogdHJ1ZSxcblxuXHRnZXRQYXRoRGF0YTogZnVuY3Rpb24oX21hdHJpeCwgX3ByZWNpc2lvbikge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0cGF0aHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG5cdFx0XHRcdG14ID0gY2hpbGQuX21hdHJpeDtcblx0XHRcdHBhdGhzLnB1c2goY2hpbGQuZ2V0UGF0aERhdGEoX21hdHJpeCAmJiAhbXguaXNJZGVudGl0eSgpXG5cdFx0XHRcdFx0PyBfbWF0cml4LmNoYWluKG14KSA6IF9tYXRyaXgsIF9wcmVjaXNpb24pKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBhdGhzLmpvaW4oJyAnKTtcblx0fVxufSwge1xuXHRfZ2V0Q2hpbGRIaXRUZXN0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBvcHRpb25zLmNsYXNzID09PSBQYXRoIHx8IG9wdGlvbnMudHlwZSA9PT0gJ3BhdGgnXG5cdFx0XHRcdD8gb3B0aW9uc1xuXHRcdFx0XHQ6IG5ldyBCYXNlKG9wdGlvbnMsIHsgZmlsbDogZmFsc2UgfSk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApXG5cdFx0XHRyZXR1cm47XG5cblx0XHRpZiAodGhpcy5fY3VycmVudFBhdGgpIHtcblx0XHRcdGN0eC5jdXJyZW50UGF0aCA9IHRoaXMuX2N1cnJlbnRQYXRoO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRwYXJhbSA9IHBhcmFtLmV4dGVuZCh7IGRvbnRTdGFydDogdHJ1ZSwgZG9udEZpbmlzaDogdHJ1ZSB9KTtcblx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5kcmF3KGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCk7XG5cdFx0XHR0aGlzLl9jdXJyZW50UGF0aCA9IGN0eC5jdXJyZW50UGF0aDtcblx0XHR9XG5cblx0XHRpZiAoIXBhcmFtLmNsaXApIHtcblx0XHRcdHRoaXMuX3NldFN0eWxlcyhjdHgpO1xuXHRcdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGU7XG5cdFx0XHRpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG5cdFx0XHRcdGN0eC5maWxsKHN0eWxlLmdldFdpbmRpbmdSdWxlKCkpO1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpXG5cdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHR9XG5cdH0sXG5cblx0X2RyYXdTZWxlY3RlZDogZnVuY3Rpb24oY3R4LCBtYXRyaXgsIHNlbGVjdGVkSXRlbXMpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG5cdFx0XHRcdG14ID0gY2hpbGQuX21hdHJpeDtcblx0XHRcdGlmICghc2VsZWN0ZWRJdGVtc1tjaGlsZC5faWRdKVxuXHRcdFx0XHRjaGlsZC5fZHJhd1NlbGVjdGVkKGN0eCwgbXguaXNJZGVudGl0eSgpID8gbWF0cml4XG5cdFx0XHRcdFx0XHQ6IG1hdHJpeC5jaGFpbihteCkpO1xuXHRcdH1cblx0fVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gZ2V0Q3VycmVudFBhdGgodGhhdCwgY2hlY2spIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGF0Ll9jaGlsZHJlbjtcblx0XHRpZiAoY2hlY2sgJiYgY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVc2UgYSBtb3ZlVG8oKSBjb21tYW5kIGZpcnN0Jyk7XG5cdFx0cmV0dXJuIGNoaWxkcmVuW2NoaWxkcmVuLmxlbmd0aCAtIDFdO1xuXHR9XG5cblx0dmFyIGZpZWxkcyA9IHtcblx0XHRtb3ZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50UGF0aCh0aGlzKSxcblx0XHRcdFx0cGF0aCA9IGN1cnJlbnQgJiYgY3VycmVudC5pc0VtcHR5KCkgPyBjdXJyZW50XG5cdFx0XHRcdFx0XHQ6IG5ldyBQYXRoKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRcdGlmIChwYXRoICE9PSBjdXJyZW50KVxuXHRcdFx0XHR0aGlzLmFkZENoaWxkKHBhdGgpO1xuXHRcdFx0cGF0aC5tb3ZlVG8uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0bW92ZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSksXG5cdFx0XHRcdGxhc3QgPSBjdXJyZW50ICYmIGN1cnJlbnQuZ2V0TGFzdFNlZ21lbnQoKSxcblx0XHRcdFx0cG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLm1vdmVUbyhsYXN0ID8gcG9pbnQuYWRkKGxhc3QuX3BvaW50KSA6IHBvaW50KTtcblx0XHR9LFxuXG5cdFx0Y2xvc2VQYXRoOiBmdW5jdGlvbihqb2luKSB7XG5cdFx0XHRnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKS5jbG9zZVBhdGgoam9pbik7XG5cdFx0fVxuXHR9O1xuXG5cdEJhc2UuZWFjaChbJ2xpbmVUbycsICdjdWJpY0N1cnZlVG8nLCAncXVhZHJhdGljQ3VydmVUbycsICdjdXJ2ZVRvJywgJ2FyY1RvJyxcblx0XHRcdCdsaW5lQnknLCAnY3ViaWNDdXJ2ZUJ5JywgJ3F1YWRyYXRpY0N1cnZlQnknLCAnY3VydmVCeScsICdhcmNCeSddLFxuXHRcdFx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRcdGZpZWxkc1trZXldID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dmFyIHBhdGggPSBnZXRDdXJyZW50UGF0aCh0aGlzLCB0cnVlKTtcblx0XHRcdFx0XHRwYXRoW2tleV0uYXBwbHkocGF0aCwgYXJndW1lbnRzKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0KTtcblxuXHRyZXR1cm4gZmllbGRzO1xufSk7XG5cblBhdGhJdGVtLmluamVjdChuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBvcGVyYXRvcnMgPSB7XG5cdFx0dW5pdGU6IGZ1bmN0aW9uKHcpIHtcblx0XHRcdHJldHVybiB3ID09PSAxIHx8IHcgPT09IDA7XG5cdFx0fSxcblxuXHRcdGludGVyc2VjdDogZnVuY3Rpb24odykge1xuXHRcdFx0cmV0dXJuIHcgPT09IDI7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbih3KSB7XG5cdFx0XHRyZXR1cm4gdyA9PT0gMTtcblx0XHR9LFxuXG5cdFx0ZXhjbHVkZTogZnVuY3Rpb24odykge1xuXHRcdFx0cmV0dXJuIHcgPT09IDE7XG5cdFx0fVxuXHR9O1xuXG5cdGZ1bmN0aW9uIHByZXBhcmVQYXRoKHBhdGgsIHJlc29sdmUpIHtcblx0XHR2YXIgcmVzID0gcGF0aC5jbG9uZShmYWxzZSkucmVkdWNlKCkudHJhbnNmb3JtKG51bGwsIHRydWUsIHRydWUpO1xuXHRcdHJldHVybiByZXNvbHZlID8gcmVzLnJlc29sdmVDcm9zc2luZ3MoKS5yZW9yaWVudCgpIDogcmVzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZmluaXNoQm9vbGVhbihjdG9yLCBwYXRocywgcGF0aDEsIHBhdGgyLCByZWR1Y2UpIHtcblx0XHR2YXIgcmVzdWx0ID0gbmV3IGN0b3IoSXRlbS5OT19JTlNFUlQpO1xuXHRcdHJlc3VsdC5hZGRDaGlsZHJlbihwYXRocywgdHJ1ZSk7XG5cdFx0aWYgKHJlZHVjZSlcblx0XHRcdHJlc3VsdCA9IHJlc3VsdC5yZWR1Y2UoKTtcblx0XHRyZXN1bHQuaW5zZXJ0QWJvdmUocGF0aDIgJiYgcGF0aDEuaXNTaWJsaW5nKHBhdGgyKVxuXHRcdFx0XHQmJiBwYXRoMS5nZXRJbmRleCgpIDwgcGF0aDIuZ2V0SW5kZXgoKVxuXHRcdFx0XHRcdD8gcGF0aDIgOiBwYXRoMSk7XG5cdFx0cmVzdWx0LnNldFN0eWxlKHBhdGgxLl9zdHlsZSk7XG5cdFx0cmV0dXJuIHJlc3VsdDtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXB1dGVCb29sZWFuKHBhdGgxLCBwYXRoMiwgb3BlcmF0aW9uKSB7XG5cdFx0aWYgKCFwYXRoMS5fY2hpbGRyZW4gJiYgIXBhdGgxLl9jbG9zZWQpXG5cdFx0XHRyZXR1cm4gY29tcHV0ZU9wZW5Cb29sZWFuKHBhdGgxLCBwYXRoMiwgb3BlcmF0aW9uKTtcblx0XHR2YXIgX3BhdGgxID0gcHJlcGFyZVBhdGgocGF0aDEsIHRydWUpLFxuXHRcdFx0X3BhdGgyID0gcGF0aDIgJiYgcGF0aDEgIT09IHBhdGgyICYmIHByZXBhcmVQYXRoKHBhdGgyLCB0cnVlKTtcblx0XHRpZiAoX3BhdGgyICYmIC9eKHN1YnRyYWN0fGV4Y2x1ZGUpJC8udGVzdChvcGVyYXRpb24pXG5cdFx0XHRcdF4gKF9wYXRoMi5pc0Nsb2Nrd2lzZSgpICE9PSBfcGF0aDEuaXNDbG9ja3dpc2UoKSkpXG5cdFx0XHRfcGF0aDIucmV2ZXJzZSgpO1xuXHRcdHZhciBpbnRlcnNlY3Rpb25zID0gQ3VydmVMb2NhdGlvbi5leHBhbmQoXG5cdFx0XHRfcGF0aDEuZ2V0SW50ZXJzZWN0aW9ucyhfcGF0aDIsIGZ1bmN0aW9uKGludGVyKSB7XG5cdFx0XHRcdHJldHVybiBfcGF0aDIgJiYgaW50ZXIuaXNPdmVybGFwKCkgfHwgaW50ZXIuaXNDcm9zc2luZygpO1xuXHRcdFx0fSlcblx0XHQpO1xuXHRcdGRpdmlkZUxvY2F0aW9ucyhpbnRlcnNlY3Rpb25zKTtcblxuXHRcdHZhciBzZWdtZW50cyA9IFtdLFxuXHRcdFx0bW9ub0N1cnZlcyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gY29sbGVjdChwYXRocykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHBhdGggPSBwYXRoc1tpXTtcblx0XHRcdFx0c2VnbWVudHMucHVzaC5hcHBseShzZWdtZW50cywgcGF0aC5fc2VnbWVudHMpO1xuXHRcdFx0XHRtb25vQ3VydmVzLnB1c2guYXBwbHkobW9ub0N1cnZlcywgcGF0aC5fZ2V0TW9ub0N1cnZlcygpKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRjb2xsZWN0KF9wYXRoMS5fY2hpbGRyZW4gfHwgW19wYXRoMV0pO1xuXHRcdGlmIChfcGF0aDIpXG5cdFx0XHRjb2xsZWN0KF9wYXRoMi5fY2hpbGRyZW4gfHwgW19wYXRoMl0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gaW50ZXJzZWN0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHByb3BhZ2F0ZVdpbmRpbmcoaW50ZXJzZWN0aW9uc1tpXS5fc2VnbWVudCwgX3BhdGgxLCBfcGF0aDIsXG5cdFx0XHRcdFx0bW9ub0N1cnZlcywgb3BlcmF0aW9uKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fd2luZGluZyA9PSBudWxsKSB7XG5cdFx0XHRcdHByb3BhZ2F0ZVdpbmRpbmcoc2VnbWVudCwgX3BhdGgxLCBfcGF0aDIsIG1vbm9DdXJ2ZXMsXG5cdFx0XHRcdFx0XHRvcGVyYXRpb24pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZmluaXNoQm9vbGVhbihDb21wb3VuZFBhdGgsIHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdGlvbiksXG5cdFx0XHRcdHBhdGgxLCBwYXRoMiwgdHJ1ZSk7XG5cdH1cblxuXHRmdW5jdGlvbiBjb21wdXRlT3BlbkJvb2xlYW4ocGF0aDEsIHBhdGgyLCBvcGVyYXRpb24pIHtcblx0XHRpZiAoIXBhdGgyIHx8ICFwYXRoMi5fY2hpbGRyZW4gJiYgIXBhdGgyLl9jbG9zZWRcblx0XHRcdFx0fHwgIS9eKHN1YnRyYWN0fGludGVyc2VjdCkkLy50ZXN0KG9wZXJhdGlvbikpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR2YXIgX3BhdGgxID0gcHJlcGFyZVBhdGgocGF0aDEsIGZhbHNlKSxcblx0XHRcdF9wYXRoMiA9IHByZXBhcmVQYXRoKHBhdGgyLCBmYWxzZSksXG5cdFx0XHRpbnRlcnNlY3Rpb25zID0gX3BhdGgxLmdldEludGVyc2VjdGlvbnMoX3BhdGgyLCBmdW5jdGlvbihpbnRlcikge1xuXHRcdFx0XHRyZXR1cm4gaW50ZXIuaXNPdmVybGFwKCkgfHwgaW50ZXIuaXNDcm9zc2luZygpO1xuXHRcdFx0fSksXG5cdFx0XHRzdWIgPSBvcGVyYXRpb24gPT09ICdzdWJ0cmFjdCcsXG5cdFx0XHRwYXRocyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYWRkUGF0aChwYXRoKSB7XG5cdFx0XHRpZiAoX3BhdGgyLmNvbnRhaW5zKHBhdGguZ2V0UG9pbnRBdChwYXRoLmdldExlbmd0aCgpIC8gMikpIF4gc3ViKSB7XG5cdFx0XHRcdHBhdGhzLnVuc2hpZnQocGF0aCk7XG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSBpbnRlcnNlY3Rpb25zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgcGF0aCA9IGludGVyc2VjdGlvbnNbaV0uc3BsaXQoKTtcblx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdGlmIChhZGRQYXRoKHBhdGgpKVxuXHRcdFx0XHRcdHBhdGguZ2V0Rmlyc3RTZWdtZW50KCkuc2V0SGFuZGxlSW4oMCwgMCk7XG5cdFx0XHRcdF9wYXRoMS5nZXRMYXN0U2VnbWVudCgpLnNldEhhbmRsZU91dCgwLCAwKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0YWRkUGF0aChfcGF0aDEpO1xuXHRcdHJldHVybiBmaW5pc2hCb29sZWFuKEdyb3VwLCBwYXRocywgcGF0aDEsIHBhdGgyKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxpbmtJbnRlcnNlY3Rpb25zKGZyb20sIHRvKSB7XG5cdFx0dmFyIHByZXYgPSBmcm9tO1xuXHRcdHdoaWxlIChwcmV2KSB7XG5cdFx0XHRpZiAocHJldiA9PT0gdG8pXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHByZXYgPSBwcmV2Ll9wcmV2O1xuXHRcdH1cblx0XHR3aGlsZSAoZnJvbS5fbmV4dCAmJiBmcm9tLl9uZXh0ICE9PSB0bylcblx0XHRcdGZyb20gPSBmcm9tLl9uZXh0O1xuXHRcdGlmICghZnJvbS5fbmV4dCkge1xuXHRcdFx0d2hpbGUgKHRvLl9wcmV2KVxuXHRcdFx0XHR0byA9IHRvLl9wcmV2O1xuXHRcdFx0ZnJvbS5fbmV4dCA9IHRvO1xuXHRcdFx0dG8uX3ByZXYgPSBmcm9tO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGRpdmlkZUxvY2F0aW9ucyhsb2NhdGlvbnMpIHtcblx0XHR2YXIgdE1pbiA9IDRlLTcsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHRub0hhbmRsZXMgPSBmYWxzZSxcblx0XHRcdGNsZWFyU2VnbWVudHMgPSBbXSxcblx0XHRcdHByZXZDdXJ2ZSxcblx0XHRcdHByZXZUO1xuXG5cdFx0Zm9yICh2YXIgaSA9IGxvY2F0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGxvYyA9IGxvY2F0aW9uc1tpXSxcblx0XHRcdFx0Y3VydmUgPSBsb2MuX2N1cnZlLFxuXHRcdFx0XHR0ID0gbG9jLl9wYXJhbWV0ZXIsXG5cdFx0XHRcdG9yaWdUID0gdDtcblx0XHRcdGlmIChjdXJ2ZSAhPT0gcHJldkN1cnZlKSB7XG5cdFx0XHRcdG5vSGFuZGxlcyA9ICFjdXJ2ZS5oYXNIYW5kbGVzKCk7XG5cdFx0XHR9IGVsc2UgaWYgKHByZXZUID4gMCkge1xuXHRcdFx0XHR0IC89IHByZXZUO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHNlZ21lbnQ7XG5cdFx0XHRpZiAodCA8IHRNaW4pIHtcblx0XHRcdFx0c2VnbWVudCA9IGN1cnZlLl9zZWdtZW50MTtcblx0XHRcdH0gZWxzZSBpZiAodCA+IHRNYXgpIHtcblx0XHRcdFx0c2VnbWVudCA9IGN1cnZlLl9zZWdtZW50Mjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5kaXZpZGUodCwgdHJ1ZSwgdHJ1ZSkuX3NlZ21lbnQxO1xuXHRcdFx0XHRpZiAobm9IYW5kbGVzKVxuXHRcdFx0XHRcdGNsZWFyU2VnbWVudHMucHVzaChzZWdtZW50KTtcblx0XHRcdH1cblx0XHRcdGxvYy5fc2V0U2VnbWVudChzZWdtZW50KTtcblx0XHRcdHZhciBpbnRlciA9IHNlZ21lbnQuX2ludGVyc2VjdGlvbixcblx0XHRcdFx0ZGVzdCA9IGxvYy5faW50ZXJzZWN0aW9uO1xuXHRcdFx0aWYgKGludGVyKSB7XG5cdFx0XHRcdGxpbmtJbnRlcnNlY3Rpb25zKGludGVyLCBkZXN0KTtcblx0XHRcdFx0dmFyIG90aGVyID0gaW50ZXI7XG5cdFx0XHRcdHdoaWxlIChvdGhlcikge1xuXHRcdFx0XHRcdGxpbmtJbnRlcnNlY3Rpb25zKG90aGVyLl9pbnRlcnNlY3Rpb24sIGludGVyKTtcblx0XHRcdFx0XHRvdGhlciA9IG90aGVyLl9uZXh0O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWdtZW50Ll9pbnRlcnNlY3Rpb24gPSBkZXN0O1xuXHRcdFx0fVxuXHRcdFx0cHJldkN1cnZlID0gY3VydmU7XG5cdFx0XHRwcmV2VCA9IG9yaWdUO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNsZWFyU2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjbGVhclNlZ21lbnRzW2ldLmNsZWFySGFuZGxlcygpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFdpbmRpbmcocG9pbnQsIGN1cnZlcywgaG9yaXpvbnRhbCwgdGVzdENvbnRhaW5zKSB7XG5cdFx0dmFyIGVwc2lsb24gPSAyZS03LFxuXHRcdFx0dE1pbiA9IDRlLTcsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHRweCA9IHBvaW50LngsXG5cdFx0XHRweSA9IHBvaW50LnksXG5cdFx0XHR3aW5kTGVmdCA9IDAsXG5cdFx0XHR3aW5kUmlnaHQgPSAwLFxuXHRcdFx0cm9vdHMgPSBbXSxcblx0XHRcdGFicyA9IE1hdGguYWJzO1xuXHRcdGlmIChob3Jpem9udGFsKSB7XG5cdFx0XHR2YXIgeVRvcCA9IC1JbmZpbml0eSxcblx0XHRcdFx0eUJvdHRvbSA9IEluZmluaXR5LFxuXHRcdFx0XHR5QmVmb3JlID0gcHkgLSBlcHNpbG9uLFxuXHRcdFx0XHR5QWZ0ZXIgPSBweSArIGVwc2lsb247XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlcyA9IGN1cnZlc1tpXS52YWx1ZXM7XG5cdFx0XHRcdGlmIChDdXJ2ZS5zb2x2ZUN1YmljKHZhbHVlcywgMCwgcHgsIHJvb3RzLCAwLCAxKSA+IDApIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gcm9vdHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0XHRcdHZhciB5ID0gQ3VydmUuZ2V0UG9pbnQodmFsdWVzLCByb290c1tqXSkueTtcblx0XHRcdFx0XHRcdGlmICh5IDwgeUJlZm9yZSAmJiB5ID4geVRvcCkge1xuXHRcdFx0XHRcdFx0XHR5VG9wID0geTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoeSA+IHlBZnRlciAmJiB5IDwgeUJvdHRvbSkge1xuXHRcdFx0XHRcdFx0XHR5Qm90dG9tID0geTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHlUb3AgPSAoeVRvcCArIHB5KSAvIDI7XG5cdFx0XHR5Qm90dG9tID0gKHlCb3R0b20gKyBweSkgLyAyO1xuXHRcdFx0aWYgKHlUb3AgPiAtSW5maW5pdHkpXG5cdFx0XHRcdHdpbmRMZWZ0ID0gZ2V0V2luZGluZyhuZXcgUG9pbnQocHgsIHlUb3ApLCBjdXJ2ZXMsIGZhbHNlLFxuXHRcdFx0XHRcdFx0dGVzdENvbnRhaW5zKTtcblx0XHRcdGlmICh5Qm90dG9tIDwgSW5maW5pdHkpXG5cdFx0XHRcdHdpbmRSaWdodCA9IGdldFdpbmRpbmcobmV3IFBvaW50KHB4LCB5Qm90dG9tKSwgY3VydmVzLCBmYWxzZSxcblx0XHRcdFx0XHRcdHRlc3RDb250YWlucyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB4QmVmb3JlID0gcHggLSBlcHNpbG9uLFxuXHRcdFx0XHR4QWZ0ZXIgPSBweCArIGVwc2lsb247XG5cdFx0XHR2YXIgc3RhcnRDb3VudGVkID0gZmFsc2UsXG5cdFx0XHRcdHByZXZDdXJ2ZSxcblx0XHRcdFx0cHJldlQ7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGN1cnZlID0gY3VydmVzW2ldLFxuXHRcdFx0XHRcdHZhbHVlcyA9IGN1cnZlLnZhbHVlcyxcblx0XHRcdFx0XHR3aW5kaW5nID0gY3VydmUud2luZGluZztcblx0XHRcdFx0aWYgKHdpbmRpbmcgJiYgKHdpbmRpbmcgPT09IDFcblx0XHRcdFx0XHRcdCYmIHB5ID49IHZhbHVlc1sxXSAmJiBweSA8PSB2YWx1ZXNbN11cblx0XHRcdFx0XHRcdHx8IHB5ID49IHZhbHVlc1s3XSAmJiBweSA8PSB2YWx1ZXNbMV0pXG5cdFx0XHRcdFx0JiYgQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDEsIHB5LCByb290cywgMCwgMSkgPT09IDEpIHtcblx0XHRcdFx0XHR2YXIgdCA9IHJvb3RzWzBdO1xuXHRcdFx0XHRcdGlmICghKFxuXHRcdFx0XHRcdFx0dCA+IHRNYXggJiYgc3RhcnRDb3VudGVkICYmIGN1cnZlLm5leHQgIT09IGN1cnZlc1tpICsgMV1cblx0XHRcdFx0XHRcdHx8IHQgPCB0TWluICYmIHByZXZUID4gdE1heFxuXHRcdFx0XHRcdFx0XHQmJiBjdXJ2ZS5wcmV2aW91cyA9PT0gcHJldkN1cnZlKSkge1xuXHRcdFx0XHRcdFx0dmFyIHggPSBDdXJ2ZS5nZXRQb2ludCh2YWx1ZXMsIHQpLngsXG5cdFx0XHRcdFx0XHRcdHNsb3BlID0gQ3VydmUuZ2V0VGFuZ2VudCh2YWx1ZXMsIHQpLnksXG5cdFx0XHRcdFx0XHRcdGNvdW50ZWQgPSBmYWxzZTtcblx0XHRcdFx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKHNsb3BlKSAmJiAhQ3VydmUuaXNTdHJhaWdodCh2YWx1ZXMpXG5cdFx0XHRcdFx0XHRcdFx0fHwgdCA8IHRNaW4gJiYgc2xvcGUgKiBDdXJ2ZS5nZXRUYW5nZW50KFxuXHRcdFx0XHRcdFx0XHRcdFx0Y3VydmUucHJldmlvdXMudmFsdWVzLCAxKS55IDwgMFxuXHRcdFx0XHRcdFx0XHRcdHx8IHQgPiB0TWF4ICYmIHNsb3BlICogQ3VydmUuZ2V0VGFuZ2VudChcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnZlLm5leHQudmFsdWVzLCAwKS55IDwgMCkge1xuXHRcdFx0XHRcdFx0XHRpZiAodGVzdENvbnRhaW5zICYmIHggPj0geEJlZm9yZSAmJiB4IDw9IHhBZnRlcikge1xuXHRcdFx0XHRcdFx0XHRcdCsrd2luZExlZnQ7XG5cdFx0XHRcdFx0XHRcdFx0Kyt3aW5kUmlnaHQ7XG5cdFx0XHRcdFx0XHRcdFx0Y291bnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoeCA8PSB4QmVmb3JlKSB7XG5cdFx0XHRcdFx0XHRcdHdpbmRMZWZ0ICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0XHRcdGNvdW50ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fSBlbHNlIGlmICh4ID49IHhBZnRlcikge1xuXHRcdFx0XHRcdFx0XHR3aW5kUmlnaHQgKz0gd2luZGluZztcblx0XHRcdFx0XHRcdFx0Y291bnRlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRpZiAoY3VydmUucHJldmlvdXMgIT09IGN1cnZlc1tpIC0gMV0pXG5cdFx0XHRcdFx0XHRcdHN0YXJ0Q291bnRlZCA9IHQgPCB0TWluICYmIGNvdW50ZWQ7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHByZXZDdXJ2ZSA9IGN1cnZlO1xuXHRcdFx0XHRcdHByZXZUID0gdDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gTWF0aC5tYXgoYWJzKHdpbmRMZWZ0KSwgYWJzKHdpbmRSaWdodCkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gcHJvcGFnYXRlV2luZGluZyhzZWdtZW50LCBwYXRoMSwgcGF0aDIsIG1vbm9DdXJ2ZXMsIG9wZXJhdGlvbikge1xuXHRcdHZhciBlcHNpbG9uID0gMmUtNyxcblx0XHRcdGNoYWluID0gW10sXG5cdFx0XHRzdGFydCA9IHNlZ21lbnQsXG5cdFx0XHR0b3RhbExlbmd0aCA9IDAsXG5cdFx0XHR3aW5kaW5nU3VtID0gMDtcblx0XHRkbyB7XG5cdFx0XHR2YXIgY3VydmUgPSBzZWdtZW50LmdldEN1cnZlKCksXG5cdFx0XHRcdGxlbmd0aCA9IGN1cnZlLmdldExlbmd0aCgpO1xuXHRcdFx0Y2hhaW4ucHVzaCh7IHNlZ21lbnQ6IHNlZ21lbnQsIGN1cnZlOiBjdXJ2ZSwgbGVuZ3RoOiBsZW5ndGggfSk7XG5cdFx0XHR0b3RhbExlbmd0aCArPSBsZW5ndGg7XG5cdFx0XHRzZWdtZW50ID0gc2VnbWVudC5nZXROZXh0KCk7XG5cdFx0fSB3aGlsZSAoc2VnbWVudCAmJiAhc2VnbWVudC5faW50ZXJzZWN0aW9uICYmIHNlZ21lbnQgIT09IHN0YXJ0KTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRvdGFsTGVuZ3RoICogKGkgKyAxKSAvIDQ7XG5cdFx0XHRmb3IgKHZhciBrID0gMCwgbSA9IGNoYWluLmxlbmd0aDsgayA8IG07IGsrKykge1xuXHRcdFx0XHR2YXIgbm9kZSA9IGNoYWluW2tdLFxuXHRcdFx0XHRcdGN1cnZlTGVuZ3RoID0gbm9kZS5sZW5ndGg7XG5cdFx0XHRcdGlmIChsZW5ndGggPD0gY3VydmVMZW5ndGgpIHtcblx0XHRcdFx0XHRpZiAobGVuZ3RoIDwgZXBzaWxvbiB8fCBjdXJ2ZUxlbmd0aCAtIGxlbmd0aCA8IGVwc2lsb24pXG5cdFx0XHRcdFx0XHRsZW5ndGggPSBjdXJ2ZUxlbmd0aCAvIDI7XG5cdFx0XHRcdFx0dmFyIGN1cnZlID0gbm9kZS5jdXJ2ZSxcblx0XHRcdFx0XHRcdHBhdGggPSBjdXJ2ZS5fcGF0aCxcblx0XHRcdFx0XHRcdHBhcmVudCA9IHBhdGguX3BhcmVudCxcblx0XHRcdFx0XHRcdHB0ID0gY3VydmUuZ2V0UG9pbnRBdChsZW5ndGgpLFxuXHRcdFx0XHRcdFx0aG9yID0gY3VydmUuaXNIb3Jpem9udGFsKCk7XG5cdFx0XHRcdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aClcblx0XHRcdFx0XHRcdHBhdGggPSBwYXJlbnQ7XG5cdFx0XHRcdFx0d2luZGluZ1N1bSArPSBvcGVyYXRpb24gPT09ICdzdWJ0cmFjdCcgJiYgcGF0aDJcblx0XHRcdFx0XHRcdCYmIChwYXRoID09PSBwYXRoMSAmJiBwYXRoMi5fZ2V0V2luZGluZyhwdCwgaG9yKVxuXHRcdFx0XHRcdFx0fHwgcGF0aCA9PT0gcGF0aDIgJiYgIXBhdGgxLl9nZXRXaW5kaW5nKHB0LCBob3IpKVxuXHRcdFx0XHRcdFx0PyAwXG5cdFx0XHRcdFx0XHQ6IGdldFdpbmRpbmcocHQsIG1vbm9DdXJ2ZXMsIGhvcik7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdFx0bGVuZ3RoIC09IGN1cnZlTGVuZ3RoO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgd2luZGluZyA9IE1hdGgucm91bmQod2luZGluZ1N1bSAvIDMpO1xuXHRcdGZvciAodmFyIGogPSBjaGFpbi5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcblx0XHRcdGNoYWluW2pdLnNlZ21lbnQuX3dpbmRpbmcgPSB3aW5kaW5nO1xuXHR9XG5cblx0ZnVuY3Rpb24gdHJhY2VQYXRocyhzZWdtZW50cywgb3BlcmF0aW9uKSB7XG5cdFx0dmFyIHBhdGhzID0gW10sXG5cdFx0XHRzdGFydCxcblx0XHRcdG90aGVyU3RhcnQsXG5cdFx0XHRvcGVyYXRvciA9IG9wZXJhdG9yc1tvcGVyYXRpb25dLFxuXHRcdFx0b3ZlcmxhcFdpbmRpbmcgPSB7XG5cdFx0XHRcdHVuaXRlOiB7IDE6IDIgfSxcblx0XHRcdFx0aW50ZXJzZWN0OiB7IDI6IDEgfVxuXHRcdFx0fVtvcGVyYXRpb25dO1xuXG5cdFx0ZnVuY3Rpb24gaXNWYWxpZChzZWcsIGFkanVzdGVkKSB7XG5cdFx0XHRpZiAoc2VnLl92aXNpdGVkKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRpZiAoIW9wZXJhdG9yKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdHZhciB3aW5kaW5nID0gc2VnLl93aW5kaW5nLFxuXHRcdFx0XHRpbnRlciA9IHNlZy5faW50ZXJzZWN0aW9uO1xuXHRcdFx0aWYgKGludGVyICYmIGFkanVzdGVkICYmIG92ZXJsYXBXaW5kaW5nICYmIGludGVyLmlzT3ZlcmxhcCgpKVxuXHRcdFx0XHR3aW5kaW5nID0gb3ZlcmxhcFdpbmRpbmdbd2luZGluZ10gfHwgd2luZGluZztcblx0XHRcdHJldHVybiBvcGVyYXRvcih3aW5kaW5nKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc1N0YXJ0KHNlZykge1xuXHRcdFx0cmV0dXJuIHNlZyA9PT0gc3RhcnQgfHwgc2VnID09PSBvdGhlclN0YXJ0O1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGZpbmRCZXN0SW50ZXJzZWN0aW9uKGludGVyLCBzdHJpY3QpIHtcblx0XHRcdGlmICghaW50ZXIuX25leHQpXG5cdFx0XHRcdHJldHVybiBpbnRlcjtcblx0XHRcdHdoaWxlIChpbnRlcikge1xuXHRcdFx0XHR2YXIgc2VnID0gaW50ZXIuX3NlZ21lbnQsXG5cdFx0XHRcdFx0bmV4dFNlZyA9IHNlZy5nZXROZXh0KCksXG5cdFx0XHRcdFx0bmV4dEludGVyID0gbmV4dFNlZy5faW50ZXJzZWN0aW9uO1xuXHRcdFx0XHRpZiAoaXNTdGFydChuZXh0U2VnKVxuXHRcdFx0XHRcdHx8ICFzZWcuX3Zpc2l0ZWQgJiYgIW5leHRTZWcuX3Zpc2l0ZWRcblx0XHRcdFx0XHQmJiAoIW9wZXJhdG9yXG5cdFx0XHRcdFx0XHR8fCAoIXN0cmljdCB8fCBpc1ZhbGlkKHNlZykpXG5cdFx0XHRcdFx0XHQmJiAoIShzdHJpY3QgJiYgbmV4dEludGVyICYmIG5leHRJbnRlci5pc092ZXJsYXAoKSlcblx0XHRcdFx0XHRcdFx0JiYgaXNWYWxpZChuZXh0U2VnKVxuXHRcdFx0XHRcdFx0XHR8fCAhc3RyaWN0ICYmIG5leHRJbnRlclxuXHRcdFx0XHRcdFx0XHQmJiBpc1ZhbGlkKG5leHRJbnRlci5fc2VnbWVudCkpXG5cdFx0XHRcdFx0KSlcblx0XHRcdFx0XHRyZXR1cm4gaW50ZXI7XG5cdFx0XHRcdGludGVyID0gaW50ZXIuX25leHQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaW5kU3RhcnRTZWdtZW50KGludGVyLCBuZXh0KSB7XG5cdFx0XHR3aGlsZSAoaW50ZXIpIHtcblx0XHRcdFx0dmFyIHNlZyA9IGludGVyLl9zZWdtZW50O1xuXHRcdFx0XHRpZiAoaXNTdGFydChzZWcpKVxuXHRcdFx0XHRcdHJldHVybiBzZWc7XG5cdFx0XHRcdGludGVyID0gaW50ZXJbbmV4dCA/ICdfbmV4dCcgOiAnX3ByZXYnXTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZyA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRwYXRoID0gbnVsbCxcblx0XHRcdFx0ZmluaXNoZWQgPSBmYWxzZTtcblx0XHRcdGlmICghaXNWYWxpZChzZWcsIHRydWUpKVxuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdHN0YXJ0ID0gb3RoZXJTdGFydCA9IG51bGw7XG5cdFx0XHR3aGlsZSAoIWZpbmlzaGVkKSB7XG5cdFx0XHRcdHZhciBpbnRlciA9IHNlZy5faW50ZXJzZWN0aW9uLFxuXHRcdFx0XHRcdGhhbmRsZUluID0gcGF0aCAmJiBzZWcuX2hhbmRsZUluO1xuXHRcdFx0XHRpbnRlciA9IGludGVyICYmIChmaW5kQmVzdEludGVyc2VjdGlvbihpbnRlciwgdHJ1ZSlcblx0XHRcdFx0XHRcdHx8IGZpbmRCZXN0SW50ZXJzZWN0aW9uKGludGVyLCBmYWxzZSkpIHx8IGludGVyO1xuXHRcdFx0XHR2YXIgb3RoZXIgPSBpbnRlciAmJiBpbnRlci5fc2VnbWVudDtcblx0XHRcdFx0aWYgKG90aGVyICYmIGlzVmFsaWQob3RoZXIpKVxuXHRcdFx0XHRcdHNlZyA9IG90aGVyO1xuXHRcdFx0XHRpZiAoc2VnLl92aXNpdGVkKSB7XG5cdFx0XHRcdFx0ZmluaXNoZWQgPSBpc1N0YXJ0KHNlZyk7XG5cdFx0XHRcdFx0aWYgKCFmaW5pc2hlZCAmJiBpbnRlcikge1xuXHRcdFx0XHRcdFx0dmFyIGZvdW5kID0gZmluZFN0YXJ0U2VnbWVudChpbnRlciwgdHJ1ZSlcblx0XHRcdFx0XHRcdFx0fHwgZmluZFN0YXJ0U2VnbWVudChpbnRlciwgZmFsc2UpO1xuXHRcdFx0XHRcdFx0aWYgKGZvdW5kKSB7XG5cdFx0XHRcdFx0XHRcdHNlZyA9IGZvdW5kO1xuXHRcdFx0XHRcdFx0XHRmaW5pc2hlZCA9IHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghcGF0aCkge1xuXHRcdFx0XHRcdHBhdGggPSBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRcdFx0c3RhcnQgPSBzZWc7XG5cdFx0XHRcdFx0b3RoZXJTdGFydCA9IG90aGVyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHBhdGguYWRkKG5ldyBTZWdtZW50KHNlZy5fcG9pbnQsIGhhbmRsZUluLCBzZWcuX2hhbmRsZU91dCkpO1xuXHRcdFx0XHRzZWcuX3Zpc2l0ZWQgPSB0cnVlO1xuXHRcdFx0XHRzZWcgPSBzZWcuZ2V0TmV4dCgpO1xuXHRcdFx0XHRmaW5pc2hlZCA9IGlzU3RhcnQoc2VnKTtcblx0XHRcdH1cblx0XHRcdGlmIChmaW5pc2hlZCkge1xuXHRcdFx0XHRwYXRoLmZpcnN0U2VnbWVudC5zZXRIYW5kbGVJbihzZWcuX2hhbmRsZUluKTtcblx0XHRcdFx0cGF0aC5zZXRDbG9zZWQodHJ1ZSk7XG5cdFx0XHR9IGVsc2UgaWYgKHBhdGgpIHtcblx0XHRcdFx0Y29uc29sZS5lcnJvcignQm9vbGVhbiBvcGVyYXRpb24gcmVzdWx0ZWQgaW4gb3BlbiBwYXRoJyxcblx0XHRcdFx0XHRcdCdzZWdtZW50cyA9JywgcGF0aC5fc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0XHRcdFx0J2xlbmd0aCA9JywgcGF0aC5nZXRMZW5ndGgoKSk7XG5cdFx0XHRcdHBhdGggPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHBhdGggJiYgKHBhdGguX3NlZ21lbnRzLmxlbmd0aCA+IDhcblx0XHRcdFx0XHR8fCAhTnVtZXJpY2FsLmlzWmVybyhwYXRoLmdldEFyZWEoKSkpKSB7XG5cdFx0XHRcdHBhdGhzLnB1c2gocGF0aCk7XG5cdFx0XHRcdHBhdGggPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gcGF0aHM7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdF9nZXRXaW5kaW5nOiBmdW5jdGlvbihwb2ludCwgaG9yaXpvbnRhbCwgdGVzdENvbnRhaW5zKSB7XG5cdFx0XHRyZXR1cm4gZ2V0V2luZGluZyhwb2ludCwgdGhpcy5fZ2V0TW9ub0N1cnZlcygpLFxuXHRcdFx0XHRcdGhvcml6b250YWwsIHRlc3RDb250YWlucyk7XG5cdFx0fSxcblxuXHRcdHVuaXRlOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gY29tcHV0ZUJvb2xlYW4odGhpcywgcGF0aCwgJ3VuaXRlJyk7XG5cdFx0fSxcblxuXHRcdGludGVyc2VjdDogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVCb29sZWFuKHRoaXMsIHBhdGgsICdpbnRlcnNlY3QnKTtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCAnc3VidHJhY3QnKTtcblx0XHR9LFxuXG5cdFx0ZXhjbHVkZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVCb29sZWFuKHRoaXMsIHBhdGgsICdleGNsdWRlJyk7XG5cdFx0fSxcblxuXHRcdGRpdmlkZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGZpbmlzaEJvb2xlYW4oR3JvdXAsXG5cdFx0XHRcdFx0W3RoaXMuc3VidHJhY3QocGF0aCksIHRoaXMuaW50ZXJzZWN0KHBhdGgpXSxcblx0XHRcdFx0XHR0aGlzLCBwYXRoLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0cmVzb2x2ZUNyb3NzaW5nczogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3Jvc3NpbmdzID0gdGhpcy5nZXRDcm9zc2luZ3MoKTtcblx0XHRcdGlmICghY3Jvc3NpbmdzLmxlbmd0aClcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRkaXZpZGVMb2NhdGlvbnMoQ3VydmVMb2NhdGlvbi5leHBhbmQoY3Jvc3NpbmdzKSk7XG5cdFx0XHR2YXIgcGF0aHMgPSB0aGlzLl9jaGlsZHJlbiB8fCBbdGhpc10sXG5cdFx0XHRcdHNlZ21lbnRzID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhdGhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRzZWdtZW50cy5wdXNoLmFwcGx5KHNlZ21lbnRzLCBwYXRoc1tpXS5fc2VnbWVudHMpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGZpbmlzaEJvb2xlYW4oQ29tcG91bmRQYXRoLCB0cmFjZVBhdGhzKHNlZ21lbnRzKSxcblx0XHRcdFx0XHR0aGlzLCBudWxsLCBmYWxzZSk7XG5cdFx0fVxuXHR9O1xufSk7XG5cblBhdGguaW5qZWN0KHtcblx0X2dldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtb25vQ3VydmVzID0gdGhpcy5fbW9ub0N1cnZlcyxcblx0XHRcdHByZXZDdXJ2ZTtcblxuXHRcdGZ1bmN0aW9uIGluc2VydEN1cnZlKHYpIHtcblx0XHRcdHZhciB5MCA9IHZbMV0sXG5cdFx0XHRcdHkxID0gdls3XSxcblx0XHRcdFx0Y3VydmUgPSB7XG5cdFx0XHRcdFx0dmFsdWVzOiB2LFxuXHRcdFx0XHRcdHdpbmRpbmc6IHkwID09PSB5MVxuXHRcdFx0XHRcdFx0PyAwXG5cdFx0XHRcdFx0XHQ6IHkwID4geTFcblx0XHRcdFx0XHRcdFx0PyAtMVxuXHRcdFx0XHRcdFx0XHQ6IDEsXG5cdFx0XHRcdFx0cHJldmlvdXM6IHByZXZDdXJ2ZSxcblx0XHRcdFx0XHRuZXh0OiBudWxsXG5cdFx0XHRcdH07XG5cdFx0XHRpZiAocHJldkN1cnZlKVxuXHRcdFx0XHRwcmV2Q3VydmUubmV4dCA9IGN1cnZlO1xuXHRcdFx0bW9ub0N1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRcdHByZXZDdXJ2ZSA9IGN1cnZlO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGhhbmRsZUN1cnZlKHYpIHtcblx0XHRcdGlmIChDdXJ2ZS5nZXRMZW5ndGgodikgPT09IDApXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciB5MCA9IHZbMV0sXG5cdFx0XHRcdHkxID0gdlszXSxcblx0XHRcdFx0eTIgPSB2WzVdLFxuXHRcdFx0XHR5MyA9IHZbN107XG5cdFx0XHRpZiAoQ3VydmUuaXNTdHJhaWdodCh2KSkge1xuXHRcdFx0XHRpbnNlcnRDdXJ2ZSh2KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhID0gMyAqICh5MSAtIHkyKSAtIHkwICsgeTMsXG5cdFx0XHRcdFx0YiA9IDIgKiAoeTAgKyB5MikgLSA0ICogeTEsXG5cdFx0XHRcdFx0YyA9IHkxIC0geTAsXG5cdFx0XHRcdFx0dE1pbiA9IDRlLTcsXG5cdFx0XHRcdFx0dE1heCA9IDEgLSB0TWluLFxuXHRcdFx0XHRcdHJvb3RzID0gW10sXG5cdFx0XHRcdFx0biA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiLCBjLCByb290cywgdE1pbiwgdE1heCk7XG5cdFx0XHRcdGlmIChuID09PSAwKSB7XG5cdFx0XHRcdFx0aW5zZXJ0Q3VydmUodik7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cm9vdHMuc29ydCgpO1xuXHRcdFx0XHRcdHZhciB0ID0gcm9vdHNbMF0sXG5cdFx0XHRcdFx0XHRwYXJ0cyA9IEN1cnZlLnN1YmRpdmlkZSh2LCB0KTtcblx0XHRcdFx0XHRpbnNlcnRDdXJ2ZShwYXJ0c1swXSk7XG5cdFx0XHRcdFx0aWYgKG4gPiAxKSB7XG5cdFx0XHRcdFx0XHR0ID0gKHJvb3RzWzFdIC0gdCkgLyAoMSAtIHQpO1xuXHRcdFx0XHRcdFx0cGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUocGFydHNbMV0sIHQpO1xuXHRcdFx0XHRcdFx0aW5zZXJ0Q3VydmUocGFydHNbMF0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpbnNlcnRDdXJ2ZShwYXJ0c1sxXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIW1vbm9DdXJ2ZXMpIHtcblx0XHRcdG1vbm9DdXJ2ZXMgPSB0aGlzLl9tb25vQ3VydmVzID0gW107XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKSxcblx0XHRcdFx0c2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aGFuZGxlQ3VydmUoY3VydmVzW2ldLmdldFZhbHVlcygpKTtcblx0XHRcdGlmICghdGhpcy5fY2xvc2VkICYmIHNlZ21lbnRzLmxlbmd0aCA+IDEpIHtcblx0XHRcdFx0dmFyIHAxID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uX3BvaW50LFxuXHRcdFx0XHRcdHAyID0gc2VnbWVudHNbMF0uX3BvaW50LFxuXHRcdFx0XHRcdHAxeCA9IHAxLl94LCBwMXkgPSBwMS5feSxcblx0XHRcdFx0XHRwMnggPSBwMi5feCwgcDJ5ID0gcDIuX3k7XG5cdFx0XHRcdGhhbmRsZUN1cnZlKFtwMXgsIHAxeSwgcDF4LCBwMXksIHAyeCwgcDJ5LCBwMngsIHAyeV0pO1xuXHRcdFx0fVxuXHRcdFx0aWYgKG1vbm9DdXJ2ZXMubGVuZ3RoID4gMCkge1xuXHRcdFx0XHR2YXIgZmlyc3QgPSBtb25vQ3VydmVzWzBdLFxuXHRcdFx0XHRcdGxhc3QgPSBtb25vQ3VydmVzW21vbm9DdXJ2ZXMubGVuZ3RoIC0gMV07XG5cdFx0XHRcdGZpcnN0LnByZXZpb3VzID0gbGFzdDtcblx0XHRcdFx0bGFzdC5uZXh0ID0gZmlyc3Q7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBtb25vQ3VydmVzO1xuXHR9LFxuXG5cdGdldEludGVyaW9yUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0cG9pbnQgPSBib3VuZHMuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdGlmICghdGhpcy5jb250YWlucyhwb2ludCkpIHtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9nZXRNb25vQ3VydmVzKCksXG5cdFx0XHRcdHJvb3RzID0gW10sXG5cdFx0XHRcdHkgPSBwb2ludC55LFxuXHRcdFx0XHR4SW50ZXJjZXB0cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBjdXJ2ZXNbaV0udmFsdWVzO1xuXHRcdFx0XHRpZiAoKGN1cnZlc1tpXS53aW5kaW5nID09PSAxXG5cdFx0XHRcdFx0XHQmJiB5ID49IHZhbHVlc1sxXSAmJiB5IDw9IHZhbHVlc1s3XVxuXHRcdFx0XHRcdFx0fHwgeSA+PSB2YWx1ZXNbN10gJiYgeSA8PSB2YWx1ZXNbMV0pXG5cdFx0XHRcdFx0XHQmJiBDdXJ2ZS5zb2x2ZUN1YmljKHZhbHVlcywgMSwgeSwgcm9vdHMsIDAsIDEpID4gMCkge1xuXHRcdFx0XHRcdGZvciAodmFyIGogPSByb290cy5sZW5ndGggLSAxOyBqID49IDA7IGotLSlcblx0XHRcdFx0XHRcdHhJbnRlcmNlcHRzLnB1c2goQ3VydmUuZ2V0UG9pbnQodmFsdWVzLCByb290c1tqXSkueCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHhJbnRlcmNlcHRzLmxlbmd0aCA+IDEpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRwb2ludC54ID0gKHhJbnRlcmNlcHRzWzBdICsgeEludGVyY2VwdHNbMV0pIC8gMjtcblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50O1xuXHR9LFxuXG5cdHJlb3JpZW50OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnNldENsb2Nrd2lzZSh0cnVlKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSk7XG5cbkNvbXBvdW5kUGF0aC5pbmplY3Qoe1xuXHRfZ2V0TW9ub0N1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRtb25vQ3VydmVzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRtb25vQ3VydmVzLnB1c2guYXBwbHkobW9ub0N1cnZlcywgY2hpbGRyZW5baV0uX2dldE1vbm9DdXJ2ZXMoKSk7XG5cdFx0cmV0dXJuIG1vbm9DdXJ2ZXM7XG5cdH0sXG5cblx0cmVvcmllbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMucmVtb3ZlQ2hpbGRyZW4oKS5zb3J0KGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBiLmdldEJvdW5kcygpLmdldEFyZWEoKSAtIGEuZ2V0Qm91bmRzKCkuZ2V0QXJlYSgpO1xuXHRcdH0pO1xuXHRcdGlmIChjaGlsZHJlbi5sZW5ndGggPiAwKSB7XG5cdFx0XHR0aGlzLmFkZENoaWxkcmVuKGNoaWxkcmVuKTtcblx0XHRcdHZhciBjbG9ja3dpc2UgPSBjaGlsZHJlblswXS5pc0Nsb2Nrd2lzZSgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHBvaW50ID0gY2hpbGRyZW5baV0uZ2V0SW50ZXJpb3JQb2ludCgpLFxuXHRcdFx0XHRcdGNvdW50ZXJzID0gMDtcblx0XHRcdFx0Zm9yICh2YXIgaiA9IGkgLSAxOyBqID49IDA7IGotLSkge1xuXHRcdFx0XHRcdGlmIChjaGlsZHJlbltqXS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0XHRjb3VudGVycysrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNoaWxkcmVuW2ldLnNldENsb2Nrd2lzZShjb3VudGVycyAlIDIgPT09IDAgJiYgY2xvY2t3aXNlKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG52YXIgUGF0aEl0ZXJhdG9yID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdQYXRoSXRlcmF0b3InLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKHBhdGgsIG1heFJlY3Vyc2lvbiwgdG9sZXJhbmNlLCBtYXRyaXgpIHtcblx0XHR2YXIgY3VydmVzID0gW10sXG5cdFx0XHRwYXJ0cyA9IFtdLFxuXHRcdFx0bGVuZ3RoID0gMCxcblx0XHRcdG1pbkRpZmZlcmVuY2UgPSAxIC8gKG1heFJlY3Vyc2lvbiB8fCAzMiksXG5cdFx0XHRzZWdtZW50cyA9IHBhdGguX3NlZ21lbnRzLFxuXHRcdFx0c2VnbWVudDEgPSBzZWdtZW50c1swXSxcblx0XHRcdHNlZ21lbnQyO1xuXG5cdFx0ZnVuY3Rpb24gYWRkQ3VydmUoc2VnbWVudDEsIHNlZ21lbnQyKSB7XG5cdFx0XHR2YXIgY3VydmUgPSBDdXJ2ZS5nZXRWYWx1ZXMoc2VnbWVudDEsIHNlZ21lbnQyLCBtYXRyaXgpO1xuXHRcdFx0Y3VydmVzLnB1c2goY3VydmUpO1xuXHRcdFx0Y29tcHV0ZVBhcnRzKGN1cnZlLCBzZWdtZW50MS5faW5kZXgsIDAsIDEpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNvbXB1dGVQYXJ0cyhjdXJ2ZSwgaW5kZXgsIG1pblQsIG1heFQpIHtcblx0XHRcdGlmICgobWF4VCAtIG1pblQpID4gbWluRGlmZmVyZW5jZVxuXHRcdFx0XHRcdCYmICFDdXJ2ZS5pc0ZsYXRFbm91Z2goY3VydmUsIHRvbGVyYW5jZSB8fCAwLjI1KSkge1xuXHRcdFx0XHR2YXIgc3BsaXQgPSBDdXJ2ZS5zdWJkaXZpZGUoY3VydmUsIDAuNSksXG5cdFx0XHRcdFx0aGFsZlQgPSAobWluVCArIG1heFQpIC8gMjtcblx0XHRcdFx0Y29tcHV0ZVBhcnRzKHNwbGl0WzBdLCBpbmRleCwgbWluVCwgaGFsZlQpO1xuXHRcdFx0XHRjb21wdXRlUGFydHMoc3BsaXRbMV0sIGluZGV4LCBoYWxmVCwgbWF4VCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgeCA9IGN1cnZlWzZdIC0gY3VydmVbMF0sXG5cdFx0XHRcdFx0eSA9IGN1cnZlWzddIC0gY3VydmVbMV0sXG5cdFx0XHRcdFx0ZGlzdCA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHRcdFx0aWYgKGRpc3QgPiAxZS02KSB7XG5cdFx0XHRcdFx0bGVuZ3RoICs9IGRpc3Q7XG5cdFx0XHRcdFx0cGFydHMucHVzaCh7XG5cdFx0XHRcdFx0XHRvZmZzZXQ6IGxlbmd0aCxcblx0XHRcdFx0XHRcdHZhbHVlOiBtYXhULFxuXHRcdFx0XHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0c2VnbWVudDIgPSBzZWdtZW50c1tpXTtcblx0XHRcdGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mik7XG5cdFx0XHRzZWdtZW50MSA9IHNlZ21lbnQyO1xuXHRcdH1cblx0XHRpZiAocGF0aC5fY2xvc2VkKVxuXHRcdFx0YWRkQ3VydmUoc2VnbWVudDIsIHNlZ21lbnRzWzBdKTtcblxuXHRcdHRoaXMuY3VydmVzID0gY3VydmVzO1xuXHRcdHRoaXMucGFydHMgPSBwYXJ0cztcblx0XHR0aGlzLmxlbmd0aCA9IGxlbmd0aDtcblx0XHR0aGlzLmluZGV4ID0gMDtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24ob2Zmc2V0KSB7XG5cdFx0dmFyIGksIGogPSB0aGlzLmluZGV4O1xuXHRcdGZvciAoOzspIHtcblx0XHRcdGkgPSBqO1xuXHRcdFx0aWYgKGogPT0gMCB8fCB0aGlzLnBhcnRzWy0tal0ub2Zmc2V0IDwgb2Zmc2V0KVxuXHRcdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Zm9yICh2YXIgbCA9IHRoaXMucGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcGFydCA9IHRoaXMucGFydHNbaV07XG5cdFx0XHRpZiAocGFydC5vZmZzZXQgPj0gb2Zmc2V0KSB7XG5cdFx0XHRcdHRoaXMuaW5kZXggPSBpO1xuXHRcdFx0XHR2YXIgcHJldiA9IHRoaXMucGFydHNbaSAtIDFdO1xuXHRcdFx0XHR2YXIgcHJldlZhbCA9IHByZXYgJiYgcHJldi5pbmRleCA9PSBwYXJ0LmluZGV4ID8gcHJldi52YWx1ZSA6IDAsXG5cdFx0XHRcdFx0cHJldkxlbiA9IHByZXYgPyBwcmV2Lm9mZnNldCA6IDA7XG5cdFx0XHRcdHJldHVybiB7XG5cdFx0XHRcdFx0dmFsdWU6IHByZXZWYWwgKyAocGFydC52YWx1ZSAtIHByZXZWYWwpXG5cdFx0XHRcdFx0XHQqIChvZmZzZXQgLSBwcmV2TGVuKSAvIChwYXJ0Lm9mZnNldCAtIHByZXZMZW4pLFxuXHRcdFx0XHRcdGluZGV4OiBwYXJ0LmluZGV4XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHZhciBwYXJ0ID0gdGhpcy5wYXJ0c1t0aGlzLnBhcnRzLmxlbmd0aCAtIDFdO1xuXHRcdHJldHVybiB7XG5cdFx0XHR2YWx1ZTogMSxcblx0XHRcdGluZGV4OiBwYXJ0LmluZGV4XG5cdFx0fTtcblx0fSxcblxuXHRkcmF3UGFydDogZnVuY3Rpb24oY3R4LCBmcm9tLCB0bykge1xuXHRcdGZyb20gPSB0aGlzLmdldFBhcmFtZXRlckF0KGZyb20pO1xuXHRcdHRvID0gdGhpcy5nZXRQYXJhbWV0ZXJBdCh0byk7XG5cdFx0Zm9yICh2YXIgaSA9IGZyb20uaW5kZXg7IGkgPD0gdG8uaW5kZXg7IGkrKykge1xuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmUuZ2V0UGFydCh0aGlzLmN1cnZlc1tpXSxcblx0XHRcdFx0XHRpID09IGZyb20uaW5kZXggPyBmcm9tLnZhbHVlIDogMCxcblx0XHRcdFx0XHRpID09IHRvLmluZGV4ID8gdG8udmFsdWUgOiAxKTtcblx0XHRcdGlmIChpID09IGZyb20uaW5kZXgpXG5cdFx0XHRcdGN0eC5tb3ZlVG8oY3VydmVbMF0sIGN1cnZlWzFdKTtcblx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvLmFwcGx5KGN0eCwgY3VydmUuc2xpY2UoMikpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKEN1cnZlLmV2YWx1YXRlTWV0aG9kcyxcblx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdHRoaXNbbmFtZSArICdBdCddID0gZnVuY3Rpb24ob2Zmc2V0LCB3ZWlnaHRlZCkge1xuXHRcdFx0dmFyIHBhcmFtID0gdGhpcy5nZXRQYXJhbWV0ZXJBdChvZmZzZXQpO1xuXHRcdFx0cmV0dXJuIEN1cnZlW25hbWVdKHRoaXMuY3VydmVzW3BhcmFtLmluZGV4XSwgcGFyYW0udmFsdWUsIHdlaWdodGVkKTtcblx0XHR9O1xuXHR9LCB7fSlcbik7XG5cbnZhciBQYXRoRml0dGVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBlcnJvcikge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyA9IFtdLFxuXHRcdFx0c2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdHByZXY7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwb2ludCA9IHNlZ21lbnRzW2ldLnBvaW50LmNsb25lKCk7XG5cdFx0XHRpZiAoIXByZXYgfHwgIXByZXYuZXF1YWxzKHBvaW50KSkge1xuXHRcdFx0XHRwb2ludHMucHVzaChwb2ludCk7XG5cdFx0XHRcdHByZXYgPSBwb2ludDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAocGF0aC5fY2xvc2VkKSB7XG5cdFx0XHR0aGlzLmNsb3NlZCA9IHRydWU7XG5cdFx0XHRwb2ludHMudW5zaGlmdChwb2ludHNbcG9pbnRzLmxlbmd0aCAtIDFdKTtcblx0XHRcdHBvaW50cy5wdXNoKHBvaW50c1sxXSk7XG5cdFx0fVxuXG5cdFx0dGhpcy5lcnJvciA9IGVycm9yO1xuXHR9LFxuXG5cdGZpdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50cyA9IHRoaXMucG9pbnRzLFxuXHRcdFx0bGVuZ3RoID0gcG9pbnRzLmxlbmd0aCxcblx0XHRcdHNlZ21lbnRzID0gdGhpcy5zZWdtZW50cyA9IGxlbmd0aCA+IDBcblx0XHRcdFx0XHQ/IFtuZXcgU2VnbWVudChwb2ludHNbMF0pXSA6IFtdO1xuXHRcdGlmIChsZW5ndGggPiAxKVxuXHRcdFx0dGhpcy5maXRDdWJpYygwLCBsZW5ndGggLSAxLFxuXHRcdFx0XHRwb2ludHNbMV0uc3VidHJhY3QocG9pbnRzWzBdKS5ub3JtYWxpemUoKSxcblx0XHRcdFx0cG9pbnRzW2xlbmd0aCAtIDJdLnN1YnRyYWN0KHBvaW50c1tsZW5ndGggLSAxXSkubm9ybWFsaXplKCkpO1xuXG5cdFx0aWYgKHRoaXMuY2xvc2VkKSB7XG5cdFx0XHRzZWdtZW50cy5zaGlmdCgpO1xuXHRcdFx0c2VnbWVudHMucG9wKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHNlZ21lbnRzO1xuXHR9LFxuXG5cdGZpdEN1YmljOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdGFuMSwgdGFuMikge1xuXHRcdGlmIChsYXN0IC0gZmlyc3QgPT0gMSkge1xuXHRcdFx0dmFyIHB0MSA9IHRoaXMucG9pbnRzW2ZpcnN0XSxcblx0XHRcdFx0cHQyID0gdGhpcy5wb2ludHNbbGFzdF0sXG5cdFx0XHRcdGRpc3QgPSBwdDEuZ2V0RGlzdGFuY2UocHQyKSAvIDM7XG5cdFx0XHR0aGlzLmFkZEN1cnZlKFtwdDEsIHB0MS5hZGQodGFuMS5ub3JtYWxpemUoZGlzdCkpLFxuXHRcdFx0XHRcdHB0Mi5hZGQodGFuMi5ub3JtYWxpemUoZGlzdCkpLCBwdDJdKTtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cdFx0dmFyIHVQcmltZSA9IHRoaXMuY2hvcmRMZW5ndGhQYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QpLFxuXHRcdFx0bWF4RXJyb3IgPSBNYXRoLm1heCh0aGlzLmVycm9yLCB0aGlzLmVycm9yICogdGhpcy5lcnJvciksXG5cdFx0XHRzcGxpdCxcblx0XHRcdHBhcmFtZXRlcnNJbk9yZGVyID0gdHJ1ZTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSA0OyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2VuZXJhdGVCZXppZXIoZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMik7XG5cdFx0XHR2YXIgbWF4ID0gdGhpcy5maW5kTWF4RXJyb3IoZmlyc3QsIGxhc3QsIGN1cnZlLCB1UHJpbWUpO1xuXHRcdFx0aWYgKG1heC5lcnJvciA8IHRoaXMuZXJyb3IgJiYgcGFyYW1ldGVyc0luT3JkZXIpIHtcblx0XHRcdFx0dGhpcy5hZGRDdXJ2ZShjdXJ2ZSk7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblx0XHRcdHNwbGl0ID0gbWF4LmluZGV4O1xuXHRcdFx0aWYgKG1heC5lcnJvciA+PSBtYXhFcnJvcilcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRwYXJhbWV0ZXJzSW5PcmRlciA9IHRoaXMucmVwYXJhbWV0ZXJpemUoZmlyc3QsIGxhc3QsIHVQcmltZSwgY3VydmUpO1xuXHRcdFx0bWF4RXJyb3IgPSBtYXguZXJyb3I7XG5cdFx0fVxuXHRcdHZhciBWMSA9IHRoaXMucG9pbnRzW3NwbGl0IC0gMV0uc3VidHJhY3QodGhpcy5wb2ludHNbc3BsaXRdKSxcblx0XHRcdFYyID0gdGhpcy5wb2ludHNbc3BsaXRdLnN1YnRyYWN0KHRoaXMucG9pbnRzW3NwbGl0ICsgMV0pLFxuXHRcdFx0dGFuQ2VudGVyID0gVjEuYWRkKFYyKS5kaXZpZGUoMikubm9ybWFsaXplKCk7XG5cdFx0dGhpcy5maXRDdWJpYyhmaXJzdCwgc3BsaXQsIHRhbjEsIHRhbkNlbnRlcik7XG5cdFx0dGhpcy5maXRDdWJpYyhzcGxpdCwgbGFzdCwgdGFuQ2VudGVyLm5lZ2F0ZSgpLCB0YW4yKTtcblx0fSxcblxuXHRhZGRDdXJ2ZTogZnVuY3Rpb24oY3VydmUpIHtcblx0XHR2YXIgcHJldiA9IHRoaXMuc2VnbWVudHNbdGhpcy5zZWdtZW50cy5sZW5ndGggLSAxXTtcblx0XHRwcmV2LnNldEhhbmRsZU91dChjdXJ2ZVsxXS5zdWJ0cmFjdChjdXJ2ZVswXSkpO1xuXHRcdHRoaXMuc2VnbWVudHMucHVzaChcblx0XHRcdFx0bmV3IFNlZ21lbnQoY3VydmVbM10sIGN1cnZlWzJdLnN1YnRyYWN0KGN1cnZlWzNdKSkpO1xuXHR9LFxuXG5cdGdlbmVyYXRlQmV6aWVyOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdVByaW1lLCB0YW4xLCB0YW4yKSB7XG5cdFx0dmFyIGVwc2lsb24gPSAxZS0xMixcblx0XHRcdHB0MSA9IHRoaXMucG9pbnRzW2ZpcnN0XSxcblx0XHRcdHB0MiA9IHRoaXMucG9pbnRzW2xhc3RdLFxuXHRcdFx0QyA9IFtbMCwgMF0sIFswLCAwXV0sXG5cdFx0XHRYID0gWzAsIDBdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsYXN0IC0gZmlyc3QgKyAxOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdSA9IHVQcmltZVtpXSxcblx0XHRcdFx0dCA9IDEgLSB1LFxuXHRcdFx0XHRiID0gMyAqIHUgKiB0LFxuXHRcdFx0XHRiMCA9IHQgKiB0ICogdCxcblx0XHRcdFx0YjEgPSBiICogdCxcblx0XHRcdFx0YjIgPSBiICogdSxcblx0XHRcdFx0YjMgPSB1ICogdSAqIHUsXG5cdFx0XHRcdGExID0gdGFuMS5ub3JtYWxpemUoYjEpLFxuXHRcdFx0XHRhMiA9IHRhbjIubm9ybWFsaXplKGIyKSxcblx0XHRcdFx0dG1wID0gdGhpcy5wb2ludHNbZmlyc3QgKyBpXVxuXHRcdFx0XHRcdC5zdWJ0cmFjdChwdDEubXVsdGlwbHkoYjAgKyBiMSkpXG5cdFx0XHRcdFx0LnN1YnRyYWN0KHB0Mi5tdWx0aXBseShiMiArIGIzKSk7XG5cdFx0XHRDWzBdWzBdICs9IGExLmRvdChhMSk7XG5cdFx0XHRDWzBdWzFdICs9IGExLmRvdChhMik7XG5cdFx0XHRDWzFdWzBdID0gQ1swXVsxXTtcblx0XHRcdENbMV1bMV0gKz0gYTIuZG90KGEyKTtcblx0XHRcdFhbMF0gKz0gYTEuZG90KHRtcCk7XG5cdFx0XHRYWzFdICs9IGEyLmRvdCh0bXApO1xuXHRcdH1cblxuXHRcdHZhciBkZXRDMEMxID0gQ1swXVswXSAqIENbMV1bMV0gLSBDWzFdWzBdICogQ1swXVsxXSxcblx0XHRcdGFscGhhMSwgYWxwaGEyO1xuXHRcdGlmIChNYXRoLmFicyhkZXRDMEMxKSA+IGVwc2lsb24pIHtcblx0XHRcdHZhciBkZXRDMFhcdD0gQ1swXVswXSAqIFhbMV1cdC0gQ1sxXVswXSAqIFhbMF0sXG5cdFx0XHRcdGRldFhDMVx0PSBYWzBdXHQgICogQ1sxXVsxXSAtIFhbMV1cdCAgKiBDWzBdWzFdO1xuXHRcdFx0YWxwaGExID0gZGV0WEMxIC8gZGV0QzBDMTtcblx0XHRcdGFscGhhMiA9IGRldEMwWCAvIGRldEMwQzE7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjMCA9IENbMF1bMF0gKyBDWzBdWzFdLFxuXHRcdFx0XHRjMSA9IENbMV1bMF0gKyBDWzFdWzFdO1xuXHRcdFx0aWYgKE1hdGguYWJzKGMwKSA+IGVwc2lsb24pIHtcblx0XHRcdFx0YWxwaGExID0gYWxwaGEyID0gWFswXSAvIGMwO1xuXHRcdFx0fSBlbHNlIGlmIChNYXRoLmFicyhjMSkgPiBlcHNpbG9uKSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IFhbMV0gLyBjMTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IDA7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIHNlZ0xlbmd0aCA9IHB0Mi5nZXREaXN0YW5jZShwdDEpLFxuXHRcdFx0ZXBzID0gZXBzaWxvbiAqIHNlZ0xlbmd0aCxcblx0XHRcdGhhbmRsZTEsXG5cdFx0XHRoYW5kbGUyO1xuXHRcdGlmIChhbHBoYTEgPCBlcHMgfHwgYWxwaGEyIDwgZXBzKSB7XG5cdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBzZWdMZW5ndGggLyAzO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgbGluZSA9IHB0Mi5zdWJ0cmFjdChwdDEpO1xuXHRcdFx0aGFuZGxlMSA9IHRhbjEubm9ybWFsaXplKGFscGhhMSk7XG5cdFx0XHRoYW5kbGUyID0gdGFuMi5ub3JtYWxpemUoYWxwaGEyKTtcblx0XHRcdGlmIChoYW5kbGUxLmRvdChsaW5lKSAtIGhhbmRsZTIuZG90KGxpbmUpID4gc2VnTGVuZ3RoICogc2VnTGVuZ3RoKSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IHNlZ0xlbmd0aCAvIDM7XG5cdFx0XHRcdGhhbmRsZTEgPSBoYW5kbGUyID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gW3B0MSwgcHQxLmFkZChoYW5kbGUxIHx8IHRhbjEubm9ybWFsaXplKGFscGhhMSkpLFxuXHRcdFx0XHRwdDIuYWRkKGhhbmRsZTIgfHwgdGFuMi5ub3JtYWxpemUoYWxwaGEyKSksIHB0Ml07XG5cdH0sXG5cblx0cmVwYXJhbWV0ZXJpemU6IGZ1bmN0aW9uKGZpcnN0LCBsYXN0LCB1LCBjdXJ2ZSkge1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdDsgaSA8PSBsYXN0OyBpKyspIHtcblx0XHRcdHVbaSAtIGZpcnN0XSA9IHRoaXMuZmluZFJvb3QoY3VydmUsIHRoaXMucG9pbnRzW2ldLCB1W2kgLSBmaXJzdF0pO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRpZiAodVtpXSA8PSB1W2kgLSAxXSlcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRmaW5kUm9vdDogZnVuY3Rpb24oY3VydmUsIHBvaW50LCB1KSB7XG5cdFx0dmFyIGN1cnZlMSA9IFtdLFxuXHRcdFx0Y3VydmUyID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gMjsgaSsrKSB7XG5cdFx0XHRjdXJ2ZTFbaV0gPSBjdXJ2ZVtpICsgMV0uc3VidHJhY3QoY3VydmVbaV0pLm11bHRpcGx5KDMpO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSAxOyBpKyspIHtcblx0XHRcdGN1cnZlMltpXSA9IGN1cnZlMVtpICsgMV0uc3VidHJhY3QoY3VydmUxW2ldKS5tdWx0aXBseSgyKTtcblx0XHR9XG5cdFx0dmFyIHB0ID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdSksXG5cdFx0XHRwdDEgPSB0aGlzLmV2YWx1YXRlKDIsIGN1cnZlMSwgdSksXG5cdFx0XHRwdDIgPSB0aGlzLmV2YWx1YXRlKDEsIGN1cnZlMiwgdSksXG5cdFx0XHRkaWZmID0gcHQuc3VidHJhY3QocG9pbnQpLFxuXHRcdFx0ZGYgPSBwdDEuZG90KHB0MSkgKyBkaWZmLmRvdChwdDIpO1xuXHRcdGlmIChNYXRoLmFicyhkZikgPCAxZS02KVxuXHRcdFx0cmV0dXJuIHU7XG5cdFx0cmV0dXJuIHUgLSBkaWZmLmRvdChwdDEpIC8gZGY7XG5cdH0sXG5cblx0ZXZhbHVhdGU6IGZ1bmN0aW9uKGRlZ3JlZSwgY3VydmUsIHQpIHtcblx0XHR2YXIgdG1wID0gY3VydmUuc2xpY2UoKTtcblx0XHRmb3IgKHZhciBpID0gMTsgaSA8PSBkZWdyZWU7IGkrKykge1xuXHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPD0gZGVncmVlIC0gaTsgaisrKSB7XG5cdFx0XHRcdHRtcFtqXSA9IHRtcFtqXS5tdWx0aXBseSgxIC0gdCkuYWRkKHRtcFtqICsgMV0ubXVsdGlwbHkodCkpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdG1wWzBdO1xuXHR9LFxuXG5cdGNob3JkTGVuZ3RoUGFyYW1ldGVyaXplOiBmdW5jdGlvbihmaXJzdCwgbGFzdCkge1xuXHRcdHZhciB1ID0gWzBdO1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPD0gbGFzdDsgaSsrKSB7XG5cdFx0XHR1W2kgLSBmaXJzdF0gPSB1W2kgLSBmaXJzdCAtIDFdXG5cdFx0XHRcdFx0KyB0aGlzLnBvaW50c1tpXS5nZXREaXN0YW5jZSh0aGlzLnBvaW50c1tpIC0gMV0pO1xuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMSwgbSA9IGxhc3QgLSBmaXJzdDsgaSA8PSBtOyBpKyspIHtcblx0XHRcdHVbaV0gLz0gdVttXTtcblx0XHR9XG5cdFx0cmV0dXJuIHU7XG5cdH0sXG5cblx0ZmluZE1heEVycm9yOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgY3VydmUsIHUpIHtcblx0XHR2YXIgaW5kZXggPSBNYXRoLmZsb29yKChsYXN0IC0gZmlyc3QgKyAxKSAvIDIpLFxuXHRcdFx0bWF4RGlzdCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IGZpcnN0ICsgMTsgaSA8IGxhc3Q7IGkrKykge1xuXHRcdFx0dmFyIFAgPSB0aGlzLmV2YWx1YXRlKDMsIGN1cnZlLCB1W2kgLSBmaXJzdF0pO1xuXHRcdFx0dmFyIHYgPSBQLnN1YnRyYWN0KHRoaXMucG9pbnRzW2ldKTtcblx0XHRcdHZhciBkaXN0ID0gdi54ICogdi54ICsgdi55ICogdi55O1xuXHRcdFx0aWYgKGRpc3QgPj0gbWF4RGlzdCkge1xuXHRcdFx0XHRtYXhEaXN0ID0gZGlzdDtcblx0XHRcdFx0aW5kZXggPSBpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4ge1xuXHRcdFx0ZXJyb3I6IG1heERpc3QsXG5cdFx0XHRpbmRleDogaW5kZXhcblx0XHR9O1xuXHR9XG59KTtcblxudmFyIFRleHRJdGVtID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdUZXh0SXRlbScsXG5cdF9ib3VuZHNTZWxlY3RlZDogdHJ1ZSxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdGNvbnRlbnQ6IG51bGxcblx0fSxcblx0X2JvdW5kc0dldHRlcjogJ2dldEJvdW5kcycsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVGV4dEl0ZW0oYXJnKSB7XG5cdFx0dGhpcy5fY29udGVudCA9ICcnO1xuXHRcdHRoaXMuX2xpbmVzID0gW107XG5cdFx0dmFyIGhhc1Byb3BzID0gYXJnICYmIEJhc2UuaXNQbGFpbk9iamVjdChhcmcpXG5cdFx0XHRcdCYmIGFyZy54ID09PSB1bmRlZmluZWQgJiYgYXJnLnkgPT09IHVuZGVmaW5lZDtcblx0XHR0aGlzLl9pbml0aWFsaXplKGhhc1Byb3BzICYmIGFyZywgIWhhc1Byb3BzICYmIFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiB0aGlzLl9jb250ZW50ID09PSBpdGVtLl9jb250ZW50O1xuXHR9LFxuXG5cdF9jbG9uZTogZnVuY3Rpb24gX2Nsb25lKGNvcHksIGluc2VydCwgaW5jbHVkZU1hdHJpeCkge1xuXHRcdGNvcHkuc2V0Q29udGVudCh0aGlzLl9jb250ZW50KTtcblx0XHRyZXR1cm4gX2Nsb25lLmJhc2UuY2FsbCh0aGlzLCBjb3B5LCBpbnNlcnQsIGluY2x1ZGVNYXRyaXgpO1xuXHR9LFxuXG5cdGdldENvbnRlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jb250ZW50O1xuXHR9LFxuXG5cdHNldENvbnRlbnQ6IGZ1bmN0aW9uKGNvbnRlbnQpIHtcblx0XHR0aGlzLl9jb250ZW50ID0gJycgKyBjb250ZW50O1xuXHRcdHRoaXMuX2xpbmVzID0gdGhpcy5fY29udGVudC5zcGxpdCgvXFxyXFxufFxcbnxcXHIvbWcpO1xuXHRcdHRoaXMuX2NoYW5nZWQoMjY1KTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2NvbnRlbnQ7XG5cdH0sXG5cblx0Z2V0Q2hhcmFjdGVyU3R5bGU6ICcjZ2V0U3R5bGUnLFxuXHRzZXRDaGFyYWN0ZXJTdHlsZTogJyNzZXRTdHlsZScsXG5cblx0Z2V0UGFyYWdyYXBoU3R5bGU6ICcjZ2V0U3R5bGUnLFxuXHRzZXRQYXJhZ3JhcGhTdHlsZTogJyNzZXRTdHlsZSdcbn0pO1xuXG52YXIgUG9pbnRUZXh0ID0gVGV4dEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUG9pbnRUZXh0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQb2ludFRleHQoKSB7XG5cdFx0VGV4dEl0ZW0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKG5ldyBQb2ludFRleHQoSXRlbS5OT19JTlNFUlQpLCBpbnNlcnQpO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSB0aGlzLl9tYXRyaXguZ2V0VHJhbnNsYXRpb24oKTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFBvaW50KHBvaW50LngsIHBvaW50LnksIHRoaXMsICdzZXRQb2ludCcpO1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy50cmFuc2xhdGUocG9pbnQuc3VidHJhY3QodGhpcy5fbWF0cml4LmdldFRyYW5zbGF0aW9uKCkpKTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4KSB7XG5cdFx0aWYgKCF0aGlzLl9jb250ZW50KVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuX3NldFN0eWxlcyhjdHgpO1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0bGluZXMgPSB0aGlzLl9saW5lcyxcblx0XHRcdGxlYWRpbmcgPSBzdHlsZS5nZXRMZWFkaW5nKCksXG5cdFx0XHRzaGFkb3dDb2xvciA9IGN0eC5zaGFkb3dDb2xvcjtcblx0XHRjdHguZm9udCA9IHN0eWxlLmdldEZvbnRTdHlsZSgpO1xuXHRcdGN0eC50ZXh0QWxpZ24gPSBzdHlsZS5nZXRKdXN0aWZpY2F0aW9uKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBsaW5lcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yO1xuXHRcdFx0dmFyIGxpbmUgPSBsaW5lc1tpXTtcblx0XHRcdGlmIChzdHlsZS5oYXNGaWxsKCkpIHtcblx0XHRcdFx0Y3R4LmZpbGxUZXh0KGxpbmUsIDAsIDApO1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc3R5bGUuaGFzU3Ryb2tlKCkpXG5cdFx0XHRcdGN0eC5zdHJva2VUZXh0KGxpbmUsIDAsIDApO1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgwLCBsZWFkaW5nKTtcblx0XHR9XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGxpbmVzID0gdGhpcy5fbGluZXMsXG5cdFx0XHRudW1MaW5lcyA9IGxpbmVzLmxlbmd0aCxcblx0XHRcdGp1c3RpZmljYXRpb24gPSBzdHlsZS5nZXRKdXN0aWZpY2F0aW9uKCksXG5cdFx0XHRsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuXHRcdFx0d2lkdGggPSB0aGlzLmdldFZpZXcoKS5nZXRUZXh0V2lkdGgoc3R5bGUuZ2V0Rm9udFN0eWxlKCksIGxpbmVzKSxcblx0XHRcdHggPSAwO1xuXHRcdGlmIChqdXN0aWZpY2F0aW9uICE9PSAnbGVmdCcpXG5cdFx0XHR4IC09IHdpZHRoIC8gKGp1c3RpZmljYXRpb24gPT09ICdjZW50ZXInID8gMjogMSk7XG5cdFx0dmFyIGJvdW5kcyA9IG5ldyBSZWN0YW5nbGUoeCxcblx0XHRcdFx0XHRudW1MaW5lcyA/IC0gMC43NSAqIGxlYWRpbmcgOiAwLFxuXHRcdFx0XHRcdHdpZHRoLCBudW1MaW5lcyAqIGxlYWRpbmcpO1xuXHRcdHJldHVybiBtYXRyaXggPyBtYXRyaXguX3RyYW5zZm9ybUJvdW5kcyhib3VuZHMsIGJvdW5kcykgOiBib3VuZHM7XG5cdH1cbn0pO1xuXG52YXIgQ29sb3IgPSBCYXNlLmV4dGVuZChuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciB0eXBlcyA9IHtcblx0XHRncmF5OiBbJ2dyYXknXSxcblx0XHRyZ2I6IFsncmVkJywgJ2dyZWVuJywgJ2JsdWUnXSxcblx0XHRoc2I6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnYnJpZ2h0bmVzcyddLFxuXHRcdGhzbDogWydodWUnLCAnc2F0dXJhdGlvbicsICdsaWdodG5lc3MnXSxcblx0XHRncmFkaWVudDogWydncmFkaWVudCcsICdvcmlnaW4nLCAnZGVzdGluYXRpb24nLCAnaGlnaGxpZ2h0J11cblx0fTtcblxuXHR2YXIgY29tcG9uZW50UGFyc2VycyA9IHt9LFxuXHRcdGNvbG9yQ2FjaGUgPSB7fSxcblx0XHRjb2xvckN0eDtcblxuXHRmdW5jdGlvbiBmcm9tQ1NTKHN0cmluZykge1xuXHRcdHZhciBtYXRjaCA9IHN0cmluZy5tYXRjaCgvXiMoXFx3ezEsMn0pKFxcd3sxLDJ9KShcXHd7MSwyfSkkLyksXG5cdFx0XHRjb21wb25lbnRzO1xuXHRcdGlmIChtYXRjaCkge1xuXHRcdFx0Y29tcG9uZW50cyA9IFswLCAwLCAwXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgMzsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IG1hdGNoW2kgKyAxXTtcblx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHBhcnNlSW50KHZhbHVlLmxlbmd0aCA9PSAxXG5cdFx0XHRcdFx0XHQ/IHZhbHVlICsgdmFsdWUgOiB2YWx1ZSwgMTYpIC8gMjU1O1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAobWF0Y2ggPSBzdHJpbmcubWF0Y2goL15yZ2JhP1xcKCguKilcXCkkLykpIHtcblx0XHRcdGNvbXBvbmVudHMgPSBtYXRjaFsxXS5zcGxpdCgnLCcpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb21wb25lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSArY29tcG9uZW50c1tpXTtcblx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IGkgPCAzID8gdmFsdWUgLyAyNTUgOiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGNhY2hlZCA9IGNvbG9yQ2FjaGVbc3RyaW5nXTtcblx0XHRcdGlmICghY2FjaGVkKSB7XG5cdFx0XHRcdGlmICghY29sb3JDdHgpIHtcblx0XHRcdFx0XHRjb2xvckN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG5cdFx0XHRcdFx0Y29sb3JDdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gJ2NvcHknO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGNvbG9yQ3R4LmZpbGxTdHlsZSA9ICdyZ2JhKDAsMCwwLDApJztcblx0XHRcdFx0Y29sb3JDdHguZmlsbFN0eWxlID0gc3RyaW5nO1xuXHRcdFx0XHRjb2xvckN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblx0XHRcdFx0dmFyIGRhdGEgPSBjb2xvckN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YTtcblx0XHRcdFx0Y2FjaGVkID0gY29sb3JDYWNoZVtzdHJpbmddID0gW1xuXHRcdFx0XHRcdGRhdGFbMF0gLyAyNTUsXG5cdFx0XHRcdFx0ZGF0YVsxXSAvIDI1NSxcblx0XHRcdFx0XHRkYXRhWzJdIC8gMjU1XG5cdFx0XHRcdF07XG5cdFx0XHR9XG5cdFx0XHRjb21wb25lbnRzID0gY2FjaGVkLnNsaWNlKCk7XG5cdFx0fVxuXHRcdHJldHVybiBjb21wb25lbnRzO1xuXHR9XG5cblx0dmFyIGhzYkluZGljZXMgPSBbXG5cdFx0WzAsIDMsIDFdLFxuXHRcdFsyLCAwLCAxXSxcblx0XHRbMSwgMCwgM10sXG5cdFx0WzEsIDIsIDBdLFxuXHRcdFszLCAxLCAwXSxcblx0XHRbMCwgMSwgMl1cblx0XTtcblxuXHR2YXIgY29udmVydGVycyA9IHtcblx0XHQncmdiLWhzYic6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcblx0XHRcdFx0bWluID0gTWF0aC5taW4ociwgZywgYiksXG5cdFx0XHRcdGRlbHRhID0gbWF4IC0gbWluLFxuXHRcdFx0XHRoID0gZGVsdGEgPT09IDAgPyAwXG5cdFx0XHRcdFx0Olx0KCBtYXggPT0gciA/IChnIC0gYikgLyBkZWx0YSArIChnIDwgYiA/IDYgOiAwKVxuXHRcdFx0XHRcdFx0OiBtYXggPT0gZyA/IChiIC0gcikgLyBkZWx0YSArIDJcblx0XHRcdFx0XHRcdDpcdFx0XHQgKHIgLSBnKSAvIGRlbHRhICsgNCkgKiA2MDtcblx0XHRcdHJldHVybiBbaCwgbWF4ID09PSAwID8gMCA6IGRlbHRhIC8gbWF4LCBtYXhdO1xuXHRcdH0sXG5cblx0XHQnaHNiLXJnYic6IGZ1bmN0aW9uKGgsIHMsIGIpIHtcblx0XHRcdGggPSAoKChoIC8gNjApICUgNikgKyA2KSAlIDY7XG5cdFx0XHR2YXIgaSA9IE1hdGguZmxvb3IoaCksXG5cdFx0XHRcdGYgPSBoIC0gaSxcblx0XHRcdFx0aSA9IGhzYkluZGljZXNbaV0sXG5cdFx0XHRcdHYgPSBbXG5cdFx0XHRcdFx0Yixcblx0XHRcdFx0XHRiICogKDEgLSBzKSxcblx0XHRcdFx0XHRiICogKDEgLSBzICogZiksXG5cdFx0XHRcdFx0YiAqICgxIC0gcyAqICgxIC0gZikpXG5cdFx0XHRcdF07XG5cdFx0XHRyZXR1cm4gW3ZbaVswXV0sIHZbaVsxXV0sIHZbaVsyXV1dO1xuXHRcdH0sXG5cblx0XHQncmdiLWhzbCc6IGZ1bmN0aW9uKHIsIGcsIGIpIHtcblx0XHRcdHZhciBtYXggPSBNYXRoLm1heChyLCBnLCBiKSxcblx0XHRcdFx0bWluID0gTWF0aC5taW4ociwgZywgYiksXG5cdFx0XHRcdGRlbHRhID0gbWF4IC0gbWluLFxuXHRcdFx0XHRhY2hyb21hdGljID0gZGVsdGEgPT09IDAsXG5cdFx0XHRcdGggPSBhY2hyb21hdGljID8gMFxuXHRcdFx0XHRcdDpcdCggbWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMClcblx0XHRcdFx0XHRcdDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyXG5cdFx0XHRcdFx0XHQ6XHRcdFx0IChyIC0gZykgLyBkZWx0YSArIDQpICogNjAsXG5cdFx0XHRcdGwgPSAobWF4ICsgbWluKSAvIDIsXG5cdFx0XHRcdHMgPSBhY2hyb21hdGljID8gMCA6IGwgPCAwLjVcblx0XHRcdFx0XHRcdD8gZGVsdGEgLyAobWF4ICsgbWluKVxuXHRcdFx0XHRcdFx0OiBkZWx0YSAvICgyIC0gbWF4IC0gbWluKTtcblx0XHRcdHJldHVybiBbaCwgcywgbF07XG5cdFx0fSxcblxuXHRcdCdoc2wtcmdiJzogZnVuY3Rpb24oaCwgcywgbCkge1xuXHRcdFx0aCA9ICgoKGggLyAzNjApICUgMSkgKyAxKSAlIDE7XG5cdFx0XHRpZiAocyA9PT0gMClcblx0XHRcdFx0cmV0dXJuIFtsLCBsLCBsXTtcblx0XHRcdHZhciB0M3MgPSBbIGggKyAxIC8gMywgaCwgaCAtIDEgLyAzIF0sXG5cdFx0XHRcdHQyID0gbCA8IDAuNSA/IGwgKiAoMSArIHMpIDogbCArIHMgLSBsICogcyxcblx0XHRcdFx0dDEgPSAyICogbCAtIHQyLFxuXHRcdFx0XHRjID0gW107XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0XHR2YXIgdDMgPSB0M3NbaV07XG5cdFx0XHRcdGlmICh0MyA8IDApIHQzICs9IDE7XG5cdFx0XHRcdGlmICh0MyA+IDEpIHQzIC09IDE7XG5cdFx0XHRcdGNbaV0gPSA2ICogdDMgPCAxXG5cdFx0XHRcdFx0PyB0MSArICh0MiAtIHQxKSAqIDYgKiB0M1xuXHRcdFx0XHRcdDogMiAqIHQzIDwgMVxuXHRcdFx0XHRcdFx0PyB0MlxuXHRcdFx0XHRcdFx0OiAzICogdDMgPCAyXG5cdFx0XHRcdFx0XHRcdD8gdDEgKyAodDIgLSB0MSkgKiAoKDIgLyAzKSAtIHQzKSAqIDZcblx0XHRcdFx0XHRcdFx0OiB0MTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBjO1xuXHRcdH0sXG5cblx0XHQncmdiLWdyYXknOiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdFx0XHRyZXR1cm4gW3IgKiAwLjI5ODkgKyBnICogMC41ODcgKyBiICogMC4xMTRdO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1yZ2InOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gW2csIGcsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1oc2InOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gWzAsIDAsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JheS1oc2wnOiBmdW5jdGlvbihnKSB7XG5cdFx0XHRyZXR1cm4gWzAsIDAsIGddO1xuXHRcdH0sXG5cblx0XHQnZ3JhZGllbnQtcmdiJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fSxcblxuXHRcdCdyZ2ItZ3JhZGllbnQnOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbXTtcblx0XHR9XG5cblx0fTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKHR5cGVzLCBmdW5jdGlvbihwcm9wZXJ0aWVzLCB0eXBlKSB7XG5cdFx0Y29tcG9uZW50UGFyc2Vyc1t0eXBlXSA9IFtdO1xuXHRcdEJhc2UuZWFjaChwcm9wZXJ0aWVzLCBmdW5jdGlvbihuYW1lLCBpbmRleCkge1xuXHRcdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRcdGhhc092ZXJsYXAgPSAvXihodWV8c2F0dXJhdGlvbikkLy50ZXN0KG5hbWUpLFxuXHRcdFx0XHRwYXJzZXIgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdW2luZGV4XSA9IG5hbWUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHQ/IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHR2YXIgY3VycmVudCA9IHRoaXMuX2NvbXBvbmVudHNbMF07XG5cdFx0XHRcdFx0XHR2YWx1ZSA9IEdyYWRpZW50LnJlYWQoQXJyYXkuaXNBcnJheSh2YWx1ZSkgPyB2YWx1ZVxuXHRcdFx0XHRcdFx0XHRcdDogYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnJlbnQgIT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChjdXJyZW50KVxuXHRcdFx0XHRcdFx0XHRcdGN1cnJlbnQuX3JlbW92ZU93bmVyKHRoaXMpO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUpXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUuX2FkZE93bmVyKHRoaXMpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHQ6IHR5cGUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdD8gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwge1xuXHRcdFx0XHRcdFx0XHRcdFx0cmVhZE51bGw6IG5hbWUgPT09ICdoaWdobGlnaHQnLFxuXHRcdFx0XHRcdFx0XHRcdFx0Y2xvbmU6IHRydWVcblx0XHRcdFx0XHRcdFx0fSk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZSA9PSBudWxsIHx8IGlzTmFOKHZhbHVlKSA/IDAgOiB2YWx1ZTtcblx0XHRcdFx0XHRcdH07XG5cblx0XHRcdHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZVxuXHRcdFx0XHRcdHx8IGhhc092ZXJsYXAgJiYgL15oc1tibF0kLy50ZXN0KHRoaXMuX3R5cGUpXG5cdFx0XHRcdFx0XHQ/IHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdXG5cdFx0XHRcdFx0XHQ6IHRoaXMuX2NvbnZlcnQodHlwZSlbaW5kZXhdO1xuXHRcdFx0fTtcblxuXHRcdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdFx0aWYgKHRoaXMuX3R5cGUgIT09IHR5cGVcblx0XHRcdFx0XHRcdCYmICEoaGFzT3ZlcmxhcCAmJiAvXmhzW2JsXSQvLnRlc3QodGhpcy5fdHlwZSkpKSB7XG5cdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQodHlwZSk7XG5cdFx0XHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuXHRcdFx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2NvbXBvbmVudHNbaW5kZXhdID0gcGFyc2VyLmNhbGwodGhpcywgdmFsdWUpO1xuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0XHR9O1xuXHRcdH0sIHRoaXMpO1xuXHR9LCB7XG5cdFx0X2NsYXNzOiAnQ29sb3InLFxuXHRcdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0XHRpbml0aWFsaXplOiBmdW5jdGlvbiBDb2xvcihhcmcpIHtcblx0XHRcdHZhciBzbGljZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZSxcblx0XHRcdFx0YXJncyA9IGFyZ3VtZW50cyxcblx0XHRcdFx0cmVhZCA9IDAsXG5cdFx0XHRcdHR5cGUsXG5cdFx0XHRcdGNvbXBvbmVudHMsXG5cdFx0XHRcdGFscGhhLFxuXHRcdFx0XHR2YWx1ZXM7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdGFyZ3MgPSBhcmc7XG5cdFx0XHRcdGFyZyA9IGFyZ3NbMF07XG5cdFx0XHR9XG5cdFx0XHR2YXIgYXJnVHlwZSA9IGFyZyAhPSBudWxsICYmIHR5cGVvZiBhcmc7XG5cdFx0XHRpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycgJiYgYXJnIGluIHR5cGVzKSB7XG5cdFx0XHRcdHR5cGUgPSBhcmc7XG5cdFx0XHRcdGFyZyA9IGFyZ3NbMV07XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0XHRjb21wb25lbnRzID0gYXJnO1xuXHRcdFx0XHRcdGFscGhhID0gYXJnc1syXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdFx0XHRhcmdzID0gc2xpY2UuY2FsbChhcmdzLCAxKTtcblx0XHRcdFx0XHRhcmdUeXBlID0gdHlwZW9mIGFyZztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFjb21wb25lbnRzKSB7XG5cdFx0XHRcdHZhbHVlcyA9IGFyZ1R5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0XHQ/IGFyZ3Ncblx0XHRcdFx0XHRcdDogYXJnVHlwZSA9PT0gJ29iamVjdCcgJiYgYXJnLmxlbmd0aCAhPSBudWxsXG5cdFx0XHRcdFx0XHRcdD8gYXJnXG5cdFx0XHRcdFx0XHRcdDogbnVsbDtcblx0XHRcdFx0aWYgKHZhbHVlcykge1xuXHRcdFx0XHRcdGlmICghdHlwZSlcblx0XHRcdFx0XHRcdHR5cGUgPSB2YWx1ZXMubGVuZ3RoID49IDNcblx0XHRcdFx0XHRcdFx0XHQ/ICdyZ2InXG5cdFx0XHRcdFx0XHRcdFx0OiAnZ3JheSc7XG5cdFx0XHRcdFx0dmFyIGxlbmd0aCA9IHR5cGVzW3R5cGVdLmxlbmd0aDtcblx0XHRcdFx0XHRhbHBoYSA9IHZhbHVlc1tsZW5ndGhdO1xuXHRcdFx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0XHRcdHJlYWQgKz0gdmFsdWVzID09PSBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0PyBsZW5ndGggKyAoYWxwaGEgIT0gbnVsbCA/IDEgOiAwKVxuXHRcdFx0XHRcdFx0XHQ6IDE7XG5cdFx0XHRcdFx0aWYgKHZhbHVlcy5sZW5ndGggPiBsZW5ndGgpXG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBzbGljZS5jYWxsKHZhbHVlcywgMCwgbGVuZ3RoKTtcblx0XHRcdFx0fSBlbHNlIGlmIChhcmdUeXBlID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHRcdHR5cGUgPSAncmdiJztcblx0XHRcdFx0XHRjb21wb25lbnRzID0gZnJvbUNTUyhhcmcpO1xuXHRcdFx0XHRcdGlmIChjb21wb25lbnRzLmxlbmd0aCA9PT0gNCkge1xuXHRcdFx0XHRcdFx0YWxwaGEgPSBjb21wb25lbnRzWzNdO1xuXHRcdFx0XHRcdFx0Y29tcG9uZW50cy5sZW5ndGgtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHRpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBDb2xvcikge1xuXHRcdFx0XHRcdFx0dHlwZSA9IGFyZy5fdHlwZTtcblx0XHRcdFx0XHRcdGNvbXBvbmVudHMgPSBhcmcuX2NvbXBvbmVudHMuc2xpY2UoKTtcblx0XHRcdFx0XHRcdGFscGhhID0gYXJnLl9hbHBoYTtcblx0XHRcdFx0XHRcdGlmICh0eXBlID09PSAnZ3JhZGllbnQnKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0XHR2YXIgcG9pbnQgPSBjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRcdFx0XHRcdGlmIChwb2ludClcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSBwb2ludC5jbG9uZSgpO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fSBlbHNlIGlmIChhcmcuY29uc3RydWN0b3IgPT09IEdyYWRpZW50KSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gJ2dyYWRpZW50Jztcblx0XHRcdFx0XHRcdHZhbHVlcyA9IGFyZ3M7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHR5cGUgPSAnaHVlJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0PyAnbGlnaHRuZXNzJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHQ/ICdoc2wnXG5cdFx0XHRcdFx0XHRcdFx0OiAnaHNiJ1xuXHRcdFx0XHRcdFx0XHQ6ICdncmFkaWVudCcgaW4gYXJnIHx8ICdzdG9wcycgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0XHR8fCAncmFkaWFsJyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHQ/ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdFx0XHQ6ICdncmF5JyBpbiBhcmdcblx0XHRcdFx0XHRcdFx0XHRcdD8gJ2dyYXknXG5cdFx0XHRcdFx0XHRcdFx0XHQ6ICdyZ2InO1xuXHRcdFx0XHRcdFx0dmFyIHByb3BlcnRpZXMgPSB0eXBlc1t0eXBlXSxcblx0XHRcdFx0XHRcdFx0cGFyc2VycyA9IGNvbXBvbmVudFBhcnNlcnNbdHlwZV07XG5cdFx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cyA9IFtdO1xuXHRcdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdFx0XHR2YXIgdmFsdWUgPSBhcmdbcHJvcGVydGllc1tpXV07XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSA9PSBudWxsICYmIGkgPT09IDAgJiYgdHlwZSA9PT0gJ2dyYWRpZW50J1xuXHRcdFx0XHRcdFx0XHRcdFx0JiYgJ3N0b3BzJyBpbiBhcmcpIHtcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHtcblx0XHRcdFx0XHRcdFx0XHRcdHN0b3BzOiBhcmcuc3RvcHMsXG5cdFx0XHRcdFx0XHRcdFx0XHRyYWRpYWw6IGFyZy5yYWRpYWxcblx0XHRcdFx0XHRcdFx0XHR9O1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdHZhbHVlID0gcGFyc2Vyc1tpXS5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0XHRcdFx0Y29tcG9uZW50c1tpXSA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YWxwaGEgPSBhcmcuYWxwaGE7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh0aGlzLl9fcmVhZCAmJiB0eXBlKVxuXHRcdFx0XHRcdHJlYWQgPSAxO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdHlwZSA9IHR5cGUgfHwgJ3JnYic7XG5cdFx0XHR0aGlzLl9pZCA9IFVJRC5nZXQoQ29sb3IpO1xuXHRcdFx0aWYgKCFjb21wb25lbnRzKSB7XG5cdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzID0gW107XG5cdFx0XHRcdHZhciBwYXJzZXJzID0gY29tcG9uZW50UGFyc2Vyc1t0aGlzLl90eXBlXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJzZXJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZXMgJiYgdmFsdWVzW2ldKTtcblx0XHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHM7XG5cdFx0XHR0aGlzLl9wcm9wZXJ0aWVzID0gdHlwZXNbdGhpcy5fdHlwZV07XG5cdFx0XHR0aGlzLl9hbHBoYSA9IGFscGhhO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IHJlYWQ7XG5cdFx0fSxcblxuXHRcdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5nZXRDb21wb25lbnRzKCk7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoXG5cdFx0XHRcdFx0L14oZ3JheXxyZ2IpJC8udGVzdCh0aGlzLl90eXBlKVxuXHRcdFx0XHRcdFx0PyBjb21wb25lbnRzXG5cdFx0XHRcdFx0XHQ6IFt0aGlzLl90eXBlXS5jb25jYXQoY29tcG9uZW50cyksXG5cdFx0XHRcdFx0b3B0aW9ucywgdHJ1ZSwgZGljdGlvbmFyeSk7XG5cdFx0fSxcblxuXHRcdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRcdHRoaXMuX2NhbnZhc1N0eWxlID0gbnVsbDtcblx0XHRcdGlmICh0aGlzLl9vd25lcilcblx0XHRcdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQoNjUpO1xuXHRcdH0sXG5cblx0XHRfY29udmVydDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIGNvbnZlcnRlcjtcblx0XHRcdHJldHVybiB0aGlzLl90eXBlID09PSB0eXBlXG5cdFx0XHRcdFx0PyB0aGlzLl9jb21wb25lbnRzLnNsaWNlKClcblx0XHRcdFx0XHQ6IChjb252ZXJ0ZXIgPSBjb252ZXJ0ZXJzW3RoaXMuX3R5cGUgKyAnLScgKyB0eXBlXSlcblx0XHRcdFx0XHRcdD8gY29udmVydGVyLmFwcGx5KHRoaXMsIHRoaXMuX2NvbXBvbmVudHMpXG5cdFx0XHRcdFx0XHQ6IGNvbnZlcnRlcnNbJ3JnYi0nICsgdHlwZV0uYXBwbHkodGhpcyxcblx0XHRcdFx0XHRcdFx0Y29udmVydGVyc1t0aGlzLl90eXBlICsgJy1yZ2InXS5hcHBseSh0aGlzLFxuXHRcdFx0XHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMpKTtcblx0XHR9LFxuXG5cdFx0Y29udmVydDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih0eXBlLCB0aGlzLl9jb252ZXJ0KHR5cGUpLCB0aGlzLl9hbHBoYSk7XG5cdFx0fSxcblxuXHRcdGdldFR5cGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX3R5cGU7XG5cdFx0fSxcblxuXHRcdHNldFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3R5cGVdO1xuXHRcdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdFx0fSxcblxuXHRcdGdldENvbXBvbmVudHM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLnNsaWNlKCk7XG5cdFx0XHRpZiAodGhpcy5fYWxwaGEgIT0gbnVsbClcblx0XHRcdFx0Y29tcG9uZW50cy5wdXNoKHRoaXMuX2FscGhhKTtcblx0XHRcdHJldHVybiBjb21wb25lbnRzO1xuXHRcdH0sXG5cblx0XHRnZXRBbHBoYTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fYWxwaGEgIT0gbnVsbCA/IHRoaXMuX2FscGhhIDogMTtcblx0XHR9LFxuXG5cdFx0c2V0QWxwaGE6IGZ1bmN0aW9uKGFscGhhKSB7XG5cdFx0XHR0aGlzLl9hbHBoYSA9IGFscGhhID09IG51bGwgPyBudWxsIDogTWF0aC5taW4oTWF0aC5tYXgoYWxwaGEsIDApLCAxKTtcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHR9LFxuXG5cdFx0aGFzQWxwaGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2FscGhhICE9IG51bGw7XG5cdFx0fSxcblxuXHRcdGVxdWFsczogZnVuY3Rpb24oY29sb3IpIHtcblx0XHRcdHZhciBjb2wgPSBCYXNlLmlzUGxhaW5WYWx1ZShjb2xvciwgdHJ1ZSlcblx0XHRcdFx0XHQ/IENvbG9yLnJlYWQoYXJndW1lbnRzKVxuXHRcdFx0XHRcdDogY29sb3I7XG5cdFx0XHRyZXR1cm4gY29sID09PSB0aGlzIHx8IGNvbCAmJiB0aGlzLl9jbGFzcyA9PT0gY29sLl9jbGFzc1xuXHRcdFx0XHRcdCYmIHRoaXMuX3R5cGUgPT09IGNvbC5fdHlwZVxuXHRcdFx0XHRcdCYmIHRoaXMuX2FscGhhID09PSBjb2wuX2FscGhhXG5cdFx0XHRcdFx0JiYgQmFzZS5lcXVhbHModGhpcy5fY29tcG9uZW50cywgY29sLl9jb21wb25lbnRzKVxuXHRcdFx0XHRcdHx8IGZhbHNlO1xuXHRcdH0sXG5cblx0XHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcHJvcGVydGllcyA9IHRoaXMuX3Byb3BlcnRpZXMsXG5cdFx0XHRcdHBhcnRzID0gW10sXG5cdFx0XHRcdGlzR3JhZGllbnQgPSB0aGlzLl90eXBlID09PSAnZ3JhZGllbnQnLFxuXHRcdFx0XHRmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwcm9wZXJ0aWVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLl9jb21wb25lbnRzW2ldO1xuXHRcdFx0XHRpZiAodmFsdWUgIT0gbnVsbClcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKHByb3BlcnRpZXNbaV0gKyAnOiAnXG5cdFx0XHRcdFx0XHRcdCsgKGlzR3JhZGllbnQgPyB2YWx1ZSA6IGYubnVtYmVyKHZhbHVlKSkpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX2FscGhhICE9IG51bGwpXG5cdFx0XHRcdHBhcnRzLnB1c2goJ2FscGhhOiAnICsgZi5udW1iZXIodGhpcy5fYWxwaGEpKTtcblx0XHRcdHJldHVybiAneyAnICsgcGFydHMuam9pbignLCAnKSArICcgfSc7XG5cdFx0fSxcblxuXHRcdHRvQ1NTOiBmdW5jdGlvbihoZXgpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29udmVydCgncmdiJyksXG5cdFx0XHRcdGFscGhhID0gaGV4IHx8IHRoaXMuX2FscGhhID09IG51bGwgPyAxIDogdGhpcy5fYWxwaGE7XG5cdFx0XHRmdW5jdGlvbiBjb252ZXJ0KHZhbCkge1xuXHRcdFx0XHRyZXR1cm4gTWF0aC5yb3VuZCgodmFsIDwgMCA/IDAgOiB2YWwgPiAxID8gMSA6IHZhbCkgKiAyNTUpO1xuXHRcdFx0fVxuXHRcdFx0Y29tcG9uZW50cyA9IFtcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzBdKSxcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzFdKSxcblx0XHRcdFx0Y29udmVydChjb21wb25lbnRzWzJdKVxuXHRcdFx0XTtcblx0XHRcdGlmIChhbHBoYSA8IDEpXG5cdFx0XHRcdGNvbXBvbmVudHMucHVzaChhbHBoYSA8IDAgPyAwIDogYWxwaGEpO1xuXHRcdFx0cmV0dXJuIGhleFxuXHRcdFx0XHRcdD8gJyMnICsgKCgxIDw8IDI0KSArIChjb21wb25lbnRzWzBdIDw8IDE2KVxuXHRcdFx0XHRcdFx0KyAoY29tcG9uZW50c1sxXSA8PCA4KVxuXHRcdFx0XHRcdFx0KyBjb21wb25lbnRzWzJdKS50b1N0cmluZygxNikuc2xpY2UoMSlcblx0XHRcdFx0XHQ6IChjb21wb25lbnRzLmxlbmd0aCA9PSA0ID8gJ3JnYmEoJyA6ICdyZ2IoJylcblx0XHRcdFx0XHRcdCsgY29tcG9uZW50cy5qb2luKCcsJykgKyAnKSc7XG5cdFx0fSxcblxuXHRcdHRvQ2FudmFzU3R5bGU6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdFx0aWYgKHRoaXMuX2NhbnZhc1N0eWxlKVxuXHRcdFx0XHRyZXR1cm4gdGhpcy5fY2FudmFzU3R5bGU7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSAhPT0gJ2dyYWRpZW50Jylcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gdGhpcy50b0NTUygpO1xuXHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzLFxuXHRcdFx0XHRncmFkaWVudCA9IGNvbXBvbmVudHNbMF0sXG5cdFx0XHRcdHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzLFxuXHRcdFx0XHRvcmlnaW4gPSBjb21wb25lbnRzWzFdLFxuXHRcdFx0XHRkZXN0aW5hdGlvbiA9IGNvbXBvbmVudHNbMl0sXG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50O1xuXHRcdFx0aWYgKGdyYWRpZW50Ll9yYWRpYWwpIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IGRlc3RpbmF0aW9uLmdldERpc3RhbmNlKG9yaWdpbiksXG5cdFx0XHRcdFx0aGlnaGxpZ2h0ID0gY29tcG9uZW50c1szXTtcblx0XHRcdFx0aWYgKGhpZ2hsaWdodCkge1xuXHRcdFx0XHRcdHZhciB2ZWN0b3IgPSBoaWdobGlnaHQuc3VidHJhY3Qob3JpZ2luKTtcblx0XHRcdFx0XHRpZiAodmVjdG9yLmdldExlbmd0aCgpID4gcmFkaXVzKVxuXHRcdFx0XHRcdFx0aGlnaGxpZ2h0ID0gb3JpZ2luLmFkZCh2ZWN0b3Iubm9ybWFsaXplKHJhZGl1cyAtIDAuMSkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZhciBzdGFydCA9IGhpZ2hsaWdodCB8fCBvcmlnaW47XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50ID0gY3R4LmNyZWF0ZVJhZGlhbEdyYWRpZW50KHN0YXJ0LngsIHN0YXJ0LnksXG5cdFx0XHRcdFx0XHQwLCBvcmlnaW4ueCwgb3JpZ2luLnksIHJhZGl1cyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVMaW5lYXJHcmFkaWVudChvcmlnaW4ueCwgb3JpZ2luLnksXG5cdFx0XHRcdFx0XHRkZXN0aW5hdGlvbi54LCBkZXN0aW5hdGlvbi55KTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzdG9wID0gc3RvcHNbaV07XG5cdFx0XHRcdGNhbnZhc0dyYWRpZW50LmFkZENvbG9yU3RvcChzdG9wLl9yYW1wUG9pbnQsXG5cdFx0XHRcdFx0XHRzdG9wLl9jb2xvci50b0NhbnZhc1N0eWxlKCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlID0gY2FudmFzR3JhZGllbnQ7XG5cdFx0fSxcblxuXHRcdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0XHRpZiAodGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuXHRcdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbXBvbmVudHM7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgcG9pbnQgPSBjb21wb25lbnRzW2ldO1xuXHRcdFx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQocG9pbnQsIHBvaW50LCB0cnVlKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdF90eXBlczogdHlwZXMsXG5cblx0XHRcdHJhbmRvbTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciByYW5kb20gPSBNYXRoLnJhbmRvbTtcblx0XHRcdFx0cmV0dXJuIG5ldyBDb2xvcihyYW5kb20oKSwgcmFuZG9tKCksIHJhbmRvbSgpKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG9wZXJhdG9ycyA9IHtcblx0XHRhZGQ6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhICsgYjtcblx0XHR9LFxuXG5cdFx0c3VidHJhY3Q6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhIC0gYjtcblx0XHR9LFxuXG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uKGEsIGIpIHtcblx0XHRcdHJldHVybiBhICogYjtcblx0XHR9LFxuXG5cdFx0ZGl2aWRlOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSAvIGI7XG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiBCYXNlLmVhY2gob3BlcmF0b3JzLCBmdW5jdGlvbihvcGVyYXRvciwgbmFtZSkge1xuXHRcdHRoaXNbbmFtZV0gPSBmdW5jdGlvbihjb2xvcikge1xuXHRcdFx0Y29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGUsXG5cdFx0XHRcdGNvbXBvbmVudHMxID0gdGhpcy5fY29tcG9uZW50cyxcblx0XHRcdFx0Y29tcG9uZW50czIgPSBjb2xvci5fY29udmVydCh0eXBlKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY29tcG9uZW50czEubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjb21wb25lbnRzMltpXSA9IG9wZXJhdG9yKGNvbXBvbmVudHMxW2ldLCBjb21wb25lbnRzMltpXSk7XG5cdFx0XHRyZXR1cm4gbmV3IENvbG9yKHR5cGUsIGNvbXBvbmVudHMyLFxuXHRcdFx0XHRcdHRoaXMuX2FscGhhICE9IG51bGxcblx0XHRcdFx0XHRcdFx0PyBvcGVyYXRvcih0aGlzLl9hbHBoYSwgY29sb3IuZ2V0QWxwaGEoKSlcblx0XHRcdFx0XHRcdFx0OiBudWxsKTtcblx0XHR9O1xuXHR9LCB7XG5cdH0pO1xufSk7XG5cbnZhciBHcmFkaWVudCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnR3JhZGllbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50KHN0b3BzLCByYWRpYWwpIHtcblx0XHR0aGlzLl9pZCA9IFVJRC5nZXQoKTtcblx0XHRpZiAoc3RvcHMgJiYgdGhpcy5fc2V0KHN0b3BzKSlcblx0XHRcdHN0b3BzID0gcmFkaWFsID0gbnVsbDtcblx0XHRpZiAoIXRoaXMuX3N0b3BzKVxuXHRcdFx0dGhpcy5zZXRTdG9wcyhzdG9wcyB8fCBbJ3doaXRlJywgJ2JsYWNrJ10pO1xuXHRcdGlmICh0aGlzLl9yYWRpYWwgPT0gbnVsbClcblx0XHRcdHRoaXMuc2V0UmFkaWFsKHR5cGVvZiByYWRpYWwgPT09ICdzdHJpbmcnICYmIHJhZGlhbCA9PT0gJ3JhZGlhbCdcblx0XHRcdFx0XHR8fCByYWRpYWwgfHwgZmFsc2UpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gZGljdGlvbmFyeS5hZGQodGhpcywgZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX3N0b3BzLCB0aGlzLl9yYWRpYWxdLFxuXHRcdFx0XHRcdG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHRcdH0pO1xuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX293bmVycyAmJiB0aGlzLl9vd25lcnMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0dGhpcy5fb3duZXJzW2ldLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0X2FkZE93bmVyOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdGlmICghdGhpcy5fb3duZXJzKVxuXHRcdFx0dGhpcy5fb3duZXJzID0gW107XG5cdFx0dGhpcy5fb3duZXJzLnB1c2goY29sb3IpO1xuXHR9LFxuXG5cdF9yZW1vdmVPd25lcjogZnVuY3Rpb24oY29sb3IpIHtcblx0XHR2YXIgaW5kZXggPSB0aGlzLl9vd25lcnMgPyB0aGlzLl9vd25lcnMuaW5kZXhPZihjb2xvcikgOiAtMTtcblx0XHRpZiAoaW5kZXggIT0gLTEpIHtcblx0XHRcdHRoaXMuX293bmVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0aWYgKHRoaXMuX293bmVycy5sZW5ndGggPT09IDApXG5cdFx0XHRcdHRoaXMuX293bmVycyA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzdG9wcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c3RvcHNbaV0gPSB0aGlzLl9zdG9wc1tpXS5jbG9uZSgpO1xuXHRcdHJldHVybiBuZXcgR3JhZGllbnQoc3RvcHMsIHRoaXMuX3JhZGlhbCk7XG5cdH0sXG5cblx0Z2V0U3RvcHM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zdG9wcztcblx0fSxcblxuXHRzZXRTdG9wczogZnVuY3Rpb24oc3RvcHMpIHtcblx0XHRpZiAodGhpcy5zdG9wcykge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHRoaXMuX3N0b3BzW2ldLl9vd25lciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKHN0b3BzLmxlbmd0aCA8IDIpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0J0dyYWRpZW50IHN0b3AgbGlzdCBuZWVkcyB0byBjb250YWluIGF0IGxlYXN0IHR3byBzdG9wcy4nKTtcblx0XHR0aGlzLl9zdG9wcyA9IEdyYWRpZW50U3RvcC5yZWFkQWxsKHN0b3BzLCAwLCB7IGNsb25lOiB0cnVlIH0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc3RvcCA9IHRoaXMuX3N0b3BzW2ldO1xuXHRcdFx0c3RvcC5fb3duZXIgPSB0aGlzO1xuXHRcdFx0aWYgKHN0b3AuX2RlZmF1bHRSYW1wKVxuXHRcdFx0XHRzdG9wLnNldFJhbXBQb2ludChpIC8gKGwgLSAxKSk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRnZXRSYWRpYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYWRpYWw7XG5cdH0sXG5cblx0c2V0UmFkaWFsOiBmdW5jdGlvbihyYWRpYWwpIHtcblx0XHR0aGlzLl9yYWRpYWwgPSByYWRpYWw7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oZ3JhZGllbnQpIHtcblx0XHRpZiAoZ3JhZGllbnQgPT09IHRoaXMpXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRpZiAoZ3JhZGllbnQgJiYgdGhpcy5fY2xhc3MgPT09IGdyYWRpZW50Ll9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9zdG9wcy5sZW5ndGggPT09IGdyYWRpZW50Ll9zdG9wcy5sZW5ndGgpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGlmICghdGhpcy5fc3RvcHNbaV0uZXF1YWxzKGdyYWRpZW50Ll9zdG9wc1tpXSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5cbnZhciBHcmFkaWVudFN0b3AgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyYWRpZW50U3RvcCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JhZGllbnRTdG9wKGFyZzAsIGFyZzEpIHtcblx0XHRpZiAoYXJnMCkge1xuXHRcdFx0dmFyIGNvbG9yLCByYW1wUG9pbnQ7XG5cdFx0XHRpZiAoYXJnMSA9PT0gdW5kZWZpbmVkICYmIEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwWzBdO1xuXHRcdFx0XHRyYW1wUG9pbnQgPSBhcmcwWzFdO1xuXHRcdFx0fSBlbHNlIGlmIChhcmcwLmNvbG9yKSB7XG5cdFx0XHRcdGNvbG9yID0gYXJnMC5jb2xvcjtcblx0XHRcdFx0cmFtcFBvaW50ID0gYXJnMC5yYW1wUG9pbnQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjb2xvciA9IGFyZzA7XG5cdFx0XHRcdHJhbXBQb2ludCA9IGFyZzE7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLnNldENvbG9yKGNvbG9yKTtcblx0XHRcdHRoaXMuc2V0UmFtcFBvaW50KHJhbXBQb2ludCk7XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEdyYWRpZW50U3RvcCh0aGlzLl9jb2xvci5jbG9uZSgpLCB0aGlzLl9yYW1wUG9pbnQpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMsIGRpY3Rpb25hcnkpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUoW3RoaXMuX2NvbG9yLCB0aGlzLl9yYW1wUG9pbnRdLCBvcHRpb25zLCB0cnVlLFxuXHRcdFx0XHRkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX293bmVyKVxuXHRcdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQoNjUpO1xuXHR9LFxuXG5cdGdldFJhbXBQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3JhbXBQb2ludDtcblx0fSxcblxuXHRzZXRSYW1wUG9pbnQ6IGZ1bmN0aW9uKHJhbXBQb2ludCkge1xuXHRcdHRoaXMuX2RlZmF1bHRSYW1wID0gcmFtcFBvaW50ID09IG51bGw7XG5cdFx0dGhpcy5fcmFtcFBvaW50ID0gcmFtcFBvaW50IHx8IDA7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdGdldENvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29sb3I7XG5cdH0sXG5cblx0c2V0Q29sb3I6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0dGhpcy5fY29sb3IgPSBDb2xvci5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHRoaXMuX2NvbG9yID09PSBjb2xvcilcblx0XHRcdHRoaXMuX2NvbG9yID0gY29sb3IuY2xvbmUoKTtcblx0XHR0aGlzLl9jb2xvci5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHN0b3ApIHtcblx0XHRyZXR1cm4gc3RvcCA9PT0gdGhpcyB8fCBzdG9wICYmIHRoaXMuX2NsYXNzID09PSBzdG9wLl9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9jb2xvci5lcXVhbHMoc3RvcC5fY29sb3IpXG5cdFx0XHRcdCYmIHRoaXMuX3JhbXBQb2ludCA9PSBzdG9wLl9yYW1wUG9pbnRcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH1cbn0pO1xuXG52YXIgU3R5bGUgPSBCYXNlLmV4dGVuZChuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBkZWZhdWx0cyA9IHtcblx0XHRmaWxsQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRzdHJva2VDb2xvcjogdW5kZWZpbmVkLFxuXHRcdHN0cm9rZVdpZHRoOiAxLFxuXHRcdHN0cm9rZUNhcDogJ2J1dHQnLFxuXHRcdHN0cm9rZUpvaW46ICdtaXRlcicsXG5cdFx0c3Ryb2tlU2NhbGluZzogdHJ1ZSxcblx0XHRtaXRlckxpbWl0OiAxMCxcblx0XHRkYXNoT2Zmc2V0OiAwLFxuXHRcdGRhc2hBcnJheTogW10sXG5cdFx0d2luZGluZ1J1bGU6ICdub256ZXJvJyxcblx0XHRzaGFkb3dDb2xvcjogdW5kZWZpbmVkLFxuXHRcdHNoYWRvd0JsdXI6IDAsXG5cdFx0c2hhZG93T2Zmc2V0OiBuZXcgUG9pbnQoKSxcblx0XHRzZWxlY3RlZENvbG9yOiB1bmRlZmluZWQsXG5cdFx0Zm9udEZhbWlseTogJ3NhbnMtc2VyaWYnLFxuXHRcdGZvbnRXZWlnaHQ6ICdub3JtYWwnLFxuXHRcdGZvbnRTaXplOiAxMixcblx0XHRmb250OiAnc2Fucy1zZXJpZicsXG5cdFx0bGVhZGluZzogbnVsbCxcblx0XHRqdXN0aWZpY2F0aW9uOiAnbGVmdCdcblx0fTtcblxuXHR2YXIgZmxhZ3MgPSB7XG5cdFx0c3Ryb2tlV2lkdGg6IDk3LFxuXHRcdHN0cm9rZUNhcDogOTcsXG5cdFx0c3Ryb2tlSm9pbjogOTcsXG5cdFx0c3Ryb2tlU2NhbGluZzogMTA1LFxuXHRcdG1pdGVyTGltaXQ6IDk3LFxuXHRcdGZvbnRGYW1pbHk6IDksXG5cdFx0Zm9udFdlaWdodDogOSxcblx0XHRmb250U2l6ZTogOSxcblx0XHRmb250OiA5LFxuXHRcdGxlYWRpbmc6IDksXG5cdFx0anVzdGlmaWNhdGlvbjogOVxuXHR9O1xuXG5cdHZhciBpdGVtID0geyBiZWFuczogdHJ1ZSB9LFxuXHRcdGZpZWxkcyA9IHtcblx0XHRcdF9kZWZhdWx0czogZGVmYXVsdHMsXG5cdFx0XHRfdGV4dERlZmF1bHRzOiBuZXcgQmFzZShkZWZhdWx0cywge1xuXHRcdFx0XHRmaWxsQ29sb3I6IG5ldyBDb2xvcigpXG5cdFx0XHR9KSxcblx0XHRcdGJlYW5zOiB0cnVlXG5cdFx0fTtcblxuXHRCYXNlLmVhY2goZGVmYXVsdHMsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcblx0XHR2YXIgaXNDb2xvciA9IC9Db2xvciQvLnRlc3Qoa2V5KSxcblx0XHRcdGlzUG9pbnQgPSBrZXkgPT09ICdzaGFkb3dPZmZzZXQnLFxuXHRcdFx0cGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuXHRcdFx0ZmxhZyA9IGZsYWdzW2tleV0sXG5cdFx0XHRzZXQgPSAnc2V0JyArIHBhcnQsXG5cdFx0XHRnZXQgPSAnZ2V0JyArIHBhcnQ7XG5cblx0XHRmaWVsZHNbc2V0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHR2YXIgb3duZXIgPSB0aGlzLl9vd25lcixcblx0XHRcdFx0Y2hpbGRyZW4gPSBvd25lciAmJiBvd25lci5fY2hpbGRyZW47XG5cdFx0XHRpZiAoY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoID4gMFxuXHRcdFx0XHRcdCYmICEob3duZXIgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdGNoaWxkcmVuW2ldLl9zdHlsZVtzZXRdKHZhbHVlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBvbGQgPSB0aGlzLl92YWx1ZXNba2V5XTtcblx0XHRcdFx0aWYgKG9sZCAhPT0gdmFsdWUpIHtcblx0XHRcdFx0XHRpZiAoaXNDb2xvcikge1xuXHRcdFx0XHRcdFx0aWYgKG9sZClcblx0XHRcdFx0XHRcdFx0b2xkLl9vd25lciA9IHVuZGVmaW5lZDtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gQ29sb3IpIHtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlLl9vd25lcilcblx0XHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHZhbHVlLmNsb25lKCk7XG5cdFx0XHRcdFx0XHRcdHZhbHVlLl9vd25lciA9IG93bmVyO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlO1xuXHRcdFx0XHRcdGlmIChvd25lcilcblx0XHRcdFx0XHRcdG93bmVyLl9jaGFuZ2VkKGZsYWcgfHwgNjUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblxuXHRcdGZpZWxkc1tnZXRdID0gZnVuY3Rpb24oX2RvbnRNZXJnZSkge1xuXHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXIsXG5cdFx0XHRcdGNoaWxkcmVuID0gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuLFxuXHRcdFx0XHR2YWx1ZTtcblx0XHRcdGlmICghY2hpbGRyZW4gfHwgY2hpbGRyZW4ubGVuZ3RoID09PSAwIHx8IF9kb250TWVyZ2Vcblx0XHRcdFx0XHR8fCBvd25lciBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSB0aGlzLl92YWx1ZXNba2V5XTtcblx0XHRcdFx0aWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcblx0XHRcdFx0XHR2YWx1ZSA9IHRoaXMuX2RlZmF1bHRzW2tleV07XG5cdFx0XHRcdFx0aWYgKHZhbHVlICYmIHZhbHVlLmNsb25lKVxuXHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciBjdG9yID0gaXNDb2xvciA/IENvbG9yIDogaXNQb2ludCA/IFBvaW50IDogbnVsbDtcblx0XHRcdFx0XHRpZiAoY3RvciAmJiAhKHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yID09PSBjdG9yKSkge1xuXHRcdFx0XHRcdFx0dGhpcy5fdmFsdWVzW2tleV0gPSB2YWx1ZSA9IGN0b3IucmVhZChbdmFsdWVdLCAwLFxuXHRcdFx0XHRcdFx0XHRcdHsgcmVhZE51bGw6IHRydWUsIGNsb25lOiB0cnVlIH0pO1xuXHRcdFx0XHRcdFx0aWYgKHZhbHVlICYmIGlzQ29sb3IpXG5cdFx0XHRcdFx0XHRcdHZhbHVlLl9vd25lciA9IG93bmVyO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgY2hpbGRWYWx1ZSA9IGNoaWxkcmVuW2ldLl9zdHlsZVtnZXRdKCk7XG5cdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSBjaGlsZFZhbHVlO1xuXHRcdFx0XHR9IGVsc2UgaWYgKCFCYXNlLmVxdWFscyh2YWx1ZSwgY2hpbGRWYWx1ZSkpIHtcblx0XHRcdFx0XHRyZXR1cm4gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0fTtcblxuXHRcdGl0ZW1bZ2V0XSA9IGZ1bmN0aW9uKF9kb250TWVyZ2UpIHtcblx0XHRcdHJldHVybiB0aGlzLl9zdHlsZVtnZXRdKF9kb250TWVyZ2UpO1xuXHRcdH07XG5cblx0XHRpdGVtW3NldF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpcy5fc3R5bGVbc2V0XSh2YWx1ZSk7XG5cdFx0fTtcblx0fSk7XG5cblx0SXRlbS5pbmplY3QoaXRlbSk7XG5cdHJldHVybiBmaWVsZHM7XG59LCB7XG5cdF9jbGFzczogJ1N0eWxlJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTdHlsZShzdHlsZSwgX293bmVyLCBfcHJvamVjdCkge1xuXHRcdHRoaXMuX3ZhbHVlcyA9IHt9O1xuXHRcdHRoaXMuX293bmVyID0gX293bmVyO1xuXHRcdHRoaXMuX3Byb2plY3QgPSBfb3duZXIgJiYgX293bmVyLl9wcm9qZWN0IHx8IF9wcm9qZWN0IHx8IHBhcGVyLnByb2plY3Q7XG5cdFx0aWYgKF9vd25lciBpbnN0YW5jZW9mIFRleHRJdGVtKVxuXHRcdFx0dGhpcy5fZGVmYXVsdHMgPSB0aGlzLl90ZXh0RGVmYXVsdHM7XG5cdFx0aWYgKHN0eWxlKVxuXHRcdFx0dGhpcy5zZXQoc3R5bGUpO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHR2YXIgaXNTdHlsZSA9IHN0eWxlIGluc3RhbmNlb2YgU3R5bGUsXG5cdFx0XHR2YWx1ZXMgPSBpc1N0eWxlID8gc3R5bGUuX3ZhbHVlcyA6IHN0eWxlO1xuXHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiB2YWx1ZXMpIHtcblx0XHRcdFx0aWYgKGtleSBpbiB0aGlzLl9kZWZhdWx0cykge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHZhbHVlc1trZXldO1xuXHRcdFx0XHRcdHRoaXNba2V5XSA9IHZhbHVlICYmIGlzU3R5bGUgJiYgdmFsdWUuY2xvbmVcblx0XHRcdFx0XHRcdFx0PyB2YWx1ZS5jbG9uZSgpIDogdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHJldHVybiBzdHlsZSA9PT0gdGhpcyB8fCBzdHlsZSAmJiB0aGlzLl9jbGFzcyA9PT0gc3R5bGUuX2NsYXNzXG5cdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3ZhbHVlcywgc3R5bGUuX3ZhbHVlcylcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0aGFzRmlsbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5nZXRGaWxsQ29sb3IoKTtcblx0fSxcblxuXHRoYXNTdHJva2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0U3Ryb2tlQ29sb3IoKSAmJiB0aGlzLmdldFN0cm9rZVdpZHRoKCkgPiAwO1xuXHR9LFxuXG5cdGhhc1NoYWRvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5nZXRTaGFkb3dDb2xvcigpICYmIHRoaXMuZ2V0U2hhZG93Qmx1cigpID4gMDtcblx0fSxcblxuXHRnZXRWaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcHJvamVjdC5nZXRWaWV3KCk7XG5cdH0sXG5cblx0Z2V0Rm9udFN0eWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Rm9udFdlaWdodCgpXG5cdFx0XHRcdCsgJyAnICsgZm9udFNpemUgKyAoL1thLXpdL2kudGVzdChmb250U2l6ZSArICcnKSA/ICcgJyA6ICdweCAnKVxuXHRcdFx0XHQrIHRoaXMuZ2V0Rm9udEZhbWlseSgpO1xuXHR9LFxuXG5cdGdldEZvbnQ6ICcjZ2V0Rm9udEZhbWlseScsXG5cdHNldEZvbnQ6ICcjc2V0Rm9udEZhbWlseScsXG5cblx0Z2V0TGVhZGluZzogZnVuY3Rpb24gZ2V0TGVhZGluZygpIHtcblx0XHR2YXIgbGVhZGluZyA9IGdldExlYWRpbmcuYmFzZS5jYWxsKHRoaXMpLFxuXHRcdFx0Zm9udFNpemUgPSB0aGlzLmdldEZvbnRTaXplKCk7XG5cdFx0aWYgKC9wdHxlbXwlfHB4Ly50ZXN0KGZvbnRTaXplKSlcblx0XHRcdGZvbnRTaXplID0gdGhpcy5nZXRWaWV3KCkuZ2V0UGl4ZWxTaXplKGZvbnRTaXplKTtcblx0XHRyZXR1cm4gbGVhZGluZyAhPSBudWxsID8gbGVhZGluZyA6IGZvbnRTaXplICogMS4yO1xuXHR9XG5cbn0pO1xuXG52YXIgRG9tRWxlbWVudCA9IG5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gaGFuZGxlUHJlZml4KGVsLCBuYW1lLCBzZXQsIHZhbHVlKSB7XG5cdFx0dmFyIHByZWZpeGVzID0gWycnLCAnd2Via2l0JywgJ21veicsICdNb3onLCAnbXMnLCAnbyddLFxuXHRcdFx0c3VmZml4ID0gbmFtZVswXS50b1VwcGVyQ2FzZSgpICsgbmFtZS5zdWJzdHJpbmcoMSk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA2OyBpKyspIHtcblx0XHRcdHZhciBwcmVmaXggPSBwcmVmaXhlc1tpXSxcblx0XHRcdFx0a2V5ID0gcHJlZml4ID8gcHJlZml4ICsgc3VmZml4IDogbmFtZTtcblx0XHRcdGlmIChrZXkgaW4gZWwpIHtcblx0XHRcdFx0aWYgKHNldCkge1xuXHRcdFx0XHRcdGVsW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gZWxba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGdldFN0eWxlczogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHZhciBkb2MgPSBlbCAmJiBlbC5ub2RlVHlwZSAhPT0gOSA/IGVsLm93bmVyRG9jdW1lbnQgOiBlbCxcblx0XHRcdFx0dmlldyA9IGRvYyAmJiBkb2MuZGVmYXVsdFZpZXc7XG5cdFx0XHRyZXR1cm4gdmlldyAmJiB2aWV3LmdldENvbXB1dGVkU3R5bGUoZWwsICcnKTtcblx0XHR9LFxuXG5cdFx0Z2V0Qm91bmRzOiBmdW5jdGlvbihlbCwgdmlld3BvcnQpIHtcblx0XHRcdHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuXHRcdFx0XHRib2R5ID0gZG9jLmJvZHksXG5cdFx0XHRcdGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50LFxuXHRcdFx0XHRyZWN0O1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0cmVjdCA9IGVsLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRyZWN0ID0geyBsZWZ0OiAwLCB0b3A6IDAsIHdpZHRoOiAwLCBoZWlnaHQ6IDAgfTtcblx0XHRcdH1cblx0XHRcdHZhciB4ID0gcmVjdC5sZWZ0IC0gKGh0bWwuY2xpZW50TGVmdCB8fCBib2R5LmNsaWVudExlZnQgfHwgMCksXG5cdFx0XHRcdHkgPSByZWN0LnRvcCAtIChodG1sLmNsaWVudFRvcCB8fCBib2R5LmNsaWVudFRvcCB8fCAwKTtcblx0XHRcdGlmICghdmlld3BvcnQpIHtcblx0XHRcdFx0dmFyIHZpZXcgPSBkb2MuZGVmYXVsdFZpZXc7XG5cdFx0XHRcdHggKz0gdmlldy5wYWdlWE9mZnNldCB8fCBodG1sLnNjcm9sbExlZnQgfHwgYm9keS5zY3JvbGxMZWZ0O1xuXHRcdFx0XHR5ICs9IHZpZXcucGFnZVlPZmZzZXQgfHwgaHRtbC5zY3JvbGxUb3AgfHwgYm9keS5zY3JvbGxUb3A7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSh4LCB5LCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdFx0fSxcblxuXHRcdGdldFZpZXdwb3J0Qm91bmRzOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0dmFyIGRvYyA9IGVsLm93bmVyRG9jdW1lbnQsXG5cdFx0XHRcdHZpZXcgPSBkb2MuZGVmYXVsdFZpZXcsXG5cdFx0XHRcdGh0bWwgPSBkb2MuZG9jdW1lbnRFbGVtZW50O1xuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoMCwgMCxcblx0XHRcdFx0dmlldy5pbm5lcldpZHRoIHx8IGh0bWwuY2xpZW50V2lkdGgsXG5cdFx0XHRcdHZpZXcuaW5uZXJIZWlnaHQgfHwgaHRtbC5jbGllbnRIZWlnaHRcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdGdldE9mZnNldDogZnVuY3Rpb24oZWwsIHZpZXdwb3J0KSB7XG5cdFx0XHRyZXR1cm4gRG9tRWxlbWVudC5nZXRCb3VuZHMoZWwsIHZpZXdwb3J0KS5nZXRQb2ludCgpO1xuXHRcdH0sXG5cblx0XHRnZXRTaXplOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB0cnVlKS5nZXRTaXplKCk7XG5cdFx0fSxcblxuXHRcdGlzSW52aXNpYmxlOiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0U2l6ZShlbCkuZXF1YWxzKG5ldyBTaXplKDAsIDApKTtcblx0XHR9LFxuXG5cdFx0aXNJblZpZXc6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHRyZXR1cm4gIURvbUVsZW1lbnQuaXNJbnZpc2libGUoZWwpXG5cdFx0XHRcdFx0JiYgRG9tRWxlbWVudC5nZXRWaWV3cG9ydEJvdW5kcyhlbCkuaW50ZXJzZWN0cyhcblx0XHRcdFx0XHRcdERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB0cnVlKSk7XG5cdFx0fSxcblxuXHRcdGdldFByZWZpeGVkOiBmdW5jdGlvbihlbCwgbmFtZSkge1xuXHRcdFx0cmV0dXJuIGhhbmRsZVByZWZpeChlbCwgbmFtZSk7XG5cdFx0fSxcblxuXHRcdHNldFByZWZpeGVkOiBmdW5jdGlvbihlbCwgbmFtZSwgdmFsdWUpIHtcblx0XHRcdGlmICh0eXBlb2YgbmFtZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG5hbWUpXG5cdFx0XHRcdFx0aGFuZGxlUHJlZml4KGVsLCBrZXksIHRydWUsIG5hbWVba2V5XSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRoYW5kbGVQcmVmaXgoZWwsIG5hbWUsIHRydWUsIHZhbHVlKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG52YXIgRG9tRXZlbnQgPSB7XG5cdGFkZDogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuXHRcdGZvciAodmFyIHR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHR2YXIgZnVuYyA9IGV2ZW50c1t0eXBlXSxcblx0XHRcdFx0cGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGVsLmFkZEV2ZW50TGlzdGVuZXIocGFydHNbaV0sIGZ1bmMsIGZhbHNlKTtcblx0XHR9XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbihlbCwgZXZlbnRzKSB7XG5cdFx0Zm9yICh2YXIgdHlwZSBpbiBldmVudHMpIHtcblx0XHRcdHZhciBmdW5jID0gZXZlbnRzW3R5cGVdLFxuXHRcdFx0XHRwYXJ0cyA9IHR5cGUuc3BsaXQoL1tcXHMsXSsvZyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0ZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihwYXJ0c1tpXSwgZnVuYywgZmFsc2UpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgcG9zID0gZXZlbnQudGFyZ2V0VG91Y2hlc1xuXHRcdFx0XHQ/IGV2ZW50LnRhcmdldFRvdWNoZXMubGVuZ3RoXG5cdFx0XHRcdFx0PyBldmVudC50YXJnZXRUb3VjaGVzWzBdXG5cdFx0XHRcdFx0OiBldmVudC5jaGFuZ2VkVG91Y2hlc1swXVxuXHRcdFx0XHQ6IGV2ZW50O1xuXHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRwb3MucGFnZVggfHwgcG9zLmNsaWVudFggKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsTGVmdCxcblx0XHRcdHBvcy5wYWdlWSB8fCBwb3MuY2xpZW50WSArIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5zY3JvbGxUb3Bcblx0XHQpO1xuXHR9LFxuXG5cdGdldFRhcmdldDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gZXZlbnQudGFyZ2V0IHx8IGV2ZW50LnNyY0VsZW1lbnQ7XG5cdH0sXG5cblx0Z2V0UmVsYXRlZFRhcmdldDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRyZXR1cm4gZXZlbnQucmVsYXRlZFRhcmdldCB8fCBldmVudC50b0VsZW1lbnQ7XG5cdH0sXG5cblx0Z2V0T2Zmc2V0OiBmdW5jdGlvbihldmVudCwgdGFyZ2V0KSB7XG5cdFx0cmV0dXJuIERvbUV2ZW50LmdldFBvaW50KGV2ZW50KS5zdWJ0cmFjdChEb21FbGVtZW50LmdldE9mZnNldChcblx0XHRcdFx0dGFyZ2V0IHx8IERvbUV2ZW50LmdldFRhcmdldChldmVudCkpKTtcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbihldmVudCkge1xuXHRcdGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH1cbn07XG5cbkRvbUV2ZW50LnJlcXVlc3RBbmltYXRpb25GcmFtZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG5hdGl2ZVJlcXVlc3QgPSBEb21FbGVtZW50LmdldFByZWZpeGVkKHdpbmRvdywgJ3JlcXVlc3RBbmltYXRpb25GcmFtZScpLFxuXHRcdHJlcXVlc3RlZCA9IGZhbHNlLFxuXHRcdGNhbGxiYWNrcyA9IFtdLFxuXHRcdGZvY3VzZWQgPSB0cnVlLFxuXHRcdHRpbWVyO1xuXG5cdERvbUV2ZW50LmFkZCh3aW5kb3csIHtcblx0XHRmb2N1czogZnVuY3Rpb24oKSB7XG5cdFx0XHRmb2N1c2VkID0gdHJ1ZTtcblx0XHR9LFxuXHRcdGJsdXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9jdXNlZCA9IGZhbHNlO1xuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gaGFuZGxlQ2FsbGJhY2tzKCkge1xuXHRcdGZvciAodmFyIGkgPSBjYWxsYmFja3MubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBlbnRyeSA9IGNhbGxiYWNrc1tpXSxcblx0XHRcdFx0ZnVuYyA9IGVudHJ5WzBdLFxuXHRcdFx0XHRlbCA9IGVudHJ5WzFdO1xuXHRcdFx0aWYgKCFlbCB8fCAoUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoZWwsICdrZWVwYWxpdmUnKSA9PSAndHJ1ZSdcblx0XHRcdFx0XHR8fCBmb2N1c2VkKSAmJiBEb21FbGVtZW50LmlzSW5WaWV3KGVsKSkge1xuXHRcdFx0XHRjYWxsYmFja3Muc3BsaWNlKGksIDEpO1xuXHRcdFx0XHRmdW5jKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChuYXRpdmVSZXF1ZXN0KSB7XG5cdFx0XHRpZiAoY2FsbGJhY2tzLmxlbmd0aCkge1xuXHRcdFx0XHRuYXRpdmVSZXF1ZXN0KGhhbmRsZUNhbGxiYWNrcyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXF1ZXN0ZWQgPSBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZnVuY3Rpb24oY2FsbGJhY2ssIGVsZW1lbnQpIHtcblx0XHRjYWxsYmFja3MucHVzaChbY2FsbGJhY2ssIGVsZW1lbnRdKTtcblx0XHRpZiAobmF0aXZlUmVxdWVzdCkge1xuXHRcdFx0aWYgKCFyZXF1ZXN0ZWQpIHtcblx0XHRcdFx0bmF0aXZlUmVxdWVzdChoYW5kbGVDYWxsYmFja3MpO1xuXHRcdFx0XHRyZXF1ZXN0ZWQgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoIXRpbWVyKSB7XG5cdFx0XHR0aW1lciA9IHNldEludGVydmFsKGhhbmRsZUNhbGxiYWNrcywgMTAwMCAvIDYwKTtcblx0XHR9XG5cdH07XG59O1xuXG52YXIgVmlldyA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcblx0X2NsYXNzOiAnVmlldycsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gVmlldyhwcm9qZWN0LCBlbGVtZW50KSB7XG5cdFx0dGhpcy5fcHJvamVjdCA9IHByb2plY3Q7XG5cdFx0dGhpcy5fc2NvcGUgPSBwcm9qZWN0Ll9zY29wZTtcblx0XHR0aGlzLl9lbGVtZW50ID0gZWxlbWVudDtcblx0XHR2YXIgc2l6ZTtcblx0XHRpZiAoIXRoaXMuX3BpeGVsUmF0aW8pXG5cdFx0XHR0aGlzLl9waXhlbFJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMTtcblx0XHR0aGlzLl9pZCA9IGVsZW1lbnQuZ2V0QXR0cmlidXRlKCdpZCcpO1xuXHRcdGlmICh0aGlzLl9pZCA9PSBudWxsKVxuXHRcdFx0ZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ2lkJywgdGhpcy5faWQgPSAndmlldy0nICsgVmlldy5faWQrKyk7XG5cdFx0RG9tRXZlbnQuYWRkKGVsZW1lbnQsIHRoaXMuX3ZpZXdFdmVudHMpO1xuXHRcdHZhciBub25lID0gJ25vbmUnO1xuXHRcdERvbUVsZW1lbnQuc2V0UHJlZml4ZWQoZWxlbWVudC5zdHlsZSwge1xuXHRcdFx0dXNlclNlbGVjdDogbm9uZSxcblx0XHRcdHRvdWNoQWN0aW9uOiBub25lLFxuXHRcdFx0dG91Y2hDYWxsb3V0OiBub25lLFxuXHRcdFx0Y29udGVudFpvb21pbmc6IG5vbmUsXG5cdFx0XHR1c2VyRHJhZzogbm9uZSxcblx0XHRcdHRhcEhpZ2hsaWdodENvbG9yOiAncmdiYSgwLDAsMCwwKSdcblx0XHR9KTtcblxuXHRcdGZ1bmN0aW9uIGdldFNpemUobmFtZSkge1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRbbmFtZV0gfHwgcGFyc2VJbnQoZWxlbWVudC5nZXRBdHRyaWJ1dGUobmFtZSksIDEwKTtcblx0XHR9O1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Q2FudmFzU2l6ZSgpIHtcblx0XHRcdHZhciBzaXplID0gRG9tRWxlbWVudC5nZXRTaXplKGVsZW1lbnQpO1xuXHRcdFx0cmV0dXJuIHNpemUuaXNOYU4oKSB8fCBzaXplLmlzWmVybygpXG5cdFx0XHRcdFx0PyBuZXcgU2l6ZShnZXRTaXplKCd3aWR0aCcpLCBnZXRTaXplKCdoZWlnaHQnKSlcblx0XHRcdFx0XHQ6IHNpemU7XG5cdFx0fTtcblxuXHRcdGlmIChQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAncmVzaXplJykpIHtcblx0XHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHRcdERvbUV2ZW50LmFkZCh3aW5kb3csIHRoaXMuX3dpbmRvd0V2ZW50cyA9IHtcblx0XHRcdFx0cmVzaXplOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGF0LnNldFZpZXdTaXplKGdldENhbnZhc1NpemUoKSk7XG5cdFx0XHRcdH1cblx0XHRcdH0pO1xuXHRcdH1cblx0XHR0aGlzLl9zZXRWaWV3U2l6ZShzaXplID0gZ2V0Q2FudmFzU2l6ZSgpKTtcblx0XHRpZiAoUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3N0YXRzJylcblx0XHRcdFx0JiYgdHlwZW9mIFN0YXRzICE9PSAndW5kZWZpbmVkJykge1xuXHRcdFx0dGhpcy5fc3RhdHMgPSBuZXcgU3RhdHMoKTtcblx0XHRcdHZhciBzdGF0cyA9IHRoaXMuX3N0YXRzLmRvbUVsZW1lbnQsXG5cdFx0XHRcdHN0eWxlID0gc3RhdHMuc3R5bGUsXG5cdFx0XHRcdG9mZnNldCA9IERvbUVsZW1lbnQuZ2V0T2Zmc2V0KGVsZW1lbnQpO1xuXHRcdFx0c3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuXHRcdFx0c3R5bGUubGVmdCA9IG9mZnNldC54ICsgJ3B4Jztcblx0XHRcdHN0eWxlLnRvcCA9IG9mZnNldC55ICsgJ3B4Jztcblx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoc3RhdHMpO1xuXHRcdH1cblx0XHRWaWV3Ll92aWV3cy5wdXNoKHRoaXMpO1xuXHRcdFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF0gPSB0aGlzO1xuXHRcdHRoaXMuX3ZpZXdTaXplID0gc2l6ZTtcblx0XHQodGhpcy5fbWF0cml4ID0gbmV3IE1hdHJpeCgpKS5fb3duZXIgPSB0aGlzO1xuXHRcdHRoaXMuX3pvb20gPSAxO1xuXHRcdGlmICghVmlldy5fZm9jdXNlZClcblx0XHRcdFZpZXcuX2ZvY3VzZWQgPSB0aGlzO1xuXHRcdHRoaXMuX2ZyYW1lSXRlbXMgPSB7fTtcblx0XHR0aGlzLl9mcmFtZUl0ZW1Db3VudCA9IDA7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX3Byb2plY3QpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0aWYgKFZpZXcuX2ZvY3VzZWQgPT09IHRoaXMpXG5cdFx0XHRWaWV3Ll9mb2N1c2VkID0gbnVsbDtcblx0XHRWaWV3Ll92aWV3cy5zcGxpY2UoVmlldy5fdmlld3MuaW5kZXhPZih0aGlzKSwgMSk7XG5cdFx0ZGVsZXRlIFZpZXcuX3ZpZXdzQnlJZFt0aGlzLl9pZF07XG5cdFx0aWYgKHRoaXMuX3Byb2plY3QuX3ZpZXcgPT09IHRoaXMpXG5cdFx0XHR0aGlzLl9wcm9qZWN0Ll92aWV3ID0gbnVsbDtcblx0XHREb21FdmVudC5yZW1vdmUodGhpcy5fZWxlbWVudCwgdGhpcy5fdmlld0V2ZW50cyk7XG5cdFx0RG9tRXZlbnQucmVtb3ZlKHdpbmRvdywgdGhpcy5fd2luZG93RXZlbnRzKTtcblx0XHR0aGlzLl9lbGVtZW50ID0gdGhpcy5fcHJvamVjdCA9IG51bGw7XG5cdFx0dGhpcy5vZmYoJ2ZyYW1lJyk7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xuXHRcdHRoaXMuX2ZyYW1lSXRlbXMgPSB7fTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfZXZlbnRzOiBCYXNlLmVhY2goWydvblJlc2l6ZScsICdvbk1vdXNlRG93bicsICdvbk1vdXNlVXAnLCAnb25Nb3VzZU1vdmUnXSxcblx0XHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0XHR0aGlzW25hbWVdID0ge1xuXHRcdFx0XHRpbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50KHR5cGUpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHRcdHRoaXMuX3VuaW5zdGFsbEV2ZW50KHR5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0sIHtcblx0XHRcdG9uRnJhbWU6IHtcblx0XHRcdFx0aW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5wbGF5KCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHR0aGlzLnBhdXNlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdCksXG5cblx0X2FuaW1hdGU6IGZhbHNlLFxuXHRfdGltZTogMCxcblx0X2NvdW50OiAwLFxuXG5cdF9yZXF1ZXN0RnJhbWU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciB0aGF0ID0gdGhpcztcblx0XHREb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGF0Ll9yZXF1ZXN0ZWQgPSBmYWxzZTtcblx0XHRcdGlmICghdGhhdC5fYW5pbWF0ZSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dGhhdC5fcmVxdWVzdEZyYW1lKCk7XG5cdFx0XHR0aGF0Ll9oYW5kbGVGcmFtZSgpO1xuXHRcdH0sIHRoaXMuX2VsZW1lbnQpO1xuXHRcdHRoaXMuX3JlcXVlc3RlZCA9IHRydWU7XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lOiBmdW5jdGlvbigpIHtcblx0XHRwYXBlciA9IHRoaXMuX3Njb3BlO1xuXHRcdHZhciBub3cgPSBEYXRlLm5vdygpIC8gMTAwMCxcblx0XHRcdGRlbHRhID0gdGhpcy5fYmVmb3JlID8gbm93IC0gdGhpcy5fYmVmb3JlIDogMDtcblx0XHR0aGlzLl9iZWZvcmUgPSBub3c7XG5cdFx0dGhpcy5faGFuZGxpbmdGcmFtZSA9IHRydWU7XG5cdFx0dGhpcy5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKHtcblx0XHRcdGRlbHRhOiBkZWx0YSxcblx0XHRcdHRpbWU6IHRoaXMuX3RpbWUgKz0gZGVsdGEsXG5cdFx0XHRjb3VudDogdGhpcy5fY291bnQrK1xuXHRcdH0pKTtcblx0XHRpZiAodGhpcy5fc3RhdHMpXG5cdFx0XHR0aGlzLl9zdGF0cy51cGRhdGUoKTtcblx0XHR0aGlzLl9oYW5kbGluZ0ZyYW1lID0gZmFsc2U7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fSxcblxuXHRfYW5pbWF0ZUl0ZW06IGZ1bmN0aW9uKGl0ZW0sIGFuaW1hdGUpIHtcblx0XHR2YXIgaXRlbXMgPSB0aGlzLl9mcmFtZUl0ZW1zO1xuXHRcdGlmIChhbmltYXRlKSB7XG5cdFx0XHRpdGVtc1tpdGVtLl9pZF0gPSB7XG5cdFx0XHRcdGl0ZW06IGl0ZW0sXG5cdFx0XHRcdHRpbWU6IDAsXG5cdFx0XHRcdGNvdW50OiAwXG5cdFx0XHR9O1xuXHRcdFx0aWYgKCsrdGhpcy5fZnJhbWVJdGVtQ291bnQgPT09IDEpXG5cdFx0XHRcdHRoaXMub24oJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbGV0ZSBpdGVtc1tpdGVtLl9pZF07XG5cdFx0XHRpZiAoLS10aGlzLl9mcmFtZUl0ZW1Db3VudCA9PT0gMCkge1xuXHRcdFx0XHR0aGlzLm9mZignZnJhbWUnLCB0aGlzLl9oYW5kbGVGcmFtZUl0ZW1zKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2hhbmRsZUZyYW1lSXRlbXM6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0Zm9yICh2YXIgaSBpbiB0aGlzLl9mcmFtZUl0ZW1zKSB7XG5cdFx0XHR2YXIgZW50cnkgPSB0aGlzLl9mcmFtZUl0ZW1zW2ldO1xuXHRcdFx0ZW50cnkuaXRlbS5lbWl0KCdmcmFtZScsIG5ldyBCYXNlKGV2ZW50LCB7XG5cdFx0XHRcdHRpbWU6IGVudHJ5LnRpbWUgKz0gZXZlbnQuZGVsdGEsXG5cdFx0XHRcdGNvdW50OiBlbnRyeS5jb3VudCsrXG5cdFx0XHR9KSk7XG5cdFx0fVxuXHR9LFxuXG5cdF91cGRhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3Byb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRpZiAodGhpcy5faGFuZGxpbmdGcmFtZSlcblx0XHRcdHJldHVybjtcblx0XHRpZiAodGhpcy5fYW5pbWF0ZSkge1xuXHRcdFx0dGhpcy5faGFuZGxlRnJhbWUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGhpcy51cGRhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKGZsYWdzKSB7XG5cdFx0aWYgKGZsYWdzICYgMSlcblx0XHRcdHRoaXMuX3Byb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0fSxcblxuXHRfdHJhbnNmb3JtOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR0aGlzLl9tYXRyaXguY29uY2F0ZW5hdGUobWF0cml4KTtcblx0XHR0aGlzLl9ib3VuZHMgPSBudWxsO1xuXHRcdHRoaXMuX3VwZGF0ZSgpO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9lbGVtZW50O1xuXHR9LFxuXG5cdGdldFBpeGVsUmF0aW86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9waXhlbFJhdGlvO1xuXHR9LFxuXG5cdGdldFJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9waXhlbFJhdGlvICogNzI7XG5cdH0sXG5cblx0Z2V0Vmlld1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fdmlld1NpemU7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCB0aGlzLCAnc2V0Vmlld1NpemUnKTtcblx0fSxcblxuXHRzZXRWaWV3U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGRlbHRhID0gc2l6ZS5zdWJ0cmFjdCh0aGlzLl92aWV3U2l6ZSk7XG5cdFx0aWYgKGRlbHRhLmlzWmVybygpKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHRoaXMuX3ZpZXdTaXplLnNldChzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdFx0dGhpcy5fc2V0Vmlld1NpemUoc2l6ZSk7XG5cdFx0dGhpcy5fYm91bmRzID0gbnVsbDtcblx0XHR0aGlzLmVtaXQoJ3Jlc2l6ZScsIHtcblx0XHRcdHNpemU6IHNpemUsXG5cdFx0XHRkZWx0YTogZGVsdGFcblx0XHR9KTtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRfc2V0Vmlld1NpemU6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuX2VsZW1lbnQ7XG5cdFx0ZWxlbWVudC53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0ZWxlbWVudC5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0fSxcblxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fYm91bmRzKVxuXHRcdFx0dGhpcy5fYm91bmRzID0gdGhpcy5fbWF0cml4LmludmVydGVkKCkuX3RyYW5zZm9ybUJvdW5kcyhcblx0XHRcdFx0XHRuZXcgUmVjdGFuZ2xlKG5ldyBQb2ludCgpLCB0aGlzLl92aWV3U2l6ZSkpO1xuXHRcdHJldHVybiB0aGlzLl9ib3VuZHM7XG5cdH0sXG5cblx0Z2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuZ2V0U2l6ZSgpO1xuXHR9LFxuXG5cdGdldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKCk7XG5cdH0sXG5cblx0c2V0Q2VudGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuc2Nyb2xsQnkoY2VudGVyLnN1YnRyYWN0KHRoaXMuZ2V0Q2VudGVyKCkpKTtcblx0fSxcblxuXHRnZXRab29tOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fem9vbTtcblx0fSxcblxuXHRzZXRab29tOiBmdW5jdGlvbih6b29tKSB7XG5cdFx0dGhpcy5fdHJhbnNmb3JtKG5ldyBNYXRyaXgoKS5zY2FsZSh6b29tIC8gdGhpcy5fem9vbSxcblx0XHRcdHRoaXMuZ2V0Q2VudGVyKCkpKTtcblx0XHR0aGlzLl96b29tID0gem9vbTtcblx0fSxcblxuXHRpc1Zpc2libGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBEb21FbGVtZW50LmlzSW5WaWV3KHRoaXMuX2VsZW1lbnQpO1xuXHR9LFxuXG5cdHNjcm9sbEJ5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl90cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShQb2ludC5yZWFkKGFyZ3VtZW50cykubmVnYXRlKCkpKTtcblx0fSxcblxuXHRwbGF5OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hbmltYXRlID0gdHJ1ZTtcblx0XHRpZiAoIXRoaXMuX3JlcXVlc3RlZClcblx0XHRcdHRoaXMuX3JlcXVlc3RGcmFtZSgpO1xuXHR9LFxuXG5cdHBhdXNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9hbmltYXRlID0gZmFsc2U7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy51cGRhdGUoKTtcblx0fSxcblxuXHRwcm9qZWN0VG9WaWV3OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdHZpZXdUb1Byb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fVxuXG59LCB7XG5cdHN0YXRpY3M6IHtcblx0XHRfdmlld3M6IFtdLFxuXHRcdF92aWV3c0J5SWQ6IHt9LFxuXHRcdF9pZDogMCxcblxuXHRcdGNyZWF0ZTogZnVuY3Rpb24ocHJvamVjdCwgZWxlbWVudCkge1xuXHRcdFx0aWYgKHR5cGVvZiBlbGVtZW50ID09PSAnc3RyaW5nJylcblx0XHRcdFx0ZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGVsZW1lbnQpO1xuXHRcdFx0cmV0dXJuIG5ldyBDYW52YXNWaWV3KHByb2plY3QsIGVsZW1lbnQpO1xuXHRcdH1cblx0fVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIHRvb2wsXG5cdFx0cHJldkZvY3VzLFxuXHRcdHRlbXBGb2N1cyxcblx0XHRkcmFnZ2luZyA9IGZhbHNlO1xuXG5cdGZ1bmN0aW9uIGdldFZpZXcoZXZlbnQpIHtcblx0XHR2YXIgdGFyZ2V0ID0gRG9tRXZlbnQuZ2V0VGFyZ2V0KGV2ZW50KTtcblx0XHRyZXR1cm4gdGFyZ2V0LmdldEF0dHJpYnV0ZSAmJiBWaWV3Ll92aWV3c0J5SWRbdGFyZ2V0LmdldEF0dHJpYnV0ZSgnaWQnKV07XG5cdH1cblxuXHRmdW5jdGlvbiB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KSB7XG5cdFx0cmV0dXJuIHZpZXcudmlld1RvUHJvamVjdChEb21FdmVudC5nZXRPZmZzZXQoZXZlbnQsIHZpZXcuX2VsZW1lbnQpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHVwZGF0ZUZvY3VzKCkge1xuXHRcdGlmICghVmlldy5fZm9jdXNlZCB8fCAhVmlldy5fZm9jdXNlZC5pc1Zpc2libGUoKSkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBWaWV3Ll92aWV3cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZpZXcgPSBWaWV3Ll92aWV3c1tpXTtcblx0XHRcdFx0aWYgKHZpZXcgJiYgdmlldy5pc1Zpc2libGUoKSkge1xuXHRcdFx0XHRcdFZpZXcuX2ZvY3VzZWQgPSB0ZW1wRm9jdXMgPSB2aWV3O1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gaGFuZGxlTW91c2VNb3ZlKHZpZXcsIHBvaW50LCBldmVudCkge1xuXHRcdHZpZXcuX2hhbmRsZUV2ZW50KCdtb3VzZW1vdmUnLCBwb2ludCwgZXZlbnQpO1xuXHRcdHZhciB0b29sID0gdmlldy5fc2NvcGUudG9vbDtcblx0XHRpZiAodG9vbCkge1xuXHRcdFx0dG9vbC5faGFuZGxlRXZlbnQoZHJhZ2dpbmcgJiYgdG9vbC5yZXNwb25kcygnbW91c2VkcmFnJylcblx0XHRcdFx0XHQ/ICdtb3VzZWRyYWcnIDogJ21vdXNlbW92ZScsIHBvaW50LCBldmVudCk7XG5cdFx0fVxuXHRcdHZpZXcudXBkYXRlKCk7XG5cdFx0cmV0dXJuIHRvb2w7XG5cdH1cblxuXHR2YXIgbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcixcblx0XHRtb3VzZWRvd24sIG1vdXNlbW92ZSwgbW91c2V1cDtcblx0aWYgKG5hdmlnYXRvci5wb2ludGVyRW5hYmxlZCB8fCBuYXZpZ2F0b3IubXNQb2ludGVyRW5hYmxlZCkge1xuXHRcdG1vdXNlZG93biA9ICdwb2ludGVyZG93biBNU1BvaW50ZXJEb3duJztcblx0XHRtb3VzZW1vdmUgPSAncG9pbnRlcm1vdmUgTVNQb2ludGVyTW92ZSc7XG5cdFx0bW91c2V1cCA9ICdwb2ludGVydXAgcG9pbnRlcmNhbmNlbCBNU1BvaW50ZXJVcCBNU1BvaW50ZXJDYW5jZWwnO1xuXHR9IGVsc2Uge1xuXHRcdG1vdXNlZG93biA9ICd0b3VjaHN0YXJ0Jztcblx0XHRtb3VzZW1vdmUgPSAndG91Y2htb3ZlJztcblx0XHRtb3VzZXVwID0gJ3RvdWNoZW5kIHRvdWNoY2FuY2VsJztcblx0XHRpZiAoISgnb250b3VjaHN0YXJ0JyBpbiB3aW5kb3cgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC5tYXRjaChcblx0XHRcdFx0L21vYmlsZXx0YWJsZXR8aXAoYWR8aG9uZXxvZCl8YW5kcm9pZHxzaWxrL2kpKSkge1xuXHRcdFx0bW91c2Vkb3duICs9ICcgbW91c2Vkb3duJztcblx0XHRcdG1vdXNlbW92ZSArPSAnIG1vdXNlbW92ZSc7XG5cdFx0XHRtb3VzZXVwICs9ICcgbW91c2V1cCc7XG5cdFx0fVxuXHR9XG5cblx0dmFyIHZpZXdFdmVudHMgPSB7XG5cdFx0J3NlbGVjdHN0YXJ0IGRyYWdzdGFydCc6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRpZiAoZHJhZ2dpbmcpXG5cdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBkb2NFdmVudHMgPSB7XG5cdFx0bW91c2VvdXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQsXG5cdFx0XHRcdHRhcmdldCA9IERvbUV2ZW50LmdldFJlbGF0ZWRUYXJnZXQoZXZlbnQpO1xuXHRcdFx0aWYgKHZpZXcgJiYgKCF0YXJnZXQgfHwgdGFyZ2V0Lm5vZGVOYW1lID09PSAnSFRNTCcpKVxuXHRcdFx0XHRoYW5kbGVNb3VzZU1vdmUodmlldywgdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCksIGV2ZW50KTtcblx0XHR9LFxuXG5cdFx0c2Nyb2xsOiB1cGRhdGVGb2N1c1xuXHR9O1xuXG5cdHZpZXdFdmVudHNbbW91c2Vkb3duXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkID0gZ2V0VmlldyhldmVudCksXG5cdFx0XHRwb2ludCA9IHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpO1xuXHRcdGRyYWdnaW5nID0gdHJ1ZTtcblx0XHR2aWV3Ll9oYW5kbGVFdmVudCgnbW91c2Vkb3duJywgcG9pbnQsIGV2ZW50KTtcblx0XHRpZiAodG9vbCA9IHZpZXcuX3Njb3BlLnRvb2wpXG5cdFx0XHR0b29sLl9oYW5kbGVFdmVudCgnbW91c2Vkb3duJywgcG9pbnQsIGV2ZW50KTtcblx0XHR2aWV3LnVwZGF0ZSgpO1xuXHR9O1xuXG5cdGRvY0V2ZW50c1ttb3VzZW1vdmVdID0gZnVuY3Rpb24oZXZlbnQpIHtcblx0XHR2YXIgdmlldyA9IFZpZXcuX2ZvY3VzZWQ7XG5cdFx0aWYgKCFkcmFnZ2luZykge1xuXHRcdFx0dmFyIHRhcmdldCA9IGdldFZpZXcoZXZlbnQpO1xuXHRcdFx0aWYgKHRhcmdldCkge1xuXHRcdFx0XHRpZiAodmlldyAhPT0gdGFyZ2V0KVxuXHRcdFx0XHRcdGhhbmRsZU1vdXNlTW92ZSh2aWV3LCB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KSwgZXZlbnQpO1xuXHRcdFx0XHRwcmV2Rm9jdXMgPSB2aWV3O1xuXHRcdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCA9IHRlbXBGb2N1cyA9IHRhcmdldDtcblx0XHRcdH0gZWxzZSBpZiAodGVtcEZvY3VzICYmIHRlbXBGb2N1cyA9PT0gdmlldykge1xuXHRcdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCA9IHByZXZGb2N1cztcblx0XHRcdFx0dXBkYXRlRm9jdXMoKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHZpZXcpIHtcblx0XHRcdHZhciBwb2ludCA9IHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpO1xuXHRcdFx0aWYgKGRyYWdnaW5nIHx8IHZpZXcuZ2V0Qm91bmRzKCkuY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHR0b29sID0gaGFuZGxlTW91c2VNb3ZlKHZpZXcsIHBvaW50LCBldmVudCk7XG5cdFx0fVxuXHR9O1xuXG5cdGRvY0V2ZW50c1ttb3VzZXVwXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkO1xuXHRcdGlmICghdmlldyB8fCAhZHJhZ2dpbmcpXG5cdFx0XHRyZXR1cm47XG5cdFx0dmFyIHBvaW50ID0gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCk7XG5cdFx0ZHJhZ2dpbmcgPSBmYWxzZTtcblx0XHR2aWV3Ll9oYW5kbGVFdmVudCgnbW91c2V1cCcsIHBvaW50LCBldmVudCk7XG5cdFx0aWYgKHRvb2wpXG5cdFx0XHR0b29sLl9oYW5kbGVFdmVudCgnbW91c2V1cCcsIHBvaW50LCBldmVudCk7XG5cdFx0dmlldy51cGRhdGUoKTtcblx0fTtcblxuXHREb21FdmVudC5hZGQoZG9jdW1lbnQsIGRvY0V2ZW50cyk7XG5cblx0RG9tRXZlbnQuYWRkKHdpbmRvdywge1xuXHRcdGxvYWQ6IHVwZGF0ZUZvY3VzXG5cdH0pO1xuXG5cdHZhciBtb3VzZUZsYWdzID0ge1xuXHRcdG1vdXNlZG93bjoge1xuXHRcdFx0bW91c2Vkb3duOiAxLFxuXHRcdFx0bW91c2VkcmFnOiAxLFxuXHRcdFx0Y2xpY2s6IDEsXG5cdFx0XHRkb3VibGVjbGljazogMVxuXHRcdH0sXG5cdFx0bW91c2V1cDoge1xuXHRcdFx0bW91c2V1cDogMSxcblx0XHRcdG1vdXNlZHJhZzogMSxcblx0XHRcdGNsaWNrOiAxLFxuXHRcdFx0ZG91YmxlY2xpY2s6IDFcblx0XHR9LFxuXHRcdG1vdXNlbW92ZToge1xuXHRcdFx0bW91c2VkcmFnOiAxLFxuXHRcdFx0bW91c2Vtb3ZlOiAxLFxuXHRcdFx0bW91c2VlbnRlcjogMSxcblx0XHRcdG1vdXNlbGVhdmU6IDFcblx0XHR9XG5cdH07XG5cblx0cmV0dXJuIHtcblx0XHRfdmlld0V2ZW50czogdmlld0V2ZW50cyxcblxuXHRcdF9oYW5kbGVFdmVudDogZnVuY3Rpb24oKSB7fSxcblxuXHRcdF9pbnN0YWxsRXZlbnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBjb3VudGVycyA9IHRoaXMuX2V2ZW50Q291bnRlcnM7XG5cdFx0XHRpZiAoY291bnRlcnMpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG1vdXNlRmxhZ3MpIHtcblx0XHRcdFx0XHRjb3VudGVyc1trZXldID0gKGNvdW50ZXJzW2tleV0gfHwgMClcblx0XHRcdFx0XHRcdFx0KyAobW91c2VGbGFnc1trZXldW3R5cGVdIHx8IDApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF91bmluc3RhbGxFdmVudDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0dmFyIGNvdW50ZXJzID0gdGhpcy5fZXZlbnRDb3VudGVycztcblx0XHRcdGlmIChjb3VudGVycykge1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gbW91c2VGbGFncylcblx0XHRcdFx0XHRjb3VudGVyc1trZXldIC09IG1vdXNlRmxhZ3Nba2V5XVt0eXBlXSB8fCAwO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHR1cGRhdGVGb2N1czogdXBkYXRlRm9jdXNcblx0XHR9XG5cdH07XG59KTtcblxudmFyIENhbnZhc1ZpZXcgPSBWaWV3LmV4dGVuZCh7XG5cdF9jbGFzczogJ0NhbnZhc1ZpZXcnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIENhbnZhc1ZpZXcocHJvamVjdCwgY2FudmFzKSB7XG5cdFx0aWYgKCEoY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMsIDEpO1xuXHRcdFx0aWYgKHNpemUuaXNaZXJvKCkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIENhbnZhc1ZpZXcgd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnQ6ICdcblx0XHRcdFx0XHRcdCsgW10uc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcblx0XHRcdGNhbnZhcyA9IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKTtcblx0XHR9XG5cdFx0dGhpcy5fY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdHRoaXMuX2V2ZW50Q291bnRlcnMgPSB7fTtcblx0XHR0aGlzLl9waXhlbFJhdGlvID0gMTtcblx0XHRpZiAoIS9eb2ZmfGZhbHNlJC8udGVzdChQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShjYW52YXMsICdoaWRwaScpKSkge1xuXHRcdFx0dmFyIGRldmljZVJhdGlvID0gd2luZG93LmRldmljZVBpeGVsUmF0aW8gfHwgMSxcblx0XHRcdFx0YmFja2luZ1N0b3JlUmF0aW8gPSBEb21FbGVtZW50LmdldFByZWZpeGVkKHRoaXMuX2NvbnRleHQsXG5cdFx0XHRcdFx0XHQnYmFja2luZ1N0b3JlUGl4ZWxSYXRpbycpIHx8IDE7XG5cdFx0XHR0aGlzLl9waXhlbFJhdGlvID0gZGV2aWNlUmF0aW8gLyBiYWNraW5nU3RvcmVSYXRpbztcblx0XHR9XG5cdFx0Vmlldy5jYWxsKHRoaXMsIHByb2plY3QsIGNhbnZhcyk7XG5cdH0sXG5cblx0X3NldFZpZXdTaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50LFxuXHRcdFx0cGl4ZWxSYXRpbyA9IHRoaXMuX3BpeGVsUmF0aW8sXG5cdFx0XHR3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRlbGVtZW50LndpZHRoID0gd2lkdGggKiBwaXhlbFJhdGlvO1xuXHRcdGVsZW1lbnQuaGVpZ2h0ID0gaGVpZ2h0ICogcGl4ZWxSYXRpbztcblx0XHRpZiAocGl4ZWxSYXRpbyAhPT0gMSkge1xuXHRcdFx0aWYgKCFQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShlbGVtZW50LCAncmVzaXplJykpIHtcblx0XHRcdFx0dmFyIHN0eWxlID0gZWxlbWVudC5zdHlsZTtcblx0XHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aCArICdweCc7XG5cdFx0XHRcdHN0eWxlLmhlaWdodCA9IGhlaWdodCArICdweCc7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jb250ZXh0LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXHRcdH1cblx0fSxcblxuXHRnZXRQaXhlbFNpemU6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHR2YXIgYnJvd3NlciA9IHBhcGVyLmJyb3dzZXIsXG5cdFx0XHRwaXhlbHM7XG5cdFx0aWYgKGJyb3dzZXIgJiYgYnJvd3Nlci5maXJlZm94KSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5fZWxlbWVudC5wYXJlbnROb2RlLFxuXHRcdFx0XHR0ZW1wID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG5cdFx0XHR0ZW1wLnN0eWxlLmZvbnRTaXplID0gc2l6ZTtcblx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZCh0ZW1wKTtcblx0XHRcdHBpeGVscyA9IHBhcnNlRmxvYXQoRG9tRWxlbWVudC5nZXRTdHlsZXModGVtcCkuZm9udFNpemUpO1xuXHRcdFx0cGFyZW50LnJlbW92ZUNoaWxkKHRlbXApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdFx0cHJldkZvbnQgPSBjdHguZm9udDtcblx0XHRcdGN0eC5mb250ID0gc2l6ZSArICcgc2VyaWYnO1xuXHRcdFx0cGl4ZWxzID0gcGFyc2VGbG9hdChjdHguZm9udCk7XG5cdFx0XHRjdHguZm9udCA9IHByZXZGb250O1xuXHRcdH1cblx0XHRyZXR1cm4gcGl4ZWxzO1xuXHR9LFxuXG5cdGdldFRleHRXaWR0aDogZnVuY3Rpb24oZm9udCwgbGluZXMpIHtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdHByZXZGb250ID0gY3R4LmZvbnQsXG5cdFx0XHR3aWR0aCA9IDA7XG5cdFx0Y3R4LmZvbnQgPSBmb250O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0d2lkdGggPSBNYXRoLm1heCh3aWR0aCwgY3R4Lm1lYXN1cmVUZXh0KGxpbmVzW2ldKS53aWR0aCk7XG5cdFx0Y3R4LmZvbnQgPSBwcmV2Rm9udDtcblx0XHRyZXR1cm4gd2lkdGg7XG5cdH0sXG5cblx0dXBkYXRlOiBmdW5jdGlvbihmb3JjZSkge1xuXHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRpZiAoIXByb2plY3QgfHwgIWZvcmNlICYmICFwcm9qZWN0Ll9uZWVkc1VwZGF0ZSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgY3R4ID0gdGhpcy5fY29udGV4dCxcblx0XHRcdHNpemUgPSB0aGlzLl92aWV3U2l6ZTtcblx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHNpemUud2lkdGggKyAxLCBzaXplLmhlaWdodCArIDEpO1xuXHRcdHByb2plY3QuZHJhdyhjdHgsIHRoaXMuX21hdHJpeCwgdGhpcy5fcGl4ZWxSYXRpbyk7XG5cdFx0cHJvamVjdC5fbmVlZHNVcGRhdGUgPSBmYWxzZTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGRvd25Qb2ludCxcblx0XHRsYXN0UG9pbnQsXG5cdFx0b3ZlclBvaW50LFxuXHRcdGRvd25JdGVtLFxuXHRcdGxhc3RJdGVtLFxuXHRcdG92ZXJJdGVtLFxuXHRcdGRyYWdJdGVtLFxuXHRcdGRibENsaWNrLFxuXHRcdGNsaWNrVGltZTtcblxuXHRmdW5jdGlvbiBjYWxsRXZlbnQodmlldywgdHlwZSwgZXZlbnQsIHBvaW50LCB0YXJnZXQsIGxhc3RQb2ludCkge1xuXHRcdHZhciBpdGVtID0gdGFyZ2V0LFxuXHRcdFx0bW91c2VFdmVudDtcblxuXHRcdGZ1bmN0aW9uIGNhbGwob2JqKSB7XG5cdFx0XHRpZiAob2JqLnJlc3BvbmRzKHR5cGUpKSB7XG5cdFx0XHRcdGlmICghbW91c2VFdmVudCkge1xuXHRcdFx0XHRcdG1vdXNlRXZlbnQgPSBuZXcgTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCxcblx0XHRcdFx0XHRcdFx0bGFzdFBvaW50ID8gcG9pbnQuc3VidHJhY3QobGFzdFBvaW50KSA6IG51bGwpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChvYmouZW1pdCh0eXBlLCBtb3VzZUV2ZW50KSAmJiBtb3VzZUV2ZW50LmlzU3RvcHBlZCkge1xuXHRcdFx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHR3aGlsZSAoaXRlbSkge1xuXHRcdFx0aWYgKGNhbGwoaXRlbSkpXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0aXRlbSA9IGl0ZW0uZ2V0UGFyZW50KCk7XG5cdFx0fVxuXHRcdGlmIChjYWxsKHZpZXcpKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHBvaW50LCBldmVudCkge1xuXHRcdFx0aWYgKCF0aGlzLl9ldmVudENvdW50ZXJzW3R5cGVdKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdGhpdCA9IHByb2plY3QuaGl0VGVzdChwb2ludCwge1xuXHRcdFx0XHRcdHRvbGVyYW5jZTogMCxcblx0XHRcdFx0XHRmaWxsOiB0cnVlLFxuXHRcdFx0XHRcdHN0cm9rZTogdHJ1ZVxuXHRcdFx0XHR9KSxcblx0XHRcdFx0aXRlbSA9IGhpdCAmJiBoaXQuaXRlbSxcblx0XHRcdFx0c3RvcHBlZCA9IGZhbHNlO1xuXHRcdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50LCBwb2ludCwgaXRlbSk7XG5cdFx0XHRcdGRibENsaWNrID0gbGFzdEl0ZW0gPT0gaXRlbSAmJiAoRGF0ZS5ub3coKSAtIGNsaWNrVGltZSA8IDMwMCk7XG5cdFx0XHRcdGRvd25JdGVtID0gbGFzdEl0ZW0gPSBpdGVtO1xuXHRcdFx0XHRkb3duUG9pbnQgPSBsYXN0UG9pbnQgPSBvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0ZHJhZ0l0ZW0gPSAhc3RvcHBlZCAmJiBpdGVtO1xuXHRcdFx0XHR3aGlsZSAoZHJhZ0l0ZW0gJiYgIWRyYWdJdGVtLnJlc3BvbmRzKCdtb3VzZWRyYWcnKSlcblx0XHRcdFx0XHRkcmFnSXRlbSA9IGRyYWdJdGVtLl9wYXJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgdHlwZSwgZXZlbnQsIHBvaW50LCBpdGVtLCBkb3duUG9pbnQpO1xuXHRcdFx0XHRpZiAoZHJhZ0l0ZW0pIHtcblx0XHRcdFx0XHRpZiAobGFzdFBvaW50ICYmICFsYXN0UG9pbnQuZXF1YWxzKHBvaW50KSlcblx0XHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCAnbW91c2VkcmFnJywgZXZlbnQsIHBvaW50LCBkcmFnSXRlbSxcblx0XHRcdFx0XHRcdFx0XHRsYXN0UG9pbnQpO1xuXHRcdFx0XHRcdGlmIChpdGVtICE9PSBkcmFnSXRlbSkge1xuXHRcdFx0XHRcdFx0b3ZlclBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlbW92ZScsIGV2ZW50LCBwb2ludCwgaXRlbSxcblx0XHRcdFx0XHRcdFx0XHRvdmVyUG9pbnQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXN0b3BwZWQgJiYgaXRlbSAmJiBpdGVtID09PSBkb3duSXRlbSkge1xuXHRcdFx0XHRcdGNsaWNrVGltZSA9IERhdGUubm93KCk7XG5cdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsIGRibENsaWNrICYmIGRvd25JdGVtLnJlc3BvbmRzKCdkb3VibGVjbGljaycpXG5cdFx0XHRcdFx0XHRcdD8gJ2RvdWJsZWNsaWNrJyA6ICdjbGljaycsIGV2ZW50LCBkb3duUG9pbnQsIGl0ZW0pO1xuXHRcdFx0XHRcdGRibENsaWNrID0gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZG93bkl0ZW0gPSBkcmFnSXRlbSA9IG51bGw7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdFx0aWYgKGRyYWdJdGVtKVxuXHRcdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgJ21vdXNlZHJhZycsIGV2ZW50LCBwb2ludCxcblx0XHRcdFx0XHRcdFx0ZHJhZ0l0ZW0sIGxhc3RQb2ludCk7XG5cdFx0XHRcdGlmICghc3RvcHBlZCkge1xuXHRcdFx0XHRcdGlmIChpdGVtICE9PSBvdmVySXRlbSlcblx0XHRcdFx0XHRcdG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRcdHN0b3BwZWQgPSBjYWxsRXZlbnQodGhpcywgdHlwZSwgZXZlbnQsIHBvaW50LCBpdGVtLFxuXHRcdFx0XHRcdFx0XHRvdmVyUG9pbnQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxhc3RQb2ludCA9IG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRpZiAoaXRlbSAhPT0gb3Zlckl0ZW0pIHtcblx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlbGVhdmUnLCBldmVudCwgcG9pbnQsIG92ZXJJdGVtKTtcblx0XHRcdFx0XHRvdmVySXRlbSA9IGl0ZW07XG5cdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZWVudGVyJywgZXZlbnQsIHBvaW50LCBpdGVtKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdHJldHVybiBzdG9wcGVkO1xuXHRcdH1cblx0fTtcbn0pO1xuXG52YXIgRXZlbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0V2ZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBFdmVudChldmVudCkge1xuXHRcdHRoaXMuZXZlbnQgPSBldmVudDtcblx0fSxcblxuXHRpc1ByZXZlbnRlZDogZmFsc2UsXG5cdGlzU3RvcHBlZDogZmFsc2UsXG5cblx0cHJldmVudERlZmF1bHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaXNQcmV2ZW50ZWQgPSB0cnVlO1xuXHRcdHRoaXMuZXZlbnQucHJldmVudERlZmF1bHQoKTtcblx0fSxcblxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuaXNTdG9wcGVkID0gdHJ1ZTtcblx0XHR0aGlzLmV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9LFxuXG5cdHN0b3A6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuc3RvcFByb3BhZ2F0aW9uKCk7XG5cdFx0dGhpcy5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9LFxuXG5cdGdldE1vZGlmaWVyczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEtleS5tb2RpZmllcnM7XG5cdH1cbn0pO1xuXG52YXIgS2V5RXZlbnQgPSBFdmVudC5leHRlbmQoe1xuXHRfY2xhc3M6ICdLZXlFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gS2V5RXZlbnQoZG93biwga2V5LCBjaGFyYWN0ZXIsIGV2ZW50KSB7XG5cdFx0RXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0dGhpcy50eXBlID0gZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCc7XG5cdFx0dGhpcy5rZXkgPSBrZXk7XG5cdFx0dGhpcy5jaGFyYWN0ZXIgPSBjaGFyYWN0ZXI7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgXCInLCBrZXk6ICdcIiArIHRoaXMua2V5XG5cdFx0XHRcdCsgXCInLCBjaGFyYWN0ZXI6ICdcIiArIHRoaXMuY2hhcmFjdGVyXG5cdFx0XHRcdCsgXCInLCBtb2RpZmllcnM6IFwiICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrIFwiIH1cIjtcblx0fVxufSk7XG5cbnZhciBLZXkgPSBuZXcgZnVuY3Rpb24oKSB7XG5cblx0dmFyIHNwZWNpYWxLZXlzID0ge1xuXHRcdDg6ICdiYWNrc3BhY2UnLFxuXHRcdDk6ICd0YWInLFxuXHRcdDEzOiAnZW50ZXInLFxuXHRcdDE2OiAnc2hpZnQnLFxuXHRcdDE3OiAnY29udHJvbCcsXG5cdFx0MTg6ICdvcHRpb24nLFxuXHRcdDE5OiAncGF1c2UnLFxuXHRcdDIwOiAnY2Fwcy1sb2NrJyxcblx0XHQyNzogJ2VzY2FwZScsXG5cdFx0MzI6ICdzcGFjZScsXG5cdFx0MzU6ICdlbmQnLFxuXHRcdDM2OiAnaG9tZScsXG5cdFx0Mzc6ICdsZWZ0Jyxcblx0XHQzODogJ3VwJyxcblx0XHQzOTogJ3JpZ2h0Jyxcblx0XHQ0MDogJ2Rvd24nLFxuXHRcdDQ2OiAnZGVsZXRlJyxcblx0XHQ5MTogJ2NvbW1hbmQnLFxuXHRcdDkzOiAnY29tbWFuZCcsXG5cdFx0MjI0OiAnY29tbWFuZCdcblx0fSxcblxuXHRzcGVjaWFsQ2hhcnMgPSB7XG5cdFx0OTogdHJ1ZSxcblx0XHQxMzogdHJ1ZSxcblx0XHQzMjogdHJ1ZVxuXHR9LFxuXG5cdG1vZGlmaWVycyA9IG5ldyBCYXNlKHtcblx0XHRzaGlmdDogZmFsc2UsXG5cdFx0Y29udHJvbDogZmFsc2UsXG5cdFx0b3B0aW9uOiBmYWxzZSxcblx0XHRjb21tYW5kOiBmYWxzZSxcblx0XHRjYXBzTG9jazogZmFsc2UsXG5cdFx0c3BhY2U6IGZhbHNlXG5cdH0pLFxuXG5cdGNoYXJDb2RlTWFwID0ge30sXG5cdGtleU1hcCA9IHt9LFxuXHRjb21tYW5kRml4TWFwLFxuXHRkb3duQ29kZTtcblxuXHRmdW5jdGlvbiBoYW5kbGVLZXkoZG93biwga2V5Q29kZSwgY2hhckNvZGUsIGV2ZW50KSB7XG5cdFx0dmFyIGNoYXJhY3RlciA9IGNoYXJDb2RlID8gU3RyaW5nLmZyb21DaGFyQ29kZShjaGFyQ29kZSkgOiAnJyxcblx0XHRcdHNwZWNpYWxLZXkgPSBzcGVjaWFsS2V5c1trZXlDb2RlXSxcblx0XHRcdGtleSA9IHNwZWNpYWxLZXkgfHwgY2hhcmFjdGVyLnRvTG93ZXJDYXNlKCksXG5cdFx0XHR0eXBlID0gZG93biA/ICdrZXlkb3duJyA6ICdrZXl1cCcsXG5cdFx0XHR2aWV3ID0gVmlldy5fZm9jdXNlZCxcblx0XHRcdHNjb3BlID0gdmlldyAmJiB2aWV3LmlzVmlzaWJsZSgpICYmIHZpZXcuX3Njb3BlLFxuXHRcdFx0dG9vbCA9IHNjb3BlICYmIHNjb3BlLnRvb2wsXG5cdFx0XHRuYW1lO1xuXHRcdGtleU1hcFtrZXldID0gZG93bjtcblx0XHRpZiAoZG93bikge1xuXHRcdFx0Y2hhckNvZGVNYXBba2V5Q29kZV0gPSBjaGFyQ29kZTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGVsZXRlIGNoYXJDb2RlTWFwW2tleUNvZGVdO1xuXHRcdH1cblx0XHRpZiAoc3BlY2lhbEtleSAmJiAobmFtZSA9IEJhc2UuY2FtZWxpemUoc3BlY2lhbEtleSkpIGluIG1vZGlmaWVycykge1xuXHRcdFx0bW9kaWZpZXJzW25hbWVdID0gZG93bjtcblx0XHRcdHZhciBicm93c2VyID0gcGFwZXIuYnJvd3Nlcjtcblx0XHRcdGlmIChuYW1lID09PSAnY29tbWFuZCcgJiYgYnJvd3NlciAmJiBicm93c2VyLm1hYykge1xuXHRcdFx0XHRpZiAoZG93bikge1xuXHRcdFx0XHRcdGNvbW1hbmRGaXhNYXAgPSB7fTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRmb3IgKHZhciBjb2RlIGluIGNvbW1hbmRGaXhNYXApIHtcblx0XHRcdFx0XHRcdGlmIChjb2RlIGluIGNoYXJDb2RlTWFwKVxuXHRcdFx0XHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGNvZGUsIGNvbW1hbmRGaXhNYXBbY29kZV0sIGV2ZW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y29tbWFuZEZpeE1hcCA9IG51bGw7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKGRvd24gJiYgY29tbWFuZEZpeE1hcCkge1xuXHRcdFx0Y29tbWFuZEZpeE1hcFtrZXlDb2RlXSA9IGNoYXJDb2RlO1xuXHRcdH1cblx0XHRpZiAodG9vbCAmJiB0b29sLnJlc3BvbmRzKHR5cGUpKSB7XG5cdFx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdFx0dG9vbC5lbWl0KHR5cGUsIG5ldyBLZXlFdmVudChkb3duLCBrZXksIGNoYXJhY3RlciwgZXZlbnQpKTtcblx0XHRcdGlmICh2aWV3KVxuXHRcdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdH1cblx0fVxuXG5cdERvbUV2ZW50LmFkZChkb2N1bWVudCwge1xuXHRcdGtleWRvd246IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgY29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGU7XG5cdFx0XHRpZiAoY29kZSBpbiBzcGVjaWFsS2V5cyB8fCBtb2RpZmllcnMuY29tbWFuZCkge1xuXHRcdFx0XHRoYW5kbGVLZXkodHJ1ZSwgY29kZSxcblx0XHRcdFx0XHRcdGNvZGUgaW4gc3BlY2lhbENoYXJzIHx8IG1vZGlmaWVycy5jb21tYW5kID8gY29kZSA6IDAsXG5cdFx0XHRcdFx0XHRldmVudCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkb3duQ29kZSA9IGNvZGU7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGtleXByZXNzOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYgKGRvd25Db2RlICE9IG51bGwpIHtcblx0XHRcdFx0aGFuZGxlS2V5KHRydWUsIGRvd25Db2RlLCBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlLCBldmVudCk7XG5cdFx0XHRcdGRvd25Db2RlID0gbnVsbDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0a2V5dXA6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHR2YXIgY29kZSA9IGV2ZW50LndoaWNoIHx8IGV2ZW50LmtleUNvZGU7XG5cdFx0XHRpZiAoY29kZSBpbiBjaGFyQ29kZU1hcClcblx0XHRcdFx0aGFuZGxlS2V5KGZhbHNlLCBjb2RlLCBjaGFyQ29kZU1hcFtjb2RlXSwgZXZlbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0RG9tRXZlbnQuYWRkKHdpbmRvdywge1xuXHRcdGJsdXI6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0XHRmb3IgKHZhciBjb2RlIGluIGNoYXJDb2RlTWFwKVxuXHRcdFx0XHRoYW5kbGVLZXkoZmFsc2UsIGNvZGUsIGNoYXJDb2RlTWFwW2NvZGVdLCBldmVudCk7XG5cdFx0fVxuXHR9KTtcblxuXHRyZXR1cm4ge1xuXHRcdG1vZGlmaWVyczogbW9kaWZpZXJzLFxuXG5cdFx0aXNEb3duOiBmdW5jdGlvbihrZXkpIHtcblx0XHRcdHJldHVybiAhIWtleU1hcFtrZXldO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBNb3VzZUV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTW91c2VFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTW91c2VFdmVudCh0eXBlLCBldmVudCwgcG9pbnQsIHRhcmdldCwgZGVsdGEpIHtcblx0XHRFdmVudC5jYWxsKHRoaXMsIGV2ZW50KTtcblx0XHR0aGlzLnR5cGUgPSB0eXBlO1xuXHRcdHRoaXMucG9pbnQgPSBwb2ludDtcblx0XHR0aGlzLnRhcmdldCA9IHRhcmdldDtcblx0XHR0aGlzLmRlbHRhID0gZGVsdGE7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBcInsgdHlwZTogJ1wiICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgXCInLCBwb2ludDogXCIgKyB0aGlzLnBvaW50XG5cdFx0XHRcdCsgJywgdGFyZ2V0OiAnICsgdGhpcy50YXJnZXRcblx0XHRcdFx0KyAodGhpcy5kZWx0YSA/ICcsIGRlbHRhOiAnICsgdGhpcy5kZWx0YSA6ICcnKVxuXHRcdFx0XHQrICcsIG1vZGlmaWVyczogJyArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyAnIH0nO1xuXHR9XG59KTtcblxudmFyIFRvb2xFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG5cdF9jbGFzczogJ1Rvb2xFdmVudCcsXG5cdF9pdGVtOiBudWxsLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2xFdmVudCh0b29sLCB0eXBlLCBldmVudCkge1xuXHRcdHRoaXMudG9vbCA9IHRvb2w7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdH0sXG5cblx0X2Nob29zZVBvaW50OiBmdW5jdGlvbihwb2ludCwgdG9vbFBvaW50KSB7XG5cdFx0cmV0dXJuIHBvaW50ID8gcG9pbnQgOiB0b29sUG9pbnQgPyB0b29sUG9pbnQuY2xvbmUoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9wb2ludCwgdGhpcy50b29sLl9wb2ludCk7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludDtcblx0fSxcblxuXHRnZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9sYXN0UG9pbnQsIHRoaXMudG9vbC5fbGFzdFBvaW50KTtcblx0fSxcblxuXHRzZXRMYXN0UG9pbnQ6IGZ1bmN0aW9uKGxhc3RQb2ludCkge1xuXHRcdHRoaXMuX2xhc3RQb2ludCA9IGxhc3RQb2ludDtcblx0fSxcblxuXHRnZXREb3duUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaG9vc2VQb2ludCh0aGlzLl9kb3duUG9pbnQsIHRoaXMudG9vbC5fZG93blBvaW50KTtcblx0fSxcblxuXHRzZXREb3duUG9pbnQ6IGZ1bmN0aW9uKGRvd25Qb2ludCkge1xuXHRcdHRoaXMuX2Rvd25Qb2ludCA9IGRvd25Qb2ludDtcblx0fSxcblxuXHRnZXRNaWRkbGVQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9taWRkbGVQb2ludCAmJiB0aGlzLnRvb2wuX2xhc3RQb2ludCkge1xuXHRcdFx0cmV0dXJuIHRoaXMudG9vbC5fcG9pbnQuYWRkKHRoaXMudG9vbC5fbGFzdFBvaW50KS5kaXZpZGUoMik7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9taWRkbGVQb2ludDtcblx0fSxcblxuXHRzZXRNaWRkbGVQb2ludDogZnVuY3Rpb24obWlkZGxlUG9pbnQpIHtcblx0XHR0aGlzLl9taWRkbGVQb2ludCA9IG1pZGRsZVBvaW50O1xuXHR9LFxuXG5cdGdldERlbHRhOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2RlbHRhICYmIHRoaXMudG9vbC5fbGFzdFBvaW50XG5cdFx0XHRcdD8gdGhpcy50b29sLl9wb2ludC5zdWJ0cmFjdCh0aGlzLnRvb2wuX2xhc3RQb2ludClcblx0XHRcdFx0OiB0aGlzLl9kZWx0YTtcblx0fSxcblxuXHRzZXREZWx0YTogZnVuY3Rpb24oZGVsdGEpIHtcblx0XHR0aGlzLl9kZWx0YSA9IGRlbHRhO1xuXHR9LFxuXG5cdGdldENvdW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKVxuXHRcdFx0XHQ/IHRoaXMudG9vbC5fZG93bkNvdW50XG5cdFx0XHRcdDogdGhpcy50b29sLl9jb3VudDtcblx0fSxcblxuXHRzZXRDb3VudDogZnVuY3Rpb24oY291bnQpIHtcblx0XHR0aGlzLnRvb2xbL15tb3VzZShkb3dufHVwKSQvLnRlc3QodGhpcy50eXBlKSA/ICdkb3duQ291bnQnIDogJ2NvdW50J11cblx0XHRcdD0gY291bnQ7XG5cdH0sXG5cblx0Z2V0SXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9pdGVtKSB7XG5cdFx0XHR2YXIgcmVzdWx0ID0gdGhpcy50b29sLl9zY29wZS5wcm9qZWN0LmhpdFRlc3QodGhpcy5nZXRQb2ludCgpKTtcblx0XHRcdGlmIChyZXN1bHQpIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSByZXN1bHQuaXRlbSxcblx0XHRcdFx0XHRwYXJlbnQgPSBpdGVtLl9wYXJlbnQ7XG5cdFx0XHRcdHdoaWxlICgvXihHcm91cHxDb21wb3VuZFBhdGgpJC8udGVzdChwYXJlbnQuX2NsYXNzKSkge1xuXHRcdFx0XHRcdGl0ZW0gPSBwYXJlbnQ7XG5cdFx0XHRcdFx0cGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5faXRlbSA9IGl0ZW07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9pdGVtO1xuXHR9LFxuXG5cdHNldEl0ZW06IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR0aGlzLl9pdGVtID0gaXRlbTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICd7IHR5cGU6ICcgKyB0aGlzLnR5cGVcblx0XHRcdFx0KyAnLCBwb2ludDogJyArIHRoaXMuZ2V0UG9pbnQoKVxuXHRcdFx0XHQrICcsIGNvdW50OiAnICsgdGhpcy5nZXRDb3VudCgpXG5cdFx0XHRcdCsgJywgbW9kaWZpZXJzOiAnICsgdGhpcy5nZXRNb2RpZmllcnMoKVxuXHRcdFx0XHQrICcgfSc7XG5cdH1cbn0pO1xuXG52YXIgVG9vbCA9IFBhcGVyU2NvcGVJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1Rvb2wnLFxuXHRfbGlzdDogJ3Rvb2xzJyxcblx0X3JlZmVyZW5jZTogJ3Rvb2wnLFxuXHRfZXZlbnRzOiBbICdvbkFjdGl2YXRlJywgJ29uRGVhY3RpdmF0ZScsICdvbkVkaXRPcHRpb25zJyxcblx0XHRcdCdvbk1vdXNlRG93bicsICdvbk1vdXNlVXAnLCAnb25Nb3VzZURyYWcnLCAnb25Nb3VzZU1vdmUnLFxuXHRcdFx0J29uS2V5RG93bicsICdvbktleVVwJyBdLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRvb2wocHJvcHMpIHtcblx0XHRQYXBlclNjb3BlSXRlbS5jYWxsKHRoaXMpO1xuXHRcdHRoaXMuX2ZpcnN0TW92ZSA9IHRydWU7XG5cdFx0dGhpcy5fY291bnQgPSAwO1xuXHRcdHRoaXMuX2Rvd25Db3VudCA9IDA7XG5cdFx0dGhpcy5fc2V0KHByb3BzKTtcblx0fSxcblxuXHRnZXRNaW5EaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlO1xuXHR9LFxuXG5cdHNldE1pbkRpc3RhbmNlOiBmdW5jdGlvbihtaW5EaXN0YW5jZSkge1xuXHRcdHRoaXMuX21pbkRpc3RhbmNlID0gbWluRGlzdGFuY2U7XG5cdFx0aWYgKG1pbkRpc3RhbmNlICE9IG51bGwgJiYgdGhpcy5fbWF4RGlzdGFuY2UgIT0gbnVsbFxuXHRcdFx0XHQmJiBtaW5EaXN0YW5jZSA+IHRoaXMuX21heERpc3RhbmNlKSB7XG5cdFx0XHR0aGlzLl9tYXhEaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xuXHRcdH1cblx0fSxcblxuXHRnZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21heERpc3RhbmNlO1xuXHR9LFxuXG5cdHNldE1heERpc3RhbmNlOiBmdW5jdGlvbihtYXhEaXN0YW5jZSkge1xuXHRcdHRoaXMuX21heERpc3RhbmNlID0gbWF4RGlzdGFuY2U7XG5cdFx0aWYgKHRoaXMuX21pbkRpc3RhbmNlICE9IG51bGwgJiYgbWF4RGlzdGFuY2UgIT0gbnVsbFxuXHRcdFx0XHQmJiBtYXhEaXN0YW5jZSA8IHRoaXMuX21pbkRpc3RhbmNlKSB7XG5cdFx0XHR0aGlzLl9taW5EaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuXHRcdH1cblx0fSxcblxuXHRnZXRGaXhlZERpc3RhbmNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWluRGlzdGFuY2UgPT0gdGhpcy5fbWF4RGlzdGFuY2Vcblx0XHRcdD8gdGhpcy5fbWluRGlzdGFuY2UgOiBudWxsO1xuXHR9LFxuXG5cdHNldEZpeGVkRGlzdGFuY2U6IGZ1bmN0aW9uKGRpc3RhbmNlKSB7XG5cdFx0dGhpcy5fbWluRGlzdGFuY2UgPSB0aGlzLl9tYXhEaXN0YW5jZSA9IGRpc3RhbmNlO1xuXHR9LFxuXG5cdF91cGRhdGVFdmVudDogZnVuY3Rpb24odHlwZSwgcG9pbnQsIG1pbkRpc3RhbmNlLCBtYXhEaXN0YW5jZSwgc3RhcnQsXG5cdFx0XHRuZWVkc0NoYW5nZSwgbWF0Y2hNYXhEaXN0YW5jZSkge1xuXHRcdGlmICghc3RhcnQpIHtcblx0XHRcdGlmIChtaW5EaXN0YW5jZSAhPSBudWxsIHx8IG1heERpc3RhbmNlICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIG1pbkRpc3QgPSBtaW5EaXN0YW5jZSAhPSBudWxsID8gbWluRGlzdGFuY2UgOiAwLFxuXHRcdFx0XHRcdHZlY3RvciA9IHBvaW50LnN1YnRyYWN0KHRoaXMuX3BvaW50KSxcblx0XHRcdFx0XHRkaXN0YW5jZSA9IHZlY3Rvci5nZXRMZW5ndGgoKTtcblx0XHRcdFx0aWYgKGRpc3RhbmNlIDwgbWluRGlzdClcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlmIChtYXhEaXN0YW5jZSAhPSBudWxsICYmIG1heERpc3RhbmNlICE9IDApIHtcblx0XHRcdFx0XHRpZiAoZGlzdGFuY2UgPiBtYXhEaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0cG9pbnQgPSB0aGlzLl9wb2ludC5hZGQodmVjdG9yLm5vcm1hbGl6ZShtYXhEaXN0YW5jZSkpO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAobWF0Y2hNYXhEaXN0YW5jZSkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKG5lZWRzQ2hhbmdlICYmIHBvaW50LmVxdWFscyh0aGlzLl9wb2ludCkpXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0dGhpcy5fbGFzdFBvaW50ID0gc3RhcnQgJiYgdHlwZSA9PSAnbW91c2Vtb3ZlJyA/IHBvaW50IDogdGhpcy5fcG9pbnQ7XG5cdFx0dGhpcy5fcG9pbnQgPSBwb2ludDtcblx0XHRzd2l0Y2ggKHR5cGUpIHtcblx0XHRjYXNlICdtb3VzZWRvd24nOlxuXHRcdFx0dGhpcy5fbGFzdFBvaW50ID0gdGhpcy5fZG93blBvaW50O1xuXHRcdFx0dGhpcy5fZG93blBvaW50ID0gdGhpcy5fcG9pbnQ7XG5cdFx0XHR0aGlzLl9kb3duQ291bnQrKztcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0dGhpcy5fbGFzdFBvaW50ID0gdGhpcy5fZG93blBvaW50O1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdHRoaXMuX2NvdW50ID0gc3RhcnQgPyAwIDogdGhpcy5fY291bnQgKyAxO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdF9maXJlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIGV2ZW50KSB7XG5cdFx0dmFyIHNldHMgPSBwYXBlci5wcm9qZWN0Ll9yZW1vdmVTZXRzO1xuXHRcdGlmIChzZXRzKSB7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ21vdXNldXAnKVxuXHRcdFx0XHRzZXRzLm1vdXNlZHJhZyA9IG51bGw7XG5cdFx0XHR2YXIgc2V0ID0gc2V0c1t0eXBlXTtcblx0XHRcdGlmIChzZXQpIHtcblx0XHRcdFx0Zm9yICh2YXIgaWQgaW4gc2V0KSB7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSBzZXRbaWRdO1xuXHRcdFx0XHRcdGZvciAodmFyIGtleSBpbiBzZXRzKSB7XG5cdFx0XHRcdFx0XHR2YXIgb3RoZXIgPSBzZXRzW2tleV07XG5cdFx0XHRcdFx0XHRpZiAob3RoZXIgJiYgb3RoZXIgIT0gc2V0KVxuXHRcdFx0XHRcdFx0XHRkZWxldGUgb3RoZXJbaXRlbS5faWRdO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHNldHNbdHlwZV0gPSBudWxsO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5yZXNwb25kcyh0eXBlKVxuXHRcdFx0XHQmJiB0aGlzLmVtaXQodHlwZSwgbmV3IFRvb2xFdmVudCh0aGlzLCB0eXBlLCBldmVudCkpO1xuXHR9LFxuXG5cdF9oYW5kbGVFdmVudDogZnVuY3Rpb24odHlwZSwgcG9pbnQsIGV2ZW50KSB7XG5cdFx0cGFwZXIgPSB0aGlzLl9zY29wZTtcblx0XHR2YXIgY2FsbGVkID0gZmFsc2U7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCBudWxsLCBudWxsLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ21vdXNlZHJhZyc6XG5cdFx0XHR2YXIgbmVlZHNDaGFuZ2UgPSBmYWxzZSxcblx0XHRcdFx0bWF0Y2hNYXhEaXN0YW5jZSA9IGZhbHNlO1xuXHRcdFx0d2hpbGUgKHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCB0aGlzLm1pbkRpc3RhbmNlLFxuXHRcdFx0XHRcdHRoaXMubWF4RGlzdGFuY2UsIGZhbHNlLCBuZWVkc0NoYW5nZSwgbWF0Y2hNYXhEaXN0YW5jZSkpIHtcblx0XHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KSB8fCBjYWxsZWQ7XG5cdFx0XHRcdG5lZWRzQ2hhbmdlID0gdHJ1ZTtcblx0XHRcdFx0bWF0Y2hNYXhEaXN0YW5jZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdGlmICghcG9pbnQuZXF1YWxzKHRoaXMuX3BvaW50KVxuXHRcdFx0XHRcdCYmIHRoaXMuX3VwZGF0ZUV2ZW50KCdtb3VzZWRyYWcnLCBwb2ludCwgdGhpcy5taW5EaXN0YW5jZSxcblx0XHRcdFx0XHRcdFx0dGhpcy5tYXhEaXN0YW5jZSwgZmFsc2UsIGZhbHNlLCBmYWxzZSkpIHtcblx0XHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KCdtb3VzZWRyYWcnLCBldmVudCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgbnVsbCwgdGhpcy5tYXhEaXN0YW5jZSwgZmFsc2UsXG5cdFx0XHRcdFx0ZmFsc2UsIGZhbHNlKTtcblx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCh0eXBlLCBldmVudCkgfHwgY2FsbGVkO1xuXHRcdFx0dGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIG51bGwsIG51bGwsIHRydWUsIGZhbHNlLCBmYWxzZSk7XG5cdFx0XHR0aGlzLl9maXJzdE1vdmUgPSB0cnVlO1xuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbW91c2Vtb3ZlJzpcblx0XHRcdHdoaWxlICh0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgdGhpcy5taW5EaXN0YW5jZSxcblx0XHRcdFx0XHR0aGlzLm1heERpc3RhbmNlLCB0aGlzLl9maXJzdE1vdmUsIHRydWUsIGZhbHNlKSkge1xuXHRcdFx0XHRjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQodHlwZSwgZXZlbnQpIHx8IGNhbGxlZDtcblx0XHRcdFx0dGhpcy5fZmlyc3RNb3ZlID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0aWYgKGNhbGxlZClcblx0XHRcdGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdFx0cmV0dXJuIGNhbGxlZDtcblx0fVxuXG59KTtcblxudmFyIEh0dHAgPSB7XG5cdHJlcXVlc3Q6IGZ1bmN0aW9uKG1ldGhvZCwgdXJsLCBjYWxsYmFjaywgYXN5bmMpIHtcblx0XHRhc3luYyA9IChhc3luYyA9PT0gdW5kZWZpbmVkKSA/IHRydWUgOiBhc3luYztcblx0XHR2YXIgeGhyID0gbmV3ICh3aW5kb3cuQWN0aXZlWE9iamVjdCB8fCBYTUxIdHRwUmVxdWVzdCkoXG5cdFx0XHRcdFx0J01pY3Jvc29mdC5YTUxIVFRQJyk7XG5cdFx0eGhyLm9wZW4obWV0aG9kLnRvVXBwZXJDYXNlKCksIHVybCwgYXN5bmMpO1xuXHRcdGlmICgnb3ZlcnJpZGVNaW1lVHlwZScgaW4geGhyKVxuXHRcdFx0eGhyLm92ZXJyaWRlTWltZVR5cGUoJ3RleHQvcGxhaW4nKTtcblx0XHR4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoeGhyLnJlYWR5U3RhdGUgPT09IDQpIHtcblx0XHRcdFx0dmFyIHN0YXR1cyA9IHhoci5zdGF0dXM7XG5cdFx0XHRcdGlmIChzdGF0dXMgPT09IDAgfHwgc3RhdHVzID09PSAyMDApIHtcblx0XHRcdFx0XHRjYWxsYmFjay5jYWxsKHhociwgeGhyLnJlc3BvbnNlVGV4dCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgbG9hZCAnICsgdXJsICsgJyAoRXJyb3IgJ1xuXHRcdFx0XHRcdFx0XHQrIHN0YXR1cyArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHRcdHJldHVybiB4aHIuc2VuZChudWxsKTtcblx0fVxufTtcblxudmFyIENhbnZhc1Byb3ZpZGVyID0ge1xuXHRjYW52YXNlczogW10sXG5cblx0Z2V0Q2FudmFzOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dmFyIGNhbnZhcyxcblx0XHRcdGNsZWFyID0gdHJ1ZTtcblx0XHRpZiAodHlwZW9mIHdpZHRoID09PSAnb2JqZWN0Jykge1xuXHRcdFx0aGVpZ2h0ID0gd2lkdGguaGVpZ2h0O1xuXHRcdFx0d2lkdGggPSB3aWR0aC53aWR0aDtcblx0XHR9XG5cdFx0aWYgKHRoaXMuY2FudmFzZXMubGVuZ3RoKSB7XG5cdFx0XHRjYW52YXMgPSB0aGlzLmNhbnZhc2VzLnBvcCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcblx0XHR9XG5cdFx0dmFyIGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGlmIChjYW52YXMud2lkdGggPT09IHdpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT09IGhlaWdodCkge1xuXHRcdFx0aWYgKGNsZWFyKVxuXHRcdFx0XHRjdHguY2xlYXJSZWN0KDAsIDAsIHdpZHRoICsgMSwgaGVpZ2h0ICsgMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNhbnZhcy53aWR0aCA9IHdpZHRoO1xuXHRcdFx0Y2FudmFzLmhlaWdodCA9IGhlaWdodDtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRyZXR1cm4gY2FudmFzO1xuXHR9LFxuXG5cdGdldENvbnRleHQ6IGZ1bmN0aW9uKHdpZHRoLCBoZWlnaHQpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRDYW52YXMod2lkdGgsIGhlaWdodCkuZ2V0Q29udGV4dCgnMmQnKTtcblx0fSxcblxuXHRyZWxlYXNlOiBmdW5jdGlvbihvYmopIHtcblx0XHR2YXIgY2FudmFzID0gb2JqLmNhbnZhcyA/IG9iai5jYW52YXMgOiBvYmo7XG5cdFx0Y2FudmFzLmdldENvbnRleHQoJzJkJykucmVzdG9yZSgpO1xuXHRcdHRoaXMuY2FudmFzZXMucHVzaChjYW52YXMpO1xuXHR9XG59O1xuXG52YXIgQmxlbmRNb2RlID0gbmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgbWluID0gTWF0aC5taW4sXG5cdFx0bWF4ID0gTWF0aC5tYXgsXG5cdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0c3IsIHNnLCBzYiwgc2EsXG5cdFx0YnIsIGJnLCBiYiwgYmEsXG5cdFx0ZHIsIGRnLCBkYjtcblxuXHRmdW5jdGlvbiBnZXRMdW0ociwgZywgYikge1xuXHRcdHJldHVybiAwLjI5ODkgKiByICsgMC41ODcgKiBnICsgMC4xMTQgKiBiO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0THVtKHIsIGcsIGIsIGwpIHtcblx0XHR2YXIgZCA9IGwgLSBnZXRMdW0ociwgZywgYik7XG5cdFx0ZHIgPSByICsgZDtcblx0XHRkZyA9IGcgKyBkO1xuXHRcdGRiID0gYiArIGQ7XG5cdFx0dmFyIGwgPSBnZXRMdW0oZHIsIGRnLCBkYiksXG5cdFx0XHRtbiA9IG1pbihkciwgZGcsIGRiKSxcblx0XHRcdG14ID0gbWF4KGRyLCBkZywgZGIpO1xuXHRcdGlmIChtbiA8IDApIHtcblx0XHRcdHZhciBsbW4gPSBsIC0gbW47XG5cdFx0XHRkciA9IGwgKyAoZHIgLSBsKSAqIGwgLyBsbW47XG5cdFx0XHRkZyA9IGwgKyAoZGcgLSBsKSAqIGwgLyBsbW47XG5cdFx0XHRkYiA9IGwgKyAoZGIgLSBsKSAqIGwgLyBsbW47XG5cdFx0fVxuXHRcdGlmIChteCA+IDI1NSkge1xuXHRcdFx0dmFyIGxuID0gMjU1IC0gbCxcblx0XHRcdFx0bXhsID0gbXggLSBsO1xuXHRcdFx0ZHIgPSBsICsgKGRyIC0gbCkgKiBsbiAvIG14bDtcblx0XHRcdGRnID0gbCArIChkZyAtIGwpICogbG4gLyBteGw7XG5cdFx0XHRkYiA9IGwgKyAoZGIgLSBsKSAqIGxuIC8gbXhsO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGdldFNhdChyLCBnLCBiKSB7XG5cdFx0cmV0dXJuIG1heChyLCBnLCBiKSAtIG1pbihyLCBnLCBiKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldFNhdChyLCBnLCBiLCBzKSB7XG5cdFx0dmFyIGNvbCA9IFtyLCBnLCBiXSxcblx0XHRcdG14ID0gbWF4KHIsIGcsIGIpLFxuXHRcdFx0bW4gPSBtaW4ociwgZywgYiksXG5cdFx0XHRtZDtcblx0XHRtbiA9IG1uID09PSByID8gMCA6IG1uID09PSBnID8gMSA6IDI7XG5cdFx0bXggPSBteCA9PT0gciA/IDAgOiBteCA9PT0gZyA/IDEgOiAyO1xuXHRcdG1kID0gbWluKG1uLCBteCkgPT09IDAgPyBtYXgobW4sIG14KSA9PT0gMSA/IDIgOiAxIDogMDtcblx0XHRpZiAoY29sW214XSA+IGNvbFttbl0pIHtcblx0XHRcdGNvbFttZF0gPSAoY29sW21kXSAtIGNvbFttbl0pICogcyAvIChjb2xbbXhdIC0gY29sW21uXSk7XG5cdFx0XHRjb2xbbXhdID0gcztcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y29sW21kXSA9IGNvbFtteF0gPSAwO1xuXHRcdH1cblx0XHRjb2xbbW5dID0gMDtcblx0XHRkciA9IGNvbFswXTtcblx0XHRkZyA9IGNvbFsxXTtcblx0XHRkYiA9IGNvbFsyXTtcblx0fVxuXG5cdHZhciBtb2RlcyA9IHtcblx0XHRtdWx0aXBseTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyICogc3IgLyAyNTU7XG5cdFx0XHRkZyA9IGJnICogc2cgLyAyNTU7XG5cdFx0XHRkYiA9IGJiICogc2IgLyAyNTU7XG5cdFx0fSxcblxuXHRcdHNjcmVlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyICsgc3IgLSAoYnIgKiBzciAvIDI1NSk7XG5cdFx0XHRkZyA9IGJnICsgc2cgLSAoYmcgKiBzZyAvIDI1NSk7XG5cdFx0XHRkYiA9IGJiICsgc2IgLSAoYmIgKiBzYiAvIDI1NSk7XG5cdFx0fSxcblxuXHRcdG92ZXJsYXk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA8IDEyOCA/IDIgKiBiciAqIHNyIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBicikgKiAoMjU1IC0gc3IpIC8gMjU1O1xuXHRcdFx0ZGcgPSBiZyA8IDEyOCA/IDIgKiBiZyAqIHNnIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBiZykgKiAoMjU1IC0gc2cpIC8gMjU1O1xuXHRcdFx0ZGIgPSBiYiA8IDEyOCA/IDIgKiBiYiAqIHNiIC8gMjU1IDogMjU1IC0gMiAqICgyNTUgLSBiYikgKiAoMjU1IC0gc2IpIC8gMjU1O1xuXHRcdH0sXG5cblx0XHQnc29mdC1saWdodCc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHQgPSBzciAqIGJyIC8gMjU1O1xuXHRcdFx0ZHIgPSB0ICsgYnIgKiAoMjU1IC0gKDI1NSAtIGJyKSAqICgyNTUgLSBzcikgLyAyNTUgLSB0KSAvIDI1NTtcblx0XHRcdHQgPSBzZyAqIGJnIC8gMjU1O1xuXHRcdFx0ZGcgPSB0ICsgYmcgKiAoMjU1IC0gKDI1NSAtIGJnKSAqICgyNTUgLSBzZykgLyAyNTUgLSB0KSAvIDI1NTtcblx0XHRcdHQgPSBzYiAqIGJiIC8gMjU1O1xuXHRcdFx0ZGIgPSB0ICsgYmIgKiAoMjU1IC0gKDI1NSAtIGJiKSAqICgyNTUgLSBzYikgLyAyNTUgLSB0KSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0J2hhcmQtbGlnaHQnOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gc3IgPCAxMjggPyAyICogc3IgKiBiciAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gc3IpICogKDI1NSAtIGJyKSAvIDI1NTtcblx0XHRcdGRnID0gc2cgPCAxMjggPyAyICogc2cgKiBiZyAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gc2cpICogKDI1NSAtIGJnKSAvIDI1NTtcblx0XHRcdGRiID0gc2IgPCAxMjggPyAyICogc2IgKiBiYiAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gc2IpICogKDI1NSAtIGJiKSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0J2NvbG9yLWRvZGdlJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyID09PSAwID8gMCA6IHNyID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiciAvICgyNTUgLSBzcikpO1xuXHRcdFx0ZGcgPSBiZyA9PT0gMCA/IDAgOiBzZyA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYmcgLyAoMjU1IC0gc2cpKTtcblx0XHRcdGRiID0gYmIgPT09IDAgPyAwIDogc2IgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJiIC8gKDI1NSAtIHNiKSk7XG5cdFx0fSxcblxuXHRcdCdjb2xvci1idXJuJzogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyID09PSAyNTUgPyAyNTUgOiBzciA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJyKSAqIDI1NSAvIHNyKTtcblx0XHRcdGRnID0gYmcgPT09IDI1NSA/IDI1NSA6IHNnID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYmcpICogMjU1IC8gc2cpO1xuXHRcdFx0ZGIgPSBiYiA9PT0gMjU1ID8gMjU1IDogc2IgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBiYikgKiAyNTUgLyBzYik7XG5cdFx0fSxcblxuXHRcdGRhcmtlbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyIDwgc3IgPyBiciA6IHNyO1xuXHRcdFx0ZGcgPSBiZyA8IHNnID8gYmcgOiBzZztcblx0XHRcdGRiID0gYmIgPCBzYiA/IGJiIDogc2I7XG5cdFx0fSxcblxuXHRcdGxpZ2h0ZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA+IHNyID8gYnIgOiBzcjtcblx0XHRcdGRnID0gYmcgPiBzZyA/IGJnIDogc2c7XG5cdFx0XHRkYiA9IGJiID4gc2IgPyBiYiA6IHNiO1xuXHRcdH0sXG5cblx0XHRkaWZmZXJlbmNlOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgLSBzcjtcblx0XHRcdGlmIChkciA8IDApXG5cdFx0XHRcdGRyID0gLWRyO1xuXHRcdFx0ZGcgPSBiZyAtIHNnO1xuXHRcdFx0aWYgKGRnIDwgMClcblx0XHRcdFx0ZGcgPSAtZGc7XG5cdFx0XHRkYiA9IGJiIC0gc2I7XG5cdFx0XHRpZiAoZGIgPCAwKVxuXHRcdFx0XHRkYiA9IC1kYjtcblx0XHR9LFxuXG5cdFx0ZXhjbHVzaW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgKyBzciAqICgyNTUgLSBiciAtIGJyKSAvIDI1NTtcblx0XHRcdGRnID0gYmcgKyBzZyAqICgyNTUgLSBiZyAtIGJnKSAvIDI1NTtcblx0XHRcdGRiID0gYmIgKyBzYiAqICgyNTUgLSBiYiAtIGJiKSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0aHVlOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldFNhdChzciwgc2csIHNiLCBnZXRTYXQoYnIsIGJnLCBiYikpO1xuXHRcdFx0c2V0THVtKGRyLCBkZywgZGIsIGdldEx1bShiciwgYmcsIGJiKSk7XG5cdFx0fSxcblxuXHRcdHNhdHVyYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0U2F0KGJyLCBiZywgYmIsIGdldFNhdChzciwgc2csIHNiKSk7XG5cdFx0XHRzZXRMdW0oZHIsIGRnLCBkYiwgZ2V0THVtKGJyLCBiZywgYmIpKTtcblx0XHR9LFxuXG5cdFx0bHVtaW5vc2l0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRMdW0oYnIsIGJnLCBiYiwgZ2V0THVtKHNyLCBzZywgc2IpKTtcblx0XHR9LFxuXG5cdFx0Y29sb3I6IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0THVtKHNyLCBzZywgc2IsIGdldEx1bShiciwgYmcsIGJiKSk7XG5cdFx0fSxcblxuXHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IG1pbihiciArIHNyLCAyNTUpO1xuXHRcdFx0ZGcgPSBtaW4oYmcgKyBzZywgMjU1KTtcblx0XHRcdGRiID0gbWluKGJiICsgc2IsIDI1NSk7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gbWF4KGJyIC0gc3IsIDApO1xuXHRcdFx0ZGcgPSBtYXgoYmcgLSBzZywgMCk7XG5cdFx0XHRkYiA9IG1heChiYiAtIHNiLCAwKTtcblx0XHR9LFxuXG5cdFx0YXZlcmFnZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IChiciArIHNyKSAvIDI7XG5cdFx0XHRkZyA9IChiZyArIHNnKSAvIDI7XG5cdFx0XHRkYiA9IChiYiArIHNiKSAvIDI7XG5cdFx0fSxcblxuXHRcdG5lZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gMjU1IC0gYWJzKDI1NSAtIHNyIC0gYnIpO1xuXHRcdFx0ZGcgPSAyNTUgLSBhYnMoMjU1IC0gc2cgLSBiZyk7XG5cdFx0XHRkYiA9IDI1NSAtIGFicygyNTUgLSBzYiAtIGJiKTtcblx0XHR9XG5cdH07XG5cblx0dmFyIG5hdGl2ZU1vZGVzID0gdGhpcy5uYXRpdmVNb2RlcyA9IEJhc2UuZWFjaChbXG5cdFx0J3NvdXJjZS1vdmVyJywgJ3NvdXJjZS1pbicsICdzb3VyY2Utb3V0JywgJ3NvdXJjZS1hdG9wJyxcblx0XHQnZGVzdGluYXRpb24tb3ZlcicsICdkZXN0aW5hdGlvbi1pbicsICdkZXN0aW5hdGlvbi1vdXQnLFxuXHRcdCdkZXN0aW5hdGlvbi1hdG9wJywgJ2xpZ2h0ZXInLCAnZGFya2VyJywgJ2NvcHknLCAneG9yJ1xuXHRdLCBmdW5jdGlvbihtb2RlKSB7XG5cdFx0dGhpc1ttb2RlXSA9IHRydWU7XG5cdH0sIHt9KTtcblxuXHR2YXIgY3R4ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dCgxLCAxKTtcblx0QmFzZS5lYWNoKG1vZGVzLCBmdW5jdGlvbihmdW5jLCBtb2RlKSB7XG5cdFx0dmFyIGRhcmtlbiA9IG1vZGUgPT09ICdkYXJrZW4nLFxuXHRcdFx0b2sgPSBmYWxzZTtcblx0XHRjdHguc2F2ZSgpO1xuXHRcdHRyeSB7XG5cdFx0XHRjdHguZmlsbFN0eWxlID0gZGFya2VuID8gJyMzMDAnIDogJyNhMDAnO1xuXHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG1vZGU7XG5cdFx0XHRpZiAoY3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9PT0gbW9kZSkge1xuXHRcdFx0XHRjdHguZmlsbFN0eWxlID0gZGFya2VuID8gJyNhMDAnIDogJyMzMDAnO1xuXHRcdFx0XHRjdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG5cdFx0XHRcdG9rID0gY3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhWzBdICE9PSBkYXJrZW4gPyAxNzAgOiA1MTtcblx0XHRcdH1cblx0XHR9IGNhdGNoIChlKSB7fVxuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0bmF0aXZlTW9kZXNbbW9kZV0gPSBvaztcblx0fSk7XG5cdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblxuXHR0aGlzLnByb2Nlc3MgPSBmdW5jdGlvbihtb2RlLCBzcmNDb250ZXh0LCBkc3RDb250ZXh0LCBhbHBoYSwgb2Zmc2V0KSB7XG5cdFx0dmFyIHNyY0NhbnZhcyA9IHNyY0NvbnRleHQuY2FudmFzLFxuXHRcdFx0bm9ybWFsID0gbW9kZSA9PT0gJ25vcm1hbCc7XG5cdFx0aWYgKG5vcm1hbCB8fCBuYXRpdmVNb2Rlc1ttb2RlXSkge1xuXHRcdFx0ZHN0Q29udGV4dC5zYXZlKCk7XG5cdFx0XHRkc3RDb250ZXh0LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcblx0XHRcdGRzdENvbnRleHQuZ2xvYmFsQWxwaGEgPSBhbHBoYTtcblx0XHRcdGlmICghbm9ybWFsKVxuXHRcdFx0XHRkc3RDb250ZXh0Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IG1vZGU7XG5cdFx0XHRkc3RDb250ZXh0LmRyYXdJbWFnZShzcmNDYW52YXMsIG9mZnNldC54LCBvZmZzZXQueSk7XG5cdFx0XHRkc3RDb250ZXh0LnJlc3RvcmUoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHByb2Nlc3MgPSBtb2Rlc1ttb2RlXTtcblx0XHRcdGlmICghcHJvY2Vzcylcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIGRzdERhdGEgPSBkc3RDb250ZXh0LmdldEltYWdlRGF0YShvZmZzZXQueCwgb2Zmc2V0LnksXG5cdFx0XHRcdFx0c3JjQ2FudmFzLndpZHRoLCBzcmNDYW52YXMuaGVpZ2h0KSxcblx0XHRcdFx0ZHN0ID0gZHN0RGF0YS5kYXRhLFxuXHRcdFx0XHRzcmMgPSBzcmNDb250ZXh0LmdldEltYWdlRGF0YSgwLCAwLFxuXHRcdFx0XHRcdHNyY0NhbnZhcy53aWR0aCwgc3JjQ2FudmFzLmhlaWdodCkuZGF0YTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gZHN0Lmxlbmd0aDsgaSA8IGw7IGkgKz0gNCkge1xuXHRcdFx0XHRzciA9IHNyY1tpXTtcblx0XHRcdFx0YnIgPSBkc3RbaV07XG5cdFx0XHRcdHNnID0gc3JjW2kgKyAxXTtcblx0XHRcdFx0YmcgPSBkc3RbaSArIDFdO1xuXHRcdFx0XHRzYiA9IHNyY1tpICsgMl07XG5cdFx0XHRcdGJiID0gZHN0W2kgKyAyXTtcblx0XHRcdFx0c2EgPSBzcmNbaSArIDNdO1xuXHRcdFx0XHRiYSA9IGRzdFtpICsgM107XG5cdFx0XHRcdHByb2Nlc3MoKTtcblx0XHRcdFx0dmFyIGExID0gc2EgKiBhbHBoYSAvIDI1NSxcblx0XHRcdFx0XHRhMiA9IDEgLSBhMTtcblx0XHRcdFx0ZHN0W2ldID0gYTEgKiBkciArIGEyICogYnI7XG5cdFx0XHRcdGRzdFtpICsgMV0gPSBhMSAqIGRnICsgYTIgKiBiZztcblx0XHRcdFx0ZHN0W2kgKyAyXSA9IGExICogZGIgKyBhMiAqIGJiO1xuXHRcdFx0XHRkc3RbaSArIDNdID0gc2EgKiBhbHBoYSArIGEyICogYmE7XG5cdFx0XHR9XG5cdFx0XHRkc3RDb250ZXh0LnB1dEltYWdlRGF0YShkc3REYXRhLCBvZmZzZXQueCwgb2Zmc2V0LnkpO1xuXHRcdH1cblx0fTtcbn07XG5cbnZhciBTVkdTdHlsZXMgPSBCYXNlLmVhY2goe1xuXHRmaWxsQ29sb3I6IFsnZmlsbCcsICdjb2xvciddLFxuXHRzdHJva2VDb2xvcjogWydzdHJva2UnLCAnY29sb3InXSxcblx0c3Ryb2tlV2lkdGg6IFsnc3Ryb2tlLXdpZHRoJywgJ251bWJlciddLFxuXHRzdHJva2VDYXA6IFsnc3Ryb2tlLWxpbmVjYXAnLCAnc3RyaW5nJ10sXG5cdHN0cm9rZUpvaW46IFsnc3Ryb2tlLWxpbmVqb2luJywgJ3N0cmluZyddLFxuXHRzdHJva2VTY2FsaW5nOiBbJ3ZlY3Rvci1lZmZlY3QnLCAnbG9va3VwJywge1xuXHRcdHRydWU6ICdub25lJyxcblx0XHRmYWxzZTogJ25vbi1zY2FsaW5nLXN0cm9rZSdcblx0fSwgZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRyZXR1cm4gIXZhbHVlXG5cdFx0XHRcdCYmIChpdGVtIGluc3RhbmNlb2YgUGF0aEl0ZW1cblx0XHRcdFx0XHR8fCBpdGVtIGluc3RhbmNlb2YgU2hhcGVcblx0XHRcdFx0XHR8fCBpdGVtIGluc3RhbmNlb2YgVGV4dEl0ZW0pO1xuXHR9XSxcblx0bWl0ZXJMaW1pdDogWydzdHJva2UtbWl0ZXJsaW1pdCcsICdudW1iZXInXSxcblx0ZGFzaEFycmF5OiBbJ3N0cm9rZS1kYXNoYXJyYXknLCAnYXJyYXknXSxcblx0ZGFzaE9mZnNldDogWydzdHJva2UtZGFzaG9mZnNldCcsICdudW1iZXInXSxcblx0Zm9udEZhbWlseTogWydmb250LWZhbWlseScsICdzdHJpbmcnXSxcblx0Zm9udFdlaWdodDogWydmb250LXdlaWdodCcsICdzdHJpbmcnXSxcblx0Zm9udFNpemU6IFsnZm9udC1zaXplJywgJ251bWJlciddLFxuXHRqdXN0aWZpY2F0aW9uOiBbJ3RleHQtYW5jaG9yJywgJ2xvb2t1cCcsIHtcblx0XHRsZWZ0OiAnc3RhcnQnLFxuXHRcdGNlbnRlcjogJ21pZGRsZScsXG5cdFx0cmlnaHQ6ICdlbmQnXG5cdH1dLFxuXHRvcGFjaXR5OiBbJ29wYWNpdHknLCAnbnVtYmVyJ10sXG5cdGJsZW5kTW9kZTogWydtaXgtYmxlbmQtbW9kZScsICdzdHJpbmcnXVxufSwgZnVuY3Rpb24oZW50cnksIGtleSkge1xuXHR2YXIgcGFydCA9IEJhc2UuY2FwaXRhbGl6ZShrZXkpLFxuXHRcdGxvb2t1cCA9IGVudHJ5WzJdO1xuXHR0aGlzW2tleV0gPSB7XG5cdFx0dHlwZTogZW50cnlbMV0sXG5cdFx0cHJvcGVydHk6IGtleSxcblx0XHRhdHRyaWJ1dGU6IGVudHJ5WzBdLFxuXHRcdHRvU1ZHOiBsb29rdXAsXG5cdFx0ZnJvbVNWRzogbG9va3VwICYmIEJhc2UuZWFjaChsb29rdXAsIGZ1bmN0aW9uKHZhbHVlLCBuYW1lKSB7XG5cdFx0XHR0aGlzW3ZhbHVlXSA9IG5hbWU7XG5cdFx0fSwge30pLFxuXHRcdGV4cG9ydEZpbHRlcjogZW50cnlbM10sXG5cdFx0Z2V0OiAnZ2V0JyArIHBhcnQsXG5cdFx0c2V0OiAnc2V0JyArIHBhcnRcblx0fTtcbn0sIHt9KTtcblxudmFyIFNWR05hbWVzcGFjZXMgPSB7XG5cdGhyZWY6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJyxcblx0eGxpbms6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3htbG5zJ1xufTtcblxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgZm9ybWF0dGVyO1xuXG5cdGZ1bmN0aW9uIHNldEF0dHJpYnV0ZXMobm9kZSwgYXR0cnMpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gYXR0cnMpIHtcblx0XHRcdHZhciB2YWwgPSBhdHRyc1trZXldLFxuXHRcdFx0XHRuYW1lc3BhY2UgPSBTVkdOYW1lc3BhY2VzW2tleV07XG5cdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ251bWJlcicpXG5cdFx0XHRcdHZhbCA9IGZvcm1hdHRlci5udW1iZXIodmFsKTtcblx0XHRcdGlmIChuYW1lc3BhY2UpIHtcblx0XHRcdFx0bm9kZS5zZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIGtleSwgdmFsKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKGtleSwgdmFsKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBjcmVhdGVFbGVtZW50KHRhZywgYXR0cnMpIHtcblx0XHRyZXR1cm4gc2V0QXR0cmlidXRlcyhcblx0XHRcdGRvY3VtZW50LmNyZWF0ZUVsZW1lbnROUygnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLCB0YWcpLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRUcmFuc2Zvcm0obWF0cml4LCBjb29yZGluYXRlcywgY2VudGVyKSB7XG5cdFx0dmFyIGF0dHJzID0gbmV3IEJhc2UoKSxcblx0XHRcdHRyYW5zID0gbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cdFx0aWYgKGNvb3JkaW5hdGVzKSB7XG5cdFx0XHRtYXRyaXggPSBtYXRyaXguc2hpZnRsZXNzKCk7XG5cdFx0XHR2YXIgcG9pbnQgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0odHJhbnMpO1xuXHRcdFx0YXR0cnNbY2VudGVyID8gJ2N4JyA6ICd4J10gPSBwb2ludC54O1xuXHRcdFx0YXR0cnNbY2VudGVyID8gJ2N5JyA6ICd5J10gPSBwb2ludC55O1xuXHRcdFx0dHJhbnMgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAoIW1hdHJpeC5pc0lkZW50aXR5KCkpIHtcblx0XHRcdHZhciBkZWNvbXBvc2VkID0gbWF0cml4LmRlY29tcG9zZSgpO1xuXHRcdFx0aWYgKGRlY29tcG9zZWQgJiYgIWRlY29tcG9zZWQuc2hlYXJpbmcpIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gW10sXG5cdFx0XHRcdFx0YW5nbGUgPSBkZWNvbXBvc2VkLnJvdGF0aW9uLFxuXHRcdFx0XHRcdHNjYWxlID0gZGVjb21wb3NlZC5zY2FsaW5nO1xuXHRcdFx0XHRpZiAodHJhbnMgJiYgIXRyYW5zLmlzWmVybygpKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3RyYW5zbGF0ZSgnICsgZm9ybWF0dGVyLnBvaW50KHRyYW5zKSArICcpJyk7XG5cdFx0XHRcdGlmICghTnVtZXJpY2FsLmlzWmVybyhzY2FsZS54IC0gMSlcblx0XHRcdFx0XHRcdHx8ICFOdW1lcmljYWwuaXNaZXJvKHNjYWxlLnkgLSAxKSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdzY2FsZSgnICsgZm9ybWF0dGVyLnBvaW50KHNjYWxlKSArJyknKTtcblx0XHRcdFx0aWYgKGFuZ2xlKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goJ3JvdGF0ZSgnICsgZm9ybWF0dGVyLm51bWJlcihhbmdsZSkgKyAnKScpO1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSBwYXJ0cy5qb2luKCcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycy50cmFuc2Zvcm0gPSAnbWF0cml4KCcgKyBtYXRyaXguZ2V0VmFsdWVzKCkuam9pbignLCcpICsgJyknO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gYXR0cnM7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRHcm91cChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCksXG5cdFx0XHRjaGlsZHJlbiA9IGl0ZW0uX2NoaWxkcmVuO1xuXHRcdHZhciBub2RlID0gY3JlYXRlRWxlbWVudCgnZycsIGF0dHJzKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gZXhwb3J0U1ZHKGNoaWxkLCBvcHRpb25zKTtcblx0XHRcdGlmIChjaGlsZE5vZGUpIHtcblx0XHRcdFx0aWYgKGNoaWxkLmlzQ2xpcE1hc2soKSkge1xuXHRcdFx0XHRcdHZhciBjbGlwID0gY3JlYXRlRWxlbWVudCgnY2xpcFBhdGgnKTtcblx0XHRcdFx0XHRjbGlwLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG5cdFx0XHRcdFx0c2V0RGVmaW5pdGlvbihjaGlsZCwgY2xpcCwgJ2NsaXAnKTtcblx0XHRcdFx0XHRzZXRBdHRyaWJ1dGVzKG5vZGUsIHtcblx0XHRcdFx0XHRcdCdjbGlwLXBhdGgnOiAndXJsKCMnICsgY2xpcC5pZCArICcpJ1xuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGROb2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFJhc3RlcihpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSksXG5cdFx0XHRzaXplID0gaXRlbS5nZXRTaXplKCksXG5cdFx0XHRpbWFnZSA9IGl0ZW0uZ2V0SW1hZ2UoKTtcblx0XHRhdHRycy54IC09IHNpemUud2lkdGggLyAyO1xuXHRcdGF0dHJzLnkgLT0gc2l6ZS5oZWlnaHQgLyAyO1xuXHRcdGF0dHJzLndpZHRoID0gc2l6ZS53aWR0aDtcblx0XHRhdHRycy5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRhdHRycy5ocmVmID0gb3B0aW9ucy5lbWJlZEltYWdlcyA9PT0gZmFsc2UgJiYgaW1hZ2UgJiYgaW1hZ2Uuc3JjXG5cdFx0XHRcdHx8IGl0ZW0udG9EYXRhVVJMKCk7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ2ltYWdlJywgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0UGF0aChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIG1hdGNoU2hhcGVzID0gb3B0aW9ucy5tYXRjaFNoYXBlcztcblx0XHRpZiAobWF0Y2hTaGFwZXMpIHtcblx0XHRcdHZhciBzaGFwZSA9IGl0ZW0udG9TaGFwZShmYWxzZSk7XG5cdFx0XHRpZiAoc2hhcGUpXG5cdFx0XHRcdHJldHVybiBleHBvcnRTaGFwZShzaGFwZSwgb3B0aW9ucyk7XG5cdFx0fVxuXHRcdHZhciBzZWdtZW50cyA9IGl0ZW0uX3NlZ21lbnRzLFxuXHRcdFx0dHlwZSxcblx0XHRcdGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCk7XG5cdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGlmIChtYXRjaFNoYXBlcyAmJiAhaXRlbS5oYXNIYW5kbGVzKCkpIHtcblx0XHRcdGlmIChzZWdtZW50cy5sZW5ndGggPj0gMykge1xuXHRcdFx0XHR0eXBlID0gaXRlbS5fY2xvc2VkID8gJ3BvbHlnb24nIDogJ3BvbHlsaW5lJztcblx0XHRcdFx0dmFyIHBhcnRzID0gW107XG5cdFx0XHRcdGZvcih2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cGFydHMucHVzaChmb3JtYXR0ZXIucG9pbnQoc2VnbWVudHNbaV0uX3BvaW50KSk7XG5cdFx0XHRcdGF0dHJzLnBvaW50cyA9IHBhcnRzLmpvaW4oJyAnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSAnbGluZSc7XG5cdFx0XHRcdHZhciBmaXJzdCA9IHNlZ21lbnRzWzBdLl9wb2ludCxcblx0XHRcdFx0XHRsYXN0ID0gc2VnbWVudHNbc2VnbWVudHMubGVuZ3RoIC0gMV0uX3BvaW50O1xuXHRcdFx0XHRhdHRycy5zZXQoe1xuXHRcdFx0XHRcdHgxOiBmaXJzdC54LFxuXHRcdFx0XHRcdHkxOiBmaXJzdC55LFxuXHRcdFx0XHRcdHgyOiBsYXN0LngsXG5cdFx0XHRcdFx0eTI6IGxhc3QueVxuXHRcdFx0XHR9KTtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0dHlwZSA9ICdwYXRoJztcblx0XHRcdGF0dHJzLmQgPSBpdGVtLmdldFBhdGhEYXRhKG51bGwsIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQodHlwZSwgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0U2hhcGUoaXRlbSkge1xuXHRcdHZhciB0eXBlID0gaXRlbS5fdHlwZSxcblx0XHRcdHJhZGl1cyA9IGl0ZW0uX3JhZGl1cyxcblx0XHRcdGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCwgdHJ1ZSwgdHlwZSAhPT0gJ3JlY3RhbmdsZScpO1xuXHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0dHlwZSA9ICdyZWN0Jztcblx0XHRcdHZhciBzaXplID0gaXRlbS5fc2l6ZSxcblx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdGF0dHJzLnggLT0gd2lkdGggLyAyO1xuXHRcdFx0YXR0cnMueSAtPSBoZWlnaHQgLyAyO1xuXHRcdFx0YXR0cnMud2lkdGggPSB3aWR0aDtcblx0XHRcdGF0dHJzLmhlaWdodCA9IGhlaWdodDtcblx0XHRcdGlmIChyYWRpdXMuaXNaZXJvKCkpXG5cdFx0XHRcdHJhZGl1cyA9IG51bGw7XG5cdFx0fVxuXHRcdGlmIChyYWRpdXMpIHtcblx0XHRcdGlmICh0eXBlID09PSAnY2lyY2xlJykge1xuXHRcdFx0XHRhdHRycy5yID0gcmFkaXVzO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMucnggPSByYWRpdXMud2lkdGg7XG5cdFx0XHRcdGF0dHJzLnJ5ID0gcmFkaXVzLmhlaWdodDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQodHlwZSwgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0Q29tcG91bmRQYXRoKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4KTtcblx0XHR2YXIgZGF0YSA9IGl0ZW0uZ2V0UGF0aERhdGEobnVsbCwgb3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdGlmIChkYXRhKVxuXHRcdFx0YXR0cnMuZCA9IGRhdGE7XG5cdFx0cmV0dXJuIGNyZWF0ZUVsZW1lbnQoJ3BhdGgnLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRQbGFjZWRTeW1ib2woaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUpLFxuXHRcdFx0c3ltYm9sID0gaXRlbS5nZXRTeW1ib2woKSxcblx0XHRcdHN5bWJvbE5vZGUgPSBnZXREZWZpbml0aW9uKHN5bWJvbCwgJ3N5bWJvbCcpLFxuXHRcdFx0ZGVmaW5pdGlvbiA9IHN5bWJvbC5nZXREZWZpbml0aW9uKCksXG5cdFx0XHRib3VuZHMgPSBkZWZpbml0aW9uLmdldEJvdW5kcygpO1xuXHRcdGlmICghc3ltYm9sTm9kZSkge1xuXHRcdFx0c3ltYm9sTm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ3N5bWJvbCcsIHtcblx0XHRcdFx0dmlld0JveDogZm9ybWF0dGVyLnJlY3RhbmdsZShib3VuZHMpXG5cdFx0XHR9KTtcblx0XHRcdHN5bWJvbE5vZGUuYXBwZW5kQ2hpbGQoZXhwb3J0U1ZHKGRlZmluaXRpb24sIG9wdGlvbnMpKTtcblx0XHRcdHNldERlZmluaXRpb24oc3ltYm9sLCBzeW1ib2xOb2RlLCAnc3ltYm9sJyk7XG5cdFx0fVxuXHRcdGF0dHJzLmhyZWYgPSAnIycgKyBzeW1ib2xOb2RlLmlkO1xuXHRcdGF0dHJzLnggKz0gYm91bmRzLng7XG5cdFx0YXR0cnMueSArPSBib3VuZHMueTtcblx0XHRhdHRycy53aWR0aCA9IGZvcm1hdHRlci5udW1iZXIoYm91bmRzLndpZHRoKTtcblx0XHRhdHRycy5oZWlnaHQgPSBmb3JtYXR0ZXIubnVtYmVyKGJvdW5kcy5oZWlnaHQpO1xuXHRcdGF0dHJzLm92ZXJmbG93ID0gJ3Zpc2libGUnO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KCd1c2UnLCBhdHRycyk7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRHcmFkaWVudChjb2xvcikge1xuXHRcdHZhciBncmFkaWVudE5vZGUgPSBnZXREZWZpbml0aW9uKGNvbG9yLCAnY29sb3InKTtcblx0XHRpZiAoIWdyYWRpZW50Tm9kZSkge1xuXHRcdFx0dmFyIGdyYWRpZW50ID0gY29sb3IuZ2V0R3JhZGllbnQoKSxcblx0XHRcdFx0cmFkaWFsID0gZ3JhZGllbnQuX3JhZGlhbCxcblx0XHRcdFx0b3JpZ2luID0gY29sb3IuZ2V0T3JpZ2luKCkudHJhbnNmb3JtKCksXG5cdFx0XHRcdGRlc3RpbmF0aW9uID0gY29sb3IuZ2V0RGVzdGluYXRpb24oKS50cmFuc2Zvcm0oKSxcblx0XHRcdFx0YXR0cnM7XG5cdFx0XHRpZiAocmFkaWFsKSB7XG5cdFx0XHRcdGF0dHJzID0ge1xuXHRcdFx0XHRcdGN4OiBvcmlnaW4ueCxcblx0XHRcdFx0XHRjeTogb3JpZ2luLnksXG5cdFx0XHRcdFx0cjogb3JpZ2luLmdldERpc3RhbmNlKGRlc3RpbmF0aW9uKVxuXHRcdFx0XHR9O1xuXHRcdFx0XHR2YXIgaGlnaGxpZ2h0ID0gY29sb3IuZ2V0SGlnaGxpZ2h0KCk7XG5cdFx0XHRcdGlmIChoaWdobGlnaHQpIHtcblx0XHRcdFx0XHRoaWdobGlnaHQgPSBoaWdobGlnaHQudHJhbnNmb3JtKCk7XG5cdFx0XHRcdFx0YXR0cnMuZnggPSBoaWdobGlnaHQueDtcblx0XHRcdFx0XHRhdHRycy5meSA9IGhpZ2hsaWdodC55O1xuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhdHRycyA9IHtcblx0XHRcdFx0XHR4MTogb3JpZ2luLngsXG5cdFx0XHRcdFx0eTE6IG9yaWdpbi55LFxuXHRcdFx0XHRcdHgyOiBkZXN0aW5hdGlvbi54LFxuXHRcdFx0XHRcdHkyOiBkZXN0aW5hdGlvbi55XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdFx0XHRhdHRycy5ncmFkaWVudFVuaXRzID0gJ3VzZXJTcGFjZU9uVXNlJztcblx0XHRcdGdyYWRpZW50Tm9kZSA9IGNyZWF0ZUVsZW1lbnQoXG5cdFx0XHRcdFx0KHJhZGlhbCA/ICdyYWRpYWwnIDogJ2xpbmVhcicpICsgJ0dyYWRpZW50JywgYXR0cnMpO1xuXHRcdFx0dmFyIHN0b3BzID0gZ3JhZGllbnQuX3N0b3BzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzdG9wcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHN0b3AgPSBzdG9wc1tpXSxcblx0XHRcdFx0XHRzdG9wQ29sb3IgPSBzdG9wLl9jb2xvcixcblx0XHRcdFx0XHRhbHBoYSA9IHN0b3BDb2xvci5nZXRBbHBoYSgpO1xuXHRcdFx0XHRhdHRycyA9IHtcblx0XHRcdFx0XHRvZmZzZXQ6IHN0b3AuX3JhbXBQb2ludCxcblx0XHRcdFx0XHQnc3RvcC1jb2xvcic6IHN0b3BDb2xvci50b0NTUyh0cnVlKVxuXHRcdFx0XHR9O1xuXHRcdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRcdGF0dHJzWydzdG9wLW9wYWNpdHknXSA9IGFscGhhO1xuXHRcdFx0XHRncmFkaWVudE5vZGUuYXBwZW5kQ2hpbGQoY3JlYXRlRWxlbWVudCgnc3RvcCcsIGF0dHJzKSk7XG5cdFx0XHR9XG5cdFx0XHRzZXREZWZpbml0aW9uKGNvbG9yLCBncmFkaWVudE5vZGUsICdjb2xvcicpO1xuXHRcdH1cblx0XHRyZXR1cm4gJ3VybCgjJyArIGdyYWRpZW50Tm9kZS5pZCArICcpJztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFRleHQoaXRlbSkge1xuXHRcdHZhciBub2RlID0gY3JlYXRlRWxlbWVudCgndGV4dCcsIGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUpKTtcblx0XHRub2RlLnRleHRDb250ZW50ID0gaXRlbS5fY29udGVudDtcblx0XHRyZXR1cm4gbm9kZTtcblx0fVxuXG5cdHZhciBleHBvcnRlcnMgPSB7XG5cdFx0R3JvdXA6IGV4cG9ydEdyb3VwLFxuXHRcdExheWVyOiBleHBvcnRHcm91cCxcblx0XHRSYXN0ZXI6IGV4cG9ydFJhc3Rlcixcblx0XHRQYXRoOiBleHBvcnRQYXRoLFxuXHRcdFNoYXBlOiBleHBvcnRTaGFwZSxcblx0XHRDb21wb3VuZFBhdGg6IGV4cG9ydENvbXBvdW5kUGF0aCxcblx0XHRQbGFjZWRTeW1ib2w6IGV4cG9ydFBsYWNlZFN5bWJvbCxcblx0XHRQb2ludFRleHQ6IGV4cG9ydFRleHRcblx0fTtcblxuXHRmdW5jdGlvbiBhcHBseVN0eWxlKGl0ZW0sIG5vZGUsIGlzUm9vdCkge1xuXHRcdHZhciBhdHRycyA9IHt9LFxuXHRcdFx0cGFyZW50ID0gIWlzUm9vdCAmJiBpdGVtLmdldFBhcmVudCgpO1xuXG5cdFx0aWYgKGl0ZW0uX25hbWUgIT0gbnVsbClcblx0XHRcdGF0dHJzLmlkID0gaXRlbS5fbmFtZTtcblxuXHRcdEJhc2UuZWFjaChTVkdTdHlsZXMsIGZ1bmN0aW9uKGVudHJ5KSB7XG5cdFx0XHR2YXIgZ2V0ID0gZW50cnkuZ2V0LFxuXHRcdFx0XHR0eXBlID0gZW50cnkudHlwZSxcblx0XHRcdFx0dmFsdWUgPSBpdGVtW2dldF0oKTtcblx0XHRcdGlmIChlbnRyeS5leHBvcnRGaWx0ZXJcblx0XHRcdFx0XHQ/IGVudHJ5LmV4cG9ydEZpbHRlcihpdGVtLCB2YWx1ZSlcblx0XHRcdFx0XHQ6ICFwYXJlbnQgfHwgIUJhc2UuZXF1YWxzKHBhcmVudFtnZXRdKCksIHZhbHVlKSkge1xuXHRcdFx0XHRpZiAodHlwZSA9PT0gJ2NvbG9yJyAmJiB2YWx1ZSAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dmFyIGFscGhhID0gdmFsdWUuZ2V0QWxwaGEoKTtcblx0XHRcdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRcdFx0YXR0cnNbZW50cnkuYXR0cmlidXRlICsgJy1vcGFjaXR5J10gPSBhbHBoYTtcblx0XHRcdFx0fVxuXHRcdFx0XHRhdHRyc1tlbnRyeS5hdHRyaWJ1dGVdID0gdmFsdWUgPT0gbnVsbFxuXHRcdFx0XHRcdD8gJ25vbmUnXG5cdFx0XHRcdFx0OiB0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0PyBmb3JtYXR0ZXIubnVtYmVyKHZhbHVlKVxuXHRcdFx0XHRcdFx0OiB0eXBlID09PSAnY29sb3InXG5cdFx0XHRcdFx0XHRcdD8gdmFsdWUuZ3JhZGllbnRcblx0XHRcdFx0XHRcdFx0XHQ/IGV4cG9ydEdyYWRpZW50KHZhbHVlLCBpdGVtKVxuXHRcdFx0XHRcdFx0XHRcdDogdmFsdWUudG9DU1ModHJ1ZSlcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnYXJyYXknXG5cdFx0XHRcdFx0XHRcdFx0PyB2YWx1ZS5qb2luKCcsJylcblx0XHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdsb29rdXAnXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGVudHJ5LnRvU1ZHW3ZhbHVlXVxuXHRcdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGlmIChhdHRycy5vcGFjaXR5ID09PSAxKVxuXHRcdFx0ZGVsZXRlIGF0dHJzLm9wYWNpdHk7XG5cblx0XHRpZiAoIWl0ZW0uX3Zpc2libGUpXG5cdFx0XHRhdHRycy52aXNpYmlsaXR5ID0gJ2hpZGRlbic7XG5cblx0XHRyZXR1cm4gc2V0QXR0cmlidXRlcyhub2RlLCBhdHRycyk7XG5cdH1cblxuXHR2YXIgZGVmaW5pdGlvbnM7XG5cdGZ1bmN0aW9uIGdldERlZmluaXRpb24oaXRlbSwgdHlwZSkge1xuXHRcdGlmICghZGVmaW5pdGlvbnMpXG5cdFx0XHRkZWZpbml0aW9ucyA9IHsgaWRzOiB7fSwgc3Znczoge30gfTtcblx0XHRyZXR1cm4gaXRlbSAmJiBkZWZpbml0aW9ucy5zdmdzW3R5cGUgKyAnLScgKyBpdGVtLl9pZF07XG5cdH1cblxuXHRmdW5jdGlvbiBzZXREZWZpbml0aW9uKGl0ZW0sIG5vZGUsIHR5cGUpIHtcblx0XHRpZiAoIWRlZmluaXRpb25zKVxuXHRcdFx0Z2V0RGVmaW5pdGlvbigpO1xuXHRcdHZhciBpZCA9IGRlZmluaXRpb25zLmlkc1t0eXBlXSA9IChkZWZpbml0aW9ucy5pZHNbdHlwZV0gfHwgMCkgKyAxO1xuXHRcdG5vZGUuaWQgPSB0eXBlICsgJy0nICsgaWQ7XG5cdFx0ZGVmaW5pdGlvbnMuc3Znc1t0eXBlICsgJy0nICsgaXRlbS5faWRdID0gbm9kZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydERlZmluaXRpb25zKG5vZGUsIG9wdGlvbnMpIHtcblx0XHR2YXIgc3ZnID0gbm9kZSxcblx0XHRcdGRlZnMgPSBudWxsO1xuXHRcdGlmIChkZWZpbml0aW9ucykge1xuXHRcdFx0c3ZnID0gbm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSAnc3ZnJyAmJiBub2RlO1xuXHRcdFx0Zm9yICh2YXIgaSBpbiBkZWZpbml0aW9ucy5zdmdzKSB7XG5cdFx0XHRcdGlmICghZGVmcykge1xuXHRcdFx0XHRcdGlmICghc3ZnKSB7XG5cdFx0XHRcdFx0XHRzdmcgPSBjcmVhdGVFbGVtZW50KCdzdmcnKTtcblx0XHRcdFx0XHRcdHN2Zy5hcHBlbmRDaGlsZChub2RlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0ZGVmcyA9IHN2Zy5pbnNlcnRCZWZvcmUoY3JlYXRlRWxlbWVudCgnZGVmcycpLFxuXHRcdFx0XHRcdFx0XHRzdmcuZmlyc3RDaGlsZCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0ZGVmcy5hcHBlbmRDaGlsZChkZWZpbml0aW9ucy5zdmdzW2ldKTtcblx0XHRcdH1cblx0XHRcdGRlZmluaXRpb25zID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIG9wdGlvbnMuYXNTdHJpbmdcblx0XHRcdFx0PyBuZXcgWE1MU2VyaWFsaXplcigpLnNlcmlhbGl6ZVRvU3RyaW5nKHN2Zylcblx0XHRcdFx0OiBzdmc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRTVkcoaXRlbSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0dmFyIGV4cG9ydGVyID0gZXhwb3J0ZXJzW2l0ZW0uX2NsYXNzXSxcblx0XHRcdG5vZGUgPSBleHBvcnRlciAmJiBleHBvcnRlcihpdGVtLCBvcHRpb25zKTtcblx0XHRpZiAobm9kZSkge1xuXHRcdFx0dmFyIG9uRXhwb3J0ID0gb3B0aW9ucy5vbkV4cG9ydDtcblx0XHRcdGlmIChvbkV4cG9ydClcblx0XHRcdFx0bm9kZSA9IG9uRXhwb3J0KGl0ZW0sIG5vZGUsIG9wdGlvbnMpIHx8IG5vZGU7XG5cdFx0XHR2YXIgZGF0YSA9IEpTT04uc3RyaW5naWZ5KGl0ZW0uX2RhdGEpO1xuXHRcdFx0aWYgKGRhdGEgJiYgZGF0YSAhPT0gJ3t9JyAmJiBkYXRhICE9PSAnbnVsbCcpXG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWRhdGEnLCBkYXRhKTtcblx0XHR9XG5cdFx0cmV0dXJuIG5vZGUgJiYgYXBwbHlTdHlsZShpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0T3B0aW9ucyhvcHRpb25zKSB7XG5cdFx0aWYgKCFvcHRpb25zKVxuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdGZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIob3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGV4cG9ydFNWRzogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHNldE9wdGlvbnMob3B0aW9ucyk7XG5cdFx0XHRyZXR1cm4gZXhwb3J0RGVmaW5pdGlvbnMoZXhwb3J0U1ZHKHRoaXMsIG9wdGlvbnMsIHRydWUpLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRleHBvcnRTVkc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0dmFyIGxheWVycyA9IHRoaXMubGF5ZXJzLFxuXHRcdFx0XHR2aWV3ID0gdGhpcy5nZXRWaWV3KCksXG5cdFx0XHRcdHNpemUgPSB2aWV3LmdldFZpZXdTaXplKCksXG5cdFx0XHRcdG5vZGUgPSBjcmVhdGVFbGVtZW50KCdzdmcnLCB7XG5cdFx0XHRcdFx0eDogMCxcblx0XHRcdFx0XHR5OiAwLFxuXHRcdFx0XHRcdHdpZHRoOiBzaXplLndpZHRoLFxuXHRcdFx0XHRcdGhlaWdodDogc2l6ZS5oZWlnaHQsXG5cdFx0XHRcdFx0dmVyc2lvbjogJzEuMScsXG5cdFx0XHRcdFx0eG1sbnM6ICdodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2ZycsXG5cdFx0XHRcdFx0J3htbG5zOnhsaW5rJzogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnXG5cdFx0XHRcdH0pLFxuXHRcdFx0XHRwYXJlbnQgPSBub2RlLFxuXHRcdFx0XHRtYXRyaXggPSB2aWV3Ll9tYXRyaXg7XG5cdFx0XHRpZiAoIW1hdHJpeC5pc0lkZW50aXR5KCkpXG5cdFx0XHRcdHBhcmVudCA9IG5vZGUuYXBwZW5kQ2hpbGQoXG5cdFx0XHRcdFx0XHRjcmVhdGVFbGVtZW50KCdnJywgZ2V0VHJhbnNmb3JtKG1hdHJpeCkpKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGF5ZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0cGFyZW50LmFwcGVuZENoaWxkKGV4cG9ydFNWRyhsYXllcnNbaV0sIG9wdGlvbnMsIHRydWUpKTtcblx0XHRcdHJldHVybiBleHBvcnREZWZpbml0aW9ucyhub2RlLCBvcHRpb25zKTtcblx0XHR9XG5cdH0pO1xufTtcblxubmV3IGZ1bmN0aW9uKCkge1xuXG5cdGZ1bmN0aW9uIGdldFZhbHVlKG5vZGUsIG5hbWUsIGlzU3RyaW5nLCBhbGxvd051bGwpIHtcblx0XHR2YXIgbmFtZXNwYWNlID0gU1ZHTmFtZXNwYWNlc1tuYW1lXSxcblx0XHRcdHZhbHVlID0gbmFtZXNwYWNlXG5cdFx0XHRcdD8gbm9kZS5nZXRBdHRyaWJ1dGVOUyhuYW1lc3BhY2UsIG5hbWUpXG5cdFx0XHRcdDogbm9kZS5nZXRBdHRyaWJ1dGUobmFtZSk7XG5cdFx0aWYgKHZhbHVlID09PSAnbnVsbCcpXG5cdFx0XHR2YWx1ZSA9IG51bGw7XG5cdFx0cmV0dXJuIHZhbHVlID09IG51bGxcblx0XHRcdFx0PyBhbGxvd051bGxcblx0XHRcdFx0XHQ/IG51bGxcblx0XHRcdFx0XHQ6IGlzU3RyaW5nXG5cdFx0XHRcdFx0XHQ/ICcnXG5cdFx0XHRcdFx0XHQ6IDBcblx0XHRcdFx0OiBpc1N0cmluZ1xuXHRcdFx0XHRcdD8gdmFsdWVcblx0XHRcdFx0XHQ6IHBhcnNlRmxvYXQodmFsdWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0UG9pbnQobm9kZSwgeCwgeSwgYWxsb3dOdWxsKSB7XG5cdFx0eCA9IGdldFZhbHVlKG5vZGUsIHgsIGZhbHNlLCBhbGxvd051bGwpO1xuXHRcdHkgPSBnZXRWYWx1ZShub2RlLCB5LCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHRyZXR1cm4gYWxsb3dOdWxsICYmICh4ID09IG51bGwgfHwgeSA9PSBudWxsKSA/IG51bGxcblx0XHRcdFx0OiBuZXcgUG9pbnQoeCwgeSk7XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTaXplKG5vZGUsIHcsIGgsIGFsbG93TnVsbCkge1xuXHRcdHcgPSBnZXRWYWx1ZShub2RlLCB3LCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHRoID0gZ2V0VmFsdWUobm9kZSwgaCwgZmFsc2UsIGFsbG93TnVsbCk7XG5cdFx0cmV0dXJuIGFsbG93TnVsbCAmJiAodyA9PSBudWxsIHx8IGggPT0gbnVsbCkgPyBudWxsXG5cdFx0XHRcdDogbmV3IFNpemUodywgaCk7XG5cdH1cblxuXHRmdW5jdGlvbiBjb252ZXJ0VmFsdWUodmFsdWUsIHR5cGUsIGxvb2t1cCkge1xuXHRcdHJldHVybiB2YWx1ZSA9PT0gJ25vbmUnXG5cdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHQ6IHR5cGUgPT09ICdudW1iZXInXG5cdFx0XHRcdFx0PyBwYXJzZUZsb2F0KHZhbHVlKVxuXHRcdFx0XHRcdDogdHlwZSA9PT0gJ2FycmF5J1xuXHRcdFx0XHRcdFx0PyB2YWx1ZSA/IHZhbHVlLnNwbGl0KC9bXFxzLF0rL2cpLm1hcChwYXJzZUZsb2F0KSA6IFtdXG5cdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdjb2xvcidcblx0XHRcdFx0XHRcdFx0PyBnZXREZWZpbml0aW9uKHZhbHVlKSB8fCB2YWx1ZVxuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdsb29rdXAnXG5cdFx0XHRcdFx0XHRcdFx0PyBsb29rdXBbdmFsdWVdXG5cdFx0XHRcdFx0XHRcdFx0OiB2YWx1ZTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcyxcblx0XHRcdGlzQ2xpcCA9IHR5cGUgPT09ICdjbGlwcGF0aCcsXG5cdFx0XHRpdGVtID0gbmV3IEdyb3VwKCksXG5cdFx0XHRwcm9qZWN0ID0gaXRlbS5fcHJvamVjdCxcblx0XHRcdGN1cnJlbnRTdHlsZSA9IHByb2plY3QuX2N1cnJlbnRTdHlsZSxcblx0XHRcdGNoaWxkcmVuID0gW107XG5cdFx0aWYgKCFpc0NsaXApIHtcblx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KTtcblx0XHRcdHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGl0ZW0uX3N0eWxlLmNsb25lKCk7XG5cdFx0fVxuXHRcdGlmIChpc1Jvb3QpIHtcblx0XHRcdHZhciBkZWZzID0gbm9kZS5xdWVyeVNlbGVjdG9yQWxsKCdkZWZzJyk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGRlZnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdGltcG9ydFNWRyhkZWZzW2ldLCBvcHRpb25zLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgY2hpbGROb2RlID0gbm9kZXNbaV0sXG5cdFx0XHRcdGNoaWxkO1xuXHRcdFx0aWYgKGNoaWxkTm9kZS5ub2RlVHlwZSA9PT0gMVxuXHRcdFx0XHRcdCYmIGNoaWxkTm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpICE9PSAnZGVmcydcblx0XHRcdFx0XHQmJiAoY2hpbGQgPSBpbXBvcnRTVkcoY2hpbGROb2RlLCBvcHRpb25zLCBmYWxzZSkpXG5cdFx0XHRcdFx0JiYgIShjaGlsZCBpbnN0YW5jZW9mIFN5bWJvbCkpXG5cdFx0XHRcdGNoaWxkcmVuLnB1c2goY2hpbGQpO1xuXHRcdH1cblx0XHRpdGVtLmFkZENoaWxkcmVuKGNoaWxkcmVuKTtcblx0XHRpZiAoaXNDbGlwKVxuXHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLnJlZHVjZSgpLCBub2RlLCBpc1Jvb3QpO1xuXHRcdHByb2plY3QuX2N1cnJlbnRTdHlsZSA9IGN1cnJlbnRTdHlsZTtcblx0XHRpZiAoaXNDbGlwIHx8IHR5cGUgPT09ICdkZWZzJykge1xuXHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdGl0ZW0gPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFBvbHkobm9kZSwgdHlwZSkge1xuXHRcdHZhciBjb29yZHMgPSBub2RlLmdldEF0dHJpYnV0ZSgncG9pbnRzJykubWF0Y2goXG5cdFx0XHRcdFx0L1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpLFxuXHRcdFx0cG9pbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjb29yZHMubGVuZ3RoOyBpIDwgbDsgaSArPSAyKVxuXHRcdFx0cG9pbnRzLnB1c2gobmV3IFBvaW50KFxuXHRcdFx0XHRcdHBhcnNlRmxvYXQoY29vcmRzW2ldKSxcblx0XHRcdFx0XHRwYXJzZUZsb2F0KGNvb3Jkc1tpICsgMV0pKSk7XG5cdFx0dmFyIHBhdGggPSBuZXcgUGF0aChwb2ludHMpO1xuXHRcdGlmICh0eXBlID09PSAncG9seWdvbicpXG5cdFx0XHRwYXRoLmNsb3NlUGF0aCgpO1xuXHRcdHJldHVybiBwYXRoO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0UGF0aChub2RlKSB7XG5cdFx0dmFyIGRhdGEgPSBub2RlLmdldEF0dHJpYnV0ZSgnZCcpLFxuXHRcdFx0cGFyYW0gPSB7IHBhdGhEYXRhOiBkYXRhIH07XG5cdFx0cmV0dXJuIChkYXRhLm1hdGNoKC9tL2dpKSB8fCBbXSkubGVuZ3RoID4gMSB8fCAvelxcUysvaS50ZXN0KGRhdGEpXG5cdFx0XHRcdD8gbmV3IENvbXBvdW5kUGF0aChwYXJhbSlcblx0XHRcdFx0OiBuZXcgUGF0aChwYXJhbSk7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRHcmFkaWVudChub2RlLCB0eXBlKSB7XG5cdFx0dmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcblx0XHRcdGlzUmFkaWFsID0gdHlwZSA9PT0gJ3JhZGlhbGdyYWRpZW50Jyxcblx0XHRcdGdyYWRpZW50O1xuXHRcdGlmIChpZCkge1xuXHRcdFx0Z3JhZGllbnQgPSBkZWZpbml0aW9uc1tpZF0uZ2V0R3JhZGllbnQoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzLFxuXHRcdFx0XHRzdG9wcyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSlcblx0XHRcdFx0XHRzdG9wcy5wdXNoKGFwcGx5QXR0cmlidXRlcyhuZXcgR3JhZGllbnRTdG9wKCksIGNoaWxkKSk7XG5cdFx0XHR9XG5cdFx0XHRncmFkaWVudCA9IG5ldyBHcmFkaWVudChzdG9wcywgaXNSYWRpYWwpO1xuXHRcdH1cblx0XHR2YXIgb3JpZ2luLCBkZXN0aW5hdGlvbiwgaGlnaGxpZ2h0O1xuXHRcdGlmIChpc1JhZGlhbCkge1xuXHRcdFx0b3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5Jyk7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IG9yaWdpbi5hZGQoZ2V0VmFsdWUobm9kZSwgJ3InKSwgMCk7XG5cdFx0XHRoaWdobGlnaHQgPSBnZXRQb2ludChub2RlLCAnZngnLCAnZnknLCB0cnVlKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0b3JpZ2luID0gZ2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJyk7XG5cdFx0XHRkZXN0aW5hdGlvbiA9IGdldFBvaW50KG5vZGUsICd4MicsICd5MicpO1xuXHRcdH1cblx0XHRhcHBseUF0dHJpYnV0ZXMoXG5cdFx0XHRuZXcgQ29sb3IoZ3JhZGllbnQsIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodCksIG5vZGUpO1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0dmFyIGltcG9ydGVycyA9IHtcblx0XHQnI2RvY3VtZW50JzogZnVuY3Rpb24gKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdFx0dmFyIG5vZGVzID0gbm9kZS5jaGlsZE5vZGVzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBub2Rlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gbm9kZXNbaV07XG5cdFx0XHRcdGlmIChjaGlsZC5ub2RlVHlwZSA9PT0gMSkge1xuXHRcdFx0XHRcdHZhciBuZXh0ID0gY2hpbGQubmV4dFNpYmxpbmc7XG5cdFx0XHRcdFx0ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdFx0dmFyIGl0ZW0gPSBpbXBvcnRTVkcoY2hpbGQsIG9wdGlvbnMsIGlzUm9vdCk7XG5cdFx0XHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0XHRcdG5vZGUuaW5zZXJ0QmVmb3JlKGNoaWxkLCBuZXh0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0bm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblx0XHRnOiBpbXBvcnRHcm91cCxcblx0XHRzdmc6IGltcG9ydEdyb3VwLFxuXHRcdGNsaXBwYXRoOiBpbXBvcnRHcm91cCxcblx0XHRwb2x5Z29uOiBpbXBvcnRQb2x5LFxuXHRcdHBvbHlsaW5lOiBpbXBvcnRQb2x5LFxuXHRcdHBhdGg6IGltcG9ydFBhdGgsXG5cdFx0bGluZWFyZ3JhZGllbnQ6IGltcG9ydEdyYWRpZW50LFxuXHRcdHJhZGlhbGdyYWRpZW50OiBpbXBvcnRHcmFkaWVudCxcblxuXHRcdGltYWdlOiBmdW5jdGlvbiAobm9kZSkge1xuXHRcdFx0dmFyIHJhc3RlciA9IG5ldyBSYXN0ZXIoZ2V0VmFsdWUobm9kZSwgJ2hyZWYnLCB0cnVlKSk7XG5cdFx0XHRyYXN0ZXIub24oJ2xvYWQnLCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIHNpemUgPSBnZXRTaXplKG5vZGUsICd3aWR0aCcsICdoZWlnaHQnKTtcblx0XHRcdFx0dGhpcy5zZXRTaXplKHNpemUpO1xuXHRcdFx0XHR2YXIgY2VudGVyID0gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChcblx0XHRcdFx0XHRcdGdldFBvaW50KG5vZGUsICd4JywgJ3knKS5hZGQoc2l6ZS5kaXZpZGUoMikpKTtcblx0XHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHJhc3Rlcjtcblx0XHR9LFxuXG5cdFx0c3ltYm9sOiBmdW5jdGlvbihub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHRcdHJldHVybiBuZXcgU3ltYm9sKGltcG9ydEdyb3VwKG5vZGUsIHR5cGUsIG9wdGlvbnMsIGlzUm9vdCksIHRydWUpO1xuXHRcdH0sXG5cblx0XHRkZWZzOiBpbXBvcnRHcm91cCxcblxuXHRcdHVzZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIGlkID0gKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkgfHwgJycpLnN1YnN0cmluZygxKSxcblx0XHRcdFx0ZGVmaW5pdGlvbiA9IGRlZmluaXRpb25zW2lkXSxcblx0XHRcdFx0cG9pbnQgPSBnZXRQb2ludChub2RlLCAneCcsICd5Jyk7XG5cdFx0XHRyZXR1cm4gZGVmaW5pdGlvblxuXHRcdFx0XHRcdD8gZGVmaW5pdGlvbiBpbnN0YW5jZW9mIFN5bWJvbFxuXHRcdFx0XHRcdFx0PyBkZWZpbml0aW9uLnBsYWNlKHBvaW50KVxuXHRcdFx0XHRcdFx0OiBkZWZpbml0aW9uLmNsb25lKCkudHJhbnNsYXRlKHBvaW50KVxuXHRcdFx0XHRcdDogbnVsbDtcblx0XHR9LFxuXG5cdFx0Y2lyY2xlOiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlLkNpcmNsZShnZXRQb2ludChub2RlLCAnY3gnLCAnY3knKSxcblx0XHRcdFx0XHRnZXRWYWx1ZShub2RlLCAncicpKTtcblx0XHR9LFxuXG5cdFx0ZWxsaXBzZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5FbGxpcHNlKHtcblx0XHRcdFx0Y2VudGVyOiBnZXRQb2ludChub2RlLCAnY3gnLCAnY3knKSxcblx0XHRcdFx0cmFkaXVzOiBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpXG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0cmVjdDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIHBvaW50ID0gZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpLFxuXHRcdFx0XHRzaXplID0gZ2V0U2l6ZShub2RlLCAnd2lkdGgnLCAnaGVpZ2h0JyksXG5cdFx0XHRcdHJhZGl1cyA9IGdldFNpemUobm9kZSwgJ3J4JywgJ3J5Jyk7XG5cdFx0XHRyZXR1cm4gbmV3IFNoYXBlLlJlY3RhbmdsZShuZXcgUmVjdGFuZ2xlKHBvaW50LCBzaXplKSwgcmFkaXVzKTtcblx0XHR9LFxuXG5cdFx0bGluZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBQYXRoLkxpbmUoZ2V0UG9pbnQobm9kZSwgJ3gxJywgJ3kxJyksXG5cdFx0XHRcdFx0Z2V0UG9pbnQobm9kZSwgJ3gyJywgJ3kyJykpO1xuXHRcdH0sXG5cblx0XHR0ZXh0OiBmdW5jdGlvbihub2RlKSB7XG5cdFx0XHR2YXIgdGV4dCA9IG5ldyBQb2ludFRleHQoZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpXG5cdFx0XHRcdFx0LmFkZChnZXRQb2ludChub2RlLCAnZHgnLCAnZHknKSkpO1xuXHRcdFx0dGV4dC5zZXRDb250ZW50KG5vZGUudGV4dENvbnRlbnQudHJpbSgpIHx8ICcnKTtcblx0XHRcdHJldHVybiB0ZXh0O1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBhcHBseVRyYW5zZm9ybShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSkge1xuXHRcdHZhciB0cmFuc2Zvcm1zID0gKG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpIHx8ICcnKS5zcGxpdCgvXFwpXFxzKi9nKSxcblx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRyYW5zZm9ybXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgdHJhbnNmb3JtID0gdHJhbnNmb3Jtc1tpXTtcblx0XHRcdGlmICghdHJhbnNmb3JtKVxuXHRcdFx0XHRicmVhaztcblx0XHRcdHZhciBwYXJ0cyA9IHRyYW5zZm9ybS5zcGxpdCgvXFwoXFxzKi8pLFxuXHRcdFx0XHRjb21tYW5kID0gcGFydHNbMF0sXG5cdFx0XHRcdHYgPSBwYXJ0c1sxXS5zcGxpdCgvW1xccyxdKy9nKTtcblx0XHRcdGZvciAodmFyIGogPSAwLCBtID0gdi5sZW5ndGg7IGogPCBtOyBqKyspXG5cdFx0XHRcdHZbal0gPSBwYXJzZUZsb2F0KHZbal0pO1xuXHRcdFx0c3dpdGNoIChjb21tYW5kKSB7XG5cdFx0XHRjYXNlICdtYXRyaXgnOlxuXHRcdFx0XHRtYXRyaXguY29uY2F0ZW5hdGUoXG5cdFx0XHRcdFx0XHRuZXcgTWF0cml4KHZbMF0sIHZbMV0sIHZbMl0sIHZbM10sIHZbNF0sIHZbNV0pKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdyb3RhdGUnOlxuXHRcdFx0XHRtYXRyaXgucm90YXRlKHZbMF0sIHZbMV0sIHZbMl0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3RyYW5zbGF0ZSc6XG5cdFx0XHRcdG1hdHJpeC50cmFuc2xhdGUodlswXSwgdlsxXSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2NhbGUnOlxuXHRcdFx0XHRtYXRyaXguc2NhbGUodik7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2tld1gnOlxuXHRcdFx0XHRtYXRyaXguc2tldyh2WzBdLCAwKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdza2V3WSc6XG5cdFx0XHRcdG1hdHJpeC5za2V3KDAsIHZbMF0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0aXRlbS50cmFuc2Zvcm0obWF0cml4KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGFwcGx5T3BhY2l0eShpdGVtLCB2YWx1ZSwgbmFtZSkge1xuXHRcdHZhciBjb2xvciA9IGl0ZW1bbmFtZSA9PT0gJ2ZpbGwtb3BhY2l0eScgPyAnZ2V0RmlsbENvbG9yJ1xuXHRcdFx0XHQ6ICdnZXRTdHJva2VDb2xvciddKCk7XG5cdFx0aWYgKGNvbG9yKVxuXHRcdFx0Y29sb3Iuc2V0QWxwaGEocGFyc2VGbG9hdCh2YWx1ZSkpO1xuXHR9XG5cblx0dmFyIGF0dHJpYnV0ZXMgPSBCYXNlLnNldChCYXNlLmVhY2goU1ZHU3R5bGVzLCBmdW5jdGlvbihlbnRyeSkge1xuXHRcdHRoaXNbZW50cnkuYXR0cmlidXRlXSA9IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpdGVtW2VudHJ5LnNldF0oY29udmVydFZhbHVlKHZhbHVlLCBlbnRyeS50eXBlLCBlbnRyeS5mcm9tU1ZHKSk7XG5cdFx0XHRpZiAoZW50cnkudHlwZSA9PT0gJ2NvbG9yJyAmJiBpdGVtIGluc3RhbmNlb2YgU2hhcGUpIHtcblx0XHRcdFx0dmFyIGNvbG9yID0gaXRlbVtlbnRyeS5nZXRdKCk7XG5cdFx0XHRcdGlmIChjb2xvcilcblx0XHRcdFx0XHRjb2xvci50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShcblx0XHRcdFx0XHRcdFx0aXRlbS5nZXRQb3NpdGlvbih0cnVlKS5uZWdhdGUoKSkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdH0sIHt9KSwge1xuXHRcdGlkOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0ZGVmaW5pdGlvbnNbdmFsdWVdID0gaXRlbTtcblx0XHRcdGlmIChpdGVtLnNldE5hbWUpXG5cdFx0XHRcdGl0ZW0uc2V0TmFtZSh2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdCdjbGlwLXBhdGgnOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0dmFyIGNsaXAgPSBnZXREZWZpbml0aW9uKHZhbHVlKTtcblx0XHRcdGlmIChjbGlwKSB7XG5cdFx0XHRcdGNsaXAgPSBjbGlwLmNsb25lKCk7XG5cdFx0XHRcdGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG5cdFx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXApIHtcblx0XHRcdFx0XHRpdGVtLmluc2VydENoaWxkKDAsIGNsaXApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJldHVybiBuZXcgR3JvdXAoY2xpcCwgaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Z3JhZGllbnRUcmFuc2Zvcm06IGFwcGx5VHJhbnNmb3JtLFxuXHRcdHRyYW5zZm9ybTogYXBwbHlUcmFuc2Zvcm0sXG5cblx0XHQnZmlsbC1vcGFjaXR5JzogYXBwbHlPcGFjaXR5LFxuXHRcdCdzdHJva2Utb3BhY2l0eSc6IGFwcGx5T3BhY2l0eSxcblxuXHRcdHZpc2liaWxpdHk6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpdGVtLnNldFZpc2libGUodmFsdWUgPT09ICd2aXNpYmxlJyk7XG5cdFx0fSxcblxuXHRcdGRpc3BsYXk6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpdGVtLnNldFZpc2libGUodmFsdWUgIT09IG51bGwpO1xuXHRcdH0sXG5cblx0XHQnc3RvcC1jb2xvcic6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHRpZiAoaXRlbS5zZXRDb2xvcilcblx0XHRcdFx0aXRlbS5zZXRDb2xvcih2YWx1ZSk7XG5cdFx0fSxcblxuXHRcdCdzdG9wLW9wYWNpdHknOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aWYgKGl0ZW0uX2NvbG9yKVxuXHRcdFx0XHRpdGVtLl9jb2xvci5zZXRBbHBoYShwYXJzZUZsb2F0KHZhbHVlKSk7XG5cdFx0fSxcblxuXHRcdG9mZnNldDogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdHZhciBwZXJjZW50YWdlID0gdmFsdWUubWF0Y2goLyguKiklJC8pO1xuXHRcdFx0aXRlbS5zZXRSYW1wUG9pbnQocGVyY2VudGFnZVxuXHRcdFx0XHRcdD8gcGVyY2VudGFnZVsxXSAvIDEwMFxuXHRcdFx0XHRcdDogcGFyc2VGbG9hdCh2YWx1ZSkpO1xuXHRcdH0sXG5cblx0XHR2aWV3Qm94OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSwgc3R5bGVzKSB7XG5cdFx0XHR2YXIgcmVjdCA9IG5ldyBSZWN0YW5nbGUoY29udmVydFZhbHVlKHZhbHVlLCAnYXJyYXknKSksXG5cdFx0XHRcdHNpemUgPSBnZXRTaXplKG5vZGUsICd3aWR0aCcsICdoZWlnaHQnLCB0cnVlKTtcblx0XHRcdGlmIChpdGVtIGluc3RhbmNlb2YgR3JvdXApIHtcblx0XHRcdFx0dmFyIHNjYWxlID0gc2l6ZSA/IHJlY3QuZ2V0U2l6ZSgpLmRpdmlkZShzaXplKSA6IDEsXG5cdFx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShyZWN0LmdldFBvaW50KCkpLnNjYWxlKHNjYWxlKTtcblx0XHRcdFx0aXRlbS50cmFuc2Zvcm0obWF0cml4LmludmVydGVkKCkpO1xuXHRcdFx0fSBlbHNlIGlmIChpdGVtIGluc3RhbmNlb2YgU3ltYm9sKSB7XG5cdFx0XHRcdGlmIChzaXplKVxuXHRcdFx0XHRcdHJlY3Quc2V0U2l6ZShzaXplKTtcblx0XHRcdFx0dmFyIGNsaXAgPSBnZXRBdHRyaWJ1dGUobm9kZSwgJ292ZXJmbG93Jywgc3R5bGVzKSAhPSAndmlzaWJsZScsXG5cdFx0XHRcdFx0Z3JvdXAgPSBpdGVtLl9kZWZpbml0aW9uO1xuXHRcdFx0XHRpZiAoY2xpcCAmJiAhcmVjdC5jb250YWlucyhncm91cC5nZXRCb3VuZHMoKSkpIHtcblx0XHRcdFx0XHRjbGlwID0gbmV3IFNoYXBlLlJlY3RhbmdsZShyZWN0KS50cmFuc2Zvcm0oZ3JvdXAuX21hdHJpeCk7XG5cdFx0XHRcdFx0Y2xpcC5zZXRDbGlwTWFzayh0cnVlKTtcblx0XHRcdFx0XHRncm91cC5hZGRDaGlsZChjbGlwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSk7XG5cblx0ZnVuY3Rpb24gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHN0eWxlcykge1xuXHRcdHZhciBhdHRyID0gbm9kZS5hdHRyaWJ1dGVzW25hbWVdLFxuXHRcdFx0dmFsdWUgPSBhdHRyICYmIGF0dHIudmFsdWU7XG5cdFx0aWYgKCF2YWx1ZSkge1xuXHRcdFx0dmFyIHN0eWxlID0gQmFzZS5jYW1lbGl6ZShuYW1lKTtcblx0XHRcdHZhbHVlID0gbm9kZS5zdHlsZVtzdHlsZV07XG5cdFx0XHRpZiAoIXZhbHVlICYmIHN0eWxlcy5ub2RlW3N0eWxlXSAhPT0gc3R5bGVzLnBhcmVudFtzdHlsZV0pXG5cdFx0XHRcdHZhbHVlID0gc3R5bGVzLm5vZGVbc3R5bGVdO1xuXHRcdH1cblx0XHRyZXR1cm4gIXZhbHVlXG5cdFx0XHRcdD8gdW5kZWZpbmVkXG5cdFx0XHRcdDogdmFsdWUgPT09ICdub25lJ1xuXHRcdFx0XHRcdD8gbnVsbFxuXHRcdFx0XHRcdDogdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KSB7XG5cdFx0dmFyIHN0eWxlcyA9IHtcblx0XHRcdG5vZGU6IERvbUVsZW1lbnQuZ2V0U3R5bGVzKG5vZGUpIHx8IHt9LFxuXHRcdFx0cGFyZW50OiAhaXNSb290ICYmIERvbUVsZW1lbnQuZ2V0U3R5bGVzKG5vZGUucGFyZW50Tm9kZSkgfHwge31cblx0XHR9O1xuXHRcdEJhc2UuZWFjaChhdHRyaWJ1dGVzLCBmdW5jdGlvbihhcHBseSwgbmFtZSkge1xuXHRcdFx0dmFyIHZhbHVlID0gZ2V0QXR0cmlidXRlKG5vZGUsIG5hbWUsIHN0eWxlcyk7XG5cdFx0XHRpZiAodmFsdWUgIT09IHVuZGVmaW5lZClcblx0XHRcdFx0aXRlbSA9IEJhc2UucGljayhhcHBseShpdGVtLCB2YWx1ZSwgbmFtZSwgbm9kZSwgc3R5bGVzKSwgaXRlbSk7XG5cdFx0fSk7XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHR2YXIgZGVmaW5pdGlvbnMgPSB7fTtcblx0ZnVuY3Rpb24gZ2V0RGVmaW5pdGlvbih2YWx1ZSkge1xuXHRcdHZhciBtYXRjaCA9IHZhbHVlICYmIHZhbHVlLm1hdGNoKC9cXCgoPzojfCkoW14pJ10rKS8pO1xuXHRcdHJldHVybiBtYXRjaCAmJiBkZWZpbml0aW9uc1ttYXRjaFsxXV07XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRTVkcoc291cmNlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHRpZiAoIXNvdXJjZSlcblx0XHRcdHJldHVybiBudWxsO1xuXHRcdGlmICghb3B0aW9ucykge1xuXHRcdFx0b3B0aW9ucyA9IHt9O1xuXHRcdH0gZWxzZSBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdG9wdGlvbnMgPSB7IG9uTG9hZDogb3B0aW9ucyB9O1xuXHRcdH1cblxuXHRcdHZhciBub2RlID0gc291cmNlLFxuXHRcdFx0c2NvcGUgPSBwYXBlcjtcblxuXHRcdGZ1bmN0aW9uIG9uTG9hZENhbGxiYWNrKHN2Zykge1xuXHRcdFx0cGFwZXIgPSBzY29wZTtcblx0XHRcdHZhciBpdGVtID0gaW1wb3J0U1ZHKHN2Zywgb3B0aW9ucywgaXNSb290KSxcblx0XHRcdFx0b25Mb2FkID0gb3B0aW9ucy5vbkxvYWQsXG5cdFx0XHRcdHZpZXcgPSBzY29wZS5wcm9qZWN0ICYmIHNjb3BlLmdldFZpZXcoKTtcblx0XHRcdGlmIChvbkxvYWQpXG5cdFx0XHRcdG9uTG9hZC5jYWxsKHRoaXMsIGl0ZW0pO1xuXHRcdFx0dmlldy51cGRhdGUoKTtcblx0XHR9XG5cblx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHRpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycgJiYgIS9eLio8Ly50ZXN0KHNvdXJjZSkpIHtcblx0XHRcdFx0bm9kZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNvdXJjZSk7XG5cdFx0XHRcdGlmIChub2RlKSB7XG5cdFx0XHRcdFx0c291cmNlID0gbnVsbDtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gSHR0cC5yZXF1ZXN0KCdnZXQnLCBzb3VyY2UsIG9uTG9hZENhbGxiYWNrKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2YgRmlsZSAhPT0gJ3VuZGVmaW5lZCcgJiYgc291cmNlIGluc3RhbmNlb2YgRmlsZSkge1xuXHRcdFx0XHR2YXIgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcblx0XHRcdFx0cmVhZGVyLm9ubG9hZCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdG9uTG9hZENhbGxiYWNrKHJlYWRlci5yZXN1bHQpO1xuXHRcdFx0XHR9O1xuXHRcdFx0XHRyZXR1cm4gcmVhZGVyLnJlYWRBc1RleHQoc291cmNlKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIHNvdXJjZSA9PT0gJ3N0cmluZycpXG5cdFx0XHRub2RlID0gbmV3IERPTVBhcnNlcigpLnBhcnNlRnJvbVN0cmluZyhzb3VyY2UsICdpbWFnZS9zdmcreG1sJyk7XG5cdFx0aWYgKCFub2RlLm5vZGVOYW1lKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBTVkcgc291cmNlOiAnICsgc291cmNlKTtcblx0XHR2YXIgdHlwZSA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSxcblx0XHRcdGltcG9ydGVyID0gaW1wb3J0ZXJzW3R5cGVdLFxuXHRcdFx0aXRlbSxcblx0XHRcdGRhdGEgPSBub2RlLmdldEF0dHJpYnV0ZSAmJiBub2RlLmdldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1kYXRhJyksXG5cdFx0XHRzZXR0aW5ncyA9IHNjb3BlLnNldHRpbmdzLFxuXHRcdFx0YXBwbHlNYXRyaXggPSBzZXR0aW5ncy5hcHBseU1hdHJpeDtcblx0XHRzZXR0aW5ncy5hcHBseU1hdHJpeCA9IGZhbHNlO1xuXHRcdGl0ZW0gPSBpbXBvcnRlciAmJiBpbXBvcnRlcihub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHx8IG51bGw7XG5cdFx0c2V0dGluZ3MuYXBwbHlNYXRyaXggPSBhcHBseU1hdHJpeDtcblx0XHRpZiAoaXRlbSkge1xuXHRcdFx0aWYgKHR5cGUgIT09ICcjZG9jdW1lbnQnICYmICEoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSlcblx0XHRcdFx0aXRlbSA9IGFwcGx5QXR0cmlidXRlcyhpdGVtLCBub2RlLCBpc1Jvb3QpO1xuXHRcdFx0dmFyIG9uSW1wb3J0ID0gb3B0aW9ucy5vbkltcG9ydDtcblx0XHRcdGlmIChvbkltcG9ydClcblx0XHRcdFx0aXRlbSA9IG9uSW1wb3J0KG5vZGUsIGl0ZW0sIG9wdGlvbnMpIHx8IGl0ZW07XG5cdFx0XHRpZiAob3B0aW9ucy5leHBhbmRTaGFwZXMgJiYgaXRlbSBpbnN0YW5jZW9mIFNoYXBlKSB7XG5cdFx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRcdGl0ZW0gPSBpdGVtLnRvUGF0aCgpO1xuXHRcdFx0fVxuXHRcdFx0aWYgKGRhdGEpXG5cdFx0XHRcdGl0ZW0uX2RhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuXHRcdH1cblx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHRkZWZpbml0aW9ucyA9IHt9O1xuXHRcdFx0aWYgKGl0ZW0gJiYgQmFzZS5waWNrKG9wdGlvbnMuYXBwbHlNYXRyaXgsIGFwcGx5TWF0cml4KSlcblx0XHRcdFx0aXRlbS5tYXRyaXguYXBwbHkodHJ1ZSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0SXRlbS5pbmplY3Qoe1xuXHRcdGltcG9ydFNWRzogZnVuY3Rpb24obm9kZSwgb3B0aW9ucykge1xuXHRcdFx0cmV0dXJuIHRoaXMuYWRkQ2hpbGQoaW1wb3J0U1ZHKG5vZGUsIG9wdGlvbnMsIHRydWUpKTtcblx0XHR9XG5cdH0pO1xuXG5cdFByb2plY3QuaW5qZWN0KHtcblx0XHRpbXBvcnRTVkc6IGZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0XHRcdHJldHVybiBpbXBvcnRTVkcobm9kZSwgb3B0aW9ucywgdHJ1ZSk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbkJhc2UuZXhwb3J0cy5QYXBlclNjcmlwdCA9IChmdW5jdGlvbigpIHtcblx0dmFyIGV4cG9ydHMsIGRlZmluZSxcblx0XHRzY29wZSA9IHRoaXM7XG4hZnVuY3Rpb24oZSxyKXtyZXR1cm5cIm9iamVjdFwiPT10eXBlb2YgZXhwb3J0cyYmXCJvYmplY3RcIj09dHlwZW9mIG1vZHVsZT9yKGV4cG9ydHMpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW1wiZXhwb3J0c1wiXSxyKToocihlLmFjb3JufHwoZS5hY29ybj17fSkpLHZvaWQgMCl9KHRoaXMsZnVuY3Rpb24oZSl7XCJ1c2Ugc3RyaWN0XCI7ZnVuY3Rpb24gcihlKXtmcj1lfHx7fTtmb3IodmFyIHIgaW4gbXIpT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKGZyLHIpfHwoZnJbcl09bXJbcl0pO2hyPWZyLnNvdXJjZUZpbGV8fG51bGx9ZnVuY3Rpb24gdChlLHIpe3ZhciB0PXZyKGRyLGUpO3IrPVwiIChcIit0LmxpbmUrXCI6XCIrdC5jb2x1bW4rXCIpXCI7dmFyIG49bmV3IFN5bnRheEVycm9yKHIpO3Rocm93IG4ucG9zPWUsbi5sb2M9dCxuLnJhaXNlZEF0PWJyLG59ZnVuY3Rpb24gbihlKXtmdW5jdGlvbiByKGUpe2lmKDE9PWUubGVuZ3RoKXJldHVybiB0Kz1cInJldHVybiBzdHIgPT09IFwiK0pTT04uc3RyaW5naWZ5KGVbMF0pK1wiO1wiO3QrPVwic3dpdGNoKHN0cil7XCI7Zm9yKHZhciByPTA7cjxlLmxlbmd0aDsrK3IpdCs9XCJjYXNlIFwiK0pTT04uc3RyaW5naWZ5KGVbcl0pK1wiOlwiO3QrPVwicmV0dXJuIHRydWV9cmV0dXJuIGZhbHNlO1wifWU9ZS5zcGxpdChcIiBcIik7dmFyIHQ9XCJcIixuPVtdO2U6Zm9yKHZhciBhPTA7YTxlLmxlbmd0aDsrK2Epe2Zvcih2YXIgbz0wO288bi5sZW5ndGg7KytvKWlmKG5bb11bMF0ubGVuZ3RoPT1lW2FdLmxlbmd0aCl7bltvXS5wdXNoKGVbYV0pO2NvbnRpbnVlIGV9bi5wdXNoKFtlW2FdXSl9aWYobi5sZW5ndGg+Myl7bi5zb3J0KGZ1bmN0aW9uKGUscil7cmV0dXJuIHIubGVuZ3RoLWUubGVuZ3RofSksdCs9XCJzd2l0Y2goc3RyLmxlbmd0aCl7XCI7Zm9yKHZhciBhPTA7YTxuLmxlbmd0aDsrK2Epe3ZhciBpPW5bYV07dCs9XCJjYXNlIFwiK2lbMF0ubGVuZ3RoK1wiOlwiLHIoaSl9dCs9XCJ9XCJ9ZWxzZSByKGUpO3JldHVybiBuZXcgRnVuY3Rpb24oXCJzdHJcIix0KX1mdW5jdGlvbiBhKCl7dGhpcy5saW5lPUFyLHRoaXMuY29sdW1uPWJyLVNyfWZ1bmN0aW9uIG8oKXtBcj0xLGJyPVNyPTAsRXI9ITAsdSgpfWZ1bmN0aW9uIGkoZSxyKXtncj1icixmci5sb2NhdGlvbnMmJihrcj1uZXcgYSksd3I9ZSx1KCksQ3I9cixFcj1lLmJlZm9yZUV4cHJ9ZnVuY3Rpb24gcygpe3ZhciBlPWZyLm9uQ29tbWVudCYmZnIubG9jYXRpb25zJiZuZXcgYSxyPWJyLG49ZHIuaW5kZXhPZihcIiovXCIsYnIrPTIpO2lmKC0xPT09biYmdChici0yLFwiVW50ZXJtaW5hdGVkIGNvbW1lbnRcIiksYnI9bisyLGZyLmxvY2F0aW9ucyl7S3QubGFzdEluZGV4PXI7Zm9yKHZhciBvOyhvPUt0LmV4ZWMoZHIpKSYmby5pbmRleDxicjspKytBcixTcj1vLmluZGV4K29bMF0ubGVuZ3RofWZyLm9uQ29tbWVudCYmZnIub25Db21tZW50KCEwLGRyLnNsaWNlKHIrMixuKSxyLGJyLGUsZnIubG9jYXRpb25zJiZuZXcgYSl9ZnVuY3Rpb24gYygpe2Zvcih2YXIgZT1icixyPWZyLm9uQ29tbWVudCYmZnIubG9jYXRpb25zJiZuZXcgYSx0PWRyLmNoYXJDb2RlQXQoYnIrPTIpO3ByPmJyJiYxMCE9PXQmJjEzIT09dCYmODIzMiE9PXQmJjgyMzMhPT10OykrK2JyLHQ9ZHIuY2hhckNvZGVBdChicik7ZnIub25Db21tZW50JiZmci5vbkNvbW1lbnQoITEsZHIuc2xpY2UoZSsyLGJyKSxlLGJyLHIsZnIubG9jYXRpb25zJiZuZXcgYSl9ZnVuY3Rpb24gdSgpe2Zvcig7cHI+YnI7KXt2YXIgZT1kci5jaGFyQ29kZUF0KGJyKTtpZigzMj09PWUpKyticjtlbHNlIGlmKDEzPT09ZSl7Kyticjt2YXIgcj1kci5jaGFyQ29kZUF0KGJyKTsxMD09PXImJisrYnIsZnIubG9jYXRpb25zJiYoKytBcixTcj1icil9ZWxzZSBpZigxMD09PWV8fDgyMzI9PT1lfHw4MjMzPT09ZSkrK2JyLGZyLmxvY2F0aW9ucyYmKCsrQXIsU3I9YnIpO2Vsc2UgaWYoZT44JiYxND5lKSsrYnI7ZWxzZSBpZig0Nz09PWUpe3ZhciByPWRyLmNoYXJDb2RlQXQoYnIrMSk7aWYoNDI9PT1yKXMoKTtlbHNle2lmKDQ3IT09cilicmVhaztjKCl9fWVsc2UgaWYoMTYwPT09ZSkrK2JyO2Vsc2V7aWYoIShlPj01NzYwJiZKdC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpKSlicmVhazsrK2JyfX19ZnVuY3Rpb24gbCgpe3ZhciBlPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIGU+PTQ4JiY1Nz49ZT9FKCEwKTooKyticixpKHh0KSl9ZnVuY3Rpb24gZigpe3ZhciBlPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIEVyPygrK2JyLGsoKSk6NjE9PT1lP3goRXQsMik6eCh3dCwxKX1mdW5jdGlvbiBkKCl7dmFyIGU9ZHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gNjE9PT1lP3goRXQsMik6eChEdCwxKX1mdW5jdGlvbiBwKGUpe3ZhciByPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIHI9PT1lP3goMTI0PT09ZT9MdDpVdCwyKTo2MT09PXI/eChFdCwyKTp4KDEyND09PWU/UnQ6VHQsMSl9ZnVuY3Rpb24gaCgpe3ZhciBlPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIDYxPT09ZT94KEV0LDIpOngoVnQsMSl9ZnVuY3Rpb24gbShlKXt2YXIgcj1kci5jaGFyQ29kZUF0KGJyKzEpO3JldHVybiByPT09ZT80NT09ciYmNjI9PWRyLmNoYXJDb2RlQXQoYnIrMikmJkd0LnRlc3QoZHIuc2xpY2UoTHIsYnIpKT8oYnIrPTMsYygpLHUoKSxnKCkpOngoU3QsMik6NjE9PT1yP3goRXQsMik6eChBdCwxKX1mdW5jdGlvbiB2KGUpe3ZhciByPWRyLmNoYXJDb2RlQXQoYnIrMSksdD0xO3JldHVybiByPT09ZT8odD02Mj09PWUmJjYyPT09ZHIuY2hhckNvZGVBdChicisyKT8zOjIsNjE9PT1kci5jaGFyQ29kZUF0KGJyK3QpP3goRXQsdCsxKTp4KGp0LHQpKTozMz09ciYmNjA9PWUmJjQ1PT1kci5jaGFyQ29kZUF0KGJyKzIpJiY0NT09ZHIuY2hhckNvZGVBdChiciszKT8oYnIrPTQsYygpLHUoKSxnKCkpOig2MT09PXImJih0PTYxPT09ZHIuY2hhckNvZGVBdChicisyKT8zOjIpLHgoT3QsdCkpfWZ1bmN0aW9uIGIoZSl7dmFyIHI9ZHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gNjE9PT1yP3gocXQsNjE9PT1kci5jaGFyQ29kZUF0KGJyKzIpPzM6Mik6eCg2MT09PWU/Q3Q6SXQsMSl9ZnVuY3Rpb24geShlKXtzd2l0Y2goZSl7Y2FzZSA0NjpyZXR1cm4gbCgpO2Nhc2UgNDA6cmV0dXJuKyticixpKG10KTtjYXNlIDQxOnJldHVybisrYnIsaSh2dCk7Y2FzZSA1OTpyZXR1cm4rK2JyLGkoeXQpO2Nhc2UgNDQ6cmV0dXJuKyticixpKGJ0KTtjYXNlIDkxOnJldHVybisrYnIsaShmdCk7Y2FzZSA5MzpyZXR1cm4rK2JyLGkoZHQpO2Nhc2UgMTIzOnJldHVybisrYnIsaShwdCk7Y2FzZSAxMjU6cmV0dXJuKyticixpKGh0KTtjYXNlIDU4OnJldHVybisrYnIsaShndCk7Y2FzZSA2MzpyZXR1cm4rK2JyLGkoa3QpO2Nhc2UgNDg6dmFyIHI9ZHIuY2hhckNvZGVBdChicisxKTtpZigxMjA9PT1yfHw4OD09PXIpcmV0dXJuIEMoKTtjYXNlIDQ5OmNhc2UgNTA6Y2FzZSA1MTpjYXNlIDUyOmNhc2UgNTM6Y2FzZSA1NDpjYXNlIDU1OmNhc2UgNTY6Y2FzZSA1NzpyZXR1cm4gRSghMSk7Y2FzZSAzNDpjYXNlIDM5OnJldHVybiBBKGUpO2Nhc2UgNDc6cmV0dXJuIGYoZSk7Y2FzZSAzNzpjYXNlIDQyOnJldHVybiBkKCk7Y2FzZSAxMjQ6Y2FzZSAzODpyZXR1cm4gcChlKTtjYXNlIDk0OnJldHVybiBoKCk7Y2FzZSA0MzpjYXNlIDQ1OnJldHVybiBtKGUpO2Nhc2UgNjA6Y2FzZSA2MjpyZXR1cm4gdihlKTtjYXNlIDYxOmNhc2UgMzM6cmV0dXJuIGIoZSk7Y2FzZSAxMjY6cmV0dXJuIHgoSXQsMSl9cmV0dXJuITF9ZnVuY3Rpb24gZyhlKXtpZihlP2JyPXlyKzE6eXI9YnIsZnIubG9jYXRpb25zJiYoeHI9bmV3IGEpLGUpcmV0dXJuIGsoKTtpZihicj49cHIpcmV0dXJuIGkoQnIpO3ZhciByPWRyLmNoYXJDb2RlQXQoYnIpO2lmKFF0KHIpfHw5Mj09PXIpcmV0dXJuIEwoKTt2YXIgbj15KHIpO2lmKG49PT0hMSl7dmFyIG89U3RyaW5nLmZyb21DaGFyQ29kZShyKTtpZihcIlxcXFxcIj09PW98fCR0LnRlc3QobykpcmV0dXJuIEwoKTt0KGJyLFwiVW5leHBlY3RlZCBjaGFyYWN0ZXIgJ1wiK28rXCInXCIpfXJldHVybiBufWZ1bmN0aW9uIHgoZSxyKXt2YXIgdD1kci5zbGljZShicixicityKTticis9cixpKGUsdCl9ZnVuY3Rpb24gaygpe2Zvcih2YXIgZSxyLG49XCJcIixhPWJyOzspe2JyPj1wciYmdChhLFwiVW50ZXJtaW5hdGVkIHJlZ3VsYXIgZXhwcmVzc2lvblwiKTt2YXIgbz1kci5jaGFyQXQoYnIpO2lmKEd0LnRlc3QobykmJnQoYSxcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIiksZSllPSExO2Vsc2V7aWYoXCJbXCI9PT1vKXI9ITA7ZWxzZSBpZihcIl1cIj09PW8mJnIpcj0hMTtlbHNlIGlmKFwiL1wiPT09byYmIXIpYnJlYWs7ZT1cIlxcXFxcIj09PW99Kyticn12YXIgbj1kci5zbGljZShhLGJyKTsrK2JyO3ZhciBzPUkoKTtyZXR1cm4gcyYmIS9eW2dtc2l5XSokLy50ZXN0KHMpJiZ0KGEsXCJJbnZhbGlkIHJlZ2V4cCBmbGFnXCIpLGkoanIsbmV3IFJlZ0V4cChuLHMpKX1mdW5jdGlvbiB3KGUscil7Zm9yKHZhciB0PWJyLG49MCxhPTAsbz1udWxsPT1yPzEvMDpyO28+YTsrK2Epe3ZhciBpLHM9ZHIuY2hhckNvZGVBdChicik7aWYoaT1zPj05Nz9zLTk3KzEwOnM+PTY1P3MtNjUrMTA6cz49NDgmJjU3Pj1zP3MtNDg6MS8wLGk+PWUpYnJlYWs7KyticixuPW4qZStpfXJldHVybiBicj09PXR8fG51bGwhPXImJmJyLXQhPT1yP251bGw6bn1mdW5jdGlvbiBDKCl7YnIrPTI7dmFyIGU9dygxNik7cmV0dXJuIG51bGw9PWUmJnQoeXIrMixcIkV4cGVjdGVkIGhleGFkZWNpbWFsIG51bWJlclwiKSxRdChkci5jaGFyQ29kZUF0KGJyKSkmJnQoYnIsXCJJZGVudGlmaWVyIGRpcmVjdGx5IGFmdGVyIG51bWJlclwiKSxpKE9yLGUpfWZ1bmN0aW9uIEUoZSl7dmFyIHI9YnIsbj0hMSxhPTQ4PT09ZHIuY2hhckNvZGVBdChicik7ZXx8bnVsbCE9PXcoMTApfHx0KHIsXCJJbnZhbGlkIG51bWJlclwiKSw0Nj09PWRyLmNoYXJDb2RlQXQoYnIpJiYoKyticix3KDEwKSxuPSEwKTt2YXIgbz1kci5jaGFyQ29kZUF0KGJyKTsoNjk9PT1vfHwxMDE9PT1vKSYmKG89ZHIuY2hhckNvZGVBdCgrK2JyKSwoNDM9PT1vfHw0NT09PW8pJiYrK2JyLG51bGw9PT13KDEwKSYmdChyLFwiSW52YWxpZCBudW1iZXJcIiksbj0hMCksUXQoZHIuY2hhckNvZGVBdChicikpJiZ0KGJyLFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIik7dmFyIHMsYz1kci5zbGljZShyLGJyKTtyZXR1cm4gbj9zPXBhcnNlRmxvYXQoYyk6YSYmMSE9PWMubGVuZ3RoPy9bODldLy50ZXN0KGMpfHxUcj90KHIsXCJJbnZhbGlkIG51bWJlclwiKTpzPXBhcnNlSW50KGMsOCk6cz1wYXJzZUludChjLDEwKSxpKE9yLHMpfWZ1bmN0aW9uIEEoZSl7YnIrKztmb3IodmFyIHI9XCJcIjs7KXticj49cHImJnQoeXIsXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpO3ZhciBuPWRyLmNoYXJDb2RlQXQoYnIpO2lmKG49PT1lKXJldHVybisrYnIsaShEcixyKTtpZig5Mj09PW4pe249ZHIuY2hhckNvZGVBdCgrK2JyKTt2YXIgYT0vXlswLTddKy8uZXhlYyhkci5zbGljZShicixiciszKSk7Zm9yKGEmJihhPWFbMF0pO2EmJnBhcnNlSW50KGEsOCk+MjU1OylhPWEuc2xpY2UoMCxhLmxlbmd0aC0xKTtpZihcIjBcIj09PWEmJihhPW51bGwpLCsrYnIsYSlUciYmdChici0yLFwiT2N0YWwgbGl0ZXJhbCBpbiBzdHJpY3QgbW9kZVwiKSxyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGEsOCkpLGJyKz1hLmxlbmd0aC0xO2Vsc2Ugc3dpdGNoKG4pe2Nhc2UgMTEwOnIrPVwiXFxuXCI7YnJlYWs7Y2FzZSAxMTQ6cis9XCJcXHJcIjticmVhaztjYXNlIDEyMDpyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKFMoMikpO2JyZWFrO2Nhc2UgMTE3OnIrPVN0cmluZy5mcm9tQ2hhckNvZGUoUyg0KSk7YnJlYWs7Y2FzZSA4NTpyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKFMoOCkpO2JyZWFrO2Nhc2UgMTE2OnIrPVwiXHRcIjticmVhaztjYXNlIDk4OnIrPVwiXFxiXCI7YnJlYWs7Y2FzZSAxMTg6cis9XCJcdTAwMGJcIjticmVhaztjYXNlIDEwMjpyKz1cIlxcZlwiO2JyZWFrO2Nhc2UgNDg6cis9XCJcXDBcIjticmVhaztjYXNlIDEzOjEwPT09ZHIuY2hhckNvZGVBdChicikmJisrYnI7Y2FzZSAxMDpmci5sb2NhdGlvbnMmJihTcj1iciwrK0FyKTticmVhaztkZWZhdWx0OnIrPVN0cmluZy5mcm9tQ2hhckNvZGUobil9fWVsc2UoMTM9PT1ufHwxMD09PW58fDgyMzI9PT1ufHw4MjMzPT09bikmJnQoeXIsXCJVbnRlcm1pbmF0ZWQgc3RyaW5nIGNvbnN0YW50XCIpLHIrPVN0cmluZy5mcm9tQ2hhckNvZGUobiksKyticn19ZnVuY3Rpb24gUyhlKXt2YXIgcj13KDE2LGUpO3JldHVybiBudWxsPT09ciYmdCh5cixcIkJhZCBjaGFyYWN0ZXIgZXNjYXBlIHNlcXVlbmNlXCIpLHJ9ZnVuY3Rpb24gSSgpe0J0PSExO2Zvcih2YXIgZSxyPSEwLG49YnI7Oyl7dmFyIGE9ZHIuY2hhckNvZGVBdChicik7aWYoWXQoYSkpQnQmJihlKz1kci5jaGFyQXQoYnIpKSwrK2JyO2Vsc2V7aWYoOTIhPT1hKWJyZWFrO0J0fHwoZT1kci5zbGljZShuLGJyKSksQnQ9ITAsMTE3IT1kci5jaGFyQ29kZUF0KCsrYnIpJiZ0KGJyLFwiRXhwZWN0aW5nIFVuaWNvZGUgZXNjYXBlIHNlcXVlbmNlIFxcXFx1WFhYWFwiKSwrK2JyO3ZhciBvPVMoNCksaT1TdHJpbmcuZnJvbUNoYXJDb2RlKG8pO2l8fHQoYnItMSxcIkludmFsaWQgVW5pY29kZSBlc2NhcGVcIiksKHI/UXQobyk6WXQobykpfHx0KGJyLTQsXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpLGUrPWl9cj0hMX1yZXR1cm4gQnQ/ZTpkci5zbGljZShuLGJyKX1mdW5jdGlvbiBMKCl7dmFyIGU9SSgpLHI9RnI7cmV0dXJuIEJ0fHwoV3QoZSk/cj1sdFtlXTooZnIuZm9yYmlkUmVzZXJ2ZWQmJigzPT09ZnIuZWNtYVZlcnNpb24/TXQ6enQpKGUpfHxUciYmWHQoZSkpJiZ0KHlyLFwiVGhlIGtleXdvcmQgJ1wiK2UrXCInIGlzIHJlc2VydmVkXCIpKSxpKHIsZSl9ZnVuY3Rpb24gVSgpe0lyPXlyLExyPWdyLFVyPWtyLGcoKX1mdW5jdGlvbiBSKGUpe2lmKFRyPWUsYnI9THIsZnIubG9jYXRpb25zKWZvcig7U3I+YnI7KVNyPWRyLmxhc3RJbmRleE9mKFwiXFxuXCIsU3ItMikrMSwtLUFyO3UoKSxnKCl9ZnVuY3Rpb24gVigpe3RoaXMudHlwZT1udWxsLHRoaXMuc3RhcnQ9eXIsdGhpcy5lbmQ9bnVsbH1mdW5jdGlvbiBUKCl7dGhpcy5zdGFydD14cix0aGlzLmVuZD1udWxsLG51bGwhPT1ociYmKHRoaXMuc291cmNlPWhyKX1mdW5jdGlvbiBxKCl7dmFyIGU9bmV3IFY7cmV0dXJuIGZyLmxvY2F0aW9ucyYmKGUubG9jPW5ldyBUKSxmci5yYW5nZXMmJihlLnJhbmdlPVt5ciwwXSksZX1mdW5jdGlvbiBPKGUpe3ZhciByPW5ldyBWO3JldHVybiByLnN0YXJ0PWUuc3RhcnQsZnIubG9jYXRpb25zJiYoci5sb2M9bmV3IFQsci5sb2Muc3RhcnQ9ZS5sb2Muc3RhcnQpLGZyLnJhbmdlcyYmKHIucmFuZ2U9W2UucmFuZ2VbMF0sMF0pLHJ9ZnVuY3Rpb24gaihlLHIpe3JldHVybiBlLnR5cGU9cixlLmVuZD1Mcixmci5sb2NhdGlvbnMmJihlLmxvYy5lbmQ9VXIpLGZyLnJhbmdlcyYmKGUucmFuZ2VbMV09THIpLGV9ZnVuY3Rpb24gRChlKXtyZXR1cm4gZnIuZWNtYVZlcnNpb24+PTUmJlwiRXhwcmVzc2lvblN0YXRlbWVudFwiPT09ZS50eXBlJiZcIkxpdGVyYWxcIj09PWUuZXhwcmVzc2lvbi50eXBlJiZcInVzZSBzdHJpY3RcIj09PWUuZXhwcmVzc2lvbi52YWx1ZX1mdW5jdGlvbiBGKGUpe3JldHVybiB3cj09PWU/KFUoKSwhMCk6dm9pZCAwfWZ1bmN0aW9uIEIoKXtyZXR1cm4hZnIuc3RyaWN0U2VtaWNvbG9ucyYmKHdyPT09QnJ8fHdyPT09aHR8fEd0LnRlc3QoZHIuc2xpY2UoTHIseXIpKSl9ZnVuY3Rpb24gTSgpe0YoeXQpfHxCKCl8fFgoKX1mdW5jdGlvbiB6KGUpe3dyPT09ZT9VKCk6WCgpfWZ1bmN0aW9uIFgoKXt0KHlyLFwiVW5leHBlY3RlZCB0b2tlblwiKX1mdW5jdGlvbiBOKGUpe1wiSWRlbnRpZmllclwiIT09ZS50eXBlJiZcIk1lbWJlckV4cHJlc3Npb25cIiE9PWUudHlwZSYmdChlLnN0YXJ0LFwiQXNzaWduaW5nIHRvIHJ2YWx1ZVwiKSxUciYmXCJJZGVudGlmaWVyXCI9PT1lLnR5cGUmJk50KGUubmFtZSkmJnQoZS5zdGFydCxcIkFzc2lnbmluZyB0byBcIitlLm5hbWUrXCIgaW4gc3RyaWN0IG1vZGVcIil9ZnVuY3Rpb24gVyhlKXtJcj1Mcj1icixmci5sb2NhdGlvbnMmJihVcj1uZXcgYSksUnI9VHI9bnVsbCxWcj1bXSxnKCk7dmFyIHI9ZXx8cSgpLHQ9ITA7Zm9yKGV8fChyLmJvZHk9W10pO3dyIT09QnI7KXt2YXIgbj1KKCk7ci5ib2R5LnB1c2gobiksdCYmRChuKSYmUighMCksdD0hMX1yZXR1cm4gaihyLFwiUHJvZ3JhbVwiKX1mdW5jdGlvbiBKKCl7KHdyPT09d3R8fHdyPT09RXQmJlwiLz1cIj09Q3IpJiZnKCEwKTt2YXIgZT13cixyPXEoKTtzd2l0Y2goZSl7Y2FzZSBNcjpjYXNlIE5yOlUoKTt2YXIgbj1lPT09TXI7Rih5dCl8fEIoKT9yLmxhYmVsPW51bGw6d3IhPT1Gcj9YKCk6KHIubGFiZWw9bHIoKSxNKCkpO2Zvcih2YXIgYT0wO2E8VnIubGVuZ3RoOysrYSl7dmFyIG89VnJbYV07aWYobnVsbD09ci5sYWJlbHx8by5uYW1lPT09ci5sYWJlbC5uYW1lKXtpZihudWxsIT1vLmtpbmQmJihufHxcImxvb3BcIj09PW8ua2luZCkpYnJlYWs7aWYoci5sYWJlbCYmbilicmVha319cmV0dXJuIGE9PT1Wci5sZW5ndGgmJnQoci5zdGFydCxcIlVuc3ludGFjdGljIFwiK2Uua2V5d29yZCksaihyLG4/XCJCcmVha1N0YXRlbWVudFwiOlwiQ29udGludWVTdGF0ZW1lbnRcIik7Y2FzZSBXcjpyZXR1cm4gVSgpLE0oKSxqKHIsXCJEZWJ1Z2dlclN0YXRlbWVudFwiKTtjYXNlIFByOnJldHVybiBVKCksVnIucHVzaChadCksci5ib2R5PUooKSxWci5wb3AoKSx6KHR0KSxyLnRlc3Q9UCgpLE0oKSxqKHIsXCJEb1doaWxlU3RhdGVtZW50XCIpO2Nhc2UgX3I6aWYoVSgpLFZyLnB1c2goWnQpLHoobXQpLHdyPT09eXQpcmV0dXJuICQocixudWxsKTtpZih3cj09PXJ0KXt2YXIgaT1xKCk7cmV0dXJuIFUoKSxHKGksITApLGooaSxcIlZhcmlhYmxlRGVjbGFyYXRpb25cIiksMT09PWkuZGVjbGFyYXRpb25zLmxlbmd0aCYmRih1dCk/XyhyLGkpOiQocixpKX12YXIgaT1LKCExLCEwKTtyZXR1cm4gRih1dCk/KE4oaSksXyhyLGkpKTokKHIsaSk7Y2FzZSBHcjpyZXR1cm4gVSgpLGNyKHIsITApO2Nhc2UgS3I6cmV0dXJuIFUoKSxyLnRlc3Q9UCgpLHIuY29uc2VxdWVudD1KKCksci5hbHRlcm5hdGU9RihIcik/SigpOm51bGwsaihyLFwiSWZTdGF0ZW1lbnRcIik7Y2FzZSBRcjpyZXR1cm4gUnJ8fHQoeXIsXCIncmV0dXJuJyBvdXRzaWRlIG9mIGZ1bmN0aW9uXCIpLFUoKSxGKHl0KXx8QigpP3IuYXJndW1lbnQ9bnVsbDooci5hcmd1bWVudD1LKCksTSgpKSxqKHIsXCJSZXR1cm5TdGF0ZW1lbnRcIik7Y2FzZSBZcjpVKCksci5kaXNjcmltaW5hbnQ9UCgpLHIuY2FzZXM9W10seihwdCksVnIucHVzaChlbik7Zm9yKHZhciBzLGM7d3IhPWh0OylpZih3cj09PXpyfHx3cj09PUpyKXt2YXIgdT13cj09PXpyO3MmJmoocyxcIlN3aXRjaENhc2VcIiksci5jYXNlcy5wdXNoKHM9cSgpKSxzLmNvbnNlcXVlbnQ9W10sVSgpLHU/cy50ZXN0PUsoKTooYyYmdChJcixcIk11bHRpcGxlIGRlZmF1bHQgY2xhdXNlc1wiKSxjPSEwLHMudGVzdD1udWxsKSx6KGd0KX1lbHNlIHN8fFgoKSxzLmNvbnNlcXVlbnQucHVzaChKKCkpO3JldHVybiBzJiZqKHMsXCJTd2l0Y2hDYXNlXCIpLFUoKSxWci5wb3AoKSxqKHIsXCJTd2l0Y2hTdGF0ZW1lbnRcIik7Y2FzZSBacjpyZXR1cm4gVSgpLEd0LnRlc3QoZHIuc2xpY2UoTHIseXIpKSYmdChMcixcIklsbGVnYWwgbmV3bGluZSBhZnRlciB0aHJvd1wiKSxyLmFyZ3VtZW50PUsoKSxNKCksaihyLFwiVGhyb3dTdGF0ZW1lbnRcIik7Y2FzZSBldDppZihVKCksci5ibG9jaz1IKCksci5oYW5kbGVyPW51bGwsd3I9PT1Ycil7dmFyIGw9cSgpO1UoKSx6KG10KSxsLnBhcmFtPWxyKCksVHImJk50KGwucGFyYW0ubmFtZSkmJnQobC5wYXJhbS5zdGFydCxcIkJpbmRpbmcgXCIrbC5wYXJhbS5uYW1lK1wiIGluIHN0cmljdCBtb2RlXCIpLHoodnQpLGwuZ3VhcmQ9bnVsbCxsLmJvZHk9SCgpLHIuaGFuZGxlcj1qKGwsXCJDYXRjaENsYXVzZVwiKX1yZXR1cm4gci5ndWFyZGVkSGFuZGxlcnM9cXIsci5maW5hbGl6ZXI9Rigkcik/SCgpOm51bGwsci5oYW5kbGVyfHxyLmZpbmFsaXplcnx8dChyLnN0YXJ0LFwiTWlzc2luZyBjYXRjaCBvciBmaW5hbGx5IGNsYXVzZVwiKSxqKHIsXCJUcnlTdGF0ZW1lbnRcIik7Y2FzZSBydDpyZXR1cm4gVSgpLEcociksTSgpLGoocixcIlZhcmlhYmxlRGVjbGFyYXRpb25cIik7Y2FzZSB0dDpyZXR1cm4gVSgpLHIudGVzdD1QKCksVnIucHVzaChadCksci5ib2R5PUooKSxWci5wb3AoKSxqKHIsXCJXaGlsZVN0YXRlbWVudFwiKTtjYXNlIG50OnJldHVybiBUciYmdCh5cixcIid3aXRoJyBpbiBzdHJpY3QgbW9kZVwiKSxVKCksci5vYmplY3Q9UCgpLHIuYm9keT1KKCksaihyLFwiV2l0aFN0YXRlbWVudFwiKTtjYXNlIHB0OnJldHVybiBIKCk7Y2FzZSB5dDpyZXR1cm4gVSgpLGoocixcIkVtcHR5U3RhdGVtZW50XCIpO2RlZmF1bHQ6dmFyIGY9Q3IsZD1LKCk7aWYoZT09PUZyJiZcIklkZW50aWZpZXJcIj09PWQudHlwZSYmRihndCkpe2Zvcih2YXIgYT0wO2E8VnIubGVuZ3RoOysrYSlWclthXS5uYW1lPT09ZiYmdChkLnN0YXJ0LFwiTGFiZWwgJ1wiK2YrXCInIGlzIGFscmVhZHkgZGVjbGFyZWRcIik7dmFyIHA9d3IuaXNMb29wP1wibG9vcFwiOndyPT09WXI/XCJzd2l0Y2hcIjpudWxsO3JldHVybiBWci5wdXNoKHtuYW1lOmYsa2luZDpwfSksci5ib2R5PUooKSxWci5wb3AoKSxyLmxhYmVsPWQsaihyLFwiTGFiZWxlZFN0YXRlbWVudFwiKX1yZXR1cm4gci5leHByZXNzaW9uPWQsTSgpLGoocixcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIil9fWZ1bmN0aW9uIFAoKXt6KG10KTt2YXIgZT1LKCk7cmV0dXJuIHoodnQpLGV9ZnVuY3Rpb24gSChlKXt2YXIgcix0PXEoKSxuPSEwLGE9ITE7Zm9yKHQuYm9keT1bXSx6KHB0KTshRihodCk7KXt2YXIgbz1KKCk7dC5ib2R5LnB1c2gobyksbiYmZSYmRChvKSYmKHI9YSxSKGE9ITApKSxuPSExfXJldHVybiBhJiYhciYmUighMSksaih0LFwiQmxvY2tTdGF0ZW1lbnRcIil9ZnVuY3Rpb24gJChlLHIpe3JldHVybiBlLmluaXQ9cix6KHl0KSxlLnRlc3Q9d3I9PT15dD9udWxsOksoKSx6KHl0KSxlLnVwZGF0ZT13cj09PXZ0P251bGw6SygpLHoodnQpLGUuYm9keT1KKCksVnIucG9wKCksaihlLFwiRm9yU3RhdGVtZW50XCIpfWZ1bmN0aW9uIF8oZSxyKXtyZXR1cm4gZS5sZWZ0PXIsZS5yaWdodD1LKCkseih2dCksZS5ib2R5PUooKSxWci5wb3AoKSxqKGUsXCJGb3JJblN0YXRlbWVudFwiKX1mdW5jdGlvbiBHKGUscil7Zm9yKGUuZGVjbGFyYXRpb25zPVtdLGUua2luZD1cInZhclwiOzspe3ZhciBuPXEoKTtpZihuLmlkPWxyKCksVHImJk50KG4uaWQubmFtZSkmJnQobi5pZC5zdGFydCxcIkJpbmRpbmcgXCIrbi5pZC5uYW1lK1wiIGluIHN0cmljdCBtb2RlXCIpLG4uaW5pdD1GKEN0KT9LKCEwLHIpOm51bGwsZS5kZWNsYXJhdGlvbnMucHVzaChqKG4sXCJWYXJpYWJsZURlY2xhcmF0b3JcIikpLCFGKGJ0KSlicmVha31yZXR1cm4gZX1mdW5jdGlvbiBLKGUscil7dmFyIHQ9UShyKTtpZighZSYmd3I9PT1idCl7dmFyIG49Tyh0KTtmb3Iobi5leHByZXNzaW9ucz1bdF07RihidCk7KW4uZXhwcmVzc2lvbnMucHVzaChRKHIpKTtyZXR1cm4gaihuLFwiU2VxdWVuY2VFeHByZXNzaW9uXCIpfXJldHVybiB0fWZ1bmN0aW9uIFEoZSl7dmFyIHI9WShlKTtpZih3ci5pc0Fzc2lnbil7dmFyIHQ9TyhyKTtyZXR1cm4gdC5vcGVyYXRvcj1Dcix0LmxlZnQ9cixVKCksdC5yaWdodD1RKGUpLE4ociksaih0LFwiQXNzaWdubWVudEV4cHJlc3Npb25cIil9cmV0dXJuIHJ9ZnVuY3Rpb24gWShlKXt2YXIgcj1aKGUpO2lmKEYoa3QpKXt2YXIgdD1PKHIpO3JldHVybiB0LnRlc3Q9cix0LmNvbnNlcXVlbnQ9SyghMCkseihndCksdC5hbHRlcm5hdGU9SyghMCxlKSxqKHQsXCJDb25kaXRpb25hbEV4cHJlc3Npb25cIil9cmV0dXJuIHJ9ZnVuY3Rpb24gWihlKXtyZXR1cm4gZXIocnIoKSwtMSxlKX1mdW5jdGlvbiBlcihlLHIsdCl7dmFyIG49d3IuYmlub3A7aWYobnVsbCE9biYmKCF0fHx3ciE9PXV0KSYmbj5yKXt2YXIgYT1PKGUpO2EubGVmdD1lLGEub3BlcmF0b3I9Q3IsVSgpLGEucmlnaHQ9ZXIocnIoKSxuLHQpO3ZhciBvPWooYSwvJiZ8XFx8XFx8Ly50ZXN0KGEub3BlcmF0b3IpP1wiTG9naWNhbEV4cHJlc3Npb25cIjpcIkJpbmFyeUV4cHJlc3Npb25cIik7cmV0dXJuIGVyKG8scix0KX1yZXR1cm4gZX1mdW5jdGlvbiBycigpe2lmKHdyLnByZWZpeCl7dmFyIGU9cSgpLHI9d3IuaXNVcGRhdGU7cmV0dXJuIGUub3BlcmF0b3I9Q3IsZS5wcmVmaXg9ITAsRXI9ITAsVSgpLGUuYXJndW1lbnQ9cnIoKSxyP04oZS5hcmd1bWVudCk6VHImJlwiZGVsZXRlXCI9PT1lLm9wZXJhdG9yJiZcIklkZW50aWZpZXJcIj09PWUuYXJndW1lbnQudHlwZSYmdChlLnN0YXJ0LFwiRGVsZXRpbmcgbG9jYWwgdmFyaWFibGUgaW4gc3RyaWN0IG1vZGVcIiksaihlLHI/XCJVcGRhdGVFeHByZXNzaW9uXCI6XCJVbmFyeUV4cHJlc3Npb25cIil9Zm9yKHZhciBuPXRyKCk7d3IucG9zdGZpeCYmIUIoKTspe3ZhciBlPU8obik7ZS5vcGVyYXRvcj1DcixlLnByZWZpeD0hMSxlLmFyZ3VtZW50PW4sTihuKSxVKCksbj1qKGUsXCJVcGRhdGVFeHByZXNzaW9uXCIpfXJldHVybiBufWZ1bmN0aW9uIHRyKCl7cmV0dXJuIG5yKGFyKCkpfWZ1bmN0aW9uIG5yKGUscil7aWYoRih4dCkpe3ZhciB0PU8oZSk7cmV0dXJuIHQub2JqZWN0PWUsdC5wcm9wZXJ0eT1scighMCksdC5jb21wdXRlZD0hMSxucihqKHQsXCJNZW1iZXJFeHByZXNzaW9uXCIpLHIpfWlmKEYoZnQpKXt2YXIgdD1PKGUpO3JldHVybiB0Lm9iamVjdD1lLHQucHJvcGVydHk9SygpLHQuY29tcHV0ZWQ9ITAseihkdCksbnIoaih0LFwiTWVtYmVyRXhwcmVzc2lvblwiKSxyKX1pZighciYmRihtdCkpe3ZhciB0PU8oZSk7cmV0dXJuIHQuY2FsbGVlPWUsdC5hcmd1bWVudHM9dXIodnQsITEpLG5yKGoodCxcIkNhbGxFeHByZXNzaW9uXCIpLHIpfXJldHVybiBlfWZ1bmN0aW9uIGFyKCl7c3dpdGNoKHdyKXtjYXNlIG90OnZhciBlPXEoKTtyZXR1cm4gVSgpLGooZSxcIlRoaXNFeHByZXNzaW9uXCIpO2Nhc2UgRnI6cmV0dXJuIGxyKCk7Y2FzZSBPcjpjYXNlIERyOmNhc2UganI6dmFyIGU9cSgpO3JldHVybiBlLnZhbHVlPUNyLGUucmF3PWRyLnNsaWNlKHlyLGdyKSxVKCksaihlLFwiTGl0ZXJhbFwiKTtjYXNlIGl0OmNhc2Ugc3Q6Y2FzZSBjdDp2YXIgZT1xKCk7cmV0dXJuIGUudmFsdWU9d3IuYXRvbVZhbHVlLGUucmF3PXdyLmtleXdvcmQsVSgpLGooZSxcIkxpdGVyYWxcIik7Y2FzZSBtdDp2YXIgcj14cix0PXlyO1UoKTt2YXIgbj1LKCk7cmV0dXJuIG4uc3RhcnQ9dCxuLmVuZD1ncixmci5sb2NhdGlvbnMmJihuLmxvYy5zdGFydD1yLG4ubG9jLmVuZD1rciksZnIucmFuZ2VzJiYobi5yYW5nZT1bdCxncl0pLHoodnQpLG47Y2FzZSBmdDp2YXIgZT1xKCk7cmV0dXJuIFUoKSxlLmVsZW1lbnRzPXVyKGR0LCEwLCEwKSxqKGUsXCJBcnJheUV4cHJlc3Npb25cIik7Y2FzZSBwdDpyZXR1cm4gaXIoKTtjYXNlIEdyOnZhciBlPXEoKTtyZXR1cm4gVSgpLGNyKGUsITEpO2Nhc2UgYXQ6cmV0dXJuIG9yKCk7ZGVmYXVsdDpYKCl9fWZ1bmN0aW9uIG9yKCl7dmFyIGU9cSgpO3JldHVybiBVKCksZS5jYWxsZWU9bnIoYXIoKSwhMCksZS5hcmd1bWVudHM9RihtdCk/dXIodnQsITEpOnFyLGooZSxcIk5ld0V4cHJlc3Npb25cIil9ZnVuY3Rpb24gaXIoKXt2YXIgZT1xKCkscj0hMCxuPSExO2ZvcihlLnByb3BlcnRpZXM9W10sVSgpOyFGKGh0KTspe2lmKHIpcj0hMTtlbHNlIGlmKHooYnQpLGZyLmFsbG93VHJhaWxpbmdDb21tYXMmJkYoaHQpKWJyZWFrO3ZhciBhLG89e2tleTpzcigpfSxpPSExO2lmKEYoZ3QpPyhvLnZhbHVlPUsoITApLGE9by5raW5kPVwiaW5pdFwiKTpmci5lY21hVmVyc2lvbj49NSYmXCJJZGVudGlmaWVyXCI9PT1vLmtleS50eXBlJiYoXCJnZXRcIj09PW8ua2V5Lm5hbWV8fFwic2V0XCI9PT1vLmtleS5uYW1lKT8oaT1uPSEwLGE9by5raW5kPW8ua2V5Lm5hbWUsby5rZXk9c3IoKSx3ciE9PW10JiZYKCksby52YWx1ZT1jcihxKCksITEpKTpYKCksXCJJZGVudGlmaWVyXCI9PT1vLmtleS50eXBlJiYoVHJ8fG4pKWZvcih2YXIgcz0wO3M8ZS5wcm9wZXJ0aWVzLmxlbmd0aDsrK3Mpe3ZhciBjPWUucHJvcGVydGllc1tzXTtpZihjLmtleS5uYW1lPT09by5rZXkubmFtZSl7dmFyIHU9YT09Yy5raW5kfHxpJiZcImluaXRcIj09PWMua2luZHx8XCJpbml0XCI9PT1hJiYoXCJnZXRcIj09PWMua2luZHx8XCJzZXRcIj09PWMua2luZCk7dSYmIVRyJiZcImluaXRcIj09PWEmJlwiaW5pdFwiPT09Yy5raW5kJiYodT0hMSksdSYmdChvLmtleS5zdGFydCxcIlJlZGVmaW5pdGlvbiBvZiBwcm9wZXJ0eVwiKX19ZS5wcm9wZXJ0aWVzLnB1c2gobyl9cmV0dXJuIGooZSxcIk9iamVjdEV4cHJlc3Npb25cIil9ZnVuY3Rpb24gc3IoKXtyZXR1cm4gd3I9PT1Pcnx8d3I9PT1Ecj9hcigpOmxyKCEwKX1mdW5jdGlvbiBjcihlLHIpe3dyPT09RnI/ZS5pZD1scigpOnI/WCgpOmUuaWQ9bnVsbCxlLnBhcmFtcz1bXTt2YXIgbj0hMDtmb3IoeihtdCk7IUYodnQpOyluP249ITE6eihidCksZS5wYXJhbXMucHVzaChscigpKTt2YXIgYT1ScixvPVZyO2lmKFJyPSEwLFZyPVtdLGUuYm9keT1IKCEwKSxScj1hLFZyPW8sVHJ8fGUuYm9keS5ib2R5Lmxlbmd0aCYmRChlLmJvZHkuYm9keVswXSkpZm9yKHZhciBpPWUuaWQ/LTE6MDtpPGUucGFyYW1zLmxlbmd0aDsrK2kpe3ZhciBzPTA+aT9lLmlkOmUucGFyYW1zW2ldO2lmKChYdChzLm5hbWUpfHxOdChzLm5hbWUpKSYmdChzLnN0YXJ0LFwiRGVmaW5pbmcgJ1wiK3MubmFtZStcIicgaW4gc3RyaWN0IG1vZGVcIiksaT49MClmb3IodmFyIGM9MDtpPmM7KytjKXMubmFtZT09PWUucGFyYW1zW2NdLm5hbWUmJnQocy5zdGFydCxcIkFyZ3VtZW50IG5hbWUgY2xhc2ggaW4gc3RyaWN0IG1vZGVcIil9cmV0dXJuIGooZSxyP1wiRnVuY3Rpb25EZWNsYXJhdGlvblwiOlwiRnVuY3Rpb25FeHByZXNzaW9uXCIpfWZ1bmN0aW9uIHVyKGUscix0KXtmb3IodmFyIG49W10sYT0hMDshRihlKTspe2lmKGEpYT0hMTtlbHNlIGlmKHooYnQpLHImJmZyLmFsbG93VHJhaWxpbmdDb21tYXMmJkYoZSkpYnJlYWs7dCYmd3I9PT1idD9uLnB1c2gobnVsbCk6bi5wdXNoKEsoITApKX1yZXR1cm4gbn1mdW5jdGlvbiBscihlKXt2YXIgcj1xKCk7cmV0dXJuIHIubmFtZT13cj09PUZyP0NyOmUmJiFmci5mb3JiaWRSZXNlcnZlZCYmd3Iua2V5d29yZHx8WCgpLEVyPSExLFUoKSxqKHIsXCJJZGVudGlmaWVyXCIpfWUudmVyc2lvbj1cIjAuNC4wXCI7dmFyIGZyLGRyLHByLGhyO2UucGFyc2U9ZnVuY3Rpb24oZSx0KXtyZXR1cm4gZHI9U3RyaW5nKGUpLHByPWRyLmxlbmd0aCxyKHQpLG8oKSxXKGZyLnByb2dyYW0pfTt2YXIgbXI9ZS5kZWZhdWx0T3B0aW9ucz17ZWNtYVZlcnNpb246NSxzdHJpY3RTZW1pY29sb25zOiExLGFsbG93VHJhaWxpbmdDb21tYXM6ITAsZm9yYmlkUmVzZXJ2ZWQ6ITEsbG9jYXRpb25zOiExLG9uQ29tbWVudDpudWxsLHJhbmdlczohMSxwcm9ncmFtOm51bGwsc291cmNlRmlsZTpudWxsfSx2cj1lLmdldExpbmVJbmZvPWZ1bmN0aW9uKGUscil7Zm9yKHZhciB0PTEsbj0wOzspe0t0Lmxhc3RJbmRleD1uO3ZhciBhPUt0LmV4ZWMoZSk7aWYoIShhJiZhLmluZGV4PHIpKWJyZWFrOysrdCxuPWEuaW5kZXgrYVswXS5sZW5ndGh9cmV0dXJue2xpbmU6dCxjb2x1bW46ci1ufX07ZS50b2tlbml6ZT1mdW5jdGlvbihlLHQpe2Z1bmN0aW9uIG4oZSl7cmV0dXJuIGcoZSksYS5zdGFydD15cixhLmVuZD1ncixhLnN0YXJ0TG9jPXhyLGEuZW5kTG9jPWtyLGEudHlwZT13cixhLnZhbHVlPUNyLGF9ZHI9U3RyaW5nKGUpLHByPWRyLmxlbmd0aCxyKHQpLG8oKTt2YXIgYT17fTtyZXR1cm4gbi5qdW1wVG89ZnVuY3Rpb24oZSxyKXtpZihicj1lLGZyLmxvY2F0aW9ucyl7QXI9MSxTcj1LdC5sYXN0SW5kZXg9MDtmb3IodmFyIHQ7KHQ9S3QuZXhlYyhkcikpJiZ0LmluZGV4PGU7KSsrQXIsU3I9dC5pbmRleCt0WzBdLmxlbmd0aH1Fcj1yLHUoKX0sbn07dmFyIGJyLHlyLGdyLHhyLGtyLHdyLENyLEVyLEFyLFNyLElyLExyLFVyLFJyLFZyLFRyLHFyPVtdLE9yPXt0eXBlOlwibnVtXCJ9LGpyPXt0eXBlOlwicmVnZXhwXCJ9LERyPXt0eXBlOlwic3RyaW5nXCJ9LEZyPXt0eXBlOlwibmFtZVwifSxCcj17dHlwZTpcImVvZlwifSxNcj17a2V5d29yZDpcImJyZWFrXCJ9LHpyPXtrZXl3b3JkOlwiY2FzZVwiLGJlZm9yZUV4cHI6ITB9LFhyPXtrZXl3b3JkOlwiY2F0Y2hcIn0sTnI9e2tleXdvcmQ6XCJjb250aW51ZVwifSxXcj17a2V5d29yZDpcImRlYnVnZ2VyXCJ9LEpyPXtrZXl3b3JkOlwiZGVmYXVsdFwifSxQcj17a2V5d29yZDpcImRvXCIsaXNMb29wOiEwfSxIcj17a2V5d29yZDpcImVsc2VcIixiZWZvcmVFeHByOiEwfSwkcj17a2V5d29yZDpcImZpbmFsbHlcIn0sX3I9e2tleXdvcmQ6XCJmb3JcIixpc0xvb3A6ITB9LEdyPXtrZXl3b3JkOlwiZnVuY3Rpb25cIn0sS3I9e2tleXdvcmQ6XCJpZlwifSxRcj17a2V5d29yZDpcInJldHVyblwiLGJlZm9yZUV4cHI6ITB9LFlyPXtrZXl3b3JkOlwic3dpdGNoXCJ9LFpyPXtrZXl3b3JkOlwidGhyb3dcIixiZWZvcmVFeHByOiEwfSxldD17a2V5d29yZDpcInRyeVwifSxydD17a2V5d29yZDpcInZhclwifSx0dD17a2V5d29yZDpcIndoaWxlXCIsaXNMb29wOiEwfSxudD17a2V5d29yZDpcIndpdGhcIn0sYXQ9e2tleXdvcmQ6XCJuZXdcIixiZWZvcmVFeHByOiEwfSxvdD17a2V5d29yZDpcInRoaXNcIn0saXQ9e2tleXdvcmQ6XCJudWxsXCIsYXRvbVZhbHVlOm51bGx9LHN0PXtrZXl3b3JkOlwidHJ1ZVwiLGF0b21WYWx1ZTohMH0sY3Q9e2tleXdvcmQ6XCJmYWxzZVwiLGF0b21WYWx1ZTohMX0sdXQ9e2tleXdvcmQ6XCJpblwiLGJpbm9wOjcsYmVmb3JlRXhwcjohMH0sbHQ9e1wiYnJlYWtcIjpNcixcImNhc2VcIjp6cixcImNhdGNoXCI6WHIsXCJjb250aW51ZVwiOk5yLFwiZGVidWdnZXJcIjpXcixcImRlZmF1bHRcIjpKcixcImRvXCI6UHIsXCJlbHNlXCI6SHIsXCJmaW5hbGx5XCI6JHIsXCJmb3JcIjpfcixcImZ1bmN0aW9uXCI6R3IsXCJpZlwiOktyLFwicmV0dXJuXCI6UXIsXCJzd2l0Y2hcIjpZcixcInRocm93XCI6WnIsXCJ0cnlcIjpldCxcInZhclwiOnJ0LFwid2hpbGVcIjp0dCxcIndpdGhcIjpudCxcIm51bGxcIjppdCxcInRydWVcIjpzdCxcImZhbHNlXCI6Y3QsXCJuZXdcIjphdCxcImluXCI6dXQsXCJpbnN0YW5jZW9mXCI6e2tleXdvcmQ6XCJpbnN0YW5jZW9mXCIsYmlub3A6NyxiZWZvcmVFeHByOiEwfSxcInRoaXNcIjpvdCxcInR5cGVvZlwiOntrZXl3b3JkOlwidHlwZW9mXCIscHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9LFwidm9pZFwiOntrZXl3b3JkOlwidm9pZFwiLHByZWZpeDohMCxiZWZvcmVFeHByOiEwfSxcImRlbGV0ZVwiOntrZXl3b3JkOlwiZGVsZXRlXCIscHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9fSxmdD17dHlwZTpcIltcIixiZWZvcmVFeHByOiEwfSxkdD17dHlwZTpcIl1cIn0scHQ9e3R5cGU6XCJ7XCIsYmVmb3JlRXhwcjohMH0saHQ9e3R5cGU6XCJ9XCJ9LG10PXt0eXBlOlwiKFwiLGJlZm9yZUV4cHI6ITB9LHZ0PXt0eXBlOlwiKVwifSxidD17dHlwZTpcIixcIixiZWZvcmVFeHByOiEwfSx5dD17dHlwZTpcIjtcIixiZWZvcmVFeHByOiEwfSxndD17dHlwZTpcIjpcIixiZWZvcmVFeHByOiEwfSx4dD17dHlwZTpcIi5cIn0sa3Q9e3R5cGU6XCI/XCIsYmVmb3JlRXhwcjohMH0sd3Q9e2Jpbm9wOjEwLGJlZm9yZUV4cHI6ITB9LEN0PXtpc0Fzc2lnbjohMCxiZWZvcmVFeHByOiEwfSxFdD17aXNBc3NpZ246ITAsYmVmb3JlRXhwcjohMH0sQXQ9e2Jpbm9wOjkscHJlZml4OiEwLGJlZm9yZUV4cHI6ITB9LFN0PXtwb3N0Zml4OiEwLHByZWZpeDohMCxpc1VwZGF0ZTohMH0sSXQ9e3ByZWZpeDohMCxiZWZvcmVFeHByOiEwfSxMdD17Ymlub3A6MSxiZWZvcmVFeHByOiEwfSxVdD17Ymlub3A6MixiZWZvcmVFeHByOiEwfSxSdD17Ymlub3A6MyxiZWZvcmVFeHByOiEwfSxWdD17Ymlub3A6NCxiZWZvcmVFeHByOiEwfSxUdD17Ymlub3A6NSxiZWZvcmVFeHByOiEwfSxxdD17Ymlub3A6NixiZWZvcmVFeHByOiEwfSxPdD17Ymlub3A6NyxiZWZvcmVFeHByOiEwfSxqdD17Ymlub3A6OCxiZWZvcmVFeHByOiEwfSxEdD17Ymlub3A6MTAsYmVmb3JlRXhwcjohMH07ZS50b2tUeXBlcz17YnJhY2tldEw6ZnQsYnJhY2tldFI6ZHQsYnJhY2VMOnB0LGJyYWNlUjpodCxwYXJlbkw6bXQscGFyZW5SOnZ0LGNvbW1hOmJ0LHNlbWk6eXQsY29sb246Z3QsZG90Onh0LHF1ZXN0aW9uOmt0LHNsYXNoOnd0LGVxOkN0LG5hbWU6RnIsZW9mOkJyLG51bTpPcixyZWdleHA6anIsc3RyaW5nOkRyfTtmb3IodmFyIEZ0IGluIGx0KWUudG9rVHlwZXNbXCJfXCIrRnRdPWx0W0Z0XTt2YXIgQnQsTXQ9bihcImFic3RyYWN0IGJvb2xlYW4gYnl0ZSBjaGFyIGNsYXNzIGRvdWJsZSBlbnVtIGV4cG9ydCBleHRlbmRzIGZpbmFsIGZsb2F0IGdvdG8gaW1wbGVtZW50cyBpbXBvcnQgaW50IGludGVyZmFjZSBsb25nIG5hdGl2ZSBwYWNrYWdlIHByaXZhdGUgcHJvdGVjdGVkIHB1YmxpYyBzaG9ydCBzdGF0aWMgc3VwZXIgc3luY2hyb25pemVkIHRocm93cyB0cmFuc2llbnQgdm9sYXRpbGVcIiksenQ9bihcImNsYXNzIGVudW0gZXh0ZW5kcyBzdXBlciBjb25zdCBleHBvcnQgaW1wb3J0XCIpLFh0PW4oXCJpbXBsZW1lbnRzIGludGVyZmFjZSBsZXQgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc3RhdGljIHlpZWxkXCIpLE50PW4oXCJldmFsIGFyZ3VtZW50c1wiKSxXdD1uKFwiYnJlYWsgY2FzZSBjYXRjaCBjb250aW51ZSBkZWJ1Z2dlciBkZWZhdWx0IGRvIGVsc2UgZmluYWxseSBmb3IgZnVuY3Rpb24gaWYgcmV0dXJuIHN3aXRjaCB0aHJvdyB0cnkgdmFyIHdoaWxlIHdpdGggbnVsbCB0cnVlIGZhbHNlIGluc3RhbmNlb2YgdHlwZW9mIHZvaWQgZGVsZXRlIG5ldyBpbiB0aGlzXCIpLEp0PS9bXFx1MTY4MFxcdTE4MGVcXHUyMDAwLVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXHVmZWZmXS8sUHQ9XCJcXHhhYVxceGI1XFx4YmFcXHhjMC1cXHhkNlxceGQ4LVxceGY2XFx4ZjgtXFx1MDJjMVxcdTAyYzYtXFx1MDJkMVxcdTAyZTAtXFx1MDJlNFxcdTAyZWNcXHUwMmVlXFx1MDM3MC1cXHUwMzc0XFx1MDM3NlxcdTAzNzdcXHUwMzdhLVxcdTAzN2RcXHUwMzg2XFx1MDM4OC1cXHUwMzhhXFx1MDM4Y1xcdTAzOGUtXFx1MDNhMVxcdTAzYTMtXFx1MDNmNVxcdTAzZjctXFx1MDQ4MVxcdTA0OGEtXFx1MDUyN1xcdTA1MzEtXFx1MDU1NlxcdTA1NTlcXHUwNTYxLVxcdTA1ODdcXHUwNWQwLVxcdTA1ZWFcXHUwNWYwLVxcdTA1ZjJcXHUwNjIwLVxcdTA2NGFcXHUwNjZlXFx1MDY2ZlxcdTA2NzEtXFx1MDZkM1xcdTA2ZDVcXHUwNmU1XFx1MDZlNlxcdTA2ZWVcXHUwNmVmXFx1MDZmYS1cXHUwNmZjXFx1MDZmZlxcdTA3MTBcXHUwNzEyLVxcdTA3MmZcXHUwNzRkLVxcdTA3YTVcXHUwN2IxXFx1MDdjYS1cXHUwN2VhXFx1MDdmNFxcdTA3ZjVcXHUwN2ZhXFx1MDgwMC1cXHUwODE1XFx1MDgxYVxcdTA4MjRcXHUwODI4XFx1MDg0MC1cXHUwODU4XFx1MDhhMFxcdTA4YTItXFx1MDhhY1xcdTA5MDQtXFx1MDkzOVxcdTA5M2RcXHUwOTUwXFx1MDk1OC1cXHUwOTYxXFx1MDk3MS1cXHUwOTc3XFx1MDk3OS1cXHUwOTdmXFx1MDk4NS1cXHUwOThjXFx1MDk4ZlxcdTA5OTBcXHUwOTkzLVxcdTA5YThcXHUwOWFhLVxcdTA5YjBcXHUwOWIyXFx1MDliNi1cXHUwOWI5XFx1MDliZFxcdTA5Y2VcXHUwOWRjXFx1MDlkZFxcdTA5ZGYtXFx1MDllMVxcdTA5ZjBcXHUwOWYxXFx1MGEwNS1cXHUwYTBhXFx1MGEwZlxcdTBhMTBcXHUwYTEzLVxcdTBhMjhcXHUwYTJhLVxcdTBhMzBcXHUwYTMyXFx1MGEzM1xcdTBhMzVcXHUwYTM2XFx1MGEzOFxcdTBhMzlcXHUwYTU5LVxcdTBhNWNcXHUwYTVlXFx1MGE3Mi1cXHUwYTc0XFx1MGE4NS1cXHUwYThkXFx1MGE4Zi1cXHUwYTkxXFx1MGE5My1cXHUwYWE4XFx1MGFhYS1cXHUwYWIwXFx1MGFiMlxcdTBhYjNcXHUwYWI1LVxcdTBhYjlcXHUwYWJkXFx1MGFkMFxcdTBhZTBcXHUwYWUxXFx1MGIwNS1cXHUwYjBjXFx1MGIwZlxcdTBiMTBcXHUwYjEzLVxcdTBiMjhcXHUwYjJhLVxcdTBiMzBcXHUwYjMyXFx1MGIzM1xcdTBiMzUtXFx1MGIzOVxcdTBiM2RcXHUwYjVjXFx1MGI1ZFxcdTBiNWYtXFx1MGI2MVxcdTBiNzFcXHUwYjgzXFx1MGI4NS1cXHUwYjhhXFx1MGI4ZS1cXHUwYjkwXFx1MGI5Mi1cXHUwYjk1XFx1MGI5OVxcdTBiOWFcXHUwYjljXFx1MGI5ZVxcdTBiOWZcXHUwYmEzXFx1MGJhNFxcdTBiYTgtXFx1MGJhYVxcdTBiYWUtXFx1MGJiOVxcdTBiZDBcXHUwYzA1LVxcdTBjMGNcXHUwYzBlLVxcdTBjMTBcXHUwYzEyLVxcdTBjMjhcXHUwYzJhLVxcdTBjMzNcXHUwYzM1LVxcdTBjMzlcXHUwYzNkXFx1MGM1OFxcdTBjNTlcXHUwYzYwXFx1MGM2MVxcdTBjODUtXFx1MGM4Y1xcdTBjOGUtXFx1MGM5MFxcdTBjOTItXFx1MGNhOFxcdTBjYWEtXFx1MGNiM1xcdTBjYjUtXFx1MGNiOVxcdTBjYmRcXHUwY2RlXFx1MGNlMFxcdTBjZTFcXHUwY2YxXFx1MGNmMlxcdTBkMDUtXFx1MGQwY1xcdTBkMGUtXFx1MGQxMFxcdTBkMTItXFx1MGQzYVxcdTBkM2RcXHUwZDRlXFx1MGQ2MFxcdTBkNjFcXHUwZDdhLVxcdTBkN2ZcXHUwZDg1LVxcdTBkOTZcXHUwZDlhLVxcdTBkYjFcXHUwZGIzLVxcdTBkYmJcXHUwZGJkXFx1MGRjMC1cXHUwZGM2XFx1MGUwMS1cXHUwZTMwXFx1MGUzMlxcdTBlMzNcXHUwZTQwLVxcdTBlNDZcXHUwZTgxXFx1MGU4MlxcdTBlODRcXHUwZTg3XFx1MGU4OFxcdTBlOGFcXHUwZThkXFx1MGU5NC1cXHUwZTk3XFx1MGU5OS1cXHUwZTlmXFx1MGVhMS1cXHUwZWEzXFx1MGVhNVxcdTBlYTdcXHUwZWFhXFx1MGVhYlxcdTBlYWQtXFx1MGViMFxcdTBlYjJcXHUwZWIzXFx1MGViZFxcdTBlYzAtXFx1MGVjNFxcdTBlYzZcXHUwZWRjLVxcdTBlZGZcXHUwZjAwXFx1MGY0MC1cXHUwZjQ3XFx1MGY0OS1cXHUwZjZjXFx1MGY4OC1cXHUwZjhjXFx1MTAwMC1cXHUxMDJhXFx1MTAzZlxcdTEwNTAtXFx1MTA1NVxcdTEwNWEtXFx1MTA1ZFxcdTEwNjFcXHUxMDY1XFx1MTA2NlxcdTEwNmUtXFx1MTA3MFxcdTEwNzUtXFx1MTA4MVxcdTEwOGVcXHUxMGEwLVxcdTEwYzVcXHUxMGM3XFx1MTBjZFxcdTEwZDAtXFx1MTBmYVxcdTEwZmMtXFx1MTI0OFxcdTEyNGEtXFx1MTI0ZFxcdTEyNTAtXFx1MTI1NlxcdTEyNThcXHUxMjVhLVxcdTEyNWRcXHUxMjYwLVxcdTEyODhcXHUxMjhhLVxcdTEyOGRcXHUxMjkwLVxcdTEyYjBcXHUxMmIyLVxcdTEyYjVcXHUxMmI4LVxcdTEyYmVcXHUxMmMwXFx1MTJjMi1cXHUxMmM1XFx1MTJjOC1cXHUxMmQ2XFx1MTJkOC1cXHUxMzEwXFx1MTMxMi1cXHUxMzE1XFx1MTMxOC1cXHUxMzVhXFx1MTM4MC1cXHUxMzhmXFx1MTNhMC1cXHUxM2Y0XFx1MTQwMS1cXHUxNjZjXFx1MTY2Zi1cXHUxNjdmXFx1MTY4MS1cXHUxNjlhXFx1MTZhMC1cXHUxNmVhXFx1MTZlZS1cXHUxNmYwXFx1MTcwMC1cXHUxNzBjXFx1MTcwZS1cXHUxNzExXFx1MTcyMC1cXHUxNzMxXFx1MTc0MC1cXHUxNzUxXFx1MTc2MC1cXHUxNzZjXFx1MTc2ZS1cXHUxNzcwXFx1MTc4MC1cXHUxN2IzXFx1MTdkN1xcdTE3ZGNcXHUxODIwLVxcdTE4NzdcXHUxODgwLVxcdTE4YThcXHUxOGFhXFx1MThiMC1cXHUxOGY1XFx1MTkwMC1cXHUxOTFjXFx1MTk1MC1cXHUxOTZkXFx1MTk3MC1cXHUxOTc0XFx1MTk4MC1cXHUxOWFiXFx1MTljMS1cXHUxOWM3XFx1MWEwMC1cXHUxYTE2XFx1MWEyMC1cXHUxYTU0XFx1MWFhN1xcdTFiMDUtXFx1MWIzM1xcdTFiNDUtXFx1MWI0YlxcdTFiODMtXFx1MWJhMFxcdTFiYWVcXHUxYmFmXFx1MWJiYS1cXHUxYmU1XFx1MWMwMC1cXHUxYzIzXFx1MWM0ZC1cXHUxYzRmXFx1MWM1YS1cXHUxYzdkXFx1MWNlOS1cXHUxY2VjXFx1MWNlZS1cXHUxY2YxXFx1MWNmNVxcdTFjZjZcXHUxZDAwLVxcdTFkYmZcXHUxZTAwLVxcdTFmMTVcXHUxZjE4LVxcdTFmMWRcXHUxZjIwLVxcdTFmNDVcXHUxZjQ4LVxcdTFmNGRcXHUxZjUwLVxcdTFmNTdcXHUxZjU5XFx1MWY1YlxcdTFmNWRcXHUxZjVmLVxcdTFmN2RcXHUxZjgwLVxcdTFmYjRcXHUxZmI2LVxcdTFmYmNcXHUxZmJlXFx1MWZjMi1cXHUxZmM0XFx1MWZjNi1cXHUxZmNjXFx1MWZkMC1cXHUxZmQzXFx1MWZkNi1cXHUxZmRiXFx1MWZlMC1cXHUxZmVjXFx1MWZmMi1cXHUxZmY0XFx1MWZmNi1cXHUxZmZjXFx1MjA3MVxcdTIwN2ZcXHUyMDkwLVxcdTIwOWNcXHUyMTAyXFx1MjEwN1xcdTIxMGEtXFx1MjExM1xcdTIxMTVcXHUyMTE5LVxcdTIxMWRcXHUyMTI0XFx1MjEyNlxcdTIxMjhcXHUyMTJhLVxcdTIxMmRcXHUyMTJmLVxcdTIxMzlcXHUyMTNjLVxcdTIxM2ZcXHUyMTQ1LVxcdTIxNDlcXHUyMTRlXFx1MjE2MC1cXHUyMTg4XFx1MmMwMC1cXHUyYzJlXFx1MmMzMC1cXHUyYzVlXFx1MmM2MC1cXHUyY2U0XFx1MmNlYi1cXHUyY2VlXFx1MmNmMlxcdTJjZjNcXHUyZDAwLVxcdTJkMjVcXHUyZDI3XFx1MmQyZFxcdTJkMzAtXFx1MmQ2N1xcdTJkNmZcXHUyZDgwLVxcdTJkOTZcXHUyZGEwLVxcdTJkYTZcXHUyZGE4LVxcdTJkYWVcXHUyZGIwLVxcdTJkYjZcXHUyZGI4LVxcdTJkYmVcXHUyZGMwLVxcdTJkYzZcXHUyZGM4LVxcdTJkY2VcXHUyZGQwLVxcdTJkZDZcXHUyZGQ4LVxcdTJkZGVcXHUyZTJmXFx1MzAwNS1cXHUzMDA3XFx1MzAyMS1cXHUzMDI5XFx1MzAzMS1cXHUzMDM1XFx1MzAzOC1cXHUzMDNjXFx1MzA0MS1cXHUzMDk2XFx1MzA5ZC1cXHUzMDlmXFx1MzBhMS1cXHUzMGZhXFx1MzBmYy1cXHUzMGZmXFx1MzEwNS1cXHUzMTJkXFx1MzEzMS1cXHUzMThlXFx1MzFhMC1cXHUzMWJhXFx1MzFmMC1cXHUzMWZmXFx1MzQwMC1cXHU0ZGI1XFx1NGUwMC1cXHU5ZmNjXFx1YTAwMC1cXHVhNDhjXFx1YTRkMC1cXHVhNGZkXFx1YTUwMC1cXHVhNjBjXFx1YTYxMC1cXHVhNjFmXFx1YTYyYVxcdWE2MmJcXHVhNjQwLVxcdWE2NmVcXHVhNjdmLVxcdWE2OTdcXHVhNmEwLVxcdWE2ZWZcXHVhNzE3LVxcdWE3MWZcXHVhNzIyLVxcdWE3ODhcXHVhNzhiLVxcdWE3OGVcXHVhNzkwLVxcdWE3OTNcXHVhN2EwLVxcdWE3YWFcXHVhN2Y4LVxcdWE4MDFcXHVhODAzLVxcdWE4MDVcXHVhODA3LVxcdWE4MGFcXHVhODBjLVxcdWE4MjJcXHVhODQwLVxcdWE4NzNcXHVhODgyLVxcdWE4YjNcXHVhOGYyLVxcdWE4ZjdcXHVhOGZiXFx1YTkwYS1cXHVhOTI1XFx1YTkzMC1cXHVhOTQ2XFx1YTk2MC1cXHVhOTdjXFx1YTk4NC1cXHVhOWIyXFx1YTljZlxcdWFhMDAtXFx1YWEyOFxcdWFhNDAtXFx1YWE0MlxcdWFhNDQtXFx1YWE0YlxcdWFhNjAtXFx1YWE3NlxcdWFhN2FcXHVhYTgwLVxcdWFhYWZcXHVhYWIxXFx1YWFiNVxcdWFhYjZcXHVhYWI5LVxcdWFhYmRcXHVhYWMwXFx1YWFjMlxcdWFhZGItXFx1YWFkZFxcdWFhZTAtXFx1YWFlYVxcdWFhZjItXFx1YWFmNFxcdWFiMDEtXFx1YWIwNlxcdWFiMDktXFx1YWIwZVxcdWFiMTEtXFx1YWIxNlxcdWFiMjAtXFx1YWIyNlxcdWFiMjgtXFx1YWIyZVxcdWFiYzAtXFx1YWJlMlxcdWFjMDAtXFx1ZDdhM1xcdWQ3YjAtXFx1ZDdjNlxcdWQ3Y2ItXFx1ZDdmYlxcdWY5MDAtXFx1ZmE2ZFxcdWZhNzAtXFx1ZmFkOVxcdWZiMDAtXFx1ZmIwNlxcdWZiMTMtXFx1ZmIxN1xcdWZiMWRcXHVmYjFmLVxcdWZiMjhcXHVmYjJhLVxcdWZiMzZcXHVmYjM4LVxcdWZiM2NcXHVmYjNlXFx1ZmI0MFxcdWZiNDFcXHVmYjQzXFx1ZmI0NFxcdWZiNDYtXFx1ZmJiMVxcdWZiZDMtXFx1ZmQzZFxcdWZkNTAtXFx1ZmQ4ZlxcdWZkOTItXFx1ZmRjN1xcdWZkZjAtXFx1ZmRmYlxcdWZlNzAtXFx1ZmU3NFxcdWZlNzYtXFx1ZmVmY1xcdWZmMjEtXFx1ZmYzYVxcdWZmNDEtXFx1ZmY1YVxcdWZmNjYtXFx1ZmZiZVxcdWZmYzItXFx1ZmZjN1xcdWZmY2EtXFx1ZmZjZlxcdWZmZDItXFx1ZmZkN1xcdWZmZGEtXFx1ZmZkY1wiLEh0PVwiXFx1MDMwMC1cXHUwMzZmXFx1MDQ4My1cXHUwNDg3XFx1MDU5MS1cXHUwNWJkXFx1MDViZlxcdTA1YzFcXHUwNWMyXFx1MDVjNFxcdTA1YzVcXHUwNWM3XFx1MDYxMC1cXHUwNjFhXFx1MDYyMC1cXHUwNjQ5XFx1MDY3Mi1cXHUwNmQzXFx1MDZlNy1cXHUwNmU4XFx1MDZmYi1cXHUwNmZjXFx1MDczMC1cXHUwNzRhXFx1MDgwMC1cXHUwODE0XFx1MDgxYi1cXHUwODIzXFx1MDgyNS1cXHUwODI3XFx1MDgyOS1cXHUwODJkXFx1MDg0MC1cXHUwODU3XFx1MDhlNC1cXHUwOGZlXFx1MDkwMC1cXHUwOTAzXFx1MDkzYS1cXHUwOTNjXFx1MDkzZS1cXHUwOTRmXFx1MDk1MS1cXHUwOTU3XFx1MDk2Mi1cXHUwOTYzXFx1MDk2Ni1cXHUwOTZmXFx1MDk4MS1cXHUwOTgzXFx1MDliY1xcdTA5YmUtXFx1MDljNFxcdTA5YzdcXHUwOWM4XFx1MDlkN1xcdTA5ZGYtXFx1MDllMFxcdTBhMDEtXFx1MGEwM1xcdTBhM2NcXHUwYTNlLVxcdTBhNDJcXHUwYTQ3XFx1MGE0OFxcdTBhNGItXFx1MGE0ZFxcdTBhNTFcXHUwYTY2LVxcdTBhNzFcXHUwYTc1XFx1MGE4MS1cXHUwYTgzXFx1MGFiY1xcdTBhYmUtXFx1MGFjNVxcdTBhYzctXFx1MGFjOVxcdTBhY2ItXFx1MGFjZFxcdTBhZTItXFx1MGFlM1xcdTBhZTYtXFx1MGFlZlxcdTBiMDEtXFx1MGIwM1xcdTBiM2NcXHUwYjNlLVxcdTBiNDRcXHUwYjQ3XFx1MGI0OFxcdTBiNGItXFx1MGI0ZFxcdTBiNTZcXHUwYjU3XFx1MGI1Zi1cXHUwYjYwXFx1MGI2Ni1cXHUwYjZmXFx1MGI4MlxcdTBiYmUtXFx1MGJjMlxcdTBiYzYtXFx1MGJjOFxcdTBiY2EtXFx1MGJjZFxcdTBiZDdcXHUwYmU2LVxcdTBiZWZcXHUwYzAxLVxcdTBjMDNcXHUwYzQ2LVxcdTBjNDhcXHUwYzRhLVxcdTBjNGRcXHUwYzU1XFx1MGM1NlxcdTBjNjItXFx1MGM2M1xcdTBjNjYtXFx1MGM2ZlxcdTBjODJcXHUwYzgzXFx1MGNiY1xcdTBjYmUtXFx1MGNjNFxcdTBjYzYtXFx1MGNjOFxcdTBjY2EtXFx1MGNjZFxcdTBjZDVcXHUwY2Q2XFx1MGNlMi1cXHUwY2UzXFx1MGNlNi1cXHUwY2VmXFx1MGQwMlxcdTBkMDNcXHUwZDQ2LVxcdTBkNDhcXHUwZDU3XFx1MGQ2Mi1cXHUwZDYzXFx1MGQ2Ni1cXHUwZDZmXFx1MGQ4MlxcdTBkODNcXHUwZGNhXFx1MGRjZi1cXHUwZGQ0XFx1MGRkNlxcdTBkZDgtXFx1MGRkZlxcdTBkZjJcXHUwZGYzXFx1MGUzNC1cXHUwZTNhXFx1MGU0MC1cXHUwZTQ1XFx1MGU1MC1cXHUwZTU5XFx1MGViNC1cXHUwZWI5XFx1MGVjOC1cXHUwZWNkXFx1MGVkMC1cXHUwZWQ5XFx1MGYxOFxcdTBmMTlcXHUwZjIwLVxcdTBmMjlcXHUwZjM1XFx1MGYzN1xcdTBmMzlcXHUwZjQxLVxcdTBmNDdcXHUwZjcxLVxcdTBmODRcXHUwZjg2LVxcdTBmODdcXHUwZjhkLVxcdTBmOTdcXHUwZjk5LVxcdTBmYmNcXHUwZmM2XFx1MTAwMC1cXHUxMDI5XFx1MTA0MC1cXHUxMDQ5XFx1MTA2Ny1cXHUxMDZkXFx1MTA3MS1cXHUxMDc0XFx1MTA4Mi1cXHUxMDhkXFx1MTA4Zi1cXHUxMDlkXFx1MTM1ZC1cXHUxMzVmXFx1MTcwZS1cXHUxNzEwXFx1MTcyMC1cXHUxNzMwXFx1MTc0MC1cXHUxNzUwXFx1MTc3MlxcdTE3NzNcXHUxNzgwLVxcdTE3YjJcXHUxN2RkXFx1MTdlMC1cXHUxN2U5XFx1MTgwYi1cXHUxODBkXFx1MTgxMC1cXHUxODE5XFx1MTkyMC1cXHUxOTJiXFx1MTkzMC1cXHUxOTNiXFx1MTk1MS1cXHUxOTZkXFx1MTliMC1cXHUxOWMwXFx1MTljOC1cXHUxOWM5XFx1MTlkMC1cXHUxOWQ5XFx1MWEwMC1cXHUxYTE1XFx1MWEyMC1cXHUxYTUzXFx1MWE2MC1cXHUxYTdjXFx1MWE3Zi1cXHUxYTg5XFx1MWE5MC1cXHUxYTk5XFx1MWI0Ni1cXHUxYjRiXFx1MWI1MC1cXHUxYjU5XFx1MWI2Yi1cXHUxYjczXFx1MWJiMC1cXHUxYmI5XFx1MWJlNi1cXHUxYmYzXFx1MWMwMC1cXHUxYzIyXFx1MWM0MC1cXHUxYzQ5XFx1MWM1Yi1cXHUxYzdkXFx1MWNkMC1cXHUxY2QyXFx1MWQwMC1cXHUxZGJlXFx1MWUwMS1cXHUxZjE1XFx1MjAwY1xcdTIwMGRcXHUyMDNmXFx1MjA0MFxcdTIwNTRcXHUyMGQwLVxcdTIwZGNcXHUyMGUxXFx1MjBlNS1cXHUyMGYwXFx1MmQ4MS1cXHUyZDk2XFx1MmRlMC1cXHUyZGZmXFx1MzAyMS1cXHUzMDI4XFx1MzA5OVxcdTMwOWFcXHVhNjQwLVxcdWE2NmRcXHVhNjc0LVxcdWE2N2RcXHVhNjlmXFx1YTZmMC1cXHVhNmYxXFx1YTdmOC1cXHVhODAwXFx1YTgwNlxcdWE4MGJcXHVhODIzLVxcdWE4MjdcXHVhODgwLVxcdWE4ODFcXHVhOGI0LVxcdWE4YzRcXHVhOGQwLVxcdWE4ZDlcXHVhOGYzLVxcdWE4ZjdcXHVhOTAwLVxcdWE5MDlcXHVhOTI2LVxcdWE5MmRcXHVhOTMwLVxcdWE5NDVcXHVhOTgwLVxcdWE5ODNcXHVhOWIzLVxcdWE5YzBcXHVhYTAwLVxcdWFhMjdcXHVhYTQwLVxcdWFhNDFcXHVhYTRjLVxcdWFhNGRcXHVhYTUwLVxcdWFhNTlcXHVhYTdiXFx1YWFlMC1cXHVhYWU5XFx1YWFmMi1cXHVhYWYzXFx1YWJjMC1cXHVhYmUxXFx1YWJlY1xcdWFiZWRcXHVhYmYwLVxcdWFiZjlcXHVmYjIwLVxcdWZiMjhcXHVmZTAwLVxcdWZlMGZcXHVmZTIwLVxcdWZlMjZcXHVmZTMzXFx1ZmUzNFxcdWZlNGQtXFx1ZmU0ZlxcdWZmMTAtXFx1ZmYxOVxcdWZmM2ZcIiwkdD1uZXcgUmVnRXhwKFwiW1wiK1B0K1wiXVwiKSxfdD1uZXcgUmVnRXhwKFwiW1wiK1B0K0h0K1wiXVwiKSxHdD0vW1xcblxcclxcdTIwMjhcXHUyMDI5XS8sS3Q9L1xcclxcbnxbXFxuXFxyXFx1MjAyOFxcdTIwMjldL2csUXQ9ZS5pc0lkZW50aWZpZXJTdGFydD1mdW5jdGlvbihlKXtyZXR1cm4gNjU+ZT8zNj09PWU6OTE+ZT8hMDo5Nz5lPzk1PT09ZToxMjM+ZT8hMDplPj0xNzAmJiR0LnRlc3QoU3RyaW5nLmZyb21DaGFyQ29kZShlKSl9LFl0PWUuaXNJZGVudGlmaWVyQ2hhcj1mdW5jdGlvbihlKXtyZXR1cm4gNDg+ZT8zNj09PWU6NTg+ZT8hMDo2NT5lPyExOjkxPmU/ITA6OTc+ZT85NT09PWU6MTIzPmU/ITA6ZT49MTcwJiZfdC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpfSxadD17a2luZDpcImxvb3BcIn0sZW49e2tpbmQ6XCJzd2l0Y2hcIn19KTtcblxuXHR2YXIgYmluYXJ5T3BlcmF0b3JzID0ge1xuXHRcdCcrJzogJ19fYWRkJyxcblx0XHQnLSc6ICdfX3N1YnRyYWN0Jyxcblx0XHQnKic6ICdfX211bHRpcGx5Jyxcblx0XHQnLyc6ICdfX2RpdmlkZScsXG5cdFx0JyUnOiAnX19tb2R1bG8nLFxuXHRcdCc9PSc6ICdlcXVhbHMnLFxuXHRcdCchPSc6ICdlcXVhbHMnXG5cdH07XG5cblx0dmFyIHVuYXJ5T3BlcmF0b3JzID0ge1xuXHRcdCctJzogJ19fbmVnYXRlJyxcblx0XHQnKyc6IG51bGxcblx0fTtcblxuXHR2YXIgZmllbGRzID0gQmFzZS5lYWNoKFxuXHRcdFsnYWRkJywgJ3N1YnRyYWN0JywgJ211bHRpcGx5JywgJ2RpdmlkZScsICdtb2R1bG8nLCAnbmVnYXRlJ10sXG5cdFx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dGhpc1snX18nICsgbmFtZV0gPSAnIycgKyBuYW1lO1xuXHRcdH0sXG5cdFx0e31cblx0KTtcblx0UG9pbnQuaW5qZWN0KGZpZWxkcyk7XG5cdFNpemUuaW5qZWN0KGZpZWxkcyk7XG5cdENvbG9yLmluamVjdChmaWVsZHMpO1xuXG5cdGZ1bmN0aW9uIF9fJF9fKGxlZnQsIG9wZXJhdG9yLCByaWdodCkge1xuXHRcdHZhciBoYW5kbGVyID0gYmluYXJ5T3BlcmF0b3JzW29wZXJhdG9yXTtcblx0XHRpZiAobGVmdCAmJiBsZWZ0W2hhbmRsZXJdKSB7XG5cdFx0XHR2YXIgcmVzID0gbGVmdFtoYW5kbGVyXShyaWdodCk7XG5cdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09ICchPScgPyAhcmVzIDogcmVzO1xuXHRcdH1cblx0XHRzd2l0Y2ggKG9wZXJhdG9yKSB7XG5cdFx0Y2FzZSAnKyc6IHJldHVybiBsZWZ0ICsgcmlnaHQ7XG5cdFx0Y2FzZSAnLSc6IHJldHVybiBsZWZ0IC0gcmlnaHQ7XG5cdFx0Y2FzZSAnKic6IHJldHVybiBsZWZ0ICogcmlnaHQ7XG5cdFx0Y2FzZSAnLyc6IHJldHVybiBsZWZ0IC8gcmlnaHQ7XG5cdFx0Y2FzZSAnJSc6IHJldHVybiBsZWZ0ICUgcmlnaHQ7XG5cdFx0Y2FzZSAnPT0nOiByZXR1cm4gbGVmdCA9PSByaWdodDtcblx0XHRjYXNlICchPSc6IHJldHVybiBsZWZ0ICE9IHJpZ2h0O1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uICRfXyhvcGVyYXRvciwgdmFsdWUpIHtcblx0XHR2YXIgaGFuZGxlciA9IHVuYXJ5T3BlcmF0b3JzW29wZXJhdG9yXTtcblx0XHRpZiAoaGFuZGxlciAmJiB2YWx1ZSAmJiB2YWx1ZVtoYW5kbGVyXSlcblx0XHRcdHJldHVybiB2YWx1ZVtoYW5kbGVyXSgpO1xuXHRcdHN3aXRjaCAob3BlcmF0b3IpIHtcblx0XHRjYXNlICcrJzogcmV0dXJuICt2YWx1ZTtcblx0XHRjYXNlICctJzogcmV0dXJuIC12YWx1ZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBwYXJzZShjb2RlLCBvcHRpb25zKSB7XG5cdFx0cmV0dXJuIHNjb3BlLmFjb3JuLnBhcnNlKGNvZGUsIG9wdGlvbnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tcGlsZShjb2RlLCB1cmwsIG9wdGlvbnMpIHtcblx0XHRpZiAoIWNvZGUpXG5cdFx0XHRyZXR1cm4gJyc7XG5cdFx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cdFx0dXJsID0gdXJsIHx8ICcnO1xuXG5cdFx0dmFyIGluc2VydGlvbnMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGdldE9mZnNldChvZmZzZXQpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gaW5zZXJ0aW9ucy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGluc2VydGlvbiA9IGluc2VydGlvbnNbaV07XG5cdFx0XHRcdGlmIChpbnNlcnRpb25bMF0gPj0gb2Zmc2V0KVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRvZmZzZXQgKz0gaW5zZXJ0aW9uWzFdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9mZnNldDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRDb2RlKG5vZGUpIHtcblx0XHRcdHJldHVybiBjb2RlLnN1YnN0cmluZyhnZXRPZmZzZXQobm9kZS5yYW5nZVswXSksXG5cdFx0XHRcdFx0Z2V0T2Zmc2V0KG5vZGUucmFuZ2VbMV0pKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBnZXRCZXR3ZWVuKGxlZnQsIHJpZ2h0KSB7XG5cdFx0XHRyZXR1cm4gY29kZS5zdWJzdHJpbmcoZ2V0T2Zmc2V0KGxlZnQucmFuZ2VbMV0pLFxuXHRcdFx0XHRcdGdldE9mZnNldChyaWdodC5yYW5nZVswXSkpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHJlcGxhY2VDb2RlKG5vZGUsIHN0cikge1xuXHRcdFx0dmFyIHN0YXJ0ID0gZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMF0pLFxuXHRcdFx0XHRlbmQgPSBnZXRPZmZzZXQobm9kZS5yYW5nZVsxXSksXG5cdFx0XHRcdGluc2VydCA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5zZXJ0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0XHRpZiAoc3RhcnQgPiBpbnNlcnRpb25zW2ldWzBdKSB7XG5cdFx0XHRcdFx0aW5zZXJ0ID0gaSArIDE7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGluc2VydGlvbnMuc3BsaWNlKGluc2VydCwgMCwgW3N0YXJ0LCBzdHIubGVuZ3RoIC0gZW5kICsgc3RhcnRdKTtcblx0XHRcdGNvZGUgPSBjb2RlLnN1YnN0cmluZygwLCBzdGFydCkgKyBzdHIgKyBjb2RlLnN1YnN0cmluZyhlbmQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHdhbGtBU1Qobm9kZSwgcGFyZW50KSB7XG5cdFx0XHRpZiAoIW5vZGUpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGZvciAodmFyIGtleSBpbiBub2RlKSB7XG5cdFx0XHRcdGlmIChrZXkgPT09ICdyYW5nZScgfHwga2V5ID09PSAnbG9jJylcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0dmFyIHZhbHVlID0gbm9kZVtrZXldO1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHZhbHVlLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRcdHdhbGtBU1QodmFsdWVbaV0sIG5vZGUpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0XHR3YWxrQVNUKHZhbHVlLCBub2RlKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0c3dpdGNoIChub2RlLnR5cGUpIHtcblx0XHRcdGNhc2UgJ1VuYXJ5RXhwcmVzc2lvbic6XG5cdFx0XHRcdGlmIChub2RlLm9wZXJhdG9yIGluIHVuYXJ5T3BlcmF0b3JzXG5cdFx0XHRcdFx0XHQmJiBub2RlLmFyZ3VtZW50LnR5cGUgIT09ICdMaXRlcmFsJykge1xuXHRcdFx0XHRcdHZhciBhcmcgPSBnZXRDb2RlKG5vZGUuYXJndW1lbnQpO1xuXHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsICckX18oXCInICsgbm9kZS5vcGVyYXRvciArICdcIiwgJ1xuXHRcdFx0XHRcdFx0XHQrIGFyZyArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdCaW5hcnlFeHByZXNzaW9uJzpcblx0XHRcdFx0aWYgKG5vZGUub3BlcmF0b3IgaW4gYmluYXJ5T3BlcmF0b3JzXG5cdFx0XHRcdFx0XHQmJiBub2RlLmxlZnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0dmFyIGxlZnQgPSBnZXRDb2RlKG5vZGUubGVmdCksXG5cdFx0XHRcdFx0XHRyaWdodCA9IGdldENvZGUobm9kZS5yaWdodCksXG5cdFx0XHRcdFx0XHRiZXR3ZWVuID0gZ2V0QmV0d2Vlbihub2RlLmxlZnQsIG5vZGUucmlnaHQpLFxuXHRcdFx0XHRcdFx0b3BlcmF0b3IgPSBub2RlLm9wZXJhdG9yO1xuXHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsICdfXyRfXygnICsgbGVmdCArICcsJ1xuXHRcdFx0XHRcdFx0XHQrIGJldHdlZW4ucmVwbGFjZShuZXcgUmVnRXhwKCdcXFxcJyArIG9wZXJhdG9yKSxcblx0XHRcdFx0XHRcdFx0XHQnXCInICsgb3BlcmF0b3IgKyAnXCInKVxuXHRcdFx0XHRcdFx0XHQrICcsICcgKyByaWdodCArICcpJyk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdVcGRhdGVFeHByZXNzaW9uJzpcblx0XHRcdGNhc2UgJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJzpcblx0XHRcdFx0dmFyIHBhcmVudFR5cGUgPSBwYXJlbnQgJiYgcGFyZW50LnR5cGU7XG5cdFx0XHRcdGlmICghKFxuXHRcdFx0XHRcdFx0cGFyZW50VHlwZSA9PT0gJ0ZvclN0YXRlbWVudCdcblx0XHRcdFx0XHRcdHx8IHBhcmVudFR5cGUgPT09ICdCaW5hcnlFeHByZXNzaW9uJ1xuXHRcdFx0XHRcdFx0XHQmJiAvXls9ITw+XS8udGVzdChwYXJlbnQub3BlcmF0b3IpXG5cdFx0XHRcdFx0XHR8fCBwYXJlbnRUeXBlID09PSAnTWVtYmVyRXhwcmVzc2lvbicgJiYgcGFyZW50LmNvbXB1dGVkXG5cdFx0XHRcdCkpIHtcblx0XHRcdFx0XHRpZiAobm9kZS50eXBlID09PSAnVXBkYXRlRXhwcmVzc2lvbicpIHtcblx0XHRcdFx0XHRcdHZhciBhcmcgPSBnZXRDb2RlKG5vZGUuYXJndW1lbnQpLFxuXHRcdFx0XHRcdFx0XHRleHAgPSAnX18kX18oJyArIGFyZyArICcsIFwiJyArIG5vZGUub3BlcmF0b3JbMF1cblx0XHRcdFx0XHRcdFx0XHRcdCsgJ1wiLCAxKScsXG5cdFx0XHRcdFx0XHRcdHN0ciA9IGFyZyArICcgPSAnICsgZXhwO1xuXHRcdFx0XHRcdFx0aWYgKCFub2RlLnByZWZpeFxuXHRcdFx0XHRcdFx0XHRcdCYmIChwYXJlbnRUeXBlID09PSAnQXNzaWdubWVudEV4cHJlc3Npb24nXG5cdFx0XHRcdFx0XHRcdFx0XHR8fCBwYXJlbnRUeXBlID09PSAnVmFyaWFibGVEZWNsYXJhdG9yJykpIHtcblx0XHRcdFx0XHRcdFx0aWYgKGdldENvZGUocGFyZW50LmxlZnQgfHwgcGFyZW50LmlkKSA9PT0gYXJnKVxuXHRcdFx0XHRcdFx0XHRcdHN0ciA9IGV4cDtcblx0XHRcdFx0XHRcdFx0c3RyID0gYXJnICsgJzsgJyArIHN0cjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJlcGxhY2VDb2RlKG5vZGUsIHN0cik7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGlmICgvXi49JC8udGVzdChub2RlLm9wZXJhdG9yKVxuXHRcdFx0XHRcdFx0XHRcdCYmIG5vZGUubGVmdC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGxlZnQgPSBnZXRDb2RlKG5vZGUubGVmdCksXG5cdFx0XHRcdFx0XHRcdFx0cmlnaHQgPSBnZXRDb2RlKG5vZGUucmlnaHQpO1xuXHRcdFx0XHRcdFx0XHRyZXBsYWNlQ29kZShub2RlLCBsZWZ0ICsgJyA9IF9fJF9fKCcgKyBsZWZ0ICsgJywgXCInXG5cdFx0XHRcdFx0XHRcdFx0XHQrIG5vZGUub3BlcmF0b3JbMF0gKyAnXCIsICcgKyByaWdodCArICcpJyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgc291cmNlTWFwID0gbnVsbCxcblx0XHRcdGJyb3dzZXIgPSBwYXBlci5icm93c2VyLFxuXHRcdFx0dmVyc2lvbiA9IGJyb3dzZXIudmVyc2lvbk51bWJlcixcblx0XHRcdGxpbmVCcmVha3MgPSAvXFxyXFxufFxcbnxcXHIvbWc7XG5cdFx0aWYgKGJyb3dzZXIuY2hyb21lICYmIHZlcnNpb24gPj0gMzBcblx0XHRcdFx0fHwgYnJvd3Nlci53ZWJraXQgJiYgdmVyc2lvbiA+PSA1MzcuNzZcblx0XHRcdFx0fHwgYnJvd3Nlci5maXJlZm94ICYmIHZlcnNpb24gPj0gMjMpIHtcblx0XHRcdHZhciBvZmZzZXQgPSAwO1xuXHRcdFx0aWYgKHdpbmRvdy5sb2NhdGlvbi5ocmVmLmluZGV4T2YodXJsKSA9PT0gMCkge1xuXHRcdFx0XHR2YXIgaHRtbCA9IGRvY3VtZW50LmdldEVsZW1lbnRzQnlUYWdOYW1lKCdodG1sJylbMF0uaW5uZXJIVE1MO1xuXHRcdFx0XHRvZmZzZXQgPSBodG1sLnN1YnN0cigwLCBodG1sLmluZGV4T2YoY29kZSkgKyAxKS5tYXRjaChcblx0XHRcdFx0XHRcdGxpbmVCcmVha3MpLmxlbmd0aCArIDE7XG5cdFx0XHR9XG5cdFx0XHR2YXIgbWFwcGluZ3MgPSBbJ0FBQUEnXTtcblx0XHRcdG1hcHBpbmdzLmxlbmd0aCA9IChjb2RlLm1hdGNoKGxpbmVCcmVha3MpIHx8IFtdKS5sZW5ndGggKyAxICsgb2Zmc2V0O1xuXHRcdFx0c291cmNlTWFwID0ge1xuXHRcdFx0XHR2ZXJzaW9uOiAzLFxuXHRcdFx0XHRmaWxlOiB1cmwsXG5cdFx0XHRcdG5hbWVzOltdLFxuXHRcdFx0XHRtYXBwaW5nczogbWFwcGluZ3Muam9pbignO0FBQ0EnKSxcblx0XHRcdFx0c291cmNlUm9vdDogJycsXG5cdFx0XHRcdHNvdXJjZXM6IFt1cmxdXG5cdFx0XHR9O1xuXHRcdFx0dmFyIHNvdXJjZSA9IG9wdGlvbnMuc291cmNlIHx8ICF1cmwgJiYgY29kZTtcblx0XHRcdGlmIChzb3VyY2UpXG5cdFx0XHRcdHNvdXJjZU1hcC5zb3VyY2VzQ29udGVudCA9IFtzb3VyY2VdO1xuXHRcdH1cblx0XHR3YWxrQVNUKHBhcnNlKGNvZGUsIHsgcmFuZ2VzOiB0cnVlIH0pKTtcblx0XHRpZiAoc291cmNlTWFwKSB7XG5cdFx0XHRjb2RlID0gbmV3IEFycmF5KG9mZnNldCArIDEpLmpvaW4oJ1xcbicpICsgY29kZVxuXHRcdFx0XHRcdCsgXCJcXG4vLyMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LFwiXG5cdFx0XHRcdFx0KyAoYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoXG5cdFx0XHRcdFx0XHRKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpKVxuXHRcdFx0XHRcdCsgXCJcXG4vLyMgc291cmNlVVJMPVwiICsgKHVybCB8fCAncGFwZXJzY3JpcHQnKTtcblx0XHR9XG5cdFx0cmV0dXJuIGNvZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBleGVjdXRlKGNvZGUsIHNjb3BlLCB1cmwsIG9wdGlvbnMpIHtcblx0XHRwYXBlciA9IHNjb3BlO1xuXHRcdHZhciB2aWV3ID0gc2NvcGUuZ2V0VmlldygpLFxuXHRcdFx0dG9vbCA9IC9cXHMrb24oPzpLZXl8TW91c2UpKD86VXB8RG93bnxNb3ZlfERyYWcpXFxiLy50ZXN0KGNvZGUpXG5cdFx0XHRcdFx0PyBuZXcgVG9vbCgpXG5cdFx0XHRcdFx0OiBudWxsLFxuXHRcdFx0dG9vbEhhbmRsZXJzID0gdG9vbCA/IHRvb2wuX2V2ZW50cyA6IFtdLFxuXHRcdFx0aGFuZGxlcnMgPSBbJ29uRnJhbWUnLCAnb25SZXNpemUnXS5jb25jYXQodG9vbEhhbmRsZXJzKSxcblx0XHRcdHBhcmFtcyA9IFtdLFxuXHRcdFx0YXJncyA9IFtdLFxuXHRcdFx0ZnVuYztcblx0XHRjb2RlID0gY29tcGlsZShjb2RlLCB1cmwsIG9wdGlvbnMpO1xuXHRcdGZ1bmN0aW9uIGV4cG9zZShzY29wZSwgaGlkZGVuKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gc2NvcGUpIHtcblx0XHRcdFx0aWYgKChoaWRkZW4gfHwgIS9eXy8udGVzdChrZXkpKSAmJiBuZXcgUmVnRXhwKCcoW1xcXFxiXFxcXHNcXFxcV118XiknXG5cdFx0XHRcdFx0XHQrIGtleS5yZXBsYWNlKC9cXCQvZywgJ1xcXFwkJykgKyAnXFxcXGInKS50ZXN0KGNvZGUpKSB7XG5cdFx0XHRcdFx0cGFyYW1zLnB1c2goa2V5KTtcblx0XHRcdFx0XHRhcmdzLnB1c2goc2NvcGVba2V5XSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0ZXhwb3NlKHsgX18kX186IF9fJF9fLCAkX186ICRfXywgcGFwZXI6IHNjb3BlLCB2aWV3OiB2aWV3LCB0b29sOiB0b29sIH0sXG5cdFx0XHRcdHRydWUpO1xuXHRcdGV4cG9zZShzY29wZSk7XG5cdFx0aGFuZGxlcnMgPSBCYXNlLmVhY2goaGFuZGxlcnMsIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0aWYgKG5ldyBSZWdFeHAoJ1xcXFxzKycgKyBrZXkgKyAnXFxcXGInKS50ZXN0KGNvZGUpKSB7XG5cdFx0XHRcdHBhcmFtcy5wdXNoKGtleSk7XG5cdFx0XHRcdHRoaXMucHVzaChrZXkgKyAnOiAnICsga2V5KTtcblx0XHRcdH1cblx0XHR9LCBbXSkuam9pbignLCAnKTtcblx0XHRpZiAoaGFuZGxlcnMpXG5cdFx0XHRjb2RlICs9ICdcXG5yZXR1cm4geyAnICsgaGFuZGxlcnMgKyAnIH07Jztcblx0XHR2YXIgYnJvd3NlciA9IHBhcGVyLmJyb3dzZXI7XG5cdFx0aWYgKGJyb3dzZXIuY2hyb21lIHx8IGJyb3dzZXIuZmlyZWZveCkge1xuXHRcdFx0dmFyIHNjcmlwdCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3NjcmlwdCcpLFxuXHRcdFx0XHRoZWFkID0gZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuXHRcdFx0aWYgKGJyb3dzZXIuZmlyZWZveClcblx0XHRcdFx0Y29kZSA9ICdcXG4nICsgY29kZTtcblx0XHRcdHNjcmlwdC5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShcblx0XHRcdFx0J3BhcGVyLl9leGVjdXRlID0gZnVuY3Rpb24oJyArIHBhcmFtcyArICcpIHsnICsgY29kZSArICdcXG59J1xuXHRcdFx0KSk7XG5cdFx0XHRoZWFkLmFwcGVuZENoaWxkKHNjcmlwdCk7XG5cdFx0XHRmdW5jID0gcGFwZXIuX2V4ZWN1dGU7XG5cdFx0XHRkZWxldGUgcGFwZXIuX2V4ZWN1dGU7XG5cdFx0XHRoZWFkLnJlbW92ZUNoaWxkKHNjcmlwdCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGZ1bmMgPSBGdW5jdGlvbihwYXJhbXMsIGNvZGUpO1xuXHRcdH1cblx0XHR2YXIgcmVzID0gZnVuYy5hcHBseShzY29wZSwgYXJncykgfHwge307XG5cdFx0QmFzZS5lYWNoKHRvb2xIYW5kbGVycywgZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHR2YXIgdmFsdWUgPSByZXNba2V5XTtcblx0XHRcdGlmICh2YWx1ZSlcblx0XHRcdFx0dG9vbFtrZXldID0gdmFsdWU7XG5cdFx0fSk7XG5cdFx0aWYgKHZpZXcpIHtcblx0XHRcdGlmIChyZXMub25SZXNpemUpXG5cdFx0XHRcdHZpZXcuc2V0T25SZXNpemUocmVzLm9uUmVzaXplKTtcblx0XHRcdHZpZXcuZW1pdCgncmVzaXplJywge1xuXHRcdFx0XHRzaXplOiB2aWV3LnNpemUsXG5cdFx0XHRcdGRlbHRhOiBuZXcgUG9pbnQoKVxuXHRcdFx0fSk7XG5cdFx0XHRpZiAocmVzLm9uRnJhbWUpXG5cdFx0XHRcdHZpZXcuc2V0T25GcmFtZShyZXMub25GcmFtZSk7XG5cdFx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWRTY3JpcHQoc2NyaXB0KSB7XG5cdFx0aWYgKC9edGV4dFxcLyg/OngtfClwYXBlcnNjcmlwdCQvLnRlc3Qoc2NyaXB0LnR5cGUpXG5cdFx0XHRcdCYmIFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKHNjcmlwdCwgJ2lnbm9yZScpICE9PSAndHJ1ZScpIHtcblx0XHRcdHZhciBjYW52YXNJZCA9IFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKHNjcmlwdCwgJ2NhbnZhcycpLFxuXHRcdFx0XHRjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNJZCksXG5cdFx0XHRcdHNyYyA9IHNjcmlwdC5zcmMgfHwgc2NyaXB0LmdldEF0dHJpYnV0ZSgnZGF0YS1zcmMnKSxcblx0XHRcdFx0YXN5bmMgPSBQYXBlclNjb3BlLmhhc0F0dHJpYnV0ZShzY3JpcHQsICdhc3luYycpLFxuXHRcdFx0XHRzY29wZUF0dHJpYnV0ZSA9ICdkYXRhLXBhcGVyLXNjb3BlJztcblx0XHRcdGlmICghY2FudmFzKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBmaW5kIGNhbnZhcyB3aXRoIGlkIFwiJ1xuXHRcdFx0XHRcdFx0KyBjYW52YXNJZCArICdcIicpO1xuXHRcdFx0dmFyIHNjb3BlID0gUGFwZXJTY29wZS5nZXQoY2FudmFzLmdldEF0dHJpYnV0ZShzY29wZUF0dHJpYnV0ZSkpXG5cdFx0XHRcdFx0XHR8fCBuZXcgUGFwZXJTY29wZSgpLnNldHVwKGNhbnZhcyk7XG5cdFx0XHRjYW52YXMuc2V0QXR0cmlidXRlKHNjb3BlQXR0cmlidXRlLCBzY29wZS5faWQpO1xuXHRcdFx0aWYgKHNyYykge1xuXHRcdFx0XHRIdHRwLnJlcXVlc3QoJ2dldCcsIHNyYywgZnVuY3Rpb24oY29kZSkge1xuXHRcdFx0XHRcdGV4ZWN1dGUoY29kZSwgc2NvcGUsIHNyYyk7XG5cdFx0XHRcdH0sIGFzeW5jKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGV4ZWN1dGUoc2NyaXB0LmlubmVySFRNTCwgc2NvcGUsIHNjcmlwdC5iYXNlVVJJKTtcblx0XHRcdH1cblx0XHRcdHNjcmlwdC5zZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItaWdub3JlJywgJ3RydWUnKTtcblx0XHRcdHJldHVybiBzY29wZTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBsb2FkQWxsKCkge1xuXHRcdEJhc2UuZWFjaChkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnc2NyaXB0JyksIGxvYWRTY3JpcHQpO1xuXHR9XG5cblx0ZnVuY3Rpb24gbG9hZChzY3JpcHQpIHtcblx0XHRyZXR1cm4gc2NyaXB0ID8gbG9hZFNjcmlwdChzY3JpcHQpIDogbG9hZEFsbCgpO1xuXHR9XG5cblx0aWYgKGRvY3VtZW50LnJlYWR5U3RhdGUgPT09ICdjb21wbGV0ZScpIHtcblx0XHRzZXRUaW1lb3V0KGxvYWRBbGwpO1xuXHR9IGVsc2Uge1xuXHRcdERvbUV2ZW50LmFkZCh3aW5kb3csIHsgbG9hZDogbG9hZEFsbCB9KTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0Y29tcGlsZTogY29tcGlsZSxcblx0XHRleGVjdXRlOiBleGVjdXRlLFxuXHRcdGxvYWQ6IGxvYWQsXG5cdFx0cGFyc2U6IHBhcnNlXG5cdH07XG5cbn0pLmNhbGwodGhpcyk7XG5cbnBhcGVyID0gbmV3IChQYXBlclNjb3BlLmluamVjdChCYXNlLmV4cG9ydHMsIHtcblx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0QmFzZTogQmFzZSxcblx0TnVtZXJpY2FsOiBOdW1lcmljYWwsXG5cdEtleTogS2V5XG59KSkoKTtcblxuaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuXHRkZWZpbmUoJ3BhcGVyJywgcGFwZXIpO1xufSBlbHNlIGlmICh0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0JyAmJiBtb2R1bGUpIHtcblx0bW9kdWxlLmV4cG9ydHMgPSBwYXBlcjtcbn1cblxucmV0dXJuIHBhcGVyO1xufTtcbiIsIi8vIENvcHlyaWdodCBKb3llbnQsIEluYy4gYW5kIG90aGVyIE5vZGUgY29udHJpYnV0b3JzLlxuLy9cbi8vIFBlcm1pc3Npb24gaXMgaGVyZWJ5IGdyYW50ZWQsIGZyZWUgb2YgY2hhcmdlLCB0byBhbnkgcGVyc29uIG9idGFpbmluZyBhXG4vLyBjb3B5IG9mIHRoaXMgc29mdHdhcmUgYW5kIGFzc29jaWF0ZWQgZG9jdW1lbnRhdGlvbiBmaWxlcyAodGhlXG4vLyBcIlNvZnR3YXJlXCIpLCB0byBkZWFsIGluIHRoZSBTb2Z0d2FyZSB3aXRob3V0IHJlc3RyaWN0aW9uLCBpbmNsdWRpbmdcbi8vIHdpdGhvdXQgbGltaXRhdGlvbiB0aGUgcmlnaHRzIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBtZXJnZSwgcHVibGlzaCxcbi8vIGRpc3RyaWJ1dGUsIHN1YmxpY2Vuc2UsIGFuZC9vciBzZWxsIGNvcGllcyBvZiB0aGUgU29mdHdhcmUsIGFuZCB0byBwZXJtaXRcbi8vIHBlcnNvbnMgdG8gd2hvbSB0aGUgU29mdHdhcmUgaXMgZnVybmlzaGVkIHRvIGRvIHNvLCBzdWJqZWN0IHRvIHRoZVxuLy8gZm9sbG93aW5nIGNvbmRpdGlvbnM6XG4vL1xuLy8gVGhlIGFib3ZlIGNvcHlyaWdodCBub3RpY2UgYW5kIHRoaXMgcGVybWlzc2lvbiBub3RpY2Ugc2hhbGwgYmUgaW5jbHVkZWRcbi8vIGluIGFsbCBjb3BpZXMgb3Igc3Vic3RhbnRpYWwgcG9ydGlvbnMgb2YgdGhlIFNvZnR3YXJlLlxuLy9cbi8vIFRIRSBTT0ZUV0FSRSBJUyBQUk9WSURFRCBcIkFTIElTXCIsIFdJVEhPVVQgV0FSUkFOVFkgT0YgQU5ZIEtJTkQsIEVYUFJFU1Ncbi8vIE9SIElNUExJRUQsIElOQ0xVRElORyBCVVQgTk9UIExJTUlURUQgVE8gVEhFIFdBUlJBTlRJRVMgT0Zcbi8vIE1FUkNIQU5UQUJJTElUWSwgRklUTkVTUyBGT1IgQSBQQVJUSUNVTEFSIFBVUlBPU0UgQU5EIE5PTklORlJJTkdFTUVOVC4gSU5cbi8vIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1JTIE9SIENPUFlSSUdIVCBIT0xERVJTIEJFIExJQUJMRSBGT1IgQU5ZIENMQUlNLFxuLy8gREFNQUdFUyBPUiBPVEhFUiBMSUFCSUxJVFksIFdIRVRIRVIgSU4gQU4gQUNUSU9OIE9GIENPTlRSQUNULCBUT1JUIE9SXG4vLyBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSwgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgU09GVFdBUkUgT1IgVEhFXG4vLyBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFIFNPRlRXQVJFLlxuXG4vLyByZXNvbHZlcyAuIGFuZCAuLiBlbGVtZW50cyBpbiBhIHBhdGggYXJyYXkgd2l0aCBkaXJlY3RvcnkgbmFtZXMgdGhlcmVcbi8vIG11c3QgYmUgbm8gc2xhc2hlcywgZW1wdHkgZWxlbWVudHMsIG9yIGRldmljZSBuYW1lcyAoYzpcXCkgaW4gdGhlIGFycmF5XG4vLyAoc28gYWxzbyBubyBsZWFkaW5nIGFuZCB0cmFpbGluZyBzbGFzaGVzIC0gaXQgZG9lcyBub3QgZGlzdGluZ3Vpc2hcbi8vIHJlbGF0aXZlIGFuZCBhYnNvbHV0ZSBwYXRocylcbmZ1bmN0aW9uIG5vcm1hbGl6ZUFycmF5KHBhcnRzLCBhbGxvd0Fib3ZlUm9vdCkge1xuICAvLyBpZiB0aGUgcGF0aCB0cmllcyB0byBnbyBhYm92ZSB0aGUgcm9vdCwgYHVwYCBlbmRzIHVwID4gMFxuICB2YXIgdXAgPSAwO1xuICBmb3IgKHZhciBpID0gcGFydHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICB2YXIgbGFzdCA9IHBhcnRzW2ldO1xuICAgIGlmIChsYXN0ID09PSAnLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICB9IGVsc2UgaWYgKGxhc3QgPT09ICcuLicpIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwKys7XG4gICAgfSBlbHNlIGlmICh1cCkge1xuICAgICAgcGFydHMuc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICAvLyBpZiB0aGUgcGF0aCBpcyBhbGxvd2VkIHRvIGdvIGFib3ZlIHRoZSByb290LCByZXN0b3JlIGxlYWRpbmcgLi5zXG4gIGlmIChhbGxvd0Fib3ZlUm9vdCkge1xuICAgIGZvciAoOyB1cC0tOyB1cCkge1xuICAgICAgcGFydHMudW5zaGlmdCgnLi4nKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gcGFydHM7XG59XG5cbi8vIFNwbGl0IGEgZmlsZW5hbWUgaW50byBbcm9vdCwgZGlyLCBiYXNlbmFtZSwgZXh0XSwgdW5peCB2ZXJzaW9uXG4vLyAncm9vdCcgaXMganVzdCBhIHNsYXNoLCBvciBub3RoaW5nLlxudmFyIHNwbGl0UGF0aFJlID1cbiAgICAvXihcXC8/fCkoW1xcc1xcU10qPykoKD86XFwuezEsMn18W15cXC9dKz98KShcXC5bXi5cXC9dKnwpKSg/OltcXC9dKikkLztcbnZhciBzcGxpdFBhdGggPSBmdW5jdGlvbihmaWxlbmFtZSkge1xuICByZXR1cm4gc3BsaXRQYXRoUmUuZXhlYyhmaWxlbmFtZSkuc2xpY2UoMSk7XG59O1xuXG4vLyBwYXRoLnJlc29sdmUoW2Zyb20gLi4uXSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlc29sdmUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHJlc29sdmVkUGF0aCA9ICcnLFxuICAgICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IGZhbHNlO1xuXG4gIGZvciAodmFyIGkgPSBhcmd1bWVudHMubGVuZ3RoIC0gMTsgaSA+PSAtMSAmJiAhcmVzb2x2ZWRBYnNvbHV0ZTsgaS0tKSB7XG4gICAgdmFyIHBhdGggPSAoaSA+PSAwKSA/IGFyZ3VtZW50c1tpXSA6IHByb2Nlc3MuY3dkKCk7XG5cbiAgICAvLyBTa2lwIGVtcHR5IGFuZCBpbnZhbGlkIGVudHJpZXNcbiAgICBpZiAodHlwZW9mIHBhdGggIT09ICdzdHJpbmcnKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdBcmd1bWVudHMgdG8gcGF0aC5yZXNvbHZlIG11c3QgYmUgc3RyaW5ncycpO1xuICAgIH0gZWxzZSBpZiAoIXBhdGgpIHtcbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cblxuICAgIHJlc29sdmVkUGF0aCA9IHBhdGggKyAnLycgKyByZXNvbHZlZFBhdGg7XG4gICAgcmVzb2x2ZWRBYnNvbHV0ZSA9IHBhdGguY2hhckF0KDApID09PSAnLyc7XG4gIH1cblxuICAvLyBBdCB0aGlzIHBvaW50IHRoZSBwYXRoIHNob3VsZCBiZSByZXNvbHZlZCB0byBhIGZ1bGwgYWJzb2x1dGUgcGF0aCwgYnV0XG4gIC8vIGhhbmRsZSByZWxhdGl2ZSBwYXRocyB0byBiZSBzYWZlIChtaWdodCBoYXBwZW4gd2hlbiBwcm9jZXNzLmN3ZCgpIGZhaWxzKVxuXG4gIC8vIE5vcm1hbGl6ZSB0aGUgcGF0aFxuICByZXNvbHZlZFBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocmVzb2x2ZWRQYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIXJlc29sdmVkQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICByZXR1cm4gKChyZXNvbHZlZEFic29sdXRlID8gJy8nIDogJycpICsgcmVzb2x2ZWRQYXRoKSB8fCAnLic7XG59O1xuXG4vLyBwYXRoLm5vcm1hbGl6ZShwYXRoKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5ub3JtYWxpemUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciBpc0Fic29sdXRlID0gZXhwb3J0cy5pc0Fic29sdXRlKHBhdGgpLFxuICAgICAgdHJhaWxpbmdTbGFzaCA9IHN1YnN0cihwYXRoLCAtMSkgPT09ICcvJztcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcGF0aCA9IG5vcm1hbGl6ZUFycmF5KGZpbHRlcihwYXRoLnNwbGl0KCcvJyksIGZ1bmN0aW9uKHApIHtcbiAgICByZXR1cm4gISFwO1xuICB9KSwgIWlzQWJzb2x1dGUpLmpvaW4oJy8nKTtcblxuICBpZiAoIXBhdGggJiYgIWlzQWJzb2x1dGUpIHtcbiAgICBwYXRoID0gJy4nO1xuICB9XG4gIGlmIChwYXRoICYmIHRyYWlsaW5nU2xhc2gpIHtcbiAgICBwYXRoICs9ICcvJztcbiAgfVxuXG4gIHJldHVybiAoaXNBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHBhdGg7XG59O1xuXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLmlzQWJzb2x1dGUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHJldHVybiBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5qb2luID0gZnVuY3Rpb24oKSB7XG4gIHZhciBwYXRocyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMCk7XG4gIHJldHVybiBleHBvcnRzLm5vcm1hbGl6ZShmaWx0ZXIocGF0aHMsIGZ1bmN0aW9uKHAsIGluZGV4KSB7XG4gICAgaWYgKHR5cGVvZiBwICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGguam9pbiBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9XG4gICAgcmV0dXJuIHA7XG4gIH0pLmpvaW4oJy8nKSk7XG59O1xuXG5cbi8vIHBhdGgucmVsYXRpdmUoZnJvbSwgdG8pXG4vLyBwb3NpeCB2ZXJzaW9uXG5leHBvcnRzLnJlbGF0aXZlID0gZnVuY3Rpb24oZnJvbSwgdG8pIHtcbiAgZnJvbSA9IGV4cG9ydHMucmVzb2x2ZShmcm9tKS5zdWJzdHIoMSk7XG4gIHRvID0gZXhwb3J0cy5yZXNvbHZlKHRvKS5zdWJzdHIoMSk7XG5cbiAgZnVuY3Rpb24gdHJpbShhcnIpIHtcbiAgICB2YXIgc3RhcnQgPSAwO1xuICAgIGZvciAoOyBzdGFydCA8IGFyci5sZW5ndGg7IHN0YXJ0KyspIHtcbiAgICAgIGlmIChhcnJbc3RhcnRdICE9PSAnJykgYnJlYWs7XG4gICAgfVxuXG4gICAgdmFyIGVuZCA9IGFyci5sZW5ndGggLSAxO1xuICAgIGZvciAoOyBlbmQgPj0gMDsgZW5kLS0pIHtcbiAgICAgIGlmIChhcnJbZW5kXSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIGlmIChzdGFydCA+IGVuZCkgcmV0dXJuIFtdO1xuICAgIHJldHVybiBhcnIuc2xpY2Uoc3RhcnQsIGVuZCAtIHN0YXJ0ICsgMSk7XG4gIH1cblxuICB2YXIgZnJvbVBhcnRzID0gdHJpbShmcm9tLnNwbGl0KCcvJykpO1xuICB2YXIgdG9QYXJ0cyA9IHRyaW0odG8uc3BsaXQoJy8nKSk7XG5cbiAgdmFyIGxlbmd0aCA9IE1hdGgubWluKGZyb21QYXJ0cy5sZW5ndGgsIHRvUGFydHMubGVuZ3RoKTtcbiAgdmFyIHNhbWVQYXJ0c0xlbmd0aCA9IGxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGlmIChmcm9tUGFydHNbaV0gIT09IHRvUGFydHNbaV0pIHtcbiAgICAgIHNhbWVQYXJ0c0xlbmd0aCA9IGk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cblxuICB2YXIgb3V0cHV0UGFydHMgPSBbXTtcbiAgZm9yICh2YXIgaSA9IHNhbWVQYXJ0c0xlbmd0aDsgaSA8IGZyb21QYXJ0cy5sZW5ndGg7IGkrKykge1xuICAgIG91dHB1dFBhcnRzLnB1c2goJy4uJyk7XG4gIH1cblxuICBvdXRwdXRQYXJ0cyA9IG91dHB1dFBhcnRzLmNvbmNhdCh0b1BhcnRzLnNsaWNlKHNhbWVQYXJ0c0xlbmd0aCkpO1xuXG4gIHJldHVybiBvdXRwdXRQYXJ0cy5qb2luKCcvJyk7XG59O1xuXG5leHBvcnRzLnNlcCA9ICcvJztcbmV4cG9ydHMuZGVsaW1pdGVyID0gJzonO1xuXG5leHBvcnRzLmRpcm5hbWUgPSBmdW5jdGlvbihwYXRoKSB7XG4gIHZhciByZXN1bHQgPSBzcGxpdFBhdGgocGF0aCksXG4gICAgICByb290ID0gcmVzdWx0WzBdLFxuICAgICAgZGlyID0gcmVzdWx0WzFdO1xuXG4gIGlmICghcm9vdCAmJiAhZGlyKSB7XG4gICAgLy8gTm8gZGlybmFtZSB3aGF0c29ldmVyXG4gICAgcmV0dXJuICcuJztcbiAgfVxuXG4gIGlmIChkaXIpIHtcbiAgICAvLyBJdCBoYXMgYSBkaXJuYW1lLCBzdHJpcCB0cmFpbGluZyBzbGFzaFxuICAgIGRpciA9IGRpci5zdWJzdHIoMCwgZGlyLmxlbmd0aCAtIDEpO1xuICB9XG5cbiAgcmV0dXJuIHJvb3QgKyBkaXI7XG59O1xuXG5cbmV4cG9ydHMuYmFzZW5hbWUgPSBmdW5jdGlvbihwYXRoLCBleHQpIHtcbiAgdmFyIGYgPSBzcGxpdFBhdGgocGF0aClbMl07XG4gIC8vIFRPRE86IG1ha2UgdGhpcyBjb21wYXJpc29uIGNhc2UtaW5zZW5zaXRpdmUgb24gd2luZG93cz9cbiAgaWYgKGV4dCAmJiBmLnN1YnN0cigtMSAqIGV4dC5sZW5ndGgpID09PSBleHQpIHtcbiAgICBmID0gZi5zdWJzdHIoMCwgZi5sZW5ndGggLSBleHQubGVuZ3RoKTtcbiAgfVxuICByZXR1cm4gZjtcbn07XG5cblxuZXhwb3J0cy5leHRuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gc3BsaXRQYXRoKHBhdGgpWzNdO1xufTtcblxuZnVuY3Rpb24gZmlsdGVyICh4cywgZikge1xuICAgIGlmICh4cy5maWx0ZXIpIHJldHVybiB4cy5maWx0ZXIoZik7XG4gICAgdmFyIHJlcyA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGYoeHNbaV0sIGksIHhzKSkgcmVzLnB1c2goeHNbaV0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzO1xufVxuXG4vLyBTdHJpbmcucHJvdG90eXBlLnN1YnN0ciAtIG5lZ2F0aXZlIGluZGV4IGRvbid0IHdvcmsgaW4gSUU4XG52YXIgc3Vic3RyID0gJ2FiJy5zdWJzdHIoLTEpID09PSAnYidcbiAgICA/IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHsgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbikgfVxuICAgIDogZnVuY3Rpb24gKHN0ciwgc3RhcnQsIGxlbikge1xuICAgICAgICBpZiAoc3RhcnQgPCAwKSBzdGFydCA9IHN0ci5sZW5ndGggKyBzdGFydDtcbiAgICAgICAgcmV0dXJuIHN0ci5zdWJzdHIoc3RhcnQsIGxlbik7XG4gICAgfVxuO1xuIiwiLy8gICAgIFVuZGVyc2NvcmUuanMgMS44LjNcbi8vICAgICBodHRwOi8vdW5kZXJzY29yZWpzLm9yZ1xuLy8gICAgIChjKSAyMDA5LTIwMTUgSmVyZW15IEFzaGtlbmFzLCBEb2N1bWVudENsb3VkIGFuZCBJbnZlc3RpZ2F0aXZlIFJlcG9ydGVycyAmIEVkaXRvcnNcbi8vICAgICBVbmRlcnNjb3JlIG1heSBiZSBmcmVlbHkgZGlzdHJpYnV0ZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlLlxuXG4oZnVuY3Rpb24oKSB7XG5cbiAgLy8gQmFzZWxpbmUgc2V0dXBcbiAgLy8gLS0tLS0tLS0tLS0tLS1cblxuICAvLyBFc3RhYmxpc2ggdGhlIHJvb3Qgb2JqZWN0LCBgd2luZG93YCBpbiB0aGUgYnJvd3Nlciwgb3IgYGV4cG9ydHNgIG9uIHRoZSBzZXJ2ZXIuXG4gIHZhciByb290ID0gdGhpcztcblxuICAvLyBTYXZlIHRoZSBwcmV2aW91cyB2YWx1ZSBvZiB0aGUgYF9gIHZhcmlhYmxlLlxuICB2YXIgcHJldmlvdXNVbmRlcnNjb3JlID0gcm9vdC5fO1xuXG4gIC8vIFNhdmUgYnl0ZXMgaW4gdGhlIG1pbmlmaWVkIChidXQgbm90IGd6aXBwZWQpIHZlcnNpb246XG4gIHZhciBBcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlLCBPYmpQcm90byA9IE9iamVjdC5wcm90b3R5cGUsIEZ1bmNQcm90byA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcblxuICAvLyBDcmVhdGUgcXVpY2sgcmVmZXJlbmNlIHZhcmlhYmxlcyBmb3Igc3BlZWQgYWNjZXNzIHRvIGNvcmUgcHJvdG90eXBlcy5cbiAgdmFyXG4gICAgcHVzaCAgICAgICAgICAgICA9IEFycmF5UHJvdG8ucHVzaCxcbiAgICBzbGljZSAgICAgICAgICAgID0gQXJyYXlQcm90by5zbGljZSxcbiAgICB0b1N0cmluZyAgICAgICAgID0gT2JqUHJvdG8udG9TdHJpbmcsXG4gICAgaGFzT3duUHJvcGVydHkgICA9IE9ialByb3RvLmhhc093blByb3BlcnR5O1xuXG4gIC8vIEFsbCAqKkVDTUFTY3JpcHQgNSoqIG5hdGl2ZSBmdW5jdGlvbiBpbXBsZW1lbnRhdGlvbnMgdGhhdCB3ZSBob3BlIHRvIHVzZVxuICAvLyBhcmUgZGVjbGFyZWQgaGVyZS5cbiAgdmFyXG4gICAgbmF0aXZlSXNBcnJheSAgICAgID0gQXJyYXkuaXNBcnJheSxcbiAgICBuYXRpdmVLZXlzICAgICAgICAgPSBPYmplY3Qua2V5cyxcbiAgICBuYXRpdmVCaW5kICAgICAgICAgPSBGdW5jUHJvdG8uYmluZCxcbiAgICBuYXRpdmVDcmVhdGUgICAgICAgPSBPYmplY3QuY3JlYXRlO1xuXG4gIC8vIE5ha2VkIGZ1bmN0aW9uIHJlZmVyZW5jZSBmb3Igc3Vycm9nYXRlLXByb3RvdHlwZS1zd2FwcGluZy5cbiAgdmFyIEN0b3IgPSBmdW5jdGlvbigpe307XG5cbiAgLy8gQ3JlYXRlIGEgc2FmZSByZWZlcmVuY2UgdG8gdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciB1c2UgYmVsb3cuXG4gIHZhciBfID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKG9iaiBpbnN0YW5jZW9mIF8pIHJldHVybiBvYmo7XG4gICAgaWYgKCEodGhpcyBpbnN0YW5jZW9mIF8pKSByZXR1cm4gbmV3IF8ob2JqKTtcbiAgICB0aGlzLl93cmFwcGVkID0gb2JqO1xuICB9O1xuXG4gIC8vIEV4cG9ydCB0aGUgVW5kZXJzY29yZSBvYmplY3QgZm9yICoqTm9kZS5qcyoqLCB3aXRoXG4gIC8vIGJhY2t3YXJkcy1jb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkIGByZXF1aXJlKClgIEFQSS4gSWYgd2UncmUgaW5cbiAgLy8gdGhlIGJyb3dzZXIsIGFkZCBgX2AgYXMgYSBnbG9iYWwgb2JqZWN0LlxuICBpZiAodHlwZW9mIGV4cG9ydHMgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIG1vZHVsZS5leHBvcnRzKSB7XG4gICAgICBleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSBfO1xuICAgIH1cbiAgICBleHBvcnRzLl8gPSBfO1xuICB9IGVsc2Uge1xuICAgIHJvb3QuXyA9IF87XG4gIH1cblxuICAvLyBDdXJyZW50IHZlcnNpb24uXG4gIF8uVkVSU0lPTiA9ICcxLjguMyc7XG5cbiAgLy8gSW50ZXJuYWwgZnVuY3Rpb24gdGhhdCByZXR1cm5zIGFuIGVmZmljaWVudCAoZm9yIGN1cnJlbnQgZW5naW5lcykgdmVyc2lvblxuICAvLyBvZiB0aGUgcGFzc2VkLWluIGNhbGxiYWNrLCB0byBiZSByZXBlYXRlZGx5IGFwcGxpZWQgaW4gb3RoZXIgVW5kZXJzY29yZVxuICAvLyBmdW5jdGlvbnMuXG4gIHZhciBvcHRpbWl6ZUNiID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCwgYXJnQ291bnQpIHtcbiAgICBpZiAoY29udGV4dCA9PT0gdm9pZCAwKSByZXR1cm4gZnVuYztcbiAgICBzd2l0Y2ggKGFyZ0NvdW50ID09IG51bGwgPyAzIDogYXJnQ291bnQpIHtcbiAgICAgIGNhc2UgMTogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMjogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBvdGhlcikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBvdGhlcik7XG4gICAgICB9O1xuICAgICAgY2FzZSAzOiByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDQ6IHJldHVybiBmdW5jdGlvbihhY2N1bXVsYXRvciwgdmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmNhbGwoY29udGV4dCwgYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShjb250ZXh0LCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQSBtb3N0bHktaW50ZXJuYWwgZnVuY3Rpb24gdG8gZ2VuZXJhdGUgY2FsbGJhY2tzIHRoYXQgY2FuIGJlIGFwcGxpZWRcbiAgLy8gdG8gZWFjaCBlbGVtZW50IGluIGEgY29sbGVjdGlvbiwgcmV0dXJuaW5nIHRoZSBkZXNpcmVkIHJlc3VsdCDigJQgZWl0aGVyXG4gIC8vIGlkZW50aXR5LCBhbiBhcmJpdHJhcnkgY2FsbGJhY2ssIGEgcHJvcGVydHkgbWF0Y2hlciwgb3IgYSBwcm9wZXJ0eSBhY2Nlc3Nvci5cbiAgdmFyIGNiID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKHZhbHVlID09IG51bGwpIHJldHVybiBfLmlkZW50aXR5O1xuICAgIGlmIChfLmlzRnVuY3Rpb24odmFsdWUpKSByZXR1cm4gb3B0aW1pemVDYih2YWx1ZSwgY29udGV4dCwgYXJnQ291bnQpO1xuICAgIGlmIChfLmlzT2JqZWN0KHZhbHVlKSkgcmV0dXJuIF8ubWF0Y2hlcih2YWx1ZSk7XG4gICAgcmV0dXJuIF8ucHJvcGVydHkodmFsdWUpO1xuICB9O1xuICBfLml0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gY2IodmFsdWUsIGNvbnRleHQsIEluZmluaXR5KTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYXNzaWduZXIgZnVuY3Rpb25zLlxuICB2YXIgY3JlYXRlQXNzaWduZXIgPSBmdW5jdGlvbihrZXlzRnVuYywgdW5kZWZpbmVkT25seSkge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHZhciBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgICAgaWYgKGxlbmd0aCA8IDIgfHwgb2JqID09IG51bGwpIHJldHVybiBvYmo7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDE7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBhcmd1bWVudHNbaW5kZXhdLFxuICAgICAgICAgICAga2V5cyA9IGtleXNGdW5jKHNvdXJjZSksXG4gICAgICAgICAgICBsID0ga2V5cy5sZW5ndGg7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICAgICAgaWYgKCF1bmRlZmluZWRPbmx5IHx8IG9ialtrZXldID09PSB2b2lkIDApIG9ialtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiBvYmo7XG4gICAgfTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiBmb3IgY3JlYXRpbmcgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSBhbm90aGVyLlxuICB2YXIgYmFzZUNyZWF0ZSA9IGZ1bmN0aW9uKHByb3RvdHlwZSkge1xuICAgIGlmICghXy5pc09iamVjdChwcm90b3R5cGUpKSByZXR1cm4ge307XG4gICAgaWYgKG5hdGl2ZUNyZWF0ZSkgcmV0dXJuIG5hdGl2ZUNyZWF0ZShwcm90b3R5cGUpO1xuICAgIEN0b3IucHJvdG90eXBlID0gcHJvdG90eXBlO1xuICAgIHZhciByZXN1bHQgPSBuZXcgQ3RvcjtcbiAgICBDdG9yLnByb3RvdHlwZSA9IG51bGw7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICB2YXIgcHJvcGVydHkgPSBmdW5jdGlvbihrZXkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gb2JqID09IG51bGwgPyB2b2lkIDAgOiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEhlbHBlciBmb3IgY29sbGVjdGlvbiBtZXRob2RzIHRvIGRldGVybWluZSB3aGV0aGVyIGEgY29sbGVjdGlvblxuICAvLyBzaG91bGQgYmUgaXRlcmF0ZWQgYXMgYW4gYXJyYXkgb3IgYXMgYW4gb2JqZWN0XG4gIC8vIFJlbGF0ZWQ6IGh0dHA6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLXRvbGVuZ3RoXG4gIC8vIEF2b2lkcyBhIHZlcnkgbmFzdHkgaU9TIDggSklUIGJ1ZyBvbiBBUk0tNjQuICMyMDk0XG4gIHZhciBNQVhfQVJSQVlfSU5ERVggPSBNYXRoLnBvdygyLCA1MykgLSAxO1xuICB2YXIgZ2V0TGVuZ3RoID0gcHJvcGVydHkoJ2xlbmd0aCcpO1xuICB2YXIgaXNBcnJheUxpa2UgPSBmdW5jdGlvbihjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChjb2xsZWN0aW9uKTtcbiAgICByZXR1cm4gdHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyAmJiBsZW5ndGggPj0gMCAmJiBsZW5ndGggPD0gTUFYX0FSUkFZX0lOREVYO1xuICB9O1xuXG4gIC8vIENvbGxlY3Rpb24gRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gVGhlIGNvcm5lcnN0b25lLCBhbiBgZWFjaGAgaW1wbGVtZW50YXRpb24sIGFrYSBgZm9yRWFjaGAuXG4gIC8vIEhhbmRsZXMgcmF3IG9iamVjdHMgaW4gYWRkaXRpb24gdG8gYXJyYXktbGlrZXMuIFRyZWF0cyBhbGxcbiAgLy8gc3BhcnNlIGFycmF5LWxpa2VzIGFzIGlmIHRoZXkgd2VyZSBkZW5zZS5cbiAgXy5lYWNoID0gXy5mb3JFYWNoID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGksIGxlbmd0aDtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAgZm9yIChpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtpXSwgaSwgb2JqKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaXRlcmF0ZWUob2JqW2tleXNbaV1dLCBrZXlzW2ldLCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50LlxuICBfLm1hcCA9IF8uY29sbGVjdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgcmVzdWx0cyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIHJlc3VsdHNbaW5kZXhdID0gaXRlcmF0ZWUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDcmVhdGUgYSByZWR1Y2luZyBmdW5jdGlvbiBpdGVyYXRpbmcgbGVmdCBvciByaWdodC5cbiAgZnVuY3Rpb24gY3JlYXRlUmVkdWNlKGRpcikge1xuICAgIC8vIE9wdGltaXplZCBpdGVyYXRvciBmdW5jdGlvbiBhcyB1c2luZyBhcmd1bWVudHMubGVuZ3RoXG4gICAgLy8gaW4gdGhlIG1haW4gZnVuY3Rpb24gd2lsbCBkZW9wdGltaXplIHRoZSwgc2VlICMxOTkxLlxuICAgIGZ1bmN0aW9uIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpIHtcbiAgICAgIGZvciAoOyBpbmRleCA+PSAwICYmIGluZGV4IDwgbGVuZ3RoOyBpbmRleCArPSBkaXIpIHtcbiAgICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgICAgbWVtbyA9IGl0ZXJhdGVlKG1lbW8sIG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtZW1vO1xuICAgIH1cblxuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBtZW1vLCBjb250ZXh0KSB7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQsIDQpO1xuICAgICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aCxcbiAgICAgICAgICBpbmRleCA9IGRpciA+IDAgPyAwIDogbGVuZ3RoIC0gMTtcbiAgICAgIC8vIERldGVybWluZSB0aGUgaW5pdGlhbCB2YWx1ZSBpZiBub25lIGlzIHByb3ZpZGVkLlxuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPCAzKSB7XG4gICAgICAgIG1lbW8gPSBvYmpba2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXhdO1xuICAgICAgICBpbmRleCArPSBkaXI7XG4gICAgICB9XG4gICAgICByZXR1cm4gaXRlcmF0b3Iob2JqLCBpdGVyYXRlZSwgbWVtbywga2V5cywgaW5kZXgsIGxlbmd0aCk7XG4gICAgfTtcbiAgfVxuXG4gIC8vICoqUmVkdWNlKiogYnVpbGRzIHVwIGEgc2luZ2xlIHJlc3VsdCBmcm9tIGEgbGlzdCBvZiB2YWx1ZXMsIGFrYSBgaW5qZWN0YCxcbiAgLy8gb3IgYGZvbGRsYC5cbiAgXy5yZWR1Y2UgPSBfLmZvbGRsID0gXy5pbmplY3QgPSBjcmVhdGVSZWR1Y2UoMSk7XG5cbiAgLy8gVGhlIHJpZ2h0LWFzc29jaWF0aXZlIHZlcnNpb24gb2YgcmVkdWNlLCBhbHNvIGtub3duIGFzIGBmb2xkcmAuXG4gIF8ucmVkdWNlUmlnaHQgPSBfLmZvbGRyID0gY3JlYXRlUmVkdWNlKC0xKTtcblxuICAvLyBSZXR1cm4gdGhlIGZpcnN0IHZhbHVlIHdoaWNoIHBhc3NlcyBhIHRydXRoIHRlc3QuIEFsaWFzZWQgYXMgYGRldGVjdGAuXG4gIF8uZmluZCA9IF8uZGV0ZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICB2YXIga2V5O1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSB7XG4gICAgICBrZXkgPSBfLmZpbmRJbmRleChvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGtleSA9IF8uZmluZEtleShvYmosIHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgfVxuICAgIGlmIChrZXkgIT09IHZvaWQgMCAmJiBrZXkgIT09IC0xKSByZXR1cm4gb2JqW2tleV07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgdGhhdCBwYXNzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgc2VsZWN0YC5cbiAgXy5maWx0ZXIgPSBfLnNlbGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdHMgPSBbXTtcbiAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgaWYgKHByZWRpY2F0ZSh2YWx1ZSwgaW5kZXgsIGxpc3QpKSByZXN1bHRzLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIGZvciB3aGljaCBhIHRydXRoIHRlc3QgZmFpbHMuXG4gIF8ucmVqZWN0ID0gZnVuY3Rpb24ob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm5lZ2F0ZShjYihwcmVkaWNhdGUpKSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIHdoZXRoZXIgYWxsIG9mIHRoZSBlbGVtZW50cyBtYXRjaCBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYGFsbGAuXG4gIF8uZXZlcnkgPSBfLmFsbCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKCFwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiBhdCBsZWFzdCBvbmUgZWxlbWVudCBpbiB0aGUgb2JqZWN0IG1hdGNoZXMgYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbnlgLlxuICBfLnNvbWUgPSBfLmFueSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9ICFpc0FycmF5TGlrZShvYmopICYmIF8ua2V5cyhvYmopLFxuICAgICAgICBsZW5ndGggPSAoa2V5cyB8fCBvYmopLmxlbmd0aDtcbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICB2YXIgY3VycmVudEtleSA9IGtleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4O1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaikpIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH07XG5cbiAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBhcnJheSBvciBvYmplY3QgY29udGFpbnMgYSBnaXZlbiBpdGVtICh1c2luZyBgPT09YCkuXG4gIC8vIEFsaWFzZWQgYXMgYGluY2x1ZGVzYCBhbmQgYGluY2x1ZGVgLlxuICBfLmNvbnRhaW5zID0gXy5pbmNsdWRlcyA9IF8uaW5jbHVkZSA9IGZ1bmN0aW9uKG9iaiwgaXRlbSwgZnJvbUluZGV4LCBndWFyZCkge1xuICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICBpZiAodHlwZW9mIGZyb21JbmRleCAhPSAnbnVtYmVyJyB8fCBndWFyZCkgZnJvbUluZGV4ID0gMDtcbiAgICByZXR1cm4gXy5pbmRleE9mKG9iaiwgaXRlbSwgZnJvbUluZGV4KSA+PSAwO1xuICB9O1xuXG4gIC8vIEludm9rZSBhIG1ldGhvZCAod2l0aCBhcmd1bWVudHMpIG9uIGV2ZXJ5IGl0ZW0gaW4gYSBjb2xsZWN0aW9uLlxuICBfLmludm9rZSA9IGZ1bmN0aW9uKG9iaiwgbWV0aG9kKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGlzRnVuYyA9IF8uaXNGdW5jdGlvbihtZXRob2QpO1xuICAgIHJldHVybiBfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgZnVuYyA9IGlzRnVuYyA/IG1ldGhvZCA6IHZhbHVlW21ldGhvZF07XG4gICAgICByZXR1cm4gZnVuYyA9PSBudWxsID8gZnVuYyA6IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3MpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYG1hcGA6IGZldGNoaW5nIGEgcHJvcGVydHkuXG4gIF8ucGx1Y2sgPSBmdW5jdGlvbihvYmosIGtleSkge1xuICAgIHJldHVybiBfLm1hcChvYmosIF8ucHJvcGVydHkoa2V5KSk7XG4gIH07XG5cbiAgLy8gQ29udmVuaWVuY2UgdmVyc2lvbiBvZiBhIGNvbW1vbiB1c2UgY2FzZSBvZiBgZmlsdGVyYDogc2VsZWN0aW5nIG9ubHkgb2JqZWN0c1xuICAvLyBjb250YWluaW5nIHNwZWNpZmljIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLndoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbHRlcihvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbmRgOiBnZXR0aW5nIHRoZSBmaXJzdCBvYmplY3RcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5maW5kV2hlcmUgPSBmdW5jdGlvbihvYmosIGF0dHJzKSB7XG4gICAgcmV0dXJuIF8uZmluZChvYmosIF8ubWF0Y2hlcihhdHRycykpO1xuICB9O1xuXG4gIC8vIFJldHVybiB0aGUgbWF4aW11bSBlbGVtZW50IChvciBlbGVtZW50LWJhc2VkIGNvbXB1dGF0aW9uKS5cbiAgXy5tYXggPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IC1JbmZpbml0eSwgbGFzdENvbXB1dGVkID0gLUluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlID4gcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPiBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IC1JbmZpbml0eSAmJiByZXN1bHQgPT09IC1JbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1pbmltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWluID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSBJbmZpbml0eSwgbGFzdENvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIHZhbHVlLCBjb21wdXRlZDtcbiAgICBpZiAoaXRlcmF0ZWUgPT0gbnVsbCAmJiBvYmogIT0gbnVsbCkge1xuICAgICAgb2JqID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gb2JqLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhbHVlID0gb2JqW2ldO1xuICAgICAgICBpZiAodmFsdWUgPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdCk7XG4gICAgICAgIGlmIChjb21wdXRlZCA8IGxhc3RDb21wdXRlZCB8fCBjb21wdXRlZCA9PT0gSW5maW5pdHkgJiYgcmVzdWx0ID09PSBJbmZpbml0eSkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICAgIGxhc3RDb21wdXRlZCA9IGNvbXB1dGVkO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBTaHVmZmxlIGEgY29sbGVjdGlvbiwgdXNpbmcgdGhlIG1vZGVybiB2ZXJzaW9uIG9mIHRoZVxuICAvLyBbRmlzaGVyLVlhdGVzIHNodWZmbGVdKGh0dHA6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvRmlzaGVy4oCTWWF0ZXNfc2h1ZmZsZSkuXG4gIF8uc2h1ZmZsZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBzZXQgPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0gc2V0Lmxlbmd0aDtcbiAgICB2YXIgc2h1ZmZsZWQgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMCwgcmFuZDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJhbmQgPSBfLnJhbmRvbSgwLCBpbmRleCk7XG4gICAgICBpZiAocmFuZCAhPT0gaW5kZXgpIHNodWZmbGVkW2luZGV4XSA9IHNodWZmbGVkW3JhbmRdO1xuICAgICAgc2h1ZmZsZWRbcmFuZF0gPSBzZXRbaW5kZXhdO1xuICAgIH1cbiAgICByZXR1cm4gc2h1ZmZsZWQ7XG4gIH07XG5cbiAgLy8gU2FtcGxlICoqbioqIHJhbmRvbSB2YWx1ZXMgZnJvbSBhIGNvbGxlY3Rpb24uXG4gIC8vIElmICoqbioqIGlzIG5vdCBzcGVjaWZpZWQsIHJldHVybnMgYSBzaW5nbGUgcmFuZG9tIGVsZW1lbnQuXG4gIC8vIFRoZSBpbnRlcm5hbCBgZ3VhcmRgIGFyZ3VtZW50IGFsbG93cyBpdCB0byB3b3JrIHdpdGggYG1hcGAuXG4gIF8uc2FtcGxlID0gZnVuY3Rpb24ob2JqLCBuLCBndWFyZCkge1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHtcbiAgICAgIGlmICghaXNBcnJheUxpa2Uob2JqKSkgb2JqID0gXy52YWx1ZXMob2JqKTtcbiAgICAgIHJldHVybiBvYmpbXy5yYW5kb20ob2JqLmxlbmd0aCAtIDEpXTtcbiAgICB9XG4gICAgcmV0dXJuIF8uc2h1ZmZsZShvYmopLnNsaWNlKDAsIE1hdGgubWF4KDAsIG4pKTtcbiAgfTtcblxuICAvLyBTb3J0IHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24gcHJvZHVjZWQgYnkgYW4gaXRlcmF0ZWUuXG4gIF8uc29ydEJ5ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHJldHVybiBfLnBsdWNrKF8ubWFwKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgIGluZGV4OiBpbmRleCxcbiAgICAgICAgY3JpdGVyaWE6IGl0ZXJhdGVlKHZhbHVlLCBpbmRleCwgbGlzdClcbiAgICAgIH07XG4gICAgfSkuc29ydChmdW5jdGlvbihsZWZ0LCByaWdodCkge1xuICAgICAgdmFyIGEgPSBsZWZ0LmNyaXRlcmlhO1xuICAgICAgdmFyIGIgPSByaWdodC5jcml0ZXJpYTtcbiAgICAgIGlmIChhICE9PSBiKSB7XG4gICAgICAgIGlmIChhID4gYiB8fCBhID09PSB2b2lkIDApIHJldHVybiAxO1xuICAgICAgICBpZiAoYSA8IGIgfHwgYiA9PT0gdm9pZCAwKSByZXR1cm4gLTE7XG4gICAgICB9XG4gICAgICByZXR1cm4gbGVmdC5pbmRleCAtIHJpZ2h0LmluZGV4O1xuICAgIH0pLCAndmFsdWUnKTtcbiAgfTtcblxuICAvLyBBbiBpbnRlcm5hbCBmdW5jdGlvbiB1c2VkIGZvciBhZ2dyZWdhdGUgXCJncm91cCBieVwiIG9wZXJhdGlvbnMuXG4gIHZhciBncm91cCA9IGZ1bmN0aW9uKGJlaGF2aW9yKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4KSB7XG4gICAgICAgIHZhciBrZXkgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIG9iaik7XG4gICAgICAgIGJlaGF2aW9yKHJlc3VsdCwgdmFsdWUsIGtleSk7XG4gICAgICB9KTtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBHcm91cHMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbi4gUGFzcyBlaXRoZXIgYSBzdHJpbmcgYXR0cmlidXRlXG4gIC8vIHRvIGdyb3VwIGJ5LCBvciBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGUgY3JpdGVyaW9uLlxuICBfLmdyb3VwQnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICBpZiAoXy5oYXMocmVzdWx0LCBrZXkpKSByZXN1bHRba2V5XS5wdXNoKHZhbHVlKTsgZWxzZSByZXN1bHRba2V5XSA9IFt2YWx1ZV07XG4gIH0pO1xuXG4gIC8vIEluZGV4ZXMgdGhlIG9iamVjdCdzIHZhbHVlcyBieSBhIGNyaXRlcmlvbiwgc2ltaWxhciB0byBgZ3JvdXBCeWAsIGJ1dCBmb3JcbiAgLy8gd2hlbiB5b3Uga25vdyB0aGF0IHlvdXIgaW5kZXggdmFsdWVzIHdpbGwgYmUgdW5pcXVlLlxuICBfLmluZGV4QnkgPSBncm91cChmdW5jdGlvbihyZXN1bHQsIHZhbHVlLCBrZXkpIHtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9KTtcblxuICAvLyBDb3VudHMgaW5zdGFuY2VzIG9mIGFuIG9iamVjdCB0aGF0IGdyb3VwIGJ5IGEgY2VydGFpbiBjcml0ZXJpb24uIFBhc3NcbiAgLy8gZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZSB0byBjb3VudCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlXG4gIC8vIGNyaXRlcmlvbi5cbiAgXy5jb3VudEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0rKzsgZWxzZSByZXN1bHRba2V5XSA9IDE7XG4gIH0pO1xuXG4gIC8vIFNhZmVseSBjcmVhdGUgYSByZWFsLCBsaXZlIGFycmF5IGZyb20gYW55dGhpbmcgaXRlcmFibGUuXG4gIF8udG9BcnJheSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghb2JqKSByZXR1cm4gW107XG4gICAgaWYgKF8uaXNBcnJheShvYmopKSByZXR1cm4gc2xpY2UuY2FsbChvYmopO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopKSByZXR1cm4gXy5tYXAob2JqLCBfLmlkZW50aXR5KTtcbiAgICByZXR1cm4gXy52YWx1ZXMob2JqKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG51bWJlciBvZiBlbGVtZW50cyBpbiBhbiBvYmplY3QuXG4gIF8uc2l6ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIDA7XG4gICAgcmV0dXJuIGlzQXJyYXlMaWtlKG9iaikgPyBvYmoubGVuZ3RoIDogXy5rZXlzKG9iaikubGVuZ3RoO1xuICB9O1xuXG4gIC8vIFNwbGl0IGEgY29sbGVjdGlvbiBpbnRvIHR3byBhcnJheXM6IG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgc2F0aXNmeSB0aGUgZ2l2ZW5cbiAgLy8gcHJlZGljYXRlLCBhbmQgb25lIHdob3NlIGVsZW1lbnRzIGFsbCBkbyBub3Qgc2F0aXNmeSB0aGUgcHJlZGljYXRlLlxuICBfLnBhcnRpdGlvbiA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIgcGFzcyA9IFtdLCBmYWlsID0gW107XG4gICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqKSB7XG4gICAgICAocHJlZGljYXRlKHZhbHVlLCBrZXksIG9iaikgPyBwYXNzIDogZmFpbCkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIFtwYXNzLCBmYWlsXTtcbiAgfTtcblxuICAvLyBBcnJheSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gR2V0IHRoZSBmaXJzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBmaXJzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYGhlYWRgIGFuZCBgdGFrZWAuIFRoZSAqKmd1YXJkKiogY2hlY2tcbiAgLy8gYWxsb3dzIGl0IHRvIHdvcmsgd2l0aCBgXy5tYXBgLlxuICBfLmZpcnN0ID0gXy5oZWFkID0gXy50YWtlID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5WzBdO1xuICAgIHJldHVybiBfLmluaXRpYWwoYXJyYXksIGFycmF5Lmxlbmd0aCAtIG4pO1xuICB9O1xuXG4gIC8vIFJldHVybnMgZXZlcnl0aGluZyBidXQgdGhlIGxhc3QgZW50cnkgb2YgdGhlIGFycmF5LiBFc3BlY2lhbGx5IHVzZWZ1bCBvblxuICAvLyB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiBhbGwgdGhlIHZhbHVlcyBpblxuICAvLyB0aGUgYXJyYXksIGV4Y2x1ZGluZyB0aGUgbGFzdCBOLlxuICBfLmluaXRpYWwgPSBmdW5jdGlvbihhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gc2xpY2UuY2FsbChhcnJheSwgMCwgTWF0aC5tYXgoMCwgYXJyYXkubGVuZ3RoIC0gKG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKSkpO1xuICB9O1xuXG4gIC8vIEdldCB0aGUgbGFzdCBlbGVtZW50IG9mIGFuIGFycmF5LiBQYXNzaW5nICoqbioqIHdpbGwgcmV0dXJuIHRoZSBsYXN0IE5cbiAgLy8gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5sYXN0ID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5ID09IG51bGwpIHJldHVybiB2b2lkIDA7XG4gICAgaWYgKG4gPT0gbnVsbCB8fCBndWFyZCkgcmV0dXJuIGFycmF5W2FycmF5Lmxlbmd0aCAtIDFdO1xuICAgIHJldHVybiBfLnJlc3QoYXJyYXksIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIG4pKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBmaXJzdCBlbnRyeSBvZiB0aGUgYXJyYXkuIEFsaWFzZWQgYXMgYHRhaWxgIGFuZCBgZHJvcGAuXG4gIC8vIEVzcGVjaWFsbHkgdXNlZnVsIG9uIHRoZSBhcmd1bWVudHMgb2JqZWN0LiBQYXNzaW5nIGFuICoqbioqIHdpbGwgcmV0dXJuXG4gIC8vIHRoZSByZXN0IE4gdmFsdWVzIGluIHRoZSBhcnJheS5cbiAgXy5yZXN0ID0gXy50YWlsID0gXy5kcm9wID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIG4gPT0gbnVsbCB8fCBndWFyZCA/IDEgOiBuKTtcbiAgfTtcblxuICAvLyBUcmltIG91dCBhbGwgZmFsc3kgdmFsdWVzIGZyb20gYW4gYXJyYXkuXG4gIF8uY29tcGFjdCA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBfLmlkZW50aXR5KTtcbiAgfTtcblxuICAvLyBJbnRlcm5hbCBpbXBsZW1lbnRhdGlvbiBvZiBhIHJlY3Vyc2l2ZSBgZmxhdHRlbmAgZnVuY3Rpb24uXG4gIHZhciBmbGF0dGVuID0gZnVuY3Rpb24oaW5wdXQsIHNoYWxsb3csIHN0cmljdCwgc3RhcnRJbmRleCkge1xuICAgIHZhciBvdXRwdXQgPSBbXSwgaWR4ID0gMDtcbiAgICBmb3IgKHZhciBpID0gc3RhcnRJbmRleCB8fCAwLCBsZW5ndGggPSBnZXRMZW5ndGgoaW5wdXQpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciB2YWx1ZSA9IGlucHV0W2ldO1xuICAgICAgaWYgKGlzQXJyYXlMaWtlKHZhbHVlKSAmJiAoXy5pc0FycmF5KHZhbHVlKSB8fCBfLmlzQXJndW1lbnRzKHZhbHVlKSkpIHtcbiAgICAgICAgLy9mbGF0dGVuIGN1cnJlbnQgbGV2ZWwgb2YgYXJyYXkgb3IgYXJndW1lbnRzIG9iamVjdFxuICAgICAgICBpZiAoIXNoYWxsb3cpIHZhbHVlID0gZmxhdHRlbih2YWx1ZSwgc2hhbGxvdywgc3RyaWN0KTtcbiAgICAgICAgdmFyIGogPSAwLCBsZW4gPSB2YWx1ZS5sZW5ndGg7XG4gICAgICAgIG91dHB1dC5sZW5ndGggKz0gbGVuO1xuICAgICAgICB3aGlsZSAoaiA8IGxlbikge1xuICAgICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZVtqKytdO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKCFzdHJpY3QpIHtcbiAgICAgICAgb3V0cHV0W2lkeCsrXSA9IHZhbHVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gb3V0cHV0O1xuICB9O1xuXG4gIC8vIEZsYXR0ZW4gb3V0IGFuIGFycmF5LCBlaXRoZXIgcmVjdXJzaXZlbHkgKGJ5IGRlZmF1bHQpLCBvciBqdXN0IG9uZSBsZXZlbC5cbiAgXy5mbGF0dGVuID0gZnVuY3Rpb24oYXJyYXksIHNoYWxsb3cpIHtcbiAgICByZXR1cm4gZmxhdHRlbihhcnJheSwgc2hhbGxvdywgZmFsc2UpO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHZlcnNpb24gb2YgdGhlIGFycmF5IHRoYXQgZG9lcyBub3QgY29udGFpbiB0aGUgc3BlY2lmaWVkIHZhbHVlKHMpLlxuICBfLndpdGhvdXQgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmRpZmZlcmVuY2UoYXJyYXksIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhIGR1cGxpY2F0ZS1mcmVlIHZlcnNpb24gb2YgdGhlIGFycmF5LiBJZiB0aGUgYXJyYXkgaGFzIGFscmVhZHlcbiAgLy8gYmVlbiBzb3J0ZWQsIHlvdSBoYXZlIHRoZSBvcHRpb24gb2YgdXNpbmcgYSBmYXN0ZXIgYWxnb3JpdGhtLlxuICAvLyBBbGlhc2VkIGFzIGB1bmlxdWVgLlxuICBfLnVuaXEgPSBfLnVuaXF1ZSA9IGZ1bmN0aW9uKGFycmF5LCBpc1NvcnRlZCwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoIV8uaXNCb29sZWFuKGlzU29ydGVkKSkge1xuICAgICAgY29udGV4dCA9IGl0ZXJhdGVlO1xuICAgICAgaXRlcmF0ZWUgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChpdGVyYXRlZSAhPSBudWxsKSBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIHNlZW4gPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpXSxcbiAgICAgICAgICBjb21wdXRlZCA9IGl0ZXJhdGVlID8gaXRlcmF0ZWUodmFsdWUsIGksIGFycmF5KSA6IHZhbHVlO1xuICAgICAgaWYgKGlzU29ydGVkKSB7XG4gICAgICAgIGlmICghaSB8fCBzZWVuICE9PSBjb21wdXRlZCkgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgICBzZWVuID0gY29tcHV0ZWQ7XG4gICAgICB9IGVsc2UgaWYgKGl0ZXJhdGVlKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhzZWVuLCBjb21wdXRlZCkpIHtcbiAgICAgICAgICBzZWVuLnB1c2goY29tcHV0ZWQpO1xuICAgICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghXy5jb250YWlucyhyZXN1bHQsIHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUHJvZHVjZSBhbiBhcnJheSB0aGF0IGNvbnRhaW5zIHRoZSB1bmlvbjogZWFjaCBkaXN0aW5jdCBlbGVtZW50IGZyb20gYWxsIG9mXG4gIC8vIHRoZSBwYXNzZWQtaW4gYXJyYXlzLlxuICBfLnVuaW9uID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW5pcShmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyBldmVyeSBpdGVtIHNoYXJlZCBiZXR3ZWVuIGFsbCB0aGVcbiAgLy8gcGFzc2VkLWluIGFycmF5cy5cbiAgXy5pbnRlcnNlY3Rpb24gPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICB2YXIgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBhcnJheVtpXTtcbiAgICAgIGlmIChfLmNvbnRhaW5zKHJlc3VsdCwgaXRlbSkpIGNvbnRpbnVlO1xuICAgICAgZm9yICh2YXIgaiA9IDE7IGogPCBhcmdzTGVuZ3RoOyBqKyspIHtcbiAgICAgICAgaWYgKCFfLmNvbnRhaW5zKGFyZ3VtZW50c1tqXSwgaXRlbSkpIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGogPT09IGFyZ3NMZW5ndGgpIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFRha2UgdGhlIGRpZmZlcmVuY2UgYmV0d2VlbiBvbmUgYXJyYXkgYW5kIGEgbnVtYmVyIG9mIG90aGVyIGFycmF5cy5cbiAgLy8gT25seSB0aGUgZWxlbWVudHMgcHJlc2VudCBpbiBqdXN0IHRoZSBmaXJzdCBhcnJheSB3aWxsIHJlbWFpbi5cbiAgXy5kaWZmZXJlbmNlID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdCA9IGZsYXR0ZW4oYXJndW1lbnRzLCB0cnVlLCB0cnVlLCAxKTtcbiAgICByZXR1cm4gXy5maWx0ZXIoYXJyYXksIGZ1bmN0aW9uKHZhbHVlKXtcbiAgICAgIHJldHVybiAhXy5jb250YWlucyhyZXN0LCB2YWx1ZSk7XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gWmlwIHRvZ2V0aGVyIG11bHRpcGxlIGxpc3RzIGludG8gYSBzaW5nbGUgYXJyYXkgLS0gZWxlbWVudHMgdGhhdCBzaGFyZVxuICAvLyBhbiBpbmRleCBnbyB0b2dldGhlci5cbiAgXy56aXAgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gXy51bnppcChhcmd1bWVudHMpO1xuICB9O1xuXG4gIC8vIENvbXBsZW1lbnQgb2YgXy56aXAuIFVuemlwIGFjY2VwdHMgYW4gYXJyYXkgb2YgYXJyYXlzIGFuZCBncm91cHNcbiAgLy8gZWFjaCBhcnJheSdzIGVsZW1lbnRzIG9uIHNoYXJlZCBpbmRpY2VzXG4gIF8udW56aXAgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHZhciBsZW5ndGggPSBhcnJheSAmJiBfLm1heChhcnJheSwgZ2V0TGVuZ3RoKS5sZW5ndGggfHwgMDtcbiAgICB2YXIgcmVzdWx0ID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBfLnBsdWNrKGFycmF5LCBpbmRleCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ29udmVydHMgbGlzdHMgaW50byBvYmplY3RzLiBQYXNzIGVpdGhlciBhIHNpbmdsZSBhcnJheSBvZiBgW2tleSwgdmFsdWVdYFxuICAvLyBwYWlycywgb3IgdHdvIHBhcmFsbGVsIGFycmF5cyBvZiB0aGUgc2FtZSBsZW5ndGggLS0gb25lIG9mIGtleXMsIGFuZCBvbmUgb2ZcbiAgLy8gdGhlIGNvcnJlc3BvbmRpbmcgdmFsdWVzLlxuICBfLm9iamVjdCA9IGZ1bmN0aW9uKGxpc3QsIHZhbHVlcykge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGxpc3QpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1dID0gdmFsdWVzW2ldO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2xpc3RbaV1bMF1dID0gbGlzdFtpXVsxXTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBHZW5lcmF0b3IgZnVuY3Rpb24gdG8gY3JlYXRlIHRoZSBmaW5kSW5kZXggYW5kIGZpbmRMYXN0SW5kZXggZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKGRpcikge1xuICAgIHJldHVybiBmdW5jdGlvbihhcnJheSwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgICBwcmVkaWNhdGUgPSBjYihwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgICAgdmFyIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7XG4gICAgICB2YXIgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIGlmIChwcmVkaWNhdGUoYXJyYXlbaW5kZXhdLCBpbmRleCwgYXJyYXkpKSByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGluZGV4IG9uIGFuIGFycmF5LWxpa2UgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRJbmRleCA9IGNyZWF0ZVByZWRpY2F0ZUluZGV4RmluZGVyKDEpO1xuICBfLmZpbmRMYXN0SW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigtMSk7XG5cbiAgLy8gVXNlIGEgY29tcGFyYXRvciBmdW5jdGlvbiB0byBmaWd1cmUgb3V0IHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaFxuICAvLyBhbiBvYmplY3Qgc2hvdWxkIGJlIGluc2VydGVkIHNvIGFzIHRvIG1haW50YWluIG9yZGVyLiBVc2VzIGJpbmFyeSBzZWFyY2guXG4gIF8uc29ydGVkSW5kZXggPSBmdW5jdGlvbihhcnJheSwgb2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQsIDEpO1xuICAgIHZhciB2YWx1ZSA9IGl0ZXJhdGVlKG9iaik7XG4gICAgdmFyIGxvdyA9IDAsIGhpZ2ggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gTWF0aC5mbG9vcigobG93ICsgaGlnaCkgLyAyKTtcbiAgICAgIGlmIChpdGVyYXRlZShhcnJheVttaWRdKSA8IHZhbHVlKSBsb3cgPSBtaWQgKyAxOyBlbHNlIGhpZ2ggPSBtaWQ7XG4gICAgfVxuICAgIHJldHVybiBsb3c7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgaW5kZXhPZiBhbmQgbGFzdEluZGV4T2YgZnVuY3Rpb25zXG4gIGZ1bmN0aW9uIGNyZWF0ZUluZGV4RmluZGVyKGRpciwgcHJlZGljYXRlRmluZCwgc29ydGVkSW5kZXgpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIGl0ZW0sIGlkeCkge1xuICAgICAgdmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgaWYgKHR5cGVvZiBpZHggPT0gJ251bWJlcicpIHtcbiAgICAgICAgaWYgKGRpciA+IDApIHtcbiAgICAgICAgICAgIGkgPSBpZHggPj0gMCA/IGlkeCA6IE1hdGgubWF4KGlkeCArIGxlbmd0aCwgaSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBsZW5ndGggPSBpZHggPj0gMCA/IE1hdGgubWluKGlkeCArIDEsIGxlbmd0aCkgOiBpZHggKyBsZW5ndGggKyAxO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHNvcnRlZEluZGV4ICYmIGlkeCAmJiBsZW5ndGgpIHtcbiAgICAgICAgaWR4ID0gc29ydGVkSW5kZXgoYXJyYXksIGl0ZW0pO1xuICAgICAgICByZXR1cm4gYXJyYXlbaWR4XSA9PT0gaXRlbSA/IGlkeCA6IC0xO1xuICAgICAgfVxuICAgICAgaWYgKGl0ZW0gIT09IGl0ZW0pIHtcbiAgICAgICAgaWR4ID0gcHJlZGljYXRlRmluZChzbGljZS5jYWxsKGFycmF5LCBpLCBsZW5ndGgpLCBfLmlzTmFOKTtcbiAgICAgICAgcmV0dXJuIGlkeCA+PSAwID8gaWR4ICsgaSA6IC0xO1xuICAgICAgfVxuICAgICAgZm9yIChpZHggPSBkaXIgPiAwID8gaSA6IGxlbmd0aCAtIDE7IGlkeCA+PSAwICYmIGlkeCA8IGxlbmd0aDsgaWR4ICs9IGRpcikge1xuICAgICAgICBpZiAoYXJyYXlbaWR4XSA9PT0gaXRlbSkgcmV0dXJuIGlkeDtcbiAgICAgIH1cbiAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuICB9XG5cbiAgLy8gUmV0dXJuIHRoZSBwb3NpdGlvbiBvZiB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBhbiBpdGVtIGluIGFuIGFycmF5LFxuICAvLyBvciAtMSBpZiB0aGUgaXRlbSBpcyBub3QgaW5jbHVkZWQgaW4gdGhlIGFycmF5LlxuICAvLyBJZiB0aGUgYXJyYXkgaXMgbGFyZ2UgYW5kIGFscmVhZHkgaW4gc29ydCBvcmRlciwgcGFzcyBgdHJ1ZWBcbiAgLy8gZm9yICoqaXNTb3J0ZWQqKiB0byB1c2UgYmluYXJ5IHNlYXJjaC5cbiAgXy5pbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoMSwgXy5maW5kSW5kZXgsIF8uc29ydGVkSW5kZXgpO1xuICBfLmxhc3RJbmRleE9mID0gY3JlYXRlSW5kZXhGaW5kZXIoLTEsIF8uZmluZExhc3RJbmRleCk7XG5cbiAgLy8gR2VuZXJhdGUgYW4gaW50ZWdlciBBcnJheSBjb250YWluaW5nIGFuIGFyaXRobWV0aWMgcHJvZ3Jlc3Npb24uIEEgcG9ydCBvZlxuICAvLyB0aGUgbmF0aXZlIFB5dGhvbiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZVxuICAvLyBbdGhlIFB5dGhvbiBkb2N1bWVudGF0aW9uXShodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UpLlxuICBfLnJhbmdlID0gZnVuY3Rpb24oc3RhcnQsIHN0b3AsIHN0ZXApIHtcbiAgICBpZiAoc3RvcCA9PSBudWxsKSB7XG4gICAgICBzdG9wID0gc3RhcnQgfHwgMDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgc3RlcCA9IHN0ZXAgfHwgMTtcblxuICAgIHZhciBsZW5ndGggPSBNYXRoLm1heChNYXRoLmNlaWwoKHN0b3AgLSBzdGFydCkgLyBzdGVwKSwgMCk7XG4gICAgdmFyIHJhbmdlID0gQXJyYXkobGVuZ3RoKTtcblxuICAgIGZvciAodmFyIGlkeCA9IDA7IGlkeCA8IGxlbmd0aDsgaWR4KyssIHN0YXJ0ICs9IHN0ZXApIHtcbiAgICAgIHJhbmdlW2lkeF0gPSBzdGFydDtcbiAgICB9XG5cbiAgICByZXR1cm4gcmFuZ2U7XG4gIH07XG5cbiAgLy8gRnVuY3Rpb24gKGFoZW0pIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBEZXRlcm1pbmVzIHdoZXRoZXIgdG8gZXhlY3V0ZSBhIGZ1bmN0aW9uIGFzIGEgY29uc3RydWN0b3JcbiAgLy8gb3IgYSBub3JtYWwgZnVuY3Rpb24gd2l0aCB0aGUgcHJvdmlkZWQgYXJndW1lbnRzXG4gIHZhciBleGVjdXRlQm91bmQgPSBmdW5jdGlvbihzb3VyY2VGdW5jLCBib3VuZEZ1bmMsIGNvbnRleHQsIGNhbGxpbmdDb250ZXh0LCBhcmdzKSB7XG4gICAgaWYgKCEoY2FsbGluZ0NvbnRleHQgaW5zdGFuY2VvZiBib3VuZEZ1bmMpKSByZXR1cm4gc291cmNlRnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICB2YXIgc2VsZiA9IGJhc2VDcmVhdGUoc291cmNlRnVuYy5wcm90b3R5cGUpO1xuICAgIHZhciByZXN1bHQgPSBzb3VyY2VGdW5jLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICAgIGlmIChfLmlzT2JqZWN0KHJlc3VsdCkpIHJldHVybiByZXN1bHQ7XG4gICAgcmV0dXJuIHNlbGY7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgZnVuY3Rpb24gYm91bmQgdG8gYSBnaXZlbiBvYmplY3QgKGFzc2lnbmluZyBgdGhpc2AsIGFuZCBhcmd1bWVudHMsXG4gIC8vIG9wdGlvbmFsbHkpLiBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgRnVuY3Rpb24uYmluZGAgaWZcbiAgLy8gYXZhaWxhYmxlLlxuICBfLmJpbmQgPSBmdW5jdGlvbihmdW5jLCBjb250ZXh0KSB7XG4gICAgaWYgKG5hdGl2ZUJpbmQgJiYgZnVuYy5iaW5kID09PSBuYXRpdmVCaW5kKSByZXR1cm4gbmF0aXZlQmluZC5hcHBseShmdW5jLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICAgIGlmICghXy5pc0Z1bmN0aW9uKGZ1bmMpKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdCaW5kIG11c3QgYmUgY2FsbGVkIG9uIGEgZnVuY3Rpb24nKTtcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAyKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIGNvbnRleHQsIHRoaXMsIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSkpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIFBhcnRpYWxseSBhcHBseSBhIGZ1bmN0aW9uIGJ5IGNyZWF0aW5nIGEgdmVyc2lvbiB0aGF0IGhhcyBoYWQgc29tZSBvZiBpdHNcbiAgLy8gYXJndW1lbnRzIHByZS1maWxsZWQsIHdpdGhvdXQgY2hhbmdpbmcgaXRzIGR5bmFtaWMgYHRoaXNgIGNvbnRleHQuIF8gYWN0c1xuICAvLyBhcyBhIHBsYWNlaG9sZGVyLCBhbGxvd2luZyBhbnkgY29tYmluYXRpb24gb2YgYXJndW1lbnRzIHRvIGJlIHByZS1maWxsZWQuXG4gIF8ucGFydGlhbCA9IGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICB2YXIgYm91bmRBcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpO1xuICAgIHZhciBib3VuZCA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHBvc2l0aW9uID0gMCwgbGVuZ3RoID0gYm91bmRBcmdzLmxlbmd0aDtcbiAgICAgIHZhciBhcmdzID0gQXJyYXkobGVuZ3RoKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgYXJnc1tpXSA9IGJvdW5kQXJnc1tpXSA9PT0gXyA/IGFyZ3VtZW50c1twb3NpdGlvbisrXSA6IGJvdW5kQXJnc1tpXTtcbiAgICAgIH1cbiAgICAgIHdoaWxlIChwb3NpdGlvbiA8IGFyZ3VtZW50cy5sZW5ndGgpIGFyZ3MucHVzaChhcmd1bWVudHNbcG9zaXRpb24rK10pO1xuICAgICAgcmV0dXJuIGV4ZWN1dGVCb3VuZChmdW5jLCBib3VuZCwgdGhpcywgdGhpcywgYXJncyk7XG4gICAgfTtcbiAgICByZXR1cm4gYm91bmQ7XG4gIH07XG5cbiAgLy8gQmluZCBhIG51bWJlciBvZiBhbiBvYmplY3QncyBtZXRob2RzIHRvIHRoYXQgb2JqZWN0LiBSZW1haW5pbmcgYXJndW1lbnRzXG4gIC8vIGFyZSB0aGUgbWV0aG9kIG5hbWVzIHRvIGJlIGJvdW5kLiBVc2VmdWwgZm9yIGVuc3VyaW5nIHRoYXQgYWxsIGNhbGxiYWNrc1xuICAvLyBkZWZpbmVkIG9uIGFuIG9iamVjdCBiZWxvbmcgdG8gaXQuXG4gIF8uYmluZEFsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpLCBsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLCBrZXk7XG4gICAgaWYgKGxlbmd0aCA8PSAxKSB0aHJvdyBuZXcgRXJyb3IoJ2JpbmRBbGwgbXVzdCBiZSBwYXNzZWQgZnVuY3Rpb24gbmFtZXMnKTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgIG9ialtrZXldID0gXy5iaW5kKG9ialtrZXldLCBvYmopO1xuICAgIH1cbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIE1lbW9pemUgYW4gZXhwZW5zaXZlIGZ1bmN0aW9uIGJ5IHN0b3JpbmcgaXRzIHJlc3VsdHMuXG4gIF8ubWVtb2l6ZSA9IGZ1bmN0aW9uKGZ1bmMsIGhhc2hlcikge1xuICAgIHZhciBtZW1vaXplID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgICB2YXIgY2FjaGUgPSBtZW1vaXplLmNhY2hlO1xuICAgICAgdmFyIGFkZHJlc3MgPSAnJyArIChoYXNoZXIgPyBoYXNoZXIuYXBwbHkodGhpcywgYXJndW1lbnRzKSA6IGtleSk7XG4gICAgICBpZiAoIV8uaGFzKGNhY2hlLCBhZGRyZXNzKSkgY2FjaGVbYWRkcmVzc10gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gY2FjaGVbYWRkcmVzc107XG4gICAgfTtcbiAgICBtZW1vaXplLmNhY2hlID0ge307XG4gICAgcmV0dXJuIG1lbW9pemU7XG4gIH07XG5cbiAgLy8gRGVsYXlzIGEgZnVuY3Rpb24gZm9yIHRoZSBnaXZlbiBudW1iZXIgb2YgbWlsbGlzZWNvbmRzLCBhbmQgdGhlbiBjYWxsc1xuICAvLyBpdCB3aXRoIHRoZSBhcmd1bWVudHMgc3VwcGxpZWQuXG4gIF8uZGVsYXkgPSBmdW5jdGlvbihmdW5jLCB3YWl0KSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiBmdW5jLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH0sIHdhaXQpO1xuICB9O1xuXG4gIC8vIERlZmVycyBhIGZ1bmN0aW9uLCBzY2hlZHVsaW5nIGl0IHRvIHJ1biBhZnRlciB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhc1xuICAvLyBjbGVhcmVkLlxuICBfLmRlZmVyID0gXy5wYXJ0aWFsKF8uZGVsYXksIF8sIDEpO1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgd2hlbiBpbnZva2VkLCB3aWxsIG9ubHkgYmUgdHJpZ2dlcmVkIGF0IG1vc3Qgb25jZVxuICAvLyBkdXJpbmcgYSBnaXZlbiB3aW5kb3cgb2YgdGltZS4gTm9ybWFsbHksIHRoZSB0aHJvdHRsZWQgZnVuY3Rpb24gd2lsbCBydW5cbiAgLy8gYXMgbXVjaCBhcyBpdCBjYW4sIHdpdGhvdXQgZXZlciBnb2luZyBtb3JlIHRoYW4gb25jZSBwZXIgYHdhaXRgIGR1cmF0aW9uO1xuICAvLyBidXQgaWYgeW91J2QgbGlrZSB0byBkaXNhYmxlIHRoZSBleGVjdXRpb24gb24gdGhlIGxlYWRpbmcgZWRnZSwgcGFzc1xuICAvLyBge2xlYWRpbmc6IGZhbHNlfWAuIFRvIGRpc2FibGUgZXhlY3V0aW9uIG9uIHRoZSB0cmFpbGluZyBlZGdlLCBkaXR0by5cbiAgXy50aHJvdHRsZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIG9wdGlvbnMpIHtcbiAgICB2YXIgY29udGV4dCwgYXJncywgcmVzdWx0O1xuICAgIHZhciB0aW1lb3V0ID0gbnVsbDtcbiAgICB2YXIgcHJldmlvdXMgPSAwO1xuICAgIGlmICghb3B0aW9ucykgb3B0aW9ucyA9IHt9O1xuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgcHJldmlvdXMgPSBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlID8gMCA6IF8ubm93KCk7XG4gICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICB9O1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBub3cgPSBfLm5vdygpO1xuICAgICAgaWYgKCFwcmV2aW91cyAmJiBvcHRpb25zLmxlYWRpbmcgPT09IGZhbHNlKSBwcmV2aW91cyA9IG5vdztcbiAgICAgIHZhciByZW1haW5pbmcgPSB3YWl0IC0gKG5vdyAtIHByZXZpb3VzKTtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIGlmIChyZW1haW5pbmcgPD0gMCB8fCByZW1haW5pbmcgPiB3YWl0KSB7XG4gICAgICAgIGlmICh0aW1lb3V0KSB7XG4gICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xuICAgICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHByZXZpb3VzID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBpZiAoIXRpbWVvdXQpIGNvbnRleHQgPSBhcmdzID0gbnVsbDtcbiAgICAgIH0gZWxzZSBpZiAoIXRpbWVvdXQgJiYgb3B0aW9ucy50cmFpbGluZyAhPT0gZmFsc2UpIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHJlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uLCB0aGF0LCBhcyBsb25nIGFzIGl0IGNvbnRpbnVlcyB0byBiZSBpbnZva2VkLCB3aWxsIG5vdFxuICAvLyBiZSB0cmlnZ2VyZWQuIFRoZSBmdW5jdGlvbiB3aWxsIGJlIGNhbGxlZCBhZnRlciBpdCBzdG9wcyBiZWluZyBjYWxsZWQgZm9yXG4gIC8vIE4gbWlsbGlzZWNvbmRzLiBJZiBgaW1tZWRpYXRlYCBpcyBwYXNzZWQsIHRyaWdnZXIgdGhlIGZ1bmN0aW9uIG9uIHRoZVxuICAvLyBsZWFkaW5nIGVkZ2UsIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLlxuICBfLmRlYm91bmNlID0gZnVuY3Rpb24oZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIHRpbWVvdXQsIGFyZ3MsIGNvbnRleHQsIHRpbWVzdGFtcCwgcmVzdWx0O1xuXG4gICAgdmFyIGxhdGVyID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGFzdCA9IF8ubm93KCkgLSB0aW1lc3RhbXA7XG5cbiAgICAgIGlmIChsYXN0IDwgd2FpdCAmJiBsYXN0ID49IDApIHtcbiAgICAgICAgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQgLSBsYXN0KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRpbWVvdXQgPSBudWxsO1xuICAgICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgY29udGV4dCA9IHRoaXM7XG4gICAgICBhcmdzID0gYXJndW1lbnRzO1xuICAgICAgdGltZXN0YW1wID0gXy5ub3coKTtcbiAgICAgIHZhciBjYWxsTm93ID0gaW1tZWRpYXRlICYmICF0aW1lb3V0O1xuICAgICAgaWYgKCF0aW1lb3V0KSB0aW1lb3V0ID0gc2V0VGltZW91dChsYXRlciwgd2FpdCk7XG4gICAgICBpZiAoY2FsbE5vdykge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBmdW5jdGlvbiBwYXNzZWQgYXMgYW4gYXJndW1lbnQgdG8gdGhlIHNlY29uZCxcbiAgLy8gYWxsb3dpbmcgeW91IHRvIGFkanVzdCBhcmd1bWVudHMsIHJ1biBjb2RlIGJlZm9yZSBhbmQgYWZ0ZXIsIGFuZFxuICAvLyBjb25kaXRpb25hbGx5IGV4ZWN1dGUgdGhlIG9yaWdpbmFsIGZ1bmN0aW9uLlxuICBfLndyYXAgPSBmdW5jdGlvbihmdW5jLCB3cmFwcGVyKSB7XG4gICAgcmV0dXJuIF8ucGFydGlhbCh3cmFwcGVyLCBmdW5jKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgbmVnYXRlZCB2ZXJzaW9uIG9mIHRoZSBwYXNzZWQtaW4gcHJlZGljYXRlLlxuICBfLm5lZ2F0ZSA9IGZ1bmN0aW9uKHByZWRpY2F0ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAhcHJlZGljYXRlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCBpcyB0aGUgY29tcG9zaXRpb24gb2YgYSBsaXN0IG9mIGZ1bmN0aW9ucywgZWFjaFxuICAvLyBjb25zdW1pbmcgdGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgZnVuY3Rpb24gdGhhdCBmb2xsb3dzLlxuICBfLmNvbXBvc2UgPSBmdW5jdGlvbigpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cztcbiAgICB2YXIgc3RhcnQgPSBhcmdzLmxlbmd0aCAtIDE7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGkgPSBzdGFydDtcbiAgICAgIHZhciByZXN1bHQgPSBhcmdzW3N0YXJ0XS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgd2hpbGUgKGktLSkgcmVzdWx0ID0gYXJnc1tpXS5jYWxsKHRoaXMsIHJlc3VsdCk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIG9uIGFuZCBhZnRlciB0aGUgTnRoIGNhbGwuXG4gIF8uYWZ0ZXIgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzIDwgMSkge1xuICAgICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgd2lsbCBvbmx5IGJlIGV4ZWN1dGVkIHVwIHRvIChidXQgbm90IGluY2x1ZGluZykgdGhlIE50aCBjYWxsLlxuICBfLmJlZm9yZSA9IGZ1bmN0aW9uKHRpbWVzLCBmdW5jKSB7XG4gICAgdmFyIG1lbW87XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKC0tdGltZXMgPiAwKSB7XG4gICAgICAgIG1lbW8gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgICBpZiAodGltZXMgPD0gMSkgZnVuYyA9IG51bGw7XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgYXQgbW9zdCBvbmUgdGltZSwgbm8gbWF0dGVyIGhvd1xuICAvLyBvZnRlbiB5b3UgY2FsbCBpdC4gVXNlZnVsIGZvciBsYXp5IGluaXRpYWxpemF0aW9uLlxuICBfLm9uY2UgPSBfLnBhcnRpYWwoXy5iZWZvcmUsIDIpO1xuXG4gIC8vIE9iamVjdCBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEtleXMgaW4gSUUgPCA5IHRoYXQgd29uJ3QgYmUgaXRlcmF0ZWQgYnkgYGZvciBrZXkgaW4gLi4uYCBhbmQgdGh1cyBtaXNzZWQuXG4gIHZhciBoYXNFbnVtQnVnID0gIXt0b1N0cmluZzogbnVsbH0ucHJvcGVydHlJc0VudW1lcmFibGUoJ3RvU3RyaW5nJyk7XG4gIHZhciBub25FbnVtZXJhYmxlUHJvcHMgPSBbJ3ZhbHVlT2YnLCAnaXNQcm90b3R5cGVPZicsICd0b1N0cmluZycsXG4gICAgICAgICAgICAgICAgICAgICAgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJywgJ2hhc093blByb3BlcnR5JywgJ3RvTG9jYWxlU3RyaW5nJ107XG5cbiAgZnVuY3Rpb24gY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpIHtcbiAgICB2YXIgbm9uRW51bUlkeCA9IG5vbkVudW1lcmFibGVQcm9wcy5sZW5ndGg7XG4gICAgdmFyIGNvbnN0cnVjdG9yID0gb2JqLmNvbnN0cnVjdG9yO1xuICAgIHZhciBwcm90byA9IChfLmlzRnVuY3Rpb24oY29uc3RydWN0b3IpICYmIGNvbnN0cnVjdG9yLnByb3RvdHlwZSkgfHwgT2JqUHJvdG87XG5cbiAgICAvLyBDb25zdHJ1Y3RvciBpcyBhIHNwZWNpYWwgY2FzZS5cbiAgICB2YXIgcHJvcCA9ICdjb25zdHJ1Y3Rvcic7XG4gICAgaWYgKF8uaGFzKG9iaiwgcHJvcCkgJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIGtleXMucHVzaChwcm9wKTtcblxuICAgIHdoaWxlIChub25FbnVtSWR4LS0pIHtcbiAgICAgIHByb3AgPSBub25FbnVtZXJhYmxlUHJvcHNbbm9uRW51bUlkeF07XG4gICAgICBpZiAocHJvcCBpbiBvYmogJiYgb2JqW3Byb3BdICE9PSBwcm90b1twcm9wXSAmJiAhXy5jb250YWlucyhrZXlzLCBwcm9wKSkge1xuICAgICAgICBrZXlzLnB1c2gocHJvcCk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gUmV0cmlldmUgdGhlIG5hbWVzIG9mIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzLlxuICAvLyBEZWxlZ2F0ZXMgdG8gKipFQ01BU2NyaXB0IDUqKidzIG5hdGl2ZSBgT2JqZWN0LmtleXNgXG4gIF8ua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgaWYgKG5hdGl2ZUtleXMpIHJldHVybiBuYXRpdmVLZXlzKG9iaik7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBpZiAoXy5oYXMob2JqLCBrZXkpKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSBhbGwgdGhlIHByb3BlcnR5IG5hbWVzIG9mIGFuIG9iamVjdC5cbiAgXy5hbGxLZXlzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBbXTtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIGtleXMucHVzaChrZXkpO1xuICAgIC8vIEFoZW0sIElFIDwgOS5cbiAgICBpZiAoaGFzRW51bUJ1ZykgY29sbGVjdE5vbkVudW1Qcm9wcyhvYmosIGtleXMpO1xuICAgIHJldHVybiBrZXlzO1xuICB9O1xuXG4gIC8vIFJldHJpZXZlIHRoZSB2YWx1ZXMgb2YgYW4gb2JqZWN0J3MgcHJvcGVydGllcy5cbiAgXy52YWx1ZXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICB2YXIgdmFsdWVzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YWx1ZXNbaV0gPSBvYmpba2V5c1tpXV07XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZXM7XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgcmVzdWx0cyBvZiBhcHBseWluZyB0aGUgaXRlcmF0ZWUgdG8gZWFjaCBlbGVtZW50IG9mIHRoZSBvYmplY3RcbiAgLy8gSW4gY29udHJhc3QgdG8gXy5tYXAgaXQgcmV0dXJucyBhbiBvYmplY3RcbiAgXy5tYXBPYmplY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGgsXG4gICAgICAgICAgcmVzdWx0cyA9IHt9LFxuICAgICAgICAgIGN1cnJlbnRLZXk7XG4gICAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICAgIGN1cnJlbnRLZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgICAgcmVzdWx0c1tjdXJyZW50S2V5XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHRzO1xuICB9O1xuXG4gIC8vIENvbnZlcnQgYW4gb2JqZWN0IGludG8gYSBsaXN0IG9mIGBba2V5LCB2YWx1ZV1gIHBhaXJzLlxuICBfLnBhaXJzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHBhaXJzID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBwYWlyc1tpXSA9IFtrZXlzW2ldLCBvYmpba2V5c1tpXV1dO1xuICAgIH1cbiAgICByZXR1cm4gcGFpcnM7XG4gIH07XG5cbiAgLy8gSW52ZXJ0IHRoZSBrZXlzIGFuZCB2YWx1ZXMgb2YgYW4gb2JqZWN0LiBUaGUgdmFsdWVzIG11c3QgYmUgc2VyaWFsaXphYmxlLlxuICBfLmludmVydCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICByZXN1bHRbb2JqW2tleXNbaV1dXSA9IGtleXNbaV07XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgc29ydGVkIGxpc3Qgb2YgdGhlIGZ1bmN0aW9uIG5hbWVzIGF2YWlsYWJsZSBvbiB0aGUgb2JqZWN0LlxuICAvLyBBbGlhc2VkIGFzIGBtZXRob2RzYFxuICBfLmZ1bmN0aW9ucyA9IF8ubWV0aG9kcyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBuYW1lcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmIChfLmlzRnVuY3Rpb24ob2JqW2tleV0pKSBuYW1lcy5wdXNoKGtleSk7XG4gICAgfVxuICAgIHJldHVybiBuYW1lcy5zb3J0KCk7XG4gIH07XG5cbiAgLy8gRXh0ZW5kIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBwcm9wZXJ0aWVzIGluIHBhc3NlZC1pbiBvYmplY3QocykuXG4gIF8uZXh0ZW5kID0gY3JlYXRlQXNzaWduZXIoXy5hbGxLZXlzKTtcblxuICAvLyBBc3NpZ25zIGEgZ2l2ZW4gb2JqZWN0IHdpdGggYWxsIHRoZSBvd24gcHJvcGVydGllcyBpbiB0aGUgcGFzc2VkLWluIG9iamVjdChzKVxuICAvLyAoaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2Fzc2lnbilcbiAgXy5leHRlbmRPd24gPSBfLmFzc2lnbiA9IGNyZWF0ZUFzc2lnbmVyKF8ua2V5cyk7XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3Qga2V5IG9uIGFuIG9iamVjdCB0aGF0IHBhc3NlcyBhIHByZWRpY2F0ZSB0ZXN0XG4gIF8uZmluZEtleSA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICB2YXIga2V5cyA9IF8ua2V5cyhvYmopLCBrZXk7XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAocHJlZGljYXRlKG9ialtrZXldLCBrZXksIG9iaikpIHJldHVybiBrZXk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFJldHVybiBhIGNvcHkgb2YgdGhlIG9iamVjdCBvbmx5IGNvbnRhaW5pbmcgdGhlIHdoaXRlbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ucGljayA9IGZ1bmN0aW9uKG9iamVjdCwgb2l0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9LCBvYmogPSBvYmplY3QsIGl0ZXJhdGVlLCBrZXlzO1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKG9pdGVyYXRlZSkpIHtcbiAgICAgIGtleXMgPSBfLmFsbEtleXMob2JqKTtcbiAgICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihvaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXlzID0gZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikgeyByZXR1cm4ga2V5IGluIG9iajsgfTtcbiAgICAgIG9iaiA9IE9iamVjdChvYmopO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICB2YXIgdmFsdWUgPSBvYmpba2V5XTtcbiAgICAgIGlmIChpdGVyYXRlZSh2YWx1ZSwga2V5LCBvYmopKSByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgd2l0aG91dCB0aGUgYmxhY2tsaXN0ZWQgcHJvcGVydGllcy5cbiAgXy5vbWl0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGlmIChfLmlzRnVuY3Rpb24oaXRlcmF0ZWUpKSB7XG4gICAgICBpdGVyYXRlZSA9IF8ubmVnYXRlKGl0ZXJhdGVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGtleXMgPSBfLm1hcChmbGF0dGVuKGFyZ3VtZW50cywgZmFsc2UsIGZhbHNlLCAxKSwgU3RyaW5nKTtcbiAgICAgIGl0ZXJhdGVlID0gZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgICByZXR1cm4gIV8uY29udGFpbnMoa2V5cywga2V5KTtcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBfLnBpY2sob2JqLCBpdGVyYXRlZSwgY29udGV4dCk7XG4gIH07XG5cbiAgLy8gRmlsbCBpbiBhIGdpdmVuIG9iamVjdCB3aXRoIGRlZmF1bHQgcHJvcGVydGllcy5cbiAgXy5kZWZhdWx0cyA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cywgdHJ1ZSk7XG5cbiAgLy8gQ3JlYXRlcyBhbiBvYmplY3QgdGhhdCBpbmhlcml0cyBmcm9tIHRoZSBnaXZlbiBwcm90b3R5cGUgb2JqZWN0LlxuICAvLyBJZiBhZGRpdGlvbmFsIHByb3BlcnRpZXMgYXJlIHByb3ZpZGVkIHRoZW4gdGhleSB3aWxsIGJlIGFkZGVkIHRvIHRoZVxuICAvLyBjcmVhdGVkIG9iamVjdC5cbiAgXy5jcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUsIHByb3BzKSB7XG4gICAgdmFyIHJlc3VsdCA9IGJhc2VDcmVhdGUocHJvdG90eXBlKTtcbiAgICBpZiAocHJvcHMpIF8uZXh0ZW5kT3duKHJlc3VsdCwgcHJvcHMpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgKHNoYWxsb3ctY2xvbmVkKSBkdXBsaWNhdGUgb2YgYW4gb2JqZWN0LlxuICBfLmNsb25lID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgaWYgKCFfLmlzT2JqZWN0KG9iaikpIHJldHVybiBvYmo7XG4gICAgcmV0dXJuIF8uaXNBcnJheShvYmopID8gb2JqLnNsaWNlKCkgOiBfLmV4dGVuZCh7fSwgb2JqKTtcbiAgfTtcblxuICAvLyBJbnZva2VzIGludGVyY2VwdG9yIHdpdGggdGhlIG9iaiwgYW5kIHRoZW4gcmV0dXJucyBvYmouXG4gIC8vIFRoZSBwcmltYXJ5IHB1cnBvc2Ugb2YgdGhpcyBtZXRob2QgaXMgdG8gXCJ0YXAgaW50b1wiIGEgbWV0aG9kIGNoYWluLCBpblxuICAvLyBvcmRlciB0byBwZXJmb3JtIG9wZXJhdGlvbnMgb24gaW50ZXJtZWRpYXRlIHJlc3VsdHMgd2l0aGluIHRoZSBjaGFpbi5cbiAgXy50YXAgPSBmdW5jdGlvbihvYmosIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3Iob2JqKTtcbiAgICByZXR1cm4gb2JqO1xuICB9O1xuXG4gIC8vIFJldHVybnMgd2hldGhlciBhbiBvYmplY3QgaGFzIGEgZ2l2ZW4gc2V0IG9mIGBrZXk6dmFsdWVgIHBhaXJzLlxuICBfLmlzTWF0Y2ggPSBmdW5jdGlvbihvYmplY3QsIGF0dHJzKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMoYXR0cnMpLCBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICBpZiAob2JqZWN0ID09IG51bGwpIHJldHVybiAhbGVuZ3RoO1xuICAgIHZhciBvYmogPSBPYmplY3Qob2JqZWN0KTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgIGlmIChhdHRyc1trZXldICE9PSBvYmpba2V5XSB8fCAhKGtleSBpbiBvYmopKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG5cbiAgLy8gSW50ZXJuYWwgcmVjdXJzaXZlIGNvbXBhcmlzb24gZnVuY3Rpb24gZm9yIGBpc0VxdWFsYC5cbiAgdmFyIGVxID0gZnVuY3Rpb24oYSwgYiwgYVN0YWNrLCBiU3RhY2spIHtcbiAgICAvLyBJZGVudGljYWwgb2JqZWN0cyBhcmUgZXF1YWwuIGAwID09PSAtMGAsIGJ1dCB0aGV5IGFyZW4ndCBpZGVudGljYWwuXG4gICAgLy8gU2VlIHRoZSBbSGFybW9ueSBgZWdhbGAgcHJvcG9zYWxdKGh0dHA6Ly93aWtpLmVjbWFzY3JpcHQub3JnL2Rva3UucGhwP2lkPWhhcm1vbnk6ZWdhbCkuXG4gICAgaWYgKGEgPT09IGIpIHJldHVybiBhICE9PSAwIHx8IDEgLyBhID09PSAxIC8gYjtcbiAgICAvLyBBIHN0cmljdCBjb21wYXJpc29uIGlzIG5lY2Vzc2FyeSBiZWNhdXNlIGBudWxsID09IHVuZGVmaW5lZGAuXG4gICAgaWYgKGEgPT0gbnVsbCB8fCBiID09IG51bGwpIHJldHVybiBhID09PSBiO1xuICAgIC8vIFVud3JhcCBhbnkgd3JhcHBlZCBvYmplY3RzLlxuICAgIGlmIChhIGluc3RhbmNlb2YgXykgYSA9IGEuX3dyYXBwZWQ7XG4gICAgaWYgKGIgaW5zdGFuY2VvZiBfKSBiID0gYi5fd3JhcHBlZDtcbiAgICAvLyBDb21wYXJlIGBbW0NsYXNzXV1gIG5hbWVzLlxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKGEpO1xuICAgIGlmIChjbGFzc05hbWUgIT09IHRvU3RyaW5nLmNhbGwoYikpIHJldHVybiBmYWxzZTtcbiAgICBzd2l0Y2ggKGNsYXNzTmFtZSkge1xuICAgICAgLy8gU3RyaW5ncywgbnVtYmVycywgcmVndWxhciBleHByZXNzaW9ucywgZGF0ZXMsIGFuZCBib29sZWFucyBhcmUgY29tcGFyZWQgYnkgdmFsdWUuXG4gICAgICBjYXNlICdbb2JqZWN0IFJlZ0V4cF0nOlxuICAgICAgLy8gUmVnRXhwcyBhcmUgY29lcmNlZCB0byBzdHJpbmdzIGZvciBjb21wYXJpc29uIChOb3RlOiAnJyArIC9hL2kgPT09ICcvYS9pJylcbiAgICAgIGNhc2UgJ1tvYmplY3QgU3RyaW5nXSc6XG4gICAgICAgIC8vIFByaW1pdGl2ZXMgYW5kIHRoZWlyIGNvcnJlc3BvbmRpbmcgb2JqZWN0IHdyYXBwZXJzIGFyZSBlcXVpdmFsZW50OyB0aHVzLCBgXCI1XCJgIGlzXG4gICAgICAgIC8vIGVxdWl2YWxlbnQgdG8gYG5ldyBTdHJpbmcoXCI1XCIpYC5cbiAgICAgICAgcmV0dXJuICcnICsgYSA9PT0gJycgKyBiO1xuICAgICAgY2FzZSAnW29iamVjdCBOdW1iZXJdJzpcbiAgICAgICAgLy8gYE5hTmBzIGFyZSBlcXVpdmFsZW50LCBidXQgbm9uLXJlZmxleGl2ZS5cbiAgICAgICAgLy8gT2JqZWN0KE5hTikgaXMgZXF1aXZhbGVudCB0byBOYU5cbiAgICAgICAgaWYgKCthICE9PSArYSkgcmV0dXJuICtiICE9PSArYjtcbiAgICAgICAgLy8gQW4gYGVnYWxgIGNvbXBhcmlzb24gaXMgcGVyZm9ybWVkIGZvciBvdGhlciBudW1lcmljIHZhbHVlcy5cbiAgICAgICAgcmV0dXJuICthID09PSAwID8gMSAvICthID09PSAxIC8gYiA6ICthID09PSArYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgRGF0ZV0nOlxuICAgICAgY2FzZSAnW29iamVjdCBCb29sZWFuXSc6XG4gICAgICAgIC8vIENvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtZXJpYyBwcmltaXRpdmUgdmFsdWVzLiBEYXRlcyBhcmUgY29tcGFyZWQgYnkgdGhlaXJcbiAgICAgICAgLy8gbWlsbGlzZWNvbmQgcmVwcmVzZW50YXRpb25zLiBOb3RlIHRoYXQgaW52YWxpZCBkYXRlcyB3aXRoIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9uc1xuICAgICAgICAvLyBvZiBgTmFOYCBhcmUgbm90IGVxdWl2YWxlbnQuXG4gICAgICAgIHJldHVybiArYSA9PT0gK2I7XG4gICAgfVxuXG4gICAgdmFyIGFyZUFycmF5cyA9IGNsYXNzTmFtZSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICBpZiAoIWFyZUFycmF5cykge1xuICAgICAgaWYgKHR5cGVvZiBhICE9ICdvYmplY3QnIHx8IHR5cGVvZiBiICE9ICdvYmplY3QnKSByZXR1cm4gZmFsc2U7XG5cbiAgICAgIC8vIE9iamVjdHMgd2l0aCBkaWZmZXJlbnQgY29uc3RydWN0b3JzIGFyZSBub3QgZXF1aXZhbGVudCwgYnV0IGBPYmplY3RgcyBvciBgQXJyYXlgc1xuICAgICAgLy8gZnJvbSBkaWZmZXJlbnQgZnJhbWVzIGFyZS5cbiAgICAgIHZhciBhQ3RvciA9IGEuY29uc3RydWN0b3IsIGJDdG9yID0gYi5jb25zdHJ1Y3RvcjtcbiAgICAgIGlmIChhQ3RvciAhPT0gYkN0b3IgJiYgIShfLmlzRnVuY3Rpb24oYUN0b3IpICYmIGFDdG9yIGluc3RhbmNlb2YgYUN0b3IgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfLmlzRnVuY3Rpb24oYkN0b3IpICYmIGJDdG9yIGluc3RhbmNlb2YgYkN0b3IpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICYmICgnY29uc3RydWN0b3InIGluIGEgJiYgJ2NvbnN0cnVjdG9yJyBpbiBiKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIEFzc3VtZSBlcXVhbGl0eSBmb3IgY3ljbGljIHN0cnVjdHVyZXMuIFRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWNcbiAgICAvLyBzdHJ1Y3R1cmVzIGlzIGFkYXB0ZWQgZnJvbSBFUyA1LjEgc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYC5cblxuICAgIC8vIEluaXRpYWxpemluZyBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICAvLyBJdCdzIGRvbmUgaGVyZSBzaW5jZSB3ZSBvbmx5IG5lZWQgdGhlbSBmb3Igb2JqZWN0cyBhbmQgYXJyYXlzIGNvbXBhcmlzb24uXG4gICAgYVN0YWNrID0gYVN0YWNrIHx8IFtdO1xuICAgIGJTdGFjayA9IGJTdGFjayB8fCBbXTtcbiAgICB2YXIgbGVuZ3RoID0gYVN0YWNrLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIC8vIExpbmVhciBzZWFyY2guIFBlcmZvcm1hbmNlIGlzIGludmVyc2VseSBwcm9wb3J0aW9uYWwgdG8gdGhlIG51bWJlciBvZlxuICAgICAgLy8gdW5pcXVlIG5lc3RlZCBzdHJ1Y3R1cmVzLlxuICAgICAgaWYgKGFTdGFja1tsZW5ndGhdID09PSBhKSByZXR1cm4gYlN0YWNrW2xlbmd0aF0gPT09IGI7XG4gICAgfVxuXG4gICAgLy8gQWRkIHRoZSBmaXJzdCBvYmplY3QgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wdXNoKGEpO1xuICAgIGJTdGFjay5wdXNoKGIpO1xuXG4gICAgLy8gUmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMuXG4gICAgaWYgKGFyZUFycmF5cykge1xuICAgICAgLy8gQ29tcGFyZSBhcnJheSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkuXG4gICAgICBsZW5ndGggPSBhLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggIT09IGIubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgdGhlIGNvbnRlbnRzLCBpZ25vcmluZyBub24tbnVtZXJpYyBwcm9wZXJ0aWVzLlxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGlmICghZXEoYVtsZW5ndGhdLCBiW2xlbmd0aF0sIGFTdGFjaywgYlN0YWNrKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBEZWVwIGNvbXBhcmUgb2JqZWN0cy5cbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKGEpLCBrZXk7XG4gICAgICBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiAgICAgIC8vIEVuc3VyZSB0aGF0IGJvdGggb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIG51bWJlciBvZiBwcm9wZXJ0aWVzIGJlZm9yZSBjb21wYXJpbmcgZGVlcCBlcXVhbGl0eS5cbiAgICAgIGlmIChfLmtleXMoYikubGVuZ3RoICE9PSBsZW5ndGgpIHJldHVybiBmYWxzZTtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICAvLyBEZWVwIGNvbXBhcmUgZWFjaCBtZW1iZXJcbiAgICAgICAga2V5ID0ga2V5c1tsZW5ndGhdO1xuICAgICAgICBpZiAoIShfLmhhcyhiLCBrZXkpICYmIGVxKGFba2V5XSwgYltrZXldLCBhU3RhY2ssIGJTdGFjaykpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIC8vIFJlbW92ZSB0aGUgZmlyc3Qgb2JqZWN0IGZyb20gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzLlxuICAgIGFTdGFjay5wb3AoKTtcbiAgICBiU3RhY2sucG9wKCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gUGVyZm9ybSBhIGRlZXAgY29tcGFyaXNvbiB0byBjaGVjayBpZiB0d28gb2JqZWN0cyBhcmUgZXF1YWwuXG4gIF8uaXNFcXVhbCA9IGZ1bmN0aW9uKGEsIGIpIHtcbiAgICByZXR1cm4gZXEoYSwgYik7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiBhcnJheSwgc3RyaW5nLCBvciBvYmplY3QgZW1wdHk/XG4gIC8vIEFuIFwiZW1wdHlcIiBvYmplY3QgaGFzIG5vIGVudW1lcmFibGUgb3duLXByb3BlcnRpZXMuXG4gIF8uaXNFbXB0eSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogPT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikgJiYgKF8uaXNBcnJheShvYmopIHx8IF8uaXNTdHJpbmcob2JqKSB8fCBfLmlzQXJndW1lbnRzKG9iaikpKSByZXR1cm4gb2JqLmxlbmd0aCA9PT0gMDtcbiAgICByZXR1cm4gXy5rZXlzKG9iaikubGVuZ3RoID09PSAwO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBET00gZWxlbWVudD9cbiAgXy5pc0VsZW1lbnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gISEob2JqICYmIG9iai5ub2RlVHlwZSA9PT0gMSk7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBhbiBhcnJheT9cbiAgLy8gRGVsZWdhdGVzIHRvIEVDTUE1J3MgbmF0aXZlIEFycmF5LmlzQXJyYXlcbiAgXy5pc0FycmF5ID0gbmF0aXZlSXNBcnJheSB8fCBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBBcnJheV0nO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFyaWFibGUgYW4gb2JqZWN0P1xuICBfLmlzT2JqZWN0ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIHR5cGUgPSB0eXBlb2Ygb2JqO1xuICAgIHJldHVybiB0eXBlID09PSAnZnVuY3Rpb24nIHx8IHR5cGUgPT09ICdvYmplY3QnICYmICEhb2JqO1xuICB9O1xuXG4gIC8vIEFkZCBzb21lIGlzVHlwZSBtZXRob2RzOiBpc0FyZ3VtZW50cywgaXNGdW5jdGlvbiwgaXNTdHJpbmcsIGlzTnVtYmVyLCBpc0RhdGUsIGlzUmVnRXhwLCBpc0Vycm9yLlxuICBfLmVhY2goWydBcmd1bWVudHMnLCAnRnVuY3Rpb24nLCAnU3RyaW5nJywgJ051bWJlcicsICdEYXRlJywgJ1JlZ0V4cCcsICdFcnJvciddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgX1snaXMnICsgbmFtZV0gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0ICcgKyBuYW1lICsgJ10nO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIERlZmluZSBhIGZhbGxiYWNrIHZlcnNpb24gb2YgdGhlIG1ldGhvZCBpbiBicm93c2VycyAoYWhlbSwgSUUgPCA5KSwgd2hlcmVcbiAgLy8gdGhlcmUgaXNuJ3QgYW55IGluc3BlY3RhYmxlIFwiQXJndW1lbnRzXCIgdHlwZS5cbiAgaWYgKCFfLmlzQXJndW1lbnRzKGFyZ3VtZW50cykpIHtcbiAgICBfLmlzQXJndW1lbnRzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gXy5oYXMob2JqLCAnY2FsbGVlJyk7XG4gICAgfTtcbiAgfVxuXG4gIC8vIE9wdGltaXplIGBpc0Z1bmN0aW9uYCBpZiBhcHByb3ByaWF0ZS4gV29yayBhcm91bmQgc29tZSB0eXBlb2YgYnVncyBpbiBvbGQgdjgsXG4gIC8vIElFIDExICgjMTYyMSksIGFuZCBpbiBTYWZhcmkgOCAoIzE5MjkpLlxuICBpZiAodHlwZW9mIC8uLyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiBJbnQ4QXJyYXkgIT0gJ29iamVjdCcpIHtcbiAgICBfLmlzRnVuY3Rpb24gPSBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiB0eXBlb2Ygb2JqID09ICdmdW5jdGlvbicgfHwgZmFsc2U7XG4gICAgfTtcbiAgfVxuXG4gIC8vIElzIGEgZ2l2ZW4gb2JqZWN0IGEgZmluaXRlIG51bWJlcj9cbiAgXy5pc0Zpbml0ZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBpc0Zpbml0ZShvYmopICYmICFpc05hTihwYXJzZUZsb2F0KG9iaikpO1xuICB9O1xuXG4gIC8vIElzIHRoZSBnaXZlbiB2YWx1ZSBgTmFOYD8gKE5hTiBpcyB0aGUgb25seSBudW1iZXIgd2hpY2ggZG9lcyBub3QgZXF1YWwgaXRzZWxmKS5cbiAgXy5pc05hTiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBfLmlzTnVtYmVyKG9iaikgJiYgb2JqICE9PSArb2JqO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYSBib29sZWFuP1xuICBfLmlzQm9vbGVhbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHRydWUgfHwgb2JqID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKG9iaikgPT09ICdbb2JqZWN0IEJvb2xlYW5dJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGVxdWFsIHRvIG51bGw/XG4gIF8uaXNOdWxsID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PT0gbnVsbDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIHVuZGVmaW5lZD9cbiAgXy5pc1VuZGVmaW5lZCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IHZvaWQgMDtcbiAgfTtcblxuICAvLyBTaG9ydGN1dCBmdW5jdGlvbiBmb3IgY2hlY2tpbmcgaWYgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHByb3BlcnR5IGRpcmVjdGx5XG4gIC8vIG9uIGl0c2VsZiAoaW4gb3RoZXIgd29yZHMsIG5vdCBvbiBhIHByb3RvdHlwZSkuXG4gIF8uaGFzID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gb2JqICE9IG51bGwgJiYgaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSk7XG4gIH07XG5cbiAgLy8gVXRpbGl0eSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBSdW4gVW5kZXJzY29yZS5qcyBpbiAqbm9Db25mbGljdCogbW9kZSwgcmV0dXJuaW5nIHRoZSBgX2AgdmFyaWFibGUgdG8gaXRzXG4gIC8vIHByZXZpb3VzIG93bmVyLiBSZXR1cm5zIGEgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5ub0NvbmZsaWN0ID0gZnVuY3Rpb24oKSB7XG4gICAgcm9vdC5fID0gcHJldmlvdXNVbmRlcnNjb3JlO1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIC8vIEtlZXAgdGhlIGlkZW50aXR5IGZ1bmN0aW9uIGFyb3VuZCBmb3IgZGVmYXVsdCBpdGVyYXRlZXMuXG4gIF8uaWRlbnRpdHkgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfTtcblxuICAvLyBQcmVkaWNhdGUtZ2VuZXJhdGluZyBmdW5jdGlvbnMuIE9mdGVuIHVzZWZ1bCBvdXRzaWRlIG9mIFVuZGVyc2NvcmUuXG4gIF8uY29uc3RhbnQgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9O1xuICB9O1xuXG4gIF8ubm9vcCA9IGZ1bmN0aW9uKCl7fTtcblxuICBfLnByb3BlcnR5ID0gcHJvcGVydHk7XG5cbiAgLy8gR2VuZXJhdGVzIGEgZnVuY3Rpb24gZm9yIGEgZ2l2ZW4gb2JqZWN0IHRoYXQgcmV0dXJucyBhIGdpdmVuIHByb3BlcnR5LlxuICBfLnByb3BlcnR5T2YgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09IG51bGwgPyBmdW5jdGlvbigpe30gOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBwcmVkaWNhdGUgZm9yIGNoZWNraW5nIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZlxuICAvLyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5tYXRjaGVyID0gXy5tYXRjaGVzID0gZnVuY3Rpb24oYXR0cnMpIHtcbiAgICBhdHRycyA9IF8uZXh0ZW5kT3duKHt9LCBhdHRycyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaXNNYXRjaChvYmosIGF0dHJzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJ1biBhIGZ1bmN0aW9uICoqbioqIHRpbWVzLlxuICBfLnRpbWVzID0gZnVuY3Rpb24obiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgYWNjdW0gPSBBcnJheShNYXRoLm1heCgwLCBuKSk7XG4gICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykgYWNjdW1baV0gPSBpdGVyYXRlZShpKTtcbiAgICByZXR1cm4gYWNjdW07XG4gIH07XG5cbiAgLy8gUmV0dXJuIGEgcmFuZG9tIGludGVnZXIgYmV0d2VlbiBtaW4gYW5kIG1heCAoaW5jbHVzaXZlKS5cbiAgXy5yYW5kb20gPSBmdW5jdGlvbihtaW4sIG1heCkge1xuICAgIGlmIChtYXggPT0gbnVsbCkge1xuICAgICAgbWF4ID0gbWluO1xuICAgICAgbWluID0gMDtcbiAgICB9XG4gICAgcmV0dXJuIG1pbiArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4gKyAxKSk7XG4gIH07XG5cbiAgLy8gQSAocG9zc2libHkgZmFzdGVyKSB3YXkgdG8gZ2V0IHRoZSBjdXJyZW50IHRpbWVzdGFtcCBhcyBhbiBpbnRlZ2VyLlxuICBfLm5vdyA9IERhdGUubm93IHx8IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgfTtcblxuICAgLy8gTGlzdCBvZiBIVE1MIGVudGl0aWVzIGZvciBlc2NhcGluZy5cbiAgdmFyIGVzY2FwZU1hcCA9IHtcbiAgICAnJic6ICcmYW1wOycsXG4gICAgJzwnOiAnJmx0OycsXG4gICAgJz4nOiAnJmd0OycsXG4gICAgJ1wiJzogJyZxdW90OycsXG4gICAgXCInXCI6ICcmI3gyNzsnLFxuICAgICdgJzogJyYjeDYwOydcbiAgfTtcbiAgdmFyIHVuZXNjYXBlTWFwID0gXy5pbnZlcnQoZXNjYXBlTWFwKTtcblxuICAvLyBGdW5jdGlvbnMgZm9yIGVzY2FwaW5nIGFuZCB1bmVzY2FwaW5nIHN0cmluZ3MgdG8vZnJvbSBIVE1MIGludGVycG9sYXRpb24uXG4gIHZhciBjcmVhdGVFc2NhcGVyID0gZnVuY3Rpb24obWFwKSB7XG4gICAgdmFyIGVzY2FwZXIgPSBmdW5jdGlvbihtYXRjaCkge1xuICAgICAgcmV0dXJuIG1hcFttYXRjaF07XG4gICAgfTtcbiAgICAvLyBSZWdleGVzIGZvciBpZGVudGlmeWluZyBhIGtleSB0aGF0IG5lZWRzIHRvIGJlIGVzY2FwZWRcbiAgICB2YXIgc291cmNlID0gJyg/OicgKyBfLmtleXMobWFwKS5qb2luKCd8JykgKyAnKSc7XG4gICAgdmFyIHRlc3RSZWdleHAgPSBSZWdFeHAoc291cmNlKTtcbiAgICB2YXIgcmVwbGFjZVJlZ2V4cCA9IFJlZ0V4cChzb3VyY2UsICdnJyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKHN0cmluZykge1xuICAgICAgc3RyaW5nID0gc3RyaW5nID09IG51bGwgPyAnJyA6ICcnICsgc3RyaW5nO1xuICAgICAgcmV0dXJuIHRlc3RSZWdleHAudGVzdChzdHJpbmcpID8gc3RyaW5nLnJlcGxhY2UocmVwbGFjZVJlZ2V4cCwgZXNjYXBlcikgOiBzdHJpbmc7XG4gICAgfTtcbiAgfTtcbiAgXy5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKGVzY2FwZU1hcCk7XG4gIF8udW5lc2NhcGUgPSBjcmVhdGVFc2NhcGVyKHVuZXNjYXBlTWFwKTtcblxuICAvLyBJZiB0aGUgdmFsdWUgb2YgdGhlIG5hbWVkIGBwcm9wZXJ0eWAgaXMgYSBmdW5jdGlvbiB0aGVuIGludm9rZSBpdCB3aXRoIHRoZVxuICAvLyBgb2JqZWN0YCBhcyBjb250ZXh0OyBvdGhlcndpc2UsIHJldHVybiBpdC5cbiAgXy5yZXN1bHQgPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5LCBmYWxsYmFjaykge1xuICAgIHZhciB2YWx1ZSA9IG9iamVjdCA9PSBudWxsID8gdm9pZCAwIDogb2JqZWN0W3Byb3BlcnR5XTtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgdmFsdWUgPSBmYWxsYmFjaztcbiAgICB9XG4gICAgcmV0dXJuIF8uaXNGdW5jdGlvbih2YWx1ZSkgPyB2YWx1ZS5jYWxsKG9iamVjdCkgOiB2YWx1ZTtcbiAgfTtcblxuICAvLyBHZW5lcmF0ZSBhIHVuaXF1ZSBpbnRlZ2VyIGlkICh1bmlxdWUgd2l0aGluIHRoZSBlbnRpcmUgY2xpZW50IHNlc3Npb24pLlxuICAvLyBVc2VmdWwgZm9yIHRlbXBvcmFyeSBET00gaWRzLlxuICB2YXIgaWRDb3VudGVyID0gMDtcbiAgXy51bmlxdWVJZCA9IGZ1bmN0aW9uKHByZWZpeCkge1xuICAgIHZhciBpZCA9ICsraWRDb3VudGVyICsgJyc7XG4gICAgcmV0dXJuIHByZWZpeCA/IHByZWZpeCArIGlkIDogaWQ7XG4gIH07XG5cbiAgLy8gQnkgZGVmYXVsdCwgVW5kZXJzY29yZSB1c2VzIEVSQi1zdHlsZSB0ZW1wbGF0ZSBkZWxpbWl0ZXJzLCBjaGFuZ2UgdGhlXG4gIC8vIGZvbGxvd2luZyB0ZW1wbGF0ZSBzZXR0aW5ncyB0byB1c2UgYWx0ZXJuYXRpdmUgZGVsaW1pdGVycy5cbiAgXy50ZW1wbGF0ZVNldHRpbmdzID0ge1xuICAgIGV2YWx1YXRlICAgIDogLzwlKFtcXHNcXFNdKz8pJT4vZyxcbiAgICBpbnRlcnBvbGF0ZSA6IC88JT0oW1xcc1xcU10rPyklPi9nLFxuICAgIGVzY2FwZSAgICAgIDogLzwlLShbXFxzXFxTXSs/KSU+L2dcbiAgfTtcblxuICAvLyBXaGVuIGN1c3RvbWl6aW5nIGB0ZW1wbGF0ZVNldHRpbmdzYCwgaWYgeW91IGRvbid0IHdhbnQgdG8gZGVmaW5lIGFuXG4gIC8vIGludGVycG9sYXRpb24sIGV2YWx1YXRpb24gb3IgZXNjYXBpbmcgcmVnZXgsIHdlIG5lZWQgb25lIHRoYXQgaXNcbiAgLy8gZ3VhcmFudGVlZCBub3QgdG8gbWF0Y2guXG4gIHZhciBub01hdGNoID0gLyguKV4vO1xuXG4gIC8vIENlcnRhaW4gY2hhcmFjdGVycyBuZWVkIHRvIGJlIGVzY2FwZWQgc28gdGhhdCB0aGV5IGNhbiBiZSBwdXQgaW50byBhXG4gIC8vIHN0cmluZyBsaXRlcmFsLlxuICB2YXIgZXNjYXBlcyA9IHtcbiAgICBcIidcIjogICAgICBcIidcIixcbiAgICAnXFxcXCc6ICAgICAnXFxcXCcsXG4gICAgJ1xccic6ICAgICAncicsXG4gICAgJ1xcbic6ICAgICAnbicsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIHZhciBlc2NhcGVyID0gL1xcXFx8J3xcXHJ8XFxufFxcdTIwMjh8XFx1MjAyOS9nO1xuXG4gIHZhciBlc2NhcGVDaGFyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlc1ttYXRjaF07XG4gIH07XG5cbiAgLy8gSmF2YVNjcmlwdCBtaWNyby10ZW1wbGF0aW5nLCBzaW1pbGFyIHRvIEpvaG4gUmVzaWcncyBpbXBsZW1lbnRhdGlvbi5cbiAgLy8gVW5kZXJzY29yZSB0ZW1wbGF0aW5nIGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlcyB3aGl0ZXNwYWNlLFxuICAvLyBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgLy8gTkI6IGBvbGRTZXR0aW5nc2Agb25seSBleGlzdHMgZm9yIGJhY2t3YXJkcyBjb21wYXRpYmlsaXR5LlxuICBfLnRlbXBsYXRlID0gZnVuY3Rpb24odGV4dCwgc2V0dGluZ3MsIG9sZFNldHRpbmdzKSB7XG4gICAgaWYgKCFzZXR0aW5ncyAmJiBvbGRTZXR0aW5ncykgc2V0dGluZ3MgPSBvbGRTZXR0aW5ncztcbiAgICBzZXR0aW5ncyA9IF8uZGVmYXVsdHMoe30sIHNldHRpbmdzLCBfLnRlbXBsYXRlU2V0dGluZ3MpO1xuXG4gICAgLy8gQ29tYmluZSBkZWxpbWl0ZXJzIGludG8gb25lIHJlZ3VsYXIgZXhwcmVzc2lvbiB2aWEgYWx0ZXJuYXRpb24uXG4gICAgdmFyIG1hdGNoZXIgPSBSZWdFeHAoW1xuICAgICAgKHNldHRpbmdzLmVzY2FwZSB8fCBub01hdGNoKS5zb3VyY2UsXG4gICAgICAoc2V0dGluZ3MuaW50ZXJwb2xhdGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmV2YWx1YXRlIHx8IG5vTWF0Y2gpLnNvdXJjZVxuICAgIF0uam9pbignfCcpICsgJ3wkJywgJ2cnKTtcblxuICAgIC8vIENvbXBpbGUgdGhlIHRlbXBsYXRlIHNvdXJjZSwgZXNjYXBpbmcgc3RyaW5nIGxpdGVyYWxzIGFwcHJvcHJpYXRlbHkuXG4gICAgdmFyIGluZGV4ID0gMDtcbiAgICB2YXIgc291cmNlID0gXCJfX3ArPSdcIjtcbiAgICB0ZXh0LnJlcGxhY2UobWF0Y2hlciwgZnVuY3Rpb24obWF0Y2gsIGVzY2FwZSwgaW50ZXJwb2xhdGUsIGV2YWx1YXRlLCBvZmZzZXQpIHtcbiAgICAgIHNvdXJjZSArPSB0ZXh0LnNsaWNlKGluZGV4LCBvZmZzZXQpLnJlcGxhY2UoZXNjYXBlciwgZXNjYXBlQ2hhcik7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcblxuICAgICAgaWYgKGVzY2FwZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGVzY2FwZSArIFwiKSk9PW51bGw/Jyc6Xy5lc2NhcGUoX190KSkrXFxuJ1wiO1xuICAgICAgfSBlbHNlIGlmIChpbnRlcnBvbGF0ZSkge1xuICAgICAgICBzb3VyY2UgKz0gXCInK1xcbigoX190PShcIiArIGludGVycG9sYXRlICsgXCIpKT09bnVsbD8nJzpfX3QpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoZXZhbHVhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJztcXG5cIiArIGV2YWx1YXRlICsgXCJcXG5fX3ArPSdcIjtcbiAgICAgIH1cblxuICAgICAgLy8gQWRvYmUgVk1zIG5lZWQgdGhlIG1hdGNoIHJldHVybmVkIHRvIHByb2R1Y2UgdGhlIGNvcnJlY3Qgb2ZmZXN0LlxuICAgICAgcmV0dXJuIG1hdGNoO1xuICAgIH0pO1xuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBJZiBhIHZhcmlhYmxlIGlzIG5vdCBzcGVjaWZpZWQsIHBsYWNlIGRhdGEgdmFsdWVzIGluIGxvY2FsIHNjb3BlLlxuICAgIGlmICghc2V0dGluZ3MudmFyaWFibGUpIHNvdXJjZSA9ICd3aXRoKG9ianx8e30pe1xcbicgKyBzb3VyY2UgKyAnfVxcbic7XG5cbiAgICBzb3VyY2UgPSBcInZhciBfX3QsX19wPScnLF9faj1BcnJheS5wcm90b3R5cGUuam9pbixcIiArXG4gICAgICBcInByaW50PWZ1bmN0aW9uKCl7X19wKz1fX2ouY2FsbChhcmd1bWVudHMsJycpO307XFxuXCIgK1xuICAgICAgc291cmNlICsgJ3JldHVybiBfX3A7XFxuJztcblxuICAgIHRyeSB7XG4gICAgICB2YXIgcmVuZGVyID0gbmV3IEZ1bmN0aW9uKHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonLCAnXycsIHNvdXJjZSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZS5zb3VyY2UgPSBzb3VyY2U7XG4gICAgICB0aHJvdyBlO1xuICAgIH1cblxuICAgIHZhciB0ZW1wbGF0ZSA9IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICAgIHJldHVybiByZW5kZXIuY2FsbCh0aGlzLCBkYXRhLCBfKTtcbiAgICB9O1xuXG4gICAgLy8gUHJvdmlkZSB0aGUgY29tcGlsZWQgc291cmNlIGFzIGEgY29udmVuaWVuY2UgZm9yIHByZWNvbXBpbGF0aW9uLlxuICAgIHZhciBhcmd1bWVudCA9IHNldHRpbmdzLnZhcmlhYmxlIHx8ICdvYmonO1xuICAgIHRlbXBsYXRlLnNvdXJjZSA9ICdmdW5jdGlvbignICsgYXJndW1lbnQgKyAnKXtcXG4nICsgc291cmNlICsgJ30nO1xuXG4gICAgcmV0dXJuIHRlbXBsYXRlO1xuICB9O1xuXG4gIC8vIEFkZCBhIFwiY2hhaW5cIiBmdW5jdGlvbi4gU3RhcnQgY2hhaW5pbmcgYSB3cmFwcGVkIFVuZGVyc2NvcmUgb2JqZWN0LlxuICBfLmNoYWluID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGluc3RhbmNlID0gXyhvYmopO1xuICAgIGluc3RhbmNlLl9jaGFpbiA9IHRydWU7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9O1xuXG4gIC8vIE9PUFxuICAvLyAtLS0tLS0tLS0tLS0tLS1cbiAgLy8gSWYgVW5kZXJzY29yZSBpcyBjYWxsZWQgYXMgYSBmdW5jdGlvbiwgaXQgcmV0dXJucyBhIHdyYXBwZWQgb2JqZWN0IHRoYXRcbiAgLy8gY2FuIGJlIHVzZWQgT08tc3R5bGUuIFRoaXMgd3JhcHBlciBob2xkcyBhbHRlcmVkIHZlcnNpb25zIG9mIGFsbCB0aGVcbiAgLy8gdW5kZXJzY29yZSBmdW5jdGlvbnMuIFdyYXBwZWQgb2JqZWN0cyBtYXkgYmUgY2hhaW5lZC5cblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gY29udGludWUgY2hhaW5pbmcgaW50ZXJtZWRpYXRlIHJlc3VsdHMuXG4gIHZhciByZXN1bHQgPSBmdW5jdGlvbihpbnN0YW5jZSwgb2JqKSB7XG4gICAgcmV0dXJuIGluc3RhbmNlLl9jaGFpbiA/IF8ob2JqKS5jaGFpbigpIDogb2JqO1xuICB9O1xuXG4gIC8vIEFkZCB5b3VyIG93biBjdXN0b20gZnVuY3Rpb25zIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5taXhpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIF8uZWFjaChfLmZ1bmN0aW9ucyhvYmopLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgICB2YXIgZnVuYyA9IF9bbmFtZV0gPSBvYmpbbmFtZV07XG4gICAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICB2YXIgYXJncyA9IFt0aGlzLl93cmFwcGVkXTtcbiAgICAgICAgcHVzaC5hcHBseShhcmdzLCBhcmd1bWVudHMpO1xuICAgICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIGZ1bmMuYXBwbHkoXywgYXJncykpO1xuICAgICAgfTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBBZGQgYWxsIG9mIHRoZSBVbmRlcnNjb3JlIGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlciBvYmplY3QuXG4gIF8ubWl4aW4oXyk7XG5cbiAgLy8gQWRkIGFsbCBtdXRhdG9yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG5hbWUpIHtcbiAgICB2YXIgbWV0aG9kID0gQXJyYXlQcm90b1tuYW1lXTtcbiAgICBfLnByb3RvdHlwZVtuYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG9iaiA9IHRoaXMuX3dyYXBwZWQ7XG4gICAgICBtZXRob2QuYXBwbHkob2JqLCBhcmd1bWVudHMpO1xuICAgICAgaWYgKChuYW1lID09PSAnc2hpZnQnIHx8IG5hbWUgPT09ICdzcGxpY2UnKSAmJiBvYmoubGVuZ3RoID09PSAwKSBkZWxldGUgb2JqWzBdO1xuICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBvYmopO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBfLmVhY2goWydjb25jYXQnLCAnam9pbicsICdzbGljZSddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgbWV0aG9kLmFwcGx5KHRoaXMuX3dyYXBwZWQsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIEV4dHJhY3RzIHRoZSByZXN1bHQgZnJvbSBhIHdyYXBwZWQgYW5kIGNoYWluZWQgb2JqZWN0LlxuICBfLnByb3RvdHlwZS52YWx1ZSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzLl93cmFwcGVkO1xuICB9O1xuXG4gIC8vIFByb3ZpZGUgdW53cmFwcGluZyBwcm94eSBmb3Igc29tZSBtZXRob2RzIHVzZWQgaW4gZW5naW5lIG9wZXJhdGlvbnNcbiAgLy8gc3VjaCBhcyBhcml0aG1ldGljIGFuZCBKU09OIHN0cmluZ2lmaWNhdGlvbi5cbiAgXy5wcm90b3R5cGUudmFsdWVPZiA9IF8ucHJvdG90eXBlLnRvSlNPTiA9IF8ucHJvdG90eXBlLnZhbHVlO1xuXG4gIF8ucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuICcnICsgdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBBTUQgcmVnaXN0cmF0aW9uIGhhcHBlbnMgYXQgdGhlIGVuZCBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIEFNRCBsb2FkZXJzXG4gIC8vIHRoYXQgbWF5IG5vdCBlbmZvcmNlIG5leHQtdHVybiBzZW1hbnRpY3Mgb24gbW9kdWxlcy4gRXZlbiB0aG91Z2ggZ2VuZXJhbFxuICAvLyBwcmFjdGljZSBmb3IgQU1EIHJlZ2lzdHJhdGlvbiBpcyB0byBiZSBhbm9ueW1vdXMsIHVuZGVyc2NvcmUgcmVnaXN0ZXJzXG4gIC8vIGFzIGEgbmFtZWQgbW9kdWxlIGJlY2F1c2UsIGxpa2UgalF1ZXJ5LCBpdCBpcyBhIGJhc2UgbGlicmFyeSB0aGF0IGlzXG4gIC8vIHBvcHVsYXIgZW5vdWdoIHRvIGJlIGJ1bmRsZWQgaW4gYSB0aGlyZCBwYXJ0eSBsaWIsIGJ1dCBub3QgYmUgcGFydCBvZlxuICAvLyBhbiBBTUQgbG9hZCByZXF1ZXN0LiBUaG9zZSBjYXNlcyBjb3VsZCBnZW5lcmF0ZSBhbiBlcnJvciB3aGVuIGFuXG4gIC8vIGFub255bW91cyBkZWZpbmUoKSBpcyBjYWxsZWQgb3V0c2lkZSBvZiBhIGxvYWRlciByZXF1ZXN0LlxuICBpZiAodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKSB7XG4gICAgZGVmaW5lKCd1bmRlcnNjb3JlJywgW10sIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIF87XG4gICAgfSk7XG4gIH1cbn0uY2FsbCh0aGlzKSk7XG4iLCIvKipcbiAqIFZleEZsb3cgMS4yLjM2IGJ1aWx0IG9uIDIwMTUtMTAtMTUuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgTW9oaXQgTXV0aGFubmEgQ2hlcHB1ZGlyYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuICpcbiAqIGh0dHA6Ly93d3cudmV4Zmxvdy5jb20gIGh0dHA6Ly9naXRodWIuY29tLzB4ZmUvdmV4Zmxvd1xuICovXG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIHV0aWxpdHkgbWV0aG9kcyB1c2VkIGJ5IHRoZSByZXN0IG9mIHRoZSBWZXhGbG93XG4vLyBjb2RlYmFzZS5cbi8vXG4vLyAjIyBKU0hpbnQgU2V0dGluZ3Ncbi8vXG4vKiBnbG9iYWwgd2luZG93OiBmYWxzZSAqL1xuLyogZ2xvYmFsIGRvY3VtZW50OiBmYWxzZSAqL1xuXG5pZiAodHlwZW9mIFZleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLyogZ2xvYmFsIFZleDogdHJ1ZSAqL1xuICBWZXggPSBmdW5jdGlvbigpIHt9O1xufVxuXG4vLyBEZWZhdWx0IGxvZyBmdW5jdGlvbiBzZW5kcyBhbGwgYXJndW1lbnRzIHRvIGNvbnNvbGUuXG5WZXguTCA9IGZ1bmN0aW9uKGJsb2NrLCBhcmdzKSB7XG4gIGlmICghYXJncykgcmV0dXJuO1xuICB2YXIgbGluZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oXCIgXCIpO1xuICB3aW5kb3cuY29uc29sZS5sb2coYmxvY2sgKyBcIjogXCIgKyBsaW5lKTtcbn07XG5cbi8vIERlZmF1bHQgcnVudGltZSBleGNlcHRpb24uXG5WZXguUnVudGltZUVycm9yID0gZnVuY3Rpb24oY29kZSwgbWVzc2FnZSkge1xuICB0aGlzLmNvZGUgPSBjb2RlO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufTtcblxuVmV4LlJ1bnRpbWVFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiUnVudGltZUVycm9yOiBcIiArIHRoaXMubWVzc2FnZTtcbn07XG5cbi8vIFNob3J0Y3V0IG1ldGhvZCBmb3IgYFJ1bnRpbWVFcnJvcmAuXG5WZXguUkVSUiA9IFZleC5SdW50aW1lRXJyb3I7XG5cbi8vIE1lcmdlIGBkZXN0aW5hdGlvbmAgaGFzaCB3aXRoIGBzb3VyY2VgIGhhc2gsIG92ZXJ3cml0aW5nIGxpa2Uga2V5c1xuLy8gaW4gYHNvdXJjZWAgaWYgbmVjZXNzYXJ5LlxuVmV4Lk1lcmdlID0gZnVuY3Rpb24oZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpXG4gICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufTtcblxuLy8gREVQUkVDQVRFRC4gVXNlIGBNYXRoLipgLlxuVmV4Lk1pbiA9IE1hdGgubWluO1xuVmV4Lk1heCA9IE1hdGgubWF4O1xuVmV4LmZvckVhY2ggPSBmdW5jdGlvbihhLCBmbikge1xuICBmb3IgKHZhciBpPTA7IGk8YS5sZW5ndGg7IGkrKykge1xuICAgIGZuKGFbaV0saSk7XG4gIH1cbn07XG5cbi8vIFJvdW5kIG51bWJlciB0byBuZWFyZXN0IGZyYWN0aW9uYWwgdmFsdWUgKGAuNWAsIGAuMjVgLCBldGMuKVxuVmV4LlJvdW5kTiA9IGZ1bmN0aW9uKHgsIG4pIHtcbiAgcmV0dXJuICh4ICUgbikgPj0gKG4vMikgP1xuICAgIHBhcnNlSW50KHggLyBuLCAxMCkgKiBuICsgbiA6IHBhcnNlSW50KHggLyBuLCAxMCkgKiBuO1xufTtcblxuLy8gTG9jYXRlIHRoZSBtaWQgcG9pbnQgYmV0d2VlbiBzdGF2ZSBsaW5lcy4gUmV0dXJucyBhIGZyYWN0aW9uYWwgbGluZSBpZiBhIHNwYWNlLlxuVmV4Lk1pZExpbmUgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBtaWRfbGluZSA9IGIgKyAoYSAtIGIpIC8gMjtcbiAgaWYgKG1pZF9saW5lICUgMiA+IDApIHtcbiAgICBtaWRfbGluZSA9IFZleC5Sb3VuZE4obWlkX2xpbmUgKiAxMCwgNSkgLyAxMDtcbiAgfVxuICByZXR1cm4gbWlkX2xpbmU7XG59O1xuXG4vLyBUYWtlIGBhcnJgIGFuZCByZXR1cm4gYSBuZXcgbGlzdCBjb25zaXN0aW5nIG9mIHRoZSBzb3J0ZWQsIHVuaXF1ZSxcbi8vIGNvbnRlbnRzIG9mIGFyci4gRG9lcyBub3QgbW9kaWZ5IGBhcnJgLlxuVmV4LlNvcnRBbmRVbmlxdWUgPSBmdW5jdGlvbihhcnIsIGNtcCwgZXEpIHtcbiAgaWYgKGFyci5sZW5ndGggPiAxKSB7XG4gICAgdmFyIG5ld0FyciA9IFtdO1xuICAgIHZhciBsYXN0O1xuICAgIGFyci5zb3J0KGNtcCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgPT09IDAgfHwgIWVxKGFycltpXSwgbGFzdCkpIHtcbiAgICAgICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0FycjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG59O1xuXG4vLyBDaGVjayBpZiBhcnJheSBgYWAgY29udGFpbnMgYG9iamAuXG5WZXguQ29udGFpbnMgPSBmdW5jdGlvbihhLCBvYmopIHtcbiAgdmFyIGkgPSBhLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChhW2ldID09PSBvYmopIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBHZXQgdGhlIDJEIENhbnZhcyBjb250ZXh0IGZyb20gRE9NIGVsZW1lbnQgYGNhbnZhc19zZWxgLlxuVmV4LmdldENhbnZhc0NvbnRleHQgPSBmdW5jdGlvbihjYW52YXNfc2VsKSB7XG4gIGlmICghY2FudmFzX3NlbClcbiAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudFwiLCBcIkludmFsaWQgY2FudmFzIHNlbGVjdG9yOiBcIiArIGNhbnZhc19zZWwpO1xuXG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNfc2VsKTtcbiAgaWYgKCEoY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0KSkge1xuICAgIHRocm93IG5ldyBWZXguUkVSUihcIlVuc3VwcG9ydGVkQnJvd3NlckVycm9yXCIsXG4gICAgICAgIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgSFRNTDUgQ2FudmFzXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xufTtcblxuLy8gRHJhdyBhIHRpbnkgZG90IG1hcmtlciBvbiB0aGUgc3BlY2lmaWVkIGNhbnZhcy4gQSBncmVhdCBkZWJ1Z2dpbmcgYWlkLlxuLy9cbi8vIGBjdHhgOiBDYW52YXMgY29udGV4dC5cbi8vIGB4YCwgYHlgOiBEb3QgY29vcmRpbmF0ZXMuXG5WZXguZHJhd0RvdCA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgY29sb3IpIHtcbiAgdmFyIGMgPSBjb2xvciB8fCBcIiNmNTVcIjtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnNldEZpbGxTdHlsZShjKTtcblxuICAvL2RyYXcgYSBjaXJjbGVcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIDMsIDAsIE1hdGguUEkqMiwgdHJ1ZSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmZpbGwoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn07XG5cbi8vIEJlbmNobWFyay4gUnVuIGZ1bmN0aW9uIGBmYCBvbmNlIGFuZCByZXBvcnQgdGltZSBlbGFwc2VkIHNoaWZ0ZWQgYnkgYHNgIG1pbGxpc2Vjb25kcy5cblZleC5CTSA9IGZ1bmN0aW9uKHMsIGYpIHtcbiAgdmFyIHN0YXJ0X3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgZigpO1xuICB2YXIgZWxhcHNlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRfdGltZTtcbiAgVmV4LkwocyArIGVsYXBzZWQgKyBcIm1zXCIpO1xufTtcblxuLy8gQmFzaWMgY2xhc3NpY2FsIGluaGVyaXRhbmNlIGhlbHBlci4gVXNhZ2U6XG4vLyBgYGBcbi8vIC8vIFZleC5Jbmhlcml0KENoaWxkLCBQYXJlbnQsIHtcbi8vIC8vICAgZ2V0TmFtZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMubmFtZTt9LFxuLy8gLy8gICBzZXROYW1lOiBmdW5jdGlvbihuYW1lKSB7dGhpcy5uYW1lID0gbmFtZX1cbi8vIC8vIH0pO1xuLy8gLy9cbi8vIC8vIFJldHVybnMgJ0NoaWxkJy5cbi8vIGBgYFxuVmV4LkluaGVyaXQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgRiA9IGZ1bmN0aW9uICgpIHt9O1xuICAvLyBgQ2AgaXMgQ2hpbGQuIGBQYCBpcyBwYXJlbnQuIGBPYCBpcyBhbiBvYmplY3QgdG9cbiAgLy8gdG8gZXh0ZW5kIGBDYCB3aXRoLlxuICByZXR1cm4gZnVuY3Rpb24gKEMsIFAsIE8pIHtcbiAgICBGLnByb3RvdHlwZSA9IFAucHJvdG90eXBlO1xuICAgIEMucHJvdG90eXBlID0gbmV3IEYoKTtcbiAgICBDLnN1cGVyY2xhc3MgPSBQLnByb3RvdHlwZTtcbiAgICBDLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEM7XG4gICAgVmV4Lk1lcmdlKEMucHJvdG90eXBlLCBPKTtcbiAgICByZXR1cm4gQztcbiAgfTtcbn0oKSk7XG5cbi8vIEdldCBzdGFjayB0cmFjZS5cblZleC5TdGFja1RyYWNlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgcmV0dXJuIGVyci5zdGFjaztcbn07XG5cbi8vIER1bXAgd2FybmluZyB0byBjb25zb2xlLlxuVmV4LlcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxpbmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO1xuICB3aW5kb3cuY29uc29sZS5sb2coXCJXYXJuaW5nOiBcIiwgbGluZSwgVmV4LlN0YWNrVHJhY2UoKSk7XG59O1xuXG4vLyBVc2VkIGJ5IHZhcmlvdXMgY2xhc3NlcyAoZS5nLiwgU1ZHQ29udGV4dCkgdG8gcHJvdmlkZSBhXG4vLyB1bmlxdWUgcHJlZml4IHRvIGVsZW1lbnQgbmFtZXMgKG9yIG90aGVyIGtleXMgaW4gc2hhcmVkIG5hbWVzcGFjZXMpLlxuVmV4LlByZWZpeCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuIFZleC5QcmVmaXgucHJlZml4ICsgdGV4dDtcbn07XG5WZXguUHJlZml4LnByZWZpeCA9IFwidmYtXCI7XG5cbi8vIFVNRCB0byBleHBvcnQgVmV4LlxuLy9cbi8qIGdsb2JhbCByZXF1aXJlOiBmYWxzZSAqL1xuLyogZ2xvYmFsIGRlZmluZTogZmFsc2UgKi9cbi8qIGdsb2JhbCBtb2R1bGU6IGZhbHNlICovXG5pZiAodHlwZW9mIHJlcXVpcmUgPT0gXCJmdW5jdGlvblwiKSB7XG4gIHRyeSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBWZXg7XG4gIH0gY2F0Y2ggKGUpIHt9XG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKFwiVmV4XCIsIFtdLCBmdW5jdGlvbigpeyByZXR1cm4gVmV4OyB9KTtcbn0gZWxzZSB7XG4gICh0aGlzIHx8IHdpbmRvdylbXCJWZXhcIl0gPSBWZXg7XG59XG5cbi8qKlxuICogVmV4IEZsb3cgLSBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuICovXG5cbi8qKlxuICogTmV3IG5hbWVzcGFjZS5cbiAqL1xuXG5pZiAodHlwZW9mIFZleC5GbG93ID09PSAndW5kZWZpbmVkJykge1xuICBWZXguRmxvdyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVzb2x1dGlvbiB1c2VkIGZvciBhbGwgdGhlIHJoeXRobSB0aW1pbmcgaW4gdGhpc1xuICAgICAqIGxpYnJhcnkuXG4gICAgICpcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIFJFU09MVVRJT046IDE2Mzg0LFxuXG4gICAgLyogS2VybmluZyAoREVQUkVDQVRFRCkgKi9cbiAgICBJc0tlcm5lZDogdHJ1ZVxuICB9O1xufVxuXG4vLyBGcmFjdGlvbiBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSByYXRpb25hbCBudW1iZXJcbi8vIEBhdXRob3Igeno4NVxuLy8gQGF1dGhvciBpbmNvbXBsZXRlb3B1cyAobW9kaWZpY2F0aW9ucylcblxuVmV4LkZsb3cuRnJhY3Rpb24gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEZyYWN0aW9uKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICB0aGlzLnNldChudW1lcmF0b3IsIGRlbm9taW5hdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHQ0Q6IEZpbmQgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3IgdXNpbmcgRXVjbGlkZWFuIGFsZ29yaXRobVxuICAgKi9cbiAgRnJhY3Rpb24uR0NEID0gZnVuY3Rpb24oYSwgYikge1xuICAgIGlmICh0eXBlb2YgYSAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgYiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRcIiwgXCJJbnZhbGlkIG51bWJlcnM6IFwiICsgYSArIFwiLCBcIiArIGIpO1xuICAgIH1cblxuICAgIHZhciB0O1xuXG4gICAgd2hpbGUgKGIgIT09IDApIHtcbiAgICAgIHQgPSBiO1xuICAgICAgYiA9IGEgJSBiO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIExDTTogTG93ZXN0IGNvbW1vbiBtdWx0aXBsZVxuICAgKi9cbiAgRnJhY3Rpb24uTENNID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiAoKGEgKiBiKSAvIEZyYWN0aW9uLkdDRChhLCBiKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExDTU06IExvd2VzdCBjb21tb24gbXVsdGlwbGUgZm9yIG1vcmUgdGhhbiB0d28gbnVtYmVyc1xuICAgKi9cbiAgRnJhY3Rpb24uTENNTSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT0gMSkge1xuICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PSAyKSB7XG4gICAgICByZXR1cm4gVmV4LkZsb3cuRnJhY3Rpb24uTENNKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJnMCA9IGFyZ3NbMF07XG4gICAgICBhcmdzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4gRnJhY3Rpb24uTENNKGFyZzAsIFZleC5GbG93LkZyYWN0aW9uLkxDTU0oYXJncykpO1xuICAgIH1cbiAgfTtcblxuICBGcmFjdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihudW1lcmF0b3IsIGRlbm9taW5hdG9yKSB7XG4gICAgICB0aGlzLm51bWVyYXRvciA9IG51bWVyYXRvciA9PT0gdW5kZWZpbmVkID8gMSA6IG51bWVyYXRvcjtcbiAgICAgIHRoaXMuZGVub21pbmF0b3IgPSBkZW5vbWluYXRvciA9PT0gdW5kZWZpbmVkID8gMSA6IGRlbm9taW5hdG9yO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm51bWVyYXRvciAvIHRoaXMuZGVub21pbmF0b3I7XG4gICAgfSxcblxuICAgIHNpbXBsaWZ5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1ID0gdGhpcy5udW1lcmF0b3I7XG4gICAgICB2YXIgZCA9IHRoaXMuZGVub21pbmF0b3I7XG5cbiAgICAgIHZhciBnY2QgPSBWZXguRmxvdy5GcmFjdGlvbi5HQ0QodSwgZCk7XG4gICAgICB1IC89IGdjZDtcbiAgICAgIGQgLz0gZ2NkO1xuXG4gICAgICBpZiAoZCA8IDApIHtcbiAgICAgICAgZCA9IC1kO1xuICAgICAgICB1ID0gLXU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zZXQodSwgZCk7XG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24ocGFyYW0xLCBwYXJhbTIpIHtcbiAgICAgIHZhciBvdGhlck51bWVyYXRvcjtcbiAgICAgIHZhciBvdGhlckRlbm9taW5hdG9yO1xuXG4gICAgICBpZiAocGFyYW0xIGluc3RhbmNlb2YgVmV4LkZsb3cuRnJhY3Rpb24pIHtcbiAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSBwYXJhbTEubnVtZXJhdG9yO1xuICAgICAgICBvdGhlckRlbm9taW5hdG9yID0gcGFyYW0xLmRlbm9taW5hdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmFtMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSBwYXJhbTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3RoZXJEZW5vbWluYXRvciA9IHBhcmFtMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlckRlbm9taW5hdG9yID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGNtID0gVmV4LkZsb3cuRnJhY3Rpb24uTENNKHRoaXMuZGVub21pbmF0b3IsIG90aGVyRGVub21pbmF0b3IpO1xuICAgICAgdmFyIGEgPSBsY20gLyB0aGlzLmRlbm9taW5hdG9yO1xuICAgICAgdmFyIGIgPSBsY20gLyBvdGhlckRlbm9taW5hdG9yO1xuXG4gICAgICB2YXIgdSA9IHRoaXMubnVtZXJhdG9yICogYSArIG90aGVyTnVtZXJhdG9yICogYjtcbiAgICAgIHJldHVybiB0aGlzLnNldCh1LCBsY20pO1xuICAgIH0sXG5cbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24ocGFyYW0xLCBwYXJhbTIpIHtcbiAgICAgIHZhciBvdGhlck51bWVyYXRvcjtcbiAgICAgIHZhciBvdGhlckRlbm9taW5hdG9yO1xuXG4gICAgICBpZiAocGFyYW0xIGluc3RhbmNlb2YgVmV4LkZsb3cuRnJhY3Rpb24pIHtcbiAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSBwYXJhbTEubnVtZXJhdG9yO1xuICAgICAgICBvdGhlckRlbm9taW5hdG9yID0gcGFyYW0xLmRlbm9taW5hdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmFtMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSBwYXJhbTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3RoZXJEZW5vbWluYXRvciA9IHBhcmFtMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlckRlbm9taW5hdG9yID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGNtID0gVmV4LkZsb3cuRnJhY3Rpb24uTENNKHRoaXMuZGVub21pbmF0b3IsIG90aGVyRGVub21pbmF0b3IpO1xuICAgICAgdmFyIGEgPSBsY20gLyB0aGlzLmRlbm9taW5hdG9yO1xuICAgICAgdmFyIGIgPSBsY20gLyBvdGhlckRlbm9taW5hdG9yO1xuXG4gICAgICB2YXIgdSA9IHRoaXMubnVtZXJhdG9yICogYSAtIG90aGVyTnVtZXJhdG9yICogYjtcbiAgICAgIHJldHVybiB0aGlzLnNldCh1LCBsY20pO1xuICAgIH0sXG5cbiAgICBtdWx0aXBseTogZnVuY3Rpb24ocGFyYW0xLCBwYXJhbTIpIHtcbiAgICAgIHZhciBvdGhlck51bWVyYXRvcjtcbiAgICAgIHZhciBvdGhlckRlbm9taW5hdG9yO1xuXG4gICAgICBpZiAocGFyYW0xIGluc3RhbmNlb2YgVmV4LkZsb3cuRnJhY3Rpb24pIHtcbiAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSBwYXJhbTEubnVtZXJhdG9yO1xuICAgICAgICBvdGhlckRlbm9taW5hdG9yID0gcGFyYW0xLmRlbm9taW5hdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmFtMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSBwYXJhbTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3RoZXJEZW5vbWluYXRvciA9IHBhcmFtMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlckRlbm9taW5hdG9yID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zZXQodGhpcy5udW1lcmF0b3IgKiBvdGhlck51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvciAqIG90aGVyRGVub21pbmF0b3IpO1xuICAgIH0sXG5cbiAgICBkaXZpZGU6IGZ1bmN0aW9uKHBhcmFtMSwgcGFyYW0yKSB7XG4gICAgICB2YXIgb3RoZXJOdW1lcmF0b3I7XG4gICAgICB2YXIgb3RoZXJEZW5vbWluYXRvcjtcblxuICAgICAgaWYgKHBhcmFtMSBpbnN0YW5jZW9mIFZleC5GbG93LkZyYWN0aW9uKSB7XG4gICAgICAgIG90aGVyTnVtZXJhdG9yID0gcGFyYW0xLm51bWVyYXRvcjtcbiAgICAgICAgb3RoZXJEZW5vbWluYXRvciA9IHBhcmFtMS5kZW5vbWluYXRvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXJhbTEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG90aGVyTnVtZXJhdG9yID0gcGFyYW0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVyTnVtZXJhdG9yID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbTIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG90aGVyRGVub21pbmF0b3IgPSBwYXJhbTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJEZW5vbWluYXRvciA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc2V0KHRoaXMubnVtZXJhdG9yICogb3RoZXJEZW5vbWluYXRvciwgdGhpcy5kZW5vbWluYXRvciAqIG90aGVyTnVtZXJhdG9yKTtcbiAgICB9LFxuXG5cbiAgICAvLyBTaW1wbGlmaWVzIGJvdGggc2lkZXMgYW5kIGNoZWNrcyBpZiB0aGV5IGFyZSBlcXVhbC5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKGNvbXBhcmUpIHtcbiAgICAgIHZhciBhID0gVmV4LkZsb3cuRnJhY3Rpb24uX19jb21wYXJlQS5jb3B5KGNvbXBhcmUpLnNpbXBsaWZ5KCk7XG4gICAgICB2YXIgYiA9IFZleC5GbG93LkZyYWN0aW9uLl9fY29tcGFyZUIuY29weSh0aGlzKS5zaW1wbGlmeSgpO1xuXG4gICAgICByZXR1cm4gKGEubnVtZXJhdG9yID09PSBiLm51bWVyYXRvcikgJiYgKGEuZGVub21pbmF0b3IgPT09IGIuZGVub21pbmF0b3IpO1xuICAgIH0sXG4gICAgXG4gICAgLy8gR3JlYXRlciB0aGFuIG9wZXJhdG9yLlxuICAgIGdyZWF0ZXJUaGFuOiBmdW5jdGlvbihjb21wYXJlKSB7XG4gICAgICB2YXIgYSA9IFZleC5GbG93LkZyYWN0aW9uLl9fY29tcGFyZUIuY29weSh0aGlzKTtcbiAgICAgIGEuc3VidHJhY3QoY29tcGFyZSk7XG4gICAgICByZXR1cm4gKGEubnVtZXJhdG9yID4gMCk7XG4gICAgfSxcbiAgICBcbiAgICAvLyBHcmVhdGVyIHRoYW4gb3IgZXF1YWxzIG9wZXJhdG9yLlxuICAgIGdyZWF0ZXJUaGFuRXF1YWxzOiBmdW5jdGlvbihjb21wYXJlKSB7XG4gICAgICB2YXIgYSA9IFZleC5GbG93LkZyYWN0aW9uLl9fY29tcGFyZUIuY29weSh0aGlzKTtcbiAgICAgIGEuc3VidHJhY3QoY29tcGFyZSk7XG4gICAgICByZXR1cm4gKGEubnVtZXJhdG9yID49IDApO1xuICAgIH0sXG5cbiAgICAvLyBMZXNzIHRoYW4gb3BlcmF0b3IuXG4gICAgbGVzc1RoYW46IGZ1bmN0aW9uKGNvbXBhcmUpIHtcbiAgICAgIHJldHVybiAhKHRoaXMuZ3JlYXRlclRoYW5FcXVhbHMoY29tcGFyZSkpOyAgXG4gICAgfSxcblxuICAgIC8vIExlc3MgdGhhbiBvciBlcXVhbHMgb3BlcmF0b3IuXG4gICAgbGVzc1RoYW5FcXVhbHM6IGZ1bmN0aW9uKGNvbXBhcmUpIHtcbiAgICAgIHJldHVybiAhKHRoaXMuZ3JlYXRlclRoYW4oY29tcGFyZSkpOyAgXG4gICAgfSxcblxuICAgIC8vIENyZWF0ZXMgYSBuZXcgY29weSB3aXRoIHRoaXMgY3VycmVudCB2YWx1ZXMuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBWZXguRmxvdy5GcmFjdGlvbih0aGlzLm51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvcik7XG4gICAgfSxcblxuICAgIC8vIENvcGllcyB2YWx1ZSBvZiBhbm90aGVyIEZyYWN0aW9uIGludG8gaXRzZWxmLlxuICAgIGNvcHk6IGZ1bmN0aW9uKGNvcHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChjb3B5Lm51bWVyYXRvciwgY29weS5kZW5vbWluYXRvcik7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIGludGVnZXIgY29tcG9uZW50IGVnLiAoNC8yKSA9PSAyXG4gICAgcXVvdGllbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5udW1lcmF0b3IgLyB0aGlzLmRlbm9taW5hdG9yKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgZnJhY3Rpb24gY29tcG9uZW50IHdoZW4gcmVkdWNlZCB0byBhIG1peGVkIG51bWJlclxuICAgIGZyYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm51bWVyYXRvciAlIHRoaXMuZGVub21pbmF0b3I7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgYWJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGVub21pbmF0b3IgPSBNYXRoLmFicyh0aGlzLmRlbm9taW5hdG9yKTtcbiAgICAgIHRoaXMubnVtZXJhdG9yID0gTWF0aC5hYnModGhpcy5udW1lcmF0b3IpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSByYXcgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubnVtZXJhdG9yICsgJy8nICsgdGhpcy5kZW5vbWluYXRvcjtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIHNpbXBsaWZpZWQgc3RyaW5nIHJlc3ByZXNlbnRhdGlvblxuICAgIHRvU2ltcGxpZmllZFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gVmV4LkZsb3cuRnJhY3Rpb24uX190bXAuY29weSh0aGlzKS5zaW1wbGlmeSgpLnRvU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGluIG1peGVkIGZvcm1cbiAgICB0b01peGVkU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzID0gJyc7XG4gICAgICB2YXIgcSA9IHRoaXMucXVvdGllbnQoKTtcbiAgICAgIHZhciBmID0gVmV4LkZsb3cuRnJhY3Rpb24uX190bXAuY29weSh0aGlzKTtcblxuICAgICAgaWYgKHEgPCAwKSB7XG4gICAgICAgIGYuYWJzKCkuZnJhY3Rpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGYuZnJhY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHEgIT09IDApIHtcbiAgICAgICAgcyArPSBxO1xuXG4gICAgICAgIGlmIChmLm51bWVyYXRvciAhPT0gMCkge1xuICAgICAgICAgIHMgKz0gJyAnICsgZi50b1NpbXBsaWZpZWRTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGYubnVtZXJhdG9yID09PSAwKSB7XG4gICAgICAgICAgcyA9ICcwJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzID0gZi50b1NpbXBsaWZpZWRTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuXG4gICAgLy8gUGFyc2VzIGEgZnJhY3Rpb24gc3RyaW5nXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIGkgPSBzdHIuc3BsaXQoJy8nKTtcbiAgICAgIHZhciBuID0gcGFyc2VJbnQoaVswXSwgMTApO1xuICAgICAgdmFyIGQgPSAoaVsxXSkgPyBwYXJzZUludChpWzFdLCAxMCkgOiAxO1xuXG4gICAgICByZXR1cm4gdGhpcy5zZXQobiwgZCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRlbXBvcmFyeSBjYWNoZWQgb2JqZWN0c1xuICBGcmFjdGlvbi5fX2NvbXBhcmVBID0gbmV3IEZyYWN0aW9uKCk7XG4gIEZyYWN0aW9uLl9fY29tcGFyZUIgPSBuZXcgRnJhY3Rpb24oKTtcbiAgRnJhY3Rpb24uX190bXAgPSBuZXcgRnJhY3Rpb24oKTtcblxuICByZXR1cm4gRnJhY3Rpb247XG59KCkpO1xuXG5cbi8vIFZleCBGbG93IE5vdGF0aW9uXG4vLyBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy9cbi8vIENvcHlyaWdodCBNb2hpdCBNdXRoYW5uYSAyMDEwXG4vL1xuLy8gUmVxdWlyZXMgdmV4LmpzLlxuXG5WZXguRmxvdy5TVEVNX1dJRFRIID0gMS41O1xuVmV4LkZsb3cuU1RFTV9IRUlHSFQgPSAzMjtcblZleC5GbG93LlNUQVZFX0xJTkVfVEhJQ0tORVNTID0gMjtcblxuVmV4LkZsb3cuY2xlZlByb3BlcnRpZXMgPSBmdW5jdGlvbihjbGVmKSB7XG4gIGlmICghY2xlZikgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRcIiwgXCJJbnZhbGlkIGNsZWY6IFwiICsgY2xlZik7XG5cbiAgdmFyIHByb3BzID0gVmV4LkZsb3cuY2xlZlByb3BlcnRpZXMudmFsdWVzW2NsZWZdO1xuICBpZiAoIXByb3BzKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudFwiLCBcIkludmFsaWQgY2xlZjogXCIgKyBjbGVmKTtcblxuICByZXR1cm4gcHJvcHM7XG59O1xuXG5WZXguRmxvdy5jbGVmUHJvcGVydGllcy52YWx1ZXMgPSB7XG4gICd0cmVibGUnOiAgeyBsaW5lX3NoaWZ0OiAwIH0sXG4gICdiYXNzJzogICAgeyBsaW5lX3NoaWZ0OiA2IH0sXG4gICd0ZW5vcic6ICAgeyBsaW5lX3NoaWZ0OiA0IH0sXG4gICdhbHRvJzogICAgeyBsaW5lX3NoaWZ0OiAzIH0sXG4gICdzb3ByYW5vJzogeyBsaW5lX3NoaWZ0OiAxIH0sXG4gICdwZXJjdXNzaW9uJzogeyBsaW5lX3NoaWZ0OiAwIH0sXG4gICdtZXp6by1zb3ByYW5vJzogeyBsaW5lX3NoaWZ0OiAyIH0sXG4gICdiYXJpdG9uZS1jJzogeyBsaW5lX3NoaWZ0OiA1IH0sXG4gICdiYXJpdG9uZS1mJzogeyBsaW5lX3NoaWZ0OiA1IH0sXG4gICdzdWJiYXNzJzogeyBsaW5lX3NoaWZ0OiA3IH0sXG4gICdmcmVuY2gnOiB7IGxpbmVfc2hpZnQ6IC0xIH1cbn07XG5cbi8qXG4gIFRha2UgYSBub3RlIGluIHRoZSBmb3JtYXQgXCJLZXkvT2N0YXZlXCIgKGUuZy4sIFwiQy81XCIpIGFuZCByZXR1cm4gcHJvcGVydGllcy5cblxuICBUaGUgbGFzdCBhcmd1bWVudCwgcGFyYW1zLCBpcyBhIHN0cnVjdCB0aGUgY3VycmVudGx5IGNhbiBjb250YWluIG9uZSBvcHRpb24sXG4gIG9jdGF2ZV9zaGlmdCBmb3IgY2xlZiBvdHRhdmF0aW9uICgwID0gZGVmYXVsdDsgMSA9IDh2YTsgLTEgPSA4dmIsIGV0Yy4pLlxuKi9cblZleC5GbG93LmtleVByb3BlcnRpZXMgPSBmdW5jdGlvbihrZXksIGNsZWYsIHBhcmFtcykge1xuICBpZiAoY2xlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xlZiA9ICd0cmVibGUnO1xuICB9XG4gIHZhciBvcHRpb25zID0ge1xuICAgIG9jdGF2ZV9zaGlmdDogMFxuICB9O1xuICBpZiAodHlwZW9mIHBhcmFtcyA9PSBcIm9iamVjdFwiKSB7XG4gICAgVmV4Lk1lcmdlKG9wdGlvbnMsIHBhcmFtcyk7XG4gIH1cblxuICB2YXIgcGllY2VzID0ga2V5LnNwbGl0KFwiL1wiKTtcblxuICBpZiAocGllY2VzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgXCJLZXkgbXVzdCBoYXZlIG5vdGUgKyBvY3RhdmUgYW5kIGFuIG9wdGlvbmFsIGdseXBoOiBcIiArIGtleSk7XG4gIH1cblxuICB2YXIgayA9IHBpZWNlc1swXS50b1VwcGVyQ2FzZSgpO1xuICB2YXIgdmFsdWUgPSBWZXguRmxvdy5rZXlQcm9wZXJ0aWVzLm5vdGVfdmFsdWVzW2tdO1xuICBpZiAoIXZhbHVlKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJJbnZhbGlkIGtleSBuYW1lOiBcIiArIGspO1xuICBpZiAodmFsdWUub2N0YXZlKSBwaWVjZXNbMV0gPSB2YWx1ZS5vY3RhdmU7XG5cbiAgdmFyIG8gPSBwYXJzZUludChwaWVjZXNbMV0pO1xuXG4gIC8vIE9jdGF2ZV9zaGlmdCBpcyB0aGUgc2hpZnQgdG8gY29tcGVuc2F0ZSBmb3IgY2xlZiA4dmEvOHZiLlxuICBvICs9IC0xICogb3B0aW9ucy5vY3RhdmVfc2hpZnQ7XG5cbiAgdmFyIGJhc2VfaW5kZXggPSAobyAqIDcpIC0gKDQgKiA3KTtcbiAgdmFyIGxpbmUgPSAoYmFzZV9pbmRleCArIHZhbHVlLmluZGV4KSAvIDI7XG4gIGxpbmUgKz0gVmV4LkZsb3cuY2xlZlByb3BlcnRpZXMoY2xlZikubGluZV9zaGlmdDtcblxuICB2YXIgc3Ryb2tlID0gMDtcblxuICBpZiAobGluZSA8PSAwICYmICgoKGxpbmUgKiAyKSAlIDIpID09PSAwKSkgc3Ryb2tlID0gMTsgIC8vIHN0cm9rZSB1cFxuICBpZiAobGluZSA+PSA2ICYmICgoKGxpbmUgKiAyKSAlIDIpID09PSAwKSkgc3Ryb2tlID0gLTE7IC8vIHN0cm9rZSBkb3duXG5cbiAgLy8gSW50ZWdlciB2YWx1ZSBmb3Igbm90ZSBhcml0aG1ldGljLlxuICB2YXIgaW50X3ZhbHVlID0gKHR5cGVvZih2YWx1ZS5pbnRfdmFsKSE9J3VuZGVmaW5lZCcpID8gKG8gKiAxMikgK1xuICAgIHZhbHVlLmludF92YWwgOiBudWxsO1xuXG4gIC8qIENoZWNrIGlmIHRoZSB1c2VyIHNwZWNpZmllZCBhIGdseXBoLiAqL1xuICB2YXIgY29kZSA9IHZhbHVlLmNvZGU7XG4gIHZhciBzaGlmdF9yaWdodCA9IHZhbHVlLnNoaWZ0X3JpZ2h0O1xuICBpZiAoKHBpZWNlcy5sZW5ndGggPiAyKSAmJiAocGllY2VzWzJdKSkge1xuICAgIHZhciBnbHlwaF9uYW1lID0gcGllY2VzWzJdLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIG5vdGVfZ2x5cGggPSBWZXguRmxvdy5rZXlQcm9wZXJ0aWVzLm5vdGVfZ2x5cGhbZ2x5cGhfbmFtZV07XG4gICAgaWYgKG5vdGVfZ2x5cGgpIHtcbiAgICAgIGNvZGUgPSBub3RlX2dseXBoLmNvZGU7XG4gICAgICBzaGlmdF9yaWdodCA9IG5vdGVfZ2x5cGguc2hpZnRfcmlnaHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBrZXk6IGssXG4gICAgb2N0YXZlOiBvLFxuICAgIGxpbmU6IGxpbmUsXG4gICAgaW50X3ZhbHVlOiBpbnRfdmFsdWUsXG4gICAgYWNjaWRlbnRhbDogdmFsdWUuYWNjaWRlbnRhbCxcbiAgICBjb2RlOiBjb2RlLFxuICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgIHNoaWZ0X3JpZ2h0OiBzaGlmdF9yaWdodCxcbiAgICBkaXNwbGFjZWQ6IGZhbHNlXG4gIH07XG59O1xuXG5WZXguRmxvdy5rZXlQcm9wZXJ0aWVzLm5vdGVfdmFsdWVzID0ge1xuICAnQyc6ICB7IGluZGV4OiAwLCBpbnRfdmFsOiAwLCBhY2NpZGVudGFsOiBudWxsIH0sXG4gICdDTic6IHsgaW5kZXg6IDAsIGludF92YWw6IDAsIGFjY2lkZW50YWw6IFwiblwiIH0sXG4gICdDIyc6IHsgaW5kZXg6IDAsIGludF92YWw6IDEsIGFjY2lkZW50YWw6IFwiI1wiIH0sXG4gICdDIyMnOiB7IGluZGV4OiAwLCBpbnRfdmFsOiAyLCBhY2NpZGVudGFsOiBcIiMjXCIgfSxcbiAgJ0NCJzogeyBpbmRleDogMCwgaW50X3ZhbDogLTEsIGFjY2lkZW50YWw6IFwiYlwiIH0sXG4gICdDQkInOiB7IGluZGV4OiAwLCBpbnRfdmFsOiAtMiwgYWNjaWRlbnRhbDogXCJiYlwiIH0sXG4gICdEJzogIHsgaW5kZXg6IDEsIGludF92YWw6IDIsIGFjY2lkZW50YWw6IG51bGwgfSxcbiAgJ0ROJzogeyBpbmRleDogMSwgaW50X3ZhbDogMiwgYWNjaWRlbnRhbDogXCJuXCIgfSxcbiAgJ0QjJzogeyBpbmRleDogMSwgaW50X3ZhbDogMywgYWNjaWRlbnRhbDogXCIjXCIgfSxcbiAgJ0QjIyc6IHsgaW5kZXg6IDEsIGludF92YWw6IDQsIGFjY2lkZW50YWw6IFwiIyNcIiB9LFxuICAnREInOiB7IGluZGV4OiAxLCBpbnRfdmFsOiAxLCBhY2NpZGVudGFsOiBcImJcIiB9LFxuICAnREJCJzogeyBpbmRleDogMSwgaW50X3ZhbDogMCwgYWNjaWRlbnRhbDogXCJiYlwiIH0sXG4gICdFJzogIHsgaW5kZXg6IDIsIGludF92YWw6IDQsIGFjY2lkZW50YWw6IG51bGwgfSxcbiAgJ0VOJzogeyBpbmRleDogMiwgaW50X3ZhbDogNCwgYWNjaWRlbnRhbDogXCJuXCIgfSxcbiAgJ0UjJzogeyBpbmRleDogMiwgaW50X3ZhbDogNSwgYWNjaWRlbnRhbDogXCIjXCIgfSxcbiAgJ0UjIyc6IHsgaW5kZXg6IDIsIGludF92YWw6IDYsIGFjY2lkZW50YWw6IFwiIyNcIiB9LFxuICAnRUInOiB7IGluZGV4OiAyLCBpbnRfdmFsOiAzLCBhY2NpZGVudGFsOiBcImJcIiB9LFxuICAnRUJCJzogeyBpbmRleDogMiwgaW50X3ZhbDogMiwgYWNjaWRlbnRhbDogXCJiYlwiIH0sXG4gICdGJzogIHsgaW5kZXg6IDMsIGludF92YWw6IDUsIGFjY2lkZW50YWw6IG51bGwgfSxcbiAgJ0ZOJzogeyBpbmRleDogMywgaW50X3ZhbDogNSwgYWNjaWRlbnRhbDogXCJuXCIgfSxcbiAgJ0YjJzogeyBpbmRleDogMywgaW50X3ZhbDogNiwgYWNjaWRlbnRhbDogXCIjXCIgfSxcbiAgJ0YjIyc6IHsgaW5kZXg6IDMsIGludF92YWw6IDcsIGFjY2lkZW50YWw6IFwiIyNcIiB9LFxuICAnRkInOiB7IGluZGV4OiAzLCBpbnRfdmFsOiA0LCBhY2NpZGVudGFsOiBcImJcIiB9LFxuICAnRkJCJzogeyBpbmRleDogMywgaW50X3ZhbDogMywgYWNjaWRlbnRhbDogXCJiYlwiIH0sXG4gICdHJzogIHsgaW5kZXg6IDQsIGludF92YWw6IDcsIGFjY2lkZW50YWw6IG51bGwgfSxcbiAgJ0dOJzogeyBpbmRleDogNCwgaW50X3ZhbDogNywgYWNjaWRlbnRhbDogXCJuXCIgfSxcbiAgJ0cjJzogeyBpbmRleDogNCwgaW50X3ZhbDogOCwgYWNjaWRlbnRhbDogXCIjXCIgfSxcbiAgJ0cjIyc6IHsgaW5kZXg6IDQsIGludF92YWw6IDksIGFjY2lkZW50YWw6IFwiIyNcIiB9LFxuICAnR0InOiB7IGluZGV4OiA0LCBpbnRfdmFsOiA2LCBhY2NpZGVudGFsOiBcImJcIiB9LFxuICAnR0JCJzogeyBpbmRleDogNCwgaW50X3ZhbDogNSwgYWNjaWRlbnRhbDogXCJiYlwiIH0sXG4gICdBJzogIHsgaW5kZXg6IDUsIGludF92YWw6IDksIGFjY2lkZW50YWw6IG51bGwgfSxcbiAgJ0FOJzogeyBpbmRleDogNSwgaW50X3ZhbDogOSwgYWNjaWRlbnRhbDogXCJuXCIgfSxcbiAgJ0EjJzogeyBpbmRleDogNSwgaW50X3ZhbDogMTAsIGFjY2lkZW50YWw6IFwiI1wiIH0sXG4gICdBIyMnOiB7IGluZGV4OiA1LCBpbnRfdmFsOiAxMSwgYWNjaWRlbnRhbDogXCIjI1wiIH0sXG4gICdBQic6IHsgaW5kZXg6IDUsIGludF92YWw6IDgsIGFjY2lkZW50YWw6IFwiYlwiIH0sXG4gICdBQkInOiB7IGluZGV4OiA1LCBpbnRfdmFsOiA3LCBhY2NpZGVudGFsOiBcImJiXCIgfSxcbiAgJ0InOiAgeyBpbmRleDogNiwgaW50X3ZhbDogMTEsIGFjY2lkZW50YWw6IG51bGwgfSxcbiAgJ0JOJzogeyBpbmRleDogNiwgaW50X3ZhbDogMTEsIGFjY2lkZW50YWw6IFwiblwiIH0sXG4gICdCIyc6IHsgaW5kZXg6IDYsIGludF92YWw6IDEyLCBhY2NpZGVudGFsOiBcIiNcIiB9LFxuICAnQiMjJzogeyBpbmRleDogNiwgaW50X3ZhbDogMTMsIGFjY2lkZW50YWw6IFwiIyNcIiB9LFxuICAnQkInOiB7IGluZGV4OiA2LCBpbnRfdmFsOiAxMCwgYWNjaWRlbnRhbDogXCJiXCIgfSxcbiAgJ0JCQic6IHsgaW5kZXg6IDYsIGludF92YWw6IDksIGFjY2lkZW50YWw6IFwiYmJcIiB9LFxuICAnUic6IHsgaW5kZXg6IDYsIGludF92YWw6IDksIHJlc3Q6IHRydWUgfSwgLy8gUmVzdFxuICAnWCc6ICB7XG4gICAgaW5kZXg6IDYsXG4gICAgYWNjaWRlbnRhbDogXCJcIixcbiAgICBvY3RhdmU6IDQsXG4gICAgY29kZTogXCJ2M2VcIixcbiAgICBzaGlmdF9yaWdodDogNS41XG4gIH1cbn07XG5cblZleC5GbG93LmtleVByb3BlcnRpZXMubm90ZV9nbHlwaCA9IHtcbiAgLyogRGlhbW9uZCAqL1xuICAnRDAnOiAgeyBjb2RlOiBcInYyN1wiLCBzaGlmdF9yaWdodDogLTAuNSB9LFxuICAnRDEnOiAgeyBjb2RlOiBcInYyZFwiLCBzaGlmdF9yaWdodDogLTAuNSB9LFxuICAnRDInOiAgeyBjb2RlOiBcInYyMlwiLCBzaGlmdF9yaWdodDogLTAuNSB9LFxuICAnRDMnOiAgeyBjb2RlOiBcInY3MFwiLCBzaGlmdF9yaWdodDogLTAuNSB9LFxuXG4gIC8qIFRyaWFuZ2xlICovXG4gICdUMCc6ICB7IGNvZGU6IFwidjQ5XCIsIHNoaWZ0X3JpZ2h0OiAtMiB9LFxuICAnVDEnOiAgeyBjb2RlOiBcInY5M1wiLCBzaGlmdF9yaWdodDogMC41IH0sXG4gICdUMic6ICB7IGNvZGU6IFwidjQwXCIsIHNoaWZ0X3JpZ2h0OiAwLjUgfSxcbiAgJ1QzJzogIHsgY29kZTogXCJ2N2RcIiwgc2hpZnRfcmlnaHQ6IDAuNSB9LFxuXG4gIC8qIENyb3NzICovXG4gICdYMCc6ICB7IGNvZGU6IFwidjkyXCIsIHNoaWZ0X3JpZ2h0OiAtMiB9LFxuICAnWDEnOiAgeyBjb2RlOiBcInY5NVwiLCBzaGlmdF9yaWdodDogLTAuNSB9LFxuICAnWDInOiAgeyBjb2RlOiBcInY3ZlwiLCBzaGlmdF9yaWdodDogMC41IH0sXG4gICdYMyc6ICB7IGNvZGU6IFwidjNiXCIsIHNoaWZ0X3JpZ2h0OiAtMiB9XG59O1xuXG5WZXguRmxvdy5pbnRlZ2VyVG9Ob3RlID0gZnVuY3Rpb24oaW50ZWdlcikge1xuICBpZiAodHlwZW9mKGludGVnZXIpID09IFwidW5kZWZpbmVkXCIpXG4gICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsIFwiVW5kZWZpbmVkIGludGVnZXIgZm9yIGludGVnZXJUb05vdGVcIik7XG5cbiAgaWYgKGludGVnZXIgPCAtMilcbiAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgXCJpbnRlZ2VyVG9Ob3RlIHJlcXVpcmVzIGludGVnZXIgPiAtMjogXCIgKyBpbnRlZ2VyKTtcblxuICB2YXIgbm90ZVZhbHVlID0gVmV4LkZsb3cuaW50ZWdlclRvTm90ZS50YWJsZVtpbnRlZ2VyXTtcbiAgaWYgKCFub3RlVmFsdWUpXG4gICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsIFwiVW5rbm93biBub3RlIHZhbHVlIGZvciBpbnRlZ2VyOiBcIiArXG4gICAgICAgIGludGVnZXIpO1xuXG4gIHJldHVybiBub3RlVmFsdWU7XG59O1xuXG5WZXguRmxvdy5pbnRlZ2VyVG9Ob3RlLnRhYmxlID0ge1xuICAwOiBcIkNcIixcbiAgMTogXCJDI1wiLFxuICAyOiBcIkRcIixcbiAgMzogXCJEI1wiLFxuICA0OiBcIkVcIixcbiAgNTogXCJGXCIsXG4gIDY6IFwiRiNcIixcbiAgNzogXCJHXCIsXG4gIDg6IFwiRyNcIixcbiAgOTogXCJBXCIsXG4gIDEwOiBcIkEjXCIsXG4gIDExOiBcIkJcIlxufTtcblxuXG5WZXguRmxvdy50YWJUb0dseXBoID0gZnVuY3Rpb24oZnJldCkge1xuICB2YXIgZ2x5cGggPSBudWxsO1xuICB2YXIgd2lkdGggPSAwO1xuICB2YXIgc2hpZnRfeSA9IDA7XG5cbiAgaWYgKGZyZXQudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpID09IFwiWFwiKSB7XG4gICAgZ2x5cGggPSBcInY3ZlwiO1xuICAgIHdpZHRoID0gNztcbiAgICBzaGlmdF95ID0gLTQuNTtcbiAgfSBlbHNlIHtcbiAgICB3aWR0aCA9IFZleC5GbG93LnRleHRXaWR0aChmcmV0LnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0ZXh0OiBmcmV0LFxuICAgIGNvZGU6IGdseXBoLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBzaGlmdF95OiBzaGlmdF95XG4gIH07XG59O1xuXG5WZXguRmxvdy50ZXh0V2lkdGggPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiA2ICogdGV4dC50b1N0cmluZygpLmxlbmd0aDtcbn07XG5cblZleC5GbG93LmFydGljdWxhdGlvbkNvZGVzID0gZnVuY3Rpb24oYXJ0aWMpIHtcbiAgcmV0dXJuIFZleC5GbG93LmFydGljdWxhdGlvbkNvZGVzLmFydGljdWxhdGlvbnNbYXJ0aWNdO1xufTtcblxuVmV4LkZsb3cuYXJ0aWN1bGF0aW9uQ29kZXMuYXJ0aWN1bGF0aW9ucyA9IHtcbiAgXCJhLlwiOiB7ICAgLy8gU3RhY2NhdG9cbiAgICBjb2RlOiBcInYyM1wiLFxuICAgIHdpZHRoOiA0LFxuICAgIHNoaWZ0X3JpZ2h0OiAtMixcbiAgICBzaGlmdF91cDogOCxcbiAgICBzaGlmdF9kb3duOiAwLFxuICAgIGJldHdlZW5fbGluZXM6IHRydWVcbiAgfSxcbiAgXCJhdlwiOiB7ICAgLy8gU3RhY2NhdGlzc2ltb1xuICAgIGNvZGU6IFwidjI4XCIsXG4gICAgd2lkdGg6IDQsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfdXA6IDExLFxuICAgIHNoaWZ0X2Rvd246IDUsXG4gICAgYmV0d2Vlbl9saW5lczogdHJ1ZVxuICB9LFxuICBcImE+XCI6IHsgICAvLyBBY2NlbnRcbiAgICBjb2RlOiBcInY0MlwiLFxuICAgIHdpZHRoOiAxMCxcbiAgICBzaGlmdF9yaWdodDogNSxcbiAgICBzaGlmdF91cDogOCxcbiAgICBzaGlmdF9kb3duOiAxLFxuICAgIGJldHdlZW5fbGluZXM6IHRydWVcbiAgfSxcbiAgXCJhLVwiOiB7ICAgLy8gVGVudXRvXG4gICAgY29kZTogXCJ2MjVcIixcbiAgICB3aWR0aDogOSxcbiAgICBzaGlmdF9yaWdodDogLTQsXG4gICAgc2hpZnRfdXA6IDE3LFxuICAgIHNoaWZ0X2Rvd246IDEwLFxuICAgIGJldHdlZW5fbGluZXM6IHRydWVcbiAgfSxcbiAgXCJhXlwiOiB7ICAgLy8gTWFyY2F0b1xuICAgIGNvZGU6IFwidmFcIixcbiAgICB3aWR0aDogOCxcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF91cDogLTQsXG4gICAgc2hpZnRfZG93bjogLTIsXG4gICAgYmV0d2Vlbl9saW5lczogZmFsc2VcbiAgfSxcbiAgXCJhK1wiOiB7ICAgLy8gTGVmdCBoYW5kIHBpenppY2F0b1xuICAgIGNvZGU6IFwidjhiXCIsXG4gICAgd2lkdGg6IDksXG4gICAgc2hpZnRfcmlnaHQ6IC00LFxuICAgIHNoaWZ0X3VwOiAxMixcbiAgICBzaGlmdF9kb3duOiAxMixcbiAgICBiZXR3ZWVuX2xpbmVzOiBmYWxzZVxuICB9LFxuICBcImFvXCI6IHsgICAvLyBTbmFwIHBpenppY2F0b1xuICAgIGNvZGU6IFwidjk0XCIsXG4gICAgd2lkdGg6IDgsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfdXA6IC00LFxuICAgIHNoaWZ0X2Rvd246IDYsXG4gICAgYmV0d2Vlbl9saW5lczogZmFsc2VcbiAgfSxcbiAgXCJhaFwiOiB7ICAgLy8gTmF0dXJhbCBoYXJtb25pYyBvciBvcGVuIG5vdGVcbiAgICBjb2RlOiBcInZiOVwiLFxuICAgIHdpZHRoOiA3LFxuICAgIHNoaWZ0X3JpZ2h0OiAwLFxuICAgIHNoaWZ0X3VwOiAtNCxcbiAgICBzaGlmdF9kb3duOiA0LFxuICAgIGJldHdlZW5fbGluZXM6IGZhbHNlXG4gIH0sXG4gIFwiYUBhXCI6IHsgICAvLyBGZXJtYXRhIGFib3ZlIHN0YWZmXG4gICAgY29kZTogXCJ2NDNcIixcbiAgICB3aWR0aDogMjUsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfdXA6IDgsXG4gICAgc2hpZnRfZG93bjogMTAsXG4gICAgYmV0d2Vlbl9saW5lczogZmFsc2VcbiAgfSxcbiAgXCJhQHVcIjogeyAgIC8vIEZlcm1hdGEgYmVsb3cgc3RhZmZcbiAgICBjb2RlOiBcInY1YlwiLFxuICAgIHdpZHRoOiAyNSxcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF91cDogMCxcbiAgICBzaGlmdF9kb3duOiAtNCxcbiAgICBiZXR3ZWVuX2xpbmVzOiBmYWxzZVxuICB9LFxuICBcImF8XCI6IHsgICAvLyBCb3cgdXAgLSB1cCBzdHJva2VcbiAgICBjb2RlOiBcInY3NVwiLFxuICAgIHdpZHRoOiA4LFxuICAgIHNoaWZ0X3JpZ2h0OiAwLFxuICAgIHNoaWZ0X3VwOiA4LFxuICAgIHNoaWZ0X2Rvd246IDEwLFxuICAgIGJldHdlZW5fbGluZXM6IGZhbHNlXG4gIH0sXG4gIFwiYW1cIjogeyAgIC8vIEJvdyBkb3duIC0gZG93biBzdHJva2VcbiAgICBjb2RlOiBcInY5N1wiLFxuICAgIHdpZHRoOiAxMyxcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF91cDogMTAsXG4gICAgc2hpZnRfZG93bjogMTIsXG4gICAgYmV0d2Vlbl9saW5lczogZmFsc2VcbiAgfSxcbiAgXCJhLFwiOiB7ICAgLy8gQ2hva2VkXG4gICAgY29kZTogXCJ2YjNcIixcbiAgICB3aWR0aDogNixcbiAgICBzaGlmdF9yaWdodDogOCxcbiAgICBzaGlmdF91cDogLTQsXG4gICAgc2hpZnRfZG93bjogNCxcbiAgICBiZXR3ZWVuX2xpbmVzOiBmYWxzZVxuICB9XG59O1xuXG5WZXguRmxvdy5hY2NpZGVudGFsQ29kZXMgPSBmdW5jdGlvbihhY2MpIHtcbiAgcmV0dXJuIFZleC5GbG93LmFjY2lkZW50YWxDb2Rlcy5hY2NpZGVudGFsc1thY2NdO1xufTtcblxuVmV4LkZsb3cuYWNjaWRlbnRhbENvZGVzLmFjY2lkZW50YWxzID0ge1xuICBcIiNcIjoge1xuICAgIGNvZGU6IFwidjE4XCIsXG4gICAgd2lkdGg6IDEwLFxuICAgIGdyYWNlbm90ZV93aWR0aDogNC41LFxuICAgIHNoaWZ0X3JpZ2h0OiAwLFxuICAgIHNoaWZ0X2Rvd246IDBcbiAgfSxcbiAgXCIjI1wiOiB7XG4gICAgY29kZTogXCJ2N2ZcIixcbiAgICB3aWR0aDogMTMsXG4gICAgZ3JhY2Vub3RlX3dpZHRoOiA2LFxuICAgIHNoaWZ0X3JpZ2h0OiAtMSxcbiAgICBzaGlmdF9kb3duOiAwXG4gIH0sXG4gIFwiYlwiOiB7XG4gICAgY29kZTogXCJ2NDRcIixcbiAgICB3aWR0aDogOCxcbiAgICBncmFjZW5vdGVfd2lkdGg6IDQuNSxcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF9kb3duOiAwXG4gIH0sXG4gIFwiYmJcIjoge1xuICAgIGNvZGU6IFwidjI2XCIsXG4gICAgd2lkdGg6IDE0LFxuICAgIGdyYWNlbm90ZV93aWR0aDogOCxcbiAgICBzaGlmdF9yaWdodDogLTMsXG4gICAgc2hpZnRfZG93bjogMFxuICB9LFxuICBcIm5cIjoge1xuICAgIGNvZGU6IFwidjRlXCIsXG4gICAgd2lkdGg6IDgsXG4gICAgZ3JhY2Vub3RlX3dpZHRoOiA0LjUsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfZG93bjogMFxuICB9LFxuICBcIntcIjogeyAgIC8vIExlZnQgcGFyZW4gZm9yIGNhdXRpb25hcnkgYWNjaWRlbnRhbHNcbiAgICBjb2RlOiBcInY5Y1wiLFxuICAgIHdpZHRoOiA1LFxuICAgIHNoaWZ0X3JpZ2h0OiAyLFxuICAgIHNoaWZ0X2Rvd246IDBcbiAgfSxcbiAgXCJ9XCI6IHsgICAvLyBSaWdodCBwYXJlbiBmb3IgY2F1dGlvbmFyeSBhY2NpZGVudGFsc1xuICAgIGNvZGU6IFwidjg0XCIsXG4gICAgd2lkdGg6IDUsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfZG93bjogMFxuICB9LFxuICBcImRiXCI6IHtcbiAgICBjb2RlOiBcInY5ZVwiLFxuICAgIHdpZHRoOiAxNixcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF9kb3duOiAwXG4gIH0sXG4gIFwiZFwiOiB7XG4gICAgY29kZTogXCJ2YWJcIixcbiAgICB3aWR0aDogMTAsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfZG93bjogMFxuICB9LFxuICBcImJic1wiOiB7XG4gICAgY29kZTogXCJ2OTBcIixcbiAgICB3aWR0aDogMTMsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfZG93bjogMFxuICB9LFxuICBcIisrXCI6IHtcbiAgICBjb2RlOiBcInY1MVwiLFxuICAgIHdpZHRoOiAxMyxcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF9kb3duOiAwXG4gIH0sXG4gIFwiK1wiOiB7XG4gICAgY29kZTogXCJ2NzhcIixcbiAgICB3aWR0aDogOCxcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF9kb3duOiAwXG4gIH1cbn07XG5cblZleC5GbG93LmFjY2lkZW50YWxDb2x1bW5zVGFibGUgPSB7XG4gIDEgOiB7IGEgOiBbMV0sIGIgOiBbMV19LFxuICAyIDogeyBhIDogWzEsIDJdIH0sXG4gIDMgOiB7IGEgOiBbMSwgMywgMl0sIGIgOiBbMSwgMiwgMV0sIHNlY29uZF9vbl9ib3R0b20gOiBbMSwgMiwgM10gfSxcbiAgNCA6IHsgYSA6IFsxLCAzLCA0LCAyXSwgYiA6IFsxLCAyLCAzLCAxXSwgc3BhY2VkX291dF90ZXRyYWNob3JkIDogWzEsIDIsIDEsIDJdIH0sXG4gIDUgOiB7IGEgOiBbMSwgMywgNSwgNCwgMl0sIGIgOiBbMSwgMiwgNCwgMywgMV0sXG4gICAgICAgIHNwYWNlZF9vdXRfcGVudGFjaG9yZCA6IFsxLCAyLCAzLCAyLCAxXSxcbiAgICAgICAgdmVyeV9zcGFjZWRfb3V0X3BlbnRhY2hvcmQgOiBbMSwgMiwgMSwgMiwgMV0gfSxcbiAgNiA6IHsgYSA6IFsxLCAzLCA1LCA2LCA0LCAyXSwgYiA6IFsxLCAyLCA0LCA1LCAzLCAxXSxcbiAgICAgICAgc3BhY2VkX291dF9oZXhhY2hvcmQgOiBbMSwgMywgMiwgMSwgMywgMl0sXG4gICAgICAgIHZlcnlfc3BhY2VkX291dF9oZXhhY2hvcmQgOiBbMSwgMiwgMSwgMiwgMSwgMl0gfVxufTtcblxuVmV4LkZsb3cub3JuYW1lbnRDb2RlcyA9IGZ1bmN0aW9uKGFjYykge1xuICByZXR1cm4gVmV4LkZsb3cub3JuYW1lbnRDb2Rlcy5vcm5hbWVudHNbYWNjXTtcbn07XG5cblZleC5GbG93Lm9ybmFtZW50Q29kZXMub3JuYW1lbnRzID0ge1xuICBcIm1vcmRlbnRcIjoge1xuICAgIGNvZGU6IFwidjFlXCIsXG4gICAgc2hpZnRfcmlnaHQ6IDEsXG4gICAgc2hpZnRfdXA6IDAsXG4gICAgc2hpZnRfZG93bjogNSxcbiAgICB3aWR0aDogMTQsXG4gIH0sXG4gIFwibW9yZGVudF9pbnZlcnRlZFwiOiB7XG4gICAgY29kZTogXCJ2NDVcIixcbiAgICBzaGlmdF9yaWdodDogMSxcbiAgICBzaGlmdF91cDogMCxcbiAgICBzaGlmdF9kb3duOiA1LFxuICAgIHdpZHRoOiAxNCxcbiAgfSxcbiAgXCJ0dXJuXCI6IHtcbiAgICBjb2RlOiBcInY3MlwiLFxuICAgIHNoaWZ0X3JpZ2h0OiAxLFxuICAgIHNoaWZ0X3VwOiAwLFxuICAgIHNoaWZ0X2Rvd246IDUsXG4gICAgd2lkdGg6IDIwLFxuICB9LFxuICBcInR1cm5faW52ZXJ0ZWRcIjoge1xuICAgIGNvZGU6IFwidjMzXCIsXG4gICAgc2hpZnRfcmlnaHQ6IDEsXG4gICAgc2hpZnRfdXA6IDAsXG4gICAgc2hpZnRfZG93bjogNixcbiAgICB3aWR0aDogMjAsXG4gIH0sXG4gIFwidHJcIjoge1xuICAgIGNvZGU6IFwidjFmXCIsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfdXA6IDUsXG4gICAgc2hpZnRfZG93bjogMTUsXG4gICAgd2lkdGg6IDEwLFxuICB9LFxuICBcInVwcHJhbGxcIjoge1xuICAgIGNvZGU6IFwidjYwXCIsXG4gICAgc2hpZnRfcmlnaHQ6IDEsXG4gICAgc2hpZnRfdXA6IC0zLFxuICAgIHNoaWZ0X2Rvd246IDYsXG4gICAgd2lkdGg6IDIwLFxuICB9LFxuICBcImRvd25wcmFsbFwiOiB7XG4gICAgY29kZTogXCJ2YjRcIixcbiAgICBzaGlmdF9yaWdodDogMSxcbiAgICBzaGlmdF91cDogLTMsXG4gICAgc2hpZnRfZG93bjogNixcbiAgICB3aWR0aDogMjAsXG4gIH0sXG4gIFwicHJhbGx1cFwiOiB7XG4gICAgY29kZTogXCJ2NmRcIixcbiAgICBzaGlmdF9yaWdodDogMSxcbiAgICBzaGlmdF91cDogLTMsXG4gICAgc2hpZnRfZG93bjogNixcbiAgICB3aWR0aDogMjAsXG4gIH0sXG4gIFwicHJhbGxkb3duXCI6IHtcbiAgICBjb2RlOiBcInYyY1wiLFxuICAgIHNoaWZ0X3JpZ2h0OiAxLFxuICAgIHNoaWZ0X3VwOiAtMyxcbiAgICBzaGlmdF9kb3duOiA2LFxuICAgIHdpZHRoOiAyMCxcbiAgfSxcbiAgXCJ1cG1vcmRlbnRcIjoge1xuICAgIGNvZGU6IFwidjI5XCIsXG4gICAgc2hpZnRfcmlnaHQ6IDEsXG4gICAgc2hpZnRfdXA6IC0zLFxuICAgIHNoaWZ0X2Rvd246IDYsXG4gICAgd2lkdGg6IDIwLFxuICB9LFxuICBcImRvd25tb3JkZW50XCI6IHtcbiAgICBjb2RlOiBcInY2OFwiLFxuICAgIHNoaWZ0X3JpZ2h0OiAxLFxuICAgIHNoaWZ0X3VwOiAtMyxcbiAgICBzaGlmdF9kb3duOiA2LFxuICAgIHdpZHRoOiAyMCxcbiAgfSxcbiAgXCJsaW5lcHJhbGxcIjoge1xuICAgIGNvZGU6IFwidjIwXCIsXG4gICAgc2hpZnRfcmlnaHQ6IDEsXG4gICAgc2hpZnRfdXA6IC0zLFxuICAgIHNoaWZ0X2Rvd246IDYsXG4gICAgd2lkdGg6IDIwLFxuICB9LFxuICBcInByYWxscHJhbGxcIjoge1xuICAgIGNvZGU6IFwidjg2XCIsXG4gICAgc2hpZnRfcmlnaHQ6IDEsXG4gICAgc2hpZnRfdXA6IC0zLFxuICAgIHNoaWZ0X2Rvd246IDYsXG4gICAgd2lkdGg6IDIwLFxuICB9XG59O1xuXG5WZXguRmxvdy5rZXlTaWduYXR1cmUgPSBmdW5jdGlvbihzcGVjKSB7XG4gIHZhciBrZXlTcGVjID0gVmV4LkZsb3cua2V5U2lnbmF0dXJlLmtleVNwZWNzW3NwZWNdO1xuXG4gIGlmICgha2V5U3BlYykge1xuICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEtleVNpZ25hdHVyZVwiLFxuICAgICAgICBcIkJhZCBrZXkgc2lnbmF0dXJlIHNwZWM6ICdcIiArIHNwZWMgKyBcIidcIik7XG4gIH1cblxuICBpZiAoIWtleVNwZWMuYWNjKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG5vdGVzID0gVmV4LkZsb3cua2V5U2lnbmF0dXJlLmFjY2lkZW50YWxMaXN0KGtleVNwZWMuYWNjKTtcblxuICB2YXIgYWNjX2xpc3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlTcGVjLm51bTsgKytpKSB7XG4gICAgdmFyIGxpbmUgPSBub3Rlc1tpXTtcbiAgICBhY2NfbGlzdC5wdXNoKHt0eXBlOiBrZXlTcGVjLmFjYywgbGluZTogbGluZX0pO1xuICB9XG5cbiAgcmV0dXJuIGFjY19saXN0O1xufTtcblxuVmV4LkZsb3cua2V5U2lnbmF0dXJlLmtleVNwZWNzID0ge1xuICBcIkNcIjoge2FjYzogbnVsbCwgbnVtOiAwfSxcbiAgXCJBbVwiOiB7YWNjOiBudWxsLCBudW06IDB9LFxuICBcIkZcIjoge2FjYzogXCJiXCIsIG51bTogMX0sXG4gIFwiRG1cIjoge2FjYzogXCJiXCIsIG51bTogMX0sXG4gIFwiQmJcIjoge2FjYzogXCJiXCIsIG51bTogMn0sXG4gIFwiR21cIjoge2FjYzogXCJiXCIsIG51bTogMn0sXG4gIFwiRWJcIjoge2FjYzogXCJiXCIsIG51bTogM30sXG4gIFwiQ21cIjoge2FjYzogXCJiXCIsIG51bTogM30sXG4gIFwiQWJcIjoge2FjYzogXCJiXCIsIG51bTogNH0sXG4gIFwiRm1cIjoge2FjYzogXCJiXCIsIG51bTogNH0sXG4gIFwiRGJcIjoge2FjYzogXCJiXCIsIG51bTogNX0sXG4gIFwiQmJtXCI6IHthY2M6IFwiYlwiLCBudW06IDV9LFxuICBcIkdiXCI6IHthY2M6IFwiYlwiLCBudW06IDZ9LFxuICBcIkVibVwiOiB7YWNjOiBcImJcIiwgbnVtOiA2fSxcbiAgXCJDYlwiOiB7YWNjOiBcImJcIiwgbnVtOiA3fSxcbiAgXCJBYm1cIjoge2FjYzogXCJiXCIsIG51bTogN30sXG4gIFwiR1wiOiB7YWNjOiBcIiNcIiwgbnVtOiAxfSxcbiAgXCJFbVwiOiB7YWNjOiBcIiNcIiwgbnVtOiAxfSxcbiAgXCJEXCI6IHthY2M6IFwiI1wiLCBudW06IDJ9LFxuICBcIkJtXCI6IHthY2M6IFwiI1wiLCBudW06IDJ9LFxuICBcIkFcIjoge2FjYzogXCIjXCIsIG51bTogM30sXG4gIFwiRiNtXCI6IHthY2M6IFwiI1wiLCBudW06IDN9LFxuICBcIkVcIjoge2FjYzogXCIjXCIsIG51bTogNH0sXG4gIFwiQyNtXCI6IHthY2M6IFwiI1wiLCBudW06IDR9LFxuICBcIkJcIjoge2FjYzogXCIjXCIsIG51bTogNX0sXG4gIFwiRyNtXCI6IHthY2M6IFwiI1wiLCBudW06IDV9LFxuICBcIkYjXCI6IHthY2M6IFwiI1wiLCBudW06IDZ9LFxuICBcIkQjbVwiOiB7YWNjOiBcIiNcIiwgbnVtOiA2fSxcbiAgXCJDI1wiOiB7YWNjOiBcIiNcIiwgbnVtOiA3fSxcbiAgXCJBI21cIjoge2FjYzogXCIjXCIsIG51bTogN31cbn07XG5cblZleC5GbG93LnVuaWNvZGUgPSB7XG4gIC8vIFVuaWNvZGUgYWNjaWRlbnRhbHNcbiAgXCJzaGFycFwiOiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KCcyNjZGJywgMTYpKSxcbiAgXCJmbGF0XCIgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KCcyNjZEJywgMTYpKSxcbiAgXCJuYXR1cmFsXCI6IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoJzI2NkUnLCAxNikpLFxuICAvLyBNYWpvciBDaG9yZFxuICBcInRyaWFuZ2xlXCI6IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoJzI1QjMnLCAxNikpLFxuICAvLyBoYWxmLWRpbWluaXNoZWRcbiAgXCJvLXdpdGgtc2xhc2hcIjogU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCgnMDBGOCcsIDE2KSksXG4gICAvLyBEaW1pbmlzaGVkXG4gIFwiZGVncmVlc1wiOiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KCcwMEIwJywgMTYpKSxcbiAgXCJjaXJjbGVcIjogU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCgnMjVDQicsIDE2KSlcbn07XG5cblZleC5GbG93LmtleVNpZ25hdHVyZS5hY2NpZGVudGFsTGlzdCA9IGZ1bmN0aW9uKGFjYykge1xuICBpZiAoYWNjID09IFwiYlwiKSB7XG4gICAgcmV0dXJuIFsyLCAwLjUsIDIuNSwgMSwgMywgMS41LCAzLjVdO1xuICB9XG4gIGVsc2UgaWYgKGFjYyA9PSBcIiNcIikge1xuICAgIHJldHVybiBbMCwgMS41LCAtMC41LCAxLCAyLjUsIDAuNSwgMl07IH1cbn07XG5cblZleC5GbG93LnBhcnNlTm90ZUR1cmF0aW9uU3RyaW5nID0gZnVuY3Rpb24oZHVyYXRpb25TdHJpbmcpIHtcbiAgaWYgKHR5cGVvZihkdXJhdGlvblN0cmluZykgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvKFxcZCpcXC8/XFxkK3xbYS16XSkoZCopKFtucmhtc118JCkvO1xuXG4gIHZhciByZXN1bHQgPSByZWdleHAuZXhlYyhkdXJhdGlvblN0cmluZyk7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZHVyYXRpb24gPSByZXN1bHRbMV07XG4gIHZhciBkb3RzID0gcmVzdWx0WzJdLmxlbmd0aDtcbiAgdmFyIHR5cGUgPSByZXN1bHRbM107XG5cbiAgaWYgKHR5cGUubGVuZ3RoID09PSAwKSB7XG4gICAgdHlwZSA9IFwiblwiO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgZG90czogZG90cyxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG59O1xuXG5WZXguRmxvdy5wYXJzZU5vdGVEYXRhID0gZnVuY3Rpb24obm90ZURhdGEpIHtcbiAgdmFyIGR1cmF0aW9uID0gbm90ZURhdGEuZHVyYXRpb247XG5cbiAgLy8gUHJlc2VydmUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHlcbiAgdmFyIGR1cmF0aW9uU3RyaW5nRGF0YSA9IFZleC5GbG93LnBhcnNlTm90ZUR1cmF0aW9uU3RyaW5nKGR1cmF0aW9uKTtcbiAgaWYgKCFkdXJhdGlvblN0cmluZ0RhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciB0aWNrcyA9IFZleC5GbG93LmR1cmF0aW9uVG9UaWNrcyhkdXJhdGlvblN0cmluZ0RhdGEuZHVyYXRpb24pO1xuICBpZiAodGlja3MgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBub3RlRGF0YS50eXBlO1xuXG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCEodHlwZSA9PT0gXCJuXCIgfHwgdHlwZSA9PT0gXCJyXCIgfHwgdHlwZSA9PT0gXCJoXCIgfHxcbiAgICAgICAgICB0eXBlID09PSBcIm1cIiB8fCB0eXBlID09PSBcInNcIikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gZHVyYXRpb25TdHJpbmdEYXRhLnR5cGU7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0eXBlID0gXCJuXCI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRvdHMgPSAwO1xuICBpZiAobm90ZURhdGEuZG90cykge1xuICAgIGRvdHMgPSBub3RlRGF0YS5kb3RzO1xuICB9IGVsc2Uge1xuICAgIGRvdHMgPSBkdXJhdGlvblN0cmluZ0RhdGEuZG90cztcbiAgfVxuXG4gIGlmICh0eXBlb2YoZG90cykgIT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjdXJyZW50VGlja3MgPSB0aWNrcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRvdHM7IGkrKykge1xuICAgIGlmIChjdXJyZW50VGlja3MgPD0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY3VycmVudFRpY2tzID0gY3VycmVudFRpY2tzIC8gMjtcbiAgICB0aWNrcyArPSBjdXJyZW50VGlja3M7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGR1cmF0aW9uOiBkdXJhdGlvblN0cmluZ0RhdGEuZHVyYXRpb24sXG4gICAgdHlwZTogdHlwZSxcbiAgICBkb3RzOiBkb3RzLFxuICAgIHRpY2tzOiB0aWNrc1xuICB9O1xufTtcblxuLy8gVXNlZCB0byBjb252ZXJ0IGR1cmF0aW9uIGFsaWFzZXMgdG8gdGhlIG51bWJlciBiYXNlZCBkdXJhdGlvbi5cbi8vIElmIHRoZSBpbnB1dCBpc24ndCBhbiBhbGlhcywgc2ltcGx5IHJldHVybiB0aGUgaW5wdXQuXG4vL1xuLy8gZXhhbXBsZTogJ3EnIC0+ICc0JywgJzgnIC0+ICc4J1xuVmV4LkZsb3cuc2FuaXRpemVEdXJhdGlvbiA9IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gIHZhciBhbGlhcyA9IFZleC5GbG93LmR1cmF0aW9uQWxpYXNlc1tkdXJhdGlvbl07XG4gIGlmIChhbGlhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZHVyYXRpb24gPSBhbGlhcztcbiAgfVxuXG4gIGlmIChWZXguRmxvdy5kdXJhdGlvblRvVGlja3MuZHVyYXRpb25zW2R1cmF0aW9uXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFZleC5SRVJSKCdCYWRBcmd1bWVudHMnLFxuICAgICAgJ1RoZSBwcm92aWRlZCBkdXJhdGlvbiBpcyBub3QgdmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiBkdXJhdGlvbjtcbn07XG5cbi8vIENvbnZlcnQgdGhlIGBkdXJhdGlvbmAgdG8gYW4gZnJhY3Rpb25cblZleC5GbG93LmR1cmF0aW9uVG9GcmFjdGlvbiA9IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gIHJldHVybiBuZXcgVmV4LkZsb3cuRnJhY3Rpb24oKS5wYXJzZShWZXguRmxvdy5zYW5pdGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSk7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBgZHVyYXRpb25gIHRvIGFuIG51bWJlclxuVmV4LkZsb3cuZHVyYXRpb25Ub051bWJlciA9IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gIHJldHVybiBWZXguRmxvdy5kdXJhdGlvblRvRnJhY3Rpb24oZHVyYXRpb24pLnZhbHVlKCk7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBgZHVyYXRpb25gIHRvIHRvdGFsIHRpY2tzXG5WZXguRmxvdy5kdXJhdGlvblRvVGlja3MgPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICBkdXJhdGlvbiA9IFZleC5GbG93LnNhbml0aXplRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gIHZhciB0aWNrcyA9IFZleC5GbG93LmR1cmF0aW9uVG9UaWNrcy5kdXJhdGlvbnNbZHVyYXRpb25dO1xuICBpZiAodGlja3MgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRpY2tzO1xufTtcblxuVmV4LkZsb3cuZHVyYXRpb25Ub1RpY2tzLmR1cmF0aW9ucyA9IHtcbiAgXCIxLzJcIjogIFZleC5GbG93LlJFU09MVVRJT04gKiAyLFxuICBcIjFcIjogICAgVmV4LkZsb3cuUkVTT0xVVElPTiAvIDEsXG4gIFwiMlwiOiAgICBWZXguRmxvdy5SRVNPTFVUSU9OIC8gMixcbiAgXCI0XCI6ICAgIFZleC5GbG93LlJFU09MVVRJT04gLyA0LFxuICBcIjhcIjogICAgVmV4LkZsb3cuUkVTT0xVVElPTiAvIDgsXG4gIFwiMTZcIjogICBWZXguRmxvdy5SRVNPTFVUSU9OIC8gMTYsXG4gIFwiMzJcIjogICBWZXguRmxvdy5SRVNPTFVUSU9OIC8gMzIsXG4gIFwiNjRcIjogICBWZXguRmxvdy5SRVNPTFVUSU9OIC8gNjQsXG4gIFwiMTI4XCI6ICBWZXguRmxvdy5SRVNPTFVUSU9OIC8gMTI4LFxuICBcIjI1NlwiOiAgVmV4LkZsb3cuUkVTT0xVVElPTiAvIDI1NlxufTtcblxuVmV4LkZsb3cuZHVyYXRpb25BbGlhc2VzID0ge1xuICBcIndcIjogXCIxXCIsXG4gIFwiaFwiOiBcIjJcIixcbiAgXCJxXCI6IFwiNFwiLFxuXG4gIC8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgZHVyYXRpb24gdXNlZCB0byByZW5kZXIgYmFycyAoQmFyTm90ZSkuIEJhcnMgbm8gbG9uZ2VyXG4gIC8vIGNvbnN1bWUgdGlja3MsIHNvIHRoaXMgc2hvdWxkIGJlIGEgbm8tb3AuXG4gIC8vXG4gIC8vIFRPRE8oMHhmZSk6IFRoaXMgbmVlZHMgdG8gYmUgY2xlYW5lZCB1cC5cbiAgXCJiXCI6IFwiMjU2XCJcbn07XG5cblZleC5GbG93LmR1cmF0aW9uVG9HbHlwaCA9IGZ1bmN0aW9uKGR1cmF0aW9uLCB0eXBlKSB7XG4gIGR1cmF0aW9uID0gVmV4LkZsb3cuc2FuaXRpemVEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgdmFyIGNvZGUgPSBWZXguRmxvdy5kdXJhdGlvblRvR2x5cGguZHVyYXRpb25fY29kZXNbZHVyYXRpb25dO1xuICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIXR5cGUpIHtcbiAgICB0eXBlID0gXCJuXCI7XG4gIH1cblxuICB2YXIgZ2x5cGhUeXBlUHJvcGVydGllcyA9IGNvZGUudHlwZVt0eXBlXTtcbiAgaWYgKGdseXBoVHlwZVByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIFZleC5NZXJnZShWZXguTWVyZ2Uoe30sIGNvZGUuY29tbW9uKSwgZ2x5cGhUeXBlUHJvcGVydGllcyk7XG59O1xuXG5WZXguRmxvdy5kdXJhdGlvblRvR2x5cGguZHVyYXRpb25fY29kZXMgPSB7XG4gIFwiMS8yXCI6IHtcbiAgICBjb21tb246IHtcbiAgICAgIGhlYWRfd2lkdGg6IDIyLFxuICAgICAgc3RlbTogZmFsc2UsXG4gICAgICBzdGVtX29mZnNldDogMCxcbiAgICAgIGZsYWc6IGZhbHNlLFxuICAgICAgc3RlbV91cF9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIHN0ZW1fZG93bl9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIGdyYWNlbm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogLVZleC5GbG93LlNURU1fSEVJR0hULFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fZG93bl9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIHRhYm5vdGVfc3RlbV91cF9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIHRhYm5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLVZleC5GbG93LlNURU1fSEVJR0hULFxuICAgICAgZG90X3NoaWZ0WTogMCxcbiAgICAgIGxpbmVfYWJvdmU6IDAsXG4gICAgICBsaW5lX2JlbG93OiAwXG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICBcIm5cIjogeyAvLyBCcmV2ZSBub3RlXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2NTNcIlxuICAgICAgfSxcbiAgICAgIFwiaFwiOiB7IC8vIEJyZXZlIG5vdGUgaGFybW9uaWNcbiAgICAgICAgY29kZV9oZWFkOiBcInY1OVwiXG4gICAgICB9LFxuICAgICAgXCJtXCI6IHsgLy8gQnJldmUgbm90ZSBtdXRlZCAtXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2ZlwiLFxuICAgICAgICBzdGVtX29mZnNldDogMFxuICAgICAgfSxcbiAgICAgIFwiclwiOiB7IC8vIEJyZXZlIHJlc3RcbiAgICAgICAgY29kZV9oZWFkOiBcInYzMVwiLFxuICAgICAgICBoZWFkX3dpZHRoOiAyNCxcbiAgICAgICAgcmVzdDogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246IFwiQi81XCIsXG4gICAgICAgIGRvdF9zaGlmdFk6IDAuNVxuICAgICAgfSxcbiAgICAgIFwic1wiOiB7IC8vIEJyZXZlIG5vdGUgc2xhc2ggLVxuICAgICAgICAvLyBEcmF3biB3aXRoIGNhbnZhcyBwcmltaXRpdmVzXG4gICAgICAgIGhlYWRfd2lkdGg6IDE1LFxuICAgICAgICBwb3NpdGlvbjogXCJCLzRcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCIxXCI6IHtcbiAgICBjb21tb246IHtcbiAgICAgIGhlYWRfd2lkdGg6IDE2LFxuICAgICAgc3RlbTogZmFsc2UsXG4gICAgICBzdGVtX29mZnNldDogMCxcbiAgICAgIGZsYWc6IGZhbHNlLFxuICAgICAgc3RlbV91cF9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIHN0ZW1fZG93bl9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIGdyYWNlbm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogLVZleC5GbG93LlNURU1fSEVJR0hULFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fZG93bl9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIHRhYm5vdGVfc3RlbV91cF9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIHRhYm5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLVZleC5GbG93LlNURU1fSEVJR0hULFxuICAgICAgZG90X3NoaWZ0WTogMCxcbiAgICAgIGxpbmVfYWJvdmU6IDAsXG4gICAgICBsaW5lX2JlbG93OiAwXG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICBcIm5cIjogeyAvLyBXaG9sZSBub3RlXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2MWRcIlxuICAgICAgfSxcbiAgICAgIFwiaFwiOiB7IC8vIFdob2xlIG5vdGUgaGFybW9uaWNcbiAgICAgICAgY29kZV9oZWFkOiBcInY0NlwiXG4gICAgICB9LFxuICAgICAgXCJtXCI6IHsgLy8gV2hvbGUgbm90ZSBtdXRlZFxuICAgICAgICBjb2RlX2hlYWQ6IFwidjkyXCIsXG4gICAgICAgIHN0ZW1fb2Zmc2V0OiAtM1xuICAgICAgfSxcbiAgICAgIFwiclwiOiB7IC8vIFdob2xlIHJlc3RcbiAgICAgICAgY29kZV9oZWFkOiBcInY1Y1wiLFxuICAgICAgICBoZWFkX3dpZHRoOiAxMixcbiAgICAgICAgcmVzdDogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246IFwiRC81XCIsXG4gICAgICAgIGRvdF9zaGlmdFk6IDAuNVxuICAgICAgfSxcbiAgICAgIFwic1wiOiB7IC8vIFdob2xlIG5vdGUgc2xhc2hcbiAgICAgICAgLy8gRHJhd24gd2l0aCBjYW52YXMgcHJpbWl0aXZlc1xuICAgICAgICBoZWFkX3dpZHRoOiAxNSxcbiAgICAgICAgcG9zaXRpb246IFwiQi80XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiMlwiOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICBoZWFkX3dpZHRoOiAxMCxcbiAgICAgIHN0ZW06IHRydWUsXG4gICAgICBzdGVtX29mZnNldDogMCxcbiAgICAgIGZsYWc6IGZhbHNlLFxuICAgICAgc3RlbV91cF9leHRlbnNpb246IDAsXG4gICAgICBzdGVtX2Rvd25fZXh0ZW5zaW9uOiAwLFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fdXBfZXh0ZW5zaW9uOiAtMTQsXG4gICAgICBncmFjZW5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLTE0LFxuICAgICAgdGFibm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogMCxcbiAgICAgIHRhYm5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogMCxcbiAgICAgIGRvdF9zaGlmdFk6IDAsXG4gICAgICBsaW5lX2Fib3ZlOiAwLFxuICAgICAgbGluZV9iZWxvdzogMFxuICAgIH0sXG4gICAgdHlwZToge1xuICAgICAgXCJuXCI6IHsgLy8gSGFsZiBub3RlXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2ODFcIlxuICAgICAgfSxcbiAgICAgIFwiaFwiOiB7IC8vIEhhbGYgbm90ZSBoYXJtb25pY1xuICAgICAgICBjb2RlX2hlYWQ6IFwidjJkXCJcbiAgICAgIH0sXG4gICAgICBcIm1cIjogeyAvLyBIYWxmIG5vdGUgbXV0ZWRcbiAgICAgICAgY29kZV9oZWFkOiBcInY5NVwiLFxuICAgICAgICBzdGVtX29mZnNldDogLTNcbiAgICAgIH0sXG4gICAgICBcInJcIjogeyAvLyBIYWxmIHJlc3RcbiAgICAgICAgY29kZV9oZWFkOiBcInZjXCIsXG4gICAgICAgIGhlYWRfd2lkdGg6IDEyLFxuICAgICAgICBzdGVtOiBmYWxzZSxcbiAgICAgICAgcmVzdDogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246IFwiQi80XCIsXG4gICAgICAgIGRvdF9zaGlmdFk6IC0wLjVcbiAgICAgIH0sXG4gICAgICBcInNcIjogeyAvLyBIYWxmIG5vdGUgc2xhc2hcbiAgICAgICAgLy8gRHJhd24gd2l0aCBjYW52YXMgcHJpbWl0aXZlc1xuICAgICAgICBoZWFkX3dpZHRoOiAxNSxcbiAgICAgICAgcG9zaXRpb246IFwiQi80XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiNFwiOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICBoZWFkX3dpZHRoOiAxMCxcbiAgICAgIHN0ZW06IHRydWUsXG4gICAgICBzdGVtX29mZnNldDogMCxcbiAgICAgIGZsYWc6IGZhbHNlLFxuICAgICAgc3RlbV91cF9leHRlbnNpb246IDAsXG4gICAgICBzdGVtX2Rvd25fZXh0ZW5zaW9uOiAwLFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fdXBfZXh0ZW5zaW9uOiAtMTQsXG4gICAgICBncmFjZW5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLTE0LFxuICAgICAgdGFibm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogMCxcbiAgICAgIHRhYm5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogMCxcbiAgICAgIGRvdF9zaGlmdFk6IDAsXG4gICAgICBsaW5lX2Fib3ZlOiAwLFxuICAgICAgbGluZV9iZWxvdzogMFxuICAgIH0sXG4gICAgdHlwZToge1xuICAgICAgXCJuXCI6IHsgLy8gUXVhcnRlciBub3RlXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2YlwiXG4gICAgICB9LFxuICAgICAgXCJoXCI6IHsgLy8gUXVhcnRlciBoYXJtb25pY1xuICAgICAgICBjb2RlX2hlYWQ6IFwidjIyXCJcbiAgICAgIH0sXG4gICAgICBcIm1cIjogeyAvLyBRdWFydGVyIG11dGVkXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2M2VcIixcbiAgICAgICAgc3RlbV9vZmZzZXQ6IC0zXG4gICAgICB9LFxuICAgICAgXCJyXCI6IHsgLy8gUXVhcnRlciByZXN0XG4gICAgICAgIGNvZGVfaGVhZDogXCJ2N2NcIixcbiAgICAgICAgaGVhZF93aWR0aDogOCxcbiAgICAgICAgc3RlbTogZmFsc2UsXG4gICAgICAgIHJlc3Q6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBcIkIvNFwiLFxuICAgICAgICBkb3Rfc2hpZnRZOiAtMC41LFxuICAgICAgICBsaW5lX2Fib3ZlOiAxLjUsXG4gICAgICAgIGxpbmVfYmVsb3c6IDEuNVxuICAgICAgfSxcbiAgICAgIFwic1wiOiB7IC8vIFF1YXJ0ZXIgc2xhc2hcbiAgICAgICAgIC8vIERyYXduIHdpdGggY2FudmFzIHByaW1pdGl2ZXNcbiAgICAgICAgIGhlYWRfd2lkdGg6IDE1LFxuICAgICAgICAgcG9zaXRpb246IFwiQi80XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiOFwiOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICBoZWFkX3dpZHRoOiAxMCxcbiAgICAgIHN0ZW06IHRydWUsXG4gICAgICBzdGVtX29mZnNldDogMCxcbiAgICAgIGZsYWc6IHRydWUsXG4gICAgICBiZWFtX2NvdW50OiAxLFxuICAgICAgY29kZV9mbGFnX3Vwc3RlbTogXCJ2NTRcIixcbiAgICAgIGNvZGVfZmxhZ19kb3duc3RlbTogXCJ2OWFcIixcbiAgICAgIHN0ZW1fdXBfZXh0ZW5zaW9uOiAwLFxuICAgICAgc3RlbV9kb3duX2V4dGVuc2lvbjogMCxcbiAgICAgIGdyYWNlbm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogLTE0LFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fZG93bl9leHRlbnNpb246IC0xNCxcbiAgICAgIHRhYm5vdGVfc3RlbV91cF9leHRlbnNpb246IDAsXG4gICAgICB0YWJub3RlX3N0ZW1fZG93bl9leHRlbnNpb246IDAsXG4gICAgICBkb3Rfc2hpZnRZOiAwLFxuICAgICAgbGluZV9hYm92ZTogMCxcbiAgICAgIGxpbmVfYmVsb3c6IDBcbiAgICB9LFxuICAgIHR5cGU6IHtcbiAgICAgIFwiblwiOiB7IC8vIEVpZ2h0aCBub3RlXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2YlwiXG4gICAgICB9LFxuICAgICAgXCJoXCI6IHsgLy8gRWlnaHRoIG5vdGUgaGFybW9uaWNcbiAgICAgICAgY29kZV9oZWFkOiBcInYyMlwiXG4gICAgICB9LFxuICAgICAgXCJtXCI6IHsgLy8gRWlnaHRoIG5vdGUgbXV0ZWRcbiAgICAgICAgY29kZV9oZWFkOiBcInYzZVwiXG4gICAgICB9LFxuICAgICAgXCJyXCI6IHsgLy8gRWlnaHRoIHJlc3RcbiAgICAgICAgY29kZV9oZWFkOiBcInZhNVwiLFxuICAgICAgICBzdGVtOiBmYWxzZSxcbiAgICAgICAgZmxhZzogZmFsc2UsXG4gICAgICAgIHJlc3Q6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBcIkIvNFwiLFxuICAgICAgICBkb3Rfc2hpZnRZOiAtMC41LFxuICAgICAgICBsaW5lX2Fib3ZlOiAxLjAsXG4gICAgICAgIGxpbmVfYmVsb3c6IDEuMFxuICAgICAgfSxcbiAgICAgIFwic1wiOiB7IC8vIEVpZ2h0IHNsYXNoXG4gICAgICAgIC8vIERyYXduIHdpdGggY2FudmFzIHByaW1pdGl2ZXNcbiAgICAgICAgaGVhZF93aWR0aDogMTUsXG4gICAgICAgIHBvc2l0aW9uOiBcIkIvNFwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcIjE2XCI6IHtcbiAgICBjb21tb246IHtcbiAgICAgIGJlYW1fY291bnQ6IDIsXG4gICAgICBoZWFkX3dpZHRoOiAxMCxcbiAgICAgIHN0ZW06IHRydWUsXG4gICAgICBzdGVtX29mZnNldDogMCxcbiAgICAgIGZsYWc6IHRydWUsXG4gICAgICBjb2RlX2ZsYWdfdXBzdGVtOiBcInYzZlwiLFxuICAgICAgY29kZV9mbGFnX2Rvd25zdGVtOiBcInY4ZlwiLFxuICAgICAgc3RlbV91cF9leHRlbnNpb246IDQsXG4gICAgICBzdGVtX2Rvd25fZXh0ZW5zaW9uOiAwLFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fdXBfZXh0ZW5zaW9uOiAtMTQsXG4gICAgICBncmFjZW5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLTE0LFxuICAgICAgdGFibm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogMCxcbiAgICAgIHRhYm5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogMCxcbiAgICAgIGRvdF9zaGlmdFk6IDAsXG4gICAgICBsaW5lX2Fib3ZlOiAwLFxuICAgICAgbGluZV9iZWxvdzogMFxuICAgIH0sXG4gICAgdHlwZToge1xuICAgICAgXCJuXCI6IHsgLy8gU2l4dGVlbnRoIG5vdGVcbiAgICAgICAgY29kZV9oZWFkOiBcInZiXCJcbiAgICAgIH0sXG4gICAgICBcImhcIjogeyAvLyBTaXh0ZWVudGggbm90ZSBoYXJtb25pY1xuICAgICAgICBjb2RlX2hlYWQ6IFwidjIyXCJcbiAgICAgIH0sXG4gICAgICBcIm1cIjogeyAvLyBTaXh0ZWVudGggbm90ZSBtdXRlZFxuICAgICAgICBjb2RlX2hlYWQ6IFwidjNlXCJcbiAgICAgIH0sXG4gICAgICBcInJcIjogeyAvLyBTaXh0ZWVudGggcmVzdFxuICAgICAgICBjb2RlX2hlYWQ6IFwidjNjXCIsXG4gICAgICAgIGhlYWRfd2lkdGg6IDEzLFxuICAgICAgICBzdGVtOiBmYWxzZSxcbiAgICAgICAgZmxhZzogZmFsc2UsXG4gICAgICAgIHJlc3Q6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBcIkIvNFwiLFxuICAgICAgICBkb3Rfc2hpZnRZOiAtMC41LFxuICAgICAgICBsaW5lX2Fib3ZlOiAxLjAsXG4gICAgICAgIGxpbmVfYmVsb3c6IDIuMFxuICAgICAgfSxcbiAgICAgIFwic1wiOiB7IC8vIFNpeHRlZW50aCBzbGFzaFxuICAgICAgICAvLyBEcmF3biB3aXRoIGNhbnZhcyBwcmltaXRpdmVzXG4gICAgICAgIGhlYWRfd2lkdGg6IDE1LFxuICAgICAgICBwb3NpdGlvbjogXCJCLzRcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCIzMlwiOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICBiZWFtX2NvdW50OiAzLFxuICAgICAgaGVhZF93aWR0aDogMTAsXG4gICAgICBzdGVtOiB0cnVlLFxuICAgICAgc3RlbV9vZmZzZXQ6IDAsXG4gICAgICBmbGFnOiB0cnVlLFxuICAgICAgY29kZV9mbGFnX3Vwc3RlbTogXCJ2NDdcIixcbiAgICAgIGNvZGVfZmxhZ19kb3duc3RlbTogXCJ2MmFcIixcbiAgICAgIHN0ZW1fdXBfZXh0ZW5zaW9uOiAxMyxcbiAgICAgIHN0ZW1fZG93bl9leHRlbnNpb246IDksXG4gICAgICBncmFjZW5vdGVfc3RlbV91cF9leHRlbnNpb246IC0xMixcbiAgICAgIGdyYWNlbm90ZV9zdGVtX2Rvd25fZXh0ZW5zaW9uOiAtMTIsXG4gICAgICB0YWJub3RlX3N0ZW1fdXBfZXh0ZW5zaW9uOiA5LFxuICAgICAgdGFibm90ZV9zdGVtX2Rvd25fZXh0ZW5zaW9uOiA1LFxuICAgICAgZG90X3NoaWZ0WTogMCxcbiAgICAgIGxpbmVfYWJvdmU6IDAsXG4gICAgICBsaW5lX2JlbG93OiAwXG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICBcIm5cIjogeyAvLyBUaGlydHktc2Vjb25kIG5vdGVcbiAgICAgICAgY29kZV9oZWFkOiBcInZiXCJcbiAgICAgIH0sXG4gICAgICBcImhcIjogeyAvLyBUaGlydHktc2Vjb25kIGhhcm1vbmljXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2MjJcIlxuICAgICAgfSxcbiAgICAgIFwibVwiOiB7IC8vIFRoaXJ0eS1zZWNvbmQgbXV0ZWRcbiAgICAgICAgY29kZV9oZWFkOiBcInYzZVwiXG4gICAgICB9LFxuICAgICAgXCJyXCI6IHsgLy8gVGhpcnR5LXNlY29uZCByZXN0XG4gICAgICAgIGNvZGVfaGVhZDogXCJ2NTVcIixcbiAgICAgICAgaGVhZF93aWR0aDogMTYsXG4gICAgICAgIHN0ZW06IGZhbHNlLFxuICAgICAgICBmbGFnOiBmYWxzZSxcbiAgICAgICAgcmVzdDogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246IFwiQi80XCIsXG4gICAgICAgIGRvdF9zaGlmdFk6IC0xLjUsXG4gICAgICAgIGxpbmVfYWJvdmU6IDIuMCxcbiAgICAgICAgbGluZV9iZWxvdzogMi4wXG4gICAgICB9LFxuICAgICAgXCJzXCI6IHsgLy8gVGhpcnR5LXNlY29uZCBzbGFzaFxuICAgICAgICAvLyBEcmF3biB3aXRoIGNhbnZhcyBwcmltaXRpdmVzXG4gICAgICAgIGhlYWRfd2lkdGg6IDE1LFxuICAgICAgICBwb3NpdGlvbjogXCJCLzRcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCI2NFwiOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICBiZWFtX2NvdW50OiA0LFxuICAgICAgaGVhZF93aWR0aDogMTAsXG4gICAgICBzdGVtOiB0cnVlLFxuICAgICAgc3RlbV9vZmZzZXQ6IDAsXG4gICAgICBmbGFnOiB0cnVlLFxuICAgICAgY29kZV9mbGFnX3Vwc3RlbTogXCJ2YTlcIixcbiAgICAgIGNvZGVfZmxhZ19kb3duc3RlbTogXCJ2NThcIixcbiAgICAgIHN0ZW1fdXBfZXh0ZW5zaW9uOiAxNyxcbiAgICAgIHN0ZW1fZG93bl9leHRlbnNpb246IDEzLFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fdXBfZXh0ZW5zaW9uOiAtMTAsXG4gICAgICBncmFjZW5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLTEwLFxuICAgICAgdGFibm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogMTMsXG4gICAgICB0YWJub3RlX3N0ZW1fZG93bl9leHRlbnNpb246IDksXG4gICAgICBkb3Rfc2hpZnRZOiAwLFxuICAgICAgbGluZV9hYm92ZTogMCxcbiAgICAgIGxpbmVfYmVsb3c6IDBcbiAgICB9LFxuICAgIHR5cGU6IHtcbiAgICAgIFwiblwiOiB7IC8vIFNpeHR5LWZvdXJ0aCBub3RlXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2YlwiXG4gICAgICB9LFxuICAgICAgXCJoXCI6IHsgLy8gU2l4dHktZm91cnRoIGhhcm1vbmljXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2MjJcIlxuICAgICAgfSxcbiAgICAgIFwibVwiOiB7IC8vIFNpeHR5LWZvdXJ0aCBtdXRlZFxuICAgICAgICBjb2RlX2hlYWQ6IFwidjNlXCJcbiAgICAgIH0sXG4gICAgICBcInJcIjogeyAvLyBTaXh0eS1mb3VydGggcmVzdFxuICAgICAgICBjb2RlX2hlYWQ6IFwidjM4XCIsXG4gICAgICAgIGhlYWRfd2lkdGg6IDE4LFxuICAgICAgICBzdGVtOiBmYWxzZSxcbiAgICAgICAgZmxhZzogZmFsc2UsXG4gICAgICAgIHJlc3Q6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBcIkIvNFwiLFxuICAgICAgICBkb3Rfc2hpZnRZOiAtMS41LFxuICAgICAgICBsaW5lX2Fib3ZlOiAyLjAsXG4gICAgICAgIGxpbmVfYmVsb3c6IDMuMFxuICAgICAgfSxcbiAgICAgIFwic1wiOiB7IC8vIFNpeHR5LWZvdXJ0aCBzbGFzaFxuICAgICAgICAvLyBEcmF3biB3aXRoIGNhbnZhcyBwcmltaXRpdmVzXG4gICAgICAgIGhlYWRfd2lkdGg6IDE1LFxuICAgICAgICBwb3NpdGlvbjogXCJCLzRcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCIxMjhcIjoge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgYmVhbV9jb3VudDogNSxcbiAgICAgICAgICBoZWFkX3dpZHRoOiAxMCxcbiAgICAgICAgICBzdGVtOiB0cnVlLFxuICAgICAgICAgIHN0ZW1fb2Zmc2V0OjAsXG4gICAgICAgICAgZmxhZzogdHJ1ZSxcbiAgICAgICAgICBjb2RlX2ZsYWdfdXBzdGVtOiBcInY5YlwiLFxuICAgICAgICAgIGNvZGVfZmxhZ19kb3duc3RlbTogXCJ2MzBcIixcbiAgICAgICAgICBzdGVtX3VwX2V4dGVuc2lvbjogMjYsXG4gICAgICAgICAgc3RlbV9kb3duX2V4dGVuc2lvbjogMjIsXG4gICAgICAgICAgZ3JhY2Vub3RlX3N0ZW1fdXBfZXh0ZW5zaW9uOiAtOCxcbiAgICAgICAgICBncmFjZW5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLTgsXG4gICAgICAgICAgdGFibm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogMjIsXG4gICAgICAgICAgdGFibm90ZV9zdGVtX2Rvd25fZXh0ZW5zaW9uOiAxOCxcbiAgICAgICAgICBkb3Rfc2hpZnRZOiAwLFxuICAgICAgICAgIGxpbmVfYWJvdmU6IDAsXG4gICAgICAgICAgbGluZV9iZWxvdzogMFxuICAgICAgfSxcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgICBcIm5cIjogeyAgLy8gSHVuZHJlZC10d2VudHktZWlnaHQgbm90ZVxuICAgICAgICAgICAgICBjb2RlX2hlYWQ6IFwidmJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoXCI6IHsgLy8gSHVuZHJlZC10d2VudHktZWlnaHQgaGFybW9uaWNcbiAgICAgICAgICAgICAgY29kZV9oZWFkOiBcInYyMlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm1cIjogeyAvLyBIdW5kcmVkLXR3ZW50eS1laWdodCBtdXRlZFxuICAgICAgICAgICAgICBjb2RlX2hlYWQ6IFwidjNlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiclwiOiB7ICAvLyBIdW5kcmVkLXR3ZW50eS1laWdodCByZXN0XG4gICAgICAgICAgICAgIGNvZGVfaGVhZDogXCJ2YWFcIixcbiAgICAgICAgICAgICAgaGVhZF93aWR0aDogMjAsXG4gICAgICAgICAgICAgIHN0ZW06IGZhbHNlLFxuICAgICAgICAgICAgICBmbGFnOiBmYWxzZSxcbiAgICAgICAgICAgICAgcmVzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgcG9zaXRpb246IFwiQi80XCIsXG4gICAgICAgICAgICAgIGRvdF9zaGlmdFk6IDEuNSxcbiAgICAgICAgICAgICAgbGluZV9hYm92ZTogMy4wLFxuICAgICAgICAgICAgICBsaW5lX2JlbG93OiAzLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic1wiOiB7IC8vIEh1bmRyZWQtdHdlbnR5LWVpZ2h0IHJlc3RcbiAgICAgICAgICAgICAgLy8gRHJhd24gd2l0aCBjYW52YXMgcHJpbWl0aXZlc1xuICAgICAgICAgICAgICBoZWFkX3dpZHRoOiAxNSxcbiAgICAgICAgICAgICAgcG9zaXRpb246IFwiQi80XCJcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cbn07XG5cbi8vIFNvbWUgZGVmYXVsdHNcblZleC5GbG93LlRJTUU0XzQgPSB7XG4gIG51bV9iZWF0czogNCxcbiAgYmVhdF92YWx1ZTogNCxcbiAgcmVzb2x1dGlvbjogVmV4LkZsb3cuUkVTT0xVVElPTlxufTtcblxuVmV4LkZsb3cuRm9udCA9IHtcImdseXBoc1wiOntcInYwXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo1MTQuNSxcImhhXCI6NTI1LFwib1wiOlwibSAyMzYgNjQ4IGIgMjQ2IDY0OCAyMzggNjQ4IDI0MiA2NDggYiAyODggNjQ2IDI2MSA2NDggMjgzIDY0OCBiIDQ3MiA1MTMgMzY0IDYzNCA0MjggNTg3IGIgNTE0IDM0NyA1MDIgNDY0IDUxNCA0MTMgYiA0NjIgMTYzIDUxNCAyNzIgNDk5IDIxNyBiIDI1NyA0NCA0MDkgODMgMzMzIDQ0IGIgNTAgMTYzIDE4MSA0NCAxMDMgODMgYiAwIDM0NyAxNCAyMTcgMCAyNzIgYiA0MCA1MTMgMCA0MTMgMTIgNDY0IGIgMjM2IDY0OCA4NyA1OTEgMTU1IDYzOCBtIDI3NyA2MTQgYiAyNTMgNjE2IDI3MyA2MTYgMjYxIDYxNiBiIDI0MiA2MTYgMjQ3IDYxNiAyNDMgNjE2IGIgMTcwIDQ5OSAxOTMgNjA5IDE4MSA1ODkgYiAxNTkgMzQ4IDE2MyA0NDYgMTU5IDM5OCBiIDE2NiAyMjIgMTU5IDMwOCAxNjEgMjY2IGIgMjAxIDkxIDE3NCAxMzggMTgzIDEwNiBiIDI1NyA3NiAyMTUgODEgMjM1IDc2IGIgMzExIDkxIDI3NyA3NiAyOTkgODEgYiAzNDcgMjIyIDMzMCAxMDYgMzM4IDEzOCBiIDM1MyAzNDggMzUyIDI2NiAzNTMgMzA4IGIgMzQ0IDQ5OSAzNTMgMzk4IDM1MSA0NDYgYiAyNzcgNjE0IDMzMyA1ODcgMzIyIDYwNiBtIDI1NyAtMSBsIDI1OCAtMSBsIDI1NSAtMSBsIDI1NyAtMSBtIDI1NyA2NzMgbCAyNTggNjczIGwgMjU1IDY3MyBsIDI1NyA2NzMgXCJ9LFwidjFcIjp7XCJ4X21pblwiOi0xLjM1OTM3NSxcInhfbWF4XCI6MzQ0LjM1OTM3NSxcImhhXCI6MzUxLFwib1wiOlwibSAxMjYgNjM3IGwgMTI5IDYzOCBsIDE5OCA2MzggbCAyNjYgNjM4IGwgMjY5IDYzNSBiIDI3NCA2MzEgMjcyIDYzNCAyNzMgNjMyIGwgMjc3IDYyNyBsIDI3NyAzOTUgYiAyNzkgMTU2IDI3NyAyMzAgMjc3IDE2MSBiIDMyOSA4OCAyODEgMTIzIDI5NSAxMDYgYiAzNDQgNjkgMzQxIDgxIDM0NCA3OSBiIDMzNyA1NSAzNDQgNjIgMzQzIDU5IGwgMzMzIDU0IGwgMTk3IDU0IGwgNjEgNTQgbCA1OCA1NSBiIDUwIDY5IDUzIDU5IDUwIDYyIGIgNjUgODggNTAgNzkgNTMgODEgYiA4MCA5NyA3MiA5MSA3NCA5MyBiIDExNyAxNTYgMTAzIDExMyAxMTIgMTI5IGIgMTE3IDM0NSAxMTcgMTYxIDExNyAyMjIgbCAxMTcgNTI4IGwgMTAwIDUwMyBsIDM4IDQwNiBiIDE0IDM4MyAyNCAzODQgMjMgMzgzIGIgLTEgMzk4IDUgMzgzIC0xIDM5MCBiIDQgNDE1IC0xIDQwMyAxIDQwOSBiIDE2IDQzNyA1IDQxNiAxMCA0MjYgbCA3MiA1MzkgbCAxMDAgNTk2IGIgMTIxIDYzMiAxMTkgNjMxIDExOSA2MzEgYiAxMjYgNjM3IDEyMiA2MzQgMTI1IDYzNSBtIDE3MSAtMSBsIDE3MiAtMSBsIDE3MCAtMSBsIDE3MSAtMSBtIDE3MSA2NzMgbCAxNzIgNjczIGwgMTcwIDY3MyBsIDE3MSA2NzMgXCJ9LFwidjJcIjp7XCJ4X21pblwiOi0xLjM1OTM3NSxcInhfbWF4XCI6NDU4LjY4NzUsXCJoYVwiOjQ2OCxcIm9cIjpcIm0gMTk3IDY0OCBiIDIxNiA2NDggMjAxIDY0OCAyMDggNjQ4IGIgMjU4IDY0NiAyMzIgNjQ4IDI1MyA2NDggYiA0MTkgNTQ2IDMzMyA2MzcgMzkzIDU5OSBiIDQzMiA0ODkgNDI4IDUyOCA0MzIgNTA5IGIgMzU2IDM0MiA0MzIgNDQwIDQwNSAzODQgYiAyMzUgMjc4IDMyMiAzMTMgMjg4IDI5NSBiIDY5IDE3MCAxNjYgMjU2IDEwNyAyMTcgYiA2OSAxNjkgNjkgMTcwIDY5IDE2OSBiIDY5IDE2OSA2OSAxNjkgNjkgMTY5IGIgNzQgMTczIDY5IDE2OSA3MiAxNzAgYiAyMDkgMjIyIDExMiAyMDQgMTYzIDIyMiBiIDMxMCAxOTUgMjQ3IDIyMiAyNzQgMjE1IGIgMzcxIDE3OSAzMzIgMTg0IDM1MiAxNzkgYiAzOTYgMTgxIDM3OSAxNzkgMzg3IDE3OSBiIDQyOCAyMDIgNDA5IDE4NCA0MjMgMTk0IGIgNDQyIDIxMiA0MzEgMjA5IDQzNiAyMTIgYiA0NTggMTk3IDQ1MCAyMTIgNDU4IDIwNiBiIDQ0MSAxNDggNDU4IDE5MCA0NDkgMTY1IGIgMjk5IDQ0IDQwOSA4NCAzNTMgNDQgYiAyODggNDUgMjk1IDQ0IDI5MiA0NCBiIDI1MCA2MSAyNzQgNDUgMjY4IDQ5IGIgMTIyIDk5IDIxMiA4NiAxNjQgOTkgYiA3MyA5MSAxMDQgOTkgODggOTcgYiAyOCA2MyA1MyA4NCAzNCA3MiBiIDE0IDU0IDI1IDU2IDIwIDU0IGIgMSA2MiA5IDU0IDQgNTYgbCAtMSA2NSBsIC0xIDc5IGIgMCA5OSAtMSA5MSAwIDk1IGIgMiAxMTMgMSAxMDIgMiAxMDggYiAxNjQgMzA5IDIwIDE5NyA4MSAyNzIgYiAyODUgNDcwIDIzMiAzNDEgMjc3IDM5OCBiIDI4NyA0ODcgMjg3IDQ3NiAyODcgNDgxIGIgMTcxIDU5NSAyODcgNTUxIDIzOSA1OTUgYiAxNTUgNTk1IDE2NiA1OTUgMTYwIDU5NSBiIDE0MiA1OTIgMTQ1IDU5NCAxNDIgNTk0IGIgMTQ1IDU4OSAxNDIgNTkyIDE0MiA1OTEgYiAxNzkgNTI3IDE2OCA1NzYgMTc5IDU1MSBiIDEzMiA0NTUgMTc5IDQ5NiAxNjMgNDY3IGIgMTA0IDQ1MSAxMjIgNDUyIDExMiA0NTEgYiAyNyA1MzAgNjIgNDUxIDI3IDQ4NyBiIDI5IDU1NSAyNyA1MzggMjcgNTQ2IGIgMTk3IDY0OCA0NCA2MDEgMTE1IDYzOSBtIDIyOCAtMSBsIDIzMCAtMSBsIDIyNyAtMSBsIDIyOCAtMSBtIDIyOCA2NzMgbCAyMzAgNjczIGwgMjI3IDY3MyBsIDIyOCA2NzMgXCJ9LFwidjNcIjp7XCJ4X21pblwiOi0xLjM1OTM3NSxcInhfbWF4XCI6NDA5LjY4NzUsXCJoYVwiOjQxOCxcIm9cIjpcIm0gMTc0IDY0OCBiIDE5MSA2NDggMTc2IDY0OCAxODMgNjQ4IGIgMjI1IDY0OCAyMDQgNjQ4IDIyMCA2NDggYiA0MDIgNTIzIDMxNyA2MzggMzg5IDU4OCBiIDQwNCA1MDMgNDA0IDUxNyA0MDQgNTEwIGIgNDAyIDQ4NCA0MDQgNDk1IDQwNCA0ODggYiAyNjQgMzczIDM4OSA0MzcgMzM0IDM5NCBiIDI1NyAzNzAgMjU5IDM3MSAyNTcgMzcxIGIgMjU3IDM3MCAyNTcgMzcwIDI1NyAzNzAgYiAyNjQgMzY5IDI1OCAzNzAgMjYxIDM2OSBiIDQwOSAyMDIgMzU5IDMzNCA0MDkgMjY3IGIgMzE4IDcyIDQwOSAxNTIgMzgxIDEwNCBiIDIwMCA0MyAyODEgNTIgMjQwIDQzIGIgMjMgMTEzIDEzNCA0MyA2OSA2OCBiIDAgMTY5IDYgMTI5IDAgMTQ5IGIgNzcgMjQ5IDAgMjEwIDI5IDI0OSBsIDc3IDI0OSBiIDE1MiAxNzQgMTI1IDI0OSAxNTIgMjEyIGIgMTAzIDEwMiAxNTIgMTQ1IDEzNyAxMTYgYiAxMDMgMTAyIDEwMyAxMDIgMTAzIDEwMiBiIDE0NyA5NCAxMDMgMTAxIDEzMiA5NSBiIDE1MyA5NCAxNDkgOTQgMTUxIDk0IGIgMjY1IDIwNiAyMTkgOTQgMjY1IDE0MSBiIDI2NCAyMjYgMjY1IDIxMyAyNjUgMjE5IGIgMTQ3IDM1NSAyNTMgMjk5IDIwNCAzNTMgYiAxMjYgMzcxIDEzMyAzNTYgMTI2IDM2MiBiIDE0NyAzODggMTI2IDM4MyAxMzIgMzg4IGIgMjU0IDQ3NCAxOTYgMzkxIDIzOCA0MjQgYiAyNTkgNTAyIDI1OCA0ODQgMjU5IDQ5NCBiIDE4MiA1OTIgMjU5IDU0NCAyMjggNTgyIGIgMTU2IDU5NSAxNzUgNTk1IDE2NiA1OTUgYiAxMTUgNTkyIDE0MiA1OTUgMTI5IDU5NCBsIDExMSA1OTEgbCAxMTUgNTg4IGIgMTUyIDUyNCAxNDEgNTc0IDE1MiA1NDkgYiA5MiA0NDkgMTUyIDQ5MSAxMzAgNDU4IGIgNzYgNDQ4IDg3IDQ0OCA4MSA0NDggYiAtMSA1MzAgMzIgNDQ4IC0xIDQ4OCBiIDIwIDU4MSAtMSA1NDggNSA1NjYgYiAxNzQgNjQ4IDU1IDYxOSAxMDggNjQxIG0gMjA0IC0xIGwgMjA1IC0xIGwgMjAyIC0xIGwgMjA0IC0xIG0gMjA0IDY3MyBsIDIwNSA2NzMgbCAyMDIgNjczIGwgMjA0IDY3MyBcIn0sXCJ2NFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NDY4LjIxODc1LFwiaGFcIjo0NzgsXCJvXCI6XCJtIDE3NCA2MzcgYiAyMzIgNjM4IDE3NSA2MzggMTg5IDYzOCBiIDI3NyA2MzggMjQ1IDYzOCAyNTkgNjM4IGwgMzc4IDYzOCBsIDM4MSA2MzUgYiAzODkgNjIzIDM4NiA2MzIgMzg5IDYyNyBiIDM4MiA2MDkgMzg5IDYxNyAzODYgNjEzIGIgMzY2IDU4OSAzODEgNjA2IDM3MiA1OTggbCAzMTMgNTI4IGwgMjQ1IDQ1MSBsIDIwOSA0MTAgbCAxNTUgMzQ4IGwgODQgMjY3IGIgNTkgMjQwIDcyIDI1MiA1OSAyNDAgYiA1OSAyNDAgNTkgMjQwIDU5IDI0MCBiIDE1MSAyMzggNTkgMjM4IDY4IDIzOCBsIDI0MiAyMzggbCAyNDIgMzAzIGIgMjQzIDM3MSAyNDIgMzY5IDI0MiAzNzAgYiAyODkgNDI2IDI0NSAzNzQgMjU0IDM4NSBsIDMwMyA0NDEgbCAzMTcgNDU2IGwgMzM4IDQ4MyBsIDM2MCA1MDYgbCAzNzEgNTIwIGIgMzg2IDUyNyAzNzUgNTI2IDM4MSA1MjcgYiA0MDAgNTE5IDM5MiA1MjcgMzk3IDUyNCBiIDQwMSA0NDAgNDAxIDUxNiA0MDEgNTE0IGIgNDAxIDM3NyA0MDEgNDIzIDQwMSA0MDIgbCA0MDEgMjM4IGwgNDI2IDIzOCBiIDQ1MyAyMzcgNDQ5IDIzOCA0NTAgMjM4IGIgNDY1IDIxNyA0NjEgMjM0IDQ2NSAyMjYgYiA0NjAgMjAyIDQ2NSAyMTIgNDY0IDIwNiBiIDQyNiAxOTcgNDU0IDE5NyA0NTMgMTk3IGwgNDAxIDE5NyBsIDQwMSAxODAgYiA0NTEgODggNDAyIDEyOSA0MTIgMTA5IGIgNDY4IDY5IDQ2NSA4MSA0NjggNzkgYiA0NjEgNTUgNDY4IDYyIDQ2NiA1OSBsIDQ1OCA1NCBsIDMyMSA1NCBsIDE4NSA1NCBsIDE4MiA1NSBiIDE3NSA2OSAxNzYgNTkgMTc1IDYyIGIgMTkxIDg4IDE3NSA3OSAxNzYgODEgYiAyNDAgMTgwIDIzMCAxMDkgMjQwIDEyOSBsIDI0MCAxOTcgbCAxMjUgMTk3IGIgNzMgMTk1IDEwNCAxOTUgODcgMTk1IGIgOCAxOTcgMTAgMTk1IDkgMTk3IGIgMCAyMTIgMiAxOTkgMCAyMDUgYiAwIDIxMiAwIDIxMiAwIDIxMiBiIDIwIDI0MiAwIDIxOSAwIDIxOSBiIDE2MyA2MTAgMTA0IDM0NCAxNjMgNDkyIGIgMTc0IDYzNyAxNjMgNjI4IDE2NiA2MzQgbSAyMzQgLTEgbCAyMzUgLTEgbCAyMzIgLTEgbCAyMzQgLTEgbSAyMzQgNjczIGwgMjM1IDY3MyBsIDIzMiA2NzMgbCAyMzQgNjczIFwifSxcInY1XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0MDkuNjg3NSxcImhhXCI6NDE4LFwib1wiOlwibSA0NyA2MzcgYiA1MyA2MzggNDkgNjM4IDUwIDYzOCBiIDY5IDYzNCA1NSA2MzggNjEgNjM3IGIgMjEwIDYxMCAxMTQgNjE5IDE2MSA2MTAgYiAzNjMgNjM0IDI1OSA2MTAgMzExIDYxOSBiIDM4MiA2MzggMzcyIDYzNyAzNzggNjM4IGIgMzkyIDYzNCAzODYgNjM4IDM4OSA2MzcgYiAzOTcgNjIzIDM5NiA2MzAgMzk3IDYyNyBiIDM5MyA2MTAgMzk3IDYyMCAzOTYgNjE2IGIgMjk4IDUwNSAzNjggNTUyIDMzOCA1MjAgYiAyMTIgNDk0IDI3NyA0OTggMjQ2IDQ5NCBiIDY1IDUxNyAxNjMgNDk0IDEwNiA1MDIgYiA2MSA1MTcgNjIgNTE3IDYxIDUxNyBiIDYxIDUxNyA2MSA1MTcgNjEgNTE3IGIgNTEgNDA4IDYxIDUxNyA1MSA0MTIgYiA1MSA0MDggNTEgNDA4IDUxIDQwOCBiIDUxIDQwOCA1MSA0MDggNTEgNDA4IGIgNjEgNDEyIDUzIDQwOCA1NSA0MDkgYiAxMjUgNDM0IDgwIDQyMSAxMDMgNDMwIGIgMTg1IDQ0MSAxNDUgNDQwIDE2NiA0NDEgYiA0MDkgMjQ0IDMxMCA0NDEgNDA5IDM1MyBiIDQwMSAxOTEgNDA5IDIyNyA0MDYgMjA5IGIgMTk3IDQzIDM3NSAxMDUgMjg3IDQzIGIgMTU5IDQ3IDE4MyA0MyAxNzEgNDQgYiAyMyAxMjMgMTEyIDU2IDYxIDg2IGIgMCAxODAgNiAxNDAgMCAxNTkgYiA3NiAyNjAgMCAyMjAgMzEgMjYwIGIgOTIgMjU5IDgxIDI2MCA4NyAyNTkgYiAxNTIgMTgzIDEzMiAyNTEgMTUyIDIxNiBiIDEwMCAxMTIgMTUyIDE1MiAxMzQgMTIyIGIgOTUgMTExIDk4IDExMiA5NSAxMTEgYiA5NSAxMTEgOTUgMTExIDk1IDExMSBiIDEyOSA5OCA5NSAxMDkgMTE5IDEwMSBiIDE0OCA5NyAxMzYgOTcgMTQxIDk3IGIgMjY0IDIzNSAyMDYgOTcgMjYxIDE1OCBiIDI2NSAyNDggMjY1IDI0MCAyNjUgMjQ0IGIgMjEwIDM5OCAyNjUgMzEyIDI0MyAzNzMgYiAxNzkgNDA4IDIwMSA0MDYgMTk0IDQwOCBiIDE3NCA0MDggMTc4IDQwOCAxNzYgNDA4IGIgNTMgMzY5IDEzMCA0MDggODggMzk0IGIgMzQgMzU5IDM5IDM1OSAzOCAzNTkgYiAxNyAzNzQgMjQgMzU5IDE3IDM2NSBiIDM5IDYyOCAxNyAzODQgMzggNjI1IGIgNDcgNjM3IDQwIDYzMSA0MyA2MzUgbSAyMDQgLTEgbCAyMDUgLTEgbCAyMDIgLTEgbCAyMDQgLTEgbSAyMDQgNjczIGwgMjA1IDY3MyBsIDIwMiA2NzMgbCAyMDQgNjczIFwifSxcInY2XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0NzUuMDMxMjUsXCJoYVwiOjQ4NSxcIm9cIjpcIm0gMjU1IDY0OCBiIDI3NCA2NDggMjU5IDY0OCAyNjYgNjQ4IGIgMzE0IDY0NiAyODggNjQ4IDMwNyA2NDggYiA0NTAgNTU1IDM3NCA2MzcgNDM4IDU5NCBiIDQ1NCA1MzAgNDUzIDU0NiA0NTQgNTM4IGIgMzc1IDQ1MSA0NTQgNDg1IDQxNiA0NTEgYiAzMjggNDY3IDM1OSA0NTEgMzQzIDQ1NSBiIDMwMCA1MjYgMzEwIDQ4MyAzMDAgNTAzIGIgMzUyIDU5OCAzMDAgNTU3IDMxOSA1ODkgYiAzNTYgNTk5IDM1NSA1OTggMzU2IDU5OSBiIDM1MiA2MDIgMzU2IDU5OSAzNTUgNjAxIGIgMjg4IDYxNiAzMzAgNjEyIDMwOCA2MTYgYiAyMTAgNTg0IDI1NyA2MTYgMjMwIDYwNSBiIDE2NCA0MzMgMTg5IDU1OSAxNzQgNTA4IGIgMTYwIDM3NCAxNjMgNDE1IDE2MCAzODEgYiAxNjAgMzc0IDE2MCAzNzQgMTYwIDM3NCBiIDE2MCAzNzQgMTYwIDM3NCAxNjAgMzc0IGIgMTY4IDM3NyAxNjAgMzc0IDE2NCAzNzYgYiAyNTggMzk1IDIwMCAzOTAgMjI4IDM5NSBiIDM2NiAzNjcgMjk0IDM5NSAzMjggMzg3IGIgNDc1IDIyMyA0MzYgMzMzIDQ3NSAyODMgYiA0NzIgMTk3IDQ3NSAyMTUgNDczIDIwNiBiIDM0OSA2NSA0NjIgMTQxIDQxOSA5NSBiIDI1OSA0MyAzMTcgNTEgMjg4IDQzIGIgMTY3IDY5IDIzMCA0MyAyMDAgNTIgYiA0IDI5MCA4MCAxMTMgMjAgMTk1IGIgMCAzNDkgMSAzMDkgMCAzMjggYiAyMCA0NjcgMCAzOTEgNiA0MzMgYiAyNTUgNjQ4IDU4IDU2MyAxNTUgNjM3IG0gMjY5IDM2MyBiIDI1NyAzNjMgMjY1IDM2MyAyNjEgMzYzIGIgMjEwIDM0NSAyMzYgMzYzIDIyMCAzNTYgYiAxODYgMjI2IDE5NiAzMjQgMTg2IDI3MiBiIDE4NyAxOTggMTg2IDIxNiAxODYgMjA2IGIgMjEzIDk1IDE5MSAxNTEgMjAyIDExMiBiIDI1NyA3NiAyMjEgODMgMjM4IDc2IGIgMjcwIDc3IDI2MSA3NiAyNjYgNzYgYiAzMjEgMTU2IDI5OSA4MSAzMTAgOTkgYiAzMjkgMjI5IDMyNiAxODMgMzI5IDIwNiBiIDMyMSAzMDEgMzI5IDI1MiAzMjYgMjc0IGIgMjY5IDM2MyAzMTEgMzQyIDI5OCAzNTkgbSAyMzYgLTEgbCAyMzggLTEgbCAyMzUgLTEgbCAyMzYgLTEgbSAyMzYgNjczIGwgMjM4IDY3MyBsIDIzNSA2NzMgbCAyMzYgNjczIFwifSxcInY3XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0NDIuMzU5Mzc1LFwiaGFcIjo0NTEsXCJvXCI6XCJtIDE0NyA2NDggYiAxNjYgNjQ5IDE1MyA2NDkgMTYwIDY0OSBiIDMxMyA1OTggMjE3IDY0OSAyNzMgNjMwIGIgMzQwIDU4NyAzMjMgNTg4IDMyOCA1ODcgbCAzNDEgNTg3IGIgNDEyIDYyOCAzNjcgNTg3IDM5MCA2MDEgYiA0MjcgNjM4IDQxNiA2MzUgNDIxIDYzOCBiIDQzOSA2MzIgNDMxIDYzOCA0MzUgNjM3IGIgNDQyIDYyMyA0NDEgNjMwIDQ0MiA2MjggYiA0MzAgNTY5IDQ0MiA2MTYgNDM5IDYwMyBiIDM1MiAzNjkgNDA4IDQ5MiAzNzcgNDEwIGIgMzAwIDI1OSAzMjUgMzI0IDMxMyAyOTggYiAyNzMgODQgMjgzIDIwNSAyNzMgMTQwIGIgMjY1IDU1IDI3MyA2NSAyNzIgNTkgbCAyNjEgNTQgbCAxODEgNTQgbCA5OSA1NCBsIDk2IDU1IGIgOTEgNjEgOTUgNTYgOTIgNTkgbCA4OSA2MyBsIDg5IDc3IGIgMTQ3IDI2MyA4OSAxMzMgMTExIDIwMiBiIDI2MSA0MDEgMTc2IDMxMyAyMTIgMzU1IGIgMzc4IDU0MSAzMTUgNDQ5IDM0OSA0ODkgbCAzODIgNTQ4IGwgMzc1IDU0NCBiIDI0MCA0OTUgMzMzIDUxMiAyODUgNDk1IGIgMTI5IDUzNSAxOTggNDk1IDE2MCA1MDkgYiA4NCA1NjAgMTA4IDU1MiA5NSA1NjAgYiA3NiA1NTkgODEgNTYwIDc4IDU2MCBiIDMxIDQ4NyA1OSA1NTUgNDMgNTMwIGIgMTQgNDcwIDI3IDQ3MyAyNCA0NzAgYiAxIDQ3NyA4IDQ3MCA0IDQ3MSBsIDAgNDgwIGwgMCA1NTMgbCAwIDYyNyBsIDEgNjMwIGIgMTYgNjM4IDQgNjM1IDkgNjM4IGIgMjMgNjM1IDE3IDYzOCAyMCA2MzcgYiA0OSA2MjYgMzYgNjI2IDM5IDYyNiBiIDk2IDYzOCA1OSA2MjYgODAgNjMwIGIgMTA0IDYzOSA5OSA2MzggMTAyIDYzOSBiIDExNyA2NDQgMTA3IDY0MSAxMTIgNjQyIGIgMTQ3IDY0OCAxMjUgNjQ1IDEzNyA2NDggbSAyMjAgLTEgbCAyMjEgLTEgbCAyMTkgLTEgbCAyMjAgLTEgbSAyMjAgNjczIGwgMjIxIDY3MyBsIDIxOSA2NzMgbCAyMjAgNjczIFwifSxcInY4XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0ODguNjQwNjI1LFwiaGFcIjo0OTksXCJvXCI6XCJtIDIxNyA2NDggYiAyNDUgNjQ5IDIyNSA2NDggMjM1IDY0OSBiIDQ1MyA1MTYgMzQzIDY0OSA0MzAgNTk1IGIgNDU4IDQ3OCA0NTUgNTAzIDQ1OCA0OTEgYiA0MTIgMzcwIDQ1OCA0NDAgNDQxIDM5OCBiIDQxMSAzNjkgNDEyIDM2OSA0MTEgMzY5IGIgNDE1IDM2NSA0MTEgMzY3IDQxMiAzNjcgYiA0ODggMjMxIDQ2MiAzMzEgNDg4IDI4MSBiIDQ3MiAxNjUgNDg4IDIwOCA0ODMgMTg2IGIgMjQzIDQzIDQzNCA4NiAzMzggNDMgYiA2MyAxMDQgMTc4IDQzIDExMiA2MiBiIDAgMjMzIDIwIDE0MCAwIDE4NiBiIDczIDM2NSAwIDI4MyAyNCAzMzEgbCA3NyAzNjkgbCA3MiAzNzQgYiAyOSA0NzYgNDIgNDA2IDI5IDQ0MSBiIDIxNyA2NDggMjkgNTU3IDEwMyA2MzUgbSAyNTggNjA1IGIgMjQyIDYwNiAyNTMgNjA1IDI0NyA2MDYgYiAxNTcgNTUyIDE5OCA2MDYgMTU3IDU4MCBiIDE2MCA1NDEgMTU3IDU0OCAxNTkgNTQ0IGIgMzE5IDQxMyAxNzYgNTAzIDI0MiA0NTIgbCAzMzcgNDAzIGwgMzM4IDQwNiBiIDM1OSA0NzYgMzUyIDQyOCAzNTkgNDUyIGIgMjU4IDYwNSAzNTkgNTM3IDMxOCA1OTUgbSAxMzggMzI2IGIgMTMwIDMzMCAxMzQgMzI4IDEzMCAzMzAgYiAxMzAgMzMwIDEzMCAzMzAgMTMwIDMzMCBiIDEwNyAzMDUgMTI3IDMzMCAxMTIgMzEzIGIgODQgMjMxIDkxIDI4MSA4NCAyNTYgYiAyNDMgODYgODQgMTU2IDE1MSA4NiBiIDI0OSA4NyAyNDUgODYgMjQ2IDg3IGIgMzQ3IDE1NiAzMDMgODggMzQ3IDEyMCBiIDM0NCAxNzIgMzQ3IDE2MiAzNDUgMTY3IGIgMTU2IDMxOSAzMjUgMjI3IDI1NyAyODEgYiAxMzggMzI2IDE1MSAzMjIgMTQ0IDMyNCBtIDI0MyAtMSBsIDI0NSAtMSBsIDI0MiAtMSBsIDI0MyAtMSBtIDI0MyA2NzMgbCAyNDUgNjczIGwgMjQyIDY3MyBsIDI0MyA2NzMgXCJ9LFwidjlcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ3NS4wMzEyNSxcImhhXCI6NDg1LFwib1wiOlwibSAxOTEgNjQ2IGIgMjEyIDY0OSAxOTggNjQ4IDIwNSA2NDkgYiAyNTUgNjQ0IDIyNyA2NDkgMjQzIDY0NiBiIDQ1OCA0NDggMzQ4IDYxNiA0MjggNTM5IGIgNDc1IDM0MiA0NjkgNDE1IDQ3NSAzNzggYiA0NjAgMjQ0IDQ3NSAzMDggNDY5IDI3NCBiIDE5MyA0NCA0MjEgMTI0IDMwMyA0NCBiIDkxIDY5IDE1NyA0NCAxMjIgNTEgYiAxOSAxNjEgNDMgOTcgMTkgMTI2IGIgMjEgMTgxIDE5IDE2NyAyMCAxNzQgYiA5OCAyNDEgMzIgMjIwIDY1IDI0MSBiIDE3MCAxODYgMTI5IDI0MSAxNjAgMjIzIGIgMTcyIDE2NiAxNzEgMTc5IDE3MiAxNzMgYiAxMjEgOTQgMTcyIDEzNCAxNTIgMTAyIGIgMTE3IDkzIDExOCA5NCAxMTcgOTMgYiAxMjEgOTAgMTE3IDkzIDExOCA5MSBiIDE4NSA3NiAxNDIgODAgMTY0IDc2IGIgMjcwIDExOSAyMjAgNzYgMjUxIDkxIGIgMzA4IDI1OSAyODcgMTQ1IDMwMCAxOTQgYiAzMTMgMzE3IDMxMCAyNzcgMzEzIDMxMCBiIDMxMyAzMTcgMzEzIDMxNyAzMTMgMzE3IGIgMzEzIDMxNyAzMTMgMzE3IDMxMyAzMTcgYiAzMDQgMzE1IDMxMyAzMTcgMzA4IDMxNiBiIDIxNiAyOTUgMjczIDMwMiAyNDUgMjk1IGIgMTQ1IDMwOCAxOTMgMjk1IDE3MCAyOTkgYiAxOSAzOTggODggMzI3IDQyIDM2MCBiIDAgNDY5IDUgNDIwIDAgNDQ0IGIgMjQgNTUxIDAgNDk2IDggNTI2IGIgMTkxIDY0NiA1NCA1OTYgMTI1IDYzNyBtIDIyNyA2MTQgYiAyMTUgNjE2IDIyNCA2MTYgMjIwIDYxNiBiIDIwMiA2MTQgMjEwIDYxNiAyMDYgNjE2IGIgMTUyIDUzNSAxNzQgNjEwIDE2MyA1OTIgYiAxNDQgNDYzIDE0NyA1MDkgMTQ0IDQ4NSBiIDE1MiAzOTEgMTQ0IDQ0MCAxNDcgNDE3IGIgMjE2IDMyOCAxNjMgMzQ0IDE3OSAzMjggYiAyODAgMzkxIDI1MyAzMjggMjY5IDM0NCBiIDI4OCA0NjMgMjg1IDQxNyAyODggNDQwIGIgMjgwIDUzNSAyODggNDg1IDI4NSA1MDkgYiAyMjcgNjE0IDI2OSA1OTQgMjU4IDYxMCBtIDIzNiAtMSBsIDIzOCAtMSBsIDIzNSAtMSBsIDIzNiAtMSBtIDIzNiA2NzMgbCAyMzggNjczIGwgMjM1IDY3MyBsIDIzNiA2NzMgXCJ9LFwidmFcIjp7XCJ4X21pblwiOi0xNDkuNzE4NzUsXCJ4X21heFwiOjE0OC4zNTkzNzUsXCJoYVwiOjE1MSxcIm9cIjpcIm0gLTggLTEgYiAtMSAwIC01IC0xIC00IDAgYiAxNiAtMTEgNSAwIDEzIC00IGIgODMgLTE4NiAxNyAtMTIgNDcgLTkwIGwgMTQ4IC0zNTggbCAxNDggLTM2MyBiIDEyNyAtMzg1IDE0OCAtMzc2IDEzOCAtMzg1IGIgMTEyIC0zNzggMTIyIC0zODUgMTE4IC0zODMgYiA1NCAtMjI2IDExMCAtMzc0IDExNCAtMzg1IGIgMCAtODEgMjQgLTE0NyAwIC04MSBiIC01NSAtMjI2IC0xIC04MSAtMjUgLTE0NyBiIC0xMTQgLTM3OCAtMTE1IC0zODUgLTExMSAtMzc0IGIgLTEyOSAtMzg1IC0xMTkgLTM4MyAtMTIzIC0zODUgYiAtMTQ5IC0zNjMgLTE0MCAtMzg1IC0xNDkgLTM3NiBsIC0xNDkgLTM1OCBsIC04NCAtMTg2IGIgLTE5IC0xMSAtNDkgLTkwIC0xOSAtMTIgYiAtOCAtMSAtMTcgLTggLTEyIC00IFwifSxcInZiXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0MjguNzUsXCJoYVwiOjQzOCxcIm9cIjpcIm0gMjYyIDE4NiBiIDI3MyAxODYgMjY2IDE4NiAyNzIgMTg2IGIgMjc0IDE4NiAyNzMgMTg2IDI3NCAxODYgYiAyODUgMTg2IDI3NCAxODYgMjgwIDE4NiBiIDQyOCA0OCAzNzUgMTgxIDQyOCAxMjIgYiAzODYgLTY4IDQyOCAxMiA0MTYgLTI5IGIgMTU1IC0xODcgMzI5IC0xNDUgMjM2IC0xODcgYiAxMiAtMTExIDkyIC0xODcgMzggLTE2MiBiIDAgLTUxIDQgLTkxIDAgLTcyIGIgMjYyIDE4NiAwIDU4IDEyMiAxNzkgXCJ9LFwidmNcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ0Ny44MTI1LFwiaGFcIjo0NTcsXCJvXCI6XCJtIDAgODYgbCAwIDE3MyBsIDIyMyAxNzMgbCA0NDcgMTczIGwgNDQ3IDg2IGwgNDQ3IDAgbCAyMjMgMCBsIDAgMCBsIDAgODYgXCJ9LFwidmZcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjM3MC4yMTg3NSxcImhhXCI6Mzc4LFwib1wiOlwibSAwIDAgbCAwIDI3NyBsIDYxIDI3NyBsIDEyMiAyNzcgbCAxMjIgMCBsIDEyMiAtMjc4IGwgNjEgLTI3OCBsIDAgLTI3OCBsIDAgMCBtIDI0NiAtMSBsIDI0NiAyNzcgbCAzMDggMjc3IGwgMzcwIDI3NyBsIDM3MCAtMSBsIDM3MCAtMjc4IGwgMzA4IC0yNzggbCAyNDYgLTI3OCBsIDI0NiAtMSBcIn0sXCJ2MTBcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjU1OS40MjE4NzUsXCJoYVwiOjU3MSxcIm9cIjpcIm0gNSAxMjcgYiAxNCAxMjcgNiAxMjcgOSAxMjcgYiA1MSAxMjYgMjUgMTI3IDQzIDEyNyBiIDE3NSA5OCA5MyAxMjIgMTM4IDExMiBsIDE4NiA5NCBiIDI3OSA1MSAyMTAgODYgMjU1IDY1IGIgMjg1IDQ3IDI4MCA1MSAyODMgNDggYiAzMTkgMjcgMjkxIDQ0IDMxMSAzMSBsIDMyNiAyMiBiIDM1OSAwIDMzMiAxOSAzNTIgNCBsIDM2NyAtNiBiIDM3MSAtOSAzNjggLTYgMzcwIC04IGwgMzc5IC0xNSBiIDM4NyAtMjIgMzgzIC0xOCAzODYgLTIwIGwgMzk4IC0zMCBsIDQxMSAtNDAgbCA0MTcgLTQ3IGwgNDI3IC01NSBsIDQzNCAtNjEgYiA0NDEgLTY2IDQzNiAtNjIgNDM5IC02NSBsIDQ0NiAtNzIgbCA0NTMgLTc3IGwgNDYyIC04NyBiIDU1OCAtMTg4IDQ5MCAtMTEzIDU0OSAtMTc2IGIgNTU5IC0xOTUgNTU5IC0xOTEgNTU5IC0xOTQgYiA1NDggLTIwNSA1NTkgLTIwMSA1NTUgLTIwNSBiIDU0MSAtMjA0IDU0NyAtMjA1IDU0NCAtMjA1IGIgNTM0IC0xOTggNTM5IC0yMDEgNTM2IC0xOTkgbCA1MjUgLTE5MSBiIDQ4MSAtMTYyIDUxOCAtMTg3IDQ5MCAtMTY3IGIgNDcyIC0xNTUgNDc3IC0xNTkgNDcyIC0xNTYgYiA0NjggLTE1MiA0NzAgLTE1NSA0NjkgLTE1NCBiIDQ2MSAtMTQ5IDQ2NiAtMTUyIDQ2NCAtMTUxIGIgNDI4IC0xMzAgNDU0IC0xNDUgNDQxIC0xMzcgYiAzNzEgLTk5IDQxMyAtMTIyIDM3MiAtOTkgYiAzNjMgLTk1IDM3MSAtOTkgMzY3IC05OCBiIDM1MyAtOTEgMzU3IC05NCAzNTMgLTkxIGIgMzQ4IC05MCAzNTMgLTkxIDM1MiAtOTEgYiAzMzIgLTgxIDM0MyAtODcgMzQxIC04NiBiIDI3IC0xMiAyMzAgLTM3IDEyNyAtMTMgYiAwIC01IDQgLTExIDIgLTExIGIgMCA1OCAwIC0yIDAgMjcgYiAwIDEyMiAwIDg4IDAgMTIwIGIgNSAxMjcgMSAxMjQgNCAxMjYgXCJ9LFwidjExXCI6e1wieF9taW5cIjotMTU1LjE3MTg3NSxcInhfbWF4XCI6MTUzLjgxMjUsXCJoYVwiOjE1NyxcIm9cIjpcIm0gLTEzNyAzNTMgYiAtMTMwIDM1MyAtMTM2IDM1MyAtMTMzIDM1MyBiIC0xMTIgMzQ5IC0xMjUgMzUzIC0xMTkgMzUyIGIgLTEwMCAzNDIgLTExMCAzNDcgLTEwNCAzNDQgYiAwIDMxNyAtNjkgMzI2IC0zNSAzMTcgYiAxMTEgMzQ5IDM4IDMxNyA3NiAzMjggYiAxMjkgMzUzIDExNyAzNTIgMTIzIDM1MyBiIDE1MyAzMjcgMTQyIDM1MyAxNTMgMzQ0IGIgMTQ0IDMwMiAxNTMgMzIwIDE1MyAzMTcgYiAyNyA2IDkzIDIyNiA1MCAxMTMgYiAyMSAtMTMgMjQgLTExIDI0IC0xMSBiIDAgLTI2IDE3IC0yMiA4IC0yNiBiIC0yNCAtMTIgLTkgLTI2IC0xOSAtMjIgYiAtMjggNSAtMjQgLTkgLTI3IC0yIGIgLTE0NSAzMDIgLTUzIDExNyAtOTUgMjI0IGIgLTE1NSAzMjcgLTE1NSAzMTcgLTE1NSAzMjAgYiAtMTM3IDM1MyAtMTU1IDM0MCAtMTQ4IDM0OSBcIn0sXCJ2MThcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjMyMy45Mzc1LFwiaGFcIjozMzEsXCJvXCI6XCJtIDIxNyA1MzUgYiAyMjUgNTM3IDIyMCA1MzcgMjIxIDUzNyBiIDI0NSA1MjQgMjM1IDUzNyAyNDIgNTMzIGwgMjQ2IDUyMSBsIDI0NyAzOTAgbCAyNDcgMjU4IGwgMjczIDI2NSBiIDMwNiAyNzAgMjg4IDI2OSAyOTkgMjcwIGIgMzIyIDI1OSAzMTUgMjcwIDMxOSAyNjcgYiAzMjMgMjA4IDMyMyAyNTYgMzIzIDIzMyBiIDMyMiAxNTggMzIzIDE4NCAzMjMgMTU5IGIgMjg4IDE0MCAzMTggMTQ4IDMxNSAxNDcgYiAyNDcgMTMwIDI1NCAxMzEgMjQ3IDEzMCBiIDI0NyA2NSAyNDcgMTMwIDI0NyAxMDQgYiAyNDcgMjAgMjQ3IDUxIDI0NyAzNiBsIDI0NyAtODggbCAyNzMgLTgxIGIgMzA2IC03NiAyODkgLTc3IDI5OSAtNzYgYiAzMTggLTgxIDMxMSAtNzYgMzE1IC03NyBiIDMyMyAtMTIzIDMyMyAtODcgMzIzIC04NiBsIDMyMyAtMTM4IGwgMzIzIC0xNTQgYiAzMTggLTE5NSAzMjMgLTE5MSAzMjMgLTE5MCBiIDI2OSAtMjEwIDMxNCAtMTk5IDMxNSAtMTk5IGIgMjQ5IC0yMTYgMjU5IC0yMTMgMjUwIC0yMTYgbCAyNDcgLTIxNiBsIDI0NyAtMzQ5IGwgMjQ2IC00ODMgbCAyNDUgLTQ4NyBiIDIyNSAtNDk5IDI0MiAtNDk1IDIzNCAtNDk5IGIgMjA2IC00ODcgMjE5IC00OTkgMjEwIC00OTUgbCAyMDUgLTQ4MyBsIDIwNSAtMzU1IGwgMjA1IC0yMjcgbCAyMDQgLTIyNyBsIDE4MSAtMjMzIGwgMTM4IC0yNDQgYiAxMTcgLTI0OSAxMjcgLTI0NyAxMTcgLTI0OSBiIDExNSAtMzg1IDExNSAtMjQ5IDExNSAtMjU2IGwgMTE1IC01MjMgbCAxMTQgLTUyNiBiIDk1IC01MzggMTEwIC01MzQgMTAyIC01MzggYiA3NCAtNTI2IDg3IC01MzggNzggLTUzNCBsIDczIC01MjMgbCA3MyAtMzkxIGIgNzIgLTI2MCA3MyAtMjY5IDczIC0yNjAgYiA3MiAtMjYwIDcyIC0yNjAgNzIgLTI2MCBiIDE5IC0yNzMgNjEgLTI2MyAyMyAtMjczIGIgMCAtMjYwIDEwIC0yNzMgNCAtMjY3IGIgMCAtMjA5IDAgLTI1NiAwIC0yNTYgbCAwIC0xNjIgbCAxIC0xNTggYiA2MSAtMTM0IDUgLTE0OCA1IC0xNDggbCA3MyAtMTMxIGwgNzMgLTIyIGIgNzIgODYgNzMgNzkgNzMgODYgYiA3MiA4NiA3MiA4NiA3MiA4NiBiIDE5IDc0IDYxIDgzIDIzIDc0IGIgMCA4NiAxMCA3NCA0IDc5IGIgMCAxMzcgMCA5MCAwIDkwIGwgMCAxODQgbCAxIDE4OCBiIDYxIDIxMiA1IDE5OCA1IDE5OCBsIDczIDIxNSBsIDczIDM0OCBsIDczIDQ4MSBsIDc0IDQ4NSBiIDk1IDQ5OCA3OCA0OTIgODcgNDk4IGIgMTAzIDQ5NSA5OCA0OTggMTAwIDQ5NiBiIDExNCA0ODUgMTA3IDQ5NCAxMTEgNDg5IGwgMTE1IDQ4MSBsIDExNSAzNTMgbCAxMTUgMjI2IGwgMTIxIDIyNiBiIDE1OSAyMzUgMTIzIDIyNyAxNDEgMjMxIGwgMTk4IDI0NyBsIDIwNSAyNDggbCAyMDUgMzg0IGwgMjA1IDUyMSBsIDIwNiA1MjQgYiAyMTcgNTM1IDIwOSA1MjggMjEyIDUzMyBtIDIwNSA5IGIgMjA1IDExOSAyMDUgNzAgMjA1IDExOSBsIDIwNSAxMTkgYiAxODIgMTEzIDIwNCAxMTkgMTk0IDExNiBsIDEzOCAxMDIgYiAxMTcgOTcgMTI3IDk5IDExNyA5NyBiIDExNSAtMTIgMTE1IDk3IDExNSA5MSBsIDExNSAtMTIyIGwgMTIxIC0xMjAgYiAxNTkgLTExMSAxMjMgLTExOSAxNDEgLTExNSBsIDE5OCAtMTAxIGwgMjA1IC05OCBsIDIwNSA5IFwifSxcInYxYlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NTU5LjQyMTg3NSxcImhhXCI6NTcxLFwib1wiOlwibSA1NDQgMjA0IGIgNTQ4IDIwNCA1NDUgMjA0IDU0NyAyMDQgYiA1NTkgMTk0IDU1NSAyMDQgNTU5IDE5OSBiIDU1OSAxOTAgNTU5IDE5MiA1NTkgMTkxIGIgNTMwIDE1NiA1NTkgMTg4IDU1NiAxODQgYiA0NjIgODYgNTEwIDEzNCA0ODEgMTA0IGIgNDUzIDc2IDQ1OCA4MSA0NTQgNzcgbCA0NDYgNzAgbCA0NDEgNjUgYiA0MzQgNTkgNDM5IDYzIDQzNiA2MSBsIDQyNyA1NCBiIDQwOSAzNyA0MjYgNTEgNDE2IDQ0IGIgMzkyIDIzIDM5OCAyOSAzOTQgMjYgYiAzODcgMTkgMzg5IDIyIDM4NyAyMCBiIDM3OSAxMyAzODYgMTkgMzgzIDE2IGwgMzcxIDggbCAzNjcgNSBsIDM1OSAtMSBsIDMzNyAtMTYgYiAyODUgLTQ4IDMxOSAtMjkgMjk4IC00MSBsIDI3OSAtNTIgYiAxODYgLTk1IDI1NSAtNjYgMjEwIC04NyBsIDE3NSAtOTkgYiAyMyAtMTI5IDEyNyAtMTE3IDY4IC0xMjkgYiAxNyAtMTI5IDIwIC0xMjkgMTkgLTEyOSBiIDEgLTEyMyAyIC0xMjkgMiAtMTI5IGIgMCAtNDkgMCAtMTIyIDAgLTgzIGIgMCA0IDAgLTIyIDAgMSBiIDI3IDExIDIgOSA0IDkgYiAxODUgMzEgNzggMTIgMTQ1IDIwIGIgMTk4IDM0IDE4NiAzMSAxOTMgMzMgYiAzMTQgNzMgMjM0IDQ0IDI3NyA1OCBiIDM0OSA4OCAzMjggNzkgMzQwIDg0IGIgMzUzIDkwIDM1MiA5MCAzNTMgOTAgYiAzNjMgOTQgMzUzIDkwIDM1NyA5MyBiIDM3MSA5OCAzNjcgOTcgMzcxIDk4IGIgNDI4IDEyOSAzNzIgOTggNDEzIDEyMCBiIDQ2MSAxNDggNDQxIDEzNiA0NTQgMTQ0IGIgNDY4IDE1MSA0NjQgMTQ5IDQ2NiAxNTEgYiA0NzIgMTU0IDQ2OSAxNTIgNDcwIDE1NCBiIDQ4MSAxNjEgNDczIDE1NSA0NzcgMTU4IGIgNTI1IDE5MCA0OTAgMTY2IDUxOCAxODYgbCA1MzQgMTk3IGIgNTQwIDIwMSA1MzYgMTk4IDUzOSAxOTkgYiA1NDQgMjA0IDU0MSAyMDIgNTQ0IDIwNCBcIn0sXCJ2MWRcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjYxOS4zMTI1LFwiaGFcIjo2MzIsXCJvXCI6XCJtIDI3NCAxODQgYiAzMDcgMTg2IDI4NSAxODYgMjk2IDE4NiBiIDYxNiAyMiA0NjUgMTg2IDU5NyAxMTYgYiA2MTkgLTEgNjE3IDEzIDYxOSA1IGIgMzA4IC0xODcgNjE5IC0xMDQgNDgzIC0xODcgYiAwIC0xIDEzMyAtMTg3IDAgLTEwMiBiIDUgMzYgMCAxMSAxIDIzIGIgMjc0IDE4NCAyOSAxMTUgMTQxIDE3NiBtIDI4OSAxNjEgYiAyNzIgMTYyIDI4NCAxNjIgMjc3IDE2MiBiIDE3MSA0MSAyMDkgMTYyIDE3MSAxMDggYiAyMDUgLTczIDE3MSA1IDE4MiAtMzQgYiAzNDUgLTE2MyAyNDMgLTEzMyAyOTggLTE2MyBiIDQzNiAtOTggMzg1IC0xNjMgNDIwIC0xNDIgYiA0NDYgLTQzIDQ0MyAtODAgNDQ2IC02MiBiIDI4OSAxNjEgNDQ2IDQ3IDM3NyAxNDcgXCJ9LFwidjFlXCI6e1wieF9taW5cIjotNDAyLjg5MDYyNSxcInhfbWF4XCI6NDAxLjUzMTI1LFwiaGFcIjo0MTAsXCJvXCI6XCJtIC0yMTkgMTczIGIgLTIxMyAxNzQgLTIxNyAxNzQgLTIxNSAxNzQgYiAtMjAyIDE3MyAtMjA5IDE3NCAtMjA1IDE3MyBiIC0xMTQgODYgLTIwMCAxNzIgLTE3OSAxNTEgYiAtMjggMCAtNjYgMzcgLTI4IDAgYiA0MCA4NCAtMjggMCAyIDM3IGIgMTE3IDE3NCAxMTEgMTczIDExMCAxNzIgYiAxMjIgMTc0IDExOCAxNzQgMTE5IDE3NCBiIDEzMiAxNzMgMTI1IDE3NCAxMjkgMTczIGIgMjk1IDExIDEzNCAxNzIgMTcxIDEzNCBsIDMwNyAtMSBsIDMzNiAzNCBiIDM3NCA3NiAzNjYgNzIgMzY4IDc0IGIgMzgxIDc3IDM3NSA3NyAzNzggNzcgYiA0MDEgNTYgMzkyIDc3IDQwMSA2OCBiIDQwMCA0OCA0MDEgNTQgNDAxIDUxIGIgMjIzIC0xNzIgMzk3IDQxIDIzMCAtMTY2IGIgMjEwIC0xNzYgMjIwIC0xNzQgMjE1IC0xNzYgYiAyMDEgLTE3NCAyMDYgLTE3NiAyMDQgLTE3NiBiIDExMiAtODcgMTk4IC0xNzMgMTc4IC0xNTIgYiAyNyAwIDY1IC0zOCAyNyAwIGIgLTQyIC04NiAyNyAwIC00IC0zOCBiIC0xMTggLTE3NCAtMTEyIC0xNzQgLTExMSAtMTczIGIgLTEyMyAtMTc2IC0xMTkgLTE3NiAtMTIxIC0xNzYgYiAtMTMzIC0xNzQgLTEyNiAtMTc2IC0xMzAgLTE3NCBiIC0yOTYgLTEyIC0xMzYgLTE3MyAtMTcyIC0xMzcgbCAtMzA4IDAgbCAtMzM3IC0zNCBiIC0zNzUgLTc3IC0zNjcgLTczIC0zNzAgLTc2IGIgLTM4MiAtNzkgLTM3NyAtNzkgLTM3OSAtNzkgYiAtNDAyIC01OCAtMzkzIC03OSAtNDAyIC02OSBiIC00MDEgLTQ5IC00MDIgLTU1IC00MDIgLTUyIGIgLTIyNCAxNzIgLTM5OCAtNDMgLTIyOCAxNjcgYiAtMjE5IDE3MyAtMjIzIDE3MiAtMjIwIDE3MyBcIn0sXCJ2MWZcIjp7XCJ4X21pblwiOi0zNDAuMjgxMjUsXCJ4X21heFwiOjMzOC45MjE4NzUsXCJoYVwiOjM0NixcIm9cIjpcIm0gLTMyIDUyMCBiIC0yOSA1MjEgLTMxIDUyMCAtMzEgNTIxIGIgLTIzIDUxOSAtMjcgNTIxIC0yNCA1MjAgYiAtMjAgNTEzIC0yMSA1MTcgLTIwIDUxNiBiIC0yMSA1MDYgLTIwIDUxMiAtMjAgNTA5IGIgLTMxIDQ3NCAtMjMgNTAyIC0yNyA0ODggbCAtNTMgNDAyIGwgLTY2IDM1MiBsIC02OCAzNDkgbCAtNTcgMzQ5IGIgLTMyIDM1MSAtNTEgMzQ5IC00MCAzNTEgYiAxMjMgMzcwIDE5IDM1MiA3NCAzNTkgYiAxMzcgMzcxIDEyNyAzNzAgMTMzIDM3MSBiIDE3MCAzNTYgMTUyIDM3MSAxNjQgMzY2IGIgMTcxIDM1NSAxNzAgMzU1IDE3MCAzNTUgYiAyMTYgMzY2IDE3NCAzNTUgMTgzIDM1OCBiIDI4MCAzNzggMjY4IDM3NyAyNjYgMzc3IGIgMjg3IDM3OCAyODMgMzc4IDI4NCAzNzggYiAzMzIgMzQ5IDMwNyAzNzggMzIyIDM2OSBiIDMzOCAzMTkgMzM2IDM0MSAzMzggMzMwIGIgMzMyIDMwMSAzMzggMzEwIDMzNiAzMDIgYiAyNDIgMjgwIDMyOSAyOTkgMjQ2IDI4MCBiIDI0MiAyODAgMjQyIDI4MCAyNDIgMjgwIGIgMjM1IDI4OCAyMzYgMjgwIDIzNSAyODMgYiAyMzUgMjkyIDIzNSAyOTAgMjM1IDI5MSBiIDIzNiAzMDIgMjM2IDI5NyAyMzYgMjk5IGIgMjIwIDMzNyAyMzYgMzE2IDIzMCAzMzAgbCAyMTYgMzQwIGwgMjEwIDMzNSBiIDE1OSAyNzYgMTg5IDMyMiAxNzIgMzAxIGIgMTE4IDE0OSAxNTIgMjY1IDE1NiAyNzQgYiA4MSAzNCA4NCAzNiA4NSAzNiBiIC04IDEzIDc4IDMzIC00IDEzIGIgLTggMTMgLTggMTMgLTggMTMgYiAtMTQgMjAgLTEyIDE1IC0xNCAxNSBiIC04IDQ0IC0xNCAyNCAtMTIgMzEgYiAtMiA2NiAtNSA1NSAtMiA2NSBiIC0yIDY2IC0yIDY2IC0yIDY2IGwgLTIgNjYgYiAtNDMgNDEgLTIgNjYgLTIxIDU1IGIgLTExNCA0IC05OCA4IC05OCA4IGIgLTE0NCAwIC0xMjMgMCAtMTM0IDAgYiAtMjQyIDk5IC0xOTcgMCAtMjQyIDQzIGIgLTI0MiAxMDkgLTI0MiAxMDIgLTI0MiAxMDUgYiAtMjEyIDIxOSAtMjQwIDEyMiAtMjQyIDExNiBiIC0xODUgMzEyIC0xOTcgMjcwIC0xODUgMzEyIGwgLTE4NSAzMTIgYiAtMTg5IDMxMiAtMTg1IDMxMiAtMTg2IDMxMiBiIC0yNTkgMzEyIC0yMDAgMzEyIC0yMjcgMzEyIGIgLTMyMSAzMTAgLTI5MSAzMTIgLTMxMCAzMTAgYiAtMzM0IDMxMiAtMzMwIDMxMCAtMzM0IDMxMiBiIC0zNDAgMzE5IC0zMzggMzEzIC0zNDAgMzE2IGIgLTMzNiAzMjYgLTM0MCAzMjIgLTMzOCAzMjQgYiAtMjkxIDMzNyAtMzM0IDMyNiAtMzE0IDMzMSBsIC0yNDcgMzQ3IGwgLTIxMCAzNDggYiAtMTcyIDM0OCAtMTkwIDM0OCAtMTcyIDM0OCBiIC0xNjggMzYzIC0xNzIgMzQ4IC0xNzEgMzU1IGIgLTE0NSA0NDIgLTE1MSA0MjQgLTE0NSA0NDEgYiAtMTMzIDQ1MiAtMTQ0IDQ0NCAtMTQwIDQ0NiBsIC03NyA0ODkgYiAtMzIgNTIwIC01MyA1MDYgLTMyIDUyMCBtIDU3IDMzNCBiIDUzIDMzNSA1NSAzMzUgNTQgMzM1IGIgNDQgMzM0IDUwIDMzNSA0OSAzMzUgYiAtNzAgMzE2IDggMzI2IC0yOCAzMjAgYiAtNzggMzA5IC03OCAzMTYgLTc4IDMxNiBiIC0xMDggMjAyIC04MCAzMDUgLTg4IDI3NCBiIC0xNDEgODEgLTEzNiAxMTIgLTE0MSA5MyBiIC0xNDAgNzQgLTE0MSA3OSAtMTQxIDc3IGIgLTExNyA0OSAtMTM3IDU5IC0xMjcgNDkgYiAtMTA3IDUyIC0xMTQgNDkgLTExMCA1MSBiIDE2IDEyNyAtMTA2IDU0IDE0IDEyNiBiIDQyIDIxNyAxNiAxMjcgNDIgMjE1IGIgNDkgMjQxIDQyIDIyMiA0NCAyMjkgYiA3MyAzMjAgNTMgMjUxIDczIDMxNyBiIDU3IDMzNCA3MyAzMjcgNjUgMzMzIFwifSxcInYyMFwiOntcInhfbWluXCI6LTU3MS42NzE4NzUsXCJ4X21heFwiOjU3MC4zMTI1LFwiaGFcIjo1ODIsXCJvXCI6XCJtIC01NTkgMzUxIGIgLTU1MSAzNTIgLTU1NiAzNTIgLTU1MyAzNTIgYiAtNTMwIDMzOCAtNTQzIDM1MiAtNTMzIDM0OCBiIC01MjkgMTY5IC01MzAgMzM3IC01MjkgMjkxIGwgLTUyOSAxIGwgLTUwNyAyNyBsIC00NDEgMTEyIGIgLTM4MiAxNzQgLTM5NCAxNjkgLTM5MCAxNzQgYiAtMzc4IDE3NCAtMzgxIDE3NCAtMzc5IDE3NCBiIC0yODEgODYgLTM3MCAxNzQgLTM3NSAxNzkgYiAtMTk2IDAgLTIzNCAzNyAtMTk2IDAgYiAtMTI2IDg0IC0xOTYgMCAtMTY0IDM3IGIgLTUwIDE3NCAtNTUgMTczIC01NyAxNzIgYiAtNDQgMTc0IC00OSAxNzQgLTQ3IDE3NCBiIC0zNSAxNzMgLTQyIDE3NCAtMzggMTczIGIgNTMgODYgLTMyIDE3MiAtMTIgMTUxIGIgMTM4IDAgMTAwIDM3IDEzOCAwIGIgMjA4IDg0IDE0MCAwIDE3MCAzNyBiIDI4NCAxNzQgMjc5IDE3MyAyNzkgMTcyIGIgMjg5IDE3NCAyODUgMTc0IDI4OCAxNzQgYiAzMDAgMTczIDI5NCAxNzQgMjk4IDE3MyBiIDQ2MiAxMSAzMDMgMTcyIDM0MCAxMzQgbCA0NzUgLTEgbCA1MDMgMzQgYiA1NDEgNzYgNTM0IDcyIDUzNiA3NCBiIDU0OCA3NyA1NDQgNzcgNTQ1IDc3IGIgNTcwIDU2IDU2MCA3NyA1NzAgNjggYiA1NjcgNDggNTcwIDU0IDU2OCA1MSBiIDM5MiAtMTcyIDU2NCA0MSAzOTcgLTE2NiBiIDM3OCAtMTc2IDM4NyAtMTc0IDM4MiAtMTc2IGIgMzY4IC0xNzQgMzc1IC0xNzYgMzcxIC0xNzYgYiAyODAgLTg3IDM2NyAtMTczIDM0NyAtMTUyIGIgMTk0IDAgMjM0IC0zOCAxOTQgMCBiIDEyNiAtODYgMTk0IDAgMTYzIC0zOCBiIDQ5IC0xNzQgNTQgLTE3NCA1NSAtMTczIGIgNDQgLTE3NiA0NyAtMTc2IDQ2IC0xNzYgYiAzNCAtMTc0IDQwIC0xNzYgMzYgLTE3NCBiIC01NCAtODcgMzEgLTE3MyAxMCAtMTUyIGIgLTE0MCAwIC0xMDIgLTM4IC0xNDAgMCBiIC0yMDkgLTg2IC0xNDAgMCAtMTcxIC0zOCBiIC0yODUgLTE3NCAtMjgwIC0xNzQgLTI3OSAtMTczIGIgLTI5MSAtMTc2IC0yODcgLTE3NiAtMjg4IC0xNzYgYiAtMzAwIC0xNzQgLTI5NCAtMTc2IC0yOTggLTE3NCBiIC00NjQgLTExIC0zMDMgLTE3MyAtMzc0IC0xMDIgbCAtNDc2IDAgbCAtNTA2IC0zNyBiIC01MzkgLTc2IC01MjggLTY1IC01MzcgLTc0IGIgLTU1MSAtODAgLTU0MyAtNzkgLTU0NyAtODAgYiAtNTcwIC02OCAtNTU4IC04MCAtNTY2IC03NiBsIC01NzEgLTY1IGwgLTU3MSAxMzYgYiAtNTcwIDM0MCAtNTcxIDMzMSAtNTcxIDMzNyBiIC01NTkgMzUxIC01NjggMzQ0IC01NjQgMzQ4IFwifSxcInYyMlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NDMyLjgyODEyNSxcImhhXCI6NDQyLFwib1wiOlwibSAyMDkgMTg2IGIgMjEzIDE4NyAyMTAgMTg3IDIxMiAxODcgYiAyMTYgMTg3IDIxNSAxODcgMjE2IDE4NyBiIDIyNCAxNzQgMjE2IDE4NiAyMjAgMTgwIGIgNDIwIC0xIDI2OSAxMDUgMzM4IDQzIGIgNDMyIC0xMiA0MzEgLTggNDMyIC05IGIgNDIxIC0yMyA0MzIgLTE1IDQzMiAtMTYgYiAyMjggLTE4MCAzNDUgLTcwIDI2NCAtMTM3IGIgMjE5IC0xODggMjIxIC0xODggMjIxIC0xODggbCAyMTkgLTE4OCBiIDIwOCAtMTc3IDIxNSAtMTg4IDIxNSAtMTg4IGIgMTAgMSAxNjMgLTEwNiA5MyAtNDQgYiAwIDExIDAgNiAwIDggYiAxMCAyMiAwIDEzIDAgMTUgYiAyMDIgMTc5IDg3IDY5IDE2NyAxMzYgYiAyMDkgMTg2IDIwNiAxODMgMjA5IDE4NiBcIn0sXCJ2MjNcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjEzMy4zOTA2MjUsXCJoYVwiOjEzNixcIm9cIjpcIm0gNTQgNjYgYiA2NSA2OCA1OCA2OCA2MSA2OCBiIDEyMiAzNyA4OCA2OCAxMTAgNTYgYiAxMzMgLTEgMTMwIDI2IDEzMyAxMiBiIDEwNCAtNTggMTMzIC0yMyAxMjMgLTQ0IGIgNjYgLTY5IDkyIC02NSA3OCAtNjkgYiAxMCAtMzggNDQgLTY5IDIzIC01OCBiIDAgLTEgMiAtMjcgMCAtMTMgYiA1NCA2NiAwIDMwIDIwIDYxIFwifSxcInYyNVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MzE4LjUsXCJoYVwiOjMyNSxcIm9cIjpcIm0gMjAgMzc2IGIgMTY3IDM3NyAyMyAzNzcgOTYgMzc3IGIgMjk2IDM3NiAyMzEgMzc3IDI5NCAzNzcgYiAzMTggMzQ3IDMxMSAzNzEgMzE4IDM1OSBiIDI5NiAzMTYgMzE4IDMzMyAzMTEgMzIwIGIgMTU5IDMxNSAyOTQgMzE1IDIyNyAzMTUgYiAyMSAzMTYgOTEgMzE1IDI0IDMxNSBiIDAgMzQ1IDYgMzIwIDAgMzMzIGIgMjAgMzc2IDAgMzU5IDYgMzcxIFwifSxcInYyNlwiOntcInhfbWluXCI6LTIxLjc4MTI1LFwieF9tYXhcIjo0ODMuMTg3NSxcImhhXCI6NDkzLFwib1wiOlwibSAtOCA2MzEgYiAtMSA2MzIgLTYgNjMyIC00IDYzMiBiIDE5IDYyMCA4IDYzMiAxNiA2MjggYiAyMCAzODMgMjAgNjE2IDIwIDYxNiBsIDIwIDE0OCBsIDIxIDE1MSBiIDE0MCAxOTkgNTkgMTgzIDEwMiAxOTkgYiAyMDYgMTc5IDE2NCAxOTkgMTg3IDE5MiBsIDIxMCAxNzYgbCAyMTAgMzk2IGwgMjEwIDYxNyBsIDIxMiA2MjEgYiAyMzEgNjMyIDIxNiA2MjggMjIzIDYzMiBiIDI1MCA2MjAgMjM5IDYzMiAyNDcgNjI4IGIgMjUxIDM4MyAyNTEgNjE2IDI1MSA2MTYgbCAyNTEgMTQ4IGwgMjU0IDE1MSBiIDM3MCAxOTkgMjkxIDE4MyAzMzIgMTk5IGIgNDE1IDE5MSAzODUgMTk5IDQwMCAxOTcgYiA0ODMgODQgNDU4IDE3NiA0ODMgMTM0IGIgNDYxIDAgNDgzIDU4IDQ3NiAyOSBiIDMzMiAtMTQyIDQzOSAtNDAgNDExIC03MiBsIDI1NSAtMjE1IGIgMjMxIC0yMjkgMjQwIC0yMjkgMjM5IC0yMjkgYiAyMTYgLTIyMyAyMjQgLTIyOSAyMjAgLTIyNyBiIDIxMCAtMTU4IDIxMCAtMjE3IDIxMCAtMjIzIGIgMjEwIC0xMjAgMjEwIC0xNDggMjEwIC0xMzYgbCAyMTAgLTI5IGwgMjA1IC0zNCBiIDEwMCAtMTQyIDE4MiAtNjUgMTU5IC04OCBsIDIzIC0yMTUgYiAtMSAtMjI5IDkgLTIyOSA2IC0yMjkgYiAtMjAgLTIxNiAtOSAtMjI5IC0xNyAtMjI0IGwgLTIxIC0yMTIgbCAtMjEgMjAxIGwgLTIxIDYxNiBsIC0yMCA2MjAgYiAtOCA2MzEgLTE3IDYyNCAtMTMgNjMwIG0gMTEwIDEzMSBiIDk2IDEzMyAxMDYgMTMzIDEwMCAxMzMgYiA4OSAxMzMgOTMgMTMzIDkxIDEzMyBiIDI0IDg3IDYzIDEyOSA0MCAxMTMgbCAyMCA4MCBsIDIwIC0zNyBsIDIwIC0xNTYgbCAyMyAtMTUyIGIgMTQ0IDgxIDk2IC03MiAxNDQgMjAgbCAxNDQgODMgYiAxMTAgMTMxIDE0NCAxMTMgMTM0IDEyNiBtIDM0MSAxMzEgYiAzMjggMTMzIDMzNyAxMzMgMzMyIDEzMyBiIDMyMiAxMzMgMzI2IDEzMyAzMjMgMTMzIGIgMjU3IDg3IDI5NiAxMjkgMjczIDExMyBsIDI1MSA4MCBsIDI1MSAtMzcgbCAyNTEgLTE1NiBsIDI1NSAtMTUyIGIgMzc1IDgxIDMyOCAtNzIgMzc1IDIwIGwgMzc1IDgzIGIgMzQxIDEzMSAzNzUgMTEzIDM2NyAxMjYgXCJ9LFwidjI3XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0MzIuODI4MTI1LFwiaGFcIjo0NDIsXCJvXCI6XCJtIDIwOCAxODQgYiAyMTMgMTg3IDIwOSAxODYgMjEyIDE4NyBiIDIyNCAxNzYgMjE3IDE4NyAyMjEgMTgzIGIgMjQ1IDE0NyAyMjUgMTcyIDIzNSAxNTkgYiA0MTkgLTEgMjg4IDkwIDM0NyAzOCBiIDQzMSAtOCA0MjQgLTQgNDMxIC04IGIgNDMyIC0xMiA0MzIgLTkgNDMyIC0xMSBiIDQzMCAtMTggNDMyIC0xMyA0MzIgLTE2IGIgMzY0IC02MSA0MjQgLTIwIDM4MyAtNDcgYiAyMjUgLTE4MyAzMDcgLTEwMiAyNTAgLTE1MiBiIDIyMyAtMTg3IDIyNCAtMTg0IDIyMyAtMTg3IGIgMjIwIC0xODggMjIxIC0xODggMjIwIC0xODggYiAyMDggLTE3NiAyMTYgLTE4OCAyMTAgLTE4NCBiIDE4NyAtMTQ4IDIwNSAtMTczIDE5NyAtMTU5IGIgMTIgMCAxNDQgLTkwIDg0IC0zOCBiIDAgMTEgNCA1IDAgOCBiIDE2IDI0IDAgMTMgNCAxOCBiIDE4MyAxNTggODMgNjkgMTQxIDExNSBiIDIwOCAxODQgMTk0IDE2OSAxOTggMTczIG0gMTgzIDEwNSBiIDE3NiAxMTMgMTgxIDEwOSAxNzYgMTEzIGIgMTcyIDEwOSAxNzYgMTEzIDE3NSAxMTIgYiA5MiA0NSAxNDkgOTAgMTE3IDYyIGwgODggNDEgbCAxMDIgMzEgYiAyNDcgLTEwNSAxNjAgLTYgMjEwIC01NSBsIDI1NCAtMTE1IGwgMjU3IC0xMTIgbCAyNjkgLTEwMiBiIDM0MCAtNDUgMjg3IC04NyAzMTkgLTYxIGwgMzQ0IC00MyBsIDMzMCAtMzMgYiAxODMgMTA1IDI3MiA2IDIyMSA1NCBcIn0sXCJ2MjhcIjp7XCJ4X21pblwiOi03My41LFwieF9tYXhcIjo3Mi4xNDA2MjUsXCJoYVwiOjc0LFwib1wiOlwibSAtNzIgMjUyIGwgLTczIDI1NCBsIDAgMjU0IGwgNzIgMjU0IGwgNzAgMjUyIGIgMCAtMSA3MCAyNDggMCAtMSBiIC03MiAyNTIgLTEgLTEgLTcyIDI0OCBcIn0sXCJ2MjlcIjp7XCJ4X21pblwiOi01OTAuNzE4NzUsXCJ4X21heFwiOjU4OS4zNTkzNzUsXCJoYVwiOjYwMSxcIm9cIjpcIm0gMTc1IDI3MyBiIDE4MiAyNzQgMTc4IDI3MyAxODEgMjc0IGIgMjAyIDI2MiAxOTAgMjc0IDE5OCAyNjkgYiAyMDQgMTU4IDIwNCAyNTkgMjA0IDI1OSBsIDIwNCA1NiBsIDI1MCAxMTIgYiAzMDMgMTc0IDI5NiAxNzIgMjk4IDE3MiBiIDMwOCAxNzQgMzA0IDE3NCAzMDcgMTc0IGIgMzE4IDE3MyAzMTMgMTc0IDMxNyAxNzMgYiA0ODEgMTEgMzIyIDE3MiAzNTcgMTM0IGwgNDk0IC0xIGwgNTIyIDM0IGIgNTYwIDc2IDU1MyA3MiA1NTUgNzQgYiA1NjcgNzcgNTYzIDc3IDU2NCA3NyBiIDU4OSA1NiA1NzkgNzcgNTg5IDY4IGIgNTg2IDQ4IDU4OSA1NCA1ODggNTEgYiA0MTEgLTE3MiA1ODMgNDEgNDE2IC0xNjYgYiAzOTcgLTE3NiA0MDYgLTE3NCA0MDEgLTE3NiBiIDM4NyAtMTc0IDM5MyAtMTc2IDM5MCAtMTc2IGIgMjk5IC04NyAzODYgLTE3MyAzNjYgLTE1MiBiIDIxMyAwIDI1MyAtMzggMjEzIDAgYiAyMDggLTYgMjEzIDAgMjEwIC0yIGwgMjA0IC0xMiBsIDIwNCAtMTQ3IGIgMjA0IC0yMTAgMjA0IC0xNzMgMjA0IC0xOTQgYiAxOTggLTI5MiAyMDQgLTI5NyAyMDQgLTI4NyBiIDE4MyAtMjk5IDE5NCAtMjk3IDE4OSAtMjk5IGIgMTY0IC0yODcgMTc1IC0yOTkgMTY3IC0yOTUgYiAxNjMgLTE3NCAxNjMgLTI4NCAxNjMgLTI4NCBsIDE2MSAtNjMgbCAxMTkgLTExNyBiIDY1IC0xNzYgNzYgLTE3MCA3MyAtMTc2IGIgNjEgLTE3NiA2MyAtMTc2IDYyIC0xNzYgYiAtMzUgLTg3IDUxIC0xNzQgNTcgLTE4MCBiIC0xMjEgMCAtODMgLTM4IC0xMjEgMCBiIC0xOTAgLTg2IC0xMjIgMCAtMTUyIC0zOCBiIC0yNjYgLTE3NCAtMjYxIC0xNzQgLTI1OSAtMTczIGIgLTI3MiAtMTc2IC0yNjggLTE3NiAtMjcwIC0xNzYgYiAtMjgxIC0xNzQgLTI3NiAtMTc2IC0yODAgLTE3NCBiIC0zNzEgLTg2IC0yODQgLTE3MyAtMzA0IC0xNTIgYiAtNDU3IDAgLTQxNyAtMzggLTQ1NyAwIGwgLTQ1NyAwIGIgLTQ3NyAtMjYgLTQ1NyAwIC00NzAgLTE2IGIgLTU0OCAtMjI3IC01MjQgLTg4IC01NDggLTE2MSBiIC01MzYgLTMwMyAtNTQ4IC0yNTQgLTU0NCAtMjgwIGIgLTUzMyAtMzE3IC01MzQgLTMwOSAtNTMzIC0zMTMgYiAtNTUzIC0zMzggLTUzMyAtMzMwIC01NDEgLTMzOCBiIC01NzcgLTMxNSAtNTY2IC0zMzggLTU3MSAtMzMzIGIgLTU5MCAtMjI3IC01ODYgLTI4NyAtNTkwIC0yNTggYiAtNTE4IC05IC01OTAgLTE1NCAtNTY0IC03NyBiIC00NjUgNTYgLTUwOSAyIC01MDQgOCBsIC00MDIgMTM0IGIgLTM2MyAxNzQgLTM3NCAxNzAgLTM3MSAxNzQgYiAtMzU5IDE3NCAtMzYyIDE3NCAtMzYwIDE3NCBiIC0yNjIgODYgLTM1MSAxNzQgLTM1NiAxNzkgYiAtMTc2IDAgLTIxNiAzNyAtMTc2IDAgYiAtMTA3IDg0IC0xNzYgMCAtMTQ1IDM3IGIgLTMxIDE3NCAtMzYgMTczIC0zOCAxNzIgYiAtMjUgMTc0IC0yOSAxNzQgLTI4IDE3NCBiIC0xNiAxNzMgLTIzIDE3NCAtMTkgMTczIGIgMTQ3IDExIC0xMyAxNzIgMzUgMTIzIGwgMTU3IC0xIGwgMTYwIDEgbCAxNjMgNCBsIDE2MyAxMzAgYiAxNjQgMjYwIDE2MyAyNTYgMTYzIDI1OCBiIDE3NSAyNzMgMTY2IDI2NiAxNzAgMjcwIFwifSxcInYyYVwiOntcInhfbWluXCI6LTIxLjc4MTI1LFwieF9tYXhcIjozNjYuMTQwNjI1LFwiaGFcIjozNzQsXCJvXCI6XCJtIDI3NiAxMzc4IGIgMjg0IDEzNzkgMjc5IDEzNzkgMjgxIDEzNzkgYiAzMDYgMTM2MCAyOTIgMTM3OSAyOTggMTM3NCBiIDM1MiAxMjQ3IDMyNiAxMzI2IDM0MyAxMjg2IGIgMzY2IDExMzkgMzYyIDEyMTMgMzY2IDExNzUgYiAzNDcgMTAwOSAzNjYgMTA5MyAzNTkgMTA0OSBsIDM0NCAxMDAyIGwgMzQ3IDk5MiBiIDM1MiA5NzEgMzQ4IDk4NiAzNTEgOTc3IGIgMzY2IDg2MyAzNjIgOTM2IDM2NiA4OTkgYiAzNDcgNzMyIDM2NiA4MTggMzU5IDc3MyBsIDM0NCA3MjUgbCAzNDcgNzE2IGIgMzUyIDY5NSAzNDggNzEwIDM1MSA3MDAgYiAzNjYgNTg4IDM2MiA2NTkgMzY2IDYyMyBiIDIyMyAyNjIgMzY2IDQ2NCAzMTQgMzQ1IGIgMTg5IDIzMyAyMTIgMjUyIDIxMiAyNTIgYiAzNSA3NiAxMjYgMTgzIDczIDEyOSBiIC0xIDE2IDIwIDU2IDIgMjcgYiAtMTkgNCAtNCA5IC0xMiA0IGwgLTIxIDQgbCAtMjEgMTM3IGwgLTIxIDI3MCBsIC0xNyAyNzAgYiAxODYgMzQ0IDU5IDI4MSAxMzQgMzA4IGIgMzE5IDYwNiAyNzAgMzk5IDMxOSA0OTkgYiAzMTcgNjUwIDMxOSA2MjAgMzE5IDYzNSBsIDMxNSA2NTkgbCAzMTQgNjU1IGIgMjIzIDUzNyAyODggNjA3IDI1OCA1NzAgYiAxODkgNTA5IDIxMiA1MjggMjEyIDUyOCBiIDM1IDM1MiAxMjYgNDU5IDczIDQwNSBiIC0xIDI5MiAyMCAzMzMgMiAzMDMgYiAtMTkgMjgwIC00IDI4NSAtMTIgMjgwIGwgLTIxIDI4MCBsIC0yMSA0MTMgbCAtMjEgNTQ2IGwgLTE3IDU0NiBiIDE4NiA2MjAgNTkgNTU3IDEzNCA1ODQgYiAzMTkgODgyIDI3MCA2NzUgMzE5IDc3NSBiIDMxNyA5MjUgMzE5IDg5NiAzMTkgOTExIGwgMzE1IDkzNSBsIDMxNCA5MzEgYiAyMjMgODEzIDI4OCA4ODQgMjU4IDg0NiBiIDE4OSA3ODUgMjEyIDgwNSAyMTIgODA1IGIgMzUgNjI4IDEyNiA3MzUgNzMgNjgxIGIgLTEgNTY5IDIwIDYwOSAyIDU4MCBiIC0xOSA1NTYgLTQgNTYyIC0xMiA1NTYgbCAtMjEgNTU2IGwgLTIxIDY4OSBsIC0yMSA4MjMgbCAtMTcgODIzIGIgMjAyIDkwNyA2OCA4MzUgMTUyIDg2NyBiIDMxOSAxMTU3IDI4MCA5NjggMzE5IDEwNjEgYiAyNzAgMTMzOCAzMTkgMTIxOCAzMDMgMTI4MSBiIDI2MiAxMzU4IDI2NCAxMzQ5IDI2MiAxMzUzIGIgMjYyIDEzNjQgMjYyIDEzNjAgMjYyIDEzNjMgYiAyNzYgMTM3OCAyNjUgMTM3MSAyNjkgMTM3NiBcIn0sXCJ2MmNcIjp7XCJ4X21pblwiOi01OTcuNTMxMjUsXCJ4X21heFwiOjU5Ni4xNzE4NzUsXCJoYVwiOjYwOCxcIm9cIjpcIm0gLTQxMyAxNzMgYiAtNDA4IDE3NCAtNDEyIDE3NCAtNDA5IDE3NCBiIC0zOTcgMTczIC00MDQgMTc0IC00MDAgMTczIGIgLTMwOCA4NiAtMzk0IDE3MiAtMzc0IDE1MSBiIC0yMjMgMCAtMjYxIDM3IC0yMjMgMCBiIC0xNTMgODQgLTIyMyAwIC0xOTEgMzcgYiAtNzcgMTc0IC04MyAxNzMgLTg0IDE3MiBiIC03MiAxNzQgLTc2IDE3NCAtNzQgMTc0IGIgLTYyIDE3MyAtNjggMTc0IC02MyAxNzMgYiAyNSA4NiAtNTkgMTcyIC0zOSAxNTEgYiAxMTIgMCA3MyAzNyAxMTEgMCBiIDE4MSA4NCAxMTIgMCAxNDQgMzcgYiAyNTcgMTc0IDI1MSAxNzMgMjUxIDE3MiBiIDI2MiAxNzQgMjU4IDE3NCAyNjEgMTc0IGIgMjczIDE3MyAyNjYgMTc0IDI3MCAxNzMgYiA0MzYgOSAyNzYgMTcyIDM0NyAxMDEgbCA0NDcgLTEgbCA0NzcgMzYgYiA1MjIgNzkgNTExIDc5IDUxMyA3OSBsIDUyMiA3OSBiIDU1MiA1MSA1MzMgNzkgNTM5IDczIGIgNTk2IC0xMTIgNTgyIDYgNTk2IC01MSBiIDU2NyAtMjYyIDU5NiAtMTYxIDU4NiAtMjEzIGIgNTM5IC0zMjIgNTU4IC0yODcgNTQ0IC0zMTYgYiA1MjQgLTMyNyA1MzQgLTMyNiA1MjkgLTMyNyBiIDUwNCAtMzE1IDUxNSAtMzI3IDUwNyAtMzIzIGIgNTAzIC0zMDggNTAzIC0zMTIgNTAzIC0zMDkgYiA1MTEgLTI4NSA1MDMgLTMwMiA1MDQgLTI5NyBiIDU1NSAtMTEzIDU0MCAtMjI3IDU1NSAtMTY5IGIgNTQ0IC0zNCA1NTUgLTg2IDU1MSAtNTkgYiA1MjIgMTkgNTQwIC0xNiA1MzAgOCBsIDUyMSAyMiBsIDQ4MSAtMjYgbCA0MDUgLTEyMiBiIDM1MyAtMTc2IDM2NiAtMTcyIDM2MiAtMTc2IGIgMzQ5IC0xNzYgMzUyIC0xNzYgMzUxIC0xNzYgYiAyNTMgLTg3IDM0MSAtMTc2IDM0NyAtMTgwIGIgMTY3IDAgMjA2IC0zOCAxNjcgMCBiIDk5IC04NiAxNjcgMCAxMzYgLTM4IGIgMjEgLTE3NCAyNyAtMTc0IDI4IC0xNzMgYiAxNyAtMTc2IDIwIC0xNzYgMTkgLTE3NiBiIDYgLTE3NCAxMyAtMTc2IDkgLTE3NCBiIC04MSAtODcgNCAtMTczIC0xNCAtMTUyIGIgLTE2NyAwIC0xMjkgLTM4IC0xNjcgMCBiIC0yMzYgLTg2IC0xNjcgMCAtMTk4IC0zOCBiIC0zMTMgLTE3NCAtMzA3IC0xNzQgLTMwNiAtMTczIGIgLTMxOCAtMTc2IC0zMTQgLTE3NiAtMzE1IC0xNzYgYiAtMzI4IC0xNzQgLTMyMSAtMTc2IC0zMjUgLTE3NCBiIC00OTEgLTEyIC0zMzAgLTE3MyAtMzY3IC0xMzcgbCAtNTAzIDAgbCAtNTMwIC0zNCBiIC01NzAgLTc3IC01NjIgLTczIC01NjQgLTc2IGIgLTU3NyAtNzkgLTU3MSAtNzkgLTU3NCAtNzkgYiAtNTk3IC01OCAtNTg4IC03OSAtNTk3IC02OSBiIC01OTYgLTQ5IC01OTcgLTU1IC01OTcgLTUyIGIgLTQxNyAxNzIgLTU5MyAtNDMgLTQyMyAxNjcgYiAtNDEzIDE3MyAtNDE3IDE3MiAtNDE1IDE3MyBcIn0sXCJ2MmRcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQzOC4yODEyNSxcImhhXCI6NDQ3LFwib1wiOlwibSAyMTIgMTkwIGIgMjE5IDE5MSAyMTMgMTkxIDIxNiAxOTEgYiAyMzYgMTc2IDIyNSAxOTEgMjI4IDE5MCBiIDQxOSAxOCAyNzcgMTA1IDM0MSA0OSBiIDQzNiA1IDQzMSAxMyA0MzQgMTEgYiA0MzggLTEgNDM4IDQgNDM4IDEgYiA0MjQgLTE2IDQzOCAtOCA0MzIgLTEzIGIgMzU2IC00OSA0MDkgLTIwIDM3OSAtMzYgYiAyMzQgLTE4MCAzMDYgLTgzIDI1OCAtMTMzIGIgMjE5IC0xOTIgMjMwIC0xODggMjI0IC0xOTIgYiAyMDAgLTE3NiAyMTMgLTE5MiAyMDYgLTE4NyBiIDkgLTE1IDE1NyAtMTAyIDg5IC00NSBiIDAgMCAyIC0xMiAwIC02IGIgMTYgMTggMCA5IDIgMTIgYiAyMDAgMTc2IDkzIDQ4IDE1OSAxMDQgYiAyMTIgMTkwIDIwNSAxODYgMjA4IDE4OCBtIDIzOSAxMTMgYiAyMzYgMTE3IDIzOCAxMTYgMjM4IDExNyBiIDIzMCAxMDggMjM1IDExNyAyMzQgMTE1IGIgOTIgLTE1IDE5NiA1OCAxNDAgOCBiIDg4IC0xOCA5MSAtMTYgODggLTE4IGIgOTIgLTIwIDg4IC0xOCA5MSAtMTkgYiAxOTggLTExNiAxMzAgLTQzIDE2NiAtNzQgYiAyMDAgLTExNyAyMDAgLTExNyAyMDAgLTExNyBiIDIwMSAtMTE3IDIwMCAtMTE3IDIwMSAtMTE3IGIgMjY0IC00MyAyMTIgLTk4IDI0MiAtNjIgYiAzNDUgMTUgMjg4IC0xOSAzMjEgNCBiIDM0OCAxOCAzNDcgMTYgMzQ4IDE2IGIgMzQ0IDIwIDM0OCAxOCAzNDcgMTkgYiAyMzkgMTEzIDMwNyA0MSAyNjYgNzkgXCJ9LFwidjJmXCI6e1wieF9taW5cIjotMS4zNTkzNzUsXCJ4X21heFwiOjY4MC41NjI1LFwiaGFcIjo2OTQsXCJvXCI6XCJtIDU5NyAxMDQyIGIgNjA0IDEwNDIgNjAwIDEwNDIgNjAyIDEwNDIgYiA2NDIgMTAwMiA2MjcgMTA0MiA2NDIgMTAyMiBiIDYxOSA5NjYgNjQyIDk4OCA2MzUgOTc0IGIgNDM5IDkyNyA1NzQgOTQyIDUwMyA5MjcgbCA0MjYgOTI3IGwgNDI2IDkyMSBiIDQzMCA4MzggNDI4IDg5MyA0MzAgODY2IGIgMzQ1IDQ4MCA0MzAgNjk2IDM5OCA1NjAgYiAxNzkgMzkxIDMwNyA0MjMgMjQ5IDM5MSBiIDE1NiAzOTIgMTcxIDM5MSAxNjQgMzkyIGIgMTM4IDM5NCAxNDkgMzk0IDE0MiAzOTQgYiAxMDMgNDM0IDExNSAzOTYgMTAzIDQxNiBiIDEyOSA0NzEgMTAzIDQ1MSAxMTEgNDY2IGIgMTQxIDQ3NCAxMzMgNDczIDEzNyA0NzQgYiAxNzIgNDU5IDE1MyA0NzQgMTY0IDQ2OSBiIDE4MSA0NTUgMTc1IDQ1NiAxNzYgNDU1IGIgMTg3IDQ1NiAxODIgNDU1IDE4NSA0NTUgYiAyNTMgNTIwIDIxMiA0NjAgMjM0IDQ4MyBiIDMxNSA4MzYgMjk0IDYwNSAzMTUgNzE0IGIgMzExIDkyOCAzMTUgODY3IDMxNCA4OTggYiAzMDIgOTQ1IDMxMCA5NDMgMzExIDk0MiBiIDI0NSA5NTMgMjgzIDk1MCAyNjIgOTUzIGIgMTMwIDg5MSAxOTMgOTUzIDE0OSA5MzEgYiA4NCA4NjAgMTE5IDg3MCAxMDIgODYwIGIgMzYgOTA1IDYxIDg2MCAzOSA4NzcgYiAzNiA5MTAgMzYgOTA3IDM2IDkwOSBiIDgwIDk3MCAzNiA5MzEgNTAgOTQ5IGIgMjQ5IDEwMTcgMTI1IDEwMDAgMTg3IDEwMTcgYiAzMjIgMTAwOSAyNzMgMTAxNyAyOTkgMTAxNCBsIDM0MSAxMDAzIGIgNDM2IDk5MSAzNzIgOTk1IDQwNiA5OTEgYiA1NzcgMTAzMSA0OTUgOTkxIDU0NSAxMDA0IGIgNTk3IDEwNDIgNTgzIDEwMzggNTkwIDEwNDEgbSA0MTYgMzYwIGIgNDI0IDM2MCA0MTkgMzYwIDQyMSAzNjAgYiA0ODEgMzA5IDQ1NCAzNjAgNDc5IDMzOCBiIDUwMyAxNDUgNDg0IDI4MCA0OTUgMTk5IGIgNTg1IC0xODUgNTI1IDE2IDU1NSAtMTA2IGIgNjMwIC0yNDUgNTk2IC0yMTMgNjEzIC0yMzcgbCA2MzQgLTI0NyBsIDYzOCAtMjQ1IGIgNjQ3IC0yNDQgNjQxIC0yNDUgNjQ1IC0yNDQgYiA2ODAgLTI3OCA2NjYgLTI0NCA2ODAgLTI2MiBiIDY2NCAtMzA4IDY4MCAtMjkwIDY3NSAtMzAxIGIgNjM4IC0zMTIgNjU4IC0zMTAgNjUwIC0zMTIgYiA2MTMgLTMwOSA2MzEgLTMxMiA2MjMgLTMxMCBiIDQ3NyAtMjAxIDU1NSAtMzAzIDUwMiAtMjYwIGIgNDE3IC0yIDQ2MCAtMTU5IDQzNCAtNzIgYiA0MTYgNSA0MTcgMSA0MTYgNSBiIDQxNiA1IDQxNiA1IDQxNiA1IGIgNDExIC01IDQxNSA1IDQxMyAwIGIgMzU5IC05NyAzOTcgLTMzIDM3NyAtNzAgYiAzNTMgLTEwNiAzNTUgLTEwMiAzNTMgLTEwNSBiIDM1OSAtMTEyIDM1MyAtMTA4IDM1NSAtMTA5IGIgNDA5IC0xMzAgMzc1IC0xMjMgMzkwIC0xMjkgYiA0MjYgLTEzNCA0MjAgLTEzMCA0MjEgLTEzMSBiIDQzMSAtMTQ3IDQyOCAtMTM3IDQzMSAtMTQxIGIgNDIwIC0xNjIgNDMxIC0xNTIgNDI3IC0xNTkgYiAzODIgLTE2OSA0MDkgLTE2NiAzOTYgLTE2OSBiIDMyMyAtMTU1IDM2MyAtMTY5IDM0MSAtMTY1IGwgMzE3IC0xNTIgbCAzMTQgLTE1NSBiIDYyIC0zMDMgMjQwIC0yNDAgMTQ4IC0yOTUgYiAzNiAtMzA1IDU1IC0zMDUgNDQgLTMwNSBiIDIzIC0zMDMgMjkgLTMwNSAyNCAtMzA1IGIgLTEgLTI3MyA2IC0yOTkgLTEgLTI4NyBiIDMxIC0yNDAgLTEgLTI1NiAxMCAtMjQwIGIgMzYgLTI0MCAzMiAtMjQwIDM0IC0yNDAgYiA0MiAtMjQxIDM4IC0yNDEgMzkgLTI0MSBiIDEzNCAtMjA0IDYzIC0yNDEgOTkgLTIyNiBiIDM2NyAyODggMjY1IC0xMTUgMzU3IDgxIGIgMzc1IDMzMCAzNjggMzEzIDM3MCAzMjAgYiA0MTYgMzYwIDM4MyAzNDcgNDAwIDM1OCBtIDM2MCAtMzU5IGIgMzc5IC0zNTkgMzYzIC0zNTkgMzcxIC0zNTkgYiA0MjQgLTM2MCAzOTYgLTM1OSA0MTYgLTM1OSBiIDY0NiAtNTAyIDUzNiAtMzczIDYyNCAtNDMwIGIgNjQ5IC01MjcgNjQ5IC01MTAgNjQ5IC01MTkgYiA1MzAgLTY3MyA2NDkgLTU3OCA2MDQgLTYzNSBsIDUyMSAtNjc3IGwgNTI5IC02ODEgYiA2NTMgLTgxMSA1OTIgLTcxNCA2MzcgLTc2MiBiIDY2MCAtODUzIDY1OCAtODI3IDY2MCAtODM5IGIgNjQ1IC05MTEgNjYwIC04NzMgNjU2IC04OTIgYiA0MjYgLTEwMjEgNjA4IC05ODEgNTE5IC0xMDIxIGIgMjgzIC05ODkgMzc3IC0xMDIxIDMyOCAtMTAxMSBiIDIzNSAtOTQ5IDI0OSAtOTcyIDIzOSAtOTY0IGIgMjM0IC05MzYgMjM0IC05NDYgMjM0IC05NDEgYiAyMzQgLTkyOCAyMzQgLTkzNCAyMzQgLTkzMSBsIDIzNSAtOTI1IGwgMjM0IC05MjcgbCAyMjUgLTkzNCBiIDg3IC05ODIgMTg2IC05NjYgMTM4IC05ODIgYiA4MCAtOTgyIDg1IC05ODIgODMgLTk4MiBiIDU1IC05ODEgNzAgLTk4MSA1OCAtOTgxIGIgMTcgLTk0MyAzMiAtOTgxIDE3IC05NjQgYiA1NCAtOTA0IDE3IC05MjEgMzUgLTkwNCBiIDc4IC05MTQgNjIgLTkwNCA3MiAtOTA5IGwgODMgLTkxOCBsIDg4IC05MTggYiAxOTAgLTgzMSAxMjIgLTkxOCAxNjYgLTg4MSBiIDI2OSAtNTA2IDI0MiAtNzI3IDI2OSAtNjEyIGIgMjY4IC00NjIgMjY5IC00OTIgMjY5IC00NzcgYiAyNjYgLTQ0OSAyNjYgLTQ1OCAyNjYgLTQ1MiBiIDI2NSAtNDQ0IDI2NiAtNDQ1IDI2NiAtNDQ0IGIgMjU3IC00NDYgMjY0IC00NDQgMjYxIC00NDUgYiAxMzIgLTU0NSAxOTYgLTQ3MCAxNTIgLTUwNSBiIDg4IC01NzMgMTIyIC01NjMgMTA0IC01NzMgYiAzOSAtNTIzIDYzIC01NzMgMzkgLTU1MyBiIDYzIC00NzYgMzkgLTUwNSA0NCAtNDk0IGIgMzYwIC0zNTkgMTM2IC00MDggMjM1IC0zNjkgbSA0MTkgLTQyNCBiIDM5MyAtNDIzIDQxMSAtNDIzIDQwNiAtNDIzIGwgMzc1IC00MjMgbCAzNzcgLTQyNiBiIDM3OSAtNDM5IDM3NyAtNDI3IDM3OCAtNDM0IGIgMzgzIC01MTAgMzgyIC00NjMgMzgzIC00ODcgYiAzMTQgLTgxMSAzODMgLTYwOSAzNjAgLTcxMCBiIDI2NiAtODkzIDI5NiAtODUwIDI4NSAtODcwIGIgMjY0IC04OTggMjY1IC04OTYgMjY0IC04OTggbCAyNjQgLTg5OCBiIDI2NCAtODk4IDI2NCAtODk4IDI2NCAtODk4IGIgMjY4IC04OTggMjY0IC04OTggMjY2IC04OTggYiAyNzMgLTg5OCAyNzAgLTg5OCAyNzIgLTg5OCBiIDMwMCAtOTA5IDI4MyAtODk4IDI5MSAtOTAwIGIgNDI2IC05NTcgMzQwIC05NDEgMzg1IC05NTcgYiA0NzYgLTk0OSA0NDMgLTk1NyA0NjAgLTk1NCBiIDU0NyAtODUzIDUyMiAtOTMxIDU0NyAtODkzIGIgNDg1IC03NDUgNTQ3IC04MTYgNTI2IC03NzUgYiAzOTcgLTcwNyA0NjAgLTcyNyA0MzIgLTcxNCBiIDM2NiAtNjc1IDM3NSAtNzAzIDM2NiAtNjkyIGIgMzk2IC02NDIgMzY2IC02NTcgMzc3IC02NDUgYiA1MzAgLTU1NyA0NTUgLTYzNyA1MTEgLTYwMSBiIDUzNiAtNTI3IDUzNCAtNTQ4IDUzNiAtNTM3IGIgNDE5IC00MjQgNTM2IC00ODAgNDkwIC00MzcgXCJ9LFwidjMwXCI6e1wieF9taW5cIjotMjEuNzgxMjUsXCJ4X21heFwiOjM2Ny41LFwiaGFcIjozNzUsXCJvXCI6XCJtIDI3NiAxOTAwIGIgMjg0IDE5MDEgMjc5IDE5MDAgMjgxIDE5MDEgYiAzMDYgMTg4MyAyOTEgMTkwMSAyOTggMTg5NiBiIDM2NyAxNjg2IDM0NyAxODI1IDM2NyAxNzU3IGIgMzQzIDE1NTggMzY3IDE2NDMgMzU5IDE2MDAgbCAzMzggMTU0OSBsIDM0MyAxNTM3IGIgMzY3IDE0MTEgMzU5IDE0OTcgMzY3IDE0NTQgYiAzNDMgMTI4MiAzNjcgMTM2NyAzNTkgMTMyNCBsIDMzOCAxMjcyIGwgMzQzIDEyNjEgYiAzNjcgMTEzNSAzNTkgMTIyMSAzNjcgMTE3OCBiIDM0MyAxMDA3IDM2NyAxMDkwIDM1OSAxMDQ3IGwgMzM4IDk5NiBsIDM0MyA5ODUgYiAzNjcgODU5IDM1OSA5NDUgMzY3IDkwMiBiIDM0MyA3MzEgMzY3IDgxNCAzNTkgNzcxIGwgMzM4IDcyMCBsIDM0MyA3MDkgYiAzNjcgNTgyIDM1OSA2NjcgMzY3IDYyNiBiIDI4OSAzNjIgMzY3IDUwMyAzNDAgNDI2IGIgMjM5IDMxMiAyNzYgMzQ1IDI1OSAzMzAgYiAyOSA3NyAxNTIgMjM3IDc2IDE1MiBiIC0xIDE4IDE0IDU0IDIgMzAgYiAtMTkgNCAtNCAxMSAtMTIgNCBsIC0yMSA0IGwgLTIxIDEzMyBsIC0yMCAyNjAgbCAtMTMgMjYyIGIgOTggMjk5IDE3IDI2OSA2MiAyODQgYiAxMTEgMzA1IDEwMyAzMDIgMTEwIDMwNSBiIDE2NyAzMzQgMTIzIDMxMCAxNTYgMzI3IGIgMzE5IDU5NSAyNjQgMzkxIDMxOSA0OTEgYiAzMTMgNjU5IDMxOSA2MTYgMzE4IDYzOCBiIDMxMCA2NjcgMzExIDY2NCAzMTEgNjY3IGIgMzA3IDY2MyAzMTAgNjY3IDMwOCA2NjYgYiAyNDAgNTg4IDI4OSA2MzcgMjY5IDYxNCBiIDE2IDMzMSAxNDEgNTA1IDYyIDQxMyBiIC0xIDI5NCA4IDMxNiAxIDMwMiBiIC0xOSAyODAgLTQgMjg3IC0xMiAyODAgbCAtMjEgMjgwIGwgLTIxIDQwOCBsIC0yMCA1MzcgbCAtMTMgNTM4IGIgOTggNTc2IDE3IDU0NSA2MiA1NjAgYiAxMTEgNTgxIDEwMyA1NzggMTEwIDU4MSBiIDE2NyA2MTAgMTIzIDU4NyAxNTYgNjAzIGIgMzE5IDg3MSAyNjQgNjY3IDMxOSA3NjcgYiAzMTMgOTM1IDMxOSA4OTIgMzE4IDkxMyBiIDMxMCA5NDIgMzExIDk0MSAzMTEgOTQyIGIgMzA3IDkzOSAzMTAgOTQyIDMwOCA5NDEgYiAyNDAgODY0IDI4OSA5MTMgMjY5IDg4OSBiIDE2IDYwNyAxNDEgNzgxIDYyIDY4OSBiIC0xIDU3MCA4IDU5MiAxIDU3OCBiIC0xOSA1NTYgLTQgNTYzIC0xMiA1NTYgbCAtMjEgNTU2IGwgLTIxIDY4NCBsIC0yMCA4MTMgbCAtMTMgODE0IGIgOTggODUyIDE3IDgyMSA2MiA4MzYgYiAxMTEgODU3IDEwMyA4NTUgMTEwIDg1NyBiIDE2NyA4ODYgMTIzIDg2MyAxNTYgODgwIGIgMzE5IDExNDcgMjY0IDk0MyAzMTkgMTA0MyBiIDMxMyAxMjExIDMxOSAxMTY4IDMxOCAxMTg5IGIgMzEwIDEyMTggMzExIDEyMTcgMzExIDEyMTggYiAzMDcgMTIxNSAzMTAgMTIxOCAzMDggMTIxNyBiIDI0MCAxMTQwIDI4OSAxMTg4IDI2OSAxMTY1IGIgMTYgODg0IDE0MSAxMDU3IDYyIDk2NiBiIC0xIDg0NiA4IDg2OCAxIDg1NSBiIC0xOSA4MzIgLTQgODM5IC0xMiA4MzIgbCAtMjEgODMyIGwgLTIxIDk2MCBsIC0yMCAxMDg5IGwgLTEzIDEwOTAgYiA5OCAxMTI4IDE3IDEwOTcgNjIgMTExMSBiIDExMSAxMTM0IDEwMyAxMTMxIDExMCAxMTM0IGIgMTY3IDExNjMgMTIzIDExMzkgMTU2IDExNTYgYiAzMTkgMTQyNCAyNjQgMTIyMCAzMTkgMTMyMCBiIDMxMyAxNDg2IDMxOSAxNDQ0IDMxOCAxNDY1IGIgMzEwIDE0OTQgMzExIDE0OTMgMzExIDE0OTQgYiAzMDcgMTQ5MiAzMTAgMTQ5NCAzMDggMTQ5MyBiIDI0MCAxNDE3IDI4OSAxNDY0IDI2OSAxNDQyIGIgMTYgMTE2MCAxNDEgMTMzMyA2MiAxMjQyIGIgLTEgMTEyMSA4IDExNDUgMSAxMTMxIGIgLTE5IDExMDkgLTQgMTExNSAtMTIgMTEwOSBsIC0yMSAxMTA5IGwgLTIxIDEyMzYgbCAtMjAgMTM2NSBsIC0xMyAxMzY3IGIgOTggMTQwNCAxNyAxMzc0IDYyIDEzODggYiAxMTEgMTQxMCAxMDMgMTQwNyAxMTAgMTQxMCBiIDI1MCAxNTA4IDE3MiAxNDM3IDIxNSAxNDY3IGIgMzE5IDE3MDEgMjk2IDE1NjQgMzE5IDE2MzMgYiAyNzAgMTg1OSAzMTkgMTc1NyAzMDMgMTgxNCBiIDI2MiAxODgyIDI2NSAxODY4IDI2MiAxODc1IGIgMjc2IDE5MDAgMjYyIDE4OTAgMjY2IDE4OTYgXCJ9LFwidjMxXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjozODYuNTYyNSxcImhhXCI6Mzk0LFwib1wiOlwibSAwIDE3MyBsIDAgMzQ3IGwgMTkzIDM0NyBsIDM4NiAzNDcgbCAzODYgMTczIGwgMzg2IDAgbCAxOTMgMCBsIDAgMCBsIDAgMTczIFwifSxcInYzM1wiOntcInhfbWluXCI6LTQyMy4zMTI1LFwieF9tYXhcIjo0MjEuOTM3NSxcImhhXCI6NDMxLFwib1wiOlwibSAtMTAgMjc2IGIgLTIgMjc3IC04IDI3NyAtNSAyNzcgYiAxNyAyNjUgNSAyNzcgMTMgMjczIGIgMTkgMTYzIDE5IDI2MCAxOSAyNjAgbCAxOSA2OCBsIDM5IDQ1IGIgMjc3IC05NSAxMjIgLTM0IDIwMCAtODEgYiAyODkgLTk3IDI4MSAtOTcgMjg1IC05NyBiIDM3OCAwIDMzMiAtOTcgMzcxIC01NCBiIDM3OCAxMSAzNzggNCAzNzggNiBiIDMwMiA4MyAzNzggNTUgMzQ1IDgzIGIgMjQyIDY2IDI4MyA4MyAyNjIgNzcgYiAyMDggNTYgMjMxIDU5IDIxOSA1NiBiIDE0OCAxMjAgMTc1IDU2IDE0OCA4MSBiIDIwMCAxODYgMTQ4IDE1MSAxNjQgMTcyIGIgMjYxIDE5OCAyMjAgMTk0IDI0MCAxOTggYiA0MjAgNDUgMzQxIDE5OCA0MTEgMTM3IGIgNDIxIDIyIDQyMSAzNyA0MjEgMjkgYiAyNTcgLTE5OCA0MjEgLTg2IDM0NyAtMTg4IGIgMjQyIC0xOTggMjUxIC0xOTggMjQ3IC0xOTggYiAyMCAtMTA1IDE4MSAtMTk4IDk1IC0xNjMgbCAxOSAtMTA0IGwgMTkgLTE4MyBiIDE5IC0yMTYgMTkgLTE5NSAxOSAtMjA2IGIgMTIgLTI3MyAxOSAtMjcyIDE3IC0yNjcgYiAtMiAtMjc4IDggLTI3NyAyIC0yNzggYiAtMjEgLTI2NiAtMTAgLTI3OCAtMTkgLTI3NCBiIC0yMyAtMTY1IC0yMyAtMjYzIC0yMyAtMjYyIGwgLTIzIC02OSBsIC00NCAtNDcgYiAtMjUwIDg2IC0xMTcgMjMgLTE4MyA2NiBiIC0yOTUgOTQgLTI3MCA5MyAtMjg0IDk0IGIgLTMxNSA5MSAtMzAyIDk0IC0zMDggOTQgYiAtMzgxIDUgLTM1NiA4MSAtMzgxIDQzIGIgLTM1NSAtNTYgLTM4MSAtMTYgLTM3MiAtNDAgYiAtMjk5IC04MSAtMzM4IC03MyAtMzE5IC04MSBiIC0yNDYgLTY4IC0yODMgLTgxIC0yNjUgLTc3IGIgLTIxMiAtNTggLTIzNCAtNjEgLTIyMyAtNTggYiAtMTY4IC03NyAtMTk2IC01OCAtMTc5IC02NSBiIC0xNTEgLTEyMiAtMTU2IC05MCAtMTUxIC0xMDUgYiAtMTc5IC0xNzQgLTE1MSAtMTQxIC0xNjAgLTE2MiBiIC0yMzkgLTE5NSAtMTk0IC0xODQgLTIxNyAtMTkyIGIgLTI1NyAtMTk3IC0yNDUgLTE5NSAtMjUwIC0xOTcgYiAtNDIzIC01IC0zNDkgLTE5NyAtNDIzIC0xMTMgYiAtNDIzIDAgLTQyMyAtNCAtNDIzIC0xIGIgLTI3NyAxOTQgLTQyMCA5NyAtMzYyIDE3MyBiIC0yNDcgMTk3IC0yNjggMTk3IC0yNTggMTk3IGIgLTI0IDEwNCAtMTg1IDE5NyAtMTAwIDE2MiBsIC0yMyAxMDIgbCAtMjMgMTgxIGIgLTIxIDI2NSAtMjMgMjYwIC0yMyAyNjAgYiAtMTAgMjc2IC0yMCAyNjkgLTE0IDI3NCBcIn0sXCJ2MzRcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjYyMi4wMzEyNSxcImhhXCI6NjM1LFwib1wiOlwibSAzOTggNDE3IGIgNDA2IDQxOSA0MDEgNDE5IDQwNCA0MTkgYiA0MjcgMzk4IDQxNyA0MTkgNDI3IDQwOSBiIDQyNyAzOTEgNDI3IDM5NSA0MjcgMzkyIGIgMzQgLTI3NCA0MjQgMzg1IDM4IC0yNzIgYiAyMCAtMjgwIDI5IC0yNzggMjUgLTI4MCBiIDAgLTI1OSA5IC0yODAgMCAtMjcwIGIgMCAtMjUyIDAgLTI1NiAwIC0yNTQgYiAzOTMgNDEzIDIgLTI0NyAzODkgNDEwIGIgMzk4IDQxNyAzOTQgNDE1IDM5NyA0MTYgbSA1OTIgNDE3IGIgNjAwIDQxOSA1OTQgNDE5IDU5NyA0MTkgYiA2MjIgMzk4IDYxMSA0MTkgNjIyIDQwOSBiIDYyMCAzOTEgNjIyIDM5NSA2MjAgMzkyIGIgMjI3IC0yNzQgNjE3IDM4NSAyMzEgLTI3MiBiIDIxMyAtMjgwIDIyMyAtMjc4IDIxOSAtMjgwIGIgMTkzIC0yNTkgMjAyIC0yODAgMTkzIC0yNzAgYiAxOTQgLTI1MiAxOTMgLTI1NiAxOTMgLTI1NCBiIDU4NiA0MTMgMTk2IC0yNDcgNTgyIDQxMCBiIDU5MiA0MTcgNTg4IDQxNSA1OTAgNDE2IFwifSxcInYzNlwiOntcInhfbWluXCI6LTEuMzU5Mzc1LFwieF9tYXhcIjoxMDY0LjM5MDYyNSxcImhhXCI6MTA4NixcIm9cIjpcIm0gMjk2IDY5MiBiIDMxNCA2OTQgMzAyIDY5NCAzMDcgNjk0IGIgMzg2IDY4NSAzMzcgNjk0IDM2NiA2ODkgYiA1NDggNDk4IDQ4MCA2NjAgNTQ4IDU4MCBiIDU0OCA0ODEgNTQ4IDQ5MiA1NDggNDg3IGIgNDU1IDM5NSA1NDEgNDI2IDQ5OSAzOTUgYiAzNzAgNDYyIDQyMCAzOTUgMzgzIDQxNyBiIDM2MiA0OTYgMzY0IDQ3NyAzNjIgNDg4IGIgMzc3IDUxNCAzNjIgNTA5IDM2NyA1MTQgYiAzOTMgNTAxIDM4NiA1MTQgMzkwIDUxMCBiIDQzMiA0NzQgMzk3IDQ4NCA0MTMgNDc0IGIgNDcwIDQ4NyA0NDUgNDc0IDQ1OCA0NzggYiA0OTEgNTMwIDQ4NCA0OTYgNDkxIDUxMCBiIDQ5MCA1NDQgNDkxIDUzNCA0OTEgNTM5IGIgMzMzIDY2MCA0NzkgNjA2IDQxMSA2NTcgbCAzMjMgNjYyIGwgMzE1IDY0NiBiIDI2OSA1MjQgMjg1IDU5MSAyNjkgNTU2IGIgMzIxIDQzMSAyNjkgNDkyIDI4NyA0NjYgYiAzNDkgMzk1IDMzOCA0MTMgMzQzIDQwOCBiIDM2MyAzNDIgMzU5IDM3OCAzNjMgMzYyIGIgMzU5IDMxMiAzNjMgMzMzIDM2MiAzMjIgYiAyODUgMTU4IDM0OCAyNjYgMzE4IDIwNiBiIDI4MSAxNTIgMjgzIDE1NSAyODEgMTUyIGIgMjgxIDE1MiAyODEgMTUyIDI4MSAxNTIgYiAyODcgMTU0IDI4MyAxNTIgMjg0IDE1MiBiIDMxOCAxNTUgMjk4IDE1NCAzMDggMTU1IGIgNDYxIDk4IDM3MSAxNTUgNDE5IDEzNiBsIDQ2NCA5NyBsIDQ4MyAxMTIgYiA1MDMgMTI5IDQ5NCAxMjAgNTAzIDEyNyBiIDUwNCAxMzAgNTAzIDEyOSA1MDQgMTI5IGIgNTAzIDEzOCA1MDQgMTMxIDUwMyAxMzQgYiA1MDAgMTgwIDUwMCAxNTIgNTAwIDE2NiBiIDU1MyAzMjYgNTAwIDIzOCA1MTggMjg4IGIgNjA0IDM2NiA1NjAgMzMxIDU5MiAzNTggYiA2NDkgMzgxIDYxNyAzNzYgNjMyIDM4MSBiIDY5NiAzNjIgNjY1IDM4MSA2ODEgMzc0IGIgNzI0IDMwMiA3MTQgMzQ3IDcyNCAzMjQgYiA2OTUgMjM4IDcyNCAyNzggNzE0IDI1NSBiIDY2MCAyMTAgNjkxIDIzNCA2NjIgMjEyIGIgNTc5IDE0OCA2NTggMjA5IDU4MiAxNTEgYiA1NzkgMTQ4IDU3OSAxNDggNTc5IDE0OCBiIDU5NiAxMDYgNTc5IDE0NCA1ODkgMTE5IGIgNjIyIDc3IDYwNCA4OCA2MDkgODMgYiA2NTcgNjkgNjMyIDcyIDY0NSA2OSBiIDc0OCAxMTIgNjg4IDY5IDcyMSA4NCBiIDc1NSAxMjMgNzU0IDExNyA3NTUgMTIwIGIgNzU1IDEyNyA3NTUgMTI0IDc1NSAxMjYgYiA3NTEgMTY1IDc1MiAxMzcgNzUxIDE1MSBiIDc1OCAyMTkgNzUxIDE4MyA3NTQgMjAyIGIgODk0IDM4NyA3NzQgMjkwIDgyMCAzNDcgYiA4OTYgMzkwIDg5NiAzODggODk2IDM4OCBiIDg5MSAzOTggODk2IDM5MSA4OTUgMzkyIGIgNjIyIDU2MCA4MjcgNDc3IDczMCA1MzUgYiA2MDAgNTgwIDYwNSA1NjQgNjAwIDU2OSBiIDYxNyA1OTYgNjAwIDU5MSA2MDcgNTk2IGIgNjI4IDU5NSA2MjIgNTk2IDYyNCA1OTYgYiAxMDU3IDI0OCA4NDYgNTUyIDEwMjAgNDEyIGIgMTA2NCAxOTEgMTA2MSAyMjkgMTA2NCAyMDkgYiA5MjIgMCAxMDY0IDk0IDEwMDUgOSBiIDkwMiAtMSA5MTYgLTEgOTA5IC0xIGIgNzc0IDc2IDg0NyAtMSA4MDAgMjYgYiA3NjkgODMgNzcwIDgxIDc3MCA4MyBiIDc2OSA4MSA3NjkgODMgNzY5IDgzIGIgNjI3IC0xIDczMyAyOSA2NzcgLTEgYiA1NDggMjcgNTk3IC0xIDU3MCA4IGIgNTE1IDg4IDUzNyAzNyA1MjUgNjEgbCA1MTMgOTUgbCA1MTAgOTMgbCA0NTMgNDUgYiAzOTAgMCAzOTYgMCAzOTYgMCBiIDM5MCAwIDM5MCAwIDM5MCAwIGIgMzc0IDE1IDM4MSAwIDM3NyA0IGIgMjY4IDEwNSAzNTkgNjkgMzE0IDEwNSBiIDI1MCAxMDQgMjYyIDEwNSAyNTcgMTA1IGwgMjQzIDEwMiBsIDIzNCA5MCBiIDE1NSAxIDIwMSA0OSAxNTkgMiBiIDE0NyAtMSAxNTIgMCAxNDkgLTEgYiAxMzAgMTUgMTM4IC0xIDEzMCA2IGIgMTMyIDIwIDEzMCAxOCAxMzIgMTkgYiAxMzYgMzEgMTMzIDIyIDEzNCAyNyBiIDIyMCAxMzEgMTQ5IDc0IDE3OCAxMDkgYiAyMzEgMTM3IDIyNSAxMzQgMjMwIDEzNiBiIDMwMiAyNzggMjgwIDIwMiAzMDIgMjQ0IGIgMjY1IDMzNSAzMDIgMjk5IDI5NSAzMDkgYiAyMDkgNDQyIDIzNCAzNjMgMjEzIDQwMiBiIDIwOSA0NTUgMjA5IDQ0NiAyMDkgNDUxIGIgMjc5IDY0OCAyMDkgNTAyIDIzMiA1NjQgbCAyODUgNjU5IGwgMjgzIDY1OSBiIDE3NiA2MjcgMjM4IDY1MyAyMTAgNjQ1IGIgNTcgNDc3IDExMSA1OTQgNjYgNTM4IGIgNTUgNDU5IDU1IDQ3MSA1NSA0NjQgYiA3MiA0MDkgNTUgNDM3IDYxIDQxNSBiIDkzIDQwMyA3OCA0MDUgODcgNDAzIGIgMTUyIDQ2NyAxMjMgNDAzIDE1MSA0MzEgYiAxNjggNDg4IDE1MyA0ODMgMTU3IDQ4OCBiIDE4NSA0NjIgMTgxIDQ4OCAxODUgNDgzIGwgMTg1IDQ2MCBiIDEzNyAzNDQgMTgzIDQwOSAxNjggMzY5IGIgNzggMzIyIDExOSAzMjggOTggMzIyIGIgMTMgMzYwIDUwIDMyMiAyNSAzMzUgYiAtMSA0MjYgNCAzODAgLTEgNDAyIGIgODkgNjEwIC0xIDQ4OCAzMiA1NTkgYiAyOTYgNjkyIDE0NyA2NTkgMjEwIDY4NSBtIDkyNiAzNDggYiA5MjEgMzUzIDkyNCAzNTEgOTIyIDM1MyBiIDkxNCAzNDggOTIwIDM1MyA5MTggMzUxIGIgODIzIDE2NyA4NTcgMzA2IDgyMyAyMzcgYiA4MjggMTI0IDgyMyAxNTQgODI2IDEzOCBiIDg5MCAzMSA4MzcgNzkgODYyIDQwIGIgODk2IDMxIDg5MiAzMSA4OTQgMzEgYiA5NTYgMTA0IDkxNiAzMSA5NDAgNTkgYiA5NzAgMTkxIDk2NSAxMjkgOTcwIDE1OSBiIDk2NiAyNDEgOTcwIDIwOCA5NjkgMjI0IGIgOTI2IDM0OCA5NTkgMjc3IDk0NSAzMTMgbSA2MjcgMzI2IGIgNjE5IDMyNiA2MjQgMzI2IDYyMiAzMjYgYiA1OTggMzE2IDYxMSAzMjYgNjA0IDMyMyBiIDU2OCAyMTUgNTc5IDI4OCA1NjggMjU1IGIgNTY4IDIwOCA1NjggMjEzIDU2OCAyMTAgYiA1NzEgMTgzIDU3MCAxOTUgNTcwIDE4NCBsIDU3MSAxODMgYiA1OTQgMjAxIDU3MSAxODMgNTgyIDE5MSBsIDYzNCAyMzEgYiA2NjAgMjU5IDY1MyAyNDcgNjU2IDI0OCBiIDY2NCAyNzggNjYyIDI2NiA2NjQgMjcyIGIgNjI3IDMyNiA2NjQgMjk5IDY0OSAzMjAgXCJ9LFwidjM4XCI6e1wieF9taW5cIjotMS4zNTkzNzUsXCJ4X21heFwiOjY1MS45Njg3NSxcImhhXCI6NjY1LFwib1wiOlwibSAzODkgNjQ0IGIgNDA1IDY0NSAzOTQgNjQ1IDQwMCA2NDUgYiA1MDQgNTY2IDQ1MCA2NDUgNDkyIDYxMyBiIDUwNyA1NDEgNTA2IDU1NyA1MDcgNTQ5IGIgNDgwIDQ3MSA1MDcgNTE0IDQ5OCA0ODkgbCA0NzcgNDY3IGwgNDgzIDQ3MCBiIDYwOSA1OTEgNTM5IDQ4NSA1ODYgNTMxIGIgNjEzIDYwMSA2MTEgNTk1IDYxMyA1OTkgYiA2MzEgNjA5IDYxOSA2MDcgNjI0IDYwOSBiIDY1MSA1ODggNjQxIDYwOSA2NTEgNjAyIGIgMjAwIC05NDYgNjUxIDU4NCAyMDQgLTk0MSBiIDE4MiAtOTU3IDE5NyAtOTUzIDE5MCAtOTU3IGIgMTYzIC05NDUgMTc0IC05NTcgMTY2IC05NTMgYiAxNjEgLTkzOSAxNjEgLTk0MiAxNjEgLTk0MiBiIDIxNyAtNzQzIDE2MSAtOTMxIDE3MCAtOTA0IGIgMjcyIC01NTUgMjQ3IC02MzkgMjcyIC01NTUgYiAyNzIgLTU1NSAyNzIgLTU1NSAyNzIgLTU1NSBiIDI2NCAtNTYwIDI3MiAtNTU1IDI2OCAtNTU3IGIgMTQwIC02MDMgMjI3IC01ODkgMTgyIC02MDMgYiAzNiAtNTY3IDEwMiAtNjAzIDY1IC01OTIgYiAtMSAtNDg3IDEyIC01NDggLTEgLTUxNyBiIDE3IC00MjcgLTEgLTQ2NiA1IC00NDUgYiAxMDMgLTM4MCAzOCAtMzk1IDcwIC0zODAgYiAxOTEgLTQzMyAxMzcgLTM4MCAxNzIgLTM5OCBiIDIwNSAtNDg0IDIwMSAtNDQ4IDIwNSAtNDY2IGIgMTc4IC01NTMgMjA1IC01MDkgMTk2IC01MzUgbCAxNzUgLTU1NyBsIDE4MiAtNTU1IGIgMzA3IC00MzUgMjM2IC01MzkgMjg0IC00OTQgYiAzNzIgLTIxMyAzMDggLTQzMCAzNzIgLTIxNSBiIDM3MiAtMjEzIDM3MiAtMjEzIDM3MiAtMjEzIGIgMzY0IC0yMTkgMzcyIC0yMTMgMzY4IC0yMTYgYiAyNDAgLTI2MiAzMjggLTI0NyAyODMgLTI2MiBiIDEzNyAtMjI2IDIwMiAtMjYyIDE2NiAtMjQ5IGIgOTkgLTE0NSAxMTIgLTIwNiA5OSAtMTc2IGIgMTE4IC04NCA5OSAtMTI0IDEwNiAtMTA0IGIgMjA0IC0zOCAxMzggLTU0IDE3MSAtMzggYiAyOTIgLTkxIDIzOCAtMzggMjczIC01NiBiIDMwNiAtMTQxIDMwMiAtMTA2IDMwNiAtMTI0IGIgMjc5IC0yMTIgMzA2IC0xNjcgMjk2IC0xOTQgbCAyNzYgLTIxNSBsIDI4MSAtMjEzIGIgNDA4IC05MyAzMzYgLTE5OCAzODUgLTE1MSBiIDQ3MyAxMjkgNDA5IC04OCA0NzMgMTI3IGIgNDczIDEyOSA0NzMgMTI5IDQ3MyAxMjkgYiA0NjUgMTIyIDQ3MyAxMjkgNDY5IDEyNiBiIDM0MSA4MCA0MjggOTQgMzgzIDgwIGIgMjM2IDExNSAzMDMgODAgMjY2IDkxIGIgMjAwIDE5NSAyMTMgMTM2IDIwMCAxNjUgYiAyMTcgMjU2IDIwMCAyMTcgMjA2IDIzOCBiIDMwNCAzMDMgMjM5IDI4NyAyNzIgMzAzIGIgMzkzIDI0OSAzMzggMzAzIDM3NCAyODUgYiA0MDYgMTk5IDQwMiAyMzQgNDA2IDIxNyBiIDM3OSAxMjkgNDA2IDE3MyAzOTcgMTQ4IGwgMzc3IDEyNiBsIDM4MiAxMjcgYiA1MDkgMjQ4IDQzNiAxNDIgNDg1IDE5MCBiIDU3NCA0NzAgNTEwIDI1NCA1NzQgNDY5IGIgNTc0IDQ3MCA1NzQgNDcwIDU3NCA0NzAgYiA1NjYgNDY0IDU3NCA0NzAgNTcwIDQ2NyBiIDQ0MiA0MjEgNTI5IDQzNSA0ODQgNDIxIGIgMzM3IDQ1OCA0MDQgNDIxIDM2NyA0MzMgYiAzMDAgNTM3IDMxMyA0NzggMzAwIDUwOCBiIDM4OSA2NDQgMzAwIDU4NSAzMzQgNjM1IFwifSxcInYzYlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NDg0LjU2MjUsXCJoYVwiOjQ5NCxcIm9cIjpcIm0gMjI4IDI0NSBiIDIzOSAyNDcgMjM0IDI0NyAyMzkgMjQ3IGIgMjQzIDI0NyAyNDAgMjQ3IDI0MiAyNDcgYiAzMDMgMjM4IDI1NyAyNDcgMjg3IDI0MiBiIDQ4NCAtMiA0MTcgMjA4IDQ4NCAxMDQgYiA0MTIgLTE3NyA0ODQgLTY1IDQ2MSAtMTI3IGIgMjQzIC0yNDggMzYzIC0yMjYgMzAzIC0yNDggYiA2IC02MyAxMzggLTI0OCAzNiAtMTgwIGIgMCAtMSAxIC00MSAwIC0yMCBiIDIyOCAyNDUgMCAxMjcgOTggMjQwIG0gMjU1IDE4MSBiIDI0MCAxODMgMjQ3IDE4MyAyNDUgMTgzIGIgMjMyIDE4MSAyMzggMTgzIDIzNSAxODMgYiAxNDIgMTUyIDIwMCAxODAgMTY4IDE3MCBsIDEzOCAxNDkgbCAxOTAgOTcgbCAyNDIgNDQgbCAyOTQgOTcgbCAzNDUgMTQ5IGwgMzQwIDE1MiBiIDI1NSAxODEgMzE1IDE2OSAyODQgMTgwIG0gMTQ3IC01NCBsIDE5NyAtMSBsIDE0NyA1MSBsIDk1IDEwNCBsIDkxIDk5IGIgNjIgLTEgNzIgNzAgNjIgMzQgYiA2NiAtNDMgNjIgLTE1IDYzIC0yOSBiIDkxIC0xMDEgNzIgLTYzIDgwIC04NCBsIDk1IC0xMDYgbCAxNDcgLTU0IG0gMzkzIDk5IGIgMzg5IDEwNCAzOTAgMTAyIDM4OSAxMDQgYiAzMzcgNTEgMzg5IDEwNCAzNjYgODAgbCAyODUgLTEgbCAzMzcgLTU0IGwgMzg5IC0xMDYgbCAzOTMgLTEwMSBiIDQyMSAtMSA0MTIgLTcyIDQyMSAtMzYgYiAzOTMgOTkgNDIxIDM0IDQxMiA2OSBtIDI5NCAtOTggYiAyNDIgLTQ1IDI2NSAtNjkgMjQyIC00NSBiIDE5MCAtOTggMjQyIC00NSAyMTkgLTY5IGwgMTM4IC0xNTEgbCAxNDIgLTE1NCBiIDI0MiAtMTg0IDE3MiAtMTc0IDIwNiAtMTg0IGIgMzQwIC0xNTQgMjc2IC0xODQgMzExIC0xNzQgbCAzNDUgLTE1MSBsIDI5NCAtOTggXCJ9LFwidjNjXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0NTAuNTMxMjUsXCJoYVwiOjQ2MCxcIm9cIjpcIm0gMTg5IDMwMiBiIDIwNCAzMDMgMTkzIDMwMiAxOTggMzAzIGIgMzAzIDIyNCAyNTAgMzAzIDI5MiAyNzAgYiAzMDYgMTk5IDMwNCAyMTYgMzA2IDIwOCBiIDI3OSAxMjkgMzA2IDE3MyAyOTYgMTQ3IGwgMjc2IDEyNiBsIDI4MSAxMjcgYiA0MDggMjQ5IDMzNyAxNDIgMzg1IDE5MCBiIDQxMiAyNTkgNDA5IDI1NCA0MTIgMjU4IGIgNDMwIDI2NyA0MTcgMjY1IDQyMyAyNjcgYiA0NTAgMjQ3IDQ0MSAyNjcgNDUwIDI1OSBiIDIwMCAtNjA1IDQ1MCAyNDIgMjA0IC01OTkgYiAxODIgLTYxNiAxOTcgLTYxMiAxOTAgLTYxNiBiIDE2MyAtNjAyIDE3NCAtNjE2IDE2NiAtNjEwIGIgMTYxIC01OTggMTYxIC02MDEgMTYxIC02MDEgYiAyMTcgLTQwMiAxNjEgLTU4OSAxNzAgLTU2MiBiIDI3MiAtMjEzIDI0NyAtMjk4IDI3MiAtMjEzIGIgMjcyIC0yMTMgMjcyIC0yMTMgMjcyIC0yMTMgYiAyNjQgLTIxOSAyNzIgLTIxMyAyNjggLTIxNiBiIDE0MCAtMjYyIDIyNyAtMjQ3IDE4MiAtMjYyIGIgMzYgLTIyNiAxMDIgLTI2MiA2NSAtMjQ5IGIgMCAtMTQ1IDEyIC0yMDYgMCAtMTc2IGIgMTcgLTg0IDAgLTEyNCA1IC0xMDQgYiAxMDMgLTM4IDM4IC01NCA3MCAtMzggYiAxOTEgLTkxIDEzNyAtMzggMTcyIC01NiBiIDIwNSAtMTQxIDIwMSAtMTA2IDIwNSAtMTI0IGIgMTc4IC0yMTIgMjA1IC0xNjcgMTk2IC0xOTQgbCAxNzUgLTIxNSBsIDE4MiAtMjEzIGIgMzA3IC05MyAyMzYgLTE5OCAyODQgLTE1MSBiIDM3MiAxMjkgMzA4IC04OCAzNzIgMTI3IGIgMzcyIDEyOSAzNzIgMTI5IDM3MiAxMjkgYiAzNjQgMTIyIDM3MiAxMjkgMzY4IDEyNiBiIDI0MCA4MCAzMjggOTQgMjgzIDgwIGIgMTM3IDExNSAyMDIgODAgMTY2IDkxIGIgOTkgMTk0IDExMSAxMzYgOTkgMTY1IGIgMTg5IDMwMiA5OSAyNDQgMTMzIDI5MiBcIn0sXCJ2M2VcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQwNi45Njg3NSxcImhhXCI6NDE1LFwib1wiOlwibSAyMSAxODMgYiAyOCAxODMgMjQgMTgzIDI1IDE4MyBiIDQyIDE4MSAzNCAxODMgMzkgMTgzIGIgMTI3IDEwOCA0NyAxNzkgNDcgMTc5IGIgMjAyIDQxIDE2OCA3MiAyMDIgNDEgYiAyNzkgMTA4IDIwNCA0MSAyMzggNzIgYiAzNTcgMTc3IDMyMSAxNDUgMzU2IDE3NiBiIDM3NSAxODMgMzYzIDE4MSAzNzAgMTgzIGIgNDA2IDE1MSAzOTIgMTgzIDQwNiAxNjkgYiA0MDQgMTM3IDQwNiAxNDcgNDA1IDE0MSBiIDMyMiA2MiA0MDEgMTMxIDM5OCAxMjkgYiAyNTEgMCAyODQgMjcgMjUxIDAgYiAzMjIgLTYzIDI1MSAtMSAyODQgLTI5IGIgNDA0IC0xMzggMzk4IC0xMzAgNDAxIC0xMzMgYiA0MDYgLTE1MiA0MDUgLTE0MiA0MDYgLTE0OCBiIDM3NSAtMTg0IDQwNiAtMTcwIDM5MiAtMTg0IGIgMzU3IC0xNzkgMzcwIC0xODQgMzYzIC0xODMgYiAyNzkgLTEwOSAzNTYgLTE3NyAzMjEgLTE0NyBiIDIwMiAtNDMgMjM4IC03MyAyMDQgLTQzIGIgMTI3IC0xMDkgMjAyIC00MyAxNjggLTczIGIgNDkgLTE3OSA4NSAtMTQ3IDUwIC0xNzcgYiAzMSAtMTg0IDQzIC0xODMgMzYgLTE4NCBiIDAgLTE1MiAxMyAtMTg0IDAgLTE3MCBiIDIgLTEzOCAwIC0xNDggMCAtMTQyIGIgODMgLTYzIDUgLTEzMyA4IC0xMzAgYiAxNTUgMCAxMjIgLTI5IDE1NSAtMSBiIDgzIDYyIDE1NSAwIDEyMiAyNyBiIDggMTI5IDQzIDk3IDEwIDEyNyBiIDAgMTUxIDIgMTM2IDAgMTQ0IGIgMjEgMTgzIDAgMTY1IDggMTc3IFwifSxcInYzZlwiOntcInhfbWluXCI6LTI0LjUsXCJ4X21heFwiOjMxNy4xNDA2MjUsXCJoYVwiOjMyNCxcIm9cIjpcIm0gLTI0IC0xNDcgbCAtMjQgLTUgbCAtMjAgLTUgYiAtMSAtMTkgLTEyIC01IC00IC0xMSBiIDU4IC0xMjMgNiAtNDMgMzEgLTg2IGIgMTk2IC0yNzggOTMgLTE3MyAxMzQgLTIxOSBiIDMxNyAtNTcwIDI3NCAtMzU2IDMxNyAtNDYwIGIgMjk0IC03MTMgMzE3IC02MTcgMzA4IC02NjYgbCAyODkgLTcyNCBsIDI5NCAtNzM1IGIgMzE3IC04NzMgMzA4IC03ODAgMzE3IC04MjcgYiAyMzUgLTExMzIgMzE3IC05NjMgMjg4IC0xMDU0IGIgMjA5IC0xMTY1IDIyOCAtMTE0MCAyMjQgLTExNDYgYiAxODkgLTExNzcgMjA0IC0xMTcyIDE5NiAtMTE3NyBiIDE3MSAtMTE2NCAxODIgLTExNzcgMTc1IC0xMTcyIGIgMTY4IC0xMTU0IDE3MCAtMTE2MSAxNjggLTExNTkgYiAxODEgLTExMzIgMTY4IC0xMTQ5IDE3MiAtMTE0MiBiIDI2OSAtODkxIDIzOCAtMTA2NCAyNjkgLTk3NSBiIDI2OSAtODgxIDI2OSAtODg2IDI2OSAtODg0IGIgMjYyIC04MTQgMjY5IC04NTcgMjY1IC04MjcgYiAyNTggLTgwMCAyNjEgLTgxMSAyNTkgLTgwNiBiIDE0MiAtNjI4IDI0MCAtNzMxIDE5OCAtNjY3IGIgLTggLTU4OSAxMTIgLTYwNiA0NyAtNTg5IGIgLTIwIC01ODkgLTEzIC01ODkgLTE5IC01ODkgbCAtMjQgLTU4OSBsIC0yNCAtNDQ5IGwgLTI0IC0zMDggbCAtMjAgLTMwOCBiIC0xIC0zMjIgLTEyIC0zMDggLTQgLTMxMyBiIDU4IC00MjQgNiAtMzQ1IDMxIC0zODggYiAxOTQgLTU4MCA5MyAtNDc2IDEzNiAtNTIzIGIgMjU5IC02NjAgMjIxIC02MDYgMjQ1IC02MzUgYiAyNjEgLTY2MyAyNTkgLTY2MiAyNjEgLTY2MyBiIDI2NCAtNjU2IDI2MiAtNjYzIDI2MiAtNjYwIGIgMjY5IC01ODcgMjY4IC02MzIgMjY5IC02MTAgYiAyNjQgLTUyMSAyNjkgLTU2NiAyNjggLTU0NCBiIDI2MiAtNTEyIDI2NCAtNTE3IDI2MiAtNTEzIGIgMjU4IC00OTggMjYxIC01MDkgMjU5IC01MDMgYiAxNDIgLTMyNiAyNDAgLTQyOCAxOTggLTM2NSBiIC04IC0yODcgMTEyIC0zMDMgNDcgLTI4OCBiIC0yMCAtMjg3IC0xMyAtMjg3IC0xOSAtMjg3IGwgLTI0IC0yODcgbCAtMjQgLTE0NyBcIn0sXCJ2NDBcIjp7XCJ4X21pblwiOi0xLjM1OTM3NSxcInhfbWF4XCI6NDM2LjkyMTg3NSxcImhhXCI6NDQ2LFwib1wiOlwibSAyMTMgMjA1IGIgMjE3IDIwNSAyMTUgMjA1IDIxNiAyMDUgYiAyMzQgMTk0IDIyNCAyMDUgMjM0IDE5OSBiIDIzNiAxODcgMjM0IDE5NCAyMzUgMTkwIGwgMjQ1IDE2NyBsIDI2MSAxMjkgbCAyNzAgMTA2IGIgMzU1IC02MSAyOTQgNTQgMzI5IC0xMyBiIDQyMCAtMTYzIDM4MSAtMTA1IDQwMiAtMTM4IGIgNDM2IC0xODggNDM1IC0xODQgNDM2IC0xODQgYiA0MzYgLTE5MSA0MzYgLTE5MCA0MzYgLTE5MCBiIDQyMSAtMjA2IDQzNiAtMjAxIDQzMSAtMjA2IGwgNDIxIC0yMDYgbCA0MTYgLTIwNiBsIDQwNSAtMjAxIGIgMjE3IC0xNTggMzQ3IC0xNzIgMjgzIC0xNTggYiAzMSAtMjAxIDE1MyAtMTU4IDg4IC0xNzIgbCAyMCAtMjA2IGwgMTQgLTIwNiBsIDE0IC0yMDYgYiAwIC0xOTEgNSAtMjA2IDAgLTIwMSBiIC0xIC0xODggMCAtMTkwIC0xIC0xOTAgYiAxNCAtMTYzIC0xIC0xODYgMCAtMTg0IGIgOTUgLTM0IDM2IC0xMzYgNzIgLTc3IGIgMTY2IDEwNiAxMTkgOCAxNDggNjggbCAxNzUgMTI5IGwgMTgzIDE0OCBsIDIwMCAxODggYiAyMTMgMjA1IDIwNSAxOTkgMjA4IDIwMiBcIn0sXCJ2NDFcIjp7XCJ4X21pblwiOi0xLjM1OTM3NSxcInhfbWF4XCI6NTU2LjY4NzUsXCJoYVwiOjU2OCxcIm9cIjpcIm0gMjk0IDMyMiBiIDMxOCAzMjMgMjk5IDMyMiAzMDggMzIzIGIgMzYwIDMyMCAzMzQgMzIzIDM1MiAzMjIgYiA1MjYgMjE3IDQzMCAzMTAgNDkwIDI3MyBiIDU0MyAxNjYgNTM3IDIwMiA1NDMgMTg0IGIgNDQ3IDcwIDU0MyAxMTcgNTAzIDcwIGIgNDQ1IDcwIDQ0NyA3MCA0NDYgNzAgYiAzNTkgMTU5IDM5NCA3MiAzNTkgMTEzIGIgMzY4IDIwMSAzNTkgMTczIDM2MiAxODcgYiA0NDIgMjQ1IDM4MiAyMjkgNDEyIDI0NSBiIDQ1NSAyNDQgNDQ2IDI0NSA0NTEgMjQ1IGIgNDYwIDI0NCA0NTggMjQ0IDQ2MCAyNDQgYiA0NjAgMjQ0IDQ2MCAyNDQgNDYwIDI0NCBiIDQ1NCAyNDggNDYwIDI0NCA0NTggMjQ1IGIgMzI1IDI5MSA0MTcgMjc2IDM3MiAyOTEgYiAyODUgMjg3IDMxMyAyOTEgMjk5IDI5MCBiIDE0NCAtMiAxODMgMjY5IDE0NCAxOTAgYiAyODEgLTI5MCAxNDQgLTIwOCAxNzkgLTI4MCBiIDMwNCAtMjkxIDI4OSAtMjkxIDI5OCAtMjkxIGIgNTI0IC0xMDUgNDEyIC0yOTEgNTA2IC0yMTIgYiA1NDEgLTg0IDUyNiAtODggNTMwIC04NCBiIDU1NiAtMTAxIDU1MSAtODQgNTU2IC05MCBiIDU0OSAtMTM4IDU1NiAtMTExIDU1MyAtMTIyIGIgMzM0IC0zMjIgNTIxIC0yMzcgNDM1IC0zMTAgYiAzMDIgLTMyNCAzMjMgLTMyMyAzMTMgLTMyNCBiIDEzIC0xMDEgMTcyIC0zMjQgNTQgLTIzNCBiIC0xIC0xIDQgLTY4IC0xIC0zNCBiIDI5NCAzMjIgLTEgMTYxIDEyMSAzMDMgXCJ9LFwidjQyXCI6e1wieF9taW5cIjotMzQ4LjQzNzUsXCJ4X21heFwiOjI0LjUsXCJoYVwiOjI1LFwib1wiOlwibSAtMzMwIDE1NSBiIC0zMjIgMTU2IC0zMjkgMTU2IC0zMjYgMTU2IGIgLTMxNSAxNTYgLTMxOSAxNTYgLTMxNyAxNTYgYiAtMjk4IDE0NyAtMzExIDE1NSAtMzA4IDE1NCBiIC0xOSAzMCAtMjI0IDk4IC0xMjIgNTUgbCAyIDI2IGIgMjQgLTEgMTcgMjIgMjQgMTMgYiAyIC0yNyAyNCAtMTUgMTcgLTIzIGwgLTE5IC0zMSBiIC0yOTggLTE0OCAtMTIyIC01NiAtMjI0IC05OSBiIC0zMjIgLTE1OCAtMzEzIC0xNTggLTMxNSAtMTU4IGIgLTM0OCAtMTMxIC0zMzggLTE1OCAtMzQ4IC0xNDUgYiAtMzQ0IC0xMTcgLTM0OCAtMTI3IC0zNDcgLTEyMiBiIC0zMjggLTEwNCAtMzQxIC0xMTIgLTMzOCAtMTExIGIgLTEyNyAtOCAtMjY5IC02NSAtMjAyIC0zMyBiIC0xMDYgMCAtMTE1IC00IC0xMDYgLTEgYiAtMTI3IDYgLTEwNiAwIC0xMTUgMiBiIC0zMjggMTAyIC0yMDIgMzEgLTI2OSA2MyBiIC0zNDQgMTE2IC0zMzggMTA5IC0zNDEgMTExIGIgLTM0OCAxMzAgLTM0NyAxMjAgLTM0OCAxMjQgYiAtMzMwIDE1NSAtMzQ4IDE0MSAtMzQxIDE1MiBcIn0sXCJ2NDNcIjp7XCJ4X21pblwiOi00NDIuMzU5Mzc1LFwieF9tYXhcIjo0NDEsXCJoYVwiOjQ1MCxcIm9cIjpcIm0gLTMxIDQ4NyBiIC0xIDQ4OCAtMjEgNDg4IC0xMCA0ODggYiA0MzQgMTA0IDIxNiA0ODggMzk3IDMzMCBiIDQ0MSAyNyA0MzggNzkgNDQxIDQ3IGIgNDM5IDEyIDQ0MSAyMCA0MzkgMTUgYiA0MTkgMCA0MzUgNCA0MjcgMCBiIDQwNCA1IDQxMyAwIDQwOCAxIGIgMzk4IDMwIDQwMCAxMSAzOTggMTMgYiAwIDM1MSAzOTAgMjEzIDIxMyAzNTEgYiAtNTkgMzQ4IC0yMCAzNTEgLTM5IDM0OSBiIC00MDAgMzAgLTI1MSAzMjQgLTM5MyAxOTEgYiAtNDA1IDUgLTQwMCAxMyAtNDAxIDExIGIgLTQyMCAwIC00MDkgMSAtNDE1IDAgYiAtNDQxIDEyIC00MjggMCAtNDM2IDQgYiAtNDQyIDI3IC00NDEgMTUgLTQ0MiAyMCBiIC00MzUgMTA0IC00NDIgNDcgLTQzOSA3OSBiIC0zMSA0ODcgLTQwMSAzMTYgLTIzNSA0NzQgbSAtMTMgMTMxIGIgLTEgMTMzIC05IDEzMyAtNSAxMzMgYiA1MSAxMDUgMTkgMTMzIDM5IDEyMyBiIDYxIDcwIDU4IDk1IDYxIDgzIGIgNTEgMzQgNjEgNTggNTggNDUgYiAtMSA2IDM5IDE2IDE5IDYgYiAtNDYgMjcgLTE3IDYgLTM0IDEzIGIgLTYyIDY5IC01NyAzOCAtNjIgNTQgYiAtMTMgMTMxIC02MiA5OCAtNDQgMTI0IFwifSxcInY0NFwiOntcInhfbWluXCI6LTIxLjc4MTI1LFwieF9tYXhcIjoyNTEuODEyNSxcImhhXCI6MjU3LFwib1wiOlwibSAtOCA2MzEgYiAtMSA2MzIgLTYgNjMyIC00IDYzMiBiIDE5IDYyMCA4IDYzMiAxNiA2MjggYiAyMCAzODMgMjAgNjE2IDIwIDYxNiBsIDIwIDE0OCBsIDIxIDE1MSBiIDEzNyAxOTkgNTkgMTgzIDk5IDE5OSBiIDE4MiAxOTEgMTUyIDE5OSAxNjcgMTk3IGIgMjUxIDg0IDIyNyAxNzYgMjUxIDEzNCBiIDIyOCAwIDI1MSA1OCAyNDMgMjkgYiAxMDAgLTE0MiAyMDYgLTQwIDE3OCAtNzIgbCAyMyAtMjE1IGIgMCAtMjI5IDkgLTIyOSA2IC0yMjkgYiAtMjAgLTIxNiAtOSAtMjI5IC0xNyAtMjI0IGwgLTIxIC0yMTIgbCAtMjEgMjAxIGwgLTIxIDYxNiBsIC0yMCA2MjAgYiAtOCA2MzEgLTE3IDYyNCAtMTMgNjMwIG0gMTEwIDEzMSBiIDk2IDEzMyAxMDYgMTMzIDEwMCAxMzMgYiA4OSAxMzMgOTMgMTMzIDkxIDEzMyBiIDI0IDg3IDYzIDEyOSA0MCAxMTMgbCAyMCA4MCBsIDIwIC0zNyBsIDIwIC0xNTYgbCAyMyAtMTUyIGIgMTQ0IDgxIDk2IC03MiAxNDQgMjAgbCAxNDQgODMgYiAxMTAgMTMxIDE0NCAxMTMgMTM0IDEyNiBcIn0sXCJ2NDVcIjp7XCJ4X21pblwiOi00MDIuODkwNjI1LFwieF9tYXhcIjo0MDEuNTMxMjUsXCJoYVwiOjQxMCxcIm9cIjpcIm0gLTEwIDI3MyBiIC00IDI3NCAtOSAyNzMgLTYgMjc0IGIgMTYgMjYyIDQgMjc0IDEyIDI2OSBiIDE3IDE1OCAxNyAyNTkgMTcgMjU5IGwgMTcgNTYgbCA2MiAxMTIgYiAxMTcgMTc0IDExMCAxNzIgMTEwIDE3MiBiIDEyMiAxNzQgMTE4IDE3NCAxMTkgMTc0IGIgMTMyIDE3MyAxMjUgMTc0IDEyOSAxNzMgYiAyOTUgMTEgMTM0IDE3MiAxNzEgMTM0IGwgMzA3IC0xIGwgMzM2IDM0IGIgMzc0IDc2IDM2NiA3MiAzNjggNzQgYiAzODEgNzcgMzc1IDc3IDM3OCA3NyBiIDQwMSA1NiAzOTIgNzcgNDAxIDY4IGIgNDAwIDQ4IDQwMSA1NCA0MDEgNTEgYiAyMjMgLTE3MiAzOTcgNDEgMjMwIC0xNjYgYiAyMTAgLTE3NiAyMjAgLTE3NCAyMTUgLTE3NiBiIDIwMSAtMTc0IDIwNiAtMTc2IDIwNCAtMTc2IGIgMTEyIC04NyAxOTggLTE3MyAxNzggLTE1MiBiIDI3IDAgNjUgLTM4IDI3IDAgYiAyMSAtNiAyNyAwIDI0IC0yIGwgMTcgLTEyIGwgMTcgLTE0NyBiIDE3IC0yMTAgMTcgLTE3MyAxNyAtMTk0IGIgMTAgLTI5MiAxNyAtMjk3IDE2IC0yODcgYiAtMiAtMjk5IDYgLTI5NyAyIC0yOTkgYiAtMjEgLTI4NyAtMTAgLTI5OSAtMTkgLTI5NSBiIC0yNCAtMTc0IC0yMyAtMjg0IC0yMyAtMjg0IGwgLTI0IC02MyBsIC02NiAtMTE3IGIgLTEyMSAtMTc2IC0xMTAgLTE3MCAtMTE0IC0xNzYgYiAtMTI1IC0xNzYgLTEyMiAtMTc2IC0xMjMgLTE3NiBiIC0yOTYgLTEyIC0xMzQgLTE3NCAtMTI1IC0xODQgbCAtMzA4IDAgbCAtMzM3IC0zNCBiIC0zNzUgLTc3IC0zNjcgLTczIC0zNzAgLTc2IGIgLTM4MiAtNzkgLTM3NyAtNzkgLTM3OSAtNzkgYiAtNDAyIC01OCAtMzkzIC03OSAtNDAyIC02OSBiIC00MDEgLTQ5IC00MDIgLTU1IC00MDIgLTUyIGIgLTIyNCAxNzAgLTM5OCAtNDMgLTIzMSAxNjUgYiAtMjEyIDE3NCAtMjIxIDE3MyAtMjE2IDE3NCBiIC0yMDIgMTczIC0yMDggMTc0IC0yMDUgMTc0IGIgLTM5IDExIC0yMDAgMTcyIC0xNTEgMTIyIGwgLTI4IC0xIGwgLTI1IDEgbCAtMjQgNCBsIC0yNCAxMzAgYiAtMjMgMjYwIC0yNCAyNTYgLTI0IDI1OCBiIC0xMCAyNzMgLTIwIDI2NiAtMTYgMjcwIFwifSxcInY0NlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjI3LjQ2ODc1LFwiaGFcIjo2NDAsXCJvXCI6XCJtIDMwNiAxOTAgYiAzMTQgMTkxIDMwOCAxOTEgMzExIDE5MSBiIDMyNiAxODQgMzE4IDE5MSAzMjIgMTkwIGwgMzM2IDE3MyBiIDUxMCA1MiAzNzcgMTI3IDQ0MiA4MCBiIDUxNSA0OSA1MTMgNTEgNTE1IDQ5IGIgNjExIDE2IDUzNyA0MCA1NzkgMjQgYiA2MjcgMCA2MjQgMTMgNjI3IDkgYiA2MDcgLTE4IDYyNyAtMTEgNjI0IC0xMyBiIDMzMCAtMTgxIDQ5MCAtNDkgMzg5IC0xMDkgYiAzMTQgLTE5MiAzMjMgLTE5MCAzMTkgLTE5MiBiIDMwNiAtMTkxIDMxMSAtMTkyIDMwOCAtMTkyIGIgMjk0IC0xNzcgMzAyIC0xODggMzAyIC0xODggYiAyNTcgLTE0MCAyODcgLTE3MCAyNjUgLTE0OCBiIDE5IC0xOCAxOTMgLTg0IDExNCAtNDQgYiAwIDAgMiAtMTMgMCAtMTEgYiAxNiAxNiAwIDkgMiAxMyBiIDExMCA0OSA0NyAyNCA4OSA0MCBiIDExNyA1MiAxMTEgNDkgMTE0IDUxIGIgMTQ1IDY1IDEyNiA1NiAxMzAgNTggYiAyODEgMTYzIDIwMCA5MyAyNDUgMTI0IGIgMzAwIDE4NiAyODggMTcwIDI5MSAxNzQgYiAzMDYgMTkwIDMwMCAxODcgMzAzIDE4OCBtIDMxNyAxMzcgYiAzMTMgMTQyIDMxNSAxNDEgMzE0IDE0MiBiIDMwOCAxMzcgMzEzIDE0MiAzMTEgMTQxIGIgMTYxIDQgMjc2IDg0IDIyMCAzMyBiIDE1NSAwIDE1OSAxIDE1NSAwIGIgMTYzIC00IDE1NSAwIDE1OSAtMiBiIDMwOCAtMTM4IDIyMCAtMzQgMjc2IC04NCBiIDMxMyAtMTQyIDMxMSAtMTQxIDMxMyAtMTQyIGIgMzE3IC0xMzggMzE0IC0xNDIgMzE1IC0xNDEgYiA0NjQgLTQgMzUxIC04NCA0MDYgLTM0IGIgNDcwIDAgNDY4IC0yIDQ3MCAwIGIgNDY0IDQgNDcwIDAgNDY4IDEgYiAzMTcgMTM3IDQwNiAzMyAzNTEgODQgXCJ9LFwidjQ3XCI6e1wieF9taW5cIjotMjQuNSxcInhfbWF4XCI6MzE1Ljc4MTI1LFwiaGFcIjozMjIsXCJvXCI6XCJtIC0yNCAtMTQ1IGwgLTI0IC01IGwgLTIwIC01IGIgMSAtMjYgLTEwIC01IC02IC05IGIgMTc1IC0yNDEgMzEgLTg2IDk2IC0xNjYgYiAzMTQgLTU0OCAyNTkgLTMyMyAzMDQgLTQyMCBiIDMxNSAtNTg5IDMxNSAtNTU1IDMxNSAtNTcxIGIgMzE0IC02MzAgMzE1IC02MDYgMzE1IC02MjMgYiAyOTggLTczMCAzMTEgLTY2NCAzMDYgLTY5OSBsIDI5NSAtNzQyIGwgMjk2IC03NDggYiAzMTQgLTg1MCAzMDQgLTc3OCAzMTEgLTgxMyBiIDMxNSAtODkyIDMxNSAtODU3IDMxNSAtODc0IGIgMzE0IC05MzIgMzE1IC05MDkgMzE1IC05MjUgYiAyOTggLTEwMzIgMzExIC05NjcgMzA2IC0xMDAyIGwgMjk1IC0xMDQ1IGwgMjk2IC0xMDUwIGIgMzE0IC0xMTUzIDMwNCAtMTA4MSAzMTEgLTExMTUgYiAzMTUgLTExOTMgMzE1IC0xMTYwIDMxNSAtMTE3NyBiIDMxNCAtMTIzNSAzMTUgLTEyMTEgMzE1IC0xMjI4IGIgMjE3IC0xNTI2IDMwNiAtMTMzOCAyNzAgLTE0NDQgYiAyMDEgLTE1MzMgMjEzIC0xNTMyIDIwOCAtMTUzMyBiIDE4MiAtMTUyMiAxOTMgLTE1MzMgMTg1IC0xNTI5IGIgMTc5IC0xNTE0IDE4MSAtMTUxOCAxNzkgLTE1MTcgYiAxODkgLTE0ODkgMTc5IC0xNTA4IDE4MiAtMTUwMSBiIDI2NiAtMTIxNyAyNDAgLTE0MDMgMjY2IC0xMzA4IGIgMjYyIC0xMTU2IDI2NiAtMTE5NiAyNjUgLTExNzcgYiAxMTAgLTkwNyAyNDcgLTEwNDMgMTkwIC05NTAgYiAwIC04ODkgODcgLTg5NSA1MCAtODg5IGwgLTEgLTg4OSBsIC0yNCAtODg5IGwgLTI0IC03NDkgbCAtMjQgLTYxMCBsIC0yMCAtNjEwIGIgMSAtNjMxIC0xMCAtNjEwIC02IC02MTQgYiAxNzUgLTg0NiAzMSAtNjkxIDk2IC03NzEgYiAyNTkgLTk1NiAyMTMgLTg4NCAyMzYgLTkxNCBiIDI2NSAtOTY2IDI2MiAtOTYxIDI2NCAtOTY2IGIgMjY1IC05NjYgMjY1IC05NjYgMjY1IC05NjYgYiAyNjUgLTk1MyAyNjUgLTk2NCAyNjUgLTk1OSBiIDI2NiAtOTIwIDI2NiAtOTQzIDI2NiAtOTMyIGIgMjYyIC04NTMgMjY2IC04OTggMjY1IC04NzMgYiAxMTAgLTYwNSAyNDcgLTc0MSAxOTAgLTY0OCBiIDAgLTU4NyA4NyAtNTkyIDUwIC01ODcgbCAtMSAtNTg3IGwgLTI0IC01ODcgbCAtMjQgLTQ0OCBsIC0yNCAtMzA4IGwgLTIwIC0zMDggYiAxIC0zMjggLTEwIC0zMDggLTYgLTMxMiBiIDE3NSAtNTQ0IDMxIC0zODggOTYgLTQ2OSBiIDI1OSAtNjU1IDIxMyAtNTgxIDIzNiAtNjEyIGIgMjY1IC02NjMgMjYyIC02NTkgMjY0IC02NjMgYiAyNjUgLTY2MyAyNjUgLTY2MyAyNjUgLTY2MyBiIDI2NSAtNjUwIDI2NSAtNjYzIDI2NSAtNjU3IGIgMjY2IC02MTcgMjY2IC02NDEgMjY2IC02MzAgYiAyNjIgLTU1MSAyNjYgLTU5NSAyNjUgLTU3MCBiIDExMCAtMzAzIDI0NyAtNDM4IDE5MCAtMzQ1IGIgMCAtMjg0IDg3IC0yOTAgNTAgLTI4NCBsIC0xIC0yODQgbCAtMjQgLTI4NCBsIC0yNCAtMTQ1IFwifSxcInY0OVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjMwLjIwMzEyNSxcImhhXCI6NjQzLFwib1wiOlwibSAzMDggMjA0IGIgMzE0IDIwNSAzMTAgMjA1IDMxMyAyMDUgYiAzMjYgMjAxIDMxOSAyMDUgMzIzIDIwNCBiIDM1NSAxNTQgMzI4IDE5OSAzMzggMTgwIGIgNDAxIDgzIDM2MiAxNDIgMzkyIDk1IGwgNDA5IDcyIGIgNDMxIDQxIDQxMiA2NiA0MjQgNDkgYiA2MTkgLTE3NCA0OTggLTUxIDU3MCAtMTM0IGIgNjMwIC0xOTIgNjI2IC0xODAgNjMwIC0xODYgYiA2MjYgLTIwMiA2MzAgLTE5NSA2MjggLTE5OSBiIDYxNiAtMjA2IDYyMyAtMjA1IDYyMCAtMjA2IGIgNTUyIC0xODggNjA4IC0yMDYgNTkyIC0yMDIgYiAzMTAgLTE1NSA0ODggLTE2OSAzOTIgLTE1NSBiIDI2OCAtMTU2IDI5NSAtMTU1IDI4MSAtMTU1IGIgNzcgLTE4OCAxOTcgLTE2MSAxMjYgLTE3MyBiIDEzIC0yMDYgMzUgLTIwMiAyMCAtMjA2IGIgOSAtMjA2IDEyIC0yMDYgMTAgLTIwNiBiIDAgLTE5MSAyIC0yMDIgMCAtMTk3IGIgOCAtMTc2IDAgLTE4NiAyIC0xODAgYiAyMDQgNDkgNTggLTEzNiAxMzggLTQzIGwgMjIwIDcyIGwgMjI3IDgzIGIgMjk1IDE4OCAyNDUgMTA4IDI4MSAxNjYgYiAzMDggMjA0IDI5OSAxOTcgMzA0IDIwMiBtIDMxNSAxNDcgYiAzMTQgMTQ3IDMxNSAxNDcgMzE0IDE0NyBiIDMxNCAxNDcgMzE0IDE0NyAzMTQgMTQ3IGIgMzA2IDEyOSAzMTQgMTQ1IDMxMCAxMzggbCAyOTYgMTA1IGIgMjgxIDcyIDI5MiA5NyAyODQgNzcgbCAyNzQgNTYgYiAxODEgLTEyMyAyNDcgLTQgMjEyIC03MiBsIDE3NCAtMTM0IGwgMTc2IC0xMzMgYiAzMTQgLTEyMyAyMTUgLTEyNyAyNzIgLTEyMyBiIDQ1MSAtMTMzIDM1NiAtMTIzIDQxMyAtMTI3IGwgNDU0IC0xMzQgbCA0NDkgLTEyMyBiIDM1MyA1NiA0MTcgLTcyIDM4MSAtNCBsIDM0NyA3MiBiIDMzMiAxMDUgMzQ0IDc3IDMzNiA5NyBsIDMyMiAxMjkgYiAzMTUgMTQ3IDMxOCAxMzggMzE1IDE0NSBcIn0sXCJ2NGFcIjp7XCJ4X21pblwiOjcwLjc4MTI1LFwieF9tYXhcIjozNzguMzkwNjI1LFwiaGFcIjozMTUsXCJvXCI6XCJtIDI0NiAzNzMgYiAyNTQgMzczIDI0OSAzNzMgMjUxIDM3MyBiIDM3MiAzMjQgMzAzIDM3MyAzNjAgMzUxIGIgMzc4IDMwMiAzNzcgMzE3IDM3OCAzMDkgYiAzMzggMjUxIDM3OCAyNzggMzYyIDI1NSBiIDMyOCAyNDkgMzM0IDI0OSAzMzIgMjQ5IGIgMjgzIDI5NCAzMDMgMjQ5IDI4MyAyNzAgYiAyODggMzE1IDI4MyAzMDEgMjg0IDMwOCBiIDI4OSAzMTkgMjg5IDMxNyAyODkgMzE5IGIgMjg5IDMxOSAyODkgMzE5IDI4OSAzMTkgYiAyODMgMzIwIDI4OSAzMjAgMjg3IDMyMCBiIDI3MCAzMjIgMjc5IDMyMiAyNzQgMzIyIGIgMjA2IDI4OCAyNDIgMzIyIDIxNSAzMDggYiAyMDYgMjgzIDIwNiAyODcgMjA2IDI4NSBiIDI1NyAyMjMgMjA2IDI2NyAyMzAgMjM4IGIgMjg0IDIwNiAyNzIgMjEzIDI3NyAyMTAgYiAzNTEgOTAgMzI4IDE3MyAzNTEgMTMwIGIgMzQwIDQ3IDM1MSA3NCAzNDggNTkgYiAyMDUgLTMwIDMxNCAtMiAyNjQgLTMwIGIgMTgyIC0yOSAxOTggLTMwIDE5MCAtMzAgYiA4NCAxNSAxNDcgLTI0IDEwMyAtNSBiIDcwIDQ4IDc0IDI0IDcwIDM2IGIgMTA4IDk5IDcwIDcwIDg1IDk0IGIgMTIxIDEwMiAxMTIgMTAxIDExNyAxMDIgYiAxNjcgNTYgMTQ3IDEwMiAxNjcgODAgYiAxNTkgMzEgMTY3IDQ4IDE2NCA0MCBsIDE1NiAyNiBsIDE1NyAyNiBiIDE5MCAyMCAxNjcgMjIgMTc4IDIwIGIgMjIwIDI2IDIwMSAyMCAyMTIgMjIgYiAyNTggNjUgMjQzIDM0IDI1OCA1MSBiIDI1NyA3MCAyNTggNjYgMjU4IDY5IGIgMjA0IDEyNiAyNDkgOTQgMjM0IDEwOSBiIDExNCAyNTggMTQ4IDE1OCAxMTQgMjA5IGIgMTI1IDMwMiAxMTQgMjczIDExOCAyODggYiAyNDYgMzczIDE0NyAzNDIgMTkzIDM3MCBcIn0sXCJ2NGJcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjUwMy42MDkzNzUsXCJoYVwiOjUxNCxcIm9cIjpcIm0gMjc0IDQzMCBiIDI3NyA0MzAgMjc2IDQzMCAyNzcgNDMwIGIgMzEwIDM5NCAyOTYgNDMwIDMxMCA0MTUgYiAzMDggMzgzIDMxMCAzOTEgMzA4IDM4NyBiIDMwNiAzNjcgMzA3IDM4MSAzMDcgMzc0IGIgMjM2IDEyMCAyOTggMzA1IDI3MiAyMTAgYiA0MCAtMjczIDE4OSAtNSAxMjUgLTEzNCBiIDIwIC0yODcgMzUgLTI4MyAyNyAtMjg3IGIgNSAtMjgxIDE0IC0yODcgOSAtMjg1IGIgMCAtMjY3IDEgLTI3NyAwIC0yNzMgYiA5IC0yNDIgMCAtMjYyIDIgLTI1NSBiIDI0NiAzOTUgMTM3IC0xMiAyMzIgMjQyIGIgMjc0IDQzMCAyNDkgNDE2IDI1NyA0MjcgbSA0NjggNDMwIGIgNDcyIDQzMCA0NjkgNDMwIDQ3MCA0MzAgYiA1MDMgMzk0IDQ5MCA0MzAgNTAzIDQxNSBiIDUwMiAzODMgNTAzIDM5MSA1MDMgMzg3IGIgNDk5IDM2NyA1MDIgMzgxIDUwMCAzNzQgYiA0MzEgMTIwIDQ5MSAzMDUgNDY1IDIxMCBiIDIzNCAtMjczIDM4MiAtNSAzMTggLTEzNCBiIDIxMyAtMjg3IDIyOCAtMjgzIDIyMCAtMjg3IGIgMTk4IC0yODEgMjA4IC0yODcgMjAyIC0yODUgYiAxOTMgLTI2NyAxOTQgLTI3NyAxOTMgLTI3MyBiIDIwMiAtMjQyIDE5MyAtMjYyIDE5NiAtMjU1IGIgNDM5IDM5NSAzMzAgLTEyIDQyNiAyNDIgYiA0NjggNDMwIDQ0MiA0MTYgNDUxIDQyNyBcIn0sXCJ2NGRcIjp7XCJ4X21pblwiOi0zMTEuNjg3NSxcInhfbWF4XCI6MzEwLjMyODEyNSxcImhhXCI6MzE3LFwib1wiOlwibSAtOSAzODggYiAtMiAzOTAgLTggMzkwIC01IDM5MCBiIDUgMzg4IDEgMzkwIDQgMzkwIGIgMTkgMzc4IDEwIDM4NyAxNiAzODMgYiAyMyAzMzMgMjMgMzcxIDIzIDM3MSBiIDI0IDI5OCAyMyAyOTkgMjQgMjk4IGIgODEgMjc2IDM0IDI5OCA2NSAyODUgYiAyMTMgOTEgMTQ1IDI0MCAxOTAgMTc3IGIgMjI0IDI0IDIxNyA3NiAyMjQgMzYgYiAyNTcgMjQgMjI0IDI0IDIzNSAyNCBiIDI5OSAxOSAyOTIgMjQgMjkyIDI0IGIgMzEwIC0xIDMwNiAxNSAzMTAgNiBiIDI5OSAtMjMgMzEwIC0xMSAzMDYgLTE5IGIgMjU3IC0yNyAyOTIgLTI3IDI5MiAtMjcgYiAyMjQgLTI5IDIzNSAtMjcgMjI0IC0yOSBiIDIxMyAtOTUgMjI0IC00MCAyMTcgLTgwIGIgODEgLTI4MCAxOTAgLTE4MSAxNDUgLTI0NCBiIDI0IC0zMDEgNjUgLTI5MCAzNCAtMzAxIGIgMjMgLTMzNSAyNCAtMzAxIDIzIC0zMDMgbCAyMyAtMzQwIGIgMTcgLTM4MSAyMyAtMzc0IDIzIC0zNzQgYiAtMSAtMzkxIDEzIC0zODggNSAtMzkxIGIgLTIxIC0zODEgLTkgLTM5MSAtMTcgLTM4OCBiIC0yNyAtMzQwIC0yNyAtMzc0IC0yNyAtMzc0IGwgLTI3IC0zMzUgYiAtMjggLTMwMSAtMjcgLTMwMyAtMjcgLTMwMSBiIC04NSAtMjgwIC0zOCAtMzAxIC02OSAtMjkwIGIgLTIxNyAtOTUgLTE0OSAtMjQ0IC0xOTQgLTE4MSBiIC0yMjggLTI5IC0yMjEgLTgwIC0yMjggLTQwIGIgLTI1OSAtMjcgLTIyOCAtMjkgLTIzOCAtMjcgYiAtMzAwIC0yMyAtMjk0IC0yNyAtMjk0IC0yNyBiIC0zMTEgLTIgLTMwNyAtMTkgLTMxMSAtMTEgYiAtMjk0IDIzIC0zMTEgOCAtMzA0IDE5IGIgLTI1OSAyNCAtMjkxIDIzIC0yODQgMjQgYiAtMjI4IDI0IC0yMzkgMjQgLTIyOCAyNCBiIC0yMTcgOTEgLTIyOCAzNiAtMjIxIDc2IGIgLTg1IDI3NiAtMTk0IDE3NyAtMTQ5IDI0MCBiIC0yOCAyOTggLTY5IDI4NSAtMzggMjk4IGIgLTI3IDMzMyAtMjcgMjk4IC0yNyAyOTkgYiAtMjcgMzcxIC0yNyAzNjIgLTI3IDM2OSBiIC05IDM4OCAtMjQgMzc4IC0xNyAzODUgbSAtMjcgMTM2IGIgLTI4IDI0NyAtMjcgMTk3IC0yOCAyNDcgYiAtNjEgMjE2IC0zMSAyNDcgLTUzIDIyNiBiIC0xMjMgMzMgLTk1IDE3MiAtMTIxIDk4IGwgLTEyNSAyNCBsIC03NiAyNCBsIC0yNyAyNCBsIC0yNyAxMzYgbSAyOSAyNDIgYiAyNCAyNDcgMjcgMjQ1IDI0IDI0NyBiIDIzIDEzNiAyNCAyNDcgMjMgMTk3IGwgMjMgMjQgbCA3MiAyNCBsIDEyMSAyNCBsIDExOSAzMyBiIDI5IDI0MiAxMTUgMTE2IDc3IDIwNiBtIC0yNyAtMTQwIGwgLTI3IC0yNyBsIC03NiAtMjcgbCAtMTI1IC0yNyBsIC0xMjMgLTM2IGIgLTYxIC0yMjAgLTEyMSAtMTAyIC05NSAtMTc2IGIgLTI4IC0yNTEgLTUzIC0yMzAgLTMxIC0yNTEgYiAtMjcgLTE0MCAtMjggLTI1MSAtMjcgLTIwMSBtIDExOSAtMzYgbCAxMjEgLTI3IGwgNzIgLTI3IGwgMjMgLTI3IGwgMjMgLTE0MCBiIDI0IC0yNTEgMjMgLTIwMSAyNCAtMjUxIGIgNTcgLTIyMCAyNyAtMjUxIDQ5IC0yMzAgYiAxMTkgLTM2IDkxIC0xNzYgMTE3IC0xMDIgXCJ9LFwidjRlXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoyMzkuNTYyNSxcImhhXCI6MjQ0LFwib1wiOlwibSAxMCA0NjAgYiAyMCA0NjIgMTMgNDYyIDE0IDQ2MiBiIDM5IDQ0OSAyOCA0NjIgMzUgNDU4IGwgNDAgNDQ2IGwgNDAgMzI2IGIgNDAgMjA1IDQwIDI1OSA0MCAyMDUgYiAxMjcgMjI3IDQwIDIwNSA4MCAyMTUgYiAyMjAgMjQ5IDE5NiAyNDQgMjEzIDI0OSBiIDIyNyAyNDcgMjI0IDI0OSAyMjUgMjQ4IGIgMjM4IDIzNyAyMzEgMjQ1IDIzNSAyNDEgbCAyMzkgMjMzIGwgMjM5IC0xMDYgbCAyMzkgLTQ0OCBsIDIzOCAtNDUxIGIgMjE5IC00NjMgMjM0IC00NTkgMjI1IC00NjMgYiAxOTggLTQ1MSAyMTAgLTQ2MyAyMDIgLTQ1OSBsIDE5NyAtNDQ4IGwgMTk3IC0zMjQgYiAxOTcgLTIwMSAxOTcgLTI0OCAxOTcgLTIwMSBiIDExMCAtMjIzIDE5NiAtMjAxIDE1NyAtMjEwIGIgMTcgLTI0NSA0MiAtMjQwIDI0IC0yNDUgYiAxMCAtMjQyIDEzIC0yNDUgMTMgLTI0NCBiIDAgLTIzMyA2IC0yNDEgMiAtMjM3IGwgMCAtMjMwIGwgMCAxMDggbCAwIDQ0NiBsIDAgNDQ5IGIgMTAgNDYwIDIgNDUzIDYgNDU4IG0gMTk3IDIyIGIgMTk3IDcwIDE5NyA0MSAxOTcgNTggYiAxOTYgMTE2IDE5NyAxMTMgMTk3IDExNiBsIDE5NiAxMTYgYiAxMTggOTcgMTk2IDExNiAxNjAgMTA2IGwgNDAgNzcgbCA0MCAtMTggYiA0MCAtMTEyIDQwIC02OSA0MCAtMTEyIGwgMTE5IC05MyBsIDE5NyAtNzMgbCAxOTcgMjIgXCJ9LFwidjUxXCI6e1wieF9taW5cIjotMS4zNTkzNzUsXCJ4X21heFwiOjQ1NS45Njg3NSxcImhhXCI6NDY1LFwib1wiOlwibSAzNTIgNTQxIGIgMzU3IDU0MiAzNTMgNTQyIDM1NSA1NDIgYiAzNzcgNTMwIDM2NCA1NDIgMzcyIDUzNyBsIDM3OCA1MjYgbCAzNzggMzk0IGwgMzc5IDI2MiBsIDQwNCAyNjYgYiA0MzYgMjcwIDQyMCAyNjkgNDMwIDI3MCBiIDQ1MCAyNjUgNDQzIDI3MCA0NDYgMjY5IGIgNDU1IDIyMCA0NTUgMjU5IDQ1NSAyNjAgbCA0NTUgMjA4IGwgNDU1IDE2MSBsIDQ1NCAxNTYgYiA0MTEgMTQwIDQ0OSAxNDcgNDQ3IDE0NyBiIDM3OCAxMzMgMzkzIDEzNyAzNzkgMTM0IGIgMzc4IDY4IDM3OCAxMzMgMzc4IDEwNiBiIDM3OCAyMiAzNzggNTQgMzc4IDM4IGwgMzc5IC04NyBsIDQwNCAtODMgYiA0MzYgLTc5IDQyMCAtODAgNDMwIC03OSBiIDQ1MCAtODQgNDQzIC03OSA0NDYgLTgwIGIgNDU1IC0xMjkgNDU1IC05MCA0NTUgLTg4IGwgNDU1IC0xNDEgbCA0NTUgLTE4OCBsIDQ1NCAtMTkyIGIgNDEzIC0yMDkgNDQ5IC0yMDIgNDQ3IC0yMDIgYiAzODIgLTIxNSAzOTggLTIxMiAzODMgLTIxNSBsIDM3OCAtMjE1IGwgMzc4IC0zNDUgbCAzNzggLTM4MCBiIDM3NSAtNDg1IDM3OCAtNDg0IDM3OCAtNDgwIGIgMzU3IC00OTQgMzcxIC00OTEgMzY0IC00OTQgYiAzNDAgLTQ4NSAzNTEgLTQ5NCAzNDQgLTQ5MSBiIDMzNiAtMzgzIDMzNyAtNDgwIDMzNiAtNDg0IGwgMzM2IC0zNDkgbCAzMzYgLTIyMyBsIDMzNCAtMjIzIGIgMjkxIC0yMzEgMzM0IC0yMjMgMzE0IC0yMjcgbCAyNDcgLTI0MCBsIDI0NyAtMzcxIGwgMjQ2IC01MDMgbCAyNDUgLTUwNiBiIDIyNSAtNTE5IDI0MiAtNTE0IDIzNCAtNTE5IGIgMjA2IC01MDYgMjE5IC01MTkgMjEwIC01MTQgbCAyMDUgLTUwMyBsIDIwNSAtMzc2IGwgMjA1IC0yNDggbCAxNjAgLTI1NiBsIDExNSAtMjY1IGwgMTE1IC0zOTYgbCAxMTUgLTUyNyBsIDExNCAtNTMxIGIgOTUgLTU0NCAxMTAgLTUzOSAxMDIgLTU0NCBiIDc2IC01MzEgODcgLTU0NCA3OCAtNTM5IGwgNzMgLTUyNyBsIDczIC0zOTkgYiA3MyAtMjczIDczIC0zMzAgNzMgLTI3MyBiIDQ5IC0yNzcgNzMgLTI3MyA2MSAtMjc0IGIgMTcgLTI4MSAzMiAtMjgwIDI0IC0yODEgYiA0IC0yNzYgMTAgLTI4MSA4IC0yODAgYiAtMSAtMjM0IDAgLTI2OSAtMSAtMjcyIGIgMCAtMjE5IC0xIC0yMjkgMCAtMjI0IGwgMCAtMTcwIGwgMSAtMTY3IGIgMTAgLTE1OCAyIC0xNjMgNiAtMTU5IGIgNDkgLTE0OSAxMyAtMTU2IDE2IC0xNTUgbCA3MyAtMTQ1IGwgNzMgLTM0IGIgNzMgNzYgNzMgMjYgNzMgNzYgYiA0OSA3MiA3MyA3NiA2MSA3NCBiIDE3IDY4IDMyIDY5IDI0IDY4IGIgNCA3MyAxMCA2OCA4IDY5IGIgLTEgMTE1IDAgODAgLTEgNzcgYiAwIDEzMCAtMSAxMjAgMCAxMjQgbCAwIDE3OSBsIDEgMTgxIGIgMTAgMTkxIDIgMTg2IDYgMTkwIGIgNDkgMTk5IDEzIDE5MiAxNiAxOTQgbCA3MyAyMDQgbCA3MyAzMzggYiA3MyAzNzQgNzMgMzUyIDczIDM2NSBiIDc3IDQ4MyA3MyA0ODQgNzMgNDc3IGIgOTUgNDkyIDgxIDQ4OSA4OCA0OTIgYiAxMTEgNDgzIDEwMCA0OTIgMTA3IDQ4OSBiIDExNSAzNzggMTE1IDQ3NyAxMTUgNDgzIGwgMTE1IDM0MiBiIDExNyAyMTIgMTE1IDIyMyAxMTUgMjEyIGIgMjA0IDIyOSAxMTcgMjEyIDIwMCAyMjcgbCAyMDUgMjI5IGwgMjA1IDM2NSBsIDIwNSA1MDIgbCAyMDYgNTA1IGIgMjI1IDUxNyAyMTAgNTEzIDIxOSA1MTcgYiAyNDUgNTA1IDIzNCA1MTcgMjQyIDUxMyBsIDI0NiA1MDIgbCAyNDcgMzY5IGwgMjQ3IDIzNyBsIDI0OSAyMzcgYiAzMzYgMjU0IDI1MyAyMzggMzM2IDI1NCBiIDMzNyAzOTAgMzM2IDI1NCAzMzcgMzAyIGwgMzM3IDUyNiBsIDMzOCA1MzAgYiAzNTIgNTQxIDM0MSA1MzUgMzQ3IDUzOSBtIDMzNiAxNSBiIDMzNiAxMjYgMzM2IDEwMiAzMzYgMTI2IGwgMzM2IDEyNiBiIDI5MSAxMTcgMzM2IDEyNiAzMTUgMTIyIGwgMjQ3IDEwOSBsIDI0NyAtMSBsIDI0NyAtMTEyIGwgMjQ5IC0xMTIgYiAzMzYgLTk1IDI1MyAtMTExIDMzNiAtOTUgYiAzMzYgMTUgMzM2IC05NSAzMzYgLTU2IG0gMjA1IC0xMjAgYiAyMDUgLTU1IDIwNSAtMTIwIDIwNSAtOTMgYiAyMDUgLTkgMjA1IC00MSAyMDUgLTI0IGwgMjA1IDEwMSBsIDE2MCA5MyBsIDExNSA4NCBsIDExNSAtMjYgYiAxMTUgLTgzIDExNSAtNDkgMTE1IC02OSBiIDExNyAtMTM3IDExNSAtMTMzIDExNSAtMTM3IGIgMjA1IC0xMjAgMTE4IC0xMzcgMjA0IC0xMjAgXCJ9LFwidjUyXCI6e1wieF9taW5cIjotMTAuODkwNjI1LFwieF9tYXhcIjoyOTguMDc4MTI1LFwiaGFcIjoyOTQsXCJvXCI6XCJtIDEzOCA0NzMgYiAxNDIgNDc0IDE0MCA0NzMgMTQxIDQ3NCBiIDE2NCA0NTkgMTQ4IDQ3NCAxNTMgNDcwIGIgMTkxIDQwMiAxODMgNDQyIDE5MSA0MjMgYiAxODEgMzUzIDE5MSAzODggMTg3IDM3MSBiIDE3OCAzNDkgMTc5IDM1MiAxNzggMzQ5IGIgMTc5IDM0OCAxNzggMzQ4IDE3OSAzNDggYiAxODUgMzQ5IDE4MSAzNDggMTgyIDM0OCBiIDI1NSAzNzYgMjEwIDM1NSAyMzQgMzYzIGIgMjcyIDM4MSAyNjQgMzgxIDI2NiAzODEgYiAyOTggMzU1IDI4NyAzODEgMjk4IDM3MCBiIDI4OCAzMzAgMjk4IDM0OCAyOTggMzQ1IGIgMTcxIDM0IDIzOCAyNTQgMTk0IDE0MSBiIDE2NiAxMyAxNjggMTYgMTY4IDE2IGIgMTQ0IDEgMTYxIDUgMTUyIDEgYiAxMjEgMTUgMTM0IDEgMTI1IDUgYiAxMTUgMzMgMTE5IDE4IDExNyAyNCBiIDAgMzMwIDkxIDE0NSA0OSAyNTIgYiAtMTAgMzU1IC05IDM0NSAtMTAgMzQ4IGIgMTMgMzgxIC0xMCAzNzEgMCAzODEgYiAzMSAzNzYgMTkgMzgxIDI1IDM4MCBiIDEzMiAzNDUgNjEgMzU4IDEwMyAzNDUgbCAxMzYgMzQ1IGwgMTM3IDM1NSBiIDE0NSAzNzggMTM4IDM1OSAxNDIgMzcwIGIgMTUyIDQxNSAxNDkgMzk0IDE1MiA0MDUgYiAxMzcgNDUyIDE1MiA0MjcgMTQ4IDQzOCBiIDEzMyA0NjQgMTM0IDQ1OCAxMzMgNDYwIGIgMTM4IDQ3MyAxMzMgNDY3IDEzNCA0NzAgXCJ9LFwidjUzXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5MDIuNDIxODc1LFwiaGFcIjo5MjEsXCJvXCI6XCJtIDE3IDI0MCBiIDI0IDI0MSAxOSAyNDEgMjEgMjQxIGIgMzIgMjQwIDI4IDI0MSAzMSAyNDEgYiA0NiAyMjkgMzggMjM4IDQzIDIzNCBiIDUwIDg4IDUwIDIyMyA1MCAyMzcgYiA1MCAtMSA1MCA2MyA1MCAzNCBiIDUwIC05MCA1MCAtMzYgNTAgLTY1IGIgNDYgLTIzMSA1MCAtMjM4IDUwIC0yMjQgYiAyNSAtMjQyIDQyIC0yMzggMzQgLTI0MiBiIDAgLTIyNCAxNCAtMjQyIDQgLTIzNSBiIDAgMiAwIC0yMjIgMCAtMTA4IGIgMCAyMjMgMCAxMTIgMCAyMjAgYiAxNyAyNDAgMiAyMzAgOSAyMzcgbSAxMTAgMjQwIGIgMTE4IDI0MSAxMTEgMjQxIDExNCAyNDEgYiAxMjYgMjQwIDEyMSAyNDEgMTIzIDI0MSBiIDE0MiAyMjMgMTMzIDIzNyAxNDAgMjMwIGIgMTQ0IDEyMyAxNDQgMjIwIDE0NCAyMDUgYiAxNDQgMjkgMTQ0IDQ1IDE0NCAyOSBiIDE0NCAyOSAxNDQgMjkgMTQ0IDI5IGIgMzkzIDE4MyAxNjYgMTA2IDI2NCAxNjcgYiA0NTAgMTg2IDQxMiAxODQgNDMxIDE4NiBiIDc1NiAyOSA2MDAgMTg2IDczMiAxMjAgYiA3NTYgMjkgNzU2IDI5IDc1NiAyOSBiIDc1OCAxMjMgNzU4IDI5IDc1OCA0NSBiIDc2MCAyMjcgNzU4IDIyNiA3NTggMjIzIGIgNzg0IDI0MSA3NjYgMjM3IDc3NCAyNDEgYiA4MDQgMjI5IDc5MiAyNDEgODAwIDIzNyBiIDgwOSA4OCA4MDggMjIzIDgwOSAyMzcgbCA4MDkgLTEgbCA4MDkgLTkwIGIgODA0IC0yMzEgODA5IC0yMzggODA4IC0yMjQgYiA3ODQgLTI0MiA4MDAgLTIzOCA3OTIgLTI0MiBiIDc2MiAtMjMxIDc3NSAtMjQyIDc2NiAtMjM4IGIgNzU4IC0xMjQgNzU2IC0yMjQgNzU4IC0yMzEgYiA3NTYgLTMwIDc1OCAtNDcgNzU4IC0zMCBiIDc1NiAtMzAgNzU2IC0zMCA3NTYgLTMwIGIgNTA5IC0xODQgNzM2IC0xMDggNjM3IC0xNjkgYiA0NTAgLTE4NyA0ODggLTE4NyA0NjkgLTE4NyBiIDE0NCAtMzAgMzAwIC0xODcgMTY4IC0xMjIgYiAxNDQgLTMwIDE0NCAtMzAgMTQ0IC0zMCBiIDE0NCAtMTI0IDE0NCAtMzAgMTQ0IC00NyBiIDE0MCAtMjMxIDE0NCAtMjMxIDE0NCAtMjI0IGIgMTE4IC0yNDIgMTM0IC0yMzggMTI2IC0yNDIgYiA5MiAtMjI0IDEwNyAtMjQyIDk2IC0yMzUgYiA5MiAyIDkyIC0yMjIgOTIgLTEwOCBiIDkyIDIyMyA5MiAxMTIgOTIgMjIwIGIgMTEwIDI0MCA5NSAyMzAgMTAyIDIzNyBtIDQzMiAxNjEgYiA0MTMgMTYyIDQyNiAxNjIgNDIwIDE2MiBiIDMxMyA0MSAzNTEgMTYyIDMxMyAxMDkgYiAzNDcgLTczIDMxMyA1IDMyMyAtMzQgYiA0ODcgLTE2MyAzODUgLTEzMyA0MzkgLTE2MyBiIDU3OCAtOTcgNTI2IC0xNjMgNTYyIC0xNDIgYiA1ODggLTQzIDU4NSAtODAgNTg4IC02MiBiIDQzMiAxNjEgNTg4IDQ3IDUxOCAxNDcgbSA4NjggMjQwIGIgODc2IDI0MSA4NjkgMjQxIDg3MiAyNDEgYiA4ODQgMjQwIDg3OSAyNDEgODgyIDI0MSBiIDg5OCAyMjkgODkwIDIzOCA4OTQgMjM0IGIgOTAyIDg4IDkwMiAyMjMgOTAyIDIzNyBsIDkwMiAtMSBsIDkwMiAtOTAgYiA4OTggLTIzMSA5MDIgLTIzOCA5MDIgLTIyNCBiIDg3NiAtMjQyIDg5MiAtMjM4IDg4NCAtMjQyIGIgODUyIC0yMjQgODY1IC0yNDIgODU0IC0yMzUgYiA4NTAgMiA4NTAgLTIyMiA4NTAgLTEwOCBiIDg1MiAyMjMgODUwIDExMiA4NTAgMjIwIGIgODY4IDI0MCA4NTMgMjMwIDg2MCAyMzcgXCJ9LFwidjU0XCI6e1wieF9taW5cIjotMjQuNSxcInhfbWF4XCI6MzE3LjE0MDYyNSxcImhhXCI6MzI0LFwib1wiOlwibSAtMjQgLTE2MSBsIC0yNCAtNSBsIC0yMCAtNSBiIDAgLTI0IC05IC01IC0yIC0xMiBiIDE3MSAtMzE1IDIxIC0xMjQgODQgLTIzMyBiIDMxNyAtNjYwIDI2OCAtNDA2IDMxNyAtNTMxIGIgMTg3IC0xMDE0IDMxNyAtNzgyIDI3NCAtOTA5IGIgMTYxIC0xMDM0IDE3MiAtMTAzNCAxNzEgLTEwMzQgYiAxNDEgLTEwMTMgMTQ5IC0xMDM0IDE0MSAtMTAyNSBiIDE1MiAtOTkxIDE0MSAtMTAwNCAxNDIgLTEwMDIgYiAyNjYgLTY4MiAyMjggLTg5OSAyNjYgLTc4OCBiIDE3NCAtNDMwIDI2NiAtNTg4IDIzNiAtNDk4IGIgLTIzIC0zMTcgMTM2IC0zODggNjYgLTM0OCBiIC0yNCAtMTYxIC0yMyAtMzE2IC0yNCAtMjg1IFwifSxcInY1NVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NTUxLjI1LFwiaGFcIjo1NjMsXCJvXCI6XCJtIDI4OSA2NDQgYiAzMDQgNjQ1IDI5NCA2NDUgMjk5IDY0NSBiIDQwNCA1NjYgMzQ5IDY0NSAzOTIgNjEzIGIgNDA2IDU0MSA0MDUgNTU3IDQwNiA1NDkgYiAzNzkgNDcxIDQwNiA1MTQgMzk3IDQ4OSBsIDM3NyA0NjcgbCAzODIgNDcwIGIgNTA5IDU5MSA0MzggNDg1IDQ4NSA1MzEgYiA1MTMgNjAxIDUxMCA1OTUgNTEzIDU5OSBiIDUzMCA2MDkgNTE4IDYwNyA1MjQgNjA5IGIgNTUxIDU4OCA1NDAgNjA5IDU1MSA2MDIgYiAyMDAgLTYwNSA1NTEgNTg0IDIwNCAtNTk5IGIgMTgyIC02MTYgMTk3IC02MTIgMTkwIC02MTYgYiAxNjMgLTYwMiAxNzQgLTYxNiAxNjYgLTYxMCBiIDE2MSAtNTk4IDE2MSAtNjAxIDE2MSAtNjAxIGIgMjE3IC00MDIgMTYxIC01ODkgMTcwIC01NjIgYiAyNzIgLTIxMyAyNDcgLTI5OCAyNzIgLTIxMyBiIDI3MiAtMjEzIDI3MiAtMjEzIDI3MiAtMjEzIGIgMjY0IC0yMTkgMjcyIC0yMTMgMjY4IC0yMTYgYiAxNDAgLTI2MiAyMjcgLTI0NyAxODIgLTI2MiBiIDM2IC0yMjYgMTAyIC0yNjIgNjUgLTI0OSBiIDAgLTE0NSAxMiAtMjA2IDAgLTE3NiBiIDE3IC04NCAwIC0xMjQgNSAtMTA0IGIgMTAzIC0zOCAzOCAtNTQgNzAgLTM4IGIgMTkxIC05MSAxMzcgLTM4IDE3MiAtNTYgYiAyMDUgLTE0MSAyMDEgLTEwNiAyMDUgLTEyNCBiIDE3OCAtMjEyIDIwNSAtMTY3IDE5NiAtMTk0IGwgMTc1IC0yMTUgbCAxODIgLTIxMyBiIDMwNyAtOTMgMjM2IC0xOTggMjg0IC0xNTEgYiAzNzIgMTI5IDMwOCAtODggMzcyIDEyNyBiIDM3MiAxMjkgMzcyIDEyOSAzNzIgMTI5IGIgMzY0IDEyMiAzNzIgMTI5IDM2OCAxMjYgYiAyNDAgODAgMzI4IDk0IDI4MyA4MCBiIDEzNyAxMTUgMjAyIDgwIDE2NiA5MSBiIDk5IDE5NSAxMTIgMTM2IDk5IDE2NSBiIDExOCAyNTYgOTkgMjE3IDEwNiAyMzggYiAyMDQgMzAzIDEzOCAyODcgMTcxIDMwMyBiIDI5MiAyNDkgMjM4IDMwMyAyNzMgMjg1IGIgMzA2IDE5OSAzMDIgMjM0IDMwNiAyMTcgYiAyNzkgMTI5IDMwNiAxNzMgMjk2IDE0OCBsIDI3NiAxMjYgbCAyODEgMTI3IGIgNDA4IDI0OCAzMzYgMTQyIDM4NSAxOTAgYiA0NzMgNDcwIDQwOSAyNTQgNDczIDQ2OSBiIDQ3MyA0NzAgNDczIDQ3MCA0NzMgNDcwIGIgNDY1IDQ2NCA0NzMgNDcwIDQ2OSA0NjcgYiAzNDEgNDIxIDQyOCA0MzUgMzgzIDQyMSBiIDIzNiA0NTggMzAzIDQyMSAyNjYgNDMzIGIgMjAwIDUzNyAyMTIgNDc4IDIwMCA1MDggYiAyODkgNjQ0IDIwMCA1ODUgMjM0IDYzNSBcIn0sXCJ2NThcIjp7XCJ4X21pblwiOi0yMS43ODEyNSxcInhfbWF4XCI6MzY3LjUsXCJoYVwiOjM3NSxcIm9cIjpcIm0gMjU5IDE1NTMgYiAyNjUgMTU1MyAyNjEgMTU1MyAyNjQgMTU1MyBiIDI4OCAxNTQwIDI3MiAxNTUzIDI3NyAxNTUwIGIgMzY3IDEzNTEgMzQwIDE0OTMgMzY3IDE0MjQgYiAzMzYgMTIyMSAzNjcgMTMwOCAzNTcgMTI2MyBsIDMzMiAxMjExIGwgMzMzIDEyMDggYiAzNjcgMTA3NyAzNTYgMTE3MCAzNjcgMTEyNCBiIDMzNiA5NDUgMzY3IDEwMzIgMzU3IDk4NiBsIDMzMiA5MzUgbCAzMzMgOTMyIGIgMzY3IDgwMCAzNTYgODkzIDM2NyA4NDggYiAzMzYgNjY5IDM2NyA3NTYgMzU3IDcxMCBsIDMzMiA2NTkgbCAzMzMgNjU2IGIgMzY3IDUyMyAzNTYgNjE3IDM2NyA1NzEgYiAzNDUgNDEyIDM2NyA0ODUgMzYwIDQ0NiBiIDIzMSAyNzMgMzIyIDM1NiAyODQgMzEwIGIgLTEgMTkgMTIxIDE5NSAyNyA5MyBiIC0xNyA0IC00IDExIC0xMCA1IGwgLTIxIDQgbCAtMjEgMTM0IGwgLTIxIDI2NSBsIC0xNyAyNjUgYiAxMzMgMjkxIDIwIDI2NSA5NiAyNzggYiAzMTggNTM3IDI0NSAzMjggMzE4IDQzMyBiIDMwNyA2MDMgMzE4IDU1OSAzMTUgNTgyIGIgMzAzIDYxNCAzMDQgNjEyIDMwNCA2MTQgYiAyOTggNjA5IDMwMiA2MTQgMzAwIDYxMyBiIDIzMSA1NDkgMjgxIDU4OSAyNTggNTY3IGIgLTEgMjk1IDEyMSA0NzEgMjcgMzY5IGIgLTE3IDI4MCAtNCAyODcgLTEwIDI4MSBsIC0yMSAyODAgbCAtMjEgNDEwIGwgLTIxIDU0MSBsIC0xNyA1NDEgYiAxMzMgNTY3IDIwIDU0MSA5NiA1NTUgYiAzMTggODEzIDI0NSA2MDUgMzE4IDcwOSBiIDMwNyA4ODAgMzE4IDgzNSAzMTUgODU5IGIgMzAzIDg5MSAzMDQgODg4IDMwNCA4OTEgYiAyOTggODg1IDMwMiA4OTEgMzAwIDg4OCBiIDIzMSA4MjUgMjgxIDg2NiAyNTggODQzIGIgLTEgNTcxIDEyMSA3NDggMjcgNjQ1IGIgLTE3IDU1NiAtNCA1NjMgLTEwIDU1NyBsIC0yMSA1NTYgbCAtMjEgNjg3IGwgLTIxIDgxNyBsIC0xNyA4MTcgYiAxMzMgODQzIDIwIDgxNyA5NiA4MzAgYiAzMTggMTA4OSAyNDUgODgxIDMxOCA5ODUgYiAzMDcgMTE1NiAzMTggMTExMSAzMTUgMTEzNCBiIDMwMyAxMTY3IDMwNCAxMTY0IDMwNCAxMTY3IGIgMjk4IDExNjEgMzAyIDExNjcgMzAwIDExNjQgYiAyMzEgMTEwMiAyODEgMTE0MCAyNTggMTEyMCBiIC0xIDg0OCAxMjEgMTAyNCAyNyA5MjEgYiAtMTcgODMyIC00IDgzOSAtMTAgODM0IGwgLTIxIDgzMiBsIC0yMSA5NjMgbCAtMjEgMTA5MyBsIC0xNyAxMDkzIGIgMTE0IDExMTMgMTIgMTA5MyA3OCAxMTAzIGIgMzEzIDEzMTQgMjE1IDExNDIgMjg5IDEyMTggYiAzMTggMTM2NCAzMTcgMTMzMSAzMTggMTM0NyBiIDI1NSAxNTExIDMxOCAxNDIyIDI5NSAxNDc4IGIgMjQzIDE1MzIgMjQ3IDE1MTkgMjQzIDE1MjUgYiAyNTkgMTU1MyAyNDMgMTU0MCAyNTAgMTU1MCBcIn0sXCJ2NTlcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ2NC4xNDA2MjUsXCJoYVwiOjQ3NCxcIm9cIjpcIm0gMCAwIGwgMCAzNDcgbCA3NiAzNDcgbCAxNTMgMzQ3IGwgMTUzIDAgbCAxNTMgLTM0OCBsIDc2IC0zNDggbCAwIC0zNDggbCAwIDAgbSAzMDggLTEgbCAzMDggMzQ3IGwgMzg2IDM0NyBsIDQ2NCAzNDcgbCA0NjQgLTEgbCA0NjQgLTM0OCBsIDM4NiAtMzQ4IGwgMzA4IC0zNDggbCAzMDggLTEgXCJ9LFwidjVhXCI6e1wieF9taW5cIjotMTcxLjUsXCJ4X21heFwiOjE3MC4xNDA2MjUsXCJoYVwiOjE3NCxcIm9cIjpcIm0gLTYgNTY2IGIgMCA1NjcgLTUgNTY3IC0yIDU2NyBiIDE0IDU1NiA2IDU2NyAxMiA1NjMgYiA5MiAyODUgMTQgNTU1IDUwIDQzMyBiIDE3MCAxMyAxNjYgMzMgMTcwIDE5IGIgMTY4IDEzIDE3MCAxMyAxNzAgMTMgYiAxNjEgMSAxNjggOCAxNjcgNCBsIDE1OSAwIGwgMTIyIDAgbCA4NCAwIGwgODEgMSBiIDIxIDE5NSA3NiA1IDc4IC01IGIgLTMyIDM4MSAtOCAyOTcgLTMyIDM4MSBiIC04NyAxOTcgLTMyIDM4MSAtNTcgMjk4IGIgLTE0MSA4IC0xMTUgOTQgLTE0MCA5IGIgLTE1NSAwIC0xNDIgMiAtMTQ5IDAgYiAtMTcxIDE1IC0xNjMgMCAtMTcxIDUgYiAtMTQgNTU2IC0xNzEgMTggLTI0IDUyOCBiIC02IDU2NiAtMTQgNTYwIC0xMCA1NjQgXCJ9LFwidjViXCI6e1wieF9taW5cIjotNDQxLFwieF9tYXhcIjo0MzkuNjQwNjI1LFwiaGFcIjo0NDksXCJvXCI6XCJtIC00MjggLTIgYiAtNDIxIDAgLTQyNyAtMSAtNDI0IDAgYiAtNDA2IC02IC00MTYgMCAtNDA5IC0yIGIgLTQwMCAtMzEgLTQwMSAtMTIgLTQwMCAtMTUgYiAtMSAtMzUyIC0zOTIgLTIxNSAtMjE1IC0zNTIgYiA1OCAtMzQ5IDE5IC0zNTIgMzggLTM1MSBiIDM5OCAtMzEgMjUwIC0zMjYgMzkyIC0xOTIgYiA0MDQgLTYgMzk4IC0xNSA0MDAgLTEyIGIgNDE5IC0xIDQwOCAtMiA0MTMgLTEgYiA0MzkgLTEzIDQyNyAtMSA0MzUgLTUgYiA0MzkgLTI5IDQzOSAtMTYgNDM5IC0yMiBiIDQzNCAtMTA1IDQzOSAtNDggNDM4IC04MCBiIDAgLTQ4OSAzOTcgLTMzMyAyMTMgLTQ4OSBiIC02OCAtNDg0IC0yMyAtNDg5IC00NCAtNDg4IGIgLTQ0MSAtMzYgLTI4MCAtNDUyIC00MzYgLTI2MyBiIC00NDEgLTMwIC00NDEgLTM0IC00NDEgLTMxIGIgLTQyOCAtMiAtNDQxIC0xMSAtNDM5IC01IG0gLTEzIC05IGIgLTEgLTggLTkgLTggLTUgLTggYiA1MCAtMzYgMTkgLTggMzkgLTE5IGIgNjEgLTcyIDU3IC00NyA2MSAtNTkgYiA1MCAtMTA2IDYxIC04NCA1NyAtOTcgYiAtMSAtMTM0IDM5IC0xMjQgMTkgLTEzNCBiIC00NiAtMTE1IC0xNyAtMTM0IC0zNCAtMTI5IGIgLTYyIC03MiAtNTcgLTEwMiAtNjIgLTg3IGIgLTEzIC05IC02MiAtNDQgLTQ0IC0xNiBcIn0sXCJ2NWNcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ0Ny44MTI1LFwiaGFcIjo0NTcsXCJvXCI6XCJtIDAgLTg3IGwgMCAwIGwgMjIzIDAgbCA0NDcgMCBsIDQ0NyAtODcgbCA0NDcgLTE3NCBsIDIyMyAtMTc0IGwgMCAtMTc0IGwgMCAtODcgXCJ9LFwidjVkXCI6e1wieF9taW5cIjotMS4zNTkzNzUsXCJ4X21heFwiOjU5Mi4wNzgxMjUsXCJoYVwiOjYwNCxcIm9cIjpcIm0gMjgwIDY5MiBiIDI5NSA2OTQgMjgzIDY5MiAyODkgNjk0IGIgMzEwIDY5MiAzMDAgNjk0IDMwNyA2OTIgYiAzNTcgNjMwIDM0MCA2ODQgMzU3IDY1NyBiIDMzNiA1ODAgMzU3IDYxMiAzNTEgNTk0IGIgMzExIDUzOCAzMjEgNTY2IDMxMSA1NDkgYiAzNTIgNDkyIDMxMSA1MTIgMzMwIDQ5MiBiIDM2NiA0OTUgMzU3IDQ5MiAzNjIgNDkyIGIgMzk3IDU1MyAzOTAgNTAzIDM5NyA1MTcgYiA0MTUgNjAzIDM5NyA1NzYgNDAyIDU5MSBiIDQ2MCA2MjMgNDI3IDYxNyA0NDMgNjIzIGIgNTA5IDU5OSA0NzkgNjIzIDQ5OCA2MTQgYiA1MjIgNTU5IDUxOCA1ODcgNTIyIDU3MyBiIDQ5NCA1MDYgNTIyIDUzOCA1MTMgNTE5IGIgNDUxIDQ5NSA0ODEgNDk4IDQ3MyA0OTYgYiA0MTUgNDg4IDQzMiA0OTUgNDI2IDQ5NCBiIDM5NCA0NDkgNDA0IDQ4MyAzOTQgNDY0IGIgMzk0IDQ0OCAzOTQgNDQ4IDM5NCA0NDggbCAzOTQgNDQwIGwgMzk3IDQzMyBiIDQyOCA0MDkgNDA0IDQyMCA0MTMgNDEzIGIgNDM4IDQwOCA0MzEgNDA4IDQzNSA0MDggYiA0NzkgNDMxIDQ1MCA0MDggNDYyIDQxNSBiIDUyOCA0NTUgNDk1IDQ0OCA1MTAgNDU1IGIgNTQ4IDQ1MiA1MzQgNDU1IDU0MSA0NTMgYiA1OTIgMzkxIDU3NyA0NDIgNTkyIDQxNiBiIDU0OSAzMzEgNTkyIDM2NSA1NzcgMzQwIGIgNTI4IDMyNyA1NDEgMzI4IDUzNCAzMjcgYiA0NzkgMzUxIDUxMCAzMjcgNDk1IDMzNSBiIDQzOCAzNzQgNDY0IDM2NyA0NTAgMzc0IGIgNDE3IDM2OSA0MzEgMzc0IDQyNCAzNzMgYiAzOTQgMzMzIDQwMiAzNjAgMzk0IDM0OCBiIDQwMCAzMTIgMzk0IDMyNiAzOTYgMzE5IGIgNDUxIDI4NyA0MDggMjk0IDQyMCAyODggYiA1MTMgMjU4IDQ4NCAyODUgNDk5IDI3OCBiIDUyMiAyMjMgNTE5IDI0NyA1MjIgMjM0IGIgNDYxIDE1OSA1MjIgMTkwIDQ5NiAxNTkgYiA0NDkgMTYxIDQ1NyAxNTkgNDUzIDE1OSBiIDM5NyAyMjkgNDE2IDE2NyAzOTcgMTkxIGIgMzY2IDI4OCAzOTcgMjY1IDM5MCAyNzggYiAzNTIgMjkwIDM2MiAyOTAgMzU3IDI5MCBiIDMxNSAyNjIgMzM2IDI5MCAzMjEgMjgwIGIgMzExIDI0NSAzMTMgMjU2IDMxMSAyNTEgYiAzMzQgMjA0IDMxMSAyMzMgMzE4IDIyMCBiIDM1NSAxNzAgMzQ4IDE5MCAzNTEgMTg0IGIgMzU3IDE1MiAzNTYgMTY2IDM1NyAxNTkgYiAzNTUgMTM2IDM1NyAxNDcgMzU2IDE0MCBiIDI5NSA4OCAzNDUgMTA0IDMyMSA4OCBiIDIzMiAxNTIgMjY0IDg4IDIzMiAxMTIgYiAyNTUgMjA0IDIzMiAxNzQgMjM4IDE4NiBiIDI3OSAyNDQgMjczIDIyMiAyNzkgMjMxIGwgMjc5IDI0NSBiIDIzOCAyOTAgMjc5IDI3MCAyNTkgMjkwIGIgMjI0IDI4OCAyMzQgMjkwIDIyOCAyOTAgYiAxOTMgMjI5IDIwMCAyNzggMTkzIDI2NSBiIDE0MSAxNjEgMTkzIDE5MSAxNzQgMTY3IGIgMTI5IDE1OSAxMzcgMTU5IDEzMyAxNTkgYiA2OCAyMjMgOTMgMTU5IDY4IDE5MCBiIDc3IDI1OCA2OCAyMzQgNzAgMjQ3IGIgMTM4IDI4NyA5MSAyNzggMTA2IDI4NSBiIDE4NSAzMDIgMTY2IDI4NyAxNzUgMjkxIGIgMTk2IDMzMyAxOTMgMzEyIDE5NiAzMjMgYiAxNzQgMzY5IDE5NiAzNDcgMTg3IDM2MCBiIDE1MiAzNzQgMTY2IDM3MyAxNTkgMzc0IGIgMTExIDM1MSAxNDAgMzc0IDEyNiAzNjcgYiA2MiAzMjcgOTUgMzM1IDgwIDMyNyBiIDUxIDMyOCA1OCAzMjcgNTQgMzI3IGIgLTEgMzkxIDE2IDMzNCAtMSAzNjMgYiA1MyA0NTUgLTEgNDIwIDE3IDQ0OSBiIDYyIDQ1NSA1NyA0NTUgNTkgNDU1IGIgMTExIDQzMSA4MCA0NTUgOTUgNDQ4IGIgMTUyIDQwOCAxMjcgNDE1IDE0MCA0MDggYiAxNjEgNDA5IDE1NSA0MDggMTU5IDQwOCBiIDE5MyA0MzMgMTc2IDQxMyAxODYgNDIwIGwgMTk2IDQ0MCBsIDE5NiA0NDggYiAxOTYgNDUxIDE5NiA0NDkgMTk2IDQ0OSBiIDE5MCA0NzEgMTk2IDQ1OSAxOTQgNDYzIGIgMTM3IDQ5NSAxODIgNDg5IDE2NyA0OTUgbCAxMzQgNDk1IGwgMTM0IDQ5NSBiIDY4IDU2MCA5NSA0OTUgNjggNTIxIGIgMTI5IDYyMyA2OCA1OTYgOTUgNjIzIGIgMTQ0IDYyMSAxMzQgNjIzIDEzOCA2MjMgYiAxOTMgNTUzIDE3NSA2MTQgMTkzIDU4OSBiIDIyNCA0OTUgMTkzIDUxNyAyMDAgNTAzIGIgMjM4IDQ5MiAyMjggNDkyIDIzNCA0OTIgYiAyNzkgNTM4IDI1OSA0OTIgMjc5IDUxMiBiIDI1NCA1ODAgMjc5IDU0OSAyNjkgNTY2IGIgMjMyIDYzMCAyMzkgNTk0IDIzMiA2MTIgYiAyODAgNjkyIDIzMiA2NTcgMjUwIDY4NCBtIDMwNyA0NTYgYiAyOTUgNDU4IDMwMyA0NTggMjk5IDQ1OCBiIDIzMCAzOTEgMjU4IDQ1OCAyMzAgNDI2IGIgMjM2IDM2MCAyMzAgMzgxIDIzMSAzNzEgYiAyOTUgMzI0IDI0OSAzMzcgMjcyIDMyNCBiIDM1MyAzNjAgMzE4IDMyNCAzNDEgMzM3IGIgMzYwIDM5MSAzNTcgMzcwIDM2MCAzODEgYiAzMDcgNDU2IDM2MCA0MjEgMzQwIDQ1MSBcIn0sXCJ2NjBcIjp7XCJ4X21pblwiOi01OTAuNzE4NzUsXCJ4X21heFwiOjU4OS4zNTkzNzUsXCJoYVwiOjYwMSxcIm9cIjpcIm0gLTM2NyAxNzMgYiAtMzYyIDE3NCAtMzY2IDE3NCAtMzY0IDE3NCBiIC0zNTEgMTczIC0zNTcgMTc0IC0zNTMgMTczIGIgLTI2MiA4NiAtMzQ4IDE3MiAtMzI4IDE1MSBiIC0xNzYgMCAtMjE2IDM3IC0xNzYgMCBiIC0xMDcgODQgLTE3NiAwIC0xNDUgMzcgYiAtMzEgMTc0IC0zNiAxNzMgLTM4IDE3MiBiIC0yNSAxNzQgLTI5IDE3NCAtMjggMTc0IGIgLTE2IDE3MyAtMjMgMTc0IC0xOSAxNzMgYiA3MiA4NiAtMTMgMTcyIDYgMTUxIGIgMTU3IDAgMTE5IDM3IDE1NyAwIGIgMjI3IDg0IDE1OSAwIDE4OSAzNyBiIDMwMyAxNzQgMjk4IDE3MyAyOTYgMTcyIGIgMzA4IDE3NCAzMDQgMTc0IDMwNyAxNzQgYiAzMTggMTczIDMxMyAxNzQgMzE3IDE3MyBiIDQ4MSAxMSAzMjIgMTcyIDM1NyAxMzQgbCA0OTQgLTEgbCA1MjIgMzQgYiA1NjAgNzYgNTUzIDcyIDU1NSA3NCBiIDU2NyA3NyA1NjMgNzcgNTY0IDc3IGIgNTg5IDU2IDU3OSA3NyA1ODkgNjggYiA1ODYgNDggNTg5IDU0IDU4OCA1MSBiIDQxMSAtMTcyIDU4MyA0MSA0MTYgLTE2NiBiIDM5NyAtMTc2IDQwNiAtMTc0IDQwMSAtMTc2IGIgMzg3IC0xNzQgMzkzIC0xNzYgMzkwIC0xNzYgYiAyOTkgLTg3IDM4NiAtMTczIDM2NiAtMTUyIGIgMjEzIDAgMjUzIC0zOCAyMTMgMCBiIDE0NCAtODYgMjEzIDAgMTgyIC0zOCBiIDY4IC0xNzQgNzMgLTE3NCA3NCAtMTczIGIgNjIgLTE3NiA2NiAtMTc2IDY1IC0xNzYgYiA1MyAtMTc0IDU5IC0xNzYgNTUgLTE3NCBiIC0zNSAtODcgNTAgLTE3MyAyOSAtMTUyIGIgLTEyMSAwIC04MyAtMzggLTEyMSAwIGIgLTE5MCAtODYgLTEyMiAwIC0xNTIgLTM4IGIgLTI2NiAtMTc0IC0yNjEgLTE3NCAtMjU5IC0xNzMgYiAtMjcyIC0xNzYgLTI2OCAtMTc2IC0yNzAgLTE3NiBiIC0yODEgLTE3NCAtMjc2IC0xNzYgLTI4MCAtMTc0IGIgLTM3MSAtODYgLTI4NCAtMTczIC0zMDQgLTE1MiBiIC00NTcgMCAtNDE3IC0zOCAtNDU3IDAgbCAtNDU3IDAgYiAtNDc3IC0yNiAtNDU3IDAgLTQ3MCAtMTYgYiAtNTQ4IC0yMjcgLTUyNCAtODggLTU0OCAtMTYxIGIgLTUzNiAtMzAzIC01NDggLTI1NCAtNTQ0IC0yODAgYiAtNTMzIC0zMTcgLTUzNCAtMzA5IC01MzMgLTMxMyBiIC01NTMgLTMzOCAtNTMzIC0zMzAgLTU0MSAtMzM4IGIgLTU3NyAtMzE1IC01NjYgLTMzOCAtNTcxIC0zMzMgYiAtNTkwIC0yMjcgLTU4NiAtMjg3IC01OTAgLTI1OCBiIC01MTggLTkgLTU5MCAtMTU0IC01NjQgLTc3IGIgLTQ2NSA1NiAtNTA5IDIgLTUwNCA4IGwgLTQwMiAxMzQgYiAtMzY3IDE3MyAtMzc1IDE2OSAtMzcyIDE3MiBcIn0sXCJ2NjJcIjp7XCJ4X21pblwiOjQ2LjI4MTI1LFwieF9tYXhcIjo2NjkuNjcxODc1LFwiaGFcIjo1NjMsXCJvXCI6XCJtIDE4MyAzNzYgYiAxODkgMzc2IDE4NSAzNzYgMTg3IDM3NiBiIDIxMiAzNzQgMTk3IDM3NiAyMDggMzc2IGIgMjY1IDMzNyAyMzQgMzY5IDI1MyAzNTUgYiAyNzQgMzE3IDI2OCAzMzEgMjczIDMyMCBiIDI3NCAzMTYgMjc0IDMxNyAyNzQgMzE2IGIgMjgwIDMyMyAyNzYgMzE2IDI3NiAzMTkgYiAzMTEgMzU4IDI4OCAzMzcgMjk5IDM0OCBiIDMxOSAzNjYgMzE1IDM2MCAzMTggMzY1IGIgMzU2IDM3NiAzMjYgMzczIDM0MCAzNzYgYiAzODIgMzcxIDM2NCAzNzYgMzc0IDM3NCBiIDQyOCAzMzcgNDAwIDM2NiA0MTcgMzUyIGIgNDM2IDMxNyA0MzEgMzMxIDQzNiAzMjAgYiA0MzggMzE2IDQzNiAzMTcgNDM2IDMxNiBiIDQ0MiAzMjMgNDM4IDMxNiA0MzkgMzE5IGIgNDc1IDM1OCA0NTEgMzM3IDQ2MiAzNDggYiA0ODMgMzY2IDQ3NyAzNjAgNDgxIDM2NSBiIDUxOCAzNzYgNDg4IDM3MyA1MDMgMzc2IGIgNTQ0IDM3MyA1MjggMzc2IDUzNiAzNzYgYiA2MDQgMjg1IDU3OSAzNjAgNjA0IDMyNiBiIDU5NyAyNDkgNjA0IDI3MyA2MDEgMjU4IGIgNTQzIDYzIDU5NiAyNDcgNTQ0IDcwIGIgNTQxIDU0IDU0MyA2MSA1NDEgNTUgYiA1NDAgNDQgNTQwIDUxIDU0MCA0NyBiIDU1MiAyMyA1NDAgMzMgNTQ1IDIzIGIgNTUyIDIzIDU1MiAyMyA1NTIgMjMgYiA2NDcgMTI2IDU4NiAyOSA2MjcgNzIgYiA2NTggMTM4IDY1MSAxMzYgNjUzIDEzOCBiIDY2MCAxMzggNjYwIDEzOCA2NjAgMTM4IGIgNjY5IDEyOSA2NjYgMTM3IDY2OSAxMzYgYiA2NTQgODggNjY5IDEyMiA2NjUgMTA5IGIgNTYyIC0xMiA2MzEgNDMgNjAyIDkgbCA1NDkgLTE5IGIgNTIxIC0yNyA1NDAgLTI0IDUzMCAtMjcgYiA0NDcgMzAgNDkwIC0yNyA0NTggLTQgYiA0NDMgNTggNDQ1IDM4IDQ0MyA0OCBiIDQ1MCA5MyA0NDMgNzIgNDQ2IDg0IGIgNTA0IDI3OCA0NTMgOTcgNTA0IDI3MiBiIDUwNyAyODggNTA2IDI4MyA1MDYgMjg3IGIgNTA5IDI5OCA1MDcgMjkyIDUwOSAyOTUgYiA0OTEgMzI2IDUwOSAzMTAgNTAyIDMyMCBiIDQ4NyAzMjcgNDkwIDMyNyA0ODggMzI3IGIgNDc5IDMyNCA0ODQgMzI3IDQ4MyAzMjYgYiA0NDEgMjcwIDQ2MiAzMTYgNDQzIDI4OCBiIDQzNSAyNDkgNDQxIDI2NSA0MzYgMjU0IGIgMzk4IDEyNyA0MzQgMjQ4IDQxOSAxOTUgYiAzNjIgNCAzNzkgNjEgMzYyIDUgYiAzMjggLTEgMzU5IC0xIDM2MiAtMSBiIDMxNCAtMSAzMjMgLTEgMzE5IC0xIGIgMzAyIC0xIDMxMCAtMSAzMDYgLTEgYiAyNjYgNCAyNjYgLTEgMjY5IC0xIGIgMjY1IDYgMjY1IDUgMjY1IDUgYiAzMDMgMTQ0IDI2NSAxMyAyNzIgMzQgYiAzNDMgMjc4IDMyNSAyMTYgMzQzIDI3NiBiIDM0NCAyODggMzQzIDI4MSAzNDQgMjg1IGIgMzQ1IDI5OCAzNDUgMjkxIDM0NSAyOTUgYiAzMzAgMzI2IDM0NSAzMTAgMzQwIDMyMCBiIDMyMyAzMjcgMzI4IDMyNyAzMjUgMzI3IGIgMzE3IDMyNCAzMjIgMzI3IDMyMSAzMjYgYiAyNzkgMjcwIDMwMCAzMTYgMjgxIDI4OCBiIDI3MyAyNDkgMjc5IDI2NSAyNzQgMjU0IGIgMjM2IDEyNyAyNzIgMjQ4IDI1NSAxOTUgYiAyMDAgNCAyMTYgNjEgMjAwIDUgYiAxNjQgLTEgMTk3IC0xIDE5OCAtMSBiIDE1MSAtMSAxNjEgLTEgMTU2IC0xIGIgMTQwIC0xIDE0NyAtMSAxNDIgLTEgYiAxMDMgNCAxMDQgLTEgMTA2IC0xIGIgMTAzIDYgMTAzIDUgMTAzIDUgYiAxNDEgMTQ0IDEwMyAxMyAxMDggMzQgYiAxODEgMjc4IDE2MSAyMTYgMTc5IDI3NiBiIDE4MiAyODggMTgxIDI4MSAxODEgMjg1IGIgMTgzIDI5OCAxODIgMjkxIDE4MyAyOTUgYiAxNjggMzI0IDE4MyAzMTAgMTc4IDMyMCBiIDE2MCAzMjcgMTY2IDMyNiAxNjMgMzI3IGIgMTQxIDMyMCAxNTYgMzI3IDE1MSAzMjQgYiA2OSAyMzAgMTEyIDMwNSA4NSAyNzIgYiA1NyAyMTUgNjUgMjE3IDYyIDIxNSBiIDU1IDIxNSA1NyAyMTUgNTUgMjE1IGIgNDYgMjI0IDQ5IDIxNSA0NiAyMTcgYiA1OSAyNjAgNDYgMjMxIDUwIDI0MiBiIDE1MSAzNjMgODEgMzA2IDExMiAzNDEgYiAxNjEgMzY5IDE1NSAzNjUgMTYwIDM2NyBiIDE4MyAzNzYgMTY2IDM3MSAxNzQgMzc0IFwifSxcInY2OFwiOntcInhfbWluXCI6LTU5Ny41MzEyNSxcInhfbWF4XCI6NTk2LjE3MTg3NSxcImhhXCI6NjA4LFwib1wiOlwibSAtNTMzIDMyNCBiIC01MjUgMzI3IC01MzAgMzI2IC01MjggMzI3IGIgLTUwNCAzMDUgLTUxNCAzMjcgLTUwNCAzMTcgYiAtNTA0IDMwNSAtNTA0IDMwNSAtNTA0IDMwNSBiIC01MTMgMjg0IC01MDQgMjk5IC01MDQgMjk5IGIgLTU1NiAxMTIgLTU0MSAyMjYgLTU1NiAxNjcgYiAtNTQ1IDMzIC01NTYgODQgLTU1MiA1OCBiIC01MjQgLTIwIC01NDEgMTUgLTUzMiAtOSBsIC01MjIgLTIzIGwgLTQ5MSAxNSBsIC00MTMgMTExIGIgLTM1NSAxNzQgLTM2NyAxNjkgLTM2MyAxNzQgYiAtMzUxIDE3NCAtMzUzIDE3NCAtMzUyIDE3NCBiIC0yNTQgODYgLTM0MyAxNzQgLTM0OCAxNzkgYiAtMTY4IC0xIC0yMDggMzcgLTE2OCAtMSBiIC0xMDAgODQgLTE2OCAtMSAtMTM3IDM3IGIgLTIzIDE3MyAtMjggMTczIC0yOSAxNzIgYiAtMTkgMTc0IC0yMSAxNzQgLTIwIDE3NCBiIC04IDE3MyAtMTQgMTc0IC0xMCAxNzMgYiAxNTUgMTEgLTUgMTcyIDQzIDEyMyBsIDE2NiAtMSBsIDE2OCAxIGwgMTcwIDQgbCAxNzAgMTMwIGIgMTcxIDI2MCAxNzAgMjU2IDE3MCAyNTggYiAxOTEgMjc0IDE3NSAyNjkgMTgzIDI3NCBiIDIwNSAyNjcgMTk2IDI3NCAyMDEgMjcyIGIgMjEyIDE1OCAyMTIgMjYyIDIxMCAyNzMgbCAyMTIgNTYgbCAyNTcgMTEyIGIgMzExIDE3MyAzMDQgMTcyIDMwNCAxNzIgYiAzMTcgMTc0IDMxMyAxNzQgMzE0IDE3NCBiIDMyNiAxNzMgMzE5IDE3NCAzMjMgMTczIGIgNDkwIDExIDMyOSAxNzIgMzY2IDEzNCBsIDUwMiAtMSBsIDUzMCAzNCBiIDU2OCA3NiA1NjAgNzIgNTYzIDc0IGIgNTc1IDc3IDU3MCA3NyA1NzMgNzcgYiA1OTYgNTYgNTg2IDc3IDU5NiA2OCBiIDU5NCA0OCA1OTYgNTQgNTk2IDUxIGIgNDE3IC0xNzIgNTkyIDQxIDQyNCAtMTY2IGIgNDA1IC0xNzYgNDE1IC0xNzQgNDA5IC0xNzYgYiAzOTYgLTE3NCA0MDEgLTE3NiAzOTggLTE3NiBiIDMwNyAtODcgMzkzIC0xNzMgMzcyIC0xNTIgYiAyMjEgLTEgMjU5IC0zOCAyMjEgLTEgYiAyMTYgLTYgMjIxIC0xIDIxOSAtMiBsIDIxMiAtMTIgbCAyMTIgLTE0NyBiIDIxMiAtMjEwIDIxMiAtMTczIDIxMiAtMTk0IGIgMjA1IC0yOTIgMjEyIC0yOTcgMjEwIC0yODcgYiAxOTEgLTI5OSAyMDEgLTI5NyAxOTYgLTI5OSBiIDE3MiAtMjg3IDE4MyAtMjk5IDE3NSAtMjk1IGIgMTcwIC0xNzQgMTcxIC0yODQgMTcxIC0yODQgbCAxNzAgLTYzIGwgMTI3IC0xMTcgYiA3MyAtMTc2IDg0IC0xNzAgODAgLTE3NiBiIDY4IC0xNzYgNzIgLTE3NiA3MCAtMTc2IGIgLTI3IC04NyA1OSAtMTc0IDY1IC0xODAgYiAtMTE0IDAgLTc0IC0zOCAtMTEyIDAgYiAtMTgyIC04NiAtMTE0IDAgLTE0NSAtMzggYiAtMjU4IC0xNzQgLTI1MyAtMTc0IC0yNTMgLTE3MyBiIC0yNjQgLTE3NiAtMjU5IC0xNzYgLTI2MiAtMTc2IGIgLTI3NCAtMTc0IC0yNjggLTE3NiAtMjcyIC0xNzQgYiAtNDM4IC0xMSAtMjc3IC0xNzMgLTM0OCAtMTAyIGwgLTQ0OSAwIGwgLTQ3OSAtMzcgYiAtNTI0IC04MCAtNTEzIC04MCAtNTE0IC04MCBsIC01MjQgLTgwIGIgLTU1MyAtNTIgLTUzNCAtODAgLTU0MCAtNzQgYiAtNTk3IDEwOSAtNTgzIC04IC01OTcgNDggYiAtNTYwIDI4MCAtNTk3IDE2NSAtNTg1IDIyNCBiIC01MzMgMzI0IC01NDggMzEwIC01NDAgMzIyIFwifSxcInY2Y1wiOntcInhfbWluXCI6LTEuMzU5Mzc1LFwieF9tYXhcIjoxOTMuMjgxMjUsXCJoYVwiOjE5NyxcIm9cIjpcIm0gNzggMjMzIGIgODcgMjMzIDgxIDIzMyA4NCAyMzMgYiAxODcgMTQwIDEzMiAyMzMgMTc0IDE5NSBiIDE5MyAxMDIgMTkwIDEyNyAxOTMgMTE1IGIgNDMgLTExMyAxOTMgMjIgMTM2IC02MiBiIDI3IC0xMTkgMzYgLTExNiAzMSAtMTE5IGIgMTkgLTEwOCAyMSAtMTE5IDE5IC0xMTUgYiAyOSAtOTcgMTkgLTEwMiAyMCAtMTAxIGIgMTAyIDEzIDczIC03MiAxMDIgLTI3IGIgOTIgNTEgMTAyIDI2IDk4IDQwIGwgOTEgNTQgbCA4NCA1NCBiIDggMTA0IDUzIDU0IDIxIDc0IGIgLTEgMTQyIDEgMTE2IC0xIDEzMCBiIDc4IDIzMyAtMSAxODcgMzEgMjI3IFwifSxcInY2ZFwiOntcInhfbWluXCI6LTU5MC43MTg3NSxcInhfbWF4XCI6NTg5LjM1OTM3NSxcImhhXCI6NjAxLFwib1wiOlwibSA1NDQgMzM1IGIgNTUzIDMzNyA1NDggMzM3IDU1MSAzMzcgYiA1NzUgMzEzIDU2MyAzMzcgNTcwIDMzMCBiIDU4OSAyMjYgNTgzIDI4NSA1ODkgMjU2IGIgNTE3IDggNTg5IDE1MiA1NjMgNzYgYiA0NjQgLTU4IDUwNyAtNCA1MDMgLTkgbCA0MDEgLTEzNiBiIDM2MiAtMTc2IDM3MiAtMTcyIDM3MCAtMTc2IGIgMzU3IC0xNzYgMzYwIC0xNzYgMzU5IC0xNzYgYiAyNjEgLTg3IDM0OSAtMTc0IDM1NSAtMTgwIGIgMTc1IDAgMjE1IC0zOCAxNzUgMCBiIDEwNiAtODYgMTc1IDAgMTQ0IC0zOCBiIDI5IC0xNzQgMzUgLTE3NCAzNiAtMTczIGIgMjQgLTE3NiAyOCAtMTc2IDI3IC0xNzYgYiAxNCAtMTc0IDIxIC0xNzYgMTcgLTE3NCBiIC03MyAtODcgMTIgLTE3MyAtOCAtMTUyIGIgLTE1OSAwIC0xMjEgLTM4IC0xNTkgMCBiIC0yMjggLTg2IC0xNjAgMCAtMTkwIC0zOCBiIC0zMDQgLTE3NCAtMjk5IC0xNzQgLTI5OCAtMTczIGIgLTMxMCAtMTc2IC0zMDYgLTE3NiAtMzA4IC0xNzYgYiAtMzE5IC0xNzQgLTMxNCAtMTc2IC0zMTggLTE3NCBiIC00ODMgLTEyIC0zMjMgLTE3MyAtMzU5IC0xMzcgbCAtNDk1IDAgbCAtNTI0IC0zNCBiIC01NjIgLTc3IC01NTMgLTczIC01NTYgLTc2IGIgLTU2OCAtNzkgLTU2NCAtNzkgLTU2NiAtNzkgYiAtNTkwIC01OCAtNTgxIC03OSAtNTkwIC02OSBiIC01ODggLTQ5IC01OTAgLTU1IC01ODkgLTUyIGIgLTQxMiAxNzAgLTU4NSAtNDMgLTQxNyAxNjUgYiAtMzk4IDE3NCAtNDA4IDE3MyAtNDAyIDE3NCBiIC0zODkgMTczIC0zOTQgMTc0IC0zOTIgMTc0IGIgLTMwMCA4NiAtMzg3IDE3MiAtMzY2IDE1MSBiIC0yMTUgLTEgLTI1NCAzNyAtMjE1IC0xIGIgLTE0NSA4NCAtMjE1IC0xIC0xODMgMzcgYiAtNjkgMTczIC03NCAxNzMgLTc2IDE3MiBiIC02MyAxNzQgLTY4IDE3NCAtNjYgMTc0IGIgLTU0IDE3MyAtNjEgMTc0IC01NyAxNzMgYiAzNCA4NiAtNTEgMTcyIC0zMSAxNTEgYiAxMTkgLTEgODEgMzcgMTE5IC0xIGIgMTg5IDg0IDEyMSAtMSAxNTEgMzcgYiAyNjUgMTczIDI1OSAxNzMgMjU4IDE3MiBiIDI3MCAxNzQgMjY2IDE3NCAyNjkgMTc0IGIgMjgwIDE3MyAyNzQgMTc0IDI3OSAxNzMgYiAzNzAgODQgMjgzIDE3MiAzMDMgMTUxIGIgNDU1IC0xIDQxNiAzNyA0NTUgLTEgbCA0NTUgLTEgYiA0NzYgMjQgNDU1IC0xIDQ2OSAxNSBiIDU0NyAyMjYgNTIyIDg3IDU0NyAxNTkgYiA1MzQgMzAyIDU0NyAyNTIgNTQzIDI3OCBiIDUzMiAzMTcgNTMzIDMwOCA1MzIgMzEzIGIgNTQ0IDMzNSA1MzIgMzI2IDUzNiAzMzMgXCJ9LFwidjZmXCI6e1wieF9taW5cIjotODAuMzEyNSxcInhfbWF4XCI6NzguOTM3NSxcImhhXCI6ODEsXCJvXCI6XCJtIDYzIDE5MSBiIDY5IDE5MiA2NSAxOTIgNjYgMTkyIGIgNzcgMTg4IDcyIDE5MiA3NiAxOTEgYiA3OCAxODMgNzggMTg3IDc4IDE4NiBiIDc0IDE1OCA3OCAxNzkgNzcgMTcyIGwgNjYgMTE1IGIgOSAtMTYxIDQ5IDMwIDEwIC0xNTggYiAtMTAgLTE4NyA2IC0xNzIgLTEgLTE4MSBiIC0zNCAtMTk0IC0xNyAtMTkxIC0yNSAtMTk0IGIgLTgwIC0xNDcgLTU4IC0xOTQgLTgwIC0xNzQgYiAtODAgLTE0MSAtODAgLTE0NCAtODAgLTE0MiBiIDkgNzAgLTgwIC0xMzQgLTczIC0xMTcgbCA0OSAxNjMgYiA2MyAxOTEgNTkgMTg4IDYxIDE5MCBcIn0sXCJ2NzBcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQzNi45MjE4NzUsXCJoYVwiOjQ0NixcIm9cIjpcIm0gMjEzIDE5MCBiIDIxNyAxOTEgMjE1IDE5MSAyMTYgMTkxIGIgMjMxIDE4NCAyMjMgMTkxIDIyOCAxODggYiAyNDkgMTU0IDI0MCAxNjcgMjQ2IDE1OSBiIDQxOSAxOCAyOTIgOTEgMzQ4IDQ1IGIgNDM2IC0xIDQzNSAxMSA0MzYgOCBiIDQyNCAtMTYgNDM2IC05IDQzNCAtMTMgYiAzMDggLTg3IDM5NCAtMjYgMzQwIC01OSBiIDIzMSAtMTg2IDI3NiAtMTE3IDI1NyAtMTQyIGIgMjE5IC0xOTIgMjI4IC0xOTEgMjI1IC0xOTIgYiAxOTggLTE3NCAyMDkgLTE5MiAyMDggLTE5MSBiIDQ3IC0zMyAxNjEgLTExMyAxMTAgLTYzIGIgMTAgLTE2IDM0IC0yNiAxNyAtMTkgYiAwIC0xIDIgLTEzIDAgLTkgYiAxNyAxOCAwIDggMSAxMSBiIDE5OCAxNzMgOTUgNDggMTU2IDEwMSBiIDIxMyAxOTAgMjA2IDE4NyAyMDggMTg4IFwifSxcInY3MlwiOntcInhfbWluXCI6LTQyMy4zMTI1LFwieF9tYXhcIjo0MjEuOTM3NSxcImhhXCI6NDMxLFwib1wiOlwibSAtMjYyIDE5NyBiIC0yNDcgMTk3IC0yNTcgMTk3IC0yNTMgMTk3IGIgLTExOCAxNjIgLTIxMCAxOTcgLTE2MyAxODQgYiA0MCA0NSAtNjEgMTM0IC0xMyA5OCBiIDI3NyAtOTUgMTE5IC0zMyAyMDAgLTgxIGIgMjg5IC05NyAyODEgLTk3IDI4NSAtOTcgYiAzNzggMCAzMzIgLTk3IDM3MSAtNTUgYiAzNzggMTEgMzc4IDQgMzc4IDYgYiAzMDIgODMgMzc4IDU1IDM0NSA4MyBiIDI0MiA2NiAyODMgODMgMjYyIDc3IGIgMjA4IDU2IDIzMSA1OSAyMTkgNTYgYiAxNDggMTIwIDE3NSA1NiAxNDggODEgYiAyMDEgMTg2IDE0OCAxNTEgMTY0IDE3MiBiIDI2MSAxOTggMjIwIDE5NCAyNDAgMTk4IGIgNDIwIDQ1IDM0MSAxOTggNDExIDEzNiBiIDQyMSAyMiA0MjEgMzcgNDIxIDI5IGIgMjQ1IC0xOTkgNDIxIC05MyAzMzggLTE5OSBiIDIzOCAtMTk4IDI0MyAtMTk5IDI0MCAtMTk5IGIgLTQ0IC00NyAxNDggLTE5NCA1MCAtMTQxIGIgLTI1MCA4NiAtMTE0IDIyIC0xODMgNjYgYiAtMjk1IDk0IC0yNzAgOTEgLTI4MyA5NCBiIC0zMTUgOTEgLTMwMiA5NCAtMzA3IDk0IGIgLTM4MSA0IC0zNTYgODEgLTM4MSA0MyBiIC0zNTUgLTU2IC0zODEgLTE4IC0zNzIgLTQwIGIgLTI5OCAtODEgLTMzOCAtNzMgLTMxOSAtODEgYiAtMjQ2IC02OCAtMjgzIC04MSAtMjY1IC03NyBiIC0yMTIgLTU4IC0yMzQgLTYxIC0yMjMgLTU4IGIgLTE3OCAtNjkgLTIwMCAtNTggLTE4OSAtNjIgYiAtMTUxIC0xMjIgLTE2MCAtODEgLTE1MSAtMTAxIGIgLTE3MSAtMTY3IC0xNTEgLTEzOCAtMTU3IC0xNTUgYiAtMjM5IC0xOTUgLTE4NSAtMTgxIC0yMTMgLTE5MiBiIC0yNTcgLTE5NyAtMjQ1IC0xOTcgLTI1MCAtMTk3IGIgLTQyMyAtNSAtMzUyIC0xOTcgLTQyMyAtMTA5IGIgLTQxMiA2NSAtNDIzIDE2IC00MTkgNDAgYiAtMjYyIDE5NyAtMzg5IDEzNyAtMzI5IDE4OCBcIn0sXCJ2NzRcIjp7XCJ4X21pblwiOi0yMDYuODkwNjI1LFwieF9tYXhcIjo0MjguNzUsXCJoYVwiOjQzOCxcIm9cIjpcIm0gMzg5IC0zNTEgYiAzOTQgLTM1MSAzOTAgLTM1MSAzOTMgLTM1MSBiIDQyOCAtMzg1IDQxMyAtMzUxIDQyOCAtMzY3IGIgNDI4IC0zOTQgNDI4IC0zODggNDI4IC0zOTEgYiAzOTQgLTQyOCA0MjYgLTQwNiA0MjEgLTQxMCBsIDMzMiAtNDczIGwgMjY5IC01MTYgbCAyMDUgLTU2MCBsIDE0MSAtNjAzIGwgNzcgLTY0OCBsIDEzIC02OTIgbCAtNTAgLTczNyBsIC0xMTQgLTc4MCBsIC0xNDUgLTgwMiBiIC0xNzEgLTgxMyAtMTU3IC04MTAgLTE2MyAtODEzIGIgLTE3NSAtODEzIC0xNzIgLTgxMyAtMTc0IC04MTMgYiAtMjA2IC03NzcgLTE5NCAtODExIC0yMDYgLTc5NSBiIC0yMDIgLTc2MCAtMjA2IC03NzEgLTIwNSAtNzY2IGIgLTg3IC02NzUgLTE5NyAtNzUyIC0yMDYgLTc1NyBsIC0zNCAtNjM5IGwgODMgLTU1NyBsIDE0NSAtNTE0IGwgMjA5IC00NzAgbCAyNzIgLTQyNyBiIDM4OSAtMzUxIDM3NSAtMzU2IDM4MSAtMzUyIFwifSxcInY3NVwiOntcInhfbWluXCI6LTE0OS43MTg3NSxcInhfbWF4XCI6MTQ4LjM1OTM3NSxcImhhXCI6MTUxLFwib1wiOlwibSAtMTM3IDM4MSBiIC0xMzAgMzgzIC0xMzQgMzgzIC0xMzMgMzgzIGIgLTExMSAzNzEgLTEyMiAzODMgLTExNCAzNzggYiAtNTUgMjI0IC0xMTAgMzcwIC04NSAzMDUgYiAwIDgwIC0yNSAxNDUgLTEgODAgYiA1NCAyMjQgMCA4MCAyNCAxNDUgYiAxMTIgMzc3IDExNCAzODQgMTEwIDM3MyBiIDEyNyAzODQgMTE4IDM4MSAxMjIgMzg0IGIgMTQ4IDM2MiAxMzggMzg0IDE0OCAzNzQgbCAxNDggMzU2IGwgODMgMTgzIGIgMTYgOSA0NyA4OCAxNyAxMSBiIC0xIDAgMTIgMiA1IDAgYiAtMTQgNSAtNSAwIC0xMCAxIGIgLTg0IDE4MyAtMTkgOSAtMTMgLTYgbCAtMTQ5IDM1NiBsIC0xNDkgMzYyIGIgLTEzNyAzODEgLTE0OSAzNzEgLTE0NSAzNzggXCJ9LFwidjc4XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoxOTMuMjgxMjUsXCJoYVwiOjE5NyxcIm9cIjpcIm0gODUgNTE0IGIgOTUgNTE3IDg4IDUxNyA4OSA1MTcgYiAxMTQgNTA1IDEwMyA1MTcgMTEwIDUxMyBsIDExNSA1MDIgbCAxMTUgMzc2IGIgMTE1IDI0OSAxMTUgMzA2IDExNSAyNDkgYiAxNDEgMjU4IDExNyAyNDkgMTI3IDI1MiBsIDE2NyAyNjYgbCAxNzIgMjY2IGIgMTkwIDI1NCAxODEgMjY1IDE4NyAyNjIgbCAxOTMgMjUxIGwgMTkzIDIwMiBsIDE5MyAxODggYiAxODcgMTQ3IDE5MyAxNDkgMTkxIDE1MiBiIDE0NyAxMzAgMTgzIDE0MiAxODIgMTQxIGwgMTE1IDExOSBsIDExNSA5IGIgMTE1IC05OSAxMTUgLTUxIDExNSAtOTkgYiAxNDEgLTkxIDExNSAtOTkgMTI3IC05NSBiIDE3MSAtODEgMTY2IC04MSAxNjcgLTgxIGwgMTcxIC04MSBiIDE5MSAtOTQgMTgxIC04MSAxODkgLTg3IGIgMTkzIC0xNDIgMTkxIC05NyAxOTMgLTEyMCBiIDE5MSAtMTk1IDE5MyAtMTY3IDE5MSAtMTk0IGIgMTI1IC0yMjcgMTg3IC0yMDUgMTg3IC0yMDQgbCAxMTUgLTIzMCBsIDExNSAtMzY2IGwgMTE1IC01MDMgbCAxMTQgLTUwNiBiIDk1IC01MTkgMTEwIC01MTQgMTAyIC01MTkgYiA3NCAtNTA2IDg3IC01MTkgNzggLTUxNCBsIDczIC01MDMgbCA3MyAtMzc0IGIgNzMgLTI0NSA3MyAtMjYwIDczIC0yNDUgYiA3MyAtMjQ1IDczIC0yNDUgNzMgLTI0NSBiIDU1IC0yNTIgNzIgLTI0NSA2MyAtMjQ5IGwgMzIgLTI2MCBiIDE5IC0yNjMgMjcgLTI2MiAyMyAtMjYzIGIgNCAtMjU2IDEzIC0yNjMgOCAtMjYwIGIgMCAtMjE1IDAgLTI1MSAwIC0yNTQgYiAwIC0xOTkgMCAtMjEwIDAgLTIwNiBsIDAgLTE1MiBsIDEgLTE0OSBiIDggLTE0MCAyIC0xNDUgNSAtMTQxIGIgNDIgLTEyNyA5IC0xNDAgMjQgLTEzMyBsIDczIC0xMTYgbCA3MyAtNSBiIDczIDIzIDczIDQgNzMgMTUgYiA3MyAxMDUgNzMgNzAgNzMgMTA1IGIgNDkgOTcgNzMgMTA1IDYxIDEwMSBiIDE3IDg4IDMyIDkxIDIzIDg4IGIgNCA5NSAxMCA4OCA4IDkxIGIgMCAxMzcgMCAxMDEgMCA5OCBiIDAgMTUxIDAgMTQxIDAgMTQ1IGwgMCAxOTkgbCAxIDIwMiBiIDQzIDIyNCA1IDIxMiA1IDIxMiBsIDczIDIzNCBsIDczIDM2NyBsIDczIDUwMiBsIDc0IDUwNSBiIDg1IDUxNCA3NyA1MDkgODEgNTEzIFwifSxcInY3OVwiOntcInhfbWluXCI6LTEuMzU5Mzc1LFwieF9tYXhcIjo4OTkuNzAzMTI1LFwiaGFcIjo5MTgsXCJvXCI6XCJtIDMwNyAzNDkgYiAzMzIgMzUxIDMxNSAzNTEgMzIzIDM1MSBiIDQ0MyAzNDAgMzY3IDM1MSA0MDggMzQ3IGIgNzQxIDQ3IDYwNyAzMDYgNzIwIDE5NSBiIDc0NCAwIDc0MyAzMSA3NDQgMTYgYiA2NjAgLTMwMyA3NDQgLTkwIDcxMyAtMjA2IGIgMjggLTc1NSA1MzQgLTUzMSAzMDQgLTY5NSBiIDE0IC03NTYgMjMgLTc1NSAxOSAtNzU2IGIgLTEgLTc0MSA0IC03NTYgLTEgLTc1MCBiIDIxIC03MjAgLTEgLTczMSAxIC03MjggYiA1NjcgLTU2IDMzNyAtNjAxIDU0OCAtMzQ0IGIgNTY4IC0xMSA1NjggLTQxIDU2OCAtMjQgYiA0NDIgMjg1IDU2OCAxMjkgNTI1IDIzMyBiIDMyNSAzMTkgNDA2IDMwOCAzNjcgMzE5IGIgOTMgMTc3IDIzMiAzMTkgMTM3IDI2NiBiIDg0IDE1NCA5MSAxNzAgODQgMTU1IGIgODQgMTU0IDg0IDE1NCA4NCAxNTQgYiA4OCAxNTYgODQgMTU0IDg1IDE1NSBiIDE1OSAxNzcgMTEwIDE3MCAxMzQgMTc3IGIgMjU3IDEzNCAxOTQgMTc3IDIzMSAxNjIgYiAyOTQgNDEgMjgxIDEwOCAyOTQgNzMgYiAxNzEgLTk3IDI5NCAtMjQgMjQ2IC05MCBiIDE1NiAtOTggMTY2IC05NyAxNjEgLTk4IGIgNiA3NCA3MyAtOTggNiAtMjIgYiA2IDgwIDYgNzYgNiA3OSBiIDMwNyAzNDkgMTAgMjIzIDE0MSAzNDAgbSA4MzkgMjE1IGIgODQ1IDIxNiA4NDEgMjE2IDg0MiAyMTYgYiA4NjIgMjEzIDg1MiAyMTYgODYwIDIxNSBiIDg5OSAxNjMgODg3IDIwNiA4OTkgMTg0IGIgODcyIDExNyA4OTkgMTQ1IDg5MCAxMjcgYiA4NDcgMTExIDg2NSAxMTIgODU2IDExMSBiIDgwOCAxMzAgODMzIDExMSA4MTggMTE3IGIgNzk2IDE2MiA4MDAgMTQwIDc5NiAxNTEgYiA4MzkgMjE1IDc5NiAxODcgODEyIDIxMiBtIDgzOSAtMTEyIGIgODQ1IC0xMTIgODQxIC0xMTIgODQyIC0xMTIgYiA4NjIgLTExNSA4NTIgLTExMiA4NjAgLTExMyBiIDg5OSAtMTY1IDg4NyAtMTIyIDg5OSAtMTQ0IGIgODcyIC0yMTAgODk5IC0xODMgODkwIC0yMDEgYiA4NDcgLTIxNyA4NjUgLTIxNSA4NTYgLTIxNyBiIDgwOCAtMTk4IDgzMyAtMjE3IDgxOCAtMjEwIGIgNzk2IC0xNjUgODAwIC0xODggNzk2IC0xNzcgYiA4MzkgLTExMiA3OTYgLTE0MCA4MTIgLTExNiBcIn0sXCJ2N2NcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjMwMC44MTI1LFwiaGFcIjozMDcsXCJvXCI6XCJtIDQ5IDUwNSBiIDUzIDUwNiA1MCA1MDUgNTEgNTA2IGIgNzAgNDk2IDU4IDUwNiA2MiA1MDMgYiA4MSA0ODUgNzMgNDkyIDc4IDQ4OCBsIDk2IDQ3MyBsIDExMSA0NTkgbCAxMjIgNDQ5IGwgMTM0IDQzOCBsIDE4MiAzOTYgbCAyNTUgMzMwIGIgMjkyIDI5MSAyOTIgMjk4IDI5MiAyOTggbCAyOTIgMjkwIGwgMjkyIDI4NCBsIDI4MyAyNzAgYiAyMDkgMzYgMjM0IDE5NyAyMDkgMTEzIGIgMjg4IC0xNzAgMjA5IC00NCAyMzUgLTExOSBiIDI5OSAtMTg0IDI5NSAtMTc5IDI5OSAtMTgxIGIgMzAwIC0xOTEgMzAwIC0xODcgMzAwIC0xODggYiAyODUgLTIwNiAzMDAgLTE5OSAyOTQgLTIwNiBiIDI4MCAtMjA2IDI4MyAtMjA2IDI4MSAtMjA2IGIgMjQ3IC0yMDEgMjcwIC0yMDIgMjU5IC0yMDEgYiAxNzYgLTIyMiAyMjMgLTIwMSAxOTcgLTIwOCBiIDExNCAtMzQwIDEzNiAtMjQ5IDExNCAtMjkyIGIgMTcyIC00NzEgMTE0IC0zODQgMTM0IC00MzMgYiAxODUgLTQ5MiAxODIgLTQ4MSAxODUgLTQ4NyBiIDE4MSAtNTAyIDE4NSAtNDk2IDE4MyAtNDk5IGIgMTcxIC01MDggMTc2IC01MDUgMTc0IC01MDggYiAxNTIgLTQ5OCAxNjYgLTUwOCAxNjAgLTUwMyBiIDAgLTI4NCA2NSAtNDI4IDEyIC0zNTIgYiAwIC0yNjAgMCAtMjc4IDAgLTI3MCBiIDEgLTIzOCAwIC0yNTIgMCAtMjQyIGIgMTQ4IC0xNDAgMTYgLTE3NyA3MyAtMTQwIGIgMjA5IC0xNDggMTY3IC0xNDAgMTg5IC0xNDIgYiAyMTUgLTE0OSAyMTIgLTE0OCAyMTUgLTE0OSBiIDIxNSAtMTQ5IDIxNSAtMTQ5IDIxNSAtMTQ5IGwgMjE1IC0xNDkgYiAyMDEgLTEzNiAyMTUgLTE0OCAyMDkgLTE0MiBsIDE1NyAtOTcgbCA5NiAtNDEgYiAxNyAzNCAyMSAyNCAxNyAyOSBiIDE3IDM3IDE3IDM2IDE3IDM2IGIgMTcgMzggMTcgMzcgMTcgMzggYiAyNSA1NiAxNyA0NCAxNyA0NCBiIDExMCAyOTggODEgMTMxIDExMCAyMTkgYiA0NiA0NzQgMTEwIDM2NyA4OCA0MzEgYiAzOCA0OTEgNDAgNDgwIDM4IDQ4NyBiIDQ5IDUwNSAzOCA0OTggNDIgNTAyIFwifSxcInY3ZFwiOntcInhfbWluXCI6LTEuMzU5Mzc1LFwieF9tYXhcIjo0MzYuOTIxODc1LFwiaGFcIjo0NDYsXCJvXCI6XCJtIDIxMyAyMDUgYiAyMTcgMjA1IDIxNSAyMDUgMjE2IDIwNSBiIDIzNCAxOTQgMjI0IDIwNSAyMzQgMTk5IGIgMjM2IDE4NyAyMzQgMTk0IDIzNSAxOTAgbCAyNDUgMTY3IGwgMjYxIDEyOSBsIDI3MCAxMDYgYiAzNTUgLTYxIDI5NCA1NCAzMjkgLTEzIGIgNDIwIC0xNjMgMzgxIC0xMDUgNDAyIC0xMzggYiA0MzYgLTE4OCA0MzUgLTE4NCA0MzYgLTE4NCBiIDQzNiAtMTkxIDQzNiAtMTkwIDQzNiAtMTkwIGIgNDIxIC0yMDYgNDM2IC0yMDEgNDMxIC0yMDYgbCA0MjEgLTIwNiBsIDQxNiAtMjA2IGwgNDA1IC0yMDEgYiAyMTcgLTE1OCAzNDcgLTE3MiAyODMgLTE1OCBiIDMxIC0yMDEgMTUzIC0xNTggODggLTE3MiBsIDIwIC0yMDYgbCAxNCAtMjA2IGwgMTQgLTIwNiBiIDAgLTE5MSA1IC0yMDYgMCAtMjAxIGIgLTEgLTE4OCAwIC0xOTAgLTEgLTE5MCBiIDE0IC0xNjMgLTEgLTE4NiAwIC0xODQgYiA5NSAtMzQgMzYgLTEzNiA3MiAtNzcgYiAxNjYgMTA2IDExOSA4IDE0OCA2OCBsIDE3NSAxMjkgbCAxODMgMTQ4IGwgMjAwIDE4OCBiIDIxMyAyMDUgMjA1IDE5OSAyMDggMjAyIFwifSxcInY3ZlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MzY3LjUsXCJoYVwiOjM3NSxcIm9cIjpcIm0gMCAxMjQgbCAwIDE4NyBsIDYxIDE4NyBsIDEyMiAxODcgbCAxMjIgMTM4IGwgMTIyIDkxIGwgMTUzIDYxIGwgMTgzIDMwIGwgMjEzIDYxIGwgMjQzIDkxIGwgMjQzIDEzOCBsIDI0MyAxODcgbCAzMDYgMTg3IGwgMzY3IDE4NyBsIDM2NyAxMjQgbCAzNjcgNjEgbCAzMjEgNjEgbCAyNzQgNjEgbCAyNDMgMzAgbCAyMTMgMCBsIDI0MyAtMzEgbCAyNzQgLTYyIGwgMzIxIC02MiBsIDM2NyAtNjIgbCAzNjcgLTEyNCBsIDM2NyAtMTg4IGwgMzA2IC0xODggbCAyNDMgLTE4OCBsIDI0MyAtMTQwIGwgMjQzIC05MyBsIDIxMyAtNjIgbCAxODMgLTMxIGwgMTUzIC02MiBsIDEyMiAtOTMgbCAxMjIgLTE0MCBsIDEyMiAtMTg4IGwgNjEgLTE4OCBsIDAgLTE4OCBsIDAgLTEyNCBsIDAgLTYyIGwgNDYgLTYyIGwgOTIgLTYyIGwgMTIzIC0zMSBsIDE1MyAwIGwgMTIzIDMwIGwgOTIgNjEgbCA0NiA2MSBsIDAgNjEgbCAwIDEyNCBcIn0sXCJ2ODBcIjp7XCJ4X21pblwiOjI5LjkzNzUsXCJ4X21heFwiOjQyMC41NzgxMjUsXCJoYVwiOjM3MSxcIm9cIjpcIm0gMTE1IDM0NSBiIDIyMSAzNDcgMTE3IDM0NSAxNjYgMzQ3IGIgNDExIDM0NSAzMDYgMzQ3IDQwOSAzNDUgYiA0MjAgMzMwIDQxNiAzNDIgNDIwIDMzNSBiIDQxNSAzMTkgNDIwIDMyNiA0MTkgMzIxIGIgMTc4IDExOCAzOTcgMzAzIDE3OSAxMTggYiAxNzggMTE3IDE3OCAxMTggMTc4IDExNyBiIDE4MSAxMTcgMTc4IDExNyAxNzggMTE3IGIgMTg5IDExNyAxODIgMTE3IDE4NSAxMTcgYiAxOTMgMTE3IDE5MCAxMTcgMTkxIDExNyBiIDI0NyA5OCAyMTUgMTE3IDIzMiAxMTEgYiAyOTYgNzUgMjY2IDgzIDI4MCA3NiBiIDMwMiA3NSAyOTkgNzUgMzAwIDc1IGIgMzIyIDkxIDMxMSA3NSAzMTUgNzkgYiAzMjIgOTEgMzIyIDkxIDMyMiA5MSBiIDMyMiA5MSAzMjIgOTEgMzIyIDkxIGIgMzE5IDkxIDMyMiA5MSAzMjEgOTEgYiAzMTMgOTAgMzE4IDkwIDMxNSA5MCBiIDI4MyAxMDcgMzAwIDkwIDI4OCA5NyBiIDI3NyAxMjYgMjc5IDExNCAyNzcgMTIxIGIgMzE5IDE2NyAyNzcgMTQ5IDI5NSAxNjcgYiAzMTkgMTY3IDMxOSAxNjcgMzE5IDE2NyBiIDM2MiAxMTggMzQ3IDE2NyAzNjIgMTQ3IGIgMzU1IDgyIDM2MiAxMDggMzU5IDk2IGIgMzExIDMzIDM0OSA2NSAzNDAgNTUgYiAyMjQgMSAyODQgMTIgMjUzIDEgYiAxOTQgNSAyMTMgMSAyMDQgMiBiIDE2OCAxOCAxODMgOCAxNzggMTEgYiAxMTAgMzYgMTUxIDMwIDEzMCAzNiBiIDU3IDE1IDg4IDM2IDY4IDI5IGIgNDcgMTEgNTQgMTIgNTEgMTEgYiAzMSAyMCA0MCAxMSAzNCAxMyBiIDI5IDI2IDMxIDIyIDI5IDI1IGIgNjggNjYgMjkgMzYgMzkgNDUgYiAyODUgMjUwIDczIDcxIDI4MSAyNDggYiAyODUgMjUwIDI4NSAyNTAgMjg1IDI1MCBiIDIzMSAyNTIgMjg1IDI1MiAyNjEgMjUyIGIgMTM3IDI1MCAxOTAgMjUyIDE0MSAyNTAgYiA5MyAyMjcgMTIyIDI0OCAxMTAgMjQxIGIgNzggMjIwIDg4IDIyMiA4MyAyMjAgYiA2NiAyMjcgNzQgMjIwIDcwIDIyMiBiIDYzIDIzNCA2NSAyMjkgNjMgMjMxIGIgODUgMjkxIDYzIDI0MSA2OSAyNTIgYiAxMTUgMzQ1IDEwOCAzNDIgMTA4IDM0NCBcIn0sXCJ2ODFcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQyOC43NSxcImhhXCI6NDM4LFwib1wiOlwibSAyNjIgMTg2IGIgMjczIDE4NiAyNjYgMTg2IDI3MiAxODYgYiAyNzQgMTg2IDI3MyAxODYgMjc0IDE4NiBiIDI4NSAxODYgMjc0IDE4NiAyODAgMTg2IGIgNDI4IDQ4IDM3NSAxODEgNDI4IDEyMiBiIDM4NiAtNjggNDI4IDEyIDQxNiAtMjkgYiAxNTUgLTE4NyAzMjkgLTE0NSAyMzYgLTE4NyBiIDEyIC0xMTEgOTIgLTE4NyAzOCAtMTYyIGIgMCAtNTEgNCAtOTEgMCAtNzIgYiAyNjIgMTg2IDAgNTggMTIyIDE3OSBtIDM2NiAxMzEgYiAzNTIgMTM0IDM2MiAxMzMgMzU3IDEzNCBiIDIxOSA4MSAzMjEgMTM0IDI2OSAxMTUgYiA0NyAtMTExIDEyNiAyMyA1MCAtNjIgYiA0NyAtMTEyIDQ3IC0xMTEgNDcgLTExMiBiIDc3IC0xMzYgNDcgLTEyOSA1OCAtMTM2IGIgMjY0IC00NSAxMTggLTEzNiAxOTQgLTEwMSBiIDM4MiAxMDkgMzM2IDEyIDM4MiA3NiBiIDM2NiAxMzEgMzgyIDEyMCAzNzcgMTI5IFwifSxcInY4M1wiOntcInhfbWluXCI6LTEuMzU5Mzc1LFwieF9tYXhcIjo4NDcuOTY4NzUsXCJoYVwiOjg2NSxcIm9cIjpcIm0gNDg4IDE0OTkgYiA0OTUgMTUwMCA0OTAgMTUwMCA0OTIgMTUwMCBiIDU0MSAxNDY1IDUwNyAxNTAwIDUyMSAxNDkwIGIgNjc5IDEwNzggNjIyIDEzNzIgNjc5IDEyMTAgYiA2NzcgMTA1MCA2NzkgMTA2OCA2NzcgMTA2MCBiIDQ3NyA2NDIgNjY4IDg5MyA2MDQgNzY0IGwgNDQzIDYwOSBsIDQzMSA1OTYgbCA0MzEgNTkyIGwgNDM4IDU2MiBsIDQ0OSA1MDggbCA0NjAgNDU4IGIgNDgxIDM1NSA0NzUgMzkwIDQ4MSAzNTUgYiA0ODEgMzU1IDQ4MSAzNTUgNDgxIDM1NSBiIDQ5MCAzNTYgNDgxIDM1NSA0ODUgMzU1IGIgNTI4IDM1OCA0OTUgMzU2IDUxMSAzNTggYiA1NTggMzU2IDU0MCAzNTggNTUyIDM1NiBiIDgzOSA5NSA2OTkgMzM4IDgwOCAyMzcgYiA4NDcgMjIgODQ1IDcyIDg0NyA0NyBiIDYzMSAtMzAzIDg0NyAtMTEzIDc2NiAtMjQyIGIgNjIwIC0zMDkgNjIzIC0zMDggNjIwIC0zMDkgbCA2MjAgLTMxMCBiIDYzMSAtMzU5IDYyMCAtMzEwIDYyNiAtMzMzIGwgNjQ2IC00MzUgbCA2NjAgLTQ5NiBiIDY3MiAtNTg4IDY2OCAtNTM1IDY3MiAtNTYzIGIgNjY0IC02NTMgNjcyIC02MTAgNjY5IC02MzAgYiAzODMgLTg3NSA2MzAgLTc5MiA1MDkgLTg3NSBiIDIwMSAtODEwIDMyMSAtODc1IDI1NyAtODU1IGIgMTI5IC02ODAgMTUxIC03NjggMTI5IC03MzAgYiAyNzQgLTUzMCAxMjkgLTU5MiAyMDAgLTUzMCBiIDM1MSAtNTUzIDMwMCAtNTMwIDMyNiAtNTM4IGIgNDEyIC02NjkgMzkzIC01ODIgNDEyIC02MjYgYiAyODcgLTgwNSA0MTIgLTczNSAzNjYgLTgwMCBsIDI3OSAtODA1IGwgMjg1IC04MDkgYiAzODMgLTgzMCAzMTggLTgyMyAzNTEgLTgzMCBiIDU4NiAtNzE4IDQ2NCAtODMwIDU0MCAtNzg5IGIgNjI2IC01ODQgNjEyIC02NzggNjI2IC02MzEgYiA2MTkgLTUyOCA2MjYgLTU2NiA2MjMgLTU0OCBiIDYxMiAtNDk1IDYxOSAtNTI2IDYxNiAtNTEwIGIgNTc3IC0zMjQgNTkwIC0zODcgNTc3IC0zMjQgYiA1NzcgLTMyNCA1NzcgLTMyNCA1NzcgLTMyNCBiIDU2OCAtMzI2IDU3NSAtMzI0IDU3MSAtMzI0IGIgNTI4IC0zMzQgNTU4IC0zMjggNTM3IC0zMzMgYiA0NjUgLTMzOCA1MDYgLTMzNyA0ODUgLTMzOCBiIDI0IC0xMSAyNjkgLTMzOCA4NyAtMjA2IGIgLTEgMTQ1IDggNDEgLTEgOTMgYiA5NiA0NDIgLTEgMjQ5IDMyIDM1MSBiIDMyMiA3MTQgMTY2IDU0MSAyMzYgNjI2IGwgMzUyIDc0NSBsIDM0NSA3ODIgbCAzMzIgODQzIGwgMzE1IDkyMSBiIDMwMyA5ODQgMzEwIDk1MCAzMDQgOTc4IGIgMjk1IDEwODIgMjk4IDEwMTcgMjk1IDEwNDkgYiA0MTMgMTQyNiAyOTUgMTIwOCAzMzYgMTMyOSBiIDQ4OCAxNDk5IDQzNiAxNDU2IDQ3NyAxNDk2IG0gNTQ5IDEzMDEgYiA1NDEgMTMwMSA1NDcgMTMwMSA1NDQgMTMwMSBiIDQxMSAxMjA3IDUwMCAxMzAxIDQ0NyAxMjYzIGIgMzU1IDEwMDQgMzc0IDExNTIgMzU1IDEwNzkgYiAzNTkgOTQyIDM1NSA5ODQgMzU2IDk2MyBiIDM3MSA4ODEgMzYyIDkyNyAzNjMgOTE3IGwgMzg1IDgxOCBiIDM5MiA3ODIgMzg5IDc5OSAzOTIgNzg0IGwgMzkyIDc4MiBiIDQzNCA4MjggMzkzIDc4MiA0MjQgODE2IGIgNjA3IDExNjUgNTM0IDk0MSA1OTQgMTA2MCBiIDYwOCAxMTkzIDYwOCAxMTc1IDYwOCAxMTgzIGIgNTk3IDEyNzAgNjA4IDEyMjQgNjA0IDEyNTQgYiA1NDkgMTMwMSA1ODkgMTI4NiA1NzEgMTI5OSBtIDM5OCA1MjggYiAzOTMgNTU1IDM5NiA1NDIgMzkzIDU1MyBiIDM5MiA1NTUgMzkzIDU1NSAzOTMgNTU1IGIgMzE3IDQ3MCAzOTAgNTU1IDM0NyA1MDUgYiAxOTAgMjk4IDI2NiA0MDggMjEyIDMzNCBiIDEyNyA3MCAxNDggMjI3IDEyNyAxNDggYiAxNTUgLTc3IDEyNyAxOSAxMzcgLTMwIGIgNDY4IC0zMDMgMjA5IC0yMTYgMzMzIC0zMDMgYiA1MTkgLTI5OSA0ODQgLTMwMyA1MDIgLTMwMiBiIDU2OCAtMjg0IDU0MSAtMjk1IDU2OCAtMjg3IGwgNTY4IC0yODQgYiA1NjMgLTI2MyA1NjggLTI4NCA1NjYgLTI3NCBsIDUzNCAtMTIwIGwgNTExIC0xMyBsIDQ5NiA2MSBsIDQ4MCAxMzMgYiA0NjkgMTg3IDQ3MiAxNzYgNDY5IDE4NyBiIDQ2OCAxODggNDY5IDE4NyA0NjkgMTg4IGIgNDE2IDE2MiA0NjIgMTg4IDQzMCAxNzIgYiAzMzcgMTMgMzY0IDEyNiAzMzcgNjkgYiA0MTMgLTEyNCAzMzcgLTQwIDM2MyAtOTMgYiA0MjggLTE0NCA0MjQgLTEzMSA0MjggLTEzNyBiIDQyOCAtMTQ5IDQyOCAtMTQ1IDQyOCAtMTQ4IGIgNDA5IC0xNjYgNDI2IC0xNjEgNDE5IC0xNjYgYiAzOTQgLTE2MiA0MDUgLTE2NiA0MDAgLTE2NSBiIDI0MCA3NyAzMDIgLTEyMiAyNDAgLTI3IGwgMjQwIDc3IGIgNDMwIDM0MiAyNDAgMTk3IDMxNSAzMDEgbCA0MzYgMzQ0IGwgNDI2IDM5NCBsIDM5OCA1MjggbSA1NDggMTk0IGIgNTI2IDE5NSA1NDAgMTk1IDUzMiAxOTUgYiA1MTkgMTk1IDUyNCAxOTUgNTIxIDE5NSBsIDUxNCAxOTUgbCA1MTggMTc3IGwgNTM5IDc5IGwgNTUyIDE1IGwgNTY2IC00OCBsIDU5NCAtMTg3IGwgNjA1IC0yNDAgYiA2MTIgLTI2NiA2MDkgLTI1NCA2MTEgLTI2NiBiIDYxMiAtMjY2IDYxMiAtMjY2IDYxMiAtMjY2IGIgNjQxIC0yNDggNjEzIC0yNjYgNjMwIC0yNTYgYiA3NDQgLTk4IDY5MiAtMjEyIDczMCAtMTU2IGIgNzUxIC00MCA3NDkgLTc5IDc1MSAtNTkgYiA1NDggMTk0IDc1MSA3NiA2NjUgMTgxIFwifSxcInY4NFwiOntcInhfbWluXCI6MjUuODU5Mzc1LFwieF9tYXhcIjoxNjQuNjg3NSxcImhhXCI6MTY4LFwib1wiOlwibSAzNCAzNjkgYiA0MCAzNzAgMzUgMzcwIDM4IDM3MCBiIDU5IDM1MyA0OSAzNzAgNTAgMzY3IGIgMTY0IDQwIDEyMiAyNTQgMTU1IDE1OCBiIDE2NCAwIDE2NCAzMyAxNjQgMTYgYiAxNjQgLTQwIDE2NCAtMTYgMTY0IC0zNCBiIDU5IC0zNTMgMTU1IC0xNTggMTIyIC0yNTQgYiA0MCAtMzcxIDUzIC0zNjYgNDcgLTM3MSBiIDM0IC0zNzAgMzggLTM3MSAzNiAtMzcwIGIgMjUgLTM1OCAyOCAtMzY3IDI1IC0zNjMgYiAzMSAtMzM3IDI1IC0zNTIgMjcgLTM0NyBiIDkyIDAgNzIgLTIzNCA5MiAtMTE3IGIgMzEgMzM1IDkyIDExNiA3MiAyMzMgYiAyNSAzNTYgMjcgMzQ1IDI1IDM1MiBiIDM0IDM2OSAyNSAzNjMgMjggMzY2IFwifSxcInY4NlwiOntcInhfbWluXCI6LTU3MS42NzE4NzUsXCJ4X21heFwiOjU3MC4zMTI1LFwiaGFcIjo1ODIsXCJvXCI6XCJtIC0zODYgMTczIGIgLTM4MSAxNzQgLTM4NSAxNzQgLTM4MyAxNzQgYiAtMzcwIDE3MyAtMzc3IDE3NCAtMzcyIDE3MyBiIC0yODEgODYgLTM2NyAxNzIgLTM0NyAxNTEgYiAtMTk2IDAgLTIzNSAzNyAtMTk2IDAgYiAtMTI2IDg0IC0xOTYgMCAtMTY0IDM3IGIgLTUwIDE3NCAtNTUgMTczIC01NyAxNzIgYiAtNDQgMTc0IC00OSAxNzQgLTQ3IDE3NCBiIC0zNSAxNzMgLTQyIDE3NCAtMzggMTczIGIgNTMgODYgLTMyIDE3MiAtMTIgMTUxIGIgMTM4IDAgMTAwIDM3IDEzOCAwIGIgMjA4IDg0IDE0MCAwIDE3MCAzNyBiIDI4NCAxNzQgMjc5IDE3MyAyNzcgMTcyIGIgMjg5IDE3NCAyODUgMTc0IDI4OCAxNzQgYiAyOTkgMTczIDI5NCAxNzQgMjk4IDE3MyBiIDQ2MiAxMSAzMDMgMTcyIDMzOCAxMzQgbCA0NzUgLTEgbCA1MDMgMzQgYiA1NDEgNzYgNTM0IDcyIDUzNiA3NCBiIDU0OCA3NyA1NDQgNzcgNTQ1IDc3IGIgNTcwIDU2IDU2MCA3NyA1NzAgNjggYiA1NjcgNDggNTcwIDU0IDU2OCA1MSBiIDM5MiAtMTcyIDU2NCA0MSAzOTcgLTE2NiBiIDM3OCAtMTc2IDM4NyAtMTc0IDM4MiAtMTc2IGIgMzY4IC0xNzQgMzc0IC0xNzYgMzcxIC0xNzYgYiAyODAgLTg3IDM2NyAtMTczIDM0NSAtMTUyIGIgMTk0IDAgMjM0IC0zOCAxOTQgMCBiIDEyNSAtODYgMTk0IDAgMTYzIC0zOCBiIDQ5IC0xNzQgNTQgLTE3NCA1NSAtMTczIGIgNDMgLTE3NiA0NyAtMTc2IDQ2IC0xNzYgYiAzNCAtMTc0IDQwIC0xNzYgMzYgLTE3NCBiIC01NCAtODcgMzEgLTE3MyAxMCAtMTUyIGIgLTE0MCAwIC0xMDIgLTM4IC0xNDAgMCBiIC0yMDkgLTg2IC0xNDEgMCAtMTcxIC0zOCBiIC0yODUgLTE3NCAtMjgwIC0xNzQgLTI3OSAtMTczIGIgLTI5MSAtMTc2IC0yODcgLTE3NiAtMjg5IC0xNzYgYiAtMzAwIC0xNzQgLTI5NSAtMTc2IC0yOTkgLTE3NCBiIC00NjQgLTEyIC0zMDQgLTE3MyAtMzQwIC0xMzcgbCAtNDc2IDAgbCAtNTA0IC0zNCBiIC01NDMgLTc3IC01MzQgLTczIC01MzcgLTc2IGIgLTU0OSAtNzkgLTU0NSAtNzkgLTU0NyAtNzkgYiAtNTcxIC01OCAtNTYyIC03OSAtNTcxIC02OSBiIC01NjggLTQ5IC01NzEgLTU1IC01NzAgLTUyIGIgLTM5MiAxNzIgLTU2NiAtNDMgLTM5NiAxNjcgYiAtMzg2IDE3MyAtMzkwIDE3MiAtMzg3IDE3MyBcIn0sXCJ2OGFcIjp7XCJ4X21pblwiOi0xNzAuMTQwNjI1LFwieF9tYXhcIjoxNjguNzgxMjUsXCJoYVwiOjE3MixcIm9cIjpcIm0gLTE2MCA1NjcgYiAtMTIyIDU2NyAtMTU5IDU2NyAtMTQ5IDU2NyBsIC04NyA1NjcgbCAtODQgNTY2IGIgLTc0IDU1MyAtNzggNTYzIC03NyA1NjAgYiAtMjAgMzY2IC03MyA1NTEgLTQ5IDQ2NiBiIDMxIDE4NiA4IDI2NyAzMSAxODYgYiA4NSAzNzEgMzEgMTg2IDU1IDI2OSBiIDE0MCA1NTkgMTE0IDQ3MyAxMzggNTU3IGIgMTUzIDU2NyAxNDEgNTY0IDE0OCA1NjcgYiAxNjggNTU5IDE1OSA1NjcgMTY2IDU2NCBiIDE2OCA1NTUgMTY4IDU1NyAxNjggNTU3IGIgOTIgMjgxIDE2OCA1NDggMTU5IDUxMyBiIDE0IDEzIDUwIDEzNCAxNCAxMyBiIDAgMCAxNCA2IDYgMCBiIC0xNyAxNSAtOCAwIC0xNyA4IGIgLTkzIDI4MyAtMTcgMTUgLTUxIDEzNiBiIC0xNzAgNTUyIC0xNjYgNTMzIC0xNzAgNTQ4IGIgLTE3MCA1NTMgLTE3MCA1NTIgLTE3MCA1NTIgYiAtMTYwIDU2NyAtMTcwIDU2MCAtMTY3IDU2NCBcIn0sXCJ2OGJcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjMxOS44NTkzNzUsXCJoYVwiOjMyNixcIm9cIjpcIm0gMTQ5IDUwOCBiIDE1OSA1MDkgMTUyIDUwOSAxNTUgNTA5IGIgMTg2IDQ5NCAxNzAgNTA5IDE4MSA1MDMgYiAxOTAgNDQwIDE5MCA0ODcgMTkwIDQ4OCBsIDE5MCA0MzAgbCAxOTAgMzc3IGwgMjQyIDM3NyBsIDI1MSAzNzcgYiAzMDMgMzczIDI5OCAzNzcgMjk2IDM3NyBiIDMxOSAzNDUgMzE0IDM2NyAzMTkgMzU2IGIgMzA0IDMxOSAzMTkgMzM1IDMxNCAzMjQgYiAyNTAgMzE1IDI5NiAzMTUgMjk5IDMxNSBsIDI0MiAzMTUgbCAxOTAgMzE1IGwgMTkwIDI2MiBsIDE5MCAyNTIgYiAxODYgMTk4IDE5MCAyMDQgMTkwIDIwNSBiIDE1OSAxODMgMTc5IDE4OCAxNzAgMTgzIGIgMTMyIDE5OCAxNDggMTgzIDEzOCAxODggYiAxMjcgMjUyIDEyNyAyMDUgMTI3IDIwNCBsIDEyNyAyNjIgbCAxMjcgMzE1IGwgNzYgMzE1IGwgNjggMzE1IGIgMTQgMzE5IDIwIDMxNSAyMSAzMTUgYiAwIDM0NyA0IDMyNCAwIDMzNSBiIDE0IDM3MyAwIDM1NiA0IDM2NyBiIDY4IDM3NyAyMSAzNzcgMjAgMzc3IGwgNzYgMzc3IGwgMTI3IDM3NyBsIDEyNyA0MzAgbCAxMjcgNDQwIGIgMTMyIDQ5NCAxMjcgNDg4IDEyNyA0ODcgYiAxNDkgNTA4IDEzNiA1MDEgMTQyIDUwNSBcIn0sXCJ2OGNcIjp7XCJ4X21pblwiOi0zMzAuNzUsXCJ4X21heFwiOjMyOS4zOTA2MjUsXCJoYVwiOjMzNixcIm9cIjpcIm0gLTEzMyA0ODMgYiAtMTE3IDQ4NCAtMTI3IDQ4NCAtMTIyIDQ4NCBiIDMxIDM3MyAtNTEgNDg0IDkgNDQwIGIgMzUgMzQ4IDM0IDM2NSAzNSAzNTYgYiAtMjUgMjg1IDM1IDMxMyAxMCAyODUgYiAtODcgMzMxIC01NSAyODUgLTc2IDMwMiBiIC0xNjcgNDAyIC0xMDAgMzc2IC0xMzMgNDAyIGIgLTE5MSAzOTggLTE3NSA0MDIgLTE4MyA0MDEgYiAtMjI3IDM0MSAtMjE1IDM4OCAtMjI3IDM2OSBiIC0yMjUgMzIwIC0yMjcgMzM0IC0yMjcgMzI3IGIgLTEzIDc0IC0yMDkgMjMwIC0xMjUgMTMzIGIgNiA2NSAtNCA3MCA1IDY2IGwgOSA2MyBsIDEwIDY1IGIgMTE3IDIzMSAxMiA2OCA0MCAxMTIgbCAxODkgMzQxIGwgMjQyIDQyNCBiIDI2OCA0NjAgMjYyIDQ1NiAyNjQgNDU4IGIgMjgzIDQ2NCAyNzMgNDYzIDI3NyA0NjQgYiAzMDggNDM4IDI5NiA0NjQgMzA4IDQ1MyBsIDMwOCA0MzcgYiAyODcgMzk2IDMwOCA0MzAgMzA4IDQyOCBsIDk1IDk4IGwgNTkgNDMgbCA1OCA0MSBsIDY1IDM3IGIgMjUzIC0xNTYgMTUxIC04IDIxNyAtNzcgYiAyODEgLTI4NSAyNzIgLTE5OSAyODEgLTI0NCBiIDE0OCAtNDgxIDI4MSAtMzgxIDIzMSAtNDYzIGIgMTE1IC00ODUgMTM3IC00ODQgMTI2IC00ODUgYiAtMzIgLTM3NiA1MSAtNDg1IC05IC00NDIgYiAtMzYgLTM0OSAtMzUgLTM2NiAtMzYgLTM1OCBiIDI1IC0yODcgLTM2IC0zMTUgLTEyIC0yODcgYiA4NSAtMzMzIDU0IC0yODcgNzQgLTMwMiBiIDE2NiAtNDAzIDk5IC0zNzcgMTMzIC00MDMgYiAxOTAgLTM5OSAxNzQgLTQwMyAxODIgLTQwMiBiIDIyNSAtMzQyIDIxNSAtMzkwIDIyNSAtMzcwIGIgMjI0IC0zMjIgMjI1IC0zMzUgMjI1IC0zMjggYiAxMiAtNzYgMjA4IC0yMzEgMTI1IC0xMzQgYiAtOCAtNjYgMiAtNzIgLTYgLTY4IGwgLTEwIC02NSBsIC0xMiAtNjYgYiAtMTE4IC0yMzEgLTEzIC02OCAtNDIgLTExMyBsIC0xOTAgLTM0MiBsIC0yNDMgLTQyNiBiIC0yNjkgLTQ2MiAtMjY0IC00NTggLTI2NSAtNDU4IGIgLTI4NCAtNDY2IC0yNzQgLTQ2NCAtMjc5IC00NjYgYiAtMzEwIC00NDAgLTI5OCAtNDY2IC0zMTAgLTQ1NSBsIC0zMTAgLTQzOCBiIC0yODggLTM5OCAtMzEwIC00MzAgLTMwOCAtNDMwIGwgLTk2IC05OSBsIC01OSAtNDQgbCAtNTkgLTQzIGwgLTY2IC0zOCBiIC0yODEgMjg0IC0xOTggMzMgLTI4MSAxNTggbCAtMjgxIDI4NCBiIC0xMzMgNDgzIC0yODEgMzkyIC0yMjAgNDc0IG0gMjU0IDE3NyBiIDI2NiAxNzkgMjU4IDE3NyAyNjIgMTc5IGIgMzE5IDE0OSAyODcgMTc5IDMwNyAxNjcgYiAzMjkgMTE1IDMyNiAxNDAgMzI5IDEyNyBiIDMxOSA3OSAzMjkgMTAyIDMyNiA5MCBiIDI2OCA1MSAzMDcgNjEgMjg3IDUxIGIgMjIxIDcyIDI1MCA1MSAyMzQgNTggYiAyMDUgMTE1IDIxMCA4NCAyMDUgOTkgYiAyNTQgMTc3IDIwNSAxNDIgMjIzIDE3MCBtIC0yODEgLTU0IGIgLTI2OSAtNTIgLTI3NyAtNTIgLTI3MyAtNTIgYiAtMjIzIC03MyAtMjUzIC01MiAtMjM1IC01OSBiIC0yMDYgLTExNiAtMjEyIC04NCAtMjA2IC0xMDEgYiAtMjE2IC0xNTEgLTIwNiAtMTI5IC0yMDkgLTE0MSBiIC0yNjkgLTE3OSAtMjI4IC0xNzAgLTI0OSAtMTc5IGIgLTMxNCAtMTU5IC0yODUgLTE3OSAtMzAyIC0xNzMgYiAtMzMwIC0xMTYgLTMyNSAtMTQ3IC0zMzAgLTEzMSBiIC0yODEgLTU0IC0zMzAgLTg4IC0zMTMgLTYxIFwifSxcInY4ZlwiOntcInhfbWluXCI6LTIxLjc4MTI1LFwieF9tYXhcIjozNjIuMDYyNSxcImhhXCI6MzY5LFwib1wiOlwibSAzMDIgMTAzMSBiIDMwOCAxMDMyIDMwNCAxMDMyIDMwNyAxMDMyIGIgMzMwIDEwMTYgMzE4IDEwMzIgMzI1IDEwMjcgYiAzNjIgODY3IDM1MSA5NzAgMzYyIDkyMCBiIDM0MCA3MzggMzYyIDgyNCAzNTMgNzgwIGwgMzM2IDcyNyBsIDM0MCA3MTcgYiAzNjIgNTkxIDM1NSA2NzcgMzYyIDYzNCBiIDI1NyAzMjMgMzYyIDQ5NiAzMjUgNDAxIGIgMjA0IDI3MiAyNDMgMzA2IDIyNyAyOTAgYiAyMCA1NiAxMjkgMjA2IDY2IDEzMyBiIC0xIDE4IDEyIDQ0IDAgMjIgYiAtMTkgNCAtNCA5IC0xMiA0IGwgLTIxIDQgbCAtMjEgMTQwIGwgLTIxIDI3NiBsIC0xMiAyNzcgYiAxNjcgMzMzIDYxIDI4OCAxMjcgMzA5IGIgMzE5IDU5OCAyNjIgMzg4IDMxOSA0OTEgYiAzMTEgNjY0IDMxOSA2MjAgMzE3IDY0MiBsIDMxMCA2NzMgbCAzMDQgNjY0IGIgMjA0IDU0OCAyNzkgNjIwIDI1MCA1ODcgYiAyMCAzMzMgMTI5IDQ4MyA2NiA0MDkgYiAtMSAyOTIgMTIgMzIwIDAgMjk4IGIgLTE5IDI4MCAtNCAyODUgLTEyIDI4MCBsIC0yMSAyODAgbCAtMjEgNDE2IGwgLTIxIDU1MiBsIC0xMiA1NTMgYiAxNjcgNjA5IDYxIDU2NCAxMjcgNTg1IGIgMzE5IDg3NCAyNjQgNjY2IDMxOSA3NzAgYiAyOTQgOTkyIDMxOSA5MTQgMzExIDk1NCBiIDI4OCAxMDExIDI4OCAxMDA0IDI4OCAxMDA3IGIgMzAyIDEwMzEgMjg4IDEwMjEgMjk0IDEwMjggXCJ9LFwidjkwXCI6e1wieF9taW5cIjotMTcxLjUsXCJ4X21heFwiOjQ4My4xODc1LFwiaGFcIjo0OTMsXCJvXCI6XCJtIC04IDYzMSBiIC0xIDYzMiAtNiA2MzIgLTQgNjMyIGIgMTkgNjIwIDggNjMyIDE2IDYyOCBiIDIwIDQ5NSAyMCA2MTYgMjAgNjE2IGIgMjAgMzczIDIwIDQyNyAyMCAzNzMgYiAxMTUgNDEwIDIwIDM3MyA2MyAzOTAgbCAyMTAgNDQ4IGwgMjEwIDUzMSBiIDIxMiA2MjAgMjEwIDYxNCAyMTAgNjE2IGIgMjMxIDYzMiAyMTUgNjI4IDIyMyA2MzIgYiAyNDYgNjI3IDIzNiA2MzIgMjQyIDYzMSBiIDI1MSA1NDEgMjUxIDYyMCAyNTEgNjI4IGwgMjUxIDQ2MyBsIDMxNSA0ODkgYiAzODcgNTE0IDM2OCA1MDkgMzgxIDUxNCBiIDM5MyA1MTMgMzkwIDUxNCAzOTIgNTE0IGIgNDA2IDQ5NCA0MDIgNTEwIDQwNiA1MDIgYiAzOTcgNDc2IDQwNiA0ODcgNDA0IDQ4MCBiIDMyMyA0NDYgMzk2IDQ3NCAzNjMgNDYyIGwgMjUxIDQxNyBsIDI1MSAyODMgbCAyNTEgMTQ4IGwgMjU0IDE1MSBiIDM3MCAxOTkgMjkxIDE4MyAzMzIgMTk5IGIgNDE1IDE5MSAzODUgMTk5IDQwMCAxOTcgYiA0ODMgODQgNDU4IDE3NiA0ODMgMTM0IGIgNDYxIDAgNDgzIDU4IDQ3NiAyOSBiIDMzMiAtMTQyIDQzOSAtNDAgNDExIC03MiBsIDI1NSAtMjE1IGIgMjMxIC0yMjkgMjQwIC0yMjkgMjM5IC0yMjkgYiAyMTYgLTIyMyAyMjQgLTIyOSAyMjAgLTIyNyBiIDIxMCAtMTU4IDIxMCAtMjE3IDIxMCAtMjIzIGIgMjEwIC0xMjAgMjEwIC0xNDggMjEwIC0xMzYgbCAyMTAgLTI5IGwgMjA1IC0zNCBiIDEwMCAtMTQyIDE4MiAtNjUgMTU5IC04OCBsIDIzIC0yMTUgYiAtMSAtMjI5IDkgLTIyOSA2IC0yMjkgYiAtMTkgLTIxNyAtOSAtMjI5IC0xNiAtMjI0IGwgLTIwIC0yMTUgbCAtMjEgNDggbCAtMjEgMzEwIGwgLTgzIDI4NyBiIC0xNTIgMjYyIC0xMzMgMjY2IC0xNDUgMjYyIGIgLTE1NyAyNjMgLTE1MyAyNjIgLTE1NSAyNjIgYiAtMTcxIDI4MyAtMTY2IDI2NiAtMTcxIDI3NCBiIC0xNjEgMzAxIC0xNzEgMjkwIC0xNjcgMjk3IGIgLTkxIDMyOCAtMTYwIDMwMiAtMTI5IDMxNSBsIC0yMSAzNTYgbCAtMjEgNDg3IGwgLTIwIDYxNyBsIC0xOSA2MjEgYiAtOCA2MzEgLTE3IDYyNiAtMTIgNjMwIG0gMjEwIDI4OCBiIDIxMCA0MDEgMjEwIDM1MSAyMTAgNDAxIGIgMTE0IDM2NSAyMDkgNDAxIDE2NyAzODQgbCAyMCAzMjcgbCAyMCAyMzggbCAyMCAxNDggbCAyMSAxNTEgYiAxNDAgMTk5IDU5IDE4MyAxMDIgMTk5IGIgMjA2IDE4MCAxNjQgMTk5IDE4NyAxOTIgbCAyMDkgMTc3IGIgMjA5IDE3NyAyMDkgMTc3IDIwOSAxNzcgYiAyMTAgMjg4IDIxMCAxNzcgMjEwIDE5OSBtIDExMCAxMzEgYiA5NiAxMzMgMTA2IDEzMyAxMDAgMTMzIGIgODkgMTMzIDkzIDEzMyA5MSAxMzMgYiAyNCA4NyA2MyAxMjkgNDAgMTEzIGwgMjAgODAgbCAyMCAtMzcgbCAyMCAtMTU2IGwgMjMgLTE1MiBiIDE0NCA4MSA5NiAtNzIgMTQ0IDIwIGwgMTQ0IDgzIGIgMTEwIDEzMSAxNDQgMTEzIDEzNCAxMjYgbSAzNDEgMTMxIGIgMzI4IDEzMyAzMzcgMTMzIDMzMiAxMzMgYiAzMjIgMTMzIDMyNiAxMzMgMzIzIDEzMyBiIDI1NyA4NyAyOTYgMTI5IDI3MyAxMTMgbCAyNTEgODAgbCAyNTEgLTM3IGwgMjUxIC0xNTYgbCAyNTUgLTE1MiBiIDM3NSA4MSAzMjggLTcyIDM3NSAyMCBsIDM3NSA4MyBiIDM0MSAxMzEgMzc1IDExMyAzNjcgMTI2IFwifSxcInY5MlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NTk4Ljg5MDYyNSxcImhhXCI6NjExLFwib1wiOlwibSA2MiAxODEgYiA3NyAxODMgNjYgMTgzIDcyIDE4MyBiIDkxIDE4MSA4MyAxODMgODggMTgzIGIgMjAyIDEzMSAxMDAgMTgwIDEwNiAxNzcgbCAyOTkgODcgbCAzOTQgMTMxIGIgNTE3IDE4MyA0OTkgMTgxIDUwMiAxODMgYiA1MTkgMTgzIDUxNyAxODMgNTE4IDE4MyBiIDU5OCAxMDQgNTY3IDE4MyA1OTggMTQ0IGIgNTc3IDQ5IDU5OCA4NCA1OTIgNjUgYiA1MTggMTUgNTY3IDM4IDU2MyAzNyBiIDQ4NCAwIDQ5OSA2IDQ4NCAwIGIgNTE4IC0xNiA0ODQgLTEgNDk5IC04IGIgNTc3IC01MSA1NjMgLTM4IDU2NyAtNDAgYiA1OTggLTEwNSA1OTIgLTY2IDU5OCAtODYgYiA1MTkgLTE4NCA1OTggLTE0NSA1NjcgLTE4NCBiIDUxNyAtMTg0IDUxOCAtMTg0IDUxNyAtMTg0IGIgMzk0IC0xMzMgNTAyIC0xODQgNDk5IC0xODMgbCAyOTkgLTg4IGwgMjAyIC0xMzMgYiA4MSAtMTg0IDk5IC0xODMgOTUgLTE4NCBiIDc3IC0xODQgODAgLTE4NCA3OCAtMTg0IGIgMCAtMTA1IDI5IC0xODQgMCAtMTQ1IGIgMjAgLTUxIDAgLTg2IDUgLTY2IGIgODAgLTE2IDI5IC00MCAzNCAtMzggYiAxMTQgLTEgOTggLTggMTE0IC0xIGIgODAgMTUgMTE0IDAgOTggNiBiIDIwIDQ5IDM0IDM3IDI5IDM4IGIgMCAxMDQgNiA2NSAwIDg0IGIgNjIgMTgxIDAgMTQwIDIzIDE3NCBtIDg4IDEzNCBiIDc0IDEzNiA4NSAxMzQgODAgMTM2IGIgNjggMTM0IDcyIDEzNiA2OSAxMzYgYiA0NiAxMDQgNTQgMTMwIDQ2IDExNyBiIDU1IDgxIDQ2IDk1IDQ5IDg4IGIgMTQ5IDM0IDU5IDc2IDUzIDgwIGIgMjI0IC0xIDE5MCAxNSAyMjQgMCBiIDE0NCAtMzggMjI0IC0xIDE4NyAtMTggYiA1NCAtODQgNTkgLTc5IDU4IC03OSBiIDQ2IC0xMDUgNDkgLTkwIDQ2IC05OCBiIDc2IC0xMzcgNDYgLTEyMiA1OCAtMTM3IGIgNzggLTEzNyA3NyAtMTM3IDc3IC0xMzcgYiAxOTQgLTg2IDg3IC0xMzcgNzYgLTE0MSBiIDI5OCAtMzYgMjUwIC01OCAyOTggLTM2IGIgMjk4IC0zNiAyOTggLTM2IDI5OCAtMzYgYiA0MDIgLTg0IDI5OSAtMzYgMzQ1IC01OCBiIDUxOCAtMTM3IDUyMiAtMTQxIDUxMCAtMTM3IGIgNTIxIC0xMzcgNTE5IC0xMzcgNTE5IC0xMzcgYiA1NTEgLTEwNSA1MzkgLTEzNyA1NTEgLTEyMiBiIDU0MSAtODMgNTUxIC05OCA1NDggLTkwIGIgNDQ3IC0zNiA1MzcgLTc3IDU0NCAtODEgYiAzNzQgLTEgNDA2IC0xNiAzNzQgLTEgYiA0NDcgMzQgMzc0IDAgNDA2IDE1IGIgNTQxIDgxIDU0NCA4MCA1MzcgNzYgYiA1NTEgMTA0IDU0OCA4OCA1NTEgOTcgYiA1MjEgMTM2IDU1MSAxMjAgNTM5IDEzNiBiIDUxOCAxMzYgNTE5IDEzNiA1MTkgMTM2IGIgNTE3IDEzNiA1MTggMTM2IDUxNyAxMzYgbCA1MTcgMTM2IGIgNDAyIDgzIDUxMSAxMzYgNTExIDEzNiBiIDI5OCAzNCAzNDUgNTYgMjk5IDM0IGIgMjk4IDM0IDI5OCAzNCAyOTggMzQgYiAxOTQgODQgMjk4IDM0IDI1MCA1NiBiIDg4IDEzNCAxMzcgMTExIDg5IDEzMyBcIn0sXCJ2OTNcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQzOC4yODEyNSxcImhhXCI6NDQ3LFwib1wiOlwibSAyMTIgMjA1IGIgMjE5IDIwNSAyMTMgMjA1IDIxNiAyMDUgYiAyMzkgMTgzIDIyOCAyMDUgMjMxIDIwNCBiIDQyMSAtMTYzIDI5OCA0MCAzNjMgLTgzIGIgNDM4IC0xOTEgNDM0IC0xODAgNDM4IC0xODYgYiA0MzYgLTE5NyA0MzggLTE5MiA0MzggLTE5NSBiIDQyNCAtMjA2IDQzNCAtMjA0IDQzMSAtMjA2IGIgNDA2IC0yMDEgNDIwIC0yMDYgNDE1IC0yMDUgYiAyMTYgLTE1NiAzNDcgLTE3MiAyODEgLTE1NiBiIDIzIC0yMDUgMTQ4IC0xNTYgODAgLTE3MyBiIDE0IC0yMDYgMjAgLTIwNiAxNyAtMjA2IGIgMCAtMTkxIDYgLTIwNiAwIC0yMDEgYiA2IC0xNzYgMCAtMTg3IDEgLTE4MyBiIDIwMiAxOTIgNjMgLTEwNCAxNDIgNDUgYiAyMTIgMjA1IDIwNSAxOTkgMjA4IDIwMiBtIDI2NCA0OCBsIDI0OSA4MSBsIDI0MyA5NCBsIDI0MiA5MSBiIDg5IC0xMjYgMjA4IDM2IDEzNyAtNjYgYiA4MSAtMTM4IDg1IC0xMzMgODEgLTEzOCBiIDgxIC0xMzggODEgLTEzOCA4MSAtMTM4IGIgODEgLTEzOCA4MSAtMTM4IDgxIC0xMzggYiA5NSAtMTMzIDgxIC0xMzggODcgLTEzNiBiIDI4MCAtOTQgMTU2IC0xMDggMjIxIC05NCBiIDMzNCAtOTggMjk5IC05NCAzMTcgLTk1IGIgMzQzIC05OSAzMzggLTk5IDM0MyAtOTkgYiAzNDMgLTk5IDM0MyAtOTkgMzQzIC05OSBiIDMzOCAtOTQgMzQzIC05OSAzNDEgLTk3IGIgMjY0IDQ4IDMxOCAtNTggMjg3IDEgXCJ9LFwidjk0XCI6e1wieF9taW5cIjotMTQ5LjcxODc1LFwieF9tYXhcIjoxNDguMzU5Mzc1LFwiaGFcIjoxNTEsXCJvXCI6XCJtIC05IDIxNSBiIDAgMjE3IC02IDIxNyAtNCAyMTcgYiAxOSAyMDUgOCAyMTcgMTQgMjEzIGIgMjAgMTQyIDIwIDIwMiAyMCAyMDEgbCAyMCA4NCBsIDIzIDg0IGIgMTQ0IC0yNyA4MSA3NCAxMjkgMzAgYiAxNDggLTY2IDE0NyAtNDAgMTQ4IC01NCBiIDM2IC0yMTMgMTQ4IC0xMzQgMTAzIC0xOTcgYiAwIC0yMTkgMjQgLTIxNyAxMiAtMjE5IGIgLTE0NSAtMTA0IC02OCAtMjE5IC0xMjkgLTE3MyBiIC0xNDkgLTY4IC0xNDggLTkxIC0xNDkgLTc5IGIgLTI0IDg0IC0xNDkgNiAtOTggNzQgbCAtMjEgODQgbCAtMjEgMTQyIGIgLTE5IDIwNSAtMjAgMjAxIC0yMCAyMDIgYiAtOSAyMTUgLTE3IDIwOSAtMTMgMjEzIG0gLTIxIC0xNSBiIC0yMyA0MSAtMjEgMzcgLTIxIDQxIGIgLTIzIDQxIC0yMyA0MSAtMjMgNDEgYiAtNzYgMTEgLTM1IDQwIC02MiAyNiBiIC0xMDggLTY1IC05OCAtMTEgLTEwOCAtMzggYiAtMSAtMTc2IC0xMDggLTEyMiAtNjUgLTE3NiBiIDEwNyAtNjUgNjMgLTE3NiAxMDcgLTEyMiBiIDc0IDExIDEwNyAtMzggOTYgLTExIGIgMjAgNDEgNjEgMjYgMzIgNDEgYiAyMCAtMTUgMjAgNDEgMjAgMTUgYiAxOSAtNzQgMjAgLTcyIDIwIC03MiBiIDAgLTg3IDE0IC04MyA2IC04NyBiIC0xOSAtNzQgLTggLTg3IC0xNiAtODMgYiAtMjEgLTE1IC0yMCAtNzIgLTIwIC03MiBcIn0sXCJ2OTVcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQwNi45Njg3NSxcImhhXCI6NDE1LFwib1wiOlwibSA1NSAxODEgYiA3MCAxODMgNjEgMTgzIDY2IDE4MyBiIDExMSAxNzAgODUgMTgzIDk5IDE3OSBiIDE2MCAxMzAgMTE1IDE2NyAxMzcgMTQ5IGwgMjAyIDk1IGwgMjQ1IDEzMCBiIDMxOSAxODEgMjk5IDE3NiAzMDIgMTc5IGIgMzM0IDE4MyAzMjUgMTgzIDMzMCAxODMgYiA0MDYgMTA5IDM3NSAxODMgNDA2IDE0OCBiIDQwMSA4MSA0MDYgOTkgNDA1IDkxIGIgMzQ4IDI0IDM5NCA2NSAzOTAgNTkgYiAzMTggLTEgMzMyIDExIDMxOCAwIGIgMzQ4IC0yNiAzMTggLTEgMzMyIC0xMiBiIDQwMSAtODMgMzkwIC02MSAzOTQgLTY2IGIgNDA2IC0xMTEgNDA1IC05MyA0MDYgLTEwMSBiIDMzNCAtMTg0IDQwNiAtMTQ5IDM3NSAtMTg0IGIgMzE5IC0xODMgMzMwIC0xODQgMzI1IC0xODQgYiAyNDUgLTEzMSAzMDIgLTE4MCAyOTkgLTE3NyBsIDIwMiAtOTcgbCAxNjAgLTEzMSBiIDg1IC0xODMgMTA3IC0xNzcgMTAzIC0xODAgYiA3MCAtMTg0IDgwIC0xODQgNzYgLTE4NCBiIDAgLTExMSAzMSAtMTg0IDAgLTE0OSBiIDQgLTgzIDAgLTEwMSAxIC05MyBiIDU4IC0yNiAxMCAtNjYgMTYgLTYxIGIgODggLTEgNzQgLTEyIDg4IC0xIGIgNTggMjQgODggMCA3NCAxMSBiIDEwIDY5IDIzIDU0IDE3IDU5IGIgMCAxMDkgMiA4MSAwIDk1IGIgNTUgMTgxIDAgMTQyIDIxIDE3MyBtIDgzIDEzMyBiIDcyIDEzNiA3OCAxMzYgNzYgMTM2IGIgNTcgMTMxIDY2IDEzNiA2MSAxMzQgYiA0NiAxMDkgNDkgMTI2IDQ2IDExNyBiIDUwIDkzIDQ2IDEwNCA0NyA5OCBiIDEwNyA0NSA1MSA5MSA3NyA3MCBiIDE2MCAwIDEzNyAyMCAxNjAgMCBiIDEwNyAtNDcgMTYwIC0xIDEzNyAtMjIgYiA1MCAtOTQgNzcgLTcyIDUxIC05MyBiIDQ2IC0xMTEgNDcgLTk5IDQ2IC0xMDUgYiA1OSAtMTM0IDQ2IC0xMjAgNTAgLTEzMCBiIDcyIC0xMzcgNjIgLTEzNiA2OCAtMTM3IGIgODMgLTEzNiA3NiAtMTM3IDgwIC0xMzYgYiAxNDQgLTg0IDg0IC0xMzQgMTA3IC0xMTYgYiAyMDIgLTM2IDE3NiAtNTggMjAyIC0zNiBiIDI2MSAtODQgMjAyIC0zNiAyMzAgLTU4IGIgMzIzIC0xMzYgMjk5IC0xMTYgMzIxIC0xMzQgYiAzMzQgLTEzNyAzMjYgLTEzNiAzMzAgLTEzNyBiIDM0NSAtMTM0IDMzOCAtMTM3IDM0MyAtMTM2IGIgMzYwIC0xMTEgMzU1IC0xMzAgMzYwIC0xMjAgYiAzNTUgLTk0IDM2MCAtMTA1IDM1OSAtOTkgYiAyOTkgLTQ3IDM1MyAtOTMgMzI5IC03MiBiIDI0NSAwIDI2OSAtMjIgMjQ1IC0xIGIgMjk5IDQ1IDI0NSAwIDI2OSAyMCBiIDM1NSA5MyAzMjkgNzAgMzUzIDkxIGIgMzYwIDEwOSAzNTkgOTggMzYwIDEwNCBiIDM0NSAxMzMgMzYwIDExOSAzNTUgMTI5IGIgMzM0IDEzNiAzNDMgMTM0IDMzOCAxMzYgYiAzMjMgMTM0IDMzMCAxMzYgMzI2IDEzNCBiIDI2MSA4MyAzMjEgMTMzIDI5OSAxMTUgYiAyMDIgMzQgMjMwIDU2IDIwMiAzNCBiIDE0NCA4MyAyMDIgMzQgMTc2IDU2IGIgODMgMTMzIDEwNiAxMTUgODQgMTMzIFwifSxcInY5N1wiOntcInhfbWluXCI6LTIyOC42NzE4NzUsXCJ4X21heFwiOjIyNy4zMTI1LFwiaGFcIjoyMzIsXCJvXCI6XCJtIC0yMTcgNDg3IGwgLTIxMyA0ODggbCAwIDQ4OCBsIDIxMiA0ODggbCAyMTYgNDg3IGIgMjI1IDQ3NiAyMjAgNDg0IDIyNCA0ODAgbCAyMjcgNDczIGwgMjI3IDI0NCBsIDIyNyAxNSBsIDIyNSAxMiBiIDIwNiAwIDIyMyA0IDIxNSAwIGIgMTk3IDEgMjA0IDAgMjAwIDAgYiAxODcgMTIgMTkzIDQgMTg5IDYgbCAxODYgMTUgbCAxODYgMTM4IGwgMTg2IDI2MiBsIC0xIDI2MiBsIC0xODcgMjYyIGwgLTE4NyAxMzggbCAtMTg3IDE1IGwgLTE4OSAxMiBiIC0yMDggMCAtMTkzIDQgLTIwMCAwIGIgLTIyNyAxMiAtMjE2IDAgLTIyMyA0IGwgLTIyOCAxNSBsIC0yMjggMjQ0IGwgLTIyOCA0NzMgbCAtMjI3IDQ3NiBiIC0yMTcgNDg3IC0yMjUgNDgwIC0yMjEgNDg0IFwifSxcInY5YVwiOntcInhfbWluXCI6LTIxLjc4MTI1LFwieF9tYXhcIjozNjcuNSxcImhhXCI6Mzc1LFwib1wiOlwibSAyMzAgMTAzMSBiIDIzOCAxMDMyIDIzMiAxMDMyIDIzNSAxMDMyIGIgMjU5IDEwMTQgMjQ1IDEwMzIgMjUxIDEwMjcgYiAzNjcgNjYyIDMzMCA5MDYgMzY3IDc4MiBiIDM2NCA2MDIgMzY3IDY0MSAzNjcgNjIxIGIgMjMyIDMxNyAzNTIgNDg4IDMwNCAzODQgYiA1NyAxMjAgMTU1IDI0NSAxMDMgMTg3IGIgLTEgMTggMzEgODQgNiA0MCBiIC0xOSA0IC00IDExIC0xMiA0IGwgLTIxIDQgbCAtMjEgMTU5IGwgLTIxIDMxNSBsIC0xNiAzMTUgYiA5NiAzMzUgMTAgMzE1IDYyIDMyNCBiIDMxNSA2OTUgMjI3IDM4MCAzMTUgNTI3IGIgMzEzIDczOCAzMTUgNzA5IDMxNCA3MjQgYiAyMjQgOTkxIDMwNCA4MjUgMjczIDkxNiBiIDIxNiAxMDEzIDIxOSA5OTkgMjE2IDEwMDcgYiAyMzAgMTAzMSAyMTYgMTAyMSAyMjAgMTAyOCBcIn0sXCJ2OWJcIjp7XCJ4X21pblwiOi0yNC41LFwieF9tYXhcIjozMTMuMDYyNSxcImhhXCI6MzE5LFwib1wiOlwibSAtMjQgLTEzMyBsIC0yNCAtNSBsIC0yMCAtNSBiIC0xIC0xOSAtMTIgLTUgLTQgLTExIGIgMTQyIC0yMTMgMTMgLTYxIDc0IC0xNDQgYiAyNTggLTM3NiAxOTYgLTI2OSAyMzAgLTMxNSBiIDMxMyAtNjA1IDI5NSAtNDQ5IDMxMyAtNTI4IGIgMjkyIC03NDIgMzEzIC02NTIgMzA2IC02OTkgYiAyODggLTc1MiAyODkgLTc0OCAyODggLTc1MiBiIDI4OCAtNzUyIDI4OCAtNzUyIDI4OCAtNzUyIGIgMjkyIC03NjQgMjg5IC03NTMgMjkxIC03NTcgYiAzMTMgLTkwNyAzMDYgLTgxMSAzMTMgLTg2MCBiIDI5MiAtMTA0NSAzMTMgLTk1NCAzMDYgLTEwMDIgYiAyODggLTEwNTQgMjg5IC0xMDUwIDI4OCAtMTA1NCBiIDI4OCAtMTA1NCAyODggLTEwNTQgMjg4IC0xMDU0IGIgMjkyIC0xMDY3IDI4OSAtMTA1NCAyOTEgLTEwNjAgYiAzMTMgLTEyMTAgMzA2IC0xMTEzIDMxMyAtMTE2MSBiIDI5MiAtMTM0NiAzMTMgLTEyNTcgMzA2IC0xMzA0IGIgMjg4IC0xMzU3IDI4OSAtMTM1MyAyODggLTEzNTcgYiAyODggLTEzNTcgMjg4IC0xMzU3IDI4OCAtMTM1NyBiIDI5MiAtMTM2OCAyODkgLTEzNTcgMjkxIC0xMzYzIGIgMzEzIC0xNTEyIDMwNiAtMTQxNSAzMTMgLTE0NjQgYiAyOTIgLTE2NDggMzEzIC0xNTYwIDMwNiAtMTYwNSBiIDI4OCAtMTY2MCAyODkgLTE2NTQgMjg4IC0xNjYwIGIgMjg4IC0xNjYwIDI4OCAtMTY2MCAyODggLTE2NjAgYiAyOTIgLTE2NzEgMjg5IC0xNjYwIDI5MSAtMTY2NSBiIDMxMyAtMTgxNCAzMDYgLTE3MTkgMzEzIC0xNzY2IGIgMjUwIC0yMDQwIDMxMyAtMTg5NyAyOTEgLTE5NzcgYiAyMzIgLTIwNjIgMjM4IC0yMDU3IDIzNiAtMjA1OSBiIDIyMSAtMjA2NSAyMzAgLTIwNjMgMjI1IC0yMDY1IGIgMjAwIC0yMDQ1IDIxMCAtMjA2NSAyMDEgLTIwNTcgYiAyMDAgLTIwNDMgMjAwIC0yMDQ0IDIwMCAtMjA0NCBiIDIwOCAtMjAyNiAyMDAgLTIwMzcgMjAyIC0yMDM0IGIgMjY5IC0xODI2IDI0OSAtMTk2NiAyNjkgLTE4OTcgYiAxNTMgLTE1NDQgMjY5IC0xNzI2IDIzMCAtMTYyNSBiIC05IC0xNDcyIDExNSAtMTUwNiA1OCAtMTQ4MSBiIC0yMSAtMTQ3MSAtMTQgLTE0NzEgLTE5IC0xNDcxIGwgLTI0IC0xNDcxIGwgLTI0IC0xMzQzIGwgLTI0IC0xMjE1IGwgLTIwIC0xMjE1IGIgLTEgLTEyMjkgLTEyIC0xMjE1IC00IC0xMjIxIGIgMTQyIC0xNDI0IDEzIC0xMjcwIDc0IC0xMzUzIGIgMjU3IC0xNTgyIDE5NiAtMTQ3OCAyMjggLTE1MjQgYiAyNjQgLTE1OTQgMjYxIC0xNTg5IDI2NCAtMTU5NCBsIDI2NCAtMTU5NCBiIDI2NSAtMTU4MiAyNjQgLTE1OTQgMjY0IC0xNTg5IGIgMjcwIC0xNTI1IDI2OCAtMTU2MiAyNzAgLTE1NDQgYiAxNTMgLTEyNDMgMjcwIC0xNDI0IDIyOCAtMTMyMSBiIC05IC0xMTcwIDExNSAtMTIwMyA1OCAtMTE3OCBiIC0yMSAtMTE2OCAtMTQgLTExNzAgLTE5IC0xMTY4IGwgLTI0IC0xMTY4IGwgLTI0IC0xMDQxIGwgLTI0IC05MTMgbCAtMjAgLTkxMyBiIC0xIC05MjcgLTEyIC05MTMgLTQgLTkxOCBiIDE0MiAtMTEyMSAxMyAtOTY3IDc0IC0xMDUwIGIgMjU3IC0xMjgxIDE5NiAtMTE3NSAyMjggLTEyMjEgYiAyNjQgLTEyOTIgMjYxIC0xMjg2IDI2NCAtMTI5MiBsIDI2NCAtMTI5MiBiIDI2NSAtMTI3OSAyNjQgLTEyOTIgMjY0IC0xMjg2IGIgMjcwIC0xMjIyIDI2OCAtMTI2MSAyNzAgLTEyNDIgYiAxNTMgLTk0MSAyNzAgLTExMjEgMjI4IC0xMDE4IGIgLTkgLTg2NyAxMTUgLTkwMCA1OCAtODc1IGIgLTIxIC04NjYgLTE0IC04NjcgLTE5IC04NjYgbCAtMjQgLTg2NiBsIC0yNCAtNzM4IGwgLTI0IC02MTAgbCAtMjAgLTYxMCBiIC0xIC02MjQgLTEyIC02MTAgLTQgLTYxNiBiIDE0MiAtODE4IDEzIC02NjQgNzQgLTc0OSBiIDI1NyAtOTc4IDE5NiAtODczIDIyOCAtOTE4IGIgMjY0IC05ODkgMjYxIC05ODQgMjY0IC05ODkgbCAyNjQgLTk4OSBiIDI2NSAtOTc3IDI2NCAtOTg5IDI2NCAtOTg0IGIgMjcwIC05MjAgMjY4IC05NTkgMjcwIC05MzkgYiAxNTMgLTYzOCAyNzAgLTgxOCAyMjggLTcxNiBiIC05IC01NjQgMTE1IC01OTggNTggLTU3MyBiIC0yMSAtNTYzIC0xNCAtNTY0IC0xOSAtNTYzIGwgLTI0IC01NjMgbCAtMjQgLTQzNSBsIC0yNCAtMzA4IGwgLTIwIC0zMDggYiAtMSAtMzIyIC0xMiAtMzA4IC00IC0zMTMgYiAxNDIgLTUxNiAxMyAtMzYzIDc0IC00NDYgYiAyNTcgLTY3NSAxOTYgLTU3MSAyMjggLTYxNiBiIDI2NCAtNjg3IDI2MSAtNjgxIDI2NCAtNjg3IGwgMjY0IC02ODcgYiAyNjUgLTY3NCAyNjQgLTY4NyAyNjQgLTY4MSBiIDI3MCAtNjE3IDI2OCAtNjU2IDI3MCAtNjM3IGIgMTUzIC0zMzUgMjcwIC01MTYgMjI4IC00MTMgYiAtOSAtMjYyIDExNSAtMjk1IDU4IC0yNzAgYiAtMjEgLTI2MCAtMTQgLTI2MiAtMTkgLTI2MCBsIC0yNCAtMjYwIGwgLTI0IC0xMzMgXCJ9LFwidjljXCI6e1wieF9taW5cIjotMTY2LjA2MjUsXCJ4X21heFwiOi0yNS44NTkzNzUsXCJoYVwiOjAsXCJvXCI6XCJtIC00OSAzNjkgYiAtNDIgMzcwIC00NiAzNjkgLTQ0IDM3MCBiIC0yNyAzNjAgLTM2IDM3MCAtMjkgMzY2IGIgLTI1IDM1NSAtMjcgMzU5IC0yNSAzNTggYiAtMzIgMzM1IC0yNSAzNTEgLTI4IDM0NyBiIC05MiA1MiAtNjYgMjQ4IC04NyAxNTkgYiAtOTMgLTEgLTkzIDQzIC05MyAyMCBiIC05MiAtNTQgLTkzIC0yMyAtOTMgLTQ1IGIgLTMyIC0zMzcgLTg1IC0xNjIgLTY2IC0yNTEgYiAtMjUgLTM1NSAtMjcgLTM0OSAtMjUgLTM1MiBiIC00MiAtMzcxIC0yNSAtMzY1IC0zMiAtMzcxIGIgLTYxIC0zNTMgLTUwIC0zNzEgLTUxIC0zNjkgYiAtMTYzIC02MyAtMTE5IC0yNjIgLTE1MyAtMTY1IGIgLTE2NiAtMSAtMTY2IC0zNyAtMTY2IC0zMSBiIC0xNjMgNjIgLTE2NiAzMCAtMTY2IDM2IGIgLTYxIDM1MiAtMTUzIDE2MyAtMTE5IDI2MCBiIC00OSAzNjkgLTU0IDM2NSAtNTEgMzY2IFwifSxcInY5ZVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjA3LjA2MjUsXCJoYVwiOjYxOSxcIm9cIjpcIm0gMjQzIDYzMSBiIDI1MCA2MzIgMjQ2IDYzMiAyNDkgNjMyIGIgMjcwIDYyMCAyNTkgNjMyIDI2OCA2MjggbCAyNzIgNjE2IGwgMjcyIDIwMSBsIDI3MiAtMjEyIGwgMjcwIC0yMTYgYiAyNTEgLTIyOSAyNjggLTIyNCAyNTkgLTIyOSBiIDIyNyAtMjE1IDI0MyAtMjI5IDI0MCAtMjI5IGwgMTUxIC0xNDIgYiAzMiAtMTYgODEgLTgwIDUzIC00OSBiIDAgODQgOSAxOCAwIDUyIGIgMTExIDE5OSAwIDE0OSA0MiAxOTkgYiAxMzcgMTk3IDExOSAxOTkgMTI3IDE5OCBiIDIyOCAxNTEgMTY4IDE5MSAxOTcgMTc3IGwgMjMxIDE0OCBsIDIzMSAzODMgYiAyMzIgNjIwIDIzMSA2MTYgMjMxIDYxNiBiIDI0MyA2MzEgMjM0IDYyNCAyMzggNjMwIG0gMTY4IDEzMSBiIDE1MiAxMzMgMTYzIDEzMyAxNTcgMTMzIGIgMTA3IDEwMiAxMzAgMTMzIDExMSAxMjAgYiAxMDYgODYgMTA3IDk3IDEwNiA5MSBiIDExMSA0MSAxMDYgNzMgMTA4IDU2IGIgMjI3IC0xNTIgMTI1IC0xMyAxNzEgLTkwIGwgMjMxIC0xNTYgbCAyMzEgLTM3IGwgMjMxIDgwIGwgMjI1IDg3IGIgMTY4IDEzMSAyMTAgMTExIDE5MCAxMjYgbSAzNDcgNjMxIGIgMzUzIDYzMiAzNDggNjMyIDM1MSA2MzIgYiAzNzQgNjIwIDM2MyA2MzIgMzcxIDYyOCBiIDM3NSAzODMgMzc1IDYxNiAzNzUgNjE2IGwgMzc1IDE0OCBsIDM3NyAxNTEgYiA0OTIgMTk5IDQxNSAxODMgNDU0IDE5OSBiIDUzNyAxOTEgNTA3IDE5OSA1MjIgMTk3IGIgNjA3IDg0IDU4MiAxNzYgNjA3IDEzNCBiIDU4MyAwIDYwNyA1OCA1OTggMjkgYiA0NTUgLTE0MiA1NjIgLTQwIDUzMyAtNzIgbCAzNzggLTIxNSBiIDM1NSAtMjI5IDM2NCAtMjI5IDM2MiAtMjI5IGIgMzM0IC0yMTYgMzQ1IC0yMjkgMzM3IC0yMjQgbCAzMzMgLTIxMiBsIDMzMyAyMDEgbCAzMzMgNjE2IGwgMzM0IDYyMCBiIDM0NyA2MzEgMzM3IDYyNCAzNDEgNjMwIG0gNDY1IDEzMSBiIDQ1MSAxMzMgNDYxIDEzMyA0NTUgMTMzIGIgNDQ1IDEzMyA0NDkgMTMzIDQ0NiAxMzMgYiAzNzkgODcgNDE5IDEyOSAzOTYgMTEzIGwgMzc1IDgwIGwgMzc1IC0zNyBsIDM3NSAtMTU2IGwgMzc4IC0xNTIgYiA0OTkgODEgNDUxIC03MiA0OTkgMjAgbCA0OTkgODMgYiA0NjUgMTMxIDQ5OSAxMTMgNDkwIDEyNiBcIn0sXCJ2YTNcIjp7XCJ4X21pblwiOjU4LjUzMTI1LFwieF9tYXhcIjoyMjguNjcxODc1LFwiaGFcIjoyOTQsXCJvXCI6XCJtIDEzOCAzNzEgYiAxNDIgMzczIDE0MCAzNzEgMTQxIDM3MyBiIDE3OCAzNDIgMTQ5IDM3MyAxNTYgMzY2IGIgMjI4IDI1MSAyMTcgMjk3IDIyOCAyNzggYiAyMjggMjQ0IDIyOCAyNDggMjI4IDI0NyBiIDE3NiAxNDcgMjI3IDIxMiAyMTIgMTg0IGIgMTIzIDczIDE1MiAxMjIgMTMyIDkzIGIgMTIxIDYyIDEyMiA3MCAxMjEgNjYgYiAxNDUgMTMgMTIxIDQ4IDEyOSAzMSBiIDE1MyAtMiAxNTEgNiAxNTMgMSBiIDE0OSAtOSAxNTMgLTUgMTUyIC02IGIgMTQ0IC0xMSAxNDggLTExIDE0NSAtMTEgYiAxMjkgLTEgMTQwIC0xMSAxMzYgLTggYiA2MSA4NyA4OSAzNyA2OCA2OCBiIDU4IDExMyA1OSA5NSA1OCAxMDUgYiAxMTAgMjE1IDU4IDE0NCA3NCAxNzcgYiAxNjMgMjg3IDEzNCAyNDAgMTU1IDI2OSBiIDE2NiAyOTkgMTY2IDI5MSAxNjYgMjk1IGIgMTQxIDM0OCAxNjYgMzEzIDE1NyAzMzAgYiAxMzMgMzYwIDEzNCAzNTYgMTMzIDM1OCBiIDEzMyAzNjMgMTMzIDM2MiAxMzMgMzYyIGIgMTM4IDM3MSAxMzMgMzY3IDEzNiAzNzAgXCJ9LFwidmE1XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjozNDkuODEyNSxcImhhXCI6MzU3LFwib1wiOlwibSA4OCAzMDIgYiAxMDMgMzAzIDkzIDMwMiA5OCAzMDMgYiAyMDIgMjI0IDE0OSAzMDMgMTkxIDI3MCBiIDIwNSAxOTkgMjA0IDIxNiAyMDUgMjA4IGIgMTc4IDEyOSAyMDUgMTczIDE5NiAxNDcgbCAxNzUgMTI2IGwgMTgyIDEyNyBiIDMwNyAyNDkgMjM2IDE0MiAyODQgMTkwIGIgMzEzIDI1OSAzMDggMjU0IDMxMSAyNTggYiAzMjkgMjY3IDMxNyAyNjUgMzIzIDI2NyBiIDM0OSAyNDcgMzQwIDI2NyAzNDkgMjU5IGIgMjAxIC0yNjMgMzQ5IDI0MiAyMDQgLTI1OCBiIDE4MiAtMjczIDE5NyAtMjcwIDE5MCAtMjczIGIgMTYzIC0yNjAgMTc0IC0yNzMgMTY2IC0yNjkgYiAxNjEgLTI1NiAxNjEgLTI1OSAxNjEgLTI1OCBiIDIxNyAtNTkgMTYxIC0yNDggMTcwIC0yMjAgYiAyNzIgMTI5IDI0NyA0MyAyNzIgMTI3IGIgMjcyIDEyOSAyNzIgMTI5IDI3MiAxMjkgYiAyNjQgMTIyIDI3MiAxMjkgMjY4IDEyNiBiIDE0MCA4MCAyMjcgOTQgMTgzIDgwIGIgMzYgMTE1IDEwMiA4MCA2NSA5MSBiIDAgMTk0IDEwIDEzNiAwIDE2NSBiIDg4IDMwMiAwIDI0NCAzMiAyOTIgXCJ9LFwidmE5XCI6e1wieF9taW5cIjotMjQuNSxcInhfbWF4XCI6MzE0LjQyMTg3NSxcImhhXCI6MzIxLFwib1wiOlwibSAtMjQgLTE0NSBsIC0yNCAtNSBsIC0yMCAtNSBiIDAgLTIzIC05IC01IC0yIC0xMiBiIDI3IC04NyA0IC0zOCAxNCAtNjYgYiAxMzggLTIyMCA1MyAtMTM2IDg4IC0xNzcgYiAyMzUgLTMyOCAxNzkgLTI1NSAyMDggLTI4OCBiIDMxNCAtNTkyIDI4NyAtNDA5IDMxNCAtNTAxIGIgMjkyIC03MzIgMzE0IC02MzkgMzA3IC02ODcgbCAyODkgLTc0MiBsIDI5NCAtNzU2IGIgMzE0IC04OTYgMzA3IC04MDIgMzE0IC04NDkgYiAyOTIgLTEwMzUgMzE0IC05NDMgMzA3IC05OTEgbCAyODkgLTEwNDUgbCAyOTQgLTEwNTcgYiAzMTQgLTExOTcgMzA3IC0xMTA0IDMxNCAtMTE1MiBiIDI5MiAtMTMzOCAzMTQgLTEyNDYgMzA3IC0xMjkyIGwgMjg5IC0xMzQ3IGwgMjk0IC0xMzYwIGIgMzE0IC0xNTAwIDMwNyAtMTQwNyAzMTQgLTE0NTQgYiAyNzMgLTE2ODkgMzE0IC0xNTY1IDMwMCAtMTYyOCBiIDI1MCAtMTcxMiAyNjUgLTE3MTAgMjYxIC0xNzEyIGIgMjI4IC0xNjkxIDIzNiAtMTcxMiAyMjggLTE3MDQgbCAyMjggLTE2ODUgbCAyMzQgLTE2NzUgYiAyNzAgLTE1MDcgMjU4IC0xNjIxIDI3MCAtMTU2NCBiIDk4IC0xMTkzIDI3MCAtMTM4MSAyMDkgLTEyNjEgYiA0MCAtMTE3NCA3NiAtMTE3OSA1OCAtMTE3NCBiIC0xMCAtMTE4OSAyNCAtMTE3NCA4IC0xMTc4IGIgLTIwIC0xMTkyIC0xNCAtMTE5MiAtMTYgLTExOTIgbCAtMjQgLTExOTIgbCAtMjQgLTEwNTIgbCAtMjQgLTkxMyBsIC0yMCAtOTEzIGIgMCAtOTMxIC05IC05MTMgLTIgLTkyMCBiIDI3IC05OTUgNCAtOTQ2IDE0IC05NzQgYiAxMzggLTExMjggNTMgLTEwNDMgODggLTEwODUgYiAyNTcgLTEyNzUgMTkwIC0xMTcyIDIyOCAtMTIyMCBiIDI2MiAtMTI4MyAyNTkgLTEyNzkgMjYyIC0xMjgzIGwgMjYyIC0xMjgzIGIgMjY5IC0xMjQ5IDI2NCAtMTI4MiAyNjggLTEyNjAgYiAyNzAgLTEyMDYgMjcwIC0xMjMzIDI3MCAtMTIyMCBiIDk4IC04OTEgMjcwIC0xMDc1IDIwNiAtOTU3IGIgNDAgLTg3MSA3NiAtODc3IDU4IC04NzEgYiAtMTAgLTg4NiAyNCAtODcxIDggLTg3NSBiIC0yMCAtODg5IC0xNCAtODg5IC0xNiAtODg5IGwgLTI0IC04ODkgbCAtMjQgLTc0OSBsIC0yNCAtNjEwIGwgLTIwIC02MTAgYiAwIC02MjggLTkgLTYxMCAtMiAtNjE3IGIgMjcgLTY5MiA0IC02NDQgMTQgLTY3MSBiIDEzOCAtODI1IDUzIC03NDEgODggLTc4MiBiIDI1NyAtOTczIDE5MCAtODcwIDIyOCAtOTE3IGIgMjYyIC05ODEgMjU5IC05NzcgMjYyIC05ODEgbCAyNjIgLTk4MSBiIDI2OSAtOTQ2IDI2NCAtOTc5IDI2OCAtOTU3IGIgMjcwIC05MDMgMjcwIC05MzEgMjcwIC05MTcgYiA5OCAtNTg4IDI3MCAtNzc0IDIwNiAtNjU1IGIgNDAgLTU2OSA3NiAtNTc0IDU4IC01NjkgYiAtMTAgLTU4NCAyNCAtNTY5IDggLTU3NCBiIC0yMCAtNTg3IC0xNCAtNTg3IC0xNiAtNTg3IGwgLTI0IC01ODcgbCAtMjQgLTQ0OCBsIC0yNCAtMzA4IGwgLTIwIC0zMDggYiAwIC0zMjYgLTkgLTMwOCAtMiAtMzE1IGIgMjcgLTM5MCA0IC0zNDEgMTQgLTM2OSBiIDEzOCAtNTIzIDUzIC00MzggODggLTQ4MCBiIDI1NyAtNjcwIDE5MCAtNTY3IDIyOCAtNjE0IGIgMjYyIC02NzggMjU5IC02NzQgMjYyIC02NzggYiAyNjIgLTY3OCAyNjIgLTY3OCAyNjIgLTY3OCBiIDI2OSAtNjQ0IDI2NCAtNjc3IDI2OCAtNjU2IGIgMjcwIC02MDEgMjcwIC02MjggMjcwIC02MTQgYiA5OCAtMjg1IDI3MCAtNDcxIDIwNiAtMzUyIGIgNDAgLTI2NiA3NiAtMjczIDU4IC0yNjYgYiAtMTAgLTI4MSAyNCAtMjY2IDggLTI3MiBiIC0yMCAtMjg0IC0xNCAtMjg0IC0xNiAtMjg0IGwgLTI0IC0yODQgbCAtMjQgLTE0NSBcIn0sXCJ2YWFcIjp7XCJ4X21pblwiOi0xLjM1OTM3NSxcInhfbWF4XCI6NzUyLjcwMzEyNSxcImhhXCI6NzY4LFwib1wiOlwibSA0OTAgOTg1IGIgNTA0IDk4NiA0OTUgOTg2IDUwMCA5ODYgYiA2MDQgOTA3IDU1MSA5ODYgNTkzIDk1NCBiIDYwNyA4ODQgNjA3IDkwMCA2MDcgODkyIGIgNTgxIDgxMyA2MDcgODU3IDU5NyA4MzEgbCA1NzggODEwIGwgNTgzIDgxMSBiIDcxMCA5MzIgNjM4IDgyNyA2ODcgODczIGIgNzE0IDk0MyA3MTEgOTM2IDcxMyA5NDIgYiA3MzAgOTUyIDcyMCA5NDkgNzI1IDk1MiBiIDc1MiA5MzEgNzQxIDk1MiA3NTIgOTQzIGIgMjAwIC05NDYgNzUyIDkyNyAyMDQgLTk0MSBiIDE4MiAtOTU3IDE5NyAtOTUzIDE5MCAtOTU3IGIgMTYzIC05NDUgMTc0IC05NTcgMTY2IC05NTMgYiAxNjEgLTkzOSAxNjEgLTk0MiAxNjEgLTk0MiBiIDIxNyAtNzQzIDE2MSAtOTMxIDE3MCAtOTA0IGIgMjcyIC01NTUgMjQ3IC02MzkgMjcyIC01NTUgYiAyNzIgLTU1NSAyNzIgLTU1NSAyNzIgLTU1NSBiIDI2NCAtNTYwIDI3MiAtNTU1IDI2OCAtNTU3IGIgMTQwIC02MDMgMjI3IC01ODkgMTgyIC02MDMgYiAzNiAtNTY3IDEwMiAtNjAzIDY1IC01OTIgYiAtMSAtNDg3IDEyIC01NDggLTEgLTUxNyBiIDE3IC00MjcgLTEgLTQ2NiA1IC00NDUgYiAxMDMgLTM4MCAzOCAtMzk1IDcwIC0zODAgYiAxOTEgLTQzMyAxMzcgLTM4MCAxNzIgLTM5OCBiIDIwNSAtNDg0IDIwMSAtNDQ4IDIwNSAtNDY2IGIgMTc4IC01NTMgMjA1IC01MDkgMTk2IC01MzUgbCAxNzUgLTU1NyBsIDE4MiAtNTU1IGIgMzA3IC00MzUgMjM2IC01MzkgMjg0IC00OTQgYiAzNzIgLTIxMyAzMDggLTQzMCAzNzIgLTIxNSBiIDM3MiAtMjEzIDM3MiAtMjEzIDM3MiAtMjEzIGIgMzY0IC0yMTkgMzcyIC0yMTMgMzY4IC0yMTYgYiAyNDAgLTI2MiAzMjggLTI0NyAyODMgLTI2MiBiIDEzNyAtMjI2IDIwMiAtMjYyIDE2NiAtMjQ5IGIgOTkgLTE0NSAxMTIgLTIwNiA5OSAtMTc2IGIgMTE4IC04NCA5OSAtMTI0IDEwNiAtMTA0IGIgMjA0IC0zOCAxMzggLTU0IDE3MSAtMzggYiAyOTIgLTkxIDIzOCAtMzggMjczIC01NiBiIDMwNiAtMTQxIDMwMiAtMTA2IDMwNiAtMTI0IGIgMjc5IC0yMTIgMzA2IC0xNjcgMjk2IC0xOTQgbCAyNzYgLTIxNSBsIDI4MSAtMjEzIGIgNDA4IC05MyAzMzYgLTE5OCAzODUgLTE1MSBiIDQ3MyAxMjkgNDA5IC04OCA0NzMgMTI3IGIgNDczIDEyOSA0NzMgMTI5IDQ3MyAxMjkgYiA0NjUgMTIyIDQ3MyAxMjkgNDY5IDEyNiBiIDM0MSA4MCA0MjggOTQgMzgzIDgwIGIgMjM2IDExNSAzMDMgODAgMjY2IDkxIGIgMjAwIDE5NSAyMTMgMTM2IDIwMCAxNjUgYiAyMTcgMjU2IDIwMCAyMTcgMjA2IDIzOCBiIDMwNCAzMDMgMjM5IDI4NyAyNzIgMzAzIGIgMzkzIDI0OSAzMzggMzAzIDM3NCAyODUgYiA0MDYgMTk5IDQwMiAyMzQgNDA2IDIxNyBiIDM3OSAxMjkgNDA2IDE3MyAzOTcgMTQ4IGwgMzc3IDEyNiBsIDM4MiAxMjcgYiA1MDkgMjQ4IDQzNiAxNDIgNDg1IDE5MCBiIDU3NCA0NzAgNTEwIDI1NCA1NzQgNDY5IGIgNTc0IDQ3MCA1NzQgNDcwIDU3NCA0NzAgYiA1NjYgNDY0IDU3NCA0NzAgNTcwIDQ2NyBiIDQ0MiA0MjEgNTI5IDQzNSA0ODQgNDIxIGIgMzM3IDQ1OCA0MDQgNDIxIDM2NyA0MzMgYiAzMDAgNTM4IDMxNCA0NzcgMzAwIDUwOCBiIDMxOCA1OTggMzAwIDU1OSAzMDYgNTgwIGIgNDA0IDY0NSAzNDAgNjMwIDM3MiA2NDUgYiA0OTQgNTkyIDQzOSA2NDUgNDc1IDYyNyBiIDUwNyA1NDEgNTAyIDU3NyA1MDcgNTU5IGIgNDgwIDQ3MSA1MDcgNTE2IDQ5OCA0ODkgbCA0NzcgNDY3IGwgNDgzIDQ3MCBiIDYwOCA1ODkgNTM3IDQ4NSA1ODYgNTMxIGIgNjc1IDgxMSA2MTEgNTk1IDY3NSA4MTAgYiA2NzUgODExIDY3NSA4MTEgNjc1IDgxMSBiIDY2NiA4MDYgNjc1IDgxMSA2NzEgODA5IGIgNTQzIDc2MyA2MjggNzc3IDU4NSA3NjMgYiA0MzggNzk5IDUwNCA3NjMgNDY4IDc3NSBiIDQwMSA4NzggNDEyIDgyMCA0MDEgODQ5IGIgNDkwIDk4NSA0MDEgOTI4IDQzNCA5NzcgXCJ9LFwidmFiXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoyNzIuMjE4NzUsXCJoYVwiOjI3OCxcIm9cIjpcIm0gMjQzIDYzMSBiIDI1MCA2MzIgMjQ2IDYzMiAyNDkgNjMyIGIgMjcwIDYyMCAyNTkgNjMyIDI2OCA2MjggbCAyNzIgNjE2IGwgMjcyIDIwMSBsIDI3MiAtMjEyIGwgMjcwIC0yMTYgYiAyNTEgLTIyOSAyNjggLTIyNCAyNTkgLTIyOSBiIDIyNyAtMjE1IDI0MyAtMjI5IDI0MCAtMjI5IGwgMTUxIC0xNDIgYiAzMiAtMTYgODEgLTgwIDUzIC00OSBiIDAgODQgOSAxOCAwIDUyIGIgMTExIDE5OSAwIDE0OSA0MiAxOTkgYiAxMzcgMTk3IDExOSAxOTkgMTI3IDE5OCBiIDIyOCAxNTEgMTY4IDE5MSAxOTcgMTc3IGwgMjMxIDE0OCBsIDIzMSAzODMgYiAyMzIgNjIwIDIzMSA2MTYgMjMxIDYxNiBiIDI0MyA2MzEgMjM0IDYyNCAyMzggNjMwIG0gMTY4IDEzMSBiIDE1MiAxMzMgMTYzIDEzMyAxNTcgMTMzIGIgMTA3IDEwMiAxMzAgMTMzIDExMSAxMjAgYiAxMDYgODYgMTA3IDk3IDEwNiA5MSBiIDExMSA0MSAxMDYgNzMgMTA4IDU2IGIgMjI3IC0xNTIgMTI1IC0xMyAxNzEgLTkwIGwgMjMxIC0xNTYgbCAyMzEgLTM3IGwgMjMxIDgwIGwgMjI1IDg3IGIgMTY4IDEzMSAyMTAgMTExIDE5MCAxMjYgXCJ9LFwidmFkXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo4NzMuODI4MTI1LFwiaGFcIjo4OTIsXCJvXCI6XCJtIDAgMCBsIDAgNzAzIGwgODEgNzAzIGwgMTY0IDcwMyBsIDE2NCAwIGwgMTY0IC03MDUgbCA4MSAtNzA1IGwgMCAtNzA1IGwgMCAwIG0gMjI1IDAgbCAyMjUgNzAzIGwgMjQ2IDcwMyBsIDI2OCA3MDMgbCAyNjggMzY2IGwgMjY4IDMwIGwgMjc0IDM2IGIgMzE0IDc5IDI4NCA0NCAzMDIgNjMgYiA0MTMgMzAyIDM1NyAxMzcgMzkyIDIxMyBiIDQzMiAzMjcgNDE5IDMyNCA0MjEgMzI3IGIgNDQ5IDMwNiA0NDMgMzI3IDQ0NyAzMjIgYiA2MTEgMTE1IDQ1NyAxOTUgNTI5IDExNSBiIDY1MSAxMjIgNjI0IDExNSA2MzggMTE3IGIgNzI4IDMxNiA3MDUgMTQwIDcyNCAxODggYiA3MjkgMzg4IDcyOCAzNDIgNzI5IDM2NiBiIDY3MSA2MzUgNzI5IDUzMyA3MTEgNjAyIGIgNTgxIDY2MiA2NDkgNjUyIDYxNiA2NjIgYiA0NzcgNjM3IDU0NSA2NjIgNTEwIDY1MyBsIDQ3NSA2MzUgbCA0NzcgNjM0IGIgNTAzIDYyNyA0ODggNjMyIDQ5NSA2MzEgYiA1NDUgNTU2IDUzMiA2MTIgNTQ1IDU4NCBiIDQ5MSA0ODAgNTQ1IDUyNCA1MjYgNDkxIGIgNDY1IDQ3NCA0ODEgNDc2IDQ3MyA0NzQgYiAzNzkgNTYzIDQxNyA0NzQgMzc5IDUxNiBiIDM4OSA2MDIgMzc5IDU3NiAzODIgNTg4IGIgNTQxIDY5MSA0MDkgNjQxIDQ3OSA2ODEgYiA1ODIgNjk0IDU1NSA2OTIgNTY4IDY5NCBiIDg2NSA0NjIgNzE0IDY5NCA4MzQgNTk4IGIgODczIDM5MiA4NzEgNDQwIDg3MyA0MTYgYiA4NjUgMzE3IDg3MyAzNjcgODcxIDM0MSBiIDYzOSA4NCA4MzkgMTk0IDc0OCAxMDEgYiA2MTIgODMgNjMwIDgzIDYyMCA4MyBiIDUxMSAxMTYgNTc3IDgzIDU0MyA5NCBiIDUwNCAxMjAgNTA5IDExOSA1MDYgMTIwIGIgNTA0IDEyMCA1MDQgMTIwIDUwNCAxMjAgYiA0NjkgNTkgNTA0IDEyMCA0ODggOTMgbCA0MzIgLTEgbCA0NjkgLTYxIGIgNTA0IC0xMjIgNDg4IC05NCA1MDQgLTEyMiBiIDUwNCAtMTIyIDUwNCAtMTIyIDUwNCAtMTIyIGIgNTExIC0xMTcgNTA2IC0xMjIgNTA5IC0xMjAgYiA2MTIgLTg0IDU0MyAtOTUgNTc3IC04NCBiIDY2NSAtOTEgNjMwIC04NCA2NDcgLTg3IGIgODY5IC0zMzggNzcxIC0xMjIgODUwIC0yMTYgYiA4NzMgLTM5MiA4NzIgLTM1NiA4NzMgLTM3NCBiIDc5OCAtNTk1IDg3MyAtNDY5IDg0NyAtNTM5IGIgNTgxIC02OTUgNzQxIC02NjIgNjYwIC02OTUgYiA0MDYgLTYyNiA1MTcgLTY5NSA0NTQgLTY3MSBiIDM4MSAtNTYzIDM4OSAtNjA3IDM4MSAtNTg1IGIgNDY1IC00NzcgMzgxIC01MTkgNDEzIC00NzcgYiA1NDUgLTU1OSA1MTQgLTQ3NyA1NDUgLTUxOSBiIDUwMyAtNjI4IDU0NSAtNTg3IDUzMiAtNjEzIGIgNDc3IC02MzUgNDk1IC02MzIgNDg4IC02MzQgbCA0NzUgLTYzNyBsIDQ3NyAtNjM4IGIgNTgxIC02NjMgNTEwIC02NTUgNTQ1IC02NjMgYiA2NzEgLTYzNyA2MTYgLTY2MyA2NDkgLTY1MyBiIDcyOSAtMzkxIDcxMSAtNjAzIDcyOSAtNTM0IGIgNzI4IC0zMTcgNzI5IC0zNjcgNzI4IC0zNDQgYiA2MjMgLTExNyA3MjIgLTE3MyA2OTggLTEyNCBiIDYxMSAtMTE2IDYxOSAtMTE2IDYxNSAtMTE2IGIgNDQ5IC0zMDggNTI4IC0xMTYgNDU3IC0xOTggYiA0MzIgLTMyOCA0NDcgLTMyMyA0NDMgLTMyOCBiIDQxMyAtMzAzIDQyMSAtMzI4IDQxOSAtMzI2IGIgMzE0IC04MCAzOTIgLTIxNSAzNTcgLTEzOCBiIDI3NCAtMzcgMzAyIC02NSAyODQgLTQ1IGwgMjY4IC0zMSBsIDI2OCAtMzY3IGwgMjY4IC03MDUgbCAyNDYgLTcwNSBsIDIyNSAtNzA1IGwgMjI1IDAgXCJ9LFwidmIxXCI6e1wieF9taW5cIjo3OC45Mzc1LFwieF9tYXhcIjo0ODUuOTIxODc1LFwiaGFcIjo0MTcsXCJvXCI6XCJtIDM2MiAzNzggYiAzNzggMzgwIDM2NyAzODAgMzcyIDM4MCBiIDQ3MiAzNDggNDE1IDM4MCA0NTMgMzY3IGIgNDg1IDMxNSA0ODEgMzM4IDQ4NSAzMjcgYiA0NjIgMjczIDQ4NSAyOTggNDc3IDI4MSBiIDQzOSAyNjcgNDU0IDI2OSA0NDYgMjY3IGIgMzk4IDI5MCA0MjQgMjY3IDQwOSAyNzQgYiAzNDQgMzE5IDM4NSAzMDkgMzY0IDMxOSBiIDI4MSAyNjkgMzE1IDMxOSAyODkgMzAxIGIgMjc5IDI2MiAyODAgMjY2IDI3OSAyNjIgYiAyNzYgMjU2IDI3OSAyNjAgMjc3IDI1OCBiIDI3NCAyNDkgMjc2IDI1NCAyNzQgMjUxIGIgMjM4IDEyNyAyNzMgMjQ4IDI1NyAxOTIgYiAyMDEgNCAyMTcgNjEgMjAxIDUgYiAxNjYgLTEgMTk4IC0xIDIwMCAtMSBiIDE1MyAtMSAxNjMgLTEgMTU3IC0xIGIgMTQxIC0xIDE0OCAtMSAxNDQgLTEgYiAxMDQgNCAxMDYgLTEgMTA3IC0xIGIgMTA0IDYgMTA0IDUgMTA0IDUgYiAxNDIgMTQ0IDEwNCAxMyAxMTAgMzQgYiAxODIgMjc4IDE2NCAyMTkgMTgxIDI3NiBiIDE4MyAyODggMTgyIDI4MSAxODIgMjg1IGIgMTg1IDMwMiAxODUgMjkyIDE4NSAyOTggYiAxNjQgMzMwIDE4NSAzMTcgMTc2IDMyOCBiIDE1OSAzMzAgMTYzIDMzMCAxNjEgMzMwIGIgMTAyIDMwMiAxNDAgMzMwIDExOSAzMjAgYiA5MSAyOTQgOTUgMjk1IDkzIDI5NCBiIDg4IDI5NCA5MSAyOTQgODkgMjk0IGIgNzggMzAzIDgzIDI5NCA3OCAyOTggYiA4MSAzMTIgNzggMzA2IDc4IDMwOSBiIDIwMCAzNzMgMTA2IDM0NyAxNjAgMzczIGIgMjE1IDM3MSAyMDUgMzczIDIwOSAzNzEgYiAyNjYgMzM1IDIzNSAzNjcgMjU0IDM1MyBiIDI2OSAzMzEgMjY4IDMzMyAyNjkgMzMxIGIgMjY5IDMzMSAyNjkgMzMxIDI2OSAzMzEgYiAyNzMgMzM1IDI2OSAzMzEgMjcwIDMzNCBiIDM2MiAzNzggMjk4IDM1OSAzMzAgMzc2IFwifSxcInZiM1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MjI3LjMxMjUsXCJoYVwiOjIzMixcIm9cIjpcIm0gOTEgMjEzIGIgMTAwIDIxNSA5MyAyMTUgOTYgMjE1IGIgMjI3IDU4IDE2NyAyMTUgMjI0IDE0NCBiIDIyNyA1MiAyMjcgNTYgMjI3IDU0IGIgNjEgLTIwMSAyMjcgLTQzIDE2NCAtMTM4IGIgMjkgLTIxNiA0NCAtMjEyIDM2IC0yMTYgYiAyMyAtMjEwIDI3IC0yMTYgMjQgLTIxMyBiIDIxIC0yMDUgMjEgLTIwOCAyMSAtMjA2IGIgMzQgLTE5MiAyMSAtMjAxIDI1IC0xOTcgYiAxMjIgLTU1IDg5IC0xNjEgMTIyIC0xMDYgYiAxMDQgNiAxMjIgLTMzIDExNyAtMTIgbCAxMDMgOSBsIDk2IDkgYiA0IDc5IDU3IDkgMTcgMzggYiAwIDExMiAxIDkwIDAgMTAxIGIgOTEgMjEzIDAgMTYzIDM2IDIwOSBcIn0sXCJ2YjRcIjp7XCJ4X21pblwiOi01OTcuNTMxMjUsXCJ4X21heFwiOjU5Ni4xNzE4NzUsXCJoYVwiOjYwOCxcIm9cIjpcIm0gLTUzMyAzMjQgYiAtNTI1IDMyNyAtNTMwIDMyNiAtNTI4IDMyNyBiIC01MDQgMzA1IC01MTQgMzI3IC01MDQgMzE3IGIgLTUwNCAzMDUgLTUwNCAzMDUgLTUwNCAzMDUgYiAtNTEzIDI4NCAtNTA0IDI5OSAtNTA0IDI5OSBiIC01NTYgMTEyIC01NDEgMjI2IC01NTYgMTY3IGIgLTU0NSAzMyAtNTU2IDg0IC01NTIgNTggYiAtNTI0IC0yMCAtNTQxIDE1IC01MzIgLTkgbCAtNTIyIC0yMyBsIC00OTEgMTUgbCAtNDEzIDExMSBiIC0zNTUgMTc0IC0zNjcgMTY5IC0zNjMgMTc0IGIgLTM1MSAxNzQgLTM1MyAxNzQgLTM1MiAxNzQgYiAtMjU0IDg2IC0zNDMgMTc0IC0zNDggMTc5IGIgLTE2OCAtMSAtMjA4IDM3IC0xNjggLTEgYiAtMTAwIDg0IC0xNjggLTEgLTEzNyAzNyBiIC0yMyAxNzMgLTI4IDE3MyAtMjkgMTcyIGIgLTE5IDE3NCAtMjEgMTc0IC0yMCAxNzQgYiAtOCAxNzMgLTE0IDE3NCAtMTAgMTczIGIgODAgODYgLTUgMTcyIDEzIDE1MSBiIDE2NiAtMSAxMjcgMzcgMTY2IC0xIGIgMjM1IDg0IDE2NiAtMSAxOTcgMzcgYiAzMTEgMTczIDMwNiAxNzMgMzA0IDE3MiBiIDMxNyAxNzQgMzEzIDE3NCAzMTQgMTc0IGIgMzI2IDE3MyAzMTkgMTc0IDMyMyAxNzMgYiA0OTAgMTEgMzI5IDE3MiAzNjYgMTM0IGwgNTAyIC0xIGwgNTMwIDM0IGIgNTY4IDc2IDU2MCA3MiA1NjMgNzQgYiA1NzUgNzcgNTcwIDc3IDU3MyA3NyBiIDU5NiA1NiA1ODYgNzcgNTk2IDY4IGIgNTk0IDQ4IDU5NiA1NCA1OTYgNTEgYiA0MTcgLTE3MiA1OTIgNDEgNDI0IC0xNjYgYiA0MDUgLTE3NiA0MTUgLTE3NCA0MDkgLTE3NiBiIDM5NiAtMTc0IDQwMSAtMTc2IDM5OCAtMTc2IGIgMzA3IC04NyAzOTMgLTE3MyAzNzIgLTE1MiBiIDIyMSAtMSAyNTkgLTM4IDIyMSAtMSBiIDE1MiAtODYgMjIxIC0xIDE5MCAtMzggYiA3NiAtMTc2IDgxIC0xNzQgODMgLTE3MyBiIDcwIC0xNzYgNzQgLTE3NiA3MyAtMTc2IGIgNjEgLTE3NCA2NiAtMTc2IDYyIC0xNzQgYiAtMjcgLTg3IDU4IC0xNzMgMzggLTE1MiBiIC0xMTQgLTEgLTc0IC0zOCAtMTEyIC0xIGIgLTE4MiAtODYgLTExNCAtMSAtMTQ1IC0zOCBiIC0yNTggLTE3NiAtMjUzIC0xNzQgLTI1MyAtMTczIGIgLTI2NCAtMTc2IC0yNTkgLTE3NiAtMjYyIC0xNzYgYiAtMjc0IC0xNzQgLTI2OCAtMTc2IC0yNzIgLTE3NCBiIC00MzggLTExIC0yNzcgLTE3MyAtMzQ4IC0xMDIgbCAtNDQ5IDAgbCAtNDc5IC0zNyBiIC01MjQgLTgwIC01MTMgLTgwIC01MTQgLTgwIGwgLTUyNCAtODAgYiAtNTUzIC01MiAtNTM0IC04MCAtNTQwIC03NCBiIC01OTcgMTA5IC01ODMgLTggLTU5NyA0OCBiIC01NjAgMjgwIC01OTcgMTY1IC01ODUgMjI0IGIgLTUzMyAzMjQgLTU0OCAzMTAgLTU0MCAzMjIgXCJ9LFwidmI2XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo1NTYuNjg3NSxcImhhXCI6NTY4LFwib1wiOlwibSAyODkgNTQ1IGIgMjk4IDU0NiAyOTIgNTQ1IDI5NSA1NDYgYiAzMTggNTMzIDMwNiA1NDYgMzE1IDU0MSBiIDMxOSA0MjggMzE5IDUzMCAzMTkgNTI4IGwgMzE5IDMyNyBsIDMzNCAzMjcgYiA1MjYgMjIzIDQxMiAzMjYgNDg1IDI4NSBiIDU0MyAxNzIgNTM3IDIwNiA1NDMgMTkwIGIgNDQ3IDc2IDU0MyAxMjIgNTAzIDc2IGIgNDQ1IDc2IDQ0NiA3NiA0NDYgNzYgYiAzNTkgMTY1IDM5NCA3NyAzNTkgMTE5IGIgMzY4IDIwNSAzNTkgMTc5IDM2MiAxOTIgYiA0NDEgMjUxIDM4MiAyMzMgNDEyIDI1MSBiIDQ1NSAyNDkgNDQ2IDI1MSA0NTEgMjUxIGIgNDYwIDI0OCA0NTggMjQ5IDQ2MCAyNDggYiA0NjAgMjQ4IDQ2MCAyNDggNDYwIDI0OCBiIDQ1NCAyNTQgNDYwIDI0OSA0NTggMjUxIGIgMzM0IDI5NSA0MTkgMjgwIDM3OCAyOTQgbCAzMTkgMjk1IGwgMzE5IDQgbCAzMTkgLTI4NyBsIDMyMSAtMjg1IGIgMzI4IC0yODUgMzIyIC0yODUgMzI1IC0yODUgYiA1MjQgLTk5IDQyNCAtMjc3IDUwNyAtMTk4IGIgNTQxIC03OSA1MjYgLTg0IDUzMCAtNzkgYiA1NTYgLTk3IDU1MSAtNzkgNTU2IC04NCBiIDU0OCAtMTMzIDU1NiAtMTA1IDU1MyAtMTE3IGIgMzM0IC0zMTcgNTIxIC0yMzMgNDM0IC0zMDYgYiAzMjIgLTMxOSAzMjkgLTMxNyAzMjMgLTMxNyBsIDMxOSAtMzE5IGwgMzE5IC00MjQgYiAzMTkgLTQ3MSAzMTkgLTQ0NCAzMTkgLTQ1OSBiIDMxMyAtNTQxIDMxOSAtNTQ0IDMxOCAtNTM1IGIgMjk4IC01NDggMzA4IC01NDUgMzAzIC01NDggYiAyNzkgLTUzNCAyODkgLTU0OCAyODEgLTU0MiBiIDI3NyAtNDI0IDI3NyAtNTMxIDI3NyAtNTMwIGwgMjc3IC0zMTcgbCAyNzMgLTMxNyBiIDEzIC05NSAxNTMgLTMwNSA1MSAtMjE3IGIgMCAyIDQgLTYyIDAgLTI5IGIgMTgyIDI5NSAwIDEyNiA2NiAyMzggYiAyNzQgMzI0IDIxMCAzMDkgMjQ5IDMyMCBsIDI3NyAzMjQgbCAyNzcgNDI3IGIgMjc5IDUzMyAyNzcgNTI4IDI3NyA1MzAgYiAyODkgNTQ1IDI4MSA1MzggMjg1IDU0MiBtIDI3NyAyIGIgMjc3IDI5MSAyNzcgMTYxIDI3NyAyOTEgYiAyNjggMjg4IDI3NyAyOTEgMjczIDI5MCBiIDE0NCAxIDE3OSAyNjUgMTQ0IDE4NCBiIDI3NiAtMjg0IDE0NCAtMTk5IDE3NSAtMjY3IGwgMjc3IC0yODUgbCAyNzcgMiBcIn0sXCJ2YjlcIjp7XCJ4X21pblwiOi0xMjIuNSxcInhfbWF4XCI6MTIxLjE0MDYyNSxcImhhXCI6MTI0LFwib1wiOlwibSAtMTYgMTQ1IGIgMCAxNDcgLTEwIDE0NyAtNSAxNDcgYiAxMjEgLTEgNjYgMTQ3IDEyMSA3NyBiIDExNCAtNDkgMTIxIC0xNiAxMTggLTMzIGIgLTEgLTE0OCA5NSAtMTEyIDQ3IC0xNDggYiAtODUgLTEwNiAtMzEgLTE0OCAtNjEgLTEzNCBiIC0xMjIgLTEgLTExMCAtNzYgLTEyMiAtMzggYiAtMTYgMTQ1IC0xMjIgNjggLTgxIDEzNCBtIDEyIDExMSBiIDAgMTEzIDggMTEzIDQgMTEzIGIgLTY4IDIyIC0yOSAxMTMgLTYxIDczIGIgLTcwIDAgLTY5IDE1IC03MCA2IGIgLTEzIC0xMTMgLTcwIC00OSAtNDcgLTk4IGIgLTEgLTExNSAtOSAtMTE1IC01IC0xMTUgYiA2MyAtNDAgMjQgLTExNSA1MyAtODMgYiA2OCAtMSA2NiAtMjcgNjggLTE1IGIgMTIgMTExIDY4IDQ4IDQ2IDk3IFwifSxcInZiYVwiOntcInhfbWluXCI6LTExOC40MjE4NzUsXCJ4X21heFwiOjU5Ny41MzEyNSxcImhhXCI6MzgxLFwib1wiOlwibSA0NjAgNTc0IGIgNDY0IDU3NCA0NjEgNTc0IDQ2MiA1NzQgYiA0ODggNTc0IDQ3MCA1NzQgNDgxIDU3NCBiIDUwMCA1NzMgNDkxIDU3NCA0OTggNTc0IGIgNTk0IDUwMyA1NDMgNTcwIDU4OCA1MzggYiA1OTcgNDg4IDU5NiA0OTggNTk3IDQ5NCBiIDUyOCA0MTcgNTk3IDQ0OSA1NjQgNDE3IGIgNTAyIDQyMyA1MTkgNDE3IDUxMCA0MTkgYiA0NjUgNDgxIDQ3NyA0MzQgNDY1IDQ1OCBiIDQ4OCA1MjggNDY1IDQ5OSA0NzIgNTE2IGIgNDkwIDUzMCA0OTAgNTMwIDQ5MCA1MzAgYiA0OTAgNTMwIDQ5MCA1MzAgNDkwIDUzMCBiIDQ2OCA1MTcgNDg4IDUzMCA0NzUgNTIzIGIgMzQ5IDM0MCA0MTkgNDg1IDM3NyA0MjAgYiAzNDcgMzMwIDM0OCAzMzQgMzQ3IDMzMCBiIDM4MyAzMjggMzQ3IDMyOCAzNjMgMzI4IGIgNDI4IDMyNiA0MjMgMzI4IDQyNCAzMjggYiA0NDIgMzAyIDQzOCAzMjAgNDQyIDMxMiBiIDQzMCAyODEgNDQyIDI5NCA0MzggMjg1IGIgMzg1IDI3NiA0MjQgMjc3IDQyNiAyNzYgbCAzNzcgMjc2IGwgMzMyIDI3NiBsIDMzMCAyNjkgYiAxNzggLTExNyAzMDMgMTI2IDI1MCAtOSBiIDEgLTI0OSAxMjkgLTE5NCA2OSAtMjM3IGIgLTIwIC0yNTEgLTYgLTI1MSAtMTMgLTI1MSBiIC0xMTQgLTE4NyAtNjUgLTI1MSAtMTAwIC0yMjcgYiAtMTE4IC0xNTYgLTExNyAtMTc3IC0xMTggLTE2NiBiIC01MSAtODQgLTExOCAtMTE2IC05MSAtODQgYiAtMzEgLTg3IC00NiAtODQgLTM5IC04NiBiIDE2IC0xNTIgMCAtOTUgMTYgLTEyNCBiIC0xMiAtMjA1IDE2IC0xNzMgOCAtMTk0IGIgLTE2IC0yMDggLTE0IC0yMDYgLTE2IC0yMDggYiAtMTQgLTIwOCAtMTYgLTIwOCAtMTQgLTIwOCBiIC05IC0yMDYgLTE0IC0yMDggLTEyIC0yMDggYiA3NCAtMTI0IDIzIC0xOTcgNTQgLTE2NiBiIDE3MiAyMjQgOTggLTc5IDEyNSAyMiBiIDE4NSAyNzYgMTc4IDI1MiAxODMgMjc0IGIgMTg1IDI3NiAxODUgMjc2IDE4NSAyNzYgYiAxNDEgMjc2IDE4NSAyNzYgMTgxIDI3NiBiIDkxIDI4MCA5NiAyNzYgOTYgMjc2IGIgNzcgMzAyIDgzIDI4NSA3NyAyOTQgYiA5MSAzMjYgNzcgMzEyIDgzIDMyMCBiIDE0OCAzMjggOTUgMzI4IDk2IDMyOCBsIDE5OCAzMzAgbCAyMDIgMzQxIGIgNDYwIDU3NCAyNDkgNDczIDM1MSA1NjYgXCJ9LFwidmJmXCI6e1wieF9taW5cIjotNTMuMDc4MTI1LFwieF9tYXhcIjo1MTMuMTQwNjI1LFwiaGFcIjo0ODUsXCJvXCI6XCJtIDE4NSAzODMgYiAxOTYgMzg0IDE4NyAzODMgMTkxIDM4NCBiIDI3NyAzMzQgMjMwIDM4NCAyNTkgMzY1IGIgMjg4IDMwMSAyODEgMzI0IDI4OCAzMDYgYiAyODggMjk3IDI4OCAyOTggMjg4IDI5NyBiIDI5NCAzMDIgMjg5IDI5NyAyOTEgMjk5IGIgMzk0IDM3MCAzMjMgMzM4IDM2NyAzNjcgYiA0MDQgMzcxIDM5OCAzNzAgNDAxIDM3MSBiIDUxMCAyNzIgNDUzIDM3MSA0OTggMzI4IGIgNTEzIDIzNyA1MTMgMjYyIDUxMyAyNTEgYiA1MDcgMTcyIDUxMyAyMTcgNTExIDE5MiBiIDMyNiAtMzQgNDg3IDU5IDQxMiAtMjYgYiAzMTQgLTM2IDMyMiAtMzYgMzE4IC0zNiBiIDI3NCAtMjQgMjk4IC0zNiAyODMgLTMxIGwgMjY1IC0xNiBiIDIyNCA0NCAyNDYgLTEgMjMyIDIwIGIgMjIzIDQ5IDIyNCA0NyAyMjMgNDkgYiAyMjMgNDkgMjIzIDQ5IDIyMyA0OSBiIDE0OSAtMTk3IDIyMSA0OCAxNDkgLTE5NCBiIDE0OSAtMTk4IDE0OSAtMTk3IDE0OSAtMTk4IGIgMTcwIC0yMTAgMTQ5IC0yMDIgMTU1IC0yMDUgYiAxODcgLTIxNSAxNzQgLTIxMCAxNzUgLTIxMiBiIDIwNCAtMjMxIDIwMSAtMjE5IDIwNCAtMjIyIGIgMTk3IC0yNDUgMjA0IC0yNDAgMjAyIC0yNDIgbCAxOTQgLTI0OCBsIDc2IC0yNDggbCAtNDIgLTI0OCBsIC00NiAtMjQ1IGIgLTUzIC0yMzEgLTUxIC0yNDIgLTUzIC0yNDAgYiAtMzUgLTIxNSAtNTMgLTIyMiAtNDkgLTIxNyBiIC0xMyAtMjEwIC0yMSAtMjEyIC0yMCAtMjEyIGIgLTYgLTIwOCAtMTAgLTIwOSAtOCAtMjA4IGIgMCAtMjA2IC02IC0yMDggLTIgLTIwNiBiIDI1IC0xODggMTMgLTIwMSAyMSAtMTk1IGIgMTYzIDI4MCAyOCAtMTgzIDE2MyAyNzYgYiAxNjYgMjkxIDE2MyAyODMgMTY0IDI4NyBiIDE2NyAzMDIgMTY3IDI5NSAxNjcgMjk5IGIgMTU1IDMyNCAxNjcgMzE1IDE2MSAzMjQgYiAxNTUgMzI0IDE1NSAzMjQgMTU1IDMyNCBiIDY1IDIzMCAxMjUgMzIyIDg1IDI4MCBiIDUzIDIxNSA2MSAyMTcgNTggMjE1IGIgNTEgMjE1IDUzIDIxNSA1MSAyMTUgYiA0MiAyMjQgNDYgMjE1IDQyIDIxNyBiIDU3IDI2MyA0MiAyMzEgNDcgMjQ0IGIgMTQwIDM2MCA3NyAzMDUgMTA0IDMzNyBiIDE1MiAzNzAgMTQ0IDM2NSAxNDkgMzY5IGIgMTg1IDM4MyAxNTcgMzc2IDE3MiAzODEgbSAzNzQgMzA2IGIgMzY2IDMwOCAzNzEgMzA4IDM2OCAzMDggYiAzMDAgMjczIDM0OCAzMDggMzIxIDI5NCBiIDI4NCAyNTQgMjg4IDI2MiAyODcgMjU5IGIgMjgwIDI0MiAyODMgMjQ5IDI4MSAyNDUgYiAyNTcgMTY5IDI3OSAyNDAgMjcwIDIxMyBsIDIzNiA5OCBsIDIzNiA5MyBiIDI1MSA0OCAyMzggNzcgMjQzIDYxIGIgMjc5IDI3IDI1OCAzNyAyNzIgMjcgYiAyODEgMjcgMjc5IDI3IDI4MCAyNyBiIDI5MSAzMSAyODEgMjcgMjg3IDMwIGIgMzk2IDE3MCAzMzQgNTIgMzc4IDEwOSBiIDQwNiAyNDcgNDAyIDE5NyA0MDYgMjI0IGIgNDAxIDI3NyA0MDYgMjU5IDQwNSAyNzAgYiAzNzQgMzA2IDM5NyAyOTAgMzgzIDMwMyBcIn0sXCJ2YzNcIjp7XCJ4X21pblwiOi0xMC44OTA2MjUsXCJ4X21heFwiOjI5OS40Mzc1LFwiaGFcIjoyOTQsXCJvXCI6XCJtIDEzNiA0NjAgYiAxNDIgNDYyIDEzNyA0NjIgMTQwIDQ2MiBiIDE2NiA0NDkgMTUyIDQ2MiAxNjEgNDU2IGIgMTcxIDQyOCAxNjggNDQ2IDE2OCA0NDUgYiAyODggMTMxIDE5NCAzMjIgMjM4IDIwOSBiIDI5OCAxMTUgMjk1IDEyMCAyOTYgMTE3IGIgMjk5IDEwNiAyOTggMTEyIDI5OSAxMDkgYiAyNzMgODEgMjk5IDkxIDI4NyA4MSBiIDI1NSA4NiAyNjggODEgMjYxIDgzIGIgMTU1IDExNiAyMjUgMTA0IDE4MyAxMTYgbCAxNTIgMTE2IGwgMTQ5IDEwOCBiIDE0MSA4MyAxNDggMTAyIDE0NCA5MSBiIDEzNCA0OCAxMzcgNjkgMTM0IDU4IGIgMTQ5IDkgMTM0IDM0IDE0MCAyNCBiIDE1MyAtMSAxNTIgNSAxNTMgMSBiIDE0OSAtOSAxNTMgLTUgMTUyIC02IGIgMTQ0IC0xMSAxNDggLTExIDE0NyAtMTEgYiAxMjIgMiAxMzggLTExIDEzMyAtNiBiIDk1IDYxIDEwNCAyMCA5NSAzOCBiIDEwNyAxMDggOTUgNzQgOTkgOTAgYiAxMDggMTEzIDEwNyAxMTEgMTA4IDExMiBiIDEwNyAxMTMgMTA4IDExMyAxMDggMTEzIGIgMTAyIDExMyAxMDYgMTEzIDEwNCAxMTMgYiAzMSA4NiA3NiAxMDggNTMgOTggYiAxNCA4MCAyNCA4MSAyMCA4MCBiIC0xMCAxMDYgMCA4MCAtMTAgOTEgYiAwIDEzMSAtMTAgMTE1IC05IDExNiBiIDExNSA0MzAgNDkgMjA5IDkxIDMxNyBiIDEzNiA0NjAgMTE5IDQ1MSAxMjMgNDU2IFwifX0sXCJjc3NGb250V2VpZ2h0XCI6XCJub3JtYWxcIixcImFzY2VuZGVyXCI6MTkwMyxcInVuZGVybGluZVBvc2l0aW9uXCI6LTEyNSxcImNzc0ZvbnRTdHlsZVwiOlwibm9ybWFsXCIsXCJib3VuZGluZ0JveFwiOntcInlNaW5cIjotMjA2NS4zNzUsXCJ4TWluXCI6LTY5NS41MzEyNSxcInlNYXhcIjoxOTAxLjU3ODEyNSxcInhNYXhcIjoxMTU5LjY3MTg3NX0sXCJyZXNvbHV0aW9uXCI6MTAwMCxcImRlc2NlbmRlclwiOi0yMDY2LFwiZmFtaWx5TmFtZVwiOlwiVmV4Rmxvdy0xOFwiLFwibGluZUhlaWdodFwiOjQwOTMsXCJ1bmRlcmxpbmVUaGlja25lc3NcIjo1MH07XG4vLyBWZXggRmxvd1xuLy8gTW9oaXQgTXV0aGFubmEgPG1vaGl0QG11dGhhbm5hLmNvbT5cbi8vXG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFJlcXVpcmVzIGEgZ2x5cGggZm9udCB0byBiZSBsb2FkZWQgYW5kIFZleC5GbG93LkZvbnQgdG8gYmUgc2V0LlxuXG4vKipcbiAqIEEgcXVpY2sgYW5kIGRpcnR5IHN0YXRpYyBnbHlwaCByZW5kZXJlci4gUmVuZGVycyBnbHlwaHMgZnJvbSB0aGUgZGVmYXVsdFxuICogZm9udCBkZWZpbmVkIGluIFZleC5GbG93LkZvbnQuXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBjdHggVGhlIGNhbnZhcyBjb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHhfcG9zIFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5X3BvcyBZIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcG9pbnQgVGhlIHBvaW50IHNpemUgdG8gdXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCBUaGUgZ2x5cGggY29kZSBpbiBWZXguRmxvdy5Gb250LlxuICogQHBhcmFtIHtib29sZWFufSBub2NhY2hlIElmIHNldCwgZGlzYWJsZXMgY2FjaGluZyBvZiBmb250IG91dGxpbmUuXG4gKi9cblZleC5GbG93LnJlbmRlckdseXBoID0gZnVuY3Rpb24oY3R4LCB4X3BvcywgeV9wb3MsIHBvaW50LCB2YWwsIG5vY2FjaGUpIHtcbiAgdmFyIHNjYWxlID0gcG9pbnQgKiA3Mi4wIC8gKFZleC5GbG93LkZvbnQucmVzb2x1dGlvbiAqIDEwMC4wKTtcbiAgdmFyIG1ldHJpY3MgPSBWZXguRmxvdy5HbHlwaC5sb2FkTWV0cmljcyhWZXguRmxvdy5Gb250LCB2YWwsICFub2NhY2hlKTtcbiAgVmV4LkZsb3cuR2x5cGgucmVuZGVyT3V0bGluZShjdHgsIG1ldHJpY3Mub3V0bGluZSwgc2NhbGUsIHhfcG9zLCB5X3Bvcyk7XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5WZXguRmxvdy5HbHlwaCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gR2x5cGgoY29kZSwgcG9pbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMucG9pbnQgPSBwb2ludDtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgZm9udDogVmV4LkZsb3cuRm9udFxuICAgIH07XG5cbiAgICB0aGlzLndpZHRoID0gbnVsbDtcbiAgICB0aGlzLm1ldHJpY3MgPSBudWxsO1xuICAgIHRoaXMueF9zaGlmdCA9IDA7XG4gICAgdGhpcy55X3NoaWZ0ID0gMDtcblxuICAgIGlmIChvcHRpb25zKSB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7IGVsc2UgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgR2x5cGgucHJvdG90eXBlID0ge1xuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIFZleC5NZXJnZSh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0sXG5cbiAgICBzZXRTdGF2ZTogZnVuY3Rpb24oc3RhdmUpIHsgdGhpcy5zdGF2ZSA9IHN0YXZlOyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRYU2hpZnQ6IGZ1bmN0aW9uKHhfc2hpZnQpIHsgdGhpcy54X3NoaWZ0ID0geF9zaGlmdDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgc2V0WVNoaWZ0OiBmdW5jdGlvbih5X3NoaWZ0KSB7IHRoaXMueV9zaGlmdCA9IHlfc2hpZnQ7IHJldHVybiB0aGlzOyB9LFxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHsgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvbnRleHQ7IH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm1ldHJpY3MgPSBWZXguRmxvdy5HbHlwaC5sb2FkTWV0cmljcyh0aGlzLm9wdGlvbnMuZm9udCwgdGhpcy5jb2RlLFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5jYWNoZSk7XG4gICAgICB0aGlzLnNjYWxlID0gdGhpcy5wb2ludCAqIDcyIC8gKHRoaXMub3B0aW9ucy5mb250LnJlc29sdXRpb24gKiAxMDApO1xuICAgIH0sXG5cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIHRoaXMud2lkdGggPSAgd2lkdGg7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0TWV0cmljczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubWV0cmljcykgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRHbHlwaFwiLCBcIkdseXBoIFwiICtcbiAgICAgICAgICB0aGlzLmNvZGUgKyBcIiBpcyBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeF9taW46IHRoaXMubWV0cmljcy54X21pbiAqIHRoaXMuc2NhbGUsXG4gICAgICAgIHhfbWF4OiB0aGlzLm1ldHJpY3MueF9tYXggKiB0aGlzLnNjYWxlLFxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCB8fCAodGhpcy5tZXRyaWNzLnhfbWF4IC0gdGhpcy5tZXRyaWNzLnhfbWluKSAqIHRoaXMuc2NhbGUsXG4gICAgICAgIGhlaWdodDogdGhpcy5tZXRyaWNzLmhhICogdGhpcy5zY2FsZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgsIHhfcG9zLCB5X3Bvcykge1xuICAgICAgaWYgKCF0aGlzLm1ldHJpY3MpIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiQmFkR2x5cGhcIiwgXCJHbHlwaCBcIiArXG4gICAgICAgICAgdGhpcy5jb2RlICsgXCIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcblxuICAgICAgdmFyIG91dGxpbmUgPSB0aGlzLm1ldHJpY3Mub3V0bGluZTtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgICAgIEdseXBoLnJlbmRlck91dGxpbmUoY3R4LCBvdXRsaW5lLCBzY2FsZSwgeF9wb3MsIHlfcG9zKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyVG9TdGF2ZTogZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCF0aGlzLm1ldHJpY3MpIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiQmFkR2x5cGhcIiwgXCJHbHlwaCBcIiArXG4gICAgICAgICAgdGhpcy5jb2RlICsgXCIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICAgIGlmICghdGhpcy5zdGF2ZSkgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJHbHlwaEVycm9yXCIsIFwiTm8gdmFsaWQgc3RhdmVcIik7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiR2x5cGhFcnJvclwiLCBcIk5vIHZhbGlkIGNvbnRleHRcIik7XG5cbiAgICAgIHZhciBvdXRsaW5lID0gdGhpcy5tZXRyaWNzLm91dGxpbmU7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuXG4gICAgICBHbHlwaC5yZW5kZXJPdXRsaW5lKHRoaXMuY29udGV4dCwgb3V0bGluZSwgc2NhbGUsXG4gICAgICAgICAgeCArIHRoaXMueF9zaGlmdCwgdGhpcy5zdGF2ZS5nZXRZRm9yR2x5cGhzKCkgKyB0aGlzLnlfc2hpZnQpO1xuICAgIH1cbiAgfTtcblxuICAvKiBTdGF0aWMgbWV0aG9kcyB1c2VkIHRvIGltcGxlbWVudCBsb2FkaW5nIC8gdW5sb2FkaW5nIG9mIGdseXBocyAqL1xuICBHbHlwaC5sb2FkTWV0cmljcyA9IGZ1bmN0aW9uKGZvbnQsIGNvZGUsIGNhY2hlKSB7XG4gICAgdmFyIGdseXBoID0gZm9udC5nbHlwaHNbY29kZV07XG4gICAgaWYgKCFnbHlwaCkgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRHbHlwaFwiLCBcIkdseXBoIFwiICsgY29kZSArXG4gICAgICAgIFwiIGRvZXMgbm90IGV4aXN0IGluIGZvbnQuXCIpO1xuXG4gICAgdmFyIHhfbWluID0gZ2x5cGgueF9taW47XG4gICAgdmFyIHhfbWF4ID0gZ2x5cGgueF9tYXg7XG4gICAgdmFyIGhhID0gZ2x5cGguaGE7XG5cbiAgICB2YXIgb3V0bGluZTtcblxuICAgIGlmIChnbHlwaC5vKSB7XG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgaWYgKGdseXBoLmNhY2hlZF9vdXRsaW5lKSB7XG4gICAgICAgICAgb3V0bGluZSA9IGdseXBoLmNhY2hlZF9vdXRsaW5lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dGxpbmUgPSBnbHlwaC5vLnNwbGl0KCcgJyk7XG4gICAgICAgICAgZ2x5cGguY2FjaGVkX291dGxpbmUgPSBvdXRsaW5lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZ2x5cGguY2FjaGVkX291dGxpbmUpIGRlbGV0ZSBnbHlwaC5jYWNoZWRfb3V0bGluZTtcbiAgICAgICAgb3V0bGluZSA9IGdseXBoLm8uc3BsaXQoJyAnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeF9taW46IHhfbWluLFxuICAgICAgICB4X21heDogeF9tYXgsXG4gICAgICAgIGhhOiBoYSxcbiAgICAgICAgb3V0bGluZTogb3V0bGluZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRHbHlwaFwiLCBcIkdseXBoIFwiICsgdGhpcy5jb2RlICtcbiAgICAgICAgICBcIiBoYXMgbm8gb3V0bGluZSBkZWZpbmVkLlwiKTtcbiAgICB9XG4gIH07XG5cbiAgR2x5cGgucmVuZGVyT3V0bGluZSA9IGZ1bmN0aW9uKGN0eCwgb3V0bGluZSwgc2NhbGUsIHhfcG9zLCB5X3Bvcykge1xuICAgIHZhciBvdXRsaW5lTGVuZ3RoID0gb3V0bGluZS5sZW5ndGg7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBjdHgubW92ZVRvKHhfcG9zLCB5X3Bvcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dGxpbmVMZW5ndGg7ICkge1xuICAgICAgdmFyIGFjdGlvbiA9IG91dGxpbmVbaSsrXTtcblxuICAgICAgc3dpdGNoKGFjdGlvbikge1xuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICBjdHgubW92ZVRvKHhfcG9zICsgb3V0bGluZVtpKytdICogc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICB5X3BvcyArIG91dGxpbmVbaSsrXSAqIC1zY2FsZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgIGN0eC5saW5lVG8oeF9wb3MgKyBvdXRsaW5lW2krK10gKiBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgIHlfcG9zICsgb3V0bGluZVtpKytdICogLXNjYWxlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICB2YXIgY3B4ID0geF9wb3MgKyBvdXRsaW5lW2krK10gKiBzY2FsZTtcbiAgICAgICAgICB2YXIgY3B5ID0geV9wb3MgKyBvdXRsaW5lW2krK10gKiAtc2NhbGU7XG5cbiAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgeF9wb3MgKyBvdXRsaW5lW2krK10gKiBzY2FsZSxcbiAgICAgICAgICAgICAgeV9wb3MgKyBvdXRsaW5lW2krK10gKiAtc2NhbGUsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICB2YXIgeCA9IHhfcG9zICsgb3V0bGluZVtpKytdICogc2NhbGU7XG4gICAgICAgICAgdmFyIHkgPSB5X3BvcyArIG91dGxpbmVbaSsrXSAqIC1zY2FsZTtcblxuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICB4X3BvcyArIG91dGxpbmVbaSsrXSAqIHNjYWxlLCB5X3BvcyArIG91dGxpbmVbaSsrXSAqIC1zY2FsZSxcbiAgICAgICAgICAgICAgeF9wb3MgKyBvdXRsaW5lW2krK10gKiBzY2FsZSwgeV9wb3MgKyBvdXRsaW5lW2krK10gKiAtc2NhbGUsXG4gICAgICAgICAgICAgIHgsIHkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguZmlsbCgpO1xuICB9O1xuXG4gIHJldHVybiBHbHlwaDtcbn0oKSk7XG5cbi8vIFZleCBGbG93XG4vLyBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy9cbi8vIENvcHlyaWdodCBNb2hpdCBDaGVwcHVkaXJhIDIwMTBcblxuLyoqIEBjb25zdHJ1Y3RvciAqL1xuVmV4LkZsb3cuU3RhdmUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFN0YXZlKHgsIHksIHdpZHRoLCBvcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQoeCwgeSwgd2lkdGgsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIFRISUNLTkVTUyA9IChWZXguRmxvdy5TVEFWRV9MSU5FX1RISUNLTkVTUyA+IDEgP1xuICAgICAgICBWZXguRmxvdy5TVEFWRV9MSU5FX1RISUNLTkVTUyA6IDApO1xuICBTdGF2ZS5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5nbHlwaF9zdGFydF94ID0geCArIDU7XG4gICAgICB0aGlzLmdseXBoX2VuZF94ID0geCArIHdpZHRoO1xuICAgICAgdGhpcy5zdGFydF94ID0gdGhpcy5nbHlwaF9zdGFydF94O1xuICAgICAgdGhpcy5lbmRfeCA9IHRoaXMuZ2x5cGhfZW5kX3g7XG4gICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy5nbHlwaHMgPSBbXTtcbiAgICAgIHRoaXMuZW5kX2dseXBocyA9IFtdO1xuICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTsgIC8vIG5vbi1nbHlwaCBzdGF2ZSBpdGVtcyAoYmFybGluZXMsIGNvZGEsIHNlZ25vLCBldGMuKVxuICAgICAgdGhpcy5tZWFzdXJlID0gMDtcbiAgICAgIHRoaXMuY2xlZiA9IFwidHJlYmxlXCI7XG4gICAgICB0aGlzLmZvbnQgPSB7XG4gICAgICAgIGZhbWlseTogXCJzYW5zLXNlcmlmXCIsXG4gICAgICAgIHNpemU6IDgsXG4gICAgICAgIHdlaWdodDogXCJcIlxuICAgICAgfTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgdmVydGljYWxfYmFyX3dpZHRoOiAxMCwgICAgICAgLy8gV2lkdGggYXJvdW5kIHZlcnRpY2FsIGJhciBlbmQtbWFya2VyXG4gICAgICAgIGdseXBoX3NwYWNpbmdfcHg6IDEwLFxuICAgICAgICBudW1fbGluZXM6IDUsXG4gICAgICAgIGZpbGxfc3R5bGU6IFwiIzk5OTk5OVwiLFxuICAgICAgICBzcGFjaW5nX2JldHdlZW5fbGluZXNfcHg6IDEwLCAvLyBpbiBwaXhlbHNcbiAgICAgICAgc3BhY2VfYWJvdmVfc3RhZmZfbG46IDQsICAgICAgLy8gaW4gc3RhZmYgbGluZXNcbiAgICAgICAgc3BhY2VfYmVsb3dfc3RhZmZfbG46IDQsICAgICAgLy8gaW4gc3RhZmYgbGluZXNcbiAgICAgICAgdG9wX3RleHRfcG9zaXRpb246IDEgICAgICAgICAgLy8gaW4gc3RhZmYgbGluZXNcbiAgICAgIH07XG4gICAgICB0aGlzLmJvdW5kcyA9IHt4OiB0aGlzLngsIHk6IHRoaXMueSwgdzogdGhpcy53aWR0aCwgaDogMH07XG4gICAgICBWZXguTWVyZ2UodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5yZXNldExpbmVzKCk7XG5cbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2goXG4gICAgICAgICAgbmV3IFZleC5GbG93LkJhcmxpbmUoVmV4LkZsb3cuQmFybGluZS50eXBlLlNJTkdMRSwgdGhpcy54KSk7IC8vIGJlZyBiYXJcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2goXG4gICAgICAgICAgbmV3IFZleC5GbG93LkJhcmxpbmUoVmV4LkZsb3cuQmFybGluZS50eXBlLlNJTkdMRSxcbiAgICAgICAgICB0aGlzLnggKyB0aGlzLndpZHRoKSk7IC8vIGVuZCBiYXJcbiAgICB9LFxuXG4gICAgcmVzZXRMaW5lczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubGluZV9jb25maWcgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLm51bV9saW5lczsgaSsrKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5saW5lX2NvbmZpZy5wdXNoKHt2aXNpYmxlOiB0cnVlfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmhlaWdodCA9ICh0aGlzLm9wdGlvbnMubnVtX2xpbmVzICsgdGhpcy5vcHRpb25zLnNwYWNlX2Fib3ZlX3N0YWZmX2xuKSAqXG4gICAgICAgICB0aGlzLm9wdGlvbnMuc3BhY2luZ19iZXR3ZWVuX2xpbmVzX3B4O1xuICAgICAgdGhpcy5vcHRpb25zLmJvdHRvbV90ZXh0X3Bvc2l0aW9uID0gdGhpcy5vcHRpb25zLm51bV9saW5lcyArIDE7XG4gICAgfSxcblxuICAgIHNldE5vdGVTdGFydFg6IGZ1bmN0aW9uKHgpIHsgdGhpcy5zdGFydF94ID0geDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgZ2V0Tm90ZVN0YXJ0WDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhcnRfeCA9IHRoaXMuc3RhcnRfeDtcblxuICAgICAgLy8gQWRkIGFkZGl0aW9uYWwgc3BhY2UgaWYgbGVmdCBiYXJsaW5lIGlzIFJFUEVBVF9CRUdJTiBhbmQgdGhlcmUgYXJlIG90aGVyXG4gICAgICAvLyBzdGFydCBtb2RpZmllcnMgdGhhbiBiYXJsaW5lc1xuICAgICAgaWYgKHRoaXMubW9kaWZpZXJzWzBdLmJhcmxpbmUgPT0gVmV4LkZsb3cuQmFybGluZS50eXBlLlJFUEVBVF9CRUdJTiAmJlxuICAgICAgICAgIHRoaXMubW9kaWZpZXJzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgc3RhcnRfeCArPSAyMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0X3g7XG4gICAgfSxcblxuICAgIGdldE5vdGVFbmRYOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZW5kX3g7IH0sXG4gICAgZ2V0VGllU3RhcnRYOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc3RhcnRfeDsgfSxcbiAgICBnZXRUaWVFbmRYOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7IH0sXG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcblx0Zm9yKHZhciBpPTA7IGk8dGhpcy5nbHlwaHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgIGlmKHR5cGVvZih0aGlzLmdseXBoc1tpXS5zZXRDb250ZXh0KSA9PT0gXCJmdW5jdGlvblwiKXtcblx0ICAgIHRoaXMuZ2x5cGhzW2ldLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgfVxuXHR9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0OyB9LFxuICAgIGdldFg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy54OyB9LFxuICAgIGdldE51bUxpbmVzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMub3B0aW9ucy5udW1fbGluZXM7IH0sXG4gICAgc2V0TnVtTGluZXM6IGZ1bmN0aW9uKGxpbmVzKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubnVtX2xpbmVzID0gcGFyc2VJbnQobGluZXMsIDEwKTtcbiAgICAgIHRoaXMucmVzZXRMaW5lcygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXRZOiBmdW5jdGlvbih5KSB7IHRoaXMueSA9IHk7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgc2V0WDogZnVuY3Rpb24oeCl7XG4gICAgICB2YXIgc2hpZnQgPSB4IC0gdGhpcy54O1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMuZ2x5cGhfc3RhcnRfeCArPSBzaGlmdDtcbiAgICAgIHRoaXMuZ2x5cGhfZW5kX3ggKz0gc2hpZnQ7XG4gICAgICB0aGlzLnN0YXJ0X3ggKz0gc2hpZnQ7XG4gICAgICB0aGlzLmVuZF94ICs9IHNoaWZ0O1xuICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5tb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIFx0dmFyIG1vZCA9IHRoaXMubW9kaWZpZXJzW2ldO1xuICAgICAgICBpZiAobW9kLnggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG1vZC54ICs9IHNoaWZ0O1xuICAgICAgXHR9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmdseXBoX2VuZF94ID0gdGhpcy54ICsgd2lkdGg7XG4gICAgICB0aGlzLmVuZF94ID0gdGhpcy5nbHlwaF9lbmRfeDtcblxuICAgICAgLy8gcmVzZXQgdGhlIHggcG9zaXRpb24gb2YgdGhlIGVuZCBiYXJsaW5lIChUT0RPKDB4ZmUpOiBUaGlzIG1ha2VzIG5vIHNlbnNlKVxuICAgICAgLy8gdGhpcy5tb2RpZmllcnNbMV0uc2V0WCh0aGlzLmVuZF94KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9LFxuXG4gICAgc2V0TWVhc3VyZTogZnVuY3Rpb24obWVhc3VyZSkgeyB0aGlzLm1lYXN1cmUgPSBtZWFzdXJlOyByZXR1cm4gdGhpczsgfSxcblxuICAgICAgLy8gQmFyIExpbmUgZnVuY3Rpb25zXG4gICAgc2V0QmVnQmFyVHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgLy8gT25seSB2YWxpZCBiYXIgdHlwZXMgYXQgYmVnaW5uaW5nIG9mIHN0YXZlIGlzIG5vbmUsIHNpbmdsZSBvciBiZWdpbiByZXBlYXRcbiAgICAgIGlmICh0eXBlID09IFZleC5GbG93LkJhcmxpbmUudHlwZS5TSU5HTEUgfHxcbiAgICAgICAgICB0eXBlID09IFZleC5GbG93LkJhcmxpbmUudHlwZS5SRVBFQVRfQkVHSU4gfHxcbiAgICAgICAgICB0eXBlID09IFZleC5GbG93LkJhcmxpbmUudHlwZS5OT05FKSB7XG4gICAgICAgICAgdGhpcy5tb2RpZmllcnNbMF0gPSBuZXcgVmV4LkZsb3cuQmFybGluZSh0eXBlLCB0aGlzLngpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEVuZEJhclR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIC8vIFJlcGVhdCBlbmQgbm90IHZhbGlkIGF0IGVuZCBvZiBzdGF2ZVxuICAgICAgaWYgKHR5cGUgIT0gVmV4LkZsb3cuQmFybGluZS50eXBlLlJFUEVBVF9CRUdJTilcbiAgICAgICAgdGhpcy5tb2RpZmllcnNbMV0gPSBuZXcgVmV4LkZsb3cuQmFybGluZSh0eXBlLCB0aGlzLnggKyB0aGlzLndpZHRoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwaXhlbHMgdG8gc2hpZnQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdGF2ZVxuICAgICAqIGZvbGxvd2luZyB0aGUgbW9kaWZpZXIgYXQgdGhlIHByb3ZpZGVkIGluZGV4XG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggZnJvbSB3aGljaCB0byBkZXRlcm1pbmUgdGhlIHNoaWZ0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICBUaGUgYW1vdW50IG9mIHBpeGVscyBzaGlmdGVkXG4gICAgICovXG4gICAgZ2V0TW9kaWZpZXJYU2hpZnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykgaW5kZXggPSB0aGlzLmdseXBocy5sZW5ndGggLTE7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykgbmV3IFZleC5SRVJSKFwiSW52YWxpZEluZGV4XCIsXG4gICAgICAgIFwiTXVzdCBiZSBvZiBudW1iZXIgdHlwZVwiKTtcblxuICAgICAgdmFyIHggPSB0aGlzLmdseXBoX3N0YXJ0X3g7XG4gICAgICB2YXIgYmFyX3hfc2hpZnQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4ICsgMTsgKytpKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2x5cGhzW2ldO1xuICAgICAgICB4ICs9IGdseXBoLmdldE1ldHJpY3MoKS53aWR0aDtcbiAgICAgICAgYmFyX3hfc2hpZnQgKz0gZ2x5cGguZ2V0TWV0cmljcygpLndpZHRoO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgcGFkZGluZyBhZnRlciBjbGVmLCB0aW1lIHNpZywga2V5IHNpZ1xuICAgICAgaWYgKGJhcl94X3NoaWZ0ID4gMCkgYmFyX3hfc2hpZnQgKz0gdGhpcy5vcHRpb25zLnZlcnRpY2FsX2Jhcl93aWR0aCArIDEwO1xuXG4gICAgICByZXR1cm4gYmFyX3hfc2hpZnQ7XG4gICAgfSxcblxuICAgIC8vIENvZGEgJiBTZWdubyBTeW1ib2wgZnVuY3Rpb25zXG4gICAgc2V0UmVwZXRpdGlvblR5cGVMZWZ0OiBmdW5jdGlvbih0eXBlLCB5KSB7XG4gICAgICB0aGlzLm1vZGlmaWVycy5wdXNoKG5ldyBWZXguRmxvdy5SZXBldGl0aW9uKHR5cGUsIHRoaXMueCwgeSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFJlcGV0aXRpb25UeXBlUmlnaHQ6IGZ1bmN0aW9uKHR5cGUsIHkpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobmV3IFZleC5GbG93LlJlcGV0aXRpb24odHlwZSwgdGhpcy54LCB5KSApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFZvbHRhIGZ1bmN0aW9uc1xuICAgIHNldFZvbHRhVHlwZTogZnVuY3Rpb24odHlwZSwgbnVtYmVyX3QsIHkpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobmV3IFZleC5GbG93LlZvbHRhKHR5cGUsIG51bWJlcl90LCB0aGlzLngsIHkpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZWN0aW9uIGZ1bmN0aW9uc1xuICAgIHNldFNlY3Rpb246IGZ1bmN0aW9uKHNlY3Rpb24sIHkpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobmV3IFZleC5GbG93LlN0YXZlU2VjdGlvbihzZWN0aW9uLCB0aGlzLngsIHkpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUZW1wbyBmdW5jdGlvbnNcbiAgICBzZXRUZW1wbzogZnVuY3Rpb24odGVtcG8sIHkpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobmV3IFZleC5GbG93LlN0YXZlVGVtcG8odGVtcG8sIHRoaXMueCwgeSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRleHQgZnVuY3Rpb25zXG4gICAgc2V0VGV4dDogZnVuY3Rpb24odGV4dCwgcG9zaXRpb24sIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobmV3IFZleC5GbG93LlN0YXZlVGV4dCh0ZXh0LCBwb3NpdGlvbiwgb3B0aW9ucykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgfSxcblxuICAgIGdldFNwYWNpbmdCZXR3ZWVuTGluZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zcGFjaW5nX2JldHdlZW5fbGluZXNfcHg7XG4gICAgfSxcblxuICAgIGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgVmV4LkZsb3cuQm91bmRpbmdCb3godGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuZ2V0Qm90dG9tWSgpIC0gdGhpcy55KTtcbiAgICAgIC8vIGJvZHkuLi5cbiAgICB9LFxuXG4gICAgZ2V0Qm90dG9tWTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBzcGFjaW5nID0gb3B0aW9ucy5zcGFjaW5nX2JldHdlZW5fbGluZXNfcHg7XG4gICAgICB2YXIgc2NvcmVfYm90dG9tID0gdGhpcy5nZXRZRm9yTGluZShvcHRpb25zLm51bV9saW5lcykgK1xuICAgICAgICAgKG9wdGlvbnMuc3BhY2VfYmVsb3dfc3RhZmZfbG4gKiBzcGFjaW5nKTtcblxuICAgICAgcmV0dXJuIHNjb3JlX2JvdHRvbTtcbiAgICB9LFxuXG4gICAgZ2V0Qm90dG9tTGluZVk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0WUZvckxpbmUodGhpcy5vcHRpb25zLm51bV9saW5lcyk7XG4gICAgfSxcblxuICAgIGdldFlGb3JMaW5lOiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBzcGFjaW5nID0gb3B0aW9ucy5zcGFjaW5nX2JldHdlZW5fbGluZXNfcHg7XG4gICAgICB2YXIgaGVhZHJvb20gPSBvcHRpb25zLnNwYWNlX2Fib3ZlX3N0YWZmX2xuO1xuXG4gICAgICB2YXIgeSA9IHRoaXMueSArICgobGluZSAqIHNwYWNpbmcpICsgKGhlYWRyb29tICogc3BhY2luZykpIC1cbiAgICAgICAgKFRISUNLTkVTUyAvIDIpO1xuXG4gICAgICByZXR1cm4geTtcbiAgICB9LFxuXG4gICAgZ2V0WUZvclRvcFRleHQ6IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBsID0gbGluZSB8fCAwO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0WUZvckxpbmUoLWwgLSB0aGlzLm9wdGlvbnMudG9wX3RleHRfcG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICBnZXRZRm9yQm90dG9tVGV4dDogZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIGwgPSBsaW5lIHx8IDA7XG4gICAgICByZXR1cm4gdGhpcy5nZXRZRm9yTGluZSh0aGlzLm9wdGlvbnMuYm90dG9tX3RleHRfcG9zaXRpb24gKyBsKTtcbiAgICB9LFxuXG4gICAgZ2V0WUZvck5vdGU6IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIHNwYWNpbmcgPSBvcHRpb25zLnNwYWNpbmdfYmV0d2Vlbl9saW5lc19weDtcbiAgICAgIHZhciBoZWFkcm9vbSA9IG9wdGlvbnMuc3BhY2VfYWJvdmVfc3RhZmZfbG47XG4gICAgICB2YXIgeSA9IHRoaXMueSArIChoZWFkcm9vbSAqIHNwYWNpbmcpICsgKDUgKiBzcGFjaW5nKSAtIChsaW5lICogc3BhY2luZyk7XG5cbiAgICAgIHJldHVybiB5O1xuICAgIH0sXG5cbiAgICBnZXRZRm9yR2x5cGhzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFlGb3JMaW5lKDMpO1xuICAgIH0sXG5cbiAgICBhZGRHbHlwaDogZnVuY3Rpb24oZ2x5cGgpIHtcbiAgICAgIGdseXBoLnNldFN0YXZlKHRoaXMpO1xuICAgICAgdGhpcy5nbHlwaHMucHVzaChnbHlwaCk7XG4gICAgICB0aGlzLnN0YXJ0X3ggKz0gZ2x5cGguZ2V0TWV0cmljcygpLndpZHRoO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFkZEVuZEdseXBoOiBmdW5jdGlvbihnbHlwaCkge1xuICAgICAgZ2x5cGguc2V0U3RhdmUodGhpcyk7XG4gICAgICB0aGlzLmVuZF9nbHlwaHMucHVzaChnbHlwaCk7XG4gICAgICB0aGlzLmVuZF94IC09IGdseXBoLmdldE1ldHJpY3MoKS53aWR0aDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhZGRNb2RpZmllcjogZnVuY3Rpb24obW9kaWZpZXIpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgbW9kaWZpZXIuYWRkVG9TdGF2ZSh0aGlzLCAodGhpcy5nbHlwaHMubGVuZ3RoID09PSAwKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYWRkRW5kTW9kaWZpZXI6IGZ1bmN0aW9uKG1vZGlmaWVyKSB7XG4gICAgICB0aGlzLm1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgIG1vZGlmaWVyLmFkZFRvU3RhdmVFbmQodGhpcywgKHRoaXMuZW5kX2dseXBocy5sZW5ndGggPT09IDApKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhZGRLZXlTaWduYXR1cmU6IGZ1bmN0aW9uKGtleVNwZWMpIHtcbiAgICAgIHRoaXMuYWRkTW9kaWZpZXIobmV3IFZleC5GbG93LktleVNpZ25hdHVyZShrZXlTcGVjKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYWRkQ2xlZjogZnVuY3Rpb24oY2xlZiwgc2l6ZSwgYW5ub3RhdGlvbikge1xuICAgICAgdGhpcy5jbGVmID0gY2xlZjtcbiAgICAgIHRoaXMuYWRkTW9kaWZpZXIobmV3IFZleC5GbG93LkNsZWYoY2xlZiwgc2l6ZSwgYW5ub3RhdGlvbikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFkZEVuZENsZWY6IGZ1bmN0aW9uKGNsZWYsIHNpemUsIGFubm90YXRpb24pIHtcbiAgICAgIHRoaXMuYWRkRW5kTW9kaWZpZXIobmV3IFZleC5GbG93LkNsZWYoY2xlZiwgc2l6ZSwgYW5ub3RhdGlvbikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFkZFRpbWVTaWduYXR1cmU6IGZ1bmN0aW9uKHRpbWVTcGVjLCBjdXN0b21QYWRkaW5nKSB7XG4gICAgICB0aGlzLmFkZE1vZGlmaWVyKG5ldyBWZXguRmxvdy5UaW1lU2lnbmF0dXJlKHRpbWVTcGVjLCBjdXN0b21QYWRkaW5nKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYWRkRW5kVGltZVNpZ25hdHVyZTogZnVuY3Rpb24odGltZVNwZWMsIGN1c3RvbVBhZGRpbmcpIHtcbiAgICAgIHRoaXMuYWRkRW5kTW9kaWZpZXIobmV3IFZleC5GbG93LlRpbWVTaWduYXR1cmUodGltZVNwZWMsIGN1c3RvbVBhZGRpbmcpKTtcbiAgICB9LFxuXG4gICAgYWRkVHJlYmxlR2x5cGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGVmID0gXCJ0cmVibGVcIjtcbiAgICAgIHRoaXMuYWRkR2x5cGgobmV3IFZleC5GbG93LkdseXBoKFwidjgzXCIsIDQwKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWxsIGRyYXdpbmcgZnVuY3Rpb25zIGJlbG93IG5lZWQgdGhlIGNvbnRleHQgdG8gYmUgc2V0LlxuICAgICAqL1xuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ2FudmFzQ29udGV4dFwiLFxuICAgICAgICAgIFwiQ2FuJ3QgZHJhdyBzdGF2ZSB3aXRob3V0IGNhbnZhcyBjb250ZXh0LlwiKTtcblxuICAgICAgdmFyIG51bV9saW5lcyA9IHRoaXMub3B0aW9ucy5udW1fbGluZXM7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgdmFyIHggPSB0aGlzLng7XG4gICAgICB2YXIgeTtcbiAgICAgIHZhciBnbHlwaDtcblxuICAgICAgLy8gUmVuZGVyIGxpbmVzXG4gICAgICBmb3IgKHZhciBsaW5lPTA7IGxpbmUgPCBudW1fbGluZXM7IGxpbmUrKykge1xuICAgICAgICB5ID0gdGhpcy5nZXRZRm9yTGluZShsaW5lKTtcblxuICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xuICAgICAgICB0aGlzLmNvbnRleHQuc2V0RmlsbFN0eWxlKHRoaXMub3B0aW9ucy5maWxsX3N0eWxlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnNldFN0cm9rZVN0eWxlKHRoaXMub3B0aW9ucy5maWxsX3N0eWxlKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5lX2NvbmZpZ1tsaW5lXS52aXNpYmxlKSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KHgsIHksIHdpZHRoLCBWZXguRmxvdy5TVEFWRV9MSU5FX1RISUNLTkVTUyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIGdseXBoc1xuICAgICAgeCA9IHRoaXMuZ2x5cGhfc3RhcnRfeDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nbHlwaHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZ2x5cGggPSB0aGlzLmdseXBoc1tpXTtcbiAgICAgICAgaWYgKCFnbHlwaC5nZXRDb250ZXh0KCkpIHtcbiAgICAgICAgICBnbHlwaC5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2x5cGgucmVuZGVyVG9TdGF2ZSh4KTtcbiAgICAgICAgeCArPSBnbHlwaC5nZXRNZXRyaWNzKCkud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbmRlciBlbmQgZ2x5cGhzXG4gICAgICB4ID0gdGhpcy5nbHlwaF9lbmRfeDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmVuZF9nbHlwaHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZ2x5cGggPSB0aGlzLmVuZF9nbHlwaHNbaV07XG4gICAgICAgIGlmICghZ2x5cGguZ2V0Q29udGV4dCgpKSB7XG4gICAgICAgICAgZ2x5cGguc2V0Q29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHggLT0gZ2x5cGguZ2V0TWV0cmljcygpLndpZHRoO1xuICAgICAgICBnbHlwaC5yZW5kZXJUb1N0YXZlKHgpO1xuICAgICAgfVxuXG4gICAgICAvLyBEcmF3IHRoZSBtb2RpZmllcnMgKGJhciBsaW5lcywgY29kYSwgc2Vnbm8sIHJlcGVhdCBicmFja2V0cywgZXRjLilcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBPbmx5IGRyYXcgbW9kaWZpZXIgaWYgaXQgaGFzIGEgZHJhdyBmdW5jdGlvblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMubW9kaWZpZXJzW2ldLmRyYXcgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHRoaXMubW9kaWZpZXJzW2ldLmRyYXcodGhpcywgdGhpcy5nZXRNb2RpZmllclhTaGlmdCgpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIG1lYXN1cmUgbnVtYmVyc1xuICAgICAgaWYgKHRoaXMubWVhc3VyZSA+IDApIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnNldEZvbnQodGhpcy5mb250LmZhbWlseSwgdGhpcy5mb250LnNpemUsIHRoaXMuZm9udC53ZWlnaHQpO1xuICAgICAgICB2YXIgdGV4dF93aWR0aCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dChcIlwiICsgdGhpcy5tZWFzdXJlKS53aWR0aDtcbiAgICAgICAgeSA9IHRoaXMuZ2V0WUZvclRvcFRleHQoMCkgKyAzO1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFRleHQoXCJcIiArIHRoaXMubWVhc3VyZSwgdGhpcy54IC0gdGV4dF93aWR0aCAvIDIsIHkpO1xuICAgICAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRHJhdyBTaW1wbGUgYmFybGluZXMgZm9yIGJhY2t3YXJkIGNvbXBhdGFiaWxpdHlcbiAgICAvLyBEbyBub3QgZGVsZXRlIC0gZHJhd3MgdGhlIGJlZ2lubmluZyBiYXIgb2YgdGhlIHN0YXZlXG4gICAgZHJhd1ZlcnRpY2FsOiBmdW5jdGlvbih4LCBpc0RvdWJsZSkge1xuICAgICAgdGhpcy5kcmF3VmVydGljYWxGaXhlZCh0aGlzLnggKyB4LCBpc0RvdWJsZSk7XG4gICAgfSxcblxuICAgIGRyYXdWZXJ0aWNhbEZpeGVkOiBmdW5jdGlvbih4LCBpc0RvdWJsZSkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ2FudmFzQ29udGV4dFwiLFxuICAgICAgICAgIFwiQ2FuJ3QgZHJhdyBzdGF2ZSB3aXRob3V0IGNhbnZhcyBjb250ZXh0LlwiKTtcblxuICAgICAgdmFyIHRvcF9saW5lID0gdGhpcy5nZXRZRm9yTGluZSgwKTtcbiAgICAgIHZhciBib3R0b21fbGluZSA9IHRoaXMuZ2V0WUZvckxpbmUodGhpcy5vcHRpb25zLm51bV9saW5lcyAtIDEpO1xuICAgICAgaWYgKGlzRG91YmxlKVxuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoeCAtIDMsIHRvcF9saW5lLCAxLCBib3R0b21fbGluZSAtIHRvcF9saW5lICsgMSk7XG4gICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoeCwgdG9wX2xpbmUsIDEsIGJvdHRvbV9saW5lIC0gdG9wX2xpbmUgKyAxKTtcbiAgICB9LFxuXG4gICAgZHJhd1ZlcnRpY2FsQmFyOiBmdW5jdGlvbih4KSB7XG4gICAgICB0aGlzLmRyYXdWZXJ0aWNhbEJhckZpeGVkKHRoaXMueCArIHgsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZHJhd1ZlcnRpY2FsQmFyRml4ZWQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgc3RhdmUgd2l0aG91dCBjYW52YXMgY29udGV4dC5cIik7XG5cbiAgICAgIHZhciB0b3BfbGluZSA9IHRoaXMuZ2V0WUZvckxpbmUoMCk7XG4gICAgICB2YXIgYm90dG9tX2xpbmUgPSB0aGlzLmdldFlGb3JMaW5lKHRoaXMub3B0aW9ucy5udW1fbGluZXMgLSAxKTtcbiAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCh4LCB0b3BfbGluZSwgMSwgYm90dG9tX2xpbmUgLSB0b3BfbGluZSArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBmb3IgdGhlIFN0YXZlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBjb25maWd1cmF0aW9uIG9iamVjdHMuXG4gICAgICovXG4gICAgZ2V0Q29uZmlnRm9yTGluZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5saW5lX2NvbmZpZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIHByb3BlcnRpZXMgb2YgdGhlIGxpbmVzIGluIHRoZSBTdGF2ZVxuICAgICAqIEBwYXJhbSBsaW5lX251bWJlciBUaGUgaW5kZXggb2YgdGhlIGxpbmUgdG8gY29uZmlndXJlLlxuICAgICAqIEBwYXJhbSBsaW5lX2NvbmZpZyBBbiBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBsaW5lLlxuICAgICAqIEB0aHJvd3MgVmV4LlJFUlIgXCJTdGF2ZUNvbmZpZ0Vycm9yXCIgV2hlbiB0aGUgc3BlY2lmaWVkIGxpbmUgbnVtYmVyIGlzIG91dCBvZlxuICAgICAqICAgcmFuZ2Ugb2YgdGhlIG51bWJlciBvZiBsaW5lcyBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIHNldENvbmZpZ0ZvckxpbmU6IGZ1bmN0aW9uKGxpbmVfbnVtYmVyLCBsaW5lX2NvbmZpZykge1xuICAgICAgaWYgKGxpbmVfbnVtYmVyID49IHRoaXMub3B0aW9ucy5udW1fbGluZXMgfHwgbGluZV9udW1iZXIgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIlN0YXZlQ29uZmlnRXJyb3JcIixcbiAgICAgICAgICBcIlRoZSBsaW5lIG51bWJlciBtdXN0IGJlIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgdGhlIG51bWJlciBvZiBsaW5lcyBpbiB0aGUgU3RhdmUuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFsaW5lX2NvbmZpZy5oYXNPd25Qcm9wZXJ0eSgndmlzaWJsZScpKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIlN0YXZlQ29uZmlnRXJyb3JcIixcbiAgICAgICAgICBcIlRoZSBsaW5lIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGlzIG1pc3NpbmcgdGhlICd2aXNpYmxlJyBwcm9wZXJ0eS5cIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mKGxpbmVfY29uZmlnLnZpc2libGUpICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiU3RhdmVDb25maWdFcnJvclwiLFxuICAgICAgICAgIFwiVGhlIGxpbmUgY29uZmlndXJhdGlvbiBvYmplY3RzICd2aXNpYmxlJyBwcm9wZXJ0eSBtdXN0IGJlIHRydWUgb3IgZmFsc2UuXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wdGlvbnMubGluZV9jb25maWdbbGluZV9udW1iZXJdID0gbGluZV9jb25maWc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN0YWZmIGxpbmUgY29uZmlndXJhdGlvbiBhcnJheSBmb3IgYWxsIG9mIHRoZSBsaW5lcyBhdCBvbmNlLlxuICAgICAqIEBwYXJhbSBsaW5lc19jb25maWd1cmF0aW9uIEFuIGFycmF5IG9mIGxpbmUgY29uZmlndXJhdGlvbiBvYmplY3RzLiAgVGhlc2Ugb2JqZWN0c1xuICAgICAqICAgYXJlIG9mIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgc2luZ2xlIG9uZSBwYXNzZWQgaW4gdG8gc2V0TGluZUNvbmZpZ3VyYXRpb24oKS5cbiAgICAgKiAgIFRoZSBjYWxsZXIgY2FuIHNldCBudWxsIGZvciBhbnkgbGluZSBjb25maWcgZW50cnkgaWYgaXQgaXMgZGVzaXJlZCB0aGF0IHRoZSBkZWZhdWx0IGJlIHVzZWRcbiAgICAgKiBAdGhyb3dzIFZleC5SRVJSIFwiU3RhdmVDb25maWdFcnJvclwiIFdoZW4gdGhlIGxpbmVzX2NvbmZpZ3VyYXRpb24gYXJyYXkgZG9lcyBub3QgaGF2ZVxuICAgICAqICAgZXhhY3RseSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYXMgdGhlIG51bV9saW5lcyBjb25maWd1cmF0aW9uIG9iamVjdCBzZXQgaW5cbiAgICAgKiAgIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBzZXRDb25maWdGb3JMaW5lczogZnVuY3Rpb24obGluZXNfY29uZmlndXJhdGlvbikge1xuICAgICAgaWYgKGxpbmVzX2NvbmZpZ3VyYXRpb24ubGVuZ3RoICE9PSB0aGlzLm9wdGlvbnMubnVtX2xpbmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIlN0YXZlQ29uZmlnRXJyb3JcIixcbiAgICAgICAgICBcIlRoZSBsZW5ndGggb2YgdGhlIGxpbmVzIGNvbmZpZ3VyYXRpb24gYXJyYXkgbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGxpbmVzIGluIHRoZSBTdGF2ZVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBkZWZhdWx0cyBhcmUgcHJlc2VudCBpbiBjYXNlIGFuIGluY29tcGxldGUgc2V0IG9mXG4gICAgICAvLyAgY29uZmlndXJhdGlvbiBvcHRpb25zIHdlcmUgc3VwcGxpZWQuXG4gICAgICBmb3IgKHZhciBsaW5lX2NvbmZpZyBpbiBsaW5lc19jb25maWd1cmF0aW9uKSB7XG4gICAgICAgIC8vIEFsbG93ICdudWxsJyB0byBiZSB1c2VkIGlmIHRoZSBjYWxsZXIganVzdCB3YW50cyB0aGUgZGVmYXVsdCBmb3IgYSBwYXJ0aWN1bGFyIG5vZGUuXG4gICAgICAgIGlmICghbGluZXNfY29uZmlndXJhdGlvbltsaW5lX2NvbmZpZ10pIHtcbiAgICAgICAgICBsaW5lc19jb25maWd1cmF0aW9uW2xpbmVfY29uZmlnXSA9IHRoaXMub3B0aW9ucy5saW5lX2NvbmZpZ1tsaW5lX2NvbmZpZ107XG4gICAgICAgIH1cbiAgICAgICAgVmV4Lk1lcmdlKHRoaXMub3B0aW9ucy5saW5lX2NvbmZpZ1tsaW5lX2NvbmZpZ10sIGxpbmVzX2NvbmZpZ3VyYXRpb25bbGluZV9jb25maWddKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zLmxpbmVfY29uZmlnID0gbGluZXNfY29uZmlndXJhdGlvbjtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTdGF2ZTtcbn0oKSk7XG5cbi8vIFZleCBGbG93IE5vdGF0aW9uXG4vLyBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy9cbi8vIENvcHlyaWdodCBNb2hpdCBNdXRoYW5uYSAyMDEwXG4vL1xuLy8gUmVxdWlyZXMgdmV4LmpzLlxuXG4vKiogQGNvbnN0cnVjdG9yICovXG5WZXguRmxvdy5TdGF2ZUNvbm5lY3RvciA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gU3RhdmVDb25uZWN0b3IodG9wX3N0YXZlLCBib3R0b21fc3RhdmUpIHtcbiAgICB0aGlzLmluaXQodG9wX3N0YXZlLCBib3R0b21fc3RhdmUpO1xuICB9XG5cbiAgLy8gU0lOR0xFX0xFRlQgYW5kIFNJTkdMRSBhcmUgdGhlIHNhbWUgdmFsdWUgZm9yIGNvbXBhdGliaWxpdHlcbiAgLy8gd2l0aCBvbGRlciB2ZXJzaW9ucyBvZiB2ZXhmbG93IHdoaWNoIGRpZG4ndCBoYXZlIHJpZ2h0IHNpZGVkXG4gIC8vIHN0YXZlIGNvbm5lY3RvcnNcbiAgU3RhdmVDb25uZWN0b3IudHlwZSA9IHtcbiAgICBTSU5HTEVfUklHSFQgOiAwLFxuICAgIFNJTkdMRV9MRUZUIDogMSxcbiAgICBTSU5HTEU6IDEsXG4gICAgRE9VQkxFOiAyLFxuICAgIEJSQUNFOiAzLFxuICAgIEJSQUNLRVQ6IDQsXG4gICAgQk9MRF9ET1VCTEVfTEVGVDogNSxcbiAgICBCT0xEX0RPVUJMRV9SSUdIVDogNixcbiAgICBUSElOX0RPVUJMRTogN1xuICB9O1xuXG4gIFN0YXZlQ29ubmVjdG9yLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbih0b3Bfc3RhdmUsIGJvdHRvbV9zdGF2ZSkge1xuICAgICAgdGhpcy50aGlja25lc3MgPSBWZXguRmxvdy5TVEFWRV9MSU5FX1RISUNLTkVTUztcbiAgICAgIHRoaXMud2lkdGggPSAzO1xuICAgICAgdGhpcy50b3Bfc3RhdmUgPSB0b3Bfc3RhdmU7XG4gICAgICB0aGlzLmJvdHRvbV9zdGF2ZSA9IGJvdHRvbV9zdGF2ZTtcbiAgICAgIHRoaXMudHlwZSA9IFN0YXZlQ29ubmVjdG9yLnR5cGUuRE9VQkxFO1xuICAgICAgdGhpcy54X3NoaWZ0ID0gMDsgLy8gTWFpbmx5IHVzZWQgdG8gb2Zmc2V0IEJvbGQgRG91YmxlIExlZnQgdG8gYWxpZ24gd2l0aCBvZmZzZXQgUmVwZWF0IEJlZ2luIGJhcnNcbiAgICB9LFxuXG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24oY3R4KSB7XG4gICAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBpZiAodHlwZSA+PSBTdGF2ZUNvbm5lY3Rvci50eXBlLlNJTkdMRV9SSUdIVCAmJlxuICAgICAgICAgIHR5cGUgPD0gU3RhdmVDb25uZWN0b3IudHlwZS5USElOX0RPVUJMRSlcbiAgICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRUZXh0OiBmdW5jdGlvbih0ZXh0LCB0ZXh0X29wdGlvbnMpIHtcbiAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICB0aGlzLnRleHRfb3B0aW9ucyA9IHtcbiAgICAgICAgc2hpZnRfeDogMCxcbiAgICAgICAgc2hpZnRfeTogMFxuICAgICAgfTtcbiAgICAgIFZleC5NZXJnZSh0aGlzLnRleHRfb3B0aW9ucywgdGV4dF9vcHRpb25zKTtcblxuICAgICAgdGhpcy5mb250ID0ge1xuICAgICAgICBmYW1pbHk6IFwidGltZXNcIixcbiAgICAgICAgc2l6ZTogMTYsXG4gICAgICAgIHdlaWdodDogXCJub3JtYWxcIlxuICAgICAgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRGb250OiBmdW5jdGlvbihmb250KSB7XG4gICAgICBWZXguTWVyZ2UodGhpcy5mb250LCBmb250KTtcbiAgICB9LFxuXG4gICAgc2V0WFNoaWZ0OiBmdW5jdGlvbih4X3NoaWZ0KXtcbiAgICAgIGlmICh0eXBlb2YgeF9zaGlmdCAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgdGhyb3cgVmV4LlJFUlIoXCJJbnZhbGlkVHlwZVwiLCBcInhfc2hpZnQgbXVzdCBiZSBhIE51bWJlclwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy54X3NoaWZ0ID0geF9zaGlmdDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jdHgpIHRocm93IG5ldyBWZXguUkVSUihcbiAgICAgICAgICBcIk5vQ29udGV4dFwiLCBcIkNhbid0IGRyYXcgd2l0aG91dCBhIGNvbnRleHQuXCIpO1xuICAgICAgdmFyIHRvcFkgPSB0aGlzLnRvcF9zdGF2ZS5nZXRZRm9yTGluZSgwKTtcbiAgICAgIHZhciBib3RZID0gdGhpcy5ib3R0b21fc3RhdmUuZ2V0WUZvckxpbmUodGhpcy5ib3R0b21fc3RhdmUuZ2V0TnVtTGluZXMoKSAtIDEpICtcbiAgICAgICAgdGhpcy50aGlja25lc3M7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgdmFyIHRvcFggPSB0aGlzLnRvcF9zdGF2ZS5nZXRYKCk7XG5cbiAgICAgIHZhciBpc1JpZ2h0U2lkZWRDb25uZWN0b3IgPSAoXG4gICAgICAgIHRoaXMudHlwZSA9PT0gU3RhdmVDb25uZWN0b3IudHlwZS5TSU5HTEVfUklHSFQgfHxcbiAgICAgICAgdGhpcy50eXBlID09PSBTdGF2ZUNvbm5lY3Rvci50eXBlLkJPTERfRE9VQkxFX1JJR0hUIHx8XG4gICAgICAgIHRoaXMudHlwZSA9PT0gU3RhdmVDb25uZWN0b3IudHlwZS5USElOX0RPVUJMRVxuICAgICAgKTtcblxuICAgICAgaWYgKGlzUmlnaHRTaWRlZENvbm5lY3Rvcil7XG4gICAgICAgIHRvcFggPSB0aGlzLnRvcF9zdGF2ZS5nZXRYKCkgKyB0aGlzLnRvcF9zdGF2ZS53aWR0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIGF0dGFjaG1lbnRfaGVpZ2h0ID0gYm90WSAtIHRvcFk7XG4gICAgICBzd2l0Y2ggKHRoaXMudHlwZSkge1xuICAgICAgICBjYXNlIFN0YXZlQ29ubmVjdG9yLnR5cGUuU0lOR0xFOlxuICAgICAgICAgIHdpZHRoID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdGF2ZUNvbm5lY3Rvci50eXBlLlNJTkdMRV9MRUZUOlxuICAgICAgICAgIHdpZHRoID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdGF2ZUNvbm5lY3Rvci50eXBlLlNJTkdMRV9SSUdIVDpcbiAgICAgICAgICB3aWR0aCA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3RhdmVDb25uZWN0b3IudHlwZS5ET1VCTEU6XG4gICAgICAgICAgdG9wWCAtPSAodGhpcy53aWR0aCArIDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN0YXZlQ29ubmVjdG9yLnR5cGUuQlJBQ0U6XG4gICAgICAgICAgd2lkdGggPSAxMjtcbiAgICAgICAgICAvLyBNYXkgbmVlZCBhZGRpdGlvbmFsIGNvZGUgdG8gZHJhdyBicmFjZVxuICAgICAgICAgIHZhciB4MSA9IHRoaXMudG9wX3N0YXZlLmdldFgoKSAtIDI7XG4gICAgICAgICAgdmFyIHkxID0gdG9wWTtcbiAgICAgICAgICB2YXIgeDMgPSB4MTtcbiAgICAgICAgICB2YXIgeTMgPSBib3RZO1xuICAgICAgICAgIHZhciB4MiA9IHgxIC0gd2lkdGg7XG4gICAgICAgICAgdmFyIHkyID0geTEgKyBhdHRhY2htZW50X2hlaWdodC8yLjA7XG4gICAgICAgICAgdmFyIGNweDEgPSB4MiAtICgwLjkwICogd2lkdGgpO1xuICAgICAgICAgIHZhciBjcHkxID0geTEgKyAoMC4yICogYXR0YWNobWVudF9oZWlnaHQpO1xuICAgICAgICAgIHZhciBjcHgyID0geDEgKyAoMS4xMCAqIHdpZHRoKTtcbiAgICAgICAgICB2YXIgY3B5MiA9IHkyIC0gKDAuMTM1ICogYXR0YWNobWVudF9oZWlnaHQpO1xuICAgICAgICAgIHZhciBjcHgzID0gY3B4MjtcbiAgICAgICAgICB2YXIgY3B5MyA9IHkyICsgKDAuMTM1ICogYXR0YWNobWVudF9oZWlnaHQpO1xuICAgICAgICAgIHZhciBjcHg0ID0gY3B4MTtcbiAgICAgICAgICB2YXIgY3B5NCA9IHkzIC0gKDAuMiAqIGF0dGFjaG1lbnRfaGVpZ2h0KTtcbiAgICAgICAgICB2YXIgY3B4NSA9IHgyIC0gd2lkdGg7XG4gICAgICAgICAgdmFyIGNweTUgPSBjcHk0O1xuICAgICAgICAgIHZhciBjcHg2ID0geDEgKyAoMC40MCAqIHdpZHRoKTtcbiAgICAgICAgICB2YXIgY3B5NiA9IHkyICsgKDAuMTM1ICogYXR0YWNobWVudF9oZWlnaHQpO1xuICAgICAgICAgIHZhciBjcHg3ID0gY3B4NjtcbiAgICAgICAgICB2YXIgY3B5NyA9IHkyIC0gKDAuMTM1ICogYXR0YWNobWVudF9oZWlnaHQpO1xuICAgICAgICAgIHZhciBjcHg4ID0gY3B4NTtcbiAgICAgICAgICB2YXIgY3B5OCA9IGNweTE7XG4gICAgICAgICAgdGhpcy5jdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgdGhpcy5jdHgubW92ZVRvKHgxLCB5MSk7XG4gICAgICAgICAgdGhpcy5jdHguYmV6aWVyQ3VydmVUbyhjcHgxLCBjcHkxLCBjcHgyLCBjcHkyLCB4MiwgeTIpO1xuICAgICAgICAgIHRoaXMuY3R4LmJlemllckN1cnZlVG8oY3B4MywgY3B5MywgY3B4NCwgY3B5NCwgeDMsIHkzKTtcbiAgICAgICAgICB0aGlzLmN0eC5iZXppZXJDdXJ2ZVRvKGNweDUsIGNweTUsIGNweDYsIGNweTYsIHgyLCB5Mik7XG4gICAgICAgICAgdGhpcy5jdHguYmV6aWVyQ3VydmVUbyhjcHg3LCBjcHk3LCBjcHg4LCBjcHk4LCB4MSwgeTEpO1xuICAgICAgICAgIHRoaXMuY3R4LmZpbGwoKTtcbiAgICAgICAgICB0aGlzLmN0eC5zdHJva2UoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdGF2ZUNvbm5lY3Rvci50eXBlLkJSQUNLRVQ6XG4gICAgICAgICAgdG9wWSAtPSA0O1xuICAgICAgICAgIGJvdFkgKz0gNDtcbiAgICAgICAgICBhdHRhY2htZW50X2hlaWdodCA9IGJvdFkgLSB0b3BZO1xuICAgICAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKHRoaXMuY3R4LCB0b3BYIC0gNSwgdG9wWSAtIDMsIDQwLCBcInYxYlwiLCB0cnVlKTtcbiAgICAgICAgICBWZXguRmxvdy5yZW5kZXJHbHlwaCh0aGlzLmN0eCwgdG9wWCAtIDUsIGJvdFkgKyAzLCA0MCwgXCJ2MTBcIiwgdHJ1ZSk7XG4gICAgICAgICAgdG9wWCAtPSAodGhpcy53aWR0aCArIDIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN0YXZlQ29ubmVjdG9yLnR5cGUuQk9MRF9ET1VCTEVfTEVGVDpcbiAgICAgICAgICBkcmF3Qm9sZERvdWJsZUxpbmUodGhpcy5jdHgsIHRoaXMudHlwZSwgdG9wWCArIHRoaXMueF9zaGlmdCwgdG9wWSwgYm90WSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3RhdmVDb25uZWN0b3IudHlwZS5CT0xEX0RPVUJMRV9SSUdIVDpcbiAgICAgICAgICBkcmF3Qm9sZERvdWJsZUxpbmUodGhpcy5jdHgsIHRoaXMudHlwZSwgdG9wWCwgdG9wWSwgYm90WSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3RhdmVDb25uZWN0b3IudHlwZS5USElOX0RPVUJMRTpcbiAgICAgICAgICB3aWR0aCA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnR5cGUgIT09IFN0YXZlQ29ubmVjdG9yLnR5cGUuQlJBQ0UgJiZcbiAgICAgICAgdGhpcy50eXBlICE9PSBTdGF2ZUNvbm5lY3Rvci50eXBlLkJPTERfRE9VQkxFX0xFRlQgJiZcbiAgICAgICAgdGhpcy50eXBlICE9PSBTdGF2ZUNvbm5lY3Rvci50eXBlLkJPTERfRE9VQkxFX1JJR0hUKSB7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHRvcFggLCB0b3BZLCB3aWR0aCwgYXR0YWNobWVudF9oZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGUgY29ubmVjdG9yIGlzIGEgdGhpbiBkb3VibGUgYmFybGluZSwgZHJhdyB0aGUgcGFyYWxlbGwgbGluZVxuICAgICAgaWYgKHRoaXMudHlwZSA9PT0gU3RhdmVDb25uZWN0b3IudHlwZS5USElOX0RPVUJMRSkge1xuICAgICAgICB0aGlzLmN0eC5maWxsUmVjdCh0b3BYIC0gMywgdG9wWSwgd2lkdGgsIGF0dGFjaG1lbnRfaGVpZ2h0KTtcbiAgICAgIH1cblxuICAgICAgLy8gQWRkIHN0YXZlIGNvbm5lY3RvciB0ZXh0XG4gICAgICBpZiAodGhpcy50ZXh0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgICAgICB0aGlzLmN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgICB0aGlzLmN0eC5zZXRGb250KHRoaXMuZm9udC5mYW1pbHksIHRoaXMuZm9udC5zaXplLCB0aGlzLmZvbnQud2VpZ2h0KTtcbiAgICAgICAgdmFyIHRleHRfd2lkdGggPSB0aGlzLmN0eC5tZWFzdXJlVGV4dChcIlwiICsgdGhpcy50ZXh0KS53aWR0aDtcblxuICAgICAgICB2YXIgeCA9IHRoaXMudG9wX3N0YXZlLmdldFgoKSAtIHRleHRfd2lkdGggLSAyNCArIHRoaXMudGV4dF9vcHRpb25zLnNoaWZ0X3g7XG4gICAgICAgIHZhciB5ID0gKHRoaXMudG9wX3N0YXZlLmdldFlGb3JMaW5lKDApICsgdGhpcy5ib3R0b21fc3RhdmUuZ2V0Qm90dG9tTGluZVkoKSkgLyAyICtcbiAgICAgICAgICB0aGlzLnRleHRfb3B0aW9ucy5zaGlmdF95O1xuXG4gICAgICAgIHRoaXMuY3R4LmZpbGxUZXh0KFwiXCIgKyB0aGlzLnRleHQsIHgsIHkgKyA0KTtcbiAgICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcblxuICBmdW5jdGlvbiBkcmF3Qm9sZERvdWJsZUxpbmUoY3R4LCB0eXBlLCB0b3BYLCB0b3BZLCBib3RZKXtcbiAgICBpZiAodHlwZSAhPT0gU3RhdmVDb25uZWN0b3IudHlwZS5CT0xEX0RPVUJMRV9MRUZUICYmXG4gICAgICAgIHR5cGUgIT09IFN0YXZlQ29ubmVjdG9yLnR5cGUuQk9MRF9ET1VCTEVfUklHSFQpIHtcbiAgICAgIHRocm93IFZleC5SRVJSKFwiSW52YWxpZENvbm5lY3RvclwiLFxuICAgICAgICBcIkEgUkVQRUFUX0JFR0lOIG9yIFJFUEVBVF9FTkQgdHlwZSBtdXN0IGJlIHByb3ZpZGVkLlwiKTtcbiAgICB9XG5cbiAgICB2YXIgeF9zaGlmdCA9IDM7XG4gICAgdmFyIHZhcmlhYmxlV2lkdGggPSAzLjU7IC8vIFdpZHRoIGZvciBhdm9pZGluZyBhbnRpLWFsaWFzaW5nIHdpZHRoIGlzc3Vlc1xuICAgIHZhciB0aGlja0xpbmVPZmZzZXQgPSAyOyAvLyBGb3IgYWVzdGhldGljc1xuXG4gICAgaWYgKHR5cGUgPT09IFN0YXZlQ29ubmVjdG9yLnR5cGUuQk9MRF9ET1VCTEVfUklHSFQpIHtcbiAgICAgIHhfc2hpZnQgPSAtNTsgLy8gRmxpcHMgdGhlIHNpZGUgb2YgdGhlIHRoaW4gbGluZVxuICAgICAgdmFyaWFibGVXaWR0aCA9IDM7XG4gICAgfVxuXG4gICAgLy8gVGhpbiBsaW5lXG4gICAgY3R4LmZpbGxSZWN0KHRvcFggKyB4X3NoaWZ0LCB0b3BZLCAxLCBib3RZIC0gdG9wWSk7XG4gICAgLy8gVGhpY2sgbGluZVxuICAgIGN0eC5maWxsUmVjdCh0b3BYIC0gdGhpY2tMaW5lT2Zmc2V0LCB0b3BZLCB2YXJpYWJsZVdpZHRoLCBib3RZIC0gdG9wWSk7XG4gIH1cblxuICByZXR1cm4gU3RhdmVDb25uZWN0b3I7XG59KCkpO1xuLy8gVmV4IEZsb3dcbi8vIE1vaGl0IE11dGhhbm5hIDxtb2hpdEBtdXRoYW5uYS5jb20+XG4vL1xuLy8gQ29weXJpZ2h0IE1vaGl0IENoZXBwdWRpcmEgMjAxMFxuXG4vKiogQGNvbnN0cnVjdG9yICovXG5WZXguRmxvdy5UYWJTdGF2ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gVGFiU3RhdmUoeCwgeSwgd2lkdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdCh4LCB5LCB3aWR0aCwgb3B0aW9ucyk7XG4gIH1cblxuICBWZXguSW5oZXJpdChUYWJTdGF2ZSwgVmV4LkZsb3cuU3RhdmUsIHtcbiAgICBpbml0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgb3B0aW9ucykge1xuICAgICAgdmFyIHRhYl9vcHRpb25zID0ge1xuICAgICAgICBzcGFjaW5nX2JldHdlZW5fbGluZXNfcHg6IDEzLFxuICAgICAgICBudW1fbGluZXM6IDYsXG4gICAgICAgIHRvcF90ZXh0X3Bvc2l0aW9uOiAxXG4gICAgICB9O1xuXG4gICAgICBWZXguTWVyZ2UodGFiX29wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgVGFiU3RhdmUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgeCwgeSwgd2lkdGgsIHRhYl9vcHRpb25zKTtcbiAgICB9LFxuXG4gICAgZ2V0WUZvckdseXBoczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5nZXRZRm9yTGluZSgyLjUpO1xuICAgIH0sXG5cbiAgICBhZGRUYWJHbHlwaDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZ2x5cGhTY2FsZTtcbiAgICAgIHZhciBnbHlwaE9mZnNldDtcblxuICAgICAgc3dpdGNoKHRoaXMub3B0aW9ucy5udW1fbGluZXMpIHtcbiAgICAgICAgY2FzZSA4OlxuICAgICAgICAgIGdseXBoU2NhbGUgPSA1NTtcbiAgICAgICAgICBnbHlwaE9mZnNldCA9IDE0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDc6XG4gICAgICAgICAgZ2x5cGhTY2FsZSA9IDQ3O1xuICAgICAgICAgIGdseXBoT2Zmc2V0ID0gODtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA2OlxuICAgICAgICAgIGdseXBoU2NhbGUgPSA0MDtcbiAgICAgICAgICBnbHlwaE9mZnNldCA9IDE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNTpcbiAgICAgICAgICBnbHlwaFNjYWxlID0gMzA7XG4gICAgICAgICAgZ2x5cGhPZmZzZXQgPSAtNjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA0OlxuICAgICAgICAgIGdseXBoU2NhbGUgPSAyMztcbiAgICAgICAgICBnbHlwaE9mZnNldCA9IC0xMjtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgdmFyIHRhYkdseXBoID0gbmV3IFZleC5GbG93LkdseXBoKFwidjJmXCIsIGdseXBoU2NhbGUpO1xuICAgICAgdGFiR2x5cGgueV9zaGlmdCA9IGdseXBoT2Zmc2V0O1xuICAgICAgdGhpcy5hZGRHbHlwaCh0YWJHbHlwaCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBUYWJTdGF2ZTtcbn0oKSk7XG4vLyBWZXggRmxvd1xuLy8gQ29weXJpZ2h0IE1vaGl0IENoZXBwdWRpcmEgPG1vaGl0QG11dGhhbm5hLmNvbT5cbi8vXG4vLyBBIGZvcm1hdHRlciBmb3IgYWJzdHJhY3QgdGlja2FibGUgb2JqZWN0cywgc3VjaCBhcyBub3RlcywgY2hvcmRzLFxuLy8gdGFicywgZXRjLlxuXG4vKiogQGNvbnN0cnVjdG9yICovXG5WZXguRmxvdy5UaWNrQ29udGV4dCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gVGlja0NvbnRleHQoKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBUaWNrQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmN1cnJlbnRUaWNrID0gbmV3IFZleC5GbG93LkZyYWN0aW9uKDAsIDEpO1xuICAgICAgdGhpcy5tYXhUaWNrcyA9IG5ldyBWZXguRmxvdy5GcmFjdGlvbigwLCAxKTtcbiAgICAgIHRoaXMubWluVGlja3MgPSBudWxsO1xuICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICB0aGlzLnBhZGRpbmcgPSAzOyAgICAgLy8gcGFkZGluZyBvbiBlYWNoIHNpZGUgKHdpZHRoICs9IHBhZGRpbmcgKiAyKVxuICAgICAgdGhpcy5waXhlbHNVc2VkID0gMDtcbiAgICAgIHRoaXMueCA9IDA7XG4gICAgICB0aGlzLnRpY2thYmxlcyA9IFtdOyAgIC8vIE5vdGVzLCB0YWJzLCBjaG9yZHMsIGx5cmljcy5cbiAgICAgIHRoaXMubm90ZVB4ID0gMDsgICAgICAgLy8gd2lkdGggb2Ygd2lkZXN0IG5vdGUgaW4gdGhpcyBjb250ZXh0XG4gICAgICB0aGlzLmV4dHJhTGVmdFB4ID0gMDsgIC8vIEV4dHJhIGxlZnQgcGl4ZWxzIGZvciBtb2RpZmVycyAmIGRpc3BsYWNlIG5vdGVzXG4gICAgICB0aGlzLmV4dHJhUmlnaHRQeCA9IDA7IC8vIEV4dHJhIHJpZ2h0IHBpeGVscyBmb3IgbW9kaWZlcnMgJiBkaXNwbGFjZSBub3Rlc1xuICAgICAgdGhpcy5hbGlnbl9jZW50ZXIgPSBmYWxzZTtcblxuICAgICAgdGhpcy50Q29udGV4dHMgPSBbXTsgICAvLyBQYXJlbnQgYXJyYXkgb2YgdGljayBjb250ZXh0c1xuXG4gICAgICAvLyBJZ25vcmUgdGhpcyB0aWNrIGNvbnRleHQgZm9yIGZvcm1hdHRpbmcgYW5kIGp1c3RpZmljYXRpb25cbiAgICAgIHRoaXMuaWdub3JlX3RpY2tzID0gdHJ1ZTtcbiAgICAgIHRoaXMucHJlRm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnBvc3RGb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7IC8vIFJlbmRlcmluZyBjb250ZXh0XG4gICAgfSxcblxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHsgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvbnRleHQ7IH0sXG4gICAgc2hvdWxkSWdub3JlVGlja3M6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pZ25vcmVfdGlja3M7IH0sXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy53aWR0aCArICh0aGlzLnBhZGRpbmcgKiAyKTsgfSxcbiAgICBnZXRYOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueDsgfSxcbiAgICBzZXRYOiBmdW5jdGlvbih4KSB7IHRoaXMueCA9IHg7IHJldHVybiB0aGlzOyB9LFxuICAgIGdldFBpeGVsc1VzZWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5waXhlbHNVc2VkOyB9LFxuICAgIHNldFBpeGVsc1VzZWQ6IGZ1bmN0aW9uKHBpeGVsc1VzZWQpIHsgdGhpcy5waXhlbHNVc2VkID0gcGl4ZWxzVXNlZDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgc2V0UGFkZGluZzogZnVuY3Rpb24ocGFkZGluZykgeyB0aGlzLnBhZGRpbmcgPSBwYWRkaW5nOyByZXR1cm4gdGhpczsgfSxcbiAgICBnZXRNYXhUaWNrczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm1heFRpY2tzOyB9LFxuICAgIGdldE1pblRpY2tzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubWluVGlja3M7IH0sXG4gICAgZ2V0VGlja2FibGVzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudGlja2FibGVzOyB9LFxuXG4gICAgZ2V0Q2VudGVyQWxpZ25lZFRpY2thYmxlczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50aWNrYWJsZXMuZmlsdGVyKGZ1bmN0aW9uKHRpY2thYmxlKSB7XG4gICAgICAgIHJldHVybiB0aWNrYWJsZS5pc0NlbnRlckFsaWduZWQoKTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgd2lkdGhzIGNvbnRleHQsIG5vdGUgYW5kIGxlZnQvcmlnaHQgbW9kaWZpZXJzIGZvciBmb3JtYXR0aW5nXG4gICAgZ2V0TWV0cmljczogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4geyB3aWR0aDogdGhpcy53aWR0aCwgbm90ZVB4OiB0aGlzLm5vdGVQeCxcbiAgICAgICAgICAgICAgIGV4dHJhTGVmdFB4OiB0aGlzLmV4dHJhTGVmdFB4LCBleHRyYVJpZ2h0UHg6IHRoaXMuZXh0cmFSaWdodFB4IH07XG4gICAgfSxcblxuICAgIGdldEN1cnJlbnRUaWNrOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY3VycmVudFRpY2s7IH0sXG4gICAgc2V0Q3VycmVudFRpY2s6IGZ1bmN0aW9uKHRpY2spIHtcbiAgICAgIHRoaXMuY3VycmVudFRpY2sgPSB0aWNrO1xuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGxlZnQgJiByaWdodCBwaXhlbHMgdXNlZCBmb3IgbW9kaWZpZXJzXG4gICAgZ2V0RXh0cmFQeDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbGVmdF9zaGlmdCA9IDA7XG4gICAgICB2YXIgcmlnaHRfc2hpZnQgPSAwO1xuICAgICAgdmFyIGV4dHJhTGVmdFB4ID0gMDtcbiAgICAgIHZhciBleHRyYVJpZ2h0UHggPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnRpY2thYmxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBleHRyYUxlZnRQeCA9IE1hdGgubWF4KHRoaXMudGlja2FibGVzW2ldLmV4dHJhTGVmdFB4LCBleHRyYUxlZnRQeCk7XG4gICAgICAgIGV4dHJhUmlnaHRQeCA9IE1hdGgubWF4KHRoaXMudGlja2FibGVzW2ldLmV4dHJhUmlnaHRQeCwgZXh0cmFSaWdodFB4KTtcbiAgICAgICAgdmFyIG1Db250ZXh0ID0gdGhpcy50aWNrYWJsZXNbaV0ubW9kaWZpZXJDb250ZXh0O1xuICAgICAgICBpZiAobUNvbnRleHQgJiYgbUNvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICAgIGxlZnRfc2hpZnQgPSBNYXRoLm1heCggbGVmdF9zaGlmdCwgbUNvbnRleHQuc3RhdGUubGVmdF9zaGlmdCk7XG4gICAgICAgICAgcmlnaHRfc2hpZnQgPSBNYXRoLm1heCggcmlnaHRfc2hpZnQsIG1Db250ZXh0LnN0YXRlLnJpZ2h0X3NoaWZ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHsgbGVmdDogbGVmdF9zaGlmdCwgcmlnaHQ6IHJpZ2h0X3NoaWZ0LFxuICAgICAgICAgICAgICAgZXh0cmFMZWZ0OiBleHRyYUxlZnRQeCwgZXh0cmFSaWdodDogZXh0cmFSaWdodFB4IH07XG4gICAgfSxcblxuICAgIGFkZFRpY2thYmxlOiBmdW5jdGlvbih0aWNrYWJsZSkge1xuICAgICAgaWYgKCF0aWNrYWJsZSkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudFwiLCBcIkludmFsaWQgdGlja2FibGUgYWRkZWQuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAoIXRpY2thYmxlLnNob3VsZElnbm9yZVRpY2tzKCkpIHtcbiAgICAgICAgdGhpcy5pZ25vcmVfdGlja3MgPSBmYWxzZTtcblxuICAgICAgICB2YXIgdGlja3MgPSB0aWNrYWJsZS5nZXRUaWNrcygpO1xuXG4gICAgICAgIGlmICh0aWNrcy5ncmVhdGVyVGhhbih0aGlzLm1heFRpY2tzKSkge1xuICAgICAgICAgIHRoaXMubWF4VGlja3MgPSB0aWNrcy5jbG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHRoaXMubWluVGlja3MgPT0gbnVsbCkge1xuICAgICAgICAgIHRoaXMubWluVGlja3MgPSB0aWNrcy5jbG9uZSgpO1xuICAgICAgICB9IGVsc2UgaWYgKHRpY2tzLmxlc3NUaGFuKHRoaXMubWluVGlja3MpKSB7XG4gICAgICAgICAgdGhpcy5taW5UaWNrcyA9IHRpY2tzLmNsb25lKCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGlja2FibGUuc2V0VGlja0NvbnRleHQodGhpcyk7XG4gICAgICB0aGlzLnRpY2thYmxlcy5wdXNoKHRpY2thYmxlKTtcbiAgICAgIHRoaXMucHJlRm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcHJlRm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnByZUZvcm1hdHRlZCkgcmV0dXJuO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGlja2FibGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB0aWNrYWJsZSA9IHRoaXMudGlja2FibGVzW2ldO1xuICAgICAgICB0aWNrYWJsZS5wcmVGb3JtYXQoKTtcbiAgICAgICAgdmFyIG1ldHJpY3MgPSB0aWNrYWJsZS5nZXRNZXRyaWNzKCk7XG5cbiAgICAgICAgLy8gTWFpbnRhaW4gbWF4IGV4dHJhIHBpeGVscyBmcm9tIGFsbCB0aWNrYWJsZXMgaW4gdGhlIGNvbnRleHRcbiAgICAgICAgdGhpcy5leHRyYUxlZnRQeCA9IE1hdGgubWF4KHRoaXMuZXh0cmFMZWZ0UHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtZXRyaWNzLmV4dHJhTGVmdFB4ICsgbWV0cmljcy5tb2RMZWZ0UHgpO1xuICAgICAgICB0aGlzLmV4dHJhUmlnaHRQeCA9IE1hdGgubWF4KHRoaXMuZXh0cmFSaWdodFB4LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldHJpY3MuZXh0cmFSaWdodFB4ICsgbWV0cmljcy5tb2RSaWdodFB4KTtcblxuICAgICAgICAvLyBNYWludGFpbiB0aGUgd2lkZXN0IG5vdGUgZm9yIGFsbCB0aWNrYWJsZXMgaW4gdGhlIGNvbnRleHRcbiAgICAgICAgdGhpcy5ub3RlUHggPSBNYXRoLm1heCh0aGlzLm5vdGVQeCwgbWV0cmljcy5ub3RlV2lkdGgpO1xuXG4gICAgICAgIC8vIFJlY2FsY3VsYXRlIHRoZSB0aWNrIGNvbnRleHQgdG90YWwgd2lkdGhcbiAgICAgICAgdGhpcy53aWR0aCA9IHRoaXMubm90ZVB4ICtcbiAgICAgICAgICAgICAgICAgICAgIHRoaXMuZXh0cmFMZWZ0UHggK1xuICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRyYVJpZ2h0UHg7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwb3N0Rm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBvc3RGb3JtYXR0ZWQpIHJldHVybiB0aGlzO1xuICAgICAgdGhpcy5wb3N0Rm9ybWF0dGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICBUaWNrQ29udGV4dC5nZXROZXh0Q29udGV4dCA9IGZ1bmN0aW9uKHRDb250ZXh0KSB7XG4gICAgdmFyIGNvbnRleHRzID0gdENvbnRleHQudENvbnRleHRzO1xuICAgIHZhciBpbmRleCA9IGNvbnRleHRzLmluZGV4T2YodENvbnRleHQpO1xuXG4gICAgcmV0dXJuIGNvbnRleHRzW2luZGV4KzFdO1xuICB9O1xuXG4gIHJldHVybiBUaWNrQ29udGV4dDtcbn0oKSk7XG5cbi8vIFZleCBGbG93XG4vLyBDb3B5cmlnaHQgTW9oaXQgQ2hlcHB1ZGlyYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy9cbi8vIFRoZSB0aWNrYWJsZSBpbnRlcmZhY2UuIFRpY2thYmxlcyBhcmUgdGhpbmdzIHRoYXQgc2l0IG9uIGEgc2NvcmUgYW5kXG4vLyBoYXZlIGEgZHVyYXRpb24sIGkuZS4sIHRoZXkgb2NjdXB5IHNwYWNlIGluIHRoZSBtdXNpY2FsIHJlbmRlcmluZyBkaW1lbnNpb24uXG5cbi8qKiBAY29uc3RydWN0b3IgKi9cblZleC5GbG93LlRpY2thYmxlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUaWNrYWJsZSgpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIFRpY2thYmxlLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuaW50cmluc2ljVGlja3MgPSAwO1xuICAgICAgdGhpcy50aWNrTXVsdGlwbGllciA9IG5ldyBWZXguRmxvdy5GcmFjdGlvbigxLCAxKTtcbiAgICAgIHRoaXMudGlja3MgPSBuZXcgVmV4LkZsb3cuRnJhY3Rpb24oMCwgMSk7XG4gICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgIHRoaXMueF9zaGlmdCA9IDA7IC8vIFNoaWZ0IGZyb20gdGljayBjb250ZXh0XG4gICAgICB0aGlzLnZvaWNlID0gbnVsbDtcbiAgICAgIHRoaXMudGlja0NvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy5tb2RpZmllckNvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcbiAgICAgIHRoaXMucHJlRm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICB0aGlzLnBvc3RGb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMudHVwbGV0ID0gbnVsbDtcblxuICAgICAgLy8gRm9yIGludGVyYWN0aXZpdHlcbiAgICAgIHRoaXMuaWQgPSBudWxsO1xuICAgICAgdGhpcy5lbGVtID0gbnVsbDtcblxuICAgICAgdGhpcy5hbGlnbl9jZW50ZXIgPSBmYWxzZTtcbiAgICAgIHRoaXMuY2VudGVyX3hfc2hpZnQgPSAwOyAvLyBTaGlmdCBmcm9tIHRpY2sgY29udGV4dCBpZiBjZW50ZXIgYWxpZ25lZFxuXG4gICAgICAvLyBUaGlzIGZsYWcgdGVsbHMgdGhlIGZvcm1hdHRlciB0byBpZ25vcmUgdGhpcyB0aWNrYWJsZSBkdXJpbmdcbiAgICAgIC8vIGZvcm1hdHRpbmcgYW5kIGp1c3RpZmljYXRpb24uIEl0IGlzIHNldCBieSB0aWNrYWJsZXMgc3VjaCBhcyBCYXJOb3RlLlxuICAgICAgdGhpcy5pZ25vcmVfdGlja3MgPSBmYWxzZTtcbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgfSxcblxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHsgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgfSxcblxuICAgIC8vIFNldCB0aGUgRE9NIElEIG9mIHRoZSBlbGVtZW50LiBNdXN0IGJlIGNhbGxlZCBiZWZvcmUgZHJhdygpLiBUT0RPOiBVcGRhdGVcbiAgICAvLyBJRCBvZiBlbGVtZW50IGlmIGhhcyBhbHJlYWR5IGJlZW4gcmVuZGVyZWQuXG4gICAgc2V0SWQ6IGZ1bmN0aW9uKGlkKSB7IHRoaXMuaWQgPSBpZDsgfSxcbiAgICBnZXRJZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlkOyB9LFxuICAgIGdldEVsZW06IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5lbGVtOyB9LFxuICAgIGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbigpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgZ2V0VGlja3M6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50aWNrczsgfSxcbiAgICBzaG91bGRJZ25vcmVUaWNrczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlnbm9yZV90aWNrczsgfSxcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLndpZHRoOyB9LFxuICAgIHNldFhTaGlmdDogZnVuY3Rpb24oeCkgeyB0aGlzLnhfc2hpZnQgPSB4OyB9LFxuICAgIGdldENlbnRlclhTaGlmdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5pc0NlbnRlckFsaWduZWQoKSkge1xuICAgICAgICByZXR1cm4gdGhpcy5jZW50ZXJfeF9zaGlmdDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIDA7XG4gICAgfSxcblxuICAgIGlzQ2VudGVyQWxpZ25lZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmFsaWduX2NlbnRlcjsgfSxcbiAgICBzZXRDZW50ZXJBbGlnbm1lbnQ6IGZ1bmN0aW9uKGFsaWduX2NlbnRlcikge1xuICAgICAgdGhpcy5hbGlnbl9jZW50ZXIgPSBhbGlnbl9jZW50ZXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRXZlcnkgdGlja2FibGUgbXVzdCBiZSBhc3NvY2lhdGVkIHdpdGggYSB2b2ljZS4gVGhpcyBhbGxvd3MgZm9ybWF0dGVyc1xuICAgIC8vIGFuZCBwcmVGb3JtYXR0ZXIgdG8gYXNzb2NpYXRlIHRoZW0gd2l0aCB0aGUgcmlnaHQgbW9kaWZpZXJDb250ZXh0cy5cbiAgICBnZXRWb2ljZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMudm9pY2UpIHRocm93IG5ldyBWZXguUkVSUihcIk5vVm9pY2VcIiwgXCJUaWNrYWJsZSBoYXMgbm8gdm9pY2UuXCIpO1xuICAgICAgcmV0dXJuIHRoaXMudm9pY2U7XG4gICAgfSxcbiAgICBzZXRWb2ljZTogZnVuY3Rpb24odm9pY2UpIHsgdGhpcy52b2ljZSA9IHZvaWNlOyB9LFxuXG4gICAgZ2V0VHVwbGV0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudHVwbGV0OyB9LFxuICAgIHNldFR1cGxldDogZnVuY3Rpb24odHVwbGV0KSB7XG4gICAgICAvLyBEZXRhY2ggZnJvbSBwcmV2aW91cyB0dXBsZXRcbiAgICAgIHZhciBub3RlQ291bnQsIGJlYXRzT2NjdXBpZWQ7XG5cbiAgICAgIGlmICh0aGlzLnR1cGxldCkge1xuICAgICAgICBub3RlQ291bnQgPSB0aGlzLnR1cGxldC5nZXROb3RlQ291bnQoKTtcbiAgICAgICAgYmVhdHNPY2N1cGllZCA9IHRoaXMudHVwbGV0LmdldEJlYXRzT2NjdXBpZWQoKTtcblxuICAgICAgICAvLyBSZXZlcnQgb2xkIG11bHRpcGxpZXJcbiAgICAgICAgdGhpcy5hcHBseVRpY2tNdWx0aXBsaWVyKG5vdGVDb3VudCwgYmVhdHNPY2N1cGllZCk7XG4gICAgICB9XG5cbiAgICAgIC8vIEF0dGFjaCB0byBuZXcgdHVwbGV0XG4gICAgICBpZiAodHVwbGV0KSB7XG4gICAgICAgIG5vdGVDb3VudCA9IHR1cGxldC5nZXROb3RlQ291bnQoKTtcbiAgICAgICAgYmVhdHNPY2N1cGllZCA9IHR1cGxldC5nZXRCZWF0c09jY3VwaWVkKCk7XG5cbiAgICAgICAgdGhpcy5hcHBseVRpY2tNdWx0aXBsaWVyKGJlYXRzT2NjdXBpZWQsIG5vdGVDb3VudCk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMudHVwbGV0ID0gdHVwbGV0O1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqIG9wdGlvbmFsLCBpZiB0aWNrYWJsZSBoYXMgbW9kaWZpZXJzICoqL1xuICAgIGFkZFRvTW9kaWZpZXJDb250ZXh0OiBmdW5jdGlvbihtYykge1xuICAgICAgdGhpcy5tb2RpZmllckNvbnRleHQgPSBtYztcbiAgICAgIC8vIEFkZCBtb2RpZmllcnMgdG8gbW9kaWZpZXIgY29udGV4dCAoaWYgYW55KVxuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLyoqIG9wdGlvbmFsLCBpZiB0aWNrYWJsZSBoYXMgbW9kaWZpZXJzICoqL1xuICAgIGFkZE1vZGlmaWVyOiBmdW5jdGlvbihtb2QpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobW9kKTtcbiAgICAgIHRoaXMucHJlRm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0VGlja0NvbnRleHQ6IGZ1bmN0aW9uKHRjKSB7XG4gICAgICB0aGlzLnRpY2tDb250ZXh0ID0gdGM7XG4gICAgICB0aGlzLnByZUZvcm1hdHRlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucHJlRm9ybWF0dGVkKSByZXR1cm47XG5cbiAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgaWYgKHRoaXMubW9kaWZpZXJDb250ZXh0KSB7XG4gICAgICAgIHRoaXMubW9kaWZpZXJDb250ZXh0LnByZUZvcm1hdCgpO1xuICAgICAgICB0aGlzLndpZHRoICs9IHRoaXMubW9kaWZpZXJDb250ZXh0LmdldFdpZHRoKCk7XG4gICAgICB9XG4gICAgfSxcbiAgICBwb3N0Rm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBvc3RGb3JtYXR0ZWQpIHJldHVybjtcbiAgICAgIHRoaXMucG9zdEZvcm1hdHRlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldEludHJpbnNpY1RpY2tzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmludHJpbnNpY1RpY2tzO1xuICAgIH0sXG4gICAgc2V0SW50cmluc2ljVGlja3M6IGZ1bmN0aW9uKGludHJpbnNpY1RpY2tzKSB7XG4gICAgICB0aGlzLmludHJpbnNpY1RpY2tzID0gaW50cmluc2ljVGlja3M7XG4gICAgICB0aGlzLnRpY2tzID0gdGhpcy50aWNrTXVsdGlwbGllci5jbG9uZSgpLm11bHRpcGx5KHRoaXMuaW50cmluc2ljVGlja3MpO1xuICAgIH0sXG4gICAgZ2V0VGlja011bHRpcGxpZXI6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudGlja011bHRpcGxpZXI7XG4gICAgfSxcbiAgICBhcHBseVRpY2tNdWx0aXBsaWVyOiBmdW5jdGlvbihudW1lcmF0b3IsIGRlbm9taW5hdG9yKSB7XG4gICAgICB0aGlzLnRpY2tNdWx0aXBsaWVyLm11bHRpcGx5KG51bWVyYXRvciwgZGVub21pbmF0b3IpO1xuICAgICAgdGhpcy50aWNrcyA9IHRoaXMudGlja011bHRpcGxpZXIuY2xvbmUoKS5tdWx0aXBseSh0aGlzLmludHJpbnNpY1RpY2tzKTtcbiAgICB9LFxuICAgIHNldER1cmF0aW9uOiBmdW5jdGlvbihkdXJhdGlvbikge1xuICAgICAgdmFyIHRpY2tzID0gZHVyYXRpb24ubnVtZXJhdG9yICogKFZleC5GbG93LlJFU09MVVRJT04gLyBkdXJhdGlvbi5kZW5vbWluYXRvcik7XG4gICAgICB0aGlzLnRpY2tzID0gdGhpcy50aWNrTXVsdGlwbGllci5jbG9uZSgpLm11bHRpcGx5KHRpY2tzKTtcbiAgICAgIHRoaXMuaW50cmluc2ljVGlja3MgPSB0aGlzLnRpY2tzLnZhbHVlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUaWNrYWJsZTtcbn0oKSk7XG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIGFuIGFic3RyYWN0IGludGVyZmFjZSBmb3Igbm90ZXMgYW5kIGNob3JkcyB0aGF0XG4vLyBhcmUgcmVuZGVyZWQgb24gYSBzdGF2ZS4gTm90ZXMgaGF2ZSBzb21lIGNvbW1vbiBwcm9wZXJ0aWVzOiBBbGwgb2YgdGhlbVxuLy8gaGF2ZSBhIHZhbHVlIChlLmcuLCBwaXRjaCwgZnJldCwgZXRjLikgYW5kIGEgZHVyYXRpb24gKHF1YXJ0ZXIsIGhhbGYsIGV0Yy4pXG4vL1xuLy8gU29tZSBub3RlcyBoYXZlIHN0ZW1zLCBoZWFkcywgZG90cywgZXRjLiBNb3N0IG5vdGF0aW9uYWwgZWxlbWVudHMgdGhhdFxuLy8gc3Vycm91bmQgYSBub3RlIGFyZSBjYWxsZWQgKm1vZGlmaWVycyosIGFuZCBldmVyeSBub3RlIGhhcyBhbiBhc3NvY2lhdGVkXG4vLyBhcnJheSBvZiB0aGVtLiBBbGwgbm90ZXMgYWxzbyBoYXZlIGEgcmVuZGVyaW5nIGNvbnRleHQgYW5kIGJlbG9uZyB0byBhIHN0YXZlLlxuXG5WZXguRmxvdy5Ob3RlID0gKGZ1bmN0aW9uKCkge1xuICAvLyBUbyBjcmVhdGUgYSBuZXcgbm90ZSB5b3UgbmVlZCB0byBwcm92aWRlIGEgYG5vdGVfc3RydWN0YCwgd2hpY2ggY29uc2lzdHNcbiAgLy8gb2YgdGhlIGZvbGxvd2luZyBmaWVsZHM6XG4gIC8vXG4gIC8vIGB0eXBlYDogVGhlIG5vdGUgdHlwZSAoZS5nLiwgYHJgIGZvciByZXN0LCBgc2AgZm9yIHNsYXNoIG5vdGVzLCBldGMuKVxuICAvLyBgZG90c2A6IFRoZSBudW1iZXIgb2YgZG90cywgd2hpY2ggYWZmZWN0cyB0aGUgZHVyYXRpb24uXG4gIC8vIGBkdXJhdGlvbmA6IFRoZSB0aW1lIGxlbmd0aCAoZS5nLiwgYHFgIGZvciBxdWFydGVyLCBgaGAgZm9yIGhhbGYsIGA4YCBmb3IgZWlnaHRoIGV0Yy4pXG4gIC8vXG4gIC8vIFRoZSByYW5nZSBvZiB2YWx1ZXMgZm9yIHRoZXNlIHBhcmFtZXRlcnMgYXJlIGF2YWlsYWJsZSBpbiBgc3JjL3RhYmxlcy5qc2AuXG4gIGZ1bmN0aW9uIE5vdGUobm90ZV9zdHJ1Y3QpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChub3RlX3N0cnVjdCk7XG4gIH1cbiAgTm90ZS5DQVRFR09SWSA9IFwibm90ZVwiO1xuXG4gIC8vIERlYnVnIGhlbHBlci4gRGlzcGxheXMgdmFyaW91cyBub3RlIG1ldHJpY3MgZm9yIHRoZSBnaXZlblxuICAvLyBub3RlLlxuICBOb3RlLnBsb3RNZXRyaWNzID0gZnVuY3Rpb24oY3R4LCBub3RlLCB5UG9zKSB7XG4gICAgdmFyIG1ldHJpY3MgPSBub3RlLmdldE1ldHJpY3MoKTtcbiAgICB2YXIgdyA9IG1ldHJpY3Mud2lkdGg7XG4gICAgdmFyIHhTdGFydCA9IG5vdGUuZ2V0QWJzb2x1dGVYKCkgLSBtZXRyaWNzLm1vZExlZnRQeCAtIG1ldHJpY3MuZXh0cmFMZWZ0UHg7XG4gICAgdmFyIHhQcmUxID0gbm90ZS5nZXRBYnNvbHV0ZVgoKSAtIG1ldHJpY3MuZXh0cmFMZWZ0UHg7XG4gICAgdmFyIHhBYnMgPSBub3RlLmdldEFic29sdXRlWCgpO1xuICAgIHZhciB4UG9zdDEgPSBub3RlLmdldEFic29sdXRlWCgpICsgbWV0cmljcy5ub3RlV2lkdGg7XG4gICAgdmFyIHhQb3N0MiA9IG5vdGUuZ2V0QWJzb2x1dGVYKCkgKyBtZXRyaWNzLm5vdGVXaWR0aCArIG1ldHJpY3MuZXh0cmFSaWdodFB4O1xuICAgIHZhciB4RW5kID0gbm90ZS5nZXRBYnNvbHV0ZVgoKSArIG1ldHJpY3Mubm90ZVdpZHRoICsgbWV0cmljcy5leHRyYVJpZ2h0UHggKyBtZXRyaWNzLm1vZFJpZ2h0UHg7XG5cbiAgICB2YXIgeFdpZHRoID0geEVuZCAtIHhTdGFydDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5zZXRGb250KFwiQXJpYWxcIiwgOCwgXCJcIik7XG4gICAgY3R4LmZpbGxUZXh0KE1hdGgucm91bmQoeFdpZHRoKSArIFwicHhcIiwgeFN0YXJ0ICsgbm90ZS5nZXRYU2hpZnQoKSwgeVBvcyk7XG5cbiAgICB2YXIgeSA9ICh5UG9zICsgNyk7XG4gICAgZnVuY3Rpb24gc3Ryb2tlKHgxLCB4MiwgY29sb3IpIHtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5zZXRTdHJva2VTdHlsZShjb2xvcik7XG4gICAgICBjdHguc2V0RmlsbFN0eWxlKGNvbG9yKTtcbiAgICAgIGN0eC5zZXRMaW5lV2lkdGgoMyk7XG4gICAgICBjdHgubW92ZVRvKHgxICsgbm90ZS5nZXRYU2hpZnQoKSwgeSk7XG4gICAgICBjdHgubGluZVRvKHgyICsgbm90ZS5nZXRYU2hpZnQoKSwgeSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuXG4gICAgc3Ryb2tlKHhTdGFydCwgeFByZTEsIFwicmVkXCIpO1xuICAgIHN0cm9rZSh4UHJlMSwgeEFicywgXCIjOTk5XCIpO1xuICAgIHN0cm9rZSh4QWJzLCB4UG9zdDEsIFwiZ3JlZW5cIik7XG4gICAgc3Ryb2tlKHhQb3N0MSwgeFBvc3QyLCBcIiM5OTlcIik7XG4gICAgc3Ryb2tlKHhQb3N0MiwgeEVuZCwgXCJyZWRcIik7XG4gICAgc3Ryb2tlKHhTdGFydCAtIG5vdGUuZ2V0WFNoaWZ0KCksIHhTdGFydCwgXCIjREREXCIpOyAvLyBTaGlmdFxuICAgIFZleC5kcmF3RG90KGN0eCwgeEFicyArIG5vdGUuZ2V0WFNoaWZ0KCksIHksIFwiYmx1ZVwiKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9O1xuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIC8vXG4gIC8vIEV2ZXJ5IG5vdGUgaXMgYSB0aWNrYWJsZSwgaS5lLiwgaXQgY2FuIGJlIG11dGF0ZWQgYnkgdGhlIGBGb3JtYXR0ZXJgIGNsYXNzIGZvclxuICAvLyBwb3NpdGlvbmluZyBhbmQgbGF5b3V0LlxuICBWZXguSW5oZXJpdChOb3RlLCBWZXguRmxvdy5UaWNrYWJsZSwge1xuICAgIC8vIFNlZSBjb25zdHJ1Y3RvciBhYm92ZSBmb3IgaG93IHRvIGNyZWF0ZSBhIG5vdGUuXG4gICAgaW5pdDogZnVuY3Rpb24obm90ZV9zdHJ1Y3QpIHtcbiAgICAgIE5vdGUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcyk7XG5cbiAgICAgIGlmICghbm90ZV9zdHJ1Y3QpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgIFwiTm90ZSBtdXN0IGhhdmUgdmFsaWQgaW5pdGlhbGl6YXRpb24gZGF0YSB0byBpZGVudGlmeSBcIiArXG4gICAgICAgICAgICBcImR1cmF0aW9uIGFuZCB0eXBlLlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gUGFyc2UgYG5vdGVfc3RydWN0YCBhbmQgZ2V0IG5vdGUgcHJvcGVydGllcy5cbiAgICAgIHZhciBpbml0RGF0YSA9IFZleC5GbG93LnBhcnNlTm90ZURhdGEobm90ZV9zdHJ1Y3QpO1xuICAgICAgaWYgKCFpbml0RGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLFxuICAgICAgICAgICAgXCJJbnZhbGlkIG5vdGUgaW5pdGlhbGl6YXRpb24gb2JqZWN0OiBcIiArIEpTT04uc3RyaW5naWZ5KG5vdGVfc3RydWN0KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCBub3RlIHByb3BlcnRpZXMgZnJvbSBwYXJhbWV0ZXJzLlxuICAgICAgdGhpcy5kdXJhdGlvbiA9IGluaXREYXRhLmR1cmF0aW9uO1xuICAgICAgdGhpcy5kb3RzID0gaW5pdERhdGEuZG90cztcbiAgICAgIHRoaXMubm90ZVR5cGUgPSBpbml0RGF0YS50eXBlO1xuXG4gICAgICBpZiAobm90ZV9zdHJ1Y3QuZHVyYXRpb25fb3ZlcnJpZGUpIHtcbiAgICAgICAgLy8gQ3VzdG9tIGR1cmF0aW9uXG4gICAgICAgIHRoaXMuc2V0RHVyYXRpb24obm90ZV9zdHJ1Y3QuZHVyYXRpb25fb3ZlcnJpZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gRGVmYXVsdCBkdXJhdGlvblxuICAgICAgICB0aGlzLnNldEludHJpbnNpY1RpY2tzKGluaXREYXRhLnRpY2tzKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTtcblxuICAgICAgLy8gR2V0IHRoZSBnbHlwaCBjb2RlIGZvciB0aGlzIG5vdGUgZnJvbSB0aGUgZm9udC5cbiAgICAgIHRoaXMuZ2x5cGggPSBWZXguRmxvdy5kdXJhdGlvblRvR2x5cGgodGhpcy5kdXJhdGlvbiwgdGhpcy5ub3RlVHlwZSk7XG5cbiAgICAgIGlmICh0aGlzLnBvc2l0aW9ucyAmJlxuICAgICAgICAgICh0eXBlb2YodGhpcy5wb3NpdGlvbnMpICE9IFwib2JqZWN0XCIgfHwgIXRoaXMucG9zaXRpb25zLmxlbmd0aCkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXG4gICAgICAgICAgXCJCYWRBcmd1bWVudHNcIiwgXCJOb3RlIGtleXMgbXVzdCBiZSBhcnJheSB0eXBlLlwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gTm90ZSB0byBwbGF5IGZvciBhdWRpbyBwbGF5ZXJzLlxuICAgICAgdGhpcy5wbGF5Tm90ZSA9IG51bGw7XG5cbiAgICAgIC8vIFBvc2l0aW9uaW5nIGNvbnRleHRzIHVzZWQgYnkgdGhlIEZvcm1hdHRlci5cbiAgICAgIHRoaXMudGlja0NvbnRleHQgPSBudWxsOyAgICAvLyBUaGUgY3VycmVudCB0aWNrIGNvbnRleHQuXG4gICAgICB0aGlzLm1vZGlmaWVyQ29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLmlnbm9yZV90aWNrcyA9IGZhbHNlO1xuXG4gICAgICAvLyBQb3NpdGlvbmluZyB2YXJpYWJsZXNcbiAgICAgIHRoaXMud2lkdGggPSAwOyAgICAgICAgICAgICAvLyBXaWR0aCBpbiBwaXhlbHMgY2FsY3VsYXRlZCBhZnRlciBwcmVGb3JtYXRcbiAgICAgIHRoaXMuZXh0cmFMZWZ0UHggPSAwOyAgICAgICAvLyBFeHRyYSByb29tIG9uIGxlZnQgZm9yIG9mZnNldCBub3RlIGhlYWRcbiAgICAgIHRoaXMuZXh0cmFSaWdodFB4ID0gMDsgICAgICAvLyBFeHRyYSByb29tIG9uIHJpZ2h0IGZvciBvZmZzZXQgbm90ZSBoZWFkXG4gICAgICB0aGlzLnhfc2hpZnQgPSAwOyAgICAgICAgICAgLy8gWCBzaGlmdCBmcm9tIHRpY2sgY29udGV4dCBYXG4gICAgICB0aGlzLmxlZnRfbW9kUHggPSAwOyAgICAgICAgLy8gTWF4IHdpZHRoIG9mIGxlZnQgbW9kaWZpZXJzXG4gICAgICB0aGlzLnJpZ2h0X21vZFB4ID0gMDsgICAgICAgLy8gTWF4IHdpZHRoIG9mIHJpZ2h0IG1vZGlmaWVyc1xuICAgICAgdGhpcy52b2ljZSA9IG51bGw7ICAgICAgICAgIC8vIFRoZSB2b2ljZSB0aGF0IHRoaXMgbm90ZSBpcyBpblxuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSBmYWxzZTsgIC8vIElzIHRoaXMgbm90ZSBwcmVGb3JtYXR0ZWQ/XG4gICAgICB0aGlzLnlzID0gW107ICAgICAgICAgICAgICAgLy8gbGlzdCBvZiB5IGNvb3JkaW5hdGVzIGZvciBlYWNoIG5vdGVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB3ZSBuZWVkIHRvIGhvbGQgb24gdG8gdGhlc2UgZm9yIHRpZXMgYW5kIGJlYW1zLlxuXG4gICAgICBpZiAobm90ZV9zdHJ1Y3QuYWxpZ25fY2VudGVyKSB7XG4gICAgICAgIHRoaXMuc2V0Q2VudGVyQWxpZ25tZW50KG5vdGVfc3RydWN0LmFsaWduX2NlbnRlcik7XG4gICAgICB9XG5cbiAgICAgIC8vIFRoZSByZW5kZXIgc3VyZmFjZS5cbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLnN0YXZlID0gbnVsbDtcbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMgPSB7XG4gICAgICAgIGFubm90YXRpb25fc3BhY2luZzogNSxcbiAgICAgICAgc3RhdmVfcGFkZGluZzogMTJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIEdldCBhbmQgc2V0IHRoZSBwbGF5IG5vdGUsIHdoaWNoIGlzIGFyYml0cmFyeSBkYXRhIHRoYXQgY2FuIGJlIHVzZWQgYnkgYW5cbiAgICAvLyBhdWRpbyBwbGF5ZXIuXG4gICAgZ2V0UGxheU5vdGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5wbGF5Tm90ZTsgfSxcbiAgICBzZXRQbGF5Tm90ZTogZnVuY3Rpb24obm90ZSkgeyB0aGlzLnBsYXlOb3RlID0gbm90ZTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBEb24ndCBwbGF5IG5vdGVzIGJ5IGRlZmF1bHQsIGNhbGwgdGhlbSByZXN0cy4gVGhpcyBpcyBhbHNvIHVzZWQgYnkgdGhpbmdzIGxpa2VcbiAgICAvLyBiZWFtcyBhbmQgZG90cyBmb3IgcG9zaXRpb25pbmcuXG4gICAgaXNSZXN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9LFxuXG4gICAgLy8gVE9ETygweGZlKTogV2h5IGlzIHRoaXMgbWV0aG9kIGhlcmU/XG4gICAgYWRkU3Ryb2tlOiBmdW5jdGlvbihpbmRleCwgc3Ryb2tlKSB7XG4gICAgICBzdHJva2Uuc2V0Tm90ZSh0aGlzKTtcbiAgICAgIHN0cm9rZS5zZXRJbmRleChpbmRleCk7XG4gICAgICB0aGlzLm1vZGlmaWVycy5wdXNoKHN0cm9rZSk7XG4gICAgICB0aGlzLnNldFByZUZvcm1hdHRlZChmYWxzZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFuZCBzZXQgdGhlIHRhcmdldCBzdGF2ZS5cbiAgICBnZXRTdGF2ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN0YXZlOyB9LFxuICAgIHNldFN0YXZlOiBmdW5jdGlvbihzdGF2ZSkge1xuICAgICAgdGhpcy5zdGF2ZSA9IHN0YXZlO1xuICAgICAgdGhpcy5zZXRZcyhbc3RhdmUuZ2V0WUZvckxpbmUoMCldKTsgLy8gVXBkYXRlIFkgdmFsdWVzIGlmIHRoZSBzdGF2ZSBpcyBjaGFuZ2VkLlxuICAgICAgdGhpcy5jb250ZXh0ID0gdGhpcy5zdGF2ZS5jb250ZXh0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuXG4gICAgLy8gYE5vdGVgIGlzIG5vdCByZWFsbHkgYSBtb2RpZmllciwgYnV0IGlzIHVzZWQgaW5cbiAgICAvLyBhIGBNb2RpZmllckNvbnRleHRgLlxuICAgIGdldENhdGVnb3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuQ0FURUdPUlk7IH0sXG5cbiAgICAvLyBTZXQgdGhlIHJlbmRlcmluZyBjb250ZXh0IGZvciB0aGUgbm90ZS5cbiAgICBzZXRDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7IHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gR2V0IGFuZCBzZXQgc3BhY2luZyB0byB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgdGhlIG5vdGVzLlxuICAgIGdldEV4dHJhTGVmdFB4OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZXh0cmFMZWZ0UHg7IH0sXG4gICAgZ2V0RXh0cmFSaWdodFB4OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZXh0cmFSaWdodFB4OyB9LFxuICAgIHNldEV4dHJhTGVmdFB4OiBmdW5jdGlvbih4KSB7IHRoaXMuZXh0cmFMZWZ0UHggPSB4OyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRFeHRyYVJpZ2h0UHg6IGZ1bmN0aW9uKHgpIHsgdGhpcy5leHRyYVJpZ2h0UHggPSB4OyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIFJldHVybnMgdHJ1ZSBpZiB0aGlzIG5vdGUgaGFzIG5vIGR1cmF0aW9uIChlLmcuLCBiYXIgbm90ZXMsIHNwYWNlcnMsIGV0Yy4pXG4gICAgc2hvdWxkSWdub3JlVGlja3M6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pZ25vcmVfdGlja3M7IH0sXG5cbiAgICAvLyBHZXQgdGhlIHN0YXZlIGxpbmUgbnVtYmVyIGZvciB0aGUgbm90ZS5cbiAgICBnZXRMaW5lTnVtYmVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH0sXG5cbiAgICAvLyBHZXQgdGhlIHN0YXZlIGxpbmUgbnVtYmVyIGZvciByZXN0LlxuICAgIGdldExpbmVGb3JSZXN0OiBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH0sXG5cbiAgICAvLyBHZXQgdGhlIGdseXBoIGFzc29jaWF0ZWQgd2l0aCB0aGlzIG5vdGUuXG4gICAgZ2V0R2x5cGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5nbHlwaDsgfSxcblxuICAgIC8vIFNldCBhbmQgZ2V0IFkgcG9zaXRpb25zIGZvciB0aGlzIG5vdGUuIEVhY2ggWSB2YWx1ZSBpcyBhc3NvY2lhdGVkIHdpdGhcbiAgICAvLyBhbiBpbmRpdmlkdWFsIHBpdGNoL2tleSB3aXRoaW4gdGhlIG5vdGUvY2hvcmQuXG4gICAgc2V0WXM6IGZ1bmN0aW9uKHlzKSB7IHRoaXMueXMgPSB5czsgcmV0dXJuIHRoaXM7IH0sXG4gICAgZ2V0WXM6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMueXMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1lWYWx1ZXNcIixcbiAgICAgICAgICBcIk5vIFktdmFsdWVzIGNhbGN1bGF0ZWQgZm9yIHRoaXMgbm90ZS5cIik7XG4gICAgICByZXR1cm4gdGhpcy55cztcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBZIHBvc2l0aW9uIG9mIHRoZSBzcGFjZSBhYm92ZSB0aGUgc3RhdmUgb250byB3aGljaCB0ZXh0IGNhblxuICAgIC8vIGJlIHJlbmRlcmVkLlxuICAgIGdldFlGb3JUb3BUZXh0OiBmdW5jdGlvbih0ZXh0X2xpbmUpIHtcbiAgICAgIGlmICghdGhpcy5zdGF2ZSkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9TdGF2ZVwiLFxuICAgICAgICAgIFwiTm8gc3RhdmUgYXR0YWNoZWQgdG8gdGhpcyBub3RlLlwiKTtcbiAgICAgIHJldHVybiB0aGlzLnN0YXZlLmdldFlGb3JUb3BUZXh0KHRleHRfbGluZSk7XG4gICAgfSxcblxuICAgIC8vIEdldCBhIGBCb3VuZGluZ0JveGAgZm9yIHRoaXMgbm90ZS5cbiAgICBnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24oKSB7IHJldHVybiBudWxsOyB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgdm9pY2UgdGhhdCB0aGlzIG5vdGUgYmVsb25ncyBpbi5cbiAgICBnZXRWb2ljZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMudm9pY2UpIHRocm93IG5ldyBWZXguUkVSUihcIk5vVm9pY2VcIiwgXCJOb3RlIGhhcyBubyB2b2ljZS5cIik7XG4gICAgICByZXR1cm4gdGhpcy52b2ljZTtcbiAgICB9LFxuXG4gICAgLy8gQXR0YWNoIHRoaXMgbm90ZSB0byBgdm9pY2VgLlxuICAgIHNldFZvaWNlOiBmdW5jdGlvbih2b2ljZSkge1xuICAgICAgdGhpcy52b2ljZSA9IHZvaWNlO1xuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYW5kIHNldCB0aGUgYFRpY2tDb250ZXh0YCBmb3IgdGhpcyBub3RlLlxuICAgIGdldFRpY2tDb250ZXh0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudGlja0NvbnRleHQ7IH0sXG4gICAgc2V0VGlja0NvbnRleHQ6IGZ1bmN0aW9uKHRjKSB7XG4gICAgICB0aGlzLnRpY2tDb250ZXh0ID0gdGM7XG4gICAgICB0aGlzLnByZUZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEFjY2Vzc29ycyBmb3IgdGhlIG5vdGUgdHlwZS5cbiAgICBnZXREdXJhdGlvbjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmR1cmF0aW9uOyB9LFxuICAgIGlzRG90dGVkOiBmdW5jdGlvbigpIHsgcmV0dXJuICh0aGlzLmRvdHMgPiAwKTsgfSxcbiAgICBoYXNTdGVtOiBmdW5jdGlvbigpIHsgcmV0dXJuIGZhbHNlOyB9LFxuICAgIGdldERvdHM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kb3RzOyB9LFxuICAgIGdldE5vdGVUeXBlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubm90ZVR5cGU7IH0sXG4gICAgc2V0QmVhbTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9LCAvLyBpZ25vcmUgcGFyYW1ldGVyc1xuXG4gICAgLy8gQXR0YWNoIHRoaXMgbm90ZSB0byBhIG1vZGlmaWVyIGNvbnRleHQuXG4gICAgc2V0TW9kaWZpZXJDb250ZXh0OiBmdW5jdGlvbihtYykgeyB0aGlzLm1vZGlmaWVyQ29udGV4dCA9IG1jOyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIEF0dGFjaCBhIG1vZGlmaWVyIHRvIHRoaXMgbm90ZS5cbiAgICBhZGRNb2RpZmllcjogZnVuY3Rpb24obW9kaWZpZXIsIGluZGV4KSB7XG4gICAgICBtb2RpZmllci5zZXROb3RlKHRoaXMpO1xuICAgICAgbW9kaWZpZXIuc2V0SW5kZXgoaW5kZXggfHwgMCk7XG4gICAgICB0aGlzLm1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgIHRoaXMuc2V0UHJlRm9ybWF0dGVkKGZhbHNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGNvb3JkaW5hdGVzIGZvciB3aGVyZSBtb2RpZmllcnMgYmVnaW4uXG4gICAgZ2V0TW9kaWZpZXJTdGFydFhZOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5wcmVGb3JtYXR0ZWQpIHRocm93IG5ldyBWZXguUkVSUihcIlVuZm9ybWF0dGVkTm90ZVwiLFxuICAgICAgICAgIFwiQ2FuJ3QgY2FsbCBHZXRNb2RpZmllclN0YXJ0WFkgb24gYW4gdW5mb3JtYXR0ZWQgbm90ZVwiKTtcbiAgICAgIHJldHVybiB7eDogdGhpcy5nZXRBYnNvbHV0ZVgoKSwgeTogdGhpcy55c1swXX07XG4gICAgfSxcblxuICAgIC8vIEdldCBib3VuZHMgYW5kIG1ldHJpY3MgZm9yIHRoaXMgbm90ZS5cbiAgICAvL1xuICAgIC8vIFJldHVybnMgYSBzdHJ1Y3Qgd2l0aCBmaWVsZHM6XG4gICAgLy8gYHdpZHRoYDogVGhlIHRvdGFsIHdpZHRoIG9mIHRoZSBub3RlIChpbmNsdWRpbmcgbW9kaWZpZXJzLilcbiAgICAvLyBgbm90ZVdpZHRoYDogVGhlIHdpZHRoIG9mIHRoZSBub3RlIGhlYWQgb25seS5cbiAgICAvLyBgbGVmdF9zaGlmdGA6IFRoZSBob3Jpem9udGFsIGRpc3BsYWNlbWVudCBvZiB0aGUgbm90ZS5cbiAgICAvLyBgbW9kTGVmdFB4YDogU3RhcnQgYFhgIGZvciBsZWZ0IG1vZGlmaWVycy5cbiAgICAvLyBgbW9kUmlnaHRQeGA6IFN0YXJ0IGBYYCBmb3IgcmlnaHQgbW9kaWZpZXJzLlxuICAgIC8vIGBleHRyYUxlZnRQeGA6IEV4dHJhIHNwYWNlIG9uIGxlZnQgb2Ygbm90ZS5cbiAgICAvLyBgZXh0cmFSaWdodFB4YDogRXh0cmEgc3BhY2Ugb24gcmlnaHQgb2Ygbm90ZS5cbiAgICBnZXRNZXRyaWNzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5wcmVGb3JtYXR0ZWQpIHRocm93IG5ldyBWZXguUkVSUihcIlVuZm9ybWF0dGVkTm90ZVwiLFxuICAgICAgICAgIFwiQ2FuJ3QgY2FsbCBnZXRNZXRyaWNzIG9uIGFuIHVuZm9ybWF0dGVkIG5vdGUuXCIpO1xuICAgICAgdmFyIG1vZExlZnRQeCA9IDA7XG4gICAgICB2YXIgbW9kUmlnaHRQeCA9IDA7XG4gICAgICBpZiAodGhpcy5tb2RpZmllckNvbnRleHQgIT0gbnVsbCkge1xuICAgICAgICBtb2RMZWZ0UHggPSB0aGlzLm1vZGlmaWVyQ29udGV4dC5zdGF0ZS5sZWZ0X3NoaWZ0O1xuICAgICAgICBtb2RSaWdodFB4ID0gdGhpcy5tb2RpZmllckNvbnRleHQuc3RhdGUucmlnaHRfc2hpZnQ7XG4gICAgICB9XG5cbiAgICAgIHZhciB3aWR0aCA9IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgIHJldHVybiB7IHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgICAgIG5vdGVXaWR0aDogd2lkdGggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICBtb2RMZWZ0UHggLSBtb2RSaWdodFB4IC1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRyYUxlZnRQeCAtIHRoaXMuZXh0cmFSaWdodFB4LFxuICAgICAgICAgICAgICAgbGVmdF9zaGlmdDogdGhpcy54X3NoaWZ0LCAvLyBUT0RPKDB4ZmUpOiBNYWtlIHN0eWxlIGNvbnNpc3RlbnRcblxuXG4gICAgICAgICAgICAgICAvLyBNb2RpZmllcnMsIGFjY2lkZW50YWxzIGV0Yy5cbiAgICAgICAgICAgICAgIG1vZExlZnRQeDogbW9kTGVmdFB4LFxuICAgICAgICAgICAgICAgbW9kUmlnaHRQeDogbW9kUmlnaHRQeCxcblxuICAgICAgICAgICAgICAgLy8gRGlzcGxhY2VkIG5vdGUgaGVhZCBvbiBsZWZ0IG9yIHJpZ2h0LlxuICAgICAgICAgICAgICAgZXh0cmFMZWZ0UHg6IHRoaXMuZXh0cmFMZWZ0UHgsXG4gICAgICAgICAgICAgICBleHRyYVJpZ2h0UHg6IHRoaXMuZXh0cmFSaWdodFB4IH07XG4gICAgfSxcblxuICAgIC8vIEdldCBhbmQgc2V0IHdpZHRoIG9mIG5vdGUuIFVzZWQgYnkgdGhlIGZvcm1hdHRlciBmb3IgcG9zaXRpb25pbmcuXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7IHRoaXMud2lkdGggPSB3aWR0aDsgfSxcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMucHJlRm9ybWF0dGVkKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJVbmZvcm1hdHRlZE5vdGVcIixcbiAgICAgICAgICBcIkNhbid0IGNhbGwgR2V0V2lkdGggb24gYW4gdW5mb3JtYXR0ZWQgbm90ZS5cIik7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aCArXG4gICAgICAgICh0aGlzLm1vZGlmaWVyQ29udGV4dCA/ICB0aGlzLm1vZGlmaWVyQ29udGV4dC5nZXRXaWR0aCgpIDogMCk7XG4gICAgfSxcblxuICAgIC8vIERpc3BsYWNlIG5vdGUgYnkgYHhgIHBpeGVscy4gVXNlZCBieSB0aGUgZm9ybWF0dGVyLlxuICAgIHNldFhTaGlmdDogZnVuY3Rpb24oeCkgeyB0aGlzLnhfc2hpZnQgPSB4OyByZXR1cm4gdGhpczsgfSxcbiAgICBnZXRYU2hpZnQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy54X3NoaWZ0OyB9LFxuXG4gICAgLy8gR2V0IGBYYCBwb3NpdGlvbiBvZiB0aGlzIHRpY2sgY29udGV4dC5cbiAgICBnZXRYOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy50aWNrQ29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9UaWNrQ29udGV4dFwiLFxuICAgICAgICAgIFwiTm90ZSBuZWVkcyBhIFRpY2tDb250ZXh0IGFzc2lnbmVkIGZvciBhbiBYLVZhbHVlXCIpO1xuICAgICAgcmV0dXJuIHRoaXMudGlja0NvbnRleHQuZ2V0WCgpICsgdGhpcy54X3NoaWZ0O1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGFic29sdXRlIGBYYCBwb3NpdGlvbiBvZiB0aGlzIG5vdGUncyB0aWNrIGNvbnRleHQuIFRoaXNcbiAgICAvLyBleGNsdWRlcyB4X3NoaWZ0LCBzbyB5b3UnbGwgbmVlZCB0byBmYWN0b3IgaXQgaW4gaWYgeW91J3JlXG4gICAgLy8gbG9va2luZyBmb3IgdGhlIHBvc3QtZm9ybWF0dGVkIHgtcG9zaXRpb24uXG4gICAgZ2V0QWJzb2x1dGVYOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy50aWNrQ29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9UaWNrQ29udGV4dFwiLFxuICAgICAgICAgIFwiTm90ZSBuZWVkcyBhIFRpY2tDb250ZXh0IGFzc2lnbmVkIGZvciBhbiBYLVZhbHVlXCIpO1xuXG4gICAgICAvLyBQb3NpdGlvbiBub3RlIHRvIGxlZnQgZWRnZSBvZiB0aWNrIGNvbnRleHQuXG4gICAgICB2YXIgeCA9IHRoaXMudGlja0NvbnRleHQuZ2V0WCgpO1xuICAgICAgaWYgKHRoaXMuc3RhdmUpIHtcbiAgICAgICAgeCArPSB0aGlzLnN0YXZlLmdldE5vdGVTdGFydFgoKSArIHRoaXMucmVuZGVyX29wdGlvbnMuc3RhdmVfcGFkZGluZztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuaXNDZW50ZXJBbGlnbmVkKCkpe1xuICAgICAgICB4ICs9IHRoaXMuZ2V0Q2VudGVyWFNoaWZ0KCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB4O1xuICAgIH0sXG5cbiAgICBzZXRQcmVGb3JtYXR0ZWQ6IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB0aGlzLnByZUZvcm1hdHRlZCA9IHZhbHVlO1xuXG4gICAgICAvLyBNYWludGFpbiB0aGUgd2lkdGggb2YgbGVmdCBhbmQgcmlnaHQgbW9kaWZpZXJzIGluIHBpeGVscy5cbiAgICAgIGlmICh0aGlzLnByZUZvcm1hdHRlZCkge1xuICAgICAgICB2YXIgZXh0cmEgPSB0aGlzLnRpY2tDb250ZXh0LmdldEV4dHJhUHgoKTtcbiAgICAgICAgdGhpcy5sZWZ0X21vZFB4ID0gTWF0aC5tYXgodGhpcy5sZWZ0X21vZFB4LCBleHRyYS5sZWZ0KTtcbiAgICAgICAgdGhpcy5yaWdodF9tb2RQeCA9IE1hdGgubWF4KHRoaXMucmlnaHRfbW9kUHgsIGV4dHJhLnJpZ2h0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBOb3RlO1xufSgpKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgYE5vdGVIZWFkc2AuIGBOb3RlSGVhZHNgIGFyZSB0eXBpY2FsbHkgbm90IG1hbmlwdWxhdGVkXG4vLyBkaXJlY3RseSwgYnV0IHVzZWQgaW50ZXJuYWxseSBpbiBgU3RhdmVOb3RlYC5cbi8vXG4vLyBTZWUgYHRlc3RzL25vdGVoZWFkX3Rlc3RzLmpzYCBmb3IgdXNhZ2UgZXhhbXBsZXMuXG5WZXguRmxvdy5Ob3RlSGVhZCA9IChmdW5jdGlvbigpIHtcbiAgdmFyIE5vdGVIZWFkID0gZnVuY3Rpb24oaGVhZF9vcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQoaGVhZF9vcHRpb25zKTtcbiAgfTtcblxuICAvLyBUbyBlbmFibGUgbG9nZ2luZyBmb3IgdGhpcyBjbGFzcy4gU2V0IGBWZXguRmxvdy5Ob3RlSGVhZC5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoTm90ZUhlYWQuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuTm90ZUhlYWRcIiwgYXJndW1lbnRzKTsgfVxuXG5cbiAgLy8gRHJhdyBzbGFzaG5vdGUgaGVhZCBtYW51YWxseS4gTm8gZ2x5cGggZXhpc3RzIGZvciB0aGlzLlxuICAvL1xuICAvLyBQYXJhbWV0ZXJzOlxuICAvLyAqIGBjdHhgOiB0aGUgQ2FudmFzIGNvbnRleHRcbiAgLy8gKiBgZHVyYXRpb25gOiB0aGUgZHVyYXRpb24gb2YgdGhlIG5vdGUuIGV4OiBcIjRcIlxuICAvLyAqIGB4YDogdGhlIHggY29vcmRpbmF0ZSB0byBkcmF3IGF0XG4gIC8vICogYHlgOiB0aGUgeSBjb29yZGluYXRlIHRvIGRyYXcgYXRcbiAgLy8gKiBgc3RlbV9kaXJlY3Rpb25gOiB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzdGVtXG4gIGZ1bmN0aW9uIGRyYXdTbGFzaE5vdGVIZWFkKGN0eCwgZHVyYXRpb24sIHgsIHksIHN0ZW1fZGlyZWN0aW9uKSB7XG4gICAgdmFyIHdpZHRoID0gMTUgKyAoVmV4LkZsb3cuU1RFTV9XSURUSCAvIDIpO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNldExpbmVXaWR0aChWZXguRmxvdy5TVEVNX1dJRFRIKTtcblxuICAgIHZhciBmaWxsID0gZmFsc2U7XG5cbiAgICBpZiAoVmV4LkZsb3cuZHVyYXRpb25Ub051bWJlcihkdXJhdGlvbikgPiAyKSB7XG4gICAgICBmaWxsID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoIWZpbGwpIHggLT0gKFZleC5GbG93LlNURU1fV0lEVEggLyAyKSAqIHN0ZW1fZGlyZWN0aW9uO1xuXG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGN0eC5tb3ZlVG8oeCwgeSArIDExKTtcbiAgICBjdHgubGluZVRvKHgsIHkgKyAxKTtcbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSAtIDEwKTtcbiAgICBjdHgubGluZVRvKHggKyB3aWR0aCwgeSk7XG4gICAgY3R4LmxpbmVUbyh4LCB5ICsgMTEpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcblxuICAgIGlmIChmaWxsKSB7XG4gICAgICAgY3R4LmZpbGwoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBpZiAoVmV4LkZsb3cuZHVyYXRpb25Ub0ZyYWN0aW9uKGR1cmF0aW9uKS5lcXVhbHMoMC41KSkge1xuICAgICAgdmFyIGJyZXZlX2xpbmVzID0gWy0zLCAtMSwgd2lkdGggKyAxLCB3aWR0aCArIDNdO1xuICAgICAgZm9yKHZhciBpPTA7IGk8YnJldmVfbGluZXMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKHggKyBicmV2ZV9saW5lc1tpXSwgeSAtIDEwKTtcbiAgICAgICAgICBjdHgubGluZVRvKHggKyBicmV2ZV9saW5lc1tpXSwgeSArIDExKTtcbiAgICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgfVxuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIFZleC5Jbmhlcml0KE5vdGVIZWFkLCBWZXguRmxvdy5Ob3RlLCB7XG4gICAgaW5pdDogZnVuY3Rpb24oaGVhZF9vcHRpb25zKSB7XG4gICAgICBOb3RlSGVhZC5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBoZWFkX29wdGlvbnMpO1xuICAgICAgdGhpcy5pbmRleCA9IGhlYWRfb3B0aW9ucy5pbmRleDtcbiAgICAgIHRoaXMueCA9IGhlYWRfb3B0aW9ucy54IHx8IDA7XG4gICAgICB0aGlzLnkgPSBoZWFkX29wdGlvbnMueSB8fCAwO1xuICAgICAgdGhpcy5ub3RlX3R5cGUgPSBoZWFkX29wdGlvbnMubm90ZV90eXBlO1xuICAgICAgdGhpcy5kdXJhdGlvbiA9IGhlYWRfb3B0aW9ucy5kdXJhdGlvbjtcbiAgICAgIHRoaXMuZGlzcGxhY2VkID0gaGVhZF9vcHRpb25zLmRpc3BsYWNlZCB8fCBmYWxzZTtcbiAgICAgIHRoaXMuc3RlbV9kaXJlY3Rpb24gPSBoZWFkX29wdGlvbnMuc3RlbV9kaXJlY3Rpb24gfHwgVmV4LkZsb3cuU3RhdmVOb3RlLlNURU1fVVA7XG4gICAgICB0aGlzLmxpbmUgPSBoZWFkX29wdGlvbnMubGluZTtcblxuICAgICAgLy8gR2V0IGdseXBoIGNvZGUgYmFzZWQgb24gZHVyYXRpb24gYW5kIG5vdGUgdHlwZS4gVGhpcyBjb3VsZCBiZVxuICAgICAgLy8gcmVndWxhciBub3RlcywgcmVzdHMsIG9yIG90aGVyIGN1c3RvbSBjb2Rlcy5cbiAgICAgIHRoaXMuZ2x5cGggPSBWZXguRmxvdy5kdXJhdGlvblRvR2x5cGgodGhpcy5kdXJhdGlvbiwgdGhpcy5ub3RlX3R5cGUpO1xuICAgICAgaWYgKCF0aGlzLmdseXBoKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiQmFkQXJndW1lbnRzXCIsXG4gICAgICAgICAgICBcIk5vIGdseXBoIGZvdW5kIGZvciBkdXJhdGlvbiAnXCIgKyB0aGlzLmR1cmF0aW9uICtcbiAgICAgICAgICAgIFwiJyBhbmQgdHlwZSAnXCIgKyB0aGlzLm5vdGVfdHlwZSArIFwiJ1wiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5nbHlwaF9jb2RlID0gdGhpcy5nbHlwaC5jb2RlX2hlYWQ7XG4gICAgICB0aGlzLnhfc2hpZnQgPSBoZWFkX29wdGlvbnMueF9zaGlmdDtcbiAgICAgIGlmIChoZWFkX29wdGlvbnMuY3VzdG9tX2dseXBoX2NvZGUpIHtcbiAgICAgICAgdGhpcy5jdXN0b21fZ2x5cGggPSB0cnVlO1xuICAgICAgICB0aGlzLmdseXBoX2NvZGUgPSBoZWFkX29wdGlvbnMuY3VzdG9tX2dseXBoX2NvZGU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLnN0eWxlID0gaGVhZF9vcHRpb25zLnN0eWxlO1xuICAgICAgdGhpcy5zbGFzaGVkID0gaGVhZF9vcHRpb25zLnNsYXNoZWQ7XG5cbiAgICAgIFZleC5NZXJnZSh0aGlzLnJlbmRlcl9vcHRpb25zLCB7XG4gICAgICAgIGdseXBoX2ZvbnRfc2NhbGU6IDM1LCAvLyBmb250IHNpemUgZm9yIG5vdGUgaGVhZHNcbiAgICAgICAgc3Ryb2tlX3B4OiAzICAgICAgICAgLy8gbnVtYmVyIG9mIHN0cm9rZSBweCB0byB0aGUgbGVmdCBhbmQgcmlnaHQgb2YgaGVhZFxuICAgICAgfSk7XG5cbiAgICAgIGlmIChoZWFkX29wdGlvbnMuZ2x5cGhfZm9udF9zY2FsZSkge1xuICAgICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLmdseXBoX2ZvbnRfc2NhbGUgPSBoZWFkX29wdGlvbnMuZ2x5cGhfZm9udF9zY2FsZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLmdseXBoLmhlYWRfd2lkdGgpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGBNb2RpZmllckNvbnRleHRgIGNhdGVnb3J5XG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJub3RlaGVhZFwiOyB9LFxuXG4gICAgLy8gU2V0IHRoZSBDYXZuYXMgY29udGV4dCBmb3IgZHJhd2luZ1xuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHsgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgcmV0dXJuIHRoaXM7fSxcblxuICAgIC8vIEdldCB0aGUgd2lkdGggb2YgdGhlIG5vdGVoZWFkXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy53aWR0aDsgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgbm90ZWhlYWQgaXMgZGlzcGxhY2VkXG4gICAgaXNEaXNwbGFjZWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5kaXNwbGFjZWQgPT09IHRydWU7IH0sXG5cbiAgICAvLyBHZXQvc2V0IHRoZSBub3RlaGVhZCdzIHN0eWxlXG4gICAgLy9cbiAgICAvLyBgc3R5bGVgIGlzIGFuIGBvYmplY3RgIHdpdGggdGhlIGZvbGxvd2luZyBwcm9wZXJ0aWVzOiBgc2hhZG93Q29sb3JgLFxuICAgIC8vIGBzaGFkb3dCbHVyYCwgYGZpbGxTdHlsZWAsIGBzdHJva2VTdHlsZWBcbiAgICBnZXRTdHlsZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN0eWxlOyB9LFxuICAgIHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkgeyB0aGlzLnN0eWxlID0gc3R5bGU7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gR2V0IHRoZSBnbHlwaCBkYXRhXG4gICAgZ2V0R2x5cGg6IGZ1bmN0aW9uKCl7IHJldHVybiB0aGlzLmdseXBoOyB9LFxuXG4gICAgLy8gU2V0IHRoZSBYIGNvb3JkaW5hdGVcbiAgICBzZXRYOiBmdW5jdGlvbih4KXsgdGhpcy54ID0geDsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBnZXQvc2V0IHRoZSBZIGNvb3JkaW5hdGVcbiAgICBnZXRZOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueTsgfSxcbiAgICBzZXRZOiBmdW5jdGlvbih5KSB7IHRoaXMueSA9IHk7ICByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIEdldC9zZXQgdGhlIHN0YXZlIGxpbmUgdGhlIG5vdGVoZWFkIGlzIHBsYWNlZCBvblxuICAgIGdldExpbmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5saW5lOyB9LFxuICAgIHNldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHsgdGhpcy5saW5lID0gbGluZTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBHZXQgdGhlIGNhbnZhcyBgeGAgY29vcmRpbmF0ZSBwb3NpdGlvbiBvZiB0aGUgbm90ZWhlYWQuXG4gICAgZ2V0QWJzb2x1dGVYOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBnZXRBYnNvbHV0ZVggPSBOb3RlSGVhZC5zdXBlcmNsYXNzLmdldEFic29sdXRlWDtcblxuICAgICAgLy8gSWYgdGhlIG5vdGUgaGFzIG5vdCBiZWVuIHByZWZvcm1hdHRlZCwgdGhlbiBnZXQgdGhlIHN0YXRpYyB4IHZhbHVlXG4gICAgICAvLyBPdGhlcndpc2UsIGl0J3MgYmVlbiBmb3JtYXR0ZWQgYW5kIHdlIHNob3VsZCB1c2UgaXQncyB4IHZhbHVlIHJlbGF0aXZlXG4gICAgICAvLyB0byBpdHMgdGljayBjb250ZXh0XG4gICAgICB2YXIgeCA9ICF0aGlzLnByZUZvcm1hdHRlZCA/IHRoaXMueCA6IGdldEFic29sdXRlWC5jYWxsKHRoaXMpO1xuXG4gICAgICByZXR1cm4geCArICh0aGlzLmRpc3BsYWNlZCA/IHRoaXMud2lkdGggKiB0aGlzLnN0ZW1fZGlyZWN0aW9uIDogMCk7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgYEJvdW5kaW5nQm94YCBmb3IgdGhlIGBOb3RlSGVhZGBcbiAgICBnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMucHJlRm9ybWF0dGVkKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJVbmZvcm1hdHRlZE5vdGVcIixcbiAgICAgICAgICBcIkNhbid0IGNhbGwgZ2V0Qm91bmRpbmdCb3ggb24gYW4gdW5mb3JtYXR0ZWQgbm90ZS5cIik7XG5cbiAgICAgIHZhciBzcGFjaW5nID0gdGhpcy5zdGF2ZS5nZXRTcGFjaW5nQmV0d2VlbkxpbmVzKCk7XG4gICAgICB2YXIgaGFsZl9zcGFjaW5nID0gc3BhY2luZy8yO1xuICAgICAgdmFyIG1pbl95ID0gdGhpcy55IC0gaGFsZl9zcGFjaW5nO1xuXG4gICAgICByZXR1cm4gbmV3IFZleC5GbG93LkJvdW5kaW5nQm94KHRoaXMuZ2V0QWJzb2x1dGVYKCksIG1pbl95LCB0aGlzLndpZHRoLCBzcGFjaW5nKTtcbiAgICB9LFxuXG4gICAgLy8gQXBwbHkgY3VycmVudCBzdHlsZSB0byBDYW52YXMgYGNvbnRleHRgXG4gICAgYXBwbHlTdHlsZTogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpO1xuICAgICAgaWYgKHN0eWxlLnNoYWRvd0NvbG9yKSBjb250ZXh0LnNldFNoYWRvd0NvbG9yKHN0eWxlLnNoYWRvd0NvbG9yKTtcbiAgICAgIGlmIChzdHlsZS5zaGFkb3dCbHVyKSBjb250ZXh0LnNldFNoYWRvd0JsdXIoc3R5bGUuc2hhZG93Qmx1cik7XG4gICAgICBpZiAoc3R5bGUuZmlsbFN0eWxlKSBjb250ZXh0LnNldEZpbGxTdHlsZShzdHlsZS5maWxsU3R5bGUpO1xuICAgICAgaWYgKHN0eWxlLnN0cm9rZVN0eWxlKSBjb250ZXh0LnNldFN0cm9rZVN0eWxlKHN0eWxlLnN0cm9rZVN0eWxlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgbm90ZWhlYWQgdG8gYSBwcm92aWRlZCBgc3RhdmVgXG4gICAgc2V0U3RhdmU6IGZ1bmN0aW9uKHN0YXZlKXtcbiAgICAgIHZhciBsaW5lID0gdGhpcy5nZXRMaW5lKCk7XG5cbiAgICAgIHRoaXMuc3RhdmUgPSBzdGF2ZTtcbiAgICAgIHRoaXMuc2V0WShzdGF2ZS5nZXRZRm9yTm90ZShsaW5lKSk7XG4gICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLnN0YXZlLmNvbnRleHQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUHJlLXJlbmRlciBmb3JtYXR0aW5nXG4gICAgcHJlRm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnByZUZvcm1hdHRlZCkgcmV0dXJuIHRoaXM7XG5cbiAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2V0R2x5cGgoKTtcbiAgICAgIHZhciB3aWR0aCA9IGdseXBoLmhlYWRfd2lkdGggKyB0aGlzLmV4dHJhTGVmdFB4ICsgdGhpcy5leHRyYVJpZ2h0UHg7XG5cbiAgICAgIHRoaXMuc2V0V2lkdGgod2lkdGgpO1xuICAgICAgdGhpcy5zZXRQcmVGb3JtYXR0ZWQodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRHJhdyB0aGUgbm90ZWhlYWRcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgd2l0aG91dCBhIGNhbnZhcyBjb250ZXh0LlwiKTtcblxuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciBoZWFkX3ggPSB0aGlzLmdldEFic29sdXRlWCgpO1xuICAgICAgdmFyIHkgPSB0aGlzLnk7XG5cbiAgICAgIEwoXCJEcmF3aW5nIG5vdGUgaGVhZCAnXCIsIHRoaXMubm90ZV90eXBlLCB0aGlzLmR1cmF0aW9uLCBcIicgYXRcIiwgaGVhZF94LCB5KTtcblxuICAgICAgLy8gQmVnaW4gYW5kIGVuZCBwb3NpdGlvbnMgZm9yIGhlYWQuXG4gICAgICB2YXIgc3RlbV9kaXJlY3Rpb24gPSB0aGlzLnN0ZW1fZGlyZWN0aW9uO1xuICAgICAgdmFyIGdseXBoX2ZvbnRfc2NhbGUgPSB0aGlzLnJlbmRlcl9vcHRpb25zLmdseXBoX2ZvbnRfc2NhbGU7XG5cbiAgICAgIHZhciBsaW5lID0gdGhpcy5saW5lO1xuXG4gICAgICAvLyBJZiBub3RlIGFib3ZlL2JlbG93IHRoZSBzdGFmZiwgZHJhdyB0aGUgc21hbGwgc3RhZmZcbiAgICAgIGlmIChsaW5lIDw9IDAgfHwgbGluZSA+PSA2KSB7XG4gICAgICAgIHZhciBsaW5lX3kgPSB5O1xuICAgICAgICB2YXIgZmxvb3IgPSBNYXRoLmZsb29yKGxpbmUpO1xuICAgICAgICBpZiAobGluZSA8IDAgJiYgZmxvb3IgLSBsaW5lID09IC0wLjUpXG4gICAgICAgICAgbGluZV95IC09IDU7XG4gICAgICAgIGVsc2UgaWYgKGxpbmUgPiA2ICYmICBmbG9vciAtIGxpbmUgPT0gLTAuNSlcbiAgICAgICAgICBsaW5lX3kgKz0gNTtcbiAgICAgICAgaWYgKHRoaXMubm90ZV90eXBlICE9ICdyJykge1xuICAgICAgICAgIGN0eC5maWxsUmVjdChcbiAgICAgICAgICAgIGhlYWRfeCAtIHRoaXMucmVuZGVyX29wdGlvbnMuc3Ryb2tlX3B4LCBsaW5lX3ksXG4gICAgICAgICAgICAodGhpcy5nZXRHbHlwaCgpLmhlYWRfd2lkdGgpICtcbiAgICAgICAgICAgICh0aGlzLnJlbmRlcl9vcHRpb25zLnN0cm9rZV9weCAqIDIpLCAxKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5ub3RlX3R5cGUgPT0gXCJzXCIpIHtcbiAgICAgICAgZHJhd1NsYXNoTm90ZUhlYWQoY3R4LCB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIGhlYWRfeCwgeSwgc3RlbV9kaXJlY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHRoaXMuc3R5bGUpIHtcbiAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgIHRoaXMuYXBwbHlTdHlsZShjdHgpO1xuICAgICAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKGN0eCwgaGVhZF94LCB5LCBnbHlwaF9mb250X3NjYWxlLCB0aGlzLmdseXBoX2NvZGUpO1xuICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgoY3R4LCBoZWFkX3gsIHksIGdseXBoX2ZvbnRfc2NhbGUsIHRoaXMuZ2x5cGhfY29kZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBOb3RlSGVhZDtcbn0oKSk7XG5cbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgdGhlIGBTdGVtYCBvYmplY3QuIEdlbmVyYWxseSB0aGlzIG9iamVjdCBpcyBoYW5kbGVkXG4vLyBieSBpdHMgcGFyZW50IGBTdGVtbWFibGVOb3RlYC5cbi8vXG5WZXguRmxvdy5TdGVtID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgU3RlbSA9IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChvcHRpb25zKTtcbiAgfTtcblxuICAvLyBUbyBlbmFibGUgbG9nZ2luZyBmb3IgdGhpcyBjbGFzcy4gU2V0IGBWZXguRmxvdy5TdGVtLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChTdGVtLkRFQlVHKSBWZXguTChcIlZleC5GbG93LlN0ZW1cIiwgYXJndW1lbnRzKTsgfVxuXG4gIC8vIFN0ZW0gZGlyZWN0aW9uc1xuICBTdGVtLlVQID0gMTtcbiAgU3RlbS5ET1dOID0gLTE7XG5cbiAgLy8gVGhlbWVcbiAgU3RlbS5XSURUSCA9IFZleC5GbG93LlNURU1fV0lEVEg7XG4gIFN0ZW0uSEVJR0hUID0gVmV4LkZsb3cuU1RFTV9IRUlHSFQ7XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgU3RlbS5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24ob3B0aW9ucykge1xuICAgICAgLy8gRGVmYXVsdCBub3RlaGVhZCB4IGJvdW5kc1xuICAgICAgdGhpcy54X2JlZ2luID0gb3B0aW9ucy54X2JlZ2luIHx8IDA7XG4gICAgICB0aGlzLnhfZW5kID0gb3B0aW9ucy54X2VuZCB8fCAwO1xuXG4gICAgICAvLyBZIGJvdW5kcyBmb3IgdG9wL2JvdHRvbSBtb3N0IG5vdGVoZWFkXG4gICAgICB0aGlzLnlfdG9wID0gb3B0aW9ucy55X3RvcCB8fCAwO1xuICAgICAgdGhpcy55X2JvdHRvbSA9IG9wdGlvbnMueV9ib3R0b20gfHwgMDtcblxuICAgICAgLy8gU3RlbSBiYXNlIGV4dGVuc2lvblxuICAgICAgdGhpcy55X2V4dGVuZCA9IG9wdGlvbnMueV9leHRlbmQgfHwgMDtcbiAgICAgIC8vIFN0ZW0gdG9wIGV4dGVuc2lvblxuICAgICAgdGhpcy5zdGVtX2V4dGVuc2lvbiA9IG9wdGlvbnMuc3RlbV9leHRlbnNpb24gfHwgMDtcblxuICAgICAgLy8gRGlyZWN0aW9uIG9mIHRoZSBzdGVtXG4gICAgICB0aGlzLnN0ZW1fZGlyZWN0aW9uID0gb3B0aW9ucy5zdGVtX2RpcmVjdGlvbiB8fCAwO1xuXG4gICAgICAvLyBGbGFnIHRvIG92ZXJyaWRlIGFsbCBkcmF3IGNhbGxzXG4gICAgICB0aGlzLmhpZGUgPSBmYWxzZTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IHRoZSB4IGJvdW5kcyBmb3IgdGhlIGRlZmF1bHQgbm90ZWhlYWRcbiAgICBzZXROb3RlSGVhZFhCb3VuZHM6IGZ1bmN0aW9uKHhfYmVnaW4sIHhfZW5kKSB7XG4gICAgICB0aGlzLnhfYmVnaW4gPSB4X2JlZ2luO1xuICAgICAgdGhpcy54X2VuZCA9IHhfZW5kO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFNldCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzdGVtIGluIHJlbGF0aW9uIHRvIHRoZSBub3RlaGVhZHNcbiAgICBzZXREaXJlY3Rpb246IGZ1bmN0aW9uKGRpcmVjdGlvbil7IHRoaXMuc3RlbV9kaXJlY3Rpb24gPSBkaXJlY3Rpb247IH0sXG5cbiAgICAvLyBTZXQgdGhlIGV4dGVuc2lvbiBmb3IgdGhlIHN0ZW0sIGdlbmVyYWxseSBmb3IgZmxhZ3Mgb3IgYmVhbXNcbiAgICBzZXRFeHRlbnNpb246IGZ1bmN0aW9uKGV4dCkgeyB0aGlzLnN0ZW1fZXh0ZW5zaW9uID0gZXh0OyB9LFxuXG4gICAgLy8gVGhlIHRoZSB5IGJvdW5kcyBmb3IgdGhlIHRvcCBhbmQgYm90dG9tIG5vdGVoZWFkc1xuICAgIHNldFlCb3VuZHM6IGZ1bmN0aW9uKHlfdG9wLCB5X2JvdHRvbSkge1xuICAgICAgdGhpcy55X3RvcCA9IHlfdG9wO1xuICAgICAgdGhpcy55X2JvdHRvbSA9IHlfYm90dG9tO1xuICAgIH0sXG5cbiAgICAvLyBUaGUgY2F0ZWdvcnkgb2YgdGhlIG9iamVjdFxuICAgIGdldENhdGVnb3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIFwic3RlbVwiOyB9LFxuXG4gICAgLy8gU2V0IHRoZSBjYW52YXMgY29udGV4dCB0byByZW5kZXIgb25cbiAgICBzZXRDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7IHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IHJldHVybiB0aGlzO30sXG5cbiAgICAvLyBHZXRzIHRoZSBlbnRpcmUgaGVpZ2h0IGZvciB0aGUgc3RlbVxuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKCh0aGlzLnlfYm90dG9tIC0gdGhpcy55X3RvcCkgKiB0aGlzLnN0ZW1fZGlyZWN0aW9uKSArXG4gICAgICAgICAgICAgKChTdGVtLkhFSUdIVCArIHRoaXMuc3RlbV9leHRlbnNpb24pICogdGhpcy5zdGVtX2RpcmVjdGlvbik7XG4gICAgfSxcblxuICAgIGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbigpIHtcbiAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIk5vdEltcGxlbWVudGVkXCIsIFwiZ2V0Qm91bmRpbmdCb3goKSBub3QgaW1wbGVtZW50ZWQuXCIpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHkgY29vcmRpbmF0ZXMgZm9yIHRoZSB2ZXJ5IGJhc2Ugb2YgdGhlIHN0ZW0gdG8gdGhlIHRvcCBvZlxuICAgIC8vIHRoZSBleHRlbnNpb25cbiAgICBnZXRFeHRlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB5cyA9IFt0aGlzLnlfdG9wLCB0aGlzLnlfYm90dG9tXTtcblxuICAgICAgdmFyIHRvcF9waXhlbCA9IHRoaXMueV90b3A7XG4gICAgICB2YXIgYmFzZV9waXhlbCA9IHRoaXMueV9ib3R0b207XG4gICAgICB2YXIgc3RlbV9oZWlnaHQgPSBTdGVtLkhFSUdIVCArIHRoaXMuc3RlbV9leHRlbnNpb247XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgeXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHN0ZW1fdG9wID0geXNbaV0gKyAoc3RlbV9oZWlnaHQgKiAtdGhpcy5zdGVtX2RpcmVjdGlvbik7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RlbV9kaXJlY3Rpb24gPT0gU3RlbS5ET1dOKSB7XG4gICAgICAgICAgdG9wX3BpeGVsID0gTWF0aC5tYXgodG9wX3BpeGVsLCBzdGVtX3RvcCk7XG4gICAgICAgICAgYmFzZV9waXhlbCA9IE1hdGgubWluKGJhc2VfcGl4ZWwsIHlzW2ldKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0b3BfcGl4ZWwgPSBNYXRoLm1pbih0b3BfcGl4ZWwsIHN0ZW1fdG9wKTtcbiAgICAgICAgICBiYXNlX3BpeGVsID0gTWF0aC5tYXgoYmFzZV9waXhlbCwgeXNbaV0pO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB7IHRvcFk6IHRvcF9waXhlbCwgYmFzZVk6IGJhc2VfcGl4ZWwgfTtcbiAgICB9LFxuXG4gICAgLy8gc2V0IHRoZSBkcmF3IHN0eWxlIG9mIGEgc3RlbTpcbiAgICBzZXRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHsgdGhpcy5zdHlsZSA9IHN0eWxlOyByZXR1cm4gdGhpczsgfSxcbiAgICBnZXRTdHlsZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN0eWxlOyB9LFxuXG4gICAgLy8gQXBwbHkgY3VycmVudCBzdHlsZSB0byBDYW52YXMgYGNvbnRleHRgXG4gICAgYXBwbHlTdHlsZTogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdmFyIHN0eWxlID0gdGhpcy5nZXRTdHlsZSgpO1xuICAgICAgaWYoc3R5bGUpIHtcbiAgICAgICAgaWYgKHN0eWxlLnNoYWRvd0NvbG9yKSBjb250ZXh0LnNldFNoYWRvd0NvbG9yKHN0eWxlLnNoYWRvd0NvbG9yKTtcbiAgICAgICAgaWYgKHN0eWxlLnNoYWRvd0JsdXIpIGNvbnRleHQuc2V0U2hhZG93Qmx1cihzdHlsZS5zaGFkb3dCbHVyKTtcbiAgICAgICAgaWYgKHN0eWxlLnN0cm9rZVN0eWxlKSBjb250ZXh0LnNldFN0cm9rZVN0eWxlKHN0eWxlLnN0cm9rZVN0eWxlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW5kZXIgdGhlIHN0ZW0gb250byB0aGUgY2FudmFzXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHdpdGhvdXQgYSBjYW52YXMgY29udGV4dC5cIik7XG5cbiAgICAgIGlmICh0aGlzLmhpZGUpIHJldHVybjtcblxuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciBzdGVtX3gsIHN0ZW1feTtcbiAgICAgIHZhciBzdGVtX2RpcmVjdGlvbiA9IHRoaXMuc3RlbV9kaXJlY3Rpb247XG5cbiAgICAgIGlmIChzdGVtX2RpcmVjdGlvbiA9PSBTdGVtLkRPV04pIHtcbiAgICAgICAgLy8gRG93biBzdGVtcyBhcmUgcmVuZGVyZWQgdG8gdGhlIGxlZnQgb2YgdGhlIGhlYWQuXG4gICAgICAgIHN0ZW1feCA9IHRoaXMueF9iZWdpbiArIChTdGVtLldJRFRIIC8gMik7XG4gICAgICAgIHN0ZW1feSA9IHRoaXMueV90b3AgKyAyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVXAgc3RlbXMgYXJlIHJlbmRlcmVkIHRvIHRoZSByaWdodCBvZiB0aGUgaGVhZC5cbiAgICAgICAgc3RlbV94ID0gdGhpcy54X2VuZCArIChTdGVtLldJRFRIIC8gMik7XG4gICAgICAgIHN0ZW1feSA9IHRoaXMueV9ib3R0b20gLSAyO1xuICAgICAgfVxuXG4gICAgICBzdGVtX3kgKz0gdGhpcy55X2V4dGVuZCAqIHN0ZW1fZGlyZWN0aW9uO1xuXG4gICAgICBMKFwiUmVuZGVyaW5nIHN0ZW0gLSBcIiwgXCJUb3AgWTogXCIsIHRoaXMueV90b3AsIFwiQm90dG9tIFk6IFwiLCB0aGlzLnlfYm90dG9tKTtcblxuICAgICAgLy8gRHJhdyB0aGUgc3RlbVxuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuYXBwbHlTdHlsZShjdHgpO1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnNldExpbmVXaWR0aChTdGVtLldJRFRIKTtcbiAgICAgIGN0eC5tb3ZlVG8oc3RlbV94LCBzdGVtX3kpO1xuICAgICAgY3R4LmxpbmVUbyhzdGVtX3gsIHN0ZW1feSAtIHRoaXMuZ2V0SGVpZ2h0KCkpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFN0ZW07XG59KCkpO1xuXG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIGBTdGVtbWFibGVOb3RlYCBpcyBhbiBhYnN0cmFjdCBpbnRlcmZhY2UgZm9yIG5vdGVzIHdpdGggb3B0aW9uYWwgc3RlbXMuXG4vLyBFeGFtcGxlcyBvZiBzdGVtbWFibGUgbm90ZXMgYXJlIGBTdGF2ZU5vdGVgIGFuZCBgVGFiTm90ZWBcblZleC5GbG93LlN0ZW1tYWJsZU5vdGUgPSAoZnVuY3Rpb24oKXtcbiAgdmFyIFN0ZW1tYWJsZU5vdGUgPSBmdW5jdGlvbihub3RlX3N0cnVjdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG5vdGVfc3RydWN0KTtcbiAgfTtcblxuICAvLyBUbyBlbmFibGUgbG9nZ2luZyBmb3IgdGhpcyBjbGFzcy4gU2V0IGBWZXguRmxvdy5TdGVtbWFibGVOb3RlLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChTdGVtbWFibGVOb3RlLkRFQlVHKSBWZXguTChcIlZleC5GbG93LlN0ZW1tYWJsZU5vdGVcIiwgYXJndW1lbnRzKTsgfVxuXG4gIHZhciBTdGVtID0gVmV4LkZsb3cuU3RlbTtcblxuICBWZXguSW5oZXJpdChTdGVtbWFibGVOb3RlLCBWZXguRmxvdy5Ob3RlLCB7XG4gICAgaW5pdDogZnVuY3Rpb24obm90ZV9zdHJ1Y3Qpe1xuICAgICAgU3RlbW1hYmxlTm90ZS5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBub3RlX3N0cnVjdCk7XG5cbiAgICAgIHRoaXMuc3RlbSA9IG51bGw7XG4gICAgICB0aGlzLnN0ZW1fZXh0ZW5zaW9uX292ZXJyaWRlID0gbnVsbDtcbiAgICAgIHRoaXMuYmVhbSA9IG51bGw7XG5cbiAgICB9LFxuXG4gICAgLy8gR2V0IGFuZCBzZXQgdGhlIG5vdGUncyBgU3RlbWBcbiAgICBnZXRTdGVtOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zdGVtOyB9LFxuICAgIHNldFN0ZW06IGZ1bmN0aW9uKHN0ZW0pIHsgdGhpcy5zdGVtID0gc3RlbTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBCdWlsZHMgYW5kIHNldHMgYSBuZXcgc3RlbVxuICAgIGJ1aWxkU3RlbTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RlbSA9IG5ldyBTdGVtKCk7XG4gICAgICB0aGlzLnNldFN0ZW0oc3RlbSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBmdWxsIGxlbmd0aCBvZiBzdGVtXG4gICAgZ2V0U3RlbUxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU3RlbS5IRUlHSFQgKyB0aGlzLmdldFN0ZW1FeHRlbnNpb24oKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgYmVhbXMgZm9yIHRoaXMgZHVyYXRpb25cbiAgICBnZXRCZWFtQ291bnQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZ2x5cGggPSB0aGlzLmdldEdseXBoKCk7XG5cbiAgICAgIGlmIChnbHlwaCkge1xuICAgICAgICByZXR1cm4gZ2x5cGguYmVhbV9jb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIG1pbmltdW0gbGVuZ3RoIG9mIHN0ZW1cbiAgICBnZXRTdGVtTWludW11bUxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZnJhYyA9IFZleC5GbG93LmR1cmF0aW9uVG9GcmFjdGlvbih0aGlzLmR1cmF0aW9uKTtcbiAgICAgIHZhciBsZW5ndGggPSAoZnJhYy52YWx1ZSgpIDw9IDEpID8gMCA6IDIwO1xuICAgICAgLy8gaWYgbm90ZSBpcyBmbGFnZ2VkLCBjYW5ub3Qgc2hvcnRlbiBiZWFtXG4gICAgICBzd2l0Y2ggKHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICAgaWYgKHRoaXMuYmVhbSA9PSBudWxsKSBsZW5ndGggPSAzNTtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgIGNhc2UgXCIxNlwiOlxuICAgICAgICAgaWYgKHRoaXMuYmVhbSA9PSBudWxsKVxuICAgICAgICAgICBsZW5ndGggPSAzNTtcbiAgICAgICAgIGVsc2VcbiAgICAgICAgICAgbGVuZ3RoID0gMjU7XG4gICAgICAgICBicmVhaztcbiAgICAgICBjYXNlIFwiMzJcIjpcbiAgICAgICAgIGlmICh0aGlzLmJlYW0gPT0gbnVsbClcbiAgICAgICAgICAgbGVuZ3RoID0gNDU7XG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIGxlbmd0aCA9IDM1O1xuICAgICAgICAgYnJlYWs7XG4gICAgICAgY2FzZSBcIjY0XCI6XG4gICAgICAgICBpZiAodGhpcy5iZWFtID09IG51bGwpXG4gICAgICAgICAgIGxlbmd0aCA9IDUwO1xuICAgICAgICAgZWxzZVxuICAgICAgICAgICBsZW5ndGggPSA0MDtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgIGNhc2UgXCIxMjhcIjpcbiAgICAgICAgIGlmICh0aGlzLmJlYW0gPT0gbnVsbClcbiAgICAgICAgICAgbGVuZ3RoID0gNTU7XG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIGxlbmd0aCA9IDQ1O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gR2V0L3NldCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzdGVtXG4gICAgZ2V0U3RlbURpcmVjdGlvbjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN0ZW1fZGlyZWN0aW9uOyB9LFxuICAgIHNldFN0ZW1EaXJlY3Rpb246IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgICAgaWYgKCFkaXJlY3Rpb24pIGRpcmVjdGlvbiA9IFN0ZW0uVVA7XG4gICAgICBpZiAoZGlyZWN0aW9uICE9IFN0ZW0uVVAgJiZcbiAgICAgICAgICBkaXJlY3Rpb24gIT0gU3RlbS5ET1dOKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50XCIsIFwiSW52YWxpZCBzdGVtIGRpcmVjdGlvbjogXCIgK1xuICAgICAgICAgICAgZGlyZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGVtX2RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgIGlmICh0aGlzLnN0ZW0pIHtcbiAgICAgICAgdGhpcy5zdGVtLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLnN0ZW0uc2V0RXh0ZW5zaW9uKHRoaXMuZ2V0U3RlbUV4dGVuc2lvbigpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5iZWFtID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLnByZUZvcm1hdHRlZCkge1xuICAgICAgICB0aGlzLnByZUZvcm1hdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHN0ZW1cbiAgICBnZXRTdGVtWDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeF9iZWdpbiA9IHRoaXMuZ2V0QWJzb2x1dGVYKCkgKyB0aGlzLnhfc2hpZnQ7XG4gICAgICB2YXIgeF9lbmQgPSB0aGlzLmdldEFic29sdXRlWCgpICsgdGhpcy54X3NoaWZ0ICsgdGhpcy5nbHlwaC5oZWFkX3dpZHRoO1xuXG4gICAgICB2YXIgc3RlbV94ID0gdGhpcy5zdGVtX2RpcmVjdGlvbiA9PSBTdGVtLkRPV04gP1xuICAgICAgICB4X2JlZ2luIDogeF9lbmQ7XG5cbiAgICAgIHN0ZW1feCAtPSAoKFN0ZW0uV0lEVEggLyAyKSAqIHRoaXMuc3RlbV9kaXJlY3Rpb24pO1xuXG4gICAgICByZXR1cm4gc3RlbV94O1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGB4YCBjb29yZGluYXRlIGZvciB0aGUgY2VudGVyIG9mIHRoZSBnbHlwaC5cbiAgICAvLyBVc2VkIGZvciBgVGFiTm90ZWAgc3RlbXMgYW5kIHN0ZW1sZXRzIG92ZXIgcmVzdHNcbiAgICBnZXRDZW50ZXJHbHlwaFg6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBYnNvbHV0ZVgoKSArIHRoaXMueF9zaGlmdCArICh0aGlzLmdseXBoLmhlYWRfd2lkdGggLyAyKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBzdGVtIGV4dGVuc2lvbiBmb3IgdGhlIGN1cnJlbnQgZHVyYXRpb25cbiAgICBnZXRTdGVtRXh0ZW5zaW9uOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaCgpO1xuXG4gICAgICBpZiAodGhpcy5zdGVtX2V4dGVuc2lvbl9vdmVycmlkZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZW1fZXh0ZW5zaW9uX292ZXJyaWRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2x5cGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RlbURpcmVjdGlvbigpID09PSAxID8gZ2x5cGguc3RlbV91cF9leHRlbnNpb24gOlxuICAgICAgICAgIGdseXBoLnN0ZW1fZG93bl9leHRlbnNpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIHN0ZW0gbGVuZ3RoIHRvIGEgc3BlY2lmaWMuIFdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgbGVuZ3RoLlxuICAgIHNldFN0ZW1MZW5ndGg6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgdGhpcy5zdGVtX2V4dGVuc2lvbl9vdmVycmlkZSA9IChoZWlnaHQgLSBTdGVtLkhFSUdIVCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSB0b3AgYW5kIGJvdHRvbSBgeWAgdmFsdWVzIG9mIHRoZSBzdGVtLlxuICAgIGdldFN0ZW1FeHRlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy55cyB8fCB0aGlzLnlzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9ZVmFsdWVzXCIsXG4gICAgICAgICAgXCJDYW4ndCBnZXQgdG9wIHN0ZW0gWSB3aGVuIG5vdGUgaGFzIG5vIFkgdmFsdWVzLlwiKTtcblxuICAgICAgdmFyIHRvcF9waXhlbCA9IHRoaXMueXNbMF07XG4gICAgICB2YXIgYmFzZV9waXhlbCA9IHRoaXMueXNbMF07XG4gICAgICB2YXIgc3RlbV9oZWlnaHQgPSBTdGVtLkhFSUdIVCArIHRoaXMuZ2V0U3RlbUV4dGVuc2lvbigpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMueXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHN0ZW1fdG9wID0gdGhpcy55c1tpXSArIChzdGVtX2hlaWdodCAqIC10aGlzLnN0ZW1fZGlyZWN0aW9uKTtcblxuICAgICAgICBpZiAodGhpcy5zdGVtX2RpcmVjdGlvbiA9PSBTdGVtLkRPV04pIHtcbiAgICAgICAgICB0b3BfcGl4ZWwgPSBNYXRoLm1heCh0b3BfcGl4ZWwsIHN0ZW1fdG9wKTtcbiAgICAgICAgICBiYXNlX3BpeGVsID0gTWF0aC5taW4oYmFzZV9waXhlbCwgdGhpcy55c1tpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9wX3BpeGVsID0gTWF0aC5taW4odG9wX3BpeGVsLCBzdGVtX3RvcCk7XG4gICAgICAgICAgYmFzZV9waXhlbCA9IE1hdGgubWF4KGJhc2VfcGl4ZWwsIHRoaXMueXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5ub3RlVHlwZSA9PSBcInNcIiB8fCB0aGlzLm5vdGVUeXBlID09ICd4Jykge1xuICAgICAgICAgIHRvcF9waXhlbCAtPSB0aGlzLnN0ZW1fZGlyZWN0aW9uICogNztcbiAgICAgICAgICBiYXNlX3BpeGVsIC09IHRoaXMuc3RlbV9kaXJlY3Rpb24gKiA3O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEwoXCJTdGVtIGV4dGVudHM6IFwiLCB0b3BfcGl4ZWwsIGJhc2VfcGl4ZWwpO1xuICAgICAgcmV0dXJuIHsgdG9wWTogdG9wX3BpeGVsLCBiYXNlWTogYmFzZV9waXhlbCB9O1xuICAgIH0sXG5cbiAgICAvLyBTZXRzIHRoZSBjdXJyZW50IG5vdGUncyBiZWFtXG4gICAgc2V0QmVhbTogZnVuY3Rpb24oYmVhbSkgeyB0aGlzLmJlYW0gPSBiZWFtOyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIEdldCB0aGUgYHlgIHZhbHVlIGZvciB0aGUgdG9wL2JvdHRvbSBtb2RpZmllcnMgYXQgYSBzcGVjaWZpYyBgdGV4dF9saW5lYFxuICAgIGdldFlGb3JUb3BUZXh0OiBmdW5jdGlvbih0ZXh0X2xpbmUpIHtcbiAgICAgIHZhciBleHRlbnRzID0gdGhpcy5nZXRTdGVtRXh0ZW50cygpO1xuICAgICAgaWYgKHRoaXMuaGFzU3RlbSgpKSB7XG4gICAgICAgIHJldHVybiBWZXguTWluKHRoaXMuc3RhdmUuZ2V0WUZvclRvcFRleHQodGV4dF9saW5lKSxcbiAgICAgICAgICAgIGV4dGVudHMudG9wWSAtICh0aGlzLnJlbmRlcl9vcHRpb25zLmFubm90YXRpb25fc3BhY2luZyAqICh0ZXh0X2xpbmUgKyAxKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdmUuZ2V0WUZvclRvcFRleHQodGV4dF9saW5lKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0WUZvckJvdHRvbVRleHQ6IGZ1bmN0aW9uKHRleHRfbGluZSkge1xuICAgICAgdmFyIGV4dGVudHMgPSB0aGlzLmdldFN0ZW1FeHRlbnRzKCk7XG4gICAgICBpZiAodGhpcy5oYXNTdGVtKCkpIHtcbiAgICAgICAgcmV0dXJuIFZleC5NYXgodGhpcy5zdGF2ZS5nZXRZRm9yVG9wVGV4dCh0ZXh0X2xpbmUpLFxuICAgICAgICAgIGV4dGVudHMuYmFzZVkgKyAodGhpcy5yZW5kZXJfb3B0aW9ucy5hbm5vdGF0aW9uX3NwYWNpbmcgKiAodGV4dF9saW5lKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdmUuZ2V0WUZvckJvdHRvbVRleHQodGV4dF9saW5lKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFzRmxhZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gVmV4LkZsb3cuZHVyYXRpb25Ub0dseXBoKHRoaXMuZHVyYXRpb24pLmZsYWc7XG4gICAgfSxcblxuICAgIC8vIFBvc3QgZm9ybWF0IHRoZSBub3RlXG4gICAgcG9zdEZvcm1hdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5iZWFtKSB7XG4gICAgICAgIHRoaXMuYmVhbS5wb3N0Rm9ybWF0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBvc3RGb3JtYXR0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbmRlciB0aGUgc3RlbSBvbnRvIHRoZSBjYW52YXNcbiAgICBkcmF3U3RlbTogZnVuY3Rpb24oc3RlbV9zdHJ1Y3Qpe1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ2FudmFzQ29udGV4dFwiLFxuICAgICAgICAgIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgY2FudmFzIGNvbnRleHQuXCIpO1xuXG4gICAgICB0aGlzLnNldFN0ZW0obmV3IFN0ZW0oc3RlbV9zdHJ1Y3QpKTtcbiAgICAgIHRoaXMuc3RlbS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCkuZHJhdygpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFN0ZW1tYWJsZU5vdGU7XG59KCkpO1xuXG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIG5vdGVzIGZvciBzdGFuZGFyZCBub3RhdGlvbi4gVGhpcyBjb25zaXN0cyBvZiBvbmUgb3Jcbi8vIG1vcmUgYE5vdGVIZWFkc2AsIGFuIG9wdGlvbmFsIHN0ZW0sIGFuZCBhbiBvcHRpb25hbCBmbGFnLlxuLy9cbi8vICpUaHJvdWdob3V0IHRoZXNlIGNvbW1lbnRzLCBhIFwibm90ZVwiIHJlZmVycyB0byB0aGUgZW50aXJlIGBTdGF2ZU5vdGVgLFxuLy8gYW5kIGEgXCJrZXlcIiByZWZlcnMgdG8gYSBzcGVjaWZpYyBwaXRjaC9ub3RlaGVhZCB3aXRoaW4gYSBub3RlLipcbi8vXG4vLyBTZWUgYHRlc3RzL3N0YXZlbm90ZV90ZXN0cy5qc2AgZm9yIHVzYWdlIGV4YW1wbGVzLlxuVmV4LkZsb3cuU3RhdmVOb3RlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgU3RhdmVOb3RlID0gZnVuY3Rpb24obm90ZV9zdHJ1Y3QpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChub3RlX3N0cnVjdCk7XG4gIH07XG4gIFN0YXZlTm90ZS5DQVRFR09SWSA9IFwic3RhdmVub3Rlc1wiO1xuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93LlN0YXZlTm90ZS5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoU3RhdmVOb3RlLkRFQlVHKSBWZXguTChcIlZleC5GbG93LlN0YXZlTm90ZVwiLCBhcmd1bWVudHMpOyB9XG5cbiAgdmFyIFN0ZW0gPSBWZXguRmxvdy5TdGVtO1xuICB2YXIgTm90ZUhlYWQgPSBWZXguRmxvdy5Ob3RlSGVhZDtcblxuICAvLyBTdGVtIGRpcmVjdGlvbnNcbiAgU3RhdmVOb3RlLlNURU1fVVAgPSBTdGVtLlVQO1xuICBTdGF2ZU5vdGUuU1RFTV9ET1dOID0gU3RlbS5ET1dOO1xuXG4gIC8vIEhlbHBlciBtZXRob2RzIGZvciByZXN0IHBvc2l0aW9uaW5nIGluIE1vZGlmaWVyQ29udGV4dC5cbiAgdmFyIHNoaWZ0UmVzdFZlcnRpY2FsID0gZnVuY3Rpb24ocmVzdCwgbm90ZSwgZGlyKSB7XG4gICAgdmFyIGRlbHRhID0gKG5vdGUuaXNyZXN0ID8gMC4wIDogMS4wKSAqIGRpcjtcblxuICAgIHJlc3QubGluZSArPSBkZWx0YTtcbiAgICByZXN0Lm1heF9saW5lICs9IGRlbHRhO1xuICAgIHJlc3QubWluX2xpbmUgKz0gZGVsdGE7XG4gICAgcmVzdC5ub3RlLnNldEtleUxpbmUoMCwgcmVzdC5ub3RlLmdldEtleUxpbmUoMCkgKyAoZGVsdGEpKTtcbiAgfTtcblxuICAvLyBDYWxsZWQgZnJvbSBmb3JtYXROb3RlcyA6OiBjZW50ZXIgYSByZXN0IGJldHdlZW4gdHdvIG5vdGVzXG4gIHZhciBjZW50ZXJSZXN0ID0gZnVuY3Rpb24ocmVzdCwgbm90ZVUsIG5vdGVMKSB7XG4gICAgdmFyIGRlbHRhID0gcmVzdC5saW5lIC0gVmV4Lk1pZExpbmUobm90ZVUubWluX2xpbmUsIG5vdGVMLm1heF9saW5lKTtcbiAgICByZXN0Lm5vdGUuc2V0S2V5TGluZSgwLCByZXN0Lm5vdGUuZ2V0S2V5TGluZSgwKSAtIGRlbHRhKTtcbiAgICByZXN0LmxpbmUgLT0gZGVsdGE7XG4gICAgcmVzdC5tYXhfbGluZSAtPSBkZWx0YTtcbiAgICByZXN0Lm1pbl9saW5lIC09IGRlbHRhO1xuICB9O1xuXG4gIC8vICMjIFN0YXRpYyBNZXRob2RzXG4gIC8vXG4gIC8vIEZvcm1hdCBub3RlcyBpbnNpZGUgYSBNb2RpZmllckNvbnRleHQuXG4gIFN0YXZlTm90ZS5mb3JtYXQgPSBmdW5jdGlvbihub3Rlcywgc3RhdGUpIHtcbiAgICBpZiAoIW5vdGVzIHx8IG5vdGVzLmxlbmd0aCA8IDIpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChub3Rlc1swXS5nZXRTdGF2ZSgpICE9IG51bGwpIHJldHVybiBTdGF2ZU5vdGUuZm9ybWF0QnlZKG5vdGVzLCBzdGF0ZSk7XG5cbiAgICB2YXIgbm90ZXNfbGlzdD0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcHMgPSBub3Rlc1tpXS5nZXRLZXlQcm9wcygpO1xuICAgICAgdmFyIGxpbmUgPSBwcm9wc1swXS5saW5lO1xuICAgICAgdmFyIG1pbkwgPSBwcm9wc1twcm9wcy5sZW5ndGggLTFdLmxpbmU7XG4gICAgICB2YXIgc3RlbV9kaXIgPSBub3Rlc1tpXS5nZXRTdGVtRGlyZWN0aW9uKCk7XG4gICAgICB2YXIgc3RlbV9tYXggPSBub3Rlc1tpXS5nZXRTdGVtTGVuZ3RoKCkgLyAxMDtcbiAgICAgIHZhciBzdGVtX21pbiA9IG5vdGVzW2ldLmdldFN0ZW1NaW51bXVtTGVuZ3RoKCkgLyAxMDtcblxuICAgICAgdmFyIG1heEw7XG4gICAgICBpZiAobm90ZXNbaV0uaXNSZXN0KCkpIHtcbiAgICAgICAgbWF4TCA9IGxpbmUgKyBub3Rlc1tpXS5nbHlwaC5saW5lX2Fib3ZlO1xuICAgICAgICBtaW5MID0gbGluZSAtIG5vdGVzW2ldLmdseXBoLmxpbmVfYmVsb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhMID0gc3RlbV9kaXIgPT0gMSA/IHByb3BzW3Byb3BzLmxlbmd0aCAtMV0ubGluZSArIHN0ZW1fbWF4XG4gICAgICAgICAgICAgOiBwcm9wc1twcm9wcy5sZW5ndGggLTFdLmxpbmU7XG4gICAgICAgIG1pbkwgPSBzdGVtX2RpciA9PSAxID8gcHJvcHNbMF0ubGluZVxuICAgICAgICAgICAgIDogcHJvcHNbMF0ubGluZSAtIHN0ZW1fbWF4O1xuICAgICAgfVxuICAgICAgbm90ZXNfbGlzdC5wdXNoKFxuICAgICAgICB7bGluZTogcHJvcHNbMF0ubGluZSwgICAgICAgICAvLyBub3RlL3Jlc3QgYmFzZSBsaW5lXG4gICAgICAgICBtYXhfbGluZTogbWF4TCwgICAgICAgICAgICAgIC8vIG5vdGUvcmVzdCB1cHBlciBib3VuZHMgbGluZVxuICAgICAgICAgbWluX2xpbmU6IG1pbkwsICAgICAgICAgICAgICAvLyBub3RlL3Jlc3QgbG93ZXIgYm91bmRzIGxpbmVcbiAgICAgICAgIGlzcmVzdDogbm90ZXNbaV0uaXNSZXN0KCksXG4gICAgICAgICBzdGVtX2Rpcjogc3RlbV9kaXIsXG4gICAgICAgICBzdGVtX21heDogc3RlbV9tYXgsICAgICAgICAgIC8vIE1heGltdW0gKGRlZmF1bHQpIG5vdGUgc3RlbSBsZW5ndGg7XG4gICAgICAgICBzdGVtX21pbjogc3RlbV9taW4sICAgICAgICAgIC8vIG1pbmltdW0gbm90ZSBzdGVtIGxlbmd0aFxuICAgICAgICAgdm9pY2Vfc2hpZnQ6IG5vdGVzW2ldLmdldFZvaWNlU2hpZnRXaWR0aCgpLFxuICAgICAgICAgaXNfZGlzcGxhY2VkOiBub3Rlc1tpXS5pc0Rpc3BsYWNlZCgpLCAgIC8vIG5vdGUgbWFudWFsbHkgZGlzcGxhY2VkXG4gICAgICAgICBub3RlOiBub3Rlc1tpXX0pO1xuICAgIH1cblxuICAgIHZhciB2b2ljZXMgPSBub3Rlc19saXN0Lmxlbmd0aDtcblxuICAgIHZhciBub3RlVSA9IG5vdGVzX2xpc3RbMF07XG4gICAgdmFyIG5vdGVNID0gdm9pY2VzID4gMiA/IG5vdGVzX2xpc3RbMV0gOiBudWxsO1xuICAgIHZhciBub3RlTCA9IHZvaWNlcyA+IDIgPyBub3Rlc19saXN0WzJdIDogbm90ZXNfbGlzdFsxXTtcblxuICAgIC8vIGZvciB0d28gdm9pY2UgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgZW5zdXJlIHVwcGVyIHZvaWNlIGlzIHN0ZW1zIHVwXG4gICAgLy8gZm9yIHRocmVlIHZvaWNlcywgdGhlIHZvaWNlcyBtdXN0IGJlIGluIG9yZGVyICh1cHBlciwgbWlkZGxlLCBsb3dlcilcbiAgICBpZiAodm9pY2VzID09IDIgJiYgbm90ZVUuc3RlbV9kaXIgPT0gLTEgJiYgbm90ZUwuc3RlbV9kaXIgPT0gMSkge1xuICAgICAgbm90ZVUgPSBub3Rlc19saXN0WzFdO1xuICAgICAgbm90ZUwgPSBub3Rlc19saXN0WzBdO1xuICAgIH1cblxuICAgIHZhciB2b2ljZV94X3NoaWZ0ID0gTWF0aC5tYXgobm90ZVUudm9pY2Vfc2hpZnQsIG5vdGVMLnZvaWNlX3NoaWZ0KTtcbiAgICB2YXIgeF9zaGlmdCA9IDA7XG4gICAgdmFyIHN0ZW1fZGVsdGE7XG5cbiAgICAvLyBUZXN0IGZvciB0d28gdm9pY2Ugbm90ZSBpbnRlcnNlY3Rpb25cbiAgICBpZiAodm9pY2VzID09IDIpIHtcbiAgICAgIHZhciBsaW5lX3NwYWNpbmcgPSBub3RlVS5zdGVtX2RpciA9PSBub3RlTC5zdGVtX2RpciA/IDAuMCA6IDAuNTtcbiAgICAgIC8vIGlmIHRvcCB2b2ljZSBpcyBhIG1pZGRsZSB2b2ljZSwgY2hlY2sgc3RlbSBpbnRlcnNlY3Rpb24gd2l0aCBsb3dlciB2b2ljZVxuICAgICAgaWYgKG5vdGVVLnN0ZW1fZGlyID09IG5vdGVMLnN0ZW1fZGlyICYmXG4gICAgICAgICAgbm90ZVUubWluX2xpbmUgPD0gbm90ZUwubWF4X2xpbmUpIHtcbiAgICAgICAgaWYgKCFub3RlVS5pc3Jlc3QpIHtcbiAgICAgICAgICBzdGVtX2RlbHRhID0gTWF0aC5hYnMobm90ZVUubGluZSAtIChub3RlTC5tYXhfbGluZSArIDAuNSkpO1xuICAgICAgICAgIHN0ZW1fZGVsdGEgPSBNYXRoLm1heChzdGVtX2RlbHRhLCBub3RlVS5zdGVtX21pbik7XG4gICAgICAgICAgbm90ZVUubWluX2xpbmUgPSBub3RlVS5saW5lIC0gc3RlbV9kZWx0YTtcbiAgICAgICAgICBub3RlVS5ub3RlLnNldFN0ZW1MZW5ndGgoc3RlbV9kZWx0YSAqIDEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vdGVVLm1pbl9saW5lIDw9IG5vdGVMLm1heF9saW5lICsgbGluZV9zcGFjaW5nKSB7XG4gICAgICAgIGlmIChub3RlVS5pc3Jlc3QpIHtcbiAgICAgICAgICAvLyBzaGlmdCByZXN0IHVwXG4gICAgICAgICAgc2hpZnRSZXN0VmVydGljYWwobm90ZVUsIG5vdGVMLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChub3RlTC5pc3Jlc3QpIHtcbiAgICAgICAgICAvLyBzaGlmdCByZXN0IGRvd25cbiAgICAgICAgICBzaGlmdFJlc3RWZXJ0aWNhbChub3RlTCwgbm90ZVUsIC0xKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4X3NoaWZ0ID0gdm9pY2VfeF9zaGlmdDtcbiAgICAgICAgICBpZiAobm90ZVUuc3RlbV9kaXIgPT0gbm90ZUwuc3RlbV9kaXIpXG4gICAgICAgICAgICAvLyB1cHBlciB2b2ljZSBpcyBtaWRkbGUgdm9pY2UsIHNvIHNoaWZ0IGl0IHJpZ2h0XG4gICAgICAgICAgICBub3RlVS5ub3RlLnNldFhTaGlmdCh4X3NoaWZ0ICsgMyk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgLy8gc2hpZnQgbG93ZXIgdm9pY2UgcmlnaHRcbiAgICAgICAgICAgIG5vdGVMLm5vdGUuc2V0WFNoaWZ0KHhfc2hpZnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGZvcm1hdCBjb21wbGV0ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgbWlkZGxlIHZvaWNlIHN0ZW0gaW50ZXJzZWN0aW9uIHdpdGggbG93ZXIgdm9pY2VcbiAgICBpZiAobm90ZU0gIT0gbnVsbCAmJiBub3RlTS5taW5fbGluZSA8IG5vdGVMLm1heF9saW5lICsgMC41KSB7XG4gICAgICBpZiAoIW5vdGVNLmlzcmVzdCkge1xuICAgICAgICBzdGVtX2RlbHRhID0gTWF0aC5hYnMobm90ZU0ubGluZSAtIChub3RlTC5tYXhfbGluZSArIDAuNSkpO1xuICAgICAgICBzdGVtX2RlbHRhID0gTWF0aC5tYXgoc3RlbV9kZWx0YSwgbm90ZU0uc3RlbV9taW4pO1xuICAgICAgICBub3RlTS5taW5fbGluZSA9IG5vdGVNLmxpbmUgLSBzdGVtX2RlbHRhO1xuICAgICAgICBub3RlTS5ub3RlLnNldFN0ZW1MZW5ndGgoc3RlbV9kZWx0YSAqIDEwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3IgdGhyZWUgdm9pY2VzLCB0ZXN0IGlmIHJlc3RzIGNhbiBiZSByZXBvc2l0aW9uZWRcbiAgICAvL1xuICAgIC8vIFNwZWNpYWwgY2FzZSAxIDo6IG1pZGRsZSB2b2ljZSByZXN0IGJldHdlZW4gdHdvIG5vdGVzXG4gICAgLy9cbiAgICBpZiAobm90ZU0uaXNyZXN0ICYmICFub3RlVS5pc3Jlc3QgJiYgIW5vdGVMLmlzcmVzdCkge1xuICAgICAgaWYgKG5vdGVVLm1pbl9saW5lIDw9IG5vdGVNLm1heF9saW5lIHx8XG4gICAgICAgICAgbm90ZU0ubWluX2xpbmUgPD0gbm90ZUwubWF4X2xpbmUpIHtcbiAgICAgICAgIHZhciByZXN0X2hlaWdodCA9IG5vdGVNLm1heF9saW5lIC0gbm90ZU0ubWluX2xpbmU7XG4gICAgICAgICB2YXIgc3BhY2UgPSBub3RlVS5taW5fbGluZSAtIG5vdGVMLm1heF9saW5lO1xuICAgICAgICAgaWYgKHJlc3RfaGVpZ2h0IDwgc3BhY2UpXG4gICAgICAgICAgIC8vIGNlbnRlciBtaWRkbGUgdm9pY2UgcmVzdCBiZXR3ZWVuIHRoZSB1cHBlciBhbmQgbG93ZXIgdm9pY2VzXG4gICAgICAgICAgIGNlbnRlclJlc3Qobm90ZU0sIG5vdGVVLCBub3RlTCk7XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgeF9zaGlmdCA9IHZvaWNlX3hfc2hpZnQgKyAzOyAgICAvLyBzaGlmdCBtaWRkbGUgcmVzdCByaWdodFxuICAgICAgICAgICBub3RlTS5ub3RlLnNldFhTaGlmdCh4X3NoaWZ0KTtcbiAgICAgICAgIH1cbiAgICAgICAgIC8vIGZvcm1hdCBjb21wbGV0ZVxuICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIDIgOjogYWxsIHZvaWNlcyBhcmUgcmVzdHNcbiAgICBpZiAobm90ZVUuaXNyZXN0ICYmIG5vdGVNLmlzcmVzdCAmJiBub3RlTC5pc3Jlc3QpIHtcbiAgICAgIC8vIFNoaWZ0IHVwcGVyIHZvaWNlIHJlc3QgdXBcbiAgICAgIHNoaWZ0UmVzdFZlcnRpY2FsKG5vdGVVLCBub3RlTSwgMSk7XG4gICAgICAvLyBTaGlmdCBsb3dlciB2b2ljZSByZXN0IGRvd25cbiAgICAgIHNoaWZ0UmVzdFZlcnRpY2FsKG5vdGVMLCBub3RlTSwgLTEpO1xuICAgICAgLy8gZm9ybWF0IGNvbXBsZXRlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBUZXN0IGlmIGFueSBvdGhlciByZXN0cyBjYW4gYmUgcmVwb3NpdGlvbmVkXG4gICAgaWYgKG5vdGVNLmlzcmVzdCAmJiBub3RlVS5pc3Jlc3QgJiYgbm90ZU0ubWluX2xpbmUgPD0gbm90ZUwubWF4X2xpbmUpXG4gICAgICAvLyBTaGlmdCBtaWRkbGUgdm9pY2UgcmVzdCB1cFxuICAgICAgc2hpZnRSZXN0VmVydGljYWwobm90ZU0sIG5vdGVMLCAxKTtcbiAgICBpZiAobm90ZU0uaXNyZXN0ICYmIG5vdGVMLmlzcmVzdCAmJiBub3RlVS5taW5fbGluZSA8PSBub3RlTS5tYXhfbGluZSlcbiAgICAgIC8vIFNoaWZ0IG1pZGRsZSB2b2ljZSByZXN0IGRvd25cbiAgICAgIHNoaWZ0UmVzdFZlcnRpY2FsKG5vdGVNLCBub3RlVSwgLTEpO1xuICAgIGlmIChub3RlVS5pc3Jlc3QgJiYgbm90ZVUubWluX2xpbmUgPD0gbm90ZU0ubWF4X2xpbmUpXG4gICAgICAvLyBzaGlmdCB1cHBlciB2b2ljZSByZXN0IHVwO1xuICAgICAgc2hpZnRSZXN0VmVydGljYWwobm90ZVUsIG5vdGVNLCAxKTtcbiAgICBpZiAobm90ZUwuaXNyZXN0ICYmIG5vdGVNLm1pbl9saW5lIDw9IG5vdGVMLm1heF9saW5lKVxuICAgICAgLy8gc2hpZnQgbG93ZXIgdm9pY2UgcmVzdCBkb3duXG4gICAgICBzaGlmdFJlc3RWZXJ0aWNhbChub3RlTCwgbm90ZU0sIC0xKTtcblxuICAgIC8vIElmIG1pZGRsZSB2b2ljZSBpbnRlcnNlY3RzIHVwcGVyIG9yIGxvd2VyIHZvaWNlXG4gICAgaWYgKCghbm90ZVUuaXNyZXN0ICYmICFub3RlTS5pc3Jlc3QgJiYgbm90ZVUubWluX2xpbmUgPD0gbm90ZU0ubWF4X2xpbmUgKyAwLjUpIHx8XG4gICAgICAgICghbm90ZU0uaXNyZXN0ICYmICFub3RlTC5pc3Jlc3QgJiYgbm90ZU0ubWluX2xpbmUgPD0gbm90ZUwubWF4X2xpbmUpKSB7XG4gICAgICB4X3NoaWZ0ID0gdm9pY2VfeF9zaGlmdCArIDM7ICAgICAgLy8gc2hpZnQgbWlkZGxlIG5vdGUgcmlnaHRcbiAgICAgIG5vdGVNLm5vdGUuc2V0WFNoaWZ0KHhfc2hpZnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIFN0YXZlTm90ZS5mb3JtYXRCeVkgPSBmdW5jdGlvbihub3Rlcywgc3RhdGUpIHtcbiAgICAvLyBOT1RFOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgbW9yZSB0aGFuIHR3byB2b2ljZXMgcGVyIHN0YXZlXG4gICAgLy8gICAgICAgdXNlIHdpdGggY2FyZS5cbiAgICB2YXIgaGFzU3RhdmUgPSB0cnVlO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5vdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNTdGF2ZSA9IGhhc1N0YXZlICYmIG5vdGVzW2ldLmdldFN0YXZlKCkgIT0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIWhhc1N0YXZlKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJTdGF2ZSBNaXNzaW5nXCIsXG4gICAgICBcIkFsbCBub3RlcyBtdXN0IGhhdmUgYSBzdGF2ZSAtIFZleC5GbG93Lk1vZGlmaWVyQ29udGV4dC5mb3JtYXRNdWx0aVZvaWNlIVwiKTtcblxuICAgIHZhciB4X3NoaWZ0ID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBub3Rlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciB0b3Bfbm90ZSA9IG5vdGVzW2ldO1xuICAgICAgdmFyIGJvdHRvbV9ub3RlID0gbm90ZXNbaSArIDFdO1xuXG4gICAgICBpZiAodG9wX25vdGUuZ2V0U3RlbURpcmVjdGlvbigpID09IFZleC5GbG93LlN0YXZlTm90ZS5TVEVNX0RPV04pIHtcbiAgICAgICAgdG9wX25vdGUgPSBub3Rlc1tpICsgMV07XG4gICAgICAgIGJvdHRvbV9ub3RlID0gbm90ZXNbaV07XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3Bfa2V5cyA9IHRvcF9ub3RlLmdldEtleVByb3BzKCk7XG4gICAgICB2YXIgYm90dG9tX2tleXMgPSBib3R0b21fbm90ZS5nZXRLZXlQcm9wcygpO1xuXG4gICAgICB2YXIgdG9wWSA9IHRvcF9ub3RlLmdldFN0YXZlKCkuZ2V0WUZvckxpbmUodG9wX2tleXNbMF0ubGluZSk7XG4gICAgICB2YXIgYm90dG9tWSA9IGJvdHRvbV9ub3RlLmdldFN0YXZlKCkuZ2V0WUZvckxpbmUoYm90dG9tX2tleXNbYm90dG9tX2tleXMubGVuZ3RoIC0gMV0ubGluZSk7XG5cbiAgICAgIHZhciBsaW5lX3NwYWNlID0gdG9wX25vdGUuZ2V0U3RhdmUoKS5vcHRpb25zLnNwYWNpbmdfYmV0d2Vlbl9saW5lc19weDtcbiAgICAgIGlmIChNYXRoLmFicyh0b3BZIC0gYm90dG9tWSkgPT0gbGluZV9zcGFjZSAvIDIpIHtcbiAgICAgICAgeF9zaGlmdCA9IHRvcF9ub3RlLmdldFZvaWNlU2hpZnRXaWR0aCgpO1xuICAgICAgICBib3R0b21fbm90ZS5zZXRYU2hpZnQoeF9zaGlmdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUucmlnaHRfc2hpZnQgKz0geF9zaGlmdDtcbiAgfTtcblxuICBTdGF2ZU5vdGUucG9zdEZvcm1hdCA9IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgaWYgKCFub3RlcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgbm90ZXMuZm9yRWFjaChmdW5jdGlvbihub3RlKSB7XG4gICAgICBub3RlLnBvc3RGb3JtYXQoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIC8vXG4gIFZleC5Jbmhlcml0KFN0YXZlTm90ZSwgVmV4LkZsb3cuU3RlbW1hYmxlTm90ZSwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG5vdGVfc3RydWN0KSB7XG4gICAgICBTdGF2ZU5vdGUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbm90ZV9zdHJ1Y3QpO1xuXG4gICAgICB0aGlzLmtleXMgPSBub3RlX3N0cnVjdC5rZXlzO1xuICAgICAgdGhpcy5jbGVmID0gbm90ZV9zdHJ1Y3QuY2xlZjtcbiAgICAgIHRoaXMub2N0YXZlX3NoaWZ0ID0gbm90ZV9zdHJ1Y3Qub2N0YXZlX3NoaWZ0O1xuICAgICAgdGhpcy5iZWFtID0gbnVsbDtcblxuICAgICAgLy8gUHVsbCBub3RlIHJlbmRlcmluZyBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLmdseXBoID0gVmV4LkZsb3cuZHVyYXRpb25Ub0dseXBoKHRoaXMuZHVyYXRpb24sIHRoaXMubm90ZVR5cGUpO1xuICAgICAgaWYgKCF0aGlzLmdseXBoKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiQmFkQXJndW1lbnRzXCIsXG4gICAgICAgICAgICBcIkludmFsaWQgbm90ZSBpbml0aWFsaXphdGlvbiBkYXRhIChObyBnbHlwaCBmb3VuZCk6IFwiICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG5vdGVfc3RydWN0KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRydWUsIGRpc3BsYWNlIG5vdGUgdG8gcmlnaHRcbiAgICAgIHRoaXMuZGlzcGxhY2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmRvdF9zaGlmdFkgPSAwO1xuICAgICAgLy8gcGVyLXBpdGNoIHByb3BlcnRpZXNcbiAgICAgIHRoaXMua2V5UHJvcHMgPSBbXTtcbiAgICAgIC8vIGZvciBkaXNwbGFjZWQgbGVkZ2VyIGxpbmVzXG4gICAgICB0aGlzLnVzZV9kZWZhdWx0X2hlYWRfeCA9IGZhbHNlO1xuXG4gICAgICAvLyBEcmF3aW5nXG4gICAgICB0aGlzLm5vdGVfaGVhZHMgPSBbXTtcbiAgICAgIHRoaXMubW9kaWZpZXJzID0gW107XG5cbiAgICAgIFZleC5NZXJnZSh0aGlzLnJlbmRlcl9vcHRpb25zLCB7XG4gICAgICAgIC8vIGZvbnQgc2l6ZSBmb3Igbm90ZSBoZWFkcyBhbmQgcmVzdHNcbiAgICAgICAgZ2x5cGhfZm9udF9zY2FsZTogMzUsXG4gICAgICAgIC8vIG51bWJlciBvZiBzdHJva2UgcHggdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIGhlYWRcbiAgICAgICAgc3Ryb2tlX3B4OiAzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5jYWxjdWxhdGVLZXlQcm9wcygpO1xuXG4gICAgICB0aGlzLmJ1aWxkU3RlbSgpO1xuXG4gICAgICAvLyBTZXQgdGhlIHN0ZW0gZGlyZWN0aW9uXG4gICAgICBpZiAobm90ZV9zdHJ1Y3QuYXV0b19zdGVtKSB7XG4gICAgICAgIHRoaXMuYXV0b1N0ZW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RlbURpcmVjdGlvbihub3RlX3N0cnVjdC5zdGVtX2RpcmVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVpbGROb3RlSGVhZHMoKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGxlZnQvcmlnaHQgcGFkZGluZ1xuICAgICAgdGhpcy5jYWxjRXh0cmFQeCgpO1xuICAgIH0sXG5cbiAgICAvLyBCdWlsZHMgYSBgU3RlbWAgZm9yIHRoZSBub3RlXG4gICAgYnVpbGRTdGVtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2V0R2x5cGgoKTtcblxuICAgICAgdmFyIHlfZXh0ZW5kID0gMDtcbiAgICAgIGlmIChnbHlwaC5jb2RlX2hlYWQgPT0gXCJ2OTVcIiB8fCBnbHlwaC5jb2RlX2hlYWQgPT0gXCJ2M2VcIikge1xuICAgICAgICAgeV9leHRlbmQgPSAtNDtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0ZW0gPSBuZXcgU3RlbSh7XG4gICAgICAgIHlfZXh0ZW5kOiB5X2V4dGVuZFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmlzUmVzdCgpKSB7XG4gICAgICAgIHN0ZW0uaGlkZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RlbShzdGVtKTtcbiAgICB9LFxuXG4gICAgLy8gQnVpbGRzIGEgYE5vdGVIZWFkYCBmb3IgZWFjaCBrZXkgaW4gdGhlIG5vdGVcbiAgICBidWlsZE5vdGVIZWFkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RlbV9kaXJlY3Rpb24gPSB0aGlzLmdldFN0ZW1EaXJlY3Rpb24oKTtcblxuICAgICAgdmFyIGtleXMgPSB0aGlzLmdldEtleXMoKTtcblxuICAgICAgdmFyIGxhc3RfbGluZSA9IG51bGw7XG4gICAgICB2YXIgbGluZV9kaWZmID0gbnVsbDtcbiAgICAgIHZhciBkaXNwbGFjZWQgPSBmYWxzZTtcblxuICAgICAgLy8gRHJhdyBub3RlcyBmcm9tIGJvdHRvbSB0byB0b3AuXG4gICAgICB2YXIgc3RhcnRfaSA9IDA7XG4gICAgICB2YXIgZW5kX2kgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHZhciBzdGVwX2kgPSAxO1xuXG4gICAgICAvLyBGb3IgZG93bi1zdGVtIG5vdGVzLCB3ZSBkcmF3IGZyb20gdG9wIHRvIGJvdHRvbS5cbiAgICAgIGlmIChzdGVtX2RpcmVjdGlvbiA9PT0gU3RlbS5ET1dOKSB7XG4gICAgICAgIHN0YXJ0X2kgPSBrZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgIGVuZF9pID0gLTE7XG4gICAgICAgIHN0ZXBfaSA9IC0xO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRfaTsgaSAhPSBlbmRfaTsgaSArPSBzdGVwX2kpIHtcbiAgICAgICAgdmFyIG5vdGVfcHJvcHMgPSB0aGlzLmtleVByb3BzW2ldO1xuXG4gICAgICAgIHZhciBsaW5lID0gbm90ZV9wcm9wcy5saW5lO1xuXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgbGFzdCBsaW5lIHdpdGggYSBub3RlIGhlYWQsIHNvIHRoYXQgY29uc2VjdXRpdmUgaGVhZHNcbiAgICAgICAgLy8gYXJlIGNvcnJlY3RseSBkaXNwbGFjZWQuXG4gICAgICAgIGlmIChsYXN0X2xpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICBsYXN0X2xpbmUgPSBsaW5lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVfZGlmZiA9IE1hdGguYWJzKGxhc3RfbGluZSAtIGxpbmUpO1xuICAgICAgICAgIGlmIChsaW5lX2RpZmYgPT09IDAgfHwgbGluZV9kaWZmID09PSAwLjUpIHtcbiAgICAgICAgICAgIGRpc3BsYWNlZCA9ICFkaXNwbGFjZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3BsYWNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy51c2VfZGVmYXVsdF9oZWFkX3ggPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0X2xpbmUgPSBsaW5lO1xuXG4gICAgICAgIHZhciBub3RlX2hlYWQgPSBuZXcgTm90ZUhlYWQoe1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIG5vdGVfdHlwZTogdGhpcy5ub3RlVHlwZSxcbiAgICAgICAgICBkaXNwbGFjZWQ6IGRpc3BsYWNlZCxcbiAgICAgICAgICBzdGVtX2RpcmVjdGlvbjogc3RlbV9kaXJlY3Rpb24sXG4gICAgICAgICAgY3VzdG9tX2dseXBoX2NvZGU6IG5vdGVfcHJvcHMuY29kZSxcbiAgICAgICAgICBnbHlwaF9mb250X3NjYWxlOiB0aGlzLnJlbmRlcl9vcHRpb25zLmdseXBoX2ZvbnRfc2NhbGUsXG4gICAgICAgICAgeF9zaGlmdDogbm90ZV9wcm9wcy5zaGlmdF9yaWdodCxcbiAgICAgICAgICBsaW5lOiBub3RlX3Byb3BzLmxpbmVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ub3RlX2hlYWRzW2ldID0gbm90ZV9oZWFkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBBdXRvbWF0aWNhbGx5IHNldHMgdGhlIHN0ZW0gZGlyZWN0aW9uIGJhc2VkIG9uIHRoZSBrZXlzIGluIHRoZSBub3RlXG4gICAgYXV0b1N0ZW06IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF1dG9fc3RlbV9kaXJlY3Rpb247XG5cbiAgICAgIC8vIEZpZ3VyZSBvdXQgb3B0aW1hbCBzdGVtIGRpcmVjdGlvbiBiYXNlZCBvbiBnaXZlbiBub3Rlc1xuICAgICAgdGhpcy5taW5fbGluZSA9IHRoaXMua2V5UHJvcHNbMF0ubGluZTtcbiAgICAgIHRoaXMubWF4X2xpbmUgPSB0aGlzLmtleVByb3BzW3RoaXMua2V5UHJvcHMubGVuZ3RoIC0gMV0ubGluZTtcbiAgICAgIHZhciBkZWNpZGVyID0gKHRoaXMubWluX2xpbmUgKyB0aGlzLm1heF9saW5lKSAvIDI7XG5cbiAgICAgIGlmIChkZWNpZGVyIDwgMykge1xuICAgICAgICBhdXRvX3N0ZW1fZGlyZWN0aW9uID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF1dG9fc3RlbV9kaXJlY3Rpb24gPSAtMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdGVtRGlyZWN0aW9uKGF1dG9fc3RlbV9kaXJlY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvLyBDYWxjdWxhdGVzIGFuZCBzdG9yZXMgdGhlIHByb3BlcnRpZXMgZm9yIGVhY2gga2V5IGluIHRoZSBub3RlXG4gICAgY2FsY3VsYXRlS2V5UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3RfbGluZSA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5rZXlzW2ldO1xuXG4gICAgICAgIC8vIEFsbCByZXN0cyB1c2UgdGhlIHNhbWUgcG9zaXRpb24gb24gdGhlIGxpbmUuXG4gICAgICAgIC8vIGlmICh0aGlzLmdseXBoLnJlc3QpIGtleSA9IHRoaXMuZ2x5cGgucG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLmdseXBoLnJlc3QpIHRoaXMuZ2x5cGgucG9zaXRpb24gPSBrZXk7XG4gICAgICAgIHZhciBvcHRpb25zID0geyBvY3RhdmVfc2hpZnQ6IHRoaXMub2N0YXZlX3NoaWZ0IHx8IDAgfTtcbiAgICAgICAgdmFyIHByb3BzID0gVmV4LkZsb3cua2V5UHJvcGVydGllcyhrZXksIHRoaXMuY2xlZiwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLFxuICAgICAgICAgICAgICBcIkludmFsaWQga2V5IGZvciBub3RlIHByb3BlcnRpZXM6IFwiICsga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE92ZXJyaWRlIGxpbmUgcGxhY2VtZW50IGZvciBkZWZhdWx0IHJlc3RzXG4gICAgICAgIGlmIChwcm9wcy5rZXkgPT09IFwiUlwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZHVyYXRpb24gPT09IFwiMVwiIHx8IHRoaXMuZHVyYXRpb24gPT09IFwid1wiKSB7XG4gICAgICAgICAgICBwcm9wcy5saW5lID0gNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcHMubGluZSA9IDM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRpc3BsYWNlbWVudCBvZiB0aGlzIG5vdGVcbiAgICAgICAgdmFyIGxpbmUgPSBwcm9wcy5saW5lO1xuICAgICAgICBpZiAobGFzdF9saW5lID09PSBudWxsKSB7XG4gICAgICAgICAgbGFzdF9saW5lID0gbGluZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMobGFzdF9saW5lIC0gbGluZSkgPT0gMC41KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICBwcm9wcy5kaXNwbGFjZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBIYXZlIHRvIG1hcmsgdGhlIHByZXZpb3VzIG5vdGUgYXNcbiAgICAgICAgICAgIC8vIGRpc3BsYWNlZCBhcyB3ZWxsLCBmb3IgbW9kaWZpZXIgcGxhY2VtZW50XG4gICAgICAgICAgICBpZiAodGhpcy5rZXlQcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlQcm9wc1tpLTFdLmRpc3BsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdF9saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5rZXlQcm9wcy5wdXNoKHByb3BzKTtcbiAgICAgIH1cblxuICAgICAgLy8gU29ydCB0aGUgbm90ZXMgZnJvbSBsb3dlc3QgbGluZSB0byBoaWdoZXN0IGxpbmVcbiAgICAgIHZhciBzb3J0ZWQgPSB0cnVlO1xuICAgICAgdmFyIGxhc3RMaW5lID0gLTEwMDA7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGlzLmtleVByb3BzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkubGluZSA8IGxhc3RMaW5lKSB7XG4gICAgICAgICAgVmV4LlcoXCJVbnNvcnRlZCBrZXlzIGluIG5vdGUgd2lsbCBiZSBzb3J0ZWQuIFwiICtcbiAgICAgICAgICAgIFwiU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS8weGZlL3ZleGZsb3cvaXNzdWVzLzEwNCBmb3IgZGV0YWlscy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdExpbmUgPSBrZXkubGluZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5rZXlQcm9wcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEubGluZSAtIGIubGluZTsgfSk7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgYEJvdW5kaW5nQm94YCBmb3IgdGhlIGVudGlyZSBub3RlXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnByZUZvcm1hdHRlZCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiVW5mb3JtYXR0ZWROb3RlXCIsXG4gICAgICAgICAgXCJDYW4ndCBjYWxsIGdldEJvdW5kaW5nQm94IG9uIGFuIHVuZm9ybWF0dGVkIG5vdGUuXCIpO1xuXG4gICAgICB2YXIgbWV0cmljcyA9IHRoaXMuZ2V0TWV0cmljcygpO1xuXG4gICAgICB2YXIgdyA9IG1ldHJpY3Mud2lkdGg7XG4gICAgICB2YXIgeCA9IHRoaXMuZ2V0QWJzb2x1dGVYKCkgLSBtZXRyaWNzLm1vZExlZnRQeCAtIG1ldHJpY3MuZXh0cmFMZWZ0UHg7XG5cbiAgICAgIHZhciBtaW5feSA9IDA7XG4gICAgICB2YXIgbWF4X3kgPSAwO1xuICAgICAgdmFyIGhhbGZfbGluZV9zcGFjaW5nID0gdGhpcy5nZXRTdGF2ZSgpLmdldFNwYWNpbmdCZXR3ZWVuTGluZXMoKSAvIDI7XG4gICAgICB2YXIgbGluZV9zcGFjaW5nID0gaGFsZl9saW5lX3NwYWNpbmcgKiAyO1xuXG4gICAgICBpZiAodGhpcy5pc1Jlc3QoKSkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueXNbMF07XG4gICAgICAgIHZhciBmcmFjID0gVmV4LkZsb3cuZHVyYXRpb25Ub0ZyYWN0aW9uKHRoaXMuZHVyYXRpb24pO1xuICAgICAgICBpZiAoZnJhYy5lcXVhbHMoMSkgfHwgZnJhYy5lcXVhbHMoMikpIHtcbiAgICAgICAgICBtaW5feSA9IHkgLSBoYWxmX2xpbmVfc3BhY2luZztcbiAgICAgICAgICBtYXhfeSA9IHkgKyBoYWxmX2xpbmVfc3BhY2luZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaW5feSA9IHkgLSAodGhpcy5nbHlwaC5saW5lX2Fib3ZlICogbGluZV9zcGFjaW5nKTtcbiAgICAgICAgICBtYXhfeSA9IHkgKyAodGhpcy5nbHlwaC5saW5lX2JlbG93ICogbGluZV9zcGFjaW5nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmdseXBoLnN0ZW0pIHtcbiAgICAgICAgdmFyIHlzID0gdGhpcy5nZXRTdGVtRXh0ZW50cygpO1xuICAgICAgICB5cy5iYXNlWSArPSBoYWxmX2xpbmVfc3BhY2luZyAqIHRoaXMuc3RlbV9kaXJlY3Rpb247XG4gICAgICAgIG1pbl95ID0gVmV4Lk1pbih5cy50b3BZLCB5cy5iYXNlWSk7XG4gICAgICAgIG1heF95ID0gVmV4Lk1heCh5cy50b3BZLCB5cy5iYXNlWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5feSA9IG51bGw7XG4gICAgICAgIG1heF95ID0gbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCB0aGlzLnlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIHl5ID0gdGhpcy55c1tpXTtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgbWluX3kgPSB5eTtcbiAgICAgICAgICAgIG1heF95ID0geXk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pbl95ID0gVmV4Lk1pbih5eSwgbWluX3kpO1xuICAgICAgICAgICAgbWF4X3kgPSBWZXguTWF4KHl5LCBtYXhfeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1pbl95IC09IGhhbGZfbGluZV9zcGFjaW5nO1xuICAgICAgICAgIG1heF95ICs9IGhhbGZfbGluZV9zcGFjaW5nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgVmV4LkZsb3cuQm91bmRpbmdCb3goeCwgbWluX3ksIHcsIG1heF95IC0gbWluX3kpO1xuICAgIH0sXG5cbiAgICAvLyBHZXRzIHRoZSBsaW5lIG51bWJlciBvZiB0aGUgdG9wIG9yIGJvdHRvbSBub3RlIGluIHRoZSBjaG9yZC5cbiAgICAvLyBJZiBgaXNfdG9wX25vdGVgIGlzIGB0cnVlYCB0aGVuIGdldCB0aGUgdG9wIG5vdGVcbiAgICBnZXRMaW5lTnVtYmVyOiBmdW5jdGlvbihpc190b3Bfbm90ZSkge1xuICAgICAgaWYoIXRoaXMua2V5UHJvcHMubGVuZ3RoKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0tleVByb3BzXCIsXG4gICAgICAgICAgXCJDYW4ndCBnZXQgYm90dG9tIG5vdGUgbGluZSwgYmVjYXVzZSBub3RlIGlzIG5vdCBpbml0aWFsaXplZCBwcm9wZXJseS5cIik7XG4gICAgICB2YXIgcmVzdWx0X2xpbmUgPSB0aGlzLmtleVByb3BzWzBdLmxpbmU7XG5cbiAgICAgIC8vIE5vIHByZWNvbmRpdGlvbiBhc3N1bWVkIGZvciBzb3J0ZWRuZXNzIG9mIGtleVByb3BzIGFycmF5XG4gICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5rZXlQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGhpc19saW5lID0gdGhpcy5rZXlQcm9wc1tpXS5saW5lO1xuICAgICAgICBpZiAoaXNfdG9wX25vdGUpIHtcbiAgICAgICAgICBpZiAodGhpc19saW5lID4gcmVzdWx0X2xpbmUpIHJlc3VsdF9saW5lID0gdGhpc19saW5lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzX2xpbmUgPCByZXN1bHRfbGluZSkgcmVzdWx0X2xpbmUgPSB0aGlzX2xpbmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdF9saW5lO1xuICAgIH0sXG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgY3VycmVudCBub3RlIGlzIGEgcmVzdFxuICAgIGlzUmVzdDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmdseXBoLnJlc3Q7IH0sXG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGN1cnJlbnQgbm90ZSBpcyBhIGNob3JkXG4gICAgaXNDaG9yZDogZnVuY3Rpb24oKSB7IHJldHVybiAhdGhpcy5pc1Jlc3QoKSAmJiB0aGlzLmtleXMubGVuZ3RoID4gMTsgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgYFN0YXZlTm90ZWAgaGFzIGEgc3RlbVxuICAgIGhhc1N0ZW06IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5nbHlwaC5zdGVtOyB9LFxuXG4gICAgLy8gR2V0IHRoZSBgeWAgY29vcmRpbmF0ZSBmb3IgdGV4dCBwbGFjZWQgb24gdGhlIHRvcC9ib3R0b20gb2YgYVxuICAgIC8vIG5vdGUgYXQgYSBkZXNpcmVkIGB0ZXh0X2xpbmVgXG4gICAgZ2V0WUZvclRvcFRleHQ6IGZ1bmN0aW9uKHRleHRfbGluZSkge1xuICAgICAgdmFyIGV4dGVudHMgPSB0aGlzLmdldFN0ZW1FeHRlbnRzKCk7XG4gICAgICByZXR1cm4gVmV4Lk1pbih0aGlzLnN0YXZlLmdldFlGb3JUb3BUZXh0KHRleHRfbGluZSksXG4gICAgICAgICAgZXh0ZW50cy50b3BZIC0gKHRoaXMucmVuZGVyX29wdGlvbnMuYW5ub3RhdGlvbl9zcGFjaW5nICogKHRleHRfbGluZSArIDEpKSk7XG4gICAgfSxcbiAgICBnZXRZRm9yQm90dG9tVGV4dDogZnVuY3Rpb24odGV4dF9saW5lKSB7XG4gICAgICB2YXIgZXh0ZW50cyA9IHRoaXMuZ2V0U3RlbUV4dGVudHMoKTtcbiAgICAgIHJldHVybiBWZXguTWF4KHRoaXMuc3RhdmUuZ2V0WUZvclRvcFRleHQodGV4dF9saW5lKSxcbiAgICAgICAgICBleHRlbnRzLmJhc2VZICsgKHRoaXMucmVuZGVyX29wdGlvbnMuYW5ub3RhdGlvbl9zcGFjaW5nICogKHRleHRfbGluZSkpKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0cyB0aGUgY3VycmVudCBub3RlIHRvIHRoZSBwcm92aWRlZCBgc3RhdmVgLiBUaGlzIGFwcGxpZXNcbiAgICAvLyBgeWAgdmFsdWVzIHRvIHRoZSBgTm90ZUhlYWRzYC5cbiAgICBzZXRTdGF2ZTogZnVuY3Rpb24oc3RhdmUpIHtcbiAgICAgIHZhciBzdXBlcmNsYXNzID0gVmV4LkZsb3cuU3RhdmVOb3RlLnN1cGVyY2xhc3M7XG4gICAgICBzdXBlcmNsYXNzLnNldFN0YXZlLmNhbGwodGhpcywgc3RhdmUpO1xuXG4gICAgICB2YXIgeXMgPSB0aGlzLm5vdGVfaGVhZHMubWFwKGZ1bmN0aW9uKG5vdGVfaGVhZCkge1xuICAgICAgICBub3RlX2hlYWQuc2V0U3RhdmUoc3RhdmUpO1xuICAgICAgICByZXR1cm4gbm90ZV9oZWFkLmdldFkoKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNldFlzKHlzKTtcblxuICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Tm90ZUhlYWRCb3VuZHMoKTtcblx0ICAgIGlmICh0aGlzLmhhc1N0ZW0oKSkge1xuICAgICAgICB0aGlzLnN0ZW0uc2V0WUJvdW5kcyhib3VuZHMueV90b3AsIGJvdW5kcy55X2JvdHRvbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHBpdGNoZXMgaW4gdGhlIG5vdGVcbiAgICBnZXRLZXlzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMua2V5czsgfSxcblxuICAgIC8vIEdldCB0aGUgcHJvcGVydGllcyBmb3IgYWxsIHRoZSBrZXlzIGluIHRoZSBub3RlXG4gICAgZ2V0S2V5UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5UHJvcHM7XG4gICAgfSxcblxuICAgIC8vIENoZWNrIGlmIG5vdGUgaXMgc2hpZnRlZCB0byB0aGUgcmlnaHRcbiAgICBpc0Rpc3BsYWNlZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXNwbGFjZWQ7XG4gICAgfSxcblxuICAgIC8vIFNldHMgd2hldGhlciBzaGlmdCBub3RlIHRvIHRoZSByaWdodC4gYGRpc3BsYWNlZGAgaXMgYSBgYm9vbGVhbmBcbiAgICBzZXROb3RlRGlzcGxhY2VkOiBmdW5jdGlvbihkaXNwbGFjZWQpIHtcbiAgICAgIHRoaXMuZGlzcGxhY2VkID0gZGlzcGxhY2VkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgc3RhcnRpbmcgYHhgIGNvb3JkaW5hdGUgZm9yIGEgYFN0YXZlVGllYFxuICAgIGdldFRpZVJpZ2h0WDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGllU3RhcnRYID0gdGhpcy5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgIHRpZVN0YXJ0WCArPSB0aGlzLmdseXBoLmhlYWRfd2lkdGggKyB0aGlzLnhfc2hpZnQgKyB0aGlzLmV4dHJhUmlnaHRQeDtcbiAgICAgIGlmICh0aGlzLm1vZGlmaWVyQ29udGV4dCkgdGllU3RhcnRYICs9IHRoaXMubW9kaWZpZXJDb250ZXh0LmdldEV4dHJhUmlnaHRQeCgpO1xuICAgICAgcmV0dXJuIHRpZVN0YXJ0WDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBlbmRpbmcgYHhgIGNvb3JkaW5hdGUgZm9yIGEgYFN0YXZlVGllYFxuICAgIGdldFRpZUxlZnRYOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aWVFbmRYID0gdGhpcy5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgIHRpZUVuZFggKz0gdGhpcy54X3NoaWZ0IC0gdGhpcy5leHRyYUxlZnRQeDtcbiAgICAgIHJldHVybiB0aWVFbmRYO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHN0YXZlIGxpbmUgb24gd2hpY2ggdG8gcGxhY2UgYSByZXN0XG4gICAgZ2V0TGluZUZvclJlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3RfbGluZSA9IHRoaXMua2V5UHJvcHNbMF0ubGluZTtcbiAgICAgIGlmICh0aGlzLmtleVByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGxhc3RfbGluZSAgPSB0aGlzLmtleVByb3BzW3RoaXMua2V5UHJvcHMubGVuZ3RoIC0gMV0ubGluZTtcbiAgICAgICAgdmFyIHRvcCA9IFZleC5NYXgocmVzdF9saW5lLCBsYXN0X2xpbmUpO1xuICAgICAgICB2YXIgYm90ID0gVmV4Lk1pbihyZXN0X2xpbmUsIGxhc3RfbGluZSk7XG4gICAgICAgIHJlc3RfbGluZSA9IFZleC5NaWRMaW5lKHRvcCwgYm90KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3RfbGluZTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBkZWZhdWx0IGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGZvciB0aGUgcHJvdmlkZWQgYHBvc2l0aW9uYFxuICAgIC8vIGFuZCBrZXkgYGluZGV4YFxuICAgIGdldE1vZGlmaWVyU3RhcnRYWTogZnVuY3Rpb24ocG9zaXRpb24sIGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMucHJlRm9ybWF0dGVkKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJVbmZvcm1hdHRlZE5vdGVcIixcbiAgICAgICAgICBcIkNhbid0IGNhbGwgR2V0TW9kaWZpZXJTdGFydFhZIG9uIGFuIHVuZm9ybWF0dGVkIG5vdGVcIik7XG5cbiAgICAgIGlmICh0aGlzLnlzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9ZVmFsdWVzXCIsXG4gICAgICAgICAgXCJObyBZLVZhbHVlcyBjYWxjdWxhdGVkIGZvciB0aGlzIG5vdGUuXCIpO1xuXG4gICAgICB2YXIgeCA9IDA7XG4gICAgICBpZiAocG9zaXRpb24gPT0gVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uTEVGVCkge1xuICAgICAgICAvLyBleHRyYV9sZWZ0X3B4XG4gICAgICAgIHggPSAtMSAqIDI7XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLlJJR0hUKSB7XG4gICAgICAgIC8vIGV4dHJhX3JpZ2h0X3B4XG4gICAgICAgIHggPSB0aGlzLmdseXBoLmhlYWRfd2lkdGggKyB0aGlzLnhfc2hpZnQgKyAyO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PSBWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5CRUxPVyB8fFxuICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9PSBWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5BQk9WRSkge1xuICAgICAgICB4ID0gdGhpcy5nbHlwaC5oZWFkX3dpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgeDogdGhpcy5nZXRBYnNvbHV0ZVgoKSArIHgsIHk6IHRoaXMueXNbaW5kZXhdIH07XG4gICAgfSxcblxuICAgIC8vIFNldHMgdGhlIHN0eWxlIG9mIHRoZSBjb21wbGV0ZSBTdGF2ZU5vdGUsIGluY2x1ZGluZyBhbGwga2V5c1xuICAgIC8vIGFuZCB0aGUgc3RlbS5cbiAgICBzZXRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHRoaXMubm90ZV9oZWFkcy5mb3JFYWNoKGZ1bmN0aW9uKG5vdGVoZWFkKSB7XG4gICAgICAgIG5vdGVoZWFkLnNldFN0eWxlKHN0eWxlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5zdGVtLnNldFN0eWxlKHN0eWxlKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0cyB0aGUgbm90ZWhlYWQgYXQgYGluZGV4YCB0byB0aGUgcHJvdmlkZWQgY29sb3JpbmcgYHN0eWxlYC5cbiAgICAvL1xuICAgIC8vIGBzdHlsZWAgaXMgYW4gYG9iamVjdGAgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IGBzaGFkb3dDb2xvcmAsXG4gICAgLy8gYHNoYWRvd0JsdXJgLCBgZmlsbFN0eWxlYCwgYHN0cm9rZVN0eWxlYFxuICAgIHNldEtleVN0eWxlOiBmdW5jdGlvbihpbmRleCwgc3R5bGUpIHtcbiAgICAgIHRoaXMubm90ZV9oZWFkc1tpbmRleF0uc2V0U3R5bGUoc3R5bGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEtleUxpbmU6IGZ1bmN0aW9uKGluZGV4LCBsaW5lKSB7XG4gICAgICB0aGlzLmtleVByb3BzW2luZGV4XS5saW5lID0gbGluZTtcbiAgICAgIHRoaXMubm90ZV9oZWFkc1tpbmRleF0uc2V0TGluZShsaW5lKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRLZXlMaW5lOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5UHJvcHNbaW5kZXhdLmxpbmU7XG4gICAgfSxcblxuICAgIC8vIEFkZCBzZWxmIHRvIG1vZGlmaWVyIGNvbnRleHQuIGBtQ29udGV4dGAgaXMgdGhlIGBNb2RpZmllckNvbnRleHRgXG4gICAgLy8gdG8gYmUgYWRkZWQgdG8uXG4gICAgYWRkVG9Nb2RpZmllckNvbnRleHQ6IGZ1bmN0aW9uKG1Db250ZXh0KSB7XG4gICAgICB0aGlzLnNldE1vZGlmaWVyQ29udGV4dChtQ29udGV4dCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubW9kaWZpZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMubW9kaWZpZXJDb250ZXh0LmFkZE1vZGlmaWVyKHRoaXMubW9kaWZpZXJzW2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kaWZpZXJDb250ZXh0LmFkZE1vZGlmaWVyKHRoaXMpO1xuICAgICAgdGhpcy5zZXRQcmVGb3JtYXR0ZWQoZmFsc2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEdlbmVyaWMgZnVuY3Rpb24gdG8gYWRkIG1vZGlmaWVycyB0byBhIG5vdGVcbiAgICAvL1xuICAgIC8vIFBhcmFtZXRlcnM6XG4gICAgLy8gKiBgaW5kZXhgOiBUaGUgaW5kZXggb2YgdGhlIGtleSB0aGF0IHdlJ3JlIG1vZGlmeWluZ1xuICAgIC8vICogYG1vZGlmaWVyYDogVGhlIG1vZGlmaWVyIHRvIGFkZFxuICAgIGFkZE1vZGlmaWVyOiBmdW5jdGlvbihpbmRleCwgbW9kaWZpZXIpIHtcbiAgICAgIG1vZGlmaWVyLnNldE5vdGUodGhpcyk7XG4gICAgICBtb2RpZmllci5zZXRJbmRleChpbmRleCk7XG4gICAgICB0aGlzLm1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgIHRoaXMuc2V0UHJlRm9ybWF0dGVkKGZhbHNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gYWRkIGFuIGFjY2lkZW50YWwgdG8gYSBrZXlcbiAgICBhZGRBY2NpZGVudGFsOiBmdW5jdGlvbihpbmRleCwgYWNjaWRlbnRhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkTW9kaWZpZXIoaW5kZXgsIGFjY2lkZW50YWwpO1xuICAgIH0sXG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gYWRkIGFuIGFydGljdWxhdGlvbiB0byBhIGtleVxuICAgIGFkZEFydGljdWxhdGlvbjogZnVuY3Rpb24oaW5kZXgsIGFydGljdWxhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkTW9kaWZpZXIoaW5kZXgsIGFydGljdWxhdGlvbik7XG4gICAgfSxcblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBhZGQgYW4gYW5ub3RhdGlvbiB0byBhIGtleVxuICAgIGFkZEFubm90YXRpb246IGZ1bmN0aW9uKGluZGV4LCBhbm5vdGF0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRNb2RpZmllcihpbmRleCwgYW5ub3RhdGlvbik7XG4gICAgfSxcblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBhZGQgYSBkb3Qgb24gYSBzcGVjaWZpYyBrZXlcbiAgICBhZGREb3Q6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICB2YXIgZG90ID0gbmV3IFZleC5GbG93LkRvdCgpO1xuICAgICAgZG90LnNldERvdFNoaWZ0WSh0aGlzLmdseXBoLmRvdF9zaGlmdFkpO1xuICAgICAgdGhpcy5kb3RzKys7XG4gICAgICByZXR1cm4gdGhpcy5hZGRNb2RpZmllcihpbmRleCwgZG90KTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFkZCBkb3QgdG8gYWxsIGtleXMgaW4gbm90ZVxuICAgIGFkZERvdFRvQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICB0aGlzLmFkZERvdChpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYWxsIGFjY2lkZW50YWxzIGluIHRoZSBgTW9kaWZpZXJDb250ZXh0YFxuICAgIGdldEFjY2lkZW50YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGlmaWVyQ29udGV4dC5nZXRNb2RpZmllcnMoXCJhY2NpZGVudGFsc1wiKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFsbCBkb3RzIGluIHRoZSBgTW9kaWZpZXJDb250ZXh0YFxuICAgIGdldERvdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kaWZpZXJDb250ZXh0LmdldE1vZGlmaWVycyhcImRvdHNcIik7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgd2lkdGggb2YgdGhlIG5vdGUgaWYgaXQgaXMgZGlzcGxhY2VkLiBVc2VkIGZvciBgVm9pY2VgXG4gICAgLy8gZm9ybWF0dGluZ1xuICAgIGdldFZvaWNlU2hpZnRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBUT0RPOiBtYXkgbmVlZCB0byBhY2NvbW9kYXRlIGZvciBkb3QgaGVyZS5cbiAgICAgIHJldHVybiB0aGlzLmdseXBoLmhlYWRfd2lkdGggKiAodGhpcy5kaXNwbGFjZWQgPyAyIDogMSk7XG4gICAgfSxcblxuICAgIC8vIENhbGN1bGF0ZXMgYW5kIHNldHMgdGhlIGV4dHJhIHBpeGVscyB0byB0aGUgbGVmdCBvciByaWdodFxuICAgIC8vIGlmIHRoZSBub3RlIGlzIGRpc3BsYWNlZC5cbiAgICBjYWxjRXh0cmFQeDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldEV4dHJhTGVmdFB4KCh0aGlzLmRpc3BsYWNlZCAmJiB0aGlzLnN0ZW1fZGlyZWN0aW9uID09IC0xKSA/XG4gICAgICAgICAgdGhpcy5nbHlwaC5oZWFkX3dpZHRoIDogMCk7XG5cbiAgICAgIC8vIEZvciB1cHN0ZW1zIHdpdGggZmxhZ3MsIHRoZSBleHRyYSBzcGFjZSBpcyB1bm5lY2Vzc2FyeSwgc2luY2UgaXQncyB0YWtlblxuICAgICAgLy8gdXAgYnkgdGhlIGZsYWcuXG4gICAgICB0aGlzLnNldEV4dHJhUmlnaHRQeCgoIXRoaXMuaGFzRmxhZygpICYmIHRoaXMuZGlzcGxhY2VkICYmIHRoaXMuc3RlbV9kaXJlY3Rpb24gPT0gMSkgP1xuICAgICAgICAgIHRoaXMuZ2x5cGguaGVhZF93aWR0aCA6IDApO1xuICAgIH0sXG5cbiAgICAvLyBQcmUtcmVuZGVyIGZvcm1hdHRpbmdcbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucHJlRm9ybWF0dGVkKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5tb2RpZmllckNvbnRleHQpIHRoaXMubW9kaWZpZXJDb250ZXh0LnByZUZvcm1hdCgpO1xuXG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmdseXBoLmhlYWRfd2lkdGggKyB0aGlzLmV4dHJhTGVmdFB4ICsgdGhpcy5leHRyYVJpZ2h0UHg7XG5cbiAgICAgIC8vIEZvciB1cHdhcmQgZmxhZ2dlZCBub3RlcywgdGhlIHdpZHRoIG9mIHRoZSBmbGFnIG5lZWRzIHRvIGJlIGFkZGVkXG4gICAgICBpZiAodGhpcy5nbHlwaC5mbGFnICYmIHRoaXMuYmVhbSA9PT0gbnVsbCAmJiB0aGlzLnN0ZW1fZGlyZWN0aW9uID09IDEpIHtcbiAgICAgICAgd2lkdGggKz0gdGhpcy5nbHlwaC5oZWFkX3dpZHRoO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFdpZHRoKHdpZHRoKTtcbiAgICAgIHRoaXMuc2V0UHJlRm9ybWF0dGVkKHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBHZXRzIHRoZSBzdGFmZiBsaW5lIGFuZCB5IHZhbHVlIGZvciB0aGUgaGlnaGVzdCBhbmQgbG93ZXN0IG5vdGVoZWFkc1xuICAgIGdldE5vdGVIZWFkQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRvcCBhbmQgYm90dG9tIFkgdmFsdWVzIGZvciBzdGVtLlxuICAgICAgdmFyIHlfdG9wID0gbnVsbDtcbiAgICAgIHZhciB5X2JvdHRvbSA9IG51bGw7XG5cbiAgICAgIHZhciBoaWdoZXN0X2xpbmUgPSB0aGlzLnN0YXZlLmdldE51bUxpbmVzKCk7XG4gICAgICB2YXIgbG93ZXN0X2xpbmUgPSAxO1xuXG4gICAgICB0aGlzLm5vdGVfaGVhZHMuZm9yRWFjaChmdW5jdGlvbihub3RlX2hlYWQpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBub3RlX2hlYWQuZ2V0TGluZSgpO1xuICAgICAgICB2YXIgeSA9IG5vdGVfaGVhZC5nZXRZKCk7XG5cbiAgICAgICAgaWYgKHlfdG9wID09PSBudWxsIHx8IHkgPCB5X3RvcCkgIHtcbiAgICAgICAgICB5X3RvcCA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeV9ib3R0b20gPT09IG51bGwgfHwgeSA+IHlfYm90dG9tKSB7XG4gICAgICAgICAgeV9ib3R0b20gPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgaGlnaGVzdF9saW5lID0gbGluZSA+IGhpZ2hlc3RfbGluZSA/IGxpbmUgOiBoaWdoZXN0X2xpbmU7XG4gICAgICAgIGxvd2VzdF9saW5lID0gbGluZSA8IGxvd2VzdF9saW5lID8gbGluZSA6IGxvd2VzdF9saW5lO1xuXG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeV90b3A6IHlfdG9wLFxuICAgICAgICB5X2JvdHRvbTogeV9ib3R0b20sXG4gICAgICAgIGhpZ2hlc3RfbGluZTogaGlnaGVzdF9saW5lLFxuICAgICAgICBsb3dlc3RfbGluZTogbG93ZXN0X2xpbmVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgc3RhcnRpbmcgYHhgIGNvb3JkaW5hdGUgZm9yIHRoZSBub3RlaGVhZHNcbiAgICBnZXROb3RlSGVhZEJlZ2luWDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmdldEFic29sdXRlWCgpICsgdGhpcy54X3NoaWZ0O1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGVuZGluZyBgeGAgY29vcmRpbmF0ZSBmb3IgdGhlIG5vdGVoZWFkc1xuICAgIGdldE5vdGVIZWFkRW5kWDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciB4X2JlZ2luID0gdGhpcy5nZXROb3RlSGVhZEJlZ2luWCgpO1xuICAgICAgcmV0dXJuIHhfYmVnaW4gKyB0aGlzLmdseXBoLmhlYWRfd2lkdGggLSAoVmV4LkZsb3cuU1RFTV9XSURUSCAvIDIpO1xuICAgIH0sXG5cbiAgICAvLyBEcmF3IHRoZSBsZWRnZXIgbGluZXMgYmV0d2VlbiB0aGUgc3RhdmUgYW5kIHRoZSBoaWdoZXN0L2xvd2VzdCBrZXlzXG4gICAgZHJhd0xlZGdlckxpbmVzOiBmdW5jdGlvbigpe1xuICAgICAgaWYgKHRoaXMuaXNSZXN0KCkpIHsgcmV0dXJuOyB9XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHdpdGhvdXQgYSBjYW52YXMgY29udGV4dC5cIik7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXROb3RlSGVhZEJvdW5kcygpO1xuICAgICAgdmFyIGhpZ2hlc3RfbGluZSA9IGJvdW5kcy5oaWdoZXN0X2xpbmU7XG4gICAgICB2YXIgbG93ZXN0X2xpbmUgPSBib3VuZHMubG93ZXN0X2xpbmU7XG4gICAgICB2YXIgaGVhZF94ID0gdGhpcy5ub3RlX2hlYWRzWzBdLmdldEFic29sdXRlWCgpO1xuXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBzdHJva2UoeSkge1xuICAgICAgICBpZiAodGhhdC51c2VfZGVmYXVsdF9oZWFkX3ggPT09IHRydWUpICB7XG4gICAgICAgICAgaGVhZF94ID0gdGhhdC5nZXRBYnNvbHV0ZVgoKSArIHRoYXQueF9zaGlmdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IGhlYWRfeCAtIHRoYXQucmVuZGVyX29wdGlvbnMuc3Ryb2tlX3B4O1xuICAgICAgICB2YXIgbGVuZ3RoID0gKChoZWFkX3ggKyB0aGF0LmdseXBoLmhlYWRfd2lkdGgpIC0gaGVhZF94KSArXG4gICAgICAgICAgKHRoYXQucmVuZGVyX29wdGlvbnMuc3Ryb2tlX3B4ICogMik7XG5cbiAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHksIGxlbmd0aCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lOyAvLyBpdGVyYXRvclxuICAgICAgZm9yIChsaW5lID0gNjsgbGluZSA8PSBoaWdoZXN0X2xpbmU7ICsrbGluZSkge1xuICAgICAgICBzdHJva2UodGhpcy5zdGF2ZS5nZXRZRm9yTm90ZShsaW5lKSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGluZSA9IDA7IGxpbmUgPj0gbG93ZXN0X2xpbmU7IC0tbGluZSkge1xuICAgICAgICBzdHJva2UodGhpcy5zdGF2ZS5nZXRZRm9yTm90ZShsaW5lKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIERyYXcgYWxsIGtleSBtb2RpZmllcnNcbiAgICBkcmF3TW9kaWZpZXJzOiBmdW5jdGlvbigpe1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ2FudmFzQ29udGV4dFwiLFxuICAgICAgICAgIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgY2FudmFzIGNvbnRleHQuXCIpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIGN0eC5vcGVuR3JvdXAoXCJtb2RpZmllcnNcIik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtb2QgPSB0aGlzLm1vZGlmaWVyc1tpXTtcbiAgICAgICAgdmFyIG5vdGVfaGVhZCA9IHRoaXMubm90ZV9oZWFkc1ttb2QuZ2V0SW5kZXgoKV07XG4gICAgICAgIHZhciBrZXlfc3R5bGUgPSBub3RlX2hlYWQuZ2V0U3R5bGUoKTtcbiAgICAgICAgaWYoa2V5X3N0eWxlKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgbm90ZV9oZWFkLmFwcGx5U3R5bGUoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBtb2Quc2V0Q29udGV4dChjdHgpO1xuICAgICAgICBtb2QuZHJhdygpO1xuICAgICAgICBpZihrZXlfc3R5bGUpIHtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5jbG9zZUdyb3VwKCk7XG4gICAgfSxcblxuICAgIC8vIERyYXcgdGhlIGZsYWcgZm9yIHRoZSBub3RlXG4gICAgZHJhd0ZsYWc6IGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHdpdGhvdXQgYSBjYW52YXMgY29udGV4dC5cIik7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaCgpO1xuICAgICAgdmFyIHJlbmRlcl9mbGFnID0gdGhpcy5iZWFtID09PSBudWxsO1xuICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Tm90ZUhlYWRCb3VuZHMoKTtcblxuICAgICAgdmFyIHhfYmVnaW4gPSB0aGlzLmdldE5vdGVIZWFkQmVnaW5YKCk7XG4gICAgICB2YXIgeF9lbmQgPSB0aGlzLmdldE5vdGVIZWFkRW5kWCgpO1xuXG4gICAgICBpZiAoZ2x5cGguZmxhZyAmJiByZW5kZXJfZmxhZykge1xuICAgICAgICB2YXIgbm90ZV9zdGVtX2hlaWdodCA9IHRoaXMuc3RlbS5nZXRIZWlnaHQoKTtcbiAgICAgICAgdmFyIGZsYWdfeCwgZmxhZ195LCBmbGFnX2NvZGU7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0U3RlbURpcmVjdGlvbigpID09PSBTdGVtLkRPV04pIHtcbiAgICAgICAgICAvLyBEb3duIHN0ZW1zIGhhdmUgZmxhZ3Mgb24gdGhlIGxlZnQuXG4gICAgICAgICAgZmxhZ194ID0geF9iZWdpbiArIDE7XG4gICAgICAgICAgZmxhZ195ID0gYm91bmRzLnlfdG9wIC0gbm90ZV9zdGVtX2hlaWdodCArIDI7XG4gICAgICAgICAgZmxhZ19jb2RlID0gZ2x5cGguY29kZV9mbGFnX2Rvd25zdGVtO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVXAgc3RlbXMgaGF2ZSBmbGFncyBvbiB0aGUgbGVmdC5cbiAgICAgICAgICBmbGFnX3ggPSB4X2VuZCArIDE7XG4gICAgICAgICAgZmxhZ195ID0gYm91bmRzLnlfYm90dG9tIC0gbm90ZV9zdGVtX2hlaWdodCAtIDI7XG4gICAgICAgICAgZmxhZ19jb2RlID0gZ2x5cGguY29kZV9mbGFnX3Vwc3RlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgdGhlIEZsYWdcbiAgICAgICAgdGhpcy5jb250ZXh0Lm9wZW5Hcm91cChcImZsYWdcIiwgbnVsbCwge3BvaW50ZXJCQm94OiB0cnVlfSk7XG4gICAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKGN0eCwgZmxhZ194LCBmbGFnX3ksXG4gICAgICAgICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLmdseXBoX2ZvbnRfc2NhbGUsIGZsYWdfY29kZSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5jbG9zZUdyb3VwKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIERyYXcgdGhlIE5vdGVIZWFkc1xuICAgIGRyYXdOb3RlSGVhZHM6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGlzLm5vdGVfaGVhZHMuZm9yRWFjaChmdW5jdGlvbihub3RlX2hlYWQpIHtcbiAgICAgICAgdGhhdC5jb250ZXh0Lm9wZW5Hcm91cChcIm5vdGVoZWFkXCIsIG51bGwsIHtwb2ludGVyQkJveDogdHJ1ZX0pO1xuICAgICAgICBub3RlX2hlYWQuc2V0Q29udGV4dCh0aGF0LmNvbnRleHQpLmRyYXcoKTtcbiAgICAgICAgdGhhdC5jb250ZXh0LmNsb3NlR3JvdXAoKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBSZW5kZXIgdGhlIHN0ZW0gb250byB0aGUgY2FudmFzXG4gICAgZHJhd1N0ZW06IGZ1bmN0aW9uKHN0ZW1fc3RydWN0KXtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgd2l0aG91dCBhIGNhbnZhcyBjb250ZXh0LlwiKTtcblxuICAgICAgaWYgKHN0ZW1fc3RydWN0KSB7XG4gICAgICAgIHRoaXMuc2V0U3RlbShuZXcgU3RlbShzdGVtX3N0cnVjdCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQub3Blbkdyb3VwKFwic3RlbVwiLCBudWxsLCB7cG9pbnRlckJCb3g6IHRydWV9KTtcbiAgICAgIHRoaXMuc3RlbS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCkuZHJhdygpO1xuICAgICAgdGhpcy5jb250ZXh0LmNsb3NlR3JvdXAoKTtcbiAgICB9LFxuXG4gICAgLy8gRHJhd3MgYWxsIHRoZSBgU3RhdmVOb3RlYCBwYXJ0cy4gVGhpcyBpcyB0aGUgbWFpbiBkcmF3aW5nIG1ldGhvZC5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgd2l0aG91dCBhIGNhbnZhcyBjb250ZXh0LlwiKTtcbiAgICAgIGlmICghdGhpcy5zdGF2ZSkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9TdGF2ZVwiLFxuICAgICAgICAgIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgc3RhdmUuXCIpO1xuICAgICAgaWYgKHRoaXMueXMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1lWYWx1ZXNcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgbm90ZSB3aXRob3V0IFkgdmFsdWVzLlwiKTtcblxuICAgICAgdmFyIHhfYmVnaW4gPSB0aGlzLmdldE5vdGVIZWFkQmVnaW5YKCk7XG4gICAgICB2YXIgeF9lbmQgPSB0aGlzLmdldE5vdGVIZWFkRW5kWCgpO1xuXG4gICAgICB2YXIgcmVuZGVyX3N0ZW0gPSB0aGlzLmhhc1N0ZW0oKSAmJiAhdGhpcy5iZWFtO1xuXG4gICAgICAvLyBGb3JtYXQgbm90ZSBoZWFkIHggcG9zaXRpb25zXG4gICAgICB0aGlzLm5vdGVfaGVhZHMuZm9yRWFjaChmdW5jdGlvbihub3RlX2hlYWQpIHtcbiAgICAgICAgbm90ZV9oZWFkLnNldFgoeF9iZWdpbik7XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgLy8gRm9ybWF0IHN0ZW0geCBwb3NpdGlvbnNcbiAgICAgIHRoaXMuc3RlbS5zZXROb3RlSGVhZFhCb3VuZHMoeF9iZWdpbiwgeF9lbmQpO1xuXG4gICAgICBMKFwiUmVuZGVyaW5nIFwiLCB0aGlzLmlzQ2hvcmQoKSA/IFwiY2hvcmQgOlwiIDogXCJub3RlIDpcIiwgdGhpcy5rZXlzKTtcblxuICAgICAgLy8gRHJhdyBlYWNoIHBhcnQgb2YgdGhlIG5vdGVcbiAgICAgIHRoaXMuZHJhd0xlZGdlckxpbmVzKCk7XG5cbiAgICAgIHRoaXMuZWxlbSA9IHRoaXMuY29udGV4dC5vcGVuR3JvdXAoXCJzdGF2ZW5vdGVcIiwgdGhpcy5pZCk7XG4gICAgICB0aGlzLmNvbnRleHQub3Blbkdyb3VwKFwibm90ZVwiLCBudWxsLCB7cG9pbnRlckJCb3g6IHRydWV9KTtcbiAgICAgICAgaWYgKHJlbmRlcl9zdGVtKSB0aGlzLmRyYXdTdGVtKCk7XG4gICAgICAgIHRoaXMuZHJhd05vdGVIZWFkcygpO1xuICAgICAgICB0aGlzLmRyYXdGbGFnKCk7XG4gICAgICB0aGlzLmNvbnRleHQuY2xvc2VHcm91cCgpO1xuICAgICAgdGhpcy5kcmF3TW9kaWZpZXJzKCk7XG4gICAgICB0aGlzLmNvbnRleHQuY2xvc2VHcm91cCgpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFN0YXZlTm90ZTtcbn0oKSk7XG5cbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhlIGZpbGUgaW1wbGVtZW50cyBub3RlcyBmb3IgVGFibGF0dXJlIG5vdGF0aW9uLiBUaGlzIGNvbnNpc3RzIG9mIG9uZSBvclxuLy8gbW9yZSBmcmV0IHBvc2l0aW9ucywgYW5kIGNhbiBlaXRoZXIgYmUgZHJhd24gd2l0aCBvciB3aXRob3V0IHN0ZW1zLlxuLy9cbi8vIFNlZSBgdGVzdHMvdGFibm90ZV90ZXN0cy5qc2AgZm9yIHVzYWdlIGV4YW1wbGVzXG5WZXguRmxvdy5UYWJOb3RlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUYWJOb3RlKHRhYl9zdHJ1Y3QsIGRyYXdfc3RlbSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHRhYl9zdHJ1Y3QsIGRyYXdfc3RlbSk7XG4gIH1cblxuICB2YXIgU3RlbSA9IFZleC5GbG93LlN0ZW07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgVmV4LkluaGVyaXQoVGFiTm90ZSwgVmV4LkZsb3cuU3RlbW1hYmxlTm90ZSwge1xuICAgIC8vIEluaXRpYWxpemUgdGhlIFRhYk5vdGUgd2l0aCBhIGB0YWJfc3RydWN0YCBmdWxsIG9mIHByb3BlcnRpZXNcbiAgICAvLyBhbmQgd2hldGhlciB0byBgZHJhd19zdGVtYCB3aGVuIHJlbmRlcmluZyB0aGUgbm90ZVxuICAgIGluaXQ6IGZ1bmN0aW9uKHRhYl9zdHJ1Y3QsIGRyYXdfc3RlbSkge1xuICAgICAgdmFyIHN1cGVyY2xhc3MgPSBWZXguRmxvdy5UYWJOb3RlLnN1cGVyY2xhc3M7XG4gICAgICBzdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCB0YWJfc3RydWN0KTtcblxuICAgICAgdGhpcy5naG9zdCA9IGZhbHNlOyAvLyBSZW5kZXJzIHBhcmVudGhlc2lzIGFyb3VuZCBub3Rlc1xuICAgICAgLy8gTm90ZSBwcm9wZXJ0aWVzXG4gICAgICAvL1xuICAgICAgLy8gVGhlIGZyZXQgcG9zaXRpb25zIGluIHRoZSBub3RlLiBBbiBhcnJheSBvZiBgeyBzdHI6IFgsIGZyZXQ6IFggfWBcbiAgICAgIHRoaXMucG9zaXRpb25zID0gdGFiX3N0cnVjdC5wb3NpdGlvbnM7XG5cbiAgICAgIC8vIFJlbmRlciBPcHRpb25zXG4gICAgICBWZXguTWVyZ2UodGhpcy5yZW5kZXJfb3B0aW9ucywge1xuICAgICAgICAvLyBmb250IHNpemUgZm9yIG5vdGUgaGVhZHMgYW5kIHJlc3RzXG4gICAgICAgIGdseXBoX2ZvbnRfc2NhbGU6IDMwLFxuICAgICAgICAvLyBGbGFnIHRvIGRyYXcgYSBzdGVtXG4gICAgICAgIGRyYXdfc3RlbTogZHJhd19zdGVtLFxuICAgICAgICAvLyBGbGFnIHRvIGRyYXcgZG90IG1vZGlmaWVyc1xuICAgICAgICBkcmF3X2RvdHM6IGRyYXdfc3RlbSxcbiAgICAgICAgLy8gRmxhZyB0byBleHRlbmQgdGhlIG1haW4gc3RlbSB0aHJvdWdoIHRoZSBzdGF2ZSBhbmQgZnJldCBwb3NpdGlvbnNcbiAgICAgICAgZHJhd19zdGVtX3Rocm91Z2hfc3RhdmU6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5nbHlwaCA9XG4gICAgICAgIFZleC5GbG93LmR1cmF0aW9uVG9HbHlwaCh0aGlzLmR1cmF0aW9uLCB0aGlzLm5vdGVUeXBlKTtcbiAgICAgIGlmICghdGhpcy5nbHlwaCkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLFxuICAgICAgICAgICAgXCJJbnZhbGlkIG5vdGUgaW5pdGlhbGl6YXRpb24gZGF0YSAoTm8gZ2x5cGggZm91bmQpOiBcIiArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0YWJfc3RydWN0KSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVpbGRTdGVtKCk7XG5cbiAgICAgIGlmICh0YWJfc3RydWN0LnN0ZW1fZGlyZWN0aW9uKXtcbiAgICAgICAgdGhpcy5zZXRTdGVtRGlyZWN0aW9uKHRhYl9zdHJ1Y3Quc3RlbV9kaXJlY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGVtRGlyZWN0aW9uKFN0ZW0uVVApO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW5kZXJzIHBhcmVudGhlc2lzIGFyb3VuZCBub3Rlc1xuICAgICAgdGhpcy5naG9zdCA9IGZhbHNlO1xuICAgICAgdGhpcy51cGRhdGVXaWR0aCgpO1xuICAgIH0sXG5cbiAgICAvLyBUaGUgTW9kaWZpZXJDb250ZXh0IGNhdGVnb3J5XG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJ0YWJub3Rlc1wiOyB9LFxuXG4gICAgLy8gU2V0IGFzIGdob3N0IGBUYWJOb3RlYCwgc3Vycm91bmRzIHRoZSBmcmV0IHBvc2l0aW9ucyB3aXRoIHBhcmVudGhlc2lzLlxuICAgIC8vIE9mdGVuIHVzZWQgZm9yIGluZGljYXRpbmcgZnJldHMgdGhhdCBhcmUgYmVpbmcgYmVudCB0b1xuICAgIHNldEdob3N0OiBmdW5jdGlvbihnaG9zdCkge1xuICAgICAgdGhpcy5naG9zdCA9IGdob3N0O1xuICAgICAgdGhpcy51cGRhdGVXaWR0aCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgbm90ZSBoYXMgYSBzdGVtXG4gICAgaGFzU3RlbTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnJlbmRlcl9vcHRpb25zLmRyYXdfc3RlbTsgfSxcblxuICAgIC8vIEdldCB0aGUgZGVmYXVsdCBzdGVtIGV4dGVuc2lvbiBmb3IgdGhlIG5vdGVcbiAgICBnZXRTdGVtRXh0ZW5zaW9uOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaCgpO1xuXG4gICAgICBpZiAodGhpcy5zdGVtX2V4dGVuc2lvbl9vdmVycmlkZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZW1fZXh0ZW5zaW9uX292ZXJyaWRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2x5cGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RlbURpcmVjdGlvbigpID09PSAxID8gZ2x5cGgudGFibm90ZV9zdGVtX3VwX2V4dGVuc2lvbiA6XG4gICAgICAgICAgZ2x5cGgudGFibm90ZV9zdGVtX2Rvd25fZXh0ZW5zaW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgZG90IHRvIHRoZSBub3RlXG4gICAgYWRkRG90OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkb3QgPSBuZXcgVmV4LkZsb3cuRG90KCk7XG4gICAgICB0aGlzLmRvdHMrKztcbiAgICAgIHJldHVybiB0aGlzLmFkZE1vZGlmaWVyKGRvdCwgMCk7XG4gICAgfSxcblxuICAgIC8vIENhbGN1bGF0ZSBhbmQgc3RvcmUgdGhlIHdpZHRoIG9mIHRoZSBub3RlXG4gICAgdXBkYXRlV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5nbHlwaHMgPSBbXTtcbiAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvc2l0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZnJldCA9IHRoaXMucG9zaXRpb25zW2ldLmZyZXQ7XG4gICAgICAgIGlmICh0aGlzLmdob3N0KSBmcmV0ID0gXCIoXCIgKyBmcmV0ICsgXCIpXCI7XG4gICAgICAgIHZhciBnbHlwaCA9IFZleC5GbG93LnRhYlRvR2x5cGgoZnJldCk7XG4gICAgICAgIHRoaXMuZ2x5cGhzLnB1c2goZ2x5cGgpO1xuICAgICAgICB0aGlzLndpZHRoID0gKGdseXBoLndpZHRoID4gdGhpcy53aWR0aCkgPyBnbHlwaC53aWR0aCA6IHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFNldCB0aGUgYHN0YXZlYCB0byB0aGUgbm90ZVxuICAgIHNldFN0YXZlOiBmdW5jdGlvbihzdGF2ZSkge1xuICAgICAgdmFyIHN1cGVyY2xhc3MgPSBWZXguRmxvdy5UYWJOb3RlLnN1cGVyY2xhc3M7XG4gICAgICBzdXBlcmNsYXNzLnNldFN0YXZlLmNhbGwodGhpcywgc3RhdmUpO1xuICAgICAgdGhpcy5jb250ZXh0ID0gc3RhdmUuY29udGV4dDtcbiAgICAgIHRoaXMud2lkdGggPSAwO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGZyZXQgbnVtYmVyIHdpZHRoIGJhc2VkIG9uIGZvbnQgdXNlZFxuICAgICAgdmFyIGk7XG4gICAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmdseXBocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciB0ZXh0ID0gXCJcIiArIHRoaXMuZ2x5cGhzW2ldLnRleHQ7XG4gICAgICAgICAgaWYgKHRleHQudG9VcHBlckNhc2UoKSAhPSBcIlhcIilcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2ldLndpZHRoID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgICAgIHRoaXMud2lkdGggPSAodGhpcy5nbHlwaHNbaV0ud2lkdGggPiB0aGlzLndpZHRoKSA/XG4gICAgICAgICAgICB0aGlzLmdseXBoc1tpXS53aWR0aCA6IHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHlzID0gW107XG5cbiAgICAgIC8vIFNldHVwIHkgY29vcmRpbmF0ZXMgZm9yIHNjb3JlLlxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucG9zaXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5wb3NpdGlvbnNbaV0uc3RyO1xuICAgICAgICB5cy5wdXNoKHRoaXMuc3RhdmUuZ2V0WUZvckxpbmUobGluZSAtIDEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc2V0WXMoeXMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGZyZXQgcG9zaXRpb25zIGZvciB0aGUgbm90ZVxuICAgIGdldFBvc2l0aW9uczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnBvc2l0aW9uczsgfSxcblxuICAgIC8vIEFkZCBzZWxmIHRvIHRoZSBwcm92aWRlZCBtb2RpZmllciBjb250ZXh0IGBtY2BcbiAgICBhZGRUb01vZGlmaWVyQ29udGV4dDogZnVuY3Rpb24obWMpIHtcbiAgICAgIHRoaXMuc2V0TW9kaWZpZXJDb250ZXh0KG1jKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tb2RpZmllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5tb2RpZmllckNvbnRleHQuYWRkTW9kaWZpZXIodGhpcy5tb2RpZmllcnNbaV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RpZmllckNvbnRleHQuYWRkTW9kaWZpZXIodGhpcyk7XG4gICAgICB0aGlzLnByZUZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgYHhgIGNvb3JkaW5hdGUgdG8gdGhlIHJpZ2h0IG9mIHRoZSBub3RlXG4gICAgZ2V0VGllUmlnaHRYOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aWVTdGFydFggPSB0aGlzLmdldEFic29sdXRlWCgpO1xuICAgICAgdmFyIG5vdGVfZ2x5cGhfd2lkdGggPSB0aGlzLmdseXBoLmhlYWRfd2lkdGg7XG4gICAgICB0aWVTdGFydFggKz0gKG5vdGVfZ2x5cGhfd2lkdGggLyAyKTtcbiAgICAgIHRpZVN0YXJ0WCArPSAoKC10aGlzLndpZHRoIC8gMikgKyB0aGlzLndpZHRoICsgMik7XG5cbiAgICAgIHJldHVybiB0aWVTdGFydFg7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgYHhgIGNvb3JkaW5hdGUgdG8gdGhlIGxlZnQgb2YgdGhlIG5vdGVcbiAgICBnZXRUaWVMZWZ0WDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGllRW5kWCA9IHRoaXMuZ2V0QWJzb2x1dGVYKCk7XG4gICAgICB2YXIgbm90ZV9nbHlwaF93aWR0aCA9IHRoaXMuZ2x5cGguaGVhZF93aWR0aDtcbiAgICAgIHRpZUVuZFggKz0gKG5vdGVfZ2x5cGhfd2lkdGggLyAyKTtcbiAgICAgIHRpZUVuZFggLT0gKCh0aGlzLndpZHRoIC8gMikgKyAyKTtcblxuICAgICAgcmV0dXJuIHRpZUVuZFg7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgZGVmYXVsdCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBmb3IgYSBtb2RpZmllciBhdCBhIHNwZWNpZmljXG4gICAgLy8gYHBvc2l0aW9uYCBhdCBhIGZyZXQgcG9zaXRpb24gYGluZGV4YFxuICAgIGdldE1vZGlmaWVyU3RhcnRYWTogZnVuY3Rpb24ocG9zaXRpb24sIGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMucHJlRm9ybWF0dGVkKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJVbmZvcm1hdHRlZE5vdGVcIixcbiAgICAgICAgICBcIkNhbid0IGNhbGwgR2V0TW9kaWZpZXJTdGFydFhZIG9uIGFuIHVuZm9ybWF0dGVkIG5vdGVcIik7XG5cbiAgICAgIGlmICh0aGlzLnlzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9ZVmFsdWVzXCIsXG4gICAgICAgICAgXCJObyBZLVZhbHVlcyBjYWxjdWxhdGVkIGZvciB0aGlzIG5vdGUuXCIpO1xuXG4gICAgICB2YXIgeCA9IDA7XG4gICAgICBpZiAocG9zaXRpb24gPT0gVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uTEVGVCkge1xuICAgICAgICB4ID0gLTEgKiAyOyAgLy8gZXh0cmFfbGVmdF9weFxuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PSBWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5SSUdIVCkge1xuICAgICAgICB4ID0gdGhpcy53aWR0aCArIDI7IC8vIGV4dHJhX3JpZ2h0X3B4XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLkJFTE9XIHx8XG4gICAgICAgICAgICAgICAgIHBvc2l0aW9uID09IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFKSB7XG4gICAgICAgICAgdmFyIG5vdGVfZ2x5cGhfd2lkdGggPSB0aGlzLmdseXBoLmhlYWRfd2lkdGg7XG4gICAgICAgICAgeCA9IG5vdGVfZ2x5cGhfd2lkdGggLyAyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge3g6IHRoaXMuZ2V0QWJzb2x1dGVYKCkgKyB4LCB5OiB0aGlzLnlzW2luZGV4XX07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgZGVmYXVsdCBsaW5lIGZvciByZXN0XG4gICAgZ2V0TGluZUZvclJlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5wb3NpdGlvbnNbMF0uc3RyOyB9LFxuXG4gICAgLy8gUHJlLXJlbmRlciBmb3JtYXR0aW5nXG4gICAgcHJlRm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnByZUZvcm1hdHRlZCkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMubW9kaWZpZXJDb250ZXh0KSB0aGlzLm1vZGlmaWVyQ29udGV4dC5wcmVGb3JtYXQoKTtcbiAgICAgIC8vIHdpZHRoIGlzIGFscmVhZHkgc2V0IGR1cmluZyBpbml0KClcbiAgICAgIHRoaXMuc2V0UHJlRm9ybWF0dGVkKHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHggcG9zaXRpb24gZm9yIHRoZSBzdGVtXG4gICAgZ2V0U3RlbVg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5nZXRDZW50ZXJHbHlwaFgoKTsgfSxcblxuICAgIC8vIEdldCB0aGUgeSBwb3NpdGlvbiBmb3IgdGhlIHN0ZW1cbiAgICBnZXRTdGVtWTogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBudW1fbGluZXMgPSB0aGlzLnN0YXZlLmdldE51bUxpbmVzKCk7XG5cbiAgICAgIC8vIFRoZSBkZWNpbWFsIHN0YWZmIGxpbmUgYW1vdW50cyBwcm92aWRlIG9wdGltYWwgc3BhY2luZyBiZXR3ZWVuIHRoZVxuICAgICAgLy8gZnJldCBudW1iZXIgYW5kIHRoZSBzdGVtXG4gICAgICB2YXIgc3RlbVVwTGluZSA9IC0wLjU7XG4gICAgICB2YXIgc3RlbURvd25MaW5lID0gbnVtX2xpbmVzIC0gMC41O1xuICAgICAgdmFyIHN0ZW1TdGFydExpbmUgPSBTdGVtLlVQID09PSB0aGlzLnN0ZW1fZGlyZWN0aW9uID8gc3RlbVVwTGluZSA6IHN0ZW1Eb3duTGluZTtcblxuICAgICAgcmV0dXJuIHRoaXMuc3RhdmUuZ2V0WUZvckxpbmUoc3RlbVN0YXJ0TGluZSk7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgc3RlbSBleHRlbnRzIGZvciB0aGUgdGFibm90ZVxuICAgIGdldFN0ZW1FeHRlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdGVtX2Jhc2VfeSA9IHRoaXMuZ2V0U3RlbVkoKTtcbiAgICAgIHZhciBzdGVtX3RvcF95ID0gc3RlbV9iYXNlX3kgKyAoU3RlbS5IRUlHSFQgKiAtdGhpcy5zdGVtX2RpcmVjdGlvbik7XG5cbiAgICAgIHJldHVybiB7IHRvcFk6IHN0ZW1fdG9wX3kgLCBiYXNlWTogc3RlbV9iYXNlX3l9O1xuICAgIH0sXG5cbiAgICAvLyBEcmF3IHRoZSBmYWwgb250byB0aGUgY29udGV4dFxuICAgIGRyYXdGbGFnOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZW5kZXJfc3RlbSA9IHRoaXMuYmVhbSA9PSBudWxsICYmIHRoaXMucmVuZGVyX29wdGlvbnMuZHJhd19zdGVtO1xuICAgICAgdmFyIHJlbmRlcl9mbGFnID0gdGhpcy5iZWFtID09IG51bGwgJiYgcmVuZGVyX3N0ZW07XG5cbiAgICAgIC8vIE5vdyBpdCdzIHRoZSBmbGFnJ3MgdHVybi5cbiAgICAgIGlmICh0aGlzLmdseXBoLmZsYWcgJiYgcmVuZGVyX2ZsYWcpIHtcbiAgICAgICAgdmFyIGZsYWdfeCA9IHRoaXMuZ2V0U3RlbVgoKSArIDEgO1xuICAgICAgICB2YXIgZmxhZ195ID0gdGhpcy5nZXRTdGVtWSgpIC0gKHRoaXMuc3RlbS5nZXRIZWlnaHQoKSk7XG4gICAgICAgIHZhciBmbGFnX2NvZGU7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RlbV9kaXJlY3Rpb24gPT0gU3RlbS5ET1dOKSB7XG4gICAgICAgICAgLy8gRG93biBzdGVtcyBoYXZlIGZsYWdzIG9uIHRoZSBsZWZ0LlxuICAgICAgICAgIGZsYWdfY29kZSA9IHRoaXMuZ2x5cGguY29kZV9mbGFnX2Rvd25zdGVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVwIHN0ZW1zIGhhdmUgZmxhZ3Mgb24gdGhlIGxlZnQuXG4gICAgICAgICAgZmxhZ19jb2RlID0gdGhpcy5nbHlwaC5jb2RlX2ZsYWdfdXBzdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgRmxhZ1xuICAgICAgICBWZXguRmxvdy5yZW5kZXJHbHlwaCh0aGlzLmNvbnRleHQsIGZsYWdfeCwgZmxhZ195LFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5nbHlwaF9mb250X3NjYWxlLCBmbGFnX2NvZGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBSZW5kZXIgdGhlIG1vZGlmaWVycyBvbnRvIHRoZSBjb250ZXh0XG4gICAgZHJhd01vZGlmaWVyczogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEcmF3IHRoZSBtb2RpZmllcnNcbiAgICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24obW9kaWZpZXIpIHtcbiAgICAgICAgLy8gT25seSBkcmF3IHRoZSBkb3RzIGlmIGVuYWJsZWRcbiAgICAgICAgaWYgKG1vZGlmaWVyLmdldENhdGVnb3J5KCkgPT09ICdkb3RzJyAmJiAhdGhpcy5yZW5kZXJfb3B0aW9ucy5kcmF3X2RvdHMpIHJldHVybjtcblxuICAgICAgICBtb2RpZmllci5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIG1vZGlmaWVyLmRyYXcoKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBSZW5kZXIgdGhlIHN0ZW0gZXh0ZW5zaW9uIHRocm91Z2ggdGhlIGZyZXQgcG9zaXRpb25zXG4gICAgZHJhd1N0ZW1UaHJvdWdoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdGVtX3ggPSB0aGlzLmdldFN0ZW1YKCk7XG4gICAgICB2YXIgc3RlbV95ID0gdGhpcy5nZXRTdGVtWSgpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdmFyIHN0ZW1fdGhyb3VnaCA9IHRoaXMucmVuZGVyX29wdGlvbnMuZHJhd19zdGVtX3Rocm91Z2hfc3RhdmU7XG4gICAgICB2YXIgZHJhd19zdGVtID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5kcmF3X3N0ZW07XG4gICAgICBpZiAoZHJhd19zdGVtICYmIHN0ZW1fdGhyb3VnaCkge1xuICAgICAgICB2YXIgdG90YWxfbGluZXMgPSB0aGlzLnN0YXZlLmdldE51bUxpbmVzKCk7XG4gICAgICAgIHZhciBzdHJpbmdzX3VzZWQgPSB0aGlzLnBvc2l0aW9ucy5tYXAoZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gcG9zaXRpb24uc3RyO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdW51c2VkX3N0cmluZ3MgPSBnZXRVbnVzZWRTdHJpbmdHcm91cHModG90YWxfbGluZXMsIHN0cmluZ3NfdXNlZCk7XG4gICAgICAgIHZhciBzdGVtX2xpbmVzID0gZ2V0UGFydGlhbFN0ZW1MaW5lcyhzdGVtX3ksIHVudXNlZF9zdHJpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRTdGF2ZSgpLCB0aGlzLmdldFN0ZW1EaXJlY3Rpb24oKSk7XG5cbiAgICAgICAgLy8gRmluZSB0dW5lIHggcG9zaXRpb24gdG8gbWF0Y2ggZGVmYXVsdCBzdGVtXG4gICAgICAgIGlmICghdGhpcy5iZWFtIHx8IHRoaXMuZ2V0U3RlbURpcmVjdGlvbigpID09PSAxKSB7XG4gICAgICAgICAgc3RlbV94ICs9IChTdGVtLldJRFRIIC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc2V0TGluZVdpZHRoKFN0ZW0uV0lEVEgpO1xuICAgICAgICBzdGVtX2xpbmVzLmZvckVhY2goZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgICAgICAgaWYgKGJvdW5kcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKHN0ZW1feCwgYm91bmRzWzBdKTtcbiAgICAgICAgICBjdHgubGluZVRvKHN0ZW1feCwgYm91bmRzW2JvdW5kcy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFJlbmRlciB0aGUgZnJldCBwb3NpdGlvbnMgb250byB0aGUgY29udGV4dFxuICAgIGRyYXdQb3NpdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciB4ID0gdGhpcy5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgIHZhciB5cyA9IHRoaXMueXM7XG4gICAgICB2YXIgeTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvc2l0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB5ID0geXNbaV07XG5cbiAgICAgICAgdmFyIGdseXBoID0gdGhpcy5nbHlwaHNbaV07XG5cbiAgICAgICAgLy8gQ2VudGVyIHRoZSBmcmV0IHRleHQgYmVuZWF0aCB0aGUgbm90YXRpb24gbm90ZSBoZWFkXG4gICAgICAgIHZhciBub3RlX2dseXBoX3dpZHRoID0gdGhpcy5nbHlwaC5oZWFkX3dpZHRoO1xuICAgICAgICB2YXIgdGFiX3ggPSB4ICsgKG5vdGVfZ2x5cGhfd2lkdGggLyAyKSAtIChnbHlwaC53aWR0aCAvIDIpO1xuXG4gICAgICAgIGN0eC5jbGVhclJlY3QodGFiX3ggLSAyLCB5IC0gMywgZ2x5cGgud2lkdGggKyA0LCA2KTtcblxuICAgICAgICBpZiAoZ2x5cGguY29kZSkge1xuICAgICAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKGN0eCwgdGFiX3gsIHkgKyA1ICsgZ2x5cGguc2hpZnRfeSxcbiAgICAgICAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5nbHlwaF9mb250X3NjYWxlLCBnbHlwaC5jb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGdseXBoLnRleHQudG9TdHJpbmcoKTtcbiAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgdGFiX3gsIHkgKyA1KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBUaGUgbWFpbiByZW5kZXJpbmcgZnVuY3Rpb24gZm9yIHRoZSBlbnRpcmUgbm90ZVxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ2FudmFzQ29udGV4dFwiLFxuICAgICAgICAgIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgY2FudmFzIGNvbnRleHQuXCIpO1xuICAgICAgaWYgKCF0aGlzLnN0YXZlKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1N0YXZlXCIsIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgc3RhdmUuXCIpO1xuICAgICAgaWYgKHRoaXMueXMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1lWYWx1ZXNcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgbm90ZSB3aXRob3V0IFkgdmFsdWVzLlwiKTtcblxuICAgICAgdmFyIHJlbmRlcl9zdGVtID0gdGhpcy5iZWFtID09IG51bGwgJiYgdGhpcy5yZW5kZXJfb3B0aW9ucy5kcmF3X3N0ZW07XG5cbiAgICAgIHRoaXMuZHJhd1Bvc2l0aW9ucygpO1xuICAgICAgdGhpcy5kcmF3U3RlbVRocm91Z2goKTtcblxuICAgICAgdmFyIHN0ZW1feCA9IHRoaXMuZ2V0U3RlbVgoKTtcbiAgICAgIHZhciBzdGVtX3kgPSB0aGlzLmdldFN0ZW1ZKCk7XG4gICAgICBpZiAocmVuZGVyX3N0ZW0pIHtcbiAgICAgICAgdGhpcy5kcmF3U3RlbSh7XG4gICAgICAgICAgeF9iZWdpbjogc3RlbV94LFxuICAgICAgICAgIHhfZW5kOiBzdGVtX3gsXG4gICAgICAgICAgeV90b3A6IHN0ZW1feSxcbiAgICAgICAgICB5X2JvdHRvbTogc3RlbV95LFxuICAgICAgICAgIHlfZXh0ZW5kOiAwLFxuICAgICAgICAgIHN0ZW1fZXh0ZW5zaW9uOiB0aGlzLmdldFN0ZW1FeHRlbnNpb24oKSxcbiAgICAgICAgICBzdGVtX2RpcmVjdGlvbjogdGhpcy5zdGVtX2RpcmVjdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kcmF3RmxhZygpO1xuICAgICAgdGhpcy5kcmF3TW9kaWZpZXJzKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyAjIyBQcml2YXRlIEhlbHBlcnNcbiAgLy9cbiAgLy8gR2V0cyB0aGUgdW51c2VkIHN0cmluZ3MgZ3JvdXBlZCB0b2dldGhlciBpZiBjb25zZWN1dGl2ZS5cbiAgLy9cbiAgLy8gUGFyYW1ldGVyczpcbiAgLy8gKiBudW1fbGluZXMgLSBUaGUgbnVtYmVyIG9mIGxpbmVzXG4gIC8vICogc3RyaW5nc191c2VkIC0gQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgd2hpY2ggc3RyaW5ncyBoYXZlIGZyZXQgcG9zaXRpb25zXG4gIGZ1bmN0aW9uIGdldFVudXNlZFN0cmluZ0dyb3VwcyhudW1fbGluZXMsIHN0cmluZ3NfdXNlZCkge1xuICAgIHZhciBzdGVtX3Rocm91Z2ggPSBbXTtcbiAgICB2YXIgZ3JvdXAgPSBbXTtcbiAgICBmb3IgKHZhciBzdHJpbmcgPSAxOyBzdHJpbmcgPD0gbnVtX2xpbmVzIDsgc3RyaW5nKyspIHtcbiAgICAgIHZhciBpc191c2VkID0gc3RyaW5nc191c2VkLmluZGV4T2Yoc3RyaW5nKSA+IC0xO1xuXG4gICAgICBpZiAoIWlzX3VzZWQpIHtcbiAgICAgICAgZ3JvdXAucHVzaChzdHJpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlbV90aHJvdWdoLnB1c2goZ3JvdXApO1xuICAgICAgICBncm91cCA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMCkgc3RlbV90aHJvdWdoLnB1c2goZ3JvdXApO1xuXG4gICAgcmV0dXJuIHN0ZW1fdGhyb3VnaDtcbiAgfVxuXG4gIC8vIEdldHMgZ3JvdXBzIG9mIHBvaW50cyB0aGF0IG91dGxpbmUgdGhlIHBhcnRpYWwgc3RlbSBsaW5lc1xuICAvLyBiZXR3ZWVuIGZyZXQgcG9zaXRpb25zXG4gIC8vXG4gIC8vIFBhcmFtZXRlcnM6XG4gIC8vICogc3RlbV9ZIC0gVGhlIGB5YCBjb29yZGluYXRlIHRoZSBzdGVtIGlzIGxvY2F0ZWQgb25cbiAgLy8gKiB1bnVzZWRfc3RyaW5ncyAtIEFuIGFycmF5IG9mIGdyb3VwcyBvZiB1bnVzZWQgc3RyaW5nc1xuICAvLyAqIHN0YXZlIC0gVGhlIHN0YXZlIHRvIHVzZSBmb3IgcmVmZXJlbmNlXG4gIC8vICogc3RlbV9kaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIG9mIHRoZSBzdGVtXG4gIGZ1bmN0aW9uIGdldFBhcnRpYWxTdGVtTGluZXMgKHN0ZW1feSwgdW51c2VkX3N0cmluZ3MsIHN0YXZlLCBzdGVtX2RpcmVjdGlvbikge1xuICAgIHZhciB1cF9zdGVtID0gc3RlbV9kaXJlY3Rpb24gIT09IDE7XG4gICAgdmFyIGRvd25fc3RlbSA9IHN0ZW1fZGlyZWN0aW9uICE9PSAtMTtcblxuICAgIHZhciBsaW5lX3NwYWNpbmcgPSBzdGF2ZS5nZXRTcGFjaW5nQmV0d2VlbkxpbmVzKCk7XG4gICAgdmFyIHRvdGFsX2xpbmVzID0gc3RhdmUuZ2V0TnVtTGluZXMoKTtcblxuICAgIHZhciBzdGVtX2xpbmVzID0gW107XG5cbiAgICB1bnVzZWRfc3RyaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKHN0cmluZ3MpIHtcbiAgICAgIHZhciBjb250YWluc0xhc3RTdHJpbmcgPSBzdHJpbmdzLmluZGV4T2YodG90YWxfbGluZXMpID4gLTE7XG4gICAgICB2YXIgY29udGFpbnNGaXJzdFN0cmluZyA9ICBzdHJpbmdzLmluZGV4T2YoMSkgPiAtMTtcblxuICAgICAgaWYgKCh1cF9zdGVtICYmIGNvbnRhaW5zRmlyc3RTdHJpbmcpIHx8XG4gICAgICAgICAoZG93bl9zdGVtICYmIGNvbnRhaW5zTGFzdFN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIG9ubHkgb25lIHN0cmluZyBpbiB0aGUgZ3JvdXAsIHB1c2ggYSBkdXBsaWNhdGUgdmFsdWUuXG4gICAgICAvLyBXZSBkbyB0aGlzIGJlY2F1c2Ugd2UgbmVlZCAyIHN0cmluZ3MgdG8gY29udmVydCBpbnRvIHVwcGVyL2xvd2VyIHlcbiAgICAgIC8vIHZhbHVlcy5cbiAgICAgIGlmIChzdHJpbmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdHJpbmdzLnB1c2goc3RyaW5nc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lX3lzID0gW107XG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBncm91cCBzdHJpbmcgYW5kIHN0b3JlIGl0J3MgeSBwb3NpdGlvblxuICAgICAgc3RyaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKHN0cmluZywgaW5kZXgsIHN0cmluZ3MpIHtcbiAgICAgICAgdmFyIGlzVG9wQm91bmQgPSBzdHJpbmcgPT09IDE7XG4gICAgICAgIHZhciBpc0JvdHRvbUJvdW5kID0gc3RyaW5nID09PSB0b3RhbF9saW5lcztcblxuICAgICAgICAvLyBHZXQgdGhlIHkgdmFsdWUgZm9yIHRoZSBhcHByb3ByaWF0ZSBzdGFmZiBsaW5lLFxuICAgICAgICAvLyB3ZSBhZGp1c3QgZm9yIGEgMCBpbmRleCBhcnJheSwgc2luY2Ugc3RyaW5nIG51bWJlcnMgYXJlIGluZGV4IDFcbiAgICAgICAgdmFyIHkgPSBzdGF2ZS5nZXRZRm9yTGluZShzdHJpbmcgLSAxKTtcblxuICAgICAgICAvLyBVbmxlc3MgdGhlIHN0cmluZyBpcyB0aGUgZmlyc3Qgb3IgbGFzdCwgYWRkIHBhZGRpbmcgdG8gZWFjaCBzaWRlXG4gICAgICAgIC8vIG9mIHRoZSBsaW5lXG4gICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiAhaXNUb3BCb3VuZCkge1xuICAgICAgICAgIHkgLT0gbGluZV9zcGFjaW5nLzIgLSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBzdHJpbmdzLmxlbmd0aCAtIDEgJiYgIWlzQm90dG9tQm91bmQpe1xuICAgICAgICAgIHkgKz0gbGluZV9zcGFjaW5nLzIgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIHkgdmFsdWVcbiAgICAgICAgbGluZV95cy5wdXNoKHkpO1xuXG4gICAgICAgIC8vIFN0b3JlIGEgc3Vic2VxdWVudCB5IHZhbHVlIGNvbm5lY3RpbmcgdGhpcyBncm91cCB0byB0aGUgbWFpblxuICAgICAgICAvLyBzdGVtIGFib3ZlL2JlbG93IHRoZSBzdGF2ZSBpZiBpdCdzIHRoZSB0b3AvYm90dG9tIHN0cmluZ1xuICAgICAgICBpZiAoc3RlbV9kaXJlY3Rpb24gPT09IDEgJiYgaXNUb3BCb3VuZCkge1xuICAgICAgICAgIGxpbmVfeXMucHVzaChzdGVtX3kgLSAyKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGVtX2RpcmVjdGlvbiA9PT0gLTEgJiYgaXNCb3R0b21Cb3VuZCkge1xuICAgICAgICAgIGxpbmVfeXMucHVzaChzdGVtX3kgKyAyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCB0aGUgc29ydGVkIHkgdmFsdWVzIHRvIHRoZVxuICAgICAgc3RlbV9saW5lcy5wdXNoKGxpbmVfeXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH0pKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzdGVtX2xpbmVzO1xuICB9XG5cbiAgcmV0dXJuIFRhYk5vdGU7XG59KCkpO1xuXG4vLyBWZXggRmxvdyBOb3RhdGlvblxuLy8gTW9oaXQgTXV0aGFubmEgPG1vaGl0QG11dGhhbm5hLmNvbT5cbi8vXG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFJlcXVpcmVzIHZleC5qcy5cblxuLyoqIEBjb25zdHJ1Y3RvciAqL1xuVmV4LkZsb3cuR2hvc3ROb3RlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBHaG9zdE5vdGUoZHVyYXRpb24pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChkdXJhdGlvbik7XG4gIH1cblxuICBWZXguSW5oZXJpdChHaG9zdE5vdGUsIFZleC5GbG93LlN0ZW1tYWJsZU5vdGUsIHtcbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbWV0ZXIpIHtcbiAgICAgIC8vIFNhbml0eSBjaGVja1xuICAgICAgaWYgKCFwYXJhbWV0ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgIFwiR2hvc3Qgbm90ZSBtdXN0IGhhdmUgdmFsaWQgaW5pdGlhbGl6YXRpb24gZGF0YSB0byBpZGVudGlmeSBcIiArXG4gICAgICAgICAgICBcImR1cmF0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vdGVfc3RydWN0O1xuXG4gICAgICAvLyBQcmVzZXJ2ZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxuICAgICAgaWYgKHR5cGVvZihwYXJhbWV0ZXIpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5vdGVfc3RydWN0ID0geyBkdXJhdGlvbjogcGFyYW1ldGVyIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZihwYXJhbWV0ZXIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG5vdGVfc3RydWN0ID0gcGFyYW1ldGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgIFwiR2hvc3Qgbm90ZSBtdXN0IGhhdmUgdmFsaWQgaW5pdGlhbGl6YXRpb24gZGF0YSB0byBpZGVudGlmeSBcIiArXG4gICAgICAgICAgICBcImR1cmF0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgR2hvc3ROb3RlLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIG5vdGVfc3RydWN0KTtcblxuICAgICAgLy8gTm90ZSBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLnNldFdpZHRoKDApO1xuICAgIH0sXG5cbiAgICBpc1Jlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSxcblxuICAgIHNldFN0YXZlOiBmdW5jdGlvbihzdGF2ZSkgeyBHaG9zdE5vdGUuc3VwZXJjbGFzcy5zZXRTdGF2ZS5jYWxsKHRoaXMsIHN0YXZlKTsgfSxcblxuICAgIGFkZFRvTW9kaWZpZXJDb250ZXh0OiBmdW5jdGlvbigpXG4gICAgICB7IC8qIGludGVudGlvbmFsbHkgb3ZlcnJpZGRlbiAqLyByZXR1cm4gdGhpczsgfSxcblxuICAgIHByZUZvcm1hdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldFByZUZvcm1hdHRlZCh0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5zdGF2ZSkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9TdGF2ZVwiLCBcIkNhbid0IGRyYXcgd2l0aG91dCBhIHN0YXZlLlwiKTtcblxuICAgICAgLy8gRHJhdyB0aGUgbW9kaWZpZXJzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubW9kaWZpZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtb2RpZmllciA9IHRoaXMubW9kaWZpZXJzW2ldO1xuICAgICAgICBtb2RpZmllci5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIG1vZGlmaWVyLmRyYXcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBHaG9zdE5vdGU7XG59KCkpO1xuXG4vLyBWZXggRmxvdyBOb3RhdGlvblxuLy8gQ29weXJpZ2h0IE1vaGl0IE11dGhhbm5hIDIwMTBcbi8vXG4vLyBBdXRob3IgVGFlaG9vbiBNb29uIDIwMTRcblxuLyoqIEBjb25zdHJ1Y3RvciAqL1xuVmV4LkZsb3cuQ2xlZk5vdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIENsZWZOb3RlKGNsZWYsIHNpemUsIGFubm90YXRpb24pIHsgdGhpcy5pbml0KGNsZWYsIHNpemUsIGFubm90YXRpb24pOyB9XG5cbiAgVmV4LkluaGVyaXQoQ2xlZk5vdGUsIFZleC5GbG93Lk5vdGUsIHtcbiAgICBpbml0OiBmdW5jdGlvbihjbGVmLCBzaXplLCBhbm5vdGF0aW9uKSB7XG4gICAgICBDbGVmTm90ZS5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCB7ZHVyYXRpb246IFwiYlwifSk7XG4gICAgICBcbiAgICAgIHRoaXMuc2V0Q2xlZihjbGVmLCBzaXplLCBhbm5vdGF0aW9uKTtcblxuICAgICAgLy8gTm90ZSBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLmlnbm9yZV90aWNrcyA9IHRydWU7XG4gICAgfSxcblxuICAgIHNldENsZWY6IGZ1bmN0aW9uKGNsZWYsIHNpemUsIGFubm90YXRpb24pIHtcbiAgICAgIHRoaXMuY2xlZl9vYmogPSBuZXcgVmV4LkZsb3cuQ2xlZihjbGVmLCBzaXplLCBhbm5vdGF0aW9uKTtcbiAgICAgIHRoaXMuY2xlZiA9IHRoaXMuY2xlZl9vYmouY2xlZjtcbiAgICAgIHRoaXMuZ2x5cGggPSBuZXcgVmV4LkZsb3cuR2x5cGgodGhpcy5jbGVmLmNvZGUsIHRoaXMuY2xlZi5wb2ludCk7XG4gICAgICB0aGlzLnNldFdpZHRoKHRoaXMuZ2x5cGguZ2V0TWV0cmljcygpLndpZHRoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRDbGVmOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsZWY7XG4gICAgfSxcblxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpe1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMuZ2x5cGguc2V0Q29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFN0YXZlOiBmdW5jdGlvbihzdGF2ZSkge1xuICAgICAgdmFyIHN1cGVyY2xhc3MgPSBWZXguRmxvdy5DbGVmTm90ZS5zdXBlcmNsYXNzO1xuICAgICAgc3VwZXJjbGFzcy5zZXRTdGF2ZS5jYWxsKHRoaXMsIHN0YXZlKTtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBWZXguRmxvdy5Cb3VuZGluZ0JveCgwLCAwLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgYWRkVG9Nb2RpZmllckNvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLyogb3ZlcnJpZGRlbiB0byBpZ25vcmUgKi9cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRDYXRlZ29yeTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJjbGVmbm90ZVwiO1xuICAgIH0sXG5cbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRQcmVGb3JtYXR0ZWQodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuc3RhdmUpIHRocm93IG5ldyBWZXguUkVSUihcIk5vU3RhdmVcIiwgXCJDYW4ndCBkcmF3IHdpdGhvdXQgYSBzdGF2ZS5cIik7XG4gICAgICBcbiAgICAgIGlmICghdGhpcy5nbHlwaC5nZXRDb250ZXh0KCkpIHtcbiAgICAgICAgdGhpcy5nbHlwaC5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICB9XG4gICAgICB2YXIgYWJzX3ggPSB0aGlzLmdldEFic29sdXRlWCgpO1xuXG4gICAgICB0aGlzLmdseXBoLnNldFN0YXZlKHRoaXMuc3RhdmUpO1xuICAgICAgdGhpcy5nbHlwaC5zZXRZU2hpZnQoXG4gICAgICAgIHRoaXMuc3RhdmUuZ2V0WUZvckxpbmUodGhpcy5jbGVmLmxpbmUpIC0gdGhpcy5zdGF2ZS5nZXRZRm9yR2x5cGhzKCkpO1xuICAgICAgdGhpcy5nbHlwaC5yZW5kZXJUb1N0YXZlKGFic194KTtcbiAgICAgIFxuICAgICAgLy8gSWYgdGhlIFZleC5GbG93LkNsZWYgaGFzIGFuIGFubm90YXRpb24sIHN1Y2ggYXMgOHZhLCBkcmF3IGl0LlxuICAgICAgaWYgKHRoaXMuY2xlZl9vYmouYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBhdHRhY2htZW50ID0gbmV3IFZleC5GbG93LkdseXBoKHRoaXMuY2xlZl9vYmouYW5ub3RhdGlvbi5jb2RlLCB0aGlzLmNsZWZfb2JqLmFubm90YXRpb24ucG9pbnQpO1xuICAgICAgICBpZiAoIWF0dGFjaG1lbnQuZ2V0Q29udGV4dCgpKSB7XG4gICAgICAgICAgICBhdHRhY2htZW50LnNldENvbnRleHQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBhdHRhY2htZW50LnNldFN0YXZlKHRoaXMuc3RhdmUpO1xuICAgICAgICBhdHRhY2htZW50LnNldFlTaGlmdChcbiAgICAgICAgICB0aGlzLnN0YXZlLmdldFlGb3JMaW5lKHRoaXMuY2xlZl9vYmouYW5ub3RhdGlvbi5saW5lKSAtIHRoaXMuc3RhdmUuZ2V0WUZvckdseXBocygpKTtcbiAgICAgICAgYXR0YWNobWVudC5zZXRYU2hpZnQodGhpcy5jbGVmX29iai5hbm5vdGF0aW9uLnhfc2hpZnQpO1xuICAgICAgICBhdHRhY2htZW50LnJlbmRlclRvU3RhdmUoYWJzX3gpO1xuICAgICAgfVxuICAgICAgXG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQ2xlZk5vdGU7XG59KCkpO1xuXG4vLyBWZXggRmxvdyBOb3RhdGlvblxuLy8gQ29weXJpZ2h0IE1vaGl0IE11dGhhbm5hIDIwMTBcbi8vXG4vLyBBdXRob3IgVGFlaG9vbiBNb29uIDIwMTRcblxuLyoqIEBjb25zdHJ1Y3RvciAqL1xuVmV4LkZsb3cuVGltZVNpZ05vdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRpbWVTaWdOb3RlKHRpbWVTcGVjLCBjdXN0b21QYWRkaW5nKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGltZVNwZWMsIGN1c3RvbVBhZGRpbmcpO1xuICB9XG5cbiAgVmV4LkluaGVyaXQoVGltZVNpZ05vdGUsIFZleC5GbG93Lk5vdGUsIHtcbiAgICBpbml0OiBmdW5jdGlvbih0aW1lU3BlYywgY3VzdG9tUGFkZGluZykge1xuICAgICAgVGltZVNpZ05vdGUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywge2R1cmF0aW9uOiBcImJcIn0pO1xuXG4gICAgICB2YXIgdGltZVNpZ25hdHVyZSA9IG5ldyBWZXguRmxvdy5UaW1lU2lnbmF0dXJlKHRpbWVTcGVjLCBjdXN0b21QYWRkaW5nKTtcbiAgICAgIHRoaXMudGltZVNpZyA9IHRpbWVTaWduYXR1cmUuZ2V0VGltZVNpZygpO1xuICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLnRpbWVTaWcuZ2x5cGguZ2V0TWV0cmljcygpLndpZHRoKTtcblxuICAgICAgLy8gTm90ZSBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLmlnbm9yZV90aWNrcyA9IHRydWU7XG4gICAgfSxcblxuICAgIHNldFN0YXZlOiBmdW5jdGlvbihzdGF2ZSkge1xuICAgICAgdmFyIHN1cGVyY2xhc3MgPSBWZXguRmxvdy5UaW1lU2lnTm90ZS5zdXBlcmNsYXNzO1xuICAgICAgc3VwZXJjbGFzcy5zZXRTdGF2ZS5jYWxsKHRoaXMsIHN0YXZlKTtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBWZXguRmxvdy5Cb3VuZGluZ0JveCgwLCAwLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgYWRkVG9Nb2RpZmllckNvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLyogb3ZlcnJpZGRlbiB0byBpZ25vcmUgKi9cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRQcmVGb3JtYXR0ZWQodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuc3RhdmUpIHRocm93IG5ldyBWZXguUkVSUihcIk5vU3RhdmVcIiwgXCJDYW4ndCBkcmF3IHdpdGhvdXQgYSBzdGF2ZS5cIik7XG4gICAgICBcbiAgICAgIGlmICghdGhpcy50aW1lU2lnLmdseXBoLmdldENvbnRleHQoKSkge1xuICAgICAgICB0aGlzLnRpbWVTaWcuZ2x5cGguc2V0Q29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRpbWVTaWcuZ2x5cGguc2V0U3RhdmUodGhpcy5zdGF2ZSk7XG4gICAgICB0aGlzLnRpbWVTaWcuZ2x5cGguc2V0WVNoaWZ0KFxuICAgICAgICB0aGlzLnN0YXZlLmdldFlGb3JMaW5lKHRoaXMudGltZVNpZy5saW5lKSAtIHRoaXMuc3RhdmUuZ2V0WUZvckdseXBocygpKTtcbiAgICAgIHRoaXMudGltZVNpZy5nbHlwaC5yZW5kZXJUb1N0YXZlKHRoaXMuZ2V0QWJzb2x1dGVYKCkpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFRpbWVTaWdOb3RlO1xufSgpKTtcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBUaGlzIGZpbGUgaW1wbGVtZW50cyBgQmVhbXNgIHRoYXQgc3BhbiBvdmVyIGEgc2V0IG9mIGBTdGVtbWFibGVOb3Rlc2AuXG4vL1xuLy8gUmVxdWlyZXM6IHZleC5qcywgdmV4bXVzaWMuanMsIG5vdGUuanNcblZleC5GbG93LkJlYW0gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEJlYW0obm90ZXMsIGF1dG9fc3RlbSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG5vdGVzLCBhdXRvX3N0ZW0pO1xuICB9XG5cbiAgdmFyIFN0ZW0gPSBWZXguRmxvdy5TdGVtO1xuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIEJlYW0ucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG5vdGVzLCBhdXRvX3N0ZW0pIHtcbiAgICAgIGlmICghbm90ZXMgfHwgbm90ZXMgPT0gW10pIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIiwgXCJObyBub3RlcyBwcm92aWRlZCBmb3IgYmVhbS5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChub3Rlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLCBcIlRvbyBmZXcgbm90ZXMgZm9yIGJlYW0uXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSBiZWFtIGxpbmUsIGRpcmVjdGlvbiBhbmQgdGlja3MuXG4gICAgICB0aGlzLnRpY2tzID0gbm90ZXNbMF0uZ2V0SW50cmluc2ljVGlja3MoKTtcblxuICAgICAgaWYgKHRoaXMudGlja3MgPj0gVmV4LkZsb3cuZHVyYXRpb25Ub1RpY2tzKFwiNFwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLFxuICAgICAgICAgICAgXCJCZWFtcyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIG5vdGVzIHNob3J0ZXIgdGhhbiBhIHF1YXJ0ZXIgbm90ZS5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBpOyAvLyBzaGFyZWQgaXRlcmF0b3JcbiAgICAgIHZhciBub3RlO1xuXG4gICAgICB0aGlzLnN0ZW1fZGlyZWN0aW9uID0gU3RlbS5VUDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG5vdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG5vdGUgPSBub3Rlc1tpXTtcbiAgICAgICAgaWYgKG5vdGUuaGFzU3RlbSgpKSB7XG4gICAgICAgICAgdGhpcy5zdGVtX2RpcmVjdGlvbiA9IG5vdGUuZ2V0U3RlbURpcmVjdGlvbigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGVtX2RpcmVjdGlvbiA9IHRoaXMuc3RlbV9kaXJlY3Rpb247XG4gICAgICAvLyBGaWd1cmUgb3V0IG9wdGltYWwgc3RlbSBkaXJlY3Rpb24gYmFzZWQgb24gZ2l2ZW4gbm90ZXNcbiAgICAgIGlmIChhdXRvX3N0ZW0gJiYgbm90ZXNbMF0uZ2V0Q2F0ZWdvcnkoKSA9PT0gJ3N0YXZlbm90ZXMnKSAge1xuICAgICAgICBzdGVtX2RpcmVjdGlvbiA9IGNhbGN1bGF0ZVN0ZW1EaXJlY3Rpb24obm90ZXMpO1xuICAgICAgfSBlbHNlIGlmIChhdXRvX3N0ZW0gJiYgbm90ZXNbMF0uZ2V0Q2F0ZWdvcnkoKSA9PT0gJ3RhYm5vdGVzJykge1xuICAgICAgICAvLyBBdXRvIFN0ZW0gVGFiTm90ZXNcbiAgICAgICAgdmFyIHN0ZW1fd2VpZ2h0ID0gbm90ZXMucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIG5vdGUpIHtcbiAgICAgICAgICByZXR1cm4gbWVtbyArIG5vdGUuc3RlbV9kaXJlY3Rpb247XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIHN0ZW1fZGlyZWN0aW9uID0gc3RlbV93ZWlnaHQgPiAtMSA/IFN0ZW0uVVAgOiBTdGVtLkRPV047XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IHN0ZW0gZGlyZWN0aW9ucyBhbmQgYXR0YWNoIGJlYW0gdG8gbm90ZXNcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBub3Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBub3RlID0gbm90ZXNbaV07XG4gICAgICAgIGlmIChhdXRvX3N0ZW0pIHtcbiAgICAgICAgICBub3RlLnNldFN0ZW1EaXJlY3Rpb24oc3RlbV9kaXJlY3Rpb24pO1xuICAgICAgICAgIHRoaXMuc3RlbV9kaXJlY3Rpb24gPSBzdGVtX2RpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBub3RlLnNldEJlYW0odGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9zdEZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5ub3RlcyA9IG5vdGVzO1xuICAgICAgdGhpcy5iZWFtX2NvdW50ID0gdGhpcy5nZXRCZWFtQ291bnQoKTtcbiAgICAgIHRoaXMuYnJlYWtfb25faW5kaWNlcyA9IFtdO1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgYmVhbV93aWR0aDogNSxcbiAgICAgICAgbWF4X3Nsb3BlOiAwLjI1LFxuICAgICAgICBtaW5fc2xvcGU6IC0wLjI1LFxuICAgICAgICBzbG9wZV9pdGVyYXRpb25zOiAyMCxcbiAgICAgICAgc2xvcGVfY29zdDogMTAwLFxuICAgICAgICBzaG93X3N0ZW1sZXRzOiBmYWxzZSxcbiAgICAgICAgc3RlbWxldF9leHRlbnNpb246IDcsXG4gICAgICAgIHBhcnRpYWxfYmVhbV9sZW5ndGg6IDEwLFxuICAgICAgICBmbGF0X2JlYW1zOiBmYWxzZSxcbiAgICAgICAgbWluX2ZsYXRfYmVhbV9vZmZzZXQ6IDE1XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBUaGUgdGhlIHJlbmRlcmluZyBgY29udGV4dGBcbiAgICBzZXRDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7IHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gR2V0IHRoZSBub3RlcyBpbiB0aGlzIGJlYW1cbiAgICBnZXROb3RlczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5vdGVzOyB9LFxuXG4gICAgLy8gR2V0IHRoZSBtYXggbnVtYmVyIG9mIGJlYW1zIGluIHRoZSBzZXQgb2Ygbm90ZXNcbiAgICBnZXRCZWFtQ291bnQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgYmVhbUNvdW50cyA9ICB0aGlzLm5vdGVzLm1hcChmdW5jdGlvbihub3RlKSB7XG4gICAgICAgIHJldHVybiBub3RlLmdldEdseXBoKCkuYmVhbV9jb3VudDtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbWF4QmVhbUNvdW50ID0gIGJlYW1Db3VudHMucmVkdWNlKGZ1bmN0aW9uKG1heCwgYmVhbUNvdW50KSB7XG4gICAgICAgICAgcmV0dXJuIGJlYW1Db3VudCA+IG1heCA/IGJlYW1Db3VudCA6IG1heDtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbWF4QmVhbUNvdW50O1xuICAgIH0sXG5cbiAgICAvLyBTZXQgd2hpY2ggbm90ZSBgaW5kaWNlc2AgdG8gYnJlYWsgdGhlIHNlY29uZGFyeSBiZWFtIGF0XG4gICAgYnJlYWtTZWNvbmRhcnlBdDogZnVuY3Rpb24oaW5kaWNlcykge1xuICAgICAgdGhpcy5icmVha19vbl9pbmRpY2VzID0gaW5kaWNlcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIHkgY29vcmRpbmF0ZSBmb3IgbGluZWFyIGZ1bmN0aW9uXG4gICAgZ2V0U2xvcGVZOiBmdW5jdGlvbih4LCBmaXJzdF94X3B4LCBmaXJzdF95X3B4LCBzbG9wZSkge1xuICAgICAgcmV0dXJuIGZpcnN0X3lfcHggKyAoKHggLSBmaXJzdF94X3B4KSAqIHNsb3BlKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBiZXN0IHBvc3NpYmxlIHNsb3BlIGZvciB0aGUgcHJvdmlkZWQgbm90ZXNcbiAgICBjYWxjdWxhdGVTbG9wZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmlyc3Rfbm90ZSA9IHRoaXMubm90ZXNbMF07XG4gICAgICB2YXIgZmlyc3RfeV9weCA9IGZpcnN0X25vdGUuZ2V0U3RlbUV4dGVudHMoKS50b3BZO1xuICAgICAgdmFyIGZpcnN0X3hfcHggPSBmaXJzdF9ub3RlLmdldFN0ZW1YKCk7XG5cbiAgICAgIHZhciBpbmMgPSAodGhpcy5yZW5kZXJfb3B0aW9ucy5tYXhfc2xvcGUgLSB0aGlzLnJlbmRlcl9vcHRpb25zLm1pbl9zbG9wZSkgL1xuICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuc2xvcGVfaXRlcmF0aW9ucztcbiAgICAgIHZhciBtaW5fY29zdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICB2YXIgYmVzdF9zbG9wZSA9IDA7XG4gICAgICB2YXIgeV9zaGlmdCA9IDA7XG5cbiAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBzbG9wZSB2YWx1ZXMgdG8gZmluZCBiZXN0IHdlaWdodGVkIGZpdFxuICAgICAgZm9yICh2YXIgc2xvcGUgPSB0aGlzLnJlbmRlcl9vcHRpb25zLm1pbl9zbG9wZTtcbiAgICAgICAgICAgc2xvcGUgPD0gdGhpcy5yZW5kZXJfb3B0aW9ucy5tYXhfc2xvcGU7XG4gICAgICAgICAgIHNsb3BlICs9IGluYykge1xuICAgICAgICB2YXIgdG90YWxfc3RlbV9leHRlbnNpb24gPSAwO1xuICAgICAgICB2YXIgeV9zaGlmdF90bXAgPSAwO1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBub3RlcywgY2FsY3VsYXRpbmcgeSBzaGlmdCBhbmQgc3RlbSBleHRlbnNpb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm5vdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIG5vdGUgPSB0aGlzLm5vdGVzW2ldO1xuXG4gICAgICAgICAgdmFyIHhfcHggPSBub3RlLmdldFN0ZW1YKCk7XG4gICAgICAgICAgdmFyIHlfcHggPSBub3RlLmdldFN0ZW1FeHRlbnRzKCkudG9wWTtcbiAgICAgICAgICB2YXIgc2xvcGVfeV9weCA9IHRoaXMuZ2V0U2xvcGVZKHhfcHgsIGZpcnN0X3hfcHgsIGZpcnN0X3lfcHgsIHNsb3BlKSArIHlfc2hpZnRfdG1wO1xuXG4gICAgICAgICAgLy8gYmVhbSBuZWVkcyB0byBiZSBzaGlmdGVkIHVwIHRvIGFjY29tbW9kYXRlIG5vdGVcbiAgICAgICAgICBpZiAoeV9weCAqIHRoaXMuc3RlbV9kaXJlY3Rpb24gPCBzbG9wZV95X3B4ICogdGhpcy5zdGVtX2RpcmVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSAgTWF0aC5hYnMoeV9weCAtIHNsb3BlX3lfcHgpO1xuICAgICAgICAgICAgeV9zaGlmdF90bXAgKz0gZGlmZiAqIC10aGlzLnN0ZW1fZGlyZWN0aW9uO1xuICAgICAgICAgICAgdG90YWxfc3RlbV9leHRlbnNpb24gKz0gKGRpZmYgKiBpKTtcbiAgICAgICAgICB9IGVsc2UgeyAvLyBiZWFtIG92ZXJzaG9vdHMgbm90ZSwgYWNjb3VudCBmb3IgdGhlIGRpZmZlcmVuY2VcbiAgICAgICAgICAgIHRvdGFsX3N0ZW1fZXh0ZW5zaW9uICs9ICh5X3B4IC0gc2xvcGVfeV9weCkgKiB0aGlzLnN0ZW1fZGlyZWN0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3Rfbm90ZSA9IHRoaXMubm90ZXNbdGhpcy5ub3Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGZpcnN0X2xhc3Rfc2xvcGUgPSAoKGxhc3Rfbm90ZS5nZXRTdGVtRXh0ZW50cygpLnRvcFkgLSBmaXJzdF95X3B4KSAvXG4gICAgICAgICAgICAgICAgKGxhc3Rfbm90ZS5nZXRTdGVtWCgpIC0gZmlyc3RfeF9weCkpO1xuICAgICAgICAvLyBtb3N0IGVuZ3JhdmluZyBib29rcyBzdWdnZXN0IGFpbWluZyBmb3IgYSBzbG9wZSBhYm91dCBoYWxmIHRoZSBhbmdsZSBvZiB0aGVcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBub3Rlcycgc3RlbSBsZW5ndGg7XG4gICAgICAgIHZhciBpZGVhbF9zbG9wZSA9IGZpcnN0X2xhc3Rfc2xvcGUgLyAyO1xuICAgICAgICB2YXIgZGlzdGFuY2VfZnJvbV9pZGVhbCA9IE1hdGguYWJzKGlkZWFsX3Nsb3BlIC0gc2xvcGUpO1xuXG4gICAgICAgIC8vIFRoaXMgdHJpZXMgdG8gYWxpZ24gbW9zdCBiZWFtcyB0byBzb21ldGhpbmcgY2xvc2VyIHRvIHRoZSBpZGVhbF9zbG9wZSwgYnV0XG4gICAgICAgIC8vIGRvZXNuJ3QgZ28gY3JhenkuIFRvIGRpc2FibGUsIHNldCB0aGlzLnJlbmRlcl9vcHRpb25zLnNsb3BlX2Nvc3QgPSAwXG4gICAgICAgIHZhciBjb3N0ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5zbG9wZV9jb3N0ICogZGlzdGFuY2VfZnJvbV9pZGVhbCArXG4gICAgICAgICAgICBNYXRoLmFicyh0b3RhbF9zdGVtX2V4dGVuc2lvbik7XG5cbiAgICAgICAgLy8gdXBkYXRlIHN0YXRlIHdoZW4gYSBtb3JlIGlkZWFsIHNsb3BlIGlzIGZvdW5kXG4gICAgICAgIGlmIChjb3N0IDwgbWluX2Nvc3QpIHtcbiAgICAgICAgICBtaW5fY29zdCA9IGNvc3Q7XG4gICAgICAgICAgYmVzdF9zbG9wZSA9IHNsb3BlO1xuICAgICAgICAgIHlfc2hpZnQgPSB5X3NoaWZ0X3RtcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNsb3BlID0gYmVzdF9zbG9wZTtcbiAgICAgIHRoaXMueV9zaGlmdCA9IHlfc2hpZnQ7XG4gICAgfSxcblxuICAgIC8vIENhbGN1bGF0ZSBhIHNsb3BlIGFuZCB5LXNoaWZ0IGZvciBmbGF0IGJlYW1zXG4gICAgY2FsY3VsYXRlRmxhdFNsb3BlOiBmdW5jdGlvbigpIHtcblxuICAgICAgLy8gSWYgYSBmbGF0IGJlYW0gb2Zmc2V0IGhhcyBub3QgeWV0IGJlZW4gc3VwcGxpZWQgb3IgY2FsY3VsYXRlZCxcbiAgICAgIC8vIGdlbmVyYXRlIG9uZSBiYXNlZCBvbiB0aGUgbm90ZXMgaW4gdGhpcyBwYXJ0aWN1bGFyIG5vdGUgZ3JvdXBcbiAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICB2YXIgZXh0cmVtZV95ID0gMDsgIC8vIFN0b3JlIHRoZSBoaWdoZXN0IG9yIGxvd2VzdCBub3RlIGhlcmVcbiAgICAgIHZhciBleHRyZW1lX2JlYW1fY291bnQgPSAwOyAgLy8gVGhlIGJlYW0gY291bnQgb2YgdGhlIGV4dHJlbWUgbm90ZVxuICAgICAgdmFyIGN1cnJlbnRfZXh0cmVtZSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubm90ZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAvLyBUb3RhbCB1cCBhbGwgb2YgdGhlIG9mZnNldHMgc28gd2UgY2FuIGF2ZXJhZ2UgdGhlbSBvdXQgbGF0ZXJcbiAgICAgICAgdmFyIG5vdGUgPSB0aGlzLm5vdGVzW2ldO1xuICAgICAgICB2YXIgdG9wX3kgPSBub3RlLmdldFN0ZW1FeHRlbnRzKCkudG9wWTtcbiAgICAgICAgdG90YWwgKz0gdG9wX3k7XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIGhpZ2hlc3QgKHN0ZW1zLXVwKSBvciBsb3dlc3QgKHN0ZW1zLWRvd24pIG5vdGUgc28gdGhlXG4gICAgICAgIC8vICBvZmZzZXQgY2FuIGJlIGFkanVzdGVkIGluIGNhc2UgdGhlIGF2ZXJhZ2UgaXNuJ3QgZW5vdWdoXG4gICAgICAgIGlmICh0aGlzLnN0ZW1fZGlyZWN0aW9uID09PSBTdGVtLkRPV04gJiYgY3VycmVudF9leHRyZW1lIDwgdG9wX3kpIHtcbiAgICAgICAgICBjdXJyZW50X2V4dHJlbWUgPSB0b3BfeTtcbiAgICAgICAgICBleHRyZW1lX3kgPSBub3RlLmdldE5vdGVIZWFkQm91bmRzKCkueV9ib3R0b207XG4gICAgICAgICAgZXh0cmVtZV9iZWFtX2NvdW50ID0gbm90ZS5nZXRCZWFtQ291bnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0ZW1fZGlyZWN0aW9uID09PSBTdGVtLlVQICYmIChjdXJyZW50X2V4dHJlbWUgPT09IDAgfHwgY3VycmVudF9leHRyZW1lID4gdG9wX3kpKSB7XG4gICAgICAgICAgY3VycmVudF9leHRyZW1lID0gdG9wX3k7XG4gICAgICAgICAgZXh0cmVtZV95ID0gbm90ZS5nZXROb3RlSGVhZEJvdW5kcygpLnlfdG9wO1xuICAgICAgICAgIGV4dHJlbWVfYmVhbV9jb3VudCA9IG5vdGUuZ2V0QmVhbUNvdW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQXZlcmFnZSB0aGUgb2Zmc2V0cyB0byB0cnkgYW5kIGNvbWUgdXAgd2l0aCBhIHJlYXNvbmFibGUgb25lIHRoYXRcbiAgICAgIC8vICB3b3JrcyBmb3IgYWxsIG9mIHRoZSBub3RlcyBpbiB0aGUgYmVhbSBncm91cC5cbiAgICAgIHZhciBvZmZzZXQgPSB0b3RhbCAvIHRoaXMubm90ZXMubGVuZ3RoO1xuXG4gICAgICAvLyBJbiBjYXNlIHRoZSBhdmVyYWdlIGlzbid0IGxvbmcgZW5vdWdoLCBhZGQgb3Igc3VidHJhY3Qgc29tZSBtb3JlXG4gICAgICAvLyAgYmFzZWQgb24gdGhlIGhpZ2hlc3Qgb3IgbG93ZXN0IG5vdGUgKGFnYWluLCBiYXNlZCBvbiB0aGUgc3RlbVxuICAgICAgLy8gIGRpcmVjdGlvbikuIFRoaXMgYWxzbyB0YWtlcyBpbnRvIGFjY291bnQgdGhlIGFkZGVkIGhlaWdodCBkdWUgdG9cbiAgICAgIC8vICB0aGUgd2lkdGggb2YgdGhlIGJlYW1zLlxuICAgICAgdmFyIGJlYW1fd2lkdGggPSB0aGlzLnJlbmRlcl9vcHRpb25zLmJlYW1fd2lkdGggKiAxLjU7XG4gICAgICB2YXIgZXh0cmVtZV90ZXN0ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5taW5fZmxhdF9iZWFtX29mZnNldCArIChleHRyZW1lX2JlYW1fY291bnQgKiBiZWFtX3dpZHRoKTtcbiAgICAgIHZhciBuZXdfb2Zmc2V0ID0gZXh0cmVtZV95ICsgKGV4dHJlbWVfdGVzdCAqIC10aGlzLnN0ZW1fZGlyZWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLnN0ZW1fZGlyZWN0aW9uID09PSBTdGVtLkRPV04gJiYgb2Zmc2V0IDwgbmV3X29mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBleHRyZW1lX3kgKyBleHRyZW1lX3Rlc3Q7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RlbV9kaXJlY3Rpb24gPT09IFN0ZW0uVVAgJiYgb2Zmc2V0ID4gbmV3X29mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBleHRyZW1lX3kgLSBleHRyZW1lX3Rlc3Q7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtX29mZnNldCkge1xuXG4gICAgICAgIC8vIFNldCB0aGUgb2Zmc2V0IGZvciB0aGUgZ3JvdXAgYmFzZWQgb24gdGhlIGNhbGN1bGF0aW9ucyBhYm92ZS5cbiAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5mbGF0X2JlYW1fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0ZW1fZGlyZWN0aW9uID09PSBTdGVtLkRPV04gJiYgb2Zmc2V0ID4gdGhpcy5yZW5kZXJfb3B0aW9ucy5mbGF0X2JlYW1fb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtX29mZnNldCA9IG9mZnNldDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGVtX2RpcmVjdGlvbiA9PT0gU3RlbS5VUCAmJiBvZmZzZXQgPCB0aGlzLnJlbmRlcl9vcHRpb25zLmZsYXRfYmVhbV9vZmZzZXQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5mbGF0X2JlYW1fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICAvLyBmb3IgZmxhdCBiZWFtcywgdGhlIHNsb3BlIGFuZCB5X3NoaWZ0IGFyZSBzaW1wbHkgMFxuICAgICAgdGhpcy5zbG9wZSA9IDA7XG4gICAgICB0aGlzLnlfc2hpZnQgPSAwO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgbmV3IHN0ZW1zIGZvciB0aGUgbm90ZXMgaW4gdGhlIGJlYW0sIHNvIHRoYXQgZWFjaCBzdGVtXG4gICAgLy8gZXh0ZW5kcyBpbnRvIHRoZSBiZWFtcy5cbiAgICBhcHBseVN0ZW1FeHRlbnNpb25zOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGZpcnN0X25vdGUgPSB0aGlzLm5vdGVzWzBdO1xuICAgICAgdmFyIGZpcnN0X3lfcHggPSBmaXJzdF9ub3RlLmdldFN0ZW1FeHRlbnRzKCkudG9wWTtcblxuICAgICAgLy8gSWYgcmVuZGVyaW5nIGZsYXQgYmVhbXMsIGFuZCBhbiBvZmZzZXQgZXhpc3RzLCBzZXQgdGhlIHktY29vcmRpbmF0ZSB0b1xuICAgICAgLy8gIHRoZSBvZmZzZXQgc28gdGhlIHN0ZW1zIGFsbCBlbmQgYXQgdGhlIGJlYW0gb2Zmc2V0LlxuICAgICAgaWYgKHRoaXMucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtcyAmJiB0aGlzLnJlbmRlcl9vcHRpb25zLmZsYXRfYmVhbV9vZmZzZXQpIHtcbiAgICAgICAgZmlyc3RfeV9weCA9IHRoaXMucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtX29mZnNldDtcbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdF94X3B4ID0gZmlyc3Rfbm90ZS5nZXRTdGVtWCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubm90ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG5vdGUgPSB0aGlzLm5vdGVzW2ldO1xuXG4gICAgICAgIHZhciB4X3B4ID0gbm90ZS5nZXRTdGVtWCgpO1xuICAgICAgICB2YXIgeV9leHRlbnRzID0gbm90ZS5nZXRTdGVtRXh0ZW50cygpO1xuICAgICAgICB2YXIgYmFzZV95X3B4ID0geV9leHRlbnRzLmJhc2VZO1xuICAgICAgICB2YXIgdG9wX3lfcHggPSB5X2V4dGVudHMudG9wWTtcblxuICAgICAgICAvLyBJZiBmbGF0IGJlYW1zLCBzZXQgdGhlIHRvcCBvZiB0aGUgc3RlbSB0byB0aGUgb2Zmc2V0LCByYXRoZXIgdGhhblxuICAgICAgICAvLyAgcmVseWluZyBvbiB0aGUgdG9wWSB2YWx1ZSBmcm9tIGFib3ZlLlxuICAgICAgICBpZiAodGhpcy5yZW5kZXJfb3B0aW9ucy5mbGF0X2JlYW1zKSB7XG4gICAgICAgICAgdG9wX3lfcHggPSBmaXJzdF95X3B4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIGhhcm1vbmljIG5vdGUgaGVhZHMsIHNob3J0ZW4gc3RlbSBsZW5ndGggYnkgMyBwaXhlbHNcbiAgICAgICAgYmFzZV95X3B4ICs9IHRoaXMuc3RlbV9kaXJlY3Rpb24gKiBub3RlLmdseXBoLnN0ZW1fb2Zmc2V0O1xuXG4gICAgICAgIC8vIERvbid0IGdvIGFsbCB0aGUgd2F5IHRvIHRoZSB0b3AgKGZvciB0aGlja2VyIHN0ZW1zKVxuICAgICAgICB2YXIgeV9kaXNwbGFjZW1lbnQgPSBWZXguRmxvdy5TVEVNX1dJRFRIO1xuXG4gICAgICAgIGlmICghbm90ZS5oYXNTdGVtKCkpIHtcbiAgICAgICAgICBpZiAobm90ZS5pc1Jlc3QoKSAmJiB0aGlzLnJlbmRlcl9vcHRpb25zLnNob3dfc3RlbWxldHMpIHtcbiAgICAgICAgICAgIHZhciBjZW50ZXJHbHlwaFggPSBub3RlLmdldENlbnRlckdseXBoWCgpO1xuXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnJlbmRlcl9vcHRpb25zLmJlYW1fd2lkdGg7XG4gICAgICAgICAgICB2YXIgdG90YWxfd2lkdGggPSAoKHRoaXMuYmVhbV9jb3VudCAtIDEpKiB3aWR0aCAqIDEuNSkgKyB3aWR0aDtcblxuICAgICAgICAgICAgdmFyIHN0ZW1sZXRfaGVpZ2h0ID0gKHRvdGFsX3dpZHRoIC0geV9kaXNwbGFjZW1lbnQgK1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLnN0ZW1sZXRfZXh0ZW5zaW9uKTtcblxuICAgICAgICAgICAgdmFyIGJlYW1feSA9IHRoaXMuZ2V0U2xvcGVZKGNlbnRlckdseXBoWCwgZmlyc3RfeF9weCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF95X3B4LCB0aGlzLnNsb3BlKSArIHRoaXMueV9zaGlmdDtcbiAgICAgICAgICAgIHZhciBzdGFydF95ID0gYmVhbV95ICsgKFZleC5GbG93LlN0ZW0uSEVJR0hUICogdGhpcy5zdGVtX2RpcmVjdGlvbik7XG4gICAgICAgICAgICB2YXIgZW5kX3kgPSBiZWFtX3kgKyAoc3RlbWxldF9oZWlnaHQgKiB0aGlzLnN0ZW1fZGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgLy8gRHJhdyBTdGVtbGV0XG4gICAgICAgICAgICBub3RlLnNldFN0ZW0obmV3IFZleC5GbG93LlN0ZW0oe1xuICAgICAgICAgICAgICB4X2JlZ2luOiBjZW50ZXJHbHlwaFgsXG4gICAgICAgICAgICAgIHhfZW5kOiBjZW50ZXJHbHlwaFgsXG4gICAgICAgICAgICAgIHlfYm90dG9tOiB0aGlzLnN0ZW1fZGlyZWN0aW9uID09PSBTdGVtLlVQID8gZW5kX3kgOiBzdGFydF95LFxuICAgICAgICAgICAgICB5X3RvcDogdGhpcy5zdGVtX2RpcmVjdGlvbiA9PT0gU3RlbS5VUCA/IHN0YXJ0X3kgOiBlbmRfeSxcbiAgICAgICAgICAgICAgeV9leHRlbmQ6IHlfZGlzcGxhY2VtZW50LFxuICAgICAgICAgICAgICBzdGVtX2V4dGVuc2lvbjogLTEsIC8vIFRvIGF2b2lkIHByb3RydWRpbmcgdGhyb3VnaCB0aGUgYmVhbVxuICAgICAgICAgICAgICBzdGVtX2RpcmVjdGlvbjogdGhpcy5zdGVtX2RpcmVjdGlvblxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNsb3BlX3kgPSB0aGlzLmdldFNsb3BlWSh4X3B4LCBmaXJzdF94X3B4LCBmaXJzdF95X3B4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zbG9wZSkgKyB0aGlzLnlfc2hpZnQ7XG5cbiAgICAgICAgbm90ZS5zZXRTdGVtKG5ldyBWZXguRmxvdy5TdGVtKHtcbiAgICAgICAgICB4X2JlZ2luOiB4X3B4IC0gKFZleC5GbG93LlNURU1fV0lEVEgvMiksXG4gICAgICAgICAgeF9lbmQ6IHhfcHgsXG4gICAgICAgICAgeV90b3A6IHRoaXMuc3RlbV9kaXJlY3Rpb24gPT09IFN0ZW0uVVAgPyB0b3BfeV9weCA6IGJhc2VfeV9weCxcbiAgICAgICAgICB5X2JvdHRvbTogdGhpcy5zdGVtX2RpcmVjdGlvbiA9PT0gU3RlbS5VUCA/IGJhc2VfeV9weCA6ICB0b3BfeV9weCxcbiAgICAgICAgICB5X2V4dGVuZDogeV9kaXNwbGFjZW1lbnQsXG4gICAgICAgICAgc3RlbV9leHRlbnNpb246IE1hdGguYWJzKHRvcF95X3B4IC0gc2xvcGVfeSkgLSBTdGVtLkhFSUdIVCAtIDEsXG4gICAgICAgICAgc3RlbV9kaXJlY3Rpb246IHRoaXMuc3RlbV9kaXJlY3Rpb25cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHggY29vcmRpbmF0ZXMgZm9yIHRoZSBiZWFtIGxpbmVzIG9mIHNwZWNpZmljIGBkdXJhdGlvbmBcbiAgICBnZXRCZWFtTGluZXM6IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gICAgICB2YXIgYmVhbV9saW5lcyA9IFtdO1xuICAgICAgdmFyIGJlYW1fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgdmFyIGN1cnJlbnRfYmVhbSA9IG51bGw7XG4gICAgICB2YXIgcGFydGlhbF9iZWFtX2xlbmd0aCA9IHRoaXMucmVuZGVyX29wdGlvbnMucGFydGlhbF9iZWFtX2xlbmd0aDtcbiAgICAgIHZhciBwcmV2aW91c19zaG91bGRfYnJlYWsgPSBmYWxzZTtcbiAgICAgIHZhciB0aWNrX3RhbGx5ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub3Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbm90ZSA9IHRoaXMubm90ZXNbaV07XG5cbiAgICAgICAgLy8gU2VlIGlmIHdlIG5lZWQgdG8gYnJlYWsgc2Vjb25kYXJ5IGJlYW1zIG9uIHRoaXMgbm90ZS5cbiAgICAgICAgdmFyIHRpY2tzID0gbm90ZS5nZXRJbnRyaW5zaWNUaWNrcygpO1xuICAgICAgICB0aWNrX3RhbGx5ICs9IHRpY2tzO1xuICAgICAgICB2YXIgc2hvdWxkX2JyZWFrID0gZmFsc2U7XG5cbiAgICAgICAgLy8gOHRoIG5vdGUgYmVhbXMgYXJlIGFsd2F5cyBkcmF3bi5cbiAgICAgICAgaWYgKHBhcnNlSW50KGR1cmF0aW9uKSA+PSA4KSB7XG5cbiAgICAgICAgICAvLyBGaXJzdCwgY2hlY2sgdG8gc2VlIGlmIGFueSBpbmRpY2VzIHdlcmUgc2V0IHVwIHRocm91Z2ggYnJlYWtTZWNvbmRhcnlBdCgpXG4gICAgICAgICAgc2hvdWxkX2JyZWFrID0gdGhpcy5icmVha19vbl9pbmRpY2VzLmluZGV4T2YoaSkgIT09IC0xO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIHNlY29uZGFyeSBicmVha3Mgd2VyZSBhdXRvLWNvbmZpZ3VyZWQgaW4gdGhlIHJlbmRlciBvcHRpb25zLFxuICAgICAgICAgIC8vICBoYW5kbGUgdGhhdCBhcyB3ZWxsLlxuICAgICAgICAgIGlmICh0aGlzLnJlbmRlcl9vcHRpb25zLnNlY29uZGFyeV9icmVha190aWNrcyAmJiB0aWNrX3RhbGx5ID49IHRoaXMucmVuZGVyX29wdGlvbnMuc2Vjb25kYXJ5X2JyZWFrX3RpY2tzKSB7XG4gICAgICAgICAgICB0aWNrX3RhbGx5ID0gMDtcbiAgICAgICAgICAgIHNob3VsZF9icmVhayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBub3RlX2dldHNfYmVhbSA9IHRpY2tzIDwgVmV4LkZsb3cuZHVyYXRpb25Ub1RpY2tzKGR1cmF0aW9uKTtcbiAgICAgICAgdmFyIHN0ZW1feCA9IG5vdGUuaXNSZXN0KCkgPyBub3RlLmdldENlbnRlckdseXBoWCgpIDogbm90ZS5nZXRTdGVtWCgpO1xuXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgbmV4dCBub3RlIGluIHRoZSBncm91cCB3aWxsIGdldCBhIGJlYW0gYXQgdGhpc1xuICAgICAgICAvLyAgbGV2ZWwuIFRoaXMgd2lsbCBoZWxwIHRvIGluZm9ybSB0aGUgcGFydGlhbCBiZWFtIGxvZ2ljIGJlbG93LlxuICAgICAgICB2YXIgbmV4dF9ub3RlID0gdGhpcy5ub3Rlc1tpICsgMV07XG4gICAgICAgIHZhciBiZWFtX25leHQgPSBuZXh0X25vdGUgJiYgbmV4dF9ub3RlLmdldEludHJpbnNpY1RpY2tzKCkgPCBWZXguRmxvdy5kdXJhdGlvblRvVGlja3MoZHVyYXRpb24pO1xuICAgICAgICBpZiAobm90ZV9nZXRzX2JlYW0pIHtcblxuICAgICAgICAgIC8vIFRoaXMgbm90ZSBnZXRzIGEgYmVhbSBhdCB0aGUgY3VycmVudCBsZXZlbFxuICAgICAgICAgIGlmIChiZWFtX3N0YXJ0ZWQpIHtcblxuICAgICAgICAgICAgLy8gV2UncmUgY3VycmVudGx5IGluIHRoZSBtaWRkbGUgb2YgYSBiZWFtLiBKdXN0IGNvbnRpbnVlIGl0IG9uIHRvXG4gICAgICAgICAgICAvLyAgdGhlIHN0ZW0gWCBvZiB0aGUgY3VycmVudCBub3RlLlxuICAgICAgICAgICAgY3VycmVudF9iZWFtID0gYmVhbV9saW5lc1tiZWFtX2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY3VycmVudF9iZWFtLmVuZCA9IHN0ZW1feDtcblxuICAgICAgICAgICAgLy8gSWYgYSBzZWNvbmRhcnkgYmVhbSBicmVhayBpcyBzZXQgdXAsIGVuZCB0aGUgYmVhbSByaWdodCBub3cuXG4gICAgICAgICAgICBpZiAoc2hvdWxkX2JyZWFrKSB7XG4gICAgICAgICAgICAgIGJlYW1fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAobmV4dF9ub3RlICYmICFiZWFtX25leHQgJiYgY3VycmVudF9iZWFtLmVuZCA9PT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub3RlIGdldHMgYSBiZWFtLC5idXQgdGhlIG5leHQgb25lIGRvZXMgbm90LiBUaGlzIG1lYW5zXG4gICAgICAgICAgICAgICAgLy8gIHdlIG5lZWQgYSBwYXJ0aWFsIHBvaW50aW5nIHJpZ2h0LlxuICAgICAgICAgICAgICAgIGN1cnJlbnRfYmVhbS5lbmQgPSBjdXJyZW50X2JlYW0uc3RhcnQgLSBwYXJ0aWFsX2JlYW1fbGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gTm8gYmVhbSBzdGFydGVkIHlldC4gU3RhcnQgYSBuZXcgb25lLlxuICAgICAgICAgICAgY3VycmVudF9iZWFtID0geyBzdGFydDogc3RlbV94LCBlbmQ6IG51bGwgfTtcbiAgICAgICAgICAgIGJlYW1fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWJlYW1fbmV4dCkge1xuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG5vdGUgZG9lc24ndCBnZXQgYSBiZWFtLiBEcmF3IGEgcGFydGlhbC5cbiAgICAgICAgICAgICAgaWYoKHByZXZpb3VzX3Nob3VsZF9icmVhayB8fCBpID09PSAwKSAmJiBuZXh0X25vdGUpIHtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IG5vdGUgKGJ1dCBub3QgdGhlIGxhc3Qgb25lKSwgb3IgaXQgaXNcbiAgICAgICAgICAgICAgICAvLyAgZm9sbG93aW5nIGEgc2Vjb25kYXJ5IGJyZWFrLiBEcmF3IGEgcGFydGlhbCB0byB0aGUgcmlnaHQuXG4gICAgICAgICAgICAgICAgY3VycmVudF9iZWFtLmVuZCA9IGN1cnJlbnRfYmVhbS5zdGFydCArIHBhcnRpYWxfYmVhbV9sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBkcmF3IGEgcGFydGlhbCB0byB0aGUgbGVmdC5cbiAgICAgICAgICAgICAgICBjdXJyZW50X2JlYW0uZW5kID0gY3VycmVudF9iZWFtLnN0YXJ0IC0gcGFydGlhbF9iZWFtX2xlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaG91bGRfYnJlYWspIHtcblxuICAgICAgICAgICAgICAvLyBUaGlzIG5vdGUgc2hvdWxkIGhhdmUgYSBzZWNvbmRhcnkgYnJlYWsgYWZ0ZXIgaXQuIEV2ZW4gdGhvdWdoXG4gICAgICAgICAgICAgIC8vICB3ZSBqdXN0IHN0YXJ0ZWQgYSBiZWFtLCBpdCBuZWVkcyB0byBlbmQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgIGN1cnJlbnRfYmVhbS5lbmQgPSBjdXJyZW50X2JlYW0uc3RhcnQgLSBwYXJ0aWFsX2JlYW1fbGVuZ3RoO1xuICAgICAgICAgICAgICBiZWFtX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJlYW1fbGluZXMucHVzaChjdXJyZW50X2JlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIFRoZSBjdXJyZW50IG5vdGUgZG9lcyBub3QgZ2V0IGEgYmVhbS5cbiAgICAgICAgICBiZWFtX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBzZWNvbmRhcnkgYnJlYWsgZmxhZyB0byBpbmZvcm0gdGhlIHBhcnRpYWwgYmVhbSBsb2dpYyBpblxuICAgICAgICAvLyAgdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICBwcmV2aW91c19zaG91bGRfYnJlYWsgPSBzaG91bGRfYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBhIHBhcnRpYWwgYmVhbSBwb2ludGluZyBsZWZ0IGlmIHRoaXMgaXMgdGhlIGxhc3Qgbm90ZSBpbiB0aGUgZ3JvdXBcbiAgICAgIHZhciBsYXN0X2JlYW0gPSBiZWFtX2xpbmVzW2JlYW1fbGluZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdF9iZWFtICYmIGxhc3RfYmVhbS5lbmQgPT09IG51bGwpIHtcbiAgICAgICAgbGFzdF9iZWFtLmVuZCA9IGxhc3RfYmVhbS5zdGFydCAtIHBhcnRpYWxfYmVhbV9sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmVhbV9saW5lcztcbiAgICB9LFxuXG4gICAgLy8gUmVuZGVyIHRoZSBzdGVtcyBmb3IgZWFjaCBub3Rlc1xuICAgIGRyYXdTdGVtczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm5vdGVzLmZvckVhY2goZnVuY3Rpb24obm90ZSkge1xuICAgICAgICBpZiAobm90ZS5nZXRTdGVtKCkpIHtcbiAgICAgICAgICBub3RlLmdldFN0ZW0oKS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCkuZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gUmVuZGVyIHRoZSBiZWFtIGxpbmVzXG4gICAgZHJhd0JlYW1MaW5lczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHdpdGhvdXQgYSBjYW52YXMgY29udGV4dC5cIik7XG5cbiAgICAgIHZhciB2YWxpZF9iZWFtX2R1cmF0aW9ucyA9IFtcIjRcIiwgXCI4XCIsIFwiMTZcIiwgXCIzMlwiLCBcIjY0XCJdO1xuXG4gICAgICB2YXIgZmlyc3Rfbm90ZSA9IHRoaXMubm90ZXNbMF07XG4gICAgICB2YXIgbGFzdF9ub3RlID0gdGhpcy5ub3Rlc1t0aGlzLm5vdGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICB2YXIgZmlyc3RfeV9weCA9IGZpcnN0X25vdGUuZ2V0U3RlbUV4dGVudHMoKS50b3BZO1xuICAgICAgdmFyIGxhc3RfeV9weCA9IGxhc3Rfbm90ZS5nZXRTdGVtRXh0ZW50cygpLnRvcFk7XG5cbiAgICAgIC8vIEZvciBmbGF0IGJlYW1zLCBzZXQgdGhlIGZpcnN0IGFuZCBsYXN0IFkgdG8gdGhlIG9mZnNldCwgcmF0aGVyIHRoYW5cbiAgICAgIC8vICB1c2luZyB0aGUgbm90ZSdzIHN0ZW0gZXh0ZW50cy5cbiAgICAgIGlmICh0aGlzLnJlbmRlcl9vcHRpb25zLmZsYXRfYmVhbXMgJiYgdGhpcy5yZW5kZXJfb3B0aW9ucy5mbGF0X2JlYW1fb2Zmc2V0KSB7XG4gICAgICAgIGZpcnN0X3lfcHggPSB0aGlzLnJlbmRlcl9vcHRpb25zLmZsYXRfYmVhbV9vZmZzZXQ7XG4gICAgICAgIGxhc3RfeV9weCA9IHRoaXMucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtX29mZnNldDtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0X3hfcHggPSBmaXJzdF9ub3RlLmdldFN0ZW1YKCk7XG5cbiAgICAgIHZhciBiZWFtX3dpZHRoID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5iZWFtX3dpZHRoICogdGhpcy5zdGVtX2RpcmVjdGlvbjtcblxuICAgICAgLy8gRHJhdyB0aGUgYmVhbXMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbGlkX2JlYW1fZHVyYXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHZhbGlkX2JlYW1fZHVyYXRpb25zW2ldO1xuICAgICAgICB2YXIgYmVhbV9saW5lcyA9IHRoaXMuZ2V0QmVhbUxpbmVzKGR1cmF0aW9uKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJlYW1fbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICB2YXIgYmVhbV9saW5lID0gYmVhbV9saW5lc1tqXTtcbiAgICAgICAgICB2YXIgZmlyc3RfeCA9IGJlYW1fbGluZS5zdGFydCAtICh0aGlzLnN0ZW1fZGlyZWN0aW9uID09IFN0ZW0uRE9XTiA/IFZleC5GbG93LlNURU1fV0lEVEgvMjowKTtcbiAgICAgICAgICB2YXIgZmlyc3RfeSA9IHRoaXMuZ2V0U2xvcGVZKGZpcnN0X3gsIGZpcnN0X3hfcHgsIGZpcnN0X3lfcHgsIHRoaXMuc2xvcGUpO1xuXG4gICAgICAgICAgdmFyIGxhc3RfeCA9IGJlYW1fbGluZS5lbmQgK1xuICAgICAgICAgICAgKHRoaXMuc3RlbV9kaXJlY3Rpb24gPT0gMSA/IChWZXguRmxvdy5TVEVNX1dJRFRILzMpOigtVmV4LkZsb3cuU1RFTV9XSURUSC8zKSk7XG4gICAgICAgICAgdmFyIGxhc3RfeSA9IHRoaXMuZ2V0U2xvcGVZKGxhc3RfeCwgZmlyc3RfeF9weCwgZmlyc3RfeV9weCwgdGhpcy5zbG9wZSk7XG5cbiAgICAgICAgICB0aGlzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgdGhpcy5jb250ZXh0Lm1vdmVUbyhmaXJzdF94LCBmaXJzdF95ICsgdGhpcy55X3NoaWZ0KTtcbiAgICAgICAgICB0aGlzLmNvbnRleHQubGluZVRvKGZpcnN0X3gsIGZpcnN0X3kgKyBiZWFtX3dpZHRoICsgdGhpcy55X3NoaWZ0KTtcbiAgICAgICAgICB0aGlzLmNvbnRleHQubGluZVRvKGxhc3RfeCArIDEsIGxhc3RfeSArIGJlYW1fd2lkdGggKyB0aGlzLnlfc2hpZnQpO1xuICAgICAgICAgIHRoaXMuY29udGV4dC5saW5lVG8obGFzdF94ICsgMSwgbGFzdF95ICsgdGhpcy55X3NoaWZ0KTtcbiAgICAgICAgICB0aGlzLmNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpcnN0X3lfcHggKz0gYmVhbV93aWR0aCAqIDEuNTtcbiAgICAgICAgbGFzdF95X3B4ICs9IGJlYW1fd2lkdGggKiAxLjU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFByZS1mb3JtYXQgdGhlIGJlYW1cbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIFBvc3QtZm9ybWF0IHRoZSBiZWFtLiBUaGlzIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlclxuICAgIC8vIHRoZSBub3RlcyBpbiB0aGUgYmVhbSBoYXZlIGJvdGggYHhgIGFuZCBgeWAgdmFsdWVzLiBpZTogdGhleSd2ZVxuICAgIC8vIGJlZW4gZm9ybWF0dGVkIGFuZCBoYXZlIHN0YXZlc1xuICAgIHBvc3RGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucG9zdEZvcm1hdHRlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgYSBzbWFydCBzbG9wZSBpZiB3ZSdyZSBub3QgZm9yY2luZyB0aGUgYmVhbXMgdG8gYmUgZmxhdC5cbiAgICAgIGlmKHRoaXMucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtcykge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUZsYXRTbG9wZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVTbG9wZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBseVN0ZW1FeHRlbnNpb25zKCk7XG5cbiAgICAgIHRoaXMucG9zdEZvcm1hdHRlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8vIFJlbmRlciB0aGUgYmVhbSB0byB0aGUgY2FudmFzIGNvbnRleHRcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgd2l0aG91dCBhIGNhbnZhcyBjb250ZXh0LlwiKTtcblxuICAgICAgaWYgKHRoaXMudW5iZWFtYWJsZSkgcmV0dXJuO1xuXG4gICAgICBpZiAoIXRoaXMucG9zdEZvcm1hdHRlZCkge1xuICAgICAgICB0aGlzLnBvc3RGb3JtYXQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kcmF3U3RlbXMoKTtcbiAgICAgIHRoaXMuZHJhd0JlYW1MaW5lcygpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlU3RlbURpcmVjdGlvbihub3Rlcykge1xuICAgIHZhciBsaW5lU3VtID0gMDtcbiAgICBub3Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vdGUpIHtcbiAgICAgIGlmIChub3RlLmtleVByb3BzKSB7XG4gICAgICAgIG5vdGUua2V5UHJvcHMuZm9yRWFjaChmdW5jdGlvbihrZXlQcm9wKXtcbiAgICAgICAgICBsaW5lU3VtICs9IChrZXlQcm9wLmxpbmUgLSAzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobGluZVN1bSA+PSAwKVxuICAgICAgcmV0dXJuIFN0ZW0uRE9XTjtcbiAgICByZXR1cm4gU3RlbS5VUDtcbiAgfVxuXG4gIC8vICMjIFN0YXRpYyBNZXRob2RzXG4gIC8vXG4gIC8vIEdldHMgdGhlIGRlZmF1bHQgYmVhbSBncm91cHMgZm9yIGEgcHJvdmlkZWQgdGltZSBzaWduYXR1cmUuXG4gIC8vIEF0dGVtcHRzIHRvIGd1ZXNzIGlmIHRoZSB0aW1lIHNpZ25hdHVyZSBpcyBub3QgZm91bmQgaW4gdGFibGUuXG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIGZhaXJseSBuYWl2ZS5cbiAgQmVhbS5nZXREZWZhdWx0QmVhbUdyb3VwcyA9IGZ1bmN0aW9uKHRpbWVfc2lnKXtcbiAgICBpZiAoIXRpbWVfc2lnIHx8IHRpbWVfc2lnID09IFwiY1wiKSB0aW1lX3NpZyA9IFwiNC80XCI7XG5cbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAnMS8yJyA6ICBbJzEvMiddLFxuICAgICAgJzIvMicgOiAgWycxLzInXSxcbiAgICAgICczLzInIDogIFsnMS8yJ10sXG4gICAgICAnNC8yJyA6ICBbJzEvMiddLFxuXG4gICAgICAnMS80JyA6ICBbJzEvNCddLFxuICAgICAgJzIvNCcgOiAgWycxLzQnXSxcbiAgICAgICczLzQnIDogIFsnMS80J10sXG4gICAgICAnNC80JyA6ICBbJzEvNCddLFxuXG4gICAgICAnMS84JyA6ICBbJzEvOCddLFxuICAgICAgJzIvOCcgOiAgWycyLzgnXSxcbiAgICAgICczLzgnIDogIFsnMy84J10sXG4gICAgICAnNC84JyA6ICBbJzIvOCddLFxuXG4gICAgICAnMS8xNicgOiBbJzEvMTYnXSxcbiAgICAgICcyLzE2JyA6IFsnMi8xNiddLFxuICAgICAgJzMvMTYnIDogWyczLzE2J10sXG4gICAgICAnNC8xNicgOiBbJzIvMTYnXVxuICAgIH07XG5cbiAgICB2YXIgRnJhY3Rpb24gPSBWZXguRmxvdy5GcmFjdGlvbjtcbiAgICB2YXIgZ3JvdXBzID0gZGVmYXVsdHNbdGltZV9zaWddO1xuXG4gICAgaWYgKCFncm91cHMpIHtcbiAgICAgIC8vIElmIG5vIGJlYW0gZ3JvdXBzIGZvdW5kLCBuYWl2ZWx5IGRldGVybWluZVxuICAgICAgLy8gdGhlIGJlYW0gZ3JvdXBpbmdzIGZyb20gdGhlIHRpbWUgc2lnbmF0dXJlXG4gICAgICB2YXIgYmVhdFRvdGFsID0gcGFyc2VJbnQodGltZV9zaWcuc3BsaXQoJy8nKVswXSwgMTApO1xuICAgICAgdmFyIGJlYXRWYWx1ZSA9IHBhcnNlSW50KHRpbWVfc2lnLnNwbGl0KCcvJylbMV0sIDEwKTtcblxuICAgICAgdmFyIHRyaXBsZU1ldGVyID0gYmVhdFRvdGFsICUgMyA9PT0gMDtcblxuICAgICAgaWYgKHRyaXBsZU1ldGVyKSB7XG4gICAgICAgIHJldHVybiBbbmV3IEZyYWN0aW9uKDMsIGJlYXRWYWx1ZSldO1xuICAgICAgfSBlbHNlIGlmIChiZWF0VmFsdWUgPiA0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IEZyYWN0aW9uKDIsIGJlYXRWYWx1ZSldO1xuICAgICAgfSBlbHNlIGlmIChiZWF0VmFsdWUgPD0gNCkge1xuICAgICAgICByZXR1cm4gW25ldyBGcmFjdGlvbigxLCBiZWF0VmFsdWUpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdyb3Vwcy5tYXAoZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbigpLnBhcnNlKGdyb3VwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBBIGhlbHBlciBmdW5jdGlvbiB0byBhdXRvbWF0aWNhbGx5IGJ1aWxkIGJhc2ljIGJlYW1zIGZvciBhIHZvaWNlLiBGb3IgbW9yZVxuICAvLyBjb21wbGV4IGF1dG8tYmVhbWluZyB1c2UgYEJlYW0uZ2VuZXJhdGVCZWFtcygpYC5cbiAgLy9cbiAgLy8gUGFyYW1ldGVyczpcbiAgLy8gKiBgdm9pY2VgIC0gVGhlIHZvaWNlIHRvIGdlbmVyYXRlIHRoZSBiZWFtcyBmb3JcbiAgLy8gKiBgc3RlbV9kaXJlY3Rpb25gIC0gQSBzdGVtIGRpcmVjdGlvbiB0byBhcHBseSB0byB0aGUgZW50aXJlIHZvaWNlXG4gIC8vICogYGdyb3Vwc2AgLSBBbiBhcnJheSBvZiBgRnJhY3Rpb25gIHJlcHJlc2VudGluZyBiZWF0IGdyb3VwaW5ncyBmb3IgdGhlIGJlYW1cbiAgQmVhbS5hcHBseUFuZEdldEJlYW1zID0gZnVuY3Rpb24odm9pY2UsIHN0ZW1fZGlyZWN0aW9uLCBncm91cHMpIHtcbiAgICByZXR1cm4gQmVhbS5nZW5lcmF0ZUJlYW1zKHZvaWNlLmdldFRpY2thYmxlcygpLCB7XG4gICAgICBncm91cHM6IGdyb3VwcyxcbiAgICAgIHN0ZW1fZGlyZWN0aW9uOiBzdGVtX2RpcmVjdGlvblxuICAgIH0pO1xuICB9O1xuXG4gIC8vIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGF1dGltYXRpY2FsbHkgYnVpbGQgYmVhbXMgZm9yIGEgdm9pY2Ugd2l0aFxuICAvLyBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gIC8vXG4gIC8vIEV4YW1wbGUgY29uZmlndXJhdGlvbiBvYmplY3Q6XG4gIC8vXG4gIC8vIGBgYFxuICAvLyBjb25maWcgPSB7XG4gIC8vICAgZ3JvdXBzOiBbbmV3IFZleC5GbG93LkZyYWN0aW9uKDIsIDgpXSxcbiAgLy8gICBzdGVtX2RpcmVjdGlvbjogLTEsXG4gIC8vICAgYmVhbV9yZXN0czogdHJ1ZSxcbiAgLy8gICBiZWFtX21pZGRsZV9vbmx5OiB0cnVlLFxuICAvLyAgIHNob3dfc3RlbWxldHM6IGZhbHNlXG4gIC8vIH07XG4gIC8vIGBgYFxuICAvL1xuICAvLyBQYXJhbWV0ZXJzOlxuICAvLyAqIGBub3Rlc2AgLSBBbiBhcnJheSBvZiBub3RlcyB0byBjcmVhdGUgdGhlIGJlYW1zIGZvclxuICAvLyAqIGBjb25maWdgIC0gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gIC8vICAgICogYGdyb3Vwc2AgLSBBcnJheSBvZiBgRnJhY3Rpb25zYCB0aGF0IHJlcHJlc2VudCB0aGUgYmVhdCBzdHJ1Y3R1cmUgdG8gYmVhbSB0aGUgbm90ZXNcbiAgLy8gICAgKiBgc3RlbV9kaXJlY3Rpb25gIC0gU2V0IHRvIGFwcGx5IHRoZSBzYW1lIGRpcmVjdGlvbiB0byBhbGwgbm90ZXNcbiAgLy8gICAgKiBgYmVhbV9yZXN0c2AgLSBTZXQgdG8gYHRydWVgIHRvIGluY2x1ZGUgcmVzdHMgaW4gdGhlIGJlYW1zXG4gIC8vICAgICogYGJlYW1fbWlkZGxlX29ubHlgIC0gU2V0IHRvIGB0cnVlYCB0byBvbmx5IGJlYW0gcmVzdHMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgYmVhdFxuICAvLyAgICAqIGBzaG93X3N0ZW1sZXRzYCAtIFNldCB0byBgdHJ1ZWAgdG8gZHJhdyBzdGVtbGV0cyBmb3IgcmVzdHNcbiAgLy8gICAgKiBgbWFpbnRhaW5fc3RlbV9kaXJlY3Rpb25zYCAtIFNldCB0byBgdHJ1ZWAgdG8gbm90IGFwcGx5IG5ldyBzdGVtIGRpcmVjdGlvbnNcbiAgLy9cbiAgQmVhbS5nZW5lcmF0ZUJlYW1zID0gZnVuY3Rpb24obm90ZXMsIGNvbmZpZykge1xuXG4gICAgaWYgKCFjb25maWcpIGNvbmZpZyA9IHt9O1xuXG4gICAgaWYgKCFjb25maWcuZ3JvdXBzIHx8ICFjb25maWcuZ3JvdXBzLmxlbmd0aCkge1xuICAgICAgY29uZmlnLmdyb3VwcyA9IFtuZXcgVmV4LkZsb3cuRnJhY3Rpb24oMiwgOCldO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgYmVhbSBncm91cHMgdG8gdGljayBhbW91bnRzXG4gICAgdmFyIHRpY2tHcm91cHMgPSBjb25maWcuZ3JvdXBzLm1hcChmdW5jdGlvbihncm91cCkge1xuICAgICAgaWYgKCFncm91cC5tdWx0aXBseSkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkludmFsaWRCZWFtR3JvdXBzXCIsXG4gICAgICAgICAgXCJUaGUgYmVhbSBncm91cHMgbXVzdCBiZSBhbiBhcnJheSBvZiBWZXguRmxvdy5GcmFjdGlvbnNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXAuY2xvbmUoKS5tdWx0aXBseShWZXguRmxvdy5SRVNPTFVUSU9OLCAxKTtcbiAgICB9KTtcblxuICAgIHZhciB1bnByb2Nlc3NlZE5vdGVzID0gbm90ZXM7XG4gICAgdmFyIGN1cnJlbnRUaWNrR3JvdXAgPSAwO1xuICAgIHZhciBub3RlR3JvdXBzICAgICAgID0gW107XG4gICAgdmFyIGN1cnJlbnRHcm91cCAgICAgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGdldFRvdGFsVGlja3ModmZfbm90ZXMpe1xuICAgICAgcmV0dXJuIHZmX25vdGVzLnJlZHVjZShmdW5jdGlvbihtZW1vLG5vdGUpe1xuICAgICAgICByZXR1cm4gbm90ZS5nZXRUaWNrcygpLmNsb25lKCkuYWRkKG1lbW8pO1xuICAgICAgfSwgbmV3IFZleC5GbG93LkZyYWN0aW9uKDAsIDEpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0VGlja0dyb3VwKCkge1xuICAgICAgaWYgKHRpY2tHcm91cHMubGVuZ3RoIC0gMSA+IGN1cnJlbnRUaWNrR3JvdXApIHtcbiAgICAgICAgY3VycmVudFRpY2tHcm91cCArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFRpY2tHcm91cCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlR3JvdXBzKCl7XG4gICAgICB2YXIgbmV4dEdyb3VwID0gW107XG5cbiAgICAgIHVucHJvY2Vzc2VkTm90ZXMuZm9yRWFjaChmdW5jdGlvbih1bnByb2Nlc3NlZE5vdGUpe1xuICAgICAgICBuZXh0R3JvdXAgICAgPSBbXTtcbiAgICAgICAgaWYgKHVucHJvY2Vzc2VkTm90ZS5zaG91bGRJZ25vcmVUaWNrcygpKSB7XG4gICAgICAgICAgbm90ZUdyb3Vwcy5wdXNoKGN1cnJlbnRHcm91cCk7XG4gICAgICAgICAgY3VycmVudEdyb3VwID0gbmV4dEdyb3VwO1xuICAgICAgICAgIHJldHVybjsgLy8gSWdub3JlIHVudGlja2FibGVzIChsaWtlIGJhciBub3RlcylcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRHcm91cC5wdXNoKHVucHJvY2Vzc2VkTm90ZSk7XG4gICAgICAgIHZhciB0aWNrc1Blckdyb3VwID0gdGlja0dyb3Vwc1tjdXJyZW50VGlja0dyb3VwXS5jbG9uZSgpO1xuICAgICAgICB2YXIgdG90YWxUaWNrcyA9IGdldFRvdGFsVGlja3MoY3VycmVudEdyb3VwKTtcblxuICAgICAgICAvLyBEb3VibGUgdGhlIGFtb3VudCBvZiB0aWNrcyBpbiBhIGdyb3VwLCBpZiBpdCdzIGFuIHVuYmVhbWFibGUgdHVwbGV0XG4gICAgICAgIHZhciB1bmJlYW1hYmxlID0gVmV4LkZsb3cuZHVyYXRpb25Ub051bWJlcih1bnByb2Nlc3NlZE5vdGUuZHVyYXRpb24pIDwgODtcbiAgICAgICAgaWYgKHVuYmVhbWFibGUgJiYgdW5wcm9jZXNzZWROb3RlLnR1cGxldCkge1xuICAgICAgICAgIHRpY2tzUGVyR3JvdXAubnVtZXJhdG9yICo9IDI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgbm90ZSB0aGF0IHdhcyBqdXN0IGFkZGVkIG92ZXJmbG93cyB0aGUgZ3JvdXAgdGljayB0b3RhbFxuICAgICAgICBpZiAodG90YWxUaWNrcy5ncmVhdGVyVGhhbih0aWNrc1Blckdyb3VwKSkge1xuICAgICAgICAgIC8vIElmIHRoZSBvdmVyZmxvdyBub3RlIGNhbiBiZSBiZWFtZWQsIHN0YXJ0IHRoZSBuZXh0IGdyb3VwXG4gICAgICAgICAgLy8gd2l0aCBpdC4gVW5iZWFtYWJsZSBub3RlcyBsZWF2ZSB0aGUgZ3JvdXAgb3ZlcmZsb3dlZC5cbiAgICAgICAgICBpZiAoIXVuYmVhbWFibGUpIHtcbiAgICAgICAgICAgIG5leHRHcm91cC5wdXNoKGN1cnJlbnRHcm91cC5wb3AoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vdGVHcm91cHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgICAgICAgIGN1cnJlbnRHcm91cCA9IG5leHRHcm91cDtcbiAgICAgICAgICBuZXh0VGlja0dyb3VwKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodG90YWxUaWNrcy5lcXVhbHModGlja3NQZXJHcm91cCkpIHtcbiAgICAgICAgICBub3RlR3JvdXBzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICAgICAgICBjdXJyZW50R3JvdXAgPSBuZXh0R3JvdXA7XG4gICAgICAgICAgbmV4dFRpY2tHcm91cCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkcyBhbnkgcmVtYWluZGVyIG5vdGVzXG4gICAgICBpZiAoY3VycmVudEdyb3VwLmxlbmd0aCA+IDApXG4gICAgICAgIG5vdGVHcm91cHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJlYW1Hcm91cHMoKSB7XG4gICAgICByZXR1cm4gbm90ZUdyb3Vwcy5maWx0ZXIoZnVuY3Rpb24oZ3JvdXApe1xuICAgICAgICAgIGlmIChncm91cC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgYmVhbWFibGUgPSB0cnVlO1xuICAgICAgICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbihub3RlKSB7XG4gICAgICAgICAgICAgIGlmIChub3RlLmdldEludHJpbnNpY1RpY2tzKCkgPj0gVmV4LkZsb3cuZHVyYXRpb25Ub1RpY2tzKFwiNFwiKSkge1xuICAgICAgICAgICAgICAgIGJlYW1hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJlYW1hYmxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTcGxpdHMgdXAgZ3JvdXBzIGJ5IFJlc3RcbiAgICBmdW5jdGlvbiBzYW5pdGl6ZUdyb3VwcygpIHtcbiAgICAgIHZhciBzYW5pdGl6ZWRHcm91cHMgPSBbXTtcbiAgICAgIG5vdGVHcm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCkge1xuICAgICAgICB2YXIgdGVtcEdyb3VwID0gW107XG4gICAgICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24obm90ZSwgaW5kZXgsIGdyb3VwKSB7XG4gICAgICAgICAgdmFyIGlzRmlyc3RPckxhc3QgPSBpbmRleCA9PT0gMCB8fCBpbmRleCA9PT0gZ3JvdXAubGVuZ3RoIC0gMTtcbiAgICAgICAgICB2YXIgcHJldk5vdGUgPSBncm91cFtpbmRleC0xXTtcblxuICAgICAgICAgIHZhciBicmVha3NPbkVhY2hSZXN0ID0gIWNvbmZpZy5iZWFtX3Jlc3RzICYmIG5vdGUuaXNSZXN0KCk7XG4gICAgICAgICAgdmFyIGJyZWFrc09uRmlyc3RPckxhc3RSZXN0ID0gKGNvbmZpZy5iZWFtX3Jlc3RzICYmXG4gICAgICAgICAgICBjb25maWcuYmVhbV9taWRkbGVfb25seSAmJiBub3RlLmlzUmVzdCgpICYmIGlzRmlyc3RPckxhc3QpO1xuXG4gICAgICAgICAgdmFyIGJyZWFrT25TdGVtQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGNvbmZpZy5tYWludGFpbl9zdGVtX2RpcmVjdGlvbnMgJiYgcHJldk5vdGUgJiZcbiAgICAgICAgICAgICAgIW5vdGUuaXNSZXN0KCkgJiYgIXByZXZOb3RlLmlzUmVzdCgpKSB7XG4gICAgICAgICAgICB2YXIgcHJldkRpcmVjdGlvbiA9IHByZXZOb3RlLmdldFN0ZW1EaXJlY3Rpb24oKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RGlyZWN0aW9uID0gbm90ZS5nZXRTdGVtRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICBicmVha09uU3RlbUNoYW5nZSA9IGN1cnJlbnREaXJlY3Rpb24gIT09IHByZXZEaXJlY3Rpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlzVW5iZWFtYWJsZUR1cmF0aW9uID0gcGFyc2VJbnQobm90ZS5kdXJhdGlvbiwgMTApIDwgODtcblxuICAgICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgZ3JvdXAgc2hvdWxkIGJlIGJyb2tlbiBhdCB0aGlzIG5vdGVcbiAgICAgICAgICB2YXIgc2hvdWxkQnJlYWsgPSBicmVha3NPbkVhY2hSZXN0IHx8IGJyZWFrc09uRmlyc3RPckxhc3RSZXN0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtPblN0ZW1DaGFuZ2UgfHwgaXNVbmJlYW1hYmxlRHVyYXRpb247XG5cbiAgICAgICAgICBpZiAoc2hvdWxkQnJlYWspIHtcbiAgICAgICAgICAgIC8vIEFkZCBjdXJyZW50IGdyb3VwXG4gICAgICAgICAgICBpZiAodGVtcEdyb3VwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgc2FuaXRpemVkR3JvdXBzLnB1c2godGVtcEdyb3VwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RhcnQgYSBuZXcgZ3JvdXAuIEluY2x1ZGUgdGhlIGN1cnJlbnQgbm90ZSBpZiB0aGUgZ3JvdXBcbiAgICAgICAgICAgIC8vIHdhcyBicm9rZW4gdXAgYnkgc3RlbSBkaXJlY3Rpb24sIGFzIHRoYXQgbm90ZSBuZWVkcyB0byBzdGFydFxuICAgICAgICAgICAgLy8gdGhlIG5leHQgZ3JvdXAgb2Ygbm90ZXNcbiAgICAgICAgICAgIHRlbXBHcm91cCA9IGJyZWFrT25TdGVtQ2hhbmdlID8gW25vdGVdIDogW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCBub3RlIHRvIGdyb3VwXG4gICAgICAgICAgICB0ZW1wR3JvdXAucHVzaChub3RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVtYWluaW5nIGdyb3VwLCBhZGQgaXQgYXMgd2VsbFxuICAgICAgICBpZiAodGVtcEdyb3VwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzYW5pdGl6ZWRHcm91cHMucHVzaCh0ZW1wR3JvdXApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbm90ZUdyb3VwcyA9IHNhbml0aXplZEdyb3VwcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRTdGVtcygpIHtcbiAgICAgIG5vdGVHcm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCl7XG4gICAgICAgIHZhciBzdGVtRGlyZWN0aW9uO1xuICAgICAgICBpZiAoY29uZmlnLm1haW50YWluX3N0ZW1fZGlyZWN0aW9ucykge1xuICAgICAgICAgIHZhciBub3RlID0gZmluZEZpcnN0Tm90ZShncm91cCk7XG4gICAgICAgICAgc3RlbURpcmVjdGlvbiA9IG5vdGUgPyBub3RlLmdldFN0ZW1EaXJlY3Rpb24oKSA6IFN0ZW0uVVA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy5zdGVtX2RpcmVjdGlvbil7XG4gICAgICAgICAgICBzdGVtRGlyZWN0aW9uID0gY29uZmlnLnN0ZW1fZGlyZWN0aW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGVtRGlyZWN0aW9uID0gY2FsY3VsYXRlU3RlbURpcmVjdGlvbihncm91cCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcGx5U3RlbURpcmVjdGlvbihncm91cCwgc3RlbURpcmVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kRmlyc3ROb3RlKGdyb3VwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub3RlID0gZ3JvdXBbaV07XG4gICAgICAgIGlmICghbm90ZS5pc1Jlc3QoKSkge1xuICAgICAgICAgIHJldHVybiBub3RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVN0ZW1EaXJlY3Rpb24oZ3JvdXAsIGRpcmVjdGlvbikge1xuICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbihub3RlKXtcbiAgICAgICAgbm90ZS5zZXRTdGVtRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUdXBsZXRHcm91cHMoKSB7XG4gICAgICByZXR1cm4gbm90ZUdyb3Vwcy5maWx0ZXIoZnVuY3Rpb24oZ3JvdXApe1xuICAgICAgICBpZiAoZ3JvdXBbMF0pIHJldHVybiBncm91cFswXS50dXBsZXQ7XG4gICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8vIFVzaW5nIGNsb3N1cmVzIHRvIHN0b3JlIHRoZSB2YXJpYWJsZXMgdGhyb3VnaG91dCB0aGUgdmFyaW91cyBmdW5jdGlvbnNcbiAgICAvLyBJTU8gS2VlcHMgaXQgdGhpcyBwcm9jZXNzIGxvdCBjbGVhbmVyIC0gYnV0IG5vdCBzdXBlciBjb25zaXN0ZW50IHdpdGhcbiAgICAvLyB0aGUgcmVzdCBvZiB0aGUgQVBJJ3Mgc3R5bGUgLSBTaWx2ZXJ3b2xmOTAgKEN5cmlsKVxuICAgIGNyZWF0ZUdyb3VwcygpO1xuICAgIHNhbml0aXplR3JvdXBzKCk7XG4gICAgZm9ybWF0U3RlbXMoKTtcblxuICAgIC8vIEdldCB0aGUgbm90ZXMgdG8gYmUgYmVhbWVkXG4gICAgdmFyIGJlYW1lZE5vdGVHcm91cHMgPSBnZXRCZWFtR3JvdXBzKCk7XG5cbiAgICAvLyBHZXQgdGhlIHR1cGxldHMgaW4gb3JkZXIgdG8gZm9ybWF0IHRoZW0gYWNjdXJhdGVseVxuICAgIHZhciB0dXBsZXRHcm91cHMgPSBnZXRUdXBsZXRHcm91cHMoKTtcblxuICAgIC8vIENyZWF0ZSBhIFZleC5GbG93LkJlYW0gZnJvbSBlYWNoIGdyb3VwIG9mIG5vdGVzIHRvIGJlIGJlYW1lZFxuICAgIHZhciBiZWFtcyA9IFtdO1xuICAgIGJlYW1lZE5vdGVHcm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCl7XG4gICAgICB2YXIgYmVhbSA9IG5ldyBWZXguRmxvdy5CZWFtKGdyb3VwKTtcblxuICAgICAgaWYgKGNvbmZpZy5zaG93X3N0ZW1sZXRzKSB7XG4gICAgICAgIGJlYW0ucmVuZGVyX29wdGlvbnMuc2hvd19zdGVtbGV0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLnNlY29uZGFyeV9icmVha3MpIHtcbiAgICAgICAgYmVhbS5yZW5kZXJfb3B0aW9ucy5zZWNvbmRhcnlfYnJlYWtfdGlja3MgPSBWZXguRmxvdy5kdXJhdGlvblRvVGlja3MoY29uZmlnLnNlY29uZGFyeV9icmVha3MpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5mbGF0X2JlYW1zID09PSB0cnVlKSB7XG4gICAgICAgIGJlYW0ucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtcyA9IHRydWU7XG4gICAgICAgIGJlYW0ucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtX29mZnNldCA9IGNvbmZpZy5mbGF0X2JlYW1fb2Zmc2V0O1xuICAgICAgfVxuICAgICAgYmVhbXMucHVzaChiZWFtKTtcbiAgICB9KTtcblxuICAgIC8vIFJlZm9ybWF0IHR1cGxldHNcbiAgICB0dXBsZXRHcm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCl7XG4gICAgICB2YXIgZmlyc3ROb3RlID0gZ3JvdXBbMF07XG4gICAgICBmb3IgKHZhciBpPTA7IGk8Z3JvdXAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGdyb3VwW2ldLmhhc1N0ZW0oKSkge1xuICAgICAgICAgIGZpcnN0Tm90ZSA9IGdyb3VwW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0dXBsZXQgPSBmaXJzdE5vdGUudHVwbGV0O1xuXG4gICAgICBpZiAoZmlyc3ROb3RlLmJlYW0pIHR1cGxldC5zZXRCcmFja2V0ZWQoZmFsc2UpO1xuICAgICAgaWYgKGZpcnN0Tm90ZS5zdGVtX2RpcmVjdGlvbiA9PSBTdGVtLkRPV04pIHtcbiAgICAgICAgdHVwbGV0LnNldFR1cGxldExvY2F0aW9uKFZleC5GbG93LlR1cGxldC5MT0NBVElPTl9CT1RUT00pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJlYW1zO1xuICB9O1xuXG4gIHJldHVybiBCZWFtO1xufSgpKTtcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBUaGlzIGZpbGUgaW1wbGVtZW50cyB0aGUgbWFpbiBWb2ljZSBjbGFzcy4gSXQncyBtYWlubHkgYSBjb250YWluZXJcbi8vIG9iamVjdCB0byBncm91cCBgVGlja2FibGVzYCBmb3IgZm9ybWF0dGluZy5cblZleC5GbG93LlZvaWNlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBWb2ljZSh0aW1lKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGltZSk7XG4gIH1cblxuICAvLyBNb2RlcyBhbGxvdyB0aGUgYWRkaXRpb24gb2YgdGlja3MgaW4gdGhyZWUgZGlmZmVyZW50IHdheXM6XG4gIC8vXG4gIC8vIFNUUklDVDogVGhpcyBpcyB0aGUgZGVmYXVsdC4gVGlja3MgbXVzdCBmaWxsIHRoZSB2b2ljZS5cbiAgLy8gU09GVDogICBUaWNrcyBjYW4gYmUgYWRkZWQgd2l0aG91dCByZXN0cmljdGlvbnMuXG4gIC8vIEZVTEw6ICAgVGlja3MgZG8gbm90IG5lZWQgdG8gZmlsbCB0aGUgdm9pY2UsIGJ1dCBjYW4ndCBleGNlZWQgdGhlIG1heGltdW1cbiAgLy8gICAgICAgICB0aWNrIGxlbmd0aC5cbiAgVm9pY2UuTW9kZSA9IHtcbiAgICBTVFJJQ1Q6IDEsXG4gICAgU09GVDogICAyLFxuICAgIEZVTEw6ICAgM1xuICB9O1xuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIFZvaWNlLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbih0aW1lKSB7XG4gICAgICB0aGlzLnRpbWUgPSBWZXguTWVyZ2Uoe1xuICAgICAgICBudW1fYmVhdHM6IDQsXG4gICAgICAgIGJlYXRfdmFsdWU6IDQsXG4gICAgICAgIHJlc29sdXRpb246IFZleC5GbG93LlJFU09MVVRJT05cbiAgICAgIH0sIHRpbWUpO1xuXG4gICAgICAvLyBSZWNhbGN1bGF0ZSB0b3RhbCB0aWNrcy5cbiAgICAgIHRoaXMudG90YWxUaWNrcyA9IG5ldyBWZXguRmxvdy5GcmFjdGlvbihcbiAgICAgICAgdGhpcy50aW1lLm51bV9iZWF0cyAqICh0aGlzLnRpbWUucmVzb2x1dGlvbiAvIHRoaXMudGltZS5iZWF0X3ZhbHVlKSwgMSk7XG5cbiAgICAgIHRoaXMucmVzb2x1dGlvbk11bHRpcGxpZXIgPSAxO1xuXG4gICAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICAgIHRoaXMudGlja2FibGVzID0gW107XG4gICAgICB0aGlzLnRpY2tzVXNlZCA9IG5ldyBWZXguRmxvdy5GcmFjdGlvbigwLCAxKTtcbiAgICAgIHRoaXMuc21hbGxlc3RUaWNrQ291bnQgPSB0aGlzLnRvdGFsVGlja3MuY2xvbmUoKTtcbiAgICAgIHRoaXMubGFyZ2VzdFRpY2tXaWR0aCA9IDA7XG4gICAgICB0aGlzLnN0YXZlID0gbnVsbDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuICAgICAgLy8gRG8gd2UgY2FyZSBhYm91dCBzdHJpY3RseSB0aW1lZCBub3Rlc1xuICAgICAgdGhpcy5tb2RlID0gVmV4LkZsb3cuVm9pY2UuTW9kZS5TVFJJQ1Q7XG5cbiAgICAgIC8vIFRoaXMgbXVzdCBiZWxvbmcgdG8gYSBWb2ljZUdyb3VwXG4gICAgICB0aGlzLnZvaWNlR3JvdXAgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHRvdGFsIHRpY2tzIGluIHRoZSB2b2ljZVxuICAgIGdldFRvdGFsVGlja3M6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50b3RhbFRpY2tzOyB9LFxuXG4gICAgLy8gR2V0IHRoZSB0b3RhbCB0aWNrcyB1c2VkIGluIHRoZSB2b2ljZSBieSBhbGwgdGhlIHRpY2thYmxlc1xuICAgIGdldFRpY2tzVXNlZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRpY2tzVXNlZDsgfSxcblxuICAgIC8vIEdldCB0aGUgbGFyZ2VzdCB3aWR0aCBvZiBhbGwgdGhlIHRpY2thYmxlc1xuICAgIGdldExhcmdlc3RUaWNrV2lkdGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5sYXJnZXN0VGlja1dpZHRoOyB9LFxuXG4gICAgLy8gR2V0IHRoZSB0aWNrIGNvdW50IGZvciB0aGUgc2hvcnRlc3QgdGlja2FibGVcbiAgICBnZXRTbWFsbGVzdFRpY2tDb3VudDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNtYWxsZXN0VGlja0NvdW50OyB9LFxuXG4gICAgLy8gR2V0IHRoZSB0aWNrYWJsZXMgaW4gdGhlIHZvaWNlXG4gICAgZ2V0VGlja2FibGVzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudGlja2FibGVzOyB9LFxuXG4gICAgLy8gR2V0L3NldCB0aGUgdm9pY2UgbW9kZSwgdXNlIGEgdmFsdWUgZnJvbSBgVm9pY2UuTW9kZWBcbiAgICBnZXRNb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubW9kZTsgfSxcbiAgICBzZXRNb2RlOiBmdW5jdGlvbihtb2RlKSB7IHRoaXMubW9kZSA9IG1vZGU7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gR2V0IHRoZSByZXNvbHV0aW9uIG11bHRpcGxpZXIgZm9yIHRoZSB2b2ljZVxuICAgIGdldFJlc29sdXRpb25NdWx0aXBsaWVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucmVzb2x1dGlvbk11bHRpcGxpZXI7IH0sXG5cbiAgICAvLyBHZXQgdGhlIGFjdHVhbCB0aWNrIHJlc29sdXRpb24gZm9yIHRoZSB2b2ljZVxuICAgIGdldEFjdHVhbFJlc29sdXRpb246IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5yZXNvbHV0aW9uTXVsdGlwbGllciAqIHRoaXMudGltZS5yZXNvbHV0aW9uOyB9LFxuXG4gICAgLy8gU2V0IHRoZSB2b2ljZSdzIHN0YXZlXG4gICAgc2V0U3RhdmU6IGZ1bmN0aW9uKHN0YXZlKSB7XG4gICAgICB0aGlzLnN0YXZlID0gc3RhdmU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDsgLy8gUmVzZXQgYm91bmRpbmcgYm94IHNvIHdlIGNhbiByZWZvcm1hdFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgYm91bmRpbmcgYm94IGZvciB0aGUgdm9pY2VcbiAgICBnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhdmUsIGJvdW5kaW5nQm94LCBiYiwgaTtcblxuICAgICAgaWYgKCF0aGlzLmJvdW5kaW5nQm94KSB7XG4gICAgICAgIGlmICghdGhpcy5zdGF2ZSkgdGhyb3cgVmV4LlJFUlIoXCJOb1N0YXZlXCIsIFwiQ2FuJ3QgZ2V0IGJvdW5kaW5nIGJveCB3aXRob3V0IHN0YXZlLlwiKTtcbiAgICAgICAgc3RhdmUgPSB0aGlzLnN0YXZlO1xuICAgICAgICBib3VuZGluZ0JveCA9IG51bGw7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudGlja2FibGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdGhpcy50aWNrYWJsZXNbaV0uc2V0U3RhdmUoc3RhdmUpO1xuXG4gICAgICAgICAgYmIgPSB0aGlzLnRpY2thYmxlc1tpXS5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgICAgIGlmICghYmIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveCA/IGJvdW5kaW5nQm94Lm1lcmdlV2l0aChiYikgOiBiYjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nQm94O1xuICAgIH0sXG5cbiAgICAvLyBFdmVyeSB0aWNrYWJsZSBtdXN0IGJlIGFzc29jaWF0ZWQgd2l0aCBhIHZvaWNlR3JvdXAuIFRoaXMgYWxsb3dzIGZvcm1hdHRlcnNcbiAgICAvLyBhbmQgcHJlZm9ybWF0dGVycyB0byBhc3NvY2lhdGUgdGhlbSB3aXRoIHRoZSByaWdodCBtb2RpZmllckNvbnRleHRzLlxuICAgIGdldFZvaWNlR3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnZvaWNlR3JvdXApXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIk5vVm9pY2VHcm91cFwiLCBcIk5vIHZvaWNlIGdyb3VwIGZvciB2b2ljZS5cIik7XG4gICAgICByZXR1cm4gdGhpcy52b2ljZUdyb3VwO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIHZvaWNlIGdyb3VwXG4gICAgc2V0Vm9pY2VHcm91cDogZnVuY3Rpb24oZykgeyB0aGlzLnZvaWNlR3JvdXAgPSBnOyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIFNldCB0aGUgdm9pY2UgbW9kZSB0byBzdHJpY3Qgb3Igc29mdCBcbiAgICBzZXRTdHJpY3Q6IGZ1bmN0aW9uKHN0cmljdCkge1xuICAgICAgdGhpcy5tb2RlID0gc3RyaWN0ID8gVmV4LkZsb3cuVm9pY2UuTW9kZS5TVFJJQ1QgOiBWZXguRmxvdy5Wb2ljZS5Nb2RlLlNPRlQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSB2b2ljZSBpcyBjb21wbGV0ZSBhY2NvcmRpbmcgdG8gdGhlIHZvaWNlIG1vZGVcbiAgICBpc0NvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLm1vZGUgPT0gVmV4LkZsb3cuVm9pY2UuTW9kZS5TVFJJQ1QgfHxcbiAgICAgICAgICB0aGlzLm1vZGUgPT0gVmV4LkZsb3cuVm9pY2UuTW9kZS5GVUxMKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpY2tzVXNlZC5lcXVhbHModGhpcy50b3RhbFRpY2tzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBBZGQgYSB0aWNrYWJsZSB0byB0aGUgdm9pY2VcbiAgICBhZGRUaWNrYWJsZTogZnVuY3Rpb24odGlja2FibGUpIHtcbiAgICAgIGlmICghdGlja2FibGUuc2hvdWxkSWdub3JlVGlja3MoKSkge1xuICAgICAgICB2YXIgdGlja3MgPSB0aWNrYWJsZS5nZXRUaWNrcygpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdG90YWwgdGlja3MgZm9yIHRoaXMgbGluZS5cbiAgICAgICAgdGhpcy50aWNrc1VzZWQuYWRkKHRpY2tzKTtcblxuICAgICAgICBpZiAoKHRoaXMubW9kZSA9PSBWZXguRmxvdy5Wb2ljZS5Nb2RlLlNUUklDVCB8fFxuICAgICAgICAgICAgIHRoaXMubW9kZSA9PSBWZXguRmxvdy5Wb2ljZS5Nb2RlLkZVTEwpICYmXG4gICAgICAgICAgICAgdGhpcy50aWNrc1VzZWQuZ3JlYXRlclRoYW4odGhpcy50b3RhbFRpY2tzKSkge1xuICAgICAgICAgIHRoaXMudG90YWxUaWNrcy5zdWJ0cmFjdCh0aWNrcyk7XG4gICAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRcIiwgXCJUb28gbWFueSB0aWNrcy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjayB0aGUgc21hbGxlc3QgdGlja2FibGUgZm9yIGZvcm1hdHRpbmcuXG4gICAgICAgIGlmICh0aWNrcy5sZXNzVGhhbih0aGlzLnNtYWxsZXN0VGlja0NvdW50KSkge1xuICAgICAgICAgIHRoaXMuc21hbGxlc3RUaWNrQ291bnQgPSB0aWNrcy5jbG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uTXVsdGlwbGllciA9IHRoaXMudGlja3NVc2VkLmRlbm9taW5hdG9yO1xuXG4gICAgICAgIC8vIEV4cGFuZCB0b3RhbCB0aWNrcyB1c2luZyBkZW5vbWluYXRvciBmcm9tIHRpY2tzIHVzZWQuXG4gICAgICAgIHRoaXMudG90YWxUaWNrcy5hZGQoMCwgdGhpcy50aWNrc1VzZWQuZGVub21pbmF0b3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIHRpY2thYmxlIHRvIHRoZSBsaW5lLlxuICAgICAgdGhpcy50aWNrYWJsZXMucHVzaCh0aWNrYWJsZSk7XG4gICAgICB0aWNrYWJsZS5zZXRWb2ljZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYW4gYXJyYXkgb2YgdGlja2FibGVzIHRvIHRoZSB2b2ljZS5cbiAgICBhZGRUaWNrYWJsZXM6IGZ1bmN0aW9uKHRpY2thYmxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrYWJsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5hZGRUaWNrYWJsZSh0aWNrYWJsZXNbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUHJlZm9ybWF0cyB0aGUgdm9pY2UgYnkgYXBwbHlpbmcgdGhlIHZvaWNlJ3Mgc3RhdmUgdG8gZWFjaCBub3RlLlxuICAgIHByZUZvcm1hdDogZnVuY3Rpb24oKXtcbiAgICAgIGlmICh0aGlzLnByZUZvcm1hdHRlZCkgcmV0dXJuO1xuXG4gICAgICB0aGlzLnRpY2thYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKHRpY2thYmxlKSB7XG4gICAgICAgIGlmICghdGlja2FibGUuZ2V0U3RhdmUoKSkge1xuICAgICAgICAgIHRpY2thYmxlLnNldFN0YXZlKHRoaXMuc3RhdmUpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbmRlciB0aGUgdm9pY2Ugb250byB0aGUgY2FudmFzIGBjb250ZXh0YCBhbmQgYW4gb3B0aW9uYWwgYHN0YXZlYC5cbiAgICAvLyBJZiBgc3RhdmVgIGlzIG9taXR0ZWQsIGl0IGlzIGV4cGVjdGVkIHRoYXQgdGhlIG5vdGVzIGhhdmUgc3RhdmVzXG4gICAgLy8gYWxyZWFkeSBzZXQuXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc3RhdmUpIHtcbiAgICAgIHZhciBib3VuZGluZ0JveCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGlja2FibGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB0aWNrYWJsZSA9IHRoaXMudGlja2FibGVzW2ldO1xuXG4gICAgICAgIC8vIFNldCB0aGUgc3RhdmUgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKHN0YXZlKSB0aWNrYWJsZS5zZXRTdGF2ZShzdGF2ZSk7XG5cbiAgICAgICAgaWYgKCF0aWNrYWJsZS5nZXRTdGF2ZSgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJNaXNzaW5nU3RhdmVcIixcbiAgICAgICAgICAgIFwiVGhlIHZvaWNlIGNhbm5vdCBkcmF3IHRpY2thYmxlcyB3aXRob3V0IHN0YXZlcy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA9PT0gMCkgYm91bmRpbmdCb3ggPSB0aWNrYWJsZS5nZXRCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIGlmIChpID4gMCAmJiBib3VuZGluZ0JveCkge1xuICAgICAgICAgIHZhciB0aWNrYWJsZV9iYiA9IHRpY2thYmxlLmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgaWYgKHRpY2thYmxlX2JiKSBib3VuZGluZ0JveC5tZXJnZVdpdGgodGlja2FibGVfYmIpO1xuICAgICAgICB9XG5cbiAgICAgICB0aWNrYWJsZS5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgIHRpY2thYmxlLmRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVm9pY2U7XG59KCkpO1xuLy8gVmV4IE11c2ljIE5vdGF0aW9uXG4vLyBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy9cbi8vIENvcHlyaWdodCBNb2hpdCBNdXRoYW5uYSAyMDEwXG5cbi8qKiBAY29uc3RydWN0b3IgKi9cblZleC5GbG93LlZvaWNlR3JvdXAgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFZvaWNlR3JvdXAoKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBWb2ljZUdyb3VwLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudm9pY2VzID0gW107XG4gICAgICB0aGlzLm1vZGlmaWVyQ29udGV4dHMgPSBbXTtcbiAgICB9LFxuXG4gICAgLy8gRXZlcnkgdGlja2FibGUgbXVzdCBiZSBhc3NvY2lhdGVkIHdpdGggYSB2b2ljZUdyb3VwLiBUaGlzIGFsbG93cyBmb3JtYXR0ZXJzXG4gICAgLy8gYW5kIHByZWZvcm1hdHRlcnMgdG8gYXNzb2NpYXRlIHRoZW0gd2l0aCB0aGUgcmlnaHQgbW9kaWZpZXJDb250ZXh0cy5cbiAgICBnZXRWb2ljZXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy52b2ljZXM7IH0sXG4gICAgZ2V0TW9kaWZpZXJDb250ZXh0czogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm1vZGlmaWVyQ29udGV4dHM7IH0sXG5cbiAgICBhZGRWb2ljZTogZnVuY3Rpb24odm9pY2UpIHtcbiAgICAgIGlmICghdm9pY2UpIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIlZvaWNlIGNhbm5vdCBiZSBudWxsLlwiKTtcbiAgICAgIHRoaXMudm9pY2VzLnB1c2godm9pY2UpO1xuICAgICAgdm9pY2Uuc2V0Vm9pY2VHcm91cCh0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFZvaWNlR3JvdXA7XG59KCkpO1xuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBgTW9kaWZpZXJgIGlzIGFuIGFic3RyYWN0IGludGVyZmFjZSBmb3Igbm90YXRpb25hbCBlbGVtZW50cyB0aGF0IG1vZGlmeVxuLy8gYSBgTm90ZWAuIEV4YW1wbGVzIG9mIG1vZGlmaWVycyBhcmUgYEFjY2lkZW50YWxgLCBgQW5ub3RhdGlvbmAsIGBTdHJva2VgLCBldGMuXG4vL1xuLy8gRm9yIGEgYE1vZGlmaWVyYCBpbnN0YW5jZSB0byBiZSBwb3NpdGlvbmVkIGNvcnJlY3RseSwgaXQgbXVzdCBiZSBwYXJ0IG9mXG4vLyBhIGBNb2RpZmllckNvbnRleHRgLiBBbGwgbW9kaWZpZXJzIGluIHRoZSBzYW1lIGNvbnRleHQgYXJlIHJlbmRlcmVkIHJlbGF0aXZlIHRvXG4vLyBvbmUgYW5vdGhlci5cbi8vXG4vLyBUeXBpY2FsbHksIGFsbCBtb2RpZmllcnMgdG8gYSBub3RlIGFyZSBwYXJ0IG9mIHRoZSBzYW1lIGBNb2RpZmllckNvbnRleHRgIGluc3RhbmNlLiBBbHNvLFxuLy8gaW4gbXVsdGktdm9pY2Ugc3RhdmVzLCBhbGwgbW9kaWZpZXJzIHRvIG5vdGVzIG9uIHRoZSBzYW1lIGB0aWNrYCBhcmUgcGFydCBvZiB0aGUgc2FtZVxuLy8gYE1vZGlmaWVyQ29udGV4dGAuIFRoaXMgZW5zdXJlcyB0aGF0IG11bHRpcGxlIHZvaWNlcyBkb24ndCB0cmFtcGxlIGFsbCBvdmVyIGVhY2ggb3RoZXIuXG5cblZleC5GbG93Lk1vZGlmaWVyID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBNb2RpZmllcigpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gTW9kaWZpZXI7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgTW9kaWZpZXIuQ0FURUdPUlkgPSBcIm5vbmVcIjtcblxuICAgIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93Lk1vZGlmaWVyLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChNb2RpZmllci5ERUJVRykgVmV4LkwoXCJWZXguRmxvdy5Nb2RpZmllclwiLCBhcmd1bWVudHMpOyB9XG5cbiAgLy8gTW9kaWZpZXJzIGNhbiBiZSBwb3NpdGlvbmVkIGFsbW9zdCBhbnl3aGVyZSwgcmVsYXRpdmUgdG8gYSBub3RlLlxuICBNb2RpZmllci5Qb3NpdGlvbiA9IHtcbiAgICBMRUZUOiAxLFxuICAgIFJJR0hUOiAyLFxuICAgIEFCT1ZFOiAzLFxuICAgIEJFTE9XOiA0XG4gIH07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgTW9kaWZpZXIucHJvdG90eXBlID0ge1xuXG4gICAgLy8gVGhlIGNvbnN0cnVjdG9yIHNldHMgaW5pdGlhbCB3aWR0aHMgYW5kIGNvbnN0YW50cy5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgICAgLy8gTW9kaWZpZXJzIGFyZSBhdHRhY2hlZCB0byBhIG5vdGUgYW5kIGFuIGluZGV4LiBBbiBpbmRleCBpcyBhXG4gICAgICAvLyBzcGVjaWZpYyBoZWFkIGluIGEgY2hvcmQuXG4gICAgICB0aGlzLm5vdGUgPSBudWxsO1xuICAgICAgdGhpcy5pbmRleCA9IG51bGw7XG5cbiAgICAgIC8vIFRoZSBgdGV4dF9saW5lYCBpcyByZXNlcnZlZCBzcGFjZSBhYm92ZSBvciBiZWxvdyBhIHN0YXZlLlxuICAgICAgdGhpcy50ZXh0X2xpbmUgPSAwO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IE1vZGlmaWVyLlBvc2l0aW9uLkxFRlQ7XG4gICAgICB0aGlzLm1vZGlmaWVyX2NvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy54X3NoaWZ0ID0gMDtcbiAgICAgIHRoaXMueV9zaGlmdCA9IDA7XG4gICAgICB0aGlzLnNwYWNpbmdGcm9tTmV4dE1vZGlmaWVyID0gMDtcbiAgICAgIEwoXCJDcmVhdGVkIG5ldyBtb2RpZmllclwiKTtcbiAgICB9LFxuXG4gICAgLy8gRXZlcnkgbW9kaWZpZXIgaGFzIGEgY2F0ZWdvcnkuIFRoZSBgTW9kaWZpZXJDb250ZXh0YCB1c2VzIHRoaXMgdG8gZGV0ZXJtaW5lXG4gICAgLy8gdGhlIHR5cGUgYW5kIG9yZGVyIG9mIHRoZSBtb2RpZmllcnMuXG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5DQVRFR09SWTsgfSxcblxuICAgIC8vIEdldCBhbmQgc2V0IG1vZGlmaWVyIHdpZHRocy5cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLndpZHRoOyB9LFxuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkgeyB0aGlzLndpZHRoID0gd2lkdGg7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gR2V0IGFuZCBzZXQgYXR0YWNoZWQgbm90ZSAoYFN0YXZlTm90ZWAsIGBUYWJOb3RlYCwgZXRjLilcbiAgICBnZXROb3RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubm90ZTsgfSxcbiAgICBzZXROb3RlOiBmdW5jdGlvbihub3RlKSB7IHRoaXMubm90ZSA9IG5vdGU7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gR2V0IGFuZCBzZXQgbm90ZSBpbmRleCwgd2hpY2ggaXMgYSBzcGVjaWZpYyBub3RlIGluIGEgY2hvcmQuXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfSxcbiAgICBzZXRJbmRleDogZnVuY3Rpb24oaW5kZXgpIHsgdGhpcy5pbmRleCA9IGluZGV4OyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIEdldCBhbmQgc2V0IHJlbmRlcmluZyBjb250ZXh0LlxuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0OyB9LFxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHsgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBFdmVyeSBtb2RpZmllciBtdXN0IGJlIHBhcnQgb2YgYSBgTW9kaWZpZXJDb250ZXh0YC5cbiAgICBnZXRNb2RpZmllckNvbnRleHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5tb2RpZmllcl9jb250ZXh0OyB9LFxuICAgIHNldE1vZGlmaWVyQ29udGV4dDogZnVuY3Rpb24oYykgeyB0aGlzLm1vZGlmaWVyX2NvbnRleHQgPSBjOyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIEdldCBhbmQgc2V0IGFydGljdWxhdGlvbiBwb3NpdGlvbi5cbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnBvc2l0aW9uOyB9LFxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbihwb3NpdGlvbikgeyB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gU2V0IHRoZSBgdGV4dF9saW5lYCBmb3IgdGhlIG1vZGlmaWVyLlxuICAgIHNldFRleHRMaW5lOiBmdW5jdGlvbihsaW5lKSB7IHRoaXMudGV4dF9saW5lID0gbGluZTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBTaGlmdCBtb2RpZmllciBkb3duIGB5YCBwaXhlbHMuIE5lZ2F0aXZlIHZhbHVlcyBzaGlmdCB1cC5cbiAgICBzZXRZU2hpZnQ6IGZ1bmN0aW9uKHkpIHsgdGhpcy55X3NoaWZ0ID0geTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICBzZXRTcGFjaW5nRnJvbU5leHRNb2RpZmllcjogZnVuY3Rpb24oeCkge1xuICAgICAgdGhpcy5zcGFjaW5nRnJvbU5leHRNb2RpZmllciA9IHg7XG4gICAgfSxcblxuICAgIGdldFNwYWNpbmdGcm9tTmV4dE1vZGlmaWVyOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zcGFjaW5nRnJvbU5leHRNb2RpZmllcjsgfSxcblxuICAgIC8vIFNoaWZ0IG1vZGlmaWVyIGB4YCBwaXhlbHMgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbW9kaWZpZXIuIE5lZ2F0aXZlIHZhbHVlc1xuICAgIC8vIHNoaWZ0IHJldmVyc2UuXG4gICAgc2V0WFNoaWZ0OiBmdW5jdGlvbih4KSB7XG4gICAgICB0aGlzLnhfc2hpZnQgPSAwO1xuICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gTW9kaWZpZXIuUG9zaXRpb24uTEVGVCkge1xuICAgICAgICB0aGlzLnhfc2hpZnQgLT0geDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueF9zaGlmdCArPSB4O1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0WFNoaWZ0OiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy54X3NoaWZ0O30sXG5cbiAgICAvLyBSZW5kZXIgdGhlIG1vZGlmaWVyIG9udG8gdGhlIGNhbnZhcy5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgd2l0aG91dCBhIGNhbnZhcyBjb250ZXh0LlwiKTtcbiAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIk1ldGhvZE5vdEltcGxlbWVudGVkXCIsXG4gICAgICAgICAgXCJEcmF3KCkgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIG1vZGlmaWVyLlwiKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1vZGlmaWVyO1xufSgpKTtcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBUaGlzIGNsYXNzIGltcGxlbWVudHMgdmFyaW91cyB0eXBlcyBvZiBtb2RpZmllcnMgdG8gbm90ZXMgKGUuZy4gYmVuZHMsXG4vLyBmaW5nZXJpbmcgcG9zaXRpb25zIGV0Yy4pXG5cblZleC5GbG93Lk1vZGlmaWVyQ29udGV4dCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gTW9kaWZpZXJDb250ZXh0KCkge1xuICAgIC8vIEN1cnJlbnQgbW9kaWZpZXJzXG4gICAgdGhpcy5tb2RpZmllcnMgPSB7fTtcblxuICAgIC8vIEZvcm1hdHRpbmcgZGF0YS5cbiAgICB0aGlzLnByZUZvcm1hdHRlZCA9IGZhbHNlO1xuICAgIHRoaXMucG9zdEZvcm1hdHRlZCA9IGZhbHNlO1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMuc3BhY2luZyA9IDA7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxlZnRfc2hpZnQ6IDAsXG4gICAgICByaWdodF9zaGlmdDogMCxcbiAgICAgIHRleHRfbGluZTogMCxcbiAgICAgIHRvcF90ZXh0X2xpbmU6IDBcbiAgICB9O1xuXG4gICAgLy8gQWRkIG5ldyBtb2RpZmllcnMgdG8gdGhpcyBhcnJheS4gVGhlIG9yZGVyaW5nIGlzIHNpZ25pZmljYW50IC0tIGxvd2VyXG4gICAgLy8gbW9kaWZpZXJzIGFyZSBmb3JtYXR0ZWQgYW5kIHJlbmRlcmVkIGJlZm9yZSBoaWdoZXIgb25lcy5cbiAgICB0aGlzLlBSRUZPUk1BVCA9IFtcbiAgICAgIFZleC5GbG93LlN0YXZlTm90ZSxcbiAgICAgIFZleC5GbG93LkRvdCxcbiAgICAgIFZleC5GbG93LkZyZXRIYW5kRmluZ2VyLFxuICAgICAgVmV4LkZsb3cuQWNjaWRlbnRhbCxcbiAgICAgIFZleC5GbG93LkdyYWNlTm90ZUdyb3VwLFxuICAgICAgVmV4LkZsb3cuU3Ryb2tlLFxuICAgICAgVmV4LkZsb3cuU3RyaW5nTnVtYmVyLFxuICAgICAgVmV4LkZsb3cuQXJ0aWN1bGF0aW9uLFxuICAgICAgVmV4LkZsb3cuT3JuYW1lbnQsXG4gICAgICBWZXguRmxvdy5Bbm5vdGF0aW9uLFxuICAgICAgVmV4LkZsb3cuQmVuZCxcbiAgICAgIFZleC5GbG93LlZpYnJhdG9cbiAgICBdO1xuXG4gICAgLy8gSWYgcG9zdC1mb3JtYXR0aW5nIGlzIHJlcXVpcmVkIGZvciBhbiBlbGVtZW50LCBhZGQgaXQgdG8gdGhpcyBhcnJheS5cbiAgICB0aGlzLlBPU1RGT1JNQVQgPSBbIFZleC5GbG93LlN0YXZlTm90ZSBdO1xuICB9XG5cbiAgLy8gVG8gZW5hYmxlIGxvZ2dpbmcgZm9yIHRoaXMgY2xhc3MuIFNldCBgVmV4LkZsb3cuTW9kaWZpZXJDb250ZXh0LkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChNb2RpZmllckNvbnRleHQuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuTW9kaWZpZXJDb250ZXh0XCIsIGFyZ3VtZW50cyk7IH1cblxuICBNb2RpZmllckNvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGFkZE1vZGlmaWVyOiBmdW5jdGlvbihtb2RpZmllcikge1xuICAgICAgdmFyIHR5cGUgPSBtb2RpZmllci5nZXRDYXRlZ29yeSgpO1xuICAgICAgaWYgKCF0aGlzLm1vZGlmaWVyc1t0eXBlXSkgdGhpcy5tb2RpZmllcnNbdHlwZV0gPSBbXTtcbiAgICAgIHRoaXMubW9kaWZpZXJzW3R5cGVdLnB1c2gobW9kaWZpZXIpO1xuICAgICAgbW9kaWZpZXIuc2V0TW9kaWZpZXJDb250ZXh0KHRoaXMpO1xuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRNb2RpZmllcnM6IGZ1bmN0aW9uKHR5cGUpIHsgcmV0dXJuIHRoaXMubW9kaWZpZXJzW3R5cGVdOyB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMud2lkdGg7IH0sXG4gICAgZ2V0RXh0cmFMZWZ0UHg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zdGF0ZS5sZWZ0X3NoaWZ0OyB9LFxuICAgIGdldEV4dHJhUmlnaHRQeDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN0YXRlLnJpZ2h0X3NoaWZ0OyB9LFxuICAgIGdldFN0YXRlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc3RhdGU7IH0sXG5cbiAgICBnZXRNZXRyaWNzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5mb3JtYXR0ZWQpIHRocm93IG5ldyBWZXguUkVSUihcIlVuZm9ybWF0dGVkTW9kaWZpZXJcIixcbiAgICAgICAgICBcIlVuZm9ybWF0dGVkIG1vZGlmaWVyIGhhcyBubyBtZXRyaWNzLlwiKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuc3RhdGUubGVmdF9zaGlmdCArIHRoaXMuc3RhdGUucmlnaHRfc2hpZnQgKyB0aGlzLnNwYWNpbmcsXG4gICAgICAgIHNwYWNpbmc6IHRoaXMuc3BhY2luZyxcbiAgICAgICAgZXh0cmFfbGVmdF9weDogdGhpcy5zdGF0ZS5sZWZ0X3NoaWZ0LFxuICAgICAgICBleHRyYV9yaWdodF9weDogdGhpcy5zdGF0ZS5yaWdodF9zaGlmdFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgcHJlRm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnByZUZvcm1hdHRlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5QUkVGT1JNQVQuZm9yRWFjaChmdW5jdGlvbihtb2RpZmllcikge1xuICAgICAgICBMKFwiUHJlZm9ybWF0dGluZyBNb2RpZmllckNvbnRleHQ6IFwiLCBtb2RpZmllci5DQVRFR09SWSk7XG4gICAgICAgIG1vZGlmaWVyLmZvcm1hdCh0aGlzLmdldE1vZGlmaWVycyhtb2RpZmllci5DQVRFR09SWSksIHRoaXMuc3RhdGUsIHRoaXMpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIC8vIFVwZGF0ZSB3aWR0aCBvZiB0aGlzIG1vZGlmaWVyIGNvbnRleHRcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLnN0YXRlLmxlZnRfc2hpZnQgKyB0aGlzLnN0YXRlLnJpZ2h0X3NoaWZ0O1xuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBwb3N0Rm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBvc3RGb3JtYXR0ZWQpIHJldHVybjtcbiAgICAgIHRoaXMuUE9TVEZPUk1BVC5mb3JFYWNoKGZ1bmN0aW9uKG1vZGlmaWVyKSB7XG4gICAgICAgIEwoXCJQb3N0Zm9ybWF0dGluZyBNb2RpZmllckNvbnRleHQ6IFwiLCBtb2RpZmllci5DQVRFR09SWSk7XG4gICAgICAgIG1vZGlmaWVyLnBvc3RGb3JtYXQodGhpcy5nZXRNb2RpZmllcnMobW9kaWZpZXIuQ0FURUdPUlkpLCB0aGlzKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTW9kaWZpZXJDb250ZXh0O1xufSgpKTtcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vLyBAYXV0aG9yIE1vaGl0IENoZXBwdWRpcmFcbi8vIEBhdXRob3IgR3JlZyBSaXN0b3cgKG1vZGlmaWNhdGlvbnMpXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBUaGlzIGZpbGUgaW1wbGVtZW50cyBhY2NpZGVudGFscyBhcyBtb2RpZmllcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG9cbi8vIG5vdGVzLiBTdXBwb3J0IGlzIGluY2x1ZGVkIGZvciBib3RoIHdlc3Rlcm4gYW5kIG1pY3JvdG9uYWwgYWNjaWRlbnRhbHMuXG4vL1xuLy8gU2VlIGB0ZXN0cy9hY2NpZGVudGFsX3Rlc3RzLmpzYCBmb3IgdXNhZ2UgZXhhbXBsZXMuXG5cblZleC5GbG93LkFjY2lkZW50YWwgPSAoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gQWNjaWRlbnRhbCh0eXBlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodHlwZSk7XG4gIH1cbiAgQWNjaWRlbnRhbC5DQVRFR09SWSA9IFwiYWNjaWRlbnRhbHNcIjtcblxuICAvLyBUbyBlbmFibGUgbG9nZ2luZyBmb3IgdGhpcyBjbGFzcy4gU2V0IGBWZXguRmxvdy5BY2NpZGVudGFsLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChBY2NpZGVudGFsLkRFQlVHKSBWZXguTChcIlZleC5GbG93LkFjY2lkZW50YWxcIiwgYXJndW1lbnRzKTsgfVxuXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xuXG4gIC8vICMjIFN0YXRpYyBNZXRob2RzXG4gIC8vXG4gIC8vIEFycmFuZ2UgYWNjaWRlbnRhbHMgaW5zaWRlIGEgTW9kaWZpZXJDb250ZXh0LlxuICBBY2NpZGVudGFsLmZvcm1hdCA9IGZ1bmN0aW9uKGFjY2lkZW50YWxzLCBzdGF0ZSkge1xuICAgIHZhciBsZWZ0X3NoaWZ0ID0gc3RhdGUubGVmdF9zaGlmdDtcbiAgICB2YXIgYWNjaWRlbnRhbF9zcGFjaW5nID0gMjtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBhY2NpZGVudGFscywgd2UgbmVlZG4ndCBmb3JtYXQgdGhlaXIgcG9zaXRpb25zXG4gICAgaWYgKCFhY2NpZGVudGFscyB8fCBhY2NpZGVudGFscy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBhY2NfbGlzdCA9IFtdO1xuICAgIHZhciBoYXNTdGF2ZSA9IGZhbHNlO1xuICAgIHZhciBwcmV2X25vdGUgPSBudWxsO1xuICAgIHZhciBzaGlmdEwgPSAwO1xuXG4gICAgLy8gRmlyc3QgZGV0ZXJtaW5lIHRoZSBhY2NpZGVudGFscycgWSBwb3NpdGlvbnMgZnJvbSB0aGUgbm90ZS5rZXlzXG4gICAgdmFyIGksIGFjYywgcHJvcHNfdG1wO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhY2NpZGVudGFscy5sZW5ndGg7ICsraSkge1xuICAgICAgYWNjID0gYWNjaWRlbnRhbHNbaV07XG4gICAgICB2YXIgbm90ZSA9IGFjYy5nZXROb3RlKCk7XG4gICAgICB2YXIgc3RhdmUgPSBub3RlLmdldFN0YXZlKCk7XG4gICAgICB2YXIgcHJvcHMgPSBub3RlLmdldEtleVByb3BzKClbYWNjLmdldEluZGV4KCldO1xuICAgICAgaWYgKG5vdGUgIT0gcHJldl9ub3RlKSB7XG4gICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIG5vdGVzIHRvIGdldCB0aGUgZGlzcGxhY2VkIHBpeGVsc1xuICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub3RlLmtleXMubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICAgIHByb3BzX3RtcCA9IG5vdGUuZ2V0S2V5UHJvcHMoKVtuXTtcbiAgICAgICAgICAgIHNoaWZ0TCA9IChwcm9wc190bXAuZGlzcGxhY2VkID8gbm90ZS5nZXRFeHRyYUxlZnRQeCgpIDogc2hpZnRMKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldl9ub3RlID0gbm90ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF2ZSAhPT0gbnVsbCkge1xuICAgICAgICBoYXNTdGF2ZSA9IHRydWU7XG4gICAgICAgIHZhciBsaW5lX3NwYWNlID0gc3RhdmUub3B0aW9ucy5zcGFjaW5nX2JldHdlZW5fbGluZXNfcHg7XG4gICAgICAgIHZhciB5ID0gc3RhdmUuZ2V0WUZvckxpbmUocHJvcHMubGluZSk7XG4gICAgICAgIHZhciBhY2NfbGluZSA9IE1hdGgucm91bmQoeSAvIGxpbmVfc3BhY2UgKiAyKS8yO1xuICAgICAgICBhY2NfbGlzdC5wdXNoKHsgeTogeSwgbGluZTogYWNjX2xpbmUsIHNoaWZ0OiBzaGlmdEwsIGFjYzogYWNjLCBsaW5lU3BhY2U6IGxpbmVfc3BhY2UgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY2NfbGlzdC5wdXNoKHsgbGluZTogcHJvcHMubGluZSwgc2hpZnQ6IHNoaWZ0TCwgYWNjOiBhY2MgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29ydCBhY2NpZGVudGFscyBieSBsaW5lIG51bWJlci5cbiAgICBhY2NfbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIChiLmxpbmUgLSBhLmxpbmUpOyB9KTtcblxuICAgIC8vIENyZWF0ZSBhbiBhcnJheSBvZiB1bmlxdWUgbGluZSBudW1iZXJzIChsaW5lX2xpc3QpIGZyb20gYWNjX2xpc3RcbiAgICB2YXIgbGluZV9saXN0ID0gW107IC8vIGFuIGFycmF5IG9mIHVuaXF1ZSBsaW5lIG51bWJlcnNcbiAgICB2YXIgYWNjX3NoaWZ0ID0gMDsgLy8gYW1vdW50IGJ5IHdoaWNoIGFsbCBhY2NpZGVudGFscyBtdXN0IGJlIHNoaWZ0ZWQgcmlnaHQgb3IgbGVmdCBmb3Igc3RlbSBmbGlwcGluZywgbm90ZWhlYWQgc2hpZnRpbmcgY29uY2VybnMuXG4gICAgdmFyIHByZXZpb3VzX2xpbmUgPSBudWxsO1xuXG4gICAgZm9yKGkgPSAwOyBpPGFjY19saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY2MgPSBhY2NfbGlzdFtpXTtcblxuICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgZmlyc3QgbGluZSwgb3IgYSBuZXcgbGluZSwgYWRkIGEgbGluZV9saXN0XG4gICAgICBpZiggKHByZXZpb3VzX2xpbmUgPT09IG51bGwpIHx8IChwcmV2aW91c19saW5lICE9IGFjYy5saW5lKSApIHtcbiAgICAgICAgbGluZV9saXN0LnB1c2goe2xpbmUgOiBhY2MubGluZSwgZmxhdF9saW5lIDogdHJ1ZSwgZGJsX3NoYXJwX2xpbmU6IHRydWUsIG51bV9hY2MgOiAwLCB3aWR0aCA6IDB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoaXMgYWNjaWRlbnRhbCBpcyBub3QgYSBmbGF0LCB0aGUgYWNjaWRlbnRhbCBuZWVkcyAzLjAgbGluZXMgbG93ZXJcbiAgICAgIC8vIGNsZWFyYW5jZSBpbnN0ZWFkIG9mIDIuNSBsaW5lcyBmb3IgYiBvciBiYi5cbiAgICAgIGlmKCAoYWNjLmFjYy50eXBlICE9IFwiYlwiKSAmJiAoYWNjLmFjYy50eXBlICE9XCJiYlwiKSApIHtcbiAgICAgICAgbGluZV9saXN0W2xpbmVfbGlzdC5sZW5ndGggLSAxXS5mbGF0X2xpbmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoaXMgYWNjaWRlbnRhbCBpcyBub3QgYSBkb3VibGUgc2hhcnAsIHRoZSBhY2NpZGVudGFsIG5lZWRzIDMuMCBsaW5lcyBhYm92ZVxuICAgICAgaWYoIGFjYy5hY2MudHlwZSAhPSBcIiMjXCIpXG4gICAgICAgIGxpbmVfbGlzdFtsaW5lX2xpc3QubGVuZ3RoIC0gMV0uZGJsX3NoYXJwX2xpbmUgPSBmYWxzZTtcblxuICAgICAgLy8gVHJhY2sgaG93IG1hbnkgYWNjaWRlbnRhbHMgYXJlIG9uIHRoaXMgbGluZTpcbiAgICAgIGxpbmVfbGlzdFtsaW5lX2xpc3QubGVuZ3RoIC0gMV0ubnVtX2FjYysrO1xuXG4gICAgICAvLyBUcmFjayB0aGUgdG90YWwgeF9vZmZzZXQgbmVlZGVkIGZvciB0aGlzIGxpbmUgd2hpY2ggd2lsbCBiZSBuZWVkZWRcbiAgICAgIC8vIGZvciBmb3JtYXR0aW5nIGxpbmVzIHcvIG11bHRpcGxlIGFjY2lkZW50YWxzOlxuXG4gICAgICAvL3dpZHRoID0gYWNjaWRlbnRhbCB3aWR0aCArIHVuaXZlcnNhbCBzcGFjaW5nIGJldHdlZW4gYWNjaWRlbnRhbHNcbiAgICAgIGxpbmVfbGlzdFtsaW5lX2xpc3QubGVuZ3RoIC0gMV0ud2lkdGggKz0gYWNjLmFjYy5nZXRXaWR0aCgpICsgYWNjaWRlbnRhbF9zcGFjaW5nO1xuXG4gICAgICAvLyBpZiB0aGlzIGFjY19zaGlmdCBpcyBsYXJnZXIsIHVzZSBpdCB0byBrZWVwIGZpcnN0IGNvbHVtbiBhY2NpZGVudGFscyBpbiB0aGUgc2FtZSBsaW5lXG4gICAgICBhY2Nfc2hpZnQgPSAoIChhY2Muc2hpZnQgPiBhY2Nfc2hpZnQpID8gYWNjLnNoaWZ0IDogYWNjX3NoaWZ0KTtcblxuICAgICAgcHJldmlvdXNfbGluZSA9IGFjYy5saW5lO1xuICAgIH1cblxuICAgIC8vICMjIyBQbGFjZSBBY2NpZGVudGFscyBpbiBDb2x1bW5zXG4gICAgLy9cbiAgICAvLyBEZWZhdWx0IHRvIGEgY2xhc3NpYyB0cmlhbmd1bGFyIGxheW91dCAobWlkZGxlIGFjY2lkZW50YWwgZmFydGhlc3QgbGVmdCksXG4gICAgLy8gYnV0IGZvbGxvdyBleGNlcHRpb25zIGFzIG91dGxpbmVkIGluIEcuIFJlYWQncyBfTXVzaWMgTm90YXRpb25fIGFuZFxuICAgIC8vIEVsYWluZSBHb3VsZCdzIF9CZWhpbmQgQmFyc18uXG4gICAgLy9cbiAgICAvLyBBZGRpdGlvbmFsbHksIHRoaXMgaW1wbGVtZW50cyBkaWZmZXJlbnQgdmVydGljYWwgY29saXNzaW9uIHJ1bGVzIGZvclxuICAgIC8vIGZsYXRzIChvbmx5IG5lZWQgMi41IGxpbmVzIGNsZWFyYW5jZSBiZWxvdykgYW5kIGRvdWJsZSBzaGFycHMgKG9ubHlcbiAgICAvLyBuZWVkIDIuNSBsaW5lcyBvZiBjbGVhcmFuY2UgYWJvdmUgb3IgYmVsb3cpLlxuICAgIC8vXG4gICAgLy8gQ2xhc3NpYyBsYXlvdXRzIGFuZCBleGNlcHRpb24gcGF0dGVybnMgYXJlIGZvdW5kIGluIHRoZSAndGFibGVzLmpzJ1xuICAgIC8vIGluICdWZXguRmxvdy5hY2NpZGVudGFsQ29sdW1uc1RhYmxlJ1xuICAgIC8vXG4gICAgLy8gQmV5b25kIDYgdmVydGljYWwgYWNjaWRlbnRhbHMsIGRlZmF1bHQgdG8gdGhlIHBhcmFsbGVsIGFzY2VuZGluZyBsaW5lcyBhcHByb2FjaCxcbiAgICAvLyB1c2luZyBhcyBmZXcgY29sdW1ucyBhcyBwb3NzaWJsZSBmb3IgdGhlIHZlcnRpY2xlIHN0cnVjdHVyZS5cbiAgICAvL1xuICAgIC8vIFRPRE8gKD8pOiBBbGxvdyBjb2x1bW4gdG8gYmUgc3BlY2lmaWVkIGZvciBhbiBhY2NpZGVudGFsIGF0IHJ1bi10aW1lP1xuXG4gICAgdmFyIHRvdGFsX2NvbHVtbnMgPSAwO1xuXG4gICAgLy8gZXN0YWJsaXNoIHRoZSBib3VuZGFyaWVzIGZvciBhIGdyb3VwIG9mIG5vdGVzIHdpdGggY2xhc2hpbmcgYWNjaWRlbnRhbHM6XG4gICAgZm9yKGkgPSAwOyBpPGxpbmVfbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vX2Z1cnRoZXJfY29uZmxpY3RzID0gZmFsc2U7XG4gICAgICB2YXIgZ3JvdXBfc3RhcnQgPSBpO1xuICAgICAgdmFyIGdyb3VwX2VuZCA9IGk7XG5cbiAgICAgIGdyb3VwX2NoZWNrX3doaWxlIDogd2hpbGUoIChncm91cF9lbmQrMSA8IGxpbmVfbGlzdC5sZW5ndGgpICYmICghbm9fZnVydGhlcl9jb25mbGljdHMpICkge1xuICAgICAgICAvLyBpZiB0aGlzIG5vdGUgY29uZmxpY3RzIHdpdGggdGhlIG5leHQ6XG4gICAgICAgIGlmKHRoaXMuY2hlY2tDb2xsaXNpb24obGluZV9saXN0W2dyb3VwX2VuZF0sIGxpbmVfbGlzdFtncm91cF9lbmQgKyAxXSkpIHtcbiAgICAgICAgLy8gaW5jbHVkZSB0aGUgbmV4dCBub3RlIGluIHRoZSBncm91cDpcbiAgICAgICAgICBncm91cF9lbmQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIG5vX2Z1cnRoZXJfY29uZmxpY3RzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGNvbHVtbnMgZm9yIHRoZSBsaW5lcyBpbiB0aGlzIGdyb3VwOlxuICAgICAgdmFyIGdyb3VwX2xlbmd0aCA9IGdyb3VwX2VuZCAtIGdyb3VwX3N0YXJ0ICsgMTtcblxuICAgICAgLy8gU2V0IHRoZSBhY2NpZGVudGFsIGNvbHVtbiBmb3IgZWFjaCBsaW5lIG9mIHRoZSBncm91cFxuICAgICAgdmFyIGVuZF9jYXNlID0gKHRoaXMuY2hlY2tDb2xsaXNpb24obGluZV9saXN0W2dyb3VwX3N0YXJ0XSwgbGluZV9saXN0W2dyb3VwX2VuZF0pKSA/IFwiYVwiIDogXCJiXCI7XG5cblxuICAgICAgICB2YXIgY2hlY2tDb2xsaXNpb24gPSB0aGlzLmNoZWNrQ29sbGlzaW9uO1xuICAgICAgICBzd2l0Y2goZ3JvdXBfbGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYoIChlbmRfY2FzZSA9PSBcImFcIikgJiZcbiAgICAgICAgICAgICAgICAobGluZV9saXN0W2dyb3VwX3N0YXJ0KzFdLmxpbmUgLSBsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrMl0ubGluZSA9PSAwLjUpICYmXG4gICAgICAgICAgICAgICAgKGxpbmVfbGlzdFtncm91cF9zdGFydF0ubGluZSAtIGxpbmVfbGlzdFtncm91cF9zdGFydCArIDFdLmxpbmUgIT0gMC41KSApXG4gICAgICAgICAgICAgIGVuZF9jYXNlID0gXCJzZWNvbmRfb25fYm90dG9tXCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGlmKCAoIWNoZWNrQ29sbGlzaW9uKGxpbmVfbGlzdFtncm91cF9zdGFydF0sIGxpbmVfbGlzdFtncm91cF9zdGFydCsyXSkpICYmXG4gICAgICAgICAgICAgICAgKCFjaGVja0NvbGxpc2lvbihsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrMV0sIGxpbmVfbGlzdFtncm91cF9zdGFydCszXSkpIClcbiAgICAgICAgICAgICAgZW5kX2Nhc2UgPSBcInNwYWNlZF9vdXRfdGV0cmFjaG9yZFwiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBpZiggKGVuZF9jYXNlID09IFwiYlwiKSAmJlxuICAgICAgICAgICAgICAgICghY2hlY2tDb2xsaXNpb24obGluZV9saXN0W2dyb3VwX3N0YXJ0KzFdLCBsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrM10pKSApXG4gICAgICAgICAgICAgIGVuZF9jYXNlID0gXCJzcGFjZWRfb3V0X3BlbnRhY2hvcmRcIjtcbiAgICAgICAgICAgIGlmKCAoZW5kX2Nhc2UgPT0gXCJzcGFjZWRfb3V0X3BlbnRhY2hvcmRcIikgJiZcbiAgICAgICAgICAgICAgICAoIWNoZWNrQ29sbGlzaW9uKGxpbmVfbGlzdFtncm91cF9zdGFydF0sIGxpbmVfbGlzdFtncm91cF9zdGFydCsyXSkpICYmXG4gICAgICAgICAgICAgICAgKCFjaGVja0NvbGxpc2lvbihsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrMl0sIGxpbmVfbGlzdFtncm91cF9zdGFydCs0XSkpIClcbiAgICAgICAgICAgICAgZW5kX2Nhc2UgPSBcInZlcnlfc3BhY2VkX291dF9wZW50YWNob3JkXCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGlmKCAoIWNoZWNrQ29sbGlzaW9uKGxpbmVfbGlzdFtncm91cF9zdGFydF0sIGxpbmVfbGlzdFtncm91cF9zdGFydCszXSkpICYmXG4gICAgICAgICAgICAgICAgKCFjaGVja0NvbGxpc2lvbihsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrMV0sIGxpbmVfbGlzdFtncm91cF9zdGFydCs0XSkpICYmXG4gICAgICAgICAgICAgICAgKCFjaGVja0NvbGxpc2lvbihsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrMl0sIGxpbmVfbGlzdFtncm91cF9zdGFydCs1XSkpIClcbiAgICAgICAgICAgICAgZW5kX2Nhc2UgPSBcInNwYWNlZF9vdXRfaGV4YWNob3JkXCI7XG4gICAgICAgICAgICBpZiggKCFjaGVja0NvbGxpc2lvbihsaW5lX2xpc3RbZ3JvdXBfc3RhcnRdLCBsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrMl0pKSAmJlxuICAgICAgICAgICAgICAgICghY2hlY2tDb2xsaXNpb24obGluZV9saXN0W2dyb3VwX3N0YXJ0KzJdLCBsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrNF0pKSAmJlxuICAgICAgICAgICAgICAgICghY2hlY2tDb2xsaXNpb24obGluZV9saXN0W2dyb3VwX3N0YXJ0KzFdLCBsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrM10pKSAmJlxuICAgICAgICAgICAgICAgICghY2hlY2tDb2xsaXNpb24obGluZV9saXN0W2dyb3VwX3N0YXJ0KzNdLCBsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrNV0pKSApXG4gICAgICAgICAgICAgIGVuZF9jYXNlID0gXCJ2ZXJ5X3NwYWNlZF9vdXRfaGV4YWNob3JkXCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIHZhciBncm91cF9tZW1iZXI7XG4gICAgICB2YXIgY29sdW1uO1xuICAgICAgLy8gSWYgdGhlIGdyb3VwIGNvbnRhaW5zIG1vcmUgdGhhbiBzZXZlbiBtZW1iZXJzLCB1c2UgYXNjZW5kaW5nIHBhcmFsbGVsIGxpbmVzXG4gICAgICAvLyBvZiBhY2NpZGVudGFscywgdXNpbmcgYXMgZmV3IGNvbHVtbnMgYXMgcG9zc2libGUgd2hpbGUgYXZvaWRpbmcgY29sbGlzaW9ucy5cbiAgICAgIGlmIChncm91cF9sZW5ndGg+PTcpIHtcbiAgICAgICAgLy8gRmlyc3QsIGRldGVybWluZSBob3cgbWFueSBjb2x1bW5zIHRvIHVzZTpcbiAgICAgICAgdmFyIHBhdHRlcm5fbGVuZ3RoID0gMjtcbiAgICAgICAgdmFyIGNvbGlzc2lvbl9kZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIHdoaWxlKGNvbGlzc2lvbl9kZXRlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvbGlzc2lvbl9kZXRlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIGNvbGlzc2lvbl9kZXRlY3RlciA6IGZvcih2YXIgbGluZSA9IDA7IGxpbmUgKyBwYXR0ZXJuX2xlbmd0aCA8IGxpbmVfbGlzdC5sZW5ndGg7IGxpbmUrKykge1xuICAgICAgICAgICAgaWYodGhpcy5jaGVja0NvbGxpc2lvbihsaW5lX2xpc3RbbGluZV0sIGxpbmVfbGlzdFtsaW5lK3BhdHRlcm5fbGVuZ3RoXSkpIHtcbiAgICAgICAgICAgICAgY29saXNzaW9uX2RldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcGF0dGVybl9sZW5ndGgrKztcbiAgICAgICAgICAgICAgYnJlYWsgY29saXNzaW9uX2RldGVjdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVuLCBhc3NpZ24gYSBjb2x1bW4gdG8gZWFjaCBsaW5lIG9mIGFjY2lkZW50YWxzXG4gICAgICAgIGZvcihncm91cF9tZW1iZXIgPSBpOyBncm91cF9tZW1iZXIgPD0gZ3JvdXBfZW5kOyBncm91cF9tZW1iZXIrKykge1xuICAgICAgICAgIGNvbHVtbiA9ICgoZ3JvdXBfbWVtYmVyLWkpICUgcGF0dGVybl9sZW5ndGgpICsgMTtcbiAgICAgICAgICBsaW5lX2xpc3RbZ3JvdXBfbWVtYmVyXS5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgdG90YWxfY29sdW1ucyA9ICh0b3RhbF9jb2x1bW5zID4gY29sdW1uKSA/IHRvdGFsX2NvbHVtbnMgOiBjb2x1bW47XG4gICAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGUgZ3JvdXAgY29udGFpbnMgZmV3ZXIgdGhhbiBzZXZlbiBtZW1iZXJzLCB1c2UgdGhlIGxheW91dHMgZnJvbVxuICAgICAgLy8gdGhlIGFjY2lkZW50YWxzQ29sdW1uc1RhYmxlIGhvdXNlZCBpbiB0YWJsZXMuanMuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IoZ3JvdXBfbWVtYmVyID0gaTsgZ3JvdXBfbWVtYmVyIDw9IGdyb3VwX2VuZDsgZ3JvdXBfbWVtYmVyKyspIHtcbiAgICAgICAgICBjb2x1bW4gPSBWZXguRmxvdy5hY2NpZGVudGFsQ29sdW1uc1RhYmxlW2dyb3VwX2xlbmd0aF1bZW5kX2Nhc2VdW2dyb3VwX21lbWJlci1pXTtcbiAgICAgICAgICBsaW5lX2xpc3RbZ3JvdXBfbWVtYmVyXS5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgdG90YWxfY29sdW1ucyA9ICh0b3RhbF9jb2x1bW5zID4gY29sdW1uKSA/IHRvdGFsX2NvbHVtbnMgOiBjb2x1bW47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSW5jcmVtZW50IGkgdG8gdGhlIGxhc3Qgbm90ZSB0aGF0IHdhcyBzZXQsIHNvIHRoYXQgaWYgYSBsb3dlciBzZXQgb2Ygbm90ZXNcbiAgICAgIC8vIGRvZXMgbm90IGNvbmZsaWN0IGF0IGFsbCB3aXRoIHRoaXMgZ3JvdXAsIGl0IGNhbiBoYXZlIGl0cyBvd24gY2xhc3NpYyBzaGFwZS5cbiAgICAgIGkgPSBncm91cF9lbmQ7XG4gICAgfVxuXG4gICAgLy8gIyMjIENvbnZlcnQgQ29sdW1ucyB0byB4X29mZnNldHNcbiAgICAvL1xuICAgIC8vIFRoaXMga2VlcHMgY29sdW1ucyBhbGlnbmVkLCBldmVuIGlmIHRoZXkgaGF2ZSBkaWZmZXJlbnQgYWNjaWRlbnRhbHMgd2l0aGluIHRoZW1cbiAgICAvLyB3aGljaCBzb21ldGltZXMgcmVzdWx0cyBpbiBhIGxhcmdlciB4X29mZnNldCB0aGFuIGlzIGFuIGFjY2lkZW50YWwgbWlnaHQgbmVlZFxuICAgIC8vIHRvIHByZXNlcnZlIHRoZSBzeW1tZXRyeSBvZiB0aGUgYWNjaWRlbnRhbCBzaGFwZS5cbiAgICAvL1xuICAgIC8vIE5laXRoZXIgQS5DLiBWaW5jaSBub3IgRy4gUmVhZCBhZGRyZXNzIHRoaXMsIGFuZCBpdCB0eXBpY2FsbHkgb25seSBoYXBwZW5zIGluXG4gICAgLy8gbXVzaWMgd2l0aCBjb21wbGV4IGNob3JkIGNsdXN0ZXJzLlxuICAgIC8vXG4gICAgLy8gVE9ETyAoPyk6IE9wdGlvbmFsbHkgYWxsb3cgY2xvc2VyIGNvbXByZXNzaW9uIG9mIGFjY2lkZW50YWxzLCBpbnN0ZWFkIG9mIGZvcmNpbmdcbiAgICAvLyBwYXJhbGxlbCBjb2x1bW5zLlxuXG4gICAgLy8gdHJhY2sgZWFjaCBjb2x1bW4ncyBtYXggd2lkdGgsIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBpbml0aWFsIHNoaWZ0IG9mIGxhdGVyIGNvbHVtbnM6XG4gICAgdmFyIGNvbHVtbl93aWR0aHMgPSBbXTtcbiAgICB2YXIgY29sdW1uX3hfb2Zmc2V0cyA9IFtdO1xuICAgIGZvcihpPTA7IGk8PXRvdGFsX2NvbHVtbnM7IGkrKykge1xuICAgICAgY29sdW1uX3dpZHRoc1tpXSA9IDA7XG4gICAgICBjb2x1bW5feF9vZmZzZXRzW2ldID0gMDtcbiAgICB9XG5cbiAgICBjb2x1bW5fd2lkdGhzWzBdID0gYWNjX3NoaWZ0ICsgbGVmdF9zaGlmdDtcbiAgICBjb2x1bW5feF9vZmZzZXRzWzBdID0gYWNjX3NoaWZ0ICsgbGVmdF9zaGlmdDtcblxuICAgIC8vIEZpbGwgY29sdW1uX3dpZHRocyB3aXRoIHdpZGVzdCBuZWVkZWQgeC1zcGFjZTtcbiAgICAvLyB0aGlzIGlzIHdoYXQga2VlcHMgdGhlIGNvbHVtbnMgcGFyYWxsZWwuXG4gICAgbGluZV9saXN0LmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgaWYobGluZS53aWR0aCA+IGNvbHVtbl93aWR0aHNbbGluZS5jb2x1bW5dKSBjb2x1bW5fd2lkdGhzW2xpbmUuY29sdW1uXSA9IGxpbmUud2lkdGg7XG4gICAgfSk7XG5cbiAgICBmb3IoaT0xOyBpPGNvbHVtbl93aWR0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHRoaXMgY29sdW1uJ3Mgb2Zmc2V0ID0gdGhpcyBjb2x1bW4ncyB3aWR0aCArIHByZXZpb3VzIGNvbHVtbidzIG9mZnNldFxuICAgICAgY29sdW1uX3hfb2Zmc2V0c1tpXSA9IGNvbHVtbl93aWR0aHNbaV0gKyBjb2x1bW5feF9vZmZzZXRzW2ktMV07XG4gICAgfVxuXG4gICAgdmFyIHRvdGFsX3NoaWZ0ID0gY29sdW1uX3hfb2Zmc2V0c1tjb2x1bW5feF9vZmZzZXRzLmxlbmd0aC0xXTtcbiAgICAvLyBTZXQgdGhlIHhfc2hpZnQgZm9yIGVhY2ggYWNjaWRlbnRhbCBhY2NvcmRpbmcgdG8gY29sdW1uIG9mZnNldHM6XG4gICAgdmFyIGFjY19jb3VudCA9IDA7XG4gICAgbGluZV9saXN0LmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIGxpbmVfd2lkdGggPSAwO1xuICAgICAgdmFyIGxhc3RfYWNjX29uX2xpbmUgPSBhY2NfY291bnQgKyBsaW5lLm51bV9hY2M7XG4gICAgICAvLyBoYW5kbGUgYWxsIG9mIHRoZSBhY2NpZGVudGFscyBvbiBhIGdpdmVuIGxpbmU6XG4gICAgICBmb3IoYWNjX2NvdW50OyBhY2NfY291bnQ8bGFzdF9hY2Nfb25fbGluZTsgYWNjX2NvdW50KyspIHtcbiAgICAgICAgdmFyIHhfc2hpZnQgPSAoY29sdW1uX3hfb2Zmc2V0c1tsaW5lLmNvbHVtbi0xXSArIGxpbmVfd2lkdGgpO1xuICAgICAgICBhY2NfbGlzdFthY2NfY291bnRdLmFjYy5zZXRYU2hpZnQoeF9zaGlmdCk7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIHdpZHRoIG9mIGFjY2lkZW50YWxzIHdlJ3ZlIGFkZGVkIHNvIGZhciwgc28gdGhhdCB3aGVuXG4gICAgICAgIC8vIHdlIGxvb3AsIHdlIGFkZCBzcGFjZSBmb3IgdGhlbS5cbiAgICAgICAgbGluZV93aWR0aCArPSBhY2NfbGlzdFthY2NfY291bnRdLmFjYy5nZXRXaWR0aCgpICsgYWNjaWRlbnRhbF9zcGFjaW5nO1xuICAgICAgICBMKFwiTGluZSwgYWNjX2NvdW50LCBzaGlmdDogXCIsIGxpbmUubGluZSwgYWNjX2NvdW50LCB4X3NoaWZ0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgb3ZlcmFsbCBsYXlvdXQgd2l0aCB0aGUgZnVsbCB3aWR0aCBvZiB0aGUgYWNjaWRlbnRhbCBzaGFwZXM6XG4gICAgc3RhdGUubGVmdF9zaGlmdCArPSB0b3RhbF9zaGlmdDtcbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdHdvIGxpbmVzIG9mIGFjY2lkZW50YWxzIGNvbGxpZGUgdmVydGljYWxseVxuICBBY2NpZGVudGFsLmNoZWNrQ29sbGlzaW9uID0gZnVuY3Rpb24obGluZV8xLCBsaW5lXzIpIHtcbiAgICB2YXIgY2xlYXJhbmNlID0gbGluZV8yLmxpbmUgLSBsaW5lXzEubGluZTtcbiAgICB2YXIgY2xlYXJhbmNlX3JlcXVpcmVkID0gMztcbiAgICAvLyBCdXQgbGVzcyBjbGVhcmFuY2UgaXMgcmVxdWlyZWQgZm9yIGNlcnRhaW4gYWNjaWRlbnRhbHM6IGIsIGJiIGFuZCAjIy5cbiAgICBpZihjbGVhcmFuY2U+MCkgeyAvLyB0aGVuIGxpbmUgMiBpcyBvbiB0b3BcbiAgICAgIGNsZWFyYW5jZV9yZXF1aXJlZCA9IChsaW5lXzIuZmxhdF9saW5lIHx8IGxpbmVfMi5kYmxfc2hhcnBfbGluZSkgPyAyLjUgOiAzLjA7XG4gICAgICBpZihsaW5lXzEuZGJsX3NoYXJwX2xpbmUpIGNsZWFyYW5jZSAtPSAwLjU7XG4gICAgfSBlbHNlIHsgLy8gbGluZSAxIGlzIG9uIHRvcFxuICAgICAgY2xlYXJhbmNlX3JlcXVpcmVkID0gKGxpbmVfMS5mbGF0X2xpbmUgfHwgbGluZV8xLmRibF9zaGFycF9saW5lKSA/IDIuNSA6IDMuMDtcbiAgICAgIGlmKGxpbmVfMi5kYmxfc2hhcnBfbGluZSkgY2xlYXJhbmNlIC09IDAuNTtcbiAgICB9XG4gICAgdmFyIGNvbGlzc2lvbiA9IChNYXRoLmFicyhjbGVhcmFuY2UpIDwgY2xlYXJhbmNlX3JlcXVpcmVkKTtcbiAgICBMKFwiTGluZV8xLCBMaW5lXzIsIENvbGxpc2lvbjogXCIsIGxpbmVfMS5saW5lLCBsaW5lXzIubGluZSwgY29saXNzaW9uKTtcbiAgICByZXR1cm4oY29saXNzaW9uKTtcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICAvL1xuICAvLyBBbiBgQWNjaWRlbnRhbGAgaW5oZXJpdHMgZnJvbSBgTW9kaWZpZXJgLCBhbmQgaXMgZm9ybWF0dGVkIHdpdGhpbiBhXG4gIC8vIGBNb2RpZmllckNvbnRleHRgLlxuICBWZXguSW5oZXJpdChBY2NpZGVudGFsLCBNb2RpZmllciwge1xuICAgIC8vIENyZWF0ZSBhY2NpZGVudGFsLiBgdHlwZWAgY2FuIGJlIGEgdmFsdWUgZnJvbSB0aGVcbiAgICAvLyBgVmV4LkZsb3cuYWNjaWRlbnRhbENvZGVzLmFjY2lkZW50YWxzYCB0YWJsZSBpbiBgdGFibGVzLmpzYC4gRm9yXG4gICAgLy8gZXhhbXBsZTogYCNgLCBgIyNgLCBgYmAsIGBuYCwgZXRjLlxuICAgIGluaXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIEFjY2lkZW50YWwuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcyk7XG4gICAgICBMKFwiTmV3IGFjY2lkZW50YWw6IFwiLCB0eXBlKTtcblxuICAgICAgdGhpcy5ub3RlID0gbnVsbDtcbiAgICAgIC8vIFRoZSBgaW5kZXhgIHBvaW50cyB0byBhIHNwZWNpZmljIG5vdGUgaW4gYSBjaG9yZC5cbiAgICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBNb2RpZmllci5Qb3NpdGlvbi5MRUZUO1xuXG4gICAgICB0aGlzLnJlbmRlcl9vcHRpb25zID0ge1xuICAgICAgICAvLyBGb250IHNpemUgZm9yIGdseXBoc1xuICAgICAgICBmb250X3NjYWxlOiAzOCxcblxuICAgICAgICAvLyBMZW5ndGggb2Ygc3Ryb2tlIGFjcm9zcyBoZWFkcyBhYm92ZSBvciBiZWxvdyB0aGUgc3RhdmUuXG4gICAgICAgIHN0cm9rZV9weDogM1xuICAgICAgfTtcblxuICAgICAgdGhpcy5hY2NpZGVudGFsID0gVmV4LkZsb3cuYWNjaWRlbnRhbENvZGVzKHRoaXMudHlwZSk7XG4gICAgICBpZiAoIXRoaXMuYWNjaWRlbnRhbCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiQXJndW1lbnRFcnJvclwiLCBcIlVua25vd24gYWNjaWRlbnRhbCB0eXBlOiBcIiArIHR5cGUpO1xuXG4gICAgICAvLyBDYXV0aW9uYXJ5IGFjY2lkZW50YWxzIGhhdmUgcGFyZW50aGVzZXMgYXJvdW5kIHRoZW1cbiAgICAgIHRoaXMuY2F1dGlvbmFyeSA9IGZhbHNlO1xuICAgICAgdGhpcy5wYXJlbl9sZWZ0ID0gbnVsbDtcbiAgICAgIHRoaXMucGFyZW5fcmlnaHQgPSBudWxsO1xuXG4gICAgICAvLyBJbml0aWFsIHdpZHRoIGlzIHNldCBmcm9tIHRhYmxlLlxuICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLmFjY2lkZW50YWwud2lkdGgpO1xuICAgIH0sXG5cbiAgICAvLyBBdHRhY2ggdGhpcyBhY2NpZGVudGFsIHRvIGBub3RlYCwgd2hpY2ggbXVzdCBiZSBhIGBTdGF2ZU5vdGVgLlxuICAgIHNldE5vdGU6IGZ1bmN0aW9uKG5vdGUpe1xuICAgICAgaWYgKCFub3RlKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJBcmd1bWVudEVycm9yXCIsIFwiQmFkIG5vdGUgdmFsdWU6IFwiICsgbm90ZSk7XG4gICAgICB0aGlzLm5vdGUgPSBub3RlO1xuXG4gICAgICAvLyBBY2NpZGVudGFscyBhdHRhY2hlZCB0byBncmFjZSBub3RlcyBhcmUgcmVuZGVyZWQgc21hbGxlci5cbiAgICAgIGlmICh0aGlzLm5vdGUuZ2V0Q2F0ZWdvcnkoKSA9PT0gJ2dyYWNlbm90ZXMnKSB7XG4gICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuZm9udF9zY2FsZSA9IDI1O1xuICAgICAgICB0aGlzLnNldFdpZHRoKHRoaXMuYWNjaWRlbnRhbC5ncmFjZW5vdGVfd2lkdGgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBJZiBjYWxsZWQsIGRyYXdzIHBhcmVudGhlc2lzIGFyb3VuZCBhY2NpZGVudGFsLlxuICAgIHNldEFzQ2F1dGlvbmFyeTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNhdXRpb25hcnkgPSB0cnVlO1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5mb250X3NjYWxlID0gMjg7XG4gICAgICB0aGlzLnBhcmVuX2xlZnQgPSBWZXguRmxvdy5hY2NpZGVudGFsQ29kZXMoXCJ7XCIpO1xuICAgICAgdGhpcy5wYXJlbl9yaWdodCA9IFZleC5GbG93LmFjY2lkZW50YWxDb2RlcyhcIn1cIik7XG4gICAgICB2YXIgd2lkdGhfYWRqdXN0ID0gKHRoaXMudHlwZSA9PSBcIiMjXCIgfHwgdGhpcy50eXBlID09IFwiYmJcIikgPyA2IDogNDtcblxuICAgICAgLy8gTWFrZSBzdXJlIGB3aWR0aGAgYWNjb21vZGF0ZXMgZm9yIHBhcmVudGhlc2VzLlxuICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLnBhcmVuX2xlZnQud2lkdGggKyB0aGlzLmFjY2lkZW50YWwud2lkdGggKyB0aGlzLnBhcmVuX3JpZ2h0LndpZHRoIC0gd2lkdGhfYWRqdXN0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW5kZXIgYWNjaWRlbnRhbCBvbnRvIGNhbnZhcy5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IGFjY2lkZW50YWwgd2l0aG91dCBhIGNvbnRleHQuXCIpO1xuICAgICAgaWYgKCEodGhpcy5ub3RlICYmICh0aGlzLmluZGV4ICE9IG51bGwpKSkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9BdHRhY2hlZE5vdGVcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IGFjY2lkZW50YWwgd2l0aG91dCBhIG5vdGUgYW5kIGluZGV4LlwiKTtcblxuICAgICAgLy8gRmlndXJlIG91dCB0aGUgc3RhcnQgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgZm9yIHRoaXMgbm90ZSBhbmQgaW5kZXguXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLm5vdGUuZ2V0TW9kaWZpZXJTdGFydFhZKHRoaXMucG9zaXRpb24sIHRoaXMuaW5kZXgpO1xuICAgICAgdmFyIGFjY194ID0gKChzdGFydC54ICsgdGhpcy54X3NoaWZ0KSAtIHRoaXMud2lkdGgpO1xuICAgICAgdmFyIGFjY195ID0gc3RhcnQueSArIHRoaXMueV9zaGlmdDtcbiAgICAgIEwoXCJSZW5kZXJpbmc6IFwiLCB0aGlzLnR5cGUsIGFjY194LCBhY2NfeSk7XG5cbiAgICAgIGlmICghdGhpcy5jYXV0aW9uYXJ5KSB7XG4gICAgICAgIC8vIFJlbmRlciB0aGUgYWNjaWRlbnRhbCBhbG9uZS5cbiAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgodGhpcy5jb250ZXh0LCBhY2NfeCwgYWNjX3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuZm9udF9zY2FsZSwgdGhpcy5hY2NpZGVudGFsLmNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVuZGVyIHRoZSBhY2NpZGVudGFsIGluIHBhcmVudGhlc2VzLlxuICAgICAgICBhY2NfeCArPSAzO1xuICAgICAgICBWZXguRmxvdy5yZW5kZXJHbHlwaCh0aGlzLmNvbnRleHQsIGFjY194LCBhY2NfeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5mb250X3NjYWxlLCB0aGlzLnBhcmVuX2xlZnQuY29kZSk7XG4gICAgICAgIGFjY194ICs9IDI7XG4gICAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKHRoaXMuY29udGV4dCwgYWNjX3gsIGFjY195LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLmZvbnRfc2NhbGUsIHRoaXMuYWNjaWRlbnRhbC5jb2RlKTtcbiAgICAgICAgYWNjX3ggKz0gdGhpcy5hY2NpZGVudGFsLndpZHRoIC0gMjtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcIiMjXCIgfHwgdGhpcy50eXBlID09IFwiYmJcIikgYWNjX3ggLT0gMjtcbiAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgodGhpcy5jb250ZXh0LCBhY2NfeCwgYWNjX3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuZm9udF9zY2FsZSwgdGhpcy5wYXJlbl9yaWdodC5jb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vICMjIFN0YXRpYyBNZXRob2RzXG4gIC8vXG4gIC8vIFVzZSB0aGlzIG1ldGhvZCB0byBhdXRvbWF0aWNhbGx5IGFwcGx5IGFjY2lkZW50YWxzIHRvIGEgc2V0IG9mIGB2b2ljZXNgLlxuICAvLyBUaGUgYWNjaWRlbnRhbHMgd2lsbCBiZSByZW1lbWJlcmVkIGJldHdlZW4gYWxsIHRoZSB2b2ljZXMgcHJvdmlkZWQuXG4gIC8vIE9wdGlvbmFsbHksIHlvdSBjYW4gYWxzbyBwcm92aWRlIGFuIGluaXRpYWwgYGtleVNpZ25hdHVyZWAuXG4gIEFjY2lkZW50YWwuYXBwbHlBY2NpZGVudGFscyA9IGZ1bmN0aW9uKHZvaWNlcywga2V5U2lnbmF0dXJlKSB7XG4gICAgdmFyIHRpY2tQb3NpdGlvbnMgPSBbXTtcbiAgICB2YXIgdGlja05vdGVNYXAgPSB7fTtcblxuICAgIC8vIFNvcnQgdGhlIHRpY2thYmxlcyBpbiBlYWNoIHZvaWNlIGJ5IHRoZWlyIHRpY2sgcG9zaXRpb24gaW4gdGhlIHZvaWNlXG4gICAgdm9pY2VzLmZvckVhY2goZnVuY3Rpb24odm9pY2UpIHtcbiAgICAgIHZhciB0aWNrUG9zaXRpb24gPSBuZXcgVmV4LkZsb3cuRnJhY3Rpb24oMCwgMSk7XG4gICAgICB2YXIgbm90ZXMgPSB2b2ljZS5nZXRUaWNrYWJsZXMoKTtcbiAgICAgIG5vdGVzLmZvckVhY2goZnVuY3Rpb24obm90ZSkge1xuICAgICAgICB2YXIgbm90ZXNBdFBvc2l0aW9uID0gdGlja05vdGVNYXBbdGlja1Bvc2l0aW9uLnZhbHVlKCldO1xuXG4gICAgICAgIGlmICghbm90ZXNBdFBvc2l0aW9uKSB7XG4gICAgICAgICAgdGlja1Bvc2l0aW9ucy5wdXNoKHRpY2tQb3NpdGlvbi52YWx1ZSgpKTtcbiAgICAgICAgICB0aWNrTm90ZU1hcFt0aWNrUG9zaXRpb24udmFsdWUoKV0gPSBbbm90ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm90ZXNBdFBvc2l0aW9uLnB1c2gobm90ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aWNrUG9zaXRpb24uYWRkKG5vdGUuZ2V0VGlja3MoKSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBtdXNpYyA9IG5ldyBWZXguRmxvdy5NdXNpYygpO1xuXG4gICAgLy8gRGVmYXVsdCBrZXkgc2lnbmF0dXJlIGlzIEMgbWFqb3JcbiAgICBpZiAoIWtleVNpZ25hdHVyZSkga2V5U2lnbmF0dXJlID0gXCJDXCI7XG5cbiAgICAvLyBHZXQgdGhlIHNjYWxlIG1hcCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBzdGF0ZSBvZiBlYWNoIHBpdGNoXG4gICAgdmFyIHNjYWxlTWFwID0gbXVzaWMuY3JlYXRlU2NhbGVNYXAoa2V5U2lnbmF0dXJlKTtcblxuICAgIHRpY2tQb3NpdGlvbnMuZm9yRWFjaChmdW5jdGlvbih0aWNrKSB7XG4gICAgICB2YXIgbm90ZXMgPSB0aWNrTm90ZU1hcFt0aWNrXTtcblxuICAgICAgLy8gQXJyYXkgdG8gc3RvcmUgYWxsIHBpdGNoZXMgdGhhdCBtb2RpZmllZCBhY2NpZGVudGFsIHN0YXRlc1xuICAgICAgLy8gYXQgdGhpcyB0aWNrIHBvc2l0aW9uXG4gICAgICB2YXIgbW9kaWZpZWRQaXRjaGVzID0gW107XG5cbiAgICAgIG5vdGVzLmZvckVhY2goZnVuY3Rpb24obm90ZSkge1xuICAgICAgICAgIGlmIChub3RlLmlzUmVzdCgpKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBHbyB0aHJvdWdoIGVhY2gga2V5IGFuZCBkZXRlcm1pbmUgaWYgYW4gYWNjaWRlbnRhbCBzaG91bGQgYmVcbiAgICAgICAgICAvLyBhcHBsaWVkXG4gICAgICAgICAgbm90ZS5rZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5U3RyaW5nLCBrZXlJbmRleCkge1xuICAgICAgICAgICAgICB2YXIga2V5ID0gbXVzaWMuZ2V0Tm90ZVBhcnRzKGtleVN0cmluZy5zcGxpdCgnLycpWzBdKTtcblxuICAgICAgICAgICAgICAvLyBGb3JjZSBhIG5hdHVyYWwgZm9yIGV2ZXJ5IGtleSB3aXRob3V0IGFuIGFjY2lkZW50YWxcbiAgICAgICAgICAgICAgdmFyIGFjY2lkZW50YWxTdHJpbmcgPSBrZXkuYWNjaWRlbnRhbCB8fCBcIm5cIjtcbiAgICAgICAgICAgICAgdmFyIHBpdGNoID0ga2V5LnJvb3QgKyBhY2NpZGVudGFsU3RyaW5nO1xuXG4gICAgICAgICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgY3VycmVudCBwaXRjaCBoYXMgdGhlIHNhbWUgYWNjaWRlbnRhbFxuICAgICAgICAgICAgICAvLyBhcyB0aGUgc2NhbGUgc3RhdGVcbiAgICAgICAgICAgICAgdmFyIHNhbWVBY2NpZGVudGFsID0gc2NhbGVNYXBba2V5LnJvb3RdID09PSBwaXRjaDtcblxuICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgYW4gaWRlbnRpY2FsIHBpdGNoIGluIHRoZSBjaG9yZCBhbHJlYWR5XG4gICAgICAgICAgICAgIC8vIG1vZGlmaWVkIHRoZSBhY2NpZGVudGFsIHN0YXRlXG4gICAgICAgICAgICAgIHZhciBwcmV2aW91c2x5TW9kaWZpZWQgPSBtb2RpZmllZFBpdGNoZXMuaW5kZXhPZihwaXRjaCkgPiAtMTtcblxuICAgICAgICAgICAgICAvLyBBZGQgdGhlIGFjY2lkZW50YWwgdG8gdGhlIFN0YXZlTm90ZVxuICAgICAgICAgICAgICBpZiAoIXNhbWVBY2NpZGVudGFsIHx8IChzYW1lQWNjaWRlbnRhbCAmJiBwcmV2aW91c2x5TW9kaWZpZWQpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIHNjYWxlIG1hcCBzbyB0aGF0IHRoZSByb290IHBpdGNoIGhhcyBhblxuICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlZCBzdGF0ZVxuICAgICAgICAgICAgICAgICAgc2NhbGVNYXBba2V5LnJvb3RdID0gcGl0Y2g7XG5cbiAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYWNjaWRlbnRhbFxuICAgICAgICAgICAgICAgICAgdmFyIGFjY2lkZW50YWwgPSBuZXcgVmV4LkZsb3cuQWNjaWRlbnRhbChhY2NpZGVudGFsU3RyaW5nKTtcblxuICAgICAgICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSBhY2NpZGVudGFsIHRvIHRoZSBTdGF2ZU5vdGVcbiAgICAgICAgICAgICAgICAgIG5vdGUuYWRkQWNjaWRlbnRhbChrZXlJbmRleCwgYWNjaWRlbnRhbCk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcGl0Y2ggdG8gbGlzdCBvZiBwaXRjaGVzIHRoYXQgbW9kaWZpZWQgYWNjaWRlbnRhbHNcbiAgICAgICAgICAgICAgICAgIG1vZGlmaWVkUGl0Y2hlcy5wdXNoKHBpdGNoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEFjY2lkZW50YWw7XG59KCkpO1xuXG4vLyBWZXhGbG93IC0gTXVzaWMgRW5ncmF2aW5nIGZvciBIVE1MNVxyXG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxyXG4vL1xyXG4vLyBUaGlzIGNsYXNzIGltcGxlbWVudHMgZG90IG1vZGlmaWVycyBmb3Igbm90ZXMuXHJcblxyXG4vKipcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5WZXguRmxvdy5Eb3QgPSAoZnVuY3Rpb24oKSB7XHJcbiAgZnVuY3Rpb24gRG90KCkge1xyXG4gICAgdGhpcy5pbml0KCk7XHJcbiAgfVxyXG5cclxuICBEb3QuQ0FURUdPUlkgPSBcImRvdHNcIjtcclxuXHJcbiAgdmFyIE1vZGlmaWVyID0gVmV4LkZsb3cuTW9kaWZpZXI7XHJcblxyXG4gIC8vIEFycmFuZ2UgZG90cyBpbnNpZGUgYSBNb2RpZmllckNvbnRleHQuXHJcbiAgRG90LmZvcm1hdCA9IGZ1bmN0aW9uKGRvdHMsIHN0YXRlKSB7XHJcbiAgICB2YXIgcmlnaHRfc2hpZnQgPSBzdGF0ZS5yaWdodF9zaGlmdDtcclxuICAgIHZhciBkb3Rfc3BhY2luZyA9IDE7XHJcblxyXG4gICAgaWYgKCFkb3RzIHx8IGRvdHMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgdmFyIGksIGRvdCwgbm90ZSwgc2hpZnQ7XHJcbiAgICB2YXIgZG90X2xpc3QgPSBbXTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBkb3RzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGRvdCA9IGRvdHNbaV07XHJcbiAgICAgIG5vdGUgPSBkb3QuZ2V0Tm90ZSgpO1xyXG5cclxuICAgICAgdmFyIHByb3BzO1xyXG4gICAgICAvLyBPbmx5IFN0YXZlTm90ZSBoYXMgLmdldEtleVByb3BzKClcclxuICAgICAgaWYgKHR5cGVvZiBub3RlLmdldEtleVByb3BzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcHJvcHMgPSBub3RlLmdldEtleVByb3BzKClbZG90LmdldEluZGV4KCldO1xyXG4gICAgICAgIHNoaWZ0ID0gKHByb3BzLmRpc3BsYWNlZCA/IG5vdGUuZ2V0RXh0cmFSaWdodFB4KCkgOiAwKTtcclxuICAgICAgfSBlbHNlIHsgLy8gRWxzZSBpdCdzIGEgVGFiTm90ZVxyXG4gICAgICAgIHByb3BzID0geyBsaW5lOiAwLjUgfTsgLy8gU2hpbSBrZXkgcHJvcHMgZm9yIGRvdCBwbGFjZW1lbnRcclxuICAgICAgICBzaGlmdCA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRvdF9saXN0LnB1c2goeyBsaW5lOiBwcm9wcy5saW5lLCBzaGlmdDogc2hpZnQsIG5vdGU6IG5vdGUsIGRvdDogZG90IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNvcnQgZG90cyBieSBsaW5lIG51bWJlci5cclxuICAgIGRvdF9saXN0LnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gKGIubGluZSAtIGEubGluZSk7IH0pO1xyXG5cclxuICAgIHZhciBkb3Rfc2hpZnQgPSByaWdodF9zaGlmdDtcclxuICAgIHZhciB4X3dpZHRoID0gMDtcclxuICAgIHZhciBsYXN0X2xpbmUgPSBudWxsO1xyXG4gICAgdmFyIGxhc3Rfbm90ZSA9IG51bGw7XHJcbiAgICB2YXIgcHJldl9kb3R0ZWRfc3BhY2UgPSBudWxsO1xyXG4gICAgdmFyIGhhbGZfc2hpZnRZID0gMDtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZG90X2xpc3QubGVuZ3RoOyArK2kpIHtcclxuICAgICAgZG90ID0gZG90X2xpc3RbaV0uZG90O1xyXG4gICAgICBub3RlID0gZG90X2xpc3RbaV0ubm90ZTtcclxuICAgICAgc2hpZnQgPSBkb3RfbGlzdFtpXS5zaGlmdDtcclxuICAgICAgdmFyIGxpbmUgPSBkb3RfbGlzdFtpXS5saW5lO1xyXG5cclxuICAgICAgLy8gUmVzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBkb3QgZXZlcnkgbGluZS5cclxuICAgICAgaWYgKGxpbmUgIT0gbGFzdF9saW5lIHx8IG5vdGUgIT0gbGFzdF9ub3RlKSB7XHJcbiAgICAgICAgZG90X3NoaWZ0ID0gc2hpZnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghbm90ZS5pc1Jlc3QoKSAmJiBsaW5lICE9IGxhc3RfbGluZSkge1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhsaW5lICUgMSkgPT0gMC41KSB7XHJcbiAgICAgICAgICAvLyBub3RlIGlzIG9uIGEgc3BhY2UsIHNvIG5vIGRvdCBzaGlmdFxyXG4gICAgICAgICAgaGFsZl9zaGlmdFkgPSAwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIW5vdGUuaXNSZXN0KCkpIHtcclxuICAgICAgICAgIC8vIG5vdGUgaXMgb24gYSBsaW5lLCBzbyBzaGlmdCBkb3QgdG8gc3BhY2UgYWJvdmUgdGhlIGxpbmVcclxuICAgICAgICAgIGhhbGZfc2hpZnRZID0gMC41O1xyXG4gICAgICAgICAgaWYgKGxhc3Rfbm90ZSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgIWxhc3Rfbm90ZS5pc1Jlc3QoKSAmJiBsYXN0X2xpbmUgLSBsaW5lID09IDAuNSkge1xyXG4gICAgICAgICAgICAvLyBwcmV2aW91cyBub3RlIG9uIGEgc3BhY2UsIHNvIHNoaWZ0IGRvdCB0byBzcGFjZSBiZWxvdyB0aGUgbGluZVxyXG4gICAgICAgICAgICBoYWxmX3NoaWZ0WSA9IC0wLjU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUgKyBoYWxmX3NoaWZ0WSA9PSBwcmV2X2RvdHRlZF9zcGFjZSkge1xyXG4gICAgICAgICAgICAvLyBwcmV2aW91cyBzcGFjZSBpcyBkb3R0ZWQsIHNvIHNoaWZ0IGRvdCB0byBzcGFjZSBiZWxvdyB0aGUgbGluZVxyXG4gICAgICAgICAgICAgaGFsZl9zaGlmdFkgPSAtMC41O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY29udmVydCBoYWxmX3NoaWZ0WSB0byBhIG11bHRpcGxpZXIgZm9yIGRvdHMuZHJhdygpXHJcbiAgICAgIGRvdC5kb3Rfc2hpZnRZID0gKC1oYWxmX3NoaWZ0WSk7XHJcbiAgICAgIHByZXZfZG90dGVkX3NwYWNlID0gbGluZSArIGhhbGZfc2hpZnRZO1xyXG5cclxuICAgICAgZG90LnNldFhTaGlmdChkb3Rfc2hpZnQpO1xyXG4gICAgICBkb3Rfc2hpZnQgKz0gZG90LmdldFdpZHRoKCkgKyBkb3Rfc3BhY2luZzsgLy8gc3BhY2luZ1xyXG4gICAgICB4X3dpZHRoID0gKGRvdF9zaGlmdCA+IHhfd2lkdGgpID8gZG90X3NoaWZ0IDogeF93aWR0aDtcclxuICAgICAgbGFzdF9saW5lID0gbGluZTtcclxuICAgICAgbGFzdF9ub3RlID0gbm90ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBVcGRhdGUgc3RhdGUuXHJcbiAgICBzdGF0ZS5yaWdodF9zaGlmdCArPSB4X3dpZHRoO1xyXG4gIH07XHJcblxyXG4gIFZleC5Jbmhlcml0KERvdCwgTW9kaWZpZXIsIHtcclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBEb3Quc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICB0aGlzLm5vdGUgPSBudWxsO1xyXG4gICAgICB0aGlzLmluZGV4ID0gbnVsbDtcclxuICAgICAgdGhpcy5wb3NpdGlvbiA9IE1vZGlmaWVyLlBvc2l0aW9uLlJJR0hUO1xyXG5cclxuICAgICAgdGhpcy5yYWRpdXMgPSAyO1xyXG4gICAgICB0aGlzLnNldFdpZHRoKDUpO1xyXG4gICAgICB0aGlzLmRvdF9zaGlmdFkgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXROb3RlOiBmdW5jdGlvbihub3RlKXtcclxuICAgICAgdGhpcy5ub3RlID0gbm90ZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm5vdGUuZ2V0Q2F0ZWdvcnkoKSA9PT0gJ2dyYWNlbm90ZXMnKSB7XHJcbiAgICAgICAgdGhpcy5yYWRpdXMgKj0gMC41MDtcclxuICAgICAgICB0aGlzLnNldFdpZHRoKDMpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldERvdFNoaWZ0WTogZnVuY3Rpb24oeSkgeyB0aGlzLmRvdF9zaGlmdFkgPSB5OyByZXR1cm4gdGhpczsgfSxcclxuXHJcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxyXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBkb3Qgd2l0aG91dCBhIGNvbnRleHQuXCIpO1xyXG4gICAgICBpZiAoISh0aGlzLm5vdGUgJiYgKHRoaXMuaW5kZXggIT0gbnVsbCkpKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0F0dGFjaGVkTm90ZVwiLFxyXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBkb3Qgd2l0aG91dCBhIG5vdGUgYW5kIGluZGV4LlwiKTtcclxuXHJcbiAgICAgIHZhciBsaW5lX3NwYWNlID0gdGhpcy5ub3RlLnN0YXZlLm9wdGlvbnMuc3BhY2luZ19iZXR3ZWVuX2xpbmVzX3B4O1xyXG5cclxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5ub3RlLmdldE1vZGlmaWVyU3RhcnRYWSh0aGlzLnBvc2l0aW9uLCB0aGlzLmluZGV4KTtcclxuXHJcbiAgICAgIC8vIFNldCB0aGUgc3RhcnRpbmcgeSBjb29yZGluYXRlIHRvIHRoZSBiYXNlIG9mIHRoZSBzdGVtIGZvciBUYWJOb3Rlc1xyXG4gICAgICBpZiAodGhpcy5ub3RlLmdldENhdGVnb3J5KCkgPT09ICd0YWJub3RlcycpIHtcclxuICAgICAgICBzdGFydC55ID0gdGhpcy5ub3RlLmdldFN0ZW1FeHRlbnRzKCkuYmFzZVk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBkb3RfeCA9IChzdGFydC54ICsgdGhpcy54X3NoaWZ0KSArIHRoaXMud2lkdGggLSB0aGlzLnJhZGl1cztcclxuICAgICAgdmFyIGRvdF95ID0gc3RhcnQueSArIHRoaXMueV9zaGlmdCArICh0aGlzLmRvdF9zaGlmdFkgKiBsaW5lX3NwYWNlKTtcclxuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgY3R4LmFyYyhkb3RfeCwgZG90X3ksIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xyXG4gICAgICBjdHguZmlsbCgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gRG90O1xyXG59KCkpO1xyXG5cbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgdGhlIGZvcm1hdHRpbmcgYW5kIGxheW91dCBhbGdvcml0aG1zIHRoYXQgYXJlIHVzZWRcbi8vIHRvIHBvc2l0aW9uIG5vdGVzIGluIGEgdm9pY2UuIFRoZSBhbGdvcml0aG0gY2FuIGFsaWduIG11bHRpcGxlIHZvaWNlcyBib3RoXG4vLyB3aXRoaW4gYSBzdGF2ZSwgYW5kIGFjcm9zcyBtdWx0aXBsZSBzdGF2ZXMuXG4vL1xuLy8gVG8gZG8gdGhpcywgdGhlIGZvcm1hdHRlciBicmVha3MgdXAgdm9pY2VzIGludG8gYSBncmlkIG9mIHJhdGlvbmFsLXZhbHVlZFxuLy8gYHRpY2tzYCwgdG8gd2hpY2ggZWFjaCBub3RlIGlzIGFzc2lnbmVkLiBUaGVuLCBtaW5pbXVtIHdpZHRocyBhcmUgYXNzaWduZWRcbi8vIHRvIGVhY2ggdGljayBiYXNlZCBvbiB0aGUgd2lkdGhzIG9mIHRoZSBub3RlcyBhbmQgbW9kaWZpZXJzIGluIHRoYXQgdGljay4gVGhpc1xuLy8gZXN0YWJsaXNoZXMgdGhlIHNtYWxsZXN0IGFtb3VudCBvZiBzcGFjZSByZXF1aXJlZCBmb3IgZWFjaCB0aWNrLlxuLy9cbi8vIEZpbmFsbHksIHRoZSBmb3JtYXR0ZXIgZGlzdHJpYnV0ZXMgdGhlIGxlZnQgb3ZlciBzcGFjZSBwcm9wb3J0aW9uYWxseSB0b1xuLy8gYWxsIHRoZSB0aWNrcywgc2V0dGluZyB0aGUgYHhgIHZhbHVlcyBvZiB0aGUgbm90ZXMgaW4gZWFjaCB0aWNrLlxuLy9cbi8vIFNlZSBgdGVzdHMvZm9ybWF0dGVyX3Rlc3RzLmpzYCBmb3IgdXNhZ2UgZXhhbXBsZXMuIFRoZSBoZWxwZXIgZnVuY3Rpb25zIGluY2x1ZGVkXG4vLyBoZXJlIChgRm9ybWF0QW5kRHJhd2AsIGBGb3JtYXRBbmREcmF3VGFiYCkgYWxzbyBzZXJ2ZSBhcyB1c2VmdWwgdXNhZ2UgZXhhbXBsZXMuXG5cblZleC5GbG93LkZvcm1hdHRlciA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRm9ybWF0dGVyKCkge1xuICAgIC8vIE1pbmltdW0gd2lkdGggcmVxdWlyZWQgdG8gcmVuZGVyIGFsbCB0aGUgbm90ZXMgaW4gdGhlIHZvaWNlcy5cbiAgICB0aGlzLm1pblRvdGFsV2lkdGggPSAwO1xuXG4gICAgLy8gVGhpcyBpcyBzZXQgdG8gYHRydWVgIGFmdGVyIGBtaW5Ub3RhbFdpZHRoYCBpcyBjYWxjdWxhdGVkLlxuICAgIHRoaXMuaGFzTWluVG90YWxXaWR0aCA9IGZhbHNlO1xuXG4gICAgLy8gVGhlIHN1Z2dlc3RlZCBhbW91bnQgb2Ygc3BhY2UgZm9yIGVhY2ggdGljay5cbiAgICB0aGlzLnBpeGVsc1BlclRpY2sgPSAwO1xuXG4gICAgLy8gVG90YWwgbnVtYmVyIG9mIHRpY2tzIGluIHRoZSB2b2ljZS5cbiAgICB0aGlzLnRvdGFsVGlja3MgPSBuZXcgVmV4LkZsb3cuRnJhY3Rpb24oMCwgMSk7XG5cbiAgICAvLyBBcnJheXMgb2YgdGljayBhbmQgbW9kaWZpZXIgY29udGV4dHMuXG4gICAgdGhpcy50Q29udGV4dHMgPSBudWxsO1xuICAgIHRoaXMubUNvbnRleHRzID0gbnVsbDtcbiAgfVxuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93LkZvcm1hdHRlci5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoRm9ybWF0dGVyLkRFQlVHKSBWZXguTChcIlZleC5GbG93LkZvcm1hdHRlclwiLCBhcmd1bWVudHMpOyB9XG5cbiAgLy8gIyMgUHJpdmF0ZSBIZWxwZXJzXG4gIC8vXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBsb2NhdGUgdGhlIG5leHQgbm9uLXJlc3Qgbm90ZShzKS5cbiAgZnVuY3Rpb24gbG9va0FoZWFkKG5vdGVzLCByZXN0X2xpbmUsIGksIGNvbXBhcmUpIHtcbiAgICAvLyBJZiBubyB2YWxpZCBuZXh0IG5vdGUgZ3JvdXAsIG5leHRfcmVzdF9saW5lIGlzIHNhbWUgYXMgY3VycmVudC5cbiAgICB2YXIgbmV4dF9yZXN0X2xpbmUgPSByZXN0X2xpbmU7XG5cbiAgICAvLyBHZXQgdGhlIHJlc3QgbGluZSBmb3IgbmV4dCB2YWxpZCBub24tcmVzdCBub3RlIGdyb3VwLlxuICAgIGkrKztcbiAgICB3aGlsZSAoaSA8IG5vdGVzLmxlbmd0aCkge1xuICAgICAgaWYgKCFub3Rlc1tpXS5pc1Jlc3QoKSAmJiAhbm90ZXNbaV0uc2hvdWxkSWdub3JlVGlja3MoKSkge1xuICAgICAgICBuZXh0X3Jlc3RfbGluZSA9IG5vdGVzW2ldLmdldExpbmVGb3JSZXN0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIC8vIExvY2F0ZSB0aGUgbWlkIHBvaW50IGJldHdlZW4gdHdvIGxpbmVzLlxuICAgIGlmIChjb21wYXJlICYmIHJlc3RfbGluZSAhPSBuZXh0X3Jlc3RfbGluZSkge1xuICAgICAgdmFyIHRvcCA9IFZleC5NYXgocmVzdF9saW5lLCBuZXh0X3Jlc3RfbGluZSk7XG4gICAgICB2YXIgYm90ID0gVmV4Lk1pbihyZXN0X2xpbmUsIG5leHRfcmVzdF9saW5lKTtcbiAgICAgIG5leHRfcmVzdF9saW5lID0gVmV4Lk1pZExpbmUodG9wLCBib3QpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dF9yZXN0X2xpbmU7XG4gIH1cblxuICAvLyBUYWtlIGFuIGFycmF5IG9mIGB2b2ljZXNgIGFuZCBwbGFjZSBhbGlnbmVkIHRpY2thYmxlcyBpbiB0aGUgc2FtZSBjb250ZXh0LiBSZXR1cm5zXG4gIC8vIGEgbWFwcGluZyBmcm9tIGB0aWNrYCB0byBgY29udGV4dF90eXBlYCwgYSBsaXN0IG9mIGB0aWNrYHMsIGFuZCB0aGUgcmVzb2x1dGlvblxuICAvLyBtdWx0aXBsaWVyLlxuICAvL1xuICAvLyBQYXJhbXM6XG4gIC8vICogYHZvaWNlc2A6IEFycmF5IG9mIGBWb2ljZWAgaW5zdGFuY2VzLlxuICAvLyAqIGBjb250ZXh0X3R5cGVgOiBBIGNvbnRleHQgY2xhc3MgKGUuZy4sIGBNb2RpZmllckNvbnRleHRgLCBgVGlja0NvbnRleHRgKVxuICAvLyAqIGBhZGRfZm5gOiBGdW5jdGlvbiB0byBhZGQgdGlja2FibGUgdG8gY29udGV4dC5cbiAgZnVuY3Rpb24gY3JlYXRlQ29udGV4dHModm9pY2VzLCBjb250ZXh0X3R5cGUsIGFkZF9mbikge1xuICAgIGlmICghdm9pY2VzIHx8ICF2b2ljZXMubGVuZ3RoKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudFwiLFxuICAgICAgICBcIk5vIHZvaWNlcyB0byBmb3JtYXRcIik7XG5cbiAgICAvLyBJbml0aWFsaXplIHRpY2sgbWFwcy5cbiAgICB2YXIgdG90YWxUaWNrcyA9IHZvaWNlc1swXS5nZXRUb3RhbFRpY2tzKCk7XG4gICAgdmFyIHRpY2tUb0NvbnRleHRNYXAgPSB7fTtcbiAgICB2YXIgdGlja0xpc3QgPSBbXTtcbiAgICB2YXIgY29udGV4dHMgPSBbXTtcblxuICAgIHZhciByZXNvbHV0aW9uTXVsdGlwbGllciA9IDE7XG5cbiAgICAvLyBGaW5kIG91dCBoaWdoZXN0IGNvbW1vbiBtdWx0aXBsZSBvZiByZXNvbHV0aW9uIG11bHRpcGxpZXJzLlxuICAgIC8vIFRoZSBwdXJwb3NlIG9mIHRoaXMgaXMgdG8gZmluZCBvdXQgYSBjb21tb24gZGVub21pbmF0b3JcbiAgICAvLyBmb3IgYWxsIGZyYWN0aW9uYWwgdGljayB2YWx1ZXMgaW4gYWxsIHRpY2thYmxlcyBvZiBhbGwgdm9pY2VzLFxuICAgIC8vIHNvIHRoYXQgdGhlIHZhbHVlcyBjYW4gYmUgZXhwYW5kZWQgYW5kIHRoZSBudW1lcmF0b3IgdXNlZFxuICAgIC8vIGFzIGFuIGludGVnZXIgdGljayB2YWx1ZS5cbiAgICB2YXIgaTsgLy8gc2hhcmVkIGl0ZXJhdG9yXG4gICAgdmFyIHZvaWNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2b2ljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZvaWNlID0gdm9pY2VzW2ldO1xuICAgICAgaWYgKCEodm9pY2UuZ2V0VG90YWxUaWNrcygpLmVxdWFscyh0b3RhbFRpY2tzKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiVGlja01pc21hdGNoXCIsXG4gICAgICAgICAgICBcIlZvaWNlcyBzaG91bGQgaGF2ZSBzYW1lIHRvdGFsIG5vdGUgZHVyYXRpb24gaW4gdGlja3MuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodm9pY2UuZ2V0TW9kZSgpID09IFZleC5GbG93LlZvaWNlLk1vZGUuU1RSSUNUICYmICF2b2ljZS5pc0NvbXBsZXRlKCkpXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkluY29tcGxldGVWb2ljZVwiLFxuICAgICAgICAgIFwiVm9pY2UgZG9lcyBub3QgaGF2ZSBlbm91Z2ggbm90ZXMuXCIpO1xuXG4gICAgICB2YXIgbGNtID0gVmV4LkZsb3cuRnJhY3Rpb24uTENNKHJlc29sdXRpb25NdWx0aXBsaWVyLFxuICAgICAgICAgIHZvaWNlLmdldFJlc29sdXRpb25NdWx0aXBsaWVyKCkpO1xuICAgICAgaWYgKHJlc29sdXRpb25NdWx0aXBsaWVyIDwgbGNtKSB7XG4gICAgICAgIHJlc29sdXRpb25NdWx0aXBsaWVyID0gbGNtO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBlYWNoIHZvaWNlLCBleHRyYWN0IG5vdGVzIGFuZCBjcmVhdGUgYSBjb250ZXh0IGZvciBldmVyeVxuICAgIC8vIG5ldyB0aWNrIHRoYXQgaGFzbid0IGJlZW4gc2VlbiBiZWZvcmUuXG4gICAgZm9yIChpID0gMDsgaSA8IHZvaWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdm9pY2UgPSB2b2ljZXNbaV07XG5cbiAgICAgIHZhciB0aWNrYWJsZXMgPSB2b2ljZS5nZXRUaWNrYWJsZXMoKTtcblxuICAgICAgLy8gVXNlIHJlc29sdXRpb24gbXVsdGlwbGllciBhcyBkZW5vbWluYXRvciB0byBleHBhbmQgdGlja3NcbiAgICAgIC8vIHRvIHN1aXRhYmxlIGludGVnZXIgdmFsdWVzLCBzbyB0aGF0IG5vIGFkZGl0aW9uYWwgZXhwYW5zaW9uXG4gICAgICAvLyBvZiBmcmFjdGlvbmFsIHRpY2sgdmFsdWVzIGlzIG5lZWRlZC5cbiAgICAgIHZhciB0aWNrc1VzZWQgPSBuZXcgVmV4LkZsb3cuRnJhY3Rpb24oMCwgcmVzb2x1dGlvbk11bHRpcGxpZXIpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRpY2thYmxlcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgdGlja2FibGUgPSB0aWNrYWJsZXNbal07XG4gICAgICAgIHZhciBpbnRlZ2VyVGlja3MgPSB0aWNrc1VzZWQubnVtZXJhdG9yO1xuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbm8gdGljayBjb250ZXh0IGZvciB0aGlzIHRpY2ssIGNyZWF0ZSBvbmUuXG4gICAgICAgIGlmICghdGlja1RvQ29udGV4dE1hcFtpbnRlZ2VyVGlja3NdKSB7XG4gICAgICAgICAgdmFyIG5ld0NvbnRleHQgPSBuZXcgY29udGV4dF90eXBlKCk7XG4gICAgICAgICAgY29udGV4dHMucHVzaChuZXdDb250ZXh0KTtcbiAgICAgICAgICB0aWNrVG9Db250ZXh0TWFwW2ludGVnZXJUaWNrc10gPSBuZXdDb250ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoaXMgdGlja2FibGUgdG8gdGhlIFRpY2tDb250ZXh0LlxuICAgICAgICBhZGRfZm4odGlja2FibGUsIHRpY2tUb0NvbnRleHRNYXBbaW50ZWdlclRpY2tzXSk7XG5cbiAgICAgICAgLy8gTWFpbnRhaW4gYSBzb3J0ZWQgbGlzdCBvZiB0aWNrIGNvbnRleHRzLlxuICAgICAgICB0aWNrTGlzdC5wdXNoKGludGVnZXJUaWNrcyk7XG4gICAgICAgIHRpY2tzVXNlZC5hZGQodGlja2FibGUuZ2V0VGlja3MoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcDogdGlja1RvQ29udGV4dE1hcCxcbiAgICAgIGFycmF5OiBjb250ZXh0cyxcbiAgICAgIGxpc3Q6IFZleC5Tb3J0QW5kVW5pcXVlKHRpY2tMaXN0LCBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSxcbiAgICAgICAgICBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhID09PSBiOyB9ICksXG4gICAgICByZXNvbHV0aW9uTXVsdGlwbGllcjogcmVzb2x1dGlvbk11bHRpcGxpZXJcbiAgICB9O1xuICB9XG5cblxuICAvLyAjIyBTdGF0aWMgTWV0aG9kc1xuICAvL1xuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZm9ybWF0IGFuZCBkcmF3IGEgc2luZ2xlIHZvaWNlLiBSZXR1cm5zIGEgYm91bmRpbmdcbiAgLy8gYm94IGZvciB0aGUgbm90YXRpb24uXG4gIC8vXG4gIC8vIFBhcmFtZXRlcnM6XG4gIC8vICogYGN0eGAgLSBUaGUgcmVuZGVyaW5nIGNvbnRleHRcbiAgLy8gKiBgc3RhdmVgIC0gVGhlIHN0YXZlIHRvIHdoaWNoIHRvIGRyYXcgKGBTdGF2ZWAgb3IgYFRhYlN0YXZlYClcbiAgLy8gKiBgbm90ZXNgIC0gQXJyYXkgb2YgYE5vdGVgIGluc3RhbmNlcyAoYFN0YXZlTm90ZWAsIGBUZXh0Tm90ZWAsIGBUYWJOb3RlYCwgZXRjLilcbiAgLy8gKiBgcGFyYW1zYCAtIE9uZSBvZiBiZWxvdzpcbiAgLy8gICAgKiBTZXR0aW5nIGBhdXRvYmVhbWAgb25seSBgKGNvbnRleHQsIHN0YXZlLCBub3RlcywgdHJ1ZSlgIG9yIGAoY3R4LCBzdGF2ZSwgbm90ZXMsIHthdXRvYmVhbTogdHJ1ZX0pYFxuICAvLyAgICAqIFNldHRpbmcgYGFsaWduX3Jlc3RzYCBhIHN0cnVjdCBpcyBuZWVkZWQgYChjb250ZXh0LCBzdGF2ZSwgbm90ZXMsIHthbGlnbl9yZXN0czogdHJ1ZX0pYFxuICAvLyAgICAqIFNldHRpbmcgYm90aCBhIHN0cnVjdCBpcyBuZWVkZWQgYChjb250ZXh0LCBzdGF2ZSwgbm90ZXMsIHthdXRvYmVhbTogdHJ1ZSwgYWxpZ25fcmVzdHM6IHRydWV9KWBcbiAgLy9cbiAgLy8gYGF1dG9iZWFtYCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlcyBiZWFtcyBmb3IgdGhlIG5vdGVzLlxuICAvLyBgYWxpZ25fcmVzdHNgIGFsaWducyByZXN0cyB3aXRoIG5lYXJieSBub3Rlcy5cbiAgRm9ybWF0dGVyLkZvcm1hdEFuZERyYXcgPSBmdW5jdGlvbihjdHgsIHN0YXZlLCBub3RlcywgcGFyYW1zKSB7XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICBhdXRvX2JlYW06IGZhbHNlLFxuICAgICAgYWxpZ25fcmVzdHM6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zID09IFwib2JqZWN0XCIpIHtcbiAgICAgIFZleC5NZXJnZShvcHRzLCBwYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PSBcImJvb2xlYW5cIikge1xuICAgICAgb3B0cy5hdXRvX2JlYW0gPSBwYXJhbXM7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgYnkgY3JlYXRpbmcgYSB2b2ljZSBhbmQgYWRkaW5nIGFsbCB0aGUgbm90ZXMgdG8gaXQuXG4gICAgdmFyIHZvaWNlID0gbmV3IFZleC5GbG93LlZvaWNlKFZleC5GbG93LlRJTUU0XzQpLlxuICAgICAgc2V0TW9kZShWZXguRmxvdy5Wb2ljZS5Nb2RlLlNPRlQpO1xuICAgIHZvaWNlLmFkZFRpY2thYmxlcyhub3Rlcyk7XG5cbiAgICAvLyBUaGVuIGNyZWF0ZSBiZWFtcywgaWYgcmVxdWVzdGVkLlxuICAgIHZhciBiZWFtcyA9IG51bGw7XG4gICAgaWYgKG9wdHMuYXV0b19iZWFtKSB7XG4gICAgICBiZWFtcyA9IFZleC5GbG93LkJlYW0uYXBwbHlBbmRHZXRCZWFtcyh2b2ljZSk7XG4gICAgfVxuXG4gICAgLy8gSW5zdGFudGlhdGUgYSBgRm9ybWF0dGVyYCBhbmQgZm9ybWF0IHRoZSBub3Rlcy5cbiAgICBuZXcgRm9ybWF0dGVyKCkuXG4gICAgICBqb2luVm9pY2VzKFt2b2ljZV0sIHthbGlnbl9yZXN0czogb3B0cy5hbGlnbl9yZXN0c30pLlxuICAgICAgZm9ybWF0VG9TdGF2ZShbdm9pY2VdLCBzdGF2ZSwge2FsaWduX3Jlc3RzOiBvcHRzLmFsaWduX3Jlc3RzfSk7XG5cbiAgICAvLyBSZW5kZXIgdGhlIHZvaWNlIGFuZCBiZWFtcyB0byB0aGUgc3RhdmUuXG4gICAgdm9pY2Uuc2V0U3RhdmUoc3RhdmUpO1xuICAgIHZvaWNlLmRyYXcoY3R4LCBzdGF2ZSk7XG4gICAgaWYgKGJlYW1zICE9IG51bGwpIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxiZWFtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBiZWFtc1tpXS5zZXRDb250ZXh0KGN0eCkuZHJhdygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB2b2ljZS5cbiAgICByZXR1cm4gdm9pY2UuZ2V0Qm91bmRpbmdCb3goKTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZm9ybWF0IGFuZCBkcmF3IGFsaWduZWQgdGFiIGFuZCBzdGF2ZSBub3RlcyBpbiB0d29cbiAgLy8gc2VwYXJhdGUgc3RhdmVzLlxuICAvL1xuICAvLyBQYXJhbWV0ZXJzOlxuICAvLyAqIGBjdHhgIC0gVGhlIHJlbmRlcmluZyBjb250ZXh0XG4gIC8vICogYHRhYnN0YXZlYCAtIEEgYFRhYlN0YXZlYCBpbnN0YW5jZSBvbiB3aGljaCB0byByZW5kZXIgYFRhYk5vdGVgcy5cbiAgLy8gKiBgc3RhdmVgIC0gQSBgU3RhdmVgIGluc3RhbmNlIG9uIHdoaWNoIHRvIHJlbmRlciBgTm90ZWBzLlxuICAvLyAqIGBub3Rlc2AgLSBBcnJheSBvZiBgTm90ZWAgaW5zdGFuY2VzIGZvciB0aGUgc3RhdmUgKGBTdGF2ZU5vdGVgLCBgQmFyTm90ZWAsIGV0Yy4pXG4gIC8vICogYHRhYm5vdGVzYCAtIEFycmF5IG9mIGBOb3RlYCBpbnN0YW5jZXMgZm9yIHRoZSB0YWIgc3RhdmUgKGBUYWJOb3RlYCwgYEJhck5vdGVgLCBldGMuKVxuICAvLyAqIGBhdXRvYmVhbWAgLSBBdXRvbWF0aWNhbGx5IGdlbmVyYXRlIGJlYW1zLlxuICAvLyAqIGBwYXJhbXNgIC0gQSBjb25maWd1cmF0aW9uIG9iamVjdDpcbiAgLy8gICAgKiBgYXV0b2JlYW1gIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzIGJlYW1zIGZvciB0aGUgbm90ZXMuXG4gIC8vICAgICogYGFsaWduX3Jlc3RzYCBhbGlnbnMgcmVzdHMgd2l0aCBuZWFyYnkgbm90ZXMuXG4gIEZvcm1hdHRlci5Gb3JtYXRBbmREcmF3VGFiID0gZnVuY3Rpb24oY3R4LFxuICAgICAgdGFic3RhdmUsIHN0YXZlLCB0YWJub3Rlcywgbm90ZXMsIGF1dG9iZWFtLCBwYXJhbXMpIHtcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIGF1dG9fYmVhbTogYXV0b2JlYW0sXG4gICAgICBhbGlnbl9yZXN0czogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXCJvYmplY3RcIikge1xuICAgICAgVmV4Lk1lcmdlKG9wdHMsIHBhcmFtcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09IFwiYm9vbGVhblwiKSB7XG4gICAgICBvcHRzLmF1dG9fYmVhbSA9IHBhcmFtcztcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBgNC80YCB2b2ljZSBmb3IgYG5vdGVzYC5cbiAgICB2YXIgbm90ZXZvaWNlID0gbmV3IFZleC5GbG93LlZvaWNlKFZleC5GbG93LlRJTUU0XzQpLlxuICAgICAgc2V0TW9kZShWZXguRmxvdy5Wb2ljZS5Nb2RlLlNPRlQpO1xuICAgIG5vdGV2b2ljZS5hZGRUaWNrYWJsZXMobm90ZXMpO1xuXG4gICAgLy8gQ3JlYXRlIGEgYDQvNGAgdm9pY2UgZm9yIGB0YWJub3Rlc2AuXG4gICAgdmFyIHRhYnZvaWNlID0gbmV3IFZleC5GbG93LlZvaWNlKFZleC5GbG93LlRJTUU0XzQpLlxuICAgICAgc2V0TW9kZShWZXguRmxvdy5Wb2ljZS5Nb2RlLlNPRlQpO1xuICAgIHRhYnZvaWNlLmFkZFRpY2thYmxlcyh0YWJub3Rlcyk7XG5cbiAgICAvLyBHZW5lcmF0ZSBiZWFtcyBpZiByZXF1ZXN0ZWQuXG4gICAgdmFyIGJlYW1zID0gbnVsbDtcbiAgICBpZiAob3B0cy5hdXRvX2JlYW0pIHtcbiAgICAgIGJlYW1zID0gVmV4LkZsb3cuQmVhbS5hcHBseUFuZEdldEJlYW1zKG5vdGV2b2ljZSk7XG4gICAgfVxuXG5cbiAgICAvLyBJbnN0YW50aWF0ZSBhIGBGb3JtYXR0ZXJgIGFuZCBhbGlnbiB0YWIgYW5kIHN0YXZlIG5vdGVzLlxuICAgIG5ldyBGb3JtYXR0ZXIoKS5cbiAgICAgIGpvaW5Wb2ljZXMoW25vdGV2b2ljZV0sIHthbGlnbl9yZXN0czogb3B0cy5hbGlnbl9yZXN0c30pLlxuICAgICAgam9pblZvaWNlcyhbdGFidm9pY2VdKS5cbiAgICAgIGZvcm1hdFRvU3RhdmUoW25vdGV2b2ljZSx0YWJ2b2ljZV0sIHN0YXZlLCB7YWxpZ25fcmVzdHM6IG9wdHMuYWxpZ25fcmVzdHN9KTtcblxuICAgIC8vIFJlbmRlciB2b2ljZXMgYW5kIGJlYW1zIHRvIHN0YXZlcy5cbiAgICBub3Rldm9pY2UuZHJhdyhjdHgsIHN0YXZlKTtcbiAgICB0YWJ2b2ljZS5kcmF3KGN0eCwgdGFic3RhdmUpO1xuICAgIGlmIChiZWFtcyAhPSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8YmVhbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYmVhbXNbaV0uc2V0Q29udGV4dChjdHgpLmRyYXcoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEcmF3IGEgY29ubmVjdG9yIGJldHdlZW4gdGFiIGFuZCBub3RlIHN0YXZlcy5cbiAgICAobmV3IFZleC5GbG93LlN0YXZlQ29ubmVjdG9yKHN0YXZlLCB0YWJzdGF2ZSkpLnNldENvbnRleHQoY3R4KS5kcmF3KCk7XG4gIH07XG5cbiAgLy8gQXV0byBwb3NpdGlvbiByZXN0cyBiYXNlZCBvbiBwcmV2aW91cy9uZXh0IG5vdGUgcG9zaXRpb25zLlxuICAvL1xuICAvLyBQYXJhbXM6XG4gIC8vICogYG5vdGVzYDogQW4gYXJyYXkgb2Ygbm90ZXMuXG4gIC8vICogYGFsaWduX2FsbF9ub3Rlc2A6IElmIHNldCB0byBmYWxzZSwgb25seSBhbGlnbnMgbm9uLWJlYW1lZCBub3Rlcy5cbiAgLy8gKiBgYWxpZ25fdHVwbGV0c2A6IElmIHNldCB0byBmYWxzZSwgaWdub3JlcyB0dXBsZXRzLlxuICBGb3JtYXR0ZXIuQWxpZ25SZXN0c1RvTm90ZXMgPSBmdW5jdGlvbihub3RlcywgYWxpZ25fYWxsX25vdGVzLCBhbGlnbl90dXBsZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKG5vdGVzW2ldIGluc3RhbmNlb2YgVmV4LkZsb3cuU3RhdmVOb3RlICYmIG5vdGVzW2ldLmlzUmVzdCgpKSB7XG4gICAgICAgIHZhciBub3RlID0gbm90ZXNbaV07XG5cbiAgICAgICAgaWYgKG5vdGUudHVwbGV0ICYmICFhbGlnbl90dXBsZXRzKSBjb250aW51ZTtcblxuICAgICAgICAvLyBJZiBhY3RpdmF0ZWQgcmVzdHMgbm90IG9uIGRlZmF1bHQgY2FuIGJlIHJlbmRlcmVkIGFzIHNwZWNpZmllZC5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbm90ZS5nZXRHbHlwaCgpLnBvc2l0aW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbiAhPSBcIlIvNFwiICYmIHBvc2l0aW9uICE9IFwiQi80XCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbGlnbl9hbGxfbm90ZXMgfHwgbm90ZS5iZWFtICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBBbGlnbiByZXN0cyB3aXRoIHByZXZpb3VzL25leHQgbm90ZXMuXG4gICAgICAgICAgdmFyIHByb3BzID0gbm90ZS5nZXRLZXlQcm9wcygpWzBdO1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBwcm9wcy5saW5lID0gbG9va0FoZWFkKG5vdGVzLCBwcm9wcy5saW5lLCBpLCBmYWxzZSk7XG4gICAgICAgICAgICBub3RlLnNldEtleUxpbmUoMCwgcHJvcHMubGluZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID4gMCAmJiBpIDwgbm90ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBub3RlIGlzIGEgcmVzdCwgdXNlIGl0cyBsaW5lIG51bWJlci5cbiAgICAgICAgICAgIHZhciByZXN0X2xpbmU7XG4gICAgICAgICAgICBpZiAobm90ZXNbaS0xXS5pc1Jlc3QoKSkge1xuICAgICAgICAgICAgICByZXN0X2xpbmUgPSBub3Rlc1tpLTFdLmdldEtleVByb3BzKClbMF0ubGluZTtcbiAgICAgICAgICAgICAgcHJvcHMubGluZSA9IHJlc3RfbGluZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3RfbGluZSA9IG5vdGVzW2ktMV0uZ2V0TGluZUZvclJlc3QoKTtcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZXN0IGxpbmUgZm9yIG5leHQgdmFsaWQgbm9uLXJlc3Qgbm90ZSBncm91cC5cbiAgICAgICAgICAgICAgcHJvcHMubGluZSA9IGxvb2tBaGVhZChub3RlcywgcmVzdF9saW5lLCBpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vdGUuc2V0S2V5TGluZSgwLCBwcm9wcy5saW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICBGb3JtYXR0ZXIucHJvdG90eXBlID0ge1xuICAgIC8vIEZpbmQgYWxsIHRoZSByZXN0cyBpbiBlYWNoIG9mIHRoZSBgdm9pY2VzYCBhbmQgYWxpZ24gdGhlbVxuICAgIC8vIHRvIG5laWdoYm9yaW5nIG5vdGVzLiBJZiBgYWxpZ25fYWxsX25vdGVzYCBpcyBgZmFsc2VgLCB0aGVuIG9ubHlcbiAgICAvLyBhbGlnbiBub24tYmVhbWVkIG5vdGVzLlxuICAgIGFsaWduUmVzdHM6IGZ1bmN0aW9uKHZvaWNlcywgYWxpZ25fYWxsX25vdGVzKSB7XG4gICAgICBpZiAoIXZvaWNlcyB8fCAhdm9pY2VzLmxlbmd0aCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRcIixcbiAgICAgICAgICBcIk5vIHZvaWNlcyB0byBmb3JtYXQgcmVzdHNcIik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZvaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXcgRm9ybWF0dGVyLkFsaWduUmVzdHNUb05vdGVzKHZvaWNlc1tpXS50aWNrYWJsZXMsIGFsaWduX2FsbF9ub3Rlcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWluaW11bSB3aWR0aCByZXF1aXJlZCB0byBhbGlnbiBhbmQgZm9ybWF0IGB2b2ljZXNgLlxuICAgIHByZUNhbGN1bGF0ZU1pblRvdGFsV2lkdGg6IGZ1bmN0aW9uKHZvaWNlcykge1xuICAgICAgLy8gQ2FjaGUgcmVzdWx0cy5cbiAgICAgIGlmICh0aGlzLmhhc01pblRvdGFsV2lkdGgpIHJldHVybjtcblxuICAgICAgLy8gQ3JlYXRlIHRpY2sgY29udGV4dHMgaWYgbm90IGFscmVhZHkgY3JlYXRlZC5cbiAgICAgIGlmICghdGhpcy50Q29udGV4dHMpIHtcbiAgICAgICAgaWYgKCF2b2ljZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIid2b2ljZXMnIHJlcXVpcmVkIHRvIHJ1biBwcmVDYWxjdWxhdGVNaW5Ub3RhbFdpZHRoXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlVGlja0NvbnRleHRzKHZvaWNlcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMudENvbnRleHRzO1xuICAgICAgdmFyIGNvbnRleHRMaXN0ID0gY29udGV4dHMubGlzdDtcbiAgICAgIHZhciBjb250ZXh0TWFwID0gY29udGV4dHMubWFwO1xuXG4gICAgICB0aGlzLm1pblRvdGFsV2lkdGggPSAwO1xuXG4gICAgICAvLyBHbyB0aHJvdWdoIGVhY2ggdGljayBjb250ZXh0IGFuZCBjYWxjdWxhdGUgdG90YWwgd2lkdGguXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHRMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dE1hcFtjb250ZXh0TGlzdFtpXV07XG5cbiAgICAgICAgLy8gYHByZUZvcm1hdGAgZ2V0cyB0aGVtIHRvIGRlc2NlbmQgZG93biB0byB0aGVpciB0aWNrYWJsZXMgYW5kIG1vZGlmaWVyXG4gICAgICAgIC8vIGNvbnRleHRzLCBhbmQgY2FsY3VsYXRlIHRoZWlyIHdpZHRocy5cbiAgICAgICAgY29udGV4dC5wcmVGb3JtYXQoKTtcbiAgICAgICAgdGhpcy5taW5Ub3RhbFdpZHRoICs9IGNvbnRleHQuZ2V0V2lkdGgoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5oYXNNaW5Ub3RhbFdpZHRoID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIHRoaXMubWluVG90YWxXaWR0aDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IG1pbmltdW0gd2lkdGggcmVxdWlyZWQgdG8gcmVuZGVyIGFsbCB2b2ljZXMuIEVpdGhlciBgZm9ybWF0YCBvclxuICAgIC8vIGBwcmVDYWxjdWxhdGVNaW5Ub3RhbFdpZHRoYCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgdGhpcyBtZXRob2QuXG4gICAgZ2V0TWluVG90YWxXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzTWluVG90YWxXaWR0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb01pblRvdGFsV2lkdGhcIixcbiAgICAgICAgICAgIFwiTmVlZCB0byBjYWxsICdwcmVDYWxjdWxhdGVNaW5Ub3RhbFdpZHRoJyBvciAncHJlRm9ybWF0JyBiZWZvcmVcIiArXG4gICAgICAgICAgICBcIiBjYWxsaW5nICdnZXRNaW5Ub3RhbFdpZHRoJ1wiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubWluVG90YWxXaWR0aDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGBNb2RpZmllckNvbnRleHRgcyBmb3IgZWFjaCB0aWNrIGluIGB2b2ljZXNgLlxuICAgIGNyZWF0ZU1vZGlmaWVyQ29udGV4dHM6IGZ1bmN0aW9uKHZvaWNlcykge1xuICAgICAgdmFyIGNvbnRleHRzID0gY3JlYXRlQ29udGV4dHModm9pY2VzLFxuICAgICAgICAgIFZleC5GbG93Lk1vZGlmaWVyQ29udGV4dCxcbiAgICAgICAgICBmdW5jdGlvbih0aWNrYWJsZSwgY29udGV4dCkge1xuICAgICAgICAgICAgdGlja2FibGUuYWRkVG9Nb2RpZmllckNvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgfSk7XG4gICAgICB0aGlzLm1Db250ZXh0cyA9IGNvbnRleHRzO1xuICAgICAgcmV0dXJuIGNvbnRleHRzO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYFRpY2tDb250ZXh0YHMgZm9yIGVhY2ggdGljayBpbiBgdm9pY2VzYC4gQWxzbyBjYWxjdWxhdGUgdGhlXG4gICAgLy8gdG90YWwgbnVtYmVyIG9mIHRpY2tzIGluIHZvaWNlcy5cbiAgICBjcmVhdGVUaWNrQ29udGV4dHM6IGZ1bmN0aW9uKHZvaWNlcykge1xuICAgICAgdmFyIGNvbnRleHRzID0gY3JlYXRlQ29udGV4dHModm9pY2VzLFxuICAgICAgICAgIFZleC5GbG93LlRpY2tDb250ZXh0LFxuICAgICAgICAgIGZ1bmN0aW9uKHRpY2thYmxlLCBjb250ZXh0KSB7IGNvbnRleHQuYWRkVGlja2FibGUodGlja2FibGUpOyB9KTtcblxuICAgICAgY29udGV4dHMuYXJyYXkuZm9yRWFjaChmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQudENvbnRleHRzID0gY29udGV4dHMuYXJyYXk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy50b3RhbFRpY2tzID0gdm9pY2VzWzBdLmdldFRpY2tzVXNlZCgpLmNsb25lKCk7XG4gICAgICB0aGlzLnRDb250ZXh0cyA9IGNvbnRleHRzO1xuICAgICAgcmV0dXJuIGNvbnRleHRzO1xuICAgIH0sXG5cbiAgICAvLyBUaGlzIGlzIHRoZSBjb3JlIGZvcm1hdHRlciBsb2dpYy4gRm9ybWF0IHZvaWNlcyBhbmQganVzdGlmeSB0aGVtXG4gICAgLy8gdG8gYGp1c3RpZnlXaWR0aGAgcGl4ZWxzLiBgcmVuZGVyaW5nX2NvbnRleHRgIGlzIHJlcXVpcmVkIHRvIGp1c3RpZnkgZWxlbWVudHNcbiAgICAvLyB0aGF0IGNhbid0IHJldHJlaXZlIHdpZHRocyB3aXRob3V0IGEgY2FudmFzLiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBgeGAgcG9zaXRpb25zXG4gICAgLy8gb2YgYWxsIHRoZSB0aWNrYWJsZXMvbm90ZXMgaW4gdGhlIGZvcm1hdHRlci5cbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKGp1c3RpZnlXaWR0aCwgcmVuZGVyaW5nX2NvbnRleHQsIHZvaWNlcywgc3RhdmUpIHtcbiAgICAgIC8vIEluaXRpYWxpemUgY29udGV4dCBtYXBzLlxuICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy50Q29udGV4dHM7XG4gICAgICB2YXIgY29udGV4dExpc3QgPSBjb250ZXh0cy5saXN0O1xuICAgICAgdmFyIGNvbnRleHRNYXAgPSBjb250ZXh0cy5tYXA7XG5cbiAgICAgIC8vIElmIHZvaWNlcyBhbmQgYSBzdGF2ZSB3ZXJlIHByb3ZpZGVkLCBzZXQgdGhlIFN0YXZlIGZvciBlYWNoIHZvaWNlXG4gICAgICAvLyBhbmQgcHJlRm9ybWF0IHRvIGFwcGx5IFkgdmFsdWVzIHRvIHRoZSBub3RlcztcbiAgICAgIGlmICh2b2ljZXMgJiYgc3RhdmUpIHtcbiAgICAgICAgdm9pY2VzLmZvckVhY2goZnVuY3Rpb24odm9pY2UpIHtcbiAgICAgICAgICB2b2ljZS5zZXRTdGF2ZShzdGF2ZSk7XG4gICAgICAgICAgdm9pY2UucHJlRm9ybWF0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBGaWd1cmUgb3V0IGhvdyBtYW55IHBpeGVscyB0byBhbGxvY2F0ZSBwZXIgdGljay5cbiAgICAgIGlmICghanVzdGlmeVdpZHRoKSB7XG4gICAgICAgIGp1c3RpZnlXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMucGl4ZWxzUGVyVGljayA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBpeGVsc1BlclRpY2sgPSBqdXN0aWZ5V2lkdGggLyAodGhpcy50b3RhbFRpY2tzLnZhbHVlKCkgKiBjb250ZXh0cy5yZXNvbHV0aW9uTXVsdGlwbGllcik7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyBkaXN0cmlidXRlIHRoZSB0aWNrcyB0byBlYWNoIHRpY2sgY29udGV4dCwgYW5kIGFzc2lnbiB0aGVtIHRoZWlyXG4gICAgICAvLyBvd24gWCBwb3NpdGlvbnMuXG4gICAgICB2YXIgeCA9IDA7XG4gICAgICB2YXIgY2VudGVyX3ggPSBqdXN0aWZ5V2lkdGggLyAyO1xuICAgICAgdmFyIHdoaXRlX3NwYWNlID0gMDsgLy8gV2hpdGUgc3BhY2UgdG8gcmlnaHQgb2YgcHJldmlvdXMgbm90ZVxuICAgICAgdmFyIHRpY2tfc3BhY2UgPSAwOyAgLy8gUGl4ZWxzIGZyb20gcHJldiBub3RlIHgtcG9zIHRvIGN1cmVudCBub3RlIHgtcG9zXG4gICAgICB2YXIgcHJldl90aWNrID0gMDtcbiAgICAgIHZhciBwcmV2X3dpZHRoID0gMDtcbiAgICAgIHZhciBsYXN0TWV0cmljcyA9IG51bGw7XG4gICAgICB2YXIgaW5pdGlhbF9qdXN0aWZ5X3dpZHRoID0ganVzdGlmeVdpZHRoO1xuICAgICAgdGhpcy5taW5Ub3RhbFdpZHRoID0gMDtcblxuICAgICAgdmFyIGksIHRpY2ssIGNvbnRleHQ7XG5cbiAgICAgIC8vIFBhc3MgMTogR2l2ZSBlYWNoIG5vdGUgbWF4aW11bSB3aWR0aCByZXF1ZXN0ZWQgYnkgY29udGV4dC5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250ZXh0TGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aWNrID0gY29udGV4dExpc3RbaV07XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0TWFwW3RpY2tdO1xuICAgICAgICBpZiAocmVuZGVyaW5nX2NvbnRleHQpIGNvbnRleHQuc2V0Q29udGV4dChyZW5kZXJpbmdfY29udGV4dCk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYWxsIHRpY2thYmxlcyBpbiB0aGlzIGNvbnRleHQgaGF2ZSBjYWxjdWxhdGVkIHRoZWlyXG4gICAgICAgIC8vIHNwYWNlIHJlcXVpcmVtZW50cy5cbiAgICAgICAgY29udGV4dC5wcmVGb3JtYXQoKTtcblxuICAgICAgICB2YXIgdGhpc01ldHJpY3MgPSBjb250ZXh0LmdldE1ldHJpY3MoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gY29udGV4dC5nZXRXaWR0aCgpO1xuICAgICAgICB0aGlzLm1pblRvdGFsV2lkdGggKz0gd2lkdGg7XG4gICAgICAgIHZhciBtaW5feCA9IDA7XG4gICAgICAgIHZhciBwaXhlbHNfdXNlZCA9IHdpZHRoO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBzcGFjZSBiZXR3ZWVuIGxhc3Qgbm90ZSBhbmQgbmV4dCBub3RlLlxuICAgICAgICB0aWNrX3NwYWNlID0gTWF0aC5taW4oKHRpY2sgLSBwcmV2X3RpY2spICogdGhpcy5waXhlbHNQZXJUaWNrLCBwaXhlbHNfdXNlZCk7XG5cbiAgICAgICAgLy8gU2hpZnQgbmV4dCBub3RlIHVwIGB0aWNrX3NwYWNlYCBwaXhlbHMuXG4gICAgICAgIHZhciBzZXRfeCA9IHggKyB0aWNrX3NwYWNlO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbWluaW11bSBuZXh0IG5vdGUgcG9zaXRpb24gdG8gYWxsb3cgZm9yIHJpZ2h0IG1vZGlmaWVycy5cbiAgICAgICAgaWYgKGxhc3RNZXRyaWNzICE9IG51bGwpIHtcbiAgICAgICAgICBtaW5feCA9IHggKyBwcmV2X3dpZHRoIC0gbGFzdE1ldHJpY3MuZXh0cmFMZWZ0UHg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHNwYWNlIHJlcXVpcmVkIGZvciB0aGUgcHJldmlvdXMgdGljay5cbiAgICAgICAgLy8gVGhlIGBzaG91bGRJZ25vcmVUaWNrc2AgYm9vbCBpcyB0cnVlIGZvciBlbGVtZW50cyBpbiB0aGUgc3RhdmVcbiAgICAgICAgLy8gdGhhdCBkb24ndCBjb25zdW1lIHRpY2tzIChiYXIgbGluZXMsIGtleSBhbmQgdGltZSBzaWduYXR1cmVzLCBldGMuKVxuICAgICAgICBzZXRfeCA9IGNvbnRleHQuc2hvdWxkSWdub3JlVGlja3MoKSA/XG4gICAgICAgICAgICAobWluX3ggKyBjb250ZXh0LmdldFdpZHRoKCkpIDogTWF0aC5tYXgoc2V0X3gsIG1pbl94KTtcblxuICAgICAgICBpZiAoY29udGV4dC5zaG91bGRJZ25vcmVUaWNrcygpICYmIGp1c3RpZnlXaWR0aCkge1xuICAgICAgICAgICAgLy8gVGhpcyBub3RlIHN0b2xlIHJvb20uLi4gcmVjYWxjdWxhdGUgd2l0aCBuZXcganVzdGlmaWNhdGlvbiB3aWR0aC5cbiAgICAgICAgICAgIGp1c3RpZnlXaWR0aCAtPSBjb250ZXh0LmdldFdpZHRoKCk7XG4gICAgICAgICAgICB0aGlzLnBpeGVsc1BlclRpY2sgPSBqdXN0aWZ5V2lkdGggL1xuICAgICAgICAgICAgICAodGhpcy50b3RhbFRpY2tzLnZhbHVlKCkgKiBjb250ZXh0cy5yZXNvbHV0aW9uTXVsdGlwbGllcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgcGl4ZWxzIG5lZWRlZCBmb3IgbGVmdCBtb2RpZmllcnMuXG4gICAgICAgIHZhciBsZWZ0X3B4ID0gdGhpc01ldHJpY3MuZXh0cmFMZWZ0UHg7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaXRlIHNwYWNlIHRvIHJpZ2h0IG9mIHByZXZpb3VzIHRpY2sgKGZyb20gcmlnaHQgbW9kaWZpZXJzLilcbiAgICAgICAgaWYgKGxhc3RNZXRyaWNzICE9IG51bGwpIHtcbiAgICAgICAgICB3aGl0ZV9zcGFjZSA9IChzZXRfeCAtIHgpIC0gKHByZXZfd2lkdGggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1ldHJpY3MuZXh0cmFMZWZ0UHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVkdWN0IHBpeGVscyBmcm9tIHdoaXRlIHNwYWNlIHF1b3RhLlxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBpZiAod2hpdGVfc3BhY2UgPiAwKSB7XG4gICAgICAgICAgICBpZiAod2hpdGVfc3BhY2UgPj0gbGVmdF9weCkge1xuICAgICAgICAgICAgICAvLyBIYXZlIGVub3VnaCB3aGl0ZSBzcGFjZSBmb3IgbGVmdCBtb2RpZmllcnMgLSBubyBvZmZzZXQgbmVlZGVkLlxuICAgICAgICAgICAgICBsZWZ0X3B4ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIERlY3JlYXNlIGxlZnQgbW9kaWZpZXIgb2Zmc2V0IGJ5IGFtb3VudCBvZiB3aGl0ZSBzcGFjZS5cbiAgICAgICAgICAgICAgbGVmdF9weCAtPSB3aGl0ZV9zcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGp1c3QgdGhlIHRpY2sgeCBwb3NpdGlvbiB3aXRoIHRoZSBsZWZ0IG1vZGlmaWVyIG9mZnNldC5cbiAgICAgICAgc2V0X3ggKz0gbGVmdF9weDtcblxuICAgICAgICAvLyBTZXQgdGhlIGB4YCB2YWx1ZSBmb3IgdGhlIGNvbnRleHQsIHdoaWNoIHNldHMgdGhlIGB4YCB2YWx1ZSBmb3IgYWxsXG4gICAgICAgIC8vIHRpY2thYmxlcyBpbiB0aGlzIGNvbnRleHQuXG4gICAgICAgIGNvbnRleHQuc2V0WChzZXRfeCk7XG4gICAgICAgIGNvbnRleHQuc2V0UGl4ZWxzVXNlZChwaXhlbHNfdXNlZCk7ICAvLyA/Pz8gUmVtb3ZlIHRoaXMgaWYgbm90aGluZyBicmVha3NcblxuICAgICAgICBsYXN0TWV0cmljcyA9IHRoaXNNZXRyaWNzO1xuICAgICAgICBwcmV2X3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHByZXZfdGljayA9IHRpY2s7XG4gICAgICAgIHggPSBzZXRfeDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5oYXNNaW5Ub3RhbFdpZHRoID0gdHJ1ZTtcbiAgICAgIGlmIChqdXN0aWZ5V2lkdGggPiAwKSB7XG4gICAgICAgIC8vIFBhc3MgMjogVGFrZSBsZWZ0b3ZlciB3aWR0aCwgYW5kIGRpc3RyaWJ1dGUgaXQgdG8gcHJvcG9ydGlvbmF0ZWx5IHRvXG4gICAgICAgIC8vIGFsbCBub3Rlcy5cbiAgICAgICAgdmFyIHJlbWFpbmluZ194ID0gaW5pdGlhbF9qdXN0aWZ5X3dpZHRoIC0gKHggKyBwcmV2X3dpZHRoKTtcbiAgICAgICAgdmFyIGxlZnRvdmVyX3BpeGVsc19wZXJfdGljayA9IHJlbWFpbmluZ194IC8gKHRoaXMudG90YWxUaWNrcy52YWx1ZSgpICogY29udGV4dHMucmVzb2x1dGlvbk11bHRpcGxpZXIpO1xuICAgICAgICB2YXIgYWNjdW11bGF0ZWRfc3BhY2UgPSAwO1xuICAgICAgICBwcmV2X3RpY2sgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250ZXh0TGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRpY2sgPSBjb250ZXh0TGlzdFtpXTtcbiAgICAgICAgICBjb250ZXh0ID0gY29udGV4dE1hcFt0aWNrXTtcbiAgICAgICAgICB0aWNrX3NwYWNlID0gKHRpY2sgLSBwcmV2X3RpY2spICogbGVmdG92ZXJfcGl4ZWxzX3Blcl90aWNrO1xuICAgICAgICAgIGFjY3VtdWxhdGVkX3NwYWNlID0gYWNjdW11bGF0ZWRfc3BhY2UgKyB0aWNrX3NwYWNlO1xuICAgICAgICAgIGNvbnRleHQuc2V0WChjb250ZXh0LmdldFgoKSArIGFjY3VtdWxhdGVkX3NwYWNlKTtcbiAgICAgICAgICBwcmV2X3RpY2sgPSB0aWNrO1xuXG4gICAgICAgICAgLy8gTW92ZSBjZW50ZXIgYWxpZ25lZCB0aWNrYWJsZXMgdG8gbWlkZGxlXG4gICAgICAgICAgdmFyIGNlbnRlcmVkVGlja2FibGVzID0gY29udGV4dC5nZXRDZW50ZXJBbGlnbmVkVGlja2FibGVzKCk7XG5cbiAgICAgICAgICAvKmpzaGludCAtVzA4MyAqL1xuICAgICAgICAgIGNlbnRlcmVkVGlja2FibGVzLmZvckVhY2goZnVuY3Rpb24odGlja2FibGUpIHtcbiAgICAgICAgICAgIHRpY2thYmxlLmNlbnRlcl94X3NoaWZ0ID0gY2VudGVyX3ggLSBjb250ZXh0LmdldFgoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBUaGlzIGlzIHRoZSB0b3AtbGV2ZWwgY2FsbCBmb3IgYWxsIGZvcm1hdHRpbmcgbG9naWMgY29tcGxldGVkXG4gICAgLy8gYWZ0ZXIgYHhgICphbmQqIGB5YCB2YWx1ZXMgaGF2ZSBiZWVuIGNvbXB1dGVkIGZvciB0aGUgbm90ZXNcbiAgICAvLyBpbiB0aGUgdm9pY2VzLlxuICAgIHBvc3RGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gUG9zdGZvcm1hdCBtb2RpZmllciBjb250ZXh0c1xuICAgICAgdGhpcy5tQ29udGV4dHMubGlzdC5mb3JFYWNoKGZ1bmN0aW9uKG1Db250ZXh0KSB7XG4gICAgICAgIHRoaXMubUNvbnRleHRzLm1hcFttQ29udGV4dF0ucG9zdEZvcm1hdCgpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIC8vIFBvc3Rmb3JtYXQgdGljayBjb250ZXh0c1xuICAgICAgdGhpcy50Q29udGV4dHMubGlzdC5mb3JFYWNoKGZ1bmN0aW9uKHRDb250ZXh0KSB7XG4gICAgICAgIHRoaXMudENvbnRleHRzLm1hcFt0Q29udGV4dF0ucG9zdEZvcm1hdCgpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUYWtlIGFsbCBgdm9pY2VzYCBhbmQgY3JlYXRlIGBNb2RpZmllckNvbnRleHRgcyBvdXQgb2YgdGhlbS4gVGhpcyB0ZWxsc1xuICAgIC8vIHRoZSBmb3JtYXR0ZXJzIHRoYXQgdGhlIHZvaWNlcyBiZWxvbmcgb24gYSBzaW5nbGUgc3RhdmUuXG4gICAgam9pblZvaWNlczogZnVuY3Rpb24odm9pY2VzKSB7XG4gICAgICB0aGlzLmNyZWF0ZU1vZGlmaWVyQ29udGV4dHModm9pY2VzKTtcbiAgICAgIHRoaXMuaGFzTWluVG90YWxXaWR0aCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEFsaWduIHJlc3RzIGluIHZvaWNlcywganVzdGlmeSB0aGUgY29udGV4dHMsIGFuZCBwb3NpdGlvbiB0aGUgbm90ZXNcbiAgICAvLyBzbyB2b2ljZXMgYXJlIGFsaWduZWQgYW5kIHJlYWR5IHRvIHJlbmRlciBvbnRvIHRoZSBzdGF2ZS4gVGhpcyBtZXRob2RcbiAgICAvLyBtdXRhdGVzIHRoZSBgeGAgcG9zaXRpb25zIG9mIGFsbCB0aWNrYWJsZXMgaW4gYHZvaWNlc2AuXG4gICAgLy9cbiAgICAvLyBWb2ljZXMgYXJlIGZ1bGwganVzdGlmaWVkIHRvIGZpdCBpbiBganVzdGlmeVdpZHRoYCBwaXhlbHMuXG4gICAgLy9cbiAgICAvLyBTZXQgYG9wdGlvbnMuY29udGV4dGAgdG8gdGhlIHJlbmRlcmluZyBjb250ZXh0LiBTZXQgYG9wdGlvbnMuYWxpZ25fcmVzdHNgXG4gICAgLy8gdG8gdHJ1ZSB0byBlbmFibGUgcmVzdCBhbGlnbm1lbnQuXG4gICAgZm9ybWF0OiBmdW5jdGlvbih2b2ljZXMsIGp1c3RpZnlXaWR0aCwgb3B0aW9ucykge1xuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIGFsaWduX3Jlc3RzOiBmYWxzZSxcbiAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgc3RhdmU6IG51bGxcbiAgICAgIH07XG5cbiAgICAgIFZleC5NZXJnZShvcHRzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYWxpZ25SZXN0cyh2b2ljZXMsIG9wdHMuYWxpZ25fcmVzdHMpO1xuICAgICAgdGhpcy5jcmVhdGVUaWNrQ29udGV4dHModm9pY2VzKTtcbiAgICAgIHRoaXMucHJlRm9ybWF0KGp1c3RpZnlXaWR0aCwgb3B0cy5jb250ZXh0LCB2b2ljZXMsIG9wdHMuc3RhdmUpO1xuXG4gICAgICAvLyBPbmx5IHBvc3RGb3JtYXQgaWYgYSBzdGF2ZSB3YXMgc3VwcGxpZWQgZm9yIHkgdmFsdWUgZm9ybWF0dGluZ1xuICAgICAgaWYgKG9wdHMuc3RhdmUpIHRoaXMucG9zdEZvcm1hdCgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gVGhpcyBtZXRob2QgaXMganVzdCBsaWtlIGBmb3JtYXRgIGV4Y2VwdCB0aGF0IHRoZSBganVzdGlmeVdpZHRoYCBpcyBpbmZlcnJlZFxuICAgIC8vIGZyb20gdGhlIGBzdGF2ZWAuXG4gICAgZm9ybWF0VG9TdGF2ZTogZnVuY3Rpb24odm9pY2VzLCBzdGF2ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGp1c3RpZnlXaWR0aCA9IHN0YXZlLmdldE5vdGVFbmRYKCkgLSBzdGF2ZS5nZXROb3RlU3RhcnRYKCkgLSAxMDtcbiAgICAgIEwoXCJGb3JtYXR0aW5nIHZvaWNlcyB0byB3aWR0aDogXCIsIGp1c3RpZnlXaWR0aCk7XG4gICAgICB2YXIgb3B0cyA9IHtjb250ZXh0OiBzdGF2ZS5nZXRDb250ZXh0KCl9O1xuICAgICAgVmV4Lk1lcmdlKG9wdHMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHZvaWNlcywganVzdGlmeVdpZHRoLCBvcHRzKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEZvcm1hdHRlcjtcbn0oKSk7XG5cbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB2YXJpZXMgdHlwZXMgb2YgdGllcyBiZXR3ZWVuIGNvbnRpZ3VvdXMgbm90ZXMuIFRoZVxuLy8gdGllcyBpbmNsdWRlOiByZWd1bGFyIHRpZXMsIGhhbW1lciBvbnMsIHB1bGwgb2ZmcywgYW5kIHNsaWRlcy5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdGllIGZyb20gdGhlIHNwZWNpZmllZCBub3Rlcy4gVGhlIG5vdGVzIG11c3RcbiAqIGJlIHBhcnQgb2YgdGhlIHNhbWUgbGluZSwgYW5kIGhhdmUgdGhlIHNhbWUgZHVyYXRpb24gKGluIHRpY2tzKS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7IU9iamVjdH0gY29udGV4dCBUaGUgY2FudmFzIGNvbnRleHQuXG4gKiBAcGFyYW0geyFPYmplY3R9IG5vdGVzIFRoZSBub3RlcyB0byB0aWUgdXAuXG4gKiBAcGFyYW0geyFPYmplY3R9IE9wdGlvbnNcbiAqL1xuVmV4LkZsb3cuU3RhdmVUaWUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFN0YXZlVGllKG5vdGVzLCB0ZXh0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQobm90ZXMsIHRleHQpO1xuICB9XG5cbiAgU3RhdmVUaWUucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG5vdGVzLCB0ZXh0KSB7XG4gICAgICAvKipcbiAgICAgICAqIE5vdGVzIGlzIGEgc3RydWN0IHRoYXQgaGFzOlxuICAgICAgICpcbiAgICAgICAqICB7XG4gICAgICAgKiAgICBmaXJzdF9ub3RlOiBOb3RlLFxuICAgICAgICogICAgbGFzdF9ub3RlOiBOb3RlLFxuICAgICAgICogICAgZmlyc3RfaW5kaWNlczogW24xLCBuMiwgbjNdLFxuICAgICAgICogICAgbGFzdF9pbmRpY2VzOiBbbjEsIG4yLCBuM11cbiAgICAgICAqICB9XG4gICAgICAgKlxuICAgICAgICoqL1xuICAgICAgdGhpcy5ub3RlcyA9IG5vdGVzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG5cbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMgPSB7XG4gICAgICAgICAgY3AxOiA4LCAgICAgIC8vIEN1cnZlIGNvbnRyb2wgcG9pbnQgMVxuICAgICAgICAgIGNwMjogMTIsICAgICAgLy8gQ3VydmUgY29udHJvbCBwb2ludCAyXG4gICAgICAgICAgdGV4dF9zaGlmdF94OiAwLFxuICAgICAgICAgIGZpcnN0X3hfc2hpZnQ6IDAsXG4gICAgICAgICAgbGFzdF94X3NoaWZ0OiAwLFxuICAgICAgICAgIHlfc2hpZnQ6IDcsXG4gICAgICAgICAgdGllX3NwYWNpbmc6IDAsXG4gICAgICAgICAgZm9udDogeyBmYW1pbHk6IFwiQXJpYWxcIiwgc2l6ZTogMTAsIHN0eWxlOiBcIlwiIH1cbiAgICAgICAgfTtcblxuICAgICAgdGhpcy5mb250ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5mb250O1xuICAgICAgdGhpcy5zZXROb3Rlcyhub3Rlcyk7XG4gICAgfSxcblxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHsgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgc2V0Rm9udDogZnVuY3Rpb24oZm9udCkgeyB0aGlzLmZvbnQgPSBmb250OyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbm90ZXMgdG8gYXR0YWNoIHRoaXMgdGllIHRvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBub3RlcyBUaGUgbm90ZXMgdG8gdGllIHVwLlxuICAgICAqL1xuICAgIHNldE5vdGVzOiBmdW5jdGlvbihub3Rlcykge1xuICAgICAgaWYgKCFub3Rlcy5maXJzdF9ub3RlICYmICFub3Rlcy5sYXN0X25vdGUpXG4gICAgICAgIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiQmFkQXJndW1lbnRzXCIsXG4gICAgICAgICAgICBcIlRpZSBuZWVkcyB0byBoYXZlIGVpdGhlciBmaXJzdF9ub3RlIG9yIGxhc3Rfbm90ZSBzZXQuXCIpO1xuXG4gICAgICBpZiAoIW5vdGVzLmZpcnN0X2luZGljZXMpIG5vdGVzLmZpcnN0X2luZGljZXMgPSBbMF07XG4gICAgICBpZiAoIW5vdGVzLmxhc3RfaW5kaWNlcykgbm90ZXMubGFzdF9pbmRpY2VzID0gWzBdO1xuXG4gICAgICBpZiAobm90ZXMuZmlyc3RfaW5kaWNlcy5sZW5ndGggIT0gbm90ZXMubGFzdF9pbmRpY2VzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIiwgXCJUaWVkIG5vdGVzIG11c3QgaGF2ZSBzaW1pbGFyXCIgK1xuICAgICAgICAgIFwiIGluZGV4IHNpemVzXCIpO1xuXG4gICAgICAvLyBTdWNjZXNzLiBMZXRzIGdyYWIgJ2VtIG5vdGVzLlxuICAgICAgdGhpcy5maXJzdF9ub3RlID0gbm90ZXMuZmlyc3Rfbm90ZTtcbiAgICAgIHRoaXMuZmlyc3RfaW5kaWNlcyA9IG5vdGVzLmZpcnN0X2luZGljZXM7XG4gICAgICB0aGlzLmxhc3Rfbm90ZSA9IG5vdGVzLmxhc3Rfbm90ZTtcbiAgICAgIHRoaXMubGFzdF9pbmRpY2VzID0gbm90ZXMubGFzdF9pbmRpY2VzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgcGFydGlhbCBiYXIuXG4gICAgICovXG4gICAgaXNQYXJ0aWFsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoIXRoaXMuZmlyc3Rfbm90ZSB8fCAhdGhpcy5sYXN0X25vdGUpO1xuICAgIH0sXG5cbiAgICByZW5kZXJUaWU6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgaWYgKHBhcmFtcy5maXJzdF95cy5sZW5ndGggPT09IDAgfHwgcGFyYW1zLmxhc3RfeXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJObyBZLXZhbHVlcyB0byByZW5kZXJcIik7XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgY3AxID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5jcDE7XG4gICAgICB2YXIgY3AyID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5jcDI7XG5cbiAgICAgIGlmIChNYXRoLmFicyhwYXJhbXMubGFzdF94X3B4IC0gcGFyYW1zLmZpcnN0X3hfcHgpIDwgMTApIHtcbiAgICAgICAgY3AxID0gMjsgY3AyID0gODtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0X3hfc2hpZnQgPSB0aGlzLnJlbmRlcl9vcHRpb25zLmZpcnN0X3hfc2hpZnQ7XG4gICAgICB2YXIgbGFzdF94X3NoaWZ0ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5sYXN0X3hfc2hpZnQ7XG4gICAgICB2YXIgeV9zaGlmdCA9IHRoaXMucmVuZGVyX29wdGlvbnMueV9zaGlmdCAqIHBhcmFtcy5kaXJlY3Rpb247XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maXJzdF9pbmRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjcF94ID0gKChwYXJhbXMubGFzdF94X3B4ICsgbGFzdF94X3NoaWZ0KSArXG4gICAgICAgICAgICAgICAgICAgIChwYXJhbXMuZmlyc3RfeF9weCArIGZpcnN0X3hfc2hpZnQpKSAvIDI7XG4gICAgICAgIHZhciBmaXJzdF95X3B4ID0gcGFyYW1zLmZpcnN0X3lzW3RoaXMuZmlyc3RfaW5kaWNlc1tpXV0gKyB5X3NoaWZ0O1xuICAgICAgICB2YXIgbGFzdF95X3B4ID0gcGFyYW1zLmxhc3RfeXNbdGhpcy5sYXN0X2luZGljZXNbaV1dICsgeV9zaGlmdDtcblxuICAgICAgICBpZiAoaXNOYU4oZmlyc3RfeV9weCkgfHwgaXNOYU4obGFzdF95X3B4KSlcbiAgICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJCYWQgaW5kaWNlcyBmb3IgdGllIHJlbmRlcmluZy5cIik7XG5cbiAgICAgICAgdmFyIHRvcF9jcF95ID0gKChmaXJzdF95X3B4ICsgbGFzdF95X3B4KSAvIDIpICsgKGNwMSAqIHBhcmFtcy5kaXJlY3Rpb24pO1xuICAgICAgICB2YXIgYm90dG9tX2NwX3kgPSAoKGZpcnN0X3lfcHggKyBsYXN0X3lfcHgpIC8gMikgKyAoY3AyICogcGFyYW1zLmRpcmVjdGlvbik7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHBhcmFtcy5maXJzdF94X3B4ICsgZmlyc3RfeF9zaGlmdCwgZmlyc3RfeV9weCk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNwX3gsIHRvcF9jcF95LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMubGFzdF94X3B4ICsgbGFzdF94X3NoaWZ0LCBsYXN0X3lfcHgpO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjcF94LCBib3R0b21fY3BfeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmZpcnN0X3hfcHggKyBmaXJzdF94X3NoaWZ0LCBmaXJzdF95X3B4KTtcblxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlclRleHQ6IGZ1bmN0aW9uKGZpcnN0X3hfcHgsIGxhc3RfeF9weCkge1xuICAgICAgaWYgKCF0aGlzLnRleHQpIHJldHVybjtcbiAgICAgIHZhciBjZW50ZXJfeCA9IChmaXJzdF94X3B4ICsgbGFzdF94X3B4KSAvIDI7XG4gICAgICBjZW50ZXJfeCAtPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aCAvIDI7XG5cbiAgICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XG4gICAgICB0aGlzLmNvbnRleHQuc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSwgdGhpcy5mb250LnN0eWxlKTtcbiAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dChcbiAgICAgICAgICB0aGlzLnRleHQsIGNlbnRlcl94ICsgdGhpcy5yZW5kZXJfb3B0aW9ucy50ZXh0X3NoaWZ0X3gsXG4gICAgICAgICAgKHRoaXMuZmlyc3Rfbm90ZSB8fCB0aGlzLmxhc3Rfbm90ZSkuZ2V0U3RhdmUoKS5nZXRZRm9yVG9wVGV4dCgpIC0gMSk7XG4gICAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIiwgXCJObyBjb250ZXh0IHRvIHJlbmRlciB0aWUuXCIpO1xuICAgICAgdmFyIGZpcnN0X25vdGUgPSB0aGlzLmZpcnN0X25vdGU7XG4gICAgICB2YXIgbGFzdF9ub3RlID0gdGhpcy5sYXN0X25vdGU7XG4gICAgICB2YXIgZmlyc3RfeF9weCwgbGFzdF94X3B4LCBmaXJzdF95cywgbGFzdF95cywgc3RlbV9kaXJlY3Rpb247XG5cbiAgICAgIGlmIChmaXJzdF9ub3RlKSB7XG4gICAgICAgIGZpcnN0X3hfcHggPSBmaXJzdF9ub3RlLmdldFRpZVJpZ2h0WCgpICsgdGhpcy5yZW5kZXJfb3B0aW9ucy50aWVfc3BhY2luZztcbiAgICAgICAgc3RlbV9kaXJlY3Rpb24gPSBmaXJzdF9ub3RlLmdldFN0ZW1EaXJlY3Rpb24oKTtcbiAgICAgICAgZmlyc3RfeXMgPSBmaXJzdF9ub3RlLmdldFlzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdF94X3B4ID0gbGFzdF9ub3RlLmdldFN0YXZlKCkuZ2V0VGllU3RhcnRYKCk7XG4gICAgICAgIGZpcnN0X3lzID0gbGFzdF9ub3RlLmdldFlzKCk7XG4gICAgICAgIHRoaXMuZmlyc3RfaW5kaWNlcyA9IHRoaXMubGFzdF9pbmRpY2VzO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdF9ub3RlKSB7XG4gICAgICAgIGxhc3RfeF9weCA9IGxhc3Rfbm90ZS5nZXRUaWVMZWZ0WCgpICsgdGhpcy5yZW5kZXJfb3B0aW9ucy50aWVfc3BhY2luZztcbiAgICAgICAgc3RlbV9kaXJlY3Rpb24gPSBsYXN0X25vdGUuZ2V0U3RlbURpcmVjdGlvbigpO1xuICAgICAgICBsYXN0X3lzID0gbGFzdF9ub3RlLmdldFlzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0X3hfcHggPSBmaXJzdF9ub3RlLmdldFN0YXZlKCkuZ2V0VGllRW5kWCgpO1xuICAgICAgICBsYXN0X3lzID0gZmlyc3Rfbm90ZS5nZXRZcygpO1xuICAgICAgICB0aGlzLmxhc3RfaW5kaWNlcyA9IHRoaXMuZmlyc3RfaW5kaWNlcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJUaWUoe1xuICAgICAgICBmaXJzdF94X3B4OiBmaXJzdF94X3B4LFxuICAgICAgICBsYXN0X3hfcHg6IGxhc3RfeF9weCxcbiAgICAgICAgZmlyc3RfeXM6IGZpcnN0X3lzLFxuICAgICAgICBsYXN0X3lzOiBsYXN0X3lzLFxuICAgICAgICBkaXJlY3Rpb246IHN0ZW1fZGlyZWN0aW9uXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5yZW5kZXJUZXh0KGZpcnN0X3hfcHgsIGxhc3RfeF9weCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFN0YXZlVGllO1xufSgpKTtcblxuLy8gVmV4RmxvdyAtIE11c2ljIEVuZ3JhdmluZyBmb3IgSFRNTDVcbi8vIENvcHlyaWdodCBNb2hpdCBNdXRoYW5uYSAyMDEwXG4vL1xuLy8gVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHZhcmllcyB0eXBlcyBvZiB0aWVzIGJldHdlZW4gY29udGlndW91cyBub3Rlcy4gVGhlXG4vLyB0aWVzIGluY2x1ZGU6IHJlZ3VsYXIgdGllcywgaGFtbWVyIG9ucywgcHVsbCBvZmZzLCBhbmQgc2xpZGVzLlxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0aWUgZnJvbSB0aGUgc3BlY2lmaWVkIG5vdGVzLiBUaGUgbm90ZXMgbXVzdFxuICogYmUgcGFydCBvZiB0aGUgc2FtZSBsaW5lLCBhbmQgaGF2ZSB0aGUgc2FtZSBkdXJhdGlvbiAoaW4gdGlja3MpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHshT2JqZWN0fSBjb250ZXh0IFRoZSBjYW52YXMgY29udGV4dC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gbm90ZXMgVGhlIG5vdGVzIHRvIHRpZSB1cC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gT3B0aW9uc1xuICovXG5WZXguRmxvdy5UYWJUaWUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRhYlRpZShub3RlcywgdGV4dCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG5vdGVzLCB0ZXh0KTtcbiAgfVxuXG4gIFRhYlRpZS5jcmVhdGVIYW1tZXJvbiA9IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJUaWUobm90ZXMsIFwiSFwiKTtcbiAgfTtcblxuICBUYWJUaWUuY3JlYXRlUHVsbG9mZiA9IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJUaWUobm90ZXMsIFwiUFwiKTtcbiAgfTtcblxuICBWZXguSW5oZXJpdChUYWJUaWUsIFZleC5GbG93LlN0YXZlVGllLCB7XG4gICAgaW5pdDogZnVuY3Rpb24obm90ZXMsIHRleHQpIHtcbiAgICAgIC8qKlxuICAgICAgICogTm90ZXMgaXMgYSBzdHJ1Y3QgdGhhdCBoYXM6XG4gICAgICAgKlxuICAgICAgICogIHtcbiAgICAgICAqICAgIGZpcnN0X25vdGU6IE5vdGUsXG4gICAgICAgKiAgICBsYXN0X25vdGU6IE5vdGUsXG4gICAgICAgKiAgICBmaXJzdF9pbmRpY2VzOiBbbjEsIG4yLCBuM10sXG4gICAgICAgKiAgICBsYXN0X2luZGljZXM6IFtuMSwgbjIsIG4zXVxuICAgICAgICogIH1cbiAgICAgICAqXG4gICAgICAgKiovXG4gICAgICBUYWJUaWUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbm90ZXMsIHRleHQpO1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5jcDEgPSA5O1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5jcDIgPSAxMTtcbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMueV9zaGlmdCA9IDM7XG5cbiAgICAgIHRoaXMuc2V0Tm90ZXMobm90ZXMpO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIiwgXCJObyBjb250ZXh0IHRvIHJlbmRlciB0aWUuXCIpO1xuICAgICAgdmFyIGZpcnN0X25vdGUgPSB0aGlzLmZpcnN0X25vdGU7XG4gICAgICB2YXIgbGFzdF9ub3RlID0gdGhpcy5sYXN0X25vdGU7XG4gICAgICB2YXIgZmlyc3RfeF9weCwgbGFzdF94X3B4LCBmaXJzdF95cywgbGFzdF95cztcblxuICAgICAgaWYgKGZpcnN0X25vdGUpIHtcbiAgICAgICAgZmlyc3RfeF9weCA9IGZpcnN0X25vdGUuZ2V0VGllUmlnaHRYKCkgKyB0aGlzLnJlbmRlcl9vcHRpb25zLnRpZV9zcGFjaW5nO1xuICAgICAgICBmaXJzdF95cyA9IGZpcnN0X25vdGUuZ2V0WXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0X3hfcHggPSBsYXN0X25vdGUuZ2V0U3RhdmUoKS5nZXRUaWVTdGFydFgoKTtcbiAgICAgICAgZmlyc3RfeXMgPSBsYXN0X25vdGUuZ2V0WXMoKTtcbiAgICAgICAgdGhpcy5maXJzdF9pbmRpY2VzID0gdGhpcy5sYXN0X2luZGljZXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXN0X25vdGUpIHtcbiAgICAgICAgbGFzdF94X3B4ID0gbGFzdF9ub3RlLmdldFRpZUxlZnRYKCkgKyB0aGlzLnJlbmRlcl9vcHRpb25zLnRpZV9zcGFjaW5nO1xuICAgICAgICBsYXN0X3lzID0gbGFzdF9ub3RlLmdldFlzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0X3hfcHggPSBmaXJzdF9ub3RlLmdldFN0YXZlKCkuZ2V0VGllRW5kWCgpO1xuICAgICAgICBsYXN0X3lzID0gZmlyc3Rfbm90ZS5nZXRZcygpO1xuICAgICAgICB0aGlzLmxhc3RfaW5kaWNlcyA9IHRoaXMuZmlyc3RfaW5kaWNlcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJUaWUoe1xuICAgICAgICBmaXJzdF94X3B4OiBmaXJzdF94X3B4LFxuICAgICAgICBsYXN0X3hfcHg6IGxhc3RfeF9weCxcbiAgICAgICAgZmlyc3RfeXM6IGZpcnN0X3lzLFxuICAgICAgICBsYXN0X3lzOiBsYXN0X3lzLFxuICAgICAgICBkaXJlY3Rpb246IC0xICAgICAgICAgICAvLyBUYWIgdGllJ3MgYXJlIGFsd2F5cyBmYWNlIHVwLlxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucmVuZGVyVGV4dChmaXJzdF94X3B4LCBsYXN0X3hfcHgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gVGFiVGllO1xufSgpKTtcblxuLy8gVmV4RmxvdyAtIE11c2ljIEVuZ3JhdmluZyBmb3IgSFRNTDVcbi8vIENvcHlyaWdodCBNb2hpdCBNdXRoYW5uYSAyMDEwXG4vL1xuLy8gVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHZhcmllcyB0eXBlcyBvZiB0aWVzIGJldHdlZW4gY29udGlndW91cyBub3Rlcy4gVGhlXG4vLyB0aWVzIGluY2x1ZGU6IHJlZ3VsYXIgdGllcywgaGFtbWVyIG9ucywgcHVsbCBvZmZzLCBhbmQgc2xpZGVzLlxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0aWUgZnJvbSB0aGUgc3BlY2lmaWVkIG5vdGVzLiBUaGUgbm90ZXMgbXVzdFxuICogYmUgcGFydCBvZiB0aGUgc2FtZSBsaW5lLCBhbmQgaGF2ZSB0aGUgc2FtZSBkdXJhdGlvbiAoaW4gdGlja3MpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHshT2JqZWN0fSBjb250ZXh0IFRoZSBjYW52YXMgY29udGV4dC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gbm90ZXMgVGhlIG5vdGVzIHRvIHRpZSB1cC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gT3B0aW9uc1xuICovXG5WZXguRmxvdy5UYWJTbGlkZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gVGFiU2xpZGUobm90ZXMsIGRpcmVjdGlvbikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG5vdGVzLCBkaXJlY3Rpb24pO1xuICB9XG5cbiAgVGFiU2xpZGUuU0xJREVfVVAgPSAxO1xuICBUYWJTbGlkZS5TTElERV9ET1dOID0gLTE7XG5cbiAgVGFiU2xpZGUuY3JlYXRlU2xpZGVVcCA9IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJTbGlkZShub3RlcywgVGFiU2xpZGUuU0xJREVfVVApO1xuICB9O1xuXG4gIFRhYlNsaWRlLmNyZWF0ZVNsaWRlRG93biA9IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJTbGlkZShub3RlcywgVGFiU2xpZGUuU0xJREVfRE9XTik7XG4gIH07XG5cbiAgVmV4LkluaGVyaXQoVGFiU2xpZGUsIFZleC5GbG93LlRhYlRpZSwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG5vdGVzLCBkaXJlY3Rpb24pIHtcbiAgICAgIC8qKlxuICAgICAgICogTm90ZXMgaXMgYSBzdHJ1Y3QgdGhhdCBoYXM6XG4gICAgICAgKlxuICAgICAgICogIHtcbiAgICAgICAqICAgIGZpcnN0X25vdGU6IE5vdGUsXG4gICAgICAgKiAgICBsYXN0X25vdGU6IE5vdGUsXG4gICAgICAgKiAgICBmaXJzdF9pbmRpY2VzOiBbbjEsIG4yLCBuM10sXG4gICAgICAgKiAgICBsYXN0X2luZGljZXM6IFtuMSwgbjIsIG4zXVxuICAgICAgICogIH1cbiAgICAgICAqXG4gICAgICAgKiovXG4gICAgICBUYWJTbGlkZS5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBub3RlcywgXCJzbC5cIik7XG4gICAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgICB2YXIgZmlyc3RfZnJldCA9IG5vdGVzLmZpcnN0X25vdGUuZ2V0UG9zaXRpb25zKClbMF0uZnJldDtcbiAgICAgICAgdmFyIGxhc3RfZnJldCA9IG5vdGVzLmxhc3Rfbm90ZS5nZXRQb3NpdGlvbnMoKVswXS5mcmV0O1xuXG4gICAgICAgIGRpcmVjdGlvbiA9ICgocGFyc2VJbnQoZmlyc3RfZnJldCwgMTApID4gcGFyc2VJbnQobGFzdF9mcmV0LCAxMCkpID9cbiAgICAgICAgICBUYWJTbGlkZS5TTElERV9ET1dOIDogVGFiU2xpZGUuU0xJREVfVVApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNsaWRlX2RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuY3AxID0gMTE7XG4gICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLmNwMiA9IDE0O1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy55X3NoaWZ0ID0gMC41O1xuXG4gICAgICB0aGlzLnNldEZvbnQoe2ZvbnQ6IFwiVGltZXNcIiwgc2l6ZTogMTAsIHN0eWxlOiBcImJvbGQgaXRhbGljXCJ9KTtcbiAgICAgIHRoaXMuc2V0Tm90ZXMobm90ZXMpO1xuICAgIH0sXG5cbiAgICByZW5kZXJUaWU6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgaWYgKHBhcmFtcy5maXJzdF95cy5sZW5ndGggPT09IDAgfHwgcGFyYW1zLmxhc3RfeXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJObyBZLXZhbHVlcyB0byByZW5kZXJcIik7XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgZmlyc3RfeF9weCA9IHBhcmFtcy5maXJzdF94X3B4O1xuICAgICAgdmFyIGZpcnN0X3lzID0gcGFyYW1zLmZpcnN0X3lzO1xuICAgICAgdmFyIGxhc3RfeF9weCA9IHBhcmFtcy5sYXN0X3hfcHg7XG5cbiAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLnNsaWRlX2RpcmVjdGlvbjtcbiAgICAgIGlmIChkaXJlY3Rpb24gIT0gVGFiU2xpZGUuU0xJREVfVVAgJiZcbiAgICAgICAgICBkaXJlY3Rpb24gIT0gVGFiU2xpZGUuU0xJREVfRE9XTikge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRTbGlkZVwiLCBcIkludmFsaWQgc2xpZGUgZGlyZWN0aW9uXCIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmlyc3RfaW5kaWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc2xpZGVfeSA9IGZpcnN0X3lzW3RoaXMuZmlyc3RfaW5kaWNlc1tpXV0gK1xuICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMueV9zaGlmdDtcblxuICAgICAgICBpZiAoaXNOYU4oc2xpZGVfeSkpXG4gICAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsIFwiQmFkIGluZGljZXMgZm9yIHNsaWRlIHJlbmRlcmluZy5cIik7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGZpcnN0X3hfcHgsIHNsaWRlX3kgKyAoMyAqIGRpcmVjdGlvbikpO1xuICAgICAgICBjdHgubGluZVRvKGxhc3RfeF9weCwgc2xpZGVfeSAtICgzICogZGlyZWN0aW9uKSk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFRhYlNsaWRlO1xufSgpKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgdGFibGF0dXJlIGJlbmRzLlxuXG4vKipcbiAgIEBwYXJhbSB0ZXh0IFRleHQgZm9yIGJlbmQgKFwiRnVsbFwiLCBcIkhhbGZcIiwgZXRjLikgKERFUFJFQ0FURUQpXG4gICBAcGFyYW0gcmVsZWFzZSBJZiB0cnVlLCByZW5kZXIgYSByZWxlYXNlLiAoREVQUkVDQVRFRClcbiAgIEBwYXJhbSBwaHJhc2UgSWYgc2V0LCBpZ25vcmUgXCJ0ZXh0XCIgYW5kIFwicmVsZWFzZVwiLCBhbmQgdXNlIHRoZSBtb3JlXG4gICAgICAgICAgICAgICAgIHNvcGhpc3RpY2F0ZWQgcGhyYXNlIHNwZWNpZmllZC5cblxuICAgRXhhbXBsZSBvZiBhIHBocmFzZTpcblxuICAgICBbe1xuICAgICAgIHR5cGU6IFVQLFxuICAgICAgIHRleHQ6IFwid2hvbGVcIlxuICAgICAgIHdpZHRoOiA4O1xuICAgICB9LFxuICAgICB7XG4gICAgICAgdHlwZTogRE9XTixcbiAgICAgICB0ZXh0OiBcIndob2xlXCJcbiAgICAgICB3aWR0aDogODtcbiAgICAgfSxcbiAgICAge1xuICAgICAgIHR5cGU6IFVQLFxuICAgICAgIHRleHQ6IFwiaGFsZlwiXG4gICAgICAgd2lkdGg6IDg7XG4gICAgIH0sXG4gICAgIHtcbiAgICAgICB0eXBlOiBVUCxcbiAgICAgICB0ZXh0OiBcIndob2xlXCJcbiAgICAgICB3aWR0aDogODtcbiAgICAgfSxcbiAgICAge1xuICAgICAgIHR5cGU6IERPV04sXG4gICAgICAgdGV4dDogXCIxIDEvMlwiXG4gICAgICAgd2lkdGg6IDg7XG4gICAgIH1dXG4gKi9cblZleC5GbG93LkJlbmQgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEJlbmQodGV4dCwgcmVsZWFzZSwgcGhyYXNlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGV4dCwgcmVsZWFzZSwgcGhyYXNlKTtcbiAgfVxuICBCZW5kLkNBVEVHT1JZID0gXCJiZW5kc1wiO1xuXG4gIEJlbmQuVVAgPSAwO1xuICBCZW5kLkRPV04gPSAxO1xuXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xuXG4gIC8vICMjIFN0YXRpYyBNZXRob2RzXG4gIC8vIEFycmFuZ2UgYmVuZHMgaW4gYE1vZGlmaWVyQ29udGV4dGBcbiAgQmVuZC5mb3JtYXQgPSBmdW5jdGlvbihiZW5kcywgc3RhdGUpIHtcbiAgICBpZiAoIWJlbmRzIHx8IGJlbmRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxhc3Rfd2lkdGggPSAwO1xuICAgIC8vIEJlbmRzIGFyZSBhbHdheXMgb24gdG9wLlxuICAgIHZhciB0ZXh0X2xpbmUgPSBzdGF0ZS50b3BfdGV4dF9saW5lO1xuXG4gICAgLy8gRm9ybWF0IEJlbmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiZW5kcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGJlbmQgPSBiZW5kc1tpXTtcbiAgICAgIGJlbmQuc2V0WFNoaWZ0KGxhc3Rfd2lkdGgpO1xuICAgICAgbGFzdF93aWR0aCA9IGJlbmQuZ2V0V2lkdGgoKTtcbiAgICAgIGJlbmQuc2V0VGV4dExpbmUodGV4dF9saW5lKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5yaWdodF9zaGlmdCArPSBsYXN0X3dpZHRoO1xuICAgIHN0YXRlLnRvcF90ZXh0X2xpbmUgKz0gMTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICBWZXguSW5oZXJpdChCZW5kLCBNb2RpZmllciwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKHRleHQsIHJlbGVhc2UsIHBocmFzZSkge1xuICAgICAgdmFyIHN1cGVyY2xhc3MgPSBWZXguRmxvdy5CZW5kLnN1cGVyY2xhc3M7XG4gICAgICBzdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgIHRoaXMueF9zaGlmdCA9IDA7XG4gICAgICB0aGlzLnJlbGVhc2UgPSByZWxlYXNlIHx8IGZhbHNlO1xuICAgICAgdGhpcy5mb250ID0gXCIxMHB0IEFyaWFsXCI7XG4gICAgICB0aGlzLnJlbmRlcl9vcHRpb25zID0ge1xuICAgICAgICBsaW5lX3dpZHRoOiAxLjUsXG4gICAgICAgIGxpbmVfc3R5bGU6IFwiIzc3Nzc3N1wiLFxuICAgICAgICBiZW5kX3dpZHRoOiA4LFxuICAgICAgICByZWxlYXNlX3dpZHRoOiA4XG4gICAgICB9O1xuXG4gICAgICBpZiAocGhyYXNlKSB7XG4gICAgICAgIHRoaXMucGhyYXNlID0gcGhyYXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICB0aGlzLnBocmFzZSA9IFt7dHlwZTogQmVuZC5VUCwgdGV4dDogdGhpcy50ZXh0fV07XG4gICAgICAgIGlmICh0aGlzLnJlbGVhc2UpIHRoaXMucGhyYXNlLnB1c2goe3R5cGU6IEJlbmQuRE9XTiwgdGV4dDogXCJcIn0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVdpZHRoKCk7XG4gICAgfSxcblxuICAgIHNldFhTaGlmdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMueF9zaGlmdCA9IHZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVXaWR0aCgpO1xuICAgIH0sXG5cbiAgICBzZXRGb250OiBmdW5jdGlvbihmb250KSB7IHRoaXMuZm9udCA9IGZvbnQ7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgZ2V0VGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRleHQ7IH0sXG5cbiAgICB1cGRhdGVXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIG1lYXN1cmVfdGV4dCh0ZXh0KSB7XG4gICAgICAgIHZhciB0ZXh0X3dpZHRoO1xuICAgICAgICBpZiAodGhhdC5jb250ZXh0KSB7XG4gICAgICAgICAgdGV4dF93aWR0aCA9IHRoYXQuY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0X3dpZHRoID0gVmV4LkZsb3cudGV4dFdpZHRoKHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHRfd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3RhbF93aWR0aCA9IDA7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5waHJhc2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGJlbmQgPSB0aGlzLnBocmFzZVtpXTtcbiAgICAgICAgaWYgKCd3aWR0aCcgaW4gYmVuZCkge1xuICAgICAgICAgIHRvdGFsX3dpZHRoICs9IGJlbmQud2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFkZGl0aW9uYWxfd2lkdGggPSAoYmVuZC50eXBlID09IEJlbmQuVVApID9cbiAgICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuYmVuZF93aWR0aCA6IHRoaXMucmVuZGVyX29wdGlvbnMucmVsZWFzZV93aWR0aDtcblxuICAgICAgICAgIGJlbmQud2lkdGggPSBWZXguTWF4KGFkZGl0aW9uYWxfd2lkdGgsIG1lYXN1cmVfdGV4dChiZW5kLnRleHQpKSArIDM7XG4gICAgICAgICAgYmVuZC5kcmF3X3dpZHRoID0gYmVuZC53aWR0aCAvIDI7XG4gICAgICAgICAgdG90YWxfd2lkdGggKz0gYmVuZC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFdpZHRoKHRvdGFsX3dpZHRoICsgdGhpcy54X3NoaWZ0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgYmVuZCB3aXRob3V0IGEgY29udGV4dC5cIik7XG4gICAgICBpZiAoISh0aGlzLm5vdGUgJiYgKHRoaXMuaW5kZXggIT0gbnVsbCkpKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb05vdGVGb3JCZW5kXCIsXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBiZW5kIHdpdGhvdXQgYSBub3RlIG9yIGluZGV4LlwiKTtcblxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5ub3RlLmdldE1vZGlmaWVyU3RhcnRYWShNb2RpZmllci5Qb3NpdGlvbi5SSUdIVCxcbiAgICAgICAgICB0aGlzLmluZGV4KTtcbiAgICAgIHN0YXJ0LnggKz0gMztcbiAgICAgIHN0YXJ0LnkgKz0gMC41O1xuICAgICAgdmFyIHhfc2hpZnQgPSB0aGlzLnhfc2hpZnQ7XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgYmVuZF9oZWlnaHQgPSB0aGlzLm5vdGUuZ2V0U3RhdmUoKS5nZXRZRm9yVG9wVGV4dCh0aGlzLnRleHRfbGluZSkgKyAzO1xuICAgICAgdmFyIGFubm90YXRpb25feSA9IHRoaXMubm90ZS5nZXRTdGF2ZSgpLmdldFlGb3JUb3BUZXh0KHRoaXMudGV4dF9saW5lKSAtIDE7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbmRlckJlbmQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgY3BfeCA9IHggKyB3aWR0aDtcbiAgICAgICAgdmFyIGNwX3kgPSB5O1xuXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnNldExpbmVXaWR0aCh0aGF0LnJlbmRlcl9vcHRpb25zLmxpbmVfd2lkdGgpO1xuICAgICAgICBjdHguc2V0U3Ryb2tlU3R5bGUodGhhdC5yZW5kZXJfb3B0aW9ucy5saW5lX3N0eWxlKTtcbiAgICAgICAgY3R4LnNldEZpbGxTdHlsZSh0aGF0LnJlbmRlcl9vcHRpb25zLmxpbmVfc3R5bGUpO1xuICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjcF94LCBjcF95LCB4ICsgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVuZGVyUmVsZWFzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnNldExpbmVXaWR0aCh0aGF0LnJlbmRlcl9vcHRpb25zLmxpbmVfd2lkdGgpO1xuICAgICAgICBjdHguc2V0U3Ryb2tlU3R5bGUodGhhdC5yZW5kZXJfb3B0aW9ucy5saW5lX3N0eWxlKTtcbiAgICAgICAgY3R4LnNldEZpbGxTdHlsZSh0aGF0LnJlbmRlcl9vcHRpb25zLmxpbmVfc3R5bGUpO1xuICAgICAgICBjdHgubW92ZVRvKHgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgeCArIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICB4ICsgd2lkdGgsIHkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbmRlckFycm93SGVhZCh4LCB5LCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIHdpZHRoID0gNDtcbiAgICAgICAgdmFyIGRpciA9IGRpcmVjdGlvbiB8fCAxO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4IC0gd2lkdGgsIHkgKyB3aWR0aCAqIGRpcik7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgd2lkdGggKiBkaXIpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbmRlclRleHQoeCwgdGV4dCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc2V0UmF3Rm9udCh0aGF0LmZvbnQpO1xuICAgICAgICB2YXIgcmVuZGVyX3ggPSB4IC0gKGN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCAvIDIpO1xuICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgcmVuZGVyX3gsIGFubm90YXRpb25feSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0X2JlbmQgPSBudWxsO1xuICAgICAgdmFyIGxhc3RfZHJhd25fd2lkdGggPSAwO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMucGhyYXNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBiZW5kID0gdGhpcy5waHJhc2VbaV07XG4gICAgICAgIGlmIChpID09PSAwKSBiZW5kLmRyYXdfd2lkdGggKz0geF9zaGlmdDtcblxuICAgICAgICBsYXN0X2RyYXduX3dpZHRoID0gYmVuZC5kcmF3X3dpZHRoICsgKGxhc3RfYmVuZD9sYXN0X2JlbmQuZHJhd193aWR0aDowKSAtIChpPT0xP3hfc2hpZnQ6MCk7XG4gICAgICAgIGlmIChiZW5kLnR5cGUgPT0gQmVuZC5VUCkge1xuICAgICAgICAgIGlmIChsYXN0X2JlbmQgJiYgbGFzdF9iZW5kLnR5cGUgPT0gQmVuZC5VUCkge1xuICAgICAgICAgICAgcmVuZGVyQXJyb3dIZWFkKHN0YXJ0LngsIGJlbmRfaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW5kZXJCZW5kKHN0YXJ0LngsIHN0YXJ0LnksIGxhc3RfZHJhd25fd2lkdGgsIGJlbmRfaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiZW5kLnR5cGUgPT0gQmVuZC5ET1dOKSB7XG4gICAgICAgICAgaWYgKGxhc3RfYmVuZCAmJiBsYXN0X2JlbmQudHlwZSA9PSBCZW5kLlVQKSB7XG4gICAgICAgICAgICByZW5kZXJSZWxlYXNlKHN0YXJ0LngsIHN0YXJ0LnksIGxhc3RfZHJhd25fd2lkdGgsIGJlbmRfaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGFzdF9iZW5kICYmIGxhc3RfYmVuZC50eXBlID09IEJlbmQuRE9XTikge1xuICAgICAgICAgICAgcmVuZGVyQXJyb3dIZWFkKHN0YXJ0LngsIHN0YXJ0LnksIC0xKTtcbiAgICAgICAgICAgIHJlbmRlclJlbGVhc2Uoc3RhcnQueCwgc3RhcnQueSwgbGFzdF9kcmF3bl93aWR0aCwgYmVuZF9oZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsYXN0X2JlbmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgbGFzdF9kcmF3bl93aWR0aCA9IGJlbmQuZHJhd193aWR0aDtcbiAgICAgICAgICAgIHJlbmRlclJlbGVhc2Uoc3RhcnQueCwgc3RhcnQueSwgbGFzdF9kcmF3bl93aWR0aCwgYmVuZF9oZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlclRleHQoc3RhcnQueCArIGxhc3RfZHJhd25fd2lkdGgsIGJlbmQudGV4dCk7XG4gICAgICAgIGxhc3RfYmVuZCA9IGJlbmQ7XG4gICAgICAgIGxhc3RfYmVuZC54ID0gc3RhcnQueDtcblxuICAgICAgICBzdGFydC54ICs9IGxhc3RfZHJhd25fd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmFsIGFycm93aGVhZCBhbmQgdGV4dFxuICAgICAgaWYgKGxhc3RfYmVuZC50eXBlID09IEJlbmQuVVApIHtcbiAgICAgICAgcmVuZGVyQXJyb3dIZWFkKGxhc3RfYmVuZC54ICsgbGFzdF9kcmF3bl93aWR0aCwgYmVuZF9oZWlnaHQpO1xuICAgICAgfSBlbHNlIGlmIChsYXN0X2JlbmQudHlwZSA9PSBCZW5kLkRPV04pIHtcbiAgICAgICAgcmVuZGVyQXJyb3dIZWFkKGxhc3RfYmVuZC54ICsgbGFzdF9kcmF3bl93aWR0aCwgc3RhcnQueSwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIEJlbmQ7XG59KCkpO1xuXG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB2aWJyYXRvcy5cblxuVmV4LkZsb3cuVmlicmF0byA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gVmlicmF0bygpIHsgdGhpcy5pbml0KCk7IH1cbiAgVmlicmF0by5DQVRFR09SWSA9IFwidmlicmF0b3NcIjtcblxuICB2YXIgTW9kaWZpZXIgPSBWZXguRmxvdy5Nb2RpZmllcjtcblxuICAvLyAjIyBTdGF0aWMgTWV0aG9kc1xuICAvLyBBcnJhbmdlIHZpYnJhdG9zIGluc2lkZSBhIGBNb2RpZmllckNvbnRleHRgLlxuICBWaWJyYXRvLmZvcm1hdCA9IGZ1bmN0aW9uKHZpYnJhdG9zLCBzdGF0ZSwgY29udGV4dCkge1xuICAgIGlmICghdmlicmF0b3MgfHwgdmlicmF0b3MubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBWaWJyYXRvcyBhcmUgYWx3YXlzIG9uIHRvcC5cbiAgICB2YXIgdGV4dF9saW5lID0gc3RhdGUudG9wX3RleHRfbGluZTtcbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIHZhciBzaGlmdCA9IHN0YXRlLnJpZ2h0X3NoaWZ0IC0gNztcblxuICAgIC8vIElmIHRoZXJlJ3MgYSBiZW5kLCBkcm9wIHRoZSB0ZXh0IGxpbmVcbiAgICB2YXIgYmVuZHMgPSBjb250ZXh0LmdldE1vZGlmaWVycyhWZXguRmxvdy5CZW5kLkNBVEVHT1JZKTtcbiAgICBpZiAoYmVuZHMgJiYgYmVuZHMubGVuZ3RoID4gMCkge1xuICAgICAgdGV4dF9saW5lLS07XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IFZpYnJhdG9zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWJyYXRvcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHZpYnJhdG8gPSB2aWJyYXRvc1tpXTtcbiAgICAgIHZpYnJhdG8uc2V0WFNoaWZ0KHNoaWZ0KTtcbiAgICAgIHZpYnJhdG8uc2V0VGV4dExpbmUodGV4dF9saW5lKTtcbiAgICAgIHdpZHRoICs9IHZpYnJhdG8uZ2V0V2lkdGgoKTtcbiAgICAgIHNoaWZ0ICs9IHdpZHRoO1xuICAgIH1cblxuICAgIHN0YXRlLnJpZ2h0X3NoaWZ0ICs9IHdpZHRoO1xuICAgIHN0YXRlLnRvcF90ZXh0X2xpbmUgKz0gMTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICBWZXguSW5oZXJpdChWaWJyYXRvLCBNb2RpZmllciwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN1cGVyY2xhc3MgPSBWZXguRmxvdy5WaWJyYXRvLnN1cGVyY2xhc3M7XG4gICAgICBzdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5oYXJzaCA9IGZhbHNlO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLlJJR0hUO1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgdmlicmF0b193aWR0aDogMjAsXG4gICAgICAgIHdhdmVfaGVpZ2h0OiA2LFxuICAgICAgICB3YXZlX3dpZHRoOiA0LFxuICAgICAgICB3YXZlX2dpcnRoOiAyXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNldFZpYnJhdG9XaWR0aCh0aGlzLnJlbmRlcl9vcHRpb25zLnZpYnJhdG9fd2lkdGgpO1xuICAgIH0sXG5cbiAgICBzZXRIYXJzaDogZnVuY3Rpb24oaGFyc2gpIHsgdGhpcy5oYXJzaCA9IGhhcnNoOyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRWaWJyYXRvV2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICB0aGlzLnZpYnJhdG9fd2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuc2V0V2lkdGgodGhpcy52aWJyYXRvX3dpZHRoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IHZpYnJhdG8gd2l0aG91dCBhIGNvbnRleHQuXCIpO1xuICAgICAgaWYgKCF0aGlzLm5vdGUpIHRocm93IG5ldyBWZXguUkVSUihcIk5vTm90ZUZvclZpYnJhdG9cIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IHZpYnJhdG8gd2l0aG91dCBhbiBhdHRhY2hlZCBub3RlLlwiKTtcblxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5ub3RlLmdldE1vZGlmaWVyU3RhcnRYWShWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5SSUdIVCxcbiAgICAgICAgICB0aGlzLmluZGV4KTtcblxuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciB2aWJyYXRvX3dpZHRoID0gdGhpcy52aWJyYXRvX3dpZHRoO1xuXG4gICAgICBmdW5jdGlvbiByZW5kZXJWaWJyYXRvKHgsIHkpIHtcbiAgICAgICAgdmFyIHdhdmVfd2lkdGggPSB0aGF0LnJlbmRlcl9vcHRpb25zLndhdmVfd2lkdGg7XG4gICAgICAgIHZhciB3YXZlX2dpcnRoID0gdGhhdC5yZW5kZXJfb3B0aW9ucy53YXZlX2dpcnRoO1xuICAgICAgICB2YXIgd2F2ZV9oZWlnaHQgPSB0aGF0LnJlbmRlcl9vcHRpb25zLndhdmVfaGVpZ2h0O1xuICAgICAgICB2YXIgbnVtX3dhdmVzID0gdmlicmF0b193aWR0aCAvIHdhdmVfd2lkdGg7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHZhciBpO1xuICAgICAgICBpZiAodGhhdC5oYXJzaCkge1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSArIHdhdmVfZ2lydGggKyAxKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtX3dhdmVzIC8gMjsgKytpKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB3YXZlX3dpZHRoLCB5IC0gKHdhdmVfaGVpZ2h0IC8gMikpO1xuICAgICAgICAgICAgeCArPSB3YXZlX3dpZHRoO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2F2ZV93aWR0aCwgeSArICh3YXZlX2hlaWdodCAvIDIpKTtcbiAgICAgICAgICAgIHggKz0gd2F2ZV93aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bV93YXZlcyAvIDI7ICsraSkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0gd2F2ZV93aWR0aCwgKHkgLSAod2F2ZV9oZWlnaHQgLyAyKSkgKyB3YXZlX2dpcnRoICsgMSk7XG4gICAgICAgICAgICB4IC09IHdhdmVfd2lkdGg7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggLSB3YXZlX3dpZHRoLCAoeSArICh3YXZlX2hlaWdodCAvIDIpKSArIHdhdmVfZ2lydGggKyAxKTtcbiAgICAgICAgICAgIHggLT0gd2F2ZV93aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgubW92ZVRvKHgsIHkgKyB3YXZlX2dpcnRoKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtX3dhdmVzIC8gMjsgKytpKSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgKHdhdmVfd2lkdGggLyAyKSwgeSAtICh3YXZlX2hlaWdodCAvIDIpLFxuICAgICAgICAgICAgICB4ICsgd2F2ZV93aWR0aCwgeSk7XG4gICAgICAgICAgICB4ICs9IHdhdmVfd2lkdGg7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgKHdhdmVfd2lkdGggLyAyKSwgeSArICh3YXZlX2hlaWdodCAvIDIpLFxuICAgICAgICAgICAgICB4ICsgd2F2ZV93aWR0aCwgeSk7XG4gICAgICAgICAgICB4ICs9IHdhdmVfd2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bV93YXZlcyAvIDI7ICsraSkge1xuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCAtICh3YXZlX3dpZHRoIC8gMiksXG4gICAgICAgICAgICAgICAgKHkgKyAod2F2ZV9oZWlnaHQgLyAyKSkgKyB3YXZlX2dpcnRoLFxuICAgICAgICAgICAgICAgIHggLSB3YXZlX3dpZHRoLCB5ICsgd2F2ZV9naXJ0aCk7XG4gICAgICAgICAgICB4IC09IHdhdmVfd2lkdGg7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4IC0gKHdhdmVfd2lkdGggLyAyKSxcbiAgICAgICAgICAgICAgICAoeSAtICh3YXZlX2hlaWdodCAvIDIpKSArIHdhdmVfZ2lydGgsXG4gICAgICAgICAgICAgICAgeCAtIHdhdmVfd2lkdGgsIHkgKyB3YXZlX2dpcnRoKTtcbiAgICAgICAgICAgIHggLT0gd2F2ZV93aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdnggPSBzdGFydC54ICsgdGhpcy54X3NoaWZ0O1xuICAgICAgdmFyIHZ5ID0gdGhpcy5ub3RlLmdldFlGb3JUb3BUZXh0KHRoaXMudGV4dF9saW5lKSArIDI7XG5cbiAgICAgIHJlbmRlclZpYnJhdG8odngsIHZ5KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBWaWJyYXRvO1xufSgpKTtcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBUaGlzIGZpbGUgaW1wbGVtZW50cyB0ZXh0IGFubm90YXRpb25zIGFzIG1vZGlmaWVycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0b1xuLy8gbm90ZXMuXG4vL1xuLy8gU2VlIGB0ZXN0cy9hbm5vdGF0aW9uX3Rlc3RzLmpzYCBmb3IgdXNhZ2UgZXhhbXBsZXMuXG5cblZleC5GbG93LkFubm90YXRpb24gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEFubm90YXRpb24odGV4dCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHRleHQpO1xuICB9XG5cbiAgQW5ub3RhdGlvbi5DQVRFR09SWSA9IFwiYW5ub3RhdGlvbnNcIjtcbiAgdmFyIE1vZGlmaWVyID0gVmV4LkZsb3cuTW9kaWZpZXI7XG5cbiAgLy8gVG8gZW5hYmxlIGxvZ2dpbmcgZm9yIHRoaXMgY2xhc3MuIFNldCBgVmV4LkZsb3cuQW5ub3RhdGlvbi5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoQW5ub3RhdGlvbi5ERUJVRykgVmV4LkwoXCJWZXguRmxvdy5Bbm5vdGF0aW9uXCIsIGFyZ3VtZW50cyk7IH1cblxuICAvLyBUZXh0IGFubm90YXRpb25zIGNhbiBiZSBwb3NpdGlvbmVkIGFuZCBqdXN0aWZpZWQgcmVsYXRpdmUgdG8gdGhlIG5vdGUuXG4gIEFubm90YXRpb24uSnVzdGlmeSA9IHtcbiAgICBMRUZUOiAxLFxuICAgIENFTlRFUjogMixcbiAgICBSSUdIVDogMyxcbiAgICBDRU5URVJfU1RFTTogNFxuICB9O1xuXG4gIEFubm90YXRpb24uVmVydGljYWxKdXN0aWZ5ID0ge1xuICAgIFRPUDogMSxcbiAgICBDRU5URVI6IDIsXG4gICAgQk9UVE9NOiAzLFxuICAgIENFTlRFUl9TVEVNOiA0XG4gIH07XG5cbiAgLy8gQXJyYW5nZSBhbm5vdGF0aW9ucyB3aXRoaW4gYSBgTW9kaWZpZXJDb250ZXh0YFxuICBBbm5vdGF0aW9uLmZvcm1hdCA9IGZ1bmN0aW9uKGFubm90YXRpb25zLCBzdGF0ZSkge1xuICAgIGlmICghYW5ub3RhdGlvbnMgfHwgYW5ub3RhdGlvbnMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbaV07XG4gICAgICB3aWR0aCA9IE1hdGgubWF4KGFubm90YXRpb24uZ2V0V2lkdGgoKSwgd2lkdGgpO1xuICAgICAgaWYgKGFubm90YXRpb24uZ2V0UG9zaXRpb24oKSA9PT0gTW9kaWZpZXIuUG9zaXRpb24uQUJPVkUpIHtcbiAgICAgICAgYW5ub3RhdGlvbi5zZXRUZXh0TGluZShzdGF0ZS50b3BfdGV4dF9saW5lKTtcbiAgICAgICAgc3RhdGUudG9wX3RleHRfbGluZSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5ub3RhdGlvbi5zZXRUZXh0TGluZShzdGF0ZS50ZXh0X2xpbmUpO1xuICAgICAgICBzdGF0ZS50ZXh0X2xpbmUrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5sZWZ0X3NoaWZ0ICs9IHdpZHRoIC8gMjtcbiAgICBzdGF0ZS5yaWdodF9zaGlmdCArPSB3aWR0aCAvIDI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgLy9cbiAgLy8gQW5ub3RhdGlvbnMgaW5oZXJpdCBmcm9tIGBNb2RpZmllcmAgYW5kIGlzIHBvc2l0aW9uZWQgY29ycmVjdGx5IHdoZW5cbiAgLy8gaW4gYSBgTW9kaWZpZXJDb250ZXh0YC5cbiAgVmV4LkluaGVyaXQoQW5ub3RhdGlvbiwgTW9kaWZpZXIsIHtcbiAgICAvLyBDcmVhdGUgYSBuZXcgYEFubm90YXRpb25gIHdpdGggdGhlIHN0cmluZyBgdGV4dGAuXG4gICAgaW5pdDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgQW5ub3RhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5ub3RlID0gbnVsbDtcbiAgICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgIHRoaXMuanVzdGlmaWNhdGlvbiA9IEFubm90YXRpb24uSnVzdGlmeS5DRU5URVI7XG4gICAgICB0aGlzLnZlcnRfanVzdGlmaWNhdGlvbiA9IEFubm90YXRpb24uVmVydGljYWxKdXN0aWZ5LlRPUDtcbiAgICAgIHRoaXMuZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiBcIkFyaWFsXCIsXG4gICAgICAgIHNpemU6IDEwLFxuICAgICAgICB3ZWlnaHQ6IFwiXCJcbiAgICAgIH07XG5cbiAgICAgIC8vIFRoZSBkZWZhdWx0IHdpZHRoIGlzIGNhbGN1bGF0ZWQgZnJvbSB0aGUgdGV4dC5cbiAgICAgIHRoaXMuc2V0V2lkdGgoVmV4LkZsb3cudGV4dFdpZHRoKHRleHQpKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGZvbnQgZmFtaWx5LCBzaXplLCBhbmQgd2VpZ2h0LiBFLmcuLCBgQXJpYWxgLCBgMTBwdGAsIGBCb2xkYC5cbiAgICBzZXRGb250OiBmdW5jdGlvbihmYW1pbHksIHNpemUsIHdlaWdodCkge1xuICAgICAgdGhpcy5mb250ID0geyBmYW1pbHk6IGZhbWlseSwgc2l6ZTogc2l6ZSwgd2VpZ2h0OiB3ZWlnaHQgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdmVydGljYWwgcG9zaXRpb24gb2YgdGV4dCAoYWJvdmUgb3IgYmVsb3cgc3RhdmUpLiBganVzdGAgbXVzdCBiZVxuICAgIC8vIGEgdmFsdWUgaW4gYEFubm90YXRpb24uVmVydGljYWxKdXN0aWZ5YC5cbiAgICBzZXRWZXJ0aWNhbEp1c3RpZmljYXRpb246IGZ1bmN0aW9uKGp1c3QpIHtcbiAgICAgIHRoaXMudmVydF9qdXN0aWZpY2F0aW9uID0ganVzdDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYW5kIHNldCBob3Jpem9udGFsIGp1c3RpZmljYXRpb24uIGBqdXN0aWZpY2F0aW9uYCBpcyBhIHZhbHVlIGluXG4gICAgLy8gYEFubm90YXRpb24uSnVzdGlmeWAuXG4gICAgZ2V0SnVzdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmp1c3RpZmljYXRpb247IH0sXG4gICAgc2V0SnVzdGlmaWNhdGlvbjogZnVuY3Rpb24oanVzdGlmaWNhdGlvbikge1xuICAgICAgdGhpcy5qdXN0aWZpY2F0aW9uID0ganVzdGlmaWNhdGlvbjsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBSZW5kZXIgdGV4dCBiZXNpZGUgdGhlIG5vdGUuXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9Db250ZXh0XCIsXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyB0ZXh0IGFubm90YXRpb24gd2l0aG91dCBhIGNvbnRleHQuXCIpO1xuICAgICAgaWYgKCF0aGlzLm5vdGUpIHRocm93IG5ldyBWZXguUkVSUihcIk5vTm90ZUZvckFubm90YXRpb25cIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IHRleHQgYW5ub3RhdGlvbiB3aXRob3V0IGFuIGF0dGFjaGVkIG5vdGUuXCIpO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLm5vdGUuZ2V0TW9kaWZpZXJTdGFydFhZKE1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFLFxuICAgICAgICAgIHRoaXMuaW5kZXgpO1xuXG4gICAgICAvLyBXZSdyZSBjaGFuZ2luZyBjb250ZXh0IHBhcmFtZXRlcnMuIFNhdmUgY3VycmVudCBzdGF0ZS5cbiAgICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XG4gICAgICB0aGlzLmNvbnRleHQuc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSwgdGhpcy5mb250LndlaWdodCk7XG4gICAgICB2YXIgdGV4dF93aWR0aCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dCh0aGlzLnRleHQpLndpZHRoO1xuXG4gICAgICAvLyBFc3RpbWF0ZSB0ZXh0IGhlaWdodCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgd2lkdGggb2YgYW4gJ20nLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIHdvcmsgYXJvdW5kIHRoZSBpbmFiaWxpdHkgdG8gbWVhc3VyZSB0ZXh0IGhlaWdodFxuICAgICAgLy8gaW4gSFRNTDUgQ2FudmFzIChhbmQgU1ZHKS5cbiAgICAgIHZhciB0ZXh0X2hlaWdodCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dChcIm1cIikud2lkdGg7XG4gICAgICB2YXIgeCwgeTtcblxuICAgICAgaWYgKHRoaXMuanVzdGlmaWNhdGlvbiA9PSBBbm5vdGF0aW9uLkp1c3RpZnkuTEVGVCkge1xuICAgICAgICB4ID0gc3RhcnQueDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5qdXN0aWZpY2F0aW9uID09IEFubm90YXRpb24uSnVzdGlmeS5SSUdIVCkge1xuICAgICAgICB4ID0gc3RhcnQueCAtIHRleHRfd2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuanVzdGlmaWNhdGlvbiA9PSBBbm5vdGF0aW9uLkp1c3RpZnkuQ0VOVEVSKSB7XG4gICAgICAgIHggPSBzdGFydC54IC0gdGV4dF93aWR0aCAvIDI7XG4gICAgICB9IGVsc2UgLyogQ0VOVEVSX1NURU0gKi8ge1xuICAgICAgICB4ID0gdGhpcy5ub3RlLmdldFN0ZW1YKCkgLSB0ZXh0X3dpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0ZW1fZXh0LCBzcGFjaW5nO1xuICAgICAgdmFyIGhhc19zdGVtID0gdGhpcy5ub3RlLmhhc1N0ZW0oKTtcbiAgICAgIHZhciBzdGF2ZSA9IHRoaXMubm90ZS5nZXRTdGF2ZSgpO1xuXG4gICAgICAvLyBUaGUgcG9zaXRpb24gb2YgdGhlIHRleHQgdmFyaWVzIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IHRoZSBub3RlXG4gICAgICAvLyBoYXMgYSBzdGVtLlxuICAgICAgaWYgKGhhc19zdGVtKSB7XG4gICAgICAgIHN0ZW1fZXh0ID0gdGhpcy5ub3RlLmdldFN0ZW0oKS5nZXRFeHRlbnRzKCk7XG4gICAgICAgIHNwYWNpbmcgPSBzdGF2ZS5nZXRTcGFjaW5nQmV0d2VlbkxpbmVzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnZlcnRfanVzdGlmaWNhdGlvbiA9PSBBbm5vdGF0aW9uLlZlcnRpY2FsSnVzdGlmeS5CT1RUT00pIHtcbiAgICAgICAgeSA9IHN0YXZlLmdldFlGb3JCb3R0b21UZXh0KHRoaXMudGV4dF9saW5lKTtcbiAgICAgICAgaWYgKGhhc19zdGVtKSB7XG4gICAgICAgICAgdmFyIHN0ZW1fYmFzZSA9ICh0aGlzLm5vdGUuZ2V0U3RlbURpcmVjdGlvbigpID09PSAxID8gc3RlbV9leHQuYmFzZVkgOiBzdGVtX2V4dC50b3BZKTtcbiAgICAgICAgICB5ID0gTWF0aC5tYXgoeSwgc3RlbV9iYXNlICsgKHNwYWNpbmcgKiAodGhpcy50ZXh0X2xpbmUgKyAyKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudmVydF9qdXN0aWZpY2F0aW9uID09XG4gICAgICAgICAgICAgICAgIEFubm90YXRpb24uVmVydGljYWxKdXN0aWZ5LkNFTlRFUikge1xuICAgICAgICB2YXIgeXQgPSB0aGlzLm5vdGUuZ2V0WUZvclRvcFRleHQodGhpcy50ZXh0X2xpbmUpIC0gMTtcbiAgICAgICAgdmFyIHliID0gc3RhdmUuZ2V0WUZvckJvdHRvbVRleHQodGhpcy50ZXh0X2xpbmUpO1xuICAgICAgICB5ID0geXQgKyAoIHliIC0geXQgKSAvIDIgKyB0ZXh0X2hlaWdodCAvIDI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudmVydF9qdXN0aWZpY2F0aW9uID09XG4gICAgICAgICAgICAgICAgIEFubm90YXRpb24uVmVydGljYWxKdXN0aWZ5LlRPUCkge1xuICAgICAgICB5ID0gTWF0aC5taW4oc3RhdmUuZ2V0WUZvclRvcFRleHQodGhpcy50ZXh0X2xpbmUpLCB0aGlzLm5vdGUuZ2V0WXMoKVswXSAtIDEwKTtcbiAgICAgICAgaWYgKGhhc19zdGVtKSB7XG4gICAgICAgICAgeSA9IE1hdGgubWluKHksIChzdGVtX2V4dC50b3BZIC0gNSkgLSAoc3BhY2luZyAqIHRoaXMudGV4dF9saW5lKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSAvKiBDRU5URVJfU1RFTSAqL3tcbiAgICAgICAgdmFyIGV4dGVudHMgPSB0aGlzLm5vdGUuZ2V0U3RlbUV4dGVudHMoKTtcbiAgICAgICAgeSA9IGV4dGVudHMudG9wWSArIChleHRlbnRzLmJhc2VZIC0gZXh0ZW50cy50b3BZKSAvIDIgK1xuICAgICAgICAgIHRleHRfaGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgTChcIlJlbmRlcmluZyBhbm5vdGF0aW9uOiBcIiwgdGhpcy50ZXh0LCB4LCB5KTtcbiAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dCh0aGlzLnRleHQsIHgsIHkpO1xuICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBBbm5vdGF0aW9uO1xufSgpKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy8gQXV0aG9yOiBMYXJyeSBLdWhucy5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIGFydGljdWxhdGlvbnMgYW5kIGFjY2VudHMgYXMgbW9kaWZpZXJzIHRoYXQgY2FuIGJlXG4vLyBhdHRhY2hlZCB0byBub3Rlcy4gVGhlIGNvbXBsZXRlIGxpc3Qgb2YgYXJ0aWN1bGF0aW9ucyBpcyBhdmFpbGFibGUgaW5cbi8vIGB0YWJsZXMuanNgIHVuZGVyIGBWZXguRmxvdy5hcnRpY3VsYXRpb25Db2Rlc2AuXG4vL1xuLy8gU2VlIGB0ZXN0cy9hcnRpY3VsYXRpb25fdGVzdHMuanNgIGZvciB1c2FnZSBleGFtcGxlcy5cblxuVmV4LkZsb3cuQXJ0aWN1bGF0aW9uID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBBcnRpY3VsYXRpb24odHlwZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHR5cGUpO1xuICB9XG4gIEFydGljdWxhdGlvbi5DQVRFR09SWSA9IFwiYXJ0aWN1bGF0aW9uc1wiO1xuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93LkFydGljdWxhdGlvbi5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoQXJ0aWN1bGF0aW9uLkRFQlVHKSBWZXguTChcIlZleC5GbG93LkFydGljdWxhdGlvblwiLCBhcmd1bWVudHMpOyB9XG5cbiAgdmFyIE1vZGlmaWVyID0gVmV4LkZsb3cuTW9kaWZpZXI7XG5cbiAgLy8gIyMgU3RhdGljIE1ldGhvZHNcbiAgLy8gQXJyYW5nZSBhcnRpY3VsYXRpb25zIGluc2lkZSBgTW9kaWZpZXJDb250ZXh0YFxuICBBcnRpY3VsYXRpb24uZm9ybWF0ID0gZnVuY3Rpb24oYXJ0aWN1bGF0aW9ucywgc3RhdGUpIHtcbiAgICBpZiAoIWFydGljdWxhdGlvbnMgfHwgYXJ0aWN1bGF0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnRpY3VsYXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgaW5jcmVtZW50ID0gMTtcbiAgICAgIHZhciBhcnRpY3VsYXRpb24gPSBhcnRpY3VsYXRpb25zW2ldO1xuICAgICAgd2lkdGggPSBNYXRoLm1heChhcnRpY3VsYXRpb24uZ2V0V2lkdGgoKSwgd2lkdGgpO1xuXG4gICAgICB2YXIgdHlwZSA9IFZleC5GbG93LmFydGljdWxhdGlvbkNvZGVzKGFydGljdWxhdGlvbi50eXBlKTtcblxuICAgICAgaWYgKCF0eXBlLmJldHdlZW5fbGluZXMpIGluY3JlbWVudCArPSAxLjU7XG5cbiAgICAgIGlmIChhcnRpY3VsYXRpb24uZ2V0UG9zaXRpb24oKSA9PT0gTW9kaWZpZXIuUG9zaXRpb24uQUJPVkUpIHtcbiAgICAgICAgYXJ0aWN1bGF0aW9uLnNldFRleHRMaW5lKHN0YXRlLnRvcF90ZXh0X2xpbmUpO1xuICAgICAgICBzdGF0ZS50b3BfdGV4dF9saW5lICs9IGluY3JlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFydGljdWxhdGlvbi5zZXRUZXh0TGluZShzdGF0ZS50ZXh0X2xpbmUpO1xuICAgICAgICBzdGF0ZS50ZXh0X2xpbmUgKz0gaW5jcmVtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLmxlZnRfc2hpZnQgKz0gd2lkdGggLyAyO1xuICAgIHN0YXRlLnJpZ2h0X3NoaWZ0ICs9IHdpZHRoIC8gMjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICBWZXguSW5oZXJpdChBcnRpY3VsYXRpb24sIE1vZGlmaWVyLCB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IGFydGljdWxhdGlvbiBvZiB0eXBlIGB0eXBlYCwgd2hpY2ggaXMgYW4gZW50cnkgaW5cbiAgICAvLyBgVmV4LkZsb3cuYXJ0aWN1bGF0aW9uQ29kZXNgIGluIGB0YWJsZXMuanNgLlxuICAgIGluaXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIEFydGljdWxhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5ub3RlID0gbnVsbDtcbiAgICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBNb2RpZmllci5Qb3NpdGlvbi5CRUxPVztcblxuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgZm9udF9zY2FsZTogMzhcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJ0aWN1bGF0aW9uID0gVmV4LkZsb3cuYXJ0aWN1bGF0aW9uQ29kZXModGhpcy50eXBlKTtcbiAgICAgIGlmICghdGhpcy5hcnRpY3VsYXRpb24pIHRocm93IG5ldyBWZXguUkVSUihcIkFyZ3VtZW50RXJyb3JcIixcbiAgICAgICAgIFwiQXJ0aWN1bGF0aW9uIG5vdCBmb3VuZDogJ1wiICsgdGhpcy50eXBlICsgXCInXCIpO1xuXG4gICAgICAvLyBEZWZhdWx0IHdpZHRoIGNvbWVzIGZyb20gYXJ0aWN1bGF0aW9uIHRhYmxlLlxuICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLmFydGljdWxhdGlvbi53aWR0aCk7XG4gICAgfSxcblxuICAgIC8vIFJlbmRlciBhcnRpY3VsYXRpb24gaW4gcG9zaXRpb24gbmV4dCB0byBub3RlLlxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgQXJ0aWN1bGF0aW9uIHdpdGhvdXQgYSBjb250ZXh0LlwiKTtcbiAgICAgIGlmICghKHRoaXMubm90ZSAmJiAodGhpcy5pbmRleCAhPT0gbnVsbCkpKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0F0dGFjaGVkTm90ZVwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgQXJ0aWN1bGF0aW9uIHdpdGhvdXQgYSBub3RlIGFuZCBpbmRleC5cIik7XG5cbiAgICAgIHZhciBzdGVtX2RpcmVjdGlvbiA9IHRoaXMubm90ZS5nZXRTdGVtRGlyZWN0aW9uKCk7XG4gICAgICB2YXIgc3RhdmUgPSB0aGlzLm5vdGUuZ2V0U3RhdmUoKTtcblxuICAgICAgdmFyIGlzX29uX2hlYWQgPSAodGhpcy5wb3NpdGlvbiA9PT0gTW9kaWZpZXIuUG9zaXRpb24uQUJPVkUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZW1fZGlyZWN0aW9uID09PSBWZXguRmxvdy5TdGF2ZU5vdGUuU1RFTV9ET1dOKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5wb3NpdGlvbiA9PT0gTW9kaWZpZXIuUG9zaXRpb24uQkVMT1cgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZW1fZGlyZWN0aW9uID09PSBWZXguRmxvdy5TdGF2ZU5vdGUuU1RFTV9VUCk7XG5cbiAgICAgIHZhciBuZWVkc0xpbmVBZGp1c3RtZW50ID0gZnVuY3Rpb24oYXJ0aWN1bGF0aW9uLCBub3RlX2xpbmUsIGxpbmVfc3BhY2luZykge1xuICAgICAgICB2YXIgb2Zmc2V0X2RpcmVjdGlvbiA9IChhcnRpY3VsYXRpb24ucG9zaXRpb24gPT09IE1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFKSA/IDEgOiAtMTtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gYXJ0aWN1bGF0aW9uLmdldE5vdGUoKS5nZXREdXJhdGlvbigpO1xuICAgICAgICBpZighaXNfb25faGVhZCAmJiBWZXguRmxvdy5kdXJhdGlvblRvTnVtYmVyKGR1cmF0aW9uKSA8PSAxKXtcbiAgICAgICAgICAvLyBBZGQgc3RlbSBsZW5ndGgsIHVubGVzcyBpdCdzIG9uIGEgd2hvbGUgbm90ZS5cbiAgICAgICAgICBub3RlX2xpbmUgKz0gb2Zmc2V0X2RpcmVjdGlvbiAqIDMuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcnRpY3VsYXRpb25fbGluZSA9IG5vdGVfbGluZSArIChvZmZzZXRfZGlyZWN0aW9uICogbGluZV9zcGFjaW5nKTtcblxuICAgICAgICBpZihhcnRpY3VsYXRpb25fbGluZSA+PSAxICYmXG4gICAgICAgICAgIGFydGljdWxhdGlvbl9saW5lIDw9IDUgJiZcbiAgICAgICAgICAgYXJ0aWN1bGF0aW9uX2xpbmUgJSAxID09PSAwKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEFydGljdWxhdGlvbnMgYXJlIGNlbnRlcmVkIG92ZXIvdW5kZXIgdGhlIG5vdGUgaGVhZC5cbiAgICAgIHZhciBzdGFydCA9IHRoaXMubm90ZS5nZXRNb2RpZmllclN0YXJ0WFkodGhpcy5wb3NpdGlvbiwgdGhpcy5pbmRleCk7XG4gICAgICB2YXIgZ2x5cGhfeSA9IHN0YXJ0Lnk7XG4gICAgICB2YXIgc2hpZnRZID0gMDtcbiAgICAgIHZhciBsaW5lX3NwYWNpbmcgPSAxO1xuICAgICAgdmFyIHNwYWNpbmcgPSBzdGF2ZS5nZXRTcGFjaW5nQmV0d2VlbkxpbmVzKCk7XG4gICAgICB2YXIgaXNfdGFibm90ZSA9IHRoaXMubm90ZS5nZXRDYXRlZ29yeSgpID09PSAndGFibm90ZXMnO1xuICAgICAgdmFyIHN0ZW1fZXh0ID0gdGhpcy5ub3RlLmdldFN0ZW0oKS5nZXRFeHRlbnRzKCk7XG5cbiAgICAgIHZhciB0b3AgPSBzdGVtX2V4dC50b3BZO1xuICAgICAgdmFyIGJvdHRvbSA9IHN0ZW1fZXh0LmJhc2VZO1xuXG4gICAgICBpZiAoc3RlbV9kaXJlY3Rpb24gPT09IFZleC5GbG93LlN0YXZlTm90ZS5TVEVNX0RPV04pIHtcbiAgICAgICAgdG9wID0gc3RlbV9leHQuYmFzZVk7XG4gICAgICAgIGJvdHRvbSA9IHN0ZW1fZXh0LnRvcFk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhYk5vdGVzIGRvbid0IGhhdmUgc3RlbXMgYXR0YWNoZWQgdG8gdGhlbS4gVGFiIHN0ZW1zIGFyZSByZW5kZXJlZFxuICAgICAgLy8gb3V0c2lkZSB0aGUgc3RhdmUuXG4gICAgICBpZiAoaXNfdGFibm90ZSkge1xuICAgICAgICBpZiAodGhpcy5ub3RlLmhhc1N0ZW0oKSl7XG4gICAgICAgICAgaWYgKHN0ZW1fZGlyZWN0aW9uID09PSBWZXguRmxvdy5TdGF2ZU5vdGUuU1RFTV9VUCkge1xuICAgICAgICAgICAgYm90dG9tID0gc3RhdmUuZ2V0WUZvckJvdHRvbVRleHQodGhpcy50ZXh0X2xpbmUgLSAyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0ZW1fZGlyZWN0aW9uID09PSBWZXguRmxvdy5TdGF2ZU5vdGUuU1RFTV9ET1dOICkge1xuICAgICAgICAgICAgdG9wID0gc3RhdmUuZ2V0WUZvclRvcFRleHQodGhpcy50ZXh0X2xpbmUgLSAxLjUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gV2l0aG91dCBhIHN0ZW1cbiAgICAgICAgICB0b3AgPSBzdGF2ZS5nZXRZRm9yVG9wVGV4dCh0aGlzLnRleHRfbGluZSAtIDEpO1xuICAgICAgICAgIGJvdHRvbSA9IHN0YXZlLmdldFlGb3JCb3R0b21UZXh0KHRoaXMudGV4dF9saW5lIC0gMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGlzX2Fib3ZlID0gKHRoaXMucG9zaXRpb24gPT09IE1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgIHZhciBub3RlX2xpbmUgPSB0aGlzLm5vdGUuZ2V0TGluZU51bWJlcihpc19hYm92ZSk7XG5cbiAgICAgIC8vIEJlYW1lZCBzdGVtcyBhcmUgbG9uZ2VyIHRoYW4gcXVhcnRlciBub3RlIHN0ZW1zLlxuICAgICAgaWYgKCFpc19vbl9oZWFkICYmIHRoaXMubm90ZS5iZWFtKSBsaW5lX3NwYWNpbmcgKz0gMC41O1xuXG4gICAgICAvLyBJZiBhcnRpY3VsYXRpb24gd2lsbCBvdmVybGFwIGEgbGluZSwgcmVwb3NpdGlvbiBpdC5cbiAgICAgIGlmIChuZWVkc0xpbmVBZGp1c3RtZW50KHRoaXMsIG5vdGVfbGluZSwgbGluZV9zcGFjaW5nKSkgbGluZV9zcGFjaW5nICs9IDAuNTtcblxuICAgICAgdmFyIGdseXBoX3lfYmV0d2Vlbl9saW5lcztcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSBNb2RpZmllci5Qb3NpdGlvbi5BQk9WRSkge1xuICAgICAgICBzaGlmdFkgPSB0aGlzLmFydGljdWxhdGlvbi5zaGlmdF91cDtcbiAgICAgICAgZ2x5cGhfeV9iZXR3ZWVuX2xpbmVzID0gKHRvcCAtIDcpIC0gKHNwYWNpbmcgKiAodGhpcy50ZXh0X2xpbmUgKyBsaW5lX3NwYWNpbmcpKTtcblxuICAgICAgICBpZiAodGhpcy5hcnRpY3VsYXRpb24uYmV0d2Vlbl9saW5lcykge1xuICAgICAgICAgIGdseXBoX3kgPSBnbHlwaF95X2JldHdlZW5fbGluZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2x5cGhfeSA9IE1hdGgubWluKHN0YXZlLmdldFlGb3JUb3BUZXh0KHRoaXMudGV4dF9saW5lKSAtIDMsIGdseXBoX3lfYmV0d2Vlbl9saW5lcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNoaWZ0WSA9IHRoaXMuYXJ0aWN1bGF0aW9uLnNoaWZ0X2Rvd24gLSAxMDtcblxuICAgICAgICBnbHlwaF95X2JldHdlZW5fbGluZXMgPSBib3R0b20gKyAxMCArIHNwYWNpbmcgKiAodGhpcy50ZXh0X2xpbmUgKyBsaW5lX3NwYWNpbmcpO1xuICAgICAgICBpZiAodGhpcy5hcnRpY3VsYXRpb24uYmV0d2Vlbl9saW5lcykge1xuICAgICAgICAgIGdseXBoX3kgPSBnbHlwaF95X2JldHdlZW5fbGluZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2x5cGhfeSA9IE1hdGgubWF4KHN0YXZlLmdldFlGb3JCb3R0b21UZXh0KHRoaXMudGV4dF9saW5lKSwgZ2x5cGhfeV9iZXR3ZWVuX2xpbmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZ2x5cGhfeCA9IHN0YXJ0LnggKyB0aGlzLmFydGljdWxhdGlvbi5zaGlmdF9yaWdodDtcbiAgICAgIGdseXBoX3kgKz0gc2hpZnRZICsgdGhpcy55X3NoaWZ0O1xuXG4gICAgICBMKFwiUmVuZGVyaW5nIGFydGljdWxhdGlvbjogXCIsIHRoaXMuYXJ0aWN1bGF0aW9uLCBnbHlwaF94LCBnbHlwaF95KTtcbiAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKHRoaXMuY29udGV4dCwgZ2x5cGhfeCwgZ2x5cGhfeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuZm9udF9zY2FsZSwgdGhpcy5hcnRpY3VsYXRpb24uY29kZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQXJ0aWN1bGF0aW9uO1xufSgpKTtcbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB2YXJpZXMgdHlwZXMgb2YgdHVuaW5ncyBmb3IgdGFibGF0dXJlLlxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5WZXguRmxvdy5UdW5pbmcgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFR1bmluZyh0dW5pbmdTdHJpbmcpIHtcbiAgICB0aGlzLmluaXQodHVuaW5nU3RyaW5nKTtcbiAgfVxuXG4gIFR1bmluZy5uYW1lcyA9IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRS81LEIvNCxHLzQsRC80LEEvMyxFLzNcIixcbiAgICBcImRhZ2RhZFwiOiBcIkQvNSxBLzQsRy80LEQvNCxBLzMsRC8zXCIsXG4gICAgXCJkcm9wZFwiOiBcIkUvNSxCLzQsRy80LEQvNCxBLzMsRC8zXCIsXG4gICAgXCJlYlwiOiBcIkViLzUsQmIvNCxHYi80LERiLzQsQWIvMyxEYi8zXCIsXG4gICAgXCJzdGFuZGFyZEJhbmpvXCI6IFwiRC81LEIvNCxHLzQsRC80LEcvNVwiXG4gIH07XG5cbiAgVHVuaW5nLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbih0dW5pbmdTdHJpbmcpIHtcbiAgICAgIC8vIERlZmF1bHQgdG8gc3RhbmRhcmQgdHVuaW5nLlxuICAgICAgdGhpcy5zZXRUdW5pbmcodHVuaW5nU3RyaW5nIHx8IFwiRS81LEIvNCxHLzQsRC80LEEvMyxFLzMsQi8yLEUvMlwiKTtcbiAgICB9LFxuXG4gICAgbm90ZVRvSW50ZWdlcjogZnVuY3Rpb24obm90ZVN0cmluZykge1xuICAgICAgcmV0dXJuIFZleC5GbG93LmtleVByb3BlcnRpZXMobm90ZVN0cmluZykuaW50X3ZhbHVlO1xuICAgIH0sXG5cbiAgICBzZXRUdW5pbmc6IGZ1bmN0aW9uKG5vdGVTdHJpbmcpIHtcbiAgICAgIGlmIChWZXguRmxvdy5UdW5pbmcubmFtZXNbbm90ZVN0cmluZ10pXG4gICAgICAgIG5vdGVTdHJpbmcgPSBWZXguRmxvdy5UdW5pbmcubmFtZXNbbm90ZVN0cmluZ107XG5cbiAgICAgIHRoaXMudHVuaW5nU3RyaW5nID0gbm90ZVN0cmluZztcbiAgICAgIHRoaXMudHVuaW5nVmFsdWVzID0gW107XG4gICAgICB0aGlzLm51bVN0cmluZ3MgPSAwO1xuXG4gICAgICB2YXIga2V5cyA9IG5vdGVTdHJpbmcuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJJbnZhbGlkIHR1bmluZyBzdHJpbmc6IFwiICsgbm90ZVN0cmluZyk7XG5cbiAgICAgIHRoaXMubnVtU3RyaW5ncyA9IGtleXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bVN0cmluZ3M7ICsraSkge1xuICAgICAgICB0aGlzLnR1bmluZ1ZhbHVlc1tpXSA9IHRoaXMubm90ZVRvSW50ZWdlcihrZXlzW2ldKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VmFsdWVGb3JTdHJpbmc6IGZ1bmN0aW9uKHN0cmluZ051bSkge1xuICAgICAgdmFyIHMgPSBwYXJzZUludChzdHJpbmdOdW0sIDEwKTtcbiAgICAgIGlmIChzIDwgMSB8fCBzID4gdGhpcy5udW1TdHJpbmdzKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJTdHJpbmcgbnVtYmVyIG11c3QgYmUgYmV0d2VlbiAxIGFuZCBcIiArXG4gICAgICAgICAgICB0aGlzLm51bVN0cmluZ3MgKyBcIjogXCIgKyBzdHJpbmdOdW0pO1xuXG4gICAgICByZXR1cm4gdGhpcy50dW5pbmdWYWx1ZXNbcyAtIDFdO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZUZvckZyZXQ6IGZ1bmN0aW9uKGZyZXROdW0sIHN0cmluZ051bSkge1xuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gdGhpcy5nZXRWYWx1ZUZvclN0cmluZyhzdHJpbmdOdW0pO1xuICAgICAgdmFyIGYgPSBwYXJzZUludChmcmV0TnVtLCAxMCk7XG5cbiAgICAgIGlmIChmIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJGcmV0IG51bWJlciBtdXN0IGJlIDAgb3IgaGlnaGVyOiBcIiArXG4gICAgICAgICAgICBmcmV0TnVtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlICsgZjtcbiAgICB9LFxuXG4gICAgZ2V0Tm90ZUZvckZyZXQ6IGZ1bmN0aW9uKGZyZXROdW0sIHN0cmluZ051bSkge1xuICAgICAgdmFyIG5vdGVWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVGb3JGcmV0KGZyZXROdW0sIHN0cmluZ051bSk7XG5cbiAgICAgIHZhciBvY3RhdmUgPSBNYXRoLmZsb29yKG5vdGVWYWx1ZSAvIDEyKTtcbiAgICAgIHZhciB2YWx1ZSA9IG5vdGVWYWx1ZSAlIDEyO1xuXG4gICAgICByZXR1cm4gVmV4LkZsb3cuaW50ZWdlclRvTm90ZSh2YWx1ZSkgKyBcIi9cIiArIG9jdGF2ZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFR1bmluZztcbn0oKSk7XG5cbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vL1xuLy8gQSBiYXNlIGNsYXNzIGZvciBzdGF2ZSBtb2RpZmllcnMgKGUuZy4gY2xlZnMsIGtleSBzaWduYXR1cmVzKVxuLy9cblxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5WZXguRmxvdy5TdGF2ZU1vZGlmaWVyID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBTdGF2ZU1vZGlmaWVyKCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgU3RhdmVNb2RpZmllci5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBhZGRpbmcgPSAxMDtcbiAgICB9LFxuXG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkge3JldHVybiBcIlwiO30sXG4gICAgbWFrZVNwYWNlcjogZnVuY3Rpb24ocGFkZGluZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7cmV0dXJuIHRydWU7fSxcbiAgICAgICAgc2V0U3RhdmU6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIHJlbmRlclRvU3RhdmU6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIGdldE1ldHJpY3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7d2lkdGg6IHBhZGRpbmd9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBwbGFjZUdseXBoT25MaW5lOiBmdW5jdGlvbihnbHlwaCwgc3RhdmUsIGxpbmUpIHtcbiAgICAgIGdseXBoLnNldFlTaGlmdChzdGF2ZS5nZXRZRm9yTGluZShsaW5lKSAtIHN0YXZlLmdldFlGb3JHbHlwaHMoKSk7XG4gICAgfSxcblxuICAgIHNldFBhZGRpbmc6IGZ1bmN0aW9uKHBhZGRpbmcpIHtcbiAgICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgfSxcblxuICAgIGFkZFRvU3RhdmU6IGZ1bmN0aW9uKHN0YXZlLCBmaXJzdEdseXBoKSB7XG4gICAgICBpZiAoIWZpcnN0R2x5cGgpIHtcbiAgICAgICAgc3RhdmUuYWRkR2x5cGgodGhpcy5tYWtlU3BhY2VyKHRoaXMucGFkZGluZykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZE1vZGlmaWVyKHN0YXZlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhZGRUb1N0YXZlRW5kOiBmdW5jdGlvbihzdGF2ZSwgZmlyc3RHbHlwaCkge1xuICAgICAgaWYgKCFmaXJzdEdseXBoKSB7XG4gICAgICAgIHN0YXZlLmFkZEVuZEdseXBoKHRoaXMubWFrZVNwYWNlcih0aGlzLnBhZGRpbmcpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdGF2ZS5hZGRFbmRHbHlwaCh0aGlzLm1ha2VTcGFjZXIoMikpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZEVuZE1vZGlmaWVyKHN0YXZlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhZGRNb2RpZmllcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJNZXRob2ROb3RJbXBsZW1lbnRlZFwiLFxuICAgICAgICAgIFwiYWRkTW9kaWZpZXIoKSBub3QgaW1wbGVtZW50ZWQgZm9yIHRoaXMgc3RhdmUgbW9kaWZpZXIuXCIpO1xuICAgIH0sXG5cbiAgICBhZGRFbmRNb2RpZmllcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJNZXRob2ROb3RJbXBsZW1lbnRlZFwiLFxuICAgICAgICAgIFwiYWRkRW5kTW9kaWZpZXIoKSBub3QgaW1wbGVtZW50ZWQgZm9yIHRoaXMgc3RhdmUgbW9kaWZpZXIuXCIpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3RhdmVNb2RpZmllcjtcbn0oKSk7XG5cblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vLyBBdXRob3I6IEN5cmlsIFNpbHZlcm1hblxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMga2V5IHNpZ25hdHVyZXMuIEEga2V5IHNpZ25hdHVyZSBzaXRzIG9uIGEgc3RhdmVcbi8vIGFuZCBpbmRpY2F0ZXMgdGhlIG5vdGVzIHdpdGggaW1wbGljaXQgYWNjaWRlbnRhbHMuXG5WZXguRmxvdy5LZXlTaWduYXR1cmUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEtleVNpZ25hdHVyZShrZXlTcGVjKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQoa2V5U3BlYyk7XG4gIH1cblxuICAvLyBTcGFjZSBiZXR3ZWVuIG5hdHVyYWwgYW5kIGZvbGxvd2luZyBhY2NpZGVudGFsIGRlcGVuZGluZ1xuICAvLyBvbiB2ZXJ0aWNhbCBwb3NpdGlvblxuICBLZXlTaWduYXR1cmUuYWNjaWRlbnRhbFNwYWNpbmcgPSB7XG4gICAgJyMnOiB7XG4gICAgICBhYm92ZTogNixcbiAgICAgIGJlbG93OiA0XG4gICAgfSxcbiAgICAnYic6IHtcbiAgICAgIGFib3ZlOiA0LFxuICAgICAgYmVsb3c6IDdcbiAgICB9LFxuICAgICduJzoge1xuICAgICAgYWJvdmU6IDMsXG4gICAgICBiZWxvdzogLTFcbiAgICB9XG4gIH07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgVmV4LkluaGVyaXQoS2V5U2lnbmF0dXJlLCBWZXguRmxvdy5TdGF2ZU1vZGlmaWVyLCB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IEtleSBTaWduYXR1cmUgYmFzZWQgb24gYSBga2V5X3NwZWNgXG4gICAgaW5pdDogZnVuY3Rpb24oa2V5X3NwZWMpIHtcbiAgICAgIEtleVNpZ25hdHVyZS5zdXBlcmNsYXNzLmluaXQoKTtcblxuICAgICAgdGhpcy5nbHlwaEZvbnRTY2FsZSA9IDM4OyAvLyBUT0RPKDB4RkUpOiBTaG91bGQgdGhpcyBtYXRjaCBTdGF2ZU5vdGU/XG4gICAgICB0aGlzLmFjY0xpc3QgPSBWZXguRmxvdy5rZXlTaWduYXR1cmUoa2V5X3NwZWMpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYW4gYWNjaWRlbnRhbCBnbHlwaCB0byB0aGUgYHN0YXZlYC4gYGFjY2AgaXMgdGhlIGRhdGEgb2YgdGhlXG4gICAgLy8gYWNjaWRlbnRhbCB0byBhZGQuIElmIHRoZSBgbmV4dGAgYWNjaWRlbnRhbCBpcyBhbHNvIHByb3ZpZGVkLCBleHRyYVxuICAgIC8vIHdpZHRoIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGluaXRpYWwgYWNjaWRlbnRhbCBmb3Igb3B0aW1hbCBzcGFjaW5nLlxuICAgIGFkZEFjY1RvU3RhdmU6IGZ1bmN0aW9uKHN0YXZlLCBhY2MsIG5leHQpIHtcbiAgICAgIHZhciBnbHlwaF9kYXRhID0gVmV4LkZsb3cuYWNjaWRlbnRhbENvZGVzKGFjYy50eXBlKTtcbiAgICAgIHZhciBnbHlwaCA9IG5ldyBWZXguRmxvdy5HbHlwaChnbHlwaF9kYXRhLmNvZGUsIHRoaXMuZ2x5cGhGb250U2NhbGUpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgc3BhY2luZyBiZXR3ZWVuIGN1cnJlbnQgYWNjaWRlbnRhbCBhbmQgdGhlIG5leHQgYWNjaWRlbnRhbFxuICAgICAgdmFyIGV4dHJhX3dpZHRoID0gMDtcbiAgICAgIGlmIChhY2MudHlwZSA9PT0gXCJuXCIgJiYgbmV4dCkge1xuICAgICAgICB2YXIgYWJvdmUgPSBuZXh0LmxpbmUgPj0gYWNjLmxpbmU7XG4gICAgICAgIHZhciBzcGFjZSA9IEtleVNpZ25hdHVyZS5hY2NpZGVudGFsU3BhY2luZ1tuZXh0LnR5cGVdO1xuICAgICAgICBleHRyYV93aWR0aCA9IGFib3ZlID8gc3BhY2UuYWJvdmUgOiBzcGFjZS5iZWxvdztcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRoZSB3aWR0aCBhbmQgcGxhY2UgdGhlIGdseXBoIG9uIHRoZSBzdGF2ZVxuICAgICAgZ2x5cGguc2V0V2lkdGgoZ2x5cGhfZGF0YS53aWR0aCArIGV4dHJhX3dpZHRoKTtcbiAgICAgIHRoaXMucGxhY2VHbHlwaE9uTGluZShnbHlwaCwgc3RhdmUsIGFjYy5saW5lKTtcbiAgICAgIHN0YXZlLmFkZEdseXBoKGdseXBoKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FuY2VsIG91dCBhIGtleSBzaWduYXR1cmUgcHJvdmlkZWQgaW4gdGhlIGBzcGVjYCBwYXJhbWV0ZXIuIFRoaXMgd2lsbFxuICAgIC8vIHBsYWNlIGFwcHJvcHJpYXRlIG5hdHVyYWwgYWNjaWRlbnRhbHMgYmVmb3JlIHRoZSBrZXkgc2lnbmF0dXJlLlxuICAgIGNhbmNlbEtleTogZnVuY3Rpb24oc3BlYykge1xuICAgICAgLy8gR2V0IHRoZSBhY2NpZGVudGFsIGxpc3QgZm9yIHRoZSBjYW5jZWxsZWQga2V5IHNpZ25hdHVyZVxuICAgICAgdmFyIGNhbmNlbF9hY2NMaXN0ID0gVmV4LkZsb3cua2V5U2lnbmF0dXJlKHNwZWMpO1xuXG4gICAgICAvLyBJZiB0aGUgY2FuY2VsbGVkIGtleSBoYXMgYSBkaWZmZXJlbnQgYWNjaWRlbnRhbCB0eXBlLCBpZTogIyB2cyBiXG4gICAgICB2YXIgZGlmZmVyZW50X3R5cGVzID0gdGhpcy5hY2NMaXN0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxfYWNjTGlzdFswXS50eXBlICE9PSB0aGlzLmFjY0xpc3RbMF0udHlwZTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBtYW55IG5hdHVyYWxzIG5lZWRlZCB0byBhZGRcbiAgICAgIHZhciBuYXR1cmFscyA9IDA7XG4gICAgICBpZiAoZGlmZmVyZW50X3R5cGVzKSB7XG4gICAgICAgIG5hdHVyYWxzID0gY2FuY2VsX2FjY0xpc3QubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmF0dXJhbHMgPSBjYW5jZWxfYWNjTGlzdC5sZW5ndGggLSB0aGlzLmFjY0xpc3QubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gaWYgbm8gbmF0dXJhbHMgbmVlZGVkXG4gICAgICBpZiAobmF0dXJhbHMgPCAxKSByZXR1cm47XG5cbiAgICAgIC8vIEdldCB0aGUgbGluZSBwb3NpdGlvbiBmb3IgZWFjaCBuYXR1cmFsXG4gICAgICB2YXIgY2FuY2VsbGVkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hdHVyYWxzOyBpKyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaTtcbiAgICAgICAgaWYgKCFkaWZmZXJlbnRfdHlwZXMpIHtcbiAgICAgICAgICBpbmRleCA9IGNhbmNlbF9hY2NMaXN0Lmxlbmd0aCAtIG5hdHVyYWxzICsgaTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY2MgPSBjYW5jZWxfYWNjTGlzdFtpbmRleF07XG4gICAgICAgIGNhbmNlbGxlZC5wdXNoKHt0eXBlOiBcIm5cIiwgbGluZTogYWNjLmxpbmV9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29tYmluZSBuYXR1cmFscyB3aXRoIG1haW4gYWNjaWRlbnRhbCBsaXN0IGZvciB0aGUga2V5IHNpZ25hdHVyZVxuICAgICAgdGhpcy5hY2NMaXN0ID0gY2FuY2VsbGVkLmNvbmNhdCh0aGlzLmFjY0xpc3QpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQWRkIHRoZSBrZXkgc2lnbmF0dXJlIHRvIHRoZSBgc3RhdmVgLiBZb3UgcHJvYmFibHkgd2FudCB0byB1c2UgdGhlIFxuICAgIC8vIGhlbHBlciBtZXRob2QgYC5hZGRUb1N0YXZlKClgIGluc3RlYWRcbiAgICBhZGRNb2RpZmllcjogZnVuY3Rpb24oc3RhdmUpIHtcbiAgICAgIHRoaXMuY29udmVydEFjY0xpbmVzKHN0YXZlLmNsZWYsIHRoaXMuYWNjTGlzdFswXS50eXBlKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY2NMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuYWRkQWNjVG9TdGF2ZShzdGF2ZSwgdGhpcy5hY2NMaXN0W2ldLCB0aGlzLmFjY0xpc3RbaSsxXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIEFkZCB0aGUga2V5IHNpZ25hdHVyZSB0byB0aGUgYHN0YXZlYCwgaWYgaXQncyB0aGUgbm90IHRoZSBgZmlyc3RHbHlwaGBcbiAgICAvLyBhIHNwYWNlciB3aWxsIGJlIGFkZGVkIGFzIHdlbGwuXG4gICAgYWRkVG9TdGF2ZTogZnVuY3Rpb24oc3RhdmUsIGZpcnN0R2x5cGgpIHtcbiAgICAgIGlmICh0aGlzLmFjY0xpc3QubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKCFmaXJzdEdseXBoKSB7XG4gICAgICAgIHN0YXZlLmFkZEdseXBoKHRoaXMubWFrZVNwYWNlcih0aGlzLnBhZGRpbmcpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRNb2RpZmllcihzdGF2ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQXBwbHkgdGhlIGFjY2lkZW50YWwgc3RhZmYgbGluZSBwbGFjZW1lbnQgYmFzZWQgb24gdGhlIGBjbGVmYCBhbmRcbiAgICAvLyB0aGUgIGFjY2lkZW50YWwgYHR5cGVgIGZvciB0aGUga2V5IHNpZ25hdHVyZSAoJyMgb3IgJ2InKS5cbiAgICBjb252ZXJ0QWNjTGluZXM6IGZ1bmN0aW9uKGNsZWYsIHR5cGUpIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLjA7IC8vIGlmIGNsZWYgPT09IFwidHJlYmxlXCJcbiAgICAgIHZhciBjdXN0b21MaW5lczsgLy8gd2hlbiBjbGVmIGRvZXNuJ3QgZm9sbG93IHRyZWJsZSBrZXkgc2lnIHNoYXBlXG5cbiAgICAgIHN3aXRjaCAoY2xlZikge1xuICAgICAgICAvLyBUcmVibGUgJiBTdWJiYXNzIGJvdGggaGF2ZSBvZmZzZXRzIG9mIDAsIHNvIGFyZSBub3QgaW5jbHVkZWQuXG4gICAgICAgIGNhc2UgXCJzb3ByYW5vXCI6XG4gICAgICAgICAgaWYodHlwZSA9PT0gXCIjXCIpIGN1c3RvbUxpbmVzID0gWzIuNSwwLjUsMiwwLDEuNSwtMC41LDFdO1xuICAgICAgICAgIGVsc2Ugb2Zmc2V0ID0gLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtZXp6by1zb3ByYW5vXCI6XG4gICAgICAgICAgaWYodHlwZSA9PT0gXCJiXCIpIGN1c3RvbUxpbmVzID0gWzAsMiwwLjUsMi41LDEsMywxLjVdO1xuICAgICAgICAgIGVsc2Ugb2Zmc2V0ID0gMS41O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWx0b1wiOlxuICAgICAgICAgIG9mZnNldCA9IDAuNTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRlbm9yXCI6XG4gICAgICAgICAgaWYodHlwZSA9PT0gXCIjXCIpIGN1c3RvbUxpbmVzID0gWzMsIDEsIDIuNSwgMC41LCAyLCAwLCAxLjVdO1xuICAgICAgICAgIGVsc2Ugb2Zmc2V0ID0gLTAuNTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJhcml0b25lLWZcIjpcbiAgICAgICAgY2FzZSBcImJhcml0b25lLWNcIjpcbiAgICAgICAgICBpZih0eXBlID09PSBcImJcIikgY3VzdG9tTGluZXMgPSBbMC41LDIuNSwxLDMsMS41LDMuNSwyXTtcbiAgICAgICAgICBlbHNlIG9mZnNldCA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJiYXNzXCI6XG4gICAgICAgIGNhc2UgXCJmcmVuY2hcIjpcbiAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIGEgc3BlY2lhbCBjYXNlLCBhc3NpZ24gdGhvc2UgbGluZXMvc3BhY2VzOlxuICAgICAgdmFyIGk7XG4gICAgICBpZiAodHlwZW9mIGN1c3RvbUxpbmVzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmFjY0xpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB0aGlzLmFjY0xpc3RbaV0ubGluZSA9IGN1c3RvbUxpbmVzW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5hY2NMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdGhpcy5hY2NMaXN0W2ldLmxpbmUgKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gS2V5U2lnbmF0dXJlO1xufSgpKTtcbi8vIFZleCBGbG93IE5vdGF0aW9uXG4vLyBJbXBsZW1lbnRzIHRpbWUgc2lnbmF0dXJlcyBnbHlwaHMgZm9yIHN0YWZmc1xuLy8gU2VlIHRhYmxlcy5qcyBmb3IgdGhlIGludGVybmFsIHRpbWUgc2lnbmF0dXJlc1xuLy8gcmVwcmVzZW50YXRpb25cbi8vXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRpbWVTcGVjIHRpbWUgc2lnbmF0dXJlLCBpLmUuIFwiNC80XCJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY3VzdG9tUGFkZGluZ10gY3VzdG9tIHBhZGRpbmcgd2hlbiB1c2luZyBtdWx0aS1zdGF2ZS9tdWx0aS1pbnN0cnVtZW50IHNldHRpbmdcbiAqIHRvIGFsaWduIGtleS90aW1lIHNpZ25hdHVyZSAoaW4gcGl4ZWxzKSwgb3B0aW9uYWxcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5WZXguRmxvdy5UaW1lU2lnbmF0dXJlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUaW1lU2lnbmF0dXJlKHRpbWVTcGVjLCBjdXN0b21QYWRkaW5nKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGltZVNwZWMsIGN1c3RvbVBhZGRpbmcpO1xuICB9XG5cbiAgVGltZVNpZ25hdHVyZS5nbHlwaHMgPSB7XG4gICAgXCJDXCI6IHtcbiAgICAgIGNvZGU6IFwidjQxXCIsXG4gICAgICBwb2ludDogNDAsXG4gICAgICBsaW5lOiAyXG4gICAgfSxcbiAgICBcIkN8XCI6IHtcbiAgICAgIGNvZGU6IFwidmI2XCIsXG4gICAgICBwb2ludDogNDAsXG4gICAgICBsaW5lOiAyXG4gICAgfVxuICB9O1xuXG4gIFZleC5Jbmhlcml0KFRpbWVTaWduYXR1cmUsIFZleC5GbG93LlN0YXZlTW9kaWZpZXIsIHtcbiAgICBpbml0OiBmdW5jdGlvbih0aW1lU3BlYywgY3VzdG9tUGFkZGluZykge1xuICAgICAgVGltZVNpZ25hdHVyZS5zdXBlcmNsYXNzLmluaXQoKTtcbiAgICAgICB2YXIgcGFkZGluZyA9IGN1c3RvbVBhZGRpbmcgfHwgMTU7XG5cbiAgICAgIHRoaXMuc2V0UGFkZGluZyhwYWRkaW5nKTtcbiAgICAgIHRoaXMucG9pbnQgPSA0MDtcbiAgICAgIHRoaXMudG9wTGluZSA9IDI7XG4gICAgICB0aGlzLmJvdHRvbUxpbmUgPSA0O1xuICAgICAgdGhpcy50aW1lU2lnID0gdGhpcy5wYXJzZVRpbWVTcGVjKHRpbWVTcGVjKTtcbiAgICB9LFxuXG4gICAgcGFyc2VUaW1lU3BlYzogZnVuY3Rpb24odGltZVNwZWMpIHtcbiAgICAgIGlmICh0aW1lU3BlYyA9PSBcIkNcIiB8fCB0aW1lU3BlYyA9PSBcIkN8XCIpIHtcbiAgICAgICAgdmFyIGdseXBoSW5mbyA9IFRpbWVTaWduYXR1cmUuZ2x5cGhzW3RpbWVTcGVjXTtcbiAgICAgICAgcmV0dXJuIHtudW06IGZhbHNlLCBsaW5lOiBnbHlwaEluZm8ubGluZSxcbiAgICAgICAgICBnbHlwaDogbmV3IFZleC5GbG93LkdseXBoKGdseXBoSW5mby5jb2RlLCBnbHlwaEluZm8ucG9pbnQpfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvcE51bXMgPSBbXTtcbiAgICAgIHZhciBpLCBjO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRpbWVTcGVjLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGMgPSB0aW1lU3BlYy5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjID09IFwiL1wiKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL1swLTldLy50ZXN0KGMpKSB7XG4gICAgICAgICAgdG9wTnVtcy5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZFRpbWVTaWduYXR1cmVcIixcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIHRpbWUgc3BlYzogXCIgKyB0aW1lU3BlYyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkVGltZVNpZ25hdHVyZVwiLFxuICAgICAgICAgICAgICBcIkludmFsaWQgdGltZSBzcGVjOiBcIiArIHRpbWVTcGVjKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2tpcCB0aGUgXCIvXCJcbiAgICAgICsraTtcblxuICAgICAgaWYgKGkgPT0gdGltZVNwZWMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZFRpbWVTaWduYXR1cmVcIixcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIHRpbWUgc3BlYzogXCIgKyB0aW1lU3BlYyk7XG4gICAgICB9XG5cblxuICAgICAgdmFyIGJvdE51bXMgPSBbXTtcbiAgICAgIGZvciAoOyBpIDwgdGltZVNwZWMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYyA9IHRpbWVTcGVjLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKC9bMC05XS8udGVzdChjKSkge1xuICAgICAgICAgIGJvdE51bXMucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRUaW1lU2lnbmF0dXJlXCIsXG4gICAgICAgICAgICAgIFwiSW52YWxpZCB0aW1lIHNwZWM6IFwiICsgdGltZVNwZWMpO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgcmV0dXJuIHtudW06IHRydWUsIGdseXBoOiB0aGlzLm1ha2VUaW1lU2lnbmF0dXJlR2x5cGgodG9wTnVtcywgYm90TnVtcyl9O1xuICAgIH0sXG5cbiAgICBtYWtlVGltZVNpZ25hdHVyZUdseXBoOiBmdW5jdGlvbih0b3BOdW1zLCBib3ROdW1zKSB7XG4gICAgICB2YXIgZ2x5cGggPSBuZXcgVmV4LkZsb3cuR2x5cGgoXCJ2MFwiLCB0aGlzLnBvaW50KTtcbiAgICAgIGdseXBoW1widG9wR2x5cGhzXCJdID0gW107XG4gICAgICBnbHlwaFtcImJvdEdseXBoc1wiXSA9IFtdO1xuXG4gICAgICB2YXIgdG9wV2lkdGggPSAwO1xuICAgICAgdmFyIGksIG51bTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3BOdW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG51bSA9IHRvcE51bXNbaV07XG4gICAgICAgIHZhciB0b3BHbHlwaCA9IG5ldyBWZXguRmxvdy5HbHlwaChcInZcIiArIG51bSwgdGhpcy5wb2ludCk7XG5cbiAgICAgICAgZ2x5cGgudG9wR2x5cGhzLnB1c2godG9wR2x5cGgpO1xuICAgICAgICB0b3BXaWR0aCArPSB0b3BHbHlwaC5nZXRNZXRyaWNzKCkud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBib3RXaWR0aCA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYm90TnVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBudW0gPSBib3ROdW1zW2ldO1xuICAgICAgICB2YXIgYm90R2x5cGggPSBuZXcgVmV4LkZsb3cuR2x5cGgoXCJ2XCIgKyBudW0sIHRoaXMucG9pbnQpO1xuXG4gICAgICAgIGdseXBoLmJvdEdseXBocy5wdXNoKGJvdEdseXBoKTtcbiAgICAgICAgYm90V2lkdGggKz0gYm90R2x5cGguZ2V0TWV0cmljcygpLndpZHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2lkdGggPSAodG9wV2lkdGggPiBib3RXaWR0aCA/IHRvcFdpZHRoIDogYm90V2lkdGgpO1xuICAgICAgdmFyIHhNaW4gPSBnbHlwaC5nZXRNZXRyaWNzKCkueF9taW47XG5cbiAgICAgIGdseXBoLmdldE1ldHJpY3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4X21pbjogeE1pbixcbiAgICAgICAgICB4X21heDogeE1pbiArIHdpZHRoLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgdmFyIHRvcFN0YXJ0WCA9ICh3aWR0aCAtIHRvcFdpZHRoKSAvIDIuMDtcbiAgICAgIHZhciBib3RTdGFydFggPSAod2lkdGggLSBib3RXaWR0aCkgLyAyLjA7XG5cbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIGdseXBoLnJlbmRlclRvU3RhdmUgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBzdGFydF94ID0geCArIHRvcFN0YXJ0WDtcbiAgICAgICAgdmFyIGksIGc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRvcEdseXBocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGcgPSB0aGlzLnRvcEdseXBoc1tpXTtcbiAgICAgICAgICBWZXguRmxvdy5HbHlwaC5yZW5kZXJPdXRsaW5lKHRoaXMuY29udGV4dCwgZy5tZXRyaWNzLm91dGxpbmUsXG4gICAgICAgICAgICAgIGcuc2NhbGUsIHN0YXJ0X3ggKyBnLnhfc2hpZnQsIHRoaXMuc3RhdmUuZ2V0WUZvckxpbmUodGhhdC50b3BMaW5lKSArIDEpO1xuICAgICAgICAgIHN0YXJ0X3ggKz0gZy5nZXRNZXRyaWNzKCkud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydF94ID0geCArIGJvdFN0YXJ0WDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYm90R2x5cGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgZyA9IHRoaXMuYm90R2x5cGhzW2ldO1xuICAgICAgICAgIHRoYXQucGxhY2VHbHlwaE9uTGluZShnLCB0aGlzLnN0YXZlLCBnLmxpbmUpO1xuICAgICAgICAgIFZleC5GbG93LkdseXBoLnJlbmRlck91dGxpbmUodGhpcy5jb250ZXh0LCBnLm1ldHJpY3Mub3V0bGluZSxcbiAgICAgICAgICAgICAgZy5zY2FsZSwgc3RhcnRfeCArIGcueF9zaGlmdCwgdGhpcy5zdGF2ZS5nZXRZRm9yTGluZSh0aGF0LmJvdHRvbUxpbmUpICsgMSk7XG4gICAgICAgICAgc3RhcnRfeCArPSBnLmdldE1ldHJpY3MoKS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGdseXBoO1xuICAgIH0sXG5cbiAgICBnZXRUaW1lU2lnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbWVTaWc7XG4gICAgfSxcblxuICAgIGFkZE1vZGlmaWVyOiBmdW5jdGlvbihzdGF2ZSkge1xuICAgICAgaWYgKCF0aGlzLnRpbWVTaWcubnVtKSB7XG4gICAgICAgIHRoaXMucGxhY2VHbHlwaE9uTGluZSh0aGlzLnRpbWVTaWcuZ2x5cGgsIHN0YXZlLCB0aGlzLnRpbWVTaWcubGluZSk7XG4gICAgICB9XG4gICAgICBzdGF2ZS5hZGRHbHlwaCh0aGlzLnRpbWVTaWcuZ2x5cGgpO1xuICAgIH0sXG5cbiAgICBhZGRFbmRNb2RpZmllcjogZnVuY3Rpb24oc3RhdmUpIHtcbiAgICAgIGlmICghdGhpcy50aW1lU2lnLm51bSkge1xuICAgICAgICB0aGlzLnBsYWNlR2x5cGhPbkxpbmUodGhpcy50aW1lU2lnLmdseXBoLCBzdGF2ZSwgdGhpcy50aW1lU2lnLmxpbmUpO1xuICAgICAgfVxuICAgICAgc3RhdmUuYWRkRW5kR2x5cGgodGhpcy50aW1lU2lnLmdseXBoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBUaW1lU2lnbmF0dXJlO1xufSgpKTtcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIENoZXBwdWRpcmEgMjAxMy5cbi8vIENvLWF1dGhvcjogQmVuamFtaW4gVy4gQm9obFxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgdmFyaW91cyB0eXBlcyBvZiBjbGVmcyB0aGF0IGNhbiBiZSByZW5kZXJlZCBvbiBhIHN0YXZlLlxuLy9cbi8vIFNlZSBgdGVzdHMvY2xlZl90ZXN0cy5qc2AgZm9yIHVzYWdlIGV4YW1wbGVzLlxuXG5WZXguRmxvdy5DbGVmID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBDbGVmKGNsZWYsIHNpemUsIGFubm90YXRpb24pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChjbGVmLCBzaXplLCBhbm5vdGF0aW9uKTtcbiAgfVxuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLCBzZXQgYFZleC5GbG93LkNsZWYuREVCVUdgIHRvIGB0cnVlYC5cbiAgZnVuY3Rpb24gTCgpIHsgaWYgKFZleC5GbG93LkNsZWYuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuQ2xlZlwiLCBhcmd1bWVudHMpOyB9XG5cbiAgLy8gRXZlcnkgY2xlZiBuYW1lIGlzIGFzc29jaWF0ZWQgd2l0aCBhIGdseXBoIGNvZGUgZnJvbSB0aGUgZm9udCBmaWxlXG4gIC8vIGFuZCBhIGRlZmF1bHQgc3RhdmUgbGluZSBudW1iZXIuXG4gIENsZWYudHlwZXMgPSB7XG4gICAgXCJ0cmVibGVcIjoge1xuICAgICAgY29kZTogXCJ2ODNcIixcbiAgICAgIGxpbmU6IDNcbiAgICB9LFxuICAgIFwiYmFzc1wiOiB7XG4gICAgICBjb2RlOiBcInY3OVwiLFxuICAgICAgbGluZTogMVxuICAgIH0sXG4gICAgXCJhbHRvXCI6IHtcbiAgICAgIGNvZGU6IFwidmFkXCIsXG4gICAgICBsaW5lOiAyXG4gICAgfSxcbiAgICBcInRlbm9yXCI6IHtcbiAgICAgIGNvZGU6IFwidmFkXCIsXG4gICAgICBsaW5lOiAxXG4gICAgfSxcbiAgICBcInBlcmN1c3Npb25cIjoge1xuICAgICAgY29kZTogXCJ2NTlcIixcbiAgICAgIGxpbmU6IDJcbiAgICB9LFxuICAgIFwic29wcmFub1wiOiB7XG4gICAgICBjb2RlOiBcInZhZFwiLFxuICAgICAgbGluZTogNFxuICAgIH0sXG4gICAgXCJtZXp6by1zb3ByYW5vXCI6IHtcbiAgICAgIGNvZGU6IFwidmFkXCIsXG4gICAgICBsaW5lOiAzXG4gICAgfSxcbiAgICBcImJhcml0b25lLWNcIjoge1xuICAgICAgY29kZTogXCJ2YWRcIixcbiAgICAgIGxpbmU6IDBcbiAgICB9LFxuICAgIFwiYmFyaXRvbmUtZlwiOiB7XG4gICAgICBjb2RlOiBcInY3OVwiLFxuICAgICAgbGluZTogMlxuICAgIH0sXG4gICAgXCJzdWJiYXNzXCI6IHtcbiAgICAgIGNvZGU6IFwidjc5XCIsXG4gICAgICBsaW5lOiAwXG4gICAgfSxcbiAgICBcImZyZW5jaFwiOiB7XG4gICAgICBjb2RlOiBcInY4M1wiLFxuICAgICAgbGluZTogNFxuICAgIH0sXG4gIH07XG4gIC8vIFNpemVzIGFmZmVjdCB0aGUgcG9pbnQtc2l6ZSBvZiB0aGUgY2xlZi5cbiAgQ2xlZi5zaXplcyA9IHtcbiAgICBcImRlZmF1bHRcIjogNDAsXG4gICAgXCJzbWFsbFwiOiAzMlxuICB9O1xuXG4gIC8vIEFubm90YXRpb25zIGF0dGFjaCB0byBjbGVmcyAtLSBzdWNoIGFzIFwiOFwiIGZvciBvY3RhdmUgdXAgb3IgZG93bi5cbiAgQ2xlZi5hbm5vdGF0aW9ucyA9IHtcbiAgICBcIjh2YVwiOiB7XG4gICAgICBjb2RlOiBcInY4XCIsXG4gICAgICBzaXplczoge1xuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgIHBvaW50OiAyMCxcbiAgICAgICAgICBhdHRhY2htZW50czoge1xuICAgICAgICAgICAgXCJ0cmVibGVcIjoge1xuICAgICAgICAgICAgICBsaW5lOiAtMS4yLFxuICAgICAgICAgICAgICB4X3NoaWZ0OiAxMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzbWFsbFwiOiB7XG4gICAgICAgICAgcG9pbnQ6IDE4LFxuICAgICAgICAgIGF0dGFjaG1lbnRzOiB7XG4gICAgICAgICAgICBcInRyZWJsZVwiOiB7XG4gICAgICAgICAgICAgIGxpbmU6IC0wLjQsXG4gICAgICAgICAgICAgIHhfc2hpZnQ6IDhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiOHZiXCI6IHtcbiAgICAgIGNvZGU6IFwidjhcIixcbiAgICAgIHNpemVzOiB7XG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgcG9pbnQ6IDIwLFxuICAgICAgICAgIGF0dGFjaG1lbnRzOiB7XG4gICAgICAgICAgICBcInRyZWJsZVwiOiB7XG4gICAgICAgICAgICAgIGxpbmU6IDYuMyxcbiAgICAgICAgICAgICAgeF9zaGlmdDogMTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImJhc3NcIjoge1xuICAgICAgICAgICAgICBsaW5lOiA0LFxuICAgICAgICAgICAgICB4X3NoaWZ0OiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInNtYWxsXCI6IHtcbiAgICAgICAgICBwb2ludDogMTgsXG4gICAgICAgICAgYXR0YWNobWVudHM6IHtcbiAgICAgICAgICAgIFwidHJlYmxlXCI6IHtcbiAgICAgICAgICAgICAgbGluZTogNS44LFxuICAgICAgICAgICAgICB4X3NoaWZ0OiA2XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJiYXNzXCI6IHtcbiAgICAgICAgICAgICAgbGluZTogMy41LFxuICAgICAgICAgICAgICB4X3NoaWZ0OiAwLjVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICB9O1xuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICBWZXguSW5oZXJpdChDbGVmLCBWZXguRmxvdy5TdGF2ZU1vZGlmaWVyLCB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IGNsZWYuIFRoZSBwYXJhbWV0ZXIgYGNsZWZgIG11c3QgYmUgYSBrZXkgZnJvbVxuICAgIC8vIGBDbGVmLnR5cGVzYC5cbiAgICBpbml0OiBmdW5jdGlvbihjbGVmLCBzaXplLCBhbm5vdGF0aW9uKSB7XG4gICAgICB2YXIgc3VwZXJjbGFzcyA9IFZleC5GbG93LkNsZWYuc3VwZXJjbGFzcztcbiAgICAgIHN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLmNsZWYgPSBWZXguRmxvdy5DbGVmLnR5cGVzW2NsZWZdO1xuICAgICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNpemUgPSBcImRlZmF1bHRcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWYucG9pbnQgPSBWZXguRmxvdy5DbGVmLnNpemVzW3RoaXMuc2l6ZV07XG5cbiAgICAgIC8vIElmIGFuIGFubm90YXRpb24sIHN1Y2ggYXMgOHZhLCBpcyBzcGVjaWZpZWQsIGFkZCBpdCB0byB0aGUgQ2xlZiBvYmplY3QuXG4gICAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBhbm5vX2RpY3QgPSBWZXguRmxvdy5DbGVmLmFubm90YXRpb25zW2Fubm90YXRpb25dO1xuICAgICAgICB0aGlzLmFubm90YXRpb24gPSB7XG4gICAgICAgICAgY29kZTogYW5ub19kaWN0LmNvZGUsXG4gICAgICAgICAgcG9pbnQ6IGFubm9fZGljdC5zaXplc1t0aGlzLnNpemVdLnBvaW50LFxuICAgICAgICAgIGxpbmU6IGFubm9fZGljdC5zaXplc1t0aGlzLnNpemVdLmF0dGFjaG1lbnRzW2NsZWZdLmxpbmUsXG4gICAgICAgICAgeF9zaGlmdDogYW5ub19kaWN0LnNpemVzW3RoaXMuc2l6ZV0uYXR0YWNobWVudHNbY2xlZl0ueF9zaGlmdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgTChcIkNyZWF0aW5nIGNsZWY6XCIsIGNsZWYpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgdGhpcyBjbGVmIHRvIHRoZSBzdGFydCBvZiB0aGUgZ2l2ZW4gYHN0YXZlYC5cbiAgICBhZGRNb2RpZmllcjogZnVuY3Rpb24oc3RhdmUpIHtcbiAgICAgIHZhciBnbHlwaCA9IG5ldyBWZXguRmxvdy5HbHlwaCh0aGlzLmNsZWYuY29kZSwgdGhpcy5jbGVmLnBvaW50KTtcbiAgICAgIHRoaXMucGxhY2VHbHlwaE9uTGluZShnbHlwaCwgc3RhdmUsIHRoaXMuY2xlZi5saW5lKTtcbiAgICAgIGlmICh0aGlzLmFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgYXR0YWNobWVudCA9IG5ldyBWZXguRmxvdy5HbHlwaCh0aGlzLmFubm90YXRpb24uY29kZSwgdGhpcy5hbm5vdGF0aW9uLnBvaW50KTtcbiAgICAgICAgYXR0YWNobWVudC5tZXRyaWNzLnhfbWF4ID0gMDtcbiAgICAgICAgYXR0YWNobWVudC5zZXRYU2hpZnQodGhpcy5hbm5vdGF0aW9uLnhfc2hpZnQpO1xuICAgICAgICB0aGlzLnBsYWNlR2x5cGhPbkxpbmUoYXR0YWNobWVudCwgc3RhdmUsIHRoaXMuYW5ub3RhdGlvbi5saW5lKTtcbiAgICAgICAgc3RhdmUuYWRkR2x5cGgoYXR0YWNobWVudCk7XG4gICAgICB9XG4gICAgICBzdGF2ZS5hZGRHbHlwaChnbHlwaCk7XG4gICAgfSxcblxuICAgIC8vIEFkZCB0aGlzIGNsZWYgdG8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYHN0YXZlYC5cbiAgICBhZGRFbmRNb2RpZmllcjogZnVuY3Rpb24oc3RhdmUpIHtcbiAgICAgIHZhciBnbHlwaCA9IG5ldyBWZXguRmxvdy5HbHlwaCh0aGlzLmNsZWYuY29kZSwgdGhpcy5jbGVmLnBvaW50KTtcbiAgICAgIHRoaXMucGxhY2VHbHlwaE9uTGluZShnbHlwaCwgc3RhdmUsIHRoaXMuY2xlZi5saW5lKTtcbiAgICAgIHN0YXZlLmFkZEVuZEdseXBoKGdseXBoKTtcbiAgICAgIGlmICh0aGlzLmFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgYXR0YWNobWVudCA9IG5ldyBWZXguRmxvdy5HbHlwaCh0aGlzLmFubm90YXRpb24uY29kZSwgdGhpcy5hbm5vdGF0aW9uLnBvaW50KTtcbiAgICAgICAgYXR0YWNobWVudC5tZXRyaWNzLnhfbWF4ID0gMDtcbiAgICAgICAgYXR0YWNobWVudC5zZXRYU2hpZnQodGhpcy5hbm5vdGF0aW9uLnhfc2hpZnQpO1xuICAgICAgICB0aGlzLnBsYWNlR2x5cGhPbkxpbmUoYXR0YWNobWVudCwgc3RhdmUsIHRoaXMuYW5ub3RhdGlvbi5saW5lKTtcbiAgICAgICAgc3RhdmUuYWRkRW5kR2x5cGgoYXR0YWNobWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQ2xlZjtcbn0oKSk7XG5cbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBzb21lIHN0YW5kYXJkIG11c2ljIHRoZW9yeSByb3V0aW5lcy5cbi8vXG4vLyByZXF1aXJlczogdmV4LmpzICAgKFZleClcbi8vIHJlcXVpcmVzOiBmbG93LmpzICAoVmV4LkZsb3cpXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblZleC5GbG93Lk11c2ljID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBNdXNpYygpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIE11c2ljLk5VTV9UT05FUyA9IDEyO1xuICBNdXNpYy5yb290cyA9IFsgXCJjXCIsIFwiZFwiLCBcImVcIiwgXCJmXCIsIFwiZ1wiLCBcImFcIiwgXCJiXCIgXTtcbiAgTXVzaWMucm9vdF92YWx1ZXMgPSBbIDAsIDIsIDQsIDUsIDcsIDksIDExIF07XG4gIE11c2ljLnJvb3RfaW5kaWNlcyA9IHtcbiAgICBcImNcIjogMCxcbiAgICBcImRcIjogMSxcbiAgICBcImVcIjogMixcbiAgICBcImZcIjogMyxcbiAgICBcImdcIjogNCxcbiAgICBcImFcIjogNSxcbiAgICBcImJcIjogNlxuICB9O1xuXG4gIE11c2ljLmNhbm9uaWNhbF9ub3RlcyA9IFtcbiAgICBcImNcIiwgXCJjI1wiLCBcImRcIiwgXCJkI1wiLFxuICAgIFwiZVwiLCBcImZcIiwgXCJmI1wiLCBcImdcIixcbiAgICBcImcjXCIsIFwiYVwiLCBcImEjXCIsIFwiYlwiXG4gIF07XG5cbiAgTXVzaWMuZGlhdG9uaWNfaW50ZXJ2YWxzID0gW1xuICAgIFwidW5pc29uXCIsIFwibTJcIiwgXCJNMlwiLCBcIm0zXCIsIFwiTTNcIixcbiAgICBcInA0XCIsIFwiZGltNVwiLCBcInA1XCIsIFwibTZcIiwgXCJNNlwiLFxuICAgIFwiYjdcIiwgXCJNN1wiLCBcIm9jdGF2ZVwiXG4gIF07XG5cbiAgTXVzaWMuZGlhdG9uaWNfYWNjaWRlbnRhbHMgPSB7XG4gICAgXCJ1bmlzb25cIjoge25vdGU6IDAsIGFjY2lkZW50YWw6IDB9LFxuICAgIFwibTJcIjogICAgIHtub3RlOiAxLCBhY2NpZGVudGFsOiAtMX0sXG4gICAgXCJNMlwiOiAgICAge25vdGU6IDEsIGFjY2lkZW50YWw6IDB9LFxuICAgIFwibTNcIjogICAgIHtub3RlOiAyLCBhY2NpZGVudGFsOiAtMX0sXG4gICAgXCJNM1wiOiAgICAge25vdGU6IDIsIGFjY2lkZW50YWw6IDB9LFxuICAgIFwicDRcIjogICAgIHtub3RlOiAzLCBhY2NpZGVudGFsOiAwfSxcbiAgICBcImRpbTVcIjogICB7bm90ZTogNCwgYWNjaWRlbnRhbDogLTF9LFxuICAgIFwicDVcIjogICAgIHtub3RlOiA0LCBhY2NpZGVudGFsOiAwfSxcbiAgICBcIm02XCI6ICAgICB7bm90ZTogNSwgYWNjaWRlbnRhbDogLTF9LFxuICAgIFwiTTZcIjogICAgIHtub3RlOiA1LCBhY2NpZGVudGFsOiAwfSxcbiAgICBcImI3XCI6ICAgICB7bm90ZTogNiwgYWNjaWRlbnRhbDogLTF9LFxuICAgIFwiTTdcIjogICAgIHtub3RlOiA2LCBhY2NpZGVudGFsOiAwfSxcbiAgICBcIm9jdGF2ZVwiOiB7bm90ZTogNywgYWNjaWRlbnRhbDogMH1cbiAgfTtcblxuICBNdXNpYy5pbnRlcnZhbHMgPSB7XG4gICAgXCJ1XCI6ICAwLCBcInVuaXNvblwiOiAwLFxuICAgIFwibTJcIjogMSwgXCJiMlwiOiAxLCBcIm1pbjJcIjogMSwgXCJTXCI6IDEsIFwiSFwiOiAxLFxuICAgIFwiMlwiOiAyLCBcIk0yXCI6IDIsIFwibWFqMlwiOiAyLCBcIlRcIjogMiwgXCJXXCI6IDIsXG4gICAgXCJtM1wiOiAzLCBcImIzXCI6IDMsIFwibWluM1wiOiAzLFxuICAgIFwiTTNcIjogNCwgXCIzXCI6IDQsIFwibWFqM1wiOiA0LFxuICAgIFwiNFwiOiAgNSwgXCJwNFwiOiAgNSxcbiAgICBcIiM0XCI6IDYsIFwiYjVcIjogNiwgXCJhdWc0XCI6IDYsIFwiZGltNVwiOiA2LFxuICAgIFwiNVwiOiAgNywgXCJwNVwiOiAgNyxcbiAgICBcIiM1XCI6IDgsIFwiYjZcIjogOCwgXCJhdWc1XCI6IDgsXG4gICAgXCI2XCI6ICA5LCBcIk02XCI6ICA5LCBcIm1hajZcIjogOSxcbiAgICBcImI3XCI6IDEwLCBcIm03XCI6IDEwLCBcIm1pbjdcIjogMTAsIFwiZG9tN1wiOiAxMCxcbiAgICBcIk03XCI6IDExLCBcIm1hajdcIjogMTEsXG4gICAgXCI4XCI6IDEyLCBcIm9jdGF2ZVwiOiAxMlxuICB9O1xuXG4gIE11c2ljLnNjYWxlcyA9IHtcbiAgICBtYWpvcjogWzIsIDIsIDEsIDIsIDIsIDIsIDFdLFxuICAgIGRvcmlhbjogWzIsIDEsIDIsIDIsIDIsIDEsIDJdLFxuICAgIG1peG9seWRpYW46IFsyLCAyLCAxLCAyLCAyLCAxLCAyXSxcbiAgICBtaW5vcjogWzIsIDEsIDIsIDIsIDEsIDIsIDJdXG4gIH07XG5cbiAgTXVzaWMuYWNjaWRlbnRhbHMgPSBbIFwiYmJcIiwgXCJiXCIsIFwiblwiLCBcIiNcIiwgXCIjI1wiIF07XG5cbiAgTXVzaWMubm90ZVZhbHVlcyA9IHtcbiAgICAnYyc6ICAgeyByb290X2luZGV4OiAwLCBpbnRfdmFsOiAwIH0sXG4gICAgJ2NuJzogIHsgcm9vdF9pbmRleDogMCwgaW50X3ZhbDogMCB9LFxuICAgICdjIyc6ICB7IHJvb3RfaW5kZXg6IDAsIGludF92YWw6IDEgfSxcbiAgICAnYyMjJzogeyByb290X2luZGV4OiAwLCBpbnRfdmFsOiAyIH0sXG4gICAgJ2NiJzogIHsgcm9vdF9pbmRleDogMCwgaW50X3ZhbDogMTEgfSxcbiAgICAnY2JiJzogeyByb290X2luZGV4OiAwLCBpbnRfdmFsOiAxMCB9LFxuICAgICdkJzogICB7IHJvb3RfaW5kZXg6IDEsIGludF92YWw6IDIgfSxcbiAgICAnZG4nOiAgeyByb290X2luZGV4OiAxLCBpbnRfdmFsOiAyIH0sXG4gICAgJ2QjJzogIHsgcm9vdF9pbmRleDogMSwgaW50X3ZhbDogMyB9LFxuICAgICdkIyMnOiB7IHJvb3RfaW5kZXg6IDEsIGludF92YWw6IDQgfSxcbiAgICAnZGInOiAgeyByb290X2luZGV4OiAxLCBpbnRfdmFsOiAxIH0sXG4gICAgJ2RiYic6IHsgcm9vdF9pbmRleDogMSwgaW50X3ZhbDogMCB9LFxuICAgICdlJzogICB7IHJvb3RfaW5kZXg6IDIsIGludF92YWw6IDQgfSxcbiAgICAnZW4nOiAgeyByb290X2luZGV4OiAyLCBpbnRfdmFsOiA0IH0sXG4gICAgJ2UjJzogIHsgcm9vdF9pbmRleDogMiwgaW50X3ZhbDogNSB9LFxuICAgICdlIyMnOiB7IHJvb3RfaW5kZXg6IDIsIGludF92YWw6IDYgfSxcbiAgICAnZWInOiAgeyByb290X2luZGV4OiAyLCBpbnRfdmFsOiAzIH0sXG4gICAgJ2ViYic6IHsgcm9vdF9pbmRleDogMiwgaW50X3ZhbDogMiB9LFxuICAgICdmJzogICB7IHJvb3RfaW5kZXg6IDMsIGludF92YWw6IDUgfSxcbiAgICAnZm4nOiAgeyByb290X2luZGV4OiAzLCBpbnRfdmFsOiA1IH0sXG4gICAgJ2YjJzogIHsgcm9vdF9pbmRleDogMywgaW50X3ZhbDogNiB9LFxuICAgICdmIyMnOiB7IHJvb3RfaW5kZXg6IDMsIGludF92YWw6IDcgfSxcbiAgICAnZmInOiAgeyByb290X2luZGV4OiAzLCBpbnRfdmFsOiA0IH0sXG4gICAgJ2ZiYic6IHsgcm9vdF9pbmRleDogMywgaW50X3ZhbDogMyB9LFxuICAgICdnJzogICB7IHJvb3RfaW5kZXg6IDQsIGludF92YWw6IDcgfSxcbiAgICAnZ24nOiAgeyByb290X2luZGV4OiA0LCBpbnRfdmFsOiA3IH0sXG4gICAgJ2cjJzogIHsgcm9vdF9pbmRleDogNCwgaW50X3ZhbDogOCB9LFxuICAgICdnIyMnOiB7IHJvb3RfaW5kZXg6IDQsIGludF92YWw6IDkgfSxcbiAgICAnZ2InOiAgeyByb290X2luZGV4OiA0LCBpbnRfdmFsOiA2IH0sXG4gICAgJ2diYic6IHsgcm9vdF9pbmRleDogNCwgaW50X3ZhbDogNSB9LFxuICAgICdhJzogICB7IHJvb3RfaW5kZXg6IDUsIGludF92YWw6IDkgfSxcbiAgICAnYW4nOiAgeyByb290X2luZGV4OiA1LCBpbnRfdmFsOiA5IH0sXG4gICAgJ2EjJzogIHsgcm9vdF9pbmRleDogNSwgaW50X3ZhbDogMTAgfSxcbiAgICAnYSMjJzogeyByb290X2luZGV4OiA1LCBpbnRfdmFsOiAxMSB9LFxuICAgICdhYic6ICB7IHJvb3RfaW5kZXg6IDUsIGludF92YWw6IDggfSxcbiAgICAnYWJiJzogeyByb290X2luZGV4OiA1LCBpbnRfdmFsOiA3IH0sXG4gICAgJ2InOiAgIHsgcm9vdF9pbmRleDogNiwgaW50X3ZhbDogMTEgfSxcbiAgICAnYm4nOiAgeyByb290X2luZGV4OiA2LCBpbnRfdmFsOiAxMSB9LFxuICAgICdiIyc6ICB7IHJvb3RfaW5kZXg6IDYsIGludF92YWw6IDAgfSxcbiAgICAnYiMjJzogeyByb290X2luZGV4OiA2LCBpbnRfdmFsOiAxIH0sXG4gICAgJ2JiJzogIHsgcm9vdF9pbmRleDogNiwgaW50X3ZhbDogMTAgfSxcbiAgICAnYmJiJzogeyByb290X2luZGV4OiA2LCBpbnRfdmFsOiA5IH1cbiAgfTtcblxuICBNdXNpYy5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oKSB7fSxcblxuICAgIGlzVmFsaWROb3RlVmFsdWU6IGZ1bmN0aW9uKG5vdGUpIHtcbiAgICAgIGlmIChub3RlID09IG51bGwgfHwgbm90ZSA8IDAgfHwgbm90ZSA+PSBWZXguRmxvdy5NdXNpYy5OVU1fVE9ORVMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBpc1ZhbGlkSW50ZXJ2YWxWYWx1ZTogZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWROb3RlVmFsdWUoaW50ZXJ2YWwpO1xuICAgIH0sXG5cbiAgICBnZXROb3RlUGFydHM6IGZ1bmN0aW9uKG5vdGVTdHJpbmcpIHtcbiAgICAgIGlmICghbm90ZVN0cmluZyB8fCBub3RlU3RyaW5nLmxlbmd0aCA8IDEpXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIkludmFsaWQgbm90ZSBuYW1lOiBcIiArIG5vdGVTdHJpbmcpO1xuXG4gICAgICBpZiAobm90ZVN0cmluZy5sZW5ndGggPiAzKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJJbnZhbGlkIG5vdGUgbmFtZTogXCIgKyBub3RlU3RyaW5nKTtcblxuICAgICAgdmFyIG5vdGUgPSBub3RlU3RyaW5nLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHZhciByZWdleCA9IC9eKFtjZGVmZ2FiXSkoYnxiYnxufCN8IyMpPyQvO1xuICAgICAgdmFyIG1hdGNoID0gcmVnZXguZXhlYyhub3RlKTtcblxuICAgICAgaWYgKG1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBtYXRjaFsxXTtcbiAgICAgICAgdmFyIGFjY2lkZW50YWwgPSBtYXRjaFsyXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICdyb290Jzogcm9vdCxcbiAgICAgICAgICAnYWNjaWRlbnRhbCc6IGFjY2lkZW50YWxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIkludmFsaWQgbm90ZSBuYW1lOiBcIiArIG5vdGVTdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRLZXlQYXJ0czogZnVuY3Rpb24oa2V5U3RyaW5nKSB7XG4gICAgICBpZiAoIWtleVN0cmluZyB8fCBrZXlTdHJpbmcubGVuZ3RoIDwgMSlcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsIFwiSW52YWxpZCBrZXk6IFwiICsga2V5U3RyaW5nKTtcblxuICAgICAgdmFyIGtleSA9IGtleVN0cmluZy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAvLyBTdXBwb3J0IE1ham9yLCBNaW5vciwgTWVsb2RpYyBNaW5vciwgYW5kIEhhcm1vbmljIE1pbm9yIGtleSB0eXBlcy5cbiAgICAgIHZhciByZWdleCA9IC9eKFtjZGVmZ2FiXSkoYnwjKT8obWVsfGhhcm18bXxNKT8kLztcbiAgICAgIHZhciBtYXRjaCA9IHJlZ2V4LmV4ZWMoa2V5KTtcblxuICAgICAgaWYgKG1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBtYXRjaFsxXTtcbiAgICAgICAgdmFyIGFjY2lkZW50YWwgPSBtYXRjaFsyXTtcbiAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFszXTtcblxuICAgICAgICAvLyBVbnNwZWNpZmllZCB0eXBlIGltcGxpZXMgbWFqb3JcbiAgICAgICAgaWYgKCF0eXBlKSB0eXBlID0gXCJNXCI7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAncm9vdCc6IHJvb3QsXG4gICAgICAgICAgJ2FjY2lkZW50YWwnOiBhY2NpZGVudGFsLFxuICAgICAgICAgICd0eXBlJzogdHlwZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsIFwiSW52YWxpZCBrZXk6IFwiICsga2V5U3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Tm90ZVZhbHVlOiBmdW5jdGlvbihub3RlU3RyaW5nKSB7XG4gICAgICB2YXIgdmFsdWUgPSBNdXNpYy5ub3RlVmFsdWVzW25vdGVTdHJpbmddO1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIkludmFsaWQgbm90ZSBuYW1lOiBcIiArIG5vdGVTdHJpbmcpO1xuXG4gICAgICByZXR1cm4gdmFsdWUuaW50X3ZhbDtcbiAgICB9LFxuXG4gICAgZ2V0SW50ZXJ2YWxWYWx1ZTogZnVuY3Rpb24oaW50ZXJ2YWxTdHJpbmcpIHtcbiAgICAgIHZhciB2YWx1ZSA9IE11c2ljLmludGVydmFsc1tpbnRlcnZhbFN0cmluZ107XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcIkludmFsaWQgaW50ZXJ2YWwgbmFtZTogXCIgKyBpbnRlcnZhbFN0cmluZyk7XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0Q2Fub25pY2FsTm90ZU5hbWU6IGZ1bmN0aW9uKG5vdGVWYWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWROb3RlVmFsdWUobm90ZVZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcIkludmFsaWQgbm90ZSB2YWx1ZTogXCIgKyBub3RlVmFsdWUpO1xuXG4gICAgICByZXR1cm4gTXVzaWMuY2Fub25pY2FsX25vdGVzW25vdGVWYWx1ZV07XG4gICAgfSxcblxuICAgIGdldENhbm9uaWNhbEludGVydmFsTmFtZTogZnVuY3Rpb24oaW50ZXJ2YWxWYWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRJbnRlcnZhbFZhbHVlKGludGVydmFsVmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSW52YWxpZCBpbnRlcnZhbCB2YWx1ZTogXCIgKyBpbnRlcnZhbFZhbHVlKTtcblxuICAgICAgcmV0dXJuIE11c2ljLmRpYXRvbmljX2ludGVydmFsc1tpbnRlcnZhbFZhbHVlXTtcbiAgICB9LFxuXG4gICAgLyogR2l2ZW4gYSBub3RlLCBpbnRlcnZhbCwgYW5kIGludGVydmFsIGRpcmVjdGlvbiwgcHJvZHVjdCB0aGVcbiAgICAgKiByZWxhdGl2ZSBub3RlLlxuICAgICAqL1xuICAgIGdldFJlbGF0aXZlTm90ZVZhbHVlOiBmdW5jdGlvbihub3RlVmFsdWUsIGludGVydmFsVmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PSBudWxsKSBkaXJlY3Rpb24gPSAxO1xuICAgICAgaWYgKGRpcmVjdGlvbiAhPSAxICYmIGRpcmVjdGlvbiAhPSAtMSlcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsIFwiSW52YWxpZCBkaXJlY3Rpb246IFwiICsgZGlyZWN0aW9uKTtcblxuICAgICAgdmFyIHN1bSA9IChub3RlVmFsdWUgKyAoZGlyZWN0aW9uICogaW50ZXJ2YWxWYWx1ZSkpICUgTXVzaWMuTlVNX1RPTkVTO1xuICAgICAgaWYgKHN1bSA8IDApIHN1bSArPSBNdXNpYy5OVU1fVE9ORVM7XG5cbiAgICAgIHJldHVybiBzdW07XG4gICAgfSxcblxuICAgIGdldFJlbGF0aXZlTm90ZU5hbWU6IGZ1bmN0aW9uKHJvb3QsIG5vdGVWYWx1ZSkge1xuICAgICAgdmFyIHBhcnRzID0gdGhpcy5nZXROb3RlUGFydHMocm9vdCk7XG4gICAgICB2YXIgcm9vdFZhbHVlID0gdGhpcy5nZXROb3RlVmFsdWUocGFydHMucm9vdCk7XG4gICAgICB2YXIgaW50ZXJ2YWwgPSBub3RlVmFsdWUgLSByb290VmFsdWU7XG5cbiAgICAgIGlmIChNYXRoLmFicyhpbnRlcnZhbCkgPiBNdXNpYy5OVU1fVE9ORVMgLSAzKSB7XG4gICAgICAgIHZhciBtdWx0aXBsaWVyID0gMTtcbiAgICAgICAgaWYgKGludGVydmFsID4gMCApIG11bHRpcGxpZXIgPSAtMTtcblxuICAgICAgICAvLyBQb3NzaWJseSB3cmFwIGFyb3VuZC4gKEFkZCArMSBmb3IgbW9kdWxvIG9wZXJhdG9yKVxuICAgICAgICB2YXIgcmV2ZXJzZV9pbnRlcnZhbCA9ICgoKG5vdGVWYWx1ZSArIDEpICsgKHJvb3RWYWx1ZSArIDEpKSAlXG4gICAgICAgICAgTXVzaWMuTlVNX1RPTkVTKSAqIG11bHRpcGxpZXI7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHJldmVyc2VfaW50ZXJ2YWwpID4gMikge1xuICAgICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIk5vdGVzIG5vdCByZWxhdGVkOiBcIiArIHJvb3QgKyBcIiwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJ2YWwgPSByZXZlcnNlX2ludGVydmFsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChNYXRoLmFicyhpbnRlcnZhbCkgPiAyKVxuICAgICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIk5vdGVzIG5vdCByZWxhdGVkOiBcIiArIHJvb3QgKyBcIiwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVWYWx1ZSk7XG5cbiAgICAgIHZhciByZWxhdGl2ZU5vdGVOYW1lID0gcGFydHMucm9vdDtcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKGludGVydmFsID4gMCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGludGVydmFsOyArK2kpXG4gICAgICAgICAgcmVsYXRpdmVOb3RlTmFtZSArPSBcIiNcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJ2YWwgPCAwKSB7XG4gICAgICAgIGZvciAoaSA9IC0xOyBpID49IGludGVydmFsOyAtLWkpXG4gICAgICAgICAgcmVsYXRpdmVOb3RlTmFtZSArPSBcImJcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbGF0aXZlTm90ZU5hbWU7XG4gICAgfSxcblxuICAgIC8qIFJldHVybiBzY2FsZSB0b25lcywgZ2l2ZW4gaW50ZXJ2YWxzLiBFYWNoIHN1Y2Nlc3NpdmUgaW50ZXJ2YWwgaXNcbiAgICAgKiByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLCBlLmcuLCBNYWpvciBTY2FsZTpcbiAgICAgKlxuICAgICAqICAgVFRTVFRUUyA9IFsyLDIsMSwyLDIsMiwxXVxuICAgICAqXG4gICAgICogV2hlbiB1c2VkIHdpdGgga2V5ID0gMCwgcmV0dXJucyBDIHNjYWxlICh3aGljaCBpcyBpc29tb3JwaGljIHRvXG4gICAgICogaW50ZXJ2YWwgbGlzdCkuXG4gICAgICovXG4gICAgZ2V0U2NhbGVUb25lczogZnVuY3Rpb24oa2V5LCBpbnRlcnZhbHMpIHtcbiAgICAgIHZhciB0b25lcyA9IFtdO1xuICAgICAgdG9uZXMucHVzaChrZXkpO1xuXG4gICAgICB2YXIgbmV4dE5vdGUgPSBrZXk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVydmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICBuZXh0Tm90ZSA9IHRoaXMuZ2V0UmVsYXRpdmVOb3RlVmFsdWUobmV4dE5vdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbHNbaV0pO1xuICAgICAgICBpZiAobmV4dE5vdGUgIT0ga2V5KSB0b25lcy5wdXNoKG5leHROb3RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvbmVzO1xuICAgIH0sXG5cbiAgICAvKiBSZXR1cm5zIHRoZSBpbnRlcnZhbCBvZiBhIG5vdGUsIGdpdmVuIGEgZGlhdG9uaWMgc2NhbGUuXG4gICAgICpcbiAgICAgKiBFLmcuLCBHaXZlbiB0aGUgc2NhbGUgQywgYW5kIHRoZSBub3RlIEUsIHJldHVybnMgTTNcbiAgICAgKi9cbiAgICBnZXRJbnRlcnZhbEJldHdlZW46IGZ1bmN0aW9uKG5vdGUxLCBub3RlMiwgZGlyZWN0aW9uKSB7XG4gICAgICBpZiAoZGlyZWN0aW9uID09IG51bGwpIGRpcmVjdGlvbiA9IDE7XG4gICAgICBpZiAoZGlyZWN0aW9uICE9IDEgJiYgZGlyZWN0aW9uICE9IC0xKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJJbnZhbGlkIGRpcmVjdGlvbjogXCIgKyBkaXJlY3Rpb24pO1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWROb3RlVmFsdWUobm90ZTEpIHx8ICF0aGlzLmlzVmFsaWROb3RlVmFsdWUobm90ZTIpKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSW52YWxpZCBub3RlczogXCIgKyBub3RlMSArIFwiLCBcIiArIG5vdGUyKTtcblxuICAgICAgdmFyIGRpZmZlcmVuY2U7XG4gICAgICBpZiAoZGlyZWN0aW9uID09IDEpXG4gICAgICAgIGRpZmZlcmVuY2UgPSBub3RlMiAtIG5vdGUxO1xuICAgICAgZWxzZVxuICAgICAgICBkaWZmZXJlbmNlID0gbm90ZTEgLSBub3RlMjtcblxuICAgICAgaWYgKGRpZmZlcmVuY2UgPCAwKSBkaWZmZXJlbmNlICs9IE11c2ljLk5VTV9UT05FUztcbiAgICAgIHJldHVybiBkaWZmZXJlbmNlO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBzY2FsZSBtYXAgdGhhdCByZXByZXNlbnRzIHRoZSBwaXRjaCBzdGF0ZSBmb3IgYVxuICAgIC8vIGBrZXlTaWduYXR1cmVgLiBGb3IgZXhhbXBsZSwgcGFzc2luZyBhIGBHYCB0byBga2V5U2lnbmF0dXJlYCB3b3VsZCBcbiAgICAvLyByZXR1cm4gYSBzY2FsZSBtYXAgd2l0aCBldmVyeSBub3RlIG5hdHVyYWxpemVkIGV4Y2VwdCBmb3IgYEZgIHdoaWNoXG4gICAgLy8gaGFzIGFuIGBGI2Agc3RhdGUuXG4gICAgY3JlYXRlU2NhbGVNYXA6IGZ1bmN0aW9uKGtleVNpZ25hdHVyZSkge1xuICAgICAgdmFyIGtleVNpZ1BhcnRzID0gdGhpcy5nZXRLZXlQYXJ0cyhrZXlTaWduYXR1cmUpO1xuICAgICAgdmFyIHNjYWxlTmFtZSA9IFZleC5GbG93LktleU1hbmFnZXIuc2NhbGVzW2tleVNpZ1BhcnRzLnR5cGVdO1xuXG4gICAgICB2YXIga2V5U2lnU3RyaW5nID0ga2V5U2lnUGFydHMucm9vdDtcbiAgICAgIGlmIChrZXlTaWdQYXJ0cy5hY2NpZGVudGFsKSBrZXlTaWdTdHJpbmcgKz0ga2V5U2lnUGFydHMuYWNjaWRlbnRhbDtcblxuICAgICAgaWYgKCFzY2FsZU5hbWUpIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIlVuc3VwcG9ydGVkIGtleSB0eXBlOiBcIiArIGtleVNpZ25hdHVyZSk7XG5cbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0U2NhbGVUb25lcyh0aGlzLmdldE5vdGVWYWx1ZShrZXlTaWdTdHJpbmcpLCBzY2FsZU5hbWUpO1xuICAgICAgdmFyIG5vdGVMb2NhdGlvbiA9IFZleC5GbG93Lk11c2ljLnJvb3RfaW5kaWNlc1trZXlTaWdQYXJ0cy5yb290XTtcblxuICAgICAgdmFyIHNjYWxlTWFwID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFZleC5GbG93Lk11c2ljLnJvb3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBpbmRleCA9IChub3RlTG9jYXRpb24gKyBpKSAlIFZleC5GbG93Lk11c2ljLnJvb3RzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJvb3ROYW1lID0gVmV4LkZsb3cuTXVzaWMucm9vdHNbaW5kZXhdO1xuICAgICAgICB2YXIgbm90ZU5hbWUgPSB0aGlzLmdldFJlbGF0aXZlTm90ZU5hbWUocm9vdE5hbWUsIHNjYWxlW2ldKTtcblxuICAgICAgICBpZiAobm90ZU5hbWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbm90ZU5hbWUgKz0gXCJuXCI7XG4gICAgICAgIH1cblxuICAgICAgICBzY2FsZU1hcFtyb290TmFtZV0gPSBub3RlTmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjYWxlTWFwO1xuICAgIH1cblxuICB9O1xuXG4gIHJldHVybiBNdXNpYztcbn0oKSk7XG5cbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBkaWF0b25pYyBrZXkgbWFuYWdlbWVudC5cbi8vXG4vLyByZXF1aXJlczogdmV4LmpzICAgKFZleClcbi8vIHJlcXVpcmVzOiBmbG93LmpzICAoVmV4LkZsb3cpXG4vLyByZXF1aXJlczogbXVzaWMuanMgKFZleC5GbG93Lk11c2ljKVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5WZXguRmxvdy5LZXlNYW5hZ2VyID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBLZXlNYW5hZ2VyKGtleSkge1xuICAgIHRoaXMuaW5pdChrZXkpO1xuICB9XG5cbiAgS2V5TWFuYWdlci5zY2FsZXMgPSB7XG4gICAgXCJNXCI6IFZleC5GbG93Lk11c2ljLnNjYWxlcy5tYWpvcixcbiAgICBcIm1cIjogVmV4LkZsb3cuTXVzaWMuc2NhbGVzLm1pbm9yXG4gIH07XG5cbiAgS2V5TWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB0aGlzLm11c2ljID0gbmV3IFZleC5GbG93Lk11c2ljKCk7XG4gICAgICB0aGlzLnNldEtleShrZXkpO1xuICAgIH0sXG5cbiAgICBzZXRLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0S2V5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMua2V5OyB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5rZXlQYXJ0cyA9IHRoaXMubXVzaWMuZ2V0S2V5UGFydHModGhpcy5rZXkpO1xuXG4gICAgICB0aGlzLmtleVN0cmluZyA9IHRoaXMua2V5UGFydHMucm9vdDtcbiAgICAgIGlmICh0aGlzLmtleVBhcnRzLmFjY2lkZW50YWwpIHRoaXMua2V5U3RyaW5nICs9IHRoaXMua2V5UGFydHMuYWNjaWRlbnRhbDtcblxuICAgICAgdmFyIGlzX3N1cHBvcnRlZF90eXBlID0gS2V5TWFuYWdlci5zY2FsZXNbdGhpcy5rZXlQYXJ0cy50eXBlXTtcbiAgICAgIGlmICghaXNfc3VwcG9ydGVkX3R5cGUpXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIlVuc3VwcG9ydGVkIGtleSB0eXBlOiBcIiArIHRoaXMua2V5KTtcblxuICAgICAgdGhpcy5zY2FsZSA9IHRoaXMubXVzaWMuZ2V0U2NhbGVUb25lcyhcbiAgICAgICAgICB0aGlzLm11c2ljLmdldE5vdGVWYWx1ZSh0aGlzLmtleVN0cmluZyksXG4gICAgICAgICAgVmV4LkZsb3cuS2V5TWFuYWdlci5zY2FsZXNbdGhpcy5rZXlQYXJ0cy50eXBlXSk7XG5cbiAgICAgIHRoaXMuc2NhbGVNYXAgPSB7fTtcbiAgICAgIHRoaXMuc2NhbGVNYXBCeVZhbHVlID0ge307XG4gICAgICB0aGlzLm9yaWdpbmFsU2NhbGVNYXBCeVZhbHVlID0ge307XG5cbiAgICAgIHZhciBub3RlTG9jYXRpb24gPSBWZXguRmxvdy5NdXNpYy5yb290X2luZGljZXNbdGhpcy5rZXlQYXJ0cy5yb290XTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWZXguRmxvdy5NdXNpYy5yb290cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgaW5kZXggPSAobm90ZUxvY2F0aW9uICsgaSkgJSBWZXguRmxvdy5NdXNpYy5yb290cy5sZW5ndGg7XG4gICAgICAgIHZhciByb290TmFtZSA9IFZleC5GbG93Lk11c2ljLnJvb3RzW2luZGV4XTtcblxuICAgICAgICB2YXIgbm90ZU5hbWUgPSB0aGlzLm11c2ljLmdldFJlbGF0aXZlTm90ZU5hbWUocm9vdE5hbWUsIHRoaXMuc2NhbGVbaV0pO1xuICAgICAgICB0aGlzLnNjYWxlTWFwW3Jvb3ROYW1lXSA9IG5vdGVOYW1lO1xuICAgICAgICB0aGlzLnNjYWxlTWFwQnlWYWx1ZVt0aGlzLnNjYWxlW2ldXSA9IG5vdGVOYW1lO1xuICAgICAgICB0aGlzLm9yaWdpbmFsU2NhbGVNYXBCeVZhbHVlW3RoaXMuc2NhbGVbaV1dID0gbm90ZU5hbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRBY2NpZGVudGFsOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciByb290ID0gdGhpcy5tdXNpYy5nZXRLZXlQYXJ0cyhrZXkpLnJvb3Q7XG4gICAgICB2YXIgcGFydHMgPSB0aGlzLm11c2ljLmdldE5vdGVQYXJ0cyh0aGlzLnNjYWxlTWFwW3Jvb3RdKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm90ZTogdGhpcy5zY2FsZU1hcFtyb290XSxcbiAgICAgICAgYWNjaWRlbnRhbDogcGFydHMuYWNjaWRlbnRhbFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2VsZWN0Tm90ZTogZnVuY3Rpb24obm90ZSkge1xuICAgICAgbm90ZSA9IG5vdGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwYXJ0cyA9IHRoaXMubXVzaWMuZ2V0Tm90ZVBhcnRzKG5vdGUpO1xuXG4gICAgICAvLyBGaXJzdCBsb29rIGZvciBtYXRjaGluZyBub3RlIGluIG91ciBhbHRlcmVkIHNjYWxlXG4gICAgICB2YXIgc2NhbGVOb3RlID0gdGhpcy5zY2FsZU1hcFtwYXJ0cy5yb290XTtcbiAgICAgIHZhciBtb2RwYXJ0cyA9IHRoaXMubXVzaWMuZ2V0Tm90ZVBhcnRzKHNjYWxlTm90ZSk7XG5cbiAgICAgIGlmIChzY2FsZU5vdGUgPT0gbm90ZSkgcmV0dXJuIHtcbiAgICAgICAgXCJub3RlXCI6IHNjYWxlTm90ZSxcbiAgICAgICAgXCJhY2NpZGVudGFsXCI6IHBhcnRzLmFjY2lkZW50YWwsXG4gICAgICAgIFwiY2hhbmdlXCI6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICAvLyBUaGVuIHNlYXJjaCBmb3IgYSBub3RlIG9mIGVxdWl2YWxlbnQgdmFsdWUgaW4gb3VyIGFsdGVyZWQgc2NhbGVcbiAgICAgIHZhciB2YWx1ZU5vdGUgPSB0aGlzLnNjYWxlTWFwQnlWYWx1ZVt0aGlzLm11c2ljLmdldE5vdGVWYWx1ZShub3RlKV07XG4gICAgICBpZiAodmFsdWVOb3RlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBcIm5vdGVcIjogdmFsdWVOb3RlLFxuICAgICAgICAgIFwiYWNjaWRlbnRhbFwiOiB0aGlzLm11c2ljLmdldE5vdGVQYXJ0cyh2YWx1ZU5vdGUpLmFjY2lkZW50YWwsXG4gICAgICAgICAgXCJjaGFuZ2VcIjogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlbiBzZWFyY2ggZm9yIGEgbm90ZSBvZiBlcXVpdmFsZW50IHZhbHVlIGluIHRoZSBvcmlnaW5hbCBzY2FsZVxuICAgICAgdmFyIG9yaWdpbmFsVmFsdWVOb3RlID0gdGhpcy5vcmlnaW5hbFNjYWxlTWFwQnlWYWx1ZVtcbiAgICAgICAgdGhpcy5tdXNpYy5nZXROb3RlVmFsdWUobm90ZSldO1xuICAgICAgaWYgKG9yaWdpbmFsVmFsdWVOb3RlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zY2FsZU1hcFttb2RwYXJ0cy5yb290XSA9IG9yaWdpbmFsVmFsdWVOb3RlO1xuICAgICAgICBkZWxldGUgdGhpcy5zY2FsZU1hcEJ5VmFsdWVbdGhpcy5tdXNpYy5nZXROb3RlVmFsdWUoc2NhbGVOb3RlKV07XG4gICAgICAgIHRoaXMuc2NhbGVNYXBCeVZhbHVlW3RoaXMubXVzaWMuZ2V0Tm90ZVZhbHVlKG5vdGUpXSA9IG9yaWdpbmFsVmFsdWVOb3RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFwibm90ZVwiOiBvcmlnaW5hbFZhbHVlTm90ZSxcbiAgICAgICAgICBcImFjY2lkZW50YWxcIjogdGhpcy5tdXNpYy5nZXROb3RlUGFydHMob3JpZ2luYWxWYWx1ZU5vdGUpLmFjY2lkZW50YWwsXG4gICAgICAgICAgXCJjaGFuZ2VcIjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBUaGVuIHRyeSB0byB1bm1vZGlmeSBhIGN1cnJlbnRseSBtb2RpZmllZCBub3RlLlxuICAgICAgaWYgKG1vZHBhcnRzLnJvb3QgPT0gbm90ZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5zY2FsZU1hcEJ5VmFsdWVbXG4gICAgICAgICAgdGhpcy5tdXNpYy5nZXROb3RlVmFsdWUodGhpcy5zY2FsZU1hcFtwYXJ0cy5yb290XSldO1xuICAgICAgICB0aGlzLnNjYWxlTWFwQnlWYWx1ZVt0aGlzLm11c2ljLmdldE5vdGVWYWx1ZShtb2RwYXJ0cy5yb290KV0gPVxuICAgICAgICAgIG1vZHBhcnRzLnJvb3Q7XG4gICAgICAgIHRoaXMuc2NhbGVNYXBbbW9kcGFydHMucm9vdF0gPSBtb2RwYXJ0cy5yb290O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFwibm90ZVwiOiBtb2RwYXJ0cy5yb290LFxuICAgICAgICAgIFwiYWNjaWRlbnRhbFwiOiBudWxsLFxuICAgICAgICAgIFwiY2hhbmdlXCI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gTGFzdCByZXNvcnQgLS0gc2hpdHNob290XG4gICAgICBkZWxldGUgdGhpcy5zY2FsZU1hcEJ5VmFsdWVbXG4gICAgICAgIHRoaXMubXVzaWMuZ2V0Tm90ZVZhbHVlKHRoaXMuc2NhbGVNYXBbcGFydHMucm9vdF0pXTtcbiAgICAgIHRoaXMuc2NhbGVNYXBCeVZhbHVlW3RoaXMubXVzaWMuZ2V0Tm90ZVZhbHVlKG5vdGUpXSA9IG5vdGU7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLnNjYWxlTWFwW21vZHBhcnRzLnJvb3RdO1xuICAgICAgdGhpcy5zY2FsZU1hcFttb2RwYXJ0cy5yb290XSA9IG5vdGU7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFwibm90ZVwiOiBub3RlLFxuICAgICAgICBcImFjY2lkZW50YWxcIjogcGFydHMuYWNjaWRlbnRhbCxcbiAgICAgICAgXCJjaGFuZ2VcIjogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEtleU1hbmFnZXI7XG59KCkpO1xuXG4vLyBWZXggRmxvd1xuLy8gTW9oaXQgTXV0aGFubmEgPG1vaGl0QG11dGhhbm5hLmNvbT5cbi8vXG4vLyBTdXBwb3J0IGZvciBkaWZmZXJlbnQgcmVuZGVyaW5nIGNvbnRleHRzOiBDYW52YXMsIFJhcGhhZWxcbi8vXG4vLyBDb3B5cmlnaHQgTW9oaXQgQ2hlcHB1ZGlyYSAyMDEwXG5cbi8qIGdsb2JhbCBkb2N1bWVudDogZmFsc2UgKi9cblxuVmV4LkZsb3cuUmVuZGVyZXIgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFJlbmRlcmVyKHNlbCwgYmFja2VuZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHNlbCwgYmFja2VuZCk7XG4gIH1cblxuICBSZW5kZXJlci5CYWNrZW5kcyA9IHtcbiAgICBDQU5WQVM6IDEsXG4gICAgUkFQSEFFTDogMixcbiAgICBTVkc6IDMsXG4gICAgVk1MOiA0XG4gIH07XG5cbiAgLy9FbmQgb2YgbGluZSB0eXBlc1xuICBSZW5kZXJlci5MaW5lRW5kVHlwZSA9IHtcbiAgICAgIE5PTkU6IDEsICAgICAgICAvLyBObyBsZWdcbiAgICAgIFVQOiAyLCAgICAgICAgICAvLyBVcHdhcmQgbGVnXG4gICAgICBET1dOOiAzICAgICAgICAgLy8gRG93bndhcmQgbGVnXG4gIH07XG5cbiAgLy8gU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3UncmUgdXNpbmcgVmV4RmxvdyBpbnNpZGUgYSBydW50aW1lXG4gIC8vIHRoYXQgZG9lcyBub3QgYWxsb3cgbW9kaWZpeWluZyBjYW52YXMgb2JqZWN0cy4gVGhlcmUgaXMgYSBzbWFsbFxuICAvLyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbiBkdWUgdG8gdGhlIGV4dHJhIGluZGlyZWN0aW9uLlxuICBSZW5kZXJlci5VU0VfQ0FOVkFTX1BST1hZID0gZmFsc2U7XG4gIFJlbmRlcmVyLmxhc3RDb250ZXh0ID0gbnVsbDtcblxuICBSZW5kZXJlci5idWlsZENvbnRleHQgPSBmdW5jdGlvbihzZWwsXG4gICAgICBiYWNrZW5kLCB3aWR0aCwgaGVpZ2h0LCBiYWNrZ3JvdW5kKSB7XG5cbiAgICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoc2VsLCBiYWNrZW5kKTtcbiAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7IHJlbmRlcmVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTsgfVxuXG4gICAgaWYgKCFiYWNrZ3JvdW5kKSBiYWNrZ3JvdW5kID0gXCIjRkZGXCI7XG4gICAgdmFyIGN0eCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcbiAgICBjdHguc2V0QmFja2dyb3VuZEZpbGxTdHlsZShiYWNrZ3JvdW5kKTtcbiAgICBSZW5kZXJlci5sYXN0Q29udGV4dCA9IGN0eDtcbiAgICByZXR1cm4gY3R4O1xuICB9O1xuXG4gIFJlbmRlcmVyLmdldENhbnZhc0NvbnRleHQgPSBmdW5jdGlvbihzZWwsIHdpZHRoLCBoZWlnaHQsIGJhY2tncm91bmQpIHtcbiAgICByZXR1cm4gUmVuZGVyZXIuYnVpbGRDb250ZXh0KHNlbCwgUmVuZGVyZXIuQmFja2VuZHMuQ0FOVkFTLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LCBiYWNrZ3JvdW5kKTtcbiAgfTtcblxuICBSZW5kZXJlci5nZXRSYXBoYWVsQ29udGV4dCA9IGZ1bmN0aW9uKHNlbCwgd2lkdGgsIGhlaWdodCwgYmFja2dyb3VuZCkge1xuICAgIHJldHVybiBSZW5kZXJlci5idWlsZENvbnRleHQoc2VsLCBSZW5kZXJlci5CYWNrZW5kcy5SQVBIQUVMLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LCBiYWNrZ3JvdW5kKTtcbiAgfTtcblxuICBSZW5kZXJlci5nZXRTVkdDb250ZXh0ID0gZnVuY3Rpb24oc2VsLCB3aWR0aCwgaGVpZ2h0LCBiYWNrZ3JvdW5kKSB7XG4gICAgcmV0dXJuIFJlbmRlcmVyLmJ1aWxkQ29udGV4dChzZWwsIFJlbmRlcmVyLkJhY2tlbmRzLlNWRyxcbiAgICAgICAgd2lkdGgsIGhlaWdodCwgYmFja2dyb3VuZCk7XG4gIH07XG5cblxuICBSZW5kZXJlci5ib2xzdGVyQ2FudmFzQ29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIGlmIChSZW5kZXJlci5VU0VfQ0FOVkFTX1BST1hZKSB7XG4gICAgICByZXR1cm4gbmV3IFZleC5GbG93LkNhbnZhc0NvbnRleHQoY3R4KTtcbiAgICB9XG5cbiAgICB2YXIgbWV0aG9kcyA9IFtcImNsZWFyXCIsIFwic2V0Rm9udFwiLCBcInNldFJhd0ZvbnRcIiwgXCJzZXRGaWxsU3R5bGVcIiwgXCJzZXRCYWNrZ3JvdW5kRmlsbFN0eWxlXCIsXG4gICAgICAgICAgICAgICAgICAgXCJzZXRTdHJva2VTdHlsZVwiLCBcInNldFNoYWRvd0NvbG9yXCIsIFwic2V0U2hhZG93Qmx1clwiLCBcInNldExpbmVXaWR0aFwiLFxuICAgICAgICAgICAgICAgICAgIFwic2V0TGluZUNhcFwiLCBcInNldExpbmVEYXNoXCIsIFwib3Blbkdyb3VwXCIsIFwiY2xvc2VHcm91cFwiLCBcImdldEdyb3VwXCJdO1xuICAgIGN0eC52ZXhGbG93Q2FudmFzQ29udGV4dCA9IGN0eDtcblxuICAgIGZvciAodmFyIGkgaW4gbWV0aG9kcykge1xuICAgICAgdmFyIG1ldGhvZCA9IG1ldGhvZHNbaV07XG4gICAgICBjdHhbbWV0aG9kXSA9IFZleC5GbG93LkNhbnZhc0NvbnRleHQucHJvdG90eXBlW21ldGhvZF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN0eDtcbiAgfTtcblxuICAvL0RyYXcgYSBkYXNoZWQgbGluZSAoaG9yaXpvbnRhbCwgdmVydGljYWwgb3IgZGlhZ29uYWxcbiAgLy9kYXNoUGF0dGVybiA9IFszLDNdIGRyYXdzIGEgMyBwaXhlbCBkYXNoIGZvbGxvd2VkIGJ5IGEgdGhyZWUgcGl4ZWwgc3BhY2UuXG4gIC8vc2V0dGluZyB0aGUgc2Vjb25kIG51bWJlciB0byAwIGRyYXdzIGEgc29saWQgbGluZS5cbiAgUmVuZGVyZXIuZHJhd0Rhc2hlZExpbmUgPSBmdW5jdGlvbihjb250ZXh0LCBmcm9tWCwgZnJvbVksIHRvWCwgdG9ZLCBkYXNoUGF0dGVybikge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICB2YXIgZHggPSB0b1ggLSBmcm9tWDtcbiAgICB2YXIgZHkgPSB0b1kgLSBmcm9tWTtcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgdmFyIHggPSBmcm9tWDtcbiAgICB2YXIgeSA9IGZyb21ZO1xuICAgIGNvbnRleHQubW92ZVRvKGZyb21YLCBmcm9tWSk7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGRyYXcgPSB0cnVlO1xuICAgIHdoaWxlICghKChkeCA8IDAgPyB4IDw9IHRvWCA6IHggPj0gdG9YKSAmJiAoZHkgPCAwID8geSA8PSB0b1kgOiB5ID49IHRvWSkpKSB7XG4gICAgICB2YXIgZGFzaExlbmd0aCA9IGRhc2hQYXR0ZXJuW2lkeCsrICUgZGFzaFBhdHRlcm4ubGVuZ3RoXTtcbiAgICAgIHZhciBueCA9IHggKyAoTWF0aC5jb3MoYW5nbGUpICogZGFzaExlbmd0aCk7XG4gICAgICB4ID0gZHggPCAwID8gTWF0aC5tYXgodG9YLCBueCkgOiBNYXRoLm1pbih0b1gsIG54KTtcbiAgICAgIHZhciBueSA9IHkgKyAoTWF0aC5zaW4oYW5nbGUpICogZGFzaExlbmd0aCk7XG4gICAgICB5ID0gZHkgPCAwID8gTWF0aC5tYXgodG9ZLCBueSkgOiBNYXRoLm1pbih0b1ksIG55KTtcbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICB9XG4gICAgICAgIGRyYXcgPSAhZHJhdztcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH07XG5cbiAgUmVuZGVyZXIucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKHNlbCwgYmFja2VuZCkge1xuICAgICAgLy8gVmVyaWZ5IHNlbGVjdG9yXG4gICAgICB0aGlzLnNlbCA9IHNlbDtcbiAgICAgIGlmICghdGhpcy5zZWwpIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50XCIsXG4gICAgICAgICAgXCJJbnZhbGlkIHNlbGVjdG9yIGZvciByZW5kZXJlci5cIik7XG5cbiAgICAgIC8vIEdldCBlbGVtZW50IGZyb20gc2VsZWN0b3JcbiAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbCk7XG4gICAgICBpZiAoIXRoaXMuZWxlbWVudCkgdGhpcy5lbGVtZW50ID0gc2VsO1xuXG4gICAgICAvLyBWZXJpZnkgYmFja2VuZCBhbmQgY3JlYXRlIGNvbnRleHRcbiAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICAgIHRoaXMucGFwZXIgPSBudWxsO1xuICAgICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICAgIGlmICh0aGlzLmJhY2tlbmQgPT0gUmVuZGVyZXIuQmFja2VuZHMuQ0FOVkFTKSB7XG4gICAgICAgIC8vIENyZWF0ZSBjb250ZXh0LlxuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudC5nZXRDb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRFbGVtZW50XCIsXG4gICAgICAgICAgXCJDYW4ndCBnZXQgY2FudmFzIGNvbnRleHQgZnJvbSBlbGVtZW50OiBcIiArIHNlbCk7XG4gICAgICAgIHRoaXMuY3R4ID0gUmVuZGVyZXIuYm9sc3RlckNhbnZhc0NvbnRleHQoXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKSk7XG5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrZW5kID09IFJlbmRlcmVyLkJhY2tlbmRzLlJBUEhBRUwpIHtcbiAgICAgICAgdGhpcy5jdHggPSBuZXcgVmV4LkZsb3cuUmFwaGFlbENvbnRleHQodGhpcy5lbGVtZW50KTtcblxuICAgICAgfSBlbHNlIGlmICh0aGlzLmJhY2tlbmQgPT0gUmVuZGVyZXIuQmFja2VuZHMuU1ZHKSB7XG4gICAgICAgIHRoaXMuY3R4ID0gbmV3IFZleC5GbG93LlNWR0NvbnRleHQodGhpcy5lbGVtZW50KTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiSW52YWxpZEJhY2tlbmRcIixcbiAgICAgICAgICBcIk5vIHN1cHBvcnQgZm9yIGJhY2tlbmQ6IFwiICsgdGhpcy5iYWNrZW5kKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAodGhpcy5iYWNrZW5kID09IFJlbmRlcmVyLkJhY2tlbmRzLkNBTlZBUykge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudC5nZXRDb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRFbGVtZW50XCIsXG4gICAgICAgICAgXCJDYW4ndCBnZXQgY2FudmFzIGNvbnRleHQgZnJvbSBlbGVtZW50OiBcIiArIHRoaXMuc2VsKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuY3R4ID0gUmVuZGVyZXIuYm9sc3RlckNhbnZhc0NvbnRleHQoXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN0eC5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY3R4OyB9XG4gIH07XG5cbiAgcmV0dXJuIFJlbmRlcmVyO1xufSgpKTtcblxuXG5cbi8vIFZleCBGbG93XG4vLyBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy9cbi8vIEEgcmVuZGVyaW5nIGNvbnRleHQgZm9yIHRoZSBSYXBoYWVsIGJhY2tlbmQuXG4vL1xuLy8gQ29weXJpZ2h0IE1vaGl0IENoZXBwdWRpcmEgMjAxMFxuXG4vLyAjIyBXYXJuaW5nOiBEZXByZWNhdGVkIGZvciBTVkdDb250ZXh0XG4vLyBFeGNlcHQgaW4gaW5zdGFuY2VzIHdoZXJlIFNWRyBzdXBwb3J0IGZvciBJRSA8IDkuMCBpc1xuLy8gbmVlZGVkLCBTVkdDb250ZXh0IGlzIHJlY29tbWVuZGVkLlxuXG4vKiogQGNvbnN0cnVjdG9yICovXG5WZXguRmxvdy5SYXBoYWVsQ29udGV4dCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUmFwaGFlbENvbnRleHQoZWxlbWVudCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KGVsZW1lbnQpO1xuICB9XG5cbiAgUmFwaGFlbENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLnBhcGVyID0gUmFwaGFlbChlbGVtZW50KTtcbiAgICAgIHRoaXMucGF0aCA9IFwiXCI7XG4gICAgICB0aGlzLnBlbiA9IHt4OiAwLCB5OiAwfTtcbiAgICAgIHRoaXMubGluZVdpZHRoID0gMS4wO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgc2NhbGU6IHsgeDogMSwgeTogMSB9LFxuICAgICAgICBmb250X2ZhbWlseTogXCJBcmlhbFwiLFxuICAgICAgICBmb250X3NpemU6IDgsXG4gICAgICAgIGZvbnRfd2VpZ2h0OiA4MDBcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHtcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMC4zLFxuICAgICAgICBcImZpbGxcIjogXCJibGFja1wiLFxuICAgICAgICBcInN0cm9rZVwiOiBcImJsYWNrXCIsXG4gICAgICAgIFwiZm9udFwiOiBcIjEwcHQgQXJpYWxcIlxuICAgICAgfTtcblxuICAgICAgdGhpcy5iYWNrZ3JvdW5kX2F0dHJpYnV0ZXMgPSB7XG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDAsXG4gICAgICAgIFwiZmlsbFwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwic3Ryb2tlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJmb250XCI6IFwiMTBwdCBBcmlhbFwiXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNoYWRvd19hdHRyaWJ1dGVzID0ge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgY29sb3I6IFwiYmxhY2tcIlxuICAgICAgfTtcblxuICAgICAgdGhpcy5zdGF0ZV9zdGFjaz0gW107XG4gICAgfSxcblxuICAgIC8vIENvbnRhaW5lcnMgbm90IGltcGxlbWVudGVkXG4gICAgb3Blbkdyb3VwOiBmdW5jdGlvbihjbHMsIGlkLCBhdHRycykge30sXG4gICAgY2xvc2VHcm91cDogZnVuY3Rpb24oKSB7fSxcbiAgICBhZGQ6IGZ1bmN0aW9uKGVsZW0pIHt9LFxuXG4gICAgc2V0Rm9udDogZnVuY3Rpb24oZmFtaWx5LCBzaXplLCB3ZWlnaHQpIHtcbiAgICAgIHRoaXMuc3RhdGUuZm9udF9mYW1pbHkgPSBmYW1pbHk7XG4gICAgICB0aGlzLnN0YXRlLmZvbnRfc2l6ZSA9IHNpemU7XG4gICAgICB0aGlzLnN0YXRlLmZvbnRfd2VpZ2h0ID0gd2VpZ2h0O1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzLmZvbnQgPSAodGhpcy5zdGF0ZS5mb250X3dlaWdodCB8fCBcIlwiKSArIFwiIFwiICtcbiAgICAgICAgKHRoaXMuc3RhdGUuZm9udF9zaXplICogdGhpcy5zdGF0ZS5zY2FsZS54KSArIFwicHQgXCIgK1xuICAgICAgICB0aGlzLnN0YXRlLmZvbnRfZmFtaWx5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFJhd0ZvbnQ6IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICAgIHRoaXMuYXR0cmlidXRlcy5mb250ID0gZm9udDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRGaWxsU3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuZmlsbCA9IHN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEJhY2tncm91bmRGaWxsU3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICB0aGlzLmJhY2tncm91bmRfYXR0cmlidXRlcy5maWxsID0gc3R5bGU7XG4gICAgICB0aGlzLmJhY2tncm91bmRfYXR0cmlidXRlcy5zdHJva2UgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTdHJva2VTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHRoaXMuYXR0cmlidXRlcy5zdHJva2UgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3dDb2xvcjogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHRoaXMuc2hhZG93X2F0dHJpYnV0ZXMuY29sb3IgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3dCbHVyOiBmdW5jdGlvbihibHVyKSB7XG4gICAgICB0aGlzLnNoYWRvd19hdHRyaWJ1dGVzLndpZHRoID0gYmx1cjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRMaW5lV2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbXCJzdHJva2Utd2lkdGhcIl0gPSB3aWR0aDtcbiAgICAgIHRoaXMubGluZVdpZHRoID0gd2lkdGg7XG4gICAgfSxcblxuICAgIC8vIEVtcHR5IGJlY2F1c2UgdGhlcmUgaXMgbm8gZXF1aXZhbGVudCBpbiBTVkdcbiAgICBzZXRMaW5lRGFzaDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9LFxuICAgIHNldExpbmVDYXA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnN0YXRlLnNjYWxlID0geyB4OiB4LCB5OiB5IH07XG4gICAgICAvLyBUaGUgc2NhbGUoKSBtZXRob2QgaXMgZGVwcmVjYXRlZCBhcyBvZiBSYXBoYWVsLkpTIDIuMCwgYW5kXG4gICAgICAvLyBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYXMgYW4gb3B0aW9uIGluIGFuIEVsZW1lbnQuYXR0cigpIGNhbGwuXG4gICAgICAvLyBJdCBpcyBwcmVzZXJ2ZWQgaGVyZSBmb3IgdXNlcnMgcnVubmluZyBlYXJsaWVyIHZlcnNpb25zIG9mXG4gICAgICAvLyBSYXBoYWVsLkpTLCB0aG91Z2ggaXQgaGFzIG5vIGVmZmVjdCBvbiB0aGUgU1ZHIG91dHB1dCBpblxuICAgICAgLy8gUmFwaGFlbCAyIGFuZCBoaWdoZXIuXG4gICAgICB0aGlzLmF0dHJpYnV0ZXMudHJhbnNmb3JtID0gXCJTXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIsMCwwXCI7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuc2NhbGUgPSB4ICsgXCIsXCIgKyB5ICsgXCIsMCwwXCI7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuZm9udCA9IHRoaXMuc3RhdGUuZm9udF9zaXplICogdGhpcy5zdGF0ZS5zY2FsZS54ICsgXCJwdCBcIiArXG4gICAgICAgIHRoaXMuc3RhdGUuZm9udF9mYW1pbHk7XG4gICAgICB0aGlzLmJhY2tncm91bmRfYXR0cmlidXRlcy50cmFuc2Zvcm0gPSBcIlNcIiArIHggKyBcIixcIiArIHkgKyBcIiwwLDBcIjtcbiAgICAgIHRoaXMuYmFja2dyb3VuZF9hdHRyaWJ1dGVzLmZvbnQgPSB0aGlzLnN0YXRlLmZvbnRfc2l6ZSAqXG4gICAgICAgIHRoaXMuc3RhdGUuc2NhbGUueCArIFwicHQgXCIgK1xuICAgICAgICB0aGlzLnN0YXRlLmZvbnRfZmFtaWx5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHsgdGhpcy5wYXBlci5jbGVhcigpOyB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMucGFwZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXRzIHRoZSBTVkcgYHZpZXdCb3hgIHByb3BlcnR5LCB3aGljaCByZXN1bHRzIGluIGF1dG8gc2NhbGluZyBpbWFnZXMgd2hlbiBpdHMgY29udGFpbmVyXG4gICAgLy8gaXMgcmVzaXplZC5cbiAgICAvL1xuICAgIC8vIFVzYWdlOiBgY3R4LnNldFZpZXdCb3goXCIwIDAgNjAwIDQwMFwiKWBcbiAgICBzZXRWaWV3Qm94OiBmdW5jdGlvbih2aWV3Qm94KSB7XG4gICAgICB0aGlzLnBhcGVyLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB2aWV3Qm94KTtcbiAgICB9LFxuXG4gICAgcmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgeSArPSBoZWlnaHQ7XG4gICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFwZXIucmVjdCh4LCB5LCB3aWR0aCAtIDAuNSwgaGVpZ2h0IC0gMC41KS5cbiAgICAgICAgYXR0cih0aGlzLmF0dHJpYnV0ZXMpLlxuICAgICAgICBhdHRyKFwiZmlsbFwiLCBcIm5vbmVcIikuXG4gICAgICAgIGF0dHIoXCJzdHJva2Utd2lkdGhcIiwgdGhpcy5saW5lV2lkdGgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZpbGxSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICB5ICs9IGhlaWdodDtcbiAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXBlci5yZWN0KHgsIHksIHdpZHRoIC0gMC41LCBoZWlnaHQgLSAwLjUpLlxuICAgICAgICBhdHRyKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xlYXJSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICB5ICs9IGhlaWdodDtcbiAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXBlci5yZWN0KHgsIHksIHdpZHRoIC0gMC41LCBoZWlnaHQgLSAwLjUpLlxuICAgICAgICBhdHRyKHRoaXMuYmFja2dyb3VuZF9hdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBiZWdpblBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYXRoID0gXCJcIjtcbiAgICAgIHRoaXMucGVuLnggPSAwO1xuICAgICAgdGhpcy5wZW4ueSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJNXCIgKyB4ICsgXCIsXCIgKyB5O1xuICAgICAgdGhpcy5wZW4ueCA9IHg7XG4gICAgICB0aGlzLnBlbi55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMucGF0aCArPSBcIkxcIiArIHggKyBcIixcIiArIHk7XG4gICAgICB0aGlzLnBlbi54ID0geDtcbiAgICAgIHRoaXMucGVuLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJDXCIgK1xuICAgICAgICB4MSArIFwiLFwiICtcbiAgICAgICAgeTEgKyBcIixcIiArXG4gICAgICAgIHgyICsgXCIsXCIgK1xuICAgICAgICB5MiArIFwiLFwiICtcbiAgICAgICAgeCArIFwiLFwiICtcbiAgICAgICAgeTtcbiAgICAgIHRoaXMucGVuLnggPSB4O1xuICAgICAgdGhpcy5wZW4ueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4LCB5KSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJRXCIgK1xuICAgICAgICB4MSArIFwiLFwiICtcbiAgICAgICAgeTEgKyBcIixcIiArXG4gICAgICAgIHggKyBcIixcIiArXG4gICAgICAgIHk7XG4gICAgICB0aGlzLnBlbi54ID0geDtcbiAgICAgIHRoaXMucGVuLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRoaXMgaXMgYW4gYXR0ZW1wdCAoaGFjaykgdG8gc2ltdWxhdGUgdGhlIEhUTUw1IGNhbnZhc1xuICAgIC8vIGFyYyBtZXRob2QuXG4gICAgYXJjOiBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpQ2xvY2t3aXNlKSB7XG4gICAgICBmdW5jdGlvbiBub3JtYWxpemVBbmdsZShhbmdsZSkge1xuICAgICAgICB3aGlsZSAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoYW5nbGUgPiBNYXRoLlBJICogMikge1xuICAgICAgICAgIGFuZ2xlIC09IE1hdGguUEkgKiAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmdsZTtcbiAgICAgIH1cblxuICAgICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlKHN0YXJ0QW5nbGUpO1xuICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVBbmdsZShlbmRBbmdsZSk7XG5cbiAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICAgICAgZW5kQW5nbGUgPSB0bXA7XG4gICAgICAgICAgYW50aUNsb2Nrd2lzZSA9ICFhbnRpQ2xvY2t3aXNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVsdGEgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG5cbiAgICAgIGlmIChkZWx0YSA+IE1hdGguUEkpIHtcbiAgICAgICAgICB0aGlzLmFyY0hlbHBlcih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIHN0YXJ0QW5nbGUgKyBkZWx0YSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgYW50aUNsb2Nrd2lzZSk7XG4gICAgICAgICAgdGhpcy5hcmNIZWxwZXIoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlICsgZGVsdGEgLyAyLCBlbmRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhbnRpQ2xvY2t3aXNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXJjSGVscGVyKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGlDbG9ja3dpc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFyY0hlbHBlcjogZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aUNsb2Nrd2lzZSkge1xuICAgICAgdmFyIHgxID0geCArIHJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgdmFyIHkxID0geSArIHJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuXG4gICAgICB2YXIgeDIgPSB4ICsgcmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgICAgdmFyIHkyID0geSArIHJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKTtcblxuICAgICAgdmFyIGxhcmdlQXJjRmxhZyA9IDA7XG4gICAgICB2YXIgc3dlZXBGbGFnID0gMDtcbiAgICAgIGlmIChhbnRpQ2xvY2t3aXNlKSB7XG4gICAgICAgIHN3ZWVwRmxhZyA9IDE7XG4gICAgICAgIGlmIChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPCBNYXRoLlBJKVxuICAgICAgICAgIGxhcmdlQXJjRmxhZyA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPiBNYXRoLlBJKSB7XG4gICAgICAgICAgbGFyZ2VBcmNGbGFnID0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXRoICs9IFwiTVwiICsgeDEgKyBcIixcIiArIHkxICsgXCIsXCIgKyBcIkFcIiArXG4gICAgICAgIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIsXCIgKyBcIjAsXCIgKyBsYXJnZUFyY0ZsYWcgKyBcIixcIiArIHN3ZWVwRmxhZyArIFwiLFwiICtcbiAgICAgICAgeDIgKyBcIixcIiArIHkyICsgXCJNXCIgKyB0aGlzLnBlbi54ICsgXCIsXCIgKyB0aGlzLnBlbi55O1xuICAgIH0sXG5cbiAgICAvLyBBZGFwdGVkIGZyb20gdGhlIHNvdXJjZSBmb3IgUmFwaGFlbCdzIEVsZW1lbnQuZ2xvd1xuICAgIGdsb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG91dCA9IHRoaXMucGFwZXIuc2V0KCk7XG4gICAgICBpZiAodGhpcy5zaGFkb3dfYXR0cmlidXRlcy53aWR0aCA+IDApIHtcbiAgICAgICAgdmFyIHNhID0gdGhpcy5zaGFkb3dfYXR0cmlidXRlcztcbiAgICAgICAgdmFyIG51bV9wYXRocyA9IHNhLndpZHRoIC8gMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbnVtX3BhdGhzOyBpKyspIHtcbiAgICAgICAgICBvdXQucHVzaCh0aGlzLnBhcGVyLnBhdGgodGhpcy5wYXRoKS5hdHRyKHtcbiAgICAgICAgICAgIHN0cm9rZTogc2EuY29sb3IsXG4gICAgICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIsXG4gICAgICAgICAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIixcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6ICsoc2Eud2lkdGggLyBudW1fcGF0aHMgKiBpKS50b0ZpeGVkKDMpLFxuICAgICAgICAgICAgb3BhY2l0eTogKygoc2Eub3BhY2l0eSB8fCAwLjMpIC8gbnVtX3BhdGhzKS50b0ZpeGVkKDMpLFxuICAgICAgICAgICAgLy8gU2VlIG5vdGUgaW4gdGhpcy5zY2FsZSgpOiBJbiBSYXBoYWVsIHRoZSBzY2FsZSgpIG1ldGhvZFxuICAgICAgICAgICAgLy8gaXMgZGVwcmVjYXRlZCBhbmQgcmVtb3ZlZCBhcyBvZiBSYXBoYWVsIDIuMCBhbmQgcmVwbGFjZWRcbiAgICAgICAgICAgIC8vIGJ5IHRoZSB0cmFuc2Zvcm0oKSBtZXRob2QuICBJdCBpcyBwcmVzZXJ2ZWQgaGVyZSBmb3JcbiAgICAgICAgICAgIC8vIHVzZXJzIHdpdGggZWFybGllciB2ZXJzaW9ucyBvZiBSYXBoYWVsLCBidXQgaGFzIG5vIGVmZmVjdFxuICAgICAgICAgICAgLy8gb24gdGhlIG91dHB1dCBTVkcgaW4gUmFwaGFlbCAyLjArLlxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLmF0dHJpYnV0ZXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuYXR0cmlidXRlcy5zY2FsZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9LFxuXG4gICAgZmlsbDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbSA9IHRoaXMucGFwZXIucGF0aCh0aGlzLnBhdGgpLlxuICAgICAgICBhdHRyKHRoaXMuYXR0cmlidXRlcykuXG4gICAgICAgIGF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMCk7XG4gICAgICB0aGlzLmdsb3coZWxlbSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3Ryb2tlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRoZSBmaXJzdCBsaW5lIG9mIGNvZGUgYmVsb3cgaXMsIHVuZm9ydHVuYXRlbHksIGEgYml0IG9mIGEgaGFjazpcbiAgICAgIC8vIFJhcGhhZWwncyB0cmFuc2Zvcm0oKSBzY2FsaW5nIGRvZXMgbm90IHNjYWxlIHRoZSBzdHJva2Utd2lkdGgsIHNvXG4gICAgICAvLyBpbiBvcmRlciB0byBzY2FsZSBhIHN0cm9rZSwgd2UgaGF2ZSB0byBtYW51YWxseSBzY2FsZSB0aGVcbiAgICAgIC8vIHN0cm9rZS13aWR0aC5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIHdvcmtzIHdlbGwgc28gbG9uZyBhcyB0aGUgWCAmIFkgc3RhdGVzIGZvciB0aGlzLnNjYWxlKCkgYXJlXG4gICAgICAvLyByZWxhdGl2ZWx5IHNpbWlsYXIuICBIb3dldmVyLCBpZiB0aGV5IGFyZSB2ZXJ5IGRpZmZlcmVudCwgd2VcbiAgICAgIC8vIHdvdWxkIGV4cGVjdCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBsaW5lcyB0byBoYXZlIGRpZmZlcmVudFxuICAgICAgLy8gc3Ryb2tlLXdpZHRocy5cbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgZnV0dXJlLCBpZiB3ZSB3YW50IHRvIHN1cHBvcnQgdmVyeSBkaXZlcmdlbnQgdmFsdWVzIGZvclxuICAgICAgLy8gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2NhbGluZywgd2UgbWF5IHdhbnQgdG8gY29uc2lkZXJcbiAgICAgIC8vIGltcGxlbWVudGluZyBTVkcgc2NhbGluZyB3aXRoIHByb3BlcnRpZXMgb2YgdGhlIFNWRyB2aWV3Qm94ICZcbiAgICAgIC8vIHZpZXdQb3J0IGFuZCByZW1vdmluZyBpdCBlbnRpcmVseSBmcm9tIHRoZSBFbGVtZW50LmF0dHIoKSBjYWxscy5cbiAgICAgIC8vIFRoaXMgd291bGQgbW9yZSBjbG9zZWx5IHBhcmFsbGVsIHRoZSBhcHByb2FjaCB0YWtlbiBpblxuICAgICAgLy8gY2FudmFzY29udGV4dC5qcyBhcyB3ZWxsLlxuXG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSB0aGlzLmxpbmVXaWR0aCAqICh0aGlzLnN0YXRlLnNjYWxlLnggKyB0aGlzLnN0YXRlLnNjYWxlLnkpLzI7XG4gICAgICB2YXIgZWxlbSA9IHRoaXMucGFwZXIucGF0aCh0aGlzLnBhdGgpLlxuICAgICAgICBhdHRyKHRoaXMuYXR0cmlidXRlcykuXG4gICAgICAgIGF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKS5cbiAgICAgICAgYXR0cihcInN0cm9rZS13aWR0aFwiLCBzdHJva2VXaWR0aCk7XG4gICAgICB0aGlzLmdsb3coZWxlbSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucGF0aCArPSBcIlpcIjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtZWFzdXJlVGV4dDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgdmFyIHR4dCA9IHRoaXMucGFwZXIudGV4dCgwLCAwLCB0ZXh0KS5cbiAgICAgICAgYXR0cih0aGlzLmF0dHJpYnV0ZXMpLlxuICAgICAgICBhdHRyKFwiZmlsbFwiLCBcIm5vbmVcIikuXG4gICAgICAgIGF0dHIoXCJzdHJva2VcIiwgXCJub25lXCIpO1xuICAgICAgdmFyIGJvdW5kcyA9IHR4dC5nZXRCQm94KCk7XG4gICAgICB0eHQucmVtb3ZlKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBib3VuZHMud2lkdGgsXG4gICAgICAgIGhlaWdodDogYm91bmRzLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgZmlsbFRleHQ6IGZ1bmN0aW9uKHRleHQsIHgsIHkpIHtcbiAgICAgIHRoaXMucGFwZXIudGV4dCh4ICsgKHRoaXMubWVhc3VyZVRleHQodGV4dCkud2lkdGggLyAyKSxcbiAgICAgICAgICAoeSAtICh0aGlzLnN0YXRlLmZvbnRfc2l6ZSAvICgyLjI1ICogdGhpcy5zdGF0ZS5zY2FsZS55KSkpLCB0ZXh0KS5cbiAgICAgICAgYXR0cih0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNhdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVE9ETyhtbXV0aGFubmEpOiBTdGF0ZSBuZWVkcyB0byBiZSBkZWVwLWNvcGllZC5cbiAgICAgIHRoaXMuc3RhdGVfc3RhY2sucHVzaCh7XG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgZm9udF9mYW1pbHk6IHRoaXMuc3RhdGUuZm9udF9mYW1pbHlcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIGZvbnQ6IHRoaXMuYXR0cmlidXRlcy5mb250LFxuICAgICAgICAgIGZpbGw6IHRoaXMuYXR0cmlidXRlcy5maWxsLFxuICAgICAgICAgIHN0cm9rZTogdGhpcy5hdHRyaWJ1dGVzLnN0cm9rZSxcbiAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlzLmF0dHJpYnV0ZXNbXCJzdHJva2Utd2lkdGhcIl1cbiAgICAgICAgfSxcbiAgICAgICAgc2hhZG93X2F0dHJpYnV0ZXM6IHtcbiAgICAgICAgICB3aWR0aDogdGhpcy5zaGFkb3dfYXR0cmlidXRlcy53aWR0aCxcbiAgICAgICAgICBjb2xvcjogdGhpcy5zaGFkb3dfYXR0cmlidXRlcy5jb2xvclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZXN0b3JlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRPRE8oMHhmZSk6IFN0YXRlIG5lZWRzIHRvIGJlIGRlZXAtcmVzdG9yZWQuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlX3N0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5zdGF0ZS5mb250X2ZhbWlseSA9IHN0YXRlLnN0YXRlLmZvbnRfZmFtaWx5O1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzLmZvbnQgPSBzdGF0ZS5hdHRyaWJ1dGVzLmZvbnQ7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuZmlsbCA9IHN0YXRlLmF0dHJpYnV0ZXMuZmlsbDtcbiAgICAgIHRoaXMuYXR0cmlidXRlcy5zdHJva2UgPSBzdGF0ZS5hdHRyaWJ1dGVzLnN0cm9rZTtcbiAgICAgIHRoaXMuYXR0cmlidXRlc1tcInN0cm9rZS13aWR0aFwiXSA9IHN0YXRlLmF0dHJpYnV0ZXNbXCJzdHJva2Utd2lkdGhcIl07XG4gICAgICB0aGlzLnNoYWRvd19hdHRyaWJ1dGVzLndpZHRoID0gc3RhdGUuc2hhZG93X2F0dHJpYnV0ZXMud2lkdGg7XG4gICAgICB0aGlzLnNoYWRvd19hdHRyaWJ1dGVzLmNvbG9yID0gc3RhdGUuc2hhZG93X2F0dHJpYnV0ZXMuY29sb3I7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJhcGhhZWxDb250ZXh0O1xufSgpKTtcblxuLy8gVmV4IEZsb3dcbi8vIE1vaGl0IE11dGhhbm5hIDxtb2hpdEBtdXRoYW5uYS5jb20+XG4vL1xuLy8gQSByZW5kZXJpbmcgY29udGV4dCBmb3IgU1ZHLlxuLy9cbi8vIENvcHlyaWdodCBNb2hpdCBNdXRoYW5uYSAyMDE1XG4vLyBAYXV0aG9yIEdyZWdvcnkgUmlzdG93ICgyMDE1KVxuXG4vKiogQGNvbnN0cnVjdG9yICovXG5WZXguRmxvdy5TVkdDb250ZXh0ID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBTVkdDb250ZXh0KGVsZW1lbnQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChlbGVtZW50KTtcbiAgfVxuXG4gIC8vIFRoZSBtZWFzdXJlVGV4dENhY2hlIGlzIHVzZWQgaW4gSmF2YXNjcmlwdCBydW50aW1lcyB3aGVyZVxuICAvLyB0aGVyZSBpcyBubyBwcm9wZXIgRE9NIHN1cHBvcnQgZm9yIFNWRyBib3VuZGluZyBib3hlcy4gVGhpc1xuICAvLyBpcyBjdXJyZW50bHkgb25seSB1c2VmdWwgaW4gdGhlIE5vZGVKUyB2aXN1YWwgcmVncmVzc2lvbiB0ZXN0cy5cbiAgU1ZHQ29udGV4dC5tZWFzdXJlVGV4dENhY2hlID0ge307XG5cbiAgLy8gSWYgZW5hYmxlZCwgd2lsbCBzdGFydCBjb2xsZWN0aW5nIGFuZCBpbmRleGluZyBnZXRCQm94IGRhdGEgYnlcbiAgLy8gZm9udCBuYW1lLCBzaXplLCB3ZWlnaHQsIGFuZCBzdHlsZS4gVGhpcyBzaG91bGQgYmUgZGlzYWJsZWQgYnlcbiAgLy8gZGVmYXVsdCAob3IgeW91IHdpbGwgZmluZCB5b3Vyc2VsZiBzbG93bHkgbGVha2luZyBSQU0uKVxuICBTVkdDb250ZXh0LmNvbGxlY3RNZWFzdXJlbWVudHMgPSBmYWxzZTtcblxuICAvLyBJZiBlbmFibGVkLCB3aWxsIHdhcm4gaWYgdGhlcmUgYXJlIG5ldyBnZXRCQm94IHJlcXVlc3RzIHRoYXQgYXJlXG4gIC8vIG5vdCBpbiB0aGUgY2FjaGUuIFRoaXMgaXMgZW5hYmxlZCBpbiB0aGUgVmV4RmxvdyB0ZXN0cywgYW5kIGlmIHlvdVxuICAvLyBzZWUgYSB3YXJuaW5nIG9uIHRoZSBjb25zb2xlLCB5b3Ugd2lsbCBuZWVkIHRvIGVuYWJsZSBjb2xsZWN0TWVhc3VyZW1lbnRzXG4gIC8vIGFib3ZlLCB0aGVuIHVwZGF0ZSBtZWFzdXJlVGV4dENhY2hlIHdpdGggdGhlIG5ldyB2YWx1ZXMuIFNlZVxuICAvLyB0ZXN0cy9tZWFzdXJlX3RleHRfY2FjaGUuanMgZm9yIGluc3RydWN0aW9ucyBvbiBob3cgdG8gZG8gdGhpcy5cbiAgU1ZHQ29udGV4dC52YWxpZGF0ZU1lYXN1cmVtZW50ID0gZmFsc2U7XG5cbiAgU1ZHQ29udGV4dC5hZGRQcmVmaXggPSBWZXguUHJlZml4O1xuXG4gIFNWR0NvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIC8vIGVsZW1lbnQgaXMgdGhlIHBhcmVudCBET00gb2JqZWN0XG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgLy8gQ3JlYXRlIHRoZSBTVkcgaW4gdGhlIFNWRyBuYW1lc3BhY2U6XG4gICAgICB0aGlzLnN2Z05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuICAgICAgdmFyIHN2ZyA9IHRoaXMuY3JlYXRlKFwic3ZnXCIpO1xuICAgICAgLy8gQWRkIGl0IHRvIHRoZSBjYW52YXM6XG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnKTtcblxuICAgICAgLy8gUG9pbnQgdG8gaXQ6XG4gICAgICB0aGlzLnN2ZyA9IHN2ZztcbiAgICAgIHRoaXMuZ3JvdXBzID0gW3RoaXMuc3ZnXTsgLy8gQ3JlYXRlIHRoZSBncm91cCBzdGFja1xuICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLnN2ZztcblxuICAgICAgdGhpcy5wYXRoID0gXCJcIjtcbiAgICAgIHRoaXMucGVuID0ge3g6IDAsIHk6IDB9O1xuICAgICAgdGhpcy5saW5lV2lkdGggPSAxLjA7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBzY2FsZTogeyB4OiAxLCB5OiAxIH0sXG4gICAgICAgIFwiZm9udC1mYW1pbHlcIjogXCJBcmlhbFwiLFxuICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjhwdFwiLFxuICAgICAgICBcImZvbnQtd2VpZ2h0XCI6IFwibm9ybWFsXCJcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHtcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMC4zLFxuICAgICAgICBcImZpbGxcIjogXCJibGFja1wiLFxuICAgICAgICBcInN0cm9rZVwiOiBcImJsYWNrXCIsXG4gICAgICAgIFwiZm9udC1mYW1pbHlcIjogXCJBcmlhbFwiLFxuICAgICAgICBcImZvbnQtc2l6ZVwiIDogXCIxMHB0XCIsXG4gICAgICAgIFwiZm9udC13ZWlnaHRcIiA6IFwibm9ybWFsXCIsXG4gICAgICAgIFwiZm9udC1zdHlsZVwiIDogXCJub3JtYWxcIlxuICAgICAgfTtcblxuICAgICAgdGhpcy5iYWNrZ3JvdW5kX2F0dHJpYnV0ZXMgPSB7XG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDAsXG4gICAgICAgIFwiZmlsbFwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwic3Ryb2tlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJmb250LWZhbWlseVwiOiBcIkFyaWFsXCIsXG4gICAgICAgIFwiZm9udC1zaXplXCIgOiBcIjEwcHRcIixcbiAgICAgICAgXCJmb250LXdlaWdodFwiOiBcIm5vcm1hbFwiLFxuICAgICAgICBcImZvbnQtc3R5bGVcIjogXCJub3JtYWxcIlxuICAgICAgfTtcblxuICAgICAgdGhpcy5zaGFkb3dfYXR0cmlidXRlcyA9IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGNvbG9yOiBcImJsYWNrXCJcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuc3RhdGVfc3RhY2s9IFtdO1xuXG4gICAgICAvLyBUZXN0IGZvciBJbnRlcm5ldCBFeHBsb3JlclxuICAgICAgdGhpcy5pZVBvbHlmaWxsKCk7XG4gICAgfSxcblxuICAgIGNyZWF0ZTogZnVuY3Rpb24oc3ZnRWxlbWVudFR5cGUpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5zdmdOUywgc3ZnRWxlbWVudFR5cGUpO1xuICAgIH0sXG5cbiAgICAvLyBBbGxvdyBncm91cGluZyBlbGVtZW50cyBpbiBjb250YWluZXJzIGZvciBpbnRlcmFjdGl2aXR5LlxuICAgIG9wZW5Hcm91cDogZnVuY3Rpb24oY2xzLCBpZCwgYXR0cnMpIHtcbiAgICAgIHZhciBncm91cCA9IHRoaXMuY3JlYXRlKFwiZ1wiKTtcbiAgICAgIHRoaXMuZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICAgICAgdGhpcy5wYXJlbnQgPSBncm91cDtcbiAgICAgIGlmIChjbHMpIGdyb3VwLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFNWR0NvbnRleHQuYWRkUHJlZml4KGNscykpO1xuICAgICAgaWYgKGlkKSBncm91cC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBTVkdDb250ZXh0LmFkZFByZWZpeChpZCkpO1xuXG4gICAgICBpZiAoYXR0cnMgJiYgYXR0cnMucG9pbnRlckJCb3gpIHtcbiAgICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlKFwicG9pbnRlci1ldmVudHNcIiwgXCJib3VuZGluZy1ib3hcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSxcblxuICAgIGNsb3NlR3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHMucG9wKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHRoaXMuZ3JvdXBzW3RoaXMuZ3JvdXBzLmxlbmd0aCAtIDFdO1xuICAgIH0sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHRoaXMucGFyZW50LmFwcGVuZENoaWxkKGVsZW0pO1xuICAgIH0sXG5cbiAgICAvLyBUZXN0cyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlcjsgaWYgaXQgaXMsXG4gICAgLy8gd2UgZG8gc29tZSB0cmlja3MgdG8gaW1wcm92ZSB0ZXh0IGxheW91dC4gIFNlZSB0aGVcbiAgICAvLyBub3RlIGF0IGllTWVhc3VyZVRleHRGaXgoKSBmb3IgZGV0YWlscy5cbiAgICBpZVBvbHlmaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0eXBlb2YobmF2aWdhdG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmllID0gKCAgL01TSUUgOS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvTVNJRSAxMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvcnY6MTFcXC4wL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9UcmlkZW50L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyAjIyMgU3R5bGluZyAmIFN0YXRlIE1ldGhvZHM6XG5cbiAgICBzZXRGb250OiBmdW5jdGlvbihmYW1pbHksIHNpemUsIHdlaWdodCkge1xuICAgICAgLy8gVW5saWtlIGNhbnZhcywgaW4gU1ZHIGl0YWxpYyBpcyBoYW5kbGVkIGJ5IGZvbnQtc3R5bGUsXG4gICAgICAvLyBub3Qgd2VpZ2h0LiBTbzogd2Ugc2VhcmNoIHRoZSB3ZWlnaHQgYXJndW1lbnQgYW5kXG4gICAgICAvLyBhcHBseSBib2xkIGFuZCBpdGFsaWMgdG8gd2VpZ2h0IGFuZCBzdHlsZSByZXNwZWN0aXZlbHkuXG4gICAgICB2YXIgYm9sZCA9IGZhbHNlO1xuICAgICAgdmFyIGl0YWxpYyA9IGZhbHNlO1xuICAgICAgdmFyIHN0eWxlID0gXCJub3JtYWxcIjtcbiAgICAgIC8vIFdlaWdodCBtaWdodCBhbHNvIGJlIGEgbnVtYmVyICgyMDAsIDQwMCwgZXRjLi4uKSBzbyB3ZVxuICAgICAgLy8gdGVzdCBpdHMgdHlwZSB0byBiZSBzdXJlIHdlIGhhdmUgYWNjZXNzIHRvIFN0cmluZyBtZXRob2RzLlxuICAgICAgaWYoIHR5cGVvZiB3ZWlnaHQgPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAvLyBsb29rIGZvciBcIml0YWxpY1wiIGluIHRoZSB3ZWlnaHQ6XG4gICAgICAgICAgaWYod2VpZ2h0LmluZGV4T2YoXCJpdGFsaWNcIikgIT09IC0xKSB7XG4gICAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHQucmVwbGFjZSgvaXRhbGljL2csIFwiXCIpO1xuICAgICAgICAgICAgaXRhbGljID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbG9vayBmb3IgXCJib2xkXCIgaW4gd2VpZ2h0XG4gICAgICAgICAgaWYod2VpZ2h0LmluZGV4T2YoXCJib2xkXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0LnJlcGxhY2UoL2JvbGQvZywgXCJcIik7XG4gICAgICAgICAgICBib2xkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcmVtb3ZlIGFueSByZW1haW5pbmcgc3BhY2VzXG4gICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0LnJlcGxhY2UoLyAvZywgXCJcIik7XG4gICAgICB9XG4gICAgICB3ZWlnaHQgPSBib2xkID8gXCJib2xkXCIgOiB3ZWlnaHQ7XG4gICAgICB3ZWlnaHQgPSAodHlwZW9mIHdlaWdodCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB3ZWlnaHQgPT09IFwiXCIpID8gXCJub3JtYWxcIiA6IHdlaWdodDtcblxuICAgICAgc3R5bGUgPSBpdGFsaWMgPyBcIml0YWxpY1wiIDogc3R5bGU7XG5cbiAgICAgIHZhciBmb250QXR0cmlidXRlcyA9IHtcbiAgICAgICAgXCJmb250LWZhbWlseVwiOiBmYW1pbHksXG4gICAgICAgIFwiZm9udC1zaXplXCI6IHNpemUgKyBcInB0XCIsXG4gICAgICAgIFwiZm9udC13ZWlnaHRcIjogd2VpZ2h0LFxuICAgICAgICBcImZvbnQtc3R5bGVcIiA6IHN0eWxlXG4gICAgICB9O1xuXG4gICAgICAvLyBTdG9yZSB0aGUgZm9udCBzaXplIHNvIHRoYXQgaWYgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXRcbiAgICAgIC8vIEV4cGxvcmVyIHdlIGNhbiBmaXggaXRzIGNhbGN1bGF0aW9ucyBvZiB0ZXh0IHdpZHRoLlxuICAgICAgdGhpcy5mb250U2l6ZSA9IE51bWJlcihzaXplKTtcblxuICAgICAgVmV4Lk1lcmdlKHRoaXMuYXR0cmlidXRlcywgZm9udEF0dHJpYnV0ZXMpO1xuICAgICAgVmV4Lk1lcmdlKHRoaXMuc3RhdGUsIGZvbnRBdHRyaWJ1dGVzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFJhd0ZvbnQ6IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICAgIGZvbnQ9Zm9udC50cmltKCk7XG4gICAgICAvLyBBc3N1bWVzIHNpemUgZmlyc3QsIHNwbGl0cyBvbiBzcGFjZSAtLSB3aGljaCBpcyBwcmVzZW50bHlcbiAgICAgIC8vIGhvdyBhbGwgZXhpc3RpbmcgbW9kdWxlcyBhcmUgY2FsbGluZyB0aGlzLlxuICAgICAgdmFyIGZvbnRBcnJheSA9IGZvbnQuc3BsaXQoXCIgXCIpO1xuXG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbXCJmb250LWZhbWlseVwiXSA9IGZvbnRBcnJheVsxXTtcbiAgICAgIHRoaXMuc3RhdGVbXCJmb250LWZhbWlseVwiXSA9IGZvbnRBcnJheVsxXTtcblxuICAgICAgdGhpcy5hdHRyaWJ1dGVzW1wiZm9udC1zaXplXCJdID0gZm9udEFycmF5WzBdO1xuICAgICAgdGhpcy5zdGF0ZVtcImZvbnQtc2l6ZVwiXSA9IGZvbnRBcnJheVswXTtcblxuICAgICAgLy8gU2F2ZXMgZm9udFNpemUgZm9yIElFIHBvbHlmaWxsXG4gICAgICB0aGlzLmZvbnRTaXplID0gTnVtYmVyKGZvbnRBcnJheVswXS5tYXRjaCgvXFxkKy8pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRGaWxsU3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuZmlsbCA9IHN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEJhY2tncm91bmRGaWxsU3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICB0aGlzLmJhY2tncm91bmRfYXR0cmlidXRlcy5maWxsID0gc3R5bGU7XG4gICAgICB0aGlzLmJhY2tncm91bmRfYXR0cmlidXRlcy5zdHJva2UgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTdHJva2VTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHRoaXMuYXR0cmlidXRlcy5zdHJva2UgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3dDb2xvcjogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHRoaXMuc2hhZG93X2F0dHJpYnV0ZXMuY29sb3IgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3dCbHVyOiBmdW5jdGlvbihibHVyKSB7XG4gICAgICB0aGlzLnNoYWRvd19hdHRyaWJ1dGVzLndpZHRoID0gYmx1cjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRMaW5lV2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbXCJzdHJva2Utd2lkdGhcIl0gPSB3aWR0aDtcbiAgICAgIHRoaXMubGluZVdpZHRoID0gd2lkdGg7XG4gICAgfSxcblxuICAgIHNldExpbmVEYXNoOiBmdW5jdGlvbihsaW5lRGFzaCkge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW1wic3Ryb2tlLWxpbmVkYXNoXCJdID0gbGluZURhc2g7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0TGluZUNhcDogZnVuY3Rpb24obGluZUNhcCkge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW1wic3Ryb2tlLWxpbmVjYXBcIl0gPSBsaW5lQ2FwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vICMjIyBTaXppbmcgJiBTY2FsaW5nIE1ldGhvZHM6XG5cbiAgICAvLyBUT0RPIChHQ1IpOiBTZWUgbm90ZSBhdCBzY2FsZSgpIC0tIHNlcGVyYXRlIG91ciBpbnRlcm5hbFxuICAgIC8vIGNvbmNlcHRpb24gb2YgcGl4ZWwtYmFzZWQgd2lkdGgvaGVpZ2h0IGZyb20gdGhlIHN0eWxlLndpZHRoXG4gICAgLy8gYW5kIHN0eWxlLmhlaWdodCBwcm9wZXJ0aWVzIGV2ZW50dWFsbHkgdG8gYWxsb3cgdXNlcnMgdG9cbiAgICAvLyBhcHBseSByZXNwb25zaXZlIHNpemluZyBhdHRyaWJ1dGVzIHRvIHRoZSBTVkcuXG4gICAgcmVzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIHdpZHRoIDogd2lkdGgsXG4gICAgICAgIGhlaWdodCA6IGhlaWdodFxuICAgICAgfTtcbiAgICAgIHRoaXMuYXBwbHlBdHRyaWJ1dGVzKHRoaXMuc3ZnLCBhdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgLy8gdXNlcyB2aWV3Qm94IHRvIHNjYWxlXG4gICAgICAvLyBUT0RPIChHQ1IpOiB3ZSBtYXkgYXQgc29tZSBwb2ludCB3YW50IHRvIGRpc3Rpbmd1aXNoIHRoZVxuICAgICAgLy8gc3R5bGUud2lkdGggLyBzdHlsZS5oZWlnaHQgcHJvcGVydGllcyB0aGF0IGFyZSBhcHBsaWVkIHRvXG4gICAgICAvLyB0aGUgU1ZHIG9iamVjdCBmcm9tIG91ciBpbnRlcm5hbCBjb25jZXB0aW9uIG9mIHRoZSBTVkdcbiAgICAgIC8vIHdpZHRoL2hlaWdodC4gIFRoaXMgd291bGQgYWxsb3cgdXMgdG8gY3JlYXRlIGF1dG9tYXRpY2FsbHlcbiAgICAgIC8vIHNjYWxpbmcgU1ZHJ3MgdGhhdCBmaWxsZWQgdGhlaXIgY29udGFpbmVycywgZm9yIGluc3RhbmNlLlxuICAgICAgLy9cbiAgICAgIC8vIEFzIHRoaXMgaXNuJ3QgaW1wbGVtZW50ZWQgaW4gQ2FudmFzIG9yIFJhcGhhZWwgY29udGV4dHMsXG4gICAgICAvLyBJJ3ZlIGxlZnQgYXMgaXMgZm9yIG5vdywgYnV0IGluIHVzaW5nIHRoZSB2aWV3Qm94IHRvXG4gICAgICAvLyBoYW5kbGUgaW50ZXJuYWwgc2NhbGluZywgYW0gdHJ5aW5nIHRvIG1ha2UgaXQgcG9zc2libGVcbiAgICAgIC8vIGZvciB1cyB0byBldmVudHVhbGx5IG1vdmUgaW4gdGhhdCBkaXJlY3Rpb24uXG5cbiAgICAgIHRoaXMuc3RhdGUuc2NhbGUgPSB7IHg6IHgsIHk6IHkgfTtcbiAgICAgIHZhciB2aXNpYmxlV2lkdGggPSB0aGlzLndpZHRoIC8geDtcbiAgICAgIHZhciB2aXNpYmxlSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyB5O1xuICAgICAgdGhpcy5zZXRWaWV3Qm94KDAsMCwgdmlzaWJsZVdpZHRoLCB2aXNpYmxlSGVpZ2h0KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFZpZXdCb3g6IGZ1bmN0aW9uKHhNaW4sIHlNaW4sIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIC8vIE92ZXJyaWRlIGZvciBcInggeSB3IGhcIiBzdHlsZTpcbiAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkgdGhpcy5zdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCB2aWV3Qm94KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgdmlld0JveFN0cmluZyA9IHhNaW4gKyBcIiBcIiArIHlNaW4gKyBcIiBcIiArIHdpZHRoICsgXCIgXCIgKyBoZWlnaHQ7XG4gICAgICAgIHRoaXMuc3ZnLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgdmlld0JveFN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vICMjIyBEcmF3aW5nIGhlbHBlciBtZXRob2RzOlxuXG4gICAgYXBwbHlBdHRyaWJ1dGVzOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gICAgICBmb3IodmFyIHByb3BlcnR5TmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgcHJvcGVydHlOYW1lLCBhdHRyaWJ1dGVzW3Byb3BlcnR5TmFtZV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSxcblxuICAgIGZsaXBSZWN0YW5nbGU6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIC8vIEF2b2lkIGludmFsaWQgbmVnYXRpdmUgaGVpZ2h0IGF0dHJpYnV0ZXMgYnlcbiAgICAgIC8vIGZsaXBwaW5nIGEgcmVjdGFuZ2xlIHcvIG5lZ2F0aXZlIGhlaWdodCBvbiBpdHMgaGVhZC5cbiAgICAgIC8vIFNpbmNlIGFyZ3MgaXMgdGhlIGFjdHVhbCBhcmd1bWVudHMgb2JqZWN0IGZyb21cbiAgICAgIC8vIG9uZSBvZiB0aGUgcmVjdGFuZ2xlIGZ1bmN0aW9ucywgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgLy8gcmV0dXJuIGl0LlxuXG4gICAgICAvLyBBZGQgbmVnYXRpdmUgaGVpZ2h0IHRvIFlcbiAgICAgIGFyZ3NbMV0gKz0gYXJnc1szXTtcbiAgICAgIC8vIE1ha2UgdGhlIG5lZ2F0aXZlIGhlaWdodCBwb3NpdGl2ZS5cbiAgICAgIGFyZ3NbM10gPSAtYXJnc1szXTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIFNoYXBlICYgUGF0aCBNZXRob2RzOlxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2xlYXIgdGhlIFNWRyBieSByZW1vdmluZyBhbGwgaW5uZXIgY2hpbGRyZW4uXG5cbiAgICAgIC8vIChUaGlzIGFwcHJvYWNoIGlzIHVzdWFsbHkgc2xpZ2h0bHkgbW9yZSBlZmZpY2llbnRcbiAgICAgIC8vIHRoYW4gcmVtb3ZpbmcgdGhlIG9sZCBTVkcgJiBhZGRpbmcgYSBuZXcgb25lIHRvXG4gICAgICAvLyB0aGUgY29udGFpbmVyIGVsZW1lbnQsIHNpbmNlIGl0IGRvZXMgbm90IGNhdXNlIHRoZVxuICAgICAgLy8gY29udGFpbmVyIHRvIHJlc2l6ZSB0d2ljZS4gIEFsc28sIHRoZSByZXNpemVcbiAgICAgIC8vIHRyaWdnZXJlZCBieSByZW1vdmluZyB0aGUgZW50aXJlIFNWRyBjYW4gdHJpZ2dlclxuICAgICAgLy8gYSB0b3VjaGNhbmNlbCBldmVudCB3aGVuIHRoZSBlbGVtZW50IHJlc2l6ZXMgYXdheVxuICAgICAgLy8gZnJvbSBhIHRvdWNoIHBvaW50LilcblxuICAgICAgd2hpbGUgKHRoaXMuc3ZnLmxhc3RDaGlsZCkge1xuICAgICAgICB0aGlzLnN2Zy5yZW1vdmVDaGlsZCh0aGlzLnN2Zy5sYXN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXBsYWNlIHRoZSB2aWV3Ym94IGF0dHJpYnV0ZSB3ZSBqdXN0IHJlbW92ZWQ6XG4gICAgICB0aGlzLnNjYWxlKHRoaXMuc3RhdGUuc2NhbGUueCwgdGhpcy5zdGF0ZS5zY2FsZS55KTtcbiAgICB9LFxuXG4gICAgLy8gIyMgUmVjdGFuZ2xlczpcblxuICAgIHJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIGF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vIEF2b2lkIGludmFsaWQgbmVnYXRpdmUgaGVpZ2h0IGF0dHJpYnMgYnlcbiAgICAgIC8vIGZsaXBwaW5nIHRoZSByZWN0YW5nbGUgb24gaXRzIGhlYWQ6XG4gICAgICBpZiAoaGVpZ2h0IDwgMCkgdGhpcy5mbGlwUmVjdGFuZ2xlKGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgcmVjdCAmIHN0eWxlIGl0OlxuICAgICAgdmFyIHJlY3QgPSB0aGlzLmNyZWF0ZShcInJlY3RcIik7XG4gICAgICBpZih0eXBlb2YgYXR0cmlidXRlcyA9PT0gXCJ1bmRlZmluZWRcIikgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaXMubGluZVdpZHRoLFxuICAgICAgICBzdHJva2U6IFwiYmxhY2tcIlxuICAgICAgfTtcbiAgICAgIFZleC5NZXJnZShhdHRyaWJ1dGVzLCB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmFwcGx5QXR0cmlidXRlcyhyZWN0LCBhdHRyaWJ1dGVzKTtcblxuICAgICAgdGhpcy5hZGQocmVjdCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZmlsbFJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmKGhlaWdodCA8IDApIHRoaXMuZmxpcFJlY3RhbmdsZShhcmd1bWVudHMpO1xuXG4gICAgICB0aGlzLnJlY3QoeCwgeSwgd2lkdGggLSAwLjUsIGhlaWdodCAtIDAuNSwgdGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhclJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIC8vIFRPRE8oR0NSKTogSW1wcm92ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzLi4uXG4gICAgICAvLyBDdXJyZW50bHkgaXQgZHJhd3MgYSBib3ggb2YgdGhlIGJhY2tncm91bmQgY29sb3IsIHJhdGhlclxuICAgICAgLy8gdGhhbiBjcmVhdGluZyBhbHBoYSB0aHJvdWdoIGxvd2VyIHotbGV2ZWxzLlxuICAgICAgLy9cbiAgICAgIC8vIFNlZSB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBpbiBTVkdLaXQ6XG4gICAgICAvLyBodHRwOi8vc291cmNlZm9yZ2UubmV0L3Byb2plY3RzL3N2Z2tpdC9cbiAgICAgIC8vIGFzIGEgc3RhcnRpbmcgcG9pbnQuXG4gICAgICAvL1xuICAgICAgLy8gQWRkaW5nIGEgbGFyZ2UgbnVtYmVyIG9mIHRyYW5zZm9ybSBwYXRocyAoYXMgd2Ugd291bGRcbiAgICAgIC8vIGhhdmUgdG8gZG8pIGNvdWxkIGJlIGEgcmVhbCBwZXJmb3JtYW5jZSBoaXQuICBTaW5jZVxuICAgICAgLy8gdGFiTm90ZSBzZWVtcyB0byBiZSB0aGUgb25seSBtb2R1bGUgdGhhdCBtYWtlcyB1c2Ugb2YgdGhpc1xuICAgICAgLy8gaXQgbWF5IGJlIHdvcnRoIGNyZWF0aW5nIGEgc2VwZXJhdGUgdGFiU3RhdmUgdGhhdCB3b3VsZFxuICAgICAgLy8gZHJhdyBsaW5lcyBhcm91bmQgbG9jYXRpb25zIG9mIHRhYmxhdHVyZSBmaW5nZXJpbmcuXG4gICAgICAvL1xuXG4gICAgICBpZiAoaGVpZ2h0IDwgMCkgdGhpcy5mbGlwUmVjdGFuZ2xlKGFyZ3VtZW50cyk7XG5cbiAgICAgIHRoaXMucmVjdCh4LCB5LCB3aWR0aCAtIDAuNSwgaGVpZ2h0IC0gMC41LCB0aGlzLmJhY2tncm91bmRfYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gIyMgUGF0aHM6XG5cbiAgICBiZWdpblBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYXRoID0gXCJcIjtcbiAgICAgIHRoaXMucGVuLnggPSAwO1xuICAgICAgdGhpcy5wZW4ueSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJNXCIgKyB4ICsgXCIgXCIgKyB5O1xuICAgICAgdGhpcy5wZW4ueCA9IHg7XG4gICAgICB0aGlzLnBlbi55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMucGF0aCArPSBcIkxcIiArIHggKyBcIiBcIiArIHk7XG4gICAgICB0aGlzLnBlbi54ID0geDtcbiAgICAgIHRoaXMucGVuLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJDXCIgK1xuICAgICAgICB4MSArIFwiIFwiICtcbiAgICAgICAgeTEgKyBcIixcIiArXG4gICAgICAgIHgyICsgXCIgXCIgK1xuICAgICAgICB5MiArIFwiLFwiICtcbiAgICAgICAgeCArIFwiIFwiICtcbiAgICAgICAgeTtcbiAgICAgIHRoaXMucGVuLnggPSB4O1xuICAgICAgdGhpcy5wZW4ueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4LCB5KSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJRXCIgK1xuICAgICAgICB4MSArIFwiIFwiICtcbiAgICAgICAgeTEgKyBcIixcIiArXG4gICAgICAgIHggKyBcIiBcIiArXG4gICAgICAgIHk7XG4gICAgICB0aGlzLnBlbi54ID0geDtcbiAgICAgIHRoaXMucGVuLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRoaXMgaXMgYW4gYXR0ZW1wdCAoaGFjaykgdG8gc2ltdWxhdGUgdGhlIEhUTUw1IGNhbnZhc1xuICAgIC8vIGFyYyBtZXRob2QuXG4gICAgYXJjOiBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpQ2xvY2t3aXNlKSB7XG4gICAgICBmdW5jdGlvbiBub3JtYWxpemVBbmdsZShhbmdsZSkge1xuICAgICAgICB3aGlsZSAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoYW5nbGUgPiBNYXRoLlBJICogMikge1xuICAgICAgICAgIGFuZ2xlIC09IE1hdGguUEkgKiAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmdsZTtcbiAgICAgIH1cblxuICAgICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlKHN0YXJ0QW5nbGUpO1xuICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVBbmdsZShlbmRBbmdsZSk7XG5cbiAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICAgICAgZW5kQW5nbGUgPSB0bXA7XG4gICAgICAgICAgYW50aUNsb2Nrd2lzZSA9ICFhbnRpQ2xvY2t3aXNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVsdGEgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG5cbiAgICAgIGlmIChkZWx0YSA+IE1hdGguUEkpIHtcbiAgICAgICAgICB0aGlzLmFyY0hlbHBlcih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIHN0YXJ0QW5nbGUgKyBkZWx0YSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgYW50aUNsb2Nrd2lzZSk7XG4gICAgICAgICAgdGhpcy5hcmNIZWxwZXIoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlICsgZGVsdGEgLyAyLCBlbmRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhbnRpQ2xvY2t3aXNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXJjSGVscGVyKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGlDbG9ja3dpc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFyY0hlbHBlcjogZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aUNsb2Nrd2lzZSkge1xuICAgICAgdmFyIHgxID0geCArIHJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgdmFyIHkxID0geSArIHJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuXG4gICAgICB2YXIgeDIgPSB4ICsgcmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgICAgdmFyIHkyID0geSArIHJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKTtcblxuICAgICAgdmFyIGxhcmdlQXJjRmxhZyA9IDA7XG4gICAgICB2YXIgc3dlZXBGbGFnID0gMDtcbiAgICAgIGlmIChhbnRpQ2xvY2t3aXNlKSB7XG4gICAgICAgIHN3ZWVwRmxhZyA9IDE7XG4gICAgICAgIGlmIChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPCBNYXRoLlBJKVxuICAgICAgICAgIGxhcmdlQXJjRmxhZyA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPiBNYXRoLlBJKSB7XG4gICAgICAgICAgbGFyZ2VBcmNGbGFnID0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXRoICs9IFwiTVwiICsgeDEgKyBcIiBcIiArIHkxICsgXCIgXCIgKyBcIkFcIiArXG4gICAgICAgIHJhZGl1cyArIFwiIFwiICsgcmFkaXVzICsgXCIgXCIgKyBcIjAgXCIgKyBsYXJnZUFyY0ZsYWcgKyBcIiBcIiArIHN3ZWVwRmxhZyArIFwiIFwiICtcbiAgICAgICAgeDIgKyBcIiBcIiArIHkyICsgXCJNXCIgKyB0aGlzLnBlbi54ICsgXCIgXCIgKyB0aGlzLnBlbi55O1xuXG4gICAgfSxcblxuICAgIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJaXCI7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGFwdGVkIGZyb20gdGhlIHNvdXJjZSBmb3IgUmFwaGFlbCdzIEVsZW1lbnQuZ2xvd1xuICAgIGdsb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB3aWR0aCAmIHBhdGhzIG9mIHRoZSBnbG93OlxuICAgICAgaWYgKHRoaXMuc2hhZG93X2F0dHJpYnV0ZXMud2lkdGggPiAwKSB7XG4gICAgICAgIHZhciBzYSA9IHRoaXMuc2hhZG93X2F0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBudW1fcGF0aHMgPSBzYS53aWR0aCAvIDI7XG4gICAgICAgIC8vIFN0cm9rZSBhdCB2YXJ5aW5nIHdpZHRocyB0byBjcmVhdGUgZWZmZWN0IG9mIGdhdXNzaWFuIGJsdXI6XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG51bV9wYXRoczsgaSsrKSB7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICBzdHJva2U6IHNhLmNvbG9yLFxuICAgICAgICAgICAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiLFxuICAgICAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiBcInJvdW5kXCIsXG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiArKChzYS53aWR0aCAqMC40KSAvIG51bV9wYXRocyAqIGkpLnRvRml4ZWQoMyksXG4gICAgICAgICAgICBvcGFjaXR5OiArKChzYS5vcGFjaXR5IHx8IDAuMykgLyBudW1fcGF0aHMpLnRvRml4ZWQoMyksXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5jcmVhdGUoXCJwYXRoXCIpO1xuICAgICAgICAgIGF0dHJpYnV0ZXMuZCA9IHRoaXMucGF0aDtcbiAgICAgICAgICB0aGlzLmFwcGx5QXR0cmlidXRlcyhwYXRoLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICB0aGlzLmFkZChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZpbGw6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vIElmIG91ciBjdXJyZW50IHBhdGggaXMgc2V0IHRvIGdsb3csIG1ha2UgaXQgZ2xvd1xuICAgICAgdGhpcy5nbG93KCk7XG5cbiAgICAgIHZhciBwYXRoID0gdGhpcy5jcmVhdGUoXCJwYXRoXCIpO1xuICAgICAgaWYodHlwZW9mIGF0dHJpYnV0ZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBWZXguTWVyZ2UoYXR0cmlidXRlcywgdGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgYXR0cmlidXRlcy5zdHJva2UgPSBcIm5vbmVcIjtcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlcy5kID0gdGhpcy5wYXRoO1xuXG4gICAgICB0aGlzLmFwcGx5QXR0cmlidXRlcyhwYXRoLCBhdHRyaWJ1dGVzKTtcbiAgICAgIHRoaXMuYWRkKHBhdGgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHN0cm9rZTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJZiBvdXIgY3VycmVudCBwYXRoIGlzIHNldCB0byBnbG93LCBtYWtlIGl0IGdsb3cuXG4gICAgICB0aGlzLmdsb3coKTtcblxuICAgICAgdmFyIHBhdGggPSB0aGlzLmNyZWF0ZShcInBhdGhcIik7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgVmV4Lk1lcmdlKGF0dHJpYnV0ZXMsIHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICBhdHRyaWJ1dGVzLmZpbGwgPSBcIm5vbmVcIjtcbiAgICAgIGF0dHJpYnV0ZXNbXCJzdHJva2Utd2lkdGhcIl0gPSB0aGlzLmxpbmVXaWR0aDtcbiAgICAgIGF0dHJpYnV0ZXMuZCA9IHRoaXMucGF0aDtcblxuICAgICAgdGhpcy5hcHBseUF0dHJpYnV0ZXMocGF0aCwgYXR0cmlidXRlcyk7XG4gICAgICB0aGlzLmFkZChwYXRoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyAjIyBUZXh0IE1ldGhvZHM6XG4gICAgbWVhc3VyZVRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBpbmRleCA9IHRleHQgKyB0aGlzLmF0dHJpYnV0ZXNbXCJmb250LXN0eWxlXCJdICsgdGhpcy5hdHRyaWJ1dGVzW1wiZm9udC1mYW1pbHlcIl0gK1xuICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW1wiZm9udC13ZWlnaHRcIl0gKyB0aGlzLmF0dHJpYnV0ZXNbXCJmb250LXNpemVcIl07XG5cbiAgICAgIHZhciB0eHQgPSB0aGlzLmNyZWF0ZShcInRleHRcIik7XG4gICAgICBpZiAodHlwZW9mKHR4dC5nZXRCQm94KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHR4dC50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIHRoaXMuYXBwbHlBdHRyaWJ1dGVzKHR4dCwgdGhpcy5hdHRyaWJ1dGVzKTtcblxuICAgICAgICAvLyBUZW1wb3JhcmlseSBhZGQgaXQgdG8gdGhlIGRvY3VtZW50IGZvciBtZWFzdXJlbWVudC5cbiAgICAgICAgdGhpcy5zdmcuYXBwZW5kQ2hpbGQodHh0KTtcblxuICAgICAgICB2YXIgYmJveCA9IHR4dC5nZXRCQm94KCk7XG4gICAgICAgIGlmKCB0aGlzLmllICYmXG4gICAgICAgICAgICB0ZXh0ICE9PSBcIlwiICYmXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbXCJmb250LXN0eWxlXCJdID09IFwiaXRhbGljXCIpIGJib3ggPSB0aGlzLmllTWVhc3VyZVRleHRGaXgoYmJveCwgdGV4dCk7XG4gICAgICAgIHRoaXMuc3ZnLnJlbW92ZUNoaWxkKHR4dCk7XG5cbiAgICAgICAgLy8gRm9yIHJ1bnRpbWVzIHRoYXQgZG8gbm90IGhhdmUgZnVsbCBzdXBwb3J0IG9mIGJvdW5kaW5nIGJveGVzLCBjb2xsZWN0XG4gICAgICAgIC8vIHNvbWUgZGF0YSB3aGljaCBjYW4gYmUgdXNlZCBsYXRlciB0byBleHRyYXBvbGF0ZSB0aGVtLlxuICAgICAgICBpZiAoU1ZHQ29udGV4dC5jb2xsZWN0TWVhc3VyZW1lbnRzKSB7XG4gICAgICAgICAgU1ZHQ29udGV4dC5tZWFzdXJlVGV4dENhY2hlW2luZGV4XSA9IHtcbiAgICAgICAgICAgIHg6IGJib3gueCxcbiAgICAgICAgICAgIHk6IGJib3gueSxcbiAgICAgICAgICAgIHdpZHRoOiBiYm94LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBiYm94LmhlaWdodFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFNWR0NvbnRleHQudmFsaWRhdGVNZWFzdXJlbWVudHMpIHtcbiAgICAgICAgICBpZiAoIShpbmRleCBpbiBTVkdDb250ZXh0Lm1lYXN1cmVUZXh0Q2FjaGUpKSB7XG4gICAgICAgICAgICBWZXguVyhcIm1lYXN1cmVUZXh0Q2FjaGUgaXMgc3RhbGUuIFBsZWFzZSB1cGRhdGUgdGVzdHMvbWVhc3VyZV90ZXh0X2NhY2hlLmpzOiBcIiwgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmJveDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluc2lkZSBOb2RlSlMgb3Igb3RoZXIgcnVudGltZXMgdGhhdCBkb24ndCBzdXBwb3J0IGdldEJCb3guIFRoaXNcbiAgICAgICAgLy8gaXMgY3VycmVudGx5IG9ubHkgdXNlZnVsIGZvciB0aGUgTm9kZUpTIHZpc3VhbCByZWdyZXNzaW9uIHRlc3RzLlxuICAgICAgICByZXR1cm4gU1ZHQ29udGV4dC5tZWFzdXJlVGV4dENhY2hlW2luZGV4XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaWVNZWFzdXJlVGV4dEZpeDogZnVuY3Rpb24oYmJveCwgdGV4dCkge1xuICAgIC8vIEludGVybmV0IEV4cGxvcmVyIG92ZXItcGFkcyB0ZXh0IGluIGl0YWxpY3MsXG4gICAgLy8gcmVzdWx0aW5nIGluIGdpYW50IHdpZHRoIGVzdGltYXRlcyBmb3IgbWVhc3VyZVRleHQuXG4gICAgLy8gVG8gZml4IHRoaXMsIHdlIHVzZSB0aGlzIGZvcm11bGEsIHRlc3RlZCBhZ2FpbnN0XG4gICAgLy8gaWUgMTE6XG4gICAgLy8gb3ZlcmVzdGltYXRlIChpbiBwaXhlbHMpID0gRm9udFNpemUoaW4gcHQpICogMS4xOTYgKyAxLjk2XG4gICAgLy8gQW5kIHRoZW4gc3VidHJhY3QgdGhlIG92ZXJlc3RpbWF0ZSBmcm9tIGNhbGN1bGF0ZWQgd2lkdGguXG5cbiAgICAgIHZhciBmb250U2l6ZSA9IE51bWJlcih0aGlzLmZvbnRTaXplKTtcbiAgICAgIHZhciBtID0gMS4xOTY7XG4gICAgICB2YXIgYiA9IDEuOTU5ODtcbiAgICAgIHZhciB3aWR0aENvcnJlY3Rpb24gPSAobSAqIGZvbnRTaXplKSArIGI7XG4gICAgICB2YXIgd2lkdGggPSBiYm94LndpZHRoIC0gd2lkdGhDb3JyZWN0aW9uO1xuICAgICAgdmFyIGhlaWdodCA9IGJib3guaGVpZ2h0IC0gMS41O1xuXG4gICAgICAvLyBHZXQgbm9uLXByb3RlY3RlZCBjb3B5OlxuICAgICAgdmFyIGJveCA9IHtcbiAgICAgICAgeCA6IGJib3gueCxcbiAgICAgICAgeSA6IGJib3gueSxcbiAgICAgICAgd2lkdGggOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0IDogaGVpZ2h0XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYm94O1xuICAgIH0sXG5cbiAgICBmaWxsVGV4dDogZnVuY3Rpb24odGV4dCwgeCwgeSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIFZleC5NZXJnZShhdHRyaWJ1dGVzLCB0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgYXR0cmlidXRlcy5zdHJva2UgPSBcIm5vbmVcIjtcbiAgICAgIGF0dHJpYnV0ZXMueCA9IHg7XG4gICAgICBhdHRyaWJ1dGVzLnkgPSB5O1xuXG4gICAgICB2YXIgdHh0ID0gdGhpcy5jcmVhdGUoXCJ0ZXh0XCIpO1xuICAgICAgdHh0LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgIHRoaXMuYXBwbHlBdHRyaWJ1dGVzKHR4dCwgYXR0cmlidXRlcyk7XG4gICAgICB0aGlzLmFkZCh0eHQpO1xuICAgIH0sXG5cbiAgICBzYXZlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRPRE8obW11dGhhbm5hKTogU3RhdGUgbmVlZHMgdG8gYmUgZGVlcC1jb3BpZWQuXG4gICAgICB0aGlzLnN0YXRlX3N0YWNrLnB1c2goe1xuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgIFwiZm9udC1mYW1pbHlcIjogdGhpcy5zdGF0ZVtcImZvbnQtZmFtaWx5XCJdLFxuICAgICAgICAgIFwiZm9udC13ZWlnaHRcIjogdGhpcy5zdGF0ZVtcImZvbnQtd2VpZ2h0XCJdLFxuICAgICAgICAgIFwiZm9udC1zdHlsZVwiOiB0aGlzLnN0YXRlW1wiZm9udC1zdHlsZVwiXSxcbiAgICAgICAgICBcImZvbnQtc2l6ZVwiOiB0aGlzLnN0YXRlW1wiZm9udC1zaXplXCJdXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBcImZvbnQtZmFtaWx5XCI6IHRoaXMuYXR0cmlidXRlc1tcImZvbnQtZmFtaWx5XCJdLFxuICAgICAgICAgIFwiZm9udC13ZWlnaHRcIjogdGhpcy5hdHRyaWJ1dGVzW1wiZm9udC13ZWlnaHRcIl0sXG4gICAgICAgICAgXCJmb250LXN0eWxlXCI6IHRoaXMuYXR0cmlidXRlc1tcImZvbnQtc3R5bGVcIl0sXG4gICAgICAgICAgXCJmb250LXNpemVcIjogdGhpcy5hdHRyaWJ1dGVzW1wiZm9udC1zaXplXCJdLFxuICAgICAgICAgIGZpbGw6IHRoaXMuYXR0cmlidXRlcy5maWxsLFxuICAgICAgICAgIHN0cm9rZTogdGhpcy5hdHRyaWJ1dGVzLnN0cm9rZSxcbiAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlzLmF0dHJpYnV0ZXNbXCJzdHJva2Utd2lkdGhcIl1cbiAgICAgICAgfSxcbiAgICAgICAgc2hhZG93X2F0dHJpYnV0ZXM6IHtcbiAgICAgICAgICB3aWR0aDogdGhpcy5zaGFkb3dfYXR0cmlidXRlcy53aWR0aCxcbiAgICAgICAgICBjb2xvcjogdGhpcy5zaGFkb3dfYXR0cmlidXRlcy5jb2xvclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZXN0b3JlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRPRE8oMHhmZSk6IFN0YXRlIG5lZWRzIHRvIGJlIGRlZXAtcmVzdG9yZWQuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlX3N0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5zdGF0ZVtcImZvbnQtZmFtaWx5XCJdID0gc3RhdGUuc3RhdGVbXCJmb250LWZhbWlseVwiXTtcbiAgICAgIHRoaXMuc3RhdGVbXCJmb250LXdlaWdodFwiXSA9IHN0YXRlLnN0YXRlW1wiZm9udC13ZWlnaHRcIl07XG4gICAgICB0aGlzLnN0YXRlW1wiZm9udC1zdHlsZVwiXSA9IHN0YXRlLnN0YXRlW1wiZm9udC1zdHlsZVwiXTtcbiAgICAgIHRoaXMuc3RhdGVbXCJmb250LXNpemVcIl0gPSBzdGF0ZS5zdGF0ZVtcImZvbnQtc2l6ZVwiXTtcblxuICAgICAgdGhpcy5hdHRyaWJ1dGVzW1wiZm9udC1mYW1pbHlcIl0gPSBzdGF0ZS5hdHRyaWJ1dGVzW1wiZm9udC1mYW1pbHlcIl07XG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbXCJmb250LXdlaWdodFwiXSA9IHN0YXRlLmF0dHJpYnV0ZXNbXCJmb250LXdlaWdodFwiXTtcbiAgICAgIHRoaXMuYXR0cmlidXRlc1tcImZvbnQtc3R5bGVcIl0gPSBzdGF0ZS5hdHRyaWJ1dGVzW1wiZm9udC1zdHlsZVwiXTtcbiAgICAgIHRoaXMuYXR0cmlidXRlc1tcImZvbnQtc2l6ZVwiXSA9IHN0YXRlLmF0dHJpYnV0ZXNbXCJmb250LXNpemVcIl07XG5cbiAgICAgIHRoaXMuYXR0cmlidXRlcy5maWxsID0gc3RhdGUuYXR0cmlidXRlcy5maWxsO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzLnN0cm9rZSA9IHN0YXRlLmF0dHJpYnV0ZXMuc3Ryb2tlO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW1wic3Ryb2tlLXdpZHRoXCJdID0gc3RhdGUuYXR0cmlidXRlc1tcInN0cm9rZS13aWR0aFwiXTtcbiAgICAgIHRoaXMuc2hhZG93X2F0dHJpYnV0ZXMud2lkdGggPSBzdGF0ZS5zaGFkb3dfYXR0cmlidXRlcy53aWR0aDtcbiAgICAgIHRoaXMuc2hhZG93X2F0dHJpYnV0ZXMuY29sb3IgPSBzdGF0ZS5zaGFkb3dfYXR0cmlidXRlcy5jb2xvcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU1ZHQ29udGV4dDtcbn0oKSk7XG5cbi8vIFZleCBGbG93XG4vLyBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy9cbi8vIEEgcmVuZGVyaW5nIGNvbnRleHQgZm9yIHRoZSBSYXBoYWVsIGJhY2tlbmQuXG4vL1xuLy8gQ29weXJpZ2h0IE1vaGl0IENoZXBwdWRpcmEgMjAxMFxuXG4vKiogQGNvbnN0cnVjdG9yICovXG5WZXguRmxvdy5DYW52YXNDb250ZXh0ID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBDYW52YXNDb250ZXh0KGNvbnRleHQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChjb250ZXh0KTtcbiAgfVxuXG4gIENhbnZhc0NvbnRleHQuV0lEVEggPSA2MDA7XG4gIENhbnZhc0NvbnRleHQuSEVJR0hUID0gNDAwO1xuXG4gIENhbnZhc0NvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIC8vIFVzZSBhIG5hbWUgdGhhdCBpcyB1bmxpa2VseSB0byBjbGFzaCB3aXRoIGEgY2FudmFzIGNvbnRleHRcbiAgICAgIC8vIHByb3BlcnR5XG4gICAgICB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIGlmICghY29udGV4dC5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSB7XG4gICAgICAgICAgd2lkdGg6IENhbnZhc0NvbnRleHQuV0lEVEgsXG4gICAgICAgICAgaGVpZ2h0OiBDYW52YXNDb250ZXh0LkhFSUdIVFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIC8vIENvbnRhaW5lcnMgbm90IGltcGxlbWVudGVkXG4gICAgb3Blbkdyb3VwOiBmdW5jdGlvbihjbHMsIGlkLCBhdHRycykge30sXG4gICAgY2xvc2VHcm91cDogZnVuY3Rpb24oKSB7fSxcbiAgICBhZGQ6IGZ1bmN0aW9uKGVsZW0pIHt9LFxuXG4gICAgc2V0Rm9udDogZnVuY3Rpb24oZmFtaWx5LCBzaXplLCB3ZWlnaHQpIHtcbiAgICAgIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuZm9udCA9ICh3ZWlnaHQgfHwgXCJcIikgKyBcIiBcIiArIHNpemUgKyBcInB0IFwiICsgZmFtaWx5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFJhd0ZvbnQ6IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICAgIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0RmlsbFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5maWxsU3R5bGUgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRCYWNrZ3JvdW5kRmlsbFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kX2ZpbGxTdHlsZSA9IHN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFN0cm9rZVN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5zdHJva2VTdHlsZSA9IHN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFNoYWRvd0NvbG9yOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5zaGFkb3dDb2xvciA9IHN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFNoYWRvd0JsdXI6IGZ1bmN0aW9uKGJsdXIpIHtcbiAgICAgIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuc2hhZG93Qmx1ciA9IGJsdXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0TGluZVdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRMaW5lQ2FwOiBmdW5jdGlvbihjYXBfdHlwZSkge1xuICAgICAgdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5saW5lQ2FwID0gY2FwX3R5cGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0TGluZURhc2g6IGZ1bmN0aW9uKGRhc2gpIHtcbiAgICAgIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQubGluZURhc2ggPSBkYXNoO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuc2NhbGUocGFyc2VGbG9hdCh4KSwgcGFyc2VGbG9hdCh5KSk7XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQucmVzaXplKFxuICAgICAgICAgIHBhcnNlSW50KHdpZHRoLCAxMCksIHBhcnNlSW50KGhlaWdodCwgMTApKTtcbiAgICB9LFxuXG4gICAgcmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZmlsbFJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0LmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICBjbGVhclJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0LmNsZWFyUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgYmVnaW5QYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH0sXG5cbiAgICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICB9LFxuXG4gICAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgfSxcblxuICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5iZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB4LCB5KTtcbiAgICB9LFxuXG4gICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHgxLCB5MSwgeCwgeSk7XG4gICAgfSxcblxuICAgIC8vIFRoaXMgaXMgYW4gYXR0ZW1wdCAoaGFjaykgdG8gc2ltdWxhdGUgdGhlIEhUTUw1IGNhbnZhc1xuICAgIC8vIGFyYyBtZXRob2QuXG4gICAgYXJjOiBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpQ2xvY2t3aXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5hcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aUNsb2Nrd2lzZSk7XG4gICAgfSxcblxuICAgIC8vIEFkYXB0ZWQgZnJvbSB0aGUgc291cmNlIGZvciBSYXBoYWVsJ3MgRWxlbWVudC5nbG93XG4gICAgZ2xvdzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5nbG93KCk7XG4gICAgfSxcblxuICAgIGZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuZmlsbCgpO1xuICAgIH0sXG5cbiAgICBzdHJva2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgfSxcblxuICAgIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgbWVhc3VyZVRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgIH0sXG5cbiAgICBmaWxsVGV4dDogZnVuY3Rpb24odGV4dCwgeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuZmlsbFRleHQodGV4dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHNhdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuc2F2ZSgpO1xuICAgIH0sXG5cbiAgICByZXN0b3JlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc0NvbnRleHQ7XG59KCkpO1xuXG4vLyBWZXggRmxvdyBOb3RhdGlvblxuLy8gQXV0aG9yIExhcnJ5IEt1aG5zIDIwMTFcbi8vIEltcGxlbWVudHMgYmFybGluZXMgKHNpbmdsZSwgZG91YmxlLCByZXBlYXQsIGVuZClcbi8vXG4vLyBSZXF1aXJlcyB2ZXguanMuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblZleC5GbG93LkJhcmxpbmUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEJhcmxpbmUodHlwZSwgeCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHR5cGUsIHgpO1xuICB9XG5cbiAgQmFybGluZS50eXBlID0ge1xuICAgIFNJTkdMRTogMSxcbiAgICBET1VCTEU6IDIsXG4gICAgRU5EOiAzLFxuICAgIFJFUEVBVF9CRUdJTjogNCxcbiAgICBSRVBFQVRfRU5EOiA1LFxuICAgIFJFUEVBVF9CT1RIOiA2LFxuICAgIE5PTkU6IDdcbiAgfTtcblxuICBWZXguSW5oZXJpdChCYXJsaW5lLCBWZXguRmxvdy5TdGF2ZU1vZGlmaWVyLCB7XG4gICAgaW5pdDogZnVuY3Rpb24odHlwZSwgeCkge1xuICAgICAgQmFybGluZS5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMudGhpY2tuZXNzID0gVmV4LkZsb3cuU1RBVkVfTElORV9USElDS05FU1M7XG4gICAgICB0aGlzLmJhcmxpbmUgPSB0eXBlO1xuICAgICAgdGhpcy54ID0geDsgICAgLy8gTGVmdCBtb3N0IHggZm9yIHRoZSBzdGF2ZVxuICAgIH0sXG5cbiAgICBnZXRDYXRlZ29yeTogZnVuY3Rpb24oKSB7IHJldHVybiBcImJhcmxpbmVzXCI7IH0sXG4gICAgc2V0WDogZnVuY3Rpb24oeCkgeyB0aGlzLnggPSB4OyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIERyYXcgYmFybGluZXNcbiAgICBkcmF3OiBmdW5jdGlvbihzdGF2ZSwgeF9zaGlmdCkge1xuICAgICAgeF9zaGlmdCA9IHR5cGVvZiB4X3NoaWZ0ICE9PSAnbnVtYmVyJyA/IDAgOiB4X3NoaWZ0O1xuXG4gICAgICBzd2l0Y2ggKHRoaXMuYmFybGluZSkge1xuICAgICAgICBjYXNlIEJhcmxpbmUudHlwZS5TSU5HTEU6XG4gICAgICAgICAgdGhpcy5kcmF3VmVydGljYWxCYXIoc3RhdmUsIHRoaXMueCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJhcmxpbmUudHlwZS5ET1VCTEU6XG4gICAgICAgICAgdGhpcy5kcmF3VmVydGljYWxCYXIoc3RhdmUsIHRoaXMueCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQmFybGluZS50eXBlLkVORDpcbiAgICAgICAgICB0aGlzLmRyYXdWZXJ0aWNhbEVuZEJhcihzdGF2ZSwgdGhpcy54KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCYXJsaW5lLnR5cGUuUkVQRUFUX0JFR0lOOlxuICAgICAgICAgIC8vIElmIHRoZSBiYXJsaW5lIGlzIHNoaWZ0ZWQgb3ZlciAoaW4gZnJvbnQgb2YgY2xlZi90aW1lL2tleSlcbiAgICAgICAgICAvLyBEcmF3IHZlcnRpY2FsIGJhciBhdCB0aGUgYmVnaW5uaW5nLlxuICAgICAgICAgIGlmICh4X3NoaWZ0ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3VmVydGljYWxCYXIoc3RhdmUsIHRoaXMueCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZHJhd1JlcGVhdEJhcihzdGF2ZSwgdGhpcy54ICsgeF9zaGlmdCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQmFybGluZS50eXBlLlJFUEVBVF9FTkQ6XG4gICAgICAgICAgdGhpcy5kcmF3UmVwZWF0QmFyKHN0YXZlLCB0aGlzLngsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCYXJsaW5lLnR5cGUuUkVQRUFUX0JPVEg6XG4gICAgICAgICAgdGhpcy5kcmF3UmVwZWF0QmFyKHN0YXZlLCB0aGlzLngsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLmRyYXdSZXBlYXRCYXIoc3RhdmUsIHRoaXMueCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gRGVmYXVsdCBpcyBOT05FLCBzbyBub3RoaW5nIHRvIGRyYXdcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZHJhd1ZlcnRpY2FsQmFyOiBmdW5jdGlvbihzdGF2ZSwgeCwgZG91YmxlX2Jhcikge1xuICAgICAgaWYgKCFzdGF2ZS5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgc3RhdmUgd2l0aG91dCBjYW52YXMgY29udGV4dC5cIik7XG4gICAgICB2YXIgdG9wWSA9IHN0YXZlLmdldFlGb3JMaW5lKDApO1xuICAgICAgdmFyIGJvdFkgPSBzdGF2ZS5nZXRZRm9yTGluZShzdGF2ZS5nZXROdW1MaW5lcygpIC0gMSkgKyB0aGlzLnRoaWNrbmVzcztcbiAgICAgIGlmIChkb3VibGVfYmFyKVxuICAgICAgICBzdGF2ZS5jb250ZXh0LmZpbGxSZWN0KHggLSAzLCB0b3BZLCAxLCBib3RZIC0gdG9wWSk7XG4gICAgICBzdGF2ZS5jb250ZXh0LmZpbGxSZWN0KHgsIHRvcFksIDEsIGJvdFkgLSB0b3BZKTtcbiAgICB9LFxuXG4gICAgZHJhd1ZlcnRpY2FsRW5kQmFyOiBmdW5jdGlvbihzdGF2ZSwgeCkge1xuICAgICAgaWYgKCFzdGF2ZS5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgc3RhdmUgd2l0aG91dCBjYW52YXMgY29udGV4dC5cIik7XG5cbiAgICAgIHZhciB0b3BZID0gc3RhdmUuZ2V0WUZvckxpbmUoMCk7XG4gICAgICB2YXIgYm90WSA9IHN0YXZlLmdldFlGb3JMaW5lKHN0YXZlLmdldE51bUxpbmVzKCkgLSAxKSArIHRoaXMudGhpY2tuZXNzO1xuICAgICAgc3RhdmUuY29udGV4dC5maWxsUmVjdCh4IC0gNSwgdG9wWSwgMSwgYm90WSAtIHRvcFkpO1xuICAgICAgc3RhdmUuY29udGV4dC5maWxsUmVjdCh4IC0gMiwgdG9wWSwgMywgYm90WSAtIHRvcFkpO1xuICAgIH0sXG5cbiAgICBkcmF3UmVwZWF0QmFyOiBmdW5jdGlvbihzdGF2ZSwgeCwgYmVnaW4pIHtcbiAgICAgIGlmICghc3RhdmUuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHN0YXZlIHdpdGhvdXQgY2FudmFzIGNvbnRleHQuXCIpO1xuXG4gICAgICB2YXIgdG9wWSA9IHN0YXZlLmdldFlGb3JMaW5lKDApO1xuICAgICAgdmFyIGJvdFkgPSBzdGF2ZS5nZXRZRm9yTGluZShzdGF2ZS5nZXROdW1MaW5lcygpIC0gMSkgKyB0aGlzLnRoaWNrbmVzcztcbiAgICAgIHZhciB4X3NoaWZ0ID0gMztcblxuICAgICAgaWYgKCFiZWdpbikge1xuICAgICAgICB4X3NoaWZ0ID0gLTU7XG4gICAgICB9XG5cbiAgICAgIHN0YXZlLmNvbnRleHQuZmlsbFJlY3QoeCArIHhfc2hpZnQsIHRvcFksIDEsIGJvdFkgLSB0b3BZKTtcbiAgICAgIHN0YXZlLmNvbnRleHQuZmlsbFJlY3QoeCAtIDIsIHRvcFksIDMsIGJvdFkgLSB0b3BZKTtcblxuICAgICAgdmFyIGRvdF9yYWRpdXMgPSAyO1xuXG4gICAgICAvLyBTaGlmdCBkb3RzIGxlZnQgb3IgcmlnaHRcbiAgICAgIGlmIChiZWdpbikge1xuICAgICAgICB4X3NoaWZ0ICs9IDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4X3NoaWZ0IC09IDQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBkb3RfeCA9ICh4ICsgeF9zaGlmdCkgKyAoZG90X3JhZGl1cyAvIDIpO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIHkgb2Zmc2V0IGJhc2VkIG9uIG51bWJlciBvZiBzdGF2ZSBsaW5lc1xuICAgICAgdmFyIHlfb2Zmc2V0ID0gKHN0YXZlLmdldE51bUxpbmVzKCkgLSAxKSAqXG4gICAgICAgIHN0YXZlLmdldFNwYWNpbmdCZXR3ZWVuTGluZXMoKTtcbiAgICAgIHlfb2Zmc2V0ID0gKHlfb2Zmc2V0IC8gMikgLVxuICAgICAgICAgICAgICAgICAoc3RhdmUuZ2V0U3BhY2luZ0JldHdlZW5MaW5lcygpIC8gMik7XG4gICAgICB2YXIgZG90X3kgPSB0b3BZICsgeV9vZmZzZXQgKyAoZG90X3JhZGl1cyAvIDIpO1xuXG4gICAgICAvLyBkcmF3IHRoZSB0b3AgcmVwZWF0IGRvdFxuICAgICAgc3RhdmUuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIHN0YXZlLmNvbnRleHQuYXJjKGRvdF94LCBkb3RfeSwgZG90X3JhZGl1cywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICAgIHN0YXZlLmNvbnRleHQuZmlsbCgpO1xuXG4gICAgICAvL2RyYXcgdGhlIGJvdHRvbSByZXBlYXQgZG90XG4gICAgICBkb3RfeSArPSBzdGF2ZS5nZXRTcGFjaW5nQmV0d2VlbkxpbmVzKCk7XG4gICAgICBzdGF2ZS5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgc3RhdmUuY29udGV4dC5hcmMoZG90X3gsIGRvdF95LCBkb3RfcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgc3RhdmUuY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQmFybGluZTtcbn0oKSk7XG5cbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy8gVGhpcyBjbGFzcyBieSBSYWZmYWVsZSBWaWdsaWFudGksIDIwMTIgaHR0cDovL2l0aXNub3Rzb3VuZC53b3JkcHJlc3MuY29tL1xuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBoYWlycGlucyBiZXR3ZWVuIG5vdGVzLlxuLy8gSGFpcnBpbnMgY2FuIGJlIGVpdGhlciBDcmVzY2VuZG8gb3IgRGVzY3Jlc2NlbmRvLlxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBoYWlycGluIGZyb20gdGhlIHNwZWNpZmllZCBub3Rlcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7IU9iamVjdH0gbm90ZXMgVGhlIG5vdGVzIHRvIHRpZSB1cC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gdHlwZSBUaGUgdHlwZSBvZiBoYWlycGluXG4gKi9cblZleC5GbG93LlN0YXZlSGFpcnBpbiA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gU3RhdmVIYWlycGluKG5vdGVzLCB0eXBlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQobm90ZXMsIHR5cGUpO1xuICB9XG5cbiAgU3RhdmVIYWlycGluLnR5cGUgPSB7XG4gICAgQ1JFU0M6IDEsXG4gICAgREVDUkVTQzogMlxuICB9O1xuXG4gIC8qIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IHRpY2tzIGludG8gcGl4ZWxzLlxuICAgKiBSZXF1aXJlcyBhIEZvcm1hdHRlciB3aXRoIHZvaWNlcyBqb2luZWQgYW5kIGZvcm1hdHRlZCAodG9cbiAgICogZ2V0IHBpeGVscyBwZXIgdGljaylcbiAgICpcbiAgICogb3B0aW9ucyBpcyBzdHJ1Y3QgdGhhdCBoYXM6XG4gICAqXG4gICAqICB7XG4gICAqICAgaGVpZ2h0OiBweCxcbiAgICogICB5X3NoaWZ0OiBweCwgLy92ZXJ0aWNhbCBvZmZzZXRcbiAgICogICBsZWZ0X3NoaWZ0X3RpY2tzOiAwLCAvL2xlZnQgaG9yaXpvbnRhbCBvZmZzZXQgZXhwcmVzc2VkIGluIHRpY2tzXG4gICAqICAgcmlnaHRfc2hpZnRfdGlja3M6IDAgLy8gcmlnaHQgaG9yaXpvbnRhbCBvZmZzZXQgZXhwcmVzc2VkIGluIHRpY2tzXG4gICAqICB9XG4gICAqXG4gICAqKi9cbiAgU3RhdmVIYWlycGluLkZvcm1hdEJ5VGlja3NBbmREcmF3ID0gZnVuY3Rpb24oY3R4LCBmb3JtYXR0ZXIsIG5vdGVzLCB0eXBlLCBwb3NpdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBwcHQgPSBmb3JtYXR0ZXIucGl4ZWxzUGVyVGljaztcblxuICAgIGlmIChwcHQgPT0gbnVsbCl7XG4gICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLFxuICAgICAgICAgIFwiQSB2YWxpZCBGb3JtYXR0ZXIgbXVzdCBiZSBwcm92aWRlIHRvIGRyYXcgb2Zmc2V0cyBieSB0aWNrcy5cIik7fVxuXG4gICAgdmFyIGxfc2hpZnRfcHggPSBwcHQgKiBvcHRpb25zLmxlZnRfc2hpZnRfdGlja3M7XG4gICAgdmFyIHJfc2hpZnRfcHggPSBwcHQgKiBvcHRpb25zLnJpZ2h0X3NoaWZ0X3RpY2tzO1xuXG4gICAgdmFyIGhhaXJwaW5fb3B0aW9ucyA9IHtcbiAgICAgIGhlaWdodDogb3B0aW9ucy5oZWlnaHQsXG4gICAgICB5X3NoaWZ0Om9wdGlvbnMueV9zaGlmdCxcbiAgICAgIGxlZnRfc2hpZnRfcHg6bF9zaGlmdF9weCxcbiAgICAgIHJpZ2h0X3NoaWZ0X3B4OnJfc2hpZnRfcHh9O1xuXG4gICAgbmV3IFN0YXZlSGFpcnBpbih7XG4gICAgICBmaXJzdF9ub3RlOiBub3Rlcy5maXJzdF9ub3RlLFxuICAgICAgbGFzdF9ub3RlOiBub3Rlcy5sYXN0X25vdGVcbiAgICB9LCB0eXBlKVxuICAgICAgLnNldENvbnRleHQoY3R4KVxuICAgICAgLnNldFJlbmRlck9wdGlvbnMoaGFpcnBpbl9vcHRpb25zKVxuICAgICAgLnNldFBvc2l0aW9uKHBvc2l0aW9uKVxuICAgICAgLmRyYXcoKTtcbiAgfTtcblxuICBTdGF2ZUhhaXJwaW4ucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG5vdGVzLCB0eXBlKSB7XG4gICAgICAvKipcbiAgICAgICAqIE5vdGVzIGlzIGEgc3RydWN0IHRoYXQgaGFzOlxuICAgICAgICpcbiAgICAgICAqICB7XG4gICAgICAgKiAgICBmaXJzdF9ub3RlOiBOb3RlLFxuICAgICAgICogICAgbGFzdF9ub3RlOiBOb3RlLFxuICAgICAgICogIH1cbiAgICAgICAqXG4gICAgICAgKiovXG5cbiAgICAgIHRoaXMubm90ZXMgPSBub3RlcztcbiAgICAgIHRoaXMuaGFpcnBpbiA9IHR5cGU7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uQkVMT1c7XG5cbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG5cbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMgPSB7XG4gICAgICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgICAgICB5X3NoaWZ0OiAwLCAvL3ZlcnRpY2FsIG9mZnNldFxuICAgICAgICAgIGxlZnRfc2hpZnRfcHg6IDAsIC8vbGVmdCBob3Jpem9udGFsIG9mZnNldFxuICAgICAgICAgIHJpZ2h0X3NoaWZ0X3B4OiAwIC8vIHJpZ2h0IGhvcml6b250YWwgb2Zmc2V0XG4gICAgICAgIH07XG5cbiAgICAgIHRoaXMuc2V0Tm90ZXMobm90ZXMpO1xuICAgIH0sXG5cbiAgICBzZXRDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7IHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT0gVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uQUJPVkUgfHxcbiAgICAgICAgICBwb3NpdGlvbiA9PSBWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5CRUxPVylcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFJlbmRlck9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmhlaWdodCAhPSBudWxsICYmXG4gICAgICAgICAgb3B0aW9ucy55X3NoaWZ0ICE9IG51bGwgJiZcbiAgICAgICAgICBvcHRpb25zLmxlZnRfc2hpZnRfcHggIT0gbnVsbCAmJlxuICAgICAgICAgIG9wdGlvbnMucmlnaHRfc2hpZnRfcHggIT0gbnVsbCl7XG4gICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbm90ZXMgdG8gYXR0YWNoIHRoaXMgaGFpcnBpbiB0by5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gbm90ZXMgVGhlIHN0YXJ0IGFuZCBlbmQgbm90ZXMuXG4gICAgICovXG4gICAgc2V0Tm90ZXM6IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgICBpZiAoIW5vdGVzLmZpcnN0X25vdGUgJiYgIW5vdGVzLmxhc3Rfbm90ZSlcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgIFwiSGFpcnBpbiBuZWVkcyB0byBoYXZlIGVpdGhlciBmaXJzdF9ub3RlIG9yIGxhc3Rfbm90ZSBzZXQuXCIpO1xuXG4gICAgICAvLyBTdWNjZXNzLiBMZXRzIGdyYWIgJ2VtIG5vdGVzLlxuICAgICAgdGhpcy5maXJzdF9ub3RlID0gbm90ZXMuZmlyc3Rfbm90ZTtcbiAgICAgIHRoaXMubGFzdF9ub3RlID0gbm90ZXMubGFzdF9ub3RlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbmRlckhhaXJwaW46IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciBkaXMgPSB0aGlzLnJlbmRlcl9vcHRpb25zLnlfc2hpZnQgKyAyMDtcbiAgICAgIHZhciB5X3NoaWZ0ID0gcGFyYW1zLmZpcnN0X3k7XG5cbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFKSB7XG4gICAgICAgIGRpcyA9IC1kaXMgKzMwO1xuICAgICAgICB5X3NoaWZ0ID0gcGFyYW1zLmZpcnN0X3kgLSBwYXJhbXMuc3RhZmZfaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB2YXIgbF9zaGlmdCA9IHRoaXMucmVuZGVyX29wdGlvbnMubGVmdF9zaGlmdF9weDtcbiAgICAgIHZhciByX3NoaWZ0ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5yaWdodF9zaGlmdF9weDtcblxuICAgICAgc3dpdGNoICh0aGlzLmhhaXJwaW4pIHtcbiAgICAgICAgY2FzZSBTdGF2ZUhhaXJwaW4udHlwZS5DUkVTQzpcbiAgICAgICAgICBjdHgubW92ZVRvKHBhcmFtcy5sYXN0X3ggKyByX3NoaWZ0LCB5X3NoaWZ0ICsgZGlzKTtcbiAgICAgICAgICBjdHgubGluZVRvKHBhcmFtcy5maXJzdF94ICsgbF9zaGlmdCwgeV9zaGlmdCArKHRoaXMucmVuZGVyX29wdGlvbnMuaGVpZ2h0LzIpICsgZGlzKTtcbiAgICAgICAgICBjdHgubGluZVRvKHBhcmFtcy5sYXN0X3ggKyByX3NoaWZ0LCB5X3NoaWZ0ICsgdGhpcy5yZW5kZXJfb3B0aW9ucy5oZWlnaHQgKyBkaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN0YXZlSGFpcnBpbi50eXBlLkRFQ1JFU0M6XG4gICAgICAgICAgY3R4Lm1vdmVUbyhwYXJhbXMuZmlyc3RfeCArIGxfc2hpZnQsIHlfc2hpZnQgKyBkaXMpO1xuICAgICAgICAgIGN0eC5saW5lVG8ocGFyYW1zLmxhc3RfeCArIHJfc2hpZnQsIHlfc2hpZnQgKyh0aGlzLnJlbmRlcl9vcHRpb25zLmhlaWdodC8yKSArIGRpcyk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhwYXJhbXMuZmlyc3RfeCArIGxfc2hpZnQsIHlfc2hpZnQgKyB0aGlzLnJlbmRlcl9vcHRpb25zLmhlaWdodCArIGRpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gRGVmYXVsdCBpcyBOT05FLCBzbyBub3RoaW5nIHRvIGRyYXdcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IEhhaXJwaW4gd2l0aG91dCBhIGNvbnRleHQuXCIpO1xuXG4gICAgICB2YXIgZmlyc3Rfbm90ZSA9IHRoaXMuZmlyc3Rfbm90ZTtcbiAgICAgIHZhciBsYXN0X25vdGUgPSB0aGlzLmxhc3Rfbm90ZTtcblxuICAgICAgdmFyIHN0YXJ0ID0gZmlyc3Rfbm90ZS5nZXRNb2RpZmllclN0YXJ0WFkodGhpcy5wb3NpdGlvbiwgMCk7XG4gICAgICB2YXIgZW5kID0gbGFzdF9ub3RlLmdldE1vZGlmaWVyU3RhcnRYWSh0aGlzLnBvc2l0aW9uLCAwKTtcblxuICAgICAgdGhpcy5yZW5kZXJIYWlycGluKHtcbiAgICAgICAgZmlyc3RfeDogc3RhcnQueCxcbiAgICAgICAgbGFzdF94OiBlbmQueCxcbiAgICAgICAgZmlyc3RfeTogZmlyc3Rfbm90ZS5nZXRTdGF2ZSgpLnkgKyBmaXJzdF9ub3RlLmdldFN0YXZlKCkuaGVpZ2h0LFxuICAgICAgICBsYXN0X3k6IGxhc3Rfbm90ZS5nZXRTdGF2ZSgpLnkgKyBsYXN0X25vdGUuZ2V0U3RhdmUoKS5oZWlnaHQsXG4gICAgICAgIHN0YWZmX2hlaWdodDogZmlyc3Rfbm90ZS5nZXRTdGF2ZSgpLmhlaWdodFxuICAgICAgfSk7XG4gICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFN0YXZlSGFpcnBpbjtcbn0oKSk7XG5cblxuLy8gVmV4IEZsb3cgTm90YXRpb25cbi8vIEF1dGhvciBMYXJyeSBLdWhucyAyMDExXG4vLyBJbXBsZW1lbnRzIHZvbHRhcyAocmVwZWF0IGJyYWNrZXRzKVxuLy9cbi8vIFJlcXVpcmVzIHZleC5qcy5cblxuVmV4LkZsb3cuVm9sdGEgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFZvbHRhKHR5cGUsIG51bWJlciwgeCwgeV9zaGlmdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHR5cGUsIG51bWJlciwgeCwgeV9zaGlmdCk7XG4gIH1cblxuICBWb2x0YS50eXBlID0ge1xuICAgIE5PTkU6IDEsXG4gICAgQkVHSU46IDIsXG4gICAgTUlEOiAzLFxuICAgIEVORDogNCxcbiAgICBCRUdJTl9FTkQ6IDVcbiAgfTtcblxuICBWZXguSW5oZXJpdChWb2x0YSwgVmV4LkZsb3cuU3RhdmVNb2RpZmllciwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKHR5cGUsIG51bWJlciwgeCwgeV9zaGlmdCkge1xuICAgICAgVm9sdGEuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcyk7XG5cbiAgICAgIHRoaXMudm9sdGEgPSB0eXBlO1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueV9zaGlmdCA9IHlfc2hpZnQ7XG4gICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICAgIHRoaXMuZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiBcInNhbnMtc2VyaWZcIixcbiAgICAgICAgc2l6ZTogOSxcbiAgICAgICAgd2VpZ2h0OiBcImJvbGRcIlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJ2b2x0YXNcIjsgfSxcbiAgICBzZXRTaGlmdFk6IGZ1bmN0aW9uKHkpIHsgdGhpcy55X3NoaWZ0ID0geTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbihzdGF2ZSwgeCkge1xuICAgICAgaWYgKCFzdGF2ZS5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IHN0YXZlIHdpdGhvdXQgY2FudmFzIGNvbnRleHQuXCIpO1xuICAgICAgdmFyIGN0eCA9IHN0YXZlLmNvbnRleHQ7XG4gICAgICB2YXIgd2lkdGggPSBzdGF2ZS53aWR0aDtcbiAgICAgIHZhciB0b3BfeSA9IHN0YXZlLmdldFlGb3JUb3BUZXh0KHN0YXZlLm9wdGlvbnMubnVtX2xpbmVzKSArIHRoaXMueV9zaGlmdDtcbiAgICAgIHZhciB2ZXJ0X2hlaWdodCA9IDEuNSAqIHN0YXZlLm9wdGlvbnMuc3BhY2luZ19iZXR3ZWVuX2xpbmVzX3B4O1xuICAgICAgc3dpdGNoKHRoaXMudm9sdGEpIHtcbiAgICAgICAgY2FzZSBWZXguRmxvdy5Wb2x0YS50eXBlLkJFR0lOOlxuICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnggKyB4LCB0b3BfeSwgMSwgdmVydF9oZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFZleC5GbG93LlZvbHRhLnR5cGUuRU5EOlxuICAgICAgICAgIHdpZHRoIC09IDU7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHRoaXMueCArIHggKyB3aWR0aCwgdG9wX3ksIDEsIHZlcnRfaGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBWZXguRmxvdy5Wb2x0YS50eXBlLkJFR0lOX0VORDpcbiAgICAgICAgICB3aWR0aCAtPSAzO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnggKyB4LCB0b3BfeSwgMSwgdmVydF9oZWlnaHQpO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnggKyB4ICsgd2lkdGgsIHRvcF95LCAxLCB2ZXJ0X2hlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBiZWdpbm5pbmcgb2YgYSB2b2x0YSwgZHJhdyBtZWFzdXJlIG51bWJlclxuICAgICAgaWYgKHRoaXMudm9sdGEgPT0gVm9sdGEudHlwZS5CRUdJTiB8fFxuICAgICAgICAgIHRoaXMudm9sdGEgPT0gVm9sdGEudHlwZS5CRUdJTl9FTkQpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnNldEZvbnQodGhpcy5mb250LmZhbWlseSwgdGhpcy5mb250LnNpemUsIHRoaXMuZm9udC53ZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFRleHQodGhpcy5udW1iZXIsIHRoaXMueCArIHggKyA1LCB0b3BfeSArIDE1KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnggKyB4LCB0b3BfeSwgd2lkdGgsIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gVm9sdGE7XG59KCkpO1xuLy8gVmV4IEZsb3cgTm90YXRpb25cbi8vIEF1dGhvciBMYXJyeSBLdWhucyAyMDExXG4vLyBJbXBsZW1lbnRzIFJlcGV0aXRpb25zIChDb2RhLCBzaWdubywgRC5DLiwgZXRjLilcbi8vXG4vLyBSZXF1aXJlcyB2ZXguanMuXG5cblZleC5GbG93LlJlcGV0aXRpb24gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFJlcGV0aXRpb24odHlwZSwgeCwgeV9zaGlmdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHR5cGUsIHgsIHlfc2hpZnQpO1xuICB9XG5cbiAgUmVwZXRpdGlvbi50eXBlID0ge1xuICAgIE5PTkU6IDEsICAgICAgICAgLy8gbm8gY29kYSBvciBzZWdub1xuICAgIENPREFfTEVGVDogMiwgICAgLy8gY29kYSBhdCBiZWdpbm5pbmcgb2Ygc3RhdmVcbiAgICBDT0RBX1JJR0hUOiAzLCAgIC8vIGNvZGEgYXQgZW5kIG9mIHN0YXZlXG4gICAgU0VHTk9fTEVGVDogNCwgICAvLyBzZWdubyBhdCBiZWdpbm5pbmcgb2Ygc3RhdmVcbiAgICBTRUdOT19SSUdIVDogNSwgIC8vIHNlZ25vIGF0IGVuZCBvZiBzdGF2ZVxuICAgIERDOiA2LCAgICAgICAgICAgLy8gRC5DLiBhdCBlbmQgb2Ygc3RhdmVcbiAgICBEQ19BTF9DT0RBOiA3LCAgIC8vIEQuQy4gYWwgY29kYSBhdCBlbmQgb2Ygc3RhdmVcbiAgICBEQ19BTF9GSU5FOiA4LCAgIC8vIEQuQy4gYWwgRmluZSBlbmQgb2Ygc3RhdmVcbiAgICBEUzogOSwgICAgICAgICAgIC8vIEQuUy4gYXQgZW5kIG9mIHN0YXZlXG4gICAgRFNfQUxfQ09EQTogMTAsICAvLyBELlMuIGFsIGNvZGEgYXQgZW5kIG9mIHN0YXZlXG4gICAgRFNfQUxfRklORTogMTEsICAvLyBELlMuIGFsIEZpbmUgYXQgZW5kIG9mIHN0YXZlXG4gICAgRklORTogMTIgICAgICAgICAvLyBGaW5lIGF0IGVuZCBvZiBzdGF2ZVxuICB9O1xuXG4gIFZleC5Jbmhlcml0KFJlcGV0aXRpb24sIFZleC5GbG93LlN0YXZlTW9kaWZpZXIsIHtcbiAgICBpbml0OiBmdW5jdGlvbih0eXBlLCB4LCB5X3NoaWZ0KSB7XG4gICAgICBSZXBldGl0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLnN5bWJvbF90eXBlID0gdHlwZTtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnhfc2hpZnQgPSAwO1xuICAgICAgdGhpcy55X3NoaWZ0ID0geV9zaGlmdDtcbiAgICAgIHRoaXMuZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiBcInRpbWVzXCIsXG4gICAgICAgIHNpemU6IDEyLFxuICAgICAgICB3ZWlnaHQ6IFwiYm9sZCBpdGFsaWNcIlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJyZXBldGl0aW9uc1wiOyB9LFxuICAgIHNldFNoaWZ0WDogZnVuY3Rpb24oeCkgeyB0aGlzLnhfc2hpZnQgPSB4OyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRTaGlmdFk6IGZ1bmN0aW9uKHkpIHsgdGhpcy55X3NoaWZ0ID0geTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbihzdGF2ZSwgeCkge1xuICAgICAgc3dpdGNoICh0aGlzLnN5bWJvbF90eXBlKSB7XG4gICAgICAgIGNhc2UgUmVwZXRpdGlvbi50eXBlLkNPREFfUklHSFQ6XG4gICAgICAgICAgdGhpcy5kcmF3Q29kYUZpeGVkKHN0YXZlLCB4ICsgc3RhdmUud2lkdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlcGV0aXRpb24udHlwZS5DT0RBX0xFRlQ6XG4gICAgICAgICAgdGhpcy5kcmF3U3ltYm9sVGV4dChzdGF2ZSwgeCwgXCJDb2RhXCIsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlcGV0aXRpb24udHlwZS5TRUdOT19MRUZUOlxuICAgICAgICAgIHRoaXMuZHJhd1NpZ25vRml4ZWQoc3RhdmUsIHgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlcGV0aXRpb24udHlwZS5TRUdOT19SSUdIVDpcbiAgICAgICAgICB0aGlzLmRyYXdTaWdub0ZpeGVkKHN0YXZlLCB4ICsgc3RhdmUud2lkdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlcGV0aXRpb24udHlwZS5EQzpcbiAgICAgICAgICB0aGlzLmRyYXdTeW1ib2xUZXh0KHN0YXZlLCB4LCBcIkQuQy5cIiwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlcGV0aXRpb24udHlwZS5EQ19BTF9DT0RBOlxuICAgICAgICAgIHRoaXMuZHJhd1N5bWJvbFRleHQoc3RhdmUsIHgsIFwiRC5DLiBhbFwiLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZXBldGl0aW9uLnR5cGUuRENfQUxfRklORTpcbiAgICAgICAgICB0aGlzLmRyYXdTeW1ib2xUZXh0KHN0YXZlLCB4LCBcIkQuQy4gYWwgRmluZVwiLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVwZXRpdGlvbi50eXBlLkRTOlxuICAgICAgICAgIHRoaXMuZHJhd1N5bWJvbFRleHQoc3RhdmUsIHgsIFwiRC5TLlwiLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVwZXRpdGlvbi50eXBlLkRTX0FMX0NPREE6XG4gICAgICAgICAgdGhpcy5kcmF3U3ltYm9sVGV4dChzdGF2ZSwgeCwgXCJELlMuIGFsXCIsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlcGV0aXRpb24udHlwZS5EU19BTF9GSU5FOlxuICAgICAgICAgIHRoaXMuZHJhd1N5bWJvbFRleHQoc3RhdmUsIHgsIFwiRC5TLiBhbCBGaW5lXCIsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZXBldGl0aW9uLnR5cGUuRklORTpcbiAgICAgICAgICB0aGlzLmRyYXdTeW1ib2xUZXh0KHN0YXZlLCB4LCBcIkZpbmVcIiwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZHJhd0NvZGFGaXhlZDogZnVuY3Rpb24oc3RhdmUsIHgpIHtcbiAgICAgIGlmICghc3RhdmUuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHN0YXZlIHdpdGhvdXQgY2FudmFzIGNvbnRleHQuXCIpO1xuXG4gICAgICB2YXIgeSA9IHN0YXZlLmdldFlGb3JUb3BUZXh0KHN0YXZlLm9wdGlvbnMubnVtX2xpbmVzKSArIHRoaXMueV9zaGlmdDtcbiAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKHN0YXZlLmNvbnRleHQsIHRoaXMueCArIHggKyB0aGlzLnhfc2hpZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB5ICsgMjUsIDQwLCBcInY0ZFwiLCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkcmF3U2lnbm9GaXhlZDogZnVuY3Rpb24oc3RhdmUsIHgpIHtcbiAgICAgIGlmICghc3RhdmUuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHN0YXZlIHdpdGhvdXQgY2FudmFzIGNvbnRleHQuXCIpO1xuICAgICAgdmFyIHkgPSBzdGF2ZS5nZXRZRm9yVG9wVGV4dChzdGF2ZS5vcHRpb25zLm51bV9saW5lcykgKyB0aGlzLnlfc2hpZnQ7XG4gICAgICBWZXguRmxvdy5yZW5kZXJHbHlwaChzdGF2ZS5jb250ZXh0LCB0aGlzLnggKyB4ICsgdGhpcy54X3NoaWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArIDI1LCAzMCwgXCJ2OGNcIiwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZHJhd1N5bWJvbFRleHQ6IGZ1bmN0aW9uKHN0YXZlLCB4LCB0ZXh0LCBkcmF3X2NvZGEpIHtcbiAgICAgIGlmICghc3RhdmUuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHN0YXZlIHdpdGhvdXQgY2FudmFzIGNvbnRleHQuXCIpO1xuXG4gICAgICB2YXIgY3R4ID0gc3RhdmUuY29udGV4dDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSwgdGhpcy5mb250LndlaWdodCk7XG4gICAgICAgIC8vIERlZmF1bHQgdG8gcmlnaHQgc3ltYm9sXG4gICAgICB2YXIgdGV4dF94ID0gMCArIHRoaXMueF9zaGlmdDtcbiAgICAgIHZhciBzeW1ib2xfeCA9IHggKyB0aGlzLnhfc2hpZnQ7XG4gICAgICBpZiAodGhpcy5zeW1ib2xfdHlwZSA9PSBWZXguRmxvdy5SZXBldGl0aW9uLnR5cGUuQ09EQV9MRUZUKSB7XG4gICAgICAgICAgLy8gT2Zmc2V0IENvZGEgdGV4dCB0byByaWdodCBvZiBzdGF2ZSBiZWdpbm5pbmdcbiAgICAgICAgdGV4dF94ID0gdGhpcy54ICsgc3RhdmUub3B0aW9ucy52ZXJ0aWNhbF9iYXJfd2lkdGg7XG4gICAgICAgIHN5bWJvbF94ID0gdGV4dF94ICsgY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoICsgMTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE9mZnNldCBTaWdubyB0ZXh0IHRvIGxlZnQgc3RhdmUgZW5kXG4gICAgICAgIHN5bWJvbF94ID0gdGhpcy54ICsgeCArIHN0YXZlLndpZHRoIC0gNSArIHRoaXMueF9zaGlmdDtcbiAgICAgICAgdGV4dF94ID0gc3ltYm9sX3ggLSArIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCAtIDEyO1xuICAgICAgfVxuICAgICAgdmFyIHkgPSBzdGF2ZS5nZXRZRm9yVG9wVGV4dChzdGF2ZS5vcHRpb25zLm51bV9saW5lcykgKyB0aGlzLnlfc2hpZnQ7XG4gICAgICBpZiAoZHJhd19jb2RhKSB7XG4gICAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKGN0eCwgc3ltYm9sX3gsIHksIDQwLCBcInY0ZFwiLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIHRleHRfeCwgeSArIDUpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gUmVwZXRpdGlvbjtcbn0oKSk7XG4vLyBWZXhGbG93IC0gTXVzaWMgRW5ncmF2aW5nIGZvciBIVE1MNVxuLy8gQ29weXJpZ2h0IE1vaGl0IE11dGhhbm5hIDIwMTBcbi8vIEF1dGhvciBMYXJyeSBLdWhucyAyMDExXG4vLyBJbXBsZW1lbnRzIHN0YXZlIHNlY3Rpb24gbmFtZXMuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblZleC5GbG93LlN0YXZlU2VjdGlvbiA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gU3RhdmVTZWN0aW9uKHNlY3Rpb24sIHgsIHNoaWZ0X3kpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChzZWN0aW9uLCB4LCBzaGlmdF95KTtcbiAgfVxuXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xuICBWZXguSW5oZXJpdChTdGF2ZVNlY3Rpb24sIE1vZGlmaWVyLCB7XG4gICAgaW5pdDogZnVuY3Rpb24oc2VjdGlvbiwgeCwgc2hpZnRfeSkge1xuICAgICAgU3RhdmVTZWN0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLnNldFdpZHRoKDE2KTtcbiAgICAgIHRoaXMuc2VjdGlvbiA9IHNlY3Rpb247XG4gICAgICB0aGlzLnBvc2l0aW9uID0gTW9kaWZpZXIuUG9zaXRpb24uQUJPVkU7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy5zaGlmdF94ID0gMDtcbiAgICAgIHRoaXMuc2hpZnRfeSA9IHNoaWZ0X3k7XG4gICAgICB0aGlzLmZvbnQgPSB7XG4gICAgICAgIGZhbWlseTogXCJzYW5zLXNlcmlmXCIsXG4gICAgICAgIHNpemU6IDEyLFxuICAgICAgICB3ZWlnaHQ6IFwiYm9sZFwiXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRDYXRlZ29yeTogZnVuY3Rpb24oKSB7IHJldHVybiBcInN0YXZlc2VjdGlvblwiOyB9LFxuICAgIHNldFN0YXZlU2VjdGlvbjogZnVuY3Rpb24oc2VjdGlvbikgeyB0aGlzLnNlY3Rpb24gPSBzZWN0aW9uOyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRTaGlmdFg6IGZ1bmN0aW9uKHgpIHsgdGhpcy5zaGlmdF94ID0geDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgc2V0U2hpZnRZOiBmdW5jdGlvbih5KSB7IHRoaXMuc2hpZnRfeSA9IHk7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oc3RhdmUsIHNoaWZ0X3gpIHtcbiAgICAgIGlmICghc3RhdmUuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9Db250ZXh0XCIsXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBzdGF2ZSBzZWN0aW9uIHdpdGhvdXQgYSBjb250ZXh0LlwiKTtcblxuICAgICAgdmFyIGN0eCA9IHN0YXZlLmNvbnRleHQ7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgIGN0eC5zZXRGb250KHRoaXMuZm9udC5mYW1pbHksIHRoaXMuZm9udC5zaXplLCB0aGlzLmZvbnQud2VpZ2h0KTtcbiAgICAgIHZhciB0ZXh0X3dpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KFwiXCIgKyB0aGlzLnNlY3Rpb24pLndpZHRoO1xuICAgICAgdmFyIHdpZHRoID0gdGV4dF93aWR0aCArIDY7ICAvLyBhZGQgbGVmdCAmIHJpZ2h0IHBhZGRpbmdcbiAgICAgIGlmICh3aWR0aCA8IDE4KSB3aWR0aCA9IDE4O1xuICAgICAgdmFyIGhlaWdodCA9IDIwO1xuICAgICAgICAvLyAgU2VlbXMgdG8gYmUgYSBnb29kIGRlZmF1bHQgeVxuICAgICAgdmFyIHkgPSBzdGF2ZS5nZXRZRm9yVG9wVGV4dCgzKSArIHRoaXMuc2hpZnRfeTtcbiAgICAgIHZhciB4ID0gdGhpcy54ICsgc2hpZnRfeDtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB4ICs9ICh3aWR0aCAtIHRleHRfd2lkdGgpIC8gMjtcbiAgICAgIGN0eC5maWxsVGV4dChcIlwiICsgdGhpcy5zZWN0aW9uLCB4LCB5ICsgMTYpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFN0YXZlU2VjdGlvbjtcbn0oKSk7XG4vLyBWZXhGbG93IC0gTXVzaWMgRW5ncmF2aW5nIGZvciBIVE1MNVxuLy8gQ29weXJpZ2h0IE1vaGl0IE11dGhhbm5hIDIwMTBcbi8vIEF1dGhvciBSYWRvc2F3IEVpY2hsZXIgMjAxMlxuLy8gSW1wbGVtZW50cyB0ZW1wbyBtYXJrZXIuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gdGVtcG8gVGVtcG8gcGFyYW1ldGVyczogeyBuYW1lLCBkdXJhdGlvbiwgZG90cywgYnBtIH1cbiAqL1xuVmV4LkZsb3cuU3RhdmVUZW1wbyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gU3RhdmVUZW1wbyh0ZW1wbywgeCwgc2hpZnRfeSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHRlbXBvLCB4LCBzaGlmdF95KTtcbiAgfVxuXG4gIFZleC5Jbmhlcml0KFN0YXZlVGVtcG8sIFZleC5GbG93LlN0YXZlTW9kaWZpZXIsIHtcbiAgICBpbml0OiBmdW5jdGlvbih0ZW1wbywgeCwgc2hpZnRfeSkge1xuICAgICAgU3RhdmVUZW1wby5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy50ZW1wbyA9IHRlbXBvO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFO1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMuc2hpZnRfeCA9IDEwO1xuICAgICAgdGhpcy5zaGlmdF95ID0gc2hpZnRfeTtcbiAgICAgIHRoaXMuZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiBcInRpbWVzXCIsXG4gICAgICAgIHNpemU6IDE0LFxuICAgICAgICB3ZWlnaHQ6IFwiYm9sZFwiXG4gICAgICB9O1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgZ2x5cGhfZm9udF9zY2FsZTogMzAgIC8vIGZvbnQgc2l6ZSBmb3Igbm90ZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJzdGF2ZXRlbXBvXCI7IH0sXG4gICAgc2V0VGVtcG86IGZ1bmN0aW9uKHRlbXBvKSB7IHRoaXMudGVtcG8gPSB0ZW1wbzsgcmV0dXJuIHRoaXM7IH0sXG4gICAgc2V0U2hpZnRYOiBmdW5jdGlvbih4KSB7IHRoaXMuc2hpZnRfeCA9IHg7IHJldHVybiB0aGlzOyB9LFxuICAgIHNldFNoaWZ0WTogZnVuY3Rpb24oeSkgeyB0aGlzLnNoaWZ0X3kgPSB5OyByZXR1cm4gdGhpczsgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKHN0YXZlLCBzaGlmdF94KSB7XG4gICAgICBpZiAoIXN0YXZlLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgc3RhdmUgdGVtcG8gd2l0aG91dCBhIGNvbnRleHQuXCIpO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMucmVuZGVyX29wdGlvbnM7XG4gICAgICB2YXIgc2NhbGUgPSBvcHRpb25zLmdseXBoX2ZvbnRfc2NhbGUgLyAzODtcbiAgICAgIHZhciBuYW1lID0gdGhpcy50ZW1wby5uYW1lO1xuICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy50ZW1wby5kdXJhdGlvbjtcbiAgICAgIHZhciBkb3RzID0gdGhpcy50ZW1wby5kb3RzO1xuICAgICAgdmFyIGJwbSA9IHRoaXMudGVtcG8uYnBtO1xuICAgICAgdmFyIGZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgICB2YXIgY3R4ID0gc3RhdmUuY29udGV4dDtcbiAgICAgIHZhciB4ID0gdGhpcy54ICsgdGhpcy5zaGlmdF94ICsgc2hpZnRfeDtcbiAgICAgIHZhciB5ID0gc3RhdmUuZ2V0WUZvclRvcFRleHQoMSkgKyB0aGlzLnNoaWZ0X3k7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGN0eC5zZXRGb250KGZvbnQuZmFtaWx5LCBmb250LnNpemUsIGZvbnQud2VpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KG5hbWUsIHgsIHkpO1xuICAgICAgICB4ICs9IGN0eC5tZWFzdXJlVGV4dChuYW1lKS53aWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGR1cmF0aW9uICYmIGJwbSkge1xuICAgICAgICBjdHguc2V0Rm9udChmb250LmZhbWlseSwgZm9udC5zaXplLCAnbm9ybWFsJyk7XG5cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICB4ICs9IGN0eC5tZWFzdXJlVGV4dChcIiBcIikud2lkdGg7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KFwiKFwiLCB4LCB5KTtcbiAgICAgICAgICB4ICs9IGN0eC5tZWFzdXJlVGV4dChcIihcIikud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29kZSA9IFZleC5GbG93LmR1cmF0aW9uVG9HbHlwaChkdXJhdGlvbik7XG5cbiAgICAgICAgeCArPSAzICogc2NhbGU7XG4gICAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKGN0eCwgeCwgeSwgb3B0aW9ucy5nbHlwaF9mb250X3NjYWxlLCBjb2RlLmNvZGVfaGVhZCk7XG4gICAgICAgIHggKz0gY29kZS5oZWFkX3dpZHRoICogc2NhbGU7XG5cbiAgICAgICAgLy8gRHJhdyBzdGVtIGFuZCBmbGFnc1xuICAgICAgICBpZiAoY29kZS5zdGVtKSB7XG4gICAgICAgICAgdmFyIHN0ZW1faGVpZ2h0ID0gMzA7XG5cbiAgICAgICAgICBpZiAoY29kZS5iZWFtX2NvdW50KSBzdGVtX2hlaWdodCArPSAzICogKGNvZGUuYmVhbV9jb3VudCAtIDEpO1xuXG4gICAgICAgICAgc3RlbV9oZWlnaHQgKj0gc2NhbGU7XG5cbiAgICAgICAgICB2YXIgeV90b3AgPSB5IC0gc3RlbV9oZWlnaHQ7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHlfdG9wLCBzY2FsZSwgc3RlbV9oZWlnaHQpO1xuXG4gICAgICAgICAgaWYgKGNvZGUuZmxhZykge1xuICAgICAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgoY3R4LCB4ICsgc2NhbGUsIHlfdG9wLCBvcHRpb25zLmdseXBoX2ZvbnRfc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLmNvZGVfZmxhZ191cHN0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoIWRvdHMpIHggKz0gNiAqIHNjYWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgZG90XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG90czsgaSsrKSB7XG4gICAgICAgICAgeCArPSA2ICogc2NhbGU7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5hcmMoeCwgeSArIDIgKiBzY2FsZSwgMiAqIHNjYWxlLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZmlsbFRleHQoXCIgPSBcIiArIGJwbSArIChuYW1lID8gXCIpXCIgOiBcIlwiKSwgeCArIDMgKiBzY2FsZSwgeSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBTdGF2ZVRlbXBvO1xufSgpKTtcblxuLy8gVmV4RmxvdyAtIE11c2ljIEVuZ3JhdmluZyBmb3IgSFRNTDVcbi8vIENvcHlyaWdodCBNb2hpdCBNdXRoYW5uYSAyMDEwXG4vL1xuLy8gQXV0aG9yIFRhZWhvb24gTW9vbiAyMDE0XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblZleC5GbG93LlN0YXZlVGV4dCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gU3RhdmVUZXh0KHRleHQsIHBvc2l0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGV4dCwgcG9zaXRpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIE1vZGlmaWVyID0gVmV4LkZsb3cuTW9kaWZpZXI7XG4gIFZleC5Jbmhlcml0KFN0YXZlVGV4dCwgTW9kaWZpZXIsIHtcbiAgICBpbml0OiBmdW5jdGlvbih0ZXh0LCBwb3NpdGlvbiwgb3B0aW9ucykge1xuICAgICAgU3RhdmVUZXh0LnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLnNldFdpZHRoKDE2KTtcbiAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIHNoaWZ0X3g6IDAsXG4gICAgICAgIHNoaWZ0X3k6IDAsXG4gICAgICAgIGp1c3RpZmljYXRpb246IFZleC5GbG93LlRleHROb3RlLkp1c3RpZmljYXRpb24uQ0VOVEVSXG4gICAgICB9O1xuICAgICAgVmV4Lk1lcmdlKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiBcInRpbWVzXCIsXG4gICAgICAgIHNpemU6IDE2LFxuICAgICAgICB3ZWlnaHQ6IFwibm9ybWFsXCJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGdldENhdGVnb3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIFwic3RhdmV0ZXh0XCI7IH0sXG4gICAgc2V0U3RhdmVUZXh0OiBmdW5jdGlvbih0ZXh0KSB7IHRoaXMudGV4dCA9IHRleHQ7IHJldHVybiB0aGlzOyB9LFxuICAgIHNldFNoaWZ0WDogZnVuY3Rpb24oeCkgeyB0aGlzLnNoaWZ0X3ggPSB4OyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRTaGlmdFk6IGZ1bmN0aW9uKHkpIHsgdGhpcy5zaGlmdF95ID0geTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICBzZXRGb250OiBmdW5jdGlvbihmb250KSB7XG4gICAgICBWZXguTWVyZ2UodGhpcy5mb250LCBmb250KTtcbiAgICB9LFxuXG4gICAgc2V0VGV4dDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oc3RhdmUpIHtcbiAgICAgIGlmICghc3RhdmUuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9Db250ZXh0XCIsXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBzdGF2ZSB0ZXh0IHdpdGhvdXQgYSBjb250ZXh0LlwiKTtcblxuICAgICAgdmFyIGN0eCA9IHN0YXZlLmNvbnRleHQ7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgIGN0eC5zZXRGb250KHRoaXMuZm9udC5mYW1pbHksIHRoaXMuZm9udC5zaXplLCB0aGlzLmZvbnQud2VpZ2h0KTtcbiAgICAgIHZhciB0ZXh0X3dpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KFwiXCIgKyB0aGlzLnRleHQpLndpZHRoO1xuXG4gICAgICB2YXIgeCwgeTtcbiAgICAgIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xuICAgICAgc3dpdGNoKHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBNb2RpZmllci5Qb3NpdGlvbi5MRUZUOlxuICAgICAgICBjYXNlIE1vZGlmaWVyLlBvc2l0aW9uLlJJR0hUOlxuICAgICAgICAgIHkgPSAoc3RhdmUuZ2V0WUZvckxpbmUoMCkgKyBzdGF2ZS5nZXRCb3R0b21MaW5lWSgpKSAvIDIgKyB0aGlzLm9wdGlvbnMuc2hpZnRfeTtcbiAgICAgICAgICBpZih0aGlzLnBvc2l0aW9uID09IE1vZGlmaWVyLlBvc2l0aW9uLkxFRlQpIHtcbiAgICAgICAgICAgIHggPSBzdGF2ZS5nZXRYKCkgLSB0ZXh0X3dpZHRoIC0gMjQgKyB0aGlzLm9wdGlvbnMuc2hpZnRfeDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4ID0gc3RhdmUuZ2V0WCgpICsgc3RhdmUuZ2V0V2lkdGgoKSArIDI0ICsgdGhpcy5vcHRpb25zLnNoaWZ0X3g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFOlxuICAgICAgICBjYXNlIE1vZGlmaWVyLlBvc2l0aW9uLkJFTE9XOlxuICAgICAgICAgIHZhciBKdXN0aWZpY2F0aW9uID0gVmV4LkZsb3cuVGV4dE5vdGUuSnVzdGlmaWNhdGlvbjtcbiAgICAgICAgICB4ID0gc3RhdmUuZ2V0WCgpICsgdGhpcy5vcHRpb25zLnNoaWZ0X3g7XG4gICAgICAgICAgaWYodGhpcy5vcHRpb25zLmp1c3RpZmljYXRpb24gPT0gSnVzdGlmaWNhdGlvbi5DRU5URVIpIHtcbiAgICAgICAgICAgIHggKz0gc3RhdmUuZ2V0V2lkdGgoKSAvIDIgLSB0ZXh0X3dpZHRoIC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZih0aGlzLm9wdGlvbnMuanVzdGlmaWNhdGlvbiA9PSBKdXN0aWZpY2F0aW9uLlJJR0hUKSB7XG4gICAgICAgICAgICB4ICs9IHN0YXZlLmdldFdpZHRoKCkgLSB0ZXh0X3dpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZih0aGlzLnBvc2l0aW9uID09IE1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFKSB7XG4gICAgICAgICAgICB5ID0gc3RhdmUuZ2V0WUZvclRvcFRleHQoMikgKyB0aGlzLm9wdGlvbnMuc2hpZnRfeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5ID0gc3RhdmUuZ2V0WUZvckJvdHRvbVRleHQoMikgKyB0aGlzLm9wdGlvbnMuc2hpZnRfeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiSW52YWxpZFBvc2l0aW9uXCIsXG4gICAgICAgICAgICBcIlZhbHVlIE11c3QgYmUgaW4gTW9kaWZpZXIuUG9zaXRpb24uXCIpO1xuICAgICAgfVxuXG4gICAgICBjdHguZmlsbFRleHQoXCJcIiArIHRoaXMudGV4dCwgeCwgeSArIDQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFN0YXZlVGV4dDtcbn0oKSk7XG5cbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gQSBgQmFyTm90ZWAgaXMgdXNlZCB0byByZW5kZXIgYmFyIGxpbmVzIChmcm9tIGBiYXJsaW5lLmpzYCkuIGBCYXJOb3RlYHMgY2FuXG4vLyBiZSBhZGRlZCB0byBhIHZvaWNlIGFuZCByZW5kZXJlZCBpbiB0aGUgbWlkZGxlIG9mIGEgc3RhdmUuIFNpbmNlIGl0IGhhcyBub1xuLy8gZHVyYXRpb24sIGl0IGNvbnN1bWVzIG5vIGB0aWNrYHMsIGFuZCBpcyBkZWFsdCB3aXRoIGFwcHJvcHJpYXRlbHkgYnkgdGhlIGZvcm1hdHRlci5cbi8vXG4vLyBTZWUgYHRlc3RzL2Jhcm5vdGVfdGVzdHMuanNgIGZvciB1c2FnZSBleGFtcGxlcy5cblxuVmV4LkZsb3cuQmFyTm90ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQmFyTm90ZSgpIHsgdGhpcy5pbml0KCk7IH1cblxuICAvLyBUbyBlbmFibGUgbG9nZ2luZyBmb3IgdGhpcyBjbGFzcy4gU2V0IGBWZXguRmxvdy5CYXJOb3RlLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChCYXJOb3RlLkRFQlVHKSBWZXguTChcIlZleC5GbG93LkJhck5vdGVcIiwgYXJndW1lbnRzKTsgfVxuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIFZleC5Jbmhlcml0KEJhck5vdGUsIFZleC5GbG93Lk5vdGUsIHtcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIEJhck5vdGUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywge2R1cmF0aW9uOiBcImJcIn0pO1xuXG4gICAgICB2YXIgVFlQRSA9IFZleC5GbG93LkJhcmxpbmUudHlwZTtcbiAgICAgIHRoaXMubWV0cmljcyA9IHtcbiAgICAgICAgd2lkdGhzOiB7fVxuICAgICAgfTtcblxuICAgICAgLy8gRGVmaW5lZCB0aGlzIHdheSB0byBwcmV2ZW50IGxpbnQgZXJyb3JzLlxuICAgICAgdGhpcy5tZXRyaWNzLndpZHRoc1tUWVBFLlNJTkdMRV0gPSA4O1xuICAgICAgdGhpcy5tZXRyaWNzLndpZHRoc1tUWVBFLkRPVUJMRV0gPSAxMjtcbiAgICAgIHRoaXMubWV0cmljcy53aWR0aHNbVFlQRS5FTkRdID0gMTU7XG4gICAgICB0aGlzLm1ldHJpY3Mud2lkdGhzW1RZUEUuUkVQRUFUX0JFR0lOXSA9IDE0O1xuICAgICAgdGhpcy5tZXRyaWNzLndpZHRoc1tUWVBFLlJFUEVBVF9FTkRdID0gMTQ7XG4gICAgICB0aGlzLm1ldHJpY3Mud2lkdGhzW1RZUEUuUkVQRUFUX0JPVEhdID0gMTg7XG4gICAgICB0aGlzLm1ldHJpY3Mud2lkdGhzW1RZUEUuTk9ORV0gPSAwO1xuXG4gICAgICAvLyBUZWxsIHRoZSBmb3JtYXR0ZXIgdGhhdCBiYXIgbm90ZXMgaGF2ZSBubyBkdXJhdGlvbi5cbiAgICAgIHRoaXMuaWdub3JlX3RpY2tzID0gdHJ1ZTtcbiAgICAgIHRoaXMudHlwZSA9IFRZUEUuU0lOR0xFO1xuXG4gICAgICAvLyBTZXQgd2lkdGggdG8gd2lkdGggb2YgcmVsZXZhbnQgYEJhcmxpbmVgLlxuICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLm1ldHJpY3Mud2lkdGhzW3RoaXMudHlwZV0pO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYW5kIHNldCB0aGUgdHlwZSBvZiBCYXIgbm90ZS4gYHR5cGVgIG11c3QgYmUgb25lIG9mIGBWZXguRmxvdy5CYXJsaW5lLnR5cGVgLlxuICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50eXBlOyB9LFxuICAgIHNldFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLnNldFdpZHRoKHRoaXMubWV0cmljcy53aWR0aHNbdGhpcy50eXBlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBWZXguRmxvdy5Cb3VuZGluZ0JveCgwLCAwLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgYWRkVG9Nb2RpZmllckNvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLyogb3ZlcnJpZGRlbiB0byBpZ25vcmUgKi9cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLyogb3ZlcnJpZGRlbiB0byBpZ25vcmUgKi9cbiAgICAgIHRoaXMuc2V0UHJlRm9ybWF0dGVkKHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbmRlciBub3RlIHRvIHN0YXZlLlxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnN0YXZlKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1N0YXZlXCIsIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgc3RhdmUuXCIpO1xuICAgICAgTChcIlJlbmRlcmluZyBiYXIgbGluZSBhdDogXCIsIHRoaXMuZ2V0QWJzb2x1dGVYKCkpO1xuICAgICAgdmFyIGJhcmxpbmUgPSBuZXcgVmV4LkZsb3cuQmFybGluZSh0aGlzLnR5cGUsIHRoaXMuZ2V0QWJzb2x1dGVYKCkpO1xuICAgICAgYmFybGluZS5kcmF3KHRoaXMuc3RhdmUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIEJhck5vdGU7XG59KCkpO1xuXG4vLyBWZXhGbG93IC0gTXVzaWMgRW5ncmF2aW5nIGZvciBIVE1MNVxuLy8gQXV0aG9yOiBNaWtlIENvcnJpZ2FuIDxjb3JyaWdhbkBnbWFpbC5jb20+XG4vL1xuLy8gVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRyZW1vbG8gbm90YXRpb24uXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblZleC5GbG93LlRyZW1vbG8gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRyZW1vbG8obnVtKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQobnVtKTtcbiAgfVxuXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xuICBWZXguSW5oZXJpdChUcmVtb2xvLCBNb2RpZmllciwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG51bSkge1xuICAgICAgVHJlbW9sby5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5udW0gPSBudW07XG4gICAgICB0aGlzLm5vdGUgPSBudWxsO1xuICAgICAgdGhpcy5pbmRleCA9IG51bGw7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gTW9kaWZpZXIuUG9zaXRpb24uQ0VOVEVSO1xuICAgICAgdGhpcy5jb2RlID0gXCJ2NzRcIjtcbiAgICAgIHRoaXMuc2hpZnRfcmlnaHQgPSAtMjtcbiAgICAgIHRoaXMueV9zcGFjaW5nID0gNDtcblxuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgZm9udF9zY2FsZTogMzUsXG4gICAgICAgIHN0cm9rZV9weDogMyxcbiAgICAgICAgc3Ryb2tlX3NwYWNpbmc6IDEwXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmZvbnQgPSB7XG4gICAgICAgIGZhbWlseTogXCJBcmlhbFwiLFxuICAgICAgICBzaXplOiAxNixcbiAgICAgICAgd2VpZ2h0OiBcIlwiXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRDYXRlZ29yeTogZnVuY3Rpb24oKSB7IHJldHVybiBcInRyZW1vbG9cIjsgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgVHJlbW9sbyB3aXRob3V0IGEgY29udGV4dC5cIik7XG4gICAgICBpZiAoISh0aGlzLm5vdGUgJiYgKHRoaXMuaW5kZXggIT0gbnVsbCkpKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0F0dGFjaGVkTm90ZVwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgVHJlbW9sbyB3aXRob3V0IGEgbm90ZSBhbmQgaW5kZXguXCIpO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLm5vdGUuZ2V0TW9kaWZpZXJTdGFydFhZKHRoaXMucG9zaXRpb24sIHRoaXMuaW5kZXgpO1xuICAgICAgdmFyIHggPSBzdGFydC54O1xuICAgICAgdmFyIHkgPSBzdGFydC55O1xuXG4gICAgICB4ICs9IHRoaXMuc2hpZnRfcmlnaHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtOyArK2kpIHtcbiAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgodGhpcy5jb250ZXh0LCB4LCB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLmZvbnRfc2NhbGUsIHRoaXMuY29kZSk7XG4gICAgICAgIHkgKz0gdGhpcy55X3NwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gVHJlbW9sbztcbn0oKSk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHR1cGxldCBmcm9tIHRoZSBzcGVjaWZpZWQgbm90ZXMuIFRoZSBub3RlcyBtdXN0XG4gKiBiZSBwYXJ0IG9mIHRoZSBzYW1lIGxpbmUsIGFuZCBoYXZlIHRoZSBzYW1lIGR1cmF0aW9uIChpbiB0aWNrcykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5LjxWZXguRmxvdy5TdGF2ZU5vdGU+fSBBIHNldCBvZiBub3Rlcy5cbiAqL1xuVmV4LkZsb3cuVHVwbGV0ID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUdXBsZXQobm90ZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChub3Rlcywgb3B0aW9ucyk7XG4gIH1cblxuICBUdXBsZXQuTE9DQVRJT05fVE9QID0gMTtcbiAgVHVwbGV0LkxPQ0FUSU9OX0JPVFRPTSA9IC0xO1xuXG4gIFR1cGxldC5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24obm90ZXMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghbm90ZXMgfHwgbm90ZXMgPT0gW10pIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIiwgXCJObyBub3RlcyBwcm92aWRlZCBmb3IgdHVwbGV0LlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vdGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiQmFkQXJndW1lbnRzXCIsIFwiVG9vIGZldyBub3RlcyBmb3IgdHVwbGV0LlwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zID0gVmV4Lk1lcmdlKHt9LCBvcHRpb25zKTtcbiAgICAgIHRoaXMubm90ZXMgPSBub3RlcztcbiAgICAgIHRoaXMubnVtX25vdGVzID0gJ251bV9ub3RlcycgaW4gdGhpcy5vcHRpb25zID9cbiAgICAgICAgdGhpcy5vcHRpb25zLm51bV9ub3RlcyA6IG5vdGVzLmxlbmd0aDtcbiAgICAgIHRoaXMuYmVhdHNfb2NjdXBpZWQgPSAnYmVhdHNfb2NjdXBpZWQnIGluIHRoaXMub3B0aW9ucyA/XG4gICAgICAgIHRoaXMub3B0aW9ucy5iZWF0c19vY2N1cGllZCA6IDI7XG4gICAgICB0aGlzLmJyYWNrZXRlZCA9IChub3Rlc1swXS5iZWFtID09IG51bGwpO1xuICAgICAgdGhpcy5yYXRpb2VkID0gZmFsc2U7XG4gICAgICB0aGlzLnBvaW50ID0gMjg7XG4gICAgICB0aGlzLnlfcG9zID0gMTY7XG4gICAgICB0aGlzLnhfcG9zID0gMTAwO1xuICAgICAgdGhpcy53aWR0aCA9IDIwMDtcbiAgICAgIHRoaXMubG9jYXRpb24gPSBUdXBsZXQuTE9DQVRJT05fVE9QO1xuXG4gICAgICBWZXguRmxvdy5Gb3JtYXR0ZXIuQWxpZ25SZXN0c1RvTm90ZXMobm90ZXMsIHRydWUsIHRydWUpO1xuICAgICAgdGhpcy5yZXNvbHZlR2x5cGhzKCk7XG4gICAgICB0aGlzLmF0dGFjaCgpO1xuICAgIH0sXG5cbiAgICBhdHRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub3Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm90ZSA9IHRoaXMubm90ZXNbaV07XG4gICAgICAgIG5vdGUuc2V0VHVwbGV0KHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub3Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm90ZSA9IHRoaXMubm90ZXNbaV07XG4gICAgICAgIG5vdGUuc2V0VHVwbGV0KG51bGwpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB3aGV0aGVyIG9yIG5vdCB0aGUgYnJhY2tldCBpcyBkcmF3bi5cbiAgICAgKi9cbiAgICBzZXRCcmFja2V0ZWQ6IGZ1bmN0aW9uKGJyYWNrZXRlZCkge1xuICAgICAgdGhpcy5icmFja2V0ZWQgPSBicmFja2V0ZWQgPyB0cnVlIDogZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgb3Igbm90IHRoZSByYXRpbyBpcyBzaG93bi5cbiAgICAgKi9cbiAgICBzZXRSYXRpb2VkOiBmdW5jdGlvbihyYXRpb2VkKSB7XG4gICAgICB0aGlzLnJhdGlvZWQgPSByYXRpb2VkID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdHVwbGV0IHRvIGJlIGRpc3BsYXllZCBlaXRoZXIgb24gdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIHN0YXZlXG4gICAgICovXG4gICAgc2V0VHVwbGV0TG9jYXRpb246IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG4gICAgICBpZiAoIWxvY2F0aW9uKSBsb2NhdGlvbiA9IFR1cGxldC5MT0NBVElPTl9UT1A7XG4gICAgICBlbHNlIGlmIChsb2NhdGlvbiAhPSBUdXBsZXQuTE9DQVRJT05fVE9QICYmXG4gICAgICAgICAgbG9jYXRpb24gIT0gVHVwbGV0LkxPQ0FUSU9OX0JPVFRPTSkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudFwiLCBcIkludmFsaWQgdHVwbGV0IGxvY2F0aW9uOiBcIiArIGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldE5vdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdGVzO1xuICAgIH0sXG5cbiAgICBnZXROb3RlQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubnVtX25vdGVzO1xuICAgIH0sXG5cbiAgICBnZXRCZWF0c09jY3VwaWVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmJlYXRzX29jY3VwaWVkO1xuICAgIH0sXG5cbiAgICBzZXRCZWF0c09jY3VwaWVkOiBmdW5jdGlvbihiZWF0cykge1xuICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgIHRoaXMuYmVhdHNfb2NjdXBpZWQgPSBiZWF0cztcbiAgICAgIHRoaXMucmVzb2x2ZUdseXBocygpO1xuICAgICAgdGhpcy5hdHRhY2goKTtcbiAgICB9LFxuXG4gICAgcmVzb2x2ZUdseXBoczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm51bV9nbHlwaHMgPSBbXTtcbiAgICAgIHZhciBuID0gdGhpcy5udW1fbm90ZXM7XG4gICAgICB3aGlsZSAobiA+PSAxKSB7XG4gICAgICAgIHRoaXMubnVtX2dseXBocy5wdXNoKG5ldyBWZXguRmxvdy5HbHlwaChcInZcIiArIChuICUgMTApLCB0aGlzLnBvaW50KSk7XG4gICAgICAgIG4gPSBwYXJzZUludChuIC8gMTAsIDEwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kZW5vbV9nbHlwaHMgPSBbXTtcbiAgICAgIG4gPSB0aGlzLmJlYXRzX29jY3VwaWVkO1xuICAgICAgd2hpbGUgKG4gPj0gMSkge1xuICAgICAgICB0aGlzLmRlbm9tX2dseXBocy5wdXNoKG5ldyBWZXguRmxvdy5HbHlwaChcInZcIiArIChuICUgMTApLCB0aGlzLnBvaW50KSk7XG4gICAgICAgIG4gPSBwYXJzZUludChuIC8gMTAsIDEwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHdpdGhvdXQgYSBjYW52YXMgY29udGV4dC5cIik7XG5cbiAgICAgIC8vIGRldGVybWluZSB4IHZhbHVlIG9mIGxlZnQgYm91bmQgb2YgdHVwbGV0XG4gICAgICB2YXIgZmlyc3Rfbm90ZSA9IHRoaXMubm90ZXNbMF07XG4gICAgICB2YXIgbGFzdF9ub3RlID0gdGhpcy5ub3Rlc1t0aGlzLm5vdGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoIXRoaXMuYnJhY2tldGVkKSB7XG4gICAgICAgIHRoaXMueF9wb3MgPSBmaXJzdF9ub3RlLmdldFN0ZW1YKCk7XG4gICAgICAgIHRoaXMud2lkdGggPSBsYXN0X25vdGUuZ2V0U3RlbVgoKSAtIHRoaXMueF9wb3M7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy54X3BvcyA9IGZpcnN0X25vdGUuZ2V0VGllTGVmdFgoKSAtIDU7XG4gICAgICAgIHRoaXMud2lkdGggPSBsYXN0X25vdGUuZ2V0VGllUmlnaHRYKCkgLSB0aGlzLnhfcG9zICsgNTtcbiAgICAgIH1cblxuICAgICAgLy8gZGV0ZXJtaW5lIHkgdmFsdWUgZm9yIHR1cGxldFxuICAgICAgdmFyIGk7XG4gICAgICBpZiAodGhpcy5sb2NhdGlvbiA9PSBUdXBsZXQuTE9DQVRJT05fVE9QKSB7XG4gICAgICAgIHRoaXMueV9wb3MgPSBmaXJzdF9ub3RlLmdldFN0YXZlKCkuZ2V0WUZvckxpbmUoMCkgLSAxNTtcbiAgICAgICAgLy90aGlzLnlfcG9zID0gZmlyc3Rfbm90ZS5nZXRTdGVtRXh0ZW50cygpLnRvcFkgLSAxMDtcblxuICAgICAgICBmb3IgKGk9MDsgaTx0aGlzLm5vdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIHRvcF95ID0gdGhpcy5ub3Rlc1tpXS5nZXRTdGVtRGlyZWN0aW9uKCkgPT09IFZleC5GbG93LlN0ZW0uVVAgP1xuICAgICAgICAgICAgICB0aGlzLm5vdGVzW2ldLmdldFN0ZW1FeHRlbnRzKCkudG9wWSAtIDEwXG4gICAgICAgICAgICA6IHRoaXMubm90ZXNbaV0uZ2V0U3RlbUV4dGVudHMoKS5iYXNlWSAtIDIwO1xuICAgICAgICAgIGlmICh0b3BfeSA8IHRoaXMueV9wb3MpXG4gICAgICAgICAgICB0aGlzLnlfcG9zID0gdG9wX3k7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnlfcG9zID0gZmlyc3Rfbm90ZS5nZXRTdGF2ZSgpLmdldFlGb3JMaW5lKDQpICsgMjA7XG5cbiAgICAgICAgZm9yIChpPTA7IGk8dGhpcy5ub3Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBib3R0b21feSA9IHRoaXMubm90ZXNbaV0uZ2V0U3RlbURpcmVjdGlvbigpID09PSBWZXguRmxvdy5TdGVtLlVQID9cbiAgICAgICAgICAgICAgdGhpcy5ub3Rlc1tpXS5nZXRTdGVtRXh0ZW50cygpLmJhc2VZICsgMjBcbiAgICAgICAgICAgIDogdGhpcy5ub3Rlc1tpXS5nZXRTdGVtRXh0ZW50cygpLnRvcFkgKyAxMDtcbiAgICAgICAgICBpZiAoYm90dG9tX3kgPiB0aGlzLnlfcG9zKVxuICAgICAgICAgICAgdGhpcy55X3BvcyA9IGJvdHRvbV95O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSB0b3RhbCB3aWR0aCBvZiB0dXBsZXQgbm90YXRpb25cbiAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICB2YXIgZ2x5cGg7XG4gICAgICBmb3IgKGdseXBoIGluIHRoaXMubnVtX2dseXBocykge1xuICAgICAgICB3aWR0aCArPSB0aGlzLm51bV9nbHlwaHNbZ2x5cGhdLmdldE1ldHJpY3MoKS53aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJhdGlvZWQpIHtcbiAgICAgICAgZm9yIChnbHlwaCBpbiB0aGlzLmRlbm9tX2dseXBocykge1xuICAgICAgICAgIHdpZHRoICs9IHRoaXMuZGVub21fZ2x5cGhzW2dseXBoXS5nZXRNZXRyaWNzKCkud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgd2lkdGggKz0gdGhpcy5wb2ludCAqIDAuMzI7XG4gICAgICB9XG5cbiAgICAgIHZhciBub3RhdGlvbl9jZW50ZXJfeCA9IHRoaXMueF9wb3MgKyAodGhpcy53aWR0aC8yKTtcbiAgICAgIHZhciBub3RhdGlvbl9zdGFydF94ID0gbm90YXRpb25fY2VudGVyX3ggLSAod2lkdGgvMik7XG5cbiAgICAgIC8vIGRyYXcgYnJhY2tldCBpZiB0aGUgdHVwbGV0IGlzIG5vdCBiZWFtZWRcbiAgICAgIGlmICh0aGlzLmJyYWNrZXRlZCkge1xuICAgICAgICB2YXIgbGluZV93aWR0aCA9IHRoaXMud2lkdGgvMiAtIHdpZHRoLzIgLSA1O1xuXG4gICAgICAgIC8vIG9ubHkgZHJhdyB0aGUgYnJhY2tldCBpZiBpdCBoYXMgcG9zaXRpdmUgbGVuZ3RoXG4gICAgICAgIGlmIChsaW5lX3dpZHRoID4gMCkge1xuICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCh0aGlzLnhfcG9zLCB0aGlzLnlfcG9zLGxpbmVfd2lkdGgsIDEpO1xuICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCh0aGlzLnhfcG9zICsgdGhpcy53aWR0aCAvIDIgKyB3aWR0aCAvIDIgKyA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnlfcG9zLGxpbmVfd2lkdGgsIDEpO1xuICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCh0aGlzLnhfcG9zLFxuICAgICAgICAgICAgICB0aGlzLnlfcG9zICsgKHRoaXMubG9jYXRpb24gPT0gVHVwbGV0LkxPQ0FUSU9OX0JPVFRPTSksXG4gICAgICAgICAgICAgIDEsIHRoaXMubG9jYXRpb24gKiAxMCk7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KHRoaXMueF9wb3MgKyB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICB0aGlzLnlfcG9zICsgKHRoaXMubG9jYXRpb24gPT0gVHVwbGV0LkxPQ0FUSU9OX0JPVFRPTSksXG4gICAgICAgICAgICAgIDEsIHRoaXMubG9jYXRpb24gKiAxMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZHJhdyBudW1lcmF0b3IgZ2x5cGhzXG4gICAgICB2YXIgeF9vZmZzZXQgPSAwO1xuICAgICAgdmFyIHNpemUgPSB0aGlzLm51bV9nbHlwaHMubGVuZ3RoO1xuICAgICAgZm9yIChnbHlwaCBpbiB0aGlzLm51bV9nbHlwaHMpIHtcbiAgICAgICAgdGhpcy5udW1fZ2x5cGhzW3NpemUtZ2x5cGgtMV0ucmVuZGVyKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LCBub3RhdGlvbl9zdGFydF94ICsgeF9vZmZzZXQsXG4gICAgICAgICAgICB0aGlzLnlfcG9zICsgKHRoaXMucG9pbnQvMykgLSAyKTtcbiAgICAgICAgeF9vZmZzZXQgKz0gdGhpcy5udW1fZ2x5cGhzW3NpemUtZ2x5cGgtMV0uZ2V0TWV0cmljcygpLndpZHRoO1xuICAgICAgfVxuXG4gICAgICAvLyBkaXNwbGF5IGNvbG9uIGFuZCBkZW5vbWluYXRvciBpZiB0aGUgcmF0aW8gaXMgdG8gYmUgc2hvd25cbiAgICAgIGlmICh0aGlzLnJhdGlvZWQpIHtcbiAgICAgICAgdmFyIGNvbG9uX3ggPSBub3RhdGlvbl9zdGFydF94ICsgeF9vZmZzZXQgKyB0aGlzLnBvaW50KjAuMTY7XG4gICAgICAgIHZhciBjb2xvbl9yYWRpdXMgPSB0aGlzLnBvaW50ICogMC4wNjtcbiAgICAgICAgdGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmNvbnRleHQuYXJjKGNvbG9uX3gsIHRoaXMueV9wb3MgLSB0aGlzLnBvaW50KjAuMDgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgY29sb25fcmFkaXVzLCAwLCBNYXRoLlBJKjIsIHRydWUpO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5maWxsKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFyYyhjb2xvbl94LCB0aGlzLnlfcG9zICsgdGhpcy5wb2ludCowLjEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9uX3JhZGl1cywgMCwgTWF0aC5QSSoyLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbCgpO1xuICAgICAgICB4X29mZnNldCArPSB0aGlzLnBvaW50KjAuMzI7XG4gICAgICAgIHNpemUgPSB0aGlzLmRlbm9tX2dseXBocy5sZW5ndGg7XG4gICAgICAgIGZvciAoZ2x5cGggaW4gdGhpcy5kZW5vbV9nbHlwaHMpIHtcbiAgICAgICAgICB0aGlzLmRlbm9tX2dseXBoc1tzaXplLWdseXBoLTFdLnJlbmRlcihcbiAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LCBub3RhdGlvbl9zdGFydF94ICsgeF9vZmZzZXQsXG4gICAgICAgICAgICAgIHRoaXMueV9wb3MgKyAodGhpcy5wb2ludC8zKSAtIDIpO1xuICAgICAgICAgIHhfb2Zmc2V0ICs9IHRoaXMuZGVub21fZ2x5cGhzW3NpemUtZ2x5cGgtMV0uZ2V0TWV0cmljcygpLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUdXBsZXQ7XG59KCkpO1xuXG4vLyBWZXggTXVzaWMgTm90YXRpb25cbi8vIE1vaGl0IE11dGhhbm5hIDxtb2hpdEBtdXRoYW5uYS5jb20+XG4vL1xuLy8gQ29weXJpZ2h0IE1vaGl0IE11dGhhbm5hIDIwMTBcblxuLy8gQm91bmRpbmcgYm94ZXMgZm9yIGludGVyYWN0aXZlIG5vdGF0aW9uXG5cbi8qKiBAY29uc3RydWN0b3IgKi9cblZleC5GbG93LkJvdW5kaW5nQm94ID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBCb3VuZGluZ0JveCh4LCB5LCB3LCBoKSB7IHRoaXMuaW5pdCh4LCB5LCB3LCBoKTsgfVxuICBCb3VuZGluZ0JveC5jb3B5ID0gZnVuY3Rpb24odGhhdCkge1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhhdC54LCB0aGF0LnksIHRoYXQudywgdGhhdC5oKTsgfTtcblxuICBCb3VuZGluZ0JveC5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLncgPSB3O1xuICAgICAgdGhpcy5oID0gaDtcbiAgICB9LFxuXG4gICAgZ2V0WDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLng7IH0sXG4gICAgZ2V0WTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnk7IH0sXG4gICAgZ2V0VzogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnc7IH0sXG4gICAgZ2V0SDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmg7IH0sXG5cbiAgICBzZXRYOiBmdW5jdGlvbih4KSB7IHRoaXMueCA9IHg7IHJldHVybiB0aGlzOyB9LFxuICAgIHNldFk6IGZ1bmN0aW9uKHkpIHsgdGhpcy55ID0geTsgcmV0dXJuIHRoaXM7IH0sXG4gICAgc2V0VzogZnVuY3Rpb24odykgeyB0aGlzLncgPSB3OyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRIOiBmdW5jdGlvbihoKSB7IHRoaXMuaCA9IGg7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgbW92ZTogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLnggKz0geDsgdGhpcy55ICs9IHk7IH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gQm91bmRpbmdCb3guY29weSh0aGlzKTsgfSxcblxuICAgIC8vIE1lcmdlIG15IGJveCB3aXRoIGdpdmVuIGJveC4gQ3JlYXRlcyBhIGJpZ2dlciBib3VuZGluZyBib3ggdW5sZXNzXG4gICAgLy8gdGhlIGdpdmVuIGJveCBpcyBjb250YWluZWQgaW4gdGhpcyBvbmUuXG4gICAgbWVyZ2VXaXRoOiBmdW5jdGlvbihib3VuZGluZ0JveCwgY3R4KSB7XG4gICAgICB2YXIgdGhhdCA9IGJvdW5kaW5nQm94O1xuXG4gICAgICB2YXIgbmV3X3ggPSB0aGlzLnggPCB0aGF0LnggPyB0aGlzLnggOiB0aGF0Lng7XG4gICAgICB2YXIgbmV3X3kgPSB0aGlzLnkgPCB0aGF0LnkgPyB0aGlzLnkgOiB0aGF0Lnk7XG4gICAgICB2YXIgbmV3X3cgPSAodGhpcy54ICsgdGhpcy53KSA8ICh0aGF0LnggKyB0aGF0LncpID8gKHRoYXQueCArIHRoYXQudykgLSB0aGlzLnggOiAodGhpcy54ICsgdGhpcy53KSAtIFZleC5NaW4odGhpcy54LCB0aGF0LngpO1xuICAgICAgdmFyIG5ld19oID0gKHRoaXMueSArIHRoaXMuaCkgPCAodGhhdC55ICsgdGhhdC5oKSA/ICh0aGF0LnkgKyB0aGF0LmgpIC0gdGhpcy55IDogKHRoaXMueSArIHRoaXMuaCkgLSBWZXguTWluKHRoaXMueSwgdGhhdC55KTtcblxuICAgICAgdGhpcy54ID0gbmV3X3g7XG4gICAgICB0aGlzLnkgPSBuZXdfeTtcbiAgICAgIHRoaXMudyA9IG5ld193O1xuICAgICAgdGhpcy5oID0gbmV3X2g7XG5cbiAgICAgIGlmIChjdHgpIHRoaXMuZHJhdyhjdHgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKGN0eCwgeCwgeSkge1xuICAgICAgaWYgKCF4KSB4ID0gMDtcbiAgICAgIGlmICgheSkgeSA9IDA7XG4gICAgICBjdHgucmVjdCh0aGlzLnggKyB4LCB0aGlzLnkgKyB5LCB0aGlzLncsIHRoaXMuaCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBCb3VuZGluZ0JveDtcbn0oKSk7XG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIGBUZXh0Tm90ZWAgaXMgYSBub3RhdGlvbiBlbGVtZW50IHRoYXQgaXMgcG9zaXRpb25lZCBpbiB0aW1lLiBHZW5lcmFsbHkgXG4vLyBtZWFudCBmb3Igb2JqZWN0cyB0aGF0IHNpdCBhYm92ZS9iZWxvdyB0aGUgc3RhZmYgYW5kIGlubGluZSB3aXRoIGVhY2ggb3RoZXIuXG4vLyBFeGFtcGxlcyBvZiB0aGlzIHdvdWxkIGJlIHN1Y2ggYXMgZHluYW1pY3MsIGx5cmljcywgY2hvcmQgY2hhbmdlcywgZXRjLlxuVmV4LkZsb3cuVGV4dE5vdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRleHROb3RlKHRleHRfc3RydWN0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGV4dF9zdHJ1Y3QpO1xuICB9XG5cbiAgVGV4dE5vdGUuSnVzdGlmaWNhdGlvbiA9IHtcbiAgICBMRUZUOiAxLFxuICAgIENFTlRFUjogMixcbiAgICBSSUdIVDogM1xuICB9O1xuXG4gIC8vIEdseXBoIGRhdGFcbiAgVGV4dE5vdGUuR0xZUEhTID0ge1xuICAgIFwic2Vnbm9cIjoge1xuICAgICAgY29kZTogXCJ2OGNcIixcbiAgICAgIHBvaW50OiA0MCxcbiAgICAgIHhfc2hpZnQ6IDAsXG4gICAgICB5X3NoaWZ0OiAtMTBcbiAgICAgIC8vIHdpZHRoOiAxMCAvLyBvcHRpb25hbFxuICAgIH0sXG4gICAgXCJ0clwiOiB7XG4gICAgICBjb2RlOiBcInYxZlwiLFxuICAgICAgcG9pbnQ6IDQwLFxuICAgICAgeF9zaGlmdDogMCxcbiAgICAgIHlfc2hpZnQ6IDBcbiAgICAgIC8vIHdpZHRoOiAxMCAvLyBvcHRpb25hbFxuICAgIH0sXG4gICAgXCJtb3JkZW50X3VwcGVyXCI6IHtcbiAgICAgIGNvZGU6IFwidjFlXCIsXG4gICAgICBwb2ludDogNDAsXG4gICAgICB4X3NoaWZ0OiAwLFxuICAgICAgeV9zaGlmdDogMFxuICAgICAgLy8gd2lkdGg6IDEwIC8vIG9wdGlvbmFsXG4gICAgfSxcbiAgICBcIm1vcmRlbnRfbG93ZXJcIjoge1xuICAgICAgY29kZTogXCJ2NDVcIixcbiAgICAgIHBvaW50OiA0MCxcbiAgICAgIHhfc2hpZnQ6IDAsXG4gICAgICB5X3NoaWZ0OiAwXG4gICAgICAvLyB3aWR0aDogMTAgLy8gb3B0aW9uYWxcbiAgICB9LFxuICAgIFwiZlwiOiB7XG4gICAgICBjb2RlOiBcInZiYVwiLFxuICAgICAgcG9pbnQ6IDQwLFxuICAgICAgeF9zaGlmdDogMCxcbiAgICAgIHlfc2hpZnQ6IDBcbiAgICAgIC8vIHdpZHRoOiAxMCAvLyBvcHRpb25hbFxuICAgIH0sXG4gICAgXCJwXCI6IHtcbiAgICAgIGNvZGU6IFwidmJmXCIsXG4gICAgICBwb2ludDogNDAsXG4gICAgICB4X3NoaWZ0OiAwLFxuICAgICAgeV9zaGlmdDogMFxuICAgICAgLy8gd2lkdGg6IDEwIC8vIG9wdGlvbmFsXG4gICAgfSxcbiAgICBcIm1cIjoge1xuICAgICAgY29kZTogXCJ2NjJcIixcbiAgICAgIHBvaW50OiA0MCxcbiAgICAgIHhfc2hpZnQ6IDAsXG4gICAgICB5X3NoaWZ0OiAwXG4gICAgICAvLyB3aWR0aDogMTAgLy8gb3B0aW9uYWxcbiAgICB9LFxuICAgIFwic1wiOiB7XG4gICAgICBjb2RlOiBcInY0YVwiLFxuICAgICAgcG9pbnQ6IDQwLFxuICAgICAgeF9zaGlmdDogMCxcbiAgICAgIHlfc2hpZnQ6IDBcbiAgICAgIC8vIHdpZHRoOiAxMCAvLyBvcHRpb25hbFxuICAgIH0sXG4gICAgXCJ6XCI6IHtcbiAgICAgIGNvZGU6IFwidjgwXCIsXG4gICAgICBwb2ludDogNDAsXG4gICAgICB4X3NoaWZ0OiAwLFxuICAgICAgeV9zaGlmdDogMFxuICAgICAgLy8gd2lkdGg6IDEwIC8vIG9wdGlvbmFsXG4gICAgfSxcbiAgICBcImNvZGFcIjoge1xuICAgICAgY29kZTogXCJ2NGRcIixcbiAgICAgIHBvaW50OiA0MCxcbiAgICAgIHhfc2hpZnQ6IDAsXG4gICAgICB5X3NoaWZ0OiAtOFxuICAgICAgLy8gd2lkdGg6IDEwIC8vIG9wdGlvbmFsXG4gICAgfSxcbiAgICBcInBlZGFsX29wZW5cIjoge1xuICAgICAgY29kZTogXCJ2MzZcIixcbiAgICAgIHBvaW50OjQwLFxuICAgICAgeF9zaGlmdDowLFxuICAgICAgeV9zaGlmdDowXG4gICAgfSxcbiAgICBcInBlZGFsX2Nsb3NlXCI6IHtcbiAgICAgIGNvZGU6IFwidjVkXCIsXG4gICAgICBwb2ludDo0MCxcbiAgICAgIHhfc2hpZnQ6MCxcbiAgICAgIHlfc2hpZnQ6M1xuICAgIH0sXG4gICAgXCJjYWVzdXJhX3N0cmFpZ2h0XCI6IHtcbiAgICAgIGNvZGU6IFwidjM0XCIsXG4gICAgICBwb2ludDo0MCxcbiAgICAgIHhfc2hpZnQ6MCxcbiAgICAgIHlfc2hpZnQ6MlxuICAgIH0sXG4gICAgXCJjYWVzdXJhX2N1cnZlZFwiOiB7XG4gICAgICBjb2RlOiBcInY0YlwiLFxuICAgICAgcG9pbnQ6NDAsXG4gICAgICB4X3NoaWZ0OjAsXG4gICAgICB5X3NoaWZ0OjJcbiAgICB9LFxuICAgIFwiYnJlYXRoXCI6IHtcbiAgICAgIGNvZGU6IFwidjZjXCIsXG4gICAgICBwb2ludDo0MCxcbiAgICAgIHhfc2hpZnQ6MCxcbiAgICAgIHlfc2hpZnQ6MFxuICAgIH0sXG4gICAgXCJ0aWNrXCI6IHtcbiAgICAgIGNvZGU6IFwidjZmXCIsXG4gICAgICBwb2ludDo1MCxcbiAgICAgIHhfc2hpZnQ6MCxcbiAgICAgIHlfc2hpZnQ6MFxuICAgIH0sXG4gICAgXCJ0dXJuXCI6IHtcbiAgICAgIGNvZGU6IFwidjcyXCIsXG4gICAgICBwb2ludDo0MCxcbiAgICAgIHhfc2hpZnQ6MCxcbiAgICAgIHlfc2hpZnQ6MFxuICAgIH0sXG4gICAgXCJ0dXJuX2ludmVydGVkXCI6IHtcbiAgICAgIGNvZGU6IFwidjMzXCIsXG4gICAgICBwb2ludDo0MCxcbiAgICAgIHhfc2hpZnQ6MCxcbiAgICAgIHlfc2hpZnQ6MFxuICAgIH0sXG5cbiAgICAvLyBERVBSRUNBVEVEIC0gcGxlYXNlIHVzZSBcIm1vcmRlbnRfdXBwZXJcIiBvciBcIm1vcmRlbnRfbG93ZXJcIlxuICAgIFwibW9yZGVudFwiOiB7XG4gICAgICBjb2RlOiBcInYxZVwiLFxuICAgICAgcG9pbnQ6IDQwLFxuICAgICAgeF9zaGlmdDogMCxcbiAgICAgIHlfc2hpZnQ6IDBcbiAgICAgIC8vIHdpZHRoOiAxMCAvLyBvcHRpb25hbFxuICAgIH0sXG4gIH07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgVmV4LkluaGVyaXQoVGV4dE5vdGUsIFZleC5GbG93Lk5vdGUsIHtcbiAgICBpbml0OiBmdW5jdGlvbih0ZXh0X3N0cnVjdCkge1xuICAgICAgVGV4dE5vdGUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgdGV4dF9zdHJ1Y3QpO1xuXG4gICAgICAvLyBOb3RlIHByb3BlcnRpZXNcbiAgICAgIHRoaXMudGV4dCA9IHRleHRfc3RydWN0LnRleHQ7XG4gICAgICB0aGlzLnN1cGVyc2NyaXB0ID0gdGV4dF9zdHJ1Y3Quc3VwZXJzY3JpcHQ7XG4gICAgICB0aGlzLnN1YnNjcmlwdCA9IHRleHRfc3RydWN0LnN1YnNjcmlwdDtcbiAgICAgIHRoaXMuZ2x5cGhfdHlwZSA9IHRleHRfc3RydWN0LmdseXBoO1xuICAgICAgdGhpcy5nbHlwaCA9IG51bGw7XG4gICAgICB0aGlzLmZvbnQgPSB7XG4gICAgICAgIGZhbWlseTogXCJBcmlhbFwiLFxuICAgICAgICBzaXplOiAxMixcbiAgICAgICAgd2VpZ2h0OiBcIlwiXG4gICAgICB9O1xuXG4gICAgICAvLyBTZXQgZm9udFxuICAgICAgaWYgKHRleHRfc3RydWN0LmZvbnQpIHRoaXMuZm9udCA9IHRleHRfc3RydWN0LmZvbnQ7XG5cbiAgICAgIC8vIERldGVybWluZSBhbmQgc2V0IGluaXRpYWwgbm90ZSB3aWR0aC4gTm90ZSB0aGF0IHRoZSB0ZXh0IHdpZHRoIGlzIFxuICAgICAgLy8gYW4gYXBwcm94aW1hdGlvbiBhbmQgaXNuJ3QgdmVyeSBhY2N1cmF0ZS4gVGhlIG9ubHkgd2F5IHRvIGFjY3VyYXRlbHlcbiAgICAgIC8vIG1lYXN1cmUgdGhlIGxlbmd0aCBvZiB0ZXh0IGlzIHdpdGggYGNhbnZhc0NvbnRleHQubWVhc3VyZVRleHQoKWBcbiAgICAgIGlmICh0aGlzLmdseXBoX3R5cGUpIHtcbiAgICAgICAgdmFyIHN0cnVjdCA9IFRleHROb3RlLkdMWVBIU1t0aGlzLmdseXBoX3R5cGVdO1xuICAgICAgICBpZiAoIXN0cnVjdCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiSW52YWxpZCBnbHlwaCB0eXBlOiBcIiArIHRoaXMuZ2x5cGhfdHlwZSk7XG5cbiAgICAgICAgdGhpcy5nbHlwaCA9IG5ldyBWZXguRmxvdy5HbHlwaChzdHJ1Y3QuY29kZSwgc3RydWN0LnBvaW50LCB7Y2FjaGU6IGZhbHNlfSk7XG5cbiAgICAgICAgaWYgKHN0cnVjdC53aWR0aClcbiAgICAgICAgICB0aGlzLnNldFdpZHRoKHN0cnVjdC53aWR0aCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLnNldFdpZHRoKHRoaXMuZ2x5cGguZ2V0TWV0cmljcygpLndpZHRoKTtcblxuICAgICAgICB0aGlzLmdseXBoX3N0cnVjdCA9IHN0cnVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0V2lkdGgoVmV4LkZsb3cudGV4dFdpZHRoKHRoaXMudGV4dCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5saW5lID0gdGV4dF9zdHJ1Y3QubGluZSB8fCAwO1xuICAgICAgdGhpcy5zbW9vdGggPSB0ZXh0X3N0cnVjdC5zbW9vdGggfHwgZmFsc2U7XG4gICAgICB0aGlzLmlnbm9yZV90aWNrcyA9IHRleHRfc3RydWN0Lmlnbm9yZV90aWNrcyB8fCBmYWxzZTtcbiAgICAgIHRoaXMuanVzdGlmaWNhdGlvbiA9IFRleHROb3RlLkp1c3RpZmljYXRpb24uTEVGVDtcbiAgICB9LFxuXG4gICAgLy8gU2V0IHRoZSBob3Jpem9udGFsIGp1c3RpZmljYXRpb24gb2YgdGhlIFRleHROb3RlXG4gICAgc2V0SnVzdGlmaWNhdGlvbjogZnVuY3Rpb24oanVzdCkge1xuICAgICAgdGhpcy5qdXN0aWZpY2F0aW9uID0ganVzdDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIFN0YXZlIGxpbmUgb24gd2hpY2ggdGhlIG5vdGUgc2hvdWxkIGJlIHBsYWNlZFxuICAgIHNldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUHJlLXJlbmRlciBmb3JtYXR0aW5nXG4gICAgcHJlRm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1JlbmRlckNvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IG1lYXN1cmUgdGV4dCB3aXRob3V0IHJlbmRlcmluZyBjb250ZXh0LlwiKTtcbiAgICAgIGlmICh0aGlzLnByZUZvcm1hdHRlZCkgcmV0dXJuO1xuXG4gICAgICBpZiAodGhpcy5zbW9vdGgpIHtcbiAgICAgICAgdGhpcy5zZXRXaWR0aCgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmdseXBoKSB7XG4gICAgICAgICAgLy8gV2lkdGggYWxyZWFkeSBzZXQuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLmNvbnRleHQubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuanVzdGlmaWNhdGlvbiA9PSBUZXh0Tm90ZS5KdXN0aWZpY2F0aW9uLkNFTlRFUikge1xuICAgICAgICB0aGlzLmV4dHJhTGVmdFB4ID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuanVzdGlmaWNhdGlvbiA9PSBUZXh0Tm90ZS5KdXN0aWZpY2F0aW9uLlJJR0hUKSB7XG4gICAgICAgIHRoaXMuZXh0cmFMZWZ0UHggPSB0aGlzLndpZHRoO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFByZUZvcm1hdHRlZCh0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gUmVuZGVycyB0aGUgVGV4dE5vdGVcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgd2l0aG91dCBhIGNhbnZhcyBjb250ZXh0LlwiKTtcbiAgICAgIGlmICghdGhpcy5zdGF2ZSkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9TdGF2ZVwiLCBcIkNhbid0IGRyYXcgd2l0aG91dCBhIHN0YXZlLlwiKTtcblxuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciB4ID0gdGhpcy5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgIGlmICh0aGlzLmp1c3RpZmljYXRpb24gPT0gVGV4dE5vdGUuSnVzdGlmaWNhdGlvbi5DRU5URVIpIHtcbiAgICAgICAgeCAtPSB0aGlzLmdldFdpZHRoKCkgLyAyO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmp1c3RpZmljYXRpb24gPT0gVGV4dE5vdGUuSnVzdGlmaWNhdGlvbi5SSUdIVCkge1xuICAgICAgICB4IC09IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHk7XG4gICAgICBpZiAodGhpcy5nbHlwaCkge1xuICAgICAgICB5ID0gdGhpcy5zdGF2ZS5nZXRZRm9yTGluZSh0aGlzLmxpbmUgKyAoLTMpKTtcbiAgICAgICAgdGhpcy5nbHlwaC5yZW5kZXIodGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB4ICsgdGhpcy5nbHlwaF9zdHJ1Y3QueF9zaGlmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeSArIHRoaXMuZ2x5cGhfc3RydWN0Lnlfc2hpZnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHRoaXMuc3RhdmUuZ2V0WUZvckxpbmUodGhpcy5saW5lICsgKC0zKSk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zZXRGb250KHRoaXMuZm9udC5mYW1pbHksIHRoaXMuZm9udC5zaXplLCB0aGlzLmZvbnQud2VpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMudGV4dCwgeCwgeSk7XG5cbiAgICAgICAgLy8gV2lkdGggb2YgdGhlIGxldHRlciBNIGdpdmVzIHVzIHRoZSBhcHByb3hpbWF0ZSBoZWlnaHQgb2YgdGhlIHRleHRcbiAgICAgICAgdmFyIGhlaWdodCA9IGN0eC5tZWFzdXJlVGV4dChcIk1cIikud2lkdGg7XG4gICAgICAgIC8vIEdldCBhY2N1cmF0ZSB3aWR0aCBvZiB0ZXh0XG4gICAgICAgIHZhciB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLnRleHQpLndpZHRoO1xuXG4gICAgICAgIC8vIFdyaXRlIHN1cGVyc2NyaXB0XG4gICAgICAgIGlmICh0aGlzLnN1cGVyc2NyaXB0KSB7XG4gICAgICAgICAgY3R4LnNldEZvbnQodGhpcy5mb250LmZhbWlseSwgdGhpcy5mb250LnNpemUgLyAxLjMsIHRoaXMuZm9udC53ZWlnaHQpO1xuICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnN1cGVyc2NyaXB0LCB4ICsgd2lkdGggKyAyLCB5IC0gKGhlaWdodC8yLjIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIHN1YnNjcmlwdFxuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHQpIHtcbiAgICAgICAgICBjdHguc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSAvIDEuMywgdGhpcy5mb250LndlaWdodCk7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMuc3Vic2NyaXB0LCB4ICsgd2lkdGggKyAyLCB5ICsgKGhlaWdodC8yLjIpIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFRleHROb3RlO1xufSgpKTtcblxuLy8gVmV4RmxvdyAtIE11c2ljIEVuZ3JhdmluZyBmb3IgSFRNTDVcclxuLy8gQ29weXJpZ2h0IE1vaGl0IE11dGhhbm5hIDIwMTBcclxuLy8gQXV0aG9yIExhcnJ5IEt1aG5zIDIwMTNcclxuLy8gQ2xhc3MgdG8gZHJhd3Mgc3RyaW5nIG51bWJlcnMgaW50byB0aGUgbm90YXRpb24uXHJcblxyXG4vKipcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5WZXguRmxvdy5GcmV0SGFuZEZpbmdlciA9IChmdW5jdGlvbigpIHtcclxuICBmdW5jdGlvbiBGcmV0SGFuZEZpbmdlcihudW1iZXIpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG51bWJlcik7XHJcbiAgfVxyXG4gIEZyZXRIYW5kRmluZ2VyLkNBVEVHT1JZID0gXCJmcmV0aGFuZGZpbmdlclwiO1xyXG5cclxuICB2YXIgTW9kaWZpZXIgPSBWZXguRmxvdy5Nb2RpZmllcjtcclxuXHJcbiAgLy8gQXJyYW5nZSBmaW5nZXJpbmdzIGluc2lkZSBhIE1vZGlmaWVyQ29udGV4dC5cclxuICBGcmV0SGFuZEZpbmdlci5mb3JtYXQgPSBmdW5jdGlvbihudW1zLCBzdGF0ZSkge1xyXG4gICAgdmFyIGxlZnRfc2hpZnQgPSBzdGF0ZS5sZWZ0X3NoaWZ0O1xyXG4gICAgdmFyIHJpZ2h0X3NoaWZ0ID0gc3RhdGUucmlnaHRfc2hpZnQ7XHJcbiAgICB2YXIgbnVtX3NwYWNpbmcgPSAxO1xyXG5cclxuICAgIGlmICghbnVtcyB8fCBudW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHZhciBudW1zX2xpc3QgPSBbXTtcclxuICAgIHZhciBwcmV2X25vdGUgPSBudWxsO1xyXG4gICAgdmFyIHNoaWZ0X2xlZnQgPSAwO1xyXG4gICAgdmFyIHNoaWZ0X3JpZ2h0ID0gMDtcclxuXHJcbiAgICB2YXIgaSwgbnVtLCBub3RlLCBwb3MsIHByb3BzX3RtcDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIG51bSA9IG51bXNbaV07XHJcbiAgICAgIG5vdGUgPSBudW0uZ2V0Tm90ZSgpO1xyXG4gICAgICBwb3MgPSBudW0uZ2V0UG9zaXRpb24oKTtcclxuICAgICAgdmFyIHByb3BzID0gbm90ZS5nZXRLZXlQcm9wcygpW251bS5nZXRJbmRleCgpXTtcclxuICAgICAgaWYgKG5vdGUgIT0gcHJldl9ub3RlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub3RlLmtleXMubGVuZ3RoOyArK24pIHtcclxuICAgICAgICAgIHByb3BzX3RtcCA9IG5vdGUuZ2V0S2V5UHJvcHMoKVtuXTtcclxuICAgICAgICAgIGlmIChsZWZ0X3NoaWZ0ID09PSAwKVxyXG4gICAgICAgICAgICBzaGlmdF9sZWZ0ID0gKHByb3BzX3RtcC5kaXNwbGFjZWQgPyBub3RlLmdldEV4dHJhTGVmdFB4KCkgOiBzaGlmdF9sZWZ0KTtcclxuICAgICAgICAgIGlmIChyaWdodF9zaGlmdCA9PT0gMClcclxuICAgICAgICAgICAgc2hpZnRfcmlnaHQgPSAocHJvcHNfdG1wLmRpc3BsYWNlZCA/IG5vdGUuZ2V0RXh0cmFSaWdodFB4KCkgOiBzaGlmdF9yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZfbm90ZSA9IG5vdGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG51bXNfbGlzdC5wdXNoKHsgbGluZTogcHJvcHMubGluZSwgcG9zOiBwb3MsIHNoaWZ0TDogc2hpZnRfbGVmdCwgc2hpZnRSOiBzaGlmdF9yaWdodCwgbm90ZTogbm90ZSwgbnVtOiBudW0gfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU29ydCBmaW5nZXJudW1iZXJzIGJ5IGxpbmUgbnVtYmVyLlxyXG4gICAgbnVtc19saXN0LnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gKGIubGluZSAtIGEubGluZSk7IH0pO1xyXG5cclxuICAgIHZhciBudW1fc2hpZnRMID0gMDtcclxuICAgIHZhciBudW1fc2hpZnRSID0gMDtcclxuICAgIHZhciB4X3dpZHRoTCA9IDA7XHJcbiAgICB2YXIgeF93aWR0aFIgPSAwO1xyXG4gICAgdmFyIGxhc3RfbGluZSA9IG51bGw7XHJcbiAgICB2YXIgbGFzdF9ub3RlID0gbnVsbDtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtc19saXN0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHZhciBudW1fc2hpZnQgPSAwO1xyXG4gICAgICBub3RlID0gbnVtc19saXN0W2ldLm5vdGU7XHJcbiAgICAgIHBvcyA9IG51bXNfbGlzdFtpXS5wb3M7XHJcbiAgICAgIG51bSA9IG51bXNfbGlzdFtpXS5udW07XHJcbiAgICAgIHZhciBsaW5lID0gbnVtc19saXN0W2ldLmxpbmU7XHJcbiAgICAgIHZhciBzaGlmdEwgPSBudW1zX2xpc3RbaV0uc2hpZnRMO1xyXG4gICAgICB2YXIgc2hpZnRSID0gbnVtc19saXN0W2ldLnNoaWZ0UjtcclxuXHJcbiAgICAgIC8vIFJlc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc3RyaW5nIG51bWJlciBldmVyeSBsaW5lLlxyXG4gICAgICBpZiAobGluZSAhPSBsYXN0X2xpbmUgfHwgbm90ZSAhPSBsYXN0X25vdGUpIHtcclxuICAgICAgICBudW1fc2hpZnRMID0gbGVmdF9zaGlmdCArIHNoaWZ0TDtcclxuICAgICAgICBudW1fc2hpZnRSID0gcmlnaHRfc2hpZnQgKyBzaGlmdFI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBudW1fd2lkdGggPSBudW0uZ2V0V2lkdGgoKSArIG51bV9zcGFjaW5nO1xyXG4gICAgICBpZiAocG9zID09IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLkxFRlQpIHtcclxuICAgICAgICBudW0uc2V0WFNoaWZ0KGxlZnRfc2hpZnQgKyBudW1fc2hpZnRMKTtcclxuICAgICAgICBudW1fc2hpZnQgPSBsZWZ0X3NoaWZ0ICsgbnVtX3dpZHRoOyAvLyBzcGFjaW5nXHJcbiAgICAgICAgeF93aWR0aEwgPSAobnVtX3NoaWZ0ID4geF93aWR0aEwpID8gbnVtX3NoaWZ0IDogeF93aWR0aEw7XHJcbiAgICAgIH0gZWxzZSBpZiAocG9zID09IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLlJJR0hUKSB7XHJcbiAgICAgICAgbnVtLnNldFhTaGlmdChudW1fc2hpZnRSKTtcclxuICAgICAgICBudW1fc2hpZnQgPSBzaGlmdF9yaWdodCArIG51bV93aWR0aDsgLy8gc3BhY2luZ1xyXG4gICAgICAgIHhfd2lkdGhSID0gKG51bV9zaGlmdCA+IHhfd2lkdGhSKSA/IG51bV9zaGlmdCA6IHhfd2lkdGhSO1xyXG4gICAgICB9XHJcbiAgICAgIGxhc3RfbGluZSA9IGxpbmU7XHJcbiAgICAgIGxhc3Rfbm90ZSA9IG5vdGU7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGUubGVmdF9zaGlmdCArPSB4X3dpZHRoTDtcclxuICAgIHN0YXRlLnJpZ2h0X3NoaWZ0ICs9IHhfd2lkdGhSO1xyXG4gIH07XHJcblxyXG4gIFZleC5Jbmhlcml0KEZyZXRIYW5kRmluZ2VyLCBNb2RpZmllciwge1xyXG4gICAgaW5pdDogZnVuY3Rpb24obnVtYmVyKSB7XHJcbiAgICAgIHZhciBzdXBlcmNsYXNzID0gVmV4LkZsb3cuRnJldEhhbmRGaW5nZXIuc3VwZXJjbGFzcztcclxuICAgICAgc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICB0aGlzLm5vdGUgPSBudWxsO1xyXG4gICAgICB0aGlzLmluZGV4ID0gbnVsbDtcclxuICAgICAgdGhpcy5maW5nZXIgPSBudW1iZXI7XHJcbiAgICAgIHRoaXMud2lkdGggPSA3O1xyXG4gICAgICB0aGlzLnBvc2l0aW9uID0gTW9kaWZpZXIuUG9zaXRpb24uTEVGVDsgIC8vIERlZmF1bHQgcG9zaXRpb24gYWJvdmUgc3RlbSBvciBub3RlIGhlYWRcclxuICAgICAgdGhpcy54X3NoaWZ0ID0gMDtcclxuICAgICAgdGhpcy55X3NoaWZ0ID0gMDtcclxuICAgICAgdGhpcy54X29mZnNldCA9IDA7ICAgICAgIC8vIEhvcml6b250YWwgb2Zmc2V0IGZyb20gZGVmYXVsdFxyXG4gICAgICB0aGlzLnlfb2Zmc2V0ID0gMDsgICAgICAgLy8gVmVydGljYWwgb2Zmc2V0IGZyb20gZGVmYXVsdFxyXG4gICAgICB0aGlzLmZvbnQgPSB7XHJcbiAgICAgICAgZmFtaWx5OiBcInNhbnMtc2VyaWZcIixcclxuICAgICAgICBzaXplOiA5LFxyXG4gICAgICAgIHdlaWdodDogXCJib2xkXCJcclxuICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Tm90ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5vdGU7IH0sXHJcbiAgICBzZXROb3RlOiBmdW5jdGlvbihub3RlKSB7IHRoaXMubm90ZSA9IG5vdGU7IHJldHVybiB0aGlzOyB9LFxyXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfSxcclxuICAgIHNldEluZGV4OiBmdW5jdGlvbihpbmRleCkgeyB0aGlzLmluZGV4ID0gaW5kZXg7IHJldHVybiB0aGlzOyB9LFxyXG4gICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5wb3NpdGlvbjsgfSxcclxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgICBpZiAocG9zaXRpb24gPj0gTW9kaWZpZXIuUG9zaXRpb24uTEVGVCAmJlxyXG4gICAgICAgICAgcG9zaXRpb24gPD0gTW9kaWZpZXIuUG9zaXRpb24uQkVMT1cpXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBzZXRGcmV0SGFuZEZpbmdlcjogZnVuY3Rpb24obnVtYmVyKSB7IHRoaXMuZmluZ2VyID0gbnVtYmVyOyByZXR1cm4gdGhpczsgfSxcclxuICAgIHNldE9mZnNldFg6IGZ1bmN0aW9uKHgpIHsgdGhpcy54X29mZnNldCA9IHg7IHJldHVybiB0aGlzOyB9LFxyXG4gICAgc2V0T2Zmc2V0WTogZnVuY3Rpb24oeSkgeyB0aGlzLnlfb2Zmc2V0ID0geTsgcmV0dXJuIHRoaXM7IH0sXHJcblxyXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcclxuICAgICAgICBcIkNhbid0IGRyYXcgc3RyaW5nIG51bWJlciB3aXRob3V0IGEgY29udGV4dC5cIik7XHJcbiAgICAgIGlmICghKHRoaXMubm90ZSAmJiAodGhpcy5pbmRleCAhPSBudWxsKSkpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQXR0YWNoZWROb3RlXCIsXHJcbiAgICAgICAgXCJDYW4ndCBkcmF3IHN0cmluZyBudW1iZXIgd2l0aG91dCBhIG5vdGUgYW5kIGluZGV4LlwiKTtcclxuXHJcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgIHZhciBzdGFydCA9IHRoaXMubm90ZS5nZXRNb2RpZmllclN0YXJ0WFkodGhpcy5wb3NpdGlvbiwgdGhpcy5pbmRleCk7XHJcbiAgICAgIHZhciBkb3RfeCA9IChzdGFydC54ICsgdGhpcy54X3NoaWZ0ICsgdGhpcy54X29mZnNldCk7XHJcbiAgICAgIHZhciBkb3RfeSA9IHN0YXJ0LnkgKyB0aGlzLnlfc2hpZnQgKyB0aGlzLnlfb2Zmc2V0ICsgNTtcclxuXHJcbiAgICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xyXG4gICAgICAgIGNhc2UgTW9kaWZpZXIuUG9zaXRpb24uQUJPVkU6XHJcbiAgICAgICAgICBkb3RfeCAtPSA0O1xyXG4gICAgICAgICAgZG90X3kgLT0gMTI7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIE1vZGlmaWVyLlBvc2l0aW9uLkJFTE9XOlxyXG4gICAgICAgICAgZG90X3ggLT0gMjtcclxuICAgICAgICAgIGRvdF95ICs9IDEwO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBNb2RpZmllci5Qb3NpdGlvbi5MRUZUOlxyXG4gICAgICAgICAgZG90X3ggLT0gdGhpcy53aWR0aDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTW9kaWZpZXIuUG9zaXRpb24uUklHSFQ6XHJcbiAgICAgICAgICBkb3RfeCArPSAxO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgIGN0eC5zZXRGb250KHRoaXMuZm9udC5mYW1pbHksIHRoaXMuZm9udC5zaXplLCB0aGlzLmZvbnQud2VpZ2h0KTtcclxuICAgICAgY3R4LmZpbGxUZXh0KFwiXCIgKyB0aGlzLmZpbmdlciwgZG90X3gsIGRvdF95KTtcclxuXHJcbiAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBGcmV0SGFuZEZpbmdlcjtcclxufSgpKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxyXG4vLyBBdXRob3I6IExhcnJ5IEt1aG5zXHJcbi8vXHJcbi8vICMjIERlc2NyaXB0aW9uXHJcbi8vXHJcbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIHRoZSBgU3RyaW5nTnVtYmVyYCBjbGFzcyB3aGljaCByZW5kZXJzIHN0cmluZ1xyXG4vLyBudW1iZXIgYW5ub3RhdGlvbnMgYmVzaWRlIG5vdGVzLlxyXG5cclxuVmV4LkZsb3cuU3RyaW5nTnVtYmVyID0gKGZ1bmN0aW9uKCkge1xyXG4gIGZ1bmN0aW9uIFN0cmluZ051bWJlcihudW1iZXIpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG51bWJlcik7XHJcbiAgfVxyXG4gIFN0cmluZ051bWJlci5DQVRFR09SWSA9IFwic3RyaW5nbnVtYmVyXCI7XHJcblxyXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xyXG5cclxuICAvLyAjIyBTdGF0aWMgTWV0aG9kc1xyXG4gIC8vIEFycmFuZ2Ugc3RyaW5nIG51bWJlcnMgaW5zaWRlIGEgYE1vZGlmaWVyQ29udGV4dGBcclxuICBTdHJpbmdOdW1iZXIuZm9ybWF0ID0gZnVuY3Rpb24obnVtcywgc3RhdGUpIHtcclxuICAgIHZhciBsZWZ0X3NoaWZ0ID0gc3RhdGUubGVmdF9zaGlmdDtcclxuICAgIHZhciByaWdodF9zaGlmdCA9IHN0YXRlLnJpZ2h0X3NoaWZ0O1xyXG4gICAgdmFyIG51bV9zcGFjaW5nID0gMTtcclxuXHJcbiAgICBpZiAoIW51bXMgfHwgbnVtcy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzO1xyXG5cclxuICAgIHZhciBudW1zX2xpc3QgPSBbXTtcclxuICAgIHZhciBwcmV2X25vdGUgPSBudWxsO1xyXG4gICAgdmFyIHNoaWZ0X2xlZnQgPSAwO1xyXG4gICAgdmFyIHNoaWZ0X3JpZ2h0ID0gMDtcclxuXHJcbiAgICB2YXIgaSwgbnVtLCBub3RlLCBwb3MsIHByb3BzX3RtcDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIG51bSA9IG51bXNbaV07XHJcbiAgICAgIG5vdGUgPSBudW0uZ2V0Tm90ZSgpO1xyXG5cclxuICAgICAgZm9yIChpID0gMDsgaSA8IG51bXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBudW0gPSBudW1zW2ldO1xyXG4gICAgICAgIG5vdGUgPSBudW0uZ2V0Tm90ZSgpO1xyXG4gICAgICAgIHBvcyA9IG51bS5nZXRQb3NpdGlvbigpO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IG5vdGUuZ2V0S2V5UHJvcHMoKVtudW0uZ2V0SW5kZXgoKV07XHJcblxyXG4gICAgICAgIGlmIChub3RlICE9IHByZXZfbm90ZSkge1xyXG4gICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub3RlLmtleXMubGVuZ3RoOyArK24pIHtcclxuICAgICAgICAgICAgcHJvcHNfdG1wID0gbm90ZS5nZXRLZXlQcm9wcygpW25dO1xyXG4gICAgICAgICAgICBpZiAobGVmdF9zaGlmdCA9PT0gMClcclxuICAgICAgICAgICAgICBzaGlmdF9sZWZ0ID0gKHByb3BzX3RtcC5kaXNwbGFjZWQgPyBub3RlLmdldEV4dHJhTGVmdFB4KCkgOiBzaGlmdF9sZWZ0KTtcclxuICAgICAgICAgICAgaWYgKHJpZ2h0X3NoaWZ0ID09PSAwKVxyXG4gICAgICAgICAgICAgIHNoaWZ0X3JpZ2h0ID0gKHByb3BzX3RtcC5kaXNwbGFjZWQgPyBub3RlLmdldEV4dHJhUmlnaHRQeCgpIDogc2hpZnRfcmlnaHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcHJldl9ub3RlID0gbm90ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG51bXNfbGlzdC5wdXNoKHsgbGluZTogcHJvcHMubGluZSwgcG9zOiBwb3MsIHNoaWZ0TDogc2hpZnRfbGVmdCwgc2hpZnRSOiBzaGlmdF9yaWdodCwgbm90ZTogbm90ZSwgbnVtOiBudW0gfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTb3J0IHN0cmluZyBudW1iZXJzIGJ5IGxpbmUgbnVtYmVyLlxyXG4gICAgbnVtc19saXN0LnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gKGIubGluZSAtIGEubGluZSk7IH0pO1xyXG5cclxuICAgIHZhciBudW1fc2hpZnRMID0gMDtcclxuICAgIHZhciBudW1fc2hpZnRSID0gMDtcclxuICAgIHZhciB4X3dpZHRoTCA9IDA7XHJcbiAgICB2YXIgeF93aWR0aFIgPSAwO1xyXG4gICAgdmFyIGxhc3RfbGluZSA9IG51bGw7XHJcbiAgICB2YXIgbGFzdF9ub3RlID0gbnVsbDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBudW1zX2xpc3QubGVuZ3RoOyArK2kpIHtcclxuICAgICAgdmFyIG51bV9zaGlmdCA9IDA7XHJcbiAgICAgIG5vdGUgPSBudW1zX2xpc3RbaV0ubm90ZTtcclxuICAgICAgcG9zID0gbnVtc19saXN0W2ldLnBvcztcclxuICAgICAgbnVtID0gbnVtc19saXN0W2ldLm51bTtcclxuICAgICAgdmFyIGxpbmUgPSBudW1zX2xpc3RbaV0ubGluZTtcclxuICAgICAgdmFyIHNoaWZ0TCA9IG51bXNfbGlzdFtpXS5zaGlmdEw7XHJcbiAgICAgIHZhciBzaGlmdFIgPSBudW1zX2xpc3RbaV0uc2hpZnRSO1xyXG5cclxuICAgICAgLy8gUmVzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBzdHJpbmcgbnVtYmVyIGV2ZXJ5IGxpbmUuXHJcbiAgICAgIGlmIChsaW5lICE9IGxhc3RfbGluZSB8fCBub3RlICE9IGxhc3Rfbm90ZSkge1xyXG4gICAgICAgIG51bV9zaGlmdEwgPSBsZWZ0X3NoaWZ0ICsgc2hpZnRMO1xyXG4gICAgICAgIG51bV9zaGlmdFIgPSByaWdodF9zaGlmdCArIHNoaWZ0UjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG51bV93aWR0aCA9IG51bS5nZXRXaWR0aCgpICsgbnVtX3NwYWNpbmc7XHJcbiAgICAgIGlmIChwb3MgPT0gVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uTEVGVCkge1xyXG4gICAgICAgIG51bS5zZXRYU2hpZnQobGVmdF9zaGlmdCk7XHJcbiAgICAgICAgbnVtX3NoaWZ0ID0gc2hpZnRfbGVmdCArIG51bV93aWR0aDsgLy8gc3BhY2luZ1xyXG4gICAgICAgIHhfd2lkdGhMID0gKG51bV9zaGlmdCA+IHhfd2lkdGhMKSA/IG51bV9zaGlmdCA6IHhfd2lkdGhMO1xyXG4gICAgICB9IGVsc2UgaWYgKHBvcyA9PSBWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5SSUdIVCkge1xyXG4gICAgICAgIG51bS5zZXRYU2hpZnQobnVtX3NoaWZ0Uik7XHJcbiAgICAgICAgbnVtX3NoaWZ0ICs9IG51bV93aWR0aDsgLy8gc3BhY2luZ1xyXG4gICAgICAgIHhfd2lkdGhSID0gKG51bV9zaGlmdCA+IHhfd2lkdGhSKSA/IG51bV9zaGlmdCA6IHhfd2lkdGhSO1xyXG4gICAgICB9XHJcbiAgICAgIGxhc3RfbGluZSA9IGxpbmU7XHJcbiAgICAgIGxhc3Rfbm90ZSA9IG5vdGU7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGUubGVmdF9zaGlmdCArPSB4X3dpZHRoTDtcclxuICAgIHN0YXRlLnJpZ2h0X3NoaWZ0ICs9IHhfd2lkdGhSO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcclxuICBWZXguSW5oZXJpdChTdHJpbmdOdW1iZXIsIE1vZGlmaWVyLCB7XHJcbiAgICBpbml0OiBmdW5jdGlvbihudW1iZXIpIHtcclxuICAgICAgU3RyaW5nTnVtYmVyLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgdGhpcy5ub3RlID0gbnVsbDtcclxuICAgICAgdGhpcy5sYXN0X25vdGUgPSBudWxsO1xyXG4gICAgICB0aGlzLmluZGV4ID0gbnVsbDtcclxuICAgICAgdGhpcy5zdHJpbmdfbnVtYmVyID0gbnVtYmVyO1xyXG4gICAgICB0aGlzLnNldFdpZHRoKDIwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA/Pz9cclxuICAgICAgdGhpcy5wb3NpdGlvbiA9IE1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFOyAgLy8gRGVmYXVsdCBwb3NpdGlvbiBhYm92ZSBzdGVtIG9yIG5vdGUgaGVhZFxyXG4gICAgICB0aGlzLnhfc2hpZnQgPSAwO1xyXG4gICAgICB0aGlzLnlfc2hpZnQgPSAwO1xyXG4gICAgICB0aGlzLnhfb2Zmc2V0ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBvZmZzZXQgZnJvbSBkZWZhdWx0XHJcbiAgICAgIHRoaXMueV9vZmZzZXQgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJ0aWNhbCBvZmZzZXQgZnJvbSBkZWZhdWx0XHJcbiAgICAgIHRoaXMuZGFzaGVkID0gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIC0gZHJhdyBkYXNoZWQgZXh0ZW5zaW9uICBmYWxzZSAtIG5vIGV4dGVuc2lvblxyXG4gICAgICB0aGlzLmxlZyA9IFZleC5GbG93LlJlbmRlcmVyLkxpbmVFbmRUeXBlLk5PTkU7ICAgLy8gZHJhdyB1cHdhcmQvZG93bndhcmQgbGVnIGF0IHRoZSBvZiBleHRlbnNpb24gbGluZVxyXG4gICAgICB0aGlzLnJhZGl1cyA9IDg7XHJcbiAgICAgIHRoaXMuZm9udCA9IHtcclxuICAgICAgICBmYW1pbHk6IFwic2Fucy1zZXJpZlwiLFxyXG4gICAgICAgIHNpemU6IDEwLFxyXG4gICAgICAgIHdlaWdodDogXCJib2xkXCJcclxuICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Tm90ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5vdGU7IH0sXHJcbiAgICBzZXROb3RlOiBmdW5jdGlvbihub3RlKSB7IHRoaXMubm90ZSA9IG5vdGU7IHJldHVybiB0aGlzOyB9LFxyXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfSxcclxuICAgIHNldEluZGV4OiBmdW5jdGlvbihpbmRleCkgeyB0aGlzLmluZGV4ID0gaW5kZXg7IHJldHVybiB0aGlzOyB9LFxyXG5cclxuICAgIHNldExpbmVFbmRUeXBlOiBmdW5jdGlvbihsZWcpIHtcclxuICAgICAgaWYgKGxlZyA+PSBWZXguRmxvdy5SZW5kZXJlci5MaW5lRW5kVHlwZS5OT05FICYmXHJcbiAgICAgICAgICBsZWcgPD0gVmV4LkZsb3cuUmVuZGVyZXIuTGluZUVuZFR5cGUuRE9XTilcclxuICAgICAgICB0aGlzLmxlZyA9IGxlZztcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucG9zaXRpb247IH0sXHJcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgICAgaWYgKHBvc2l0aW9uID49IE1vZGlmaWVyLlBvc2l0aW9uLkxFRlQgJiZcclxuICAgICAgICAgIHBvc2l0aW9uIDw9IE1vZGlmaWVyLlBvc2l0aW9uLkJFTE9XKVxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFN0cmluZ051bWJlcjogZnVuY3Rpb24obnVtYmVyKSB7IHRoaXMuc3RyaW5nX251bWJlciA9IG51bWJlcjsgcmV0dXJuIHRoaXM7IH0sXHJcbiAgICBzZXRPZmZzZXRYOiBmdW5jdGlvbih4KSB7IHRoaXMueF9vZmZzZXQgPSB4OyByZXR1cm4gdGhpczsgfSxcclxuICAgIHNldE9mZnNldFk6IGZ1bmN0aW9uKHkpIHsgdGhpcy55X29mZnNldCA9IHk7IHJldHVybiB0aGlzOyB9LFxyXG4gICAgc2V0TGFzdE5vdGU6IGZ1bmN0aW9uKG5vdGUpIHsgdGhpcy5sYXN0X25vdGUgPSBub3RlOyByZXR1cm4gdGhpczsgfSxcclxuICAgIHNldERhc2hlZDogZnVuY3Rpb24oZGFzaGVkKSB7IHRoaXMuZGFzaGVkID0gZGFzaGVkOyByZXR1cm4gdGhpczsgfSxcclxuXHJcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxyXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBzdHJpbmcgbnVtYmVyIHdpdGhvdXQgYSBjb250ZXh0LlwiKTtcclxuICAgICAgaWYgKCEodGhpcy5ub3RlICYmICh0aGlzLmluZGV4ICE9IG51bGwpKSkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9BdHRhY2hlZE5vdGVcIixcclxuICAgICAgICBcIkNhbid0IGRyYXcgc3RyaW5nIG51bWJlciB3aXRob3V0IGEgbm90ZSBhbmQgaW5kZXguXCIpO1xyXG5cclxuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgdmFyIGxpbmVfc3BhY2UgPSB0aGlzLm5vdGUuc3RhdmUub3B0aW9ucy5zcGFjaW5nX2JldHdlZW5fbGluZXNfcHg7XHJcblxyXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLm5vdGUuZ2V0TW9kaWZpZXJTdGFydFhZKHRoaXMucG9zaXRpb24sIHRoaXMuaW5kZXgpO1xyXG4gICAgICB2YXIgZG90X3ggPSAoc3RhcnQueCArIHRoaXMueF9zaGlmdCArIHRoaXMueF9vZmZzZXQpO1xyXG4gICAgICB2YXIgZG90X3kgPSBzdGFydC55ICsgdGhpcy55X3NoaWZ0ICsgdGhpcy55X29mZnNldDtcclxuXHJcbiAgICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xyXG4gICAgICAgIGNhc2UgTW9kaWZpZXIuUG9zaXRpb24uQUJPVkU6XHJcbiAgICAgICAgY2FzZSBNb2RpZmllci5Qb3NpdGlvbi5CRUxPVzpcclxuICAgICAgICAgIHZhciBzdGVtX2V4dCA9IHRoaXMubm90ZS5nZXRTdGVtRXh0ZW50cygpO1xyXG4gICAgICAgICAgdmFyIHRvcCA9IHN0ZW1fZXh0LnRvcFk7XHJcbiAgICAgICAgICB2YXIgYm90dG9tID0gc3RlbV9leHQuYmFzZVkgKyAyO1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLm5vdGUuc3RlbV9kaXJlY3Rpb24gPT0gVmV4LkZsb3cuU3RhdmVOb3RlLlNURU1fRE9XTikge1xyXG4gICAgICAgICAgICB0b3AgPSBzdGVtX2V4dC5iYXNlWTtcclxuICAgICAgICAgICAgYm90dG9tID0gc3RlbV9leHQudG9wWSAtIDI7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gTW9kaWZpZXIuUG9zaXRpb24uQUJPVkUpIHtcclxuICAgICAgICAgICAgZG90X3kgPSB0aGlzLm5vdGUuaGFzU3RlbSgpID8gdG9wIC0gKGxpbmVfc3BhY2UgKiAxLjc1KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdGFydC55IC0gKGxpbmVfc3BhY2UgKiAxLjc1KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkb3RfeSA9IHRoaXMubm90ZS5oYXNTdGVtKCkgPyBib3R0b20gKyAobGluZV9zcGFjZSAqIDEuNSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc3RhcnQueSArIChsaW5lX3NwYWNlICogMS43NSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZG90X3kgKz0gdGhpcy55X3NoaWZ0ICsgdGhpcy55X29mZnNldDtcclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIE1vZGlmaWVyLlBvc2l0aW9uLkxFRlQ6XHJcbiAgICAgICAgICBkb3RfeCAtPSAodGhpcy5yYWRpdXMgLyAyKSArIDU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIE1vZGlmaWVyLlBvc2l0aW9uLlJJR0hUOlxyXG4gICAgICAgICAgZG90X3ggKz0gKHRoaXMucmFkaXVzIC8gMikgKyA2O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgY3R4LmFyYyhkb3RfeCwgZG90X3ksIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xyXG4gICAgICBjdHgubGluZVdpZHRoID0gMS41O1xyXG4gICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgIGN0eC5zZXRGb250KHRoaXMuZm9udC5mYW1pbHksIHRoaXMuZm9udC5zaXplLCB0aGlzLmZvbnQud2VpZ2h0KTtcclxuICAgICAgdmFyIHggPSBkb3RfeCAtIGN0eC5tZWFzdXJlVGV4dCh0aGlzLnN0cmluZ19udW1iZXIpLndpZHRoIC8gMjtcclxuICAgICAgY3R4LmZpbGxUZXh0KFwiXCIgKyB0aGlzLnN0cmluZ19udW1iZXIsIHgsIGRvdF95ICsgNC41KTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmxhc3Rfbm90ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMubGFzdF9ub3RlLmdldFN0ZW1YKCkgLSB0aGlzLm5vdGUuZ2V0WCgpICsgNTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGU9XCIjMDAwMDAwXCI7XHJcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDAuNjtcclxuICAgICAgICBpZiAodGhpcy5kYXNoZWQpXHJcbiAgICAgICAgICBWZXguRmxvdy5SZW5kZXJlci5kcmF3RGFzaGVkTGluZShjdHgsIGRvdF94ICsgMTAsIGRvdF95LCBkb3RfeCArIGVuZCwgZG90X3ksIFszLDNdKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBWZXguRmxvdy5SZW5kZXJlci5kcmF3RGFzaGVkTGluZShjdHgsIGRvdF94ICsgMTAsIGRvdF95LCBkb3RfeCArIGVuZCwgZG90X3ksIFszLDBdKTtcclxuXHJcbiAgICAgICAgdmFyIGxlbiwgcGF0dGVybjtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMubGVnKSB7XHJcbiAgICAgICAgICBjYXNlIFZleC5GbG93LlJlbmRlcmVyLkxpbmVFbmRUeXBlLlVQOlxyXG4gICAgICAgICAgICBsZW4gPSAtMTA7XHJcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLmRhc2hlZCA/IFszLDNdIDogWzMsMF07XHJcbiAgICAgICAgICAgIFZleC5GbG93LlJlbmRlcmVyLmRyYXdEYXNoZWRMaW5lKGN0eCwgZG90X3ggKyBlbmQsIGRvdF95LCBkb3RfeCArIGVuZCwgZG90X3kgKyBsZW4sIHBhdHRlcm4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgVmV4LkZsb3cuUmVuZGVyZXIuTGluZUVuZFR5cGUuRE9XTjpcclxuICAgICAgICAgICAgbGVuID0gMTA7XHJcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLmRhc2hlZCA/IFszLDNdIDogWzMsMF07XHJcbiAgICAgICAgICAgIFZleC5GbG93LlJlbmRlcmVyLmRyYXdEYXNoZWRMaW5lKGN0eCwgZG90X3ggKyBlbmQsIGRvdF95LCBkb3RfeCArIGVuZCwgZG90X3kgKyBsZW4sIHBhdHRlcm4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBTdHJpbmdOdW1iZXI7XHJcbn0oKSk7XHJcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXHJcbi8vIEF1dGhvcjogTGFycnkgS3VobnNcclxuLy9cclxuLy8gIyMgRGVzY3JpcHRpb25cclxuLy9cclxuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgdGhlIGBTdHJva2VgIGNsYXNzIHdoaWNoIHJlbmRlcnMgY2hvcmQgc3Ryb2tlc1xyXG4vLyB0aGF0IGNhbiBiZSBhcnBlZ2dpYXRlZCwgYnJ1c2hlZCwgcmFzcXVlZG8sIGV0Yy5cclxuXHJcblZleC5GbG93LlN0cm9rZSA9IChmdW5jdGlvbigpIHtcclxuICBmdW5jdGlvbiBTdHJva2UodHlwZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodHlwZSwgb3B0aW9ucyk7XHJcbiAgfVxyXG4gIFN0cm9rZS5DQVRFR09SWSA9IFwic3Ryb2tlc1wiO1xyXG5cclxuICBTdHJva2UuVHlwZSA9IHtcclxuICAgIEJSVVNIX0RPV046IDEsXHJcbiAgICBCUlVTSF9VUDogMixcclxuICAgIFJPTExfRE9XTjogMywgICAgICAgIC8vIEFycGVnaWF0ZWQgY2hvcmRcclxuICAgIFJPTExfVVA6IDQsICAgICAgICAgIC8vIEFycGVnaWF0ZWQgY2hvcmRcclxuICAgIFJBU1FVRURPX0RPV046IDUsXHJcbiAgICBSQVNRVUVET19VUDogNlxyXG4gIH07XHJcblxyXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xyXG5cclxuICAvLyAjIyBTdGF0aWMgTWV0aG9kc1xyXG5cclxuICAvLyBBcnJhbmdlIHN0cm9rZXMgaW5zaWRlIGBNb2RpZmllckNvbnRleHRgXHJcbiAgU3Ryb2tlLmZvcm1hdCA9IGZ1bmN0aW9uKHN0cm9rZXMsIHN0YXRlKSB7XHJcbiAgICB2YXIgbGVmdF9zaGlmdCA9IHN0YXRlLmxlZnRfc2hpZnQ7XHJcbiAgICB2YXIgc3Ryb2tlX3NwYWNpbmcgPSAwO1xyXG5cclxuICAgIGlmICghc3Ryb2tlcyB8fCBzdHJva2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgdmFyIHN0cl9saXN0ID0gW107XHJcbiAgICB2YXIgaSwgc3RyLCBzaGlmdDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJva2VzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHN0ciA9IHN0cm9rZXNbaV07XHJcbiAgICAgIHZhciBub3RlID0gc3RyLmdldE5vdGUoKTtcclxuICAgICAgdmFyIHByb3BzO1xyXG4gICAgICBpZiAobm90ZSBpbnN0YW5jZW9mIFZleC5GbG93LlN0YXZlTm90ZSkge1xyXG4gICAgICAgIHByb3BzID0gbm90ZS5nZXRLZXlQcm9wcygpW3N0ci5nZXRJbmRleCgpXTtcclxuICAgICAgICBzaGlmdCA9IChwcm9wcy5kaXNwbGFjZWQgPyBub3RlLmdldEV4dHJhTGVmdFB4KCkgOiAwKTtcclxuICAgICAgICBzdHJfbGlzdC5wdXNoKHsgbGluZTogcHJvcHMubGluZSwgc2hpZnQ6IHNoaWZ0LCBzdHI6IHN0ciB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwcm9wcyA9IG5vdGUuZ2V0UG9zaXRpb25zKClbc3RyLmdldEluZGV4KCldO1xyXG4gICAgICAgIHN0cl9saXN0LnB1c2goeyBsaW5lOiBwcm9wcy5zdHIsIHNoaWZ0OiAwLCBzdHI6IHN0ciB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdHJfc2hpZnQgPSBsZWZ0X3NoaWZ0O1xyXG4gICAgdmFyIHhfc2hpZnQgPSAwO1xyXG5cclxuICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzdHJva2UgLi4gaWYgbW9yZSB0aGFuIG9uZSwgdGhleSBvdmVybGF5IGVhY2ggb3RoZXJcclxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJfbGlzdC5sZW5ndGg7ICsraSkge1xyXG4gICAgICBzdHIgPSBzdHJfbGlzdFtpXS5zdHI7XHJcbiAgICAgIHNoaWZ0ID0gc3RyX2xpc3RbaV0uc2hpZnQ7XHJcblxyXG4gICAgICBzdHIuc2V0WFNoaWZ0KHN0cl9zaGlmdCArIHNoaWZ0KTtcclxuICAgICAgeF9zaGlmdCA9IE1hdGgubWF4KHN0ci5nZXRXaWR0aCgpICsgc3Ryb2tlX3NwYWNpbmcsIHhfc2hpZnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLmxlZnRfc2hpZnQgKz0geF9zaGlmdDtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcblxyXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXHJcbiAgVmV4LkluaGVyaXQoU3Ryb2tlLCBNb2RpZmllciwge1xyXG4gICAgaW5pdDogZnVuY3Rpb24odHlwZSwgb3B0aW9ucykge1xyXG4gICAgICBTdHJva2Uuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICB0aGlzLm5vdGUgPSBudWxsO1xyXG4gICAgICB0aGlzLm9wdGlvbnMgPSBWZXguTWVyZ2Uoe30sIG9wdGlvbnMpO1xyXG5cclxuICAgICAgLy8gbXVsdGkgdm9pY2UgLSBzcGFuIHN0cm9rZSBhY3Jvc3MgYWxsIHZvaWNlcyBpZiB0cnVlXHJcbiAgICAgIHRoaXMuYWxsX3ZvaWNlcyA9ICdhbGxfdm9pY2VzJyBpbiB0aGlzLm9wdGlvbnMgP1xyXG4gICAgICAgIHRoaXMub3B0aW9ucy5hbGxfdm9pY2VzIDogdHJ1ZTtcclxuXHJcbiAgICAgIC8vIG11bHRpIHZvaWNlIC0gZW5kIG5vdGUgb2Ygc3Ryb2tlLCBzZXQgaW4gZHJhdygpXHJcbiAgICAgIHRoaXMubm90ZV9lbmQgPSBudWxsO1xyXG4gICAgICB0aGlzLmluZGV4ID0gbnVsbDtcclxuICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgdGhpcy5wb3NpdGlvbiA9IE1vZGlmaWVyLlBvc2l0aW9uLkxFRlQ7XHJcblxyXG4gICAgICB0aGlzLnJlbmRlcl9vcHRpb25zID0ge1xyXG4gICAgICAgIGZvbnRfc2NhbGU6IDM4LFxyXG4gICAgICAgIHN0cm9rZV9weDogMyxcclxuICAgICAgICBzdHJva2Vfc3BhY2luZzogMTBcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuZm9udCA9IHtcclxuICAgICAgIGZhbWlseTogXCJzZXJpZlwiLFxyXG4gICAgICAgc2l6ZTogMTAsXHJcbiAgICAgICB3ZWlnaHQ6IFwiYm9sZCBpdGFsaWNcIlxyXG4gICAgIH07XHJcblxyXG4gICAgICB0aGlzLnNldFhTaGlmdCgwKTtcclxuICAgICAgdGhpcy5zZXRXaWR0aCgxMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucG9zaXRpb247IH0sXHJcbiAgICBhZGRFbmROb3RlOiBmdW5jdGlvbihub3RlKSB7IHRoaXMubm90ZV9lbmQgPSBub3RlOyByZXR1cm4gdGhpczsgfSxcclxuXHJcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxyXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBzdHJva2Ugd2l0aG91dCBhIGNvbnRleHQuXCIpO1xyXG4gICAgICBpZiAoISh0aGlzLm5vdGUgJiYgKHRoaXMuaW5kZXggIT0gbnVsbCkpKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0F0dGFjaGVkTm90ZVwiLFxyXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBzdHJva2Ugd2l0aG91dCBhIG5vdGUgYW5kIGluZGV4LlwiKTtcclxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5ub3RlLmdldE1vZGlmaWVyU3RhcnRYWSh0aGlzLnBvc2l0aW9uLCB0aGlzLmluZGV4KTtcclxuICAgICAgdmFyIHlzID0gdGhpcy5ub3RlLmdldFlzKCk7XHJcbiAgICAgIHZhciB0b3BZID0gc3RhcnQueTtcclxuICAgICAgdmFyIGJvdFkgPSBzdGFydC55O1xyXG4gICAgICB2YXIgeCA9IHN0YXJ0LnggLSA1O1xyXG4gICAgICB2YXIgbGluZV9zcGFjZSA9IHRoaXMubm90ZS5zdGF2ZS5vcHRpb25zLnNwYWNpbmdfYmV0d2Vlbl9saW5lc19weDtcclxuXHJcbiAgICAgIHZhciBub3RlcyA9IHRoaXMuZ2V0TW9kaWZpZXJDb250ZXh0KCkuZ2V0TW9kaWZpZXJzKHRoaXMubm90ZS5nZXRDYXRlZ29yeSgpKTtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBub3Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHlzID0gbm90ZXNbaV0uZ2V0WXMoKTtcclxuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHlzLmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5ub3RlID09IG5vdGVzW2ldIHx8IHRoaXMuYWxsX3ZvaWNlcykge1xyXG4gICAgICAgICAgICB0b3BZID0gVmV4Lk1pbih0b3BZLCB5c1tuXSk7XHJcbiAgICAgICAgICAgIGJvdFkgPSBWZXguTWF4KGJvdFksIHlzW25dKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBhcnJvdywgYXJyb3dfc2hpZnRfeCwgYXJyb3dfeSwgdGV4dF9zaGlmdF94LCB0ZXh0X3k7XHJcbiAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBTdHJva2UuVHlwZS5CUlVTSF9ET1dOOlxyXG4gICAgICAgICAgYXJyb3cgPSBcInZjM1wiO1xyXG4gICAgICAgICAgYXJyb3dfc2hpZnRfeCA9IC0zO1xyXG4gICAgICAgICAgYXJyb3dfeSA9IHRvcFkgLSAobGluZV9zcGFjZSAvIDIpICsgMTA7XHJcbiAgICAgICAgICBib3RZICs9IChsaW5lX3NwYWNlIC8gMik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFN0cm9rZS5UeXBlLkJSVVNIX1VQOlxyXG4gICAgICAgICAgYXJyb3cgPSBcInYxMVwiO1xyXG4gICAgICAgICAgYXJyb3dfc2hpZnRfeCA9IDAuNTtcclxuICAgICAgICAgIGFycm93X3kgPSBib3RZICsgKGxpbmVfc3BhY2UgLyAyKTtcclxuICAgICAgICAgIHRvcFkgLT0gKGxpbmVfc3BhY2UgLyAyKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgU3Ryb2tlLlR5cGUuUk9MTF9ET1dOOlxyXG4gICAgICAgIGNhc2UgU3Ryb2tlLlR5cGUuUkFTUVVFRE9fRE9XTjpcclxuICAgICAgICAgIGFycm93ID0gXCJ2YzNcIjtcclxuICAgICAgICAgIGFycm93X3NoaWZ0X3ggPSAtMztcclxuICAgICAgICAgIHRleHRfc2hpZnRfeCA9IHRoaXMueF9zaGlmdCArIGFycm93X3NoaWZ0X3ggLSAyO1xyXG4gICAgICAgICAgaWYgKHRoaXMubm90ZSBpbnN0YW5jZW9mIFZleC5GbG93LlN0YXZlTm90ZSkge1xyXG4gICAgICAgICAgICB0b3BZICs9IDEuNSAqIGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICAgIGlmICgoYm90WSAtIHRvcFkpICUgMiAhPT0gMCkge1xyXG4gICAgICAgICAgICAgIGJvdFkgKz0gMC41ICogbGluZV9zcGFjZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBib3RZICs9IGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJyb3dfeSA9IHRvcFkgLSBsaW5lX3NwYWNlO1xyXG4gICAgICAgICAgICB0ZXh0X3kgPSBib3RZICsgbGluZV9zcGFjZSArIDI7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0b3BZICs9IDEuNSAqIGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICAgIGJvdFkgKz0gbGluZV9zcGFjZTtcclxuICAgICAgICAgICAgYXJyb3dfeSA9IHRvcFkgLSAwLjc1ICogbGluZV9zcGFjZTtcclxuICAgICAgICAgICAgdGV4dF95ID0gYm90WSArIDAuMjUgKiBsaW5lX3NwYWNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBTdHJva2UuVHlwZS5ST0xMX1VQOlxyXG4gICAgICAgIGNhc2UgU3Ryb2tlLlR5cGUuUkFTUVVFRE9fVVA6XHJcbiAgICAgICAgICBhcnJvdyA9IFwidjUyXCI7XHJcbiAgICAgICAgICBhcnJvd19zaGlmdF94ID0gLTQ7XHJcbiAgICAgICAgICB0ZXh0X3NoaWZ0X3ggPSB0aGlzLnhfc2hpZnQgKyBhcnJvd19zaGlmdF94IC0gMTtcclxuICAgICAgICAgIGlmICh0aGlzLm5vdGUgaW5zdGFuY2VvZiBWZXguRmxvdy5TdGF2ZU5vdGUpIHtcclxuICAgICAgICAgICAgYXJyb3dfeSA9IGxpbmVfc3BhY2UgLyAyO1xyXG4gICAgICAgICAgICB0b3BZICs9IDAuNSAqIGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICAgIGlmICgoYm90WSAtIHRvcFkpICUgMiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIGJvdFkgKz0gbGluZV9zcGFjZSAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJyb3dfeSA9IGJvdFkgKyAwLjUgKiBsaW5lX3NwYWNlO1xyXG4gICAgICAgICAgICB0ZXh0X3kgPSB0b3BZIC0gMS4yNSAqIGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0b3BZICs9IDAuMjUgKiBsaW5lX3NwYWNlO1xyXG4gICAgICAgICAgICBib3RZICs9IDAuNSAqIGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICAgIGFycm93X3kgPSBib3RZICsgMC4yNSAqIGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICAgIHRleHRfeSA9IHRvcFkgLSBsaW5lX3NwYWNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERyYXcgdGhlIHN0cm9rZVxyXG4gICAgICBpZiAodGhpcy50eXBlID09IFN0cm9rZS5UeXBlLkJSVVNIX0RPV04gfHxcclxuICAgICAgICAgIHRoaXMudHlwZSA9PSBTdHJva2UuVHlwZS5CUlVTSF9VUCkge1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCh4ICsgdGhpcy54X3NoaWZ0LCB0b3BZLCAxLCBib3RZIC0gdG9wWSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHRoaXMubm90ZSBpbnN0YW5jZW9mIFZleC5GbG93LlN0YXZlTm90ZSkge1xyXG4gICAgICAgICAgZm9yIChpID0gdG9wWTsgaSA8PSBib3RZOyBpICs9IGxpbmVfc3BhY2UpIHtcclxuICAgICAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgodGhpcy5jb250ZXh0LCB4ICsgdGhpcy54X3NoaWZ0IC0gNCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5mb250X3NjYWxlLCBcInZhM1wiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9yIChpID0gdG9wWTsgaSA8PSBib3RZOyBpKz0gMTApIHtcclxuICAgICAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgodGhpcy5jb250ZXh0LCB4ICsgdGhpcy54X3NoaWZ0IC0gNCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5mb250X3NjYWxlLCBcInZhM1wiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT0gVmV4LkZsb3cuU3Ryb2tlLlR5cGUuUkFTUVVFRE9fRE9XTilcclxuICAgICAgICAgICAgdGV4dF95ID0gaSArIDAuMjUgKiBsaW5lX3NwYWNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRHJhdyB0aGUgYXJyb3cgaGVhZFxyXG4gICAgICBWZXguRmxvdy5yZW5kZXJHbHlwaCh0aGlzLmNvbnRleHQsIHggKyB0aGlzLnhfc2hpZnQgKyBhcnJvd19zaGlmdF94LCBhcnJvd195LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLmZvbnRfc2NhbGUsIGFycm93KTtcclxuXHJcbiAgICAgIC8vIERyYXcgdGhlIHJhc3F1ZWRvIFwiUlwiXHJcbiAgICAgIGlmICh0aGlzLnR5cGUgPT0gU3Ryb2tlLlR5cGUuUkFTUVVFRE9fRE9XTiB8fFxyXG4gICAgICAgICAgdGhpcy50eXBlID09IFN0cm9rZS5UeXBlLlJBU1FVRURPX1VQKSB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcclxuICAgICAgICB0aGlzLmNvbnRleHQuc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSwgdGhpcy5mb250LndlaWdodCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxUZXh0KFwiUlwiLCB4ICsgdGV4dF9zaGlmdF94LCB0ZXh0X3kpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIFN0cm9rZTtcclxufSgpKTtcbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBjdXJ2ZXMgKGZvciBzbHVycylcblxuVmV4LkZsb3cuQ3VydmUgPSAoZnVuY3Rpb24oKSB7XG4gIC8vIGZyb206IFN0YXJ0IG5vdGVcbiAgLy8gdG86IEVuZCBub3RlXG4gIC8vIG9wdGlvbnM6XG4gIC8vICAgIGNwczogTGlzdCBvZiBjb250cm9sIHBvaW50c1xuICAvLyAgICB4X3NoaWZ0OiBwaXhlbHMgdG8gc2hpZnRcbiAgLy8gICAgeV9zaGlmdDogcGl4ZWxzIHRvIHNoaWZ0XG4gIGZ1bmN0aW9uIEN1cnZlKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICB9XG5cbiAgQ3VydmUuUG9zaXRpb24gPSB7XG4gICAgTkVBUl9IRUFEOiAxLFxuICAgIE5FQVJfVE9QOiAyXG4gIH07XG5cbiAgQ3VydmUuREVCVUcgPSB0cnVlO1xuXG4gIEN1cnZlLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgc3BhY2luZzogMixcbiAgICAgICAgdGhpY2tuZXNzOiAyLFxuICAgICAgICB4X3NoaWZ0OiAwLFxuICAgICAgICB5X3NoaWZ0OiAxMCxcbiAgICAgICAgcG9zaXRpb246IEN1cnZlLlBvc2l0aW9uLk5FQVJfSEVBRCxcbiAgICAgICAgaW52ZXJ0OiBmYWxzZSxcbiAgICAgICAgY3BzOiBbe3g6IDAsIHk6IDEwfSwge3g6IDAsIHk6IDEwfV1cbiAgICAgIH07XG5cbiAgICAgIFZleC5NZXJnZSh0aGlzLnJlbmRlcl9vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0Tm90ZXMoZnJvbSwgdG8pO1xuICAgIH0sXG5cbiAgICBzZXRDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7IHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IHJldHVybiB0aGlzOyB9LFxuICAgIHNldE5vdGVzOiBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgaWYgKCFmcm9tICYmICF0bylcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgIFwiQ3VydmUgbmVlZHMgdG8gaGF2ZSBlaXRoZXIgZmlyc3Rfbm90ZSBvciBsYXN0X25vdGUgc2V0LlwiKTtcblxuICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIHBhcnRpYWwgYmFyLlxuICAgICAqL1xuICAgIGlzUGFydGlhbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKCF0aGlzLmZyb20gfHwgIXRoaXMudG8pO1xuICAgIH0sXG5cbiAgICByZW5kZXJDdXJ2ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIGNwcyA9IHRoaXMucmVuZGVyX29wdGlvbnMuY3BzO1xuXG4gICAgICB2YXIgeF9zaGlmdCA9IHRoaXMucmVuZGVyX29wdGlvbnMueF9zaGlmdDtcbiAgICAgIHZhciB5X3NoaWZ0ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy55X3NoaWZ0ICogcGFyYW1zLmRpcmVjdGlvbjtcblxuICAgICAgdmFyIGZpcnN0X3ggPSBwYXJhbXMuZmlyc3RfeCArIHhfc2hpZnQ7XG4gICAgICB2YXIgZmlyc3RfeSA9IHBhcmFtcy5maXJzdF95ICsgeV9zaGlmdDtcbiAgICAgIHZhciBsYXN0X3ggPSBwYXJhbXMubGFzdF94IC0geF9zaGlmdDtcbiAgICAgIHZhciBsYXN0X3kgPSBwYXJhbXMubGFzdF95ICsgeV9zaGlmdDtcbiAgICAgIHZhciB0aGlja25lc3MgPSB0aGlzLnJlbmRlcl9vcHRpb25zLnRoaWNrbmVzcztcblxuICAgICAgdmFyIGNwX3NwYWNpbmcgPSAobGFzdF94IC0gZmlyc3RfeCkgLyAoY3BzLmxlbmd0aCArIDIpO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGZpcnN0X3gsIGZpcnN0X3kpO1xuICAgICAgY3R4LmJlemllckN1cnZlVG8oZmlyc3RfeCArIGNwX3NwYWNpbmcgKyBjcHNbMF0ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X3kgKyAoY3BzWzBdLnkgKiBwYXJhbXMuZGlyZWN0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfeCAtIGNwX3NwYWNpbmcgKyBjcHNbMV0ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfeSArIChjcHNbMV0ueSAqIHBhcmFtcy5kaXJlY3Rpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF94LCBsYXN0X3kpO1xuICAgICAgY3R4LmJlemllckN1cnZlVG8obGFzdF94IC0gY3Bfc3BhY2luZyArIGNwc1sxXS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF95ICsgKChjcHNbMV0ueSArIHRoaWNrbmVzcykgKiBwYXJhbXMuZGlyZWN0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X3ggKyBjcF9zcGFjaW5nICsgY3BzWzBdLngsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF95ICsgKChjcHNbMF0ueSArIHRoaWNrbmVzcykgKiBwYXJhbXMuZGlyZWN0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X3gsIGZpcnN0X3kpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dClcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9Db250ZXh0XCIsIFwiTm8gY29udGV4dCB0byByZW5kZXIgdGllLlwiKTtcbiAgICAgIHZhciBmaXJzdF9ub3RlID0gdGhpcy5mcm9tO1xuICAgICAgdmFyIGxhc3Rfbm90ZSA9IHRoaXMudG87XG4gICAgICB2YXIgZmlyc3RfeCwgbGFzdF94LCBmaXJzdF95LCBsYXN0X3ksIHN0ZW1fZGlyZWN0aW9uO1xuXG4gICAgICB2YXIgbWV0cmljID0gXCJiYXNlWVwiO1xuICAgICAgdmFyIGVuZF9tZXRyaWMgPSBcImJhc2VZXCI7XG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnJlbmRlcl9vcHRpb25zLnBvc2l0aW9uO1xuICAgICAgdmFyIHBvc2l0aW9uX2VuZCA9IHRoaXMucmVuZGVyX29wdGlvbnMucG9zaXRpb25fZW5kO1xuXG4gICAgICBpZiAocG9zaXRpb24gPT09IEN1cnZlLlBvc2l0aW9uLk5FQVJfVE9QKSB7XG4gICAgICAgIG1ldHJpYyA9IFwidG9wWVwiO1xuICAgICAgICBlbmRfbWV0cmljID0gXCJ0b3BZXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbl9lbmQgPT0gQ3VydmUuUG9zaXRpb24uTkVBUl9IRUFEKSB7XG4gICAgICAgIGVuZF9tZXRyaWMgPSBcImJhc2VZXCI7XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uX2VuZCA9PSBDdXJ2ZS5Qb3NpdGlvbi5ORUFSX1RPUCkge1xuICAgICAgICBlbmRfbWV0cmljID0gXCJ0b3BZXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdF9ub3RlKSB7XG4gICAgICAgIGZpcnN0X3ggPSBmaXJzdF9ub3RlLmdldFRpZVJpZ2h0WCgpO1xuICAgICAgICBzdGVtX2RpcmVjdGlvbiA9IGZpcnN0X25vdGUuZ2V0U3RlbURpcmVjdGlvbigpO1xuICAgICAgICBmaXJzdF95ID0gZmlyc3Rfbm90ZS5nZXRTdGVtRXh0ZW50cygpW21ldHJpY107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdF94ID0gbGFzdF9ub3RlLmdldFN0YXZlKCkuZ2V0VGllU3RhcnRYKCk7XG4gICAgICAgIGZpcnN0X3kgPSBsYXN0X25vdGUuZ2V0U3RlbUV4dGVudHMoKVttZXRyaWNdO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdF9ub3RlKSB7XG4gICAgICAgIGxhc3RfeCA9IGxhc3Rfbm90ZS5nZXRUaWVMZWZ0WCgpO1xuICAgICAgICBzdGVtX2RpcmVjdGlvbiA9IGxhc3Rfbm90ZS5nZXRTdGVtRGlyZWN0aW9uKCk7XG4gICAgICAgIGxhc3RfeSA9IGxhc3Rfbm90ZS5nZXRTdGVtRXh0ZW50cygpW2VuZF9tZXRyaWNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdF94ID0gZmlyc3Rfbm90ZS5nZXRTdGF2ZSgpLmdldFRpZUVuZFgoKTtcbiAgICAgICAgbGFzdF95ID0gZmlyc3Rfbm90ZS5nZXRTdGVtRXh0ZW50cygpW2VuZF9tZXRyaWNdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlckN1cnZlKHtcbiAgICAgICAgZmlyc3RfeDogZmlyc3RfeCxcbiAgICAgICAgbGFzdF94OiBsYXN0X3gsXG4gICAgICAgIGZpcnN0X3k6IGZpcnN0X3ksXG4gICAgICAgIGxhc3RfeTogbGFzdF95LFxuICAgICAgICBkaXJlY3Rpb246IHN0ZW1fZGlyZWN0aW9uICpcbiAgICAgICAgICAodGhpcy5yZW5kZXJfb3B0aW9ucy5pbnZlcnQgPT09IHRydWUgPyAtMSA6IDEpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ3VydmU7XG59KCkpO1xuXG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIGBTdGF2ZUxpbmVgIHdoaWNoIGFyZSBzaW1wbHkgbGluZXMgdGhhdCBjb25uZWN0XG4vLyB0d28gbm90ZXMuIFRoaXMgb2JqZWN0IGlzIGhpZ2hseSBjb25maWd1cmFibGUsIHNlZSB0aGUgYHJlbmRlcl9vcHRpb25zYC5cbi8vIEEgc2ltcGxlIGxpbmUgaXMgb2Z0ZW4gdXNlZCBmb3Igbm90YXRpbmcgZ2xpc3NhbmRvIGFydGljdWxhdGlvbnMsIGJ1dCB5b3Vcbi8vIGNhbiBmb3JtYXQgYSBgU3RhdmVMaW5lYCB3aXRoIGFycm93cyBvciBjb2xvcnMgZm9yIG1vcmUgcGVkYWdvZ2ljYWxcbi8vIHB1cnBvc2VzLCBzdWNoIGFzIGRpYWdyYW1zLlxuVmV4LkZsb3cuU3RhdmVMaW5lID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBTdGF2ZUxpbmUobm90ZXMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChub3Rlcyk7XG4gIH1cblxuICAvLyBUZXh0IFBvc2l0aW9uaW5nXG4gIFN0YXZlTGluZS5UZXh0VmVydGljYWxQb3NpdGlvbiA9IHtcbiAgICBUT1A6IDEsXG4gICAgQk9UVE9NOiAyXG4gIH07XG5cbiAgU3RhdmVMaW5lLlRleHRKdXN0aWZpY2F0aW9uID0ge1xuICAgIExFRlQ6IDEsXG4gICAgQ0VOVEVSOiAyLFxuICAgIFJJR0hUOiAzXG4gIH07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgU3RhdmVMaW5lLnByb3RvdHlwZSA9IHtcbiAgICAvLyBJbml0aWFsaXplIHRoZSBTdGF2ZUxpbmUgd2l0aCB0aGUgZ2l2ZW4gYG5vdGVzYC5cbiAgICAvL1xuICAgIC8vIGBub3Rlc2AgaXMgYSBzdHJ1Y3QgdGhhdCBoYXM6XG4gICAgLy9cbiAgICAvLyAgYGBgXG4gICAgLy8gIHtcbiAgICAvLyAgICBmaXJzdF9ub3RlOiBOb3RlLFxuICAgIC8vICAgIGxhc3Rfbm90ZTogTm90ZSxcbiAgICAvLyAgICBmaXJzdF9pbmRpY2VzOiBbbjEsIG4yLCBuM10sXG4gICAgLy8gICAgbGFzdF9pbmRpY2VzOiBbbjEsIG4yLCBuM11cbiAgICAvLyAgfVxuICAgIC8vICBgYGBcbiAgICBpbml0OiBmdW5jdGlvbihub3Rlcykge1xuICAgICAgdGhpcy5ub3RlcyA9IG5vdGVzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcblxuICAgICAgdGhpcy5mb250ID0ge1xuICAgICAgICBmYW1pbHk6IFwiQXJpYWxcIixcbiAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgIHdlaWdodDogXCJcIlxuICAgICAgfTtcblxuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgLy8gU3BhY2UgdG8gYWRkIHRvIHRoZSBsZWZ0IG9yIHRoZSByaWdodFxuICAgICAgICBwYWRkaW5nX2xlZnQ6IDQsXG4gICAgICAgIHBhZGRpbmdfcmlnaHQ6IDMsXG5cbiAgICAgICAgLy8gVGhlIHdpZHRoIG9mIHRoZSBsaW5lIGluIHBpeGVsc1xuICAgICAgICBsaW5lX3dpZHRoOiAxLFxuICAgICAgICAvLyBBbiBhcnJheSBvZiBsaW5lL3NwYWNlIGxlbmd0aHMuIFVuc3VwcG9ydGVkIHdpdGggUmFwaGFlbCAoU1ZHKVxuICAgICAgICBsaW5lX2Rhc2g6IG51bGwsXG4gICAgICAgIC8vIENhbiBkcmF3IHJvdW5kZWQgbGluZSBlbmQsIGluc3RlYWQgb2YgYSBzcXVhcmUuIFVuc3VwcG9ydGVkIHdpdGggUmFwaGFlbCAoU1ZHKVxuICAgICAgICByb3VuZGVkX2VuZDogdHJ1ZSxcbiAgICAgICAgLy8gVGhlIGNvbG9yIG9mIHRoZSBsaW5lIGFuZCBhcnJvd2hlYWRzXG4gICAgICAgIGNvbG9yOiBudWxsLFxuXG4gICAgICAgIC8vIEZsYWdzIHRvIGRyYXcgYXJyb3dzIG9uIGVhY2ggZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgIGRyYXdfc3RhcnRfYXJyb3c6IGZhbHNlLFxuICAgICAgICBkcmF3X2VuZF9hcnJvdzogZmFsc2UsXG5cbiAgICAgICAgLy8gVGhlIGxlbmd0aCBvZiB0aGUgYXJyb3doZWFkIHNpZGVzXG4gICAgICAgIGFycm93aGVhZF9sZW5ndGg6IDEwLFxuICAgICAgICAvLyBUaGUgYW5nbGUgb2YgdGhlIGFycm93aGVhZFxuICAgICAgICBhcnJvd2hlYWRfYW5nbGU6IE1hdGguUEkgLyA4LFxuXG4gICAgICAgIC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGV4dFxuICAgICAgICB0ZXh0X3Bvc2l0aW9uX3ZlcnRpY2FsOiBTdGF2ZUxpbmUuVGV4dFZlcnRpY2FsUG9zaXRpb24uVE9QLFxuICAgICAgICB0ZXh0X2p1c3RpZmljYXRpb246IFN0YXZlTGluZS5UZXh0SnVzdGlmaWNhdGlvbi5DRU5URVJcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuc2V0Tm90ZXMobm90ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIHJlbmRlcmluZyBjb250ZXh0XG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkgeyB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyByZXR1cm4gdGhpczsgfSxcbiAgICAvLyBTZXQgdGhlIGZvbnQgZm9yIHRoZSBgU3RhdmVMaW5lYCB0ZXh0XG4gICAgc2V0Rm9udDogZnVuY3Rpb24oZm9udCkgeyB0aGlzLmZvbnQgPSBmb250OyByZXR1cm4gdGhpczsgfSxcbiAgICAvLyBUaGUgdGhlIGFubm90YXRpb24gZm9yIHRoZSBgU3RhdmVMaW5lYFxuICAgIHNldFRleHQ6IGZ1bmN0aW9uKHRleHQpIHsgdGhpcy50ZXh0ID0gdGV4dDsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBTZXQgdGhlIG5vdGVzIGZvciB0aGUgYFN0YXZlTGluZWBcbiAgICBzZXROb3RlczogZnVuY3Rpb24obm90ZXMpIHtcbiAgICAgIGlmICghbm90ZXMuZmlyc3Rfbm90ZSAmJiAhbm90ZXMubGFzdF9ub3RlKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLFxuICAgICAgICAgICAgXCJOb3RlcyBuZWVkcyB0byBoYXZlIGVpdGhlciBmaXJzdF9ub3RlIG9yIGxhc3Rfbm90ZSBzZXQuXCIpO1xuXG4gICAgICBpZiAoIW5vdGVzLmZpcnN0X2luZGljZXMpIG5vdGVzLmZpcnN0X2luZGljZXMgPSBbMF07XG4gICAgICBpZiAoIW5vdGVzLmxhc3RfaW5kaWNlcykgbm90ZXMubGFzdF9pbmRpY2VzID0gWzBdO1xuXG4gICAgICBpZiAobm90ZXMuZmlyc3RfaW5kaWNlcy5sZW5ndGggIT0gbm90ZXMubGFzdF9pbmRpY2VzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIiwgXCJDb25uZWN0ZWQgbm90ZXMgbXVzdCBoYXZlIHNpbWlsYXJcIiArXG4gICAgICAgICAgXCIgaW5kZXggc2l6ZXNcIik7XG5cbiAgICAgIC8vIFN1Y2Nlc3MuIExldHMgZ3JhYiAnZW0gbm90ZXMuXG4gICAgICB0aGlzLmZpcnN0X25vdGUgPSBub3Rlcy5maXJzdF9ub3RlO1xuICAgICAgdGhpcy5maXJzdF9pbmRpY2VzID0gbm90ZXMuZmlyc3RfaW5kaWNlcztcbiAgICAgIHRoaXMubGFzdF9ub3RlID0gbm90ZXMubGFzdF9ub3RlO1xuICAgICAgdGhpcy5sYXN0X2luZGljZXMgPSBub3Rlcy5sYXN0X2luZGljZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQXBwbHkgdGhlIHN0eWxlIG9mIHRoZSBgU3RhdmVMaW5lYCB0byB0aGUgY29udGV4dFxuICAgIGFwcGx5TGluZVN0eWxlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFwiTm8gY29udGV4dCB0byBhcHBseSB0aGUgc3R5bGluZyB0b1wiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbmRlcl9vcHRpb25zID0gdGhpcy5yZW5kZXJfb3B0aW9ucztcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmIChyZW5kZXJfb3B0aW9ucy5saW5lX2Rhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKHJlbmRlcl9vcHRpb25zLmxpbmVfZGFzaCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW5kZXJfb3B0aW9ucy5saW5lX3dpZHRoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lV2lkdGgocmVuZGVyX29wdGlvbnMubGluZV93aWR0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW5kZXJfb3B0aW9ucy5yb3VuZGVkX2VuZCkge1xuICAgICAgICBjdHguc2V0TGluZUNhcChcInJvdW5kXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LnNldExpbmVDYXAoXCJzcXVhcmVcIik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIEFwcGx5IHRoZSB0ZXh0IHN0eWxpbmcgdG8gdGhlIGNvbnRleHRcbiAgICBhcHBseUZvbnRTdHlsZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcIk5vIGNvbnRleHQgdG8gYXBwbHkgdGhlIHN0eWxpbmcgdG9cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmICh0aGlzLmZvbnQpIHtcbiAgICAgICAgY3R4LnNldEZvbnQodGhpcy5mb250LmZhbWlseSwgdGhpcy5mb250LnNpemUsIHRoaXMuZm9udC53ZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5yZW5kZXJfb3B0aW9ucy5jb2xvcikge1xuICAgICAgICBjdHguc2V0U3Ryb2tlU3R5bGUodGhpcy5yZW5kZXJfb3B0aW9ucy5jb2xvcik7XG4gICAgICAgIGN0eC5zZXRGaWxsU3R5bGUodGhpcy5yZW5kZXJfb3B0aW9ucy5jb2xvcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFJlbmRlcnMgdGhlIGBTdGF2ZUxpbmVgIG9uIHRoZSBjb250ZXh0XG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIiwgXCJObyBjb250ZXh0IHRvIHJlbmRlciBTdGF2ZUxpbmUuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIGZpcnN0X25vdGUgPSB0aGlzLmZpcnN0X25vdGU7XG4gICAgICB2YXIgbGFzdF9ub3RlID0gdGhpcy5sYXN0X25vdGU7XG4gICAgICB2YXIgcmVuZGVyX29wdGlvbnMgPSB0aGlzLnJlbmRlcl9vcHRpb25zO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5hcHBseUxpbmVTdHlsZSgpO1xuXG4gICAgICAvLyBDeWNsZSB0aHJvdWdoIGVhY2ggc2V0IG9mIGluZGljZXMgYW5kIGRyYXcgbGluZXNcbiAgICAgIHZhciBzdGFydF9wb3NpdGlvbjtcbiAgICAgIHZhciBlbmRfcG9zaXRpb247XG4gICAgICB0aGlzLmZpcnN0X2luZGljZXMuZm9yRWFjaChmdW5jdGlvbihmaXJzdF9pbmRleCwgaSkge1xuICAgICAgICB2YXIgbGFzdF9pbmRleCA9IHRoaXMubGFzdF9pbmRpY2VzW2ldO1xuXG4gICAgICAgIC8vIEdldCBpbml0aWFsIGNvb3JkaW5hdGVzIGZvciB0aGUgc3RhcnQvZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgIHN0YXJ0X3Bvc2l0aW9uID0gZmlyc3Rfbm90ZS5nZXRNb2RpZmllclN0YXJ0WFkoMiwgZmlyc3RfaW5kZXgpO1xuICAgICAgICBlbmRfcG9zaXRpb24gPSBsYXN0X25vdGUuZ2V0TW9kaWZpZXJTdGFydFhZKDEsIGxhc3RfaW5kZXgpO1xuICAgICAgICB2YXIgdXB3YXJkc19zbG9wZSA9IHN0YXJ0X3Bvc2l0aW9uLnkgPiBlbmRfcG9zaXRpb24ueTtcblxuICAgICAgICAvLyBBZGp1c3QgYHhgIGNvb3JkaW5hdGVzIGZvciBtb2RpZmllcnNcbiAgICAgICAgc3RhcnRfcG9zaXRpb24ueCArPSBmaXJzdF9ub3RlLmdldE1ldHJpY3MoKS5tb2RSaWdodFB4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJfb3B0aW9ucy5wYWRkaW5nX2xlZnQ7XG4gICAgICAgIGVuZF9wb3NpdGlvbi54IC09IGxhc3Rfbm90ZS5nZXRNZXRyaWNzKCkubW9kTGVmdFB4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyX29wdGlvbnMucGFkZGluZ19yaWdodDtcblxuXG4gICAgICAgIC8vIEFkanVzdCBmaXJzdCBgeGAgY29vcmRpbmF0ZXMgZm9yIGRpc3BsYWNlbWVudHNcbiAgICAgICAgdmFyIG5vdGVoZWFkX3dpZHRoID0gZmlyc3Rfbm90ZS5nZXRHbHlwaCgpLmhlYWRfd2lkdGg7XG4gICAgICAgIHZhciBmaXJzdF9kaXNwbGFjZWQgPSBmaXJzdF9ub3RlLmdldEtleVByb3BzKClbZmlyc3RfaW5kZXhdLmRpc3BsYWNlZDtcbiAgICAgICAgaWYgKGZpcnN0X2Rpc3BsYWNlZCAmJiBmaXJzdF9ub3RlLmdldFN0ZW1EaXJlY3Rpb24oKSA9PT0gMSkge1xuICAgICAgICAgIHN0YXJ0X3Bvc2l0aW9uLnggKz0gbm90ZWhlYWRfd2lkdGggKyByZW5kZXJfb3B0aW9ucy5wYWRkaW5nX2xlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGp1c3QgbGFzdCBgeGAgY29vcmRpbmF0ZXMgZm9yIGRpc3BsYWNlbWVudHNcbiAgICAgICAgdmFyIGxhc3RfZGlzcGxhY2VkID0gbGFzdF9ub3RlLmdldEtleVByb3BzKClbbGFzdF9pbmRleF0uZGlzcGxhY2VkO1xuICAgICAgICBpZiAobGFzdF9kaXNwbGFjZWQgJiYgbGFzdF9ub3RlLmdldFN0ZW1EaXJlY3Rpb24oKSA9PT0gLTEpIHtcbiAgICAgICAgICBlbmRfcG9zaXRpb24ueCAtPSBub3RlaGVhZF93aWR0aCArIHJlbmRlcl9vcHRpb25zLnBhZGRpbmdfcmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGp1c3QgeSBwb3NpdGlvbiBiZXR0ZXIgaWYgaXQncyBub3QgY29taW5nIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgbm90ZVxuICAgICAgICBzdGFydF9wb3NpdGlvbi55ICs9IHVwd2FyZHNfc2xvcGUgPyAtMyA6IDE7XG4gICAgICAgIGVuZF9wb3NpdGlvbi55ICs9IHVwd2FyZHNfc2xvcGUgPyAyIDogMDtcblxuICAgICAgICBkcmF3QXJyb3dMaW5lKGN0eCwgc3RhcnRfcG9zaXRpb24sIGVuZF9wb3NpdGlvbiwgdGhpcy5yZW5kZXJfb3B0aW9ucyk7XG5cbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIHggY29vcmRpbmF0ZSB3aGVyZSB0byBzdGFydCB0aGUgdGV4dFxuICAgICAgdmFyIHRleHRfd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aDtcbiAgICAgIHZhciBqdXN0aWZpY2F0aW9uID0gcmVuZGVyX29wdGlvbnMudGV4dF9qdXN0aWZpY2F0aW9uO1xuICAgICAgdmFyIHggPSAwO1xuICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09IFN0YXZlTGluZS5UZXh0SnVzdGlmaWNhdGlvbi5MRUZUKSB7XG4gICAgICAgIHggPSBzdGFydF9wb3NpdGlvbi54O1xuICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSBTdGF2ZUxpbmUuVGV4dEp1c3RpZmljYXRpb24uQ0VOVEVSKSB7XG4gICAgICAgIHZhciBkZWx0YV94ID0gKGVuZF9wb3NpdGlvbi54IC0gc3RhcnRfcG9zaXRpb24ueCk7XG4gICAgICAgIHZhciBjZW50ZXJfeCA9IChkZWx0YV94IC8gMiApICsgc3RhcnRfcG9zaXRpb24ueDtcbiAgICAgICAgeCA9IGNlbnRlcl94IC0gKHRleHRfd2lkdGggLyAyKTtcbiAgICAgIH0gZWxzZSBpZiAoanVzdGlmaWNhdGlvbiA9PT0gU3RhdmVMaW5lLlRleHRKdXN0aWZpY2F0aW9uLlJJR0hUKSB7XG4gICAgICAgIHggPSBlbmRfcG9zaXRpb24ueCAgLSAgdGV4dF93aWR0aDtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB5IHZhbHVlIHRvIHN0YXJ0IHRoZSB0ZXh0XG4gICAgICB2YXIgeTtcbiAgICAgIHZhciB2ZXJ0aWNhbF9wb3NpdGlvbiA9IHJlbmRlcl9vcHRpb25zLnRleHRfcG9zaXRpb25fdmVydGljYWw7XG4gICAgICBpZiAodmVydGljYWxfcG9zaXRpb24gPT09IFN0YXZlTGluZS5UZXh0VmVydGljYWxQb3NpdGlvbi5UT1ApIHtcbiAgICAgICAgeSA9IGZpcnN0X25vdGUuZ2V0U3RhdmUoKS5nZXRZRm9yVG9wVGV4dCgpO1xuICAgICAgfSBlbHNlIGlmICh2ZXJ0aWNhbF9wb3NpdGlvbiA9PT0gU3RhdmVMaW5lLlRleHRWZXJ0aWNhbFBvc2l0aW9uLkJPVFRPTSkge1xuICAgICAgICB5ID0gZmlyc3Rfbm90ZS5nZXRTdGF2ZSgpLmdldFlGb3JCb3R0b21UZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERyYXcgdGhlIHRleHRcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmFwcGx5Rm9udFN0eWxlKCk7XG4gICAgICBjdHguZmlsbFRleHQodGhpcy50ZXh0LCB4LCB5KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvLyAjIyBQcml2YXRlIEhlbHBlcnNcbiAgLy8gXG4gIC8vIEF0dHJpYnV0aW9uOiBBcnJvdyByZW5kZXJpbmcgaW1wbGVtZW50YXRpb25zIGJhc2VkIG9mZiBvZlxuICAvLyBQYXRyaWNrIEhvcmdhbidzIGFydGljbGUsIFwiRHJhd2luZyBsaW5lcyBhbmQgYXJjcyB3aXRoIFxuICAvLyBhcnJvdyBoZWFkcyBvbiAgSFRNTDUgQ2FudmFzXCJcbiAgLy8gXG4gIC8vIERyYXcgYW4gYXJyb3cgaGVhZCB0aGF0IGNvbm5lY3RzIGJldHdlZW4gMyBjb29yZGluYXRlc1xuICBmdW5jdGlvbiBkcmF3QXJyb3dIZWFkKGN0eCwgeDAsIHkwLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIC8vIGFsbCBjYXNlcyBkbyB0aGlzLlxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgwLHkwKTtcbiAgICBjdHgubGluZVRvKHgxLHkxKTtcbiAgICBjdHgubGluZVRvKHgyLHkyKTtcbiAgICBjdHgubGluZVRvKHgwLCB5MCk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgY3R4LmZpbGwoKTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBkcmF3IGEgbGluZSB3aXRoIGFycm93IGhlYWRzXG4gIGZ1bmN0aW9uIGRyYXdBcnJvd0xpbmUoY3R4LCBwb2ludDEsIHBvaW50MiwgY29uZmlnKSB7XG4gICAgdmFyIGJvdGhfYXJyb3dzID0gY29uZmlnLmRyYXdfc3RhcnRfYXJyb3cgJiYgY29uZmlnLmRyYXdfZW5kX2Fycm93O1xuXG4gICAgdmFyIHgxID0gcG9pbnQxLng7XG4gICAgdmFyIHkxID0gcG9pbnQxLnk7XG4gICAgdmFyIHgyID0gcG9pbnQyLng7XG4gICAgdmFyIHkyID0gcG9pbnQyLnk7XG5cbiAgICAvLyBGb3IgZW5kcyB3aXRoIGFycm93IHdlIGFjdHVhbGx5IHdhbnQgdG8gc3RvcCBiZWZvcmUgd2UgZ2V0IHRvIHRoZSBhcnJvd1xuICAgIC8vIHNvIHRoYXQgd2lkZSBsaW5lcyB3b24ndCBwdXQgYSBmbGF0IGVuZCBvbiB0aGUgYXJyb3cuXG4gICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KCh4Mi14MSkqKHgyLXgxKSsoeTIteTEpKih5Mi15MSkpO1xuICAgIHZhciByYXRpbyA9IChkaXN0YW5jZSAtIGNvbmZpZy5hcnJvd2hlYWRfbGVuZ3RoLzMpIC8gZGlzdGFuY2U7XG4gICAgdmFyIGVuZF94LCBlbmRfeSwgc3RhcnRfeCwgc3RhcnRfeTtcbiAgICBpZiAoY29uZmlnLmRyYXdfZW5kX2Fycm93IHx8IGJvdGhfYXJyb3dzKSB7XG4gICAgICBlbmRfeCA9IE1hdGgucm91bmQoeDEgKyAoeDIgLSB4MSkgKiByYXRpbyk7XG4gICAgICBlbmRfeSA9IE1hdGgucm91bmQoeTEgKyAoeTIgLSB5MSkgKiByYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZF94ID0geDI7XG4gICAgICBlbmRfeSA9IHkyO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuZHJhd19zdGFydF9hcnJvdyB8fCBib3RoX2Fycm93cykge1xuICAgICAgc3RhcnRfeCA9IHgxICsgKHgyIC0geDEpICogKDEgLSByYXRpbyk7XG4gICAgICBzdGFydF95ID0geTEgKyAoeTIgLSB5MSkgKiAoMSAtIHJhdGlvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRfeCA9IHgxO1xuICAgICAgc3RhcnRfeSA9IHkxO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY29sb3IpIHtcbiAgICAgIGN0eC5zZXRTdHJva2VTdHlsZShjb25maWcuY29sb3IpO1xuICAgICAgY3R4LnNldEZpbGxTdHlsZShjb25maWcuY29sb3IpO1xuICAgIH1cblxuICAgIC8vIERyYXcgdGhlIHNoYWZ0IG9mIHRoZSBhcnJvd1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHN0YXJ0X3gsIHN0YXJ0X3kpO1xuICAgIGN0eC5saW5lVG8oZW5kX3gsZW5kX3kpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGFuZ2xlIG9mIHRoZSBsaW5lXG4gICAgdmFyIGxpbmVfYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpO1xuICAgIC8vIGggaXMgdGhlIGxpbmUgbGVuZ3RoIG9mIGEgc2lkZSBvZiB0aGUgYXJyb3cgaGVhZFxuICAgIHZhciBoID0gTWF0aC5hYnMoY29uZmlnLmFycm93aGVhZF9sZW5ndGggLyBNYXRoLmNvcyhjb25maWcuYXJyb3doZWFkX2FuZ2xlKSk7XG5cbiAgICB2YXIgYW5nbGUxLCBhbmdsZTI7XG4gICAgdmFyIHRvcF94LCB0b3BfeTtcbiAgICB2YXIgYm90dG9tX3gsIGJvdHRvbV95O1xuXG4gICAgaWYgKGNvbmZpZy5kcmF3X2VuZF9hcnJvdyB8fCBib3RoX2Fycm93cykge1xuICAgICAgYW5nbGUxID0gbGluZV9hbmdsZSArIE1hdGguUEkgKyBjb25maWcuYXJyb3doZWFkX2FuZ2xlO1xuICAgICAgdG9wX3ggPSB4MiArIE1hdGguY29zKGFuZ2xlMSkgKiBoO1xuICAgICAgdG9wX3kgPSB5MiArIE1hdGguc2luKGFuZ2xlMSkgKiBoO1xuXG4gICAgICBhbmdsZTIgPSBsaW5lX2FuZ2xlICsgTWF0aC5QSSAtIGNvbmZpZy5hcnJvd2hlYWRfYW5nbGU7XG4gICAgICBib3R0b21feCA9IHgyICsgTWF0aC5jb3MoYW5nbGUyKSAqIGg7XG4gICAgICBib3R0b21feSA9IHkyICsgTWF0aC5zaW4oYW5nbGUyKSAqIGg7XG5cbiAgICAgIGRyYXdBcnJvd0hlYWQoY3R4LCB0b3BfeCwgdG9wX3ksIHgyLCB5MiwgYm90dG9tX3gsIGJvdHRvbV95KTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmRyYXdfc3RhcnRfYXJyb3cgfHwgYm90aF9hcnJvd3MpIHtcbiAgICAgIGFuZ2xlMSA9IGxpbmVfYW5nbGUgKyBjb25maWcuYXJyb3doZWFkX2FuZ2xlO1xuICAgICAgdG9wX3ggPSB4MSArIE1hdGguY29zKGFuZ2xlMSkgKiBoO1xuICAgICAgdG9wX3kgPSB5MSArIE1hdGguc2luKGFuZ2xlMSkgKiBoO1xuXG4gICAgICBhbmdsZTIgPSBsaW5lX2FuZ2xlIC0gY29uZmlnLmFycm93aGVhZF9hbmdsZTtcbiAgICAgIGJvdHRvbV94ID0geDEgKyBNYXRoLmNvcyhhbmdsZTIpICogaDtcbiAgICAgIGJvdHRvbV95ID0geTEgKyBNYXRoLnNpbihhbmdsZTIpICogaDtcblxuICAgICAgZHJhd0Fycm93SGVhZChjdHgsIHRvcF94LCB0b3BfeSwgeDEsIHkxLCBib3R0b21feCwgYm90dG9tX3kpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBTdGF2ZUxpbmU7XG59KCkpO1xuXG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIHRoZSBgQ3Jlc2NlbmRvYCBvYmplY3Qgd2hpY2ggZHJhd3MgY3Jlc2NlbmRvcyBhbmRcbi8vIGRlY3Jlc2NlbmRvIGR5bmFtaWNzIG1hcmtpbmdzLiBBIGBDcmVzY2VuZG9gIGlzIGluaXRpYWxpemVkIHdpdGggYVxuLy8gZHVyYXRpb24gYW5kIGZvcm1hdHRlZCBhcyBwYXJ0IG9mIGEgYFZvaWNlYCBsaWtlIGFueSBvdGhlciBgTm90ZWBcbi8vIHR5cGUgaW4gVmV4Rmxvdy4gVGhpcyBvYmplY3Qgd291bGQgbW9zdCBsaWtlbHkgYmUgZm9ybWF0dGVkIGluIGEgVm9pY2Vcbi8vIHdpdGggYFRleHROb3Rlc2AgLSB3aGljaCBhcmUgdXNlZCB0byByZXByZXNlbnQgb3RoZXIgZHluYW1pY3MgbWFya2luZ3MuXG5WZXguRmxvdy5DcmVzY2VuZG8gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIENyZXNjZW5kbyhub3RlX3N0cnVjdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG5vdGVfc3RydWN0KTtcbiAgfVxuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93LkNyZXNjZW5kby5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoQ3Jlc2NlbmRvLkRFQlVHKSBWZXguTChcIlZleC5GbG93LkNyZXNjZW5kb1wiLCBhcmd1bWVudHMpOyB9XG5cbiAgLy8gUHJpdmF0ZSBoZWxwZXIgdG8gZHJhdyB0aGUgaGFpcnBpblxuICBmdW5jdGlvbiByZW5kZXJIYWlycGluKGN0eCwgcGFyYW1zKSB7XG4gICAgdmFyIGJlZ2luX3ggPSBwYXJhbXMuYmVnaW5feDtcbiAgICB2YXIgZW5kX3ggPSBwYXJhbXMuZW5kX3g7XG4gICAgdmFyIHkgPSBwYXJhbXMueTtcbiAgICB2YXIgaGFsZl9oZWlnaHQgPSAgcGFyYW1zLmhlaWdodCAvIDI7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBpZiAocGFyYW1zLnJldmVyc2UpIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhiZWdpbl94LCB5IC0gaGFsZl9oZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKGVuZF94LCAgeSk7XG4gICAgICAgIGN0eC5saW5lVG8oYmVnaW5feCwgeSArIGhhbGZfaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubW92ZVRvKGVuZF94LCAgeSAtIGhhbGZfaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbyhiZWdpbl94LCB5KTtcbiAgICAgICAgY3R4LmxpbmVUbyhlbmRfeCwgIHkgKyBoYWxmX2hlaWdodCk7XG4gICAgfVxuXG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIFZleC5Jbmhlcml0KENyZXNjZW5kbywgVmV4LkZsb3cuTm90ZSwge1xuICAgIC8vIEluaXRpYWxpemUgdGhlIGNyZXNjZW5kbydzIHByb3BlcnRpZXNcbiAgICBpbml0OiBmdW5jdGlvbihub3RlX3N0cnVjdCkge1xuICAgICAgQ3Jlc2NlbmRvLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIG5vdGVfc3RydWN0KTtcblxuICAgICAgLy8gV2hldGhlciB0aGUgb2JqZWN0IGlzIGEgZGVjcmVzY2VuZG9cbiAgICAgIHRoaXMuZGVjcmVzY2VuZG8gPSBmYWxzZTtcblxuICAgICAgLy8gVGhlIHN0YWZmIGxpbmUgdG8gYmUgcGxhY2VkIG9uXG4gICAgICB0aGlzLmxpbmUgPSBub3RlX3N0cnVjdC5saW5lIHx8IDA7XG5cbiAgICAgIC8vIFRoZSBoZWlnaHQgYXQgdGhlIG9wZW4gZW5kIG9mIHRoZSBjcmVzYy9kZWNyZXNjXG4gICAgICB0aGlzLmhlaWdodCA9IDE1O1xuXG4gICAgICBWZXguTWVyZ2UodGhpcy5yZW5kZXJfb3B0aW9ucywge1xuICAgICAgICAvLyBFeHRlbnNpb25zIHRvIHRoZSBsZW5ndGggb2YgdGhlIGNyZXNjZW5kbyBvbiBlaXRoZXIgc2lkZVxuICAgICAgICBleHRlbmRfbGVmdDogMCxcbiAgICAgICAgZXh0ZW5kX3JpZ2h0OiAwLFxuICAgICAgICAvLyBWZXJ0aWNhbCBzaGlmdFxuICAgICAgICB5X3NoaWZ0OiAwXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IHRoZSBsaW5lIHRvIGNlbnRlciB0aGUgZWxlbWVudCBvblxuICAgIHNldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHsgdGhpcy5saW5lID0gbGluZTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBTZXQgdGhlIGZ1bGwgaGVpZ2h0IGF0IHRoZSBvcGVuIGVuZFxuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7IHRoaXMuaGVpZ2h0ID0gaGVpZ2h0OyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIFNldCB3aGV0aGVyIHRoZSBzaWduIHNob3VsZCBiZSBhIGRlc2NyZXNlbmRvIGJ5IHBhc3NpbmcgYSBib29sXG4gICAgLy8gdG8gYGRlY3Jlc2NgXG4gICAgc2V0RGVjcmVzY2VuZG86IGZ1bmN0aW9uKGRlY3Jlc2MpIHtcbiAgICAgIHRoaXMuZGVjcmVzY2VuZG8gPSBkZWNyZXNjO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFByZWZvcm1hdCB0aGUgbm90ZVxuICAgIHByZUZvcm1hdDogZnVuY3Rpb24oKSB7IHRoaXMucHJlRm9ybWF0dGVkID0gdHJ1ZTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBSZW5kZXIgdGhlIENyZXNjZW5kbyBvYmplY3Qgb250byB0aGUgY2FudmFzXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9Db250ZXh0XCIsXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBIYWlycGluIHdpdGhvdXQgYSBjb250ZXh0LlwiKTtcblxuICAgICAgdmFyIHRpY2tfY29udGV4dCA9IHRoaXMuZ2V0VGlja0NvbnRleHQoKTtcbiAgICAgIHZhciBuZXh0X2NvbnRleHQgPSBWZXguRmxvdy5UaWNrQ29udGV4dC5nZXROZXh0Q29udGV4dCh0aWNrX2NvbnRleHQpO1xuXG4gICAgICB2YXIgYmVnaW5feCA9IHRoaXMuZ2V0QWJzb2x1dGVYKCk7XG4gICAgICB2YXIgZW5kX3g7XG4gICAgICBpZiAobmV4dF9jb250ZXh0KSB7XG4gICAgICAgIGVuZF94ID0gbmV4dF9jb250ZXh0LmdldFgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZF94ID0gdGhpcy5zdGF2ZS54ICsgdGhpcy5zdGF2ZS53aWR0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHkgPSB0aGlzLnN0YXZlLmdldFlGb3JMaW5lKHRoaXMubGluZSArICgtMykpICsgMTtcblxuICAgICAgTChcIkRyYXdpbmcgXCIsICB0aGlzLmRlY3Jlc2NlbmRvID8gXCJkZWNyZXNjZW5kbyBcIiA6IFwiY3Jlc2NlbmRvIFwiLFxuICAgICAgICB0aGlzLmhlaWdodCwgXCJ4XCIsIGJlZ2luX3ggLSBlbmRfeCk7XG5cbiAgICAgIHJlbmRlckhhaXJwaW4odGhpcy5jb250ZXh0LCB7XG4gICAgICAgIGJlZ2luX3g6IGJlZ2luX3ggLSB0aGlzLnJlbmRlcl9vcHRpb25zLmV4dGVuZF9sZWZ0LFxuICAgICAgICBlbmRfeDogZW5kX3ggKyB0aGlzLnJlbmRlcl9vcHRpb25zLmV4dGVuZF9yaWdodCxcbiAgICAgICAgeTogeSArIHRoaXMucmVuZGVyX29wdGlvbnMueV9zaGlmdCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgcmV2ZXJzZTogdGhpcy5kZWNyZXNjZW5kb1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQ3Jlc2NlbmRvO1xufSkoKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy8gQXV0aG9yOiBDeXJpbCBTaWx2ZXJtYW5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIG9ybmFtZW50cyBhcyBtb2RpZmllcnMgdGhhdCBjYW4gYmVcbi8vIGF0dGFjaGVkIHRvIG5vdGVzLiBUaGUgY29tcGxldGUgbGlzdCBvZiBvcm5hbWVudHMgaXMgYXZhaWxhYmxlIGluXG4vLyBgdGFibGVzLmpzYCB1bmRlciBgVmV4LkZsb3cub3JuYW1lbnRDb2Rlc2AuXG4vL1xuLy8gU2VlIGB0ZXN0cy9vcm5hbWVudF90ZXN0cy5qc2AgZm9yIHVzYWdlIGV4YW1wbGVzLlxuXG5WZXguRmxvdy5Pcm5hbWVudCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gT3JuYW1lbnQodHlwZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHR5cGUpO1xuICB9XG4gIE9ybmFtZW50LkNBVEVHT1JZID0gXCJvcm5hbWVudHNcIjtcblxuICAvLyBBY2NpZGVudGFsIHBvc2l0aW9uIG1vZGlmaWNhdGlvbnMgZm9yIGVhY2ggZ2x5cGhcbiAgdmFyIGFjY19tb2RzID0ge1xuICAgIFwiblwiOiB7XG4gICAgICBzaGlmdF94OiAxLFxuICAgICAgc2hpZnRfeV91cHBlcjowLFxuICAgICAgc2hpZnRfeV9sb3dlcjowLFxuICAgICAgaGVpZ2h0OiAxN1xuICAgIH0sXG4gICAgXCIjXCI6IHtcbiAgICAgIHNoaWZ0X3g6IDAsXG4gICAgICBzaGlmdF95X3VwcGVyOiAtMixcbiAgICAgIHNoaWZ0X3lfbG93ZXI6IC0yLFxuICAgICAgaGVpZ2h0OiAyMFxuICAgIH0sXG4gICAgXCJiXCI6IHtcbiAgICAgIHNoaWZ0X3g6IDEsXG4gICAgICBzaGlmdF95X3VwcGVyOiAwLFxuICAgICAgc2hpZnRfeV9sb3dlcjogMyxcbiAgICAgIGhlaWdodDogMThcbiAgICB9LFxuICAgIFwiIyNcIjoge1xuICAgICAgc2hpZnRfeDogMCxcbiAgICAgIHNoaWZ0X3lfdXBwZXI6IDAsXG4gICAgICBzaGlmdF95X2xvd2VyOiAwLFxuICAgICAgaGVpZ2h0OiAxMixcbiAgICB9LFxuICAgIFwiYmJcIjoge1xuICAgICAgc2hpZnRfeDogMCxcbiAgICAgIHNoaWZ0X3lfdXBwZXI6IDAsXG4gICAgICBzaGlmdF95X2xvd2VyOiA0LFxuICAgICAgaGVpZ2h0OiAxN1xuICAgIH0sXG4gICAgXCJkYlwiOiB7XG4gICAgICBzaGlmdF94OiAtMyxcbiAgICAgIHNoaWZ0X3lfdXBwZXI6IDAsXG4gICAgICBzaGlmdF95X2xvd2VyOiA0LFxuICAgICAgaGVpZ2h0OiAxN1xuICAgIH0sXG4gICAgXCJiYnNcIjoge1xuICAgICAgc2hpZnRfeDogMCxcbiAgICAgIHNoaWZ0X3lfdXBwZXI6IDAsXG4gICAgICBzaGlmdF95X2xvd2VyOiA0LFxuICAgICAgaGVpZ2h0OiAxN1xuICAgIH0sXG4gICAgXCJkXCI6IHtcbiAgICAgIHNoaWZ0X3g6IDAsXG4gICAgICBzaGlmdF95X3VwcGVyOiAwLFxuICAgICAgc2hpZnRfeV9sb3dlcjogMCxcbiAgICAgIGhlaWdodDogMTdcbiAgICB9LFxuICAgIFwiKytcIjoge1xuICAgICAgc2hpZnRfeDogLTIsXG4gICAgICBzaGlmdF95X3VwcGVyOiAtNixcbiAgICAgIHNoaWZ0X3lfbG93ZXI6IC0zLFxuICAgICAgaGVpZ2h0OiAyMlxuICAgIH0sXG4gICAgXCIrXCI6IHtcbiAgICAgIHNoaWZ0X3g6IDEsXG4gICAgICBzaGlmdF95X3VwcGVyOiAtNCxcbiAgICAgIHNoaWZ0X3lfbG93ZXI6IC0yLFxuICAgICAgaGVpZ2h0OiAyMFxuICAgIH1cbiAgfTtcblxuICAvLyBUbyBlbmFibGUgbG9nZ2luZyBmb3IgdGhpcyBjbGFzcy4gU2V0IGBWZXguRmxvdy5Pcm5hbWVudC5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoT3JuYW1lbnQuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuT3JuYW1lbnRcIiwgYXJndW1lbnRzKTsgfVxuXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xuXG4gIC8vICMjIFN0YXRpYyBNZXRob2RzXG4gIC8vIEFycmFuZ2Ugb3JuYW1lbnRzIGluc2lkZSBgTW9kaWZpZXJDb250ZXh0YFxuICBPcm5hbWVudC5mb3JtYXQgPSBmdW5jdGlvbihvcm5hbWVudHMsIHN0YXRlKSB7XG4gICBpZiAoIW9ybmFtZW50cyB8fCBvcm5hbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JuYW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgb3JuYW1lbnQgPSBvcm5hbWVudHNbaV07XG4gICAgICB2YXIgaW5jcmVtZW50ID0gMTtcbiAgICAgIHdpZHRoID0gTWF0aC5tYXgob3JuYW1lbnQuZ2V0V2lkdGgoKSwgd2lkdGgpO1xuXG4gICAgICB2YXIgdHlwZSA9IFZleC5GbG93Lm9ybmFtZW50Q29kZXMob3JuYW1lbnQudHlwZSk7XG5cbiAgICAgIGlmICghdHlwZS5iZXR3ZWVuX2xpbmVzKSBpbmNyZW1lbnQgKz0gMS41O1xuXG4gICAgICBpZiAob3JuYW1lbnQuZ2V0UG9zaXRpb24oKSA9PT0gTW9kaWZpZXIuUG9zaXRpb24uQUJPVkUpIHtcbiAgICAgICAgb3JuYW1lbnQuc2V0VGV4dExpbmUoc3RhdGUudG9wX3RleHRfbGluZSk7XG4gICAgICAgIHN0YXRlLnRvcF90ZXh0X2xpbmUgKz0gaW5jcmVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3JuYW1lbnQuc2V0VGV4dExpbmUoc3RhdGUudGV4dF9saW5lKTtcbiAgICAgICAgc3RhdGUudGV4dF9saW5lICs9IGluY3JlbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5sZWZ0X3NoaWZ0ICs9IHdpZHRoIC8gMjtcbiAgICBzdGF0ZS5yaWdodF9zaGlmdCArPSB3aWR0aCAvIDI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgVmV4LkluaGVyaXQoT3JuYW1lbnQsIE1vZGlmaWVyLCB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IG9ybmFtZW50IG9mIHR5cGUgYHR5cGVgLCB3aGljaCBpcyBhbiBlbnRyeSBpblxuICAgIC8vIGBWZXguRmxvdy5vcm5hbWVudENvZGVzYCBpbiBgdGFibGVzLmpzYC5cbiAgICBpbml0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBPcm5hbWVudC5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5ub3RlID0gbnVsbDtcbiAgICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBNb2RpZmllci5Qb3NpdGlvbi5BQk9WRTtcbiAgICAgIHRoaXMuZGVsYXllZCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLmFjY2lkZW50YWxfdXBwZXIgPSBcIlwiO1xuICAgICAgdGhpcy5hY2NpZGVudGFsX2xvd2VyID0gXCJcIjtcblxuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgZm9udF9zY2FsZTogMzhcbiAgICAgIH07XG5cbiAgICAgIHRoaXMub3JuYW1lbnQgPSBWZXguRmxvdy5vcm5hbWVudENvZGVzKHRoaXMudHlwZSk7XG4gICAgICBpZiAoIXRoaXMub3JuYW1lbnQpIHRocm93IG5ldyBWZXguUkVSUihcIkFyZ3VtZW50RXJyb3JcIixcbiAgICAgICAgIFwiT3JuYW1lbnQgbm90IGZvdW5kOiAnXCIgKyB0aGlzLnR5cGUgKyBcIidcIik7XG5cbiAgICAgIC8vIERlZmF1bHQgd2lkdGggY29tZXMgZnJvbSBvcm5hbWVudCB0YWJsZS5cbiAgICAgIHRoaXMuc2V0V2lkdGgodGhpcy5vcm5hbWVudC53aWR0aCk7XG4gICAgfSxcblxuICAgIC8vIFNldCB3aGV0aGVyIHRoZSBvcm5hbWVudCBpcyB0byBiZSBkZWxheWVkXG4gICAgc2V0RGVsYXllZDogZnVuY3Rpb24oZGVsYXllZCkgeyB0aGlzLmRlbGF5ZWQgPSBkZWxheWVkOyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIFNldCB0aGUgdXBwZXIgYWNjaWRlbnRhbCBmb3IgdGhlIG9ybmFtZW50XG4gICAgc2V0VXBwZXJBY2NpZGVudGFsOiBmdW5jdGlvbihhY2MpIHtcbiAgICAgIHRoaXMuYWNjaWRlbnRhbF91cHBlciA9IGFjYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIGxvd2VyIGFjY2lkZW50YWwgZm9yIHRoZSBvcm5hbWVudFxuICAgIHNldExvd2VyQWNjaWRlbnRhbDogZnVuY3Rpb24oYWNjKSB7XG4gICAgICB0aGlzLmFjY2lkZW50YWxfbG93ZXIgPSBhY2M7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVuZGVyIG9ybmFtZW50IGluIHBvc2l0aW9uIG5leHQgdG8gbm90ZS5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IE9ybmFtZW50IHdpdGhvdXQgYSBjb250ZXh0LlwiKTtcbiAgICAgIGlmICghKHRoaXMubm90ZSAmJiAodGhpcy5pbmRleCAhPT0gbnVsbCkpKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0F0dGFjaGVkTm90ZVwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgT3JuYW1lbnQgd2l0aG91dCBhIG5vdGUgYW5kIGluZGV4LlwiKTtcblxuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciBzdGVtX2RpcmVjdGlvbiA9IHRoaXMubm90ZS5nZXRTdGVtRGlyZWN0aW9uKCk7XG4gICAgICB2YXIgc3RhdmUgPSB0aGlzLm5vdGUuZ2V0U3RhdmUoKTtcblxuICAgICAgLy8gR2V0IHN0ZW0gZXh0ZW50c1xuICAgICAgdmFyIHN0ZW1fZXh0ID0gdGhpcy5ub3RlLmdldFN0ZW0oKS5nZXRFeHRlbnRzKCk7XG4gICAgICB2YXIgdG9wLCBib3R0b207XG4gICAgICBpZiAoc3RlbV9kaXJlY3Rpb24gPT09IFZleC5GbG93LlN0YXZlTm90ZS5TVEVNX0RPV04pIHtcbiAgICAgICAgdG9wID0gc3RlbV9leHQuYmFzZVk7XG4gICAgICAgIGJvdHRvbSA9IHN0ZW1fZXh0LnRvcFk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3AgPSBzdGVtX2V4dC50b3BZO1xuICAgICAgICBib3R0b20gPSBzdGVtX2V4dC5iYXNlWTtcbiAgICAgIH1cblxuICAgICAgLy8gVGFiTm90ZXMgZG9uJ3QgaGF2ZSBzdGVtcyBhdHRhY2hlZCB0byB0aGVtLiBUYWIgc3RlbXMgYXJlIHJlbmRlcmVkXG4gICAgICAvLyBvdXRzaWRlIHRoZSBzdGF2ZS5cbiAgICAgIHZhciBpc190YWJub3RlID0gdGhpcy5ub3RlLmdldENhdGVnb3J5KCkgPT09ICd0YWJub3Rlcyc7XG4gICAgICBpZiAoaXNfdGFibm90ZSkge1xuICAgICAgICBpZiAodGhpcy5ub3RlLmhhc1N0ZW0oKSl7XG4gICAgICAgICAgaWYgKHN0ZW1fZGlyZWN0aW9uID09PSBWZXguRmxvdy5TdGF2ZU5vdGUuU1RFTV9VUCkge1xuICAgICAgICAgICAgYm90dG9tID0gc3RhdmUuZ2V0WUZvckJvdHRvbVRleHQodGhpcy50ZXh0X2xpbmUgLSAyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0ZW1fZGlyZWN0aW9uID09PSBWZXguRmxvdy5TdGF2ZU5vdGUuU1RFTV9ET1dOICkge1xuICAgICAgICAgICAgdG9wID0gc3RhdmUuZ2V0WUZvclRvcFRleHQodGhpcy50ZXh0X2xpbmUgLSAxLjUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gV2l0aG91dCBhIHN0ZW1cbiAgICAgICAgICB0b3AgPSBzdGF2ZS5nZXRZRm9yVG9wVGV4dCh0aGlzLnRleHRfbGluZSAtIDEpO1xuICAgICAgICAgIGJvdHRvbSA9IHN0YXZlLmdldFlGb3JCb3R0b21UZXh0KHRoaXMudGV4dF9saW5lIC0gMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGlzX29uX2hlYWQgPSBzdGVtX2RpcmVjdGlvbiA9PT0gVmV4LkZsb3cuU3RhdmVOb3RlLlNURU1fRE9XTjtcbiAgICAgIHZhciBzcGFjaW5nID0gc3RhdmUuZ2V0U3BhY2luZ0JldHdlZW5MaW5lcygpO1xuICAgICAgdmFyIGxpbmVfc3BhY2luZyA9IDE7XG5cbiAgICAgIC8vIEJlYW1lZCBzdGVtcyBhcmUgbG9uZ2VyIHRoYW4gcXVhcnRlciBub3RlIHN0ZW1zLCBhZGp1c3QgYWNjb3JkaW5nbHlcbiAgICAgIGlmICghaXNfb25faGVhZCAmJiB0aGlzLm5vdGUuYmVhbSkge1xuICAgICAgICBsaW5lX3NwYWNpbmcgKz0gMC41O1xuICAgICAgfVxuXG4gICAgICB2YXIgdG90YWxfc3BhY2luZyA9IHNwYWNpbmcgKiAodGhpcy50ZXh0X2xpbmUgKyBsaW5lX3NwYWNpbmcpO1xuICAgICAgdmFyIGdseXBoX3lfYmV0d2Vlbl9saW5lcyA9ICh0b3AgLSA3KSAtIHRvdGFsX3NwYWNpbmc7XG5cbiAgICAgIC8vIEdldCBpbml0aWFsIGNvb3JkaW5hdGVzIGZvciB0aGUgbW9kaWZpZXIgcG9zaXRpb25cbiAgICAgIHZhciBzdGFydCA9IHRoaXMubm90ZS5nZXRNb2RpZmllclN0YXJ0WFkodGhpcy5wb3NpdGlvbiwgdGhpcy5pbmRleCk7XG4gICAgICB2YXIgZ2x5cGhfeCA9IHN0YXJ0LnggKyB0aGlzLm9ybmFtZW50LnNoaWZ0X3JpZ2h0O1xuICAgICAgdmFyIGdseXBoX3kgPSBNYXRoLm1pbihzdGF2ZS5nZXRZRm9yVG9wVGV4dCh0aGlzLnRleHRfbGluZSkgLSAzLCBnbHlwaF95X2JldHdlZW5fbGluZXMpO1xuICAgICAgZ2x5cGhfeSArPSB0aGlzLm9ybmFtZW50LnNoaWZ0X3VwICsgdGhpcy55X3NoaWZ0O1xuXG4gICAgICAvLyBBamR1c3QgeCBwb3NpdGlvbiBpZiBvcm5hbWVudCBpcyBkZWxheWVkXG4gICAgICBpZiAodGhpcy5kZWxheWVkKSB7XG4gICAgICAgIGdseXBoX3ggKz0gdGhpcy5vcm5hbWVudC53aWR0aDtcbiAgICAgICAgdmFyIG5leHRfY29udGV4dCA9IFZleC5GbG93LlRpY2tDb250ZXh0LmdldE5leHRDb250ZXh0KHRoaXMubm90ZS5nZXRUaWNrQ29udGV4dCgpKTtcbiAgICAgICAgaWYgKG5leHRfY29udGV4dCkge1xuICAgICAgICAgIGdseXBoX3ggKz0gKG5leHRfY29udGV4dC5nZXRYKCkgLSBnbHlwaF94KSAqIDAuNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbHlwaF94ICs9IChzdGF2ZS54ICsgc3RhdmUud2lkdGggLSBnbHlwaF94KSAqIDAuNTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgb3JuYW1lbnQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gZHJhd0FjY2lkZW50YWwoY3R4LCBjb2RlLCB1cHBlcikge1xuICAgICAgICB2YXIgYWNjaWRlbnRhbCA9IFZleC5GbG93LmFjY2lkZW50YWxDb2Rlcyhjb2RlKTtcblxuICAgICAgICB2YXIgYWNjX3ggPSBnbHlwaF94IC0gMztcbiAgICAgICAgdmFyIGFjY195ID0gZ2x5cGhfeSArIDI7XG5cbiAgICAgICAgLy8gU3BlY2lhbCBhZGp1c3RtZW50cyBmb3IgdHJpbGwgZ2x5cGhcbiAgICAgICAgaWYgKHVwcGVyKSB7XG4gICAgICAgICAgYWNjX3kgLT0gbW9kcyA/IG1vZHMuaGVpZ2h0IDogMTg7XG4gICAgICAgICAgYWNjX3kgKz0gIG9ybmFtZW50LnR5cGUgPT09IFwidHJcIiA/IC04IDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2NfeSArPSAgb3JuYW1lbnQudHlwZSA9PT0gXCJ0clwiID8gLTYgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZSB0dW5lIHBvc2l0aW9uIG9mIGFjY2lkZW50YWwgZ2x5cGhcbiAgICAgICAgdmFyIG1vZHMgPSBhY2NfbW9kc1tjb2RlXTtcbiAgICAgICAgaWYgKG1vZHMpIHtcbiAgICAgICAgICBhY2NfeCArPSBtb2RzLnNoaWZ0X3g7XG4gICAgICAgICAgYWNjX3kgKz0gdXBwZXIgPyBtb2RzLnNoaWZ0X3lfdXBwZXIgOiBtb2RzLnNoaWZ0X3lfbG93ZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW5kZXIgdGhlIGdseXBoXG4gICAgICAgIHZhciBzY2FsZSA9IG9ybmFtZW50LnJlbmRlcl9vcHRpb25zLmZvbnRfc2NhbGUvMS4zO1xuICAgICAgICBWZXguRmxvdy5yZW5kZXJHbHlwaChjdHgsIGFjY194LCBhY2NfeSwgc2NhbGUsIGFjY2lkZW50YWwuY29kZSk7XG5cbiAgICAgICAgLy8gSWYgcmVuZGVyZWQgYSBib3R0b20gYWNjaWRlbnRhbCwgaW5jcmVhc2UgdGhlIHkgdmFsdWUgYnkgdGhlXG4gICAgICAgIC8vIGFjY2lkZW50YWwgaGVpZ2h0IHNvIHRoYXQgdGhlIG9ybmFtZW50J3MgZ2x5cGggaXMgc2hpZnRlZCB1cFxuICAgICAgICBpZiAoIXVwcGVyKSB7XG4gICAgICAgICAgZ2x5cGhfeSAtPSBtb2RzID8gbW9kcy5oZWlnaHQgOiAxODtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEcmF3IGxvd2VyIGFjY2lkZW50YWwgZm9yIG9ybmFtZW50XG4gICAgICBpZiAodGhpcy5hY2NpZGVudGFsX2xvd2VyKSB7XG4gICAgICAgIGRyYXdBY2NpZGVudGFsKGN0eCwgdGhpcy5hY2NpZGVudGFsX2xvd2VyLCBmYWxzZSwgZ2x5cGhfeCwgZ2x5cGhfeSk7XG4gICAgICB9XG5cbiAgICAgIEwoXCJSZW5kZXJpbmcgb3JuYW1lbnQ6IFwiLCB0aGlzLm9ybmFtZW50LCBnbHlwaF94LCBnbHlwaF95KTtcbiAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKGN0eCwgZ2x5cGhfeCwgZ2x5cGhfeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuZm9udF9zY2FsZSwgdGhpcy5vcm5hbWVudC5jb2RlKTtcblxuICAgICAgLy8gRHJhdyB1cHBlciBhY2NpZGVudGFsIGZvciBvcm5hbWVudFxuICAgICAgaWYgKHRoaXMuYWNjaWRlbnRhbF91cHBlcikge1xuICAgICAgICBkcmF3QWNjaWRlbnRhbChjdHgsIHRoaXMuYWNjaWRlbnRhbF91cHBlciwgdHJ1ZSwgZ2x5cGhfeCwgZ2x5cGhfeSk7XG4gICAgICB9XG5cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBPcm5hbWVudDtcbn0oKSk7XG5cbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgZGlmZmVyZW50IHR5cGVzIG9mIHBlZGFsIG1hcmtpbmdzLiBUaGVzZSBub3RhdGlvblxuLy8gZWxlbWVudHMgaW5kaWNhdGUgdG8gdGhlIHBlcmZvcm1lciB3aGVuIHRvIGRlcHJlc3MgYW5kIHJlbGVhc2UgdGhlIGEgcGVkYWwuXG4vL1xuLy8gSW4gb3JkZXIgdG8gY3JlYXRlIFwiU29zdGVudXRvXCIsIGFuZCBcInVuYSBjb3JkYVwiIG1hcmtpbmdzLCB5b3UgbXVzdCBzZXRcbi8vIGN1c3RvbSB0ZXh0IGZvciB0aGUgcmVsZWFzZS9kZXByZXNzIHBlZGFsIG1hcmtpbmdzLlxuVmV4LkZsb3cuUGVkYWxNYXJraW5nID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBQZWRhbE1hcmtpbmcodHlwZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHR5cGUpO1xuICB9XG5cbiAgLy8gVG8gZW5hYmxlIGxvZ2dpbmcgZm9yIHRoaXMgY2xhc3MuIFNldCBgVmV4LkZsb3cuUGVkYWxNYXJraW5nLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChQZWRhbE1hcmtpbmcuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuUGVkYWxNYXJraW5nXCIsIGFyZ3VtZW50cyk7IH1cblxuICAvLyBHbHlwaCBkYXRhXG4gIFBlZGFsTWFya2luZy5HTFlQSFMgPSB7XG4gICAgXCJwZWRhbF9kZXByZXNzXCI6IHtcbiAgICAgIGNvZGU6IFwidjM2XCIsXG4gICAgICB4X3NoaWZ0Oi0xMCxcbiAgICAgIHlfc2hpZnQ6MFxuICAgIH0sXG4gICAgXCJwZWRhbF9yZWxlYXNlXCI6IHtcbiAgICAgIGNvZGU6IFwidjVkXCIsXG4gICAgICB4X3NoaWZ0Oi0yLFxuICAgICAgeV9zaGlmdDozXG4gICAgfSxcbiAgfTtcblxuICBQZWRhbE1hcmtpbmcuU3R5bGVzID0ge1xuICAgIFRFWFQ6IDEsXG4gICAgQlJBQ0tFVDogMixcbiAgICBNSVhFRDogM1xuICB9O1xuXG5cbiAgLy8gIyMgUHVibGljIGhlbHBlcnNcbiAgLy9cbiAgLy8gQ3JlYXRlIGEgc3VzdGFpbiBwZWRhbCBtYXJraW5nLiBSZXR1cm5zIHRoZSBkZWZhdWx0cyBQZWRhbE1hcmtpbmcuXG4gIC8vIFdoaWNoIHVzZXMgdGhlIHRyYWRpdGlvbmFsIFwiUGVkXCIgYW5kIFwiKlwiXCIgbWFya2luZ3MuXG4gIFBlZGFsTWFya2luZy5jcmVhdGVTdXN0YWluID0gZnVuY3Rpb24obm90ZXMpIHtcbiAgICB2YXIgcGVkYWwgPSBuZXcgUGVkYWxNYXJraW5nKG5vdGVzKTtcbiAgICByZXR1cm4gcGVkYWw7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgc29zdGVudXRvIHBlZGFsIG1hcmtpbmdcbiAgUGVkYWxNYXJraW5nLmNyZWF0ZVNvc3RlbnV0byA9IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgdmFyIHBlZGFsID0gbmV3IFBlZGFsTWFya2luZyhub3Rlcyk7XG4gICAgcGVkYWwuc2V0U3R5bGUoUGVkYWxNYXJraW5nLlN0eWxlcy5NSVhFRCk7XG4gICAgcGVkYWwuc2V0Q3VzdG9tVGV4dChcIlNvc3QuIFBlZC5cIik7XG4gICAgcmV0dXJuIHBlZGFsO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhbiB1bmEgY29yZGEgcGVkYWwgbWFya2luZ1xuICBQZWRhbE1hcmtpbmcuY3JlYXRlVW5hQ29yZGEgPSBmdW5jdGlvbihub3Rlcyl7XG4gICAgdmFyIHBlZGFsID0gbmV3IFBlZGFsTWFya2luZyhub3Rlcyk7XG4gICAgcGVkYWwuc2V0U3R5bGUoUGVkYWxNYXJraW5nLlN0eWxlcy5URVhUKTtcbiAgICBwZWRhbC5zZXRDdXN0b21UZXh0KFwidW5hIGNvcmRhXCIsIFwidHJlIGNvcmRhXCIpO1xuICAgIHJldHVybiBwZWRhbDtcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICBQZWRhbE1hcmtpbmcucHJvdG90eXBlID0gIHtcbiAgICBpbml0OiBmdW5jdGlvbihub3Rlcykge1xuICAgICAgdGhpcy5ub3RlcyA9IG5vdGVzO1xuICAgICAgdGhpcy5zdHlsZSA9IFZleC5GbG93LlBlZGFsTWFya2luZy5URVhUO1xuICAgICAgdGhpcy5saW5lID0gMDtcblxuICAgICAgLy8gQ3VzdG9tIHRleHQgZm9yIHRoZSByZWxlYXNlL2RlcHJlc3MgbWFya2luZ3NcbiAgICAgIHRoaXMuY3VzdG9tX2RlcHJlc3NfdGV4dCA9IFwiXCI7XG4gICAgICB0aGlzLmN1c3RvbV9yZWxlYXNlX3RleHQgPSBcIlwiO1xuXG4gICAgICB0aGlzLmZvbnQgPSB7XG4gICAgICAgIGZhbWlseTogXCJUaW1lcyBOZXcgUm9tYW5cIixcbiAgICAgICAgc2l6ZTogMTIsXG4gICAgICAgIHdlaWdodDogXCJpdGFsaWMgYm9sZFwiXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnJlbmRlcl9vcHRpb25zID0ge1xuICAgICAgICBicmFja2V0X2hlaWdodDogMTAsXG4gICAgICAgIHRleHRfbWFyZ2luX3JpZ2h0OiA2LFxuICAgICAgICBicmFja2V0X2xpbmVfd2lkdGg6IDEsXG4gICAgICAgIGdseXBoX3BvaW50X3NpemU6IDQwLFxuICAgICAgICBjb2xvcjogXCJibGFja1wiXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBTZXQgY3VzdG9tIHRleHQgZm9yIHRoZSBgZGVwcmVzc2AvYHJlbGVhc2VgIHBlZGFsIG1hcmtpbmdzLiBObyB0ZXh0IGlzXG4gICAgLy8gc2V0IGlmIHRoZSBwYXJhbWV0ZXIgaXMgZmFsc3kuXG4gICAgc2V0Q3VzdG9tVGV4dDogZnVuY3Rpb24oZGVwcmVzcywgcmVsZWFzZSkge1xuICAgICAgdGhpcy5jdXN0b21fZGVwcmVzc190ZXh0ID0gZGVwcmVzcyB8fCBcIlwiO1xuICAgICAgdGhpcy5jdXN0b21fcmVsZWFzZV90ZXh0ID0gcmVsZWFzZSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFNldCB0aGUgcGVkYWwgbWFya2luZyBzdHlsZVxuICAgIHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSl7XG4gICAgICBpZiAoc3R5bGUgPCAxICYmIHN0eWxlID4gMykgIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiSW52YWxpZFBhcmFtZXRlclwiLFxuICAgICAgICAgIFwiVGhlIHN0eWxlIG11c3QgYmUgb25lIGZvdW5kIGluIFBlZGFsTWFya2luZy5TdHlsZXNcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIHN0YWZmIGxpbmUgdG8gcmVuZGVyIHRoZSBtYXJraW5ncyBvblxuICAgIHNldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHsgdGhpcy5saW5lID0gbGluZTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBTZXQgdGhlIHJlbmRlcmluZyBjb250ZXh0XG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkgeyB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIERyYXcgdGhlIGJyYWNrZXQgYmFzZWQgcGVkYWwgbWFya2luZ3NcbiAgICBkcmF3QnJhY2tldGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgaXNfcGVkYWxfZGVwcmVzc2VkID0gZmFsc2U7XG4gICAgICB2YXIgcHJldl94O1xuICAgICAgdmFyIHByZXZfeTtcbiAgICAgIHZhciBwZWRhbCA9IHRoaXM7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIG5vdGVcbiAgICAgIHRoaXMubm90ZXMuZm9yRWFjaChmdW5jdGlvbihub3RlLCBpbmRleCwgbm90ZXMpIHtcbiAgICAgICAgLy8gRWFjaCBub3RlIHRyaWdnZXJzIHRoZSBvcHBvc2l0ZSBwZWRhbCBhY3Rpb25cbiAgICAgICAgaXNfcGVkYWxfZGVwcmVzc2VkID0gIWlzX3BlZGFsX2RlcHJlc3NlZDtcblxuICAgICAgICAvLyBHZXQgdGhlIGluaXRpYWwgY29vcmRpbmF0ZXMgZm9yIHRoZSBub3RlXG4gICAgICAgIHZhciB4ID0gbm90ZS5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgICAgdmFyIHkgPSBub3RlLmdldFN0YXZlKCkuZ2V0WUZvckJvdHRvbVRleHQocGVkYWwubGluZSArIDMpO1xuXG4gICAgICAgIC8vIFRocm93IGlmIGN1cnJlbnQgbm90ZSBpcyBwb3NpdGlvbmVkIGJlZm9yZSB0aGUgcHJldmlvdXMgbm90ZVxuICAgICAgICBpZiAoeCA8IHByZXZfeCkgdGhyb3cgbmV3IFZleC5SRVJSKCdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICAgICAgJ1RoZSBub3RlcyBwcm92aWRlZCBtdXN0IGJlIGluIG9yZGVyIG9mIGFzY2VuZGluZyB4IHBvc2l0aW9ucycpO1xuXG4gICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgcHJldmlvdXMgb3IgbmV4dCBub3RlIGFyZSB0aGUgc2FtZVxuICAgICAgICAvLyBhcyB0aGUgY3VycmVudCBub3RlLiBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgdGhpcyBmb3JcbiAgICAgICAgLy8gd2hlbiBhZGp1c3RtZW50cyBhcmUgbWFkZSBmb3IgdGhlIHJlbGVhc2UrZGVwcmVzcyBhY3Rpb25cbiAgICAgICAgdmFyIG5leHRfaXNfc2FtZSA9IG5vdGVzW2luZGV4KzFdID09PSBub3RlO1xuICAgICAgICB2YXIgcHJldl9pc19zYW1lID0gbm90ZXNbaW5kZXgtMV0gPT09IG5vdGU7XG5cbiAgICAgICAgdmFyIHhfc2hpZnQgPSAwO1xuICAgICAgICBpZiAoaXNfcGVkYWxfZGVwcmVzc2VkKSB7XG4gICAgICAgICAgLy8gQWRqdXN0bWVudCBmb3IgcmVsZWFzZStkZXByZXNzXG4gICAgICAgICAgeF9zaGlmdCA9ICBwcmV2X2lzX3NhbWUgPyA1IDogMDtcblxuICAgICAgICAgIGlmIChwZWRhbC5zdHlsZSA9PT0gUGVkYWxNYXJraW5nLlN0eWxlcy5NSVhFRCAmJiAhcHJldl9pc19zYW1lKSB7XG4gICAgICAgICAgICAvLyBGb3IgTUlYRUQgc3R5bGUsIHN0YXJ0IHdpdGggdGV4dCBpbnN0ZWFkIG9mIGJyYWNrZXRcbiAgICAgICAgICAgIGlmIChwZWRhbC5jdXN0b21fZGVwcmVzc190ZXh0KSB7XG4gICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgY3VzdG9tIHRleHQsIHVzZSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IFwiUGVkXCIgZ2x5cGhcbiAgICAgICAgICAgICAgdmFyIHRleHRfd2lkdGggPSBjdHgubWVhc3VyZVRleHQocGVkYWwuY3VzdG9tX2RlcHJlc3NfdGV4dCkud2lkdGg7XG4gICAgICAgICAgICAgIGN0eC5maWxsVGV4dChwZWRhbC5jdXN0b21fZGVwcmVzc190ZXh0LCB4IC0gKHRleHRfd2lkdGgvMiksIHkpO1xuICAgICAgICAgICAgICB4X3NoaWZ0ID0gKHRleHRfd2lkdGggLyAyKSArIHBlZGFsLnJlbmRlcl9vcHRpb25zLnRleHRfbWFyZ2luX3JpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBQZWQgZ2x5cGggaW4gcG9zaXRpb25cbiAgICAgICAgICAgICAgZHJhd1BlZGFsR2x5cGgoJ3BlZGFsX2RlcHJlc3MnLCBjdHgsIHgsIHksIHBlZGFsLnJlbmRlcl9vcHRpb25zLmdseXBoX3BvaW50X3NpemUpO1xuICAgICAgICAgICAgICB4X3NoaWZ0ID0gMjAgKyBwZWRhbC5yZW5kZXJfb3B0aW9ucy50ZXh0X21hcmdpbl9yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRHJhdyBzdGFydCBicmFja2V0XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkgLSBwZWRhbC5yZW5kZXJfb3B0aW9ucy5icmFja2V0X2hlaWdodCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB4X3NoaWZ0LCB5KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWRqdXN0bWVudCBmb3IgcmVsZWFzZStkZXByZXNzXG4gICAgICAgICAgeF9zaGlmdCA9IG5leHRfaXNfc2FtZSA/IC01IDogMDtcblxuICAgICAgICAgIC8vIERyYXcgZW5kIGJyYWNrZXRcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhwcmV2X3gsIHByZXZfeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4ICsgeF9zaGlmdCwgeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5IC0gcGVkYWwucmVuZGVyX29wdGlvbnMuYnJhY2tldF9oZWlnaHQpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSBwcmV2aW91cyBjb29yZGluYXRlc1xuICAgICAgICBwcmV2X3ggPSB4ICsgeF9zaGlmdDtcbiAgICAgICAgcHJldl95ID0geTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBEcmF3IHRoZSB0ZXh0IGJhc2VkIHBlZGFsIG1hcmtpbmdzLiBUaGlzIGRlZmF1bHRzIHRvIHRoZSB0cmFkaXRpb25hbFxuICAgIC8vIFwiUGVkXCIgYW5kIFwiKlwiXCIgc3ltYm9scyBpZiBubyBjdXN0b20gdGV4dCBoYXMgYmVlbiBwcm92aWRlZC5cbiAgICBkcmF3VGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIGlzX3BlZGFsX2RlcHJlc3NlZCA9IGZhbHNlO1xuICAgICAgdmFyIHBlZGFsID0gdGhpcztcblxuICAgICAgLy8gVGhlIGdseXBoIHBvaW50IHNpemVcbiAgICAgIHZhciBwb2ludCA9IHBlZGFsLnJlbmRlcl9vcHRpb25zLmdseXBoX3BvaW50X3NpemU7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIG5vdGUsIHBsYWNpbmcgZ2x5cGhzIG9yIGN1c3RvbSB0ZXh0IGFjY29yZGluZ2x5XG4gICAgICB0aGlzLm5vdGVzLmZvckVhY2goZnVuY3Rpb24obm90ZSkge1xuICAgICAgICBpc19wZWRhbF9kZXByZXNzZWQgPSAhaXNfcGVkYWxfZGVwcmVzc2VkO1xuICAgICAgICB2YXIgc3RhdmUgPSBub3RlLmdldFN0YXZlKCk7XG4gICAgICAgIHZhciB4ID0gbm90ZS5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgICAgdmFyIHkgPSBzdGF2ZS5nZXRZRm9yQm90dG9tVGV4dChwZWRhbC5saW5lICsgMyk7XG5cbiAgICAgICAgdmFyIHRleHRfd2lkdGggPSAwO1xuICAgICAgICBpZiAoaXNfcGVkYWxfZGVwcmVzc2VkKSB7XG4gICAgICAgICAgaWYgKHBlZGFsLmN1c3RvbV9kZXByZXNzX3RleHQpIHtcbiAgICAgICAgICAgIHRleHRfd2lkdGggPSBjdHgubWVhc3VyZVRleHQocGVkYWwuY3VzdG9tX2RlcHJlc3NfdGV4dCkud2lkdGg7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQocGVkYWwuY3VzdG9tX2RlcHJlc3NfdGV4dCwgeCAtICh0ZXh0X3dpZHRoLzIpLCB5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhd1BlZGFsR2x5cGgoXCJwZWRhbF9kZXByZXNzXCIsIGN0eCwgeCwgeSwgcG9pbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocGVkYWwuY3VzdG9tX3JlbGVhc2VfdGV4dCkge1xuICAgICAgICAgICAgdGV4dF93aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChwZWRhbC5jdXN0b21fcmVsZWFzZV90ZXh0KS53aWR0aDtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChwZWRhbC5jdXN0b21fcmVsZWFzZV90ZXh0LCB4IC0gKHRleHRfd2lkdGgvMiksIHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmF3UGVkYWxHbHlwaChcInBlZGFsX3JlbGVhc2VcIiwgY3R4LCB4LCB5LCBwb2ludCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmVuZGVyIHRoZSBwZWRhbCBtYXJraW5nIGluIHBvc2l0aW9uIG9uIHRoZSByZW5kZXJpbmcgY29udGV4dCBcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IFBlZGFsTWFya2luZyB3aXRob3V0IGEgY29udGV4dC5cIik7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnNldFN0cm9rZVN0eWxlKHRoaXMucmVuZGVyX29wdGlvbnMuY29sb3IpO1xuICAgICAgY3R4LnNldEZpbGxTdHlsZSh0aGlzLnJlbmRlcl9vcHRpb25zLmNvbG9yKTtcbiAgICAgIGN0eC5zZXRGb250KHRoaXMuZm9udC5mYW1pbHksIHRoaXMuZm9udC5zaXplLCB0aGlzLmZvbnQud2VpZ2h0KTtcblxuICAgICAgTChcIlJlbmRlcmluZyBQZWRhbCBNYXJraW5nXCIpO1xuXG4gICAgICBpZiAodGhpcy5zdHlsZSA9PT0gUGVkYWxNYXJraW5nLlN0eWxlcy5CUkFDS0VUIHx8XG4gICAgICAgICAgdGhpcy5zdHlsZSA9PT0gUGVkYWxNYXJraW5nLlN0eWxlcy5NSVhFRCkge1xuICAgICAgICBjdHguc2V0TGluZVdpZHRoKHRoaXMucmVuZGVyX29wdGlvbnMuYnJhY2tldF9saW5lX3dpZHRoKTtcbiAgICAgICAgdGhpcy5kcmF3QnJhY2tldGVkKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3R5bGUgPT09IFZleC5GbG93LlBlZGFsTWFya2luZy5TdHlsZXMuVEVYVCkge1xuICAgICAgICB0aGlzLmRyYXdUZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vICMjIFByaXZhdGUgSGVscGVyXG4gIC8vIFxuICAvLyBEcmF3cyBhIHBlZGFsIGdseXBoIHdpdGggdGhlIHByb3ZpZGVkIGBuYW1lYCBvbiBhIHJlbmRlcmluZyBgY29udGV4dGAgXG4gIC8vIGF0IHRoZSBjb29yZGluYXRlcyBgeGAgYW5kIGB5LiBUYWtlcyBpbnRvIGFjY291bnQgdGhlIGdseXBoIGRhdGFcbiAgLy8gY29vcmRpbmF0ZSBzaGlmdHMuXG4gIGZ1bmN0aW9uIGRyYXdQZWRhbEdseXBoKG5hbWUsIGNvbnRleHQsIHgsIHksIHBvaW50KSB7XG4gICAgdmFyIGdseXBoX2RhdGEgPSBQZWRhbE1hcmtpbmcuR0xZUEhTW25hbWVdO1xuICAgIHZhciBnbHlwaCA9IG5ldyBWZXguRmxvdy5HbHlwaChnbHlwaF9kYXRhLmNvZGUsIHBvaW50KTtcbiAgICBnbHlwaC5yZW5kZXIoY29udGV4dCwgeCArIGdseXBoX2RhdGEueF9zaGlmdCwgeSArIGdseXBoX2RhdGEueV9zaGlmdCk7XG4gIH1cblxuICByZXR1cm4gUGVkYWxNYXJraW5nO1xufSgpKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy8gQXV0aG9yOiBDeXJpbCBTaWx2ZXJtYW5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnQgYFRleHRCcmFja2V0c2Agd2hpY2ggZXh0ZW5kIGJldHdlZW4gdHdvIG5vdGVzLlxuLy8gVGhlIG9jdGF2ZSB0cmFuc3Bvc2l0aW9uIG1hcmtpbmdzICg4dmEsIDh2YiwgMTV2YSwgMTV2YikgY2FuIGJlIGNyZWF0ZWRcbi8vIHVzaW5nIHRoaXMgY2xhc3MuXG4vL1xuVmV4LkZsb3cuVGV4dEJyYWNrZXQgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRleHRCcmFja2V0KGJyYWNrZXRfZGF0YSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KGJyYWNrZXRfZGF0YSk7XG4gIH1cblxuICAvLyBUbyBlbmFibGUgbG9nZ2luZyBmb3IgdGhpcyBjbGFzcy4gU2V0IGBWZXguRmxvdy5UZXh0QnJhY2tldC5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoVGV4dEJyYWNrZXQuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuVGV4dEJyYWNrZXRcIiwgYXJndW1lbnRzKTsgfVxuXG4gIFRleHRCcmFja2V0LlBvc2l0aW9ucyA9IHtcbiAgICBUT1A6IDEsXG4gICAgQk9UVE9NOiAtMVxuICB9O1xuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIFRleHRCcmFja2V0LnByb3RvdHlwZSA9ICB7XG4gICAgaW5pdDogZnVuY3Rpb24oYnJhY2tldF9kYXRhKSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gYnJhY2tldF9kYXRhLnN0YXJ0O1xuICAgICAgdGhpcy5zdG9wID0gYnJhY2tldF9kYXRhLnN0b3A7XG5cbiAgICAgIHRoaXMudGV4dCA9IGJyYWNrZXRfZGF0YS50ZXh0IHx8IFwiXCI7XG4gICAgICB0aGlzLnN1cGVyc2NyaXB0ID0gYnJhY2tldF9kYXRhLnN1cGVyc2NyaXB0IHx8IFwiXCI7XG5cbiAgICAgIHRoaXMucG9zaXRpb24gPSBicmFja2V0X2RhdGEucG9zaXRpb24gfHwgVGV4dEJyYWNrZXQuUG9zaXRpb25zLlRPUDtcbiAgICAgIHRoaXMubGluZSA9IDE7XG5cbiAgICAgIHRoaXMuZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiBcIlNlcmlmXCIsXG4gICAgICAgIHNpemU6IDE1LFxuICAgICAgICB3ZWlnaHQ6IFwiaXRhbGljXCJcbiAgICAgIH07XG5cbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMgPSB7XG4gICAgICAgIGRhc2hlZDogdHJ1ZSxcbiAgICAgICAgZGFzaDogWzVdLFxuICAgICAgICBjb2xvcjogXCJibGFja1wiLFxuICAgICAgICBsaW5lX3dpZHRoOiAxLFxuICAgICAgICBzaG93X2JyYWNrZXQ6IHRydWUsXG4gICAgICAgIGJyYWNrZXRfaGVpZ2h0OiA4LFxuXG4gICAgICAgIC8vIEluIHRoZSBCT1RUT00gcG9zaXRpb24sIHRoZSBicmFja2V0IGxpbmUgY2FuIGV4dGVuZFxuICAgICAgICAvLyB1bmRlciB0aGUgc3VwZXJzY3JpcHQuXG4gICAgICAgIHVuZGVybGluZV9zdXBlcnNjcmlwdDogdHJ1ZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gQXBwbHkgdGhlIHRleHQgYmFja2V0IHN0eWxpbmcgdG8gdGhlIHByb3ZpZGVkIGBjb250ZXh0YFxuICAgIGFwcGx5U3R5bGU6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIC8vIEFwcGx5IHN0eWxlIGZvciB0aGUgb2N0YXZlIGJyYWNrZXRcbiAgICAgIGNvbnRleHQuc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSwgdGhpcy5mb250LndlaWdodCk7XG4gICAgICBjb250ZXh0LnNldFN0cm9rZVN0eWxlKHRoaXMucmVuZGVyX29wdGlvbnMuY29sb3IpO1xuICAgICAgY29udGV4dC5zZXRGaWxsU3R5bGUodGhpcy5yZW5kZXJfb3B0aW9ucy5jb2xvcik7XG4gICAgICBjb250ZXh0LnNldExpbmVXaWR0aCh0aGlzLnJlbmRlcl9vcHRpb25zLmxpbmVfd2lkdGgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2V0IHdoZXRoZXIgdGhlIGJyYWNrZXQgbGluZSBzaG91bGQgYmUgYGRhc2hlZGAuIFlvdSBjYW4gYWxzb1xuICAgIC8vIG9wdGlvbmFsbHkgc2V0IHRoZSBgZGFzaGAgcGF0dGVybiBieSBwYXNzaW5nIGluIGFuIGFycmF5IG9mIG51bWJlcnNcbiAgICBzZXREYXNoZWQ6IGZ1bmN0aW9uKGRhc2hlZCwgZGFzaCkge1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5kYXNoZWQgPSBkYXNoZWQ7XG4gICAgICBpZiAoZGFzaCkgdGhpcy5yZW5kZXJfb3B0aW9ucy5kYXNoID0gZGFzaDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIGZvbnQgZm9yIHRoZSB0ZXh0XG4gICAgc2V0Rm9udDogZnVuY3Rpb24oZm9udCkgeyB0aGlzLmZvbnQgPSBmb250OyByZXR1cm4gdGhpczsgfSxcbiAgICAvLyBTZXQgdGhlIHJlbmRlcmluZyBgY29udGV4dGAgZm9yIHRoZSBvY3RhdmUgYnJhY2tldFxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHsgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgLy8gU2V0IHRoZSBzdGFmZiBsaW5lIHRvIHJlbmRlciB0aGUgYnJhY2tldCBvblxuICAgIHNldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHsgdGhpcy5saW5lID0gbGluZTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBEcmF3IHRoZSBvY3RhdmUgYnJhY2tldCBvbiB0aGUgcmVuZGVyaW5nIGNvbnRleHRcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHZhciB5ID0gMDtcbiAgICAgIHN3aXRjaCh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgVGV4dEJyYWNrZXQuUG9zaXRpb25zLlRPUDpcbiAgICAgICAgICB5ID0gIHRoaXMuc3RhcnQuZ2V0U3RhdmUoKS5nZXRZRm9yVG9wVGV4dCh0aGlzLmxpbmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRleHRCcmFja2V0LlBvc2l0aW9ucy5CT1RUT006XG4gICAgICAgICAgeSA9ICB0aGlzLnN0YXJ0LmdldFN0YXZlKCkuZ2V0WUZvckJvdHRvbVRleHQodGhpcy5saW5lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBwcmVsaW1pbmFyeSBzdGFydCBhbmQgc3RvcCBjb29yZGludGF0ZXMgZm9yIHRoZSBicmFja2V0XG4gICAgICB2YXIgc3RhcnQgPSB7IHg6IHRoaXMuc3RhcnQuZ2V0QWJzb2x1dGVYKCksIHk6IHl9O1xuICAgICAgdmFyIHN0b3AgPSB7IHg6IHRoaXMuc3RvcC5nZXRBYnNvbHV0ZVgoKSwgeTogeSB9O1xuXG4gICAgICBMKFwiUmVuZGVyaW5nIFRleHRCcmFja2V0OiBzdGFydDpcIiwgc3RhcnQsIFwic3RvcDpcIiwgc3RvcCwgXCJ5OlwiLCB5KTtcblxuICAgICAgdmFyIGJyYWNrZXRfaGVpZ2h0ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5icmFja2V0X2hlaWdodCAqIHRoaXMucG9zaXRpb247XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmFwcGx5U3R5bGUoY3R4KTtcblxuICAgICAgLy8gRHJhdyB0ZXh0XG4gICAgICBjdHguZmlsbFRleHQodGhpcy50ZXh0LCBzdGFydC54LCBzdGFydC55KTtcblxuICAgICAgLy8gR2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGZvciB0aGUgb2N0YXZlIG51bWJlclxuICAgICAgdmFyIG1haW5fd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aDtcbiAgICAgIHZhciBtYWluX2hlaWdodCA9IGN0eC5tZWFzdXJlVGV4dChcIk1cIikud2lkdGg7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgeSBwb3NpdGlvbiBmb3IgdGhlIHN1cGVyIHNjcmlwdFxuICAgICAgdmFyIHN1cGVyX3kgPSBzdGFydC55IC0gKG1haW5faGVpZ2h0LzIuNSk7XG5cbiAgICAgIC8vIERyYXcgdGhlIHN1cGVyc2NyaXB0XG4gICAgICBjdHguc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSAvIDEuNCwgdGhpcy5mb250LndlaWdodCk7XG4gICAgICBjdHguZmlsbFRleHQodGhpcy5zdXBlcnNjcmlwdCwgc3RhcnQueCArIG1haW5fd2lkdGggKyAxLCBzdXBlcl95KTtcblxuXG4gICAgICAvLyBEZXRlcm1pbmUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgc3VwZXJzY3JpcHRcbiAgICAgIHZhciBzdXBlcnNjcmlwdF93aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLnN1cGVyc2NyaXB0KS53aWR0aDtcbiAgICAgIHZhciBzdXBlcl9oZWlnaHQgPSBjdHgubWVhc3VyZVRleHQoXCJNXCIpLndpZHRoO1xuXG4gICAgICAvLyBTZXR1cCBpbml0aWFsIGNvb3JkaW5hdGVzIGZvciB0aGUgYnJhY2tldCBsaW5lXG4gICAgICB2YXIgc3RhcnRfeCA9IHN0YXJ0Lng7XG4gICAgICB2YXIgbGluZV95ID0gc3VwZXJfeTtcbiAgICAgIHZhciBlbmRfeCA9IHN0b3AueCArIHRoaXMuc3RvcC5nZXRHbHlwaCgpLmhlYWRfd2lkdGg7XG5cbiAgICAgIC8vIEFkanVzdCB4IGFuZCB5IGNvb3JkaW5hdGVzIGJhc2VkIG9uIHBvc2l0aW9uXG4gICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gVGV4dEJyYWNrZXQuUG9zaXRpb25zLlRPUCkge1xuICAgICAgICBzdGFydF94ICs9IG1haW5fd2lkdGggKyBzdXBlcnNjcmlwdF93aWR0aCArIDU7XG4gICAgICAgIGxpbmVfeSAtPSBzdXBlcl9oZWlnaHQvMi43O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBvc2l0aW9uID09PSBUZXh0QnJhY2tldC5Qb3NpdGlvbnMuQk9UVE9NKSB7XG4gICAgICAgIGxpbmVfeSArPSBzdXBlcl9oZWlnaHQvMi43O1xuICAgICAgICBzdGFydF94ICs9IG1haW5fd2lkdGggKyAyO1xuXG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJfb3B0aW9ucy51bmRlcmxpbmVfc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICBzdGFydF94ICs9IHN1cGVyc2NyaXB0X3dpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlcl9vcHRpb25zLmRhc2hlZCkge1xuICAgICAgICAvLyBNYWluIGxpbmVcbiAgICAgICAgVmV4LkZsb3cuUmVuZGVyZXIuZHJhd0Rhc2hlZExpbmUoY3R4LCBzdGFydF94LCBsaW5lX3ksIGVuZF94LCBsaW5lX3ksXG4gICAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5kYXNoKTtcbiAgICAgICAgLy8gRW5kaW5nIEJyYWNrZXRcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyX29wdGlvbnMuc2hvd19icmFja2V0KSB7XG4gICAgICAgICAgVmV4LkZsb3cuUmVuZGVyZXIuZHJhd0Rhc2hlZExpbmUoY3R4LCBlbmRfeCwgbGluZV95ICsgKDEgKiB0aGlzLnBvc2l0aW9uKSxcbiAgICAgICAgICAgIGVuZF94LCBsaW5lX3kgKyBicmFja2V0X2hlaWdodCwgdGhpcy5yZW5kZXJfb3B0aW9ucy5kYXNoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHN0YXJ0X3gsIGxpbmVfeSk7XG4gICAgICAgIC8vIE1haW4gbGluZVxuICAgICAgICBjdHgubGluZVRvKGVuZF94LCBsaW5lX3kpO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJfb3B0aW9ucy5zaG93X2JyYWNrZXQpIHtcbiAgICAgICAgICAvLyBFbmRpbmcgYnJhY2tldFxuICAgICAgICAgIGN0eC5saW5lVG8oZW5kX3gsIGxpbmVfeSArIGJyYWNrZXRfaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRCcmFja2V0O1xufSkoKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgdGhlIGBUZXh0RHluYW1pY3NgIHdoaWNoIHJlbmRlcnMgdHJhZGl0aW9uYWxcbi8vIHRleHQgZHluYW1pY3MgbWFya2luZ3MsICoqaWU6IHAsIGYsIHNmeiwgcmZ6LCBwcHAqKlxuLy9cbi8vIFlvdSBjYW4gcmVuZGVyIGFueSBkeW5hbWljcyBzdHJpbmcgdGhhdCBjb250YWlucyBhIGNvbWJpbmF0aW9uIG9mXG4vLyB0aGUgZm9sbG93aW5nIGxldHRlcnM6ICBQLCBNLCBGLCBaLCBSLCBTXG5WZXguRmxvdy5UZXh0RHluYW1pY3MgPSAoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gVGV4dER5bmFtaWNzKHRleHRfc3RydWN0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGV4dF9zdHJ1Y3QpO1xuICB9XG5cbiAgLy8gVG8gZW5hYmxlIGxvZ2dpbmcgZm9yIHRoaXMgY2xhc3MuIFNldCBgVmV4LkZsb3cuVGV4dER5bmFtaWNzLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChUZXh0RHluYW1pY3MuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuVGV4dER5bmFtaWNzXCIsIGFyZ3VtZW50cyk7IH1cblxuICAvLyBUaGUgZ2x5cGggZGF0YSBmb3IgZWFjaCBkeW5hbWljcyBsZXR0ZXJcbiAgVGV4dER5bmFtaWNzLkdMWVBIUyA9IHtcbiAgICBcImZcIjoge1xuICAgICAgY29kZTogXCJ2YmFcIixcbiAgICAgIHdpZHRoOiAxMlxuICAgIH0sXG4gICAgXCJwXCI6IHtcbiAgICAgIGNvZGU6IFwidmJmXCIsXG4gICAgICB3aWR0aDogMTRcbiAgICB9LFxuICAgIFwibVwiOiB7XG4gICAgICBjb2RlOiBcInY2MlwiLFxuICAgICAgd2lkdGg6IDE3XG4gICAgfSxcbiAgICBcInNcIjoge1xuICAgICAgY29kZTogXCJ2NGFcIixcbiAgICAgIHdpZHRoOiAxMFxuICAgIH0sXG4gICAgXCJ6XCI6IHtcbiAgICAgIGNvZGU6IFwidjgwXCIsXG4gICAgICB3aWR0aDogMTJcbiAgICB9LFxuICAgIFwiclwiOiB7XG4gICAgICBjb2RlOiBcInZiMVwiLFxuICAgICAgd2lkdGg6IDEyXG4gICAgfVxuICB9O1xuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIC8vXG4gIC8vIEEgYFRleHREeW5hbWljc2Agb2JqZWN0IGluaGVyaXRzIGZyb20gYE5vdGVgIHNvIHRoYXQgaXQgY2FuIGJlIGZvcm1hdHRlZFxuICAvLyB3aXRoaW4gYSBgVm9pY2VgLlxuICBWZXguSW5oZXJpdChUZXh0RHluYW1pY3MsIFZleC5GbG93Lk5vdGUsIHtcbiAgICAvLyBDcmVhdGUgdGhlIGR5bmFtaWNzIG1hcmtpbmcuIGB0ZXh0X3N0cnVjdGAgaXMgYW4gb2JqZWN0XG4gICAgLy8gdGhhdCBjb250YWlucyBhIGBkdXJhdGlvbmAgcHJvcGVydHkgYW5kIGEgYHNlcXVlbmNlYCBvZlxuICAgIC8vIGxldHRlcnMgdGhhdCByZXByZXNlbnRzIHRoZSBsZXR0ZXJzIHRvIHJlbmRlclxuICAgIGluaXQ6IGZ1bmN0aW9uKHRleHRfc3RydWN0KSB7XG4gICAgICBUZXh0RHluYW1pY3Muc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgdGV4dF9zdHJ1Y3QpO1xuXG4gICAgICB0aGlzLnNlcXVlbmNlID0gdGV4dF9zdHJ1Y3QudGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgdGhpcy5saW5lID0gdGV4dF9zdHJ1Y3QubGluZSB8fCAwO1xuICAgICAgdGhpcy5nbHlwaHMgPSBbXTtcblxuICAgICAgVmV4Lk1lcmdlKHRoaXMucmVuZGVyX29wdGlvbnMsIHtcbiAgICAgICAgZ2x5cGhfZm9udF9zaXplOiA0MFxuICAgICAgfSk7XG5cbiAgICAgIEwoXCJOZXcgRHluYW1pY3MgVGV4dDogXCIsIHRoaXMuc2VxdWVuY2UpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIFN0YXZlIGxpbmUgb24gd2hpY2ggdGhlIG5vdGUgc2hvdWxkIGJlIHBsYWNlZFxuICAgIHNldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHsgdGhpcy5saW5lID0gbGluZTsgIHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gUHJlZm9ybWF0IHRoZSBkeW5hbWljcyB0ZXh0XG4gICAgcHJlRm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b3RhbF93aWR0aCA9IDA7XG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBsZXR0ZXJcbiAgICAgIHRoaXMuc2VxdWVuY2Uuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24obGV0dGVyKSB7XG4gICAgICAgIC8vIEdldCB0aGUgZ2x5cGggZGF0YSBmb3IgdGhlIGxldHRlclxuICAgICAgICB2YXIgZ2x5cGhfZGF0YSA9IFRleHREeW5hbWljcy5HTFlQSFNbbGV0dGVyXTtcbiAgICAgICAgaWYgKCFnbHlwaF9kYXRhKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJJbnZhbGlkIGR5bmFtaWNzIGNoYXJhY3RlcjogXCIgKyBsZXR0ZXIpO1xuXG4gICAgICAgIHZhciBzaXplID0gIHRoaXMucmVuZGVyX29wdGlvbnMuZ2x5cGhfZm9udF9zaXplO1xuICAgICAgICB2YXIgZ2x5cGggPSBuZXcgVmV4LkZsb3cuR2x5cGgoZ2x5cGhfZGF0YS5jb2RlLCBzaXplKTtcblxuICAgICAgICAvLyBBZGQgdGhlIGdseXBoXG4gICAgICAgIHRoaXMuZ2x5cGhzLnB1c2goZ2x5cGgpO1xuXG4gICAgICAgIHRvdGFsX3dpZHRoICs9IGdseXBoX2RhdGEud2lkdGg7XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgLy8gU3RvcmUgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0XG4gICAgICB0aGlzLnNldFdpZHRoKHRvdGFsX3dpZHRoKTtcbiAgICAgIHRoaXMucHJlRm9ybWF0dGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBEcmF3IHRoZSBkeW5hbWljcyB0ZXh0IG9uIHRoZSByZW5kZXJpbmcgY29udGV4dFxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSB0aGlzLmdldEFic29sdXRlWCgpO1xuICAgICAgdmFyIHkgPSB0aGlzLnN0YXZlLmdldFlGb3JMaW5lKHRoaXMubGluZSArICgtMykpO1xuXG4gICAgICBMKFwiUmVuZGVyaW5nIER5bmFtaWNzOiBcIiwgdGhpcy5zZXF1ZW5jZSk7XG5cbiAgICAgIHZhciBsZXR0ZXJfeCA9IHg7XG4gICAgICB0aGlzLmdseXBocy5mb3JFYWNoKGZ1bmN0aW9uKGdseXBoLCBpbmRleCkge1xuICAgICAgICB2YXIgY3VycmVudF9sZXR0ZXIgPSB0aGlzLnNlcXVlbmNlW2luZGV4XTtcbiAgICAgICAgZ2x5cGgucmVuZGVyKHRoaXMuY29udGV4dCwgbGV0dGVyX3gsIHkpO1xuICAgICAgICBsZXR0ZXJfeCArPSBUZXh0RHluYW1pY3MuR0xZUEhTW2N1cnJlbnRfbGV0dGVyXS53aWR0aDtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFRleHREeW5hbWljcztcbn0pKCk7XG5WZXguRmxvdy5HcmFjZU5vdGUgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBHcmFjZU5vdGUgPSBmdW5jdGlvbihub3RlX3N0cnVjdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG5vdGVfc3RydWN0KTtcbiAgfTtcblxuICBWZXguSW5oZXJpdChHcmFjZU5vdGUsIFZleC5GbG93LlN0YXZlTm90ZSwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG5vdGVfc3RydWN0KSB7XG4gICAgICBHcmFjZU5vdGUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbm90ZV9zdHJ1Y3QpO1xuXG4gICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLmdseXBoX2ZvbnRfc2NhbGUgPSAyMjtcbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuc3RlbV9oZWlnaHQgPSAyMDtcbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuc3Ryb2tlX3B4ID0gMjtcbiAgICAgIHRoaXMuZ2x5cGguaGVhZF93aWR0aCA9IDY7XG5cbiAgICAgIHRoaXMuc2xhc2ggPSBub3RlX3N0cnVjdC5zbGFzaDtcbiAgICAgIHRoaXMuc2x1ciA9IHRydWU7XG5cbiAgICAgIHRoaXMuYnVpbGROb3RlSGVhZHMoKTtcblxuICAgICAgdGhpcy53aWR0aCA9IDM7XG4gICAgfSxcblxuICAgIGdldFN0ZW1FeHRlbnNpb246IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZ2x5cGggPSB0aGlzLmdldEdseXBoKCk7XG5cbiAgICAgIGlmICh0aGlzLnN0ZW1fZXh0ZW5zaW9uX292ZXJyaWRlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlbV9leHRlbnNpb25fb3ZlcnJpZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChnbHlwaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGVtRGlyZWN0aW9uKCkgPT09IDEgPyBnbHlwaC5ncmFjZW5vdGVfc3RlbV91cF9leHRlbnNpb24gOlxuICAgICAgICAgIGdseXBoLmdyYWNlbm90ZV9zdGVtX2Rvd25fZXh0ZW5zaW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ2dyYWNlbm90ZXMnOyB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oKXtcbiAgICAgIEdyYWNlTm90ZS5zdXBlcmNsYXNzLmRyYXcuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgc3RlbV9kaXJlY3Rpb24gPSB0aGlzLmdldFN0ZW1EaXJlY3Rpb24oKTtcblxuICAgICAgaWYgKHRoaXMuc2xhc2gpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHZhciB4ID0gdGhpcy5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldFlzKClbMF0gLSAodGhpcy5zdGVtLmdldEhlaWdodCgpIC8gMi44KTtcbiAgICAgICAgaWYgKHN0ZW1fZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgeCArPSAxO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4ICsgMTMsIHkgLSA5KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGVtX2RpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICB4IC09IDQ7XG4gICAgICAgICAgeSArPSAxO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4ICsgMTMsIHkgKyA5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIEdyYWNlTm90ZTtcbn0oKSk7XG5cbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgYEdyYWNlTm90ZUdyb3VwYCB3aGljaCBpcyB1c2VkIHRvIGZvcm1hdCBhbmRcbi8vIHJlbmRlciBncmFjZSBub3Rlcy5cblxuVmV4LkZsb3cuR3JhY2VOb3RlR3JvdXAgPSAoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gR3JhY2VOb3RlR3JvdXAoZ3JhY2Vfbm90ZXMsIGNvbmZpZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KGdyYWNlX25vdGVzLCBjb25maWcpO1xuICB9XG5cbiAgR3JhY2VOb3RlR3JvdXAuQ0FURUdPUlkgPSBcImdyYWNlbm90ZWdyb3Vwc1wiO1xuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93LkdyYWNlTm90ZUdyb3VwLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChHcmFjZU5vdGVHcm91cC5ERUJVRykgVmV4LkwoXCJWZXguRmxvdy5HcmFjZU5vdGVHcm91cFwiLCBhcmd1bWVudHMpOyB9XG5cbiAgLy8gQXJyYW5nZSBncm91cHMgaW5zaWRlIGEgYE1vZGlmaWVyQ29udGV4dGBcbiAgR3JhY2VOb3RlR3JvdXAuZm9ybWF0ID0gZnVuY3Rpb24oZ3JhY2Vub3RlX2dyb3Vwcywgc3RhdGUpIHtcbiAgICB2YXIgZ3JhY2Vub3RlX3NwYWNpbmcgPSA0O1xuXG4gICAgaWYgKCFncmFjZW5vdGVfZ3JvdXBzIHx8IGdyYWNlbm90ZV9ncm91cHMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgZ3JvdXBfbGlzdCA9IFtdO1xuICAgIHZhciBoYXNTdGF2ZSA9IGZhbHNlO1xuICAgIHZhciBwcmV2X25vdGUgPSBudWxsO1xuICAgIHZhciBzaGlmdEwgPSAwO1xuXG4gICAgdmFyIGksIGdyYWNlbm90ZV9ncm91cCwgcHJvcHNfdG1wO1xuICAgIGZvciAoaSA9IDA7IGkgPCBncmFjZW5vdGVfZ3JvdXBzLmxlbmd0aDsgKytpKSB7XG4gICAgICBncmFjZW5vdGVfZ3JvdXAgPSBncmFjZW5vdGVfZ3JvdXBzW2ldO1xuICAgICAgdmFyIG5vdGUgPSBncmFjZW5vdGVfZ3JvdXAuZ2V0Tm90ZSgpO1xuICAgICAgdmFyIHN0YXZlID0gbm90ZS5nZXRTdGF2ZSgpO1xuICAgICAgaWYgKG5vdGUgIT0gcHJldl9ub3RlKSB7XG4gICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIG5vdGVzIHRvIGdldCB0aGUgZGlzcGxhY2VkIHBpeGVsc1xuICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub3RlLmtleXMubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICAgIHByb3BzX3RtcCA9IG5vdGUuZ2V0S2V5UHJvcHMoKVtuXTtcbiAgICAgICAgICAgIHNoaWZ0TCA9IChwcm9wc190bXAuZGlzcGxhY2VkID8gbm90ZS5nZXRFeHRyYUxlZnRQeCgpIDogc2hpZnRMKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldl9ub3RlID0gbm90ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF2ZSAhPSBudWxsKSB7XG4gICAgICAgIGhhc1N0YXZlID0gdHJ1ZTtcbiAgICAgICAgZ3JvdXBfbGlzdC5wdXNoKHtzaGlmdDogc2hpZnRMLCBncmFjZW5vdGVfZ3JvdXA6IGdyYWNlbm90ZV9ncm91cH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXBfbGlzdC5wdXNoKHtzaGlmdDogc2hpZnRMLCBncmFjZW5vdGVfZ3JvdXA6IGdyYWNlbm90ZV9ncm91cCB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBmaXJzdCBub3RlIGxlZnQgc2hpZnQgaW4gY2FzZSBpdCBpcyBkaXNwbGFjZWRcbiAgICB2YXIgZ3JvdXBfc2hpZnQgPSBncm91cF9saXN0WzBdLnNoaWZ0O1xuICAgIHZhciBmb3JtYXRXaWR0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBfbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgZ3JhY2Vub3RlX2dyb3VwID0gZ3JvdXBfbGlzdFtpXS5ncmFjZW5vdGVfZ3JvdXA7XG4gICAgICBncmFjZW5vdGVfZ3JvdXAucHJlRm9ybWF0KCk7XG4gICAgICBmb3JtYXRXaWR0aCA9IGdyYWNlbm90ZV9ncm91cC5nZXRXaWR0aCgpICsgZ3JhY2Vub3RlX3NwYWNpbmc7XG4gICAgICBncm91cF9zaGlmdCA9IE1hdGgubWF4KGZvcm1hdFdpZHRoLCBncm91cF9zaGlmdCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGdyb3VwX2xpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGdyYWNlbm90ZV9ncm91cCA9IGdyb3VwX2xpc3RbaV0uZ3JhY2Vub3RlX2dyb3VwO1xuICAgICAgZm9ybWF0V2lkdGggPSBncmFjZW5vdGVfZ3JvdXAuZ2V0V2lkdGgoKSArIGdyYWNlbm90ZV9zcGFjaW5nO1xuICAgICAgZ3JhY2Vub3RlX2dyb3VwLnNldFNwYWNpbmdGcm9tTmV4dE1vZGlmaWVyKGdyb3VwX3NoaWZ0IC0gTWF0aC5taW4oZm9ybWF0V2lkdGgsIGdyb3VwX3NoaWZ0KSk7XG4gICAgfVxuXG4gICAgc3RhdGUubGVmdF9zaGlmdCArPSBncm91cF9zaGlmdDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICAvL1xuICAvLyBgR3JhY2VOb3RlR3JvdXBgIGluaGVyaXRzIGZyb20gYE1vZGlmaWVyYCBhbmQgaXMgcGxhY2VkIGluc2lkZSBhXG4gIC8vIGBNb2RpZmllckNvbnRleHRgLlxuICBWZXguSW5oZXJpdChHcmFjZU5vdGVHcm91cCwgVmV4LkZsb3cuTW9kaWZpZXIsIHtcbiAgICBpbml0OiBmdW5jdGlvbihncmFjZV9ub3Rlcywgc2hvd19zbHVyKSB7XG4gICAgICB2YXIgc3VwZXJjbGFzcyA9IEdyYWNlTm90ZUdyb3VwLnN1cGVyY2xhc3M7XG4gICAgICBzdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5ub3RlID0gbnVsbDtcbiAgICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLkxFRlQ7XG4gICAgICB0aGlzLmdyYWNlX25vdGVzID0gZ3JhY2Vfbm90ZXM7XG4gICAgICB0aGlzLndpZHRoID0gMDtcblxuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSBmYWxzZTtcblxuICAgICAgdGhpcy5zaG93X3NsdXIgPSBzaG93X3NsdXI7XG4gICAgICB0aGlzLnNsdXIgPSBudWxsO1xuXG4gICAgICB0aGlzLmZvcm1hdHRlciA9IG5ldyBWZXguRmxvdy5Gb3JtYXR0ZXIoKTtcbiAgICAgIHRoaXMudm9pY2UgPSBuZXcgVmV4LkZsb3cuVm9pY2Uoe1xuICAgICAgICBudW1fYmVhdHM6IDQsXG4gICAgICAgIGJlYXRfdmFsdWU6IDQsXG4gICAgICAgIHJlc29sdXRpb246IFZleC5GbG93LlJFU09MVVRJT05cbiAgICAgIH0pLnNldFN0cmljdChmYWxzZSk7XG5cbiAgICAgIHRoaXMudm9pY2UuYWRkVGlja2FibGVzKHRoaXMuZ3JhY2Vfbm90ZXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcHJlRm9ybWF0OiBmdW5jdGlvbigpe1xuICAgICAgaWYgKHRoaXMucHJlRm9ybWF0dGVkKSByZXR1cm47XG5cbiAgICAgIHRoaXMuZm9ybWF0dGVyLmpvaW5Wb2ljZXMoW3RoaXMudm9pY2VdKS5mb3JtYXQoW3RoaXMudm9pY2VdLCAwKTtcbiAgICAgIHRoaXMuc2V0V2lkdGgodGhpcy5mb3JtYXR0ZXIuZ2V0TWluVG90YWxXaWR0aCgpKTtcbiAgICAgIHRoaXMucHJlRm9ybWF0dGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgYmVhbU5vdGVzOiBmdW5jdGlvbigpe1xuICAgICAgaWYgKHRoaXMuZ3JhY2Vfbm90ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgYmVhbSA9IG5ldyBWZXguRmxvdy5CZWFtKHRoaXMuZ3JhY2Vfbm90ZXMpO1xuXG4gICAgICAgIGJlYW0ucmVuZGVyX29wdGlvbnMuYmVhbV93aWR0aCA9IDM7XG4gICAgICAgIGJlYW0ucmVuZGVyX29wdGlvbnMucGFydGlhbF9iZWFtX2xlbmd0aCA9IDQ7XG5cbiAgICAgICAgdGhpcy5iZWFtID0gYmVhbTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldE5vdGU6IGZ1bmN0aW9uKG5vdGUpIHtcbiAgICAgIHRoaXMubm90ZSA9IG5vdGU7XG4gICAgfSxcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpe1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH0sXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpICB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiTm9Db250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IEdyYWNlIG5vdGUgd2l0aG91dCBhIGNvbnRleHQuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm90ZSA9IHRoaXMuZ2V0Tm90ZSgpO1xuXG4gICAgICBMKFwiRHJhd2luZyBncmFjZSBub3RlIGdyb3VwIGZvcjpcIiwgbm90ZSk7XG5cbiAgICAgIGlmICghKG5vdGUgJiYgKHRoaXMuaW5kZXggIT09IG51bGwpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIk5vQXR0YWNoZWROb3RlXCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IGdyYWNlIG5vdGUgd2l0aG91dCBhIHBhcmVudCBub3RlIGFuZCBwYXJlbnQgbm90ZSBpbmRleC5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGFsaWduR3JhY2VOb3Rlc1dpdGhOb3RlKGdyYWNlX25vdGVzLCBub3RlLCBncm91cFdpZHRoKSB7XG4gICAgICAgIC8vIFNoaWZ0IG92ZXIgdGhlIHRpY2sgY29udGV4dHMgb2YgZWFjaCBub3RlXG4gICAgICAgIC8vIFNvIHRoYXQgdGggYWxpZ25lZCB3aXRoIHRoZSBub3RlXG4gICAgICAgIHZhciB0aWNrQ29udGV4dCA9IG5vdGUuZ2V0VGlja0NvbnRleHQoKTtcbiAgICAgICAgdmFyIGV4dHJhUHggPSB0aWNrQ29udGV4dC5nZXRFeHRyYVB4KCk7XG4gICAgICAgIHZhciB4ID0gdGlja0NvbnRleHQuZ2V0WCgpIC0gZXh0cmFQeC5sZWZ0IC0gZXh0cmFQeC5leHRyYUxlZnQgKyB0aGF0LmdldFNwYWNpbmdGcm9tTmV4dE1vZGlmaWVyKCk7XG4gICAgICAgIGdyYWNlX25vdGVzLmZvckVhY2goZnVuY3Rpb24oZ3JhY2VOb3RlKSB7XG4gICAgICAgICAgICB2YXIgdGlja19jb250ZXh0ID0gZ3JhY2VOb3RlLmdldFRpY2tDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgeF9vZmZzZXQgPSB0aWNrX2NvbnRleHQuZ2V0WCgpO1xuICAgICAgICAgICAgZ3JhY2VOb3RlLnNldFN0YXZlKG5vdGUuc3RhdmUpO1xuICAgICAgICAgICAgdGlja19jb250ZXh0LnNldFgoeCArIHhfb2Zmc2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGFsaWduR3JhY2VOb3Rlc1dpdGhOb3RlKHRoaXMuZ3JhY2Vfbm90ZXMsIG5vdGUsIHRoaXMud2lkdGgpO1xuXG4gICAgICAvLyBEcmF3IG5vdGVzXG4gICAgICB0aGlzLmdyYWNlX25vdGVzLmZvckVhY2goZnVuY3Rpb24oZ3JhY2VOb3RlKSB7XG4gICAgICAgIGdyYWNlTm90ZS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCkuZHJhdygpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIC8vIERyYXcgYmVhbVxuICAgICAgaWYgKHRoaXMuYmVhbSkge1xuICAgICAgICB0aGlzLmJlYW0uc2V0Q29udGV4dCh0aGlzLmNvbnRleHQpLmRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hvd19zbHVyKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhbmQgZHJhdyBzbHVyXG4gICAgICAgIHRoaXMuc2x1ciA9IG5ldyBWZXguRmxvdy5TdGF2ZVRpZSh7XG4gICAgICAgICAgbGFzdF9ub3RlOiB0aGlzLmdyYWNlX25vdGVzWzBdLFxuICAgICAgICAgIGZpcnN0X25vdGU6IG5vdGUsXG4gICAgICAgICAgZmlyc3RfaW5kaWNlczogWzBdLFxuICAgICAgICAgIGxhc3RfaW5kaWNlczogWzBdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2x1ci5yZW5kZXJfb3B0aW9ucy5jcDIgPSAxMjtcbiAgICAgICAgdGhpcy5zbHVyLnNldENvbnRleHQodGhpcy5jb250ZXh0KS5kcmF3KCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxucmV0dXJuIEdyYWNlTm90ZUdyb3VwO1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZleGZsb3ctZGVidWcuanMubWFwIiwiIyBWZXhUYWIgQXJ0aXN0XG4jIENvcHlyaWdodCAyMDEyIE1vaGl0IENoZXBwdWRpcmEgPG1vaGl0QG11dGhhbm5hLmNvbT5cbiNcbiMgVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIHRoZSBlbGVtZW50c1xuIyBwYXJzZWQgYnkgVmV4LkZsb3cuVmV4VGFiLlxuXG5cblZleCA9IHJlcXVpcmUgJ3ZleGZsb3cnXG5fID0gcmVxdWlyZSAndW5kZXJzY29yZSdcblxuY2xhc3MgQXJ0aXN0XG4gIEBERUJVRyA9IGZhbHNlXG4gIEwgPSAoYXJncy4uLikgLT4gY29uc29sZT8ubG9nKFwiKFZleC5GbG93LkFydGlzdClcIiwgYXJncy4uLikgaWYgQXJ0aXN0LkRFQlVHXG5cbiAgQE5PTE9HTyA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3I6IChAeCwgQHksIEB3aWR0aCwgb3B0aW9ucykgLT5cbiAgICBAb3B0aW9ucyA9XG4gICAgICBmb250X2ZhY2U6IFwiQXJpYWxcIlxuICAgICAgZm9udF9zaXplOiAxMFxuICAgICAgZm9udF9zdHlsZTogbnVsbFxuICAgICAgYm90dG9tX3NwYWNpbmc6IDIwICsgKGlmIEFydGlzdC5OT0xPR08gdGhlbiAwIGVsc2UgMTApXG4gICAgICB0YWJfc3RhdmVfbG93ZXJfc3BhY2luZzogMTBcbiAgICAgIG5vdGVfc3RhdmVfbG93ZXJfc3BhY2luZzogMFxuICAgICAgc2NhbGU6IDEuMFxuICAgIF8uZXh0ZW5kKEBvcHRpb25zLCBvcHRpb25zKSBpZiBvcHRpb25zP1xuICAgIEByZXNldCgpXG5cbiAgcmVzZXQ6IC0+XG4gICAgQHR1bmluZyA9IG5ldyBWZXguRmxvdy5UdW5pbmcoKVxuICAgIEBrZXlfbWFuYWdlciA9IG5ldyBWZXguRmxvdy5LZXlNYW5hZ2VyKFwiQ1wiKVxuICAgIEBtdXNpY19hcGkgPSBuZXcgVmV4LkZsb3cuTXVzaWMoKVxuXG4gICAgIyBVc2VyIGN1c3RvbWl6YXRpb25zXG4gICAgQGN1c3RvbWl6YXRpb25zID1cbiAgICAgIFwiZm9udC1zaXplXCI6IEBvcHRpb25zLmZvbnRfc2l6ZVxuICAgICAgXCJmb250LWZhY2VcIjogQG9wdGlvbnMuZm9udF9mYWNlXG4gICAgICBcImZvbnQtc3R5bGVcIjogQG9wdGlvbnMuZm9udF9zdHlsZVxuICAgICAgXCJhbm5vdGF0aW9uLXBvc2l0aW9uXCI6IFwiYm90dG9tXCJcbiAgICAgIFwic2NhbGVcIjogQG9wdGlvbnMuc2NhbGVcbiAgICAgIFwid2lkdGhcIjogQHdpZHRoXG4gICAgICBcInN0YXZlLWRpc3RhbmNlXCI6IDBcbiAgICAgIFwic3BhY2VcIjogMFxuICAgICAgXCJwbGF5ZXJcIjogXCJmYWxzZVwiXG4gICAgICBcInRlbXBvXCI6IDEyMFxuICAgICAgXCJpbnN0cnVtZW50XCI6IFwiYWNvdXN0aWNfZ3JhbmRfcGlhbm9cIlxuICAgICAgXCJhY2NpZGVudGFsc1wiOiBcInN0YW5kYXJkXCIgICMgc3RhbmRhcmQgLyBjYXV0aW9uYXJ5XG4gICAgICBcInRhYi1zdGVtc1wiOiBcImZhbHNlXCJcbiAgICAgIFwidGFiLXN0ZW0tZGlyZWN0aW9uXCI6IFwidXBcIlxuICAgICAgXCJiZWFtLXJlc3RzXCI6IFwidHJ1ZVwiXG4gICAgICBcImJlYW0tc3RlbWxldHNcIjogXCJ0cnVlXCJcbiAgICAgIFwiYmVhbS1taWRkbGUtb25seVwiOiBcImZhbHNlXCJcbiAgICAgIFwiY29ubmVjdG9yLXNwYWNlXCI6IDBcblxuICAgICMgR2VuZXJhdGVkIGVsZW1lbnRzXG4gICAgQHN0YXZlcyA9IFtdXG4gICAgQHRhYl9hcnRpY3VsYXRpb25zID0gW11cbiAgICBAc3RhdmVfYXJ0aWN1bGF0aW9ucyA9IFtdXG5cbiAgICAjIFZvaWNlcyBmb3IgcGxheWVyXG4gICAgQHBsYXllcl92b2ljZXMgPSBbXVxuXG4gICAgIyBDdXJyZW50IHN0YXRlXG4gICAgQGxhc3RfeSA9IEB5XG4gICAgQGN1cnJlbnRfZHVyYXRpb24gPSBcInFcIlxuICAgIEBjdXJyZW50X2NsZWYgPSBcInRyZWJsZVwiXG4gICAgQGN1cnJlbnRfYmVuZHMgPSB7fVxuICAgIEBjdXJyZW50X29jdGF2ZV9zaGlmdCA9IDBcbiAgICBAYmVuZF9zdGFydF9pbmRleCA9IG51bGxcbiAgICBAYmVuZF9zdGFydF9zdHJpbmdzID0gbnVsbFxuICAgIEByZW5kZXJlZCA9IGZhbHNlXG4gICAgQHJlbmRlcmVyX2NvbnRleHQgPSBudWxsXG5cbiAgYXR0YWNoUGxheWVyOiAocGxheWVyKSAtPlxuICAgIGlmICFAcGxheWVyXG4gICAgICBjb25zb2xlLmxvZyBcIkF0dGFjaGluZyBwbGF5ZXJcIlxuICAgICAgQHBsYXllciA9IHBsYXllclxuXG4gIHNldE9wdGlvbnM6IChvcHRpb25zKSAtPlxuICAgIEwgXCJzZXRPcHRpb25zOiBcIiwgb3B0aW9uc1xuICAgICMgU2V0IEBjdXN0b21pemF0aW9uc1xuICAgIHZhbGlkX29wdGlvbnMgPSBfLmtleXMoQGN1c3RvbWl6YXRpb25zKVxuICAgIGZvciBrLCB2IG9mIG9wdGlvbnNcbiAgICAgIGlmIGsgaW4gdmFsaWRfb3B0aW9uc1xuICAgICAgICBAY3VzdG9taXphdGlvbnNba10gPSB2XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkFydGlzdEVycm9yXCIsIFwiSW52YWxpZCBvcHRpb24gJyN7a30nXCIpXG5cbiAgICBAbGFzdF95ICs9IHBhcnNlSW50KEBjdXN0b21pemF0aW9ucy5zcGFjZSwgMTApXG4gICAgQGxhc3RfeSArPSAxIGlmIEBjdXN0b21pemF0aW9ucy5wbGF5ZXIgaXMgXCJ0cnVlXCJcblxuICBnZXRQbGF5ZXJEYXRhOiAtPlxuICAgIHZvaWNlczogQHBsYXllcl92b2ljZXNcbiAgICBjb250ZXh0OiBAcmVuZGVyZXJfY29udGV4dFxuICAgIHNjYWxlOiBAY3VzdG9taXphdGlvbnMuc2NhbGVcblxuICBwYXJzZUJvb2wgPSAoc3RyKSAtPlxuICAgIHJldHVybiAoc3RyID09IFwidHJ1ZVwiKVxuXG4gIGZvcm1hdEFuZFJlbmRlciA9IChjdHgsIHRhYiwgc2NvcmUsIHRleHRfbm90ZXMsIGN1c3RvbWl6YXRpb25zLCBvcHRpb25zKSAtPlxuICAgIHRhYl9zdGF2ZSA9IHRhYi5zdGF2ZSBpZiB0YWI/XG4gICAgc2NvcmVfc3RhdmUgPSBzY29yZS5zdGF2ZSBpZiBzY29yZT9cblxuICAgIHRhYl92b2ljZXMgPSBbXVxuICAgIHNjb3JlX3ZvaWNlcyA9IFtdXG4gICAgdGV4dF92b2ljZXMgPSBbXVxuICAgIGJlYW1zID0gW11cbiAgICBmb3JtYXRfc3RhdmUgPSBudWxsXG4gICAgdGV4dF9zdGF2ZSA9IG51bGxcblxuICAgIGJlYW1fY29uZmlnID1cbiAgICAgIGJlYW1fcmVzdHM6IHBhcnNlQm9vbChjdXN0b21pemF0aW9uc1tcImJlYW0tcmVzdHNcIl0pXG4gICAgICBzaG93X3N0ZW1sZXRzOiBwYXJzZUJvb2woY3VzdG9taXphdGlvbnNbXCJiZWFtLXN0ZW1sZXRzXCJdKVxuICAgICAgYmVhbV9taWRkbGVfb25seTogcGFyc2VCb29sKGN1c3RvbWl6YXRpb25zW1wiYmVhbS1taWRkbGUtb25seVwiXSlcbiAgICAgIGdyb3Vwczogb3B0aW9ucy5iZWFtX2dyb3Vwc1xuXG4gICAgaWYgdGFiP1xuICAgICAgbXVsdGlfdm9pY2UgPSBpZiAodGFiLnZvaWNlcy5sZW5ndGggPiAxKSB0aGVuIHRydWUgZWxzZSBmYWxzZVxuICAgICAgZm9yIG5vdGVzLCBpIGluIHRhYi52b2ljZXNcbiAgICAgICAgY29udGludWUgaWYgXy5pc0VtcHR5KG5vdGVzKVxuICAgICAgICBfLmVhY2gobm90ZXMsIChub3RlKSAtPiBub3RlLnNldFN0YXZlKHRhYl9zdGF2ZSkpXG4gICAgICAgIHZvaWNlID0gbmV3IFZleC5GbG93LlZvaWNlKFZleC5GbG93LlRJTUU0XzQpLlxuICAgICAgICAgIHNldE1vZGUoVmV4LkZsb3cuVm9pY2UuTW9kZS5TT0ZUKVxuICAgICAgICB2b2ljZS5hZGRUaWNrYWJsZXMgbm90ZXNcbiAgICAgICAgdGFiX3ZvaWNlcy5wdXNoIHZvaWNlXG5cbiAgICAgICAgaWYgY3VzdG9taXphdGlvbnNbXCJ0YWItc3RlbXNcIl0gPT0gXCJ0cnVlXCJcbiAgICAgICAgICBpZiBtdWx0aV92b2ljZVxuICAgICAgICAgICAgYmVhbV9jb25maWcuc3RlbV9kaXJlY3Rpb24gPSBpZiBpID09IDAgdGhlbiAxIGVsc2UgLTFcbiAgICAgICAgICBlbHNlXG4gICAgICAgICAgICBiZWFtX2NvbmZpZy5zdGVtX2RpcmVjdGlvbiA9IGlmIGN1c3RvbWl6YXRpb25zW1widGFiLXN0ZW0tZGlyZWN0aW9uXCJdID09IFwiZG93blwiIHRoZW4gLTEgZWxzZSAxXG5cbiAgICAgICAgICBiZWFtX2NvbmZpZy5iZWFtX3Jlc3RzID0gZmFsc2VcbiAgICAgICAgICBiZWFtcyA9IGJlYW1zLmNvbmNhdChWZXguRmxvdy5CZWFtLmdlbmVyYXRlQmVhbXModm9pY2UuZ2V0VGlja2FibGVzKCksIGJlYW1fY29uZmlnKSlcblxuICAgICAgZm9ybWF0X3N0YXZlID0gdGFiX3N0YXZlXG4gICAgICB0ZXh0X3N0YXZlID0gdGFiX3N0YXZlXG5cbiAgICBiZWFtX2NvbmZpZy5iZWFtX3Jlc3RzID0gcGFyc2VCb29sKGN1c3RvbWl6YXRpb25zW1wiYmVhbS1yZXN0c1wiXSlcblxuICAgIGlmIHNjb3JlP1xuICAgICAgbXVsdGlfdm9pY2UgPSBpZiAoc2NvcmUudm9pY2VzLmxlbmd0aCA+IDEpIHRoZW4gdHJ1ZSBlbHNlIGZhbHNlXG4gICAgICBmb3Igbm90ZXMsIGkgaW4gc2NvcmUudm9pY2VzXG4gICAgICAgIGNvbnRpbnVlIGlmIF8uaXNFbXB0eShub3RlcylcbiAgICAgICAgc3RlbV9kaXJlY3Rpb24gPSBpZiBpID09IDAgdGhlbiAxIGVsc2UgLTFcbiAgICAgICAgXy5lYWNoKG5vdGVzLCAobm90ZSkgLT4gbm90ZS5zZXRTdGF2ZShzY29yZV9zdGF2ZSkpXG5cbiAgICAgICAgdm9pY2UgPSBuZXcgVmV4LkZsb3cuVm9pY2UoVmV4LkZsb3cuVElNRTRfNCkuXG4gICAgICAgICAgc2V0TW9kZShWZXguRmxvdy5Wb2ljZS5Nb2RlLlNPRlQpXG4gICAgICAgIHZvaWNlLmFkZFRpY2thYmxlcyBub3Rlc1xuICAgICAgICBzY29yZV92b2ljZXMucHVzaCB2b2ljZVxuICAgICAgICBpZiBtdWx0aV92b2ljZVxuICAgICAgICAgIGJlYW1fY29uZmlnLnN0ZW1fZGlyZWN0aW9uID0gc3RlbV9kaXJlY3Rpb25cbiAgICAgICAgICBiZWFtcyA9IGJlYW1zLmNvbmNhdChWZXguRmxvdy5CZWFtLmdlbmVyYXRlQmVhbXMobm90ZXMsIGJlYW1fY29uZmlnKSlcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJlYW1fY29uZmlnLnN0ZW1fZGlyZWN0aW9uID0gbnVsbFxuICAgICAgICAgIGJlYW1zID0gYmVhbXMuY29uY2F0KFZleC5GbG93LkJlYW0uZ2VuZXJhdGVCZWFtcyhub3RlcywgYmVhbV9jb25maWcpKVxuXG4gICAgICBmb3JtYXRfc3RhdmUgPSBzY29yZV9zdGF2ZVxuICAgICAgdGV4dF9zdGF2ZSA9IHNjb3JlX3N0YXZlXG5cbiAgICBmb3Igbm90ZXMgaW4gdGV4dF9ub3Rlc1xuICAgICAgY29udGludWUgaWYgXy5pc0VtcHR5KG5vdGVzKVxuICAgICAgXy5lYWNoKG5vdGVzLCAodm9pY2UpIC0+IHZvaWNlLnNldFN0YXZlKHRleHRfc3RhdmUpKVxuICAgICAgdm9pY2UgPSBuZXcgVmV4LkZsb3cuVm9pY2UoVmV4LkZsb3cuVElNRTRfNCkuXG4gICAgICAgICAgc2V0TW9kZShWZXguRmxvdy5Wb2ljZS5Nb2RlLlNPRlQpXG4gICAgICB2b2ljZS5hZGRUaWNrYWJsZXMgbm90ZXNcbiAgICAgIHRleHRfdm9pY2VzLnB1c2ggdm9pY2VcblxuICAgIGlmIGZvcm1hdF9zdGF2ZT9cbiAgICAgIGZvcm1hdF92b2ljZXMgPSBbXVxuICAgICAgZm9ybWF0dGVyID0gbmV3IFZleC5GbG93LkZvcm1hdHRlcigpXG4gICAgICBhbGlnbl9yZXN0cyA9IGZhbHNlXG5cbiAgICAgIGlmIHRhYj9cbiAgICAgICAgZm9ybWF0dGVyLmpvaW5Wb2ljZXModGFiX3ZvaWNlcykgdW5sZXNzIF8uaXNFbXB0eSh0YWJfdm9pY2VzKVxuICAgICAgICBmb3JtYXRfdm9pY2VzID0gdGFiX3ZvaWNlc1xuXG4gICAgICBpZiBzY29yZT9cbiAgICAgICAgZm9ybWF0dGVyLmpvaW5Wb2ljZXMoc2NvcmVfdm9pY2VzKSB1bmxlc3MgXy5pc0VtcHR5KHNjb3JlX3ZvaWNlcylcbiAgICAgICAgZm9ybWF0X3ZvaWNlcyA9IGZvcm1hdF92b2ljZXMuY29uY2F0KHNjb3JlX3ZvaWNlcylcbiAgICAgICAgYWxpZ25fcmVzdHMgPSB0cnVlIGlmIHNjb3JlX3ZvaWNlcy5sZW5ndGggPiAxXG5cbiAgICAgIGlmIG5vdCBfLmlzRW1wdHkodGV4dF9ub3RlcykgYW5kIG5vdCBfLmlzRW1wdHkodGV4dF92b2ljZXMpXG4gICAgICAgIGZvcm1hdHRlci5qb2luVm9pY2VzKHRleHRfdm9pY2VzKVxuICAgICAgICBmb3JtYXRfdm9pY2VzID0gZm9ybWF0X3ZvaWNlcy5jb25jYXQodGV4dF92b2ljZXMpXG5cbiAgICAgIGZvcm1hdHRlci5mb3JtYXRUb1N0YXZlKGZvcm1hdF92b2ljZXMsIGZvcm1hdF9zdGF2ZSwge2FsaWduX3Jlc3RzOiBhbGlnbl9yZXN0c30pIHVubGVzcyBfLmlzRW1wdHkoZm9ybWF0X3ZvaWNlcylcblxuICAgICAgXy5lYWNoKHRhYl92b2ljZXMsICh2b2ljZSkgLT4gdm9pY2UuZHJhdyhjdHgsIHRhYl9zdGF2ZSkpIGlmIHRhYj9cbiAgICAgIF8uZWFjaChzY29yZV92b2ljZXMsICh2b2ljZSkgLT4gdm9pY2UuZHJhdyhjdHgsIHNjb3JlX3N0YXZlKSkgaWYgc2NvcmU/XG4gICAgICBfLmVhY2goYmVhbXMsIChiZWFtKSAtPiBiZWFtLnNldENvbnRleHQoY3R4KS5kcmF3KCkpXG4gICAgICBfLmVhY2godGV4dF92b2ljZXMsICh2b2ljZSkgLT4gdm9pY2UuZHJhdyhjdHgsIHRleHRfc3RhdmUpKSBpZiBub3QgXy5pc0VtcHR5KHRleHRfbm90ZXMpXG5cbiAgICAgIGlmIHRhYj8gYW5kIHNjb3JlP1xuICAgICAgICAobmV3IFZleC5GbG93LlN0YXZlQ29ubmVjdG9yKHNjb3JlLnN0YXZlLCB0YWIuc3RhdmUpKS5zZXRDb250ZXh0KGN0eCkuZHJhdygpXG5cbiAgICAgIGlmIHNjb3JlPyB0aGVuIHNjb3JlX3ZvaWNlcyBlbHNlIHRhYl92b2ljZXNcblxuICByZW5kZXI6IChyZW5kZXJlcikgLT5cbiAgICBMIFwiUmVuZGVyOiBcIiwgQG9wdGlvbnNcbiAgICBAY2xvc2VCZW5kcygpXG4gICAgcmVuZGVyZXIucmVzaXplKEBjdXN0b21pemF0aW9ucy53aWR0aCAqIEBjdXN0b21pemF0aW9ucy5zY2FsZSxcbiAgICAgICAgKEBsYXN0X3kgKyBAb3B0aW9ucy5ib3R0b21fc3BhY2luZykgKiBAY3VzdG9taXphdGlvbnMuc2NhbGUpXG4gICAgY3R4ID0gcmVuZGVyZXIuZ2V0Q29udGV4dCgpXG4gICAgY3R4LnNjYWxlKEBjdXN0b21pemF0aW9ucy5zY2FsZSwgQGN1c3RvbWl6YXRpb25zLnNjYWxlKVxuICAgIGN0eC5jbGVhcigpXG4gICAgY3R4LnNldEZvbnQoQG9wdGlvbnMuZm9udF9mYWNlLCBAb3B0aW9ucy5mb250X3NpemUsIFwiXCIpXG5cbiAgICBAcmVuZGVyZXJfY29udGV4dCA9IGN0eFxuXG4gICAgc2V0QmFyID0gKHN0YXZlLCBub3RlcykgLT5cbiAgICAgIGxhc3Rfbm90ZSA9IF8ubGFzdChub3RlcylcbiAgICAgIGlmIGxhc3Rfbm90ZSBpbnN0YW5jZW9mIFZleC5GbG93LkJhck5vdGVcbiAgICAgICAgbm90ZXMucG9wKClcbiAgICAgICAgc3RhdmUuc2V0RW5kQmFyVHlwZShsYXN0X25vdGUuZ2V0VHlwZSgpKVxuXG4gICAgZm9yIHN0YXZlIGluIEBzdGF2ZXNcbiAgICAgIEwgXCJSZW5kZXJpbmcgc3RhdmVzLlwiXG4gICAgICAjIElmIHRoZSBsYXN0IG5vdGUgaXMgYSBiYXIsIHRoZW4gcmVtb3ZlIGl0IGFuZCByZW5kZXIgaXQgYXMgYSBzdGF2ZSBtb2RpZmllci5cbiAgICAgIHNldEJhcihzdGF2ZS50YWIsIHN0YXZlLnRhYl9ub3RlcykgaWYgc3RhdmUudGFiP1xuICAgICAgc2V0QmFyKHN0YXZlLm5vdGUsIHN0YXZlLm5vdGVfbm90ZXMpIGlmIHN0YXZlLm5vdGU/XG5cbiAgICAgIHN0YXZlLnRhYi5zZXRDb250ZXh0KGN0eCkuZHJhdygpIGlmIHN0YXZlLnRhYj9cbiAgICAgIHN0YXZlLm5vdGUuc2V0Q29udGV4dChjdHgpLmRyYXcoKSBpZiBzdGF2ZS5ub3RlP1xuXG4gICAgICBzdGF2ZS50YWJfdm9pY2VzLnB1c2goc3RhdmUudGFiX25vdGVzKVxuICAgICAgc3RhdmUubm90ZV92b2ljZXMucHVzaChzdGF2ZS5ub3RlX25vdGVzKVxuXG4gICAgICB2b2ljZXMgPSBmb3JtYXRBbmRSZW5kZXIoY3R4LFxuICAgICAgICAgICAgICAgICAgICAgIGlmIHN0YXZlLnRhYj8gdGhlbiB7c3RhdmU6IHN0YXZlLnRhYiwgdm9pY2VzOiBzdGF2ZS50YWJfdm9pY2VzfSBlbHNlIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgaWYgc3RhdmUubm90ZT8gdGhlbiB7c3RhdmU6IHN0YXZlLm5vdGUsIHZvaWNlczogc3RhdmUubm90ZV92b2ljZXN9IGVsc2UgbnVsbCxcbiAgICAgICAgICAgICAgICAgICAgICBzdGF2ZS50ZXh0X3ZvaWNlcyxcbiAgICAgICAgICAgICAgICAgICAgICBAY3VzdG9taXphdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAge2JlYW1fZ3JvdXBzOiBzdGF2ZS5iZWFtX2dyb3Vwc30pXG5cbiAgICAgIEBwbGF5ZXJfdm9pY2VzLnB1c2godm9pY2VzKVxuXG4gICAgTCBcIlJlbmRlcmluZyB0YWIgYXJ0aWN1bGF0aW9ucy5cIlxuICAgIGZvciBhcnRpY3VsYXRpb24gaW4gQHRhYl9hcnRpY3VsYXRpb25zXG4gICAgICBhcnRpY3VsYXRpb24uc2V0Q29udGV4dChjdHgpLmRyYXcoKVxuXG4gICAgTCBcIlJlbmRlcmluZyBub3RlIGFydGljdWxhdGlvbnMuXCJcbiAgICBmb3IgYXJ0aWN1bGF0aW9uIGluIEBzdGF2ZV9hcnRpY3VsYXRpb25zXG4gICAgICBhcnRpY3VsYXRpb24uc2V0Q29udGV4dChjdHgpLmRyYXcoKVxuXG4gICAgaWYgQHBsYXllcj9cbiAgICAgIGlmIEBjdXN0b21pemF0aW9ucy5wbGF5ZXIgaXMgXCJ0cnVlXCJcbiAgICAgICAgQHBsYXllci5zZXRUZW1wbyhwYXJzZUludChAY3VzdG9taXphdGlvbnMudGVtcG8sIDEwKSlcbiAgICAgICAgQHBsYXllci5zZXRJbnN0cnVtZW50KEBjdXN0b21pemF0aW9ucy5pbnN0cnVtZW50KVxuICAgICAgICBAcGxheWVyLnJlbmRlcigpXG4gICAgICBlbHNlXG4gICAgICAgIEBwbGF5ZXIucmVtb3ZlQ29udHJvbHMoKVxuICAgIEByZW5kZXJlZCA9IHRydWVcblxuICAgIHVubGVzcyBBcnRpc3QuTk9MT0dPXG4gICAgICBMT0dPID0gXCJ2ZXhmbG93LmNvbVwiXG4gICAgICB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChMT0dPKS53aWR0aFxuICAgICAgY3R4LnNhdmUoKVxuICAgICAgY3R4LnNldEZvbnQoXCJUaW1lc1wiLCAxMCwgXCJpdGFsaWNcIilcbiAgICAgIGN0eC5maWxsVGV4dChMT0dPLCAoQGN1c3RvbWl6YXRpb25zLndpZHRoIC0gd2lkdGgpIC8gMiwgQGxhc3RfeSArIDI1KVxuICAgICAgY3R4LnJlc3RvcmUoKVxuXG4gIGlzUmVuZGVyZWQ6IC0+IEByZW5kZXJlZFxuXG4gIGRyYXc6IChyZW5kZXJlcikgLT4gQHJlbmRlciByZW5kZXJlclxuXG4gICMgR2l2ZW4gYSBmcmV0L3N0cmluZyBwYWlyLCByZXR1cm5zIGEgbm90ZSwgb2N0YXZlLCBhbmQgcmVxdWlyZWQgYWNjaWRlbnRhbHNcbiAgIyBiYXNlZCBvbiBjdXJyZW50IGd1aXRhciB0dW5pbmcgYW5kIHN0YXZlIGtleS4gVGhlIGFjY2lkZW50YWxzIG1heSBiZSBkaWZmZXJlbnRcbiAgIyBmb3IgcmVwZWF0cyBvZiB0aGUgc2FtZSBub3RlcyBiZWNhdXNlIHRoZXkgZ2V0IHNldCAob3IgY2FuY2VsbGVkKSBieSB0aGUgS2V5XG4gICMgTWFuYWdlci5cbiAgZ2V0Tm90ZUZvckZyZXQ6IChmcmV0LCBzdHJpbmcpIC0+XG4gICAgc3BlYyA9IEB0dW5pbmcuZ2V0Tm90ZUZvckZyZXQoZnJldCwgc3RyaW5nKVxuICAgIHNwZWNfcHJvcHMgPSBWZXguRmxvdy5rZXlQcm9wZXJ0aWVzKHNwZWMpXG5cbiAgICBzZWxlY3RlZF9ub3RlID0gQGtleV9tYW5hZ2VyLnNlbGVjdE5vdGUoc3BlY19wcm9wcy5rZXkpXG4gICAgYWNjaWRlbnRhbCA9IG51bGxcblxuICAgICMgRG8gd2UgbmVlZCB0byBzcGVjaWZ5IGFuIGV4cGxpY2l0IGFjY2lkZW50YWw/XG4gICAgc3dpdGNoIEBjdXN0b21pemF0aW9ucy5hY2NpZGVudGFsc1xuICAgICAgd2hlbiBcInN0YW5kYXJkXCJcbiAgICAgICAgaWYgc2VsZWN0ZWRfbm90ZS5jaGFuZ2VcbiAgICAgICAgICBhY2NpZGVudGFsID0gaWYgc2VsZWN0ZWRfbm90ZS5hY2NpZGVudGFsPyB0aGVuIHNlbGVjdGVkX25vdGUuYWNjaWRlbnRhbCBlbHNlIFwiblwiXG4gICAgICB3aGVuIFwiY2F1dGlvbmFyeVwiXG4gICAgICAgIGlmIHNlbGVjdGVkX25vdGUuY2hhbmdlXG4gICAgICAgICAgYWNjaWRlbnRhbCA9IGlmIHNlbGVjdGVkX25vdGUuYWNjaWRlbnRhbD8gdGhlbiBzZWxlY3RlZF9ub3RlLmFjY2lkZW50YWwgZWxzZSBcIm5cIlxuICAgICAgICBlbHNlXG4gICAgICAgICAgYWNjaWRlbnRhbCA9IGlmIHNlbGVjdGVkX25vdGUuYWNjaWRlbnRhbD8gdGhlbiBzZWxlY3RlZF9ub3RlLmFjY2lkZW50YWwgKyBcIl9jXCJcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQXJ0aXN0RXJyb3JcIiwgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gJ2FjY2lkZW50YWxzJzogI3tAY3VzdG9taXphdGlvbnMuYWNjaWRlbnRhbHN9XCIpXG5cbiAgICBuZXdfbm90ZSA9IHNlbGVjdGVkX25vdGUubm90ZVxuICAgIG5ld19vY3RhdmUgPSBzcGVjX3Byb3BzLm9jdGF2ZVxuXG4gICAgIyBUT0RPKDB4ZmUpOiBUaGlzIGxvZ2ljIHNob3VsZCBwcm9iYWJseSBiZSBpbiB0aGUgS2V5TWFuYWdlciBjb2RlXG4gICAgb2xkX3Jvb3QgPSBAbXVzaWNfYXBpLmdldE5vdGVQYXJ0cyhzcGVjX3Byb3BzLmtleSkucm9vdFxuICAgIG5ld19yb290ID0gQG11c2ljX2FwaS5nZXROb3RlUGFydHMoc2VsZWN0ZWRfbm90ZS5ub3RlKS5yb290XG5cbiAgICAjIEZpZ3VyZSBvdXQgaWYgdGhlcmUncyBhbiBvY3RhdmUgc2hpZnQgYmFzZWQgb24gd2hhdCB0aGUgS2V5XG4gICAgIyBNYW5hZ2VyIGp1c3QgdG9sZCB1cyBhYm91dCB0aGUgbm90ZS5cbiAgICBpZiBuZXdfcm9vdCA9PSBcImJcIiBhbmQgb2xkX3Jvb3QgPT0gXCJjXCJcbiAgICAgIG5ld19vY3RhdmUtLVxuICAgIGVsc2UgaWYgbmV3X3Jvb3QgPT0gXCJjXCIgYW5kIG9sZF9yb290ID09IFwiYlwiXG4gICAgICBuZXdfb2N0YXZlKytcblxuICAgIHJldHVybiBbbmV3X25vdGUsIG5ld19vY3RhdmUsIGFjY2lkZW50YWxdXG5cbiAgZ2V0Tm90ZUZvckFCQzogKGFiYywgc3RyaW5nKSAtPlxuICAgIGtleSA9IGFiYy5rZXlcbiAgICBvY3RhdmUgPSBzdHJpbmdcbiAgICBhY2NpZGVudGFsID0gYWJjLmFjY2lkZW50YWxcbiAgICBhY2NpZGVudGFsICs9IFwiXyN7YWJjLmFjY2lkZW50YWxfdHlwZX1cIiBpZiBhYmMuYWNjaWRlbnRhbF90eXBlP1xuICAgIHJldHVybiBba2V5LCBvY3RhdmUsIGFjY2lkZW50YWxdXG5cbiAgYWRkU3RhdmVOb3RlOiAobm90ZV9wYXJhbXMpIC0+XG4gICAgcGFyYW1zID1cbiAgICAgIGlzX3Jlc3Q6IGZhbHNlXG4gICAgICBwbGF5X25vdGU6IG51bGxcblxuICAgIF8uZXh0ZW5kKHBhcmFtcywgbm90ZV9wYXJhbXMpXG4gICAgc3RhdmVfbm90ZXMgPSBfLmxhc3QoQHN0YXZlcykubm90ZV9ub3Rlc1xuICAgIHN0YXZlX25vdGUgPSBuZXcgVmV4LkZsb3cuU3RhdmVOb3RlKHtcbiAgICAgIGtleXM6IHBhcmFtcy5zcGVjXG4gICAgICBkdXJhdGlvbjogQGN1cnJlbnRfZHVyYXRpb24gKyAoaWYgcGFyYW1zLmlzX3Jlc3QgdGhlbiBcInJcIiBlbHNlIFwiXCIpXG4gICAgICBjbGVmOiBpZiBwYXJhbXMuaXNfcmVzdCB0aGVuIFwidHJlYmxlXCIgZWxzZSBAY3VycmVudF9jbGVmXG4gICAgICBhdXRvX3N0ZW06IGlmIHBhcmFtcy5pc19yZXN0IHRoZW4gZmFsc2UgZWxzZSB0cnVlXG4gICAgfSlcbiAgICBmb3IgYWNjLCBpbmRleCBpbiBwYXJhbXMuYWNjaWRlbnRhbHNcbiAgICAgIGlmIGFjYz9cbiAgICAgICAgcGFydHMgPSBhY2Muc3BsaXQoXCJfXCIpXG4gICAgICAgIG5ld19hY2NpZGVudGFsID0gbmV3IFZleC5GbG93LkFjY2lkZW50YWwocGFydHNbMF0pXG5cbiAgICAgICAgaWYgcGFydHMubGVuZ3RoID4gMSBhbmQgcGFydHNbMV0gPT0gXCJjXCJcbiAgICAgICAgICBuZXdfYWNjaWRlbnRhbC5zZXRBc0NhdXRpb25hcnkoKVxuXG4gICAgICAgIHN0YXZlX25vdGUuYWRkQWNjaWRlbnRhbChpbmRleCwgbmV3X2FjY2lkZW50YWwpXG5cbiAgICBpZiBAY3VycmVudF9kdXJhdGlvbltAY3VycmVudF9kdXJhdGlvbi5sZW5ndGggLSAxXSA9PSBcImRcIlxuICAgICAgc3RhdmVfbm90ZS5hZGREb3RUb0FsbCgpXG5cbiAgICBzdGF2ZV9ub3RlLnNldFBsYXlOb3RlKHBhcmFtcy5wbGF5X25vdGUpIGlmIHBhcmFtcy5wbGF5X25vdGU/XG4gICAgc3RhdmVfbm90ZXMucHVzaCBzdGF2ZV9ub3RlXG5cbiAgYWRkVGFiTm90ZTogKHNwZWMsIHBsYXlfbm90ZT1udWxsKSAtPlxuICAgIHRhYl9ub3RlcyA9IF8ubGFzdChAc3RhdmVzKS50YWJfbm90ZXNcbiAgICBuZXdfdGFiX25vdGUgPSBuZXcgVmV4LkZsb3cuVGFiTm90ZSh7XG4gICAgICBwb3NpdGlvbnM6IHNwZWMsXG4gICAgICBkdXJhdGlvbjogQGN1cnJlbnRfZHVyYXRpb25cbiAgICAgIH0sIChAY3VzdG9taXphdGlvbnNbXCJ0YWItc3RlbXNcIl0gPT0gXCJ0cnVlXCIpXG4gICAgKVxuICAgIG5ld190YWJfbm90ZS5zZXRQbGF5Tm90ZShwbGF5X25vdGUpIGlmIHBsYXlfbm90ZT9cbiAgICB0YWJfbm90ZXMucHVzaCBuZXdfdGFiX25vdGVcblxuICAgIGlmIEBjdXJyZW50X2R1cmF0aW9uW0BjdXJyZW50X2R1cmF0aW9uLmxlbmd0aCAtIDFdID09IFwiZFwiXG4gICAgICBuZXdfdGFiX25vdGUuYWRkRG90KClcblxuICBtYWtlRHVyYXRpb24gPSAodGltZSwgZG90KSAtPiB0aW1lICsgKGlmIGRvdCB0aGVuIFwiZFwiIGVsc2UgXCJcIilcbiAgc2V0RHVyYXRpb246ICh0aW1lLCBkb3Q9ZmFsc2UpIC0+XG4gICAgdCA9IHRpbWUuc3BsaXQoL1xccysvKVxuICAgIEwgXCJzZXREdXJhdGlvbjogXCIsIHRbMF0sIGRvdFxuICAgIEBjdXJyZW50X2R1cmF0aW9uID0gbWFrZUR1cmF0aW9uKHRbMF0sIGRvdClcblxuICBhZGRCYXI6ICh0eXBlKSAtPlxuICAgIEwgXCJhZGRCYXI6IFwiLCB0eXBlXG4gICAgQGNsb3NlQmVuZHMoKVxuICAgIEBrZXlfbWFuYWdlci5yZXNldCgpXG4gICAgc3RhdmUgPSBfLmxhc3QoQHN0YXZlcylcblxuICAgIFRZUEUgPSBWZXguRmxvdy5CYXJsaW5lLnR5cGVcbiAgICB0eXBlID0gc3dpdGNoIHR5cGVcbiAgICAgIHdoZW4gXCJzaW5nbGVcIlxuICAgICAgICBUWVBFLlNJTkdMRVxuICAgICAgd2hlbiBcImRvdWJsZVwiXG4gICAgICAgIFRZUEUuRE9VQkxFXG4gICAgICB3aGVuIFwiZW5kXCJcbiAgICAgICAgVFlQRS5FTkRcbiAgICAgIHdoZW4gXCJyZXBlYXQtYmVnaW5cIlxuICAgICAgICBUWVBFLlJFUEVBVF9CRUdJTlxuICAgICAgd2hlbiBcInJlcGVhdC1lbmRcIlxuICAgICAgICBUWVBFLlJFUEVBVF9FTkRcbiAgICAgIHdoZW4gXCJyZXBlYXQtYm90aFwiXG4gICAgICAgIFRZUEUuUkVQRUFUX0JPVEhcbiAgICAgIGVsc2VcbiAgICAgICAgVFlQRS5TSU5HTEVcblxuICAgIGJhcl9ub3RlID0gbmV3IFZleC5GbG93LkJhck5vdGUoKS5zZXRUeXBlKHR5cGUpXG4gICAgc3RhdmUudGFiX25vdGVzLnB1c2goYmFyX25vdGUpXG4gICAgc3RhdmUubm90ZV9ub3Rlcy5wdXNoKGJhcl9ub3RlKSBpZiBzdGF2ZS5ub3RlP1xuXG4gIG1ha2VCZW5kID0gKGZyb21fZnJldCwgdG9fZnJldCkgLT5cbiAgICBkaXJlY3Rpb24gPSBWZXguRmxvdy5CZW5kLlVQXG4gICAgdGV4dCA9IFwiXCJcblxuICAgIGlmIHBhcnNlSW50KGZyb21fZnJldCwgMTApID4gcGFyc2VJbnQodG9fZnJldCwgMTApXG4gICAgICBkaXJlY3Rpb24gPSBWZXguRmxvdy5CZW5kLkRPV05cbiAgICBlbHNlXG4gICAgICB0ZXh0ID0gc3dpdGNoIE1hdGguYWJzKHRvX2ZyZXQgLSBmcm9tX2ZyZXQpXG4gICAgICAgIHdoZW4gMSB0aGVuIFwiMS8yXCJcbiAgICAgICAgd2hlbiAyIHRoZW4gXCJGdWxsXCJcbiAgICAgICAgd2hlbiAzIHRoZW4gXCIxIDEvMlwiXG4gICAgICAgIGVsc2UgXCJCZW5kIHRvICN7dG9fZnJldH1cIlxuXG4gICAgcmV0dXJuIHt0eXBlOiBkaXJlY3Rpb24sIHRleHQ6IHRleHR9XG5cbiAgb3BlbkJlbmRzOiAoZmlyc3Rfbm90ZSwgbGFzdF9ub3RlLCBmaXJzdF9pbmRpY2VzLCBsYXN0X2luZGljZXMpIC0+XG4gICAgTCBcIm9wZW5CZW5kc1wiLCBmaXJzdF9ub3RlLCBsYXN0X25vdGUsIGZpcnN0X2luZGljZXMsIGxhc3RfaW5kaWNlc1xuICAgIHRhYl9ub3RlcyA9IF8ubGFzdChAc3RhdmVzKS50YWJfbm90ZXNcblxuICAgIHN0YXJ0X25vdGUgPSBmaXJzdF9ub3RlXG4gICAgc3RhcnRfaW5kaWNlcyA9IGZpcnN0X2luZGljZXNcbiAgICBpZiBfLmlzRW1wdHkoQGN1cnJlbnRfYmVuZHMpXG4gICAgICBAYmVuZF9zdGFydF9pbmRleCA9IHRhYl9ub3Rlcy5sZW5ndGggLSAyXG4gICAgICBAYmVuZF9zdGFydF9zdHJpbmdzID0gZmlyc3RfaW5kaWNlc1xuICAgIGVsc2VcbiAgICAgIHN0YXJ0X25vdGUgPSB0YWJfbm90ZXNbQGJlbmRfc3RhcnRfaW5kZXhdXG4gICAgICBzdGFydF9pbmRpY2VzID0gQGJlbmRfc3RhcnRfc3RyaW5nc1xuXG4gICAgZmlyc3RfZnJldHMgPSBzdGFydF9ub3RlLmdldFBvc2l0aW9ucygpXG4gICAgbGFzdF9mcmV0cyA9IGxhc3Rfbm90ZS5nZXRQb3NpdGlvbnMoKVxuICAgIGZvciBpbmRleCwgaSBpbiBzdGFydF9pbmRpY2VzXG4gICAgICBsYXN0X2luZGV4ID0gbGFzdF9pbmRpY2VzW2ldXG4gICAgICBmcm9tX2ZyZXQgPSBmaXJzdF9ub3RlLmdldFBvc2l0aW9ucygpW2ZpcnN0X2luZGljZXNbaV1dXG4gICAgICB0b19mcmV0ID0gbGFzdF9mcmV0c1tsYXN0X2luZGV4XVxuICAgICAgQGN1cnJlbnRfYmVuZHNbaW5kZXhdID89IFtdXG4gICAgICBAY3VycmVudF9iZW5kc1tpbmRleF0ucHVzaCBtYWtlQmVuZChmcm9tX2ZyZXQuZnJldCwgdG9fZnJldC5mcmV0KVxuXG4gICMgQ2xvc2UgYW5kIGFwcGx5IGFsbCB0aGUgYmVuZHMgdG8gdGhlIGxhc3QgTiBub3Rlcy5cbiAgY2xvc2VCZW5kczogKG9mZnNldD0xKSAtPlxuICAgIHJldHVybiB1bmxlc3MgQGJlbmRfc3RhcnRfaW5kZXg/XG4gICAgTCBcImNsb3NlQmVuZHMoI3tvZmZzZXR9KVwiXG4gICAgdGFiX25vdGVzID0gXy5sYXN0KEBzdGF2ZXMpLnRhYl9ub3Rlc1xuICAgIGZvciBrLCB2IG9mIEBjdXJyZW50X2JlbmRzXG4gICAgICBwaHJhc2UgPSBbXVxuICAgICAgZm9yIGJlbmQgaW4gdlxuICAgICAgICBwaHJhc2UucHVzaCBiZW5kXG4gICAgICB0YWJfbm90ZXNbQGJlbmRfc3RhcnRfaW5kZXhdLmFkZE1vZGlmaWVyKFxuICAgICAgICBuZXcgVmV4LkZsb3cuQmVuZChudWxsLCBudWxsLCBwaHJhc2UpLCBrKVxuXG4gICAgIyBSZXBsYWNlIGJlbnQgbm90ZXMgd2l0aCBnaG9zdHMgKG1ha2UgdGhlbSBpbnZpc2libGUpXG4gICAgZm9yIHRhYl9ub3RlIGluIHRhYl9ub3Rlc1tAYmVuZF9zdGFydF9pbmRleCsxLi4oKHRhYl9ub3Rlcy5sZW5ndGggLSAyKSArIG9mZnNldCldXG4gICAgICB0YWJfbm90ZS5zZXRHaG9zdCh0cnVlKVxuXG4gICAgQGN1cnJlbnRfYmVuZHMgPSB7fVxuICAgIEBiZW5kX3N0YXJ0X2luZGV4ID0gbnVsbFxuXG4gIG1ha2VUdXBsZXRzOiAodHVwbGV0cywgbm90ZXMpIC0+XG4gICAgTCBcIm1ha2VUdXBsZXRzXCIsIHR1cGxldHMsIG5vdGVzXG4gICAgbm90ZXMgPz0gdHVwbGV0c1xuICAgIHJldHVybiB1bmxlc3MgXy5sYXN0KEBzdGF2ZXMpLm5vdGVcbiAgICBzdGF2ZV9ub3RlcyA9IF8ubGFzdChAc3RhdmVzKS5ub3RlX25vdGVzXG4gICAgdGFiX25vdGVzID0gXy5sYXN0KEBzdGF2ZXMpLnRhYl9ub3Rlc1xuXG4gICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQXJ0aXN0RXJyb3JcIiwgXCJOb3QgZW5vdWdoIG5vdGVzIGZvciB0dXBsZXRcIikgaWYgc3RhdmVfbm90ZXMubGVuZ3RoIDwgbm90ZXNcbiAgICBtb2RpZmllciA9IG5ldyBWZXguRmxvdy5UdXBsZXQoc3RhdmVfbm90ZXNbc3RhdmVfbm90ZXMubGVuZ3RoIC0gbm90ZXMuLl0sIHtudW1fbm90ZXM6IHR1cGxldHN9KVxuICAgIEBzdGF2ZV9hcnRpY3VsYXRpb25zLnB1c2ggbW9kaWZpZXJcblxuICAgICMgQ3JlYXRpbmcgYSBWZXguRmxvdy5UdXBsZXQgY29ycmVjdHMgdGhlIHRpY2tzIGZvciB0aGUgbm90ZXMsIHNvIGl0IG5lZWRzIHRvXG4gICAgIyBiZSBjcmVhdGVkIHdoZXRoZXIgb3Igbm90IGl0IGdldHMgcmVuZGVyZWQuIEJlbG93LCBpZiB0YWIgc3RlbXMgYXJlIG5vdCByZXF1aXJlZFxuICAgICMgdGhlIGNyZWF0ZWQgdHVwbGV0IGlzIHNpbXBseSB0aHJvd24gYXdheS5cbiAgICB0YWJfbW9kaWZpZXIgPSBuZXcgVmV4LkZsb3cuVHVwbGV0KHRhYl9ub3Rlc1t0YWJfbm90ZXMubGVuZ3RoIC0gbm90ZXMuLl0sIHtudW1fbm90ZXM6IHR1cGxldHN9KVxuICAgIGlmIEBjdXN0b21pemF0aW9uc1tcInRhYi1zdGVtc1wiXSA9PSBcInRydWVcIlxuICAgICAgQHRhYl9hcnRpY3VsYXRpb25zLnB1c2ggdGFiX21vZGlmaWVyXG5cbiAgZ2V0RmluZ2VyaW5nID0gKHRleHQpIC0+IHRleHQubWF0Y2goL15cXC5maW5nZXJpbmdcXC8oW14uXSspXFwuLylcbiAgbWFrZUZpbmdlcmluZzogKHRleHQpIC0+XG4gICAgcGFydHMgPSBnZXRGaW5nZXJpbmcodGV4dClcbiAgICBQT1MgPSBWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvblxuICAgIGZpbmdlcnMgPSBbXVxuICAgIGZpbmdlcmluZyA9IFtdXG5cbiAgICBpZiBwYXJ0cz9cbiAgICAgIGZpbmdlcnMgPSAocC50cmltKCkgZm9yIHAgaW4gcGFydHNbMV0uc3BsaXQoLy0vKSlcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbnVsbFxuXG4gICAgYmFkRmluZ2VyaW5nID0gLT4gbmV3IFZleC5SRVJSKFwiQXJ0aXN0RXJyb3JcIiwgXCJCYWQgZmluZ2VyaW5nOiAje3BhcnRzWzFdfVwiKVxuXG4gICAgZm9yIGZpbmdlciBpbiBmaW5nZXJzXG4gICAgICBwaWVjZXMgPSBmaW5nZXIubWF0Y2goLyhcXGQrKTooW2FibHJdKTooW2ZzXSk6KFteLS5dKykvKVxuICAgICAgdGhyb3cgYmFkRmluZ2VyaW5nKCkgdW5sZXNzIHBpZWNlcz9cblxuICAgICAgbm90ZV9udW1iZXIgPSBwYXJzZUludChwaWVjZXNbMV0sIDEwKSAtIDFcbiAgICAgIHBvc2l0aW9uID0gUE9TLlJJR0hUXG4gICAgICBzd2l0Y2ggcGllY2VzWzJdXG4gICAgICAgIHdoZW4gXCJsXCJcbiAgICAgICAgICBwb3NpdGlvbiA9IFBPUy5MRUZUXG4gICAgICAgIHdoZW4gXCJyXCJcbiAgICAgICAgICBwb3NpdGlvbiA9IFBPUy5SSUdIVFxuICAgICAgICB3aGVuIFwiYVwiXG4gICAgICAgICAgcG9zaXRpb24gPSBQT1MuQUJPVkVcbiAgICAgICAgd2hlbiBcImJcIlxuICAgICAgICAgIHBvc2l0aW9uID0gUE9TLkJFTE9XXG5cbiAgICAgIG1vZGlmaWVyID0gbnVsbFxuICAgICAgbnVtYmVyID0gcGllY2VzWzRdXG4gICAgICBzd2l0Y2ggcGllY2VzWzNdXG4gICAgICAgIHdoZW4gXCJzXCJcbiAgICAgICAgICBtb2RpZmllciA9IG5ldyBWZXguRmxvdy5TdHJpbmdOdW1iZXIobnVtYmVyKS5zZXRQb3NpdGlvbihwb3NpdGlvbilcbiAgICAgICAgd2hlbiBcImZcIlxuICAgICAgICAgIG1vZGlmaWVyID0gbmV3IFZleC5GbG93LkZyZXRIYW5kRmluZ2VyKG51bWJlcikuc2V0UG9zaXRpb24ocG9zaXRpb24pXG5cbiAgICAgIGZpbmdlcmluZy5wdXNoKHtudW06IG5vdGVfbnVtYmVyLCBtb2RpZmllcjogbW9kaWZpZXJ9KVxuXG4gICAgcmV0dXJuIGZpbmdlcmluZ1xuXG4gIGdldFN0cm9rZVBhcnRzID0gKHRleHQpIC0+IHRleHQubWF0Y2goL15cXC5zdHJva2VcXC8oW14uXSspXFwuLylcbiAgbWFrZVN0cm9rZTogKHRleHQpIC0+XG4gICAgcGFydHMgPSBnZXRTdHJva2VQYXJ0cyh0ZXh0KVxuICAgIFRZUEUgPSBWZXguRmxvdy5TdHJva2UuVHlwZVxuICAgIHR5cGUgPSBudWxsXG5cbiAgICBpZiBwYXJ0cz9cbiAgICAgIHN3aXRjaCBwYXJ0c1sxXVxuICAgICAgICB3aGVuIFwiYnVcIlxuICAgICAgICAgIHR5cGUgPSBUWVBFLkJSVVNIX1VQXG4gICAgICAgIHdoZW4gXCJiZFwiXG4gICAgICAgICAgdHlwZSA9IFRZUEUuQlJVU0hfRE9XTlxuICAgICAgICB3aGVuIFwicnVcIlxuICAgICAgICAgIHR5cGUgPSBUWVBFLlJPTExfVVBcbiAgICAgICAgd2hlbiBcInJkXCJcbiAgICAgICAgICB0eXBlID0gVFlQRS5ST0xMX0RPV05cbiAgICAgICAgd2hlbiBcInF1XCJcbiAgICAgICAgICB0eXBlID0gVFlQRS5SQVNRVUVET19VUFxuICAgICAgICB3aGVuIFwicWRcIlxuICAgICAgICAgIHR5cGUgPSBUWVBFLlJBU1FVRURPX0RPV05cbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkFydGlzdEVycm9yXCIsIFwiSW52YWxpZCBzdHJva2UgdHlwZTogI3twYXJ0c1sxXX1cIilcbiAgICAgIHJldHVybiBuZXcgVmV4LkZsb3cuU3Ryb2tlKHR5cGUpXG4gICAgZWxzZVxuICAgICAgcmV0dXJuIG51bGxcblxuICBnZXRTY29yZUFydGljdWxhdGlvblBhcnRzID0gKHRleHQpIC0+IHRleHQubWF0Y2goL15cXC4oYVteXFwvXSopXFwvKHR8YilbXi5dKlxcLi8pXG4gIG1ha2VTY29yZUFydGljdWxhdGlvbjogKHRleHQpIC0+XG4gICAgcGFydHMgPSBnZXRTY29yZUFydGljdWxhdGlvblBhcnRzKHRleHQpXG4gICAgaWYgcGFydHM/XG4gICAgICB0eXBlID0gcGFydHNbMV1cbiAgICAgIHBvc2l0aW9uID0gcGFydHNbMl1cblxuICAgICAgUE9TVFlQRSA9IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uXG4gICAgICBwb3MgPSBpZiBwb3NpdGlvbiBpcyBcInRcIiB0aGVuIFBPU1RZUEUuQUJPVkUgZWxzZSBQT1NUWVBFLkJFTE9XXG4gICAgICByZXR1cm4gbmV3IFZleC5GbG93LkFydGljdWxhdGlvbih0eXBlKS5zZXRQb3NpdGlvbihwb3MpXG4gICAgZWxzZSByZXR1cm4gbnVsbFxuXG4gIG1ha2VBbm5vdGF0aW9uOiAodGV4dCkgLT5cbiAgICBmb250X2ZhY2UgPSBAY3VzdG9taXphdGlvbnNbXCJmb250LWZhY2VcIl1cbiAgICBmb250X3NpemUgPSBAY3VzdG9taXphdGlvbnNbXCJmb250LXNpemVcIl1cbiAgICBmb250X3N0eWxlID0gQGN1c3RvbWl6YXRpb25zW1wiZm9udC1zdHlsZVwiXVxuICAgIGFwb3NpdGlvbiA9IEBjdXN0b21pemF0aW9uc1tcImFubm90YXRpb24tcG9zaXRpb25cIl1cblxuICAgIFZKVVNUID0gVmV4LkZsb3cuQW5ub3RhdGlvbi5WZXJ0aWNhbEp1c3RpZnlcbiAgICBkZWZhdWx0X3ZqdXN0ID0gaWYgYXBvc2l0aW9uIGlzIFwidG9wXCIgdGhlbiBWSlVTVC5UT1AgZWxzZSBWSlVTVC5CT1RUT01cblxuICAgIG1ha2VJdCA9ICh0ZXh0LCBqdXN0PWRlZmF1bHRfdmp1c3QpIC0+XG4gICAgICBuZXcgVmV4LkZsb3cuQW5ub3RhdGlvbih0ZXh0KS5cbiAgICAgICAgc2V0Rm9udChmb250X2ZhY2UsIGZvbnRfc2l6ZSwgZm9udF9zdHlsZSkuXG4gICAgICAgIHNldFZlcnRpY2FsSnVzdGlmaWNhdGlvbihqdXN0KVxuXG4gICAgcGFydHMgPSB0ZXh0Lm1hdGNoKC9eXFwuKFteLV0qKS0oW14tXSopLShbXi5dKilcXC4oLiopLylcbiAgICBpZiBwYXJ0cz9cbiAgICAgIGZvbnRfZmFjZSA9IHBhcnRzWzFdXG4gICAgICBmb250X3NpemUgPSBwYXJ0c1syXVxuICAgICAgZm9udF9zdHlsZSA9IHBhcnRzWzNdXG4gICAgICB0ZXh0ID0gcGFydHNbNF1cbiAgICAgIHJldHVybiBpZiB0ZXh0IHRoZW4gbWFrZUl0KHRleHQpIGVsc2UgbnVsbFxuXG4gICAgcGFydHMgPSB0ZXh0Lm1hdGNoKC9eXFwuKFteLl0qKVxcLiguKikvKVxuICAgIGlmIHBhcnRzP1xuICAgICAganVzdCA9IGRlZmF1bHRfdmp1c3RcbiAgICAgIHRleHQgPSBwYXJ0c1syXVxuICAgICAgc3dpdGNoIHBhcnRzWzFdXG4gICAgICAgIHdoZW4gXCJiaWdcIlxuICAgICAgICAgIGZvbnRfc3R5bGUgPSBcImJvbGRcIlxuICAgICAgICAgIGZvbnRfc2l6ZSA9IFwiMTRcIlxuICAgICAgICB3aGVuIFwiaXRhbGljXCIsIFwiaXRhbGljc1wiXG4gICAgICAgICAgZm9udF9mYWNlID0gXCJUaW1lc1wiXG4gICAgICAgICAgZm9udF9zdHlsZSA9IFwiaXRhbGljXCJcbiAgICAgICAgd2hlbiBcIm1lZGl1bVwiXG4gICAgICAgICAgZm9udF9zaXplID0gXCIxMlwiXG4gICAgICAgIHdoZW4gXCJ0b3BcIlxuICAgICAgICAgIGp1c3QgPSBWSlVTVC5UT1BcbiAgICAgICAgICBAY3VzdG9taXphdGlvbnNbXCJhbm5vdGF0aW9uLXBvc2l0aW9uXCJdID0gXCJ0b3BcIlxuICAgICAgICB3aGVuIFwiYm90dG9tXCJcbiAgICAgICAgICBqdXN0ID0gVkpVU1QuQk9UVE9NXG4gICAgICAgICAgQGN1c3RvbWl6YXRpb25zW1wiYW5ub3RhdGlvbi1wb3NpdGlvblwiXSA9IFwiYm90dG9tXCJcbiAgICAgIHJldHVybiBpZiB0ZXh0IHRoZW4gbWFrZUl0KHRleHQsIGp1c3QpIGVsc2UgbnVsbFxuXG4gICAgcmV0dXJuIG1ha2VJdCh0ZXh0KVxuXG4gIGFkZEFubm90YXRpb25zOiAoYW5ub3RhdGlvbnMpIC0+XG4gICAgc3RhdmUgPSBfLmxhc3QoQHN0YXZlcylcbiAgICBzdGF2ZV9ub3RlcyA9IHN0YXZlLm5vdGVfbm90ZXNcbiAgICB0YWJfbm90ZXMgPSBzdGF2ZS50YWJfbm90ZXNcblxuICAgIGlmIGFubm90YXRpb25zLmxlbmd0aCA+IHRhYl9ub3Rlcy5sZW5ndGhcbiAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkFydGlzdEVycm9yXCIsIFwiTW9yZSBhbm5vdGF0aW9ucyB0aGFuIG5vdGUgZWxlbWVudHNcIilcblxuICAgICMgQWRkIHRleHQgYW5ub3RhdGlvbnNcbiAgICBpZiBzdGF2ZS50YWJcbiAgICAgIGZvciB0YWJfbm90ZSwgaSBpbiB0YWJfbm90ZXNbdGFiX25vdGVzLmxlbmd0aCAtIGFubm90YXRpb25zLmxlbmd0aC4uXVxuICAgICAgICBpZiBnZXRTY29yZUFydGljdWxhdGlvblBhcnRzKGFubm90YXRpb25zW2ldKVxuICAgICAgICAgIHNjb3JlX2FydGljdWxhdGlvbiA9IEBtYWtlU2NvcmVBcnRpY3VsYXRpb24oYW5ub3RhdGlvbnNbaV0pXG4gICAgICAgICAgdGFiX25vdGUuYWRkTW9kaWZpZXIoc2NvcmVfYXJ0aWN1bGF0aW9uLCAwKVxuICAgICAgICBlbHNlIGlmIGdldFN0cm9rZVBhcnRzKGFubm90YXRpb25zW2ldKVxuICAgICAgICAgIHN0cm9rZSA9IEBtYWtlU3Ryb2tlKGFubm90YXRpb25zW2ldKVxuICAgICAgICAgIHRhYl9ub3RlLmFkZE1vZGlmaWVyKHN0cm9rZSwgMClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGFubm90YXRpb24gPSBAbWFrZUFubm90YXRpb24oYW5ub3RhdGlvbnNbaV0pXG4gICAgICAgICAgdGFiX25vdGUuYWRkTW9kaWZpZXIoQG1ha2VBbm5vdGF0aW9uKGFubm90YXRpb25zW2ldKSwgMCkgaWYgYW5ub3RhdGlvblxuICAgIGVsc2VcbiAgICAgIGZvciBub3RlLCBpIGluIHN0YXZlX25vdGVzW3N0YXZlX25vdGVzLmxlbmd0aCAtIGFubm90YXRpb25zLmxlbmd0aC4uXVxuICAgICAgICB1bmxlc3MgZ2V0U2NvcmVBcnRpY3VsYXRpb25QYXJ0cyhhbm5vdGF0aW9uc1tpXSlcbiAgICAgICAgICBhbm5vdGF0aW9uID0gQG1ha2VBbm5vdGF0aW9uKGFubm90YXRpb25zW2ldKVxuICAgICAgICAgIG5vdGUuYWRkQW5ub3RhdGlvbigwLCBAbWFrZUFubm90YXRpb24oYW5ub3RhdGlvbnNbaV0pKSBpZiBhbm5vdGF0aW9uXG5cbiAgICAjIEFkZCBnbHlwaCBhcnRpY3VsYXRpb25zLCBzdHJva2VzLCBvciBmaW5nZXJpbmdzIG9uIHNjb3JlXG4gICAgaWYgc3RhdmUubm90ZVxuICAgICAgZm9yIG5vdGUsIGkgaW4gc3RhdmVfbm90ZXNbc3RhdmVfbm90ZXMubGVuZ3RoIC0gYW5ub3RhdGlvbnMubGVuZ3RoLi5dXG4gICAgICAgIHNjb3JlX2FydGljdWxhdGlvbiA9IEBtYWtlU2NvcmVBcnRpY3VsYXRpb24oYW5ub3RhdGlvbnNbaV0pXG4gICAgICAgIG5vdGUuYWRkQXJ0aWN1bGF0aW9uKDAsIHNjb3JlX2FydGljdWxhdGlvbikgaWYgc2NvcmVfYXJ0aWN1bGF0aW9uP1xuXG4gICAgICAgIHN0cm9rZSA9IEBtYWtlU3Ryb2tlKGFubm90YXRpb25zW2ldKVxuICAgICAgICBub3RlLmFkZFN0cm9rZSgwLCBzdHJva2UpIGlmIHN0cm9rZT9cblxuICAgICAgICBmaW5nZXJpbmdzID0gQG1ha2VGaW5nZXJpbmcoYW5ub3RhdGlvbnNbaV0pXG4gICAgICAgIGlmIGZpbmdlcmluZ3M/XG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICAobm90ZS5hZGRNb2RpZmllcihmaW5nZXJpbmcubnVtLCBmaW5nZXJpbmcubW9kaWZpZXIpIGZvciBmaW5nZXJpbmcgaW4gZmluZ2VyaW5ncylcbiAgICAgICAgICBjYXRjaCBlXG4gICAgICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJBcnRpc3RFcnJvclwiLCBcIkJhZCBub3RlIG51bWJlciBpbiBmaW5nZXJpbmc6ICN7YW5ub3RhdGlvbnNbaV19XCIpXG5cbiAgYWRkVGFiQXJ0aWN1bGF0aW9uOiAodHlwZSwgZmlyc3Rfbm90ZSwgbGFzdF9ub3RlLCBmaXJzdF9pbmRpY2VzLCBsYXN0X2luZGljZXMpIC0+XG4gICAgTCBcImFkZFRhYkFydGljdWxhdGlvbnM6IFwiLCB0eXBlLCBmaXJzdF9ub3RlLCBsYXN0X25vdGUsIGZpcnN0X2luZGljZXMsIGxhc3RfaW5kaWNlc1xuXG4gICAgaWYgdHlwZSA9PSBcInRcIlxuICAgICAgbGFzdF9ub3RlLmFkZE1vZGlmaWVyKFxuICAgICAgICBuZXcgVmV4LkZsb3cuQW5ub3RhdGlvbihcIlRcIikuXG4gICAgICAgICAgc2V0VmVydGljYWxKdXN0aWZpY2F0aW9uKFZleC5GbG93LkFubm90YXRpb24uVmVydGljYWxKdXN0aWZ5LkJPVFRPTSkpXG5cbiAgICBpZiBfLmlzRW1wdHkoZmlyc3RfaW5kaWNlcykgYW5kIF8uaXNFbXB0eShsYXN0X2luZGljZXMpIHRoZW4gcmV0dXJuXG5cbiAgICBhcnRpY3VsYXRpb24gPSBudWxsXG5cbiAgICBpZiB0eXBlID09IFwic1wiXG4gICAgICBhcnRpY3VsYXRpb24gPSBuZXcgVmV4LkZsb3cuVGFiU2xpZGUoe1xuICAgICAgICBmaXJzdF9ub3RlOiBmaXJzdF9ub3RlXG4gICAgICAgIGxhc3Rfbm90ZTogbGFzdF9ub3RlXG4gICAgICAgIGZpcnN0X2luZGljZXM6IGZpcnN0X2luZGljZXNcbiAgICAgICAgbGFzdF9pbmRpY2VzOiBsYXN0X2luZGljZXNcbiAgICAgICAgfSlcblxuICAgIGlmIHR5cGUgaW4gW1wiaFwiLCBcInBcIl1cbiAgICAgIGFydGljdWxhdGlvbiA9IG5ldyBWZXguRmxvdy5UYWJUaWUoe1xuICAgICAgICBmaXJzdF9ub3RlOiBmaXJzdF9ub3RlXG4gICAgICAgIGxhc3Rfbm90ZTogbGFzdF9ub3RlXG4gICAgICAgIGZpcnN0X2luZGljZXM6IGZpcnN0X2luZGljZXNcbiAgICAgICAgbGFzdF9pbmRpY2VzOiBsYXN0X2luZGljZXNcbiAgICAgICAgfSwgdHlwZS50b1VwcGVyQ2FzZSgpKVxuXG4gICAgaWYgdHlwZSBpbiBbXCJUXCIsIFwidFwiXVxuICAgICAgYXJ0aWN1bGF0aW9uID0gbmV3IFZleC5GbG93LlRhYlRpZSh7XG4gICAgICAgIGZpcnN0X25vdGU6IGZpcnN0X25vdGVcbiAgICAgICAgbGFzdF9ub3RlOiBsYXN0X25vdGVcbiAgICAgICAgZmlyc3RfaW5kaWNlczogZmlyc3RfaW5kaWNlc1xuICAgICAgICBsYXN0X2luZGljZXM6IGxhc3RfaW5kaWNlc1xuICAgICAgICB9LCBcIiBcIilcblxuICAgIGlmIHR5cGUgPT0gXCJiXCJcbiAgICAgIEBvcGVuQmVuZHMoZmlyc3Rfbm90ZSwgbGFzdF9ub3RlLCBmaXJzdF9pbmRpY2VzLCBsYXN0X2luZGljZXMpXG5cbiAgICBAdGFiX2FydGljdWxhdGlvbnMucHVzaCBhcnRpY3VsYXRpb24gaWYgYXJ0aWN1bGF0aW9uP1xuXG4gIGFkZFN0YXZlQXJ0aWN1bGF0aW9uOiAodHlwZSwgZmlyc3Rfbm90ZSwgbGFzdF9ub3RlLCBmaXJzdF9pbmRpY2VzLCBsYXN0X2luZGljZXMpIC0+XG4gICAgTCBcImFkZFN0YXZlQXJ0aWN1bGF0aW9uczogXCIsIHR5cGUsIGZpcnN0X25vdGUsIGxhc3Rfbm90ZSwgZmlyc3RfaW5kaWNlcywgbGFzdF9pbmRpY2VzXG4gICAgYXJ0aWN1bGF0aW9uID0gbnVsbFxuICAgIGlmIHR5cGUgaW4gW1wiYlwiLCBcInNcIiwgXCJoXCIsIFwicFwiLCBcInRcIiwgXCJUXCJdXG4gICAgICBhcnRpY3VsYXRpb24gPSBuZXcgVmV4LkZsb3cuU3RhdmVUaWUoe1xuICAgICAgICBmaXJzdF9ub3RlOiBmaXJzdF9ub3RlXG4gICAgICAgIGxhc3Rfbm90ZTogbGFzdF9ub3RlXG4gICAgICAgIGZpcnN0X2luZGljZXM6IGZpcnN0X2luZGljZXNcbiAgICAgICAgbGFzdF9pbmRpY2VzOiBsYXN0X2luZGljZXNcbiAgICAgICAgfSlcblxuICAgIEBzdGF2ZV9hcnRpY3VsYXRpb25zLnB1c2ggYXJ0aWN1bGF0aW9uIGlmIGFydGljdWxhdGlvbj9cblxuICAjIFRoaXMgZ2V0cyB0aGUgcHJldmlvdXMgKHNlY29uZC10by1sYXN0KSBub24tYmFyIG5vbi1naG9zdCBub3RlLlxuICBnZXRQcmV2aW91c05vdGVJbmRleDogLT5cbiAgICB0YWJfbm90ZXMgPSBfLmxhc3QoQHN0YXZlcykudGFiX25vdGVzXG4gICAgaW5kZXggPSAyXG4gICAgd2hpbGUgaW5kZXggPD0gdGFiX25vdGVzLmxlbmd0aFxuICAgICAgbm90ZSA9IHRhYl9ub3Rlc1t0YWJfbm90ZXMubGVuZ3RoIC0gaW5kZXhdXG4gICAgICByZXR1cm4gKHRhYl9ub3Rlcy5sZW5ndGggLSBpbmRleCkgaWYgbm90ZSBpbnN0YW5jZW9mIFZleC5GbG93LlRhYk5vdGVcbiAgICAgIGluZGV4KytcblxuICAgIHJldHVybiAtMVxuXG4gIGFkZERlY29yYXRvcjogKGRlY29yYXRvcikgLT5cbiAgICBMIFwiYWRkRGVjb3JhdG9yOiBcIiwgZGVjb3JhdG9yXG4gICAgcmV0dXJuIHVubGVzcyBkZWNvcmF0b3I/XG5cbiAgICBzdGF2ZSA9IF8ubGFzdChAc3RhdmVzKVxuICAgIHRhYl9ub3RlcyA9IHN0YXZlLnRhYl9ub3Rlc1xuICAgIHNjb3JlX25vdGVzID0gc3RhdmUubm90ZV9ub3Rlc1xuICAgIG1vZGlmaWVyID0gbnVsbFxuICAgIHNjb3JlX21vZGlmaWVyID0gbnVsbFxuXG4gICAgaWYgZGVjb3JhdG9yID09IFwidlwiXG4gICAgICBtb2RpZmllciA9IG5ldyBWZXguRmxvdy5WaWJyYXRvKClcbiAgICBpZiBkZWNvcmF0b3IgPT0gXCJWXCJcbiAgICAgIG1vZGlmaWVyID0gbmV3IFZleC5GbG93LlZpYnJhdG8oKS5zZXRIYXJzaCh0cnVlKVxuICAgIGlmIGRlY29yYXRvciA9PSBcInVcIlxuICAgICAgbW9kaWZpZXIgPSBuZXcgVmV4LkZsb3cuQXJ0aWN1bGF0aW9uKFwiYXxcIikuc2V0UG9zaXRpb24oVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uQk9UVE9NKVxuICAgICAgc2NvcmVfbW9kaWZpZXIgPSBuZXcgVmV4LkZsb3cuQXJ0aWN1bGF0aW9uKFwiYXxcIikuc2V0UG9zaXRpb24oVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uQk9UVE9NKVxuICAgIGlmIGRlY29yYXRvciA9PSBcImRcIlxuICAgICAgbW9kaWZpZXIgPSBuZXcgVmV4LkZsb3cuQXJ0aWN1bGF0aW9uKFwiYW1cIikuc2V0UG9zaXRpb24oVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uQk9UVE9NKVxuICAgICAgc2NvcmVfbW9kaWZpZXIgPSBuZXcgVmV4LkZsb3cuQXJ0aWN1bGF0aW9uKFwiYW1cIikuc2V0UG9zaXRpb24oVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uQk9UVE9NKVxuXG4gICAgXy5sYXN0KHRhYl9ub3RlcykuYWRkTW9kaWZpZXIobW9kaWZpZXIsIDApIGlmIG1vZGlmaWVyP1xuICAgIF8ubGFzdChzY29yZV9ub3Rlcyk/LmFkZEFydGljdWxhdGlvbigwLCBzY29yZV9tb2RpZmllcikgaWYgc2NvcmVfbW9kaWZpZXI/XG5cblxuICBhZGRBcnRpY3VsYXRpb25zOiAoYXJ0aWN1bGF0aW9ucykgLT5cbiAgICBMIFwiYWRkQXJ0aWN1bGF0aW9uczogXCIsIGFydGljdWxhdGlvbnNcbiAgICBzdGF2ZSA9IF8ubGFzdChAc3RhdmVzKVxuICAgIHRhYl9ub3RlcyA9IHN0YXZlLnRhYl9ub3Rlc1xuICAgIHN0YXZlX25vdGVzID0gc3RhdmUubm90ZV9ub3Rlc1xuICAgIGlmIF8uaXNFbXB0eSh0YWJfbm90ZXMpIG9yIF8uaXNFbXB0eShhcnRpY3VsYXRpb25zKVxuICAgICAgQGNsb3NlQmVuZHMoMClcbiAgICAgIHJldHVyblxuXG4gICAgY3VycmVudF90YWJfbm90ZSA9IF8ubGFzdCh0YWJfbm90ZXMpXG5cbiAgICBoYXNfYmVuZHMgPSBmYWxzZVxuICAgIGZvciB2YWxpZF9hcnRpY3VsYXRpb24gaW4gW1wiYlwiLCBcInNcIiwgXCJoXCIsIFwicFwiLCBcInRcIiwgXCJUXCIsIFwidlwiLCBcIlZcIl1cbiAgICAgIGluZGljZXMgPSAoaSBmb3IgYXJ0LCBpIGluIGFydGljdWxhdGlvbnMgd2hlbiBhcnQ/IGFuZCBhcnQgPT0gdmFsaWRfYXJ0aWN1bGF0aW9uKVxuICAgICAgaWYgXy5pc0VtcHR5KGluZGljZXMpIHRoZW4gY29udGludWVcblxuICAgICAgaWYgdmFsaWRfYXJ0aWN1bGF0aW9uIGlzIFwiYlwiIHRoZW4gaGFzX2JlbmRzID0gdHJ1ZVxuICAgICAgcHJldl9pbmRleCA9IEBnZXRQcmV2aW91c05vdGVJbmRleCgpXG4gICAgICBpZiBwcmV2X2luZGV4IGlzIC0xXG4gICAgICAgIHByZXZfdGFiX25vdGUgPSBudWxsXG4gICAgICAgIHByZXZfaW5kaWNlcyA9IG51bGxcbiAgICAgIGVsc2VcbiAgICAgICAgcHJldl90YWJfbm90ZSA9IHRhYl9ub3Rlc1twcmV2X2luZGV4XVxuICAgICAgICAjIEZpZ3VyZSBvdXQgd2hpY2ggc3RyaW5ncyB0aGUgYXJ0aWN1bGF0aW9ucyBhcmUgb25cbiAgICAgICAgdGhpc19zdHJpbmdzID0gKG4uc3RyIGZvciBuLCBpIGluIGN1cnJlbnRfdGFiX25vdGUuZ2V0UG9zaXRpb25zKCkgd2hlbiBpIGluIGluZGljZXMpXG5cbiAgICAgICAgIyBPbmx5IGFsbG93cyBhcnRpY3VsYXRpb25zIHdoZXJlIGJvdGggbm90ZXMgYXJlIG9uIHRoZSBzYW1lIHN0cmluZ3NcbiAgICAgICAgdmFsaWRfc3RyaW5ncyA9IChwb3Muc3RyIGZvciBwb3MsIGkgaW4gcHJldl90YWJfbm90ZS5nZXRQb3NpdGlvbnMoKSB3aGVuIHBvcy5zdHIgaW4gdGhpc19zdHJpbmdzKVxuXG4gICAgICAgICMgR2V0IGluZGljZXMgb2YgYXJ0aWN1bGF0ZWQgbm90ZXMgb24gcHJldmlvdXMgY2hvcmRcbiAgICAgICAgcHJldl9pbmRpY2VzID0gKGkgZm9yIG4sIGkgaW4gcHJldl90YWJfbm90ZS5nZXRQb3NpdGlvbnMoKSB3aGVuIG4uc3RyIGluIHZhbGlkX3N0cmluZ3MpXG5cbiAgICAgICAgIyBHZXQgaW5kaWNlcyBvZiBhcnRpY3VsYXRlZCBub3RlcyBvbiBjdXJyZW50IGNob3JkXG4gICAgICAgIGN1cnJlbnRfaW5kaWNlcyA9IChpIGZvciBuLCBpIGluIGN1cnJlbnRfdGFiX25vdGUuZ2V0UG9zaXRpb25zKCkgd2hlbiBuLnN0ciBpbiB2YWxpZF9zdHJpbmdzKVxuXG4gICAgICBpZiBzdGF2ZS50YWI/XG4gICAgICAgIEBhZGRUYWJBcnRpY3VsYXRpb24odmFsaWRfYXJ0aWN1bGF0aW9uLFxuICAgICAgICAgIHByZXZfdGFiX25vdGUsIGN1cnJlbnRfdGFiX25vdGUsIHByZXZfaW5kaWNlcywgY3VycmVudF9pbmRpY2VzKVxuXG4gICAgICBpZiBzdGF2ZS5ub3RlP1xuICAgICAgICBAYWRkU3RhdmVBcnRpY3VsYXRpb24odmFsaWRfYXJ0aWN1bGF0aW9uLFxuICAgICAgICAgIHN0YXZlX25vdGVzW3ByZXZfaW5kZXhdLCBfLmxhc3Qoc3RhdmVfbm90ZXMpLFxuICAgICAgICAgIHByZXZfaW5kaWNlcywgY3VycmVudF9pbmRpY2VzKVxuXG4gICAgQGNsb3NlQmVuZHMoMCkgdW5sZXNzIGhhc19iZW5kc1xuXG4gIGFkZFJlc3Q6IChwYXJhbXMpIC0+XG4gICAgTCBcImFkZFJlc3Q6IFwiLCBwYXJhbXNcbiAgICBAY2xvc2VCZW5kcygpXG5cbiAgICBpZiBwYXJhbXNbXCJwb3NpdGlvblwiXSA9PSAwXG4gICAgICBAYWRkU3RhdmVOb3RlXG4gICAgICAgIHNwZWM6IFtcInIvNFwiXVxuICAgICAgICBhY2NpZGVudGFsczogW11cbiAgICAgICAgaXNfcmVzdDogdHJ1ZVxuICAgIGVsc2VcbiAgICAgIHBvc2l0aW9uID0gQHR1bmluZy5nZXROb3RlRm9yRnJldCgocGFyc2VJbnQocGFyYW1zW1wicG9zaXRpb25cIl0sIDEwKSArIDUpICogMiwgNilcbiAgICAgIEBhZGRTdGF2ZU5vdGVcbiAgICAgICAgc3BlYzogW3Bvc2l0aW9uXVxuICAgICAgICBhY2NpZGVudGFsczogW11cbiAgICAgICAgaXNfcmVzdDogdHJ1ZVxuXG4gICAgdGFiX25vdGVzID0gXy5sYXN0KEBzdGF2ZXMpLnRhYl9ub3Rlc1xuICAgIGlmIEBjdXN0b21pemF0aW9uc1tcInRhYi1zdGVtc1wiXSA9PSBcInRydWVcIlxuICAgICAgdGFiX25vdGUgPSBuZXcgVmV4LkZsb3cuU3RhdmVOb3RlKHtcbiAgICAgICAga2V5czogW3Bvc2l0aW9uIHx8IFwici80XCJdXG4gICAgICAgIGR1cmF0aW9uOiBAY3VycmVudF9kdXJhdGlvbiArIFwiclwiXG4gICAgICAgIGNsZWY6IFwidHJlYmxlXCJcbiAgICAgICAgYXV0b19zdGVtOiBmYWxzZVxuICAgICAgfSlcbiAgICAgIGlmIEBjdXJyZW50X2R1cmF0aW9uW0BjdXJyZW50X2R1cmF0aW9uLmxlbmd0aCAtIDFdID09IFwiZFwiXG4gICAgICAgIHRhYl9ub3RlLmFkZERvdCgwKVxuICAgICAgdGFiX25vdGVzLnB1c2ggdGFiX25vdGVcbiAgICBlbHNlXG4gICAgICB0YWJfbm90ZXMucHVzaCBuZXcgVmV4LkZsb3cuR2hvc3ROb3RlKEBjdXJyZW50X2R1cmF0aW9uKVxuXG4gIGFkZENob3JkOiAoY2hvcmQsIGNob3JkX2FydGljdWxhdGlvbiwgY2hvcmRfZGVjb3JhdG9yKSAtPlxuICAgIHJldHVybiBpZiBfLmlzRW1wdHkoY2hvcmQpXG4gICAgTCBcImFkZENob3JkOiBcIiwgY2hvcmRcbiAgICBzdGF2ZSA9IF8ubGFzdChAc3RhdmVzKVxuXG4gICAgc3BlY3MgPSBbXSAgICAgICAgICAjIFRoZSBzdGF2ZSBub3RlIHNwZWNzXG4gICAgcGxheV9ub3RlcyA9IFtdICAgICAjIE5vdGVzIHRvIGJlIHBsYXllZCBieSBhdWRpbyBwbGF5ZXJzXG4gICAgYWNjaWRlbnRhbHMgPSBbXSAgICAjIFRoZSBzdGF2ZSBhY2NpZGVudGFsc1xuICAgIGFydGljdWxhdGlvbnMgPSBbXSAgIyBBcnRpY3VsYXRpb25zICh0aWVzLCBiZW5kcywgdGFwcylcbiAgICBkZWNvcmF0b3JzID0gW10gICAgICMgRGVjb3JhdG9ycyAodmlicmF0b3MsIGhhcm1vbmljcylcbiAgICB0YWJfc3BlY3MgPSBbXSAgICAgICMgVGhlIHRhYiBub3Rlc1xuICAgIGR1cmF0aW9ucyA9IFtdICAgICAgIyBUaGUgZHVyYXRpb24gb2YgZWFjaCBwb3NpdGlvblxuICAgIG51bV9ub3RlcyA9IDBcblxuICAgICMgQ2hvcmRzIGFyZSBjb21wbGljYXRlZCwgYmVjYXVzZSB0aGV5IGNhbiBjb250YWluIGxpdHRsZVxuICAgICMgbGluZXMgb25lIGVhY2ggc3RyaW5nLiBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIG1vdGlvblxuICAgICMgb2YgZWFjaCBsaW5lIHNvIHdlIGtub3cgd2hpY2ggdGljayB0aGV5IGJlbG9uZyBpbi5cbiAgICBjdXJyZW50X3N0cmluZyA9IF8uZmlyc3QoY2hvcmQpLnN0cmluZ1xuICAgIGN1cnJlbnRfcG9zaXRpb24gPSAwXG5cbiAgICBmb3Igbm90ZSBpbiBjaG9yZFxuICAgICAgbnVtX25vdGVzKytcbiAgICAgIGlmIG5vdGUuYWJjPyBvciBub3RlLnN0cmluZyAhPSBjdXJyZW50X3N0cmluZ1xuICAgICAgICBjdXJyZW50X3Bvc2l0aW9uID0gMFxuICAgICAgICBjdXJyZW50X3N0cmluZyA9IG5vdGUuc3RyaW5nXG5cbiAgICAgIHVubGVzcyBzcGVjc1tjdXJyZW50X3Bvc2l0aW9uXT9cbiAgICAgICAgIyBOZXcgcG9zaXRpb24uIENyZWF0ZSBuZXcgZWxlbWVudCBhcnJheXMgZm9yIHRoaXNcbiAgICAgICAgIyBwb3NpdGlvbi5cbiAgICAgICAgc3BlY3NbY3VycmVudF9wb3NpdGlvbl0gPSBbXVxuICAgICAgICBwbGF5X25vdGVzW2N1cnJlbnRfcG9zaXRpb25dID0gW11cbiAgICAgICAgYWNjaWRlbnRhbHNbY3VycmVudF9wb3NpdGlvbl0gPSBbXVxuICAgICAgICB0YWJfc3BlY3NbY3VycmVudF9wb3NpdGlvbl0gPSBbXVxuICAgICAgICBhcnRpY3VsYXRpb25zW2N1cnJlbnRfcG9zaXRpb25dID0gW11cbiAgICAgICAgZGVjb3JhdG9yc1tjdXJyZW50X3Bvc2l0aW9uXSA9IFtdXG5cbiAgICAgIFtuZXdfbm90ZSwgbmV3X29jdGF2ZSwgYWNjaWRlbnRhbF0gPSBbbnVsbCwgbnVsbCwgbnVsbF1cblxuICAgICAgcGxheV9ub3RlID0gbnVsbFxuXG4gICAgICBpZiBub3RlLmFiYz9cbiAgICAgICAgb2N0YXZlID0gaWYgbm90ZS5vY3RhdmU/IHRoZW4gbm90ZS5vY3RhdmUgZWxzZSBub3RlLnN0cmluZ1xuICAgICAgICBbbmV3X25vdGUsIG5ld19vY3RhdmUsIGFjY2lkZW50YWxdID0gQGdldE5vdGVGb3JBQkMobm90ZS5hYmMsIG9jdGF2ZSlcbiAgICAgICAgaWYgYWNjaWRlbnRhbD9cbiAgICAgICAgICBhY2MgPSBhY2NpZGVudGFsLnNwbGl0KFwiX1wiKVswXVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYWNjID0gXCJcIlxuXG4gICAgICAgIHBsYXlfbm90ZSA9IFwiI3tuZXdfbm90ZX0je2FjY31cIlxuICAgICAgICBub3RlLmZyZXQgPSAnWCcgdW5sZXNzIG5vdGUuZnJldD9cbiAgICAgIGVsc2UgaWYgbm90ZS5mcmV0P1xuICAgICAgICBbbmV3X25vdGUsIG5ld19vY3RhdmUsIGFjY2lkZW50YWxdID0gQGdldE5vdGVGb3JGcmV0KG5vdGUuZnJldCwgbm90ZS5zdHJpbmcpXG4gICAgICAgIHBsYXlfbm90ZSA9IEB0dW5pbmcuZ2V0Tm90ZUZvckZyZXQobm90ZS5mcmV0LCBub3RlLnN0cmluZykuc3BsaXQoXCIvXCIpWzBdXG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkFydGlzdEVycm9yXCIsIFwiTm8gbm90ZSBzcGVjaWZpZWRcIilcblxuICAgICAgcGxheV9vY3RhdmUgPSBwYXJzZUludChuZXdfb2N0YXZlLCAxMCkgKyBAY3VycmVudF9vY3RhdmVfc2hpZnRcblxuICAgICAgY3VycmVudF9kdXJhdGlvbiA9IGlmIG5vdGUudGltZT8gdGhlbiB7dGltZTogbm90ZS50aW1lLCBkb3Q6IG5vdGUuZG90fSBlbHNlIG51bGxcbiAgICAgIHNwZWNzW2N1cnJlbnRfcG9zaXRpb25dLnB1c2ggXCIje25ld19ub3RlfS8je25ld19vY3RhdmV9XCJcbiAgICAgIHBsYXlfbm90ZXNbY3VycmVudF9wb3NpdGlvbl0ucHVzaCBcIiN7cGxheV9ub3RlfS8je3BsYXlfb2N0YXZlfVwiXG4gICAgICBhY2NpZGVudGFsc1tjdXJyZW50X3Bvc2l0aW9uXS5wdXNoIGFjY2lkZW50YWxcbiAgICAgIHRhYl9zcGVjc1tjdXJyZW50X3Bvc2l0aW9uXS5wdXNoIHtmcmV0OiBub3RlLmZyZXQsIHN0cjogbm90ZS5zdHJpbmd9XG4gICAgICBhcnRpY3VsYXRpb25zW2N1cnJlbnRfcG9zaXRpb25dLnB1c2ggbm90ZS5hcnRpY3VsYXRpb24gaWYgbm90ZS5hcnRpY3VsYXRpb24/XG4gICAgICBkdXJhdGlvbnNbY3VycmVudF9wb3NpdGlvbl0gPSBjdXJyZW50X2R1cmF0aW9uXG4gICAgICBkZWNvcmF0b3JzW2N1cnJlbnRfcG9zaXRpb25dID0gbm90ZS5kZWNvcmF0b3IgaWYgbm90ZS5kZWNvcmF0b3I/XG5cbiAgICAgIGN1cnJlbnRfcG9zaXRpb24rK1xuXG4gICAgZm9yIHNwZWMsIGkgaW4gc3BlY3NcbiAgICAgIHNhdmVkX2R1cmF0aW9uID0gQGN1cnJlbnRfZHVyYXRpb25cbiAgICAgIEBzZXREdXJhdGlvbihkdXJhdGlvbnNbaV0udGltZSwgZHVyYXRpb25zW2ldLmRvdCkgaWYgZHVyYXRpb25zW2ldP1xuICAgICAgQGFkZFRhYk5vdGUgdGFiX3NwZWNzW2ldLCBwbGF5X25vdGVzW2ldXG4gICAgICBAYWRkU3RhdmVOb3RlIHtzcGVjOiBzcGVjLCBhY2NpZGVudGFsczogYWNjaWRlbnRhbHNbaV0sIHBsYXlfbm90ZTogcGxheV9ub3Rlc1tpXX0gaWYgc3RhdmUubm90ZT9cbiAgICAgIEBhZGRBcnRpY3VsYXRpb25zIGFydGljdWxhdGlvbnNbaV1cbiAgICAgIEBhZGREZWNvcmF0b3IgZGVjb3JhdG9yc1tpXSBpZiBkZWNvcmF0b3JzW2ldP1xuXG4gICAgaWYgY2hvcmRfYXJ0aWN1bGF0aW9uP1xuICAgICAgYXJ0ID0gW11cbiAgICAgIGFydC5wdXNoIGNob3JkX2FydGljdWxhdGlvbiBmb3IgbnVtIGluIFsxLi5udW1fbm90ZXNdXG4gICAgICBAYWRkQXJ0aWN1bGF0aW9ucyBhcnRcblxuICAgIEBhZGREZWNvcmF0b3IgY2hvcmRfZGVjb3JhdG9yIGlmIGNob3JkX2RlY29yYXRvcj9cblxuICBhZGROb3RlOiAobm90ZSkgLT5cbiAgICBAYWRkQ2hvcmQoW25vdGVdKVxuXG4gIGFkZFRleHRWb2ljZTogLT5cbiAgICBfLmxhc3QoQHN0YXZlcykudGV4dF92b2ljZXMucHVzaCBbXVxuXG4gIHNldFRleHRGb250OiAoZm9udCkgLT5cbiAgICBpZiBmb250P1xuICAgICAgcGFydHMgPSBmb250Lm1hdGNoKC8oW14tXSopLShbXi1dKiktKFteLl0qKS8pXG4gICAgICBpZiBwYXJ0cz9cbiAgICAgICAgQGN1c3RvbWl6YXRpb25zW1wiZm9udC1mYWNlXCJdID0gcGFydHNbMV1cbiAgICAgICAgQGN1c3RvbWl6YXRpb25zW1wiZm9udC1zaXplXCJdID0gcGFyc2VJbnQocGFydHNbMl0sIDEwKVxuICAgICAgICBAY3VzdG9taXphdGlvbnNbXCJmb250LXN0eWxlXCJdID0gcGFydHNbM11cblxuICBhZGRUZXh0Tm90ZTogKHRleHQsIHBvc2l0aW9uPTAsIGp1c3RpZmljYXRpb249XCJjZW50ZXJcIiwgc21vb3RoPXRydWUsIGlnbm9yZV90aWNrcz1mYWxzZSkgLT5cbiAgICB2b2ljZXMgPSBfLmxhc3QoQHN0YXZlcykudGV4dF92b2ljZXNcbiAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJBcnRpc3RFcnJvclwiLCBcIkNhbid0IGFkZCB0ZXh0IG5vdGUgd2l0aG91dCB0ZXh0IHZvaWNlXCIpIGlmIF8uaXNFbXB0eSh2b2ljZXMpXG5cbiAgICBmb250X2ZhY2UgPSBAY3VzdG9taXphdGlvbnNbXCJmb250LWZhY2VcIl1cbiAgICBmb250X3NpemUgPSBAY3VzdG9taXphdGlvbnNbXCJmb250LXNpemVcIl1cbiAgICBmb250X3N0eWxlID0gQGN1c3RvbWl6YXRpb25zW1wiZm9udC1zdHlsZVwiXVxuXG4gICAganVzdCA9IHN3aXRjaCBqdXN0aWZpY2F0aW9uXG4gICAgICB3aGVuIFwiY2VudGVyXCJcbiAgICAgICAgVmV4LkZsb3cuVGV4dE5vdGUuSnVzdGlmaWNhdGlvbi5DRU5URVJcbiAgICAgIHdoZW4gXCJsZWZ0XCJcbiAgICAgICAgVmV4LkZsb3cuVGV4dE5vdGUuSnVzdGlmaWNhdGlvbi5MRUZUXG4gICAgICB3aGVuIFwicmlnaHRcIlxuICAgICAgICBWZXguRmxvdy5UZXh0Tm90ZS5KdXN0aWZpY2F0aW9uLlJJR0hUXG4gICAgICBlbHNlXG4gICAgICAgIFZleC5GbG93LlRleHROb3RlLkp1c3RpZmljYXRpb24uQ0VOVEVSXG5cbiAgICBkdXJhdGlvbiA9IGlmIGlnbm9yZV90aWNrcyB0aGVuIFwiYlwiIGVsc2UgQGN1cnJlbnRfZHVyYXRpb25cblxuICAgIHN0cnVjdCA9XG4gICAgICB0ZXh0OiB0ZXh0XG4gICAgICBkdXJhdGlvbjogZHVyYXRpb25cbiAgICAgIHNtb290aDogc21vb3RoXG4gICAgICBpZ25vcmVfdGlja3M6IGlnbm9yZV90aWNrc1xuICAgICAgZm9udDpcbiAgICAgICAgZmFtaWx5OiBmb250X2ZhY2VcbiAgICAgICAgc2l6ZTogZm9udF9zaXplXG4gICAgICAgIHdlaWdodDogZm9udF9zdHlsZVxuXG4gICAgaWYgdGV4dFswXSA9PSBcIiNcIlxuICAgICAgc3RydWN0LmdseXBoID0gdGV4dFsxLi5dXG5cbiAgICBub3RlID0gbmV3IFZleC5GbG93LlRleHROb3RlKHN0cnVjdCkuXG4gICAgICBzZXRMaW5lKHBvc2l0aW9uKS5zZXRKdXN0aWZpY2F0aW9uKGp1c3QpXG5cbiAgICBfLmxhc3Qodm9pY2VzKS5wdXNoKG5vdGUpXG5cbiAgYWRkVm9pY2U6IChvcHRpb25zKSAtPlxuICAgIEBjbG9zZUJlbmRzKClcbiAgICBzdGF2ZSA9IF8ubGFzdChAc3RhdmVzKVxuICAgIHJldHVybiBAYWRkU3RhdmUob3B0aW9ucykgdW5sZXNzIHN0YXZlP1xuXG4gICAgdW5sZXNzIF8uaXNFbXB0eShzdGF2ZS50YWJfbm90ZXMpXG4gICAgICBzdGF2ZS50YWJfdm9pY2VzLnB1c2goc3RhdmUudGFiX25vdGVzKVxuICAgICAgc3RhdmUudGFiX25vdGVzID0gW11cblxuICAgIHVubGVzcyBfLmlzRW1wdHkoc3RhdmUubm90ZV9ub3RlcylcbiAgICAgIHN0YXZlLm5vdGVfdm9pY2VzLnB1c2goc3RhdmUubm90ZV9ub3RlcylcbiAgICAgIHN0YXZlLm5vdGVfbm90ZXMgPSBbXVxuXG4gIGFkZFN0YXZlOiAoZWxlbWVudCwgb3B0aW9ucykgLT5cbiAgICBvcHRzID1cbiAgICAgIHR1bmluZzogXCJzdGFuZGFyZFwiXG4gICAgICBjbGVmOiBcInRyZWJsZVwiXG4gICAgICBrZXk6IFwiQ1wiXG4gICAgICBub3RhdGlvbjogaWYgZWxlbWVudCA9PSBcInRhYnN0YXZlXCIgdGhlbiBcImZhbHNlXCIgZWxzZSBcInRydWVcIlxuICAgICAgdGFibGF0dXJlOiBpZiBlbGVtZW50ID09IFwic3RhdmVcIiB0aGVuIFwiZmFsc2VcIiBlbHNlIFwidHJ1ZVwiXG4gICAgICBzdHJpbmdzOiA2XG5cbiAgICBfLmV4dGVuZChvcHRzLCBvcHRpb25zKVxuICAgIEwgXCJhZGRTdGF2ZTogXCIsIGVsZW1lbnQsIG9wdHNcblxuICAgIHRhYl9zdGF2ZSA9IG51bGxcbiAgICBub3RlX3N0YXZlID0gbnVsbFxuXG4gICAgIyBUaGlzIGlzIHVzZWQgdG8gbGluZSB1cCB0YWJsYXR1cmUgYW5kIG5vdGF0aW9uLlxuICAgIHN0YXJ0X3ggPSBAeCArIEBjdXN0b21pemF0aW9uc1tcImNvbm5lY3Rvci1zcGFjZVwiXVxuICAgIHRhYnN0YXZlX3N0YXJ0X3ggPSA0MFxuXG4gICAgaWYgb3B0cy5ub3RhdGlvbiBpcyBcInRydWVcIlxuICAgICAgbm90ZV9zdGF2ZSA9IG5ldyBWZXguRmxvdy5TdGF2ZShzdGFydF94LCBAbGFzdF95LCBAY3VzdG9taXphdGlvbnMud2lkdGggLSAyMClcbiAgICAgIG5vdGVfc3RhdmUuYWRkQ2xlZihvcHRzLmNsZWYpIGlmIG9wdHMuY2xlZiBpc250IFwibm9uZVwiXG4gICAgICBub3RlX3N0YXZlLmFkZEtleVNpZ25hdHVyZShvcHRzLmtleSlcbiAgICAgIG5vdGVfc3RhdmUuYWRkVGltZVNpZ25hdHVyZShvcHRzLnRpbWUpIGlmIG9wdHMudGltZT9cblxuICAgICAgQGxhc3RfeSArPSBub3RlX3N0YXZlLmdldEhlaWdodCgpICtcbiAgICAgICAgICAgICAgICAgQG9wdGlvbnMubm90ZV9zdGF2ZV9sb3dlcl9zcGFjaW5nICtcbiAgICAgICAgICAgICAgICAgcGFyc2VJbnQoQGN1c3RvbWl6YXRpb25zW1wic3RhdmUtZGlzdGFuY2VcIl0sIDEwKVxuICAgICAgdGFic3RhdmVfc3RhcnRfeCA9IG5vdGVfc3RhdmUuZ2V0Tm90ZVN0YXJ0WCgpXG4gICAgICBAY3VycmVudF9jbGVmID0gaWYgb3B0cy5jbGVmIGlzIFwibm9uZVwiIHRoZW4gXCJ0cmVibGVcIiBlbHNlIG9wdHMuY2xlZlxuXG4gICAgaWYgb3B0cy50YWJsYXR1cmUgaXMgXCJ0cnVlXCJcbiAgICAgIHRhYl9zdGF2ZSA9IG5ldyBWZXguRmxvdy5UYWJTdGF2ZShzdGFydF94LCBAbGFzdF95LCBAY3VzdG9taXphdGlvbnMud2lkdGggLSAyMClcbiAgICAgICAgLnNldE51bUxpbmVzKG9wdHMuc3RyaW5ncylcbiAgICAgIHRhYl9zdGF2ZS5hZGRUYWJHbHlwaCgpIGlmIG9wdHMuY2xlZiBpc250IFwibm9uZVwiXG4gICAgICB0YWJfc3RhdmUuc2V0Tm90ZVN0YXJ0WCh0YWJzdGF2ZV9zdGFydF94KVxuICAgICAgQGxhc3RfeSArPSB0YWJfc3RhdmUuZ2V0SGVpZ2h0KCkgKyBAb3B0aW9ucy50YWJfc3RhdmVfbG93ZXJfc3BhY2luZ1xuXG4gICAgQGNsb3NlQmVuZHMoKVxuICAgIGJlYW1fZ3JvdXBzID0gVmV4LkZsb3cuQmVhbS5nZXREZWZhdWx0QmVhbUdyb3VwcyhvcHRzLnRpbWUpXG4gICAgQHN0YXZlcy5wdXNoIHtcbiAgICAgIHRhYjogdGFiX3N0YXZlLFxuICAgICAgbm90ZTogbm90ZV9zdGF2ZSxcbiAgICAgIHRhYl92b2ljZXM6IFtdLFxuICAgICAgbm90ZV92b2ljZXM6IFtdLFxuICAgICAgdGFiX25vdGVzOiBbXSxcbiAgICAgIG5vdGVfbm90ZXM6IFtdLFxuICAgICAgdGV4dF92b2ljZXM6IFtdLFxuICAgICAgYmVhbV9ncm91cHM6IGJlYW1fZ3JvdXBzXG4gICAgfVxuXG4gICAgQHR1bmluZy5zZXRUdW5pbmcob3B0cy50dW5pbmcpXG4gICAgQGtleV9tYW5hZ2VyLnNldEtleShvcHRzLmtleSlcblxuICAgIHJldHVyblxuXG4gIHJ1bkNvbW1hbmQ6IChsaW5lLCBfbD0wLCBfYz0wKSAtPlxuICAgIEwgXCJydW5Db21tYW5kOiBcIiwgbGluZVxuICAgIHdvcmRzID0gbGluZS5zcGxpdCgvXFxzKy8pXG4gICAgc3dpdGNoIHdvcmRzWzBdXG4gICAgICB3aGVuIFwib2N0YXZlLXNoaWZ0XCJcbiAgICAgICAgQGN1cnJlbnRfb2N0YXZlX3NoaWZ0ID0gcGFyc2VJbnQod29yZHNbMV0sIDEwKVxuICAgICAgICBMIFwiT2N0YXZlIHNoaWZ0OiBcIiwgQGN1cnJlbnRfb2N0YXZlX3NoaWZ0XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkFydGlzdEVycm9yXCIsIFwiSW52YWxpZCBjb21tYW5kICcje3dvcmRzWzBdfScgYXQgbGluZSAje19sfSBjb2x1bW4gI3tfY31cIilcblxubW9kdWxlLmV4cG9ydHMgPSBBcnRpc3RcbiIsIlZleCA9IHJlcXVpcmUgJ3ZleGZsb3cnXG5BcnRpc3QgPSByZXF1aXJlICcuL2FydGlzdC5jb2ZmZWUnXG5WZXhUYWIgPSByZXF1aXJlICcuL3ZleHRhYi5jb2ZmZWUnXG5QbGF5ZXIgPSByZXF1aXJlICcuL3BsYXllci5jb2ZmZWUnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBcnRpc3Q6IEFydGlzdFxuICBWZXhUYWI6IFZleFRhYlxuICBWZXg6IFZleFxuICBQbGF5ZXI6IFBsYXllclxufVxuIiwiIyBWZXhUYWIgUGxheWVyXG4jIENvcHlyaWdodCAyMDEyIE1vaGl0IENoZXBwdWRpcmEgPG1vaGl0QG11dGhhbm5hLmNvbT5cbiNcbiMgVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIHRoZSBlbGVtZW50c1xuIyBwYXJzZWQgYnkgVmV4LkZsb3cuVmV4VGFiLlxuXG5WZXggPSByZXF1aXJlICd2ZXhmbG93J1xuXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG4kID0gcmVxdWlyZSAnanF1ZXJ5J1xucGFwZXIgPSByZXF1aXJlICdwYXBlcidcblxuY2xhc3MgVmV4LkZsb3cuUGxheWVyXG4gIEBERUJVRyA9IGZhbHNlXG4gIEBJTlNUUlVNRU5UU19MT0FERUQgPSB7fVxuICBMID0gKGFyZ3MuLi4pIC0+IGNvbnNvbGU/LmxvZyhcIihWZXguRmxvdy5QbGF5ZXIpXCIsIGFyZ3MuLi4pIGlmIFZleC5GbG93LlBsYXllci5ERUJVR1xuXG4gIEZyYWN0aW9uID0gVmV4LkZsb3cuRnJhY3Rpb25cbiAgUkVTT0xVVElPTiA9IFZleC5GbG93LlJFU09MVVRJT05cbiAgbm90ZVZhbHVlcyA9IFZleC5GbG93Lk11c2ljLm5vdGVWYWx1ZXNcbiAgZHJhd0RvdCA9IFZleC5kcmF3RG90XG5cbiAgSU5TVFJVTUVOVFMgPSB7XG4gICAgXCJhY291c3RpY19ncmFuZF9waWFub1wiOiAwLFxuICAgIFwiYWNvdXN0aWNfZ3VpdGFyX255bG9uXCI6IDI0LFxuICAgIFwiYWNvdXN0aWNfZ3VpdGFyX3N0ZWVsXCI6IDI1LFxuICAgIFwiZWxlY3RyaWNfZ3VpdGFyX2phenpcIjogMjYsXG4gICAgXCJkaXN0b3J0aW9uX2d1aXRhclwiOiAzMCxcbiAgICBcImVsZWN0cmljX2Jhc3NfZmluZ2VyXCI6IDMzLFxuICAgIFwiZWxlY3RyaWNfYmFzc19waWNrXCI6IDM0LFxuICAgIFwidHJ1bXBldFwiOiA1NixcbiAgICBcImJyYXNzX3NlY3Rpb25cIjogNjEsXG4gICAgXCJzb3ByYW5vX3NheFwiOiA2NCxcbiAgICBcImFsdG9fc2F4XCI6IDY1LFxuICAgIFwidGVub3Jfc2F4XCI6IDY2LFxuICAgIFwiYmFyaXRvbmVfc2F4XCI6IDY3LFxuICAgIFwiZmx1dGVcIjogNzMsXG4gICAgXCJzeW50aF9kcnVtXCI6IDExOFxuICB9XG5cbiAgY29uc3RydWN0b3I6IChAYXJ0aXN0LCBvcHRpb25zKSAtPlxuICAgIEwgXCJJbml0aWFsaXppbmcgcGxheWVyOiBcIiwgb3B0aW9uc1xuICAgIEBvcHRpb25zID1cbiAgICAgIGluc3RydW1lbnQ6IFwiYWNvdXN0aWNfZ3JhbmRfcGlhbm9cIlxuICAgICAgdGVtcG86IDEyMFxuICAgICAgc2hvd19jb250cm9sczogdHJ1ZVxuICAgICAgc291bmRmb250X3VybDogXCIuLi9zb3VuZGZvbnQvXCJcbiAgICAgIG92ZXJsYXlfY2xhc3M6IFwidmV4dGFiLXBsYXllclwiXG5cbiAgICBfLmV4dGVuZChAb3B0aW9ucywgb3B0aW9ucykgaWYgb3B0aW9ucz9cbiAgICBMIFwiVXNpbmcgc291bmRmb250cyBpbjogI3tAb3B0aW9ucy5zb3VuZGZvbnRfdXJsfVwiXG4gICAgQGludGVydmFsX2lkID0gbnVsbFxuICAgIEBwYXBlciA9IG51bGxcbiAgICBAcmVzZXQoKVxuXG4gIHNldEFydGlzdDogKGFydGlzdCkgLT5cbiAgICBAYXJ0aXN0ID0gYXJ0aXN0XG4gICAgQHJlc2V0KClcblxuICBzZXRUZW1wbzogKHRlbXBvKSAtPlxuICAgIEwgXCJOZXcgdGVtcG86IFwiLCB0ZW1wb1xuICAgIEBvcHRpb25zLnRlbXBvID0gdGVtcG9cbiAgICBAcmVzZXQoKVxuXG4gIHNldEluc3RydW1lbnQ6IChpbnN0cnVtZW50KSAtPlxuICAgIEwgXCJOZXcgaW5zdHJ1bWVudDogXCIsIGluc3RydW1lbnRcbiAgICBpZiBpbnN0cnVtZW50IG5vdCBpbiBfLmtleXMoSU5TVFJVTUVOVFMpXG4gICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJQbGF5ZXJFcnJvclwiLCBcIkludmFsaWQgaW5zdHJ1bWVudDogXCIgKyBpbnN0cnVtZW50KVxuICAgIEBvcHRpb25zLmluc3RydW1lbnQgPSBpbnN0cnVtZW50XG4gICAgQHJlc2V0KClcblxuICByZXNldDogLT5cbiAgICBAYXJ0aXN0LmF0dGFjaFBsYXllcih0aGlzKVxuICAgIEB0aWNrX25vdGVzID0ge31cbiAgICBAYWxsX3RpY2tzID0gW11cbiAgICBAdHBtID0gQG9wdGlvbnMudGVtcG8gKiAoUkVTT0xVVElPTiAvIDQpXG4gICAgQHJlZnJlc2hfcmF0ZSA9IDI1ICNtczogNTAgPSAyMGh6XG4gICAgQHRpY2tzX3Blcl9yZWZyZXNoID0gQHRwbSAvICg2MCAqICgxMDAwL0ByZWZyZXNoX3JhdGUpKVxuICAgIEB0b3RhbF90aWNrcyA9IDBcbiAgICBpZiBAbWFya2VyP1xuICAgICAgQG1hcmtlci5yZW1vdmUoKVxuICAgICAgQG1hcmtlciA9IG51bGxcbiAgICBAc3RvcCgpXG5cbiAgZ2V0T3ZlcmxheSA9IChjb250ZXh0LCBzY2FsZSwgb3ZlcmxheV9jbGFzcykgLT5cbiAgICBjYW52YXMgPSBjb250ZXh0LmNhbnZhc1xuICAgIGhlaWdodCA9IGNhbnZhcy5oZWlnaHRcbiAgICB3aWR0aCA9IGNhbnZhcy53aWR0aFxuXG4gICAgb3ZlcmxheSA9ICQoJzxjYW52YXM+JylcbiAgICBvdmVybGF5LmNzcyhcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIilcbiAgICBvdmVybGF5LmNzcyhcImxlZnRcIiwgMClcbiAgICBvdmVybGF5LmNzcyhcInRvcFwiLCAwKVxuICAgIG92ZXJsYXkuYWRkQ2xhc3Mob3ZlcmxheV9jbGFzcylcblxuICAgICQoY2FudmFzKS5hZnRlcihvdmVybGF5KVxuICAgIGN0eCA9IFZleC5GbG93LlJlbmRlcmVyLmdldENhbnZhc0NvbnRleHQob3ZlcmxheS5nZXQoMCksIHdpZHRoLCBoZWlnaHQpXG4gICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSlcblxuICAgIHBzID0gbmV3IHBhcGVyLlBhcGVyU2NvcGUoKVxuICAgIHBzLnNldHVwKG92ZXJsYXkuZ2V0KDApKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcGVyOiBwc1xuICAgICAgY2FudmFzOiBvdmVybGF5LmdldCgwKVxuICAgIH1cblxuICByZW1vdmVDb250cm9sczogLT5cbiAgICBAcGxheV9idXR0b24ucmVtb3ZlKCkgaWYgQHBsYXlfYnV0dG9uP1xuICAgIEBzdG9wX2J1dHRvbi5yZW1vdmUoKSBpZiBAc3RvcF9idXR0b24/XG4gICAgQHBhcGVyLnZpZXcuZHJhdygpIGlmIEBwYXBlcj9cblxuICByZW5kZXI6IC0+XG4gICAgQHJlc2V0KClcbiAgICBkYXRhID0gQGFydGlzdC5nZXRQbGF5ZXJEYXRhKClcbiAgICBAc2NhbGUgPSBkYXRhLnNjYWxlXG5cbiAgICBpZiBub3QgQHBhcGVyXG4gICAgICBvdmVybGF5ID0gZ2V0T3ZlcmxheShkYXRhLmNvbnRleHQsIGRhdGEuc2NhbGUsIEBvcHRpb25zLm92ZXJsYXlfY2xhc3MpXG4gICAgICBAcGFwZXIgPSBvdmVybGF5LnBhcGVyXG5cbiAgICBAbWFya2VyID0gbmV3IEBwYXBlci5QYXRoLlJlY3RhbmdsZSgwLDAsMTMsODUpXG4gICAgQGxvYWRpbmdfbWVzc2FnZSA9IG5ldyBAcGFwZXIuUG9pbnRUZXh0KDM1LCAxMilcblxuICAgIGlmIEBvcHRpb25zLnNob3dfY29udHJvbHNcbiAgICAgIEBwbGF5X2J1dHRvbiA9IG5ldyBAcGFwZXIuUGF0aC5SZWd1bGFyUG9seWdvbihuZXcgQHBhcGVyLlBvaW50KDI1LDEwKSwgMywgNywgNylcbiAgICAgIEBwbGF5X2J1dHRvbi5maWxsQ29sb3IgPSAnIzM5NidcbiAgICAgIEBwbGF5X2J1dHRvbi5vcGFjaXR5ID0gMC44XG4gICAgICBAcGxheV9idXR0b24ucm90YXRlKDkwKVxuICAgICAgQHBsYXlfYnV0dG9uLm9uTW91c2VVcCA9IChldmVudCkgPT5cbiAgICAgICAgQHBsYXkoKVxuXG4gICAgICBAc3RvcF9idXR0b24gPSBuZXcgQHBhcGVyLlBhdGguUmVjdGFuZ2xlKDMsMywxMCwxMClcbiAgICAgIEBzdG9wX2J1dHRvbi5maWxsQ29sb3IgPSAnIzM5NidcbiAgICAgIEBzdG9wX2J1dHRvbi5vcGFjaXR5ID0gMC44XG4gICAgICBAc3RvcF9idXR0b24ub25Nb3VzZVVwID0gKGV2ZW50KSA9PlxuICAgICAgICBAc3RvcCgpXG5cbiAgICBAcGFwZXIudmlldy5kcmF3KClcbiAgICBzdGF2ZXMgPSBkYXRhLnZvaWNlc1xuXG4gICAgdG90YWxfdGlja3MgPSBuZXcgRnJhY3Rpb24oMCwgMSlcbiAgICBmb3Igdm9pY2VfZ3JvdXAgaW4gc3RhdmVzXG4gICAgICBtYXhfdm9pY2VfdGljayA9IG5ldyBGcmFjdGlvbigwLCAxKVxuICAgICAgZm9yIHZvaWNlLCBpIGluIHZvaWNlX2dyb3VwXG4gICAgICAgIHRvdGFsX3ZvaWNlX3RpY2tzID0gbmV3IEZyYWN0aW9uKDAsIDEpXG5cbiAgICAgICAgZm9yIG5vdGUgaW4gdm9pY2UuZ2V0VGlja2FibGVzKClcbiAgICAgICAgICB1bmxlc3Mgbm90ZS5zaG91bGRJZ25vcmVUaWNrcygpXG4gICAgICAgICAgICBhYnNfdGljayA9IHRvdGFsX3RpY2tzLmNsb25lKClcbiAgICAgICAgICAgIGFic190aWNrLmFkZCh0b3RhbF92b2ljZV90aWNrcylcbiAgICAgICAgICAgIGFic190aWNrLnNpbXBsaWZ5KClcbiAgICAgICAgICAgIGtleSA9IGFic190aWNrLnRvU3RyaW5nKClcblxuICAgICAgICAgICAgaWYgXy5oYXMoQHRpY2tfbm90ZXMsIGtleSlcbiAgICAgICAgICAgICAgQHRpY2tfbm90ZXNba2V5XS5ub3Rlcy5wdXNoKG5vdGUpXG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIEB0aWNrX25vdGVzW2tleV0gPVxuICAgICAgICAgICAgICAgIHRpY2s6IGFic190aWNrXG4gICAgICAgICAgICAgICAgdmFsdWU6IGFic190aWNrLnZhbHVlKClcbiAgICAgICAgICAgICAgICBub3RlczogW25vdGVdXG5cbiAgICAgICAgICAgIHRvdGFsX3ZvaWNlX3RpY2tzLmFkZChub3RlLmdldFRpY2tzKCkpXG5cbiAgICAgICAgaWYgdG90YWxfdm9pY2VfdGlja3MudmFsdWUoKSA+IG1heF92b2ljZV90aWNrLnZhbHVlKClcbiAgICAgICAgICBtYXhfdm9pY2VfdGljay5jb3B5KHRvdGFsX3ZvaWNlX3RpY2tzKVxuXG4gICAgICB0b3RhbF90aWNrcy5hZGQobWF4X3ZvaWNlX3RpY2spXG5cbiAgICBAYWxsX3RpY2tzID0gXy5zb3J0QnkoXy52YWx1ZXMoQHRpY2tfbm90ZXMpLCAodGljaykgLT4gdGljay52YWx1ZSlcbiAgICBAdG90YWxfdGlja3MgPSBfLmxhc3QoQGFsbF90aWNrcylcbiAgICBMIEBhbGxfdGlja3NcblxuICB1cGRhdGVNYXJrZXI6ICh4LCB5KSAtPlxuICAgIEBtYXJrZXIuZmlsbENvbG9yID0gJyMzNjknXG4gICAgQG1hcmtlci5vcGFjaXR5ID0gMC4yXG4gICAgQG1hcmtlci5zZXRQb3NpdGlvbihuZXcgQHBhcGVyLlBvaW50KHggKiBAc2NhbGUsIHkgKiBAc2NhbGUpKVxuICAgIEBwYXBlci52aWV3LmRyYXcoKVxuXG4gIHBsYXlOb3RlOiAobm90ZXMpIC0+XG4gICAgTCBcIigje0BjdXJyZW50X3RpY2tzfSkgcGxheU5vdGU6IFwiLCBub3Rlc1xuXG4gICAgZm9yIG5vdGUgaW4gbm90ZXNcbiAgICAgIHggPSBub3RlLmdldEFic29sdXRlWCgpICsgNFxuICAgICAgeSA9IG5vdGUuZ2V0U3RhdmUoKS5nZXRZRm9yTGluZSgyKVxuICAgICAgQHVwZGF0ZU1hcmtlcih4LCB5KSBpZiBAcGFwZXI/XG4gICAgICBjb250aW51ZSBpZiBub3RlLmlzUmVzdCgpXG5cbiAgICAgIGtleXMgPSBub3RlLmdldFBsYXlOb3RlKClcbiAgICAgIGR1cmF0aW9uID0gbm90ZS5nZXRUaWNrcygpLnZhbHVlKCkgLyAoQHRwbS82MClcbiAgICAgIGZvciBrZXkgaW4ga2V5c1xuICAgICAgICBbbm90ZSwgb2N0YXZlXSA9IGtleS5zcGxpdChcIi9cIilcbiAgICAgICAgbm90ZSA9IG5vdGUudHJpbSgpLnRvTG93ZXJDYXNlKClcbiAgICAgICAgbm90ZV92YWx1ZSA9IG5vdGVWYWx1ZXNbbm90ZV1cbiAgICAgICAgY29udGludWUgdW5sZXNzIG5vdGVfdmFsdWU/XG5cbiAgICAgICAgbWlkaV9ub3RlID0gKDI0ICsgKG9jdGF2ZSAqIDEyKSkgKyBub3RlVmFsdWVzW25vdGVdLmludF92YWxcbiAgICAgICAgTUlESS5ub3RlT24oMCwgbWlkaV9ub3RlLCAxMjcsIDApXG4gICAgICAgIE1JREkubm90ZU9mZigwLCBtaWRpX25vdGUsIGR1cmF0aW9uKVxuXG4gIHJlZnJlc2g6IC0+XG4gICAgaWYgQGRvbmVcbiAgICAgIEBzdG9wKClcbiAgICAgIHJldHVyblxuXG4gICAgQGN1cnJlbnRfdGlja3MgKz0gQHRpY2tzX3Blcl9yZWZyZXNoXG5cbiAgICBpZiBAY3VycmVudF90aWNrcyA+PSBAbmV4dF9ldmVudF90aWNrIGFuZCBAYWxsX3RpY2tzLmxlbmd0aCA+IDBcbiAgICAgIEBwbGF5Tm90ZSBAYWxsX3RpY2tzW0BuZXh0X2luZGV4XS5ub3Rlc1xuICAgICAgQG5leHRfaW5kZXgrK1xuICAgICAgaWYgQG5leHRfaW5kZXggPj0gQGFsbF90aWNrcy5sZW5ndGhcbiAgICAgICAgQGRvbmUgPSB0cnVlXG4gICAgICBlbHNlXG4gICAgICAgIEBuZXh0X2V2ZW50X3RpY2sgPSBAYWxsX3RpY2tzW0BuZXh0X2luZGV4XS50aWNrLnZhbHVlKClcblxuICBzdG9wOiAtPlxuICAgIEwgXCJTdG9wXCJcbiAgICB3aW5kb3cuY2xlYXJJbnRlcnZhbChAaW50ZXJ2YWxfaWQpIGlmIEBpbnRlcnZhbF9pZD9cbiAgICBAcGxheV9idXR0b24uZmlsbENvbG9yID0gJyMzOTYnIGlmIEBwbGF5X2J1dHRvbj9cbiAgICBAcGFwZXIudmlldy5kcmF3KCkgaWYgQHBhcGVyP1xuICAgIEBpbnRlcnZhbF9pZCA9IG51bGxcbiAgICBAY3VycmVudF90aWNrcyA9IDBcbiAgICBAbmV4dF9ldmVudF90aWNrID0gMFxuICAgIEBuZXh0X2luZGV4ID0gMFxuICAgIEBkb25lID0gZmFsc2VcblxuICBzdGFydDogLT5cbiAgICBAc3RvcCgpXG4gICAgTCBcIlN0YXJ0XCJcbiAgICBAcGxheV9idXR0b24uZmlsbENvbG9yID0gJyNhMzYnIGlmIEBwbGF5X2J1dHRvbj9cbiAgICBNSURJLnByb2dyYW1DaGFuZ2UoMCwgSU5TVFJVTUVOVFNbQG9wdGlvbnMuaW5zdHJ1bWVudF0pXG4gICAgQHJlbmRlcigpICMgdHJ5IHRvIHVwZGF0ZSwgbWF5YmUgbm90ZXMgd2VyZSBjaGFuZ2VkIGR5bmFtaWNhbGx5XG4gICAgQGludGVydmFsX2lkID0gd2luZG93LnNldEludGVydmFsKCgoKSA9PiBAcmVmcmVzaCgpKSwgQHJlZnJlc2hfcmF0ZSlcblxuICBwbGF5OiAtPlxuICAgIEwgXCJQbGF5OiBcIiwgQHJlZnJlc2hfcmF0ZSwgQHRpY2tzX3Blcl9yZWZyZXNoXG4gICAgaWYgVmV4LkZsb3cuUGxheWVyLklOU1RSVU1FTlRTX0xPQURFRFtAb3B0aW9ucy5pbnN0cnVtZW50XSBhbmQgbm90IEBsb2FkaW5nXG4gICAgICBAc3RhcnQoKVxuICAgIGVsc2VcbiAgICAgIEwgXCJMb2FkaW5nIGluc3RydW1lbnRzLi4uXCJcbiAgICAgIEBsb2FkaW5nX21lc3NhZ2UuY29udGVudCA9IFwiTG9hZGluZyBpbnN0cnVtZW50cy4uLlwiXG4gICAgICBAbG9hZGluZ19tZXNzYWdlLmZpbGxDb2xvciA9IFwiZ3JlZW5cIlxuICAgICAgQGxvYWRpbmcgPSB0cnVlXG4gICAgICBAcGFwZXIudmlldy5kcmF3KClcblxuICAgICAgTUlESS5sb2FkUGx1Z2luXG4gICAgICAgIHNvdW5kZm9udFVybDogQG9wdGlvbnMuc291bmRmb250X3VybFxuICAgICAgICBpbnN0cnVtZW50czogW0BvcHRpb25zLmluc3RydW1lbnRdXG4gICAgICAgIGNhbGxiYWNrOiAoKSA9PlxuICAgICAgICAgIGNvbnNvbGUubG9nKFwibG9hZFBsdWdpbiBpcyBzdWNjY2VzZnVsbHkgY2FsbGluZyBiYWNrLlwiKVxuICAgICAgICAgIFZleC5GbG93LlBsYXllci5JTlNUUlVNRU5UU19MT0FERURbQG9wdGlvbnMuaW5zdHJ1bWVudF0gPSB0cnVlXG4gICAgICAgICAgQGxvYWRpbmcgPSBmYWxzZVxuICAgICAgICAgIEBsb2FkaW5nX21lc3NhZ2UuY29udGVudCA9IFwiXCJcbiAgICAgICAgICBAc3RhcnQoKVxuXG5tb2R1bGUuZXhwb3J0cyA9IFZleC5GbG93LlBsYXllclxuXG4iLCIjIFZleC5GbG93LlZleFRhYlxuIyBDb3B5cmlnaHQgMjAxMiBNb2hpdCBDaGVwcHVkaXJhIDxtb2hpdEBtdXRoYW5uYS5jb20+XG4jXG4jIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB0aGUgc2VtYW50aWMgYW5hbHlzaXMgb2YgdGhlIEppc29uXG4jIG91dHB1dCwgYW5kIGdlbmVyYXRlcyBlbGVtZW50cyB0aGF0IGNhbiBiZSB1c2VkIGJ5XG4jIFZleC5GbG93LkFydGlzdCB0byByZW5kZXIgdGhlIG5vdGF0aW9uLlxuIyBwYXJzZWQgYnkgVmV4LkZsb3cuVmV4VGFiLlxuXG5WZXggPSByZXF1aXJlICd2ZXhmbG93J1xuXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG5wYXJzZXIgPSByZXF1aXJlICcuLi9idWlsZC92ZXh0YWItamlzb24uanMnXG5cbmNsYXNzIFZleFRhYlxuICBAREVCVUcgPSBmYWxzZVxuICBMID0gKGFyZ3MuLi4pIC0+IGNvbnNvbGU/LmxvZyhcIihWZXguRmxvdy5WZXhUYWIpXCIsIGFyZ3MuLi4pIGlmIFZleFRhYi5ERUJVR1xuXG4gICMgUHJpdmF0ZSBtZXRob2RzXG4gIG5ld0Vycm9yID0gKG9iamVjdCwgbXNnKSAtPlxuICAgIG5ldyBWZXguUkVSUihcIlBhcnNlRXJyb3JcIixcbiAgICAgICAgICAgICAgICAgXCIje21zZ30gaW4gbGluZSAje29iamVjdC5fbH0gY29sdW1uICN7b2JqZWN0Ll9jfVwiKVxuXG4gICMgUHVibGljIG1ldGhvZHNcbiAgY29uc3RydWN0b3I6IChAYXJ0aXN0KSAtPlxuICAgIEByZXNldCgpXG5cbiAgcmVzZXQ6IC0+XG4gICAgQHZhbGlkID0gZmFsc2VcbiAgICBAZWxlbWVudHMgPSBmYWxzZVxuXG4gIGlzVmFsaWQ6IC0+IEB2YWxpZFxuXG4gIGdldEFydGlzdDogLT4gcmV0dXJuIEBhcnRpc3RcblxuICBwYXJzZVN0YXZlT3B0aW9uczogKG9wdGlvbnMpIC0+XG4gICAgcGFyYW1zID0ge31cbiAgICByZXR1cm4gcGFyYW1zIHVubGVzcyBvcHRpb25zP1xuXG4gICAgbm90YXRpb25fb3B0aW9uID0gbnVsbFxuICAgIGZvciBvcHRpb24gaW4gb3B0aW9uc1xuICAgICAgZXJyb3IgPSAobXNnKSAtPiBuZXdFcnJvcihvcHRpb24sIG1zZylcbiAgICAgIHBhcmFtc1tvcHRpb24ua2V5XSA9IG9wdGlvbi52YWx1ZVxuICAgICAgc3dpdGNoIG9wdGlvbi5rZXlcbiAgICAgICAgd2hlbiBcIm5vdGF0aW9uXCIsIFwidGFibGF0dXJlXCJcbiAgICAgICAgICBub3RhdGlvbl9vcHRpb24gPSBvcHRpb25cbiAgICAgICAgICB0aHJvdyBlcnJvcihcIicje29wdGlvbi5rZXl9JyBtdXN0IGJlICd0cnVlJyBvciAnZmFsc2UnXCIpIGlmIG9wdGlvbi52YWx1ZSBub3QgaW4gW1widHJ1ZVwiLCBcImZhbHNlXCJdXG4gICAgICAgIHdoZW4gXCJrZXlcIlxuICAgICAgICAgIHRocm93IGVycm9yKFwiSW52YWxpZCBrZXkgc2lnbmF0dXJlICcje29wdGlvbi52YWx1ZX0nXCIpIHVubGVzcyBfLmhhcyhWZXguRmxvdy5rZXlTaWduYXR1cmUua2V5U3BlY3MsIG9wdGlvbi52YWx1ZSlcbiAgICAgICAgd2hlbiBcImNsZWZcIlxuICAgICAgICAgIGNsZWZzID0gW1widHJlYmxlXCIsIFwiYmFzc1wiLCBcInRlbm9yXCIsIFwiYWx0b1wiLCBcInBlcmN1c3Npb25cIiwgXCJub25lXCJdXG4gICAgICAgICAgdGhyb3cgZXJyb3IoXCInY2xlZicgbXVzdCBiZSBvbmUgb2YgI3tjbGVmcy5qb2luKCcsICcpfVwiKSBpZiBvcHRpb24udmFsdWUgbm90IGluIGNsZWZzXG4gICAgICAgIHdoZW4gXCJ2b2ljZVwiXG4gICAgICAgICAgdm9pY2VzID0gW1widG9wXCIsIFwiYm90dG9tXCIsIFwibmV3XCJdXG4gICAgICAgICAgdGhyb3cgZXJyb3IoXCIndm9pY2UnIG11c3QgYmUgb25lIG9mICN7dm9pY2VzLmpvaW4oJywgJyl9XCIpIGlmIG9wdGlvbi52YWx1ZSBub3QgaW4gdm9pY2VzXG4gICAgICAgIHdoZW4gXCJ0aW1lXCJcbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIG5ldyBWZXguRmxvdy5UaW1lU2lnbmF0dXJlKG9wdGlvbi52YWx1ZSlcbiAgICAgICAgICBjYXRjaCBlXG4gICAgICAgICAgICB0aHJvdyBlcnJvcihcIkludmFsaWQgdGltZSBzaWduYXR1cmU6ICcje29wdGlvbi52YWx1ZX0nXCIpXG4gICAgICAgIHdoZW4gXCJ0dW5pbmdcIlxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbmV3IFZleC5GbG93LlR1bmluZyhvcHRpb24udmFsdWUpXG4gICAgICAgICAgY2F0Y2ggZVxuICAgICAgICAgICAgdGhyb3cgZXJyb3IoXCJJbnZhbGlkIHR1bmluZzogJyN7b3B0aW9uLnZhbHVlfSdcIilcbiAgICAgICAgd2hlbiBcInN0cmluZ3NcIlxuICAgICAgICAgIG51bV9zdHJpbmdzID0gcGFyc2VJbnQob3B0aW9uLnZhbHVlKVxuICAgICAgICAgIHRocm93IGVycm9yKFwiSW52YWxpZCBudW1iZXIgb2Ygc3RyaW5nczogI3tudW1fc3RyaW5nc31cIikgaWYgKG51bV9zdHJpbmdzIDwgNCBvciBudW1fc3RyaW5ncyA+IDgpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBlcnJvcihcIkludmFsaWQgb3B0aW9uICcje29wdGlvbi5rZXl9J1wiKVxuXG4gICAgaWYgcGFyYW1zLm5vdGF0aW9uID09IFwiZmFsc2VcIiBhbmQgcGFyYW1zLnRhYmxhdHVyZSA9PSBcImZhbHNlXCJcbiAgICAgIHRocm93IG5ld0Vycm9yKG5vdGF0aW9uX29wdGlvbiwgXCJCb3RoICdub3RhdGlvbicgYW5kICd0YWJsYXR1cmUnIGNhbid0IGJlIGludmlzaWJsZVwiKVxuXG4gICAgcmV0dXJuIHBhcmFtc1xuXG4gIHBhcnNlQ29tbWFuZDogKGVsZW1lbnQpIC0+XG4gICAgaWYgZWxlbWVudC5jb21tYW5kIGlzIFwiYmFyXCJcbiAgICAgIEBhcnRpc3QuYWRkQmFyKGVsZW1lbnQudHlwZSlcblxuICAgIGlmIGVsZW1lbnQuY29tbWFuZCBpcyBcInR1cGxldFwiXG4gICAgICBAYXJ0aXN0Lm1ha2VUdXBsZXRzKGVsZW1lbnQucGFyYW1zLnR1cGxldCwgZWxlbWVudC5wYXJhbXMubm90ZXMpXG5cbiAgICBpZiBlbGVtZW50LmNvbW1hbmQgaXMgXCJhbm5vdGF0aW9uc1wiXG4gICAgICBAYXJ0aXN0LmFkZEFubm90YXRpb25zKGVsZW1lbnQucGFyYW1zKVxuXG4gICAgaWYgZWxlbWVudC5jb21tYW5kIGlzIFwicmVzdFwiXG4gICAgICBAYXJ0aXN0LmFkZFJlc3QoZWxlbWVudC5wYXJhbXMpXG5cbiAgICBpZiBlbGVtZW50LmNvbW1hbmQgaXMgXCJjb21tYW5kXCJcbiAgICAgIEBhcnRpc3QucnVuQ29tbWFuZChlbGVtZW50LnBhcmFtcywgZWxlbWVudC5fbCwgZWxlbWVudC5fYylcblxuICBwYXJzZUNob3JkOiAoZWxlbWVudCkgLT5cbiAgICBMIFwicGFyc2VDaG9yZDpcIiwgZWxlbWVudFxuICAgIEBhcnRpc3QuYWRkQ2hvcmQoXG4gICAgICBfLm1hcChlbGVtZW50LmNob3JkLFxuICAgICAgICAgICAgKG5vdGUpLT4gXy5waWNrKG5vdGUsICd0aW1lJywgJ2RvdCcsICdmcmV0JywgJ2FiYycsICdvY3RhdmUnLCAnc3RyaW5nJywgJ2FydGljdWxhdGlvbicsICdkZWNvcmF0b3InKSksXG4gICAgICBlbGVtZW50LmFydGljdWxhdGlvbiwgZWxlbWVudC5kZWNvcmF0b3IpXG5cbiAgcGFyc2VGcmV0OiAobm90ZSkgLT5cbiAgICBAYXJ0aXN0LmFkZE5vdGUoXy5waWNrKFxuICAgICAgbm90ZSwgJ3RpbWUnLCAnZG90JywgJ2ZyZXQnLCAnc3RyaW5nJywgJ2FydGljdWxhdGlvbicsICdkZWNvcmF0b3InKSlcblxuICBwYXJzZUFCQzogKG5vdGUpIC0+XG4gICAgQGFydGlzdC5hZGROb3RlKF8ucGljayhcbiAgICAgIG5vdGUsICd0aW1lJywgJ2RvdCcsICdmcmV0JywgJ2FiYycsICdvY3RhdmUnLCAnc3RyaW5nJywgJ2FydGljdWxhdGlvbicsICdkZWNvcmF0b3InKSlcblxuICBwYXJzZVN0YXZlRWxlbWVudHM6IChub3RlcykgLT5cbiAgICBMIFwicGFyc2VTdGF2ZUVsZW1lbnRzOlwiLCBub3Rlc1xuICAgIGZvciBlbGVtZW50IGluIG5vdGVzXG4gICAgICBpZiBlbGVtZW50LnRpbWVcbiAgICAgICAgQGFydGlzdC5zZXREdXJhdGlvbihlbGVtZW50LnRpbWUsIGVsZW1lbnQuZG90KVxuXG4gICAgICBpZiBlbGVtZW50LmNvbW1hbmRcbiAgICAgICAgQHBhcnNlQ29tbWFuZChlbGVtZW50KVxuXG4gICAgICBpZiBlbGVtZW50LmNob3JkXG4gICAgICAgIEBwYXJzZUNob3JkKGVsZW1lbnQpXG5cbiAgICAgIGlmIGVsZW1lbnQuYWJjXG4gICAgICAgIEBwYXJzZUFCQyhlbGVtZW50KVxuICAgICAgZWxzZSBpZiBlbGVtZW50LmZyZXRcbiAgICAgICAgQHBhcnNlRnJldChlbGVtZW50KVxuXG4gIHBhcnNlU3RhdmVUZXh0OiAodGV4dF9saW5lKSAtPlxuICAgIEBhcnRpc3QuYWRkVGV4dFZvaWNlKCkgdW5sZXNzIF8uaXNFbXB0eSh0ZXh0X2xpbmUpXG5cbiAgICBwb3NpdGlvbiA9IDBcbiAgICBqdXN0aWZpY2F0aW9uID0gXCJjZW50ZXJcIlxuICAgIHNtb290aCA9IHRydWVcbiAgICBmb250ID0gbnVsbFxuXG4gICAgYmFydGV4dCA9ID0+IEBhcnRpc3QuYWRkVGV4dE5vdGUoXCJcIiwgMCwganVzdGlmaWNhdGlvbiwgZmFsc2UsIHRydWUpXG4gICAgY3JlYXRlTm90ZSA9ICh0ZXh0KSA9PlxuICAgICAgaWdub3JlX3RpY2tzID0gZmFsc2VcbiAgICAgIGlmIHRleHRbMF0gPT0gXCJ8XCJcbiAgICAgICAgaWdub3JlX3RpY2tzID0gdHJ1ZVxuICAgICAgICB0ZXh0ID0gdGV4dFsxLi5dXG5cbiAgICAgIHRyeVxuICAgICAgICBAYXJ0aXN0LmFkZFRleHROb3RlKHRleHQsIHBvc2l0aW9uLCBqdXN0aWZpY2F0aW9uLCBzbW9vdGgsIGlnbm9yZV90aWNrcylcbiAgICAgIGNhdGNoIGVcbiAgICAgICAgdGhyb3cgbmV3RXJyb3Ioc3RyLCBcIkJhZCB0ZXh0IG9yIGR1cmF0aW9uLiBEaWQgeW91IGZvcmdldCBhIGNvbW1hP1wiICsgZSlcblxuICAgIGZvciBzdHIgaW4gdGV4dF9saW5lXG4gICAgICB0ZXh0ID0gc3RyLnRleHQudHJpbSgpXG4gICAgICBpZiB0ZXh0Lm1hdGNoKC9cXC5mb250PS4qLylcbiAgICAgICAgZm9udCA9IHRleHRbNi4uXVxuICAgICAgICBAYXJ0aXN0LnNldFRleHRGb250KGZvbnQpXG4gICAgICBlbHNlIGlmIHRleHRbMF0gPT0gXCI6XCJcbiAgICAgICAgQGFydGlzdC5zZXREdXJhdGlvbih0ZXh0KVxuICAgICAgZWxzZSBpZiB0ZXh0WzBdID09IFwiLlwiXG4gICAgICAgIGNvbW1hbmQgPSB0ZXh0WzEuLl1cbiAgICAgICAgc3dpdGNoIGNvbW1hbmRcbiAgICAgICAgICB3aGVuIFwiY2VudGVyXCIsIFwibGVmdFwiLCBcInJpZ2h0XCJcbiAgICAgICAgICAgIGp1c3RpZmljYXRpb24gPSBjb21tYW5kXG4gICAgICAgICAgd2hlbiBcInN0cmljdFwiXG4gICAgICAgICAgICBzbW9vdGggPSBmYWxzZVxuICAgICAgICAgIHdoZW4gXCJzbW9vdGhcIlxuICAgICAgICAgICAgc21vb3RoID0gdHJ1ZVxuICAgICAgICAgIHdoZW4gXCJiYXJcIiwgXCJ8XCJcbiAgICAgICAgICAgIGJhcnRleHQoKVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIHBvc2l0aW9uID0gcGFyc2VJbnQodGV4dFsxLi5dLCAxMClcbiAgICAgIGVsc2UgaWYgdGV4dCA9PSBcInxcIlxuICAgICAgICBiYXJ0ZXh0KClcbiAgICAgIGVsc2UgaWYgdGV4dFswLi4xXSA9PSBcIisrXCJcbiAgICAgICAgQGFydGlzdC5hZGRUZXh0Vm9pY2UoKVxuICAgICAgZWxzZVxuICAgICAgICBjcmVhdGVOb3RlKHRleHQpXG5cbiAgZ2VuZXJhdGU6IC0+XG4gICAgZm9yIHN0YXZlIGluIEBlbGVtZW50c1xuICAgICAgc3dpdGNoIHN0YXZlLmVsZW1lbnRcbiAgICAgICAgd2hlbiBcInN0YXZlXCIsIFwidGFic3RhdmVcIlxuICAgICAgICAgIEBhcnRpc3QuYWRkU3RhdmUoc3RhdmUuZWxlbWVudCwgQHBhcnNlU3RhdmVPcHRpb25zKHN0YXZlLm9wdGlvbnMpKVxuICAgICAgICAgIEBwYXJzZVN0YXZlRWxlbWVudHMoc3RhdmUubm90ZXMpIGlmIHN0YXZlLm5vdGVzP1xuICAgICAgICAgIEBwYXJzZVN0YXZlVGV4dChzdGF2ZS50ZXh0KSBpZiBzdGF2ZS50ZXh0P1xuICAgICAgICB3aGVuIFwidm9pY2VcIlxuICAgICAgICAgIEBhcnRpc3QuYWRkVm9pY2UoQHBhcnNlU3RhdmVPcHRpb25zKHN0YXZlLm9wdGlvbnMpKVxuICAgICAgICAgIEBwYXJzZVN0YXZlRWxlbWVudHMoc3RhdmUubm90ZXMpIGlmIHN0YXZlLm5vdGVzP1xuICAgICAgICAgIEBwYXJzZVN0YXZlVGV4dChzdGF2ZS50ZXh0KSBpZiBzdGF2ZS50ZXh0P1xuICAgICAgICB3aGVuIFwib3B0aW9uc1wiXG4gICAgICAgICAgb3B0aW9ucyA9IHt9XG4gICAgICAgICAgZm9yIG9wdGlvbiBpbiBzdGF2ZS5wYXJhbXNcbiAgICAgICAgICAgIG9wdGlvbnNbb3B0aW9uLmtleV0gPSBvcHRpb24udmFsdWVcbiAgICAgICAgICB0cnlcbiAgICAgICAgICAgIEBhcnRpc3Quc2V0T3B0aW9ucyhvcHRpb25zKVxuICAgICAgICAgIGNhdGNoIGVcbiAgICAgICAgICAgIHRocm93IG5ld0Vycm9yKHN0YXZlLCBlLm1lc3NhZ2UpXG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aHJvdyBuZXdFcnJvcihzdGF2ZSwgXCJJbnZhbGlkIGtleXdvcmQgJyN7c3RhdmUuZWxlbWVudH0nXCIpXG5cbiAgcGFyc2U6IChjb2RlKSAtPlxuICAgIHBhcnNlci5wYXJzZUVycm9yID0gKG1lc3NhZ2UsIGhhc2gpIC0+XG4gICAgICBMIFwiVmV4VGFiIHBhcnNlIGVycm9yOiBcIiwgbWVzc2FnZSwgaGFzaFxuICAgICAgbWVzc2FnZSA9IFwiVW5leHBlY3RlZCB0ZXh0ICcje2hhc2gudGV4dH0nIGF0IGxpbmUgI3toYXNoLmxvYy5maXJzdF9saW5lfSBjb2x1bW4gI3toYXNoLmxvYy5maXJzdF9jb2x1bW59LlwiXG4gICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJQYXJzZUVycm9yXCIsIG1lc3NhZ2UpXG5cbiAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJQYXJzZUVycm9yXCIsIFwiTm8gY29kZVwiKSB1bmxlc3MgY29kZT9cblxuICAgIEwgXCJQYXJzaW5nOlxcbiN7Y29kZX1cIlxuXG4gICAgIyBTdHJpcCBsaW5lc1xuICAgIHN0cmlwcGVkX2NvZGUgPSAobGluZS50cmltKCkgZm9yIGxpbmUgaW4gY29kZS5zcGxpdCgvXFxyXFxufFxccnxcXG4vKSlcbiAgICBAZWxlbWVudHMgPSBwYXJzZXIucGFyc2Uoc3RyaXBwZWRfY29kZS5qb2luKFwiXFxuXCIpKVxuICAgIGlmIEBlbGVtZW50c1xuICAgICAgQGdlbmVyYXRlKClcbiAgICAgIEB2YWxpZCA9IHRydWVcblxuICAgIHJldHVybiBAZWxlbWVudHNcblxubW9kdWxlLmV4cG9ydHMgPSBWZXhUYWJcbiIsIi8vIExvYWQgVmV4VGFiIG1vZHVsZS5cbnZleHRhYiA9IHJlcXVpcmUoXCJ2ZXh0YWJcIik7XG4kID0gcmVxdWlyZShcImpxdWVyeVwiKTtcbl8gPSByZXF1aXJlKFwidW5kZXJzY29yZVwiKTtcblxuJChmdW5jdGlvbigpIHtcbiAgVmV4VGFiID0gdmV4dGFiLlZleFRhYjtcbiAgQXJ0aXN0ID0gdmV4dGFiLkFydGlzdDtcbiAgUmVuZGVyZXIgPSB2ZXh0YWIuVmV4LkZsb3cuUmVuZGVyZXI7XG4gIFBsYXllciA9IHZleHRhYi5QbGF5ZXI7XG5cbiAgQXJ0aXN0LkRFQlVHID0gZmFsc2U7XG4gIFZleFRhYi5ERUJVRyA9IGZhbHNlO1xuICBQbGF5ZXIuREVCVUcgPSB0cnVlO1xuXG4gIC8vIENyZWF0ZSBWZXhGbG93IFJlbmRlcmVyIGZyb20gY2FudmFzIGVsZW1lbnQgd2l0aCBpZCAjYm9vXG4gIHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCQoJyNib28nKVswXSwgUmVuZGVyZXIuQmFja2VuZHMuQ0FOVkFTKTtcblxuICAvLyBJbml0aWFsaXplIFZleFRhYiBhcnRpc3QgYW5kIHBhcnNlci5cbiAgYXJ0aXN0ID0gbmV3IEFydGlzdCgxMCwgMTAsIDYwMCwge3NjYWxlOiAwLjh9KTtcbiAgcGxheWVyID0gbmV3IFBsYXllcihhcnRpc3QpO1xuICB2ZXh0YWIgPSBuZXcgVmV4VGFiKGFydGlzdCk7XG5cbiAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHRyeSB7XG4gICAgICB2ZXh0YWIucmVzZXQoKTtcbiAgICAgIGFydGlzdC5yZXNldCgpO1xuLy8gICAgICBwbGF5ZXIucmVzZXQoKTtcbiAgICAgIHZleHRhYi5wYXJzZSgkKFwiI2JsYWhcIikudmFsKCkpO1xuICAgICAgYXJ0aXN0LnJlbmRlcihyZW5kZXJlcik7XG4gICAgICAkKFwiI2Vycm9yXCIpLnRleHQoXCJcIik7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY29uc29sZS5sb2coZSk7XG4gICAgICAkKFwiI2Vycm9yXCIpLmh0bWwoZS5tZXNzYWdlLnJlcGxhY2UoL1tcXG5dL2csICc8YnIvPicpKTtcbiAgICB9XG4gIH1cblxuICAkKFwiI2JsYWhcIikua2V5dXAoXy50aHJvdHRsZShyZW5kZXIsIDI1MCkpO1xuICByZW5kZXIoKTtcbn0pO1xuIl19
