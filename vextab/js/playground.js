(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
/**
 * VexFlow 1.2.36 built on 2016-02-04.
 * Copyright (c) 2010 Mohit Muthanna Cheppudira <mohit@muthanna.com>
 *
 * http://www.vexflow.com  http://github.com/0xfe/vexflow
 */
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements utility methods used by the rest of the VexFlow
// codebase.
//
// ## JSHint Settings
//
/* global window: false */
/* global document: false */

if (typeof Vex === 'undefined') {
  /* global Vex: true */
  Vex = function() {};
}

// Default log function sends all arguments to console.
Vex.L = function(block, args) {
  if (!args) return;
  var line = Array.prototype.slice.call(args).join(" ");
  window.console.log(block + ": " + line);
};

// Default runtime exception.
Vex.RuntimeError = function(code, message) {
  this.code = code;
  this.message = message;
};

Vex.RuntimeError.prototype.toString = function() {
  return "RuntimeError: " + this.message;
};

// Shortcut method for `RuntimeError`.
Vex.RERR = Vex.RuntimeError;

// Merge `destination` hash with `source` hash, overwriting like keys
// in `source` if necessary.
Vex.Merge = function(destination, source) {
  for (var property in source)
    destination[property] = source[property];
  return destination;
};

// DEPRECATED. Use `Math.*`.
Vex.Min = Math.min;
Vex.Max = Math.max;
Vex.forEach = function(a, fn) {
  for (var i=0; i<a.length; i++) {
    fn(a[i],i);
  }
};

// Round number to nearest fractional value (`.5`, `.25`, etc.)
Vex.RoundN = function(x, n) {
  return (x % n) >= (n/2) ?
    parseInt(x / n, 10) * n + n : parseInt(x / n, 10) * n;
};

// Locate the mid point between stave lines. Returns a fractional line if a space.
Vex.MidLine = function(a, b) {
  var mid_line = b + (a - b) / 2;
  if (mid_line % 2 > 0) {
    mid_line = Vex.RoundN(mid_line * 10, 5) / 10;
  }
  return mid_line;
};

// Take `arr` and return a new list consisting of the sorted, unique,
// contents of arr. Does not modify `arr`.
Vex.SortAndUnique = function(arr, cmp, eq) {
  if (arr.length > 1) {
    var newArr = [];
    var last;
    arr.sort(cmp);

    for (var i = 0; i < arr.length; ++i) {
      if (i === 0 || !eq(arr[i], last)) {
        newArr.push(arr[i]);
      }
      last = arr[i];
    }

    return newArr;
  } else {
    return arr;
  }
};

// Check if array `a` contains `obj`.
Vex.Contains = function(a, obj) {
  var i = a.length;
  while (i--) {
    if (a[i] === obj) {
      return true;
    }
  }
  return false;
};

// Get the 2D Canvas context from DOM element `canvas_sel`.
Vex.getCanvasContext = function(canvas_sel) {
  if (!canvas_sel)
    throw new Vex.RERR("BadArgument", "Invalid canvas selector: " + canvas_sel);

  var canvas = document.getElementById(canvas_sel);
  if (!(canvas && canvas.getContext)) {
    throw new Vex.RERR("UnsupportedBrowserError",
        "This browser does not support HTML5 Canvas");
  }

  return canvas.getContext('2d');
};

// Draw a tiny dot marker on the specified canvas. A great debugging aid.
//
// `ctx`: Canvas context.
// `x`, `y`: Dot coordinates.
Vex.drawDot = function(ctx, x, y, color) {
  var c = color || "#f55";
  ctx.save();
  ctx.setFillStyle(c);

  //draw a circle
  ctx.beginPath();
  ctx.arc(x, y, 3, 0, Math.PI*2, true);
  ctx.closePath();
  ctx.fill();
  ctx.restore();
};

// Benchmark. Run function `f` once and report time elapsed shifted by `s` milliseconds.
Vex.BM = function(s, f) {
  var start_time = new Date().getTime();
  f();
  var elapsed = new Date().getTime() - start_time;
  Vex.L(s + elapsed + "ms");
};

// Basic classical inheritance helper. Usage:
// ```
// // Vex.Inherit(Child, Parent, {
// //   getName: function() {return this.name;},
// //   setName: function(name) {this.name = name}
// // });
// //
// // Returns 'Child'.
// ```
Vex.Inherit = (function () {
  var F = function () {};
  // `C` is Child. `P` is parent. `O` is an object to
  // to extend `C` with.
  return function (C, P, O) {
    F.prototype = P.prototype;
    C.prototype = new F();
    C.superclass = P.prototype;
    C.prototype.constructor = C;
    Vex.Merge(C.prototype, O);
    return C;
  };
}());

// Get stack trace.
Vex.StackTrace = function() {
  var err = new Error();
  return err.stack;
};

// Dump warning to console.
Vex.W = function() {
  var line = Array.prototype.slice.call(arguments).join(" ");
  window.console.log("Warning: ", line, Vex.StackTrace());
};

// Used by various classes (e.g., SVGContext) to provide a
// unique prefix to element names (or other keys in shared namespaces).
Vex.Prefix = function(text) {
  return Vex.Prefix.prefix + text;
};
Vex.Prefix.prefix = "vf-";

// UMD to export Vex.
//
/* global require: false */
/* global define: false */
/* global module: false */
if (typeof require == "function") {
  try {
    module.exports = Vex;
  } catch (e) {}
} else if (typeof define == "function" && define.amd) {
  define("Vex", [], function(){ return Vex; });
} else {
  (this || window)["Vex"] = Vex;
}

/**
 * Vex Flow - Mohit Muthanna <mohit@muthanna.com>
 */

/**
 * New namespace.
 */

if (typeof Vex.Flow === 'undefined') {
  Vex.Flow = {
    /**
     * The resolution used for all the rhythm timing in this
     * library.
     *
     * @const
     * @type {number}
     */
    RESOLUTION: 16384,

    /* Kerning (DEPRECATED) */
    IsKerned: true
  };
}

// Fraction class that represents a rational number
// @author zz85
// @author incompleteopus (modifications)

Vex.Flow.Fraction = (function() {
  function Fraction(numerator, denominator) {
    this.set(numerator, denominator);
  }

  /**
   * GCD: Find greatest common divisor using Euclidean algorithm
   */
  Fraction.GCD = function(a, b) {
    if (typeof a !== "number" || typeof b !== "number") {
      throw new Vex.RERR("BadArgument", "Invalid numbers: " + a + ", " + b);
    }

    var t;

    while (b !== 0) {
      t = b;
      b = a % b;
      a = t;
    }

    return a;
  };

  /**
   * LCM: Lowest common multiple
   */
  Fraction.LCM = function(a, b) {
    return ((a * b) / Fraction.GCD(a, b));
  };

  /**
   * LCMM: Lowest common multiple for more than two numbers
   */
  Fraction.LCMM = function(args) {
    if (args.length === 0) {
      return 0;
    } else if (args.length == 1) {
      return args[0];
    } else if (args.length == 2) {
      return Vex.Flow.Fraction.LCM(args[0], args[1]);
    } else {
      var arg0 = args[0];
      args.shift();
      return Fraction.LCM(arg0, Vex.Flow.Fraction.LCMM(args));
    }
  };

  Fraction.prototype = {
    set: function(numerator, denominator) {
      this.numerator = numerator === undefined ? 1 : numerator;
      this.denominator = denominator === undefined ? 1 : denominator;
      return this;
    },

    value: function() {
      return this.numerator / this.denominator;
    },

    simplify: function() {
      var u = this.numerator;
      var d = this.denominator;

      var gcd = Vex.Flow.Fraction.GCD(u, d);
      u /= gcd;
      d /= gcd;

      if (d < 0) {
        d = -d;
        u = -u;
      }
      return this.set(u, d);
    },

    add: function(param1, param2) {
      var otherNumerator;
      var otherDenominator;

      if (param1 instanceof Vex.Flow.Fraction) {
        otherNumerator = param1.numerator;
        otherDenominator = param1.denominator;
      } else {
        if (param1 !== undefined) {
          otherNumerator = param1;
        } else {
          otherNumerator = 0;
        }

        if (param2 !== undefined) {
          otherDenominator = param2;
        } else {
          otherDenominator = 1;
        }
      }

      var lcm = Vex.Flow.Fraction.LCM(this.denominator, otherDenominator);
      var a = lcm / this.denominator;
      var b = lcm / otherDenominator;

      var u = this.numerator * a + otherNumerator * b;
      return this.set(u, lcm);
    },

    subtract: function(param1, param2) {
      var otherNumerator;
      var otherDenominator;

      if (param1 instanceof Vex.Flow.Fraction) {
        otherNumerator = param1.numerator;
        otherDenominator = param1.denominator;
      } else {
        if (param1 !== undefined) {
          otherNumerator = param1;
        } else {
          otherNumerator = 0;
        }

        if (param2 !== undefined) {
          otherDenominator = param2;
        } else {
          otherDenominator = 1;
        }
      }

      var lcm = Vex.Flow.Fraction.LCM(this.denominator, otherDenominator);
      var a = lcm / this.denominator;
      var b = lcm / otherDenominator;

      var u = this.numerator * a - otherNumerator * b;
      return this.set(u, lcm);
    },

    multiply: function(param1, param2) {
      var otherNumerator;
      var otherDenominator;

      if (param1 instanceof Vex.Flow.Fraction) {
        otherNumerator = param1.numerator;
        otherDenominator = param1.denominator;
      } else {
        if (param1 !== undefined) {
          otherNumerator = param1;
        } else {
          otherNumerator = 1;
        }

        if (param2 !== undefined) {
          otherDenominator = param2;
        } else {
          otherDenominator = 1;
        }
      }

      return this.set(this.numerator * otherNumerator, this.denominator * otherDenominator);
    },

    divide: function(param1, param2) {
      var otherNumerator;
      var otherDenominator;

      if (param1 instanceof Vex.Flow.Fraction) {
        otherNumerator = param1.numerator;
        otherDenominator = param1.denominator;
      } else {
        if (param1 !== undefined) {
          otherNumerator = param1;
        } else {
          otherNumerator = 1;
        }

        if (param2 !== undefined) {
          otherDenominator = param2;
        } else {
          otherDenominator = 1;
        }
      }

      return this.set(this.numerator * otherDenominator, this.denominator * otherNumerator);
    },


    // Simplifies both sides and checks if they are equal.
    equals: function(compare) {
      var a = Vex.Flow.Fraction.__compareA.copy(compare).simplify();
      var b = Vex.Flow.Fraction.__compareB.copy(this).simplify();

      return (a.numerator === b.numerator) && (a.denominator === b.denominator);
    },
    
    // Greater than operator.
    greaterThan: function(compare) {
      var a = Vex.Flow.Fraction.__compareB.copy(this);
      a.subtract(compare);
      return (a.numerator > 0);
    },
    
    // Greater than or equals operator.
    greaterThanEquals: function(compare) {
      var a = Vex.Flow.Fraction.__compareB.copy(this);
      a.subtract(compare);
      return (a.numerator >= 0);
    },

    // Less than operator.
    lessThan: function(compare) {
      return !(this.greaterThanEquals(compare));  
    },

    // Less than or equals operator.
    lessThanEquals: function(compare) {
      return !(this.greaterThan(compare));  
    },

    // Creates a new copy with this current values.
    clone: function() {
      return new Vex.Flow.Fraction(this.numerator, this.denominator);
    },

    // Copies value of another Fraction into itself.
    copy: function(copy) {
      return this.set(copy.numerator, copy.denominator);
    },

    // Returns the integer component eg. (4/2) == 2
    quotient: function() {
      return Math.floor(this.numerator / this.denominator);
    },

    // Returns the fraction component when reduced to a mixed number
    fraction: function() {
      return this.numerator % this.denominator;
    },

    // Returns the absolute value
    abs: function() {
      this.denominator = Math.abs(this.denominator);
      this.numerator = Math.abs(this.numerator);
      return this;
    },

    // Returns a raw string representation
    toString: function() {
      return this.numerator + '/' + this.denominator;
    },

    // Returns a simplified string respresentation
    toSimplifiedString: function() {
      return Vex.Flow.Fraction.__tmp.copy(this).simplify().toString();
    },

    // Returns string representation in mixed form
    toMixedString: function() {
      var s = '';
      var q = this.quotient();
      var f = Vex.Flow.Fraction.__tmp.copy(this);

      if (q < 0) {
        f.abs().fraction();
      } else {
        f.fraction();
      }

      if (q !== 0) {
        s += q;

        if (f.numerator !== 0) {
          s += ' ' + f.toSimplifiedString();
        }
      } else {
        if (f.numerator === 0) {
          s = '0';
        } else {
          s = f.toSimplifiedString();
        }
      }

      return s;
    },

    // Parses a fraction string
    parse: function(str) {
      var i = str.split('/');
      var n = parseInt(i[0], 10);
      var d = (i[1]) ? parseInt(i[1], 10) : 1;

      return this.set(n, d);
    }
  };

  // Temporary cached objects
  Fraction.__compareA = new Fraction();
  Fraction.__compareB = new Fraction();
  Fraction.__tmp = new Fraction();

  return Fraction;
}());


// Vex Flow Notation
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Muthanna 2010
//
// Requires vex.js.

Vex.Flow.STEM_WIDTH = 1.5;
Vex.Flow.STEM_HEIGHT = 32;
Vex.Flow.STAVE_LINE_THICKNESS = 2;

Vex.Flow.clefProperties = function(clef) {
  if (!clef) throw new Vex.RERR("BadArgument", "Invalid clef: " + clef);

  var props = Vex.Flow.clefProperties.values[clef];
  if (!props) throw new Vex.RERR("BadArgument", "Invalid clef: " + clef);

  return props;
};

Vex.Flow.clefProperties.values = {
  'treble':  { line_shift: 0 },
  'bass':    { line_shift: 6 },
  'tenor':   { line_shift: 4 },
  'alto':    { line_shift: 3 },
  'soprano': { line_shift: 1 },
  'percussion': { line_shift: 0 },
  'mezzo-soprano': { line_shift: 2 },
  'baritone-c': { line_shift: 5 },
  'baritone-f': { line_shift: 5 },
  'subbass': { line_shift: 7 },
  'french': { line_shift: -1 }
};

/*
  Take a note in the format "Key/Octave" (e.g., "C/5") and return properties.

  The last argument, params, is a struct the currently can contain one option,
  octave_shift for clef ottavation (0 = default; 1 = 8va; -1 = 8vb, etc.).
*/
Vex.Flow.keyProperties = function(key, clef, params) {
  if (clef === undefined) {
    clef = 'treble';
  }
  var options = {
    octave_shift: 0
  };
  if (typeof params == "object") {
    Vex.Merge(options, params);
  }

  var pieces = key.split("/");

  if (pieces.length < 2) {
    throw new Vex.RERR("BadArguments",
        "Key must have note + octave and an optional glyph: " + key);
  }

  var k = pieces[0].toUpperCase();
  var value = Vex.Flow.keyProperties.note_values[k];
  if (!value) throw new Vex.RERR("BadArguments", "Invalid key name: " + k);
  if (value.octave) pieces[1] = value.octave;

  var o = parseInt(pieces[1]);

  // Octave_shift is the shift to compensate for clef 8va/8vb.
  o += -1 * options.octave_shift;

  var base_index = (o * 7) - (4 * 7);
  var line = (base_index + value.index) / 2;
  line += Vex.Flow.clefProperties(clef).line_shift;

  var stroke = 0;

  if (line <= 0 && (((line * 2) % 2) === 0)) stroke = 1;  // stroke up
  if (line >= 6 && (((line * 2) % 2) === 0)) stroke = -1; // stroke down

  // Integer value for note arithmetic.
  var int_value = (typeof(value.int_val)!='undefined') ? (o * 12) +
    value.int_val : null;

  /* Check if the user specified a glyph. */
  var code = value.code;
  var shift_right = value.shift_right;
  if ((pieces.length > 2) && (pieces[2])) {
    var glyph_name = pieces[2].toUpperCase();
    var note_glyph = Vex.Flow.keyProperties.note_glyph[glyph_name];
    if (note_glyph) {
      code = note_glyph.code;
      shift_right = note_glyph.shift_right;
    }
  }

  return {
    key: k,
    octave: o,
    line: line,
    int_value: int_value,
    accidental: value.accidental,
    code: code,
    stroke: stroke,
    shift_right: shift_right,
    displaced: false
  };
};

Vex.Flow.keyProperties.note_values = {
  'C':  { index: 0, int_val: 0, accidental: null },
  'CN': { index: 0, int_val: 0, accidental: "n" },
  'C#': { index: 0, int_val: 1, accidental: "#" },
  'C##': { index: 0, int_val: 2, accidental: "##" },
  'CB': { index: 0, int_val: -1, accidental: "b" },
  'CBB': { index: 0, int_val: -2, accidental: "bb" },
  'D':  { index: 1, int_val: 2, accidental: null },
  'DN': { index: 1, int_val: 2, accidental: "n" },
  'D#': { index: 1, int_val: 3, accidental: "#" },
  'D##': { index: 1, int_val: 4, accidental: "##" },
  'DB': { index: 1, int_val: 1, accidental: "b" },
  'DBB': { index: 1, int_val: 0, accidental: "bb" },
  'E':  { index: 2, int_val: 4, accidental: null },
  'EN': { index: 2, int_val: 4, accidental: "n" },
  'E#': { index: 2, int_val: 5, accidental: "#" },
  'E##': { index: 2, int_val: 6, accidental: "##" },
  'EB': { index: 2, int_val: 3, accidental: "b" },
  'EBB': { index: 2, int_val: 2, accidental: "bb" },
  'F':  { index: 3, int_val: 5, accidental: null },
  'FN': { index: 3, int_val: 5, accidental: "n" },
  'F#': { index: 3, int_val: 6, accidental: "#" },
  'F##': { index: 3, int_val: 7, accidental: "##" },
  'FB': { index: 3, int_val: 4, accidental: "b" },
  'FBB': { index: 3, int_val: 3, accidental: "bb" },
  'G':  { index: 4, int_val: 7, accidental: null },
  'GN': { index: 4, int_val: 7, accidental: "n" },
  'G#': { index: 4, int_val: 8, accidental: "#" },
  'G##': { index: 4, int_val: 9, accidental: "##" },
  'GB': { index: 4, int_val: 6, accidental: "b" },
  'GBB': { index: 4, int_val: 5, accidental: "bb" },
  'A':  { index: 5, int_val: 9, accidental: null },
  'AN': { index: 5, int_val: 9, accidental: "n" },
  'A#': { index: 5, int_val: 10, accidental: "#" },
  'A##': { index: 5, int_val: 11, accidental: "##" },
  'AB': { index: 5, int_val: 8, accidental: "b" },
  'ABB': { index: 5, int_val: 7, accidental: "bb" },
  'B':  { index: 6, int_val: 11, accidental: null },
  'BN': { index: 6, int_val: 11, accidental: "n" },
  'B#': { index: 6, int_val: 12, accidental: "#" },
  'B##': { index: 6, int_val: 13, accidental: "##" },
  'BB': { index: 6, int_val: 10, accidental: "b" },
  'BBB': { index: 6, int_val: 9, accidental: "bb" },
  'R': { index: 6, int_val: 9, rest: true }, // Rest
  'X':  {
    index: 6,
    accidental: "",
    octave: 4,
    code: "v3e",
    shift_right: 5.5
  }
};

Vex.Flow.keyProperties.note_glyph = {
  /* Diamond */
  'D0':  { code: "v27", shift_right: -0.5 },
  'D1':  { code: "v2d", shift_right: -0.5 },
  'D2':  { code: "v22", shift_right: -0.5 },
  'D3':  { code: "v70", shift_right: -0.5 },

  /* Triangle */
  'T0':  { code: "v49", shift_right: -2 },
  'T1':  { code: "v93", shift_right: 0.5 },
  'T2':  { code: "v40", shift_right: 0.5 },
  'T3':  { code: "v7d", shift_right: 0.5 },

  /* Cross */
  'X0':  { code: "v92", shift_right: -2 },
  'X1':  { code: "v95", shift_right: -0.5 },
  'X2':  { code: "v7f", shift_right: 0.5 },
  'X3':  { code: "v3b", shift_right: -2 }
};

Vex.Flow.integerToNote = function(integer) {
  if (typeof(integer) == "undefined")
    throw new Vex.RERR("BadArguments", "Undefined integer for integerToNote");

  if (integer < -2)
    throw new Vex.RERR("BadArguments",
        "integerToNote requires integer > -2: " + integer);

  var noteValue = Vex.Flow.integerToNote.table[integer];
  if (!noteValue)
    throw new Vex.RERR("BadArguments", "Unknown note value for integer: " +
        integer);

  return noteValue;
};

Vex.Flow.integerToNote.table = {
  0: "C",
  1: "C#",
  2: "D",
  3: "D#",
  4: "E",
  5: "F",
  6: "F#",
  7: "G",
  8: "G#",
  9: "A",
  10: "A#",
  11: "B"
};


Vex.Flow.tabToGlyph = function(fret) {
  var glyph = null;
  var width = 0;
  var shift_y = 0;

  if (fret.toString().toUpperCase() == "X") {
    glyph = "v7f";
    width = 7;
    shift_y = -4.5;
  } else {
    width = Vex.Flow.textWidth(fret.toString());
  }

  return {
    text: fret,
    code: glyph,
    width: width,
    shift_y: shift_y
  };
};

Vex.Flow.textWidth = function(text) {
  return 6 * text.toString().length;
};

Vex.Flow.articulationCodes = function(artic) {
  return Vex.Flow.articulationCodes.articulations[artic];
};

Vex.Flow.articulationCodes.articulations = {
  "a.": {   // Staccato
    code: "v23",
    width: 4,
    shift_right: -2,
    shift_up: 8,
    shift_down: 0,
    between_lines: true
  },
  "av": {   // Staccatissimo
    code: "v28",
    width: 4,
    shift_right: 0,
    shift_up: 11,
    shift_down: 5,
    between_lines: true
  },
  "a>": {   // Accent
    code: "v42",
    width: 10,
    shift_right: 5,
    shift_up: 8,
    shift_down: 1,
    between_lines: true
  },
  "a-": {   // Tenuto
    code: "v25",
    width: 9,
    shift_right: -4,
    shift_up: 17,
    shift_down: 10,
    between_lines: true
  },
  "a^": {   // Marcato
    code: "va",
    width: 8,
    shift_right: 0,
    shift_up: -4,
    shift_down: -2,
    between_lines: false
  },
  "a+": {   // Left hand pizzicato
    code: "v8b",
    width: 9,
    shift_right: -4,
    shift_up: 12,
    shift_down: 12,
    between_lines: false
  },
  "ao": {   // Snap pizzicato
    code: "v94",
    width: 8,
    shift_right: 0,
    shift_up: -4,
    shift_down: 6,
    between_lines: false
  },
  "ah": {   // Natural harmonic or open note
    code: "vb9",
    width: 7,
    shift_right: 0,
    shift_up: -4,
    shift_down: 4,
    between_lines: false
  },
  "a@a": {   // Fermata above staff
    code: "v43",
    width: 25,
    shift_right: 0,
    shift_up: 8,
    shift_down: 10,
    between_lines: false
  },
  "a@u": {   // Fermata below staff
    code: "v5b",
    width: 25,
    shift_right: 0,
    shift_up: 0,
    shift_down: -4,
    between_lines: false
  },
  "a|": {   // Bow up - up stroke
    code: "v75",
    width: 8,
    shift_right: 0,
    shift_up: 8,
    shift_down: 10,
    between_lines: false
  },
  "am": {   // Bow down - down stroke
    code: "v97",
    width: 13,
    shift_right: 0,
    shift_up: 10,
    shift_down: 12,
    between_lines: false
  },
  "a,": {   // Choked
    code: "vb3",
    width: 6,
    shift_right: 8,
    shift_up: -4,
    shift_down: 4,
    between_lines: false
  }
};

Vex.Flow.accidentalCodes = function(acc) {
  return Vex.Flow.accidentalCodes.accidentals[acc];
};

Vex.Flow.accidentalCodes.accidentals = {
  "#": {
    code: "v18",
    width: 10,
    gracenote_width: 4.5,
    shift_right: 0,
    shift_down: 0
  },
  "##": {
    code: "v7f",
    width: 13,
    gracenote_width: 6,
    shift_right: -1,
    shift_down: 0
  },
  "b": {
    code: "v44",
    width: 8,
    gracenote_width: 4.5,
    shift_right: 0,
    shift_down: 0
  },
  "bb": {
    code: "v26",
    width: 14,
    gracenote_width: 8,
    shift_right: -3,
    shift_down: 0
  },
  "n": {
    code: "v4e",
    width: 8,
    gracenote_width: 4.5,
    shift_right: 0,
    shift_down: 0
  },
  "{": {   // Left paren for cautionary accidentals
    code: "v9c",
    width: 5,
    shift_right: 2,
    shift_down: 0
  },
  "}": {   // Right paren for cautionary accidentals
    code: "v84",
    width: 5,
    shift_right: 0,
    shift_down: 0
  },
  "db": {
    code: "v9e",
    width: 16,
    shift_right: 0,
    shift_down: 0
  },
  "d": {
    code: "vab",
    width: 10,
    shift_right: 0,
    shift_down: 0
  },
  "bbs": {
    code: "v90",
    width: 13,
    shift_right: 0,
    shift_down: 0
  },
  "++": {
    code: "v51",
    width: 13,
    shift_right: 0,
    shift_down: 0
  },
  "+": {
    code: "v78",
    width: 8,
    shift_right: 0,
    shift_down: 0
  }
};

Vex.Flow.accidentalColumnsTable = {
  1 : { a : [1], b : [1]},
  2 : { a : [1, 2] },
  3 : { a : [1, 3, 2], b : [1, 2, 1], second_on_bottom : [1, 2, 3] },
  4 : { a : [1, 3, 4, 2], b : [1, 2, 3, 1], spaced_out_tetrachord : [1, 2, 1, 2] },
  5 : { a : [1, 3, 5, 4, 2], b : [1, 2, 4, 3, 1],
        spaced_out_pentachord : [1, 2, 3, 2, 1],
        very_spaced_out_pentachord : [1, 2, 1, 2, 1] },
  6 : { a : [1, 3, 5, 6, 4, 2], b : [1, 2, 4, 5, 3, 1],
        spaced_out_hexachord : [1, 3, 2, 1, 3, 2],
        very_spaced_out_hexachord : [1, 2, 1, 2, 1, 2] }
};

Vex.Flow.ornamentCodes = function(acc) {
  return Vex.Flow.ornamentCodes.ornaments[acc];
};

Vex.Flow.ornamentCodes.ornaments = {
  "mordent": {
    code: "v1e",
    shift_right: 1,
    shift_up: 0,
    shift_down: 5,
    width: 14,
  },
  "mordent_inverted": {
    code: "v45",
    shift_right: 1,
    shift_up: 0,
    shift_down: 5,
    width: 14,
  },
  "turn": {
    code: "v72",
    shift_right: 1,
    shift_up: 0,
    shift_down: 5,
    width: 20,
  },
  "turn_inverted": {
    code: "v33",
    shift_right: 1,
    shift_up: 0,
    shift_down: 6,
    width: 20,
  },
  "tr": {
    code: "v1f",
    shift_right: 0,
    shift_up: 5,
    shift_down: 15,
    width: 10,
  },
  "upprall": {
    code: "v60",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "downprall": {
    code: "vb4",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "prallup": {
    code: "v6d",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "pralldown": {
    code: "v2c",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "upmordent": {
    code: "v29",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "downmordent": {
    code: "v68",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "lineprall": {
    code: "v20",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  },
  "prallprall": {
    code: "v86",
    shift_right: 1,
    shift_up: -3,
    shift_down: 6,
    width: 20,
  }
};

Vex.Flow.keySignature = function(spec) {
  var keySpec = Vex.Flow.keySignature.keySpecs[spec];

  if (!keySpec) {
    throw new Vex.RERR("BadKeySignature",
        "Bad key signature spec: '" + spec + "'");
  }

  if (!keySpec.acc) {
    return [];
  }

  var notes = Vex.Flow.keySignature.accidentalList(keySpec.acc);

  var acc_list = [];
  for (var i = 0; i < keySpec.num; ++i) {
    var line = notes[i];
    acc_list.push({type: keySpec.acc, line: line});
  }

  return acc_list;
};

Vex.Flow.keySignature.keySpecs = {
  "C": {acc: null, num: 0},
  "Am": {acc: null, num: 0},
  "F": {acc: "b", num: 1},
  "Dm": {acc: "b", num: 1},
  "Bb": {acc: "b", num: 2},
  "Gm": {acc: "b", num: 2},
  "Eb": {acc: "b", num: 3},
  "Cm": {acc: "b", num: 3},
  "Ab": {acc: "b", num: 4},
  "Fm": {acc: "b", num: 4},
  "Db": {acc: "b", num: 5},
  "Bbm": {acc: "b", num: 5},
  "Gb": {acc: "b", num: 6},
  "Ebm": {acc: "b", num: 6},
  "Cb": {acc: "b", num: 7},
  "Abm": {acc: "b", num: 7},
  "G": {acc: "#", num: 1},
  "Em": {acc: "#", num: 1},
  "D": {acc: "#", num: 2},
  "Bm": {acc: "#", num: 2},
  "A": {acc: "#", num: 3},
  "F#m": {acc: "#", num: 3},
  "E": {acc: "#", num: 4},
  "C#m": {acc: "#", num: 4},
  "B": {acc: "#", num: 5},
  "G#m": {acc: "#", num: 5},
  "F#": {acc: "#", num: 6},
  "D#m": {acc: "#", num: 6},
  "C#": {acc: "#", num: 7},
  "A#m": {acc: "#", num: 7}
};

Vex.Flow.unicode = {
  // Unicode accidentals
  "sharp": String.fromCharCode(parseInt('266F', 16)),
  "flat" : String.fromCharCode(parseInt('266D', 16)),
  "natural": String.fromCharCode(parseInt('266E', 16)),
  // Major Chord
  "triangle": String.fromCharCode(parseInt('25B3', 16)),
  // half-diminished
  "o-with-slash": String.fromCharCode(parseInt('00F8', 16)),
   // Diminished
  "degrees": String.fromCharCode(parseInt('00B0', 16)),
  "circle": String.fromCharCode(parseInt('25CB', 16))
};

Vex.Flow.keySignature.accidentalList = function(acc) {
  if (acc == "b") {
    return [2, 0.5, 2.5, 1, 3, 1.5, 3.5];
  }
  else if (acc == "#") {
    return [0, 1.5, -0.5, 1, 2.5, 0.5, 2]; }
};

Vex.Flow.parseNoteDurationString = function(durationString) {
  if (typeof(durationString) !== "string") {
    return null;
  }

  var regexp = /(\d*\/?\d+|[a-z])(d*)([nrhms]|$)/;

  var result = regexp.exec(durationString);
  if (!result) {
    return null;
  }

  var duration = result[1];
  var dots = result[2].length;
  var type = result[3];

  if (type.length === 0) {
    type = "n";
  }

  return {
    duration: duration,
    dots: dots,
    type: type
  };
};

Vex.Flow.parseNoteData = function(noteData) {
  var duration = noteData.duration;

  // Preserve backwards-compatibility
  var durationStringData = Vex.Flow.parseNoteDurationString(duration);
  if (!durationStringData) {
    return null;
  }

  var ticks = Vex.Flow.durationToTicks(durationStringData.duration);
  if (ticks == null) {
    return null;
  }

  var type = noteData.type;

  if (type) {
    if (!(type === "n" || type === "r" || type === "h" ||
          type === "m" || type === "s")) {
      return null;
    }
  } else {
    type = durationStringData.type;
    if (!type) {
      type = "n";
    }
  }

  var dots = 0;
  if (noteData.dots) {
    dots = noteData.dots;
  } else {
    dots = durationStringData.dots;
  }

  if (typeof(dots) !== "number") {
    return null;
  }

  var currentTicks = ticks;

  for (var i = 0; i < dots; i++) {
    if (currentTicks <= 1) {
      return null;
    }

    currentTicks = currentTicks / 2;
    ticks += currentTicks;
  }

  return {
    duration: durationStringData.duration,
    type: type,
    dots: dots,
    ticks: ticks
  };
};

// Used to convert duration aliases to the number based duration.
// If the input isn't an alias, simply return the input.
//
// example: 'q' -> '4', '8' -> '8'
Vex.Flow.sanitizeDuration = function(duration) {
  var alias = Vex.Flow.durationAliases[duration];
  if (alias !== undefined) {
    duration = alias;
  }

  if (Vex.Flow.durationToTicks.durations[duration] === undefined) {
    throw new Vex.RERR('BadArguments',
      'The provided duration is not valid');
  }

  return duration;
};

// Convert the `duration` to an fraction
Vex.Flow.durationToFraction = function(duration) {
  return new Vex.Flow.Fraction().parse(Vex.Flow.sanitizeDuration(duration));
};

// Convert the `duration` to an number
Vex.Flow.durationToNumber = function(duration) {
  return Vex.Flow.durationToFraction(duration).value();
};

// Convert the `duration` to total ticks
Vex.Flow.durationToTicks = function(duration) {
  duration = Vex.Flow.sanitizeDuration(duration);

  var ticks = Vex.Flow.durationToTicks.durations[duration];
  if (ticks === undefined) {
    return null;
  }

  return ticks;
};

Vex.Flow.durationToTicks.durations = {
  "1/2":  Vex.Flow.RESOLUTION * 2,
  "1":    Vex.Flow.RESOLUTION / 1,
  "2":    Vex.Flow.RESOLUTION / 2,
  "4":    Vex.Flow.RESOLUTION / 4,
  "8":    Vex.Flow.RESOLUTION / 8,
  "16":   Vex.Flow.RESOLUTION / 16,
  "32":   Vex.Flow.RESOLUTION / 32,
  "64":   Vex.Flow.RESOLUTION / 64,
  "128":  Vex.Flow.RESOLUTION / 128,
  "256":  Vex.Flow.RESOLUTION / 256
};

Vex.Flow.durationAliases = {
  "w": "1",
  "h": "2",
  "q": "4",

  // This is the default duration used to render bars (BarNote). Bars no longer
  // consume ticks, so this should be a no-op.
  //
  // TODO(0xfe): This needs to be cleaned up.
  "b": "256"
};

Vex.Flow.durationToGlyph = function(duration, type) {
  duration = Vex.Flow.sanitizeDuration(duration);

  var code = Vex.Flow.durationToGlyph.duration_codes[duration];
  if (code === undefined) {
    return null;
  }

  if (!type) {
    type = "n";
  }

  var glyphTypeProperties = code.type[type];
  if (glyphTypeProperties === undefined) {
    return null;
  }

  return Vex.Merge(Vex.Merge({}, code.common), glyphTypeProperties);
};

Vex.Flow.durationToGlyph.duration_codes = {
  "1/2": {
    common: {
      head_width: 22,
      stem: false,
      stem_offset: 0,
      flag: false,
      stem_up_extension: -Vex.Flow.STEM_HEIGHT,
      stem_down_extension: -Vex.Flow.STEM_HEIGHT,
      gracenote_stem_up_extension: -Vex.Flow.STEM_HEIGHT,
      gracenote_stem_down_extension: -Vex.Flow.STEM_HEIGHT,
      tabnote_stem_up_extension: -Vex.Flow.STEM_HEIGHT,
      tabnote_stem_down_extension: -Vex.Flow.STEM_HEIGHT,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Breve note
        code_head: "v53"
      },
      "h": { // Breve note harmonic
        code_head: "v59"
      },
      "m": { // Breve note muted -
        code_head: "vf",
        stem_offset: 0
      },
      "r": { // Breve rest
        code_head: "v31",
        head_width: 24,
        rest: true,
        position: "B/5",
        dot_shiftY: 0.5
      },
      "s": { // Breve note slash -
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "1": {
    common: {
      head_width: 16,
      stem: false,
      stem_offset: 0,
      flag: false,
      stem_up_extension: -Vex.Flow.STEM_HEIGHT,
      stem_down_extension: -Vex.Flow.STEM_HEIGHT,
      gracenote_stem_up_extension: -Vex.Flow.STEM_HEIGHT,
      gracenote_stem_down_extension: -Vex.Flow.STEM_HEIGHT,
      tabnote_stem_up_extension: -Vex.Flow.STEM_HEIGHT,
      tabnote_stem_down_extension: -Vex.Flow.STEM_HEIGHT,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Whole note
        code_head: "v1d"
      },
      "h": { // Whole note harmonic
        code_head: "v46"
      },
      "m": { // Whole note muted
        code_head: "v92",
        stem_offset: -3
      },
      "r": { // Whole rest
        code_head: "v5c",
        head_width: 12,
        rest: true,
        position: "D/5",
        dot_shiftY: 0.5
      },
      "s": { // Whole note slash
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "2": {
    common: {
      head_width: 10,
      stem: true,
      stem_offset: 0,
      flag: false,
      stem_up_extension: 0,
      stem_down_extension: 0,
      gracenote_stem_up_extension: -14,
      gracenote_stem_down_extension: -14,
      tabnote_stem_up_extension: 0,
      tabnote_stem_down_extension: 0,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Half note
        code_head: "v81"
      },
      "h": { // Half note harmonic
        code_head: "v2d"
      },
      "m": { // Half note muted
        code_head: "v95",
        stem_offset: -3
      },
      "r": { // Half rest
        code_head: "vc",
        head_width: 12,
        stem: false,
        rest: true,
        position: "B/4",
        dot_shiftY: -0.5
      },
      "s": { // Half note slash
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "4": {
    common: {
      head_width: 10,
      stem: true,
      stem_offset: 0,
      flag: false,
      stem_up_extension: 0,
      stem_down_extension: 0,
      gracenote_stem_up_extension: -14,
      gracenote_stem_down_extension: -14,
      tabnote_stem_up_extension: 0,
      tabnote_stem_down_extension: 0,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Quarter note
        code_head: "vb"
      },
      "h": { // Quarter harmonic
        code_head: "v22"
      },
      "m": { // Quarter muted
        code_head: "v3e",
        stem_offset: -3
      },
      "r": { // Quarter rest
        code_head: "v7c",
        head_width: 8,
        stem: false,
        rest: true,
        position: "B/4",
        dot_shiftY: -0.5,
        line_above: 1.5,
        line_below: 1.5
      },
      "s": { // Quarter slash
         // Drawn with canvas primitives
         head_width: 15,
         position: "B/4"
      }
    }
  },
  "8": {
    common: {
      head_width: 10,
      stem: true,
      stem_offset: 0,
      flag: true,
      beam_count: 1,
      code_flag_upstem: "v54",
      code_flag_downstem: "v9a",
      stem_up_extension: 0,
      stem_down_extension: 0,
      gracenote_stem_up_extension: -14,
      gracenote_stem_down_extension: -14,
      tabnote_stem_up_extension: 0,
      tabnote_stem_down_extension: 0,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Eighth note
        code_head: "vb"
      },
      "h": { // Eighth note harmonic
        code_head: "v22"
      },
      "m": { // Eighth note muted
        code_head: "v3e"
      },
      "r": { // Eighth rest
        code_head: "va5",
        stem: false,
        flag: false,
        rest: true,
        position: "B/4",
        dot_shiftY: -0.5,
        line_above: 1.0,
        line_below: 1.0
      },
      "s": { // Eight slash
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "16": {
    common: {
      beam_count: 2,
      head_width: 10,
      stem: true,
      stem_offset: 0,
      flag: true,
      code_flag_upstem: "v3f",
      code_flag_downstem: "v8f",
      stem_up_extension: 4,
      stem_down_extension: 0,
      gracenote_stem_up_extension: -14,
      gracenote_stem_down_extension: -14,
      tabnote_stem_up_extension: 0,
      tabnote_stem_down_extension: 0,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Sixteenth note
        code_head: "vb"
      },
      "h": { // Sixteenth note harmonic
        code_head: "v22"
      },
      "m": { // Sixteenth note muted
        code_head: "v3e"
      },
      "r": { // Sixteenth rest
        code_head: "v3c",
        head_width: 13,
        stem: false,
        flag: false,
        rest: true,
        position: "B/4",
        dot_shiftY: -0.5,
        line_above: 1.0,
        line_below: 2.0
      },
      "s": { // Sixteenth slash
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "32": {
    common: {
      beam_count: 3,
      head_width: 10,
      stem: true,
      stem_offset: 0,
      flag: true,
      code_flag_upstem: "v47",
      code_flag_downstem: "v2a",
      stem_up_extension: 13,
      stem_down_extension: 9,
      gracenote_stem_up_extension: -12,
      gracenote_stem_down_extension: -12,
      tabnote_stem_up_extension: 9,
      tabnote_stem_down_extension: 5,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Thirty-second note
        code_head: "vb"
      },
      "h": { // Thirty-second harmonic
        code_head: "v22"
      },
      "m": { // Thirty-second muted
        code_head: "v3e"
      },
      "r": { // Thirty-second rest
        code_head: "v55",
        head_width: 16,
        stem: false,
        flag: false,
        rest: true,
        position: "B/4",
        dot_shiftY: -1.5,
        line_above: 2.0,
        line_below: 2.0
      },
      "s": { // Thirty-second slash
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "64": {
    common: {
      beam_count: 4,
      head_width: 10,
      stem: true,
      stem_offset: 0,
      flag: true,
      code_flag_upstem: "va9",
      code_flag_downstem: "v58",
      stem_up_extension: 17,
      stem_down_extension: 13,
      gracenote_stem_up_extension: -10,
      gracenote_stem_down_extension: -10,
      tabnote_stem_up_extension: 13,
      tabnote_stem_down_extension: 9,
      dot_shiftY: 0,
      line_above: 0,
      line_below: 0
    },
    type: {
      "n": { // Sixty-fourth note
        code_head: "vb"
      },
      "h": { // Sixty-fourth harmonic
        code_head: "v22"
      },
      "m": { // Sixty-fourth muted
        code_head: "v3e"
      },
      "r": { // Sixty-fourth rest
        code_head: "v38",
        head_width: 18,
        stem: false,
        flag: false,
        rest: true,
        position: "B/4",
        dot_shiftY: -1.5,
        line_above: 2.0,
        line_below: 3.0
      },
      "s": { // Sixty-fourth slash
        // Drawn with canvas primitives
        head_width: 15,
        position: "B/4"
      }
    }
  },
  "128": {
      common: {
          beam_count: 5,
          head_width: 10,
          stem: true,
          stem_offset:0,
          flag: true,
          code_flag_upstem: "v9b",
          code_flag_downstem: "v30",
          stem_up_extension: 26,
          stem_down_extension: 22,
          gracenote_stem_up_extension: -8,
          gracenote_stem_down_extension: -8,
          tabnote_stem_up_extension: 22,
          tabnote_stem_down_extension: 18,
          dot_shiftY: 0,
          line_above: 0,
          line_below: 0
      },
      type: {
          "n": {  // Hundred-twenty-eight note
              code_head: "vb"
          },
          "h": { // Hundred-twenty-eight harmonic
              code_head: "v22"
          },
          "m": { // Hundred-twenty-eight muted
              code_head: "v3e"
          },
          "r": {  // Hundred-twenty-eight rest
              code_head: "vaa",
              head_width: 20,
              stem: false,
              flag: false,
              rest: true,
              position: "B/4",
              dot_shiftY: 1.5,
              line_above: 3.0,
              line_below: 3.0
          },
          "s": { // Hundred-twenty-eight rest
              // Drawn with canvas primitives
              head_width: 15,
              position: "B/4"
          }
      }
  }
};

// Some defaults
Vex.Flow.TIME4_4 = {
  num_beats: 4,
  beat_value: 4,
  resolution: Vex.Flow.RESOLUTION
};

Vex.Flow.Font = {"glyphs":{"v0":{"x_min":0,"x_max":514.5,"ha":525,"o":"m 236 648 b 246 648 238 648 242 648 b 288 646 261 648 283 648 b 472 513 364 634 428 587 b 514 347 502 464 514 413 b 462 163 514 272 499 217 b 257 44 409 83 333 44 b 50 163 181 44 103 83 b 0 347 14 217 0 272 b 40 513 0 413 12 464 b 236 648 87 591 155 638 m 277 614 b 253 616 273 616 261 616 b 242 616 247 616 243 616 b 170 499 193 609 181 589 b 159 348 163 446 159 398 b 166 222 159 308 161 266 b 201 91 174 138 183 106 b 257 76 215 81 235 76 b 311 91 277 76 299 81 b 347 222 330 106 338 138 b 353 348 352 266 353 308 b 344 499 353 398 351 446 b 277 614 333 587 322 606 m 257 -1 l 258 -1 l 255 -1 l 257 -1 m 257 673 l 258 673 l 255 673 l 257 673 "},"v1":{"x_min":-1.359375,"x_max":344.359375,"ha":351,"o":"m 126 637 l 129 638 l 198 638 l 266 638 l 269 635 b 274 631 272 634 273 632 l 277 627 l 277 395 b 279 156 277 230 277 161 b 329 88 281 123 295 106 b 344 69 341 81 344 79 b 337 55 344 62 343 59 l 333 54 l 197 54 l 61 54 l 58 55 b 50 69 53 59 50 62 b 65 88 50 79 53 81 b 80 97 72 91 74 93 b 117 156 103 113 112 129 b 117 345 117 161 117 222 l 117 528 l 100 503 l 38 406 b 14 383 24 384 23 383 b -1 398 5 383 -1 390 b 4 415 -1 403 1 409 b 16 437 5 416 10 426 l 72 539 l 100 596 b 121 632 119 631 119 631 b 126 637 122 634 125 635 m 171 -1 l 172 -1 l 170 -1 l 171 -1 m 171 673 l 172 673 l 170 673 l 171 673 "},"v2":{"x_min":-1.359375,"x_max":458.6875,"ha":468,"o":"m 197 648 b 216 648 201 648 208 648 b 258 646 232 648 253 648 b 419 546 333 637 393 599 b 432 489 428 528 432 509 b 356 342 432 440 405 384 b 235 278 322 313 288 295 b 69 170 166 256 107 217 b 69 169 69 170 69 169 b 69 169 69 169 69 169 b 74 173 69 169 72 170 b 209 222 112 204 163 222 b 310 195 247 222 274 215 b 371 179 332 184 352 179 b 396 181 379 179 387 179 b 428 202 409 184 423 194 b 442 212 431 209 436 212 b 458 197 450 212 458 206 b 441 148 458 190 449 165 b 299 44 409 84 353 44 b 288 45 295 44 292 44 b 250 61 274 45 268 49 b 122 99 212 86 164 99 b 73 91 104 99 88 97 b 28 63 53 84 34 72 b 14 54 25 56 20 54 b 1 62 9 54 4 56 l -1 65 l -1 79 b 0 99 -1 91 0 95 b 2 113 1 102 2 108 b 164 309 20 197 81 272 b 285 470 232 341 277 398 b 287 487 287 476 287 481 b 171 595 287 551 239 595 b 155 595 166 595 160 595 b 142 592 145 594 142 594 b 145 589 142 592 142 591 b 179 527 168 576 179 551 b 132 455 179 496 163 467 b 104 451 122 452 112 451 b 27 530 62 451 27 487 b 29 555 27 538 27 546 b 197 648 44 601 115 639 m 228 -1 l 230 -1 l 227 -1 l 228 -1 m 228 673 l 230 673 l 227 673 l 228 673 "},"v3":{"x_min":-1.359375,"x_max":409.6875,"ha":418,"o":"m 174 648 b 191 648 176 648 183 648 b 225 648 204 648 220 648 b 402 523 317 638 389 588 b 404 503 404 517 404 510 b 402 484 404 495 404 488 b 264 373 389 437 334 394 b 257 370 259 371 257 371 b 257 370 257 370 257 370 b 264 369 258 370 261 369 b 409 202 359 334 409 267 b 318 72 409 152 381 104 b 200 43 281 52 240 43 b 23 113 134 43 69 68 b 0 169 6 129 0 149 b 77 249 0 210 29 249 l 77 249 b 152 174 125 249 152 212 b 103 102 152 145 137 116 b 103 102 103 102 103 102 b 147 94 103 101 132 95 b 153 94 149 94 151 94 b 265 206 219 94 265 141 b 264 226 265 213 265 219 b 147 355 253 299 204 353 b 126 371 133 356 126 362 b 147 388 126 383 132 388 b 254 474 196 391 238 424 b 259 502 258 484 259 494 b 182 592 259 544 228 582 b 156 595 175 595 166 595 b 115 592 142 595 129 594 l 111 591 l 115 588 b 152 524 141 574 152 549 b 92 449 152 491 130 458 b 76 448 87 448 81 448 b -1 530 32 448 -1 488 b 20 581 -1 548 5 566 b 174 648 55 619 108 641 m 204 -1 l 205 -1 l 202 -1 l 204 -1 m 204 673 l 205 673 l 202 673 l 204 673 "},"v4":{"x_min":0,"x_max":468.21875,"ha":478,"o":"m 174 637 b 232 638 175 638 189 638 b 277 638 245 638 259 638 l 378 638 l 381 635 b 389 623 386 632 389 627 b 382 609 389 617 386 613 b 366 589 381 606 372 598 l 313 528 l 245 451 l 209 410 l 155 348 l 84 267 b 59 240 72 252 59 240 b 59 240 59 240 59 240 b 151 238 59 238 68 238 l 242 238 l 242 303 b 243 371 242 369 242 370 b 289 426 245 374 254 385 l 303 441 l 317 456 l 338 483 l 360 506 l 371 520 b 386 527 375 526 381 527 b 400 519 392 527 397 524 b 401 440 401 516 401 514 b 401 377 401 423 401 402 l 401 238 l 426 238 b 453 237 449 238 450 238 b 465 217 461 234 465 226 b 460 202 465 212 464 206 b 426 197 454 197 453 197 l 401 197 l 401 180 b 451 88 402 129 412 109 b 468 69 465 81 468 79 b 461 55 468 62 466 59 l 458 54 l 321 54 l 185 54 l 182 55 b 175 69 176 59 175 62 b 191 88 175 79 176 81 b 240 180 230 109 240 129 l 240 197 l 125 197 b 73 195 104 195 87 195 b 8 197 10 195 9 197 b 0 212 2 199 0 205 b 0 212 0 212 0 212 b 20 242 0 219 0 219 b 163 610 104 344 163 492 b 174 637 163 628 166 634 m 234 -1 l 235 -1 l 232 -1 l 234 -1 m 234 673 l 235 673 l 232 673 l 234 673 "},"v5":{"x_min":0,"x_max":409.6875,"ha":418,"o":"m 47 637 b 53 638 49 638 50 638 b 69 634 55 638 61 637 b 210 610 114 619 161 610 b 363 634 259 610 311 619 b 382 638 372 637 378 638 b 392 634 386 638 389 637 b 397 623 396 630 397 627 b 393 610 397 620 396 616 b 298 505 368 552 338 520 b 212 494 277 498 246 494 b 65 517 163 494 106 502 b 61 517 62 517 61 517 b 61 517 61 517 61 517 b 51 408 61 517 51 412 b 51 408 51 408 51 408 b 51 408 51 408 51 408 b 61 412 53 408 55 409 b 125 434 80 421 103 430 b 185 441 145 440 166 441 b 409 244 310 441 409 353 b 401 191 409 227 406 209 b 197 43 375 105 287 43 b 159 47 183 43 171 44 b 23 123 112 56 61 86 b 0 180 6 140 0 159 b 76 260 0 220 31 260 b 92 259 81 260 87 259 b 152 183 132 251 152 216 b 100 112 152 152 134 122 b 95 111 98 112 95 111 b 95 111 95 111 95 111 b 129 98 95 109 119 101 b 148 97 136 97 141 97 b 264 235 206 97 261 158 b 265 248 265 240 265 244 b 210 398 265 312 243 373 b 179 408 201 406 194 408 b 174 408 178 408 176 408 b 53 369 130 408 88 394 b 34 359 39 359 38 359 b 17 374 24 359 17 365 b 39 628 17 384 38 625 b 47 637 40 631 43 635 m 204 -1 l 205 -1 l 202 -1 l 204 -1 m 204 673 l 205 673 l 202 673 l 204 673 "},"v6":{"x_min":0,"x_max":475.03125,"ha":485,"o":"m 255 648 b 274 648 259 648 266 648 b 314 646 288 648 307 648 b 450 555 374 637 438 594 b 454 530 453 546 454 538 b 375 451 454 485 416 451 b 328 467 359 451 343 455 b 300 526 310 483 300 503 b 352 598 300 557 319 589 b 356 599 355 598 356 599 b 352 602 356 599 355 601 b 288 616 330 612 308 616 b 210 584 257 616 230 605 b 164 433 189 559 174 508 b 160 374 163 415 160 381 b 160 374 160 374 160 374 b 160 374 160 374 160 374 b 168 377 160 374 164 376 b 258 395 200 390 228 395 b 366 367 294 395 328 387 b 475 223 436 333 475 283 b 472 197 475 215 473 206 b 349 65 462 141 419 95 b 259 43 317 51 288 43 b 167 69 230 43 200 52 b 4 290 80 113 20 195 b 0 349 1 309 0 328 b 20 467 0 391 6 433 b 255 648 58 563 155 637 m 269 363 b 257 363 265 363 261 363 b 210 345 236 363 220 356 b 186 226 196 324 186 272 b 187 198 186 216 186 206 b 213 95 191 151 202 112 b 257 76 221 83 238 76 b 270 77 261 76 266 76 b 321 156 299 81 310 99 b 329 229 326 183 329 206 b 321 301 329 252 326 274 b 269 363 311 342 298 359 m 236 -1 l 238 -1 l 235 -1 l 236 -1 m 236 673 l 238 673 l 235 673 l 236 673 "},"v7":{"x_min":0,"x_max":442.359375,"ha":451,"o":"m 147 648 b 166 649 153 649 160 649 b 313 598 217 649 273 630 b 340 587 323 588 328 587 l 341 587 b 412 628 367 587 390 601 b 427 638 416 635 421 638 b 439 632 431 638 435 637 b 442 623 441 630 442 628 b 430 569 442 616 439 603 b 352 369 408 492 377 410 b 300 259 325 324 313 298 b 273 84 283 205 273 140 b 265 55 273 65 272 59 l 261 54 l 181 54 l 99 54 l 96 55 b 91 61 95 56 92 59 l 89 63 l 89 77 b 147 263 89 133 111 202 b 261 401 176 313 212 355 b 378 541 315 449 349 489 l 382 548 l 375 544 b 240 495 333 512 285 495 b 129 535 198 495 160 509 b 84 560 108 552 95 560 b 76 559 81 560 78 560 b 31 487 59 555 43 530 b 14 470 27 473 24 470 b 1 477 8 470 4 471 l 0 480 l 0 553 l 0 627 l 1 630 b 16 638 4 635 9 638 b 23 635 17 638 20 637 b 49 626 36 626 39 626 b 96 638 59 626 80 630 b 104 639 99 638 102 639 b 117 644 107 641 112 642 b 147 648 125 645 137 648 m 220 -1 l 221 -1 l 219 -1 l 220 -1 m 220 673 l 221 673 l 219 673 l 220 673 "},"v8":{"x_min":0,"x_max":488.640625,"ha":499,"o":"m 217 648 b 245 649 225 648 235 649 b 453 516 343 649 430 595 b 458 478 455 503 458 491 b 412 370 458 440 441 398 b 411 369 412 369 411 369 b 415 365 411 367 412 367 b 488 231 462 331 488 281 b 472 165 488 208 483 186 b 243 43 434 86 338 43 b 63 104 178 43 112 62 b 0 233 20 140 0 186 b 73 365 0 283 24 331 l 77 369 l 72 374 b 29 476 42 406 29 441 b 217 648 29 557 103 635 m 258 605 b 242 606 253 605 247 606 b 157 552 198 606 157 580 b 160 541 157 548 159 544 b 319 413 176 503 242 452 l 337 403 l 338 406 b 359 476 352 428 359 452 b 258 605 359 537 318 595 m 138 326 b 130 330 134 328 130 330 b 130 330 130 330 130 330 b 107 305 127 330 112 313 b 84 231 91 281 84 256 b 243 86 84 156 151 86 b 249 87 245 86 246 87 b 347 156 303 88 347 120 b 344 172 347 162 345 167 b 156 319 325 227 257 281 b 138 326 151 322 144 324 m 243 -1 l 245 -1 l 242 -1 l 243 -1 m 243 673 l 245 673 l 242 673 l 243 673 "},"v9":{"x_min":0,"x_max":475.03125,"ha":485,"o":"m 191 646 b 212 649 198 648 205 649 b 255 644 227 649 243 646 b 458 448 348 616 428 539 b 475 342 469 415 475 378 b 460 244 475 308 469 274 b 193 44 421 124 303 44 b 91 69 157 44 122 51 b 19 161 43 97 19 126 b 21 181 19 167 20 174 b 98 241 32 220 65 241 b 170 186 129 241 160 223 b 172 166 171 179 172 173 b 121 94 172 134 152 102 b 117 93 118 94 117 93 b 121 90 117 93 118 91 b 185 76 142 80 164 76 b 270 119 220 76 251 91 b 308 259 287 145 300 194 b 313 317 310 277 313 310 b 313 317 313 317 313 317 b 313 317 313 317 313 317 b 304 315 313 317 308 316 b 216 295 273 302 245 295 b 145 308 193 295 170 299 b 19 398 88 327 42 360 b 0 469 5 420 0 444 b 24 551 0 496 8 526 b 191 646 54 596 125 637 m 227 614 b 215 616 224 616 220 616 b 202 614 210 616 206 616 b 152 535 174 610 163 592 b 144 463 147 509 144 485 b 152 391 144 440 147 417 b 216 328 163 344 179 328 b 280 391 253 328 269 344 b 288 463 285 417 288 440 b 280 535 288 485 285 509 b 227 614 269 594 258 610 m 236 -1 l 238 -1 l 235 -1 l 236 -1 m 236 673 l 238 673 l 235 673 l 236 673 "},"va":{"x_min":-149.71875,"x_max":148.359375,"ha":151,"o":"m -8 -1 b -1 0 -5 -1 -4 0 b 16 -11 5 0 13 -4 b 83 -186 17 -12 47 -90 l 148 -358 l 148 -363 b 127 -385 148 -376 138 -385 b 112 -378 122 -385 118 -383 b 54 -226 110 -374 114 -385 b 0 -81 24 -147 0 -81 b -55 -226 -1 -81 -25 -147 b -114 -378 -115 -385 -111 -374 b -129 -385 -119 -383 -123 -385 b -149 -363 -140 -385 -149 -376 l -149 -358 l -84 -186 b -19 -11 -49 -90 -19 -12 b -8 -1 -17 -8 -12 -4 "},"vb":{"x_min":0,"x_max":428.75,"ha":438,"o":"m 262 186 b 273 186 266 186 272 186 b 274 186 273 186 274 186 b 285 186 274 186 280 186 b 428 48 375 181 428 122 b 386 -68 428 12 416 -29 b 155 -187 329 -145 236 -187 b 12 -111 92 -187 38 -162 b 0 -51 4 -91 0 -72 b 262 186 0 58 122 179 "},"vc":{"x_min":0,"x_max":447.8125,"ha":457,"o":"m 0 86 l 0 173 l 223 173 l 447 173 l 447 86 l 447 0 l 223 0 l 0 0 l 0 86 "},"vf":{"x_min":0,"x_max":370.21875,"ha":378,"o":"m 0 0 l 0 277 l 61 277 l 122 277 l 122 0 l 122 -278 l 61 -278 l 0 -278 l 0 0 m 246 -1 l 246 277 l 308 277 l 370 277 l 370 -1 l 370 -278 l 308 -278 l 246 -278 l 246 -1 "},"v10":{"x_min":0,"x_max":559.421875,"ha":571,"o":"m 5 127 b 14 127 6 127 9 127 b 51 126 25 127 43 127 b 175 98 93 122 138 112 l 186 94 b 279 51 210 86 255 65 b 285 47 280 51 283 48 b 319 27 291 44 311 31 l 326 22 b 359 0 332 19 352 4 l 367 -6 b 371 -9 368 -6 370 -8 l 379 -15 b 387 -22 383 -18 386 -20 l 398 -30 l 411 -40 l 417 -47 l 427 -55 l 434 -61 b 441 -66 436 -62 439 -65 l 446 -72 l 453 -77 l 462 -87 b 558 -188 490 -113 549 -176 b 559 -195 559 -191 559 -194 b 548 -205 559 -201 555 -205 b 541 -204 547 -205 544 -205 b 534 -198 539 -201 536 -199 l 525 -191 b 481 -162 518 -187 490 -167 b 472 -155 477 -159 472 -156 b 468 -152 470 -155 469 -154 b 461 -149 466 -152 464 -151 b 428 -130 454 -145 441 -137 b 371 -99 413 -122 372 -99 b 363 -95 371 -99 367 -98 b 353 -91 357 -94 353 -91 b 348 -90 353 -91 352 -91 b 332 -81 343 -87 341 -86 b 27 -12 230 -37 127 -13 b 0 -5 4 -11 2 -11 b 0 58 0 -2 0 27 b 0 122 0 88 0 120 b 5 127 1 124 4 126 "},"v11":{"x_min":-155.171875,"x_max":153.8125,"ha":157,"o":"m -137 353 b -130 353 -136 353 -133 353 b -112 349 -125 353 -119 352 b -100 342 -110 347 -104 344 b 0 317 -69 326 -35 317 b 111 349 38 317 76 328 b 129 353 117 352 123 353 b 153 327 142 353 153 344 b 144 302 153 320 153 317 b 27 6 93 226 50 113 b 21 -13 24 -11 24 -11 b 0 -26 17 -22 8 -26 b -24 -12 -9 -26 -19 -22 b -28 5 -24 -9 -27 -2 b -145 302 -53 117 -95 224 b -155 327 -155 317 -155 320 b -137 353 -155 340 -148 349 "},"v18":{"x_min":0,"x_max":323.9375,"ha":331,"o":"m 217 535 b 225 537 220 537 221 537 b 245 524 235 537 242 533 l 246 521 l 247 390 l 247 258 l 273 265 b 306 270 288 269 299 270 b 322 259 315 270 319 267 b 323 208 323 256 323 233 b 322 158 323 184 323 159 b 288 140 318 148 315 147 b 247 130 254 131 247 130 b 247 65 247 130 247 104 b 247 20 247 51 247 36 l 247 -88 l 273 -81 b 306 -76 289 -77 299 -76 b 318 -81 311 -76 315 -77 b 323 -123 323 -87 323 -86 l 323 -138 l 323 -154 b 318 -195 323 -191 323 -190 b 269 -210 314 -199 315 -199 b 249 -216 259 -213 250 -216 l 247 -216 l 247 -349 l 246 -483 l 245 -487 b 225 -499 242 -495 234 -499 b 206 -487 219 -499 210 -495 l 205 -483 l 205 -355 l 205 -227 l 204 -227 l 181 -233 l 138 -244 b 117 -249 127 -247 117 -249 b 115 -385 115 -249 115 -256 l 115 -523 l 114 -526 b 95 -538 110 -534 102 -538 b 74 -526 87 -538 78 -534 l 73 -523 l 73 -391 b 72 -260 73 -269 73 -260 b 72 -260 72 -260 72 -260 b 19 -273 61 -263 23 -273 b 0 -260 10 -273 4 -267 b 0 -209 0 -256 0 -256 l 0 -162 l 1 -158 b 61 -134 5 -148 5 -148 l 73 -131 l 73 -22 b 72 86 73 79 73 86 b 72 86 72 86 72 86 b 19 74 61 83 23 74 b 0 86 10 74 4 79 b 0 137 0 90 0 90 l 0 184 l 1 188 b 61 212 5 198 5 198 l 73 215 l 73 348 l 73 481 l 74 485 b 95 498 78 492 87 498 b 103 495 98 498 100 496 b 114 485 107 494 111 489 l 115 481 l 115 353 l 115 226 l 121 226 b 159 235 123 227 141 231 l 198 247 l 205 248 l 205 384 l 205 521 l 206 524 b 217 535 209 528 212 533 m 205 9 b 205 119 205 70 205 119 l 205 119 b 182 113 204 119 194 116 l 138 102 b 117 97 127 99 117 97 b 115 -12 115 97 115 91 l 115 -122 l 121 -120 b 159 -111 123 -119 141 -115 l 198 -101 l 205 -98 l 205 9 "},"v1b":{"x_min":0,"x_max":559.421875,"ha":571,"o":"m 544 204 b 548 204 545 204 547 204 b 559 194 555 204 559 199 b 559 190 559 192 559 191 b 530 156 559 188 556 184 b 462 86 510 134 481 104 b 453 76 458 81 454 77 l 446 70 l 441 65 b 434 59 439 63 436 61 l 427 54 b 409 37 426 51 416 44 b 392 23 398 29 394 26 b 387 19 389 22 387 20 b 379 13 386 19 383 16 l 371 8 l 367 5 l 359 -1 l 337 -16 b 285 -48 319 -29 298 -41 l 279 -52 b 186 -95 255 -66 210 -87 l 175 -99 b 23 -129 127 -117 68 -129 b 17 -129 20 -129 19 -129 b 1 -123 2 -129 2 -129 b 0 -49 0 -122 0 -83 b 0 4 0 -22 0 1 b 27 11 2 9 4 9 b 185 31 78 12 145 20 b 198 34 186 31 193 33 b 314 73 234 44 277 58 b 349 88 328 79 340 84 b 353 90 352 90 353 90 b 363 94 353 90 357 93 b 371 98 367 97 371 98 b 428 129 372 98 413 120 b 461 148 441 136 454 144 b 468 151 464 149 466 151 b 472 154 469 152 470 154 b 481 161 473 155 477 158 b 525 190 490 166 518 186 l 534 197 b 540 201 536 198 539 199 b 544 204 541 202 544 204 "},"v1d":{"x_min":0,"x_max":619.3125,"ha":632,"o":"m 274 184 b 307 186 285 186 296 186 b 616 22 465 186 597 116 b 619 -1 617 13 619 5 b 308 -187 619 -104 483 -187 b 0 -1 133 -187 0 -102 b 5 36 0 11 1 23 b 274 184 29 115 141 176 m 289 161 b 272 162 284 162 277 162 b 171 41 209 162 171 108 b 205 -73 171 5 182 -34 b 345 -163 243 -133 298 -163 b 436 -98 385 -163 420 -142 b 446 -43 443 -80 446 -62 b 289 161 446 47 377 147 "},"v1e":{"x_min":-402.890625,"x_max":401.53125,"ha":410,"o":"m -219 173 b -213 174 -217 174 -215 174 b -202 173 -209 174 -205 173 b -114 86 -200 172 -179 151 b -28 0 -66 37 -28 0 b 40 84 -28 0 2 37 b 117 174 111 173 110 172 b 122 174 118 174 119 174 b 132 173 125 174 129 173 b 295 11 134 172 171 134 l 307 -1 l 336 34 b 374 76 366 72 368 74 b 381 77 375 77 378 77 b 401 56 392 77 401 68 b 400 48 401 54 401 51 b 223 -172 397 41 230 -166 b 210 -176 220 -174 215 -176 b 201 -174 206 -176 204 -176 b 112 -87 198 -173 178 -152 b 27 0 65 -38 27 0 b -42 -86 27 0 -4 -38 b -118 -174 -112 -174 -111 -173 b -123 -176 -119 -176 -121 -176 b -133 -174 -126 -176 -130 -174 b -296 -12 -136 -173 -172 -137 l -308 0 l -337 -34 b -375 -77 -367 -73 -370 -76 b -382 -79 -377 -79 -379 -79 b -402 -58 -393 -79 -402 -69 b -401 -49 -402 -55 -402 -52 b -224 172 -398 -43 -228 167 b -219 173 -223 172 -220 173 "},"v1f":{"x_min":-340.28125,"x_max":338.921875,"ha":346,"o":"m -32 520 b -29 521 -31 520 -31 521 b -23 519 -27 521 -24 520 b -20 513 -21 517 -20 516 b -21 506 -20 512 -20 509 b -31 474 -23 502 -27 488 l -53 402 l -66 352 l -68 349 l -57 349 b -32 351 -51 349 -40 351 b 123 370 19 352 74 359 b 137 371 127 370 133 371 b 170 356 152 371 164 366 b 171 355 170 355 170 355 b 216 366 174 355 183 358 b 280 378 268 377 266 377 b 287 378 283 378 284 378 b 332 349 307 378 322 369 b 338 319 336 341 338 330 b 332 301 338 310 336 302 b 242 280 329 299 246 280 b 242 280 242 280 242 280 b 235 288 236 280 235 283 b 235 292 235 290 235 291 b 236 302 236 297 236 299 b 220 337 236 316 230 330 l 216 340 l 210 335 b 159 276 189 322 172 301 b 118 149 152 265 156 274 b 81 34 84 36 85 36 b -8 13 78 33 -4 13 b -8 13 -8 13 -8 13 b -14 20 -12 15 -14 15 b -8 44 -14 24 -12 31 b -2 66 -5 55 -2 65 b -2 66 -2 66 -2 66 l -2 66 b -43 41 -2 66 -21 55 b -114 4 -98 8 -98 8 b -144 0 -123 0 -134 0 b -242 99 -197 0 -242 43 b -242 109 -242 102 -242 105 b -212 219 -240 122 -242 116 b -185 312 -197 270 -185 312 l -185 312 b -189 312 -185 312 -186 312 b -259 312 -200 312 -227 312 b -321 310 -291 312 -310 310 b -334 312 -330 310 -334 312 b -340 319 -338 313 -340 316 b -336 326 -340 322 -338 324 b -291 337 -334 326 -314 331 l -247 347 l -210 348 b -172 348 -190 348 -172 348 b -168 363 -172 348 -171 355 b -145 442 -151 424 -145 441 b -133 452 -144 444 -140 446 l -77 489 b -32 520 -53 506 -32 520 m 57 334 b 53 335 55 335 54 335 b 44 334 50 335 49 335 b -70 316 8 326 -28 320 b -78 309 -78 316 -78 316 b -108 202 -80 305 -88 274 b -141 81 -136 112 -141 93 b -140 74 -141 79 -141 77 b -117 49 -137 59 -127 49 b -107 52 -114 49 -110 51 b 16 127 -106 54 14 126 b 42 217 16 127 42 215 b 49 241 42 222 44 229 b 73 320 53 251 73 317 b 57 334 73 327 65 333 "},"v20":{"x_min":-571.671875,"x_max":570.3125,"ha":582,"o":"m -559 351 b -551 352 -556 352 -553 352 b -530 338 -543 352 -533 348 b -529 169 -530 337 -529 291 l -529 1 l -507 27 l -441 112 b -382 174 -394 169 -390 174 b -378 174 -381 174 -379 174 b -281 86 -370 174 -375 179 b -196 0 -234 37 -196 0 b -126 84 -196 0 -164 37 b -50 174 -55 173 -57 172 b -44 174 -49 174 -47 174 b -35 173 -42 174 -38 173 b 53 86 -32 172 -12 151 b 138 0 100 37 138 0 b 208 84 140 0 170 37 b 284 174 279 173 279 172 b 289 174 285 174 288 174 b 300 173 294 174 298 173 b 462 11 303 172 340 134 l 475 -1 l 503 34 b 541 76 534 72 536 74 b 548 77 544 77 545 77 b 570 56 560 77 570 68 b 567 48 570 54 568 51 b 392 -172 564 41 397 -166 b 378 -176 387 -174 382 -176 b 368 -174 375 -176 371 -176 b 280 -87 367 -173 347 -152 b 194 0 234 -38 194 0 b 126 -86 194 0 163 -38 b 49 -174 54 -174 55 -173 b 44 -176 47 -176 46 -176 b 34 -174 40 -176 36 -174 b -54 -87 31 -173 10 -152 b -140 0 -102 -38 -140 0 b -209 -86 -140 0 -171 -38 b -285 -174 -280 -174 -279 -173 b -291 -176 -287 -176 -288 -176 b -300 -174 -294 -176 -298 -174 b -464 -11 -303 -173 -374 -102 l -476 0 l -506 -37 b -539 -76 -528 -65 -537 -74 b -551 -80 -543 -79 -547 -80 b -570 -68 -558 -80 -566 -76 l -571 -65 l -571 136 b -570 340 -571 331 -571 337 b -559 351 -568 344 -564 348 "},"v22":{"x_min":0,"x_max":432.828125,"ha":442,"o":"m 209 186 b 213 187 210 187 212 187 b 216 187 215 187 216 187 b 224 174 216 186 220 180 b 420 -1 269 105 338 43 b 432 -12 431 -8 432 -9 b 421 -23 432 -15 432 -16 b 228 -180 345 -70 264 -137 b 219 -188 221 -188 221 -188 l 219 -188 b 208 -177 215 -188 215 -188 b 10 1 163 -106 93 -44 b 0 11 0 6 0 8 b 10 22 0 13 0 15 b 202 179 87 69 167 136 b 209 186 206 183 209 186 "},"v23":{"x_min":0,"x_max":133.390625,"ha":136,"o":"m 54 66 b 65 68 58 68 61 68 b 122 37 88 68 110 56 b 133 -1 130 26 133 12 b 104 -58 133 -23 123 -44 b 66 -69 92 -65 78 -69 b 10 -38 44 -69 23 -58 b 0 -1 2 -27 0 -13 b 54 66 0 30 20 61 "},"v25":{"x_min":0,"x_max":318.5,"ha":325,"o":"m 20 376 b 167 377 23 377 96 377 b 296 376 231 377 294 377 b 318 347 311 371 318 359 b 296 316 318 333 311 320 b 159 315 294 315 227 315 b 21 316 91 315 24 315 b 0 345 6 320 0 333 b 20 376 0 359 6 371 "},"v26":{"x_min":-21.78125,"x_max":483.1875,"ha":493,"o":"m -8 631 b -1 632 -6 632 -4 632 b 19 620 8 632 16 628 b 20 383 20 616 20 616 l 20 148 l 21 151 b 140 199 59 183 102 199 b 206 179 164 199 187 192 l 210 176 l 210 396 l 210 617 l 212 621 b 231 632 216 628 223 632 b 250 620 239 632 247 628 b 251 383 251 616 251 616 l 251 148 l 254 151 b 370 199 291 183 332 199 b 415 191 385 199 400 197 b 483 84 458 176 483 134 b 461 0 483 58 476 29 b 332 -142 439 -40 411 -72 l 255 -215 b 231 -229 240 -229 239 -229 b 216 -223 224 -229 220 -227 b 210 -158 210 -217 210 -223 b 210 -120 210 -148 210 -136 l 210 -29 l 205 -34 b 100 -142 182 -65 159 -88 l 23 -215 b -1 -229 9 -229 6 -229 b -20 -216 -9 -229 -17 -224 l -21 -212 l -21 201 l -21 616 l -20 620 b -8 631 -17 624 -13 630 m 110 131 b 96 133 106 133 100 133 b 89 133 93 133 91 133 b 24 87 63 129 40 113 l 20 80 l 20 -37 l 20 -156 l 23 -152 b 144 81 96 -72 144 20 l 144 83 b 110 131 144 113 134 126 m 341 131 b 328 133 337 133 332 133 b 322 133 326 133 323 133 b 257 87 296 129 273 113 l 251 80 l 251 -37 l 251 -156 l 255 -152 b 375 81 328 -72 375 20 l 375 83 b 341 131 375 113 367 126 "},"v27":{"x_min":0,"x_max":432.828125,"ha":442,"o":"m 208 184 b 213 187 209 186 212 187 b 224 176 217 187 221 183 b 245 147 225 172 235 159 b 419 -1 288 90 347 38 b 431 -8 424 -4 431 -8 b 432 -12 432 -9 432 -11 b 430 -18 432 -13 432 -16 b 364 -61 424 -20 383 -47 b 225 -183 307 -102 250 -152 b 223 -187 224 -184 223 -187 b 220 -188 221 -188 220 -188 b 208 -176 216 -188 210 -184 b 187 -148 205 -173 197 -159 b 12 0 144 -90 84 -38 b 0 11 4 5 0 8 b 16 24 0 13 4 18 b 183 158 83 69 141 115 b 208 184 194 169 198 173 m 183 105 b 176 113 181 109 176 113 b 172 109 176 113 175 112 b 92 45 149 90 117 62 l 88 41 l 102 31 b 247 -105 160 -6 210 -55 l 254 -115 l 257 -112 l 269 -102 b 340 -45 287 -87 319 -61 l 344 -43 l 330 -33 b 183 105 272 6 221 54 "},"v28":{"x_min":-73.5,"x_max":72.140625,"ha":74,"o":"m -72 252 l -73 254 l 0 254 l 72 254 l 70 252 b 0 -1 70 248 0 -1 b -72 252 -1 -1 -72 248 "},"v29":{"x_min":-590.71875,"x_max":589.359375,"ha":601,"o":"m 175 273 b 182 274 178 273 181 274 b 202 262 190 274 198 269 b 204 158 204 259 204 259 l 204 56 l 250 112 b 303 174 296 172 298 172 b 308 174 304 174 307 174 b 318 173 313 174 317 173 b 481 11 322 172 357 134 l 494 -1 l 522 34 b 560 76 553 72 555 74 b 567 77 563 77 564 77 b 589 56 579 77 589 68 b 586 48 589 54 588 51 b 411 -172 583 41 416 -166 b 397 -176 406 -174 401 -176 b 387 -174 393 -176 390 -176 b 299 -87 386 -173 366 -152 b 213 0 253 -38 213 0 b 208 -6 213 0 210 -2 l 204 -12 l 204 -147 b 204 -210 204 -173 204 -194 b 198 -292 204 -297 204 -287 b 183 -299 194 -297 189 -299 b 164 -287 175 -299 167 -295 b 163 -174 163 -284 163 -284 l 161 -63 l 119 -117 b 65 -176 76 -170 73 -176 b 61 -176 63 -176 62 -176 b -35 -87 51 -174 57 -180 b -121 0 -83 -38 -121 0 b -190 -86 -122 0 -152 -38 b -266 -174 -261 -174 -259 -173 b -272 -176 -268 -176 -270 -176 b -281 -174 -276 -176 -280 -174 b -371 -86 -284 -173 -304 -152 b -457 0 -417 -38 -457 0 l -457 0 b -477 -26 -457 0 -470 -16 b -548 -227 -524 -88 -548 -161 b -536 -303 -548 -254 -544 -280 b -533 -317 -534 -309 -533 -313 b -553 -338 -533 -330 -541 -338 b -577 -315 -566 -338 -571 -333 b -590 -227 -586 -287 -590 -258 b -518 -9 -590 -154 -564 -77 b -465 56 -509 2 -504 8 l -402 134 b -363 174 -374 170 -371 174 b -359 174 -362 174 -360 174 b -262 86 -351 174 -356 179 b -176 0 -216 37 -176 0 b -107 84 -176 0 -145 37 b -31 174 -36 173 -38 172 b -25 174 -29 174 -28 174 b -16 173 -23 174 -19 173 b 147 11 -13 172 35 123 l 157 -1 l 160 1 l 163 4 l 163 130 b 164 260 163 256 163 258 b 175 273 166 266 170 270 "},"v2a":{"x_min":-21.78125,"x_max":366.140625,"ha":374,"o":"m 276 1378 b 284 1379 279 1379 281 1379 b 306 1360 292 1379 298 1374 b 352 1247 326 1326 343 1286 b 366 1139 362 1213 366 1175 b 347 1009 366 1093 359 1049 l 344 1002 l 347 992 b 352 971 348 986 351 977 b 366 863 362 936 366 899 b 347 732 366 818 359 773 l 344 725 l 347 716 b 352 695 348 710 351 700 b 366 588 362 659 366 623 b 223 262 366 464 314 345 b 189 233 212 252 212 252 b 35 76 126 183 73 129 b -1 16 20 56 2 27 b -19 4 -4 9 -12 4 l -21 4 l -21 137 l -21 270 l -17 270 b 186 344 59 281 134 308 b 319 606 270 399 319 499 b 317 650 319 620 319 635 l 315 659 l 314 655 b 223 537 288 607 258 570 b 189 509 212 528 212 528 b 35 352 126 459 73 405 b -1 292 20 333 2 303 b -19 280 -4 285 -12 280 l -21 280 l -21 413 l -21 546 l -17 546 b 186 620 59 557 134 584 b 319 882 270 675 319 775 b 317 925 319 896 319 911 l 315 935 l 314 931 b 223 813 288 884 258 846 b 189 785 212 805 212 805 b 35 628 126 735 73 681 b -1 569 20 609 2 580 b -19 556 -4 562 -12 556 l -21 556 l -21 689 l -21 823 l -17 823 b 202 907 68 835 152 867 b 319 1157 280 968 319 1061 b 270 1338 319 1218 303 1281 b 262 1358 264 1349 262 1353 b 262 1364 262 1360 262 1363 b 276 1378 265 1371 269 1376 "},"v2c":{"x_min":-597.53125,"x_max":596.171875,"ha":608,"o":"m -413 173 b -408 174 -412 174 -409 174 b -397 173 -404 174 -400 173 b -308 86 -394 172 -374 151 b -223 0 -261 37 -223 0 b -153 84 -223 0 -191 37 b -77 174 -83 173 -84 172 b -72 174 -76 174 -74 174 b -62 173 -68 174 -63 173 b 25 86 -59 172 -39 151 b 112 0 73 37 111 0 b 181 84 112 0 144 37 b 257 174 251 173 251 172 b 262 174 258 174 261 174 b 273 173 266 174 270 173 b 436 9 276 172 347 101 l 447 -1 l 477 36 b 522 79 511 79 513 79 l 522 79 b 552 51 533 79 539 73 b 596 -112 582 6 596 -51 b 567 -262 596 -161 586 -213 b 539 -322 558 -287 544 -316 b 524 -327 534 -326 529 -327 b 504 -315 515 -327 507 -323 b 503 -308 503 -312 503 -309 b 511 -285 503 -302 504 -297 b 555 -113 540 -227 555 -169 b 544 -34 555 -86 551 -59 b 522 19 540 -16 530 8 l 521 22 l 481 -26 l 405 -122 b 353 -176 366 -172 362 -176 b 349 -176 352 -176 351 -176 b 253 -87 341 -176 347 -180 b 167 0 206 -38 167 0 b 99 -86 167 0 136 -38 b 21 -174 27 -174 28 -173 b 17 -176 20 -176 19 -176 b 6 -174 13 -176 9 -174 b -81 -87 4 -173 -14 -152 b -167 0 -129 -38 -167 0 b -236 -86 -167 0 -198 -38 b -313 -174 -307 -174 -306 -173 b -318 -176 -314 -176 -315 -176 b -328 -174 -321 -176 -325 -174 b -491 -12 -330 -173 -367 -137 l -503 0 l -530 -34 b -570 -77 -562 -73 -564 -76 b -577 -79 -571 -79 -574 -79 b -597 -58 -588 -79 -597 -69 b -596 -49 -597 -55 -597 -52 b -417 172 -593 -43 -423 167 b -413 173 -417 172 -415 173 "},"v2d":{"x_min":0,"x_max":438.28125,"ha":447,"o":"m 212 190 b 219 191 213 191 216 191 b 236 176 225 191 228 190 b 419 18 277 105 341 49 b 436 5 431 13 434 11 b 438 -1 438 4 438 1 b 424 -16 438 -8 432 -13 b 356 -49 409 -20 379 -36 b 234 -180 306 -83 258 -133 b 219 -192 230 -188 224 -192 b 200 -176 213 -192 206 -187 b 9 -15 157 -102 89 -45 b 0 0 2 -12 0 -6 b 16 18 0 9 2 12 b 200 176 93 48 159 104 b 212 190 205 186 208 188 m 239 113 b 236 117 238 116 238 117 b 230 108 235 117 234 115 b 92 -15 196 58 140 8 b 88 -18 91 -16 88 -18 b 92 -20 88 -18 91 -19 b 198 -116 130 -43 166 -74 b 200 -117 200 -117 200 -117 b 201 -117 200 -117 201 -117 b 264 -43 212 -98 242 -62 b 345 15 288 -19 321 4 b 348 18 347 16 348 16 b 344 20 348 18 347 19 b 239 113 307 41 266 79 "},"v2f":{"x_min":-1.359375,"x_max":680.5625,"ha":694,"o":"m 597 1042 b 604 1042 600 1042 602 1042 b 642 1002 627 1042 642 1022 b 619 966 642 988 635 974 b 439 927 574 942 503 927 l 426 927 l 426 921 b 430 838 428 893 430 866 b 345 480 430 696 398 560 b 179 391 307 423 249 391 b 156 392 171 391 164 392 b 138 394 149 394 142 394 b 103 434 115 396 103 416 b 129 471 103 451 111 466 b 141 474 133 473 137 474 b 172 459 153 474 164 469 b 181 455 175 456 176 455 b 187 456 182 455 185 455 b 253 520 212 460 234 483 b 315 836 294 605 315 714 b 311 928 315 867 314 898 b 302 945 310 943 311 942 b 245 953 283 950 262 953 b 130 891 193 953 149 931 b 84 860 119 870 102 860 b 36 905 61 860 39 877 b 36 910 36 907 36 909 b 80 970 36 931 50 949 b 249 1017 125 1000 187 1017 b 322 1009 273 1017 299 1014 l 341 1003 b 436 991 372 995 406 991 b 577 1031 495 991 545 1004 b 597 1042 583 1038 590 1041 m 416 360 b 424 360 419 360 421 360 b 481 309 454 360 479 338 b 503 145 484 280 495 199 b 585 -185 525 16 555 -106 b 630 -245 596 -213 613 -237 l 634 -247 l 638 -245 b 647 -244 641 -245 645 -244 b 680 -278 666 -244 680 -262 b 664 -308 680 -290 675 -301 b 638 -312 658 -310 650 -312 b 613 -309 631 -312 623 -310 b 477 -201 555 -303 502 -260 b 417 -2 460 -159 434 -72 b 416 5 417 1 416 5 b 416 5 416 5 416 5 b 411 -5 415 5 413 0 b 359 -97 397 -33 377 -70 b 353 -106 355 -102 353 -105 b 359 -112 353 -108 355 -109 b 409 -130 375 -123 390 -129 b 426 -134 420 -130 421 -131 b 431 -147 428 -137 431 -141 b 420 -162 431 -152 427 -159 b 382 -169 409 -166 396 -169 b 323 -155 363 -169 341 -165 l 317 -152 l 314 -155 b 62 -303 240 -240 148 -295 b 36 -305 55 -305 44 -305 b 23 -303 29 -305 24 -305 b -1 -273 6 -299 -1 -287 b 31 -240 -1 -256 10 -240 b 36 -240 32 -240 34 -240 b 42 -241 38 -241 39 -241 b 134 -204 63 -241 99 -226 b 367 288 265 -115 357 81 b 375 330 368 313 370 320 b 416 360 383 347 400 358 m 360 -359 b 379 -359 363 -359 371 -359 b 424 -360 396 -359 416 -359 b 646 -502 536 -373 624 -430 b 649 -527 649 -510 649 -519 b 530 -673 649 -578 604 -635 l 521 -677 l 529 -681 b 653 -811 592 -714 637 -762 b 660 -853 658 -827 660 -839 b 645 -911 660 -873 656 -892 b 426 -1021 608 -981 519 -1021 b 283 -989 377 -1021 328 -1011 b 235 -949 249 -972 239 -964 b 234 -936 234 -946 234 -941 b 234 -928 234 -934 234 -931 l 235 -925 l 234 -927 l 225 -934 b 87 -982 186 -966 138 -982 b 80 -982 85 -982 83 -982 b 55 -981 70 -981 58 -981 b 17 -943 32 -981 17 -964 b 54 -904 17 -921 35 -904 b 78 -914 62 -904 72 -909 l 83 -918 l 88 -918 b 190 -831 122 -918 166 -881 b 269 -506 242 -727 269 -612 b 268 -462 269 -492 269 -477 b 266 -449 266 -458 266 -452 b 265 -444 266 -445 266 -444 b 257 -446 264 -444 261 -445 b 132 -545 196 -470 152 -505 b 88 -573 122 -563 104 -573 b 39 -523 63 -573 39 -553 b 63 -476 39 -505 44 -494 b 360 -359 136 -408 235 -369 m 419 -424 b 393 -423 411 -423 406 -423 l 375 -423 l 377 -426 b 379 -439 377 -427 378 -434 b 383 -510 382 -463 383 -487 b 314 -811 383 -609 360 -710 b 266 -893 296 -850 285 -870 b 264 -898 265 -896 264 -898 l 264 -898 b 264 -898 264 -898 264 -898 b 268 -898 264 -898 266 -898 b 273 -898 270 -898 272 -898 b 300 -909 283 -898 291 -900 b 426 -957 340 -941 385 -957 b 476 -949 443 -957 460 -954 b 547 -853 522 -931 547 -893 b 485 -745 547 -816 526 -775 b 397 -707 460 -727 432 -714 b 366 -675 375 -703 366 -692 b 396 -642 366 -657 377 -645 b 530 -557 455 -637 511 -601 b 536 -527 534 -548 536 -537 b 419 -424 536 -480 490 -437 "},"v30":{"x_min":-21.78125,"x_max":367.5,"ha":375,"o":"m 276 1900 b 284 1901 279 1900 281 1901 b 306 1883 291 1901 298 1896 b 367 1686 347 1825 367 1757 b 343 1558 367 1643 359 1600 l 338 1549 l 343 1537 b 367 1411 359 1497 367 1454 b 343 1282 367 1367 359 1324 l 338 1272 l 343 1261 b 367 1135 359 1221 367 1178 b 343 1007 367 1090 359 1047 l 338 996 l 343 985 b 367 859 359 945 367 902 b 343 731 367 814 359 771 l 338 720 l 343 709 b 367 582 359 667 367 626 b 289 362 367 503 340 426 b 239 312 276 345 259 330 b 29 77 152 237 76 152 b -1 18 14 54 2 30 b -19 4 -4 11 -12 4 l -21 4 l -21 133 l -20 260 l -13 262 b 98 299 17 269 62 284 b 111 305 103 302 110 305 b 167 334 123 310 156 327 b 319 595 264 391 319 491 b 313 659 319 616 318 638 b 310 667 311 664 311 667 b 307 663 310 667 308 666 b 240 588 289 637 269 614 b 16 331 141 505 62 413 b -1 294 8 316 1 302 b -19 280 -4 287 -12 280 l -21 280 l -21 408 l -20 537 l -13 538 b 98 576 17 545 62 560 b 111 581 103 578 110 581 b 167 610 123 587 156 603 b 319 871 264 667 319 767 b 313 935 319 892 318 913 b 310 942 311 941 311 942 b 307 939 310 942 308 941 b 240 864 289 913 269 889 b 16 607 141 781 62 689 b -1 570 8 592 1 578 b -19 556 -4 563 -12 556 l -21 556 l -21 684 l -20 813 l -13 814 b 98 852 17 821 62 836 b 111 857 103 855 110 857 b 167 886 123 863 156 880 b 319 1147 264 943 319 1043 b 313 1211 319 1168 318 1189 b 310 1218 311 1217 311 1218 b 307 1215 310 1218 308 1217 b 240 1140 289 1188 269 1165 b 16 884 141 1057 62 966 b -1 846 8 868 1 855 b -19 832 -4 839 -12 832 l -21 832 l -21 960 l -20 1089 l -13 1090 b 98 1128 17 1097 62 1111 b 111 1134 103 1131 110 1134 b 167 1163 123 1139 156 1156 b 319 1424 264 1220 319 1320 b 313 1486 319 1444 318 1465 b 310 1494 311 1493 311 1494 b 307 1492 310 1494 308 1493 b 240 1417 289 1464 269 1442 b 16 1160 141 1333 62 1242 b -1 1121 8 1145 1 1131 b -19 1109 -4 1115 -12 1109 l -21 1109 l -21 1236 l -20 1365 l -13 1367 b 98 1404 17 1374 62 1388 b 111 1410 103 1407 110 1410 b 250 1508 172 1437 215 1467 b 319 1701 296 1564 319 1633 b 270 1859 319 1757 303 1814 b 262 1882 265 1868 262 1875 b 276 1900 262 1890 266 1896 "},"v31":{"x_min":0,"x_max":386.5625,"ha":394,"o":"m 0 173 l 0 347 l 193 347 l 386 347 l 386 173 l 386 0 l 193 0 l 0 0 l 0 173 "},"v33":{"x_min":-423.3125,"x_max":421.9375,"ha":431,"o":"m -10 276 b -2 277 -8 277 -5 277 b 17 265 5 277 13 273 b 19 163 19 260 19 260 l 19 68 l 39 45 b 277 -95 122 -34 200 -81 b 289 -97 281 -97 285 -97 b 378 0 332 -97 371 -54 b 378 11 378 4 378 6 b 302 83 378 55 345 83 b 242 66 283 83 262 77 b 208 56 231 59 219 56 b 148 120 175 56 148 81 b 200 186 148 151 164 172 b 261 198 220 194 240 198 b 420 45 341 198 411 137 b 421 22 421 37 421 29 b 257 -198 421 -86 347 -188 b 242 -198 251 -198 247 -198 b 20 -105 181 -198 95 -163 l 19 -104 l 19 -183 b 19 -216 19 -195 19 -206 b 12 -273 19 -272 17 -267 b -2 -278 8 -277 2 -278 b -21 -266 -10 -278 -19 -274 b -23 -165 -23 -263 -23 -262 l -23 -69 l -44 -47 b -250 86 -117 23 -183 66 b -295 94 -270 93 -284 94 b -315 91 -302 94 -308 94 b -381 5 -356 81 -381 43 b -355 -56 -381 -16 -372 -40 b -299 -81 -338 -73 -319 -81 b -246 -68 -283 -81 -265 -77 b -212 -58 -234 -61 -223 -58 b -168 -77 -196 -58 -179 -65 b -151 -122 -156 -90 -151 -105 b -179 -174 -151 -141 -160 -162 b -239 -195 -194 -184 -217 -192 b -257 -197 -245 -195 -250 -197 b -423 -5 -349 -197 -423 -113 b -423 0 -423 -4 -423 -1 b -277 194 -420 97 -362 173 b -247 197 -268 197 -258 197 b -24 104 -185 197 -100 162 l -23 102 l -23 181 b -21 265 -23 260 -23 260 b -10 276 -20 269 -14 274 "},"v34":{"x_min":0,"x_max":622.03125,"ha":635,"o":"m 398 417 b 406 419 401 419 404 419 b 427 398 417 419 427 409 b 427 391 427 395 427 392 b 34 -274 424 385 38 -272 b 20 -280 29 -278 25 -280 b 0 -259 9 -280 0 -270 b 0 -252 0 -256 0 -254 b 393 413 2 -247 389 410 b 398 417 394 415 397 416 m 592 417 b 600 419 594 419 597 419 b 622 398 611 419 622 409 b 620 391 622 395 620 392 b 227 -274 617 385 231 -272 b 213 -280 223 -278 219 -280 b 193 -259 202 -280 193 -270 b 194 -252 193 -256 193 -254 b 586 413 196 -247 582 410 b 592 417 588 415 590 416 "},"v36":{"x_min":-1.359375,"x_max":1064.390625,"ha":1086,"o":"m 296 692 b 314 694 302 694 307 694 b 386 685 337 694 366 689 b 548 498 480 660 548 580 b 548 481 548 492 548 487 b 455 395 541 426 499 395 b 370 462 420 395 383 417 b 362 496 364 477 362 488 b 377 514 362 509 367 514 b 393 501 386 514 390 510 b 432 474 397 484 413 474 b 470 487 445 474 458 478 b 491 530 484 496 491 510 b 490 544 491 534 491 539 b 333 660 479 606 411 657 l 323 662 l 315 646 b 269 524 285 591 269 556 b 321 431 269 492 287 466 b 349 395 338 413 343 408 b 363 342 359 378 363 362 b 359 312 363 333 362 322 b 285 158 348 266 318 206 b 281 152 283 155 281 152 b 281 152 281 152 281 152 b 287 154 283 152 284 152 b 318 155 298 154 308 155 b 461 98 371 155 419 136 l 464 97 l 483 112 b 503 129 494 120 503 127 b 504 130 503 129 504 129 b 503 138 504 131 503 134 b 500 180 500 152 500 166 b 553 326 500 238 518 288 b 604 366 560 331 592 358 b 649 381 617 376 632 381 b 696 362 665 381 681 374 b 724 302 714 347 724 324 b 695 238 724 278 714 255 b 660 210 691 234 662 212 b 579 148 658 209 582 151 b 579 148 579 148 579 148 b 596 106 579 144 589 119 b 622 77 604 88 609 83 b 657 69 632 72 645 69 b 748 112 688 69 721 84 b 755 123 754 117 755 120 b 755 127 755 124 755 126 b 751 165 752 137 751 151 b 758 219 751 183 754 202 b 894 387 774 290 820 347 b 896 390 896 388 896 388 b 891 398 896 391 895 392 b 622 560 827 477 730 535 b 600 580 605 564 600 569 b 617 596 600 591 607 596 b 628 595 622 596 624 596 b 1057 248 846 552 1020 412 b 1064 191 1061 229 1064 209 b 922 0 1064 94 1005 9 b 902 -1 916 -1 909 -1 b 774 76 847 -1 800 26 b 769 83 770 81 770 83 b 769 81 769 83 769 83 b 627 -1 733 29 677 -1 b 548 27 597 -1 570 8 b 515 88 537 37 525 61 l 513 95 l 510 93 l 453 45 b 390 0 396 0 396 0 b 390 0 390 0 390 0 b 374 15 381 0 377 4 b 268 105 359 69 314 105 b 250 104 262 105 257 105 l 243 102 l 234 90 b 155 1 201 49 159 2 b 147 -1 152 0 149 -1 b 130 15 138 -1 130 6 b 132 20 130 18 132 19 b 136 31 133 22 134 27 b 220 131 149 74 178 109 b 231 137 225 134 230 136 b 302 278 280 202 302 244 b 265 335 302 299 295 309 b 209 442 234 363 213 402 b 209 455 209 446 209 451 b 279 648 209 502 232 564 l 285 659 l 283 659 b 176 627 238 653 210 645 b 57 477 111 594 66 538 b 55 459 55 471 55 464 b 72 409 55 437 61 415 b 93 403 78 405 87 403 b 152 467 123 403 151 431 b 168 488 153 483 157 488 b 185 462 181 488 185 483 l 185 460 b 137 344 183 409 168 369 b 78 322 119 328 98 322 b 13 360 50 322 25 335 b -1 426 4 380 -1 402 b 89 610 -1 488 32 559 b 296 692 147 659 210 685 m 926 348 b 921 353 924 351 922 353 b 914 348 920 353 918 351 b 823 167 857 306 823 237 b 828 124 823 154 826 138 b 890 31 837 79 862 40 b 896 31 892 31 894 31 b 956 104 916 31 940 59 b 970 191 965 129 970 159 b 966 241 970 208 969 224 b 926 348 959 277 945 313 m 627 326 b 619 326 624 326 622 326 b 598 316 611 326 604 323 b 568 215 579 288 568 255 b 568 208 568 213 568 210 b 571 183 570 195 570 184 l 571 183 b 594 201 571 183 582 191 l 634 231 b 660 259 653 247 656 248 b 664 278 662 266 664 272 b 627 326 664 299 649 320 "},"v38":{"x_min":-1.359375,"x_max":651.96875,"ha":665,"o":"m 389 644 b 405 645 394 645 400 645 b 504 566 450 645 492 613 b 507 541 506 557 507 549 b 480 471 507 514 498 489 l 477 467 l 483 470 b 609 591 539 485 586 531 b 613 601 611 595 613 599 b 631 609 619 607 624 609 b 651 588 641 609 651 602 b 200 -946 651 584 204 -941 b 182 -957 197 -953 190 -957 b 163 -945 174 -957 166 -953 b 161 -939 161 -942 161 -942 b 217 -743 161 -931 170 -904 b 272 -555 247 -639 272 -555 b 272 -555 272 -555 272 -555 b 264 -560 272 -555 268 -557 b 140 -603 227 -589 182 -603 b 36 -567 102 -603 65 -592 b -1 -487 12 -548 -1 -517 b 17 -427 -1 -466 5 -445 b 103 -380 38 -395 70 -380 b 191 -433 137 -380 172 -398 b 205 -484 201 -448 205 -466 b 178 -553 205 -509 196 -535 l 175 -557 l 182 -555 b 307 -435 236 -539 284 -494 b 372 -213 308 -430 372 -215 b 372 -213 372 -213 372 -213 b 364 -219 372 -213 368 -216 b 240 -262 328 -247 283 -262 b 137 -226 202 -262 166 -249 b 99 -145 112 -206 99 -176 b 118 -84 99 -124 106 -104 b 204 -38 138 -54 171 -38 b 292 -91 238 -38 273 -56 b 306 -141 302 -106 306 -124 b 279 -212 306 -167 296 -194 l 276 -215 l 281 -213 b 408 -93 336 -198 385 -151 b 473 129 409 -88 473 127 b 473 129 473 129 473 129 b 465 122 473 129 469 126 b 341 80 428 94 383 80 b 236 115 303 80 266 91 b 200 195 213 136 200 165 b 217 256 200 217 206 238 b 304 303 239 287 272 303 b 393 249 338 303 374 285 b 406 199 402 234 406 217 b 379 129 406 173 397 148 l 377 126 l 382 127 b 509 248 436 142 485 190 b 574 470 510 254 574 469 b 574 470 574 470 574 470 b 566 464 574 470 570 467 b 442 421 529 435 484 421 b 337 458 404 421 367 433 b 300 537 313 478 300 508 b 389 644 300 585 334 635 "},"v3b":{"x_min":0,"x_max":484.5625,"ha":494,"o":"m 228 245 b 239 247 234 247 239 247 b 243 247 240 247 242 247 b 303 238 257 247 287 242 b 484 -2 417 208 484 104 b 412 -177 484 -65 461 -127 b 243 -248 363 -226 303 -248 b 6 -63 138 -248 36 -180 b 0 -1 1 -41 0 -20 b 228 245 0 127 98 240 m 255 181 b 240 183 247 183 245 183 b 232 181 238 183 235 183 b 142 152 200 180 168 170 l 138 149 l 190 97 l 242 44 l 294 97 l 345 149 l 340 152 b 255 181 315 169 284 180 m 147 -54 l 197 -1 l 147 51 l 95 104 l 91 99 b 62 -1 72 70 62 34 b 66 -43 62 -15 63 -29 b 91 -101 72 -63 80 -84 l 95 -106 l 147 -54 m 393 99 b 389 104 390 102 389 104 b 337 51 389 104 366 80 l 285 -1 l 337 -54 l 389 -106 l 393 -101 b 421 -1 412 -72 421 -36 b 393 99 421 34 412 69 m 294 -98 b 242 -45 265 -69 242 -45 b 190 -98 242 -45 219 -69 l 138 -151 l 142 -154 b 242 -184 172 -174 206 -184 b 340 -154 276 -184 311 -174 l 345 -151 l 294 -98 "},"v3c":{"x_min":0,"x_max":450.53125,"ha":460,"o":"m 189 302 b 204 303 193 302 198 303 b 303 224 250 303 292 270 b 306 199 304 216 306 208 b 279 129 306 173 296 147 l 276 126 l 281 127 b 408 249 337 142 385 190 b 412 259 409 254 412 258 b 430 267 417 265 423 267 b 450 247 441 267 450 259 b 200 -605 450 242 204 -599 b 182 -616 197 -612 190 -616 b 163 -602 174 -616 166 -610 b 161 -598 161 -601 161 -601 b 217 -402 161 -589 170 -562 b 272 -213 247 -298 272 -213 b 272 -213 272 -213 272 -213 b 264 -219 272 -213 268 -216 b 140 -262 227 -247 182 -262 b 36 -226 102 -262 65 -249 b 0 -145 12 -206 0 -176 b 17 -84 0 -124 5 -104 b 103 -38 38 -54 70 -38 b 191 -91 137 -38 172 -56 b 205 -141 201 -106 205 -124 b 178 -212 205 -167 196 -194 l 175 -215 l 182 -213 b 307 -93 236 -198 284 -151 b 372 129 308 -88 372 127 b 372 129 372 129 372 129 b 364 122 372 129 368 126 b 240 80 328 94 283 80 b 137 115 202 80 166 91 b 99 194 111 136 99 165 b 189 302 99 244 133 292 "},"v3e":{"x_min":0,"x_max":406.96875,"ha":415,"o":"m 21 183 b 28 183 24 183 25 183 b 42 181 34 183 39 183 b 127 108 47 179 47 179 b 202 41 168 72 202 41 b 279 108 204 41 238 72 b 357 177 321 145 356 176 b 375 183 363 181 370 183 b 406 151 392 183 406 169 b 404 137 406 147 405 141 b 322 62 401 131 398 129 b 251 0 284 27 251 0 b 322 -63 251 -1 284 -29 b 404 -138 398 -130 401 -133 b 406 -152 405 -142 406 -148 b 375 -184 406 -170 392 -184 b 357 -179 370 -184 363 -183 b 279 -109 356 -177 321 -147 b 202 -43 238 -73 204 -43 b 127 -109 202 -43 168 -73 b 49 -179 85 -147 50 -177 b 31 -184 43 -183 36 -184 b 0 -152 13 -184 0 -170 b 2 -138 0 -148 0 -142 b 83 -63 5 -133 8 -130 b 155 0 122 -29 155 -1 b 83 62 155 0 122 27 b 8 129 43 97 10 127 b 0 151 2 136 0 144 b 21 183 0 165 8 177 "},"v3f":{"x_min":-24.5,"x_max":317.140625,"ha":324,"o":"m -24 -147 l -24 -5 l -20 -5 b -1 -19 -12 -5 -4 -11 b 58 -123 6 -43 31 -86 b 196 -278 93 -173 134 -219 b 317 -570 274 -356 317 -460 b 294 -713 317 -617 308 -666 l 289 -724 l 294 -735 b 317 -873 308 -780 317 -827 b 235 -1132 317 -963 288 -1054 b 209 -1165 228 -1140 224 -1146 b 189 -1177 204 -1172 196 -1177 b 171 -1164 182 -1177 175 -1172 b 168 -1154 170 -1161 168 -1159 b 181 -1132 168 -1149 172 -1142 b 269 -891 238 -1064 269 -975 b 269 -881 269 -886 269 -884 b 262 -814 269 -857 265 -827 b 258 -800 261 -811 259 -806 b 142 -628 240 -731 198 -667 b -8 -589 112 -606 47 -589 b -20 -589 -13 -589 -19 -589 l -24 -589 l -24 -449 l -24 -308 l -20 -308 b -1 -322 -12 -308 -4 -313 b 58 -424 6 -345 31 -388 b 194 -580 93 -476 136 -523 b 259 -660 221 -606 245 -635 b 261 -663 259 -662 261 -663 b 264 -656 262 -663 262 -660 b 269 -587 268 -632 269 -610 b 264 -521 269 -566 268 -544 b 262 -512 264 -517 262 -513 b 258 -498 261 -509 259 -503 b 142 -326 240 -428 198 -365 b -8 -287 112 -303 47 -288 b -20 -287 -13 -287 -19 -287 l -24 -287 l -24 -147 "},"v40":{"x_min":-1.359375,"x_max":436.921875,"ha":446,"o":"m 213 205 b 217 205 215 205 216 205 b 234 194 224 205 234 199 b 236 187 234 194 235 190 l 245 167 l 261 129 l 270 106 b 355 -61 294 54 329 -13 b 420 -163 381 -105 402 -138 b 436 -188 435 -184 436 -184 b 436 -191 436 -190 436 -190 b 421 -206 436 -201 431 -206 l 421 -206 l 416 -206 l 405 -201 b 217 -158 347 -172 283 -158 b 31 -201 153 -158 88 -172 l 20 -206 l 14 -206 l 14 -206 b 0 -191 5 -206 0 -201 b -1 -188 0 -190 -1 -190 b 14 -163 -1 -186 0 -184 b 95 -34 36 -136 72 -77 b 166 106 119 8 148 68 l 175 129 l 183 148 l 200 188 b 213 205 205 199 208 202 "},"v41":{"x_min":-1.359375,"x_max":556.6875,"ha":568,"o":"m 294 322 b 318 323 299 322 308 323 b 360 320 334 323 352 322 b 526 217 430 310 490 273 b 543 166 537 202 543 184 b 447 70 543 117 503 70 b 445 70 447 70 446 70 b 359 159 394 72 359 113 b 368 201 359 173 362 187 b 442 245 382 229 412 245 b 455 244 446 245 451 245 b 460 244 458 244 460 244 b 460 244 460 244 460 244 b 454 248 460 244 458 245 b 325 291 417 276 372 291 b 285 287 313 291 299 290 b 144 -2 183 269 144 190 b 281 -290 144 -208 179 -280 b 304 -291 289 -291 298 -291 b 524 -105 412 -291 506 -212 b 541 -84 526 -88 530 -84 b 556 -101 551 -84 556 -90 b 549 -138 556 -111 553 -122 b 334 -322 521 -237 435 -310 b 302 -324 323 -323 313 -324 b 13 -101 172 -324 54 -234 b -1 -1 4 -68 -1 -34 b 294 322 -1 161 121 303 "},"v42":{"x_min":-348.4375,"x_max":24.5,"ha":25,"o":"m -330 155 b -322 156 -329 156 -326 156 b -315 156 -319 156 -317 156 b -298 147 -311 155 -308 154 b -19 30 -224 98 -122 55 l 2 26 b 24 -1 17 22 24 13 b 2 -27 24 -15 17 -23 l -19 -31 b -298 -148 -122 -56 -224 -99 b -322 -158 -313 -158 -315 -158 b -348 -131 -338 -158 -348 -145 b -344 -117 -348 -127 -347 -122 b -328 -104 -341 -112 -338 -111 b -127 -8 -269 -65 -202 -33 b -106 0 -115 -4 -106 -1 b -127 6 -106 0 -115 2 b -328 102 -202 31 -269 63 b -344 116 -338 109 -341 111 b -348 130 -347 120 -348 124 b -330 155 -348 141 -341 152 "},"v43":{"x_min":-442.359375,"x_max":441,"ha":450,"o":"m -31 487 b -1 488 -21 488 -10 488 b 434 104 216 488 397 330 b 441 27 438 79 441 47 b 439 12 441 20 439 15 b 419 0 435 4 427 0 b 404 5 413 0 408 1 b 398 30 400 11 398 13 b 0 351 390 213 213 351 b -59 348 -20 351 -39 349 b -400 30 -251 324 -393 191 b -405 5 -400 13 -401 11 b -420 0 -409 1 -415 0 b -441 12 -428 0 -436 4 b -442 27 -441 15 -442 20 b -435 104 -442 47 -439 79 b -31 487 -401 316 -235 474 m -13 131 b -1 133 -9 133 -5 133 b 51 105 19 133 39 123 b 61 70 58 95 61 83 b 51 34 61 58 58 45 b -1 6 39 16 19 6 b -46 27 -17 6 -34 13 b -62 69 -57 38 -62 54 b -13 131 -62 98 -44 124 "},"v44":{"x_min":-21.78125,"x_max":251.8125,"ha":257,"o":"m -8 631 b -1 632 -6 632 -4 632 b 19 620 8 632 16 628 b 20 383 20 616 20 616 l 20 148 l 21 151 b 137 199 59 183 99 199 b 182 191 152 199 167 197 b 251 84 227 176 251 134 b 228 0 251 58 243 29 b 100 -142 206 -40 178 -72 l 23 -215 b 0 -229 9 -229 6 -229 b -20 -216 -9 -229 -17 -224 l -21 -212 l -21 201 l -21 616 l -20 620 b -8 631 -17 624 -13 630 m 110 131 b 96 133 106 133 100 133 b 89 133 93 133 91 133 b 24 87 63 129 40 113 l 20 80 l 20 -37 l 20 -156 l 23 -152 b 144 81 96 -72 144 20 l 144 83 b 110 131 144 113 134 126 "},"v45":{"x_min":-402.890625,"x_max":401.53125,"ha":410,"o":"m -10 273 b -4 274 -9 273 -6 274 b 16 262 4 274 12 269 b 17 158 17 259 17 259 l 17 56 l 62 112 b 117 174 110 172 110 172 b 122 174 118 174 119 174 b 132 173 125 174 129 173 b 295 11 134 172 171 134 l 307 -1 l 336 34 b 374 76 366 72 368 74 b 381 77 375 77 378 77 b 401 56 392 77 401 68 b 400 48 401 54 401 51 b 223 -172 397 41 230 -166 b 210 -176 220 -174 215 -176 b 201 -174 206 -176 204 -176 b 112 -87 198 -173 178 -152 b 27 0 65 -38 27 0 b 21 -6 27 0 24 -2 l 17 -12 l 17 -147 b 17 -210 17 -173 17 -194 b 10 -292 17 -297 16 -287 b -2 -299 6 -297 2 -299 b -21 -287 -10 -299 -19 -295 b -24 -174 -23 -284 -23 -284 l -24 -63 l -66 -117 b -121 -176 -110 -170 -114 -176 b -125 -176 -122 -176 -123 -176 b -296 -12 -134 -174 -125 -184 l -308 0 l -337 -34 b -375 -77 -367 -73 -370 -76 b -382 -79 -377 -79 -379 -79 b -402 -58 -393 -79 -402 -69 b -401 -49 -402 -55 -402 -52 b -224 170 -398 -43 -231 165 b -212 174 -221 173 -216 174 b -202 173 -208 174 -205 174 b -39 11 -200 172 -151 122 l -28 -1 l -25 1 l -24 4 l -24 130 b -23 260 -24 256 -24 258 b -10 273 -20 266 -16 270 "},"v46":{"x_min":0,"x_max":627.46875,"ha":640,"o":"m 306 190 b 314 191 308 191 311 191 b 326 184 318 191 322 190 l 336 173 b 510 52 377 127 442 80 b 515 49 513 51 515 49 b 611 16 537 40 579 24 b 627 0 624 13 627 9 b 607 -18 627 -11 624 -13 b 330 -181 490 -49 389 -109 b 314 -192 323 -190 319 -192 b 306 -191 311 -192 308 -192 b 294 -177 302 -188 302 -188 b 257 -140 287 -170 265 -148 b 19 -18 193 -84 114 -44 b 0 0 2 -13 0 -11 b 16 16 0 9 2 13 b 110 49 47 24 89 40 b 117 52 111 49 114 51 b 145 65 126 56 130 58 b 281 163 200 93 245 124 b 300 186 288 170 291 174 b 306 190 300 187 303 188 m 317 137 b 313 142 315 141 314 142 b 308 137 313 142 311 141 b 161 4 276 84 220 33 b 155 0 159 1 155 0 b 163 -4 155 0 159 -2 b 308 -138 220 -34 276 -84 b 313 -142 311 -141 313 -142 b 317 -138 314 -142 315 -141 b 464 -4 351 -84 406 -34 b 470 0 468 -2 470 0 b 464 4 470 0 468 1 b 317 137 406 33 351 84 "},"v47":{"x_min":-24.5,"x_max":315.78125,"ha":322,"o":"m -24 -145 l -24 -5 l -20 -5 b 1 -26 -10 -5 -6 -9 b 175 -241 31 -86 96 -166 b 314 -548 259 -323 304 -420 b 315 -589 315 -555 315 -571 b 314 -630 315 -606 315 -623 b 298 -730 311 -664 306 -699 l 295 -742 l 296 -748 b 314 -850 304 -778 311 -813 b 315 -892 315 -857 315 -874 b 314 -932 315 -909 315 -925 b 298 -1032 311 -967 306 -1002 l 295 -1045 l 296 -1050 b 314 -1153 304 -1081 311 -1115 b 315 -1193 315 -1160 315 -1177 b 314 -1235 315 -1211 315 -1228 b 217 -1526 306 -1338 270 -1444 b 201 -1533 213 -1532 208 -1533 b 182 -1522 193 -1533 185 -1529 b 179 -1514 181 -1518 179 -1517 b 189 -1489 179 -1508 182 -1501 b 266 -1217 240 -1403 266 -1308 b 262 -1156 266 -1196 265 -1177 b 110 -907 247 -1043 190 -950 b 0 -889 87 -895 50 -889 l -1 -889 l -24 -889 l -24 -749 l -24 -610 l -20 -610 b 1 -631 -10 -610 -6 -614 b 175 -846 31 -691 96 -771 b 259 -956 213 -884 236 -914 b 265 -966 262 -961 264 -966 b 265 -966 265 -966 265 -966 b 265 -953 265 -964 265 -959 b 266 -920 266 -943 266 -932 b 262 -853 266 -898 265 -873 b 110 -605 247 -741 190 -648 b 0 -587 87 -592 50 -587 l -1 -587 l -24 -587 l -24 -448 l -24 -308 l -20 -308 b 1 -328 -10 -308 -6 -312 b 175 -544 31 -388 96 -469 b 259 -655 213 -581 236 -612 b 265 -663 262 -659 264 -663 b 265 -663 265 -663 265 -663 b 265 -650 265 -663 265 -657 b 266 -617 266 -641 266 -630 b 262 -551 266 -595 265 -570 b 110 -303 247 -438 190 -345 b 0 -284 87 -290 50 -284 l -1 -284 l -24 -284 l -24 -145 "},"v49":{"x_min":0,"x_max":630.203125,"ha":643,"o":"m 308 204 b 314 205 310 205 313 205 b 326 201 319 205 323 204 b 355 154 328 199 338 180 b 401 83 362 142 392 95 l 409 72 b 431 41 412 66 424 49 b 619 -174 498 -51 570 -134 b 630 -192 626 -180 630 -186 b 626 -202 630 -195 628 -199 b 616 -206 623 -205 620 -206 b 552 -188 608 -206 592 -202 b 310 -155 488 -169 392 -155 b 268 -156 295 -155 281 -155 b 77 -188 197 -161 126 -173 b 13 -206 35 -202 20 -206 b 9 -206 12 -206 10 -206 b 0 -191 2 -202 0 -197 b 8 -176 0 -186 2 -180 b 204 49 58 -136 138 -43 l 220 72 l 227 83 b 295 188 245 108 281 166 b 308 204 299 197 304 202 m 315 147 b 314 147 315 147 314 147 b 314 147 314 147 314 147 b 306 129 314 145 310 138 l 296 105 b 281 72 292 97 284 77 l 274 56 b 181 -123 247 -4 212 -72 l 174 -134 l 176 -133 b 314 -123 215 -127 272 -123 b 451 -133 356 -123 413 -127 l 454 -134 l 449 -123 b 353 56 417 -72 381 -4 l 347 72 b 332 105 344 77 336 97 l 322 129 b 315 147 318 138 315 145 "},"v4a":{"x_min":70.78125,"x_max":378.390625,"ha":315,"o":"m 246 373 b 254 373 249 373 251 373 b 372 324 303 373 360 351 b 378 302 377 317 378 309 b 338 251 378 278 362 255 b 328 249 334 249 332 249 b 283 294 303 249 283 270 b 288 315 283 301 284 308 b 289 319 289 317 289 319 b 289 319 289 319 289 319 b 283 320 289 320 287 320 b 270 322 279 322 274 322 b 206 288 242 322 215 308 b 206 283 206 287 206 285 b 257 223 206 267 230 238 b 284 206 272 213 277 210 b 351 90 328 173 351 130 b 340 47 351 74 348 59 b 205 -30 314 -2 264 -30 b 182 -29 198 -30 190 -30 b 84 15 147 -24 103 -5 b 70 48 74 24 70 36 b 108 99 70 70 85 94 b 121 102 112 101 117 102 b 167 56 147 102 167 80 b 159 31 167 48 164 40 l 156 26 l 157 26 b 190 20 167 22 178 20 b 220 26 201 20 212 22 b 258 65 243 34 258 51 b 257 70 258 66 258 69 b 204 126 249 94 234 109 b 114 258 148 158 114 209 b 125 302 114 273 118 288 b 246 373 147 342 193 370 "},"v4b":{"x_min":0,"x_max":503.609375,"ha":514,"o":"m 274 430 b 277 430 276 430 277 430 b 310 394 296 430 310 415 b 308 383 310 391 308 387 b 306 367 307 381 307 374 b 236 120 298 305 272 210 b 40 -273 189 -5 125 -134 b 20 -287 35 -283 27 -287 b 5 -281 14 -287 9 -285 b 0 -267 1 -277 0 -273 b 9 -242 0 -262 2 -255 b 246 395 137 -12 232 242 b 274 430 249 416 257 427 m 468 430 b 472 430 469 430 470 430 b 503 394 490 430 503 415 b 502 383 503 391 503 387 b 499 367 502 381 500 374 b 431 120 491 305 465 210 b 234 -273 382 -5 318 -134 b 213 -287 228 -283 220 -287 b 198 -281 208 -287 202 -285 b 193 -267 194 -277 193 -273 b 202 -242 193 -262 196 -255 b 439 395 330 -12 426 242 b 468 430 442 416 451 427 "},"v4d":{"x_min":-311.6875,"x_max":310.328125,"ha":317,"o":"m -9 388 b -2 390 -8 390 -5 390 b 5 388 1 390 4 390 b 19 378 10 387 16 383 b 23 333 23 371 23 371 b 24 298 23 299 24 298 b 81 276 34 298 65 285 b 213 91 145 240 190 177 b 224 24 217 76 224 36 b 257 24 224 24 235 24 b 299 19 292 24 292 24 b 310 -1 306 15 310 6 b 299 -23 310 -11 306 -19 b 257 -27 292 -27 292 -27 b 224 -29 235 -27 224 -29 b 213 -95 224 -40 217 -80 b 81 -280 190 -181 145 -244 b 24 -301 65 -290 34 -301 b 23 -335 24 -301 23 -303 l 23 -340 b 17 -381 23 -374 23 -374 b -1 -391 13 -388 5 -391 b -21 -381 -9 -391 -17 -388 b -27 -340 -27 -374 -27 -374 l -27 -335 b -28 -301 -27 -303 -27 -301 b -85 -280 -38 -301 -69 -290 b -217 -95 -149 -244 -194 -181 b -228 -29 -221 -80 -228 -40 b -259 -27 -228 -29 -238 -27 b -300 -23 -294 -27 -294 -27 b -311 -2 -307 -19 -311 -11 b -294 23 -311 8 -304 19 b -259 24 -291 23 -284 24 b -228 24 -239 24 -228 24 b -217 91 -228 36 -221 76 b -85 276 -194 177 -149 240 b -28 298 -69 285 -38 298 b -27 333 -27 298 -27 299 b -27 371 -27 362 -27 369 b -9 388 -24 378 -17 385 m -27 136 b -28 247 -27 197 -28 247 b -61 216 -31 247 -53 226 b -123 33 -95 172 -121 98 l -125 24 l -76 24 l -27 24 l -27 136 m 29 242 b 24 247 27 245 24 247 b 23 136 24 247 23 197 l 23 24 l 72 24 l 121 24 l 119 33 b 29 242 115 116 77 206 m -27 -140 l -27 -27 l -76 -27 l -125 -27 l -123 -36 b -61 -220 -121 -102 -95 -176 b -28 -251 -53 -230 -31 -251 b -27 -140 -28 -251 -27 -201 m 119 -36 l 121 -27 l 72 -27 l 23 -27 l 23 -140 b 24 -251 23 -201 24 -251 b 57 -220 27 -251 49 -230 b 119 -36 91 -176 117 -102 "},"v4e":{"x_min":0,"x_max":239.5625,"ha":244,"o":"m 10 460 b 20 462 13 462 14 462 b 39 449 28 462 35 458 l 40 446 l 40 326 b 40 205 40 259 40 205 b 127 227 40 205 80 215 b 220 249 196 244 213 249 b 227 247 224 249 225 248 b 238 237 231 245 235 241 l 239 233 l 239 -106 l 239 -448 l 238 -451 b 219 -463 234 -459 225 -463 b 198 -451 210 -463 202 -459 l 197 -448 l 197 -324 b 197 -201 197 -248 197 -201 b 110 -223 196 -201 157 -210 b 17 -245 42 -240 24 -245 b 10 -242 13 -245 13 -244 b 0 -233 6 -241 2 -237 l 0 -230 l 0 108 l 0 446 l 0 449 b 10 460 2 453 6 458 m 197 22 b 197 70 197 41 197 58 b 196 116 197 113 197 116 l 196 116 b 118 97 196 116 160 106 l 40 77 l 40 -18 b 40 -112 40 -69 40 -112 l 119 -93 l 197 -73 l 197 22 "},"v51":{"x_min":-1.359375,"x_max":455.96875,"ha":465,"o":"m 352 541 b 357 542 353 542 355 542 b 377 530 364 542 372 537 l 378 526 l 378 394 l 379 262 l 404 266 b 436 270 420 269 430 270 b 450 265 443 270 446 269 b 455 220 455 259 455 260 l 455 208 l 455 161 l 454 156 b 411 140 449 147 447 147 b 378 133 393 137 379 134 b 378 68 378 133 378 106 b 378 22 378 54 378 38 l 379 -87 l 404 -83 b 436 -79 420 -80 430 -79 b 450 -84 443 -79 446 -80 b 455 -129 455 -90 455 -88 l 455 -141 l 455 -188 l 454 -192 b 413 -209 449 -202 447 -202 b 382 -215 398 -212 383 -215 l 378 -215 l 378 -345 l 378 -380 b 375 -485 378 -484 378 -480 b 357 -494 371 -491 364 -494 b 340 -485 351 -494 344 -491 b 336 -383 337 -480 336 -484 l 336 -349 l 336 -223 l 334 -223 b 291 -231 334 -223 314 -227 l 247 -240 l 247 -371 l 246 -503 l 245 -506 b 225 -519 242 -514 234 -519 b 206 -506 219 -519 210 -514 l 205 -503 l 205 -376 l 205 -248 l 160 -256 l 115 -265 l 115 -396 l 115 -527 l 114 -531 b 95 -544 110 -539 102 -544 b 76 -531 87 -544 78 -539 l 73 -527 l 73 -399 b 73 -273 73 -330 73 -273 b 49 -277 73 -273 61 -274 b 17 -281 32 -280 24 -281 b 4 -276 10 -281 8 -280 b -1 -234 0 -269 -1 -272 b 0 -219 -1 -229 0 -224 l 0 -170 l 1 -167 b 10 -158 2 -163 6 -159 b 49 -149 13 -156 16 -155 l 73 -145 l 73 -34 b 73 76 73 26 73 76 b 49 72 73 76 61 74 b 17 68 32 69 24 68 b 4 73 10 68 8 69 b -1 115 0 80 -1 77 b 0 130 -1 120 0 124 l 0 179 l 1 181 b 10 191 2 186 6 190 b 49 199 13 192 16 194 l 73 204 l 73 338 b 73 374 73 352 73 365 b 77 483 73 484 73 477 b 95 492 81 489 88 492 b 111 483 100 492 107 489 b 115 378 115 477 115 483 l 115 342 b 117 212 115 223 115 212 b 204 229 117 212 200 227 l 205 229 l 205 365 l 205 502 l 206 505 b 225 517 210 513 219 517 b 245 505 234 517 242 513 l 246 502 l 247 369 l 247 237 l 249 237 b 336 254 253 238 336 254 b 337 390 336 254 337 302 l 337 526 l 338 530 b 352 541 341 535 347 539 m 336 15 b 336 126 336 102 336 126 l 336 126 b 291 117 336 126 315 122 l 247 109 l 247 -1 l 247 -112 l 249 -112 b 336 -95 253 -111 336 -95 b 336 15 336 -95 336 -56 m 205 -120 b 205 -55 205 -120 205 -93 b 205 -9 205 -41 205 -24 l 205 101 l 160 93 l 115 84 l 115 -26 b 115 -83 115 -49 115 -69 b 117 -137 115 -133 115 -137 b 205 -120 118 -137 204 -120 "},"v52":{"x_min":-10.890625,"x_max":298.078125,"ha":294,"o":"m 138 473 b 142 474 140 473 141 474 b 164 459 148 474 153 470 b 191 402 183 442 191 423 b 181 353 191 388 187 371 b 178 349 179 352 178 349 b 179 348 178 348 179 348 b 185 349 181 348 182 348 b 255 376 210 355 234 363 b 272 381 264 381 266 381 b 298 355 287 381 298 370 b 288 330 298 348 298 345 b 171 34 238 254 194 141 b 166 13 168 16 168 16 b 144 1 161 5 152 1 b 121 15 134 1 125 5 b 115 33 119 18 117 24 b 0 330 91 145 49 252 b -10 355 -9 345 -10 348 b 13 381 -10 371 0 381 b 31 376 19 381 25 380 b 132 345 61 358 103 345 l 136 345 l 137 355 b 145 378 138 359 142 370 b 152 415 149 394 152 405 b 137 452 152 427 148 438 b 133 464 134 458 133 460 b 138 473 133 467 134 470 "},"v53":{"x_min":0,"x_max":902.421875,"ha":921,"o":"m 17 240 b 24 241 19 241 21 241 b 32 240 28 241 31 241 b 46 229 38 238 43 234 b 50 88 50 223 50 237 b 50 -1 50 63 50 34 b 50 -90 50 -36 50 -65 b 46 -231 50 -238 50 -224 b 25 -242 42 -238 34 -242 b 0 -224 14 -242 4 -235 b 0 2 0 -222 0 -108 b 0 223 0 112 0 220 b 17 240 2 230 9 237 m 110 240 b 118 241 111 241 114 241 b 126 240 121 241 123 241 b 142 223 133 237 140 230 b 144 123 144 220 144 205 b 144 29 144 45 144 29 b 144 29 144 29 144 29 b 393 183 166 106 264 167 b 450 186 412 184 431 186 b 756 29 600 186 732 120 b 756 29 756 29 756 29 b 758 123 758 29 758 45 b 760 227 758 226 758 223 b 784 241 766 237 774 241 b 804 229 792 241 800 237 b 809 88 808 223 809 237 l 809 -1 l 809 -90 b 804 -231 809 -238 808 -224 b 784 -242 800 -238 792 -242 b 762 -231 775 -242 766 -238 b 758 -124 756 -224 758 -231 b 756 -30 758 -47 758 -30 b 756 -30 756 -30 756 -30 b 509 -184 736 -108 637 -169 b 450 -187 488 -187 469 -187 b 144 -30 300 -187 168 -122 b 144 -30 144 -30 144 -30 b 144 -124 144 -30 144 -47 b 140 -231 144 -231 144 -224 b 118 -242 134 -238 126 -242 b 92 -224 107 -242 96 -235 b 92 2 92 -222 92 -108 b 92 223 92 112 92 220 b 110 240 95 230 102 237 m 432 161 b 413 162 426 162 420 162 b 313 41 351 162 313 109 b 347 -73 313 5 323 -34 b 487 -163 385 -133 439 -163 b 578 -97 526 -163 562 -142 b 588 -43 585 -80 588 -62 b 432 161 588 47 518 147 m 868 240 b 876 241 869 241 872 241 b 884 240 879 241 882 241 b 898 229 890 238 894 234 b 902 88 902 223 902 237 l 902 -1 l 902 -90 b 898 -231 902 -238 902 -224 b 876 -242 892 -238 884 -242 b 852 -224 865 -242 854 -235 b 850 2 850 -222 850 -108 b 852 223 850 112 850 220 b 868 240 853 230 860 237 "},"v54":{"x_min":-24.5,"x_max":317.140625,"ha":324,"o":"m -24 -161 l -24 -5 l -20 -5 b 0 -24 -9 -5 -2 -12 b 171 -315 21 -124 84 -233 b 317 -660 268 -406 317 -531 b 187 -1014 317 -782 274 -909 b 161 -1034 172 -1034 171 -1034 b 141 -1013 149 -1034 141 -1025 b 152 -991 141 -1004 142 -1002 b 266 -682 228 -899 266 -788 b 174 -430 266 -588 236 -498 b -23 -317 136 -388 66 -348 b -24 -161 -23 -316 -24 -285 "},"v55":{"x_min":0,"x_max":551.25,"ha":563,"o":"m 289 644 b 304 645 294 645 299 645 b 404 566 349 645 392 613 b 406 541 405 557 406 549 b 379 471 406 514 397 489 l 377 467 l 382 470 b 509 591 438 485 485 531 b 513 601 510 595 513 599 b 530 609 518 607 524 609 b 551 588 540 609 551 602 b 200 -605 551 584 204 -599 b 182 -616 197 -612 190 -616 b 163 -602 174 -616 166 -610 b 161 -598 161 -601 161 -601 b 217 -402 161 -589 170 -562 b 272 -213 247 -298 272 -213 b 272 -213 272 -213 272 -213 b 264 -219 272 -213 268 -216 b 140 -262 227 -247 182 -262 b 36 -226 102 -262 65 -249 b 0 -145 12 -206 0 -176 b 17 -84 0 -124 5 -104 b 103 -38 38 -54 70 -38 b 191 -91 137 -38 172 -56 b 205 -141 201 -106 205 -124 b 178 -212 205 -167 196 -194 l 175 -215 l 182 -213 b 307 -93 236 -198 284 -151 b 372 129 308 -88 372 127 b 372 129 372 129 372 129 b 364 122 372 129 368 126 b 240 80 328 94 283 80 b 137 115 202 80 166 91 b 99 195 112 136 99 165 b 118 256 99 217 106 238 b 204 303 138 287 171 303 b 292 249 238 303 273 285 b 306 199 302 234 306 217 b 279 129 306 173 296 148 l 276 126 l 281 127 b 408 248 336 142 385 190 b 473 470 409 254 473 469 b 473 470 473 470 473 470 b 465 464 473 470 469 467 b 341 421 428 435 383 421 b 236 458 303 421 266 433 b 200 537 212 478 200 508 b 289 644 200 585 234 635 "},"v58":{"x_min":-21.78125,"x_max":367.5,"ha":375,"o":"m 259 1553 b 265 1553 261 1553 264 1553 b 288 1540 272 1553 277 1550 b 367 1351 340 1493 367 1424 b 336 1221 367 1308 357 1263 l 332 1211 l 333 1208 b 367 1077 356 1170 367 1124 b 336 945 367 1032 357 986 l 332 935 l 333 932 b 367 800 356 893 367 848 b 336 669 367 756 357 710 l 332 659 l 333 656 b 367 523 356 617 367 571 b 345 412 367 485 360 446 b 231 273 322 356 284 310 b -1 19 121 195 27 93 b -17 4 -4 11 -10 5 l -21 4 l -21 134 l -21 265 l -17 265 b 133 291 20 265 96 278 b 318 537 245 328 318 433 b 307 603 318 559 315 582 b 303 614 304 612 304 614 b 298 609 302 614 300 613 b 231 549 281 589 258 567 b -1 295 121 471 27 369 b -17 280 -4 287 -10 281 l -21 280 l -21 410 l -21 541 l -17 541 b 133 567 20 541 96 555 b 318 813 245 605 318 709 b 307 880 318 835 315 859 b 303 891 304 888 304 891 b 298 885 302 891 300 888 b 231 825 281 866 258 843 b -1 571 121 748 27 645 b -17 556 -4 563 -10 557 l -21 556 l -21 687 l -21 817 l -17 817 b 133 843 20 817 96 830 b 318 1089 245 881 318 985 b 307 1156 318 1111 315 1134 b 303 1167 304 1164 304 1167 b 298 1161 302 1167 300 1164 b 231 1102 281 1140 258 1120 b -1 848 121 1024 27 921 b -17 832 -4 839 -10 834 l -21 832 l -21 963 l -21 1093 l -17 1093 b 114 1113 12 1093 78 1103 b 313 1314 215 1142 289 1218 b 318 1364 317 1331 318 1347 b 255 1511 318 1422 295 1478 b 243 1532 247 1519 243 1525 b 259 1553 243 1540 250 1550 "},"v59":{"x_min":0,"x_max":464.140625,"ha":474,"o":"m 0 0 l 0 347 l 76 347 l 153 347 l 153 0 l 153 -348 l 76 -348 l 0 -348 l 0 0 m 308 -1 l 308 347 l 386 347 l 464 347 l 464 -1 l 464 -348 l 386 -348 l 308 -348 l 308 -1 "},"v5a":{"x_min":-171.5,"x_max":170.140625,"ha":174,"o":"m -6 566 b 0 567 -5 567 -2 567 b 14 556 6 567 12 563 b 92 285 14 555 50 433 b 170 13 166 33 170 19 b 168 13 170 13 170 13 b 161 1 168 8 167 4 l 159 0 l 122 0 l 84 0 l 81 1 b 21 195 76 5 78 -5 b -32 381 -8 297 -32 381 b -87 197 -32 381 -57 298 b -141 8 -115 94 -140 9 b -155 0 -142 2 -149 0 b -171 15 -163 0 -171 5 b -14 556 -171 18 -24 528 b -6 566 -14 560 -10 564 "},"v5b":{"x_min":-441,"x_max":439.640625,"ha":449,"o":"m -428 -2 b -421 0 -427 -1 -424 0 b -406 -6 -416 0 -409 -2 b -400 -31 -401 -12 -400 -15 b -1 -352 -392 -215 -215 -352 b 58 -349 19 -352 38 -351 b 398 -31 250 -326 392 -192 b 404 -6 398 -15 400 -12 b 419 -1 408 -2 413 -1 b 439 -13 427 -1 435 -5 b 439 -29 439 -16 439 -22 b 434 -105 439 -48 438 -80 b 0 -489 397 -333 213 -489 b -68 -484 -23 -489 -44 -488 b -441 -36 -280 -452 -436 -263 b -441 -30 -441 -34 -441 -31 b -428 -2 -441 -11 -439 -5 m -13 -9 b -1 -8 -9 -8 -5 -8 b 50 -36 19 -8 39 -19 b 61 -72 57 -47 61 -59 b 50 -106 61 -84 57 -97 b -1 -134 39 -124 19 -134 b -46 -115 -17 -134 -34 -129 b -62 -72 -57 -102 -62 -87 b -13 -9 -62 -44 -44 -16 "},"v5c":{"x_min":0,"x_max":447.8125,"ha":457,"o":"m 0 -87 l 0 0 l 223 0 l 447 0 l 447 -87 l 447 -174 l 223 -174 l 0 -174 l 0 -87 "},"v5d":{"x_min":-1.359375,"x_max":592.078125,"ha":604,"o":"m 280 692 b 295 694 283 692 289 694 b 310 692 300 694 307 692 b 357 630 340 684 357 657 b 336 580 357 612 351 594 b 311 538 321 566 311 549 b 352 492 311 512 330 492 b 366 495 357 492 362 492 b 397 553 390 503 397 517 b 415 603 397 576 402 591 b 460 623 427 617 443 623 b 509 599 479 623 498 614 b 522 559 518 587 522 573 b 494 506 522 538 513 519 b 451 495 481 498 473 496 b 415 488 432 495 426 494 b 394 449 404 483 394 464 b 394 448 394 448 394 448 l 394 440 l 397 433 b 428 409 404 420 413 413 b 438 408 431 408 435 408 b 479 431 450 408 462 415 b 528 455 495 448 510 455 b 548 452 534 455 541 453 b 592 391 577 442 592 416 b 549 331 592 365 577 340 b 528 327 541 328 534 327 b 479 351 510 327 495 335 b 438 374 464 367 450 374 b 417 369 431 374 424 373 b 394 333 402 360 394 348 b 400 312 394 326 396 319 b 451 287 408 294 420 288 b 513 258 484 285 499 278 b 522 223 519 247 522 234 b 461 159 522 190 496 159 b 449 161 457 159 453 159 b 397 229 416 167 397 191 b 366 288 397 265 390 278 b 352 290 362 290 357 290 b 315 262 336 290 321 280 b 311 245 313 256 311 251 b 334 204 311 233 318 220 b 355 170 348 190 351 184 b 357 152 356 166 357 159 b 355 136 357 147 356 140 b 295 88 345 104 321 88 b 232 152 264 88 232 112 b 255 204 232 174 238 186 b 279 244 273 222 279 231 l 279 245 b 238 290 279 270 259 290 b 224 288 234 290 228 290 b 193 229 200 278 193 265 b 141 161 193 191 174 167 b 129 159 137 159 133 159 b 68 223 93 159 68 190 b 77 258 68 234 70 247 b 138 287 91 278 106 285 b 185 302 166 287 175 291 b 196 333 193 312 196 323 b 174 369 196 347 187 360 b 152 374 166 373 159 374 b 111 351 140 374 126 367 b 62 327 95 335 80 327 b 51 328 58 327 54 327 b -1 391 16 334 -1 363 b 53 455 -1 420 17 449 b 62 455 57 455 59 455 b 111 431 80 455 95 448 b 152 408 127 415 140 408 b 161 409 155 408 159 408 b 193 433 176 413 186 420 l 196 440 l 196 448 b 196 451 196 449 196 449 b 190 471 196 459 194 463 b 137 495 182 489 167 495 l 134 495 l 134 495 b 68 560 95 495 68 521 b 129 623 68 596 95 623 b 144 621 134 623 138 623 b 193 553 175 614 193 589 b 224 495 193 517 200 503 b 238 492 228 492 234 492 b 279 538 259 492 279 512 b 254 580 279 549 269 566 b 232 630 239 594 232 612 b 280 692 232 657 250 684 m 307 456 b 295 458 303 458 299 458 b 230 391 258 458 230 426 b 236 360 230 381 231 371 b 295 324 249 337 272 324 b 353 360 318 324 341 337 b 360 391 357 370 360 381 b 307 456 360 421 340 451 "},"v60":{"x_min":-590.71875,"x_max":589.359375,"ha":601,"o":"m -367 173 b -362 174 -366 174 -364 174 b -351 173 -357 174 -353 173 b -262 86 -348 172 -328 151 b -176 0 -216 37 -176 0 b -107 84 -176 0 -145 37 b -31 174 -36 173 -38 172 b -25 174 -29 174 -28 174 b -16 173 -23 174 -19 173 b 72 86 -13 172 6 151 b 157 0 119 37 157 0 b 227 84 159 0 189 37 b 303 174 298 173 296 172 b 308 174 304 174 307 174 b 318 173 313 174 317 173 b 481 11 322 172 357 134 l 494 -1 l 522 34 b 560 76 553 72 555 74 b 567 77 563 77 564 77 b 589 56 579 77 589 68 b 586 48 589 54 588 51 b 411 -172 583 41 416 -166 b 397 -176 406 -174 401 -176 b 387 -174 393 -176 390 -176 b 299 -87 386 -173 366 -152 b 213 0 253 -38 213 0 b 144 -86 213 0 182 -38 b 68 -174 73 -174 74 -173 b 62 -176 66 -176 65 -176 b 53 -174 59 -176 55 -174 b -35 -87 50 -173 29 -152 b -121 0 -83 -38 -121 0 b -190 -86 -122 0 -152 -38 b -266 -174 -261 -174 -259 -173 b -272 -176 -268 -176 -270 -176 b -281 -174 -276 -176 -280 -174 b -371 -86 -284 -173 -304 -152 b -457 0 -417 -38 -457 0 l -457 0 b -477 -26 -457 0 -470 -16 b -548 -227 -524 -88 -548 -161 b -536 -303 -548 -254 -544 -280 b -533 -317 -534 -309 -533 -313 b -553 -338 -533 -330 -541 -338 b -577 -315 -566 -338 -571 -333 b -590 -227 -586 -287 -590 -258 b -518 -9 -590 -154 -564 -77 b -465 56 -509 2 -504 8 l -402 134 b -367 173 -375 169 -372 172 "},"v62":{"x_min":46.28125,"x_max":669.671875,"ha":563,"o":"m 183 376 b 189 376 185 376 187 376 b 212 374 197 376 208 376 b 265 337 234 369 253 355 b 274 317 268 331 273 320 b 274 316 274 317 274 316 b 280 323 276 316 276 319 b 311 358 288 337 299 348 b 319 366 315 360 318 365 b 356 376 326 373 340 376 b 382 371 364 376 374 374 b 428 337 400 366 417 352 b 436 317 431 331 436 320 b 438 316 436 317 436 316 b 442 323 438 316 439 319 b 475 358 451 337 462 348 b 483 366 477 360 481 365 b 518 376 488 373 503 376 b 544 373 528 376 536 376 b 604 285 579 360 604 326 b 597 249 604 273 601 258 b 543 63 596 247 544 70 b 541 54 543 61 541 55 b 540 44 540 51 540 47 b 552 23 540 33 545 23 b 552 23 552 23 552 23 b 647 126 586 29 627 72 b 658 138 651 136 653 138 b 660 138 660 138 660 138 b 669 129 666 137 669 136 b 654 88 669 122 665 109 b 562 -12 631 43 602 9 l 549 -19 b 521 -27 540 -24 530 -27 b 447 30 490 -27 458 -4 b 443 58 445 38 443 48 b 450 93 443 72 446 84 b 504 278 453 97 504 272 b 507 288 506 283 506 287 b 509 298 507 292 509 295 b 491 326 509 310 502 320 b 487 327 490 327 488 327 b 479 324 484 327 483 326 b 441 270 462 316 443 288 b 435 249 441 265 436 254 b 398 127 434 248 419 195 b 362 4 379 61 362 5 b 328 -1 359 -1 362 -1 b 314 -1 323 -1 319 -1 b 302 -1 310 -1 306 -1 b 266 4 266 -1 269 -1 b 265 6 265 5 265 5 b 303 144 265 13 272 34 b 343 278 325 216 343 276 b 344 288 343 281 344 285 b 345 298 345 291 345 295 b 330 326 345 310 340 320 b 323 327 328 327 325 327 b 317 324 322 327 321 326 b 279 270 300 316 281 288 b 273 249 279 265 274 254 b 236 127 272 248 255 195 b 200 4 216 61 200 5 b 164 -1 197 -1 198 -1 b 151 -1 161 -1 156 -1 b 140 -1 147 -1 142 -1 b 103 4 104 -1 106 -1 b 103 6 103 5 103 5 b 141 144 103 13 108 34 b 181 278 161 216 179 276 b 182 288 181 281 181 285 b 183 298 182 291 183 295 b 168 324 183 310 178 320 b 160 327 166 326 163 327 b 141 320 156 327 151 324 b 69 230 112 305 85 272 b 57 215 65 217 62 215 b 55 215 57 215 55 215 b 46 224 49 215 46 217 b 59 260 46 231 50 242 b 151 363 81 306 112 341 b 161 369 155 365 160 367 b 183 376 166 371 174 374 "},"v68":{"x_min":-597.53125,"x_max":596.171875,"ha":608,"o":"m -533 324 b -525 327 -530 326 -528 327 b -504 305 -514 327 -504 317 b -504 305 -504 305 -504 305 b -513 284 -504 299 -504 299 b -556 112 -541 226 -556 167 b -545 33 -556 84 -552 58 b -524 -20 -541 15 -532 -9 l -522 -23 l -491 15 l -413 111 b -355 174 -367 169 -363 174 b -351 174 -353 174 -352 174 b -254 86 -343 174 -348 179 b -168 -1 -208 37 -168 -1 b -100 84 -168 -1 -137 37 b -23 173 -28 173 -29 172 b -19 174 -21 174 -20 174 b -8 173 -14 174 -10 173 b 155 11 -5 172 43 123 l 166 -1 l 168 1 l 170 4 l 170 130 b 171 260 170 256 170 258 b 191 274 175 269 183 274 b 205 267 196 274 201 272 b 212 158 212 262 210 273 l 212 56 l 257 112 b 311 173 304 172 304 172 b 317 174 313 174 314 174 b 326 173 319 174 323 173 b 490 11 329 172 366 134 l 502 -1 l 530 34 b 568 76 560 72 563 74 b 575 77 570 77 573 77 b 596 56 586 77 596 68 b 594 48 596 54 596 51 b 417 -172 592 41 424 -166 b 405 -176 415 -174 409 -176 b 396 -174 401 -176 398 -176 b 307 -87 393 -173 372 -152 b 221 -1 259 -38 221 -1 b 216 -6 221 -1 219 -2 l 212 -12 l 212 -147 b 212 -210 212 -173 212 -194 b 205 -292 212 -297 210 -287 b 191 -299 201 -297 196 -299 b 172 -287 183 -299 175 -295 b 170 -174 171 -284 171 -284 l 170 -63 l 127 -117 b 73 -176 84 -170 80 -176 b 68 -176 72 -176 70 -176 b -27 -87 59 -174 65 -180 b -114 0 -74 -38 -112 0 b -182 -86 -114 0 -145 -38 b -258 -174 -253 -174 -253 -173 b -264 -176 -259 -176 -262 -176 b -274 -174 -268 -176 -272 -174 b -438 -11 -277 -173 -348 -102 l -449 0 l -479 -37 b -524 -80 -513 -80 -514 -80 l -524 -80 b -553 -52 -534 -80 -540 -74 b -597 109 -583 -8 -597 48 b -560 280 -597 165 -585 224 b -533 324 -548 310 -540 322 "},"v6c":{"x_min":-1.359375,"x_max":193.28125,"ha":197,"o":"m 78 233 b 87 233 81 233 84 233 b 187 140 132 233 174 195 b 193 102 190 127 193 115 b 43 -113 193 22 136 -62 b 27 -119 36 -116 31 -119 b 19 -108 21 -119 19 -115 b 29 -97 19 -102 20 -101 b 102 13 73 -72 102 -27 b 92 51 102 26 98 40 l 91 54 l 84 54 b 8 104 53 54 21 74 b -1 142 1 116 -1 130 b 78 233 -1 187 31 227 "},"v6d":{"x_min":-590.71875,"x_max":589.359375,"ha":601,"o":"m 544 335 b 553 337 548 337 551 337 b 575 313 563 337 570 330 b 589 226 583 285 589 256 b 517 8 589 152 563 76 b 464 -58 507 -4 503 -9 l 401 -136 b 362 -176 372 -172 370 -176 b 357 -176 360 -176 359 -176 b 261 -87 349 -174 355 -180 b 175 0 215 -38 175 0 b 106 -86 175 0 144 -38 b 29 -174 35 -174 36 -173 b 24 -176 28 -176 27 -176 b 14 -174 21 -176 17 -174 b -73 -87 12 -173 -8 -152 b -159 0 -121 -38 -159 0 b -228 -86 -160 0 -190 -38 b -304 -174 -299 -174 -298 -173 b -310 -176 -306 -176 -308 -176 b -319 -174 -314 -176 -318 -174 b -483 -12 -323 -173 -359 -137 l -495 0 l -524 -34 b -562 -77 -553 -73 -556 -76 b -568 -79 -564 -79 -566 -79 b -590 -58 -581 -79 -590 -69 b -588 -49 -590 -55 -589 -52 b -412 170 -585 -43 -417 165 b -398 174 -408 173 -402 174 b -389 173 -394 174 -392 174 b -300 86 -387 172 -366 151 b -215 -1 -254 37 -215 -1 b -145 84 -215 -1 -183 37 b -69 173 -74 173 -76 172 b -63 174 -68 174 -66 174 b -54 173 -61 174 -57 173 b 34 86 -51 172 -31 151 b 119 -1 81 37 119 -1 b 189 84 121 -1 151 37 b 265 173 259 173 258 172 b 270 174 266 174 269 174 b 280 173 274 174 279 173 b 370 84 283 172 303 151 b 455 -1 416 37 455 -1 l 455 -1 b 476 24 455 -1 469 15 b 547 226 522 87 547 159 b 534 302 547 252 543 278 b 532 317 533 308 532 313 b 544 335 532 326 536 333 "},"v6f":{"x_min":-80.3125,"x_max":78.9375,"ha":81,"o":"m 63 191 b 69 192 65 192 66 192 b 77 188 72 192 76 191 b 78 183 78 187 78 186 b 74 158 78 179 77 172 l 66 115 b 9 -161 49 30 10 -158 b -10 -187 6 -172 -1 -181 b -34 -194 -17 -191 -25 -194 b -80 -147 -58 -194 -80 -174 b -80 -141 -80 -144 -80 -142 b 9 70 -80 -134 -73 -117 l 49 163 b 63 191 59 188 61 190 "},"v70":{"x_min":0,"x_max":436.921875,"ha":446,"o":"m 213 190 b 217 191 215 191 216 191 b 231 184 223 191 228 188 b 249 154 240 167 246 159 b 419 18 292 91 348 45 b 436 -1 435 11 436 8 b 424 -16 436 -9 434 -13 b 308 -87 394 -26 340 -59 b 231 -186 276 -117 257 -142 b 219 -192 228 -191 225 -192 b 198 -174 209 -192 208 -191 b 47 -33 161 -113 110 -63 b 10 -16 34 -26 17 -19 b 0 -1 2 -13 0 -9 b 17 18 0 8 1 11 b 198 173 95 48 156 101 b 213 190 206 187 208 188 "},"v72":{"x_min":-423.3125,"x_max":421.9375,"ha":431,"o":"m -262 197 b -247 197 -257 197 -253 197 b -118 162 -210 197 -163 184 b 40 45 -61 134 -13 98 b 277 -95 119 -33 200 -81 b 289 -97 281 -97 285 -97 b 378 0 332 -97 371 -55 b 378 11 378 4 378 6 b 302 83 378 55 345 83 b 242 66 283 83 262 77 b 208 56 231 59 219 56 b 148 120 175 56 148 81 b 201 186 148 151 164 172 b 261 198 220 194 240 198 b 420 45 341 198 411 136 b 421 22 421 37 421 29 b 245 -199 421 -93 338 -199 b 238 -198 243 -199 240 -199 b -44 -47 148 -194 50 -141 b -250 86 -114 22 -183 66 b -295 94 -270 91 -283 94 b -315 91 -302 94 -307 94 b -381 4 -356 81 -381 43 b -355 -56 -381 -18 -372 -40 b -298 -81 -338 -73 -319 -81 b -246 -68 -283 -81 -265 -77 b -212 -58 -234 -61 -223 -58 b -178 -69 -200 -58 -189 -62 b -151 -122 -160 -81 -151 -101 b -171 -167 -151 -138 -157 -155 b -239 -195 -185 -181 -213 -192 b -257 -197 -245 -197 -250 -197 b -423 -5 -352 -197 -423 -109 b -412 65 -423 16 -419 40 b -262 197 -389 137 -329 188 "},"v74":{"x_min":-206.890625,"x_max":428.75,"ha":438,"o":"m 389 -351 b 394 -351 390 -351 393 -351 b 428 -385 413 -351 428 -367 b 428 -394 428 -388 428 -391 b 394 -428 426 -406 421 -410 l 332 -473 l 269 -516 l 205 -560 l 141 -603 l 77 -648 l 13 -692 l -50 -737 l -114 -780 l -145 -802 b -171 -813 -157 -810 -163 -813 b -175 -813 -172 -813 -174 -813 b -206 -777 -194 -811 -206 -795 b -202 -760 -206 -771 -205 -766 b -87 -675 -197 -752 -206 -757 l -34 -639 l 83 -557 l 145 -514 l 209 -470 l 272 -427 b 389 -351 375 -356 381 -352 "},"v75":{"x_min":-149.71875,"x_max":148.359375,"ha":151,"o":"m -137 381 b -130 383 -134 383 -133 383 b -111 371 -122 383 -114 378 b -55 224 -110 370 -85 305 b 0 80 -25 145 -1 80 b 54 224 0 80 24 145 b 112 377 114 384 110 373 b 127 384 118 381 122 384 b 148 362 138 384 148 374 l 148 356 l 83 183 b 16 9 47 88 17 11 b -1 0 12 2 5 0 b -14 5 -5 0 -10 1 b -84 183 -19 9 -13 -6 l -149 356 l -149 362 b -137 381 -149 371 -145 378 "},"v78":{"x_min":0,"x_max":193.28125,"ha":197,"o":"m 85 514 b 95 517 88 517 89 517 b 114 505 103 517 110 513 l 115 502 l 115 376 b 115 249 115 306 115 249 b 141 258 117 249 127 252 l 167 266 l 172 266 b 190 254 181 265 187 262 l 193 251 l 193 202 l 193 188 b 187 147 193 149 191 152 b 147 130 183 142 182 141 l 115 119 l 115 9 b 115 -99 115 -51 115 -99 b 141 -91 115 -99 127 -95 b 171 -81 166 -81 167 -81 l 171 -81 b 191 -94 181 -81 189 -87 b 193 -142 191 -97 193 -120 b 191 -195 193 -167 191 -194 b 125 -227 187 -205 187 -204 l 115 -230 l 115 -366 l 115 -503 l 114 -506 b 95 -519 110 -514 102 -519 b 74 -506 87 -519 78 -514 l 73 -503 l 73 -374 b 73 -245 73 -260 73 -245 b 73 -245 73 -245 73 -245 b 55 -252 72 -245 63 -249 l 32 -260 b 19 -263 27 -262 23 -263 b 4 -256 13 -263 8 -260 b 0 -215 0 -251 0 -254 b 0 -199 0 -210 0 -206 l 0 -152 l 1 -149 b 8 -140 2 -145 5 -141 b 42 -127 9 -140 24 -133 l 73 -116 l 73 -5 b 73 23 73 4 73 15 b 73 105 73 70 73 105 b 49 97 73 105 61 101 b 17 88 32 91 23 88 b 4 95 10 88 8 91 b 0 137 0 101 0 98 b 0 151 0 141 0 145 l 0 199 l 1 202 b 43 224 5 212 5 212 l 73 234 l 73 367 l 73 502 l 74 505 b 85 514 77 509 81 513 "},"v79":{"x_min":-1.359375,"x_max":899.703125,"ha":918,"o":"m 307 349 b 332 351 315 351 323 351 b 443 340 367 351 408 347 b 741 47 607 306 720 195 b 744 0 743 31 744 16 b 660 -303 744 -90 713 -206 b 28 -755 534 -531 304 -695 b 14 -756 23 -755 19 -756 b -1 -741 4 -756 -1 -750 b 21 -720 -1 -731 1 -728 b 567 -56 337 -601 548 -344 b 568 -11 568 -41 568 -24 b 442 285 568 129 525 233 b 325 319 406 308 367 319 b 93 177 232 319 137 266 b 84 154 91 170 84 155 b 84 154 84 154 84 154 b 88 156 84 154 85 155 b 159 177 110 170 134 177 b 257 134 194 177 231 162 b 294 41 281 108 294 73 b 171 -97 294 -24 246 -90 b 156 -98 166 -97 161 -98 b 6 74 73 -98 6 -22 b 6 80 6 76 6 79 b 307 349 10 223 141 340 m 839 215 b 845 216 841 216 842 216 b 862 213 852 216 860 215 b 899 163 887 206 899 184 b 872 117 899 145 890 127 b 847 111 865 112 856 111 b 808 130 833 111 818 117 b 796 162 800 140 796 151 b 839 215 796 187 812 212 m 839 -112 b 845 -112 841 -112 842 -112 b 862 -115 852 -112 860 -113 b 899 -165 887 -122 899 -144 b 872 -210 899 -183 890 -201 b 847 -217 865 -215 856 -217 b 808 -198 833 -217 818 -210 b 796 -165 800 -188 796 -177 b 839 -112 796 -140 812 -116 "},"v7c":{"x_min":0,"x_max":300.8125,"ha":307,"o":"m 49 505 b 53 506 50 505 51 506 b 70 496 58 506 62 503 b 81 485 73 492 78 488 l 96 473 l 111 459 l 122 449 l 134 438 l 182 396 l 255 330 b 292 291 292 298 292 298 l 292 290 l 292 284 l 283 270 b 209 36 234 197 209 113 b 288 -170 209 -44 235 -119 b 299 -184 295 -179 299 -181 b 300 -191 300 -187 300 -188 b 285 -206 300 -199 294 -206 b 280 -206 283 -206 281 -206 b 247 -201 270 -202 259 -201 b 176 -222 223 -201 197 -208 b 114 -340 136 -249 114 -292 b 172 -471 114 -384 134 -433 b 185 -492 182 -481 185 -487 b 181 -502 185 -496 183 -499 b 171 -508 176 -505 174 -508 b 152 -498 166 -508 160 -503 b 0 -284 65 -428 12 -352 b 0 -260 0 -278 0 -270 b 1 -238 0 -252 0 -242 b 148 -140 16 -177 73 -140 b 209 -148 167 -140 189 -142 b 215 -149 212 -148 215 -149 b 215 -149 215 -149 215 -149 l 215 -149 b 201 -136 215 -148 209 -142 l 157 -97 l 96 -41 b 17 34 21 24 17 29 b 17 37 17 36 17 36 b 17 38 17 37 17 38 b 25 56 17 44 17 44 b 110 298 81 131 110 219 b 46 474 110 367 88 431 b 38 491 40 480 38 487 b 49 505 38 498 42 502 "},"v7d":{"x_min":-1.359375,"x_max":436.921875,"ha":446,"o":"m 213 205 b 217 205 215 205 216 205 b 234 194 224 205 234 199 b 236 187 234 194 235 190 l 245 167 l 261 129 l 270 106 b 355 -61 294 54 329 -13 b 420 -163 381 -105 402 -138 b 436 -188 435 -184 436 -184 b 436 -191 436 -190 436 -190 b 421 -206 436 -201 431 -206 l 421 -206 l 416 -206 l 405 -201 b 217 -158 347 -172 283 -158 b 31 -201 153 -158 88 -172 l 20 -206 l 14 -206 l 14 -206 b 0 -191 5 -206 0 -201 b -1 -188 0 -190 -1 -190 b 14 -163 -1 -186 0 -184 b 95 -34 36 -136 72 -77 b 166 106 119 8 148 68 l 175 129 l 183 148 l 200 188 b 213 205 205 199 208 202 "},"v7f":{"x_min":0,"x_max":367.5,"ha":375,"o":"m 0 124 l 0 187 l 61 187 l 122 187 l 122 138 l 122 91 l 153 61 l 183 30 l 213 61 l 243 91 l 243 138 l 243 187 l 306 187 l 367 187 l 367 124 l 367 61 l 321 61 l 274 61 l 243 30 l 213 0 l 243 -31 l 274 -62 l 321 -62 l 367 -62 l 367 -124 l 367 -188 l 306 -188 l 243 -188 l 243 -140 l 243 -93 l 213 -62 l 183 -31 l 153 -62 l 122 -93 l 122 -140 l 122 -188 l 61 -188 l 0 -188 l 0 -124 l 0 -62 l 46 -62 l 92 -62 l 123 -31 l 153 0 l 123 30 l 92 61 l 46 61 l 0 61 l 0 124 "},"v80":{"x_min":29.9375,"x_max":420.578125,"ha":371,"o":"m 115 345 b 221 347 117 345 166 347 b 411 345 306 347 409 345 b 420 330 416 342 420 335 b 415 319 420 326 419 321 b 178 118 397 303 179 118 b 178 117 178 118 178 117 b 181 117 178 117 178 117 b 189 117 182 117 185 117 b 193 117 190 117 191 117 b 247 98 215 117 232 111 b 296 75 266 83 280 76 b 302 75 299 75 300 75 b 322 91 311 75 315 79 b 322 91 322 91 322 91 b 322 91 322 91 322 91 b 319 91 322 91 321 91 b 313 90 318 90 315 90 b 283 107 300 90 288 97 b 277 126 279 114 277 121 b 319 167 277 149 295 167 b 319 167 319 167 319 167 b 362 118 347 167 362 147 b 355 82 362 108 359 96 b 311 33 349 65 340 55 b 224 1 284 12 253 1 b 194 5 213 1 204 2 b 168 18 183 8 178 11 b 110 36 151 30 130 36 b 57 15 88 36 68 29 b 47 11 54 12 51 11 b 31 20 40 11 34 13 b 29 26 31 22 29 25 b 68 66 29 36 39 45 b 285 250 73 71 281 248 b 285 250 285 250 285 250 b 231 252 285 252 261 252 b 137 250 190 252 141 250 b 93 227 122 248 110 241 b 78 220 88 222 83 220 b 66 227 74 220 70 222 b 63 234 65 229 63 231 b 85 291 63 241 69 252 b 115 345 108 342 108 344 "},"v81":{"x_min":0,"x_max":428.75,"ha":438,"o":"m 262 186 b 273 186 266 186 272 186 b 274 186 273 186 274 186 b 285 186 274 186 280 186 b 428 48 375 181 428 122 b 386 -68 428 12 416 -29 b 155 -187 329 -145 236 -187 b 12 -111 92 -187 38 -162 b 0 -51 4 -91 0 -72 b 262 186 0 58 122 179 m 366 131 b 352 134 362 133 357 134 b 219 81 321 134 269 115 b 47 -111 126 23 50 -62 b 47 -112 47 -111 47 -112 b 77 -136 47 -129 58 -136 b 264 -45 118 -136 194 -101 b 382 109 336 12 382 76 b 366 131 382 120 377 129 "},"v83":{"x_min":-1.359375,"x_max":847.96875,"ha":865,"o":"m 488 1499 b 495 1500 490 1500 492 1500 b 541 1465 507 1500 521 1490 b 679 1078 622 1372 679 1210 b 677 1050 679 1068 677 1060 b 477 642 668 893 604 764 l 443 609 l 431 596 l 431 592 l 438 562 l 449 508 l 460 458 b 481 355 475 390 481 355 b 481 355 481 355 481 355 b 490 356 481 355 485 355 b 528 358 495 356 511 358 b 558 356 540 358 552 356 b 839 95 699 338 808 237 b 847 22 845 72 847 47 b 631 -303 847 -113 766 -242 b 620 -309 623 -308 620 -309 l 620 -310 b 631 -359 620 -310 626 -333 l 646 -435 l 660 -496 b 672 -588 668 -535 672 -563 b 664 -653 672 -610 669 -630 b 383 -875 630 -792 509 -875 b 201 -810 321 -875 257 -855 b 129 -680 151 -768 129 -730 b 274 -530 129 -592 200 -530 b 351 -553 300 -530 326 -538 b 412 -669 393 -582 412 -626 b 287 -805 412 -735 366 -800 l 279 -805 l 285 -809 b 383 -830 318 -823 351 -830 b 586 -718 464 -830 540 -789 b 626 -584 612 -678 626 -631 b 619 -528 626 -566 623 -548 b 612 -495 619 -526 616 -510 b 577 -324 590 -387 577 -324 b 577 -324 577 -324 577 -324 b 568 -326 575 -324 571 -324 b 528 -334 558 -328 537 -333 b 465 -338 506 -337 485 -338 b 24 -11 269 -338 87 -206 b -1 145 8 41 -1 93 b 96 442 -1 249 32 351 b 322 714 166 541 236 626 l 352 745 l 345 782 l 332 843 l 315 921 b 303 984 310 950 304 978 b 295 1082 298 1017 295 1049 b 413 1426 295 1208 336 1329 b 488 1499 436 1456 477 1496 m 549 1301 b 541 1301 547 1301 544 1301 b 411 1207 500 1301 447 1263 b 355 1004 374 1152 355 1079 b 359 942 355 984 356 963 b 371 881 362 927 363 917 l 385 818 b 392 782 389 799 392 784 l 392 782 b 434 828 393 782 424 816 b 607 1165 534 941 594 1060 b 608 1193 608 1175 608 1183 b 597 1270 608 1224 604 1254 b 549 1301 589 1286 571 1299 m 398 528 b 393 555 396 542 393 553 b 392 555 393 555 393 555 b 317 470 390 555 347 505 b 190 298 266 408 212 334 b 127 70 148 227 127 148 b 155 -77 127 19 137 -30 b 468 -303 209 -216 333 -303 b 519 -299 484 -303 502 -302 b 568 -284 541 -295 568 -287 l 568 -284 b 563 -263 568 -284 566 -274 l 534 -120 l 511 -13 l 496 61 l 480 133 b 469 187 472 176 469 187 b 468 188 469 187 469 188 b 416 162 462 188 430 172 b 337 13 364 126 337 69 b 413 -124 337 -40 363 -93 b 428 -144 424 -131 428 -137 b 428 -149 428 -145 428 -148 b 409 -166 426 -161 419 -166 b 394 -162 405 -166 400 -165 b 240 77 302 -122 240 -27 l 240 77 b 430 342 240 197 315 301 l 436 344 l 426 394 l 398 528 m 548 194 b 526 195 540 195 532 195 b 519 195 524 195 521 195 l 514 195 l 518 177 l 539 79 l 552 15 l 566 -48 l 594 -187 l 605 -240 b 612 -266 609 -254 611 -266 b 612 -266 612 -266 612 -266 b 641 -248 613 -266 630 -256 b 744 -98 692 -212 730 -156 b 751 -40 749 -79 751 -59 b 548 194 751 76 665 181 "},"v84":{"x_min":25.859375,"x_max":164.6875,"ha":168,"o":"m 34 369 b 40 370 35 370 38 370 b 59 353 49 370 50 367 b 164 40 122 254 155 158 b 164 0 164 33 164 16 b 164 -40 164 -16 164 -34 b 59 -353 155 -158 122 -254 b 40 -371 53 -366 47 -371 b 34 -370 38 -371 36 -370 b 25 -358 28 -367 25 -363 b 31 -337 25 -352 27 -347 b 92 0 72 -234 92 -117 b 31 335 92 116 72 233 b 25 356 27 345 25 352 b 34 369 25 363 28 366 "},"v86":{"x_min":-571.671875,"x_max":570.3125,"ha":582,"o":"m -386 173 b -381 174 -385 174 -383 174 b -370 173 -377 174 -372 173 b -281 86 -367 172 -347 151 b -196 0 -235 37 -196 0 b -126 84 -196 0 -164 37 b -50 174 -55 173 -57 172 b -44 174 -49 174 -47 174 b -35 173 -42 174 -38 173 b 53 86 -32 172 -12 151 b 138 0 100 37 138 0 b 208 84 140 0 170 37 b 284 174 279 173 277 172 b 289 174 285 174 288 174 b 299 173 294 174 298 173 b 462 11 303 172 338 134 l 475 -1 l 503 34 b 541 76 534 72 536 74 b 548 77 544 77 545 77 b 570 56 560 77 570 68 b 567 48 570 54 568 51 b 392 -172 564 41 397 -166 b 378 -176 387 -174 382 -176 b 368 -174 374 -176 371 -176 b 280 -87 367 -173 345 -152 b 194 0 234 -38 194 0 b 125 -86 194 0 163 -38 b 49 -174 54 -174 55 -173 b 43 -176 47 -176 46 -176 b 34 -174 40 -176 36 -174 b -54 -87 31 -173 10 -152 b -140 0 -102 -38 -140 0 b -209 -86 -141 0 -171 -38 b -285 -174 -280 -174 -279 -173 b -291 -176 -287 -176 -289 -176 b -300 -174 -295 -176 -299 -174 b -464 -12 -304 -173 -340 -137 l -476 0 l -504 -34 b -543 -77 -534 -73 -537 -76 b -549 -79 -545 -79 -547 -79 b -571 -58 -562 -79 -571 -69 b -568 -49 -571 -55 -570 -52 b -392 172 -566 -43 -396 167 b -386 173 -390 172 -387 173 "},"v8a":{"x_min":-170.140625,"x_max":168.78125,"ha":172,"o":"m -160 567 b -122 567 -159 567 -149 567 l -87 567 l -84 566 b -74 553 -78 563 -77 560 b -20 366 -73 551 -49 466 b 31 186 8 267 31 186 b 85 371 31 186 55 269 b 140 559 114 473 138 557 b 153 567 141 564 148 567 b 168 559 159 567 166 564 b 168 555 168 557 168 557 b 92 281 168 548 159 513 b 14 13 50 134 14 13 b 0 0 14 6 6 0 b -17 15 -8 0 -17 8 b -93 283 -17 15 -51 136 b -170 552 -166 533 -170 548 b -170 553 -170 552 -170 552 b -160 567 -170 560 -167 564 "},"v8b":{"x_min":0,"x_max":319.859375,"ha":326,"o":"m 149 508 b 159 509 152 509 155 509 b 186 494 170 509 181 503 b 190 440 190 487 190 488 l 190 430 l 190 377 l 242 377 l 251 377 b 303 373 298 377 296 377 b 319 345 314 367 319 356 b 304 319 319 335 314 324 b 250 315 296 315 299 315 l 242 315 l 190 315 l 190 262 l 190 252 b 186 198 190 204 190 205 b 159 183 179 188 170 183 b 132 198 148 183 138 188 b 127 252 127 205 127 204 l 127 262 l 127 315 l 76 315 l 68 315 b 14 319 20 315 21 315 b 0 347 4 324 0 335 b 14 373 0 356 4 367 b 68 377 21 377 20 377 l 76 377 l 127 377 l 127 430 l 127 440 b 132 494 127 488 127 487 b 149 508 136 501 142 505 "},"v8c":{"x_min":-330.75,"x_max":329.390625,"ha":336,"o":"m -133 483 b -117 484 -127 484 -122 484 b 31 373 -51 484 9 440 b 35 348 34 365 35 356 b -25 285 35 313 10 285 b -87 331 -55 285 -76 302 b -167 402 -100 376 -133 402 b -191 398 -175 402 -183 401 b -227 341 -215 388 -227 369 b -225 320 -227 334 -227 327 b -13 74 -209 230 -125 133 b 6 65 -4 70 5 66 l 9 63 l 10 65 b 117 231 12 68 40 112 l 189 341 l 242 424 b 268 460 262 456 264 458 b 283 464 273 463 277 464 b 308 438 296 464 308 453 l 308 437 b 287 396 308 430 308 428 l 95 98 l 59 43 l 58 41 l 65 37 b 253 -156 151 -8 217 -77 b 281 -285 272 -199 281 -244 b 148 -481 281 -381 231 -463 b 115 -485 137 -484 126 -485 b -32 -376 51 -485 -9 -442 b -36 -349 -35 -366 -36 -358 b 25 -287 -36 -315 -12 -287 b 85 -333 54 -287 74 -302 b 166 -403 99 -377 133 -403 b 190 -399 174 -403 182 -402 b 225 -342 215 -390 225 -370 b 224 -322 225 -335 225 -328 b 12 -76 208 -231 125 -134 b -8 -66 2 -72 -6 -68 l -10 -65 l -12 -66 b -118 -231 -13 -68 -42 -113 l -190 -342 l -243 -426 b -269 -462 -264 -458 -265 -458 b -284 -466 -274 -464 -279 -466 b -310 -440 -298 -466 -310 -455 l -310 -438 b -288 -398 -310 -430 -308 -430 l -96 -99 l -59 -44 l -59 -43 l -66 -38 b -281 284 -198 33 -281 158 l -281 284 b -133 483 -281 392 -220 474 m 254 177 b 266 179 258 177 262 179 b 319 149 287 179 307 167 b 329 115 326 140 329 127 b 319 79 329 102 326 90 b 268 51 307 61 287 51 b 221 72 250 51 234 58 b 205 115 210 84 205 99 b 254 177 205 142 223 170 m -281 -54 b -269 -52 -277 -52 -273 -52 b -223 -73 -253 -52 -235 -59 b -206 -116 -212 -84 -206 -101 b -216 -151 -206 -129 -209 -141 b -269 -179 -228 -170 -249 -179 b -314 -159 -285 -179 -302 -173 b -330 -116 -325 -147 -330 -131 b -281 -54 -330 -88 -313 -61 "},"v8f":{"x_min":-21.78125,"x_max":362.0625,"ha":369,"o":"m 302 1031 b 308 1032 304 1032 307 1032 b 330 1016 318 1032 325 1027 b 362 867 351 970 362 920 b 340 738 362 824 353 780 l 336 727 l 340 717 b 362 591 355 677 362 634 b 257 323 362 496 325 401 b 204 272 243 306 227 290 b 20 56 129 206 66 133 b -1 18 12 44 0 22 b -19 4 -4 9 -12 4 l -21 4 l -21 140 l -21 276 l -12 277 b 167 333 61 288 127 309 b 319 598 262 388 319 491 b 311 664 319 620 317 642 l 310 673 l 304 664 b 204 548 279 620 250 587 b 20 333 129 483 66 409 b -1 292 12 320 0 298 b -19 280 -4 285 -12 280 l -21 280 l -21 416 l -21 552 l -12 553 b 167 609 61 564 127 585 b 319 874 264 666 319 770 b 294 992 319 914 311 954 b 288 1011 288 1004 288 1007 b 302 1031 288 1021 294 1028 "},"v90":{"x_min":-171.5,"x_max":483.1875,"ha":493,"o":"m -8 631 b -1 632 -6 632 -4 632 b 19 620 8 632 16 628 b 20 495 20 616 20 616 b 20 373 20 427 20 373 b 115 410 20 373 63 390 l 210 448 l 210 531 b 212 620 210 614 210 616 b 231 632 215 628 223 632 b 246 627 236 632 242 631 b 251 541 251 620 251 628 l 251 463 l 315 489 b 387 514 368 509 381 514 b 393 513 390 514 392 514 b 406 494 402 510 406 502 b 397 476 406 487 404 480 b 323 446 396 474 363 462 l 251 417 l 251 283 l 251 148 l 254 151 b 370 199 291 183 332 199 b 415 191 385 199 400 197 b 483 84 458 176 483 134 b 461 0 483 58 476 29 b 332 -142 439 -40 411 -72 l 255 -215 b 231 -229 240 -229 239 -229 b 216 -223 224 -229 220 -227 b 210 -158 210 -217 210 -223 b 210 -120 210 -148 210 -136 l 210 -29 l 205 -34 b 100 -142 182 -65 159 -88 l 23 -215 b -1 -229 9 -229 6 -229 b -19 -217 -9 -229 -16 -224 l -20 -215 l -21 48 l -21 310 l -83 287 b -152 262 -133 266 -145 262 b -157 263 -153 262 -155 262 b -171 283 -166 266 -171 274 b -161 301 -171 290 -167 297 b -91 328 -160 302 -129 315 l -21 356 l -21 487 l -20 617 l -19 621 b -8 631 -17 626 -12 630 m 210 288 b 210 401 210 351 210 401 b 114 365 209 401 167 384 l 20 327 l 20 238 l 20 148 l 21 151 b 140 199 59 183 102 199 b 206 180 164 199 187 192 l 209 177 b 209 177 209 177 209 177 b 210 288 210 177 210 199 m 110 131 b 96 133 106 133 100 133 b 89 133 93 133 91 133 b 24 87 63 129 40 113 l 20 80 l 20 -37 l 20 -156 l 23 -152 b 144 81 96 -72 144 20 l 144 83 b 110 131 144 113 134 126 m 341 131 b 328 133 337 133 332 133 b 322 133 326 133 323 133 b 257 87 296 129 273 113 l 251 80 l 251 -37 l 251 -156 l 255 -152 b 375 81 328 -72 375 20 l 375 83 b 341 131 375 113 367 126 "},"v92":{"x_min":0,"x_max":598.890625,"ha":611,"o":"m 62 181 b 77 183 66 183 72 183 b 91 181 83 183 88 183 b 202 131 100 180 106 177 l 299 87 l 394 131 b 517 183 499 181 502 183 b 519 183 517 183 518 183 b 598 104 567 183 598 144 b 577 49 598 84 592 65 b 518 15 567 38 563 37 b 484 0 499 6 484 0 b 518 -16 484 -1 499 -8 b 577 -51 563 -38 567 -40 b 598 -105 592 -66 598 -86 b 519 -184 598 -145 567 -184 b 517 -184 518 -184 517 -184 b 394 -133 502 -184 499 -183 l 299 -88 l 202 -133 b 81 -184 99 -183 95 -184 b 77 -184 80 -184 78 -184 b 0 -105 29 -184 0 -145 b 20 -51 0 -86 5 -66 b 80 -16 29 -40 34 -38 b 114 -1 98 -8 114 -1 b 80 15 114 0 98 6 b 20 49 34 37 29 38 b 0 104 6 65 0 84 b 62 181 0 140 23 174 m 88 134 b 74 136 85 134 80 136 b 68 134 72 136 69 136 b 46 104 54 130 46 117 b 55 81 46 95 49 88 b 149 34 59 76 53 80 b 224 -1 190 15 224 0 b 144 -38 224 -1 187 -18 b 54 -84 59 -79 58 -79 b 46 -105 49 -90 46 -98 b 76 -137 46 -122 58 -137 b 78 -137 77 -137 77 -137 b 194 -86 87 -137 76 -141 b 298 -36 250 -58 298 -36 b 298 -36 298 -36 298 -36 b 402 -84 299 -36 345 -58 b 518 -137 522 -141 510 -137 b 521 -137 519 -137 519 -137 b 551 -105 539 -137 551 -122 b 541 -83 551 -98 548 -90 b 447 -36 537 -77 544 -81 b 374 -1 406 -16 374 -1 b 447 34 374 0 406 15 b 541 81 544 80 537 76 b 551 104 548 88 551 97 b 521 136 551 120 539 136 b 518 136 519 136 519 136 b 517 136 518 136 517 136 l 517 136 b 402 83 511 136 511 136 b 298 34 345 56 299 34 b 298 34 298 34 298 34 b 194 84 298 34 250 56 b 88 134 137 111 89 133 "},"v93":{"x_min":0,"x_max":438.28125,"ha":447,"o":"m 212 205 b 219 205 213 205 216 205 b 239 183 228 205 231 204 b 421 -163 298 40 363 -83 b 438 -191 434 -180 438 -186 b 436 -197 438 -192 438 -195 b 424 -206 434 -204 431 -206 b 406 -201 420 -206 415 -205 b 216 -156 347 -172 281 -156 b 23 -205 148 -156 80 -173 b 14 -206 20 -206 17 -206 b 0 -191 6 -206 0 -201 b 6 -176 0 -187 1 -183 b 202 192 63 -104 142 45 b 212 205 205 199 208 202 m 264 48 l 249 81 l 243 94 l 242 91 b 89 -126 208 36 137 -66 b 81 -138 85 -133 81 -138 b 81 -138 81 -138 81 -138 b 81 -138 81 -138 81 -138 b 95 -133 81 -138 87 -136 b 280 -94 156 -108 221 -94 b 334 -98 299 -94 317 -95 b 343 -99 338 -99 343 -99 b 343 -99 343 -99 343 -99 b 338 -94 343 -99 341 -97 b 264 48 318 -58 287 1 "},"v94":{"x_min":-149.71875,"x_max":148.359375,"ha":151,"o":"m -9 215 b 0 217 -6 217 -4 217 b 19 205 8 217 14 213 b 20 142 20 202 20 201 l 20 84 l 23 84 b 144 -27 81 74 129 30 b 148 -66 147 -40 148 -54 b 36 -213 148 -134 103 -197 b 0 -219 24 -217 12 -219 b -145 -104 -68 -219 -129 -173 b -149 -68 -148 -91 -149 -79 b -24 84 -149 6 -98 74 l -21 84 l -21 142 b -19 205 -20 201 -20 202 b -9 215 -17 209 -13 213 m -21 -15 b -23 41 -21 37 -21 41 b -23 41 -23 41 -23 41 b -76 11 -35 40 -62 26 b -108 -65 -98 -11 -108 -38 b -1 -176 -108 -122 -65 -176 b 107 -65 63 -176 107 -122 b 74 11 107 -38 96 -11 b 20 41 61 26 32 41 b 20 -15 20 41 20 15 b 19 -74 20 -72 20 -72 b 0 -87 14 -83 6 -87 b -19 -74 -8 -87 -16 -83 b -21 -15 -20 -72 -20 -72 "},"v95":{"x_min":0,"x_max":406.96875,"ha":415,"o":"m 55 181 b 70 183 61 183 66 183 b 111 170 85 183 99 179 b 160 130 115 167 137 149 l 202 95 l 245 130 b 319 181 299 176 302 179 b 334 183 325 183 330 183 b 406 109 375 183 406 148 b 401 81 406 99 405 91 b 348 24 394 65 390 59 b 318 -1 332 11 318 0 b 348 -26 318 -1 332 -12 b 401 -83 390 -61 394 -66 b 406 -111 405 -93 406 -101 b 334 -184 406 -149 375 -184 b 319 -183 330 -184 325 -184 b 245 -131 302 -180 299 -177 l 202 -97 l 160 -131 b 85 -183 107 -177 103 -180 b 70 -184 80 -184 76 -184 b 0 -111 31 -184 0 -149 b 4 -83 0 -101 1 -93 b 58 -26 10 -66 16 -61 b 88 -1 74 -12 88 -1 b 58 24 88 0 74 11 b 10 69 23 54 17 59 b 0 109 2 81 0 95 b 55 181 0 142 21 173 m 83 133 b 72 136 78 136 76 136 b 57 131 66 136 61 134 b 46 109 49 126 46 117 b 50 93 46 104 47 98 b 107 45 51 91 77 70 b 160 0 137 20 160 0 b 107 -47 160 -1 137 -22 b 50 -94 77 -72 51 -93 b 46 -111 47 -99 46 -105 b 59 -134 46 -120 50 -130 b 72 -137 62 -136 68 -137 b 83 -136 76 -137 80 -136 b 144 -84 84 -134 107 -116 b 202 -36 176 -58 202 -36 b 261 -84 202 -36 230 -58 b 323 -136 299 -116 321 -134 b 334 -137 326 -136 330 -137 b 345 -134 338 -137 343 -136 b 360 -111 355 -130 360 -120 b 355 -94 360 -105 359 -99 b 299 -47 353 -93 329 -72 b 245 0 269 -22 245 -1 b 299 45 245 0 269 20 b 355 93 329 70 353 91 b 360 109 359 98 360 104 b 345 133 360 119 355 129 b 334 136 343 134 338 136 b 323 134 330 136 326 134 b 261 83 321 133 299 115 b 202 34 230 56 202 34 b 144 83 202 34 176 56 b 83 133 106 115 84 133 "},"v97":{"x_min":-228.671875,"x_max":227.3125,"ha":232,"o":"m -217 487 l -213 488 l 0 488 l 212 488 l 216 487 b 225 476 220 484 224 480 l 227 473 l 227 244 l 227 15 l 225 12 b 206 0 223 4 215 0 b 197 1 204 0 200 0 b 187 12 193 4 189 6 l 186 15 l 186 138 l 186 262 l -1 262 l -187 262 l -187 138 l -187 15 l -189 12 b -208 0 -193 4 -200 0 b -227 12 -216 0 -223 4 l -228 15 l -228 244 l -228 473 l -227 476 b -217 487 -225 480 -221 484 "},"v9a":{"x_min":-21.78125,"x_max":367.5,"ha":375,"o":"m 230 1031 b 238 1032 232 1032 235 1032 b 259 1014 245 1032 251 1027 b 367 662 330 906 367 782 b 364 602 367 641 367 621 b 232 317 352 488 304 384 b 57 120 155 245 103 187 b -1 18 31 84 6 40 b -19 4 -4 11 -12 4 l -21 4 l -21 159 l -21 315 l -16 315 b 96 335 10 315 62 324 b 315 695 227 380 315 527 b 313 738 315 709 314 724 b 224 991 304 825 273 916 b 216 1013 219 999 216 1007 b 230 1031 216 1021 220 1028 "},"v9b":{"x_min":-24.5,"x_max":313.0625,"ha":319,"o":"m -24 -133 l -24 -5 l -20 -5 b -1 -19 -12 -5 -4 -11 b 142 -213 13 -61 74 -144 b 258 -376 196 -269 230 -315 b 313 -605 295 -449 313 -528 b 292 -742 313 -652 306 -699 b 288 -752 289 -748 288 -752 b 288 -752 288 -752 288 -752 b 292 -764 289 -753 291 -757 b 313 -907 306 -811 313 -860 b 292 -1045 313 -954 306 -1002 b 288 -1054 289 -1050 288 -1054 b 288 -1054 288 -1054 288 -1054 b 292 -1067 289 -1054 291 -1060 b 313 -1210 306 -1113 313 -1161 b 292 -1346 313 -1257 306 -1304 b 288 -1357 289 -1353 288 -1357 b 288 -1357 288 -1357 288 -1357 b 292 -1368 289 -1357 291 -1363 b 313 -1512 306 -1415 313 -1464 b 292 -1648 313 -1560 306 -1605 b 288 -1660 289 -1654 288 -1660 b 288 -1660 288 -1660 288 -1660 b 292 -1671 289 -1660 291 -1665 b 313 -1814 306 -1719 313 -1766 b 250 -2040 313 -1897 291 -1977 b 232 -2062 238 -2057 236 -2059 b 221 -2065 230 -2063 225 -2065 b 200 -2045 210 -2065 201 -2057 b 200 -2043 200 -2044 200 -2044 b 208 -2026 200 -2037 202 -2034 b 269 -1826 249 -1966 269 -1897 b 153 -1544 269 -1726 230 -1625 b -9 -1472 115 -1506 58 -1481 b -21 -1471 -14 -1471 -19 -1471 l -24 -1471 l -24 -1343 l -24 -1215 l -20 -1215 b -1 -1229 -12 -1215 -4 -1221 b 142 -1424 13 -1270 74 -1353 b 257 -1582 196 -1478 228 -1524 b 264 -1594 261 -1589 264 -1594 l 264 -1594 b 265 -1582 264 -1594 264 -1589 b 270 -1525 268 -1562 270 -1544 b 153 -1243 270 -1424 228 -1321 b -9 -1170 115 -1203 58 -1178 b -21 -1168 -14 -1170 -19 -1168 l -24 -1168 l -24 -1041 l -24 -913 l -20 -913 b -1 -927 -12 -913 -4 -918 b 142 -1121 13 -967 74 -1050 b 257 -1281 196 -1175 228 -1221 b 264 -1292 261 -1286 264 -1292 l 264 -1292 b 265 -1279 264 -1292 264 -1286 b 270 -1222 268 -1261 270 -1242 b 153 -941 270 -1121 228 -1018 b -9 -867 115 -900 58 -875 b -21 -866 -14 -867 -19 -866 l -24 -866 l -24 -738 l -24 -610 l -20 -610 b -1 -624 -12 -610 -4 -616 b 142 -818 13 -664 74 -749 b 257 -978 196 -873 228 -918 b 264 -989 261 -984 264 -989 l 264 -989 b 265 -977 264 -989 264 -984 b 270 -920 268 -959 270 -939 b 153 -638 270 -818 228 -716 b -9 -564 115 -598 58 -573 b -21 -563 -14 -564 -19 -563 l -24 -563 l -24 -435 l -24 -308 l -20 -308 b -1 -322 -12 -308 -4 -313 b 142 -516 13 -363 74 -446 b 257 -675 196 -571 228 -616 b 264 -687 261 -681 264 -687 l 264 -687 b 265 -674 264 -687 264 -681 b 270 -617 268 -656 270 -637 b 153 -335 270 -516 228 -413 b -9 -262 115 -295 58 -270 b -21 -260 -14 -262 -19 -260 l -24 -260 l -24 -133 "},"v9c":{"x_min":-166.0625,"x_max":-25.859375,"ha":0,"o":"m -49 369 b -42 370 -46 369 -44 370 b -27 360 -36 370 -29 366 b -25 355 -27 359 -25 358 b -32 335 -25 351 -28 347 b -92 52 -66 248 -87 159 b -93 -1 -93 43 -93 20 b -92 -54 -93 -23 -93 -45 b -32 -337 -85 -162 -66 -251 b -25 -355 -27 -349 -25 -352 b -42 -371 -25 -365 -32 -371 b -61 -353 -50 -371 -51 -369 b -163 -63 -119 -262 -153 -165 b -166 -1 -166 -37 -166 -31 b -163 62 -166 30 -166 36 b -61 352 -153 163 -119 260 b -49 369 -54 365 -51 366 "},"v9e":{"x_min":0,"x_max":607.0625,"ha":619,"o":"m 243 631 b 250 632 246 632 249 632 b 270 620 259 632 268 628 l 272 616 l 272 201 l 272 -212 l 270 -216 b 251 -229 268 -224 259 -229 b 227 -215 243 -229 240 -229 l 151 -142 b 32 -16 81 -80 53 -49 b 0 84 9 18 0 52 b 111 199 0 149 42 199 b 137 197 119 199 127 198 b 228 151 168 191 197 177 l 231 148 l 231 383 b 232 620 231 616 231 616 b 243 631 234 624 238 630 m 168 131 b 152 133 163 133 157 133 b 107 102 130 133 111 120 b 106 86 107 97 106 91 b 111 41 106 73 108 56 b 227 -152 125 -13 171 -90 l 231 -156 l 231 -37 l 231 80 l 225 87 b 168 131 210 111 190 126 m 347 631 b 353 632 348 632 351 632 b 374 620 363 632 371 628 b 375 383 375 616 375 616 l 375 148 l 377 151 b 492 199 415 183 454 199 b 537 191 507 199 522 197 b 607 84 582 176 607 134 b 583 0 607 58 598 29 b 455 -142 562 -40 533 -72 l 378 -215 b 355 -229 364 -229 362 -229 b 334 -216 345 -229 337 -224 l 333 -212 l 333 201 l 333 616 l 334 620 b 347 631 337 624 341 630 m 465 131 b 451 133 461 133 455 133 b 445 133 449 133 446 133 b 379 87 419 129 396 113 l 375 80 l 375 -37 l 375 -156 l 378 -152 b 499 81 451 -72 499 20 l 499 83 b 465 131 499 113 490 126 "},"va3":{"x_min":58.53125,"x_max":228.671875,"ha":294,"o":"m 138 371 b 142 373 140 371 141 373 b 178 342 149 373 156 366 b 228 251 217 297 228 278 b 228 244 228 248 228 247 b 176 147 227 212 212 184 b 123 73 152 122 132 93 b 121 62 122 70 121 66 b 145 13 121 48 129 31 b 153 -2 151 6 153 1 b 149 -9 153 -5 152 -6 b 144 -11 148 -11 145 -11 b 129 -1 140 -11 136 -8 b 61 87 89 37 68 68 b 58 113 59 95 58 105 b 110 215 58 144 74 177 b 163 287 134 240 155 269 b 166 299 166 291 166 295 b 141 348 166 313 157 330 b 133 360 134 356 133 358 b 133 363 133 362 133 362 b 138 371 133 367 136 370 "},"va5":{"x_min":0,"x_max":349.8125,"ha":357,"o":"m 88 302 b 103 303 93 302 98 303 b 202 224 149 303 191 270 b 205 199 204 216 205 208 b 178 129 205 173 196 147 l 175 126 l 182 127 b 307 249 236 142 284 190 b 313 259 308 254 311 258 b 329 267 317 265 323 267 b 349 247 340 267 349 259 b 201 -263 349 242 204 -258 b 182 -273 197 -270 190 -273 b 163 -260 174 -273 166 -269 b 161 -256 161 -259 161 -258 b 217 -59 161 -248 170 -220 b 272 129 247 43 272 127 b 272 129 272 129 272 129 b 264 122 272 129 268 126 b 140 80 227 94 183 80 b 36 115 102 80 65 91 b 0 194 10 136 0 165 b 88 302 0 244 32 292 "},"va9":{"x_min":-24.5,"x_max":314.421875,"ha":321,"o":"m -24 -145 l -24 -5 l -20 -5 b 0 -23 -9 -5 -2 -12 b 27 -87 4 -38 14 -66 b 138 -220 53 -136 88 -177 b 235 -328 179 -255 208 -288 b 314 -592 287 -409 314 -501 b 292 -732 314 -639 307 -687 l 289 -742 l 294 -756 b 314 -896 307 -802 314 -849 b 292 -1035 314 -943 307 -991 l 289 -1045 l 294 -1057 b 314 -1197 307 -1104 314 -1152 b 292 -1338 314 -1246 307 -1292 l 289 -1347 l 294 -1360 b 314 -1500 307 -1407 314 -1454 b 273 -1689 314 -1565 300 -1628 b 250 -1712 265 -1710 261 -1712 b 228 -1691 236 -1712 228 -1704 l 228 -1685 l 234 -1675 b 270 -1507 258 -1621 270 -1564 b 98 -1193 270 -1381 209 -1261 b 40 -1174 76 -1179 58 -1174 b -10 -1189 24 -1174 8 -1178 b -20 -1192 -14 -1192 -16 -1192 l -24 -1192 l -24 -1052 l -24 -913 l -20 -913 b 0 -931 -9 -913 -2 -920 b 27 -995 4 -946 14 -974 b 138 -1128 53 -1043 88 -1085 b 257 -1275 190 -1172 228 -1220 b 262 -1283 259 -1279 262 -1283 l 262 -1283 b 269 -1249 264 -1282 268 -1260 b 270 -1206 270 -1233 270 -1220 b 98 -891 270 -1075 206 -957 b 40 -871 76 -877 58 -871 b -10 -886 24 -871 8 -875 b -20 -889 -14 -889 -16 -889 l -24 -889 l -24 -749 l -24 -610 l -20 -610 b 0 -628 -9 -610 -2 -617 b 27 -692 4 -644 14 -671 b 138 -825 53 -741 88 -782 b 257 -973 190 -870 228 -917 b 262 -981 259 -977 262 -981 l 262 -981 b 269 -946 264 -979 268 -957 b 270 -903 270 -931 270 -917 b 98 -588 270 -774 206 -655 b 40 -569 76 -574 58 -569 b -10 -584 24 -569 8 -574 b -20 -587 -14 -587 -16 -587 l -24 -587 l -24 -448 l -24 -308 l -20 -308 b 0 -326 -9 -308 -2 -315 b 27 -390 4 -341 14 -369 b 138 -523 53 -438 88 -480 b 257 -670 190 -567 228 -614 b 262 -678 259 -674 262 -678 b 262 -678 262 -678 262 -678 b 269 -644 264 -677 268 -656 b 270 -601 270 -628 270 -614 b 98 -285 270 -471 206 -352 b 40 -266 76 -273 58 -266 b -10 -281 24 -266 8 -272 b -20 -284 -14 -284 -16 -284 l -24 -284 l -24 -145 "},"vaa":{"x_min":-1.359375,"x_max":752.703125,"ha":768,"o":"m 490 985 b 504 986 495 986 500 986 b 604 907 551 986 593 954 b 607 884 607 900 607 892 b 581 813 607 857 597 831 l 578 810 l 583 811 b 710 932 638 827 687 873 b 714 943 711 936 713 942 b 730 952 720 949 725 952 b 752 931 741 952 752 943 b 200 -946 752 927 204 -941 b 182 -957 197 -953 190 -957 b 163 -945 174 -957 166 -953 b 161 -939 161 -942 161 -942 b 217 -743 161 -931 170 -904 b 272 -555 247 -639 272 -555 b 272 -555 272 -555 272 -555 b 264 -560 272 -555 268 -557 b 140 -603 227 -589 182 -603 b 36 -567 102 -603 65 -592 b -1 -487 12 -548 -1 -517 b 17 -427 -1 -466 5 -445 b 103 -380 38 -395 70 -380 b 191 -433 137 -380 172 -398 b 205 -484 201 -448 205 -466 b 178 -553 205 -509 196 -535 l 175 -557 l 182 -555 b 307 -435 236 -539 284 -494 b 372 -213 308 -430 372 -215 b 372 -213 372 -213 372 -213 b 364 -219 372 -213 368 -216 b 240 -262 328 -247 283 -262 b 137 -226 202 -262 166 -249 b 99 -145 112 -206 99 -176 b 118 -84 99 -124 106 -104 b 204 -38 138 -54 171 -38 b 292 -91 238 -38 273 -56 b 306 -141 302 -106 306 -124 b 279 -212 306 -167 296 -194 l 276 -215 l 281 -213 b 408 -93 336 -198 385 -151 b 473 129 409 -88 473 127 b 473 129 473 129 473 129 b 465 122 473 129 469 126 b 341 80 428 94 383 80 b 236 115 303 80 266 91 b 200 195 213 136 200 165 b 217 256 200 217 206 238 b 304 303 239 287 272 303 b 393 249 338 303 374 285 b 406 199 402 234 406 217 b 379 129 406 173 397 148 l 377 126 l 382 127 b 509 248 436 142 485 190 b 574 470 510 254 574 469 b 574 470 574 470 574 470 b 566 464 574 470 570 467 b 442 421 529 435 484 421 b 337 458 404 421 367 433 b 300 538 314 477 300 508 b 318 598 300 559 306 580 b 404 645 340 630 372 645 b 494 592 439 645 475 627 b 507 541 502 577 507 559 b 480 471 507 516 498 489 l 477 467 l 483 470 b 608 589 537 485 586 531 b 675 811 611 595 675 810 b 675 811 675 811 675 811 b 666 806 675 811 671 809 b 543 763 628 777 585 763 b 438 799 504 763 468 775 b 401 878 412 820 401 849 b 490 985 401 928 434 977 "},"vab":{"x_min":0,"x_max":272.21875,"ha":278,"o":"m 243 631 b 250 632 246 632 249 632 b 270 620 259 632 268 628 l 272 616 l 272 201 l 272 -212 l 270 -216 b 251 -229 268 -224 259 -229 b 227 -215 243 -229 240 -229 l 151 -142 b 32 -16 81 -80 53 -49 b 0 84 9 18 0 52 b 111 199 0 149 42 199 b 137 197 119 199 127 198 b 228 151 168 191 197 177 l 231 148 l 231 383 b 232 620 231 616 231 616 b 243 631 234 624 238 630 m 168 131 b 152 133 163 133 157 133 b 107 102 130 133 111 120 b 106 86 107 97 106 91 b 111 41 106 73 108 56 b 227 -152 125 -13 171 -90 l 231 -156 l 231 -37 l 231 80 l 225 87 b 168 131 210 111 190 126 "},"vad":{"x_min":0,"x_max":873.828125,"ha":892,"o":"m 0 0 l 0 703 l 81 703 l 164 703 l 164 0 l 164 -705 l 81 -705 l 0 -705 l 0 0 m 225 0 l 225 703 l 246 703 l 268 703 l 268 366 l 268 30 l 274 36 b 314 79 284 44 302 63 b 413 302 357 137 392 213 b 432 327 419 324 421 327 b 449 306 443 327 447 322 b 611 115 457 195 529 115 b 651 122 624 115 638 117 b 728 316 705 140 724 188 b 729 388 728 342 729 366 b 671 635 729 533 711 602 b 581 662 649 652 616 662 b 477 637 545 662 510 653 l 475 635 l 477 634 b 503 627 488 632 495 631 b 545 556 532 612 545 584 b 491 480 545 524 526 491 b 465 474 481 476 473 474 b 379 563 417 474 379 516 b 389 602 379 576 382 588 b 541 691 409 641 479 681 b 582 694 555 692 568 694 b 865 462 714 694 834 598 b 873 392 871 440 873 416 b 865 317 873 367 871 341 b 639 84 839 194 748 101 b 612 83 630 83 620 83 b 511 116 577 83 543 94 b 504 120 509 119 506 120 b 504 120 504 120 504 120 b 469 59 504 120 488 93 l 432 -1 l 469 -61 b 504 -122 488 -94 504 -122 b 504 -122 504 -122 504 -122 b 511 -117 506 -122 509 -120 b 612 -84 543 -95 577 -84 b 665 -91 630 -84 647 -87 b 869 -338 771 -122 850 -216 b 873 -392 872 -356 873 -374 b 798 -595 873 -469 847 -539 b 581 -695 741 -662 660 -695 b 406 -626 517 -695 454 -671 b 381 -563 389 -607 381 -585 b 465 -477 381 -519 413 -477 b 545 -559 514 -477 545 -519 b 503 -628 545 -587 532 -613 b 477 -635 495 -632 488 -634 l 475 -637 l 477 -638 b 581 -663 510 -655 545 -663 b 671 -637 616 -663 649 -653 b 729 -391 711 -603 729 -534 b 728 -317 729 -367 728 -344 b 623 -117 722 -173 698 -124 b 611 -116 619 -116 615 -116 b 449 -308 528 -116 457 -198 b 432 -328 447 -323 443 -328 b 413 -303 421 -328 419 -326 b 314 -80 392 -215 357 -138 b 274 -37 302 -65 284 -45 l 268 -31 l 268 -367 l 268 -705 l 246 -705 l 225 -705 l 225 0 "},"vb1":{"x_min":78.9375,"x_max":485.921875,"ha":417,"o":"m 362 378 b 378 380 367 380 372 380 b 472 348 415 380 453 367 b 485 315 481 338 485 327 b 462 273 485 298 477 281 b 439 267 454 269 446 267 b 398 290 424 267 409 274 b 344 319 385 309 364 319 b 281 269 315 319 289 301 b 279 262 280 266 279 262 b 276 256 279 260 277 258 b 274 249 276 254 274 251 b 238 127 273 248 257 192 b 201 4 217 61 201 5 b 166 -1 198 -1 200 -1 b 153 -1 163 -1 157 -1 b 141 -1 148 -1 144 -1 b 104 4 106 -1 107 -1 b 104 6 104 5 104 5 b 142 144 104 13 110 34 b 182 278 164 219 181 276 b 183 288 182 281 182 285 b 185 302 185 292 185 298 b 164 330 185 317 176 328 b 159 330 163 330 161 330 b 102 302 140 330 119 320 b 91 294 95 295 93 294 b 88 294 91 294 89 294 b 78 303 83 294 78 298 b 81 312 78 306 78 309 b 200 373 106 347 160 373 b 215 371 205 373 209 371 b 266 335 235 367 254 353 b 269 331 268 333 269 331 b 269 331 269 331 269 331 b 273 335 269 331 270 334 b 362 378 298 359 330 376 "},"vb3":{"x_min":0,"x_max":227.3125,"ha":232,"o":"m 91 213 b 100 215 93 215 96 215 b 227 58 167 215 224 144 b 227 52 227 56 227 54 b 61 -201 227 -43 164 -138 b 29 -216 44 -212 36 -216 b 23 -210 27 -216 24 -213 b 21 -205 21 -208 21 -206 b 34 -192 21 -201 25 -197 b 122 -55 89 -161 122 -106 b 104 6 122 -33 117 -12 l 103 9 l 96 9 b 4 79 57 9 17 38 b 0 112 1 90 0 101 b 91 213 0 163 36 209 "},"vb4":{"x_min":-597.53125,"x_max":596.171875,"ha":608,"o":"m -533 324 b -525 327 -530 326 -528 327 b -504 305 -514 327 -504 317 b -504 305 -504 305 -504 305 b -513 284 -504 299 -504 299 b -556 112 -541 226 -556 167 b -545 33 -556 84 -552 58 b -524 -20 -541 15 -532 -9 l -522 -23 l -491 15 l -413 111 b -355 174 -367 169 -363 174 b -351 174 -353 174 -352 174 b -254 86 -343 174 -348 179 b -168 -1 -208 37 -168 -1 b -100 84 -168 -1 -137 37 b -23 173 -28 173 -29 172 b -19 174 -21 174 -20 174 b -8 173 -14 174 -10 173 b 80 86 -5 172 13 151 b 166 -1 127 37 166 -1 b 235 84 166 -1 197 37 b 311 173 306 173 304 172 b 317 174 313 174 314 174 b 326 173 319 174 323 173 b 490 11 329 172 366 134 l 502 -1 l 530 34 b 568 76 560 72 563 74 b 575 77 570 77 573 77 b 596 56 586 77 596 68 b 594 48 596 54 596 51 b 417 -172 592 41 424 -166 b 405 -176 415 -174 409 -176 b 396 -174 401 -176 398 -176 b 307 -87 393 -173 372 -152 b 221 -1 259 -38 221 -1 b 152 -86 221 -1 190 -38 b 76 -176 81 -174 83 -173 b 70 -176 74 -176 73 -176 b 61 -174 66 -176 62 -174 b -27 -87 58 -173 38 -152 b -114 -1 -74 -38 -112 -1 b -182 -86 -114 -1 -145 -38 b -258 -176 -253 -174 -253 -173 b -264 -176 -259 -176 -262 -176 b -274 -174 -268 -176 -272 -174 b -438 -11 -277 -173 -348 -102 l -449 0 l -479 -37 b -524 -80 -513 -80 -514 -80 l -524 -80 b -553 -52 -534 -80 -540 -74 b -597 109 -583 -8 -597 48 b -560 280 -597 165 -585 224 b -533 324 -548 310 -540 322 "},"vb6":{"x_min":0,"x_max":556.6875,"ha":568,"o":"m 289 545 b 298 546 292 545 295 546 b 318 533 306 546 315 541 b 319 428 319 530 319 528 l 319 327 l 334 327 b 526 223 412 326 485 285 b 543 172 537 206 543 190 b 447 76 543 122 503 76 b 445 76 446 76 446 76 b 359 165 394 77 359 119 b 368 205 359 179 362 192 b 441 251 382 233 412 251 b 455 249 446 251 451 251 b 460 248 458 249 460 248 b 460 248 460 248 460 248 b 454 254 460 249 458 251 b 334 295 419 280 378 294 l 319 295 l 319 4 l 319 -287 l 321 -285 b 328 -285 322 -285 325 -285 b 524 -99 424 -277 507 -198 b 541 -79 526 -84 530 -79 b 556 -97 551 -79 556 -84 b 548 -133 556 -105 553 -117 b 334 -317 521 -233 434 -306 b 322 -319 329 -317 323 -317 l 319 -319 l 319 -424 b 319 -471 319 -444 319 -459 b 313 -541 319 -544 318 -535 b 298 -548 308 -545 303 -548 b 279 -534 289 -548 281 -542 b 277 -424 277 -531 277 -530 l 277 -317 l 273 -317 b 13 -95 153 -305 51 -217 b 0 2 4 -62 0 -29 b 182 295 0 126 66 238 b 274 324 210 309 249 320 l 277 324 l 277 427 b 279 533 277 528 277 530 b 289 545 281 538 285 542 m 277 2 b 277 291 277 161 277 291 b 268 288 277 291 273 290 b 144 1 179 265 144 184 b 276 -284 144 -199 175 -267 l 277 -285 l 277 2 "},"vb9":{"x_min":-122.5,"x_max":121.140625,"ha":124,"o":"m -16 145 b 0 147 -10 147 -5 147 b 121 -1 66 147 121 77 b 114 -49 121 -16 118 -33 b -1 -148 95 -112 47 -148 b -85 -106 -31 -148 -61 -134 b -122 -1 -110 -76 -122 -38 b -16 145 -122 68 -81 134 m 12 111 b 0 113 8 113 4 113 b -68 22 -29 113 -61 73 b -70 0 -69 15 -70 6 b -13 -113 -70 -49 -47 -98 b -1 -115 -9 -115 -5 -115 b 63 -40 24 -115 53 -83 b 68 -1 66 -27 68 -15 b 12 111 68 48 46 97 "},"vba":{"x_min":-118.421875,"x_max":597.53125,"ha":381,"o":"m 460 574 b 464 574 461 574 462 574 b 488 574 470 574 481 574 b 500 573 491 574 498 574 b 594 503 543 570 588 538 b 597 488 596 498 597 494 b 528 417 597 449 564 417 b 502 423 519 417 510 419 b 465 481 477 434 465 458 b 488 528 465 499 472 516 b 490 530 490 530 490 530 b 490 530 490 530 490 530 b 468 517 488 530 475 523 b 349 340 419 485 377 420 b 347 330 348 334 347 330 b 383 328 347 328 363 328 b 428 326 423 328 424 328 b 442 302 438 320 442 312 b 430 281 442 294 438 285 b 385 276 424 277 426 276 l 377 276 l 332 276 l 330 269 b 178 -117 303 126 250 -9 b 1 -249 129 -194 69 -237 b -20 -251 -6 -251 -13 -251 b -114 -187 -65 -251 -100 -227 b -118 -156 -117 -177 -118 -166 b -51 -84 -118 -116 -91 -84 b -31 -87 -46 -84 -39 -86 b 16 -152 0 -95 16 -124 b -12 -205 16 -173 8 -194 b -16 -208 -14 -206 -16 -208 b -14 -208 -16 -208 -14 -208 b -9 -206 -14 -208 -12 -208 b 74 -124 23 -197 54 -166 b 172 224 98 -79 125 22 b 185 276 178 252 183 274 b 185 276 185 276 185 276 b 141 276 185 276 181 276 b 91 280 96 276 96 276 b 77 302 83 285 77 294 b 91 326 77 312 83 320 b 148 328 95 328 96 328 l 198 330 l 202 341 b 460 574 249 473 351 566 "},"vbf":{"x_min":-53.078125,"x_max":513.140625,"ha":485,"o":"m 185 383 b 196 384 187 383 191 384 b 277 334 230 384 259 365 b 288 301 281 324 288 306 b 288 297 288 298 288 297 b 294 302 289 297 291 299 b 394 370 323 338 367 367 b 404 371 398 370 401 371 b 510 272 453 371 498 328 b 513 237 513 262 513 251 b 507 172 513 217 511 192 b 326 -34 487 59 412 -26 b 314 -36 322 -36 318 -36 b 274 -24 298 -36 283 -31 l 265 -16 b 224 44 246 -1 232 20 b 223 49 224 47 223 49 b 223 49 223 49 223 49 b 149 -197 221 48 149 -194 b 149 -198 149 -197 149 -198 b 170 -210 149 -202 155 -205 b 187 -215 174 -210 175 -212 b 204 -231 201 -219 204 -222 b 197 -245 204 -240 202 -242 l 194 -248 l 76 -248 l -42 -248 l -46 -245 b -53 -231 -51 -242 -53 -240 b -35 -215 -53 -222 -49 -217 b -13 -210 -21 -212 -20 -212 b -6 -208 -10 -209 -8 -208 b 0 -206 -6 -208 -2 -206 b 25 -188 13 -201 21 -195 b 163 280 28 -183 163 276 b 166 291 163 283 164 287 b 167 302 167 295 167 299 b 155 324 167 315 161 324 b 155 324 155 324 155 324 b 65 230 125 322 85 280 b 53 215 61 217 58 215 b 51 215 53 215 51 215 b 42 224 46 215 42 217 b 57 263 42 231 47 244 b 140 360 77 305 104 337 b 152 370 144 365 149 369 b 185 383 157 376 172 381 m 374 306 b 366 308 371 308 368 308 b 300 273 348 308 321 294 b 284 254 288 262 287 259 b 280 242 283 249 281 245 b 257 169 279 240 270 213 l 236 98 l 236 93 b 251 48 238 77 243 61 b 279 27 258 37 272 27 b 281 27 279 27 280 27 b 291 31 281 27 287 30 b 396 170 334 52 378 109 b 406 247 402 197 406 224 b 401 277 406 259 405 270 b 374 306 397 290 383 303 "},"vc3":{"x_min":-10.890625,"x_max":299.4375,"ha":294,"o":"m 136 460 b 142 462 137 462 140 462 b 166 449 152 462 161 456 b 171 428 168 446 168 445 b 288 131 194 322 238 209 b 298 115 295 120 296 117 b 299 106 298 112 299 109 b 273 81 299 91 287 81 b 255 86 268 81 261 83 b 155 116 225 104 183 116 l 152 116 l 149 108 b 141 83 148 102 144 91 b 134 48 137 69 134 58 b 149 9 134 34 140 24 b 153 -1 152 5 153 1 b 149 -9 153 -5 152 -6 b 144 -11 148 -11 147 -11 b 122 2 138 -11 133 -6 b 95 61 104 20 95 38 b 107 108 95 74 99 90 b 108 113 107 111 108 112 b 107 113 108 113 108 113 b 102 113 106 113 104 113 b 31 86 76 108 53 98 b 14 80 24 81 20 80 b -10 106 0 80 -10 91 b 0 131 -10 115 -9 116 b 115 430 49 209 91 317 b 136 460 119 451 123 456 "}},"cssFontWeight":"normal","ascender":1903,"underlinePosition":-125,"cssFontStyle":"normal","boundingBox":{"yMin":-2065.375,"xMin":-695.53125,"yMax":1901.578125,"xMax":1159.671875},"resolution":1000,"descender":-2066,"familyName":"VexFlow-18","lineHeight":4093,"underlineThickness":50};
// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Muthanna 2010
//
// Requires a glyph font to be loaded and Vex.Flow.Font to be set.

/**
 * A quick and dirty static glyph renderer. Renders glyphs from the default
 * font defined in Vex.Flow.Font.
 *
 * @param {!Object} ctx The canvas context.
 * @param {number} x_pos X coordinate.
 * @param {number} y_pos Y coordinate.
 * @param {number} point The point size to use.
 * @param {string} val The glyph code in Vex.Flow.Font.
 * @param {boolean} nocache If set, disables caching of font outline.
 */
Vex.Flow.renderGlyph = function(ctx, x_pos, y_pos, point, val, nocache) {
  var scale = point * 72.0 / (Vex.Flow.Font.resolution * 100.0);
  var metrics = Vex.Flow.Glyph.loadMetrics(Vex.Flow.Font, val, !nocache);
  Vex.Flow.Glyph.renderOutline(ctx, metrics.outline, scale, x_pos, y_pos);
};

/**
 * @constructor
 */
Vex.Flow.Glyph = (function() {
  function Glyph(code, point, options) {
    this.code = code;
    this.point = point;
    this.context = null;
    this.options = {
      cache: true,
      font: Vex.Flow.Font
    };

    this.width = null;
    this.metrics = null;
    this.x_shift = 0;
    this.y_shift = 0;

    if (options) this.setOptions(options); else this.reset();
  }

  Glyph.prototype = {
    setOptions: function(options) {
      Vex.Merge(this.options, options);
      this.reset();
    },

    setStave: function(stave) { this.stave = stave; return this; },
    setXShift: function(x_shift) { this.x_shift = x_shift; return this; },
    setYShift: function(y_shift) { this.y_shift = y_shift; return this; },
    setContext: function(context) { this.context = context; return this; },
    getContext: function() { return this.context; },

    reset: function() {
      this.metrics = Vex.Flow.Glyph.loadMetrics(this.options.font, this.code,
          this.options.cache);
      this.scale = this.point * 72 / (this.options.font.resolution * 100);
    },

    setWidth: function(width) {
      this.width =  width;
      return this;
    },

    getMetrics: function() {
      if (!this.metrics) throw new Vex.RuntimeError("BadGlyph", "Glyph " +
          this.code + " is not initialized.");
      return {
        x_min: this.metrics.x_min * this.scale,
        x_max: this.metrics.x_max * this.scale,
        width: this.width || (this.metrics.x_max - this.metrics.x_min) * this.scale,
        height: this.metrics.ha * this.scale
      };
    },

    render: function(ctx, x_pos, y_pos) {
      if (!this.metrics) throw new Vex.RuntimeError("BadGlyph", "Glyph " +
          this.code + " is not initialized.");

      var outline = this.metrics.outline;
      var scale = this.scale;

      Glyph.renderOutline(ctx, outline, scale, x_pos, y_pos);
    },

    renderToStave: function(x) {
      if (!this.metrics) throw new Vex.RuntimeError("BadGlyph", "Glyph " +
          this.code + " is not initialized.");
      if (!this.stave) throw new Vex.RuntimeError("GlyphError", "No valid stave");
      if (!this.context) throw new Vex.RERR("GlyphError", "No valid context");

      var outline = this.metrics.outline;
      var scale = this.scale;

      Glyph.renderOutline(this.context, outline, scale,
          x + this.x_shift, this.stave.getYForGlyphs() + this.y_shift);
    }
  };

  /* Static methods used to implement loading / unloading of glyphs */
  Glyph.loadMetrics = function(font, code, cache) {
    var glyph = font.glyphs[code];
    if (!glyph) throw new Vex.RuntimeError("BadGlyph", "Glyph " + code +
        " does not exist in font.");

    var x_min = glyph.x_min;
    var x_max = glyph.x_max;
    var ha = glyph.ha;

    var outline;

    if (glyph.o) {
      if (cache) {
        if (glyph.cached_outline) {
          outline = glyph.cached_outline;
        } else {
          outline = glyph.o.split(' ');
          glyph.cached_outline = outline;
        }
      } else {
        if (glyph.cached_outline) delete glyph.cached_outline;
        outline = glyph.o.split(' ');
      }

      return {
        x_min: x_min,
        x_max: x_max,
        ha: ha,
        outline: outline
      };
    } else {
      throw new Vex.RuntimeError("BadGlyph", "Glyph " + this.code +
          " has no outline defined.");
    }
  };

  Glyph.renderOutline = function(ctx, outline, scale, x_pos, y_pos) {
    var outlineLength = outline.length;

    ctx.beginPath();

    ctx.moveTo(x_pos, y_pos);

    for (var i = 0; i < outlineLength; ) {
      var action = outline[i++];

      switch(action) {
        case 'm':
          ctx.moveTo(x_pos + outline[i++] * scale,
                     y_pos + outline[i++] * -scale);
          break;
        case 'l':
          ctx.lineTo(x_pos + outline[i++] * scale,
                     y_pos + outline[i++] * -scale);
          break;

        case 'q':
          var cpx = x_pos + outline[i++] * scale;
          var cpy = y_pos + outline[i++] * -scale;

          ctx.quadraticCurveTo(
              x_pos + outline[i++] * scale,
              y_pos + outline[i++] * -scale, cpx, cpy);
          break;

        case 'b':
          var x = x_pos + outline[i++] * scale;
          var y = y_pos + outline[i++] * -scale;

          ctx.bezierCurveTo(
              x_pos + outline[i++] * scale, y_pos + outline[i++] * -scale,
              x_pos + outline[i++] * scale, y_pos + outline[i++] * -scale,
              x, y);
          break;
      }
    }
    ctx.fill();
  };

  return Glyph;
}());

// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Cheppudira 2010

/** @constructor */
Vex.Flow.Stave = (function() {
  function Stave(x, y, width, options) {
    if (arguments.length > 0) this.init(x, y, width, options);
  }

  var THICKNESS = (Vex.Flow.STAVE_LINE_THICKNESS > 1 ?
        Vex.Flow.STAVE_LINE_THICKNESS : 0);
  Stave.prototype = {
    init: function(x, y, width, options) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.glyph_start_x = x + 5;
      this.glyph_end_x = x + width;
      this.start_x = this.glyph_start_x;
      this.end_x = this.glyph_end_x;
      this.context = null;
      this.glyphs = [];
      this.end_glyphs = [];
      this.modifiers = [];  // non-glyph stave items (barlines, coda, segno, etc.)
      this.measure = 0;
      this.clef = "treble";
      this.font = {
        family: "sans-serif",
        size: 8,
        weight: ""
      };
      this.options = {
        vertical_bar_width: 10,       // Width around vertical bar end-marker
        glyph_spacing_px: 10,
        num_lines: 5,
        fill_style: "#999999",
        spacing_between_lines_px: 10, // in pixels
        space_above_staff_ln: 4,      // in staff lines
        space_below_staff_ln: 4,      // in staff lines
        top_text_position: 1          // in staff lines
      };
      this.bounds = {x: this.x, y: this.y, w: this.width, h: 0};
      Vex.Merge(this.options, options);

      this.resetLines();

      this.modifiers.push(
          new Vex.Flow.Barline(Vex.Flow.Barline.type.SINGLE, this.x)); // beg bar
      this.modifiers.push(
          new Vex.Flow.Barline(Vex.Flow.Barline.type.SINGLE,
          this.x + this.width)); // end bar
    },

    resetLines: function() {
      this.options.line_config = [];
      for (var i = 0; i < this.options.num_lines; i++) {
        this.options.line_config.push({visible: true});
      }
      this.height = (this.options.num_lines + this.options.space_above_staff_ln) *
         this.options.spacing_between_lines_px;
      this.options.bottom_text_position = this.options.num_lines + 1;
    },

    setNoteStartX: function(x) { this.start_x = x; return this; },
    getNoteStartX: function() {
      var start_x = this.start_x;

      // Add additional space if left barline is REPEAT_BEGIN and there are other
      // start modifiers than barlines
      if (this.modifiers[0].barline == Vex.Flow.Barline.type.REPEAT_BEGIN &&
          this.modifiers.length > 2) {
        start_x += 20;
      }

      return start_x;
    },

    getNoteEndX: function() { return this.end_x; },
    getTieStartX: function() { return this.start_x; },
    getTieEndX: function() { return this.x + this.width; },
    setContext: function(context) {
      this.context = context;
	for(var i=0; i<this.glyphs.length; i++){
          if(typeof(this.glyphs[i].setContext) === "function"){
	    this.glyphs[i].setContext(context);
          }
	}
      return this;
    },
    getContext: function() { return this.context; },
    getX: function() { return this.x; },
    getNumLines: function() { return this.options.num_lines; },
    setNumLines: function(lines) {
      this.options.num_lines = parseInt(lines, 10);
      this.resetLines();
      return this;
    },
    setY: function(y) { this.y = y; return this; },

    setX: function(x){
      var shift = x - this.x;
      this.x = x;
      this.glyph_start_x += shift;
      this.glyph_end_x += shift;
      this.start_x += shift;
      this.end_x += shift;
      for(var i=0; i<this.modifiers.length; i++) {
      	var mod = this.modifiers[i];
        if (mod.x !== undefined) {
          mod.x += shift;
      	}
      }
      return this;
    },

    setWidth: function(width) {
      this.width = width;
      this.glyph_end_x = this.x + width;
      this.end_x = this.glyph_end_x;

      // reset the x position of the end barline (TODO(0xfe): This makes no sense)
      // this.modifiers[1].setX(this.end_x);
      return this;
    },

    getWidth: function() {
      return this.width;
    },

    setMeasure: function(measure) { this.measure = measure; return this; },

      // Bar Line functions
    setBegBarType: function(type) {
      // Only valid bar types at beginning of stave is none, single or begin repeat
      if (type == Vex.Flow.Barline.type.SINGLE ||
          type == Vex.Flow.Barline.type.REPEAT_BEGIN ||
          type == Vex.Flow.Barline.type.NONE) {
          this.modifiers[0] = new Vex.Flow.Barline(type, this.x);
      }
      return this;
    },

    setEndBarType: function(type) {
      // Repeat end not valid at end of stave
      if (type != Vex.Flow.Barline.type.REPEAT_BEGIN)
        this.modifiers[1] = new Vex.Flow.Barline(type, this.x + this.width);
      return this;
    },

    /**
     * Gets the pixels to shift from the beginning of the stave
     * following the modifier at the provided index
     * @param  {Number} index The index from which to determine the shift
     * @return {Number}       The amount of pixels shifted
     */
    getModifierXShift: function(index) {
      if (typeof index === 'undefined') index = this.glyphs.length -1;
      if (typeof index !== 'number') new Vex.RERR("InvalidIndex",
        "Must be of number type");

      var x = this.glyph_start_x;
      var bar_x_shift = 0;

      for (var i = 0; i < index + 1; ++i) {
        var glyph = this.glyphs[i];
        x += glyph.getMetrics().width;
        bar_x_shift += glyph.getMetrics().width;
      }

      // Add padding after clef, time sig, key sig
      if (bar_x_shift > 0) bar_x_shift += this.options.vertical_bar_width + 10;

      return bar_x_shift;
    },

    // Coda & Segno Symbol functions
    setRepetitionTypeLeft: function(type, y) {
      this.modifiers.push(new Vex.Flow.Repetition(type, this.x, y));
      return this;
    },

    setRepetitionTypeRight: function(type, y) {
      this.modifiers.push(new Vex.Flow.Repetition(type, this.x, y) );
      return this;
    },

    // Volta functions
    setVoltaType: function(type, number_t, y) {
      this.modifiers.push(new Vex.Flow.Volta(type, number_t, this.x, y));
      return this;
    },

    // Section functions
    setSection: function(section, y) {
      this.modifiers.push(new Vex.Flow.StaveSection(section, this.x, y));
      return this;
    },

    // Tempo functions
    setTempo: function(tempo, y) {
      this.modifiers.push(new Vex.Flow.StaveTempo(tempo, this.x, y));
      return this;
    },

    // Text functions
    setText: function(text, position, options) {
      this.modifiers.push(new Vex.Flow.StaveText(text, position, options));
      return this;
    },

    getHeight: function() {
      return this.height;
    },

    getSpacingBetweenLines: function() {
      return this.options.spacing_between_lines_px;
    },

    getBoundingBox: function() {
      return new Vex.Flow.BoundingBox(this.x, this.y, this.width, this.getBottomY() - this.y);
      // body...
    },

    getBottomY: function() {
      var options = this.options;
      var spacing = options.spacing_between_lines_px;
      var score_bottom = this.getYForLine(options.num_lines) +
         (options.space_below_staff_ln * spacing);

      return score_bottom;
    },

    getBottomLineY: function() {
      return this.getYForLine(this.options.num_lines);
    },

    getYForLine: function(line) {
      var options = this.options;
      var spacing = options.spacing_between_lines_px;
      var headroom = options.space_above_staff_ln;

      var y = this.y + ((line * spacing) + (headroom * spacing)) -
        (THICKNESS / 2);

      return y;
    },

    getYForTopText: function(line) {
      var l = line || 0;
      return this.getYForLine(-l - this.options.top_text_position);
    },

    getYForBottomText: function(line) {
      var l = line || 0;
      return this.getYForLine(this.options.bottom_text_position + l);
    },

    getYForNote: function(line) {
      var options = this.options;
      var spacing = options.spacing_between_lines_px;
      var headroom = options.space_above_staff_ln;
      var y = this.y + (headroom * spacing) + (5 * spacing) - (line * spacing);

      return y;
    },

    getYForGlyphs: function() {
      return this.getYForLine(3);
    },

    addGlyph: function(glyph) {
      glyph.setStave(this);
      this.glyphs.push(glyph);
      this.start_x += glyph.getMetrics().width;
      return this;
    },

    addEndGlyph: function(glyph) {
      glyph.setStave(this);
      this.end_glyphs.push(glyph);
      this.end_x -= glyph.getMetrics().width;
      return this;
    },

    addModifier: function(modifier) {
      this.modifiers.push(modifier);
      modifier.addToStave(this, (this.glyphs.length === 0));
      return this;
    },

    addEndModifier: function(modifier) {
      this.modifiers.push(modifier);
      modifier.addToStaveEnd(this, (this.end_glyphs.length === 0));
      return this;
    },

    addKeySignature: function(keySpec) {
      this.addModifier(new Vex.Flow.KeySignature(keySpec));
      return this;
    },

    addClef: function(clef, size, annotation) {
      this.clef = clef;
      this.addModifier(new Vex.Flow.Clef(clef, size, annotation));
      return this;
    },

    addEndClef: function(clef, size, annotation) {
      this.addEndModifier(new Vex.Flow.Clef(clef, size, annotation));
      return this;
    },

    addTimeSignature: function(timeSpec, customPadding) {
      this.addModifier(new Vex.Flow.TimeSignature(timeSpec, customPadding));
      return this;
    },

    addEndTimeSignature: function(timeSpec, customPadding) {
      this.addEndModifier(new Vex.Flow.TimeSignature(timeSpec, customPadding));
    },

    addTrebleGlyph: function() {
      this.clef = "treble";
      this.addGlyph(new Vex.Flow.Glyph("v83", 40));
      return this;
    },

    /**
     * All drawing functions below need the context to be set.
     */
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var num_lines = this.options.num_lines;
      var width = this.width;
      var x = this.x;
      var y;
      var glyph;

      // Render lines
      for (var line=0; line < num_lines; line++) {
        y = this.getYForLine(line);

        this.context.save();
        this.context.setFillStyle(this.options.fill_style);
        this.context.setStrokeStyle(this.options.fill_style);
        if (this.options.line_config[line].visible) {
          this.context.fillRect(x, y, width, Vex.Flow.STAVE_LINE_THICKNESS);
        }
        this.context.restore();
      }

      // Render glyphs
      x = this.glyph_start_x;
      for (var i = 0; i < this.glyphs.length; ++i) {
        glyph = this.glyphs[i];
        if (!glyph.getContext()) {
          glyph.setContext(this.context);
        }
        glyph.renderToStave(x);
        x += glyph.getMetrics().width;
      }

      // Render end glyphs
      x = this.glyph_end_x;
      for (i = 0; i < this.end_glyphs.length; ++i) {
        glyph = this.end_glyphs[i];
        if (!glyph.getContext()) {
          glyph.setContext(this.context);
        }
        x -= glyph.getMetrics().width;
        glyph.renderToStave(x);
      }

      // Draw the modifiers (bar lines, coda, segno, repeat brackets, etc.)
      for (i = 0; i < this.modifiers.length; i++) {
        // Only draw modifier if it has a draw function
        if (typeof this.modifiers[i].draw == "function")
          this.modifiers[i].draw(this, this.getModifierXShift());
      }

      // Render measure numbers
      if (this.measure > 0) {
        this.context.save();
        this.context.setFont(this.font.family, this.font.size, this.font.weight);
        var text_width = this.context.measureText("" + this.measure).width;
        y = this.getYForTopText(0) + 3;
        this.context.fillText("" + this.measure, this.x - text_width / 2, y);
        this.context.restore();
      }

      return this;
    },

    // Draw Simple barlines for backward compatability
    // Do not delete - draws the beginning bar of the stave
    drawVertical: function(x, isDouble) {
      this.drawVerticalFixed(this.x + x, isDouble);
    },

    drawVerticalFixed: function(x, isDouble) {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var top_line = this.getYForLine(0);
      var bottom_line = this.getYForLine(this.options.num_lines - 1);
      if (isDouble)
        this.context.fillRect(x - 3, top_line, 1, bottom_line - top_line + 1);
      this.context.fillRect(x, top_line, 1, bottom_line - top_line + 1);
    },

    drawVerticalBar: function(x) {
      this.drawVerticalBarFixed(this.x + x, false);
    },

    drawVerticalBarFixed: function(x) {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var top_line = this.getYForLine(0);
      var bottom_line = this.getYForLine(this.options.num_lines - 1);
      this.context.fillRect(x, top_line, 1, bottom_line - top_line + 1);
    },

    /**
     * Get the current configuration for the Stave.
     * @return {Array} An array of configuration objects.
     */
    getConfigForLines: function() {
      return this.options.line_config;
    },

    /**
     * Configure properties of the lines in the Stave
     * @param line_number The index of the line to configure.
     * @param line_config An configuration object for the specified line.
     * @throws Vex.RERR "StaveConfigError" When the specified line number is out of
     *   range of the number of lines specified in the constructor.
     */
    setConfigForLine: function(line_number, line_config) {
      if (line_number >= this.options.num_lines || line_number < 0) {
        throw new Vex.RERR("StaveConfigError",
          "The line number must be within the range of the number of lines in the Stave.");
      }
      if (!line_config.hasOwnProperty('visible')) {
        throw new Vex.RERR("StaveConfigError",
          "The line configuration object is missing the 'visible' property.");
      }
      if (typeof(line_config.visible) !== 'boolean') {
        throw new Vex.RERR("StaveConfigError",
          "The line configuration objects 'visible' property must be true or false.");
      }

      this.options.line_config[line_number] = line_config;

      return this;
    },

    /**
     * Set the staff line configuration array for all of the lines at once.
     * @param lines_configuration An array of line configuration objects.  These objects
     *   are of the same format as the single one passed in to setLineConfiguration().
     *   The caller can set null for any line config entry if it is desired that the default be used
     * @throws Vex.RERR "StaveConfigError" When the lines_configuration array does not have
     *   exactly the same number of elements as the num_lines configuration object set in
     *   the constructor.
     */
    setConfigForLines: function(lines_configuration) {
      if (lines_configuration.length !== this.options.num_lines) {
        throw new Vex.RERR("StaveConfigError",
          "The length of the lines configuration array must match the number of lines in the Stave");
      }

      // Make sure the defaults are present in case an incomplete set of
      //  configuration options were supplied.
      for (var line_config in lines_configuration) {
        // Allow 'null' to be used if the caller just wants the default for a particular node.
        if (!lines_configuration[line_config]) {
          lines_configuration[line_config] = this.options.line_config[line_config];
        }
        Vex.Merge(this.options.line_config[line_config], lines_configuration[line_config]);
      }

      this.options.line_config = lines_configuration;

      return this;
    }
  };

  return Stave;
}());

// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
// Spencer Hitchcock <spencerhitch@gmail.com>
// A superclass for staves, this will allow multiple instruments to be scored at once

/** @constructor */
Vex.Flow.StaveGroup = (function() {
  function StaveGroup(x, y, width, options) {
    if (arguments.length > 0) this.init(x, y, width, options);
  }

  StaveGroup.prototype = {
    init: function(x, y, width, options) {
      this.x = x;
      this.y = y;
      this.width = width;
      this.context = null;
      this.staves = [];
      this.font = {
        family: "sans-serif",
        size: 8,
        weight: ""
      };
      this.options = {
        spacing_between_staves_px: 60,
        space_above_stavegroup: 4,      // in staff lines
        space_below_stavegroup: 4      // in staff lines
      };
      this.bounds = {x: this.x, y: this.y, w: this.width, h: 0};
    //  Vex.Merge(this.options, options);

      this.resetStaves();
    },
    addStave: function() {
      var num_staves = this.staves.length;
      var width = this.width;
      var x = this.x;
      var y = this.getYForStave(num_staves);
      this.staves.push(new Vex.Flow.Stave(x,y,width));
      this.resetStaves();
    },

    getStave: function(i) {
        return this.staves[i];
    },

    resetStaves: function() {
      this.options.stave_config = [];
      for (var i = 0; i < this.staves.length; i++) {
        this.options.stave_config.push({visible: true});
      }
      this.height = (this.staves.length + this.options.space_above_stavegroup) *
         this.options.spacing_between_staves_px;
      this.options.bottom_text_position = this.staves.length + 1;
    },

    setContext: function(context) {
      this.context = context;
      for(var i=0; i<this.staves.length; i++){
            if(typeof(this.staves[i].setContext) === "function"){
          this.staves[i].setContext(context);
            }
      }
      return this;
    },
    getContext: function() { return this.context; },
    getX: function() { return this.x; },
    getNumStaves: function() { return this.staves.length; },
    setNumStaves: function(staves) {
      this.staves.length = parseInt(staves, 10);
      this.resetStaves();
      return this;
    },
    setY: function(y) { this.y = y; return this; },

    setX: function(x){
      var shift = x - this.x;
      this.x = x;
      for(var i=0; i<this.modifiers.length; i++) {
      	var mod = this.modifiers[i];
        if (mod.x !== undefined) {
          mod.x += shift;
      	}
      }
      return this;
    },

    setWidth: function(width) {
      this.width = width;

      // reset the x position of the end barline (TODO(0xfe): This makes no sense)
      // this.modifiers[1].setX(this.end_x);
      return this;
    },

    getWidth: function() {
      return this.width;
    },

    setMeasure: function(measure) { this.measure = measure; return this; },

    /**
     * Gets the pixels to shift from the beginning of the stave
     * following the modifier at the provided index
     * @param  {Number} index The index from which to determine the shift
     * @return {Number}       The amount of pixels shifted
     */
    getModifierXShift: function(index) {
      if (typeof index === 'undefined') index = this.glyphs.length -1;
      if (typeof index !== 'number') new Vex.RERR("InvalidIndex",
        "Must be of number type");

      var x = this.glyph_start_x;
      var bar_x_shift = 0;

      for (var i = 0; i < index + 1; ++i) {
        var glyph = this.glyphs[i];
        x += glyph.getMetrics().width;
        bar_x_shift += glyph.getMetrics().width;
      }

      // Add padding after clef, time sig, key sig
      if (bar_x_shift > 0) bar_x_shift += this.options.vertical_bar_width + 10;

      return bar_x_shift;
    },

    getHeight: function() {
      return this.height;
    },

    getSpacingBetweenStaves: function() {
      return this.options.spacing_between_staves_px;
    },

    getBottomY: function() {
      var options = this.options;
      var spacing = options.spacing_between_staves_px;
      var score_bottom = this.getYForLine(staves.length) +
         (options.space_below_staff_ln * spacing);

      return score_bottom;
    },

    getBottomStaveY: function() {
      return this.getYForStave(this.staves.length);
    },

    getYForStave: function(stave_index) {
      var options = this.options;
      var spacing = options.spacing_between_staves_px;

      var y = this.y + (stave_index * spacing);

      return y;
    },

    /**
     * All drawing functions below need the context to be set.
     */
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var num_staves = this.staves.length;

      // Render staves 
      for (var stave_index=0; stave_index < num_staves; stave_index++) {

        this.context.save();
        var stave = this.getStave(stave_index);
        console.log(stave);
        stave.draw();
        this.context.restore();
      }

      // Render measure numbers
//      if (this.measure > 0) {
//        this.context.save();
//        this.context.setFont(this.font.family, this.font.size, this.font.weight);
//        var text_width = this.context.measureText("" + this.measure).width;
//        y = this.getYForTopText(0) + 3;
//        this.context.fillText("" + this.measure, this.x - text_width / 2, y);
//        this.context.restore();
//      }

      return this;
    },

    /**
     * Get the current configuration for the Stave.
     * @return {Array} An array of configuration objects.
     */
//    getConfigForLines: function() {
//      return this.options.line_config;
//    },
//
//    /**
//     * Configure properties of the lines in the Stave
//     * @param line_number The index of the line to configure.
//     * @param line_config An configuration object for the specified line.
//     * @throws Vex.RERR "StaveConfigError" When the specified line number is out of
//     *   range of the number of lines specified in the constructor.
//     */
//    setConfigForLine: function(line_number, line_config) {
//      if (line_number >= this.options.num_lines || line_number < 0) {
//        throw new Vex.RERR("StaveConfigError",
//          "The line number must be within the range of the number of lines in the Stave.");
//      }
//      if (!line_config.hasOwnProperty('visible')) {
//        throw new Vex.RERR("StaveConfigError",
//          "The line configuration object is missing the 'visible' property.");
//      }
//      if (typeof(line_config.visible) !== 'boolean') {
//        throw new Vex.RERR("StaveConfigError",
//          "The line configuration objects 'visible' property must be true or false.");
//      }
//
//      this.options.line_config[line_number] = line_config;
//
//      return this;
//    },
//
//    /**
//     * Set the staff line configuration array for all of the lines at once.
//     * @param lines_configuration An array of line configuration objects.  These objects
//     *   are of the same format as the single one passed in to setLineConfiguration().
//     *   The caller can set null for any line config entry if it is desired that the default be used
//     * @throws Vex.RERR "StaveConfigError" When the lines_configuration array does not have
//     *   exactly the same number of elements as the num_lines configuration object set in
//     *   the constructor.
//     */
//    setConfigForLines: function(lines_configuration) {
//      if (lines_configuration.length !== this.options.num_lines) {
//        throw new Vex.RERR("StaveConfigError",
//          "The length of the lines configuration array must match the number of lines in the Stave");
//      }
//
//      // Make sure the defaults are present in case an incomplete set of
//      //  configuration options were supplied.
//      for (var line_config in lines_configuration) {
//        // Allow 'null' to be used if the caller just wants the default for a particular node.
//        if (!lines_configuration[line_config]) {
//          lines_configuration[line_config] = this.options.line_config[line_config];
//        }
//        Vex.Merge(this.options.line_config[line_config], lines_configuration[line_config]);
//      }
//
//      this.options.line_config = lines_configuration;
//
//      return this;
//    }
  };

  return StaveGroup;
}());

// Vex Flow Notation
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Muthanna 2010
//
// Requires vex.js.

/** @constructor */
Vex.Flow.StaveConnector = (function() {
  function StaveConnector(top_stave, bottom_stave) {
    this.init(top_stave, bottom_stave);
  }

  // SINGLE_LEFT and SINGLE are the same value for compatibility
  // with older versions of vexflow which didn't have right sided
  // stave connectors
  StaveConnector.type = {
    SINGLE_RIGHT : 0,
    SINGLE_LEFT : 1,
    SINGLE: 1,
    DOUBLE: 2,
    BRACE: 3,
    BRACKET: 4,
    BOLD_DOUBLE_LEFT: 5,
    BOLD_DOUBLE_RIGHT: 6,
    THIN_DOUBLE: 7
  };

  StaveConnector.prototype = {
    init: function(top_stave, bottom_stave) {
      this.thickness = Vex.Flow.STAVE_LINE_THICKNESS;
      this.width = 3;
      this.top_stave = top_stave;
      this.bottom_stave = bottom_stave;
      this.type = StaveConnector.type.DOUBLE;
      this.x_shift = 0; // Mainly used to offset Bold Double Left to align with offset Repeat Begin bars
    },

    setContext: function(ctx) {
      this.ctx = ctx;
      return this;
    },

    setType: function(type) {
      if (type >= StaveConnector.type.SINGLE_RIGHT &&
          type <= StaveConnector.type.THIN_DOUBLE)
        this.type = type;
      return this;
    },

    setText: function(text, text_options) {
      this.text = text;
      this.text_options = {
        shift_x: 0,
        shift_y: 0
      };
      Vex.Merge(this.text_options, text_options);

      this.font = {
        family: "times",
        size: 16,
        weight: "normal"
      };
      return this;
    },

    setFont: function(font) {
      Vex.Merge(this.font, font);
    },

    setXShift: function(x_shift){
      if (typeof x_shift !== 'number') {
        throw Vex.RERR("InvalidType", "x_shift must be a Number");
      }

      this.x_shift = x_shift;
      return this;
    },

    draw: function() {
      if (!this.ctx) throw new Vex.RERR(
          "NoContext", "Can't draw without a context.");
      var topY = this.top_stave.getYForLine(0);
      var botY = this.bottom_stave.getYForLine(this.bottom_stave.getNumLines() - 1) +
        this.thickness;
      var width = this.width;
      var topX = this.top_stave.getX();

      var isRightSidedConnector = (
        this.type === StaveConnector.type.SINGLE_RIGHT ||
        this.type === StaveConnector.type.BOLD_DOUBLE_RIGHT ||
        this.type === StaveConnector.type.THIN_DOUBLE
      );

      if (isRightSidedConnector){
        topX = this.top_stave.getX() + this.top_stave.width;
      }

      var attachment_height = botY - topY;
      switch (this.type) {
        case StaveConnector.type.SINGLE:
          width = 1;
          break;
        case StaveConnector.type.SINGLE_LEFT:
          width = 1;
          break;
        case StaveConnector.type.SINGLE_RIGHT:
          width = 1;
          break;
        case StaveConnector.type.DOUBLE:
          topX -= (this.width + 2);
          break;
        case StaveConnector.type.BRACE:
          width = 12;
          // May need additional code to draw brace
          var x1 = this.top_stave.getX() - 2;
          var y1 = topY;
          var x3 = x1;
          var y3 = botY;
          var x2 = x1 - width;
          var y2 = y1 + attachment_height/2.0;
          var cpx1 = x2 - (0.90 * width);
          var cpy1 = y1 + (0.2 * attachment_height);
          var cpx2 = x1 + (1.10 * width);
          var cpy2 = y2 - (0.135 * attachment_height);
          var cpx3 = cpx2;
          var cpy3 = y2 + (0.135 * attachment_height);
          var cpx4 = cpx1;
          var cpy4 = y3 - (0.2 * attachment_height);
          var cpx5 = x2 - width;
          var cpy5 = cpy4;
          var cpx6 = x1 + (0.40 * width);
          var cpy6 = y2 + (0.135 * attachment_height);
          var cpx7 = cpx6;
          var cpy7 = y2 - (0.135 * attachment_height);
          var cpx8 = cpx5;
          var cpy8 = cpy1;
          this.ctx.beginPath();
          this.ctx.moveTo(x1, y1);
          this.ctx.bezierCurveTo(cpx1, cpy1, cpx2, cpy2, x2, y2);
          this.ctx.bezierCurveTo(cpx3, cpy3, cpx4, cpy4, x3, y3);
          this.ctx.bezierCurveTo(cpx5, cpy5, cpx6, cpy6, x2, y2);
          this.ctx.bezierCurveTo(cpx7, cpy7, cpx8, cpy8, x1, y1);
          this.ctx.fill();
          this.ctx.stroke();
          break;
        case StaveConnector.type.BRACKET:
          topY -= 4;
          botY += 4;
          attachment_height = botY - topY;
          Vex.Flow.renderGlyph(this.ctx, topX - 5, topY - 3, 40, "v1b", true);
          Vex.Flow.renderGlyph(this.ctx, topX - 5, botY + 3, 40, "v10", true);
          topX -= (this.width + 2);
          break;
        case StaveConnector.type.BOLD_DOUBLE_LEFT:
          drawBoldDoubleLine(this.ctx, this.type, topX + this.x_shift, topY, botY);
          break;
        case StaveConnector.type.BOLD_DOUBLE_RIGHT:
          drawBoldDoubleLine(this.ctx, this.type, topX, topY, botY);
          break;
        case StaveConnector.type.THIN_DOUBLE:
          width = 1;
          break;
      }

      if (this.type !== StaveConnector.type.BRACE &&
        this.type !== StaveConnector.type.BOLD_DOUBLE_LEFT &&
        this.type !== StaveConnector.type.BOLD_DOUBLE_RIGHT) {
        this.ctx.fillRect(topX , topY, width, attachment_height);
      }

      // If the connector is a thin double barline, draw the paralell line
      if (this.type === StaveConnector.type.THIN_DOUBLE) {
        this.ctx.fillRect(topX - 3, topY, width, attachment_height);
      }

      // Add stave connector text
      if (this.text !== undefined) {
        this.ctx.save();
        this.ctx.lineWidth = 2;
        this.ctx.setFont(this.font.family, this.font.size, this.font.weight);
        var text_width = this.ctx.measureText("" + this.text).width;

        var x = this.top_stave.getX() - text_width - 24 + this.text_options.shift_x;
        var y = (this.top_stave.getYForLine(0) + this.bottom_stave.getBottomLineY()) / 2 +
          this.text_options.shift_y;

        this.ctx.fillText("" + this.text, x, y + 4);
        this.ctx.restore();
      }
    }
  };

  function drawBoldDoubleLine(ctx, type, topX, topY, botY){
    if (type !== StaveConnector.type.BOLD_DOUBLE_LEFT &&
        type !== StaveConnector.type.BOLD_DOUBLE_RIGHT) {
      throw Vex.RERR("InvalidConnector",
        "A REPEAT_BEGIN or REPEAT_END type must be provided.");
    }

    var x_shift = 3;
    var variableWidth = 3.5; // Width for avoiding anti-aliasing width issues
    var thickLineOffset = 2; // For aesthetics

    if (type === StaveConnector.type.BOLD_DOUBLE_RIGHT) {
      x_shift = -5; // Flips the side of the thin line
      variableWidth = 3;
    }

    // Thin line
    ctx.fillRect(topX + x_shift, topY, 1, botY - topY);
    // Thick line
    ctx.fillRect(topX - thickLineOffset, topY, variableWidth, botY - topY);
  }

  return StaveConnector;
}());
// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Cheppudira 2010

/** @constructor */
Vex.Flow.TabStave = (function() {
  function TabStave(x, y, width, options) {
    if (arguments.length > 0) this.init(x, y, width, options);
  }

  Vex.Inherit(TabStave, Vex.Flow.Stave, {
    init: function(x, y, width, options) {
      var tab_options = {
        spacing_between_lines_px: 13,
        num_lines: 6,
        top_text_position: 1
      };

      Vex.Merge(tab_options, options);
      TabStave.superclass.init.call(this, x, y, width, tab_options);
    },

    getYForGlyphs: function() {
      return this.getYForLine(2.5);
    },

    addTabGlyph: function() {
      var glyphScale;
      var glyphOffset;

      switch(this.options.num_lines) {
        case 8:
          glyphScale = 55;
          glyphOffset = 14;
          break;
        case 7:
          glyphScale = 47;
          glyphOffset = 8;
          break;
        case 6:
          glyphScale = 40;
          glyphOffset = 1;
          break;
        case 5:
          glyphScale = 30;
          glyphOffset = -6;
          break;
        case 4:
          glyphScale = 23;
          glyphOffset = -12;
          break;
      }

      var tabGlyph = new Vex.Flow.Glyph("v2f", glyphScale);
      tabGlyph.y_shift = glyphOffset;
      this.addGlyph(tabGlyph);
      return this;
    }
  });

  return TabStave;
}());
// Vex Flow
// Copyright Mohit Cheppudira <mohit@muthanna.com>
//
// A formatter for abstract tickable objects, such as notes, chords,
// tabs, etc.

/** @constructor */
Vex.Flow.TickContext = (function() {
  function TickContext() {
    this.init();
  }

  TickContext.prototype = {
    init: function() {
      this.currentTick = new Vex.Flow.Fraction(0, 1);
      this.maxTicks = new Vex.Flow.Fraction(0, 1);
      this.minTicks = null;
      this.width = 0;
      this.padding = 3;     // padding on each side (width += padding * 2)
      this.pixelsUsed = 0;
      this.x = 0;
      this.tickables = [];   // Notes, tabs, chords, lyrics.
      this.notePx = 0;       // width of widest note in this context
      this.extraLeftPx = 0;  // Extra left pixels for modifers & displace notes
      this.extraRightPx = 0; // Extra right pixels for modifers & displace notes
      this.align_center = false;

      this.tContexts = [];   // Parent array of tick contexts

      // Ignore this tick context for formatting and justification
      this.ignore_ticks = true;
      this.preFormatted = false;
      this.postFormatted = false;
      this.context = null; // Rendering context
    },

    setContext: function(context) { this.context = context; return this; },
    getContext: function() { return this.context; },
    shouldIgnoreTicks: function() { return this.ignore_ticks; },
    getWidth: function() { return this.width + (this.padding * 2); },
    getX: function() { return this.x; },
    setX: function(x) { this.x = x; return this; },
    getPixelsUsed: function() { return this.pixelsUsed; },
    setPixelsUsed: function(pixelsUsed) { this.pixelsUsed = pixelsUsed; return this; },
    setPadding: function(padding) { this.padding = padding; return this; },
    getMaxTicks: function() { return this.maxTicks; },
    getMinTicks: function() { return this.minTicks; },
    getTickables: function() { return this.tickables; },

    getCenterAlignedTickables: function() {
      return this.tickables.filter(function(tickable) {
        return tickable.isCenterAligned();
      });
    },

    // Get widths context, note and left/right modifiers for formatting
    getMetrics: function() {
      return { width: this.width, notePx: this.notePx,
               extraLeftPx: this.extraLeftPx, extraRightPx: this.extraRightPx };
    },

    getCurrentTick: function() { return this.currentTick; },
    setCurrentTick: function(tick) {
      this.currentTick = tick;
      this.preFormatted = false;
    },

    // Get left & right pixels used for modifiers
    getExtraPx: function() {
      var left_shift = 0;
      var right_shift = 0;
      var extraLeftPx = 0;
      var extraRightPx = 0;
      for (var i = 0; i < this.tickables.length; i++) {
        extraLeftPx = Math.max(this.tickables[i].extraLeftPx, extraLeftPx);
        extraRightPx = Math.max(this.tickables[i].extraRightPx, extraRightPx);
        var mContext = this.tickables[i].modifierContext;
        if (mContext && mContext != null) {
          left_shift = Math.max( left_shift, mContext.state.left_shift);
          right_shift = Math.max( right_shift, mContext.state.right_shift);
        }
      }
      return { left: left_shift, right: right_shift,
               extraLeft: extraLeftPx, extraRight: extraRightPx };
    },

    addTickable: function(tickable) {
      if (!tickable) {
        throw new Vex.RERR("BadArgument", "Invalid tickable added.");
      }

      if (!tickable.shouldIgnoreTicks()) {
        this.ignore_ticks = false;

        var ticks = tickable.getTicks();

        if (ticks.greaterThan(this.maxTicks)) {
          this.maxTicks = ticks.clone();
        }

        if (this.minTicks == null) {
          this.minTicks = ticks.clone();
        } else if (ticks.lessThan(this.minTicks)) {
          this.minTicks = ticks.clone();
        }
      }

      tickable.setTickContext(this);
      this.tickables.push(tickable);
      this.preFormatted = false;
      return this;
    },

    preFormat: function() {
      if (this.preFormatted) return;

      for (var i = 0; i < this.tickables.length; ++i) {
        var tickable = this.tickables[i];
        tickable.preFormat();
        var metrics = tickable.getMetrics();

        // Maintain max extra pixels from all tickables in the context
        this.extraLeftPx = Math.max(this.extraLeftPx,
                                    metrics.extraLeftPx + metrics.modLeftPx);
        this.extraRightPx = Math.max(this.extraRightPx,
                                     metrics.extraRightPx + metrics.modRightPx);

        // Maintain the widest note for all tickables in the context
        this.notePx = Math.max(this.notePx, metrics.noteWidth);

        // Recalculate the tick context total width
        this.width = this.notePx +
                     this.extraLeftPx +
                     this.extraRightPx;
      }

      return this;
    },

    postFormat: function() {
      if (this.postFormatted) return this;
      this.postFormatted = true;
      return this;
    }
  };

  TickContext.getNextContext = function(tContext) {
    var contexts = tContext.tContexts;
    var index = contexts.indexOf(tContext);

    return contexts[index+1];
  };

  return TickContext;
}());

// Vex Flow
// Copyright Mohit Cheppudira <mohit@muthanna.com>
//
// The tickable interface. Tickables are things that sit on a score and
// have a duration, i.e., they occupy space in the musical rendering dimension.

/** @constructor */
Vex.Flow.Tickable = (function() {
  function Tickable() {
    this.init();
  }

  Tickable.prototype = {
    init: function() {
      this.intrinsicTicks = 0;
      this.tickMultiplier = new Vex.Flow.Fraction(1, 1);
      this.ticks = new Vex.Flow.Fraction(0, 1);
      this.width = 0;
      this.x_shift = 0; // Shift from tick context
      this.voice = null;
      this.tickContext = null;
      this.modifierContext = null;
      this.modifiers = [];
      this.preFormatted = false;
      this.postFormatted = false;
      this.tuplet = null;

      // For interactivity
      this.id = null;
      this.elem = null;

      this.align_center = false;
      this.center_x_shift = 0; // Shift from tick context if center aligned

      // This flag tells the formatter to ignore this tickable during
      // formatting and justification. It is set by tickables such as BarNote.
      this.ignore_ticks = false;
      this.context = null;
    },

    setContext: function(context) { this.context = context; },

    // Set the DOM ID of the element. Must be called before draw(). TODO: Update
    // ID of element if has already been rendered.
    setId: function(id) { this.id = id; },
    getId: function() { return this.id; },
    getElem: function() { return this.elem; },
    getBoundingBox: function() { return null; },
    getTicks: function() { return this.ticks; },
    shouldIgnoreTicks: function() { return this.ignore_ticks; },
    getWidth: function() { return this.width; },
    setXShift: function(x) { this.x_shift = x; },
    getCenterXShift: function() {
      if (this.isCenterAligned()) {
        return this.center_x_shift;
      }

      return 0;
    },

    isCenterAligned: function() { return this.align_center; },
    setCenterAlignment: function(align_center) {
      this.align_center = align_center;
      return this;
    },

    // Every tickable must be associated with a voice. This allows formatters
    // and preFormatter to associate them with the right modifierContexts.
    getVoice: function() {
      if (!this.voice) throw new Vex.RERR("NoVoice", "Tickable has no voice.");
      return this.voice;
    },
    setVoice: function(voice) { this.voice = voice; },

    getTuplet: function() { return this.tuplet; },
    setTuplet: function(tuplet) {
      // Detach from previous tuplet
      var noteCount, beatsOccupied;

      if (this.tuplet) {
        noteCount = this.tuplet.getNoteCount();
        beatsOccupied = this.tuplet.getBeatsOccupied();

        // Revert old multiplier
        this.applyTickMultiplier(noteCount, beatsOccupied);
      }

      // Attach to new tuplet
      if (tuplet) {
        noteCount = tuplet.getNoteCount();
        beatsOccupied = tuplet.getBeatsOccupied();

        this.applyTickMultiplier(beatsOccupied, noteCount);
      }

      this.tuplet = tuplet;

      return this;
    },

    /** optional, if tickable has modifiers **/
    addToModifierContext: function(mc) {
      this.modifierContext = mc;
      // Add modifiers to modifier context (if any)
      this.preFormatted = false;
    },

    /** optional, if tickable has modifiers **/
    addModifier: function(mod) {
      this.modifiers.push(mod);
      this.preFormatted = false;
      return this;
    },

    setTickContext: function(tc) {
      this.tickContext = tc;
      this.preFormatted = false;
    },

    preFormat: function() {
      if (this.preFormatted) return;

      this.width = 0;
      if (this.modifierContext) {
        this.modifierContext.preFormat();
        this.width += this.modifierContext.getWidth();
      }
    },
    postFormat: function() {
      if (this.postFormatted) return;
      this.postFormatted = true;
      return this;
    },
    getIntrinsicTicks: function() {
      return this.intrinsicTicks;
    },
    setIntrinsicTicks: function(intrinsicTicks) {
      this.intrinsicTicks = intrinsicTicks;
      this.ticks = this.tickMultiplier.clone().multiply(this.intrinsicTicks);
    },
    getTickMultiplier: function() {
      return this.tickMultiplier;
    },
    applyTickMultiplier: function(numerator, denominator) {
      this.tickMultiplier.multiply(numerator, denominator);
      this.ticks = this.tickMultiplier.clone().multiply(this.intrinsicTicks);
    },
    setDuration: function(duration) {
      var ticks = duration.numerator * (Vex.Flow.RESOLUTION / duration.denominator);
      this.ticks = this.tickMultiplier.clone().multiply(ticks);
      this.intrinsicTicks = this.ticks.value();
    }
  };

  return Tickable;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements an abstract interface for notes and chords that
// are rendered on a stave. Notes have some common properties: All of them
// have a value (e.g., pitch, fret, etc.) and a duration (quarter, half, etc.)
//
// Some notes have stems, heads, dots, etc. Most notational elements that
// surround a note are called *modifiers*, and every note has an associated
// array of them. All notes also have a rendering context and belong to a stave.

Vex.Flow.Note = (function() {
  // To create a new note you need to provide a `note_struct`, which consists
  // of the following fields:
  //
  // `type`: The note type (e.g., `r` for rest, `s` for slash notes, etc.)
  // `dots`: The number of dots, which affects the duration.
  // `duration`: The time length (e.g., `q` for quarter, `h` for half, `8` for eighth etc.)
  //
  // The range of values for these parameters are available in `src/tables.js`.
  function Note(note_struct) {
    if (arguments.length > 0) this.init(note_struct);
  }
  Note.CATEGORY = "note";

  // Debug helper. Displays various note metrics for the given
  // note.
  Note.plotMetrics = function(ctx, note, yPos) {
    var metrics = note.getMetrics();
    var w = metrics.width;
    var xStart = note.getAbsoluteX() - metrics.modLeftPx - metrics.extraLeftPx;
    var xPre1 = note.getAbsoluteX() - metrics.extraLeftPx;
    var xAbs = note.getAbsoluteX();
    var xPost1 = note.getAbsoluteX() + metrics.noteWidth;
    var xPost2 = note.getAbsoluteX() + metrics.noteWidth + metrics.extraRightPx;
    var xEnd = note.getAbsoluteX() + metrics.noteWidth + metrics.extraRightPx + metrics.modRightPx;

    var xWidth = xEnd - xStart;
    ctx.save();
    ctx.setFont("Arial", 8, "");
    ctx.fillText(Math.round(xWidth) + "px", xStart + note.getXShift(), yPos);

    var y = (yPos + 7);
    function stroke(x1, x2, color) {
      ctx.beginPath();
      ctx.setStrokeStyle(color);
      ctx.setFillStyle(color);
      ctx.setLineWidth(3);
      ctx.moveTo(x1 + note.getXShift(), y);
      ctx.lineTo(x2 + note.getXShift(), y);
      ctx.stroke();
    }

    stroke(xStart, xPre1, "red");
    stroke(xPre1, xAbs, "#999");
    stroke(xAbs, xPost1, "green");
    stroke(xPost1, xPost2, "#999");
    stroke(xPost2, xEnd, "red");
    stroke(xStart - note.getXShift(), xStart, "#DDD"); // Shift
    Vex.drawDot(ctx, xAbs + note.getXShift(), y, "blue");
    ctx.restore();
  };

  // ## Prototype Methods
  //
  // Every note is a tickable, i.e., it can be mutated by the `Formatter` class for
  // positioning and layout.
  Vex.Inherit(Note, Vex.Flow.Tickable, {
    // See constructor above for how to create a note.
    init: function(note_struct) {
      Note.superclass.init.call(this);

      if (!note_struct) {
        throw new Vex.RuntimeError("BadArguments",
            "Note must have valid initialization data to identify " +
            "duration and type.");
      }

      // Parse `note_struct` and get note properties.
      var initData = Vex.Flow.parseNoteData(note_struct);
      if (!initData) {
        throw new Vex.RuntimeError("BadArguments",
            "Invalid note initialization object: " + JSON.stringify(note_struct));
      }

      // Set note properties from parameters.
      this.duration = initData.duration;
      this.dots = initData.dots;
      this.noteType = initData.type;

      if (note_struct.duration_override) {
        // Custom duration
        this.setDuration(note_struct.duration_override);
      } else {
        // Default duration
        this.setIntrinsicTicks(initData.ticks);
      }

      this.modifiers = [];

      // Get the glyph code for this note from the font.
      this.glyph = Vex.Flow.durationToGlyph(this.duration, this.noteType);

      if (this.positions &&
          (typeof(this.positions) != "object" || !this.positions.length)) {
        throw new Vex.RuntimeError(
          "BadArguments", "Note keys must be array type.");
      }

      // Note to play for audio players.
      this.playNote = null;

      // Positioning contexts used by the Formatter.
      this.tickContext = null;    // The current tick context.
      this.modifierContext = null;
      this.ignore_ticks = false;

      // Positioning variables
      this.width = 0;             // Width in pixels calculated after preFormat
      this.extraLeftPx = 0;       // Extra room on left for offset note head
      this.extraRightPx = 0;      // Extra room on right for offset note head
      this.x_shift = 0;           // X shift from tick context X
      this.left_modPx = 0;        // Max width of left modifiers
      this.right_modPx = 0;       // Max width of right modifiers
      this.voice = null;          // The voice that this note is in
      this.preFormatted = false;  // Is this note preFormatted?
      this.ys = [];               // list of y coordinates for each note
                                  // we need to hold on to these for ties and beams.

      if (note_struct.align_center) {
        this.setCenterAlignment(note_struct.align_center);
      }

      // The render surface.
      this.context = null;
      this.stave = null;
      this.render_options = {
        annotation_spacing: 5,
        stave_padding: 12
      };
    },

    // Get and set the play note, which is arbitrary data that can be used by an
    // audio player.
    getPlayNote: function() { return this.playNote; },
    setPlayNote: function(note) { this.playNote = note; return this; },

    // Don't play notes by default, call them rests. This is also used by things like
    // beams and dots for positioning.
    isRest: function() { return false; },

    // TODO(0xfe): Why is this method here?
    addStroke: function(index, stroke) {
      stroke.setNote(this);
      stroke.setIndex(index);
      this.modifiers.push(stroke);
      this.setPreFormatted(false);
      return this;
    },

    // Get and set the target stave.
    getStave: function() { return this.stave; },
    setStave: function(stave) {
      this.stave = stave;
      this.setYs([stave.getYForLine(0)]); // Update Y values if the stave is changed.
      this.context = this.stave.context;
      return this;
    },


    // `Note` is not really a modifier, but is used in
    // a `ModifierContext`.
    getCategory: function() { return this.constructor.CATEGORY; },

    // Set the rendering context for the note.
    setContext: function(context) { this.context = context; return this; },

    // Get and set spacing to the left and right of the notes.
    getExtraLeftPx: function() { return this.extraLeftPx; },
    getExtraRightPx: function() { return this.extraRightPx; },
    setExtraLeftPx: function(x) { this.extraLeftPx = x; return this; },
    setExtraRightPx: function(x) { this.extraRightPx = x; return this; },

    // Returns true if this note has no duration (e.g., bar notes, spacers, etc.)
    shouldIgnoreTicks: function() { return this.ignore_ticks; },

    // Get the stave line number for the note.
    getLineNumber: function() { return 0; },

    // Get the stave line number for rest.
    getLineForRest: function() { return 0; },

    // Get the glyph associated with this note.
    getGlyph: function() { return this.glyph; },

    // Set and get Y positions for this note. Each Y value is associated with
    // an individual pitch/key within the note/chord.
    setYs: function(ys) { this.ys = ys; return this; },
    getYs: function() {
      if (this.ys.length === 0) throw new Vex.RERR("NoYValues",
          "No Y-values calculated for this note.");
      return this.ys;
    },

    // Get the Y position of the space above the stave onto which text can
    // be rendered.
    getYForTopText: function(text_line) {
      if (!this.stave) throw new Vex.RERR("NoStave",
          "No stave attached to this note.");
      return this.stave.getYForTopText(text_line);
    },

    // Get a `BoundingBox` for this note.
    getBoundingBox: function() { return null; },

    // Returns the voice that this note belongs in.
    getVoice: function() {
      if (!this.voice) throw new Vex.RERR("NoVoice", "Note has no voice.");
      return this.voice;
    },

    // Attach this note to `voice`.
    setVoice: function(voice) {
      this.voice = voice;
      this.preFormatted = false;
      return this;
    },

    // Get and set the `TickContext` for this note.
    getTickContext: function() { return this.tickContext; },
    setTickContext: function(tc) {
      this.tickContext = tc;
      this.preFormatted = false;
      return this;
    },

    // Accessors for the note type.
    getDuration: function() { return this.duration; },
    isDotted: function() { return (this.dots > 0); },
    hasStem: function() { return false; },
    getDots: function() { return this.dots; },
    getNoteType: function() { return this.noteType; },
    setBeam: function() { return this; }, // ignore parameters

    // Attach this note to a modifier context.
    setModifierContext: function(mc) { this.modifierContext = mc; return this; },

    // Attach a modifier to this note.
    addModifier: function(modifier, index) {
      modifier.setNote(this);
      modifier.setIndex(index || 0);
      this.modifiers.push(modifier);
      this.setPreFormatted(false);
      return this;
    },

    // Get the coordinates for where modifiers begin.
    getModifierStartXY: function() {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call GetModifierStartXY on an unformatted note");
      return {x: this.getAbsoluteX(), y: this.ys[0]};
    },

    // Get bounds and metrics for this note.
    //
    // Returns a struct with fields:
    // `width`: The total width of the note (including modifiers.)
    // `noteWidth`: The width of the note head only.
    // `left_shift`: The horizontal displacement of the note.
    // `modLeftPx`: Start `X` for left modifiers.
    // `modRightPx`: Start `X` for right modifiers.
    // `extraLeftPx`: Extra space on left of note.
    // `extraRightPx`: Extra space on right of note.
    getMetrics: function() {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call getMetrics on an unformatted note.");
      var modLeftPx = 0;
      var modRightPx = 0;
      if (this.modifierContext != null) {
        modLeftPx = this.modifierContext.state.left_shift;
        modRightPx = this.modifierContext.state.right_shift;
      }

      var width = this.getWidth();
      return { width: width,
               noteWidth: width -
                          modLeftPx - modRightPx -
                          this.extraLeftPx - this.extraRightPx,
               left_shift: this.x_shift, // TODO(0xfe): Make style consistent


               // Modifiers, accidentals etc.
               modLeftPx: modLeftPx,
               modRightPx: modRightPx,

               // Displaced note head on left or right.
               extraLeftPx: this.extraLeftPx,
               extraRightPx: this.extraRightPx };
    },

    // Get and set width of note. Used by the formatter for positioning.
    setWidth: function(width) { this.width = width; },
    getWidth: function() {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call GetWidth on an unformatted note.");
      return this.width +
        (this.modifierContext ?  this.modifierContext.getWidth() : 0);
    },

    // Displace note by `x` pixels. Used by the formatter.
    setXShift: function(x) { this.x_shift = x; return this; },
    getXShift: function() { return this.x_shift; },

    // Get `X` position of this tick context.
    getX: function() {
      if (!this.tickContext) throw new Vex.RERR("NoTickContext",
          "Note needs a TickContext assigned for an X-Value");
      return this.tickContext.getX() + this.x_shift;
    },

    // Get the absolute `X` position of this note's tick context. This
    // excludes x_shift, so you'll need to factor it in if you're
    // looking for the post-formatted x-position.
    getAbsoluteX: function() {
      if (!this.tickContext) throw new Vex.RERR("NoTickContext",
          "Note needs a TickContext assigned for an X-Value");

      // Position note to left edge of tick context.
      var x = this.tickContext.getX();
      if (this.stave) {
        x += this.stave.getNoteStartX() + this.render_options.stave_padding;
      }

      if (this.isCenterAligned()){
        x += this.getCenterXShift();
      }

      return x;
    },

    setPreFormatted: function(value) {
      this.preFormatted = value;

      // Maintain the width of left and right modifiers in pixels.
      if (this.preFormatted) {
        var extra = this.tickContext.getExtraPx();
        this.left_modPx = Math.max(this.left_modPx, extra.left);
        this.right_modPx = Math.max(this.right_modPx, extra.right);
      }
    }
  });

  return Note;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements `NoteHeads`. `NoteHeads` are typically not manipulated
// directly, but used internally in `StaveNote`.
//
// See `tests/notehead_tests.js` for usage examples.
Vex.Flow.NoteHead = (function() {
  var NoteHead = function(head_options) {
    if (arguments.length > 0) this.init(head_options);
  };

  // To enable logging for this class. Set `Vex.Flow.NoteHead.DEBUG` to `true`.
  function L() { if (NoteHead.DEBUG) Vex.L("Vex.Flow.NoteHead", arguments); }


  // Draw slashnote head manually. No glyph exists for this.
  //
  // Parameters:
  // * `ctx`: the Canvas context
  // * `duration`: the duration of the note. ex: "4"
  // * `x`: the x coordinate to draw at
  // * `y`: the y coordinate to draw at
  // * `stem_direction`: the direction of the stem
  function drawSlashNoteHead(ctx, duration, x, y, stem_direction) {
    var width = 15 + (Vex.Flow.STEM_WIDTH / 2);
    ctx.save();
    ctx.setLineWidth(Vex.Flow.STEM_WIDTH);

    var fill = false;

    if (Vex.Flow.durationToNumber(duration) > 2) {
      fill = true;
    }

    if (!fill) x -= (Vex.Flow.STEM_WIDTH / 2) * stem_direction;

    ctx.beginPath();
    ctx.moveTo(x, y + 11);
    ctx.lineTo(x, y + 1);
    ctx.lineTo(x + width, y - 10);
    ctx.lineTo(x + width, y);
    ctx.lineTo(x, y + 11);
    ctx.closePath();

    if (fill) {
       ctx.fill();
    } else {
       ctx.stroke();
    }

    if (Vex.Flow.durationToFraction(duration).equals(0.5)) {
      var breve_lines = [-3, -1, width + 1, width + 3];
      for(var i=0; i<breve_lines.length; i++){
          ctx.beginPath();
          ctx.moveTo(x + breve_lines[i], y - 10);
          ctx.lineTo(x + breve_lines[i], y + 11);
          ctx.stroke();
      }
    }

    ctx.restore();
  }

  // ## Prototype Methods
  Vex.Inherit(NoteHead, Vex.Flow.Note, {
    init: function(head_options) {
      NoteHead.superclass.init.call(this, head_options);
      this.index = head_options.index;
      this.x = head_options.x || 0;
      this.y = head_options.y || 0;
      this.note_type = head_options.note_type;
      this.duration = head_options.duration;
      this.displaced = head_options.displaced || false;
      this.stem_direction = head_options.stem_direction || Vex.Flow.StaveNote.STEM_UP;
      this.line = head_options.line;

      // Get glyph code based on duration and note type. This could be
      // regular notes, rests, or other custom codes.
      this.glyph = Vex.Flow.durationToGlyph(this.duration, this.note_type);
      if (!this.glyph) {
        throw new Vex.RuntimeError("BadArguments",
            "No glyph found for duration '" + this.duration +
            "' and type '" + this.note_type + "'");
      }

      this.glyph_code = this.glyph.code_head;
      this.x_shift = head_options.x_shift;
      if (head_options.custom_glyph_code) {
        this.custom_glyph = true;
        this.glyph_code = head_options.custom_glyph_code;
      }

      this.context = null;
      this.style = head_options.style;
      this.slashed = head_options.slashed;

      Vex.Merge(this.render_options, {
        glyph_font_scale: 35, // font size for note heads
        stroke_px: 3         // number of stroke px to the left and right of head
      });

      if (head_options.glyph_font_scale) {
        this.render_options.glyph_font_scale = head_options.glyph_font_scale;
      }

      this.setWidth(this.glyph.head_width);
    },

    // Get the `ModifierContext` category
    getCategory: function() { return "notehead"; },

    // Set the Cavnas context for drawing
    setContext: function(context) { this.context = context; return this;},

    // Get the width of the notehead
    getWidth: function() { return this.width; },

    // Determine if the notehead is displaced
    isDisplaced: function() { return this.displaced === true; },

    // Get/set the notehead's style
    //
    // `style` is an `object` with the following properties: `shadowColor`,
    // `shadowBlur`, `fillStyle`, `strokeStyle`
    getStyle: function() { return this.style; },
    setStyle: function(style) { this.style = style; return this; },

    // Get the glyph data
    getGlyph: function(){ return this.glyph; },

    // Set the X coordinate
    setX: function(x){ this.x = x; return this; },

    // get/set the Y coordinate
    getY: function() { return this.y; },
    setY: function(y) { this.y = y;  return this; },

    // Get/set the stave line the notehead is placed on
    getLine: function() { return this.line; },
    setLine: function(line) { this.line = line; return this; },

    // Get the canvas `x` coordinate position of the notehead.
    getAbsoluteX: function() {
      var getAbsoluteX = NoteHead.superclass.getAbsoluteX;

      // If the note has not been preformatted, then get the static x value
      // Otherwise, it's been formatted and we should use it's x value relative
      // to its tick context
      var x = !this.preFormatted ? this.x : getAbsoluteX.call(this);

      return x + (this.displaced ? this.width * this.stem_direction : 0);
    },

    // Get the `BoundingBox` for the `NoteHead`
    getBoundingBox: function() {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call getBoundingBox on an unformatted note.");

      var spacing = this.stave.getSpacingBetweenLines();
      var half_spacing = spacing/2;
      var min_y = this.y - half_spacing;

      return new Vex.Flow.BoundingBox(this.getAbsoluteX(), min_y, this.width, spacing);
    },

    // Apply current style to Canvas `context`
    applyStyle: function(context) {
      var style = this.getStyle();
      if (style.shadowColor) context.setShadowColor(style.shadowColor);
      if (style.shadowBlur) context.setShadowBlur(style.shadowBlur);
      if (style.fillStyle) context.setFillStyle(style.fillStyle);
      if (style.strokeStyle) context.setStrokeStyle(style.strokeStyle);
      return this;
    },

    // Set notehead to a provided `stave`
    setStave: function(stave){
      var line = this.getLine();

      this.stave = stave;
      this.setY(stave.getYForNote(line));
      this.context = this.stave.context;
      return this;
    },

    // Pre-render formatting
    preFormat: function() {
      if (this.preFormatted) return this;

      var glyph = this.getGlyph();
      var width = glyph.head_width + this.extraLeftPx + this.extraRightPx;

      this.setWidth(width);
      this.setPreFormatted(true);
      return this;
    },

    // Draw the notehead
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      var ctx = this.context;
      var head_x = this.getAbsoluteX();
      var y = this.y;

      L("Drawing note head '", this.note_type, this.duration, "' at", head_x, y);

      // Begin and end positions for head.
      var stem_direction = this.stem_direction;
      var glyph_font_scale = this.render_options.glyph_font_scale;

      var line = this.line;

      // If note above/below the staff, draw the small staff
      if (line <= 0 || line >= 6) {
        var line_y = y;
        var floor = Math.floor(line);
        if (line < 0 && floor - line == -0.5)
          line_y -= 5;
        else if (line > 6 &&  floor - line == -0.5)
          line_y += 5;
        if (this.note_type != 'r') {
          ctx.fillRect(
            head_x - this.render_options.stroke_px, line_y,
            (this.getGlyph().head_width) +
            (this.render_options.stroke_px * 2), 1);
        }
      }

      if (this.note_type == "s") {
        drawSlashNoteHead(ctx, this.duration,
          head_x, y, stem_direction);
      } else {
        if (this.style) {
          ctx.save();
          this.applyStyle(ctx);
          Vex.Flow.renderGlyph(ctx, head_x, y, glyph_font_scale, this.glyph_code);
          ctx.restore();
        } else {
          Vex.Flow.renderGlyph(ctx, head_x, y, glyph_font_scale, this.glyph_code);
        }
      }
    }
  });

  return NoteHead;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements the `Stem` object. Generally this object is handled
// by its parent `StemmableNote`.
//
Vex.Flow.Stem = (function() {
  var Stem = function(options) {
    if (arguments.length > 0) this.init(options);
  };

  // To enable logging for this class. Set `Vex.Flow.Stem.DEBUG` to `true`.
  function L() { if (Stem.DEBUG) Vex.L("Vex.Flow.Stem", arguments); }

  // Stem directions
  Stem.UP = 1;
  Stem.DOWN = -1;

  // Theme
  Stem.WIDTH = Vex.Flow.STEM_WIDTH;
  Stem.HEIGHT = Vex.Flow.STEM_HEIGHT;

  // ## Prototype Methods
  Stem.prototype = {
    init: function(options) {
      // Default notehead x bounds
      this.x_begin = options.x_begin || 0;
      this.x_end = options.x_end || 0;

      // Y bounds for top/bottom most notehead
      this.y_top = options.y_top || 0;
      this.y_bottom = options.y_bottom || 0;

      // Stem base extension
      this.y_extend = options.y_extend || 0;
      // Stem top extension
      this.stem_extension = options.stem_extension || 0;

      // Direction of the stem
      this.stem_direction = options.stem_direction || 0;

      // Flag to override all draw calls
      this.hide = false;
    },

    // Set the x bounds for the default notehead
    setNoteHeadXBounds: function(x_begin, x_end) {
      this.x_begin = x_begin;
      this.x_end = x_end;
      return this;
    },

    // Set the direction of the stem in relation to the noteheads
    setDirection: function(direction){ this.stem_direction = direction; },

    // Set the extension for the stem, generally for flags or beams
    setExtension: function(ext) { this.stem_extension = ext; },

    // The the y bounds for the top and bottom noteheads
    setYBounds: function(y_top, y_bottom) {
      this.y_top = y_top;
      this.y_bottom = y_bottom;
    },

    // The category of the object
    getCategory: function() { return "stem"; },

    // Set the canvas context to render on
    setContext: function(context) { this.context = context; return this;},

    // Gets the entire height for the stem
    getHeight: function() {
      return ((this.y_bottom - this.y_top) * this.stem_direction) +
             ((Stem.HEIGHT + this.stem_extension) * this.stem_direction);
    },

    getBoundingBox: function() {
      throw new Vex.RERR("NotImplemented", "getBoundingBox() not implemented.");
    },

    // Get the y coordinates for the very base of the stem to the top of
    // the extension
    getExtents: function() {
      var ys = [this.y_top, this.y_bottom];

      var top_pixel = this.y_top;
      var base_pixel = this.y_bottom;
      var stem_height = Stem.HEIGHT + this.stem_extension;

      for (var i = 0; i < ys.length; ++i) {
        var stem_top = ys[i] + (stem_height * -this.stem_direction);

        if (this.stem_direction == Stem.DOWN) {
          top_pixel = Math.max(top_pixel, stem_top);
          base_pixel = Math.min(base_pixel, ys[i]);
        } else {
          top_pixel = Math.min(top_pixel, stem_top);
          base_pixel = Math.max(base_pixel, ys[i]);
        }
      }

      return { topY: top_pixel, baseY: base_pixel };
    },

    // set the draw style of a stem:
    setStyle: function(style) { this.style = style; return this; },
    getStyle: function() { return this.style; },

    // Apply current style to Canvas `context`
    applyStyle: function(context) {
      var style = this.getStyle();
      if(style) {
        if (style.shadowColor) context.setShadowColor(style.shadowColor);
        if (style.shadowBlur) context.setShadowBlur(style.shadowBlur);
        if (style.strokeStyle) context.setStrokeStyle(style.strokeStyle);
      }
      return this;
    },

    // Render the stem onto the canvas
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      if (this.hide) return;

      var ctx = this.context;
      var stem_x, stem_y;
      var stem_direction = this.stem_direction;

      if (stem_direction == Stem.DOWN) {
        // Down stems are rendered to the left of the head.
        stem_x = this.x_begin + (Stem.WIDTH / 2);
        stem_y = this.y_top + 2;
      } else {
        // Up stems are rendered to the right of the head.
        stem_x = this.x_end + (Stem.WIDTH / 2);
        stem_y = this.y_bottom - 2;
      }

      stem_y += this.y_extend * stem_direction;

      L("Rendering stem - ", "Top Y: ", this.y_top, "Bottom Y: ", this.y_bottom);

      // Draw the stem
      ctx.save();
      this.applyStyle(ctx);
      ctx.beginPath();
      ctx.setLineWidth(Stem.WIDTH);
      ctx.moveTo(stem_x, stem_y);
      ctx.lineTo(stem_x, stem_y - this.getHeight());
      ctx.stroke();
      ctx.restore();
    }
  };

  return Stem;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// `StemmableNote` is an abstract interface for notes with optional stems.
// Examples of stemmable notes are `StaveNote` and `TabNote`
Vex.Flow.StemmableNote = (function(){
  var StemmableNote = function(note_struct) {
    if (arguments.length > 0) this.init(note_struct);
  };

  // To enable logging for this class. Set `Vex.Flow.StemmableNote.DEBUG` to `true`.
  function L() { if (StemmableNote.DEBUG) Vex.L("Vex.Flow.StemmableNote", arguments); }

  var Stem = Vex.Flow.Stem;

  Vex.Inherit(StemmableNote, Vex.Flow.Note, {
    init: function(note_struct){
      StemmableNote.superclass.init.call(this, note_struct);

      this.stem = null;
      this.stem_extension_override = null;
      this.beam = null;
    },

    // Get and set the note's `Stem`
    getStem: function() {return this.stem; },
    setStem: function(stem) { this.stem = stem; return this; },

    // Builds and sets a new stem
    buildStem: function() {
      var stem = new Stem();
      this.setStem(stem);
      return this;
    },

    // Get the full length of stem
    getStemLength: function() {
      return Stem.HEIGHT + this.getStemExtension();
    },

    // Get the number of beams for this duration
    getBeamCount: function(){
      var glyph = this.getGlyph();

      if (glyph) {
        return glyph.beam_count;
      } else {
        return 0;
      }
    },

    // Get the minimum length of stem
    getStemMinumumLength: function() {
      var frac = Vex.Flow.durationToFraction(this.duration);
      var length = (frac.value() <= 1) ? 0 : 20;
      // if note is flagged, cannot shorten beam
      switch (this.duration) {
       case "8":
         if (this.beam == null) length = 35;
         break;
       case "16":
         if (this.beam == null)
           length = 35;
         else
           length = 25;
         break;
       case "32":
         if (this.beam == null)
           length = 45;
         else
           length = 35;
         break;
       case "64":
         if (this.beam == null)
           length = 50;
         else
           length = 40;
         break;
       case "128":
         if (this.beam == null)
           length = 55;
         else
           length = 45;
      }
      return length;
    },

    // Get/set the direction of the stem
    getStemDirection: function() { return this.stem_direction; },
    setStemDirection: function(direction) {
      if (!direction) direction = Stem.UP;
      if (direction != Stem.UP &&
          direction != Stem.DOWN) {
        throw new Vex.RERR("BadArgument", "Invalid stem direction: " +
            direction);
      }

      this.stem_direction = direction;
      if (this.stem) {
        this.stem.setDirection(direction);
        this.stem.setExtension(this.getStemExtension());
      }

      this.beam = null;
      if (this.preFormatted) {
        this.preFormat();
      }
      return this;
    },

    // Get the `x` coordinate of the stem
    getStemX: function() {
      var x_begin = this.getAbsoluteX() + this.x_shift;
      var x_end = this.getAbsoluteX() + this.x_shift + this.glyph.head_width;

      var stem_x = this.stem_direction == Stem.DOWN ?
        x_begin : x_end;

      stem_x -= ((Stem.WIDTH / 2) * this.stem_direction);

      return stem_x;
    },

    // Get the `x` coordinate for the center of the glyph.
    // Used for `TabNote` stems and stemlets over rests
    getCenterGlyphX: function(){
      return this.getAbsoluteX() + this.x_shift + (this.glyph.head_width / 2);
    },

    // Get the stem extension for the current duration
    getStemExtension: function(){
      var glyph = this.getGlyph();

      if (this.stem_extension_override != null) {
        return this.stem_extension_override;
      }

      if (glyph) {
        return this.getStemDirection() === 1 ? glyph.stem_up_extension :
          glyph.stem_down_extension;
      }

      return 0;
    },

    // Set the stem length to a specific. Will override the default length.
    setStemLength: function(height) {
      this.stem_extension_override = (height - Stem.HEIGHT);
      return this;
    },

    // Get the top and bottom `y` values of the stem.
    getStemExtents: function() {
      if (!this.ys || this.ys.length === 0) throw new Vex.RERR("NoYValues",
          "Can't get top stem Y when note has no Y values.");

      var top_pixel = this.ys[0];
      var base_pixel = this.ys[0];
      var stem_height = Stem.HEIGHT + this.getStemExtension();

      for (var i = 0; i < this.ys.length; ++i) {
        var stem_top = this.ys[i] + (stem_height * -this.stem_direction);

        if (this.stem_direction == Stem.DOWN) {
          top_pixel = Math.max(top_pixel, stem_top);
          base_pixel = Math.min(base_pixel, this.ys[i]);
        } else {
          top_pixel = Math.min(top_pixel, stem_top);
          base_pixel = Math.max(base_pixel, this.ys[i]);
        }

        if(this.noteType == "s" || this.noteType == 'x') {
          top_pixel -= this.stem_direction * 7;
          base_pixel -= this.stem_direction * 7;
        }
      }

      L("Stem extents: ", top_pixel, base_pixel);
      return { topY: top_pixel, baseY: base_pixel };
    },

    // Sets the current note's beam
    setBeam: function(beam) { this.beam = beam; return this; },

    // Get the `y` value for the top/bottom modifiers at a specific `text_line`
    getYForTopText: function(text_line) {
      var extents = this.getStemExtents();
      if (this.hasStem()) {
        return Vex.Min(this.stave.getYForTopText(text_line),
            extents.topY - (this.render_options.annotation_spacing * (text_line + 1)));
      } else {
        return this.stave.getYForTopText(text_line);
      }
    },

    getYForBottomText: function(text_line) {
      var extents = this.getStemExtents();
      if (this.hasStem()) {
        return Vex.Max(this.stave.getYForTopText(text_line),
          extents.baseY + (this.render_options.annotation_spacing * (text_line)));
      } else {
        return this.stave.getYForBottomText(text_line);
      }
    },

    hasFlag: function() {
      return Vex.Flow.durationToGlyph(this.duration).flag;
    },

    // Post format the note
    postFormat: function() {
      if (this.beam) {
        this.beam.postFormat();
      }
      this.postFormatted = true;
      return this;
    },

    // Render the stem onto the canvas
    drawStem: function(stem_struct){
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      this.setStem(new Stem(stem_struct));
      this.stem.setContext(this.context).draw();
    }
  });

  return StemmableNote;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements notes for standard notation. This consists of one or
// more `NoteHeads`, an optional stem, and an optional flag.
//
// *Throughout these comments, a "note" refers to the entire `StaveNote`,
// and a "key" refers to a specific pitch/notehead within a note.*
//
// See `tests/stavenote_tests.js` for usage examples.
Vex.Flow.StaveNote = (function() {
  var StaveNote = function(note_struct) {
    if (arguments.length > 0) this.init(note_struct);
  };
  StaveNote.CATEGORY = "stavenotes";

  // To enable logging for this class. Set `Vex.Flow.StaveNote.DEBUG` to `true`.
  function L() { if (StaveNote.DEBUG) Vex.L("Vex.Flow.StaveNote", arguments); }

  var Stem = Vex.Flow.Stem;
  var NoteHead = Vex.Flow.NoteHead;

  // Stem directions
  StaveNote.STEM_UP = Stem.UP;
  StaveNote.STEM_DOWN = Stem.DOWN;

  // Helper methods for rest positioning in ModifierContext.
  var shiftRestVertical = function(rest, note, dir) {
    var delta = (note.isrest ? 0.0 : 1.0) * dir;

    rest.line += delta;
    rest.max_line += delta;
    rest.min_line += delta;
    rest.note.setKeyLine(0, rest.note.getKeyLine(0) + (delta));
  };

  // Called from formatNotes :: center a rest between two notes
  var centerRest = function(rest, noteU, noteL) {
    var delta = rest.line - Vex.MidLine(noteU.min_line, noteL.max_line);
    rest.note.setKeyLine(0, rest.note.getKeyLine(0) - delta);
    rest.line -= delta;
    rest.max_line -= delta;
    rest.min_line -= delta;
  };

  // ## Static Methods
  //
  // Format notes inside a ModifierContext.
  StaveNote.format = function(notes, state) {
    if (!notes || notes.length < 2) return false;

    if (notes[0].getStave() != null) return StaveNote.formatByY(notes, state);

    var notes_list= [];

    for (var i = 0; i < notes.length; i++) {
      var props = notes[i].getKeyProps();
      var line = props[0].line;
      var minL = props[props.length -1].line;
      var stem_dir = notes[i].getStemDirection();
      var stem_max = notes[i].getStemLength() / 10;
      var stem_min = notes[i].getStemMinumumLength() / 10;

      var maxL;
      if (notes[i].isRest()) {
        maxL = line + notes[i].glyph.line_above;
        minL = line - notes[i].glyph.line_below;
      } else {
        maxL = stem_dir == 1 ? props[props.length -1].line + stem_max
             : props[props.length -1].line;
        minL = stem_dir == 1 ? props[0].line
             : props[0].line - stem_max;
      }
      notes_list.push(
        {line: props[0].line,         // note/rest base line
         max_line: maxL,              // note/rest upper bounds line
         min_line: minL,              // note/rest lower bounds line
         isrest: notes[i].isRest(),
         stem_dir: stem_dir,
         stem_max: stem_max,          // Maximum (default) note stem length;
         stem_min: stem_min,          // minimum note stem length
         voice_shift: notes[i].getVoiceShiftWidth(),
         is_displaced: notes[i].isDisplaced(),   // note manually displaced
         note: notes[i]});
    }

    var voices = notes_list.length;

    var noteU = notes_list[0];
    var noteM = voices > 2 ? notes_list[1] : null;
    var noteL = voices > 2 ? notes_list[2] : notes_list[1];

    // for two voice backward compatibility, ensure upper voice is stems up
    // for three voices, the voices must be in order (upper, middle, lower)
    if (voices == 2 && noteU.stem_dir == -1 && noteL.stem_dir == 1) {
      noteU = notes_list[1];
      noteL = notes_list[0];
    }

    var voice_x_shift = Math.max(noteU.voice_shift, noteL.voice_shift);
    var x_shift = 0;
    var stem_delta;

    // Test for two voice note intersection
    if (voices == 2) {
      var line_spacing = noteU.stem_dir == noteL.stem_dir ? 0.0 : 0.5;
      // if top voice is a middle voice, check stem intersection with lower voice
      if (noteU.stem_dir == noteL.stem_dir &&
          noteU.min_line <= noteL.max_line) {
        if (!noteU.isrest) {
          stem_delta = Math.abs(noteU.line - (noteL.max_line + 0.5));
          stem_delta = Math.max(stem_delta, noteU.stem_min);
          noteU.min_line = noteU.line - stem_delta;
          noteU.note.setStemLength(stem_delta * 10);
        }
      }
      if (noteU.min_line <= noteL.max_line + line_spacing) {
        if (noteU.isrest) {
          // shift rest up
          shiftRestVertical(noteU, noteL, 1);
        } else if (noteL.isrest) {
          // shift rest down
          shiftRestVertical(noteL, noteU, -1);
        } else {
          x_shift = voice_x_shift;
          if (noteU.stem_dir == noteL.stem_dir)
            // upper voice is middle voice, so shift it right
            noteU.note.setXShift(x_shift + 3);
          else
            // shift lower voice right
            noteL.note.setXShift(x_shift);
        }
      }

      // format complete
      return true;
    }

    // Check middle voice stem intersection with lower voice
    if (noteM != null && noteM.min_line < noteL.max_line + 0.5) {
      if (!noteM.isrest) {
        stem_delta = Math.abs(noteM.line - (noteL.max_line + 0.5));
        stem_delta = Math.max(stem_delta, noteM.stem_min);
        noteM.min_line = noteM.line - stem_delta;
        noteM.note.setStemLength(stem_delta * 10);
      }
    }

    // For three voices, test if rests can be repositioned
    //
    // Special case 1 :: middle voice rest between two notes
    //
    if (noteM.isrest && !noteU.isrest && !noteL.isrest) {
      if (noteU.min_line <= noteM.max_line ||
          noteM.min_line <= noteL.max_line) {
         var rest_height = noteM.max_line - noteM.min_line;
         var space = noteU.min_line - noteL.max_line;
         if (rest_height < space)
           // center middle voice rest between the upper and lower voices
           centerRest(noteM, noteU, noteL);
         else {
           x_shift = voice_x_shift + 3;    // shift middle rest right
           noteM.note.setXShift(x_shift);
         }
         // format complete
         return true;
      }
    }

    // Special case 2 :: all voices are rests
    if (noteU.isrest && noteM.isrest && noteL.isrest) {
      // Shift upper voice rest up
      shiftRestVertical(noteU, noteM, 1);
      // Shift lower voice rest down
      shiftRestVertical(noteL, noteM, -1);
      // format complete
      return true;
    }

    // Test if any other rests can be repositioned
    if (noteM.isrest && noteU.isrest && noteM.min_line <= noteL.max_line)
      // Shift middle voice rest up
      shiftRestVertical(noteM, noteL, 1);
    if (noteM.isrest && noteL.isrest && noteU.min_line <= noteM.max_line)
      // Shift middle voice rest down
      shiftRestVertical(noteM, noteU, -1);
    if (noteU.isrest && noteU.min_line <= noteM.max_line)
      // shift upper voice rest up;
      shiftRestVertical(noteU, noteM, 1);
    if (noteL.isrest && noteM.min_line <= noteL.max_line)
      // shift lower voice rest down
      shiftRestVertical(noteL, noteM, -1);

    // If middle voice intersects upper or lower voice
    if ((!noteU.isrest && !noteM.isrest && noteU.min_line <= noteM.max_line + 0.5) ||
        (!noteM.isrest && !noteL.isrest && noteM.min_line <= noteL.max_line)) {
      x_shift = voice_x_shift + 3;      // shift middle note right
      noteM.note.setXShift(x_shift);
    }

    return true;
  };

  StaveNote.formatByY = function(notes, state) {
    // NOTE: this function does not support more than two voices per stave
    //       use with care.
    var hasStave = true;
    var i;

    for (i = 0; i < notes.length; i++) {
      hasStave = hasStave && notes[i].getStave() != null;
    }

    if (!hasStave) throw new Vex.RERR("Stave Missing",
      "All notes must have a stave - Vex.Flow.ModifierContext.formatMultiVoice!");

    var x_shift = 0;

    for (i = 0; i < notes.length - 1; i++) {
      var top_note = notes[i];
      var bottom_note = notes[i + 1];

      if (top_note.getStemDirection() == Vex.Flow.StaveNote.STEM_DOWN) {
        top_note = notes[i + 1];
        bottom_note = notes[i];
      }

      var top_keys = top_note.getKeyProps();
      var bottom_keys = bottom_note.getKeyProps();

      var topY = top_note.getStave().getYForLine(top_keys[0].line);
      var bottomY = bottom_note.getStave().getYForLine(bottom_keys[bottom_keys.length - 1].line);

      var line_space = top_note.getStave().options.spacing_between_lines_px;
      if (Math.abs(topY - bottomY) == line_space / 2) {
        x_shift = top_note.getVoiceShiftWidth();
        bottom_note.setXShift(x_shift);
      }
    }

    state.right_shift += x_shift;
  };

  StaveNote.postFormat = function(notes) {
    if (!notes) return false;

    notes.forEach(function(note) {
      note.postFormat();
    });

    return true;
  };

  // ## Prototype Methods
  //
  Vex.Inherit(StaveNote, Vex.Flow.StemmableNote, {
    init: function(note_struct) {
      StaveNote.superclass.init.call(this, note_struct);

      this.keys = note_struct.keys;
      this.clef = note_struct.clef;
      this.octave_shift = note_struct.octave_shift;
      this.beam = null;

      // Pull note rendering properties
      this.glyph = Vex.Flow.durationToGlyph(this.duration, this.noteType);
      if (!this.glyph) {
        throw new Vex.RuntimeError("BadArguments",
            "Invalid note initialization data (No glyph found): " +
            JSON.stringify(note_struct));
      }

      // if true, displace note to right
      this.displaced = false;
      this.dot_shiftY = 0;
      // per-pitch properties
      this.keyProps = [];
      // for displaced ledger lines
      this.use_default_head_x = false;

      // Drawing
      this.note_heads = [];
      this.modifiers = [];

      Vex.Merge(this.render_options, {
        // font size for note heads and rests
        glyph_font_scale: 35,
        // number of stroke px to the left and right of head
        stroke_px: 3
      });

      this.calculateKeyProps();

      this.buildStem();

      // Set the stem direction
      if (note_struct.auto_stem) {
        this.autoStem();
      } else {
        this.setStemDirection(note_struct.stem_direction);
      }

      this.buildNoteHeads();

      // Calculate left/right padding
      this.calcExtraPx();
    },

    // Builds a `Stem` for the note
    buildStem: function() {
      var glyph = this.getGlyph();

      var y_extend = 0;
      if (glyph.code_head == "v95" || glyph.code_head == "v3e") {
         y_extend = -4;
      }

      var stem = new Stem({
        y_extend: y_extend
      });

      if (this.isRest()) {
        stem.hide = true;
      }

      this.setStem(stem);
    },

    // Builds a `NoteHead` for each key in the note
    buildNoteHeads: function() {
      var stem_direction = this.getStemDirection();

      var keys = this.getKeys();

      var last_line = null;
      var line_diff = null;
      var displaced = false;

      // Draw notes from bottom to top.
      var start_i = 0;
      var end_i = keys.length;
      var step_i = 1;

      // For down-stem notes, we draw from top to bottom.
      if (stem_direction === Stem.DOWN) {
        start_i = keys.length - 1;
        end_i = -1;
        step_i = -1;
      }

      for (var i = start_i; i != end_i; i += step_i) {
        var note_props = this.keyProps[i];

        var line = note_props.line;

        // Keep track of last line with a note head, so that consecutive heads
        // are correctly displaced.
        if (last_line === null) {
          last_line = line;
        } else {
          line_diff = Math.abs(last_line - line);
          if (line_diff === 0 || line_diff === 0.5) {
            displaced = !displaced;
          } else {
            displaced = false;
            this.use_default_head_x = true;
          }
        }
        last_line = line;

        var note_head = new NoteHead({
          duration: this.duration,
          note_type: this.noteType,
          displaced: displaced,
          stem_direction: stem_direction,
          custom_glyph_code: note_props.code,
          glyph_font_scale: this.render_options.glyph_font_scale,
          x_shift: note_props.shift_right,
          line: note_props.line
        });

        this.note_heads[i] = note_head;
      }
    },

    // Automatically sets the stem direction based on the keys in the note
    autoStem: function() {
      var auto_stem_direction;

      // Figure out optimal stem direction based on given notes
      this.min_line = this.keyProps[0].line;
      this.max_line = this.keyProps[this.keyProps.length - 1].line;
      var decider = (this.min_line + this.max_line) / 2;

      if (decider < 3) {
        auto_stem_direction = 1;
      } else {
        auto_stem_direction = -1;
      }

      this.setStemDirection(auto_stem_direction);
    },

    // Calculates and stores the properties for each key in the note
    calculateKeyProps: function() {
      var last_line = null;
      for (var i = 0; i < this.keys.length; ++i) {
        var key = this.keys[i];

        // All rests use the same position on the line.
        // if (this.glyph.rest) key = this.glyph.position;
        if (this.glyph.rest) this.glyph.position = key;
        var options = { octave_shift: this.octave_shift || 0 };
        var props = Vex.Flow.keyProperties(key, this.clef, options);
        if (!props) {
          throw new Vex.RuntimeError("BadArguments",
              "Invalid key for note properties: " + key);
        }

        // Override line placement for default rests
        if (props.key === "R") {
          if (this.duration === "1" || this.duration === "w") {
            props.line = 4;
          } else {
            props.line = 3;
          }
        }

        // Calculate displacement of this note
        var line = props.line;
        if (last_line === null) {
          last_line = line;
        } else {
          if (Math.abs(last_line - line) == 0.5) {
            this.displaced = true;
            props.displaced = true;

            // Have to mark the previous note as
            // displaced as well, for modifier placement
            if (this.keyProps.length > 0) {
                this.keyProps[i-1].displaced = true;
            }
          }
        }

        last_line = line;
        this.keyProps.push(props);
      }

      // Sort the notes from lowest line to highest line
      var sorted = true;
      var lastLine = -1000;
      var that = this;
      this.keyProps.forEach(function(key) {
        if (key.line < lastLine) {
          Vex.W("Unsorted keys in note will be sorted. " +
            "See https://github.com/0xfe/vexflow/issues/104 for details.");
        }
        lastLine = key.line;
      });
      this.keyProps.sort(function(a, b) { return a.line - b.line; });
    },

    // Get the `BoundingBox` for the entire note
    getBoundingBox: function() {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call getBoundingBox on an unformatted note.");

      var metrics = this.getMetrics();

      var w = metrics.width;
      var x = this.getAbsoluteX() - metrics.modLeftPx - metrics.extraLeftPx;

      var min_y = 0;
      var max_y = 0;
      var half_line_spacing = this.getStave().getSpacingBetweenLines() / 2;
      var line_spacing = half_line_spacing * 2;

      if (this.isRest()) {
        var y = this.ys[0];
        var frac = Vex.Flow.durationToFraction(this.duration);
        if (frac.equals(1) || frac.equals(2)) {
          min_y = y - half_line_spacing;
          max_y = y + half_line_spacing;
        } else {
          min_y = y - (this.glyph.line_above * line_spacing);
          max_y = y + (this.glyph.line_below * line_spacing);
        }
      } else if (this.glyph.stem) {
        var ys = this.getStemExtents();
        ys.baseY += half_line_spacing * this.stem_direction;
        min_y = Vex.Min(ys.topY, ys.baseY);
        max_y = Vex.Max(ys.topY, ys.baseY);
      } else {
        min_y = null;
        max_y = null;

        for (var i=0; i < this.ys.length; ++i) {
          var yy = this.ys[i];
          if (i === 0) {
            min_y = yy;
            max_y = yy;
          } else {
            min_y = Vex.Min(yy, min_y);
            max_y = Vex.Max(yy, max_y);
          }
          min_y -= half_line_spacing;
          max_y += half_line_spacing;
        }
      }

      return new Vex.Flow.BoundingBox(x, min_y, w, max_y - min_y);
    },

    // Gets the line number of the top or bottom note in the chord.
    // If `is_top_note` is `true` then get the top note
    getLineNumber: function(is_top_note) {
      if(!this.keyProps.length) throw new Vex.RERR("NoKeyProps",
          "Can't get bottom note line, because note is not initialized properly.");
      var result_line = this.keyProps[0].line;

      // No precondition assumed for sortedness of keyProps array
      for (var i=0; i<this.keyProps.length; i++) {
        var this_line = this.keyProps[i].line;
        if (is_top_note) {
          if (this_line > result_line) result_line = this_line;
        } else {
          if (this_line < result_line) result_line = this_line;
        }
      }

      return result_line;
    },

    // Determine if current note is a rest
    isRest: function() { return this.glyph.rest; },

    // Determine if the current note is a chord
    isChord: function() { return !this.isRest() && this.keys.length > 1; },

    // Determine if the `StaveNote` has a stem
    hasStem: function() { return this.glyph.stem; },

    // Get the `y` coordinate for text placed on the top/bottom of a
    // note at a desired `text_line`
    getYForTopText: function(text_line) {
      var extents = this.getStemExtents();
      return Vex.Min(this.stave.getYForTopText(text_line),
          extents.topY - (this.render_options.annotation_spacing * (text_line + 1)));
    },
    getYForBottomText: function(text_line) {
      var extents = this.getStemExtents();
      return Vex.Max(this.stave.getYForTopText(text_line),
          extents.baseY + (this.render_options.annotation_spacing * (text_line)));
    },

    // Sets the current note to the provided `stave`. This applies
    // `y` values to the `NoteHeads`.
    setStave: function(stave) {
      var superclass = Vex.Flow.StaveNote.superclass;
      superclass.setStave.call(this, stave);

      var ys = this.note_heads.map(function(note_head) {
        note_head.setStave(stave);
        return note_head.getY();
      });

      this.setYs(ys);

      var bounds = this.getNoteHeadBounds();
	    if (this.hasStem()) {
        this.stem.setYBounds(bounds.y_top, bounds.y_bottom);
      }

      return this;
    },

    // Get the pitches in the note
    getKeys: function() { return this.keys; },

    // Get the properties for all the keys in the note
    getKeyProps: function() {
      return this.keyProps;
    },

    // Check if note is shifted to the right
    isDisplaced: function() {
      return this.displaced;
    },

    // Sets whether shift note to the right. `displaced` is a `boolean`
    setNoteDisplaced: function(displaced) {
      this.displaced = displaced;
      return this;
    },

    // Get the starting `x` coordinate for a `StaveTie`
    getTieRightX: function() {
      var tieStartX = this.getAbsoluteX();
      tieStartX += this.glyph.head_width + this.x_shift + this.extraRightPx;
      if (this.modifierContext) tieStartX += this.modifierContext.getExtraRightPx();
      return tieStartX;
    },

    // Get the ending `x` coordinate for a `StaveTie`
    getTieLeftX: function() {
      var tieEndX = this.getAbsoluteX();
      tieEndX += this.x_shift - this.extraLeftPx;
      return tieEndX;
    },

    // Get the stave line on which to place a rest
    getLineForRest: function() {
      var rest_line = this.keyProps[0].line;
      if (this.keyProps.length > 1) {
        var last_line  = this.keyProps[this.keyProps.length - 1].line;
        var top = Vex.Max(rest_line, last_line);
        var bot = Vex.Min(rest_line, last_line);
        rest_line = Vex.MidLine(top, bot);
      }

      return rest_line;
    },

    // Get the default `x` and `y` coordinates for the provided `position`
    // and key `index`
    getModifierStartXY: function(position, index) {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call GetModifierStartXY on an unformatted note");

      if (this.ys.length === 0) throw new Vex.RERR("NoYValues",
          "No Y-Values calculated for this note.");

      var x = 0;
      if (position == Vex.Flow.Modifier.Position.LEFT) {
        // extra_left_px
        x = -1 * 2;
      } else if (position == Vex.Flow.Modifier.Position.RIGHT) {
        // extra_right_px
        x = this.glyph.head_width + this.x_shift + 2;
      } else if (position == Vex.Flow.Modifier.Position.BELOW ||
                 position == Vex.Flow.Modifier.Position.ABOVE) {
        x = this.glyph.head_width / 2;
      }

      return { x: this.getAbsoluteX() + x, y: this.ys[index] };
    },

    // Sets the style of the complete StaveNote, including all keys
    // and the stem.
    setStyle: function(style) {
      this.note_heads.forEach(function(notehead) {
        notehead.setStyle(style);
      }, this);
      this.stem.setStyle(style);
    },

    // Sets the notehead at `index` to the provided coloring `style`.
    //
    // `style` is an `object` with the following properties: `shadowColor`,
    // `shadowBlur`, `fillStyle`, `strokeStyle`
    setKeyStyle: function(index, style) {
      this.note_heads[index].setStyle(style);
      return this;
    },

    setKeyLine: function(index, line) {
      this.keyProps[index].line = line;
      this.note_heads[index].setLine(line);
      return this;
    },

    getKeyLine: function(index) {
      return this.keyProps[index].line;
    },

    // Add self to modifier context. `mContext` is the `ModifierContext`
    // to be added to.
    addToModifierContext: function(mContext) {
      this.setModifierContext(mContext);
      for (var i = 0; i < this.modifiers.length; ++i) {
        this.modifierContext.addModifier(this.modifiers[i]);
      }
      this.modifierContext.addModifier(this);
      this.setPreFormatted(false);
      return this;
    },

    // Generic function to add modifiers to a note
    //
    // Parameters:
    // * `index`: The index of the key that we're modifying
    // * `modifier`: The modifier to add
    addModifier: function(index, modifier) {
      modifier.setNote(this);
      modifier.setIndex(index);
      this.modifiers.push(modifier);
      this.setPreFormatted(false);
      return this;
    },

    // Helper function to add an accidental to a key
    addAccidental: function(index, accidental) {
      return this.addModifier(index, accidental);
    },

    // Helper function to add an articulation to a key
    addArticulation: function(index, articulation) {
      return this.addModifier(index, articulation);
    },

    // Helper function to add an annotation to a key
    addAnnotation: function(index, annotation) {
      return this.addModifier(index, annotation);
    },

    // Helper function to add a dot on a specific key
    addDot: function(index) {
      var dot = new Vex.Flow.Dot();
      dot.setDotShiftY(this.glyph.dot_shiftY);
      this.dots++;
      return this.addModifier(index, dot);
    },

    // Convenience method to add dot to all keys in note
    addDotToAll: function() {
      for (var i = 0; i < this.keys.length; ++i)
        this.addDot(i);
      return this;
    },

    // Get all accidentals in the `ModifierContext`
    getAccidentals: function() {
      return this.modifierContext.getModifiers("accidentals");
    },

    // Get all dots in the `ModifierContext`
    getDots: function() {
      return this.modifierContext.getModifiers("dots");
    },

    // Get the width of the note if it is displaced. Used for `Voice`
    // formatting
    getVoiceShiftWidth: function() {
      // TODO: may need to accomodate for dot here.
      return this.glyph.head_width * (this.displaced ? 2 : 1);
    },

    // Calculates and sets the extra pixels to the left or right
    // if the note is displaced.
    calcExtraPx: function() {
      this.setExtraLeftPx((this.displaced && this.stem_direction == -1) ?
          this.glyph.head_width : 0);

      // For upstems with flags, the extra space is unnecessary, since it's taken
      // up by the flag.
      this.setExtraRightPx((!this.hasFlag() && this.displaced && this.stem_direction == 1) ?
          this.glyph.head_width : 0);
    },

    // Pre-render formatting
    preFormat: function() {
      if (this.preFormatted) return;
      if (this.modifierContext) this.modifierContext.preFormat();

      var width = this.glyph.head_width + this.extraLeftPx + this.extraRightPx;

      // For upward flagged notes, the width of the flag needs to be added
      if (this.glyph.flag && this.beam === null && this.stem_direction == 1) {
        width += this.glyph.head_width;
      }

      this.setWidth(width);
      this.setPreFormatted(true);
    },

    // Gets the staff line and y value for the highest and lowest noteheads
    getNoteHeadBounds: function() {
      // Top and bottom Y values for stem.
      var y_top = null;
      var y_bottom = null;

      var highest_line = this.stave.getNumLines();
      var lowest_line = 1;

      this.note_heads.forEach(function(note_head) {
        var line = note_head.getLine();
        var y = note_head.getY();

        if (y_top === null || y < y_top)  {
          y_top = y;
        }

        if (y_bottom === null || y > y_bottom) {
          y_bottom = y;
        }

        highest_line = line > highest_line ? line : highest_line;
        lowest_line = line < lowest_line ? line : lowest_line;

      }, this);

      return {
        y_top: y_top,
        y_bottom: y_bottom,
        highest_line: highest_line,
        lowest_line: lowest_line
      };
    },

    // Get the starting `x` coordinate for the noteheads
    getNoteHeadBeginX: function(){
      return this.getAbsoluteX() + this.x_shift;
    },

    // Get the ending `x` coordinate for the noteheads
    getNoteHeadEndX: function(){
      var x_begin = this.getNoteHeadBeginX();
      return x_begin + this.glyph.head_width - (Vex.Flow.STEM_WIDTH / 2);
    },

    // Draw the ledger lines between the stave and the highest/lowest keys
    drawLedgerLines: function(){
      if (this.isRest()) { return; }
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      var ctx = this.context;

      var bounds = this.getNoteHeadBounds();
      var highest_line = bounds.highest_line;
      var lowest_line = bounds.lowest_line;
      var head_x = this.note_heads[0].getAbsoluteX();

      var that = this;
      function stroke(y) {
        if (that.use_default_head_x === true)  {
          head_x = that.getAbsoluteX() + that.x_shift;
        }
        var x = head_x - that.render_options.stroke_px;
        var length = ((head_x + that.glyph.head_width) - head_x) +
          (that.render_options.stroke_px * 2);

        ctx.fillRect(x, y, length, 1);
      }

      var line; // iterator
      for (line = 6; line <= highest_line; ++line) {
        stroke(this.stave.getYForNote(line));
      }

      for (line = 0; line >= lowest_line; --line) {
        stroke(this.stave.getYForNote(line));
      }
    },

    // Draw all key modifiers
    drawModifiers: function(){
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      var ctx = this.context;
      ctx.openGroup("modifiers");
      for (var i = 0; i < this.modifiers.length; i++) {
        var mod = this.modifiers[i];
        var note_head = this.note_heads[mod.getIndex()];
        var key_style = note_head.getStyle();
        if(key_style) {
            ctx.save();
            note_head.applyStyle(ctx);
        }
        mod.setContext(ctx);
        mod.draw();
        if(key_style) {
            ctx.restore();
        }
      }
      ctx.closeGroup();
    },

    // Draw the flag for the note
    drawFlag: function(){
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      var ctx = this.context;
      var glyph = this.getGlyph();
      var render_flag = this.beam === null;
      var bounds = this.getNoteHeadBounds();

      var x_begin = this.getNoteHeadBeginX();
      var x_end = this.getNoteHeadEndX();

      if (glyph.flag && render_flag) {
        var note_stem_height = this.stem.getHeight();
        var flag_x, flag_y, flag_code;

        if (this.getStemDirection() === Stem.DOWN) {
          // Down stems have flags on the left.
          flag_x = x_begin + 1;
          flag_y = bounds.y_top - note_stem_height + 2;
          flag_code = glyph.code_flag_downstem;

        } else {
          // Up stems have flags on the left.
          flag_x = x_end + 1;
          flag_y = bounds.y_bottom - note_stem_height - 2;
          flag_code = glyph.code_flag_upstem;
        }

        // Draw the Flag
        this.context.openGroup("flag", null, {pointerBBox: true});
        Vex.Flow.renderGlyph(ctx, flag_x, flag_y,
            this.render_options.glyph_font_scale, flag_code);
        this.context.closeGroup();
      }
    },

    // Draw the NoteHeads
    drawNoteHeads: function(){
      var that = this;
      this.note_heads.forEach(function(note_head) {
        that.context.openGroup("notehead", null, {pointerBBox: true});
        note_head.setContext(that.context).draw();
        that.context.closeGroup();
      }, this);
    },

    // Render the stem onto the canvas
    drawStem: function(stem_struct){
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      if (stem_struct) {
        this.setStem(new Stem(stem_struct));
      }

      this.context.openGroup("stem", null, {pointerBBox: true});
      this.stem.setContext(this.context).draw();
      this.context.closeGroup();
    },

    // Draws all the `StaveNote` parts. This is the main drawing method.
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      if (!this.stave) throw new Vex.RERR("NoStave",
          "Can't draw without a stave.");
      if (this.ys.length === 0) throw new Vex.RERR("NoYValues",
          "Can't draw note without Y values.");

      var x_begin = this.getNoteHeadBeginX();
      var x_end = this.getNoteHeadEndX();

      var render_stem = this.hasStem() && !this.beam;

      // Format note head x positions
      this.note_heads.forEach(function(note_head) {
        note_head.setX(x_begin);
      }, this);

      // Format stem x positions
      this.stem.setNoteHeadXBounds(x_begin, x_end);

      L("Rendering ", this.isChord() ? "chord :" : "note :", this.keys);

      // Draw each part of the note
      this.drawLedgerLines();

      this.elem = this.context.openGroup("stavenote", this.id);
      this.context.openGroup("note", null, {pointerBBox: true});
        if (render_stem) this.drawStem();
        this.drawNoteHeads();
        this.drawFlag();
      this.context.closeGroup();
      this.drawModifiers();
      this.context.closeGroup();
    }
  });

  return StaveNote;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// The file implements notes for Tablature notation. This consists of one or
// more fret positions, and can either be drawn with or without stems.
//
// See `tests/tabnote_tests.js` for usage examples
Vex.Flow.TabNote = (function() {
  function TabNote(tab_struct, draw_stem) {
    if (arguments.length > 0) this.init(tab_struct, draw_stem);
  }

  var Stem = Vex.Flow.Stem;

  // ## Prototype Methods
  Vex.Inherit(TabNote, Vex.Flow.StemmableNote, {
    // Initialize the TabNote with a `tab_struct` full of properties
    // and whether to `draw_stem` when rendering the note
    init: function(tab_struct, draw_stem) {
      var superclass = Vex.Flow.TabNote.superclass;
      superclass.init.call(this, tab_struct);

      this.ghost = false; // Renders parenthesis around notes
      // Note properties
      //
      // The fret positions in the note. An array of `{ str: X, fret: X }`
      this.positions = tab_struct.positions;

      // Render Options
      Vex.Merge(this.render_options, {
        // font size for note heads and rests
        glyph_font_scale: 30,
        // Flag to draw a stem
        draw_stem: draw_stem,
        // Flag to draw dot modifiers
        draw_dots: draw_stem,
        // Flag to extend the main stem through the stave and fret positions
        draw_stem_through_stave: false
      });

      this.glyph =
        Vex.Flow.durationToGlyph(this.duration, this.noteType);
      if (!this.glyph) {
        throw new Vex.RuntimeError("BadArguments",
            "Invalid note initialization data (No glyph found): " +
            JSON.stringify(tab_struct));
      }

      this.buildStem();

      if (tab_struct.stem_direction){
        this.setStemDirection(tab_struct.stem_direction);
      } else {
        this.setStemDirection(Stem.UP);
      }

      // Renders parenthesis around notes
      this.ghost = false;
      this.updateWidth();
    },

    // The ModifierContext category
    getCategory: function() { return "tabnotes"; },

    // Set as ghost `TabNote`, surrounds the fret positions with parenthesis.
    // Often used for indicating frets that are being bent to
    setGhost: function(ghost) {
      this.ghost = ghost;
      this.updateWidth();
      return this;
    },

    // Determine if the note has a stem
    hasStem: function() { return this.render_options.draw_stem; },

    // Get the default stem extension for the note
    getStemExtension: function(){
      var glyph = this.getGlyph();

      if (this.stem_extension_override != null) {
        return this.stem_extension_override;
      }

      if (glyph) {
        return this.getStemDirection() === 1 ? glyph.tabnote_stem_up_extension :
          glyph.tabnote_stem_down_extension;
      }

      return 0;
    },

    // Add a dot to the note
    addDot: function() {
      var dot = new Vex.Flow.Dot();
      this.dots++;
      return this.addModifier(dot, 0);
    },

    // Calculate and store the width of the note
    updateWidth: function() {
      this.glyphs = [];
      this.width = 0;
      for (var i = 0; i < this.positions.length; ++i) {
        var fret = this.positions[i].fret;
        if (this.ghost) fret = "(" + fret + ")";
        var glyph = Vex.Flow.tabToGlyph(fret);
        this.glyphs.push(glyph);
        this.width = (glyph.width > this.width) ? glyph.width : this.width;
      }
    },

    // Set the `stave` to the note
    setStave: function(stave) {
      var superclass = Vex.Flow.TabNote.superclass;
      superclass.setStave.call(this, stave);
      this.context = stave.context;
      this.width = 0;

      // Calculate the fret number width based on font used
      var i;
      if (this.context) {
        for (i = 0; i < this.glyphs.length; ++i) {
          var text = "" + this.glyphs[i].text;
          if (text.toUpperCase() != "X")
            this.glyphs[i].width = this.context.measureText(text).width;
          this.width = (this.glyphs[i].width > this.width) ?
            this.glyphs[i].width : this.width;
        }
      }

      var ys = [];

      // Setup y coordinates for score.
      for (i = 0; i < this.positions.length; ++i) {
        var line = this.positions[i].str;
        ys.push(this.stave.getYForLine(line - 1));
      }

      return this.setYs(ys);
    },

    // Get the fret positions for the note
    getPositions: function() { return this.positions; },

    // Add self to the provided modifier context `mc`
    addToModifierContext: function(mc) {
      this.setModifierContext(mc);
      for (var i = 0; i < this.modifiers.length; ++i) {
        this.modifierContext.addModifier(this.modifiers[i]);
      }
      this.modifierContext.addModifier(this);
      this.preFormatted = false;
      return this;
    },

    // Get the `x` coordinate to the right of the note
    getTieRightX: function() {
      var tieStartX = this.getAbsoluteX();
      var note_glyph_width = this.glyph.head_width;
      tieStartX += (note_glyph_width / 2);
      tieStartX += ((-this.width / 2) + this.width + 2);

      return tieStartX;
    },

    // Get the `x` coordinate to the left of the note
    getTieLeftX: function() {
      var tieEndX = this.getAbsoluteX();
      var note_glyph_width = this.glyph.head_width;
      tieEndX += (note_glyph_width / 2);
      tieEndX -= ((this.width / 2) + 2);

      return tieEndX;
    },

    // Get the default `x` and `y` coordinates for a modifier at a specific
    // `position` at a fret position `index`
    getModifierStartXY: function(position, index) {
      if (!this.preFormatted) throw new Vex.RERR("UnformattedNote",
          "Can't call GetModifierStartXY on an unformatted note");

      if (this.ys.length === 0) throw new Vex.RERR("NoYValues",
          "No Y-Values calculated for this note.");

      var x = 0;
      if (position == Vex.Flow.Modifier.Position.LEFT) {
        x = -1 * 2;  // extra_left_px
      } else if (position == Vex.Flow.Modifier.Position.RIGHT) {
        x = this.width + 2; // extra_right_px
      } else if (position == Vex.Flow.Modifier.Position.BELOW ||
                 position == Vex.Flow.Modifier.Position.ABOVE) {
          var note_glyph_width = this.glyph.head_width;
          x = note_glyph_width / 2;
      }

      return {x: this.getAbsoluteX() + x, y: this.ys[index]};
    },

    // Get the default line for rest
    getLineForRest: function() { return this.positions[0].str; },

    // Pre-render formatting
    preFormat: function() {
      if (this.preFormatted) return;
      if (this.modifierContext) this.modifierContext.preFormat();
      // width is already set during init()
      this.setPreFormatted(true);
    },

    // Get the x position for the stem
    getStemX: function() { return this.getCenterGlyphX(); },

    // Get the y position for the stem
    getStemY: function(){
      var num_lines = this.stave.getNumLines();

      // The decimal staff line amounts provide optimal spacing between the
      // fret number and the stem
      var stemUpLine = -0.5;
      var stemDownLine = num_lines - 0.5;
      var stemStartLine = Stem.UP === this.stem_direction ? stemUpLine : stemDownLine;

      return this.stave.getYForLine(stemStartLine);
    },

    // Get the stem extents for the tabnote
    getStemExtents: function() {
      var stem_base_y = this.getStemY();
      var stem_top_y = stem_base_y + (Stem.HEIGHT * -this.stem_direction);

      return { topY: stem_top_y , baseY: stem_base_y};
    },

    // Draw the fal onto the context
    drawFlag: function() {
      var render_stem = this.beam == null && this.render_options.draw_stem;
      var render_flag = this.beam == null && render_stem;

      // Now it's the flag's turn.
      if (this.glyph.flag && render_flag) {
        var flag_x = this.getStemX() + 1 ;
        var flag_y = this.getStemY() - (this.stem.getHeight());
        var flag_code;

        if (this.stem_direction == Stem.DOWN) {
          // Down stems have flags on the left.
          flag_code = this.glyph.code_flag_downstem;
        } else {
          // Up stems have flags on the left.
          flag_code = this.glyph.code_flag_upstem;
        }

        // Draw the Flag
        Vex.Flow.renderGlyph(this.context, flag_x, flag_y,
            this.render_options.glyph_font_scale, flag_code);
      }
    },

    // Render the modifiers onto the context
    drawModifiers: function() {
      // Draw the modifiers
      this.modifiers.forEach(function(modifier) {
        // Only draw the dots if enabled
        if (modifier.getCategory() === 'dots' && !this.render_options.draw_dots) return;

        modifier.setContext(this.context);
        modifier.draw();
      }, this);
    },

    // Render the stem extension through the fret positions
    drawStemThrough: function() {
      var stem_x = this.getStemX();
      var stem_y = this.getStemY();
      var ctx = this.context;

      var stem_through = this.render_options.draw_stem_through_stave;
      var draw_stem = this.render_options.draw_stem;
      if (draw_stem && stem_through) {
        var total_lines = this.stave.getNumLines();
        var strings_used = this.positions.map(function(position) {
          return position.str;
        });

        var unused_strings = getUnusedStringGroups(total_lines, strings_used);
        var stem_lines = getPartialStemLines(stem_y, unused_strings,
                              this.getStave(), this.getStemDirection());

        // Fine tune x position to match default stem
        if (!this.beam || this.getStemDirection() === 1) {
          stem_x += (Stem.WIDTH / 2);
        }

        ctx.save();
        ctx.setLineWidth(Stem.WIDTH);
        stem_lines.forEach(function(bounds) {
          if (bounds.length === 0) return;

          ctx.beginPath();
          ctx.moveTo(stem_x, bounds[0]);
          ctx.lineTo(stem_x, bounds[bounds.length - 1]);
          ctx.stroke();
          ctx.closePath();
        });
        ctx.restore();
      }
    },

    // Render the fret positions onto the context
    drawPositions: function() {
      var ctx = this.context;
      var x = this.getAbsoluteX();
      var ys = this.ys;
      var y;

      for (var i = 0; i < this.positions.length; ++i) {
        y = ys[i];

        var glyph = this.glyphs[i];

        // Center the fret text beneath the notation note head
        var note_glyph_width = this.glyph.head_width;
        var tab_x = x + (note_glyph_width / 2) - (glyph.width / 2);

        ctx.clearRect(tab_x - 2, y - 3, glyph.width + 4, 6);

        if (glyph.code) {
          Vex.Flow.renderGlyph(ctx, tab_x, y + 5 + glyph.shift_y,
              this.render_options.glyph_font_scale, glyph.code);
        } else {
          var text = glyph.text.toString();
          ctx.fillText(text, tab_x, y + 5);
        }
      }
    },

    // The main rendering function for the entire note
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      if (!this.stave) throw new Vex.RERR("NoStave", "Can't draw without a stave.");
      if (this.ys.length === 0) throw new Vex.RERR("NoYValues",
          "Can't draw note without Y values.");

      var render_stem = this.beam == null && this.render_options.draw_stem;

      this.drawPositions();
      this.drawStemThrough();

      var stem_x = this.getStemX();
      var stem_y = this.getStemY();
      if (render_stem) {
        this.drawStem({
          x_begin: stem_x,
          x_end: stem_x,
          y_top: stem_y,
          y_bottom: stem_y,
          y_extend: 0,
          stem_extension: this.getStemExtension(),
          stem_direction: this.stem_direction
        });
      }

      this.drawFlag();
      this.drawModifiers();
    }
  });

  // ## Private Helpers
  //
  // Gets the unused strings grouped together if consecutive.
  //
  // Parameters:
  // * num_lines - The number of lines
  // * strings_used - An array of numbers representing which strings have fret positions
  function getUnusedStringGroups(num_lines, strings_used) {
    var stem_through = [];
    var group = [];
    for (var string = 1; string <= num_lines ; string++) {
      var is_used = strings_used.indexOf(string) > -1;

      if (!is_used) {
        group.push(string);
      } else {
        stem_through.push(group);
        group = [];
      }
    }
    if (group.length > 0) stem_through.push(group);

    return stem_through;
  }

  // Gets groups of points that outline the partial stem lines
  // between fret positions
  //
  // Parameters:
  // * stem_Y - The `y` coordinate the stem is located on
  // * unused_strings - An array of groups of unused strings
  // * stave - The stave to use for reference
  // * stem_direction - The direction of the stem
  function getPartialStemLines (stem_y, unused_strings, stave, stem_direction) {
    var up_stem = stem_direction !== 1;
    var down_stem = stem_direction !== -1;

    var line_spacing = stave.getSpacingBetweenLines();
    var total_lines = stave.getNumLines();

    var stem_lines = [];

    unused_strings.forEach(function(strings) {
      var containsLastString = strings.indexOf(total_lines) > -1;
      var containsFirstString =  strings.indexOf(1) > -1;

      if ((up_stem && containsFirstString) ||
         (down_stem && containsLastString)) {
        return;
      }

      // If there's only one string in the group, push a duplicate value.
      // We do this because we need 2 strings to convert into upper/lower y
      // values.
      if (strings.length === 1) {
        strings.push(strings[0]);
      }

      var line_ys = [];
      // Iterate through each group string and store it's y position
      strings.forEach(function(string, index, strings) {
        var isTopBound = string === 1;
        var isBottomBound = string === total_lines;

        // Get the y value for the appropriate staff line,
        // we adjust for a 0 index array, since string numbers are index 1
        var y = stave.getYForLine(string - 1);

        // Unless the string is the first or last, add padding to each side
        // of the line
        if (index === 0 && !isTopBound) {
          y -= line_spacing/2 - 1;
        } else if (index === strings.length - 1 && !isBottomBound){
          y += line_spacing/2 - 1;
        }

        // Store the y value
        line_ys.push(y);

        // Store a subsequent y value connecting this group to the main
        // stem above/below the stave if it's the top/bottom string
        if (stem_direction === 1 && isTopBound) {
          line_ys.push(stem_y - 2);
        } else if (stem_direction === -1 && isBottomBound) {
          line_ys.push(stem_y + 2);
        }
      });

      // Add the sorted y values to the
      stem_lines.push(line_ys.sort(function(a, b) {
        return a - b;
      }));
    });

    return stem_lines;
  }

  return TabNote;
}());

// Vex Flow Notation
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Muthanna 2010
//
// Requires vex.js.

/** @constructor */
Vex.Flow.GhostNote = (function() {
  function GhostNote(duration) {
    if (arguments.length > 0) this.init(duration);
  }

  Vex.Inherit(GhostNote, Vex.Flow.StemmableNote, {
    init: function(parameter) {
      // Sanity check
      if (!parameter) {
        throw new Vex.RuntimeError("BadArguments",
            "Ghost note must have valid initialization data to identify " +
            "duration.");
      }

      var note_struct;

      // Preserve backwards-compatibility
      if (typeof(parameter) === "string") {
        note_struct = { duration: parameter };
      } else if (typeof(parameter) === "object") {
        note_struct = parameter;
      } else {
        throw new Vex.RuntimeError("BadArguments",
            "Ghost note must have valid initialization data to identify " +
            "duration.");
      }

      GhostNote.superclass.init.call(this, note_struct);

      // Note properties
      this.setWidth(0);
    },

    isRest: function() { return true; },

    setStave: function(stave) { GhostNote.superclass.setStave.call(this, stave); },

    addToModifierContext: function()
      { /* intentionally overridden */ return this; },

    preFormat: function() {
      this.setPreFormatted(true);
      return this;
    },

    draw: function() {
      if (!this.stave) throw new Vex.RERR("NoStave", "Can't draw without a stave.");

      // Draw the modifiers
      for (var i = 0; i < this.modifiers.length; ++i) {
        var modifier = this.modifiers[i];
        modifier.setContext(this.context);
        modifier.draw();
      }
    }
  });

  return GhostNote;
}());

// Vex Flow Notation
// Copyright Mohit Muthanna 2010
//
// Author Taehoon Moon 2014

/** @constructor */
Vex.Flow.ClefNote = (function() {
  function ClefNote(clef, size, annotation) { this.init(clef, size, annotation); }

  Vex.Inherit(ClefNote, Vex.Flow.Note, {
    init: function(clef, size, annotation) {
      ClefNote.superclass.init.call(this, {duration: "b"});
      
      this.setClef(clef, size, annotation);

      // Note properties
      this.ignore_ticks = true;
    },

    setClef: function(clef, size, annotation) {
      this.clef_obj = new Vex.Flow.Clef(clef, size, annotation);
      this.clef = this.clef_obj.clef;
      this.glyph = new Vex.Flow.Glyph(this.clef.code, this.clef.point);
      this.setWidth(this.glyph.getMetrics().width);
      return this;
    },

    getClef: function() {
      return this.clef;
    },

    setContext: function(context){
      this.context = context;
      this.glyph.setContext(this.context);
      return this;
    },

    setStave: function(stave) {
      var superclass = Vex.Flow.ClefNote.superclass;
      superclass.setStave.call(this, stave);
    },

    getBoundingBox: function() {
      return new Vex.Flow.BoundingBox(0, 0, 0, 0);
    },

    addToModifierContext: function() {
      /* overridden to ignore */
      return this;
    },

    getCategory: function() {
      return "clefnote";
    },

    preFormat: function() {
      this.setPreFormatted(true);
      return this;
    },

    draw: function() {
      if (!this.stave) throw new Vex.RERR("NoStave", "Can't draw without a stave.");
      
      if (!this.glyph.getContext()) {
        this.glyph.setContext(this.context);
      }
      var abs_x = this.getAbsoluteX();

      this.glyph.setStave(this.stave);
      this.glyph.setYShift(
        this.stave.getYForLine(this.clef.line) - this.stave.getYForGlyphs());
      this.glyph.renderToStave(abs_x);
      
      // If the Vex.Flow.Clef has an annotation, such as 8va, draw it.
      if (this.clef_obj.annotation !== undefined) {
        var attachment = new Vex.Flow.Glyph(this.clef_obj.annotation.code, this.clef_obj.annotation.point);
        if (!attachment.getContext()) {
            attachment.setContext(this.context);
        }
        attachment.setStave(this.stave);
        attachment.setYShift(
          this.stave.getYForLine(this.clef_obj.annotation.line) - this.stave.getYForGlyphs());
        attachment.setXShift(this.clef_obj.annotation.x_shift);
        attachment.renderToStave(abs_x);
      }
      
    }
  });

  return ClefNote;
}());

// Vex Flow Notation
// Copyright Mohit Muthanna 2010
//
// Author Taehoon Moon 2014

/** @constructor */
Vex.Flow.TimeSigNote = (function() {
  function TimeSigNote(timeSpec, customPadding) {
    if (arguments.length > 0) this.init(timeSpec, customPadding);
  }

  Vex.Inherit(TimeSigNote, Vex.Flow.Note, {
    init: function(timeSpec, customPadding) {
      TimeSigNote.superclass.init.call(this, {duration: "b"});

      var timeSignature = new Vex.Flow.TimeSignature(timeSpec, customPadding);
      this.timeSig = timeSignature.getTimeSig();
      this.setWidth(this.timeSig.glyph.getMetrics().width);

      // Note properties
      this.ignore_ticks = true;
    },

    setStave: function(stave) {
      var superclass = Vex.Flow.TimeSigNote.superclass;
      superclass.setStave.call(this, stave);
    },

    getBoundingBox: function() {
      return new Vex.Flow.BoundingBox(0, 0, 0, 0);
    },

    addToModifierContext: function() {
      /* overridden to ignore */
      return this;
    },

    preFormat: function() {
      this.setPreFormatted(true);
      return this;
    },

    draw: function() {
      if (!this.stave) throw new Vex.RERR("NoStave", "Can't draw without a stave.");
      
      if (!this.timeSig.glyph.getContext()) {
        this.timeSig.glyph.setContext(this.context);
      }

      this.timeSig.glyph.setStave(this.stave);
      this.timeSig.glyph.setYShift(
        this.stave.getYForLine(this.timeSig.line) - this.stave.getYForGlyphs());
      this.timeSig.glyph.renderToStave(this.getAbsoluteX());
    }
  });

  return TimeSigNote;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements `Beams` that span over a set of `StemmableNotes`.
//
// Requires: vex.js, vexmusic.js, note.js
Vex.Flow.Beam = (function() {
  function Beam(notes, auto_stem) {
    if (arguments.length > 0) this.init(notes, auto_stem);
  }

  var Stem = Vex.Flow.Stem;

  // ## Prototype Methods
  Beam.prototype = {
    init: function(notes, auto_stem) {
      if (!notes || notes == []) {
        throw new Vex.RuntimeError("BadArguments", "No notes provided for beam.");
      }

      if (notes.length == 1) {
        throw new Vex.RuntimeError("BadArguments", "Too few notes for beam.");
      }

      // Validate beam line, direction and ticks.
      this.ticks = notes[0].getIntrinsicTicks();

      if (this.ticks >= Vex.Flow.durationToTicks("4")) {
        throw new Vex.RuntimeError("BadArguments",
            "Beams can only be applied to notes shorter than a quarter note.");
      }

      var i; // shared iterator
      var note;

      this.stem_direction = Stem.UP;

      for (i = 0; i < notes.length; ++i) {
        note = notes[i];
        if (note.hasStem()) {
          this.stem_direction = note.getStemDirection();
          break;
        }
      }

      var stem_direction = this.stem_direction;
      // Figure out optimal stem direction based on given notes
      if (auto_stem && notes[0].getCategory() === 'stavenotes')  {
        stem_direction = calculateStemDirection(notes);
      } else if (auto_stem && notes[0].getCategory() === 'tabnotes') {
        // Auto Stem TabNotes
        var stem_weight = notes.reduce(function(memo, note) {
          return memo + note.stem_direction;
        }, 0);

        stem_direction = stem_weight > -1 ? Stem.UP : Stem.DOWN;
      }

      // Apply stem directions and attach beam to notes
      for (i = 0; i < notes.length; ++i) {
        note = notes[i];
        if (auto_stem) {
          note.setStemDirection(stem_direction);
          this.stem_direction = stem_direction;
        }
        note.setBeam(this);
      }

      this.postFormatted = false;
      this.notes = notes;
      this.beam_count = this.getBeamCount();
      this.break_on_indices = [];
      this.render_options = {
        beam_width: 5,
        max_slope: 0.25,
        min_slope: -0.25,
        slope_iterations: 20,
        slope_cost: 100,
        show_stemlets: false,
        stemlet_extension: 7,
        partial_beam_length: 10,
        flat_beams: false,
        min_flat_beam_offset: 15
      };
    },

    // The the rendering `context`
    setContext: function(context) { this.context = context; return this; },

    // Get the notes in this beam
    getNotes: function() { return this.notes; },

    // Get the max number of beams in the set of notes
    getBeamCount: function(){
      var beamCounts =  this.notes.map(function(note) {
        return note.getGlyph().beam_count;
      });

      var maxBeamCount =  beamCounts.reduce(function(max, beamCount) {
          return beamCount > max ? beamCount : max;
      });

      return maxBeamCount;
    },

    // Set which note `indices` to break the secondary beam at
    breakSecondaryAt: function(indices) {
      this.break_on_indices = indices;
      return this;
    },

    // Return the y coordinate for linear function
    getSlopeY: function(x, first_x_px, first_y_px, slope) {
      return first_y_px + ((x - first_x_px) * slope);
    },

    // Calculate the best possible slope for the provided notes
    calculateSlope: function() {
      var first_note = this.notes[0];
      var first_y_px = first_note.getStemExtents().topY;
      var first_x_px = first_note.getStemX();

      var inc = (this.render_options.max_slope - this.render_options.min_slope) /
          this.render_options.slope_iterations;
      var min_cost = Number.MAX_VALUE;
      var best_slope = 0;
      var y_shift = 0;

      // iterate through slope values to find best weighted fit
      for (var slope = this.render_options.min_slope;
           slope <= this.render_options.max_slope;
           slope += inc) {
        var total_stem_extension = 0;
        var y_shift_tmp = 0;

        // iterate through notes, calculating y shift and stem extension
        for (var i = 1; i < this.notes.length; ++i) {
          var note = this.notes[i];

          var x_px = note.getStemX();
          var y_px = note.getStemExtents().topY;
          var slope_y_px = this.getSlopeY(x_px, first_x_px, first_y_px, slope) + y_shift_tmp;

          // beam needs to be shifted up to accommodate note
          if (y_px * this.stem_direction < slope_y_px * this.stem_direction) {
            var diff =  Math.abs(y_px - slope_y_px);
            y_shift_tmp += diff * -this.stem_direction;
            total_stem_extension += (diff * i);
          } else { // beam overshoots note, account for the difference
            total_stem_extension += (y_px - slope_y_px) * this.stem_direction;
          }

        }

        var last_note = this.notes[this.notes.length - 1];
        var first_last_slope = ((last_note.getStemExtents().topY - first_y_px) /
                (last_note.getStemX() - first_x_px));
        // most engraving books suggest aiming for a slope about half the angle of the
        // difference between the first and last notes' stem length;
        var ideal_slope = first_last_slope / 2;
        var distance_from_ideal = Math.abs(ideal_slope - slope);

        // This tries to align most beams to something closer to the ideal_slope, but
        // doesn't go crazy. To disable, set this.render_options.slope_cost = 0
        var cost = this.render_options.slope_cost * distance_from_ideal +
            Math.abs(total_stem_extension);

        // update state when a more ideal slope is found
        if (cost < min_cost) {
          min_cost = cost;
          best_slope = slope;
          y_shift = y_shift_tmp;
        }
      }

      this.slope = best_slope;
      this.y_shift = y_shift;
    },

    // Calculate a slope and y-shift for flat beams
    calculateFlatSlope: function() {

      // If a flat beam offset has not yet been supplied or calculated,
      // generate one based on the notes in this particular note group
      var total = 0;
      var extreme_y = 0;  // Store the highest or lowest note here
      var extreme_beam_count = 0;  // The beam count of the extreme note
      var current_extreme = 0;
      for (var i = 0; i < this.notes.length; i++) {

        // Total up all of the offsets so we can average them out later
        var note = this.notes[i];
        var top_y = note.getStemExtents().topY;
        total += top_y;

        // Store the highest (stems-up) or lowest (stems-down) note so the
        //  offset can be adjusted in case the average isn't enough
        if (this.stem_direction === Stem.DOWN && current_extreme < top_y) {
          current_extreme = top_y;
          extreme_y = note.getNoteHeadBounds().y_bottom;
          extreme_beam_count = note.getBeamCount();
        } else if (this.stem_direction === Stem.UP && (current_extreme === 0 || current_extreme > top_y)) {
          current_extreme = top_y;
          extreme_y = note.getNoteHeadBounds().y_top;
          extreme_beam_count = note.getBeamCount();
        }
      }

      // Average the offsets to try and come up with a reasonable one that
      //  works for all of the notes in the beam group.
      var offset = total / this.notes.length;

      // In case the average isn't long enough, add or subtract some more
      //  based on the highest or lowest note (again, based on the stem
      //  direction). This also takes into account the added height due to
      //  the width of the beams.
      var beam_width = this.render_options.beam_width * 1.5;
      var extreme_test = this.render_options.min_flat_beam_offset + (extreme_beam_count * beam_width);
      var new_offset = extreme_y + (extreme_test * -this.stem_direction);
      if (this.stem_direction === Stem.DOWN && offset < new_offset) {
        offset = extreme_y + extreme_test;
      } else if (this.stem_direction === Stem.UP && offset > new_offset) {
        offset = extreme_y - extreme_test;
      }
      if (!this.render_options.flat_beam_offset) {

        // Set the offset for the group based on the calculations above.
        this.render_options.flat_beam_offset = offset;
      } else if (this.stem_direction === Stem.DOWN && offset > this.render_options.flat_beam_offset) {
        this.render_options.flat_beam_offset = offset;
      } else if (this.stem_direction === Stem.UP && offset < this.render_options.flat_beam_offset) {
        this.render_options.flat_beam_offset = offset;
      }

      // for flat beams, the slope and y_shift are simply 0
      this.slope = 0;
      this.y_shift = 0;
    },

    // Create new stems for the notes in the beam, so that each stem
    // extends into the beams.
    applyStemExtensions: function(){
      var first_note = this.notes[0];
      var first_y_px = first_note.getStemExtents().topY;

      // If rendering flat beams, and an offset exists, set the y-coordinate to
      //  the offset so the stems all end at the beam offset.
      if (this.render_options.flat_beams && this.render_options.flat_beam_offset) {
        first_y_px = this.render_options.flat_beam_offset;
      }
      var first_x_px = first_note.getStemX();

      for (var i = 0; i < this.notes.length; ++i) {
        var note = this.notes[i];

        var x_px = note.getStemX();
        var y_extents = note.getStemExtents();
        var base_y_px = y_extents.baseY;
        var top_y_px = y_extents.topY;

        // If flat beams, set the top of the stem to the offset, rather than
        //  relying on the topY value from above.
        if (this.render_options.flat_beams) {
          top_y_px = first_y_px;
        }

        // For harmonic note heads, shorten stem length by 3 pixels
        base_y_px += this.stem_direction * note.glyph.stem_offset;

        // Don't go all the way to the top (for thicker stems)
        var y_displacement = Vex.Flow.STEM_WIDTH;

        if (!note.hasStem()) {
          if (note.isRest() && this.render_options.show_stemlets) {
            var centerGlyphX = note.getCenterGlyphX();

            var width = this.render_options.beam_width;
            var total_width = ((this.beam_count - 1)* width * 1.5) + width;

            var stemlet_height = (total_width - y_displacement +
              this.render_options.stemlet_extension);

            var beam_y = this.getSlopeY(centerGlyphX, first_x_px,
                            first_y_px, this.slope) + this.y_shift;
            var start_y = beam_y + (Vex.Flow.Stem.HEIGHT * this.stem_direction);
            var end_y = beam_y + (stemlet_height * this.stem_direction);

            // Draw Stemlet
            note.setStem(new Vex.Flow.Stem({
              x_begin: centerGlyphX,
              x_end: centerGlyphX,
              y_bottom: this.stem_direction === Stem.UP ? end_y : start_y,
              y_top: this.stem_direction === Stem.UP ? start_y : end_y,
              y_extend: y_displacement,
              stem_extension: -1, // To avoid protruding through the beam
              stem_direction: this.stem_direction
            }));
          }

          continue;
        }

        var slope_y = this.getSlopeY(x_px, first_x_px, first_y_px,
                        this.slope) + this.y_shift;

        note.setStem(new Vex.Flow.Stem({
          x_begin: x_px - (Vex.Flow.STEM_WIDTH/2),
          x_end: x_px,
          y_top: this.stem_direction === Stem.UP ? top_y_px : base_y_px,
          y_bottom: this.stem_direction === Stem.UP ? base_y_px :  top_y_px,
          y_extend: y_displacement,
          stem_extension: Math.abs(top_y_px - slope_y) - Stem.HEIGHT - 1,
          stem_direction: this.stem_direction
        }));
      }
    },

    // Get the x coordinates for the beam lines of specific `duration`
    getBeamLines: function(duration) {
      var beam_lines = [];
      var beam_started = false;
      var current_beam = null;
      var partial_beam_length = this.render_options.partial_beam_length;
      var previous_should_break = false;
      var tick_tally = 0;
      for (var i = 0; i < this.notes.length; ++i) {
        var note = this.notes[i];

        // See if we need to break secondary beams on this note.
        var ticks = note.getIntrinsicTicks();
        tick_tally += ticks;
        var should_break = false;

        // 8th note beams are always drawn.
        if (parseInt(duration) >= 8) {

          // First, check to see if any indices were set up through breakSecondaryAt()
          should_break = this.break_on_indices.indexOf(i) !== -1;

          // If the secondary breaks were auto-configured in the render options,
          //  handle that as well.
          if (this.render_options.secondary_break_ticks && tick_tally >= this.render_options.secondary_break_ticks) {
            tick_tally = 0;
            should_break = true;
          }
        }
        var note_gets_beam = ticks < Vex.Flow.durationToTicks(duration);
        var stem_x = note.isRest() ? note.getCenterGlyphX() : note.getStemX();

        // Check to see if the next note in the group will get a beam at this
        //  level. This will help to inform the partial beam logic below.
        var next_note = this.notes[i + 1];
        var beam_next = next_note && next_note.getIntrinsicTicks() < Vex.Flow.durationToTicks(duration);
        if (note_gets_beam) {

          // This note gets a beam at the current level
          if (beam_started) {

            // We're currently in the middle of a beam. Just continue it on to
            //  the stem X of the current note.
            current_beam = beam_lines[beam_lines.length - 1];
            current_beam.end = stem_x;

            // If a secondary beam break is set up, end the beam right now.
            if (should_break) {
              beam_started = false;
              if (next_note && !beam_next && current_beam.end === null) {

                // This note gets a beam,.but the next one does not. This means
                //  we need a partial pointing right.
                current_beam.end = current_beam.start - partial_beam_length;
              }
            }
          } else {

            // No beam started yet. Start a new one.
            current_beam = { start: stem_x, end: null };
            beam_started = true;
            if (!beam_next) {

              // The next note doesn't get a beam. Draw a partial.
              if((previous_should_break || i === 0) && next_note) {

                // This is the first note (but not the last one), or it is
                //  following a secondary break. Draw a partial to the right.
                current_beam.end = current_beam.start + partial_beam_length;
              } else {

                // By default, draw a partial to the left.
                current_beam.end = current_beam.start - partial_beam_length;
              }
            } else if (should_break) {

              // This note should have a secondary break after it. Even though
              //  we just started a beam, it needs to end immediately.
              current_beam.end = current_beam.start - partial_beam_length;
              beam_started = false;
            }
            beam_lines.push(current_beam);
          }
        } else {

          // The current note does not get a beam.
          beam_started = false;
        }

        // Store the secondary break flag to inform the partial beam logic in
        //  the next iteration of the loop.
        previous_should_break = should_break;
      }

      // Add a partial beam pointing left if this is the last note in the group
      var last_beam = beam_lines[beam_lines.length - 1];
      if (last_beam && last_beam.end === null) {
        last_beam.end = last_beam.start - partial_beam_length;
      }
      return beam_lines;
    },

    // Render the stems for each notes
    drawStems: function() {
      this.notes.forEach(function(note) {
        if (note.getStem()) {
          note.getStem().setContext(this.context).draw();
        }
      }, this);
    },

    // Render the beam lines
    drawBeamLines: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      var valid_beam_durations = ["4", "8", "16", "32", "64"];

      var first_note = this.notes[0];
      var last_note = this.notes[this.notes.length - 1];

      var first_y_px = first_note.getStemExtents().topY;
      var last_y_px = last_note.getStemExtents().topY;

      // For flat beams, set the first and last Y to the offset, rather than
      //  using the note's stem extents.
      if (this.render_options.flat_beams && this.render_options.flat_beam_offset) {
        first_y_px = this.render_options.flat_beam_offset;
        last_y_px = this.render_options.flat_beam_offset;
      }

      var first_x_px = first_note.getStemX();

      var beam_width = this.render_options.beam_width * this.stem_direction;

      // Draw the beams.
      for (var i = 0; i < valid_beam_durations.length; ++i) {
        var duration = valid_beam_durations[i];
        var beam_lines = this.getBeamLines(duration);

        for (var j = 0; j < beam_lines.length; ++j) {
          var beam_line = beam_lines[j];
          var first_x = beam_line.start - (this.stem_direction == Stem.DOWN ? Vex.Flow.STEM_WIDTH/2:0);
          var first_y = this.getSlopeY(first_x, first_x_px, first_y_px, this.slope);

          var last_x = beam_line.end +
            (this.stem_direction == 1 ? (Vex.Flow.STEM_WIDTH/3):(-Vex.Flow.STEM_WIDTH/3));
          var last_y = this.getSlopeY(last_x, first_x_px, first_y_px, this.slope);

          this.context.beginPath();
          this.context.moveTo(first_x, first_y + this.y_shift);
          this.context.lineTo(first_x, first_y + beam_width + this.y_shift);
          this.context.lineTo(last_x + 1, last_y + beam_width + this.y_shift);
          this.context.lineTo(last_x + 1, last_y + this.y_shift);
          this.context.closePath();
          this.context.fill();
        }

        first_y_px += beam_width * 1.5;
        last_y_px += beam_width * 1.5;
      }
    },

    // Pre-format the beam
    preFormat: function() { return this; },

    // Post-format the beam. This can only be called after
    // the notes in the beam have both `x` and `y` values. ie: they've
    // been formatted and have staves
    postFormat: function() {
      if (this.postFormatted) return;

      // Calculate a smart slope if we're not forcing the beams to be flat.
      if(this.render_options.flat_beams) {
        this.calculateFlatSlope();
      } else {
        this.calculateSlope();
      }
      this.applyStemExtensions();

      this.postFormatted = true;
    },

    // Render the beam to the canvas context
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      if (this.unbeamable) return;

      if (!this.postFormatted) {
        this.postFormat();
      }

      this.drawStems();
      this.drawBeamLines();

      return true;
    }
  };

  function calculateStemDirection(notes) {
    var lineSum = 0;
    notes.forEach(function(note) {
      if (note.keyProps) {
        note.keyProps.forEach(function(keyProp){
          lineSum += (keyProp.line - 3);
        });
      }
    });

    if (lineSum >= 0)
      return Stem.DOWN;
    return Stem.UP;
  }

  // ## Static Methods
  //
  // Gets the default beam groups for a provided time signature.
  // Attempts to guess if the time signature is not found in table.
  // Currently this is fairly naive.
  Beam.getDefaultBeamGroups = function(time_sig){
    if (!time_sig || time_sig == "c") time_sig = "4/4";

    var defaults = {
      '1/2' :  ['1/2'],
      '2/2' :  ['1/2'],
      '3/2' :  ['1/2'],
      '4/2' :  ['1/2'],

      '1/4' :  ['1/4'],
      '2/4' :  ['1/4'],
      '3/4' :  ['1/4'],
      '4/4' :  ['1/4'],

      '1/8' :  ['1/8'],
      '2/8' :  ['2/8'],
      '3/8' :  ['3/8'],
      '4/8' :  ['2/8'],

      '1/16' : ['1/16'],
      '2/16' : ['2/16'],
      '3/16' : ['3/16'],
      '4/16' : ['2/16']
    };

    var Fraction = Vex.Flow.Fraction;
    var groups = defaults[time_sig];

    if (!groups) {
      // If no beam groups found, naively determine
      // the beam groupings from the time signature
      var beatTotal = parseInt(time_sig.split('/')[0], 10);
      var beatValue = parseInt(time_sig.split('/')[1], 10);

      var tripleMeter = beatTotal % 3 === 0;

      if (tripleMeter) {
        return [new Fraction(3, beatValue)];
      } else if (beatValue > 4) {
        return [new Fraction(2, beatValue)];
      } else if (beatValue <= 4) {
        return [new Fraction(1, beatValue)];
      }
    } else {
      return groups.map(function(group) {
        return new Fraction().parse(group);
      });
    }
  };

  // A helper function to automatically build basic beams for a voice. For more
  // complex auto-beaming use `Beam.generateBeams()`.
  //
  // Parameters:
  // * `voice` - The voice to generate the beams for
  // * `stem_direction` - A stem direction to apply to the entire voice
  // * `groups` - An array of `Fraction` representing beat groupings for the beam
  Beam.applyAndGetBeams = function(voice, stem_direction, groups) {
    return Beam.generateBeams(voice.getTickables(), {
      groups: groups,
      stem_direction: stem_direction
    });
  };

  // A helper function to autimatically build beams for a voice with
  // configuration options.
  //
  // Example configuration object:
  //
  // ```
  // config = {
  //   groups: [new Vex.Flow.Fraction(2, 8)],
  //   stem_direction: -1,
  //   beam_rests: true,
  //   beam_middle_only: true,
  //   show_stemlets: false
  // };
  // ```
  //
  // Parameters:
  // * `notes` - An array of notes to create the beams for
  // * `config` - The configuration object
  //    * `groups` - Array of `Fractions` that represent the beat structure to beam the notes
  //    * `stem_direction` - Set to apply the same direction to all notes
  //    * `beam_rests` - Set to `true` to include rests in the beams
  //    * `beam_middle_only` - Set to `true` to only beam rests in the middle of the beat
  //    * `show_stemlets` - Set to `true` to draw stemlets for rests
  //    * `maintain_stem_directions` - Set to `true` to not apply new stem directions
  //
  Beam.generateBeams = function(notes, config) {

    if (!config) config = {};

    if (!config.groups || !config.groups.length) {
      config.groups = [new Vex.Flow.Fraction(2, 8)];
    }

    // Convert beam groups to tick amounts
    var tickGroups = config.groups.map(function(group) {
      if (!group.multiply) {
        throw new Vex.RuntimeError("InvalidBeamGroups",
          "The beam groups must be an array of Vex.Flow.Fractions");
      }
      return group.clone().multiply(Vex.Flow.RESOLUTION, 1);
    });

    var unprocessedNotes = notes;
    var currentTickGroup = 0;
    var noteGroups       = [];
    var currentGroup     = [];

    function getTotalTicks(vf_notes){
      return vf_notes.reduce(function(memo,note){
        return note.getTicks().clone().add(memo);
      }, new Vex.Flow.Fraction(0, 1));
    }

    function nextTickGroup() {
      if (tickGroups.length - 1 > currentTickGroup) {
        currentTickGroup += 1;
      } else {
        currentTickGroup = 0;
      }
    }

    function createGroups(){
      var nextGroup = [];

      unprocessedNotes.forEach(function(unprocessedNote){
        nextGroup    = [];
        if (unprocessedNote.shouldIgnoreTicks()) {
          noteGroups.push(currentGroup);
          currentGroup = nextGroup;
          return; // Ignore untickables (like bar notes)
        }

        currentGroup.push(unprocessedNote);
        var ticksPerGroup = tickGroups[currentTickGroup].clone();
        var totalTicks = getTotalTicks(currentGroup);

        // Double the amount of ticks in a group, if it's an unbeamable tuplet
        var unbeamable = Vex.Flow.durationToNumber(unprocessedNote.duration) < 8;
        if (unbeamable && unprocessedNote.tuplet) {
          ticksPerGroup.numerator *= 2;
        }

        // If the note that was just added overflows the group tick total
        if (totalTicks.greaterThan(ticksPerGroup)) {
          // If the overflow note can be beamed, start the next group
          // with it. Unbeamable notes leave the group overflowed.
          if (!unbeamable) {
            nextGroup.push(currentGroup.pop());
          }
          noteGroups.push(currentGroup);
          currentGroup = nextGroup;
          nextTickGroup();
        } else if (totalTicks.equals(ticksPerGroup)) {
          noteGroups.push(currentGroup);
          currentGroup = nextGroup;
          nextTickGroup();
        }
      });

      // Adds any remainder notes
      if (currentGroup.length > 0)
        noteGroups.push(currentGroup);
    }

    function getBeamGroups() {
      return noteGroups.filter(function(group){
          if (group.length > 1) {
            var beamable = true;
            group.forEach(function(note) {
              if (note.getIntrinsicTicks() >= Vex.Flow.durationToTicks("4")) {
                beamable = false;
              }
            });
            return beamable;
          }
          return false;
      });
    }

    // Splits up groups by Rest
    function sanitizeGroups() {
      var sanitizedGroups = [];
      noteGroups.forEach(function(group) {
        var tempGroup = [];
        group.forEach(function(note, index, group) {
          var isFirstOrLast = index === 0 || index === group.length - 1;
          var prevNote = group[index-1];

          var breaksOnEachRest = !config.beam_rests && note.isRest();
          var breaksOnFirstOrLastRest = (config.beam_rests &&
            config.beam_middle_only && note.isRest() && isFirstOrLast);

          var breakOnStemChange = false;
          if (config.maintain_stem_directions && prevNote &&
              !note.isRest() && !prevNote.isRest()) {
            var prevDirection = prevNote.getStemDirection();
            var currentDirection = note.getStemDirection();
            breakOnStemChange = currentDirection !== prevDirection;
          }

          var isUnbeamableDuration = parseInt(note.duration, 10) < 8;

          // Determine if the group should be broken at this note
          var shouldBreak = breaksOnEachRest || breaksOnFirstOrLastRest ||
                            breakOnStemChange || isUnbeamableDuration;

          if (shouldBreak) {
            // Add current group
            if (tempGroup.length > 0) {
              sanitizedGroups.push(tempGroup);
            }

            // Start a new group. Include the current note if the group
            // was broken up by stem direction, as that note needs to start
            // the next group of notes
            tempGroup = breakOnStemChange ? [note] : [];
          } else {
            // Add note to group
            tempGroup.push(note);
          }
        });

        // If there is a remaining group, add it as well
        if (tempGroup.length > 0) {
          sanitizedGroups.push(tempGroup);
        }
      });

      noteGroups = sanitizedGroups;
    }

    function formatStems() {
      noteGroups.forEach(function(group){
        var stemDirection;
        if (config.maintain_stem_directions) {
          var note = findFirstNote(group);
          stemDirection = note ? note.getStemDirection() : Stem.UP;
        } else {
          if (config.stem_direction){
            stemDirection = config.stem_direction;
          } else {
            stemDirection = calculateStemDirection(group);
          }
        }
        applyStemDirection(group, stemDirection);
      });
    }

    function findFirstNote(group) {
      for (var i = 0; i < group.length; i++) {
        var note = group[i];
        if (!note.isRest()) {
          return note;
        }
      }

      return false;
    }

    function applyStemDirection(group, direction) {
      group.forEach(function(note){
        note.setStemDirection(direction);
      });
    }

    function getTupletGroups() {
      return noteGroups.filter(function(group){
        if (group[0]) return group[0].tuplet;
      });
    }


    // Using closures to store the variables throughout the various functions
    // IMO Keeps it this process lot cleaner - but not super consistent with
    // the rest of the API's style - Silverwolf90 (Cyril)
    createGroups();
    sanitizeGroups();
    formatStems();

    // Get the notes to be beamed
    var beamedNoteGroups = getBeamGroups();

    // Get the tuplets in order to format them accurately
    var tupletGroups = getTupletGroups();

    // Create a Vex.Flow.Beam from each group of notes to be beamed
    var beams = [];
    beamedNoteGroups.forEach(function(group){
      var beam = new Vex.Flow.Beam(group);

      if (config.show_stemlets) {
        beam.render_options.show_stemlets = true;
      }
      if (config.secondary_breaks) {
        beam.render_options.secondary_break_ticks = Vex.Flow.durationToTicks(config.secondary_breaks);
      }
      if (config.flat_beams === true) {
        beam.render_options.flat_beams = true;
        beam.render_options.flat_beam_offset = config.flat_beam_offset;
      }
      beams.push(beam);
    });

    // Reformat tuplets
    tupletGroups.forEach(function(group){
      var firstNote = group[0];
      for (var i=0; i<group.length; ++i) {
        if (group[i].hasStem()) {
          firstNote = group[i];
          break;
        }
      }

      var tuplet = firstNote.tuplet;

      if (firstNote.beam) tuplet.setBracketed(false);
      if (firstNote.stem_direction == Stem.DOWN) {
        tuplet.setTupletLocation(Vex.Flow.Tuplet.LOCATION_BOTTOM);
      }
    });

    return beams;
  };

  return Beam;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements the main Voice class. It's mainly a container
// object to group `Tickables` for formatting.
Vex.Flow.Voice = (function() {
  function Voice(time) {
    if (arguments.length > 0) this.init(time);
  }

  // Modes allow the addition of ticks in three different ways:
  //
  // STRICT: This is the default. Ticks must fill the voice.
  // SOFT:   Ticks can be added without restrictions.
  // FULL:   Ticks do not need to fill the voice, but can't exceed the maximum
  //         tick length.
  Voice.Mode = {
    STRICT: 1,
    SOFT:   2,
    FULL:   3
  };

  // ## Prototype Methods
  Voice.prototype = {
    init: function(time) {
      this.time = Vex.Merge({
        num_beats: 4,
        beat_value: 4,
        resolution: Vex.Flow.RESOLUTION
      }, time);

      // Recalculate total ticks.
      this.totalTicks = new Vex.Flow.Fraction(
        this.time.num_beats * (this.time.resolution / this.time.beat_value), 1);

      this.resolutionMultiplier = 1;

      // Set defaults
      this.tickables = [];
      this.ticksUsed = new Vex.Flow.Fraction(0, 1);
      this.smallestTickCount = this.totalTicks.clone();
      this.largestTickWidth = 0;
      this.stave = null;
      this.boundingBox = null;
      // Do we care about strictly timed notes
      this.mode = Vex.Flow.Voice.Mode.STRICT;

      // This must belong to a VoiceGroup
      this.voiceGroup = null;
    },

    // Get the total ticks in the voice
    getTotalTicks: function() { return this.totalTicks; },

    // Get the total ticks used in the voice by all the tickables
    getTicksUsed: function() { return this.ticksUsed; },

    // Get the largest width of all the tickables
    getLargestTickWidth: function() { return this.largestTickWidth; },

    // Get the tick count for the shortest tickable
    getSmallestTickCount: function() { return this.smallestTickCount; },

    // Get the tickables in the voice
    getTickables: function() { return this.tickables; },

    // Get/set the voice mode, use a value from `Voice.Mode`
    getMode: function() { return this.mode; },
    setMode: function(mode) { this.mode = mode; return this; },

    // Get the resolution multiplier for the voice
    getResolutionMultiplier: function() { return this.resolutionMultiplier; },

    // Get the actual tick resolution for the voice
    getActualResolution: function() { return this.resolutionMultiplier * this.time.resolution; },

    // Set the voice's stave
    setStave: function(stave) {
      this.stave = stave;
      this.boundingBox = null; // Reset bounding box so we can reformat
      return this;
    },

    // Get the bounding box for the voice
    getBoundingBox: function() {
      var stave, boundingBox, bb, i;

      if (!this.boundingBox) {
        if (!this.stave) throw Vex.RERR("NoStave", "Can't get bounding box without stave.");
        stave = this.stave;
        boundingBox = null;

        for (i = 0; i < this.tickables.length; ++i) {
          this.tickables[i].setStave(stave);

          bb = this.tickables[i].getBoundingBox();
          if (!bb) continue;

          boundingBox = boundingBox ? boundingBox.mergeWith(bb) : bb;
        }

        this.boundingBox = boundingBox;
      }
      return this.boundingBox;
    },

    // Every tickable must be associated with a voiceGroup. This allows formatters
    // and preformatters to associate them with the right modifierContexts.
    getVoiceGroup: function() {
      if (!this.voiceGroup)
        throw new Vex.RERR("NoVoiceGroup", "No voice group for voice.");
      return this.voiceGroup;
    },

    // Set the voice group
    setVoiceGroup: function(g) { this.voiceGroup = g; return this; },

    // Set the voice mode to strict or soft 
    setStrict: function(strict) {
      this.mode = strict ? Vex.Flow.Voice.Mode.STRICT : Vex.Flow.Voice.Mode.SOFT;
      return this;
    },

    // Determine if the voice is complete according to the voice mode
    isComplete: function() {
      if (this.mode == Vex.Flow.Voice.Mode.STRICT ||
          this.mode == Vex.Flow.Voice.Mode.FULL) {
        return this.ticksUsed.equals(this.totalTicks);
      } else {
        return true;
      }
    },

    // Add a tickable to the voice
    addTickable: function(tickable) {
      if (!tickable.shouldIgnoreTicks()) {
        var ticks = tickable.getTicks();

        // Update the total ticks for this line.
        this.ticksUsed.add(ticks);

        if ((this.mode == Vex.Flow.Voice.Mode.STRICT ||
             this.mode == Vex.Flow.Voice.Mode.FULL) &&
             this.ticksUsed.greaterThan(this.totalTicks)) {
          this.totalTicks.subtract(ticks);
          throw new Vex.RERR("BadArgument", "Too many ticks.");
        }

        // Track the smallest tickable for formatting.
        if (ticks.lessThan(this.smallestTickCount)) {
          this.smallestTickCount = ticks.clone();
        }

        this.resolutionMultiplier = this.ticksUsed.denominator;

        // Expand total ticks using denominator from ticks used.
        this.totalTicks.add(0, this.ticksUsed.denominator);
      }

      // Add the tickable to the line.
      this.tickables.push(tickable);
      tickable.setVoice(this);
      return this;
    },

    // Add an array of tickables to the voice.
    addTickables: function(tickables) {
      for (var i = 0; i < tickables.length; ++i) {
        this.addTickable(tickables[i]);
      }

      return this;
    },

    // Preformats the voice by applying the voice's stave to each note.
    preFormat: function(){
      if (this.preFormatted) return;

      this.tickables.forEach(function(tickable) {
        if (!tickable.getStave()) {
          tickable.setStave(this.stave);
        }
      }, this);

      this.preFormatted = true;
      return this;
    },

    // Render the voice onto the canvas `context` and an optional `stave`.
    // If `stave` is omitted, it is expected that the notes have staves
    // already set.
    draw: function(context, stave) {
      var boundingBox = null;
      for (var i = 0; i < this.tickables.length; ++i) {
        var tickable = this.tickables[i];

        // Set the stave if provided
        if (stave) tickable.setStave(stave);

        if (!tickable.getStave()) {
          throw new Vex.RuntimeError("MissingStave",
            "The voice cannot draw tickables without staves.");
        }

        if (i === 0) boundingBox = tickable.getBoundingBox();

        if (i > 0 && boundingBox) {
          var tickable_bb = tickable.getBoundingBox();
          if (tickable_bb) boundingBox.mergeWith(tickable_bb);
        }

       tickable.setContext(context);
       tickable.draw();
      }

      this.boundingBox = boundingBox;
    }
  };

  return Voice;
}());
// Vex Music Notation
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Muthanna 2010

/** @constructor */
Vex.Flow.VoiceGroup = (function() {
  function VoiceGroup() {
    this.init();
  }

  VoiceGroup.prototype = {
    init: function() {
      this.voices = [];
      this.modifierContexts = [];
    },

    // Every tickable must be associated with a voiceGroup. This allows formatters
    // and preformatters to associate them with the right modifierContexts.
    getVoices: function() { return this.voices; },
    getModifierContexts: function() { return this.modifierContexts; },

    addVoice: function(voice) {
      if (!voice) throw new Vex.RERR("BadArguments", "Voice cannot be null.");
      this.voices.push(voice);
      voice.setVoiceGroup(this);
    }
  };

  return VoiceGroup;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// `Modifier` is an abstract interface for notational elements that modify
// a `Note`. Examples of modifiers are `Accidental`, `Annotation`, `Stroke`, etc.
//
// For a `Modifier` instance to be positioned correctly, it must be part of
// a `ModifierContext`. All modifiers in the same context are rendered relative to
// one another.
//
// Typically, all modifiers to a note are part of the same `ModifierContext` instance. Also,
// in multi-voice staves, all modifiers to notes on the same `tick` are part of the same
// `ModifierContext`. This ensures that multiple voices don't trample all over each other.

Vex.Flow.Modifier = (function() {
  function Modifier() {
    this.constructor = Modifier;
    this.init();
  }
  Modifier.CATEGORY = "none";

    // To enable logging for this class. Set `Vex.Flow.Modifier.DEBUG` to `true`.
  function L() { if (Modifier.DEBUG) Vex.L("Vex.Flow.Modifier", arguments); }

  // Modifiers can be positioned almost anywhere, relative to a note.
  Modifier.Position = {
    LEFT: 1,
    RIGHT: 2,
    ABOVE: 3,
    BELOW: 4
  };

  // ## Prototype Methods
  Modifier.prototype = {

    // The constructor sets initial widths and constants.
    init: function() {
      this.width = 0;
      this.context = null;

      // Modifiers are attached to a note and an index. An index is a
      // specific head in a chord.
      this.note = null;
      this.index = null;

      // The `text_line` is reserved space above or below a stave.
      this.text_line = 0;
      this.position = Modifier.Position.LEFT;
      this.modifier_context = null;
      this.x_shift = 0;
      this.y_shift = 0;
      this.spacingFromNextModifier = 0;
      L("Created new modifier");
    },

    // Every modifier has a category. The `ModifierContext` uses this to determine
    // the type and order of the modifiers.
    getCategory: function() { return this.constructor.CATEGORY; },

    // Get and set modifier widths.
    getWidth: function() { return this.width; },
    setWidth: function(width) { this.width = width; return this; },

    // Get and set attached note (`StaveNote`, `TabNote`, etc.)
    getNote: function() { return this.note; },
    setNote: function(note) { this.note = note; return this; },

    // Get and set note index, which is a specific note in a chord.
    getIndex: function() { return this.index; },
    setIndex: function(index) { this.index = index; return this; },

    // Get and set rendering context.
    getContext: function() { return this.context; },
    setContext: function(context) { this.context = context; return this; },

    // Every modifier must be part of a `ModifierContext`.
    getModifierContext: function() { return this.modifier_context; },
    setModifierContext: function(c) { this.modifier_context = c; return this; },

    // Get and set articulation position.
    getPosition: function() { return this.position; },
    setPosition: function(position) { this.position = position; return this; },

    // Set the `text_line` for the modifier.
    setTextLine: function(line) { this.text_line = line; return this; },

    // Shift modifier down `y` pixels. Negative values shift up.
    setYShift: function(y) { this.y_shift = y; return this; },

    setSpacingFromNextModifier: function(x) {
      this.spacingFromNextModifier = x;
    },

    getSpacingFromNextModifier: function() {return this.spacingFromNextModifier; },

    // Shift modifier `x` pixels in the direction of the modifier. Negative values
    // shift reverse.
    setXShift: function(x) {
      this.x_shift = 0;
      if (this.position == Modifier.Position.LEFT) {
        this.x_shift -= x;
      } else {
        this.x_shift += x;
      }
    },
    getXShift: function() {return this.x_shift;},

    // Render the modifier onto the canvas.
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      throw new Vex.RERR("MethodNotImplemented",
          "Draw() not implemented for this modifier.");
    }
  };

  return Modifier;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This class implements various types of modifiers to notes (e.g. bends,
// fingering positions etc.)

Vex.Flow.ModifierContext = (function() {
  function ModifierContext() {
    // Current modifiers
    this.modifiers = {};

    // Formatting data.
    this.preFormatted = false;
    this.postFormatted = false;
    this.width = 0;
    this.spacing = 0;
    this.state = {
      left_shift: 0,
      right_shift: 0,
      text_line: 0,
      top_text_line: 0
    };

    // Add new modifiers to this array. The ordering is significant -- lower
    // modifiers are formatted and rendered before higher ones.
    this.PREFORMAT = [
      Vex.Flow.StaveNote,
      Vex.Flow.Dot,
      Vex.Flow.FretHandFinger,
      Vex.Flow.Accidental,
      Vex.Flow.GraceNoteGroup,
      Vex.Flow.Stroke,
      Vex.Flow.StringNumber,
      Vex.Flow.Articulation,
      Vex.Flow.Ornament,
      Vex.Flow.Annotation,
      Vex.Flow.Bend,
      Vex.Flow.Vibrato
    ];

    // If post-formatting is required for an element, add it to this array.
    this.POSTFORMAT = [ Vex.Flow.StaveNote ];
  }

  // To enable logging for this class. Set `Vex.Flow.ModifierContext.DEBUG` to `true`.
  function L() { if (ModifierContext.DEBUG) Vex.L("Vex.Flow.ModifierContext", arguments); }

  ModifierContext.prototype = {
    addModifier: function(modifier) {
      var type = modifier.getCategory();
      if (!this.modifiers[type]) this.modifiers[type] = [];
      this.modifiers[type].push(modifier);
      modifier.setModifierContext(this);
      this.preFormatted = false;
      return this;
    },

    getModifiers: function(type) { return this.modifiers[type]; },
    getWidth: function() { return this.width; },
    getExtraLeftPx: function() { return this.state.left_shift; },
    getExtraRightPx: function() { return this.state.right_shift; },
    getState: function() { return this.state; },

    getMetrics: function() {
      if (!this.formatted) throw new Vex.RERR("UnformattedModifier",
          "Unformatted modifier has no metrics.");

      return {
        width: this.state.left_shift + this.state.right_shift + this.spacing,
        spacing: this.spacing,
        extra_left_px: this.state.left_shift,
        extra_right_px: this.state.right_shift
      };
    },

    preFormat: function() {
      if (this.preFormatted) return;
      this.PREFORMAT.forEach(function(modifier) {
        L("Preformatting ModifierContext: ", modifier.CATEGORY);
        modifier.format(this.getModifiers(modifier.CATEGORY), this.state, this);
      }, this);

      // Update width of this modifier context
      this.width = this.state.left_shift + this.state.right_shift;
      this.preFormatted = true;
    },

    postFormat: function() {
      if (this.postFormatted) return;
      this.POSTFORMAT.forEach(function(modifier) {
        L("Postformatting ModifierContext: ", modifier.CATEGORY);
        modifier.postFormat(this.getModifiers(modifier.CATEGORY), this);
      }, this);
    }
  };

  return ModifierContext;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// @author Mohit Cheppudira
// @author Greg Ristow (modifications)
//
// ## Description
//
// This file implements accidentals as modifiers that can be attached to
// notes. Support is included for both western and microtonal accidentals.
//
// See `tests/accidental_tests.js` for usage examples.

Vex.Flow.Accidental = (function(){
  function Accidental(type) {
    if (arguments.length > 0) this.init(type);
  }
  Accidental.CATEGORY = "accidentals";

  // To enable logging for this class. Set `Vex.Flow.Accidental.DEBUG` to `true`.
  function L() { if (Accidental.DEBUG) Vex.L("Vex.Flow.Accidental", arguments); }

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods
  //
  // Arrange accidentals inside a ModifierContext.
  Accidental.format = function(accidentals, state) {
    var left_shift = state.left_shift;
    var accidental_spacing = 2;

    // If there are no accidentals, we needn't format their positions
    if (!accidentals || accidentals.length === 0) return false;

    var acc_list = [];
    var hasStave = false;
    var prev_note = null;
    var shiftL = 0;

    // First determine the accidentals' Y positions from the note.keys
    var i, acc, props_tmp;
    for (i = 0; i < accidentals.length; ++i) {
      acc = accidentals[i];
      var note = acc.getNote();
      var stave = note.getStave();
      var props = note.getKeyProps()[acc.getIndex()];
      if (note != prev_note) {
         // Iterate through all notes to get the displaced pixels
         for (var n = 0; n < note.keys.length; ++n) {
            props_tmp = note.getKeyProps()[n];
            shiftL = (props_tmp.displaced ? note.getExtraLeftPx() : shiftL);
          }
          prev_note = note;
      }
      if (stave !== null) {
        hasStave = true;
        var line_space = stave.options.spacing_between_lines_px;
        var y = stave.getYForLine(props.line);
        var acc_line = Math.round(y / line_space * 2)/2;
        acc_list.push({ y: y, line: acc_line, shift: shiftL, acc: acc, lineSpace: line_space });
      } else {
        acc_list.push({ line: props.line, shift: shiftL, acc: acc });
      }
    }

    // Sort accidentals by line number.
    acc_list.sort(function(a, b) { return (b.line - a.line); });

    // Create an array of unique line numbers (line_list) from acc_list
    var line_list = []; // an array of unique line numbers
    var acc_shift = 0; // amount by which all accidentals must be shifted right or left for stem flipping, notehead shifting concerns.
    var previous_line = null;

    for(i = 0; i<acc_list.length; i++) {
      acc = acc_list[i];

      // if this is the first line, or a new line, add a line_list
      if( (previous_line === null) || (previous_line != acc.line) ) {
        line_list.push({line : acc.line, flat_line : true, dbl_sharp_line: true, num_acc : 0, width : 0});
      }
      // if this accidental is not a flat, the accidental needs 3.0 lines lower
      // clearance instead of 2.5 lines for b or bb.
      if( (acc.acc.type != "b") && (acc.acc.type !="bb") ) {
        line_list[line_list.length - 1].flat_line = false;
      }
      // if this accidental is not a double sharp, the accidental needs 3.0 lines above
      if( acc.acc.type != "##")
        line_list[line_list.length - 1].dbl_sharp_line = false;

      // Track how many accidentals are on this line:
      line_list[line_list.length - 1].num_acc++;

      // Track the total x_offset needed for this line which will be needed
      // for formatting lines w/ multiple accidentals:

      //width = accidental width + universal spacing between accidentals
      line_list[line_list.length - 1].width += acc.acc.getWidth() + accidental_spacing;

      // if this acc_shift is larger, use it to keep first column accidentals in the same line
      acc_shift = ( (acc.shift > acc_shift) ? acc.shift : acc_shift);

      previous_line = acc.line;
    }

    // ### Place Accidentals in Columns
    //
    // Default to a classic triangular layout (middle accidental farthest left),
    // but follow exceptions as outlined in G. Read's _Music Notation_ and
    // Elaine Gould's _Behind Bars_.
    //
    // Additionally, this implements different vertical colission rules for
    // flats (only need 2.5 lines clearance below) and double sharps (only
    // need 2.5 lines of clearance above or below).
    //
    // Classic layouts and exception patterns are found in the 'tables.js'
    // in 'Vex.Flow.accidentalColumnsTable'
    //
    // Beyond 6 vertical accidentals, default to the parallel ascending lines approach,
    // using as few columns as possible for the verticle structure.
    //
    // TODO (?): Allow column to be specified for an accidental at run-time?

    var total_columns = 0;

    // establish the boundaries for a group of notes with clashing accidentals:
    for(i = 0; i<line_list.length; i++) {
      var no_further_conflicts = false;
      var group_start = i;
      var group_end = i;

      group_check_while : while( (group_end+1 < line_list.length) && (!no_further_conflicts) ) {
        // if this note conflicts with the next:
        if(this.checkCollision(line_list[group_end], line_list[group_end + 1])) {
        // include the next note in the group:
          group_end++;
        }
        else no_further_conflicts = true;
      }

      // Set columns for the lines in this group:
      var group_length = group_end - group_start + 1;

      // Set the accidental column for each line of the group
      var end_case = (this.checkCollision(line_list[group_start], line_list[group_end])) ? "a" : "b";


        var checkCollision = this.checkCollision;
        switch(group_length) {
          case 3:
            if( (end_case == "a") &&
                (line_list[group_start+1].line - line_list[group_start+2].line == 0.5) &&
                (line_list[group_start].line - line_list[group_start + 1].line != 0.5) )
              end_case = "second_on_bottom";
              break;
          case 4:
            if( (!checkCollision(line_list[group_start], line_list[group_start+2])) &&
                (!checkCollision(line_list[group_start+1], line_list[group_start+3])) )
              end_case = "spaced_out_tetrachord";
              break;
          case 5:
            if( (end_case == "b") &&
                (!checkCollision(line_list[group_start+1], line_list[group_start+3])) )
              end_case = "spaced_out_pentachord";
            if( (end_case == "spaced_out_pentachord") &&
                (!checkCollision(line_list[group_start], line_list[group_start+2])) &&
                (!checkCollision(line_list[group_start+2], line_list[group_start+4])) )
              end_case = "very_spaced_out_pentachord";
              break;
          case 6:
            if( (!checkCollision(line_list[group_start], line_list[group_start+3])) &&
                (!checkCollision(line_list[group_start+1], line_list[group_start+4])) &&
                (!checkCollision(line_list[group_start+2], line_list[group_start+5])) )
              end_case = "spaced_out_hexachord";
            if( (!checkCollision(line_list[group_start], line_list[group_start+2])) &&
                (!checkCollision(line_list[group_start+2], line_list[group_start+4])) &&
                (!checkCollision(line_list[group_start+1], line_list[group_start+3])) &&
                (!checkCollision(line_list[group_start+3], line_list[group_start+5])) )
              end_case = "very_spaced_out_hexachord";
              break;
        }

      var group_member;
      var column;
      // If the group contains more than seven members, use ascending parallel lines
      // of accidentals, using as few columns as possible while avoiding collisions.
      if (group_length>=7) {
        // First, determine how many columns to use:
        var pattern_length = 2;
        var colission_detected = true;
        while(colission_detected === true) {
          colission_detected = false;
          colission_detecter : for(var line = 0; line + pattern_length < line_list.length; line++) {
            if(this.checkCollision(line_list[line], line_list[line+pattern_length])) {
              colission_detected = true;
              pattern_length++;
              break colission_detecter;
            }
          }
        }
        // Then, assign a column to each line of accidentals
        for(group_member = i; group_member <= group_end; group_member++) {
          column = ((group_member-i) % pattern_length) + 1;
          line_list[group_member].column = column;
          total_columns = (total_columns > column) ? total_columns : column;
        }

      // Otherwise, if the group contains fewer than seven members, use the layouts from
      // the accidentalsColumnsTable housed in tables.js.
      } else {
        for(group_member = i; group_member <= group_end; group_member++) {
          column = Vex.Flow.accidentalColumnsTable[group_length][end_case][group_member-i];
          line_list[group_member].column = column;
          total_columns = (total_columns > column) ? total_columns : column;
        }
      }

      // Increment i to the last note that was set, so that if a lower set of notes
      // does not conflict at all with this group, it can have its own classic shape.
      i = group_end;
    }

    // ### Convert Columns to x_offsets
    //
    // This keeps columns aligned, even if they have different accidentals within them
    // which sometimes results in a larger x_offset than is an accidental might need
    // to preserve the symmetry of the accidental shape.
    //
    // Neither A.C. Vinci nor G. Read address this, and it typically only happens in
    // music with complex chord clusters.
    //
    // TODO (?): Optionally allow closer compression of accidentals, instead of forcing
    // parallel columns.

    // track each column's max width, which will be used as initial shift of later columns:
    var column_widths = [];
    var column_x_offsets = [];
    for(i=0; i<=total_columns; i++) {
      column_widths[i] = 0;
      column_x_offsets[i] = 0;
    }

    column_widths[0] = acc_shift + left_shift;
    column_x_offsets[0] = acc_shift + left_shift;

    // Fill column_widths with widest needed x-space;
    // this is what keeps the columns parallel.
    line_list.forEach(function(line) {
      if(line.width > column_widths[line.column]) column_widths[line.column] = line.width;
    });

    for(i=1; i<column_widths.length; i++) {
      // this column's offset = this column's width + previous column's offset
      column_x_offsets[i] = column_widths[i] + column_x_offsets[i-1];
    }

    var total_shift = column_x_offsets[column_x_offsets.length-1];
    // Set the x_shift for each accidental according to column offsets:
    var acc_count = 0;
    line_list.forEach(function(line) {
      var line_width = 0;
      var last_acc_on_line = acc_count + line.num_acc;
      // handle all of the accidentals on a given line:
      for(acc_count; acc_count<last_acc_on_line; acc_count++) {
        var x_shift = (column_x_offsets[line.column-1] + line_width);
        acc_list[acc_count].acc.setXShift(x_shift);
        // keep track of the width of accidentals we've added so far, so that when
        // we loop, we add space for them.
        line_width += acc_list[acc_count].acc.getWidth() + accidental_spacing;
        L("Line, acc_count, shift: ", line.line, acc_count, x_shift);
      }
    });

    // update the overall layout with the full width of the accidental shapes:
    state.left_shift += total_shift;
  };

  // Helper function to determine whether two lines of accidentals collide vertically
  Accidental.checkCollision = function(line_1, line_2) {
    var clearance = line_2.line - line_1.line;
    var clearance_required = 3;
    // But less clearance is required for certain accidentals: b, bb and ##.
    if(clearance>0) { // then line 2 is on top
      clearance_required = (line_2.flat_line || line_2.dbl_sharp_line) ? 2.5 : 3.0;
      if(line_1.dbl_sharp_line) clearance -= 0.5;
    } else { // line 1 is on top
      clearance_required = (line_1.flat_line || line_1.dbl_sharp_line) ? 2.5 : 3.0;
      if(line_2.dbl_sharp_line) clearance -= 0.5;
    }
    var colission = (Math.abs(clearance) < clearance_required);
    L("Line_1, Line_2, Collision: ", line_1.line, line_2.line, colission);
    return(colission);
  };

  // ## Prototype Methods
  //
  // An `Accidental` inherits from `Modifier`, and is formatted within a
  // `ModifierContext`.
  Vex.Inherit(Accidental, Modifier, {
    // Create accidental. `type` can be a value from the
    // `Vex.Flow.accidentalCodes.accidentals` table in `tables.js`. For
    // example: `#`, `##`, `b`, `n`, etc.
    init: function(type) {
      Accidental.superclass.init.call(this);
      L("New accidental: ", type);

      this.note = null;
      // The `index` points to a specific note in a chord.
      this.index = null;
      this.type = type;
      this.position = Modifier.Position.LEFT;

      this.render_options = {
        // Font size for glyphs
        font_scale: 38,

        // Length of stroke across heads above or below the stave.
        stroke_px: 3
      };

      this.accidental = Vex.Flow.accidentalCodes(this.type);
      if (!this.accidental) throw new Vex.RERR("ArgumentError", "Unknown accidental type: " + type);

      // Cautionary accidentals have parentheses around them
      this.cautionary = false;
      this.paren_left = null;
      this.paren_right = null;

      // Initial width is set from table.
      this.setWidth(this.accidental.width);
    },

    // Attach this accidental to `note`, which must be a `StaveNote`.
    setNote: function(note){
      if (!note) throw new Vex.RERR("ArgumentError", "Bad note value: " + note);
      this.note = note;

      // Accidentals attached to grace notes are rendered smaller.
      if (this.note.getCategory() === 'gracenotes') {
        this.render_options.font_scale = 25;
        this.setWidth(this.accidental.gracenote_width);
      }
    },

    // If called, draws parenthesis around accidental.
    setAsCautionary: function() {
      this.cautionary = true;
      this.render_options.font_scale = 28;
      this.paren_left = Vex.Flow.accidentalCodes("{");
      this.paren_right = Vex.Flow.accidentalCodes("}");
      var width_adjust = (this.type == "##" || this.type == "bb") ? 6 : 4;

      // Make sure `width` accomodates for parentheses.
      this.setWidth(this.paren_left.width + this.accidental.width + this.paren_right.width - width_adjust);
      return this;
    },

    // Render accidental onto canvas.
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw accidental without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw accidental without a note and index.");

      // Figure out the start `x` and `y` coordinates for this note and index.
      var start = this.note.getModifierStartXY(this.position, this.index);
      var acc_x = ((start.x + this.x_shift) - this.width);
      var acc_y = start.y + this.y_shift;
      L("Rendering: ", this.type, acc_x, acc_y);

      if (!this.cautionary) {
        // Render the accidental alone.
        Vex.Flow.renderGlyph(this.context, acc_x, acc_y,
                             this.render_options.font_scale, this.accidental.code);
      } else {
        // Render the accidental in parentheses.
        acc_x += 3;
        Vex.Flow.renderGlyph(this.context, acc_x, acc_y,
                             this.render_options.font_scale, this.paren_left.code);
        acc_x += 2;
        Vex.Flow.renderGlyph(this.context, acc_x, acc_y,
                             this.render_options.font_scale, this.accidental.code);
        acc_x += this.accidental.width - 2;
        if (this.type == "##" || this.type == "bb") acc_x -= 2;
        Vex.Flow.renderGlyph(this.context, acc_x, acc_y,
                             this.render_options.font_scale, this.paren_right.code);
      }
    }
  });

  // ## Static Methods
  //
  // Use this method to automatically apply accidentals to a set of `voices`.
  // The accidentals will be remembered between all the voices provided.
  // Optionally, you can also provide an initial `keySignature`.
  Accidental.applyAccidentals = function(voices, keySignature) {
    var tickPositions = [];
    var tickNoteMap = {};

    // Sort the tickables in each voice by their tick position in the voice
    voices.forEach(function(voice) {
      var tickPosition = new Vex.Flow.Fraction(0, 1);
      var notes = voice.getTickables();
      notes.forEach(function(note) {
        var notesAtPosition = tickNoteMap[tickPosition.value()];

        if (!notesAtPosition) {
          tickPositions.push(tickPosition.value());
          tickNoteMap[tickPosition.value()] = [note];
        } else {
          notesAtPosition.push(note);
        }

        tickPosition.add(note.getTicks());
      });
    });

    var music = new Vex.Flow.Music();

    // Default key signature is C major
    if (!keySignature) keySignature = "C";

    // Get the scale map, which represents the current state of each pitch
    var scaleMap = music.createScaleMap(keySignature);

    tickPositions.forEach(function(tick) {
      var notes = tickNoteMap[tick];

      // Array to store all pitches that modified accidental states
      // at this tick position
      var modifiedPitches = [];

      notes.forEach(function(note) {
          if (note.isRest()) return;

          // Go through each key and determine if an accidental should be
          // applied
          note.keys.forEach(function(keyString, keyIndex) {
              var key = music.getNoteParts(keyString.split('/')[0]);

              // Force a natural for every key without an accidental
              var accidentalString = key.accidental || "n";
              var pitch = key.root + accidentalString;

              // Determine if the current pitch has the same accidental
              // as the scale state
              var sameAccidental = scaleMap[key.root] === pitch;

              // Determine if an identical pitch in the chord already
              // modified the accidental state
              var previouslyModified = modifiedPitches.indexOf(pitch) > -1;

              // Add the accidental to the StaveNote
              if (!sameAccidental || (sameAccidental && previouslyModified)) {
                  // Modify the scale map so that the root pitch has an
                  // updated state
                  scaleMap[key.root] = pitch;

                  // Create the accidental
                  var accidental = new Vex.Flow.Accidental(accidentalString);

                  // Attach the accidental to the StaveNote
                  note.addAccidental(keyIndex, accidental);

                  // Add the pitch to list of pitches that modified accidentals
                  modifiedPitches.push(pitch);
              }
          });
      });
    });
  };

  return Accidental;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements dot modifiers for notes.

/**
 * @constructor
 */
Vex.Flow.Dot = (function() {
  function Dot() {
    this.init();
  }

  Dot.CATEGORY = "dots";

  var Modifier = Vex.Flow.Modifier;

  // Arrange dots inside a ModifierContext.
  Dot.format = function(dots, state) {
    var right_shift = state.right_shift;
    var dot_spacing = 1;

    if (!dots || dots.length === 0) return false;

    var i, dot, note, shift;
    var dot_list = [];
    for (i = 0; i < dots.length; ++i) {
      dot = dots[i];
      note = dot.getNote();

      var props;
      // Only StaveNote has .getKeyProps()
      if (typeof note.getKeyProps === 'function') {
        props = note.getKeyProps()[dot.getIndex()];
        shift = (props.displaced ? note.getExtraRightPx() : 0);
      } else { // Else it's a TabNote
        props = { line: 0.5 }; // Shim key props for dot placement
        shift = 0;
      }

      dot_list.push({ line: props.line, shift: shift, note: note, dot: dot });
    }

    // Sort dots by line number.
    dot_list.sort(function(a, b) { return (b.line - a.line); });

    var dot_shift = right_shift;
    var x_width = 0;
    var last_line = null;
    var last_note = null;
    var prev_dotted_space = null;
    var half_shiftY = 0;

    for (i = 0; i < dot_list.length; ++i) {
      dot = dot_list[i].dot;
      note = dot_list[i].note;
      shift = dot_list[i].shift;
      var line = dot_list[i].line;

      // Reset the position of the dot every line.
      if (line != last_line || note != last_note) {
        dot_shift = shift;
      }

      if (!note.isRest() && line != last_line) {
        if (Math.abs(line % 1) == 0.5) {
          // note is on a space, so no dot shift
          half_shiftY = 0;
        } else if (!note.isRest()) {
          // note is on a line, so shift dot to space above the line
          half_shiftY = 0.5;
          if (last_note != null &&
              !last_note.isRest() && last_line - line == 0.5) {
            // previous note on a space, so shift dot to space below the line
            half_shiftY = -0.5;
          } else if (line + half_shiftY == prev_dotted_space) {
            // previous space is dotted, so shift dot to space below the line
             half_shiftY = -0.5;
          }
        }
      }

      // convert half_shiftY to a multiplier for dots.draw()
      dot.dot_shiftY = (-half_shiftY);
      prev_dotted_space = line + half_shiftY;

      dot.setXShift(dot_shift);
      dot_shift += dot.getWidth() + dot_spacing; // spacing
      x_width = (dot_shift > x_width) ? dot_shift : x_width;
      last_line = line;
      last_note = note;
    }

    // Update state.
    state.right_shift += x_width;
  };

  Vex.Inherit(Dot, Modifier, {
    init: function() {
      Dot.superclass.init.call(this);

      this.note = null;
      this.index = null;
      this.position = Modifier.Position.RIGHT;

      this.radius = 2;
      this.setWidth(5);
      this.dot_shiftY = 0;
    },

    setNote: function(note){
      this.note = note;

      if (this.note.getCategory() === 'gracenotes') {
        this.radius *= 0.50;
        this.setWidth(3);
      }
    },

    setDotShiftY: function(y) { this.dot_shiftY = y; return this; },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw dot without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw dot without a note and index.");

      var line_space = this.note.stave.options.spacing_between_lines_px;

      var start = this.note.getModifierStartXY(this.position, this.index);

      // Set the starting y coordinate to the base of the stem for TabNotes
      if (this.note.getCategory() === 'tabnotes') {
        start.y = this.note.getStemExtents().baseY;
      }

      var dot_x = (start.x + this.x_shift) + this.width - this.radius;
      var dot_y = start.y + this.y_shift + (this.dot_shiftY * line_space);
      var ctx = this.context;

      ctx.beginPath();
      ctx.arc(dot_x, dot_y, this.radius, 0, Math.PI * 2, false);
      ctx.fill();
    }
  });

  return Dot;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements the formatting and layout algorithms that are used
// to position notes in a voice. The algorithm can align multiple voices both
// within a stave, and across multiple staves.
//
// To do this, the formatter breaks up voices into a grid of rational-valued
// `ticks`, to which each note is assigned. Then, minimum widths are assigned
// to each tick based on the widths of the notes and modifiers in that tick. This
// establishes the smallest amount of space required for each tick.
//
// Finally, the formatter distributes the left over space proportionally to
// all the ticks, setting the `x` values of the notes in each tick.
//
// See `tests/formatter_tests.js` for usage examples. The helper functions included
// here (`FormatAndDraw`, `FormatAndDrawTab`) also serve as useful usage examples.

Vex.Flow.Formatter = (function() {
  function Formatter() {
    // Minimum width required to render all the notes in the voices.
    this.minTotalWidth = 0;

    // This is set to `true` after `minTotalWidth` is calculated.
    this.hasMinTotalWidth = false;

    // The suggested amount of space for each tick.
    this.pixelsPerTick = 0;

    // Total number of ticks in the voice.
    this.totalTicks = new Vex.Flow.Fraction(0, 1);

    // Arrays of tick and modifier contexts.
    this.tContexts = null;
    this.mContexts = null;
  }

  // To enable logging for this class. Set `Vex.Flow.Formatter.DEBUG` to `true`.
  function L() { if (Formatter.DEBUG) Vex.L("Vex.Flow.Formatter", arguments); }

  // ## Private Helpers
  //
  // Helper function to locate the next non-rest note(s).
  function lookAhead(notes, rest_line, i, compare) {
    // If no valid next note group, next_rest_line is same as current.
    var next_rest_line = rest_line;

    // Get the rest line for next valid non-rest note group.
    i++;
    while (i < notes.length) {
      if (!notes[i].isRest() && !notes[i].shouldIgnoreTicks()) {
        next_rest_line = notes[i].getLineForRest();
        break;
      }
      i++;
    }

    // Locate the mid point between two lines.
    if (compare && rest_line != next_rest_line) {
      var top = Vex.Max(rest_line, next_rest_line);
      var bot = Vex.Min(rest_line, next_rest_line);
      next_rest_line = Vex.MidLine(top, bot);
    }
    return next_rest_line;
  }

  // Take an array of `voices` and place aligned tickables in the same context. Returns
  // a mapping from `tick` to `context_type`, a list of `tick`s, and the resolution
  // multiplier.
  //
  // Params:
  // * `voices`: Array of `Voice` instances.
  // * `context_type`: A context class (e.g., `ModifierContext`, `TickContext`)
  // * `add_fn`: Function to add tickable to context.
  function createContexts(voices, context_type, add_fn) {
    if (!voices || !voices.length) throw new Vex.RERR("BadArgument",
        "No voices to format");

    // Initialize tick maps.
    var totalTicks = voices[0].getTotalTicks();
    var tickToContextMap = {};
    var tickList = [];
    var contexts = [];

    var resolutionMultiplier = 1;

    // Find out highest common multiple of resolution multipliers.
    // The purpose of this is to find out a common denominator
    // for all fractional tick values in all tickables of all voices,
    // so that the values can be expanded and the numerator used
    // as an integer tick value.
    var i; // shared iterator
    var voice;
    for (i = 0; i < voices.length; ++i) {
      voice = voices[i];
      if (!(voice.getTotalTicks().equals(totalTicks))) {
        throw new Vex.RERR("TickMismatch",
            "Voices should have same total note duration in ticks.");
      }

      if (voice.getMode() == Vex.Flow.Voice.Mode.STRICT && !voice.isComplete())
        throw new Vex.RERR("IncompleteVoice",
          "Voice does not have enough notes.");

      var lcm = Vex.Flow.Fraction.LCM(resolutionMultiplier,
          voice.getResolutionMultiplier());
      if (resolutionMultiplier < lcm) {
        resolutionMultiplier = lcm;
      }
    }

    // For each voice, extract notes and create a context for every
    // new tick that hasn't been seen before.
    for (i = 0; i < voices.length; ++i) {
      voice = voices[i];

      var tickables = voice.getTickables();

      // Use resolution multiplier as denominator to expand ticks
      // to suitable integer values, so that no additional expansion
      // of fractional tick values is needed.
      var ticksUsed = new Vex.Flow.Fraction(0, resolutionMultiplier);

      for (var j = 0; j < tickables.length; ++j) {
        var tickable = tickables[j];
        var integerTicks = ticksUsed.numerator;

        // If we have no tick context for this tick, create one.
        if (!tickToContextMap[integerTicks]) {
          var newContext = new context_type();
          contexts.push(newContext);
          tickToContextMap[integerTicks] = newContext;
        }

        // Add this tickable to the TickContext.
        add_fn(tickable, tickToContextMap[integerTicks]);

        // Maintain a sorted list of tick contexts.
        tickList.push(integerTicks);
        ticksUsed.add(tickable.getTicks());
      }
    }

    return {
      map: tickToContextMap,
      array: contexts,
      list: Vex.SortAndUnique(tickList, function(a, b) { return a - b; },
          function(a, b) { return a === b; } ),
      resolutionMultiplier: resolutionMultiplier
    };
  }


  // ## Static Methods
  //
  // Helper function to format and draw a single voice. Returns a bounding
  // box for the notation.
  //
  // Parameters:
  // * `ctx` - The rendering context
  // * `stave` - The stave to which to draw (`Stave` or `TabStave`)
  // * `notes` - Array of `Note` instances (`StaveNote`, `TextNote`, `TabNote`, etc.)
  // * `params` - One of below:
  //    * Setting `autobeam` only `(context, stave, notes, true)` or `(ctx, stave, notes, {autobeam: true})`
  //    * Setting `align_rests` a struct is needed `(context, stave, notes, {align_rests: true})`
  //    * Setting both a struct is needed `(context, stave, notes, {autobeam: true, align_rests: true})`
  //
  // `autobeam` automatically generates beams for the notes.
  // `align_rests` aligns rests with nearby notes.
  Formatter.FormatAndDraw = function(ctx, stave, notes, params) {
    var opts = {
      auto_beam: false,
      align_rests: false
    };

    if (typeof params == "object") {
      Vex.Merge(opts, params);
    } else if (typeof params == "boolean") {
      opts.auto_beam = params;
    }

    // Start by creating a voice and adding all the notes to it.
    var voice = new Vex.Flow.Voice(Vex.Flow.TIME4_4).
      setMode(Vex.Flow.Voice.Mode.SOFT);
    voice.addTickables(notes);

    // Then create beams, if requested.
    var beams = null;
    if (opts.auto_beam) {
      beams = Vex.Flow.Beam.applyAndGetBeams(voice);
    }

    // Instantiate a `Formatter` and format the notes.
    new Formatter().
      joinVoices([voice], {align_rests: opts.align_rests}).
      formatToStave([voice], stave, {align_rests: opts.align_rests});

    // Render the voice and beams to the stave.
    voice.setStave(stave);
    voice.draw(ctx, stave);
    if (beams != null) {
      for (var i=0; i<beams.length; ++i) {
        beams[i].setContext(ctx).draw();
      }
    }

    // Return the bounding box of the voice.
    return voice.getBoundingBox();
  };

  // Helper function to format and draw aligned tab and stave notes in two
  // separate staves.
  //
  // Parameters:
  // * `ctx` - The rendering context
  // * `tabstave` - A `TabStave` instance on which to render `TabNote`s.
  // * `stave` - A `Stave` instance on which to render `Note`s.
  // * `notes` - Array of `Note` instances for the stave (`StaveNote`, `BarNote`, etc.)
  // * `tabnotes` - Array of `Note` instances for the tab stave (`TabNote`, `BarNote`, etc.)
  // * `autobeam` - Automatically generate beams.
  // * `params` - A configuration object:
  //    * `autobeam` automatically generates beams for the notes.
  //    * `align_rests` aligns rests with nearby notes.
  Formatter.FormatAndDrawTab = function(ctx,
      tabstave, stave, tabnotes, notes, autobeam, params) {
    var opts = {
      auto_beam: autobeam,
      align_rests: false
    };

    if (typeof params == "object") {
      Vex.Merge(opts, params);
    } else if (typeof params == "boolean") {
      opts.auto_beam = params;
    }

    // Create a `4/4` voice for `notes`.
    var notevoice = new Vex.Flow.Voice(Vex.Flow.TIME4_4).
      setMode(Vex.Flow.Voice.Mode.SOFT);
    notevoice.addTickables(notes);

    // Create a `4/4` voice for `tabnotes`.
    var tabvoice = new Vex.Flow.Voice(Vex.Flow.TIME4_4).
      setMode(Vex.Flow.Voice.Mode.SOFT);
    tabvoice.addTickables(tabnotes);

    // Generate beams if requested.
    var beams = null;
    if (opts.auto_beam) {
      beams = Vex.Flow.Beam.applyAndGetBeams(notevoice);
    }


    // Instantiate a `Formatter` and align tab and stave notes.
    new Formatter().
      joinVoices([notevoice], {align_rests: opts.align_rests}).
      joinVoices([tabvoice]).
      formatToStave([notevoice,tabvoice], stave, {align_rests: opts.align_rests});

    // Render voices and beams to staves.
    notevoice.draw(ctx, stave);
    tabvoice.draw(ctx, tabstave);
    if (beams != null) {
      for (var i=0; i<beams.length; ++i) {
        beams[i].setContext(ctx).draw();
      }
    }

    // Draw a connector between tab and note staves.
    (new Vex.Flow.StaveConnector(stave, tabstave)).setContext(ctx).draw();
  };

  // Auto position rests based on previous/next note positions.
  //
  // Params:
  // * `notes`: An array of notes.
  // * `align_all_notes`: If set to false, only aligns non-beamed notes.
  // * `align_tuplets`: If set to false, ignores tuplets.
  Formatter.AlignRestsToNotes = function(notes, align_all_notes, align_tuplets) {
    for (var i = 0; i < notes.length; ++i) {
      if (notes[i] instanceof Vex.Flow.StaveNote && notes[i].isRest()) {
        var note = notes[i];

        if (note.tuplet && !align_tuplets) continue;

        // If activated rests not on default can be rendered as specified.
        var position = note.getGlyph().position.toUpperCase();
        if (position != "R/4" && position != "B/4") {
          continue;
        }

        if (align_all_notes || note.beam != null) {
          // Align rests with previous/next notes.
          var props = note.getKeyProps()[0];
          if (i === 0) {
            props.line = lookAhead(notes, props.line, i, false);
            note.setKeyLine(0, props.line);
          } else if (i > 0 && i < notes.length) {
            // If previous note is a rest, use its line number.
            var rest_line;
            if (notes[i-1].isRest()) {
              rest_line = notes[i-1].getKeyProps()[0].line;
              props.line = rest_line;
            } else {
              rest_line = notes[i-1].getLineForRest();
              // Get the rest line for next valid non-rest note group.
              props.line = lookAhead(notes, rest_line, i, true);
            }
            note.setKeyLine(0, props.line);
          }
        }
      }
    }

    return this;
  };

  // ## Prototype Methods
  Formatter.prototype = {
    // Find all the rests in each of the `voices` and align them
    // to neighboring notes. If `align_all_notes` is `false`, then only
    // align non-beamed notes.
    alignRests: function(voices, align_all_notes) {
      if (!voices || !voices.length) throw new Vex.RERR("BadArgument",
          "No voices to format rests");
      for (var i = 0; i < voices.length; i++) {
        new Formatter.AlignRestsToNotes(voices[i].tickables, align_all_notes);
      }
    },

    // Calculate the minimum width required to align and format `voices`.
    preCalculateMinTotalWidth: function(voices) {
      // Cache results.
      if (this.hasMinTotalWidth) return;

      // Create tick contexts if not already created.
      if (!this.tContexts) {
        if (!voices) {
          throw new Vex.RERR("BadArgument",
                             "'voices' required to run preCalculateMinTotalWidth");
        }
        this.createTickContexts(voices);
      }

      var contexts = this.tContexts;
      var contextList = contexts.list;
      var contextMap = contexts.map;

      this.minTotalWidth = 0;

      // Go through each tick context and calculate total width.
      for (var i = 0; i < contextList.length; ++i) {
        var context = contextMap[contextList[i]];

        // `preFormat` gets them to descend down to their tickables and modifier
        // contexts, and calculate their widths.
        context.preFormat();
        this.minTotalWidth += context.getWidth();
      }

      this.hasMinTotalWidth = true;

      return this.minTotalWidth;
    },

    // Get minimum width required to render all voices. Either `format` or
    // `preCalculateMinTotalWidth` must be called before this method.
    getMinTotalWidth: function() {
      if (!this.hasMinTotalWidth) {
        throw new Vex.RERR("NoMinTotalWidth",
            "Need to call 'preCalculateMinTotalWidth' or 'preFormat' before" +
            " calling 'getMinTotalWidth'");
      }

      return this.minTotalWidth;
    },

    // Create `ModifierContext`s for each tick in `voices`.
    createModifierContexts: function(voices) {
      var contexts = createContexts(voices,
          Vex.Flow.ModifierContext,
          function(tickable, context) {
            tickable.addToModifierContext(context);
          });
      this.mContexts = contexts;
      return contexts;
    },

    // Create `TickContext`s for each tick in `voices`. Also calculate the
    // total number of ticks in voices.
    createTickContexts: function(voices) {
      var contexts = createContexts(voices,
          Vex.Flow.TickContext,
          function(tickable, context) { context.addTickable(tickable); });

      contexts.array.forEach(function(context) {
        context.tContexts = contexts.array;
      });

      this.totalTicks = voices[0].getTicksUsed().clone();
      this.tContexts = contexts;
      return contexts;
    },

    // This is the core formatter logic. Format voices and justify them
    // to `justifyWidth` pixels. `rendering_context` is required to justify elements
    // that can't retreive widths without a canvas. This method sets the `x` positions
    // of all the tickables/notes in the formatter.
    preFormat: function(justifyWidth, rendering_context, voices, stave) {
      // Initialize context maps.
      var contexts = this.tContexts;
      var contextList = contexts.list;
      var contextMap = contexts.map;

      // If voices and a stave were provided, set the Stave for each voice
      // and preFormat to apply Y values to the notes;
      if (voices && stave) {
        voices.forEach(function(voice) {
          voice.setStave(stave);
          voice.preFormat();
        });
      }

      // Figure out how many pixels to allocate per tick.
      if (!justifyWidth) {
        justifyWidth = 0;
        this.pixelsPerTick = 0;
      } else {
        this.pixelsPerTick = justifyWidth / (this.totalTicks.value() * contexts.resolutionMultiplier);
      }

      // Now distribute the ticks to each tick context, and assign them their
      // own X positions.
      var x = 0;
      var center_x = justifyWidth / 2;
      var white_space = 0; // White space to right of previous note
      var tick_space = 0;  // Pixels from prev note x-pos to curent note x-pos
      var prev_tick = 0;
      var prev_width = 0;
      var lastMetrics = null;
      var initial_justify_width = justifyWidth;
      this.minTotalWidth = 0;

      var i, tick, context;

      // Pass 1: Give each note maximum width requested by context.
      for (i = 0; i < contextList.length; ++i) {
        tick = contextList[i];
        context = contextMap[tick];
        if (rendering_context) context.setContext(rendering_context);

        // Make sure that all tickables in this context have calculated their
        // space requirements.
        context.preFormat();

        var thisMetrics = context.getMetrics();
        var width = context.getWidth();
        this.minTotalWidth += width;
        var min_x = 0;
        var pixels_used = width;

        // Calculate space between last note and next note.
        tick_space = Math.min((tick - prev_tick) * this.pixelsPerTick, pixels_used);

        // Shift next note up `tick_space` pixels.
        var set_x = x + tick_space;

        // Calculate the minimum next note position to allow for right modifiers.
        if (lastMetrics != null) {
          min_x = x + prev_width - lastMetrics.extraLeftPx;
        }

        // Determine the space required for the previous tick.
        // The `shouldIgnoreTicks` bool is true for elements in the stave
        // that don't consume ticks (bar lines, key and time signatures, etc.)
        set_x = context.shouldIgnoreTicks() ?
            (min_x + context.getWidth()) : Math.max(set_x, min_x);

        if (context.shouldIgnoreTicks() && justifyWidth) {
            // This note stole room... recalculate with new justification width.
            justifyWidth -= context.getWidth();
            this.pixelsPerTick = justifyWidth /
              (this.totalTicks.value() * contexts.resolutionMultiplier);
        }

        // Determine pixels needed for left modifiers.
        var left_px = thisMetrics.extraLeftPx;

        // Determine white space to right of previous tick (from right modifiers.)
        if (lastMetrics != null) {
          white_space = (set_x - x) - (prev_width -
                                       lastMetrics.extraLeftPx);
        }

        // Deduct pixels from white space quota.
        if (i > 0) {
          if (white_space > 0) {
            if (white_space >= left_px) {
              // Have enough white space for left modifiers - no offset needed.
              left_px = 0;
            } else {
              // Decrease left modifier offset by amount of white space.
              left_px -= white_space;
            }
          }
        }

        // Adjust the tick x position with the left modifier offset.
        set_x += left_px;

        // Set the `x` value for the context, which sets the `x` value for all
        // tickables in this context.
        context.setX(set_x);
        context.setPixelsUsed(pixels_used);  // ??? Remove this if nothing breaks

        lastMetrics = thisMetrics;
        prev_width = width;
        prev_tick = tick;
        x = set_x;
      }

      this.hasMinTotalWidth = true;
      if (justifyWidth > 0) {
        // Pass 2: Take leftover width, and distribute it to proportionately to
        // all notes.
        var remaining_x = initial_justify_width - (x + prev_width);
        var leftover_pixels_per_tick = remaining_x / (this.totalTicks.value() * contexts.resolutionMultiplier);
        var accumulated_space = 0;
        prev_tick = 0;

        for (i = 0; i < contextList.length; ++i) {
          tick = contextList[i];
          context = contextMap[tick];
          tick_space = (tick - prev_tick) * leftover_pixels_per_tick;
          accumulated_space = accumulated_space + tick_space;
          context.setX(context.getX() + accumulated_space);
          prev_tick = tick;

          // Move center aligned tickables to middle
          var centeredTickables = context.getCenterAlignedTickables();

          /*jshint -W083 */
          centeredTickables.forEach(function(tickable) {
            tickable.center_x_shift = center_x - context.getX();
          });
        }
      }
    },

    // This is the top-level call for all formatting logic completed
    // after `x` *and* `y` values have been computed for the notes
    // in the voices.
    postFormat: function() {
      // Postformat modifier contexts
      this.mContexts.list.forEach(function(mContext) {
        this.mContexts.map[mContext].postFormat();
      }, this);

      // Postformat tick contexts
      this.tContexts.list.forEach(function(tContext) {
        this.tContexts.map[tContext].postFormat();
      }, this);

      return this;
    },

    // Take all `voices` and create `ModifierContext`s out of them. This tells
    // the formatters that the voices belong on a single stave.
    joinVoices: function(voices) {
      this.createModifierContexts(voices);
      this.hasMinTotalWidth = false;
      return this;
    },

    // Align rests in voices, justify the contexts, and position the notes
    // so voices are aligned and ready to render onto the stave. This method
    // mutates the `x` positions of all tickables in `voices`.
    //
    // Voices are full justified to fit in `justifyWidth` pixels.
    //
    // Set `options.context` to the rendering context. Set `options.align_rests`
    // to true to enable rest alignment.
    format: function(voices, justifyWidth, options) {
      var opts = {
        align_rests: false,
        context: null,
        stave: null
      };

      Vex.Merge(opts, options);
      this.alignRests(voices, opts.align_rests);
      this.createTickContexts(voices);
      this.preFormat(justifyWidth, opts.context, voices, opts.stave);

      // Only postFormat if a stave was supplied for y value formatting
      if (opts.stave) this.postFormat();

      return this;
    },

    // This method is just like `format` except that the `justifyWidth` is inferred
    // from the `stave`.
    formatToStave: function(voices, stave, options) {
      var justifyWidth = stave.getNoteEndX() - stave.getNoteStartX() - 10;
      L("Formatting voices to width: ", justifyWidth);
      var opts = {context: stave.getContext()};
      Vex.Merge(opts, options);
      return this.format(voices, justifyWidth, opts);
    }
  };

  return Formatter;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements varies types of ties between contiguous notes. The
// ties include: regular ties, hammer ons, pull offs, and slides.

/**
 * Create a new tie from the specified notes. The notes must
 * be part of the same line, and have the same duration (in ticks).
 *
 * @constructor
 * @param {!Object} context The canvas context.
 * @param {!Object} notes The notes to tie up.
 * @param {!Object} Options
 */
Vex.Flow.StaveTie = (function() {
  function StaveTie(notes, text) {
    if (arguments.length > 0) this.init(notes, text);
  }

  StaveTie.prototype = {
    init: function(notes, text) {
      /**
       * Notes is a struct that has:
       *
       *  {
       *    first_note: Note,
       *    last_note: Note,
       *    first_indices: [n1, n2, n3],
       *    last_indices: [n1, n2, n3]
       *  }
       *
       **/
      this.notes = notes;
      this.context = null;
      this.text = text;

      this.render_options = {
          cp1: 8,      // Curve control point 1
          cp2: 12,      // Curve control point 2
          text_shift_x: 0,
          first_x_shift: 0,
          last_x_shift: 0,
          y_shift: 7,
          tie_spacing: 0,
          font: { family: "Arial", size: 10, style: "" }
        };

      this.font = this.render_options.font;
      this.setNotes(notes);
    },

    setContext: function(context) { this.context = context; return this; },
    setFont: function(font) { this.font = font; return this; },

    /**
     * Set the notes to attach this tie to.
     *
     * @param {!Object} notes The notes to tie up.
     */
    setNotes: function(notes) {
      if (!notes.first_note && !notes.last_note)
        throw new Vex.RuntimeError("BadArguments",
            "Tie needs to have either first_note or last_note set.");

      if (!notes.first_indices) notes.first_indices = [0];
      if (!notes.last_indices) notes.last_indices = [0];

      if (notes.first_indices.length != notes.last_indices.length)
        throw new Vex.RuntimeError("BadArguments", "Tied notes must have similar" +
          " index sizes");

      // Success. Lets grab 'em notes.
      this.first_note = notes.first_note;
      this.first_indices = notes.first_indices;
      this.last_note = notes.last_note;
      this.last_indices = notes.last_indices;
      return this;
    },

    /**
     * @return {boolean} Returns true if this is a partial bar.
     */
    isPartial: function() {
      return (!this.first_note || !this.last_note);
    },

    renderTie: function(params) {
      if (params.first_ys.length === 0 || params.last_ys.length === 0)
        throw new Vex.RERR("BadArguments", "No Y-values to render");

      var ctx = this.context;
      var cp1 = this.render_options.cp1;
      var cp2 = this.render_options.cp2;

      if (Math.abs(params.last_x_px - params.first_x_px) < 10) {
        cp1 = 2; cp2 = 8;
      }

      var first_x_shift = this.render_options.first_x_shift;
      var last_x_shift = this.render_options.last_x_shift;
      var y_shift = this.render_options.y_shift * params.direction;

      for (var i = 0; i < this.first_indices.length; ++i) {
        var cp_x = ((params.last_x_px + last_x_shift) +
                    (params.first_x_px + first_x_shift)) / 2;
        var first_y_px = params.first_ys[this.first_indices[i]] + y_shift;
        var last_y_px = params.last_ys[this.last_indices[i]] + y_shift;

        if (isNaN(first_y_px) || isNaN(last_y_px))
          throw new Vex.RERR("BadArguments", "Bad indices for tie rendering.");

        var top_cp_y = ((first_y_px + last_y_px) / 2) + (cp1 * params.direction);
        var bottom_cp_y = ((first_y_px + last_y_px) / 2) + (cp2 * params.direction);

        ctx.beginPath();
        ctx.moveTo(params.first_x_px + first_x_shift, first_y_px);
        ctx.quadraticCurveTo(cp_x, top_cp_y,
                             params.last_x_px + last_x_shift, last_y_px);
        ctx.quadraticCurveTo(cp_x, bottom_cp_y,
                             params.first_x_px + first_x_shift, first_y_px);

        ctx.closePath();
        ctx.fill();
      }
    },

    renderText: function(first_x_px, last_x_px) {
      if (!this.text) return;
      var center_x = (first_x_px + last_x_px) / 2;
      center_x -= this.context.measureText(this.text).width / 2;

      this.context.save();
      this.context.setFont(this.font.family, this.font.size, this.font.style);
      this.context.fillText(
          this.text, center_x + this.render_options.text_shift_x,
          (this.first_note || this.last_note).getStave().getYForTopText() - 1);
      this.context.restore();
    },

    draw: function() {
      if (!this.context)
        throw new Vex.RERR("NoContext", "No context to render tie.");
      var first_note = this.first_note;
      var last_note = this.last_note;
      var first_x_px, last_x_px, first_ys, last_ys, stem_direction;

      if (first_note) {
        first_x_px = first_note.getTieRightX() + this.render_options.tie_spacing;
        stem_direction = first_note.getStemDirection();
        first_ys = first_note.getYs();
      } else {
        first_x_px = last_note.getStave().getTieStartX();
        first_ys = last_note.getYs();
        this.first_indices = this.last_indices;
      }

      if (last_note) {
        last_x_px = last_note.getTieLeftX() + this.render_options.tie_spacing;
        stem_direction = last_note.getStemDirection();
        last_ys = last_note.getYs();
      } else {
        last_x_px = first_note.getStave().getTieEndX();
        last_ys = first_note.getYs();
        this.last_indices = this.first_indices;
      }

      this.renderTie({
        first_x_px: first_x_px,
        last_x_px: last_x_px,
        first_ys: first_ys,
        last_ys: last_ys,
        direction: stem_direction
      });

      this.renderText(first_x_px, last_x_px);
      return true;
    }
  };

  return StaveTie;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements varies types of ties between contiguous notes. The
// ties include: regular ties, hammer ons, pull offs, and slides.

/**
 * Create a new tie from the specified notes. The notes must
 * be part of the same line, and have the same duration (in ticks).
 *
 * @constructor
 * @param {!Object} context The canvas context.
 * @param {!Object} notes The notes to tie up.
 * @param {!Object} Options
 */
Vex.Flow.TabTie = (function() {
  function TabTie(notes, text) {
    if (arguments.length > 0) this.init(notes, text);
  }

  TabTie.createHammeron = function(notes) {
    return new TabTie(notes, "H");
  };

  TabTie.createPulloff = function(notes) {
    return new TabTie(notes, "P");
  };

  Vex.Inherit(TabTie, Vex.Flow.StaveTie, {
    init: function(notes, text) {
      /**
       * Notes is a struct that has:
       *
       *  {
       *    first_note: Note,
       *    last_note: Note,
       *    first_indices: [n1, n2, n3],
       *    last_indices: [n1, n2, n3]
       *  }
       *
       **/
      TabTie.superclass.init.call(this, notes, text);
      this.render_options.cp1 = 9;
      this.render_options.cp2 = 11;
      this.render_options.y_shift = 3;

      this.setNotes(notes);
    },

    draw: function() {
      if (!this.context)
        throw new Vex.RERR("NoContext", "No context to render tie.");
      var first_note = this.first_note;
      var last_note = this.last_note;
      var first_x_px, last_x_px, first_ys, last_ys;

      if (first_note) {
        first_x_px = first_note.getTieRightX() + this.render_options.tie_spacing;
        first_ys = first_note.getYs();
      } else {
        first_x_px = last_note.getStave().getTieStartX();
        first_ys = last_note.getYs();
        this.first_indices = this.last_indices;
      }

      if (last_note) {
        last_x_px = last_note.getTieLeftX() + this.render_options.tie_spacing;
        last_ys = last_note.getYs();
      } else {
        last_x_px = first_note.getStave().getTieEndX();
        last_ys = first_note.getYs();
        this.last_indices = this.first_indices;
      }

      this.renderTie({
        first_x_px: first_x_px,
        last_x_px: last_x_px,
        first_ys: first_ys,
        last_ys: last_ys,
        direction: -1           // Tab tie's are always face up.
      });

      this.renderText(first_x_px, last_x_px);
      return true;
    }
  });

  return TabTie;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements varies types of ties between contiguous notes. The
// ties include: regular ties, hammer ons, pull offs, and slides.

/**
 * Create a new tie from the specified notes. The notes must
 * be part of the same line, and have the same duration (in ticks).
 *
 * @constructor
 * @param {!Object} context The canvas context.
 * @param {!Object} notes The notes to tie up.
 * @param {!Object} Options
 */
Vex.Flow.TabSlide = (function() {
  function TabSlide(notes, direction) {
    if (arguments.length > 0) this.init(notes, direction);
  }

  TabSlide.SLIDE_UP = 1;
  TabSlide.SLIDE_DOWN = -1;

  TabSlide.createSlideUp = function(notes) {
    return new TabSlide(notes, TabSlide.SLIDE_UP);
  };

  TabSlide.createSlideDown = function(notes) {
    return new TabSlide(notes, TabSlide.SLIDE_DOWN);
  };

  Vex.Inherit(TabSlide, Vex.Flow.TabTie, {
    init: function(notes, direction) {
      /**
       * Notes is a struct that has:
       *
       *  {
       *    first_note: Note,
       *    last_note: Note,
       *    first_indices: [n1, n2, n3],
       *    last_indices: [n1, n2, n3]
       *  }
       *
       **/
      TabSlide.superclass.init.call(this, notes, "sl.");
      if (!direction) {
        var first_fret = notes.first_note.getPositions()[0].fret;
        var last_fret = notes.last_note.getPositions()[0].fret;

        direction = ((parseInt(first_fret, 10) > parseInt(last_fret, 10)) ?
          TabSlide.SLIDE_DOWN : TabSlide.SLIDE_UP);
      }

      this.slide_direction = direction;
      this.render_options.cp1 = 11;
      this.render_options.cp2 = 14;
      this.render_options.y_shift = 0.5;

      this.setFont({font: "Times", size: 10, style: "bold italic"});
      this.setNotes(notes);
    },

    renderTie: function(params) {
      if (params.first_ys.length === 0 || params.last_ys.length === 0)
        throw new Vex.RERR("BadArguments", "No Y-values to render");

      var ctx = this.context;
      var first_x_px = params.first_x_px;
      var first_ys = params.first_ys;
      var last_x_px = params.last_x_px;

      var direction = this.slide_direction;
      if (direction != TabSlide.SLIDE_UP &&
          direction != TabSlide.SLIDE_DOWN) {
        throw new Vex.RERR("BadSlide", "Invalid slide direction");
      }

      for (var i = 0; i < this.first_indices.length; ++i) {
        var slide_y = first_ys[this.first_indices[i]] +
          this.render_options.y_shift;

        if (isNaN(slide_y))
          throw new Vex.RERR("BadArguments", "Bad indices for slide rendering.");

        ctx.beginPath();
        ctx.moveTo(first_x_px, slide_y + (3 * direction));
        ctx.lineTo(last_x_px, slide_y - (3 * direction));
        ctx.closePath();
        ctx.stroke();
      }
    }
  });

  return TabSlide;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements tablature bends.

/**
   @param text Text for bend ("Full", "Half", etc.) (DEPRECATED)
   @param release If true, render a release. (DEPRECATED)
   @param phrase If set, ignore "text" and "release", and use the more
                 sophisticated phrase specified.

   Example of a phrase:

     [{
       type: UP,
       text: "whole"
       width: 8;
     },
     {
       type: DOWN,
       text: "whole"
       width: 8;
     },
     {
       type: UP,
       text: "half"
       width: 8;
     },
     {
       type: UP,
       text: "whole"
       width: 8;
     },
     {
       type: DOWN,
       text: "1 1/2"
       width: 8;
     }]
 */
Vex.Flow.Bend = (function() {
  function Bend(text, release, phrase) {
    if (arguments.length > 0) this.init(text, release, phrase);
  }
  Bend.CATEGORY = "bends";

  Bend.UP = 0;
  Bend.DOWN = 1;

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods
  // Arrange bends in `ModifierContext`
  Bend.format = function(bends, state) {
    if (!bends || bends.length === 0) return false;

    var last_width = 0;
    // Bends are always on top.
    var text_line = state.top_text_line;

    // Format Bends
    for (var i = 0; i < bends.length; ++i) {
      var bend = bends[i];
      bend.setXShift(last_width);
      last_width = bend.getWidth();
      bend.setTextLine(text_line);
    }

    state.right_shift += last_width;
    state.top_text_line += 1;
    return true;
  };

  // ## Prototype Methods
  Vex.Inherit(Bend, Modifier, {
    init: function(text, release, phrase) {
      var superclass = Vex.Flow.Bend.superclass;
      superclass.init.call(this);

      this.text = text;
      this.x_shift = 0;
      this.release = release || false;
      this.font = "10pt Arial";
      this.render_options = {
        line_width: 1.5,
        line_style: "#777777",
        bend_width: 8,
        release_width: 8
      };

      if (phrase) {
        this.phrase = phrase;
      } else {
        // Backward compatibility
        this.phrase = [{type: Bend.UP, text: this.text}];
        if (this.release) this.phrase.push({type: Bend.DOWN, text: ""});
      }

      this.updateWidth();
    },

    setXShift: function(value) {
      this.x_shift = value;
      this.updateWidth();
    },

    setFont: function(font) { this.font = font; return this; },

    getText: function() { return this.text; },

    updateWidth: function() {
      var that = this;

      function measure_text(text) {
        var text_width;
        if (that.context) {
          text_width = that.context.measureText(text).width;
        } else {
          text_width = Vex.Flow.textWidth(text);
        }

        return text_width;
      }

      var total_width = 0;
      for (var i=0; i<this.phrase.length; ++i) {
        var bend = this.phrase[i];
        if ('width' in bend) {
          total_width += bend.width;
        } else {
          var additional_width = (bend.type == Bend.UP) ?
            this.render_options.bend_width : this.render_options.release_width;

          bend.width = Vex.Max(additional_width, measure_text(bend.text)) + 3;
          bend.draw_width = bend.width / 2;
          total_width += bend.width;
        }
      }

      this.setWidth(total_width + this.x_shift);
      return this;
    },

    draw: function() {
        if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw bend without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoNoteForBend",
        "Can't draw bend without a note or index.");

      var start = this.note.getModifierStartXY(Modifier.Position.RIGHT,
          this.index);
      start.x += 3;
      start.y += 0.5;
      var x_shift = this.x_shift;

      var ctx = this.context;
      var bend_height = this.note.getStave().getYForTopText(this.text_line) + 3;
      var annotation_y = this.note.getStave().getYForTopText(this.text_line) - 1;
      var that = this;

      function renderBend(x, y, width, height) {
        var cp_x = x + width;
        var cp_y = y;

        ctx.save();
        ctx.beginPath();
        ctx.setLineWidth(that.render_options.line_width);
        ctx.setStrokeStyle(that.render_options.line_style);
        ctx.setFillStyle(that.render_options.line_style);
        ctx.moveTo(x, y);
        ctx.quadraticCurveTo(cp_x, cp_y, x + width, height);
        ctx.stroke();
        ctx.restore();
      }

      function renderRelease(x, y, width, height) {
        ctx.save();
        ctx.beginPath();
        ctx.setLineWidth(that.render_options.line_width);
        ctx.setStrokeStyle(that.render_options.line_style);
        ctx.setFillStyle(that.render_options.line_style);
        ctx.moveTo(x, height);
        ctx.quadraticCurveTo(
            x + width, height,
            x + width, y);
        ctx.stroke();
        ctx.restore();
      }

      function renderArrowHead(x, y, direction) {
        var width = 4;
        var dir = direction || 1;

        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.lineTo(x - width, y + width * dir);
        ctx.lineTo(x + width, y + width * dir);
        ctx.closePath();
        ctx.fill();
      }

      function renderText(x, text) {
        ctx.save();
        ctx.setRawFont(that.font);
        var render_x = x - (ctx.measureText(text).width / 2);
        ctx.fillText(text, render_x, annotation_y);
        ctx.restore();
      }

      var last_bend = null;
      var last_drawn_width = 0;
      for (var i=0; i<this.phrase.length; ++i) {
        var bend = this.phrase[i];
        if (i === 0) bend.draw_width += x_shift;

        last_drawn_width = bend.draw_width + (last_bend?last_bend.draw_width:0) - (i==1?x_shift:0);
        if (bend.type == Bend.UP) {
          if (last_bend && last_bend.type == Bend.UP) {
            renderArrowHead(start.x, bend_height);
          }

          renderBend(start.x, start.y, last_drawn_width, bend_height);
        }

        if (bend.type == Bend.DOWN) {
          if (last_bend && last_bend.type == Bend.UP) {
            renderRelease(start.x, start.y, last_drawn_width, bend_height);
          }

          if (last_bend && last_bend.type == Bend.DOWN) {
            renderArrowHead(start.x, start.y, -1);
            renderRelease(start.x, start.y, last_drawn_width, bend_height);
          }

          if (last_bend == null) {
            last_drawn_width = bend.draw_width;
            renderRelease(start.x, start.y, last_drawn_width, bend_height);
          }
        }

        renderText(start.x + last_drawn_width, bend.text);
        last_bend = bend;
        last_bend.x = start.x;

        start.x += last_drawn_width;
      }

      // Final arrowhead and text
      if (last_bend.type == Bend.UP) {
        renderArrowHead(last_bend.x + last_drawn_width, bend_height);
      } else if (last_bend.type == Bend.DOWN) {
        renderArrowHead(last_bend.x + last_drawn_width, start.y, -1);
      }
    }
  });

  return Bend;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This class implements vibratos.

Vex.Flow.Vibrato = (function() {
  function Vibrato() { this.init(); }
  Vibrato.CATEGORY = "vibratos";

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods
  // Arrange vibratos inside a `ModifierContext`.
  Vibrato.format = function(vibratos, state, context) {
    if (!vibratos || vibratos.length === 0) return false;

    // Vibratos are always on top.
    var text_line = state.top_text_line;
    var width = 0;
    var shift = state.right_shift - 7;

    // If there's a bend, drop the text line
    var bends = context.getModifiers(Vex.Flow.Bend.CATEGORY);
    if (bends && bends.length > 0) {
      text_line--;
    }

    // Format Vibratos
    for (var i = 0; i < vibratos.length; ++i) {
      var vibrato = vibratos[i];
      vibrato.setXShift(shift);
      vibrato.setTextLine(text_line);
      width += vibrato.getWidth();
      shift += width;
    }

    state.right_shift += width;
    state.top_text_line += 1;
    return true;
  };

  // ## Prototype Methods
  Vex.Inherit(Vibrato, Modifier, {
    init: function() {
      var superclass = Vex.Flow.Vibrato.superclass;
      superclass.init.call(this);

      this.harsh = false;
      this.position = Vex.Flow.Modifier.Position.RIGHT;
      this.render_options = {
        vibrato_width: 20,
        wave_height: 6,
        wave_width: 4,
        wave_girth: 2
      };

      this.setVibratoWidth(this.render_options.vibrato_width);
    },

    setHarsh: function(harsh) { this.harsh = harsh; return this; },
    setVibratoWidth: function(width) {
      this.vibrato_width = width;
      this.setWidth(this.vibrato_width);
      return this;
    },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw vibrato without a context.");
      if (!this.note) throw new Vex.RERR("NoNoteForVibrato",
        "Can't draw vibrato without an attached note.");

      var start = this.note.getModifierStartXY(Vex.Flow.Modifier.Position.RIGHT,
          this.index);

      var ctx = this.context;
      var that = this;
      var vibrato_width = this.vibrato_width;

      function renderVibrato(x, y) {
        var wave_width = that.render_options.wave_width;
        var wave_girth = that.render_options.wave_girth;
        var wave_height = that.render_options.wave_height;
        var num_waves = vibrato_width / wave_width;

        ctx.beginPath();

        var i;
        if (that.harsh) {
          ctx.moveTo(x, y + wave_girth + 1);
          for (i = 0; i < num_waves / 2; ++i) {
            ctx.lineTo(x + wave_width, y - (wave_height / 2));
            x += wave_width;
            ctx.lineTo(x + wave_width, y + (wave_height / 2));
            x += wave_width;
          }
          for (i = 0; i < num_waves / 2; ++i) {
            ctx.lineTo(x - wave_width, (y - (wave_height / 2)) + wave_girth + 1);
            x -= wave_width;
            ctx.lineTo(x - wave_width, (y + (wave_height / 2)) + wave_girth + 1);
            x -= wave_width;
          }
          ctx.fill();
        } else {
          ctx.moveTo(x, y + wave_girth);
          for (i = 0; i < num_waves / 2; ++i) {
            ctx.quadraticCurveTo(x + (wave_width / 2), y - (wave_height / 2),
              x + wave_width, y);
            x += wave_width;
            ctx.quadraticCurveTo(x + (wave_width / 2), y + (wave_height / 2),
              x + wave_width, y);
            x += wave_width;
          }

          for (i = 0; i < num_waves / 2; ++i) {
            ctx.quadraticCurveTo(
                x - (wave_width / 2),
                (y + (wave_height / 2)) + wave_girth,
                x - wave_width, y + wave_girth);
            x -= wave_width;
            ctx.quadraticCurveTo(
                x - (wave_width / 2),
                (y - (wave_height / 2)) + wave_girth,
                x - wave_width, y + wave_girth);
            x -= wave_width;
          }
          ctx.fill();
        }
      }

      var vx = start.x + this.x_shift;
      var vy = this.note.getYForTopText(this.text_line) + 2;

      renderVibrato(vx, vy);
    }
  });

  return Vibrato;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements text annotations as modifiers that can be attached to
// notes.
//
// See `tests/annotation_tests.js` for usage examples.

Vex.Flow.Annotation = (function() {
  function Annotation(text) {
    if (arguments.length > 0) this.init(text);
  }

  Annotation.CATEGORY = "annotations";
  var Modifier = Vex.Flow.Modifier;

  // To enable logging for this class. Set `Vex.Flow.Annotation.DEBUG` to `true`.
  function L() { if (Annotation.DEBUG) Vex.L("Vex.Flow.Annotation", arguments); }

  // Text annotations can be positioned and justified relative to the note.
  Annotation.Justify = {
    LEFT: 1,
    CENTER: 2,
    RIGHT: 3,
    CENTER_STEM: 4
  };

  Annotation.VerticalJustify = {
    TOP: 1,
    CENTER: 2,
    BOTTOM: 3,
    CENTER_STEM: 4
  };

  // Arrange annotations within a `ModifierContext`
  Annotation.format = function(annotations, state) {
    if (!annotations || annotations.length === 0) return false;

    var width = 0;
    for (var i = 0; i < annotations.length; ++i) {
      var annotation = annotations[i];
      width = Math.max(annotation.getWidth(), width);
      if (annotation.getPosition() === Modifier.Position.ABOVE) {
        annotation.setTextLine(state.top_text_line);
        state.top_text_line++;
      } else {
        annotation.setTextLine(state.text_line);
        state.text_line++;
      }
    }

    state.left_shift += width / 2;
    state.right_shift += width / 2;
    return true;
  };

  // ## Prototype Methods
  //
  // Annotations inherit from `Modifier` and is positioned correctly when
  // in a `ModifierContext`.
  Vex.Inherit(Annotation, Modifier, {
    // Create a new `Annotation` with the string `text`.
    init: function(text) {
      Annotation.superclass.init.call(this);

      this.note = null;
      this.index = null;
      this.text = text;
      this.justification = Annotation.Justify.CENTER;
      this.vert_justification = Annotation.VerticalJustify.TOP;
      this.font = {
        family: "Arial",
        size: 10,
        weight: ""
      };

      // The default width is calculated from the text.
      this.setWidth(Vex.Flow.textWidth(text));
    },

    // Set font family, size, and weight. E.g., `Arial`, `10pt`, `Bold`.
    setFont: function(family, size, weight) {
      this.font = { family: family, size: size, weight: weight };
      return this;
    },

    // Set vertical position of text (above or below stave). `just` must be
    // a value in `Annotation.VerticalJustify`.
    setVerticalJustification: function(just) {
      this.vert_justification = just;
      return this;
    },

    // Get and set horizontal justification. `justification` is a value in
    // `Annotation.Justify`.
    getJustification: function() { return this.justification; },
    setJustification: function(justification) {
      this.justification = justification; return this; },

    // Render text beside the note.
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw text annotation without a context.");
      if (!this.note) throw new Vex.RERR("NoNoteForAnnotation",
        "Can't draw text annotation without an attached note.");

      var start = this.note.getModifierStartXY(Modifier.Position.ABOVE,
          this.index);

      // We're changing context parameters. Save current state.
      this.context.save();
      this.context.setFont(this.font.family, this.font.size, this.font.weight);
      var text_width = this.context.measureText(this.text).width;

      // Estimate text height to be the same as the width of an 'm'.
      //
      // This is a hack to work around the inability to measure text height
      // in HTML5 Canvas (and SVG).
      var text_height = this.context.measureText("m").width;
      var x, y;

      if (this.justification == Annotation.Justify.LEFT) {
        x = start.x;
      } else if (this.justification == Annotation.Justify.RIGHT) {
        x = start.x - text_width;
      } else if (this.justification == Annotation.Justify.CENTER) {
        x = start.x - text_width / 2;
      } else /* CENTER_STEM */ {
        x = this.note.getStemX() - text_width / 2;
      }

      var stem_ext, spacing;
      var has_stem = this.note.hasStem();
      var stave = this.note.getStave();

      // The position of the text varies based on whether or not the note
      // has a stem.
      if (has_stem) {
        stem_ext = this.note.getStem().getExtents();
        spacing = stave.getSpacingBetweenLines();
      }

      if (this.vert_justification == Annotation.VerticalJustify.BOTTOM) {
        y = stave.getYForBottomText(this.text_line);
        if (has_stem) {
          var stem_base = (this.note.getStemDirection() === 1 ? stem_ext.baseY : stem_ext.topY);
          y = Math.max(y, stem_base + (spacing * (this.text_line + 2)));
        }
      } else if (this.vert_justification ==
                 Annotation.VerticalJustify.CENTER) {
        var yt = this.note.getYForTopText(this.text_line) - 1;
        var yb = stave.getYForBottomText(this.text_line);
        y = yt + ( yb - yt ) / 2 + text_height / 2;
      } else if (this.vert_justification ==
                 Annotation.VerticalJustify.TOP) {
        y = Math.min(stave.getYForTopText(this.text_line), this.note.getYs()[0] - 10);
        if (has_stem) {
          y = Math.min(y, (stem_ext.topY - 5) - (spacing * this.text_line));
        }
      } else /* CENTER_STEM */{
        var extents = this.note.getStemExtents();
        y = extents.topY + (extents.baseY - extents.topY) / 2 +
          text_height / 2;
      }

      L("Rendering annotation: ", this.text, x, y);
      this.context.fillText(this.text, x, y);
      this.context.restore();
    }
  });

  return Annotation;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// Author: Larry Kuhns.
//
// ## Description
//
// This file implements articulations and accents as modifiers that can be
// attached to notes. The complete list of articulations is available in
// `tables.js` under `Vex.Flow.articulationCodes`.
//
// See `tests/articulation_tests.js` for usage examples.

Vex.Flow.Articulation = (function() {
  function Articulation(type) {
    if (arguments.length > 0) this.init(type);
  }
  Articulation.CATEGORY = "articulations";

  // To enable logging for this class. Set `Vex.Flow.Articulation.DEBUG` to `true`.
  function L() { if (Articulation.DEBUG) Vex.L("Vex.Flow.Articulation", arguments); }

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods
  // Arrange articulations inside `ModifierContext`
  Articulation.format = function(articulations, state) {
    if (!articulations || articulations.length === 0) return false;

    var width = 0;
    for (var i = 0; i < articulations.length; ++i) {
      var increment = 1;
      var articulation = articulations[i];
      width = Math.max(articulation.getWidth(), width);

      var type = Vex.Flow.articulationCodes(articulation.type);

      if (!type.between_lines) increment += 1.5;

      if (articulation.getPosition() === Modifier.Position.ABOVE) {
        articulation.setTextLine(state.top_text_line);
        state.top_text_line += increment;
      } else {
        articulation.setTextLine(state.text_line);
        state.text_line += increment;
      }
    }

    state.left_shift += width / 2;
    state.right_shift += width / 2;
    return true;
  };

  // ## Prototype Methods
  Vex.Inherit(Articulation, Modifier, {
    // Create a new articulation of type `type`, which is an entry in
    // `Vex.Flow.articulationCodes` in `tables.js`.
    init: function(type) {
      Articulation.superclass.init.call(this);

      this.note = null;
      this.index = null;
      this.type = type;
      this.position = Modifier.Position.BELOW;

      this.render_options = {
        font_scale: 38
      };

      this.articulation = Vex.Flow.articulationCodes(this.type);
      if (!this.articulation) throw new Vex.RERR("ArgumentError",
         "Articulation not found: '" + this.type + "'");

      // Default width comes from articulation table.
      this.setWidth(this.articulation.width);
    },

    // Render articulation in position next to note.
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw Articulation without a context.");
      if (!(this.note && (this.index !== null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw Articulation without a note and index.");

      var stem_direction = this.note.getStemDirection();
      var stave = this.note.getStave();

      var is_on_head = (this.position === Modifier.Position.ABOVE &&
                        stem_direction === Vex.Flow.StaveNote.STEM_DOWN) ||
                       (this.position === Modifier.Position.BELOW &&
                        stem_direction === Vex.Flow.StaveNote.STEM_UP);

      var needsLineAdjustment = function(articulation, note_line, line_spacing) {
        var offset_direction = (articulation.position === Modifier.Position.ABOVE) ? 1 : -1;
        var duration = articulation.getNote().getDuration();
        if(!is_on_head && Vex.Flow.durationToNumber(duration) <= 1){
          // Add stem length, unless it's on a whole note.
          note_line += offset_direction * 3.5;
        }

        var articulation_line = note_line + (offset_direction * line_spacing);

        if(articulation_line >= 1 &&
           articulation_line <= 5 &&
           articulation_line % 1 === 0){
          return true;
        }

        return false;
      };

      // Articulations are centered over/under the note head.
      var start = this.note.getModifierStartXY(this.position, this.index);
      var glyph_y = start.y;
      var shiftY = 0;
      var line_spacing = 1;
      var spacing = stave.getSpacingBetweenLines();
      var is_tabnote = this.note.getCategory() === 'tabnotes';
      var stem_ext = this.note.getStem().getExtents();

      var top = stem_ext.topY;
      var bottom = stem_ext.baseY;

      if (stem_direction === Vex.Flow.StaveNote.STEM_DOWN) {
        top = stem_ext.baseY;
        bottom = stem_ext.topY;
      }

      // TabNotes don't have stems attached to them. Tab stems are rendered
      // outside the stave.
      if (is_tabnote) {
        if (this.note.hasStem()){
          if (stem_direction === Vex.Flow.StaveNote.STEM_UP) {
            bottom = stave.getYForBottomText(this.text_line - 2);
          } else if (stem_direction === Vex.Flow.StaveNote.STEM_DOWN ) {
            top = stave.getYForTopText(this.text_line - 1.5);
          }
        } else { // Without a stem
          top = stave.getYForTopText(this.text_line - 1);
          bottom = stave.getYForBottomText(this.text_line - 2);
        }
      }

      var is_above = (this.position === Modifier.Position.ABOVE) ? true : false;
      var note_line = this.note.getLineNumber(is_above);

      // Beamed stems are longer than quarter note stems.
      if (!is_on_head && this.note.beam) line_spacing += 0.5;

      // If articulation will overlap a line, reposition it.
      if (needsLineAdjustment(this, note_line, line_spacing)) line_spacing += 0.5;

      var glyph_y_between_lines;
      if (this.position === Modifier.Position.ABOVE) {
        shiftY = this.articulation.shift_up;
        glyph_y_between_lines = (top - 7) - (spacing * (this.text_line + line_spacing));

        if (this.articulation.between_lines) {
          glyph_y = glyph_y_between_lines;
        } else {
          glyph_y = Math.min(stave.getYForTopText(this.text_line) - 3, glyph_y_between_lines);
        }
      } else {
        shiftY = this.articulation.shift_down - 10;

        glyph_y_between_lines = bottom + 10 + spacing * (this.text_line + line_spacing);
        if (this.articulation.between_lines) {
          glyph_y = glyph_y_between_lines;
        } else {
          glyph_y = Math.max(stave.getYForBottomText(this.text_line), glyph_y_between_lines);
        }
      }

      var glyph_x = start.x + this.articulation.shift_right;
      glyph_y += shiftY + this.y_shift;

      L("Rendering articulation: ", this.articulation, glyph_x, glyph_y);
      Vex.Flow.renderGlyph(this.context, glyph_x, glyph_y,
                           this.render_options.font_scale, this.articulation.code);
    }
  });

  return Articulation;
}());
// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements varies types of tunings for tablature.

/**
 * @constructor
 */
Vex.Flow.Tuning = (function() {
  function Tuning(tuningString) {
    this.init(tuningString);
  }

  Tuning.names = {
    "standard": "E/5,B/4,G/4,D/4,A/3,E/3",
    "dagdad": "D/5,A/4,G/4,D/4,A/3,D/3",
    "dropd": "E/5,B/4,G/4,D/4,A/3,D/3",
    "eb": "Eb/5,Bb/4,Gb/4,Db/4,Ab/3,Db/3",
    "standardBanjo": "D/5,B/4,G/4,D/4,G/5"
  };

  Tuning.prototype = {
    init: function(tuningString) {
      // Default to standard tuning.
      this.setTuning(tuningString || "E/5,B/4,G/4,D/4,A/3,E/3,B/2,E/2");
    },

    noteToInteger: function(noteString) {
      return Vex.Flow.keyProperties(noteString).int_value;
    },

    setTuning: function(noteString) {
      if (Vex.Flow.Tuning.names[noteString])
        noteString = Vex.Flow.Tuning.names[noteString];

      this.tuningString = noteString;
      this.tuningValues = [];
      this.numStrings = 0;

      var keys = noteString.split(/\s*,\s*/);
      if (keys.length === 0)
        throw new Vex.RERR("BadArguments", "Invalid tuning string: " + noteString);

      this.numStrings = keys.length;
      for (var i = 0; i < this.numStrings; ++i) {
        this.tuningValues[i] = this.noteToInteger(keys[i]);
      }
    },

    getValueForString: function(stringNum) {
      var s = parseInt(stringNum, 10);
      if (s < 1 || s > this.numStrings)
        throw new Vex.RERR("BadArguments", "String number must be between 1 and " +
            this.numStrings + ": " + stringNum);

      return this.tuningValues[s - 1];
    },

    getValueForFret: function(fretNum, stringNum) {
      var stringValue = this.getValueForString(stringNum);
      var f = parseInt(fretNum, 10);

      if (f < 0) {
        throw new Vex.RERR("BadArguments", "Fret number must be 0 or higher: " +
            fretNum);
      }

      return stringValue + f;
    },

    getNoteForFret: function(fretNum, stringNum) {
      var noteValue = this.getValueForFret(fretNum, stringNum);

      var octave = Math.floor(noteValue / 12);
      var value = noteValue % 12;

      return Vex.Flow.integerToNote(value) + "/" + octave;
    }
  };

  return Tuning;
}());

// VexFlow - Music Engraving for HTML5
//
// A base class for stave modifiers (e.g. clefs, key signatures)
//


/**
 * @constructor
 */
Vex.Flow.StaveModifier = (function() {
  function StaveModifier() {
    this.init();
  }

  StaveModifier.prototype = {
    init: function() {
      this.padding = 10;
    },

    getCategory: function() {return "";},
    makeSpacer: function(padding) {
      return {
        getContext: function() {return true;},
        setStave: function() {},
        renderToStave: function() {},
        getMetrics: function() {
          return {width: padding};
        }
      };
    },

    placeGlyphOnLine: function(glyph, stave, line) {
      glyph.setYShift(stave.getYForLine(line) - stave.getYForGlyphs());
    },

    setPadding: function(padding) {
      this.padding = padding;
    },

    addToStave: function(stave, firstGlyph) {
      if (!firstGlyph) {
        stave.addGlyph(this.makeSpacer(this.padding));
      }

      this.addModifier(stave);
      return this;
    },

    addToStaveEnd: function(stave, firstGlyph) {
      if (!firstGlyph) {
        stave.addEndGlyph(this.makeSpacer(this.padding));
      }
      else {
        stave.addEndGlyph(this.makeSpacer(2));
      }

      this.addEndModifier(stave);
      return this;
    },

    addModifier: function() {
      throw new Vex.RERR("MethodNotImplemented",
          "addModifier() not implemented for this stave modifier.");
    },

    addEndModifier: function() {
      throw new Vex.RERR("MethodNotImplemented",
          "addEndModifier() not implemented for this stave modifier.");
    }
  };

  return StaveModifier;
}());


// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// Author: Cyril Silverman
//
// ## Description
//
// This file implements key signatures. A key signature sits on a stave
// and indicates the notes with implicit accidentals.
Vex.Flow.KeySignature = (function() {
  function KeySignature(keySpec) {
    if (arguments.length > 0) this.init(keySpec);
  }

  // Space between natural and following accidental depending
  // on vertical position
  KeySignature.accidentalSpacing = {
    '#': {
      above: 6,
      below: 4
    },
    'b': {
      above: 4,
      below: 7
    },
    'n': {
      above: 3,
      below: -1
    }
  };

  // ## Prototype Methods
  Vex.Inherit(KeySignature, Vex.Flow.StaveModifier, {
    // Create a new Key Signature based on a `key_spec`
    init: function(key_spec) {
      KeySignature.superclass.init();

      this.glyphFontScale = 38; // TODO(0xFE): Should this match StaveNote?
      this.accList = Vex.Flow.keySignature(key_spec);
    },

    // Add an accidental glyph to the `stave`. `acc` is the data of the
    // accidental to add. If the `next` accidental is also provided, extra
    // width will be added to the initial accidental for optimal spacing.
    addAccToStave: function(stave, acc, next) {
      var glyph_data = Vex.Flow.accidentalCodes(acc.type);
      var glyph = new Vex.Flow.Glyph(glyph_data.code, this.glyphFontScale);

      // Determine spacing between current accidental and the next accidental
      var extra_width = 0;
      if (acc.type === "n" && next) {
        var above = next.line >= acc.line;
        var space = KeySignature.accidentalSpacing[next.type];
        extra_width = above ? space.above : space.below;
      }

      // Set the width and place the glyph on the stave
      glyph.setWidth(glyph_data.width + extra_width);
      this.placeGlyphOnLine(glyph, stave, acc.line);
      stave.addGlyph(glyph);
    },

    // Cancel out a key signature provided in the `spec` parameter. This will
    // place appropriate natural accidentals before the key signature.
    cancelKey: function(spec) {
      // Get the accidental list for the cancelled key signature
      var cancel_accList = Vex.Flow.keySignature(spec);

      // If the cancelled key has a different accidental type, ie: # vs b
      var different_types = this.accList.length > 0 &&
                            cancel_accList[0].type !== this.accList[0].type;

      // Determine how many naturals needed to add
      var naturals = 0;
      if (different_types) {
        naturals = cancel_accList.length;
      } else {
        naturals = cancel_accList.length - this.accList.length;
      }

      // Return if no naturals needed
      if (naturals < 1) return;

      // Get the line position for each natural
      var cancelled = [];
      for (var i = 0; i < naturals; i++) {
        var index = i;
        if (!different_types) {
          index = cancel_accList.length - naturals + i;
        }

        var acc = cancel_accList[index];
        cancelled.push({type: "n", line: acc.line});
      }

      // Combine naturals with main accidental list for the key signature
      this.accList = cancelled.concat(this.accList);

      return this;
    },

    // Add the key signature to the `stave`. You probably want to use the 
    // helper method `.addToStave()` instead
    addModifier: function(stave) {
      this.convertAccLines(stave.clef, this.accList[0].type);
      for (var i = 0; i < this.accList.length; ++i) {
        this.addAccToStave(stave, this.accList[i], this.accList[i+1]);
      }
    },

    // Add the key signature to the `stave`, if it's the not the `firstGlyph`
    // a spacer will be added as well.
    addToStave: function(stave, firstGlyph) {
      if (this.accList.length === 0)
        return this;

      if (!firstGlyph) {
        stave.addGlyph(this.makeSpacer(this.padding));
      }

      this.addModifier(stave);
      return this;
    },

    // Apply the accidental staff line placement based on the `clef` and
    // the  accidental `type` for the key signature ('# or 'b').
    convertAccLines: function(clef, type) {
      var offset = 0.0; // if clef === "treble"
      var customLines; // when clef doesn't follow treble key sig shape

      switch (clef) {
        // Treble & Subbass both have offsets of 0, so are not included.
        case "soprano":
          if(type === "#") customLines = [2.5,0.5,2,0,1.5,-0.5,1];
          else offset = -1;
          break;
        case "mezzo-soprano":
          if(type === "b") customLines = [0,2,0.5,2.5,1,3,1.5];
          else offset = 1.5;
          break;
        case "alto":
          offset = 0.5;
          break;
        case "tenor":
          if(type === "#") customLines = [3, 1, 2.5, 0.5, 2, 0, 1.5];
          else offset = -0.5;
          break;
        case "baritone-f":
        case "baritone-c":
          if(type === "b") customLines = [0.5,2.5,1,3,1.5,3.5,2];
          else offset = 2;
          break;
        case "bass":
        case "french":
          offset = 1;
          break;
      }

      // If there's a special case, assign those lines/spaces:
      var i;
      if (typeof customLines !== "undefined") {
        for (i = 0; i < this.accList.length; ++i) {
          this.accList[i].line = customLines[i];
        }
      } else if (offset !== 0) {
        for (i = 0; i < this.accList.length; ++i) {
          this.accList[i].line += offset;
        }
      }
    }
  });

  return KeySignature;
}());
// Vex Flow Notation
// Implements time signatures glyphs for staffs
// See tables.js for the internal time signatures
// representation
//

/**
 * @param {string} timeSpec time signature, i.e. "4/4"
 * @param {number} [customPadding] custom padding when using multi-stave/multi-instrument setting
 * to align key/time signature (in pixels), optional
 * @constructor
 */
Vex.Flow.TimeSignature = (function() {
  function TimeSignature(timeSpec, customPadding) {
    if (arguments.length > 0) this.init(timeSpec, customPadding);
  }

  TimeSignature.glyphs = {
    "C": {
      code: "v41",
      point: 40,
      line: 2
    },
    "C|": {
      code: "vb6",
      point: 40,
      line: 2
    }
  };

  Vex.Inherit(TimeSignature, Vex.Flow.StaveModifier, {
    init: function(timeSpec, customPadding) {
      TimeSignature.superclass.init();
       var padding = customPadding || 15;

      this.setPadding(padding);
      this.point = 40;
      this.topLine = 2;
      this.bottomLine = 4;
      this.timeSig = this.parseTimeSpec(timeSpec);
    },

    parseTimeSpec: function(timeSpec) {
      if (timeSpec == "C" || timeSpec == "C|") {
        var glyphInfo = TimeSignature.glyphs[timeSpec];
        return {num: false, line: glyphInfo.line,
          glyph: new Vex.Flow.Glyph(glyphInfo.code, glyphInfo.point)};
      }

      var topNums = [];
      var i, c;
      for (i = 0; i < timeSpec.length; ++i) {
        c = timeSpec.charAt(i);
        if (c == "/") {
          break;
        }
        else if (/[0-9]/.test(c)) {
          topNums.push(c);
        }
        else {
          throw new Vex.RERR("BadTimeSignature",
              "Invalid time spec: " + timeSpec);
        }
      }

      if (i === 0) {
        throw new Vex.RERR("BadTimeSignature",
              "Invalid time spec: " + timeSpec);
      }

      // skip the "/"
      ++i;

      if (i == timeSpec.length) {
        throw new Vex.RERR("BadTimeSignature",
              "Invalid time spec: " + timeSpec);
      }


      var botNums = [];
      for (; i < timeSpec.length; ++i) {
        c = timeSpec.charAt(i);
        if (/[0-9]/.test(c)) {
          botNums.push(c);
        }
        else {
          throw new Vex.RERR("BadTimeSignature",
              "Invalid time spec: " + timeSpec);
        }
      }


      return {num: true, glyph: this.makeTimeSignatureGlyph(topNums, botNums)};
    },

    makeTimeSignatureGlyph: function(topNums, botNums) {
      var glyph = new Vex.Flow.Glyph("v0", this.point);
      glyph["topGlyphs"] = [];
      glyph["botGlyphs"] = [];

      var topWidth = 0;
      var i, num;
      for (i = 0; i < topNums.length; ++i) {
        num = topNums[i];
        var topGlyph = new Vex.Flow.Glyph("v" + num, this.point);

        glyph.topGlyphs.push(topGlyph);
        topWidth += topGlyph.getMetrics().width;
      }

      var botWidth = 0;
      for (i = 0; i < botNums.length; ++i) {
        num = botNums[i];
        var botGlyph = new Vex.Flow.Glyph("v" + num, this.point);

        glyph.botGlyphs.push(botGlyph);
        botWidth += botGlyph.getMetrics().width;
      }

      var width = (topWidth > botWidth ? topWidth : botWidth);
      var xMin = glyph.getMetrics().x_min;

      glyph.getMetrics = function() {
        return {
          x_min: xMin,
          x_max: xMin + width,
          width: width
        };
      };

      var topStartX = (width - topWidth) / 2.0;
      var botStartX = (width - botWidth) / 2.0;

      var that = this;
      glyph.renderToStave = function(x) {
        var start_x = x + topStartX;
        var i, g;
        for (i = 0; i < this.topGlyphs.length; ++i) {
          g = this.topGlyphs[i];
          Vex.Flow.Glyph.renderOutline(this.context, g.metrics.outline,
              g.scale, start_x + g.x_shift, this.stave.getYForLine(that.topLine) + 1);
          start_x += g.getMetrics().width;
        }

        start_x = x + botStartX;
        for (i = 0; i < this.botGlyphs.length; ++i) {
          g = this.botGlyphs[i];
          that.placeGlyphOnLine(g, this.stave, g.line);
          Vex.Flow.Glyph.renderOutline(this.context, g.metrics.outline,
              g.scale, start_x + g.x_shift, this.stave.getYForLine(that.bottomLine) + 1);
          start_x += g.getMetrics().width;
        }
      };

      return glyph;
    },

    getTimeSig: function() {
      return this.timeSig;
    },

    addModifier: function(stave) {
      if (!this.timeSig.num) {
        this.placeGlyphOnLine(this.timeSig.glyph, stave, this.timeSig.line);
      }
      stave.addGlyph(this.timeSig.glyph);
    },

    addEndModifier: function(stave) {
      if (!this.timeSig.num) {
        this.placeGlyphOnLine(this.timeSig.glyph, stave, this.timeSig.line);
      }
      stave.addEndGlyph(this.timeSig.glyph);
    }
  });

  return TimeSignature;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna Cheppudira 2013.
// Co-author: Benjamin W. Bohl
//
// ## Description
//
// This file implements various types of clefs that can be rendered on a stave.
//
// See `tests/clef_tests.js` for usage examples.

Vex.Flow.Clef = (function() {
  function Clef(clef, size, annotation) {
    if (arguments.length > 0) this.init(clef, size, annotation);
  }

  // To enable logging for this class, set `Vex.Flow.Clef.DEBUG` to `true`.
  function L() { if (Vex.Flow.Clef.DEBUG) Vex.L("Vex.Flow.Clef", arguments); }

  // Every clef name is associated with a glyph code from the font file
  // and a default stave line number.
  Clef.types = {
    "treble": {
      code: "v83",
      line: 3
    },
    "bass": {
      code: "v79",
      line: 1
    },
    "alto": {
      code: "vad",
      line: 2
    },
    "tenor": {
      code: "vad",
      line: 1
    },
    "percussion": {
      code: "v59",
      line: 2
    },
    "soprano": {
      code: "vad",
      line: 4
    },
    "mezzo-soprano": {
      code: "vad",
      line: 3
    },
    "baritone-c": {
      code: "vad",
      line: 0
    },
    "baritone-f": {
      code: "v79",
      line: 2
    },
    "subbass": {
      code: "v79",
      line: 0
    },
    "french": {
      code: "v83",
      line: 4
    },
  };
  // Sizes affect the point-size of the clef.
  Clef.sizes = {
    "default": 40,
    "small": 32
  };

  // Annotations attach to clefs -- such as "8" for octave up or down.
  Clef.annotations = {
    "8va": {
      code: "v8",
      sizes: {
        "default": {
          point: 20,
          attachments: {
            "treble": {
              line: -1.2,
              x_shift: 11
            }
          }
        },
        "small": {
          point: 18,
          attachments: {
            "treble": {
              line: -0.4,
              x_shift: 8
            }
          }
        }
      }
    },
    "8vb": {
      code: "v8",
      sizes: {
        "default": {
          point: 20,
          attachments: {
            "treble": {
              line: 6.3,
              x_shift: 10
            },
            "bass": {
              line: 4,
              x_shift: 1
            }
          }
        },
        "small": {
          point: 18,
          attachments: {
            "treble": {
              line: 5.8,
              x_shift: 6
            },
            "bass": {
              line: 3.5,
              x_shift: 0.5
            }
          }
        }
      }
    },
  };
  // ## Prototype Methods
  Vex.Inherit(Clef, Vex.Flow.StaveModifier, {
    // Create a new clef. The parameter `clef` must be a key from
    // `Clef.types`.
    init: function(clef, size, annotation) {
      var superclass = Vex.Flow.Clef.superclass;
      superclass.init.call(this);

      this.clef = Vex.Flow.Clef.types[clef];
      if (size === undefined) {
        this.size = "default";
      } else {
        this.size = size;
      }
      this.clef.point = Vex.Flow.Clef.sizes[this.size];

      // If an annotation, such as 8va, is specified, add it to the Clef object.
      if (annotation !== undefined) {
        var anno_dict = Vex.Flow.Clef.annotations[annotation];
        this.annotation = {
          code: anno_dict.code,
          point: anno_dict.sizes[this.size].point,
          line: anno_dict.sizes[this.size].attachments[clef].line,
          x_shift: anno_dict.sizes[this.size].attachments[clef].x_shift
        };
      }
      L("Creating clef:", clef);
    },

    // Add this clef to the start of the given `stave`.
    addModifier: function(stave) {
      var glyph = new Vex.Flow.Glyph(this.clef.code, this.clef.point);
      this.placeGlyphOnLine(glyph, stave, this.clef.line);
      if (this.annotation !== undefined) {
        var attachment = new Vex.Flow.Glyph(this.annotation.code, this.annotation.point);
        attachment.metrics.x_max = 0;
        attachment.setXShift(this.annotation.x_shift);
        this.placeGlyphOnLine(attachment, stave, this.annotation.line);
        stave.addGlyph(attachment);
      }
      stave.addGlyph(glyph);
    },

    // Add this clef to the end of the given `stave`.
    addEndModifier: function(stave) {
      var glyph = new Vex.Flow.Glyph(this.clef.code, this.clef.point);
      this.placeGlyphOnLine(glyph, stave, this.clef.line);
      stave.addEndGlyph(glyph);
      if (this.annotation !== undefined) {
        var attachment = new Vex.Flow.Glyph(this.annotation.code, this.annotation.point);
        attachment.metrics.x_max = 0;
        attachment.setXShift(this.annotation.x_shift);
        this.placeGlyphOnLine(attachment, stave, this.annotation.line);
        stave.addEndGlyph(attachment);
      }
    }
  });

  return Clef;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements some standard music theory routines.
//
// requires: vex.js   (Vex)
// requires: flow.js  (Vex.Flow)

/**
 * @constructor
 */
Vex.Flow.Music = (function() {
  function Music() {
    this.init();
  }

  Music.NUM_TONES = 12;
  Music.roots = [ "c", "d", "e", "f", "g", "a", "b" ];
  Music.root_values = [ 0, 2, 4, 5, 7, 9, 11 ];
  Music.root_indices = {
    "c": 0,
    "d": 1,
    "e": 2,
    "f": 3,
    "g": 4,
    "a": 5,
    "b": 6
  };

  Music.canonical_notes = [
    "c", "c#", "d", "d#",
    "e", "f", "f#", "g",
    "g#", "a", "a#", "b"
  ];

  Music.diatonic_intervals = [
    "unison", "m2", "M2", "m3", "M3",
    "p4", "dim5", "p5", "m6", "M6",
    "b7", "M7", "octave"
  ];

  Music.diatonic_accidentals = {
    "unison": {note: 0, accidental: 0},
    "m2":     {note: 1, accidental: -1},
    "M2":     {note: 1, accidental: 0},
    "m3":     {note: 2, accidental: -1},
    "M3":     {note: 2, accidental: 0},
    "p4":     {note: 3, accidental: 0},
    "dim5":   {note: 4, accidental: -1},
    "p5":     {note: 4, accidental: 0},
    "m6":     {note: 5, accidental: -1},
    "M6":     {note: 5, accidental: 0},
    "b7":     {note: 6, accidental: -1},
    "M7":     {note: 6, accidental: 0},
    "octave": {note: 7, accidental: 0}
  };

  Music.intervals = {
    "u":  0, "unison": 0,
    "m2": 1, "b2": 1, "min2": 1, "S": 1, "H": 1,
    "2": 2, "M2": 2, "maj2": 2, "T": 2, "W": 2,
    "m3": 3, "b3": 3, "min3": 3,
    "M3": 4, "3": 4, "maj3": 4,
    "4":  5, "p4":  5,
    "#4": 6, "b5": 6, "aug4": 6, "dim5": 6,
    "5":  7, "p5":  7,
    "#5": 8, "b6": 8, "aug5": 8,
    "6":  9, "M6":  9, "maj6": 9,
    "b7": 10, "m7": 10, "min7": 10, "dom7": 10,
    "M7": 11, "maj7": 11,
    "8": 12, "octave": 12
  };

  Music.scales = {
    major: [2, 2, 1, 2, 2, 2, 1],
    dorian: [2, 1, 2, 2, 2, 1, 2],
    mixolydian: [2, 2, 1, 2, 2, 1, 2],
    minor: [2, 1, 2, 2, 1, 2, 2]
  };

  Music.accidentals = [ "bb", "b", "n", "#", "##" ];

  Music.noteValues = {
    'c':   { root_index: 0, int_val: 0 },
    'cn':  { root_index: 0, int_val: 0 },
    'c#':  { root_index: 0, int_val: 1 },
    'c##': { root_index: 0, int_val: 2 },
    'cb':  { root_index: 0, int_val: 11 },
    'cbb': { root_index: 0, int_val: 10 },
    'd':   { root_index: 1, int_val: 2 },
    'dn':  { root_index: 1, int_val: 2 },
    'd#':  { root_index: 1, int_val: 3 },
    'd##': { root_index: 1, int_val: 4 },
    'db':  { root_index: 1, int_val: 1 },
    'dbb': { root_index: 1, int_val: 0 },
    'e':   { root_index: 2, int_val: 4 },
    'en':  { root_index: 2, int_val: 4 },
    'e#':  { root_index: 2, int_val: 5 },
    'e##': { root_index: 2, int_val: 6 },
    'eb':  { root_index: 2, int_val: 3 },
    'ebb': { root_index: 2, int_val: 2 },
    'f':   { root_index: 3, int_val: 5 },
    'fn':  { root_index: 3, int_val: 5 },
    'f#':  { root_index: 3, int_val: 6 },
    'f##': { root_index: 3, int_val: 7 },
    'fb':  { root_index: 3, int_val: 4 },
    'fbb': { root_index: 3, int_val: 3 },
    'g':   { root_index: 4, int_val: 7 },
    'gn':  { root_index: 4, int_val: 7 },
    'g#':  { root_index: 4, int_val: 8 },
    'g##': { root_index: 4, int_val: 9 },
    'gb':  { root_index: 4, int_val: 6 },
    'gbb': { root_index: 4, int_val: 5 },
    'a':   { root_index: 5, int_val: 9 },
    'an':  { root_index: 5, int_val: 9 },
    'a#':  { root_index: 5, int_val: 10 },
    'a##': { root_index: 5, int_val: 11 },
    'ab':  { root_index: 5, int_val: 8 },
    'abb': { root_index: 5, int_val: 7 },
    'b':   { root_index: 6, int_val: 11 },
    'bn':  { root_index: 6, int_val: 11 },
    'b#':  { root_index: 6, int_val: 0 },
    'b##': { root_index: 6, int_val: 1 },
    'bb':  { root_index: 6, int_val: 10 },
    'bbb': { root_index: 6, int_val: 9 }
  };

  Music.prototype = {
    init: function() {},

    isValidNoteValue: function(note) {
      if (note == null || note < 0 || note >= Vex.Flow.Music.NUM_TONES)
        return false;
      return true;
    },

    isValidIntervalValue: function(interval) {
      return this.isValidNoteValue(interval);
    },

    getNoteParts: function(noteString) {
      if (!noteString || noteString.length < 1)
        throw new Vex.RERR("BadArguments", "Invalid note name: " + noteString);

      if (noteString.length > 3)
        throw new Vex.RERR("BadArguments", "Invalid note name: " + noteString);

      var note = noteString.toLowerCase();

      var regex = /^([cdefgab])(b|bb|n|#|##)?$/;
      var match = regex.exec(note);

      if (match != null) {
        var root = match[1];
        var accidental = match[2];

        return {
          'root': root,
          'accidental': accidental
        };
      } else {
        throw new Vex.RERR("BadArguments", "Invalid note name: " + noteString);
      }
    },

    getKeyParts: function(keyString) {
      if (!keyString || keyString.length < 1)
        throw new Vex.RERR("BadArguments", "Invalid key: " + keyString);

      var key = keyString.toLowerCase();

      // Support Major, Minor, Melodic Minor, and Harmonic Minor key types.
      var regex = /^([cdefgab])(b|#)?(mel|harm|m|M)?$/;
      var match = regex.exec(key);

      if (match != null) {
        var root = match[1];
        var accidental = match[2];
        var type = match[3];

        // Unspecified type implies major
        if (!type) type = "M";

        return {
          'root': root,
          'accidental': accidental,
          'type': type
        };
      } else {
        throw new Vex.RERR("BadArguments", "Invalid key: " + keyString);
      }
    },

    getNoteValue: function(noteString) {
      var value = Music.noteValues[noteString];
      if (value == null)
        throw new Vex.RERR("BadArguments", "Invalid note name: " + noteString);

      return value.int_val;
    },

    getIntervalValue: function(intervalString) {
      var value = Music.intervals[intervalString];
      if (value == null)
        throw new Vex.RERR("BadArguments",
                           "Invalid interval name: " + intervalString);

      return value;
    },

    getCanonicalNoteName: function(noteValue) {
      if (!this.isValidNoteValue(noteValue))
        throw new Vex.RERR("BadArguments",
                           "Invalid note value: " + noteValue);

      return Music.canonical_notes[noteValue];
    },

    getCanonicalIntervalName: function(intervalValue) {
      if (!this.isValidIntervalValue(intervalValue))
        throw new Vex.RERR("BadArguments",
                           "Invalid interval value: " + intervalValue);

      return Music.diatonic_intervals[intervalValue];
    },

    /* Given a note, interval, and interval direction, product the
     * relative note.
     */
    getRelativeNoteValue: function(noteValue, intervalValue, direction) {
      if (direction == null) direction = 1;
      if (direction != 1 && direction != -1)
        throw new Vex.RERR("BadArguments", "Invalid direction: " + direction);

      var sum = (noteValue + (direction * intervalValue)) % Music.NUM_TONES;
      if (sum < 0) sum += Music.NUM_TONES;

      return sum;
    },

    getRelativeNoteName: function(root, noteValue) {
      var parts = this.getNoteParts(root);
      var rootValue = this.getNoteValue(parts.root);
      var interval = noteValue - rootValue;

      if (Math.abs(interval) > Music.NUM_TONES - 3) {
        var multiplier = 1;
        if (interval > 0 ) multiplier = -1;

        // Possibly wrap around. (Add +1 for modulo operator)
        var reverse_interval = (((noteValue + 1) + (rootValue + 1)) %
          Music.NUM_TONES) * multiplier;

        if (Math.abs(reverse_interval) > 2) {
          throw new Vex.RERR("BadArguments", "Notes not related: " + root + ", " +
                            noteValue);
        } else {
          interval = reverse_interval;
        }
      }

      if (Math.abs(interval) > 2)
          throw new Vex.RERR("BadArguments", "Notes not related: " + root + ", " +
                            noteValue);

      var relativeNoteName = parts.root;
      var i;
      if (interval > 0) {
        for (i = 1; i <= interval; ++i)
          relativeNoteName += "#";
      } else if (interval < 0) {
        for (i = -1; i >= interval; --i)
          relativeNoteName += "b";
      }

      return relativeNoteName;
    },

    /* Return scale tones, given intervals. Each successive interval is
     * relative to the previous one, e.g., Major Scale:
     *
     *   TTSTTTS = [2,2,1,2,2,2,1]
     *
     * When used with key = 0, returns C scale (which is isomorphic to
     * interval list).
     */
    getScaleTones: function(key, intervals) {
      var tones = [];
      tones.push(key);

      var nextNote = key;
      for (var i = 0; i < intervals.length; ++i) {
        nextNote = this.getRelativeNoteValue(nextNote,
                                             intervals[i]);
        if (nextNote != key) tones.push(nextNote);
      }

      return tones;
    },

    /* Returns the interval of a note, given a diatonic scale.
     *
     * E.g., Given the scale C, and the note E, returns M3
     */
    getIntervalBetween: function(note1, note2, direction) {
      if (direction == null) direction = 1;
      if (direction != 1 && direction != -1)
        throw new Vex.RERR("BadArguments", "Invalid direction: " + direction);
      if (!this.isValidNoteValue(note1) || !this.isValidNoteValue(note2))
        throw new Vex.RERR("BadArguments",
                           "Invalid notes: " + note1 + ", " + note2);

      var difference;
      if (direction == 1)
        difference = note2 - note1;
      else
        difference = note1 - note2;

      if (difference < 0) difference += Music.NUM_TONES;
      return difference;
    },

    // Create a scale map that represents the pitch state for a
    // `keySignature`. For example, passing a `G` to `keySignature` would 
    // return a scale map with every note naturalized except for `F` which
    // has an `F#` state.
    createScaleMap: function(keySignature) {
      var keySigParts = this.getKeyParts(keySignature);
      var scaleName = Vex.Flow.KeyManager.scales[keySigParts.type];

      var keySigString = keySigParts.root;
      if (keySigParts.accidental) keySigString += keySigParts.accidental;

      if (!scaleName) throw new Vex.RERR("BadArguments", "Unsupported key type: " + keySignature);

      var scale = this.getScaleTones(this.getNoteValue(keySigString), scaleName);
      var noteLocation = Vex.Flow.Music.root_indices[keySigParts.root];

      var scaleMap = {};
      for (var i = 0; i < Vex.Flow.Music.roots.length; ++i) {
        var index = (noteLocation + i) % Vex.Flow.Music.roots.length;
        var rootName = Vex.Flow.Music.roots[index];
        var noteName = this.getRelativeNoteName(rootName, scale[i]);

        if (noteName.length === 1) {
          noteName += "n";
        }

        scaleMap[rootName] = noteName;
      }

      return scaleMap;
    }

  };

  return Music;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements diatonic key management.
//
// requires: vex.js   (Vex)
// requires: flow.js  (Vex.Flow)
// requires: music.js (Vex.Flow.Music)

/**
 * @constructor
 */
Vex.Flow.KeyManager = (function() {
  function KeyManager(key) {
    this.init(key);
  }

  KeyManager.scales = {
    "M": Vex.Flow.Music.scales.major,
    "m": Vex.Flow.Music.scales.minor
  };

  KeyManager.prototype = {
    init: function(key) {
      this.music = new Vex.Flow.Music();
      this.setKey(key);
    },

    setKey: function(key) {
      this.key = key;
      this.reset();
      return this;
    },

    getKey: function() { return this.key; },

    reset: function() {
      this.keyParts = this.music.getKeyParts(this.key);

      this.keyString = this.keyParts.root;
      if (this.keyParts.accidental) this.keyString += this.keyParts.accidental;

      var is_supported_type = KeyManager.scales[this.keyParts.type];
      if (!is_supported_type)
        throw new Vex.RERR("BadArguments", "Unsupported key type: " + this.key);

      this.scale = this.music.getScaleTones(
          this.music.getNoteValue(this.keyString),
          Vex.Flow.KeyManager.scales[this.keyParts.type]);

      this.scaleMap = {};
      this.scaleMapByValue = {};
      this.originalScaleMapByValue = {};

      var noteLocation = Vex.Flow.Music.root_indices[this.keyParts.root];

      for (var i = 0; i < Vex.Flow.Music.roots.length; ++i) {
        var index = (noteLocation + i) % Vex.Flow.Music.roots.length;
        var rootName = Vex.Flow.Music.roots[index];

        var noteName = this.music.getRelativeNoteName(rootName, this.scale[i]);
        this.scaleMap[rootName] = noteName;
        this.scaleMapByValue[this.scale[i]] = noteName;
        this.originalScaleMapByValue[this.scale[i]] = noteName;
      }

      return this;
    },

    getAccidental: function(key) {
      var root = this.music.getKeyParts(key).root;
      var parts = this.music.getNoteParts(this.scaleMap[root]);

      return {
        note: this.scaleMap[root],
        accidental: parts.accidental
      };
    },

    selectNote: function(note) {
      note = note.toLowerCase();
      var parts = this.music.getNoteParts(note);

      // First look for matching note in our altered scale
      var scaleNote = this.scaleMap[parts.root];
      var modparts = this.music.getNoteParts(scaleNote);

      if (scaleNote == note) return {
        "note": scaleNote,
        "accidental": parts.accidental,
        "change": false
      };

      // Then search for a note of equivalent value in our altered scale
      var valueNote = this.scaleMapByValue[this.music.getNoteValue(note)];
      if (valueNote != null) {
        return {
          "note": valueNote,
          "accidental": this.music.getNoteParts(valueNote).accidental,
          "change": false
        };
      }

      // Then search for a note of equivalent value in the original scale
      var originalValueNote = this.originalScaleMapByValue[
        this.music.getNoteValue(note)];
      if (originalValueNote != null) {
        this.scaleMap[modparts.root] = originalValueNote;
        delete this.scaleMapByValue[this.music.getNoteValue(scaleNote)];
        this.scaleMapByValue[this.music.getNoteValue(note)] = originalValueNote;
        return {
          "note": originalValueNote,
          "accidental": this.music.getNoteParts(originalValueNote).accidental,
          "change": true
        };
      }

      // Then try to unmodify a currently modified note.
      if (modparts.root == note) {
        delete this.scaleMapByValue[
          this.music.getNoteValue(this.scaleMap[parts.root])];
        this.scaleMapByValue[this.music.getNoteValue(modparts.root)] =
          modparts.root;
        this.scaleMap[modparts.root] = modparts.root;
        return {
          "note": modparts.root,
          "accidental": null,
          "change": true
        };
      }

      // Last resort -- shitshoot
      delete this.scaleMapByValue[
        this.music.getNoteValue(this.scaleMap[parts.root])];
      this.scaleMapByValue[this.music.getNoteValue(note)] = note;

      delete this.scaleMap[modparts.root];
      this.scaleMap[modparts.root] = note;

      return {
        "note": note,
        "accidental": parts.accidental,
        "change": true
      };
    }
  };

  return KeyManager;
}());

// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// Support for different rendering contexts: Canvas, Raphael
//
// Copyright Mohit Cheppudira 2010

/* global document: false */

Vex.Flow.Renderer = (function() {
  function Renderer(sel, backend) {
    if (arguments.length > 0) this.init(sel, backend);
  }

  Renderer.Backends = {
    CANVAS: 1,
    RAPHAEL: 2,
    SVG: 3,
    VML: 4
  };

  //End of line types
  Renderer.LineEndType = {
      NONE: 1,        // No leg
      UP: 2,          // Upward leg
      DOWN: 3         // Downward leg
  };

  // Set this to true if you're using VexFlow inside a runtime
  // that does not allow modifiying canvas objects. There is a small
  // performance degradation due to the extra indirection.
  Renderer.USE_CANVAS_PROXY = false;
  Renderer.lastContext = null;

  Renderer.buildContext = function(sel,
      backend, width, height, background) {

    var renderer = new Renderer(sel, backend);
    if (width && height) { renderer.resize(width, height); }

    if (!background) background = "#FFF";
    var ctx = renderer.getContext();
    ctx.setBackgroundFillStyle(background);
    Renderer.lastContext = ctx;
    return ctx;
  };

  Renderer.getCanvasContext = function(sel, width, height, background) {
    return Renderer.buildContext(sel, Renderer.Backends.CANVAS,
        width, height, background);
  };

  Renderer.getRaphaelContext = function(sel, width, height, background) {
    return Renderer.buildContext(sel, Renderer.Backends.RAPHAEL,
        width, height, background);
  };

  Renderer.getSVGContext = function(sel, width, height, background) {
    return Renderer.buildContext(sel, Renderer.Backends.SVG,
        width, height, background);
  };


  Renderer.bolsterCanvasContext = function(ctx) {
    if (Renderer.USE_CANVAS_PROXY) {
      return new Vex.Flow.CanvasContext(ctx);
    }

    var methods = ["clear", "setFont", "setRawFont", "setFillStyle", "setBackgroundFillStyle",
                   "setStrokeStyle", "setShadowColor", "setShadowBlur", "setLineWidth",
                   "setLineCap", "setLineDash", "openGroup", "closeGroup", "getGroup"];
    ctx.vexFlowCanvasContext = ctx;

    for (var i in methods) {
      var method = methods[i];
      ctx[method] = Vex.Flow.CanvasContext.prototype[method];
    }

    return ctx;
  };

  //Draw a dashed line (horizontal, vertical or diagonal
  //dashPattern = [3,3] draws a 3 pixel dash followed by a three pixel space.
  //setting the second number to 0 draws a solid line.
  Renderer.drawDashedLine = function(context, fromX, fromY, toX, toY, dashPattern) {
    context.beginPath();

    var dx = toX - fromX;
    var dy = toY - fromY;
    var angle = Math.atan2(dy, dx);
    var x = fromX;
    var y = fromY;
    context.moveTo(fromX, fromY);
    var idx = 0;
    var draw = true;
    while (!((dx < 0 ? x <= toX : x >= toX) && (dy < 0 ? y <= toY : y >= toY))) {
      var dashLength = dashPattern[idx++ % dashPattern.length];
      var nx = x + (Math.cos(angle) * dashLength);
      x = dx < 0 ? Math.max(toX, nx) : Math.min(toX, nx);
      var ny = y + (Math.sin(angle) * dashLength);
      y = dy < 0 ? Math.max(toY, ny) : Math.min(toY, ny);
      if (draw) {
        context.lineTo(x, y);
      } else {
        context.moveTo(x, y);
      }
        draw = !draw;
    }

    context.closePath();
    context.stroke();
  };

  Renderer.prototype = {
    init: function(sel, backend) {
      // Verify selector
      this.sel = sel;
      if (!this.sel) throw new Vex.RERR("BadArgument",
          "Invalid selector for renderer.");

      // Get element from selector
      this.element = document.getElementById(sel);
      if (!this.element) this.element = sel;

      // Verify backend and create context
      this.ctx = null;
      this.paper = null;
      this.backend = backend;
      if (this.backend == Renderer.Backends.CANVAS) {
        // Create context.
        if (!this.element.getContext) throw new Vex.RERR("BadElement",
          "Can't get canvas context from element: " + sel);
        this.ctx = Renderer.bolsterCanvasContext(
            this.element.getContext('2d'));

      } else if (this.backend == Renderer.Backends.RAPHAEL) {
        this.ctx = new Vex.Flow.RaphaelContext(this.element);

      } else if (this.backend == Renderer.Backends.SVG) {
        this.ctx = new Vex.Flow.SVGContext(this.element);

      } else {
        throw new Vex.RERR("InvalidBackend",
          "No support for backend: " + this.backend);
      }
    },

    resize: function(width, height) {
      if (this.backend == Renderer.Backends.CANVAS) {
        if (!this.element.getContext) throw new Vex.RERR("BadElement",
          "Can't get canvas context from element: " + this.sel);
        this.element.width = width;
        this.element.height = height;
        this.ctx = Renderer.bolsterCanvasContext(
            this.element.getContext('2d'));
      } else {
        this.ctx.resize(width, height);
      }

      return this;
    },

    getContext: function() { return this.ctx; }
  };

  return Renderer;
}());



// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// A rendering context for the Raphael backend.
//
// Copyright Mohit Cheppudira 2010

// ## Warning: Deprecated for SVGContext
// Except in instances where SVG support for IE < 9.0 is
// needed, SVGContext is recommended.

/** @constructor */
Vex.Flow.RaphaelContext = (function() {
  function RaphaelContext(element) {
    if (arguments.length > 0) this.init(element);
  }

  RaphaelContext.prototype = {
    init: function(element) {
      this.element = element;
      this.paper = Raphael(element);
      this.path = "";
      this.pen = {x: 0, y: 0};
      this.lineWidth = 1.0;
      this.state = {
        scale: { x: 1, y: 1 },
        font_family: "Arial",
        font_size: 8,
        font_weight: 800
      };

      this.attributes = {
        "stroke-width": 0.3,
        "fill": "black",
        "stroke": "black",
        "font": "10pt Arial"
      };

      this.background_attributes = {
        "stroke-width": 0,
        "fill": "white",
        "stroke": "white",
        "font": "10pt Arial"
      };

      this.shadow_attributes = {
        width: 0,
        color: "black"
      };

      this.state_stack= [];
    },

    // Containers not implemented
    openGroup: function(cls, id, attrs) {},
    closeGroup: function() {},
    add: function(elem) {},

    setFont: function(family, size, weight) {
      this.state.font_family = family;
      this.state.font_size = size;
      this.state.font_weight = weight;
      this.attributes.font = (this.state.font_weight || "") + " " +
        (this.state.font_size * this.state.scale.x) + "pt " +
        this.state.font_family;
      return this;
    },

    setRawFont: function(font) {
      this.attributes.font = font;
      return this;
    },

    setFillStyle: function(style) {
      this.attributes.fill = style;
      return this;
    },

    setBackgroundFillStyle: function(style) {
      this.background_attributes.fill = style;
      this.background_attributes.stroke = style;
      return this;
    },

    setStrokeStyle: function(style) {
      this.attributes.stroke = style;
      return this;
    },

    setShadowColor: function(style) {
      this.shadow_attributes.color = style;
      return this;
    },

    setShadowBlur: function(blur) {
      this.shadow_attributes.width = blur;
      return this;
    },

    setLineWidth: function(width) {
      this.attributes["stroke-width"] = width;
      this.lineWidth = width;
    },

    // Empty because there is no equivalent in SVG
    setLineDash: function() { return this; },
    setLineCap: function() { return this; },

    scale: function(x, y) {
      this.state.scale = { x: x, y: y };
      // The scale() method is deprecated as of Raphael.JS 2.0, and
      // can no longer be used as an option in an Element.attr() call.
      // It is preserved here for users running earlier versions of
      // Raphael.JS, though it has no effect on the SVG output in
      // Raphael 2 and higher.
      this.attributes.transform = "S" + x + "," + y + ",0,0";
      this.attributes.scale = x + "," + y + ",0,0";
      this.attributes.font = this.state.font_size * this.state.scale.x + "pt " +
        this.state.font_family;
      this.background_attributes.transform = "S" + x + "," + y + ",0,0";
      this.background_attributes.font = this.state.font_size *
        this.state.scale.x + "pt " +
        this.state.font_family;
      return this;
    },

    clear: function() { this.paper.clear(); },

    resize: function(width, height) {
      this.element.style.width = width;
      this.paper.setSize(width, height);
      return this;
    },

    // Sets the SVG `viewBox` property, which results in auto scaling images when its container
    // is resized.
    //
    // Usage: `ctx.setViewBox("0 0 600 400")`
    setViewBox: function(viewBox) {
      this.paper.canvas.setAttribute('viewBox', viewBox);
    },

    rect: function(x, y, width, height) {
      if (height < 0) {
        y += height;
        height = -height;
      }

      this.paper.rect(x, y, width - 0.5, height - 0.5).
        attr(this.attributes).
        attr("fill", "none").
        attr("stroke-width", this.lineWidth);
      return this;
    },

    fillRect: function(x, y, width, height) {
      if (height < 0) {
        y += height;
        height = -height;
      }

      this.paper.rect(x, y, width - 0.5, height - 0.5).
        attr(this.attributes);
      return this;
    },

    clearRect: function(x, y, width, height) {
      if (height < 0) {
        y += height;
        height = -height;
      }

      this.paper.rect(x, y, width - 0.5, height - 0.5).
        attr(this.background_attributes);
      return this;
    },

    beginPath: function() {
      this.path = "";
      this.pen.x = 0;
      this.pen.y = 0;
      return this;
    },

    moveTo: function(x, y) {
      this.path += "M" + x + "," + y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    lineTo: function(x, y) {
      this.path += "L" + x + "," + y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
      this.path += "C" +
        x1 + "," +
        y1 + "," +
        x2 + "," +
        y2 + "," +
        x + "," +
        y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    quadraticCurveTo: function(x1, y1, x, y) {
      this.path += "Q" +
        x1 + "," +
        y1 + "," +
        x + "," +
        y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    // This is an attempt (hack) to simulate the HTML5 canvas
    // arc method.
    arc: function(x, y, radius, startAngle, endAngle, antiClockwise) {
      function normalizeAngle(angle) {
        while (angle < 0) {
          angle += Math.PI * 2;
        }

        while (angle > Math.PI * 2) {
          angle -= Math.PI * 2;
        }
        return angle;
      }

      startAngle = normalizeAngle(startAngle);
      endAngle = normalizeAngle(endAngle);

      if (startAngle > endAngle) {
          var tmp = startAngle;
          startAngle = endAngle;
          endAngle = tmp;
          antiClockwise = !antiClockwise;
      }

      var delta = endAngle - startAngle;

      if (delta > Math.PI) {
          this.arcHelper(x, y, radius, startAngle, startAngle + delta / 2,
                         antiClockwise);
          this.arcHelper(x, y, radius, startAngle + delta / 2, endAngle,
                         antiClockwise);
      }
      else {
          this.arcHelper(x, y, radius, startAngle, endAngle, antiClockwise);
      }
      return this;
    },

    arcHelper: function(x, y, radius, startAngle, endAngle, antiClockwise) {
      var x1 = x + radius * Math.cos(startAngle);
      var y1 = y + radius * Math.sin(startAngle);

      var x2 = x + radius * Math.cos(endAngle);
      var y2 = y + radius * Math.sin(endAngle);

      var largeArcFlag = 0;
      var sweepFlag = 0;
      if (antiClockwise) {
        sweepFlag = 1;
        if (endAngle - startAngle < Math.PI)
          largeArcFlag = 1;
      }
      else if (endAngle - startAngle > Math.PI) {
          largeArcFlag = 1;
      }

      this.path += "M" + x1 + "," + y1 + "," + "A" +
        radius + "," + radius + "," + "0," + largeArcFlag + "," + sweepFlag + "," +
        x2 + "," + y2 + "M" + this.pen.x + "," + this.pen.y;
    },

    // Adapted from the source for Raphael's Element.glow
    glow: function() {
      var out = this.paper.set();
      if (this.shadow_attributes.width > 0) {
        var sa = this.shadow_attributes;
        var num_paths = sa.width / 2;
        for (var i = 1; i <= num_paths; i++) {
          out.push(this.paper.path(this.path).attr({
            stroke: sa.color,
            "stroke-linejoin": "round",
            "stroke-linecap": "round",
            "stroke-width": +(sa.width / num_paths * i).toFixed(3),
            opacity: +((sa.opacity || 0.3) / num_paths).toFixed(3),
            // See note in this.scale(): In Raphael the scale() method
            // is deprecated and removed as of Raphael 2.0 and replaced
            // by the transform() method.  It is preserved here for
            // users with earlier versions of Raphael, but has no effect
            // on the output SVG in Raphael 2.0+.
            transform: this.attributes.transform,
            scale: this.attributes.scale
          }));
        }
      }
      return out;
    },

    fill: function() {
      var elem = this.paper.path(this.path).
        attr(this.attributes).
        attr("stroke-width", 0);
      this.glow(elem);
      return this;
    },

    stroke: function() {
      // The first line of code below is, unfortunately, a bit of a hack:
      // Raphael's transform() scaling does not scale the stroke-width, so
      // in order to scale a stroke, we have to manually scale the
      // stroke-width.
      //
      // This works well so long as the X & Y states for this.scale() are
      // relatively similar.  However, if they are very different, we
      // would expect horizontal and vertical lines to have different
      // stroke-widths.
      //
      // In the future, if we want to support very divergent values for
      // horizontal and vertical scaling, we may want to consider
      // implementing SVG scaling with properties of the SVG viewBox &
      // viewPort and removing it entirely from the Element.attr() calls.
      // This would more closely parallel the approach taken in
      // canvascontext.js as well.

      var strokeWidth = this.lineWidth * (this.state.scale.x + this.state.scale.y)/2;
      var elem = this.paper.path(this.path).
        attr(this.attributes).
        attr("fill", "none").
        attr("stroke-width", strokeWidth);
      this.glow(elem);
      return this;
    },

    closePath: function() {
      this.path += "Z";
      return this;
    },

    measureText: function(text) {
      var txt = this.paper.text(0, 0, text).
        attr(this.attributes).
        attr("fill", "none").
        attr("stroke", "none");
      var bounds = txt.getBBox();
      txt.remove();

      return {
        width: bounds.width,
        height: bounds.height
      };
    },

    fillText: function(text, x, y) {
      this.paper.text(x + (this.measureText(text).width / 2),
          (y - (this.state.font_size / (2.25 * this.state.scale.y))), text).
        attr(this.attributes);
      return this;
    },

    save: function() {
      // TODO(mmuthanna): State needs to be deep-copied.
      this.state_stack.push({
        state: {
          font_family: this.state.font_family
        },
        attributes: {
          font: this.attributes.font,
          fill: this.attributes.fill,
          stroke: this.attributes.stroke,
          "stroke-width": this.attributes["stroke-width"]
        },
        shadow_attributes: {
          width: this.shadow_attributes.width,
          color: this.shadow_attributes.color
        }
      });
      return this;
    },

    restore: function() {
      // TODO(0xfe): State needs to be deep-restored.
      var state = this.state_stack.pop();
      this.state.font_family = state.state.font_family;
      this.attributes.font = state.attributes.font;
      this.attributes.fill = state.attributes.fill;
      this.attributes.stroke = state.attributes.stroke;
      this.attributes["stroke-width"] = state.attributes["stroke-width"];
      this.shadow_attributes.width = state.shadow_attributes.width;
      this.shadow_attributes.color = state.shadow_attributes.color;
      return this;
    }
  };

  return RaphaelContext;
}());

// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// A rendering context for SVG.
//
// Copyright Mohit Muthanna 2015
// @author Gregory Ristow (2015)

/** @constructor */
Vex.Flow.SVGContext = (function() {
  function SVGContext(element) {
    if (arguments.length > 0) this.init(element);
  }

  // The measureTextCache is used in Javascript runtimes where
  // there is no proper DOM support for SVG bounding boxes. This
  // is currently only useful in the NodeJS visual regression tests.
  SVGContext.measureTextCache = {};

  // If enabled, will start collecting and indexing getBBox data by
  // font name, size, weight, and style. This should be disabled by
  // default (or you will find yourself slowly leaking RAM.)
  SVGContext.collectMeasurements = false;

  // If enabled, will warn if there are new getBBox requests that are
  // not in the cache. This is enabled in the VexFlow tests, and if you
  // see a warning on the console, you will need to enable collectMeasurements
  // above, then update measureTextCache with the new values. See
  // tests/measure_text_cache.js for instructions on how to do this.
  SVGContext.validateMeasurement = false;

  SVGContext.addPrefix = Vex.Prefix;

  SVGContext.prototype = {
    init: function(element) {
      // element is the parent DOM object
      this.element = element;
      // Create the SVG in the SVG namespace:
      this.svgNS = "http://www.w3.org/2000/svg";
      var svg = this.create("svg");
      // Add it to the canvas:
      this.element.appendChild(svg);

      // Point to it:
      this.svg = svg;
      this.groups = [this.svg]; // Create the group stack
      this.parent = this.svg;

      this.path = "";
      this.pen = {x: 0, y: 0};
      this.lineWidth = 1.0;
      this.state = {
        scale: { x: 1, y: 1 },
        "font-family": "Arial",
        "font-size": "8pt",
        "font-weight": "normal"
      };

      this.attributes = {
        "stroke-width": 0.3,
        "fill": "black",
        "stroke": "black",
        "font-family": "Arial",
        "font-size" : "10pt",
        "font-weight" : "normal",
        "font-style" : "normal"
      };

      this.background_attributes = {
        "stroke-width": 0,
        "fill": "white",
        "stroke": "white",
        "font-family": "Arial",
        "font-size" : "10pt",
        "font-weight": "normal",
        "font-style": "normal"
      };

      this.shadow_attributes = {
        width: 0,
        color: "black"
      };

      this.state_stack= [];

      // Test for Internet Explorer
      this.iePolyfill();
    },

    create: function(svgElementType) {
      return document.createElementNS(this.svgNS, svgElementType);
    },

    // Allow grouping elements in containers for interactivity.
    openGroup: function(cls, id, attrs) {
      var group = this.create("g");
      this.groups.push(group);
      this.parent.appendChild(group);
      this.parent = group;
      if (cls) group.setAttribute("class", SVGContext.addPrefix(cls));
      if (id) group.setAttribute("id", SVGContext.addPrefix(id));

      if (attrs && attrs.pointerBBox) {
        group.setAttribute("pointer-events", "bounding-box");
      }
      return group;
    },

    closeGroup: function() {
      var group = this.groups.pop();
      this.parent = this.groups[this.groups.length - 1];
    },

    add: function(elem) {
      this.parent.appendChild(elem);
    },

    // Tests if the browser is Internet Explorer; if it is,
    // we do some tricks to improve text layout.  See the
    // note at ieMeasureTextFix() for details.
    iePolyfill: function() {
      if (typeof(navigator) !== "undefined") {
        this.ie = (  /MSIE 9/i.test(navigator.userAgent) ||
                            /MSIE 10/i.test(navigator.userAgent) ||
                            /rv:11\.0/i.test(navigator.userAgent) ||
                            /Trident/i.test(navigator.userAgent) );
      }
    },

    // ### Styling & State Methods:

    setFont: function(family, size, weight) {
      // Unlike canvas, in SVG italic is handled by font-style,
      // not weight. So: we search the weight argument and
      // apply bold and italic to weight and style respectively.
      var bold = false;
      var italic = false;
      var style = "normal";
      // Weight might also be a number (200, 400, etc...) so we
      // test its type to be sure we have access to String methods.
      if( typeof weight == "string" ) {
          // look for "italic" in the weight:
          if(weight.indexOf("italic") !== -1) {
            weight = weight.replace(/italic/g, "");
            italic = true;
          }
          // look for "bold" in weight
          if(weight.indexOf("bold") !== -1) {
            weight = weight.replace(/bold/g, "");
            bold = true;
          }
          // remove any remaining spaces
          weight = weight.replace(/ /g, "");
      }
      weight = bold ? "bold" : weight;
      weight = (typeof weight === "undefined" || weight === "") ? "normal" : weight;

      style = italic ? "italic" : style;

      var fontAttributes = {
        "font-family": family,
        "font-size": size + "pt",
        "font-weight": weight,
        "font-style" : style
      };

      // Store the font size so that if the browser is Internet
      // Explorer we can fix its calculations of text width.
      this.fontSize = Number(size);

      Vex.Merge(this.attributes, fontAttributes);
      Vex.Merge(this.state, fontAttributes);

      return this;
    },

    setRawFont: function(font) {
      font=font.trim();
      // Assumes size first, splits on space -- which is presently
      // how all existing modules are calling this.
      var fontArray = font.split(" ");

      this.attributes["font-family"] = fontArray[1];
      this.state["font-family"] = fontArray[1];

      this.attributes["font-size"] = fontArray[0];
      this.state["font-size"] = fontArray[0];

      // Saves fontSize for IE polyfill
      this.fontSize = Number(fontArray[0].match(/\d+/));
      return this;
    },

    setFillStyle: function(style) {
      this.attributes.fill = style;
      return this;
    },

    setBackgroundFillStyle: function(style) {
      this.background_attributes.fill = style;
      this.background_attributes.stroke = style;
      return this;
    },

    setStrokeStyle: function(style) {
      this.attributes.stroke = style;
      return this;
    },

    setShadowColor: function(style) {
      this.shadow_attributes.color = style;
      return this;
    },

    setShadowBlur: function(blur) {
      this.shadow_attributes.width = blur;
      return this;
    },

    setLineWidth: function(width) {
      this.attributes["stroke-width"] = width;
      this.lineWidth = width;
    },

    setLineDash: function(lineDash) {
      this.attributes["stroke-linedash"] = lineDash;
      return this;
    },

    setLineCap: function(lineCap) {
      this.attributes["stroke-linecap"] = lineCap;
      return this;
    },

    // ### Sizing & Scaling Methods:

    // TODO (GCR): See note at scale() -- seperate our internal
    // conception of pixel-based width/height from the style.width
    // and style.height properties eventually to allow users to
    // apply responsive sizing attributes to the SVG.
    resize: function(width, height) {
      this.width = width;
      this.height = height;
      this.element.style.width = width;
      var attributes = {
        width : width,
        height : height
      };
      this.applyAttributes(this.svg, attributes);
      return this;
    },

    scale: function(x, y) {
      // uses viewBox to scale
      // TODO (GCR): we may at some point want to distinguish the
      // style.width / style.height properties that are applied to
      // the SVG object from our internal conception of the SVG
      // width/height.  This would allow us to create automatically
      // scaling SVG's that filled their containers, for instance.
      //
      // As this isn't implemented in Canvas or Raphael contexts,
      // I've left as is for now, but in using the viewBox to
      // handle internal scaling, am trying to make it possible
      // for us to eventually move in that direction.

      this.state.scale = { x: x, y: y };
      var visibleWidth = this.width / x;
      var visibleHeight = this.height / y;
      this.setViewBox(0,0, visibleWidth, visibleHeight);

      return this;
    },

    setViewBox: function(xMin, yMin, width, height) {
      // Override for "x y w h" style:
      if(arguments.length == 1) this.svg.setAttribute("viewBox", viewBox);
      else {
        var viewBoxString = xMin + " " + yMin + " " + width + " " + height;
        this.svg.setAttribute("viewBox", viewBoxString);
      }
    },

    // ### Drawing helper methods:

    applyAttributes: function(element, attributes) {
      for(var propertyName in attributes) {
        element.setAttributeNS(null, propertyName, attributes[propertyName]);
      }
      return element;
    },

    flipRectangle: function(args) {
      // Avoid invalid negative height attributes by
      // flipping a rectangle w/ negative height on its head.
      // Since args is the actual arguments object from
      // one of the rectangle functions, we don't need to
      // return it.

      // Add negative height to Y
      args[1] += args[3];
      // Make the negative height positive.
      args[3] = -args[3];
    },

    // ### Shape & Path Methods:

    clear: function() {
      // Clear the SVG by removing all inner children.

      // (This approach is usually slightly more efficient
      // than removing the old SVG & adding a new one to
      // the container element, since it does not cause the
      // container to resize twice.  Also, the resize
      // triggered by removing the entire SVG can trigger
      // a touchcancel event when the element resizes away
      // from a touch point.)

      while (this.svg.lastChild) {
        this.svg.removeChild(this.svg.lastChild);
      }

      // Replace the viewbox attribute we just removed:
      this.scale(this.state.scale.x, this.state.scale.y);
    },

    // ## Rectangles:

    rect: function(x, y, width, height, attributes) {
      // Avoid invalid negative height attribs by
      // flipping the rectangle on its head:
      if (height < 0) this.flipRectangle(arguments);

      // Create the rect & style it:
      var rect = this.create("rect");
      if(typeof attributes === "undefined") attributes = {
        fill: "none",
        "stroke-width": this.lineWidth,
        stroke: "black"
      };
      Vex.Merge(attributes, {
        x: x,
        y: y,
        width: width,
        height: height
      });

      this.applyAttributes(rect, attributes);

      this.add(rect);
      return this;
    },

    fillRect: function(x, y, width, height) {
      if(height < 0) this.flipRectangle(arguments);

      this.rect(x, y, width - 0.5, height - 0.5, this.attributes);
      return this;
    },

    clearRect: function(x, y, width, height) {
      // TODO(GCR): Improve implementation of this...
      // Currently it draws a box of the background color, rather
      // than creating alpha through lower z-levels.
      //
      // See the implementation of this in SVGKit:
      // http://sourceforge.net/projects/svgkit/
      // as a starting point.
      //
      // Adding a large number of transform paths (as we would
      // have to do) could be a real performance hit.  Since
      // tabNote seems to be the only module that makes use of this
      // it may be worth creating a seperate tabStave that would
      // draw lines around locations of tablature fingering.
      //

      if (height < 0) this.flipRectangle(arguments);

      this.rect(x, y, width - 0.5, height - 0.5, this.background_attributes);
      return this;
    },

    // ## Paths:

    beginPath: function() {
      this.path = "";
      this.pen.x = 0;
      this.pen.y = 0;
      return this;
    },

    moveTo: function(x, y) {
      this.path += "M" + x + " " + y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    lineTo: function(x, y) {
      this.path += "L" + x + " " + y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
      this.path += "C" +
        x1 + " " +
        y1 + "," +
        x2 + " " +
        y2 + "," +
        x + " " +
        y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    quadraticCurveTo: function(x1, y1, x, y) {
      this.path += "Q" +
        x1 + " " +
        y1 + "," +
        x + " " +
        y;
      this.pen.x = x;
      this.pen.y = y;
      return this;
    },

    // This is an attempt (hack) to simulate the HTML5 canvas
    // arc method.
    arc: function(x, y, radius, startAngle, endAngle, antiClockwise) {
      function normalizeAngle(angle) {
        while (angle < 0) {
          angle += Math.PI * 2;
        }

        while (angle > Math.PI * 2) {
          angle -= Math.PI * 2;
        }
        return angle;
      }

      startAngle = normalizeAngle(startAngle);
      endAngle = normalizeAngle(endAngle);

      if (startAngle > endAngle) {
          var tmp = startAngle;
          startAngle = endAngle;
          endAngle = tmp;
          antiClockwise = !antiClockwise;
      }

      var delta = endAngle - startAngle;

      if (delta > Math.PI) {
          this.arcHelper(x, y, radius, startAngle, startAngle + delta / 2,
                         antiClockwise);
          this.arcHelper(x, y, radius, startAngle + delta / 2, endAngle,
                         antiClockwise);
      }
      else {
          this.arcHelper(x, y, radius, startAngle, endAngle, antiClockwise);
      }
      return this;
    },

    arcHelper: function(x, y, radius, startAngle, endAngle, antiClockwise) {
      var x1 = x + radius * Math.cos(startAngle);
      var y1 = y + radius * Math.sin(startAngle);

      var x2 = x + radius * Math.cos(endAngle);
      var y2 = y + radius * Math.sin(endAngle);

      var largeArcFlag = 0;
      var sweepFlag = 0;
      if (antiClockwise) {
        sweepFlag = 1;
        if (endAngle - startAngle < Math.PI)
          largeArcFlag = 1;
      }
      else if (endAngle - startAngle > Math.PI) {
          largeArcFlag = 1;
      }

      this.path += "M" + x1 + " " + y1 + " " + "A" +
        radius + " " + radius + " " + "0 " + largeArcFlag + " " + sweepFlag + " " +
        x2 + " " + y2 + "M" + this.pen.x + " " + this.pen.y;

    },

    closePath: function() {
      this.path += "Z";

      return this;
    },

    // Adapted from the source for Raphael's Element.glow
    glow: function() {
      // Calculate the width & paths of the glow:
      if (this.shadow_attributes.width > 0) {
        var sa = this.shadow_attributes;
        var num_paths = sa.width / 2;
        // Stroke at varying widths to create effect of gaussian blur:
        for (var i = 1; i <= num_paths; i++) {
          var attributes = {
            stroke: sa.color,
            "stroke-linejoin": "round",
            "stroke-linecap": "round",
            "stroke-width": +((sa.width *0.4) / num_paths * i).toFixed(3),
            opacity: +((sa.opacity || 0.3) / num_paths).toFixed(3),
          };

          var path = this.create("path");
          attributes.d = this.path;
          this.applyAttributes(path, attributes);
          this.add(path);
        }
      }
      return this;
    },

    fill: function(attributes) {
      // If our current path is set to glow, make it glow
      this.glow();

      var path = this.create("path");
      if(typeof attributes === "undefined") {
        attributes = {};
        Vex.Merge(attributes, this.attributes);
        attributes.stroke = "none";
      }

      attributes.d = this.path;

      this.applyAttributes(path, attributes);
      this.add(path);
      return this;
    },

    stroke: function() {
      // If our current path is set to glow, make it glow.
      this.glow();

      var path = this.create("path");
      var attributes = {};
      Vex.Merge(attributes, this.attributes);
      attributes.fill = "none";
      attributes["stroke-width"] = this.lineWidth;
      attributes.d = this.path;

      this.applyAttributes(path, attributes);
      this.add(path);
      return this;
    },

    // ## Text Methods:
    measureText: function(text) {
      var index = text + this.attributes["font-style"] + this.attributes["font-family"] +
                  this.attributes["font-weight"] + this.attributes["font-size"];

      var txt = this.create("text");
      if (typeof(txt.getBBox) === "function") {
        txt.textContent = text;
        this.applyAttributes(txt, this.attributes);

        // Temporarily add it to the document for measurement.
        this.svg.appendChild(txt);

        var bbox = txt.getBBox();
        if( this.ie &&
            text !== "" &&
            this.attributes["font-style"] == "italic") bbox = this.ieMeasureTextFix(bbox, text);
        this.svg.removeChild(txt);

        // For runtimes that do not have full support of bounding boxes, collect
        // some data which can be used later to extrapolate them.
        if (SVGContext.collectMeasurements) {
          SVGContext.measureTextCache[index] = {
            x: bbox.x,
            y: bbox.y,
            width: bbox.width,
            height: bbox.height
          };
        }
        if (SVGContext.validateMeasurements) {
          if (!(index in SVGContext.measureTextCache)) {
            Vex.W("measureTextCache is stale. Please update tests/measure_text_cache.js: ", index);
          }
        }
        return bbox;
      } else {
        // Inside NodeJS or other runtimes that don't support getBBox. This
        // is currently only useful for the NodeJS visual regression tests.
        return SVGContext.measureTextCache[index];
      }
    },

    ieMeasureTextFix: function(bbox, text) {
    // Internet Explorer over-pads text in italics,
    // resulting in giant width estimates for measureText.
    // To fix this, we use this formula, tested against
    // ie 11:
    // overestimate (in pixels) = FontSize(in pt) * 1.196 + 1.96
    // And then subtract the overestimate from calculated width.

      var fontSize = Number(this.fontSize);
      var m = 1.196;
      var b = 1.9598;
      var widthCorrection = (m * fontSize) + b;
      var width = bbox.width - widthCorrection;
      var height = bbox.height - 1.5;

      // Get non-protected copy:
      var box = {
        x : bbox.x,
        y : bbox.y,
        width : width,
        height : height
      };

      return box;
    },

    fillText: function(text, x, y) {
      var attributes = {};
      Vex.Merge(attributes, this.attributes);
      attributes.stroke = "none";
      attributes.x = x;
      attributes.y = y;

      var txt = this.create("text");
      txt.textContent = text;
      this.applyAttributes(txt, attributes);
      this.add(txt);
    },

    save: function() {
      // TODO(mmuthanna): State needs to be deep-copied.
      this.state_stack.push({
        state: {
          "font-family": this.state["font-family"],
          "font-weight": this.state["font-weight"],
          "font-style": this.state["font-style"],
          "font-size": this.state["font-size"]
        },
        attributes: {
          "font-family": this.attributes["font-family"],
          "font-weight": this.attributes["font-weight"],
          "font-style": this.attributes["font-style"],
          "font-size": this.attributes["font-size"],
          fill: this.attributes.fill,
          stroke: this.attributes.stroke,
          "stroke-width": this.attributes["stroke-width"]
        },
        shadow_attributes: {
          width: this.shadow_attributes.width,
          color: this.shadow_attributes.color
        }
      });
      return this;
    },

    restore: function() {
      // TODO(0xfe): State needs to be deep-restored.
      var state = this.state_stack.pop();
      this.state["font-family"] = state.state["font-family"];
      this.state["font-weight"] = state.state["font-weight"];
      this.state["font-style"] = state.state["font-style"];
      this.state["font-size"] = state.state["font-size"];

      this.attributes["font-family"] = state.attributes["font-family"];
      this.attributes["font-weight"] = state.attributes["font-weight"];
      this.attributes["font-style"] = state.attributes["font-style"];
      this.attributes["font-size"] = state.attributes["font-size"];

      this.attributes.fill = state.attributes.fill;
      this.attributes.stroke = state.attributes.stroke;
      this.attributes["stroke-width"] = state.attributes["stroke-width"];
      this.shadow_attributes.width = state.shadow_attributes.width;
      this.shadow_attributes.color = state.shadow_attributes.color;
      return this;
    }
  };

  return SVGContext;
}());

// Vex Flow
// Mohit Muthanna <mohit@muthanna.com>
//
// A rendering context for the Raphael backend.
//
// Copyright Mohit Cheppudira 2010

/** @constructor */
Vex.Flow.CanvasContext = (function() {
  function CanvasContext(context) {
    if (arguments.length > 0) this.init(context);
  }

  CanvasContext.WIDTH = 600;
  CanvasContext.HEIGHT = 400;

  CanvasContext.prototype = {
    init: function(context) {
      // Use a name that is unlikely to clash with a canvas context
      // property
      this.vexFlowCanvasContext = context;
      if (!context.canvas) {
        this.canvas = {
          width: CanvasContext.WIDTH,
          height: CanvasContext.HEIGHT
        };
      } else {
        this.canvas = context.canvas;
      }
    },

    clear: function() {
      this.vexFlowCanvasContext.clearRect(0, 0, this.canvas.width, this.canvas.height);
    },

    // Containers not implemented
    openGroup: function(cls, id, attrs) {},
    closeGroup: function() {},
    add: function(elem) {},

    setFont: function(family, size, weight) {
      this.vexFlowCanvasContext.font = (weight || "") + " " + size + "pt " + family;
      return this;
    },

    setRawFont: function(font) {
      this.vexFlowCanvasContext.font = font;
      return this;
    },

    setFillStyle: function(style) {
      this.vexFlowCanvasContext.fillStyle = style;
      return this;
    },

    setBackgroundFillStyle: function(style) {
      this.background_fillStyle = style;
      return this;
    },

    setStrokeStyle: function(style) {
      this.vexFlowCanvasContext.strokeStyle = style;
      return this;
    },

    setShadowColor: function(style) {
      this.vexFlowCanvasContext.shadowColor = style;
      return this;
    },

    setShadowBlur: function(blur) {
      this.vexFlowCanvasContext.shadowBlur = blur;
      return this;
    },

    setLineWidth: function(width) {
      this.vexFlowCanvasContext.lineWidth = width;
      return this;
    },

    setLineCap: function(cap_type) {
      this.vexFlowCanvasContext.lineCap = cap_type;
      return this;
    },

    setLineDash: function(dash) {
      this.vexFlowCanvasContext.lineDash = dash;
    },

    scale: function(x, y) {
      return this.vexFlowCanvasContext.scale(parseFloat(x), parseFloat(y));
    },

    resize: function(width, height) {
      return this.vexFlowCanvasContext.resize(
          parseInt(width, 10), parseInt(height, 10));
    },

    rect: function(x, y, width, height) {
      return this.vexFlowCanvasContext.rect(x, y, width, height);
    },

    fillRect: function(x, y, width, height) {
      return this.vexFlowCanvasContext.fillRect(x, y, width, height);
    },

    clearRect: function(x, y, width, height) {
      return this.vexFlowCanvasContext.clearRect(x, y, width, height);
    },

    beginPath: function() {
      return this.vexFlowCanvasContext.beginPath();
    },

    moveTo: function(x, y) {
      return this.vexFlowCanvasContext.moveTo(x, y);
    },

    lineTo: function(x, y) {
      return this.vexFlowCanvasContext.lineTo(x, y);
    },

    bezierCurveTo: function(x1, y1, x2, y2, x, y) {
      return this.vexFlowCanvasContext.bezierCurveTo(x1, y1, x2, y2, x, y);
    },

    quadraticCurveTo: function(x1, y1, x, y) {
      return this.vexFlowCanvasContext.quadraticCurveTo(x1, y1, x, y);
    },

    // This is an attempt (hack) to simulate the HTML5 canvas
    // arc method.
    arc: function(x, y, radius, startAngle, endAngle, antiClockwise) {
      return this.vexFlowCanvasContext.arc(x, y, radius, startAngle, endAngle, antiClockwise);
    },

    // Adapted from the source for Raphael's Element.glow
    glow: function() {
      return this.vexFlowCanvasContext.glow();
    },

    fill: function() {
      return this.vexFlowCanvasContext.fill();
    },

    stroke: function() {
      return this.vexFlowCanvasContext.stroke();
    },

    closePath: function() {
      return this.vexFlowCanvasContext.closePath();
    },

    measureText: function(text) {
      return this.vexFlowCanvasContext.measureText(text);
    },

    fillText: function(text, x, y) {
      return this.vexFlowCanvasContext.fillText(text, x, y);
    },

    save: function() {
      return this.vexFlowCanvasContext.save();
    },

    restore: function() {
      return this.vexFlowCanvasContext.restore();
    }
  };

  return CanvasContext;
}());

// Vex Flow Notation
// Author Larry Kuhns 2011
// Implements barlines (single, double, repeat, end)
//
// Requires vex.js.

/**
 * @constructor
 */
Vex.Flow.Barline = (function() {
  function Barline(type, x) {
    if (arguments.length > 0) this.init(type, x);
  }

  Barline.type = {
    SINGLE: 1,
    DOUBLE: 2,
    END: 3,
    REPEAT_BEGIN: 4,
    REPEAT_END: 5,
    REPEAT_BOTH: 6,
    NONE: 7
  };

  Vex.Inherit(Barline, Vex.Flow.StaveModifier, {
    init: function(type, x) {
      Barline.superclass.init.call(this);
      this.thickness = Vex.Flow.STAVE_LINE_THICKNESS;
      this.barline = type;
      this.x = x;    // Left most x for the stave
    },

    getCategory: function() { return "barlines"; },
    setX: function(x) { this.x = x; return this; },

    // Draw barlines
    draw: function(stave, x_shift) {
      x_shift = typeof x_shift !== 'number' ? 0 : x_shift;

      switch (this.barline) {
        case Barline.type.SINGLE:
          this.drawVerticalBar(stave, this.x, false);
          break;
        case Barline.type.DOUBLE:
          this.drawVerticalBar(stave, this.x, true);
          break;
        case Barline.type.END:
          this.drawVerticalEndBar(stave, this.x);
          break;
        case Barline.type.REPEAT_BEGIN:
          // If the barline is shifted over (in front of clef/time/key)
          // Draw vertical bar at the beginning.
          if (x_shift > 0) {
            this.drawVerticalBar(stave, this.x);
          }
          this.drawRepeatBar(stave, this.x + x_shift, true);
          break;
        case Barline.type.REPEAT_END:
          this.drawRepeatBar(stave, this.x, false);
          break;
        case Barline.type.REPEAT_BOTH:
          this.drawRepeatBar(stave, this.x, false);
          this.drawRepeatBar(stave, this.x, true);
          break;
        default:
          // Default is NONE, so nothing to draw
          break;
      }
    },

    drawVerticalBar: function(stave, x, double_bar) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");
      var topY = stave.getYForLine(0);
      var botY = stave.getYForLine(stave.getNumLines() - 1) + this.thickness;
      if (double_bar)
        stave.context.fillRect(x - 3, topY, 1, botY - topY);
      stave.context.fillRect(x, topY, 1, botY - topY);
    },

    drawVerticalEndBar: function(stave, x) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var topY = stave.getYForLine(0);
      var botY = stave.getYForLine(stave.getNumLines() - 1) + this.thickness;
      stave.context.fillRect(x - 5, topY, 1, botY - topY);
      stave.context.fillRect(x - 2, topY, 3, botY - topY);
    },

    drawRepeatBar: function(stave, x, begin) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var topY = stave.getYForLine(0);
      var botY = stave.getYForLine(stave.getNumLines() - 1) + this.thickness;
      var x_shift = 3;

      if (!begin) {
        x_shift = -5;
      }

      stave.context.fillRect(x + x_shift, topY, 1, botY - topY);
      stave.context.fillRect(x - 2, topY, 3, botY - topY);

      var dot_radius = 2;

      // Shift dots left or right
      if (begin) {
        x_shift += 4;
      } else {
        x_shift -= 4;
      }

      var dot_x = (x + x_shift) + (dot_radius / 2);

      // calculate the y offset based on number of stave lines
      var y_offset = (stave.getNumLines() - 1) *
        stave.getSpacingBetweenLines();
      y_offset = (y_offset / 2) -
                 (stave.getSpacingBetweenLines() / 2);
      var dot_y = topY + y_offset + (dot_radius / 2);

      // draw the top repeat dot
      stave.context.beginPath();
      stave.context.arc(dot_x, dot_y, dot_radius, 0, Math.PI * 2, false);
      stave.context.fill();

      //draw the bottom repeat dot
      dot_y += stave.getSpacingBetweenLines();
      stave.context.beginPath();
      stave.context.arc(dot_x, dot_y, dot_radius, 0, Math.PI * 2, false);
      stave.context.fill();
    }
  });

  return Barline;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
// This class by Raffaele Viglianti, 2012 http://itisnotsound.wordpress.com/
//
// This class implements hairpins between notes.
// Hairpins can be either Crescendo or Descrescendo.

/**
 * Create a new hairpin from the specified notes.
 *
 * @constructor
 * @param {!Object} notes The notes to tie up.
 * @param {!Object} type The type of hairpin
 */
Vex.Flow.StaveHairpin = (function() {
  function StaveHairpin(notes, type) {
    if (arguments.length > 0) this.init(notes, type);
  }

  StaveHairpin.type = {
    CRESC: 1,
    DECRESC: 2
  };

  /* Helper function to convert ticks into pixels.
   * Requires a Formatter with voices joined and formatted (to
   * get pixels per tick)
   *
   * options is struct that has:
   *
   *  {
   *   height: px,
   *   y_shift: px, //vertical offset
   *   left_shift_ticks: 0, //left horizontal offset expressed in ticks
   *   right_shift_ticks: 0 // right horizontal offset expressed in ticks
   *  }
   *
   **/
  StaveHairpin.FormatByTicksAndDraw = function(ctx, formatter, notes, type, position, options) {
    var ppt = formatter.pixelsPerTick;

    if (ppt == null){
      throw new Vex.RuntimeError("BadArguments",
          "A valid Formatter must be provide to draw offsets by ticks.");}

    var l_shift_px = ppt * options.left_shift_ticks;
    var r_shift_px = ppt * options.right_shift_ticks;

    var hairpin_options = {
      height: options.height,
      y_shift:options.y_shift,
      left_shift_px:l_shift_px,
      right_shift_px:r_shift_px};

    new StaveHairpin({
      first_note: notes.first_note,
      last_note: notes.last_note
    }, type)
      .setContext(ctx)
      .setRenderOptions(hairpin_options)
      .setPosition(position)
      .draw();
  };

  StaveHairpin.prototype = {
    init: function(notes, type) {
      /**
       * Notes is a struct that has:
       *
       *  {
       *    first_note: Note,
       *    last_note: Note,
       *  }
       *
       **/

      this.notes = notes;
      this.hairpin = type;
      this.position = Vex.Flow.Modifier.Position.BELOW;

      this.context = null;

      this.render_options = {
          height: 10,
          y_shift: 0, //vertical offset
          left_shift_px: 0, //left horizontal offset
          right_shift_px: 0 // right horizontal offset
        };

      this.setNotes(notes);
    },

    setContext: function(context) { this.context = context; return this; },

    setPosition: function(position) {
      if (position == Vex.Flow.Modifier.Position.ABOVE ||
          position == Vex.Flow.Modifier.Position.BELOW)
        this.position = position;
      return this;
    },

    setRenderOptions: function(options) {
      if (options.height != null &&
          options.y_shift != null &&
          options.left_shift_px != null &&
          options.right_shift_px != null){
        this.render_options = options;
      }
      return this;
    },

    /**
     * Set the notes to attach this hairpin to.
     *
     * @param {!Object} notes The start and end notes.
     */
    setNotes: function(notes) {
      if (!notes.first_note && !notes.last_note)
        throw new Vex.RuntimeError("BadArguments",
            "Hairpin needs to have either first_note or last_note set.");

      // Success. Lets grab 'em notes.
      this.first_note = notes.first_note;
      this.last_note = notes.last_note;
      return this;
    },

    renderHairpin: function(params) {
      var ctx = this.context;
      var dis = this.render_options.y_shift + 20;
      var y_shift = params.first_y;

      if (this.position == Vex.Flow.Modifier.Position.ABOVE) {
        dis = -dis +30;
        y_shift = params.first_y - params.staff_height;
      }

      var l_shift = this.render_options.left_shift_px;
      var r_shift = this.render_options.right_shift_px;

      switch (this.hairpin) {
        case StaveHairpin.type.CRESC:
          ctx.moveTo(params.last_x + r_shift, y_shift + dis);
          ctx.lineTo(params.first_x + l_shift, y_shift +(this.render_options.height/2) + dis);
          ctx.lineTo(params.last_x + r_shift, y_shift + this.render_options.height + dis);
          break;
        case StaveHairpin.type.DECRESC:
          ctx.moveTo(params.first_x + l_shift, y_shift + dis);
          ctx.lineTo(params.last_x + r_shift, y_shift +(this.render_options.height/2) + dis);
          ctx.lineTo(params.first_x + l_shift, y_shift + this.render_options.height + dis);
          break;
        default:
          // Default is NONE, so nothing to draw
          break;
      }

      ctx.stroke();
    },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw Hairpin without a context.");

      var first_note = this.first_note;
      var last_note = this.last_note;

      var start = first_note.getModifierStartXY(this.position, 0);
      var end = last_note.getModifierStartXY(this.position, 0);

      this.renderHairpin({
        first_x: start.x,
        last_x: end.x,
        first_y: first_note.getStave().y + first_note.getStave().height,
        last_y: last_note.getStave().y + last_note.getStave().height,
        staff_height: first_note.getStave().height
      });
     return true;
    }
  };
  return StaveHairpin;
}());


// Vex Flow Notation
// Author Larry Kuhns 2011
// Implements voltas (repeat brackets)
//
// Requires vex.js.

Vex.Flow.Volta = (function() {
  function Volta(type, number, x, y_shift) {
    if (arguments.length > 0) this.init(type, number, x, y_shift);
  }

  Volta.type = {
    NONE: 1,
    BEGIN: 2,
    MID: 3,
    END: 4,
    BEGIN_END: 5
  };

  Vex.Inherit(Volta, Vex.Flow.StaveModifier, {
    init: function(type, number, x, y_shift) {
      Volta.superclass.init.call(this);

      this.volta = type;
      this.x = x;
      this.y_shift = y_shift;
      this.number = number;
      this.font = {
        family: "sans-serif",
        size: 9,
        weight: "bold"
      };
    },

    getCategory: function() { return "voltas"; },
    setShiftY: function(y) { this.y_shift = y; return this; },

    draw: function(stave, x) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
        "Can't draw stave without canvas context.");
      var ctx = stave.context;
      var width = stave.width;
      var top_y = stave.getYForTopText(stave.options.num_lines) + this.y_shift;
      var vert_height = 1.5 * stave.options.spacing_between_lines_px;
      switch(this.volta) {
        case Vex.Flow.Volta.type.BEGIN:
          ctx.fillRect(this.x + x, top_y, 1, vert_height);
          break;
        case Vex.Flow.Volta.type.END:
          width -= 5;
          ctx.fillRect(this.x + x + width, top_y, 1, vert_height);
          break;
        case Vex.Flow.Volta.type.BEGIN_END:
          width -= 3;
          ctx.fillRect(this.x + x, top_y, 1, vert_height);
          ctx.fillRect(this.x + x + width, top_y, 1, vert_height);
          break;
      }
        // If the beginning of a volta, draw measure number
      if (this.volta == Volta.type.BEGIN ||
          this.volta == Volta.type.BEGIN_END) {
        ctx.save();
        ctx.setFont(this.font.family, this.font.size, this.font.weight);
        ctx.fillText(this.number, this.x + x + 5, top_y + 15);
        ctx.restore();
      }
      ctx.fillRect(this.x + x, top_y, width, 1);
      return this;
    }
  });

  return Volta;
}());
// Vex Flow Notation
// Author Larry Kuhns 2011
// Implements Repetitions (Coda, signo, D.C., etc.)
//
// Requires vex.js.

Vex.Flow.Repetition = (function() {
  function Repetition(type, x, y_shift) {
    if (arguments.length > 0) this.init(type, x, y_shift);
  }

  Repetition.type = {
    NONE: 1,         // no coda or segno
    CODA_LEFT: 2,    // coda at beginning of stave
    CODA_RIGHT: 3,   // coda at end of stave
    SEGNO_LEFT: 4,   // segno at beginning of stave
    SEGNO_RIGHT: 5,  // segno at end of stave
    DC: 6,           // D.C. at end of stave
    DC_AL_CODA: 7,   // D.C. al coda at end of stave
    DC_AL_FINE: 8,   // D.C. al Fine end of stave
    DS: 9,           // D.S. at end of stave
    DS_AL_CODA: 10,  // D.S. al coda at end of stave
    DS_AL_FINE: 11,  // D.S. al Fine at end of stave
    FINE: 12         // Fine at end of stave
  };

  Vex.Inherit(Repetition, Vex.Flow.StaveModifier, {
    init: function(type, x, y_shift) {
      Repetition.superclass.init.call(this);

      this.symbol_type = type;
      this.x = x;
      this.x_shift = 0;
      this.y_shift = y_shift;
      this.font = {
        family: "times",
        size: 12,
        weight: "bold italic"
      };
    },

    getCategory: function() { return "repetitions"; },
    setShiftX: function(x) { this.x_shift = x; return this; },
    setShiftY: function(y) { this.y_shift = y; return this; },

    draw: function(stave, x) {
      switch (this.symbol_type) {
        case Repetition.type.CODA_RIGHT:
          this.drawCodaFixed(stave, x + stave.width);
          break;
        case Repetition.type.CODA_LEFT:
          this.drawSymbolText(stave, x, "Coda", true);
          break;
        case Repetition.type.SEGNO_LEFT:
          this.drawSignoFixed(stave, x);
          break;
        case Repetition.type.SEGNO_RIGHT:
          this.drawSignoFixed(stave, x + stave.width);
          break;
        case Repetition.type.DC:
          this.drawSymbolText(stave, x, "D.C.", false);
          break;
        case Repetition.type.DC_AL_CODA:
          this.drawSymbolText(stave, x, "D.C. al", true);
          break;
        case Repetition.type.DC_AL_FINE:
          this.drawSymbolText(stave, x, "D.C. al Fine", false);
          break;
        case Repetition.type.DS:
          this.drawSymbolText(stave, x, "D.S.", false);
          break;
        case Repetition.type.DS_AL_CODA:
          this.drawSymbolText(stave, x, "D.S. al", true);
          break;
        case Repetition.type.DS_AL_FINE:
          this.drawSymbolText(stave, x, "D.S. al Fine", false);
          break;
        case Repetition.type.FINE:
          this.drawSymbolText(stave, x, "Fine", false);
          break;
        default:
          break;
      }

      return this;
    },

    drawCodaFixed: function(stave, x) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var y = stave.getYForTopText(stave.options.num_lines) + this.y_shift;
      Vex.Flow.renderGlyph(stave.context, this.x + x + this.x_shift,
                           y + 25, 40, "v4d", true);
      return this;
    },

    drawSignoFixed: function(stave, x) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");
      var y = stave.getYForTopText(stave.options.num_lines) + this.y_shift;
      Vex.Flow.renderGlyph(stave.context, this.x + x + this.x_shift,
                           y + 25, 30, "v8c", true);
      return this;
    },

    drawSymbolText: function(stave, x, text, draw_coda) {
      if (!stave.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw stave without canvas context.");

      var ctx = stave.context;
      ctx.save();
      ctx.setFont(this.font.family, this.font.size, this.font.weight);
        // Default to right symbol
      var text_x = 0 + this.x_shift;
      var symbol_x = x + this.x_shift;
      if (this.symbol_type == Vex.Flow.Repetition.type.CODA_LEFT) {
          // Offset Coda text to right of stave beginning
        text_x = this.x + stave.options.vertical_bar_width;
        symbol_x = text_x + ctx.measureText(text).width + 12;
      } else {
          // Offset Signo text to left stave end
        symbol_x = this.x + x + stave.width - 5 + this.x_shift;
        text_x = symbol_x - + ctx.measureText(text).width - 12;
      }
      var y = stave.getYForTopText(stave.options.num_lines) + this.y_shift;
      if (draw_coda) {
        Vex.Flow.renderGlyph(ctx, symbol_x, y, 40, "v4d", true);
      }

      ctx.fillText(text, text_x, y + 5);
      ctx.restore();

      return this;
    }
  });

  return Repetition;
}());
// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
// Author Larry Kuhns 2011
// Implements stave section names.

/**
 * @constructor
 */
Vex.Flow.StaveSection = (function() {
  function StaveSection(section, x, shift_y) {
    if (arguments.length > 0) this.init(section, x, shift_y);
  }

  var Modifier = Vex.Flow.Modifier;
  Vex.Inherit(StaveSection, Modifier, {
    init: function(section, x, shift_y) {
      StaveSection.superclass.init.call(this);

      this.setWidth(16);
      this.section = section;
      this.position = Modifier.Position.ABOVE;
      this.x = x;
      this.shift_x = 0;
      this.shift_y = shift_y;
      this.font = {
        family: "sans-serif",
        size: 12,
        weight: "bold"
      };
    },

    getCategory: function() { return "stavesection"; },
    setStaveSection: function(section) { this.section = section; return this; },
    setShiftX: function(x) { this.shift_x = x; return this; },
    setShiftY: function(y) { this.shift_y = y; return this; },

    draw: function(stave, shift_x) {
      if (!stave.context) throw new Vex.RERR("NoContext",
        "Can't draw stave section without a context.");

      var ctx = stave.context;

      ctx.save();
      ctx.lineWidth = 2;
      ctx.setFont(this.font.family, this.font.size, this.font.weight);
      var text_width = ctx.measureText("" + this.section).width;
      var width = text_width + 6;  // add left & right padding
      if (width < 18) width = 18;
      var height = 20;
        //  Seems to be a good default y
      var y = stave.getYForTopText(3) + this.shift_y;
      var x = this.x + shift_x;
      ctx.beginPath();
      ctx.lineWidth = 2;
      ctx.rect(x, y, width, height);
      ctx.stroke();
      x += (width - text_width) / 2;
      ctx.fillText("" + this.section, x, y + 16);
      ctx.restore();
      return this;
    }
  });

  return StaveSection;
}());
// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
// Author Radosaw Eichler 2012
// Implements tempo marker.

/**
 * @constructor
 * @param {Object} tempo Tempo parameters: { name, duration, dots, bpm }
 */
Vex.Flow.StaveTempo = (function() {
  function StaveTempo(tempo, x, shift_y) {
    if (arguments.length > 0) this.init(tempo, x, shift_y);
  }

  Vex.Inherit(StaveTempo, Vex.Flow.StaveModifier, {
    init: function(tempo, x, shift_y) {
      StaveTempo.superclass.init.call(this);

      this.tempo = tempo;
      this.position = Vex.Flow.Modifier.Position.ABOVE;
      this.x = x;
      this.shift_x = 10;
      this.shift_y = shift_y;
      this.font = {
        family: "times",
        size: 14,
        weight: "bold"
      };
      this.render_options = {
        glyph_font_scale: 30  // font size for note
      };
    },

    getCategory: function() { return "stavetempo"; },
    setTempo: function(tempo) { this.tempo = tempo; return this; },
    setShiftX: function(x) { this.shift_x = x; return this; },
    setShiftY: function(y) { this.shift_y = y; return this; },

    draw: function(stave, shift_x) {
      if (!stave.context) throw new Vex.RERR("NoContext",
        "Can't draw stave tempo without a context.");

      var options = this.render_options;
      var scale = options.glyph_font_scale / 38;
      var name = this.tempo.name;
      var duration = this.tempo.duration;
      var dots = this.tempo.dots;
      var bpm = this.tempo.bpm;
      var font = this.font;
      var ctx = stave.context;
      var x = this.x + this.shift_x + shift_x;
      var y = stave.getYForTopText(1) + this.shift_y;

      ctx.save();

      if (name) {
        ctx.setFont(font.family, font.size, font.weight);
        ctx.fillText(name, x, y);
        x += ctx.measureText(name).width;
      }

      if (duration && bpm) {
        ctx.setFont(font.family, font.size, 'normal');

        if (name) {
          x += ctx.measureText(" ").width;
          ctx.fillText("(", x, y);
          x += ctx.measureText("(").width;
        }

        var code = Vex.Flow.durationToGlyph(duration);

        x += 3 * scale;
        Vex.Flow.renderGlyph(ctx, x, y, options.glyph_font_scale, code.code_head);
        x += code.head_width * scale;

        // Draw stem and flags
        if (code.stem) {
          var stem_height = 30;

          if (code.beam_count) stem_height += 3 * (code.beam_count - 1);

          stem_height *= scale;

          var y_top = y - stem_height;
          ctx.fillRect(x, y_top, scale, stem_height);

          if (code.flag) {
            Vex.Flow.renderGlyph(ctx, x + scale, y_top, options.glyph_font_scale,
                                 code.code_flag_upstem);

            if (!dots) x += 6 * scale;
          }
        }

        // Draw dot
        for (var i = 0; i < dots; i++) {
          x += 6 * scale;
          ctx.beginPath();
          ctx.arc(x, y + 2 * scale, 2 * scale, 0, Math.PI * 2, false);
          ctx.fill();
        }

        ctx.fillText(" = " + bpm + (name ? ")" : ""), x + 3 * scale, y);
      }

      ctx.restore();
      return this;
    }
  });

  return StaveTempo;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// Author Taehoon Moon 2014

/**
 * @constructor
 */
Vex.Flow.StaveText = (function() {
  function StaveText(text, position, options) {
    if (arguments.length > 0) this.init(text, position, options);
  }

  var Modifier = Vex.Flow.Modifier;
  Vex.Inherit(StaveText, Modifier, {
    init: function(text, position, options) {
      StaveText.superclass.init.call(this);

      this.setWidth(16);
      this.text = text;
      this.position = position;
      this.options = {
        shift_x: 0,
        shift_y: 0,
        justification: Vex.Flow.TextNote.Justification.CENTER
      };
      Vex.Merge(this.options, options);

      this.font = {
        family: "times",
        size: 16,
        weight: "normal"
      };
    },

    getCategory: function() { return "stavetext"; },
    setStaveText: function(text) { this.text = text; return this; },
    setShiftX: function(x) { this.shift_x = x; return this; },
    setShiftY: function(y) { this.shift_y = y; return this; },

    setFont: function(font) {
      Vex.Merge(this.font, font);
    },

    setText: function(text) {
      this.text = text;
    },

    draw: function(stave) {
      if (!stave.context) throw new Vex.RERR("NoContext",
        "Can't draw stave text without a context.");

      var ctx = stave.context;

      ctx.save();
      ctx.lineWidth = 2;
      ctx.setFont(this.font.family, this.font.size, this.font.weight);
      var text_width = ctx.measureText("" + this.text).width;

      var x, y;
      var Modifier = Vex.Flow.Modifier;
      switch(this.position) {
        case Modifier.Position.LEFT:
        case Modifier.Position.RIGHT:
          y = (stave.getYForLine(0) + stave.getBottomLineY()) / 2 + this.options.shift_y;
          if(this.position == Modifier.Position.LEFT) {
            x = stave.getX() - text_width - 24 + this.options.shift_x;
          }
          else {
            x = stave.getX() + stave.getWidth() + 24 + this.options.shift_x;
          }
          break;
        case Modifier.Position.ABOVE:
        case Modifier.Position.BELOW:
          var Justification = Vex.Flow.TextNote.Justification;
          x = stave.getX() + this.options.shift_x;
          if(this.options.justification == Justification.CENTER) {
            x += stave.getWidth() / 2 - text_width / 2;
          }
          else if(this.options.justification == Justification.RIGHT) {
            x += stave.getWidth() - text_width;
          }
          
          if(this.position == Modifier.Position.ABOVE) {
            y = stave.getYForTopText(2) + this.options.shift_y;
          }
          else {
            y = stave.getYForBottomText(2) + this.options.shift_y;
          }
          break;
        default:
          throw new Vex.RERR("InvalidPosition",
            "Value Must be in Modifier.Position.");
      }

      ctx.fillText("" + this.text, x, y + 4);
      ctx.restore();
      return this;
    }
  });

  return StaveText;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// A `BarNote` is used to render bar lines (from `barline.js`). `BarNote`s can
// be added to a voice and rendered in the middle of a stave. Since it has no
// duration, it consumes no `tick`s, and is dealt with appropriately by the formatter.
//
// See `tests/barnote_tests.js` for usage examples.

Vex.Flow.BarNote = (function() {
  function BarNote() { this.init(); }

  // To enable logging for this class. Set `Vex.Flow.BarNote.DEBUG` to `true`.
  function L() { if (BarNote.DEBUG) Vex.L("Vex.Flow.BarNote", arguments); }

  // ## Prototype Methods
  Vex.Inherit(BarNote, Vex.Flow.Note, {
    init: function() {
      BarNote.superclass.init.call(this, {duration: "b"});

      var TYPE = Vex.Flow.Barline.type;
      this.metrics = {
        widths: {}
      };

      // Defined this way to prevent lint errors.
      this.metrics.widths[TYPE.SINGLE] = 8;
      this.metrics.widths[TYPE.DOUBLE] = 12;
      this.metrics.widths[TYPE.END] = 15;
      this.metrics.widths[TYPE.REPEAT_BEGIN] = 14;
      this.metrics.widths[TYPE.REPEAT_END] = 14;
      this.metrics.widths[TYPE.REPEAT_BOTH] = 18;
      this.metrics.widths[TYPE.NONE] = 0;

      // Tell the formatter that bar notes have no duration.
      this.ignore_ticks = true;
      this.type = TYPE.SINGLE;

      // Set width to width of relevant `Barline`.
      this.setWidth(this.metrics.widths[this.type]);
    },

    // Get and set the type of Bar note. `type` must be one of `Vex.Flow.Barline.type`.
    getType: function() { return this.type; },
    setType: function(type) {
      this.type = type;
      this.setWidth(this.metrics.widths[this.type]);
      return this;
    },

    getBoundingBox: function() {
      return new Vex.Flow.BoundingBox(0, 0, 0, 0);
    },

    addToModifierContext: function() {
      /* overridden to ignore */
      return this;
    },

    preFormat: function() {
      /* overridden to ignore */
      this.setPreFormatted(true);
      return this;
    },

    // Render note to stave.
    draw: function() {
      if (!this.stave) throw new Vex.RERR("NoStave", "Can't draw without a stave.");
      L("Rendering bar line at: ", this.getAbsoluteX());
      var barline = new Vex.Flow.Barline(this.type, this.getAbsoluteX());
      barline.draw(this.stave);
    }
  });

  return BarNote;
}());

// VexFlow - Music Engraving for HTML5
// Author: Mike Corrigan <corrigan@gmail.com>
//
// This class implements tremolo notation.

/**
 * @constructor
 */
Vex.Flow.Tremolo = (function() {
  function Tremolo(num) {
    if (arguments.length > 0) this.init(num);
  }

  var Modifier = Vex.Flow.Modifier;
  Vex.Inherit(Tremolo, Modifier, {
    init: function(num) {
      Tremolo.superclass.init.call(this);

      this.num = num;
      this.note = null;
      this.index = null;
      this.position = Modifier.Position.CENTER;
      this.code = "v74";
      this.shift_right = -2;
      this.y_spacing = 4;

      this.render_options = {
        font_scale: 35,
        stroke_px: 3,
        stroke_spacing: 10
      };

      this.font = {
        family: "Arial",
        size: 16,
        weight: ""
      };
    },

    getCategory: function() { return "tremolo"; },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw Tremolo without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw Tremolo without a note and index.");

      var start = this.note.getModifierStartXY(this.position, this.index);
      var x = start.x;
      var y = start.y;

      x += this.shift_right;
      for (var i = 0; i < this.num; ++i) {
        Vex.Flow.renderGlyph(this.context, x, y,
                             this.render_options.font_scale, this.code);
        y += this.y_spacing;
      }
    }
  });

  return Tremolo;
}());

/**
 * Create a new tuplet from the specified notes. The notes must
 * be part of the same line, and have the same duration (in ticks).
 *
 * @constructor
 * @param {Array.<Vex.Flow.StaveNote>} A set of notes.
 */
Vex.Flow.Tuplet = (function() {
  function Tuplet(notes, options) {
    if (arguments.length > 0) this.init(notes, options);
  }

  Tuplet.LOCATION_TOP = 1;
  Tuplet.LOCATION_BOTTOM = -1;

  Tuplet.prototype = {
    init: function(notes, options) {
      if (!notes || notes == []) {
        throw new Vex.RuntimeError("BadArguments", "No notes provided for tuplet.");
      }

      if (notes.length == 1) {
        throw new Vex.RuntimeError("BadArguments", "Too few notes for tuplet.");
      }

      this.options = Vex.Merge({}, options);
      this.notes = notes;
      this.num_notes = 'num_notes' in this.options ?
        this.options.num_notes : notes.length;
      this.beats_occupied = 'beats_occupied' in this.options ?
        this.options.beats_occupied : 2;
      this.bracketed = (notes[0].beam == null);
      this.ratioed = false;
      this.point = 28;
      this.y_pos = 16;
      this.x_pos = 100;
      this.width = 200;
      this.location = Tuplet.LOCATION_TOP;

      Vex.Flow.Formatter.AlignRestsToNotes(notes, true, true);
      this.resolveGlyphs();
      this.attach();
    },

    attach: function () {
      for (var i = 0; i < this.notes.length; i++) {
        var note = this.notes[i];
        note.setTuplet(this);
      }
    },

    detach: function () {
      for (var i = 0; i < this.notes.length; i++) {
        var note = this.notes[i];
        note.setTuplet(null);
      }
    },

    setContext: function(context) {
      this.context = context;
      return this;
    },

    /**
     * Set whether or not the bracket is drawn.
     */
    setBracketed: function(bracketed) {
      this.bracketed = bracketed ? true : false;
      return this;
    },

    /**
     * Set whether or not the ratio is shown.
     */
    setRatioed: function(ratioed) {
      this.ratioed = ratioed ? true : false;
      return this;
    },

    /**
     * Set the tuplet to be displayed either on the top or bottom of the stave
     */
    setTupletLocation: function(location) {
      if (!location) location = Tuplet.LOCATION_TOP;
      else if (location != Tuplet.LOCATION_TOP &&
          location != Tuplet.LOCATION_BOTTOM) {
        throw new Vex.RERR("BadArgument", "Invalid tuplet location: " + location);
      }

      this.location = location;
      return this;
    },

    getNotes: function() {
      return this.notes;
    },

    getNoteCount: function() {
      return this.num_notes;
    },

    getBeatsOccupied: function() {
      return this.beats_occupied;
    },

    setBeatsOccupied: function(beats) {
      this.detach();
      this.beats_occupied = beats;
      this.resolveGlyphs();
      this.attach();
    },

    resolveGlyphs: function() {
      this.num_glyphs = [];
      var n = this.num_notes;
      while (n >= 1) {
        this.num_glyphs.push(new Vex.Flow.Glyph("v" + (n % 10), this.point));
        n = parseInt(n / 10, 10);
      }

      this.denom_glyphs = [];
      n = this.beats_occupied;
      while (n >= 1) {
        this.denom_glyphs.push(new Vex.Flow.Glyph("v" + (n % 10), this.point));
        n = parseInt(n / 10, 10);
      }
    },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");

      // determine x value of left bound of tuplet
      var first_note = this.notes[0];
      var last_note = this.notes[this.notes.length - 1];

      if (!this.bracketed) {
        this.x_pos = first_note.getStemX();
        this.width = last_note.getStemX() - this.x_pos;
      }
      else {
        this.x_pos = first_note.getTieLeftX() - 5;
        this.width = last_note.getTieRightX() - this.x_pos + 5;
      }

      // determine y value for tuplet
      var i;
      if (this.location == Tuplet.LOCATION_TOP) {
        this.y_pos = first_note.getStave().getYForLine(0) - 15;
        //this.y_pos = first_note.getStemExtents().topY - 10;

        for (i=0; i<this.notes.length; ++i) {
          var top_y = this.notes[i].getStemDirection() === Vex.Flow.Stem.UP ?
              this.notes[i].getStemExtents().topY - 10
            : this.notes[i].getStemExtents().baseY - 20;
          if (top_y < this.y_pos)
            this.y_pos = top_y;
        }
      }
      else {
        this.y_pos = first_note.getStave().getYForLine(4) + 20;

        for (i=0; i<this.notes.length; ++i) {
          var bottom_y = this.notes[i].getStemDirection() === Vex.Flow.Stem.UP ?
              this.notes[i].getStemExtents().baseY + 20
            : this.notes[i].getStemExtents().topY + 10;
          if (bottom_y > this.y_pos)
            this.y_pos = bottom_y;
        }
      }

      // calculate total width of tuplet notation
      var width = 0;
      var glyph;
      for (glyph in this.num_glyphs) {
        width += this.num_glyphs[glyph].getMetrics().width;
      }
      if (this.ratioed) {
        for (glyph in this.denom_glyphs) {
          width += this.denom_glyphs[glyph].getMetrics().width;
        }
        width += this.point * 0.32;
      }

      var notation_center_x = this.x_pos + (this.width/2);
      var notation_start_x = notation_center_x - (width/2);

      // draw bracket if the tuplet is not beamed
      if (this.bracketed) {
        var line_width = this.width/2 - width/2 - 5;

        // only draw the bracket if it has positive length
        if (line_width > 0) {
          this.context.fillRect(this.x_pos, this.y_pos,line_width, 1);
          this.context.fillRect(this.x_pos + this.width / 2 + width / 2 + 5,
                                this.y_pos,line_width, 1);
          this.context.fillRect(this.x_pos,
              this.y_pos + (this.location == Tuplet.LOCATION_BOTTOM),
              1, this.location * 10);
          this.context.fillRect(this.x_pos + this.width,
              this.y_pos + (this.location == Tuplet.LOCATION_BOTTOM),
              1, this.location * 10);
        }
      }

      // draw numerator glyphs
      var x_offset = 0;
      var size = this.num_glyphs.length;
      for (glyph in this.num_glyphs) {
        this.num_glyphs[size-glyph-1].render(
            this.context, notation_start_x + x_offset,
            this.y_pos + (this.point/3) - 2);
        x_offset += this.num_glyphs[size-glyph-1].getMetrics().width;
      }

      // display colon and denominator if the ratio is to be shown
      if (this.ratioed) {
        var colon_x = notation_start_x + x_offset + this.point*0.16;
        var colon_radius = this.point * 0.06;
        this.context.beginPath();
        this.context.arc(colon_x, this.y_pos - this.point*0.08,
                         colon_radius, 0, Math.PI*2, true);
        this.context.closePath();
        this.context.fill();
        this.context.beginPath();
        this.context.arc(colon_x, this.y_pos + this.point*0.12,
                         colon_radius, 0, Math.PI*2, true);
        this.context.closePath();
        this.context.fill();
        x_offset += this.point*0.32;
        size = this.denom_glyphs.length;
        for (glyph in this.denom_glyphs) {
          this.denom_glyphs[size-glyph-1].render(
              this.context, notation_start_x + x_offset,
              this.y_pos + (this.point/3) - 2);
          x_offset += this.denom_glyphs[size-glyph-1].getMetrics().width;
        }
      }
    }
  };

  return Tuplet;
}());

// Vex Music Notation
// Mohit Muthanna <mohit@muthanna.com>
//
// Copyright Mohit Muthanna 2010

// Bounding boxes for interactive notation

/** @constructor */
Vex.Flow.BoundingBox = (function() {
  function BoundingBox(x, y, w, h) { this.init(x, y, w, h); }
  BoundingBox.copy = function(that) {
    return new BoundingBox(that.x, that.y, that.w, that.h); };

  BoundingBox.prototype = {
    init: function(x, y, w, h) {
      this.x = x;
      this.y = y;
      this.w = w;
      this.h = h;
    },

    getX: function() { return this.x; },
    getY: function() { return this.y; },
    getW: function() { return this.w; },
    getH: function() { return this.h; },

    setX: function(x) { this.x = x; return this; },
    setY: function(y) { this.y = y; return this; },
    setW: function(w) { this.w = w; return this; },
    setH: function(h) { this.h = h; return this; },

    move: function(x, y) { this.x += x; this.y += y; },
    clone: function() { return BoundingBox.copy(this); },

    // Merge my box with given box. Creates a bigger bounding box unless
    // the given box is contained in this one.
    mergeWith: function(boundingBox, ctx) {
      var that = boundingBox;

      var new_x = this.x < that.x ? this.x : that.x;
      var new_y = this.y < that.y ? this.y : that.y;
      var new_w = (this.x + this.w) < (that.x + that.w) ? (that.x + that.w) - this.x : (this.x + this.w) - Vex.Min(this.x, that.x);
      var new_h = (this.y + this.h) < (that.y + that.h) ? (that.y + that.h) - this.y : (this.y + this.h) - Vex.Min(this.y, that.y);

      this.x = new_x;
      this.y = new_y;
      this.w = new_w;
      this.h = new_h;

      if (ctx) this.draw(ctx);
      return this;
    },

    draw: function(ctx, x, y) {
      if (!x) x = 0;
      if (!y) y = 0;
      ctx.rect(this.x + x, this.y + y, this.w, this.h);
      ctx.stroke();
    }
  };

  return BoundingBox;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// `TextNote` is a notation element that is positioned in time. Generally 
// meant for objects that sit above/below the staff and inline with each other.
// Examples of this would be such as dynamics, lyrics, chord changes, etc.
Vex.Flow.TextNote = (function() {
  function TextNote(text_struct) {
    if (arguments.length > 0) this.init(text_struct);
  }

  TextNote.Justification = {
    LEFT: 1,
    CENTER: 2,
    RIGHT: 3
  };

  // Glyph data
  TextNote.GLYPHS = {
    "segno": {
      code: "v8c",
      point: 40,
      x_shift: 0,
      y_shift: -10
      // width: 10 // optional
    },
    "tr": {
      code: "v1f",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "mordent_upper": {
      code: "v1e",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "mordent_lower": {
      code: "v45",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "f": {
      code: "vba",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "p": {
      code: "vbf",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "m": {
      code: "v62",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "s": {
      code: "v4a",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "z": {
      code: "v80",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
    "coda": {
      code: "v4d",
      point: 40,
      x_shift: 0,
      y_shift: -8
      // width: 10 // optional
    },
    "pedal_open": {
      code: "v36",
      point:40,
      x_shift:0,
      y_shift:0
    },
    "pedal_close": {
      code: "v5d",
      point:40,
      x_shift:0,
      y_shift:3
    },
    "caesura_straight": {
      code: "v34",
      point:40,
      x_shift:0,
      y_shift:2
    },
    "caesura_curved": {
      code: "v4b",
      point:40,
      x_shift:0,
      y_shift:2
    },
    "breath": {
      code: "v6c",
      point:40,
      x_shift:0,
      y_shift:0
    },
    "tick": {
      code: "v6f",
      point:50,
      x_shift:0,
      y_shift:0
    },
    "turn": {
      code: "v72",
      point:40,
      x_shift:0,
      y_shift:0
    },
    "turn_inverted": {
      code: "v33",
      point:40,
      x_shift:0,
      y_shift:0
    },

    // DEPRECATED - please use "mordent_upper" or "mordent_lower"
    "mordent": {
      code: "v1e",
      point: 40,
      x_shift: 0,
      y_shift: 0
      // width: 10 // optional
    },
  };

  // ## Prototype Methods
  Vex.Inherit(TextNote, Vex.Flow.Note, {
    init: function(text_struct) {
      TextNote.superclass.init.call(this, text_struct);

      // Note properties
      this.text = text_struct.text;
      this.superscript = text_struct.superscript;
      this.subscript = text_struct.subscript;
      this.glyph_type = text_struct.glyph;
      this.glyph = null;
      this.font = {
        family: "Arial",
        size: 12,
        weight: ""
      };

      // Set font
      if (text_struct.font) this.font = text_struct.font;

      // Determine and set initial note width. Note that the text width is 
      // an approximation and isn't very accurate. The only way to accurately
      // measure the length of text is with `canvasContext.measureText()`
      if (this.glyph_type) {
        var struct = TextNote.GLYPHS[this.glyph_type];
        if (!struct) throw new Vex.RERR("Invalid glyph type: " + this.glyph_type);

        this.glyph = new Vex.Flow.Glyph(struct.code, struct.point, {cache: false});

        if (struct.width)
          this.setWidth(struct.width);
        else
          this.setWidth(this.glyph.getMetrics().width);

        this.glyph_struct = struct;
      } else {
        this.setWidth(Vex.Flow.textWidth(this.text));
      }
      this.line = text_struct.line || 0;
      this.smooth = text_struct.smooth || false;
      this.ignore_ticks = text_struct.ignore_ticks || false;
      this.justification = TextNote.Justification.LEFT;
    },

    // Set the horizontal justification of the TextNote
    setJustification: function(just) {
      this.justification = just;
      return this;
    },

    // Set the Stave line on which the note should be placed
    setLine: function(line) {
      this.line = line;
      return this;
    },

    // Pre-render formatting
    preFormat: function() {
      if (!this.context) throw new Vex.RERR("NoRenderContext",
          "Can't measure text without rendering context.");
      if (this.preFormatted) return;

      if (this.smooth) {
        this.setWidth(0);
      } else {
        if (this.glyph) {
          // Width already set.
        } else {
          this.setWidth(this.context.measureText(this.text).width);
        }
      }

      if (this.justification == TextNote.Justification.CENTER) {
        this.extraLeftPx = this.width / 2;
      } else if (this.justification == TextNote.Justification.RIGHT) {
        this.extraLeftPx = this.width;
      }

      this.setPreFormatted(true);
    },

    // Renders the TextNote
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoCanvasContext",
          "Can't draw without a canvas context.");
      if (!this.stave) throw new Vex.RERR("NoStave", "Can't draw without a stave.");

      var ctx = this.context;
      var x = this.getAbsoluteX();
      if (this.justification == TextNote.Justification.CENTER) {
        x -= this.getWidth() / 2;
      } else if (this.justification == TextNote.Justification.RIGHT) {
        x -= this.getWidth();
      }

      var y;
      if (this.glyph) {
        y = this.stave.getYForLine(this.line + (-3));
        this.glyph.render(this.context,
                          x + this.glyph_struct.x_shift,
                          y + this.glyph_struct.y_shift);
      } else {
        y = this.stave.getYForLine(this.line + (-3));
        ctx.save();
        ctx.setFont(this.font.family, this.font.size, this.font.weight);
        ctx.fillText(this.text, x, y);

        // Width of the letter M gives us the approximate height of the text
        var height = ctx.measureText("M").width;
        // Get accurate width of text
        var width = ctx.measureText(this.text).width;

        // Write superscript
        if (this.superscript) {
          ctx.setFont(this.font.family, this.font.size / 1.3, this.font.weight);
          ctx.fillText(this.superscript, x + width + 2, y - (height/2.2));
        }

        // Write subscript
        if (this.subscript) {
          ctx.setFont(this.font.family, this.font.size / 1.3, this.font.weight);
          ctx.fillText(this.subscript, x + width + 2, y + (height/2.2) - 1);
        }

        ctx.restore();
      }
    }
  });

  return TextNote;
}());

// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
// Author Larry Kuhns 2013
// Class to draws string numbers into the notation.

/**
 * @constructor
 */
Vex.Flow.FretHandFinger = (function() {
  function FretHandFinger(number) {
    if (arguments.length > 0) this.init(number);
  }
  FretHandFinger.CATEGORY = "frethandfinger";

  var Modifier = Vex.Flow.Modifier;

  // Arrange fingerings inside a ModifierContext.
  FretHandFinger.format = function(nums, state) {
    var left_shift = state.left_shift;
    var right_shift = state.right_shift;
    var num_spacing = 1;

    if (!nums || nums.length === 0) return false;

    var nums_list = [];
    var prev_note = null;
    var shift_left = 0;
    var shift_right = 0;

    var i, num, note, pos, props_tmp;
    for (i = 0; i < nums.length; ++i) {
      num = nums[i];
      note = num.getNote();
      pos = num.getPosition();
      var props = note.getKeyProps()[num.getIndex()];
      if (note != prev_note) {
        for (var n = 0; n < note.keys.length; ++n) {
          props_tmp = note.getKeyProps()[n];
          if (left_shift === 0)
            shift_left = (props_tmp.displaced ? note.getExtraLeftPx() : shift_left);
          if (right_shift === 0)
            shift_right = (props_tmp.displaced ? note.getExtraRightPx() : shift_right);
        }
        prev_note = note;
      }

      nums_list.push({ line: props.line, pos: pos, shiftL: shift_left, shiftR: shift_right, note: note, num: num });
    }

    // Sort fingernumbers by line number.
    nums_list.sort(function(a, b) { return (b.line - a.line); });

    var num_shiftL = 0;
    var num_shiftR = 0;
    var x_widthL = 0;
    var x_widthR = 0;
    var last_line = null;
    var last_note = null;

    for (i = 0; i < nums_list.length; ++i) {
      var num_shift = 0;
      note = nums_list[i].note;
      pos = nums_list[i].pos;
      num = nums_list[i].num;
      var line = nums_list[i].line;
      var shiftL = nums_list[i].shiftL;
      var shiftR = nums_list[i].shiftR;

      // Reset the position of the string number every line.
      if (line != last_line || note != last_note) {
        num_shiftL = left_shift + shiftL;
        num_shiftR = right_shift + shiftR;
      }

      var num_width = num.getWidth() + num_spacing;
      if (pos == Vex.Flow.Modifier.Position.LEFT) {
        num.setXShift(left_shift + num_shiftL);
        num_shift = left_shift + num_width; // spacing
        x_widthL = (num_shift > x_widthL) ? num_shift : x_widthL;
      } else if (pos == Vex.Flow.Modifier.Position.RIGHT) {
        num.setXShift(num_shiftR);
        num_shift = shift_right + num_width; // spacing
        x_widthR = (num_shift > x_widthR) ? num_shift : x_widthR;
      }
      last_line = line;
      last_note = note;
    }

    state.left_shift += x_widthL;
    state.right_shift += x_widthR;
  };

  Vex.Inherit(FretHandFinger, Modifier, {
    init: function(number) {
      var superclass = Vex.Flow.FretHandFinger.superclass;
      superclass.init.call(this);

      this.note = null;
      this.index = null;
      this.finger = number;
      this.width = 7;
      this.position = Modifier.Position.LEFT;  // Default position above stem or note head
      this.x_shift = 0;
      this.y_shift = 0;
      this.x_offset = 0;       // Horizontal offset from default
      this.y_offset = 0;       // Vertical offset from default
      this.font = {
        family: "sans-serif",
        size: 9,
        weight: "bold"
      };
    },

    getNote: function() { return this.note; },
    setNote: function(note) { this.note = note; return this; },
    getIndex: function() { return this.index; },
    setIndex: function(index) { this.index = index; return this; },
    getPosition: function() { return this.position; },
    setPosition: function(position) {
      if (position >= Modifier.Position.LEFT &&
          position <= Modifier.Position.BELOW)
        this.position = position;
      return this;
    },
    setFretHandFinger: function(number) { this.finger = number; return this; },
    setOffsetX: function(x) { this.x_offset = x; return this; },
    setOffsetY: function(y) { this.y_offset = y; return this; },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw string number without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw string number without a note and index.");

      var ctx = this.context;
      var start = this.note.getModifierStartXY(this.position, this.index);
      var dot_x = (start.x + this.x_shift + this.x_offset);
      var dot_y = start.y + this.y_shift + this.y_offset + 5;

      switch (this.position) {
        case Modifier.Position.ABOVE:
          dot_x -= 4;
          dot_y -= 12;
          break;
        case Modifier.Position.BELOW:
          dot_x -= 2;
          dot_y += 10;
          break;
        case Modifier.Position.LEFT:
          dot_x -= this.width;
          break;
        case Modifier.Position.RIGHT:
          dot_x += 1;
          break;
      }

      ctx.save();
      ctx.setFont(this.font.family, this.font.size, this.font.weight);
      ctx.fillText("" + this.finger, dot_x, dot_y);

      ctx.restore();
    }
  });

  return FretHandFinger;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// Author: Larry Kuhns
//
// ## Description
//
// This file implements the `StringNumber` class which renders string
// number annotations beside notes.

Vex.Flow.StringNumber = (function() {
  function StringNumber(number) {
    if (arguments.length > 0) this.init(number);
  }
  StringNumber.CATEGORY = "stringnumber";

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods
  // Arrange string numbers inside a `ModifierContext`
  StringNumber.format = function(nums, state) {
    var left_shift = state.left_shift;
    var right_shift = state.right_shift;
    var num_spacing = 1;

    if (!nums || nums.length === 0) return this;

    var nums_list = [];
    var prev_note = null;
    var shift_left = 0;
    var shift_right = 0;

    var i, num, note, pos, props_tmp;
    for (i = 0; i < nums.length; ++i) {
      num = nums[i];
      note = num.getNote();

      for (i = 0; i < nums.length; ++i) {
        num = nums[i];
        note = num.getNote();
        pos = num.getPosition();
        var props = note.getKeyProps()[num.getIndex()];

        if (note != prev_note) {
          for (var n = 0; n < note.keys.length; ++n) {
            props_tmp = note.getKeyProps()[n];
            if (left_shift === 0)
              shift_left = (props_tmp.displaced ? note.getExtraLeftPx() : shift_left);
            if (right_shift === 0)
              shift_right = (props_tmp.displaced ? note.getExtraRightPx() : shift_right);
          }
          prev_note = note;
        }

        nums_list.push({ line: props.line, pos: pos, shiftL: shift_left, shiftR: shift_right, note: note, num: num });
      }
    }

    // Sort string numbers by line number.
    nums_list.sort(function(a, b) { return (b.line - a.line); });

    var num_shiftL = 0;
    var num_shiftR = 0;
    var x_widthL = 0;
    var x_widthR = 0;
    var last_line = null;
    var last_note = null;
    for (i = 0; i < nums_list.length; ++i) {
      var num_shift = 0;
      note = nums_list[i].note;
      pos = nums_list[i].pos;
      num = nums_list[i].num;
      var line = nums_list[i].line;
      var shiftL = nums_list[i].shiftL;
      var shiftR = nums_list[i].shiftR;

      // Reset the position of the string number every line.
      if (line != last_line || note != last_note) {
        num_shiftL = left_shift + shiftL;
        num_shiftR = right_shift + shiftR;
      }

      var num_width = num.getWidth() + num_spacing;
      if (pos == Vex.Flow.Modifier.Position.LEFT) {
        num.setXShift(left_shift);
        num_shift = shift_left + num_width; // spacing
        x_widthL = (num_shift > x_widthL) ? num_shift : x_widthL;
      } else if (pos == Vex.Flow.Modifier.Position.RIGHT) {
        num.setXShift(num_shiftR);
        num_shift += num_width; // spacing
        x_widthR = (num_shift > x_widthR) ? num_shift : x_widthR;
      }
      last_line = line;
      last_note = note;
    }

    state.left_shift += x_widthL;
    state.right_shift += x_widthR;
    return true;
  };

  // ## Prototype Methods
  Vex.Inherit(StringNumber, Modifier, {
    init: function(number) {
      StringNumber.superclass.init.call(this);

      this.note = null;
      this.last_note = null;
      this.index = null;
      this.string_number = number;
      this.setWidth(20);                                 // ???
      this.position = Modifier.Position.ABOVE;  // Default position above stem or note head
      this.x_shift = 0;
      this.y_shift = 0;
      this.x_offset = 0;                               // Horizontal offset from default
      this.y_offset = 0;                               // Vertical offset from default
      this.dashed = true;                              // true - draw dashed extension  false - no extension
      this.leg = Vex.Flow.Renderer.LineEndType.NONE;   // draw upward/downward leg at the of extension line
      this.radius = 8;
      this.font = {
        family: "sans-serif",
        size: 10,
        weight: "bold"
      };
    },

    getNote: function() { return this.note; },
    setNote: function(note) { this.note = note; return this; },
    getIndex: function() { return this.index; },
    setIndex: function(index) { this.index = index; return this; },

    setLineEndType: function(leg) {
      if (leg >= Vex.Flow.Renderer.LineEndType.NONE &&
          leg <= Vex.Flow.Renderer.LineEndType.DOWN)
        this.leg = leg;
      return this;
    },

    getPosition: function() { return this.position; },
    setPosition: function(position) {
      if (position >= Modifier.Position.LEFT &&
          position <= Modifier.Position.BELOW)
        this.position = position;
      return this;
    },

    setStringNumber: function(number) { this.string_number = number; return this; },
    setOffsetX: function(x) { this.x_offset = x; return this; },
    setOffsetY: function(y) { this.y_offset = y; return this; },
    setLastNote: function(note) { this.last_note = note; return this; },
    setDashed: function(dashed) { this.dashed = dashed; return this; },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw string number without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw string number without a note and index.");

      var ctx = this.context;
      var line_space = this.note.stave.options.spacing_between_lines_px;

      var start = this.note.getModifierStartXY(this.position, this.index);
      var dot_x = (start.x + this.x_shift + this.x_offset);
      var dot_y = start.y + this.y_shift + this.y_offset;

      switch (this.position) {
        case Modifier.Position.ABOVE:
        case Modifier.Position.BELOW:
          var stem_ext = this.note.getStemExtents();
          var top = stem_ext.topY;
          var bottom = stem_ext.baseY + 2;

          if (this.note.stem_direction == Vex.Flow.StaveNote.STEM_DOWN) {
            top = stem_ext.baseY;
            bottom = stem_ext.topY - 2;
          }

          if (this.position == Modifier.Position.ABOVE) {
            dot_y = this.note.hasStem() ? top - (line_space * 1.75)
                                        : start.y - (line_space * 1.75);
        } else {
            dot_y = this.note.hasStem() ? bottom + (line_space * 1.5)
                                        : start.y + (line_space * 1.75);
          }

          dot_y += this.y_shift + this.y_offset;

          break;
        case Modifier.Position.LEFT:
          dot_x -= (this.radius / 2) + 5;
          break;
        case Modifier.Position.RIGHT:
          dot_x += (this.radius / 2) + 6;
          break;
      }

      ctx.save();
      ctx.beginPath();
      ctx.arc(dot_x, dot_y, this.radius, 0, Math.PI * 2, false);
      ctx.lineWidth = 1.5;
      ctx.stroke();
      ctx.setFont(this.font.family, this.font.size, this.font.weight);
      var x = dot_x - ctx.measureText(this.string_number).width / 2;
      ctx.fillText("" + this.string_number, x, dot_y + 4.5);

      if (this.last_note != null) {
        var end = this.last_note.getStemX() - this.note.getX() + 5;
        ctx.strokeStyle="#000000";
        ctx.lineCap = "round";
        ctx.lineWidth = 0.6;
        if (this.dashed)
          Vex.Flow.Renderer.drawDashedLine(ctx, dot_x + 10, dot_y, dot_x + end, dot_y, [3,3]);
        else
          Vex.Flow.Renderer.drawDashedLine(ctx, dot_x + 10, dot_y, dot_x + end, dot_y, [3,0]);

        var len, pattern;
        switch (this.leg) {
          case Vex.Flow.Renderer.LineEndType.UP:
            len = -10;
            pattern = this.dashed ? [3,3] : [3,0];
            Vex.Flow.Renderer.drawDashedLine(ctx, dot_x + end, dot_y, dot_x + end, dot_y + len, pattern);
            break;
          case Vex.Flow.Renderer.LineEndType.DOWN:
            len = 10;
            pattern = this.dashed ? [3,3] : [3,0];
            Vex.Flow.Renderer.drawDashedLine(ctx, dot_x + end, dot_y, dot_x + end, dot_y + len, pattern);
            break;
        }
      }

      ctx.restore();
    }
  });

  return StringNumber;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// Author: Larry Kuhns
//
// ## Description
//
// This file implements the `Stroke` class which renders chord strokes
// that can be arpeggiated, brushed, rasquedo, etc.

Vex.Flow.Stroke = (function() {
  function Stroke(type, options) {
    if (arguments.length > 0) this.init(type, options);
  }
  Stroke.CATEGORY = "strokes";

  Stroke.Type = {
    BRUSH_DOWN: 1,
    BRUSH_UP: 2,
    ROLL_DOWN: 3,        // Arpegiated chord
    ROLL_UP: 4,          // Arpegiated chord
    RASQUEDO_DOWN: 5,
    RASQUEDO_UP: 6
  };

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods

  // Arrange strokes inside `ModifierContext`
  Stroke.format = function(strokes, state) {
    var left_shift = state.left_shift;
    var stroke_spacing = 0;

    if (!strokes || strokes.length === 0) return this;

    var str_list = [];
    var i, str, shift;
    for (i = 0; i < strokes.length; ++i) {
      str = strokes[i];
      var note = str.getNote();
      var props;
      if (note instanceof Vex.Flow.StaveNote) {
        props = note.getKeyProps()[str.getIndex()];
        shift = (props.displaced ? note.getExtraLeftPx() : 0);
        str_list.push({ line: props.line, shift: shift, str: str });
      } else {
        props = note.getPositions()[str.getIndex()];
        str_list.push({ line: props.str, shift: 0, str: str });
      }
    }

    var str_shift = left_shift;
    var x_shift = 0;

    // There can only be one stroke .. if more than one, they overlay each other
    for (i = 0; i < str_list.length; ++i) {
      str = str_list[i].str;
      shift = str_list[i].shift;

      str.setXShift(str_shift + shift);
      x_shift = Math.max(str.getWidth() + stroke_spacing, x_shift);
    }

    state.left_shift += x_shift;
    return true;
  };

  // ## Prototype Methods
  Vex.Inherit(Stroke, Modifier, {
    init: function(type, options) {
      Stroke.superclass.init.call(this);

      this.note = null;
      this.options = Vex.Merge({}, options);

      // multi voice - span stroke across all voices if true
      this.all_voices = 'all_voices' in this.options ?
        this.options.all_voices : true;

      // multi voice - end note of stroke, set in draw()
      this.note_end = null;
      this.index = null;
      this.type = type;
      this.position = Modifier.Position.LEFT;

      this.render_options = {
        font_scale: 38,
        stroke_px: 3,
        stroke_spacing: 10
      };

      this.font = {
       family: "serif",
       size: 10,
       weight: "bold italic"
     };

      this.setXShift(0);
      this.setWidth(10);
    },

    getPosition: function() { return this.position; },
    addEndNote: function(note) { this.note_end = note; return this; },

    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw stroke without a context.");
      if (!(this.note && (this.index != null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw stroke without a note and index.");
      var start = this.note.getModifierStartXY(this.position, this.index);
      var ys = this.note.getYs();
      var topY = start.y;
      var botY = start.y;
      var x = start.x - 5;
      var line_space = this.note.stave.options.spacing_between_lines_px;

      var notes = this.getModifierContext().getModifiers(this.note.getCategory());
      var i;
      for (i = 0; i < notes.length; i++) {
        ys = notes[i].getYs();
        for (var n = 0; n < ys.length; n++) {
          if (this.note == notes[i] || this.all_voices) {
            topY = Vex.Min(topY, ys[n]);
            botY = Vex.Max(botY, ys[n]);
          }
        }
      }

      var arrow, arrow_shift_x, arrow_y, text_shift_x, text_y;
      switch (this.type) {
        case Stroke.Type.BRUSH_DOWN:
          arrow = "vc3";
          arrow_shift_x = -3;
          arrow_y = topY - (line_space / 2) + 10;
          botY += (line_space / 2);
          break;
        case Stroke.Type.BRUSH_UP:
          arrow = "v11";
          arrow_shift_x = 0.5;
          arrow_y = botY + (line_space / 2);
          topY -= (line_space / 2);
          break;
        case Stroke.Type.ROLL_DOWN:
        case Stroke.Type.RASQUEDO_DOWN:
          arrow = "vc3";
          arrow_shift_x = -3;
          text_shift_x = this.x_shift + arrow_shift_x - 2;
          if (this.note instanceof Vex.Flow.StaveNote) {
            topY += 1.5 * line_space;
            if ((botY - topY) % 2 !== 0) {
              botY += 0.5 * line_space;
            } else {
              botY += line_space;
            }
            arrow_y = topY - line_space;
            text_y = botY + line_space + 2;
          } else {
            topY += 1.5 * line_space;
            botY += line_space;
            arrow_y = topY - 0.75 * line_space;
            text_y = botY + 0.25 * line_space;
          }
          break;
        case Stroke.Type.ROLL_UP:
        case Stroke.Type.RASQUEDO_UP:
          arrow = "v52";
          arrow_shift_x = -4;
          text_shift_x = this.x_shift + arrow_shift_x - 1;
          if (this.note instanceof Vex.Flow.StaveNote) {
            arrow_y = line_space / 2;
            topY += 0.5 * line_space;
            if ((botY - topY) % 2 === 0) {
              botY += line_space / 2;
            }
            arrow_y = botY + 0.5 * line_space;
            text_y = topY - 1.25 * line_space;
          } else {
            topY += 0.25 * line_space;
            botY += 0.5 * line_space;
            arrow_y = botY + 0.25 * line_space;
            text_y = topY - line_space;
          }
          break;
      }

      // Draw the stroke
      if (this.type == Stroke.Type.BRUSH_DOWN ||
          this.type == Stroke.Type.BRUSH_UP) {
        this.context.fillRect(x + this.x_shift, topY, 1, botY - topY);
      } else {
        if (this.note instanceof Vex.Flow.StaveNote) {
          for (i = topY; i <= botY; i += line_space) {
            Vex.Flow.renderGlyph(this.context, x + this.x_shift - 4,
                                 i,
                                 this.render_options.font_scale, "va3");
          }
        } else {
          for (i = topY; i <= botY; i+= 10) {
            Vex.Flow.renderGlyph(this.context, x + this.x_shift - 4,
                                 i,
                                 this.render_options.font_scale, "va3");
          }
          if (this.type == Vex.Flow.Stroke.Type.RASQUEDO_DOWN)
            text_y = i + 0.25 * line_space;
        }
      }

      // Draw the arrow head
      Vex.Flow.renderGlyph(this.context, x + this.x_shift + arrow_shift_x, arrow_y,
                           this.render_options.font_scale, arrow);

      // Draw the rasquedo "R"
      if (this.type == Stroke.Type.RASQUEDO_DOWN ||
          this.type == Stroke.Type.RASQUEDO_UP) {
        this.context.save();
        this.context.setFont(this.font.family, this.font.size, this.font.weight);
        this.context.fillText("R", x + text_shift_x, text_y);
        this.context.restore();
      }
    }
  });

  return Stroke;
}());
// VexFlow - Music Engraving for HTML5
// Copyright Mohit Muthanna 2010
//
// This class implements curves (for slurs)

Vex.Flow.Curve = (function() {
  // from: Start note
  // to: End note
  // options:
  //    cps: List of control points
  //    x_shift: pixels to shift
  //    y_shift: pixels to shift
  function Curve(from, to, options) {
    if (arguments.length > 0) this.init(from, to, options);
  }

  Curve.Position = {
    NEAR_HEAD: 1,
    NEAR_TOP: 2
  };

  Curve.DEBUG = true;

  Curve.prototype = {
    init: function(from, to, options) {
      this.render_options = {
        spacing: 2,
        thickness: 2,
        x_shift: 0,
        y_shift: 10,
        position: Curve.Position.NEAR_HEAD,
        invert: false,
        cps: [{x: 0, y: 10}, {x: 0, y: 10}]
      };

      Vex.Merge(this.render_options, options);
      this.setNotes(from, to);
    },

    setContext: function(context) { this.context = context; return this; },
    setNotes: function(from, to) {
      if (!from && !to)
        throw new Vex.RuntimeError("BadArguments",
            "Curve needs to have either first_note or last_note set.");

      this.from = from;
      this.to = to;
      return this;
    },

    /**
     * @return {boolean} Returns true if this is a partial bar.
     */
    isPartial: function() {
      return (!this.from || !this.to);
    },

    renderCurve: function(params) {
      var ctx = this.context;
      var cps = this.render_options.cps;

      var x_shift = this.render_options.x_shift;
      var y_shift = this.render_options.y_shift * params.direction;

      var first_x = params.first_x + x_shift;
      var first_y = params.first_y + y_shift;
      var last_x = params.last_x - x_shift;
      var last_y = params.last_y + y_shift;
      var thickness = this.render_options.thickness;

      var cp_spacing = (last_x - first_x) / (cps.length + 2);

      ctx.beginPath();
      ctx.moveTo(first_x, first_y);
      ctx.bezierCurveTo(first_x + cp_spacing + cps[0].x,
                        first_y + (cps[0].y * params.direction),
                        last_x - cp_spacing + cps[1].x,
                        last_y + (cps[1].y * params.direction),
                        last_x, last_y);
      ctx.bezierCurveTo(last_x - cp_spacing + cps[1].x,
                        last_y + ((cps[1].y + thickness) * params.direction),
                        first_x + cp_spacing + cps[0].x,
                        first_y + ((cps[0].y + thickness) * params.direction),
                        first_x, first_y);
      ctx.stroke();
      ctx.closePath();
      ctx.fill();
    },

    draw: function() {
      if (!this.context)
        throw new Vex.RERR("NoContext", "No context to render tie.");
      var first_note = this.from;
      var last_note = this.to;
      var first_x, last_x, first_y, last_y, stem_direction;

      var metric = "baseY";
      var end_metric = "baseY";
      var position = this.render_options.position;
      var position_end = this.render_options.position_end;

      if (position === Curve.Position.NEAR_TOP) {
        metric = "topY";
        end_metric = "topY";
      }

      if (position_end == Curve.Position.NEAR_HEAD) {
        end_metric = "baseY";
      } else if (position_end == Curve.Position.NEAR_TOP) {
        end_metric = "topY";
      }

      if (first_note) {
        first_x = first_note.getTieRightX();
        stem_direction = first_note.getStemDirection();
        first_y = first_note.getStemExtents()[metric];
      } else {
        first_x = last_note.getStave().getTieStartX();
        first_y = last_note.getStemExtents()[metric];
      }

      if (last_note) {
        last_x = last_note.getTieLeftX();
        stem_direction = last_note.getStemDirection();
        last_y = last_note.getStemExtents()[end_metric];
      } else {
        last_x = first_note.getStave().getTieEndX();
        last_y = first_note.getStemExtents()[end_metric];
      }

      this.renderCurve({
        first_x: first_x,
        last_x: last_x,
        first_y: first_y,
        last_y: last_y,
        direction: stem_direction *
          (this.render_options.invert === true ? -1 : 1)
      });
      return true;
    }
  };

  return Curve;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements `StaveLine` which are simply lines that connect
// two notes. This object is highly configurable, see the `render_options`.
// A simple line is often used for notating glissando articulations, but you
// can format a `StaveLine` with arrows or colors for more pedagogical
// purposes, such as diagrams.
Vex.Flow.StaveLine = (function() {
  function StaveLine(notes) {
    if (arguments.length > 0) this.init(notes);
  }

  // Text Positioning
  StaveLine.TextVerticalPosition = {
    TOP: 1,
    BOTTOM: 2
  };

  StaveLine.TextJustification = {
    LEFT: 1,
    CENTER: 2,
    RIGHT: 3
  };

  // ## Prototype Methods
  StaveLine.prototype = {
    // Initialize the StaveLine with the given `notes`.
    //
    // `notes` is a struct that has:
    //
    //  ```
    //  {
    //    first_note: Note,
    //    last_note: Note,
    //    first_indices: [n1, n2, n3],
    //    last_indices: [n1, n2, n3]
    //  }
    //  ```
    init: function(notes) {
      this.notes = notes;
      this.context = null;

      this.text = "";

      this.font = {
        family: "Arial",
        size: 10,
        weight: ""
      };

      this.render_options = {
        // Space to add to the left or the right
        padding_left: 4,
        padding_right: 3,

        // The width of the line in pixels
        line_width: 1,
        // An array of line/space lengths. Unsupported with Raphael (SVG)
        line_dash: null,
        // Can draw rounded line end, instead of a square. Unsupported with Raphael (SVG)
        rounded_end: true,
        // The color of the line and arrowheads
        color: null,

        // Flags to draw arrows on each end of the line
        draw_start_arrow: false,
        draw_end_arrow: false,

        // The length of the arrowhead sides
        arrowhead_length: 10,
        // The angle of the arrowhead
        arrowhead_angle: Math.PI / 8,

        // The position of the text
        text_position_vertical: StaveLine.TextVerticalPosition.TOP,
        text_justification: StaveLine.TextJustification.CENTER
      };

      this.setNotes(notes);
    },

    // Set the rendering context
    setContext: function(context) { this.context = context; return this; },
    // Set the font for the `StaveLine` text
    setFont: function(font) { this.font = font; return this; },
    // The the annotation for the `StaveLine`
    setText: function(text) { this.text = text; return this; },

    // Set the notes for the `StaveLine`
    setNotes: function(notes) {
      if (!notes.first_note && !notes.last_note)
        throw new Vex.RuntimeError("BadArguments",
            "Notes needs to have either first_note or last_note set.");

      if (!notes.first_indices) notes.first_indices = [0];
      if (!notes.last_indices) notes.last_indices = [0];

      if (notes.first_indices.length != notes.last_indices.length)
        throw new Vex.RuntimeError("BadArguments", "Connected notes must have similar" +
          " index sizes");

      // Success. Lets grab 'em notes.
      this.first_note = notes.first_note;
      this.first_indices = notes.first_indices;
      this.last_note = notes.last_note;
      this.last_indices = notes.last_indices;
      return this;
    },

    // Apply the style of the `StaveLine` to the context
    applyLineStyle: function() {
      if (!this.context) {
        throw new Vex.RERR("NoContext","No context to apply the styling to");
      }

      var render_options = this.render_options;
      var ctx = this.context;

      if (render_options.line_dash) {
        ctx.setLineDash(render_options.line_dash);
      }

      if (render_options.line_width) {
        ctx.setLineWidth(render_options.line_width);
      }

      if (render_options.rounded_end) {
        ctx.setLineCap("round");
      } else {
        ctx.setLineCap("square");
      }
    },

    // Apply the text styling to the context
    applyFontStyle: function() {
      if (!this.context) {
        throw new Vex.RERR("NoContext","No context to apply the styling to");
      }

      var ctx = this.context;

      if (this.font) {
        ctx.setFont(this.font.family, this.font.size, this.font.weight);
      }

      if (this.render_options.color) {
        ctx.setStrokeStyle(this.render_options.color);
        ctx.setFillStyle(this.render_options.color);
      }
    },

    // Renders the `StaveLine` on the context
    draw: function() {
      if (!this.context) {
        throw new Vex.RERR("NoContext", "No context to render StaveLine.");
      }

      var ctx = this.context;
      var first_note = this.first_note;
      var last_note = this.last_note;
      var render_options = this.render_options;

      ctx.save();
      this.applyLineStyle();

      // Cycle through each set of indices and draw lines
      var start_position;
      var end_position;
      this.first_indices.forEach(function(first_index, i) {
        var last_index = this.last_indices[i];

        // Get initial coordinates for the start/end of the line
        start_position = first_note.getModifierStartXY(2, first_index);
        end_position = last_note.getModifierStartXY(1, last_index);
        var upwards_slope = start_position.y > end_position.y;

        // Adjust `x` coordinates for modifiers
        start_position.x += first_note.getMetrics().modRightPx +
                            render_options.padding_left;
        end_position.x -= last_note.getMetrics().modLeftPx +
                          render_options.padding_right;


        // Adjust first `x` coordinates for displacements
        var notehead_width = first_note.getGlyph().head_width;
        var first_displaced = first_note.getKeyProps()[first_index].displaced;
        if (first_displaced && first_note.getStemDirection() === 1) {
          start_position.x += notehead_width + render_options.padding_left;
        }

        // Adjust last `x` coordinates for displacements
        var last_displaced = last_note.getKeyProps()[last_index].displaced;
        if (last_displaced && last_note.getStemDirection() === -1) {
          end_position.x -= notehead_width + render_options.padding_right;
        }

        // Adjust y position better if it's not coming from the center of the note
        start_position.y += upwards_slope ? -3 : 1;
        end_position.y += upwards_slope ? 2 : 0;

        drawArrowLine(ctx, start_position, end_position, this.render_options);

      }, this);

      ctx.restore();

      // Determine the x coordinate where to start the text
      var text_width = ctx.measureText(this.text).width;
      var justification = render_options.text_justification;
      var x = 0;
      if (justification === StaveLine.TextJustification.LEFT) {
        x = start_position.x;
      } else if (justification === StaveLine.TextJustification.CENTER) {
        var delta_x = (end_position.x - start_position.x);
        var center_x = (delta_x / 2 ) + start_position.x;
        x = center_x - (text_width / 2);
      } else if (justification === StaveLine.TextJustification.RIGHT) {
        x = end_position.x  -  text_width;
      }

      // Determine the y value to start the text
      var y;
      var vertical_position = render_options.text_position_vertical;
      if (vertical_position === StaveLine.TextVerticalPosition.TOP) {
        y = first_note.getStave().getYForTopText();
      } else if (vertical_position === StaveLine.TextVerticalPosition.BOTTOM) {
        y = first_note.getStave().getYForBottomText();
      }

      // Draw the text
      ctx.save();
      this.applyFontStyle();
      ctx.fillText(this.text, x, y);
      ctx.restore();

      return this;
    }
  };

  // ## Private Helpers
  // 
  // Attribution: Arrow rendering implementations based off of
  // Patrick Horgan's article, "Drawing lines and arcs with 
  // arrow heads on  HTML5 Canvas"
  // 
  // Draw an arrow head that connects between 3 coordinates
  function drawArrowHead(ctx, x0, y0, x1, y1, x2, y2) {
    // all cases do this.
    ctx.beginPath();
    ctx.moveTo(x0,y0);
    ctx.lineTo(x1,y1);
    ctx.lineTo(x2,y2);
    ctx.lineTo(x0, y0);
    ctx.closePath();

    ctx.fill();
  }

  // Helper function to draw a line with arrow heads
  function drawArrowLine(ctx, point1, point2, config) {
    var both_arrows = config.draw_start_arrow && config.draw_end_arrow;

    var x1 = point1.x;
    var y1 = point1.y;
    var x2 = point2.x;
    var y2 = point2.y;

    // For ends with arrow we actually want to stop before we get to the arrow
    // so that wide lines won't put a flat end on the arrow.
    var distance = Math.sqrt((x2-x1)*(x2-x1)+(y2-y1)*(y2-y1));
    var ratio = (distance - config.arrowhead_length/3) / distance;
    var end_x, end_y, start_x, start_y;
    if (config.draw_end_arrow || both_arrows) {
      end_x = Math.round(x1 + (x2 - x1) * ratio);
      end_y = Math.round(y1 + (y2 - y1) * ratio);
    } else {
      end_x = x2;
      end_y = y2;
    }

    if (config.draw_start_arrow || both_arrows) {
      start_x = x1 + (x2 - x1) * (1 - ratio);
      start_y = y1 + (y2 - y1) * (1 - ratio);
    } else {
      start_x = x1;
      start_y = y1;
    }

    if (config.color) {
      ctx.setStrokeStyle(config.color);
      ctx.setFillStyle(config.color);
    }

    // Draw the shaft of the arrow
    ctx.beginPath();
    ctx.moveTo(start_x, start_y);
    ctx.lineTo(end_x,end_y);
    ctx.stroke();
    ctx.closePath();

    // calculate the angle of the line
    var line_angle = Math.atan2(y2 - y1, x2 - x1);
    // h is the line length of a side of the arrow head
    var h = Math.abs(config.arrowhead_length / Math.cos(config.arrowhead_angle));

    var angle1, angle2;
    var top_x, top_y;
    var bottom_x, bottom_y;

    if (config.draw_end_arrow || both_arrows) {
      angle1 = line_angle + Math.PI + config.arrowhead_angle;
      top_x = x2 + Math.cos(angle1) * h;
      top_y = y2 + Math.sin(angle1) * h;

      angle2 = line_angle + Math.PI - config.arrowhead_angle;
      bottom_x = x2 + Math.cos(angle2) * h;
      bottom_y = y2 + Math.sin(angle2) * h;

      drawArrowHead(ctx, top_x, top_y, x2, y2, bottom_x, bottom_y);
    }

    if (config.draw_start_arrow || both_arrows) {
      angle1 = line_angle + config.arrowhead_angle;
      top_x = x1 + Math.cos(angle1) * h;
      top_y = y1 + Math.sin(angle1) * h;

      angle2 = line_angle - config.arrowhead_angle;
      bottom_x = x1 + Math.cos(angle2) * h;
      bottom_y = y1 + Math.sin(angle2) * h;

      drawArrowHead(ctx, top_x, top_y, x1, y1, bottom_x, bottom_y);
    }
  }

  return StaveLine;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements the `Crescendo` object which draws crescendos and
// decrescendo dynamics markings. A `Crescendo` is initialized with a
// duration and formatted as part of a `Voice` like any other `Note`
// type in VexFlow. This object would most likely be formatted in a Voice
// with `TextNotes` - which are used to represent other dynamics markings.
Vex.Flow.Crescendo = (function() {
  function Crescendo(note_struct) {
    if (arguments.length > 0) this.init(note_struct);
  }

  // To enable logging for this class. Set `Vex.Flow.Crescendo.DEBUG` to `true`.
  function L() { if (Crescendo.DEBUG) Vex.L("Vex.Flow.Crescendo", arguments); }

  // Private helper to draw the hairpin
  function renderHairpin(ctx, params) {
    var begin_x = params.begin_x;
    var end_x = params.end_x;
    var y = params.y;
    var half_height =  params.height / 2;

    ctx.beginPath();

    if (params.reverse) {
        ctx.moveTo(begin_x, y - half_height);
        ctx.lineTo(end_x,  y);
        ctx.lineTo(begin_x, y + half_height);
    } else {
        ctx.moveTo(end_x,  y - half_height);
        ctx.lineTo(begin_x, y);
        ctx.lineTo(end_x,  y + half_height);
    }

    ctx.stroke();
    ctx.closePath();
  }

  // ## Prototype Methods
  Vex.Inherit(Crescendo, Vex.Flow.Note, {
    // Initialize the crescendo's properties
    init: function(note_struct) {
      Crescendo.superclass.init.call(this, note_struct);

      // Whether the object is a decrescendo
      this.decrescendo = false;

      // The staff line to be placed on
      this.line = note_struct.line || 0;

      // The height at the open end of the cresc/decresc
      this.height = 15;

      Vex.Merge(this.render_options, {
        // Extensions to the length of the crescendo on either side
        extend_left: 0,
        extend_right: 0,
        // Vertical shift
        y_shift: 0
      });
    },

    // Set the line to center the element on
    setLine: function(line) { this.line = line; return this; },

    // Set the full height at the open end
    setHeight: function(height) { this.height = height; return this; },

    // Set whether the sign should be a descresendo by passing a bool
    // to `decresc`
    setDecrescendo: function(decresc) {
      this.decrescendo = decresc;
      return this;
    },

    // Preformat the note
    preFormat: function() { this.preFormatted = true; return this; },

    // Render the Crescendo object onto the canvas
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw Hairpin without a context.");

      var tick_context = this.getTickContext();
      var next_context = Vex.Flow.TickContext.getNextContext(tick_context);

      var begin_x = this.getAbsoluteX();
      var end_x;
      if (next_context) {
        end_x = next_context.getX();
      } else {
        end_x = this.stave.x + this.stave.width;
      }

      var y = this.stave.getYForLine(this.line + (-3)) + 1;

      L("Drawing ",  this.decrescendo ? "decrescendo " : "crescendo ",
        this.height, "x", begin_x - end_x);

      renderHairpin(this.context, {
        begin_x: begin_x - this.render_options.extend_left,
        end_x: end_x + this.render_options.extend_right,
        y: y + this.render_options.y_shift,
        height: this.height,
        reverse: this.decrescendo
      });
    }
  });

  return Crescendo;
})();
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// Author: Cyril Silverman
//
// ## Description
//
// This file implements ornaments as modifiers that can be
// attached to notes. The complete list of ornaments is available in
// `tables.js` under `Vex.Flow.ornamentCodes`.
//
// See `tests/ornament_tests.js` for usage examples.

Vex.Flow.Ornament = (function() {
  function Ornament(type) {
    if (arguments.length > 0) this.init(type);
  }
  Ornament.CATEGORY = "ornaments";

  // Accidental position modifications for each glyph
  var acc_mods = {
    "n": {
      shift_x: 1,
      shift_y_upper:0,
      shift_y_lower:0,
      height: 17
    },
    "#": {
      shift_x: 0,
      shift_y_upper: -2,
      shift_y_lower: -2,
      height: 20
    },
    "b": {
      shift_x: 1,
      shift_y_upper: 0,
      shift_y_lower: 3,
      height: 18
    },
    "##": {
      shift_x: 0,
      shift_y_upper: 0,
      shift_y_lower: 0,
      height: 12,
    },
    "bb": {
      shift_x: 0,
      shift_y_upper: 0,
      shift_y_lower: 4,
      height: 17
    },
    "db": {
      shift_x: -3,
      shift_y_upper: 0,
      shift_y_lower: 4,
      height: 17
    },
    "bbs": {
      shift_x: 0,
      shift_y_upper: 0,
      shift_y_lower: 4,
      height: 17
    },
    "d": {
      shift_x: 0,
      shift_y_upper: 0,
      shift_y_lower: 0,
      height: 17
    },
    "++": {
      shift_x: -2,
      shift_y_upper: -6,
      shift_y_lower: -3,
      height: 22
    },
    "+": {
      shift_x: 1,
      shift_y_upper: -4,
      shift_y_lower: -2,
      height: 20
    }
  };

  // To enable logging for this class. Set `Vex.Flow.Ornament.DEBUG` to `true`.
  function L() { if (Ornament.DEBUG) Vex.L("Vex.Flow.Ornament", arguments); }

  var Modifier = Vex.Flow.Modifier;

  // ## Static Methods
  // Arrange ornaments inside `ModifierContext`
  Ornament.format = function(ornaments, state) {
   if (!ornaments || ornaments.length === 0) return false;

    var width = 0;
    for (var i = 0; i < ornaments.length; ++i) {
      var ornament = ornaments[i];
      var increment = 1;
      width = Math.max(ornament.getWidth(), width);

      var type = Vex.Flow.ornamentCodes(ornament.type);

      if (!type.between_lines) increment += 1.5;

      if (ornament.getPosition() === Modifier.Position.ABOVE) {
        ornament.setTextLine(state.top_text_line);
        state.top_text_line += increment;
      } else {
        ornament.setTextLine(state.text_line);
        state.text_line += increment;
      }
    }

    state.left_shift += width / 2;
    state.right_shift += width / 2;
    return true;
  };

  // ## Prototype Methods
  Vex.Inherit(Ornament, Modifier, {
    // Create a new ornament of type `type`, which is an entry in
    // `Vex.Flow.ornamentCodes` in `tables.js`.
    init: function(type) {
      Ornament.superclass.init.call(this);

      this.note = null;
      this.index = null;
      this.type = type;
      this.position = Modifier.Position.ABOVE;
      this.delayed = false;

      this.accidental_upper = "";
      this.accidental_lower = "";

      this.render_options = {
        font_scale: 38
      };

      this.ornament = Vex.Flow.ornamentCodes(this.type);
      if (!this.ornament) throw new Vex.RERR("ArgumentError",
         "Ornament not found: '" + this.type + "'");

      // Default width comes from ornament table.
      this.setWidth(this.ornament.width);
    },

    // Set whether the ornament is to be delayed
    setDelayed: function(delayed) { this.delayed = delayed; return this; },

    // Set the upper accidental for the ornament
    setUpperAccidental: function(acc) {
      this.accidental_upper = acc;
      return this;
    },

    // Set the lower accidental for the ornament
    setLowerAccidental: function(acc) {
      this.accidental_lower = acc;
      return this;
    },

    // Render ornament in position next to note.
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw Ornament without a context.");
      if (!(this.note && (this.index !== null))) throw new Vex.RERR("NoAttachedNote",
        "Can't draw Ornament without a note and index.");

      var ctx = this.context;
      var stem_direction = this.note.getStemDirection();
      var stave = this.note.getStave();

      // Get stem extents
      var stem_ext = this.note.getStem().getExtents();
      var top, bottom;
      if (stem_direction === Vex.Flow.StaveNote.STEM_DOWN) {
        top = stem_ext.baseY;
        bottom = stem_ext.topY;
      } else {
        top = stem_ext.topY;
        bottom = stem_ext.baseY;
      }

      // TabNotes don't have stems attached to them. Tab stems are rendered
      // outside the stave.
      var is_tabnote = this.note.getCategory() === 'tabnotes';
      if (is_tabnote) {
        if (this.note.hasStem()){
          if (stem_direction === Vex.Flow.StaveNote.STEM_UP) {
            bottom = stave.getYForBottomText(this.text_line - 2);
          } else if (stem_direction === Vex.Flow.StaveNote.STEM_DOWN ) {
            top = stave.getYForTopText(this.text_line - 1.5);
          }
        } else { // Without a stem
          top = stave.getYForTopText(this.text_line - 1);
          bottom = stave.getYForBottomText(this.text_line - 2);
        }
      }

      var is_on_head = stem_direction === Vex.Flow.StaveNote.STEM_DOWN;
      var spacing = stave.getSpacingBetweenLines();
      var line_spacing = 1;

      // Beamed stems are longer than quarter note stems, adjust accordingly
      if (!is_on_head && this.note.beam) {
        line_spacing += 0.5;
      }

      var total_spacing = spacing * (this.text_line + line_spacing);
      var glyph_y_between_lines = (top - 7) - total_spacing;

      // Get initial coordinates for the modifier position
      var start = this.note.getModifierStartXY(this.position, this.index);
      var glyph_x = start.x + this.ornament.shift_right;
      var glyph_y = Math.min(stave.getYForTopText(this.text_line) - 3, glyph_y_between_lines);
      glyph_y += this.ornament.shift_up + this.y_shift;

      // Ajdust x position if ornament is delayed
      if (this.delayed) {
        glyph_x += this.ornament.width;
        var next_context = Vex.Flow.TickContext.getNextContext(this.note.getTickContext());
        if (next_context) {
          glyph_x += (next_context.getX() - glyph_x) * 0.5;
        } else {
          glyph_x += (stave.x + stave.width - glyph_x) * 0.5;
        }
      }

      var ornament = this;
      function drawAccidental(ctx, code, upper) {
        var accidental = Vex.Flow.accidentalCodes(code);

        var acc_x = glyph_x - 3;
        var acc_y = glyph_y + 2;

        // Special adjustments for trill glyph
        if (upper) {
          acc_y -= mods ? mods.height : 18;
          acc_y +=  ornament.type === "tr" ? -8 : 0;
        } else {
          acc_y +=  ornament.type === "tr" ? -6 : 0;
        }

        // Fine tune position of accidental glyph
        var mods = acc_mods[code];
        if (mods) {
          acc_x += mods.shift_x;
          acc_y += upper ? mods.shift_y_upper : mods.shift_y_lower;
        }

        // Render the glyph
        var scale = ornament.render_options.font_scale/1.3;
        Vex.Flow.renderGlyph(ctx, acc_x, acc_y, scale, accidental.code);

        // If rendered a bottom accidental, increase the y value by the
        // accidental height so that the ornament's glyph is shifted up
        if (!upper) {
          glyph_y -= mods ? mods.height : 18;
        }
      }

      // Draw lower accidental for ornament
      if (this.accidental_lower) {
        drawAccidental(ctx, this.accidental_lower, false, glyph_x, glyph_y);
      }

      L("Rendering ornament: ", this.ornament, glyph_x, glyph_y);
      Vex.Flow.renderGlyph(ctx, glyph_x, glyph_y,
                           this.render_options.font_scale, this.ornament.code);

      // Draw upper accidental for ornament
      if (this.accidental_upper) {
        drawAccidental(ctx, this.accidental_upper, true, glyph_x, glyph_y);
      }

    }
  });

  return Ornament;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements different types of pedal markings. These notation
// elements indicate to the performer when to depress and release the a pedal.
//
// In order to create "Sostenuto", and "una corda" markings, you must set
// custom text for the release/depress pedal markings.
Vex.Flow.PedalMarking = (function() {
  function PedalMarking(type) {
    if (arguments.length > 0) this.init(type);
  }

  // To enable logging for this class. Set `Vex.Flow.PedalMarking.DEBUG` to `true`.
  function L() { if (PedalMarking.DEBUG) Vex.L("Vex.Flow.PedalMarking", arguments); }

  // Glyph data
  PedalMarking.GLYPHS = {
    "pedal_depress": {
      code: "v36",
      x_shift:-10,
      y_shift:0
    },
    "pedal_release": {
      code: "v5d",
      x_shift:-2,
      y_shift:3
    },
  };

  PedalMarking.Styles = {
    TEXT: 1,
    BRACKET: 2,
    MIXED: 3
  };


  // ## Public helpers
  //
  // Create a sustain pedal marking. Returns the defaults PedalMarking.
  // Which uses the traditional "Ped" and "*"" markings.
  PedalMarking.createSustain = function(notes) {
    var pedal = new PedalMarking(notes);
    return pedal;
  };

  // Create a sostenuto pedal marking
  PedalMarking.createSostenuto = function(notes) {
    var pedal = new PedalMarking(notes);
    pedal.setStyle(PedalMarking.Styles.MIXED);
    pedal.setCustomText("Sost. Ped.");
    return pedal;
  };

  // Create an una corda pedal marking
  PedalMarking.createUnaCorda = function(notes){
    var pedal = new PedalMarking(notes);
    pedal.setStyle(PedalMarking.Styles.TEXT);
    pedal.setCustomText("una corda", "tre corda");
    return pedal;
  };

  // ## Prototype Methods
  PedalMarking.prototype =  {
    init: function(notes) {
      this.notes = notes;
      this.style = Vex.Flow.PedalMarking.TEXT;
      this.line = 0;

      // Custom text for the release/depress markings
      this.custom_depress_text = "";
      this.custom_release_text = "";

      this.font = {
        family: "Times New Roman",
        size: 12,
        weight: "italic bold"
      };

      this.render_options = {
        bracket_height: 10,
        text_margin_right: 6,
        bracket_line_width: 1,
        glyph_point_size: 40,
        color: "black"
      };
    },

    // Set custom text for the `depress`/`release` pedal markings. No text is
    // set if the parameter is falsy.
    setCustomText: function(depress, release) {
      this.custom_depress_text = depress || "";
      this.custom_release_text = release || "";
      return this;
    },

    // Set the pedal marking style
    setStyle: function(style){
      if (style < 1 && style > 3)  {
        throw new Vex.RERR("InvalidParameter",
          "The style must be one found in PedalMarking.Styles");
      }

      this.style = style;
      return this;
    },

    // Set the staff line to render the markings on
    setLine: function(line) { this.line = line; return this; },

    // Set the rendering context
    setContext: function(context) { this.context = context; return this; },

    // Draw the bracket based pedal markings
    drawBracketed: function() {
      var ctx = this.context;
      var is_pedal_depressed = false;
      var prev_x;
      var prev_y;
      var pedal = this;

      // Iterate through each note
      this.notes.forEach(function(note, index, notes) {
        // Each note triggers the opposite pedal action
        is_pedal_depressed = !is_pedal_depressed;

        // Get the initial coordinates for the note
        var x = note.getAbsoluteX();
        var y = note.getStave().getYForBottomText(pedal.line + 3);

        // Throw if current note is positioned before the previous note
        if (x < prev_x) throw new Vex.RERR('InvalidConfiguration',
          'The notes provided must be in order of ascending x positions');

        // Determine if the previous or next note are the same
        // as the current note. We need to keep track of this for
        // when adjustments are made for the release+depress action
        var next_is_same = notes[index+1] === note;
        var prev_is_same = notes[index-1] === note;

        var x_shift = 0;
        if (is_pedal_depressed) {
          // Adjustment for release+depress
          x_shift =  prev_is_same ? 5 : 0;

          if (pedal.style === PedalMarking.Styles.MIXED && !prev_is_same) {
            // For MIXED style, start with text instead of bracket
            if (pedal.custom_depress_text) {
              // If we have custom text, use instead of the default "Ped" glyph
              var text_width = ctx.measureText(pedal.custom_depress_text).width;
              ctx.fillText(pedal.custom_depress_text, x - (text_width/2), y);
              x_shift = (text_width / 2) + pedal.render_options.text_margin_right;
            } else {
              // Render the Ped glyph in position
              drawPedalGlyph('pedal_depress', ctx, x, y, pedal.render_options.glyph_point_size);
              x_shift = 20 + pedal.render_options.text_margin_right;
            }
          } else {
            // Draw start bracket
            ctx.beginPath();
            ctx.moveTo(x, y - pedal.render_options.bracket_height);
            ctx.lineTo(x + x_shift, y);
            ctx.stroke();
            ctx.closePath();
          }
        } else {
          // Adjustment for release+depress
          x_shift = next_is_same ? -5 : 0;

          // Draw end bracket
          ctx.beginPath();
          ctx.moveTo(prev_x, prev_y);
          ctx.lineTo(x + x_shift, y);
          ctx.lineTo(x, y - pedal.render_options.bracket_height);
          ctx.stroke();
          ctx.closePath();
        }

        // Store previous coordinates
        prev_x = x + x_shift;
        prev_y = y;
      });
    },

    // Draw the text based pedal markings. This defaults to the traditional
    // "Ped" and "*"" symbols if no custom text has been provided.
    drawText: function() {
      var ctx = this.context;
      var is_pedal_depressed = false;
      var pedal = this;

      // The glyph point size
      var point = pedal.render_options.glyph_point_size;

      // Iterate through each note, placing glyphs or custom text accordingly
      this.notes.forEach(function(note) {
        is_pedal_depressed = !is_pedal_depressed;
        var stave = note.getStave();
        var x = note.getAbsoluteX();
        var y = stave.getYForBottomText(pedal.line + 3);

        var text_width = 0;
        if (is_pedal_depressed) {
          if (pedal.custom_depress_text) {
            text_width = ctx.measureText(pedal.custom_depress_text).width;
            ctx.fillText(pedal.custom_depress_text, x - (text_width/2), y);
          } else {
            drawPedalGlyph("pedal_depress", ctx, x, y, point);
          }
        } else {
          if (pedal.custom_release_text) {
            text_width = ctx.measureText(pedal.custom_release_text).width;
            ctx.fillText(pedal.custom_release_text, x - (text_width/2), y);
          } else {
            drawPedalGlyph("pedal_release", ctx, x, y, point);
          }
        }
      });
    },

    // Render the pedal marking in position on the rendering context 
    draw: function() {
      if (!this.context) throw new Vex.RERR("NoContext",
        "Can't draw PedalMarking without a context.");
      var ctx = this.context;

      ctx.save();
      ctx.setStrokeStyle(this.render_options.color);
      ctx.setFillStyle(this.render_options.color);
      ctx.setFont(this.font.family, this.font.size, this.font.weight);

      L("Rendering Pedal Marking");

      if (this.style === PedalMarking.Styles.BRACKET ||
          this.style === PedalMarking.Styles.MIXED) {
        ctx.setLineWidth(this.render_options.bracket_line_width);
        this.drawBracketed();
      } else if (this.style === Vex.Flow.PedalMarking.Styles.TEXT) {
        this.drawText();
      }

      ctx.restore();
    }
  };

  // ## Private Helper
  // 
  // Draws a pedal glyph with the provided `name` on a rendering `context` 
  // at the coordinates `x` and `y. Takes into account the glyph data
  // coordinate shifts.
  function drawPedalGlyph(name, context, x, y, point) {
    var glyph_data = PedalMarking.GLYPHS[name];
    var glyph = new Vex.Flow.Glyph(glyph_data.code, point);
    glyph.render(context, x + glyph_data.x_shift, y + glyph_data.y_shift);
  }

  return PedalMarking;
}());
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
// Author: Cyril Silverman
//
// ## Description
//
// This file implement `TextBrackets` which extend between two notes.
// The octave transposition markings (8va, 8vb, 15va, 15vb) can be created
// using this class.
//
Vex.Flow.TextBracket = (function() {
  function TextBracket(bracket_data) {
    if (arguments.length > 0) this.init(bracket_data);
  }

  // To enable logging for this class. Set `Vex.Flow.TextBracket.DEBUG` to `true`.
  function L() { if (TextBracket.DEBUG) Vex.L("Vex.Flow.TextBracket", arguments); }

  TextBracket.Positions = {
    TOP: 1,
    BOTTOM: -1
  };

  // ## Prototype Methods
  TextBracket.prototype =  {
    init: function(bracket_data) {
      this.start = bracket_data.start;
      this.stop = bracket_data.stop;

      this.text = bracket_data.text || "";
      this.superscript = bracket_data.superscript || "";

      this.position = bracket_data.position || TextBracket.Positions.TOP;
      this.line = 1;

      this.font = {
        family: "Serif",
        size: 15,
        weight: "italic"
      };

      this.render_options = {
        dashed: true,
        dash: [5],
        color: "black",
        line_width: 1,
        show_bracket: true,
        bracket_height: 8,

        // In the BOTTOM position, the bracket line can extend
        // under the superscript.
        underline_superscript: true
      };
    },

    // Apply the text backet styling to the provided `context`
    applyStyle: function(context) {
      // Apply style for the octave bracket
      context.setFont(this.font.family, this.font.size, this.font.weight);
      context.setStrokeStyle(this.render_options.color);
      context.setFillStyle(this.render_options.color);
      context.setLineWidth(this.render_options.line_width);

      return this;
    },

    // Set whether the bracket line should be `dashed`. You can also
    // optionally set the `dash` pattern by passing in an array of numbers
    setDashed: function(dashed, dash) {
      this.render_options.dashed = dashed;
      if (dash) this.render_options.dash = dash;
      return this;
    },

    // Set the font for the text
    setFont: function(font) { this.font = font; return this; },
    // Set the rendering `context` for the octave bracket
    setContext: function(context) { this.context = context; return this; },
    // Set the staff line to render the bracket on
    setLine: function(line) { this.line = line; return this; },

    // Draw the octave bracket on the rendering context
    draw: function() {
      var ctx = this.context;

      var y = 0;
      switch(this.position) {
        case TextBracket.Positions.TOP:
          y =  this.start.getStave().getYForTopText(this.line);
          break;
        case TextBracket.Positions.BOTTOM:
          y =  this.start.getStave().getYForBottomText(this.line);
          break;
      }

      // Get the preliminary start and stop coordintates for the bracket
      var start = { x: this.start.getAbsoluteX(), y: y};
      var stop = { x: this.stop.getAbsoluteX(), y: y };

      L("Rendering TextBracket: start:", start, "stop:", stop, "y:", y);

      var bracket_height = this.render_options.bracket_height * this.position;

      ctx.save();
      this.applyStyle(ctx);

      // Draw text
      ctx.fillText(this.text, start.x, start.y);

      // Get the width and height for the octave number
      var main_width = ctx.measureText(this.text).width;
      var main_height = ctx.measureText("M").width;

      // Calculate the y position for the super script
      var super_y = start.y - (main_height/2.5);

      // Draw the superscript
      ctx.setFont(this.font.family, this.font.size / 1.4, this.font.weight);
      ctx.fillText(this.superscript, start.x + main_width + 1, super_y);


      // Determine width and height of the superscript
      var superscript_width = ctx.measureText(this.superscript).width;
      var super_height = ctx.measureText("M").width;

      // Setup initial coordinates for the bracket line
      var start_x = start.x;
      var line_y = super_y;
      var end_x = stop.x + this.stop.getGlyph().head_width;

      // Adjust x and y coordinates based on position
      if (this.position === TextBracket.Positions.TOP) {
        start_x += main_width + superscript_width + 5;
        line_y -= super_height/2.7;
      } else if (this.position === TextBracket.Positions.BOTTOM) {
        line_y += super_height/2.7;
        start_x += main_width + 2;

        if (!this.render_options.underline_superscript) {
          start_x += superscript_width;
        }
      }

      if (this.render_options.dashed) {
        // Main line
        Vex.Flow.Renderer.drawDashedLine(ctx, start_x, line_y, end_x, line_y,
          this.render_options.dash);
        // Ending Bracket
        if (this.render_options.show_bracket) {
          Vex.Flow.Renderer.drawDashedLine(ctx, end_x, line_y + (1 * this.position),
            end_x, line_y + bracket_height, this.render_options.dash);
        }
      } else {
        ctx.beginPath();
        ctx.moveTo(start_x, line_y);
        // Main line
        ctx.lineTo(end_x, line_y);
        if (this.render_options.show_bracket) {
          // Ending bracket
          ctx.lineTo(end_x, line_y + bracket_height);
        }
        ctx.stroke();
        ctx.closePath();
      }

      ctx.restore();
    }
  };

  return TextBracket;
})();
// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements the `TextDynamics` which renders traditional
// text dynamics markings, **ie: p, f, sfz, rfz, ppp**
//
// You can render any dynamics string that contains a combination of
// the following letters:  P, M, F, Z, R, S
Vex.Flow.TextDynamics = (function(){
  function TextDynamics(text_struct) {
    if (arguments.length > 0) this.init(text_struct);
  }

  // To enable logging for this class. Set `Vex.Flow.TextDynamics.DEBUG` to `true`.
  function L() { if (TextDynamics.DEBUG) Vex.L("Vex.Flow.TextDynamics", arguments); }

  // The glyph data for each dynamics letter
  TextDynamics.GLYPHS = {
    "f": {
      code: "vba",
      width: 12
    },
    "p": {
      code: "vbf",
      width: 14
    },
    "m": {
      code: "v62",
      width: 17
    },
    "s": {
      code: "v4a",
      width: 10
    },
    "z": {
      code: "v80",
      width: 12
    },
    "r": {
      code: "vb1",
      width: 12
    }
  };

  // ## Prototype Methods
  //
  // A `TextDynamics` object inherits from `Note` so that it can be formatted
  // within a `Voice`.
  Vex.Inherit(TextDynamics, Vex.Flow.Note, {
    // Create the dynamics marking. `text_struct` is an object
    // that contains a `duration` property and a `sequence` of
    // letters that represents the letters to render
    init: function(text_struct) {
      TextDynamics.superclass.init.call(this, text_struct);

      this.sequence = text_struct.text.toLowerCase();
      this.line = text_struct.line || 0;
      this.glyphs = [];

      Vex.Merge(this.render_options, {
        glyph_font_size: 40
      });

      L("New Dynamics Text: ", this.sequence);
    },

    // Set the Stave line on which the note should be placed
    setLine: function(line) { this.line = line;  return this; },

    // Preformat the dynamics text
    preFormat: function() {
      var total_width = 0;
      // Iterate through each letter
      this.sequence.split('').forEach(function(letter) {
        // Get the glyph data for the letter
        var glyph_data = TextDynamics.GLYPHS[letter];
        if (!glyph_data) throw new Vex.RERR("Invalid dynamics character: " + letter);

        var size =  this.render_options.glyph_font_size;
        var glyph = new Vex.Flow.Glyph(glyph_data.code, size);

        // Add the glyph
        this.glyphs.push(glyph);

        total_width += glyph_data.width;
      }, this);

      // Store the width of the text
      this.setWidth(total_width);
      this.preFormatted = true;
      return this;
    },

    // Draw the dynamics text on the rendering context
    draw: function() {
      var x = this.getAbsoluteX();
      var y = this.stave.getYForLine(this.line + (-3));

      L("Rendering Dynamics: ", this.sequence);

      var letter_x = x;
      this.glyphs.forEach(function(glyph, index) {
        var current_letter = this.sequence[index];
        glyph.render(this.context, letter_x, y);
        letter_x += TextDynamics.GLYPHS[current_letter].width;
      }, this);
    }
  });

  return TextDynamics;
})();
Vex.Flow.GraceNote = (function() {
  var GraceNote = function(note_struct) {
    if (arguments.length > 0) this.init(note_struct);
  };

  Vex.Inherit(GraceNote, Vex.Flow.StaveNote, {
    init: function(note_struct) {
      GraceNote.superclass.init.call(this, note_struct);

      this.render_options.glyph_font_scale = 22;
      this.render_options.stem_height = 20;
      this.render_options.stroke_px = 2;
      this.glyph.head_width = 6;

      this.slash = note_struct.slash;
      this.slur = true;

      this.buildNoteHeads();

      this.width = 3;
    },

    getStemExtension: function(){
      var glyph = this.getGlyph();

      if (this.stem_extension_override != null) {
        return this.stem_extension_override;
      }

      if (glyph) {
        return this.getStemDirection() === 1 ? glyph.gracenote_stem_up_extension :
          glyph.gracenote_stem_down_extension;
      }

      return 0;
    },

    getCategory: function() { return 'gracenotes'; },

    draw: function(){
      GraceNote.superclass.draw.call(this);
      var ctx = this.context;
      var stem_direction = this.getStemDirection();

      if (this.slash) {
        ctx.beginPath();

        var x = this.getAbsoluteX();
        var y = this.getYs()[0] - (this.stem.getHeight() / 2.8);
        if (stem_direction === 1) {
          x += 1;
          ctx.moveTo(x, y);
          ctx.lineTo(x + 13, y - 9);
        } else if (stem_direction === -1) {
          x -= 4;
          y += 1;
          ctx.moveTo(x, y);
          ctx.lineTo(x + 13, y + 9);
        }

        ctx.closePath();
        ctx.stroke();
      }
    }
  });

  return GraceNote;
}());

// [VexFlow](http://vexflow.com) - Copyright (c) Mohit Muthanna 2010.
//
// ## Description
//
// This file implements `GraceNoteGroup` which is used to format and
// render grace notes.

Vex.Flow.GraceNoteGroup = (function(){
  function GraceNoteGroup(grace_notes, config) {
    if (arguments.length > 0) this.init(grace_notes, config);
  }

  GraceNoteGroup.CATEGORY = "gracenotegroups";

  // To enable logging for this class. Set `Vex.Flow.GraceNoteGroup.DEBUG` to `true`.
  function L() { if (GraceNoteGroup.DEBUG) Vex.L("Vex.Flow.GraceNoteGroup", arguments); }

  // Arrange groups inside a `ModifierContext`
  GraceNoteGroup.format = function(gracenote_groups, state) {
    var gracenote_spacing = 4;

    if (!gracenote_groups || gracenote_groups.length === 0) return false;

    var group_list = [];
    var hasStave = false;
    var prev_note = null;
    var shiftL = 0;

    var i, gracenote_group, props_tmp;
    for (i = 0; i < gracenote_groups.length; ++i) {
      gracenote_group = gracenote_groups[i];
      var note = gracenote_group.getNote();
      var stave = note.getStave();
      if (note != prev_note) {
         // Iterate through all notes to get the displaced pixels
         for (var n = 0; n < note.keys.length; ++n) {
            props_tmp = note.getKeyProps()[n];
            shiftL = (props_tmp.displaced ? note.getExtraLeftPx() : shiftL);
          }
          prev_note = note;
      }
      if (stave != null) {
        hasStave = true;
        group_list.push({shift: shiftL, gracenote_group: gracenote_group});
      } else {
        group_list.push({shift: shiftL, gracenote_group: gracenote_group });
      }
    }

    // If first note left shift in case it is displaced
    var group_shift = group_list[0].shift;
    var formatWidth;
    for (i = 0; i < group_list.length; ++i) {
      gracenote_group = group_list[i].gracenote_group;
      gracenote_group.preFormat();
      formatWidth = gracenote_group.getWidth() + gracenote_spacing;
      group_shift = Math.max(formatWidth, group_shift);
    }

    for (i = 0; i < group_list.length; ++i) {
      gracenote_group = group_list[i].gracenote_group;
      formatWidth = gracenote_group.getWidth() + gracenote_spacing;
      gracenote_group.setSpacingFromNextModifier(group_shift - Math.min(formatWidth, group_shift));
    }

    state.left_shift += group_shift;
    return true;
  };

  // ## Prototype Methods
  //
  // `GraceNoteGroup` inherits from `Modifier` and is placed inside a
  // `ModifierContext`.
  Vex.Inherit(GraceNoteGroup, Vex.Flow.Modifier, {
    init: function(grace_notes, show_slur) {
      var superclass = GraceNoteGroup.superclass;
      superclass.init.call(this);

      this.note = null;
      this.index = null;
      this.position = Vex.Flow.Modifier.Position.LEFT;
      this.grace_notes = grace_notes;
      this.width = 0;

      this.preFormatted = false;

      this.show_slur = show_slur;
      this.slur = null;

      this.formatter = new Vex.Flow.Formatter();
      this.voice = new Vex.Flow.Voice({
        num_beats: 4,
        beat_value: 4,
        resolution: Vex.Flow.RESOLUTION
      }).setStrict(false);

      this.voice.addTickables(this.grace_notes);

      return this;
    },

    preFormat: function(){
      if (this.preFormatted) return;

      this.formatter.joinVoices([this.voice]).format([this.voice], 0);
      this.setWidth(this.formatter.getMinTotalWidth());
      this.preFormatted = true;
    },

    beamNotes: function(){
      if (this.grace_notes.length > 1) {
        var beam = new Vex.Flow.Beam(this.grace_notes);

        beam.render_options.beam_width = 3;
        beam.render_options.partial_beam_length = 4;

        this.beam = beam;
      }

      return this;
    },

    setNote: function(note) {
      this.note = note;
    },
    setWidth: function(width){
      this.width = width;
    },
    getWidth: function(){
      return this.width;
    },
    draw: function() {
      if (!this.context)  {
        throw new Vex.RuntimeError("NoContext",
          "Can't draw Grace note without a context.");
      }

      var note = this.getNote();

      L("Drawing grace note group for:", note);

      if (!(note && (this.index !== null))) {
        throw new Vex.RuntimeError("NoAttachedNote",
          "Can't draw grace note without a parent note and parent note index.");
      }

      var that = this;
      function alignGraceNotesWithNote(grace_notes, note, groupWidth) {
        // Shift over the tick contexts of each note
        // So that th aligned with the note
        var tickContext = note.getTickContext();
        var extraPx = tickContext.getExtraPx();
        var x = tickContext.getX() - extraPx.left - extraPx.extraLeft + that.getSpacingFromNextModifier();
        grace_notes.forEach(function(graceNote) {
            var tick_context = graceNote.getTickContext();
            var x_offset = tick_context.getX();
            graceNote.setStave(note.stave);
            tick_context.setX(x + x_offset);
        });
      }

      alignGraceNotesWithNote(this.grace_notes, note, this.width);

      // Draw notes
      this.grace_notes.forEach(function(graceNote) {
        graceNote.setContext(this.context).draw();
      }, this);

      // Draw beam
      if (this.beam) {
        this.beam.setContext(this.context).draw();
      }

      if (this.show_slur) {
        // Create and draw slur
        this.slur = new Vex.Flow.StaveTie({
          last_note: this.grace_notes[0],
          first_note: note,
          first_indices: [0],
          last_indices: [0]
        });

        this.slur.render_options.cp2 = 12;
        this.slur.setContext(this.context).draw();
      }
    }
  });

return GraceNoteGroup;
}());

},{}],2:[function(require,module,exports){
(function (process){
/* parser generated by jison 0.4.16 */
/*
  Returns a Parser object of the following structure:

  Parser: {
    yy: {}
  }

  Parser.prototype: {
    yy: {},
    trace: function(),
    symbols_: {associative list: name ==> number},
    terminals_: {associative list: number ==> name},
    productions_: [...],
    performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate, $$, _$),
    table: [...],
    defaultActions: {...},
    parseError: function(str, hash),
    parse: function(input),

    lexer: {
        EOF: 1,
        parseError: function(str, hash),
        setInput: function(input),
        input: function(),
        unput: function(str),
        more: function(),
        less: function(n),
        pastInput: function(),
        upcomingInput: function(),
        showPosition: function(),
        test_match: function(regex_match_array, rule_index),
        next: function(),
        lex: function(),
        begin: function(condition),
        popState: function(),
        _currentRules: function(),
        topState: function(),
        pushState: function(condition),

        options: {
            ranges: boolean           (optional: true ==> token location info will include a .range[] member)
            flex: boolean             (optional: true ==> flex-like lexing behaviour where the rules are tested exhaustively to find the longest match)
            backtrack_lexer: boolean  (optional: true ==> lexer regexes are tested in order and for each matching regex the action code is invoked; the lexer terminates the scan when a token is returned by the action code)
        },

        performAction: function(yy, yy_, $avoiding_name_collisions, YY_START),
        rules: [...],
        conditions: {associative list: name ==> set},
    }
  }


  token location info (@$, _$, etc.): {
    first_line: n,
    last_line: n,
    first_column: n,
    last_column: n,
    range: [start_number, end_number]       (where the numbers are indexes into the input string, regular zero-based)
  }


  the parseError function receives a 'hash' object with these members for lexer and parser errors: {
    text:        (matched text)
    token:       (the produced terminal token, if any)
    line:        (yylineno)
  }
  while parser (grammar) errors will also provide these members, i.e. parser errors deliver a superset of attributes: {
    loc:         (yylloc)
    expected:    (string describing the set of expected tokens)
    recoverable: (boolean: TRUE when the parser has a error recovery rule available for this particular error)
  }
*/
var parser = (function(){
var o=function(k,v,o,l){for(o=o||{},l=k.length;l--;o[k[l]]=v);return o},$V0=[1,5],$V1=[1,6],$V2=[5,8,10],$V3=[1,12],$V4=[1,13],$V5=[1,14],$V6=[1,16],$V7=[5,8,10,16,17,18],$V8=[5,8,10,16,17,18,20,22,24],$V9=[2,20],$Va=[5,8,10,16,17,18,20,22,24,25],$Vb=[1,20],$Vc=[1,24],$Vd=[1,25],$Ve=[1,26],$Vf=[1,49],$Vg=[1,38],$Vh=[1,39],$Vi=[1,48],$Vj=[1,47],$Vk=[1,45],$Vl=[1,54],$Vm=[1,61],$Vn=[1,56],$Vo=[1,57],$Vp=[1,58],$Vq=[1,59],$Vr=[1,60],$Vs=[1,62],$Vt=[1,50],$Vu=[1,51],$Vv=[1,52],$Vw=[1,53],$Vx=[1,63],$Vy=[5,8,10,16,17,18,20,22,24,28],$Vz=[5,8,10,16,17,18,20,22,24,26,34,35,40,41,48,51,60,64,65,66,67,68,69,73,74,76,78,79],$VA=[2,82],$VB=[1,72],$VC=[1,69],$VD=[1,70],$VE=[1,71],$VF=[1,78],$VG=[1,79],$VH=[1,83],$VI=[1,84],$VJ=[1,85],$VK=[1,86],$VL=[44,60,62,64,65,66,67,68,69,70,71,72],$VM=[41,48,51,79],$VN=[44,51,60,62,64,65,66,67,68,69,70,71,72,84],$VO=[5,8,10,16,17,18,20,22,24,26,34,35,40,41,44,48,51,60,64,65,66,67,68,69,73,74,76,78,79],$VP=[1,105],$VQ=[47,49],$VR=[2,66],$VS=[1,110],$VT=[5,8,10,16,17,18,20,22,24,26,34,35,40,41,48,51,60,62,64,65,66,67,68,69,73,74,76,78,79],$VU=[5,8,10,16,17,18,20,22,24,26,34,35,40,41,48,51,60,62,63,64,65,66,67,68,69,73,74,76,78,79],$VV=[28,74],$VW=[44,51,60,62,64,65,66,67,68,69,70,71,72],$VX=[5,8,10,16,17,18,20,22,24,26,34,35,40,41,47,48,49,51,60,64,65,66,67,68,69,73,74,76,78,79];
var parser = {trace: function trace() { },
yy: {},
symbols_: {"error":2,"e":3,"maybe_vextab":4,"EOF":5,"vextab":6,"stavegroup":7,"STAVEGROUP":8,"stavelist":9,"OPTIONS":10,"options":11,"stave":12,"voice":13,"maybe_options":14,"stave_data":15,"TABSTAVE":16,"STAVE":17,"VOICE":18,"stave_additions":19,"TEXT":20,"text":21,"NOTES":22,"notes":23,"SLUR":24,"WORD":25,"=":26,"STR":27,",":28,"lingo":29,"line":30,"chord":31,"time":32,"bar":33,"[":34,"]":35,"tuplets":36,"annotations":37,"command":38,"rest":39,"|":40,":":41,"frets":42,"maybe_decorator":43,"/":44,"string":45,"chord_line":46,".":47,"(":48,")":49,"articulation":50,"NUMBER":51,"abc":52,"_":53,"timed_fret":54,"time_values":55,"maybe_dot":56,"time_unit":57,"maybe_slash":58,"w":59,"h":60,"q":61,"d":62,"S":63,"-":64,"s":65,"t":66,"T":67,"b":68,"p":69,"v":70,"V":71,"u":72,"^":73,"$":74,"annotation_words":75,"!":76,"COMMAND":77,"#":78,"ABC":79,"abc_accidental":80,"accidental_type":81,"@":82,"n":83,"~":84,"$accept":0,"$end":1},
terminals_: {2:"error",5:"EOF",8:"STAVEGROUP",10:"OPTIONS",16:"TABSTAVE",17:"STAVE",18:"VOICE",20:"TEXT",22:"NOTES",24:"SLUR",25:"WORD",26:"=",27:"STR",28:",",34:"[",35:"]",40:"|",41:":",44:"/",47:".",48:"(",49:")",51:"NUMBER",53:"_",59:"w",60:"h",61:"q",62:"d",63:"S",64:"-",65:"s",66:"t",67:"T",68:"b",69:"p",70:"v",71:"V",72:"u",73:"^",74:"$",76:"!",77:"COMMAND",78:"#",79:"ABC",82:"@",83:"n",84:"~"},
productions_: [0,[3,2],[4,0],[4,1],[6,1],[6,2],[7,2],[7,2],[9,1],[9,2],[12,3],[12,2],[13,1],[13,1],[13,1],[15,1],[15,2],[19,2],[19,2],[19,2],[14,0],[14,1],[11,3],[11,4],[21,1],[21,3],[23,1],[23,2],[29,1],[29,1],[29,1],[29,1],[29,1],[29,1],[29,1],[29,1],[29,1],[29,1],[33,1],[33,3],[33,3],[33,3],[33,3],[33,3],[30,4],[46,1],[46,3],[31,4],[31,5],[42,1],[42,1],[42,4],[42,2],[42,4],[54,5],[54,1],[54,5],[54,8],[54,1],[54,4],[32,3],[55,2],[57,1],[57,1],[57,1],[57,1],[56,0],[56,1],[58,0],[58,1],[45,1],[50,1],[50,1],[50,1],[50,1],[50,1],[50,1],[50,1],[43,1],[43,1],[43,1],[43,1],[43,0],[36,3],[36,5],[37,3],[75,1],[75,3],[38,3],[39,2],[39,3],[39,4],[52,3],[80,1],[80,2],[80,1],[80,2],[80,1],[80,0],[81,0],[81,1]],
performAction: function anonymous(yytext, yyleng, yylineno, yy, yystate /* action[1] */, $$ /* vstack */, _$ /* lstack */) {
/* this == yyval */

var $0 = $$.length - 1;
switch (yystate) {
case 1:

      return $$[$0-1];
    
break;
case 2: case 20: case 82:
 this.$ = null 
break;
case 3: case 15: case 21: case 26: case 28: case 29: case 30: case 45: case 62: case 63: case 64: case 65: case 70:
 this.$ = $$[$0] 
break;
case 4: case 8: case 86:
 this.$ = [$$[$0]] 
break;
case 5: case 9:
 this.$ = [].concat($$[$0-1], $$[$0]) 
break;
case 6:
 this.$ = {
        element: "stavegroup",
        stavelist: $$[$0],
        _l: _$[$0-1].first_line,
        _c: _$[$0-1].first_column
      }
    
break;
case 7:

      this.$ = {
        element: "options",
        params: $$[$0],
        _l: _$[$0-1].first_line,
        _c: _$[$0-1].first_column
      }
    
break;
case 10:
 this.$ = {
        element: $$[$0-2],
        options: $$[$0-1],
        notes: $$[$0].notes,
        text: $$[$0].text,
        _l: _$[$0-2].first_line,
        _c: _$[$0-2].first_column
      }
    
break;
case 11:
 this.$ = {
        element: $$[$0-1],
        options: $$[$0],
        _l: _$[$0-1].first_line,
        _c: _$[$0-1].first_column
      }
    
break;
case 16:

      var text = [].concat($$[$0-1].text, $$[$0].text);
      var notes = [].concat($$[$0-1].notes, $$[$0].notes);
      var slurs = [].concat($$[$0-1].slurs, $$[$0].slurs)
      this.$ = {text: text, notes: notes, slurs: slurs};
    
break;
case 17:
this.$ = {text: $$[$0], notes: [], slurs: []}
break;
case 18:
this.$ = {notes: $$[$0], text: [], slurs: []}
break;
case 19:
this.$ = {slurs: $$[$0], notes: [], text: []}
break;
case 22:
 this.$ = [{
        key: $$[$0-2],
        value: $$[$0],
        _l: _$[$0-2].first_line,
        _c: _$[$0-2].first_column
      }]
    
break;
case 23:
 this.$ = [].concat($$[$0-3], [{
        key: $$[$0-2],
        value: $$[$0],
        _l: _$[$0-2].first_line,
        _c: _$[$0-2].first_column
        }])
    
break;
case 24:
 this.$ = [{text: $$[$0], _l: _$[$0].first_line, _c: _$[$0].first_column}] 
break;
case 25:
 this.$ = [].concat($$[$0-2], {text: $$[$0], _l: _$[$0].first_line, _c: _$[$0].first_column}) 
break;
case 27:
 this.$ = [].concat($$[$0-1], $$[$0])  
break;
case 31:
 this.$ = [{
        command: "bar",
        type: $$[$0],
        _l: _$[$0].first_line,
        _c: _$[$0].first_column
        }]
    
break;
case 32:
 this.$ = [{
        command: "open_beam",
        _l: _$[$0].first_line,
        _c: _$[$0].first_column
      }]
    
break;
case 33:
 this.$ = [{
        command: "close_beam",
        _l: _$[$0].first_line,
        _c: _$[$0].first_column
      }]
    
break;
case 34:
 this.$ = [{
        command: "tuplet",
        params: $$[$0],
        _l: _$[$0].first_line,
        _c: _$[$0].first_column
      }]
    
break;
case 35:
 this.$ = [{
        command: "annotations",
        params: $$[$0],
        _l: _$[$0].first_line,
        _c: _$[$0].first_column
      }]
    
break;
case 36:
 this.$ = [{
        command: "command",
        params: $$[$0],
        _l: _$[$0].first_line,
        _c: _$[$0].first_column
      }]
    
break;
case 37:

    this.$ = [{
        command: "rest",
        params: $$[$0]
      }]
    
break;
case 38:
 this.$ = 'single' 
break;
case 39:
 this.$ = 'double' 
break;
case 40:
 this.$ = 'end' 
break;
case 41:
 this.$ = 'repeat-end' 
break;
case 42:
 this.$ = 'repeat-begin' 
break;
case 43:
 this.$ = 'repeat-both' 
break;
case 44:

      _.extend(_.last($$[$0-3]), {decorator: $$[$0-2]})
      _.each($$[$0-3], function(fret) { fret['string'] = $$[$0] })
      this.$ = $$[$0-3]
    
break;
case 46: case 87:
 this.$ = [].concat($$[$0-2], $$[$0]) 
break;
case 47:
 this.$ = [{chord: $$[$0-2], decorator: $$[$0]}] 
break;
case 48:
 this.$ = [{chord: $$[$0-2], articulation: $$[$0-4], decorator: $$[$0]}] 
break;
case 49:
 this.$ = [{
        fret: $$[$0],
        _l: _$[$0].first_line,
        _c: _$[$0].first_column}]
    
break;
case 50:
 this.$ = [{abc: $$[$0], _l: _$[$0].first_line, _c: _$[$0].first_column}]
break;
case 51:
 this.$ = [{abc: $$[$0-3], octave: $$[$0-2],
             fret: $$[$0], _l: _$[$0-3].first_line, _c: _$[$0-3].first_column}]
break;
case 52:
 this.$ = [_.extend($$[$0], {articulation: $$[$0-1]})] 
break;
case 53:

      _.extend(_.last($$[$0-3]), {decorator: $$[$0-2]})
      _.extend($$[$0], {articulation: $$[$0-1]})
      $$[$0-3].push($$[$0])
      this.$ = $$[$0-3]
    
break;
case 54:
 this.$ = {
      time: $$[$0-3], dot: $$[$0-2], fret: $$[$0],
      _l: _$[$0-4].first_line, _c: _$[$0-4].first_column}
break;
case 55:
 this.$ = {fret: $$[$0], _l: _$[$0].first_line, _c: _$[$0].first_column} 
break;
case 56:
 this.$ = {time: $$[$0-3], dot: $$[$0-2], abc: $$[$0]}
break;
case 57:
 this.$ = {time: $$[$0-6], dot: $$[$0-5], abc: $$[$0-3], octave: $$[$0-2], fret: $$[$0]}
break;
case 58:
 this.$ = {abc: $$[$0], _l: _$[$0].first_line, _c: _$[$0].first_column} 
break;
case 59:
 this.$ = {abc: $$[$0-3], octave: $$[$0-2],
            fret: $$[$0], _l: _$[$0-3].first_line, _c: _$[$0-3].first_column} 
break;
case 60:
 this.$ = {time: $$[$0-1], dot: $$[$0]} 
break;
case 61:
 this.$ = $$[$0-1] + $$[$0] 
break;
case 66:
 this.$ = false 
break;
case 67:
 this.$ = true 
break;
case 68:
 this.$ = '' 
break;
case 69: case 72:
 this.$ = 's' 
break;
case 71:
 this.$ = '-' 
break;
case 73:
 this.$ = 't' 
break;
case 74:
 this.$ = 'T' 
break;
case 75:
 this.$ = 'b' 
break;
case 76:
 this.$ = 'h' 
break;
case 77:
 this.$ = 'p' 
break;
case 78:
 this.$ = 'v' 
break;
case 79:
 this.$ = 'V' 
break;
case 80:
 this.$ = 'u' 
break;
case 81:
 this.$ = 'd' 
break;
case 83:
 this.$ = {tuplet: $$[$0-1]} 
break;
case 84:
 this.$ = {tuplet: $$[$0-3], notes: $$[$0-1]} 
break;
case 85: case 88:
 this.$ = $$[$0-1] 
break;
case 89:
 this.$ = {position: 0} 
break;
case 90:
 this.$ = {position: $$[$0-1]} 
break;
case 91:
 this.$ = {position: $$[$0-1] * -1} 
break;
case 92:
 this.$ = {key: $$[$0-2], accidental: $$[$0-1], accidental_type: $$[$0]} 
break;
case 93:
 this.$ = "#" 
break;
case 94:
 this.$ = "##" 
break;
case 95:
 this.$ = "b" 
break;
case 96:
 this.$ = "bb" 
break;
case 97:
 this.$ = "n" 
break;
case 99:
 this.$ = null; 
break;
case 100:
 this.$ = "c" 
break;
}
},
table: [{3:1,4:2,5:[2,2],6:3,7:4,8:$V0,10:$V1},{1:[3]},{5:[1,7]},{5:[2,3],7:8,8:$V0,10:$V1},o($V2,[2,4]),{9:9,12:10,13:11,16:$V3,17:$V4,18:$V5},{11:15,25:$V6},{1:[2,1]},o($V2,[2,5]),o($V2,[2,6],{13:11,12:17,16:$V3,17:$V4,18:$V5}),o($V7,[2,8]),o($V8,$V9,{14:18,11:19,25:$V6}),o($Va,[2,12]),o($Va,[2,13]),o($Va,[2,14]),o($V2,[2,7],{25:$Vb}),{26:[1,21]},o($V7,[2,9]),o($V7,[2,11],{15:22,19:23,20:$Vc,22:$Vd,24:$Ve}),o($V8,[2,21],{25:$Vb}),{26:[1,27]},{25:[1,28]},o($V7,[2,10],{19:29,20:$Vc,22:$Vd,24:$Ve}),o($V8,[2,15]),{21:30,27:[1,31]},{23:32,26:$Vf,29:33,30:34,31:35,32:36,33:37,34:$Vg,35:$Vh,36:40,37:41,38:42,39:43,40:$Vi,41:$Vj,42:44,48:$Vk,50:46,51:$Vl,52:55,60:$Vm,64:$Vn,65:$Vo,66:$Vp,67:$Vq,68:$Vr,69:$Vs,73:$Vt,74:$Vu,76:$Vv,78:$Vw,79:$Vx},o($V8,$V9,{11:19,14:64,25:$V6}),{25:[1,65]},o($Va,[2,22]),o($V8,[2,16]),o($V8,[2,17],{28:[1,66]}),o($Vy,[2,24]),o($V8,[2,18],{30:34,31:35,32:36,33:37,36:40,37:41,38:42,39:43,42:44,50:46,52:55,29:67,26:$Vf,34:$Vg,35:$Vh,40:$Vi,41:$Vj,48:$Vk,51:$Vl,60:$Vm,64:$Vn,65:$Vo,66:$Vp,67:$Vq,68:$Vr,69:$Vs,73:$Vt,74:$Vu,76:$Vv,78:$Vw,79:$Vx}),o($Vz,[2,26]),o($Vz,[2,28]),o($Vz,[2,29]),o($Vz,[2,30]),o($Vz,[2,31]),o($Vz,[2,32]),o($Vz,[2,33]),o($Vz,[2,34]),o($Vz,[2,35]),o($Vz,[2,36]),o($Vz,[2,37]),o([44,60,64,65,66,67,68,69],$VA,{43:68,62:$VB,70:$VC,71:$VD,72:$VE}),{30:74,42:44,46:73,50:75,51:$Vl,52:55,60:$Vm,64:$Vn,65:$Vo,66:$Vp,67:$Vq,68:$Vr,69:$Vs,79:$Vx},{41:$VF,48:[1,76],51:$VG,52:80,54:77,79:$Vx},{51:$VH,55:81,57:82,59:$VI,60:$VJ,61:$VK},o($Vz,[2,38]),{40:[1,87],41:[1,88]},{51:[1,89]},{25:[1,91],75:90},{77:[1,92]},{51:[1,94],64:[1,95],78:[1,93]},o($VL,[2,49]),o($VL,[2,50],{51:[1,96]}),o($VM,[2,71]),o($VM,[2,72]),o($VM,[2,73]),o($VM,[2,74]),o($VM,[2,75]),o($VM,[2,76]),o($VM,[2,77]),o($VN,[2,98],{80:97,78:[1,98],82:[1,99],83:[1,100]}),o($V8,[2,19]),o($Va,[2,23]),{27:[1,101]},o($Vz,[2,27]),{44:[1,102],50:103,60:$Vm,64:$Vn,65:$Vo,66:$Vp,67:$Vq,68:$Vr,69:$Vs},o($VO,[2,78]),o($VO,[2,79]),o($VO,[2,80]),o($VO,[2,81]),{47:$VP,49:[1,104]},o($VQ,[2,45]),{41:$VF,51:$VG,52:80,54:77,79:$Vx},{30:74,42:44,46:106,50:75,51:$Vl,52:55,60:$Vm,64:$Vn,65:$Vo,66:$Vp,67:$Vq,68:$Vr,69:$Vs,79:$Vx},o($VL,[2,52]),{51:$VH,55:107,57:82,59:$VI,60:$VJ,61:$VK},o($VL,[2,55]),o($VL,[2,58],{51:[1,108]}),o($Vz,$VR,{56:109,62:$VS}),o($VT,[2,68],{58:111,63:[1,112]}),o($VU,[2,62]),o($VU,[2,63]),o($VU,[2,64]),o($VU,[2,65]),{26:[1,114],40:[1,113],41:[1,115]},{40:[1,116],41:[1,117]},{28:[1,119],73:[1,118]},{28:[1,121],74:[1,120]},o($VV,[2,86]),{76:[1,122]},o($Vz,[2,89]),{78:[1,123]},{51:[1,124]},{53:[1,125]},o($VW,[2,99],{81:126,84:[1,127]}),o($VN,[2,93],{78:[1,128]}),o($VN,[2,95],{82:[1,129]}),o($VN,[2,97]),o($Vy,[2,25]),{45:130,51:[1,131]},{41:$VF,51:$VG,52:80,54:132,79:$Vx},o($Vz,$VA,{43:133,62:$VB,70:$VC,71:$VD,72:$VE}),{30:134,42:44,50:75,51:$Vl,52:55,60:$Vm,64:$Vn,65:$Vo,66:$Vp,67:$Vq,68:$Vr,69:$Vs,79:$Vx},{47:$VP,49:[1,135]},{41:$VR,56:136,62:$VS},{53:[1,137]},o($Vz,[2,60]),o($Vz,[2,67]),o($VT,[2,61]),o($VT,[2,69]),o($Vz,[2,39]),o($Vz,[2,40]),o($Vz,[2,42]),o($Vz,[2,41]),o($Vz,[2,43]),o($Vz,[2,83]),{51:[1,138]},o($Vz,[2,85]),{25:[1,139]},o($Vz,[2,88]),o($Vz,[2,90]),{78:[1,140]},{51:[1,141]},o($VW,[2,92]),o($VW,[2,100]),o($VN,[2,94]),o($VN,[2,96]),o($VX,[2,44]),o($VX,[2,70]),o($VL,[2,53]),o($Vz,[2,47]),o($VQ,[2,46]),o($Vz,$VA,{43:142,62:$VB,70:$VC,71:$VD,72:$VE}),{41:[1,143]},{51:[1,144]},{73:[1,145]},o($VV,[2,87]),o($Vz,[2,91]),o($VL,[2,51]),o($Vz,[2,48]),{51:[1,146],52:147,79:$Vx},o($VL,[2,59]),o($Vz,[2,84]),o($VL,[2,54]),o($VL,[2,56],{51:[1,148]}),{53:[1,149]},{51:[1,150]},o($VL,[2,57])],
defaultActions: {7:[2,1]},
parseError: function parseError(str, hash) {
    if (hash.recoverable) {
        this.trace(str);
    } else {
        function _parseError (msg, hash) {
            this.message = msg;
            this.hash = hash;
        }
        _parseError.prototype = new Error();

        throw new _parseError(str, hash);
    }
},
parse: function parse(input) {
    var self = this, stack = [0], tstack = [], vstack = [null], lstack = [], table = this.table, yytext = '', yylineno = 0, yyleng = 0, recovering = 0, TERROR = 2, EOF = 1;
    var args = lstack.slice.call(arguments, 1);
    var lexer = Object.create(this.lexer);
    var sharedState = { yy: {} };
    for (var k in this.yy) {
        if (Object.prototype.hasOwnProperty.call(this.yy, k)) {
            sharedState.yy[k] = this.yy[k];
        }
    }
    lexer.setInput(input, sharedState.yy);
    sharedState.yy.lexer = lexer;
    sharedState.yy.parser = this;
    if (typeof lexer.yylloc == 'undefined') {
        lexer.yylloc = {};
    }
    var yyloc = lexer.yylloc;
    lstack.push(yyloc);
    var ranges = lexer.options && lexer.options.ranges;
    if (typeof sharedState.yy.parseError === 'function') {
        this.parseError = sharedState.yy.parseError;
    } else {
        this.parseError = Object.getPrototypeOf(this).parseError;
    }
    function popStack(n) {
        stack.length = stack.length - 2 * n;
        vstack.length = vstack.length - n;
        lstack.length = lstack.length - n;
    }
    _token_stack:
        var lex = function () {
            var token;
            token = lexer.lex() || EOF;
            if (typeof token !== 'number') {
                token = self.symbols_[token] || token;
            }
            return token;
        };
    var symbol, preErrorSymbol, state, action, a, r, yyval = {}, p, len, newState, expected;
    while (true) {
        state = stack[stack.length - 1];
        if (this.defaultActions[state]) {
            action = this.defaultActions[state];
        } else {
            if (symbol === null || typeof symbol == 'undefined') {
                symbol = lex();
            }
            action = table[state] && table[state][symbol];
        }
                    if (typeof action === 'undefined' || !action.length || !action[0]) {
                var errStr = '';
                expected = [];
                for (p in table[state]) {
                    if (this.terminals_[p] && p > TERROR) {
                        expected.push('\'' + this.terminals_[p] + '\'');
                    }
                }
                if (lexer.showPosition) {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ':\n' + lexer.showPosition() + '\nExpecting ' + expected.join(', ') + ', got \'' + (this.terminals_[symbol] || symbol) + '\'';
                } else {
                    errStr = 'Parse error on line ' + (yylineno + 1) + ': Unexpected ' + (symbol == EOF ? 'end of input' : '\'' + (this.terminals_[symbol] || symbol) + '\'');
                }
                this.parseError(errStr, {
                    text: lexer.match,
                    token: this.terminals_[symbol] || symbol,
                    line: lexer.yylineno,
                    loc: yyloc,
                    expected: expected
                });
            }
        if (action[0] instanceof Array && action.length > 1) {
            throw new Error('Parse Error: multiple actions possible at state: ' + state + ', token: ' + symbol);
        }
        switch (action[0]) {
        case 1:
            stack.push(symbol);
            vstack.push(lexer.yytext);
            lstack.push(lexer.yylloc);
            stack.push(action[1]);
            symbol = null;
            if (!preErrorSymbol) {
                yyleng = lexer.yyleng;
                yytext = lexer.yytext;
                yylineno = lexer.yylineno;
                yyloc = lexer.yylloc;
                if (recovering > 0) {
                    recovering--;
                }
            } else {
                symbol = preErrorSymbol;
                preErrorSymbol = null;
            }
            break;
        case 2:
            len = this.productions_[action[1]][1];
            yyval.$ = vstack[vstack.length - len];
            yyval._$ = {
                first_line: lstack[lstack.length - (len || 1)].first_line,
                last_line: lstack[lstack.length - 1].last_line,
                first_column: lstack[lstack.length - (len || 1)].first_column,
                last_column: lstack[lstack.length - 1].last_column
            };
            if (ranges) {
                yyval._$.range = [
                    lstack[lstack.length - (len || 1)].range[0],
                    lstack[lstack.length - 1].range[1]
                ];
            }
            r = this.performAction.apply(yyval, [
                yytext,
                yyleng,
                yylineno,
                sharedState.yy,
                action[1],
                vstack,
                lstack
            ].concat(args));
            if (typeof r !== 'undefined') {
                return r;
            }
            if (len) {
                stack = stack.slice(0, -1 * len * 2);
                vstack = vstack.slice(0, -1 * len);
                lstack = lstack.slice(0, -1 * len);
            }
            stack.push(this.productions_[action[1]][0]);
            vstack.push(yyval.$);
            lstack.push(yyval._$);
            newState = table[stack[stack.length - 2]][stack[stack.length - 1]];
            stack.push(newState);
            break;
        case 3:
            return true;
        }
    }
    return true;
}};

  var _ = require("lodash");
/* generated by jison-lex 0.3.4 */
var lexer = (function(){
var lexer = ({

EOF:1,

parseError:function parseError(str, hash) {
        if (this.yy.parser) {
            this.yy.parser.parseError(str, hash);
        } else {
            throw new Error(str);
        }
    },

// resets the lexer, sets new input
setInput:function (input, yy) {
        this.yy = yy || this.yy || {};
        this._input = input;
        this._more = this._backtrack = this.done = false;
        this.yylineno = this.yyleng = 0;
        this.yytext = this.matched = this.match = '';
        this.conditionStack = ['INITIAL'];
        this.yylloc = {
            first_line: 1,
            first_column: 0,
            last_line: 1,
            last_column: 0
        };
        if (this.options.ranges) {
            this.yylloc.range = [0,0];
        }
        this.offset = 0;
        return this;
    },

// consumes and returns one char from the input
input:function () {
        var ch = this._input[0];
        this.yytext += ch;
        this.yyleng++;
        this.offset++;
        this.match += ch;
        this.matched += ch;
        var lines = ch.match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno++;
            this.yylloc.last_line++;
        } else {
            this.yylloc.last_column++;
        }
        if (this.options.ranges) {
            this.yylloc.range[1]++;
        }

        this._input = this._input.slice(1);
        return ch;
    },

// unshifts one char (or a string) into the input
unput:function (ch) {
        var len = ch.length;
        var lines = ch.split(/(?:\r\n?|\n)/g);

        this._input = ch + this._input;
        this.yytext = this.yytext.substr(0, this.yytext.length - len);
        //this.yyleng -= len;
        this.offset -= len;
        var oldLines = this.match.split(/(?:\r\n?|\n)/g);
        this.match = this.match.substr(0, this.match.length - 1);
        this.matched = this.matched.substr(0, this.matched.length - 1);

        if (lines.length - 1) {
            this.yylineno -= lines.length - 1;
        }
        var r = this.yylloc.range;

        this.yylloc = {
            first_line: this.yylloc.first_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.first_column,
            last_column: lines ?
                (lines.length === oldLines.length ? this.yylloc.first_column : 0)
                 + oldLines[oldLines.length - lines.length].length - lines[0].length :
              this.yylloc.first_column - len
        };

        if (this.options.ranges) {
            this.yylloc.range = [r[0], r[0] + this.yyleng - len];
        }
        this.yyleng = this.yytext.length;
        return this;
    },

// When called from action, caches matched text and appends it on next action
more:function () {
        this._more = true;
        return this;
    },

// When called from action, signals the lexer that this rule fails to match the input, so the next matching rule (regex) should be tested instead.
reject:function () {
        if (this.options.backtrack_lexer) {
            this._backtrack = true;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. You can only invoke reject() in the lexer when the lexer is of the backtracking persuasion (options.backtrack_lexer = true).\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });

        }
        return this;
    },

// retain first n characters of the match
less:function (n) {
        this.unput(this.match.slice(n));
    },

// displays already matched input, i.e. for error messages
pastInput:function () {
        var past = this.matched.substr(0, this.matched.length - this.match.length);
        return (past.length > 20 ? '...':'') + past.substr(-20).replace(/\n/g, "");
    },

// displays upcoming input, i.e. for error messages
upcomingInput:function () {
        var next = this.match;
        if (next.length < 20) {
            next += this._input.substr(0, 20-next.length);
        }
        return (next.substr(0,20) + (next.length > 20 ? '...' : '')).replace(/\n/g, "");
    },

// displays the character position where the lexing error occurred, i.e. for error messages
showPosition:function () {
        var pre = this.pastInput();
        var c = new Array(pre.length + 1).join("-");
        return pre + this.upcomingInput() + "\n" + c + "^";
    },

// test the lexed token: return FALSE when not a match, otherwise return token
test_match:function (match, indexed_rule) {
        var token,
            lines,
            backup;

        if (this.options.backtrack_lexer) {
            // save context
            backup = {
                yylineno: this.yylineno,
                yylloc: {
                    first_line: this.yylloc.first_line,
                    last_line: this.last_line,
                    first_column: this.yylloc.first_column,
                    last_column: this.yylloc.last_column
                },
                yytext: this.yytext,
                match: this.match,
                matches: this.matches,
                matched: this.matched,
                yyleng: this.yyleng,
                offset: this.offset,
                _more: this._more,
                _input: this._input,
                yy: this.yy,
                conditionStack: this.conditionStack.slice(0),
                done: this.done
            };
            if (this.options.ranges) {
                backup.yylloc.range = this.yylloc.range.slice(0);
            }
        }

        lines = match[0].match(/(?:\r\n?|\n).*/g);
        if (lines) {
            this.yylineno += lines.length;
        }
        this.yylloc = {
            first_line: this.yylloc.last_line,
            last_line: this.yylineno + 1,
            first_column: this.yylloc.last_column,
            last_column: lines ?
                         lines[lines.length - 1].length - lines[lines.length - 1].match(/\r?\n?/)[0].length :
                         this.yylloc.last_column + match[0].length
        };
        this.yytext += match[0];
        this.match += match[0];
        this.matches = match;
        this.yyleng = this.yytext.length;
        if (this.options.ranges) {
            this.yylloc.range = [this.offset, this.offset += this.yyleng];
        }
        this._more = false;
        this._backtrack = false;
        this._input = this._input.slice(match[0].length);
        this.matched += match[0];
        token = this.performAction.call(this, this.yy, this, indexed_rule, this.conditionStack[this.conditionStack.length - 1]);
        if (this.done && this._input) {
            this.done = false;
        }
        if (token) {
            return token;
        } else if (this._backtrack) {
            // recover context
            for (var k in backup) {
                this[k] = backup[k];
            }
            return false; // rule action called reject() implying the next rule should be tested instead.
        }
        return false;
    },

// return next match in input
next:function () {
        if (this.done) {
            return this.EOF;
        }
        if (!this._input) {
            this.done = true;
        }

        var token,
            match,
            tempMatch,
            index;
        if (!this._more) {
            this.yytext = '';
            this.match = '';
        }
        var rules = this._currentRules();
        for (var i = 0; i < rules.length; i++) {
            tempMatch = this._input.match(this.rules[rules[i]]);
            if (tempMatch && (!match || tempMatch[0].length > match[0].length)) {
                match = tempMatch;
                index = i;
                if (this.options.backtrack_lexer) {
                    token = this.test_match(tempMatch, rules[i]);
                    if (token !== false) {
                        return token;
                    } else if (this._backtrack) {
                        match = false;
                        continue; // rule action called reject() implying a rule MISmatch.
                    } else {
                        // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
                        return false;
                    }
                } else if (!this.options.flex) {
                    break;
                }
            }
        }
        if (match) {
            token = this.test_match(match, rules[index]);
            if (token !== false) {
                return token;
            }
            // else: this is a lexer rule which consumes input without producing a token (e.g. whitespace)
            return false;
        }
        if (this._input === "") {
            return this.EOF;
        } else {
            return this.parseError('Lexical error on line ' + (this.yylineno + 1) + '. Unrecognized text.\n' + this.showPosition(), {
                text: "",
                token: null,
                line: this.yylineno
            });
        }
    },

// return next match that has a token
lex:function lex() {
        var r = this.next();
        if (r) {
            return r;
        } else {
            return this.lex();
        }
    },

// activates a new lexer condition state (pushes the new lexer condition state onto the condition stack)
begin:function begin(condition) {
        this.conditionStack.push(condition);
    },

// pop the previously active lexer condition state off the condition stack
popState:function popState() {
        var n = this.conditionStack.length - 1;
        if (n > 0) {
            return this.conditionStack.pop();
        } else {
            return this.conditionStack[0];
        }
    },

// produce the lexer rule set which is active for the currently active lexer condition state
_currentRules:function _currentRules() {
        if (this.conditionStack.length && this.conditionStack[this.conditionStack.length - 1]) {
            return this.conditions[this.conditionStack[this.conditionStack.length - 1]].rules;
        } else {
            return this.conditions["INITIAL"].rules;
        }
    },

// return the currently active lexer condition state; when an index argument is provided it produces the N-th previous condition state, if available
topState:function topState(n) {
        n = this.conditionStack.length - 1 - Math.abs(n || 0);
        if (n >= 0) {
            return this.conditionStack[n];
        } else {
            return "INITIAL";
        }
    },

// alias for begin(condition)
pushState:function pushState(condition) {
        this.begin(condition);
    },

// return the number of states currently on the stack
stateStackSize:function stateStackSize() {
        return this.conditionStack.length;
    },
options: {},
performAction: function anonymous(yy,yy_,$avoiding_name_collisions,YY_START) {
var YYSTATE=YY_START;
switch($avoiding_name_collisions) {
case 0: this.begin('notes'); return 22; 
break;
case 1: this.begin('stavegroup'); return 8; 
break;
case 2: this.begin('options'); return 10; 
break;
case 3: this.begin('text'); return 20; 
break;
case 4: this.begin('options'); return 24; 
break;
case 5: this.begin('options'); return 16; 
break;
case 6: this.begin('options'); return 17; 
break;
case 7: this.begin('options'); return 18; 
break;
case 8:return 25
break;
case 9: this.begin('annotations'); return "$" ;
break;
case 10: this.begin('notes'); return "$" 
break;
case 11:return 25
break;
case 12: this.begin('command'); return "!" 
break;
case 13: this.begin('notes'); return "!" 
break;
case 14:return 77
break;
case 15:return 27
break;
case 16:return 44
break;
case 17:return '+'
break;
case 18:return 41
break;
case 19:return 26
break;
case 20:return 48
break;
case 21:return 49
break;
case 22:return 34
break;
case 23:return 35
break;
case 24:return 73
break;
case 25:return 28
break;
case 26:return 40
break;
case 27:return 47
break;
case 28:return 78
break;
case 29:return 82
break;
case 30:return 68
break;
case 31:return 65
break;
case 32:return 60
break;
case 33:return 69
break;
case 34:return 66
break;
case 35:return 67
break;
case 36:return 64
break;
case 37:return 53
break;
case 38:return 70
break;
case 39:return 71
break;
case 40:return 72
break;
case 41:return 62
break;
case 42:return 51
break;
case 43:return 61
break;
case 44:return 59
break;
case 45:return 60
break;
case 46:return 62
break;
case 47:return 63
break;
case 48:return 79
break;
case 49:return 83
break;
case 50:return 84
break;
case 51: this.begin('INITIAL'); 
break;
case 52:/* skip whitespace */
break;
case 53:return 5
break;
case 54:return 'INVALID'
break;
}
},
rules: [/^(?:notes\b)/,/^(?:stavegroup\b)/,/^(?:options\b)/,/^(?:text\b)/,/^(?:slur\b)/,/^(?:tabstave\b)/,/^(?:stave\b)/,/^(?:voice\b)/,/^(?:[^\s=]+)/,/^(?:[$])/,/^(?:[$])/,/^(?:[^,$]+)/,/^(?:[!])/,/^(?:[!])/,/^(?:[^!]+)/,/^(?:[^,\r\n]+)/,/^(?:\/)/,/^(?:\+)/,/^(?::)/,/^(?:=)/,/^(?:\()/,/^(?:\))/,/^(?:\[)/,/^(?:\])/,/^(?:\^)/,/^(?:,)/,/^(?:\|)/,/^(?:\.)/,/^(?:#)/,/^(?:@)/,/^(?:[b])/,/^(?:[s])/,/^(?:[h])/,/^(?:[p])/,/^(?:[t])/,/^(?:[T])/,/^(?:[-])/,/^(?:[_])/,/^(?:[v])/,/^(?:[V])/,/^(?:[u])/,/^(?:[d])/,/^(?:[0-9]+)/,/^(?:[q])/,/^(?:[w])/,/^(?:[h])/,/^(?:[d])/,/^(?:[S])/,/^(?:[A-GXLR])/,/^(?:[n])/,/^(?:[~])/,/^(?:[\r\n]+)/,/^(?:\s+)/,/^(?:$)/,/^(?:.)/],
conditions: {"notes":{"rules":[9,12,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54],"inclusive":true},"text":{"rules":[15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,42,43,44,45,46,51,52,53,54],"inclusive":true},"slur":{"rules":[16,17,18,19,20,21,22,23,24,25,26,27,28,29,51,52,53,54],"inclusive":true},"annotations":{"rules":[10,11,16,17,18,19,20,21,22,23,24,25,26,27,28,29,51,52,53,54],"inclusive":true},"options":{"rules":[8,16,17,18,19,20,21,22,23,24,25,26,27,28,29,51,52,53,54],"inclusive":true},"command":{"rules":[13,14,16,17,18,19,20,21,22,23,24,25,26,27,28,29,51,52,53,54],"inclusive":true},"stavegroup":{"rules":[5,6,7,16,17,18,19,20,21,22,23,24,25,26,27,28,29,51,52,53,54],"inclusive":true},"INITIAL":{"rules":[0,1,2,3,4,5,6,7,8,16,17,18,19,20,21,22,23,24,25,26,27,28,29,51,52,53,54],"inclusive":true}}
});
return lexer;
})();
parser.lexer = lexer;
function Parser () {
  this.yy = {};
}
Parser.prototype = parser;parser.Parser = Parser;
return new Parser;
})();


if (typeof require !== 'undefined' && typeof exports !== 'undefined') {
exports.parser = parser;
exports.Parser = parser.Parser;
exports.parse = function () { return parser.parse.apply(parser, arguments); };
exports.main = function commonjsMain(args) {
    if (!args[1]) {
        console.log('Usage: '+args[0]+' FILE');
        process.exit(1);
    }
    var source = require('fs').readFileSync(require('path').normalize(args[1]), "utf8");
    return exports.parser.parse(source);
};
if (typeof module !== 'undefined' && require.main === module) {
  exports.main(process.argv.slice(1));
}
}
}).call(this,require('_process'))

},{"_process":4,"fs":3,"lodash":6,"path":8}],3:[function(require,module,exports){

},{}],4:[function(require,module,exports){
// shim for using process in browser

var process = module.exports = {};
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = setTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    clearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        setTimeout(drainQueue, 0);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };

},{}],5:[function(require,module,exports){
/*!
 * jQuery JavaScript Library v2.2.0
 * http://jquery.com/
 *
 * Includes Sizzle.js
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2016-01-08T20:02Z
 */

(function( global, factory ) {

	if ( typeof module === "object" && typeof module.exports === "object" ) {
		// For CommonJS and CommonJS-like environments where a proper `window`
		// is present, execute the factory and get jQuery.
		// For environments that do not have a `window` with a `document`
		// (such as Node.js), expose a factory as module.exports.
		// This accentuates the need for the creation of a real `window`.
		// e.g. var jQuery = require("jquery")(window);
		// See ticket #14549 for more info.
		module.exports = global.document ?
			factory( global, true ) :
			function( w ) {
				if ( !w.document ) {
					throw new Error( "jQuery requires a window with a document" );
				}
				return factory( w );
			};
	} else {
		factory( global );
	}

// Pass this if window is not defined yet
}(typeof window !== "undefined" ? window : this, function( window, noGlobal ) {

// Support: Firefox 18+
// Can't be in strict mode, several libs including ASP.NET trace
// the stack via arguments.caller.callee and Firefox dies if
// you try to trace through "use strict" call chains. (#13335)
//"use strict";
var arr = [];

var document = window.document;

var slice = arr.slice;

var concat = arr.concat;

var push = arr.push;

var indexOf = arr.indexOf;

var class2type = {};

var toString = class2type.toString;

var hasOwn = class2type.hasOwnProperty;

var support = {};



var
	version = "2.2.0",

	// Define a local copy of jQuery
	jQuery = function( selector, context ) {

		// The jQuery object is actually just the init constructor 'enhanced'
		// Need init if jQuery is called (just allow error to be thrown if not included)
		return new jQuery.fn.init( selector, context );
	},

	// Support: Android<4.1
	// Make sure we trim BOM and NBSP
	rtrim = /^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g,

	// Matches dashed string for camelizing
	rmsPrefix = /^-ms-/,
	rdashAlpha = /-([\da-z])/gi,

	// Used by jQuery.camelCase as callback to replace()
	fcamelCase = function( all, letter ) {
		return letter.toUpperCase();
	};

jQuery.fn = jQuery.prototype = {

	// The current version of jQuery being used
	jquery: version,

	constructor: jQuery,

	// Start with an empty selector
	selector: "",

	// The default length of a jQuery object is 0
	length: 0,

	toArray: function() {
		return slice.call( this );
	},

	// Get the Nth element in the matched element set OR
	// Get the whole matched element set as a clean array
	get: function( num ) {
		return num != null ?

			// Return just the one element from the set
			( num < 0 ? this[ num + this.length ] : this[ num ] ) :

			// Return all the elements in a clean array
			slice.call( this );
	},

	// Take an array of elements and push it onto the stack
	// (returning the new matched element set)
	pushStack: function( elems ) {

		// Build a new jQuery matched element set
		var ret = jQuery.merge( this.constructor(), elems );

		// Add the old object onto the stack (as a reference)
		ret.prevObject = this;
		ret.context = this.context;

		// Return the newly-formed element set
		return ret;
	},

	// Execute a callback for every element in the matched set.
	each: function( callback ) {
		return jQuery.each( this, callback );
	},

	map: function( callback ) {
		return this.pushStack( jQuery.map( this, function( elem, i ) {
			return callback.call( elem, i, elem );
		} ) );
	},

	slice: function() {
		return this.pushStack( slice.apply( this, arguments ) );
	},

	first: function() {
		return this.eq( 0 );
	},

	last: function() {
		return this.eq( -1 );
	},

	eq: function( i ) {
		var len = this.length,
			j = +i + ( i < 0 ? len : 0 );
		return this.pushStack( j >= 0 && j < len ? [ this[ j ] ] : [] );
	},

	end: function() {
		return this.prevObject || this.constructor();
	},

	// For internal use only.
	// Behaves like an Array's method, not like a jQuery method.
	push: push,
	sort: arr.sort,
	splice: arr.splice
};

jQuery.extend = jQuery.fn.extend = function() {
	var options, name, src, copy, copyIsArray, clone,
		target = arguments[ 0 ] || {},
		i = 1,
		length = arguments.length,
		deep = false;

	// Handle a deep copy situation
	if ( typeof target === "boolean" ) {
		deep = target;

		// Skip the boolean and the target
		target = arguments[ i ] || {};
		i++;
	}

	// Handle case when target is a string or something (possible in deep copy)
	if ( typeof target !== "object" && !jQuery.isFunction( target ) ) {
		target = {};
	}

	// Extend jQuery itself if only one argument is passed
	if ( i === length ) {
		target = this;
		i--;
	}

	for ( ; i < length; i++ ) {

		// Only deal with non-null/undefined values
		if ( ( options = arguments[ i ] ) != null ) {

			// Extend the base object
			for ( name in options ) {
				src = target[ name ];
				copy = options[ name ];

				// Prevent never-ending loop
				if ( target === copy ) {
					continue;
				}

				// Recurse if we're merging plain objects or arrays
				if ( deep && copy && ( jQuery.isPlainObject( copy ) ||
					( copyIsArray = jQuery.isArray( copy ) ) ) ) {

					if ( copyIsArray ) {
						copyIsArray = false;
						clone = src && jQuery.isArray( src ) ? src : [];

					} else {
						clone = src && jQuery.isPlainObject( src ) ? src : {};
					}

					// Never move original objects, clone them
					target[ name ] = jQuery.extend( deep, clone, copy );

				// Don't bring in undefined values
				} else if ( copy !== undefined ) {
					target[ name ] = copy;
				}
			}
		}
	}

	// Return the modified object
	return target;
};

jQuery.extend( {

	// Unique for each copy of jQuery on the page
	expando: "jQuery" + ( version + Math.random() ).replace( /\D/g, "" ),

	// Assume jQuery is ready without the ready module
	isReady: true,

	error: function( msg ) {
		throw new Error( msg );
	},

	noop: function() {},

	isFunction: function( obj ) {
		return jQuery.type( obj ) === "function";
	},

	isArray: Array.isArray,

	isWindow: function( obj ) {
		return obj != null && obj === obj.window;
	},

	isNumeric: function( obj ) {

		// parseFloat NaNs numeric-cast false positives (null|true|false|"")
		// ...but misinterprets leading-number strings, particularly hex literals ("0x...")
		// subtraction forces infinities to NaN
		// adding 1 corrects loss of precision from parseFloat (#15100)
		var realStringObj = obj && obj.toString();
		return !jQuery.isArray( obj ) && ( realStringObj - parseFloat( realStringObj ) + 1 ) >= 0;
	},

	isPlainObject: function( obj ) {

		// Not plain objects:
		// - Any object or value whose internal [[Class]] property is not "[object Object]"
		// - DOM nodes
		// - window
		if ( jQuery.type( obj ) !== "object" || obj.nodeType || jQuery.isWindow( obj ) ) {
			return false;
		}

		if ( obj.constructor &&
				!hasOwn.call( obj.constructor.prototype, "isPrototypeOf" ) ) {
			return false;
		}

		// If the function hasn't returned already, we're confident that
		// |obj| is a plain object, created by {} or constructed with new Object
		return true;
	},

	isEmptyObject: function( obj ) {
		var name;
		for ( name in obj ) {
			return false;
		}
		return true;
	},

	type: function( obj ) {
		if ( obj == null ) {
			return obj + "";
		}

		// Support: Android<4.0, iOS<6 (functionish RegExp)
		return typeof obj === "object" || typeof obj === "function" ?
			class2type[ toString.call( obj ) ] || "object" :
			typeof obj;
	},

	// Evaluates a script in a global context
	globalEval: function( code ) {
		var script,
			indirect = eval;

		code = jQuery.trim( code );

		if ( code ) {

			// If the code includes a valid, prologue position
			// strict mode pragma, execute code by injecting a
			// script tag into the document.
			if ( code.indexOf( "use strict" ) === 1 ) {
				script = document.createElement( "script" );
				script.text = code;
				document.head.appendChild( script ).parentNode.removeChild( script );
			} else {

				// Otherwise, avoid the DOM node creation, insertion
				// and removal by using an indirect global eval

				indirect( code );
			}
		}
	},

	// Convert dashed to camelCase; used by the css and data modules
	// Support: IE9-11+
	// Microsoft forgot to hump their vendor prefix (#9572)
	camelCase: function( string ) {
		return string.replace( rmsPrefix, "ms-" ).replace( rdashAlpha, fcamelCase );
	},

	nodeName: function( elem, name ) {
		return elem.nodeName && elem.nodeName.toLowerCase() === name.toLowerCase();
	},

	each: function( obj, callback ) {
		var length, i = 0;

		if ( isArrayLike( obj ) ) {
			length = obj.length;
			for ( ; i < length; i++ ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		} else {
			for ( i in obj ) {
				if ( callback.call( obj[ i ], i, obj[ i ] ) === false ) {
					break;
				}
			}
		}

		return obj;
	},

	// Support: Android<4.1
	trim: function( text ) {
		return text == null ?
			"" :
			( text + "" ).replace( rtrim, "" );
	},

	// results is for internal usage only
	makeArray: function( arr, results ) {
		var ret = results || [];

		if ( arr != null ) {
			if ( isArrayLike( Object( arr ) ) ) {
				jQuery.merge( ret,
					typeof arr === "string" ?
					[ arr ] : arr
				);
			} else {
				push.call( ret, arr );
			}
		}

		return ret;
	},

	inArray: function( elem, arr, i ) {
		return arr == null ? -1 : indexOf.call( arr, elem, i );
	},

	merge: function( first, second ) {
		var len = +second.length,
			j = 0,
			i = first.length;

		for ( ; j < len; j++ ) {
			first[ i++ ] = second[ j ];
		}

		first.length = i;

		return first;
	},

	grep: function( elems, callback, invert ) {
		var callbackInverse,
			matches = [],
			i = 0,
			length = elems.length,
			callbackExpect = !invert;

		// Go through the array, only saving the items
		// that pass the validator function
		for ( ; i < length; i++ ) {
			callbackInverse = !callback( elems[ i ], i );
			if ( callbackInverse !== callbackExpect ) {
				matches.push( elems[ i ] );
			}
		}

		return matches;
	},

	// arg is for internal usage only
	map: function( elems, callback, arg ) {
		var length, value,
			i = 0,
			ret = [];

		// Go through the array, translating each of the items to their new values
		if ( isArrayLike( elems ) ) {
			length = elems.length;
			for ( ; i < length; i++ ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}

		// Go through every key on the object,
		} else {
			for ( i in elems ) {
				value = callback( elems[ i ], i, arg );

				if ( value != null ) {
					ret.push( value );
				}
			}
		}

		// Flatten any nested arrays
		return concat.apply( [], ret );
	},

	// A global GUID counter for objects
	guid: 1,

	// Bind a function to a context, optionally partially applying any
	// arguments.
	proxy: function( fn, context ) {
		var tmp, args, proxy;

		if ( typeof context === "string" ) {
			tmp = fn[ context ];
			context = fn;
			fn = tmp;
		}

		// Quick check to determine if target is callable, in the spec
		// this throws a TypeError, but we will just return undefined.
		if ( !jQuery.isFunction( fn ) ) {
			return undefined;
		}

		// Simulated bind
		args = slice.call( arguments, 2 );
		proxy = function() {
			return fn.apply( context || this, args.concat( slice.call( arguments ) ) );
		};

		// Set the guid of unique handler to the same of original handler, so it can be removed
		proxy.guid = fn.guid = fn.guid || jQuery.guid++;

		return proxy;
	},

	now: Date.now,

	// jQuery.support is not used in Core but other projects attach their
	// properties to it so it needs to exist.
	support: support
} );

// JSHint would error on this code due to the Symbol not being defined in ES5.
// Defining this global in .jshintrc would create a danger of using the global
// unguarded in another place, it seems safer to just disable JSHint for these
// three lines.
/* jshint ignore: start */
if ( typeof Symbol === "function" ) {
	jQuery.fn[ Symbol.iterator ] = arr[ Symbol.iterator ];
}
/* jshint ignore: end */

// Populate the class2type map
jQuery.each( "Boolean Number String Function Array Date RegExp Object Error Symbol".split( " " ),
function( i, name ) {
	class2type[ "[object " + name + "]" ] = name.toLowerCase();
} );

function isArrayLike( obj ) {

	// Support: iOS 8.2 (not reproducible in simulator)
	// `in` check used to prevent JIT error (gh-2145)
	// hasOwn isn't used here due to false negatives
	// regarding Nodelist length in IE
	var length = !!obj && "length" in obj && obj.length,
		type = jQuery.type( obj );

	if ( type === "function" || jQuery.isWindow( obj ) ) {
		return false;
	}

	return type === "array" || length === 0 ||
		typeof length === "number" && length > 0 && ( length - 1 ) in obj;
}
var Sizzle =
/*!
 * Sizzle CSS Selector Engine v2.2.1
 * http://sizzlejs.com/
 *
 * Copyright jQuery Foundation and other contributors
 * Released under the MIT license
 * http://jquery.org/license
 *
 * Date: 2015-10-17
 */
(function( window ) {

var i,
	support,
	Expr,
	getText,
	isXML,
	tokenize,
	compile,
	select,
	outermostContext,
	sortInput,
	hasDuplicate,

	// Local document vars
	setDocument,
	document,
	docElem,
	documentIsHTML,
	rbuggyQSA,
	rbuggyMatches,
	matches,
	contains,

	// Instance-specific data
	expando = "sizzle" + 1 * new Date(),
	preferredDoc = window.document,
	dirruns = 0,
	done = 0,
	classCache = createCache(),
	tokenCache = createCache(),
	compilerCache = createCache(),
	sortOrder = function( a, b ) {
		if ( a === b ) {
			hasDuplicate = true;
		}
		return 0;
	},

	// General-purpose constants
	MAX_NEGATIVE = 1 << 31,

	// Instance methods
	hasOwn = ({}).hasOwnProperty,
	arr = [],
	pop = arr.pop,
	push_native = arr.push,
	push = arr.push,
	slice = arr.slice,
	// Use a stripped-down indexOf as it's faster than native
	// http://jsperf.com/thor-indexof-vs-for/5
	indexOf = function( list, elem ) {
		var i = 0,
			len = list.length;
		for ( ; i < len; i++ ) {
			if ( list[i] === elem ) {
				return i;
			}
		}
		return -1;
	},

	booleans = "checked|selected|async|autofocus|autoplay|controls|defer|disabled|hidden|ismap|loop|multiple|open|readonly|required|scoped",

	// Regular expressions

	// http://www.w3.org/TR/css3-selectors/#whitespace
	whitespace = "[\\x20\\t\\r\\n\\f]",

	// http://www.w3.org/TR/CSS21/syndata.html#value-def-identifier
	identifier = "(?:\\\\.|[\\w-]|[^\\x00-\\xa0])+",

	// Attribute selectors: http://www.w3.org/TR/selectors/#attribute-selectors
	attributes = "\\[" + whitespace + "*(" + identifier + ")(?:" + whitespace +
		// Operator (capture 2)
		"*([*^$|!~]?=)" + whitespace +
		// "Attribute values must be CSS identifiers [capture 5] or strings [capture 3 or capture 4]"
		"*(?:'((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\"|(" + identifier + "))|)" + whitespace +
		"*\\]",

	pseudos = ":(" + identifier + ")(?:\\((" +
		// To reduce the number of selectors needing tokenize in the preFilter, prefer arguments:
		// 1. quoted (capture 3; capture 4 or capture 5)
		"('((?:\\\\.|[^\\\\'])*)'|\"((?:\\\\.|[^\\\\\"])*)\")|" +
		// 2. simple (capture 6)
		"((?:\\\\.|[^\\\\()[\\]]|" + attributes + ")*)|" +
		// 3. anything else (capture 2)
		".*" +
		")\\)|)",

	// Leading and non-escaped trailing whitespace, capturing some non-whitespace characters preceding the latter
	rwhitespace = new RegExp( whitespace + "+", "g" ),
	rtrim = new RegExp( "^" + whitespace + "+|((?:^|[^\\\\])(?:\\\\.)*)" + whitespace + "+$", "g" ),

	rcomma = new RegExp( "^" + whitespace + "*," + whitespace + "*" ),
	rcombinators = new RegExp( "^" + whitespace + "*([>+~]|" + whitespace + ")" + whitespace + "*" ),

	rattributeQuotes = new RegExp( "=" + whitespace + "*([^\\]'\"]*?)" + whitespace + "*\\]", "g" ),

	rpseudo = new RegExp( pseudos ),
	ridentifier = new RegExp( "^" + identifier + "$" ),

	matchExpr = {
		"ID": new RegExp( "^#(" + identifier + ")" ),
		"CLASS": new RegExp( "^\\.(" + identifier + ")" ),
		"TAG": new RegExp( "^(" + identifier + "|[*])" ),
		"ATTR": new RegExp( "^" + attributes ),
		"PSEUDO": new RegExp( "^" + pseudos ),
		"CHILD": new RegExp( "^:(only|first|last|nth|nth-last)-(child|of-type)(?:\\(" + whitespace +
			"*(even|odd|(([+-]|)(\\d*)n|)" + whitespace + "*(?:([+-]|)" + whitespace +
			"*(\\d+)|))" + whitespace + "*\\)|)", "i" ),
		"bool": new RegExp( "^(?:" + booleans + ")$", "i" ),
		// For use in libraries implementing .is()
		// We use this for POS matching in `select`
		"needsContext": new RegExp( "^" + whitespace + "*[>+~]|:(even|odd|eq|gt|lt|nth|first|last)(?:\\(" +
			whitespace + "*((?:-\\d)?\\d*)" + whitespace + "*\\)|)(?=[^-]|$)", "i" )
	},

	rinputs = /^(?:input|select|textarea|button)$/i,
	rheader = /^h\d$/i,

	rnative = /^[^{]+\{\s*\[native \w/,

	// Easily-parseable/retrievable ID or TAG or CLASS selectors
	rquickExpr = /^(?:#([\w-]+)|(\w+)|\.([\w-]+))$/,

	rsibling = /[+~]/,
	rescape = /'|\\/g,

	// CSS escapes http://www.w3.org/TR/CSS21/syndata.html#escaped-characters
	runescape = new RegExp( "\\\\([\\da-f]{1,6}" + whitespace + "?|(" + whitespace + ")|.)", "ig" ),
	funescape = function( _, escaped, escapedWhitespace ) {
		var high = "0x" + escaped - 0x10000;
		// NaN means non-codepoint
		// Support: Firefox<24
		// Workaround erroneous numeric interpretation of +"0x"
		return high !== high || escapedWhitespace ?
			escaped :
			high < 0 ?
				// BMP codepoint
				String.fromCharCode( high + 0x10000 ) :
				// Supplemental Plane codepoint (surrogate pair)
				String.fromCharCode( high >> 10 | 0xD800, high & 0x3FF | 0xDC00 );
	},

	// Used for iframes
	// See setDocument()
	// Removing the function wrapper causes a "Permission Denied"
	// error in IE
	unloadHandler = function() {
		setDocument();
	};

// Optimize for push.apply( _, NodeList )
try {
	push.apply(
		(arr = slice.call( preferredDoc.childNodes )),
		preferredDoc.childNodes
	);
	// Support: Android<4.0
	// Detect silently failing push.apply
	arr[ preferredDoc.childNodes.length ].nodeType;
} catch ( e ) {
	push = { apply: arr.length ?

		// Leverage slice if possible
		function( target, els ) {
			push_native.apply( target, slice.call(els) );
		} :

		// Support: IE<9
		// Otherwise append directly
		function( target, els ) {
			var j = target.length,
				i = 0;
			// Can't trust NodeList.length
			while ( (target[j++] = els[i++]) ) {}
			target.length = j - 1;
		}
	};
}

function Sizzle( selector, context, results, seed ) {
	var m, i, elem, nid, nidselect, match, groups, newSelector,
		newContext = context && context.ownerDocument,

		// nodeType defaults to 9, since context defaults to document
		nodeType = context ? context.nodeType : 9;

	results = results || [];

	// Return early from calls with invalid selector or context
	if ( typeof selector !== "string" || !selector ||
		nodeType !== 1 && nodeType !== 9 && nodeType !== 11 ) {

		return results;
	}

	// Try to shortcut find operations (as opposed to filters) in HTML documents
	if ( !seed ) {

		if ( ( context ? context.ownerDocument || context : preferredDoc ) !== document ) {
			setDocument( context );
		}
		context = context || document;

		if ( documentIsHTML ) {

			// If the selector is sufficiently simple, try using a "get*By*" DOM method
			// (excepting DocumentFragment context, where the methods don't exist)
			if ( nodeType !== 11 && (match = rquickExpr.exec( selector )) ) {

				// ID selector
				if ( (m = match[1]) ) {

					// Document context
					if ( nodeType === 9 ) {
						if ( (elem = context.getElementById( m )) ) {

							// Support: IE, Opera, Webkit
							// TODO: identify versions
							// getElementById can match elements by name instead of ID
							if ( elem.id === m ) {
								results.push( elem );
								return results;
							}
						} else {
							return results;
						}

					// Element context
					} else {

						// Support: IE, Opera, Webkit
						// TODO: identify versions
						// getElementById can match elements by name instead of ID
						if ( newContext && (elem = newContext.getElementById( m )) &&
							contains( context, elem ) &&
							elem.id === m ) {

							results.push( elem );
							return results;
						}
					}

				// Type selector
				} else if ( match[2] ) {
					push.apply( results, context.getElementsByTagName( selector ) );
					return results;

				// Class selector
				} else if ( (m = match[3]) && support.getElementsByClassName &&
					context.getElementsByClassName ) {

					push.apply( results, context.getElementsByClassName( m ) );
					return results;
				}
			}

			// Take advantage of querySelectorAll
			if ( support.qsa &&
				!compilerCache[ selector + " " ] &&
				(!rbuggyQSA || !rbuggyQSA.test( selector )) ) {

				if ( nodeType !== 1 ) {
					newContext = context;
					newSelector = selector;

				// qSA looks outside Element context, which is not what we want
				// Thanks to Andrew Dupont for this workaround technique
				// Support: IE <=8
				// Exclude object elements
				} else if ( context.nodeName.toLowerCase() !== "object" ) {

					// Capture the context ID, setting it first if necessary
					if ( (nid = context.getAttribute( "id" )) ) {
						nid = nid.replace( rescape, "\\$&" );
					} else {
						context.setAttribute( "id", (nid = expando) );
					}

					// Prefix every selector in the list
					groups = tokenize( selector );
					i = groups.length;
					nidselect = ridentifier.test( nid ) ? "#" + nid : "[id='" + nid + "']";
					while ( i-- ) {
						groups[i] = nidselect + " " + toSelector( groups[i] );
					}
					newSelector = groups.join( "," );

					// Expand context for sibling selectors
					newContext = rsibling.test( selector ) && testContext( context.parentNode ) ||
						context;
				}

				if ( newSelector ) {
					try {
						push.apply( results,
							newContext.querySelectorAll( newSelector )
						);
						return results;
					} catch ( qsaError ) {
					} finally {
						if ( nid === expando ) {
							context.removeAttribute( "id" );
						}
					}
				}
			}
		}
	}

	// All others
	return select( selector.replace( rtrim, "$1" ), context, results, seed );
}

/**
 * Create key-value caches of limited size
 * @returns {function(string, object)} Returns the Object data after storing it on itself with
 *	property name the (space-suffixed) string and (if the cache is larger than Expr.cacheLength)
 *	deleting the oldest entry
 */
function createCache() {
	var keys = [];

	function cache( key, value ) {
		// Use (key + " ") to avoid collision with native prototype properties (see Issue #157)
		if ( keys.push( key + " " ) > Expr.cacheLength ) {
			// Only keep the most recent entries
			delete cache[ keys.shift() ];
		}
		return (cache[ key + " " ] = value);
	}
	return cache;
}

/**
 * Mark a function for special use by Sizzle
 * @param {Function} fn The function to mark
 */
function markFunction( fn ) {
	fn[ expando ] = true;
	return fn;
}

/**
 * Support testing using an element
 * @param {Function} fn Passed the created div and expects a boolean result
 */
function assert( fn ) {
	var div = document.createElement("div");

	try {
		return !!fn( div );
	} catch (e) {
		return false;
	} finally {
		// Remove from its parent by default
		if ( div.parentNode ) {
			div.parentNode.removeChild( div );
		}
		// release memory in IE
		div = null;
	}
}

/**
 * Adds the same handler for all of the specified attrs
 * @param {String} attrs Pipe-separated list of attributes
 * @param {Function} handler The method that will be applied
 */
function addHandle( attrs, handler ) {
	var arr = attrs.split("|"),
		i = arr.length;

	while ( i-- ) {
		Expr.attrHandle[ arr[i] ] = handler;
	}
}

/**
 * Checks document order of two siblings
 * @param {Element} a
 * @param {Element} b
 * @returns {Number} Returns less than 0 if a precedes b, greater than 0 if a follows b
 */
function siblingCheck( a, b ) {
	var cur = b && a,
		diff = cur && a.nodeType === 1 && b.nodeType === 1 &&
			( ~b.sourceIndex || MAX_NEGATIVE ) -
			( ~a.sourceIndex || MAX_NEGATIVE );

	// Use IE sourceIndex if available on both nodes
	if ( diff ) {
		return diff;
	}

	// Check if b follows a
	if ( cur ) {
		while ( (cur = cur.nextSibling) ) {
			if ( cur === b ) {
				return -1;
			}
		}
	}

	return a ? 1 : -1;
}

/**
 * Returns a function to use in pseudos for input types
 * @param {String} type
 */
function createInputPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return name === "input" && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for buttons
 * @param {String} type
 */
function createButtonPseudo( type ) {
	return function( elem ) {
		var name = elem.nodeName.toLowerCase();
		return (name === "input" || name === "button") && elem.type === type;
	};
}

/**
 * Returns a function to use in pseudos for positionals
 * @param {Function} fn
 */
function createPositionalPseudo( fn ) {
	return markFunction(function( argument ) {
		argument = +argument;
		return markFunction(function( seed, matches ) {
			var j,
				matchIndexes = fn( [], seed.length, argument ),
				i = matchIndexes.length;

			// Match elements found at the specified indexes
			while ( i-- ) {
				if ( seed[ (j = matchIndexes[i]) ] ) {
					seed[j] = !(matches[j] = seed[j]);
				}
			}
		});
	});
}

/**
 * Checks a node for validity as a Sizzle context
 * @param {Element|Object=} context
 * @returns {Element|Object|Boolean} The input node if acceptable, otherwise a falsy value
 */
function testContext( context ) {
	return context && typeof context.getElementsByTagName !== "undefined" && context;
}

// Expose support vars for convenience
support = Sizzle.support = {};

/**
 * Detects XML nodes
 * @param {Element|Object} elem An element or a document
 * @returns {Boolean} True iff elem is a non-HTML XML node
 */
isXML = Sizzle.isXML = function( elem ) {
	// documentElement is verified for cases where it doesn't yet exist
	// (such as loading iframes in IE - #4833)
	var documentElement = elem && (elem.ownerDocument || elem).documentElement;
	return documentElement ? documentElement.nodeName !== "HTML" : false;
};

/**
 * Sets document-related variables once based on the current document
 * @param {Element|Object} [doc] An element or document object to use to set the document
 * @returns {Object} Returns the current document
 */
setDocument = Sizzle.setDocument = function( node ) {
	var hasCompare, parent,
		doc = node ? node.ownerDocument || node : preferredDoc;

	// Return early if doc is invalid or already selected
	if ( doc === document || doc.nodeType !== 9 || !doc.documentElement ) {
		return document;
	}

	// Update global variables
	document = doc;
	docElem = document.documentElement;
	documentIsHTML = !isXML( document );

	// Support: IE 9-11, Edge
	// Accessing iframe documents after unload throws "permission denied" errors (jQuery #13936)
	if ( (parent = document.defaultView) && parent.top !== parent ) {
		// Support: IE 11
		if ( parent.addEventListener ) {
			parent.addEventListener( "unload", unloadHandler, false );

		// Support: IE 9 - 10 only
		} else if ( parent.attachEvent ) {
			parent.attachEvent( "onunload", unloadHandler );
		}
	}

	/* Attributes
	---------------------------------------------------------------------- */

	// Support: IE<8
	// Verify that getAttribute really returns attributes and not properties
	// (excepting IE8 booleans)
	support.attributes = assert(function( div ) {
		div.className = "i";
		return !div.getAttribute("className");
	});

	/* getElement(s)By*
	---------------------------------------------------------------------- */

	// Check if getElementsByTagName("*") returns only elements
	support.getElementsByTagName = assert(function( div ) {
		div.appendChild( document.createComment("") );
		return !div.getElementsByTagName("*").length;
	});

	// Support: IE<9
	support.getElementsByClassName = rnative.test( document.getElementsByClassName );

	// Support: IE<10
	// Check if getElementById returns elements by name
	// The broken getElementById methods don't pick up programatically-set names,
	// so use a roundabout getElementsByName test
	support.getById = assert(function( div ) {
		docElem.appendChild( div ).id = expando;
		return !document.getElementsByName || !document.getElementsByName( expando ).length;
	});

	// ID find and filter
	if ( support.getById ) {
		Expr.find["ID"] = function( id, context ) {
			if ( typeof context.getElementById !== "undefined" && documentIsHTML ) {
				var m = context.getElementById( id );
				return m ? [ m ] : [];
			}
		};
		Expr.filter["ID"] = function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				return elem.getAttribute("id") === attrId;
			};
		};
	} else {
		// Support: IE6/7
		// getElementById is not reliable as a find shortcut
		delete Expr.find["ID"];

		Expr.filter["ID"] =  function( id ) {
			var attrId = id.replace( runescape, funescape );
			return function( elem ) {
				var node = typeof elem.getAttributeNode !== "undefined" &&
					elem.getAttributeNode("id");
				return node && node.value === attrId;
			};
		};
	}

	// Tag
	Expr.find["TAG"] = support.getElementsByTagName ?
		function( tag, context ) {
			if ( typeof context.getElementsByTagName !== "undefined" ) {
				return context.getElementsByTagName( tag );

			// DocumentFragment nodes don't have gEBTN
			} else if ( support.qsa ) {
				return context.querySelectorAll( tag );
			}
		} :

		function( tag, context ) {
			var elem,
				tmp = [],
				i = 0,
				// By happy coincidence, a (broken) gEBTN appears on DocumentFragment nodes too
				results = context.getElementsByTagName( tag );

			// Filter out possible comments
			if ( tag === "*" ) {
				while ( (elem = results[i++]) ) {
					if ( elem.nodeType === 1 ) {
						tmp.push( elem );
					}
				}

				return tmp;
			}
			return results;
		};

	// Class
	Expr.find["CLASS"] = support.getElementsByClassName && function( className, context ) {
		if ( typeof context.getElementsByClassName !== "undefined" && documentIsHTML ) {
			return context.getElementsByClassName( className );
		}
	};

	/* QSA/matchesSelector
	---------------------------------------------------------------------- */

	// QSA and matchesSelector support

	// matchesSelector(:active) reports false when true (IE9/Opera 11.5)
	rbuggyMatches = [];

	// qSa(:focus) reports false when true (Chrome 21)
	// We allow this because of a bug in IE8/9 that throws an error
	// whenever `document.activeElement` is accessed on an iframe
	// So, we allow :focus to pass through QSA all the time to avoid the IE error
	// See http://bugs.jquery.com/ticket/13378
	rbuggyQSA = [];

	if ( (support.qsa = rnative.test( document.querySelectorAll )) ) {
		// Build QSA regex
		// Regex strategy adopted from Diego Perini
		assert(function( div ) {
			// Select is set to empty string on purpose
			// This is to test IE's treatment of not explicitly
			// setting a boolean content attribute,
			// since its presence should be enough
			// http://bugs.jquery.com/ticket/12359
			docElem.appendChild( div ).innerHTML = "<a id='" + expando + "'></a>" +
				"<select id='" + expando + "-\r\\' msallowcapture=''>" +
				"<option selected=''></option></select>";

			// Support: IE8, Opera 11-12.16
			// Nothing should be selected when empty strings follow ^= or $= or *=
			// The test attribute must be unknown in Opera but "safe" for WinRT
			// http://msdn.microsoft.com/en-us/library/ie/hh465388.aspx#attribute_section
			if ( div.querySelectorAll("[msallowcapture^='']").length ) {
				rbuggyQSA.push( "[*^$]=" + whitespace + "*(?:''|\"\")" );
			}

			// Support: IE8
			// Boolean attributes and "value" are not treated correctly
			if ( !div.querySelectorAll("[selected]").length ) {
				rbuggyQSA.push( "\\[" + whitespace + "*(?:value|" + booleans + ")" );
			}

			// Support: Chrome<29, Android<4.4, Safari<7.0+, iOS<7.0+, PhantomJS<1.9.8+
			if ( !div.querySelectorAll( "[id~=" + expando + "-]" ).length ) {
				rbuggyQSA.push("~=");
			}

			// Webkit/Opera - :checked should return selected option elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":checked").length ) {
				rbuggyQSA.push(":checked");
			}

			// Support: Safari 8+, iOS 8+
			// https://bugs.webkit.org/show_bug.cgi?id=136851
			// In-page `selector#id sibing-combinator selector` fails
			if ( !div.querySelectorAll( "a#" + expando + "+*" ).length ) {
				rbuggyQSA.push(".#.+[+~]");
			}
		});

		assert(function( div ) {
			// Support: Windows 8 Native Apps
			// The type and name attributes are restricted during .innerHTML assignment
			var input = document.createElement("input");
			input.setAttribute( "type", "hidden" );
			div.appendChild( input ).setAttribute( "name", "D" );

			// Support: IE8
			// Enforce case-sensitivity of name attribute
			if ( div.querySelectorAll("[name=d]").length ) {
				rbuggyQSA.push( "name" + whitespace + "*[*^$|!~]?=" );
			}

			// FF 3.5 - :enabled/:disabled and hidden elements (hidden elements are still enabled)
			// IE8 throws error here and will not see later tests
			if ( !div.querySelectorAll(":enabled").length ) {
				rbuggyQSA.push( ":enabled", ":disabled" );
			}

			// Opera 10-11 does not throw on post-comma invalid pseudos
			div.querySelectorAll("*,:x");
			rbuggyQSA.push(",.*:");
		});
	}

	if ( (support.matchesSelector = rnative.test( (matches = docElem.matches ||
		docElem.webkitMatchesSelector ||
		docElem.mozMatchesSelector ||
		docElem.oMatchesSelector ||
		docElem.msMatchesSelector) )) ) {

		assert(function( div ) {
			// Check to see if it's possible to do matchesSelector
			// on a disconnected node (IE 9)
			support.disconnectedMatch = matches.call( div, "div" );

			// This should fail with an exception
			// Gecko does not error, returns false instead
			matches.call( div, "[s!='']:x" );
			rbuggyMatches.push( "!=", pseudos );
		});
	}

	rbuggyQSA = rbuggyQSA.length && new RegExp( rbuggyQSA.join("|") );
	rbuggyMatches = rbuggyMatches.length && new RegExp( rbuggyMatches.join("|") );

	/* Contains
	---------------------------------------------------------------------- */
	hasCompare = rnative.test( docElem.compareDocumentPosition );

	// Element contains another
	// Purposefully self-exclusive
	// As in, an element does not contain itself
	contains = hasCompare || rnative.test( docElem.contains ) ?
		function( a, b ) {
			var adown = a.nodeType === 9 ? a.documentElement : a,
				bup = b && b.parentNode;
			return a === bup || !!( bup && bup.nodeType === 1 && (
				adown.contains ?
					adown.contains( bup ) :
					a.compareDocumentPosition && a.compareDocumentPosition( bup ) & 16
			));
		} :
		function( a, b ) {
			if ( b ) {
				while ( (b = b.parentNode) ) {
					if ( b === a ) {
						return true;
					}
				}
			}
			return false;
		};

	/* Sorting
	---------------------------------------------------------------------- */

	// Document order sorting
	sortOrder = hasCompare ?
	function( a, b ) {

		// Flag for duplicate removal
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		// Sort on method existence if only one input has compareDocumentPosition
		var compare = !a.compareDocumentPosition - !b.compareDocumentPosition;
		if ( compare ) {
			return compare;
		}

		// Calculate position if both inputs belong to the same document
		compare = ( a.ownerDocument || a ) === ( b.ownerDocument || b ) ?
			a.compareDocumentPosition( b ) :

			// Otherwise we know they are disconnected
			1;

		// Disconnected nodes
		if ( compare & 1 ||
			(!support.sortDetached && b.compareDocumentPosition( a ) === compare) ) {

			// Choose the first element that is related to our preferred document
			if ( a === document || a.ownerDocument === preferredDoc && contains(preferredDoc, a) ) {
				return -1;
			}
			if ( b === document || b.ownerDocument === preferredDoc && contains(preferredDoc, b) ) {
				return 1;
			}

			// Maintain original order
			return sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;
		}

		return compare & 4 ? -1 : 1;
	} :
	function( a, b ) {
		// Exit early if the nodes are identical
		if ( a === b ) {
			hasDuplicate = true;
			return 0;
		}

		var cur,
			i = 0,
			aup = a.parentNode,
			bup = b.parentNode,
			ap = [ a ],
			bp = [ b ];

		// Parentless nodes are either documents or disconnected
		if ( !aup || !bup ) {
			return a === document ? -1 :
				b === document ? 1 :
				aup ? -1 :
				bup ? 1 :
				sortInput ?
				( indexOf( sortInput, a ) - indexOf( sortInput, b ) ) :
				0;

		// If the nodes are siblings, we can do a quick check
		} else if ( aup === bup ) {
			return siblingCheck( a, b );
		}

		// Otherwise we need full lists of their ancestors for comparison
		cur = a;
		while ( (cur = cur.parentNode) ) {
			ap.unshift( cur );
		}
		cur = b;
		while ( (cur = cur.parentNode) ) {
			bp.unshift( cur );
		}

		// Walk down the tree looking for a discrepancy
		while ( ap[i] === bp[i] ) {
			i++;
		}

		return i ?
			// Do a sibling check if the nodes have a common ancestor
			siblingCheck( ap[i], bp[i] ) :

			// Otherwise nodes in our document sort first
			ap[i] === preferredDoc ? -1 :
			bp[i] === preferredDoc ? 1 :
			0;
	};

	return document;
};

Sizzle.matches = function( expr, elements ) {
	return Sizzle( expr, null, null, elements );
};

Sizzle.matchesSelector = function( elem, expr ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	// Make sure that attribute selectors are quoted
	expr = expr.replace( rattributeQuotes, "='$1']" );

	if ( support.matchesSelector && documentIsHTML &&
		!compilerCache[ expr + " " ] &&
		( !rbuggyMatches || !rbuggyMatches.test( expr ) ) &&
		( !rbuggyQSA     || !rbuggyQSA.test( expr ) ) ) {

		try {
			var ret = matches.call( elem, expr );

			// IE 9's matchesSelector returns false on disconnected nodes
			if ( ret || support.disconnectedMatch ||
					// As well, disconnected nodes are said to be in a document
					// fragment in IE 9
					elem.document && elem.document.nodeType !== 11 ) {
				return ret;
			}
		} catch (e) {}
	}

	return Sizzle( expr, document, null, [ elem ] ).length > 0;
};

Sizzle.contains = function( context, elem ) {
	// Set document vars if needed
	if ( ( context.ownerDocument || context ) !== document ) {
		setDocument( context );
	}
	return contains( context, elem );
};

Sizzle.attr = function( elem, name ) {
	// Set document vars if needed
	if ( ( elem.ownerDocument || elem ) !== document ) {
		setDocument( elem );
	}

	var fn = Expr.attrHandle[ name.toLowerCase() ],
		// Don't get fooled by Object.prototype properties (jQuery #13807)
		val = fn && hasOwn.call( Expr.attrHandle, name.toLowerCase() ) ?
			fn( elem, name, !documentIsHTML ) :
			undefined;

	return val !== undefined ?
		val :
		support.attributes || !documentIsHTML ?
			elem.getAttribute( name ) :
			(val = elem.getAttributeNode(name)) && val.specified ?
				val.value :
				null;
};

Sizzle.error = function( msg ) {
	throw new Error( "Syntax error, unrecognized expression: " + msg );
};

/**
 * Document sorting and removing duplicates
 * @param {ArrayLike} results
 */
Sizzle.uniqueSort = function( results ) {
	var elem,
		duplicates = [],
		j = 0,
		i = 0;

	// Unless we *know* we can detect duplicates, assume their presence
	hasDuplicate = !support.detectDuplicates;
	sortInput = !support.sortStable && results.slice( 0 );
	results.sort( sortOrder );

	if ( hasDuplicate ) {
		while ( (elem = results[i++]) ) {
			if ( elem === results[ i ] ) {
				j = duplicates.push( i );
			}
		}
		while ( j-- ) {
			results.splice( duplicates[ j ], 1 );
		}
	}

	// Clear input after sorting to release objects
	// See https://github.com/jquery/sizzle/pull/225
	sortInput = null;

	return results;
};

/**
 * Utility function for retrieving the text value of an array of DOM nodes
 * @param {Array|Element} elem
 */
getText = Sizzle.getText = function( elem ) {
	var node,
		ret = "",
		i = 0,
		nodeType = elem.nodeType;

	if ( !nodeType ) {
		// If no nodeType, this is expected to be an array
		while ( (node = elem[i++]) ) {
			// Do not traverse comment nodes
			ret += getText( node );
		}
	} else if ( nodeType === 1 || nodeType === 9 || nodeType === 11 ) {
		// Use textContent for elements
		// innerText usage removed for consistency of new lines (jQuery #11153)
		if ( typeof elem.textContent === "string" ) {
			return elem.textContent;
		} else {
			// Traverse its children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				ret += getText( elem );
			}
		}
	} else if ( nodeType === 3 || nodeType === 4 ) {
		return elem.nodeValue;
	}
	// Do not include comment or processing instruction nodes

	return ret;
};

Expr = Sizzle.selectors = {

	// Can be adjusted by the user
	cacheLength: 50,

	createPseudo: markFunction,

	match: matchExpr,

	attrHandle: {},

	find: {},

	relative: {
		">": { dir: "parentNode", first: true },
		" ": { dir: "parentNode" },
		"+": { dir: "previousSibling", first: true },
		"~": { dir: "previousSibling" }
	},

	preFilter: {
		"ATTR": function( match ) {
			match[1] = match[1].replace( runescape, funescape );

			// Move the given value to match[3] whether quoted or unquoted
			match[3] = ( match[3] || match[4] || match[5] || "" ).replace( runescape, funescape );

			if ( match[2] === "~=" ) {
				match[3] = " " + match[3] + " ";
			}

			return match.slice( 0, 4 );
		},

		"CHILD": function( match ) {
			/* matches from matchExpr["CHILD"]
				1 type (only|nth|...)
				2 what (child|of-type)
				3 argument (even|odd|\d*|\d*n([+-]\d+)?|...)
				4 xn-component of xn+y argument ([+-]?\d*n|)
				5 sign of xn-component
				6 x of xn-component
				7 sign of y-component
				8 y of y-component
			*/
			match[1] = match[1].toLowerCase();

			if ( match[1].slice( 0, 3 ) === "nth" ) {
				// nth-* requires argument
				if ( !match[3] ) {
					Sizzle.error( match[0] );
				}

				// numeric x and y parameters for Expr.filter.CHILD
				// remember that false/true cast respectively to 0/1
				match[4] = +( match[4] ? match[5] + (match[6] || 1) : 2 * ( match[3] === "even" || match[3] === "odd" ) );
				match[5] = +( ( match[7] + match[8] ) || match[3] === "odd" );

			// other types prohibit arguments
			} else if ( match[3] ) {
				Sizzle.error( match[0] );
			}

			return match;
		},

		"PSEUDO": function( match ) {
			var excess,
				unquoted = !match[6] && match[2];

			if ( matchExpr["CHILD"].test( match[0] ) ) {
				return null;
			}

			// Accept quoted arguments as-is
			if ( match[3] ) {
				match[2] = match[4] || match[5] || "";

			// Strip excess characters from unquoted arguments
			} else if ( unquoted && rpseudo.test( unquoted ) &&
				// Get excess from tokenize (recursively)
				(excess = tokenize( unquoted, true )) &&
				// advance to the next closing parenthesis
				(excess = unquoted.indexOf( ")", unquoted.length - excess ) - unquoted.length) ) {

				// excess is a negative index
				match[0] = match[0].slice( 0, excess );
				match[2] = unquoted.slice( 0, excess );
			}

			// Return only captures needed by the pseudo filter method (type and argument)
			return match.slice( 0, 3 );
		}
	},

	filter: {

		"TAG": function( nodeNameSelector ) {
			var nodeName = nodeNameSelector.replace( runescape, funescape ).toLowerCase();
			return nodeNameSelector === "*" ?
				function() { return true; } :
				function( elem ) {
					return elem.nodeName && elem.nodeName.toLowerCase() === nodeName;
				};
		},

		"CLASS": function( className ) {
			var pattern = classCache[ className + " " ];

			return pattern ||
				(pattern = new RegExp( "(^|" + whitespace + ")" + className + "(" + whitespace + "|$)" )) &&
				classCache( className, function( elem ) {
					return pattern.test( typeof elem.className === "string" && elem.className || typeof elem.getAttribute !== "undefined" && elem.getAttribute("class") || "" );
				});
		},

		"ATTR": function( name, operator, check ) {
			return function( elem ) {
				var result = Sizzle.attr( elem, name );

				if ( result == null ) {
					return operator === "!=";
				}
				if ( !operator ) {
					return true;
				}

				result += "";

				return operator === "=" ? result === check :
					operator === "!=" ? result !== check :
					operator === "^=" ? check && result.indexOf( check ) === 0 :
					operator === "*=" ? check && result.indexOf( check ) > -1 :
					operator === "$=" ? check && result.slice( -check.length ) === check :
					operator === "~=" ? ( " " + result.replace( rwhitespace, " " ) + " " ).indexOf( check ) > -1 :
					operator === "|=" ? result === check || result.slice( 0, check.length + 1 ) === check + "-" :
					false;
			};
		},

		"CHILD": function( type, what, argument, first, last ) {
			var simple = type.slice( 0, 3 ) !== "nth",
				forward = type.slice( -4 ) !== "last",
				ofType = what === "of-type";

			return first === 1 && last === 0 ?

				// Shortcut for :nth-*(n)
				function( elem ) {
					return !!elem.parentNode;
				} :

				function( elem, context, xml ) {
					var cache, uniqueCache, outerCache, node, nodeIndex, start,
						dir = simple !== forward ? "nextSibling" : "previousSibling",
						parent = elem.parentNode,
						name = ofType && elem.nodeName.toLowerCase(),
						useCache = !xml && !ofType,
						diff = false;

					if ( parent ) {

						// :(first|last|only)-(child|of-type)
						if ( simple ) {
							while ( dir ) {
								node = elem;
								while ( (node = node[ dir ]) ) {
									if ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) {

										return false;
									}
								}
								// Reverse direction for :only-* (if we haven't yet done so)
								start = dir = type === "only" && !start && "nextSibling";
							}
							return true;
						}

						start = [ forward ? parent.firstChild : parent.lastChild ];

						// non-xml :nth-child(...) stores cache data on `parent`
						if ( forward && useCache ) {

							// Seek `elem` from a previously-cached index

							// ...in a gzip-friendly way
							node = parent;
							outerCache = node[ expando ] || (node[ expando ] = {});

							// Support: IE <9 only
							// Defend against cloned attroperties (jQuery gh-1709)
							uniqueCache = outerCache[ node.uniqueID ] ||
								(outerCache[ node.uniqueID ] = {});

							cache = uniqueCache[ type ] || [];
							nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
							diff = nodeIndex && cache[ 2 ];
							node = nodeIndex && parent.childNodes[ nodeIndex ];

							while ( (node = ++nodeIndex && node && node[ dir ] ||

								// Fallback to seeking `elem` from the start
								(diff = nodeIndex = 0) || start.pop()) ) {

								// When found, cache indexes on `parent` and break
								if ( node.nodeType === 1 && ++diff && node === elem ) {
									uniqueCache[ type ] = [ dirruns, nodeIndex, diff ];
									break;
								}
							}

						} else {
							// Use previously-cached element index if available
							if ( useCache ) {
								// ...in a gzip-friendly way
								node = elem;
								outerCache = node[ expando ] || (node[ expando ] = {});

								// Support: IE <9 only
								// Defend against cloned attroperties (jQuery gh-1709)
								uniqueCache = outerCache[ node.uniqueID ] ||
									(outerCache[ node.uniqueID ] = {});

								cache = uniqueCache[ type ] || [];
								nodeIndex = cache[ 0 ] === dirruns && cache[ 1 ];
								diff = nodeIndex;
							}

							// xml :nth-child(...)
							// or :nth-last-child(...) or :nth(-last)?-of-type(...)
							if ( diff === false ) {
								// Use the same loop as above to seek `elem` from the start
								while ( (node = ++nodeIndex && node && node[ dir ] ||
									(diff = nodeIndex = 0) || start.pop()) ) {

									if ( ( ofType ?
										node.nodeName.toLowerCase() === name :
										node.nodeType === 1 ) &&
										++diff ) {

										// Cache the index of each encountered element
										if ( useCache ) {
											outerCache = node[ expando ] || (node[ expando ] = {});

											// Support: IE <9 only
											// Defend against cloned attroperties (jQuery gh-1709)
											uniqueCache = outerCache[ node.uniqueID ] ||
												(outerCache[ node.uniqueID ] = {});

											uniqueCache[ type ] = [ dirruns, diff ];
										}

										if ( node === elem ) {
											break;
										}
									}
								}
							}
						}

						// Incorporate the offset, then check against cycle size
						diff -= last;
						return diff === first || ( diff % first === 0 && diff / first >= 0 );
					}
				};
		},

		"PSEUDO": function( pseudo, argument ) {
			// pseudo-class names are case-insensitive
			// http://www.w3.org/TR/selectors/#pseudo-classes
			// Prioritize by case sensitivity in case custom pseudos are added with uppercase letters
			// Remember that setFilters inherits from pseudos
			var args,
				fn = Expr.pseudos[ pseudo ] || Expr.setFilters[ pseudo.toLowerCase() ] ||
					Sizzle.error( "unsupported pseudo: " + pseudo );

			// The user may use createPseudo to indicate that
			// arguments are needed to create the filter function
			// just as Sizzle does
			if ( fn[ expando ] ) {
				return fn( argument );
			}

			// But maintain support for old signatures
			if ( fn.length > 1 ) {
				args = [ pseudo, pseudo, "", argument ];
				return Expr.setFilters.hasOwnProperty( pseudo.toLowerCase() ) ?
					markFunction(function( seed, matches ) {
						var idx,
							matched = fn( seed, argument ),
							i = matched.length;
						while ( i-- ) {
							idx = indexOf( seed, matched[i] );
							seed[ idx ] = !( matches[ idx ] = matched[i] );
						}
					}) :
					function( elem ) {
						return fn( elem, 0, args );
					};
			}

			return fn;
		}
	},

	pseudos: {
		// Potentially complex pseudos
		"not": markFunction(function( selector ) {
			// Trim the selector passed to compile
			// to avoid treating leading and trailing
			// spaces as combinators
			var input = [],
				results = [],
				matcher = compile( selector.replace( rtrim, "$1" ) );

			return matcher[ expando ] ?
				markFunction(function( seed, matches, context, xml ) {
					var elem,
						unmatched = matcher( seed, null, xml, [] ),
						i = seed.length;

					// Match elements unmatched by `matcher`
					while ( i-- ) {
						if ( (elem = unmatched[i]) ) {
							seed[i] = !(matches[i] = elem);
						}
					}
				}) :
				function( elem, context, xml ) {
					input[0] = elem;
					matcher( input, null, xml, results );
					// Don't keep the element (issue #299)
					input[0] = null;
					return !results.pop();
				};
		}),

		"has": markFunction(function( selector ) {
			return function( elem ) {
				return Sizzle( selector, elem ).length > 0;
			};
		}),

		"contains": markFunction(function( text ) {
			text = text.replace( runescape, funescape );
			return function( elem ) {
				return ( elem.textContent || elem.innerText || getText( elem ) ).indexOf( text ) > -1;
			};
		}),

		// "Whether an element is represented by a :lang() selector
		// is based solely on the element's language value
		// being equal to the identifier C,
		// or beginning with the identifier C immediately followed by "-".
		// The matching of C against the element's language value is performed case-insensitively.
		// The identifier C does not have to be a valid language name."
		// http://www.w3.org/TR/selectors/#lang-pseudo
		"lang": markFunction( function( lang ) {
			// lang value must be a valid identifier
			if ( !ridentifier.test(lang || "") ) {
				Sizzle.error( "unsupported lang: " + lang );
			}
			lang = lang.replace( runescape, funescape ).toLowerCase();
			return function( elem ) {
				var elemLang;
				do {
					if ( (elemLang = documentIsHTML ?
						elem.lang :
						elem.getAttribute("xml:lang") || elem.getAttribute("lang")) ) {

						elemLang = elemLang.toLowerCase();
						return elemLang === lang || elemLang.indexOf( lang + "-" ) === 0;
					}
				} while ( (elem = elem.parentNode) && elem.nodeType === 1 );
				return false;
			};
		}),

		// Miscellaneous
		"target": function( elem ) {
			var hash = window.location && window.location.hash;
			return hash && hash.slice( 1 ) === elem.id;
		},

		"root": function( elem ) {
			return elem === docElem;
		},

		"focus": function( elem ) {
			return elem === document.activeElement && (!document.hasFocus || document.hasFocus()) && !!(elem.type || elem.href || ~elem.tabIndex);
		},

		// Boolean properties
		"enabled": function( elem ) {
			return elem.disabled === false;
		},

		"disabled": function( elem ) {
			return elem.disabled === true;
		},

		"checked": function( elem ) {
			// In CSS3, :checked should return both checked and selected elements
			// http://www.w3.org/TR/2011/REC-css3-selectors-20110929/#checked
			var nodeName = elem.nodeName.toLowerCase();
			return (nodeName === "input" && !!elem.checked) || (nodeName === "option" && !!elem.selected);
		},

		"selected": function( elem ) {
			// Accessing this property makes selected-by-default
			// options in Safari work properly
			if ( elem.parentNode ) {
				elem.parentNode.selectedIndex;
			}

			return elem.selected === true;
		},

		// Contents
		"empty": function( elem ) {
			// http://www.w3.org/TR/selectors/#empty-pseudo
			// :empty is negated by element (1) or content nodes (text: 3; cdata: 4; entity ref: 5),
			//   but not by others (comment: 8; processing instruction: 7; etc.)
			// nodeType < 6 works because attributes (2) do not appear as children
			for ( elem = elem.firstChild; elem; elem = elem.nextSibling ) {
				if ( elem.nodeType < 6 ) {
					return false;
				}
			}
			return true;
		},

		"parent": function( elem ) {
			return !Expr.pseudos["empty"]( elem );
		},

		// Element/input types
		"header": function( elem ) {
			return rheader.test( elem.nodeName );
		},

		"input": function( elem ) {
			return rinputs.test( elem.nodeName );
		},

		"button": function( elem ) {
			var name = elem.nodeName.toLowerCase();
			return name === "input" && elem.type === "button" || name === "button";
		},

		"text": function( elem ) {
			var attr;
			return elem.nodeName.toLowerCase() === "input" &&
				elem.type === "text" &&

				// Support: IE<8
				// New HTML5 attribute values (e.g., "search") appear with elem.type === "text"
				( (attr = elem.getAttribute("type")) == null || attr.toLowerCase() === "text" );
		},

		// Position-in-collection
		"first": createPositionalPseudo(function() {
			return [ 0 ];
		}),

		"last": createPositionalPseudo(function( matchIndexes, length ) {
			return [ length - 1 ];
		}),

		"eq": createPositionalPseudo(function( matchIndexes, length, argument ) {
			return [ argument < 0 ? argument + length : argument ];
		}),

		"even": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 0;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"odd": createPositionalPseudo(function( matchIndexes, length ) {
			var i = 1;
			for ( ; i < length; i += 2 ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"lt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; --i >= 0; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		}),

		"gt": createPositionalPseudo(function( matchIndexes, length, argument ) {
			var i = argument < 0 ? argument + length : argument;
			for ( ; ++i < length; ) {
				matchIndexes.push( i );
			}
			return matchIndexes;
		})
	}
};

Expr.pseudos["nth"] = Expr.pseudos["eq"];

// Add button/input type pseudos
for ( i in { radio: true, checkbox: true, file: true, password: true, image: true } ) {
	Expr.pseudos[ i ] = createInputPseudo( i );
}
for ( i in { submit: true, reset: true } ) {
	Expr.pseudos[ i ] = createButtonPseudo( i );
}

// Easy API for creating new setFilters
function setFilters() {}
setFilters.prototype = Expr.filters = Expr.pseudos;
Expr.setFilters = new setFilters();

tokenize = Sizzle.tokenize = function( selector, parseOnly ) {
	var matched, match, tokens, type,
		soFar, groups, preFilters,
		cached = tokenCache[ selector + " " ];

	if ( cached ) {
		return parseOnly ? 0 : cached.slice( 0 );
	}

	soFar = selector;
	groups = [];
	preFilters = Expr.preFilter;

	while ( soFar ) {

		// Comma and first run
		if ( !matched || (match = rcomma.exec( soFar )) ) {
			if ( match ) {
				// Don't consume trailing commas as valid
				soFar = soFar.slice( match[0].length ) || soFar;
			}
			groups.push( (tokens = []) );
		}

		matched = false;

		// Combinators
		if ( (match = rcombinators.exec( soFar )) ) {
			matched = match.shift();
			tokens.push({
				value: matched,
				// Cast descendant combinators to space
				type: match[0].replace( rtrim, " " )
			});
			soFar = soFar.slice( matched.length );
		}

		// Filters
		for ( type in Expr.filter ) {
			if ( (match = matchExpr[ type ].exec( soFar )) && (!preFilters[ type ] ||
				(match = preFilters[ type ]( match ))) ) {
				matched = match.shift();
				tokens.push({
					value: matched,
					type: type,
					matches: match
				});
				soFar = soFar.slice( matched.length );
			}
		}

		if ( !matched ) {
			break;
		}
	}

	// Return the length of the invalid excess
	// if we're just parsing
	// Otherwise, throw an error or return tokens
	return parseOnly ?
		soFar.length :
		soFar ?
			Sizzle.error( selector ) :
			// Cache the tokens
			tokenCache( selector, groups ).slice( 0 );
};

function toSelector( tokens ) {
	var i = 0,
		len = tokens.length,
		selector = "";
	for ( ; i < len; i++ ) {
		selector += tokens[i].value;
	}
	return selector;
}

function addCombinator( matcher, combinator, base ) {
	var dir = combinator.dir,
		checkNonElements = base && dir === "parentNode",
		doneName = done++;

	return combinator.first ?
		// Check against closest ancestor/preceding element
		function( elem, context, xml ) {
			while ( (elem = elem[ dir ]) ) {
				if ( elem.nodeType === 1 || checkNonElements ) {
					return matcher( elem, context, xml );
				}
			}
		} :

		// Check against all ancestor/preceding elements
		function( elem, context, xml ) {
			var oldCache, uniqueCache, outerCache,
				newCache = [ dirruns, doneName ];

			// We can't set arbitrary data on XML nodes, so they don't benefit from combinator caching
			if ( xml ) {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						if ( matcher( elem, context, xml ) ) {
							return true;
						}
					}
				}
			} else {
				while ( (elem = elem[ dir ]) ) {
					if ( elem.nodeType === 1 || checkNonElements ) {
						outerCache = elem[ expando ] || (elem[ expando ] = {});

						// Support: IE <9 only
						// Defend against cloned attroperties (jQuery gh-1709)
						uniqueCache = outerCache[ elem.uniqueID ] || (outerCache[ elem.uniqueID ] = {});

						if ( (oldCache = uniqueCache[ dir ]) &&
							oldCache[ 0 ] === dirruns && oldCache[ 1 ] === doneName ) {

							// Assign to newCache so results back-propagate to previous elements
							return (newCache[ 2 ] = oldCache[ 2 ]);
						} else {
							// Reuse newcache so results back-propagate to previous elements
							uniqueCache[ dir ] = newCache;

							// A match means we're done; a fail means we have to keep checking
							if ( (newCache[ 2 ] = matcher( elem, context, xml )) ) {
								return true;
							}
						}
					}
				}
			}
		};
}

function elementMatcher( matchers ) {
	return matchers.length > 1 ?
		function( elem, context, xml ) {
			var i = matchers.length;
			while ( i-- ) {
				if ( !matchers[i]( elem, context, xml ) ) {
					return false;
				}
			}
			return true;
		} :
		matchers[0];
}

function multipleContexts( selector, contexts, results ) {
	var i = 0,
		len = contexts.length;
	for ( ; i < len; i++ ) {
		Sizzle( selector, contexts[i], results );
	}
	return results;
}

function condense( unmatched, map, filter, context, xml ) {
	var elem,
		newUnmatched = [],
		i = 0,
		len = unmatched.length,
		mapped = map != null;

	for ( ; i < len; i++ ) {
		if ( (elem = unmatched[i]) ) {
			if ( !filter || filter( elem, context, xml ) ) {
				newUnmatched.push( elem );
				if ( mapped ) {
					map.push( i );
				}
			}
		}
	}

	return newUnmatched;
}

function setMatcher( preFilter, selector, matcher, postFilter, postFinder, postSelector ) {
	if ( postFilter && !postFilter[ expando ] ) {
		postFilter = setMatcher( postFilter );
	}
	if ( postFinder && !postFinder[ expando ] ) {
		postFinder = setMatcher( postFinder, postSelector );
	}
	return markFunction(function( seed, results, context, xml ) {
		var temp, i, elem,
			preMap = [],
			postMap = [],
			preexisting = results.length,

			// Get initial elements from seed or context
			elems = seed || multipleContexts( selector || "*", context.nodeType ? [ context ] : context, [] ),

			// Prefilter to get matcher input, preserving a map for seed-results synchronization
			matcherIn = preFilter && ( seed || !selector ) ?
				condense( elems, preMap, preFilter, context, xml ) :
				elems,

			matcherOut = matcher ?
				// If we have a postFinder, or filtered seed, or non-seed postFilter or preexisting results,
				postFinder || ( seed ? preFilter : preexisting || postFilter ) ?

					// ...intermediate processing is necessary
					[] :

					// ...otherwise use results directly
					results :
				matcherIn;

		// Find primary matches
		if ( matcher ) {
			matcher( matcherIn, matcherOut, context, xml );
		}

		// Apply postFilter
		if ( postFilter ) {
			temp = condense( matcherOut, postMap );
			postFilter( temp, [], context, xml );

			// Un-match failing elements by moving them back to matcherIn
			i = temp.length;
			while ( i-- ) {
				if ( (elem = temp[i]) ) {
					matcherOut[ postMap[i] ] = !(matcherIn[ postMap[i] ] = elem);
				}
			}
		}

		if ( seed ) {
			if ( postFinder || preFilter ) {
				if ( postFinder ) {
					// Get the final matcherOut by condensing this intermediate into postFinder contexts
					temp = [];
					i = matcherOut.length;
					while ( i-- ) {
						if ( (elem = matcherOut[i]) ) {
							// Restore matcherIn since elem is not yet a final match
							temp.push( (matcherIn[i] = elem) );
						}
					}
					postFinder( null, (matcherOut = []), temp, xml );
				}

				// Move matched elements from seed to results to keep them synchronized
				i = matcherOut.length;
				while ( i-- ) {
					if ( (elem = matcherOut[i]) &&
						(temp = postFinder ? indexOf( seed, elem ) : preMap[i]) > -1 ) {

						seed[temp] = !(results[temp] = elem);
					}
				}
			}

		// Add elements to results, through postFinder if defined
		} else {
			matcherOut = condense(
				matcherOut === results ?
					matcherOut.splice( preexisting, matcherOut.length ) :
					matcherOut
			);
			if ( postFinder ) {
				postFinder( null, results, matcherOut, xml );
			} else {
				push.apply( results, matcherOut );
			}
		}
	});
}

function matcherFromTokens( tokens ) {
	var checkContext, matcher, j,
		len = tokens.length,
		leadingRelative = Expr.relative[ tokens[0].type ],
		implicitRelative = leadingRelative || Expr.relative[" "],
		i = leadingRelative ? 1 : 0,

		// The foundational matcher ensures that elements are reachable from top-level context(s)
		matchContext = addCombinator( function( elem ) {
			return elem === checkContext;
		}, implicitRelative, true ),
		matchAnyContext = addCombinator( function( elem ) {
			return indexOf( checkContext, elem ) > -1;
		}, implicitRelative, true ),
		matchers = [ function( elem, context, xml ) {
			var ret = ( !leadingRelative && ( xml || context !== outermostContext ) ) || (
				(checkContext = context).nodeType ?
					matchContext( elem, context, xml ) :
					matchAnyContext( elem, context, xml ) );
			// Avoid hanging onto element (issue #299)
			checkContext = null;
			return ret;
		} ];

	for ( ; i < len; i++ ) {
		if ( (matcher = Expr.relative[ tokens[i].type ]) ) {
			matchers = [ addCombinator(elementMatcher( matchers ), matcher) ];
		} else {
			matcher = Expr.filter[ tokens[i].type ].apply( null, tokens[i].matches );

			// Return special upon seeing a positional matcher
			if ( matcher[ expando ] ) {
				// Find the next relative operator (if any) for proper handling
				j = ++i;
				for ( ; j < len; j++ ) {
					if ( Expr.relative[ tokens[j].type ] ) {
						break;
					}
				}
				return setMatcher(
					i > 1 && elementMatcher( matchers ),
					i > 1 && toSelector(
						// If the preceding token was a descendant combinator, insert an implicit any-element `*`
						tokens.slice( 0, i - 1 ).concat({ value: tokens[ i - 2 ].type === " " ? "*" : "" })
					).replace( rtrim, "$1" ),
					matcher,
					i < j && matcherFromTokens( tokens.slice( i, j ) ),
					j < len && matcherFromTokens( (tokens = tokens.slice( j )) ),
					j < len && toSelector( tokens )
				);
			}
			matchers.push( matcher );
		}
	}

	return elementMatcher( matchers );
}

function matcherFromGroupMatchers( elementMatchers, setMatchers ) {
	var bySet = setMatchers.length > 0,
		byElement = elementMatchers.length > 0,
		superMatcher = function( seed, context, xml, results, outermost ) {
			var elem, j, matcher,
				matchedCount = 0,
				i = "0",
				unmatched = seed && [],
				setMatched = [],
				contextBackup = outermostContext,
				// We must always have either seed elements or outermost context
				elems = seed || byElement && Expr.find["TAG"]( "*", outermost ),
				// Use integer dirruns iff this is the outermost matcher
				dirrunsUnique = (dirruns += contextBackup == null ? 1 : Math.random() || 0.1),
				len = elems.length;

			if ( outermost ) {
				outermostContext = context === document || context || outermost;
			}

			// Add elements passing elementMatchers directly to results
			// Support: IE<9, Safari
			// Tolerate NodeList properties (IE: "length"; Safari: <number>) matching elements by id
			for ( ; i !== len && (elem = elems[i]) != null; i++ ) {
				if ( byElement && elem ) {
					j = 0;
					if ( !context && elem.ownerDocument !== document ) {
						setDocument( elem );
						xml = !documentIsHTML;
					}
					while ( (matcher = elementMatchers[j++]) ) {
						if ( matcher( elem, context || document, xml) ) {
							results.push( elem );
							break;
						}
					}
					if ( outermost ) {
						dirruns = dirrunsUnique;
					}
				}

				// Track unmatched elements for set filters
				if ( bySet ) {
					// They will have gone through all possible matchers
					if ( (elem = !matcher && elem) ) {
						matchedCount--;
					}

					// Lengthen the array for every element, matched or not
					if ( seed ) {
						unmatched.push( elem );
					}
				}
			}

			// `i` is now the count of elements visited above, and adding it to `matchedCount`
			// makes the latter nonnegative.
			matchedCount += i;

			// Apply set filters to unmatched elements
			// NOTE: This can be skipped if there are no unmatched elements (i.e., `matchedCount`
			// equals `i`), unless we didn't visit _any_ elements in the above loop because we have
			// no element matchers and no seed.
			// Incrementing an initially-string "0" `i` allows `i` to remain a string only in that
			// case, which will result in a "00" `matchedCount` that differs from `i` but is also
			// numerically zero.
			if ( bySet && i !== matchedCount ) {
				j = 0;
				while ( (matcher = setMatchers[j++]) ) {
					matcher( unmatched, setMatched, context, xml );
				}

				if ( seed ) {
					// Reintegrate element matches to eliminate the need for sorting
					if ( matchedCount > 0 ) {
						while ( i-- ) {
							if ( !(unmatched[i] || setMatched[i]) ) {
								setMatched[i] = pop.call( results );
							}
						}
					}

					// Discard index placeholder values to get only actual matches
					setMatched = condense( setMatched );
				}

				// Add matches to results
				push.apply( results, setMatched );

				// Seedless set matches succeeding multiple successful matchers stipulate sorting
				if ( outermost && !seed && setMatched.length > 0 &&
					( matchedCount + setMatchers.length ) > 1 ) {

					Sizzle.uniqueSort( results );
				}
			}

			// Override manipulation of globals by nested matchers
			if ( outermost ) {
				dirruns = dirrunsUnique;
				outermostContext = contextBackup;
			}

			return unmatched;
		};

	return bySet ?
		markFunction( superMatcher ) :
		superMatcher;
}

compile = Sizzle.compile = function( selector, match /* Internal Use Only */ ) {
	var i,
		setMatchers = [],
		elementMatchers = [],
		cached = compilerCache[ selector + " " ];

	if ( !cached ) {
		// Generate a function of recursive functions that can be used to check each element
		if ( !match ) {
			match = tokenize( selector );
		}
		i = match.length;
		while ( i-- ) {
			cached = matcherFromTokens( match[i] );
			if ( cached[ expando ] ) {
				setMatchers.push( cached );
			} else {
				elementMatchers.push( cached );
			}
		}

		// Cache the compiled function
		cached = compilerCache( selector, matcherFromGroupMatchers( elementMatchers, setMatchers ) );

		// Save selector and tokenization
		cached.selector = selector;
	}
	return cached;
};

/**
 * A low-level selection function that works with Sizzle's compiled
 *  selector functions
 * @param {String|Function} selector A selector or a pre-compiled
 *  selector function built with Sizzle.compile
 * @param {Element} context
 * @param {Array} [results]
 * @param {Array} [seed] A set of elements to match against
 */
select = Sizzle.select = function( selector, context, results, seed ) {
	var i, tokens, token, type, find,
		compiled = typeof selector === "function" && selector,
		match = !seed && tokenize( (selector = compiled.selector || selector) );

	results = results || [];

	// Try to minimize operations if there is only one selector in the list and no seed
	// (the latter of which guarantees us context)
	if ( match.length === 1 ) {

		// Reduce context if the leading compound selector is an ID
		tokens = match[0] = match[0].slice( 0 );
		if ( tokens.length > 2 && (token = tokens[0]).type === "ID" &&
				support.getById && context.nodeType === 9 && documentIsHTML &&
				Expr.relative[ tokens[1].type ] ) {

			context = ( Expr.find["ID"]( token.matches[0].replace(runescape, funescape), context ) || [] )[0];
			if ( !context ) {
				return results;

			// Precompiled matchers will still verify ancestry, so step up a level
			} else if ( compiled ) {
				context = context.parentNode;
			}

			selector = selector.slice( tokens.shift().value.length );
		}

		// Fetch a seed set for right-to-left matching
		i = matchExpr["needsContext"].test( selector ) ? 0 : tokens.length;
		while ( i-- ) {
			token = tokens[i];

			// Abort if we hit a combinator
			if ( Expr.relative[ (type = token.type) ] ) {
				break;
			}
			if ( (find = Expr.find[ type ]) ) {
				// Search, expanding context for leading sibling combinators
				if ( (seed = find(
					token.matches[0].replace( runescape, funescape ),
					rsibling.test( tokens[0].type ) && testContext( context.parentNode ) || context
				)) ) {

					// If seed is empty or no tokens remain, we can return early
					tokens.splice( i, 1 );
					selector = seed.length && toSelector( tokens );
					if ( !selector ) {
						push.apply( results, seed );
						return results;
					}

					break;
				}
			}
		}
	}

	// Compile and execute a filtering function if one is not provided
	// Provide `match` to avoid retokenization if we modified the selector above
	( compiled || compile( selector, match ) )(
		seed,
		context,
		!documentIsHTML,
		results,
		!context || rsibling.test( selector ) && testContext( context.parentNode ) || context
	);
	return results;
};

// One-time assignments

// Sort stability
support.sortStable = expando.split("").sort( sortOrder ).join("") === expando;

// Support: Chrome 14-35+
// Always assume duplicates if they aren't passed to the comparison function
support.detectDuplicates = !!hasDuplicate;

// Initialize against the default document
setDocument();

// Support: Webkit<537.32 - Safari 6.0.3/Chrome 25 (fixed in Chrome 27)
// Detached nodes confoundingly follow *each other*
support.sortDetached = assert(function( div1 ) {
	// Should return 1, but returns 4 (following)
	return div1.compareDocumentPosition( document.createElement("div") ) & 1;
});

// Support: IE<8
// Prevent attribute/property "interpolation"
// http://msdn.microsoft.com/en-us/library/ms536429%28VS.85%29.aspx
if ( !assert(function( div ) {
	div.innerHTML = "<a href='#'></a>";
	return div.firstChild.getAttribute("href") === "#" ;
}) ) {
	addHandle( "type|href|height|width", function( elem, name, isXML ) {
		if ( !isXML ) {
			return elem.getAttribute( name, name.toLowerCase() === "type" ? 1 : 2 );
		}
	});
}

// Support: IE<9
// Use defaultValue in place of getAttribute("value")
if ( !support.attributes || !assert(function( div ) {
	div.innerHTML = "<input/>";
	div.firstChild.setAttribute( "value", "" );
	return div.firstChild.getAttribute( "value" ) === "";
}) ) {
	addHandle( "value", function( elem, name, isXML ) {
		if ( !isXML && elem.nodeName.toLowerCase() === "input" ) {
			return elem.defaultValue;
		}
	});
}

// Support: IE<9
// Use getAttributeNode to fetch booleans when getAttribute lies
if ( !assert(function( div ) {
	return div.getAttribute("disabled") == null;
}) ) {
	addHandle( booleans, function( elem, name, isXML ) {
		var val;
		if ( !isXML ) {
			return elem[ name ] === true ? name.toLowerCase() :
					(val = elem.getAttributeNode( name )) && val.specified ?
					val.value :
				null;
		}
	});
}

return Sizzle;

})( window );



jQuery.find = Sizzle;
jQuery.expr = Sizzle.selectors;
jQuery.expr[ ":" ] = jQuery.expr.pseudos;
jQuery.uniqueSort = jQuery.unique = Sizzle.uniqueSort;
jQuery.text = Sizzle.getText;
jQuery.isXMLDoc = Sizzle.isXML;
jQuery.contains = Sizzle.contains;



var dir = function( elem, dir, until ) {
	var matched = [],
		truncate = until !== undefined;

	while ( ( elem = elem[ dir ] ) && elem.nodeType !== 9 ) {
		if ( elem.nodeType === 1 ) {
			if ( truncate && jQuery( elem ).is( until ) ) {
				break;
			}
			matched.push( elem );
		}
	}
	return matched;
};


var siblings = function( n, elem ) {
	var matched = [];

	for ( ; n; n = n.nextSibling ) {
		if ( n.nodeType === 1 && n !== elem ) {
			matched.push( n );
		}
	}

	return matched;
};


var rneedsContext = jQuery.expr.match.needsContext;

var rsingleTag = ( /^<([\w-]+)\s*\/?>(?:<\/\1>|)$/ );



var risSimple = /^.[^:#\[\.,]*$/;

// Implement the identical functionality for filter and not
function winnow( elements, qualifier, not ) {
	if ( jQuery.isFunction( qualifier ) ) {
		return jQuery.grep( elements, function( elem, i ) {
			/* jshint -W018 */
			return !!qualifier.call( elem, i, elem ) !== not;
		} );

	}

	if ( qualifier.nodeType ) {
		return jQuery.grep( elements, function( elem ) {
			return ( elem === qualifier ) !== not;
		} );

	}

	if ( typeof qualifier === "string" ) {
		if ( risSimple.test( qualifier ) ) {
			return jQuery.filter( qualifier, elements, not );
		}

		qualifier = jQuery.filter( qualifier, elements );
	}

	return jQuery.grep( elements, function( elem ) {
		return ( indexOf.call( qualifier, elem ) > -1 ) !== not;
	} );
}

jQuery.filter = function( expr, elems, not ) {
	var elem = elems[ 0 ];

	if ( not ) {
		expr = ":not(" + expr + ")";
	}

	return elems.length === 1 && elem.nodeType === 1 ?
		jQuery.find.matchesSelector( elem, expr ) ? [ elem ] : [] :
		jQuery.find.matches( expr, jQuery.grep( elems, function( elem ) {
			return elem.nodeType === 1;
		} ) );
};

jQuery.fn.extend( {
	find: function( selector ) {
		var i,
			len = this.length,
			ret = [],
			self = this;

		if ( typeof selector !== "string" ) {
			return this.pushStack( jQuery( selector ).filter( function() {
				for ( i = 0; i < len; i++ ) {
					if ( jQuery.contains( self[ i ], this ) ) {
						return true;
					}
				}
			} ) );
		}

		for ( i = 0; i < len; i++ ) {
			jQuery.find( selector, self[ i ], ret );
		}

		// Needed because $( selector, context ) becomes $( context ).find( selector )
		ret = this.pushStack( len > 1 ? jQuery.unique( ret ) : ret );
		ret.selector = this.selector ? this.selector + " " + selector : selector;
		return ret;
	},
	filter: function( selector ) {
		return this.pushStack( winnow( this, selector || [], false ) );
	},
	not: function( selector ) {
		return this.pushStack( winnow( this, selector || [], true ) );
	},
	is: function( selector ) {
		return !!winnow(
			this,

			// If this is a positional/relative selector, check membership in the returned set
			// so $("p:first").is("p:last") won't return true for a doc with two "p".
			typeof selector === "string" && rneedsContext.test( selector ) ?
				jQuery( selector ) :
				selector || [],
			false
		).length;
	}
} );


// Initialize a jQuery object


// A central reference to the root jQuery(document)
var rootjQuery,

	// A simple way to check for HTML strings
	// Prioritize #id over <tag> to avoid XSS via location.hash (#9521)
	// Strict HTML recognition (#11290: must start with <)
	rquickExpr = /^(?:\s*(<[\w\W]+>)[^>]*|#([\w-]*))$/,

	init = jQuery.fn.init = function( selector, context, root ) {
		var match, elem;

		// HANDLE: $(""), $(null), $(undefined), $(false)
		if ( !selector ) {
			return this;
		}

		// Method init() accepts an alternate rootjQuery
		// so migrate can support jQuery.sub (gh-2101)
		root = root || rootjQuery;

		// Handle HTML strings
		if ( typeof selector === "string" ) {
			if ( selector[ 0 ] === "<" &&
				selector[ selector.length - 1 ] === ">" &&
				selector.length >= 3 ) {

				// Assume that strings that start and end with <> are HTML and skip the regex check
				match = [ null, selector, null ];

			} else {
				match = rquickExpr.exec( selector );
			}

			// Match html or make sure no context is specified for #id
			if ( match && ( match[ 1 ] || !context ) ) {

				// HANDLE: $(html) -> $(array)
				if ( match[ 1 ] ) {
					context = context instanceof jQuery ? context[ 0 ] : context;

					// Option to run scripts is true for back-compat
					// Intentionally let the error be thrown if parseHTML is not present
					jQuery.merge( this, jQuery.parseHTML(
						match[ 1 ],
						context && context.nodeType ? context.ownerDocument || context : document,
						true
					) );

					// HANDLE: $(html, props)
					if ( rsingleTag.test( match[ 1 ] ) && jQuery.isPlainObject( context ) ) {
						for ( match in context ) {

							// Properties of context are called as methods if possible
							if ( jQuery.isFunction( this[ match ] ) ) {
								this[ match ]( context[ match ] );

							// ...and otherwise set as attributes
							} else {
								this.attr( match, context[ match ] );
							}
						}
					}

					return this;

				// HANDLE: $(#id)
				} else {
					elem = document.getElementById( match[ 2 ] );

					// Support: Blackberry 4.6
					// gEBID returns nodes no longer in the document (#6963)
					if ( elem && elem.parentNode ) {

						// Inject the element directly into the jQuery object
						this.length = 1;
						this[ 0 ] = elem;
					}

					this.context = document;
					this.selector = selector;
					return this;
				}

			// HANDLE: $(expr, $(...))
			} else if ( !context || context.jquery ) {
				return ( context || root ).find( selector );

			// HANDLE: $(expr, context)
			// (which is just equivalent to: $(context).find(expr)
			} else {
				return this.constructor( context ).find( selector );
			}

		// HANDLE: $(DOMElement)
		} else if ( selector.nodeType ) {
			this.context = this[ 0 ] = selector;
			this.length = 1;
			return this;

		// HANDLE: $(function)
		// Shortcut for document ready
		} else if ( jQuery.isFunction( selector ) ) {
			return root.ready !== undefined ?
				root.ready( selector ) :

				// Execute immediately if ready is not present
				selector( jQuery );
		}

		if ( selector.selector !== undefined ) {
			this.selector = selector.selector;
			this.context = selector.context;
		}

		return jQuery.makeArray( selector, this );
	};

// Give the init function the jQuery prototype for later instantiation
init.prototype = jQuery.fn;

// Initialize central reference
rootjQuery = jQuery( document );


var rparentsprev = /^(?:parents|prev(?:Until|All))/,

	// Methods guaranteed to produce a unique set when starting from a unique set
	guaranteedUnique = {
		children: true,
		contents: true,
		next: true,
		prev: true
	};

jQuery.fn.extend( {
	has: function( target ) {
		var targets = jQuery( target, this ),
			l = targets.length;

		return this.filter( function() {
			var i = 0;
			for ( ; i < l; i++ ) {
				if ( jQuery.contains( this, targets[ i ] ) ) {
					return true;
				}
			}
		} );
	},

	closest: function( selectors, context ) {
		var cur,
			i = 0,
			l = this.length,
			matched = [],
			pos = rneedsContext.test( selectors ) || typeof selectors !== "string" ?
				jQuery( selectors, context || this.context ) :
				0;

		for ( ; i < l; i++ ) {
			for ( cur = this[ i ]; cur && cur !== context; cur = cur.parentNode ) {

				// Always skip document fragments
				if ( cur.nodeType < 11 && ( pos ?
					pos.index( cur ) > -1 :

					// Don't pass non-elements to Sizzle
					cur.nodeType === 1 &&
						jQuery.find.matchesSelector( cur, selectors ) ) ) {

					matched.push( cur );
					break;
				}
			}
		}

		return this.pushStack( matched.length > 1 ? jQuery.uniqueSort( matched ) : matched );
	},

	// Determine the position of an element within the set
	index: function( elem ) {

		// No argument, return index in parent
		if ( !elem ) {
			return ( this[ 0 ] && this[ 0 ].parentNode ) ? this.first().prevAll().length : -1;
		}

		// Index in selector
		if ( typeof elem === "string" ) {
			return indexOf.call( jQuery( elem ), this[ 0 ] );
		}

		// Locate the position of the desired element
		return indexOf.call( this,

			// If it receives a jQuery object, the first element is used
			elem.jquery ? elem[ 0 ] : elem
		);
	},

	add: function( selector, context ) {
		return this.pushStack(
			jQuery.uniqueSort(
				jQuery.merge( this.get(), jQuery( selector, context ) )
			)
		);
	},

	addBack: function( selector ) {
		return this.add( selector == null ?
			this.prevObject : this.prevObject.filter( selector )
		);
	}
} );

function sibling( cur, dir ) {
	while ( ( cur = cur[ dir ] ) && cur.nodeType !== 1 ) {}
	return cur;
}

jQuery.each( {
	parent: function( elem ) {
		var parent = elem.parentNode;
		return parent && parent.nodeType !== 11 ? parent : null;
	},
	parents: function( elem ) {
		return dir( elem, "parentNode" );
	},
	parentsUntil: function( elem, i, until ) {
		return dir( elem, "parentNode", until );
	},
	next: function( elem ) {
		return sibling( elem, "nextSibling" );
	},
	prev: function( elem ) {
		return sibling( elem, "previousSibling" );
	},
	nextAll: function( elem ) {
		return dir( elem, "nextSibling" );
	},
	prevAll: function( elem ) {
		return dir( elem, "previousSibling" );
	},
	nextUntil: function( elem, i, until ) {
		return dir( elem, "nextSibling", until );
	},
	prevUntil: function( elem, i, until ) {
		return dir( elem, "previousSibling", until );
	},
	siblings: function( elem ) {
		return siblings( ( elem.parentNode || {} ).firstChild, elem );
	},
	children: function( elem ) {
		return siblings( elem.firstChild );
	},
	contents: function( elem ) {
		return elem.contentDocument || jQuery.merge( [], elem.childNodes );
	}
}, function( name, fn ) {
	jQuery.fn[ name ] = function( until, selector ) {
		var matched = jQuery.map( this, fn, until );

		if ( name.slice( -5 ) !== "Until" ) {
			selector = until;
		}

		if ( selector && typeof selector === "string" ) {
			matched = jQuery.filter( selector, matched );
		}

		if ( this.length > 1 ) {

			// Remove duplicates
			if ( !guaranteedUnique[ name ] ) {
				jQuery.uniqueSort( matched );
			}

			// Reverse order for parents* and prev-derivatives
			if ( rparentsprev.test( name ) ) {
				matched.reverse();
			}
		}

		return this.pushStack( matched );
	};
} );
var rnotwhite = ( /\S+/g );



// Convert String-formatted options into Object-formatted ones
function createOptions( options ) {
	var object = {};
	jQuery.each( options.match( rnotwhite ) || [], function( _, flag ) {
		object[ flag ] = true;
	} );
	return object;
}

/*
 * Create a callback list using the following parameters:
 *
 *	options: an optional list of space-separated options that will change how
 *			the callback list behaves or a more traditional option object
 *
 * By default a callback list will act like an event callback list and can be
 * "fired" multiple times.
 *
 * Possible options:
 *
 *	once:			will ensure the callback list can only be fired once (like a Deferred)
 *
 *	memory:			will keep track of previous values and will call any callback added
 *					after the list has been fired right away with the latest "memorized"
 *					values (like a Deferred)
 *
 *	unique:			will ensure a callback can only be added once (no duplicate in the list)
 *
 *	stopOnFalse:	interrupt callings when a callback returns false
 *
 */
jQuery.Callbacks = function( options ) {

	// Convert options from String-formatted to Object-formatted if needed
	// (we check in cache first)
	options = typeof options === "string" ?
		createOptions( options ) :
		jQuery.extend( {}, options );

	var // Flag to know if list is currently firing
		firing,

		// Last fire value for non-forgettable lists
		memory,

		// Flag to know if list was already fired
		fired,

		// Flag to prevent firing
		locked,

		// Actual callback list
		list = [],

		// Queue of execution data for repeatable lists
		queue = [],

		// Index of currently firing callback (modified by add/remove as needed)
		firingIndex = -1,

		// Fire callbacks
		fire = function() {

			// Enforce single-firing
			locked = options.once;

			// Execute callbacks for all pending executions,
			// respecting firingIndex overrides and runtime changes
			fired = firing = true;
			for ( ; queue.length; firingIndex = -1 ) {
				memory = queue.shift();
				while ( ++firingIndex < list.length ) {

					// Run callback and check for early termination
					if ( list[ firingIndex ].apply( memory[ 0 ], memory[ 1 ] ) === false &&
						options.stopOnFalse ) {

						// Jump to end and forget the data so .add doesn't re-fire
						firingIndex = list.length;
						memory = false;
					}
				}
			}

			// Forget the data if we're done with it
			if ( !options.memory ) {
				memory = false;
			}

			firing = false;

			// Clean up if we're done firing for good
			if ( locked ) {

				// Keep an empty list if we have data for future add calls
				if ( memory ) {
					list = [];

				// Otherwise, this object is spent
				} else {
					list = "";
				}
			}
		},

		// Actual Callbacks object
		self = {

			// Add a callback or a collection of callbacks to the list
			add: function() {
				if ( list ) {

					// If we have memory from a past run, we should fire after adding
					if ( memory && !firing ) {
						firingIndex = list.length - 1;
						queue.push( memory );
					}

					( function add( args ) {
						jQuery.each( args, function( _, arg ) {
							if ( jQuery.isFunction( arg ) ) {
								if ( !options.unique || !self.has( arg ) ) {
									list.push( arg );
								}
							} else if ( arg && arg.length && jQuery.type( arg ) !== "string" ) {

								// Inspect recursively
								add( arg );
							}
						} );
					} )( arguments );

					if ( memory && !firing ) {
						fire();
					}
				}
				return this;
			},

			// Remove a callback from the list
			remove: function() {
				jQuery.each( arguments, function( _, arg ) {
					var index;
					while ( ( index = jQuery.inArray( arg, list, index ) ) > -1 ) {
						list.splice( index, 1 );

						// Handle firing indexes
						if ( index <= firingIndex ) {
							firingIndex--;
						}
					}
				} );
				return this;
			},

			// Check if a given callback is in the list.
			// If no argument is given, return whether or not list has callbacks attached.
			has: function( fn ) {
				return fn ?
					jQuery.inArray( fn, list ) > -1 :
					list.length > 0;
			},

			// Remove all callbacks from the list
			empty: function() {
				if ( list ) {
					list = [];
				}
				return this;
			},

			// Disable .fire and .add
			// Abort any current/pending executions
			// Clear all callbacks and values
			disable: function() {
				locked = queue = [];
				list = memory = "";
				return this;
			},
			disabled: function() {
				return !list;
			},

			// Disable .fire
			// Also disable .add unless we have memory (since it would have no effect)
			// Abort any pending executions
			lock: function() {
				locked = queue = [];
				if ( !memory ) {
					list = memory = "";
				}
				return this;
			},
			locked: function() {
				return !!locked;
			},

			// Call all callbacks with the given context and arguments
			fireWith: function( context, args ) {
				if ( !locked ) {
					args = args || [];
					args = [ context, args.slice ? args.slice() : args ];
					queue.push( args );
					if ( !firing ) {
						fire();
					}
				}
				return this;
			},

			// Call all the callbacks with the given arguments
			fire: function() {
				self.fireWith( this, arguments );
				return this;
			},

			// To know if the callbacks have already been called at least once
			fired: function() {
				return !!fired;
			}
		};

	return self;
};


jQuery.extend( {

	Deferred: function( func ) {
		var tuples = [

				// action, add listener, listener list, final state
				[ "resolve", "done", jQuery.Callbacks( "once memory" ), "resolved" ],
				[ "reject", "fail", jQuery.Callbacks( "once memory" ), "rejected" ],
				[ "notify", "progress", jQuery.Callbacks( "memory" ) ]
			],
			state = "pending",
			promise = {
				state: function() {
					return state;
				},
				always: function() {
					deferred.done( arguments ).fail( arguments );
					return this;
				},
				then: function( /* fnDone, fnFail, fnProgress */ ) {
					var fns = arguments;
					return jQuery.Deferred( function( newDefer ) {
						jQuery.each( tuples, function( i, tuple ) {
							var fn = jQuery.isFunction( fns[ i ] ) && fns[ i ];

							// deferred[ done | fail | progress ] for forwarding actions to newDefer
							deferred[ tuple[ 1 ] ]( function() {
								var returned = fn && fn.apply( this, arguments );
								if ( returned && jQuery.isFunction( returned.promise ) ) {
									returned.promise()
										.progress( newDefer.notify )
										.done( newDefer.resolve )
										.fail( newDefer.reject );
								} else {
									newDefer[ tuple[ 0 ] + "With" ](
										this === promise ? newDefer.promise() : this,
										fn ? [ returned ] : arguments
									);
								}
							} );
						} );
						fns = null;
					} ).promise();
				},

				// Get a promise for this deferred
				// If obj is provided, the promise aspect is added to the object
				promise: function( obj ) {
					return obj != null ? jQuery.extend( obj, promise ) : promise;
				}
			},
			deferred = {};

		// Keep pipe for back-compat
		promise.pipe = promise.then;

		// Add list-specific methods
		jQuery.each( tuples, function( i, tuple ) {
			var list = tuple[ 2 ],
				stateString = tuple[ 3 ];

			// promise[ done | fail | progress ] = list.add
			promise[ tuple[ 1 ] ] = list.add;

			// Handle state
			if ( stateString ) {
				list.add( function() {

					// state = [ resolved | rejected ]
					state = stateString;

				// [ reject_list | resolve_list ].disable; progress_list.lock
				}, tuples[ i ^ 1 ][ 2 ].disable, tuples[ 2 ][ 2 ].lock );
			}

			// deferred[ resolve | reject | notify ]
			deferred[ tuple[ 0 ] ] = function() {
				deferred[ tuple[ 0 ] + "With" ]( this === deferred ? promise : this, arguments );
				return this;
			};
			deferred[ tuple[ 0 ] + "With" ] = list.fireWith;
		} );

		// Make the deferred a promise
		promise.promise( deferred );

		// Call given func if any
		if ( func ) {
			func.call( deferred, deferred );
		}

		// All done!
		return deferred;
	},

	// Deferred helper
	when: function( subordinate /* , ..., subordinateN */ ) {
		var i = 0,
			resolveValues = slice.call( arguments ),
			length = resolveValues.length,

			// the count of uncompleted subordinates
			remaining = length !== 1 ||
				( subordinate && jQuery.isFunction( subordinate.promise ) ) ? length : 0,

			// the master Deferred.
			// If resolveValues consist of only a single Deferred, just use that.
			deferred = remaining === 1 ? subordinate : jQuery.Deferred(),

			// Update function for both resolve and progress values
			updateFunc = function( i, contexts, values ) {
				return function( value ) {
					contexts[ i ] = this;
					values[ i ] = arguments.length > 1 ? slice.call( arguments ) : value;
					if ( values === progressValues ) {
						deferred.notifyWith( contexts, values );
					} else if ( !( --remaining ) ) {
						deferred.resolveWith( contexts, values );
					}
				};
			},

			progressValues, progressContexts, resolveContexts;

		// Add listeners to Deferred subordinates; treat others as resolved
		if ( length > 1 ) {
			progressValues = new Array( length );
			progressContexts = new Array( length );
			resolveContexts = new Array( length );
			for ( ; i < length; i++ ) {
				if ( resolveValues[ i ] && jQuery.isFunction( resolveValues[ i ].promise ) ) {
					resolveValues[ i ].promise()
						.progress( updateFunc( i, progressContexts, progressValues ) )
						.done( updateFunc( i, resolveContexts, resolveValues ) )
						.fail( deferred.reject );
				} else {
					--remaining;
				}
			}
		}

		// If we're not waiting on anything, resolve the master
		if ( !remaining ) {
			deferred.resolveWith( resolveContexts, resolveValues );
		}

		return deferred.promise();
	}
} );


// The deferred used on DOM ready
var readyList;

jQuery.fn.ready = function( fn ) {

	// Add the callback
	jQuery.ready.promise().done( fn );

	return this;
};

jQuery.extend( {

	// Is the DOM ready to be used? Set to true once it occurs.
	isReady: false,

	// A counter to track how many items to wait for before
	// the ready event fires. See #6781
	readyWait: 1,

	// Hold (or release) the ready event
	holdReady: function( hold ) {
		if ( hold ) {
			jQuery.readyWait++;
		} else {
			jQuery.ready( true );
		}
	},

	// Handle when the DOM is ready
	ready: function( wait ) {

		// Abort if there are pending holds or we're already ready
		if ( wait === true ? --jQuery.readyWait : jQuery.isReady ) {
			return;
		}

		// Remember that the DOM is ready
		jQuery.isReady = true;

		// If a normal DOM Ready event fired, decrement, and wait if need be
		if ( wait !== true && --jQuery.readyWait > 0 ) {
			return;
		}

		// If there are functions bound, to execute
		readyList.resolveWith( document, [ jQuery ] );

		// Trigger any bound ready events
		if ( jQuery.fn.triggerHandler ) {
			jQuery( document ).triggerHandler( "ready" );
			jQuery( document ).off( "ready" );
		}
	}
} );

/**
 * The ready event handler and self cleanup method
 */
function completed() {
	document.removeEventListener( "DOMContentLoaded", completed );
	window.removeEventListener( "load", completed );
	jQuery.ready();
}

jQuery.ready.promise = function( obj ) {
	if ( !readyList ) {

		readyList = jQuery.Deferred();

		// Catch cases where $(document).ready() is called
		// after the browser event has already occurred.
		// Support: IE9-10 only
		// Older IE sometimes signals "interactive" too soon
		if ( document.readyState === "complete" ||
			( document.readyState !== "loading" && !document.documentElement.doScroll ) ) {

			// Handle it asynchronously to allow scripts the opportunity to delay ready
			window.setTimeout( jQuery.ready );

		} else {

			// Use the handy event callback
			document.addEventListener( "DOMContentLoaded", completed );

			// A fallback to window.onload, that will always work
			window.addEventListener( "load", completed );
		}
	}
	return readyList.promise( obj );
};

// Kick off the DOM ready check even if the user does not
jQuery.ready.promise();




// Multifunctional method to get and set values of a collection
// The value/s can optionally be executed if it's a function
var access = function( elems, fn, key, value, chainable, emptyGet, raw ) {
	var i = 0,
		len = elems.length,
		bulk = key == null;

	// Sets many values
	if ( jQuery.type( key ) === "object" ) {
		chainable = true;
		for ( i in key ) {
			access( elems, fn, i, key[ i ], true, emptyGet, raw );
		}

	// Sets one value
	} else if ( value !== undefined ) {
		chainable = true;

		if ( !jQuery.isFunction( value ) ) {
			raw = true;
		}

		if ( bulk ) {

			// Bulk operations run against the entire set
			if ( raw ) {
				fn.call( elems, value );
				fn = null;

			// ...except when executing function values
			} else {
				bulk = fn;
				fn = function( elem, key, value ) {
					return bulk.call( jQuery( elem ), value );
				};
			}
		}

		if ( fn ) {
			for ( ; i < len; i++ ) {
				fn(
					elems[ i ], key, raw ?
					value :
					value.call( elems[ i ], i, fn( elems[ i ], key ) )
				);
			}
		}
	}

	return chainable ?
		elems :

		// Gets
		bulk ?
			fn.call( elems ) :
			len ? fn( elems[ 0 ], key ) : emptyGet;
};
var acceptData = function( owner ) {

	// Accepts only:
	//  - Node
	//    - Node.ELEMENT_NODE
	//    - Node.DOCUMENT_NODE
	//  - Object
	//    - Any
	/* jshint -W018 */
	return owner.nodeType === 1 || owner.nodeType === 9 || !( +owner.nodeType );
};




function Data() {
	this.expando = jQuery.expando + Data.uid++;
}

Data.uid = 1;

Data.prototype = {

	register: function( owner, initial ) {
		var value = initial || {};

		// If it is a node unlikely to be stringify-ed or looped over
		// use plain assignment
		if ( owner.nodeType ) {
			owner[ this.expando ] = value;

		// Otherwise secure it in a non-enumerable, non-writable property
		// configurability must be true to allow the property to be
		// deleted with the delete operator
		} else {
			Object.defineProperty( owner, this.expando, {
				value: value,
				writable: true,
				configurable: true
			} );
		}
		return owner[ this.expando ];
	},
	cache: function( owner ) {

		// We can accept data for non-element nodes in modern browsers,
		// but we should not, see #8335.
		// Always return an empty object.
		if ( !acceptData( owner ) ) {
			return {};
		}

		// Check if the owner object already has a cache
		var value = owner[ this.expando ];

		// If not, create one
		if ( !value ) {
			value = {};

			// We can accept data for non-element nodes in modern browsers,
			// but we should not, see #8335.
			// Always return an empty object.
			if ( acceptData( owner ) ) {

				// If it is a node unlikely to be stringify-ed or looped over
				// use plain assignment
				if ( owner.nodeType ) {
					owner[ this.expando ] = value;

				// Otherwise secure it in a non-enumerable property
				// configurable must be true to allow the property to be
				// deleted when data is removed
				} else {
					Object.defineProperty( owner, this.expando, {
						value: value,
						configurable: true
					} );
				}
			}
		}

		return value;
	},
	set: function( owner, data, value ) {
		var prop,
			cache = this.cache( owner );

		// Handle: [ owner, key, value ] args
		if ( typeof data === "string" ) {
			cache[ data ] = value;

		// Handle: [ owner, { properties } ] args
		} else {

			// Copy the properties one-by-one to the cache object
			for ( prop in data ) {
				cache[ prop ] = data[ prop ];
			}
		}
		return cache;
	},
	get: function( owner, key ) {
		return key === undefined ?
			this.cache( owner ) :
			owner[ this.expando ] && owner[ this.expando ][ key ];
	},
	access: function( owner, key, value ) {
		var stored;

		// In cases where either:
		//
		//   1. No key was specified
		//   2. A string key was specified, but no value provided
		//
		// Take the "read" path and allow the get method to determine
		// which value to return, respectively either:
		//
		//   1. The entire cache object
		//   2. The data stored at the key
		//
		if ( key === undefined ||
				( ( key && typeof key === "string" ) && value === undefined ) ) {

			stored = this.get( owner, key );

			return stored !== undefined ?
				stored : this.get( owner, jQuery.camelCase( key ) );
		}

		// When the key is not a string, or both a key and value
		// are specified, set or extend (existing objects) with either:
		//
		//   1. An object of properties
		//   2. A key and value
		//
		this.set( owner, key, value );

		// Since the "set" path can have two possible entry points
		// return the expected data based on which path was taken[*]
		return value !== undefined ? value : key;
	},
	remove: function( owner, key ) {
		var i, name, camel,
			cache = owner[ this.expando ];

		if ( cache === undefined ) {
			return;
		}

		if ( key === undefined ) {
			this.register( owner );

		} else {

			// Support array or space separated string of keys
			if ( jQuery.isArray( key ) ) {

				// If "name" is an array of keys...
				// When data is initially created, via ("key", "val") signature,
				// keys will be converted to camelCase.
				// Since there is no way to tell _how_ a key was added, remove
				// both plain key and camelCase key. #12786
				// This will only penalize the array argument path.
				name = key.concat( key.map( jQuery.camelCase ) );
			} else {
				camel = jQuery.camelCase( key );

				// Try the string as a key before any manipulation
				if ( key in cache ) {
					name = [ key, camel ];
				} else {

					// If a key with the spaces exists, use it.
					// Otherwise, create an array by matching non-whitespace
					name = camel;
					name = name in cache ?
						[ name ] : ( name.match( rnotwhite ) || [] );
				}
			}

			i = name.length;

			while ( i-- ) {
				delete cache[ name[ i ] ];
			}
		}

		// Remove the expando if there's no more data
		if ( key === undefined || jQuery.isEmptyObject( cache ) ) {

			// Support: Chrome <= 35-45+
			// Webkit & Blink performance suffers when deleting properties
			// from DOM nodes, so set to undefined instead
			// https://code.google.com/p/chromium/issues/detail?id=378607
			if ( owner.nodeType ) {
				owner[ this.expando ] = undefined;
			} else {
				delete owner[ this.expando ];
			}
		}
	},
	hasData: function( owner ) {
		var cache = owner[ this.expando ];
		return cache !== undefined && !jQuery.isEmptyObject( cache );
	}
};
var dataPriv = new Data();

var dataUser = new Data();



//	Implementation Summary
//
//	1. Enforce API surface and semantic compatibility with 1.9.x branch
//	2. Improve the module's maintainability by reducing the storage
//		paths to a single mechanism.
//	3. Use the same single mechanism to support "private" and "user" data.
//	4. _Never_ expose "private" data to user code (TODO: Drop _data, _removeData)
//	5. Avoid exposing implementation details on user objects (eg. expando properties)
//	6. Provide a clear path for implementation upgrade to WeakMap in 2014

var rbrace = /^(?:\{[\w\W]*\}|\[[\w\W]*\])$/,
	rmultiDash = /[A-Z]/g;

function dataAttr( elem, key, data ) {
	var name;

	// If nothing was found internally, try to fetch any
	// data from the HTML5 data-* attribute
	if ( data === undefined && elem.nodeType === 1 ) {
		name = "data-" + key.replace( rmultiDash, "-$&" ).toLowerCase();
		data = elem.getAttribute( name );

		if ( typeof data === "string" ) {
			try {
				data = data === "true" ? true :
					data === "false" ? false :
					data === "null" ? null :

					// Only convert to a number if it doesn't change the string
					+data + "" === data ? +data :
					rbrace.test( data ) ? jQuery.parseJSON( data ) :
					data;
			} catch ( e ) {}

			// Make sure we set the data so it isn't changed later
			dataUser.set( elem, key, data );
		} else {
			data = undefined;
		}
	}
	return data;
}

jQuery.extend( {
	hasData: function( elem ) {
		return dataUser.hasData( elem ) || dataPriv.hasData( elem );
	},

	data: function( elem, name, data ) {
		return dataUser.access( elem, name, data );
	},

	removeData: function( elem, name ) {
		dataUser.remove( elem, name );
	},

	// TODO: Now that all calls to _data and _removeData have been replaced
	// with direct calls to dataPriv methods, these can be deprecated.
	_data: function( elem, name, data ) {
		return dataPriv.access( elem, name, data );
	},

	_removeData: function( elem, name ) {
		dataPriv.remove( elem, name );
	}
} );

jQuery.fn.extend( {
	data: function( key, value ) {
		var i, name, data,
			elem = this[ 0 ],
			attrs = elem && elem.attributes;

		// Gets all values
		if ( key === undefined ) {
			if ( this.length ) {
				data = dataUser.get( elem );

				if ( elem.nodeType === 1 && !dataPriv.get( elem, "hasDataAttrs" ) ) {
					i = attrs.length;
					while ( i-- ) {

						// Support: IE11+
						// The attrs elements can be null (#14894)
						if ( attrs[ i ] ) {
							name = attrs[ i ].name;
							if ( name.indexOf( "data-" ) === 0 ) {
								name = jQuery.camelCase( name.slice( 5 ) );
								dataAttr( elem, name, data[ name ] );
							}
						}
					}
					dataPriv.set( elem, "hasDataAttrs", true );
				}
			}

			return data;
		}

		// Sets multiple values
		if ( typeof key === "object" ) {
			return this.each( function() {
				dataUser.set( this, key );
			} );
		}

		return access( this, function( value ) {
			var data, camelKey;

			// The calling jQuery object (element matches) is not empty
			// (and therefore has an element appears at this[ 0 ]) and the
			// `value` parameter was not undefined. An empty jQuery object
			// will result in `undefined` for elem = this[ 0 ] which will
			// throw an exception if an attempt to read a data cache is made.
			if ( elem && value === undefined ) {

				// Attempt to get data from the cache
				// with the key as-is
				data = dataUser.get( elem, key ) ||

					// Try to find dashed key if it exists (gh-2779)
					// This is for 2.2.x only
					dataUser.get( elem, key.replace( rmultiDash, "-$&" ).toLowerCase() );

				if ( data !== undefined ) {
					return data;
				}

				camelKey = jQuery.camelCase( key );

				// Attempt to get data from the cache
				// with the key camelized
				data = dataUser.get( elem, camelKey );
				if ( data !== undefined ) {
					return data;
				}

				// Attempt to "discover" the data in
				// HTML5 custom data-* attrs
				data = dataAttr( elem, camelKey, undefined );
				if ( data !== undefined ) {
					return data;
				}

				// We tried really hard, but the data doesn't exist.
				return;
			}

			// Set the data...
			camelKey = jQuery.camelCase( key );
			this.each( function() {

				// First, attempt to store a copy or reference of any
				// data that might've been store with a camelCased key.
				var data = dataUser.get( this, camelKey );

				// For HTML5 data-* attribute interop, we have to
				// store property names with dashes in a camelCase form.
				// This might not apply to all properties...*
				dataUser.set( this, camelKey, value );

				// *... In the case of properties that might _actually_
				// have dashes, we need to also store a copy of that
				// unchanged property.
				if ( key.indexOf( "-" ) > -1 && data !== undefined ) {
					dataUser.set( this, key, value );
				}
			} );
		}, null, value, arguments.length > 1, null, true );
	},

	removeData: function( key ) {
		return this.each( function() {
			dataUser.remove( this, key );
		} );
	}
} );


jQuery.extend( {
	queue: function( elem, type, data ) {
		var queue;

		if ( elem ) {
			type = ( type || "fx" ) + "queue";
			queue = dataPriv.get( elem, type );

			// Speed up dequeue by getting out quickly if this is just a lookup
			if ( data ) {
				if ( !queue || jQuery.isArray( data ) ) {
					queue = dataPriv.access( elem, type, jQuery.makeArray( data ) );
				} else {
					queue.push( data );
				}
			}
			return queue || [];
		}
	},

	dequeue: function( elem, type ) {
		type = type || "fx";

		var queue = jQuery.queue( elem, type ),
			startLength = queue.length,
			fn = queue.shift(),
			hooks = jQuery._queueHooks( elem, type ),
			next = function() {
				jQuery.dequeue( elem, type );
			};

		// If the fx queue is dequeued, always remove the progress sentinel
		if ( fn === "inprogress" ) {
			fn = queue.shift();
			startLength--;
		}

		if ( fn ) {

			// Add a progress sentinel to prevent the fx queue from being
			// automatically dequeued
			if ( type === "fx" ) {
				queue.unshift( "inprogress" );
			}

			// Clear up the last queue stop function
			delete hooks.stop;
			fn.call( elem, next, hooks );
		}

		if ( !startLength && hooks ) {
			hooks.empty.fire();
		}
	},

	// Not public - generate a queueHooks object, or return the current one
	_queueHooks: function( elem, type ) {
		var key = type + "queueHooks";
		return dataPriv.get( elem, key ) || dataPriv.access( elem, key, {
			empty: jQuery.Callbacks( "once memory" ).add( function() {
				dataPriv.remove( elem, [ type + "queue", key ] );
			} )
		} );
	}
} );

jQuery.fn.extend( {
	queue: function( type, data ) {
		var setter = 2;

		if ( typeof type !== "string" ) {
			data = type;
			type = "fx";
			setter--;
		}

		if ( arguments.length < setter ) {
			return jQuery.queue( this[ 0 ], type );
		}

		return data === undefined ?
			this :
			this.each( function() {
				var queue = jQuery.queue( this, type, data );

				// Ensure a hooks for this queue
				jQuery._queueHooks( this, type );

				if ( type === "fx" && queue[ 0 ] !== "inprogress" ) {
					jQuery.dequeue( this, type );
				}
			} );
	},
	dequeue: function( type ) {
		return this.each( function() {
			jQuery.dequeue( this, type );
		} );
	},
	clearQueue: function( type ) {
		return this.queue( type || "fx", [] );
	},

	// Get a promise resolved when queues of a certain type
	// are emptied (fx is the type by default)
	promise: function( type, obj ) {
		var tmp,
			count = 1,
			defer = jQuery.Deferred(),
			elements = this,
			i = this.length,
			resolve = function() {
				if ( !( --count ) ) {
					defer.resolveWith( elements, [ elements ] );
				}
			};

		if ( typeof type !== "string" ) {
			obj = type;
			type = undefined;
		}
		type = type || "fx";

		while ( i-- ) {
			tmp = dataPriv.get( elements[ i ], type + "queueHooks" );
			if ( tmp && tmp.empty ) {
				count++;
				tmp.empty.add( resolve );
			}
		}
		resolve();
		return defer.promise( obj );
	}
} );
var pnum = ( /[+-]?(?:\d*\.|)\d+(?:[eE][+-]?\d+|)/ ).source;

var rcssNum = new RegExp( "^(?:([+-])=|)(" + pnum + ")([a-z%]*)$", "i" );


var cssExpand = [ "Top", "Right", "Bottom", "Left" ];

var isHidden = function( elem, el ) {

		// isHidden might be called from jQuery#filter function;
		// in that case, element will be second argument
		elem = el || elem;
		return jQuery.css( elem, "display" ) === "none" ||
			!jQuery.contains( elem.ownerDocument, elem );
	};



function adjustCSS( elem, prop, valueParts, tween ) {
	var adjusted,
		scale = 1,
		maxIterations = 20,
		currentValue = tween ?
			function() { return tween.cur(); } :
			function() { return jQuery.css( elem, prop, "" ); },
		initial = currentValue(),
		unit = valueParts && valueParts[ 3 ] || ( jQuery.cssNumber[ prop ] ? "" : "px" ),

		// Starting value computation is required for potential unit mismatches
		initialInUnit = ( jQuery.cssNumber[ prop ] || unit !== "px" && +initial ) &&
			rcssNum.exec( jQuery.css( elem, prop ) );

	if ( initialInUnit && initialInUnit[ 3 ] !== unit ) {

		// Trust units reported by jQuery.css
		unit = unit || initialInUnit[ 3 ];

		// Make sure we update the tween properties later on
		valueParts = valueParts || [];

		// Iteratively approximate from a nonzero starting point
		initialInUnit = +initial || 1;

		do {

			// If previous iteration zeroed out, double until we get *something*.
			// Use string for doubling so we don't accidentally see scale as unchanged below
			scale = scale || ".5";

			// Adjust and apply
			initialInUnit = initialInUnit / scale;
			jQuery.style( elem, prop, initialInUnit + unit );

		// Update scale, tolerating zero or NaN from tween.cur()
		// Break the loop if scale is unchanged or perfect, or if we've just had enough.
		} while (
			scale !== ( scale = currentValue() / initial ) && scale !== 1 && --maxIterations
		);
	}

	if ( valueParts ) {
		initialInUnit = +initialInUnit || +initial || 0;

		// Apply relative offset (+=/-=) if specified
		adjusted = valueParts[ 1 ] ?
			initialInUnit + ( valueParts[ 1 ] + 1 ) * valueParts[ 2 ] :
			+valueParts[ 2 ];
		if ( tween ) {
			tween.unit = unit;
			tween.start = initialInUnit;
			tween.end = adjusted;
		}
	}
	return adjusted;
}
var rcheckableType = ( /^(?:checkbox|radio)$/i );

var rtagName = ( /<([\w:-]+)/ );

var rscriptType = ( /^$|\/(?:java|ecma)script/i );



// We have to close these tags to support XHTML (#13200)
var wrapMap = {

	// Support: IE9
	option: [ 1, "<select multiple='multiple'>", "</select>" ],

	// XHTML parsers do not magically insert elements in the
	// same way that tag soup parsers do. So we cannot shorten
	// this by omitting <tbody> or other required elements.
	thead: [ 1, "<table>", "</table>" ],
	col: [ 2, "<table><colgroup>", "</colgroup></table>" ],
	tr: [ 2, "<table><tbody>", "</tbody></table>" ],
	td: [ 3, "<table><tbody><tr>", "</tr></tbody></table>" ],

	_default: [ 0, "", "" ]
};

// Support: IE9
wrapMap.optgroup = wrapMap.option;

wrapMap.tbody = wrapMap.tfoot = wrapMap.colgroup = wrapMap.caption = wrapMap.thead;
wrapMap.th = wrapMap.td;


function getAll( context, tag ) {

	// Support: IE9-11+
	// Use typeof to avoid zero-argument method invocation on host objects (#15151)
	var ret = typeof context.getElementsByTagName !== "undefined" ?
			context.getElementsByTagName( tag || "*" ) :
			typeof context.querySelectorAll !== "undefined" ?
				context.querySelectorAll( tag || "*" ) :
			[];

	return tag === undefined || tag && jQuery.nodeName( context, tag ) ?
		jQuery.merge( [ context ], ret ) :
		ret;
}


// Mark scripts as having already been evaluated
function setGlobalEval( elems, refElements ) {
	var i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		dataPriv.set(
			elems[ i ],
			"globalEval",
			!refElements || dataPriv.get( refElements[ i ], "globalEval" )
		);
	}
}


var rhtml = /<|&#?\w+;/;

function buildFragment( elems, context, scripts, selection, ignored ) {
	var elem, tmp, tag, wrap, contains, j,
		fragment = context.createDocumentFragment(),
		nodes = [],
		i = 0,
		l = elems.length;

	for ( ; i < l; i++ ) {
		elem = elems[ i ];

		if ( elem || elem === 0 ) {

			// Add nodes directly
			if ( jQuery.type( elem ) === "object" ) {

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, elem.nodeType ? [ elem ] : elem );

			// Convert non-html into a text node
			} else if ( !rhtml.test( elem ) ) {
				nodes.push( context.createTextNode( elem ) );

			// Convert html into DOM nodes
			} else {
				tmp = tmp || fragment.appendChild( context.createElement( "div" ) );

				// Deserialize a standard representation
				tag = ( rtagName.exec( elem ) || [ "", "" ] )[ 1 ].toLowerCase();
				wrap = wrapMap[ tag ] || wrapMap._default;
				tmp.innerHTML = wrap[ 1 ] + jQuery.htmlPrefilter( elem ) + wrap[ 2 ];

				// Descend through wrappers to the right content
				j = wrap[ 0 ];
				while ( j-- ) {
					tmp = tmp.lastChild;
				}

				// Support: Android<4.1, PhantomJS<2
				// push.apply(_, arraylike) throws on ancient WebKit
				jQuery.merge( nodes, tmp.childNodes );

				// Remember the top-level container
				tmp = fragment.firstChild;

				// Ensure the created nodes are orphaned (#12392)
				tmp.textContent = "";
			}
		}
	}

	// Remove wrapper from fragment
	fragment.textContent = "";

	i = 0;
	while ( ( elem = nodes[ i++ ] ) ) {

		// Skip elements already in the context collection (trac-4087)
		if ( selection && jQuery.inArray( elem, selection ) > -1 ) {
			if ( ignored ) {
				ignored.push( elem );
			}
			continue;
		}

		contains = jQuery.contains( elem.ownerDocument, elem );

		// Append to fragment
		tmp = getAll( fragment.appendChild( elem ), "script" );

		// Preserve script evaluation history
		if ( contains ) {
			setGlobalEval( tmp );
		}

		// Capture executables
		if ( scripts ) {
			j = 0;
			while ( ( elem = tmp[ j++ ] ) ) {
				if ( rscriptType.test( elem.type || "" ) ) {
					scripts.push( elem );
				}
			}
		}
	}

	return fragment;
}


( function() {
	var fragment = document.createDocumentFragment(),
		div = fragment.appendChild( document.createElement( "div" ) ),
		input = document.createElement( "input" );

	// Support: Android 4.0-4.3, Safari<=5.1
	// Check state lost if the name is set (#11217)
	// Support: Windows Web Apps (WWA)
	// `name` and `type` must use .setAttribute for WWA (#14901)
	input.setAttribute( "type", "radio" );
	input.setAttribute( "checked", "checked" );
	input.setAttribute( "name", "t" );

	div.appendChild( input );

	// Support: Safari<=5.1, Android<4.2
	// Older WebKit doesn't clone checked state correctly in fragments
	support.checkClone = div.cloneNode( true ).cloneNode( true ).lastChild.checked;

	// Support: IE<=11+
	// Make sure textarea (and checkbox) defaultValue is properly cloned
	div.innerHTML = "<textarea>x</textarea>";
	support.noCloneChecked = !!div.cloneNode( true ).lastChild.defaultValue;
} )();


var
	rkeyEvent = /^key/,
	rmouseEvent = /^(?:mouse|pointer|contextmenu|drag|drop)|click/,
	rtypenamespace = /^([^.]*)(?:\.(.+)|)/;

function returnTrue() {
	return true;
}

function returnFalse() {
	return false;
}

// Support: IE9
// See #13393 for more info
function safeActiveElement() {
	try {
		return document.activeElement;
	} catch ( err ) { }
}

function on( elem, types, selector, data, fn, one ) {
	var origFn, type;

	// Types can be a map of types/handlers
	if ( typeof types === "object" ) {

		// ( types-Object, selector, data )
		if ( typeof selector !== "string" ) {

			// ( types-Object, data )
			data = data || selector;
			selector = undefined;
		}
		for ( type in types ) {
			on( elem, type, selector, data, types[ type ], one );
		}
		return elem;
	}

	if ( data == null && fn == null ) {

		// ( types, fn )
		fn = selector;
		data = selector = undefined;
	} else if ( fn == null ) {
		if ( typeof selector === "string" ) {

			// ( types, selector, fn )
			fn = data;
			data = undefined;
		} else {

			// ( types, data, fn )
			fn = data;
			data = selector;
			selector = undefined;
		}
	}
	if ( fn === false ) {
		fn = returnFalse;
	} else if ( !fn ) {
		return this;
	}

	if ( one === 1 ) {
		origFn = fn;
		fn = function( event ) {

			// Can use an empty set, since event contains the info
			jQuery().off( event );
			return origFn.apply( this, arguments );
		};

		// Use same guid so caller can remove using origFn
		fn.guid = origFn.guid || ( origFn.guid = jQuery.guid++ );
	}
	return elem.each( function() {
		jQuery.event.add( this, types, fn, data, selector );
	} );
}

/*
 * Helper functions for managing events -- not part of the public interface.
 * Props to Dean Edwards' addEvent library for many of the ideas.
 */
jQuery.event = {

	global: {},

	add: function( elem, types, handler, data, selector ) {

		var handleObjIn, eventHandle, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.get( elem );

		// Don't attach events to noData or text/comment nodes (but allow plain objects)
		if ( !elemData ) {
			return;
		}

		// Caller can pass in an object of custom data in lieu of the handler
		if ( handler.handler ) {
			handleObjIn = handler;
			handler = handleObjIn.handler;
			selector = handleObjIn.selector;
		}

		// Make sure that the handler has a unique ID, used to find/remove it later
		if ( !handler.guid ) {
			handler.guid = jQuery.guid++;
		}

		// Init the element's event structure and main handler, if this is the first
		if ( !( events = elemData.events ) ) {
			events = elemData.events = {};
		}
		if ( !( eventHandle = elemData.handle ) ) {
			eventHandle = elemData.handle = function( e ) {

				// Discard the second event of a jQuery.event.trigger() and
				// when an event is called after a page has unloaded
				return typeof jQuery !== "undefined" && jQuery.event.triggered !== e.type ?
					jQuery.event.dispatch.apply( elem, arguments ) : undefined;
			};
		}

		// Handle multiple events separated by a space
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// There *must* be a type, no attaching namespace-only handlers
			if ( !type ) {
				continue;
			}

			// If event changes its type, use the special event handlers for the changed type
			special = jQuery.event.special[ type ] || {};

			// If selector defined, determine special event api type, otherwise given type
			type = ( selector ? special.delegateType : special.bindType ) || type;

			// Update special based on newly reset type
			special = jQuery.event.special[ type ] || {};

			// handleObj is passed to all event handlers
			handleObj = jQuery.extend( {
				type: type,
				origType: origType,
				data: data,
				handler: handler,
				guid: handler.guid,
				selector: selector,
				needsContext: selector && jQuery.expr.match.needsContext.test( selector ),
				namespace: namespaces.join( "." )
			}, handleObjIn );

			// Init the event handler queue if we're the first
			if ( !( handlers = events[ type ] ) ) {
				handlers = events[ type ] = [];
				handlers.delegateCount = 0;

				// Only use addEventListener if the special events handler returns false
				if ( !special.setup ||
					special.setup.call( elem, data, namespaces, eventHandle ) === false ) {

					if ( elem.addEventListener ) {
						elem.addEventListener( type, eventHandle );
					}
				}
			}

			if ( special.add ) {
				special.add.call( elem, handleObj );

				if ( !handleObj.handler.guid ) {
					handleObj.handler.guid = handler.guid;
				}
			}

			// Add to the element's handler list, delegates in front
			if ( selector ) {
				handlers.splice( handlers.delegateCount++, 0, handleObj );
			} else {
				handlers.push( handleObj );
			}

			// Keep track of which events have ever been used, for event optimization
			jQuery.event.global[ type ] = true;
		}

	},

	// Detach an event or set of events from an element
	remove: function( elem, types, handler, selector, mappedTypes ) {

		var j, origCount, tmp,
			events, t, handleObj,
			special, handlers, type, namespaces, origType,
			elemData = dataPriv.hasData( elem ) && dataPriv.get( elem );

		if ( !elemData || !( events = elemData.events ) ) {
			return;
		}

		// Once for each type.namespace in types; type may be omitted
		types = ( types || "" ).match( rnotwhite ) || [ "" ];
		t = types.length;
		while ( t-- ) {
			tmp = rtypenamespace.exec( types[ t ] ) || [];
			type = origType = tmp[ 1 ];
			namespaces = ( tmp[ 2 ] || "" ).split( "." ).sort();

			// Unbind all events (on this namespace, if provided) for the element
			if ( !type ) {
				for ( type in events ) {
					jQuery.event.remove( elem, type + types[ t ], handler, selector, true );
				}
				continue;
			}

			special = jQuery.event.special[ type ] || {};
			type = ( selector ? special.delegateType : special.bindType ) || type;
			handlers = events[ type ] || [];
			tmp = tmp[ 2 ] &&
				new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" );

			// Remove matching events
			origCount = j = handlers.length;
			while ( j-- ) {
				handleObj = handlers[ j ];

				if ( ( mappedTypes || origType === handleObj.origType ) &&
					( !handler || handler.guid === handleObj.guid ) &&
					( !tmp || tmp.test( handleObj.namespace ) ) &&
					( !selector || selector === handleObj.selector ||
						selector === "**" && handleObj.selector ) ) {
					handlers.splice( j, 1 );

					if ( handleObj.selector ) {
						handlers.delegateCount--;
					}
					if ( special.remove ) {
						special.remove.call( elem, handleObj );
					}
				}
			}

			// Remove generic event handler if we removed something and no more handlers exist
			// (avoids potential for endless recursion during removal of special event handlers)
			if ( origCount && !handlers.length ) {
				if ( !special.teardown ||
					special.teardown.call( elem, namespaces, elemData.handle ) === false ) {

					jQuery.removeEvent( elem, type, elemData.handle );
				}

				delete events[ type ];
			}
		}

		// Remove data and the expando if it's no longer used
		if ( jQuery.isEmptyObject( events ) ) {
			dataPriv.remove( elem, "handle events" );
		}
	},

	dispatch: function( event ) {

		// Make a writable jQuery.Event from the native event object
		event = jQuery.event.fix( event );

		var i, j, ret, matched, handleObj,
			handlerQueue = [],
			args = slice.call( arguments ),
			handlers = ( dataPriv.get( this, "events" ) || {} )[ event.type ] || [],
			special = jQuery.event.special[ event.type ] || {};

		// Use the fix-ed jQuery.Event rather than the (read-only) native event
		args[ 0 ] = event;
		event.delegateTarget = this;

		// Call the preDispatch hook for the mapped type, and let it bail if desired
		if ( special.preDispatch && special.preDispatch.call( this, event ) === false ) {
			return;
		}

		// Determine handlers
		handlerQueue = jQuery.event.handlers.call( this, event, handlers );

		// Run delegates first; they may want to stop propagation beneath us
		i = 0;
		while ( ( matched = handlerQueue[ i++ ] ) && !event.isPropagationStopped() ) {
			event.currentTarget = matched.elem;

			j = 0;
			while ( ( handleObj = matched.handlers[ j++ ] ) &&
				!event.isImmediatePropagationStopped() ) {

				// Triggered event must either 1) have no namespace, or 2) have namespace(s)
				// a subset or equal to those in the bound event (both can have no namespace).
				if ( !event.rnamespace || event.rnamespace.test( handleObj.namespace ) ) {

					event.handleObj = handleObj;
					event.data = handleObj.data;

					ret = ( ( jQuery.event.special[ handleObj.origType ] || {} ).handle ||
						handleObj.handler ).apply( matched.elem, args );

					if ( ret !== undefined ) {
						if ( ( event.result = ret ) === false ) {
							event.preventDefault();
							event.stopPropagation();
						}
					}
				}
			}
		}

		// Call the postDispatch hook for the mapped type
		if ( special.postDispatch ) {
			special.postDispatch.call( this, event );
		}

		return event.result;
	},

	handlers: function( event, handlers ) {
		var i, matches, sel, handleObj,
			handlerQueue = [],
			delegateCount = handlers.delegateCount,
			cur = event.target;

		// Support (at least): Chrome, IE9
		// Find delegate handlers
		// Black-hole SVG <use> instance trees (#13180)
		//
		// Support: Firefox<=42+
		// Avoid non-left-click in FF but don't block IE radio events (#3861, gh-2343)
		if ( delegateCount && cur.nodeType &&
			( event.type !== "click" || isNaN( event.button ) || event.button < 1 ) ) {

			for ( ; cur !== this; cur = cur.parentNode || this ) {

				// Don't check non-elements (#13208)
				// Don't process clicks on disabled elements (#6911, #8165, #11382, #11764)
				if ( cur.nodeType === 1 && ( cur.disabled !== true || event.type !== "click" ) ) {
					matches = [];
					for ( i = 0; i < delegateCount; i++ ) {
						handleObj = handlers[ i ];

						// Don't conflict with Object.prototype properties (#13203)
						sel = handleObj.selector + " ";

						if ( matches[ sel ] === undefined ) {
							matches[ sel ] = handleObj.needsContext ?
								jQuery( sel, this ).index( cur ) > -1 :
								jQuery.find( sel, this, null, [ cur ] ).length;
						}
						if ( matches[ sel ] ) {
							matches.push( handleObj );
						}
					}
					if ( matches.length ) {
						handlerQueue.push( { elem: cur, handlers: matches } );
					}
				}
			}
		}

		// Add the remaining (directly-bound) handlers
		if ( delegateCount < handlers.length ) {
			handlerQueue.push( { elem: this, handlers: handlers.slice( delegateCount ) } );
		}

		return handlerQueue;
	},

	// Includes some event props shared by KeyEvent and MouseEvent
	props: ( "altKey bubbles cancelable ctrlKey currentTarget detail eventPhase " +
		"metaKey relatedTarget shiftKey target timeStamp view which" ).split( " " ),

	fixHooks: {},

	keyHooks: {
		props: "char charCode key keyCode".split( " " ),
		filter: function( event, original ) {

			// Add which for key events
			if ( event.which == null ) {
				event.which = original.charCode != null ? original.charCode : original.keyCode;
			}

			return event;
		}
	},

	mouseHooks: {
		props: ( "button buttons clientX clientY offsetX offsetY pageX pageY " +
			"screenX screenY toElement" ).split( " " ),
		filter: function( event, original ) {
			var eventDoc, doc, body,
				button = original.button;

			// Calculate pageX/Y if missing and clientX/Y available
			if ( event.pageX == null && original.clientX != null ) {
				eventDoc = event.target.ownerDocument || document;
				doc = eventDoc.documentElement;
				body = eventDoc.body;

				event.pageX = original.clientX +
					( doc && doc.scrollLeft || body && body.scrollLeft || 0 ) -
					( doc && doc.clientLeft || body && body.clientLeft || 0 );
				event.pageY = original.clientY +
					( doc && doc.scrollTop  || body && body.scrollTop  || 0 ) -
					( doc && doc.clientTop  || body && body.clientTop  || 0 );
			}

			// Add which for click: 1 === left; 2 === middle; 3 === right
			// Note: button is not normalized, so don't use it
			if ( !event.which && button !== undefined ) {
				event.which = ( button & 1 ? 1 : ( button & 2 ? 3 : ( button & 4 ? 2 : 0 ) ) );
			}

			return event;
		}
	},

	fix: function( event ) {
		if ( event[ jQuery.expando ] ) {
			return event;
		}

		// Create a writable copy of the event object and normalize some properties
		var i, prop, copy,
			type = event.type,
			originalEvent = event,
			fixHook = this.fixHooks[ type ];

		if ( !fixHook ) {
			this.fixHooks[ type ] = fixHook =
				rmouseEvent.test( type ) ? this.mouseHooks :
				rkeyEvent.test( type ) ? this.keyHooks :
				{};
		}
		copy = fixHook.props ? this.props.concat( fixHook.props ) : this.props;

		event = new jQuery.Event( originalEvent );

		i = copy.length;
		while ( i-- ) {
			prop = copy[ i ];
			event[ prop ] = originalEvent[ prop ];
		}

		// Support: Cordova 2.5 (WebKit) (#13255)
		// All events should have a target; Cordova deviceready doesn't
		if ( !event.target ) {
			event.target = document;
		}

		// Support: Safari 6.0+, Chrome<28
		// Target should not be a text node (#504, #13143)
		if ( event.target.nodeType === 3 ) {
			event.target = event.target.parentNode;
		}

		return fixHook.filter ? fixHook.filter( event, originalEvent ) : event;
	},

	special: {
		load: {

			// Prevent triggered image.load events from bubbling to window.load
			noBubble: true
		},
		focus: {

			// Fire native event if possible so blur/focus sequence is correct
			trigger: function() {
				if ( this !== safeActiveElement() && this.focus ) {
					this.focus();
					return false;
				}
			},
			delegateType: "focusin"
		},
		blur: {
			trigger: function() {
				if ( this === safeActiveElement() && this.blur ) {
					this.blur();
					return false;
				}
			},
			delegateType: "focusout"
		},
		click: {

			// For checkbox, fire native event so checked state will be right
			trigger: function() {
				if ( this.type === "checkbox" && this.click && jQuery.nodeName( this, "input" ) ) {
					this.click();
					return false;
				}
			},

			// For cross-browser consistency, don't fire native .click() on links
			_default: function( event ) {
				return jQuery.nodeName( event.target, "a" );
			}
		},

		beforeunload: {
			postDispatch: function( event ) {

				// Support: Firefox 20+
				// Firefox doesn't alert if the returnValue field is not set.
				if ( event.result !== undefined && event.originalEvent ) {
					event.originalEvent.returnValue = event.result;
				}
			}
		}
	}
};

jQuery.removeEvent = function( elem, type, handle ) {

	// This "if" is needed for plain objects
	if ( elem.removeEventListener ) {
		elem.removeEventListener( type, handle );
	}
};

jQuery.Event = function( src, props ) {

	// Allow instantiation without the 'new' keyword
	if ( !( this instanceof jQuery.Event ) ) {
		return new jQuery.Event( src, props );
	}

	// Event object
	if ( src && src.type ) {
		this.originalEvent = src;
		this.type = src.type;

		// Events bubbling up the document may have been marked as prevented
		// by a handler lower down the tree; reflect the correct value.
		this.isDefaultPrevented = src.defaultPrevented ||
				src.defaultPrevented === undefined &&

				// Support: Android<4.0
				src.returnValue === false ?
			returnTrue :
			returnFalse;

	// Event type
	} else {
		this.type = src;
	}

	// Put explicitly provided properties onto the event object
	if ( props ) {
		jQuery.extend( this, props );
	}

	// Create a timestamp if incoming event doesn't have one
	this.timeStamp = src && src.timeStamp || jQuery.now();

	// Mark it as fixed
	this[ jQuery.expando ] = true;
};

// jQuery.Event is based on DOM3 Events as specified by the ECMAScript Language Binding
// http://www.w3.org/TR/2003/WD-DOM-Level-3-Events-20030331/ecma-script-binding.html
jQuery.Event.prototype = {
	constructor: jQuery.Event,
	isDefaultPrevented: returnFalse,
	isPropagationStopped: returnFalse,
	isImmediatePropagationStopped: returnFalse,

	preventDefault: function() {
		var e = this.originalEvent;

		this.isDefaultPrevented = returnTrue;

		if ( e ) {
			e.preventDefault();
		}
	},
	stopPropagation: function() {
		var e = this.originalEvent;

		this.isPropagationStopped = returnTrue;

		if ( e ) {
			e.stopPropagation();
		}
	},
	stopImmediatePropagation: function() {
		var e = this.originalEvent;

		this.isImmediatePropagationStopped = returnTrue;

		if ( e ) {
			e.stopImmediatePropagation();
		}

		this.stopPropagation();
	}
};

// Create mouseenter/leave events using mouseover/out and event-time checks
// so that event delegation works in jQuery.
// Do the same for pointerenter/pointerleave and pointerover/pointerout
//
// Support: Safari 7 only
// Safari sends mouseenter too often; see:
// https://code.google.com/p/chromium/issues/detail?id=470258
// for the description of the bug (it existed in older Chrome versions as well).
jQuery.each( {
	mouseenter: "mouseover",
	mouseleave: "mouseout",
	pointerenter: "pointerover",
	pointerleave: "pointerout"
}, function( orig, fix ) {
	jQuery.event.special[ orig ] = {
		delegateType: fix,
		bindType: fix,

		handle: function( event ) {
			var ret,
				target = this,
				related = event.relatedTarget,
				handleObj = event.handleObj;

			// For mouseenter/leave call the handler if related is outside the target.
			// NB: No relatedTarget if the mouse left/entered the browser window
			if ( !related || ( related !== target && !jQuery.contains( target, related ) ) ) {
				event.type = handleObj.origType;
				ret = handleObj.handler.apply( this, arguments );
				event.type = fix;
			}
			return ret;
		}
	};
} );

jQuery.fn.extend( {
	on: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn );
	},
	one: function( types, selector, data, fn ) {
		return on( this, types, selector, data, fn, 1 );
	},
	off: function( types, selector, fn ) {
		var handleObj, type;
		if ( types && types.preventDefault && types.handleObj ) {

			// ( event )  dispatched jQuery.Event
			handleObj = types.handleObj;
			jQuery( types.delegateTarget ).off(
				handleObj.namespace ?
					handleObj.origType + "." + handleObj.namespace :
					handleObj.origType,
				handleObj.selector,
				handleObj.handler
			);
			return this;
		}
		if ( typeof types === "object" ) {

			// ( types-object [, selector] )
			for ( type in types ) {
				this.off( type, selector, types[ type ] );
			}
			return this;
		}
		if ( selector === false || typeof selector === "function" ) {

			// ( types [, fn] )
			fn = selector;
			selector = undefined;
		}
		if ( fn === false ) {
			fn = returnFalse;
		}
		return this.each( function() {
			jQuery.event.remove( this, types, fn, selector );
		} );
	}
} );


var
	rxhtmlTag = /<(?!area|br|col|embed|hr|img|input|link|meta|param)(([\w:-]+)[^>]*)\/>/gi,

	// Support: IE 10-11, Edge 10240+
	// In IE/Edge using regex groups here causes severe slowdowns.
	// See https://connect.microsoft.com/IE/feedback/details/1736512/
	rnoInnerhtml = /<script|<style|<link/i,

	// checked="checked" or checked
	rchecked = /checked\s*(?:[^=]|=\s*.checked.)/i,
	rscriptTypeMasked = /^true\/(.*)/,
	rcleanScript = /^\s*<!(?:\[CDATA\[|--)|(?:\]\]|--)>\s*$/g;

function manipulationTarget( elem, content ) {
	if ( jQuery.nodeName( elem, "table" ) &&
		jQuery.nodeName( content.nodeType !== 11 ? content : content.firstChild, "tr" ) ) {

		return elem.getElementsByTagName( "tbody" )[ 0 ] || elem;
	}

	return elem;
}

// Replace/restore the type attribute of script elements for safe DOM manipulation
function disableScript( elem ) {
	elem.type = ( elem.getAttribute( "type" ) !== null ) + "/" + elem.type;
	return elem;
}
function restoreScript( elem ) {
	var match = rscriptTypeMasked.exec( elem.type );

	if ( match ) {
		elem.type = match[ 1 ];
	} else {
		elem.removeAttribute( "type" );
	}

	return elem;
}

function cloneCopyEvent( src, dest ) {
	var i, l, type, pdataOld, pdataCur, udataOld, udataCur, events;

	if ( dest.nodeType !== 1 ) {
		return;
	}

	// 1. Copy private data: events, handlers, etc.
	if ( dataPriv.hasData( src ) ) {
		pdataOld = dataPriv.access( src );
		pdataCur = dataPriv.set( dest, pdataOld );
		events = pdataOld.events;

		if ( events ) {
			delete pdataCur.handle;
			pdataCur.events = {};

			for ( type in events ) {
				for ( i = 0, l = events[ type ].length; i < l; i++ ) {
					jQuery.event.add( dest, type, events[ type ][ i ] );
				}
			}
		}
	}

	// 2. Copy user data
	if ( dataUser.hasData( src ) ) {
		udataOld = dataUser.access( src );
		udataCur = jQuery.extend( {}, udataOld );

		dataUser.set( dest, udataCur );
	}
}

// Fix IE bugs, see support tests
function fixInput( src, dest ) {
	var nodeName = dest.nodeName.toLowerCase();

	// Fails to persist the checked state of a cloned checkbox or radio button.
	if ( nodeName === "input" && rcheckableType.test( src.type ) ) {
		dest.checked = src.checked;

	// Fails to return the selected option to the default selected state when cloning options
	} else if ( nodeName === "input" || nodeName === "textarea" ) {
		dest.defaultValue = src.defaultValue;
	}
}

function domManip( collection, args, callback, ignored ) {

	// Flatten any nested arrays
	args = concat.apply( [], args );

	var fragment, first, scripts, hasScripts, node, doc,
		i = 0,
		l = collection.length,
		iNoClone = l - 1,
		value = args[ 0 ],
		isFunction = jQuery.isFunction( value );

	// We can't cloneNode fragments that contain checked, in WebKit
	if ( isFunction ||
			( l > 1 && typeof value === "string" &&
				!support.checkClone && rchecked.test( value ) ) ) {
		return collection.each( function( index ) {
			var self = collection.eq( index );
			if ( isFunction ) {
				args[ 0 ] = value.call( this, index, self.html() );
			}
			domManip( self, args, callback, ignored );
		} );
	}

	if ( l ) {
		fragment = buildFragment( args, collection[ 0 ].ownerDocument, false, collection, ignored );
		first = fragment.firstChild;

		if ( fragment.childNodes.length === 1 ) {
			fragment = first;
		}

		// Require either new content or an interest in ignored elements to invoke the callback
		if ( first || ignored ) {
			scripts = jQuery.map( getAll( fragment, "script" ), disableScript );
			hasScripts = scripts.length;

			// Use the original fragment for the last item
			// instead of the first because it can end up
			// being emptied incorrectly in certain situations (#8070).
			for ( ; i < l; i++ ) {
				node = fragment;

				if ( i !== iNoClone ) {
					node = jQuery.clone( node, true, true );

					// Keep references to cloned scripts for later restoration
					if ( hasScripts ) {

						// Support: Android<4.1, PhantomJS<2
						// push.apply(_, arraylike) throws on ancient WebKit
						jQuery.merge( scripts, getAll( node, "script" ) );
					}
				}

				callback.call( collection[ i ], node, i );
			}

			if ( hasScripts ) {
				doc = scripts[ scripts.length - 1 ].ownerDocument;

				// Reenable scripts
				jQuery.map( scripts, restoreScript );

				// Evaluate executable scripts on first document insertion
				for ( i = 0; i < hasScripts; i++ ) {
					node = scripts[ i ];
					if ( rscriptType.test( node.type || "" ) &&
						!dataPriv.access( node, "globalEval" ) &&
						jQuery.contains( doc, node ) ) {

						if ( node.src ) {

							// Optional AJAX dependency, but won't run scripts if not present
							if ( jQuery._evalUrl ) {
								jQuery._evalUrl( node.src );
							}
						} else {
							jQuery.globalEval( node.textContent.replace( rcleanScript, "" ) );
						}
					}
				}
			}
		}
	}

	return collection;
}

function remove( elem, selector, keepData ) {
	var node,
		nodes = selector ? jQuery.filter( selector, elem ) : elem,
		i = 0;

	for ( ; ( node = nodes[ i ] ) != null; i++ ) {
		if ( !keepData && node.nodeType === 1 ) {
			jQuery.cleanData( getAll( node ) );
		}

		if ( node.parentNode ) {
			if ( keepData && jQuery.contains( node.ownerDocument, node ) ) {
				setGlobalEval( getAll( node, "script" ) );
			}
			node.parentNode.removeChild( node );
		}
	}

	return elem;
}

jQuery.extend( {
	htmlPrefilter: function( html ) {
		return html.replace( rxhtmlTag, "<$1></$2>" );
	},

	clone: function( elem, dataAndEvents, deepDataAndEvents ) {
		var i, l, srcElements, destElements,
			clone = elem.cloneNode( true ),
			inPage = jQuery.contains( elem.ownerDocument, elem );

		// Fix IE cloning issues
		if ( !support.noCloneChecked && ( elem.nodeType === 1 || elem.nodeType === 11 ) &&
				!jQuery.isXMLDoc( elem ) ) {

			// We eschew Sizzle here for performance reasons: http://jsperf.com/getall-vs-sizzle/2
			destElements = getAll( clone );
			srcElements = getAll( elem );

			for ( i = 0, l = srcElements.length; i < l; i++ ) {
				fixInput( srcElements[ i ], destElements[ i ] );
			}
		}

		// Copy the events from the original to the clone
		if ( dataAndEvents ) {
			if ( deepDataAndEvents ) {
				srcElements = srcElements || getAll( elem );
				destElements = destElements || getAll( clone );

				for ( i = 0, l = srcElements.length; i < l; i++ ) {
					cloneCopyEvent( srcElements[ i ], destElements[ i ] );
				}
			} else {
				cloneCopyEvent( elem, clone );
			}
		}

		// Preserve script evaluation history
		destElements = getAll( clone, "script" );
		if ( destElements.length > 0 ) {
			setGlobalEval( destElements, !inPage && getAll( elem, "script" ) );
		}

		// Return the cloned set
		return clone;
	},

	cleanData: function( elems ) {
		var data, elem, type,
			special = jQuery.event.special,
			i = 0;

		for ( ; ( elem = elems[ i ] ) !== undefined; i++ ) {
			if ( acceptData( elem ) ) {
				if ( ( data = elem[ dataPriv.expando ] ) ) {
					if ( data.events ) {
						for ( type in data.events ) {
							if ( special[ type ] ) {
								jQuery.event.remove( elem, type );

							// This is a shortcut to avoid jQuery.event.remove's overhead
							} else {
								jQuery.removeEvent( elem, type, data.handle );
							}
						}
					}

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataPriv.expando ] = undefined;
				}
				if ( elem[ dataUser.expando ] ) {

					// Support: Chrome <= 35-45+
					// Assign undefined instead of using delete, see Data#remove
					elem[ dataUser.expando ] = undefined;
				}
			}
		}
	}
} );

jQuery.fn.extend( {

	// Keep domManip exposed until 3.0 (gh-2225)
	domManip: domManip,

	detach: function( selector ) {
		return remove( this, selector, true );
	},

	remove: function( selector ) {
		return remove( this, selector );
	},

	text: function( value ) {
		return access( this, function( value ) {
			return value === undefined ?
				jQuery.text( this ) :
				this.empty().each( function() {
					if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
						this.textContent = value;
					}
				} );
		}, null, value, arguments.length );
	},

	append: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.appendChild( elem );
			}
		} );
	},

	prepend: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.nodeType === 1 || this.nodeType === 11 || this.nodeType === 9 ) {
				var target = manipulationTarget( this, elem );
				target.insertBefore( elem, target.firstChild );
			}
		} );
	},

	before: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this );
			}
		} );
	},

	after: function() {
		return domManip( this, arguments, function( elem ) {
			if ( this.parentNode ) {
				this.parentNode.insertBefore( elem, this.nextSibling );
			}
		} );
	},

	empty: function() {
		var elem,
			i = 0;

		for ( ; ( elem = this[ i ] ) != null; i++ ) {
			if ( elem.nodeType === 1 ) {

				// Prevent memory leaks
				jQuery.cleanData( getAll( elem, false ) );

				// Remove any remaining nodes
				elem.textContent = "";
			}
		}

		return this;
	},

	clone: function( dataAndEvents, deepDataAndEvents ) {
		dataAndEvents = dataAndEvents == null ? false : dataAndEvents;
		deepDataAndEvents = deepDataAndEvents == null ? dataAndEvents : deepDataAndEvents;

		return this.map( function() {
			return jQuery.clone( this, dataAndEvents, deepDataAndEvents );
		} );
	},

	html: function( value ) {
		return access( this, function( value ) {
			var elem = this[ 0 ] || {},
				i = 0,
				l = this.length;

			if ( value === undefined && elem.nodeType === 1 ) {
				return elem.innerHTML;
			}

			// See if we can take a shortcut and just use innerHTML
			if ( typeof value === "string" && !rnoInnerhtml.test( value ) &&
				!wrapMap[ ( rtagName.exec( value ) || [ "", "" ] )[ 1 ].toLowerCase() ] ) {

				value = jQuery.htmlPrefilter( value );

				try {
					for ( ; i < l; i++ ) {
						elem = this[ i ] || {};

						// Remove element nodes and prevent memory leaks
						if ( elem.nodeType === 1 ) {
							jQuery.cleanData( getAll( elem, false ) );
							elem.innerHTML = value;
						}
					}

					elem = 0;

				// If using innerHTML throws an exception, use the fallback method
				} catch ( e ) {}
			}

			if ( elem ) {
				this.empty().append( value );
			}
		}, null, value, arguments.length );
	},

	replaceWith: function() {
		var ignored = [];

		// Make the changes, replacing each non-ignored context element with the new content
		return domManip( this, arguments, function( elem ) {
			var parent = this.parentNode;

			if ( jQuery.inArray( this, ignored ) < 0 ) {
				jQuery.cleanData( getAll( this ) );
				if ( parent ) {
					parent.replaceChild( elem, this );
				}
			}

		// Force callback invocation
		}, ignored );
	}
} );

jQuery.each( {
	appendTo: "append",
	prependTo: "prepend",
	insertBefore: "before",
	insertAfter: "after",
	replaceAll: "replaceWith"
}, function( name, original ) {
	jQuery.fn[ name ] = function( selector ) {
		var elems,
			ret = [],
			insert = jQuery( selector ),
			last = insert.length - 1,
			i = 0;

		for ( ; i <= last; i++ ) {
			elems = i === last ? this : this.clone( true );
			jQuery( insert[ i ] )[ original ]( elems );

			// Support: QtWebKit
			// .get() because push.apply(_, arraylike) throws
			push.apply( ret, elems.get() );
		}

		return this.pushStack( ret );
	};
} );


var iframe,
	elemdisplay = {

		// Support: Firefox
		// We have to pre-define these values for FF (#10227)
		HTML: "block",
		BODY: "block"
	};

/**
 * Retrieve the actual display of a element
 * @param {String} name nodeName of the element
 * @param {Object} doc Document object
 */

// Called only from within defaultDisplay
function actualDisplay( name, doc ) {
	var elem = jQuery( doc.createElement( name ) ).appendTo( doc.body ),

		display = jQuery.css( elem[ 0 ], "display" );

	// We don't have any data stored on the element,
	// so use "detach" method as fast way to get rid of the element
	elem.detach();

	return display;
}

/**
 * Try to determine the default display value of an element
 * @param {String} nodeName
 */
function defaultDisplay( nodeName ) {
	var doc = document,
		display = elemdisplay[ nodeName ];

	if ( !display ) {
		display = actualDisplay( nodeName, doc );

		// If the simple way fails, read from inside an iframe
		if ( display === "none" || !display ) {

			// Use the already-created iframe if possible
			iframe = ( iframe || jQuery( "<iframe frameborder='0' width='0' height='0'/>" ) )
				.appendTo( doc.documentElement );

			// Always write a new HTML skeleton so Webkit and Firefox don't choke on reuse
			doc = iframe[ 0 ].contentDocument;

			// Support: IE
			doc.write();
			doc.close();

			display = actualDisplay( nodeName, doc );
			iframe.detach();
		}

		// Store the correct default display
		elemdisplay[ nodeName ] = display;
	}

	return display;
}
var rmargin = ( /^margin/ );

var rnumnonpx = new RegExp( "^(" + pnum + ")(?!px)[a-z%]+$", "i" );

var getStyles = function( elem ) {

		// Support: IE<=11+, Firefox<=30+ (#15098, #14150)
		// IE throws on elements created in popups
		// FF meanwhile throws on frame elements through "defaultView.getComputedStyle"
		var view = elem.ownerDocument.defaultView;

		if ( !view.opener ) {
			view = window;
		}

		return view.getComputedStyle( elem );
	};

var swap = function( elem, options, callback, args ) {
	var ret, name,
		old = {};

	// Remember the old values, and insert the new ones
	for ( name in options ) {
		old[ name ] = elem.style[ name ];
		elem.style[ name ] = options[ name ];
	}

	ret = callback.apply( elem, args || [] );

	// Revert the old values
	for ( name in options ) {
		elem.style[ name ] = old[ name ];
	}

	return ret;
};


var documentElement = document.documentElement;



( function() {
	var pixelPositionVal, boxSizingReliableVal, pixelMarginRightVal, reliableMarginLeftVal,
		container = document.createElement( "div" ),
		div = document.createElement( "div" );

	// Finish early in limited (non-browser) environments
	if ( !div.style ) {
		return;
	}

	// Support: IE9-11+
	// Style of cloned element affects source element cloned (#8908)
	div.style.backgroundClip = "content-box";
	div.cloneNode( true ).style.backgroundClip = "";
	support.clearCloneStyle = div.style.backgroundClip === "content-box";

	container.style.cssText = "border:0;width:8px;height:0;top:0;left:-9999px;" +
		"padding:0;margin-top:1px;position:absolute";
	container.appendChild( div );

	// Executing both pixelPosition & boxSizingReliable tests require only one layout
	// so they're executed at the same time to save the second computation.
	function computeStyleTests() {
		div.style.cssText =

			// Support: Firefox<29, Android 2.3
			// Vendor-prefix box-sizing
			"-webkit-box-sizing:border-box;-moz-box-sizing:border-box;box-sizing:border-box;" +
			"position:relative;display:block;" +
			"margin:auto;border:1px;padding:1px;" +
			"top:1%;width:50%";
		div.innerHTML = "";
		documentElement.appendChild( container );

		var divStyle = window.getComputedStyle( div );
		pixelPositionVal = divStyle.top !== "1%";
		reliableMarginLeftVal = divStyle.marginLeft === "2px";
		boxSizingReliableVal = divStyle.width === "4px";

		// Support: Android 4.0 - 4.3 only
		// Some styles come back with percentage values, even though they shouldn't
		div.style.marginRight = "50%";
		pixelMarginRightVal = divStyle.marginRight === "4px";

		documentElement.removeChild( container );
	}

	jQuery.extend( support, {
		pixelPosition: function() {

			// This test is executed only once but we still do memoizing
			// since we can use the boxSizingReliable pre-computing.
			// No need to check if the test was already performed, though.
			computeStyleTests();
			return pixelPositionVal;
		},
		boxSizingReliable: function() {
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return boxSizingReliableVal;
		},
		pixelMarginRight: function() {

			// Support: Android 4.0-4.3
			// We're checking for boxSizingReliableVal here instead of pixelMarginRightVal
			// since that compresses better and they're computed together anyway.
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return pixelMarginRightVal;
		},
		reliableMarginLeft: function() {

			// Support: IE <=8 only, Android 4.0 - 4.3 only, Firefox <=3 - 37
			if ( boxSizingReliableVal == null ) {
				computeStyleTests();
			}
			return reliableMarginLeftVal;
		},
		reliableMarginRight: function() {

			// Support: Android 2.3
			// Check if div with explicit width and no margin-right incorrectly
			// gets computed margin-right based on width of container. (#3333)
			// WebKit Bug 13343 - getComputedStyle returns wrong value for margin-right
			// This support function is only executed once so no memoizing is needed.
			var ret,
				marginDiv = div.appendChild( document.createElement( "div" ) );

			// Reset CSS: box-sizing; display; margin; border; padding
			marginDiv.style.cssText = div.style.cssText =

				// Support: Android 2.3
				// Vendor-prefix box-sizing
				"-webkit-box-sizing:content-box;box-sizing:content-box;" +
				"display:block;margin:0;border:0;padding:0";
			marginDiv.style.marginRight = marginDiv.style.width = "0";
			div.style.width = "1px";
			documentElement.appendChild( container );

			ret = !parseFloat( window.getComputedStyle( marginDiv ).marginRight );

			documentElement.removeChild( container );
			div.removeChild( marginDiv );

			return ret;
		}
	} );
} )();


function curCSS( elem, name, computed ) {
	var width, minWidth, maxWidth, ret,
		style = elem.style;

	computed = computed || getStyles( elem );

	// Support: IE9
	// getPropertyValue is only needed for .css('filter') (#12537)
	if ( computed ) {
		ret = computed.getPropertyValue( name ) || computed[ name ];

		if ( ret === "" && !jQuery.contains( elem.ownerDocument, elem ) ) {
			ret = jQuery.style( elem, name );
		}

		// A tribute to the "awesome hack by Dean Edwards"
		// Android Browser returns percentage for some values,
		// but width seems to be reliably pixels.
		// This is against the CSSOM draft spec:
		// http://dev.w3.org/csswg/cssom/#resolved-values
		if ( !support.pixelMarginRight() && rnumnonpx.test( ret ) && rmargin.test( name ) ) {

			// Remember the original values
			width = style.width;
			minWidth = style.minWidth;
			maxWidth = style.maxWidth;

			// Put in the new values to get a computed value out
			style.minWidth = style.maxWidth = style.width = ret;
			ret = computed.width;

			// Revert the changed values
			style.width = width;
			style.minWidth = minWidth;
			style.maxWidth = maxWidth;
		}
	}

	return ret !== undefined ?

		// Support: IE9-11+
		// IE returns zIndex value as an integer.
		ret + "" :
		ret;
}


function addGetHookIf( conditionFn, hookFn ) {

	// Define the hook, we'll check on the first run if it's really needed.
	return {
		get: function() {
			if ( conditionFn() ) {

				// Hook not needed (or it's not possible to use it due
				// to missing dependency), remove it.
				delete this.get;
				return;
			}

			// Hook needed; redefine it so that the support test is not executed again.
			return ( this.get = hookFn ).apply( this, arguments );
		}
	};
}


var

	// Swappable if display is none or starts with table
	// except "table", "table-cell", or "table-caption"
	// See here for display values: https://developer.mozilla.org/en-US/docs/CSS/display
	rdisplayswap = /^(none|table(?!-c[ea]).+)/,

	cssShow = { position: "absolute", visibility: "hidden", display: "block" },
	cssNormalTransform = {
		letterSpacing: "0",
		fontWeight: "400"
	},

	cssPrefixes = [ "Webkit", "O", "Moz", "ms" ],
	emptyStyle = document.createElement( "div" ).style;

// Return a css property mapped to a potentially vendor prefixed property
function vendorPropName( name ) {

	// Shortcut for names that are not vendor prefixed
	if ( name in emptyStyle ) {
		return name;
	}

	// Check for vendor prefixed names
	var capName = name[ 0 ].toUpperCase() + name.slice( 1 ),
		i = cssPrefixes.length;

	while ( i-- ) {
		name = cssPrefixes[ i ] + capName;
		if ( name in emptyStyle ) {
			return name;
		}
	}
}

function setPositiveNumber( elem, value, subtract ) {

	// Any relative (+/-) values have already been
	// normalized at this point
	var matches = rcssNum.exec( value );
	return matches ?

		// Guard against undefined "subtract", e.g., when used as in cssHooks
		Math.max( 0, matches[ 2 ] - ( subtract || 0 ) ) + ( matches[ 3 ] || "px" ) :
		value;
}

function augmentWidthOrHeight( elem, name, extra, isBorderBox, styles ) {
	var i = extra === ( isBorderBox ? "border" : "content" ) ?

		// If we already have the right measurement, avoid augmentation
		4 :

		// Otherwise initialize for horizontal or vertical properties
		name === "width" ? 1 : 0,

		val = 0;

	for ( ; i < 4; i += 2 ) {

		// Both box models exclude margin, so add it if we want it
		if ( extra === "margin" ) {
			val += jQuery.css( elem, extra + cssExpand[ i ], true, styles );
		}

		if ( isBorderBox ) {

			// border-box includes padding, so remove it if we want content
			if ( extra === "content" ) {
				val -= jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );
			}

			// At this point, extra isn't border nor margin, so remove border
			if ( extra !== "margin" ) {
				val -= jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		} else {

			// At this point, extra isn't content, so add padding
			val += jQuery.css( elem, "padding" + cssExpand[ i ], true, styles );

			// At this point, extra isn't content nor padding, so add border
			if ( extra !== "padding" ) {
				val += jQuery.css( elem, "border" + cssExpand[ i ] + "Width", true, styles );
			}
		}
	}

	return val;
}

function getWidthOrHeight( elem, name, extra ) {

	// Start with offset property, which is equivalent to the border-box value
	var valueIsBorderBox = true,
		val = name === "width" ? elem.offsetWidth : elem.offsetHeight,
		styles = getStyles( elem ),
		isBorderBox = jQuery.css( elem, "boxSizing", false, styles ) === "border-box";

	// Support: IE11 only
	// In IE 11 fullscreen elements inside of an iframe have
	// 100x too small dimensions (gh-1764).
	if ( document.msFullscreenElement && window.top !== window ) {

		// Support: IE11 only
		// Running getBoundingClientRect on a disconnected node
		// in IE throws an error.
		if ( elem.getClientRects().length ) {
			val = Math.round( elem.getBoundingClientRect()[ name ] * 100 );
		}
	}

	// Some non-html elements return undefined for offsetWidth, so check for null/undefined
	// svg - https://bugzilla.mozilla.org/show_bug.cgi?id=649285
	// MathML - https://bugzilla.mozilla.org/show_bug.cgi?id=491668
	if ( val <= 0 || val == null ) {

		// Fall back to computed then uncomputed css if necessary
		val = curCSS( elem, name, styles );
		if ( val < 0 || val == null ) {
			val = elem.style[ name ];
		}

		// Computed unit is not pixels. Stop here and return.
		if ( rnumnonpx.test( val ) ) {
			return val;
		}

		// Check for style in case a browser which returns unreliable values
		// for getComputedStyle silently falls back to the reliable elem.style
		valueIsBorderBox = isBorderBox &&
			( support.boxSizingReliable() || val === elem.style[ name ] );

		// Normalize "", auto, and prepare for extra
		val = parseFloat( val ) || 0;
	}

	// Use the active box-sizing model to add/subtract irrelevant styles
	return ( val +
		augmentWidthOrHeight(
			elem,
			name,
			extra || ( isBorderBox ? "border" : "content" ),
			valueIsBorderBox,
			styles
		)
	) + "px";
}

function showHide( elements, show ) {
	var display, elem, hidden,
		values = [],
		index = 0,
		length = elements.length;

	for ( ; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}

		values[ index ] = dataPriv.get( elem, "olddisplay" );
		display = elem.style.display;
		if ( show ) {

			// Reset the inline display of this element to learn if it is
			// being hidden by cascaded rules or not
			if ( !values[ index ] && display === "none" ) {
				elem.style.display = "";
			}

			// Set elements which have been overridden with display: none
			// in a stylesheet to whatever the default browser style is
			// for such an element
			if ( elem.style.display === "" && isHidden( elem ) ) {
				values[ index ] = dataPriv.access(
					elem,
					"olddisplay",
					defaultDisplay( elem.nodeName )
				);
			}
		} else {
			hidden = isHidden( elem );

			if ( display !== "none" || !hidden ) {
				dataPriv.set(
					elem,
					"olddisplay",
					hidden ? display : jQuery.css( elem, "display" )
				);
			}
		}
	}

	// Set the display of most of the elements in a second loop
	// to avoid the constant reflow
	for ( index = 0; index < length; index++ ) {
		elem = elements[ index ];
		if ( !elem.style ) {
			continue;
		}
		if ( !show || elem.style.display === "none" || elem.style.display === "" ) {
			elem.style.display = show ? values[ index ] || "" : "none";
		}
	}

	return elements;
}

jQuery.extend( {

	// Add in style property hooks for overriding the default
	// behavior of getting and setting a style property
	cssHooks: {
		opacity: {
			get: function( elem, computed ) {
				if ( computed ) {

					// We should always get a number back from opacity
					var ret = curCSS( elem, "opacity" );
					return ret === "" ? "1" : ret;
				}
			}
		}
	},

	// Don't automatically add "px" to these possibly-unitless properties
	cssNumber: {
		"animationIterationCount": true,
		"columnCount": true,
		"fillOpacity": true,
		"flexGrow": true,
		"flexShrink": true,
		"fontWeight": true,
		"lineHeight": true,
		"opacity": true,
		"order": true,
		"orphans": true,
		"widows": true,
		"zIndex": true,
		"zoom": true
	},

	// Add in properties whose names you wish to fix before
	// setting or getting the value
	cssProps: {
		"float": "cssFloat"
	},

	// Get and set the style property on a DOM Node
	style: function( elem, name, value, extra ) {

		// Don't set styles on text and comment nodes
		if ( !elem || elem.nodeType === 3 || elem.nodeType === 8 || !elem.style ) {
			return;
		}

		// Make sure that we're working with the right name
		var ret, type, hooks,
			origName = jQuery.camelCase( name ),
			style = elem.style;

		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Gets hook for the prefixed version, then unprefixed version
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// Check if we're setting a value
		if ( value !== undefined ) {
			type = typeof value;

			// Convert "+=" or "-=" to relative numbers (#7345)
			if ( type === "string" && ( ret = rcssNum.exec( value ) ) && ret[ 1 ] ) {
				value = adjustCSS( elem, name, ret );

				// Fixes bug #9237
				type = "number";
			}

			// Make sure that null and NaN values aren't set (#7116)
			if ( value == null || value !== value ) {
				return;
			}

			// If a number was passed in, add the unit (except for certain CSS properties)
			if ( type === "number" ) {
				value += ret && ret[ 3 ] || ( jQuery.cssNumber[ origName ] ? "" : "px" );
			}

			// Support: IE9-11+
			// background-* props affect original clone's values
			if ( !support.clearCloneStyle && value === "" && name.indexOf( "background" ) === 0 ) {
				style[ name ] = "inherit";
			}

			// If a hook was provided, use that value, otherwise just set the specified value
			if ( !hooks || !( "set" in hooks ) ||
				( value = hooks.set( elem, value, extra ) ) !== undefined ) {

				style[ name ] = value;
			}

		} else {

			// If a hook was provided get the non-computed value from there
			if ( hooks && "get" in hooks &&
				( ret = hooks.get( elem, false, extra ) ) !== undefined ) {

				return ret;
			}

			// Otherwise just get the value from the style object
			return style[ name ];
		}
	},

	css: function( elem, name, extra, styles ) {
		var val, num, hooks,
			origName = jQuery.camelCase( name );

		// Make sure that we're working with the right name
		name = jQuery.cssProps[ origName ] ||
			( jQuery.cssProps[ origName ] = vendorPropName( origName ) || origName );

		// Try prefixed name followed by the unprefixed name
		hooks = jQuery.cssHooks[ name ] || jQuery.cssHooks[ origName ];

		// If a hook was provided get the computed value from there
		if ( hooks && "get" in hooks ) {
			val = hooks.get( elem, true, extra );
		}

		// Otherwise, if a way to get the computed value exists, use that
		if ( val === undefined ) {
			val = curCSS( elem, name, styles );
		}

		// Convert "normal" to computed value
		if ( val === "normal" && name in cssNormalTransform ) {
			val = cssNormalTransform[ name ];
		}

		// Make numeric if forced or a qualifier was provided and val looks numeric
		if ( extra === "" || extra ) {
			num = parseFloat( val );
			return extra === true || isFinite( num ) ? num || 0 : val;
		}
		return val;
	}
} );

jQuery.each( [ "height", "width" ], function( i, name ) {
	jQuery.cssHooks[ name ] = {
		get: function( elem, computed, extra ) {
			if ( computed ) {

				// Certain elements can have dimension info if we invisibly show them
				// but it must have a current display style that would benefit
				return rdisplayswap.test( jQuery.css( elem, "display" ) ) &&
					elem.offsetWidth === 0 ?
						swap( elem, cssShow, function() {
							return getWidthOrHeight( elem, name, extra );
						} ) :
						getWidthOrHeight( elem, name, extra );
			}
		},

		set: function( elem, value, extra ) {
			var matches,
				styles = extra && getStyles( elem ),
				subtract = extra && augmentWidthOrHeight(
					elem,
					name,
					extra,
					jQuery.css( elem, "boxSizing", false, styles ) === "border-box",
					styles
				);

			// Convert to pixels if value adjustment is needed
			if ( subtract && ( matches = rcssNum.exec( value ) ) &&
				( matches[ 3 ] || "px" ) !== "px" ) {

				elem.style[ name ] = value;
				value = jQuery.css( elem, name );
			}

			return setPositiveNumber( elem, value, subtract );
		}
	};
} );

jQuery.cssHooks.marginLeft = addGetHookIf( support.reliableMarginLeft,
	function( elem, computed ) {
		if ( computed ) {
			return ( parseFloat( curCSS( elem, "marginLeft" ) ) ||
				elem.getBoundingClientRect().left -
					swap( elem, { marginLeft: 0 }, function() {
						return elem.getBoundingClientRect().left;
					} )
				) + "px";
		}
	}
);

// Support: Android 2.3
jQuery.cssHooks.marginRight = addGetHookIf( support.reliableMarginRight,
	function( elem, computed ) {
		if ( computed ) {
			return swap( elem, { "display": "inline-block" },
				curCSS, [ elem, "marginRight" ] );
		}
	}
);

// These hooks are used by animate to expand properties
jQuery.each( {
	margin: "",
	padding: "",
	border: "Width"
}, function( prefix, suffix ) {
	jQuery.cssHooks[ prefix + suffix ] = {
		expand: function( value ) {
			var i = 0,
				expanded = {},

				// Assumes a single number if not a string
				parts = typeof value === "string" ? value.split( " " ) : [ value ];

			for ( ; i < 4; i++ ) {
				expanded[ prefix + cssExpand[ i ] + suffix ] =
					parts[ i ] || parts[ i - 2 ] || parts[ 0 ];
			}

			return expanded;
		}
	};

	if ( !rmargin.test( prefix ) ) {
		jQuery.cssHooks[ prefix + suffix ].set = setPositiveNumber;
	}
} );

jQuery.fn.extend( {
	css: function( name, value ) {
		return access( this, function( elem, name, value ) {
			var styles, len,
				map = {},
				i = 0;

			if ( jQuery.isArray( name ) ) {
				styles = getStyles( elem );
				len = name.length;

				for ( ; i < len; i++ ) {
					map[ name[ i ] ] = jQuery.css( elem, name[ i ], false, styles );
				}

				return map;
			}

			return value !== undefined ?
				jQuery.style( elem, name, value ) :
				jQuery.css( elem, name );
		}, name, value, arguments.length > 1 );
	},
	show: function() {
		return showHide( this, true );
	},
	hide: function() {
		return showHide( this );
	},
	toggle: function( state ) {
		if ( typeof state === "boolean" ) {
			return state ? this.show() : this.hide();
		}

		return this.each( function() {
			if ( isHidden( this ) ) {
				jQuery( this ).show();
			} else {
				jQuery( this ).hide();
			}
		} );
	}
} );


function Tween( elem, options, prop, end, easing ) {
	return new Tween.prototype.init( elem, options, prop, end, easing );
}
jQuery.Tween = Tween;

Tween.prototype = {
	constructor: Tween,
	init: function( elem, options, prop, end, easing, unit ) {
		this.elem = elem;
		this.prop = prop;
		this.easing = easing || jQuery.easing._default;
		this.options = options;
		this.start = this.now = this.cur();
		this.end = end;
		this.unit = unit || ( jQuery.cssNumber[ prop ] ? "" : "px" );
	},
	cur: function() {
		var hooks = Tween.propHooks[ this.prop ];

		return hooks && hooks.get ?
			hooks.get( this ) :
			Tween.propHooks._default.get( this );
	},
	run: function( percent ) {
		var eased,
			hooks = Tween.propHooks[ this.prop ];

		if ( this.options.duration ) {
			this.pos = eased = jQuery.easing[ this.easing ](
				percent, this.options.duration * percent, 0, 1, this.options.duration
			);
		} else {
			this.pos = eased = percent;
		}
		this.now = ( this.end - this.start ) * eased + this.start;

		if ( this.options.step ) {
			this.options.step.call( this.elem, this.now, this );
		}

		if ( hooks && hooks.set ) {
			hooks.set( this );
		} else {
			Tween.propHooks._default.set( this );
		}
		return this;
	}
};

Tween.prototype.init.prototype = Tween.prototype;

Tween.propHooks = {
	_default: {
		get: function( tween ) {
			var result;

			// Use a property on the element directly when it is not a DOM element,
			// or when there is no matching style property that exists.
			if ( tween.elem.nodeType !== 1 ||
				tween.elem[ tween.prop ] != null && tween.elem.style[ tween.prop ] == null ) {
				return tween.elem[ tween.prop ];
			}

			// Passing an empty string as a 3rd parameter to .css will automatically
			// attempt a parseFloat and fallback to a string if the parse fails.
			// Simple values such as "10px" are parsed to Float;
			// complex values such as "rotate(1rad)" are returned as-is.
			result = jQuery.css( tween.elem, tween.prop, "" );

			// Empty strings, null, undefined and "auto" are converted to 0.
			return !result || result === "auto" ? 0 : result;
		},
		set: function( tween ) {

			// Use step hook for back compat.
			// Use cssHook if its there.
			// Use .style if available and use plain properties where available.
			if ( jQuery.fx.step[ tween.prop ] ) {
				jQuery.fx.step[ tween.prop ]( tween );
			} else if ( tween.elem.nodeType === 1 &&
				( tween.elem.style[ jQuery.cssProps[ tween.prop ] ] != null ||
					jQuery.cssHooks[ tween.prop ] ) ) {
				jQuery.style( tween.elem, tween.prop, tween.now + tween.unit );
			} else {
				tween.elem[ tween.prop ] = tween.now;
			}
		}
	}
};

// Support: IE9
// Panic based approach to setting things on disconnected nodes
Tween.propHooks.scrollTop = Tween.propHooks.scrollLeft = {
	set: function( tween ) {
		if ( tween.elem.nodeType && tween.elem.parentNode ) {
			tween.elem[ tween.prop ] = tween.now;
		}
	}
};

jQuery.easing = {
	linear: function( p ) {
		return p;
	},
	swing: function( p ) {
		return 0.5 - Math.cos( p * Math.PI ) / 2;
	},
	_default: "swing"
};

jQuery.fx = Tween.prototype.init;

// Back Compat <1.8 extension point
jQuery.fx.step = {};




var
	fxNow, timerId,
	rfxtypes = /^(?:toggle|show|hide)$/,
	rrun = /queueHooks$/;

// Animations created synchronously will run synchronously
function createFxNow() {
	window.setTimeout( function() {
		fxNow = undefined;
	} );
	return ( fxNow = jQuery.now() );
}

// Generate parameters to create a standard animation
function genFx( type, includeWidth ) {
	var which,
		i = 0,
		attrs = { height: type };

	// If we include width, step value is 1 to do all cssExpand values,
	// otherwise step value is 2 to skip over Left and Right
	includeWidth = includeWidth ? 1 : 0;
	for ( ; i < 4 ; i += 2 - includeWidth ) {
		which = cssExpand[ i ];
		attrs[ "margin" + which ] = attrs[ "padding" + which ] = type;
	}

	if ( includeWidth ) {
		attrs.opacity = attrs.width = type;
	}

	return attrs;
}

function createTween( value, prop, animation ) {
	var tween,
		collection = ( Animation.tweeners[ prop ] || [] ).concat( Animation.tweeners[ "*" ] ),
		index = 0,
		length = collection.length;
	for ( ; index < length; index++ ) {
		if ( ( tween = collection[ index ].call( animation, prop, value ) ) ) {

			// We're done with this property
			return tween;
		}
	}
}

function defaultPrefilter( elem, props, opts ) {
	/* jshint validthis: true */
	var prop, value, toggle, tween, hooks, oldfire, display, checkDisplay,
		anim = this,
		orig = {},
		style = elem.style,
		hidden = elem.nodeType && isHidden( elem ),
		dataShow = dataPriv.get( elem, "fxshow" );

	// Handle queue: false promises
	if ( !opts.queue ) {
		hooks = jQuery._queueHooks( elem, "fx" );
		if ( hooks.unqueued == null ) {
			hooks.unqueued = 0;
			oldfire = hooks.empty.fire;
			hooks.empty.fire = function() {
				if ( !hooks.unqueued ) {
					oldfire();
				}
			};
		}
		hooks.unqueued++;

		anim.always( function() {

			// Ensure the complete handler is called before this completes
			anim.always( function() {
				hooks.unqueued--;
				if ( !jQuery.queue( elem, "fx" ).length ) {
					hooks.empty.fire();
				}
			} );
		} );
	}

	// Height/width overflow pass
	if ( elem.nodeType === 1 && ( "height" in props || "width" in props ) ) {

		// Make sure that nothing sneaks out
		// Record all 3 overflow attributes because IE9-10 do not
		// change the overflow attribute when overflowX and
		// overflowY are set to the same value
		opts.overflow = [ style.overflow, style.overflowX, style.overflowY ];

		// Set display property to inline-block for height/width
		// animations on inline elements that are having width/height animated
		display = jQuery.css( elem, "display" );

		// Test default display if display is currently "none"
		checkDisplay = display === "none" ?
			dataPriv.get( elem, "olddisplay" ) || defaultDisplay( elem.nodeName ) : display;

		if ( checkDisplay === "inline" && jQuery.css( elem, "float" ) === "none" ) {
			style.display = "inline-block";
		}
	}

	if ( opts.overflow ) {
		style.overflow = "hidden";
		anim.always( function() {
			style.overflow = opts.overflow[ 0 ];
			style.overflowX = opts.overflow[ 1 ];
			style.overflowY = opts.overflow[ 2 ];
		} );
	}

	// show/hide pass
	for ( prop in props ) {
		value = props[ prop ];
		if ( rfxtypes.exec( value ) ) {
			delete props[ prop ];
			toggle = toggle || value === "toggle";
			if ( value === ( hidden ? "hide" : "show" ) ) {

				// If there is dataShow left over from a stopped hide or show
				// and we are going to proceed with show, we should pretend to be hidden
				if ( value === "show" && dataShow && dataShow[ prop ] !== undefined ) {
					hidden = true;
				} else {
					continue;
				}
			}
			orig[ prop ] = dataShow && dataShow[ prop ] || jQuery.style( elem, prop );

		// Any non-fx value stops us from restoring the original display value
		} else {
			display = undefined;
		}
	}

	if ( !jQuery.isEmptyObject( orig ) ) {
		if ( dataShow ) {
			if ( "hidden" in dataShow ) {
				hidden = dataShow.hidden;
			}
		} else {
			dataShow = dataPriv.access( elem, "fxshow", {} );
		}

		// Store state if its toggle - enables .stop().toggle() to "reverse"
		if ( toggle ) {
			dataShow.hidden = !hidden;
		}
		if ( hidden ) {
			jQuery( elem ).show();
		} else {
			anim.done( function() {
				jQuery( elem ).hide();
			} );
		}
		anim.done( function() {
			var prop;

			dataPriv.remove( elem, "fxshow" );
			for ( prop in orig ) {
				jQuery.style( elem, prop, orig[ prop ] );
			}
		} );
		for ( prop in orig ) {
			tween = createTween( hidden ? dataShow[ prop ] : 0, prop, anim );

			if ( !( prop in dataShow ) ) {
				dataShow[ prop ] = tween.start;
				if ( hidden ) {
					tween.end = tween.start;
					tween.start = prop === "width" || prop === "height" ? 1 : 0;
				}
			}
		}

	// If this is a noop like .hide().hide(), restore an overwritten display value
	} else if ( ( display === "none" ? defaultDisplay( elem.nodeName ) : display ) === "inline" ) {
		style.display = display;
	}
}

function propFilter( props, specialEasing ) {
	var index, name, easing, value, hooks;

	// camelCase, specialEasing and expand cssHook pass
	for ( index in props ) {
		name = jQuery.camelCase( index );
		easing = specialEasing[ name ];
		value = props[ index ];
		if ( jQuery.isArray( value ) ) {
			easing = value[ 1 ];
			value = props[ index ] = value[ 0 ];
		}

		if ( index !== name ) {
			props[ name ] = value;
			delete props[ index ];
		}

		hooks = jQuery.cssHooks[ name ];
		if ( hooks && "expand" in hooks ) {
			value = hooks.expand( value );
			delete props[ name ];

			// Not quite $.extend, this won't overwrite existing keys.
			// Reusing 'index' because we have the correct "name"
			for ( index in value ) {
				if ( !( index in props ) ) {
					props[ index ] = value[ index ];
					specialEasing[ index ] = easing;
				}
			}
		} else {
			specialEasing[ name ] = easing;
		}
	}
}

function Animation( elem, properties, options ) {
	var result,
		stopped,
		index = 0,
		length = Animation.prefilters.length,
		deferred = jQuery.Deferred().always( function() {

			// Don't match elem in the :animated selector
			delete tick.elem;
		} ),
		tick = function() {
			if ( stopped ) {
				return false;
			}
			var currentTime = fxNow || createFxNow(),
				remaining = Math.max( 0, animation.startTime + animation.duration - currentTime ),

				// Support: Android 2.3
				// Archaic crash bug won't allow us to use `1 - ( 0.5 || 0 )` (#12497)
				temp = remaining / animation.duration || 0,
				percent = 1 - temp,
				index = 0,
				length = animation.tweens.length;

			for ( ; index < length ; index++ ) {
				animation.tweens[ index ].run( percent );
			}

			deferred.notifyWith( elem, [ animation, percent, remaining ] );

			if ( percent < 1 && length ) {
				return remaining;
			} else {
				deferred.resolveWith( elem, [ animation ] );
				return false;
			}
		},
		animation = deferred.promise( {
			elem: elem,
			props: jQuery.extend( {}, properties ),
			opts: jQuery.extend( true, {
				specialEasing: {},
				easing: jQuery.easing._default
			}, options ),
			originalProperties: properties,
			originalOptions: options,
			startTime: fxNow || createFxNow(),
			duration: options.duration,
			tweens: [],
			createTween: function( prop, end ) {
				var tween = jQuery.Tween( elem, animation.opts, prop, end,
						animation.opts.specialEasing[ prop ] || animation.opts.easing );
				animation.tweens.push( tween );
				return tween;
			},
			stop: function( gotoEnd ) {
				var index = 0,

					// If we are going to the end, we want to run all the tweens
					// otherwise we skip this part
					length = gotoEnd ? animation.tweens.length : 0;
				if ( stopped ) {
					return this;
				}
				stopped = true;
				for ( ; index < length ; index++ ) {
					animation.tweens[ index ].run( 1 );
				}

				// Resolve when we played the last frame; otherwise, reject
				if ( gotoEnd ) {
					deferred.notifyWith( elem, [ animation, 1, 0 ] );
					deferred.resolveWith( elem, [ animation, gotoEnd ] );
				} else {
					deferred.rejectWith( elem, [ animation, gotoEnd ] );
				}
				return this;
			}
		} ),
		props = animation.props;

	propFilter( props, animation.opts.specialEasing );

	for ( ; index < length ; index++ ) {
		result = Animation.prefilters[ index ].call( animation, elem, props, animation.opts );
		if ( result ) {
			if ( jQuery.isFunction( result.stop ) ) {
				jQuery._queueHooks( animation.elem, animation.opts.queue ).stop =
					jQuery.proxy( result.stop, result );
			}
			return result;
		}
	}

	jQuery.map( props, createTween, animation );

	if ( jQuery.isFunction( animation.opts.start ) ) {
		animation.opts.start.call( elem, animation );
	}

	jQuery.fx.timer(
		jQuery.extend( tick, {
			elem: elem,
			anim: animation,
			queue: animation.opts.queue
		} )
	);

	// attach callbacks from options
	return animation.progress( animation.opts.progress )
		.done( animation.opts.done, animation.opts.complete )
		.fail( animation.opts.fail )
		.always( animation.opts.always );
}

jQuery.Animation = jQuery.extend( Animation, {
	tweeners: {
		"*": [ function( prop, value ) {
			var tween = this.createTween( prop, value );
			adjustCSS( tween.elem, prop, rcssNum.exec( value ), tween );
			return tween;
		} ]
	},

	tweener: function( props, callback ) {
		if ( jQuery.isFunction( props ) ) {
			callback = props;
			props = [ "*" ];
		} else {
			props = props.match( rnotwhite );
		}

		var prop,
			index = 0,
			length = props.length;

		for ( ; index < length ; index++ ) {
			prop = props[ index ];
			Animation.tweeners[ prop ] = Animation.tweeners[ prop ] || [];
			Animation.tweeners[ prop ].unshift( callback );
		}
	},

	prefilters: [ defaultPrefilter ],

	prefilter: function( callback, prepend ) {
		if ( prepend ) {
			Animation.prefilters.unshift( callback );
		} else {
			Animation.prefilters.push( callback );
		}
	}
} );

jQuery.speed = function( speed, easing, fn ) {
	var opt = speed && typeof speed === "object" ? jQuery.extend( {}, speed ) : {
		complete: fn || !fn && easing ||
			jQuery.isFunction( speed ) && speed,
		duration: speed,
		easing: fn && easing || easing && !jQuery.isFunction( easing ) && easing
	};

	opt.duration = jQuery.fx.off ? 0 : typeof opt.duration === "number" ?
		opt.duration : opt.duration in jQuery.fx.speeds ?
			jQuery.fx.speeds[ opt.duration ] : jQuery.fx.speeds._default;

	// Normalize opt.queue - true/undefined/null -> "fx"
	if ( opt.queue == null || opt.queue === true ) {
		opt.queue = "fx";
	}

	// Queueing
	opt.old = opt.complete;

	opt.complete = function() {
		if ( jQuery.isFunction( opt.old ) ) {
			opt.old.call( this );
		}

		if ( opt.queue ) {
			jQuery.dequeue( this, opt.queue );
		}
	};

	return opt;
};

jQuery.fn.extend( {
	fadeTo: function( speed, to, easing, callback ) {

		// Show any hidden elements after setting opacity to 0
		return this.filter( isHidden ).css( "opacity", 0 ).show()

			// Animate to the value specified
			.end().animate( { opacity: to }, speed, easing, callback );
	},
	animate: function( prop, speed, easing, callback ) {
		var empty = jQuery.isEmptyObject( prop ),
			optall = jQuery.speed( speed, easing, callback ),
			doAnimation = function() {

				// Operate on a copy of prop so per-property easing won't be lost
				var anim = Animation( this, jQuery.extend( {}, prop ), optall );

				// Empty animations, or finishing resolves immediately
				if ( empty || dataPriv.get( this, "finish" ) ) {
					anim.stop( true );
				}
			};
			doAnimation.finish = doAnimation;

		return empty || optall.queue === false ?
			this.each( doAnimation ) :
			this.queue( optall.queue, doAnimation );
	},
	stop: function( type, clearQueue, gotoEnd ) {
		var stopQueue = function( hooks ) {
			var stop = hooks.stop;
			delete hooks.stop;
			stop( gotoEnd );
		};

		if ( typeof type !== "string" ) {
			gotoEnd = clearQueue;
			clearQueue = type;
			type = undefined;
		}
		if ( clearQueue && type !== false ) {
			this.queue( type || "fx", [] );
		}

		return this.each( function() {
			var dequeue = true,
				index = type != null && type + "queueHooks",
				timers = jQuery.timers,
				data = dataPriv.get( this );

			if ( index ) {
				if ( data[ index ] && data[ index ].stop ) {
					stopQueue( data[ index ] );
				}
			} else {
				for ( index in data ) {
					if ( data[ index ] && data[ index ].stop && rrun.test( index ) ) {
						stopQueue( data[ index ] );
					}
				}
			}

			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this &&
					( type == null || timers[ index ].queue === type ) ) {

					timers[ index ].anim.stop( gotoEnd );
					dequeue = false;
					timers.splice( index, 1 );
				}
			}

			// Start the next in the queue if the last step wasn't forced.
			// Timers currently will call their complete callbacks, which
			// will dequeue but only if they were gotoEnd.
			if ( dequeue || !gotoEnd ) {
				jQuery.dequeue( this, type );
			}
		} );
	},
	finish: function( type ) {
		if ( type !== false ) {
			type = type || "fx";
		}
		return this.each( function() {
			var index,
				data = dataPriv.get( this ),
				queue = data[ type + "queue" ],
				hooks = data[ type + "queueHooks" ],
				timers = jQuery.timers,
				length = queue ? queue.length : 0;

			// Enable finishing flag on private data
			data.finish = true;

			// Empty the queue first
			jQuery.queue( this, type, [] );

			if ( hooks && hooks.stop ) {
				hooks.stop.call( this, true );
			}

			// Look for any active animations, and finish them
			for ( index = timers.length; index--; ) {
				if ( timers[ index ].elem === this && timers[ index ].queue === type ) {
					timers[ index ].anim.stop( true );
					timers.splice( index, 1 );
				}
			}

			// Look for any animations in the old queue and finish them
			for ( index = 0; index < length; index++ ) {
				if ( queue[ index ] && queue[ index ].finish ) {
					queue[ index ].finish.call( this );
				}
			}

			// Turn off finishing flag
			delete data.finish;
		} );
	}
} );

jQuery.each( [ "toggle", "show", "hide" ], function( i, name ) {
	var cssFn = jQuery.fn[ name ];
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return speed == null || typeof speed === "boolean" ?
			cssFn.apply( this, arguments ) :
			this.animate( genFx( name, true ), speed, easing, callback );
	};
} );

// Generate shortcuts for custom animations
jQuery.each( {
	slideDown: genFx( "show" ),
	slideUp: genFx( "hide" ),
	slideToggle: genFx( "toggle" ),
	fadeIn: { opacity: "show" },
	fadeOut: { opacity: "hide" },
	fadeToggle: { opacity: "toggle" }
}, function( name, props ) {
	jQuery.fn[ name ] = function( speed, easing, callback ) {
		return this.animate( props, speed, easing, callback );
	};
} );

jQuery.timers = [];
jQuery.fx.tick = function() {
	var timer,
		i = 0,
		timers = jQuery.timers;

	fxNow = jQuery.now();

	for ( ; i < timers.length; i++ ) {
		timer = timers[ i ];

		// Checks the timer has not already been removed
		if ( !timer() && timers[ i ] === timer ) {
			timers.splice( i--, 1 );
		}
	}

	if ( !timers.length ) {
		jQuery.fx.stop();
	}
	fxNow = undefined;
};

jQuery.fx.timer = function( timer ) {
	jQuery.timers.push( timer );
	if ( timer() ) {
		jQuery.fx.start();
	} else {
		jQuery.timers.pop();
	}
};

jQuery.fx.interval = 13;
jQuery.fx.start = function() {
	if ( !timerId ) {
		timerId = window.setInterval( jQuery.fx.tick, jQuery.fx.interval );
	}
};

jQuery.fx.stop = function() {
	window.clearInterval( timerId );

	timerId = null;
};

jQuery.fx.speeds = {
	slow: 600,
	fast: 200,

	// Default speed
	_default: 400
};


// Based off of the plugin by Clint Helfers, with permission.
// http://web.archive.org/web/20100324014747/http://blindsignals.com/index.php/2009/07/jquery-delay/
jQuery.fn.delay = function( time, type ) {
	time = jQuery.fx ? jQuery.fx.speeds[ time ] || time : time;
	type = type || "fx";

	return this.queue( type, function( next, hooks ) {
		var timeout = window.setTimeout( next, time );
		hooks.stop = function() {
			window.clearTimeout( timeout );
		};
	} );
};


( function() {
	var input = document.createElement( "input" ),
		select = document.createElement( "select" ),
		opt = select.appendChild( document.createElement( "option" ) );

	input.type = "checkbox";

	// Support: iOS<=5.1, Android<=4.2+
	// Default value for a checkbox should be "on"
	support.checkOn = input.value !== "";

	// Support: IE<=11+
	// Must access selectedIndex to make default options select
	support.optSelected = opt.selected;

	// Support: Android<=2.3
	// Options inside disabled selects are incorrectly marked as disabled
	select.disabled = true;
	support.optDisabled = !opt.disabled;

	// Support: IE<=11+
	// An input loses its value after becoming a radio
	input = document.createElement( "input" );
	input.value = "t";
	input.type = "radio";
	support.radioValue = input.value === "t";
} )();


var boolHook,
	attrHandle = jQuery.expr.attrHandle;

jQuery.fn.extend( {
	attr: function( name, value ) {
		return access( this, jQuery.attr, name, value, arguments.length > 1 );
	},

	removeAttr: function( name ) {
		return this.each( function() {
			jQuery.removeAttr( this, name );
		} );
	}
} );

jQuery.extend( {
	attr: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set attributes on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		// Fallback to prop when attributes are not supported
		if ( typeof elem.getAttribute === "undefined" ) {
			return jQuery.prop( elem, name, value );
		}

		// All attributes are lowercase
		// Grab necessary hook if one is defined
		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {
			name = name.toLowerCase();
			hooks = jQuery.attrHooks[ name ] ||
				( jQuery.expr.match.bool.test( name ) ? boolHook : undefined );
		}

		if ( value !== undefined ) {
			if ( value === null ) {
				jQuery.removeAttr( elem, name );
				return;
			}

			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			elem.setAttribute( name, value + "" );
			return value;
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		ret = jQuery.find.attr( elem, name );

		// Non-existent attributes return null, we normalize to undefined
		return ret == null ? undefined : ret;
	},

	attrHooks: {
		type: {
			set: function( elem, value ) {
				if ( !support.radioValue && value === "radio" &&
					jQuery.nodeName( elem, "input" ) ) {
					var val = elem.value;
					elem.setAttribute( "type", value );
					if ( val ) {
						elem.value = val;
					}
					return value;
				}
			}
		}
	},

	removeAttr: function( elem, value ) {
		var name, propName,
			i = 0,
			attrNames = value && value.match( rnotwhite );

		if ( attrNames && elem.nodeType === 1 ) {
			while ( ( name = attrNames[ i++ ] ) ) {
				propName = jQuery.propFix[ name ] || name;

				// Boolean attributes get special treatment (#10870)
				if ( jQuery.expr.match.bool.test( name ) ) {

					// Set corresponding property to false
					elem[ propName ] = false;
				}

				elem.removeAttribute( name );
			}
		}
	}
} );

// Hooks for boolean attributes
boolHook = {
	set: function( elem, value, name ) {
		if ( value === false ) {

			// Remove boolean attributes when set to false
			jQuery.removeAttr( elem, name );
		} else {
			elem.setAttribute( name, name );
		}
		return name;
	}
};
jQuery.each( jQuery.expr.match.bool.source.match( /\w+/g ), function( i, name ) {
	var getter = attrHandle[ name ] || jQuery.find.attr;

	attrHandle[ name ] = function( elem, name, isXML ) {
		var ret, handle;
		if ( !isXML ) {

			// Avoid an infinite loop by temporarily removing this function from the getter
			handle = attrHandle[ name ];
			attrHandle[ name ] = ret;
			ret = getter( elem, name, isXML ) != null ?
				name.toLowerCase() :
				null;
			attrHandle[ name ] = handle;
		}
		return ret;
	};
} );




var rfocusable = /^(?:input|select|textarea|button)$/i,
	rclickable = /^(?:a|area)$/i;

jQuery.fn.extend( {
	prop: function( name, value ) {
		return access( this, jQuery.prop, name, value, arguments.length > 1 );
	},

	removeProp: function( name ) {
		return this.each( function() {
			delete this[ jQuery.propFix[ name ] || name ];
		} );
	}
} );

jQuery.extend( {
	prop: function( elem, name, value ) {
		var ret, hooks,
			nType = elem.nodeType;

		// Don't get/set properties on text, comment and attribute nodes
		if ( nType === 3 || nType === 8 || nType === 2 ) {
			return;
		}

		if ( nType !== 1 || !jQuery.isXMLDoc( elem ) ) {

			// Fix name and attach hooks
			name = jQuery.propFix[ name ] || name;
			hooks = jQuery.propHooks[ name ];
		}

		if ( value !== undefined ) {
			if ( hooks && "set" in hooks &&
				( ret = hooks.set( elem, value, name ) ) !== undefined ) {
				return ret;
			}

			return ( elem[ name ] = value );
		}

		if ( hooks && "get" in hooks && ( ret = hooks.get( elem, name ) ) !== null ) {
			return ret;
		}

		return elem[ name ];
	},

	propHooks: {
		tabIndex: {
			get: function( elem ) {

				// elem.tabIndex doesn't always return the
				// correct value when it hasn't been explicitly set
				// http://fluidproject.org/blog/2008/01/09/getting-setting-and-removing-tabindex-values-with-javascript/
				// Use proper attribute retrieval(#12072)
				var tabindex = jQuery.find.attr( elem, "tabindex" );

				return tabindex ?
					parseInt( tabindex, 10 ) :
					rfocusable.test( elem.nodeName ) ||
						rclickable.test( elem.nodeName ) && elem.href ?
							0 :
							-1;
			}
		}
	},

	propFix: {
		"for": "htmlFor",
		"class": "className"
	}
} );

if ( !support.optSelected ) {
	jQuery.propHooks.selected = {
		get: function( elem ) {
			var parent = elem.parentNode;
			if ( parent && parent.parentNode ) {
				parent.parentNode.selectedIndex;
			}
			return null;
		}
	};
}

jQuery.each( [
	"tabIndex",
	"readOnly",
	"maxLength",
	"cellSpacing",
	"cellPadding",
	"rowSpan",
	"colSpan",
	"useMap",
	"frameBorder",
	"contentEditable"
], function() {
	jQuery.propFix[ this.toLowerCase() ] = this;
} );




var rclass = /[\t\r\n\f]/g;

function getClass( elem ) {
	return elem.getAttribute && elem.getAttribute( "class" ) || "";
}

jQuery.fn.extend( {
	addClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).addClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {
						if ( cur.indexOf( " " + clazz + " " ) < 0 ) {
							cur += clazz + " ";
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	removeClass: function( value ) {
		var classes, elem, cur, curValue, clazz, j, finalValue,
			i = 0;

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( j ) {
				jQuery( this ).removeClass( value.call( this, j, getClass( this ) ) );
			} );
		}

		if ( !arguments.length ) {
			return this.attr( "class", "" );
		}

		if ( typeof value === "string" && value ) {
			classes = value.match( rnotwhite ) || [];

			while ( ( elem = this[ i++ ] ) ) {
				curValue = getClass( elem );

				// This expression is here for better compressibility (see addClass)
				cur = elem.nodeType === 1 &&
					( " " + curValue + " " ).replace( rclass, " " );

				if ( cur ) {
					j = 0;
					while ( ( clazz = classes[ j++ ] ) ) {

						// Remove *all* instances
						while ( cur.indexOf( " " + clazz + " " ) > -1 ) {
							cur = cur.replace( " " + clazz + " ", " " );
						}
					}

					// Only assign if different to avoid unneeded rendering.
					finalValue = jQuery.trim( cur );
					if ( curValue !== finalValue ) {
						elem.setAttribute( "class", finalValue );
					}
				}
			}
		}

		return this;
	},

	toggleClass: function( value, stateVal ) {
		var type = typeof value;

		if ( typeof stateVal === "boolean" && type === "string" ) {
			return stateVal ? this.addClass( value ) : this.removeClass( value );
		}

		if ( jQuery.isFunction( value ) ) {
			return this.each( function( i ) {
				jQuery( this ).toggleClass(
					value.call( this, i, getClass( this ), stateVal ),
					stateVal
				);
			} );
		}

		return this.each( function() {
			var className, i, self, classNames;

			if ( type === "string" ) {

				// Toggle individual class names
				i = 0;
				self = jQuery( this );
				classNames = value.match( rnotwhite ) || [];

				while ( ( className = classNames[ i++ ] ) ) {

					// Check each className given, space separated list
					if ( self.hasClass( className ) ) {
						self.removeClass( className );
					} else {
						self.addClass( className );
					}
				}

			// Toggle whole class name
			} else if ( value === undefined || type === "boolean" ) {
				className = getClass( this );
				if ( className ) {

					// Store className if set
					dataPriv.set( this, "__className__", className );
				}

				// If the element has a class name or if we're passed `false`,
				// then remove the whole classname (if there was one, the above saved it).
				// Otherwise bring back whatever was previously saved (if anything),
				// falling back to the empty string if nothing was stored.
				if ( this.setAttribute ) {
					this.setAttribute( "class",
						className || value === false ?
						"" :
						dataPriv.get( this, "__className__" ) || ""
					);
				}
			}
		} );
	},

	hasClass: function( selector ) {
		var className, elem,
			i = 0;

		className = " " + selector + " ";
		while ( ( elem = this[ i++ ] ) ) {
			if ( elem.nodeType === 1 &&
				( " " + getClass( elem ) + " " ).replace( rclass, " " )
					.indexOf( className ) > -1
			) {
				return true;
			}
		}

		return false;
	}
} );




var rreturn = /\r/g;

jQuery.fn.extend( {
	val: function( value ) {
		var hooks, ret, isFunction,
			elem = this[ 0 ];

		if ( !arguments.length ) {
			if ( elem ) {
				hooks = jQuery.valHooks[ elem.type ] ||
					jQuery.valHooks[ elem.nodeName.toLowerCase() ];

				if ( hooks &&
					"get" in hooks &&
					( ret = hooks.get( elem, "value" ) ) !== undefined
				) {
					return ret;
				}

				ret = elem.value;

				return typeof ret === "string" ?

					// Handle most common string cases
					ret.replace( rreturn, "" ) :

					// Handle cases where value is null/undef or number
					ret == null ? "" : ret;
			}

			return;
		}

		isFunction = jQuery.isFunction( value );

		return this.each( function( i ) {
			var val;

			if ( this.nodeType !== 1 ) {
				return;
			}

			if ( isFunction ) {
				val = value.call( this, i, jQuery( this ).val() );
			} else {
				val = value;
			}

			// Treat null/undefined as ""; convert numbers to string
			if ( val == null ) {
				val = "";

			} else if ( typeof val === "number" ) {
				val += "";

			} else if ( jQuery.isArray( val ) ) {
				val = jQuery.map( val, function( value ) {
					return value == null ? "" : value + "";
				} );
			}

			hooks = jQuery.valHooks[ this.type ] || jQuery.valHooks[ this.nodeName.toLowerCase() ];

			// If set returns undefined, fall back to normal setting
			if ( !hooks || !( "set" in hooks ) || hooks.set( this, val, "value" ) === undefined ) {
				this.value = val;
			}
		} );
	}
} );

jQuery.extend( {
	valHooks: {
		option: {
			get: function( elem ) {

				// Support: IE<11
				// option.value not trimmed (#14858)
				return jQuery.trim( elem.value );
			}
		},
		select: {
			get: function( elem ) {
				var value, option,
					options = elem.options,
					index = elem.selectedIndex,
					one = elem.type === "select-one" || index < 0,
					values = one ? null : [],
					max = one ? index + 1 : options.length,
					i = index < 0 ?
						max :
						one ? index : 0;

				// Loop through all the selected options
				for ( ; i < max; i++ ) {
					option = options[ i ];

					// IE8-9 doesn't update selected after form reset (#2551)
					if ( ( option.selected || i === index ) &&

							// Don't return options that are disabled or in a disabled optgroup
							( support.optDisabled ?
								!option.disabled : option.getAttribute( "disabled" ) === null ) &&
							( !option.parentNode.disabled ||
								!jQuery.nodeName( option.parentNode, "optgroup" ) ) ) {

						// Get the specific value for the option
						value = jQuery( option ).val();

						// We don't need an array for one selects
						if ( one ) {
							return value;
						}

						// Multi-Selects return an array
						values.push( value );
					}
				}

				return values;
			},

			set: function( elem, value ) {
				var optionSet, option,
					options = elem.options,
					values = jQuery.makeArray( value ),
					i = options.length;

				while ( i-- ) {
					option = options[ i ];
					if ( option.selected =
							jQuery.inArray( jQuery.valHooks.option.get( option ), values ) > -1
					) {
						optionSet = true;
					}
				}

				// Force browsers to behave consistently when non-matching value is set
				if ( !optionSet ) {
					elem.selectedIndex = -1;
				}
				return values;
			}
		}
	}
} );

// Radios and checkboxes getter/setter
jQuery.each( [ "radio", "checkbox" ], function() {
	jQuery.valHooks[ this ] = {
		set: function( elem, value ) {
			if ( jQuery.isArray( value ) ) {
				return ( elem.checked = jQuery.inArray( jQuery( elem ).val(), value ) > -1 );
			}
		}
	};
	if ( !support.checkOn ) {
		jQuery.valHooks[ this ].get = function( elem ) {
			return elem.getAttribute( "value" ) === null ? "on" : elem.value;
		};
	}
} );




// Return jQuery for attributes-only inclusion


var rfocusMorph = /^(?:focusinfocus|focusoutblur)$/;

jQuery.extend( jQuery.event, {

	trigger: function( event, data, elem, onlyHandlers ) {

		var i, cur, tmp, bubbleType, ontype, handle, special,
			eventPath = [ elem || document ],
			type = hasOwn.call( event, "type" ) ? event.type : event,
			namespaces = hasOwn.call( event, "namespace" ) ? event.namespace.split( "." ) : [];

		cur = tmp = elem = elem || document;

		// Don't do events on text and comment nodes
		if ( elem.nodeType === 3 || elem.nodeType === 8 ) {
			return;
		}

		// focus/blur morphs to focusin/out; ensure we're not firing them right now
		if ( rfocusMorph.test( type + jQuery.event.triggered ) ) {
			return;
		}

		if ( type.indexOf( "." ) > -1 ) {

			// Namespaced trigger; create a regexp to match event type in handle()
			namespaces = type.split( "." );
			type = namespaces.shift();
			namespaces.sort();
		}
		ontype = type.indexOf( ":" ) < 0 && "on" + type;

		// Caller can pass in a jQuery.Event object, Object, or just an event type string
		event = event[ jQuery.expando ] ?
			event :
			new jQuery.Event( type, typeof event === "object" && event );

		// Trigger bitmask: & 1 for native handlers; & 2 for jQuery (always true)
		event.isTrigger = onlyHandlers ? 2 : 3;
		event.namespace = namespaces.join( "." );
		event.rnamespace = event.namespace ?
			new RegExp( "(^|\\.)" + namespaces.join( "\\.(?:.*\\.|)" ) + "(\\.|$)" ) :
			null;

		// Clean up the event in case it is being reused
		event.result = undefined;
		if ( !event.target ) {
			event.target = elem;
		}

		// Clone any incoming data and prepend the event, creating the handler arg list
		data = data == null ?
			[ event ] :
			jQuery.makeArray( data, [ event ] );

		// Allow special events to draw outside the lines
		special = jQuery.event.special[ type ] || {};
		if ( !onlyHandlers && special.trigger && special.trigger.apply( elem, data ) === false ) {
			return;
		}

		// Determine event propagation path in advance, per W3C events spec (#9951)
		// Bubble up to document, then to window; watch for a global ownerDocument var (#9724)
		if ( !onlyHandlers && !special.noBubble && !jQuery.isWindow( elem ) ) {

			bubbleType = special.delegateType || type;
			if ( !rfocusMorph.test( bubbleType + type ) ) {
				cur = cur.parentNode;
			}
			for ( ; cur; cur = cur.parentNode ) {
				eventPath.push( cur );
				tmp = cur;
			}

			// Only add window if we got to document (e.g., not plain obj or detached DOM)
			if ( tmp === ( elem.ownerDocument || document ) ) {
				eventPath.push( tmp.defaultView || tmp.parentWindow || window );
			}
		}

		// Fire handlers on the event path
		i = 0;
		while ( ( cur = eventPath[ i++ ] ) && !event.isPropagationStopped() ) {

			event.type = i > 1 ?
				bubbleType :
				special.bindType || type;

			// jQuery handler
			handle = ( dataPriv.get( cur, "events" ) || {} )[ event.type ] &&
				dataPriv.get( cur, "handle" );
			if ( handle ) {
				handle.apply( cur, data );
			}

			// Native handler
			handle = ontype && cur[ ontype ];
			if ( handle && handle.apply && acceptData( cur ) ) {
				event.result = handle.apply( cur, data );
				if ( event.result === false ) {
					event.preventDefault();
				}
			}
		}
		event.type = type;

		// If nobody prevented the default action, do it now
		if ( !onlyHandlers && !event.isDefaultPrevented() ) {

			if ( ( !special._default ||
				special._default.apply( eventPath.pop(), data ) === false ) &&
				acceptData( elem ) ) {

				// Call a native DOM method on the target with the same name name as the event.
				// Don't do default actions on window, that's where global variables be (#6170)
				if ( ontype && jQuery.isFunction( elem[ type ] ) && !jQuery.isWindow( elem ) ) {

					// Don't re-trigger an onFOO event when we call its FOO() method
					tmp = elem[ ontype ];

					if ( tmp ) {
						elem[ ontype ] = null;
					}

					// Prevent re-triggering of the same event, since we already bubbled it above
					jQuery.event.triggered = type;
					elem[ type ]();
					jQuery.event.triggered = undefined;

					if ( tmp ) {
						elem[ ontype ] = tmp;
					}
				}
			}
		}

		return event.result;
	},

	// Piggyback on a donor event to simulate a different one
	simulate: function( type, elem, event ) {
		var e = jQuery.extend(
			new jQuery.Event(),
			event,
			{
				type: type,
				isSimulated: true

				// Previously, `originalEvent: {}` was set here, so stopPropagation call
				// would not be triggered on donor event, since in our own
				// jQuery.event.stopPropagation function we had a check for existence of
				// originalEvent.stopPropagation method, so, consequently it would be a noop.
				//
				// But now, this "simulate" function is used only for events
				// for which stopPropagation() is noop, so there is no need for that anymore.
				//
				// For the compat branch though, guard for "click" and "submit"
				// events is still used, but was moved to jQuery.event.stopPropagation function
				// because `originalEvent` should point to the original event for the constancy
				// with other events and for more focused logic
			}
		);

		jQuery.event.trigger( e, null, elem );

		if ( e.isDefaultPrevented() ) {
			event.preventDefault();
		}
	}

} );

jQuery.fn.extend( {

	trigger: function( type, data ) {
		return this.each( function() {
			jQuery.event.trigger( type, data, this );
		} );
	},
	triggerHandler: function( type, data ) {
		var elem = this[ 0 ];
		if ( elem ) {
			return jQuery.event.trigger( type, data, elem, true );
		}
	}
} );


jQuery.each( ( "blur focus focusin focusout load resize scroll unload click dblclick " +
	"mousedown mouseup mousemove mouseover mouseout mouseenter mouseleave " +
	"change select submit keydown keypress keyup error contextmenu" ).split( " " ),
	function( i, name ) {

	// Handle event binding
	jQuery.fn[ name ] = function( data, fn ) {
		return arguments.length > 0 ?
			this.on( name, null, data, fn ) :
			this.trigger( name );
	};
} );

jQuery.fn.extend( {
	hover: function( fnOver, fnOut ) {
		return this.mouseenter( fnOver ).mouseleave( fnOut || fnOver );
	}
} );




support.focusin = "onfocusin" in window;


// Support: Firefox
// Firefox doesn't have focus(in | out) events
// Related ticket - https://bugzilla.mozilla.org/show_bug.cgi?id=687787
//
// Support: Chrome, Safari
// focus(in | out) events fire after focus & blur events,
// which is spec violation - http://www.w3.org/TR/DOM-Level-3-Events/#events-focusevent-event-order
// Related ticket - https://code.google.com/p/chromium/issues/detail?id=449857
if ( !support.focusin ) {
	jQuery.each( { focus: "focusin", blur: "focusout" }, function( orig, fix ) {

		// Attach a single capturing handler on the document while someone wants focusin/focusout
		var handler = function( event ) {
			jQuery.event.simulate( fix, event.target, jQuery.event.fix( event ) );
		};

		jQuery.event.special[ fix ] = {
			setup: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix );

				if ( !attaches ) {
					doc.addEventListener( orig, handler, true );
				}
				dataPriv.access( doc, fix, ( attaches || 0 ) + 1 );
			},
			teardown: function() {
				var doc = this.ownerDocument || this,
					attaches = dataPriv.access( doc, fix ) - 1;

				if ( !attaches ) {
					doc.removeEventListener( orig, handler, true );
					dataPriv.remove( doc, fix );

				} else {
					dataPriv.access( doc, fix, attaches );
				}
			}
		};
	} );
}
var location = window.location;

var nonce = jQuery.now();

var rquery = ( /\?/ );



// Support: Android 2.3
// Workaround failure to string-cast null input
jQuery.parseJSON = function( data ) {
	return JSON.parse( data + "" );
};


// Cross-browser xml parsing
jQuery.parseXML = function( data ) {
	var xml;
	if ( !data || typeof data !== "string" ) {
		return null;
	}

	// Support: IE9
	try {
		xml = ( new window.DOMParser() ).parseFromString( data, "text/xml" );
	} catch ( e ) {
		xml = undefined;
	}

	if ( !xml || xml.getElementsByTagName( "parsererror" ).length ) {
		jQuery.error( "Invalid XML: " + data );
	}
	return xml;
};


var
	rhash = /#.*$/,
	rts = /([?&])_=[^&]*/,
	rheaders = /^(.*?):[ \t]*([^\r\n]*)$/mg,

	// #7653, #8125, #8152: local protocol detection
	rlocalProtocol = /^(?:about|app|app-storage|.+-extension|file|res|widget):$/,
	rnoContent = /^(?:GET|HEAD)$/,
	rprotocol = /^\/\//,

	/* Prefilters
	 * 1) They are useful to introduce custom dataTypes (see ajax/jsonp.js for an example)
	 * 2) These are called:
	 *    - BEFORE asking for a transport
	 *    - AFTER param serialization (s.data is a string if s.processData is true)
	 * 3) key is the dataType
	 * 4) the catchall symbol "*" can be used
	 * 5) execution will start with transport dataType and THEN continue down to "*" if needed
	 */
	prefilters = {},

	/* Transports bindings
	 * 1) key is the dataType
	 * 2) the catchall symbol "*" can be used
	 * 3) selection will start with transport dataType and THEN go to "*" if needed
	 */
	transports = {},

	// Avoid comment-prolog char sequence (#10098); must appease lint and evade compression
	allTypes = "*/".concat( "*" ),

	// Anchor tag for parsing the document origin
	originAnchor = document.createElement( "a" );
	originAnchor.href = location.href;

// Base "constructor" for jQuery.ajaxPrefilter and jQuery.ajaxTransport
function addToPrefiltersOrTransports( structure ) {

	// dataTypeExpression is optional and defaults to "*"
	return function( dataTypeExpression, func ) {

		if ( typeof dataTypeExpression !== "string" ) {
			func = dataTypeExpression;
			dataTypeExpression = "*";
		}

		var dataType,
			i = 0,
			dataTypes = dataTypeExpression.toLowerCase().match( rnotwhite ) || [];

		if ( jQuery.isFunction( func ) ) {

			// For each dataType in the dataTypeExpression
			while ( ( dataType = dataTypes[ i++ ] ) ) {

				// Prepend if requested
				if ( dataType[ 0 ] === "+" ) {
					dataType = dataType.slice( 1 ) || "*";
					( structure[ dataType ] = structure[ dataType ] || [] ).unshift( func );

				// Otherwise append
				} else {
					( structure[ dataType ] = structure[ dataType ] || [] ).push( func );
				}
			}
		}
	};
}

// Base inspection function for prefilters and transports
function inspectPrefiltersOrTransports( structure, options, originalOptions, jqXHR ) {

	var inspected = {},
		seekingTransport = ( structure === transports );

	function inspect( dataType ) {
		var selected;
		inspected[ dataType ] = true;
		jQuery.each( structure[ dataType ] || [], function( _, prefilterOrFactory ) {
			var dataTypeOrTransport = prefilterOrFactory( options, originalOptions, jqXHR );
			if ( typeof dataTypeOrTransport === "string" &&
				!seekingTransport && !inspected[ dataTypeOrTransport ] ) {

				options.dataTypes.unshift( dataTypeOrTransport );
				inspect( dataTypeOrTransport );
				return false;
			} else if ( seekingTransport ) {
				return !( selected = dataTypeOrTransport );
			}
		} );
		return selected;
	}

	return inspect( options.dataTypes[ 0 ] ) || !inspected[ "*" ] && inspect( "*" );
}

// A special extend for ajax options
// that takes "flat" options (not to be deep extended)
// Fixes #9887
function ajaxExtend( target, src ) {
	var key, deep,
		flatOptions = jQuery.ajaxSettings.flatOptions || {};

	for ( key in src ) {
		if ( src[ key ] !== undefined ) {
			( flatOptions[ key ] ? target : ( deep || ( deep = {} ) ) )[ key ] = src[ key ];
		}
	}
	if ( deep ) {
		jQuery.extend( true, target, deep );
	}

	return target;
}

/* Handles responses to an ajax request:
 * - finds the right dataType (mediates between content-type and expected dataType)
 * - returns the corresponding response
 */
function ajaxHandleResponses( s, jqXHR, responses ) {

	var ct, type, finalDataType, firstDataType,
		contents = s.contents,
		dataTypes = s.dataTypes;

	// Remove auto dataType and get content-type in the process
	while ( dataTypes[ 0 ] === "*" ) {
		dataTypes.shift();
		if ( ct === undefined ) {
			ct = s.mimeType || jqXHR.getResponseHeader( "Content-Type" );
		}
	}

	// Check if we're dealing with a known content-type
	if ( ct ) {
		for ( type in contents ) {
			if ( contents[ type ] && contents[ type ].test( ct ) ) {
				dataTypes.unshift( type );
				break;
			}
		}
	}

	// Check to see if we have a response for the expected dataType
	if ( dataTypes[ 0 ] in responses ) {
		finalDataType = dataTypes[ 0 ];
	} else {

		// Try convertible dataTypes
		for ( type in responses ) {
			if ( !dataTypes[ 0 ] || s.converters[ type + " " + dataTypes[ 0 ] ] ) {
				finalDataType = type;
				break;
			}
			if ( !firstDataType ) {
				firstDataType = type;
			}
		}

		// Or just use first one
		finalDataType = finalDataType || firstDataType;
	}

	// If we found a dataType
	// We add the dataType to the list if needed
	// and return the corresponding response
	if ( finalDataType ) {
		if ( finalDataType !== dataTypes[ 0 ] ) {
			dataTypes.unshift( finalDataType );
		}
		return responses[ finalDataType ];
	}
}

/* Chain conversions given the request and the original response
 * Also sets the responseXXX fields on the jqXHR instance
 */
function ajaxConvert( s, response, jqXHR, isSuccess ) {
	var conv2, current, conv, tmp, prev,
		converters = {},

		// Work with a copy of dataTypes in case we need to modify it for conversion
		dataTypes = s.dataTypes.slice();

	// Create converters map with lowercased keys
	if ( dataTypes[ 1 ] ) {
		for ( conv in s.converters ) {
			converters[ conv.toLowerCase() ] = s.converters[ conv ];
		}
	}

	current = dataTypes.shift();

	// Convert to each sequential dataType
	while ( current ) {

		if ( s.responseFields[ current ] ) {
			jqXHR[ s.responseFields[ current ] ] = response;
		}

		// Apply the dataFilter if provided
		if ( !prev && isSuccess && s.dataFilter ) {
			response = s.dataFilter( response, s.dataType );
		}

		prev = current;
		current = dataTypes.shift();

		if ( current ) {

		// There's only work to do if current dataType is non-auto
			if ( current === "*" ) {

				current = prev;

			// Convert response if prev dataType is non-auto and differs from current
			} else if ( prev !== "*" && prev !== current ) {

				// Seek a direct converter
				conv = converters[ prev + " " + current ] || converters[ "* " + current ];

				// If none found, seek a pair
				if ( !conv ) {
					for ( conv2 in converters ) {

						// If conv2 outputs current
						tmp = conv2.split( " " );
						if ( tmp[ 1 ] === current ) {

							// If prev can be converted to accepted input
							conv = converters[ prev + " " + tmp[ 0 ] ] ||
								converters[ "* " + tmp[ 0 ] ];
							if ( conv ) {

								// Condense equivalence converters
								if ( conv === true ) {
									conv = converters[ conv2 ];

								// Otherwise, insert the intermediate dataType
								} else if ( converters[ conv2 ] !== true ) {
									current = tmp[ 0 ];
									dataTypes.unshift( tmp[ 1 ] );
								}
								break;
							}
						}
					}
				}

				// Apply converter (if not an equivalence)
				if ( conv !== true ) {

					// Unless errors are allowed to bubble, catch and return them
					if ( conv && s.throws ) {
						response = conv( response );
					} else {
						try {
							response = conv( response );
						} catch ( e ) {
							return {
								state: "parsererror",
								error: conv ? e : "No conversion from " + prev + " to " + current
							};
						}
					}
				}
			}
		}
	}

	return { state: "success", data: response };
}

jQuery.extend( {

	// Counter for holding the number of active queries
	active: 0,

	// Last-Modified header cache for next request
	lastModified: {},
	etag: {},

	ajaxSettings: {
		url: location.href,
		type: "GET",
		isLocal: rlocalProtocol.test( location.protocol ),
		global: true,
		processData: true,
		async: true,
		contentType: "application/x-www-form-urlencoded; charset=UTF-8",
		/*
		timeout: 0,
		data: null,
		dataType: null,
		username: null,
		password: null,
		cache: null,
		throws: false,
		traditional: false,
		headers: {},
		*/

		accepts: {
			"*": allTypes,
			text: "text/plain",
			html: "text/html",
			xml: "application/xml, text/xml",
			json: "application/json, text/javascript"
		},

		contents: {
			xml: /\bxml\b/,
			html: /\bhtml/,
			json: /\bjson\b/
		},

		responseFields: {
			xml: "responseXML",
			text: "responseText",
			json: "responseJSON"
		},

		// Data converters
		// Keys separate source (or catchall "*") and destination types with a single space
		converters: {

			// Convert anything to text
			"* text": String,

			// Text to html (true = no transformation)
			"text html": true,

			// Evaluate text as a json expression
			"text json": jQuery.parseJSON,

			// Parse text as xml
			"text xml": jQuery.parseXML
		},

		// For options that shouldn't be deep extended:
		// you can add your own custom options here if
		// and when you create one that shouldn't be
		// deep extended (see ajaxExtend)
		flatOptions: {
			url: true,
			context: true
		}
	},

	// Creates a full fledged settings object into target
	// with both ajaxSettings and settings fields.
	// If target is omitted, writes into ajaxSettings.
	ajaxSetup: function( target, settings ) {
		return settings ?

			// Building a settings object
			ajaxExtend( ajaxExtend( target, jQuery.ajaxSettings ), settings ) :

			// Extending ajaxSettings
			ajaxExtend( jQuery.ajaxSettings, target );
	},

	ajaxPrefilter: addToPrefiltersOrTransports( prefilters ),
	ajaxTransport: addToPrefiltersOrTransports( transports ),

	// Main method
	ajax: function( url, options ) {

		// If url is an object, simulate pre-1.5 signature
		if ( typeof url === "object" ) {
			options = url;
			url = undefined;
		}

		// Force options to be an object
		options = options || {};

		var transport,

			// URL without anti-cache param
			cacheURL,

			// Response headers
			responseHeadersString,
			responseHeaders,

			// timeout handle
			timeoutTimer,

			// Url cleanup var
			urlAnchor,

			// To know if global events are to be dispatched
			fireGlobals,

			// Loop variable
			i,

			// Create the final options object
			s = jQuery.ajaxSetup( {}, options ),

			// Callbacks context
			callbackContext = s.context || s,

			// Context for global events is callbackContext if it is a DOM node or jQuery collection
			globalEventContext = s.context &&
				( callbackContext.nodeType || callbackContext.jquery ) ?
					jQuery( callbackContext ) :
					jQuery.event,

			// Deferreds
			deferred = jQuery.Deferred(),
			completeDeferred = jQuery.Callbacks( "once memory" ),

			// Status-dependent callbacks
			statusCode = s.statusCode || {},

			// Headers (they are sent all at once)
			requestHeaders = {},
			requestHeadersNames = {},

			// The jqXHR state
			state = 0,

			// Default abort message
			strAbort = "canceled",

			// Fake xhr
			jqXHR = {
				readyState: 0,

				// Builds headers hashtable if needed
				getResponseHeader: function( key ) {
					var match;
					if ( state === 2 ) {
						if ( !responseHeaders ) {
							responseHeaders = {};
							while ( ( match = rheaders.exec( responseHeadersString ) ) ) {
								responseHeaders[ match[ 1 ].toLowerCase() ] = match[ 2 ];
							}
						}
						match = responseHeaders[ key.toLowerCase() ];
					}
					return match == null ? null : match;
				},

				// Raw string
				getAllResponseHeaders: function() {
					return state === 2 ? responseHeadersString : null;
				},

				// Caches the header
				setRequestHeader: function( name, value ) {
					var lname = name.toLowerCase();
					if ( !state ) {
						name = requestHeadersNames[ lname ] = requestHeadersNames[ lname ] || name;
						requestHeaders[ name ] = value;
					}
					return this;
				},

				// Overrides response content-type header
				overrideMimeType: function( type ) {
					if ( !state ) {
						s.mimeType = type;
					}
					return this;
				},

				// Status-dependent callbacks
				statusCode: function( map ) {
					var code;
					if ( map ) {
						if ( state < 2 ) {
							for ( code in map ) {

								// Lazy-add the new callback in a way that preserves old ones
								statusCode[ code ] = [ statusCode[ code ], map[ code ] ];
							}
						} else {

							// Execute the appropriate callbacks
							jqXHR.always( map[ jqXHR.status ] );
						}
					}
					return this;
				},

				// Cancel the request
				abort: function( statusText ) {
					var finalText = statusText || strAbort;
					if ( transport ) {
						transport.abort( finalText );
					}
					done( 0, finalText );
					return this;
				}
			};

		// Attach deferreds
		deferred.promise( jqXHR ).complete = completeDeferred.add;
		jqXHR.success = jqXHR.done;
		jqXHR.error = jqXHR.fail;

		// Remove hash character (#7531: and string promotion)
		// Add protocol if not provided (prefilters might expect it)
		// Handle falsy url in the settings object (#10093: consistency with old signature)
		// We also use the url parameter if available
		s.url = ( ( url || s.url || location.href ) + "" ).replace( rhash, "" )
			.replace( rprotocol, location.protocol + "//" );

		// Alias method option to type as per ticket #12004
		s.type = options.method || options.type || s.method || s.type;

		// Extract dataTypes list
		s.dataTypes = jQuery.trim( s.dataType || "*" ).toLowerCase().match( rnotwhite ) || [ "" ];

		// A cross-domain request is in order when the origin doesn't match the current origin.
		if ( s.crossDomain == null ) {
			urlAnchor = document.createElement( "a" );

			// Support: IE8-11+
			// IE throws exception if url is malformed, e.g. http://example.com:80x/
			try {
				urlAnchor.href = s.url;

				// Support: IE8-11+
				// Anchor's host property isn't correctly set when s.url is relative
				urlAnchor.href = urlAnchor.href;
				s.crossDomain = originAnchor.protocol + "//" + originAnchor.host !==
					urlAnchor.protocol + "//" + urlAnchor.host;
			} catch ( e ) {

				// If there is an error parsing the URL, assume it is crossDomain,
				// it can be rejected by the transport if it is invalid
				s.crossDomain = true;
			}
		}

		// Convert data if not already a string
		if ( s.data && s.processData && typeof s.data !== "string" ) {
			s.data = jQuery.param( s.data, s.traditional );
		}

		// Apply prefilters
		inspectPrefiltersOrTransports( prefilters, s, options, jqXHR );

		// If request was aborted inside a prefilter, stop there
		if ( state === 2 ) {
			return jqXHR;
		}

		// We can fire global events as of now if asked to
		// Don't fire events if jQuery.event is undefined in an AMD-usage scenario (#15118)
		fireGlobals = jQuery.event && s.global;

		// Watch for a new set of requests
		if ( fireGlobals && jQuery.active++ === 0 ) {
			jQuery.event.trigger( "ajaxStart" );
		}

		// Uppercase the type
		s.type = s.type.toUpperCase();

		// Determine if request has content
		s.hasContent = !rnoContent.test( s.type );

		// Save the URL in case we're toying with the If-Modified-Since
		// and/or If-None-Match header later on
		cacheURL = s.url;

		// More options handling for requests with no content
		if ( !s.hasContent ) {

			// If data is available, append data to url
			if ( s.data ) {
				cacheURL = ( s.url += ( rquery.test( cacheURL ) ? "&" : "?" ) + s.data );

				// #9682: remove data so that it's not used in an eventual retry
				delete s.data;
			}

			// Add anti-cache in url if needed
			if ( s.cache === false ) {
				s.url = rts.test( cacheURL ) ?

					// If there is already a '_' parameter, set its value
					cacheURL.replace( rts, "$1_=" + nonce++ ) :

					// Otherwise add one to the end
					cacheURL + ( rquery.test( cacheURL ) ? "&" : "?" ) + "_=" + nonce++;
			}
		}

		// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
		if ( s.ifModified ) {
			if ( jQuery.lastModified[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-Modified-Since", jQuery.lastModified[ cacheURL ] );
			}
			if ( jQuery.etag[ cacheURL ] ) {
				jqXHR.setRequestHeader( "If-None-Match", jQuery.etag[ cacheURL ] );
			}
		}

		// Set the correct header, if data is being sent
		if ( s.data && s.hasContent && s.contentType !== false || options.contentType ) {
			jqXHR.setRequestHeader( "Content-Type", s.contentType );
		}

		// Set the Accepts header for the server, depending on the dataType
		jqXHR.setRequestHeader(
			"Accept",
			s.dataTypes[ 0 ] && s.accepts[ s.dataTypes[ 0 ] ] ?
				s.accepts[ s.dataTypes[ 0 ] ] +
					( s.dataTypes[ 0 ] !== "*" ? ", " + allTypes + "; q=0.01" : "" ) :
				s.accepts[ "*" ]
		);

		// Check for headers option
		for ( i in s.headers ) {
			jqXHR.setRequestHeader( i, s.headers[ i ] );
		}

		// Allow custom headers/mimetypes and early abort
		if ( s.beforeSend &&
			( s.beforeSend.call( callbackContext, jqXHR, s ) === false || state === 2 ) ) {

			// Abort if not done already and return
			return jqXHR.abort();
		}

		// Aborting is no longer a cancellation
		strAbort = "abort";

		// Install callbacks on deferreds
		for ( i in { success: 1, error: 1, complete: 1 } ) {
			jqXHR[ i ]( s[ i ] );
		}

		// Get transport
		transport = inspectPrefiltersOrTransports( transports, s, options, jqXHR );

		// If no transport, we auto-abort
		if ( !transport ) {
			done( -1, "No Transport" );
		} else {
			jqXHR.readyState = 1;

			// Send global event
			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxSend", [ jqXHR, s ] );
			}

			// If request was aborted inside ajaxSend, stop there
			if ( state === 2 ) {
				return jqXHR;
			}

			// Timeout
			if ( s.async && s.timeout > 0 ) {
				timeoutTimer = window.setTimeout( function() {
					jqXHR.abort( "timeout" );
				}, s.timeout );
			}

			try {
				state = 1;
				transport.send( requestHeaders, done );
			} catch ( e ) {

				// Propagate exception as error if not done
				if ( state < 2 ) {
					done( -1, e );

				// Simply rethrow otherwise
				} else {
					throw e;
				}
			}
		}

		// Callback for when everything is done
		function done( status, nativeStatusText, responses, headers ) {
			var isSuccess, success, error, response, modified,
				statusText = nativeStatusText;

			// Called once
			if ( state === 2 ) {
				return;
			}

			// State is "done" now
			state = 2;

			// Clear timeout if it exists
			if ( timeoutTimer ) {
				window.clearTimeout( timeoutTimer );
			}

			// Dereference transport for early garbage collection
			// (no matter how long the jqXHR object will be used)
			transport = undefined;

			// Cache response headers
			responseHeadersString = headers || "";

			// Set readyState
			jqXHR.readyState = status > 0 ? 4 : 0;

			// Determine if successful
			isSuccess = status >= 200 && status < 300 || status === 304;

			// Get response data
			if ( responses ) {
				response = ajaxHandleResponses( s, jqXHR, responses );
			}

			// Convert no matter what (that way responseXXX fields are always set)
			response = ajaxConvert( s, response, jqXHR, isSuccess );

			// If successful, handle type chaining
			if ( isSuccess ) {

				// Set the If-Modified-Since and/or If-None-Match header, if in ifModified mode.
				if ( s.ifModified ) {
					modified = jqXHR.getResponseHeader( "Last-Modified" );
					if ( modified ) {
						jQuery.lastModified[ cacheURL ] = modified;
					}
					modified = jqXHR.getResponseHeader( "etag" );
					if ( modified ) {
						jQuery.etag[ cacheURL ] = modified;
					}
				}

				// if no content
				if ( status === 204 || s.type === "HEAD" ) {
					statusText = "nocontent";

				// if not modified
				} else if ( status === 304 ) {
					statusText = "notmodified";

				// If we have data, let's convert it
				} else {
					statusText = response.state;
					success = response.data;
					error = response.error;
					isSuccess = !error;
				}
			} else {

				// Extract error from statusText and normalize for non-aborts
				error = statusText;
				if ( status || !statusText ) {
					statusText = "error";
					if ( status < 0 ) {
						status = 0;
					}
				}
			}

			// Set data for the fake xhr object
			jqXHR.status = status;
			jqXHR.statusText = ( nativeStatusText || statusText ) + "";

			// Success/Error
			if ( isSuccess ) {
				deferred.resolveWith( callbackContext, [ success, statusText, jqXHR ] );
			} else {
				deferred.rejectWith( callbackContext, [ jqXHR, statusText, error ] );
			}

			// Status-dependent callbacks
			jqXHR.statusCode( statusCode );
			statusCode = undefined;

			if ( fireGlobals ) {
				globalEventContext.trigger( isSuccess ? "ajaxSuccess" : "ajaxError",
					[ jqXHR, s, isSuccess ? success : error ] );
			}

			// Complete
			completeDeferred.fireWith( callbackContext, [ jqXHR, statusText ] );

			if ( fireGlobals ) {
				globalEventContext.trigger( "ajaxComplete", [ jqXHR, s ] );

				// Handle the global AJAX counter
				if ( !( --jQuery.active ) ) {
					jQuery.event.trigger( "ajaxStop" );
				}
			}
		}

		return jqXHR;
	},

	getJSON: function( url, data, callback ) {
		return jQuery.get( url, data, callback, "json" );
	},

	getScript: function( url, callback ) {
		return jQuery.get( url, undefined, callback, "script" );
	}
} );

jQuery.each( [ "get", "post" ], function( i, method ) {
	jQuery[ method ] = function( url, data, callback, type ) {

		// Shift arguments if data argument was omitted
		if ( jQuery.isFunction( data ) ) {
			type = type || callback;
			callback = data;
			data = undefined;
		}

		// The url can be an options object (which then must have .url)
		return jQuery.ajax( jQuery.extend( {
			url: url,
			type: method,
			dataType: type,
			data: data,
			success: callback
		}, jQuery.isPlainObject( url ) && url ) );
	};
} );


jQuery._evalUrl = function( url ) {
	return jQuery.ajax( {
		url: url,

		// Make this explicit, since user can override this through ajaxSetup (#11264)
		type: "GET",
		dataType: "script",
		async: false,
		global: false,
		"throws": true
	} );
};


jQuery.fn.extend( {
	wrapAll: function( html ) {
		var wrap;

		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapAll( html.call( this, i ) );
			} );
		}

		if ( this[ 0 ] ) {

			// The elements to wrap the target around
			wrap = jQuery( html, this[ 0 ].ownerDocument ).eq( 0 ).clone( true );

			if ( this[ 0 ].parentNode ) {
				wrap.insertBefore( this[ 0 ] );
			}

			wrap.map( function() {
				var elem = this;

				while ( elem.firstElementChild ) {
					elem = elem.firstElementChild;
				}

				return elem;
			} ).append( this );
		}

		return this;
	},

	wrapInner: function( html ) {
		if ( jQuery.isFunction( html ) ) {
			return this.each( function( i ) {
				jQuery( this ).wrapInner( html.call( this, i ) );
			} );
		}

		return this.each( function() {
			var self = jQuery( this ),
				contents = self.contents();

			if ( contents.length ) {
				contents.wrapAll( html );

			} else {
				self.append( html );
			}
		} );
	},

	wrap: function( html ) {
		var isFunction = jQuery.isFunction( html );

		return this.each( function( i ) {
			jQuery( this ).wrapAll( isFunction ? html.call( this, i ) : html );
		} );
	},

	unwrap: function() {
		return this.parent().each( function() {
			if ( !jQuery.nodeName( this, "body" ) ) {
				jQuery( this ).replaceWith( this.childNodes );
			}
		} ).end();
	}
} );


jQuery.expr.filters.hidden = function( elem ) {
	return !jQuery.expr.filters.visible( elem );
};
jQuery.expr.filters.visible = function( elem ) {

	// Support: Opera <= 12.12
	// Opera reports offsetWidths and offsetHeights less than zero on some elements
	// Use OR instead of AND as the element is not visible if either is true
	// See tickets #10406 and #13132
	return elem.offsetWidth > 0 || elem.offsetHeight > 0 || elem.getClientRects().length > 0;
};




var r20 = /%20/g,
	rbracket = /\[\]$/,
	rCRLF = /\r?\n/g,
	rsubmitterTypes = /^(?:submit|button|image|reset|file)$/i,
	rsubmittable = /^(?:input|select|textarea|keygen)/i;

function buildParams( prefix, obj, traditional, add ) {
	var name;

	if ( jQuery.isArray( obj ) ) {

		// Serialize array item.
		jQuery.each( obj, function( i, v ) {
			if ( traditional || rbracket.test( prefix ) ) {

				// Treat each array item as a scalar.
				add( prefix, v );

			} else {

				// Item is non-scalar (array or object), encode its numeric index.
				buildParams(
					prefix + "[" + ( typeof v === "object" && v != null ? i : "" ) + "]",
					v,
					traditional,
					add
				);
			}
		} );

	} else if ( !traditional && jQuery.type( obj ) === "object" ) {

		// Serialize object item.
		for ( name in obj ) {
			buildParams( prefix + "[" + name + "]", obj[ name ], traditional, add );
		}

	} else {

		// Serialize scalar item.
		add( prefix, obj );
	}
}

// Serialize an array of form elements or a set of
// key/values into a query string
jQuery.param = function( a, traditional ) {
	var prefix,
		s = [],
		add = function( key, value ) {

			// If value is a function, invoke it and return its value
			value = jQuery.isFunction( value ) ? value() : ( value == null ? "" : value );
			s[ s.length ] = encodeURIComponent( key ) + "=" + encodeURIComponent( value );
		};

	// Set traditional to true for jQuery <= 1.3.2 behavior.
	if ( traditional === undefined ) {
		traditional = jQuery.ajaxSettings && jQuery.ajaxSettings.traditional;
	}

	// If an array was passed in, assume that it is an array of form elements.
	if ( jQuery.isArray( a ) || ( a.jquery && !jQuery.isPlainObject( a ) ) ) {

		// Serialize the form elements
		jQuery.each( a, function() {
			add( this.name, this.value );
		} );

	} else {

		// If traditional, encode the "old" way (the way 1.3.2 or older
		// did it), otherwise encode params recursively.
		for ( prefix in a ) {
			buildParams( prefix, a[ prefix ], traditional, add );
		}
	}

	// Return the resulting serialization
	return s.join( "&" ).replace( r20, "+" );
};

jQuery.fn.extend( {
	serialize: function() {
		return jQuery.param( this.serializeArray() );
	},
	serializeArray: function() {
		return this.map( function() {

			// Can add propHook for "elements" to filter or add form elements
			var elements = jQuery.prop( this, "elements" );
			return elements ? jQuery.makeArray( elements ) : this;
		} )
		.filter( function() {
			var type = this.type;

			// Use .is( ":disabled" ) so that fieldset[disabled] works
			return this.name && !jQuery( this ).is( ":disabled" ) &&
				rsubmittable.test( this.nodeName ) && !rsubmitterTypes.test( type ) &&
				( this.checked || !rcheckableType.test( type ) );
		} )
		.map( function( i, elem ) {
			var val = jQuery( this ).val();

			return val == null ?
				null :
				jQuery.isArray( val ) ?
					jQuery.map( val, function( val ) {
						return { name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
					} ) :
					{ name: elem.name, value: val.replace( rCRLF, "\r\n" ) };
		} ).get();
	}
} );


jQuery.ajaxSettings.xhr = function() {
	try {
		return new window.XMLHttpRequest();
	} catch ( e ) {}
};

var xhrSuccessStatus = {

		// File protocol always yields status code 0, assume 200
		0: 200,

		// Support: IE9
		// #1450: sometimes IE returns 1223 when it should be 204
		1223: 204
	},
	xhrSupported = jQuery.ajaxSettings.xhr();

support.cors = !!xhrSupported && ( "withCredentials" in xhrSupported );
support.ajax = xhrSupported = !!xhrSupported;

jQuery.ajaxTransport( function( options ) {
	var callback, errorCallback;

	// Cross domain only allowed if supported through XMLHttpRequest
	if ( support.cors || xhrSupported && !options.crossDomain ) {
		return {
			send: function( headers, complete ) {
				var i,
					xhr = options.xhr();

				xhr.open(
					options.type,
					options.url,
					options.async,
					options.username,
					options.password
				);

				// Apply custom fields if provided
				if ( options.xhrFields ) {
					for ( i in options.xhrFields ) {
						xhr[ i ] = options.xhrFields[ i ];
					}
				}

				// Override mime type if needed
				if ( options.mimeType && xhr.overrideMimeType ) {
					xhr.overrideMimeType( options.mimeType );
				}

				// X-Requested-With header
				// For cross-domain requests, seeing as conditions for a preflight are
				// akin to a jigsaw puzzle, we simply never set it to be sure.
				// (it can always be set on a per-request basis or even using ajaxSetup)
				// For same-domain requests, won't change header if already provided.
				if ( !options.crossDomain && !headers[ "X-Requested-With" ] ) {
					headers[ "X-Requested-With" ] = "XMLHttpRequest";
				}

				// Set headers
				for ( i in headers ) {
					xhr.setRequestHeader( i, headers[ i ] );
				}

				// Callback
				callback = function( type ) {
					return function() {
						if ( callback ) {
							callback = errorCallback = xhr.onload =
								xhr.onerror = xhr.onabort = xhr.onreadystatechange = null;

							if ( type === "abort" ) {
								xhr.abort();
							} else if ( type === "error" ) {

								// Support: IE9
								// On a manual native abort, IE9 throws
								// errors on any property access that is not readyState
								if ( typeof xhr.status !== "number" ) {
									complete( 0, "error" );
								} else {
									complete(

										// File: protocol always yields status 0; see #8605, #14207
										xhr.status,
										xhr.statusText
									);
								}
							} else {
								complete(
									xhrSuccessStatus[ xhr.status ] || xhr.status,
									xhr.statusText,

									// Support: IE9 only
									// IE9 has no XHR2 but throws on binary (trac-11426)
									// For XHR2 non-text, let the caller handle it (gh-2498)
									( xhr.responseType || "text" ) !== "text"  ||
									typeof xhr.responseText !== "string" ?
										{ binary: xhr.response } :
										{ text: xhr.responseText },
									xhr.getAllResponseHeaders()
								);
							}
						}
					};
				};

				// Listen to events
				xhr.onload = callback();
				errorCallback = xhr.onerror = callback( "error" );

				// Support: IE9
				// Use onreadystatechange to replace onabort
				// to handle uncaught aborts
				if ( xhr.onabort !== undefined ) {
					xhr.onabort = errorCallback;
				} else {
					xhr.onreadystatechange = function() {

						// Check readyState before timeout as it changes
						if ( xhr.readyState === 4 ) {

							// Allow onerror to be called first,
							// but that will not handle a native abort
							// Also, save errorCallback to a variable
							// as xhr.onerror cannot be accessed
							window.setTimeout( function() {
								if ( callback ) {
									errorCallback();
								}
							} );
						}
					};
				}

				// Create the abort callback
				callback = callback( "abort" );

				try {

					// Do send the request (this may raise an exception)
					xhr.send( options.hasContent && options.data || null );
				} catch ( e ) {

					// #14683: Only rethrow if this hasn't been notified as an error yet
					if ( callback ) {
						throw e;
					}
				}
			},

			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




// Install script dataType
jQuery.ajaxSetup( {
	accepts: {
		script: "text/javascript, application/javascript, " +
			"application/ecmascript, application/x-ecmascript"
	},
	contents: {
		script: /\b(?:java|ecma)script\b/
	},
	converters: {
		"text script": function( text ) {
			jQuery.globalEval( text );
			return text;
		}
	}
} );

// Handle cache's special case and crossDomain
jQuery.ajaxPrefilter( "script", function( s ) {
	if ( s.cache === undefined ) {
		s.cache = false;
	}
	if ( s.crossDomain ) {
		s.type = "GET";
	}
} );

// Bind script tag hack transport
jQuery.ajaxTransport( "script", function( s ) {

	// This transport only deals with cross domain requests
	if ( s.crossDomain ) {
		var script, callback;
		return {
			send: function( _, complete ) {
				script = jQuery( "<script>" ).prop( {
					charset: s.scriptCharset,
					src: s.url
				} ).on(
					"load error",
					callback = function( evt ) {
						script.remove();
						callback = null;
						if ( evt ) {
							complete( evt.type === "error" ? 404 : 200, evt.type );
						}
					}
				);

				// Use native DOM manipulation to avoid our domManip AJAX trickery
				document.head.appendChild( script[ 0 ] );
			},
			abort: function() {
				if ( callback ) {
					callback();
				}
			}
		};
	}
} );




var oldCallbacks = [],
	rjsonp = /(=)\?(?=&|$)|\?\?/;

// Default jsonp settings
jQuery.ajaxSetup( {
	jsonp: "callback",
	jsonpCallback: function() {
		var callback = oldCallbacks.pop() || ( jQuery.expando + "_" + ( nonce++ ) );
		this[ callback ] = true;
		return callback;
	}
} );

// Detect, normalize options and install callbacks for jsonp requests
jQuery.ajaxPrefilter( "json jsonp", function( s, originalSettings, jqXHR ) {

	var callbackName, overwritten, responseContainer,
		jsonProp = s.jsonp !== false && ( rjsonp.test( s.url ) ?
			"url" :
			typeof s.data === "string" &&
				( s.contentType || "" )
					.indexOf( "application/x-www-form-urlencoded" ) === 0 &&
				rjsonp.test( s.data ) && "data"
		);

	// Handle iff the expected data type is "jsonp" or we have a parameter to set
	if ( jsonProp || s.dataTypes[ 0 ] === "jsonp" ) {

		// Get callback name, remembering preexisting value associated with it
		callbackName = s.jsonpCallback = jQuery.isFunction( s.jsonpCallback ) ?
			s.jsonpCallback() :
			s.jsonpCallback;

		// Insert callback into url or form data
		if ( jsonProp ) {
			s[ jsonProp ] = s[ jsonProp ].replace( rjsonp, "$1" + callbackName );
		} else if ( s.jsonp !== false ) {
			s.url += ( rquery.test( s.url ) ? "&" : "?" ) + s.jsonp + "=" + callbackName;
		}

		// Use data converter to retrieve json after script execution
		s.converters[ "script json" ] = function() {
			if ( !responseContainer ) {
				jQuery.error( callbackName + " was not called" );
			}
			return responseContainer[ 0 ];
		};

		// Force json dataType
		s.dataTypes[ 0 ] = "json";

		// Install callback
		overwritten = window[ callbackName ];
		window[ callbackName ] = function() {
			responseContainer = arguments;
		};

		// Clean-up function (fires after converters)
		jqXHR.always( function() {

			// If previous value didn't exist - remove it
			if ( overwritten === undefined ) {
				jQuery( window ).removeProp( callbackName );

			// Otherwise restore preexisting value
			} else {
				window[ callbackName ] = overwritten;
			}

			// Save back as free
			if ( s[ callbackName ] ) {

				// Make sure that re-using the options doesn't screw things around
				s.jsonpCallback = originalSettings.jsonpCallback;

				// Save the callback name for future use
				oldCallbacks.push( callbackName );
			}

			// Call if it was a function and we have a response
			if ( responseContainer && jQuery.isFunction( overwritten ) ) {
				overwritten( responseContainer[ 0 ] );
			}

			responseContainer = overwritten = undefined;
		} );

		// Delegate to script
		return "script";
	}
} );




// Support: Safari 8+
// In Safari 8 documents created via document.implementation.createHTMLDocument
// collapse sibling forms: the second one becomes a child of the first one.
// Because of that, this security measure has to be disabled in Safari 8.
// https://bugs.webkit.org/show_bug.cgi?id=137337
support.createHTMLDocument = ( function() {
	var body = document.implementation.createHTMLDocument( "" ).body;
	body.innerHTML = "<form></form><form></form>";
	return body.childNodes.length === 2;
} )();


// Argument "data" should be string of html
// context (optional): If specified, the fragment will be created in this context,
// defaults to document
// keepScripts (optional): If true, will include scripts passed in the html string
jQuery.parseHTML = function( data, context, keepScripts ) {
	if ( !data || typeof data !== "string" ) {
		return null;
	}
	if ( typeof context === "boolean" ) {
		keepScripts = context;
		context = false;
	}

	// Stop scripts or inline event handlers from being executed immediately
	// by using document.implementation
	context = context || ( support.createHTMLDocument ?
		document.implementation.createHTMLDocument( "" ) :
		document );

	var parsed = rsingleTag.exec( data ),
		scripts = !keepScripts && [];

	// Single tag
	if ( parsed ) {
		return [ context.createElement( parsed[ 1 ] ) ];
	}

	parsed = buildFragment( [ data ], context, scripts );

	if ( scripts && scripts.length ) {
		jQuery( scripts ).remove();
	}

	return jQuery.merge( [], parsed.childNodes );
};


// Keep a copy of the old load method
var _load = jQuery.fn.load;

/**
 * Load a url into a page
 */
jQuery.fn.load = function( url, params, callback ) {
	if ( typeof url !== "string" && _load ) {
		return _load.apply( this, arguments );
	}

	var selector, type, response,
		self = this,
		off = url.indexOf( " " );

	if ( off > -1 ) {
		selector = jQuery.trim( url.slice( off ) );
		url = url.slice( 0, off );
	}

	// If it's a function
	if ( jQuery.isFunction( params ) ) {

		// We assume that it's the callback
		callback = params;
		params = undefined;

	// Otherwise, build a param string
	} else if ( params && typeof params === "object" ) {
		type = "POST";
	}

	// If we have elements to modify, make the request
	if ( self.length > 0 ) {
		jQuery.ajax( {
			url: url,

			// If "type" variable is undefined, then "GET" method will be used.
			// Make value of this field explicit since
			// user can override it through ajaxSetup method
			type: type || "GET",
			dataType: "html",
			data: params
		} ).done( function( responseText ) {

			// Save response for use in complete callback
			response = arguments;

			self.html( selector ?

				// If a selector was specified, locate the right elements in a dummy div
				// Exclude scripts to avoid IE 'Permission Denied' errors
				jQuery( "<div>" ).append( jQuery.parseHTML( responseText ) ).find( selector ) :

				// Otherwise use the full result
				responseText );

		// If the request succeeds, this function gets "data", "status", "jqXHR"
		// but they are ignored because response was set above.
		// If it fails, this function gets "jqXHR", "status", "error"
		} ).always( callback && function( jqXHR, status ) {
			self.each( function() {
				callback.apply( self, response || [ jqXHR.responseText, status, jqXHR ] );
			} );
		} );
	}

	return this;
};




// Attach a bunch of functions for handling common AJAX events
jQuery.each( [
	"ajaxStart",
	"ajaxStop",
	"ajaxComplete",
	"ajaxError",
	"ajaxSuccess",
	"ajaxSend"
], function( i, type ) {
	jQuery.fn[ type ] = function( fn ) {
		return this.on( type, fn );
	};
} );




jQuery.expr.filters.animated = function( elem ) {
	return jQuery.grep( jQuery.timers, function( fn ) {
		return elem === fn.elem;
	} ).length;
};




/**
 * Gets a window from an element
 */
function getWindow( elem ) {
	return jQuery.isWindow( elem ) ? elem : elem.nodeType === 9 && elem.defaultView;
}

jQuery.offset = {
	setOffset: function( elem, options, i ) {
		var curPosition, curLeft, curCSSTop, curTop, curOffset, curCSSLeft, calculatePosition,
			position = jQuery.css( elem, "position" ),
			curElem = jQuery( elem ),
			props = {};

		// Set position first, in-case top/left are set even on static elem
		if ( position === "static" ) {
			elem.style.position = "relative";
		}

		curOffset = curElem.offset();
		curCSSTop = jQuery.css( elem, "top" );
		curCSSLeft = jQuery.css( elem, "left" );
		calculatePosition = ( position === "absolute" || position === "fixed" ) &&
			( curCSSTop + curCSSLeft ).indexOf( "auto" ) > -1;

		// Need to be able to calculate position if either
		// top or left is auto and position is either absolute or fixed
		if ( calculatePosition ) {
			curPosition = curElem.position();
			curTop = curPosition.top;
			curLeft = curPosition.left;

		} else {
			curTop = parseFloat( curCSSTop ) || 0;
			curLeft = parseFloat( curCSSLeft ) || 0;
		}

		if ( jQuery.isFunction( options ) ) {

			// Use jQuery.extend here to allow modification of coordinates argument (gh-1848)
			options = options.call( elem, i, jQuery.extend( {}, curOffset ) );
		}

		if ( options.top != null ) {
			props.top = ( options.top - curOffset.top ) + curTop;
		}
		if ( options.left != null ) {
			props.left = ( options.left - curOffset.left ) + curLeft;
		}

		if ( "using" in options ) {
			options.using.call( elem, props );

		} else {
			curElem.css( props );
		}
	}
};

jQuery.fn.extend( {
	offset: function( options ) {
		if ( arguments.length ) {
			return options === undefined ?
				this :
				this.each( function( i ) {
					jQuery.offset.setOffset( this, options, i );
				} );
		}

		var docElem, win,
			elem = this[ 0 ],
			box = { top: 0, left: 0 },
			doc = elem && elem.ownerDocument;

		if ( !doc ) {
			return;
		}

		docElem = doc.documentElement;

		// Make sure it's not a disconnected DOM node
		if ( !jQuery.contains( docElem, elem ) ) {
			return box;
		}

		box = elem.getBoundingClientRect();
		win = getWindow( doc );
		return {
			top: box.top + win.pageYOffset - docElem.clientTop,
			left: box.left + win.pageXOffset - docElem.clientLeft
		};
	},

	position: function() {
		if ( !this[ 0 ] ) {
			return;
		}

		var offsetParent, offset,
			elem = this[ 0 ],
			parentOffset = { top: 0, left: 0 };

		// Fixed elements are offset from window (parentOffset = {top:0, left: 0},
		// because it is its only offset parent
		if ( jQuery.css( elem, "position" ) === "fixed" ) {

			// Assume getBoundingClientRect is there when computed position is fixed
			offset = elem.getBoundingClientRect();

		} else {

			// Get *real* offsetParent
			offsetParent = this.offsetParent();

			// Get correct offsets
			offset = this.offset();
			if ( !jQuery.nodeName( offsetParent[ 0 ], "html" ) ) {
				parentOffset = offsetParent.offset();
			}

			// Add offsetParent borders
			// Subtract offsetParent scroll positions
			parentOffset.top += jQuery.css( offsetParent[ 0 ], "borderTopWidth", true ) -
				offsetParent.scrollTop();
			parentOffset.left += jQuery.css( offsetParent[ 0 ], "borderLeftWidth", true ) -
				offsetParent.scrollLeft();
		}

		// Subtract parent offsets and element margins
		return {
			top: offset.top - parentOffset.top - jQuery.css( elem, "marginTop", true ),
			left: offset.left - parentOffset.left - jQuery.css( elem, "marginLeft", true )
		};
	},

	// This method will return documentElement in the following cases:
	// 1) For the element inside the iframe without offsetParent, this method will return
	//    documentElement of the parent window
	// 2) For the hidden or detached element
	// 3) For body or html element, i.e. in case of the html node - it will return itself
	//
	// but those exceptions were never presented as a real life use-cases
	// and might be considered as more preferable results.
	//
	// This logic, however, is not guaranteed and can change at any point in the future
	offsetParent: function() {
		return this.map( function() {
			var offsetParent = this.offsetParent;

			while ( offsetParent && jQuery.css( offsetParent, "position" ) === "static" ) {
				offsetParent = offsetParent.offsetParent;
			}

			return offsetParent || documentElement;
		} );
	}
} );

// Create scrollLeft and scrollTop methods
jQuery.each( { scrollLeft: "pageXOffset", scrollTop: "pageYOffset" }, function( method, prop ) {
	var top = "pageYOffset" === prop;

	jQuery.fn[ method ] = function( val ) {
		return access( this, function( elem, method, val ) {
			var win = getWindow( elem );

			if ( val === undefined ) {
				return win ? win[ prop ] : elem[ method ];
			}

			if ( win ) {
				win.scrollTo(
					!top ? val : win.pageXOffset,
					top ? val : win.pageYOffset
				);

			} else {
				elem[ method ] = val;
			}
		}, method, val, arguments.length );
	};
} );

// Support: Safari<7-8+, Chrome<37-44+
// Add the top/left cssHooks using jQuery.fn.position
// Webkit bug: https://bugs.webkit.org/show_bug.cgi?id=29084
// Blink bug: https://code.google.com/p/chromium/issues/detail?id=229280
// getComputedStyle returns percent when specified for top/left/bottom/right;
// rather than make the css module depend on the offset module, just check for it here
jQuery.each( [ "top", "left" ], function( i, prop ) {
	jQuery.cssHooks[ prop ] = addGetHookIf( support.pixelPosition,
		function( elem, computed ) {
			if ( computed ) {
				computed = curCSS( elem, prop );

				// If curCSS returns percentage, fallback to offset
				return rnumnonpx.test( computed ) ?
					jQuery( elem ).position()[ prop ] + "px" :
					computed;
			}
		}
	);
} );


// Create innerHeight, innerWidth, height, width, outerHeight and outerWidth methods
jQuery.each( { Height: "height", Width: "width" }, function( name, type ) {
	jQuery.each( { padding: "inner" + name, content: type, "": "outer" + name },
		function( defaultExtra, funcName ) {

		// Margin is only for outerHeight, outerWidth
		jQuery.fn[ funcName ] = function( margin, value ) {
			var chainable = arguments.length && ( defaultExtra || typeof margin !== "boolean" ),
				extra = defaultExtra || ( margin === true || value === true ? "margin" : "border" );

			return access( this, function( elem, type, value ) {
				var doc;

				if ( jQuery.isWindow( elem ) ) {

					// As of 5/8/2012 this will yield incorrect results for Mobile Safari, but there
					// isn't a whole lot we can do. See pull request at this URL for discussion:
					// https://github.com/jquery/jquery/pull/764
					return elem.document.documentElement[ "client" + name ];
				}

				// Get document width or height
				if ( elem.nodeType === 9 ) {
					doc = elem.documentElement;

					// Either scroll[Width/Height] or offset[Width/Height] or client[Width/Height],
					// whichever is greatest
					return Math.max(
						elem.body[ "scroll" + name ], doc[ "scroll" + name ],
						elem.body[ "offset" + name ], doc[ "offset" + name ],
						doc[ "client" + name ]
					);
				}

				return value === undefined ?

					// Get width or height on the element, requesting but not forcing parseFloat
					jQuery.css( elem, type, extra ) :

					// Set width or height on the element
					jQuery.style( elem, type, value, extra );
			}, type, chainable ? margin : undefined, chainable, null );
		};
	} );
} );


jQuery.fn.extend( {

	bind: function( types, data, fn ) {
		return this.on( types, null, data, fn );
	},
	unbind: function( types, fn ) {
		return this.off( types, null, fn );
	},

	delegate: function( selector, types, data, fn ) {
		return this.on( types, selector, data, fn );
	},
	undelegate: function( selector, types, fn ) {

		// ( namespace ) or ( selector, types [, fn] )
		return arguments.length === 1 ?
			this.off( selector, "**" ) :
			this.off( types, selector || "**", fn );
	},
	size: function() {
		return this.length;
	}
} );

jQuery.fn.andSelf = jQuery.fn.addBack;




// Register as a named AMD module, since jQuery can be concatenated with other
// files that may use define, but not via a proper concatenation script that
// understands anonymous AMD modules. A named AMD is safest and most robust
// way to register. Lowercase jquery is used because AMD module names are
// derived from file names, and jQuery is normally delivered in a lowercase
// file name. Do this after creating the global so that if an AMD module wants
// to call noConflict to hide this version of jQuery, it will work.

// Note that for maximum portability, libraries that are not jQuery should
// declare themselves as anonymous modules, and avoid setting a global if an
// AMD loader is present. jQuery is a special case. For more information, see
// https://github.com/jrburke/requirejs/wiki/Updating-existing-libraries#wiki-anon

if ( typeof define === "function" && define.amd ) {
	define( "jquery", [], function() {
		return jQuery;
	} );
}



var

	// Map over jQuery in case of overwrite
	_jQuery = window.jQuery,

	// Map over the $ in case of overwrite
	_$ = window.$;

jQuery.noConflict = function( deep ) {
	if ( window.$ === jQuery ) {
		window.$ = _$;
	}

	if ( deep && window.jQuery === jQuery ) {
		window.jQuery = _jQuery;
	}

	return jQuery;
};

// Expose jQuery and $ identifiers, even in AMD
// (#7102#comment:10, https://github.com/jquery/jquery/pull/557)
// and CommonJS for browser emulators (#13566)
if ( !noGlobal ) {
	window.jQuery = window.$ = jQuery;
}

return jQuery;
}));

},{}],6:[function(require,module,exports){
(function (global){
/*!
 * Lo-Dash v0.9.2 <http://lodash.com>
 * (c) 2012 John-David Dalton <http://allyoucanleet.com/>
 * Based on Underscore.js 1.4.2 <http://underscorejs.org>
 * (c) 2009-2012 Jeremy Ashkenas, DocumentCloud Inc.
 * Available under MIT license <http://lodash.com/license>
 */
;(function(window, undefined) {

  /** Detect free variable `exports` */
  var freeExports = typeof exports == 'object' && exports;

  /** Detect free variable `global` and use it as `window` */
  var freeGlobal = typeof global == 'object' && global;
  if (freeGlobal.global === freeGlobal) {
    window = freeGlobal;
  }

  /** Used for array and object method references */
  var arrayRef = [],
      // avoid a Closure Compiler bug by creatively creating an object
      objectRef = new function(){};

  /** Used to generate unique IDs */
  var idCounter = 0;

  /** Used internally to indicate various things */
  var indicatorObject = objectRef;

  /** Used by `cachedContains` as the default size when optimizations are enabled for large arrays */
  var largeArraySize = 30;

  /** Used to restore the original `_` reference in `noConflict` */
  var oldDash = window._;

  /** Used to detect template delimiter values that require a with-statement */
  var reComplexDelimiter = /[-?+=!~*%&^<>|{(\/]|\[\D|\b(?:delete|in|instanceof|new|typeof|void)\b/;

  /** Used to match HTML entities */
  var reEscapedHtml = /&(?:amp|lt|gt|quot|#x27);/g;

  /** Used to match empty string literals in compiled template source */
  var reEmptyStringLeading = /\b__p \+= '';/g,
      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  /** Used to match regexp flags from their coerced string values */
  var reFlags = /\w*$/;

  /** Used to insert the data object variable into compiled template source */
  var reInsertVariable = /(?:__e|__t = )\(\s*(?![\d\s"']|this\.)/g;

  /** Used to detect if a method is native */
  var reNative = RegExp('^' +
    (objectRef.valueOf + '')
      .replace(/[.*+?^=!:${}()|[\]\/\\]/g, '\\$&')
      .replace(/valueOf|for [^\]]+/g, '.+?') + '$'
  );

  /**
   * Used to match ES6 template delimiters
   * http://people.mozilla.org/~jorendorff/es6-draft.html#sec-7.8.6
   */
  var reEsTemplate = /\$\{((?:(?=\\?)\\?[\s\S])*?)}/g;

  /** Used to match "interpolate" template delimiters */
  var reInterpolate = /<%=([\s\S]+?)%>/g;

  /** Used to ensure capturing order of template delimiters */
  var reNoMatch = /($^)/;

  /** Used to match HTML characters */
  var reUnescapedHtml = /[&<>"']/g;

  /** Used to match unescaped characters in compiled string literals */
  var reUnescapedString = /['\n\r\t\u2028\u2029\\]/g;

  /** Used to fix the JScript [[DontEnum]] bug */
  var shadowed = [
    'constructor', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable',
    'toLocaleString', 'toString', 'valueOf'
  ];

  /** Used to make template sourceURLs easier to identify */
  var templateCounter = 0;

  /** Native method shortcuts */
  var ceil = Math.ceil,
      concat = arrayRef.concat,
      floor = Math.floor,
      getPrototypeOf = reNative.test(getPrototypeOf = Object.getPrototypeOf) && getPrototypeOf,
      hasOwnProperty = objectRef.hasOwnProperty,
      push = arrayRef.push,
      propertyIsEnumerable = objectRef.propertyIsEnumerable,
      slice = arrayRef.slice,
      toString = objectRef.toString;

  /* Native method shortcuts for methods with the same name as other `lodash` methods */
  var nativeBind = reNative.test(nativeBind = slice.bind) && nativeBind,
      nativeIsArray = reNative.test(nativeIsArray = Array.isArray) && nativeIsArray,
      nativeIsFinite = window.isFinite,
      nativeIsNaN = window.isNaN,
      nativeKeys = reNative.test(nativeKeys = Object.keys) && nativeKeys,
      nativeMax = Math.max,
      nativeMin = Math.min,
      nativeRandom = Math.random;

  /** `Object#toString` result shortcuts */
  var argsClass = '[object Arguments]',
      arrayClass = '[object Array]',
      boolClass = '[object Boolean]',
      dateClass = '[object Date]',
      funcClass = '[object Function]',
      numberClass = '[object Number]',
      objectClass = '[object Object]',
      regexpClass = '[object RegExp]',
      stringClass = '[object String]';

  /**
   * Detect the JScript [[DontEnum]] bug:
   *
   * In IE < 9 an objects own properties, shadowing non-enumerable ones, are
   * made non-enumerable as well.
   */
  var hasDontEnumBug;

  /** Detect if own properties are iterated after inherited properties (IE < 9) */
  var iteratesOwnLast;

  /**
   * Detect if `Array#shift` and `Array#splice` augment array-like objects
   * incorrectly:
   *
   * Firefox < 10, IE compatibility mode, and IE < 9 have buggy Array `shift()`
   * and `splice()` functions that fail to remove the last element, `value[0]`,
   * of array-like objects even though the `length` property is set to `0`.
   * The `shift()` method is buggy in IE 8 compatibility mode, while `splice()`
   * is buggy regardless of mode in IE < 9 and buggy in compatibility mode in IE 9.
   */
  var hasObjectSpliceBug = (hasObjectSpliceBug = { '0': 1, 'length': 1 },
    arrayRef.splice.call(hasObjectSpliceBug, 0, 1), hasObjectSpliceBug[0]);

  /** Detect if an `arguments` object's indexes are non-enumerable (IE < 9) */
  var noArgsEnum = true;

  (function() {
    var props = [];
    function ctor() { this.x = 1; }
    ctor.prototype = { 'valueOf': 1, 'y': 1 };
    for (var prop in new ctor) { props.push(prop); }
    for (prop in arguments) { noArgsEnum = !prop; }

    hasDontEnumBug = !/valueOf/.test(props);
    iteratesOwnLast = props[0] != 'x';
  }(1));

  /** Detect if an `arguments` object's [[Class]] is unresolvable (Firefox < 4, IE < 9) */
  var noArgsClass = !isArguments(arguments);

  /** Detect if `Array#slice` cannot be used to convert strings to arrays (Opera < 10.52) */
  var noArraySliceOnStrings = slice.call('x')[0] != 'x';

  /**
   * Detect lack of support for accessing string characters by index:
   *
   * IE < 8 can't access characters by index and IE 8 can only access
   * characters by index on string literals.
   */
  var noCharByIndex = ('x'[0] + Object('x')[0]) != 'xx';

  /**
   * Detect if a node's [[Class]] is unresolvable (IE < 9)
   * and that the JS engine won't error when attempting to coerce an object to
   * a string without a `toString` property value of `typeof` "function".
   */
  try {
    var noNodeClass = ({ 'toString': 0 } + '', toString.call(window.document || 0) == objectClass);
  } catch(e) { }

  /* Detect if `Function#bind` exists and is inferred to be fast (all but V8) */
  var isBindFast = nativeBind && /\n|Opera/.test(nativeBind + toString.call(window.opera));

  /* Detect if `Object.keys` exists and is inferred to be fast (IE, Opera, V8) */
  var isKeysFast = nativeKeys && /^.+$|true/.test(nativeKeys + !!window.attachEvent);

  /**
   * Detect if sourceURL syntax is usable without erroring:
   *
   * The JS engine in Adobe products, like InDesign, will throw a syntax error
   * when it encounters a single line comment beginning with the `@` symbol.
   *
   * The JS engine in Narwhal will generate the function `function anonymous(){//}`
   * and throw a syntax error.
   *
   * Avoid comments beginning `@` symbols in IE because they are part of its
   * non-standard conditional compilation support.
   * http://msdn.microsoft.com/en-us/library/121hztk3(v=vs.94).aspx
   */
  try {
    var useSourceURL = (Function('//@')(), !window.attachEvent);
  } catch(e) { }

  /** Used to identify object classifications that `_.clone` supports */
  var cloneableClasses = {};
  cloneableClasses[argsClass] = cloneableClasses[funcClass] = false;
  cloneableClasses[arrayClass] = cloneableClasses[boolClass] = cloneableClasses[dateClass] =
  cloneableClasses[numberClass] = cloneableClasses[objectClass] = cloneableClasses[regexpClass] =
  cloneableClasses[stringClass] = true;

  /** Used to determine if values are of the language type Object */
  var objectTypes = {
    'boolean': false,
    'function': true,
    'object': true,
    'number': false,
    'string': false,
    'undefined': false
  };

  /** Used to escape characters for inclusion in compiled string literals */
  var stringEscapes = {
    '\\': '\\',
    "'": "'",
    '\n': 'n',
    '\r': 'r',
    '\t': 't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  /*--------------------------------------------------------------------------*/

  /**
   * The `lodash` function.
   *
   * @name _
   * @constructor
   * @category Chaining
   * @param {Mixed} value The value to wrap in a `lodash` instance.
   * @returns {Object} Returns a `lodash` instance.
   */
  function lodash(value) {
    // exit early if already wrapped
    if (value && value.__wrapped__) {
      return value;
    }
    // allow invoking `lodash` without the `new` operator
    if (!(this instanceof lodash)) {
      return new lodash(value);
    }
    this.__wrapped__ = value;
  }

  /**
   * By default, the template delimiters used by Lo-Dash are similar to those in
   * embedded Ruby (ERB). Change the following template settings to use alternative
   * delimiters.
   *
   * @static
   * @memberOf _
   * @type Object
   */
  lodash.templateSettings = {

    /**
     * Used to detect `data` property values to be HTML-escaped.
     *
     * @static
     * @memberOf _.templateSettings
     * @type RegExp
     */
    'escape': /<%-([\s\S]+?)%>/g,

    /**
     * Used to detect code to be evaluated.
     *
     * @static
     * @memberOf _.templateSettings
     * @type RegExp
     */
    'evaluate': /<%([\s\S]+?)%>/g,

    /**
     * Used to detect `data` property values to inject.
     *
     * @static
     * @memberOf _.templateSettings
     * @type RegExp
     */
    'interpolate': reInterpolate,

    /**
     * Used to reference the data object in the template text.
     *
     * @static
     * @memberOf _.templateSettings
     * @type String
     */
    'variable': ''
  };

  /*--------------------------------------------------------------------------*/

  /**
   * The template used to create iterator functions.
   *
   * @private
   * @param {Obect} data The data object used to populate the text.
   * @returns {String} Returns the interpolated text.
   */
  var iteratorTemplate = template(
    // conditional strict mode
    '<% if (obj.useStrict) { %>\'use strict\';\n<% } %>' +

    // the `iteratee` may be reassigned by the `top` snippet
    'var index, value, iteratee = <%= firstArg %>, ' +
    // assign the `result` variable an initial value
    'result = <%= firstArg %>;\n' +
    // exit early if the first argument is falsey
    'if (!<%= firstArg %>) return result;\n' +
    // add code before the iteration branches
    '<%= top %>;\n' +

    // array-like iteration:
    '<% if (arrayLoop) { %>' +
    'var length = iteratee.length; index = -1;\n' +
    'if (typeof length == \'number\') {' +

    // add support for accessing string characters by index if needed
    '  <% if (noCharByIndex) { %>\n' +
    '  if (isString(iteratee)) {\n' +
    '    iteratee = iteratee.split(\'\')\n' +
    '  }' +
    '  <% } %>\n' +

    // iterate over the array-like value
    '  while (++index < length) {\n' +
    '    value = iteratee[index];\n' +
    '    <%= arrayLoop %>\n' +
    '  }\n' +
    '}\n' +
    'else {' +

    // object iteration:
    // add support for iterating over `arguments` objects if needed
    '  <%  } else if (noArgsEnum) { %>\n' +
    '  var length = iteratee.length; index = -1;\n' +
    '  if (length && isArguments(iteratee)) {\n' +
    '    while (++index < length) {\n' +
    '      value = iteratee[index += \'\'];\n' +
    '      <%= objectLoop %>\n' +
    '    }\n' +
    '  } else {' +
    '  <% } %>' +

    // Firefox < 3.6, Opera > 9.50 - Opera < 11.60, and Safari < 5.1
    // (if the prototype or a property on the prototype has been set)
    // incorrectly sets a function's `prototype` property [[Enumerable]]
    // value to `true`. Because of this Lo-Dash standardizes on skipping
    // the the `prototype` property of functions regardless of its
    // [[Enumerable]] value.
    '  <% if (!hasDontEnumBug) { %>\n' +
    '  var skipProto = typeof iteratee == \'function\' && \n' +
    '    propertyIsEnumerable.call(iteratee, \'prototype\');\n' +
    '  <% } %>' +

    // iterate own properties using `Object.keys` if it's fast
    '  <% if (isKeysFast && useHas) { %>\n' +
    '  var ownIndex = -1,\n' +
    '      ownProps = objectTypes[typeof iteratee] ? nativeKeys(iteratee) : [],\n' +
    '      length = ownProps.length;\n\n' +
    '  while (++ownIndex < length) {\n' +
    '    index = ownProps[ownIndex];\n' +
    '    <% if (!hasDontEnumBug) { %>if (!(skipProto && index == \'prototype\')) {\n  <% } %>' +
    '    value = iteratee[index];\n' +
    '    <%= objectLoop %>\n' +
    '    <% if (!hasDontEnumBug) { %>}\n<% } %>' +
    '  }' +

    // else using a for-in loop
    '  <% } else { %>\n' +
    '  for (index in iteratee) {<%' +
    '    if (!hasDontEnumBug || useHas) { %>\n    if (<%' +
    '      if (!hasDontEnumBug) { %>!(skipProto && index == \'prototype\')<% }' +
    '      if (!hasDontEnumBug && useHas) { %> && <% }' +
    '      if (useHas) { %>hasOwnProperty.call(iteratee, index)<% }' +
    '    %>) {' +
    '    <% } %>\n' +
    '    value = iteratee[index];\n' +
    '    <%= objectLoop %>;' +
    '    <% if (!hasDontEnumBug || useHas) { %>\n    }<% } %>\n' +
    '  }' +
    '  <% } %>' +

    // Because IE < 9 can't set the `[[Enumerable]]` attribute of an
    // existing property and the `constructor` property of a prototype
    // defaults to non-enumerable, Lo-Dash skips the `constructor`
    // property when it infers it's iterating over a `prototype` object.
    '  <% if (hasDontEnumBug) { %>\n\n' +
    '  var ctor = iteratee.constructor;\n' +
    '    <% for (var k = 0; k < 7; k++) { %>\n' +
    '  index = \'<%= shadowed[k] %>\';\n' +
    '  if (<%' +
    '      if (shadowed[k] == \'constructor\') {' +
    '        %>!(ctor && ctor.prototype === iteratee) && <%' +
    '      } %>hasOwnProperty.call(iteratee, index)) {\n' +
    '    value = iteratee[index];\n' +
    '    <%= objectLoop %>\n' +
    '  }' +
    '    <% } %>' +
    '  <% } %>' +
    '  <% if (arrayLoop || noArgsEnum) { %>\n}<% } %>\n' +

    // add code to the bottom of the iteration function
    '<%= bottom %>;\n' +
    // finally, return the `result`
    'return result'
  );

  /**
   * Reusable iterator options shared by `forEach`, `forIn`, and `forOwn`.
   */
  var forEachIteratorOptions = {
    'args': 'collection, callback, thisArg',
    'top': 'callback = createCallback(callback, thisArg)',
    'arrayLoop': 'if (callback(value, index, collection) === false) return result',
    'objectLoop': 'if (callback(value, index, collection) === false) return result'
  };

  /** Reusable iterator options for `defaults`, and `extend` */
  var extendIteratorOptions = {
    'useHas': false,
    'args': 'object',
    'top':
      'for (var argsIndex = 1, argsLength = arguments.length; argsIndex < argsLength; argsIndex++) {\n' +
      '  if (iteratee = arguments[argsIndex]) {',
    'objectLoop': 'result[index] = value',
    'bottom': '  }\n}'
  };

  /** Reusable iterator options for `forIn` and `forOwn` */
  var forOwnIteratorOptions = {
    'arrayLoop': null
  };

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a function optimized to search large arrays for a given `value`,
   * starting at `fromIndex`, using strict equality for comparisons, i.e. `===`.
   *
   * @private
   * @param {Array} array The array to search.
   * @param {Mixed} value The value to search for.
   * @param {Number} [fromIndex=0] The index to search from.
   * @param {Number} [largeSize=30] The length at which an array is considered large.
   * @returns {Boolean} Returns `true` if `value` is found, else `false`.
   */
  function cachedContains(array, fromIndex, largeSize) {
    fromIndex || (fromIndex = 0);

    var length = array.length,
        isLarge = (length - fromIndex) >= (largeSize || largeArraySize);

    if (isLarge) {
      var cache = {},
          index = fromIndex - 1;

      while (++index < length) {
        // manually coerce `value` to a string because `hasOwnProperty`, in some
        // older versions of Firefox, coerces objects incorrectly
        var key = array[index] + '';
        (hasOwnProperty.call(cache, key) ? cache[key] : (cache[key] = [])).push(array[index]);
      }
    }
    return function(value) {
      if (isLarge) {
        var key = value + '';
        return hasOwnProperty.call(cache, key) && indexOf(cache[key], value) > -1;
      }
      return indexOf(array, value, fromIndex) > -1;
    }
  }

  /**
   * Used by `_.max` and `_.min` as the default `callback` when a given
   * `collection` is a string value.
   *
   * @private
   * @param {String} value The character to inspect.
   * @returns {Number} Returns the code unit of given character.
   */
  function charAtCallback(value) {
    return value.charCodeAt(0);
  }

  /**
   * Used by `sortBy` to compare transformed `collection` values, stable sorting
   * them in ascending order.
   *
   * @private
   * @param {Object} a The object to compare to `b`.
   * @param {Object} b The object to compare to `a`.
   * @returns {Number} Returns the sort order indicator of `1` or `-1`.
   */
  function compareAscending(a, b) {
    var ai = a.index,
        bi = b.index;

    a = a.criteria;
    b = b.criteria;

    // ensure a stable sort in V8 and other engines
    // http://code.google.com/p/v8/issues/detail?id=90
    if (a !== b) {
      if (a > b || a === undefined) {
        return 1;
      }
      if (a < b || b === undefined) {
        return -1;
      }
    }
    return ai < bi ? -1 : 1;
  }

  /**
   * Creates a function that, when called, invokes `func` with the `this`
   * binding of `thisArg` and prepends any `partailArgs` to the arguments passed
   * to the bound function.
   *
   * @private
   * @param {Function|String} func The function to bind or the method name.
   * @param {Mixed} [thisArg] The `this` binding of `func`.
   * @param {Array} partialArgs An array of arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   */
  function createBound(func, thisArg, partialArgs) {
    var isFunc = isFunction(func),
        isPartial = !partialArgs,
        methodName = func;

    // juggle arguments
    if (isPartial) {
      partialArgs = thisArg;
    }

    function bound() {
      // `Function#bind` spec
      // http://es5.github.com/#x15.3.4.5
      var args = arguments,
          thisBinding = isPartial ? this : thisArg;

      if (!isFunc) {
        func = thisArg[methodName];
      }
      if (partialArgs.length) {
        args = args.length
          ? partialArgs.concat(slice.call(args))
          : partialArgs;
      }
      if (this instanceof bound) {
        // get `func` instance if `bound` is invoked in a `new` expression
        noop.prototype = func.prototype;
        thisBinding = new noop;

        // mimic the constructor's `return` behavior
        // http://es5.github.com/#x13.2.2
        var result = func.apply(thisBinding, args);
        return isObject(result)
          ? result
          : thisBinding
      }
      return func.apply(thisBinding, args);
    }
    return bound;
  }

  /**
   * Produces an iteration callback bound to an optional `thisArg`. If `func` is
   * a property name, the callback will return the property value for a given element.
   *
   * @private
   * @param {Function|String} [func=identity|property] The function called per
   * iteration or property name to query.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Function} Returns a callback function.
   */
  function createCallback(func, thisArg) {
    if (!func) {
      return identity;
    }
    if (typeof func != 'function') {
      return function(object) {
        return object[func];
      };
    }
    if (thisArg !== undefined) {
      return function(value, index, object) {
        return func.call(thisArg, value, index, object);
      };
    }
    return func;
  }

  /**
   * Creates compiled iteration functions.
   *
   * @private
   * @param {Object} [options1, options2, ...] The compile options object(s).
   *  useHas - A boolean to specify using `hasOwnProperty` checks in the object loop.
   *  args - A string of comma separated arguments the iteration function will accept.
   *  top - A string of code to execute before the iteration branches.
   *  arrayLoop - A string of code to execute in the array loop.
   *  objectLoop - A string of code to execute in the object loop.
   *  bottom - A string of code to execute after the iteration branches.
   *
   * @returns {Function} Returns the compiled function.
   */
  function createIterator() {
    var data = {
      'arrayLoop': '',
      'bottom': '',
      'hasDontEnumBug': hasDontEnumBug,
      'isKeysFast': isKeysFast,
      'objectLoop': '',
      'noArgsEnum': noArgsEnum,
      'noCharByIndex': noCharByIndex,
      'shadowed': shadowed,
      'top': '',
      'useHas': true
    };

    // merge options into a template data object
    for (var object, index = 0; object = arguments[index]; index++) {
      for (var key in object) {
        data[key] = object[key];
      }
    }
    var args = data.args;
    data.firstArg = /^[^,]+/.exec(args)[0];

    // create the function factory
    var factory = Function(
        'createCallback, hasOwnProperty, isArguments, isString, objectTypes, ' +
        'nativeKeys, propertyIsEnumerable',
      'return function(' + args + ') {\n' + iteratorTemplate(data) + '\n}'
    );
    // return the compiled function
    return factory(
      createCallback, hasOwnProperty, isArguments, isString, objectTypes,
      nativeKeys, propertyIsEnumerable
    );
  }

  /**
   * Used by `template` to escape characters for inclusion in compiled
   * string literals.
   *
   * @private
   * @param {String} match The matched character to escape.
   * @returns {String} Returns the escaped character.
   */
  function escapeStringChar(match) {
    return '\\' + stringEscapes[match];
  }

  /**
   * Used by `escape` to convert characters to HTML entities.
   *
   * @private
   * @param {String} match The matched character to escape.
   * @returns {String} Returns the escaped character.
   */
  function escapeHtmlChar(match) {
    return htmlEscapes[match];
  }

  /**
   * A no-operation function.
   *
   * @private
   */
  function noop() {
    // no operation performed
  }

  /**
   * Used by `unescape` to convert HTML entities to characters.
   *
   * @private
   * @param {String} match The matched character to unescape.
   * @returns {String} Returns the unescaped character.
   */
  function unescapeHtmlChar(match) {
    return htmlUnescapes[match];
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if `value` is an `arguments` object.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is an `arguments` object, else `false`.
   * @example
   *
   * (function() { return _.isArguments(arguments); })(1, 2, 3);
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  function isArguments(value) {
    return toString.call(value) == argsClass;
  }
  // fallback for browsers that can't detect `arguments` objects by [[Class]]
  if (noArgsClass) {
    isArguments = function(value) {
      return value ? hasOwnProperty.call(value, 'callee') : false;
    };
  }

  /**
   * Iterates over `object`'s own and inherited enumerable properties, executing
   * the `callback` for each property. The `callback` is bound to `thisArg` and
   * invoked with three arguments; (value, key, object). Callbacks may exit iteration
   * early by explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * function Dog(name) {
   *   this.name = name;
   * }
   *
   * Dog.prototype.bark = function() {
   *   alert('Woof, woof!');
   * };
   *
   * _.forIn(new Dog('Dagny'), function(value, key) {
   *   alert(key);
   * });
   * // => alerts 'name' and 'bark' (order is not guaranteed)
   */
  var forIn = createIterator(forEachIteratorOptions, forOwnIteratorOptions, {
    'useHas': false
  });

  /**
   * Iterates over `object`'s own enumerable properties, executing the `callback`
   * for each property. The `callback` is bound to `thisArg` and invoked with three
   * arguments; (value, key, object). Callbacks may exit iteration early by explicitly
   * returning `false`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns `object`.
   * @example
   *
   * _.forOwn({ '0': 'zero', '1': 'one', 'length': 2 }, function(num, key) {
   *   alert(key);
   * });
   * // => alerts '0', '1', and 'length' (order is not guaranteed)
   */
  var forOwn = createIterator(forEachIteratorOptions, forOwnIteratorOptions);

  /**
   * A fallback implementation of `isPlainObject` that checks if a given `value`
   * is an object created by the `Object` constructor, assuming objects created
   * by the `Object` constructor have no inherited enumerable properties and that
   * there are no `Object.prototype` extensions.
   *
   * @private
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if `value` is a plain object, else `false`.
   */
  function shimIsPlainObject(value) {
    // avoid non-objects and false positives for `arguments` objects
    var result = false;
    if (!(value && typeof value == 'object') || isArguments(value)) {
      return result;
    }
    // IE < 9 presents DOM nodes as `Object` objects except they have `toString`
    // methods that are `typeof` "string" and still can coerce nodes to strings.
    // Also check that the constructor is `Object` (i.e. `Object instanceof Object`)
    var ctor = value.constructor;
    if ((!noNodeClass || !(typeof value.toString != 'function' && typeof (value + '') == 'string')) &&
        (!isFunction(ctor) || ctor instanceof ctor)) {
      // IE < 9 iterates inherited properties before own properties. If the first
      // iterated property is an object's own property then there are no inherited
      // enumerable properties.
      if (iteratesOwnLast) {
        forIn(value, function(value, key, object) {
          result = !hasOwnProperty.call(object, key);
          return false;
        });
        return result === false;
      }
      // In most environments an object's own properties are iterated before
      // its inherited properties. If the last iterated property is an object's
      // own property then there are no inherited enumerable properties.
      forIn(value, function(value, key) {
        result = key;
      });
      return result === false || hasOwnProperty.call(value, result);
    }
    return result;
  }

  /**
   * A fallback implementation of `Object.keys` that produces an array of the
   * given object's own enumerable property names.
   *
   * @private
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns a new array of property names.
   */
  function shimKeys(object) {
    var result = [];
    forOwn(object, function(value, key) {
      result.push(key);
    });
    return result;
  }

  /**
   * Used to convert characters to HTML entities:
   *
   * Though the `>` character is escaped for symmetry, characters like `>` and `/`
   * don't require escaping in HTML and have no special meaning unless they're part
   * of a tag or an unquoted attribute value.
   * http://mathiasbynens.be/notes/ambiguous-ampersands (under "semi-related fun fact")
   */
  var htmlEscapes = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;'
  };

  /** Used to convert HTML entities to characters */
  var htmlUnescapes = invert(htmlEscapes);

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a clone of `value`. If `deep` is `true`, all nested objects will
   * also be cloned otherwise they will be assigned by reference. Functions, DOM
   * nodes, `arguments` objects, and objects created by constructors other than
   * `Object` are **not** cloned.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to clone.
   * @param {Boolean} deep A flag to indicate a deep clone.
   * @param- {Object} [guard] Internally used to allow this method to work with
   *  others like `_.map` without using their callback `index` argument for `deep`.
   * @param- {Array} [stackA=[]] Internally used to track traversed source objects.
   * @param- {Array} [stackB=[]] Internally used to associate clones with their
   *  source counterparts.
   * @returns {Mixed} Returns the cloned `value`.
   * @example
   *
   * var stooges = [
   *   { 'name': 'moe', 'age': 40 },
   *   { 'name': 'larry', 'age': 50 },
   *   { 'name': 'curly', 'age': 60 }
   * ];
   *
   * _.clone({ 'name': 'moe' });
   * // => { 'name': 'moe' }
   *
   * var shallow = _.clone(stooges);
   * shallow[0] === stooges[0];
   * // => true
   *
   * var deep = _.clone(stooges, true);
   * shallow[0] === stooges[0];
   * // => false
   */
  function clone(value, deep, guard, stackA, stackB) {
    if (value == null) {
      return value;
    }
    if (guard) {
      deep = false;
    }
    // inspect [[Class]]
    var isObj = isObject(value);
    if (isObj) {
      // don't clone `arguments` objects, functions, or non-object Objects
      var className = toString.call(value);
      if (!cloneableClasses[className] || (noArgsClass && isArguments(value))) {
        return value;
      }
      var isArr = className == arrayClass;
      isObj = isArr || (className == objectClass ? isPlainObject(value) : isObj);
    }
    // shallow clone
    if (!isObj || !deep) {
      // don't clone functions
      return isObj
        ? (isArr ? slice.call(value) : extend({}, value))
        : value;
    }

    var ctor = value.constructor;
    switch (className) {
      case boolClass:
      case dateClass:
        return new ctor(+value);

      case numberClass:
      case stringClass:
        return new ctor(value);

      case regexpClass:
        return ctor(value.source, reFlags.exec(value));
    }
    // check for circular references and return corresponding clone
    stackA || (stackA = []);
    stackB || (stackB = []);

    var length = stackA.length;
    while (length--) {
      if (stackA[length] == value) {
        return stackB[length];
      }
    }
    // init cloned object
    var result = isArr ? ctor(value.length) : {};

    // add the source value to the stack of traversed objects
    // and associate it with its clone
    stackA.push(value);
    stackB.push(result);

    // recursively populate clone (susceptible to call stack limits)
    (isArr ? forEach : forOwn)(value, function(objValue, key) {
      result[key] = clone(objValue, deep, null, stackA, stackB);
    });

    return result;
  }

  /**
   * Assigns enumerable properties of the default object(s) to the `destination`
   * object for all `destination` properties that resolve to `null`/`undefined`.
   * Once a property is set, additional defaults of the same property will be
   * ignored.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The destination object.
   * @param {Object} [default1, default2, ...] The default objects.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * var iceCream = { 'flavor': 'chocolate' };
   * _.defaults(iceCream, { 'flavor': 'vanilla', 'sprinkles': 'rainbow' });
   * // => { 'flavor': 'chocolate', 'sprinkles': 'rainbow' }
   */
  var defaults = createIterator(extendIteratorOptions, {
    'objectLoop': 'if (result[index] == null) ' + extendIteratorOptions.objectLoop
  });

  /**
   * Assigns enumerable properties of the source object(s) to the `destination`
   * object. Subsequent sources will overwrite propery assignments of previous
   * sources.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The destination object.
   * @param {Object} [source1, source2, ...] The source objects.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * _.extend({ 'name': 'moe' }, { 'age': 40 });
   * // => { 'name': 'moe', 'age': 40 }
   */
  var extend = createIterator(extendIteratorOptions);

  /**
   * Creates a sorted array of all enumerable properties, own and inherited,
   * of `object` that have function values.
   *
   * @static
   * @memberOf _
   * @alias methods
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns a new array of property names that have function values.
   * @example
   *
   * _.functions(_);
   * // => ['all', 'any', 'bind', 'bindAll', 'clone', 'compact', 'compose', ...]
   */
  function functions(object) {
    var result = [];
    forIn(object, function(value, key) {
      if (isFunction(value)) {
        result.push(key);
      }
    });
    return result.sort();
  }

  /**
   * Checks if the specified object `property` exists and is a direct property,
   * instead of an inherited property.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to check.
   * @param {String} property The property to check for.
   * @returns {Boolean} Returns `true` if key is a direct property, else `false`.
   * @example
   *
   * _.has({ 'a': 1, 'b': 2, 'c': 3 }, 'b');
   * // => true
   */
  function has(object, property) {
    return object ? hasOwnProperty.call(object, property) : false;
  }

  /**
   * Creates an object composed of the inverted keys and values of the given `object`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to invert.
   * @returns {Object} Returns the created inverted object.
   * @example
   *
   *  _.invert({ 'first': 'Moe', 'second': 'Larry', 'third': 'Curly' });
   * // => { 'Moe': 'first', 'Larry': 'second', 'Curly': 'third' } (order is not guaranteed)
   */
  function invert(object) {
    var result = {};
    forOwn(object, function(value, key) {
      result[value] = key;
    });
    return result;
  }

  /**
   * Checks if `value` is an array.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is an array, else `false`.
   * @example
   *
   * (function() { return _.isArray(arguments); })();
   * // => false
   *
   * _.isArray([1, 2, 3]);
   * // => true
   */
  var isArray = nativeIsArray || function(value) {
    return toString.call(value) == arrayClass;
  };

  /**
   * Checks if `value` is a boolean (`true` or `false`) value.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a boolean value, else `false`.
   * @example
   *
   * _.isBoolean(null);
   * // => false
   */
  function isBoolean(value) {
    return value === true || value === false || toString.call(value) == boolClass;
  }

  /**
   * Checks if `value` is a date.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a date, else `false`.
   * @example
   *
   * _.isDate(new Date);
   * // => true
   */
  function isDate(value) {
    return toString.call(value) == dateClass;
  }

  /**
   * Checks if `value` is a DOM element.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a DOM element, else `false`.
   * @example
   *
   * _.isElement(document.body);
   * // => true
   */
  function isElement(value) {
    return value ? value.nodeType === 1 : false;
  }

  /**
   * Checks if `value` is empty. Arrays, strings, or `arguments` objects with a
   * length of `0` and objects with no own enumerable properties are considered
   * "empty".
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Array|Object|String} value The value to inspect.
   * @returns {Boolean} Returns `true` if the `value` is empty, else `false`.
   * @example
   *
   * _.isEmpty([1, 2, 3]);
   * // => false
   *
   * _.isEmpty({});
   * // => true
   *
   * _.isEmpty('');
   * // => true
   */
  function isEmpty(value) {
    var result = true;
    if (!value) {
      return result;
    }
    var className = toString.call(value),
        length = value.length;

    if ((className == arrayClass || className == stringClass ||
        className == argsClass || (noArgsClass && isArguments(value))) ||
        (className == objectClass && typeof length == 'number' && isFunction(value.splice))) {
      return !length;
    }
    forOwn(value, function() {
      return (result = false);
    });
    return result;
  }

  /**
   * Performs a deep comparison between two values to determine if they are
   * equivalent to each other.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} a The value to compare.
   * @param {Mixed} b The other value to compare.
   * @param- {Object} [stackA=[]] Internally used track traversed `a` objects.
   * @param- {Object} [stackB=[]] Internally used track traversed `b` objects.
   * @returns {Boolean} Returns `true` if the values are equvalent, else `false`.
   * @example
   *
   * var moe = { 'name': 'moe', 'luckyNumbers': [13, 27, 34] };
   * var clone = { 'name': 'moe', 'luckyNumbers': [13, 27, 34] };
   *
   * moe == clone;
   * // => false
   *
   * _.isEqual(moe, clone);
   * // => true
   */
  function isEqual(a, b, stackA, stackB) {
    // exit early for identical values
    if (a === b) {
      // treat `+0` vs. `-0` as not equal
      return a !== 0 || (1 / a == 1 / b);
    }
    // a strict comparison is necessary because `null == undefined`
    if (a == null || b == null) {
      return a === b;
    }
    // compare [[Class]] names
    var className = toString.call(a);
    if (className != toString.call(b)) {
      return false;
    }
    switch (className) {
      case boolClass:
      case dateClass:
        // coerce dates and booleans to numbers, dates to milliseconds and booleans
        // to `1` or `0`, treating invalid dates coerced to `NaN` as not equal
        return +a == +b;

      case numberClass:
        // treat `NaN` vs. `NaN` as equal
        return a != +a
          ? b != +b
          // but treat `+0` vs. `-0` as not equal
          : (a == 0 ? (1 / a == 1 / b) : a == +b);

      case regexpClass:
      case stringClass:
        // coerce regexes to strings (http://es5.github.com/#x15.10.6.4)
        // treat string primitives and their corresponding object instances as equal
        return a == b + '';
    }
    // exit early, in older browsers, if `a` is array-like but not `b`
    var isArr = className == arrayClass || className == argsClass;
    if (noArgsClass && !isArr && (isArr = isArguments(a)) && !isArguments(b)) {
      return false;
    }
    if (!isArr) {
      // unwrap any `lodash` wrapped values
      if (a.__wrapped__ || b.__wrapped__) {
        return isEqual(a.__wrapped__ || a, b.__wrapped__ || b);
      }
      // exit for functions and DOM nodes
      if (className != objectClass || (noNodeClass && (
          (typeof a.toString != 'function' && typeof (a + '') == 'string') ||
          (typeof b.toString != 'function' && typeof (b + '') == 'string')))) {
        return false;
      }
      var ctorA = a.constructor,
          ctorB = b.constructor;

      // non `Object` object instances with different constructors are not equal
      if (ctorA != ctorB && !(
            isFunction(ctorA) && ctorA instanceof ctorA &&
            isFunction(ctorB) && ctorB instanceof ctorB
          )) {
        return false;
      }
    }
    // assume cyclic structures are equal
    // the algorithm for detecting cyclic structures is adapted from ES 5.1
    // section 15.12.3, abstract operation `JO` (http://es5.github.com/#x15.12.3)
    stackA || (stackA = []);
    stackB || (stackB = []);

    var length = stackA.length;
    while (length--) {
      if (stackA[length] == a) {
        return stackB[length] == b;
      }
    }

    var index = -1,
        result = true,
        size = 0;

    // add `a` and `b` to the stack of traversed objects
    stackA.push(a);
    stackB.push(b);

    // recursively compare objects and arrays (susceptible to call stack limits)
    if (isArr) {
      // compare lengths to determine if a deep comparison is necessary
      size = a.length;
      result = size == b.length;

      if (result) {
        // deep compare the contents, ignoring non-numeric properties
        while (size--) {
          if (!(result = isEqual(a[size], b[size], stackA, stackB))) {
            break;
          }
        }
      }
      return result;
    }
    // deep compare objects
    for (var key in a) {
      if (hasOwnProperty.call(a, key)) {
        // count the number of properties.
        size++;
        // deep compare each property value.
        if (!(hasOwnProperty.call(b, key) && isEqual(a[key], b[key], stackA, stackB))) {
          return false;
        }
      }
    }
    // ensure both objects have the same number of properties
    for (key in b) {
      // The JS engine in Adobe products, like InDesign, has a bug that causes
      // `!size--` to throw an error so it must be wrapped in parentheses.
      // https://github.com/documentcloud/underscore/issues/355
      if (hasOwnProperty.call(b, key) && !(size--)) {
        // `size` will be `-1` if `b` has more properties than `a`
        return false;
      }
    }
    // handle JScript [[DontEnum]] bug
    if (hasDontEnumBug) {
      while (++index < 7) {
        key = shadowed[index];
        if (hasOwnProperty.call(a, key) &&
            !(hasOwnProperty.call(b, key) && isEqual(a[key], b[key], stackA, stackB))) {
          return false;
        }
      }
    }
    return true;
  }

  /**
   * Checks if `value` is, or can be coerced to, a finite number.
   *
   * Note: This is not the same as native `isFinite`, which will return true for
   * booleans and empty strings. See http://es5.github.com/#x15.1.2.5.
   *
   * @deprecated
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a finite number, else `false`.
   * @example
   *
   * _.isFinite(-101);
   * // => true
   *
   * _.isFinite('10');
   * // => true
   *
   * _.isFinite(true);
   * // => false
   *
   * _.isFinite('');
   * // => false
   *
   * _.isFinite(Infinity);
   * // => false
   */
  function isFinite(value) {
    return nativeIsFinite(value) && !nativeIsNaN(parseFloat(value));
  }

  /**
   * Checks if `value` is a function.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   */
  function isFunction(value) {
    return typeof value == 'function';
  }
  // fallback for older versions of Chrome and Safari
  if (isFunction(/x/)) {
    isFunction = function(value) {
      return toString.call(value) == funcClass;
    };
  }

  /**
   * Checks if `value` is the language type of Object.
   * (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(1);
   * // => false
   */
  function isObject(value) {
    // check if the value is the ECMAScript language type of Object
    // http://es5.github.com/#x8
    // and avoid a V8 bug
    // http://code.google.com/p/v8/issues/detail?id=2291
    return value ? objectTypes[typeof value] : false;
  }

  /**
   * Checks if `value` is `NaN`.
   *
   * Note: This is not the same as native `isNaN`, which will return true for
   * `undefined` and other values. See http://es5.github.com/#x15.1.2.4.
   *
   * @deprecated
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is `NaN`, else `false`.
   * @example
   *
   * _.isNaN(NaN);
   * // => true
   *
   * _.isNaN(new Number(NaN));
   * // => true
   *
   * isNaN(undefined);
   * // => true
   *
   * _.isNaN(undefined);
   * // => false
   */
  function isNaN(value) {
    // `NaN` as a primitive is the only value that is not equal to itself
    // (perform the [[Class]] check first to avoid errors with some host objects in IE)
    return toString.call(value) == numberClass && value != +value
  }

  /**
   * Checks if `value` is `null`.
   *
   * @deprecated
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is `null`, else `false`.
   * @example
   *
   * _.isNull(null);
   * // => true
   *
   * _.isNull(undefined);
   * // => false
   */
  function isNull(value) {
    return value === null;
  }

  /**
   * Checks if `value` is a number.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a number, else `false`.
   * @example
   *
   * _.isNumber(8.4 * 5);
   * // => true
   */
  function isNumber(value) {
    return toString.call(value) == numberClass;
  }

  /**
   * Checks if a given `value` is an object created by the `Object` constructor.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if `value` is a plain object, else `false`.
   * @example
   *
   * function Stooge(name, age) {
   *   this.name = name;
   *   this.age = age;
   * }
   *
   * _.isPlainObject(new Stooge('moe', 40));
   * // => false
   *
   * _.isPlainObject([1, 2, 3]);
   * // => false
   *
   * _.isPlainObject({ 'name': 'moe', 'age': 40 });
   * // => true
   */
  var isPlainObject = !getPrototypeOf ? shimIsPlainObject : function(value) {
    if (!(value && typeof value == 'object')) {
      return false;
    }
    var valueOf = value.valueOf,
        objProto = typeof valueOf == 'function' && (objProto = getPrototypeOf(valueOf)) && getPrototypeOf(objProto);

    return objProto
      ? value == objProto || (getPrototypeOf(value) == objProto && !isArguments(value))
      : shimIsPlainObject(value);
  };

  /**
   * Checks if `value` is a regular expression.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a regular expression, else `false`.
   * @example
   *
   * _.isRegExp(/moe/);
   * // => true
   */
  function isRegExp(value) {
    return toString.call(value) == regexpClass;
  }

  /**
   * Checks if `value` is a string.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is a string, else `false`.
   * @example
   *
   * _.isString('moe');
   * // => true
   */
  function isString(value) {
    return toString.call(value) == stringClass;
  }

  /**
   * Checks if `value` is `undefined`.
   *
   * @deprecated
   * @static
   * @memberOf _
   * @category Objects
   * @param {Mixed} value The value to check.
   * @returns {Boolean} Returns `true` if the `value` is `undefined`, else `false`.
   * @example
   *
   * _.isUndefined(void 0);
   * // => true
   */
  function isUndefined(value) {
    return value === undefined;
  }

  /**
   * Creates an array composed of the own enumerable property names of `object`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns a new array of property names.
   * @example
   *
   * _.keys({ 'one': 1, 'two': 2, 'three': 3 });
   * // => ['one', 'two', 'three'] (order is not guaranteed)
   */
  var keys = !nativeKeys ? shimKeys : function(object) {
    // avoid iterating over the `prototype` property
    return typeof object == 'function' && propertyIsEnumerable.call(object, 'prototype')
      ? shimKeys(object)
      : (isObject(object) ? nativeKeys(object) : []);
  };

  /**
   * Merges enumerable properties of the source object(s) into the `destination`
   * object. Subsequent sources will overwrite propery assignments of previous
   * sources.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The destination object.
   * @param {Object} [source1, source2, ...] The source objects.
   * @param- {Object} [indicator] Internally used to indicate that the `stack`
   *  argument is an array of traversed objects instead of another source object.
   * @param- {Array} [stackA=[]] Internally used to track traversed source objects.
   * @param- {Array} [stackB=[]] Internally used to associate values with their
   *  source counterparts.
   * @returns {Object} Returns the destination object.
   * @example
   *
   * var stooges = [
   *   { 'name': 'moe' },
   *   { 'name': 'larry' }
   * ];
   *
   * var ages = [
   *   { 'age': 40 },
   *   { 'age': 50 }
   * ];
   *
   * _.merge(stooges, ages);
   * // => [{ 'name': 'moe', 'age': 40 }, { 'name': 'larry', 'age': 50 }]
   */
  function merge(object, source, indicator) {
    var args = arguments,
        index = 0,
        length = 2,
        stackA = args[3],
        stackB = args[4];

    if (indicator !== objectRef) {
      stackA = [];
      stackB = [];
      length = args.length;
    }
    while (++index < length) {
      forOwn(args[index], function(source, key) {
        var found, isArr, value;
        if (source && ((isArr = isArray(source)) || isPlainObject(source))) {
          // avoid merging previously merged cyclic sources
          var stackLength = stackA.length;
          while (stackLength--) {
            found = stackA[stackLength] == source;
            if (found) {
              break;
            }
          }
          if (found) {
            object[key] = stackB[stackLength];
          }
          else {
            // add `source` and associated `value` to the stack of traversed objects
            stackA.push(source);
            stackB.push(value = (value = object[key], isArr)
              ? (isArray(value) ? value : [])
              : (isPlainObject(value) ? value : {})
            );
            // recursively merge objects and arrays (susceptible to call stack limits)
            object[key] = merge(value, source, objectRef, stackA, stackB);
          }
        } else if (source != null) {
          object[key] = source;
        }
      });
    }
    return object;
  }

  /**
   * Creates a shallow clone of `object` excluding the specified properties.
   * Property names may be specified as individual arguments or as arrays of
   * property names. If `callback` is passed, it will be executed for each property
   * in the `object`, omitting the properties `callback` returns truthy for. The
   * `callback` is bound to `thisArg` and invoked with three arguments; (value, key, object).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The source object.
   * @param {Function|String} callback|[prop1, prop2, ...] The properties to omit
   *  or the function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns an object without the omitted properties.
   * @example
   *
   * _.omit({ 'name': 'moe', 'age': 40, 'userid': 'moe1' }, 'userid');
   * // => { 'name': 'moe', 'age': 40 }
   *
   * _.omit({ 'name': 'moe', '_hint': 'knucklehead', '_seed': '96c4eb' }, function(value, key) {
   *   return key.charAt(0) == '_';
   * });
   * // => { 'name': 'moe' }
   */
  function omit(object, callback, thisArg) {
    var isFunc = typeof callback == 'function',
        result = {};

    if (isFunc) {
      callback = createCallback(callback, thisArg);
    } else {
      var props = concat.apply(arrayRef, arguments);
    }
    forIn(object, function(value, key, object) {
      if (isFunc
            ? !callback(value, key, object)
            : indexOf(props, key, 1) < 0
          ) {
        result[key] = value;
      }
    });
    return result;
  }

  /**
   * Creates a two dimensional array of the given object's key-value pairs,
   * i.e. `[[key1, value1], [key2, value2]]`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns new array of key-value pairs.
   * @example
   *
   * _.pairs({ 'moe': 30, 'larry': 40, 'curly': 50 });
   * // => [['moe', 30], ['larry', 40], ['curly', 50]] (order is not guaranteed)
   */
  function pairs(object) {
    var result = [];
    forOwn(object, function(value, key) {
      result.push([key, value]);
    });
    return result;
  }

  /**
   * Creates a shallow clone of `object` composed of the specified properties.
   * Property names may be specified as individual arguments or as arrays of
   * property names. If `callback` is passed, it will be executed for each property
   * in the `object`, picking the properties `callback` returns truthy for. The
   * `callback` is bound to `thisArg` and invoked with three arguments; (value, key, object).
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The source object.
   * @param {Function|String} callback|[prop1, prop2, ...] The properties to pick
   *  or the function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns an object composed of the picked properties.
   * @example
   *
   * _.pick({ 'name': 'moe', 'age': 40, 'userid': 'moe1' }, 'name', 'age');
   * // => { 'name': 'moe', 'age': 40 }
   *
   * _.pick({ 'name': 'moe', '_hint': 'knucklehead', '_seed': '96c4eb' }, function(value, key) {
   *   return key.charAt(0) != '_';
   * });
   * // => { 'name': 'moe' }
   */
  function pick(object, callback, thisArg) {
    var result = {};
    if (typeof callback != 'function') {
      var index = 0,
          props = concat.apply(arrayRef, arguments),
          length = props.length;

      while (++index < length) {
        var key = props[index];
        if (key in object) {
          result[key] = object[key];
        }
      }
    } else {
      callback = createCallback(callback, thisArg);
      forIn(object, function(value, key, object) {
        if (callback(value, key, object)) {
          result[key] = value;
        }
      });
    }
    return result;
  }

  /**
   * Creates an array composed of the own enumerable property values of `object`.
   *
   * @static
   * @memberOf _
   * @category Objects
   * @param {Object} object The object to inspect.
   * @returns {Array} Returns a new array of property values.
   * @example
   *
   * _.values({ 'one': 1, 'two': 2, 'three': 3 });
   * // => [1, 2, 3]
   */
  function values(object) {
    var result = [];
    forOwn(object, function(value) {
      result.push(value);
    });
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Checks if a given `target` element is present in a `collection` using strict
   * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
   * as the offset from the end of the collection.
   *
   * @static
   * @memberOf _
   * @alias include
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Mixed} target The value to check for.
   * @param {Number} [fromIndex=0] The index to search from.
   * @returns {Boolean} Returns `true` if the `target` element is found, else `false`.
   * @example
   *
   * _.contains([1, 2, 3], 1);
   * // => true
   *
   * _.contains([1, 2, 3], 1, 2);
   * // => false
   *
   * _.contains({ 'name': 'moe', 'age': 40 }, 'moe');
   * // => true
   *
   * _.contains('curly', 'ur');
   * // => true
   */
  function contains(collection, target, fromIndex) {
    var index = -1,
        length = collection ? collection.length : 0;

    fromIndex = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex) || 0;
    if (typeof length == 'number') {
      return (isString(collection)
        ? collection.indexOf(target, fromIndex)
        : indexOf(collection, target, fromIndex)
      ) > -1;
    }
    return some(collection, function(value) {
      return ++index >= fromIndex && value === target;
    });
  }

  /**
   * Creates an object composed of keys returned from running each element of
   * `collection` through a `callback`. The corresponding value of each key is
   * the number of times the key was returned by `callback`. The `callback` is
   * bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
   * The `callback` argument may also be the name of a property to count by (e.g. 'length').
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function|String} callback|property The function called per iteration
   *  or property name to count by.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * _.countBy([4.3, 6.1, 6.4], function(num) { return Math.floor(num); });
   * // => { '4': 1, '6': 2 }
   *
   * _.countBy([4.3, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
   * // => { '4': 1, '6': 2 }
   *
   * _.countBy(['one', 'two', 'three'], 'length');
   * // => { '3': 2, '5': 1 }
   */
  function countBy(collection, callback, thisArg) {
    var result = {};
    callback = createCallback(callback, thisArg);
    forEach(collection, function(value, key, collection) {
      key = callback(value, key, collection);
      (hasOwnProperty.call(result, key) ? result[key]++ : result[key] = 1);
    });
    return result;
  }

  /**
   * Checks if the `callback` returns a truthy value for **all** elements of a
   * `collection`. The `callback` is bound to `thisArg` and invoked with three
   * arguments; (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias all
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Boolean} Returns `true` if all elements pass the callback check,
   *  else `false`.
   * @example
   *
   * _.every([true, 1, null, 'yes'], Boolean);
   * // => false
   */
  function every(collection, callback, thisArg) {
    var result = true;
    callback = createCallback(callback, thisArg);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        if (!(result = !!callback(collection[index], index, collection))) {
          break;
        }
      }
    } else {
      forEach(collection, function(value, index, collection) {
        return (result = !!callback(value, index, collection));
      });
    }
    return result;
  }

  /**
   * Examines each element in a `collection`, returning an array of all elements
   * the `callback` returns truthy for. The `callback` is bound to `thisArg` and
   * invoked with three arguments; (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias select
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of elements that passed the callback check.
   * @example
   *
   * var evens = _.filter([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // => [2, 4, 6]
   */
  function filter(collection, callback, thisArg) {
    var result = [];
    callback = createCallback(callback, thisArg);
    forEach(collection, function(value, index, collection) {
      if (callback(value, index, collection)) {
        result.push(value);
      }
    });
    return result;
  }

  /**
   * Examines each element in a `collection`, returning the first one the `callback`
   * returns truthy for. The function returns as soon as it finds an acceptable
   * element, and does not iterate over the entire `collection`. The `callback` is
   * bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias detect
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} callback The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Mixed} Returns the element that passed the callback check,
   *  else `undefined`.
   * @example
   *
   * var even = _.find([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // => 2
   */
  function find(collection, callback, thisArg) {
    var result;
    callback = createCallback(callback, thisArg);
    forEach(collection, function(value, index, collection) {
      if (callback(value, index, collection)) {
        result = value;
        return false;
      }
    });
    return result;
  }

  /**
   * Iterates over a `collection`, executing the `callback` for each element in
   * the `collection`. The `callback` is bound to `thisArg` and invoked with three
   * arguments; (value, index|key, collection). Callbacks may exit iteration early
   * by explicitly returning `false`.
   *
   * @static
   * @memberOf _
   * @alias each
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} callback The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array|Object|String} Returns `collection`.
   * @example
   *
   * _([1, 2, 3]).forEach(alert).join(',');
   * // => alerts each number and returns '1,2,3'
   *
   * _.forEach({ 'one': 1, 'two': 2, 'three': 3 }, alert);
   * // => alerts each number (order is not guaranteed)
   */
  var forEach = createIterator(forEachIteratorOptions);

  /**
   * Creates an object composed of keys returned from running each element of
   * `collection` through a `callback`. The corresponding value of each key is an
   * array of elements passed to `callback` that returned the key. The `callback`
   * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
   * The `callback` argument may also be the name of a property to group by (e.g. 'length').
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function|String} callback|property The function called per iteration
   *  or property name to group by.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Object} Returns the composed aggregate object.
   * @example
   *
   * _.groupBy([4.2, 6.1, 6.4], function(num) { return Math.floor(num); });
   * // => { '4': [4.2], '6': [6.1, 6.4] }
   *
   * _.groupBy([4.2, 6.1, 6.4], function(num) { return this.floor(num); }, Math);
   * // => { '4': [4.2], '6': [6.1, 6.4] }
   *
   * _.groupBy(['one', 'two', 'three'], 'length');
   * // => { '3': ['one', 'two'], '5': ['three'] }
   */
  function groupBy(collection, callback, thisArg) {
    var result = {};
    callback = createCallback(callback, thisArg);
    forEach(collection, function(value, key, collection) {
      key = callback(value, key, collection);
      (hasOwnProperty.call(result, key) ? result[key] : result[key] = []).push(value);
    });
    return result;
  }

  /**
   * Invokes the method named by `methodName` on each element in the `collection`,
   * returning an array of the results of each invoked method. Additional arguments
   * will be passed to each invoked method. If `methodName` is a function it will
   * be invoked for, and `this` bound to, each element in the `collection`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function|String} methodName The name of the method to invoke or
   *  the function invoked per iteration.
   * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the method with.
   * @returns {Array} Returns a new array of the results of each invoked method.
   * @example
   *
   * _.invoke([[5, 1, 7], [3, 2, 1]], 'sort');
   * // => [[1, 5, 7], [1, 2, 3]]
   *
   * _.invoke([123, 456], String.prototype.split, '');
   * // => [['1', '2', '3'], ['4', '5', '6']]
   */
  function invoke(collection, methodName) {
    var args = slice.call(arguments, 2),
        isFunc = typeof methodName == 'function',
        result = [];

    forEach(collection, function(value) {
      result.push((isFunc ? methodName : value[methodName]).apply(value, args));
    });
    return result;
  }

  /**
   * Creates an array of values by running each element in the `collection`
   * through a `callback`. The `callback` is bound to `thisArg` and invoked with
   * three arguments; (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias collect
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of the results of each `callback` execution.
   * @example
   *
   * _.map([1, 2, 3], function(num) { return num * 3; });
   * // => [3, 6, 9]
   *
   * _.map({ 'one': 1, 'two': 2, 'three': 3 }, function(num) { return num * 3; });
   * // => [3, 6, 9] (order is not guaranteed)
   */
  function map(collection, callback, thisArg) {
    var index = -1,
        length = collection ? collection.length : 0,
        result = Array(typeof length == 'number' ? length : 0);

    callback = createCallback(callback, thisArg);
    if (isArray(collection)) {
      while (++index < length) {
        result[index] = callback(collection[index], index, collection);
      }
    } else {
      forEach(collection, function(value, key, collection) {
        result[++index] = callback(value, key, collection);
      });
    }
    return result;
  }

  /**
   * Retrieves the maximum value of an `array`. If `callback` is passed,
   * it will be executed for each value in the `array` to generate the
   * criterion by which the value is ranked. The `callback` is bound to
   * `thisArg` and invoked with three arguments; (value, index, collection).
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Mixed} Returns the maximum value.
   * @example
   *
   * var stooges = [
   *   { 'name': 'moe', 'age': 40 },
   *   { 'name': 'larry', 'age': 50 },
   *   { 'name': 'curly', 'age': 60 }
   * ];
   *
   * _.max(stooges, function(stooge) { return stooge.age; });
   * // => { 'name': 'curly', 'age': 60 };
   */
  function max(collection, callback, thisArg) {
    var computed = -Infinity,
        index = -1,
        length = collection ? collection.length : 0,
        result = computed;

    if (callback || !isArray(collection)) {
      callback = !callback && isString(collection)
        ? charAtCallback
        : createCallback(callback, thisArg);

      forEach(collection, function(value, index, collection) {
        var current = callback(value, index, collection);
        if (current > computed) {
          computed = current;
          result = value;
        }
      });
    } else {
      while (++index < length) {
        if (collection[index] > result) {
          result = collection[index];
        }
      }
    }
    return result;
  }

  /**
   * Retrieves the minimum value of an `array`. If `callback` is passed,
   * it will be executed for each value in the `array` to generate the
   * criterion by which the value is ranked. The `callback` is bound to `thisArg`
   * and invoked with three arguments; (value, index, collection).
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Mixed} Returns the minimum value.
   * @example
   *
   * _.min([10, 5, 100, 2, 1000]);
   * // => 2
   */
  function min(collection, callback, thisArg) {
    var computed = Infinity,
        index = -1,
        length = collection ? collection.length : 0,
        result = computed;

    if (callback || !isArray(collection)) {
      callback = !callback && isString(collection)
        ? charAtCallback
        : createCallback(callback, thisArg);

      forEach(collection, function(value, index, collection) {
        var current = callback(value, index, collection);
        if (current < computed) {
          computed = current;
          result = value;
        }
      });
    } else {
      while (++index < length) {
        if (collection[index] < result) {
          result = collection[index];
        }
      }
    }
    return result;
  }

  /**
   * Retrieves the value of a specified property from all elements in
   * the `collection`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {String} property The property to pluck.
   * @returns {Array} Returns a new array of property values.
   * @example
   *
   * var stooges = [
   *   { 'name': 'moe', 'age': 40 },
   *   { 'name': 'larry', 'age': 50 },
   *   { 'name': 'curly', 'age': 60 }
   * ];
   *
   * _.pluck(stooges, 'name');
   * // => ['moe', 'larry', 'curly']
   */
  function pluck(collection, property) {
    var result = [];
    forEach(collection, function(value) {
      result.push(value[property]);
    });
    return result;
  }

  /**
   * Boils down a `collection` to a single value. The initial state of the
   * reduction is `accumulator` and each successive step of it should be returned
   * by the `callback`. The `callback` is bound to `thisArg` and invoked with 4
   * arguments; for arrays they are (accumulator, value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias foldl, inject
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} callback The function called per iteration.
   * @param {Mixed} [accumulator] Initial value of the accumulator.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Mixed} Returns the accumulated value.
   * @example
   *
   * var sum = _.reduce([1, 2, 3], function(memo, num) { return memo + num; });
   * // => 6
   */
  function reduce(collection, callback, accumulator, thisArg) {
    var noaccum = arguments.length < 3;
    callback = createCallback(callback, thisArg);
    forEach(collection, function(value, index, collection) {
      accumulator = noaccum
        ? (noaccum = false, value)
        : callback(accumulator, value, index, collection)
    });
    return accumulator;
  }

  /**
   * The right-associative version of `_.reduce`.
   *
   * @static
   * @memberOf _
   * @alias foldr
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} callback The function called per iteration.
   * @param {Mixed} [accumulator] Initial value of the accumulator.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Mixed} Returns the accumulated value.
   * @example
   *
   * var list = [[0, 1], [2, 3], [4, 5]];
   * var flat = _.reduceRight(list, function(a, b) { return a.concat(b); }, []);
   * // => [4, 5, 2, 3, 0, 1]
   */
  function reduceRight(collection, callback, accumulator, thisArg) {
    var iteratee = collection,
        length = collection ? collection.length : 0,
        noaccum = arguments.length < 3;

    if (typeof length != 'number') {
      var props = keys(collection);
      length = props.length;
    } else if (noCharByIndex && isString(collection)) {
      iteratee = collection.split('');
    }
    forEach(collection, function(value, index, collection) {
      index = props ? props[--length] : --length;
      accumulator = noaccum
        ? (noaccum = false, iteratee[index])
        : callback.call(thisArg, accumulator, iteratee[index], index, collection);
    });
    return accumulator;
  }

  /**
   * The opposite of `_.filter`, this method returns the values of a
   * `collection` that `callback` does **not** return truthy for.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of elements that did **not** pass the
   *  callback check.
   * @example
   *
   * var odds = _.reject([1, 2, 3, 4, 5, 6], function(num) { return num % 2 == 0; });
   * // => [1, 3, 5]
   */
  function reject(collection, callback, thisArg) {
    callback = createCallback(callback, thisArg);
    return filter(collection, function(value, index, collection) {
      return !callback(value, index, collection);
    });
  }

  /**
   * Creates an array of shuffled `array` values, using a version of the
   * Fisher-Yates shuffle. See http://en.wikipedia.org/wiki/Fisher-Yates_shuffle.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to shuffle.
   * @returns {Array} Returns a new shuffled collection.
   * @example
   *
   * _.shuffle([1, 2, 3, 4, 5, 6]);
   * // => [4, 1, 6, 3, 5, 2]
   */
  function shuffle(collection) {
    var index = -1,
        result = Array(collection ? collection.length : 0);

    forEach(collection, function(value) {
      var rand = floor(nativeRandom() * (++index + 1));
      result[index] = result[rand];
      result[rand] = value;
    });
    return result;
  }

  /**
   * Gets the size of the `collection` by returning `collection.length` for arrays
   * and array-like objects or the number of own enumerable properties for objects.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to inspect.
   * @returns {Number} Returns `collection.length` or number of own enumerable properties.
   * @example
   *
   * _.size([1, 2]);
   * // => 2
   *
   * _.size({ 'one': 1, 'two': 2, 'three': 3 });
   * // => 3
   *
   * _.size('curly');
   * // => 5
   */
  function size(collection) {
    var length = collection ? collection.length : 0;
    return typeof length == 'number' ? length : keys(collection).length;
  }

  /**
   * Checks if the `callback` returns a truthy value for **any** element of a
   * `collection`. The function returns as soon as it finds passing value, and
   * does not iterate over the entire `collection`. The `callback` is bound to
   * `thisArg` and invoked with three arguments; (value, index|key, collection).
   *
   * @static
   * @memberOf _
   * @alias any
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Boolean} Returns `true` if any element passes the callback check,
   *  else `false`.
   * @example
   *
   * _.some([null, 0, 'yes', false]);
   * // => true
   */
  function some(collection, callback, thisArg) {
    var result;
    callback = createCallback(callback, thisArg);

    if (isArray(collection)) {
      var index = -1,
          length = collection.length;

      while (++index < length) {
        if (result = callback(collection[index], index, collection)) {
          break;
        }
      }
    } else {
      forEach(collection, function(value, index, collection) {
        return !(result = callback(value, index, collection));
      });
    }
    return !!result;
  }

  /**
   * Creates an array, stable sorted in ascending order by the results of
   * running each element of `collection` through a `callback`. The `callback`
   * is bound to `thisArg` and invoked with three arguments; (value, index|key, collection).
   * The `callback` argument may also be the name of a property to sort by (e.g. 'length').
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Function|String} callback|property The function called per iteration
   *  or property name to sort by.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of sorted elements.
   * @example
   *
   * _.sortBy([1, 2, 3], function(num) { return Math.sin(num); });
   * // => [3, 1, 2]
   *
   * _.sortBy([1, 2, 3], function(num) { return this.sin(num); }, Math);
   * // => [3, 1, 2]
   *
   * _.sortBy(['larry', 'brendan', 'moe'], 'length');
   * // => ['moe', 'larry', 'brendan']
   */
  function sortBy(collection, callback, thisArg) {
    var result = [];
    callback = createCallback(callback, thisArg);
    forEach(collection, function(value, index, collection) {
      result.push({
        'criteria': callback(value, index, collection),
        'index': index,
        'value': value
      });
    });

    var length = result.length;
    result.sort(compareAscending);
    while (length--) {
      result[length] = result[length].value;
    }
    return result;
  }

  /**
   * Converts the `collection`, to an array.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to convert.
   * @returns {Array} Returns the new converted array.
   * @example
   *
   * (function() { return _.toArray(arguments).slice(1); })(1, 2, 3, 4);
   * // => [2, 3, 4]
   */
  function toArray(collection) {
    if (collection && typeof collection.length == 'number') {
      return (noArraySliceOnStrings ? isString(collection) : typeof collection == 'string')
        ? collection.split('')
        : slice.call(collection);
    }
    return values(collection);
  }

  /**
   * Examines each element in a `collection`, returning an array of all elements
   * that contain the given `properties`.
   *
   * @static
   * @memberOf _
   * @category Collections
   * @param {Array|Object|String} collection The collection to iterate over.
   * @param {Object} properties The object of property values to filter by.
   * @returns {Array} Returns a new array of elements that contain the given `properties`.
   * @example
   *
   * var stooges = [
   *   { 'name': 'moe', 'age': 40 },
   *   { 'name': 'larry', 'age': 50 },
   *   { 'name': 'curly', 'age': 60 }
   * ];
   *
   * _.where(stooges, { 'age': 40 });
   * // => [{ 'name': 'moe', 'age': 40 }]
   */
  function where(collection, properties) {
    var props = [];
    forIn(properties, function(value, prop) {
      props.push(prop);
    });
    return filter(collection, function(object) {
      var length = props.length;
      while (length--) {
        var result = object[props[length]] === properties[props[length]];
        if (!result) {
          break;
        }
      }
      return !!result;
    });
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates an array with all falsey values of `array` removed. The values
   * `false`, `null`, `0`, `""`, `undefined` and `NaN` are all falsey.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to compact.
   * @returns {Array} Returns a new filtered array.
   * @example
   *
   * _.compact([0, 1, false, 2, '', 3]);
   * // => [1, 2, 3]
   */
  function compact(array) {
    var index = -1,
        length = array ? array.length : 0,
        result = [];

    while (++index < length) {
      var value = array[index];
      if (value) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Creates an array of `array` elements not present in the other arrays
   * using strict equality for comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to process.
   * @param {Array} [array1, array2, ...] Arrays to check.
   * @returns {Array} Returns a new array of `array` elements not present in the
   *  other arrays.
   * @example
   *
   * _.difference([1, 2, 3, 4, 5], [5, 2, 10]);
   * // => [1, 3, 4]
   */
  function difference(array) {
    var index = -1,
        length = array ? array.length : 0,
        flattened = concat.apply(arrayRef, arguments),
        contains = cachedContains(flattened, length),
        result = [];

    while (++index < length) {
      var value = array[index];
      if (!contains(value)) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Gets the first element of the `array`. Pass `n` to return the first `n`
   * elements of the `array`.
   *
   * @static
   * @memberOf _
   * @alias head, take
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Number} [n] The number of elements to return.
   * @param- {Object} [guard] Internally used to allow this method to work with
   *  others like `_.map` without using their callback `index` argument for `n`.
   * @returns {Mixed} Returns the first element or an array of the first `n`
   *  elements of `array`.
   * @example
   *
   * _.first([5, 4, 3, 2, 1]);
   * // => 5
   */
  function first(array, n, guard) {
    if (array) {
      return (n == null || guard) ? array[0] : slice.call(array, 0, n);
    }
  }

  /**
   * Flattens a nested array (the nesting can be to any depth). If `shallow` is
   * truthy, `array` will only be flattened a single level.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to compact.
   * @param {Boolean} shallow A flag to indicate only flattening a single level.
   * @returns {Array} Returns a new flattened array.
   * @example
   *
   * _.flatten([1, [2], [3, [[4]]]]);
   * // => [1, 2, 3, 4];
   *
   * _.flatten([1, [2], [3, [[4]]]], true);
   * // => [1, 2, 3, [[4]]];
   */
  function flatten(array, shallow) {
    var index = -1,
        length = array ? array.length : 0,
        result = [];

    while (++index < length) {
      var value = array[index];

      // recursively flatten arrays (susceptible to call stack limits)
      if (isArray(value)) {
        push.apply(result, shallow ? value : flatten(value));
      } else {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Gets the index at which the first occurrence of `value` is found using
   * strict equality for comparisons, i.e. `===`. If the `array` is already
   * sorted, passing `true` for `fromIndex` will run a faster binary search.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to search.
   * @param {Mixed} value The value to search for.
   * @param {Boolean|Number} [fromIndex=0] The index to search from or `true` to
   *  perform a binary search on a sorted `array`.
   * @returns {Number} Returns the index of the matched value or `-1`.
   * @example
   *
   * _.indexOf([1, 2, 3, 1, 2, 3], 2);
   * // => 1
   *
   * _.indexOf([1, 2, 3, 1, 2, 3], 2, 3);
   * // => 4
   *
   * _.indexOf([1, 1, 2, 2, 3, 3], 2, true);
   * // => 2
   */
  function indexOf(array, value, fromIndex) {
    var index = -1,
        length = array ? array.length : 0;

    if (typeof fromIndex == 'number') {
      index = (fromIndex < 0 ? nativeMax(0, length + fromIndex) : fromIndex || 0) - 1;
    } else if (fromIndex) {
      index = sortedIndex(array, value);
      return array[index] === value ? index : -1;
    }
    while (++index < length) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Gets all but the last element of `array`. Pass `n` to exclude the last `n`
   * elements from the result.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Number} [n=1] The number of elements to exclude.
   * @param- {Object} [guard] Internally used to allow this method to work with
   *  others like `_.map` without using their callback `index` argument for `n`.
   * @returns {Array} Returns all but the last element or `n` elements of `array`.
   * @example
   *
   * _.initial([3, 2, 1]);
   * // => [3, 2]
   */
  function initial(array, n, guard) {
    return array
      ? slice.call(array, 0, -((n == null || guard) ? 1 : n))
      : [];
  }

  /**
   * Computes the intersection of all the passed-in arrays using strict equality
   * for comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} [array1, array2, ...] Arrays to process.
   * @returns {Array} Returns a new array of unique elements, in order, that are
   *  present in **all** of the arrays.
   * @example
   *
   * _.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);
   * // => [1, 2]
   */
  function intersection(array) {
    var args = arguments,
        argsLength = args.length,
        cache = {},
        result = [];

    forEach(array, function(value) {
      if (indexOf(result, value) < 0) {
        var length = argsLength;
        while (--length) {
          if (!(cache[length] || (cache[length] = cachedContains(args[length])))(value)) {
            return;
          }
        }
        result.push(value);
      }
    });
    return result;
  }

  /**
   * Gets the last element of the `array`. Pass `n` to return the last `n`
   * elements of the `array`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Number} [n] The number of elements to return.
   * @param- {Object} [guard] Internally used to allow this method to work with
   *  others like `_.map` without using their callback `index` argument for `n`.
   * @returns {Mixed} Returns the last element or an array of the last `n`
   *  elements of `array`.
   * @example
   *
   * _.last([3, 2, 1]);
   * // => 1
   */
  function last(array, n, guard) {
    if (array) {
      var length = array.length;
      return (n == null || guard) ? array[length - 1] : slice.call(array, -n || length);
    }
  }

  /**
   * Gets the index at which the last occurrence of `value` is found using strict
   * equality for comparisons, i.e. `===`. If `fromIndex` is negative, it is used
   * as the offset from the end of the collection.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to search.
   * @param {Mixed} value The value to search for.
   * @param {Number} [fromIndex=array.length-1] The index to search from.
   * @returns {Number} Returns the index of the matched value or `-1`.
   * @example
   *
   * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2);
   * // => 4
   *
   * _.lastIndexOf([1, 2, 3, 1, 2, 3], 2, 3);
   * // => 1
   */
  function lastIndexOf(array, value, fromIndex) {
    var index = array ? array.length : 0;
    if (typeof fromIndex == 'number') {
      index = (fromIndex < 0 ? nativeMax(0, index + fromIndex) : nativeMin(fromIndex, index - 1)) + 1;
    }
    while (index--) {
      if (array[index] === value) {
        return index;
      }
    }
    return -1;
  }

  /**
   * Creates an object composed from arrays of `keys` and `values`. Pass either
   * a single two dimensional array, i.e. `[[key1, value1], [key2, value2]]`, or
   * two arrays, one of `keys` and one of corresponding `values`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} keys The array of keys.
   * @param {Array} [values=[]] The array of values.
   * @returns {Object} Returns an object composed of the given keys and
   *  corresponding values.
   * @example
   *
   * _.object(['moe', 'larry', 'curly'], [30, 40, 50]);
   * // => { 'moe': 30, 'larry': 40, 'curly': 50 }
   */
  function object(keys, values) {
    var index = -1,
        length = keys ? keys.length : 0,
        result = {};

    while (++index < length) {
      var key = keys[index];
      if (values) {
        result[key] = values[index];
      } else {
        result[key[0]] = key[1];
      }
    }
    return result;
  }

  /**
   * Creates an array of numbers (positive and/or negative) progressing from
   * `start` up to but not including `stop`. This method is a port of Python's
   * `range()` function. See http://docs.python.org/library/functions.html#range.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Number} [start=0] The start of the range.
   * @param {Number} end The end of the range.
   * @param {Number} [step=1] The value to increment or descrement by.
   * @returns {Array} Returns a new range array.
   * @example
   *
   * _.range(10);
   * // => [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]
   *
   * _.range(1, 11);
   * // => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]
   *
   * _.range(0, 30, 5);
   * // => [0, 5, 10, 15, 20, 25]
   *
   * _.range(0, -10, -1);
   * // => [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]
   *
   * _.range(0);
   * // => []
   */
  function range(start, end, step) {
    start = +start || 0;
    step = +step || 1;

    if (end == null) {
      end = start;
      start = 0;
    }
    // use `Array(length)` so V8 will avoid the slower "dictionary" mode
    // http://www.youtube.com/watch?v=XAqIpGU8ZZk#t=16m27s
    var index = -1,
        length = nativeMax(0, ceil((end - start) / step)),
        result = Array(length);

    while (++index < length) {
      result[index] = start;
      start += step;
    }
    return result;
  }

  /**
   * The opposite of `_.initial`, this method gets all but the first value of
   * `array`. Pass `n` to exclude the first `n` values from the result.
   *
   * @static
   * @memberOf _
   * @alias drop, tail
   * @category Arrays
   * @param {Array} array The array to query.
   * @param {Number} [n=1] The number of elements to exclude.
   * @param- {Object} [guard] Internally used to allow this method to work with
   *  others like `_.map` without using their callback `index` argument for `n`.
   * @returns {Array} Returns all but the first value or `n` values of `array`.
   * @example
   *
   * _.rest([3, 2, 1]);
   * // => [2, 1]
   */
  function rest(array, n, guard) {
    return array
      ? slice.call(array, (n == null || guard) ? 1 : n)
      : [];
  }

  /**
   * Uses a binary search to determine the smallest index at which the `value`
   * should be inserted into `array` in order to maintain the sort order of the
   * sorted `array`. If `callback` is passed, it will be executed for `value` and
   * each element in `array` to compute their sort ranking. The `callback` is
   * bound to `thisArg` and invoked with one argument; (value). The `callback`
   * argument may also be the name of a property to order by.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to iterate over.
   * @param {Mixed} value The value to evaluate.
   * @param {Function|String} [callback=identity|property] The function called
   *  per iteration or property name to order by.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Number} Returns the index at which the value should be inserted
   *  into `array`.
   * @example
   *
   * _.sortedIndex([20, 30, 50], 40);
   * // => 2
   *
   * _.sortedIndex([{ 'x': 20 }, { 'x': 30 }, { 'x': 50 }], { 'x': 40 }, 'x');
   * // => 2
   *
   * var dict = {
   *   'wordToNumber': { 'twenty': 20, 'thirty': 30, 'fourty': 40, 'fifty': 50 }
   * };
   *
   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
   *   return dict.wordToNumber[word];
   * });
   * // => 2
   *
   * _.sortedIndex(['twenty', 'thirty', 'fifty'], 'fourty', function(word) {
   *   return this.wordToNumber[word];
   * }, dict);
   * // => 2
   */
  function sortedIndex(array, value, callback, thisArg) {
    var low = 0,
        high = array ? array.length : low;

    // explicitly reference `identity` for better engine inlining
    callback = callback ? createCallback(callback, thisArg) : identity;
    value = callback(value);
    while (low < high) {
      var mid = (low + high) >>> 1;
      callback(array[mid]) < value
        ? low = mid + 1
        : high = mid;
    }
    return low;
  }

  /**
   * Computes the union of the passed-in arrays using strict equality for
   * comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} [array1, array2, ...] Arrays to process.
   * @returns {Array} Returns a new array of unique values, in order, that are
   *  present in one or more of the arrays.
   * @example
   *
   * _.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);
   * // => [1, 2, 3, 101, 10]
   */
  function union() {
    return uniq(concat.apply(arrayRef, arguments));
  }

  /**
   * Creates a duplicate-value-free version of the `array` using strict equality
   * for comparisons, i.e. `===`. If the `array` is already sorted, passing `true`
   * for `isSorted` will run a faster algorithm. If `callback` is passed, each
   * element of `array` is passed through a callback` before uniqueness is computed.
   * The `callback` is bound to `thisArg` and invoked with three arguments; (value, index, array).
   *
   * @static
   * @memberOf _
   * @alias unique
   * @category Arrays
   * @param {Array} array The array to process.
   * @param {Boolean} [isSorted=false] A flag to indicate that the `array` is already sorted.
   * @param {Function} [callback=identity] The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a duplicate-value-free array.
   * @example
   *
   * _.uniq([1, 2, 1, 3, 1]);
   * // => [1, 2, 3]
   *
   * _.uniq([1, 1, 2, 2, 3], true);
   * // => [1, 2, 3]
   *
   * _.uniq([1, 2, 1.5, 3, 2.5], function(num) { return Math.floor(num); });
   * // => [1, 2, 3]
   *
   * _.uniq([1, 2, 1.5, 3, 2.5], function(num) { return this.floor(num); }, Math);
   * // => [1, 2, 3]
   */
  function uniq(array, isSorted, callback, thisArg) {
    var index = -1,
        length = array ? array.length : 0,
        result = [],
        seen = result;

    // juggle arguments
    if (typeof isSorted == 'function') {
      thisArg = callback;
      callback = isSorted;
      isSorted = false;
    }
    // init value cache for large arrays
    var isLarge = !isSorted && length > 74;
    if (isLarge) {
      var cache = {};
    }
    if (callback) {
      seen = [];
      callback = createCallback(callback, thisArg);
    }
    while (++index < length) {
      var value = array[index],
          computed = callback ? callback(value, index, array) : value;

      if (isLarge) {
        // manually coerce `computed` to a string because `hasOwnProperty`, in
        // some older versions of Firefox, coerces objects incorrectly
        seen = hasOwnProperty.call(cache, computed + '') ? cache[computed] : (cache[computed] = []);
      }
      if (isSorted
            ? !index || seen[seen.length - 1] !== computed
            : indexOf(seen, computed) < 0
          ) {
        if (callback || isLarge) {
          seen.push(computed);
        }
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Creates an array with all occurrences of the passed values removed using
   * strict equality for comparisons, i.e. `===`.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} array The array to filter.
   * @param {Mixed} [value1, value2, ...] Values to remove.
   * @returns {Array} Returns a new filtered array.
   * @example
   *
   * _.without([1, 2, 1, 0, 3, 1, 4], 0, 1);
   * // => [2, 3, 4]
   */
  function without(array) {
    var index = -1,
        length = array ? array.length : 0,
        contains = cachedContains(arguments, 1, 20),
        result = [];

    while (++index < length) {
      var value = array[index];
      if (!contains(value)) {
        result.push(value);
      }
    }
    return result;
  }

  /**
   * Groups the elements of each array at their corresponding indexes. Useful for
   * separate data sources that are coordinated through matching array indexes.
   * For a matrix of nested arrays, `_.zip.apply(...)` can transpose the matrix
   * in a similar fashion.
   *
   * @static
   * @memberOf _
   * @category Arrays
   * @param {Array} [array1, array2, ...] Arrays to process.
   * @returns {Array} Returns a new array of grouped elements.
   * @example
   *
   * _.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);
   * // => [['moe', 30, true], ['larry', 40, false], ['curly', 50, false]]
   */
  function zip(array) {
    var index = -1,
        length = array ? max(pluck(arguments, 'length')) : 0,
        result = Array(length);

    while (++index < length) {
      result[index] = pluck(arguments, index);
    }
    return result;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Creates a function that is restricted to executing `func` only after it is
   * called `n` times. The `func` is executed with the `this` binding of the
   * created function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Number} n The number of times the function must be called before
   * it is executed.
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * var renderNotes = _.after(notes.length, render);
   * _.forEach(notes, function(note) {
   *   note.asyncSave({ 'success': renderNotes });
   * });
   * // `renderNotes` is run once, after all notes have saved
   */
  function after(n, func) {
    if (n < 1) {
      return func();
    }
    return function() {
      if (--n < 1) {
        return func.apply(this, arguments);
      }
    };
  }

  /**
   * Creates a function that, when called, invokes `func` with the `this`
   * binding of `thisArg` and prepends any additional `bind` arguments to those
   * passed to the bound function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to bind.
   * @param {Mixed} [thisArg] The `this` binding of `func`.
   * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * var func = function(greeting) {
   *   return greeting + ' ' + this.name;
   * };
   *
   * func = _.bind(func, { 'name': 'moe' }, 'hi');
   * func();
   * // => 'hi moe'
   */
  function bind(func, thisArg) {
    // use `Function#bind` if it exists and is fast
    // (in V8 `Function#bind` is slower except when partially applied)
    return isBindFast || (nativeBind && arguments.length > 2)
      ? nativeBind.call.apply(nativeBind, arguments)
      : createBound(func, thisArg, slice.call(arguments, 2));
  }

  /**
   * Binds methods on `object` to `object`, overwriting the existing method.
   * If no method names are provided, all the function properties of `object`
   * will be bound.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Object} object The object to bind and assign the bound methods to.
   * @param {String} [methodName1, methodName2, ...] Method names on the object to bind.
   * @returns {Object} Returns `object`.
   * @example
   *
   * var buttonView = {
   *  'label': 'lodash',
   *  'onClick': function() { alert('clicked: ' + this.label); }
   * };
   *
   * _.bindAll(buttonView);
   * jQuery('#lodash_button').on('click', buttonView.onClick);
   * // => When the button is clicked, `this.label` will have the correct value
   */
  function bindAll(object) {
    var funcs = arguments,
        index = funcs.length > 1 ? 0 : (funcs = functions(object), -1),
        length = funcs.length;

    while (++index < length) {
      var key = funcs[index];
      object[key] = bind(object[key], object);
    }
    return object;
  }

  /**
   * Creates a function that is the composition of the passed functions,
   * where each function consumes the return value of the function that follows.
   * In math terms, composing the functions `f()`, `g()`, and `h()` produces `f(g(h()))`.
   * Each function is executed with the `this` binding of the composed function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} [func1, func2, ...] Functions to compose.
   * @returns {Function} Returns the new composed function.
   * @example
   *
   * var greet = function(name) { return 'hi: ' + name; };
   * var exclaim = function(statement) { return statement + '!'; };
   * var welcome = _.compose(exclaim, greet);
   * welcome('moe');
   * // => 'hi: moe!'
   */
  function compose() {
    var funcs = arguments;
    return function() {
      var args = arguments,
          length = funcs.length;

      while (length--) {
        args = [funcs[length].apply(this, args)];
      }
      return args[0];
    };
  }

  /**
   * Creates a function that will delay the execution of `func` until after
   * `wait` milliseconds have elapsed since the last time it was invoked. Pass
   * `true` for `immediate` to cause debounce to invoke `func` on the leading,
   * instead of the trailing, edge of the `wait` timeout. Subsequent calls to
   * the debounced function will return the result of the last `func` call.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to debounce.
   * @param {Number} wait The number of milliseconds to delay.
   * @param {Boolean} immediate A flag to indicate execution is on the leading
   *  edge of the timeout.
   * @returns {Function} Returns the new debounced function.
   * @example
   *
   * var lazyLayout = _.debounce(calculateLayout, 300);
   * jQuery(window).on('resize', lazyLayout);
   */
  function debounce(func, wait, immediate) {
    var args,
        result,
        thisArg,
        timeoutId;

    function delayed() {
      timeoutId = null;
      if (!immediate) {
        result = func.apply(thisArg, args);
      }
    }
    return function() {
      var isImmediate = immediate && !timeoutId;
      args = arguments;
      thisArg = this;

      clearTimeout(timeoutId);
      timeoutId = setTimeout(delayed, wait);

      if (isImmediate) {
        result = func.apply(thisArg, args);
      }
      return result;
    };
  }

  /**
   * Executes the `func` function after `wait` milliseconds. Additional arguments
   * will be passed to `func` when it is invoked.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to delay.
   * @param {Number} wait The number of milliseconds to delay execution.
   * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.
   * @returns {Number} Returns the `setTimeout` timeout id.
   * @example
   *
   * var log = _.bind(console.log, console);
   * _.delay(log, 1000, 'logged later');
   * // => 'logged later' (Appears after one second.)
   */
  function delay(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function() { func.apply(undefined, args); }, wait);
  }

  /**
   * Defers executing the `func` function until the current call stack has cleared.
   * Additional arguments will be passed to `func` when it is invoked.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to defer.
   * @param {Mixed} [arg1, arg2, ...] Arguments to invoke the function with.
   * @returns {Number} Returns the `setTimeout` timeout id.
   * @example
   *
   * _.defer(function() { alert('deferred'); });
   * // returns from the function before `alert` is called
   */
  function defer(func) {
    var args = slice.call(arguments, 1);
    return setTimeout(function() { func.apply(undefined, args); }, 1);
  }

  /**
   * Creates a function that, when called, invokes `object[methodName]` and
   * prepends any additional `lateBind` arguments to those passed to the bound
   * function. This method differs from `_.bind` by allowing bound functions to
   * reference methods that will be redefined or don't yet exist.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Object} object The object the method belongs to.
   * @param {String} methodName The method name.
   * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
   * @returns {Function} Returns the new bound function.
   * @example
   *
   * var object = {
   *   'name': 'moe',
   *   'greet': function(greeting) {
   *     return greeting + ' ' + this.name;
   *   }
   * };
   *
   * var func = _.lateBind(object, 'greet', 'hi');
   * func();
   * // => 'hi moe'
   *
   * object.greet = function(greeting) {
   *   return greeting + ', ' + this.name + '!';
   * };
   *
   * func();
   * // => 'hi, moe!'
   */
  function lateBind(object, methodName) {
    return createBound(methodName, object, slice.call(arguments, 2));
  }

  /**
   * Creates a function that memoizes the result of `func`. If `resolver` is
   * passed, it will be used to determine the cache key for storing the result
   * based on the arguments passed to the memoized function. By default, the first
   * argument passed to the memoized function is used as the cache key. The `func`
   * is executed with the `this` binding of the memoized function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to have its output memoized.
   * @param {Function} [resolver] A function used to resolve the cache key.
   * @returns {Function} Returns the new memoizing function.
   * @example
   *
   * var fibonacci = _.memoize(function(n) {
   *   return n < 2 ? n : fibonacci(n - 1) + fibonacci(n - 2);
   * });
   */
  function memoize(func, resolver) {
    var cache = {};
    return function() {
      var key = resolver ? resolver.apply(this, arguments) : arguments[0];
      return hasOwnProperty.call(cache, key)
        ? cache[key]
        : (cache[key] = func.apply(this, arguments));
    };
  }

  /**
   * Creates a function that is restricted to execute `func` once. Repeat calls to
   * the function will return the value of the first call. The `func` is executed
   * with the `this` binding of the created function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to restrict.
   * @returns {Function} Returns the new restricted function.
   * @example
   *
   * var initialize = _.once(createApplication);
   * initialize();
   * initialize();
   * // Application is only created once.
   */
  function once(func) {
    var result,
        ran = false;

    return function() {
      if (ran) {
        return result;
      }
      ran = true;
      result = func.apply(this, arguments);

      // clear the `func` variable so the function may be garbage collected
      func = null;
      return result;
    };
  }

  /**
   * Creates a function that, when called, invokes `func` with any additional
   * `partial` arguments prepended to those passed to the new function. This
   * method is similar to `bind`, except it does **not** alter the `this` binding.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to partially apply arguments to.
   * @param {Mixed} [arg1, arg2, ...] Arguments to be partially applied.
   * @returns {Function} Returns the new partially applied function.
   * @example
   *
   * var greet = function(greeting, name) { return greeting + ': ' + name; };
   * var hi = _.partial(greet, 'hi');
   * hi('moe');
   * // => 'hi: moe'
   */
  function partial(func) {
    return createBound(func, slice.call(arguments, 1));
  }

  /**
   * Creates a function that, when executed, will only call the `func`
   * function at most once per every `wait` milliseconds. If the throttled
   * function is invoked more than once during the `wait` timeout, `func` will
   * also be called on the trailing edge of the timeout. Subsequent calls to the
   * throttled function will return the result of the last `func` call.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Function} func The function to throttle.
   * @param {Number} wait The number of milliseconds to throttle executions to.
   * @returns {Function} Returns the new throttled function.
   * @example
   *
   * var throttled = _.throttle(updatePosition, 100);
   * jQuery(window).on('scroll', throttled);
   */
  function throttle(func, wait) {
    var args,
        result,
        thisArg,
        timeoutId,
        lastCalled = 0;

    function trailingCall() {
      lastCalled = new Date;
      timeoutId = null;
      result = func.apply(thisArg, args);
    }
    return function() {
      var now = new Date,
          remaining = wait - (now - lastCalled);

      args = arguments;
      thisArg = this;

      if (remaining <= 0) {
        clearTimeout(timeoutId);
        lastCalled = now;
        result = func.apply(thisArg, args);
      }
      else if (!timeoutId) {
        timeoutId = setTimeout(trailingCall, remaining);
      }
      return result;
    };
  }

  /**
   * Creates a function that passes `value` to the `wrapper` function as its
   * first argument. Additional arguments passed to the function are appended
   * to those passed to the `wrapper` function. The `wrapper` is executed with
   * the `this` binding of the created function.
   *
   * @static
   * @memberOf _
   * @category Functions
   * @param {Mixed} value The value to wrap.
   * @param {Function} wrapper The wrapper function.
   * @returns {Function} Returns the new function.
   * @example
   *
   * var hello = function(name) { return 'hello ' + name; };
   * hello = _.wrap(hello, function(func) {
   *   return 'before, ' + func('moe') + ', after';
   * });
   * hello();
   * // => 'before, hello moe, after'
   */
  function wrap(value, wrapper) {
    return function() {
      var args = [value];
      push.apply(args, arguments);
      return wrapper.apply(this, args);
    };
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Converts the characters `&`, `<`, `>`, `"`, and `'` in `string` to their
   * corresponding HTML entities.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {String} string The string to escape.
   * @returns {String} Returns the escaped string.
   * @example
   *
   * _.escape('Moe, Larry & Curly');
   * // => "Moe, Larry &amp; Curly"
   */
  function escape(string) {
    return string == null ? '' : (string + '').replace(reUnescapedHtml, escapeHtmlChar);
  }

  /**
   * This function returns the first argument passed to it.
   *
   * Note: It is used throughout Lo-Dash as a default callback.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Mixed} value Any value.
   * @returns {Mixed} Returns `value`.
   * @example
   *
   * var moe = { 'name': 'moe' };
   * moe === _.identity(moe);
   * // => true
   */
  function identity(value) {
    return value;
  }

  /**
   * Adds functions properties of `object` to the `lodash` function and chainable
   * wrapper.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} object The object of function properties to add to `lodash`.
   * @example
   *
   * _.mixin({
   *   'capitalize': function(string) {
   *     return string.charAt(0).toUpperCase() + string.slice(1).toLowerCase();
   *   }
   * });
   *
   * _.capitalize('larry');
   * // => 'Larry'
   *
   * _('curly').capitalize();
   * // => 'Curly'
   */
  function mixin(object) {
    forEach(functions(object), function(methodName) {
      var func = lodash[methodName] = object[methodName];

      lodash.prototype[methodName] = function() {
        var args = [this.__wrapped__];
        push.apply(args, arguments);

        var result = func.apply(lodash, args);
        if (this.__chain__) {
          result = new lodash(result);
          result.__chain__ = true;
        }
        return result;
      };
    });
  }

  /**
   * Reverts the '_' variable to its previous value and returns a reference to
   * the `lodash` function.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @returns {Function} Returns the `lodash` function.
   * @example
   *
   * var lodash = _.noConflict();
   */
  function noConflict() {
    window._ = oldDash;
    return this;
  }

  /**
   * Produces a random number between `min` and `max` (inclusive). If only one
   * argument is passed, a number between `0` and the given number will be returned.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Number} [min=0] The minimum possible value.
   * @param {Number} [max=1] The maximum possible value.
   * @returns {Number} Returns a random number.
   * @example
   *
   * _.random(0, 5);
   * // => a number between 1 and 5
   *
   * _.random(5);
   * // => also a number between 1 and 5
   */
  function random(min, max) {
    if (min == null && max == null) {
      max = 1;
    }
    min = +min || 0;
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + floor(nativeRandom() * ((+max || 0) - min + 1));
  }

  /**
   * Resolves the value of `property` on `object`. If `property` is a function
   * it will be invoked and its result returned, else the property value is
   * returned. If `object` is falsey, then `null` is returned.
   *
   * @deprecated
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Object} object The object to inspect.
   * @param {String} property The property to get the value of.
   * @returns {Mixed} Returns the resolved value.
   * @example
   *
   * var object = {
   *   'cheese': 'crumpets',
   *   'stuff': function() {
   *     return 'nonsense';
   *   }
   * };
   *
   * _.result(object, 'cheese');
   * // => 'crumpets'
   *
   * _.result(object, 'stuff');
   * // => 'nonsense'
   */
  function result(object, property) {
    // based on Backbone's private `getValue` function
    // https://github.com/documentcloud/backbone/blob/0.9.2/backbone.js#L1419-1424
    var value = object ? object[property] : null;
    return isFunction(value) ? object[property]() : value;
  }

  /**
   * A micro-templating method that handles arbitrary delimiters, preserves
   * whitespace, and correctly escapes quotes within interpolated code.
   *
   * Note: In the development build `_.template` utilizes sourceURLs for easier
   * debugging. See http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
   *
   * Note: Lo-Dash may be used in Chrome extensions by either creating a `lodash csp`
   * build and avoiding `_.template` use, or loading Lo-Dash in a sandboxed page.
   * See http://developer.chrome.com/trunk/extensions/sandboxingEval.html
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {String} text The template text.
   * @param {Obect} data The data object used to populate the text.
   * @param {Object} options The options object.
   *  escape - The "escape" delimiter regexp.
   *  evaluate - The "evaluate" delimiter regexp.
   *  interpolate - The "interpolate" delimiter regexp.
   *  sourceURL - The sourceURL of the template's compiled source.
   *  variable - The data object variable name.
   *
   * @returns {Function|String} Returns a compiled function when no `data` object
   *  is given, else it returns the interpolated text.
   * @example
   *
   * // using a compiled template
   * var compiled = _.template('hello <%= name %>');
   * compiled({ 'name': 'moe' });
   * // => 'hello moe'
   *
   * var list = '<% _.forEach(people, function(name) { %><li><%= name %></li><% }); %>';
   * _.template(list, { 'people': ['moe', 'larry', 'curly'] });
   * // => '<li>moe</li><li>larry</li><li>curly</li>'
   *
   * // using the "escape" delimiter to escape HTML in data property values
   * _.template('<b><%- value %></b>', { 'value': '<script>' });
   * // => '<b>&lt;script&gt;</b>'
   *
   * // using the ES6 delimiter as an alternative to the default "interpolate" delimiter
   * _.template('hello ${ name }', { 'name': 'curly' });
   * // => 'hello curly'
   *
   * // using the internal `print` function in "evaluate" delimiters
   * _.template('<% print("hello " + epithet); %>!', { 'epithet': 'stooge' });
   * // => 'hello stooge!'
   *
   * // using custom template delimiters
   * _.templateSettings = {
   *   'interpolate': /{{([\s\S]+?)}}/g
   * };
   *
   * _.template('hello {{ name }}!', { 'name': 'mustache' });
   * // => 'hello mustache!'
   *
   * // using the `sourceURL` option to specify a custom sourceURL for the template
   * var compiled = _.template('hello <%= name %>', null, { 'sourceURL': '/basic/greeting.jst' });
   * compiled(data);
   * // => find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector
   *
   * // using the `variable` option to ensure a with-statement isn't used in the compiled template
   * var compiled = _.template('hello <%= data.name %>!', null, { 'variable': 'data' });
   * compiled.source;
   * // => function(data) {
   *   var __t, __p = '', __e = _.escape;
   *   __p += 'hello ' + ((__t = ( data.name )) == null ? '' : __t) + '!';
   *   return __p;
   * }
   *
   * // using the `source` property to inline compiled templates for meaningful
   * // line numbers in error messages and a stack trace
   * fs.writeFileSync(path.join(cwd, 'jst.js'), '\
   *   var JST = {\
   *     "main": ' + _.template(mainText).source + '\
   *   };\
   * ');
   */
  function template(text, data, options) {
    // based on John Resig's `tmpl` implementation
    // http://ejohn.org/blog/javascript-micro-templating/
    // and Laura Doktorova's doT.js
    // https://github.com/olado/doT
    text || (text = '');
    options || (options = {});

    var isEvaluating,
        result,
        settings = lodash.templateSettings,
        index = 0,
        interpolate = options.interpolate || settings.interpolate || reNoMatch,
        source = "__p += '",
        variable = options.variable || settings.variable,
        hasVariable = variable;

    // compile regexp to match each delimiter
    var reDelimiters = RegExp(
      (options.escape || settings.escape || reNoMatch).source + '|' +
      interpolate.source + '|' +
      (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
      (options.evaluate || settings.evaluate || reNoMatch).source + '|$'
    , 'g');

    text.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
      interpolateValue || (interpolateValue = esTemplateValue);

      // escape characters that cannot be included in string literals
      source += text.slice(index, offset).replace(reUnescapedString, escapeStringChar);

      // replace delimiters with snippets
      source +=
        escapeValue ? "' +\n__e(" + escapeValue + ") +\n'" :
        evaluateValue ? "';\n" + evaluateValue + ";\n__p += '" :
        interpolateValue ? "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'" : '';

      isEvaluating || (isEvaluating = evaluateValue || reComplexDelimiter.test(escapeValue || interpolateValue));
      index = offset + match.length;
    });

    source += "';\n";

    // if `variable` is not specified and the template contains "evaluate"
    // delimiters, wrap a with-statement around the generated code to add the
    // data object to the top of the scope chain
    if (!hasVariable) {
      variable = 'obj';
      if (isEvaluating) {
        source = 'with (' + variable + ') {\n' + source + '\n}\n';
      }
      else {
        // avoid a with-statement by prepending data object references to property names
        var reDoubleVariable = RegExp('(\\(\\s*)' + variable + '\\.' + variable + '\\b', 'g');
        source = source
          .replace(reInsertVariable, '$&' + variable + '.')
          .replace(reDoubleVariable, '$1__d');
      }
    }

    // cleanup code by stripping empty strings
    source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
      .replace(reEmptyStringMiddle, '$1')
      .replace(reEmptyStringTrailing, '$1;');

    // frame code as the function body
    source = 'function(' + variable + ') {\n' +
      (hasVariable ? '' : variable + ' || (' + variable + ' = {});\n') +
      'var __t, __p = \'\', __e = _.escape' +
      (isEvaluating
        ? ', __j = Array.prototype.join;\n' +
          'function print() { __p += __j.call(arguments, \'\') }\n'
        : (hasVariable ? '' : ', __d = ' + variable + '.' + variable + ' || ' + variable) + ';\n'
      ) +
      source +
      'return __p\n}';

    // use a sourceURL for easier debugging
    // http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl
    var sourceURL = useSourceURL
      ? '\n//@ sourceURL=' + (options.sourceURL || '/lodash/template/source[' + (templateCounter++) + ']')
      : '';

    try {
      result = Function('_', 'return ' + source + sourceURL)(lodash);
    } catch(e) {
      e.source = source;
      throw e;
    }

    if (data) {
      return result(data);
    }
    // provide the compiled function's source via its `toString` method, in
    // supported environments, or the `source` property as a convenience for
    // inlining compiled templates during the build process
    result.source = source;
    return result;
  }

  /**
   * Executes the `callback` function `n` times, returning an array of the results
   * of each `callback` execution. The `callback` is bound to `thisArg` and invoked
   * with one argument; (index).
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {Number} n The number of times to execute the callback.
   * @param {Function} callback The function called per iteration.
   * @param {Mixed} [thisArg] The `this` binding of `callback`.
   * @returns {Array} Returns a new array of the results of each `callback` execution.
   * @example
   *
   * var diceRolls = _.times(3, _.partial(_.random, 1, 6));
   * // => [3, 6, 4]
   *
   * _.times(3, function(n) { mage.castSpell(n); });
   * // => calls `mage.castSpell(n)` three times, passing `n` of `0`, `1`, and `2` respectively
   *
   * _.times(3, function(n) { this.cast(n); }, mage);
   * // => also calls `mage.castSpell(n)` three times
   */
  function times(n, callback, thisArg) {
    n = +n || 0;
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = callback.call(thisArg, index);
    }
    return result;
  }

  /**
   * The opposite of `_.escape`, this method converts the HTML entities
   * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#x27;` in `string` to their
   * corresponding characters.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {String} string The string to unescape.
   * @returns {String} Returns the unescaped string.
   * @example
   *
   * _.unescape('Moe, Larry &amp; Curly');
   * // => "Moe, Larry & Curly"
   */
  function unescape(string) {
    return string == null ? '' : (string + '').replace(reEscapedHtml, unescapeHtmlChar);
  }

  /**
   * Generates a unique id. If `prefix` is passed, the id will be appended to it.
   *
   * @static
   * @memberOf _
   * @category Utilities
   * @param {String} [prefix] The value to prefix the id with.
   * @returns {Number|String} Returns a numeric id if no prefix is passed, else
   *  a string id may be returned.
   * @example
   *
   * _.uniqueId('contact_');
   * // => 'contact_104'
   */
  function uniqueId(prefix) {
    var id = idCounter++;
    return prefix ? prefix + id : id;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * Wraps the value in a `lodash` wrapper object.
   *
   * @static
   * @memberOf _
   * @category Chaining
   * @param {Mixed} value The value to wrap.
   * @returns {Object} Returns the wrapper object.
   * @example
   *
   * var stooges = [
   *   { 'name': 'moe', 'age': 40 },
   *   { 'name': 'larry', 'age': 50 },
   *   { 'name': 'curly', 'age': 60 }
   * ];
   *
   * var youngest = _.chain(stooges)
   *     .sortBy(function(stooge) { return stooge.age; })
   *     .map(function(stooge) { return stooge.name + ' is ' + stooge.age; })
   *     .first()
   *     .value();
   * // => 'moe is 40'
   */
  function chain(value) {
    value = new lodash(value);
    value.__chain__ = true;
    return value;
  }

  /**
   * Invokes `interceptor` with the `value` as the first argument, and then
   * returns `value`. The purpose of this method is to "tap into" a method chain,
   * in order to perform operations on intermediate results within the chain.
   *
   * @static
   * @memberOf _
   * @category Chaining
   * @param {Mixed} value The value to pass to `interceptor`.
   * @param {Function} interceptor The function to invoke.
   * @returns {Mixed} Returns `value`.
   * @example
   *
   * _.chain([1, 2, 3, 200])
   *  .filter(function(num) { return num % 2 == 0; })
   *  .tap(alert)
   *  .map(function(num) { return num * num })
   *  .value();
   * // => // [2, 200] (alerted)
   * // => [4, 40000]
   */
  function tap(value, interceptor) {
    interceptor(value);
    return value;
  }

  /**
   * Enables method chaining on the wrapper object.
   *
   * @name chain
   * @deprecated
   * @memberOf _
   * @category Chaining
   * @returns {Mixed} Returns the wrapper object.
   * @example
   *
   * _([1, 2, 3]).value();
   * // => [1, 2, 3]
   */
  function wrapperChain() {
    this.__chain__ = true;
    return this;
  }

  /**
   * Extracts the wrapped value.
   *
   * @name value
   * @memberOf _
   * @category Chaining
   * @returns {Mixed} Returns the wrapped value.
   * @example
   *
   * _([1, 2, 3]).value();
   * // => [1, 2, 3]
   */
  function wrapperValue() {
    return this.__wrapped__;
  }

  /*--------------------------------------------------------------------------*/

  /**
   * The semantic version number.
   *
   * @static
   * @memberOf _
   * @type String
   */
  lodash.VERSION = '0.9.2';

  // assign static methods
  lodash.after = after;
  lodash.bind = bind;
  lodash.bindAll = bindAll;
  lodash.chain = chain;
  lodash.clone = clone;
  lodash.compact = compact;
  lodash.compose = compose;
  lodash.contains = contains;
  lodash.countBy = countBy;
  lodash.debounce = debounce;
  lodash.defaults = defaults;
  lodash.defer = defer;
  lodash.delay = delay;
  lodash.difference = difference;
  lodash.escape = escape;
  lodash.every = every;
  lodash.extend = extend;
  lodash.filter = filter;
  lodash.find = find;
  lodash.first = first;
  lodash.flatten = flatten;
  lodash.forEach = forEach;
  lodash.forIn = forIn;
  lodash.forOwn = forOwn;
  lodash.functions = functions;
  lodash.groupBy = groupBy;
  lodash.has = has;
  lodash.identity = identity;
  lodash.indexOf = indexOf;
  lodash.initial = initial;
  lodash.intersection = intersection;
  lodash.invert = invert;
  lodash.invoke = invoke;
  lodash.isArguments = isArguments;
  lodash.isArray = isArray;
  lodash.isBoolean = isBoolean;
  lodash.isDate = isDate;
  lodash.isElement = isElement;
  lodash.isEmpty = isEmpty;
  lodash.isEqual = isEqual;
  lodash.isFinite = isFinite;
  lodash.isFunction = isFunction;
  lodash.isNaN = isNaN;
  lodash.isNull = isNull;
  lodash.isNumber = isNumber;
  lodash.isObject = isObject;
  lodash.isPlainObject = isPlainObject;
  lodash.isRegExp = isRegExp;
  lodash.isString = isString;
  lodash.isUndefined = isUndefined;
  lodash.keys = keys;
  lodash.last = last;
  lodash.lastIndexOf = lastIndexOf;
  lodash.lateBind = lateBind;
  lodash.map = map;
  lodash.max = max;
  lodash.memoize = memoize;
  lodash.merge = merge;
  lodash.min = min;
  lodash.mixin = mixin;
  lodash.noConflict = noConflict;
  lodash.object = object;
  lodash.omit = omit;
  lodash.once = once;
  lodash.pairs = pairs;
  lodash.partial = partial;
  lodash.pick = pick;
  lodash.pluck = pluck;
  lodash.random = random;
  lodash.range = range;
  lodash.reduce = reduce;
  lodash.reduceRight = reduceRight;
  lodash.reject = reject;
  lodash.rest = rest;
  lodash.result = result;
  lodash.shuffle = shuffle;
  lodash.size = size;
  lodash.some = some;
  lodash.sortBy = sortBy;
  lodash.sortedIndex = sortedIndex;
  lodash.tap = tap;
  lodash.template = template;
  lodash.throttle = throttle;
  lodash.times = times;
  lodash.toArray = toArray;
  lodash.unescape = unescape;
  lodash.union = union;
  lodash.uniq = uniq;
  lodash.uniqueId = uniqueId;
  lodash.values = values;
  lodash.where = where;
  lodash.without = without;
  lodash.wrap = wrap;
  lodash.zip = zip;

  // assign aliases
  lodash.all = every;
  lodash.any = some;
  lodash.collect = map;
  lodash.detect = find;
  lodash.drop = rest;
  lodash.each = forEach;
  lodash.foldl = reduce;
  lodash.foldr = reduceRight;
  lodash.head = first;
  lodash.include = contains;
  lodash.inject = reduce;
  lodash.methods = functions;
  lodash.select = filter;
  lodash.tail = rest;
  lodash.take = first;
  lodash.unique = uniq;

  // add pseudo private property to be used and removed during the build process
  lodash._iteratorTemplate = iteratorTemplate;

  /*--------------------------------------------------------------------------*/

  // add all static functions to `lodash.prototype`
  mixin(lodash);

  // add `lodash.prototype.chain` after calling `mixin()` to avoid overwriting
  // it with the wrapped `lodash.chain`
  lodash.prototype.chain = wrapperChain;
  lodash.prototype.value = wrapperValue;

  // add all mutator Array functions to the wrapper.
  forEach(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
    var func = arrayRef[methodName];

    lodash.prototype[methodName] = function() {
      var value = this.__wrapped__;
      func.apply(value, arguments);

      // avoid array-like object bugs with `Array#shift` and `Array#splice` in
      // Firefox < 10 and IE < 9
      if (hasObjectSpliceBug && value.length === 0) {
        delete value[0];
      }
      if (this.__chain__) {
        value = new lodash(value);
        value.__chain__ = true;
      }
      return value;
    };
  });

  // add all accessor Array functions to the wrapper.
  forEach(['concat', 'join', 'slice'], function(methodName) {
    var func = arrayRef[methodName];

    lodash.prototype[methodName] = function() {
      var value = this.__wrapped__,
          result = func.apply(value, arguments);

      if (this.__chain__) {
        result = new lodash(result);
        result.__chain__ = true;
      }
      return result;
    };
  });

  /*--------------------------------------------------------------------------*/

  // expose Lo-Dash
  // some AMD build optimizers, like r.js, check for specific condition patterns like the following:
  if (typeof define == 'function' && typeof define.amd == 'object' && define.amd) {
    // Expose Lo-Dash to the global object even when an AMD loader is present in
    // case Lo-Dash was injected by a third-party script and not intended to be
    // loaded as a module. The global assignment can be reverted in the Lo-Dash
    // module via its `noConflict()` method.
    window._ = lodash;

    // define as an anonymous module so, through path mapping, it can be
    // referenced as the "underscore" module
    define(function() {
      return lodash;
    });
  }
  // check for `exports` after `define` in case a build optimizer adds an `exports` object
  else if (freeExports) {
    // in Node.js or RingoJS v0.8.0+
    if (typeof module == 'object' && module && module.exports == freeExports) {
      (module.exports = lodash)._ = lodash;
    }
    // in Narwhal or RingoJS v0.7.0-
    else {
      freeExports._ = lodash;
    }
  }
  else {
    // in a browser or Rhino
    window._ = lodash;
  }
}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})

},{}],7:[function(require,module,exports){
/*!
 * Paper.js v0.9.25 - The Swiss Army Knife of Vector Graphics Scripting.
 * http://paperjs.org/
 *
 * Copyright (c) 2011 - 2014, Juerg Lehni & Jonathan Puckey
 * http://scratchdisk.com/ & http://jonathanpuckey.com/
 *
 * Distributed under the MIT license. See LICENSE file for details.
 *
 * All rights reserved.
 *
 * Date: Sun Oct 25 11:23:38 2015 +0100
 *
 ***
 *
 * Straps.js - Class inheritance library with support for bean-style accessors
 *
 * Copyright (c) 2006 - 2013 Juerg Lehni
 * http://scratchdisk.com/
 *
 * Distributed under the MIT license.
 *
 ***
 *
 * Acorn.js
 * http://marijnhaverbeke.nl/acorn/
 *
 * Acorn is a tiny, fast JavaScript parser written in JavaScript,
 * created by Marijn Haverbeke and released under an MIT license.
 *
 */

var paper = new function(undefined) {

var Base = new function() {
	var hidden = /^(statics|enumerable|beans|preserve)$/,

		forEach = [].forEach || function(iter, bind) {
			for (var i = 0, l = this.length; i < l; i++)
				iter.call(bind, this[i], i, this);
		},

		forIn = function(iter, bind) {
			for (var i in this)
				if (this.hasOwnProperty(i))
					iter.call(bind, this[i], i, this);
		},

		create = Object.create || function(proto) {
			return { __proto__: proto };
		},

		describe = Object.getOwnPropertyDescriptor || function(obj, name) {
			var get = obj.__lookupGetter__ && obj.__lookupGetter__(name);
			return get
					? { get: get, set: obj.__lookupSetter__(name),
						enumerable: true, configurable: true }
					: obj.hasOwnProperty(name)
						? { value: obj[name], enumerable: true,
							configurable: true, writable: true }
						: null;
		},

		_define = Object.defineProperty || function(obj, name, desc) {
			if ((desc.get || desc.set) && obj.__defineGetter__) {
				if (desc.get)
					obj.__defineGetter__(name, desc.get);
				if (desc.set)
					obj.__defineSetter__(name, desc.set);
			} else {
				obj[name] = desc.value;
			}
			return obj;
		},

		define = function(obj, name, desc) {
			delete obj[name];
			return _define(obj, name, desc);
		};

	function inject(dest, src, enumerable, beans, preserve) {
		var beansNames = {};

		function field(name, val) {
			val = val || (val = describe(src, name))
					&& (val.get ? val : val.value);
			if (typeof val === 'string' && val[0] === '#')
				val = dest[val.substring(1)] || val;
			var isFunc = typeof val === 'function',
				res = val,
				prev = preserve || isFunc && !val.base
						? (val && val.get ? name in dest : dest[name])
						: null,
				bean;
			if (!preserve || !prev) {
				if (isFunc && prev)
					val.base = prev;
				if (isFunc && beans !== false
						&& (bean = name.match(/^([gs]et|is)(([A-Z])(.*))$/)))
					beansNames[bean[3].toLowerCase() + bean[4]] = bean[2];
				if (!res || isFunc || !res.get || typeof res.get !== 'function'
						|| !Base.isPlainObject(res))
					res = { value: res, writable: true };
				if ((describe(dest, name)
						|| { configurable: true }).configurable) {
					res.configurable = true;
					res.enumerable = enumerable;
				}
				define(dest, name, res);
			}
		}
		if (src) {
			for (var name in src) {
				if (src.hasOwnProperty(name) && !hidden.test(name))
					field(name);
			}
			for (var name in beansNames) {
				var part = beansNames[name],
					set = dest['set' + part],
					get = dest['get' + part] || set && dest['is' + part];
				if (get && (beans === true || get.length === 0))
					field(name, { get: get, set: set });
			}
		}
		return dest;
	}

	function each(obj, iter, bind) {
		if (obj)
			('length' in obj && !obj.getLength
					&& typeof obj.length === 'number'
				? forEach
				: forIn).call(obj, iter, bind = bind || obj);
		return bind;
	}

	function set(obj, props, exclude) {
		for (var key in props)
			if (props.hasOwnProperty(key) && !(exclude && exclude[key]))
				obj[key] = props[key];
		return obj;
	}

	return inject(function Base() {
		for (var i = 0, l = arguments.length; i < l; i++)
			set(this, arguments[i]);
	}, {
		inject: function(src) {
			if (src) {
				var statics = src.statics === true ? src : src.statics,
					beans = src.beans,
					preserve = src.preserve;
				if (statics !== src)
					inject(this.prototype, src, src.enumerable, beans, preserve);
				inject(this, statics, true, beans, preserve);
			}
			for (var i = 1, l = arguments.length; i < l; i++)
				this.inject(arguments[i]);
			return this;
		},

		extend: function() {
			var base = this,
				ctor,
				proto;
			for (var i = 0, l = arguments.length; i < l; i++)
				if (ctor = arguments[i].initialize)
					break;
			ctor = ctor || function() {
				base.apply(this, arguments);
			};
			proto = ctor.prototype = create(this.prototype);
			define(proto, 'constructor',
					{ value: ctor, writable: true, configurable: true });
			inject(ctor, this, true);
			if (arguments.length)
				this.inject.apply(ctor, arguments);
			ctor.base = base;
			return ctor;
		}
	}, true).inject({
		inject: function() {
			for (var i = 0, l = arguments.length; i < l; i++) {
				var src = arguments[i];
				if (src)
					inject(this, src, src.enumerable, src.beans, src.preserve);
			}
			return this;
		},

		extend: function() {
			var res = create(this);
			return res.inject.apply(res, arguments);
		},

		each: function(iter, bind) {
			return each(this, iter, bind);
		},

		set: function(props) {
			return set(this, props);
		},

		clone: function() {
			return new this.constructor(this);
		},

		statics: {
			each: each,
			create: create,
			define: define,
			describe: describe,
			set: set,

			clone: function(obj) {
				return set(new obj.constructor(), obj);
			},

			isPlainObject: function(obj) {
				var ctor = obj != null && obj.constructor;
				return ctor && (ctor === Object || ctor === Base
						|| ctor.name === 'Object');
			},

			pick: function(a, b) {
				return a !== undefined ? a : b;
			}
		}
	});
};

if (typeof module !== 'undefined')
	module.exports = Base;

Base.inject({
	toString: function() {
		return this._id != null
			?  (this._class || 'Object') + (this._name
				? " '" + this._name + "'"
				: ' @' + this._id)
			: '{ ' + Base.each(this, function(value, key) {
				if (!/^_/.test(key)) {
					var type = typeof value;
					this.push(key + ': ' + (type === 'number'
							? Formatter.instance.number(value)
							: type === 'string' ? "'" + value + "'" : value));
				}
			}, []).join(', ') + ' }';
	},

	getClassName: function() {
		return this._class || '';
	},

	exportJSON: function(options) {
		return Base.exportJSON(this, options);
	},

	toJSON: function() {
		return Base.serialize(this);
	},

	_set: function(props, exclude, dontCheck) {
		if (props && (dontCheck || Base.isPlainObject(props))) {
			var keys = Object.keys(props._filtering || props);
			for (var i = 0, l = keys.length; i < l; i++) {
				var key = keys[i];
				if (!(exclude && exclude[key])) {
					var value = props[key];
					if (value !== undefined)
						this[key] = value;
				}
			}
			return true;
		}
	},

	statics: {

		exports: {
			enumerable: true
		},

		extend: function extend() {
			var res = extend.base.apply(this, arguments),
				name = res.prototype._class;
			if (name && !Base.exports[name])
				Base.exports[name] = res;
			return res;
		},

		equals: function(obj1, obj2) {
			if (obj1 === obj2)
				return true;
			if (obj1 && obj1.equals)
				return obj1.equals(obj2);
			if (obj2 && obj2.equals)
				return obj2.equals(obj1);
			if (obj1 && obj2
					&& typeof obj1 === 'object' && typeof obj2 === 'object') {
				if (Array.isArray(obj1) && Array.isArray(obj2)) {
					var length = obj1.length;
					if (length !== obj2.length)
						return false;
					while (length--) {
						if (!Base.equals(obj1[length], obj2[length]))
							return false;
					}
				} else {
					var keys = Object.keys(obj1),
						length = keys.length;
					if (length !== Object.keys(obj2).length)
						return false;
					while (length--) {
						var key = keys[length];
						if (!(obj2.hasOwnProperty(key)
								&& Base.equals(obj1[key], obj2[key])))
							return false;
					}
				}
				return true;
			}
			return false;
		},

		read: function(list, start, options, length) {
			if (this === Base) {
				var value = this.peek(list, start);
				list.__index++;
				return value;
			}
			var proto = this.prototype,
				readIndex = proto._readIndex,
				index = start || readIndex && list.__index || 0;
			if (!length)
				length = list.length - index;
			var obj = list[index];
			if (obj instanceof this
				|| options && options.readNull && obj == null && length <= 1) {
				if (readIndex)
					list.__index = index + 1;
				return obj && options && options.clone ? obj.clone() : obj;
			}
			obj = Base.create(this.prototype);
			if (readIndex)
				obj.__read = true;
			obj = obj.initialize.apply(obj, index > 0 || length < list.length
				? Array.prototype.slice.call(list, index, index + length)
				: list) || obj;
			if (readIndex) {
				list.__index = index + obj.__read;
				obj.__read = undefined;
			}
			return obj;
		},

		peek: function(list, start) {
			return list[list.__index = start || list.__index || 0];
		},

		remain: function(list) {
			return list.length - (list.__index || 0);
		},

		readAll: function(list, start, options) {
			var res = [],
				entry;
			for (var i = start || 0, l = list.length; i < l; i++) {
				res.push(Array.isArray(entry = list[i])
						? this.read(entry, 0, options)
						: this.read(list, i, options, 1));
			}
			return res;
		},

		readNamed: function(list, name, start, options, length) {
			var value = this.getNamed(list, name),
				hasObject = value !== undefined;
			if (hasObject) {
				var filtered = list._filtered;
				if (!filtered) {
					filtered = list._filtered = Base.create(list[0]);
					filtered._filtering = list[0];
				}
				filtered[name] = undefined;
			}
			return this.read(hasObject ? [value] : list, start, options, length);
		},

		getNamed: function(list, name) {
			var arg = list[0];
			if (list._hasObject === undefined)
				list._hasObject = list.length === 1 && Base.isPlainObject(arg);
			if (list._hasObject)
				return name ? arg[name] : list._filtered || arg;
		},

		hasNamed: function(list, name) {
			return !!this.getNamed(list, name);
		},

		isPlainValue: function(obj, asString) {
			return this.isPlainObject(obj) || Array.isArray(obj)
					|| asString && typeof obj === 'string';
		},

		serialize: function(obj, options, compact, dictionary) {
			options = options || {};

			var root = !dictionary,
				res;
			if (root) {
				options.formatter = new Formatter(options.precision);
				dictionary = {
					length: 0,
					definitions: {},
					references: {},
					add: function(item, create) {
						var id = '#' + item._id,
							ref = this.references[id];
						if (!ref) {
							this.length++;
							var res = create.call(item),
								name = item._class;
							if (name && res[0] !== name)
								res.unshift(name);
							this.definitions[id] = res;
							ref = this.references[id] = [id];
						}
						return ref;
					}
				};
			}
			if (obj && obj._serialize) {
				res = obj._serialize(options, dictionary);
				var name = obj._class;
				if (name && !compact && !res._compact && res[0] !== name)
					res.unshift(name);
			} else if (Array.isArray(obj)) {
				res = [];
				for (var i = 0, l = obj.length; i < l; i++)
					res[i] = Base.serialize(obj[i], options, compact,
							dictionary);
				if (compact)
					res._compact = true;
			} else if (Base.isPlainObject(obj)) {
				res = {};
				var keys = Object.keys(obj);
				for (var i = 0, l = keys.length; i < l; i++) {
					var key = keys[i];
					res[key] = Base.serialize(obj[key], options, compact,
							dictionary);
				}
			} else if (typeof obj === 'number') {
				res = options.formatter.number(obj, options.precision);
			} else {
				res = obj;
			}
			return root && dictionary.length > 0
					? [['dictionary', dictionary.definitions], res]
					: res;
		},

		deserialize: function(json, create, _data, _isDictionary) {
			var res = json,
				isRoot = !_data;
			_data = _data || {};
			if (Array.isArray(json)) {
				var type = json[0],
					isDictionary = type === 'dictionary';
				if (json.length == 1 && /^#/.test(type))
					return _data.dictionary[type];
				type = Base.exports[type];
				res = [];
				if (_isDictionary)
					_data.dictionary = res;
				for (var i = type ? 1 : 0, l = json.length; i < l; i++)
					res.push(Base.deserialize(json[i], create, _data,
							isDictionary));
				if (type) {
					var args = res;
					if (create) {
						res = create(type, args);
					} else {
						res = Base.create(type.prototype);
						type.apply(res, args);
					}
				}
			} else if (Base.isPlainObject(json)) {
				res = {};
				if (_isDictionary)
					_data.dictionary = res;
				for (var key in json)
					res[key] = Base.deserialize(json[key], create, _data);
			}
			return isRoot && json && json.length && json[0][0] === 'dictionary'
					? res[1]
					: res;
		},

		exportJSON: function(obj, options) {
			var json = Base.serialize(obj, options);
			return options && options.asString === false
					? json
					: JSON.stringify(json);
		},

		importJSON: function(json, target) {
			return Base.deserialize(
					typeof json === 'string' ? JSON.parse(json) : json,
					function(type, args) {
						var obj = target && target.constructor === type
								? target
								: Base.create(type.prototype),
							isTarget = obj === target;
						if (args.length === 1 && obj instanceof Item
								&& (isTarget || !(obj instanceof Layer))) {
							var arg = args[0];
							if (Base.isPlainObject(arg))
								arg.insert = false;
						}
						type.apply(obj, args);
						if (isTarget)
							target = null;
						return obj;
					});
		},

		splice: function(list, items, index, remove) {
			var amount = items && items.length,
				append = index === undefined;
			index = append ? list.length : index;
			if (index > list.length)
				index = list.length;
			for (var i = 0; i < amount; i++)
				items[i]._index = index + i;
			if (append) {
				list.push.apply(list, items);
				return [];
			} else {
				var args = [index, remove];
				if (items)
					args.push.apply(args, items);
				var removed = list.splice.apply(list, args);
				for (var i = 0, l = removed.length; i < l; i++)
					removed[i]._index = undefined;
				for (var i = index + amount, l = list.length; i < l; i++)
					list[i]._index = i;
				return removed;
			}
		},

		capitalize: function(str) {
			return str.replace(/\b[a-z]/g, function(match) {
				return match.toUpperCase();
			});
		},

		camelize: function(str) {
			return str.replace(/-(.)/g, function(all, chr) {
				return chr.toUpperCase();
			});
		},

		hyphenate: function(str) {
			return str.replace(/([a-z])([A-Z])/g, '$1-$2').toLowerCase();
		}
	}
});

var Emitter = {
	on: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.on(key, value);
			}, this);
		} else {
			var types = this._eventTypes,
				entry = types && types[type],
				handlers = this._callbacks = this._callbacks || {};
			handlers = handlers[type] = handlers[type] || [];
			if (handlers.indexOf(func) === -1) {
				handlers.push(func);
				if (entry && entry.install && handlers.length === 1)
					entry.install.call(this, type);
			}
		}
		return this;
	},

	off: function(type, func) {
		if (typeof type !== 'string') {
			Base.each(type, function(value, key) {
				this.off(key, value);
			}, this);
			return;
		}
		var types = this._eventTypes,
			entry = types && types[type],
			handlers = this._callbacks && this._callbacks[type],
			index;
		if (handlers) {
			if (!func || (index = handlers.indexOf(func)) !== -1
					&& handlers.length === 1) {
				if (entry && entry.uninstall)
					entry.uninstall.call(this, type);
				delete this._callbacks[type];
			} else if (index !== -1) {
				handlers.splice(index, 1);
			}
		}
		return this;
	},

	once: function(type, func) {
		return this.on(type, function() {
			func.apply(this, arguments);
			this.off(type, func);
		});
	},

	emit: function(type, event) {
		var handlers = this._callbacks && this._callbacks[type];
		if (!handlers)
			return false;
		var args = [].slice.call(arguments, 1);
		handlers = handlers.slice();
		for (var i = 0, l = handlers.length; i < l; i++) {
			if (handlers[i].apply(this, args) === false) {
				if (event && event.stop)
					event.stop();
				break;
			}
		}
		return true;
	},

	responds: function(type) {
		return !!(this._callbacks && this._callbacks[type]);
	},

	attach: '#on',
	detach: '#off',
	fire: '#emit',

	_installEvents: function(install) {
		var handlers = this._callbacks,
			key = install ? 'install' : 'uninstall';
		for (var type in handlers) {
			if (handlers[type].length > 0) {
				var types = this._eventTypes,
					entry = types && types[type],
					func = entry && entry[key];
				if (func)
					func.call(this, type);
			}
		}
	},

	statics: {
		inject: function inject(src) {
			var events = src._events;
			if (events) {
				var types = {};
				Base.each(events, function(entry, key) {
					var isString = typeof entry === 'string',
						name = isString ? entry : key,
						part = Base.capitalize(name),
						type = name.substring(2).toLowerCase();
					types[type] = isString ? {} : entry;
					name = '_' + name;
					src['get' + part] = function() {
						return this[name];
					};
					src['set' + part] = function(func) {
						var prev = this[name];
						if (prev)
							this.off(type, prev);
						if (func)
							this.on(type, func);
						this[name] = func;
					};
				});
				src._eventTypes = types;
			}
			return inject.base.apply(this, arguments);
		}
	}
};

var PaperScope = Base.extend({
	_class: 'PaperScope',

	initialize: function PaperScope() {
		paper = this;
		this.settings = new Base({
			applyMatrix: true,
			handleSize: 4,
			hitTolerance: 0
		});
		this.project = null;
		this.projects = [];
		this.tools = [];
		this.palettes = [];
		this._id = PaperScope._id++;
		PaperScope._scopes[this._id] = this;
		var proto = PaperScope.prototype;
		if (!this.support) {
			var ctx = CanvasProvider.getContext(1, 1);
			proto.support = {
				nativeDash: 'setLineDash' in ctx || 'mozDash' in ctx,
				nativeBlendModes: BlendMode.nativeModes
			};
			CanvasProvider.release(ctx);
		}

		if (!this.browser) {
			var agent = navigator.userAgent.toLowerCase(),
				platform = (/(win)/.exec(agent)
						|| /(mac)/.exec(agent)
						|| /(linux)/.exec(agent)
						|| [])[0],
				browser = proto.browser = { platform: platform };
			if (platform)
				browser[platform] = true;
			agent.replace(
				/(opera|chrome|safari|webkit|firefox|msie|trident|atom)\/?\s*([.\d]+)(?:.*version\/([.\d]+))?(?:.*rv\:([.\d]+))?/g,
				function(all, n, v1, v2, rv) {
					if (!browser.chrome) {
						var v = n === 'opera' ? v2 : v1;
						if (n === 'trident') {
							v = rv;
							n = 'msie';
						}
						browser.version = v;
						browser.versionNumber = parseFloat(v);
						browser.name = n;
						browser[n] = true;
					}
				}
			);
			if (browser.chrome)
				delete browser.webkit;
			if (browser.atom)
				delete browser.chrome;
		}
	},

	version: "0.9.25",

	getView: function() {
		return this.project && this.project.getView();
	},

	getPaper: function() {
		return this;
	},

	execute: function(code, url, options) {
		paper.PaperScript.execute(code, this, url, options);
		View.updateFocus();
	},

	install: function(scope) {
		var that = this;
		Base.each(['project', 'view', 'tool'], function(key) {
			Base.define(scope, key, {
				configurable: true,
				get: function() {
					return that[key];
				}
			});
		});
		for (var key in this)
			if (!/^_/.test(key) && this[key])
				scope[key] = this[key];
	},

	setup: function(element) {
		paper = this;
		this.project = new Project(element);
		return this;
	},

	activate: function() {
		paper = this;
	},

	clear: function() {
		for (var i = this.projects.length - 1; i >= 0; i--)
			this.projects[i].remove();
		for (var i = this.tools.length - 1; i >= 0; i--)
			this.tools[i].remove();
		for (var i = this.palettes.length - 1; i >= 0; i--)
			this.palettes[i].remove();
	},

	remove: function() {
		this.clear();
		delete PaperScope._scopes[this._id];
	},

	statics: new function() {
		function handleAttribute(name) {
			name += 'Attribute';
			return function(el, attr) {
				return el[name](attr) || el[name]('data-paper-' + attr);
			};
		}

		return {
			_scopes: {},
			_id: 0,

			get: function(id) {
				return this._scopes[id] || null;
			},

			getAttribute: handleAttribute('get'),
			hasAttribute: handleAttribute('has')
		};
	}
});

var PaperScopeItem = Base.extend(Emitter, {

	initialize: function(activate) {
		this._scope = paper;
		this._index = this._scope[this._list].push(this) - 1;
		if (activate || !this._scope[this._reference])
			this.activate();
	},

	activate: function() {
		if (!this._scope)
			return false;
		var prev = this._scope[this._reference];
		if (prev && prev !== this)
			prev.emit('deactivate');
		this._scope[this._reference] = this;
		this.emit('activate', prev);
		return true;
	},

	isActive: function() {
		return this._scope[this._reference] === this;
	},

	remove: function() {
		if (this._index == null)
			return false;
		Base.splice(this._scope[this._list], null, this._index, 1);
		if (this._scope[this._reference] == this)
			this._scope[this._reference] = null;
		this._scope = null;
		return true;
	}
});

var Formatter = Base.extend({
	initialize: function(precision) {
		this.precision = precision || 5;
		this.multiplier = Math.pow(10, this.precision);
	},

	number: function(val) {
		return Math.round(val * this.multiplier) / this.multiplier;
	},

	pair: function(val1, val2, separator) {
		return this.number(val1) + (separator || ',') + this.number(val2);
	},

	point: function(val, separator) {
		return this.number(val.x) + (separator || ',') + this.number(val.y);
	},

	size: function(val, separator) {
		return this.number(val.width) + (separator || ',')
				+ this.number(val.height);
	},

	rectangle: function(val, separator) {
		return this.point(val, separator) + (separator || ',')
				+ this.size(val, separator);
	}
});

Formatter.instance = new Formatter();

var Numerical = new function() {

	var abscissas = [
		[  0.5773502691896257645091488],
		[0,0.7745966692414833770358531],
		[  0.3399810435848562648026658,0.8611363115940525752239465],
		[0,0.5384693101056830910363144,0.9061798459386639927976269],
		[  0.2386191860831969086305017,0.6612093864662645136613996,0.9324695142031520278123016],
		[0,0.4058451513773971669066064,0.7415311855993944398638648,0.9491079123427585245261897],
		[  0.1834346424956498049394761,0.5255324099163289858177390,0.7966664774136267395915539,0.9602898564975362316835609],
		[0,0.3242534234038089290385380,0.6133714327005903973087020,0.8360311073266357942994298,0.9681602395076260898355762],
		[  0.1488743389816312108848260,0.4333953941292471907992659,0.6794095682990244062343274,0.8650633666889845107320967,0.9739065285171717200779640],
		[0,0.2695431559523449723315320,0.5190961292068118159257257,0.7301520055740493240934163,0.8870625997680952990751578,0.9782286581460569928039380],
		[  0.1252334085114689154724414,0.3678314989981801937526915,0.5873179542866174472967024,0.7699026741943046870368938,0.9041172563704748566784659,0.9815606342467192506905491],
		[0,0.2304583159551347940655281,0.4484927510364468528779129,0.6423493394403402206439846,0.8015780907333099127942065,0.9175983992229779652065478,0.9841830547185881494728294],
		[  0.1080549487073436620662447,0.3191123689278897604356718,0.5152486363581540919652907,0.6872929048116854701480198,0.8272013150697649931897947,0.9284348836635735173363911,0.9862838086968123388415973],
		[0,0.2011940939974345223006283,0.3941513470775633698972074,0.5709721726085388475372267,0.7244177313601700474161861,0.8482065834104272162006483,0.9372733924007059043077589,0.9879925180204854284895657],
		[  0.0950125098376374401853193,0.2816035507792589132304605,0.4580167776572273863424194,0.6178762444026437484466718,0.7554044083550030338951012,0.8656312023878317438804679,0.9445750230732325760779884,0.9894009349916499325961542]
	];

	var weights = [
		[1],
		[0.8888888888888888888888889,0.5555555555555555555555556],
		[0.6521451548625461426269361,0.3478548451374538573730639],
		[0.5688888888888888888888889,0.4786286704993664680412915,0.2369268850561890875142640],
		[0.4679139345726910473898703,0.3607615730481386075698335,0.1713244923791703450402961],
		[0.4179591836734693877551020,0.3818300505051189449503698,0.2797053914892766679014678,0.1294849661688696932706114],
		[0.3626837833783619829651504,0.3137066458778872873379622,0.2223810344533744705443560,0.1012285362903762591525314],
		[0.3302393550012597631645251,0.3123470770400028400686304,0.2606106964029354623187429,0.1806481606948574040584720,0.0812743883615744119718922],
		[0.2955242247147528701738930,0.2692667193099963550912269,0.2190863625159820439955349,0.1494513491505805931457763,0.0666713443086881375935688],
		[0.2729250867779006307144835,0.2628045445102466621806889,0.2331937645919904799185237,0.1862902109277342514260976,0.1255803694649046246346943,0.0556685671161736664827537],
		[0.2491470458134027850005624,0.2334925365383548087608499,0.2031674267230659217490645,0.1600783285433462263346525,0.1069393259953184309602547,0.0471753363865118271946160],
		[0.2325515532308739101945895,0.2262831802628972384120902,0.2078160475368885023125232,0.1781459807619457382800467,0.1388735102197872384636018,0.0921214998377284479144218,0.0404840047653158795200216],
		[0.2152638534631577901958764,0.2051984637212956039659241,0.1855383974779378137417166,0.1572031671581935345696019,0.1215185706879031846894148,0.0801580871597602098056333,0.0351194603317518630318329],
		[0.2025782419255612728806202,0.1984314853271115764561183,0.1861610000155622110268006,0.1662692058169939335532009,0.1395706779261543144478048,0.1071592204671719350118695,0.0703660474881081247092674,0.0307532419961172683546284],
		[0.1894506104550684962853967,0.1826034150449235888667637,0.1691565193950025381893121,0.1495959888165767320815017,0.1246289712555338720524763,0.0951585116824927848099251,0.0622535239386478928628438,0.0271524594117540948517806]
	];

	var abs = Math.abs,
		sqrt = Math.sqrt,
		pow = Math.pow,
		EPSILON = 1e-12,
		MACHINE_EPSILON = 1.12e-16;

	function clip(value, min, max) {
		return value < min ? min : value > max ? max : value;
	}

	return {
		TOLERANCE: 1e-6,
		EPSILON: EPSILON,
		MACHINE_EPSILON: MACHINE_EPSILON,
		CURVETIME_EPSILON: 4e-7,
		GEOMETRIC_EPSILON: 2e-7,
		WINDING_EPSILON: 2e-7,
		TRIGONOMETRIC_EPSILON: 1e-7,
		CLIPPING_EPSILON: 1e-7,
		KAPPA: 4 * (sqrt(2) - 1) / 3,

		isZero: function(val) {
			return val >= -EPSILON && val <= EPSILON;
		},

		integrate: function(f, a, b, n) {
			var x = abscissas[n - 2],
				w = weights[n - 2],
				A = (b - a) * 0.5,
				B = A + a,
				i = 0,
				m = (n + 1) >> 1,
				sum = n & 1 ? w[i++] * f(B) : 0;
			while (i < m) {
				var Ax = A * x[i];
				sum += w[i++] * (f(B + Ax) + f(B - Ax));
			}
			return A * sum;
		},

		findRoot: function(f, df, x, a, b, n, tolerance) {
			for (var i = 0; i < n; i++) {
				var fx = f(x),
					dx = fx / df(x),
					nx = x - dx;
				if (abs(dx) < tolerance)
					return nx;
				if (fx > 0) {
					b = x;
					x = nx <= a ? (a + b) * 0.5 : nx;
				} else {
					a = x;
					x = nx >= b ? (a + b) * 0.5 : nx;
				}
			}
			return x;
		},

		solveQuadratic: function(a, b, c, roots, min, max) {
			var count = 0,
				eMin = min - EPSILON,
				eMax = max + EPSILON,
				x1, x2 = Infinity,
				B = b,
				D;
			b /= -2;
			D = b * b - a * c;
			if (D !== 0 && abs(D) < MACHINE_EPSILON) {
				var gmC = pow(abs(a * b * c), 1 / 3);
				if (gmC < 1e-8) {
					var mult = pow(10,
							abs(Math.floor(Math.log(gmC) * Math.LOG10E)));
					if (!isFinite(mult))
						mult = 0;
					a *= mult;
					b *= mult;
					c *= mult;
					D = b * b - a * c;
				}
			}
			if (abs(a) < EPSILON) {
				if (abs(B) < EPSILON)
					return abs(c) < EPSILON ? -1 : 0;
				x1 = -c / B;
			} else if (D >= -MACHINE_EPSILON) {
				var Q = D < 0 ? 0 : sqrt(D),
					R = b + (b < 0 ? -Q : Q);
				if (R === 0) {
					x1 = c / a;
					x2 = -x1;
				} else {
					x1 = R / a;
					x2 = c / R;
				}
			}
			if (isFinite(x1) && (min == null || x1 > eMin && x1 < eMax))
				roots[count++] = min == null ? x1 : clip(x1, min, max);
			if (x2 !== x1
					&& isFinite(x2) && (min == null || x2 > eMin && x2 < eMax))
				roots[count++] = min == null ? x2 : clip(x2, min, max);
			return count;
		},

		solveCubic: function(a, b, c, d, roots, min, max) {
			var count = 0,
				x, b1, c2;
			if (abs(a) < EPSILON) {
				a = b;
				b1 = c;
				c2 = d;
				x = Infinity;
			} else if (abs(d) < EPSILON) {
				b1 = b;
				c2 = c;
				x = 0;
			} else {
				var ec = 1 + MACHINE_EPSILON,
					x0, q, qd, t, r, s, tmp;
				x = -(b / a) / 3;
				tmp = a * x,
				b1 = tmp + b,
				c2 = b1 * x + c,
				qd = (tmp + b1) * x + c2,
				q = c2 * x + d;
				t = q /a;
				r = pow(abs(t), 1/3);
				s = t < 0 ? -1 : 1;
				t = -qd / a;
				r = t > 0 ? 1.3247179572 * Math.max(r, sqrt(t)) : r;
				x0 = x - s * r;
				if (x0 !== x) {
					do {
						x = x0;
						tmp = a * x,
						b1 = tmp + b,
						c2 = b1 * x + c,
						qd = (tmp + b1) * x + c2,
						q = c2 * x + d;
						x0 = qd === 0 ? x : x - q / qd / ec;
						if (x0 === x) {
							x = x0;
							break;
						}
					} while (s * x0 > s * x);
					if (abs(a) * x * x > abs(d / x)) {
						c2 = -d / x;
						b1 = (c2 - c) / x;
					}
				}
			}
			var count = Numerical.solveQuadratic(a, b1, c2, roots, min, max);
			if (isFinite(x) && (count === 0 || x !== roots[count - 1])
					&& (min == null || x > min - EPSILON && x < max + EPSILON))
				roots[count++] = min == null ? x : clip(x, min, max);
			return count;
		}
	};
};

var UID = {
	_id: 1,
	_pools: {},

	get: function(ctor) {
		if (ctor) {
			var name = ctor._class,
				pool = this._pools[name];
			if (!pool)
				pool = this._pools[name] = { _id: 1 };
			return pool._id++;
		} else {
			return this._id++;
		}
	}
};

var Point = Base.extend({
	_class: 'Point',
	_readIndex: true,

	initialize: function Point(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasY = typeof arg1 === 'number';
			this.x = arg0;
			this.y = hasY ? arg1 : arg0;
			if (this.__read)
				this.__read = hasY ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.x != null) {
				this.x = arg0.x;
				this.y = arg0.y;
			} else if (arg0.width != null) {
				this.x = arg0.width;
				this.y = arg0.height;
			} else if (arg0.angle != null) {
				this.x = arg0.length;
				this.y = 0;
				this.setAngle(arg0.angle);
			} else {
				this.x = this.y = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(x, y) {
		this.x = x;
		this.y = y;
		return this;
	},

	equals: function(point) {
		return this === point || point
				&& (this.x === point.x && this.y === point.y
					|| Array.isArray(point)
						&& this.x === point[0] && this.y === point[1])
				|| false;
	},

	clone: function() {
		return new Point(this.x, this.y);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x) + ', y: ' + f.number(this.y) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x), f.number(this.y)];
	},

	getLength: function() {
		return Math.sqrt(this.x * this.x + this.y * this.y);
	},

	setLength: function(length) {
		if (this.isZero()) {
			var angle = this._angle || 0;
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		} else {
			var scale = length / this.getLength();
			if (Numerical.isZero(scale))
				this.getAngle();
			this.set(
				this.x * scale,
				this.y * scale
			);
		}
	},
	getAngle: function() {
		return this.getAngleInRadians.apply(this, arguments) * 180 / Math.PI;
	},

	setAngle: function(angle) {
		this.setAngleInRadians.call(this, angle * Math.PI / 180);
	},

	getAngleInDegrees: '#getAngle',
	setAngleInDegrees: '#setAngle',

	getAngleInRadians: function() {
		if (!arguments.length) {
			return this.isZero()
					? this._angle || 0
					: this._angle = Math.atan2(this.y, this.x);
		} else {
			var point = Point.read(arguments),
				div = this.getLength() * point.getLength();
			if (Numerical.isZero(div)) {
				return NaN;
			} else {
				var a = this.dot(point) / div;
				return Math.acos(a < -1 ? -1 : a > 1 ? 1 : a);
			}
		}
	},

	setAngleInRadians: function(angle) {
		this._angle = angle;
		if (!this.isZero()) {
			var length = this.getLength();
			this.set(
				Math.cos(angle) * length,
				Math.sin(angle) * length
			);
		}
	},

	getQuadrant: function() {
		return this.x >= 0 ? this.y >= 0 ? 1 : 4 : this.y >= 0 ? 2 : 3;
	}
}, {
	beans: false,

	getDirectedAngle: function() {
		var point = Point.read(arguments);
		return Math.atan2(this.cross(point), this.dot(point)) * 180 / Math.PI;
	},

	getDistance: function() {
		var point = Point.read(arguments),
			x = point.x - this.x,
			y = point.y - this.y,
			d = x * x + y * y,
			squared = Base.read(arguments);
		return squared ? d : Math.sqrt(d);
	},

	normalize: function(length) {
		if (length === undefined)
			length = 1;
		var current = this.getLength(),
			scale = current !== 0 ? length / current : 0,
			point = new Point(this.x * scale, this.y * scale);
		if (scale >= 0)
			point._angle = this._angle;
		return point;
	},

	rotate: function(angle, center) {
		if (angle === 0)
			return this.clone();
		angle = angle * Math.PI / 180;
		var point = center ? this.subtract(center) : this,
			sin = Math.sin(angle),
			cos = Math.cos(angle);
		point = new Point(
			point.x * cos - point.y * sin,
			point.x * sin + point.y * cos
		);
		return center ? point.add(center) : point;
	},

	transform: function(matrix) {
		return matrix ? matrix._transformPoint(this) : this;
	},

	add: function() {
		var point = Point.read(arguments);
		return new Point(this.x + point.x, this.y + point.y);
	},

	subtract: function() {
		var point = Point.read(arguments);
		return new Point(this.x - point.x, this.y - point.y);
	},

	multiply: function() {
		var point = Point.read(arguments);
		return new Point(this.x * point.x, this.y * point.y);
	},

	divide: function() {
		var point = Point.read(arguments);
		return new Point(this.x / point.x, this.y / point.y);
	},

	modulo: function() {
		var point = Point.read(arguments);
		return new Point(this.x % point.x, this.y % point.y);
	},

	negate: function() {
		return new Point(-this.x, -this.y);
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this);
	},

	isClose: function() {
		var point = Point.read(arguments),
			tolerance = Base.read(arguments);
		return this.getDistance(point) < tolerance;
	},

	isCollinear: function() {
		var point = Point.read(arguments);
		return Point.isCollinear(this.x, this.y, point.x, point.y);
	},

	isColinear: '#isCollinear',

	isOrthogonal: function() {
		var point = Point.read(arguments);
		return Point.isOrthogonal(this.x, this.y, point.x, point.y);
	},

	isZero: function() {
		return Numerical.isZero(this.x) && Numerical.isZero(this.y);
	},

	isNaN: function() {
		return isNaN(this.x) || isNaN(this.y);
	},

	dot: function() {
		var point = Point.read(arguments);
		return this.x * point.x + this.y * point.y;
	},

	cross: function() {
		var point = Point.read(arguments);
		return this.x * point.y - this.y * point.x;
	},

	project: function() {
		var point = Point.read(arguments),
			scale = point.isZero() ? 0 : this.dot(point) / point.dot(point);
		return new Point(
			point.x * scale,
			point.y * scale
		);
	},

	statics: {
		min: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.min(point1.x, point2.x),
				Math.min(point1.y, point2.y)
			);
		},

		max: function() {
			var point1 = Point.read(arguments),
				point2 = Point.read(arguments);
			return new Point(
				Math.max(point1.x, point2.x),
				Math.max(point1.y, point2.y)
			);
		},

		random: function() {
			return new Point(Math.random(), Math.random());
		},

		isCollinear: function(x1, y1, x2, y2) {
			return Math.abs(x1 * y2 - y1 * x2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-7;
		},

		isOrthogonal: function(x1, y1, x2, y2) {
			return Math.abs(x1 * x2 + y1 * y2)
					<= Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
						* 1e-7;
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Point(op(this.x), op(this.y));
	};
}, {}));

var LinkedPoint = Point.extend({
	initialize: function Point(x, y, owner, setter) {
		this._x = x;
		this._y = y;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, _dontNotify) {
		this._x = x;
		this._y = y;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner[this._setter](this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner[this._setter](this);
	}
});

var Size = Base.extend({
	_class: 'Size',
	_readIndex: true,

	initialize: function Size(arg0, arg1) {
		var type = typeof arg0;
		if (type === 'number') {
			var hasHeight = typeof arg1 === 'number';
			this.width = arg0;
			this.height = hasHeight ? arg1 : arg0;
			if (this.__read)
				this.__read = hasHeight ? 2 : 1;
		} else if (type === 'undefined' || arg0 === null) {
			this.width = this.height = 0;
			if (this.__read)
				this.__read = arg0 === null ? 1 : 0;
		} else {
			if (Array.isArray(arg0)) {
				this.width = arg0[0];
				this.height = arg0.length > 1 ? arg0[1] : arg0[0];
			} else if (arg0.width != null) {
				this.width = arg0.width;
				this.height = arg0.height;
			} else if (arg0.x != null) {
				this.width = arg0.x;
				this.height = arg0.y;
			} else {
				this.width = this.height = 0;
				if (this.__read)
					this.__read = 0;
			}
			if (this.__read)
				this.__read = 1;
		}
	},

	set: function(width, height) {
		this.width = width;
		this.height = height;
		return this;
	},

	equals: function(size) {
		return size === this || size && (this.width === size.width
				&& this.height === size.height
				|| Array.isArray(size) && this.width === size[0]
					&& this.height === size[1]) || false;
	},

	clone: function() {
		return new Size(this.width, this.height);
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height) + ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.width),
				f.number(this.height)];
	},

	add: function() {
		var size = Size.read(arguments);
		return new Size(this.width + size.width, this.height + size.height);
	},

	subtract: function() {
		var size = Size.read(arguments);
		return new Size(this.width - size.width, this.height - size.height);
	},

	multiply: function() {
		var size = Size.read(arguments);
		return new Size(this.width * size.width, this.height * size.height);
	},

	divide: function() {
		var size = Size.read(arguments);
		return new Size(this.width / size.width, this.height / size.height);
	},

	modulo: function() {
		var size = Size.read(arguments);
		return new Size(this.width % size.width, this.height % size.height);
	},

	negate: function() {
		return new Size(-this.width, -this.height);
	},

	isZero: function() {
		return Numerical.isZero(this.width) && Numerical.isZero(this.height);
	},

	isNaN: function() {
		return isNaN(this.width) || isNaN(this.height);
	},

	statics: {
		min: function(size1, size2) {
			return new Size(
				Math.min(size1.width, size2.width),
				Math.min(size1.height, size2.height));
		},

		max: function(size1, size2) {
			return new Size(
				Math.max(size1.width, size2.width),
				Math.max(size1.height, size2.height));
		},

		random: function() {
			return new Size(Math.random(), Math.random());
		}
	}
}, Base.each(['round', 'ceil', 'floor', 'abs'], function(name) {
	var op = Math[name];
	this[name] = function() {
		return new Size(op(this.width), op(this.height));
	};
}, {}));

var LinkedSize = Size.extend({
	initialize: function Size(width, height, owner, setter) {
		this._width = width;
		this._height = height;
		this._owner = owner;
		this._setter = setter;
	},

	set: function(width, height, _dontNotify) {
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	},

	getWidth: function() {
		return this._width;
	},

	setWidth: function(width) {
		this._width = width;
		this._owner[this._setter](this);
	},

	getHeight: function() {
		return this._height;
	},

	setHeight: function(height) {
		this._height = height;
		this._owner[this._setter](this);
	}
});

var Rectangle = Base.extend({
	_class: 'Rectangle',
	_readIndex: true,
	beans: true,

	initialize: function Rectangle(arg0, arg1, arg2, arg3) {
		var type = typeof arg0,
			read = 0;
		if (type === 'number') {
			this.x = arg0;
			this.y = arg1;
			this.width = arg2;
			this.height = arg3;
			read = 4;
		} else if (type === 'undefined' || arg0 === null) {
			this.x = this.y = this.width = this.height = 0;
			read = arg0 === null ? 1 : 0;
		} else if (arguments.length === 1) {
			if (Array.isArray(arg0)) {
				this.x = arg0[0];
				this.y = arg0[1];
				this.width = arg0[2];
				this.height = arg0[3];
				read = 1;
			} else if (arg0.x !== undefined || arg0.width !== undefined) {
				this.x = arg0.x || 0;
				this.y = arg0.y || 0;
				this.width = arg0.width || 0;
				this.height = arg0.height || 0;
				read = 1;
			} else if (arg0.from === undefined && arg0.to === undefined) {
				this.x = this.y = this.width = this.height = 0;
				this._set(arg0);
				read = 1;
			}
		}
		if (!read) {
			var point = Point.readNamed(arguments, 'from'),
				next = Base.peek(arguments);
			this.x = point.x;
			this.y = point.y;
			if (next && next.x !== undefined || Base.hasNamed(arguments, 'to')) {
				var to = Point.readNamed(arguments, 'to');
				this.width = to.x - point.x;
				this.height = to.y - point.y;
				if (this.width < 0) {
					this.x = to.x;
					this.width = -this.width;
				}
				if (this.height < 0) {
					this.y = to.y;
					this.height = -this.height;
				}
			} else {
				var size = Size.read(arguments);
				this.width = size.width;
				this.height = size.height;
			}
			read = arguments.__index;
		}
		if (this.__read)
			this.__read = read;
	},

	set: function(x, y, width, height) {
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;
		return this;
	},

	clone: function() {
		return new Rectangle(this.x, this.y, this.width, this.height);
	},

	equals: function(rect) {
		var rt = Base.isPlainValue(rect)
				? Rectangle.read(arguments)
				: rect;
		return rt === this
				|| rt && this.x === rt.x && this.y === rt.y
					&& this.width === rt.width && this.height === rt.height
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '{ x: ' + f.number(this.x)
				+ ', y: ' + f.number(this.y)
				+ ', width: ' + f.number(this.width)
				+ ', height: ' + f.number(this.height)
				+ ' }';
	},

	_serialize: function(options) {
		var f = options.formatter;
		return [f.number(this.x),
				f.number(this.y),
				f.number(this.width),
				f.number(this.height)];
	},

	getPoint: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.x, this.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.x = point.x;
		this.y = point.y;
	},

	getSize: function(_dontLink) {
		var ctor = _dontLink ? Size : LinkedSize;
		return new ctor(this.width, this.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (this._fixX)
			this.x += (this.width - size.width) * this._fixX;
		if (this._fixY)
			this.y += (this.height - size.height) * this._fixY;
		this.width = size.width;
		this.height = size.height;
		this._fixW = 1;
		this._fixH = 1;
	},

	getLeft: function() {
		return this.x;
	},

	setLeft: function(left) {
		if (!this._fixW)
			this.width -= left - this.x;
		this.x = left;
		this._fixX = 0;
	},

	getTop: function() {
		return this.y;
	},

	setTop: function(top) {
		if (!this._fixH)
			this.height -= top - this.y;
		this.y = top;
		this._fixY = 0;
	},

	getRight: function() {
		return this.x + this.width;
	},

	setRight: function(right) {
		if (this._fixX !== undefined && this._fixX !== 1)
			this._fixW = 0;
		if (this._fixW)
			this.x = right - this.width;
		else
			this.width = right - this.x;
		this._fixX = 1;
	},

	getBottom: function() {
		return this.y + this.height;
	},

	setBottom: function(bottom) {
		if (this._fixY !== undefined && this._fixY !== 1)
			this._fixH = 0;
		if (this._fixH)
			this.y = bottom - this.height;
		else
			this.height = bottom - this.y;
		this._fixY = 1;
	},

	getCenterX: function() {
		return this.x + this.width * 0.5;
	},

	setCenterX: function(x) {
		this.x = x - this.width * 0.5;
		this._fixX = 0.5;
	},

	getCenterY: function() {
		return this.y + this.height * 0.5;
	},

	setCenterY: function(y) {
		this.y = y - this.height * 0.5;
		this._fixY = 0.5;
	},

	getCenter: function(_dontLink) {
		var ctor = _dontLink ? Point : LinkedPoint;
		return new ctor(this.getCenterX(), this.getCenterY(), this, 'setCenter');
	},

	setCenter: function() {
		var point = Point.read(arguments);
		this.setCenterX(point.x);
		this.setCenterY(point.y);
		return this;
	},

	getArea: function() {
		return this.width * this.height;
	},

	isEmpty: function() {
		return this.width === 0 || this.height === 0;
	},

	contains: function(arg) {
		return arg && arg.width !== undefined
				|| (Array.isArray(arg) ? arg : arguments).length == 4
				? this._containsRectangle(Rectangle.read(arguments))
				: this._containsPoint(Point.read(arguments));
	},

	_containsPoint: function(point) {
		var x = point.x,
			y = point.y;
		return x >= this.x && y >= this.y
				&& x <= this.x + this.width
				&& y <= this.y + this.height;
	},

	_containsRectangle: function(rect) {
		var x = rect.x,
			y = rect.y;
		return x >= this.x && y >= this.y
				&& x + rect.width <= this.x + this.width
				&& y + rect.height <= this.y + this.height;
	},

	intersects: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width > this.x
				&& rect.y + rect.height > this.y
				&& rect.x < this.x + this.width
				&& rect.y < this.y + this.height;
	},

	touches: function() {
		var rect = Rectangle.read(arguments);
		return rect.x + rect.width >= this.x
				&& rect.y + rect.height >= this.y
				&& rect.x <= this.x + this.width
				&& rect.y <= this.y + this.height;
	},

	intersect: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.max(this.x, rect.x),
			y1 = Math.max(this.y, rect.y),
			x2 = Math.min(this.x + this.width, rect.x + rect.width),
			y2 = Math.min(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	unite: function() {
		var rect = Rectangle.read(arguments),
			x1 = Math.min(this.x, rect.x),
			y1 = Math.min(this.y, rect.y),
			x2 = Math.max(this.x + this.width, rect.x + rect.width),
			y2 = Math.max(this.y + this.height, rect.y + rect.height);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	include: function() {
		var point = Point.read(arguments);
		var x1 = Math.min(this.x, point.x),
			y1 = Math.min(this.y, point.y),
			x2 = Math.max(this.x + this.width, point.x),
			y2 = Math.max(this.y + this.height, point.y);
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	expand: function() {
		var amount = Size.read(arguments),
			hor = amount.width,
			ver = amount.height;
		return new Rectangle(this.x - hor / 2, this.y - ver / 2,
				this.width + hor, this.height + ver);
	},

	scale: function(hor, ver) {
		return this.expand(this.width * hor - this.width,
				this.height * (ver === undefined ? hor : ver) - this.height);
	}
}, Base.each([
		['Top', 'Left'], ['Top', 'Right'],
		['Bottom', 'Left'], ['Bottom', 'Right'],
		['Left', 'Center'], ['Top', 'Center'],
		['Right', 'Center'], ['Bottom', 'Center']
	],
	function(parts, index) {
		var part = parts.join('');
		var xFirst = /^[RL]/.test(part);
		if (index >= 4)
			parts[1] += xFirst ? 'Y' : 'X';
		var x = parts[xFirst ? 0 : 1],
			y = parts[xFirst ? 1 : 0],
			getX = 'get' + x,
			getY = 'get' + y,
			setX = 'set' + x,
			setY = 'set' + y,
			get = 'get' + part,
			set = 'set' + part;
		this[get] = function(_dontLink) {
			var ctor = _dontLink ? Point : LinkedPoint;
			return new ctor(this[getX](), this[getY](), this, set);
		};
		this[set] = function() {
			var point = Point.read(arguments);
			this[setX](point.x);
			this[setY](point.y);
		};
	}, {
		beans: true
	}
));

var LinkedRectangle = Rectangle.extend({
	initialize: function Rectangle(x, y, width, height, owner, setter) {
		this.set(x, y, width, height, true);
		this._owner = owner;
		this._setter = setter;
	},

	set: function(x, y, width, height, _dontNotify) {
		this._x = x;
		this._y = y;
		this._width = width;
		this._height = height;
		if (!_dontNotify)
			this._owner[this._setter](this);
		return this;
	}
},
new function() {
	var proto = Rectangle.prototype;

	return Base.each(['x', 'y', 'width', 'height'], function(key) {
		var part = Base.capitalize(key);
		var internal = '_' + key;
		this['get' + part] = function() {
			return this[internal];
		};

		this['set' + part] = function(value) {
			this[internal] = value;
			if (!this._dontNotify)
				this._owner[this._setter](this);
		};
	}, Base.each(['Point', 'Size', 'Center',
			'Left', 'Top', 'Right', 'Bottom', 'CenterX', 'CenterY',
			'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
			'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'],
		function(key) {
			var name = 'set' + key;
			this[name] = function() {
				this._dontNotify = true;
				proto[name].apply(this, arguments);
				this._dontNotify = false;
				this._owner[this._setter](this);
			};
		}, {
			isSelected: function() {
				return this._owner._boundsSelected;
			},

			setSelected: function(selected) {
				var owner = this._owner;
				if (owner.setSelected) {
					owner._boundsSelected = selected;
					owner.setSelected(selected || owner._selectedSegmentState > 0);
				}
			}
		})
	);
});

var Matrix = Base.extend({
	_class: 'Matrix',

	initialize: function Matrix(arg) {
		var count = arguments.length,
			ok = true;
		if (count === 6) {
			this.set.apply(this, arguments);
		} else if (count === 1) {
			if (arg instanceof Matrix) {
				this.set(arg._a, arg._c, arg._b, arg._d, arg._tx, arg._ty);
			} else if (Array.isArray(arg)) {
				this.set.apply(this, arg);
			} else {
				ok = false;
			}
		} else if (count === 0) {
			this.reset();
		} else {
			ok = false;
		}
		if (!ok)
			throw new Error('Unsupported matrix parameters');
	},

	set: function(a, c, b, d, tx, ty, _dontNotify) {
		this._a = a;
		this._c = c;
		this._b = b;
		this._d = d;
		this._tx = tx;
		this._ty = ty;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	_serialize: function(options) {
		return Base.serialize(this.getValues(), options);
	},

	_changed: function() {
		var owner = this._owner;
		if (owner) {
			if (owner._applyMatrix) {
				owner.transform(null, true);
			} else {
				owner._changed(9);
			}
		}
	},

	clone: function() {
		return new Matrix(this._a, this._c, this._b, this._d,
				this._tx, this._ty);
	},

	equals: function(mx) {
		return mx === this || mx && this._a === mx._a && this._b === mx._b
				&& this._c === mx._c && this._d === mx._d
				&& this._tx === mx._tx && this._ty === mx._ty
				|| false;
	},

	toString: function() {
		var f = Formatter.instance;
		return '[[' + [f.number(this._a), f.number(this._b),
					f.number(this._tx)].join(', ') + '], ['
				+ [f.number(this._c), f.number(this._d),
					f.number(this._ty)].join(', ') + ']]';
	},

	reset: function(_dontNotify) {
		this._a = this._d = 1;
		this._c = this._b = this._tx = this._ty = 0;
		if (!_dontNotify)
			this._changed();
		return this;
	},

	apply: function(recursively, _setApplyMatrix) {
		var owner = this._owner;
		if (owner) {
			owner.transform(null, true, Base.pick(recursively, true),
					_setApplyMatrix);
			return this.isIdentity();
		}
		return false;
	},

	translate: function() {
		var point = Point.read(arguments),
			x = point.x,
			y = point.y;
		this._tx += x * this._a + y * this._b;
		this._ty += x * this._c + y * this._d;
		this._changed();
		return this;
	},

	scale: function() {
		var scale = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		this._a *= scale.x;
		this._c *= scale.x;
		this._b *= scale.y;
		this._d *= scale.y;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	rotate: function(angle ) {
		angle *= Math.PI / 180;
		var center = Point.read(arguments, 1),
			x = center.x,
			y = center.y,
			cos = Math.cos(angle),
			sin = Math.sin(angle),
			tx = x - x * cos + y * sin,
			ty = y - x * sin - y * cos,
			a = this._a,
			b = this._b,
			c = this._c,
			d = this._d;
		this._a = cos * a + sin * b;
		this._b = -sin * a + cos * b;
		this._c = cos * c + sin * d;
		this._d = -sin * c + cos * d;
		this._tx += tx * a + ty * b;
		this._ty += tx * c + ty * d;
		this._changed();
		return this;
	},

	shear: function() {
		var shear = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		if (center)
			this.translate(center);
		var a = this._a,
			c = this._c;
		this._a += shear.y * this._b;
		this._c += shear.y * this._d;
		this._b += shear.x * a;
		this._d += shear.x * c;
		if (center)
			this.translate(center.negate());
		this._changed();
		return this;
	},

	skew: function() {
		var skew = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true }),
			toRadians = Math.PI / 180,
			shear = new Point(Math.tan(skew.x * toRadians),
				Math.tan(skew.y * toRadians));
		return this.shear(shear, center);
	},

	concatenate: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		this._a = a2 * a1 + c2 * b1;
		this._b = b2 * a1 + d2 * b1;
		this._c = a2 * c1 + c2 * d1;
		this._d = b2 * c1 + d2 * d1;
		this._tx += tx2 * a1 + ty2 * b1;
		this._ty += tx2 * c1 + ty2 * d1;
		this._changed();
		return this;
	},

	preConcatenate: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			tx1 = this._tx,
			ty1 = this._ty,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		this._a = a2 * a1 + b2 * c1;
		this._b = a2 * b1 + b2 * d1;
		this._c = c2 * a1 + d2 * c1;
		this._d = c2 * b1 + d2 * d1;
		this._tx = a2 * tx1 + b2 * ty1 + tx2;
		this._ty = c2 * tx1 + d2 * ty1 + ty2;
		this._changed();
		return this;
	},

	chain: function(mx) {
		var a1 = this._a,
			b1 = this._b,
			c1 = this._c,
			d1 = this._d,
			tx1 = this._tx,
			ty1 = this._ty,
			a2 = mx._a,
			b2 = mx._b,
			c2 = mx._c,
			d2 = mx._d,
			tx2 = mx._tx,
			ty2 = mx._ty;
		return new Matrix(
				a2 * a1 + c2 * b1,
				a2 * c1 + c2 * d1,
				b2 * a1 + d2 * b1,
				b2 * c1 + d2 * d1,
				tx1 + tx2 * a1 + ty2 * b1,
				ty1 + tx2 * c1 + ty2 * d1);
	},

	isIdentity: function() {
		return this._a === 1 && this._c === 0 && this._b === 0 && this._d === 1
				&& this._tx === 0 && this._ty === 0;
	},

	orNullIfIdentity: function() {
		return this.isIdentity() ? null : this;
	},

	isInvertible: function() {
		return !!this._getDeterminant();
	},

	isSingular: function() {
		return !this._getDeterminant();
	},

	transform: function( src, dst, count) {
		return arguments.length < 3
			? this._transformPoint(Point.read(arguments))
			: this._transformCoordinates(src, dst, count);
	},

	_transformPoint: function(point, dest, _dontNotify) {
		var x = point.x,
			y = point.y;
		if (!dest)
			dest = new Point();
		return dest.set(
			x * this._a + y * this._b + this._tx,
			x * this._c + y * this._d + this._ty,
			_dontNotify
		);
	},

	_transformCoordinates: function(src, dst, count) {
		var i = 0,
			j = 0,
			max = 2 * count;
		while (i < max) {
			var x = src[i++],
				y = src[i++];
			dst[j++] = x * this._a + y * this._b + this._tx;
			dst[j++] = x * this._c + y * this._d + this._ty;
		}
		return dst;
	},

	_transformCorners: function(rect) {
		var x1 = rect.x,
			y1 = rect.y,
			x2 = x1 + rect.width,
			y2 = y1 + rect.height,
			coords = [ x1, y1, x2, y1, x2, y2, x1, y2 ];
		return this._transformCoordinates(coords, coords, 4);
	},

	_transformBounds: function(bounds, dest, _dontNotify) {
		var coords = this._transformCorners(bounds),
			min = coords.slice(0, 2),
			max = min.slice();
		for (var i = 2; i < 8; i++) {
			var val = coords[i],
				j = i & 1;
			if (val < min[j])
				min[j] = val;
			else if (val > max[j])
				max[j] = val;
		}
		if (!dest)
			dest = new Rectangle();
		return dest.set(min[0], min[1], max[0] - min[0], max[1] - min[1],
				_dontNotify);
	},

	inverseTransform: function() {
		return this._inverseTransform(Point.read(arguments));
	},

	_getDeterminant: function() {
		var det = this._a * this._d - this._b * this._c;
		return isFinite(det) && !Numerical.isZero(det)
				&& isFinite(this._tx) && isFinite(this._ty)
				? det : null;
	},

	_inverseTransform: function(point, dest, _dontNotify) {
		var det = this._getDeterminant();
		if (!det)
			return null;
		var x = point.x - this._tx,
			y = point.y - this._ty;
		if (!dest)
			dest = new Point();
		return dest.set(
			(x * this._d - y * this._b) / det,
			(y * this._a - x * this._c) / det,
			_dontNotify
		);
	},

	decompose: function() {
		var a = this._a, b = this._b, c = this._c, d = this._d;
		if (Numerical.isZero(a * d - b * c))
			return null;

		var scaleX = Math.sqrt(a * a + b * b);
		a /= scaleX;
		b /= scaleX;

		var shear = a * c + b * d;
		c -= a * shear;
		d -= b * shear;

		var scaleY = Math.sqrt(c * c + d * d);
		c /= scaleY;
		d /= scaleY;
		shear /= scaleY;

		if (a * d < b * c) {
			a = -a;
			b = -b;
			shear = -shear;
			scaleX = -scaleX;
		}

		return {
			scaling: new Point(scaleX, scaleY),
			rotation: -Math.atan2(b, a) * 180 / Math.PI,
			shearing: shear
		};
	},

	getValues: function() {
		return [ this._a, this._c, this._b, this._d, this._tx, this._ty ];
	},

	getTranslation: function() {
		return new Point(this._tx, this._ty);
	},

	getScaling: function() {
		return (this.decompose() || {}).scaling;
	},

	getRotation: function() {
		return (this.decompose() || {}).rotation;
	},

	inverted: function() {
		var det = this._getDeterminant();
		return det && new Matrix(
				this._d / det,
				-this._c / det,
				-this._b / det,
				this._a / det,
				(this._b * this._ty - this._d * this._tx) / det,
				(this._c * this._tx - this._a * this._ty) / det);
	},

	shiftless: function() {
		return new Matrix(this._a, this._c, this._b, this._d, 0, 0);
	},

	applyToContext: function(ctx) {
		ctx.transform(this._a, this._c, this._b, this._d, this._tx, this._ty);
	}
}, Base.each(['a', 'c', 'b', 'd', 'tx', 'ty'], function(name) {
	var part = Base.capitalize(name),
		prop = '_' + name;
	this['get' + part] = function() {
		return this[prop];
	};
	this['set' + part] = function(value) {
		this[prop] = value;
		this._changed();
	};
}, {}));

var Line = Base.extend({
	_class: 'Line',

	initialize: function Line(arg0, arg1, arg2, arg3, arg4) {
		var asVector = false;
		if (arguments.length >= 4) {
			this._px = arg0;
			this._py = arg1;
			this._vx = arg2;
			this._vy = arg3;
			asVector = arg4;
		} else {
			this._px = arg0.x;
			this._py = arg0.y;
			this._vx = arg1.x;
			this._vy = arg1.y;
			asVector = arg2;
		}
		if (!asVector) {
			this._vx -= this._px;
			this._vy -= this._py;
		}
	},

	getPoint: function() {
		return new Point(this._px, this._py);
	},

	getVector: function() {
		return new Point(this._vx, this._vy);
	},

	getLength: function() {
		return this.getVector().getLength();
	},

	intersect: function(line, isInfinite) {
		return Line.intersect(
				this._px, this._py, this._vx, this._vy,
				line._px, line._py, line._vx, line._vy,
				true, isInfinite);
	},

	getSide: function(point, isInfinite) {
		return Line.getSide(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true, isInfinite);
	},

	getDistance: function(point) {
		return Math.abs(Line.getSignedDistance(
				this._px, this._py, this._vx, this._vy,
				point.x, point.y, true));
	},

	isCollinear: function(line) {
		return Point.isCollinear(this._vx, this._vy, line._vx, line._vy);
	},

	isOrthogonal: function(line) {
		return Point.isOrthogonal(this._vx, this._vy, line._vx, line._vy);
	},

	statics: {
		intersect: function(p1x, p1y, v1x, v1y, p2x, p2y, v2x, v2y, asVector,
				isInfinite) {
			if (!asVector) {
				v1x -= p1x;
				v1y -= p1y;
				v2x -= p2x;
				v2y -= p2y;
			}
			var cross = v1x * v2y - v1y * v2x;
			if (!Numerical.isZero(cross)) {
				var dx = p1x - p2x,
					dy = p1y - p2y,
					u1 = (v2x * dy - v2y * dx) / cross,
					u2 = (v1x * dy - v1y * dx) / cross,
					epsilon = 1e-12,
					uMin = -epsilon,
					uMax = 1 + epsilon;
				if (isInfinite
						|| uMin < u1 && u1 < uMax && uMin < u2 && u2 < uMax) {
					if (!isInfinite) {
						u1 = u1 <= 0 ? 0 : u1 >= 1 ? 1 : u1;
					}
					return new Point(
							p1x + u1 * v1x,
							p1y + u1 * v1y);
				}
			}
		},

		getSide: function(px, py, vx, vy, x, y, asVector, isInfinite) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			var v2x = x - px,
				v2y = y - py,
				ccw = v2x * vy - v2y * vx;
			if (ccw === 0 && !isInfinite) {
				ccw = (v2x * vx + v2x * vx) / (vx * vx + vy * vy);
				if (ccw >= 0 && ccw <= 1)
					ccw = 0;
			}
			return ccw < 0 ? -1 : ccw > 0 ? 1 : 0;
		},

		getSignedDistance: function(px, py, vx, vy, x, y, asVector) {
			if (!asVector) {
				vx -= px;
				vy -= py;
			}
			return vx === 0 ? vy > 0 ? x - px : px - x
				 : vy === 0 ? vx < 0 ? y - py : py - y
				 : ((x-px) * vy - (y-py) * vx) / Math.sqrt(vx * vx + vy * vy);
		}
	}
});

var Project = PaperScopeItem.extend({
	_class: 'Project',
	_list: 'projects',
	_reference: 'project',

	initialize: function Project(element) {
		PaperScopeItem.call(this, true);
		this.layers = [];
		this._activeLayer = null;
		this.symbols = [];
		this._currentStyle = new Style(null, null, this);
		this._view = View.create(this,
				element || CanvasProvider.getCanvas(1, 1));
		this._selectedItems = {};
		this._selectedItemCount = 0;
		this._updateVersion = 0;
	},

	_serialize: function(options, dictionary) {
		return Base.serialize(this.layers, options, true, dictionary);
	},

	clear: function() {
		for (var i = this.layers.length - 1; i >= 0; i--)
			this.layers[i].remove();
		this.symbols = [];
	},

	isEmpty: function() {
		return this.layers.length === 0;
	},

	remove: function remove() {
		if (!remove.base.call(this))
			return false;
		if (this._view)
			this._view.remove();
		return true;
	},

	getView: function() {
		return this._view;
	},

	getCurrentStyle: function() {
		return this._currentStyle;
	},

	setCurrentStyle: function(style) {
		this._currentStyle.initialize(style);
	},

	getIndex: function() {
		return this._index;
	},

	getOptions: function() {
		return this._scope.settings;
	},

	getActiveLayer: function() {
		return this._activeLayer || new Layer({ project: this });
	},

	getSelectedItems: function() {
		var items = [];
		for (var id in this._selectedItems) {
			var item = this._selectedItems[id];
			if (item.isInserted())
				items.push(item);
		}
		return items;
	},

	insertChild: function(index, item, _preserve) {
		if (item instanceof Layer) {
			item._remove(false, true);
			Base.splice(this.layers, [item], index, 0);
			item._setProject(this, true);
			if (this._changes)
				item._changed(5);
			if (!this._activeLayer)
				this._activeLayer = item;
		} else if (item instanceof Item) {
			(this._activeLayer
				|| this.insertChild(index, new Layer(Item.NO_INSERT)))
					.insertChild(index, item, _preserve);
		} else {
			item = null;
		}
		return item;
	},

	addChild: function(item, _preserve) {
		return this.insertChild(undefined, item, _preserve);
	},

	_updateSelection: function(item) {
		var id = item._id,
			selectedItems = this._selectedItems;
		if (item._selected) {
			if (selectedItems[id] !== item) {
				this._selectedItemCount++;
				selectedItems[id] = item;
			}
		} else if (selectedItems[id] === item) {
			this._selectedItemCount--;
			delete selectedItems[id];
		}
	},

	selectAll: function() {
		var layers = this.layers;
		for (var i = 0, l = layers.length; i < l; i++)
			layers[i].setFullySelected(true);
	},

	deselectAll: function() {
		var selectedItems = this._selectedItems;
		for (var i in selectedItems)
			selectedItems[i].setFullySelected(false);
	},

	hitTest: function() {
		var point = Point.read(arguments),
			options = HitResult.getOptions(Base.read(arguments));
		for (var i = this.layers.length - 1; i >= 0; i--) {
			var res = this.layers[i]._hitTest(point, options);
			if (res) return res;
		}
		return null;
	},

	getItems: function(match) {
		return Item._getItems(this.layers, match);
	},

	getItem: function(match) {
		return Item._getItems(this.layers, match, null, null, true)[0] || null;
	},

	importJSON: function(json) {
		this.activate();
		var layer = this._activeLayer;
		return Base.importJSON(json, layer && layer.isEmpty() && layer);
	},

	draw: function(ctx, matrix, pixelRatio) {
		this._updateVersion++;
		ctx.save();
		matrix.applyToContext(ctx);
		var param = new Base({
			offset: new Point(0, 0),
			pixelRatio: pixelRatio,
			viewMatrix: matrix.isIdentity() ? null : matrix,
			matrices: [new Matrix()],
			updateMatrix: true
		});
		for (var i = 0, layers = this.layers, l = layers.length; i < l; i++)
			layers[i].draw(ctx, param);
		ctx.restore();

		if (this._selectedItemCount > 0) {
			ctx.save();
			ctx.strokeWidth = 1;
			var items = this._selectedItems,
				size = this._scope.settings.handleSize,
				version = this._updateVersion;
			for (var id in items)
				items[id]._drawSelection(ctx, matrix, size, items, version);
			ctx.restore();
		}
	}
});

var Symbol = Base.extend({
	_class: 'Symbol',

	initialize: function Symbol(item, dontCenter) {
		this._id = UID.get();
		this.project = paper.project;
		this.project.symbols.push(this);
		if (item)
			this.setDefinition(item, dontCenter);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._class, this._definition],
					options, false, dictionary);
		});
	},

	_changed: function(flags) {
		if (flags & 8) {
			Item._clearBoundsCache(this);
		}
		if (flags & 1) {
			this.project._needsUpdate = true;
		}
	},

	getDefinition: function() {
		return this._definition;
	},

	setDefinition: function(item, _dontCenter) {
		if (item._parentSymbol)
			item = item.clone();
		if (this._definition)
			this._definition._parentSymbol = null;
		this._definition = item;
		item.remove();
		item.setSelected(false);
		if (!_dontCenter)
			item.setPosition(new Point());
		item._parentSymbol = this;
		this._changed(9);
	},

	place: function(position) {
		return new PlacedSymbol(this, position);
	},

	clone: function() {
		return new Symbol(this._definition.clone(false));
	},

	equals: function(symbol) {
		return symbol === this
				|| symbol && this.definition.equals(symbol.definition)
				|| false;
	}
});

var Item = Base.extend(Emitter, {
	statics: {
		extend: function extend(src) {
			if (src._serializeFields)
				src._serializeFields = new Base(
						this.prototype._serializeFields, src._serializeFields);
			return extend.base.apply(this, arguments);
		},

		NO_INSERT: { insert: false }
	},

	_class: 'Item',
	_applyMatrix: true,
	_canApplyMatrix: true,
	_boundsSelected: false,
	_selectChildren: false,
	_serializeFields: {
		name: null,
		applyMatrix: null,
		matrix: new Matrix(),
		pivot: null,
		locked: false,
		visible: true,
		blendMode: 'normal',
		opacity: 1,
		guide: false,
		selected: false,
		clipMask: false,
		data: {}
	},

	initialize: function Item() {
	},

	_initialize: function(props, point) {
		var hasProps = props && Base.isPlainObject(props),
			internal = hasProps && props.internal === true,
			matrix = this._matrix = new Matrix(),
			project = hasProps && props.project || paper.project;
		if (!internal)
			this._id = UID.get();
		this._applyMatrix = this._canApplyMatrix && paper.settings.applyMatrix;
		if (point)
			matrix.translate(point);
		matrix._owner = this;
		this._style = new Style(project._currentStyle, this, project);
		if (!this._project) {
			if (internal || hasProps && props.insert === false) {
				this._setProject(project);
			} else if (hasProps && props.parent) {
				this.setParent(props.parent);
			} else {
				(project._activeLayer || new Layer()).addChild(this);
			}
		}
		if (hasProps && props !== Item.NO_INSERT)
			this._set(props, { insert: true, project: true, parent: true },
					true);
		return hasProps;
	},

	_events: Base.each(['onMouseDown', 'onMouseUp', 'onMouseDrag', 'onClick',
			'onDoubleClick', 'onMouseMove', 'onMouseEnter', 'onMouseLeave'],
		function(name) {
			this[name] = {
				install: function(type) {
					this.getView()._installEvent(type);
				},

				uninstall: function(type) {
					this.getView()._uninstallEvent(type);
				}
			};
		}, {
			onFrame: {
				install: function() {
					this.getView()._animateItem(this, true);
				},

				uninstall: function() {
					this.getView()._animateItem(this, false);
				}
			},

			onLoad: {}
		}
	),

	_serialize: function(options, dictionary) {
		var props = {},
			that = this;

		function serialize(fields) {
			for (var key in fields) {
				var value = that[key];
				if (!Base.equals(value, key === 'leading'
						? fields.fontSize * 1.2 : fields[key])) {
					props[key] = Base.serialize(value, options,
							key !== 'data', dictionary);
				}
			}
		}

		serialize(this._serializeFields);
		if (!(this instanceof Group))
			serialize(this._style._defaults);
		return [ this._class, props ];
	},

	_changed: function(flags) {
		var symbol = this._parentSymbol,
			cacheParent = this._parent || symbol,
			project = this._project;
		if (flags & 8) {
			this._bounds = this._position = this._decomposed =
					this._globalMatrix = this._currentPath = undefined;
		}
		if (cacheParent
				&& (flags & 40)) {
			Item._clearBoundsCache(cacheParent);
		}
		if (flags & 2) {
			Item._clearBoundsCache(this);
		}
		if (project) {
			if (flags & 1) {
				project._needsUpdate = true;
			}
			if (project._changes) {
				var entry = project._changesById[this._id];
				if (entry) {
					entry.flags |= flags;
				} else {
					entry = { item: this, flags: flags };
					project._changesById[this._id] = entry;
					project._changes.push(entry);
				}
			}
		}
		if (symbol)
			symbol._changed(flags);
	},

	set: function(props) {
		if (props)
			this._set(props);
		return this;
	},

	getId: function() {
		return this._id;
	},

	getName: function() {
		return this._name;
	},

	setName: function(name, unique) {

		if (this._name)
			this._removeNamed();
		if (name === (+name) + '')
			throw new Error(
					'Names consisting only of numbers are not supported.');
		var parent = this._parent;
		if (name && parent) {
			var children = parent._children,
				namedChildren = parent._namedChildren,
				orig = name,
				i = 1;
			while (unique && children[name])
				name = orig + ' ' + (i++);
			(namedChildren[name] = namedChildren[name] || []).push(this);
			children[name] = this;
		}
		this._name = name || undefined;
		this._changed(128);
	},

	getStyle: function() {
		return this._style;
	},

	setStyle: function(style) {
		this.getStyle().set(style);
	}
}, Base.each(['locked', 'visible', 'blendMode', 'opacity', 'guide'],
	function(name) {
		var part = Base.capitalize(name),
			name = '_' + name;
		this['get' + part] = function() {
			return this[name];
		};
		this['set' + part] = function(value) {
			if (value != this[name]) {
				this[name] = value;
				this._changed(name === '_locked'
						? 128 : 129);
			}
		};
	},
{}), {
	beans: true,

	_locked: false,

	_visible: true,

	_blendMode: 'normal',

	_opacity: 1,

	_guide: false,

	isSelected: function() {
		if (this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				if (children[i].isSelected())
					return true;
		}
		return this._selected;
	},

	setSelected: function(selected, noChildren) {
		if (!noChildren && this._selectChildren) {
			var children = this._children;
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setSelected(selected);
		}
		if ((selected = !!selected) ^ this._selected) {
			this._selected = selected;
			this._project._updateSelection(this);
			this._changed(129);
		}
	},

	_selected: false,

	isFullySelected: function() {
		var children = this._children;
		if (children && this._selected) {
			for (var i = 0, l = children.length; i < l; i++)
				if (!children[i].isFullySelected())
					return false;
			return true;
		}
		return this._selected;
	},

	setFullySelected: function(selected) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].setFullySelected(selected);
		}
		this.setSelected(selected, true);
	},

	isClipMask: function() {
		return this._clipMask;
	},

	setClipMask: function(clipMask) {
		if (this._clipMask != (clipMask = !!clipMask)) {
			this._clipMask = clipMask;
			if (clipMask) {
				this.setFillColor(null);
				this.setStrokeColor(null);
			}
			this._changed(129);
			if (this._parent)
				this._parent._changed(1024);
		}
	},

	_clipMask: false,

	getData: function() {
		if (!this._data)
			this._data = {};
		return this._data;
	},

	setData: function(data) {
		this._data = data;
	},

	getPosition: function(_dontLink) {
		var position = this._position,
			ctor = _dontLink ? Point : LinkedPoint;
		if (!position) {
			var pivot = this._pivot;
			position = this._position = pivot
					? this._matrix._transformPoint(pivot)
					: this.getBounds().getCenter(true);
		}
		return new ctor(position.x, position.y, this, 'setPosition');
	},

	setPosition: function() {
		this.translate(Point.read(arguments).subtract(this.getPosition(true)));
	},

	getPivot: function(_dontLink) {
		var pivot = this._pivot;
		if (pivot) {
			var ctor = _dontLink ? Point : LinkedPoint;
			pivot = new ctor(pivot.x, pivot.y, this, 'setPivot');
		}
		return pivot;
	},

	setPivot: function() {
		this._pivot = Point.read(arguments, 0, { clone: true, readNull: true });
		this._position = undefined;
	},

	_pivot: null,
}, Base.each(['bounds', 'strokeBounds', 'handleBounds', 'roughBounds',
		'internalBounds', 'internalRoughBounds'],
	function(key) {
		var getter = 'get' + Base.capitalize(key),
			match = key.match(/^internal(.*)$/),
			internalGetter = match ? 'get' + match[1] : null;
		this[getter] = function(_matrix) {
			var boundsGetter = this._boundsGetter,
				name = !internalGetter && (typeof boundsGetter === 'string'
						? boundsGetter : boundsGetter && boundsGetter[getter])
						|| getter,
				bounds = this._getCachedBounds(name, _matrix, this,
						internalGetter);
			return key === 'bounds'
					? new LinkedRectangle(bounds.x, bounds.y, bounds.width,
							bounds.height, this, 'setBounds')
					: bounds;
		};
	},
{
	beans: true,

	_getBounds: function(getter, matrix, cacheItem) {
		var children = this._children;
		if (!children || children.length == 0)
			return new Rectangle();
		Item._updateBoundsCache(this, cacheItem);
		var x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			if (child._visible && !child.isEmpty()) {
				var rect = child._getCachedBounds(getter,
						matrix && matrix.chain(child._matrix), cacheItem);
				x1 = Math.min(rect.x, x1);
				y1 = Math.min(rect.y, y1);
				x2 = Math.max(rect.x + rect.width, x2);
				y2 = Math.max(rect.y + rect.height, y2);
			}
		}
		return isFinite(x1)
				? new Rectangle(x1, y1, x2 - x1, y2 - y1)
				: new Rectangle();
	},

	setBounds: function() {
		var rect = Rectangle.read(arguments),
			bounds = this.getBounds(),
			matrix = new Matrix(),
			center = rect.getCenter();
		matrix.translate(center);
		if (rect.width != bounds.width || rect.height != bounds.height) {
			matrix.scale(
					bounds.width != 0 ? rect.width / bounds.width : 1,
					bounds.height != 0 ? rect.height / bounds.height : 1);
		}
		center = bounds.getCenter();
		matrix.translate(-center.x, -center.y);
		this.transform(matrix);
	},

	_getCachedBounds: function(getter, matrix, cacheItem, internalGetter) {
		matrix = matrix && matrix.orNullIfIdentity();
		var _matrix = internalGetter ? null : this._matrix.orNullIfIdentity(),
			cache = (!matrix || matrix.equals(_matrix)) && getter;
		Item._updateBoundsCache(this._parent || this._parentSymbol, cacheItem);
		if (cache && this._bounds && this._bounds[cache])
			return this._bounds[cache].clone();
		var bounds = this._getBounds(internalGetter || getter,
				matrix || _matrix, cacheItem);
		if (cache) {
			if (!this._bounds)
				this._bounds = {};
			var cached = this._bounds[cache] = bounds.clone();
			cached._internal = !!internalGetter;
		}
		return bounds;
	},

	statics: {
		_updateBoundsCache: function(parent, item) {
			if (parent) {
				var id = item._id,
					ref = parent._boundsCache = parent._boundsCache || {
						ids: {},
						list: []
					};
				if (!ref.ids[id]) {
					ref.list.push(item);
					ref.ids[id] = item;
				}
			}
		},

		_clearBoundsCache: function(item) {
			var cache = item._boundsCache;
			if (cache) {
				item._bounds = item._position = item._boundsCache = undefined;
				for (var i = 0, list = cache.list, l = list.length; i < l; i++){
					var other = list[i];
					if (other !== item) {
						other._bounds = other._position = undefined;
						if (other._boundsCache)
							Item._clearBoundsCache(other);
					}
				}
			}
		}
	}

}), {
	beans: true,

	_decompose: function() {
		return this._decomposed = this._matrix.decompose();
	},

	getRotation: function() {
		var decomposed = this._decomposed || this._decompose();
		return decomposed && decomposed.rotation;
	},

	setRotation: function(rotation) {
		var current = this.getRotation();
		if (current != null && rotation != null) {
			var decomposed = this._decomposed;
			this.rotate(rotation - current);
			decomposed.rotation = rotation;
			this._decomposed = decomposed;
		}
	},

	getScaling: function(_dontLink) {
		var decomposed = this._decomposed || this._decompose(),
			scaling = decomposed && decomposed.scaling,
			ctor = _dontLink ? Point : LinkedPoint;
		return scaling && new ctor(scaling.x, scaling.y, this, 'setScaling');
	},

	setScaling: function() {
		var current = this.getScaling();
		if (current) {
			var scaling = Point.read(arguments, 0, { clone: true }),
				decomposed = this._decomposed;
			this.scale(scaling.x / current.x, scaling.y / current.y);
			decomposed.scaling = scaling;
			this._decomposed = decomposed;
		}
	},

	getMatrix: function() {
		return this._matrix;
	},

	setMatrix: function() {
		var matrix = this._matrix;
		matrix.initialize.apply(matrix, arguments);
		if (this._applyMatrix) {
			this.transform(null, true);
		} else {
			this._changed(9);
		}
	},

	getGlobalMatrix: function(_dontClone) {
		var matrix = this._globalMatrix,
			updateVersion = this._project._updateVersion;
		if (matrix && matrix._updateVersion !== updateVersion)
			matrix = null;
		if (!matrix) {
			matrix = this._globalMatrix = this._matrix.clone();
			var parent = this._parent;
			if (parent)
				matrix.preConcatenate(parent.getGlobalMatrix(true));
			matrix._updateVersion = updateVersion;
		}
		return _dontClone ? matrix : matrix.clone();
	},

	getApplyMatrix: function() {
		return this._applyMatrix;
	},

	setApplyMatrix: function(apply) {
		if (this._applyMatrix = this._canApplyMatrix && !!apply)
			this.transform(null, true);
	},

	getTransformContent: '#getApplyMatrix',
	setTransformContent: '#setApplyMatrix',
}, {
	getProject: function() {
		return this._project;
	},

	_setProject: function(project, installEvents) {
		if (this._project !== project) {
			if (this._project)
				this._installEvents(false);
			this._project = project;
			var children = this._children;
			for (var i = 0, l = children && children.length; i < l; i++)
				children[i]._setProject(project);
			installEvents = true;
		}
		if (installEvents)
			this._installEvents(true);
	},

	getView: function() {
		return this._project.getView();
	},

	_installEvents: function _installEvents(install) {
		_installEvents.base.call(this, install);
		var children = this._children;
		for (var i = 0, l = children && children.length; i < l; i++)
			children[i]._installEvents(install);
	},

	getLayer: function() {
		var parent = this;
		while (parent = parent._parent) {
			if (parent instanceof Layer)
				return parent;
		}
		return null;
	},

	getParent: function() {
		return this._parent;
	},

	setParent: function(item) {
		return item.addChild(this);
	},

	getChildren: function() {
		return this._children;
	},

	setChildren: function(items) {
		this.removeChildren();
		this.addChildren(items);
	},

	getFirstChild: function() {
		return this._children && this._children[0] || null;
	},

	getLastChild: function() {
		return this._children && this._children[this._children.length - 1]
				|| null;
	},

	getNextSibling: function() {
		return this._parent && this._parent._children[this._index + 1] || null;
	},

	getPreviousSibling: function() {
		return this._parent && this._parent._children[this._index - 1] || null;
	},

	getIndex: function() {
		return this._index;
	},

	equals: function(item) {
		return item === this || item && this._class === item._class
				&& this._style.equals(item._style)
				&& this._matrix.equals(item._matrix)
				&& this._locked === item._locked
				&& this._visible === item._visible
				&& this._blendMode === item._blendMode
				&& this._opacity === item._opacity
				&& this._clipMask === item._clipMask
				&& this._guide === item._guide
				&& this._equals(item)
				|| false;
	},

	_equals: function(item) {
		return Base.equals(this._children, item._children);
	},

	clone: function(insert) {
		return this._clone(new this.constructor(Item.NO_INSERT), insert);
	},

	_clone: function(copy, insert, includeMatrix) {
		var keys = ['_locked', '_visible', '_blendMode', '_opacity',
				'_clipMask', '_guide'],
			children = this._children;
		copy.setStyle(this._style);
		for (var i = 0, l = children && children.length; i < l; i++) {
			copy.addChild(children[i].clone(false), true);
		}
		for (var i = 0, l = keys.length; i < l; i++) {
			var key = keys[i];
			if (this.hasOwnProperty(key))
				copy[key] = this[key];
		}
		if (includeMatrix !== false)
			copy._matrix.initialize(this._matrix);
		copy.setApplyMatrix(this._applyMatrix);
		copy.setPivot(this._pivot);
		copy.setSelected(this._selected);
		copy._data = this._data ? Base.clone(this._data) : null;
		if (insert || insert === undefined)
			copy.insertAbove(this);
		if (this._name)
			copy.setName(this._name, true);
		return copy;
	},

	copyTo: function(itemOrProject) {
		return itemOrProject.addChild(this.clone(false));
	},

	rasterize: function(resolution) {
		var bounds = this.getStrokeBounds(),
			scale = (resolution || this.getView().getResolution()) / 72,
			topLeft = bounds.getTopLeft().floor(),
			bottomRight = bounds.getBottomRight().ceil(),
			size = new Size(bottomRight.subtract(topLeft)),
			canvas = CanvasProvider.getCanvas(size.multiply(scale)),
			ctx = canvas.getContext('2d'),
			matrix = new Matrix().scale(scale).translate(topLeft.negate());
		ctx.save();
		matrix.applyToContext(ctx);
		this.draw(ctx, new Base({ matrices: [matrix] }));
		ctx.restore();
		var raster = new Raster(Item.NO_INSERT);
		raster.setCanvas(canvas);
		raster.transform(new Matrix().translate(topLeft.add(size.divide(2)))
				.scale(1 / scale));
		raster.insertAbove(this);
		return raster;
	},

	contains: function() {
		return !!this._contains(
				this._matrix._inverseTransform(Point.read(arguments)));
	},

	_contains: function(point) {
		if (this._children) {
			for (var i = this._children.length - 1; i >= 0; i--) {
				if (this._children[i].contains(point))
					return true;
			}
			return false;
		}
		return point.isInside(this.getInternalBounds());
	},

	isInside: function() {
		return Rectangle.read(arguments).contains(this.getBounds());
	},

	_asPathItem: function() {
		return new Path.Rectangle({
			rectangle: this.getInternalBounds(),
			matrix: this._matrix,
			insert: false,
		});
	},

	intersects: function(item, _matrix) {
		if (!(item instanceof Item))
			return false;
		return this._asPathItem().getIntersections(item._asPathItem(), null,
				_matrix || item._matrix, true).length > 0;
	},

	hitTest: function() {
		return this._hitTest(
				Point.read(arguments),
				HitResult.getOptions(Base.read(arguments)));
	},

	_hitTest: function(point, options) {
		if (this._locked || !this._visible || this._guide && !options.guides
				|| this.isEmpty())
			return null;

		var matrix = this._matrix,
			parentTotalMatrix = options._totalMatrix,
			view = this.getView(),
			totalMatrix = options._totalMatrix = parentTotalMatrix
					? parentTotalMatrix.chain(matrix)
					: this.getGlobalMatrix().preConcatenate(view._matrix),
			tolerancePadding = options._tolerancePadding = new Size(
						Path._getPenPadding(1, totalMatrix.inverted())
					).multiply(
						Math.max(options.tolerance, 1e-6)
					);
		point = matrix._inverseTransform(point);

		if (!this._children && !this.getInternalRoughBounds()
				.expand(tolerancePadding.multiply(2))._containsPoint(point))
			return null;
		var checkSelf = !(options.guides && !this._guide
				|| options.selected && !this._selected
				|| options.type && options.type !== Base.hyphenate(this._class)
				|| options.class && !(this instanceof options.class)),
			that = this,
			res;

		function checkBounds(type, part) {
			var pt = bounds['get' + part]();
			if (point.subtract(pt).divide(tolerancePadding).length <= 1)
				return new HitResult(type, that,
						{ name: Base.hyphenate(part), point: pt });
		}

		if (checkSelf && (options.center || options.bounds) && this._parent) {
			var bounds = this.getInternalBounds();
			if (options.center)
				res = checkBounds('center', 'Center');
			if (!res && options.bounds) {
				var points = [
					'TopLeft', 'TopRight', 'BottomLeft', 'BottomRight',
					'LeftCenter', 'TopCenter', 'RightCenter', 'BottomCenter'
				];
				for (var i = 0; i < 8 && !res; i++)
					res = checkBounds('bounds', points[i]);
			}
		}

		var children = !res && this._children;
		if (children) {
			var opts = this._getChildHitTestOptions(options);
			for (var i = children.length - 1; i >= 0 && !res; i--)
				res = children[i]._hitTest(point, opts);
		}
		if (!res && checkSelf)
			res = this._hitTestSelf(point, options);
		if (res && res.point)
			res.point = matrix.transform(res.point);
		options._totalMatrix = parentTotalMatrix;
		return res;
	},

	_getChildHitTestOptions: function(options) {
		return options;
	},

	_hitTestSelf: function(point, options) {
		if (options.fill && this.hasFill() && this._contains(point))
			return new HitResult('fill', this);
	},

	matches: function(name, compare) {
		function matchObject(obj1, obj2) {
			for (var i in obj1) {
				if (obj1.hasOwnProperty(i)) {
					var val1 = obj1[i],
						val2 = obj2[i];
					if (Base.isPlainObject(val1) && Base.isPlainObject(val2)) {
						if (!matchObject(val1, val2))
							return false;
					} else if (!Base.equals(val1, val2)) {
						return false;
					}
				}
			}
			return true;
		}
		var type = typeof name;
		if (type === 'object') {
			for (var key in name) {
				if (name.hasOwnProperty(key) && !this.matches(key, name[key]))
					return false;
			}
		} else if (type === 'function') {
			return name(this);
		} else {
			var value = /^(empty|editable)$/.test(name)
					? this['is' + Base.capitalize(name)]()
					: name === 'type'
						? Base.hyphenate(this._class)
						: this[name];
			if (/^(constructor|class)$/.test(name)) {
				if (!(this instanceof compare))
					return false;
			} else if (compare instanceof RegExp) {
				if (!compare.test(value))
					return false;
			} else if (typeof compare === 'function') {
				if (!compare(value))
					return false;
			} else if (Base.isPlainObject(compare)) {
				if (!matchObject(compare, value))
					return false;
			} else if (!Base.equals(value, compare)) {
				return false;
			}
		}
		return true;
	},

	getItems: function(match) {
		return Item._getItems(this._children, match, this._matrix);
	},

	getItem: function(match) {
		return Item._getItems(this._children, match, this._matrix, null, true)
				[0] || null;
	},

	statics: {
		_getItems: function _getItems(children, match, matrix, param,
				firstOnly) {
			if (!param && typeof match === 'object') {
				var overlapping = match.overlapping,
					inside = match.inside,
					bounds = overlapping || inside,
					rect = bounds && Rectangle.read([bounds]);
				param = {
					items: [],
					inside: !!inside,
					overlapping: !!overlapping,
					rect: rect,
					path: overlapping && new Path.Rectangle({
						rectangle: rect,
						insert: false
					})
				};
				if (bounds)
					match = Base.set({}, match,
							{ inside: true, overlapping: true });
			}
			var items = param && param.items,
				rect = param && param.rect;
			matrix = rect && (matrix || new Matrix());
			for (var i = 0, l = children && children.length; i < l; i++) {
				var child = children[i],
					childMatrix = matrix && matrix.chain(child._matrix),
					add = true;
				if (rect) {
					var bounds = child.getBounds(childMatrix);
					if (!rect.intersects(bounds))
						continue;
					if (!(param.inside && rect.contains(bounds))
							&& !(param.overlapping && (bounds.contains(rect)
								|| param.path.intersects(child, childMatrix))))
						add = false;
				}
				if (add && child.matches(match)) {
					items.push(child);
					if (firstOnly)
						break;
				}
				_getItems(child._children, match,
						childMatrix, param,
						firstOnly);
				if (firstOnly && items.length > 0)
					break;
			}
			return items;
		}
	}
}, {

	importJSON: function(json) {
		var res = Base.importJSON(json, this);
		return res !== this
				? this.addChild(res)
				: res;
	},

	addChild: function(item, _preserve) {
		return this.insertChild(undefined, item, _preserve);
	},

	insertChild: function(index, item, _preserve) {
		var res = item ? this.insertChildren(index, [item], _preserve) : null;
		return res && res[0];
	},

	addChildren: function(items, _preserve) {
		return this.insertChildren(this._children.length, items, _preserve);
	},

	insertChildren: function(index, items, _preserve, _proto) {
		var children = this._children;
		if (children && items && items.length > 0) {
			items = Array.prototype.slice.apply(items);
			for (var i = items.length - 1; i >= 0; i--) {
				var item = items[i];
				if (_proto && !(item instanceof _proto)) {
					items.splice(i, 1);
				} else {
					var shift = item._parent === this && item._index < index;
					if (item._remove(false, true) && shift)
						index--;
				}
			}
			Base.splice(children, items, index, 0);
			var project = this._project,
				notifySelf = project && project._changes;
			for (var i = 0, l = items.length; i < l; i++) {
				var item = items[i];
				item._parent = this;
				item._setProject(this._project, true);
				if (item._name)
					item.setName(item._name);
				if (notifySelf)
					this._changed(5);
			}
			this._changed(11);
		} else {
			items = null;
		}
		return items;
	},

	_insertSibling: function(index, item, _preserve) {
		return this._parent
				? this._parent.insertChild(index, item, _preserve)
				: null;
	},

	insertAbove: function(item, _preserve) {
		return item._insertSibling(item._index + 1, this, _preserve);
	},

	insertBelow: function(item, _preserve) {
		return item._insertSibling(item._index, this, _preserve);
	},

	sendToBack: function() {
		return (this._parent || this instanceof Layer && this._project)
				.insertChild(0, this);
	},

	bringToFront: function() {
		return (this._parent || this instanceof Layer && this._project)
				.addChild(this);
	},

	appendTop: '#addChild',

	appendBottom: function(item) {
		return this.insertChild(0, item);
	},

	moveAbove: '#insertAbove',

	moveBelow: '#insertBelow',

	reduce: function() {
		if (this._children && this._children.length === 1) {
			var child = this._children[0].reduce();
			child.insertAbove(this);
			child.setStyle(this._style);
			this.remove();
			return child;
		}
		return this;
	},

	_removeNamed: function() {
		var parent = this._parent;
		if (parent) {
			var children = parent._children,
				namedChildren = parent._namedChildren,
				name = this._name,
				namedArray = namedChildren[name],
				index = namedArray ? namedArray.indexOf(this) : -1;
			if (index !== -1) {
				if (children[name] == this)
					delete children[name];
				namedArray.splice(index, 1);
				if (namedArray.length) {
					children[name] = namedArray[namedArray.length - 1];
				} else {
					delete namedChildren[name];
				}
			}
		}
	},

	_remove: function(notifySelf, notifyParent) {
		var parent = this._parent;
		if (parent) {
			if (this._name)
				this._removeNamed();
			if (this._index != null)
				Base.splice(parent._children, null, this._index, 1);
			this._installEvents(false);
			if (notifySelf) {
				var project = this._project;
				if (project && project._changes)
					this._changed(5);
			}
			if (notifyParent)
				parent._changed(11);
			this._parent = null;
			return true;
		}
		return false;
	},

	remove: function() {
		return this._remove(true, true);
	},

	replaceWith: function(item) {
		var ok = item && item.insertBelow(this);
		if (ok)
			this.remove();
		return ok;
	},

	removeChildren: function(from, to) {
		if (!this._children)
			return null;
		from = from || 0;
		to = Base.pick(to, this._children.length);
		var removed = Base.splice(this._children, null, from, to - from);
		for (var i = removed.length - 1; i >= 0; i--) {
			removed[i]._remove(true, false);
		}
		if (removed.length > 0)
			this._changed(11);
		return removed;
	},

	clear: '#removeChildren',

	reverseChildren: function() {
		if (this._children) {
			this._children.reverse();
			for (var i = 0, l = this._children.length; i < l; i++)
				this._children[i]._index = i;
			this._changed(11);
		}
	},

	isEmpty: function() {
		return !this._children || this._children.length === 0;
	},

	isEditable: function() {
		var item = this;
		while (item) {
			if (!item._visible || item._locked)
				return false;
			item = item._parent;
		}
		return true;
	},

	hasFill: function() {
		return this.getStyle().hasFill();
	},

	hasStroke: function() {
		return this.getStyle().hasStroke();
	},

	hasShadow: function() {
		return this.getStyle().hasShadow();
	},

	_getOrder: function(item) {
		function getList(item) {
			var list = [];
			do {
				list.unshift(item);
			} while (item = item._parent);
			return list;
		}
		var list1 = getList(this),
			list2 = getList(item);
		for (var i = 0, l = Math.min(list1.length, list2.length); i < l; i++) {
			if (list1[i] != list2[i]) {
				return list1[i]._index < list2[i]._index ? 1 : -1;
			}
		}
		return 0;
	},

	hasChildren: function() {
		return this._children && this._children.length > 0;
	},

	isInserted: function() {
		return this._parent ? this._parent.isInserted() : false;
	},

	isAbove: function(item) {
		return this._getOrder(item) === -1;
	},

	isBelow: function(item) {
		return this._getOrder(item) === 1;
	},

	isParent: function(item) {
		return this._parent === item;
	},

	isChild: function(item) {
		return item && item._parent === this;
	},

	isDescendant: function(item) {
		var parent = this;
		while (parent = parent._parent) {
			if (parent == item)
				return true;
		}
		return false;
	},

	isAncestor: function(item) {
		return item ? item.isDescendant(this) : false;
	},

	isSibling: function(item) {
		return this._parent === item._parent;
	},

	isGroupedWith: function(item) {
		var parent = this._parent;
		while (parent) {
			if (parent._parent
				&& /^(Group|Layer|CompoundPath)$/.test(parent._class)
				&& item.isDescendant(parent))
					return true;
			parent = parent._parent;
		}
		return false;
	},

	translate: function() {
		var mx = new Matrix();
		return this.transform(mx.translate.apply(mx, arguments));
	},

	rotate: function(angle ) {
		return this.transform(new Matrix().rotate(angle,
				Point.read(arguments, 1, { readNull: true })
					|| this.getPosition(true)));
	}
}, Base.each(['scale', 'shear', 'skew'], function(name) {
	this[name] = function() {
		var point = Point.read(arguments),
			center = Point.read(arguments, 0, { readNull: true });
		return this.transform(new Matrix()[name](point,
				center || this.getPosition(true)));
	};
}, {

}), {
	transform: function(matrix, _applyMatrix, _applyRecursively,
			_setApplyMatrix) {
		if (matrix && matrix.isIdentity())
			matrix = null;
		var _matrix = this._matrix,
			applyMatrix = (_applyMatrix || this._applyMatrix)
					&& ((!_matrix.isIdentity() || matrix)
						|| _applyMatrix && _applyRecursively && this._children);
		if (!matrix && !applyMatrix)
			return this;
		if (matrix)
			_matrix.preConcatenate(matrix);
		if (applyMatrix = applyMatrix && this._transformContent(_matrix,
					_applyRecursively, _setApplyMatrix)) {
			var pivot = this._pivot,
				style = this._style,
				fillColor = style.getFillColor(true),
				strokeColor = style.getStrokeColor(true);
			if (pivot)
				_matrix._transformPoint(pivot, pivot, true);
			if (fillColor)
				fillColor.transform(_matrix);
			if (strokeColor)
				strokeColor.transform(_matrix);
			_matrix.reset(true);
			if (_setApplyMatrix && this._canApplyMatrix)
				this._applyMatrix = true;
		}
		var bounds = this._bounds,
			position = this._position;
		this._changed(9);
		var decomp = bounds && matrix && matrix.decompose();
		if (decomp && !decomp.shearing && decomp.rotation % 90 === 0) {
			for (var key in bounds) {
				var rect = bounds[key];
				if (applyMatrix || !rect._internal)
					matrix._transformBounds(rect, rect);
			}
			var getter = this._boundsGetter,
				rect = bounds[getter && getter.getBounds || getter || 'getBounds'];
			if (rect)
				this._position = rect.getCenter(true);
			this._bounds = bounds;
		} else if (matrix && position) {
			this._position = matrix._transformPoint(position, position);
		}
		return this;
	},

	_transformContent: function(matrix, applyRecursively, setApplyMatrix) {
		var children = this._children;
		if (children) {
			for (var i = 0, l = children.length; i < l; i++)
				children[i].transform(matrix, true, applyRecursively,
						setApplyMatrix);
			return true;
		}
	},

	globalToLocal: function() {
		return this.getGlobalMatrix(true)._inverseTransform(
				Point.read(arguments));
	},

	localToGlobal: function() {
		return this.getGlobalMatrix(true)._transformPoint(
				Point.read(arguments));
	},

	parentToLocal: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	},

	localToParent: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	fitBounds: function(rectangle, fill) {
		rectangle = Rectangle.read(arguments);
		var bounds = this.getBounds(),
			itemRatio = bounds.height / bounds.width,
			rectRatio = rectangle.height / rectangle.width,
			scale = (fill ? itemRatio > rectRatio : itemRatio < rectRatio)
					? rectangle.width / bounds.width
					: rectangle.height / bounds.height,
			newBounds = new Rectangle(new Point(),
					new Size(bounds.width * scale, bounds.height * scale));
		newBounds.setCenter(rectangle.getCenter());
		this.setBounds(newBounds);
	},

	_setStyles: function(ctx) {
		var style = this._style,
			fillColor = style.getFillColor(),
			strokeColor = style.getStrokeColor(),
			shadowColor = style.getShadowColor();
		if (fillColor)
			ctx.fillStyle = fillColor.toCanvasStyle(ctx);
		if (strokeColor) {
			var strokeWidth = style.getStrokeWidth();
			if (strokeWidth > 0) {
				ctx.strokeStyle = strokeColor.toCanvasStyle(ctx);
				ctx.lineWidth = strokeWidth;
				var strokeJoin = style.getStrokeJoin(),
					strokeCap = style.getStrokeCap(),
					miterLimit = style.getMiterLimit();
				if (strokeJoin)
					ctx.lineJoin = strokeJoin;
				if (strokeCap)
					ctx.lineCap = strokeCap;
				if (miterLimit)
					ctx.miterLimit = miterLimit;
				if (paper.support.nativeDash) {
					var dashArray = style.getDashArray(),
						dashOffset = style.getDashOffset();
					if (dashArray && dashArray.length) {
						if ('setLineDash' in ctx) {
							ctx.setLineDash(dashArray);
							ctx.lineDashOffset = dashOffset;
						} else {
							ctx.mozDash = dashArray;
							ctx.mozDashOffset = dashOffset;
						}
					}
				}
			}
		}
		if (shadowColor) {
			var shadowBlur = style.getShadowBlur();
			if (shadowBlur > 0) {
				ctx.shadowColor = shadowColor.toCanvasStyle(ctx);
				ctx.shadowBlur = shadowBlur;
				var offset = this.getShadowOffset();
				ctx.shadowOffsetX = offset.x;
				ctx.shadowOffsetY = offset.y;
			}
		}
	},

	draw: function(ctx, param, parentStrokeMatrix) {
		var updateVersion = this._updateVersion = this._project._updateVersion;
		if (!this._visible || this._opacity === 0)
			return;
		var matrices = param.matrices,
			viewMatrix = param.viewMatrix,
			matrix = this._matrix,
			globalMatrix = matrices[matrices.length - 1].chain(matrix);
		if (!globalMatrix.isInvertible())
			return;

		function getViewMatrix(matrix) {
			return viewMatrix ? viewMatrix.chain(matrix) : matrix;
		}

		matrices.push(globalMatrix);
		if (param.updateMatrix) {
			globalMatrix._updateVersion = updateVersion;
			this._globalMatrix = globalMatrix;
		}

		var blendMode = this._blendMode,
			opacity = this._opacity,
			normalBlend = blendMode === 'normal',
			nativeBlend = BlendMode.nativeModes[blendMode],
			direct = normalBlend && opacity === 1
					|| param.dontStart
					|| param.clip
					|| (nativeBlend || normalBlend && opacity < 1)
						&& this._canComposite(),
			pixelRatio = param.pixelRatio || 1,
			mainCtx, itemOffset, prevOffset;
		if (!direct) {
			var bounds = this.getStrokeBounds(getViewMatrix(globalMatrix));
			if (!bounds.width || !bounds.height)
				return;
			prevOffset = param.offset;
			itemOffset = param.offset = bounds.getTopLeft().floor();
			mainCtx = ctx;
			ctx = CanvasProvider.getContext(bounds.getSize().ceil().add(1)
					.multiply(pixelRatio));
			if (pixelRatio !== 1)
				ctx.scale(pixelRatio, pixelRatio);
		}
		ctx.save();
		var strokeMatrix = parentStrokeMatrix
				? parentStrokeMatrix.chain(matrix)
				: !this.getStrokeScaling(true) && getViewMatrix(globalMatrix),
			clip = !direct && param.clipItem,
			transform = !strokeMatrix || clip;
		if (direct) {
			ctx.globalAlpha = opacity;
			if (nativeBlend)
				ctx.globalCompositeOperation = blendMode;
		} else if (transform) {
			ctx.translate(-itemOffset.x, -itemOffset.y);
		}
		if (transform)
			(direct ? matrix : getViewMatrix(globalMatrix)).applyToContext(ctx);
		if (clip)
			param.clipItem.draw(ctx, param.extend({ clip: true }));
		if (strokeMatrix) {
			ctx.setTransform(pixelRatio, 0, 0, pixelRatio, 0, 0);
			var offset = param.offset;
			if (offset)
				ctx.translate(-offset.x, -offset.y);
		}
		this._draw(ctx, param, strokeMatrix);
		ctx.restore();
		matrices.pop();
		if (param.clip && !param.dontFinish)
			ctx.clip();
		if (!direct) {
			BlendMode.process(blendMode, ctx, mainCtx, opacity,
					itemOffset.subtract(prevOffset).multiply(pixelRatio));
			CanvasProvider.release(ctx);
			param.offset = prevOffset;
		}
	},

	_isUpdated: function(updateVersion) {
		var parent = this._parent;
		if (parent instanceof CompoundPath)
			return parent._isUpdated(updateVersion);
		var updated = this._updateVersion === updateVersion;
		if (!updated && parent && parent._visible
				&& parent._isUpdated(updateVersion)) {
			this._updateVersion = updateVersion;
			updated = true;
		}
		return updated;
	},

	_drawSelection: function(ctx, matrix, size, selectedItems, updateVersion) {
		if ((this._drawSelected || this._boundsSelected)
				&& this._isUpdated(updateVersion)) {
			var color = this.getSelectedColor(true)
					|| this.getLayer().getSelectedColor(true),
				mx = matrix.chain(this.getGlobalMatrix(true));
			ctx.strokeStyle = ctx.fillStyle = color
					? color.toCanvasStyle(ctx) : '#009dec';
			if (this._drawSelected)
				this._drawSelected(ctx, mx, selectedItems);
			if (this._boundsSelected) {
				var half = size / 2,
					coords = mx._transformCorners(this.getInternalBounds());
				ctx.beginPath();
				for (var i = 0; i < 8; i++)
					ctx[i === 0 ? 'moveTo' : 'lineTo'](coords[i], coords[++i]);
				ctx.closePath();
				ctx.stroke();
				for (var i = 0; i < 8; i++)
					ctx.fillRect(coords[i] - half, coords[++i] - half,
							size, size);
			}
		}
	},

	_canComposite: function() {
		return false;
	}
}, Base.each(['down', 'drag', 'up', 'move'], function(name) {
	this['removeOn' + Base.capitalize(name)] = function() {
		var hash = {};
		hash[name] = true;
		return this.removeOn(hash);
	};
}, {

	removeOn: function(obj) {
		for (var name in obj) {
			if (obj[name]) {
				var key = 'mouse' + name,
					project = this._project,
					sets = project._removeSets = project._removeSets || {};
				sets[key] = sets[key] || {};
				sets[key][this._id] = this;
			}
		}
		return this;
	}
}));

var Group = Item.extend({
	_class: 'Group',
	_selectChildren: true,
	_serializeFields: {
		children: []
	},

	initialize: function Group(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg))
			this.addChildren(Array.isArray(arg) ? arg : arguments);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 1026) {
			this._clipItem = undefined;
		}
	},

	_getClipItem: function() {
		var clipItem = this._clipItem;
		if (clipItem === undefined) {
			clipItem = null;
			for (var i = 0, l = this._children.length; i < l; i++) {
				var child = this._children[i];
				if (child._clipMask) {
					clipItem = child;
					break;
				}
			}
			this._clipItem = clipItem;
		}
		return clipItem;
	},

	isClipped: function() {
		return !!this._getClipItem();
	},

	setClipped: function(clipped) {
		var child = this.getFirstChild();
		if (child)
			child.setClipMask(clipped);
	},

	_draw: function(ctx, param) {
		var clip = param.clip,
			clipItem = !clip && this._getClipItem(),
			draw = true;
		param = param.extend({ clipItem: clipItem, clip: false });
		if (clip) {
			if (this._currentPath) {
				ctx.currentPath = this._currentPath;
				draw = false;
			} else {
				ctx.beginPath();
				param.dontStart = param.dontFinish = true;
			}
		} else if (clipItem) {
			clipItem.draw(ctx, param.extend({ clip: true }));
		}
		if (draw) {
			for (var i = 0, l = this._children.length; i < l; i++) {
				var item = this._children[i];
				if (item !== clipItem)
					item.draw(ctx, param);
			}
		}
		if (clip) {
			this._currentPath = ctx.currentPath;
		}
	}
});

var Layer = Group.extend({
	_class: 'Layer',

	initialize: function Layer(arg) {
		var props = Base.isPlainObject(arg)
				? new Base(arg)
				: { children: Array.isArray(arg) ? arg : arguments },
			insert = props.insert;
		props.insert = false;
		Group.call(this, props);
		if (insert || insert === undefined) {
			this._project.addChild(this);
			this.activate();
		}
	},

	_remove: function _remove(notifySelf, notifyParent) {
		if (this._parent)
			return _remove.base.call(this, notifySelf, notifyParent);
		if (this._index != null) {
			var project = this._project;
			if (project._activeLayer === this)
				project._activeLayer = this.getNextSibling()
						|| this.getPreviousSibling();
			Base.splice(project.layers, null, this._index, 1);
			this._installEvents(false);
			if (notifySelf && project._changes)
				this._changed(5);
			if (notifyParent) {
				project._needsUpdate = true;
			}
			return true;
		}
		return false;
	},

	getNextSibling: function getNextSibling() {
		return this._parent ? getNextSibling.base.call(this)
				: this._project.layers[this._index + 1] || null;
	},

	getPreviousSibling: function getPreviousSibling() {
		return this._parent ? getPreviousSibling.base.call(this)
				: this._project.layers[this._index - 1] || null;
	},

	isInserted: function isInserted() {
		return this._parent ? isInserted.base.call(this) : this._index != null;
	},

	activate: function() {
		this._project._activeLayer = this;
	},

	_insertSibling: function _insertSibling(index, item, _preserve) {
		return !this._parent
				? this._project.insertChild(index, item, _preserve)
				: _insertSibling.base.call(this, index, item, _preserve);
	}
});

var Shape = Item.extend({
	_class: 'Shape',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsSelected: true,
	_serializeFields: {
		type: null,
		size: null,
		radius: null
	},

	initialize: function Shape(props) {
		this._initialize(props);
	},

	_equals: function(item) {
		return this._type === item._type
			&& this._size.equals(item._size)
			&& Base.equals(this._radius, item._radius);
	},

	clone: function(insert) {
		var copy = new Shape(Item.NO_INSERT);
		copy.setType(this._type);
		copy.setSize(this._size);
		copy.setRadius(this._radius);
		return this._clone(copy, insert);
	},

	getType: function() {
		return this._type;
	},

	setType: function(type) {
		this._type = type;
	},

	getShape: '#getType',
	setShape: '#setType',

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size.width, size.height, this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!this._size) {
			this._size = size.clone();
		} else if (!this._size.equals(size)) {
			var type = this._type,
				width = size.width,
				height = size.height;
			if (type === 'rectangle') {
				var radius = Size.min(this._radius, size.divide(2));
				this._radius.set(radius.width, radius.height);
			} else if (type === 'circle') {
				width = height = (width + height) / 2;
				this._radius = width / 2;
			} else if (type === 'ellipse') {
				this._radius.set(width / 2, height / 2);
			}
			this._size.set(width, height);
			this._changed(9);
		}
	},

	getRadius: function() {
		var rad = this._radius;
		return this._type === 'circle'
				? rad
				: new LinkedSize(rad.width, rad.height, this, 'setRadius');
	},

	setRadius: function(radius) {
		var type = this._type;
		if (type === 'circle') {
			if (radius === this._radius)
				return;
			var size = radius * 2;
			this._radius = radius;
			this._size.set(size, size);
		} else {
			radius = Size.read(arguments);
			if (!this._radius) {
				this._radius = radius.clone();
			} else {
				if (this._radius.equals(radius))
					return;
				this._radius.set(radius.width, radius.height);
				if (type === 'rectangle') {
					var size = Size.max(this._size, radius.multiply(2));
					this._size.set(size.width, size.height);
				} else if (type === 'ellipse') {
					this._size.set(radius.width * 2, radius.height * 2);
				}
			}
		}
		this._changed(9);
	},

	isEmpty: function() {
		return false;
	},

	toPath: function(insert) {
		var path = this._clone(new Path[Base.capitalize(this._type)]({
			center: new Point(),
			size: this._size,
			radius: this._radius,
			insert: false
		}), insert);
		if (paper.settings.applyMatrix)
			path.setApplyMatrix(true);
		return path;
	},

	_draw: function(ctx, param, strokeMatrix) {
		var style = this._style,
			hasFill = style.hasFill(),
			hasStroke = style.hasStroke(),
			dontPaint = param.dontFinish || param.clip,
			untransformed = !strokeMatrix;
		if (hasFill || hasStroke || dontPaint) {
			var type = this._type,
				radius = this._radius,
				isCircle = type === 'circle';
			if (!param.dontStart)
				ctx.beginPath();
			if (untransformed && isCircle) {
				ctx.arc(0, 0, radius, 0, Math.PI * 2, true);
			} else {
				var rx = isCircle ? radius : radius.width,
					ry = isCircle ? radius : radius.height,
					size = this._size,
					width = size.width,
					height = size.height;
				if (untransformed && type === 'rectangle' && rx === 0 && ry === 0) {
					ctx.rect(-width / 2, -height / 2, width, height);
				} else {
					var x = width / 2,
						y = height / 2,
						kappa = 1 - 0.5522847498307936,
						cx = rx * kappa,
						cy = ry * kappa,
						c = [
							-x, -y + ry,
							-x, -y + cy,
							-x + cx, -y,
							-x + rx, -y,
							x - rx, -y,
							x - cx, -y,
							x, -y + cy,
							x, -y + ry,
							x, y - ry,
							x, y - cy,
							x - cx, y,
							x - rx, y,
							-x + rx, y,
							-x + cx, y,
							-x, y - cy,
							-x, y - ry
						];
					if (strokeMatrix)
						strokeMatrix.transform(c, c, 32);
					ctx.moveTo(c[0], c[1]);
					ctx.bezierCurveTo(c[2], c[3], c[4], c[5], c[6], c[7]);
					if (x !== rx)
						ctx.lineTo(c[8], c[9]);
					ctx.bezierCurveTo(c[10], c[11], c[12], c[13], c[14], c[15]);
					if (y !== ry)
						ctx.lineTo(c[16], c[17]);
					ctx.bezierCurveTo(c[18], c[19], c[20], c[21], c[22], c[23]);
					if (x !== rx)
						ctx.lineTo(c[24], c[25]);
					ctx.bezierCurveTo(c[26], c[27], c[28], c[29], c[30], c[31]);
				}
			}
			ctx.closePath();
		}
		if (!dontPaint && (hasFill || hasStroke)) {
			this._setStyles(ctx);
			if (hasFill) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (hasStroke)
				ctx.stroke();
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		if (getter !== 'getBounds' && this.hasStroke())
			rect = rect.expand(this.getStrokeWidth());
		return matrix ? matrix._transformBounds(rect) : rect;
	}
},
new function() {
	function getCornerCenter(that, point, expand) {
		var radius = that._radius;
		if (!radius.isZero()) {
			var halfSize = that._size.divide(2);
			for (var i = 0; i < 4; i++) {
				var dir = new Point(i & 1 ? 1 : -1, i > 1 ? 1 : -1),
					corner = dir.multiply(halfSize),
					center = corner.subtract(dir.multiply(radius)),
					rect = new Rectangle(corner, center);
				if ((expand ? rect.expand(expand) : rect).contains(point))
					return center;
			}
		}
	}

	function getEllipseRadius(point, radius) {
		var angle = point.getAngleInRadians(),
			width = radius.width * 2,
			height = radius.height * 2,
			x = width * Math.sin(angle),
			y = height * Math.cos(angle);
		return width * height / (2 * Math.sqrt(x * x + y * y));
	}

	return {
		_contains: function _contains(point) {
			if (this._type === 'rectangle') {
				var center = getCornerCenter(this, point);
				return center
						? point.subtract(center).divide(this._radius)
							.getLength() <= 1
						: _contains.base.call(this, point);
			} else {
				return point.divide(this.size).getLength() <= 0.5;
			}
		},

		_hitTestSelf: function _hitTestSelf(point, options) {
			var hit = false;
			if (this.hasStroke()) {
				var type = this._type,
					radius = this._radius,
					strokeWidth = this.getStrokeWidth() + 2 * options.tolerance;
				if (type === 'rectangle') {
					var center = getCornerCenter(this, point, strokeWidth);
					if (center) {
						var pt = point.subtract(center);
						hit = 2 * Math.abs(pt.getLength()
								- getEllipseRadius(pt, radius)) <= strokeWidth;
					} else {
						var rect = new Rectangle(this._size).setCenter(0, 0),
							outer = rect.expand(strokeWidth),
							inner = rect.expand(-strokeWidth);
						hit = outer._containsPoint(point)
								&& !inner._containsPoint(point);
					}
				} else {
					if (type === 'ellipse')
						radius = getEllipseRadius(point, radius);
					hit = 2 * Math.abs(point.getLength() - radius)
							<= strokeWidth;
				}
			}
			return hit
					? new HitResult('stroke', this)
					: _hitTestSelf.base.apply(this, arguments);
		}
	};
}, {

statics: new function() {
	function createShape(type, point, size, radius, args) {
		var item = new Shape(Base.getNamed(args));
		item._type = type;
		item._size = size;
		item._radius = radius;
		return item.translate(point);
	}

	return {
		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createShape('circle', center, new Size(radius * 2), radius,
					arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.min(Size.readNamed(arguments, 'radius'),
						rect.getSize(true).divide(2));
			return createShape('rectangle', rect.getCenter(true),
					rect.getSize(true), radius, arguments);
		},

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments),
				radius = ellipse.radius;
			return createShape('ellipse', ellipse.center, radius.multiply(2),
					radius, arguments);
		},

		_readEllipse: function(args) {
			var center,
				radius;
			if (Base.hasNamed(args, 'radius')) {
				center = Point.readNamed(args, 'center');
				radius = Size.readNamed(args, 'radius');
			} else {
				var rect = Rectangle.readNamed(args, 'rectangle');
				center = rect.getCenter(true);
				radius = rect.getSize(true).divide(2);
			}
			return { center: center, radius: radius };
		}
	};
}});

var Raster = Item.extend({
	_class: 'Raster',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: 'getBounds',
	_boundsSelected: true,
	_serializeFields: {
		crossOrigin: null,
		source: null
	},

	initialize: function Raster(object, position) {
		if (!this._initialize(object,
				position !== undefined && Point.read(arguments, 1))) {
			if (typeof object === 'string') {
				this.setSource(object);
			} else {
				this.setImage(object);
			}
		}
		if (!this._size) {
			this._size = new Size();
			this._loaded = false;
		}
	},

	_equals: function(item) {
		return this.getSource() === item.getSource();
	},

	clone: function(insert) {
		var copy = new Raster(Item.NO_INSERT),
			image = this._image,
			canvas = this._canvas;
		if (image) {
			copy.setImage(image);
		} else if (canvas) {
			var copyCanvas = CanvasProvider.getCanvas(this._size);
			copyCanvas.getContext('2d').drawImage(canvas, 0, 0);
			copy.setImage(copyCanvas);
		}
		copy._crossOrigin = this._crossOrigin;
		return this._clone(copy, insert);
	},

	getSize: function() {
		var size = this._size;
		return new LinkedSize(size ? size.width : 0, size ? size.height : 0,
				this, 'setSize');
	},

	setSize: function() {
		var size = Size.read(arguments);
		if (!size.equals(this._size)) {
			if (size.width > 0 && size.height > 0) {
				var element = this.getElement();
				this.setImage(CanvasProvider.getCanvas(size));
				if (element)
					this.getContext(true).drawImage(element, 0, 0,
							size.width, size.height);
			} else {
				if (this._canvas)
					CanvasProvider.release(this._canvas);
				this._size = size.clone();
			}
		}
	},

	getWidth: function() {
		return this._size ? this._size.width : 0;
	},

	setWidth: function(width) {
		this.setSize(width, this.getHeight());
	},

	getHeight: function() {
		return this._size ? this._size.height : 0;
	},

	setHeight: function(height) {
		this.setSize(this.getWidth(), height);
	},

	isEmpty: function() {
		var size = this._size;
		return !size || size.width === 0 && size.height === 0;
	},

	getResolution: function() {
		var matrix = this._matrix,
			orig = new Point(0, 0).transform(matrix),
			u = new Point(1, 0).transform(matrix).subtract(orig),
			v = new Point(0, 1).transform(matrix).subtract(orig);
		return new Size(
			72 / u.getLength(),
			72 / v.getLength()
		);
	},

	getPpi: '#getResolution',

	getImage: function() {
		return this._image;
	},

	setImage: function(image) {
		if (this._canvas)
			CanvasProvider.release(this._canvas);
		if (image && image.getContext) {
			this._image = null;
			this._canvas = image;
			this._loaded = true;
		} else {
			this._image = image;
			this._canvas = null;
			this._loaded = image && image.complete;
		}
		this._size = new Size(
				image ? image.naturalWidth || image.width : 0,
				image ? image.naturalHeight || image.height : 0);
		this._context = null;
		this._changed(521);
	},

	getCanvas: function() {
		if (!this._canvas) {
			var ctx = CanvasProvider.getContext(this._size);
			try {
				if (this._image)
					ctx.drawImage(this._image, 0, 0);
				this._canvas = ctx.canvas;
			} catch (e) {
				CanvasProvider.release(ctx);
			}
		}
		return this._canvas;
	},

	setCanvas: '#setImage',

	getContext: function(modify) {
		if (!this._context)
			this._context = this.getCanvas().getContext('2d');
		if (modify) {
			this._image = null;
			this._changed(513);
		}
		return this._context;
	},

	setContext: function(context) {
		this._context = context;
	},

	getSource: function() {
		return this._image && this._image.src || this.toDataURL();
	},

	setSource: function(src) {
		var that = this,
			crossOrigin = this._crossOrigin,
			image;

		function loaded() {
			var view = that.getView();
			if (view) {
				paper = view._scope;
				that.setImage(image);
				that.emit('load');
				view.update();
			}
		}

		image = document.getElementById(src) || new Image();
		if (crossOrigin)
			image.crossOrigin = crossOrigin;
		if (image.naturalWidth && image.naturalHeight) {
			setTimeout(loaded, 0);
		} else {
			DomEvent.add(image, { load: loaded });
			if (!image.src)
				image.src = src;
		}
		this.setImage(image);
	},

	getCrossOrigin: function() {
		return this._image && this._image.crossOrigin || this._crossOrigin || '';
	},

	setCrossOrigin: function(crossOrigin) {
		this._crossOrigin = crossOrigin;
		if (this._image)
			this._image.crossOrigin = crossOrigin;
	},

	getElement: function() {
		return this._canvas || this._loaded && this._image;
	}
}, {
	beans: false,

	getSubCanvas: function() {
		var rect = Rectangle.read(arguments),
			ctx = CanvasProvider.getContext(rect.getSize());
		ctx.drawImage(this.getCanvas(), rect.x, rect.y,
				rect.width, rect.height, 0, 0, rect.width, rect.height);
		return ctx.canvas;
	},

	getSubRaster: function() {
		var rect = Rectangle.read(arguments),
			raster = new Raster(Item.NO_INSERT);
		raster.setImage(this.getSubCanvas(rect));
		raster.translate(rect.getCenter().subtract(this.getSize().divide(2)));
		raster._matrix.preConcatenate(this._matrix);
		raster.insertAbove(this);
		return raster;
	},

	toDataURL: function() {
		var src = this._image && this._image.src;
		if (/^data:/.test(src))
			return src;
		var canvas = this.getCanvas();
		return canvas ? canvas.toDataURL.apply(canvas, arguments) : null;
	},

	drawImage: function(image ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).drawImage(image, point.x, point.y);
	},

	getAverageColor: function(object) {
		var bounds, path;
		if (!object) {
			bounds = this.getBounds();
		} else if (object instanceof PathItem) {
			path = object;
			bounds = object.getBounds();
		} else if (object.width) {
			bounds = new Rectangle(object);
		} else if (object.x) {
			bounds = new Rectangle(object.x - 0.5, object.y - 0.5, 1, 1);
		}
		var sampleSize = 32,
			width = Math.min(bounds.width, sampleSize),
			height = Math.min(bounds.height, sampleSize);
		var ctx = Raster._sampleContext;
		if (!ctx) {
			ctx = Raster._sampleContext = CanvasProvider.getContext(
					new Size(sampleSize));
		} else {
			ctx.clearRect(0, 0, sampleSize + 1, sampleSize + 1);
		}
		ctx.save();
		var matrix = new Matrix()
				.scale(width / bounds.width, height / bounds.height)
				.translate(-bounds.x, -bounds.y);
		matrix.applyToContext(ctx);
		if (path)
			path.draw(ctx, new Base({ clip: true, matrices: [matrix] }));
		this._matrix.applyToContext(ctx);
		var element = this.getElement(),
			size = this._size;
		if (element)
			ctx.drawImage(element, -size.width / 2, -size.height / 2);
		ctx.restore();
		var pixels = ctx.getImageData(0.5, 0.5, Math.ceil(width),
				Math.ceil(height)).data,
			channels = [0, 0, 0],
			total = 0;
		for (var i = 0, l = pixels.length; i < l; i += 4) {
			var alpha = pixels[i + 3];
			total += alpha;
			alpha /= 255;
			channels[0] += pixels[i] * alpha;
			channels[1] += pixels[i + 1] * alpha;
			channels[2] += pixels[i + 2] * alpha;
		}
		for (var i = 0; i < 3; i++)
			channels[i] /= total;
		return total ? Color.read(channels) : null;
	},

	getPixel: function() {
		var point = Point.read(arguments);
		var data = this.getContext().getImageData(point.x, point.y, 1, 1).data;
		return new Color('rgb', [data[0] / 255, data[1] / 255, data[2] / 255],
				data[3] / 255);
	},

	setPixel: function() {
		var point = Point.read(arguments),
			color = Color.read(arguments),
			components = color._convert('rgb'),
			alpha = color._alpha,
			ctx = this.getContext(true),
			imageData = ctx.createImageData(1, 1),
			data = imageData.data;
		data[0] = components[0] * 255;
		data[1] = components[1] * 255;
		data[2] = components[2] * 255;
		data[3] = alpha != null ? alpha * 255 : 255;
		ctx.putImageData(imageData, point.x, point.y);
	},

	createImageData: function() {
		var size = Size.read(arguments);
		return this.getContext().createImageData(size.width, size.height);
	},

	getImageData: function() {
		var rect = Rectangle.read(arguments);
		if (rect.isEmpty())
			rect = new Rectangle(this._size);
		return this.getContext().getImageData(rect.x, rect.y,
				rect.width, rect.height);
	},

	setImageData: function(data ) {
		var point = Point.read(arguments, 1);
		this.getContext(true).putImageData(data, point.x, point.y);
	},

	_getBounds: function(getter, matrix) {
		var rect = new Rectangle(this._size).setCenter(0, 0);
		return matrix ? matrix._transformBounds(rect) : rect;
	},

	_hitTestSelf: function(point) {
		if (this._contains(point)) {
			var that = this;
			return new HitResult('pixel', that, {
				offset: point.add(that._size.divide(2)).round(),
				color: {
					get: function() {
						return that.getPixel(this.offset);
					}
				}
			});
		}
	},

	_draw: function(ctx) {
		var element = this.getElement();
		if (element) {
			ctx.globalAlpha = this._opacity;
			ctx.drawImage(element,
					-this._size.width / 2, -this._size.height / 2);
		}
	},

	_canComposite: function() {
		return true;
	}
});

var PlacedSymbol = Item.extend({
	_class: 'PlacedSymbol',
	_applyMatrix: false,
	_canApplyMatrix: false,
	_boundsGetter: { getBounds: 'getStrokeBounds' },
	_boundsSelected: true,
	_serializeFields: {
		symbol: null
	},

	initialize: function PlacedSymbol(arg0, arg1) {
		if (!this._initialize(arg0,
				arg1 !== undefined && Point.read(arguments, 1)))
			this.setSymbol(arg0 instanceof Symbol ? arg0 : new Symbol(arg0));
	},

	_equals: function(item) {
		return this._symbol === item._symbol;
	},

	getSymbol: function() {
		return this._symbol;
	},

	setSymbol: function(symbol) {
		this._symbol = symbol;
		this._changed(9);
	},

	clone: function(insert) {
		var copy = new PlacedSymbol(Item.NO_INSERT);
		copy.setSymbol(this._symbol);
		return this._clone(copy, insert);
	},

	isEmpty: function() {
		return this._symbol._definition.isEmpty();
	},

	_getBounds: function(getter, matrix, cacheItem) {
		var definition = this.symbol._definition;
		return definition._getCachedBounds(getter,
				matrix && matrix.chain(definition._matrix), cacheItem);
	},

	_hitTestSelf: function(point, options) {
		var res = this._symbol._definition._hitTest(point, options);
		if (res)
			res.item = this;
		return res;
	},

	_draw: function(ctx, param) {
		this.symbol._definition.draw(ctx, param);
	}

});

var HitResult = Base.extend({
	_class: 'HitResult',

	initialize: function HitResult(type, item, values) {
		this.type = type;
		this.item = item;
		if (values) {
			values.enumerable = true;
			this.inject(values);
		}
	},

	statics: {
		getOptions: function(options) {
			return new Base({
				type: null,
				tolerance: paper.settings.hitTolerance,
				fill: !options,
				stroke: !options,
				segments: !options,
				handles: false,
				ends: false,
				center: false,
				bounds: false,
				guides: false,
				selected: false
			}, options);
		}
	}
});

var Segment = Base.extend({
	_class: 'Segment',
	beans: true,

	initialize: function Segment(arg0, arg1, arg2, arg3, arg4, arg5) {
		var count = arguments.length,
			point, handleIn, handleOut;
		if (count === 0) {
		} else if (count === 1) {
			if ('point' in arg0) {
				point = arg0.point;
				handleIn = arg0.handleIn;
				handleOut = arg0.handleOut;
			} else {
				point = arg0;
			}
		} else if (count === 2 && typeof arg0 === 'number') {
			point = arguments;
		} else if (count <= 3) {
			point = arg0;
			handleIn = arg1;
			handleOut = arg2;
		} else {
			point = arg0 !== undefined ? [ arg0, arg1 ] : null;
			handleIn = arg2 !== undefined ? [ arg2, arg3 ] : null;
			handleOut = arg4 !== undefined ? [ arg4, arg5 ] : null;
		}
		new SegmentPoint(point, this, '_point');
		new SegmentPoint(handleIn, this, '_handleIn');
		new SegmentPoint(handleOut, this, '_handleOut');
	},

	_serialize: function(options) {
		return Base.serialize(this.hasHandles()
				? [this._point, this._handleIn, this._handleOut]
				: this._point,
				options, true);
	},

	_changed: function(point) {
		var path = this._path;
		if (!path)
			return;
		var curves = path._curves,
			index = this._index,
			curve;
		if (curves) {
			if ((!point || point === this._point || point === this._handleIn)
					&& (curve = index > 0 ? curves[index - 1] : path._closed
						? curves[curves.length - 1] : null))
				curve._changed();
			if ((!point || point === this._point || point === this._handleOut)
					&& (curve = curves[index]))
				curve._changed();
		}
		path._changed(25);
	},

	getPoint: function() {
		return this._point;
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this._point.set(point.x, point.y);
	},

	getHandleIn: function() {
		return this._handleIn;
	},

	setHandleIn: function() {
		var point = Point.read(arguments);
		this._handleIn.set(point.x, point.y);
	},

	getHandleOut: function() {
		return this._handleOut;
	},

	setHandleOut: function() {
		var point = Point.read(arguments);
		this._handleOut.set(point.x, point.y);
	},

	hasHandles: function() {
		return !this._handleIn.isZero() || !this._handleOut.isZero();
	},

	clearHandles: function() {
		this._handleIn.set(0, 0);
		this._handleOut.set(0, 0);
	},

	_selectionState: 0,

	isSelected: function(_point) {
		var state = this._selectionState;
		return !_point ? !!(state & 7)
			: _point === this._point ? !!(state & 4)
			: _point === this._handleIn ? !!(state & 1)
			: _point === this._handleOut ? !!(state & 2)
			: false;
	},

	setSelected: function(selected, _point) {
		var path = this._path,
			selected = !!selected,
			state = this._selectionState,
			oldState = state,
			flag = !_point ? 7
					: _point === this._point ? 4
					: _point === this._handleIn ? 1
					: _point === this._handleOut ? 2
					: 0;
		if (selected) {
			state |= flag;
		} else {
			state &= ~flag;
		}
		this._selectionState = state;
		if (path && state !== oldState) {
			path._updateSelection(this, oldState, state);
			path._changed(129);
		}
	},

	getIndex: function() {
		return this._index !== undefined ? this._index : null;
	},

	getPath: function() {
		return this._path || null;
	},

	getCurve: function() {
		var path = this._path,
			index = this._index;
		if (path) {
			if (index > 0 && !path._closed
					&& index === path._segments.length - 1)
				index--;
			return path.getCurves()[index] || null;
		}
		return null;
	},

	getLocation: function() {
		var curve = this.getCurve();
		return curve
				? new CurveLocation(curve, this === curve._segment1 ? 0 : 1)
				: null;
	},

	getNext: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index + 1]
				|| this._path._closed && segments[0]) || null;
	},

	getPrevious: function() {
		var segments = this._path && this._path._segments;
		return segments && (segments[this._index - 1]
				|| this._path._closed && segments[segments.length - 1]) || null;
	},

	isFirst: function() {
		return this._index === 0;
	},

	isLast: function() {
		var path = this._path;
		return path && this._index === path._segments.length - 1 || false;
	},

	reverse: function() {
		var handleIn = this._handleIn,
			handleOut = this._handleOut,
			inX = handleIn._x,
			inY = handleIn._y;
		handleIn.set(handleOut._x, handleOut._y);
		handleOut.set(inX, inY);
	},

	reversed: function() {
		return new Segment(this._point, this._handleOut, this._handleIn);
	},

	remove: function() {
		return this._path ? !!this._path.removeSegment(this._index) : false;
	},

	clone: function() {
		return new Segment(this._point, this._handleIn, this._handleOut);
	},

	equals: function(segment) {
		return segment === this || segment && this._class === segment._class
				&& this._point.equals(segment._point)
				&& this._handleIn.equals(segment._handleIn)
				&& this._handleOut.equals(segment._handleOut)
				|| false;
	},

	toString: function() {
		var parts = [ 'point: ' + this._point ];
		if (!this._handleIn.isZero())
			parts.push('handleIn: ' + this._handleIn);
		if (!this._handleOut.isZero())
			parts.push('handleOut: ' + this._handleOut);
		return '{ ' + parts.join(', ') + ' }';
	},

	transform: function(matrix) {
		this._transformCoordinates(matrix, new Array(6), true);
		this._changed();
	},

	_transformCoordinates: function(matrix, coords, change) {
		var point = this._point,
			handleIn = !change || !this._handleIn.isZero()
					? this._handleIn : null,
			handleOut = !change || !this._handleOut.isZero()
					? this._handleOut : null,
			x = point._x,
			y = point._y,
			i = 2;
		coords[0] = x;
		coords[1] = y;
		if (handleIn) {
			coords[i++] = handleIn._x + x;
			coords[i++] = handleIn._y + y;
		}
		if (handleOut) {
			coords[i++] = handleOut._x + x;
			coords[i++] = handleOut._y + y;
		}
		if (matrix) {
			matrix._transformCoordinates(coords, coords, i / 2);
			x = coords[0];
			y = coords[1];
			if (change) {
				point._x = x;
				point._y = y;
				i  = 2;
				if (handleIn) {
					handleIn._x = coords[i++] - x;
					handleIn._y = coords[i++] - y;
				}
				if (handleOut) {
					handleOut._x = coords[i++] - x;
					handleOut._y = coords[i++] - y;
				}
			} else {
				if (!handleIn) {
					coords[i++] = x;
					coords[i++] = y;
				}
				if (!handleOut) {
					coords[i++] = x;
					coords[i++] = y;
				}
			}
		}
		return coords;
	}
});

var SegmentPoint = Point.extend({
	initialize: function SegmentPoint(point, owner, key) {
		var x, y, selected;
		if (!point) {
			x = y = 0;
		} else if ((x = point[0]) !== undefined) {
			y = point[1];
		} else {
			var pt = point;
			if ((x = pt.x) === undefined) {
				pt = Point.read(arguments);
				x = pt.x;
			}
			y = pt.y;
			selected = pt.selected;
		}
		this._x = x;
		this._y = y;
		this._owner = owner;
		owner[key] = this;
		if (selected)
			this.setSelected(true);
	},

	set: function(x, y) {
		this._x = x;
		this._y = y;
		this._owner._changed(this);
		return this;
	},

	_serialize: function(options) {
		var f = options.formatter,
			x = f.number(this._x),
			y = f.number(this._y);
		return this.isSelected()
				? { x: x, y: y, selected: true }
				: [x, y];
	},

	getX: function() {
		return this._x;
	},

	setX: function(x) {
		this._x = x;
		this._owner._changed(this);
	},

	getY: function() {
		return this._y;
	},

	setY: function(y) {
		this._y = y;
		this._owner._changed(this);
	},

	isZero: function() {
		return Numerical.isZero(this._x) && Numerical.isZero(this._y);
	},

	setSelected: function(selected) {
		this._owner.setSelected(selected, this);
	},

	isSelected: function() {
		return this._owner.isSelected(this);
	}
});

var Curve = Base.extend({
	_class: 'Curve',

	initialize: function Curve(arg0, arg1, arg2, arg3, arg4, arg5, arg6, arg7) {
		var count = arguments.length,
			seg1, seg2,
			point1, point2,
			handle1, handle2;
		if (count === 3) {
			this._path = arg0;
			seg1 = arg1;
			seg2 = arg2;
		} else if (count === 0) {
			seg1 = new Segment();
			seg2 = new Segment();
		} else if (count === 1) {
			if ('segment1' in arg0) {
				seg1 = new Segment(arg0.segment1);
				seg2 = new Segment(arg0.segment2);
			} else if ('point1' in arg0) {
				point1 = arg0.point1;
				handle1 = arg0.handle1;
				handle2 = arg0.handle2;
				point2 = arg0.point2;
			} else if (Array.isArray(arg0)) {
				point1 = [arg0[0], arg0[1]];
				point2 = [arg0[6], arg0[7]];
				handle1 = [arg0[2] - arg0[0], arg0[3] - arg0[1]];
				handle2 = [arg0[4] - arg0[6], arg0[5] - arg0[7]];
			}
		} else if (count === 2) {
			seg1 = new Segment(arg0);
			seg2 = new Segment(arg1);
		} else if (count === 4) {
			point1 = arg0;
			handle1 = arg1;
			handle2 = arg2;
			point2 = arg3;
		} else if (count === 8) {
			point1 = [arg0, arg1];
			point2 = [arg6, arg7];
			handle1 = [arg2 - arg0, arg3 - arg1];
			handle2 = [arg4 - arg6, arg5 - arg7];
		}
		this._segment1 = seg1 || new Segment(point1, null, handle1);
		this._segment2 = seg2 || new Segment(point2, handle2, null);
	},

	_serialize: function(options) {
		return Base.serialize(this.hasHandles()
				? [this.getPoint1(), this.getHandle1(), this.getHandle2(),
					this.getPoint2()]
				: [this.getPoint1(), this.getPoint2()],
				options, true);
	},

	_changed: function() {
		this._length = this._bounds = undefined;
	},

	clone: function() {
		return new Curve(this._segment1, this._segment2);
	},

	toString: function() {
		var parts = [ 'point1: ' + this._segment1._point ];
		if (!this._segment1._handleOut.isZero())
			parts.push('handle1: ' + this._segment1._handleOut);
		if (!this._segment2._handleIn.isZero())
			parts.push('handle2: ' + this._segment2._handleIn);
		parts.push('point2: ' + this._segment2._point);
		return '{ ' + parts.join(', ') + ' }';
	},

	remove: function() {
		var removed = false;
		if (this._path) {
			var segment2 = this._segment2,
				handleOut = segment2._handleOut;
			removed = segment2.remove();
			if (removed)
				this._segment1._handleOut.set(handleOut.x, handleOut.y);
		}
		return removed;
	},

	getPoint1: function() {
		return this._segment1._point;
	},

	setPoint1: function() {
		var point = Point.read(arguments);
		this._segment1._point.set(point.x, point.y);
	},

	getPoint2: function() {
		return this._segment2._point;
	},

	setPoint2: function() {
		var point = Point.read(arguments);
		this._segment2._point.set(point.x, point.y);
	},

	getHandle1: function() {
		return this._segment1._handleOut;
	},

	setHandle1: function() {
		var point = Point.read(arguments);
		this._segment1._handleOut.set(point.x, point.y);
	},

	getHandle2: function() {
		return this._segment2._handleIn;
	},

	setHandle2: function() {
		var point = Point.read(arguments);
		this._segment2._handleIn.set(point.x, point.y);
	},

	getSegment1: function() {
		return this._segment1;
	},

	getSegment2: function() {
		return this._segment2;
	},

	getPath: function() {
		return this._path;
	},

	getIndex: function() {
		return this._segment1._index;
	},

	getNext: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index + 1]
				|| this._path._closed && curves[0]) || null;
	},

	getPrevious: function() {
		var curves = this._path && this._path._curves;
		return curves && (curves[this._segment1._index - 1]
				|| this._path._closed && curves[curves.length - 1]) || null;
	},

	isFirst: function() {
		return this._segment1._index === 0;
	},

	isLast: function() {
		var path = this._path;
		return path && this._segment1._index === path._curves.length - 1
				|| false;
	},

	isSelected: function() {
		return this.getPoint1().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getHandle2().isSelected()
				&& this.getPoint2().isSelected();
	},

	setSelected: function(selected) {
		this.getPoint1().setSelected(selected);
		this.getHandle1().setSelected(selected);
		this.getHandle2().setSelected(selected);
		this.getPoint2().setSelected(selected);
	},

	getValues: function(matrix) {
		return Curve.getValues(this._segment1, this._segment2, matrix);
	},

	getPoints: function() {
		var coords = this.getValues(),
			points = [];
		for (var i = 0; i < 8; i += 2)
			points.push(new Point(coords[i], coords[i + 1]));
		return points;
	},

	getLength: function() {
		if (this._length == null)
			this._length = Curve.getLength(this.getValues(), 0, 1);
		return this._length;
	},

	getArea: function() {
		return Curve.getArea(this.getValues());
	},

	getLine: function() {
		return new Line(this._segment1._point, this._segment2._point);
	},

	getPart: function(from, to) {
		return new Curve(Curve.getPart(this.getValues(), from, to));
	},

	getPartLength: function(from, to) {
		return Curve.getLength(this.getValues(), from, to);
	},

	getIntersections: function(curve) {
		return Curve._getIntersections(this.getValues(),
				curve && curve !== this ? curve.getValues() : null,
				this, curve, [], {});
	},

	_getParameter: function(offset, isParameter) {
		return isParameter
				? offset
				: offset && offset.curve === this
					? offset.parameter
					: offset === undefined && isParameter === undefined
						? 0.5
						: this.getParameterAt(offset, 0);
	},

	divide: function(offset, isParameter, _setHandles) {
		var parameter = this._getParameter(offset, isParameter),
			tMin = 4e-7,
			tMax = 1 - tMin,
			res = null;
		if (parameter >= tMin && parameter <= tMax) {
			var parts = Curve.subdivide(this.getValues(), parameter),
				left = parts[0],
				right = parts[1],
				setHandles = _setHandles || this.hasHandles(),
				segment1 = this._segment1,
				segment2 = this._segment2,
				path = this._path;
			if (setHandles) {
				segment1._handleOut.set(left[2] - left[0],
						left[3] - left[1]);
				segment2._handleIn.set(right[4] - right[6],
						right[5] - right[7]);
			}
			var x = left[6], y = left[7],
				segment = new Segment(new Point(x, y),
						setHandles && new Point(left[4] - x, left[5] - y),
						setHandles && new Point(right[2] - x, right[3] - y));
			if (path) {
				path.insert(segment1._index + 1, segment);
				res = this.getNext();
			} else {
				this._segment2 = segment;
				res = new Curve(segment, segment2);
			}
		}
		return res;
	},

	split: function(offset, isParameter) {
		return this._path
			? this._path.split(this._segment1._index,
					this._getParameter(offset, isParameter))
			: null;
	},

	reversed: function() {
		return new Curve(this._segment2.reversed(), this._segment1.reversed());
	},

	clearHandles: function() {
		this._segment1._handleOut.set(0, 0);
		this._segment2._handleIn.set(0, 0);
	},

statics: {
	getValues: function(segment1, segment2, matrix) {
		var p1 = segment1._point,
			h1 = segment1._handleOut,
			h2 = segment2._handleIn,
			p2 = segment2._point,
			values = [
				p1._x, p1._y,
				p1._x + h1._x, p1._y + h1._y,
				p2._x + h2._x, p2._y + h2._y,
				p2._x, p2._y
			];
		if (matrix)
			matrix._transformCoordinates(values, values, 4);
		return values;
	},

	subdivide: function(v, t) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7];
		if (t === undefined)
			t = 0.5;
		var u = 1 - t,
			p3x = u * p1x + t * c1x, p3y = u * p1y + t * c1y,
			p4x = u * c1x + t * c2x, p4y = u * c1y + t * c2y,
			p5x = u * c2x + t * p2x, p5y = u * c2y + t * p2y,
			p6x = u * p3x + t * p4x, p6y = u * p3y + t * p4y,
			p7x = u * p4x + t * p5x, p7y = u * p4y + t * p5y,
			p8x = u * p6x + t * p7x, p8y = u * p6y + t * p7y;
		return [
			[p1x, p1y, p3x, p3y, p6x, p6y, p8x, p8y],
			[p8x, p8y, p7x, p7y, p5x, p5y, p2x, p2y]
		];
	},

	solveCubic: function (v, coord, val, roots, min, max) {
		var p1 = v[coord],
			c1 = v[coord + 2],
			c2 = v[coord + 4],
			p2 = v[coord + 6],
			c = 3 * (c1 - p1),
			b = 3 * (c2 - c1) - c,
			a = p2 - p1 - c - b;
		return Numerical.solveCubic(a, b, c, p1 - val, roots, min, max);
	},

	getParameterOf: function(v, point) {
		var p1 = new Point(v[0], v[1]),
			p2 = new Point(v[6], v[7]),
			epsilon = 1e-12,
			t = point.isClose(p1, epsilon) ? 0
			  : point.isClose(p2, epsilon) ? 1
			  : null;
		if (t !== null)
			return t;
		var coords = [point.x, point.y],
			roots = [],
			geomEpsilon = 2e-7;
		for (var c = 0; c < 2; c++) {
			var count = Curve.solveCubic(v, c, coords[c], roots, 0, 1);
			for (var i = 0; i < count; i++) {
				t = roots[i];
				if (point.isClose(Curve.getPoint(v, t), geomEpsilon))
					return t;
			}
		}
		return point.isClose(p1, geomEpsilon) ? 0
			 : point.isClose(p2, geomEpsilon) ? 1
			 : null;
	},

	getNearestParameter: function(v, point) {
		if (Curve.isStraight(v)) {
			var p1x = v[0], p1y = v[1],
				p2x = v[6], p2y = v[7],
				vx = p2x - p1x, vy = p2y - p1y,
				det = vx * vx + vy * vy;
			if (det === 0)
				return 0;
			var u = ((point.x - p1x) * vx + (point.y - p1y) * vy) / det;
			return u < 1e-12 ? 0
				 : u > 0.999999999999 ? 1
				 : Curve.getParameterOf(v,
					new Point(p1x + u * vx, p1y + u * vy));
		}

		var count = 100,
			minDist = Infinity,
			minT = 0;

		function refine(t) {
			if (t >= 0 && t <= 1) {
				var dist = point.getDistance(Curve.getPoint(v, t), true);
				if (dist < minDist) {
					minDist = dist;
					minT = t;
					return true;
				}
			}
		}

		for (var i = 0; i <= count; i++)
			refine(i / count);

		var step = 1 / (count * 2);
		while (step > 4e-7) {
			if (!refine(minT - step) && !refine(minT + step))
				step /= 2;
		}
		return minT;
	},

	getPart: function(v, from, to) {
		var flip = from > to;
		if (flip) {
			var tmp = from;
			from = to;
			to = tmp;
		}
		if (from > 0)
			v = Curve.subdivide(v, from)[1];
		if (to < 1)
			v = Curve.subdivide(v, (to - from) / (1 - from))[0];
		return flip
				? [v[6], v[7], v[4], v[5], v[2], v[3], v[0], v[1]]
				: v;
	},

	hasHandles: function(v) {
		var isZero = Numerical.isZero;
		return !(isZero(v[0] - v[2]) && isZero(v[1] - v[3])
				&& isZero(v[4] - v[6]) && isZero(v[5] - v[7]));
	},

	isFlatEnough: function(v, tolerance) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			ux = 3 * c1x - 2 * p1x - p2x,
			uy = 3 * c1y - 2 * p1y - p2y,
			vx = 3 * c2x - 2 * p2x - p1x,
			vy = 3 * c2y - 2 * p2y - p1y;
		return Math.max(ux * ux, vx * vx) + Math.max(uy * uy, vy * vy)
				< 10 * tolerance * tolerance;
	},

	getArea: function(v) {
		var p1x = v[0], p1y = v[1],
			p2x = v[6], p2y = v[7],
			h1x = (v[2] + p1x) / 2,
			h1y = (v[3] + p1y) / 2,
			h2x = (v[4] + v[6]) / 2,
			h2y = (v[5] + v[7]) / 2;
		return 6 * ((p1x - h1x) * (h1y + p1y)
				  + (h1x - h2x) * (h2y + h1y)
				  + (h2x - p2x) * (p2y + h2y)) / 10;
	},

	getBounds: function(v) {
		var min = v.slice(0, 2),
			max = min.slice(),
			roots = [0, 0];
		for (var i = 0; i < 2; i++)
			Curve._addBounds(v[i], v[i + 2], v[i + 4], v[i + 6],
					i, 0, min, max, roots);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	_addBounds: function(v0, v1, v2, v3, coord, padding, min, max, roots) {
		function add(value, padding) {
			var left = value - padding,
				right = value + padding;
			if (left < min[coord])
				min[coord] = left;
			if (right > max[coord])
				max[coord] = right;
		}
		var a = 3 * (v1 - v2) - v0 + v3,
			b = 2 * (v0 + v2) - 4 * v1,
			c = v1 - v0,
			count = Numerical.solveQuadratic(a, b, c, roots),
			tMin = 4e-7,
			tMax = 1 - tMin;
		add(v3, 0);
		for (var i = 0; i < count; i++) {
			var t = roots[i],
				u = 1 - t;
			if (tMin < t && t < tMax)
				add(u * u * u * v0
					+ 3 * u * u * t * v1
					+ 3 * u * t * t * v2
					+ t * t * t * v3,
					padding);
		}
	}
}}, Base.each(
	['getBounds', 'getStrokeBounds', 'getHandleBounds', 'getRoughBounds'],
	function(name) {
		this[name] = function() {
			if (!this._bounds)
				this._bounds = {};
			var bounds = this._bounds[name];
			if (!bounds) {
				var path = this._path;
				bounds = this._bounds[name] = Path[name](
						[this._segment1, this._segment2], false,
						path && path.getStyle());
			}
			return bounds.clone();
		};
	},
{

}), Base.each({
	isStraight: function(l, h1, h2) {
		if (h1.isZero() && h2.isZero()) {
			return true;
		} else if (l.isZero()) {
			return false;
		} else if (h1.isCollinear(l) && h2.isCollinear(l)) {
			var div = l.dot(l),
				p1 = l.dot(h1) / div,
				p2 = l.dot(h2) / div;
			return p1 >= 0 && p1 <= 1 && p2 <= 0 && p2 >= -1;
		}
		return false;
	},

	isLinear: function(l, h1, h2) {
		var third = l.divide(3);
		return h1.equals(third) && h2.negate().equals(third);
	}
}, function(test, name) {
	this[name] = function() {
		var seg1 = this._segment1,
			seg2 = this._segment2;
		return test(seg2._point.subtract(seg1._point),
				seg1._handleOut, seg2._handleIn);
	};

	this.statics[name] = function(v) {
		var p1x = v[0], p1y = v[1],
			p2x = v[6], p2y = v[7];
		return test(new Point(p2x - p1x, p2y - p1y),
				new Point(v[2] - p1x, v[3] - p1y),
				new Point(v[4] - p2x, v[5] - p2y));
	};
}, {
	statics: {},

	hasHandles: function() {
		return !this._segment1._handleOut.isZero()
				|| !this._segment2._handleIn.isZero();
	},

	isCollinear: function(curve) {
		return curve && this.isStraight() && curve.isStraight()
				&& this.getLine().isCollinear(curve.getLine());
	},

	isHorizontal: function() {
		return this.isStraight() && Math.abs(this.getTangentAt(0.5, true).y)
				< 1e-7;
	},

	isVertical: function() {
		return this.isStraight() && Math.abs(this.getTangentAt(0.5, true).x)
				< 1e-7;
	}
}), {
	beans: false,

	getParameterAt: function(offset, start) {
		return Curve.getParameterAt(this.getValues(), offset, start);
	},

	getParameterOf: function() {
		return Curve.getParameterOf(this.getValues(), Point.read(arguments));
	},

	getLocationAt: function(offset, isParameter) {
		var t = isParameter ? offset : this.getParameterAt(offset);
		return t != null && t >= 0 && t <= 1
				? new CurveLocation(this, t)
				: null;
	},

	getLocationOf: function() {
		return this.getLocationAt(this.getParameterOf(Point.read(arguments)),
				true);
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			values = this.getValues(),
			t = Curve.getNearestParameter(values, point),
			pt = Curve.getPoint(values, t);
		return new CurveLocation(this, t, pt, null, point.getDistance(pt));
	},

	getNearestPoint: function() {
		return this.getNearestLocation.apply(this, arguments).getPoint();
	}

},
new function() {
	var methods = ['getPoint', 'getTangent', 'getNormal', 'getWeightedTangent',
		'getWeightedNormal', 'getCurvature'];
	return Base.each(methods,
	function(name) {
		this[name + 'At'] = function(offset, isParameter) {
			var values = this.getValues();
			return Curve[name](values, isParameter ? offset
					: Curve.getParameterAt(values, offset, 0));
		};
	}, {
		statics: {
			evaluateMethods: methods
		}
	})
},
new function() {

	function getLengthIntegrand(v) {
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],

			ax = 9 * (c1x - c2x) + 3 * (p2x - p1x),
			bx = 6 * (p1x + c2x) - 12 * c1x,
			cx = 3 * (c1x - p1x),

			ay = 9 * (c1y - c2y) + 3 * (p2y - p1y),
			by = 6 * (p1y + c2y) - 12 * c1y,
			cy = 3 * (c1y - p1y);

		return function(t) {
			var dx = (ax * t + bx) * t + cx,
				dy = (ay * t + by) * t + cy;
			return Math.sqrt(dx * dx + dy * dy);
		};
	}

	function getIterations(a, b) {
		return Math.max(2, Math.min(16, Math.ceil(Math.abs(b - a) * 32)));
	}

	function evaluate(v, t, type, normalized) {
		if (t == null || t < 0 || t > 1)
			return null;
		var p1x = v[0], p1y = v[1],
			c1x = v[2], c1y = v[3],
			c2x = v[4], c2y = v[5],
			p2x = v[6], p2y = v[7],
			tMin = 4e-7,
			tMax = 1 - tMin,
			x, y;

		if (type === 0 && (t < tMin || t > tMax)) {
			var isZero = t < tMin;
			x = isZero ? p1x : p2x;
			y = isZero ? p1y : p2y;
		} else {
			var cx = 3 * (c1x - p1x),
				bx = 3 * (c2x - c1x) - cx,
				ax = p2x - p1x - cx - bx,

				cy = 3 * (c1y - p1y),
				by = 3 * (c2y - c1y) - cy,
				ay = p2y - p1y - cy - by;
			if (type === 0) {
				x = ((ax * t + bx) * t + cx) * t + p1x;
				y = ((ay * t + by) * t + cy) * t + p1y;
			} else {
				if (t < tMin) {
					x = cx;
					y = cy;
				} else if (t > tMax) {
					x = 3 * (p2x - c2x);
					y = 3 * (p2y - c2y);
				} else {
					x = (3 * ax * t + 2 * bx) * t + cx;
					y = (3 * ay * t + 2 * by) * t + cy;
				}
				if (normalized) {
					if (x === 0 && y === 0 && (t < tMin || t > tMax)) {
						x = c2x - c1x;
						y = c2y - c1y;
					}
					var len = Math.sqrt(x * x + y * y);
					if (len) {
						x /= len;
						y /= len;
					}
				}
				if (type === 3) {
					var x2 = 6 * ax * t + 2 * bx,
						y2 = 6 * ay * t + 2 * by,
						d = Math.pow(x * x + y * y, 3 / 2);
					x = d !== 0 ? (x * y2 - y * x2) / d : 0;
					y = 0;
				}
			}
		}
		return type === 2 ? new Point(y, -x) : new Point(x, y);
	}

	return { statics: {

		getLength: function(v, a, b) {
			if (a === undefined)
				a = 0;
			if (b === undefined)
				b = 1;
			if (a === 0 && b === 1 && Curve.isStraight(v)) {
				var dx = v[6] - v[0],
					dy = v[7] - v[1];
				return Math.sqrt(dx * dx + dy * dy);
			}
			var ds = getLengthIntegrand(v);
			return Numerical.integrate(ds, a, b, getIterations(a, b));
		},

		getParameterAt: function(v, offset, start) {
			if (start === undefined)
				start = offset < 0 ? 1 : 0
			if (offset === 0)
				return start;
			var abs = Math.abs,
				forward = offset > 0,
				a = forward ? start : 0,
				b = forward ? 1 : start,
				ds = getLengthIntegrand(v),
				rangeLength = Numerical.integrate(ds, a, b,
						getIterations(a, b));
			if (abs(offset - rangeLength) < 1e-12) {
				return forward ? b : a;
			} else if (abs(offset) > rangeLength) {
				return null;
			}
			var guess = offset / rangeLength,
				length = 0;
			function f(t) {
				length += Numerical.integrate(ds, start, t,
						getIterations(start, t));
				start = t;
				return length - offset;
			}
			return Numerical.findRoot(f, ds, start + guess, a, b, 32,
					1e-12);
		},

		getPoint: function(v, t) {
			return evaluate(v, t, 0, false);
		},

		getTangent: function(v, t) {
			return evaluate(v, t, 1, true);
		},

		getWeightedTangent: function(v, t) {
			return evaluate(v, t, 1, false);
		},

		getNormal: function(v, t) {
			return evaluate(v, t, 2, true);
		},

		getWeightedNormal: function(v, t) {
			return evaluate(v, t, 2, false);
		},

		getCurvature: function(v, t) {
			return evaluate(v, t, 3, false).x;
		}
	}};
},
new function() {

	function addLocation(locations, param, v1, c1, t1, p1, v2, c2, t2, p2,
			overlap) {
		var startConnected = param.startConnected,
			endConnected = param.endConnected,
			tMin = 4e-7,
			tMax = 1 - tMin;
		if (t1 == null)
			t1 = Curve.getParameterOf(v1, p1);
		if (t1 !== null && t1 >= (startConnected ? tMin : 0) &&
			t1 <= (endConnected ? tMax : 1)) {
			if (t2 == null)
				t2 = Curve.getParameterOf(v2, p2);
			if (t2 !== null && t2 >= (endConnected ? tMin : 0) &&
				t2 <= (startConnected ? tMax : 1)) {
				var renormalize = param.renormalize;
				if (renormalize) {
					var res = renormalize(t1, t2);
					t1 = res[0];
					t2 = res[1];
				}
				var loc1 = new CurveLocation(c1, t1,
						p1 || Curve.getPoint(v1, t1), overlap),
					loc2 = new CurveLocation(c2, t2,
						p2 || Curve.getPoint(v2, t2), overlap),
					flip = loc1.getPath() === loc2.getPath()
						&& loc1.getIndex() > loc2.getIndex(),
					loc = flip ? loc2 : loc1,
					include = param.include;
				loc1._intersection = loc2;
				loc2._intersection = loc1;
				if (!include || include(loc)) {
					CurveLocation.insert(locations, loc, true);
				}
			}
		}
	}

	function addCurveIntersections(v1, v2, c1, c2, locations, param,
			tMin, tMax, uMin, uMax, oldTDiff, reverse, recursion) {
		if (++recursion >= 24)
			return;
		var q0x = v2[0], q0y = v2[1], q3x = v2[6], q3y = v2[7],
			getSignedDistance = Line.getSignedDistance,
			d1 = getSignedDistance(q0x, q0y, q3x, q3y, v2[2], v2[3]),
			d2 = getSignedDistance(q0x, q0y, q3x, q3y, v2[4], v2[5]),
			factor = d1 * d2 > 0 ? 3 / 4 : 4 / 9,
			dMin = factor * Math.min(0, d1, d2),
			dMax = factor * Math.max(0, d1, d2),
			dp0 = getSignedDistance(q0x, q0y, q3x, q3y, v1[0], v1[1]),
			dp1 = getSignedDistance(q0x, q0y, q3x, q3y, v1[2], v1[3]),
			dp2 = getSignedDistance(q0x, q0y, q3x, q3y, v1[4], v1[5]),
			dp3 = getSignedDistance(q0x, q0y, q3x, q3y, v1[6], v1[7]),
			hull = getConvexHull(dp0, dp1, dp2, dp3),
			top = hull[0],
			bottom = hull[1],
			tMinClip,
			tMaxClip;
		if ((tMinClip = clipConvexHull(top, bottom, dMin, dMax)) == null ||
			(tMaxClip = clipConvexHull(top.reverse(), bottom.reverse(),
				dMin, dMax)) == null)
			return;
		v1 = Curve.getPart(v1, tMinClip, tMaxClip);
		var tDiff = tMaxClip - tMinClip,
			tMinNew = tMin + (tMax - tMin) * tMinClip,
			tMaxNew = tMin + (tMax - tMin) * tMaxClip;
		if (oldTDiff > 0.5 && tDiff > 0.5) {
			if (tMaxNew - tMinNew > uMax - uMin) {
				var parts = Curve.subdivide(v1, 0.5),
					t = tMinNew + (tMaxNew - tMinNew) / 2;
				addCurveIntersections(
					v2, parts[0], c2, c1, locations, param,
					uMin, uMax, tMinNew, t, tDiff, !reverse, recursion);
				addCurveIntersections(
					v2, parts[1], c2, c1, locations, param,
					uMin, uMax, t, tMaxNew, tDiff, !reverse, recursion);
			} else {
				var parts = Curve.subdivide(v2, 0.5),
					t = uMin + (uMax - uMin) / 2;
				addCurveIntersections(
					parts[0], v1, c2, c1, locations, param,
					uMin, t, tMinNew, tMaxNew, tDiff, !reverse, recursion);
				addCurveIntersections(
					parts[1], v1, c2, c1, locations, param,
					t, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
			}
		} else if (Math.max(uMax - uMin, tMaxNew - tMinNew)
				< 1e-7) {
			var t1 = tMinNew + (tMaxNew - tMinNew) / 2,
				t2 = uMin + (uMax - uMin) / 2;
			v1 = c1.getValues();
			v2 = c2.getValues();
			addLocation(locations, param,
				reverse ? v2 : v1, reverse ? c2 : c1, reverse ? t2 : t1, null,
				reverse ? v1 : v2, reverse ? c1 : c2, reverse ? t1 : t2, null);
		} else if (tDiff > 1e-12) {
			addCurveIntersections(v2, v1, c2, c1, locations, param,
					uMin, uMax, tMinNew, tMaxNew, tDiff, !reverse, recursion);
		}
	}

	function getConvexHull(dq0, dq1, dq2, dq3) {
		var p0 = [ 0, dq0 ],
			p1 = [ 1 / 3, dq1 ],
			p2 = [ 2 / 3, dq2 ],
			p3 = [ 1, dq3 ],
			dist1 = dq1 - (2 * dq0 + dq3) / 3,
			dist2 = dq2 - (dq0 + 2 * dq3) / 3,
			hull;
		if (dist1 * dist2 < 0) {
			hull = [[p0, p1, p3], [p0, p2, p3]];
		} else {
			var distRatio = dist1 / dist2;
			hull = [
				distRatio >= 2 ? [p0, p1, p3]
				: distRatio <= .5 ? [p0, p2, p3]
				: [p0, p1, p2, p3],
				[p0, p3]
			];
		}
		return (dist1 || dist2) < 0 ? hull.reverse() : hull;
	}

	function clipConvexHull(hullTop, hullBottom, dMin, dMax) {
		if (hullTop[0][1] < dMin) {
			return clipConvexHullPart(hullTop, true, dMin);
		} else if (hullBottom[0][1] > dMax) {
			return clipConvexHullPart(hullBottom, false, dMax);
		} else {
			return hullTop[0][0];
		}
	}

	function clipConvexHullPart(part, top, threshold) {
		var px = part[0][0],
			py = part[0][1];
		for (var i = 1, l = part.length; i < l; i++) {
			var qx = part[i][0],
				qy = part[i][1];
			if (top ? qy >= threshold : qy <= threshold) {
				return qy === threshold ? qx
						: px + (threshold - py) * (qx - px) / (qy - py);
			}
			px = qx;
			py = qy;
		}
		return null;
	}

	function addCurveLineIntersections(v1, v2, c1, c2, locations, param) {
		var flip = Curve.isStraight(v1),
			vc = flip ? v2 : v1,
			vl = flip ? v1 : v2,
			lx1 = vl[0], ly1 = vl[1],
			lx2 = vl[6], ly2 = vl[7],
			ldx = lx2 - lx1,
			ldy = ly2 - ly1,
			angle = Math.atan2(-ldy, ldx),
			sin = Math.sin(angle),
			cos = Math.cos(angle),
			rvc = [];
		for(var i = 0; i < 8; i += 2) {
			var x = vc[i] - lx1,
				y = vc[i + 1] - ly1;
			rvc.push(
				x * cos - y * sin,
				x * sin + y * cos);
		}
		var roots = [],
			count = Curve.solveCubic(rvc, 1, 0, roots, 0, 1);
		for (var i = 0; i < count; i++) {
			var tc = roots[i],
				pc = Curve.getPoint(vc, tc),
				tl = Curve.getParameterOf(vl, pc);
			if (tl !== null) {
				var pl = Curve.getPoint(vl, tl),
					t1 = flip ? tl : tc,
					t2 = flip ? tc : tl;
				if (!param.endConnected || t2 > Numerical.CURVETIME_EPSILON) {
					addLocation(locations, param,
							v1, c1, t1, flip ? pl : pc,
							v2, c2, t2, flip ? pc : pl);
				}
			}
		}
	}

	function addLineIntersection(v1, v2, c1, c2, locations, param) {
		var pt = Line.intersect(
				v1[0], v1[1], v1[6], v1[7],
				v2[0], v2[1], v2[6], v2[7]);
		if (pt) {
			addLocation(locations, param, v1, c1, null, pt, v2, c2, null, pt);
		}
	}

	return { statics: {
		_getIntersections: function(v1, v2, c1, c2, locations, param) {
			if (!v2) {
				return Curve._getSelfIntersection(v1, c1, locations, param);
			}
			var c1p1x = v1[0], c1p1y = v1[1],
				c1p2x = v1[6], c1p2y = v1[7],
				c2p1x = v2[0], c2p1y = v2[1],
				c2p2x = v2[6], c2p2y = v2[7],
				c1s1x = (3 * v1[2] + c1p1x) / 4,
				c1s1y = (3 * v1[3] + c1p1y) / 4,
				c1s2x = (3 * v1[4] + c1p2x) / 4,
				c1s2y = (3 * v1[5] + c1p2y) / 4,
				c2s1x = (3 * v2[2] + c2p1x) / 4,
				c2s1y = (3 * v2[3] + c2p1y) / 4,
				c2s2x = (3 * v2[4] + c2p2x) / 4,
				c2s2y = (3 * v2[5] + c2p2y) / 4,
				min = Math.min,
				max = Math.max;
			if (!(	max(c1p1x, c1s1x, c1s2x, c1p2x) >=
					min(c2p1x, c2s1x, c2s2x, c2p2x) &&
					min(c1p1x, c1s1x, c1s2x, c1p2x) <=
					max(c2p1x, c2s1x, c2s2x, c2p2x) &&
					max(c1p1y, c1s1y, c1s2y, c1p2y) >=
					min(c2p1y, c2s1y, c2s2y, c2p2y) &&
					min(c1p1y, c1s1y, c1s2y, c1p2y) <=
					max(c2p1y, c2s1y, c2s2y, c2p2y)))
				return locations;
			if (!param.startConnected && !param.endConnected) {
				var overlaps = Curve.getOverlaps(v1, v2);
				if (overlaps) {
					for (var i = 0; i < 2; i++) {
						var overlap = overlaps[i];
						addLocation(locations, param,
							v1, c1, overlap[0], null,
							v2, c2, overlap[1], null, true);
					}
					return locations;
				}
			}

			var straight1 = Curve.isStraight(v1),
				straight2 = Curve.isStraight(v2),
				straight = straight1 && straight2,
				epsilon = 1e-12,
				before = locations.length;
			(straight
				? addLineIntersection
				: straight1 || straight2
					? addCurveLineIntersections
					: addCurveIntersections)(
						v1, v2, c1, c2, locations, param,
						0, 1, 0, 1, 0, false, 0);
			if (straight && locations.length > before)
				return locations;
			var c1p1 = new Point(c1p1x, c1p1y),
				c1p2 = new Point(c1p2x, c1p2y),
				c2p1 = new Point(c2p1x, c2p1y),
				c2p2 = new Point(c2p2x, c2p2y);
			if (c1p1.isClose(c2p1, epsilon))
				addLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 0, c2p1);
			if (!param.startConnected && c1p1.isClose(c2p2, epsilon))
				addLocation(locations, param, v1, c1, 0, c1p1, v2, c2, 1, c2p2);
			if (!param.endConnected && c1p2.isClose(c2p1, epsilon))
				addLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 0, c2p1);
			if (c1p2.isClose(c2p2, epsilon))
				addLocation(locations, param, v1, c1, 1, c1p2, v2, c2, 1, c2p2);
			return locations;
		},

		_getSelfIntersection: function(v1, c1, locations, param) {
			var p1x = v1[0], p1y = v1[1],
				h1x = v1[2], h1y = v1[3],
				h2x = v1[4], h2y = v1[5],
				p2x = v1[6], p2y = v1[7];
			var line = new Line(p1x, p1y, p2x, p2y, false),
				side1 = line.getSide(new Point(h1x, h1y), true),
				side2 = line.getSide(new Point(h2x, h2y), true);
			if (side1 === side2) {
				var edgeSum = (p1x - h2x) * (h1y - p2y)
							+ (h1x - p2x) * (h2y - p1y);
				if (edgeSum * side1 > 0)
					return locations;
			}
			var ax = p2x - 3 * h2x + 3 * h1x - p1x,
				bx = h2x - 2 * h1x + p1x,
				cx = h1x - p1x,
				ay = p2y - 3 * h2y + 3 * h1y - p1y,
				by = h2y - 2 * h1y + p1y,
				cy = h1y - p1y,
				ac = ay * cx - ax * cy,
				ab = ay * bx - ax * by,
				bc = by * cx - bx * cy;
			if (ac * ac - 4 * ab * bc < 0) {
				var roots = [],
					tSplit,
					count = Numerical.solveCubic(
							ax * ax	 + ay * ay,
							3 * (ax * bx + ay * by),
							2 * (bx * bx + by * by) + ax * cx + ay * cy,
							bx * cx + by * cy,
							roots, 0, 1);
				if (count > 0) {
					for (var i = 0, maxCurvature = 0; i < count; i++) {
						var curvature = Math.abs(
								c1.getCurvatureAt(roots[i], true));
						if (curvature > maxCurvature) {
							maxCurvature = curvature;
							tSplit = roots[i];
						}
					}
					var parts = Curve.subdivide(v1, tSplit);
					param.endConnected = true;
					param.renormalize = function(t1, t2) {
						return [t1 * tSplit, t2 * (1 - tSplit) + tSplit];
					};
					Curve._getIntersections(parts[0], parts[1], c1, c1,
							locations, param);
				}
			}
			return locations;
		},

		getOverlaps: function(v1, v2) {
			var abs = Math.abs,
				timeEpsilon = 4e-7,
				geomEpsilon = 2e-7,
				straight1 = Curve.isStraight(v1),
				straight2 = Curve.isStraight(v2),
				straight =	straight1 && straight2;

			function getLineLengthSquared(v) {
				var x = v[6] - v[0],
					y = v[7] - v[1];
				return x * x + y * y;
			}

			if (straight) {
				var flip = getLineLengthSquared(v1) < getLineLengthSquared(v2),
					l1 = flip ? v2 : v1,
					l2 = flip ? v1 : v2,
					line = new Line(l1[0], l1[1], l1[6], l1[7]);
				if (line.getDistance(new Point(l2[0], l2[1])) > geomEpsilon ||
					line.getDistance(new Point(l2[6], l2[7])) > geomEpsilon)
					return null;
			} else if (straight1 ^ straight2) {
				return null;
			}

			var v = [v1, v2],
				pairs = [];
			for (var i = 0, t1 = 0;
					i < 2 && pairs.length < 2;
					i += t1 === 0 ? 0 : 1, t1 = t1 ^ 1) {
				var t2 = Curve.getParameterOf(v[i ^ 1], new Point(
						v[i][t1 === 0 ? 0 : 6],
						v[i][t1 === 0 ? 1 : 7]));
				if (t2 != null) {
					var pair = i === 0 ? [t1, t2] : [t2, t1];
					if (pairs.length === 0 ||
						abs(pair[0] - pairs[0][0]) > timeEpsilon &&
						abs(pair[1] - pairs[0][1]) > timeEpsilon)
						pairs.push(pair);
				}
				if (i === 1 && pairs.length === 0)
					break;
			}
			if (pairs.length !== 2) {
				pairs = null;
			} else if (!straight) {
				var o1 = Curve.getPart(v1, pairs[0][0], pairs[1][0]),
					o2 = Curve.getPart(v2, pairs[0][1], pairs[1][1]);
				if (abs(o2[2] - o1[2]) > geomEpsilon ||
					abs(o2[3] - o1[3]) > geomEpsilon ||
					abs(o2[4] - o1[4]) > geomEpsilon ||
					abs(o2[5] - o1[5]) > geomEpsilon)
					pairs = null;
			}
			return pairs;
		}
	}};
});

var CurveLocation = Base.extend({
	_class: 'CurveLocation',
	beans: true,

	initialize: function CurveLocation(curve, parameter, point,
			_overlap, _distance) {
		if (parameter > 0.9999996) {
			var next = curve.getNext();
			if (next) {
				parameter = 0;
				curve = next;
			}
		}
		this._id = UID.get(CurveLocation);
		this._setCurve(curve);
		this._parameter = parameter;
		this._point = point || curve.getPointAt(parameter, true);
		this._overlap = _overlap;
		this._distance = _distance;
		this._intersection = this._next = this._prev = null;
	},

	_setCurve: function(curve) {
		var path = curve._path;
		this._version = path ? path._version : 0;
		this._curve = curve;
		this._segment = null;
		this._segment1 = curve._segment1;
		this._segment2 = curve._segment2;
	},

	_setSegment: function(segment) {
		this._setCurve(segment.getCurve());
		this._segment = segment;
		this._parameter = segment === this._segment1 ? 0 : 1;
		this._point = segment._point.clone();
	},

	getSegment: function() {
		var curve = this.getCurve(),
			segment = this._segment;
		if (!segment) {
			var parameter = this.getParameter();
			if (parameter === 0) {
				segment = curve._segment1;
			} else if (parameter === 1) {
				segment = curve._segment2;
			} else if (parameter != null) {
				segment = curve.getPartLength(0, parameter)
					< curve.getPartLength(parameter, 1)
						? curve._segment1
						: curve._segment2;
			}
			this._segment = segment;
		}
		return segment;
	},

	getCurve: function() {
		var curve = this._curve,
			path = curve && curve._path,
			that = this;
		if (path && path._version !== this._version) {
			curve = this._parameter = this._curve = this._offset = null;
		}

		function trySegment(segment) {
			var curve = segment && segment.getCurve();
			if (curve && (that._parameter = curve.getParameterOf(that._point))
					!= null) {
				that._setCurve(curve);
				that._segment = segment;
				return curve;
			}
		}

		return curve
			|| trySegment(this._segment)
			|| trySegment(this._segment1)
			|| trySegment(this._segment2.getPrevious());
	},

	getPath: function() {
		var curve = this.getCurve();
		return curve && curve._path;
	},

	getIndex: function() {
		var curve = this.getCurve();
		return curve && curve.getIndex();
	},

	getParameter: function() {
		var curve = this.getCurve(),
			parameter = this._parameter;
		return curve && parameter == null
			? this._parameter = curve.getParameterOf(this._point)
			: parameter;
	},

	getPoint: function() {
		return this._point;
	},

	getOffset: function() {
		var offset = this._offset;
		if (offset == null) {
			offset = 0;
			var path = this.getPath(),
				index = this.getIndex();
			if (path && index != null) {
				var curves = path.getCurves();
				for (var i = 0; i < index; i++)
					offset += curves[i].getLength();
			}
			this._offset = offset += this.getCurveOffset();
		}
		return offset;
	},

	getCurveOffset: function() {
		var curve = this.getCurve(),
			parameter = this.getParameter();
		return parameter != null && curve && curve.getPartLength(0, parameter);
	},

	getIntersection: function() {
		return this._intersection;
	},

	getDistance: function() {
		return this._distance;
	},

	divide: function() {
		var curve = this.getCurve(),
			res = null;
		if (curve) {
			res = curve.divide(this.getParameter(), true);
			if (res)
				this._setSegment(res._segment1);
		}
		return res;
	},

	split: function() {
		var curve = this.getCurve();
		return curve ? curve.split(this.getParameter(), true) : null;
	},

	equals: function(loc, _ignoreOther) {
		var res = this === loc,
			epsilon = 2e-7;
		if (!res && loc instanceof CurveLocation
				&& this.getPath() === loc.getPath()
				&& this.getPoint().isClose(loc.getPoint(), epsilon)) {
			var c1 = this.getCurve(),
				c2 = loc.getCurve(),
				abs = Math.abs,
				diff = abs(
					((c1.isLast() && c2.isFirst() ? -1 : c1.getIndex())
							+ this.getParameter()) -
					((c2.isLast() && c1.isFirst() ? -1 : c2.getIndex())
							+ loc.getParameter()));
			res = (diff < 4e-7
				|| ((diff = abs(this.getOffset() - loc.getOffset())) < epsilon
					|| abs(this.getPath().getLength() - diff) < epsilon))
				&& (_ignoreOther
					|| (!this._intersection && !loc._intersection
						|| this._intersection && this._intersection.equals(
								loc._intersection, true)));
		}
		return res;
	},

	toString: function() {
		var parts = [],
			point = this.getPoint(),
			f = Formatter.instance;
		if (point)
			parts.push('point: ' + point);
		var index = this.getIndex();
		if (index != null)
			parts.push('index: ' + index);
		var parameter = this.getParameter();
		if (parameter != null)
			parts.push('parameter: ' + f.number(parameter));
		if (this._distance != null)
			parts.push('distance: ' + f.number(this._distance));
		return '{ ' + parts.join(', ') + ' }';
	},

	isTouching: function() {
		var inter = this._intersection;
		if (inter && this.getTangent().isCollinear(inter.getTangent())) {
			var curve1 = this.getCurve(),
				curve2 = inter.getCurve();
			return !(curve1.isStraight() && curve2.isStraight()
					&& curve1.getLine().intersect(curve2.getLine()));
		}
		return false;
	},

	isCrossing: function() {
		var inter = this._intersection;
		if (!inter)
			return false;
		var t1 = this.getParameter(),
			t2 = inter.getParameter(),
			tMin = 4e-7,
			tMax = 1 - tMin;
		if (t1 >= tMin && t1 <= tMax || t2 >= tMin && t2 <= tMax)
			return !this.isTouching();
		var c2 = this.getCurve(),
			c1 = c2.getPrevious(),
			c4 = inter.getCurve(),
			c3 = c4.getPrevious(),
			PI = Math.PI;
		if (!c1 || !c3)
			return false;

		function isInRange(angle, min, max) {
			return min < max
				? angle > min && angle < max
				: angle > min && angle <= PI || angle >= -PI && angle < max;
		}

		var a1 = c1.getTangentAt(tMax, true).negate().getAngleInRadians(),
			a2 = c2.getTangentAt(tMin, true).getAngleInRadians(),
			a3 = c3.getTangentAt(tMax, true).negate().getAngleInRadians(),
			a4 = c4.getTangentAt(tMin, true).getAngleInRadians();

		return (isInRange(a3, a1, a2) ^ isInRange(a4, a1, a2))
			&& (isInRange(a3, a2, a1) ^ isInRange(a4, a2, a1));
	},

	isOverlap: function() {
		return !!this._overlap;
	}
}, Base.each(Curve.evaluateMethods, function(name) {
	var get = name + 'At';
	this[name] = function() {
		var parameter = this.getParameter(),
			curve = this.getCurve();
		return parameter != null && curve && curve[get](parameter, true);
	};
}, {
	preserve: true
}),
new function() {

	function insert(locations, loc, merge) {
		var length = locations.length,
			l = 0,
			r = length - 1;

		function search(index, dir) {
			for (var i = index + dir; i >= -1 && i <= length; i += dir) {
				var loc2 = locations[((i % length) + length) % length];
				if (!loc.getPoint().isClose(loc2.getPoint(),
						2e-7))
					break;
				if (loc.equals(loc2))
					return loc2;
			}
			return null;
		}

		while (l <= r) {
			var m = (l + r) >>> 1,
				loc2 = locations[m],
				found;
			if (merge && (found = loc.equals(loc2) ? loc2
					: (search(m, -1) || search(m, 1)))) {
				if (loc._overlap) {
					found._overlap = found._intersection._overlap = true;
				}
				return found;
			}
		var path1 = loc.getPath(),
			path2 = loc2.getPath(),
			diff = path1 === path2
				? (loc.getIndex() + loc.getParameter())
				- (loc2.getIndex() + loc2.getParameter())
				: path1._id - path2._id;
			if (diff < 0) {
				r = m - 1;
			} else {
				l = m + 1;
			}
		}
		locations.splice(l, 0, loc);
		return loc;
	}

	return { statics: {
		insert: insert,

		expand: function(locations) {
			var expanded = locations.slice();
			for (var i = 0, l = locations.length; i < l; i++) {
				insert(expanded, locations[i]._intersection, false);
			}
			return expanded;
		}
	}};
});

var PathItem = Item.extend({
	_class: 'PathItem',

	initialize: function PathItem() {
	},

	getIntersections: function(path, include, _matrix, _returnFirst) {
		var self = this === path || !path,
			matrix1 = this._matrix.orNullIfIdentity(),
			matrix2 = self ? matrix1
				: (_matrix || path._matrix).orNullIfIdentity();
		if (!self && !this.getBounds(matrix1).touches(path.getBounds(matrix2)))
			return [];
		var curves1 = this.getCurves(),
			curves2 = self ? curves1 : path.getCurves(),
			length1 = curves1.length,
			length2 = self ? length1 : curves2.length,
			values2 = [],
			arrays = [],
			locations,
			path;
		for (var i = 0; i < length2; i++)
			values2[i] = curves2[i].getValues(matrix2);
		for (var i = 0; i < length1; i++) {
			var curve1 = curves1[i],
				values1 = self ? values2[i] : curve1.getValues(matrix1),
				path1 = curve1.getPath();
			if (path1 !== path) {
				path = path1;
				locations = [];
				arrays.push(locations);
			}
			if (self) {
				Curve._getSelfIntersection(values1, curve1, locations, {
					include: include,
					startConnected: length1 === 1 &&
							curve1.getPoint1().equals(curve1.getPoint2())
				});
			}
			for (var j = self ? i + 1 : 0; j < length2; j++) {
				if (_returnFirst && locations.length)
					return locations;
				var curve2 = curves2[j];
				Curve._getIntersections(
					values1, values2[j], curve1, curve2, locations,
					{
						include: include,
						startConnected: self && curve1.getPrevious() === curve2,
						endConnected: self && curve1.getNext() === curve2
					}
				);
			}
		}
		locations = [];
		for (var i = 0, l = arrays.length; i < l; i++) {
			locations.push.apply(locations, arrays[i]);
		}
		return locations;
	},

	getCrossings: function(path) {
		return this.getIntersections(path, function(inter) {
			return inter.isCrossing();
		});
	},

	_asPathItem: function() {
		return this;
	},

	setPathData: function(data) {

		var parts = data.match(/[mlhvcsqtaz][^mlhvcsqtaz]*/ig),
			coords,
			relative = false,
			previous,
			control,
			current = new Point(),
			start = new Point();

		function getCoord(index, coord) {
			var val = +coords[index];
			if (relative)
				val += current[coord];
			return val;
		}

		function getPoint(index) {
			return new Point(
				getCoord(index, 'x'),
				getCoord(index + 1, 'y')
			);
		}

		this.clear();

		for (var i = 0, l = parts && parts.length; i < l; i++) {
			var part = parts[i],
				command = part[0],
				lower = command.toLowerCase();
			coords = part.match(/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g);
			var length = coords && coords.length;
			relative = command === lower;
			if (previous === 'z' && !/[mz]/.test(lower))
				this.moveTo(current = start);
			switch (lower) {
			case 'm':
			case 'l':
				var move = lower === 'm';
				for (var j = 0; j < length; j += 2)
					this[j === 0 && move ? 'moveTo' : 'lineTo'](
							current = getPoint(j));
				control = current;
				if (move)
					start = current;
				break;
			case 'h':
			case 'v':
				var coord = lower === 'h' ? 'x' : 'y';
				for (var j = 0; j < length; j++) {
					current[coord] = getCoord(j, coord);
					this.lineTo(current);
				}
				control = current;
				break;
			case 'c':
				for (var j = 0; j < length; j += 6) {
					this.cubicCurveTo(
							getPoint(j),
							control = getPoint(j + 2),
							current = getPoint(j + 4));
				}
				break;
			case 's':
				for (var j = 0; j < length; j += 4) {
					this.cubicCurveTo(
							/[cs]/.test(previous)
									? current.multiply(2).subtract(control)
									: current,
							control = getPoint(j),
							current = getPoint(j + 2));
					previous = lower;
				}
				break;
			case 'q':
				for (var j = 0; j < length; j += 4) {
					this.quadraticCurveTo(
							control = getPoint(j),
							current = getPoint(j + 2));
				}
				break;
			case 't':
				for (var j = 0; j < length; j += 2) {
					this.quadraticCurveTo(
							control = (/[qt]/.test(previous)
									? current.multiply(2).subtract(control)
									: current),
							current = getPoint(j));
					previous = lower;
				}
				break;
			case 'a':
				for (var j = 0; j < length; j += 7) {
					this.arcTo(current = getPoint(j + 5),
							new Size(+coords[j], +coords[j + 1]),
							+coords[j + 2], +coords[j + 4], +coords[j + 3]);
				}
				break;
			case 'z':
				this.closePath(true);
				break;
			}
			previous = lower;
		}
	},

	_canComposite: function() {
		return !(this.hasFill() && this.hasStroke());
	},

	_contains: function(point) {
		var winding = this._getWinding(point, false, true);
		return !!(this.getWindingRule() === 'evenodd' ? winding & 1 : winding);
	}

});

var Path = PathItem.extend({
	_class: 'Path',
	_serializeFields: {
		segments: [],
		closed: false
	},

	initialize: function Path(arg) {
		this._closed = false;
		this._segments = [];
		this._version = 0;
		var segments = Array.isArray(arg)
			? typeof arg[0] === 'object'
				? arg
				: arguments
			: arg && (arg.size === undefined && (arg.x !== undefined
					|| arg.point !== undefined))
				? arguments
				: null;
		if (segments && segments.length > 0) {
			this.setSegments(segments);
		} else {
			this._curves = undefined;
			this._selectedSegmentState = 0;
			if (!segments && typeof arg === 'string') {
				this.setPathData(arg);
				arg = null;
			}
		}
		this._initialize(!segments && arg);
	},

	_equals: function(item) {
		return this._closed === item._closed
				&& Base.equals(this._segments, item._segments);
	},

	clone: function(insert) {
		var copy = new Path(Item.NO_INSERT);
		copy.setSegments(this._segments);
		copy._closed = this._closed;
		if (this._clockwise !== undefined)
			copy._clockwise = this._clockwise;
		return this._clone(copy, insert);
	},

	_changed: function _changed(flags) {
		_changed.base.call(this, flags);
		if (flags & 8) {
			var parent = this._parent;
			if (parent)
				parent._currentPath = undefined;
			this._length = this._area = this._clockwise = this._monoCurves =
					undefined;
			if (flags & 16) {
				this._version++;
			} else if (this._curves) {
			   for (var i = 0, l = this._curves.length; i < l; i++)
					this._curves[i]._changed();
			}
		} else if (flags & 32) {
			this._bounds = undefined;
		}
	},

	getStyle: function() {
		var parent = this._parent;
		return (parent instanceof CompoundPath ? parent : this)._style;
	},

	getSegments: function() {
		return this._segments;
	},

	setSegments: function(segments) {
		var fullySelected = this.isFullySelected();
		this._segments.length = 0;
		this._selectedSegmentState = 0;
		this._curves = undefined;
		if (segments && segments.length > 0)
			this._add(Segment.readAll(segments));
		if (fullySelected)
			this.setFullySelected(true);
	},

	getFirstSegment: function() {
		return this._segments[0];
	},

	getLastSegment: function() {
		return this._segments[this._segments.length - 1];
	},

	getCurves: function() {
		var curves = this._curves,
			segments = this._segments;
		if (!curves) {
			var length = this._countCurves();
			curves = this._curves = new Array(length);
			for (var i = 0; i < length; i++)
				curves[i] = new Curve(this, segments[i],
					segments[i + 1] || segments[0]);
		}
		return curves;
	},

	getFirstCurve: function() {
		return this.getCurves()[0];
	},

	getLastCurve: function() {
		var curves = this.getCurves();
		return curves[curves.length - 1];
	},

	isClosed: function() {
		return this._closed;
	},

	setClosed: function(closed) {
		if (this._closed != (closed = !!closed)) {
			this._closed = closed;
			if (this._curves) {
				var length = this._curves.length = this._countCurves();
				if (closed)
					this._curves[length - 1] = new Curve(this,
						this._segments[length - 1], this._segments[0]);
			}
			this._changed(25);
		}
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var segments = this._segments,
			length = segments.length,
			f = new Formatter(_precision),
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY,
			parts = [];

		function addSegment(segment, skipLine) {
			segment._transformCoordinates(_matrix, coords, false);
			curX = coords[0];
			curY = coords[1];
			if (first) {
				parts.push('M' + f.pair(curX, curY));
				first = false;
			} else {
				inX = coords[2];
				inY = coords[3];
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					if (!skipLine)
						parts.push('l' + f.pair(curX - prevX, curY - prevY));
				} else {
					parts.push('c' + f.pair(outX - prevX, outY - prevY)
							+ ' ' + f.pair(inX - prevX, inY - prevY)
							+ ' ' + f.pair(curX - prevX, curY - prevY));
				}
			}
			prevX = curX;
			prevY = curY;
			outX = coords[4];
			outY = coords[5];
		}

		if (length === 0)
			return '';

		for (var i = 0; i < length; i++)
			addSegment(segments[i]);
		if (this._closed && length > 0) {
			addSegment(segments[0], true);
			parts.push('z');
		}
		return parts.join('');
	}
}, {

	isEmpty: function() {
		return this._segments.length === 0;
	},

	_transformContent: function(matrix) {
		var coords = new Array(6);
		for (var i = 0, l = this._segments.length; i < l; i++)
			this._segments[i]._transformCoordinates(matrix, coords, true);
		return true;
	},

	_add: function(segs, index) {
		var segments = this._segments,
			curves = this._curves,
			amount = segs.length,
			append = index == null,
			index = append ? segments.length : index;
		for (var i = 0; i < amount; i++) {
			var segment = segs[i];
			if (segment._path)
				segment = segs[i] = segment.clone();
			segment._path = this;
			segment._index = index + i;
			if (segment._selectionState)
				this._updateSelection(segment, 0, segment._selectionState);
		}
		if (append) {
			segments.push.apply(segments, segs);
		} else {
			segments.splice.apply(segments, [index, 0].concat(segs));
			for (var i = index + amount, l = segments.length; i < l; i++)
				segments[i]._index = i;
		}
		if (curves) {
			var total = this._countCurves(),
				from = index + amount - 1 === total ? index - 1 : index,
				start = from,
				to = Math.min(from + amount, total);
			if (segs._curves) {
				curves.splice.apply(curves, [from, 0].concat(segs._curves));
				start += segs._curves.length;
			}
			for (var i = start; i < to; i++)
				curves.splice(i, 0, new Curve(this, null, null));
			this._adjustCurves(from, to);
		}
		this._changed(25);
		return segs;
	},

	_adjustCurves: function(from, to) {
		var segments = this._segments,
			curves = this._curves,
			curve;
		for (var i = from; i < to; i++) {
			curve = curves[i];
			curve._path = this;
			curve._segment1 = segments[i];
			curve._segment2 = segments[i + 1] || segments[0];
			curve._changed();
		}
		if (curve = curves[this._closed && from === 0 ? segments.length - 1
				: from - 1]) {
			curve._segment2 = segments[from] || segments[0];
			curve._changed();
		}
		if (curve = curves[to]) {
			curve._segment1 = segments[to];
			curve._changed();
		}
	},

	_countCurves: function() {
		var length = this._segments.length;
		return !this._closed && length > 0 ? length - 1 : length;
	},

	add: function(segment1 ) {
		return arguments.length > 1 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments))
			: this._add([ Segment.read(arguments) ])[0];
	},

	insert: function(index, segment1 ) {
		return arguments.length > 2 && typeof segment1 !== 'number'
			? this._add(Segment.readAll(arguments, 1), index)
			: this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegment: function() {
		return this._add([ Segment.read(arguments) ])[0];
	},

	insertSegment: function(index ) {
		return this._add([ Segment.read(arguments, 1) ], index)[0];
	},

	addSegments: function(segments) {
		return this._add(Segment.readAll(segments));
	},

	insertSegments: function(index, segments) {
		return this._add(Segment.readAll(segments), index);
	},

	removeSegment: function(index) {
		return this.removeSegments(index, index + 1)[0] || null;
	},

	removeSegments: function(from, to, _includeCurves) {
		from = from || 0;
		to = Base.pick(to, this._segments.length);
		var segments = this._segments,
			curves = this._curves,
			count = segments.length,
			removed = segments.splice(from, to - from),
			amount = removed.length;
		if (!amount)
			return removed;
		for (var i = 0; i < amount; i++) {
			var segment = removed[i];
			if (segment._selectionState)
				this._updateSelection(segment, segment._selectionState, 0);
			segment._index = segment._path = null;
		}
		for (var i = from, l = segments.length; i < l; i++)
			segments[i]._index = i;
		if (curves) {
			var index = from > 0 && to === count + (this._closed ? 1 : 0)
					? from - 1
					: from,
				curves = curves.splice(index, amount);
			if (_includeCurves)
				removed._curves = curves.slice(1);
			this._adjustCurves(index, index);
		}
		this._changed(25);
		return removed;
	},

	clear: '#removeSegments',

	hasHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++) {
			if (segments[i].hasHandles())
				return true;
		}
		return false;
	},

	clearHandles: function() {
		var segments = this._segments;
		for (var i = 0, l = segments.length; i < l; i++)
			segments[i].clearHandles();
	},

	getLength: function() {
		if (this._length == null) {
			var curves = this.getCurves(),
				length = 0;
			for (var i = 0, l = curves.length; i < l; i++)
				length += curves[i].getLength();
			this._length = length;
		}
		return this._length;
	},

	getArea: function() {
		if (this._area == null) {
			var segments = this._segments,
				count = segments.length,
				last = count - 1,
				area = 0;
			for (var i = 0, l = this._closed ? count : last; i < l; i++) {
				area += Curve.getArea(Curve.getValues(
						segments[i], segments[i < last ? i + 1 : 0]));
			}
			this._area = area;
		}
		return this._area;
	},

	isClockwise: function() {
		if (this._clockwise !== undefined)
			return this._clockwise;
		return this.getArea() >= 0;
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() != (clockwise = !!clockwise))
			this.reverse();
		this._clockwise = clockwise;
	},

	isFullySelected: function() {
		var length = this._segments.length;
		return this._selected && length > 0 && this._selectedSegmentState
				=== length * 7;
	},

	setFullySelected: function(selected) {
		if (selected)
			this._selectSegments(true);
		this.setSelected(selected);
	},

	setSelected: function setSelected(selected) {
		if (!selected)
			this._selectSegments(false);
		setSelected.base.call(this, selected);
	},

	_selectSegments: function(selected) {
		var length = this._segments.length;
		this._selectedSegmentState = selected
				? length * 7 : 0;
		for (var i = 0; i < length; i++)
			this._segments[i]._selectionState = selected
					? 7 : 0;
	},

	_updateSelection: function(segment, oldState, newState) {
		segment._selectionState = newState;
		var total = this._selectedSegmentState += newState - oldState;
		if (total > 0)
			this.setSelected(true);
	},

	flatten: function(maxDistance) {
		var iterator = new PathIterator(this, 64, 0.1),
			pos = 0,
			step = iterator.length / Math.ceil(iterator.length / maxDistance),
			end = iterator.length + (this._closed ? -step : step) / 2;
		var segments = [];
		while (pos <= end) {
			segments.push(new Segment(iterator.getPointAt(pos)));
			pos += step;
		}
		this.setSegments(segments);
	},

	reduce: function() {
		var curves = this.getCurves();
		for (var i = curves.length - 1; i >= 0; i--) {
			var curve = curves[i];
			if (!curve.hasHandles() && (curve.getLength() === 0
					|| curve.isCollinear(curve.getNext())))
				curve.remove();
		}
		return this;
	},

	simplify: function(tolerance) {
		if (this._segments.length > 2) {
			var fitter = new PathFitter(this, tolerance || 2.5);
			this.setSegments(fitter.fit());
		}
	},

	split: function(index, parameter) {
		if (parameter === null)
			return null;
		if (arguments.length === 1) {
			var arg = index;
			if (typeof arg === 'number')
				arg = this.getLocationAt(arg);
			if (!arg)
				return null
			index = arg.index;
			parameter = arg.parameter;
		}
		var tMin = 4e-7,
			tMax = 1 - tMin;
		if (parameter >= tMax) {
			index++;
			parameter--;
		}
		var curves = this.getCurves();
		if (index >= 0 && index < curves.length) {
			if (parameter >= tMin) {
				curves[index++].divide(parameter, true);
			}
			var segs = this.removeSegments(index, this._segments.length, true),
				path;
			if (this._closed) {
				this.setClosed(false);
				path = this;
			} else {
				path = new Path(Item.NO_INSERT);
				path.insertAbove(this, true);
				this._clone(path);
			}
			path._add(segs, 0);
			this.addSegment(segs[0]);
			return path;
		}
		return null;
	},

	reverse: function() {
		this._segments.reverse();
		for (var i = 0, l = this._segments.length; i < l; i++) {
			var segment = this._segments[i];
			var handleIn = segment._handleIn;
			segment._handleIn = segment._handleOut;
			segment._handleOut = handleIn;
			segment._index = i;
		}
		this._curves = null;
		if (this._clockwise !== undefined)
			this._clockwise = !this._clockwise;
		this._changed(9);
	},

	join: function(path) {
		if (path) {
			var segments = path._segments,
				last1 = this.getLastSegment(),
				last2 = path.getLastSegment();
			if (!last2)
				return this;
			if (last1 && last1._point.equals(last2._point))
				path.reverse();
			var first2 = path.getFirstSegment();
			if (last1 && last1._point.equals(first2._point)) {
				last1.setHandleOut(first2._handleOut);
				this._add(segments.slice(1));
			} else {
				var first1 = this.getFirstSegment();
				if (first1 && first1._point.equals(first2._point))
					path.reverse();
				last2 = path.getLastSegment();
				if (first1 && first1._point.equals(last2._point)) {
					first1.setHandleIn(last2._handleIn);
					this._add(segments.slice(0, segments.length - 1), 0);
				} else {
					this._add(segments.slice());
				}
			}
			if (path._closed)
				this._add([segments[0]]);
			path.remove();
		}
		var first = this.getFirstSegment(),
			last = this.getLastSegment();
		if (first !== last && first._point.equals(last._point)) {
			first.setHandleIn(last._handleIn);
			last.remove();
			this.setClosed(true);
		}
		return this;
	},

	toShape: function(insert) {
		if (!this._closed)
			return null;

		var segments = this._segments,
			type,
			size,
			radius,
			topCenter;

		function isCollinear(i, j) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				seg3 = segments[j],
				seg4 = seg3.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg3._handleOut.isZero() && seg4._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isCollinear(
						seg4._point.subtract(seg3._point));
		}

		function isOrthogonal(i) {
			var seg2 = segments[i],
				seg1 = seg2.getPrevious(),
				seg3 = seg2.getNext();
			return seg1._handleOut.isZero() && seg2._handleIn.isZero()
					&& seg2._handleOut.isZero() && seg3._handleIn.isZero()
					&& seg2._point.subtract(seg1._point).isOrthogonal(
						seg3._point.subtract(seg2._point));
		}

		function isArc(i) {
			var seg1 = segments[i],
				seg2 = seg1.getNext(),
				handle1 = seg1._handleOut,
				handle2 = seg2._handleIn,
				kappa = 0.5522847498307936;
			if (handle1.isOrthogonal(handle2)) {
				var pt1 = seg1._point,
					pt2 = seg2._point,
					corner = new Line(pt1, handle1, true).intersect(
							new Line(pt2, handle2, true), true);
				return corner && Numerical.isZero(handle1.getLength() /
						corner.subtract(pt1).getLength() - kappa)
					&& Numerical.isZero(handle2.getLength() /
						corner.subtract(pt2).getLength() - kappa);
			}
			return false;
		}

		function getDistance(i, j) {
			return segments[i]._point.getDistance(segments[j]._point);
		}

		if (!this.hasHandles() && segments.length === 4
				&& isCollinear(0, 2) && isCollinear(1, 3) && isOrthogonal(1)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(0, 3), getDistance(0, 1));
			topCenter = segments[1]._point.add(segments[2]._point).divide(2);
		} else if (segments.length === 8 && isArc(0) && isArc(2) && isArc(4)
				&& isArc(6) && isCollinear(1, 5) && isCollinear(3, 7)) {
			type = Shape.Rectangle;
			size = new Size(getDistance(1, 6), getDistance(0, 3));
			radius = size.subtract(new Size(getDistance(0, 7),
					getDistance(1, 2))).divide(2);
			topCenter = segments[3]._point.add(segments[4]._point).divide(2);
		} else if (segments.length === 4
				&& isArc(0) && isArc(1) && isArc(2) && isArc(3)) {
			if (Numerical.isZero(getDistance(0, 2) - getDistance(1, 3))) {
				type = Shape.Circle;
				radius = getDistance(0, 2) / 2;
			} else {
				type = Shape.Ellipse;
				radius = new Size(getDistance(2, 0) / 2, getDistance(3, 1) / 2);
			}
			topCenter = segments[1]._point;
		}

		if (type) {
			var center = this.getPosition(true),
				shape = this._clone(new type({
					center: center,
					size: size,
					radius: radius,
					insert: false
				}), insert, false);
			shape.rotate(topCenter.subtract(center).getAngle() + 90);
			return shape;
		}
		return null;
	},

	_hitTestSelf: function(point, options) {
		var that = this,
			style = this.getStyle(),
			segments = this._segments,
			numSegments = segments.length,
			closed = this._closed,
			tolerancePadding = options._tolerancePadding,
			strokePadding = tolerancePadding,
			join, cap, miterLimit,
			area, loc, res,
			hitStroke = options.stroke && style.hasStroke(),
			hitFill = options.fill && style.hasFill(),
			hitCurves = options.curves,
			radius = hitStroke
					? style.getStrokeWidth() / 2
					: hitFill && options.tolerance > 0 || hitCurves
						? 0 : null;
		if (radius !== null) {
			if (radius > 0) {
				join = style.getStrokeJoin();
				cap = style.getStrokeCap();
				miterLimit = radius * style.getMiterLimit();
				strokePadding = tolerancePadding.add(new Point(radius, radius));
			} else {
				join = cap = 'round';
			}
		}

		function isCloseEnough(pt, padding) {
			return point.subtract(pt).divide(padding).length <= 1;
		}

		function checkSegmentPoint(seg, pt, name) {
			if (!options.selected || pt.isSelected()) {
				var anchor = seg._point;
				if (pt !== anchor)
					pt = pt.add(anchor);
				if (isCloseEnough(pt, strokePadding)) {
					return new HitResult(name, that, {
						segment: seg,
						point: pt
					});
				}
			}
		}

		function checkSegmentPoints(seg, ends) {
			return (ends || options.segments)
				&& checkSegmentPoint(seg, seg._point, 'segment')
				|| (!ends && options.handles) && (
					checkSegmentPoint(seg, seg._handleIn, 'handle-in') ||
					checkSegmentPoint(seg, seg._handleOut, 'handle-out'));
		}

		function addToArea(point) {
			area.add(point);
		}

		function checkSegmentStroke(segment) {
			if (join !== 'round' || cap !== 'round') {
				area = new Path({ internal: true, closed: true });
				if (closed || segment._index > 0
						&& segment._index < numSegments - 1) {
					if (join !== 'round' && (segment._handleIn.isZero()
							|| segment._handleOut.isZero()))
						Path._addBevelJoin(segment, join, radius, miterLimit,
								addToArea, true);
				} else if (cap !== 'round') {
					Path._addSquareCap(segment, cap, radius, addToArea, true);
				}
				if (!area.isEmpty()) {
					var loc;
					return area.contains(point)
						|| (loc = area.getNearestLocation(point))
							&& isCloseEnough(loc.getPoint(), tolerancePadding);
				}
			}
			return isCloseEnough(segment._point, strokePadding);
		}

		if (options.ends && !options.segments && !closed) {
			if (res = checkSegmentPoints(segments[0], true)
					|| checkSegmentPoints(segments[numSegments - 1], true))
				return res;
		} else if (options.segments || options.handles) {
			for (var i = 0; i < numSegments; i++)
				if (res = checkSegmentPoints(segments[i]))
					return res;
		}
		if (radius !== null) {
			loc = this.getNearestLocation(point);
			if (loc) {
				var parameter = loc.getParameter();
				if (parameter === 0 || parameter === 1 && numSegments > 1) {
					if (!checkSegmentStroke(loc.getSegment()))
						loc = null;
				} else if (!isCloseEnough(loc.getPoint(), strokePadding)) {
					loc = null;
				}
			}
			if (!loc && join === 'miter' && numSegments > 1) {
				for (var i = 0; i < numSegments; i++) {
					var segment = segments[i];
					if (point.getDistance(segment._point) <= miterLimit
							&& checkSegmentStroke(segment)) {
						loc = segment.getLocation();
						break;
					}
				}
			}
		}
		return !loc && hitFill && this._contains(point)
				|| loc && !hitStroke && !hitCurves
					? new HitResult('fill', this)
					: loc
						? new HitResult(hitStroke ? 'stroke' : 'curve', this, {
							location: loc,
							point: loc.getPoint()
						})
						: null;
	}

}, Base.each(Curve.evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset, isParameter) {
			var loc = this.getLocationAt(offset, isParameter);
			return loc && loc[name]();
		};
	},
{
	beans: false,

	getLocationOf: function() {
		var point = Point.read(arguments),
			curves = this.getCurves();
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getLocationOf(point);
			if (loc)
				return loc;
		}
		return null;
	},

	getOffsetOf: function() {
		var loc = this.getLocationOf.apply(this, arguments);
		return loc ? loc.getOffset() : null;
	},

	getLocationAt: function(offset, isParameter) {
		var curves = this.getCurves(),
			length = 0;
		if (isParameter) {
			var index = ~~offset,
				curve = curves[index];
			return curve ? curve.getLocationAt(offset - index, true) : null;
		}
		for (var i = 0, l = curves.length; i < l; i++) {
			var start = length,
				curve = curves[i];
			length += curve.getLength();
			if (length > offset) {
				return curve.getLocationAt(offset - start);
			}
		}
		if (curves.length > 0 && offset <= this.getLength())
			return new CurveLocation(curves[curves.length - 1], 1);
		return null;
	},

	getNearestLocation: function() {
		var point = Point.read(arguments),
			curves = this.getCurves(),
			minDist = Infinity,
			minLoc = null;
		for (var i = 0, l = curves.length; i < l; i++) {
			var loc = curves[i].getNearestLocation(point);
			if (loc._distance < minDist) {
				minDist = loc._distance;
				minLoc = loc;
			}
		}
		return minLoc;
	},

	getNearestPoint: function() {
		return this.getNearestLocation.apply(this, arguments).getPoint();
	}
}),
new function() {

	function drawHandles(ctx, segments, matrix, size) {
		var half = size / 2;

		function drawHandle(index) {
			var hX = coords[index],
				hY = coords[index + 1];
			if (pX != hX || pY != hY) {
				ctx.beginPath();
				ctx.moveTo(pX, pY);
				ctx.lineTo(hX, hY);
				ctx.stroke();
				ctx.beginPath();
				ctx.arc(hX, hY, half, 0, Math.PI * 2, true);
				ctx.fill();
			}
		}

		var coords = new Array(6);
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			var state = segment._selectionState,
				pX = coords[0],
				pY = coords[1];
			if (state & 1)
				drawHandle(2);
			if (state & 2)
				drawHandle(4);
			ctx.fillRect(pX - half, pY - half, size, size);
			if (!(state & 4)) {
				var fillStyle = ctx.fillStyle;
				ctx.fillStyle = '#ffffff';
				ctx.fillRect(pX - half + 1, pY - half + 1, size - 2, size - 2);
				ctx.fillStyle = fillStyle;
			}
		}
	}

	function drawSegments(ctx, path, matrix) {
		var segments = path._segments,
			length = segments.length,
			coords = new Array(6),
			first = true,
			curX, curY,
			prevX, prevY,
			inX, inY,
			outX, outY;

		function drawSegment(segment) {
			if (matrix) {
				segment._transformCoordinates(matrix, coords, false);
				curX = coords[0];
				curY = coords[1];
			} else {
				var point = segment._point;
				curX = point._x;
				curY = point._y;
			}
			if (first) {
				ctx.moveTo(curX, curY);
				first = false;
			} else {
				if (matrix) {
					inX = coords[2];
					inY = coords[3];
				} else {
					var handle = segment._handleIn;
					inX = curX + handle._x;
					inY = curY + handle._y;
				}
				if (inX === curX && inY === curY
						&& outX === prevX && outY === prevY) {
					ctx.lineTo(curX, curY);
				} else {
					ctx.bezierCurveTo(outX, outY, inX, inY, curX, curY);
				}
			}
			prevX = curX;
			prevY = curY;
			if (matrix) {
				outX = coords[4];
				outY = coords[5];
			} else {
				var handle = segment._handleOut;
				outX = prevX + handle._x;
				outY = prevY + handle._y;
			}
		}

		for (var i = 0; i < length; i++)
			drawSegment(segments[i]);
		if (path._closed && length > 0)
			drawSegment(segments[0]);
	}

	return {
		_draw: function(ctx, param, strokeMatrix) {
			var dontStart = param.dontStart,
				dontPaint = param.dontFinish || param.clip,
				style = this.getStyle(),
				hasFill = style.hasFill(),
				hasStroke = style.hasStroke(),
				dashArray = style.getDashArray(),
				dashLength = !paper.support.nativeDash && hasStroke
						&& dashArray && dashArray.length;

			if (!dontStart)
				ctx.beginPath();

			if (!dontStart && this._currentPath) {
				ctx.currentPath = this._currentPath;
			} else if (hasFill || hasStroke && !dashLength || dontPaint) {
				drawSegments(ctx, this, strokeMatrix);
				if (this._closed)
					ctx.closePath();
				if (!dontStart)
					this._currentPath = ctx.currentPath;
			}

			function getOffset(i) {
				return dashArray[((i % dashLength) + dashLength) % dashLength];
			}

			if (!dontPaint && (hasFill || hasStroke)) {
				this._setStyles(ctx);
				if (hasFill) {
					ctx.fill(style.getWindingRule());
					ctx.shadowColor = 'rgba(0,0,0,0)';
				}
				if (hasStroke) {
					if (dashLength) {
						if (!dontStart)
							ctx.beginPath();
						var iterator = new PathIterator(this, 32, 0.25,
								strokeMatrix),
							length = iterator.length,
							from = -style.getDashOffset(), to,
							i = 0;
						from = from % length;
						while (from > 0) {
							from -= getOffset(i--) + getOffset(i--);
						}
						while (from < length) {
							to = from + getOffset(i++);
							if (from > 0 || to > 0)
								iterator.drawPart(ctx,
										Math.max(from, 0), Math.max(to, 0));
							from = to + getOffset(i++);
						}
					}
					ctx.stroke();
				}
			}
		},

		_drawSelected: function(ctx, matrix) {
			ctx.beginPath();
			drawSegments(ctx, this, matrix);
			ctx.stroke();
			drawHandles(ctx, this._segments, matrix, paper.settings.handleSize);
		}
	};
},
new function() {
	function getFirstControlPoints(rhs) {
		var n = rhs.length,
			x = [],
			tmp = [],
			b = 2;
		x[0] = rhs[0] / b;
		for (var i = 1; i < n; i++) {
			tmp[i] = 1 / b;
			b = (i < n - 1 ? 4 : 2) - tmp[i];
			x[i] = (rhs[i] - x[i - 1]) / b;
		}
		for (var i = 1; i < n; i++) {
			x[n - i - 1] -= tmp[n - i] * x[n - i];
		}
		return x;
	}

	return {
		smooth: function() {
			var segments = this._segments,
				size = segments.length,
				closed = this._closed,
				n = size,
				overlap = 0;
			if (size <= 2)
				return;
			if (closed) {
				overlap = Math.min(size, 4);
				n += Math.min(size, overlap) * 2;
			}
			var knots = [];
			for (var i = 0; i < size; i++)
				knots[i + overlap] = segments[i]._point;
			if (closed) {
				for (var i = 0; i < overlap; i++) {
					knots[i] = segments[i + size - overlap]._point;
					knots[i + size + overlap] = segments[i]._point;
				}
			} else {
				n--;
			}
			var rhs = [];

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._x + 2 * knots[i + 1]._x;
			rhs[0] = knots[0]._x + 2 * knots[1]._x;
			rhs[n - 1] = 3 * knots[n - 1]._x;
			var x = getFirstControlPoints(rhs);

			for (var i = 1; i < n - 1; i++)
				rhs[i] = 4 * knots[i]._y + 2 * knots[i + 1]._y;
			rhs[0] = knots[0]._y + 2 * knots[1]._y;
			rhs[n - 1] = 3 * knots[n - 1]._y;
			var y = getFirstControlPoints(rhs);

			if (closed) {
				for (var i = 0, j = size; i < overlap; i++, j++) {
					var f1 = i / overlap,
						f2 = 1 - f1,
						ie = i + overlap,
						je = j + overlap;
					x[j] = x[i] * f1 + x[j] * f2;
					y[j] = y[i] * f1 + y[j] * f2;
					x[je] = x[ie] * f2 + x[je] * f1;
					y[je] = y[ie] * f2 + y[je] * f1;
				}
				n--;
			}
			var handleIn = null;
			for (var i = overlap; i <= n - overlap; i++) {
				var segment = segments[i - overlap];
				if (handleIn)
					segment.setHandleIn(handleIn.subtract(segment._point));
				if (i < n) {
					segment.setHandleOut(
							new Point(x[i], y[i]).subtract(segment._point));
					handleIn = i < n - 1
							? new Point(
								2 * knots[i + 1]._x - x[i + 1],
								2 * knots[i + 1]._y - y[i + 1])
							: new Point(
								(knots[n]._x + x[n - 1]) / 2,
								(knots[n]._y + y[n - 1]) / 2);
				}
			}
			if (closed && handleIn) {
				var segment = this._segments[0];
				segment.setHandleIn(handleIn.subtract(segment._point));
			}
		}
	};
},
new function() {
	function getCurrentSegment(that) {
		var segments = that._segments;
		if (segments.length === 0)
			throw new Error('Use a moveTo() command first');
		return segments[segments.length - 1];
	}

	return {
		moveTo: function() {
			var segments = this._segments;
			if (segments.length === 1)
				this.removeSegment(0);
			if (!segments.length)
				this._add([ new Segment(Point.read(arguments)) ]);
		},

		moveBy: function() {
			throw new Error('moveBy() is unsupported on Path items.');
		},

		lineTo: function() {
			this._add([ new Segment(Point.read(arguments)) ]);
		},

		cubicCurveTo: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this);
			current.setHandleOut(handle1.subtract(current._point));
			this._add([ new Segment(to, handle2.subtract(to)) ]);
		},

		quadraticCurveTo: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(
				handle.add(current.subtract(handle).multiply(1 / 3)),
				handle.add(to.subtract(handle).multiply(1 / 3)),
				to
			);
		},

		curveTo: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				t = Base.pick(Base.read(arguments), 0.5),
				t1 = 1 - t,
				current = getCurrentSegment(this)._point,
				handle = through.subtract(current.multiply(t1 * t1))
					.subtract(to.multiply(t * t)).divide(2 * t * t1);
			if (handle.isNaN())
				throw new Error(
					'Cannot put a curve through points with parameter = ' + t);
			this.quadraticCurveTo(handle, to);
		},

		arcTo: function() {
			var current = getCurrentSegment(this),
				from = current._point,
				to = Point.read(arguments),
				through,
				peek = Base.peek(arguments),
				clockwise = Base.pick(peek, true),
				center, extent, vector, matrix;
			if (typeof clockwise === 'boolean') {
				var middle = from.add(to).divide(2),
				through = middle.add(middle.subtract(from).rotate(
						clockwise ? -90 : 90));
			} else if (Base.remain(arguments) <= 2) {
				through = to;
				to = Point.read(arguments);
			} else {
				var radius = Size.read(arguments);
				if (radius.isZero())
					return this.lineTo(to);
				var rotation = Base.read(arguments),
					clockwise = !!Base.read(arguments),
					large = !!Base.read(arguments),
					middle = from.add(to).divide(2),
					pt = from.subtract(middle).rotate(-rotation),
					x = pt.x,
					y = pt.y,
					abs = Math.abs,
					rx = abs(radius.width),
					ry = abs(radius.height),
					rxSq = rx * rx,
					rySq = ry * ry,
					xSq =  x * x,
					ySq =  y * y;
				var factor = Math.sqrt(xSq / rxSq + ySq / rySq);
				if (factor > 1) {
					rx *= factor;
					ry *= factor;
					rxSq = rx * rx;
					rySq = ry * ry;
				}
				factor = (rxSq * rySq - rxSq * ySq - rySq * xSq) /
						(rxSq * ySq + rySq * xSq);
				if (abs(factor) < 1e-12)
					factor = 0;
				if (factor < 0)
					throw new Error(
							'Cannot create an arc with the given arguments');
				center = new Point(rx * y / ry, -ry * x / rx)
						.multiply((large === clockwise ? -1 : 1)
							* Math.sqrt(factor))
						.rotate(rotation).add(middle);
				matrix = new Matrix().translate(center).rotate(rotation)
						.scale(rx, ry);
				vector = matrix._inverseTransform(from);
				extent = vector.getDirectedAngle(matrix._inverseTransform(to));
				if (!clockwise && extent > 0)
					extent -= 360;
				else if (clockwise && extent < 0)
					extent += 360;
			}
			if (through) {
				var l1 = new Line(from.add(through).divide(2),
							through.subtract(from).rotate(90), true),
					l2 = new Line(through.add(to).divide(2),
							to.subtract(through).rotate(90), true),
					line = new Line(from, to),
					throughSide = line.getSide(through);
				center = l1.intersect(l2, true);
				if (!center) {
					if (!throughSide)
						return this.lineTo(to);
					throw new Error(
							'Cannot create an arc with the given arguments');
				}
				vector = from.subtract(center);
				extent = vector.getDirectedAngle(to.subtract(center));
				var centerSide = line.getSide(center);
				if (centerSide === 0) {
					extent = throughSide * Math.abs(extent);
				} else if (throughSide === centerSide) {
					extent += extent < 0 ? 360 : -360;
				}
			}
			var ext = Math.abs(extent),
				count = ext >= 360 ? 4 : Math.ceil(ext / 90),
				inc = extent / count,
				half = inc * Math.PI / 360,
				z = 4 / 3 * Math.sin(half) / (1 + Math.cos(half)),
				segments = [];
			for (var i = 0; i <= count; i++) {
				var pt = to,
					out = null;
				if (i < count) {
					out = vector.rotate(90).multiply(z);
					if (matrix) {
						pt = matrix._transformPoint(vector);
						out = matrix._transformPoint(vector.add(out))
								.subtract(pt);
					} else {
						pt = center.add(vector);
					}
				}
				if (i === 0) {
					current.setHandleOut(out);
				} else {
					var _in = vector.rotate(-90).multiply(z);
					if (matrix) {
						_in = matrix._transformPoint(vector.add(_in))
								.subtract(pt);
					}
					segments.push(new Segment(pt, _in, out));
				}
				vector = vector.rotate(inc);
			}
			this._add(segments);
		},

		lineBy: function() {
			var to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.lineTo(current.add(to));
		},

		curveBy: function() {
			var through = Point.read(arguments),
				to = Point.read(arguments),
				parameter = Base.read(arguments),
				current = getCurrentSegment(this)._point;
			this.curveTo(current.add(through), current.add(to), parameter);
		},

		cubicCurveBy: function() {
			var handle1 = Point.read(arguments),
				handle2 = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.cubicCurveTo(current.add(handle1), current.add(handle2),
					current.add(to));
		},

		quadraticCurveBy: function() {
			var handle = Point.read(arguments),
				to = Point.read(arguments),
				current = getCurrentSegment(this)._point;
			this.quadraticCurveTo(current.add(handle), current.add(to));
		},

		arcBy: function() {
			var current = getCurrentSegment(this)._point,
				point = current.add(Point.read(arguments)),
				clockwise = Base.pick(Base.peek(arguments), true);
			if (typeof clockwise === 'boolean') {
				this.arcTo(point, clockwise);
			} else {
				this.arcTo(point, current.add(Point.read(arguments)));
			}
		},

		closePath: function(join) {
			this.setClosed(true);
			if (join)
				this.join();
		}
	};
}, {

	_getBounds: function(getter, matrix) {
		return Path[getter](this._segments, this._closed, this.getStyle(),
				matrix);
	},

statics: {
	getBounds: function(segments, closed, style, matrix, strokePadding) {
		var first = segments[0];
		if (!first)
			return new Rectangle();
		var coords = new Array(6),
			prevCoords = first._transformCoordinates(matrix, new Array(6), false),
			min = prevCoords.slice(0, 2),
			max = min.slice(),
			roots = new Array(2);

		function processSegment(segment) {
			segment._transformCoordinates(matrix, coords, false);
			for (var i = 0; i < 2; i++) {
				Curve._addBounds(
					prevCoords[i],
					prevCoords[i + 4],
					coords[i + 2],
					coords[i],
					i, strokePadding ? strokePadding[i] : 0, min, max, roots);
			}
			var tmp = prevCoords;
			prevCoords = coords;
			coords = tmp;
		}

		for (var i = 1, l = segments.length; i < l; i++)
			processSegment(segments[i]);
		if (closed)
			processSegment(first);
		return new Rectangle(min[0], min[1], max[0] - min[0], max[1] - min[1]);
	},

	getStrokeBounds: function(segments, closed, style, matrix) {
		if (!style.hasStroke())
			return Path.getBounds(segments, closed, style, matrix);
		var length = segments.length - (closed ? 0 : 1),
			radius = style.getStrokeWidth() / 2,
			padding = Path._getPenPadding(radius, matrix),
			bounds = Path.getBounds(segments, closed, style, matrix, padding),
			join = style.getStrokeJoin(),
			cap = style.getStrokeCap(),
			miterLimit = radius * style.getMiterLimit();
		var joinBounds = new Rectangle(new Size(padding).multiply(2));

		function add(point) {
			bounds = bounds.include(matrix
				? matrix._transformPoint(point, point) : point);
		}

		function addRound(segment) {
			bounds = bounds.unite(joinBounds.setCenter(matrix
				? matrix._transformPoint(segment._point) : segment._point));
		}

		function addJoin(segment, join) {
			var handleIn = segment._handleIn,
				handleOut = segment._handleOut;
			if (join === 'round' || !handleIn.isZero() && !handleOut.isZero()
					&& handleIn.isCollinear(handleOut)) {
				addRound(segment);
			} else {
				Path._addBevelJoin(segment, join, radius, miterLimit, add);
			}
		}

		function addCap(segment, cap) {
			if (cap === 'round') {
				addRound(segment);
			} else {
				Path._addSquareCap(segment, cap, radius, add);
			}
		}

		for (var i = 1; i < length; i++)
			addJoin(segments[i], join);
		if (closed) {
			addJoin(segments[0], join);
		} else if (length > 0) {
			addCap(segments[0], cap);
			addCap(segments[segments.length - 1], cap);
		}
		return bounds;
	},

	_getPenPadding: function(radius, matrix) {
		if (!matrix)
			return [radius, radius];
		var mx = matrix.shiftless(),
			hor = mx.transform(new Point(radius, 0)),
			ver = mx.transform(new Point(0, radius)),
			phi = hor.getAngleInRadians(),
			a = hor.getLength(),
			b = ver.getLength();
		var sin = Math.sin(phi),
			cos = Math.cos(phi),
			tan = Math.tan(phi),
			tx = -Math.atan(b * tan / a),
			ty = Math.atan(b / (tan * a));
		return [Math.abs(a * Math.cos(tx) * cos - b * Math.sin(tx) * sin),
				Math.abs(b * Math.sin(ty) * cos + a * Math.cos(ty) * sin)];
	},

	_addBevelJoin: function(segment, join, radius, miterLimit, addPoint, area) {
		var curve2 = segment.getCurve(),
			curve1 = curve2.getPrevious(),
			point = curve2.getPointAt(0, true),
			normal1 = curve1.getNormalAt(1, true),
			normal2 = curve2.getNormalAt(0, true),
			step = normal1.getDirectedAngle(normal2) < 0 ? -radius : radius;
		normal1.setLength(step);
		normal2.setLength(step);
		if (area) {
			addPoint(point);
			addPoint(point.add(normal1));
		}
		if (join === 'miter') {
			var corner = new Line(
					point.add(normal1),
					new Point(-normal1.y, normal1.x), true
				).intersect(new Line(
					point.add(normal2),
					new Point(-normal2.y, normal2.x), true
				), true);
			if (corner && point.getDistance(corner) <= miterLimit) {
				addPoint(corner);
				if (!area)
					return;
			}
		}
		if (!area)
			addPoint(point.add(normal1));
		addPoint(point.add(normal2));
	},

	_addSquareCap: function(segment, cap, radius, addPoint, area) {
		var point = segment._point,
			loc = segment.getLocation(),
			normal = loc.getNormal().multiply(radius);
		if (area) {
			addPoint(point.subtract(normal));
			addPoint(point.add(normal));
		}
		if (cap === 'square')
			point = point.add(normal.rotate(loc.getParameter() === 0 ? -90 : 90));
		addPoint(point.add(normal));
		addPoint(point.subtract(normal));
	},

	getHandleBounds: function(segments, closed, style, matrix, strokePadding,
			joinPadding) {
		var coords = new Array(6),
			x1 = Infinity,
			x2 = -x1,
			y1 = x1,
			y2 = x2;
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			segment._transformCoordinates(matrix, coords, false);
			for (var j = 0; j < 6; j += 2) {
				var padding = j === 0 ? joinPadding : strokePadding,
					paddingX = padding ? padding[0] : 0,
					paddingY = padding ? padding[1] : 0,
					x = coords[j],
					y = coords[j + 1],
					xn = x - paddingX,
					xx = x + paddingX,
					yn = y - paddingY,
					yx = y + paddingY;
				if (xn < x1) x1 = xn;
				if (xx > x2) x2 = xx;
				if (yn < y1) y1 = yn;
				if (yx > y2) y2 = yx;
			}
		}
		return new Rectangle(x1, y1, x2 - x1, y2 - y1);
	},

	getRoughBounds: function(segments, closed, style, matrix) {
		var strokeRadius = style.hasStroke() ? style.getStrokeWidth() / 2 : 0,
			joinRadius = strokeRadius;
		if (strokeRadius > 0) {
			if (style.getStrokeJoin() === 'miter')
				joinRadius = strokeRadius * style.getMiterLimit();
			if (style.getStrokeCap() === 'square')
				joinRadius = Math.max(joinRadius, strokeRadius * Math.sqrt(2));
		}
		return Path.getHandleBounds(segments, closed, style, matrix,
				Path._getPenPadding(strokeRadius, matrix),
				Path._getPenPadding(joinRadius, matrix));
	}
}});

Path.inject({ statics: new function() {

	var kappa = 0.5522847498307936,
		ellipseSegments = [
			new Segment([-1, 0], [0, kappa ], [0, -kappa]),
			new Segment([0, -1], [-kappa, 0], [kappa, 0 ]),
			new Segment([1, 0], [0, -kappa], [0, kappa ]),
			new Segment([0, 1], [kappa, 0 ], [-kappa, 0])
		];

	function createPath(segments, closed, args) {
		var props = Base.getNamed(args),
			path = new Path(props && props.insert === false && Item.NO_INSERT);
		path._add(segments);
		path._closed = closed;
		return path.set(props);
	}

	function createEllipse(center, radius, args) {
		var segments = new Array(4);
		for (var i = 0; i < 4; i++) {
			var segment = ellipseSegments[i];
			segments[i] = new Segment(
				segment._point.multiply(radius).add(center),
				segment._handleIn.multiply(radius),
				segment._handleOut.multiply(radius)
			);
		}
		return createPath(segments, true, args);
	}

	return {
		Line: function() {
			return createPath([
				new Segment(Point.readNamed(arguments, 'from')),
				new Segment(Point.readNamed(arguments, 'to'))
			], false, arguments);
		},

		Circle: function() {
			var center = Point.readNamed(arguments, 'center'),
				radius = Base.readNamed(arguments, 'radius');
			return createEllipse(center, new Size(radius), arguments);
		},

		Rectangle: function() {
			var rect = Rectangle.readNamed(arguments, 'rectangle'),
				radius = Size.readNamed(arguments, 'radius', 0,
						{ readNull: true }),
				bl = rect.getBottomLeft(true),
				tl = rect.getTopLeft(true),
				tr = rect.getTopRight(true),
				br = rect.getBottomRight(true),
				segments;
			if (!radius || radius.isZero()) {
				segments = [
					new Segment(bl),
					new Segment(tl),
					new Segment(tr),
					new Segment(br)
				];
			} else {
				radius = Size.min(radius, rect.getSize(true).divide(2));
				var rx = radius.width,
					ry = radius.height,
					hx = rx * kappa,
					hy = ry * kappa;
				segments = [
					new Segment(bl.add(rx, 0), null, [-hx, 0]),
					new Segment(bl.subtract(0, ry), [0, hy]),
					new Segment(tl.add(0, ry), null, [0, -hy]),
					new Segment(tl.add(rx, 0), [-hx, 0], null),
					new Segment(tr.subtract(rx, 0), null, [hx, 0]),
					new Segment(tr.add(0, ry), [0, -hy], null),
					new Segment(br.subtract(0, ry), null, [0, hy]),
					new Segment(br.subtract(rx, 0), [hx, 0])
				];
			}
			return createPath(segments, true, arguments);
		},

		RoundRectangle: '#Rectangle',

		Ellipse: function() {
			var ellipse = Shape._readEllipse(arguments);
			return createEllipse(ellipse.center, ellipse.radius, arguments);
		},

		Oval: '#Ellipse',

		Arc: function() {
			var from = Point.readNamed(arguments, 'from'),
				through = Point.readNamed(arguments, 'through'),
				to = Point.readNamed(arguments, 'to'),
				props = Base.getNamed(arguments),
				path = new Path(props && props.insert === false
						&& Item.NO_INSERT);
			path.moveTo(from);
			path.arcTo(through, to);
			return path.set(props);
		},

		RegularPolygon: function() {
			var center = Point.readNamed(arguments, 'center'),
				sides = Base.readNamed(arguments, 'sides'),
				radius = Base.readNamed(arguments, 'radius'),
				step = 360 / sides,
				three = !(sides % 3),
				vector = new Point(0, three ? -radius : radius),
				offset = three ? -1 : 0.5,
				segments = new Array(sides);
			for (var i = 0; i < sides; i++)
				segments[i] = new Segment(center.add(
					vector.rotate((i + offset) * step)));
			return createPath(segments, true, arguments);
		},

		Star: function() {
			var center = Point.readNamed(arguments, 'center'),
				points = Base.readNamed(arguments, 'points') * 2,
				radius1 = Base.readNamed(arguments, 'radius1'),
				radius2 = Base.readNamed(arguments, 'radius2'),
				step = 360 / points,
				vector = new Point(0, -1),
				segments = new Array(points);
			for (var i = 0; i < points; i++)
				segments[i] = new Segment(center.add(vector.rotate(step * i)
						.multiply(i % 2 ? radius2 : radius1)));
			return createPath(segments, true, arguments);
		}
	};
}});

var CompoundPath = PathItem.extend({
	_class: 'CompoundPath',
	_serializeFields: {
		children: []
	},

	initialize: function CompoundPath(arg) {
		this._children = [];
		this._namedChildren = {};
		if (!this._initialize(arg)) {
			if (typeof arg === 'string') {
				this.setPathData(arg);
			} else {
				this.addChildren(Array.isArray(arg) ? arg : arguments);
			}
		}
	},

	insertChildren: function insertChildren(index, items, _preserve) {
		for (var i = items.length - 1; i >= 0; i--) {
			var item = items[i];
			if (item instanceof CompoundPath) {
				items.splice.apply(items, [i, 1].concat(item.removeChildren()));
				item.remove();
			}
		}
		items = insertChildren.base.call(this, index, items, _preserve, Path);
		for (var i = 0, l = !_preserve && items && items.length; i < l; i++) {
			var item = items[i];
			if (item._clockwise === undefined)
				item.setClockwise(item._index === 0);
		}
		return items;
	},

	reverse: function() {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++)
			children[i].reverse();
	},

	smooth: function() {
		for (var i = 0, l = this._children.length; i < l; i++)
			this._children[i].smooth();
	},

	reduce: function reduce() {
		var children = this._children;
		for (var i = children.length - 1; i >= 0; i--) {
			var path = children[i].reduce();
			if (path.isEmpty())
				children.splice(i, 1);
		}
		if (children.length === 0) {
			var path = new Path(Item.NO_INSERT);
			path.insertAbove(this);
			path.setStyle(this._style);
			this.remove();
			return path;
		}
		return reduce.base.call(this);
	},

	isClockwise: function() {
		var child = this.getFirstChild();
		return child && child.isClockwise();
	},

	setClockwise: function(clockwise) {
		if (this.isClockwise() !== !!clockwise)
			this.reverse();
	},

	getFirstSegment: function() {
		var first = this.getFirstChild();
		return first && first.getFirstSegment();
	},

	getLastSegment: function() {
		var last = this.getLastChild();
		return last && last.getLastSegment();
	},

	getCurves: function() {
		var children = this._children,
			curves = [];
		for (var i = 0, l = children.length; i < l; i++)
			curves.push.apply(curves, children[i].getCurves());
		return curves;
	},

	getFirstCurve: function() {
		var first = this.getFirstChild();
		return first && first.getFirstCurve();
	},

	getLastCurve: function() {
		var last = this.getLastChild();
		return last && last.getFirstCurve();
	},

	getArea: function() {
		var children = this._children,
			area = 0;
		for (var i = 0, l = children.length; i < l; i++)
			area += children[i].getArea();
		return area;
	}
}, {
	beans: true,

	getPathData: function(_matrix, _precision) {
		var children = this._children,
			paths = [];
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			paths.push(child.getPathData(_matrix && !mx.isIdentity()
					? _matrix.chain(mx) : _matrix, _precision));
		}
		return paths.join(' ');
	}
}, {
	_getChildHitTestOptions: function(options) {
		return options.class === Path || options.type === 'path'
				? options
				: new Base(options, { fill: false });
	},

	_draw: function(ctx, param, strokeMatrix) {
		var children = this._children;
		if (children.length === 0)
			return;

		if (this._currentPath) {
			ctx.currentPath = this._currentPath;
		} else {
			param = param.extend({ dontStart: true, dontFinish: true });
			ctx.beginPath();
			for (var i = 0, l = children.length; i < l; i++)
				children[i].draw(ctx, param, strokeMatrix);
			this._currentPath = ctx.currentPath;
		}

		if (!param.clip) {
			this._setStyles(ctx);
			var style = this._style;
			if (style.hasFill()) {
				ctx.fill(style.getWindingRule());
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.stroke();
		}
	},

	_drawSelected: function(ctx, matrix, selectedItems) {
		var children = this._children;
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i],
				mx = child._matrix;
			if (!selectedItems[child._id])
				child._drawSelected(ctx, mx.isIdentity() ? matrix
						: matrix.chain(mx));
		}
	}
},
new function() {
	function getCurrentPath(that, check) {
		var children = that._children;
		if (check && children.length === 0)
			throw new Error('Use a moveTo() command first');
		return children[children.length - 1];
	}

	var fields = {
		moveTo: function() {
			var current = getCurrentPath(this),
				path = current && current.isEmpty() ? current
						: new Path(Item.NO_INSERT);
			if (path !== current)
				this.addChild(path);
			path.moveTo.apply(path, arguments);
		},

		moveBy: function() {
			var current = getCurrentPath(this, true),
				last = current && current.getLastSegment(),
				point = Point.read(arguments);
			this.moveTo(last ? point.add(last._point) : point);
		},

		closePath: function(join) {
			getCurrentPath(this, true).closePath(join);
		}
	};

	Base.each(['lineTo', 'cubicCurveTo', 'quadraticCurveTo', 'curveTo', 'arcTo',
			'lineBy', 'cubicCurveBy', 'quadraticCurveBy', 'curveBy', 'arcBy'],
			function(key) {
				fields[key] = function() {
					var path = getCurrentPath(this, true);
					path[key].apply(path, arguments);
				};
			}
	);

	return fields;
});

PathItem.inject(new function() {
	var operators = {
		unite: function(w) {
			return w === 1 || w === 0;
		},

		intersect: function(w) {
			return w === 2;
		},

		subtract: function(w) {
			return w === 1;
		},

		exclude: function(w) {
			return w === 1;
		}
	};

	function preparePath(path, resolve) {
		var res = path.clone(false).reduce().transform(null, true, true);
		return resolve ? res.resolveCrossings().reorient() : res;
	}

	function finishBoolean(ctor, paths, path1, path2, reduce) {
		var result = new ctor(Item.NO_INSERT);
		result.addChildren(paths, true);
		if (reduce)
			result = result.reduce();
		result.insertAbove(path2 && path1.isSibling(path2)
				&& path1.getIndex() < path2.getIndex()
					? path2 : path1);
		result.setStyle(path1._style);
		return result;
	}

	function computeBoolean(path1, path2, operation) {
		if (!path1._children && !path1._closed)
			return computeOpenBoolean(path1, path2, operation);
		var _path1 = preparePath(path1, true),
			_path2 = path2 && path1 !== path2 && preparePath(path2, true);
		if (_path2 && /^(subtract|exclude)$/.test(operation)
				^ (_path2.isClockwise() !== _path1.isClockwise()))
			_path2.reverse();
		var intersections = CurveLocation.expand(
			_path1.getIntersections(_path2, function(inter) {
				return _path2 && inter.isOverlap() || inter.isCrossing();
			})
		);
		divideLocations(intersections);

		var segments = [],
			monoCurves = [];

		function collect(paths) {
			for (var i = 0, l = paths.length; i < l; i++) {
				var path = paths[i];
				segments.push.apply(segments, path._segments);
				monoCurves.push.apply(monoCurves, path._getMonoCurves());
			}
		}

		collect(_path1._children || [_path1]);
		if (_path2)
			collect(_path2._children || [_path2]);
		for (var i = 0, l = intersections.length; i < l; i++) {
			propagateWinding(intersections[i]._segment, _path1, _path2,
					monoCurves, operation);
		}
		for (var i = 0, l = segments.length; i < l; i++) {
			var segment = segments[i];
			if (segment._winding == null) {
				propagateWinding(segment, _path1, _path2, monoCurves,
						operation);
			}
		}
		return finishBoolean(CompoundPath, tracePaths(segments, operation),
				path1, path2, true);
	}

	function computeOpenBoolean(path1, path2, operation) {
		if (!path2 || !path2._children && !path2._closed
				|| !/^(subtract|intersect)$/.test(operation))
			return null;
		var _path1 = preparePath(path1, false),
			_path2 = preparePath(path2, false),
			intersections = _path1.getIntersections(_path2, function(inter) {
				return inter.isOverlap() || inter.isCrossing();
			}),
			sub = operation === 'subtract',
			paths = [];

		function addPath(path) {
			if (_path2.contains(path.getPointAt(path.getLength() / 2)) ^ sub) {
				paths.unshift(path);
				return true;
			}
		}

		for (var i = intersections.length - 1; i >= 0; i--) {
			var path = intersections[i].split();
			if (path) {
				if (addPath(path))
					path.getFirstSegment().setHandleIn(0, 0);
				_path1.getLastSegment().setHandleOut(0, 0);
			}
		}
		addPath(_path1);
		return finishBoolean(Group, paths, path1, path2);
	}

	function linkIntersections(from, to) {
		var prev = from;
		while (prev) {
			if (prev === to)
				return;
			prev = prev._prev;
		}
		while (from._next && from._next !== to)
			from = from._next;
		if (!from._next) {
			while (to._prev)
				to = to._prev;
			from._next = to;
			to._prev = from;
		}
	}

	function divideLocations(locations) {
		var tMin = 4e-7,
			tMax = 1 - tMin,
			noHandles = false,
			clearSegments = [],
			prevCurve,
			prevT;

		for (var i = locations.length - 1; i >= 0; i--) {
			var loc = locations[i],
				curve = loc._curve,
				t = loc._parameter,
				origT = t;
			if (curve !== prevCurve) {
				noHandles = !curve.hasHandles();
			} else if (prevT > 0) {
				t /= prevT;
			}
			var segment;
			if (t < tMin) {
				segment = curve._segment1;
			} else if (t > tMax) {
				segment = curve._segment2;
			} else {
				segment = curve.divide(t, true, true)._segment1;
				if (noHandles)
					clearSegments.push(segment);
			}
			loc._setSegment(segment);
			var inter = segment._intersection,
				dest = loc._intersection;
			if (inter) {
				linkIntersections(inter, dest);
				var other = inter;
				while (other) {
					linkIntersections(other._intersection, inter);
					other = other._next;
				}
			} else {
				segment._intersection = dest;
			}
			prevCurve = curve;
			prevT = origT;
		}
		for (var i = 0, l = clearSegments.length; i < l; i++) {
			clearSegments[i].clearHandles();
		}
	}

	function getWinding(point, curves, horizontal, testContains) {
		var epsilon = 2e-7,
			tMin = 4e-7,
			tMax = 1 - tMin,
			px = point.x,
			py = point.y,
			windLeft = 0,
			windRight = 0,
			roots = [],
			abs = Math.abs;
		if (horizontal) {
			var yTop = -Infinity,
				yBottom = Infinity,
				yBefore = py - epsilon,
				yAfter = py + epsilon;
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if (Curve.solveCubic(values, 0, px, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--) {
						var y = Curve.getPoint(values, roots[j]).y;
						if (y < yBefore && y > yTop) {
							yTop = y;
						} else if (y > yAfter && y < yBottom) {
							yBottom = y;
						}
					}
				}
			}
			yTop = (yTop + py) / 2;
			yBottom = (yBottom + py) / 2;
			if (yTop > -Infinity)
				windLeft = getWinding(new Point(px, yTop), curves, false,
						testContains);
			if (yBottom < Infinity)
				windRight = getWinding(new Point(px, yBottom), curves, false,
						testContains);
		} else {
			var xBefore = px - epsilon,
				xAfter = px + epsilon;
			var startCounted = false,
				prevCurve,
				prevT;
			for (var i = 0, l = curves.length; i < l; i++) {
				var curve = curves[i],
					values = curve.values,
					winding = curve.winding;
				if (winding && (winding === 1
						&& py >= values[1] && py <= values[7]
						|| py >= values[7] && py <= values[1])
					&& Curve.solveCubic(values, 1, py, roots, 0, 1) === 1) {
					var t = roots[0];
					if (!(
						t > tMax && startCounted && curve.next !== curves[i + 1]
						|| t < tMin && prevT > tMax
							&& curve.previous === prevCurve)) {
						var x = Curve.getPoint(values, t).x,
							slope = Curve.getTangent(values, t).y,
							counted = false;
						if (Numerical.isZero(slope) && !Curve.isStraight(values)
								|| t < tMin && slope * Curve.getTangent(
									curve.previous.values, 1).y < 0
								|| t > tMax && slope * Curve.getTangent(
									curve.next.values, 0).y < 0) {
							if (testContains && x >= xBefore && x <= xAfter) {
								++windLeft;
								++windRight;
								counted = true;
							}
						} else if (x <= xBefore) {
							windLeft += winding;
							counted = true;
						} else if (x >= xAfter) {
							windRight += winding;
							counted = true;
						}
						if (curve.previous !== curves[i - 1])
							startCounted = t < tMin && counted;
					}
					prevCurve = curve;
					prevT = t;
				}
			}
		}
		return Math.max(abs(windLeft), abs(windRight));
	}

	function propagateWinding(segment, path1, path2, monoCurves, operation) {
		var epsilon = 2e-7,
			chain = [],
			start = segment,
			totalLength = 0,
			windingSum = 0;
		do {
			var curve = segment.getCurve(),
				length = curve.getLength();
			chain.push({ segment: segment, curve: curve, length: length });
			totalLength += length;
			segment = segment.getNext();
		} while (segment && !segment._intersection && segment !== start);
		for (var i = 0; i < 3; i++) {
			var length = totalLength * (i + 1) / 4;
			for (var k = 0, m = chain.length; k < m; k++) {
				var node = chain[k],
					curveLength = node.length;
				if (length <= curveLength) {
					if (length < epsilon || curveLength - length < epsilon)
						length = curveLength / 2;
					var curve = node.curve,
						path = curve._path,
						parent = path._parent,
						pt = curve.getPointAt(length),
						hor = curve.isHorizontal();
					if (parent instanceof CompoundPath)
						path = parent;
					windingSum += operation === 'subtract' && path2
						&& (path === path1 && path2._getWinding(pt, hor)
						|| path === path2 && !path1._getWinding(pt, hor))
						? 0
						: getWinding(pt, monoCurves, hor);
					break;
				}
				length -= curveLength;
			}
		}
		var winding = Math.round(windingSum / 3);
		for (var j = chain.length - 1; j >= 0; j--)
			chain[j].segment._winding = winding;
	}

	function tracePaths(segments, operation) {
		var paths = [],
			start,
			otherStart,
			operator = operators[operation],
			overlapWinding = {
				unite: { 1: 2 },
				intersect: { 2: 1 }
			}[operation];

		function isValid(seg, adjusted) {
			if (seg._visited)
				return false;
			if (!operator)
				return true;
			var winding = seg._winding,
				inter = seg._intersection;
			if (inter && adjusted && overlapWinding && inter.isOverlap())
				winding = overlapWinding[winding] || winding;
			return operator(winding);
		}

		function isStart(seg) {
			return seg === start || seg === otherStart;
		}

		function findBestIntersection(inter, strict) {
			if (!inter._next)
				return inter;
			while (inter) {
				var seg = inter._segment,
					nextSeg = seg.getNext(),
					nextInter = nextSeg._intersection;
				if (isStart(nextSeg)
					|| !seg._visited && !nextSeg._visited
					&& (!operator
						|| (!strict || isValid(seg))
						&& (!(strict && nextInter && nextInter.isOverlap())
							&& isValid(nextSeg)
							|| !strict && nextInter
							&& isValid(nextInter._segment))
					))
					return inter;
				inter = inter._next;
			}
			return null;
		}

		function findStartSegment(inter, next) {
			while (inter) {
				var seg = inter._segment;
				if (isStart(seg))
					return seg;
				inter = inter[next ? '_next' : '_prev'];
			}
		}

		for (var i = 0, l = segments.length; i < l; i++) {
			var seg = segments[i],
				path = null,
				finished = false;
			if (!isValid(seg, true))
				continue;
			start = otherStart = null;
			while (!finished) {
				var inter = seg._intersection,
					handleIn = path && seg._handleIn;
				inter = inter && (findBestIntersection(inter, true)
						|| findBestIntersection(inter, false)) || inter;
				var other = inter && inter._segment;
				if (other && isValid(other))
					seg = other;
				if (seg._visited) {
					finished = isStart(seg);
					if (!finished && inter) {
						var found = findStartSegment(inter, true)
							|| findStartSegment(inter, false);
						if (found) {
							seg = found;
							finished = true;
						}
					}
					break;
				}
				if (!path) {
					path = new Path(Item.NO_INSERT);
					start = seg;
					otherStart = other;
				}
				path.add(new Segment(seg._point, handleIn, seg._handleOut));
				seg._visited = true;
				seg = seg.getNext();
				finished = isStart(seg);
			}
			if (finished) {
				path.firstSegment.setHandleIn(seg._handleIn);
				path.setClosed(true);
			} else if (path) {
				console.error('Boolean operation resulted in open path',
						'segments =', path._segments.length,
						'length =', path.getLength());
				path = null;
			}
			if (path && (path._segments.length > 8
					|| !Numerical.isZero(path.getArea()))) {
				paths.push(path);
				path = null;
			}
		}
		return paths;
	}

	return {
		_getWinding: function(point, horizontal, testContains) {
			return getWinding(point, this._getMonoCurves(),
					horizontal, testContains);
		},

		unite: function(path) {
			return computeBoolean(this, path, 'unite');
		},

		intersect: function(path) {
			return computeBoolean(this, path, 'intersect');
		},

		subtract: function(path) {
			return computeBoolean(this, path, 'subtract');
		},

		exclude: function(path) {
			return computeBoolean(this, path, 'exclude');
		},

		divide: function(path) {
			return finishBoolean(Group,
					[this.subtract(path), this.intersect(path)],
					this, path, true);
		},

		resolveCrossings: function() {
			var crossings = this.getCrossings();
			if (!crossings.length)
				return this;
			divideLocations(CurveLocation.expand(crossings));
			var paths = this._children || [this],
				segments = [];
			for (var i = 0, l = paths.length; i < l; i++) {
				segments.push.apply(segments, paths[i]._segments);
			}
			return finishBoolean(CompoundPath, tracePaths(segments),
					this, null, false);
		}
	};
});

Path.inject({
	_getMonoCurves: function() {
		var monoCurves = this._monoCurves,
			prevCurve;

		function insertCurve(v) {
			var y0 = v[1],
				y1 = v[7],
				curve = {
					values: v,
					winding: y0 === y1
						? 0
						: y0 > y1
							? -1
							: 1,
					previous: prevCurve,
					next: null
				};
			if (prevCurve)
				prevCurve.next = curve;
			monoCurves.push(curve);
			prevCurve = curve;
		}

		function handleCurve(v) {
			if (Curve.getLength(v) === 0)
				return;
			var y0 = v[1],
				y1 = v[3],
				y2 = v[5],
				y3 = v[7];
			if (Curve.isStraight(v)) {
				insertCurve(v);
			} else {
				var a = 3 * (y1 - y2) - y0 + y3,
					b = 2 * (y0 + y2) - 4 * y1,
					c = y1 - y0,
					tMin = 4e-7,
					tMax = 1 - tMin,
					roots = [],
					n = Numerical.solveQuadratic(a, b, c, roots, tMin, tMax);
				if (n === 0) {
					insertCurve(v);
				} else {
					roots.sort();
					var t = roots[0],
						parts = Curve.subdivide(v, t);
					insertCurve(parts[0]);
					if (n > 1) {
						t = (roots[1] - t) / (1 - t);
						parts = Curve.subdivide(parts[1], t);
						insertCurve(parts[0]);
					}
					insertCurve(parts[1]);
				}
			}
		}

		if (!monoCurves) {
			monoCurves = this._monoCurves = [];
			var curves = this.getCurves(),
				segments = this._segments;
			for (var i = 0, l = curves.length; i < l; i++)
				handleCurve(curves[i].getValues());
			if (!this._closed && segments.length > 1) {
				var p1 = segments[segments.length - 1]._point,
					p2 = segments[0]._point,
					p1x = p1._x, p1y = p1._y,
					p2x = p2._x, p2y = p2._y;
				handleCurve([p1x, p1y, p1x, p1y, p2x, p2y, p2x, p2y]);
			}
			if (monoCurves.length > 0) {
				var first = monoCurves[0],
					last = monoCurves[monoCurves.length - 1];
				first.previous = last;
				last.next = first;
			}
		}
		return monoCurves;
	},

	getInteriorPoint: function() {
		var bounds = this.getBounds(),
			point = bounds.getCenter(true);
		if (!this.contains(point)) {
			var curves = this._getMonoCurves(),
				roots = [],
				y = point.y,
				xIntercepts = [];
			for (var i = 0, l = curves.length; i < l; i++) {
				var values = curves[i].values;
				if ((curves[i].winding === 1
						&& y >= values[1] && y <= values[7]
						|| y >= values[7] && y <= values[1])
						&& Curve.solveCubic(values, 1, y, roots, 0, 1) > 0) {
					for (var j = roots.length - 1; j >= 0; j--)
						xIntercepts.push(Curve.getPoint(values, roots[j]).x);
				}
				if (xIntercepts.length > 1)
					break;
			}
			point.x = (xIntercepts[0] + xIntercepts[1]) / 2;
		}
		return point;
	},

	reorient: function() {
		this.setClockwise(true);
		return this;
	}
});

CompoundPath.inject({
	_getMonoCurves: function() {
		var children = this._children,
			monoCurves = [];
		for (var i = 0, l = children.length; i < l; i++)
			monoCurves.push.apply(monoCurves, children[i]._getMonoCurves());
		return monoCurves;
	},

	reorient: function() {
		var children = this.removeChildren().sort(function(a, b) {
			return b.getBounds().getArea() - a.getBounds().getArea();
		});
		if (children.length > 0) {
			this.addChildren(children);
			var clockwise = children[0].isClockwise();
			for (var i = 1, l = children.length; i < l; i++) {
				var point = children[i].getInteriorPoint(),
					counters = 0;
				for (var j = i - 1; j >= 0; j--) {
					if (children[j].contains(point))
						counters++;
				}
				children[i].setClockwise(counters % 2 === 0 && clockwise);
			}
		}
		return this;
	}
});

var PathIterator = Base.extend({
	_class: 'PathIterator',

	initialize: function(path, maxRecursion, tolerance, matrix) {
		var curves = [],
			parts = [],
			length = 0,
			minDifference = 1 / (maxRecursion || 32),
			segments = path._segments,
			segment1 = segments[0],
			segment2;

		function addCurve(segment1, segment2) {
			var curve = Curve.getValues(segment1, segment2, matrix);
			curves.push(curve);
			computeParts(curve, segment1._index, 0, 1);
		}

		function computeParts(curve, index, minT, maxT) {
			if ((maxT - minT) > minDifference
					&& !Curve.isFlatEnough(curve, tolerance || 0.25)) {
				var split = Curve.subdivide(curve, 0.5),
					halfT = (minT + maxT) / 2;
				computeParts(split[0], index, minT, halfT);
				computeParts(split[1], index, halfT, maxT);
			} else {
				var x = curve[6] - curve[0],
					y = curve[7] - curve[1],
					dist = Math.sqrt(x * x + y * y);
				if (dist > 1e-6) {
					length += dist;
					parts.push({
						offset: length,
						value: maxT,
						index: index
					});
				}
			}
		}

		for (var i = 1, l = segments.length; i < l; i++) {
			segment2 = segments[i];
			addCurve(segment1, segment2);
			segment1 = segment2;
		}
		if (path._closed)
			addCurve(segment2, segments[0]);

		this.curves = curves;
		this.parts = parts;
		this.length = length;
		this.index = 0;
	},

	getParameterAt: function(offset) {
		var i, j = this.index;
		for (;;) {
			i = j;
			if (j == 0 || this.parts[--j].offset < offset)
				break;
		}
		for (var l = this.parts.length; i < l; i++) {
			var part = this.parts[i];
			if (part.offset >= offset) {
				this.index = i;
				var prev = this.parts[i - 1];
				var prevVal = prev && prev.index == part.index ? prev.value : 0,
					prevLen = prev ? prev.offset : 0;
				return {
					value: prevVal + (part.value - prevVal)
						* (offset - prevLen) / (part.offset - prevLen),
					index: part.index
				};
			}
		}
		var part = this.parts[this.parts.length - 1];
		return {
			value: 1,
			index: part.index
		};
	},

	drawPart: function(ctx, from, to) {
		from = this.getParameterAt(from);
		to = this.getParameterAt(to);
		for (var i = from.index; i <= to.index; i++) {
			var curve = Curve.getPart(this.curves[i],
					i == from.index ? from.value : 0,
					i == to.index ? to.value : 1);
			if (i == from.index)
				ctx.moveTo(curve[0], curve[1]);
			ctx.bezierCurveTo.apply(ctx, curve.slice(2));
		}
	}
}, Base.each(Curve.evaluateMethods,
	function(name) {
		this[name + 'At'] = function(offset, weighted) {
			var param = this.getParameterAt(offset);
			return Curve[name](this.curves[param.index], param.value, weighted);
		};
	}, {})
);

var PathFitter = Base.extend({
	initialize: function(path, error) {
		var points = this.points = [],
			segments = path._segments,
			prev;
		for (var i = 0, l = segments.length; i < l; i++) {
			var point = segments[i].point.clone();
			if (!prev || !prev.equals(point)) {
				points.push(point);
				prev = point;
			}
		}

		if (path._closed) {
			this.closed = true;
			points.unshift(points[points.length - 1]);
			points.push(points[1]);
		}

		this.error = error;
	},

	fit: function() {
		var points = this.points,
			length = points.length,
			segments = this.segments = length > 0
					? [new Segment(points[0])] : [];
		if (length > 1)
			this.fitCubic(0, length - 1,
				points[1].subtract(points[0]).normalize(),
				points[length - 2].subtract(points[length - 1]).normalize());

		if (this.closed) {
			segments.shift();
			segments.pop();
		}

		return segments;
	},

	fitCubic: function(first, last, tan1, tan2) {
		if (last - first == 1) {
			var pt1 = this.points[first],
				pt2 = this.points[last],
				dist = pt1.getDistance(pt2) / 3;
			this.addCurve([pt1, pt1.add(tan1.normalize(dist)),
					pt2.add(tan2.normalize(dist)), pt2]);
			return;
		}
		var uPrime = this.chordLengthParameterize(first, last),
			maxError = Math.max(this.error, this.error * this.error),
			split,
			parametersInOrder = true;
		for (var i = 0; i <= 4; i++) {
			var curve = this.generateBezier(first, last, uPrime, tan1, tan2);
			var max = this.findMaxError(first, last, curve, uPrime);
			if (max.error < this.error && parametersInOrder) {
				this.addCurve(curve);
				return;
			}
			split = max.index;
			if (max.error >= maxError)
				break;
			parametersInOrder = this.reparameterize(first, last, uPrime, curve);
			maxError = max.error;
		}
		var V1 = this.points[split - 1].subtract(this.points[split]),
			V2 = this.points[split].subtract(this.points[split + 1]),
			tanCenter = V1.add(V2).divide(2).normalize();
		this.fitCubic(first, split, tan1, tanCenter);
		this.fitCubic(split, last, tanCenter.negate(), tan2);
	},

	addCurve: function(curve) {
		var prev = this.segments[this.segments.length - 1];
		prev.setHandleOut(curve[1].subtract(curve[0]));
		this.segments.push(
				new Segment(curve[3], curve[2].subtract(curve[3])));
	},

	generateBezier: function(first, last, uPrime, tan1, tan2) {
		var epsilon = 1e-12,
			pt1 = this.points[first],
			pt2 = this.points[last],
			C = [[0, 0], [0, 0]],
			X = [0, 0];

		for (var i = 0, l = last - first + 1; i < l; i++) {
			var u = uPrime[i],
				t = 1 - u,
				b = 3 * u * t,
				b0 = t * t * t,
				b1 = b * t,
				b2 = b * u,
				b3 = u * u * u,
				a1 = tan1.normalize(b1),
				a2 = tan2.normalize(b2),
				tmp = this.points[first + i]
					.subtract(pt1.multiply(b0 + b1))
					.subtract(pt2.multiply(b2 + b3));
			C[0][0] += a1.dot(a1);
			C[0][1] += a1.dot(a2);
			C[1][0] = C[0][1];
			C[1][1] += a2.dot(a2);
			X[0] += a1.dot(tmp);
			X[1] += a2.dot(tmp);
		}

		var detC0C1 = C[0][0] * C[1][1] - C[1][0] * C[0][1],
			alpha1, alpha2;
		if (Math.abs(detC0C1) > epsilon) {
			var detC0X	= C[0][0] * X[1]	- C[1][0] * X[0],
				detXC1	= X[0]	  * C[1][1] - X[1]	  * C[0][1];
			alpha1 = detXC1 / detC0C1;
			alpha2 = detC0X / detC0C1;
		} else {
			var c0 = C[0][0] + C[0][1],
				c1 = C[1][0] + C[1][1];
			if (Math.abs(c0) > epsilon) {
				alpha1 = alpha2 = X[0] / c0;
			} else if (Math.abs(c1) > epsilon) {
				alpha1 = alpha2 = X[1] / c1;
			} else {
				alpha1 = alpha2 = 0;
			}
		}

		var segLength = pt2.getDistance(pt1),
			eps = epsilon * segLength,
			handle1,
			handle2;
		if (alpha1 < eps || alpha2 < eps) {
			alpha1 = alpha2 = segLength / 3;
		} else {
			var line = pt2.subtract(pt1);
			handle1 = tan1.normalize(alpha1);
			handle2 = tan2.normalize(alpha2);
			if (handle1.dot(line) - handle2.dot(line) > segLength * segLength) {
				alpha1 = alpha2 = segLength / 3;
				handle1 = handle2 = null;
			}
		}

		return [pt1, pt1.add(handle1 || tan1.normalize(alpha1)),
				pt2.add(handle2 || tan2.normalize(alpha2)), pt2];
	},

	reparameterize: function(first, last, u, curve) {
		for (var i = first; i <= last; i++) {
			u[i - first] = this.findRoot(curve, this.points[i], u[i - first]);
		}
		for (var i = 1, l = u.length; i < l; i++) {
			if (u[i] <= u[i - 1])
				return false;
		}
		return true;
	},

	findRoot: function(curve, point, u) {
		var curve1 = [],
			curve2 = [];
		for (var i = 0; i <= 2; i++) {
			curve1[i] = curve[i + 1].subtract(curve[i]).multiply(3);
		}
		for (var i = 0; i <= 1; i++) {
			curve2[i] = curve1[i + 1].subtract(curve1[i]).multiply(2);
		}
		var pt = this.evaluate(3, curve, u),
			pt1 = this.evaluate(2, curve1, u),
			pt2 = this.evaluate(1, curve2, u),
			diff = pt.subtract(point),
			df = pt1.dot(pt1) + diff.dot(pt2);
		if (Math.abs(df) < 1e-6)
			return u;
		return u - diff.dot(pt1) / df;
	},

	evaluate: function(degree, curve, t) {
		var tmp = curve.slice();
		for (var i = 1; i <= degree; i++) {
			for (var j = 0; j <= degree - i; j++) {
				tmp[j] = tmp[j].multiply(1 - t).add(tmp[j + 1].multiply(t));
			}
		}
		return tmp[0];
	},

	chordLengthParameterize: function(first, last) {
		var u = [0];
		for (var i = first + 1; i <= last; i++) {
			u[i - first] = u[i - first - 1]
					+ this.points[i].getDistance(this.points[i - 1]);
		}
		for (var i = 1, m = last - first; i <= m; i++) {
			u[i] /= u[m];
		}
		return u;
	},

	findMaxError: function(first, last, curve, u) {
		var index = Math.floor((last - first + 1) / 2),
			maxDist = 0;
		for (var i = first + 1; i < last; i++) {
			var P = this.evaluate(3, curve, u[i - first]);
			var v = P.subtract(this.points[i]);
			var dist = v.x * v.x + v.y * v.y;
			if (dist >= maxDist) {
				maxDist = dist;
				index = i;
			}
		}
		return {
			error: maxDist,
			index: index
		};
	}
});

var TextItem = Item.extend({
	_class: 'TextItem',
	_boundsSelected: true,
	_applyMatrix: false,
	_canApplyMatrix: false,
	_serializeFields: {
		content: null
	},
	_boundsGetter: 'getBounds',

	initialize: function TextItem(arg) {
		this._content = '';
		this._lines = [];
		var hasProps = arg && Base.isPlainObject(arg)
				&& arg.x === undefined && arg.y === undefined;
		this._initialize(hasProps && arg, !hasProps && Point.read(arguments));
	},

	_equals: function(item) {
		return this._content === item._content;
	},

	_clone: function _clone(copy, insert, includeMatrix) {
		copy.setContent(this._content);
		return _clone.base.call(this, copy, insert, includeMatrix);
	},

	getContent: function() {
		return this._content;
	},

	setContent: function(content) {
		this._content = '' + content;
		this._lines = this._content.split(/\r\n|\n|\r/mg);
		this._changed(265);
	},

	isEmpty: function() {
		return !this._content;
	},

	getCharacterStyle: '#getStyle',
	setCharacterStyle: '#setStyle',

	getParagraphStyle: '#getStyle',
	setParagraphStyle: '#setStyle'
});

var PointText = TextItem.extend({
	_class: 'PointText',

	initialize: function PointText() {
		TextItem.apply(this, arguments);
	},

	clone: function(insert) {
		return this._clone(new PointText(Item.NO_INSERT), insert);
	},

	getPoint: function() {
		var point = this._matrix.getTranslation();
		return new LinkedPoint(point.x, point.y, this, 'setPoint');
	},

	setPoint: function() {
		var point = Point.read(arguments);
		this.translate(point.subtract(this._matrix.getTranslation()));
	},

	_draw: function(ctx) {
		if (!this._content)
			return;
		this._setStyles(ctx);
		var style = this._style,
			lines = this._lines,
			leading = style.getLeading(),
			shadowColor = ctx.shadowColor;
		ctx.font = style.getFontStyle();
		ctx.textAlign = style.getJustification();
		for (var i = 0, l = lines.length; i < l; i++) {
			ctx.shadowColor = shadowColor;
			var line = lines[i];
			if (style.hasFill()) {
				ctx.fillText(line, 0, 0);
				ctx.shadowColor = 'rgba(0,0,0,0)';
			}
			if (style.hasStroke())
				ctx.strokeText(line, 0, 0);
			ctx.translate(0, leading);
		}
	},

	_getBounds: function(getter, matrix) {
		var style = this._style,
			lines = this._lines,
			numLines = lines.length,
			justification = style.getJustification(),
			leading = style.getLeading(),
			width = this.getView().getTextWidth(style.getFontStyle(), lines),
			x = 0;
		if (justification !== 'left')
			x -= width / (justification === 'center' ? 2: 1);
		var bounds = new Rectangle(x,
					numLines ? - 0.75 * leading : 0,
					width, numLines * leading);
		return matrix ? matrix._transformBounds(bounds, bounds) : bounds;
	}
});

var Color = Base.extend(new function() {
	var types = {
		gray: ['gray'],
		rgb: ['red', 'green', 'blue'],
		hsb: ['hue', 'saturation', 'brightness'],
		hsl: ['hue', 'saturation', 'lightness'],
		gradient: ['gradient', 'origin', 'destination', 'highlight']
	};

	var componentParsers = {},
		colorCache = {},
		colorCtx;

	function fromCSS(string) {
		var match = string.match(/^#(\w{1,2})(\w{1,2})(\w{1,2})$/),
			components;
		if (match) {
			components = [0, 0, 0];
			for (var i = 0; i < 3; i++) {
				var value = match[i + 1];
				components[i] = parseInt(value.length == 1
						? value + value : value, 16) / 255;
			}
		} else if (match = string.match(/^rgba?\((.*)\)$/)) {
			components = match[1].split(',');
			for (var i = 0, l = components.length; i < l; i++) {
				var value = +components[i];
				components[i] = i < 3 ? value / 255 : value;
			}
		} else {
			var cached = colorCache[string];
			if (!cached) {
				if (!colorCtx) {
					colorCtx = CanvasProvider.getContext(1, 1);
					colorCtx.globalCompositeOperation = 'copy';
				}
				colorCtx.fillStyle = 'rgba(0,0,0,0)';
				colorCtx.fillStyle = string;
				colorCtx.fillRect(0, 0, 1, 1);
				var data = colorCtx.getImageData(0, 0, 1, 1).data;
				cached = colorCache[string] = [
					data[0] / 255,
					data[1] / 255,
					data[2] / 255
				];
			}
			components = cached.slice();
		}
		return components;
	}

	var hsbIndices = [
		[0, 3, 1],
		[2, 0, 1],
		[1, 0, 3],
		[1, 2, 0],
		[3, 1, 0],
		[0, 1, 2]
	];

	var converters = {
		'rgb-hsb': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				h = delta === 0 ? 0
					:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:			 (r - g) / delta + 4) * 60;
			return [h, max === 0 ? 0 : delta / max, max];
		},

		'hsb-rgb': function(h, s, b) {
			h = (((h / 60) % 6) + 6) % 6;
			var i = Math.floor(h),
				f = h - i,
				i = hsbIndices[i],
				v = [
					b,
					b * (1 - s),
					b * (1 - s * f),
					b * (1 - s * (1 - f))
				];
			return [v[i[0]], v[i[1]], v[i[2]]];
		},

		'rgb-hsl': function(r, g, b) {
			var max = Math.max(r, g, b),
				min = Math.min(r, g, b),
				delta = max - min,
				achromatic = delta === 0,
				h = achromatic ? 0
					:	( max == r ? (g - b) / delta + (g < b ? 6 : 0)
						: max == g ? (b - r) / delta + 2
						:			 (r - g) / delta + 4) * 60,
				l = (max + min) / 2,
				s = achromatic ? 0 : l < 0.5
						? delta / (max + min)
						: delta / (2 - max - min);
			return [h, s, l];
		},

		'hsl-rgb': function(h, s, l) {
			h = (((h / 360) % 1) + 1) % 1;
			if (s === 0)
				return [l, l, l];
			var t3s = [ h + 1 / 3, h, h - 1 / 3 ],
				t2 = l < 0.5 ? l * (1 + s) : l + s - l * s,
				t1 = 2 * l - t2,
				c = [];
			for (var i = 0; i < 3; i++) {
				var t3 = t3s[i];
				if (t3 < 0) t3 += 1;
				if (t3 > 1) t3 -= 1;
				c[i] = 6 * t3 < 1
					? t1 + (t2 - t1) * 6 * t3
					: 2 * t3 < 1
						? t2
						: 3 * t3 < 2
							? t1 + (t2 - t1) * ((2 / 3) - t3) * 6
							: t1;
			}
			return c;
		},

		'rgb-gray': function(r, g, b) {
			return [r * 0.2989 + g * 0.587 + b * 0.114];
		},

		'gray-rgb': function(g) {
			return [g, g, g];
		},

		'gray-hsb': function(g) {
			return [0, 0, g];
		},

		'gray-hsl': function(g) {
			return [0, 0, g];
		},

		'gradient-rgb': function() {
			return [];
		},

		'rgb-gradient': function() {
			return [];
		}

	};

	return Base.each(types, function(properties, type) {
		componentParsers[type] = [];
		Base.each(properties, function(name, index) {
			var part = Base.capitalize(name),
				hasOverlap = /^(hue|saturation)$/.test(name),
				parser = componentParsers[type][index] = name === 'gradient'
					? function(value) {
						var current = this._components[0];
						value = Gradient.read(Array.isArray(value) ? value
								: arguments, 0, { readNull: true });
						if (current !== value) {
							if (current)
								current._removeOwner(this);
							if (value)
								value._addOwner(this);
						}
						return value;
					}
					: type === 'gradient'
						? function() {
							return Point.read(arguments, 0, {
									readNull: name === 'highlight',
									clone: true
							});
						}
						: function(value) {
							return value == null || isNaN(value) ? 0 : value;
						};

			this['get' + part] = function() {
				return this._type === type
					|| hasOverlap && /^hs[bl]$/.test(this._type)
						? this._components[index]
						: this._convert(type)[index];
			};

			this['set' + part] = function(value) {
				if (this._type !== type
						&& !(hasOverlap && /^hs[bl]$/.test(this._type))) {
					this._components = this._convert(type);
					this._properties = types[type];
					this._type = type;
				}
				this._components[index] = parser.call(this, value);
				this._changed();
			};
		}, this);
	}, {
		_class: 'Color',
		_readIndex: true,

		initialize: function Color(arg) {
			var slice = Array.prototype.slice,
				args = arguments,
				read = 0,
				type,
				components,
				alpha,
				values;
			if (Array.isArray(arg)) {
				args = arg;
				arg = args[0];
			}
			var argType = arg != null && typeof arg;
			if (argType === 'string' && arg in types) {
				type = arg;
				arg = args[1];
				if (Array.isArray(arg)) {
					components = arg;
					alpha = args[2];
				} else {
					if (this.__read)
						read = 1;
					args = slice.call(args, 1);
					argType = typeof arg;
				}
			}
			if (!components) {
				values = argType === 'number'
						? args
						: argType === 'object' && arg.length != null
							? arg
							: null;
				if (values) {
					if (!type)
						type = values.length >= 3
								? 'rgb'
								: 'gray';
					var length = types[type].length;
					alpha = values[length];
					if (this.__read)
						read += values === arguments
							? length + (alpha != null ? 1 : 0)
							: 1;
					if (values.length > length)
						values = slice.call(values, 0, length);
				} else if (argType === 'string') {
					type = 'rgb';
					components = fromCSS(arg);
					if (components.length === 4) {
						alpha = components[3];
						components.length--;
					}
				} else if (argType === 'object') {
					if (arg.constructor === Color) {
						type = arg._type;
						components = arg._components.slice();
						alpha = arg._alpha;
						if (type === 'gradient') {
							for (var i = 1, l = components.length; i < l; i++) {
								var point = components[i];
								if (point)
									components[i] = point.clone();
							}
						}
					} else if (arg.constructor === Gradient) {
						type = 'gradient';
						values = args;
					} else {
						type = 'hue' in arg
							? 'lightness' in arg
								? 'hsl'
								: 'hsb'
							: 'gradient' in arg || 'stops' in arg
									|| 'radial' in arg
								? 'gradient'
								: 'gray' in arg
									? 'gray'
									: 'rgb';
						var properties = types[type],
							parsers = componentParsers[type];
						this._components = components = [];
						for (var i = 0, l = properties.length; i < l; i++) {
							var value = arg[properties[i]];
							if (value == null && i === 0 && type === 'gradient'
									&& 'stops' in arg) {
								value = {
									stops: arg.stops,
									radial: arg.radial
								};
							}
							value = parsers[i].call(this, value);
							if (value != null)
								components[i] = value;
						}
						alpha = arg.alpha;
					}
				}
				if (this.__read && type)
					read = 1;
			}
			this._type = type || 'rgb';
			this._id = UID.get(Color);
			if (!components) {
				this._components = components = [];
				var parsers = componentParsers[this._type];
				for (var i = 0, l = parsers.length; i < l; i++) {
					var value = parsers[i].call(this, values && values[i]);
					if (value != null)
						components[i] = value;
				}
			}
			this._components = components;
			this._properties = types[this._type];
			this._alpha = alpha;
			if (this.__read)
				this.__read = read;
		},

		_serialize: function(options, dictionary) {
			var components = this.getComponents();
			return Base.serialize(
					/^(gray|rgb)$/.test(this._type)
						? components
						: [this._type].concat(components),
					options, true, dictionary);
		},

		_changed: function() {
			this._canvasStyle = null;
			if (this._owner)
				this._owner._changed(65);
		},

		_convert: function(type) {
			var converter;
			return this._type === type
					? this._components.slice()
					: (converter = converters[this._type + '-' + type])
						? converter.apply(this, this._components)
						: converters['rgb-' + type].apply(this,
							converters[this._type + '-rgb'].apply(this,
								this._components));
		},

		convert: function(type) {
			return new Color(type, this._convert(type), this._alpha);
		},

		getType: function() {
			return this._type;
		},

		setType: function(type) {
			this._components = this._convert(type);
			this._properties = types[type];
			this._type = type;
		},

		getComponents: function() {
			var components = this._components.slice();
			if (this._alpha != null)
				components.push(this._alpha);
			return components;
		},

		getAlpha: function() {
			return this._alpha != null ? this._alpha : 1;
		},

		setAlpha: function(alpha) {
			this._alpha = alpha == null ? null : Math.min(Math.max(alpha, 0), 1);
			this._changed();
		},

		hasAlpha: function() {
			return this._alpha != null;
		},

		equals: function(color) {
			var col = Base.isPlainValue(color, true)
					? Color.read(arguments)
					: color;
			return col === this || col && this._class === col._class
					&& this._type === col._type
					&& this._alpha === col._alpha
					&& Base.equals(this._components, col._components)
					|| false;
		},

		toString: function() {
			var properties = this._properties,
				parts = [],
				isGradient = this._type === 'gradient',
				f = Formatter.instance;
			for (var i = 0, l = properties.length; i < l; i++) {
				var value = this._components[i];
				if (value != null)
					parts.push(properties[i] + ': '
							+ (isGradient ? value : f.number(value)));
			}
			if (this._alpha != null)
				parts.push('alpha: ' + f.number(this._alpha));
			return '{ ' + parts.join(', ') + ' }';
		},

		toCSS: function(hex) {
			var components = this._convert('rgb'),
				alpha = hex || this._alpha == null ? 1 : this._alpha;
			function convert(val) {
				return Math.round((val < 0 ? 0 : val > 1 ? 1 : val) * 255);
			}
			components = [
				convert(components[0]),
				convert(components[1]),
				convert(components[2])
			];
			if (alpha < 1)
				components.push(alpha < 0 ? 0 : alpha);
			return hex
					? '#' + ((1 << 24) + (components[0] << 16)
						+ (components[1] << 8)
						+ components[2]).toString(16).slice(1)
					: (components.length == 4 ? 'rgba(' : 'rgb(')
						+ components.join(',') + ')';
		},

		toCanvasStyle: function(ctx) {
			if (this._canvasStyle)
				return this._canvasStyle;
			if (this._type !== 'gradient')
				return this._canvasStyle = this.toCSS();
			var components = this._components,
				gradient = components[0],
				stops = gradient._stops,
				origin = components[1],
				destination = components[2],
				canvasGradient;
			if (gradient._radial) {
				var radius = destination.getDistance(origin),
					highlight = components[3];
				if (highlight) {
					var vector = highlight.subtract(origin);
					if (vector.getLength() > radius)
						highlight = origin.add(vector.normalize(radius - 0.1));
				}
				var start = highlight || origin;
				canvasGradient = ctx.createRadialGradient(start.x, start.y,
						0, origin.x, origin.y, radius);
			} else {
				canvasGradient = ctx.createLinearGradient(origin.x, origin.y,
						destination.x, destination.y);
			}
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i];
				canvasGradient.addColorStop(stop._rampPoint,
						stop._color.toCanvasStyle());
			}
			return this._canvasStyle = canvasGradient;
		},

		transform: function(matrix) {
			if (this._type === 'gradient') {
				var components = this._components;
				for (var i = 1, l = components.length; i < l; i++) {
					var point = components[i];
					matrix._transformPoint(point, point, true);
				}
				this._changed();
			}
		},

		statics: {
			_types: types,

			random: function() {
				var random = Math.random;
				return new Color(random(), random(), random());
			}
		}
	});
},
new function() {
	var operators = {
		add: function(a, b) {
			return a + b;
		},

		subtract: function(a, b) {
			return a - b;
		},

		multiply: function(a, b) {
			return a * b;
		},

		divide: function(a, b) {
			return a / b;
		}
	};

	return Base.each(operators, function(operator, name) {
		this[name] = function(color) {
			color = Color.read(arguments);
			var type = this._type,
				components1 = this._components,
				components2 = color._convert(type);
			for (var i = 0, l = components1.length; i < l; i++)
				components2[i] = operator(components1[i], components2[i]);
			return new Color(type, components2,
					this._alpha != null
							? operator(this._alpha, color.getAlpha())
							: null);
		};
	}, {
	});
});

var Gradient = Base.extend({
	_class: 'Gradient',

	initialize: function Gradient(stops, radial) {
		this._id = UID.get();
		if (stops && this._set(stops))
			stops = radial = null;
		if (!this._stops)
			this.setStops(stops || ['white', 'black']);
		if (this._radial == null)
			this.setRadial(typeof radial === 'string' && radial === 'radial'
					|| radial || false);
	},

	_serialize: function(options, dictionary) {
		return dictionary.add(this, function() {
			return Base.serialize([this._stops, this._radial],
					options, true, dictionary);
		});
	},

	_changed: function() {
		for (var i = 0, l = this._owners && this._owners.length; i < l; i++)
			this._owners[i]._changed();
	},

	_addOwner: function(color) {
		if (!this._owners)
			this._owners = [];
		this._owners.push(color);
	},

	_removeOwner: function(color) {
		var index = this._owners ? this._owners.indexOf(color) : -1;
		if (index != -1) {
			this._owners.splice(index, 1);
			if (this._owners.length === 0)
				this._owners = undefined;
		}
	},

	clone: function() {
		var stops = [];
		for (var i = 0, l = this._stops.length; i < l; i++)
			stops[i] = this._stops[i].clone();
		return new Gradient(stops, this._radial);
	},

	getStops: function() {
		return this._stops;
	},

	setStops: function(stops) {
		if (this.stops) {
			for (var i = 0, l = this._stops.length; i < l; i++)
				this._stops[i]._owner = undefined;
		}
		if (stops.length < 2)
			throw new Error(
					'Gradient stop list needs to contain at least two stops.');
		this._stops = GradientStop.readAll(stops, 0, { clone: true });
		for (var i = 0, l = this._stops.length; i < l; i++) {
			var stop = this._stops[i];
			stop._owner = this;
			if (stop._defaultRamp)
				stop.setRampPoint(i / (l - 1));
		}
		this._changed();
	},

	getRadial: function() {
		return this._radial;
	},

	setRadial: function(radial) {
		this._radial = radial;
		this._changed();
	},

	equals: function(gradient) {
		if (gradient === this)
			return true;
		if (gradient && this._class === gradient._class
				&& this._stops.length === gradient._stops.length) {
			for (var i = 0, l = this._stops.length; i < l; i++) {
				if (!this._stops[i].equals(gradient._stops[i]))
					return false;
			}
			return true;
		}
		return false;
	}
});

var GradientStop = Base.extend({
	_class: 'GradientStop',

	initialize: function GradientStop(arg0, arg1) {
		if (arg0) {
			var color, rampPoint;
			if (arg1 === undefined && Array.isArray(arg0)) {
				color = arg0[0];
				rampPoint = arg0[1];
			} else if (arg0.color) {
				color = arg0.color;
				rampPoint = arg0.rampPoint;
			} else {
				color = arg0;
				rampPoint = arg1;
			}
			this.setColor(color);
			this.setRampPoint(rampPoint);
		}
	},

	clone: function() {
		return new GradientStop(this._color.clone(), this._rampPoint);
	},

	_serialize: function(options, dictionary) {
		return Base.serialize([this._color, this._rampPoint], options, true,
				dictionary);
	},

	_changed: function() {
		if (this._owner)
			this._owner._changed(65);
	},

	getRampPoint: function() {
		return this._rampPoint;
	},

	setRampPoint: function(rampPoint) {
		this._defaultRamp = rampPoint == null;
		this._rampPoint = rampPoint || 0;
		this._changed();
	},

	getColor: function() {
		return this._color;
	},

	setColor: function(color) {
		this._color = Color.read(arguments);
		if (this._color === color)
			this._color = color.clone();
		this._color._owner = this;
		this._changed();
	},

	equals: function(stop) {
		return stop === this || stop && this._class === stop._class
				&& this._color.equals(stop._color)
				&& this._rampPoint == stop._rampPoint
				|| false;
	}
});

var Style = Base.extend(new function() {
	var defaults = {
		fillColor: undefined,
		strokeColor: undefined,
		strokeWidth: 1,
		strokeCap: 'butt',
		strokeJoin: 'miter',
		strokeScaling: true,
		miterLimit: 10,
		dashOffset: 0,
		dashArray: [],
		windingRule: 'nonzero',
		shadowColor: undefined,
		shadowBlur: 0,
		shadowOffset: new Point(),
		selectedColor: undefined,
		fontFamily: 'sans-serif',
		fontWeight: 'normal',
		fontSize: 12,
		font: 'sans-serif',
		leading: null,
		justification: 'left'
	};

	var flags = {
		strokeWidth: 97,
		strokeCap: 97,
		strokeJoin: 97,
		strokeScaling: 105,
		miterLimit: 97,
		fontFamily: 9,
		fontWeight: 9,
		fontSize: 9,
		font: 9,
		leading: 9,
		justification: 9
	};

	var item = { beans: true },
		fields = {
			_defaults: defaults,
			_textDefaults: new Base(defaults, {
				fillColor: new Color()
			}),
			beans: true
		};

	Base.each(defaults, function(value, key) {
		var isColor = /Color$/.test(key),
			isPoint = key === 'shadowOffset',
			part = Base.capitalize(key),
			flag = flags[key],
			set = 'set' + part,
			get = 'get' + part;

		fields[set] = function(value) {
			var owner = this._owner,
				children = owner && owner._children;
			if (children && children.length > 0
					&& !(owner instanceof CompoundPath)) {
				for (var i = 0, l = children.length; i < l; i++)
					children[i]._style[set](value);
			} else {
				var old = this._values[key];
				if (old !== value) {
					if (isColor) {
						if (old)
							old._owner = undefined;
						if (value && value.constructor === Color) {
							if (value._owner)
								value = value.clone();
							value._owner = owner;
						}
					}
					this._values[key] = value;
					if (owner)
						owner._changed(flag || 65);
				}
			}
		};

		fields[get] = function(_dontMerge) {
			var owner = this._owner,
				children = owner && owner._children,
				value;
			if (!children || children.length === 0 || _dontMerge
					|| owner instanceof CompoundPath) {
				var value = this._values[key];
				if (value === undefined) {
					value = this._defaults[key];
					if (value && value.clone)
						value = value.clone();
				} else {
					var ctor = isColor ? Color : isPoint ? Point : null;
					if (ctor && !(value && value.constructor === ctor)) {
						this._values[key] = value = ctor.read([value], 0,
								{ readNull: true, clone: true });
						if (value && isColor)
							value._owner = owner;
					}
				}
				return value;
			}
			for (var i = 0, l = children.length; i < l; i++) {
				var childValue = children[i]._style[get]();
				if (i === 0) {
					value = childValue;
				} else if (!Base.equals(value, childValue)) {
					return undefined;
				}
			}
			return value;
		};

		item[get] = function(_dontMerge) {
			return this._style[get](_dontMerge);
		};

		item[set] = function(value) {
			this._style[set](value);
		};
	});

	Item.inject(item);
	return fields;
}, {
	_class: 'Style',

	initialize: function Style(style, _owner, _project) {
		this._values = {};
		this._owner = _owner;
		this._project = _owner && _owner._project || _project || paper.project;
		if (_owner instanceof TextItem)
			this._defaults = this._textDefaults;
		if (style)
			this.set(style);
	},

	set: function(style) {
		var isStyle = style instanceof Style,
			values = isStyle ? style._values : style;
		if (values) {
			for (var key in values) {
				if (key in this._defaults) {
					var value = values[key];
					this[key] = value && isStyle && value.clone
							? value.clone() : value;
				}
			}
		}
	},

	equals: function(style) {
		return style === this || style && this._class === style._class
				&& Base.equals(this._values, style._values)
				|| false;
	},

	hasFill: function() {
		return !!this.getFillColor();
	},

	hasStroke: function() {
		return !!this.getStrokeColor() && this.getStrokeWidth() > 0;
	},

	hasShadow: function() {
		return !!this.getShadowColor() && this.getShadowBlur() > 0;
	},

	getView: function() {
		return this._project.getView();
	},

	getFontStyle: function() {
		var fontSize = this.getFontSize();
		return this.getFontWeight()
				+ ' ' + fontSize + (/[a-z]/i.test(fontSize + '') ? ' ' : 'px ')
				+ this.getFontFamily();
	},

	getFont: '#getFontFamily',
	setFont: '#setFontFamily',

	getLeading: function getLeading() {
		var leading = getLeading.base.call(this),
			fontSize = this.getFontSize();
		if (/pt|em|%|px/.test(fontSize))
			fontSize = this.getView().getPixelSize(fontSize);
		return leading != null ? leading : fontSize * 1.2;
	}

});

var DomElement = new function() {
	function handlePrefix(el, name, set, value) {
		var prefixes = ['', 'webkit', 'moz', 'Moz', 'ms', 'o'],
			suffix = name[0].toUpperCase() + name.substring(1);
		for (var i = 0; i < 6; i++) {
			var prefix = prefixes[i],
				key = prefix ? prefix + suffix : name;
			if (key in el) {
				if (set) {
					el[key] = value;
				} else {
					return el[key];
				}
				break;
			}
		}
	}

	return {
		getStyles: function(el) {
			var doc = el && el.nodeType !== 9 ? el.ownerDocument : el,
				view = doc && doc.defaultView;
			return view && view.getComputedStyle(el, '');
		},

		getBounds: function(el, viewport) {
			var doc = el.ownerDocument,
				body = doc.body,
				html = doc.documentElement,
				rect;
			try {
				rect = el.getBoundingClientRect();
			} catch (e) {
				rect = { left: 0, top: 0, width: 0, height: 0 };
			}
			var x = rect.left - (html.clientLeft || body.clientLeft || 0),
				y = rect.top - (html.clientTop || body.clientTop || 0);
			if (!viewport) {
				var view = doc.defaultView;
				x += view.pageXOffset || html.scrollLeft || body.scrollLeft;
				y += view.pageYOffset || html.scrollTop || body.scrollTop;
			}
			return new Rectangle(x, y, rect.width, rect.height);
		},

		getViewportBounds: function(el) {
			var doc = el.ownerDocument,
				view = doc.defaultView,
				html = doc.documentElement;
			return new Rectangle(0, 0,
				view.innerWidth || html.clientWidth,
				view.innerHeight || html.clientHeight
			);
		},

		getOffset: function(el, viewport) {
			return DomElement.getBounds(el, viewport).getPoint();
		},

		getSize: function(el) {
			return DomElement.getBounds(el, true).getSize();
		},

		isInvisible: function(el) {
			return DomElement.getSize(el).equals(new Size(0, 0));
		},

		isInView: function(el) {
			return !DomElement.isInvisible(el)
					&& DomElement.getViewportBounds(el).intersects(
						DomElement.getBounds(el, true));
		},

		getPrefixed: function(el, name) {
			return handlePrefix(el, name);
		},

		setPrefixed: function(el, name, value) {
			if (typeof name === 'object') {
				for (var key in name)
					handlePrefix(el, key, true, name[key]);
			} else {
				handlePrefix(el, name, true, value);
			}
		}
	};
};

var DomEvent = {
	add: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.addEventListener(parts[i], func, false);
		}
	},

	remove: function(el, events) {
		for (var type in events) {
			var func = events[type],
				parts = type.split(/[\s,]+/g);
			for (var i = 0, l = parts.length; i < l; i++)
				el.removeEventListener(parts[i], func, false);
		}
	},

	getPoint: function(event) {
		var pos = event.targetTouches
				? event.targetTouches.length
					? event.targetTouches[0]
					: event.changedTouches[0]
				: event;
		return new Point(
			pos.pageX || pos.clientX + document.documentElement.scrollLeft,
			pos.pageY || pos.clientY + document.documentElement.scrollTop
		);
	},

	getTarget: function(event) {
		return event.target || event.srcElement;
	},

	getRelatedTarget: function(event) {
		return event.relatedTarget || event.toElement;
	},

	getOffset: function(event, target) {
		return DomEvent.getPoint(event).subtract(DomElement.getOffset(
				target || DomEvent.getTarget(event)));
	},

	stop: function(event) {
		event.stopPropagation();
		event.preventDefault();
	}
};

DomEvent.requestAnimationFrame = new function() {
	var nativeRequest = DomElement.getPrefixed(window, 'requestAnimationFrame'),
		requested = false,
		callbacks = [],
		focused = true,
		timer;

	DomEvent.add(window, {
		focus: function() {
			focused = true;
		},
		blur: function() {
			focused = false;
		}
	});

	function handleCallbacks() {
		for (var i = callbacks.length - 1; i >= 0; i--) {
			var entry = callbacks[i],
				func = entry[0],
				el = entry[1];
			if (!el || (PaperScope.getAttribute(el, 'keepalive') == 'true'
					|| focused) && DomElement.isInView(el)) {
				callbacks.splice(i, 1);
				func();
			}
		}
		if (nativeRequest) {
			if (callbacks.length) {
				nativeRequest(handleCallbacks);
			} else {
				requested = false;
			}
		}
	}

	return function(callback, element) {
		callbacks.push([callback, element]);
		if (nativeRequest) {
			if (!requested) {
				nativeRequest(handleCallbacks);
				requested = true;
			}
		} else if (!timer) {
			timer = setInterval(handleCallbacks, 1000 / 60);
		}
	};
};

var View = Base.extend(Emitter, {
	_class: 'View',

	initialize: function View(project, element) {
		this._project = project;
		this._scope = project._scope;
		this._element = element;
		var size;
		if (!this._pixelRatio)
			this._pixelRatio = window.devicePixelRatio || 1;
		this._id = element.getAttribute('id');
		if (this._id == null)
			element.setAttribute('id', this._id = 'view-' + View._id++);
		DomEvent.add(element, this._viewEvents);
		var none = 'none';
		DomElement.setPrefixed(element.style, {
			userSelect: none,
			touchAction: none,
			touchCallout: none,
			contentZooming: none,
			userDrag: none,
			tapHighlightColor: 'rgba(0,0,0,0)'
		});

		function getSize(name) {
			return element[name] || parseInt(element.getAttribute(name), 10);
		};

		function getCanvasSize() {
			var size = DomElement.getSize(element);
			return size.isNaN() || size.isZero()
					? new Size(getSize('width'), getSize('height'))
					: size;
		};

		if (PaperScope.hasAttribute(element, 'resize')) {
			var that = this;
			DomEvent.add(window, this._windowEvents = {
				resize: function() {
					that.setViewSize(getCanvasSize());
				}
			});
		}
		this._setViewSize(size = getCanvasSize());
		if (PaperScope.hasAttribute(element, 'stats')
				&& typeof Stats !== 'undefined') {
			this._stats = new Stats();
			var stats = this._stats.domElement,
				style = stats.style,
				offset = DomElement.getOffset(element);
			style.position = 'absolute';
			style.left = offset.x + 'px';
			style.top = offset.y + 'px';
			document.body.appendChild(stats);
		}
		View._views.push(this);
		View._viewsById[this._id] = this;
		this._viewSize = size;
		(this._matrix = new Matrix())._owner = this;
		this._zoom = 1;
		if (!View._focused)
			View._focused = this;
		this._frameItems = {};
		this._frameItemCount = 0;
	},

	remove: function() {
		if (!this._project)
			return false;
		if (View._focused === this)
			View._focused = null;
		View._views.splice(View._views.indexOf(this), 1);
		delete View._viewsById[this._id];
		if (this._project._view === this)
			this._project._view = null;
		DomEvent.remove(this._element, this._viewEvents);
		DomEvent.remove(window, this._windowEvents);
		this._element = this._project = null;
		this.off('frame');
		this._animate = false;
		this._frameItems = {};
		return true;
	},

	_events: Base.each(['onResize', 'onMouseDown', 'onMouseUp', 'onMouseMove'],
		function(name) {
			this[name] = {
				install: function(type) {
					this._installEvent(type);
				},

				uninstall: function(type) {
					this._uninstallEvent(type);
				}
			};
		}, {
			onFrame: {
				install: function() {
					this.play();
				},

				uninstall: function() {
					this.pause();
				}
			}
		}
	),

	_animate: false,
	_time: 0,
	_count: 0,

	_requestFrame: function() {
		var that = this;
		DomEvent.requestAnimationFrame(function() {
			that._requested = false;
			if (!that._animate)
				return;
			that._requestFrame();
			that._handleFrame();
		}, this._element);
		this._requested = true;
	},

	_handleFrame: function() {
		paper = this._scope;
		var now = Date.now() / 1000,
			delta = this._before ? now - this._before : 0;
		this._before = now;
		this._handlingFrame = true;
		this.emit('frame', new Base({
			delta: delta,
			time: this._time += delta,
			count: this._count++
		}));
		if (this._stats)
			this._stats.update();
		this._handlingFrame = false;
		this.update();
	},

	_animateItem: function(item, animate) {
		var items = this._frameItems;
		if (animate) {
			items[item._id] = {
				item: item,
				time: 0,
				count: 0
			};
			if (++this._frameItemCount === 1)
				this.on('frame', this._handleFrameItems);
		} else {
			delete items[item._id];
			if (--this._frameItemCount === 0) {
				this.off('frame', this._handleFrameItems);
			}
		}
	},

	_handleFrameItems: function(event) {
		for (var i in this._frameItems) {
			var entry = this._frameItems[i];
			entry.item.emit('frame', new Base(event, {
				time: entry.time += event.delta,
				count: entry.count++
			}));
		}
	},

	_update: function() {
		this._project._needsUpdate = true;
		if (this._handlingFrame)
			return;
		if (this._animate) {
			this._handleFrame();
		} else {
			this.update();
		}
	},

	_changed: function(flags) {
		if (flags & 1)
			this._project._needsUpdate = true;
	},

	_transform: function(matrix) {
		this._matrix.concatenate(matrix);
		this._bounds = null;
		this._update();
	},

	getElement: function() {
		return this._element;
	},

	getPixelRatio: function() {
		return this._pixelRatio;
	},

	getResolution: function() {
		return this._pixelRatio * 72;
	},

	getViewSize: function() {
		var size = this._viewSize;
		return new LinkedSize(size.width, size.height, this, 'setViewSize');
	},

	setViewSize: function() {
		var size = Size.read(arguments),
			delta = size.subtract(this._viewSize);
		if (delta.isZero())
			return;
		this._viewSize.set(size.width, size.height);
		this._setViewSize(size);
		this._bounds = null;
		this.emit('resize', {
			size: size,
			delta: delta
		});
		this._update();
	},

	_setViewSize: function(size) {
		var element = this._element;
		element.width = size.width;
		element.height = size.height;
	},

	getBounds: function() {
		if (!this._bounds)
			this._bounds = this._matrix.inverted()._transformBounds(
					new Rectangle(new Point(), this._viewSize));
		return this._bounds;
	},

	getSize: function() {
		return this.getBounds().getSize();
	},

	getCenter: function() {
		return this.getBounds().getCenter();
	},

	setCenter: function() {
		var center = Point.read(arguments);
		this.scrollBy(center.subtract(this.getCenter()));
	},

	getZoom: function() {
		return this._zoom;
	},

	setZoom: function(zoom) {
		this._transform(new Matrix().scale(zoom / this._zoom,
			this.getCenter()));
		this._zoom = zoom;
	},

	isVisible: function() {
		return DomElement.isInView(this._element);
	},

	scrollBy: function() {
		this._transform(new Matrix().translate(Point.read(arguments).negate()));
	},

	play: function() {
		this._animate = true;
		if (!this._requested)
			this._requestFrame();
	},

	pause: function() {
		this._animate = false;
	},

	draw: function() {
		this.update();
	},

	projectToView: function() {
		return this._matrix._transformPoint(Point.read(arguments));
	},

	viewToProject: function() {
		return this._matrix._inverseTransform(Point.read(arguments));
	}

}, {
	statics: {
		_views: [],
		_viewsById: {},
		_id: 0,

		create: function(project, element) {
			if (typeof element === 'string')
				element = document.getElementById(element);
			return new CanvasView(project, element);
		}
	}
},
new function() {
	var tool,
		prevFocus,
		tempFocus,
		dragging = false;

	function getView(event) {
		var target = DomEvent.getTarget(event);
		return target.getAttribute && View._viewsById[target.getAttribute('id')];
	}

	function viewToProject(view, event) {
		return view.viewToProject(DomEvent.getOffset(event, view._element));
	}

	function updateFocus() {
		if (!View._focused || !View._focused.isVisible()) {
			for (var i = 0, l = View._views.length; i < l; i++) {
				var view = View._views[i];
				if (view && view.isVisible()) {
					View._focused = tempFocus = view;
					break;
				}
			}
		}
	}

	function handleMouseMove(view, point, event) {
		view._handleEvent('mousemove', point, event);
		var tool = view._scope.tool;
		if (tool) {
			tool._handleEvent(dragging && tool.responds('mousedrag')
					? 'mousedrag' : 'mousemove', point, event);
		}
		view.update();
		return tool;
	}

	var navigator = window.navigator,
		mousedown, mousemove, mouseup;
	if (navigator.pointerEnabled || navigator.msPointerEnabled) {
		mousedown = 'pointerdown MSPointerDown';
		mousemove = 'pointermove MSPointerMove';
		mouseup = 'pointerup pointercancel MSPointerUp MSPointerCancel';
	} else {
		mousedown = 'touchstart';
		mousemove = 'touchmove';
		mouseup = 'touchend touchcancel';
		if (!('ontouchstart' in window && navigator.userAgent.match(
				/mobile|tablet|ip(ad|hone|od)|android|silk/i))) {
			mousedown += ' mousedown';
			mousemove += ' mousemove';
			mouseup += ' mouseup';
		}
	}

	var viewEvents = {
		'selectstart dragstart': function(event) {
			if (dragging)
				event.preventDefault();
		}
	};

	var docEvents = {
		mouseout: function(event) {
			var view = View._focused,
				target = DomEvent.getRelatedTarget(event);
			if (view && (!target || target.nodeName === 'HTML'))
				handleMouseMove(view, viewToProject(view, event), event);
		},

		scroll: updateFocus
	};

	viewEvents[mousedown] = function(event) {
		var view = View._focused = getView(event),
			point = viewToProject(view, event);
		dragging = true;
		view._handleEvent('mousedown', point, event);
		if (tool = view._scope.tool)
			tool._handleEvent('mousedown', point, event);
		view.update();
	};

	docEvents[mousemove] = function(event) {
		var view = View._focused;
		if (!dragging) {
			var target = getView(event);
			if (target) {
				if (view !== target)
					handleMouseMove(view, viewToProject(view, event), event);
				prevFocus = view;
				view = View._focused = tempFocus = target;
			} else if (tempFocus && tempFocus === view) {
				view = View._focused = prevFocus;
				updateFocus();
			}
		}
		if (view) {
			var point = viewToProject(view, event);
			if (dragging || view.getBounds().contains(point))
				tool = handleMouseMove(view, point, event);
		}
	};

	docEvents[mouseup] = function(event) {
		var view = View._focused;
		if (!view || !dragging)
			return;
		var point = viewToProject(view, event);
		dragging = false;
		view._handleEvent('mouseup', point, event);
		if (tool)
			tool._handleEvent('mouseup', point, event);
		view.update();
	};

	DomEvent.add(document, docEvents);

	DomEvent.add(window, {
		load: updateFocus
	});

	var mouseFlags = {
		mousedown: {
			mousedown: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mouseup: {
			mouseup: 1,
			mousedrag: 1,
			click: 1,
			doubleclick: 1
		},
		mousemove: {
			mousedrag: 1,
			mousemove: 1,
			mouseenter: 1,
			mouseleave: 1
		}
	};

	return {
		_viewEvents: viewEvents,

		_handleEvent: function() {},

		_installEvent: function(type) {
			var counters = this._eventCounters;
			if (counters) {
				for (var key in mouseFlags) {
					counters[key] = (counters[key] || 0)
							+ (mouseFlags[key][type] || 0);
				}
			}
		},

		_uninstallEvent: function(type) {
			var counters = this._eventCounters;
			if (counters) {
				for (var key in mouseFlags)
					counters[key] -= mouseFlags[key][type] || 0;
			}
		},

		statics: {
			updateFocus: updateFocus
		}
	};
});

var CanvasView = View.extend({
	_class: 'CanvasView',

	initialize: function CanvasView(project, canvas) {
		if (!(canvas instanceof HTMLCanvasElement)) {
			var size = Size.read(arguments, 1);
			if (size.isZero())
				throw new Error(
						'Cannot create CanvasView with the provided argument: '
						+ [].slice.call(arguments, 1));
			canvas = CanvasProvider.getCanvas(size);
		}
		this._context = canvas.getContext('2d');
		this._eventCounters = {};
		this._pixelRatio = 1;
		if (!/^off|false$/.test(PaperScope.getAttribute(canvas, 'hidpi'))) {
			var deviceRatio = window.devicePixelRatio || 1,
				backingStoreRatio = DomElement.getPrefixed(this._context,
						'backingStorePixelRatio') || 1;
			this._pixelRatio = deviceRatio / backingStoreRatio;
		}
		View.call(this, project, canvas);
	},

	_setViewSize: function(size) {
		var element = this._element,
			pixelRatio = this._pixelRatio,
			width = size.width,
			height = size.height;
		element.width = width * pixelRatio;
		element.height = height * pixelRatio;
		if (pixelRatio !== 1) {
			if (!PaperScope.hasAttribute(element, 'resize')) {
				var style = element.style;
				style.width = width + 'px';
				style.height = height + 'px';
			}
			this._context.scale(pixelRatio, pixelRatio);
		}
	},

	getPixelSize: function(size) {
		var browser = paper.browser,
			pixels;
		if (browser && browser.firefox) {
			var parent = this._element.parentNode,
				temp = document.createElement('div');
			temp.style.fontSize = size;
			parent.appendChild(temp);
			pixels = parseFloat(DomElement.getStyles(temp).fontSize);
			parent.removeChild(temp);
		} else {
			var ctx = this._context,
				prevFont = ctx.font;
			ctx.font = size + ' serif';
			pixels = parseFloat(ctx.font);
			ctx.font = prevFont;
		}
		return pixels;
	},

	getTextWidth: function(font, lines) {
		var ctx = this._context,
			prevFont = ctx.font,
			width = 0;
		ctx.font = font;
		for (var i = 0, l = lines.length; i < l; i++)
			width = Math.max(width, ctx.measureText(lines[i]).width);
		ctx.font = prevFont;
		return width;
	},

	update: function(force) {
		var project = this._project;
		if (!project || !force && !project._needsUpdate)
			return false;
		var ctx = this._context,
			size = this._viewSize;
		ctx.clearRect(0, 0, size.width + 1, size.height + 1);
		project.draw(ctx, this._matrix, this._pixelRatio);
		project._needsUpdate = false;
		return true;
	}
},
new function() {
	var downPoint,
		lastPoint,
		overPoint,
		downItem,
		lastItem,
		overItem,
		dragItem,
		dblClick,
		clickTime;

	function callEvent(view, type, event, point, target, lastPoint) {
		var item = target,
			mouseEvent;

		function call(obj) {
			if (obj.responds(type)) {
				if (!mouseEvent) {
					mouseEvent = new MouseEvent(type, event, point, target,
							lastPoint ? point.subtract(lastPoint) : null);
				}
				if (obj.emit(type, mouseEvent) && mouseEvent.isStopped) {
					event.preventDefault();
					return true;
				}
			}
		}

		while (item) {
			if (call(item))
				return true;
			item = item.getParent();
		}
		if (call(view))
			return true;
		return false;
	}

	return {
		_handleEvent: function(type, point, event) {
			if (!this._eventCounters[type])
				return;
			var project = this._project,
				hit = project.hitTest(point, {
					tolerance: 0,
					fill: true,
					stroke: true
				}),
				item = hit && hit.item,
				stopped = false;
			switch (type) {
			case 'mousedown':
				stopped = callEvent(this, type, event, point, item);
				dblClick = lastItem == item && (Date.now() - clickTime < 300);
				downItem = lastItem = item;
				downPoint = lastPoint = overPoint = point;
				dragItem = !stopped && item;
				while (dragItem && !dragItem.responds('mousedrag'))
					dragItem = dragItem._parent;
				break;
			case 'mouseup':
				stopped = callEvent(this, type, event, point, item, downPoint);
				if (dragItem) {
					if (lastPoint && !lastPoint.equals(point))
						callEvent(this, 'mousedrag', event, point, dragItem,
								lastPoint);
					if (item !== dragItem) {
						overPoint = point;
						callEvent(this, 'mousemove', event, point, item,
								overPoint);
					}
				}
				if (!stopped && item && item === downItem) {
					clickTime = Date.now();
					callEvent(this, dblClick && downItem.responds('doubleclick')
							? 'doubleclick' : 'click', event, downPoint, item);
					dblClick = false;
				}
				downItem = dragItem = null;
				break;
			case 'mousemove':
				if (dragItem)
					stopped = callEvent(this, 'mousedrag', event, point,
							dragItem, lastPoint);
				if (!stopped) {
					if (item !== overItem)
						overPoint = point;
					stopped = callEvent(this, type, event, point, item,
							overPoint);
				}
				lastPoint = overPoint = point;
				if (item !== overItem) {
					callEvent(this, 'mouseleave', event, point, overItem);
					overItem = item;
					callEvent(this, 'mouseenter', event, point, item);
				}
				break;
			}
			return stopped;
		}
	};
});

var Event = Base.extend({
	_class: 'Event',

	initialize: function Event(event) {
		this.event = event;
	},

	isPrevented: false,
	isStopped: false,

	preventDefault: function() {
		this.isPrevented = true;
		this.event.preventDefault();
	},

	stopPropagation: function() {
		this.isStopped = true;
		this.event.stopPropagation();
	},

	stop: function() {
		this.stopPropagation();
		this.preventDefault();
	},

	getModifiers: function() {
		return Key.modifiers;
	}
});

var KeyEvent = Event.extend({
	_class: 'KeyEvent',

	initialize: function KeyEvent(down, key, character, event) {
		Event.call(this, event);
		this.type = down ? 'keydown' : 'keyup';
		this.key = key;
		this.character = character;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', key: '" + this.key
				+ "', character: '" + this.character
				+ "', modifiers: " + this.getModifiers()
				+ " }";
	}
});

var Key = new function() {

	var specialKeys = {
		8: 'backspace',
		9: 'tab',
		13: 'enter',
		16: 'shift',
		17: 'control',
		18: 'option',
		19: 'pause',
		20: 'caps-lock',
		27: 'escape',
		32: 'space',
		35: 'end',
		36: 'home',
		37: 'left',
		38: 'up',
		39: 'right',
		40: 'down',
		46: 'delete',
		91: 'command',
		93: 'command',
		224: 'command'
	},

	specialChars = {
		9: true,
		13: true,
		32: true
	},

	modifiers = new Base({
		shift: false,
		control: false,
		option: false,
		command: false,
		capsLock: false,
		space: false
	}),

	charCodeMap = {},
	keyMap = {},
	commandFixMap,
	downCode;

	function handleKey(down, keyCode, charCode, event) {
		var character = charCode ? String.fromCharCode(charCode) : '',
			specialKey = specialKeys[keyCode],
			key = specialKey || character.toLowerCase(),
			type = down ? 'keydown' : 'keyup',
			view = View._focused,
			scope = view && view.isVisible() && view._scope,
			tool = scope && scope.tool,
			name;
		keyMap[key] = down;
		if (down) {
			charCodeMap[keyCode] = charCode;
		} else {
			delete charCodeMap[keyCode];
		}
		if (specialKey && (name = Base.camelize(specialKey)) in modifiers) {
			modifiers[name] = down;
			var browser = paper.browser;
			if (name === 'command' && browser && browser.mac) {
				if (down) {
					commandFixMap = {};
				} else {
					for (var code in commandFixMap) {
						if (code in charCodeMap)
							handleKey(false, code, commandFixMap[code], event);
					}
					commandFixMap = null;
				}
			}
		} else if (down && commandFixMap) {
			commandFixMap[keyCode] = charCode;
		}
		if (tool && tool.responds(type)) {
			paper = scope;
			tool.emit(type, new KeyEvent(down, key, character, event));
			if (view)
				view.update();
		}
	}

	DomEvent.add(document, {
		keydown: function(event) {
			var code = event.which || event.keyCode;
			if (code in specialKeys || modifiers.command) {
				handleKey(true, code,
						code in specialChars || modifiers.command ? code : 0,
						event);
			} else {
				downCode = code;
			}
		},

		keypress: function(event) {
			if (downCode != null) {
				handleKey(true, downCode, event.which || event.keyCode, event);
				downCode = null;
			}
		},

		keyup: function(event) {
			var code = event.which || event.keyCode;
			if (code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	DomEvent.add(window, {
		blur: function(event) {
			for (var code in charCodeMap)
				handleKey(false, code, charCodeMap[code], event);
		}
	});

	return {
		modifiers: modifiers,

		isDown: function(key) {
			return !!keyMap[key];
		}
	};
};

var MouseEvent = Event.extend({
	_class: 'MouseEvent',

	initialize: function MouseEvent(type, event, point, target, delta) {
		Event.call(this, event);
		this.type = type;
		this.point = point;
		this.target = target;
		this.delta = delta;
	},

	toString: function() {
		return "{ type: '" + this.type
				+ "', point: " + this.point
				+ ', target: ' + this.target
				+ (this.delta ? ', delta: ' + this.delta : '')
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var ToolEvent = Event.extend({
	_class: 'ToolEvent',
	_item: null,

	initialize: function ToolEvent(tool, type, event) {
		this.tool = tool;
		this.type = type;
		this.event = event;
	},

	_choosePoint: function(point, toolPoint) {
		return point ? point : toolPoint ? toolPoint.clone() : null;
	},

	getPoint: function() {
		return this._choosePoint(this._point, this.tool._point);
	},

	setPoint: function(point) {
		this._point = point;
	},

	getLastPoint: function() {
		return this._choosePoint(this._lastPoint, this.tool._lastPoint);
	},

	setLastPoint: function(lastPoint) {
		this._lastPoint = lastPoint;
	},

	getDownPoint: function() {
		return this._choosePoint(this._downPoint, this.tool._downPoint);
	},

	setDownPoint: function(downPoint) {
		this._downPoint = downPoint;
	},

	getMiddlePoint: function() {
		if (!this._middlePoint && this.tool._lastPoint) {
			return this.tool._point.add(this.tool._lastPoint).divide(2);
		}
		return this._middlePoint;
	},

	setMiddlePoint: function(middlePoint) {
		this._middlePoint = middlePoint;
	},

	getDelta: function() {
		return !this._delta && this.tool._lastPoint
				? this.tool._point.subtract(this.tool._lastPoint)
				: this._delta;
	},

	setDelta: function(delta) {
		this._delta = delta;
	},

	getCount: function() {
		return /^mouse(down|up)$/.test(this.type)
				? this.tool._downCount
				: this.tool._count;
	},

	setCount: function(count) {
		this.tool[/^mouse(down|up)$/.test(this.type) ? 'downCount' : 'count']
			= count;
	},

	getItem: function() {
		if (!this._item) {
			var result = this.tool._scope.project.hitTest(this.getPoint());
			if (result) {
				var item = result.item,
					parent = item._parent;
				while (/^(Group|CompoundPath)$/.test(parent._class)) {
					item = parent;
					parent = parent._parent;
				}
				this._item = item;
			}
		}
		return this._item;
	},

	setItem: function(item) {
		this._item = item;
	},

	toString: function() {
		return '{ type: ' + this.type
				+ ', point: ' + this.getPoint()
				+ ', count: ' + this.getCount()
				+ ', modifiers: ' + this.getModifiers()
				+ ' }';
	}
});

var Tool = PaperScopeItem.extend({
	_class: 'Tool',
	_list: 'tools',
	_reference: 'tool',
	_events: [ 'onActivate', 'onDeactivate', 'onEditOptions',
			'onMouseDown', 'onMouseUp', 'onMouseDrag', 'onMouseMove',
			'onKeyDown', 'onKeyUp' ],

	initialize: function Tool(props) {
		PaperScopeItem.call(this);
		this._firstMove = true;
		this._count = 0;
		this._downCount = 0;
		this._set(props);
	},

	getMinDistance: function() {
		return this._minDistance;
	},

	setMinDistance: function(minDistance) {
		this._minDistance = minDistance;
		if (minDistance != null && this._maxDistance != null
				&& minDistance > this._maxDistance) {
			this._maxDistance = minDistance;
		}
	},

	getMaxDistance: function() {
		return this._maxDistance;
	},

	setMaxDistance: function(maxDistance) {
		this._maxDistance = maxDistance;
		if (this._minDistance != null && maxDistance != null
				&& maxDistance < this._minDistance) {
			this._minDistance = maxDistance;
		}
	},

	getFixedDistance: function() {
		return this._minDistance == this._maxDistance
			? this._minDistance : null;
	},

	setFixedDistance: function(distance) {
		this._minDistance = this._maxDistance = distance;
	},

	_updateEvent: function(type, point, minDistance, maxDistance, start,
			needsChange, matchMaxDistance) {
		if (!start) {
			if (minDistance != null || maxDistance != null) {
				var minDist = minDistance != null ? minDistance : 0,
					vector = point.subtract(this._point),
					distance = vector.getLength();
				if (distance < minDist)
					return false;
				if (maxDistance != null && maxDistance != 0) {
					if (distance > maxDistance) {
						point = this._point.add(vector.normalize(maxDistance));
					} else if (matchMaxDistance) {
						return false;
					}
				}
			}
			if (needsChange && point.equals(this._point))
				return false;
		}
		this._lastPoint = start && type == 'mousemove' ? point : this._point;
		this._point = point;
		switch (type) {
		case 'mousedown':
			this._lastPoint = this._downPoint;
			this._downPoint = this._point;
			this._downCount++;
			break;
		case 'mouseup':
			this._lastPoint = this._downPoint;
			break;
		}
		this._count = start ? 0 : this._count + 1;
		return true;
	},

	_fireEvent: function(type, event) {
		var sets = paper.project._removeSets;
		if (sets) {
			if (type === 'mouseup')
				sets.mousedrag = null;
			var set = sets[type];
			if (set) {
				for (var id in set) {
					var item = set[id];
					for (var key in sets) {
						var other = sets[key];
						if (other && other != set)
							delete other[item._id];
					}
					item.remove();
				}
				sets[type] = null;
			}
		}
		return this.responds(type)
				&& this.emit(type, new ToolEvent(this, type, event));
	},

	_handleEvent: function(type, point, event) {
		paper = this._scope;
		var called = false;
		switch (type) {
		case 'mousedown':
			this._updateEvent(type, point, null, null, true, false, false);
			called = this._fireEvent(type, event);
			break;
		case 'mousedrag':
			var needsChange = false,
				matchMaxDistance = false;
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, false, needsChange, matchMaxDistance)) {
				called = this._fireEvent(type, event) || called;
				needsChange = true;
				matchMaxDistance = true;
			}
			break;
		case 'mouseup':
			if (!point.equals(this._point)
					&& this._updateEvent('mousedrag', point, this.minDistance,
							this.maxDistance, false, false, false)) {
				called = this._fireEvent('mousedrag', event);
			}
			this._updateEvent(type, point, null, this.maxDistance, false,
					false, false);
			called = this._fireEvent(type, event) || called;
			this._updateEvent(type, point, null, null, true, false, false);
			this._firstMove = true;
			break;
		case 'mousemove':
			while (this._updateEvent(type, point, this.minDistance,
					this.maxDistance, this._firstMove, true, false)) {
				called = this._fireEvent(type, event) || called;
				this._firstMove = false;
			}
			break;
		}
		if (called)
			event.preventDefault();
		return called;
	}

});

var Http = {
	request: function(method, url, callback, async) {
		async = (async === undefined) ? true : async;
		var xhr = new (window.ActiveXObject || XMLHttpRequest)(
					'Microsoft.XMLHTTP');
		xhr.open(method.toUpperCase(), url, async);
		if ('overrideMimeType' in xhr)
			xhr.overrideMimeType('text/plain');
		xhr.onreadystatechange = function() {
			if (xhr.readyState === 4) {
				var status = xhr.status;
				if (status === 0 || status === 200) {
					callback.call(xhr, xhr.responseText);
				} else {
					throw new Error('Could not load ' + url + ' (Error '
							+ status + ')');
				}
			}
		};
		return xhr.send(null);
	}
};

var CanvasProvider = {
	canvases: [],

	getCanvas: function(width, height) {
		var canvas,
			clear = true;
		if (typeof width === 'object') {
			height = width.height;
			width = width.width;
		}
		if (this.canvases.length) {
			canvas = this.canvases.pop();
		} else {
			canvas = document.createElement('canvas');
		}
		var ctx = canvas.getContext('2d');
		if (canvas.width === width && canvas.height === height) {
			if (clear)
				ctx.clearRect(0, 0, width + 1, height + 1);
		} else {
			canvas.width = width;
			canvas.height = height;
		}
		ctx.save();
		return canvas;
	},

	getContext: function(width, height) {
		return this.getCanvas(width, height).getContext('2d');
	},

	release: function(obj) {
		var canvas = obj.canvas ? obj.canvas : obj;
		canvas.getContext('2d').restore();
		this.canvases.push(canvas);
	}
};

var BlendMode = new function() {
	var min = Math.min,
		max = Math.max,
		abs = Math.abs,
		sr, sg, sb, sa,
		br, bg, bb, ba,
		dr, dg, db;

	function getLum(r, g, b) {
		return 0.2989 * r + 0.587 * g + 0.114 * b;
	}

	function setLum(r, g, b, l) {
		var d = l - getLum(r, g, b);
		dr = r + d;
		dg = g + d;
		db = b + d;
		var l = getLum(dr, dg, db),
			mn = min(dr, dg, db),
			mx = max(dr, dg, db);
		if (mn < 0) {
			var lmn = l - mn;
			dr = l + (dr - l) * l / lmn;
			dg = l + (dg - l) * l / lmn;
			db = l + (db - l) * l / lmn;
		}
		if (mx > 255) {
			var ln = 255 - l,
				mxl = mx - l;
			dr = l + (dr - l) * ln / mxl;
			dg = l + (dg - l) * ln / mxl;
			db = l + (db - l) * ln / mxl;
		}
	}

	function getSat(r, g, b) {
		return max(r, g, b) - min(r, g, b);
	}

	function setSat(r, g, b, s) {
		var col = [r, g, b],
			mx = max(r, g, b),
			mn = min(r, g, b),
			md;
		mn = mn === r ? 0 : mn === g ? 1 : 2;
		mx = mx === r ? 0 : mx === g ? 1 : 2;
		md = min(mn, mx) === 0 ? max(mn, mx) === 1 ? 2 : 1 : 0;
		if (col[mx] > col[mn]) {
			col[md] = (col[md] - col[mn]) * s / (col[mx] - col[mn]);
			col[mx] = s;
		} else {
			col[md] = col[mx] = 0;
		}
		col[mn] = 0;
		dr = col[0];
		dg = col[1];
		db = col[2];
	}

	var modes = {
		multiply: function() {
			dr = br * sr / 255;
			dg = bg * sg / 255;
			db = bb * sb / 255;
		},

		screen: function() {
			dr = br + sr - (br * sr / 255);
			dg = bg + sg - (bg * sg / 255);
			db = bb + sb - (bb * sb / 255);
		},

		overlay: function() {
			dr = br < 128 ? 2 * br * sr / 255 : 255 - 2 * (255 - br) * (255 - sr) / 255;
			dg = bg < 128 ? 2 * bg * sg / 255 : 255 - 2 * (255 - bg) * (255 - sg) / 255;
			db = bb < 128 ? 2 * bb * sb / 255 : 255 - 2 * (255 - bb) * (255 - sb) / 255;
		},

		'soft-light': function() {
			var t = sr * br / 255;
			dr = t + br * (255 - (255 - br) * (255 - sr) / 255 - t) / 255;
			t = sg * bg / 255;
			dg = t + bg * (255 - (255 - bg) * (255 - sg) / 255 - t) / 255;
			t = sb * bb / 255;
			db = t + bb * (255 - (255 - bb) * (255 - sb) / 255 - t) / 255;
		},

		'hard-light': function() {
			dr = sr < 128 ? 2 * sr * br / 255 : 255 - 2 * (255 - sr) * (255 - br) / 255;
			dg = sg < 128 ? 2 * sg * bg / 255 : 255 - 2 * (255 - sg) * (255 - bg) / 255;
			db = sb < 128 ? 2 * sb * bb / 255 : 255 - 2 * (255 - sb) * (255 - bb) / 255;
		},

		'color-dodge': function() {
			dr = br === 0 ? 0 : sr === 255 ? 255 : min(255, 255 * br / (255 - sr));
			dg = bg === 0 ? 0 : sg === 255 ? 255 : min(255, 255 * bg / (255 - sg));
			db = bb === 0 ? 0 : sb === 255 ? 255 : min(255, 255 * bb / (255 - sb));
		},

		'color-burn': function() {
			dr = br === 255 ? 255 : sr === 0 ? 0 : max(0, 255 - (255 - br) * 255 / sr);
			dg = bg === 255 ? 255 : sg === 0 ? 0 : max(0, 255 - (255 - bg) * 255 / sg);
			db = bb === 255 ? 255 : sb === 0 ? 0 : max(0, 255 - (255 - bb) * 255 / sb);
		},

		darken: function() {
			dr = br < sr ? br : sr;
			dg = bg < sg ? bg : sg;
			db = bb < sb ? bb : sb;
		},

		lighten: function() {
			dr = br > sr ? br : sr;
			dg = bg > sg ? bg : sg;
			db = bb > sb ? bb : sb;
		},

		difference: function() {
			dr = br - sr;
			if (dr < 0)
				dr = -dr;
			dg = bg - sg;
			if (dg < 0)
				dg = -dg;
			db = bb - sb;
			if (db < 0)
				db = -db;
		},

		exclusion: function() {
			dr = br + sr * (255 - br - br) / 255;
			dg = bg + sg * (255 - bg - bg) / 255;
			db = bb + sb * (255 - bb - bb) / 255;
		},

		hue: function() {
			setSat(sr, sg, sb, getSat(br, bg, bb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		saturation: function() {
			setSat(br, bg, bb, getSat(sr, sg, sb));
			setLum(dr, dg, db, getLum(br, bg, bb));
		},

		luminosity: function() {
			setLum(br, bg, bb, getLum(sr, sg, sb));
		},

		color: function() {
			setLum(sr, sg, sb, getLum(br, bg, bb));
		},

		add: function() {
			dr = min(br + sr, 255);
			dg = min(bg + sg, 255);
			db = min(bb + sb, 255);
		},

		subtract: function() {
			dr = max(br - sr, 0);
			dg = max(bg - sg, 0);
			db = max(bb - sb, 0);
		},

		average: function() {
			dr = (br + sr) / 2;
			dg = (bg + sg) / 2;
			db = (bb + sb) / 2;
		},

		negation: function() {
			dr = 255 - abs(255 - sr - br);
			dg = 255 - abs(255 - sg - bg);
			db = 255 - abs(255 - sb - bb);
		}
	};

	var nativeModes = this.nativeModes = Base.each([
		'source-over', 'source-in', 'source-out', 'source-atop',
		'destination-over', 'destination-in', 'destination-out',
		'destination-atop', 'lighter', 'darker', 'copy', 'xor'
	], function(mode) {
		this[mode] = true;
	}, {});

	var ctx = CanvasProvider.getContext(1, 1);
	Base.each(modes, function(func, mode) {
		var darken = mode === 'darken',
			ok = false;
		ctx.save();
		try {
			ctx.fillStyle = darken ? '#300' : '#a00';
			ctx.fillRect(0, 0, 1, 1);
			ctx.globalCompositeOperation = mode;
			if (ctx.globalCompositeOperation === mode) {
				ctx.fillStyle = darken ? '#a00' : '#300';
				ctx.fillRect(0, 0, 1, 1);
				ok = ctx.getImageData(0, 0, 1, 1).data[0] !== darken ? 170 : 51;
			}
		} catch (e) {}
		ctx.restore();
		nativeModes[mode] = ok;
	});
	CanvasProvider.release(ctx);

	this.process = function(mode, srcContext, dstContext, alpha, offset) {
		var srcCanvas = srcContext.canvas,
			normal = mode === 'normal';
		if (normal || nativeModes[mode]) {
			dstContext.save();
			dstContext.setTransform(1, 0, 0, 1, 0, 0);
			dstContext.globalAlpha = alpha;
			if (!normal)
				dstContext.globalCompositeOperation = mode;
			dstContext.drawImage(srcCanvas, offset.x, offset.y);
			dstContext.restore();
		} else {
			var process = modes[mode];
			if (!process)
				return;
			var dstData = dstContext.getImageData(offset.x, offset.y,
					srcCanvas.width, srcCanvas.height),
				dst = dstData.data,
				src = srcContext.getImageData(0, 0,
					srcCanvas.width, srcCanvas.height).data;
			for (var i = 0, l = dst.length; i < l; i += 4) {
				sr = src[i];
				br = dst[i];
				sg = src[i + 1];
				bg = dst[i + 1];
				sb = src[i + 2];
				bb = dst[i + 2];
				sa = src[i + 3];
				ba = dst[i + 3];
				process();
				var a1 = sa * alpha / 255,
					a2 = 1 - a1;
				dst[i] = a1 * dr + a2 * br;
				dst[i + 1] = a1 * dg + a2 * bg;
				dst[i + 2] = a1 * db + a2 * bb;
				dst[i + 3] = sa * alpha + a2 * ba;
			}
			dstContext.putImageData(dstData, offset.x, offset.y);
		}
	};
};

var SVGStyles = Base.each({
	fillColor: ['fill', 'color'],
	strokeColor: ['stroke', 'color'],
	strokeWidth: ['stroke-width', 'number'],
	strokeCap: ['stroke-linecap', 'string'],
	strokeJoin: ['stroke-linejoin', 'string'],
	strokeScaling: ['vector-effect', 'lookup', {
		true: 'none',
		false: 'non-scaling-stroke'
	}, function(item, value) {
		return !value
				&& (item instanceof PathItem
					|| item instanceof Shape
					|| item instanceof TextItem);
	}],
	miterLimit: ['stroke-miterlimit', 'number'],
	dashArray: ['stroke-dasharray', 'array'],
	dashOffset: ['stroke-dashoffset', 'number'],
	fontFamily: ['font-family', 'string'],
	fontWeight: ['font-weight', 'string'],
	fontSize: ['font-size', 'number'],
	justification: ['text-anchor', 'lookup', {
		left: 'start',
		center: 'middle',
		right: 'end'
	}],
	opacity: ['opacity', 'number'],
	blendMode: ['mix-blend-mode', 'string']
}, function(entry, key) {
	var part = Base.capitalize(key),
		lookup = entry[2];
	this[key] = {
		type: entry[1],
		property: key,
		attribute: entry[0],
		toSVG: lookup,
		fromSVG: lookup && Base.each(lookup, function(value, name) {
			this[value] = name;
		}, {}),
		exportFilter: entry[3],
		get: 'get' + part,
		set: 'set' + part
	};
}, {});

var SVGNamespaces = {
	href: 'http://www.w3.org/1999/xlink',
	xlink: 'http://www.w3.org/2000/xmlns'
};

new function() {
	var formatter;

	function setAttributes(node, attrs) {
		for (var key in attrs) {
			var val = attrs[key],
				namespace = SVGNamespaces[key];
			if (typeof val === 'number')
				val = formatter.number(val);
			if (namespace) {
				node.setAttributeNS(namespace, key, val);
			} else {
				node.setAttribute(key, val);
			}
		}
		return node;
	}

	function createElement(tag, attrs) {
		return setAttributes(
			document.createElementNS('http://www.w3.org/2000/svg', tag), attrs);
	}

	function getTransform(matrix, coordinates, center) {
		var attrs = new Base(),
			trans = matrix.getTranslation();
		if (coordinates) {
			matrix = matrix.shiftless();
			var point = matrix._inverseTransform(trans);
			attrs[center ? 'cx' : 'x'] = point.x;
			attrs[center ? 'cy' : 'y'] = point.y;
			trans = null;
		}
		if (!matrix.isIdentity()) {
			var decomposed = matrix.decompose();
			if (decomposed && !decomposed.shearing) {
				var parts = [],
					angle = decomposed.rotation,
					scale = decomposed.scaling;
				if (trans && !trans.isZero())
					parts.push('translate(' + formatter.point(trans) + ')');
				if (!Numerical.isZero(scale.x - 1)
						|| !Numerical.isZero(scale.y - 1))
					parts.push('scale(' + formatter.point(scale) +')');
				if (angle)
					parts.push('rotate(' + formatter.number(angle) + ')');
				attrs.transform = parts.join(' ');
			} else {
				attrs.transform = 'matrix(' + matrix.getValues().join(',') + ')';
			}
		}
		return attrs;
	}

	function exportGroup(item, options) {
		var attrs = getTransform(item._matrix),
			children = item._children;
		var node = createElement('g', attrs);
		for (var i = 0, l = children.length; i < l; i++) {
			var child = children[i];
			var childNode = exportSVG(child, options);
			if (childNode) {
				if (child.isClipMask()) {
					var clip = createElement('clipPath');
					clip.appendChild(childNode);
					setDefinition(child, clip, 'clip');
					setAttributes(node, {
						'clip-path': 'url(#' + clip.id + ')'
					});
				} else {
					node.appendChild(childNode);
				}
			}
		}
		return node;
	}

	function exportRaster(item, options) {
		var attrs = getTransform(item._matrix, true),
			size = item.getSize(),
			image = item.getImage();
		attrs.x -= size.width / 2;
		attrs.y -= size.height / 2;
		attrs.width = size.width;
		attrs.height = size.height;
		attrs.href = options.embedImages === false && image && image.src
				|| item.toDataURL();
		return createElement('image', attrs);
	}

	function exportPath(item, options) {
		var matchShapes = options.matchShapes;
		if (matchShapes) {
			var shape = item.toShape(false);
			if (shape)
				return exportShape(shape, options);
		}
		var segments = item._segments,
			type,
			attrs = getTransform(item._matrix);
		if (segments.length === 0)
			return null;
		if (matchShapes && !item.hasHandles()) {
			if (segments.length >= 3) {
				type = item._closed ? 'polygon' : 'polyline';
				var parts = [];
				for(var i = 0, l = segments.length; i < l; i++)
					parts.push(formatter.point(segments[i]._point));
				attrs.points = parts.join(' ');
			} else {
				type = 'line';
				var first = segments[0]._point,
					last = segments[segments.length - 1]._point;
				attrs.set({
					x1: first.x,
					y1: first.y,
					x2: last.x,
					y2: last.y
				});
			}
		} else {
			type = 'path';
			attrs.d = item.getPathData(null, options.precision);
		}
		return createElement(type, attrs);
	}

	function exportShape(item) {
		var type = item._type,
			radius = item._radius,
			attrs = getTransform(item._matrix, true, type !== 'rectangle');
		if (type === 'rectangle') {
			type = 'rect';
			var size = item._size,
				width = size.width,
				height = size.height;
			attrs.x -= width / 2;
			attrs.y -= height / 2;
			attrs.width = width;
			attrs.height = height;
			if (radius.isZero())
				radius = null;
		}
		if (radius) {
			if (type === 'circle') {
				attrs.r = radius;
			} else {
				attrs.rx = radius.width;
				attrs.ry = radius.height;
			}
		}
		return createElement(type, attrs);
	}

	function exportCompoundPath(item, options) {
		var attrs = getTransform(item._matrix);
		var data = item.getPathData(null, options.precision);
		if (data)
			attrs.d = data;
		return createElement('path', attrs);
	}

	function exportPlacedSymbol(item, options) {
		var attrs = getTransform(item._matrix, true),
			symbol = item.getSymbol(),
			symbolNode = getDefinition(symbol, 'symbol'),
			definition = symbol.getDefinition(),
			bounds = definition.getBounds();
		if (!symbolNode) {
			symbolNode = createElement('symbol', {
				viewBox: formatter.rectangle(bounds)
			});
			symbolNode.appendChild(exportSVG(definition, options));
			setDefinition(symbol, symbolNode, 'symbol');
		}
		attrs.href = '#' + symbolNode.id;
		attrs.x += bounds.x;
		attrs.y += bounds.y;
		attrs.width = formatter.number(bounds.width);
		attrs.height = formatter.number(bounds.height);
		attrs.overflow = 'visible';
		return createElement('use', attrs);
	}

	function exportGradient(color) {
		var gradientNode = getDefinition(color, 'color');
		if (!gradientNode) {
			var gradient = color.getGradient(),
				radial = gradient._radial,
				origin = color.getOrigin().transform(),
				destination = color.getDestination().transform(),
				attrs;
			if (radial) {
				attrs = {
					cx: origin.x,
					cy: origin.y,
					r: origin.getDistance(destination)
				};
				var highlight = color.getHighlight();
				if (highlight) {
					highlight = highlight.transform();
					attrs.fx = highlight.x;
					attrs.fy = highlight.y;
				}
			} else {
				attrs = {
					x1: origin.x,
					y1: origin.y,
					x2: destination.x,
					y2: destination.y
				};
			}
			attrs.gradientUnits = 'userSpaceOnUse';
			gradientNode = createElement(
					(radial ? 'radial' : 'linear') + 'Gradient', attrs);
			var stops = gradient._stops;
			for (var i = 0, l = stops.length; i < l; i++) {
				var stop = stops[i],
					stopColor = stop._color,
					alpha = stopColor.getAlpha();
				attrs = {
					offset: stop._rampPoint,
					'stop-color': stopColor.toCSS(true)
				};
				if (alpha < 1)
					attrs['stop-opacity'] = alpha;
				gradientNode.appendChild(createElement('stop', attrs));
			}
			setDefinition(color, gradientNode, 'color');
		}
		return 'url(#' + gradientNode.id + ')';
	}

	function exportText(item) {
		var node = createElement('text', getTransform(item._matrix, true));
		node.textContent = item._content;
		return node;
	}

	var exporters = {
		Group: exportGroup,
		Layer: exportGroup,
		Raster: exportRaster,
		Path: exportPath,
		Shape: exportShape,
		CompoundPath: exportCompoundPath,
		PlacedSymbol: exportPlacedSymbol,
		PointText: exportText
	};

	function applyStyle(item, node, isRoot) {
		var attrs = {},
			parent = !isRoot && item.getParent();

		if (item._name != null)
			attrs.id = item._name;

		Base.each(SVGStyles, function(entry) {
			var get = entry.get,
				type = entry.type,
				value = item[get]();
			if (entry.exportFilter
					? entry.exportFilter(item, value)
					: !parent || !Base.equals(parent[get](), value)) {
				if (type === 'color' && value != null) {
					var alpha = value.getAlpha();
					if (alpha < 1)
						attrs[entry.attribute + '-opacity'] = alpha;
				}
				attrs[entry.attribute] = value == null
					? 'none'
					: type === 'number'
						? formatter.number(value)
						: type === 'color'
							? value.gradient
								? exportGradient(value, item)
								: value.toCSS(true)
							: type === 'array'
								? value.join(',')
								: type === 'lookup'
									? entry.toSVG[value]
									: value;
			}
		});

		if (attrs.opacity === 1)
			delete attrs.opacity;

		if (!item._visible)
			attrs.visibility = 'hidden';

		return setAttributes(node, attrs);
	}

	var definitions;
	function getDefinition(item, type) {
		if (!definitions)
			definitions = { ids: {}, svgs: {} };
		return item && definitions.svgs[type + '-' + item._id];
	}

	function setDefinition(item, node, type) {
		if (!definitions)
			getDefinition();
		var id = definitions.ids[type] = (definitions.ids[type] || 0) + 1;
		node.id = type + '-' + id;
		definitions.svgs[type + '-' + item._id] = node;
	}

	function exportDefinitions(node, options) {
		var svg = node,
			defs = null;
		if (definitions) {
			svg = node.nodeName.toLowerCase() === 'svg' && node;
			for (var i in definitions.svgs) {
				if (!defs) {
					if (!svg) {
						svg = createElement('svg');
						svg.appendChild(node);
					}
					defs = svg.insertBefore(createElement('defs'),
							svg.firstChild);
				}
				defs.appendChild(definitions.svgs[i]);
			}
			definitions = null;
		}
		return options.asString
				? new XMLSerializer().serializeToString(svg)
				: svg;
	}

	function exportSVG(item, options, isRoot) {
		var exporter = exporters[item._class],
			node = exporter && exporter(item, options);
		if (node) {
			var onExport = options.onExport;
			if (onExport)
				node = onExport(item, node, options) || node;
			var data = JSON.stringify(item._data);
			if (data && data !== '{}' && data !== 'null')
				node.setAttribute('data-paper-data', data);
		}
		return node && applyStyle(item, node, isRoot);
	}

	function setOptions(options) {
		if (!options)
			options = {};
		formatter = new Formatter(options.precision);
		return options;
	}

	Item.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			return exportDefinitions(exportSVG(this, options, true), options);
		}
	});

	Project.inject({
		exportSVG: function(options) {
			options = setOptions(options);
			var layers = this.layers,
				view = this.getView(),
				size = view.getViewSize(),
				node = createElement('svg', {
					x: 0,
					y: 0,
					width: size.width,
					height: size.height,
					version: '1.1',
					xmlns: 'http://www.w3.org/2000/svg',
					'xmlns:xlink': 'http://www.w3.org/1999/xlink'
				}),
				parent = node,
				matrix = view._matrix;
			if (!matrix.isIdentity())
				parent = node.appendChild(
						createElement('g', getTransform(matrix)));
			for (var i = 0, l = layers.length; i < l; i++)
				parent.appendChild(exportSVG(layers[i], options, true));
			return exportDefinitions(node, options);
		}
	});
};

new function() {

	function getValue(node, name, isString, allowNull) {
		var namespace = SVGNamespaces[name],
			value = namespace
				? node.getAttributeNS(namespace, name)
				: node.getAttribute(name);
		if (value === 'null')
			value = null;
		return value == null
				? allowNull
					? null
					: isString
						? ''
						: 0
				: isString
					? value
					: parseFloat(value);
	}

	function getPoint(node, x, y, allowNull) {
		x = getValue(node, x, false, allowNull);
		y = getValue(node, y, false, allowNull);
		return allowNull && (x == null || y == null) ? null
				: new Point(x, y);
	}

	function getSize(node, w, h, allowNull) {
		w = getValue(node, w, false, allowNull);
		h = getValue(node, h, false, allowNull);
		return allowNull && (w == null || h == null) ? null
				: new Size(w, h);
	}

	function convertValue(value, type, lookup) {
		return value === 'none'
				? null
				: type === 'number'
					? parseFloat(value)
					: type === 'array'
						? value ? value.split(/[\s,]+/g).map(parseFloat) : []
						: type === 'color'
							? getDefinition(value) || value
							: type === 'lookup'
								? lookup[value]
								: value;
	}

	function importGroup(node, type, options, isRoot) {
		var nodes = node.childNodes,
			isClip = type === 'clippath',
			item = new Group(),
			project = item._project,
			currentStyle = project._currentStyle,
			children = [];
		if (!isClip) {
			item = applyAttributes(item, node, isRoot);
			project._currentStyle = item._style.clone();
		}
		if (isRoot) {
			var defs = node.querySelectorAll('defs');
			for (var i = 0, l = defs.length; i < l; i++) {
				importSVG(defs[i], options, false);
			}
		}
		for (var i = 0, l = nodes.length; i < l; i++) {
			var childNode = nodes[i],
				child;
			if (childNode.nodeType === 1
					&& childNode.nodeName.toLowerCase() !== 'defs'
					&& (child = importSVG(childNode, options, false))
					&& !(child instanceof Symbol))
				children.push(child);
		}
		item.addChildren(children);
		if (isClip)
			item = applyAttributes(item.reduce(), node, isRoot);
		project._currentStyle = currentStyle;
		if (isClip || type === 'defs') {
			item.remove();
			item = null;
		}
		return item;
	}

	function importPoly(node, type) {
		var coords = node.getAttribute('points').match(
					/[+-]?(?:\d*\.\d+|\d+\.?)(?:[eE][+-]?\d+)?/g),
			points = [];
		for (var i = 0, l = coords.length; i < l; i += 2)
			points.push(new Point(
					parseFloat(coords[i]),
					parseFloat(coords[i + 1])));
		var path = new Path(points);
		if (type === 'polygon')
			path.closePath();
		return path;
	}

	function importPath(node) {
		var data = node.getAttribute('d'),
			param = { pathData: data };
		return (data.match(/m/gi) || []).length > 1 || /z\S+/i.test(data)
				? new CompoundPath(param)
				: new Path(param);
	}

	function importGradient(node, type) {
		var id = (getValue(node, 'href', true) || '').substring(1),
			isRadial = type === 'radialgradient',
			gradient;
		if (id) {
			gradient = definitions[id].getGradient();
		} else {
			var nodes = node.childNodes,
				stops = [];
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1)
					stops.push(applyAttributes(new GradientStop(), child));
			}
			gradient = new Gradient(stops, isRadial);
		}
		var origin, destination, highlight;
		if (isRadial) {
			origin = getPoint(node, 'cx', 'cy');
			destination = origin.add(getValue(node, 'r'), 0);
			highlight = getPoint(node, 'fx', 'fy', true);
		} else {
			origin = getPoint(node, 'x1', 'y1');
			destination = getPoint(node, 'x2', 'y2');
		}
		applyAttributes(
			new Color(gradient, origin, destination, highlight), node);
		return null;
	}

	var importers = {
		'#document': function (node, type, options, isRoot) {
			var nodes = node.childNodes;
			for (var i = 0, l = nodes.length; i < l; i++) {
				var child = nodes[i];
				if (child.nodeType === 1) {
					var next = child.nextSibling;
					document.body.appendChild(child);
					var item = importSVG(child, options, isRoot);
					if (next) {
						node.insertBefore(child, next);
					} else {
						node.appendChild(child);
					}
					return item;
				}
			}
		},
		g: importGroup,
		svg: importGroup,
		clippath: importGroup,
		polygon: importPoly,
		polyline: importPoly,
		path: importPath,
		lineargradient: importGradient,
		radialgradient: importGradient,

		image: function (node) {
			var raster = new Raster(getValue(node, 'href', true));
			raster.on('load', function() {
				var size = getSize(node, 'width', 'height');
				this.setSize(size);
				var center = this._matrix._transformPoint(
						getPoint(node, 'x', 'y').add(size.divide(2)));
				this.translate(center);
			});
			return raster;
		},

		symbol: function(node, type, options, isRoot) {
			return new Symbol(importGroup(node, type, options, isRoot), true);
		},

		defs: importGroup,

		use: function(node) {
			var id = (getValue(node, 'href', true) || '').substring(1),
				definition = definitions[id],
				point = getPoint(node, 'x', 'y');
			return definition
					? definition instanceof Symbol
						? definition.place(point)
						: definition.clone().translate(point)
					: null;
		},

		circle: function(node) {
			return new Shape.Circle(getPoint(node, 'cx', 'cy'),
					getValue(node, 'r'));
		},

		ellipse: function(node) {
			return new Shape.Ellipse({
				center: getPoint(node, 'cx', 'cy'),
				radius: getSize(node, 'rx', 'ry')
			});
		},

		rect: function(node) {
			var point = getPoint(node, 'x', 'y'),
				size = getSize(node, 'width', 'height'),
				radius = getSize(node, 'rx', 'ry');
			return new Shape.Rectangle(new Rectangle(point, size), radius);
		},

		line: function(node) {
			return new Path.Line(getPoint(node, 'x1', 'y1'),
					getPoint(node, 'x2', 'y2'));
		},

		text: function(node) {
			var text = new PointText(getPoint(node, 'x', 'y')
					.add(getPoint(node, 'dx', 'dy')));
			text.setContent(node.textContent.trim() || '');
			return text;
		}
	};

	function applyTransform(item, value, name, node) {
		var transforms = (node.getAttribute(name) || '').split(/\)\s*/g),
			matrix = new Matrix();
		for (var i = 0, l = transforms.length; i < l; i++) {
			var transform = transforms[i];
			if (!transform)
				break;
			var parts = transform.split(/\(\s*/),
				command = parts[0],
				v = parts[1].split(/[\s,]+/g);
			for (var j = 0, m = v.length; j < m; j++)
				v[j] = parseFloat(v[j]);
			switch (command) {
			case 'matrix':
				matrix.concatenate(
						new Matrix(v[0], v[1], v[2], v[3], v[4], v[5]));
				break;
			case 'rotate':
				matrix.rotate(v[0], v[1], v[2]);
				break;
			case 'translate':
				matrix.translate(v[0], v[1]);
				break;
			case 'scale':
				matrix.scale(v);
				break;
			case 'skewX':
				matrix.skew(v[0], 0);
				break;
			case 'skewY':
				matrix.skew(0, v[0]);
				break;
			}
		}
		item.transform(matrix);
	}

	function applyOpacity(item, value, name) {
		var color = item[name === 'fill-opacity' ? 'getFillColor'
				: 'getStrokeColor']();
		if (color)
			color.setAlpha(parseFloat(value));
	}

	var attributes = Base.set(Base.each(SVGStyles, function(entry) {
		this[entry.attribute] = function(item, value) {
			item[entry.set](convertValue(value, entry.type, entry.fromSVG));
			if (entry.type === 'color' && item instanceof Shape) {
				var color = item[entry.get]();
				if (color)
					color.transform(new Matrix().translate(
							item.getPosition(true).negate()));
			}
		};
	}, {}), {
		id: function(item, value) {
			definitions[value] = item;
			if (item.setName)
				item.setName(value);
		},

		'clip-path': function(item, value) {
			var clip = getDefinition(value);
			if (clip) {
				clip = clip.clone();
				clip.setClipMask(true);
				if (item instanceof Group) {
					item.insertChild(0, clip);
				} else {
					return new Group(clip, item);
				}
			}
		},

		gradientTransform: applyTransform,
		transform: applyTransform,

		'fill-opacity': applyOpacity,
		'stroke-opacity': applyOpacity,

		visibility: function(item, value) {
			item.setVisible(value === 'visible');
		},

		display: function(item, value) {
			item.setVisible(value !== null);
		},

		'stop-color': function(item, value) {
			if (item.setColor)
				item.setColor(value);
		},

		'stop-opacity': function(item, value) {
			if (item._color)
				item._color.setAlpha(parseFloat(value));
		},

		offset: function(item, value) {
			var percentage = value.match(/(.*)%$/);
			item.setRampPoint(percentage
					? percentage[1] / 100
					: parseFloat(value));
		},

		viewBox: function(item, value, name, node, styles) {
			var rect = new Rectangle(convertValue(value, 'array')),
				size = getSize(node, 'width', 'height', true);
			if (item instanceof Group) {
				var scale = size ? rect.getSize().divide(size) : 1,
					matrix = new Matrix().translate(rect.getPoint()).scale(scale);
				item.transform(matrix.inverted());
			} else if (item instanceof Symbol) {
				if (size)
					rect.setSize(size);
				var clip = getAttribute(node, 'overflow', styles) != 'visible',
					group = item._definition;
				if (clip && !rect.contains(group.getBounds())) {
					clip = new Shape.Rectangle(rect).transform(group._matrix);
					clip.setClipMask(true);
					group.addChild(clip);
				}
			}
		}
	});

	function getAttribute(node, name, styles) {
		var attr = node.attributes[name],
			value = attr && attr.value;
		if (!value) {
			var style = Base.camelize(name);
			value = node.style[style];
			if (!value && styles.node[style] !== styles.parent[style])
				value = styles.node[style];
		}
		return !value
				? undefined
				: value === 'none'
					? null
					: value;
	}

	function applyAttributes(item, node, isRoot) {
		var styles = {
			node: DomElement.getStyles(node) || {},
			parent: !isRoot && DomElement.getStyles(node.parentNode) || {}
		};
		Base.each(attributes, function(apply, name) {
			var value = getAttribute(node, name, styles);
			if (value !== undefined)
				item = Base.pick(apply(item, value, name, node, styles), item);
		});
		return item;
	}

	var definitions = {};
	function getDefinition(value) {
		var match = value && value.match(/\((?:#|)([^)']+)/);
		return match && definitions[match[1]];
	}

	function importSVG(source, options, isRoot) {
		if (!source)
			return null;
		if (!options) {
			options = {};
		} else if (typeof options === 'function') {
			options = { onLoad: options };
		}

		var node = source,
			scope = paper;

		function onLoadCallback(svg) {
			paper = scope;
			var item = importSVG(svg, options, isRoot),
				onLoad = options.onLoad,
				view = scope.project && scope.getView();
			if (onLoad)
				onLoad.call(this, item);
			view.update();
		}

		if (isRoot) {
			if (typeof source === 'string' && !/^.*</.test(source)) {
				node = document.getElementById(source);
				if (node) {
					source = null;
				} else {
					return Http.request('get', source, onLoadCallback);
				}
			} else if (typeof File !== 'undefined' && source instanceof File) {
				var reader = new FileReader();
				reader.onload = function() {
					onLoadCallback(reader.result);
				};
				return reader.readAsText(source);
			}
		}

		if (typeof source === 'string')
			node = new DOMParser().parseFromString(source, 'image/svg+xml');
		if (!node.nodeName)
			throw new Error('Unsupported SVG source: ' + source);
		var type = node.nodeName.toLowerCase(),
			importer = importers[type],
			item,
			data = node.getAttribute && node.getAttribute('data-paper-data'),
			settings = scope.settings,
			applyMatrix = settings.applyMatrix;
		settings.applyMatrix = false;
		item = importer && importer(node, type, options, isRoot) || null;
		settings.applyMatrix = applyMatrix;
		if (item) {
			if (type !== '#document' && !(item instanceof Group))
				item = applyAttributes(item, node, isRoot);
			var onImport = options.onImport;
			if (onImport)
				item = onImport(node, item, options) || item;
			if (options.expandShapes && item instanceof Shape) {
				item.remove();
				item = item.toPath();
			}
			if (data)
				item._data = JSON.parse(data);
		}
		if (isRoot) {
			definitions = {};
			if (item && Base.pick(options.applyMatrix, applyMatrix))
				item.matrix.apply(true, true);
		}
		return item;
	}

	Item.inject({
		importSVG: function(node, options) {
			return this.addChild(importSVG(node, options, true));
		}
	});

	Project.inject({
		importSVG: function(node, options) {
			this.activate();
			return importSVG(node, options, true);
		}
	});
};

Base.exports.PaperScript = (function() {
	var exports, define,
		scope = this;
!function(e,r){return"object"==typeof exports&&"object"==typeof module?r(exports):"function"==typeof define&&define.amd?define(["exports"],r):(r(e.acorn||(e.acorn={})),void 0)}(this,function(e){"use strict";function r(e){fr=e||{};for(var r in mr)Object.prototype.hasOwnProperty.call(fr,r)||(fr[r]=mr[r]);hr=fr.sourceFile||null}function t(e,r){var t=vr(dr,e);r+=" ("+t.line+":"+t.column+")";var n=new SyntaxError(r);throw n.pos=e,n.loc=t,n.raisedAt=br,n}function n(e){function r(e){if(1==e.length)return t+="return str === "+JSON.stringify(e[0])+";";t+="switch(str){";for(var r=0;r<e.length;++r)t+="case "+JSON.stringify(e[r])+":";t+="return true}return false;"}e=e.split(" ");var t="",n=[];e:for(var a=0;a<e.length;++a){for(var o=0;o<n.length;++o)if(n[o][0].length==e[a].length){n[o].push(e[a]);continue e}n.push([e[a]])}if(n.length>3){n.sort(function(e,r){return r.length-e.length}),t+="switch(str.length){";for(var a=0;a<n.length;++a){var i=n[a];t+="case "+i[0].length+":",r(i)}t+="}"}else r(e);return new Function("str",t)}function a(){this.line=Ar,this.column=br-Sr}function o(){Ar=1,br=Sr=0,Er=!0,u()}function i(e,r){gr=br,fr.locations&&(kr=new a),wr=e,u(),Cr=r,Er=e.beforeExpr}function s(){var e=fr.onComment&&fr.locations&&new a,r=br,n=dr.indexOf("*/",br+=2);if(-1===n&&t(br-2,"Unterminated comment"),br=n+2,fr.locations){Kt.lastIndex=r;for(var o;(o=Kt.exec(dr))&&o.index<br;)++Ar,Sr=o.index+o[0].length}fr.onComment&&fr.onComment(!0,dr.slice(r+2,n),r,br,e,fr.locations&&new a)}function c(){for(var e=br,r=fr.onComment&&fr.locations&&new a,t=dr.charCodeAt(br+=2);pr>br&&10!==t&&13!==t&&8232!==t&&8233!==t;)++br,t=dr.charCodeAt(br);fr.onComment&&fr.onComment(!1,dr.slice(e+2,br),e,br,r,fr.locations&&new a)}function u(){for(;pr>br;){var e=dr.charCodeAt(br);if(32===e)++br;else if(13===e){++br;var r=dr.charCodeAt(br);10===r&&++br,fr.locations&&(++Ar,Sr=br)}else if(10===e||8232===e||8233===e)++br,fr.locations&&(++Ar,Sr=br);else if(e>8&&14>e)++br;else if(47===e){var r=dr.charCodeAt(br+1);if(42===r)s();else{if(47!==r)break;c()}}else if(160===e)++br;else{if(!(e>=5760&&Jt.test(String.fromCharCode(e))))break;++br}}}function l(){var e=dr.charCodeAt(br+1);return e>=48&&57>=e?E(!0):(++br,i(xt))}function f(){var e=dr.charCodeAt(br+1);return Er?(++br,k()):61===e?x(Et,2):x(wt,1)}function d(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Dt,1)}function p(e){var r=dr.charCodeAt(br+1);return r===e?x(124===e?Lt:Ut,2):61===r?x(Et,2):x(124===e?Rt:Tt,1)}function h(){var e=dr.charCodeAt(br+1);return 61===e?x(Et,2):x(Vt,1)}function m(e){var r=dr.charCodeAt(br+1);return r===e?45==r&&62==dr.charCodeAt(br+2)&&Gt.test(dr.slice(Lr,br))?(br+=3,c(),u(),g()):x(St,2):61===r?x(Et,2):x(At,1)}function v(e){var r=dr.charCodeAt(br+1),t=1;return r===e?(t=62===e&&62===dr.charCodeAt(br+2)?3:2,61===dr.charCodeAt(br+t)?x(Et,t+1):x(jt,t)):33==r&&60==e&&45==dr.charCodeAt(br+2)&&45==dr.charCodeAt(br+3)?(br+=4,c(),u(),g()):(61===r&&(t=61===dr.charCodeAt(br+2)?3:2),x(Ot,t))}function b(e){var r=dr.charCodeAt(br+1);return 61===r?x(qt,61===dr.charCodeAt(br+2)?3:2):x(61===e?Ct:It,1)}function y(e){switch(e){case 46:return l();case 40:return++br,i(mt);case 41:return++br,i(vt);case 59:return++br,i(yt);case 44:return++br,i(bt);case 91:return++br,i(ft);case 93:return++br,i(dt);case 123:return++br,i(pt);case 125:return++br,i(ht);case 58:return++br,i(gt);case 63:return++br,i(kt);case 48:var r=dr.charCodeAt(br+1);if(120===r||88===r)return C();case 49:case 50:case 51:case 52:case 53:case 54:case 55:case 56:case 57:return E(!1);case 34:case 39:return A(e);case 47:return f(e);case 37:case 42:return d();case 124:case 38:return p(e);case 94:return h();case 43:case 45:return m(e);case 60:case 62:return v(e);case 61:case 33:return b(e);case 126:return x(It,1)}return!1}function g(e){if(e?br=yr+1:yr=br,fr.locations&&(xr=new a),e)return k();if(br>=pr)return i(Br);var r=dr.charCodeAt(br);if(Qt(r)||92===r)return L();var n=y(r);if(n===!1){var o=String.fromCharCode(r);if("\\"===o||$t.test(o))return L();t(br,"Unexpected character '"+o+"'")}return n}function x(e,r){var t=dr.slice(br,br+r);br+=r,i(e,t)}function k(){for(var e,r,n="",a=br;;){br>=pr&&t(a,"Unterminated regular expression");var o=dr.charAt(br);if(Gt.test(o)&&t(a,"Unterminated regular expression"),e)e=!1;else{if("["===o)r=!0;else if("]"===o&&r)r=!1;else if("/"===o&&!r)break;e="\\"===o}++br}var n=dr.slice(a,br);++br;var s=I();return s&&!/^[gmsiy]*$/.test(s)&&t(a,"Invalid regexp flag"),i(jr,new RegExp(n,s))}function w(e,r){for(var t=br,n=0,a=0,o=null==r?1/0:r;o>a;++a){var i,s=dr.charCodeAt(br);if(i=s>=97?s-97+10:s>=65?s-65+10:s>=48&&57>=s?s-48:1/0,i>=e)break;++br,n=n*e+i}return br===t||null!=r&&br-t!==r?null:n}function C(){br+=2;var e=w(16);return null==e&&t(yr+2,"Expected hexadecimal number"),Qt(dr.charCodeAt(br))&&t(br,"Identifier directly after number"),i(Or,e)}function E(e){var r=br,n=!1,a=48===dr.charCodeAt(br);e||null!==w(10)||t(r,"Invalid number"),46===dr.charCodeAt(br)&&(++br,w(10),n=!0);var o=dr.charCodeAt(br);(69===o||101===o)&&(o=dr.charCodeAt(++br),(43===o||45===o)&&++br,null===w(10)&&t(r,"Invalid number"),n=!0),Qt(dr.charCodeAt(br))&&t(br,"Identifier directly after number");var s,c=dr.slice(r,br);return n?s=parseFloat(c):a&&1!==c.length?/[89]/.test(c)||Tr?t(r,"Invalid number"):s=parseInt(c,8):s=parseInt(c,10),i(Or,s)}function A(e){br++;for(var r="";;){br>=pr&&t(yr,"Unterminated string constant");var n=dr.charCodeAt(br);if(n===e)return++br,i(Dr,r);if(92===n){n=dr.charCodeAt(++br);var a=/^[0-7]+/.exec(dr.slice(br,br+3));for(a&&(a=a[0]);a&&parseInt(a,8)>255;)a=a.slice(0,a.length-1);if("0"===a&&(a=null),++br,a)Tr&&t(br-2,"Octal literal in strict mode"),r+=String.fromCharCode(parseInt(a,8)),br+=a.length-1;else switch(n){case 110:r+="\n";break;case 114:r+="\r";break;case 120:r+=String.fromCharCode(S(2));break;case 117:r+=String.fromCharCode(S(4));break;case 85:r+=String.fromCharCode(S(8));break;case 116:r+="	";break;case 98:r+="\b";break;case 118:r+="";break;case 102:r+="\f";break;case 48:r+="\0";break;case 13:10===dr.charCodeAt(br)&&++br;case 10:fr.locations&&(Sr=br,++Ar);break;default:r+=String.fromCharCode(n)}}else(13===n||10===n||8232===n||8233===n)&&t(yr,"Unterminated string constant"),r+=String.fromCharCode(n),++br}}function S(e){var r=w(16,e);return null===r&&t(yr,"Bad character escape sequence"),r}function I(){Bt=!1;for(var e,r=!0,n=br;;){var a=dr.charCodeAt(br);if(Yt(a))Bt&&(e+=dr.charAt(br)),++br;else{if(92!==a)break;Bt||(e=dr.slice(n,br)),Bt=!0,117!=dr.charCodeAt(++br)&&t(br,"Expecting Unicode escape sequence \\uXXXX"),++br;var o=S(4),i=String.fromCharCode(o);i||t(br-1,"Invalid Unicode escape"),(r?Qt(o):Yt(o))||t(br-4,"Invalid Unicode escape"),e+=i}r=!1}return Bt?e:dr.slice(n,br)}function L(){var e=I(),r=Fr;return Bt||(Wt(e)?r=lt[e]:(fr.forbidReserved&&(3===fr.ecmaVersion?Mt:zt)(e)||Tr&&Xt(e))&&t(yr,"The keyword '"+e+"' is reserved")),i(r,e)}function U(){Ir=yr,Lr=gr,Ur=kr,g()}function R(e){if(Tr=e,br=Lr,fr.locations)for(;Sr>br;)Sr=dr.lastIndexOf("\n",Sr-2)+1,--Ar;u(),g()}function V(){this.type=null,this.start=yr,this.end=null}function T(){this.start=xr,this.end=null,null!==hr&&(this.source=hr)}function q(){var e=new V;return fr.locations&&(e.loc=new T),fr.ranges&&(e.range=[yr,0]),e}function O(e){var r=new V;return r.start=e.start,fr.locations&&(r.loc=new T,r.loc.start=e.loc.start),fr.ranges&&(r.range=[e.range[0],0]),r}function j(e,r){return e.type=r,e.end=Lr,fr.locations&&(e.loc.end=Ur),fr.ranges&&(e.range[1]=Lr),e}function D(e){return fr.ecmaVersion>=5&&"ExpressionStatement"===e.type&&"Literal"===e.expression.type&&"use strict"===e.expression.value}function F(e){return wr===e?(U(),!0):void 0}function B(){return!fr.strictSemicolons&&(wr===Br||wr===ht||Gt.test(dr.slice(Lr,yr)))}function M(){F(yt)||B()||X()}function z(e){wr===e?U():X()}function X(){t(yr,"Unexpected token")}function N(e){"Identifier"!==e.type&&"MemberExpression"!==e.type&&t(e.start,"Assigning to rvalue"),Tr&&"Identifier"===e.type&&Nt(e.name)&&t(e.start,"Assigning to "+e.name+" in strict mode")}function W(e){Ir=Lr=br,fr.locations&&(Ur=new a),Rr=Tr=null,Vr=[],g();var r=e||q(),t=!0;for(e||(r.body=[]);wr!==Br;){var n=J();r.body.push(n),t&&D(n)&&R(!0),t=!1}return j(r,"Program")}function J(){(wr===wt||wr===Et&&"/="==Cr)&&g(!0);var e=wr,r=q();switch(e){case Mr:case Nr:U();var n=e===Mr;F(yt)||B()?r.label=null:wr!==Fr?X():(r.label=lr(),M());for(var a=0;a<Vr.length;++a){var o=Vr[a];if(null==r.label||o.name===r.label.name){if(null!=o.kind&&(n||"loop"===o.kind))break;if(r.label&&n)break}}return a===Vr.length&&t(r.start,"Unsyntactic "+e.keyword),j(r,n?"BreakStatement":"ContinueStatement");case Wr:return U(),M(),j(r,"DebuggerStatement");case Pr:return U(),Vr.push(Zt),r.body=J(),Vr.pop(),z(tt),r.test=P(),M(),j(r,"DoWhileStatement");case _r:if(U(),Vr.push(Zt),z(mt),wr===yt)return $(r,null);if(wr===rt){var i=q();return U(),G(i,!0),j(i,"VariableDeclaration"),1===i.declarations.length&&F(ut)?_(r,i):$(r,i)}var i=K(!1,!0);return F(ut)?(N(i),_(r,i)):$(r,i);case Gr:return U(),cr(r,!0);case Kr:return U(),r.test=P(),r.consequent=J(),r.alternate=F(Hr)?J():null,j(r,"IfStatement");case Qr:return Rr||t(yr,"'return' outside of function"),U(),F(yt)||B()?r.argument=null:(r.argument=K(),M()),j(r,"ReturnStatement");case Yr:U(),r.discriminant=P(),r.cases=[],z(pt),Vr.push(en);for(var s,c;wr!=ht;)if(wr===zr||wr===Jr){var u=wr===zr;s&&j(s,"SwitchCase"),r.cases.push(s=q()),s.consequent=[],U(),u?s.test=K():(c&&t(Ir,"Multiple default clauses"),c=!0,s.test=null),z(gt)}else s||X(),s.consequent.push(J());return s&&j(s,"SwitchCase"),U(),Vr.pop(),j(r,"SwitchStatement");case Zr:return U(),Gt.test(dr.slice(Lr,yr))&&t(Lr,"Illegal newline after throw"),r.argument=K(),M(),j(r,"ThrowStatement");case et:if(U(),r.block=H(),r.handler=null,wr===Xr){var l=q();U(),z(mt),l.param=lr(),Tr&&Nt(l.param.name)&&t(l.param.start,"Binding "+l.param.name+" in strict mode"),z(vt),l.guard=null,l.body=H(),r.handler=j(l,"CatchClause")}return r.guardedHandlers=qr,r.finalizer=F($r)?H():null,r.handler||r.finalizer||t(r.start,"Missing catch or finally clause"),j(r,"TryStatement");case rt:return U(),G(r),M(),j(r,"VariableDeclaration");case tt:return U(),r.test=P(),Vr.push(Zt),r.body=J(),Vr.pop(),j(r,"WhileStatement");case nt:return Tr&&t(yr,"'with' in strict mode"),U(),r.object=P(),r.body=J(),j(r,"WithStatement");case pt:return H();case yt:return U(),j(r,"EmptyStatement");default:var f=Cr,d=K();if(e===Fr&&"Identifier"===d.type&&F(gt)){for(var a=0;a<Vr.length;++a)Vr[a].name===f&&t(d.start,"Label '"+f+"' is already declared");var p=wr.isLoop?"loop":wr===Yr?"switch":null;return Vr.push({name:f,kind:p}),r.body=J(),Vr.pop(),r.label=d,j(r,"LabeledStatement")}return r.expression=d,M(),j(r,"ExpressionStatement")}}function P(){z(mt);var e=K();return z(vt),e}function H(e){var r,t=q(),n=!0,a=!1;for(t.body=[],z(pt);!F(ht);){var o=J();t.body.push(o),n&&e&&D(o)&&(r=a,R(a=!0)),n=!1}return a&&!r&&R(!1),j(t,"BlockStatement")}function $(e,r){return e.init=r,z(yt),e.test=wr===yt?null:K(),z(yt),e.update=wr===vt?null:K(),z(vt),e.body=J(),Vr.pop(),j(e,"ForStatement")}function _(e,r){return e.left=r,e.right=K(),z(vt),e.body=J(),Vr.pop(),j(e,"ForInStatement")}function G(e,r){for(e.declarations=[],e.kind="var";;){var n=q();if(n.id=lr(),Tr&&Nt(n.id.name)&&t(n.id.start,"Binding "+n.id.name+" in strict mode"),n.init=F(Ct)?K(!0,r):null,e.declarations.push(j(n,"VariableDeclarator")),!F(bt))break}return e}function K(e,r){var t=Q(r);if(!e&&wr===bt){var n=O(t);for(n.expressions=[t];F(bt);)n.expressions.push(Q(r));return j(n,"SequenceExpression")}return t}function Q(e){var r=Y(e);if(wr.isAssign){var t=O(r);return t.operator=Cr,t.left=r,U(),t.right=Q(e),N(r),j(t,"AssignmentExpression")}return r}function Y(e){var r=Z(e);if(F(kt)){var t=O(r);return t.test=r,t.consequent=K(!0),z(gt),t.alternate=K(!0,e),j(t,"ConditionalExpression")}return r}function Z(e){return er(rr(),-1,e)}function er(e,r,t){var n=wr.binop;if(null!=n&&(!t||wr!==ut)&&n>r){var a=O(e);a.left=e,a.operator=Cr,U(),a.right=er(rr(),n,t);var o=j(a,/&&|\|\|/.test(a.operator)?"LogicalExpression":"BinaryExpression");return er(o,r,t)}return e}function rr(){if(wr.prefix){var e=q(),r=wr.isUpdate;return e.operator=Cr,e.prefix=!0,Er=!0,U(),e.argument=rr(),r?N(e.argument):Tr&&"delete"===e.operator&&"Identifier"===e.argument.type&&t(e.start,"Deleting local variable in strict mode"),j(e,r?"UpdateExpression":"UnaryExpression")}for(var n=tr();wr.postfix&&!B();){var e=O(n);e.operator=Cr,e.prefix=!1,e.argument=n,N(n),U(),n=j(e,"UpdateExpression")}return n}function tr(){return nr(ar())}function nr(e,r){if(F(xt)){var t=O(e);return t.object=e,t.property=lr(!0),t.computed=!1,nr(j(t,"MemberExpression"),r)}if(F(ft)){var t=O(e);return t.object=e,t.property=K(),t.computed=!0,z(dt),nr(j(t,"MemberExpression"),r)}if(!r&&F(mt)){var t=O(e);return t.callee=e,t.arguments=ur(vt,!1),nr(j(t,"CallExpression"),r)}return e}function ar(){switch(wr){case ot:var e=q();return U(),j(e,"ThisExpression");case Fr:return lr();case Or:case Dr:case jr:var e=q();return e.value=Cr,e.raw=dr.slice(yr,gr),U(),j(e,"Literal");case it:case st:case ct:var e=q();return e.value=wr.atomValue,e.raw=wr.keyword,U(),j(e,"Literal");case mt:var r=xr,t=yr;U();var n=K();return n.start=t,n.end=gr,fr.locations&&(n.loc.start=r,n.loc.end=kr),fr.ranges&&(n.range=[t,gr]),z(vt),n;case ft:var e=q();return U(),e.elements=ur(dt,!0,!0),j(e,"ArrayExpression");case pt:return ir();case Gr:var e=q();return U(),cr(e,!1);case at:return or();default:X()}}function or(){var e=q();return U(),e.callee=nr(ar(),!0),e.arguments=F(mt)?ur(vt,!1):qr,j(e,"NewExpression")}function ir(){var e=q(),r=!0,n=!1;for(e.properties=[],U();!F(ht);){if(r)r=!1;else if(z(bt),fr.allowTrailingCommas&&F(ht))break;var a,o={key:sr()},i=!1;if(F(gt)?(o.value=K(!0),a=o.kind="init"):fr.ecmaVersion>=5&&"Identifier"===o.key.type&&("get"===o.key.name||"set"===o.key.name)?(i=n=!0,a=o.kind=o.key.name,o.key=sr(),wr!==mt&&X(),o.value=cr(q(),!1)):X(),"Identifier"===o.key.type&&(Tr||n))for(var s=0;s<e.properties.length;++s){var c=e.properties[s];if(c.key.name===o.key.name){var u=a==c.kind||i&&"init"===c.kind||"init"===a&&("get"===c.kind||"set"===c.kind);u&&!Tr&&"init"===a&&"init"===c.kind&&(u=!1),u&&t(o.key.start,"Redefinition of property")}}e.properties.push(o)}return j(e,"ObjectExpression")}function sr(){return wr===Or||wr===Dr?ar():lr(!0)}function cr(e,r){wr===Fr?e.id=lr():r?X():e.id=null,e.params=[];var n=!0;for(z(mt);!F(vt);)n?n=!1:z(bt),e.params.push(lr());var a=Rr,o=Vr;if(Rr=!0,Vr=[],e.body=H(!0),Rr=a,Vr=o,Tr||e.body.body.length&&D(e.body.body[0]))for(var i=e.id?-1:0;i<e.params.length;++i){var s=0>i?e.id:e.params[i];if((Xt(s.name)||Nt(s.name))&&t(s.start,"Defining '"+s.name+"' in strict mode"),i>=0)for(var c=0;i>c;++c)s.name===e.params[c].name&&t(s.start,"Argument name clash in strict mode")}return j(e,r?"FunctionDeclaration":"FunctionExpression")}function ur(e,r,t){for(var n=[],a=!0;!F(e);){if(a)a=!1;else if(z(bt),r&&fr.allowTrailingCommas&&F(e))break;t&&wr===bt?n.push(null):n.push(K(!0))}return n}function lr(e){var r=q();return r.name=wr===Fr?Cr:e&&!fr.forbidReserved&&wr.keyword||X(),Er=!1,U(),j(r,"Identifier")}e.version="0.4.0";var fr,dr,pr,hr;e.parse=function(e,t){return dr=String(e),pr=dr.length,r(t),o(),W(fr.program)};var mr=e.defaultOptions={ecmaVersion:5,strictSemicolons:!1,allowTrailingCommas:!0,forbidReserved:!1,locations:!1,onComment:null,ranges:!1,program:null,sourceFile:null},vr=e.getLineInfo=function(e,r){for(var t=1,n=0;;){Kt.lastIndex=n;var a=Kt.exec(e);if(!(a&&a.index<r))break;++t,n=a.index+a[0].length}return{line:t,column:r-n}};e.tokenize=function(e,t){function n(e){return g(e),a.start=yr,a.end=gr,a.startLoc=xr,a.endLoc=kr,a.type=wr,a.value=Cr,a}dr=String(e),pr=dr.length,r(t),o();var a={};return n.jumpTo=function(e,r){if(br=e,fr.locations){Ar=1,Sr=Kt.lastIndex=0;for(var t;(t=Kt.exec(dr))&&t.index<e;)++Ar,Sr=t.index+t[0].length}Er=r,u()},n};var br,yr,gr,xr,kr,wr,Cr,Er,Ar,Sr,Ir,Lr,Ur,Rr,Vr,Tr,qr=[],Or={type:"num"},jr={type:"regexp"},Dr={type:"string"},Fr={type:"name"},Br={type:"eof"},Mr={keyword:"break"},zr={keyword:"case",beforeExpr:!0},Xr={keyword:"catch"},Nr={keyword:"continue"},Wr={keyword:"debugger"},Jr={keyword:"default"},Pr={keyword:"do",isLoop:!0},Hr={keyword:"else",beforeExpr:!0},$r={keyword:"finally"},_r={keyword:"for",isLoop:!0},Gr={keyword:"function"},Kr={keyword:"if"},Qr={keyword:"return",beforeExpr:!0},Yr={keyword:"switch"},Zr={keyword:"throw",beforeExpr:!0},et={keyword:"try"},rt={keyword:"var"},tt={keyword:"while",isLoop:!0},nt={keyword:"with"},at={keyword:"new",beforeExpr:!0},ot={keyword:"this"},it={keyword:"null",atomValue:null},st={keyword:"true",atomValue:!0},ct={keyword:"false",atomValue:!1},ut={keyword:"in",binop:7,beforeExpr:!0},lt={"break":Mr,"case":zr,"catch":Xr,"continue":Nr,"debugger":Wr,"default":Jr,"do":Pr,"else":Hr,"finally":$r,"for":_r,"function":Gr,"if":Kr,"return":Qr,"switch":Yr,"throw":Zr,"try":et,"var":rt,"while":tt,"with":nt,"null":it,"true":st,"false":ct,"new":at,"in":ut,"instanceof":{keyword:"instanceof",binop:7,beforeExpr:!0},"this":ot,"typeof":{keyword:"typeof",prefix:!0,beforeExpr:!0},"void":{keyword:"void",prefix:!0,beforeExpr:!0},"delete":{keyword:"delete",prefix:!0,beforeExpr:!0}},ft={type:"[",beforeExpr:!0},dt={type:"]"},pt={type:"{",beforeExpr:!0},ht={type:"}"},mt={type:"(",beforeExpr:!0},vt={type:")"},bt={type:",",beforeExpr:!0},yt={type:";",beforeExpr:!0},gt={type:":",beforeExpr:!0},xt={type:"."},kt={type:"?",beforeExpr:!0},wt={binop:10,beforeExpr:!0},Ct={isAssign:!0,beforeExpr:!0},Et={isAssign:!0,beforeExpr:!0},At={binop:9,prefix:!0,beforeExpr:!0},St={postfix:!0,prefix:!0,isUpdate:!0},It={prefix:!0,beforeExpr:!0},Lt={binop:1,beforeExpr:!0},Ut={binop:2,beforeExpr:!0},Rt={binop:3,beforeExpr:!0},Vt={binop:4,beforeExpr:!0},Tt={binop:5,beforeExpr:!0},qt={binop:6,beforeExpr:!0},Ot={binop:7,beforeExpr:!0},jt={binop:8,beforeExpr:!0},Dt={binop:10,beforeExpr:!0};e.tokTypes={bracketL:ft,bracketR:dt,braceL:pt,braceR:ht,parenL:mt,parenR:vt,comma:bt,semi:yt,colon:gt,dot:xt,question:kt,slash:wt,eq:Ct,name:Fr,eof:Br,num:Or,regexp:jr,string:Dr};for(var Ft in lt)e.tokTypes["_"+Ft]=lt[Ft];var Bt,Mt=n("abstract boolean byte char class double enum export extends final float goto implements import int interface long native package private protected public short static super synchronized throws transient volatile"),zt=n("class enum extends super const export import"),Xt=n("implements interface let package private protected public static yield"),Nt=n("eval arguments"),Wt=n("break case catch continue debugger default do else finally for function if return switch throw try var while with null true false instanceof typeof void delete new in this"),Jt=/[\u1680\u180e\u2000-\u200a\u202f\u205f\u3000\ufeff]/,Pt="\xaa\xb5\xba\xc0-\xd6\xd8-\xf6\xf8-\u02c1\u02c6-\u02d1\u02e0-\u02e4\u02ec\u02ee\u0370-\u0374\u0376\u0377\u037a-\u037d\u0386\u0388-\u038a\u038c\u038e-\u03a1\u03a3-\u03f5\u03f7-\u0481\u048a-\u0527\u0531-\u0556\u0559\u0561-\u0587\u05d0-\u05ea\u05f0-\u05f2\u0620-\u064a\u066e\u066f\u0671-\u06d3\u06d5\u06e5\u06e6\u06ee\u06ef\u06fa-\u06fc\u06ff\u0710\u0712-\u072f\u074d-\u07a5\u07b1\u07ca-\u07ea\u07f4\u07f5\u07fa\u0800-\u0815\u081a\u0824\u0828\u0840-\u0858\u08a0\u08a2-\u08ac\u0904-\u0939\u093d\u0950\u0958-\u0961\u0971-\u0977\u0979-\u097f\u0985-\u098c\u098f\u0990\u0993-\u09a8\u09aa-\u09b0\u09b2\u09b6-\u09b9\u09bd\u09ce\u09dc\u09dd\u09df-\u09e1\u09f0\u09f1\u0a05-\u0a0a\u0a0f\u0a10\u0a13-\u0a28\u0a2a-\u0a30\u0a32\u0a33\u0a35\u0a36\u0a38\u0a39\u0a59-\u0a5c\u0a5e\u0a72-\u0a74\u0a85-\u0a8d\u0a8f-\u0a91\u0a93-\u0aa8\u0aaa-\u0ab0\u0ab2\u0ab3\u0ab5-\u0ab9\u0abd\u0ad0\u0ae0\u0ae1\u0b05-\u0b0c\u0b0f\u0b10\u0b13-\u0b28\u0b2a-\u0b30\u0b32\u0b33\u0b35-\u0b39\u0b3d\u0b5c\u0b5d\u0b5f-\u0b61\u0b71\u0b83\u0b85-\u0b8a\u0b8e-\u0b90\u0b92-\u0b95\u0b99\u0b9a\u0b9c\u0b9e\u0b9f\u0ba3\u0ba4\u0ba8-\u0baa\u0bae-\u0bb9\u0bd0\u0c05-\u0c0c\u0c0e-\u0c10\u0c12-\u0c28\u0c2a-\u0c33\u0c35-\u0c39\u0c3d\u0c58\u0c59\u0c60\u0c61\u0c85-\u0c8c\u0c8e-\u0c90\u0c92-\u0ca8\u0caa-\u0cb3\u0cb5-\u0cb9\u0cbd\u0cde\u0ce0\u0ce1\u0cf1\u0cf2\u0d05-\u0d0c\u0d0e-\u0d10\u0d12-\u0d3a\u0d3d\u0d4e\u0d60\u0d61\u0d7a-\u0d7f\u0d85-\u0d96\u0d9a-\u0db1\u0db3-\u0dbb\u0dbd\u0dc0-\u0dc6\u0e01-\u0e30\u0e32\u0e33\u0e40-\u0e46\u0e81\u0e82\u0e84\u0e87\u0e88\u0e8a\u0e8d\u0e94-\u0e97\u0e99-\u0e9f\u0ea1-\u0ea3\u0ea5\u0ea7\u0eaa\u0eab\u0ead-\u0eb0\u0eb2\u0eb3\u0ebd\u0ec0-\u0ec4\u0ec6\u0edc-\u0edf\u0f00\u0f40-\u0f47\u0f49-\u0f6c\u0f88-\u0f8c\u1000-\u102a\u103f\u1050-\u1055\u105a-\u105d\u1061\u1065\u1066\u106e-\u1070\u1075-\u1081\u108e\u10a0-\u10c5\u10c7\u10cd\u10d0-\u10fa\u10fc-\u1248\u124a-\u124d\u1250-\u1256\u1258\u125a-\u125d\u1260-\u1288\u128a-\u128d\u1290-\u12b0\u12b2-\u12b5\u12b8-\u12be\u12c0\u12c2-\u12c5\u12c8-\u12d6\u12d8-\u1310\u1312-\u1315\u1318-\u135a\u1380-\u138f\u13a0-\u13f4\u1401-\u166c\u166f-\u167f\u1681-\u169a\u16a0-\u16ea\u16ee-\u16f0\u1700-\u170c\u170e-\u1711\u1720-\u1731\u1740-\u1751\u1760-\u176c\u176e-\u1770\u1780-\u17b3\u17d7\u17dc\u1820-\u1877\u1880-\u18a8\u18aa\u18b0-\u18f5\u1900-\u191c\u1950-\u196d\u1970-\u1974\u1980-\u19ab\u19c1-\u19c7\u1a00-\u1a16\u1a20-\u1a54\u1aa7\u1b05-\u1b33\u1b45-\u1b4b\u1b83-\u1ba0\u1bae\u1baf\u1bba-\u1be5\u1c00-\u1c23\u1c4d-\u1c4f\u1c5a-\u1c7d\u1ce9-\u1cec\u1cee-\u1cf1\u1cf5\u1cf6\u1d00-\u1dbf\u1e00-\u1f15\u1f18-\u1f1d\u1f20-\u1f45\u1f48-\u1f4d\u1f50-\u1f57\u1f59\u1f5b\u1f5d\u1f5f-\u1f7d\u1f80-\u1fb4\u1fb6-\u1fbc\u1fbe\u1fc2-\u1fc4\u1fc6-\u1fcc\u1fd0-\u1fd3\u1fd6-\u1fdb\u1fe0-\u1fec\u1ff2-\u1ff4\u1ff6-\u1ffc\u2071\u207f\u2090-\u209c\u2102\u2107\u210a-\u2113\u2115\u2119-\u211d\u2124\u2126\u2128\u212a-\u212d\u212f-\u2139\u213c-\u213f\u2145-\u2149\u214e\u2160-\u2188\u2c00-\u2c2e\u2c30-\u2c5e\u2c60-\u2ce4\u2ceb-\u2cee\u2cf2\u2cf3\u2d00-\u2d25\u2d27\u2d2d\u2d30-\u2d67\u2d6f\u2d80-\u2d96\u2da0-\u2da6\u2da8-\u2dae\u2db0-\u2db6\u2db8-\u2dbe\u2dc0-\u2dc6\u2dc8-\u2dce\u2dd0-\u2dd6\u2dd8-\u2dde\u2e2f\u3005-\u3007\u3021-\u3029\u3031-\u3035\u3038-\u303c\u3041-\u3096\u309d-\u309f\u30a1-\u30fa\u30fc-\u30ff\u3105-\u312d\u3131-\u318e\u31a0-\u31ba\u31f0-\u31ff\u3400-\u4db5\u4e00-\u9fcc\ua000-\ua48c\ua4d0-\ua4fd\ua500-\ua60c\ua610-\ua61f\ua62a\ua62b\ua640-\ua66e\ua67f-\ua697\ua6a0-\ua6ef\ua717-\ua71f\ua722-\ua788\ua78b-\ua78e\ua790-\ua793\ua7a0-\ua7aa\ua7f8-\ua801\ua803-\ua805\ua807-\ua80a\ua80c-\ua822\ua840-\ua873\ua882-\ua8b3\ua8f2-\ua8f7\ua8fb\ua90a-\ua925\ua930-\ua946\ua960-\ua97c\ua984-\ua9b2\ua9cf\uaa00-\uaa28\uaa40-\uaa42\uaa44-\uaa4b\uaa60-\uaa76\uaa7a\uaa80-\uaaaf\uaab1\uaab5\uaab6\uaab9-\uaabd\uaac0\uaac2\uaadb-\uaadd\uaae0-\uaaea\uaaf2-\uaaf4\uab01-\uab06\uab09-\uab0e\uab11-\uab16\uab20-\uab26\uab28-\uab2e\uabc0-\uabe2\uac00-\ud7a3\ud7b0-\ud7c6\ud7cb-\ud7fb\uf900-\ufa6d\ufa70-\ufad9\ufb00-\ufb06\ufb13-\ufb17\ufb1d\ufb1f-\ufb28\ufb2a-\ufb36\ufb38-\ufb3c\ufb3e\ufb40\ufb41\ufb43\ufb44\ufb46-\ufbb1\ufbd3-\ufd3d\ufd50-\ufd8f\ufd92-\ufdc7\ufdf0-\ufdfb\ufe70-\ufe74\ufe76-\ufefc\uff21-\uff3a\uff41-\uff5a\uff66-\uffbe\uffc2-\uffc7\uffca-\uffcf\uffd2-\uffd7\uffda-\uffdc",Ht="\u0300-\u036f\u0483-\u0487\u0591-\u05bd\u05bf\u05c1\u05c2\u05c4\u05c5\u05c7\u0610-\u061a\u0620-\u0649\u0672-\u06d3\u06e7-\u06e8\u06fb-\u06fc\u0730-\u074a\u0800-\u0814\u081b-\u0823\u0825-\u0827\u0829-\u082d\u0840-\u0857\u08e4-\u08fe\u0900-\u0903\u093a-\u093c\u093e-\u094f\u0951-\u0957\u0962-\u0963\u0966-\u096f\u0981-\u0983\u09bc\u09be-\u09c4\u09c7\u09c8\u09d7\u09df-\u09e0\u0a01-\u0a03\u0a3c\u0a3e-\u0a42\u0a47\u0a48\u0a4b-\u0a4d\u0a51\u0a66-\u0a71\u0a75\u0a81-\u0a83\u0abc\u0abe-\u0ac5\u0ac7-\u0ac9\u0acb-\u0acd\u0ae2-\u0ae3\u0ae6-\u0aef\u0b01-\u0b03\u0b3c\u0b3e-\u0b44\u0b47\u0b48\u0b4b-\u0b4d\u0b56\u0b57\u0b5f-\u0b60\u0b66-\u0b6f\u0b82\u0bbe-\u0bc2\u0bc6-\u0bc8\u0bca-\u0bcd\u0bd7\u0be6-\u0bef\u0c01-\u0c03\u0c46-\u0c48\u0c4a-\u0c4d\u0c55\u0c56\u0c62-\u0c63\u0c66-\u0c6f\u0c82\u0c83\u0cbc\u0cbe-\u0cc4\u0cc6-\u0cc8\u0cca-\u0ccd\u0cd5\u0cd6\u0ce2-\u0ce3\u0ce6-\u0cef\u0d02\u0d03\u0d46-\u0d48\u0d57\u0d62-\u0d63\u0d66-\u0d6f\u0d82\u0d83\u0dca\u0dcf-\u0dd4\u0dd6\u0dd8-\u0ddf\u0df2\u0df3\u0e34-\u0e3a\u0e40-\u0e45\u0e50-\u0e59\u0eb4-\u0eb9\u0ec8-\u0ecd\u0ed0-\u0ed9\u0f18\u0f19\u0f20-\u0f29\u0f35\u0f37\u0f39\u0f41-\u0f47\u0f71-\u0f84\u0f86-\u0f87\u0f8d-\u0f97\u0f99-\u0fbc\u0fc6\u1000-\u1029\u1040-\u1049\u1067-\u106d\u1071-\u1074\u1082-\u108d\u108f-\u109d\u135d-\u135f\u170e-\u1710\u1720-\u1730\u1740-\u1750\u1772\u1773\u1780-\u17b2\u17dd\u17e0-\u17e9\u180b-\u180d\u1810-\u1819\u1920-\u192b\u1930-\u193b\u1951-\u196d\u19b0-\u19c0\u19c8-\u19c9\u19d0-\u19d9\u1a00-\u1a15\u1a20-\u1a53\u1a60-\u1a7c\u1a7f-\u1a89\u1a90-\u1a99\u1b46-\u1b4b\u1b50-\u1b59\u1b6b-\u1b73\u1bb0-\u1bb9\u1be6-\u1bf3\u1c00-\u1c22\u1c40-\u1c49\u1c5b-\u1c7d\u1cd0-\u1cd2\u1d00-\u1dbe\u1e01-\u1f15\u200c\u200d\u203f\u2040\u2054\u20d0-\u20dc\u20e1\u20e5-\u20f0\u2d81-\u2d96\u2de0-\u2dff\u3021-\u3028\u3099\u309a\ua640-\ua66d\ua674-\ua67d\ua69f\ua6f0-\ua6f1\ua7f8-\ua800\ua806\ua80b\ua823-\ua827\ua880-\ua881\ua8b4-\ua8c4\ua8d0-\ua8d9\ua8f3-\ua8f7\ua900-\ua909\ua926-\ua92d\ua930-\ua945\ua980-\ua983\ua9b3-\ua9c0\uaa00-\uaa27\uaa40-\uaa41\uaa4c-\uaa4d\uaa50-\uaa59\uaa7b\uaae0-\uaae9\uaaf2-\uaaf3\uabc0-\uabe1\uabec\uabed\uabf0-\uabf9\ufb20-\ufb28\ufe00-\ufe0f\ufe20-\ufe26\ufe33\ufe34\ufe4d-\ufe4f\uff10-\uff19\uff3f",$t=new RegExp("["+Pt+"]"),_t=new RegExp("["+Pt+Ht+"]"),Gt=/[\n\r\u2028\u2029]/,Kt=/\r\n|[\n\r\u2028\u2029]/g,Qt=e.isIdentifierStart=function(e){return 65>e?36===e:91>e?!0:97>e?95===e:123>e?!0:e>=170&&$t.test(String.fromCharCode(e))},Yt=e.isIdentifierChar=function(e){return 48>e?36===e:58>e?!0:65>e?!1:91>e?!0:97>e?95===e:123>e?!0:e>=170&&_t.test(String.fromCharCode(e))},Zt={kind:"loop"},en={kind:"switch"}});

	var binaryOperators = {
		'+': '__add',
		'-': '__subtract',
		'*': '__multiply',
		'/': '__divide',
		'%': '__modulo',
		'==': 'equals',
		'!=': 'equals'
	};

	var unaryOperators = {
		'-': '__negate',
		'+': null
	};

	var fields = Base.each(
		['add', 'subtract', 'multiply', 'divide', 'modulo', 'negate'],
		function(name) {
			this['__' + name] = '#' + name;
		},
		{}
	);
	Point.inject(fields);
	Size.inject(fields);
	Color.inject(fields);

	function __$__(left, operator, right) {
		var handler = binaryOperators[operator];
		if (left && left[handler]) {
			var res = left[handler](right);
			return operator === '!=' ? !res : res;
		}
		switch (operator) {
		case '+': return left + right;
		case '-': return left - right;
		case '*': return left * right;
		case '/': return left / right;
		case '%': return left % right;
		case '==': return left == right;
		case '!=': return left != right;
		}
	}

	function $__(operator, value) {
		var handler = unaryOperators[operator];
		if (handler && value && value[handler])
			return value[handler]();
		switch (operator) {
		case '+': return +value;
		case '-': return -value;
		}
	}

	function parse(code, options) {
		return scope.acorn.parse(code, options);
	}

	function compile(code, url, options) {
		if (!code)
			return '';
		options = options || {};
		url = url || '';

		var insertions = [];

		function getOffset(offset) {
			for (var i = 0, l = insertions.length; i < l; i++) {
				var insertion = insertions[i];
				if (insertion[0] >= offset)
					break;
				offset += insertion[1];
			}
			return offset;
		}

		function getCode(node) {
			return code.substring(getOffset(node.range[0]),
					getOffset(node.range[1]));
		}

		function getBetween(left, right) {
			return code.substring(getOffset(left.range[1]),
					getOffset(right.range[0]));
		}

		function replaceCode(node, str) {
			var start = getOffset(node.range[0]),
				end = getOffset(node.range[1]),
				insert = 0;
			for (var i = insertions.length - 1; i >= 0; i--) {
				if (start > insertions[i][0]) {
					insert = i + 1;
					break;
				}
			}
			insertions.splice(insert, 0, [start, str.length - end + start]);
			code = code.substring(0, start) + str + code.substring(end);
		}

		function walkAST(node, parent) {
			if (!node)
				return;
			for (var key in node) {
				if (key === 'range' || key === 'loc')
					continue;
				var value = node[key];
				if (Array.isArray(value)) {
					for (var i = 0, l = value.length; i < l; i++)
						walkAST(value[i], node);
				} else if (value && typeof value === 'object') {
					walkAST(value, node);
				}
			}
			switch (node.type) {
			case 'UnaryExpression':
				if (node.operator in unaryOperators
						&& node.argument.type !== 'Literal') {
					var arg = getCode(node.argument);
					replaceCode(node, '$__("' + node.operator + '", '
							+ arg + ')');
				}
				break;
			case 'BinaryExpression':
				if (node.operator in binaryOperators
						&& node.left.type !== 'Literal') {
					var left = getCode(node.left),
						right = getCode(node.right),
						between = getBetween(node.left, node.right),
						operator = node.operator;
					replaceCode(node, '__$__(' + left + ','
							+ between.replace(new RegExp('\\' + operator),
								'"' + operator + '"')
							+ ', ' + right + ')');
				}
				break;
			case 'UpdateExpression':
			case 'AssignmentExpression':
				var parentType = parent && parent.type;
				if (!(
						parentType === 'ForStatement'
						|| parentType === 'BinaryExpression'
							&& /^[=!<>]/.test(parent.operator)
						|| parentType === 'MemberExpression' && parent.computed
				)) {
					if (node.type === 'UpdateExpression') {
						var arg = getCode(node.argument),
							exp = '__$__(' + arg + ', "' + node.operator[0]
									+ '", 1)',
							str = arg + ' = ' + exp;
						if (!node.prefix
								&& (parentType === 'AssignmentExpression'
									|| parentType === 'VariableDeclarator')) {
							if (getCode(parent.left || parent.id) === arg)
								str = exp;
							str = arg + '; ' + str;
						}
						replaceCode(node, str);
					} else {
						if (/^.=$/.test(node.operator)
								&& node.left.type !== 'Literal') {
							var left = getCode(node.left),
								right = getCode(node.right);
							replaceCode(node, left + ' = __$__(' + left + ', "'
									+ node.operator[0] + '", ' + right + ')');
						}
					}
				}
				break;
			}
		}
		var sourceMap = null,
			browser = paper.browser,
			version = browser.versionNumber,
			lineBreaks = /\r\n|\n|\r/mg;
		if (browser.chrome && version >= 30
				|| browser.webkit && version >= 537.76
				|| browser.firefox && version >= 23) {
			var offset = 0;
			if (window.location.href.indexOf(url) === 0) {
				var html = document.getElementsByTagName('html')[0].innerHTML;
				offset = html.substr(0, html.indexOf(code) + 1).match(
						lineBreaks).length + 1;
			}
			var mappings = ['AAAA'];
			mappings.length = (code.match(lineBreaks) || []).length + 1 + offset;
			sourceMap = {
				version: 3,
				file: url,
				names:[],
				mappings: mappings.join(';AACA'),
				sourceRoot: '',
				sources: [url]
			};
			var source = options.source || !url && code;
			if (source)
				sourceMap.sourcesContent = [source];
		}
		walkAST(parse(code, { ranges: true }));
		if (sourceMap) {
			code = new Array(offset + 1).join('\n') + code
					+ "\n//# sourceMappingURL=data:application/json;base64,"
					+ (btoa(unescape(encodeURIComponent(
						JSON.stringify(sourceMap)))))
					+ "\n//# sourceURL=" + (url || 'paperscript');
		}
		return code;
	}

	function execute(code, scope, url, options) {
		paper = scope;
		var view = scope.getView(),
			tool = /\s+on(?:Key|Mouse)(?:Up|Down|Move|Drag)\b/.test(code)
					? new Tool()
					: null,
			toolHandlers = tool ? tool._events : [],
			handlers = ['onFrame', 'onResize'].concat(toolHandlers),
			params = [],
			args = [],
			func;
		code = compile(code, url, options);
		function expose(scope, hidden) {
			for (var key in scope) {
				if ((hidden || !/^_/.test(key)) && new RegExp('([\\b\\s\\W]|^)'
						+ key.replace(/\$/g, '\\$') + '\\b').test(code)) {
					params.push(key);
					args.push(scope[key]);
				}
			}
		}
		expose({ __$__: __$__, $__: $__, paper: scope, view: view, tool: tool },
				true);
		expose(scope);
		handlers = Base.each(handlers, function(key) {
			if (new RegExp('\\s+' + key + '\\b').test(code)) {
				params.push(key);
				this.push(key + ': ' + key);
			}
		}, []).join(', ');
		if (handlers)
			code += '\nreturn { ' + handlers + ' };';
		var browser = paper.browser;
		if (browser.chrome || browser.firefox) {
			var script = document.createElement('script'),
				head = document.head || document.getElementsByTagName('head')[0];
			if (browser.firefox)
				code = '\n' + code;
			script.appendChild(document.createTextNode(
				'paper._execute = function(' + params + ') {' + code + '\n}'
			));
			head.appendChild(script);
			func = paper._execute;
			delete paper._execute;
			head.removeChild(script);
		} else {
			func = Function(params, code);
		}
		var res = func.apply(scope, args) || {};
		Base.each(toolHandlers, function(key) {
			var value = res[key];
			if (value)
				tool[key] = value;
		});
		if (view) {
			if (res.onResize)
				view.setOnResize(res.onResize);
			view.emit('resize', {
				size: view.size,
				delta: new Point()
			});
			if (res.onFrame)
				view.setOnFrame(res.onFrame);
			view.update();
		}
	}

	function loadScript(script) {
		if (/^text\/(?:x-|)paperscript$/.test(script.type)
				&& PaperScope.getAttribute(script, 'ignore') !== 'true') {
			var canvasId = PaperScope.getAttribute(script, 'canvas'),
				canvas = document.getElementById(canvasId),
				src = script.src || script.getAttribute('data-src'),
				async = PaperScope.hasAttribute(script, 'async'),
				scopeAttribute = 'data-paper-scope';
			if (!canvas)
				throw new Error('Unable to find canvas with id "'
						+ canvasId + '"');
			var scope = PaperScope.get(canvas.getAttribute(scopeAttribute))
						|| new PaperScope().setup(canvas);
			canvas.setAttribute(scopeAttribute, scope._id);
			if (src) {
				Http.request('get', src, function(code) {
					execute(code, scope, src);
				}, async);
			} else {
				execute(script.innerHTML, scope, script.baseURI);
			}
			script.setAttribute('data-paper-ignore', 'true');
			return scope;
		}
	}

	function loadAll() {
		Base.each(document.getElementsByTagName('script'), loadScript);
	}

	function load(script) {
		return script ? loadScript(script) : loadAll();
	}

	if (document.readyState === 'complete') {
		setTimeout(loadAll);
	} else {
		DomEvent.add(window, { load: loadAll });
	}

	return {
		compile: compile,
		execute: execute,
		load: load,
		parse: parse
	};

}).call(this);

paper = new (PaperScope.inject(Base.exports, {
	enumerable: true,
	Base: Base,
	Numerical: Numerical,
	Key: Key
}))();

if (typeof define === 'function' && define.amd) {
	define('paper', paper);
} else if (typeof module === 'object' && module) {
	module.exports = paper;
}

return paper;
};

},{}],8:[function(require,module,exports){
(function (process){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

}).call(this,require('_process'))

},{"_process":4}],9:[function(require,module,exports){
//     Underscore.js 1.8.3
//     http://underscorejs.org
//     (c) 2009-2015 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind,
    nativeCreate       = Object.create;

  // Naked function reference for surrogate-prototype-swapping.
  var Ctor = function(){};

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object.
  if (typeof exports !== 'undefined') {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.8.3';

  // Internal function that returns an efficient (for current engines) version
  // of the passed-in callback, to be repeatedly applied in other Underscore
  // functions.
  var optimizeCb = function(func, context, argCount) {
    if (context === void 0) return func;
    switch (argCount == null ? 3 : argCount) {
      case 1: return function(value) {
        return func.call(context, value);
      };
      case 2: return function(value, other) {
        return func.call(context, value, other);
      };
      case 3: return function(value, index, collection) {
        return func.call(context, value, index, collection);
      };
      case 4: return function(accumulator, value, index, collection) {
        return func.call(context, accumulator, value, index, collection);
      };
    }
    return function() {
      return func.apply(context, arguments);
    };
  };

  // A mostly-internal function to generate callbacks that can be applied
  // to each element in a collection, returning the desired result  either
  // identity, an arbitrary callback, a property matcher, or a property accessor.
  var cb = function(value, context, argCount) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return optimizeCb(value, context, argCount);
    if (_.isObject(value)) return _.matcher(value);
    return _.property(value);
  };
  _.iteratee = function(value, context) {
    return cb(value, context, Infinity);
  };

  // An internal function for creating assigner functions.
  var createAssigner = function(keysFunc, undefinedOnly) {
    return function(obj) {
      var length = arguments.length;
      if (length < 2 || obj == null) return obj;
      for (var index = 1; index < length; index++) {
        var source = arguments[index],
            keys = keysFunc(source),
            l = keys.length;
        for (var i = 0; i < l; i++) {
          var key = keys[i];
          if (!undefinedOnly || obj[key] === void 0) obj[key] = source[key];
        }
      }
      return obj;
    };
  };

  // An internal function for creating a new object that inherits from another.
  var baseCreate = function(prototype) {
    if (!_.isObject(prototype)) return {};
    if (nativeCreate) return nativeCreate(prototype);
    Ctor.prototype = prototype;
    var result = new Ctor;
    Ctor.prototype = null;
    return result;
  };

  var property = function(key) {
    return function(obj) {
      return obj == null ? void 0 : obj[key];
    };
  };

  // Helper for collection methods to determine whether a collection
  // should be iterated as an array or as an object
  // Related: http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength
  // Avoids a very nasty iOS 8 JIT bug on ARM-64. #2094
  var MAX_ARRAY_INDEX = Math.pow(2, 53) - 1;
  var getLength = property('length');
  var isArrayLike = function(collection) {
    var length = getLength(collection);
    return typeof length == 'number' && length >= 0 && length <= MAX_ARRAY_INDEX;
  };

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles raw objects in addition to array-likes. Treats all
  // sparse array-likes as if they were dense.
  _.each = _.forEach = function(obj, iteratee, context) {
    iteratee = optimizeCb(iteratee, context);
    var i, length;
    if (isArrayLike(obj)) {
      for (i = 0, length = obj.length; i < length; i++) {
        iteratee(obj[i], i, obj);
      }
    } else {
      var keys = _.keys(obj);
      for (i = 0, length = keys.length; i < length; i++) {
        iteratee(obj[keys[i]], keys[i], obj);
      }
    }
    return obj;
  };

  // Return the results of applying the iteratee to each element.
  _.map = _.collect = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length,
        results = Array(length);
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      results[index] = iteratee(obj[currentKey], currentKey, obj);
    }
    return results;
  };

  // Create a reducing function iterating left or right.
  function createReduce(dir) {
    // Optimized iterator function as using arguments.length
    // in the main function will deoptimize the, see #1991.
    function iterator(obj, iteratee, memo, keys, index, length) {
      for (; index >= 0 && index < length; index += dir) {
        var currentKey = keys ? keys[index] : index;
        memo = iteratee(memo, obj[currentKey], currentKey, obj);
      }
      return memo;
    }

    return function(obj, iteratee, memo, context) {
      iteratee = optimizeCb(iteratee, context, 4);
      var keys = !isArrayLike(obj) && _.keys(obj),
          length = (keys || obj).length,
          index = dir > 0 ? 0 : length - 1;
      // Determine the initial value if none is provided.
      if (arguments.length < 3) {
        memo = obj[keys ? keys[index] : index];
        index += dir;
      }
      return iterator(obj, iteratee, memo, keys, index, length);
    };
  }

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`.
  _.reduce = _.foldl = _.inject = createReduce(1);

  // The right-associative version of reduce, also known as `foldr`.
  _.reduceRight = _.foldr = createReduce(-1);

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var key;
    if (isArrayLike(obj)) {
      key = _.findIndex(obj, predicate, context);
    } else {
      key = _.findKey(obj, predicate, context);
    }
    if (key !== void 0 && key !== -1) return obj[key];
  };

  // Return all the elements that pass a truth test.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    predicate = cb(predicate, context);
    _.each(obj, function(value, index, list) {
      if (predicate(value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, _.negate(cb(predicate)), context);
  };

  // Determine whether all of the elements match a truth test.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (!predicate(obj[currentKey], currentKey, obj)) return false;
    }
    return true;
  };

  // Determine if at least one element in the object matches a truth test.
  // Aliased as `any`.
  _.some = _.any = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = !isArrayLike(obj) && _.keys(obj),
        length = (keys || obj).length;
    for (var index = 0; index < length; index++) {
      var currentKey = keys ? keys[index] : index;
      if (predicate(obj[currentKey], currentKey, obj)) return true;
    }
    return false;
  };

  // Determine if the array or object contains a given item (using `===`).
  // Aliased as `includes` and `include`.
  _.contains = _.includes = _.include = function(obj, item, fromIndex, guard) {
    if (!isArrayLike(obj)) obj = _.values(obj);
    if (typeof fromIndex != 'number' || guard) fromIndex = 0;
    return _.indexOf(obj, item, fromIndex) >= 0;
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      var func = isFunc ? method : value[method];
      return func == null ? func : func.apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matcher(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matcher(attrs));
  };

  // Return the maximum element (or element-based computation).
  _.max = function(obj, iteratee, context) {
    var result = -Infinity, lastComputed = -Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value > result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed > lastComputed || computed === -Infinity && result === -Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iteratee, context) {
    var result = Infinity, lastComputed = Infinity,
        value, computed;
    if (iteratee == null && obj != null) {
      obj = isArrayLike(obj) ? obj : _.values(obj);
      for (var i = 0, length = obj.length; i < length; i++) {
        value = obj[i];
        if (value < result) {
          result = value;
        }
      }
    } else {
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index, list) {
        computed = iteratee(value, index, list);
        if (computed < lastComputed || computed === Infinity && result === Infinity) {
          result = value;
          lastComputed = computed;
        }
      });
    }
    return result;
  };

  // Shuffle a collection, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/FisherYates_shuffle).
  _.shuffle = function(obj) {
    var set = isArrayLike(obj) ? obj : _.values(obj);
    var length = set.length;
    var shuffled = Array(length);
    for (var index = 0, rand; index < length; index++) {
      rand = _.random(0, index);
      if (rand !== index) shuffled[index] = shuffled[rand];
      shuffled[rand] = set[index];
    }
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (!isArrayLike(obj)) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // Sort the object's values by a criterion produced by an iteratee.
  _.sortBy = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iteratee(value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iteratee, context) {
      var result = {};
      iteratee = cb(iteratee, context);
      _.each(obj, function(value, index) {
        var key = iteratee(value, index, obj);
        behavior(result, value, key);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key].push(value); else result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, value, key) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, value, key) {
    if (_.has(result, key)) result[key]++; else result[key] = 1;
  });

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (isArrayLike(obj)) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return isArrayLike(obj) ? obj.length : _.keys(obj).length;
  };

  // Split a collection into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var pass = [], fail = [];
    _.each(obj, function(value, key, obj) {
      (predicate(value, key, obj) ? pass : fail).push(value);
    });
    return [pass, fail];
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[0];
    return _.initial(array, array.length - n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, Math.max(0, array.length - (n == null || guard ? 1 : n)));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if (n == null || guard) return array[array.length - 1];
    return _.rest(array, Math.max(0, array.length - n));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, n == null || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, strict, startIndex) {
    var output = [], idx = 0;
    for (var i = startIndex || 0, length = getLength(input); i < length; i++) {
      var value = input[i];
      if (isArrayLike(value) && (_.isArray(value) || _.isArguments(value))) {
        //flatten current level of array or arguments object
        if (!shallow) value = flatten(value, shallow, strict);
        var j = 0, len = value.length;
        output.length += len;
        while (j < len) {
          output[idx++] = value[j++];
        }
      } else if (!strict) {
        output[idx++] = value;
      }
    }
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, false);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iteratee, context) {
    if (!_.isBoolean(isSorted)) {
      context = iteratee;
      iteratee = isSorted;
      isSorted = false;
    }
    if (iteratee != null) iteratee = cb(iteratee, context);
    var result = [];
    var seen = [];
    for (var i = 0, length = getLength(array); i < length; i++) {
      var value = array[i],
          computed = iteratee ? iteratee(value, i, array) : value;
      if (isSorted) {
        if (!i || seen !== computed) result.push(value);
        seen = computed;
      } else if (iteratee) {
        if (!_.contains(seen, computed)) {
          seen.push(computed);
          result.push(value);
        }
      } else if (!_.contains(result, value)) {
        result.push(value);
      }
    }
    return result;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(flatten(arguments, true, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var result = [];
    var argsLength = arguments.length;
    for (var i = 0, length = getLength(array); i < length; i++) {
      var item = array[i];
      if (_.contains(result, item)) continue;
      for (var j = 1; j < argsLength; j++) {
        if (!_.contains(arguments[j], item)) break;
      }
      if (j === argsLength) result.push(item);
    }
    return result;
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = flatten(arguments, true, true, 1);
    return _.filter(array, function(value){
      return !_.contains(rest, value);
    });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    return _.unzip(arguments);
  };

  // Complement of _.zip. Unzip accepts an array of arrays and groups
  // each array's elements on shared indices
  _.unzip = function(array) {
    var length = array && _.max(array, getLength).length || 0;
    var result = Array(length);

    for (var index = 0; index < length; index++) {
      result[index] = _.pluck(array, index);
    }
    return result;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    var result = {};
    for (var i = 0, length = getLength(list); i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // Generator function to create the findIndex and findLastIndex functions
  function createPredicateIndexFinder(dir) {
    return function(array, predicate, context) {
      predicate = cb(predicate, context);
      var length = getLength(array);
      var index = dir > 0 ? 0 : length - 1;
      for (; index >= 0 && index < length; index += dir) {
        if (predicate(array[index], index, array)) return index;
      }
      return -1;
    };
  }

  // Returns the first index on an array-like that passes a predicate test
  _.findIndex = createPredicateIndexFinder(1);
  _.findLastIndex = createPredicateIndexFinder(-1);

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iteratee, context) {
    iteratee = cb(iteratee, context, 1);
    var value = iteratee(obj);
    var low = 0, high = getLength(array);
    while (low < high) {
      var mid = Math.floor((low + high) / 2);
      if (iteratee(array[mid]) < value) low = mid + 1; else high = mid;
    }
    return low;
  };

  // Generator function to create the indexOf and lastIndexOf functions
  function createIndexFinder(dir, predicateFind, sortedIndex) {
    return function(array, item, idx) {
      var i = 0, length = getLength(array);
      if (typeof idx == 'number') {
        if (dir > 0) {
            i = idx >= 0 ? idx : Math.max(idx + length, i);
        } else {
            length = idx >= 0 ? Math.min(idx + 1, length) : idx + length + 1;
        }
      } else if (sortedIndex && idx && length) {
        idx = sortedIndex(array, item);
        return array[idx] === item ? idx : -1;
      }
      if (item !== item) {
        idx = predicateFind(slice.call(array, i, length), _.isNaN);
        return idx >= 0 ? idx + i : -1;
      }
      for (idx = dir > 0 ? i : length - 1; idx >= 0 && idx < length; idx += dir) {
        if (array[idx] === item) return idx;
      }
      return -1;
    };
  }

  // Return the position of the first occurrence of an item in an array,
  // or -1 if the item is not included in the array.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = createIndexFinder(1, _.findIndex, _.sortedIndex);
  _.lastIndexOf = createIndexFinder(-1, _.findLastIndex);

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (stop == null) {
      stop = start || 0;
      start = 0;
    }
    step = step || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var range = Array(length);

    for (var idx = 0; idx < length; idx++, start += step) {
      range[idx] = start;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Determines whether to execute a function as a constructor
  // or a normal function with the provided arguments
  var executeBound = function(sourceFunc, boundFunc, context, callingContext, args) {
    if (!(callingContext instanceof boundFunc)) return sourceFunc.apply(context, args);
    var self = baseCreate(sourceFunc.prototype);
    var result = sourceFunc.apply(self, args);
    if (_.isObject(result)) return result;
    return self;
  };

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError('Bind must be called on a function');
    var args = slice.call(arguments, 2);
    var bound = function() {
      return executeBound(func, bound, context, this, args.concat(slice.call(arguments)));
    };
    return bound;
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    var bound = function() {
      var position = 0, length = boundArgs.length;
      var args = Array(length);
      for (var i = 0; i < length; i++) {
        args[i] = boundArgs[i] === _ ? arguments[position++] : boundArgs[i];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return executeBound(func, bound, this, this, args);
    };
    return bound;
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var i, length = arguments.length, key;
    if (length <= 1) throw new Error('bindAll must be passed function names');
    for (i = 1; i < length; i++) {
      key = arguments[i];
      obj[key] = _.bind(obj[key], obj);
    }
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memoize = function(key) {
      var cache = memoize.cache;
      var address = '' + (hasher ? hasher.apply(this, arguments) : key);
      if (!_.has(cache, address)) cache[address] = func.apply(this, arguments);
      return cache[address];
    };
    memoize.cache = {};
    return memoize;
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){
      return func.apply(null, args);
    }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = _.partial(_.delay, _, 1);

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    if (!options) options = {};
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      if (!timeout) context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0 || remaining > wait) {
        if (timeout) {
          clearTimeout(timeout);
          timeout = null;
        }
        previous = now;
        result = func.apply(context, args);
        if (!timeout) context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;

      if (last < wait && last >= 0) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          if (!timeout) context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) timeout = setTimeout(later, wait);
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a negated version of the passed-in predicate.
  _.negate = function(predicate) {
    return function() {
      return !predicate.apply(this, arguments);
    };
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var args = arguments;
    var start = args.length - 1;
    return function() {
      var i = start;
      var result = args[start].apply(this, arguments);
      while (i--) result = args[i].call(this, result);
      return result;
    };
  };

  // Returns a function that will only be executed on and after the Nth call.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Returns a function that will only be executed up to (but not including) the Nth call.
  _.before = function(times, func) {
    var memo;
    return function() {
      if (--times > 0) {
        memo = func.apply(this, arguments);
      }
      if (times <= 1) func = null;
      return memo;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = _.partial(_.before, 2);

  // Object Functions
  // ----------------

  // Keys in IE < 9 that won't be iterated by `for key in ...` and thus missed.
  var hasEnumBug = !{toString: null}.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['valueOf', 'isPrototypeOf', 'toString',
                      'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString'];

  function collectNonEnumProps(obj, keys) {
    var nonEnumIdx = nonEnumerableProps.length;
    var constructor = obj.constructor;
    var proto = (_.isFunction(constructor) && constructor.prototype) || ObjProto;

    // Constructor is a special case.
    var prop = 'constructor';
    if (_.has(obj, prop) && !_.contains(keys, prop)) keys.push(prop);

    while (nonEnumIdx--) {
      prop = nonEnumerableProps[nonEnumIdx];
      if (prop in obj && obj[prop] !== proto[prop] && !_.contains(keys, prop)) {
        keys.push(prop);
      }
    }
  }

  // Retrieve the names of an object's own properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve all the property names of an object.
  _.allKeys = function(obj) {
    if (!_.isObject(obj)) return [];
    var keys = [];
    for (var key in obj) keys.push(key);
    // Ahem, IE < 9.
    if (hasEnumBug) collectNonEnumProps(obj, keys);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Returns the results of applying the iteratee to each element of the object
  // In contrast to _.map it returns an object
  _.mapObject = function(obj, iteratee, context) {
    iteratee = cb(iteratee, context);
    var keys =  _.keys(obj),
          length = keys.length,
          results = {},
          currentKey;
      for (var index = 0; index < length; index++) {
        currentKey = keys[index];
        results[currentKey] = iteratee(obj[currentKey], currentKey, obj);
      }
      return results;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = createAssigner(_.allKeys);

  // Assigns a given object with all the own properties in the passed-in object(s)
  // (https://developer.mozilla.org/docs/Web/JavaScript/Reference/Global_Objects/Object/assign)
  _.extendOwn = _.assign = createAssigner(_.keys);

  // Returns the first key on an object that passes a predicate test
  _.findKey = function(obj, predicate, context) {
    predicate = cb(predicate, context);
    var keys = _.keys(obj), key;
    for (var i = 0, length = keys.length; i < length; i++) {
      key = keys[i];
      if (predicate(obj[key], key, obj)) return key;
    }
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(object, oiteratee, context) {
    var result = {}, obj = object, iteratee, keys;
    if (obj == null) return result;
    if (_.isFunction(oiteratee)) {
      keys = _.allKeys(obj);
      iteratee = optimizeCb(oiteratee, context);
    } else {
      keys = flatten(arguments, false, false, 1);
      iteratee = function(value, key, obj) { return key in obj; };
      obj = Object(obj);
    }
    for (var i = 0, length = keys.length; i < length; i++) {
      var key = keys[i];
      var value = obj[key];
      if (iteratee(value, key, obj)) result[key] = value;
    }
    return result;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj, iteratee, context) {
    if (_.isFunction(iteratee)) {
      iteratee = _.negate(iteratee);
    } else {
      var keys = _.map(flatten(arguments, false, false, 1), String);
      iteratee = function(value, key) {
        return !_.contains(keys, key);
      };
    }
    return _.pick(obj, iteratee, context);
  };

  // Fill in a given object with default properties.
  _.defaults = createAssigner(_.allKeys, true);

  // Creates an object that inherits from the given prototype object.
  // If additional properties are provided then they will be added to the
  // created object.
  _.create = function(prototype, props) {
    var result = baseCreate(prototype);
    if (props) _.extendOwn(result, props);
    return result;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Returns whether an object has a given set of `key:value` pairs.
  _.isMatch = function(object, attrs) {
    var keys = _.keys(attrs), length = keys.length;
    if (object == null) return !length;
    var obj = Object(object);
    for (var i = 0; i < length; i++) {
      var key = keys[i];
      if (attrs[key] !== obj[key] || !(key in obj)) return false;
    }
    return true;
  };


  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a === 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className !== toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, regular expressions, dates, and booleans are compared by value.
      case '[object RegExp]':
      // RegExps are coerced to strings for comparison (Note: '' + /a/i === '/a/i')
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return '' + a === '' + b;
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive.
        // Object(NaN) is equivalent to NaN
        if (+a !== +a) return +b !== +b;
        // An `egal` comparison is performed for other numeric values.
        return +a === 0 ? 1 / +a === 1 / b : +a === +b;
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a === +b;
    }

    var areArrays = className === '[object Array]';
    if (!areArrays) {
      if (typeof a != 'object' || typeof b != 'object') return false;

      // Objects with different constructors are not equivalent, but `Object`s or `Array`s
      // from different frames are.
      var aCtor = a.constructor, bCtor = b.constructor;
      if (aCtor !== bCtor && !(_.isFunction(aCtor) && aCtor instanceof aCtor &&
                               _.isFunction(bCtor) && bCtor instanceof bCtor)
                          && ('constructor' in a && 'constructor' in b)) {
        return false;
      }
    }
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.

    // Initializing stack of traversed objects.
    // It's done here since we only need them for objects and arrays comparison.
    aStack = aStack || [];
    bStack = bStack || [];
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] === a) return bStack[length] === b;
    }

    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);

    // Recursively compare objects and arrays.
    if (areArrays) {
      // Compare array lengths to determine if a deep comparison is necessary.
      length = a.length;
      if (length !== b.length) return false;
      // Deep compare the contents, ignoring non-numeric properties.
      while (length--) {
        if (!eq(a[length], b[length], aStack, bStack)) return false;
      }
    } else {
      // Deep compare objects.
      var keys = _.keys(a), key;
      length = keys.length;
      // Ensure that both objects contain the same number of properties before comparing deep equality.
      if (_.keys(b).length !== length) return false;
      while (length--) {
        // Deep compare each member
        key = keys[length];
        if (!(_.has(b, key) && eq(a[key], b[key], aStack, bStack))) return false;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return true;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (isArrayLike(obj) && (_.isArray(obj) || _.isString(obj) || _.isArguments(obj))) return obj.length === 0;
    return _.keys(obj).length === 0;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) === '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    var type = typeof obj;
    return type === 'function' || type === 'object' && !!obj;
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp, isError.
  _.each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp', 'Error'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) === '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE < 9), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return _.has(obj, 'callee');
    };
  }

  // Optimize `isFunction` if appropriate. Work around some typeof bugs in old v8,
  // IE 11 (#1621), and in Safari 8 (#1929).
  if (typeof /./ != 'function' && typeof Int8Array != 'object') {
    _.isFunction = function(obj) {
      return typeof obj == 'function' || false;
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj !== +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) === '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return obj != null && hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iteratees.
  _.identity = function(value) {
    return value;
  };

  // Predicate-generating functions. Often useful outside of Underscore.
  _.constant = function(value) {
    return function() {
      return value;
    };
  };

  _.noop = function(){};

  _.property = property;

  // Generates a function for a given object that returns a given property.
  _.propertyOf = function(obj) {
    return obj == null ? function(){} : function(key) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of
  // `key:value` pairs.
  _.matcher = _.matches = function(attrs) {
    attrs = _.extendOwn({}, attrs);
    return function(obj) {
      return _.isMatch(obj, attrs);
    };
  };

  // Run a function **n** times.
  _.times = function(n, iteratee, context) {
    var accum = Array(Math.max(0, n));
    iteratee = optimizeCb(iteratee, context, 1);
    for (var i = 0; i < n; i++) accum[i] = iteratee(i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() {
    return new Date().getTime();
  };

   // List of HTML entities for escaping.
  var escapeMap = {
    '&': '&amp;',
    '<': '&lt;',
    '>': '&gt;',
    '"': '&quot;',
    "'": '&#x27;',
    '`': '&#x60;'
  };
  var unescapeMap = _.invert(escapeMap);

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  var createEscaper = function(map) {
    var escaper = function(match) {
      return map[match];
    };
    // Regexes for identifying a key that needs to be escaped
    var source = '(?:' + _.keys(map).join('|') + ')';
    var testRegexp = RegExp(source);
    var replaceRegexp = RegExp(source, 'g');
    return function(string) {
      string = string == null ? '' : '' + string;
      return testRegexp.test(string) ? string.replace(replaceRegexp, escaper) : string;
    };
  };
  _.escape = createEscaper(escapeMap);
  _.unescape = createEscaper(unescapeMap);

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property, fallback) {
    var value = object == null ? void 0 : object[property];
    if (value === void 0) {
      value = fallback;
    }
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\u2028|\u2029/g;

  var escapeChar = function(match) {
    return '\\' + escapes[match];
  };

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  // NB: `oldSettings` only exists for backwards compatibility.
  _.template = function(text, settings, oldSettings) {
    if (!settings && oldSettings) settings = oldSettings;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset).replace(escaper, escapeChar);
      index = offset + match.length;

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      } else if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      } else if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }

      // Adobe VMs need the match returned to produce the correct offest.
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + 'return __p;\n';

    try {
      var render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled source as a convenience for precompilation.
    var argument = settings.variable || 'obj';
    template.source = 'function(' + argument + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function. Start chaining a wrapped Underscore object.
  _.chain = function(obj) {
    var instance = _(obj);
    instance._chain = true;
    return instance;
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(instance, obj) {
    return instance._chain ? _(obj).chain() : obj;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    _.each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result(this, func.apply(_, args));
      };
    });
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  _.each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name === 'shift' || name === 'splice') && obj.length === 0) delete obj[0];
      return result(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  _.each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result(this, method.apply(this._wrapped, arguments));
    };
  });

  // Extracts the result from a wrapped and chained object.
  _.prototype.value = function() {
    return this._wrapped;
  };

  // Provide unwrapping proxy for some methods used in engine operations
  // such as arithmetic and JSON stringification.
  _.prototype.valueOf = _.prototype.toJSON = _.prototype.value;

  _.prototype.toString = function() {
    return '' + this._wrapped;
  };

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (typeof define === 'function' && define.amd) {
    define('underscore', [], function() {
      return _;
    });
  }
}.call(this));

},{}],10:[function(require,module,exports){
var Artist, Vex, _,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Vex = require('vexflow');

_ = require('underscore');

Artist = (function() {
  var L, formatAndRender, getFingering, getScoreArticulationParts, getStrokeParts, makeBend, makeDuration, parseBool;

  Artist.DEBUG = false;

  L = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (Artist.DEBUG) {
      return typeof console !== "undefined" && console !== null ? console.log.apply(console, ["(Vex.Flow.Artist)"].concat(slice.call(args))) : void 0;
    }
  };

  Artist.NOLOGO = false;

  function Artist(x, y, width1, options) {
    this.x = x;
    this.y = y;
    this.width = width1;
    this.options = {
      font_face: "Arial",
      font_size: 10,
      font_style: null,
      bottom_spacing: 20 + (Artist.NOLOGO ? 0 : 10),
      tab_stave_lower_spacing: 10,
      note_stave_lower_spacing: 0,
      scale: 1.0
    };
    if (options != null) {
      _.extend(this.options, options);
    }
    this.reset();
  }

  Artist.prototype.reset = function() {
    this.tuning = new Vex.Flow.Tuning();
    this.key_manager = new Vex.Flow.KeyManager("C");
    this.music_api = new Vex.Flow.Music();
    this.customizations = {
      "font-size": this.options.font_size,
      "font-face": this.options.font_face,
      "font-style": this.options.font_style,
      "annotation-position": "bottom",
      "scale": this.options.scale,
      "width": this.width,
      "stave-distance": 0,
      "space": 0,
      "player": "false",
      "tempo": 120,
      "instrument": "acoustic_grand_piano",
      "accidentals": "standard",
      "tab-stems": "false",
      "tab-stem-direction": "up",
      "beam-rests": "true",
      "beam-stemlets": "true",
      "beam-middle-only": "false",
      "connector-space": 0
    };
    this.stavegroups = [];
    this.tab_articulations = [];
    this.stave_articulations = [];
    this.player_staves = [];
    this.last_y = this.y;
    this.current_duration = "q";
    this.current_clef = "treble";
    this.current_bends = {};
    this.current_octave_shift = 0;
    this.bend_start_index = null;
    this.bend_start_strings = null;
    this.rendered = false;
    return this.renderer_context = null;
  };

  Artist.prototype.attachPlayer = function(player) {
    if (!this.player) {
      return this.player = player;
    }
  };

  Artist.prototype.setOptions = function(options) {
    var k, v, valid_options;
    L("setOptions: ", options);
    valid_options = _.keys(this.customizations);
    for (k in options) {
      v = options[k];
      if (indexOf.call(valid_options, k) >= 0) {
        this.customizations[k] = v;
      } else {
        throw new Vex.RERR("ArtistError", "Invalid option '" + k + "'");
      }
    }
    this.last_y += parseInt(this.customizations.space, 10);
    if (this.customizations.player === "true") {
      return this.last_y += 1;
    }
  };

  Artist.prototype.getPlayerData = function() {
    return {
      staves: this.player_staves,
      context: this.renderer_context,
      scale: this.customizations.scale
    };
  };

  parseBool = function(str) {
    return str === "true";
  };

  formatAndRender = function(ctx, tab, score, text_notes, customizations, options) {
    var align_rests, beam_config, beams, format_stave, format_voices, formatter, i, j, l, len, len1, len2, m, multi_voice, notes, ref, ref1, score_stave, score_voices, stem_direction, tab_stave, tab_voices, text_stave, text_voices, voice;
    if (tab != null) {
      tab_stave = tab.stave;
    }
    if (score != null) {
      score_stave = score.stave;
    }
    tab_voices = [];
    score_voices = [];
    text_voices = [];
    beams = [];
    format_stave = null;
    text_stave = null;
    beam_config = {
      beam_rests: parseBool(customizations["beam-rests"]),
      show_stemlets: parseBool(customizations["beam-stemlets"]),
      beam_middle_only: parseBool(customizations["beam-middle-only"]),
      groups: options.beam_groups
    };
    if (tab != null) {
      multi_voice = tab.voices.length > 1 ? true : false;
      ref = tab.voices;
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        notes = ref[i];
        if (_.isEmpty(notes)) {
          continue;
        }
        _.each(notes, function(note) {
          return note.setStave(tab_stave);
        });
        voice = new Vex.Flow.Voice(Vex.Flow.TIME4_4).setMode(Vex.Flow.Voice.Mode.SOFT);
        voice.addTickables(notes);
        tab_voices.push(voice);
        if (customizations["tab-stems"] === "true") {
          if (multi_voice) {
            beam_config.stem_direction = i === 0 ? 1 : -1;
          } else {
            beam_config.stem_direction = customizations["tab-stem-direction"] === "down" ? -1 : 1;
          }
          beam_config.beam_rests = false;
          beams = beams.concat(Vex.Flow.Beam.generateBeams(voice.getTickables(), beam_config));
        }
      }
      format_stave = tab_stave;
      text_stave = tab_stave;
    }
    beam_config.beam_rests = parseBool(customizations["beam-rests"]);
    if (score != null) {
      multi_voice = score.voices.length > 1 ? true : false;
      ref1 = score.voices;
      for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
        notes = ref1[i];
        if (_.isEmpty(notes)) {
          continue;
        }
        stem_direction = i === 0 ? 1 : -1;
        _.each(notes, function(note) {
          return note.setStave(score_stave);
        });
        voice = new Vex.Flow.Voice(Vex.Flow.TIME4_4).setMode(Vex.Flow.Voice.Mode.SOFT);
        voice.addTickables(notes);
        score_voices.push(voice);
        if (multi_voice) {
          beam_config.stem_direction = stem_direction;
          beams = beams.concat(Vex.Flow.Beam.generateBeams(notes, beam_config));
        } else {
          beam_config.stem_direction = null;
          beams = beams.concat(Vex.Flow.Beam.generateBeams(notes, beam_config));
        }
      }
      format_stave = score_stave;
      text_stave = score_stave;
    }
    for (m = 0, len2 = text_notes.length; m < len2; m++) {
      notes = text_notes[m];
      if (_.isEmpty(notes)) {
        continue;
      }
      _.each(notes, function(voice) {
        return voice.setStave(text_stave);
      });
      voice = new Vex.Flow.Voice(Vex.Flow.TIME4_4).setMode(Vex.Flow.Voice.Mode.SOFT);
      voice.addTickables(notes);
      text_voices.push(voice);
    }
    if (format_stave != null) {
      format_voices = [];
      formatter = new Vex.Flow.Formatter();
      align_rests = false;
      if (tab != null) {
        if (!_.isEmpty(tab_voices)) {
          formatter.joinVoices(tab_voices);
        }
        format_voices = tab_voices;
      }
      if (score != null) {
        if (!_.isEmpty(score_voices)) {
          formatter.joinVoices(score_voices);
        }
        format_voices = format_voices.concat(score_voices);
        if (score_voices.length > 1) {
          align_rests = true;
        }
      }
      if (!_.isEmpty(text_notes) && !_.isEmpty(text_voices)) {
        formatter.joinVoices(text_voices);
        format_voices = format_voices.concat(text_voices);
      }
      if (!_.isEmpty(format_voices)) {
        formatter.formatToStave(format_voices, format_stave, {
          align_rests: align_rests
        });
      }
      if (tab != null) {
        _.each(tab_voices, function(voice) {
          return voice.draw(ctx, tab_stave);
        });
      }
      if (score != null) {
        _.each(score_voices, function(voice) {
          return voice.draw(ctx, score_stave);
        });
      }
      _.each(beams, function(beam) {
        return beam.setContext(ctx).draw();
      });
      if (!_.isEmpty(text_notes)) {
        _.each(text_voices, function(voice) {
          return voice.draw(ctx, text_stave);
        });
      }
      if ((tab != null) && (score != null)) {
        (new Vex.Flow.StaveConnector(score.stave, tab.stave)).setContext(ctx).draw();
      }
      if (score != null) {
        return score_voices;
      } else {
        return tab_voices;
      }
    }
  };

  Artist.prototype.render = function(renderer) {
    var LOGO, articulation, ctx, j, l, len, len1, len2, len3, m, o, ref, ref1, ref2, ref3, setBar, stave, stavegroup, staves, voices, width;
    L("Render: ", this.options);
    this.closeBends();
    renderer.resize(this.customizations.width * this.customizations.scale, (this.last_y + this.options.bottom_spacing) * this.customizations.scale);
    ctx = renderer.getContext();
    ctx.scale(this.customizations.scale, this.customizations.scale);
    ctx.clear();
    ctx.setFont(this.options.font_face, this.options.font_size, "");
    this.renderer_context = ctx;
    setBar = function(stave, notes) {
      var last_note;
      last_note = _.last(notes);
      if (last_note instanceof Vex.Flow.BarNote) {
        notes.pop();
        return stave.setEndBarType(last_note.getType());
      }
    };
    ref = this.stavegroups;
    for (j = 0, len = ref.length; j < len; j++) {
      stavegroup = ref[j];
      L("Rendering stavegroups.");
      staves = [];
      ref1 = stavegroup.staves;
      for (l = 0, len1 = ref1.length; l < len1; l++) {
        stave = ref1[l];
        L("Rendering staves.");
        if (stave.tab != null) {
          setBar(stave.tab, stave.tab_notes);
        }
        if (stave.note != null) {
          setBar(stave.note, stave.note_notes);
        }
        if (stave.tab != null) {
          stave.tab.setContext(ctx).draw();
        }
        if (stave.note != null) {
          stave.note.setContext(ctx).draw();
        }
        stave.tab_voices.push(stave.tab_notes);
        stave.note_voices.push(stave.note_notes);
        voices = formatAndRender(ctx, stave.tab != null ? {
          stave: stave.tab,
          voices: stave.tab_voices
        } : null, stave.note != null ? {
          stave: stave.note,
          voices: stave.note_voices
        } : null, stave.text_voices, this.customizations, {
          beam_groups: stave.beam_groups
        });
        staves.push(voices);
      }
    }
    this.player_staves.push(staves);
    L("Rendering tab articulations.");
    ref2 = this.tab_articulations;
    for (m = 0, len2 = ref2.length; m < len2; m++) {
      articulation = ref2[m];
      articulation.setContext(ctx).draw();
    }
    L("Rendering note articulations.");
    ref3 = this.stave_articulations;
    for (o = 0, len3 = ref3.length; o < len3; o++) {
      articulation = ref3[o];
      articulation.setContext(ctx).draw();
    }
    if (this.player != null) {
      if (this.customizations.player === "true") {
        this.player.setTempo(parseInt(this.customizations.tempo, 10));
        this.player.setInstrument(this.customizations.instrument);
        this.player.render();
      } else {
        this.player.removeControls();
      }
    }
    this.rendered = true;
    if (!Artist.NOLOGO) {
      LOGO = "vexflow.com";
      width = ctx.measureText(LOGO).width;
      ctx.save();
      ctx.setFont("Times", 10, "italic");
      ctx.fillText(LOGO, (this.customizations.width - width) / 2, this.last_y + 25);
      return ctx.restore();
    }
  };

  Artist.prototype.isRendered = function() {
    return this.rendered;
  };

  Artist.prototype.draw = function(renderer) {
    return this.render(renderer);
  };

  Artist.prototype.getNoteForFret = function(fret, string) {
    var accidental, new_note, new_octave, new_root, old_root, selected_note, spec, spec_props;
    spec = this.tuning.getNoteForFret(fret, string);
    spec_props = Vex.Flow.keyProperties(spec);
    selected_note = this.key_manager.selectNote(spec_props.key);
    accidental = null;
    switch (this.customizations.accidentals) {
      case "standard":
        if (selected_note.change) {
          accidental = selected_note.accidental != null ? selected_note.accidental : "n";
        }
        break;
      case "cautionary":
        if (selected_note.change) {
          accidental = selected_note.accidental != null ? selected_note.accidental : "n";
        } else {
          accidental = selected_note.accidental != null ? selected_note.accidental + "_c" : void 0;
        }
        break;
      default:
        throw new Vex.RERR("ArtistError", "Invalid value for option 'accidentals': " + this.customizations.accidentals);
    }
    new_note = selected_note.note;
    new_octave = spec_props.octave;
    old_root = this.music_api.getNoteParts(spec_props.key).root;
    new_root = this.music_api.getNoteParts(selected_note.note).root;
    if (new_root === "b" && old_root === "c") {
      new_octave--;
    } else if (new_root === "c" && old_root === "b") {
      new_octave++;
    }
    return [new_note, new_octave, accidental];
  };

  Artist.prototype.getNoteForABC = function(abc, string) {
    var accidental, key, octave;
    key = abc.key;
    octave = string;
    accidental = abc.accidental;
    if (abc.accidental_type != null) {
      accidental += "_" + abc.accidental_type;
    }
    return [key, octave, accidental];
  };

  Artist.prototype.addStaveNote = function(note_params) {
    var acc, index, j, len, new_accidental, params, parts, ref, stave_note, stave_notes;
    params = {
      is_rest: false,
      play_note: null
    };
    _.extend(params, note_params);
    stave_notes = _.last(_.last(this.stavegroups).staves).note_notes;
    stave_note = new Vex.Flow.StaveNote({
      keys: params.spec,
      duration: this.current_duration + (params.is_rest ? "r" : ""),
      clef: params.is_rest ? "treble" : this.current_clef,
      auto_stem: params.is_rest ? false : true
    });
    ref = params.accidentals;
    for (index = j = 0, len = ref.length; j < len; index = ++j) {
      acc = ref[index];
      if (acc != null) {
        parts = acc.split("_");
        new_accidental = new Vex.Flow.Accidental(parts[0]);
        if (parts.length > 1 && parts[1] === "c") {
          new_accidental.setAsCautionary();
        }
        stave_note.addAccidental(index, new_accidental);
      }
    }
    if (this.current_duration[this.current_duration.length - 1] === "d") {
      stave_note.addDotToAll();
    }
    if (params.play_note != null) {
      stave_note.setPlayNote(params.play_note);
    }
    return stave_notes.push(stave_note);
  };

  Artist.prototype.addTabNote = function(spec, play_note) {
    var new_tab_note, tab_notes;
    if (play_note == null) {
      play_note = null;
    }
    tab_notes = _.last(_.last(this.stavegroups).staves).tab_notes;
    new_tab_note = new Vex.Flow.TabNote({
      positions: spec,
      duration: this.current_duration
    }, this.customizations["tab-stems"] === "true");
    if (play_note != null) {
      new_tab_note.setPlayNote(play_note);
    }
    tab_notes.push(new_tab_note);
    if (this.current_duration[this.current_duration.length - 1] === "d") {
      return new_tab_note.addDot();
    }
  };

  makeDuration = function(time, dot) {
    return time + (dot ? "d" : "");
  };

  Artist.prototype.setDuration = function(time, dot) {
    var t;
    if (dot == null) {
      dot = false;
    }
    t = time.split(/\s+/);
    L("setDuration: ", t[0], dot);
    return this.current_duration = makeDuration(t[0], dot);
  };

  Artist.prototype.addBar = function(type) {
    var TYPE, bar_note, stave;
    L("addBar: ", type);
    this.closeBends();
    this.key_manager.reset();
    stave = _.last(_.last(this.stavegroups).staves);
    TYPE = Vex.Flow.Barline.type;
    type = (function() {
      switch (type) {
        case "single":
          return TYPE.SINGLE;
        case "double":
          return TYPE.DOUBLE;
        case "end":
          return TYPE.END;
        case "repeat-begin":
          return TYPE.REPEAT_BEGIN;
        case "repeat-end":
          return TYPE.REPEAT_END;
        case "repeat-both":
          return TYPE.REPEAT_BOTH;
        default:
          return TYPE.SINGLE;
      }
    })();
    bar_note = new Vex.Flow.BarNote().setType(type);
    stave.tab_notes.push(bar_note);
    if (stave.note != null) {
      return stave.note_notes.push(bar_note);
    }
  };

  makeBend = function(from_fret, to_fret) {
    var direction, text;
    direction = Vex.Flow.Bend.UP;
    text = "";
    if (parseInt(from_fret, 10) > parseInt(to_fret, 10)) {
      direction = Vex.Flow.Bend.DOWN;
    } else {
      text = (function() {
        switch (Math.abs(to_fret - from_fret)) {
          case 1:
            return "1/2";
          case 2:
            return "Full";
          case 3:
            return "1 1/2";
          default:
            return "Bend to " + to_fret;
        }
      })();
    }
    return {
      type: direction,
      text: text
    };
  };

  Artist.prototype.openBends = function(first_note, last_note, first_indices, last_indices) {
    var base, first_frets, from_fret, i, index, j, last_frets, last_index, len, results, start_indices, start_note, tab_notes, to_fret;
    L("openBends", first_note, last_note, first_indices, last_indices);
    tab_notes = _.last(_.last(this.stavegroups).staves).tab_notes;
    start_note = first_note;
    start_indices = first_indices;
    if (_.isEmpty(this.current_bends)) {
      this.bend_start_index = tab_notes.length - 2;
      this.bend_start_strings = first_indices;
    } else {
      start_note = tab_notes[this.bend_start_index];
      start_indices = this.bend_start_strings;
    }
    first_frets = start_note.getPositions();
    last_frets = last_note.getPositions();
    results = [];
    for (i = j = 0, len = start_indices.length; j < len; i = ++j) {
      index = start_indices[i];
      last_index = last_indices[i];
      from_fret = first_note.getPositions()[first_indices[i]];
      to_fret = last_frets[last_index];
      if ((base = this.current_bends)[index] == null) {
        base[index] = [];
      }
      results.push(this.current_bends[index].push(makeBend(from_fret.fret, to_fret.fret)));
    }
    return results;
  };

  Artist.prototype.closeBends = function(offset) {
    var bend, j, k, l, len, len1, phrase, ref, ref1, tab_note, tab_notes, v;
    if (offset == null) {
      offset = 1;
    }
    if (this.bend_start_index == null) {
      return;
    }
    L("closeBends(" + offset + ")");
    tab_notes = _.last(_.last(this.stavegroups).staves).tab_notes;
    ref = this.current_bends;
    for (k in ref) {
      v = ref[k];
      phrase = [];
      for (j = 0, len = v.length; j < len; j++) {
        bend = v[j];
        phrase.push(bend);
      }
      tab_notes[this.bend_start_index].addModifier(new Vex.Flow.Bend(null, null, phrase), k);
    }
    ref1 = tab_notes.slice(this.bend_start_index + 1, +((tab_notes.length - 2) + offset) + 1 || 9e9);
    for (l = 0, len1 = ref1.length; l < len1; l++) {
      tab_note = ref1[l];
      tab_note.setGhost(true);
    }
    this.current_bends = {};
    return this.bend_start_index = null;
  };

  Artist.prototype.makeTuplets = function(tuplets, notes) {
    var modifier, stave_notes, tab_modifier, tab_notes;
    L("makeTuplets", tuplets, notes);
    if (notes == null) {
      notes = tuplets;
    }
    if (!_.last(_.last(this.stavegroups).staves).note) {
      return;
    }
    stave_notes = _.last(_.last(this.stavegroups).staves).note_notes;
    tab_notes = _.last(_.last(this.stavegroups).staves).tab_notes;
    if (stave_notes.length < notes) {
      throw new Vex.RERR("ArtistError", "Not enough notes for tuplet");
    }
    modifier = new Vex.Flow.Tuplet(stave_notes.slice(stave_notes.length - notes), {
      num_notes: tuplets
    });
    this.stave_articulations.push(modifier);
    tab_modifier = new Vex.Flow.Tuplet(tab_notes.slice(tab_notes.length - notes), {
      num_notes: tuplets
    });
    if (this.customizations["tab-stems"] === "true") {
      return this.tab_articulations.push(tab_modifier);
    }
  };

  getFingering = function(text) {
    return text.match(/^\.fingering\/([^.]+)\./);
  };

  Artist.prototype.makeFingering = function(text) {
    var POS, badFingering, finger, fingering, fingers, j, len, modifier, note_number, number, p, parts, pieces, position;
    parts = getFingering(text);
    POS = Vex.Flow.Modifier.Position;
    fingers = [];
    fingering = [];
    if (parts != null) {
      fingers = (function() {
        var j, len, ref, results;
        ref = parts[1].split(/-/);
        results = [];
        for (j = 0, len = ref.length; j < len; j++) {
          p = ref[j];
          results.push(p.trim());
        }
        return results;
      })();
    } else {
      return null;
    }
    badFingering = function() {
      return new Vex.RERR("ArtistError", "Bad fingering: " + parts[1]);
    };
    for (j = 0, len = fingers.length; j < len; j++) {
      finger = fingers[j];
      pieces = finger.match(/(\d+):([ablr]):([fs]):([^-.]+)/);
      if (pieces == null) {
        throw badFingering();
      }
      note_number = parseInt(pieces[1], 10) - 1;
      position = POS.RIGHT;
      switch (pieces[2]) {
        case "l":
          position = POS.LEFT;
          break;
        case "r":
          position = POS.RIGHT;
          break;
        case "a":
          position = POS.ABOVE;
          break;
        case "b":
          position = POS.BELOW;
      }
      modifier = null;
      number = pieces[4];
      switch (pieces[3]) {
        case "s":
          modifier = new Vex.Flow.StringNumber(number).setPosition(position);
          break;
        case "f":
          modifier = new Vex.Flow.FretHandFinger(number).setPosition(position);
      }
      fingering.push({
        num: note_number,
        modifier: modifier
      });
    }
    return fingering;
  };

  getStrokeParts = function(text) {
    return text.match(/^\.stroke\/([^.]+)\./);
  };

  Artist.prototype.makeStroke = function(text) {
    var TYPE, parts, type;
    parts = getStrokeParts(text);
    TYPE = Vex.Flow.Stroke.Type;
    type = null;
    if (parts != null) {
      switch (parts[1]) {
        case "bu":
          type = TYPE.BRUSH_UP;
          break;
        case "bd":
          type = TYPE.BRUSH_DOWN;
          break;
        case "ru":
          type = TYPE.ROLL_UP;
          break;
        case "rd":
          type = TYPE.ROLL_DOWN;
          break;
        case "qu":
          type = TYPE.RASQUEDO_UP;
          break;
        case "qd":
          type = TYPE.RASQUEDO_DOWN;
          break;
        default:
          throw new Vex.RERR("ArtistError", "Invalid stroke type: " + parts[1]);
      }
      return new Vex.Flow.Stroke(type);
    } else {
      return null;
    }
  };

  getScoreArticulationParts = function(text) {
    return text.match(/^\.(a[^\/]*)\/(t|b)[^.]*\./);
  };

  Artist.prototype.makeScoreArticulation = function(text) {
    var POSTYPE, parts, pos, position, type;
    parts = getScoreArticulationParts(text);
    if (parts != null) {
      type = parts[1];
      position = parts[2];
      POSTYPE = Vex.Flow.Modifier.Position;
      pos = position === "t" ? POSTYPE.ABOVE : POSTYPE.BELOW;
      return new Vex.Flow.Articulation(type).setPosition(pos);
    } else {
      return null;
    }
  };

  Artist.prototype.makeAnnotation = function(text) {
    var VJUST, aposition, default_vjust, font_face, font_size, font_style, just, makeIt, parts;
    font_face = this.customizations["font-face"];
    font_size = this.customizations["font-size"];
    font_style = this.customizations["font-style"];
    aposition = this.customizations["annotation-position"];
    VJUST = Vex.Flow.Annotation.VerticalJustify;
    default_vjust = aposition === "top" ? VJUST.TOP : VJUST.BOTTOM;
    makeIt = function(text, just) {
      if (just == null) {
        just = default_vjust;
      }
      return new Vex.Flow.Annotation(text).setFont(font_face, font_size, font_style).setVerticalJustification(just);
    };
    parts = text.match(/^\.([^-]*)-([^-]*)-([^.]*)\.(.*)/);
    if (parts != null) {
      font_face = parts[1];
      font_size = parts[2];
      font_style = parts[3];
      text = parts[4];
      if (text) {
        return makeIt(text);
      } else {
        return null;
      }
    }
    parts = text.match(/^\.([^.]*)\.(.*)/);
    if (parts != null) {
      just = default_vjust;
      text = parts[2];
      switch (parts[1]) {
        case "big":
          font_style = "bold";
          font_size = "14";
          break;
        case "italic":
        case "italics":
          font_face = "Times";
          font_style = "italic";
          break;
        case "medium":
          font_size = "12";
          break;
        case "top":
          just = VJUST.TOP;
          this.customizations["annotation-position"] = "top";
          break;
        case "bottom":
          just = VJUST.BOTTOM;
          this.customizations["annotation-position"] = "bottom";
      }
      if (text) {
        return makeIt(text, just);
      } else {
        return null;
      }
    }
    return makeIt(text);
  };

  Artist.prototype.addAnnotations = function(annotations) {
    var annotation, e, error, fingering, fingerings, i, j, l, len, len1, len2, m, note, ref, ref1, ref2, results, score_articulation, stave, stave_notes, stroke, tab_note, tab_notes;
    stave = _.last(_.last(this.stavegroups).staves);
    stave_notes = stave.note_notes;
    tab_notes = stave.tab_notes;
    if (annotations.length > tab_notes.length) {
      throw new Vex.RERR("ArtistError", "More annotations than note elements");
    }
    if (stave.tab) {
      ref = tab_notes.slice(tab_notes.length - annotations.length);
      for (i = j = 0, len = ref.length; j < len; i = ++j) {
        tab_note = ref[i];
        if (getScoreArticulationParts(annotations[i])) {
          score_articulation = this.makeScoreArticulation(annotations[i]);
          tab_note.addModifier(score_articulation, 0);
        } else if (getStrokeParts(annotations[i])) {
          stroke = this.makeStroke(annotations[i]);
          tab_note.addModifier(stroke, 0);
        } else {
          annotation = this.makeAnnotation(annotations[i]);
          if (annotation) {
            tab_note.addModifier(this.makeAnnotation(annotations[i]), 0);
          }
        }
      }
    } else {
      ref1 = stave_notes.slice(stave_notes.length - annotations.length);
      for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
        note = ref1[i];
        if (!getScoreArticulationParts(annotations[i])) {
          annotation = this.makeAnnotation(annotations[i]);
          if (annotation) {
            note.addAnnotation(0, this.makeAnnotation(annotations[i]));
          }
        }
      }
    }
    if (stave.note) {
      ref2 = stave_notes.slice(stave_notes.length - annotations.length);
      results = [];
      for (i = m = 0, len2 = ref2.length; m < len2; i = ++m) {
        note = ref2[i];
        score_articulation = this.makeScoreArticulation(annotations[i]);
        if (score_articulation != null) {
          note.addArticulation(0, score_articulation);
        }
        stroke = this.makeStroke(annotations[i]);
        if (stroke != null) {
          note.addStroke(0, stroke);
        }
        fingerings = this.makeFingering(annotations[i]);
        if (fingerings != null) {
          try {
            results.push((function() {
              var len3, o, results1;
              results1 = [];
              for (o = 0, len3 = fingerings.length; o < len3; o++) {
                fingering = fingerings[o];
                results1.push(note.addModifier(fingering.num, fingering.modifier));
              }
              return results1;
            })());
          } catch (error) {
            e = error;
            throw new Vex.RERR("ArtistError", "Bad note number in fingering: " + annotations[i]);
          }
        } else {
          results.push(void 0);
        }
      }
      return results;
    }
  };

  Artist.prototype.addTabArticulation = function(type, first_note, last_note, first_indices, last_indices) {
    var articulation;
    L("addTabArticulations: ", type, first_note, last_note, first_indices, last_indices);
    if (type === "t") {
      last_note.addModifier(new Vex.Flow.Annotation("T").setVerticalJustification(Vex.Flow.Annotation.VerticalJustify.BOTTOM));
    }
    if (_.isEmpty(first_indices) && _.isEmpty(last_indices)) {
      return;
    }
    articulation = null;
    if (type === "s") {
      articulation = new Vex.Flow.TabSlide({
        first_note: first_note,
        last_note: last_note,
        first_indices: first_indices,
        last_indices: last_indices
      });
    }
    if (type === "h" || type === "p") {
      articulation = new Vex.Flow.TabTie({
        first_note: first_note,
        last_note: last_note,
        first_indices: first_indices,
        last_indices: last_indices
      }, type.toUpperCase());
    }
    if (type === "T" || type === "t") {
      articulation = new Vex.Flow.TabTie({
        first_note: first_note,
        last_note: last_note,
        first_indices: first_indices,
        last_indices: last_indices
      }, " ");
    }
    if (type === "b") {
      this.openBends(first_note, last_note, first_indices, last_indices);
    }
    if (articulation != null) {
      return this.tab_articulations.push(articulation);
    }
  };

  Artist.prototype.addStaveArticulation = function(type, first_note, last_note, first_indices, last_indices) {
    var articulation;
    L("addStaveArticulations: ", type, first_note, last_note, first_indices, last_indices);
    articulation = null;
    if (type === "b" || type === "s" || type === "h" || type === "p" || type === "t" || type === "T") {
      articulation = new Vex.Flow.StaveTie({
        first_note: first_note,
        last_note: last_note,
        first_indices: first_indices,
        last_indices: last_indices
      });
    }
    if (articulation != null) {
      return this.stave_articulations.push(articulation);
    }
  };

  Artist.prototype.getPreviousNoteIndex = function() {
    var index, note, tab_notes;
    tab_notes = _.last(_.last(this.stavegroups).staves).tab_notes;
    index = 2;
    while (index <= tab_notes.length) {
      note = tab_notes[tab_notes.length - index];
      if (note instanceof Vex.Flow.TabNote) {
        return tab_notes.length - index;
      }
      index++;
    }
    return -1;
  };

  Artist.prototype.addDecorator = function(decorator) {
    var modifier, ref, score_modifier, score_notes, stave, tab_notes;
    L("addDecorator: ", decorator);
    if (decorator == null) {
      return;
    }
    stave = _.last(_.last(this.stavegroups).staves);
    tab_notes = stave.tab_notes;
    score_notes = stave.note_notes;
    modifier = null;
    score_modifier = null;
    if (decorator === "v") {
      modifier = new Vex.Flow.Vibrato();
    }
    if (decorator === "V") {
      modifier = new Vex.Flow.Vibrato().setHarsh(true);
    }
    if (decorator === "u") {
      modifier = new Vex.Flow.Articulation("a|").setPosition(Vex.Flow.Modifier.Position.BOTTOM);
      score_modifier = new Vex.Flow.Articulation("a|").setPosition(Vex.Flow.Modifier.Position.BOTTOM);
    }
    if (decorator === "d") {
      modifier = new Vex.Flow.Articulation("am").setPosition(Vex.Flow.Modifier.Position.BOTTOM);
      score_modifier = new Vex.Flow.Articulation("am").setPosition(Vex.Flow.Modifier.Position.BOTTOM);
    }
    if (modifier != null) {
      _.last(tab_notes).addModifier(modifier, 0);
    }
    if (score_modifier != null) {
      return (ref = _.last(score_notes)) != null ? ref.addArticulation(0, score_modifier) : void 0;
    }
  };

  Artist.prototype.addArticulations = function(articulations) {
    var art, current_indices, current_tab_note, has_bends, i, indices, j, len, n, pos, prev_index, prev_indices, prev_tab_note, ref, stave, stave_notes, tab_notes, this_strings, valid_articulation, valid_strings;
    L("addArticulations: ", articulations);
    stave = _.last(_.last(this.stavegroups).staves);
    tab_notes = stave.tab_notes;
    stave_notes = stave.note_notes;
    if (_.isEmpty(tab_notes) || _.isEmpty(articulations)) {
      this.closeBends(0);
      return;
    }
    current_tab_note = _.last(tab_notes);
    has_bends = false;
    ref = ["b", "s", "h", "p", "t", "T", "v", "V"];
    for (j = 0, len = ref.length; j < len; j++) {
      valid_articulation = ref[j];
      indices = (function() {
        var l, len1, results;
        results = [];
        for (i = l = 0, len1 = articulations.length; l < len1; i = ++l) {
          art = articulations[i];
          if ((art != null) && art === valid_articulation) {
            results.push(i);
          }
        }
        return results;
      })();
      if (_.isEmpty(indices)) {
        continue;
      }
      if (valid_articulation === "b") {
        has_bends = true;
      }
      prev_index = this.getPreviousNoteIndex();
      if (prev_index === -1) {
        prev_tab_note = null;
        prev_indices = null;
      } else {
        prev_tab_note = tab_notes[prev_index];
        this_strings = (function() {
          var l, len1, ref1, results;
          ref1 = current_tab_note.getPositions();
          results = [];
          for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
            n = ref1[i];
            if (indexOf.call(indices, i) >= 0) {
              results.push(n.str);
            }
          }
          return results;
        })();
        valid_strings = (function() {
          var l, len1, ref1, ref2, results;
          ref1 = prev_tab_note.getPositions();
          results = [];
          for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
            pos = ref1[i];
            if (ref2 = pos.str, indexOf.call(this_strings, ref2) >= 0) {
              results.push(pos.str);
            }
          }
          return results;
        })();
        prev_indices = (function() {
          var l, len1, ref1, ref2, results;
          ref1 = prev_tab_note.getPositions();
          results = [];
          for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
            n = ref1[i];
            if (ref2 = n.str, indexOf.call(valid_strings, ref2) >= 0) {
              results.push(i);
            }
          }
          return results;
        })();
        current_indices = (function() {
          var l, len1, ref1, ref2, results;
          ref1 = current_tab_note.getPositions();
          results = [];
          for (i = l = 0, len1 = ref1.length; l < len1; i = ++l) {
            n = ref1[i];
            if (ref2 = n.str, indexOf.call(valid_strings, ref2) >= 0) {
              results.push(i);
            }
          }
          return results;
        })();
      }
      if (stave.tab != null) {
        this.addTabArticulation(valid_articulation, prev_tab_note, current_tab_note, prev_indices, current_indices);
      }
      if (stave.note != null) {
        this.addStaveArticulation(valid_articulation, stave_notes[prev_index], _.last(stave_notes), prev_indices, current_indices);
      }
    }
    if (!has_bends) {
      return this.closeBends(0);
    }
  };

  Artist.prototype.addRest = function(params) {
    var position, tab_note, tab_notes;
    L("addRest: ", params);
    this.closeBends();
    if (params["position"] === 0) {
      this.addStaveNote({
        spec: ["r/4"],
        accidentals: [],
        is_rest: true
      });
    } else {
      position = this.tuning.getNoteForFret((parseInt(params["position"], 10) + 5) * 2, 6);
      this.addStaveNote({
        spec: [position],
        accidentals: [],
        is_rest: true
      });
    }
    tab_notes = _.last(_.last(this.stavegroups).staves).tab_notes;
    if (this.customizations["tab-stems"] === "true") {
      tab_note = new Vex.Flow.StaveNote({
        keys: [position || "r/4"],
        duration: this.current_duration + "r",
        clef: "treble",
        auto_stem: false
      });
      if (this.current_duration[this.current_duration.length - 1] === "d") {
        tab_note.addDot(0);
      }
      return tab_notes.push(tab_note);
    } else {
      return tab_notes.push(new Vex.Flow.GhostNote(this.current_duration));
    }
  };

  Artist.prototype.addChord = function(chord, chord_articulation, chord_decorator) {
    var acc, accidental, accidentals, art, articulations, current_duration, current_position, current_string, decorators, durations, i, j, l, len, len1, m, new_note, new_octave, note, num, num_notes, octave, play_note, play_notes, play_octave, ref, ref1, ref2, ref3, saved_duration, spec, specs, stave, tab_specs;
    if (_.isEmpty(chord)) {
      return;
    }
    L("addChord: ", chord);
    stave = _.last(_.last(this.stavegroups).staves);
    L("stave in addChord.", stave);
    specs = [];
    play_notes = [];
    accidentals = [];
    articulations = [];
    decorators = [];
    tab_specs = [];
    durations = [];
    num_notes = 0;
    current_string = _.first(chord).string;
    current_position = 0;
    for (j = 0, len = chord.length; j < len; j++) {
      note = chord[j];
      num_notes++;
      if ((note.abc != null) || note.string !== current_string) {
        current_position = 0;
        current_string = note.string;
      }
      if (specs[current_position] == null) {
        specs[current_position] = [];
        play_notes[current_position] = [];
        accidentals[current_position] = [];
        tab_specs[current_position] = [];
        articulations[current_position] = [];
        decorators[current_position] = [];
      }
      ref = [null, null, null], new_note = ref[0], new_octave = ref[1], accidental = ref[2];
      play_note = null;
      if (note.abc != null) {
        octave = note.octave != null ? note.octave : note.string;
        ref1 = this.getNoteForABC(note.abc, octave), new_note = ref1[0], new_octave = ref1[1], accidental = ref1[2];
        if (accidental != null) {
          acc = accidental.split("_")[0];
        } else {
          acc = "";
        }
        play_note = "" + new_note + acc;
        if (note.fret == null) {
          note.fret = 'X';
        }
      } else if (note.fret != null) {
        ref2 = this.getNoteForFret(note.fret, note.string), new_note = ref2[0], new_octave = ref2[1], accidental = ref2[2];
        play_note = this.tuning.getNoteForFret(note.fret, note.string).split("/")[0];
      } else {
        throw new Vex.RERR("ArtistError", "No note specified");
      }
      play_octave = parseInt(new_octave, 10) + this.current_octave_shift;
      current_duration = note.time != null ? {
        time: note.time,
        dot: note.dot
      } : null;
      specs[current_position].push(new_note + "/" + new_octave);
      play_notes[current_position].push(play_note + "/" + play_octave);
      accidentals[current_position].push(accidental);
      tab_specs[current_position].push({
        fret: note.fret,
        str: note.string
      });
      if (note.articulation != null) {
        articulations[current_position].push(note.articulation);
      }
      durations[current_position] = current_duration;
      if (note.decorator != null) {
        decorators[current_position] = note.decorator;
      }
      current_position++;
    }
    for (i = l = 0, len1 = specs.length; l < len1; i = ++l) {
      spec = specs[i];
      saved_duration = this.current_duration;
      if (durations[i] != null) {
        this.setDuration(durations[i].time, durations[i].dot);
      }
      this.addTabNote(tab_specs[i], play_notes[i]);
      if (stave.note != null) {
        this.addStaveNote({
          spec: spec,
          accidentals: accidentals[i],
          play_note: play_notes[i]
        });
      }
      this.addArticulations(articulations[i]);
      if (decorators[i] != null) {
        this.addDecorator(decorators[i]);
      }
    }
    if (chord_articulation != null) {
      art = [];
      for (num = m = 1, ref3 = num_notes; 1 <= ref3 ? m <= ref3 : m >= ref3; num = 1 <= ref3 ? ++m : --m) {
        art.push(chord_articulation);
      }
      this.addArticulations(art);
    }
    if (chord_decorator != null) {
      return this.addDecorator(chord_decorator);
    }
  };

  Artist.prototype.addNote = function(note) {
    return this.addChord([note]);
  };

  Artist.prototype.addTextVoice = function() {
    return _.last(_.last(this.stavegroups).staves).text_voices.push([]);
  };

  Artist.prototype.setTextFont = function(font) {
    var parts;
    if (font != null) {
      parts = font.match(/([^-]*)-([^-]*)-([^.]*)/);
      if (parts != null) {
        this.customizations["font-face"] = parts[1];
        this.customizations["font-size"] = parseInt(parts[2], 10);
        return this.customizations["font-style"] = parts[3];
      }
    }
  };

  Artist.prototype.addTextNote = function(text, position, justification, smooth, ignore_ticks) {
    var duration, font_face, font_size, font_style, just, note, struct, voices;
    if (position == null) {
      position = 0;
    }
    if (justification == null) {
      justification = "center";
    }
    if (smooth == null) {
      smooth = true;
    }
    if (ignore_ticks == null) {
      ignore_ticks = false;
    }
    voices = _.last(_.last(this.stavegroups).staves).text_voices;
    if (_.isEmpty(voices)) {
      throw new Vex.RERR("ArtistError", "Can't add text note without text voice");
    }
    font_face = this.customizations["font-face"];
    font_size = this.customizations["font-size"];
    font_style = this.customizations["font-style"];
    just = (function() {
      switch (justification) {
        case "center":
          return Vex.Flow.TextNote.Justification.CENTER;
        case "left":
          return Vex.Flow.TextNote.Justification.LEFT;
        case "right":
          return Vex.Flow.TextNote.Justification.RIGHT;
        default:
          return Vex.Flow.TextNote.Justification.CENTER;
      }
    })();
    duration = ignore_ticks ? "b" : this.current_duration;
    struct = {
      text: text,
      duration: duration,
      smooth: smooth,
      ignore_ticks: ignore_ticks,
      font: {
        family: font_face,
        size: font_size,
        weight: font_style
      }
    };
    if (text[0] === "#") {
      struct.glyph = text.slice(1);
    }
    note = new Vex.Flow.TextNote(struct).setLine(position).setJustification(just);
    return _.last(voices).push(note);
  };

  Artist.prototype.addVoice = function(options) {
    var stave;
    this.closeBends();
    stave = _.last(_.last(this.stavegroups).staves);
    if (stave == null) {
      return this.addStave(options);
    }
    if (!_.isEmpty(stave.tab_notes)) {
      stave.tab_voices.push(stave.tab_notes);
      stave.tab_notes = [];
    }
    if (!_.isEmpty(stave.note_notes)) {
      stave.note_voices.push(stave.note_notes);
      return stave.note_notes = [];
    }
  };

  Artist.prototype.addStaveGroup = function() {
    this.stavegroups.push({
      staves: []
    });
    L("addStaveGroup");
  };

  Artist.prototype.staveGroupsLength = function() {
    return this.stavegroups.length;
  };

  Artist.prototype.getStaveGroup = function(i) {
    return this.stavegroups[i];
  };

  Artist.prototype.addStave = function(stavegroup_index, element, options) {
    var beam_groups, note_stave, opts, start_x, tab_stave, tabstave_start_x;
    opts = {
      tuning: "standard",
      clef: "treble",
      key: "C",
      notation: element === "tabstave" ? "false" : "true",
      tablature: element === "stave" ? "false" : "true",
      strings: 6
    };
    _.extend(opts, options);
    L("addStave: ", element, opts);
    tab_stave = null;
    note_stave = null;
    start_x = this.x + this.customizations["connector-space"];
    tabstave_start_x = 40;
    if (opts.notation === "true") {
      note_stave = new Vex.Flow.Stave(start_x, this.last_y, this.customizations.width - 20);
      if (opts.clef !== "none") {
        note_stave.addClef(opts.clef);
      }
      note_stave.addKeySignature(opts.key);
      if (opts.time != null) {
        note_stave.addTimeSignature(opts.time);
      }
      this.last_y += note_stave.getHeight() + this.options.note_stave_lower_spacing + parseInt(this.customizations["stave-distance"], 10);
      tabstave_start_x = note_stave.getNoteStartX();
      this.current_clef = opts.clef === "none" ? "treble" : opts.clef;
    }
    if (opts.tablature === "true") {
      tab_stave = new Vex.Flow.TabStave(start_x, this.last_y, this.customizations.width - 20).setNumLines(opts.strings);
      if (opts.clef !== "none") {
        tab_stave.addTabGlyph();
      }
      tab_stave.setNoteStartX(tabstave_start_x);
      this.last_y += tab_stave.getHeight() + this.options.tab_stave_lower_spacing;
    }
    this.closeBends();
    beam_groups = Vex.Flow.Beam.getDefaultBeamGroups(opts.time);
    this.getStaveGroup(stavegroup_index).staves.push({
      tab: tab_stave,
      note: note_stave,
      tab_voices: [],
      note_voices: [],
      tab_notes: [],
      note_notes: [],
      text_voices: [],
      beam_groups: beam_groups
    });
    this.tuning.setTuning(opts.tuning);
    this.key_manager.setKey(opts.key);
  };

  Artist.prototype.runCommand = function(line, _l, _c) {
    var words;
    if (_l == null) {
      _l = 0;
    }
    if (_c == null) {
      _c = 0;
    }
    L("runCommand: ", line);
    words = line.split(/\s+/);
    switch (words[0]) {
      case "octave-shift":
        this.current_octave_shift = parseInt(words[1], 10);
        return L("Octave shift: ", this.current_octave_shift);
      default:
        throw new Vex.RERR("ArtistError", "Invalid command '" + words[0] + "' at line " + _l + " column " + _c);
    }
  };

  return Artist;

})();

module.exports = Artist;


},{"underscore":9,"vexflow":1}],11:[function(require,module,exports){
var Artist, Player, Vex, VexTab;

Vex = require('vexflow');

Artist = require('./artist.coffee');

VexTab = require('./vextab.coffee');

Player = require('./player.coffee');

module.exports = {
  Artist: Artist,
  VexTab: VexTab,
  Vex: Vex,
  Player: Player
};


},{"./artist.coffee":10,"./player.coffee":12,"./vextab.coffee":13,"vexflow":1}],12:[function(require,module,exports){
var $, Vex, _, paper,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Vex = require('vexflow');

_ = require('underscore');

$ = require('jquery');

paper = require('paper');

Vex.Flow.Player = (function() {
  var Fraction, INSTRUMENTS, L, RESOLUTION, drawDot, getOverlay, noteValues;

  Player.DEBUG = false;

  Player.INSTRUMENTS_LOADED = {};

  L = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (Vex.Flow.Player.DEBUG) {
      return typeof console !== "undefined" && console !== null ? console.log.apply(console, ["(Vex.Flow.Player)"].concat(slice.call(args))) : void 0;
    }
  };

  Fraction = Vex.Flow.Fraction;

  RESOLUTION = Vex.Flow.RESOLUTION;

  noteValues = Vex.Flow.Music.noteValues;

  drawDot = Vex.drawDot;

  INSTRUMENTS = {
    "acoustic_grand_piano": 0,
    "acoustic_guitar_nylon": 24,
    "acoustic_guitar_steel": 25,
    "electric_guitar_jazz": 26,
    "distortion_guitar": 30,
    "electric_bass_finger": 33,
    "electric_bass_pick": 34,
    "trumpet": 56,
    "brass_section": 61,
    "soprano_sax": 64,
    "alto_sax": 65,
    "tenor_sax": 66,
    "baritone_sax": 67,
    "flute": 73,
    "synth_drum": 118
  };

  function Player(artist1, options) {
    this.artist = artist1;
    L("Initializing player: ", options);
    this.options = {
      instrument: "acoustic_grand_piano",
      tempo: 120,
      show_controls: true,
      soundfont_url: "../soundfont/",
      overlay_class: "vextab-player"
    };
    if (options != null) {
      _.extend(this.options, options);
    }
    L("Using soundfonts in: " + this.options.soundfont_url);
    this.interval_id = null;
    this.paper = null;
    this.reset();
  }

  Player.prototype.setArtist = function(artist) {
    this.artist = artist;
    return this.reset();
  };

  Player.prototype.setTempo = function(tempo) {
    L("New tempo: ", tempo);
    this.options.tempo = tempo;
    return this.reset();
  };

  Player.prototype.setInstrument = function(instrument) {
    L("New instrument: ", instrument);
    if (indexOf.call(_.keys(INSTRUMENTS), instrument) < 0) {
      throw new Vex.RERR("PlayerError", "Invalid instrument: " + instrument);
    }
    this.options.instrument = instrument;
    return this.reset();
  };

  Player.prototype.reset = function() {
    this.artist.attachPlayer(this);
    this.tick_notes = {};
    this.all_ticks = [];
    this.tpm = this.options.tempo * (RESOLUTION / 4);
    this.refresh_rate = 25;
    this.ticks_per_refresh = this.tpm / (60 * (1000 / this.refresh_rate));
    this.total_ticks = 0;
    if (this.marker != null) {
      this.marker.remove();
      this.marker = null;
    }
    return this.stop();
  };

  getOverlay = function(context, scale, overlay_class) {
    var canvas, ctx, height, overlay, ps, width;
    canvas = context.canvas;
    height = canvas.height;
    width = canvas.width;
    overlay = $('<canvas>');
    overlay.css("position", "absolute");
    overlay.css("left", 0);
    overlay.css("top", 0);
    overlay.addClass(overlay_class);
    $(canvas).after(overlay);
    ctx = Vex.Flow.Renderer.getCanvasContext(overlay.get(0), width, height);
    ctx.scale(scale, scale);
    ps = new paper.PaperScope();
    ps.setup(overlay.get(0));
    return {
      paper: ps,
      canvas: overlay.get(0)
    };
  };

  Player.prototype.removeControls = function() {
    if (this.play_button != null) {
      this.play_button.remove();
    }
    if (this.stop_button != null) {
      this.stop_button.remove();
    }
    if (this.paper != null) {
      return this.paper.view.draw();
    }
  };

  Player.prototype.render = function() {
    var abs_tick, data, i, j, k, key, l, len, len1, len2, len3, m, max_voice_tick, note, overlay, ref, stave, staves, total_ticks, total_voice_ticks, voice, voice_group;
    this.reset();
    data = this.artist.getPlayerData();
    this.scale = data.scale;
    if (!this.paper) {
      overlay = getOverlay(data.context, data.scale, this.options.overlay_class);
      this.paper = overlay.paper;
    }
    this.marker = new this.paper.Path.Rectangle(0, 0, 13, 85);
    this.loading_message = new this.paper.PointText(35, 12);
    if (this.options.show_controls) {
      this.play_button = new this.paper.Path.RegularPolygon(new this.paper.Point(25, 10), 3, 7, 7);
      this.play_button.fillColor = '#396';
      this.play_button.opacity = 0.8;
      this.play_button.rotate(90);
      this.play_button.onMouseUp = (function(_this) {
        return function(event) {
          return _this.play();
        };
      })(this);
      this.stop_button = new this.paper.Path.Rectangle(3, 3, 10, 10);
      this.stop_button.fillColor = '#396';
      this.stop_button.opacity = 0.8;
      this.stop_button.onMouseUp = (function(_this) {
        return function(event) {
          return _this.stop();
        };
      })(this);
    }
    this.paper.view.draw();
    staves = data.staves;
    total_ticks = new Fraction(0, 1);
    for (j = 0, len = staves.length; j < len; j++) {
      stave = staves[j];
      max_voice_tick = new Fraction(0, 1);
      for (k = 0, len1 = stave.length; k < len1; k++) {
        voice_group = stave[k];
        total_voice_ticks = new Fraction(0, 1);
        for (i = l = 0, len2 = voice_group.length; l < len2; i = ++l) {
          voice = voice_group[i];
          ref = voice.getTickables();
          for (m = 0, len3 = ref.length; m < len3; m++) {
            note = ref[m];
            if (!note.shouldIgnoreTicks()) {
              abs_tick = total_ticks.clone();
              abs_tick.add(total_voice_ticks);
              abs_tick.simplify();
              key = abs_tick.toString();
              if (_.has(this.tick_notes, key)) {
                this.tick_notes[key].notes.push(note);
              } else {
                this.tick_notes[key] = {
                  tick: abs_tick,
                  value: abs_tick.value(),
                  notes: [note]
                };
              }
              total_voice_ticks.add(note.getTicks());
            }
          }
        }
        if (total_voice_ticks.value() > max_voice_tick.value()) {
          max_voice_tick.copy(total_voice_ticks);
        }
      }
      total_ticks.add(max_voice_tick);
    }
    this.all_ticks = _.sortBy(_.values(this.tick_notes), function(tick) {
      return tick.value;
    });
    this.total_ticks = _.last(this.all_ticks);
    return L(this.all_ticks);
  };

  Player.prototype.updateMarker = function(x, y) {
    this.marker.fillColor = '#369';
    this.marker.opacity = 0.2;
    this.marker.setPosition(new this.paper.Point(x * this.scale, y * this.scale));
    return this.paper.view.draw();
  };

  Player.prototype.playNote = function(notes) {
    var duration, j, key, keys, len, midi_note, note, note_value, octave, results, x, y;
    L("(" + this.current_ticks + ") playNote: ", notes);
    results = [];
    for (j = 0, len = notes.length; j < len; j++) {
      note = notes[j];
      x = note.getAbsoluteX() + 4;
      y = note.getStave().getYForLine(2);
      if (this.paper != null) {
        this.updateMarker(x, y);
      }
      if (note.isRest()) {
        continue;
      }
      keys = note.getPlayNote();
      duration = note.getTicks().value() / (this.tpm / 60);
      results.push((function() {
        var k, len1, ref, results1;
        results1 = [];
        for (k = 0, len1 = keys.length; k < len1; k++) {
          key = keys[k];
          ref = key.split("/"), note = ref[0], octave = ref[1];
          note = note.trim().toLowerCase();
          note_value = noteValues[note];
          if (note_value == null) {
            continue;
          }
          midi_note = (24 + (octave * 12)) + noteValues[note].int_val;
          MIDI.noteOn(0, midi_note, 127, 0);
          results1.push(MIDI.noteOff(0, midi_note, duration));
        }
        return results1;
      })());
    }
    return results;
  };

  Player.prototype.refresh = function() {
    if (this.done) {
      this.stop();
      return;
    }
    this.current_ticks += this.ticks_per_refresh;
    if (this.current_ticks >= this.next_event_tick && this.all_ticks.length > 0) {
      this.playNote(this.all_ticks[this.next_index].notes);
      this.next_index++;
      if (this.next_index >= this.all_ticks.length) {
        return this.done = true;
      } else {
        return this.next_event_tick = this.all_ticks[this.next_index].tick.value();
      }
    }
  };

  Player.prototype.stop = function() {
    L("Stop");
    if (this.interval_id != null) {
      window.clearInterval(this.interval_id);
    }
    if (this.play_button != null) {
      this.play_button.fillColor = '#396';
    }
    if (this.paper != null) {
      this.paper.view.draw();
    }
    this.interval_id = null;
    this.current_ticks = 0;
    this.next_event_tick = 0;
    this.next_index = 0;
    return this.done = false;
  };

  Player.prototype.start = function() {
    this.stop();
    L("Start");
    if (this.play_button != null) {
      this.play_button.fillColor = '#a36';
    }
    MIDI.programChange(0, INSTRUMENTS[this.options.instrument]);
    this.render();
    return this.interval_id = window.setInterval(((function(_this) {
      return function() {
        return _this.refresh();
      };
    })(this)), this.refresh_rate);
  };

  Player.prototype.play = function() {
    L("Play: ", this.refresh_rate, this.ticks_per_refresh);
    if (Vex.Flow.Player.INSTRUMENTS_LOADED[this.options.instrument] && !this.loading) {
      return this.start();
    } else {
      L("Loading instruments...");
      this.loading_message.content = "Loading instruments...";
      this.loading_message.fillColor = "green";
      this.loading = true;
      this.paper.view.draw();
      return MIDI.loadPlugin({
        soundfontUrl: this.options.soundfont_url,
        instruments: [this.options.instrument],
        callback: (function(_this) {
          return function() {
            console.log("loadPlugin is succcesfully calling back.");
            Vex.Flow.Player.INSTRUMENTS_LOADED[_this.options.instrument] = true;
            _this.loading = false;
            _this.loading_message.content = "";
            return _this.start();
          };
        })(this)
      });
    }
  };

  return Player;

})();

module.exports = Vex.Flow.Player;


},{"jquery":5,"paper":7,"underscore":9,"vexflow":1}],13:[function(require,module,exports){
var Vex, VexTab, _, parser,
  slice = [].slice,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

Vex = require('vexflow');

_ = require('underscore');

parser = require('../build/vextab-jison.js');

VexTab = (function() {
  var L, newError;

  VexTab.DEBUG = false;

  L = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (VexTab.DEBUG) {
      return typeof console !== "undefined" && console !== null ? console.log.apply(console, ["(Vex.Flow.VexTab)"].concat(slice.call(args))) : void 0;
    }
  };

  newError = function(object, msg) {
    return new Vex.RERR("ParseError", msg + " in line " + object._l + " column " + object._c);
  };

  function VexTab(artist) {
    this.artist = artist;
    this.reset();
  }

  VexTab.prototype.reset = function() {
    this.valid = false;
    return this.elements = false;
  };

  VexTab.prototype.isValid = function() {
    return this.valid;
  };

  VexTab.prototype.getArtist = function() {
    return this.artist;
  };

  VexTab.prototype.parseStaveOptions = function(options) {
    var clefs, e, error, error1, error2, i, len, notation_option, num_strings, option, params, ref, ref1, ref2, voices;
    params = {};
    if (options == null) {
      return params;
    }
    notation_option = null;
    for (i = 0, len = options.length; i < len; i++) {
      option = options[i];
      error = function(msg) {
        return newError(option, msg);
      };
      params[option.key] = option.value;
      switch (option.key) {
        case "notation":
        case "tablature":
          notation_option = option;
          if ((ref = option.value) !== "true" && ref !== "false") {
            throw error("'" + option.key + "' must be 'true' or 'false'");
          }
          break;
        case "key":
          if (!_.has(Vex.Flow.keySignature.keySpecs, option.value)) {
            throw error("Invalid key signature '" + option.value + "'");
          }
          break;
        case "clef":
          clefs = ["treble", "bass", "tenor", "alto", "percussion", "none"];
          if (ref1 = option.value, indexOf.call(clefs, ref1) < 0) {
            throw error("'clef' must be one of " + (clefs.join(', ')));
          }
          break;
        case "voice":
          voices = ["top", "bottom", "new"];
          if (ref2 = option.value, indexOf.call(voices, ref2) < 0) {
            throw error("'voice' must be one of " + (voices.join(', ')));
          }
          break;
        case "time":
          try {
            new Vex.Flow.TimeSignature(option.value);
          } catch (error1) {
            e = error1;
            throw error("Invalid time signature: '" + option.value + "'");
          }
          break;
        case "tuning":
          try {
            new Vex.Flow.Tuning(option.value);
          } catch (error2) {
            e = error2;
            throw error("Invalid tuning: '" + option.value + "'");
          }
          break;
        case "strings":
          num_strings = parseInt(option.value);
          if (num_strings < 4 || num_strings > 8) {
            throw error("Invalid number of strings: " + num_strings);
          }
          break;
        default:
          throw error("Invalid option '" + option.key + "'");
      }
    }
    if (params.notation === "false" && params.tablature === "false") {
      throw newError(notation_option, "Both 'notation' and 'tablature' can't be invisible");
    }
    return params;
  };

  VexTab.prototype.parseCommand = function(element) {
    if (element.command === "bar") {
      this.artist.addBar(element.type);
    }
    if (element.command === "tuplet") {
      this.artist.makeTuplets(element.params.tuplet, element.params.notes);
    }
    if (element.command === "annotations") {
      this.artist.addAnnotations(element.params);
    }
    if (element.command === "rest") {
      this.artist.addRest(element.params);
    }
    if (element.command === "command") {
      return this.artist.runCommand(element.params, element._l, element._c);
    }
  };

  VexTab.prototype.parseChord = function(element) {
    L("parseChord:", element);
    return this.artist.addChord(_.map(element.chord, function(note) {
      return _.pick(note, 'time', 'dot', 'fret', 'abc', 'octave', 'string', 'articulation', 'decorator');
    }), element.articulation, element.decorator);
  };

  VexTab.prototype.parseFret = function(note) {
    return this.artist.addNote(_.pick(note, 'time', 'dot', 'fret', 'string', 'articulation', 'decorator'));
  };

  VexTab.prototype.parseABC = function(note) {
    return this.artist.addNote(_.pick(note, 'time', 'dot', 'fret', 'abc', 'octave', 'string', 'articulation', 'decorator'));
  };

  VexTab.prototype.parseStaveElements = function(notes) {
    var element, i, len, results;
    L("parseStaveElements:", notes);
    results = [];
    for (i = 0, len = notes.length; i < len; i++) {
      element = notes[i];
      if (element.time) {
        this.artist.setDuration(element.time, element.dot);
      }
      if (element.command) {
        this.parseCommand(element);
      }
      if (element.chord) {
        this.parseChord(element);
      }
      if (element.abc) {
        results.push(this.parseABC(element));
      } else if (element.fret) {
        results.push(this.parseFret(element));
      } else {
        results.push(void 0);
      }
    }
    return results;
  };

  VexTab.prototype.parseStaveText = function(text_line) {
    var bartext, command, createNote, font, i, justification, len, position, results, smooth, str, text;
    if (!_.isEmpty(text_line)) {
      this.artist.addTextVoice();
    }
    position = 0;
    justification = "center";
    smooth = true;
    font = null;
    bartext = (function(_this) {
      return function() {
        return _this.artist.addTextNote("", 0, justification, false, true);
      };
    })(this);
    createNote = (function(_this) {
      return function(text) {
        var e, error1, ignore_ticks;
        ignore_ticks = false;
        if (text[0] === "|") {
          ignore_ticks = true;
          text = text.slice(1);
        }
        try {
          return _this.artist.addTextNote(text, position, justification, smooth, ignore_ticks);
        } catch (error1) {
          e = error1;
          throw newError(str, "Bad text or duration. Did you forget a comma?" + e);
        }
      };
    })(this);
    results = [];
    for (i = 0, len = text_line.length; i < len; i++) {
      str = text_line[i];
      text = str.text.trim();
      if (text.match(/\.font=.*/)) {
        font = text.slice(6);
        results.push(this.artist.setTextFont(font));
      } else if (text[0] === ":") {
        results.push(this.artist.setDuration(text));
      } else if (text[0] === ".") {
        command = text.slice(1);
        switch (command) {
          case "center":
          case "left":
          case "right":
            results.push(justification = command);
            break;
          case "strict":
            results.push(smooth = false);
            break;
          case "smooth":
            results.push(smooth = true);
            break;
          case "bar":
          case "|":
            results.push(bartext());
            break;
          default:
            results.push(position = parseInt(text.slice(1), 10));
        }
      } else if (text === "|") {
        results.push(bartext());
      } else if (text.slice(0, 2) === "++") {
        results.push(this.artist.addTextVoice());
      } else {
        results.push(createNote(text));
      }
    }
    return results;
  };

  VexTab.prototype.generate = function() {
    var e, error1, i, j, k, len, len1, len2, newStaveGroupIndex, option, options, ref, ref1, ref2, results, s, stave;
    ref = this.elements;
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      stave = ref[i];
      switch (stave.element) {
        case "stavegroup":
          newStaveGroupIndex = this.artist.staveGroupsLength();
          this.artist.addStaveGroup();
          ref1 = stave.stavelist;
          for (j = 0, len1 = ref1.length; j < len1; j++) {
            s = ref1[j];
            L("stave in generate", s);
            this.artist.addStave(newStaveGroupIndex, s.element, this.parseStaveOptions(s.options));
            if (s.notes != null) {
              this.parseStaveElements(s.notes);
            }
            if (s.text != null) {
              this.parseStaveText(s.text);
            }
          }
          results.push(L("Stavegroup generated", this.artist.stavegroups[newStaveGroupIndex]));
          break;
        case "voice":
          results.push(L("skipping voice for now."));
          break;
        case "options":
          options = {};
          ref2 = stave.params;
          for (k = 0, len2 = ref2.length; k < len2; k++) {
            option = ref2[k];
            options[option.key] = option.value;
          }
          try {
            results.push(this.artist.setOptions(options));
          } catch (error1) {
            e = error1;
            throw newError(stave, e.message);
          }
          break;
        default:
          throw newError(stave, "Invalid keyword '" + stave.element + "'");
      }
    }
    return results;
  };

  VexTab.prototype.parse = function(code) {
    var line, stripped_code;
    parser.parseError = function(message, hash) {
      L("VexTab parse error: ", message, hash);
      message = "Unexpected text '" + hash.text + "' at line " + hash.loc.first_line + " column " + hash.loc.first_column + ".";
      throw new Vex.RERR("ParseError", message);
    };
    if (code == null) {
      throw new Vex.RERR("ParseError", "No code");
    }
    L("Parsing:\n" + code);
    stripped_code = (function() {
      var i, len, ref, results;
      ref = code.split(/\r\n|\r|\n/);
      results = [];
      for (i = 0, len = ref.length; i < len; i++) {
        line = ref[i];
        results.push(line.trim());
      }
      return results;
    })();
    this.elements = parser.parse(stripped_code.join("\n"));
    if (this.elements) {
      this.generate();
      this.valid = true;
    }
    return this.elements;
  };

  return VexTab;

})();

module.exports = VexTab;


},{"../build/vextab-jison.js":2,"underscore":9,"vexflow":1}],14:[function(require,module,exports){
// Load VexTab module.
vextab = require("vextab");
$ = require("jquery");
_ = require("underscore");

$(function() {
  VexTab = vextab.VexTab;
  Artist = vextab.Artist;
  Renderer = vextab.Vex.Flow.Renderer;
  Player = vextab.Player;

  Artist.DEBUG = true;
  VexTab.DEBUG = true;
  Player.DEBUG = false;

  // Create VexFlow Renderer from canvas element with id #boo
  renderer = new Renderer($('#boo')[0], Renderer.Backends.CANVAS);

  // Initialize VexTab artist and parser.
  artist = new Artist(10, 10, 600, {scale: 0.8});
  player = new Player(artist);
  vextab = new VexTab(artist);

  function render() {
    try {
      vextab.reset();
      artist.reset();
      vextab.parse($("#blah").val());
      artist.render(renderer);
      $("#error").text("");
    } catch (e) {
      console.log(e);
      $("#error").html(e.message.replace(/[\n]/g, '<br/>'));
    }
  }

  $("#blah").keyup(_.throttle(render, 250));
  render();
});

},{"jquery":5,"underscore":9,"vextab":11}]},{},[14])
//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9ncnVudC1icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCIuLi92ZXhmbG93L3JlbGVhc2VzL3ZleGZsb3ctZGVidWcuanMiLCJidWlsZC92ZXh0YWItamlzb24uanMiLCJub2RlX21vZHVsZXMvZ3J1bnQtYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9saWIvX2VtcHR5LmpzIiwibm9kZV9tb2R1bGVzL2dydW50LWJyb3dzZXJpZnkvbm9kZV9tb2R1bGVzL3Byb2Nlc3MvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9qcXVlcnkvZGlzdC9qcXVlcnkuanMiLCJub2RlX21vZHVsZXMvbG9kYXNoL2xvZGFzaC5qcyIsIm5vZGVfbW9kdWxlcy9wYXBlci9kaXN0L3BhcGVyLWZ1bGwuanMiLCJub2RlX21vZHVsZXMvcGF0aC1icm93c2VyaWZ5L2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3VuZGVyc2NvcmUvdW5kZXJzY29yZS5qcyIsIi9Vc2Vycy9zcGVuY2VyaGl0Y2hjb2NrL2NvZGUvdmV4dGFiL3NyYy9hcnRpc3QuY29mZmVlIiwiL1VzZXJzL3NwZW5jZXJoaXRjaGNvY2svY29kZS92ZXh0YWIvc3JjL21haW4uY29mZmVlIiwiL1VzZXJzL3NwZW5jZXJoaXRjaGNvY2svY29kZS92ZXh0YWIvc3JjL3BsYXllci5jb2ZmZWUiLCIvVXNlcnMvc3BlbmNlcmhpdGNoY29jay9jb2RlL3ZleHRhYi9zcmMvdmV4dGFiLmNvZmZlZSIsInRlc3RzL3BsYXlncm91bmQuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQ3p2ZkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaGhDQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDdm1UQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDbHFJQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDeDRhQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUNoT0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcmdEQSxJQUFBLGNBQUE7RUFBQTs7O0FBQUEsR0FBQSxHQUFNLE9BQUEsQ0FBUSxTQUFSOztBQUNOLENBQUEsR0FBSSxPQUFBLENBQVEsWUFBUjs7QUFFRTtBQUNKLE1BQUE7O0VBQUEsTUFBQyxDQUFBLEtBQUQsR0FBUzs7RUFDVCxDQUFBLEdBQUksU0FBQTtBQUFhLFFBQUE7SUFBWjtJQUFZLElBQThDLE1BQU0sQ0FBQyxLQUFyRDtrRUFBQSxPQUFPLENBQUUsR0FBVCxnQkFBYSxDQUFBLG1CQUFxQixTQUFBLFdBQUEsSUFBQSxDQUFBLENBQWxDLFdBQUE7O0VBQWI7O0VBRUosTUFBQyxDQUFBLE1BQUQsR0FBVTs7RUFFRyxnQkFBQyxDQUFELEVBQUssQ0FBTCxFQUFTLE1BQVQsRUFBaUIsT0FBakI7SUFBQyxJQUFDLENBQUEsSUFBRDtJQUFJLElBQUMsQ0FBQSxJQUFEO0lBQUksSUFBQyxDQUFBLFFBQUQ7SUFDcEIsSUFBQyxDQUFBLE9BQUQsR0FDRTtNQUFBLFNBQUEsRUFBVyxPQUFYO01BQ0EsU0FBQSxFQUFXLEVBRFg7TUFFQSxVQUFBLEVBQVksSUFGWjtNQUdBLGNBQUEsRUFBZ0IsRUFBQSxHQUFLLENBQUksTUFBTSxDQUFDLE1BQVYsR0FBc0IsQ0FBdEIsR0FBNkIsRUFBOUIsQ0FIckI7TUFJQSx1QkFBQSxFQUF5QixFQUp6QjtNQUtBLHdCQUFBLEVBQTBCLENBTDFCO01BTUEsS0FBQSxFQUFPLEdBTlA7O0lBT0YsSUFBK0IsZUFBL0I7TUFBQSxDQUFDLENBQUMsTUFBRixDQUFTLElBQUMsQ0FBQSxPQUFWLEVBQW1CLE9BQW5CLEVBQUE7O0lBQ0EsSUFBQyxDQUFBLEtBQUQsQ0FBQTtFQVZXOzttQkFZYixLQUFBLEdBQU8sU0FBQTtJQUNMLElBQUMsQ0FBQSxNQUFELEdBQWMsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQVQsQ0FBQTtJQUNkLElBQUMsQ0FBQSxXQUFELEdBQW1CLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFULENBQW9CLEdBQXBCO0lBQ25CLElBQUMsQ0FBQSxTQUFELEdBQWlCLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFULENBQUE7SUFHakIsSUFBQyxDQUFBLGNBQUQsR0FDRTtNQUFBLFdBQUEsRUFBYSxJQUFDLENBQUEsT0FBTyxDQUFDLFNBQXRCO01BQ0EsV0FBQSxFQUFhLElBQUMsQ0FBQSxPQUFPLENBQUMsU0FEdEI7TUFFQSxZQUFBLEVBQWMsSUFBQyxDQUFBLE9BQU8sQ0FBQyxVQUZ2QjtNQUdBLHFCQUFBLEVBQXVCLFFBSHZCO01BSUEsT0FBQSxFQUFTLElBQUMsQ0FBQSxPQUFPLENBQUMsS0FKbEI7TUFLQSxPQUFBLEVBQVMsSUFBQyxDQUFBLEtBTFY7TUFNQSxnQkFBQSxFQUFrQixDQU5sQjtNQU9BLE9BQUEsRUFBUyxDQVBUO01BUUEsUUFBQSxFQUFVLE9BUlY7TUFTQSxPQUFBLEVBQVMsR0FUVDtNQVVBLFlBQUEsRUFBYyxzQkFWZDtNQVdBLGFBQUEsRUFBZSxVQVhmO01BWUEsV0FBQSxFQUFhLE9BWmI7TUFhQSxvQkFBQSxFQUFzQixJQWJ0QjtNQWNBLFlBQUEsRUFBYyxNQWRkO01BZUEsZUFBQSxFQUFpQixNQWZqQjtNQWdCQSxrQkFBQSxFQUFvQixPQWhCcEI7TUFpQkEsaUJBQUEsRUFBbUIsQ0FqQm5COztJQW9CRixJQUFDLENBQUEsV0FBRCxHQUFlO0lBRWYsSUFBQyxDQUFBLGlCQUFELEdBQXFCO0lBQ3JCLElBQUMsQ0FBQSxtQkFBRCxHQUF1QjtJQUd2QixJQUFDLENBQUEsYUFBRCxHQUFpQjtJQUdqQixJQUFDLENBQUEsTUFBRCxHQUFVLElBQUMsQ0FBQTtJQUNYLElBQUMsQ0FBQSxnQkFBRCxHQUFvQjtJQUNwQixJQUFDLENBQUEsWUFBRCxHQUFnQjtJQUNoQixJQUFDLENBQUEsYUFBRCxHQUFpQjtJQUNqQixJQUFDLENBQUEsb0JBQUQsR0FBd0I7SUFDeEIsSUFBQyxDQUFBLGdCQUFELEdBQW9CO0lBQ3BCLElBQUMsQ0FBQSxrQkFBRCxHQUFzQjtJQUN0QixJQUFDLENBQUEsUUFBRCxHQUFZO1dBQ1osSUFBQyxDQUFBLGdCQUFELEdBQW9CO0VBNUNmOzttQkE4Q1AsWUFBQSxHQUFjLFNBQUMsTUFBRDtJQUNaLElBQUcsQ0FBQyxJQUFDLENBQUEsTUFBTDthQUNFLElBQUMsQ0FBQSxNQUFELEdBQVUsT0FEWjs7RUFEWTs7bUJBSWQsVUFBQSxHQUFZLFNBQUMsT0FBRDtBQUNWLFFBQUE7SUFBQSxDQUFBLENBQUUsY0FBRixFQUFrQixPQUFsQjtJQUVBLGFBQUEsR0FBZ0IsQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsY0FBUjtBQUNoQixTQUFBLFlBQUE7O01BQ0UsSUFBRyxhQUFLLGFBQUwsRUFBQSxDQUFBLE1BQUg7UUFDRSxJQUFDLENBQUEsY0FBZSxDQUFBLENBQUEsQ0FBaEIsR0FBcUIsRUFEdkI7T0FBQSxNQUFBO0FBR0UsY0FBVSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsYUFBVCxFQUF3QixrQkFBQSxHQUFtQixDQUFuQixHQUFxQixHQUE3QyxFQUhaOztBQURGO0lBTUEsSUFBQyxDQUFBLE1BQUQsSUFBVyxRQUFBLENBQVMsSUFBQyxDQUFBLGNBQWMsQ0FBQyxLQUF6QixFQUFnQyxFQUFoQztJQUNYLElBQWdCLElBQUMsQ0FBQSxjQUFjLENBQUMsTUFBaEIsS0FBMEIsTUFBMUM7YUFBQSxJQUFDLENBQUEsTUFBRCxJQUFXLEVBQVg7O0VBWFU7O21CQWFaLGFBQUEsR0FBZSxTQUFBO1dBQ2I7TUFBQSxNQUFBLEVBQVEsSUFBQyxDQUFBLGFBQVQ7TUFDQSxPQUFBLEVBQVMsSUFBQyxDQUFBLGdCQURWO01BRUEsS0FBQSxFQUFPLElBQUMsQ0FBQSxjQUFjLENBQUMsS0FGdkI7O0VBRGE7O0VBS2YsU0FBQSxHQUFZLFNBQUMsR0FBRDtBQUNWLFdBQVEsR0FBQSxLQUFPO0VBREw7O0VBR1osZUFBQSxHQUFrQixTQUFDLEdBQUQsRUFBTSxHQUFOLEVBQVcsS0FBWCxFQUFrQixVQUFsQixFQUE4QixjQUE5QixFQUE4QyxPQUE5QztBQUNoQixRQUFBO0lBQUEsSUFBeUIsV0FBekI7TUFBQSxTQUFBLEdBQVksR0FBRyxDQUFDLE1BQWhCOztJQUNBLElBQTZCLGFBQTdCO01BQUEsV0FBQSxHQUFjLEtBQUssQ0FBQyxNQUFwQjs7SUFFQSxVQUFBLEdBQWE7SUFDYixZQUFBLEdBQWU7SUFDZixXQUFBLEdBQWM7SUFDZCxLQUFBLEdBQVE7SUFDUixZQUFBLEdBQWU7SUFDZixVQUFBLEdBQWE7SUFFYixXQUFBLEdBQ0U7TUFBQSxVQUFBLEVBQVksU0FBQSxDQUFVLGNBQWUsQ0FBQSxZQUFBLENBQXpCLENBQVo7TUFDQSxhQUFBLEVBQWUsU0FBQSxDQUFVLGNBQWUsQ0FBQSxlQUFBLENBQXpCLENBRGY7TUFFQSxnQkFBQSxFQUFrQixTQUFBLENBQVUsY0FBZSxDQUFBLGtCQUFBLENBQXpCLENBRmxCO01BR0EsTUFBQSxFQUFRLE9BQU8sQ0FBQyxXQUhoQjs7SUFLRixJQUFHLFdBQUg7TUFDRSxXQUFBLEdBQWtCLEdBQUcsQ0FBQyxNQUFNLENBQUMsTUFBWCxHQUFvQixDQUF4QixHQUFnQyxJQUFoQyxHQUEwQztBQUN4RDtBQUFBLFdBQUEsNkNBQUE7O1FBQ0UsSUFBWSxDQUFDLENBQUMsT0FBRixDQUFVLEtBQVYsQ0FBWjtBQUFBLG1CQUFBOztRQUNBLENBQUMsQ0FBQyxJQUFGLENBQU8sS0FBUCxFQUFjLFNBQUMsSUFBRDtpQkFBVSxJQUFJLENBQUMsUUFBTCxDQUFjLFNBQWQ7UUFBVixDQUFkO1FBQ0EsS0FBQSxHQUFZLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFULENBQWUsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUF4QixDQUFnQyxDQUMxQyxPQURVLENBQ0YsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBRGxCO1FBRVosS0FBSyxDQUFDLFlBQU4sQ0FBbUIsS0FBbkI7UUFDQSxVQUFVLENBQUMsSUFBWCxDQUFnQixLQUFoQjtRQUVBLElBQUcsY0FBZSxDQUFBLFdBQUEsQ0FBZixLQUErQixNQUFsQztVQUNFLElBQUcsV0FBSDtZQUNFLFdBQVcsQ0FBQyxjQUFaLEdBQWdDLENBQUEsS0FBSyxDQUFSLEdBQWUsQ0FBZixHQUFzQixDQUFDLEVBRHREO1dBQUEsTUFBQTtZQUdFLFdBQVcsQ0FBQyxjQUFaLEdBQWdDLGNBQWUsQ0FBQSxvQkFBQSxDQUFmLEtBQXdDLE1BQTNDLEdBQXVELENBQUMsQ0FBeEQsR0FBK0QsRUFIOUY7O1VBS0EsV0FBVyxDQUFDLFVBQVosR0FBeUI7VUFDekIsS0FBQSxHQUFRLEtBQUssQ0FBQyxNQUFOLENBQWEsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBZCxDQUE0QixLQUFLLENBQUMsWUFBTixDQUFBLENBQTVCLEVBQWtELFdBQWxELENBQWIsRUFQVjs7QUFSRjtNQWlCQSxZQUFBLEdBQWU7TUFDZixVQUFBLEdBQWEsVUFwQmY7O0lBc0JBLFdBQVcsQ0FBQyxVQUFaLEdBQXlCLFNBQUEsQ0FBVSxjQUFlLENBQUEsWUFBQSxDQUF6QjtJQUV6QixJQUFHLGFBQUg7TUFDRSxXQUFBLEdBQWtCLEtBQUssQ0FBQyxNQUFNLENBQUMsTUFBYixHQUFzQixDQUExQixHQUFrQyxJQUFsQyxHQUE0QztBQUMxRDtBQUFBLFdBQUEsZ0RBQUE7O1FBQ0UsSUFBWSxDQUFDLENBQUMsT0FBRixDQUFVLEtBQVYsQ0FBWjtBQUFBLG1CQUFBOztRQUNBLGNBQUEsR0FBb0IsQ0FBQSxLQUFLLENBQVIsR0FBZSxDQUFmLEdBQXNCLENBQUM7UUFDeEMsQ0FBQyxDQUFDLElBQUYsQ0FBTyxLQUFQLEVBQWMsU0FBQyxJQUFEO2lCQUFVLElBQUksQ0FBQyxRQUFMLENBQWMsV0FBZDtRQUFWLENBQWQ7UUFFQSxLQUFBLEdBQVksSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQVQsQ0FBZSxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQXhCLENBQWdDLENBQzFDLE9BRFUsQ0FDRixHQUFHLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxJQUFJLENBQUMsSUFEbEI7UUFFWixLQUFLLENBQUMsWUFBTixDQUFtQixLQUFuQjtRQUNBLFlBQVksQ0FBQyxJQUFiLENBQWtCLEtBQWxCO1FBQ0EsSUFBRyxXQUFIO1VBQ0UsV0FBVyxDQUFDLGNBQVosR0FBNkI7VUFDN0IsS0FBQSxHQUFRLEtBQUssQ0FBQyxNQUFOLENBQWEsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBZCxDQUE0QixLQUE1QixFQUFtQyxXQUFuQyxDQUFiLEVBRlY7U0FBQSxNQUFBO1VBSUUsV0FBVyxDQUFDLGNBQVosR0FBNkI7VUFDN0IsS0FBQSxHQUFRLEtBQUssQ0FBQyxNQUFOLENBQWEsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFJLENBQUMsYUFBZCxDQUE0QixLQUE1QixFQUFtQyxXQUFuQyxDQUFiLEVBTFY7O0FBVEY7TUFnQkEsWUFBQSxHQUFlO01BQ2YsVUFBQSxHQUFhLFlBbkJmOztBQXFCQSxTQUFBLDhDQUFBOztNQUNFLElBQVksQ0FBQyxDQUFDLE9BQUYsQ0FBVSxLQUFWLENBQVo7QUFBQSxpQkFBQTs7TUFDQSxDQUFDLENBQUMsSUFBRixDQUFPLEtBQVAsRUFBYyxTQUFDLEtBQUQ7ZUFBVyxLQUFLLENBQUMsUUFBTixDQUFlLFVBQWY7TUFBWCxDQUFkO01BQ0EsS0FBQSxHQUFZLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFULENBQWUsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUF4QixDQUFnQyxDQUN4QyxPQURRLENBQ0EsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsSUFBSSxDQUFDLElBRHBCO01BRVosS0FBSyxDQUFDLFlBQU4sQ0FBbUIsS0FBbkI7TUFDQSxXQUFXLENBQUMsSUFBWixDQUFpQixLQUFqQjtBQU5GO0lBUUEsSUFBRyxvQkFBSDtNQUNFLGFBQUEsR0FBZ0I7TUFDaEIsU0FBQSxHQUFnQixJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsU0FBVCxDQUFBO01BQ2hCLFdBQUEsR0FBYztNQUVkLElBQUcsV0FBSDtRQUNFLElBQUEsQ0FBd0MsQ0FBQyxDQUFDLE9BQUYsQ0FBVSxVQUFWLENBQXhDO1VBQUEsU0FBUyxDQUFDLFVBQVYsQ0FBcUIsVUFBckIsRUFBQTs7UUFDQSxhQUFBLEdBQWdCLFdBRmxCOztNQUlBLElBQUcsYUFBSDtRQUNFLElBQUEsQ0FBMEMsQ0FBQyxDQUFDLE9BQUYsQ0FBVSxZQUFWLENBQTFDO1VBQUEsU0FBUyxDQUFDLFVBQVYsQ0FBcUIsWUFBckIsRUFBQTs7UUFDQSxhQUFBLEdBQWdCLGFBQWEsQ0FBQyxNQUFkLENBQXFCLFlBQXJCO1FBQ2hCLElBQXNCLFlBQVksQ0FBQyxNQUFiLEdBQXNCLENBQTVDO1VBQUEsV0FBQSxHQUFjLEtBQWQ7U0FIRjs7TUFLQSxJQUFHLENBQUksQ0FBQyxDQUFDLE9BQUYsQ0FBVSxVQUFWLENBQUosSUFBOEIsQ0FBSSxDQUFDLENBQUMsT0FBRixDQUFVLFdBQVYsQ0FBckM7UUFDRSxTQUFTLENBQUMsVUFBVixDQUFxQixXQUFyQjtRQUNBLGFBQUEsR0FBZ0IsYUFBYSxDQUFDLE1BQWQsQ0FBcUIsV0FBckIsRUFGbEI7O01BSUEsSUFBQSxDQUF3RixDQUFDLENBQUMsT0FBRixDQUFVLGFBQVYsQ0FBeEY7UUFBQSxTQUFTLENBQUMsYUFBVixDQUF3QixhQUF4QixFQUF1QyxZQUF2QyxFQUFxRDtVQUFDLFdBQUEsRUFBYSxXQUFkO1NBQXJELEVBQUE7O01BRUEsSUFBNkQsV0FBN0Q7UUFBQSxDQUFDLENBQUMsSUFBRixDQUFPLFVBQVAsRUFBbUIsU0FBQyxLQUFEO2lCQUFXLEtBQUssQ0FBQyxJQUFOLENBQVcsR0FBWCxFQUFnQixTQUFoQjtRQUFYLENBQW5CLEVBQUE7O01BQ0EsSUFBaUUsYUFBakU7UUFBQSxDQUFDLENBQUMsSUFBRixDQUFPLFlBQVAsRUFBcUIsU0FBQyxLQUFEO2lCQUFXLEtBQUssQ0FBQyxJQUFOLENBQVcsR0FBWCxFQUFnQixXQUFoQjtRQUFYLENBQXJCLEVBQUE7O01BQ0EsQ0FBQyxDQUFDLElBQUYsQ0FBTyxLQUFQLEVBQWMsU0FBQyxJQUFEO2VBQVUsSUFBSSxDQUFDLFVBQUwsQ0FBZ0IsR0FBaEIsQ0FBb0IsQ0FBQyxJQUFyQixDQUFBO01BQVYsQ0FBZDtNQUNBLElBQStELENBQUksQ0FBQyxDQUFDLE9BQUYsQ0FBVSxVQUFWLENBQW5FO1FBQUEsQ0FBQyxDQUFDLElBQUYsQ0FBTyxXQUFQLEVBQW9CLFNBQUMsS0FBRDtpQkFBVyxLQUFLLENBQUMsSUFBTixDQUFXLEdBQVgsRUFBZ0IsVUFBaEI7UUFBWCxDQUFwQixFQUFBOztNQUVBLElBQUcsYUFBQSxJQUFTLGVBQVo7UUFDRSxDQUFLLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxjQUFULENBQXdCLEtBQUssQ0FBQyxLQUE5QixFQUFxQyxHQUFHLENBQUMsS0FBekMsQ0FBTCxDQUFxRCxDQUFDLFVBQXRELENBQWlFLEdBQWpFLENBQXFFLENBQUMsSUFBdEUsQ0FBQSxFQURGOztNQUdBLElBQUcsYUFBSDtlQUFlLGFBQWY7T0FBQSxNQUFBO2VBQWlDLFdBQWpDO09BNUJGOztFQXRFZ0I7O21CQW9HbEIsTUFBQSxHQUFRLFNBQUMsUUFBRDtBQUNOLFFBQUE7SUFBQSxDQUFBLENBQUUsVUFBRixFQUFjLElBQUMsQ0FBQSxPQUFmO0lBQ0EsSUFBQyxDQUFBLFVBQUQsQ0FBQTtJQUNBLFFBQVEsQ0FBQyxNQUFULENBQWdCLElBQUMsQ0FBQSxjQUFjLENBQUMsS0FBaEIsR0FBd0IsSUFBQyxDQUFBLGNBQWMsQ0FBQyxLQUF4RCxFQUNJLENBQUMsSUFBQyxDQUFBLE1BQUQsR0FBVSxJQUFDLENBQUEsT0FBTyxDQUFDLGNBQXBCLENBQUEsR0FBc0MsSUFBQyxDQUFBLGNBQWMsQ0FBQyxLQUQxRDtJQUVBLEdBQUEsR0FBTSxRQUFRLENBQUMsVUFBVCxDQUFBO0lBQ04sR0FBRyxDQUFDLEtBQUosQ0FBVSxJQUFDLENBQUEsY0FBYyxDQUFDLEtBQTFCLEVBQWlDLElBQUMsQ0FBQSxjQUFjLENBQUMsS0FBakQ7SUFDQSxHQUFHLENBQUMsS0FBSixDQUFBO0lBQ0EsR0FBRyxDQUFDLE9BQUosQ0FBWSxJQUFDLENBQUEsT0FBTyxDQUFDLFNBQXJCLEVBQWdDLElBQUMsQ0FBQSxPQUFPLENBQUMsU0FBekMsRUFBb0QsRUFBcEQ7SUFFQSxJQUFDLENBQUEsZ0JBQUQsR0FBb0I7SUFFcEIsTUFBQSxHQUFTLFNBQUMsS0FBRCxFQUFRLEtBQVI7QUFDUCxVQUFBO01BQUEsU0FBQSxHQUFZLENBQUMsQ0FBQyxJQUFGLENBQU8sS0FBUDtNQUNaLElBQUcsU0FBQSxZQUFxQixHQUFHLENBQUMsSUFBSSxDQUFDLE9BQWpDO1FBQ0UsS0FBSyxDQUFDLEdBQU4sQ0FBQTtlQUNBLEtBQUssQ0FBQyxhQUFOLENBQW9CLFNBQVMsQ0FBQyxPQUFWLENBQUEsQ0FBcEIsRUFGRjs7SUFGTztBQU1UO0FBQUEsU0FBQSxxQ0FBQTs7TUFDRSxDQUFBLENBQUUsd0JBQUY7TUFFQSxNQUFBLEdBQVM7QUFFVDtBQUFBLFdBQUEsd0NBQUE7O1FBQ0UsQ0FBQSxDQUFFLG1CQUFGO1FBRUEsSUFBc0MsaUJBQXRDO1VBQUEsTUFBQSxDQUFPLEtBQUssQ0FBQyxHQUFiLEVBQWtCLEtBQUssQ0FBQyxTQUF4QixFQUFBOztRQUNBLElBQXdDLGtCQUF4QztVQUFBLE1BQUEsQ0FBTyxLQUFLLENBQUMsSUFBYixFQUFtQixLQUFLLENBQUMsVUFBekIsRUFBQTs7UUFFQSxJQUFvQyxpQkFBcEM7VUFBQSxLQUFLLENBQUMsR0FBRyxDQUFDLFVBQVYsQ0FBcUIsR0FBckIsQ0FBeUIsQ0FBQyxJQUExQixDQUFBLEVBQUE7O1FBQ0EsSUFBcUMsa0JBQXJDO1VBQUEsS0FBSyxDQUFDLElBQUksQ0FBQyxVQUFYLENBQXNCLEdBQXRCLENBQTBCLENBQUMsSUFBM0IsQ0FBQSxFQUFBOztRQUVBLEtBQUssQ0FBQyxVQUFVLENBQUMsSUFBakIsQ0FBc0IsS0FBSyxDQUFDLFNBQTVCO1FBQ0EsS0FBSyxDQUFDLFdBQVcsQ0FBQyxJQUFsQixDQUF1QixLQUFLLENBQUMsVUFBN0I7UUFFQSxNQUFBLEdBQVMsZUFBQSxDQUFnQixHQUFoQixFQUNVLGlCQUFILEdBQW1CO1VBQUMsS0FBQSxFQUFPLEtBQUssQ0FBQyxHQUFkO1VBQW1CLE1BQUEsRUFBUSxLQUFLLENBQUMsVUFBakM7U0FBbkIsR0FBcUUsSUFENUUsRUFFVSxrQkFBSCxHQUFvQjtVQUFDLEtBQUEsRUFBTyxLQUFLLENBQUMsSUFBZDtVQUFvQixNQUFBLEVBQVEsS0FBSyxDQUFDLFdBQWxDO1NBQXBCLEdBQXdFLElBRi9FLEVBR08sS0FBSyxDQUFDLFdBSGIsRUFJTyxJQUFDLENBQUEsY0FKUixFQUtPO1VBQUMsV0FBQSxFQUFhLEtBQUssQ0FBQyxXQUFwQjtTQUxQO1FBT1QsTUFBTSxDQUFDLElBQVAsQ0FBWSxNQUFaO0FBbkJGO0FBTEY7SUF5QkEsSUFBQyxDQUFBLGFBQWEsQ0FBQyxJQUFmLENBQW9CLE1BQXBCO0lBRUEsQ0FBQSxDQUFFLDhCQUFGO0FBQ0E7QUFBQSxTQUFBLHdDQUFBOztNQUNFLFlBQVksQ0FBQyxVQUFiLENBQXdCLEdBQXhCLENBQTRCLENBQUMsSUFBN0IsQ0FBQTtBQURGO0lBR0EsQ0FBQSxDQUFFLCtCQUFGO0FBQ0E7QUFBQSxTQUFBLHdDQUFBOztNQUNFLFlBQVksQ0FBQyxVQUFiLENBQXdCLEdBQXhCLENBQTRCLENBQUMsSUFBN0IsQ0FBQTtBQURGO0lBR0EsSUFBRyxtQkFBSDtNQUNFLElBQUcsSUFBQyxDQUFBLGNBQWMsQ0FBQyxNQUFoQixLQUEwQixNQUE3QjtRQUNFLElBQUMsQ0FBQSxNQUFNLENBQUMsUUFBUixDQUFpQixRQUFBLENBQVMsSUFBQyxDQUFBLGNBQWMsQ0FBQyxLQUF6QixFQUFnQyxFQUFoQyxDQUFqQjtRQUNBLElBQUMsQ0FBQSxNQUFNLENBQUMsYUFBUixDQUFzQixJQUFDLENBQUEsY0FBYyxDQUFDLFVBQXRDO1FBQ0EsSUFBQyxDQUFBLE1BQU0sQ0FBQyxNQUFSLENBQUEsRUFIRjtPQUFBLE1BQUE7UUFLRSxJQUFDLENBQUEsTUFBTSxDQUFDLGNBQVIsQ0FBQSxFQUxGO09BREY7O0lBT0EsSUFBQyxDQUFBLFFBQUQsR0FBWTtJQUVaLElBQUEsQ0FBTyxNQUFNLENBQUMsTUFBZDtNQUNFLElBQUEsR0FBTztNQUNQLEtBQUEsR0FBUSxHQUFHLENBQUMsV0FBSixDQUFnQixJQUFoQixDQUFxQixDQUFDO01BQzlCLEdBQUcsQ0FBQyxJQUFKLENBQUE7TUFDQSxHQUFHLENBQUMsT0FBSixDQUFZLE9BQVosRUFBcUIsRUFBckIsRUFBeUIsUUFBekI7TUFDQSxHQUFHLENBQUMsUUFBSixDQUFhLElBQWIsRUFBbUIsQ0FBQyxJQUFDLENBQUEsY0FBYyxDQUFDLEtBQWhCLEdBQXdCLEtBQXpCLENBQUEsR0FBa0MsQ0FBckQsRUFBd0QsSUFBQyxDQUFBLE1BQUQsR0FBVSxFQUFsRTthQUNBLEdBQUcsQ0FBQyxPQUFKLENBQUEsRUFORjs7RUE5RE07O21CQXNFUixVQUFBLEdBQVksU0FBQTtXQUFHLElBQUMsQ0FBQTtFQUFKOzttQkFFWixJQUFBLEdBQU0sU0FBQyxRQUFEO1dBQWMsSUFBQyxDQUFBLE1BQUQsQ0FBUSxRQUFSO0VBQWQ7O21CQU1OLGNBQUEsR0FBZ0IsU0FBQyxJQUFELEVBQU8sTUFBUDtBQUNkLFFBQUE7SUFBQSxJQUFBLEdBQU8sSUFBQyxDQUFBLE1BQU0sQ0FBQyxjQUFSLENBQXVCLElBQXZCLEVBQTZCLE1BQTdCO0lBQ1AsVUFBQSxHQUFhLEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBVCxDQUF1QixJQUF2QjtJQUViLGFBQUEsR0FBZ0IsSUFBQyxDQUFBLFdBQVcsQ0FBQyxVQUFiLENBQXdCLFVBQVUsQ0FBQyxHQUFuQztJQUNoQixVQUFBLEdBQWE7QUFHYixZQUFPLElBQUMsQ0FBQSxjQUFjLENBQUMsV0FBdkI7QUFBQSxXQUNPLFVBRFA7UUFFSSxJQUFHLGFBQWEsQ0FBQyxNQUFqQjtVQUNFLFVBQUEsR0FBZ0IsZ0NBQUgsR0FBa0MsYUFBYSxDQUFDLFVBQWhELEdBQWdFLElBRC9FOztBQURHO0FBRFAsV0FJTyxZQUpQO1FBS0ksSUFBRyxhQUFhLENBQUMsTUFBakI7VUFDRSxVQUFBLEdBQWdCLGdDQUFILEdBQWtDLGFBQWEsQ0FBQyxVQUFoRCxHQUFnRSxJQUQvRTtTQUFBLE1BQUE7VUFHRSxVQUFBLEdBQWdCLGdDQUFILEdBQWtDLGFBQWEsQ0FBQyxVQUFkLEdBQTJCLElBQTdELEdBQUEsT0FIZjs7QUFERztBQUpQO0FBVUksY0FBVSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsYUFBVCxFQUF3QiwwQ0FBQSxHQUEyQyxJQUFDLENBQUEsY0FBYyxDQUFDLFdBQW5GO0FBVmQ7SUFZQSxRQUFBLEdBQVcsYUFBYSxDQUFDO0lBQ3pCLFVBQUEsR0FBYSxVQUFVLENBQUM7SUFHeEIsUUFBQSxHQUFXLElBQUMsQ0FBQSxTQUFTLENBQUMsWUFBWCxDQUF3QixVQUFVLENBQUMsR0FBbkMsQ0FBdUMsQ0FBQztJQUNuRCxRQUFBLEdBQVcsSUFBQyxDQUFBLFNBQVMsQ0FBQyxZQUFYLENBQXdCLGFBQWEsQ0FBQyxJQUF0QyxDQUEyQyxDQUFDO0lBSXZELElBQUcsUUFBQSxLQUFZLEdBQVosSUFBb0IsUUFBQSxLQUFZLEdBQW5DO01BQ0UsVUFBQSxHQURGO0tBQUEsTUFFSyxJQUFHLFFBQUEsS0FBWSxHQUFaLElBQW9CLFFBQUEsS0FBWSxHQUFuQztNQUNILFVBQUEsR0FERzs7QUFHTCxXQUFPLENBQUMsUUFBRCxFQUFXLFVBQVgsRUFBdUIsVUFBdkI7RUFsQ087O21CQW9DaEIsYUFBQSxHQUFlLFNBQUMsR0FBRCxFQUFNLE1BQU47QUFDYixRQUFBO0lBQUEsR0FBQSxHQUFNLEdBQUcsQ0FBQztJQUNWLE1BQUEsR0FBUztJQUNULFVBQUEsR0FBYSxHQUFHLENBQUM7SUFDakIsSUFBMkMsMkJBQTNDO01BQUEsVUFBQSxJQUFjLEdBQUEsR0FBSSxHQUFHLENBQUMsZ0JBQXRCOztBQUNBLFdBQU8sQ0FBQyxHQUFELEVBQU0sTUFBTixFQUFjLFVBQWQ7RUFMTTs7bUJBT2YsWUFBQSxHQUFjLFNBQUMsV0FBRDtBQUNaLFFBQUE7SUFBQSxNQUFBLEdBQ0U7TUFBQSxPQUFBLEVBQVMsS0FBVDtNQUNBLFNBQUEsRUFBVyxJQURYOztJQUdGLENBQUMsQ0FBQyxNQUFGLENBQVMsTUFBVCxFQUFpQixXQUFqQjtJQUNBLFdBQUEsR0FBYyxDQUFDLENBQUMsSUFBRixDQUFPLENBQUMsQ0FBQyxJQUFGLENBQU8sSUFBQyxDQUFBLFdBQVIsQ0FBb0IsQ0FBQyxNQUE1QixDQUFtQyxDQUFDO0lBQ2xELFVBQUEsR0FBaUIsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVQsQ0FBbUI7TUFDbEMsSUFBQSxFQUFNLE1BQU0sQ0FBQyxJQURxQjtNQUVsQyxRQUFBLEVBQVUsSUFBQyxDQUFBLGdCQUFELEdBQW9CLENBQUksTUFBTSxDQUFDLE9BQVYsR0FBdUIsR0FBdkIsR0FBZ0MsRUFBakMsQ0FGSTtNQUdsQyxJQUFBLEVBQVMsTUFBTSxDQUFDLE9BQVYsR0FBdUIsUUFBdkIsR0FBcUMsSUFBQyxDQUFBLFlBSFY7TUFJbEMsU0FBQSxFQUFjLE1BQU0sQ0FBQyxPQUFWLEdBQXVCLEtBQXZCLEdBQWtDLElBSlg7S0FBbkI7QUFNakI7QUFBQSxTQUFBLHFEQUFBOztNQUNFLElBQUcsV0FBSDtRQUNFLEtBQUEsR0FBUSxHQUFHLENBQUMsS0FBSixDQUFVLEdBQVY7UUFDUixjQUFBLEdBQXFCLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxVQUFULENBQW9CLEtBQU0sQ0FBQSxDQUFBLENBQTFCO1FBRXJCLElBQUcsS0FBSyxDQUFDLE1BQU4sR0FBZSxDQUFmLElBQXFCLEtBQU0sQ0FBQSxDQUFBLENBQU4sS0FBWSxHQUFwQztVQUNFLGNBQWMsQ0FBQyxlQUFmLENBQUEsRUFERjs7UUFHQSxVQUFVLENBQUMsYUFBWCxDQUF5QixLQUF6QixFQUFnQyxjQUFoQyxFQVBGOztBQURGO0lBVUEsSUFBRyxJQUFDLENBQUEsZ0JBQWlCLENBQUEsSUFBQyxDQUFBLGdCQUFnQixDQUFDLE1BQWxCLEdBQTJCLENBQTNCLENBQWxCLEtBQW1ELEdBQXREO01BQ0UsVUFBVSxDQUFDLFdBQVgsQ0FBQSxFQURGOztJQUdBLElBQTRDLHdCQUE1QztNQUFBLFVBQVUsQ0FBQyxXQUFYLENBQXVCLE1BQU0sQ0FBQyxTQUE5QixFQUFBOztXQUNBLFdBQVcsQ0FBQyxJQUFaLENBQWlCLFVBQWpCO0VBM0JZOzttQkE2QmQsVUFBQSxHQUFZLFNBQUMsSUFBRCxFQUFPLFNBQVA7QUFDVixRQUFBOztNQURpQixZQUFVOztJQUMzQixTQUFBLEdBQVksQ0FBQyxDQUFDLElBQUYsQ0FBTyxDQUFDLENBQUMsSUFBRixDQUFPLElBQUMsQ0FBQSxXQUFSLENBQW9CLENBQUMsTUFBNUIsQ0FBbUMsQ0FBQztJQUNoRCxZQUFBLEdBQW1CLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFULENBQWlCO01BQ2xDLFNBQUEsRUFBVyxJQUR1QjtNQUVsQyxRQUFBLEVBQVUsSUFBQyxDQUFBLGdCQUZ1QjtLQUFqQixFQUdiLElBQUMsQ0FBQSxjQUFlLENBQUEsV0FBQSxDQUFoQixLQUFnQyxNQUhuQjtJQUtuQixJQUF1QyxpQkFBdkM7TUFBQSxZQUFZLENBQUMsV0FBYixDQUF5QixTQUF6QixFQUFBOztJQUNBLFNBQVMsQ0FBQyxJQUFWLENBQWUsWUFBZjtJQUVBLElBQUcsSUFBQyxDQUFBLGdCQUFpQixDQUFBLElBQUMsQ0FBQSxnQkFBZ0IsQ0FBQyxNQUFsQixHQUEyQixDQUEzQixDQUFsQixLQUFtRCxHQUF0RDthQUNFLFlBQVksQ0FBQyxNQUFiLENBQUEsRUFERjs7RUFWVTs7RUFhWixZQUFBLEdBQWUsU0FBQyxJQUFELEVBQU8sR0FBUDtXQUFlLElBQUEsR0FBTyxDQUFJLEdBQUgsR0FBWSxHQUFaLEdBQXFCLEVBQXRCO0VBQXRCOzttQkFDZixXQUFBLEdBQWEsU0FBQyxJQUFELEVBQU8sR0FBUDtBQUNYLFFBQUE7O01BRGtCLE1BQUk7O0lBQ3RCLENBQUEsR0FBSSxJQUFJLENBQUMsS0FBTCxDQUFXLEtBQVg7SUFDSixDQUFBLENBQUUsZUFBRixFQUFtQixDQUFFLENBQUEsQ0FBQSxDQUFyQixFQUF5QixHQUF6QjtXQUNBLElBQUMsQ0FBQSxnQkFBRCxHQUFvQixZQUFBLENBQWEsQ0FBRSxDQUFBLENBQUEsQ0FBZixFQUFtQixHQUFuQjtFQUhUOzttQkFLYixNQUFBLEdBQVEsU0FBQyxJQUFEO0FBQ04sUUFBQTtJQUFBLENBQUEsQ0FBRSxVQUFGLEVBQWMsSUFBZDtJQUNBLElBQUMsQ0FBQSxVQUFELENBQUE7SUFDQSxJQUFDLENBQUEsV0FBVyxDQUFDLEtBQWIsQ0FBQTtJQUNBLEtBQUEsR0FBUSxDQUFDLENBQUMsSUFBRixDQUFPLENBQUMsQ0FBQyxJQUFGLENBQU8sSUFBQyxDQUFBLFdBQVIsQ0FBb0IsQ0FBQyxNQUE1QjtJQUVSLElBQUEsR0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLE9BQU8sQ0FBQztJQUN4QixJQUFBO0FBQU8sY0FBTyxJQUFQO0FBQUEsYUFDQSxRQURBO2lCQUVILElBQUksQ0FBQztBQUZGLGFBR0EsUUFIQTtpQkFJSCxJQUFJLENBQUM7QUFKRixhQUtBLEtBTEE7aUJBTUgsSUFBSSxDQUFDO0FBTkYsYUFPQSxjQVBBO2lCQVFILElBQUksQ0FBQztBQVJGLGFBU0EsWUFUQTtpQkFVSCxJQUFJLENBQUM7QUFWRixhQVdBLGFBWEE7aUJBWUgsSUFBSSxDQUFDO0FBWkY7aUJBY0gsSUFBSSxDQUFDO0FBZEY7O0lBZ0JQLFFBQUEsR0FBZSxJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBVCxDQUFBLENBQWtCLENBQUMsT0FBbkIsQ0FBMkIsSUFBM0I7SUFDZixLQUFLLENBQUMsU0FBUyxDQUFDLElBQWhCLENBQXFCLFFBQXJCO0lBQ0EsSUFBbUMsa0JBQW5DO2FBQUEsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFqQixDQUFzQixRQUF0QixFQUFBOztFQXpCTTs7RUEyQlIsUUFBQSxHQUFXLFNBQUMsU0FBRCxFQUFZLE9BQVo7QUFDVCxRQUFBO0lBQUEsU0FBQSxHQUFZLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDO0lBQzFCLElBQUEsR0FBTztJQUVQLElBQUcsUUFBQSxDQUFTLFNBQVQsRUFBb0IsRUFBcEIsQ0FBQSxHQUEwQixRQUFBLENBQVMsT0FBVCxFQUFrQixFQUFsQixDQUE3QjtNQUNFLFNBQUEsR0FBWSxHQUFHLENBQUMsSUFBSSxDQUFDLElBQUksQ0FBQyxLQUQ1QjtLQUFBLE1BQUE7TUFHRSxJQUFBO0FBQU8sZ0JBQU8sSUFBSSxDQUFDLEdBQUwsQ0FBUyxPQUFBLEdBQVUsU0FBbkIsQ0FBUDtBQUFBLGVBQ0EsQ0FEQTttQkFDTztBQURQLGVBRUEsQ0FGQTttQkFFTztBQUZQLGVBR0EsQ0FIQTttQkFHTztBQUhQO21CQUlBLFVBQUEsR0FBVztBQUpYO1dBSFQ7O0FBU0EsV0FBTztNQUFDLElBQUEsRUFBTSxTQUFQO01BQWtCLElBQUEsRUFBTSxJQUF4Qjs7RUFiRTs7bUJBZVgsU0FBQSxHQUFXLFNBQUMsVUFBRCxFQUFhLFNBQWIsRUFBd0IsYUFBeEIsRUFBdUMsWUFBdkM7QUFDVCxRQUFBO0lBQUEsQ0FBQSxDQUFFLFdBQUYsRUFBZSxVQUFmLEVBQTJCLFNBQTNCLEVBQXNDLGFBQXRDLEVBQXFELFlBQXJEO0lBQ0EsU0FBQSxHQUFZLENBQUMsQ0FBQyxJQUFGLENBQU8sQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsV0FBUixDQUFvQixDQUFDLE1BQTVCLENBQW1DLENBQUM7SUFFaEQsVUFBQSxHQUFhO0lBQ2IsYUFBQSxHQUFnQjtJQUNoQixJQUFHLENBQUMsQ0FBQyxPQUFGLENBQVUsSUFBQyxDQUFBLGFBQVgsQ0FBSDtNQUNFLElBQUMsQ0FBQSxnQkFBRCxHQUFvQixTQUFTLENBQUMsTUFBVixHQUFtQjtNQUN2QyxJQUFDLENBQUEsa0JBQUQsR0FBc0IsY0FGeEI7S0FBQSxNQUFBO01BSUUsVUFBQSxHQUFhLFNBQVUsQ0FBQSxJQUFDLENBQUEsZ0JBQUQ7TUFDdkIsYUFBQSxHQUFnQixJQUFDLENBQUEsbUJBTG5COztJQU9BLFdBQUEsR0FBYyxVQUFVLENBQUMsWUFBWCxDQUFBO0lBQ2QsVUFBQSxHQUFhLFNBQVMsQ0FBQyxZQUFWLENBQUE7QUFDYjtTQUFBLHVEQUFBOztNQUNFLFVBQUEsR0FBYSxZQUFhLENBQUEsQ0FBQTtNQUMxQixTQUFBLEdBQVksVUFBVSxDQUFDLFlBQVgsQ0FBQSxDQUEwQixDQUFBLGFBQWMsQ0FBQSxDQUFBLENBQWQ7TUFDdEMsT0FBQSxHQUFVLFVBQVcsQ0FBQSxVQUFBOztZQUNOLENBQUEsS0FBQSxJQUFVOzttQkFDekIsSUFBQyxDQUFBLGFBQWMsQ0FBQSxLQUFBLENBQU0sQ0FBQyxJQUF0QixDQUEyQixRQUFBLENBQVMsU0FBUyxDQUFDLElBQW5CLEVBQXlCLE9BQU8sQ0FBQyxJQUFqQyxDQUEzQjtBQUxGOztFQWZTOzttQkF1QlgsVUFBQSxHQUFZLFNBQUMsTUFBRDtBQUNWLFFBQUE7O01BRFcsU0FBTzs7SUFDbEIsSUFBYyw2QkFBZDtBQUFBLGFBQUE7O0lBQ0EsQ0FBQSxDQUFFLGFBQUEsR0FBYyxNQUFkLEdBQXFCLEdBQXZCO0lBQ0EsU0FBQSxHQUFZLENBQUMsQ0FBQyxJQUFGLENBQU8sQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsV0FBUixDQUFvQixDQUFDLE1BQTVCLENBQW1DLENBQUM7QUFDaEQ7QUFBQSxTQUFBLFFBQUE7O01BQ0UsTUFBQSxHQUFTO0FBQ1QsV0FBQSxtQ0FBQTs7UUFDRSxNQUFNLENBQUMsSUFBUCxDQUFZLElBQVo7QUFERjtNQUVBLFNBQVUsQ0FBQSxJQUFDLENBQUEsZ0JBQUQsQ0FBa0IsQ0FBQyxXQUE3QixDQUNNLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFULENBQWMsSUFBZCxFQUFvQixJQUFwQixFQUEwQixNQUExQixDQUROLEVBQ3lDLENBRHpDO0FBSkY7QUFRQTtBQUFBLFNBQUEsd0NBQUE7O01BQ0UsUUFBUSxDQUFDLFFBQVQsQ0FBa0IsSUFBbEI7QUFERjtJQUdBLElBQUMsQ0FBQSxhQUFELEdBQWlCO1dBQ2pCLElBQUMsQ0FBQSxnQkFBRCxHQUFvQjtFQWhCVjs7bUJBa0JaLFdBQUEsR0FBYSxTQUFDLE9BQUQsRUFBVSxLQUFWO0FBQ1gsUUFBQTtJQUFBLENBQUEsQ0FBRSxhQUFGLEVBQWlCLE9BQWpCLEVBQTBCLEtBQTFCOztNQUNBLFFBQVM7O0lBQ1QsSUFBQSxDQUFjLENBQUMsQ0FBQyxJQUFGLENBQU8sQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsV0FBUixDQUFvQixDQUFDLE1BQTVCLENBQW1DLENBQUMsSUFBbEQ7QUFBQSxhQUFBOztJQUNBLFdBQUEsR0FBYyxDQUFDLENBQUMsSUFBRixDQUFPLENBQUMsQ0FBQyxJQUFGLENBQU8sSUFBQyxDQUFBLFdBQVIsQ0FBb0IsQ0FBQyxNQUE1QixDQUFtQyxDQUFDO0lBQ2xELFNBQUEsR0FBWSxDQUFDLENBQUMsSUFBRixDQUFPLENBQUMsQ0FBQyxJQUFGLENBQU8sSUFBQyxDQUFBLFdBQVIsQ0FBb0IsQ0FBQyxNQUE1QixDQUFtQyxDQUFDO0lBRWhELElBQW9FLFdBQVcsQ0FBQyxNQUFaLEdBQXFCLEtBQXpGO0FBQUEsWUFBVSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsYUFBVCxFQUF3Qiw2QkFBeEIsRUFBVjs7SUFDQSxRQUFBLEdBQWUsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQVQsQ0FBZ0IsV0FBWSxrQ0FBNUIsRUFBMkQ7TUFBQyxTQUFBLEVBQVcsT0FBWjtLQUEzRDtJQUNmLElBQUMsQ0FBQSxtQkFBbUIsQ0FBQyxJQUFyQixDQUEwQixRQUExQjtJQUtBLFlBQUEsR0FBbUIsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQVQsQ0FBZ0IsU0FBVSxnQ0FBMUIsRUFBdUQ7TUFBQyxTQUFBLEVBQVcsT0FBWjtLQUF2RDtJQUNuQixJQUFHLElBQUMsQ0FBQSxjQUFlLENBQUEsV0FBQSxDQUFoQixLQUFnQyxNQUFuQzthQUNFLElBQUMsQ0FBQSxpQkFBaUIsQ0FBQyxJQUFuQixDQUF3QixZQUF4QixFQURGOztFQWZXOztFQWtCYixZQUFBLEdBQWUsU0FBQyxJQUFEO1dBQVUsSUFBSSxDQUFDLEtBQUwsQ0FBVyx5QkFBWDtFQUFWOzttQkFDZixhQUFBLEdBQWUsU0FBQyxJQUFEO0FBQ2IsUUFBQTtJQUFBLEtBQUEsR0FBUSxZQUFBLENBQWEsSUFBYjtJQUNSLEdBQUEsR0FBTSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQztJQUN4QixPQUFBLEdBQVU7SUFDVixTQUFBLEdBQVk7SUFFWixJQUFHLGFBQUg7TUFDRSxPQUFBOztBQUFXO0FBQUE7YUFBQSxxQ0FBQTs7dUJBQUEsQ0FBQyxDQUFDLElBQUYsQ0FBQTtBQUFBOztXQURiO0tBQUEsTUFBQTtBQUdFLGFBQU8sS0FIVDs7SUFLQSxZQUFBLEdBQWUsU0FBQTthQUFPLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxhQUFULEVBQXdCLGlCQUFBLEdBQWtCLEtBQU0sQ0FBQSxDQUFBLENBQWhEO0lBQVA7QUFFZixTQUFBLHlDQUFBOztNQUNFLE1BQUEsR0FBUyxNQUFNLENBQUMsS0FBUCxDQUFhLGdDQUFiO01BQ1QsSUFBNEIsY0FBNUI7QUFBQSxjQUFNLFlBQUEsQ0FBQSxFQUFOOztNQUVBLFdBQUEsR0FBYyxRQUFBLENBQVMsTUFBTyxDQUFBLENBQUEsQ0FBaEIsRUFBb0IsRUFBcEIsQ0FBQSxHQUEwQjtNQUN4QyxRQUFBLEdBQVcsR0FBRyxDQUFDO0FBQ2YsY0FBTyxNQUFPLENBQUEsQ0FBQSxDQUFkO0FBQUEsYUFDTyxHQURQO1VBRUksUUFBQSxHQUFXLEdBQUcsQ0FBQztBQURaO0FBRFAsYUFHTyxHQUhQO1VBSUksUUFBQSxHQUFXLEdBQUcsQ0FBQztBQURaO0FBSFAsYUFLTyxHQUxQO1VBTUksUUFBQSxHQUFXLEdBQUcsQ0FBQztBQURaO0FBTFAsYUFPTyxHQVBQO1VBUUksUUFBQSxHQUFXLEdBQUcsQ0FBQztBQVJuQjtNQVVBLFFBQUEsR0FBVztNQUNYLE1BQUEsR0FBUyxNQUFPLENBQUEsQ0FBQTtBQUNoQixjQUFPLE1BQU8sQ0FBQSxDQUFBLENBQWQ7QUFBQSxhQUNPLEdBRFA7VUFFSSxRQUFBLEdBQWUsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVQsQ0FBc0IsTUFBdEIsQ0FBNkIsQ0FBQyxXQUE5QixDQUEwQyxRQUExQztBQURaO0FBRFAsYUFHTyxHQUhQO1VBSUksUUFBQSxHQUFlLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxjQUFULENBQXdCLE1BQXhCLENBQStCLENBQUMsV0FBaEMsQ0FBNEMsUUFBNUM7QUFKbkI7TUFNQSxTQUFTLENBQUMsSUFBVixDQUFlO1FBQUMsR0FBQSxFQUFLLFdBQU47UUFBbUIsUUFBQSxFQUFVLFFBQTdCO09BQWY7QUF4QkY7QUEwQkEsV0FBTztFQXZDTTs7RUF5Q2YsY0FBQSxHQUFpQixTQUFDLElBQUQ7V0FBVSxJQUFJLENBQUMsS0FBTCxDQUFXLHNCQUFYO0VBQVY7O21CQUNqQixVQUFBLEdBQVksU0FBQyxJQUFEO0FBQ1YsUUFBQTtJQUFBLEtBQUEsR0FBUSxjQUFBLENBQWUsSUFBZjtJQUNSLElBQUEsR0FBTyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQztJQUN2QixJQUFBLEdBQU87SUFFUCxJQUFHLGFBQUg7QUFDRSxjQUFPLEtBQU0sQ0FBQSxDQUFBLENBQWI7QUFBQSxhQUNPLElBRFA7VUFFSSxJQUFBLEdBQU8sSUFBSSxDQUFDO0FBRFQ7QUFEUCxhQUdPLElBSFA7VUFJSSxJQUFBLEdBQU8sSUFBSSxDQUFDO0FBRFQ7QUFIUCxhQUtPLElBTFA7VUFNSSxJQUFBLEdBQU8sSUFBSSxDQUFDO0FBRFQ7QUFMUCxhQU9PLElBUFA7VUFRSSxJQUFBLEdBQU8sSUFBSSxDQUFDO0FBRFQ7QUFQUCxhQVNPLElBVFA7VUFVSSxJQUFBLEdBQU8sSUFBSSxDQUFDO0FBRFQ7QUFUUCxhQVdPLElBWFA7VUFZSSxJQUFBLEdBQU8sSUFBSSxDQUFDO0FBRFQ7QUFYUDtBQWNJLGdCQUFVLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxhQUFULEVBQXdCLHVCQUFBLEdBQXdCLEtBQU0sQ0FBQSxDQUFBLENBQXREO0FBZGQ7QUFlQSxhQUFXLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxNQUFULENBQWdCLElBQWhCLEVBaEJiO0tBQUEsTUFBQTtBQWtCRSxhQUFPLEtBbEJUOztFQUxVOztFQXlCWix5QkFBQSxHQUE0QixTQUFDLElBQUQ7V0FBVSxJQUFJLENBQUMsS0FBTCxDQUFXLDRCQUFYO0VBQVY7O21CQUM1QixxQkFBQSxHQUF1QixTQUFDLElBQUQ7QUFDckIsUUFBQTtJQUFBLEtBQUEsR0FBUSx5QkFBQSxDQUEwQixJQUExQjtJQUNSLElBQUcsYUFBSDtNQUNFLElBQUEsR0FBTyxLQUFNLENBQUEsQ0FBQTtNQUNiLFFBQUEsR0FBVyxLQUFNLENBQUEsQ0FBQTtNQUVqQixPQUFBLEdBQVUsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUM7TUFDNUIsR0FBQSxHQUFTLFFBQUEsS0FBWSxHQUFmLEdBQXdCLE9BQU8sQ0FBQyxLQUFoQyxHQUEyQyxPQUFPLENBQUM7QUFDekQsYUFBVyxJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBVCxDQUFzQixJQUF0QixDQUEyQixDQUFDLFdBQTVCLENBQXdDLEdBQXhDLEVBTmI7S0FBQSxNQUFBO0FBT0ssYUFBTyxLQVBaOztFQUZxQjs7bUJBV3ZCLGNBQUEsR0FBZ0IsU0FBQyxJQUFEO0FBQ2QsUUFBQTtJQUFBLFNBQUEsR0FBWSxJQUFDLENBQUEsY0FBZSxDQUFBLFdBQUE7SUFDNUIsU0FBQSxHQUFZLElBQUMsQ0FBQSxjQUFlLENBQUEsV0FBQTtJQUM1QixVQUFBLEdBQWEsSUFBQyxDQUFBLGNBQWUsQ0FBQSxZQUFBO0lBQzdCLFNBQUEsR0FBWSxJQUFDLENBQUEsY0FBZSxDQUFBLHFCQUFBO0lBRTVCLEtBQUEsR0FBUSxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQztJQUM1QixhQUFBLEdBQW1CLFNBQUEsS0FBYSxLQUFoQixHQUEyQixLQUFLLENBQUMsR0FBakMsR0FBMEMsS0FBSyxDQUFDO0lBRWhFLE1BQUEsR0FBUyxTQUFDLElBQUQsRUFBTyxJQUFQOztRQUFPLE9BQUs7O2FBQ2YsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVQsQ0FBb0IsSUFBcEIsQ0FBeUIsQ0FDM0IsT0FERSxDQUNNLFNBRE4sRUFDaUIsU0FEakIsRUFDNEIsVUFENUIsQ0FDdUMsQ0FDekMsd0JBRkUsQ0FFdUIsSUFGdkI7SUFERztJQUtULEtBQUEsR0FBUSxJQUFJLENBQUMsS0FBTCxDQUFXLGtDQUFYO0lBQ1IsSUFBRyxhQUFIO01BQ0UsU0FBQSxHQUFZLEtBQU0sQ0FBQSxDQUFBO01BQ2xCLFNBQUEsR0FBWSxLQUFNLENBQUEsQ0FBQTtNQUNsQixVQUFBLEdBQWEsS0FBTSxDQUFBLENBQUE7TUFDbkIsSUFBQSxHQUFPLEtBQU0sQ0FBQSxDQUFBO01BQ04sSUFBRyxJQUFIO2VBQWEsTUFBQSxDQUFPLElBQVAsRUFBYjtPQUFBLE1BQUE7ZUFBK0IsS0FBL0I7T0FMVDs7SUFPQSxLQUFBLEdBQVEsSUFBSSxDQUFDLEtBQUwsQ0FBVyxrQkFBWDtJQUNSLElBQUcsYUFBSDtNQUNFLElBQUEsR0FBTztNQUNQLElBQUEsR0FBTyxLQUFNLENBQUEsQ0FBQTtBQUNiLGNBQU8sS0FBTSxDQUFBLENBQUEsQ0FBYjtBQUFBLGFBQ08sS0FEUDtVQUVJLFVBQUEsR0FBYTtVQUNiLFNBQUEsR0FBWTtBQUZUO0FBRFAsYUFJTyxRQUpQO0FBQUEsYUFJaUIsU0FKakI7VUFLSSxTQUFBLEdBQVk7VUFDWixVQUFBLEdBQWE7QUFGQTtBQUpqQixhQU9PLFFBUFA7VUFRSSxTQUFBLEdBQVk7QUFEVDtBQVBQLGFBU08sS0FUUDtVQVVJLElBQUEsR0FBTyxLQUFLLENBQUM7VUFDYixJQUFDLENBQUEsY0FBZSxDQUFBLHFCQUFBLENBQWhCLEdBQXlDO0FBRnRDO0FBVFAsYUFZTyxRQVpQO1VBYUksSUFBQSxHQUFPLEtBQUssQ0FBQztVQUNiLElBQUMsQ0FBQSxjQUFlLENBQUEscUJBQUEsQ0FBaEIsR0FBeUM7QUFkN0M7TUFlTyxJQUFHLElBQUg7ZUFBYSxNQUFBLENBQU8sSUFBUCxFQUFhLElBQWIsRUFBYjtPQUFBLE1BQUE7ZUFBcUMsS0FBckM7T0FsQlQ7O0FBb0JBLFdBQU8sTUFBQSxDQUFPLElBQVA7RUEzQ087O21CQTZDaEIsY0FBQSxHQUFnQixTQUFDLFdBQUQ7QUFDZCxRQUFBO0lBQUEsS0FBQSxHQUFRLENBQUMsQ0FBQyxJQUFGLENBQU8sQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsV0FBUixDQUFvQixDQUFDLE1BQTVCO0lBQ1IsV0FBQSxHQUFjLEtBQUssQ0FBQztJQUNwQixTQUFBLEdBQVksS0FBSyxDQUFDO0lBRWxCLElBQUcsV0FBVyxDQUFDLE1BQVosR0FBcUIsU0FBUyxDQUFDLE1BQWxDO0FBQ0UsWUFBVSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsYUFBVCxFQUF3QixxQ0FBeEIsRUFEWjs7SUFJQSxJQUFHLEtBQUssQ0FBQyxHQUFUO0FBQ0U7QUFBQSxXQUFBLDZDQUFBOztRQUNFLElBQUcseUJBQUEsQ0FBMEIsV0FBWSxDQUFBLENBQUEsQ0FBdEMsQ0FBSDtVQUNFLGtCQUFBLEdBQXFCLElBQUMsQ0FBQSxxQkFBRCxDQUF1QixXQUFZLENBQUEsQ0FBQSxDQUFuQztVQUNyQixRQUFRLENBQUMsV0FBVCxDQUFxQixrQkFBckIsRUFBeUMsQ0FBekMsRUFGRjtTQUFBLE1BR0ssSUFBRyxjQUFBLENBQWUsV0FBWSxDQUFBLENBQUEsQ0FBM0IsQ0FBSDtVQUNILE1BQUEsR0FBUyxJQUFDLENBQUEsVUFBRCxDQUFZLFdBQVksQ0FBQSxDQUFBLENBQXhCO1VBQ1QsUUFBUSxDQUFDLFdBQVQsQ0FBcUIsTUFBckIsRUFBNkIsQ0FBN0IsRUFGRztTQUFBLE1BQUE7VUFJSCxVQUFBLEdBQWEsSUFBQyxDQUFBLGNBQUQsQ0FBZ0IsV0FBWSxDQUFBLENBQUEsQ0FBNUI7VUFDYixJQUE0RCxVQUE1RDtZQUFBLFFBQVEsQ0FBQyxXQUFULENBQXFCLElBQUMsQ0FBQSxjQUFELENBQWdCLFdBQVksQ0FBQSxDQUFBLENBQTVCLENBQXJCLEVBQXNELENBQXRELEVBQUE7V0FMRzs7QUFKUCxPQURGO0tBQUEsTUFBQTtBQVlFO0FBQUEsV0FBQSxnREFBQTs7UUFDRSxJQUFBLENBQU8seUJBQUEsQ0FBMEIsV0FBWSxDQUFBLENBQUEsQ0FBdEMsQ0FBUDtVQUNFLFVBQUEsR0FBYSxJQUFDLENBQUEsY0FBRCxDQUFnQixXQUFZLENBQUEsQ0FBQSxDQUE1QjtVQUNiLElBQTBELFVBQTFEO1lBQUEsSUFBSSxDQUFDLGFBQUwsQ0FBbUIsQ0FBbkIsRUFBc0IsSUFBQyxDQUFBLGNBQUQsQ0FBZ0IsV0FBWSxDQUFBLENBQUEsQ0FBNUIsQ0FBdEIsRUFBQTtXQUZGOztBQURGLE9BWkY7O0lBa0JBLElBQUcsS0FBSyxDQUFDLElBQVQ7QUFDRTtBQUFBO1dBQUEsZ0RBQUE7O1FBQ0Usa0JBQUEsR0FBcUIsSUFBQyxDQUFBLHFCQUFELENBQXVCLFdBQVksQ0FBQSxDQUFBLENBQW5DO1FBQ3JCLElBQStDLDBCQUEvQztVQUFBLElBQUksQ0FBQyxlQUFMLENBQXFCLENBQXJCLEVBQXdCLGtCQUF4QixFQUFBOztRQUVBLE1BQUEsR0FBUyxJQUFDLENBQUEsVUFBRCxDQUFZLFdBQVksQ0FBQSxDQUFBLENBQXhCO1FBQ1QsSUFBNkIsY0FBN0I7VUFBQSxJQUFJLENBQUMsU0FBTCxDQUFlLENBQWYsRUFBa0IsTUFBbEIsRUFBQTs7UUFFQSxVQUFBLEdBQWEsSUFBQyxDQUFBLGFBQUQsQ0FBZSxXQUFZLENBQUEsQ0FBQSxDQUEzQjtRQUNiLElBQUcsa0JBQUg7QUFDRTs7O0FBQ0c7bUJBQUEsOENBQUE7OzhCQUFBLElBQUksQ0FBQyxXQUFMLENBQWlCLFNBQVMsQ0FBQyxHQUEzQixFQUFnQyxTQUFTLENBQUMsUUFBMUM7QUFBQTs7a0JBREg7V0FBQSxhQUFBO1lBRU07QUFDSixrQkFBVSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsYUFBVCxFQUF3QixnQ0FBQSxHQUFpQyxXQUFZLENBQUEsQ0FBQSxDQUFyRSxFQUhaO1dBREY7U0FBQSxNQUFBOytCQUFBOztBQVJGO3FCQURGOztFQTNCYzs7bUJBMENoQixrQkFBQSxHQUFvQixTQUFDLElBQUQsRUFBTyxVQUFQLEVBQW1CLFNBQW5CLEVBQThCLGFBQTlCLEVBQTZDLFlBQTdDO0FBQ2xCLFFBQUE7SUFBQSxDQUFBLENBQUUsdUJBQUYsRUFBMkIsSUFBM0IsRUFBaUMsVUFBakMsRUFBNkMsU0FBN0MsRUFBd0QsYUFBeEQsRUFBdUUsWUFBdkU7SUFFQSxJQUFHLElBQUEsS0FBUSxHQUFYO01BQ0UsU0FBUyxDQUFDLFdBQVYsQ0FDTSxJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsVUFBVCxDQUFvQixHQUFwQixDQUF3QixDQUMxQix3QkFERSxDQUN1QixHQUFHLENBQUMsSUFBSSxDQUFDLFVBQVUsQ0FBQyxlQUFlLENBQUMsTUFEM0QsQ0FETixFQURGOztJQUtBLElBQUcsQ0FBQyxDQUFDLE9BQUYsQ0FBVSxhQUFWLENBQUEsSUFBNkIsQ0FBQyxDQUFDLE9BQUYsQ0FBVSxZQUFWLENBQWhDO0FBQTZELGFBQTdEOztJQUVBLFlBQUEsR0FBZTtJQUVmLElBQUcsSUFBQSxLQUFRLEdBQVg7TUFDRSxZQUFBLEdBQW1CLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFULENBQWtCO1FBQ25DLFVBQUEsRUFBWSxVQUR1QjtRQUVuQyxTQUFBLEVBQVcsU0FGd0I7UUFHbkMsYUFBQSxFQUFlLGFBSG9CO1FBSW5DLFlBQUEsRUFBYyxZQUpxQjtPQUFsQixFQURyQjs7SUFRQSxJQUFHLElBQUEsS0FBUyxHQUFULElBQUEsSUFBQSxLQUFjLEdBQWpCO01BQ0UsWUFBQSxHQUFtQixJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBVCxDQUFnQjtRQUNqQyxVQUFBLEVBQVksVUFEcUI7UUFFakMsU0FBQSxFQUFXLFNBRnNCO1FBR2pDLGFBQUEsRUFBZSxhQUhrQjtRQUlqQyxZQUFBLEVBQWMsWUFKbUI7T0FBaEIsRUFLZCxJQUFJLENBQUMsV0FBTCxDQUFBLENBTGMsRUFEckI7O0lBUUEsSUFBRyxJQUFBLEtBQVMsR0FBVCxJQUFBLElBQUEsS0FBYyxHQUFqQjtNQUNFLFlBQUEsR0FBbUIsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQVQsQ0FBZ0I7UUFDakMsVUFBQSxFQUFZLFVBRHFCO1FBRWpDLFNBQUEsRUFBVyxTQUZzQjtRQUdqQyxhQUFBLEVBQWUsYUFIa0I7UUFJakMsWUFBQSxFQUFjLFlBSm1CO09BQWhCLEVBS2QsR0FMYyxFQURyQjs7SUFRQSxJQUFHLElBQUEsS0FBUSxHQUFYO01BQ0UsSUFBQyxDQUFBLFNBQUQsQ0FBVyxVQUFYLEVBQXVCLFNBQXZCLEVBQWtDLGFBQWxDLEVBQWlELFlBQWpELEVBREY7O0lBR0EsSUFBd0Msb0JBQXhDO2FBQUEsSUFBQyxDQUFBLGlCQUFpQixDQUFDLElBQW5CLENBQXdCLFlBQXhCLEVBQUE7O0VBdkNrQjs7bUJBeUNwQixvQkFBQSxHQUFzQixTQUFDLElBQUQsRUFBTyxVQUFQLEVBQW1CLFNBQW5CLEVBQThCLGFBQTlCLEVBQTZDLFlBQTdDO0FBQ3BCLFFBQUE7SUFBQSxDQUFBLENBQUUseUJBQUYsRUFBNkIsSUFBN0IsRUFBbUMsVUFBbkMsRUFBK0MsU0FBL0MsRUFBMEQsYUFBMUQsRUFBeUUsWUFBekU7SUFDQSxZQUFBLEdBQWU7SUFDZixJQUFHLElBQUEsS0FBUyxHQUFULElBQUEsSUFBQSxLQUFjLEdBQWQsSUFBQSxJQUFBLEtBQW1CLEdBQW5CLElBQUEsSUFBQSxLQUF3QixHQUF4QixJQUFBLElBQUEsS0FBNkIsR0FBN0IsSUFBQSxJQUFBLEtBQWtDLEdBQXJDO01BQ0UsWUFBQSxHQUFtQixJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBVCxDQUFrQjtRQUNuQyxVQUFBLEVBQVksVUFEdUI7UUFFbkMsU0FBQSxFQUFXLFNBRndCO1FBR25DLGFBQUEsRUFBZSxhQUhvQjtRQUluQyxZQUFBLEVBQWMsWUFKcUI7T0FBbEIsRUFEckI7O0lBUUEsSUFBMEMsb0JBQTFDO2FBQUEsSUFBQyxDQUFBLG1CQUFtQixDQUFDLElBQXJCLENBQTBCLFlBQTFCLEVBQUE7O0VBWG9COzttQkFjdEIsb0JBQUEsR0FBc0IsU0FBQTtBQUNwQixRQUFBO0lBQUEsU0FBQSxHQUFZLENBQUMsQ0FBQyxJQUFGLENBQU8sQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsV0FBUixDQUFvQixDQUFDLE1BQTVCLENBQW1DLENBQUM7SUFDaEQsS0FBQSxHQUFRO0FBQ1IsV0FBTSxLQUFBLElBQVMsU0FBUyxDQUFDLE1BQXpCO01BQ0UsSUFBQSxHQUFPLFNBQVUsQ0FBQSxTQUFTLENBQUMsTUFBVixHQUFtQixLQUFuQjtNQUNqQixJQUFxQyxJQUFBLFlBQWdCLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBOUQ7QUFBQSxlQUFRLFNBQVMsQ0FBQyxNQUFWLEdBQW1CLE1BQTNCOztNQUNBLEtBQUE7SUFIRjtBQUtBLFdBQU8sQ0FBQztFQVJZOzttQkFVdEIsWUFBQSxHQUFjLFNBQUMsU0FBRDtBQUNaLFFBQUE7SUFBQSxDQUFBLENBQUUsZ0JBQUYsRUFBb0IsU0FBcEI7SUFDQSxJQUFjLGlCQUFkO0FBQUEsYUFBQTs7SUFFQSxLQUFBLEdBQVEsQ0FBQyxDQUFDLElBQUYsQ0FBTyxDQUFDLENBQUMsSUFBRixDQUFPLElBQUMsQ0FBQSxXQUFSLENBQW9CLENBQUMsTUFBNUI7SUFDUixTQUFBLEdBQVksS0FBSyxDQUFDO0lBQ2xCLFdBQUEsR0FBYyxLQUFLLENBQUM7SUFDcEIsUUFBQSxHQUFXO0lBQ1gsY0FBQSxHQUFpQjtJQUVqQixJQUFHLFNBQUEsS0FBYSxHQUFoQjtNQUNFLFFBQUEsR0FBZSxJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsT0FBVCxDQUFBLEVBRGpCOztJQUVBLElBQUcsU0FBQSxLQUFhLEdBQWhCO01BQ0UsUUFBQSxHQUFlLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxPQUFULENBQUEsQ0FBa0IsQ0FBQyxRQUFuQixDQUE0QixJQUE1QixFQURqQjs7SUFFQSxJQUFHLFNBQUEsS0FBYSxHQUFoQjtNQUNFLFFBQUEsR0FBZSxJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsWUFBVCxDQUFzQixJQUF0QixDQUEyQixDQUFDLFdBQTVCLENBQXdDLEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLFFBQVEsQ0FBQyxNQUFuRTtNQUNmLGNBQUEsR0FBcUIsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVQsQ0FBc0IsSUFBdEIsQ0FBMkIsQ0FBQyxXQUE1QixDQUF3QyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBbkUsRUFGdkI7O0lBR0EsSUFBRyxTQUFBLEtBQWEsR0FBaEI7TUFDRSxRQUFBLEdBQWUsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVQsQ0FBc0IsSUFBdEIsQ0FBMkIsQ0FBQyxXQUE1QixDQUF3QyxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxRQUFRLENBQUMsTUFBbkU7TUFDZixjQUFBLEdBQXFCLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxZQUFULENBQXNCLElBQXRCLENBQTJCLENBQUMsV0FBNUIsQ0FBd0MsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxDQUFDLE1BQW5FLEVBRnZCOztJQUlBLElBQThDLGdCQUE5QztNQUFBLENBQUMsQ0FBQyxJQUFGLENBQU8sU0FBUCxDQUFpQixDQUFDLFdBQWxCLENBQThCLFFBQTlCLEVBQXdDLENBQXhDLEVBQUE7O0lBQ0EsSUFBMkQsc0JBQTNEO3NEQUFtQixDQUFFLGVBQXJCLENBQXFDLENBQXJDLEVBQXdDLGNBQXhDLFdBQUE7O0VBdEJZOzttQkF5QmQsZ0JBQUEsR0FBa0IsU0FBQyxhQUFEO0FBQ2hCLFFBQUE7SUFBQSxDQUFBLENBQUUsb0JBQUYsRUFBd0IsYUFBeEI7SUFDQSxLQUFBLEdBQVEsQ0FBQyxDQUFDLElBQUYsQ0FBTyxDQUFDLENBQUMsSUFBRixDQUFPLElBQUMsQ0FBQSxXQUFSLENBQW9CLENBQUMsTUFBNUI7SUFDUixTQUFBLEdBQVksS0FBSyxDQUFDO0lBQ2xCLFdBQUEsR0FBYyxLQUFLLENBQUM7SUFDcEIsSUFBRyxDQUFDLENBQUMsT0FBRixDQUFVLFNBQVYsQ0FBQSxJQUF3QixDQUFDLENBQUMsT0FBRixDQUFVLGFBQVYsQ0FBM0I7TUFDRSxJQUFDLENBQUEsVUFBRCxDQUFZLENBQVo7QUFDQSxhQUZGOztJQUlBLGdCQUFBLEdBQW1CLENBQUMsQ0FBQyxJQUFGLENBQU8sU0FBUDtJQUVuQixTQUFBLEdBQVk7QUFDWjtBQUFBLFNBQUEscUNBQUE7O01BQ0UsT0FBQTs7QUFBVzthQUFBLHlEQUFBOztjQUFtQyxhQUFBLElBQVMsR0FBQSxLQUFPO3lCQUFuRDs7QUFBQTs7O01BQ1gsSUFBRyxDQUFDLENBQUMsT0FBRixDQUFVLE9BQVYsQ0FBSDtBQUEyQixpQkFBM0I7O01BRUEsSUFBRyxrQkFBQSxLQUFzQixHQUF6QjtRQUFrQyxTQUFBLEdBQVksS0FBOUM7O01BQ0EsVUFBQSxHQUFhLElBQUMsQ0FBQSxvQkFBRCxDQUFBO01BQ2IsSUFBRyxVQUFBLEtBQWMsQ0FBQyxDQUFsQjtRQUNFLGFBQUEsR0FBZ0I7UUFDaEIsWUFBQSxHQUFlLEtBRmpCO09BQUEsTUFBQTtRQUlFLGFBQUEsR0FBZ0IsU0FBVSxDQUFBLFVBQUE7UUFFMUIsWUFBQTs7QUFBZ0I7QUFBQTtlQUFBLGdEQUFBOztnQkFBdUQsYUFBSyxPQUFMLEVBQUEsQ0FBQTsyQkFBdkQsQ0FBQyxDQUFDOztBQUFGOzs7UUFHaEIsYUFBQTs7QUFBaUI7QUFBQTtlQUFBLGdEQUFBOzt1QkFBd0QsR0FBRyxDQUFDLEdBQUosRUFBQSxhQUFXLFlBQVgsRUFBQSxJQUFBOzJCQUF4RCxHQUFHLENBQUM7O0FBQUo7OztRQUdqQixZQUFBOztBQUFnQjtBQUFBO2VBQUEsZ0RBQUE7O3VCQUFnRCxDQUFDLENBQUMsR0FBRixFQUFBLGFBQVMsYUFBVCxFQUFBLElBQUE7MkJBQWhEOztBQUFBOzs7UUFHaEIsZUFBQTs7QUFBbUI7QUFBQTtlQUFBLGdEQUFBOzt1QkFBbUQsQ0FBQyxDQUFDLEdBQUYsRUFBQSxhQUFTLGFBQVQsRUFBQSxJQUFBOzJCQUFuRDs7QUFBQTs7YUFmckI7O01BaUJBLElBQUcsaUJBQUg7UUFDRSxJQUFDLENBQUEsa0JBQUQsQ0FBb0Isa0JBQXBCLEVBQ0UsYUFERixFQUNpQixnQkFEakIsRUFDbUMsWUFEbkMsRUFDaUQsZUFEakQsRUFERjs7TUFJQSxJQUFHLGtCQUFIO1FBQ0UsSUFBQyxDQUFBLG9CQUFELENBQXNCLGtCQUF0QixFQUNFLFdBQVksQ0FBQSxVQUFBLENBRGQsRUFDMkIsQ0FBQyxDQUFDLElBQUYsQ0FBTyxXQUFQLENBRDNCLEVBRUUsWUFGRixFQUVnQixlQUZoQixFQURGOztBQTNCRjtJQWdDQSxJQUFBLENBQXNCLFNBQXRCO2FBQUEsSUFBQyxDQUFBLFVBQUQsQ0FBWSxDQUFaLEVBQUE7O0VBNUNnQjs7bUJBOENsQixPQUFBLEdBQVMsU0FBQyxNQUFEO0FBQ1AsUUFBQTtJQUFBLENBQUEsQ0FBRSxXQUFGLEVBQWUsTUFBZjtJQUNBLElBQUMsQ0FBQSxVQUFELENBQUE7SUFFQSxJQUFHLE1BQU8sQ0FBQSxVQUFBLENBQVAsS0FBc0IsQ0FBekI7TUFDRSxJQUFDLENBQUEsWUFBRCxDQUNFO1FBQUEsSUFBQSxFQUFNLENBQUMsS0FBRCxDQUFOO1FBQ0EsV0FBQSxFQUFhLEVBRGI7UUFFQSxPQUFBLEVBQVMsSUFGVDtPQURGLEVBREY7S0FBQSxNQUFBO01BTUUsUUFBQSxHQUFXLElBQUMsQ0FBQSxNQUFNLENBQUMsY0FBUixDQUF1QixDQUFDLFFBQUEsQ0FBUyxNQUFPLENBQUEsVUFBQSxDQUFoQixFQUE2QixFQUE3QixDQUFBLEdBQW1DLENBQXBDLENBQUEsR0FBeUMsQ0FBaEUsRUFBbUUsQ0FBbkU7TUFDWCxJQUFDLENBQUEsWUFBRCxDQUNFO1FBQUEsSUFBQSxFQUFNLENBQUMsUUFBRCxDQUFOO1FBQ0EsV0FBQSxFQUFhLEVBRGI7UUFFQSxPQUFBLEVBQVMsSUFGVDtPQURGLEVBUEY7O0lBWUEsU0FBQSxHQUFZLENBQUMsQ0FBQyxJQUFGLENBQU8sQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsV0FBUixDQUFvQixDQUFDLE1BQTVCLENBQW1DLENBQUM7SUFDaEQsSUFBRyxJQUFDLENBQUEsY0FBZSxDQUFBLFdBQUEsQ0FBaEIsS0FBZ0MsTUFBbkM7TUFDRSxRQUFBLEdBQWUsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLFNBQVQsQ0FBbUI7UUFDaEMsSUFBQSxFQUFNLENBQUMsUUFBQSxJQUFZLEtBQWIsQ0FEMEI7UUFFaEMsUUFBQSxFQUFVLElBQUMsQ0FBQSxnQkFBRCxHQUFvQixHQUZFO1FBR2hDLElBQUEsRUFBTSxRQUgwQjtRQUloQyxTQUFBLEVBQVcsS0FKcUI7T0FBbkI7TUFNZixJQUFHLElBQUMsQ0FBQSxnQkFBaUIsQ0FBQSxJQUFDLENBQUEsZ0JBQWdCLENBQUMsTUFBbEIsR0FBMkIsQ0FBM0IsQ0FBbEIsS0FBbUQsR0FBdEQ7UUFDRSxRQUFRLENBQUMsTUFBVCxDQUFnQixDQUFoQixFQURGOzthQUVBLFNBQVMsQ0FBQyxJQUFWLENBQWUsUUFBZixFQVRGO0tBQUEsTUFBQTthQVdFLFNBQVMsQ0FBQyxJQUFWLENBQW1CLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxTQUFULENBQW1CLElBQUMsQ0FBQSxnQkFBcEIsQ0FBbkIsRUFYRjs7RUFqQk87O21CQThCVCxRQUFBLEdBQVUsU0FBQyxLQUFELEVBQVEsa0JBQVIsRUFBNEIsZUFBNUI7QUFDUixRQUFBO0lBQUEsSUFBVSxDQUFDLENBQUMsT0FBRixDQUFVLEtBQVYsQ0FBVjtBQUFBLGFBQUE7O0lBQ0EsQ0FBQSxDQUFFLFlBQUYsRUFBZ0IsS0FBaEI7SUFDQSxLQUFBLEdBQVEsQ0FBQyxDQUFDLElBQUYsQ0FBTyxDQUFDLENBQUMsSUFBRixDQUFPLElBQUMsQ0FBQSxXQUFSLENBQW9CLENBQUMsTUFBNUI7SUFDUixDQUFBLENBQUUsb0JBQUYsRUFBd0IsS0FBeEI7SUFFQSxLQUFBLEdBQVE7SUFDUixVQUFBLEdBQWE7SUFDYixXQUFBLEdBQWM7SUFDZCxhQUFBLEdBQWdCO0lBQ2hCLFVBQUEsR0FBYTtJQUNiLFNBQUEsR0FBWTtJQUNaLFNBQUEsR0FBWTtJQUNaLFNBQUEsR0FBWTtJQUtaLGNBQUEsR0FBaUIsQ0FBQyxDQUFDLEtBQUYsQ0FBUSxLQUFSLENBQWMsQ0FBQztJQUNoQyxnQkFBQSxHQUFtQjtBQUVuQixTQUFBLHVDQUFBOztNQUNFLFNBQUE7TUFDQSxJQUFHLGtCQUFBLElBQWEsSUFBSSxDQUFDLE1BQUwsS0FBZSxjQUEvQjtRQUNFLGdCQUFBLEdBQW1CO1FBQ25CLGNBQUEsR0FBaUIsSUFBSSxDQUFDLE9BRnhCOztNQUlBLElBQU8sK0JBQVA7UUFHRSxLQUFNLENBQUEsZ0JBQUEsQ0FBTixHQUEwQjtRQUMxQixVQUFXLENBQUEsZ0JBQUEsQ0FBWCxHQUErQjtRQUMvQixXQUFZLENBQUEsZ0JBQUEsQ0FBWixHQUFnQztRQUNoQyxTQUFVLENBQUEsZ0JBQUEsQ0FBVixHQUE4QjtRQUM5QixhQUFjLENBQUEsZ0JBQUEsQ0FBZCxHQUFrQztRQUNsQyxVQUFXLENBQUEsZ0JBQUEsQ0FBWCxHQUErQixHQVJqQzs7TUFVQSxNQUFxQyxDQUFDLElBQUQsRUFBTyxJQUFQLEVBQWEsSUFBYixDQUFyQyxFQUFDLGlCQUFELEVBQVcsbUJBQVgsRUFBdUI7TUFFdkIsU0FBQSxHQUFZO01BRVosSUFBRyxnQkFBSDtRQUNFLE1BQUEsR0FBWSxtQkFBSCxHQUFxQixJQUFJLENBQUMsTUFBMUIsR0FBc0MsSUFBSSxDQUFDO1FBQ3BELE9BQXFDLElBQUMsQ0FBQSxhQUFELENBQWUsSUFBSSxDQUFDLEdBQXBCLEVBQXlCLE1BQXpCLENBQXJDLEVBQUMsa0JBQUQsRUFBVyxvQkFBWCxFQUF1QjtRQUN2QixJQUFHLGtCQUFIO1VBQ0UsR0FBQSxHQUFNLFVBQVUsQ0FBQyxLQUFYLENBQWlCLEdBQWpCLENBQXNCLENBQUEsQ0FBQSxFQUQ5QjtTQUFBLE1BQUE7VUFHRSxHQUFBLEdBQU0sR0FIUjs7UUFLQSxTQUFBLEdBQVksRUFBQSxHQUFHLFFBQUgsR0FBYztRQUMxQixJQUF1QixpQkFBdkI7VUFBQSxJQUFJLENBQUMsSUFBTCxHQUFZLElBQVo7U0FURjtPQUFBLE1BVUssSUFBRyxpQkFBSDtRQUNILE9BQXFDLElBQUMsQ0FBQSxjQUFELENBQWdCLElBQUksQ0FBQyxJQUFyQixFQUEyQixJQUFJLENBQUMsTUFBaEMsQ0FBckMsRUFBQyxrQkFBRCxFQUFXLG9CQUFYLEVBQXVCO1FBQ3ZCLFNBQUEsR0FBWSxJQUFDLENBQUEsTUFBTSxDQUFDLGNBQVIsQ0FBdUIsSUFBSSxDQUFDLElBQTVCLEVBQWtDLElBQUksQ0FBQyxNQUF2QyxDQUE4QyxDQUFDLEtBQS9DLENBQXFELEdBQXJELENBQTBELENBQUEsQ0FBQSxFQUZuRTtPQUFBLE1BQUE7QUFJSCxjQUFVLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxhQUFULEVBQXdCLG1CQUF4QixFQUpQOztNQU1MLFdBQUEsR0FBYyxRQUFBLENBQVMsVUFBVCxFQUFxQixFQUFyQixDQUFBLEdBQTJCLElBQUMsQ0FBQTtNQUUxQyxnQkFBQSxHQUFzQixpQkFBSCxHQUFtQjtRQUFDLElBQUEsRUFBTSxJQUFJLENBQUMsSUFBWjtRQUFrQixHQUFBLEVBQUssSUFBSSxDQUFDLEdBQTVCO09BQW5CLEdBQXlEO01BQzVFLEtBQU0sQ0FBQSxnQkFBQSxDQUFpQixDQUFDLElBQXhCLENBQWdDLFFBQUQsR0FBVSxHQUFWLEdBQWEsVUFBNUM7TUFDQSxVQUFXLENBQUEsZ0JBQUEsQ0FBaUIsQ0FBQyxJQUE3QixDQUFxQyxTQUFELEdBQVcsR0FBWCxHQUFjLFdBQWxEO01BQ0EsV0FBWSxDQUFBLGdCQUFBLENBQWlCLENBQUMsSUFBOUIsQ0FBbUMsVUFBbkM7TUFDQSxTQUFVLENBQUEsZ0JBQUEsQ0FBaUIsQ0FBQyxJQUE1QixDQUFpQztRQUFDLElBQUEsRUFBTSxJQUFJLENBQUMsSUFBWjtRQUFrQixHQUFBLEVBQUssSUFBSSxDQUFDLE1BQTVCO09BQWpDO01BQ0EsSUFBMEQseUJBQTFEO1FBQUEsYUFBYyxDQUFBLGdCQUFBLENBQWlCLENBQUMsSUFBaEMsQ0FBcUMsSUFBSSxDQUFDLFlBQTFDLEVBQUE7O01BQ0EsU0FBVSxDQUFBLGdCQUFBLENBQVYsR0FBOEI7TUFDOUIsSUFBaUQsc0JBQWpEO1FBQUEsVUFBVyxDQUFBLGdCQUFBLENBQVgsR0FBK0IsSUFBSSxDQUFDLFVBQXBDOztNQUVBLGdCQUFBO0FBL0NGO0FBZ0RBLFNBQUEsaURBQUE7O01BQ0UsY0FBQSxHQUFpQixJQUFDLENBQUE7TUFDbEIsSUFBcUQsb0JBQXJEO1FBQUEsSUFBQyxDQUFBLFdBQUQsQ0FBYSxTQUFVLENBQUEsQ0FBQSxDQUFFLENBQUMsSUFBMUIsRUFBZ0MsU0FBVSxDQUFBLENBQUEsQ0FBRSxDQUFDLEdBQTdDLEVBQUE7O01BQ0EsSUFBQyxDQUFBLFVBQUQsQ0FBWSxTQUFVLENBQUEsQ0FBQSxDQUF0QixFQUEwQixVQUFXLENBQUEsQ0FBQSxDQUFyQztNQUNBLElBQXFGLGtCQUFyRjtRQUFBLElBQUMsQ0FBQSxZQUFELENBQWM7VUFBQyxJQUFBLEVBQU0sSUFBUDtVQUFhLFdBQUEsRUFBYSxXQUFZLENBQUEsQ0FBQSxDQUF0QztVQUEwQyxTQUFBLEVBQVcsVUFBVyxDQUFBLENBQUEsQ0FBaEU7U0FBZCxFQUFBOztNQUNBLElBQUMsQ0FBQSxnQkFBRCxDQUFrQixhQUFjLENBQUEsQ0FBQSxDQUFoQztNQUNBLElBQStCLHFCQUEvQjtRQUFBLElBQUMsQ0FBQSxZQUFELENBQWMsVUFBVyxDQUFBLENBQUEsQ0FBekIsRUFBQTs7QUFORjtJQVFBLElBQUcsMEJBQUg7TUFDRSxHQUFBLEdBQU07QUFDTixXQUF1Qyw2RkFBdkM7UUFBQSxHQUFHLENBQUMsSUFBSixDQUFTLGtCQUFUO0FBQUE7TUFDQSxJQUFDLENBQUEsZ0JBQUQsQ0FBa0IsR0FBbEIsRUFIRjs7SUFLQSxJQUFpQyx1QkFBakM7YUFBQSxJQUFDLENBQUEsWUFBRCxDQUFjLGVBQWQsRUFBQTs7RUFsRlE7O21CQW9GVixPQUFBLEdBQVMsU0FBQyxJQUFEO1dBQ1AsSUFBQyxDQUFBLFFBQUQsQ0FBVSxDQUFDLElBQUQsQ0FBVjtFQURPOzttQkFHVCxZQUFBLEdBQWMsU0FBQTtXQUNaLENBQUMsQ0FBQyxJQUFGLENBQU8sQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsV0FBUixDQUFvQixDQUFDLE1BQTVCLENBQW1DLENBQUMsV0FBVyxDQUFDLElBQWhELENBQXFELEVBQXJEO0VBRFk7O21CQUdkLFdBQUEsR0FBYSxTQUFDLElBQUQ7QUFDWCxRQUFBO0lBQUEsSUFBRyxZQUFIO01BQ0UsS0FBQSxHQUFRLElBQUksQ0FBQyxLQUFMLENBQVcseUJBQVg7TUFDUixJQUFHLGFBQUg7UUFDRSxJQUFDLENBQUEsY0FBZSxDQUFBLFdBQUEsQ0FBaEIsR0FBK0IsS0FBTSxDQUFBLENBQUE7UUFDckMsSUFBQyxDQUFBLGNBQWUsQ0FBQSxXQUFBLENBQWhCLEdBQStCLFFBQUEsQ0FBUyxLQUFNLENBQUEsQ0FBQSxDQUFmLEVBQW1CLEVBQW5CO2VBQy9CLElBQUMsQ0FBQSxjQUFlLENBQUEsWUFBQSxDQUFoQixHQUFnQyxLQUFNLENBQUEsQ0FBQSxFQUh4QztPQUZGOztFQURXOzttQkFRYixXQUFBLEdBQWEsU0FBQyxJQUFELEVBQU8sUUFBUCxFQUFtQixhQUFuQixFQUEyQyxNQUEzQyxFQUF3RCxZQUF4RDtBQUNYLFFBQUE7O01BRGtCLFdBQVM7OztNQUFHLGdCQUFjOzs7TUFBVSxTQUFPOzs7TUFBTSxlQUFhOztJQUNoRixNQUFBLEdBQVMsQ0FBQyxDQUFDLElBQUYsQ0FBTyxDQUFDLENBQUMsSUFBRixDQUFPLElBQUMsQ0FBQSxXQUFSLENBQW9CLENBQUMsTUFBNUIsQ0FBbUMsQ0FBQztJQUM3QyxJQUErRSxDQUFDLENBQUMsT0FBRixDQUFVLE1BQVYsQ0FBL0U7QUFBQSxZQUFVLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxhQUFULEVBQXdCLHdDQUF4QixFQUFWOztJQUVBLFNBQUEsR0FBWSxJQUFDLENBQUEsY0FBZSxDQUFBLFdBQUE7SUFDNUIsU0FBQSxHQUFZLElBQUMsQ0FBQSxjQUFlLENBQUEsV0FBQTtJQUM1QixVQUFBLEdBQWEsSUFBQyxDQUFBLGNBQWUsQ0FBQSxZQUFBO0lBRTdCLElBQUE7QUFBTyxjQUFPLGFBQVA7QUFBQSxhQUNBLFFBREE7aUJBRUgsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFRLENBQUMsYUFBYSxDQUFDO0FBRjdCLGFBR0EsTUFIQTtpQkFJSCxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUM7QUFKN0IsYUFLQSxPQUxBO2lCQU1ILEdBQUcsQ0FBQyxJQUFJLENBQUMsUUFBUSxDQUFDLGFBQWEsQ0FBQztBQU43QjtpQkFRSCxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxhQUFhLENBQUM7QUFSN0I7O0lBVVAsUUFBQSxHQUFjLFlBQUgsR0FBcUIsR0FBckIsR0FBOEIsSUFBQyxDQUFBO0lBRTFDLE1BQUEsR0FDRTtNQUFBLElBQUEsRUFBTSxJQUFOO01BQ0EsUUFBQSxFQUFVLFFBRFY7TUFFQSxNQUFBLEVBQVEsTUFGUjtNQUdBLFlBQUEsRUFBYyxZQUhkO01BSUEsSUFBQSxFQUNFO1FBQUEsTUFBQSxFQUFRLFNBQVI7UUFDQSxJQUFBLEVBQU0sU0FETjtRQUVBLE1BQUEsRUFBUSxVQUZSO09BTEY7O0lBU0YsSUFBRyxJQUFLLENBQUEsQ0FBQSxDQUFMLEtBQVcsR0FBZDtNQUNFLE1BQU0sQ0FBQyxLQUFQLEdBQWUsSUFBSyxVQUR0Qjs7SUFHQSxJQUFBLEdBQVcsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVQsQ0FBa0IsTUFBbEIsQ0FBeUIsQ0FDbEMsT0FEUyxDQUNELFFBREMsQ0FDUSxDQUFDLGdCQURULENBQzBCLElBRDFCO1dBR1gsQ0FBQyxDQUFDLElBQUYsQ0FBTyxNQUFQLENBQWMsQ0FBQyxJQUFmLENBQW9CLElBQXBCO0VBcENXOzttQkFzQ2IsUUFBQSxHQUFVLFNBQUMsT0FBRDtBQUNSLFFBQUE7SUFBQSxJQUFDLENBQUEsVUFBRCxDQUFBO0lBQ0EsS0FBQSxHQUFRLENBQUMsQ0FBQyxJQUFGLENBQU8sQ0FBQyxDQUFDLElBQUYsQ0FBTyxJQUFDLENBQUEsV0FBUixDQUFvQixDQUFDLE1BQTVCO0lBQ1IsSUFBaUMsYUFBakM7QUFBQSxhQUFPLElBQUMsQ0FBQSxRQUFELENBQVUsT0FBVixFQUFQOztJQUVBLElBQUEsQ0FBTyxDQUFDLENBQUMsT0FBRixDQUFVLEtBQUssQ0FBQyxTQUFoQixDQUFQO01BQ0UsS0FBSyxDQUFDLFVBQVUsQ0FBQyxJQUFqQixDQUFzQixLQUFLLENBQUMsU0FBNUI7TUFDQSxLQUFLLENBQUMsU0FBTixHQUFrQixHQUZwQjs7SUFJQSxJQUFBLENBQU8sQ0FBQyxDQUFDLE9BQUYsQ0FBVSxLQUFLLENBQUMsVUFBaEIsQ0FBUDtNQUNFLEtBQUssQ0FBQyxXQUFXLENBQUMsSUFBbEIsQ0FBdUIsS0FBSyxDQUFDLFVBQTdCO2FBQ0EsS0FBSyxDQUFDLFVBQU4sR0FBbUIsR0FGckI7O0VBVFE7O21CQWFWLGFBQUEsR0FBZSxTQUFBO0lBQ2IsSUFBQyxDQUFBLFdBQVcsQ0FBQyxJQUFiLENBQWtCO01BQUMsTUFBQSxFQUFPLEVBQVI7S0FBbEI7SUFDQSxDQUFBLENBQUUsZUFBRjtFQUZhOzttQkFLZixpQkFBQSxHQUFtQixTQUFBO0FBQ2pCLFdBQU8sSUFBQyxDQUFBLFdBQVcsQ0FBQztFQURIOzttQkFHbkIsYUFBQSxHQUFlLFNBQUMsQ0FBRDtBQUNiLFdBQU8sSUFBQyxDQUFBLFdBQVksQ0FBQSxDQUFBO0VBRFA7O21CQUdmLFFBQUEsR0FBVSxTQUFDLGdCQUFELEVBQW1CLE9BQW5CLEVBQTRCLE9BQTVCO0FBQ1IsUUFBQTtJQUFBLElBQUEsR0FDRTtNQUFBLE1BQUEsRUFBUSxVQUFSO01BQ0EsSUFBQSxFQUFNLFFBRE47TUFFQSxHQUFBLEVBQUssR0FGTDtNQUdBLFFBQUEsRUFBYSxPQUFBLEtBQVcsVUFBZCxHQUE4QixPQUE5QixHQUEyQyxNQUhyRDtNQUlBLFNBQUEsRUFBYyxPQUFBLEtBQVcsT0FBZCxHQUEyQixPQUEzQixHQUF3QyxNQUpuRDtNQUtBLE9BQUEsRUFBUyxDQUxUOztJQU9GLENBQUMsQ0FBQyxNQUFGLENBQVMsSUFBVCxFQUFlLE9BQWY7SUFDQSxDQUFBLENBQUUsWUFBRixFQUFnQixPQUFoQixFQUF5QixJQUF6QjtJQUVBLFNBQUEsR0FBWTtJQUNaLFVBQUEsR0FBYTtJQUdiLE9BQUEsR0FBVSxJQUFDLENBQUEsQ0FBRCxHQUFLLElBQUMsQ0FBQSxjQUFlLENBQUEsaUJBQUE7SUFDL0IsZ0JBQUEsR0FBbUI7SUFFbkIsSUFBRyxJQUFJLENBQUMsUUFBTCxLQUFpQixNQUFwQjtNQUNFLFVBQUEsR0FBaUIsSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLEtBQVQsQ0FBZSxPQUFmLEVBQXdCLElBQUMsQ0FBQSxNQUF6QixFQUFpQyxJQUFDLENBQUEsY0FBYyxDQUFDLEtBQWhCLEdBQXdCLEVBQXpEO01BQ2pCLElBQWlDLElBQUksQ0FBQyxJQUFMLEtBQWUsTUFBaEQ7UUFBQSxVQUFVLENBQUMsT0FBWCxDQUFtQixJQUFJLENBQUMsSUFBeEIsRUFBQTs7TUFDQSxVQUFVLENBQUMsZUFBWCxDQUEyQixJQUFJLENBQUMsR0FBaEM7TUFDQSxJQUEwQyxpQkFBMUM7UUFBQSxVQUFVLENBQUMsZ0JBQVgsQ0FBNEIsSUFBSSxDQUFDLElBQWpDLEVBQUE7O01BRUEsSUFBQyxDQUFBLE1BQUQsSUFBVyxVQUFVLENBQUMsU0FBWCxDQUFBLENBQUEsR0FDQSxJQUFDLENBQUEsT0FBTyxDQUFDLHdCQURULEdBRUEsUUFBQSxDQUFTLElBQUMsQ0FBQSxjQUFlLENBQUEsZ0JBQUEsQ0FBekIsRUFBNEMsRUFBNUM7TUFDWCxnQkFBQSxHQUFtQixVQUFVLENBQUMsYUFBWCxDQUFBO01BQ25CLElBQUMsQ0FBQSxZQUFELEdBQW1CLElBQUksQ0FBQyxJQUFMLEtBQWEsTUFBaEIsR0FBNEIsUUFBNUIsR0FBMEMsSUFBSSxDQUFDLEtBVmpFOztJQVlBLElBQUcsSUFBSSxDQUFDLFNBQUwsS0FBa0IsTUFBckI7TUFDRSxTQUFBLEdBQWdCLElBQUEsR0FBRyxDQUFDLElBQUksQ0FBQyxRQUFULENBQWtCLE9BQWxCLEVBQTJCLElBQUMsQ0FBQSxNQUE1QixFQUFvQyxJQUFDLENBQUEsY0FBYyxDQUFDLEtBQWhCLEdBQXdCLEVBQTVELENBQ2QsQ0FBQyxXQURhLENBQ0QsSUFBSSxDQUFDLE9BREo7TUFFaEIsSUFBMkIsSUFBSSxDQUFDLElBQUwsS0FBZSxNQUExQztRQUFBLFNBQVMsQ0FBQyxXQUFWLENBQUEsRUFBQTs7TUFDQSxTQUFTLENBQUMsYUFBVixDQUF3QixnQkFBeEI7TUFDQSxJQUFDLENBQUEsTUFBRCxJQUFXLFNBQVMsQ0FBQyxTQUFWLENBQUEsQ0FBQSxHQUF3QixJQUFDLENBQUEsT0FBTyxDQUFDLHdCQUw5Qzs7SUFPQSxJQUFDLENBQUEsVUFBRCxDQUFBO0lBQ0EsV0FBQSxHQUFjLEdBQUcsQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLG9CQUFkLENBQW1DLElBQUksQ0FBQyxJQUF4QztJQUNkLElBQUMsQ0FBQSxhQUFELENBQWUsZ0JBQWYsQ0FBZ0MsQ0FBQyxNQUFNLENBQUMsSUFBeEMsQ0FBNkM7TUFDM0MsR0FBQSxFQUFLLFNBRHNDO01BRTNDLElBQUEsRUFBTSxVQUZxQztNQUczQyxVQUFBLEVBQVksRUFIK0I7TUFJM0MsV0FBQSxFQUFhLEVBSjhCO01BSzNDLFNBQUEsRUFBVyxFQUxnQztNQU0zQyxVQUFBLEVBQVksRUFOK0I7TUFPM0MsV0FBQSxFQUFhLEVBUDhCO01BUTNDLFdBQUEsRUFBYSxXQVI4QjtLQUE3QztJQVdBLElBQUMsQ0FBQSxNQUFNLENBQUMsU0FBUixDQUFrQixJQUFJLENBQUMsTUFBdkI7SUFDQSxJQUFDLENBQUEsV0FBVyxDQUFDLE1BQWIsQ0FBb0IsSUFBSSxDQUFDLEdBQXpCO0VBcERROzttQkF3RFYsVUFBQSxHQUFZLFNBQUMsSUFBRCxFQUFPLEVBQVAsRUFBYSxFQUFiO0FBQ1YsUUFBQTs7TUFEaUIsS0FBRzs7O01BQUcsS0FBRzs7SUFDMUIsQ0FBQSxDQUFFLGNBQUYsRUFBa0IsSUFBbEI7SUFDQSxLQUFBLEdBQVEsSUFBSSxDQUFDLEtBQUwsQ0FBVyxLQUFYO0FBQ1IsWUFBTyxLQUFNLENBQUEsQ0FBQSxDQUFiO0FBQUEsV0FDTyxjQURQO1FBRUksSUFBQyxDQUFBLG9CQUFELEdBQXdCLFFBQUEsQ0FBUyxLQUFNLENBQUEsQ0FBQSxDQUFmLEVBQW1CLEVBQW5CO2VBQ3hCLENBQUEsQ0FBRSxnQkFBRixFQUFvQixJQUFDLENBQUEsb0JBQXJCO0FBSEo7QUFLSSxjQUFVLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxhQUFULEVBQXdCLG1CQUFBLEdBQW9CLEtBQU0sQ0FBQSxDQUFBLENBQTFCLEdBQTZCLFlBQTdCLEdBQXlDLEVBQXpDLEdBQTRDLFVBQTVDLEdBQXNELEVBQTlFO0FBTGQ7RUFIVTs7Ozs7O0FBVWQsTUFBTSxDQUFDLE9BQVAsR0FBaUI7Ozs7QUNwZ0NqQixJQUFBOztBQUFBLEdBQUEsR0FBTSxPQUFBLENBQVEsU0FBUjs7QUFDTixNQUFBLEdBQVMsT0FBQSxDQUFRLGlCQUFSOztBQUNULE1BQUEsR0FBUyxPQUFBLENBQVEsaUJBQVI7O0FBQ1QsTUFBQSxHQUFTLE9BQUEsQ0FBUSxpQkFBUjs7QUFFVCxNQUFNLENBQUMsT0FBUCxHQUFpQjtFQUNmLE1BQUEsRUFBUSxNQURPO0VBRWYsTUFBQSxFQUFRLE1BRk87RUFHZixHQUFBLEVBQUssR0FIVTtFQUlmLE1BQUEsRUFBUSxNQUpPOzs7OztBQ0NqQixJQUFBLGdCQUFBO0VBQUE7OztBQUFBLEdBQUEsR0FBTSxPQUFBLENBQVEsU0FBUjs7QUFDTixDQUFBLEdBQUksT0FBQSxDQUFRLFlBQVI7O0FBQ0osQ0FBQSxHQUFJLE9BQUEsQ0FBUSxRQUFSOztBQUNKLEtBQUEsR0FBUSxPQUFBLENBQVEsT0FBUjs7QUFFRixHQUFHLENBQUMsSUFBSSxDQUFDO0FBQ2IsTUFBQTs7RUFBQSxNQUFDLENBQUEsS0FBRCxHQUFTOztFQUNULE1BQUMsQ0FBQSxrQkFBRCxHQUFzQjs7RUFDdEIsQ0FBQSxHQUFJLFNBQUE7QUFBYSxRQUFBO0lBQVo7SUFBWSxJQUE4QyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxLQUE5RDtrRUFBQSxPQUFPLENBQUUsR0FBVCxnQkFBYSxDQUFBLG1CQUFxQixTQUFBLFdBQUEsSUFBQSxDQUFBLENBQWxDLFdBQUE7O0VBQWI7O0VBRUosUUFBQSxHQUFXLEdBQUcsQ0FBQyxJQUFJLENBQUM7O0VBQ3BCLFVBQUEsR0FBYSxHQUFHLENBQUMsSUFBSSxDQUFDOztFQUN0QixVQUFBLEdBQWEsR0FBRyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUM7O0VBQzVCLE9BQUEsR0FBVSxHQUFHLENBQUM7O0VBRWQsV0FBQSxHQUFjO0lBQ1osc0JBQUEsRUFBd0IsQ0FEWjtJQUVaLHVCQUFBLEVBQXlCLEVBRmI7SUFHWix1QkFBQSxFQUF5QixFQUhiO0lBSVosc0JBQUEsRUFBd0IsRUFKWjtJQUtaLG1CQUFBLEVBQXFCLEVBTFQ7SUFNWixzQkFBQSxFQUF3QixFQU5aO0lBT1osb0JBQUEsRUFBc0IsRUFQVjtJQVFaLFNBQUEsRUFBVyxFQVJDO0lBU1osZUFBQSxFQUFpQixFQVRMO0lBVVosYUFBQSxFQUFlLEVBVkg7SUFXWixVQUFBLEVBQVksRUFYQTtJQVlaLFdBQUEsRUFBYSxFQVpEO0lBYVosY0FBQSxFQUFnQixFQWJKO0lBY1osT0FBQSxFQUFTLEVBZEc7SUFlWixZQUFBLEVBQWMsR0FmRjs7O0VBa0JELGdCQUFDLE9BQUQsRUFBVSxPQUFWO0lBQUMsSUFBQyxDQUFBLFNBQUQ7SUFDWixDQUFBLENBQUUsdUJBQUYsRUFBMkIsT0FBM0I7SUFDQSxJQUFDLENBQUEsT0FBRCxHQUNFO01BQUEsVUFBQSxFQUFZLHNCQUFaO01BQ0EsS0FBQSxFQUFPLEdBRFA7TUFFQSxhQUFBLEVBQWUsSUFGZjtNQUdBLGFBQUEsRUFBZSxlQUhmO01BSUEsYUFBQSxFQUFlLGVBSmY7O0lBTUYsSUFBK0IsZUFBL0I7TUFBQSxDQUFDLENBQUMsTUFBRixDQUFTLElBQUMsQ0FBQSxPQUFWLEVBQW1CLE9BQW5CLEVBQUE7O0lBQ0EsQ0FBQSxDQUFFLHVCQUFBLEdBQXdCLElBQUMsQ0FBQSxPQUFPLENBQUMsYUFBbkM7SUFDQSxJQUFDLENBQUEsV0FBRCxHQUFlO0lBQ2YsSUFBQyxDQUFBLEtBQUQsR0FBUztJQUNULElBQUMsQ0FBQSxLQUFELENBQUE7RUFiVzs7bUJBZWIsU0FBQSxHQUFXLFNBQUMsTUFBRDtJQUNULElBQUMsQ0FBQSxNQUFELEdBQVU7V0FDVixJQUFDLENBQUEsS0FBRCxDQUFBO0VBRlM7O21CQUlYLFFBQUEsR0FBVSxTQUFDLEtBQUQ7SUFDUixDQUFBLENBQUUsYUFBRixFQUFpQixLQUFqQjtJQUNBLElBQUMsQ0FBQSxPQUFPLENBQUMsS0FBVCxHQUFpQjtXQUNqQixJQUFDLENBQUEsS0FBRCxDQUFBO0VBSFE7O21CQUtWLGFBQUEsR0FBZSxTQUFDLFVBQUQ7SUFDYixDQUFBLENBQUUsa0JBQUYsRUFBc0IsVUFBdEI7SUFDQSxJQUFHLGFBQWtCLENBQUMsQ0FBQyxJQUFGLENBQU8sV0FBUCxDQUFsQixFQUFBLFVBQUEsS0FBSDtBQUNFLFlBQVUsSUFBQSxHQUFHLENBQUMsSUFBSixDQUFTLGFBQVQsRUFBd0Isc0JBQUEsR0FBeUIsVUFBakQsRUFEWjs7SUFFQSxJQUFDLENBQUEsT0FBTyxDQUFDLFVBQVQsR0FBc0I7V0FDdEIsSUFBQyxDQUFBLEtBQUQsQ0FBQTtFQUxhOzttQkFPZixLQUFBLEdBQU8sU0FBQTtJQUNMLElBQUMsQ0FBQSxNQUFNLENBQUMsWUFBUixDQUFxQixJQUFyQjtJQUNBLElBQUMsQ0FBQSxVQUFELEdBQWM7SUFDZCxJQUFDLENBQUEsU0FBRCxHQUFhO0lBQ2IsSUFBQyxDQUFBLEdBQUQsR0FBTyxJQUFDLENBQUEsT0FBTyxDQUFDLEtBQVQsR0FBaUIsQ0FBQyxVQUFBLEdBQWEsQ0FBZDtJQUN4QixJQUFDLENBQUEsWUFBRCxHQUFnQjtJQUNoQixJQUFDLENBQUEsaUJBQUQsR0FBcUIsSUFBQyxDQUFBLEdBQUQsR0FBTyxDQUFDLEVBQUEsR0FBSyxDQUFDLElBQUEsR0FBSyxJQUFDLENBQUEsWUFBUCxDQUFOO0lBQzVCLElBQUMsQ0FBQSxXQUFELEdBQWU7SUFDZixJQUFHLG1CQUFIO01BQ0UsSUFBQyxDQUFBLE1BQU0sQ0FBQyxNQUFSLENBQUE7TUFDQSxJQUFDLENBQUEsTUFBRCxHQUFVLEtBRlo7O1dBR0EsSUFBQyxDQUFBLElBQUQsQ0FBQTtFQVhLOztFQWFQLFVBQUEsR0FBYSxTQUFDLE9BQUQsRUFBVSxLQUFWLEVBQWlCLGFBQWpCO0FBQ1gsUUFBQTtJQUFBLE1BQUEsR0FBUyxPQUFPLENBQUM7SUFDakIsTUFBQSxHQUFTLE1BQU0sQ0FBQztJQUNoQixLQUFBLEdBQVEsTUFBTSxDQUFDO0lBRWYsT0FBQSxHQUFVLENBQUEsQ0FBRSxVQUFGO0lBQ1YsT0FBTyxDQUFDLEdBQVIsQ0FBWSxVQUFaLEVBQXdCLFVBQXhCO0lBQ0EsT0FBTyxDQUFDLEdBQVIsQ0FBWSxNQUFaLEVBQW9CLENBQXBCO0lBQ0EsT0FBTyxDQUFDLEdBQVIsQ0FBWSxLQUFaLEVBQW1CLENBQW5CO0lBQ0EsT0FBTyxDQUFDLFFBQVIsQ0FBaUIsYUFBakI7SUFFQSxDQUFBLENBQUUsTUFBRixDQUFTLENBQUMsS0FBVixDQUFnQixPQUFoQjtJQUNBLEdBQUEsR0FBTSxHQUFHLENBQUMsSUFBSSxDQUFDLFFBQVEsQ0FBQyxnQkFBbEIsQ0FBbUMsT0FBTyxDQUFDLEdBQVIsQ0FBWSxDQUFaLENBQW5DLEVBQW1ELEtBQW5ELEVBQTBELE1BQTFEO0lBQ04sR0FBRyxDQUFDLEtBQUosQ0FBVSxLQUFWLEVBQWlCLEtBQWpCO0lBRUEsRUFBQSxHQUFTLElBQUEsS0FBSyxDQUFDLFVBQU4sQ0FBQTtJQUNULEVBQUUsQ0FBQyxLQUFILENBQVMsT0FBTyxDQUFDLEdBQVIsQ0FBWSxDQUFaLENBQVQ7QUFFQSxXQUFPO01BQ0wsS0FBQSxFQUFPLEVBREY7TUFFTCxNQUFBLEVBQVEsT0FBTyxDQUFDLEdBQVIsQ0FBWSxDQUFaLENBRkg7O0VBbEJJOzttQkF1QmIsY0FBQSxHQUFnQixTQUFBO0lBQ2QsSUFBeUIsd0JBQXpCO01BQUEsSUFBQyxDQUFBLFdBQVcsQ0FBQyxNQUFiLENBQUEsRUFBQTs7SUFDQSxJQUF5Qix3QkFBekI7TUFBQSxJQUFDLENBQUEsV0FBVyxDQUFDLE1BQWIsQ0FBQSxFQUFBOztJQUNBLElBQXNCLGtCQUF0QjthQUFBLElBQUMsQ0FBQSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQVosQ0FBQSxFQUFBOztFQUhjOzttQkFLaEIsTUFBQSxHQUFRLFNBQUE7QUFDTixRQUFBO0lBQUEsSUFBQyxDQUFBLEtBQUQsQ0FBQTtJQUNBLElBQUEsR0FBTyxJQUFDLENBQUEsTUFBTSxDQUFDLGFBQVIsQ0FBQTtJQUNQLElBQUMsQ0FBQSxLQUFELEdBQVMsSUFBSSxDQUFDO0lBRWQsSUFBRyxDQUFJLElBQUMsQ0FBQSxLQUFSO01BQ0UsT0FBQSxHQUFVLFVBQUEsQ0FBVyxJQUFJLENBQUMsT0FBaEIsRUFBeUIsSUFBSSxDQUFDLEtBQTlCLEVBQXFDLElBQUMsQ0FBQSxPQUFPLENBQUMsYUFBOUM7TUFDVixJQUFDLENBQUEsS0FBRCxHQUFTLE9BQU8sQ0FBQyxNQUZuQjs7SUFJQSxJQUFDLENBQUEsTUFBRCxHQUFjLElBQUEsSUFBQyxDQUFBLEtBQUssQ0FBQyxJQUFJLENBQUMsU0FBWixDQUFzQixDQUF0QixFQUF3QixDQUF4QixFQUEwQixFQUExQixFQUE2QixFQUE3QjtJQUNkLElBQUMsQ0FBQSxlQUFELEdBQXVCLElBQUEsSUFBQyxDQUFBLEtBQUssQ0FBQyxTQUFQLENBQWlCLEVBQWpCLEVBQXFCLEVBQXJCO0lBRXZCLElBQUcsSUFBQyxDQUFBLE9BQU8sQ0FBQyxhQUFaO01BQ0UsSUFBQyxDQUFBLFdBQUQsR0FBbUIsSUFBQSxJQUFDLENBQUEsS0FBSyxDQUFDLElBQUksQ0FBQyxjQUFaLENBQStCLElBQUEsSUFBQyxDQUFBLEtBQUssQ0FBQyxLQUFQLENBQWEsRUFBYixFQUFnQixFQUFoQixDQUEvQixFQUFvRCxDQUFwRCxFQUF1RCxDQUF2RCxFQUEwRCxDQUExRDtNQUNuQixJQUFDLENBQUEsV0FBVyxDQUFDLFNBQWIsR0FBeUI7TUFDekIsSUFBQyxDQUFBLFdBQVcsQ0FBQyxPQUFiLEdBQXVCO01BQ3ZCLElBQUMsQ0FBQSxXQUFXLENBQUMsTUFBYixDQUFvQixFQUFwQjtNQUNBLElBQUMsQ0FBQSxXQUFXLENBQUMsU0FBYixHQUF5QixDQUFBLFNBQUEsS0FBQTtlQUFBLFNBQUMsS0FBRDtpQkFDdkIsS0FBQyxDQUFBLElBQUQsQ0FBQTtRQUR1QjtNQUFBLENBQUEsQ0FBQSxDQUFBLElBQUE7TUFHekIsSUFBQyxDQUFBLFdBQUQsR0FBbUIsSUFBQSxJQUFDLENBQUEsS0FBSyxDQUFDLElBQUksQ0FBQyxTQUFaLENBQXNCLENBQXRCLEVBQXdCLENBQXhCLEVBQTBCLEVBQTFCLEVBQTZCLEVBQTdCO01BQ25CLElBQUMsQ0FBQSxXQUFXLENBQUMsU0FBYixHQUF5QjtNQUN6QixJQUFDLENBQUEsV0FBVyxDQUFDLE9BQWIsR0FBdUI7TUFDdkIsSUFBQyxDQUFBLFdBQVcsQ0FBQyxTQUFiLEdBQXlCLENBQUEsU0FBQSxLQUFBO2VBQUEsU0FBQyxLQUFEO2lCQUN2QixLQUFDLENBQUEsSUFBRCxDQUFBO1FBRHVCO01BQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxFQVgzQjs7SUFjQSxJQUFDLENBQUEsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFaLENBQUE7SUFDQSxNQUFBLEdBQVMsSUFBSSxDQUFDO0lBRWQsV0FBQSxHQUFrQixJQUFBLFFBQUEsQ0FBUyxDQUFULEVBQVksQ0FBWjtBQUNsQixTQUFBLHdDQUFBOztNQUNFLGNBQUEsR0FBcUIsSUFBQSxRQUFBLENBQVMsQ0FBVCxFQUFZLENBQVo7QUFDckIsV0FBQSx5Q0FBQTs7UUFDRSxpQkFBQSxHQUF3QixJQUFBLFFBQUEsQ0FBUyxDQUFULEVBQVksQ0FBWjtBQUN4QixhQUFBLHVEQUFBOztBQUVFO0FBQUEsZUFBQSx1Q0FBQTs7WUFDRSxJQUFBLENBQU8sSUFBSSxDQUFDLGlCQUFMLENBQUEsQ0FBUDtjQUNFLFFBQUEsR0FBVyxXQUFXLENBQUMsS0FBWixDQUFBO2NBQ1gsUUFBUSxDQUFDLEdBQVQsQ0FBYSxpQkFBYjtjQUNBLFFBQVEsQ0FBQyxRQUFULENBQUE7Y0FDQSxHQUFBLEdBQU0sUUFBUSxDQUFDLFFBQVQsQ0FBQTtjQUVOLElBQUcsQ0FBQyxDQUFDLEdBQUYsQ0FBTSxJQUFDLENBQUEsVUFBUCxFQUFtQixHQUFuQixDQUFIO2dCQUNFLElBQUMsQ0FBQSxVQUFXLENBQUEsR0FBQSxDQUFJLENBQUMsS0FBSyxDQUFDLElBQXZCLENBQTRCLElBQTVCLEVBREY7ZUFBQSxNQUFBO2dCQUdFLElBQUMsQ0FBQSxVQUFXLENBQUEsR0FBQSxDQUFaLEdBQ0U7a0JBQUEsSUFBQSxFQUFNLFFBQU47a0JBQ0EsS0FBQSxFQUFPLFFBQVEsQ0FBQyxLQUFULENBQUEsQ0FEUDtrQkFFQSxLQUFBLEVBQU8sQ0FBQyxJQUFELENBRlA7a0JBSko7O2NBUUEsaUJBQWlCLENBQUMsR0FBbEIsQ0FBc0IsSUFBSSxDQUFDLFFBQUwsQ0FBQSxDQUF0QixFQWRGOztBQURGO0FBRkY7UUFtQkEsSUFBRyxpQkFBaUIsQ0FBQyxLQUFsQixDQUFBLENBQUEsR0FBNEIsY0FBYyxDQUFDLEtBQWYsQ0FBQSxDQUEvQjtVQUNFLGNBQWMsQ0FBQyxJQUFmLENBQW9CLGlCQUFwQixFQURGOztBQXJCRjtNQXdCQSxXQUFXLENBQUMsR0FBWixDQUFnQixjQUFoQjtBQTFCRjtJQTRCQSxJQUFDLENBQUEsU0FBRCxHQUFhLENBQUMsQ0FBQyxNQUFGLENBQVMsQ0FBQyxDQUFDLE1BQUYsQ0FBUyxJQUFDLENBQUEsVUFBVixDQUFULEVBQWdDLFNBQUMsSUFBRDthQUFVLElBQUksQ0FBQztJQUFmLENBQWhDO0lBQ2IsSUFBQyxDQUFBLFdBQUQsR0FBZSxDQUFDLENBQUMsSUFBRixDQUFPLElBQUMsQ0FBQSxTQUFSO1dBQ2YsQ0FBQSxDQUFFLElBQUMsQ0FBQSxTQUFIO0VBNURNOzttQkE4RFIsWUFBQSxHQUFjLFNBQUMsQ0FBRCxFQUFJLENBQUo7SUFDWixJQUFDLENBQUEsTUFBTSxDQUFDLFNBQVIsR0FBb0I7SUFDcEIsSUFBQyxDQUFBLE1BQU0sQ0FBQyxPQUFSLEdBQWtCO0lBQ2xCLElBQUMsQ0FBQSxNQUFNLENBQUMsV0FBUixDQUF3QixJQUFBLElBQUMsQ0FBQSxLQUFLLENBQUMsS0FBUCxDQUFhLENBQUEsR0FBSSxJQUFDLENBQUEsS0FBbEIsRUFBeUIsQ0FBQSxHQUFJLElBQUMsQ0FBQSxLQUE5QixDQUF4QjtXQUNBLElBQUMsQ0FBQSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQVosQ0FBQTtFQUpZOzttQkFNZCxRQUFBLEdBQVUsU0FBQyxLQUFEO0FBQ1IsUUFBQTtJQUFBLENBQUEsQ0FBRSxHQUFBLEdBQUksSUFBQyxDQUFBLGFBQUwsR0FBbUIsY0FBckIsRUFBb0MsS0FBcEM7QUFFQTtTQUFBLHVDQUFBOztNQUNFLENBQUEsR0FBSSxJQUFJLENBQUMsWUFBTCxDQUFBLENBQUEsR0FBc0I7TUFDMUIsQ0FBQSxHQUFJLElBQUksQ0FBQyxRQUFMLENBQUEsQ0FBZSxDQUFDLFdBQWhCLENBQTRCLENBQTVCO01BQ0osSUFBdUIsa0JBQXZCO1FBQUEsSUFBQyxDQUFBLFlBQUQsQ0FBYyxDQUFkLEVBQWlCLENBQWpCLEVBQUE7O01BQ0EsSUFBWSxJQUFJLENBQUMsTUFBTCxDQUFBLENBQVo7QUFBQSxpQkFBQTs7TUFFQSxJQUFBLEdBQU8sSUFBSSxDQUFDLFdBQUwsQ0FBQTtNQUNQLFFBQUEsR0FBVyxJQUFJLENBQUMsUUFBTCxDQUFBLENBQWUsQ0FBQyxLQUFoQixDQUFBLENBQUEsR0FBMEIsQ0FBQyxJQUFDLENBQUEsR0FBRCxHQUFLLEVBQU47OztBQUNyQzthQUFBLHdDQUFBOztVQUNFLE1BQWlCLEdBQUcsQ0FBQyxLQUFKLENBQVUsR0FBVixDQUFqQixFQUFDLGFBQUQsRUFBTztVQUNQLElBQUEsR0FBTyxJQUFJLENBQUMsSUFBTCxDQUFBLENBQVcsQ0FBQyxXQUFaLENBQUE7VUFDUCxVQUFBLEdBQWEsVUFBVyxDQUFBLElBQUE7VUFDeEIsSUFBZ0Isa0JBQWhCO0FBQUEscUJBQUE7O1VBRUEsU0FBQSxHQUFZLENBQUMsRUFBQSxHQUFLLENBQUMsTUFBQSxHQUFTLEVBQVYsQ0FBTixDQUFBLEdBQXVCLFVBQVcsQ0FBQSxJQUFBLENBQUssQ0FBQztVQUNwRCxJQUFJLENBQUMsTUFBTCxDQUFZLENBQVosRUFBZSxTQUFmLEVBQTBCLEdBQTFCLEVBQStCLENBQS9CO3dCQUNBLElBQUksQ0FBQyxPQUFMLENBQWEsQ0FBYixFQUFnQixTQUFoQixFQUEyQixRQUEzQjtBQVJGOzs7QUFSRjs7RUFIUTs7bUJBcUJWLE9BQUEsR0FBUyxTQUFBO0lBQ1AsSUFBRyxJQUFDLENBQUEsSUFBSjtNQUNFLElBQUMsQ0FBQSxJQUFELENBQUE7QUFDQSxhQUZGOztJQUlBLElBQUMsQ0FBQSxhQUFELElBQWtCLElBQUMsQ0FBQTtJQUVuQixJQUFHLElBQUMsQ0FBQSxhQUFELElBQWtCLElBQUMsQ0FBQSxlQUFuQixJQUF1QyxJQUFDLENBQUEsU0FBUyxDQUFDLE1BQVgsR0FBb0IsQ0FBOUQ7TUFDRSxJQUFDLENBQUEsUUFBRCxDQUFVLElBQUMsQ0FBQSxTQUFVLENBQUEsSUFBQyxDQUFBLFVBQUQsQ0FBWSxDQUFDLEtBQWxDO01BQ0EsSUFBQyxDQUFBLFVBQUQ7TUFDQSxJQUFHLElBQUMsQ0FBQSxVQUFELElBQWUsSUFBQyxDQUFBLFNBQVMsQ0FBQyxNQUE3QjtlQUNFLElBQUMsQ0FBQSxJQUFELEdBQVEsS0FEVjtPQUFBLE1BQUE7ZUFHRSxJQUFDLENBQUEsZUFBRCxHQUFtQixJQUFDLENBQUEsU0FBVSxDQUFBLElBQUMsQ0FBQSxVQUFELENBQVksQ0FBQyxJQUFJLENBQUMsS0FBN0IsQ0FBQSxFQUhyQjtPQUhGOztFQVBPOzttQkFlVCxJQUFBLEdBQU0sU0FBQTtJQUNKLENBQUEsQ0FBRSxNQUFGO0lBQ0EsSUFBc0Msd0JBQXRDO01BQUEsTUFBTSxDQUFDLGFBQVAsQ0FBcUIsSUFBQyxDQUFBLFdBQXRCLEVBQUE7O0lBQ0EsSUFBbUMsd0JBQW5DO01BQUEsSUFBQyxDQUFBLFdBQVcsQ0FBQyxTQUFiLEdBQXlCLE9BQXpCOztJQUNBLElBQXNCLGtCQUF0QjtNQUFBLElBQUMsQ0FBQSxLQUFLLENBQUMsSUFBSSxDQUFDLElBQVosQ0FBQSxFQUFBOztJQUNBLElBQUMsQ0FBQSxXQUFELEdBQWU7SUFDZixJQUFDLENBQUEsYUFBRCxHQUFpQjtJQUNqQixJQUFDLENBQUEsZUFBRCxHQUFtQjtJQUNuQixJQUFDLENBQUEsVUFBRCxHQUFjO1dBQ2QsSUFBQyxDQUFBLElBQUQsR0FBUTtFQVRKOzttQkFXTixLQUFBLEdBQU8sU0FBQTtJQUNMLElBQUMsQ0FBQSxJQUFELENBQUE7SUFDQSxDQUFBLENBQUUsT0FBRjtJQUNBLElBQW1DLHdCQUFuQztNQUFBLElBQUMsQ0FBQSxXQUFXLENBQUMsU0FBYixHQUF5QixPQUF6Qjs7SUFDQSxJQUFJLENBQUMsYUFBTCxDQUFtQixDQUFuQixFQUFzQixXQUFZLENBQUEsSUFBQyxDQUFBLE9BQU8sQ0FBQyxVQUFULENBQWxDO0lBQ0EsSUFBQyxDQUFBLE1BQUQsQ0FBQTtXQUNBLElBQUMsQ0FBQSxXQUFELEdBQWUsTUFBTSxDQUFDLFdBQVAsQ0FBbUIsQ0FBQyxDQUFBLFNBQUEsS0FBQTthQUFBLFNBQUE7ZUFBTSxLQUFDLENBQUEsT0FBRCxDQUFBO01BQU47SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBLENBQUQsQ0FBbkIsRUFBdUMsSUFBQyxDQUFBLFlBQXhDO0VBTlY7O21CQVFQLElBQUEsR0FBTSxTQUFBO0lBQ0osQ0FBQSxDQUFFLFFBQUYsRUFBWSxJQUFDLENBQUEsWUFBYixFQUEyQixJQUFDLENBQUEsaUJBQTVCO0lBQ0EsSUFBRyxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQU0sQ0FBQyxrQkFBbUIsQ0FBQSxJQUFDLENBQUEsT0FBTyxDQUFDLFVBQVQsQ0FBbkMsSUFBNEQsQ0FBSSxJQUFDLENBQUEsT0FBcEU7YUFDRSxJQUFDLENBQUEsS0FBRCxDQUFBLEVBREY7S0FBQSxNQUFBO01BR0UsQ0FBQSxDQUFFLHdCQUFGO01BQ0EsSUFBQyxDQUFBLGVBQWUsQ0FBQyxPQUFqQixHQUEyQjtNQUMzQixJQUFDLENBQUEsZUFBZSxDQUFDLFNBQWpCLEdBQTZCO01BQzdCLElBQUMsQ0FBQSxPQUFELEdBQVc7TUFDWCxJQUFDLENBQUEsS0FBSyxDQUFDLElBQUksQ0FBQyxJQUFaLENBQUE7YUFFQSxJQUFJLENBQUMsVUFBTCxDQUNFO1FBQUEsWUFBQSxFQUFjLElBQUMsQ0FBQSxPQUFPLENBQUMsYUFBdkI7UUFDQSxXQUFBLEVBQWEsQ0FBQyxJQUFDLENBQUEsT0FBTyxDQUFDLFVBQVYsQ0FEYjtRQUVBLFFBQUEsRUFBVSxDQUFBLFNBQUEsS0FBQTtpQkFBQSxTQUFBO1lBQ1IsT0FBTyxDQUFDLEdBQVIsQ0FBWSwwQ0FBWjtZQUNBLEdBQUcsQ0FBQyxJQUFJLENBQUMsTUFBTSxDQUFDLGtCQUFtQixDQUFBLEtBQUMsQ0FBQSxPQUFPLENBQUMsVUFBVCxDQUFuQyxHQUEwRDtZQUMxRCxLQUFDLENBQUEsT0FBRCxHQUFXO1lBQ1gsS0FBQyxDQUFBLGVBQWUsQ0FBQyxPQUFqQixHQUEyQjttQkFDM0IsS0FBQyxDQUFBLEtBQUQsQ0FBQTtVQUxRO1FBQUEsQ0FBQSxDQUFBLENBQUEsSUFBQSxDQUZWO09BREYsRUFURjs7RUFGSTs7Ozs7O0FBcUJSLE1BQU0sQ0FBQyxPQUFQLEdBQWlCLEdBQUcsQ0FBQyxJQUFJLENBQUM7Ozs7QUN2UDFCLElBQUEsc0JBQUE7RUFBQTs7O0FBQUEsR0FBQSxHQUFNLE9BQUEsQ0FBUSxTQUFSOztBQUNOLENBQUEsR0FBSSxPQUFBLENBQVEsWUFBUjs7QUFDSixNQUFBLEdBQVMsT0FBQSxDQUFRLDBCQUFSOztBQUVIO0FBQ0osTUFBQTs7RUFBQSxNQUFDLENBQUEsS0FBRCxHQUFTOztFQUNULENBQUEsR0FBSSxTQUFBO0FBQWEsUUFBQTtJQUFaO0lBQVksSUFBOEMsTUFBTSxDQUFDLEtBQXJEO2tFQUFBLE9BQU8sQ0FBRSxHQUFULGdCQUFhLENBQUEsbUJBQXFCLFNBQUEsV0FBQSxJQUFBLENBQUEsQ0FBbEMsV0FBQTs7RUFBYjs7RUFHSixRQUFBLEdBQVcsU0FBQyxNQUFELEVBQVMsR0FBVDtXQUNMLElBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxZQUFULEVBQ1ksR0FBRCxHQUFLLFdBQUwsR0FBZ0IsTUFBTSxDQUFDLEVBQXZCLEdBQTBCLFVBQTFCLEdBQW9DLE1BQU0sQ0FBQyxFQUR0RDtFQURLOztFQUtFLGdCQUFDLE1BQUQ7SUFBQyxJQUFDLENBQUEsU0FBRDtJQUNaLElBQUMsQ0FBQSxLQUFELENBQUE7RUFEVzs7bUJBR2IsS0FBQSxHQUFPLFNBQUE7SUFDTCxJQUFDLENBQUEsS0FBRCxHQUFTO1dBQ1QsSUFBQyxDQUFBLFFBQUQsR0FBWTtFQUZQOzttQkFJUCxPQUFBLEdBQVMsU0FBQTtXQUFHLElBQUMsQ0FBQTtFQUFKOzttQkFFVCxTQUFBLEdBQVcsU0FBQTtBQUFHLFdBQU8sSUFBQyxDQUFBO0VBQVg7O21CQUVYLGlCQUFBLEdBQW1CLFNBQUMsT0FBRDtBQUNqQixRQUFBO0lBQUEsTUFBQSxHQUFTO0lBQ1QsSUFBcUIsZUFBckI7QUFBQSxhQUFPLE9BQVA7O0lBRUEsZUFBQSxHQUFrQjtBQUNsQixTQUFBLHlDQUFBOztNQUNFLEtBQUEsR0FBUSxTQUFDLEdBQUQ7ZUFBUyxRQUFBLENBQVMsTUFBVCxFQUFpQixHQUFqQjtNQUFUO01BQ1IsTUFBTyxDQUFBLE1BQU0sQ0FBQyxHQUFQLENBQVAsR0FBcUIsTUFBTSxDQUFDO0FBQzVCLGNBQU8sTUFBTSxDQUFDLEdBQWQ7QUFBQSxhQUNPLFVBRFA7QUFBQSxhQUNtQixXQURuQjtVQUVJLGVBQUEsR0FBa0I7VUFDbEIsV0FBNEQsTUFBTSxDQUFDLE1BQVAsS0FBcUIsTUFBckIsSUFBQSxHQUFBLEtBQTZCLE9BQXpGO0FBQUEsa0JBQU0sS0FBQSxDQUFNLEdBQUEsR0FBSSxNQUFNLENBQUMsR0FBWCxHQUFlLDZCQUFyQixFQUFOOztBQUZlO0FBRG5CLGFBSU8sS0FKUDtVQUtJLElBQUEsQ0FBOEQsQ0FBQyxDQUFDLEdBQUYsQ0FBTSxHQUFHLENBQUMsSUFBSSxDQUFDLFlBQVksQ0FBQyxRQUE1QixFQUFzQyxNQUFNLENBQUMsS0FBN0MsQ0FBOUQ7QUFBQSxrQkFBTSxLQUFBLENBQU0seUJBQUEsR0FBMEIsTUFBTSxDQUFDLEtBQWpDLEdBQXVDLEdBQTdDLEVBQU47O0FBREc7QUFKUCxhQU1PLE1BTlA7VUFPSSxLQUFBLEdBQVEsQ0FBQyxRQUFELEVBQVcsTUFBWCxFQUFtQixPQUFuQixFQUE0QixNQUE1QixFQUFvQyxZQUFwQyxFQUFrRCxNQUFsRDtVQUNSLFdBQTRELE1BQU0sQ0FBQyxLQUFQLEVBQUEsYUFBb0IsS0FBcEIsRUFBQSxJQUFBLEtBQTVEO0FBQUEsa0JBQU0sS0FBQSxDQUFNLHdCQUFBLEdBQXdCLENBQUMsS0FBSyxDQUFDLElBQU4sQ0FBVyxJQUFYLENBQUQsQ0FBOUIsRUFBTjs7QUFGRztBQU5QLGFBU08sT0FUUDtVQVVJLE1BQUEsR0FBUyxDQUFDLEtBQUQsRUFBUSxRQUFSLEVBQWtCLEtBQWxCO1VBQ1QsV0FBOEQsTUFBTSxDQUFDLEtBQVAsRUFBQSxhQUFvQixNQUFwQixFQUFBLElBQUEsS0FBOUQ7QUFBQSxrQkFBTSxLQUFBLENBQU0seUJBQUEsR0FBeUIsQ0FBQyxNQUFNLENBQUMsSUFBUCxDQUFZLElBQVosQ0FBRCxDQUEvQixFQUFOOztBQUZHO0FBVFAsYUFZTyxNQVpQO0FBYUk7WUFDTSxJQUFBLEdBQUcsQ0FBQyxJQUFJLENBQUMsYUFBVCxDQUF1QixNQUFNLENBQUMsS0FBOUIsRUFETjtXQUFBLGNBQUE7WUFFTTtBQUNKLGtCQUFNLEtBQUEsQ0FBTSwyQkFBQSxHQUE0QixNQUFNLENBQUMsS0FBbkMsR0FBeUMsR0FBL0MsRUFIUjs7QUFERztBQVpQLGFBaUJPLFFBakJQO0FBa0JJO1lBQ00sSUFBQSxHQUFHLENBQUMsSUFBSSxDQUFDLE1BQVQsQ0FBZ0IsTUFBTSxDQUFDLEtBQXZCLEVBRE47V0FBQSxjQUFBO1lBRU07QUFDSixrQkFBTSxLQUFBLENBQU0sbUJBQUEsR0FBb0IsTUFBTSxDQUFDLEtBQTNCLEdBQWlDLEdBQXZDLEVBSFI7O0FBREc7QUFqQlAsYUFzQk8sU0F0QlA7VUF1QkksV0FBQSxHQUFjLFFBQUEsQ0FBUyxNQUFNLENBQUMsS0FBaEI7VUFDZCxJQUE2RCxXQUFBLEdBQWMsQ0FBZCxJQUFtQixXQUFBLEdBQWMsQ0FBOUY7QUFBQSxrQkFBTSxLQUFBLENBQU0sNkJBQUEsR0FBOEIsV0FBcEMsRUFBTjs7QUFGRztBQXRCUDtBQTBCSSxnQkFBTSxLQUFBLENBQU0sa0JBQUEsR0FBbUIsTUFBTSxDQUFDLEdBQTFCLEdBQThCLEdBQXBDO0FBMUJWO0FBSEY7SUErQkEsSUFBRyxNQUFNLENBQUMsUUFBUCxLQUFtQixPQUFuQixJQUErQixNQUFNLENBQUMsU0FBUCxLQUFvQixPQUF0RDtBQUNFLFlBQU0sUUFBQSxDQUFTLGVBQVQsRUFBMEIsb0RBQTFCLEVBRFI7O0FBR0EsV0FBTztFQXZDVTs7bUJBeUNuQixZQUFBLEdBQWMsU0FBQyxPQUFEO0lBQ1osSUFBRyxPQUFPLENBQUMsT0FBUixLQUFtQixLQUF0QjtNQUNFLElBQUMsQ0FBQSxNQUFNLENBQUMsTUFBUixDQUFlLE9BQU8sQ0FBQyxJQUF2QixFQURGOztJQUdBLElBQUcsT0FBTyxDQUFDLE9BQVIsS0FBbUIsUUFBdEI7TUFDRSxJQUFDLENBQUEsTUFBTSxDQUFDLFdBQVIsQ0FBb0IsT0FBTyxDQUFDLE1BQU0sQ0FBQyxNQUFuQyxFQUEyQyxPQUFPLENBQUMsTUFBTSxDQUFDLEtBQTFELEVBREY7O0lBR0EsSUFBRyxPQUFPLENBQUMsT0FBUixLQUFtQixhQUF0QjtNQUNFLElBQUMsQ0FBQSxNQUFNLENBQUMsY0FBUixDQUF1QixPQUFPLENBQUMsTUFBL0IsRUFERjs7SUFHQSxJQUFHLE9BQU8sQ0FBQyxPQUFSLEtBQW1CLE1BQXRCO01BQ0UsSUFBQyxDQUFBLE1BQU0sQ0FBQyxPQUFSLENBQWdCLE9BQU8sQ0FBQyxNQUF4QixFQURGOztJQUdBLElBQUcsT0FBTyxDQUFDLE9BQVIsS0FBbUIsU0FBdEI7YUFDRSxJQUFDLENBQUEsTUFBTSxDQUFDLFVBQVIsQ0FBbUIsT0FBTyxDQUFDLE1BQTNCLEVBQW1DLE9BQU8sQ0FBQyxFQUEzQyxFQUErQyxPQUFPLENBQUMsRUFBdkQsRUFERjs7RUFiWTs7bUJBZ0JkLFVBQUEsR0FBWSxTQUFDLE9BQUQ7SUFDVixDQUFBLENBQUUsYUFBRixFQUFpQixPQUFqQjtXQUNBLElBQUMsQ0FBQSxNQUFNLENBQUMsUUFBUixDQUNFLENBQUMsQ0FBQyxHQUFGLENBQU0sT0FBTyxDQUFDLEtBQWQsRUFDTSxTQUFDLElBQUQ7YUFBUyxDQUFDLENBQUMsSUFBRixDQUFPLElBQVAsRUFBYSxNQUFiLEVBQXFCLEtBQXJCLEVBQTRCLE1BQTVCLEVBQW9DLEtBQXBDLEVBQTJDLFFBQTNDLEVBQXFELFFBQXJELEVBQStELGNBQS9ELEVBQStFLFdBQS9FO0lBQVQsQ0FETixDQURGLEVBR0UsT0FBTyxDQUFDLFlBSFYsRUFHd0IsT0FBTyxDQUFDLFNBSGhDO0VBRlU7O21CQU9aLFNBQUEsR0FBVyxTQUFDLElBQUQ7V0FDVCxJQUFDLENBQUEsTUFBTSxDQUFDLE9BQVIsQ0FBZ0IsQ0FBQyxDQUFDLElBQUYsQ0FDZCxJQURjLEVBQ1IsTUFEUSxFQUNBLEtBREEsRUFDTyxNQURQLEVBQ2UsUUFEZixFQUN5QixjQUR6QixFQUN5QyxXQUR6QyxDQUFoQjtFQURTOzttQkFJWCxRQUFBLEdBQVUsU0FBQyxJQUFEO1dBQ1IsSUFBQyxDQUFBLE1BQU0sQ0FBQyxPQUFSLENBQWdCLENBQUMsQ0FBQyxJQUFGLENBQ2QsSUFEYyxFQUNSLE1BRFEsRUFDQSxLQURBLEVBQ08sTUFEUCxFQUNlLEtBRGYsRUFDc0IsUUFEdEIsRUFDZ0MsUUFEaEMsRUFDMEMsY0FEMUMsRUFDMEQsV0FEMUQsQ0FBaEI7RUFEUTs7bUJBSVYsa0JBQUEsR0FBb0IsU0FBQyxLQUFEO0FBQ2xCLFFBQUE7SUFBQSxDQUFBLENBQUUscUJBQUYsRUFBeUIsS0FBekI7QUFDQTtTQUFBLHVDQUFBOztNQUNFLElBQUcsT0FBTyxDQUFDLElBQVg7UUFDRSxJQUFDLENBQUEsTUFBTSxDQUFDLFdBQVIsQ0FBb0IsT0FBTyxDQUFDLElBQTVCLEVBQWtDLE9BQU8sQ0FBQyxHQUExQyxFQURGOztNQUdBLElBQUcsT0FBTyxDQUFDLE9BQVg7UUFDRSxJQUFDLENBQUEsWUFBRCxDQUFjLE9BQWQsRUFERjs7TUFHQSxJQUFHLE9BQU8sQ0FBQyxLQUFYO1FBQ0UsSUFBQyxDQUFBLFVBQUQsQ0FBWSxPQUFaLEVBREY7O01BR0EsSUFBRyxPQUFPLENBQUMsR0FBWDtxQkFDRSxJQUFDLENBQUEsUUFBRCxDQUFVLE9BQVYsR0FERjtPQUFBLE1BRUssSUFBRyxPQUFPLENBQUMsSUFBWDtxQkFDSCxJQUFDLENBQUEsU0FBRCxDQUFXLE9BQVgsR0FERztPQUFBLE1BQUE7NkJBQUE7O0FBWlA7O0VBRmtCOzttQkFpQnBCLGNBQUEsR0FBZ0IsU0FBQyxTQUFEO0FBQ2QsUUFBQTtJQUFBLElBQUEsQ0FBOEIsQ0FBQyxDQUFDLE9BQUYsQ0FBVSxTQUFWLENBQTlCO01BQUEsSUFBQyxDQUFBLE1BQU0sQ0FBQyxZQUFSLENBQUEsRUFBQTs7SUFFQSxRQUFBLEdBQVc7SUFDWCxhQUFBLEdBQWdCO0lBQ2hCLE1BQUEsR0FBUztJQUNULElBQUEsR0FBTztJQUVQLE9BQUEsR0FBVSxDQUFBLFNBQUEsS0FBQTthQUFBLFNBQUE7ZUFBRyxLQUFDLENBQUEsTUFBTSxDQUFDLFdBQVIsQ0FBb0IsRUFBcEIsRUFBd0IsQ0FBeEIsRUFBMkIsYUFBM0IsRUFBMEMsS0FBMUMsRUFBaUQsSUFBakQ7TUFBSDtJQUFBLENBQUEsQ0FBQSxDQUFBLElBQUE7SUFDVixVQUFBLEdBQWEsQ0FBQSxTQUFBLEtBQUE7YUFBQSxTQUFDLElBQUQ7QUFDWCxZQUFBO1FBQUEsWUFBQSxHQUFlO1FBQ2YsSUFBRyxJQUFLLENBQUEsQ0FBQSxDQUFMLEtBQVcsR0FBZDtVQUNFLFlBQUEsR0FBZTtVQUNmLElBQUEsR0FBTyxJQUFLLFVBRmQ7O0FBSUE7aUJBQ0UsS0FBQyxDQUFBLE1BQU0sQ0FBQyxXQUFSLENBQW9CLElBQXBCLEVBQTBCLFFBQTFCLEVBQW9DLGFBQXBDLEVBQW1ELE1BQW5ELEVBQTJELFlBQTNELEVBREY7U0FBQSxjQUFBO1VBRU07QUFDSixnQkFBTSxRQUFBLENBQVMsR0FBVCxFQUFjLCtDQUFBLEdBQWtELENBQWhFLEVBSFI7O01BTlc7SUFBQSxDQUFBLENBQUEsQ0FBQSxJQUFBO0FBV2I7U0FBQSwyQ0FBQTs7TUFDRSxJQUFBLEdBQU8sR0FBRyxDQUFDLElBQUksQ0FBQyxJQUFULENBQUE7TUFDUCxJQUFHLElBQUksQ0FBQyxLQUFMLENBQVcsV0FBWCxDQUFIO1FBQ0UsSUFBQSxHQUFPLElBQUs7cUJBQ1osSUFBQyxDQUFBLE1BQU0sQ0FBQyxXQUFSLENBQW9CLElBQXBCLEdBRkY7T0FBQSxNQUdLLElBQUcsSUFBSyxDQUFBLENBQUEsQ0FBTCxLQUFXLEdBQWQ7cUJBQ0gsSUFBQyxDQUFBLE1BQU0sQ0FBQyxXQUFSLENBQW9CLElBQXBCLEdBREc7T0FBQSxNQUVBLElBQUcsSUFBSyxDQUFBLENBQUEsQ0FBTCxLQUFXLEdBQWQ7UUFDSCxPQUFBLEdBQVUsSUFBSztBQUNmLGdCQUFPLE9BQVA7QUFBQSxlQUNPLFFBRFA7QUFBQSxlQUNpQixNQURqQjtBQUFBLGVBQ3lCLE9BRHpCO3lCQUVJLGFBQUEsR0FBZ0I7QUFESztBQUR6QixlQUdPLFFBSFA7eUJBSUksTUFBQSxHQUFTO0FBRE47QUFIUCxlQUtPLFFBTFA7eUJBTUksTUFBQSxHQUFTO0FBRE47QUFMUCxlQU9PLEtBUFA7QUFBQSxlQU9jLEdBUGQ7eUJBUUksT0FBQSxDQUFBO0FBRFU7QUFQZDt5QkFVSSxRQUFBLEdBQVcsUUFBQSxDQUFTLElBQUssU0FBZCxFQUFvQixFQUFwQjtBQVZmLFNBRkc7T0FBQSxNQWFBLElBQUcsSUFBQSxLQUFRLEdBQVg7cUJBQ0gsT0FBQSxDQUFBLEdBREc7T0FBQSxNQUVBLElBQUcsSUFBSyxZQUFMLEtBQWMsSUFBakI7cUJBQ0gsSUFBQyxDQUFBLE1BQU0sQ0FBQyxZQUFSLENBQUEsR0FERztPQUFBLE1BQUE7cUJBR0gsVUFBQSxDQUFXLElBQVgsR0FIRzs7QUF0QlA7O0VBcEJjOzttQkErQ2hCLFFBQUEsR0FBVSxTQUFBO0FBQ1IsUUFBQTtBQUFBO0FBQUE7U0FBQSxxQ0FBQTs7QUFDRSxjQUFPLEtBQUssQ0FBQyxPQUFiO0FBQUEsYUFDTyxZQURQO1VBRUksa0JBQUEsR0FBcUIsSUFBQyxDQUFBLE1BQU0sQ0FBQyxpQkFBUixDQUFBO1VBQ3JCLElBQUMsQ0FBQSxNQUFNLENBQUMsYUFBUixDQUFBO0FBQ0E7QUFBQSxlQUFBLHdDQUFBOztZQUNFLENBQUEsQ0FBRSxtQkFBRixFQUF1QixDQUF2QjtZQUNBLElBQUMsQ0FBQSxNQUFNLENBQUMsUUFBUixDQUNFLGtCQURGLEVBRUUsQ0FBQyxDQUFDLE9BRkosRUFHRSxJQUFDLENBQUEsaUJBQUQsQ0FBbUIsQ0FBQyxDQUFDLE9BQXJCLENBSEY7WUFLQSxJQUFnQyxlQUFoQztjQUFBLElBQUMsQ0FBQSxrQkFBRCxDQUFvQixDQUFDLENBQUMsS0FBdEIsRUFBQTs7WUFDQSxJQUEyQixjQUEzQjtjQUFBLElBQUMsQ0FBQSxjQUFELENBQWdCLENBQUMsQ0FBQyxJQUFsQixFQUFBOztBQVJGO3VCQVNBLENBQUEsQ0FBRSxzQkFBRixFQUEwQixJQUFDLENBQUEsTUFBTSxDQUFDLFdBQVksQ0FBQSxrQkFBQSxDQUE5QztBQVpHO0FBRFAsYUFjTyxPQWRQO3VCQWVJLENBQUEsQ0FBRSx5QkFBRjtBQURHO0FBZFAsYUFtQk8sU0FuQlA7VUFvQkksT0FBQSxHQUFVO0FBQ1Y7QUFBQSxlQUFBLHdDQUFBOztZQUNFLE9BQVEsQ0FBQSxNQUFNLENBQUMsR0FBUCxDQUFSLEdBQXNCLE1BQU0sQ0FBQztBQUQvQjtBQUVBO3lCQUNFLElBQUMsQ0FBQSxNQUFNLENBQUMsVUFBUixDQUFtQixPQUFuQixHQURGO1dBQUEsY0FBQTtZQUVNO0FBQ0osa0JBQU0sUUFBQSxDQUFTLEtBQVQsRUFBZ0IsQ0FBQyxDQUFDLE9BQWxCLEVBSFI7O0FBSkc7QUFuQlA7QUE0QkksZ0JBQU0sUUFBQSxDQUFTLEtBQVQsRUFBZ0IsbUJBQUEsR0FBb0IsS0FBSyxDQUFDLE9BQTFCLEdBQWtDLEdBQWxEO0FBNUJWO0FBREY7O0VBRFE7O21CQWdDVixLQUFBLEdBQU8sU0FBQyxJQUFEO0FBQ0wsUUFBQTtJQUFBLE1BQU0sQ0FBQyxVQUFQLEdBQW9CLFNBQUMsT0FBRCxFQUFVLElBQVY7TUFDbEIsQ0FBQSxDQUFFLHNCQUFGLEVBQTBCLE9BQTFCLEVBQW1DLElBQW5DO01BQ0EsT0FBQSxHQUFVLG1CQUFBLEdBQW9CLElBQUksQ0FBQyxJQUF6QixHQUE4QixZQUE5QixHQUEwQyxJQUFJLENBQUMsR0FBRyxDQUFDLFVBQW5ELEdBQThELFVBQTlELEdBQXdFLElBQUksQ0FBQyxHQUFHLENBQUMsWUFBakYsR0FBOEY7QUFDeEcsWUFBVSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsWUFBVCxFQUF1QixPQUF2QjtJQUhRO0lBS3BCLElBQW1ELFlBQW5EO0FBQUEsWUFBVSxJQUFBLEdBQUcsQ0FBQyxJQUFKLENBQVMsWUFBVCxFQUF1QixTQUF2QixFQUFWOztJQUVBLENBQUEsQ0FBRSxZQUFBLEdBQWEsSUFBZjtJQUdBLGFBQUE7O0FBQWlCO0FBQUE7V0FBQSxxQ0FBQTs7cUJBQUEsSUFBSSxDQUFDLElBQUwsQ0FBQTtBQUFBOzs7SUFDakIsSUFBQyxDQUFBLFFBQUQsR0FBWSxNQUFNLENBQUMsS0FBUCxDQUFhLGFBQWEsQ0FBQyxJQUFkLENBQW1CLElBQW5CLENBQWI7SUFDWixJQUFHLElBQUMsQ0FBQSxRQUFKO01BQ0UsSUFBQyxDQUFBLFFBQUQsQ0FBQTtNQUNBLElBQUMsQ0FBQSxLQUFELEdBQVMsS0FGWDs7QUFJQSxXQUFPLElBQUMsQ0FBQTtFQWpCSDs7Ozs7O0FBbUJULE1BQU0sQ0FBQyxPQUFQLEdBQWlCOzs7O0FDNU5qQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uIGUodCxuLHIpe2Z1bmN0aW9uIHMobyx1KXtpZighbltvXSl7aWYoIXRbb10pe3ZhciBhPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7aWYoIXUmJmEpcmV0dXJuIGEobywhMCk7aWYoaSlyZXR1cm4gaShvLCEwKTt2YXIgZj1uZXcgRXJyb3IoXCJDYW5ub3QgZmluZCBtb2R1bGUgJ1wiK28rXCInXCIpO3Rocm93IGYuY29kZT1cIk1PRFVMRV9OT1RfRk9VTkRcIixmfXZhciBsPW5bb109e2V4cG9ydHM6e319O3Rbb11bMF0uY2FsbChsLmV4cG9ydHMsZnVuY3Rpb24oZSl7dmFyIG49dFtvXVsxXVtlXTtyZXR1cm4gcyhuP246ZSl9LGwsbC5leHBvcnRzLGUsdCxuLHIpfXJldHVybiBuW29dLmV4cG9ydHN9dmFyIGk9dHlwZW9mIHJlcXVpcmU9PVwiZnVuY3Rpb25cIiYmcmVxdWlyZTtmb3IodmFyIG89MDtvPHIubGVuZ3RoO28rKylzKHJbb10pO3JldHVybiBzfSkiLCIvKipcbiAqIFZleEZsb3cgMS4yLjM2IGJ1aWx0IG9uIDIwMTYtMDItMDQuXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTAgTW9oaXQgTXV0aGFubmEgQ2hlcHB1ZGlyYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuICpcbiAqIGh0dHA6Ly93d3cudmV4Zmxvdy5jb20gIGh0dHA6Ly9naXRodWIuY29tLzB4ZmUvdmV4Zmxvd1xuICovXG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIHV0aWxpdHkgbWV0aG9kcyB1c2VkIGJ5IHRoZSByZXN0IG9mIHRoZSBWZXhGbG93XG4vLyBjb2RlYmFzZS5cbi8vXG4vLyAjIyBKU0hpbnQgU2V0dGluZ3Ncbi8vXG4vKiBnbG9iYWwgd2luZG93OiBmYWxzZSAqL1xuLyogZ2xvYmFsIGRvY3VtZW50OiBmYWxzZSAqL1xuXG5pZiAodHlwZW9mIFZleCA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgLyogZ2xvYmFsIFZleDogdHJ1ZSAqL1xuICBWZXggPSBmdW5jdGlvbigpIHt9O1xufVxuXG4vLyBEZWZhdWx0IGxvZyBmdW5jdGlvbiBzZW5kcyBhbGwgYXJndW1lbnRzIHRvIGNvbnNvbGUuXG5WZXguTCA9IGZ1bmN0aW9uKGJsb2NrLCBhcmdzKSB7XG4gIGlmICghYXJncykgcmV0dXJuO1xuICB2YXIgbGluZSA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3MpLmpvaW4oXCIgXCIpO1xuICB3aW5kb3cuY29uc29sZS5sb2coYmxvY2sgKyBcIjogXCIgKyBsaW5lKTtcbn07XG5cbi8vIERlZmF1bHQgcnVudGltZSBleGNlcHRpb24uXG5WZXguUnVudGltZUVycm9yID0gZnVuY3Rpb24oY29kZSwgbWVzc2FnZSkge1xuICB0aGlzLmNvZGUgPSBjb2RlO1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufTtcblxuVmV4LlJ1bnRpbWVFcnJvci5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIFwiUnVudGltZUVycm9yOiBcIiArIHRoaXMubWVzc2FnZTtcbn07XG5cbi8vIFNob3J0Y3V0IG1ldGhvZCBmb3IgYFJ1bnRpbWVFcnJvcmAuXG5WZXguUkVSUiA9IFZleC5SdW50aW1lRXJyb3I7XG5cbi8vIE1lcmdlIGBkZXN0aW5hdGlvbmAgaGFzaCB3aXRoIGBzb3VyY2VgIGhhc2gsIG92ZXJ3cml0aW5nIGxpa2Uga2V5c1xuLy8gaW4gYHNvdXJjZWAgaWYgbmVjZXNzYXJ5LlxuVmV4Lk1lcmdlID0gZnVuY3Rpb24oZGVzdGluYXRpb24sIHNvdXJjZSkge1xuICBmb3IgKHZhciBwcm9wZXJ0eSBpbiBzb3VyY2UpXG4gICAgZGVzdGluYXRpb25bcHJvcGVydHldID0gc291cmNlW3Byb3BlcnR5XTtcbiAgcmV0dXJuIGRlc3RpbmF0aW9uO1xufTtcblxuLy8gREVQUkVDQVRFRC4gVXNlIGBNYXRoLipgLlxuVmV4Lk1pbiA9IE1hdGgubWluO1xuVmV4Lk1heCA9IE1hdGgubWF4O1xuVmV4LmZvckVhY2ggPSBmdW5jdGlvbihhLCBmbikge1xuICBmb3IgKHZhciBpPTA7IGk8YS5sZW5ndGg7IGkrKykge1xuICAgIGZuKGFbaV0saSk7XG4gIH1cbn07XG5cbi8vIFJvdW5kIG51bWJlciB0byBuZWFyZXN0IGZyYWN0aW9uYWwgdmFsdWUgKGAuNWAsIGAuMjVgLCBldGMuKVxuVmV4LlJvdW5kTiA9IGZ1bmN0aW9uKHgsIG4pIHtcbiAgcmV0dXJuICh4ICUgbikgPj0gKG4vMikgP1xuICAgIHBhcnNlSW50KHggLyBuLCAxMCkgKiBuICsgbiA6IHBhcnNlSW50KHggLyBuLCAxMCkgKiBuO1xufTtcblxuLy8gTG9jYXRlIHRoZSBtaWQgcG9pbnQgYmV0d2VlbiBzdGF2ZSBsaW5lcy4gUmV0dXJucyBhIGZyYWN0aW9uYWwgbGluZSBpZiBhIHNwYWNlLlxuVmV4Lk1pZExpbmUgPSBmdW5jdGlvbihhLCBiKSB7XG4gIHZhciBtaWRfbGluZSA9IGIgKyAoYSAtIGIpIC8gMjtcbiAgaWYgKG1pZF9saW5lICUgMiA+IDApIHtcbiAgICBtaWRfbGluZSA9IFZleC5Sb3VuZE4obWlkX2xpbmUgKiAxMCwgNSkgLyAxMDtcbiAgfVxuICByZXR1cm4gbWlkX2xpbmU7XG59O1xuXG4vLyBUYWtlIGBhcnJgIGFuZCByZXR1cm4gYSBuZXcgbGlzdCBjb25zaXN0aW5nIG9mIHRoZSBzb3J0ZWQsIHVuaXF1ZSxcbi8vIGNvbnRlbnRzIG9mIGFyci4gRG9lcyBub3QgbW9kaWZ5IGBhcnJgLlxuVmV4LlNvcnRBbmRVbmlxdWUgPSBmdW5jdGlvbihhcnIsIGNtcCwgZXEpIHtcbiAgaWYgKGFyci5sZW5ndGggPiAxKSB7XG4gICAgdmFyIG5ld0FyciA9IFtdO1xuICAgIHZhciBsYXN0O1xuICAgIGFyci5zb3J0KGNtcCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKGkgPT09IDAgfHwgIWVxKGFycltpXSwgbGFzdCkpIHtcbiAgICAgICAgbmV3QXJyLnB1c2goYXJyW2ldKTtcbiAgICAgIH1cbiAgICAgIGxhc3QgPSBhcnJbaV07XG4gICAgfVxuXG4gICAgcmV0dXJuIG5ld0FycjtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gYXJyO1xuICB9XG59O1xuXG4vLyBDaGVjayBpZiBhcnJheSBgYWAgY29udGFpbnMgYG9iamAuXG5WZXguQ29udGFpbnMgPSBmdW5jdGlvbihhLCBvYmopIHtcbiAgdmFyIGkgPSBhLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChhW2ldID09PSBvYmopIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2U7XG59O1xuXG4vLyBHZXQgdGhlIDJEIENhbnZhcyBjb250ZXh0IGZyb20gRE9NIGVsZW1lbnQgYGNhbnZhc19zZWxgLlxuVmV4LmdldENhbnZhc0NvbnRleHQgPSBmdW5jdGlvbihjYW52YXNfc2VsKSB7XG4gIGlmICghY2FudmFzX3NlbClcbiAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudFwiLCBcIkludmFsaWQgY2FudmFzIHNlbGVjdG9yOiBcIiArIGNhbnZhc19zZWwpO1xuXG4gIHZhciBjYW52YXMgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChjYW52YXNfc2VsKTtcbiAgaWYgKCEoY2FudmFzICYmIGNhbnZhcy5nZXRDb250ZXh0KSkge1xuICAgIHRocm93IG5ldyBWZXguUkVSUihcIlVuc3VwcG9ydGVkQnJvd3NlckVycm9yXCIsXG4gICAgICAgIFwiVGhpcyBicm93c2VyIGRvZXMgbm90IHN1cHBvcnQgSFRNTDUgQ2FudmFzXCIpO1xuICB9XG5cbiAgcmV0dXJuIGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xufTtcblxuLy8gRHJhdyBhIHRpbnkgZG90IG1hcmtlciBvbiB0aGUgc3BlY2lmaWVkIGNhbnZhcy4gQSBncmVhdCBkZWJ1Z2dpbmcgYWlkLlxuLy9cbi8vIGBjdHhgOiBDYW52YXMgY29udGV4dC5cbi8vIGB4YCwgYHlgOiBEb3QgY29vcmRpbmF0ZXMuXG5WZXguZHJhd0RvdCA9IGZ1bmN0aW9uKGN0eCwgeCwgeSwgY29sb3IpIHtcbiAgdmFyIGMgPSBjb2xvciB8fCBcIiNmNTVcIjtcbiAgY3R4LnNhdmUoKTtcbiAgY3R4LnNldEZpbGxTdHlsZShjKTtcblxuICAvL2RyYXcgYSBjaXJjbGVcbiAgY3R4LmJlZ2luUGF0aCgpO1xuICBjdHguYXJjKHgsIHksIDMsIDAsIE1hdGguUEkqMiwgdHJ1ZSk7XG4gIGN0eC5jbG9zZVBhdGgoKTtcbiAgY3R4LmZpbGwoKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn07XG5cbi8vIEJlbmNobWFyay4gUnVuIGZ1bmN0aW9uIGBmYCBvbmNlIGFuZCByZXBvcnQgdGltZSBlbGFwc2VkIHNoaWZ0ZWQgYnkgYHNgIG1pbGxpc2Vjb25kcy5cblZleC5CTSA9IGZ1bmN0aW9uKHMsIGYpIHtcbiAgdmFyIHN0YXJ0X3RpbWUgPSBuZXcgRGF0ZSgpLmdldFRpbWUoKTtcbiAgZigpO1xuICB2YXIgZWxhcHNlZCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpIC0gc3RhcnRfdGltZTtcbiAgVmV4LkwocyArIGVsYXBzZWQgKyBcIm1zXCIpO1xufTtcblxuLy8gQmFzaWMgY2xhc3NpY2FsIGluaGVyaXRhbmNlIGhlbHBlci4gVXNhZ2U6XG4vLyBgYGBcbi8vIC8vIFZleC5Jbmhlcml0KENoaWxkLCBQYXJlbnQsIHtcbi8vIC8vICAgZ2V0TmFtZTogZnVuY3Rpb24oKSB7cmV0dXJuIHRoaXMubmFtZTt9LFxuLy8gLy8gICBzZXROYW1lOiBmdW5jdGlvbihuYW1lKSB7dGhpcy5uYW1lID0gbmFtZX1cbi8vIC8vIH0pO1xuLy8gLy9cbi8vIC8vIFJldHVybnMgJ0NoaWxkJy5cbi8vIGBgYFxuVmV4LkluaGVyaXQgPSAoZnVuY3Rpb24gKCkge1xuICB2YXIgRiA9IGZ1bmN0aW9uICgpIHt9O1xuICAvLyBgQ2AgaXMgQ2hpbGQuIGBQYCBpcyBwYXJlbnQuIGBPYCBpcyBhbiBvYmplY3QgdG9cbiAgLy8gdG8gZXh0ZW5kIGBDYCB3aXRoLlxuICByZXR1cm4gZnVuY3Rpb24gKEMsIFAsIE8pIHtcbiAgICBGLnByb3RvdHlwZSA9IFAucHJvdG90eXBlO1xuICAgIEMucHJvdG90eXBlID0gbmV3IEYoKTtcbiAgICBDLnN1cGVyY2xhc3MgPSBQLnByb3RvdHlwZTtcbiAgICBDLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEM7XG4gICAgVmV4Lk1lcmdlKEMucHJvdG90eXBlLCBPKTtcbiAgICByZXR1cm4gQztcbiAgfTtcbn0oKSk7XG5cbi8vIEdldCBzdGFjayB0cmFjZS5cblZleC5TdGFja1RyYWNlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcbiAgcmV0dXJuIGVyci5zdGFjaztcbn07XG5cbi8vIER1bXAgd2FybmluZyB0byBjb25zb2xlLlxuVmV4LlcgPSBmdW5jdGlvbigpIHtcbiAgdmFyIGxpbmUgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMpLmpvaW4oXCIgXCIpO1xuICB3aW5kb3cuY29uc29sZS5sb2coXCJXYXJuaW5nOiBcIiwgbGluZSwgVmV4LlN0YWNrVHJhY2UoKSk7XG59O1xuXG4vLyBVc2VkIGJ5IHZhcmlvdXMgY2xhc3NlcyAoZS5nLiwgU1ZHQ29udGV4dCkgdG8gcHJvdmlkZSBhXG4vLyB1bmlxdWUgcHJlZml4IHRvIGVsZW1lbnQgbmFtZXMgKG9yIG90aGVyIGtleXMgaW4gc2hhcmVkIG5hbWVzcGFjZXMpLlxuVmV4LlByZWZpeCA9IGZ1bmN0aW9uKHRleHQpIHtcbiAgcmV0dXJuIFZleC5QcmVmaXgucHJlZml4ICsgdGV4dDtcbn07XG5WZXguUHJlZml4LnByZWZpeCA9IFwidmYtXCI7XG5cbi8vIFVNRCB0byBleHBvcnQgVmV4LlxuLy9cbi8qIGdsb2JhbCByZXF1aXJlOiBmYWxzZSAqL1xuLyogZ2xvYmFsIGRlZmluZTogZmFsc2UgKi9cbi8qIGdsb2JhbCBtb2R1bGU6IGZhbHNlICovXG5pZiAodHlwZW9mIHJlcXVpcmUgPT0gXCJmdW5jdGlvblwiKSB7XG4gIHRyeSB7XG4gICAgbW9kdWxlLmV4cG9ydHMgPSBWZXg7XG4gIH0gY2F0Y2ggKGUpIHt9XG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgZGVmaW5lKFwiVmV4XCIsIFtdLCBmdW5jdGlvbigpeyByZXR1cm4gVmV4OyB9KTtcbn0gZWxzZSB7XG4gICh0aGlzIHx8IHdpbmRvdylbXCJWZXhcIl0gPSBWZXg7XG59XG5cbi8qKlxuICogVmV4IEZsb3cgLSBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuICovXG5cbi8qKlxuICogTmV3IG5hbWVzcGFjZS5cbiAqL1xuXG5pZiAodHlwZW9mIFZleC5GbG93ID09PSAndW5kZWZpbmVkJykge1xuICBWZXguRmxvdyA9IHtcbiAgICAvKipcbiAgICAgKiBUaGUgcmVzb2x1dGlvbiB1c2VkIGZvciBhbGwgdGhlIHJoeXRobSB0aW1pbmcgaW4gdGhpc1xuICAgICAqIGxpYnJhcnkuXG4gICAgICpcbiAgICAgKiBAY29uc3RcbiAgICAgKiBAdHlwZSB7bnVtYmVyfVxuICAgICAqL1xuICAgIFJFU09MVVRJT046IDE2Mzg0LFxuXG4gICAgLyogS2VybmluZyAoREVQUkVDQVRFRCkgKi9cbiAgICBJc0tlcm5lZDogdHJ1ZVxuICB9O1xufVxuXG4vLyBGcmFjdGlvbiBjbGFzcyB0aGF0IHJlcHJlc2VudHMgYSByYXRpb25hbCBudW1iZXJcbi8vIEBhdXRob3Igeno4NVxuLy8gQGF1dGhvciBpbmNvbXBsZXRlb3B1cyAobW9kaWZpY2F0aW9ucylcblxuVmV4LkZsb3cuRnJhY3Rpb24gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEZyYWN0aW9uKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICB0aGlzLnNldChudW1lcmF0b3IsIGRlbm9taW5hdG9yKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHQ0Q6IEZpbmQgZ3JlYXRlc3QgY29tbW9uIGRpdmlzb3IgdXNpbmcgRXVjbGlkZWFuIGFsZ29yaXRobVxuICAgKi9cbiAgRnJhY3Rpb24uR0NEID0gZnVuY3Rpb24oYSwgYikge1xuICAgIGlmICh0eXBlb2YgYSAhPT0gXCJudW1iZXJcIiB8fCB0eXBlb2YgYiAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRcIiwgXCJJbnZhbGlkIG51bWJlcnM6IFwiICsgYSArIFwiLCBcIiArIGIpO1xuICAgIH1cblxuICAgIHZhciB0O1xuXG4gICAgd2hpbGUgKGIgIT09IDApIHtcbiAgICAgIHQgPSBiO1xuICAgICAgYiA9IGEgJSBiO1xuICAgICAgYSA9IHQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGE7XG4gIH07XG5cbiAgLyoqXG4gICAqIExDTTogTG93ZXN0IGNvbW1vbiBtdWx0aXBsZVxuICAgKi9cbiAgRnJhY3Rpb24uTENNID0gZnVuY3Rpb24oYSwgYikge1xuICAgIHJldHVybiAoKGEgKiBiKSAvIEZyYWN0aW9uLkdDRChhLCBiKSk7XG4gIH07XG5cbiAgLyoqXG4gICAqIExDTU06IExvd2VzdCBjb21tb24gbXVsdGlwbGUgZm9yIG1vcmUgdGhhbiB0d28gbnVtYmVyc1xuICAgKi9cbiAgRnJhY3Rpb24uTENNTSA9IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiAwO1xuICAgIH0gZWxzZSBpZiAoYXJncy5sZW5ndGggPT0gMSkge1xuICAgICAgcmV0dXJuIGFyZ3NbMF07XG4gICAgfSBlbHNlIGlmIChhcmdzLmxlbmd0aCA9PSAyKSB7XG4gICAgICByZXR1cm4gVmV4LkZsb3cuRnJhY3Rpb24uTENNKGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgYXJnMCA9IGFyZ3NbMF07XG4gICAgICBhcmdzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4gRnJhY3Rpb24uTENNKGFyZzAsIFZleC5GbG93LkZyYWN0aW9uLkxDTU0oYXJncykpO1xuICAgIH1cbiAgfTtcblxuICBGcmFjdGlvbi5wcm90b3R5cGUgPSB7XG4gICAgc2V0OiBmdW5jdGlvbihudW1lcmF0b3IsIGRlbm9taW5hdG9yKSB7XG4gICAgICB0aGlzLm51bWVyYXRvciA9IG51bWVyYXRvciA9PT0gdW5kZWZpbmVkID8gMSA6IG51bWVyYXRvcjtcbiAgICAgIHRoaXMuZGVub21pbmF0b3IgPSBkZW5vbWluYXRvciA9PT0gdW5kZWZpbmVkID8gMSA6IGRlbm9taW5hdG9yO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHZhbHVlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm51bWVyYXRvciAvIHRoaXMuZGVub21pbmF0b3I7XG4gICAgfSxcblxuICAgIHNpbXBsaWZ5OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB1ID0gdGhpcy5udW1lcmF0b3I7XG4gICAgICB2YXIgZCA9IHRoaXMuZGVub21pbmF0b3I7XG5cbiAgICAgIHZhciBnY2QgPSBWZXguRmxvdy5GcmFjdGlvbi5HQ0QodSwgZCk7XG4gICAgICB1IC89IGdjZDtcbiAgICAgIGQgLz0gZ2NkO1xuXG4gICAgICBpZiAoZCA8IDApIHtcbiAgICAgICAgZCA9IC1kO1xuICAgICAgICB1ID0gLXU7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zZXQodSwgZCk7XG4gICAgfSxcblxuICAgIGFkZDogZnVuY3Rpb24ocGFyYW0xLCBwYXJhbTIpIHtcbiAgICAgIHZhciBvdGhlck51bWVyYXRvcjtcbiAgICAgIHZhciBvdGhlckRlbm9taW5hdG9yO1xuXG4gICAgICBpZiAocGFyYW0xIGluc3RhbmNlb2YgVmV4LkZsb3cuRnJhY3Rpb24pIHtcbiAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSBwYXJhbTEubnVtZXJhdG9yO1xuICAgICAgICBvdGhlckRlbm9taW5hdG9yID0gcGFyYW0xLmRlbm9taW5hdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmFtMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSBwYXJhbTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3RoZXJEZW5vbWluYXRvciA9IHBhcmFtMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlckRlbm9taW5hdG9yID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGNtID0gVmV4LkZsb3cuRnJhY3Rpb24uTENNKHRoaXMuZGVub21pbmF0b3IsIG90aGVyRGVub21pbmF0b3IpO1xuICAgICAgdmFyIGEgPSBsY20gLyB0aGlzLmRlbm9taW5hdG9yO1xuICAgICAgdmFyIGIgPSBsY20gLyBvdGhlckRlbm9taW5hdG9yO1xuXG4gICAgICB2YXIgdSA9IHRoaXMubnVtZXJhdG9yICogYSArIG90aGVyTnVtZXJhdG9yICogYjtcbiAgICAgIHJldHVybiB0aGlzLnNldCh1LCBsY20pO1xuICAgIH0sXG5cbiAgICBzdWJ0cmFjdDogZnVuY3Rpb24ocGFyYW0xLCBwYXJhbTIpIHtcbiAgICAgIHZhciBvdGhlck51bWVyYXRvcjtcbiAgICAgIHZhciBvdGhlckRlbm9taW5hdG9yO1xuXG4gICAgICBpZiAocGFyYW0xIGluc3RhbmNlb2YgVmV4LkZsb3cuRnJhY3Rpb24pIHtcbiAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSBwYXJhbTEubnVtZXJhdG9yO1xuICAgICAgICBvdGhlckRlbm9taW5hdG9yID0gcGFyYW0xLmRlbm9taW5hdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmFtMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSBwYXJhbTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSAwO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3RoZXJEZW5vbWluYXRvciA9IHBhcmFtMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlckRlbm9taW5hdG9yID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgbGNtID0gVmV4LkZsb3cuRnJhY3Rpb24uTENNKHRoaXMuZGVub21pbmF0b3IsIG90aGVyRGVub21pbmF0b3IpO1xuICAgICAgdmFyIGEgPSBsY20gLyB0aGlzLmRlbm9taW5hdG9yO1xuICAgICAgdmFyIGIgPSBsY20gLyBvdGhlckRlbm9taW5hdG9yO1xuXG4gICAgICB2YXIgdSA9IHRoaXMubnVtZXJhdG9yICogYSAtIG90aGVyTnVtZXJhdG9yICogYjtcbiAgICAgIHJldHVybiB0aGlzLnNldCh1LCBsY20pO1xuICAgIH0sXG5cbiAgICBtdWx0aXBseTogZnVuY3Rpb24ocGFyYW0xLCBwYXJhbTIpIHtcbiAgICAgIHZhciBvdGhlck51bWVyYXRvcjtcbiAgICAgIHZhciBvdGhlckRlbm9taW5hdG9yO1xuXG4gICAgICBpZiAocGFyYW0xIGluc3RhbmNlb2YgVmV4LkZsb3cuRnJhY3Rpb24pIHtcbiAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSBwYXJhbTEubnVtZXJhdG9yO1xuICAgICAgICBvdGhlckRlbm9taW5hdG9yID0gcGFyYW0xLmRlbm9taW5hdG9yO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHBhcmFtMSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSBwYXJhbTE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJOdW1lcmF0b3IgPSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBhcmFtMiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgb3RoZXJEZW5vbWluYXRvciA9IHBhcmFtMjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBvdGhlckRlbm9taW5hdG9yID0gMTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5zZXQodGhpcy5udW1lcmF0b3IgKiBvdGhlck51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvciAqIG90aGVyRGVub21pbmF0b3IpO1xuICAgIH0sXG5cbiAgICBkaXZpZGU6IGZ1bmN0aW9uKHBhcmFtMSwgcGFyYW0yKSB7XG4gICAgICB2YXIgb3RoZXJOdW1lcmF0b3I7XG4gICAgICB2YXIgb3RoZXJEZW5vbWluYXRvcjtcblxuICAgICAgaWYgKHBhcmFtMSBpbnN0YW5jZW9mIFZleC5GbG93LkZyYWN0aW9uKSB7XG4gICAgICAgIG90aGVyTnVtZXJhdG9yID0gcGFyYW0xLm51bWVyYXRvcjtcbiAgICAgICAgb3RoZXJEZW5vbWluYXRvciA9IHBhcmFtMS5kZW5vbWluYXRvcjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwYXJhbTEgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG90aGVyTnVtZXJhdG9yID0gcGFyYW0xO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG90aGVyTnVtZXJhdG9yID0gMTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChwYXJhbTIgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG90aGVyRGVub21pbmF0b3IgPSBwYXJhbTI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgb3RoZXJEZW5vbWluYXRvciA9IDE7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc2V0KHRoaXMubnVtZXJhdG9yICogb3RoZXJEZW5vbWluYXRvciwgdGhpcy5kZW5vbWluYXRvciAqIG90aGVyTnVtZXJhdG9yKTtcbiAgICB9LFxuXG5cbiAgICAvLyBTaW1wbGlmaWVzIGJvdGggc2lkZXMgYW5kIGNoZWNrcyBpZiB0aGV5IGFyZSBlcXVhbC5cbiAgICBlcXVhbHM6IGZ1bmN0aW9uKGNvbXBhcmUpIHtcbiAgICAgIHZhciBhID0gVmV4LkZsb3cuRnJhY3Rpb24uX19jb21wYXJlQS5jb3B5KGNvbXBhcmUpLnNpbXBsaWZ5KCk7XG4gICAgICB2YXIgYiA9IFZleC5GbG93LkZyYWN0aW9uLl9fY29tcGFyZUIuY29weSh0aGlzKS5zaW1wbGlmeSgpO1xuXG4gICAgICByZXR1cm4gKGEubnVtZXJhdG9yID09PSBiLm51bWVyYXRvcikgJiYgKGEuZGVub21pbmF0b3IgPT09IGIuZGVub21pbmF0b3IpO1xuICAgIH0sXG4gICAgXG4gICAgLy8gR3JlYXRlciB0aGFuIG9wZXJhdG9yLlxuICAgIGdyZWF0ZXJUaGFuOiBmdW5jdGlvbihjb21wYXJlKSB7XG4gICAgICB2YXIgYSA9IFZleC5GbG93LkZyYWN0aW9uLl9fY29tcGFyZUIuY29weSh0aGlzKTtcbiAgICAgIGEuc3VidHJhY3QoY29tcGFyZSk7XG4gICAgICByZXR1cm4gKGEubnVtZXJhdG9yID4gMCk7XG4gICAgfSxcbiAgICBcbiAgICAvLyBHcmVhdGVyIHRoYW4gb3IgZXF1YWxzIG9wZXJhdG9yLlxuICAgIGdyZWF0ZXJUaGFuRXF1YWxzOiBmdW5jdGlvbihjb21wYXJlKSB7XG4gICAgICB2YXIgYSA9IFZleC5GbG93LkZyYWN0aW9uLl9fY29tcGFyZUIuY29weSh0aGlzKTtcbiAgICAgIGEuc3VidHJhY3QoY29tcGFyZSk7XG4gICAgICByZXR1cm4gKGEubnVtZXJhdG9yID49IDApO1xuICAgIH0sXG5cbiAgICAvLyBMZXNzIHRoYW4gb3BlcmF0b3IuXG4gICAgbGVzc1RoYW46IGZ1bmN0aW9uKGNvbXBhcmUpIHtcbiAgICAgIHJldHVybiAhKHRoaXMuZ3JlYXRlclRoYW5FcXVhbHMoY29tcGFyZSkpOyAgXG4gICAgfSxcblxuICAgIC8vIExlc3MgdGhhbiBvciBlcXVhbHMgb3BlcmF0b3IuXG4gICAgbGVzc1RoYW5FcXVhbHM6IGZ1bmN0aW9uKGNvbXBhcmUpIHtcbiAgICAgIHJldHVybiAhKHRoaXMuZ3JlYXRlclRoYW4oY29tcGFyZSkpOyAgXG4gICAgfSxcblxuICAgIC8vIENyZWF0ZXMgYSBuZXcgY29weSB3aXRoIHRoaXMgY3VycmVudCB2YWx1ZXMuXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBWZXguRmxvdy5GcmFjdGlvbih0aGlzLm51bWVyYXRvciwgdGhpcy5kZW5vbWluYXRvcik7XG4gICAgfSxcblxuICAgIC8vIENvcGllcyB2YWx1ZSBvZiBhbm90aGVyIEZyYWN0aW9uIGludG8gaXRzZWxmLlxuICAgIGNvcHk6IGZ1bmN0aW9uKGNvcHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnNldChjb3B5Lm51bWVyYXRvciwgY29weS5kZW5vbWluYXRvcik7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIGludGVnZXIgY29tcG9uZW50IGVnLiAoNC8yKSA9PSAyXG4gICAgcXVvdGllbnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIE1hdGguZmxvb3IodGhpcy5udW1lcmF0b3IgLyB0aGlzLmRlbm9taW5hdG9yKTtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyB0aGUgZnJhY3Rpb24gY29tcG9uZW50IHdoZW4gcmVkdWNlZCB0byBhIG1peGVkIG51bWJlclxuICAgIGZyYWN0aW9uOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm51bWVyYXRvciAlIHRoaXMuZGVub21pbmF0b3I7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgdGhlIGFic29sdXRlIHZhbHVlXG4gICAgYWJzOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuZGVub21pbmF0b3IgPSBNYXRoLmFicyh0aGlzLmRlbm9taW5hdG9yKTtcbiAgICAgIHRoaXMubnVtZXJhdG9yID0gTWF0aC5hYnModGhpcy5udW1lcmF0b3IpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgYSByYXcgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gICAgdG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubnVtZXJhdG9yICsgJy8nICsgdGhpcy5kZW5vbWluYXRvcjtcbiAgICB9LFxuXG4gICAgLy8gUmV0dXJucyBhIHNpbXBsaWZpZWQgc3RyaW5nIHJlc3ByZXNlbnRhdGlvblxuICAgIHRvU2ltcGxpZmllZFN0cmluZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gVmV4LkZsb3cuRnJhY3Rpb24uX190bXAuY29weSh0aGlzKS5zaW1wbGlmeSgpLnRvU3RyaW5nKCk7XG4gICAgfSxcblxuICAgIC8vIFJldHVybnMgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGluIG1peGVkIGZvcm1cbiAgICB0b01peGVkU3RyaW5nOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzID0gJyc7XG4gICAgICB2YXIgcSA9IHRoaXMucXVvdGllbnQoKTtcbiAgICAgIHZhciBmID0gVmV4LkZsb3cuRnJhY3Rpb24uX190bXAuY29weSh0aGlzKTtcblxuICAgICAgaWYgKHEgPCAwKSB7XG4gICAgICAgIGYuYWJzKCkuZnJhY3Rpb24oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGYuZnJhY3Rpb24oKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHEgIT09IDApIHtcbiAgICAgICAgcyArPSBxO1xuXG4gICAgICAgIGlmIChmLm51bWVyYXRvciAhPT0gMCkge1xuICAgICAgICAgIHMgKz0gJyAnICsgZi50b1NpbXBsaWZpZWRTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKGYubnVtZXJhdG9yID09PSAwKSB7XG4gICAgICAgICAgcyA9ICcwJztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzID0gZi50b1NpbXBsaWZpZWRTdHJpbmcoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gcztcbiAgICB9LFxuXG4gICAgLy8gUGFyc2VzIGEgZnJhY3Rpb24gc3RyaW5nXG4gICAgcGFyc2U6IGZ1bmN0aW9uKHN0cikge1xuICAgICAgdmFyIGkgPSBzdHIuc3BsaXQoJy8nKTtcbiAgICAgIHZhciBuID0gcGFyc2VJbnQoaVswXSwgMTApO1xuICAgICAgdmFyIGQgPSAoaVsxXSkgPyBwYXJzZUludChpWzFdLCAxMCkgOiAxO1xuXG4gICAgICByZXR1cm4gdGhpcy5zZXQobiwgZCk7XG4gICAgfVxuICB9O1xuXG4gIC8vIFRlbXBvcmFyeSBjYWNoZWQgb2JqZWN0c1xuICBGcmFjdGlvbi5fX2NvbXBhcmVBID0gbmV3IEZyYWN0aW9uKCk7XG4gIEZyYWN0aW9uLl9fY29tcGFyZUIgPSBuZXcgRnJhY3Rpb24oKTtcbiAgRnJhY3Rpb24uX190bXAgPSBuZXcgRnJhY3Rpb24oKTtcblxuICByZXR1cm4gRnJhY3Rpb247XG59KCkpO1xuXG5cbi8vIFZleCBGbG93IE5vdGF0aW9uXG4vLyBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy9cbi8vIENvcHlyaWdodCBNb2hpdCBNdXRoYW5uYSAyMDEwXG4vL1xuLy8gUmVxdWlyZXMgdmV4LmpzLlxuXG5WZXguRmxvdy5TVEVNX1dJRFRIID0gMS41O1xuVmV4LkZsb3cuU1RFTV9IRUlHSFQgPSAzMjtcblZleC5GbG93LlNUQVZFX0xJTkVfVEhJQ0tORVNTID0gMjtcblxuVmV4LkZsb3cuY2xlZlByb3BlcnRpZXMgPSBmdW5jdGlvbihjbGVmKSB7XG4gIGlmICghY2xlZikgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRcIiwgXCJJbnZhbGlkIGNsZWY6IFwiICsgY2xlZik7XG5cbiAgdmFyIHByb3BzID0gVmV4LkZsb3cuY2xlZlByb3BlcnRpZXMudmFsdWVzW2NsZWZdO1xuICBpZiAoIXByb3BzKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudFwiLCBcIkludmFsaWQgY2xlZjogXCIgKyBjbGVmKTtcblxuICByZXR1cm4gcHJvcHM7XG59O1xuXG5WZXguRmxvdy5jbGVmUHJvcGVydGllcy52YWx1ZXMgPSB7XG4gICd0cmVibGUnOiAgeyBsaW5lX3NoaWZ0OiAwIH0sXG4gICdiYXNzJzogICAgeyBsaW5lX3NoaWZ0OiA2IH0sXG4gICd0ZW5vcic6ICAgeyBsaW5lX3NoaWZ0OiA0IH0sXG4gICdhbHRvJzogICAgeyBsaW5lX3NoaWZ0OiAzIH0sXG4gICdzb3ByYW5vJzogeyBsaW5lX3NoaWZ0OiAxIH0sXG4gICdwZXJjdXNzaW9uJzogeyBsaW5lX3NoaWZ0OiAwIH0sXG4gICdtZXp6by1zb3ByYW5vJzogeyBsaW5lX3NoaWZ0OiAyIH0sXG4gICdiYXJpdG9uZS1jJzogeyBsaW5lX3NoaWZ0OiA1IH0sXG4gICdiYXJpdG9uZS1mJzogeyBsaW5lX3NoaWZ0OiA1IH0sXG4gICdzdWJiYXNzJzogeyBsaW5lX3NoaWZ0OiA3IH0sXG4gICdmcmVuY2gnOiB7IGxpbmVfc2hpZnQ6IC0xIH1cbn07XG5cbi8qXG4gIFRha2UgYSBub3RlIGluIHRoZSBmb3JtYXQgXCJLZXkvT2N0YXZlXCIgKGUuZy4sIFwiQy81XCIpIGFuZCByZXR1cm4gcHJvcGVydGllcy5cblxuICBUaGUgbGFzdCBhcmd1bWVudCwgcGFyYW1zLCBpcyBhIHN0cnVjdCB0aGUgY3VycmVudGx5IGNhbiBjb250YWluIG9uZSBvcHRpb24sXG4gIG9jdGF2ZV9zaGlmdCBmb3IgY2xlZiBvdHRhdmF0aW9uICgwID0gZGVmYXVsdDsgMSA9IDh2YTsgLTEgPSA4dmIsIGV0Yy4pLlxuKi9cblZleC5GbG93LmtleVByb3BlcnRpZXMgPSBmdW5jdGlvbihrZXksIGNsZWYsIHBhcmFtcykge1xuICBpZiAoY2xlZiA9PT0gdW5kZWZpbmVkKSB7XG4gICAgY2xlZiA9ICd0cmVibGUnO1xuICB9XG4gIHZhciBvcHRpb25zID0ge1xuICAgIG9jdGF2ZV9zaGlmdDogMFxuICB9O1xuICBpZiAodHlwZW9mIHBhcmFtcyA9PSBcIm9iamVjdFwiKSB7XG4gICAgVmV4Lk1lcmdlKG9wdGlvbnMsIHBhcmFtcyk7XG4gIH1cblxuICB2YXIgcGllY2VzID0ga2V5LnNwbGl0KFwiL1wiKTtcblxuICBpZiAocGllY2VzLmxlbmd0aCA8IDIpIHtcbiAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgXCJLZXkgbXVzdCBoYXZlIG5vdGUgKyBvY3RhdmUgYW5kIGFuIG9wdGlvbmFsIGdseXBoOiBcIiArIGtleSk7XG4gIH1cblxuICB2YXIgayA9IHBpZWNlc1swXS50b1VwcGVyQ2FzZSgpO1xuICB2YXIgdmFsdWUgPSBWZXguRmxvdy5rZXlQcm9wZXJ0aWVzLm5vdGVfdmFsdWVzW2tdO1xuICBpZiAoIXZhbHVlKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJJbnZhbGlkIGtleSBuYW1lOiBcIiArIGspO1xuICBpZiAodmFsdWUub2N0YXZlKSBwaWVjZXNbMV0gPSB2YWx1ZS5vY3RhdmU7XG5cbiAgdmFyIG8gPSBwYXJzZUludChwaWVjZXNbMV0pO1xuXG4gIC8vIE9jdGF2ZV9zaGlmdCBpcyB0aGUgc2hpZnQgdG8gY29tcGVuc2F0ZSBmb3IgY2xlZiA4dmEvOHZiLlxuICBvICs9IC0xICogb3B0aW9ucy5vY3RhdmVfc2hpZnQ7XG5cbiAgdmFyIGJhc2VfaW5kZXggPSAobyAqIDcpIC0gKDQgKiA3KTtcbiAgdmFyIGxpbmUgPSAoYmFzZV9pbmRleCArIHZhbHVlLmluZGV4KSAvIDI7XG4gIGxpbmUgKz0gVmV4LkZsb3cuY2xlZlByb3BlcnRpZXMoY2xlZikubGluZV9zaGlmdDtcblxuICB2YXIgc3Ryb2tlID0gMDtcblxuICBpZiAobGluZSA8PSAwICYmICgoKGxpbmUgKiAyKSAlIDIpID09PSAwKSkgc3Ryb2tlID0gMTsgIC8vIHN0cm9rZSB1cFxuICBpZiAobGluZSA+PSA2ICYmICgoKGxpbmUgKiAyKSAlIDIpID09PSAwKSkgc3Ryb2tlID0gLTE7IC8vIHN0cm9rZSBkb3duXG5cbiAgLy8gSW50ZWdlciB2YWx1ZSBmb3Igbm90ZSBhcml0aG1ldGljLlxuICB2YXIgaW50X3ZhbHVlID0gKHR5cGVvZih2YWx1ZS5pbnRfdmFsKSE9J3VuZGVmaW5lZCcpID8gKG8gKiAxMikgK1xuICAgIHZhbHVlLmludF92YWwgOiBudWxsO1xuXG4gIC8qIENoZWNrIGlmIHRoZSB1c2VyIHNwZWNpZmllZCBhIGdseXBoLiAqL1xuICB2YXIgY29kZSA9IHZhbHVlLmNvZGU7XG4gIHZhciBzaGlmdF9yaWdodCA9IHZhbHVlLnNoaWZ0X3JpZ2h0O1xuICBpZiAoKHBpZWNlcy5sZW5ndGggPiAyKSAmJiAocGllY2VzWzJdKSkge1xuICAgIHZhciBnbHlwaF9uYW1lID0gcGllY2VzWzJdLnRvVXBwZXJDYXNlKCk7XG4gICAgdmFyIG5vdGVfZ2x5cGggPSBWZXguRmxvdy5rZXlQcm9wZXJ0aWVzLm5vdGVfZ2x5cGhbZ2x5cGhfbmFtZV07XG4gICAgaWYgKG5vdGVfZ2x5cGgpIHtcbiAgICAgIGNvZGUgPSBub3RlX2dseXBoLmNvZGU7XG4gICAgICBzaGlmdF9yaWdodCA9IG5vdGVfZ2x5cGguc2hpZnRfcmlnaHQ7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBrZXk6IGssXG4gICAgb2N0YXZlOiBvLFxuICAgIGxpbmU6IGxpbmUsXG4gICAgaW50X3ZhbHVlOiBpbnRfdmFsdWUsXG4gICAgYWNjaWRlbnRhbDogdmFsdWUuYWNjaWRlbnRhbCxcbiAgICBjb2RlOiBjb2RlLFxuICAgIHN0cm9rZTogc3Ryb2tlLFxuICAgIHNoaWZ0X3JpZ2h0OiBzaGlmdF9yaWdodCxcbiAgICBkaXNwbGFjZWQ6IGZhbHNlXG4gIH07XG59O1xuXG5WZXguRmxvdy5rZXlQcm9wZXJ0aWVzLm5vdGVfdmFsdWVzID0ge1xuICAnQyc6ICB7IGluZGV4OiAwLCBpbnRfdmFsOiAwLCBhY2NpZGVudGFsOiBudWxsIH0sXG4gICdDTic6IHsgaW5kZXg6IDAsIGludF92YWw6IDAsIGFjY2lkZW50YWw6IFwiblwiIH0sXG4gICdDIyc6IHsgaW5kZXg6IDAsIGludF92YWw6IDEsIGFjY2lkZW50YWw6IFwiI1wiIH0sXG4gICdDIyMnOiB7IGluZGV4OiAwLCBpbnRfdmFsOiAyLCBhY2NpZGVudGFsOiBcIiMjXCIgfSxcbiAgJ0NCJzogeyBpbmRleDogMCwgaW50X3ZhbDogLTEsIGFjY2lkZW50YWw6IFwiYlwiIH0sXG4gICdDQkInOiB7IGluZGV4OiAwLCBpbnRfdmFsOiAtMiwgYWNjaWRlbnRhbDogXCJiYlwiIH0sXG4gICdEJzogIHsgaW5kZXg6IDEsIGludF92YWw6IDIsIGFjY2lkZW50YWw6IG51bGwgfSxcbiAgJ0ROJzogeyBpbmRleDogMSwgaW50X3ZhbDogMiwgYWNjaWRlbnRhbDogXCJuXCIgfSxcbiAgJ0QjJzogeyBpbmRleDogMSwgaW50X3ZhbDogMywgYWNjaWRlbnRhbDogXCIjXCIgfSxcbiAgJ0QjIyc6IHsgaW5kZXg6IDEsIGludF92YWw6IDQsIGFjY2lkZW50YWw6IFwiIyNcIiB9LFxuICAnREInOiB7IGluZGV4OiAxLCBpbnRfdmFsOiAxLCBhY2NpZGVudGFsOiBcImJcIiB9LFxuICAnREJCJzogeyBpbmRleDogMSwgaW50X3ZhbDogMCwgYWNjaWRlbnRhbDogXCJiYlwiIH0sXG4gICdFJzogIHsgaW5kZXg6IDIsIGludF92YWw6IDQsIGFjY2lkZW50YWw6IG51bGwgfSxcbiAgJ0VOJzogeyBpbmRleDogMiwgaW50X3ZhbDogNCwgYWNjaWRlbnRhbDogXCJuXCIgfSxcbiAgJ0UjJzogeyBpbmRleDogMiwgaW50X3ZhbDogNSwgYWNjaWRlbnRhbDogXCIjXCIgfSxcbiAgJ0UjIyc6IHsgaW5kZXg6IDIsIGludF92YWw6IDYsIGFjY2lkZW50YWw6IFwiIyNcIiB9LFxuICAnRUInOiB7IGluZGV4OiAyLCBpbnRfdmFsOiAzLCBhY2NpZGVudGFsOiBcImJcIiB9LFxuICAnRUJCJzogeyBpbmRleDogMiwgaW50X3ZhbDogMiwgYWNjaWRlbnRhbDogXCJiYlwiIH0sXG4gICdGJzogIHsgaW5kZXg6IDMsIGludF92YWw6IDUsIGFjY2lkZW50YWw6IG51bGwgfSxcbiAgJ0ZOJzogeyBpbmRleDogMywgaW50X3ZhbDogNSwgYWNjaWRlbnRhbDogXCJuXCIgfSxcbiAgJ0YjJzogeyBpbmRleDogMywgaW50X3ZhbDogNiwgYWNjaWRlbnRhbDogXCIjXCIgfSxcbiAgJ0YjIyc6IHsgaW5kZXg6IDMsIGludF92YWw6IDcsIGFjY2lkZW50YWw6IFwiIyNcIiB9LFxuICAnRkInOiB7IGluZGV4OiAzLCBpbnRfdmFsOiA0LCBhY2NpZGVudGFsOiBcImJcIiB9LFxuICAnRkJCJzogeyBpbmRleDogMywgaW50X3ZhbDogMywgYWNjaWRlbnRhbDogXCJiYlwiIH0sXG4gICdHJzogIHsgaW5kZXg6IDQsIGludF92YWw6IDcsIGFjY2lkZW50YWw6IG51bGwgfSxcbiAgJ0dOJzogeyBpbmRleDogNCwgaW50X3ZhbDogNywgYWNjaWRlbnRhbDogXCJuXCIgfSxcbiAgJ0cjJzogeyBpbmRleDogNCwgaW50X3ZhbDogOCwgYWNjaWRlbnRhbDogXCIjXCIgfSxcbiAgJ0cjIyc6IHsgaW5kZXg6IDQsIGludF92YWw6IDksIGFjY2lkZW50YWw6IFwiIyNcIiB9LFxuICAnR0InOiB7IGluZGV4OiA0LCBpbnRfdmFsOiA2LCBhY2NpZGVudGFsOiBcImJcIiB9LFxuICAnR0JCJzogeyBpbmRleDogNCwgaW50X3ZhbDogNSwgYWNjaWRlbnRhbDogXCJiYlwiIH0sXG4gICdBJzogIHsgaW5kZXg6IDUsIGludF92YWw6IDksIGFjY2lkZW50YWw6IG51bGwgfSxcbiAgJ0FOJzogeyBpbmRleDogNSwgaW50X3ZhbDogOSwgYWNjaWRlbnRhbDogXCJuXCIgfSxcbiAgJ0EjJzogeyBpbmRleDogNSwgaW50X3ZhbDogMTAsIGFjY2lkZW50YWw6IFwiI1wiIH0sXG4gICdBIyMnOiB7IGluZGV4OiA1LCBpbnRfdmFsOiAxMSwgYWNjaWRlbnRhbDogXCIjI1wiIH0sXG4gICdBQic6IHsgaW5kZXg6IDUsIGludF92YWw6IDgsIGFjY2lkZW50YWw6IFwiYlwiIH0sXG4gICdBQkInOiB7IGluZGV4OiA1LCBpbnRfdmFsOiA3LCBhY2NpZGVudGFsOiBcImJiXCIgfSxcbiAgJ0InOiAgeyBpbmRleDogNiwgaW50X3ZhbDogMTEsIGFjY2lkZW50YWw6IG51bGwgfSxcbiAgJ0JOJzogeyBpbmRleDogNiwgaW50X3ZhbDogMTEsIGFjY2lkZW50YWw6IFwiblwiIH0sXG4gICdCIyc6IHsgaW5kZXg6IDYsIGludF92YWw6IDEyLCBhY2NpZGVudGFsOiBcIiNcIiB9LFxuICAnQiMjJzogeyBpbmRleDogNiwgaW50X3ZhbDogMTMsIGFjY2lkZW50YWw6IFwiIyNcIiB9LFxuICAnQkInOiB7IGluZGV4OiA2LCBpbnRfdmFsOiAxMCwgYWNjaWRlbnRhbDogXCJiXCIgfSxcbiAgJ0JCQic6IHsgaW5kZXg6IDYsIGludF92YWw6IDksIGFjY2lkZW50YWw6IFwiYmJcIiB9LFxuICAnUic6IHsgaW5kZXg6IDYsIGludF92YWw6IDksIHJlc3Q6IHRydWUgfSwgLy8gUmVzdFxuICAnWCc6ICB7XG4gICAgaW5kZXg6IDYsXG4gICAgYWNjaWRlbnRhbDogXCJcIixcbiAgICBvY3RhdmU6IDQsXG4gICAgY29kZTogXCJ2M2VcIixcbiAgICBzaGlmdF9yaWdodDogNS41XG4gIH1cbn07XG5cblZleC5GbG93LmtleVByb3BlcnRpZXMubm90ZV9nbHlwaCA9IHtcbiAgLyogRGlhbW9uZCAqL1xuICAnRDAnOiAgeyBjb2RlOiBcInYyN1wiLCBzaGlmdF9yaWdodDogLTAuNSB9LFxuICAnRDEnOiAgeyBjb2RlOiBcInYyZFwiLCBzaGlmdF9yaWdodDogLTAuNSB9LFxuICAnRDInOiAgeyBjb2RlOiBcInYyMlwiLCBzaGlmdF9yaWdodDogLTAuNSB9LFxuICAnRDMnOiAgeyBjb2RlOiBcInY3MFwiLCBzaGlmdF9yaWdodDogLTAuNSB9LFxuXG4gIC8qIFRyaWFuZ2xlICovXG4gICdUMCc6ICB7IGNvZGU6IFwidjQ5XCIsIHNoaWZ0X3JpZ2h0OiAtMiB9LFxuICAnVDEnOiAgeyBjb2RlOiBcInY5M1wiLCBzaGlmdF9yaWdodDogMC41IH0sXG4gICdUMic6ICB7IGNvZGU6IFwidjQwXCIsIHNoaWZ0X3JpZ2h0OiAwLjUgfSxcbiAgJ1QzJzogIHsgY29kZTogXCJ2N2RcIiwgc2hpZnRfcmlnaHQ6IDAuNSB9LFxuXG4gIC8qIENyb3NzICovXG4gICdYMCc6ICB7IGNvZGU6IFwidjkyXCIsIHNoaWZ0X3JpZ2h0OiAtMiB9LFxuICAnWDEnOiAgeyBjb2RlOiBcInY5NVwiLCBzaGlmdF9yaWdodDogLTAuNSB9LFxuICAnWDInOiAgeyBjb2RlOiBcInY3ZlwiLCBzaGlmdF9yaWdodDogMC41IH0sXG4gICdYMyc6ICB7IGNvZGU6IFwidjNiXCIsIHNoaWZ0X3JpZ2h0OiAtMiB9XG59O1xuXG5WZXguRmxvdy5pbnRlZ2VyVG9Ob3RlID0gZnVuY3Rpb24oaW50ZWdlcikge1xuICBpZiAodHlwZW9mKGludGVnZXIpID09IFwidW5kZWZpbmVkXCIpXG4gICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsIFwiVW5kZWZpbmVkIGludGVnZXIgZm9yIGludGVnZXJUb05vdGVcIik7XG5cbiAgaWYgKGludGVnZXIgPCAtMilcbiAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgXCJpbnRlZ2VyVG9Ob3RlIHJlcXVpcmVzIGludGVnZXIgPiAtMjogXCIgKyBpbnRlZ2VyKTtcblxuICB2YXIgbm90ZVZhbHVlID0gVmV4LkZsb3cuaW50ZWdlclRvTm90ZS50YWJsZVtpbnRlZ2VyXTtcbiAgaWYgKCFub3RlVmFsdWUpXG4gICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsIFwiVW5rbm93biBub3RlIHZhbHVlIGZvciBpbnRlZ2VyOiBcIiArXG4gICAgICAgIGludGVnZXIpO1xuXG4gIHJldHVybiBub3RlVmFsdWU7XG59O1xuXG5WZXguRmxvdy5pbnRlZ2VyVG9Ob3RlLnRhYmxlID0ge1xuICAwOiBcIkNcIixcbiAgMTogXCJDI1wiLFxuICAyOiBcIkRcIixcbiAgMzogXCJEI1wiLFxuICA0OiBcIkVcIixcbiAgNTogXCJGXCIsXG4gIDY6IFwiRiNcIixcbiAgNzogXCJHXCIsXG4gIDg6IFwiRyNcIixcbiAgOTogXCJBXCIsXG4gIDEwOiBcIkEjXCIsXG4gIDExOiBcIkJcIlxufTtcblxuXG5WZXguRmxvdy50YWJUb0dseXBoID0gZnVuY3Rpb24oZnJldCkge1xuICB2YXIgZ2x5cGggPSBudWxsO1xuICB2YXIgd2lkdGggPSAwO1xuICB2YXIgc2hpZnRfeSA9IDA7XG5cbiAgaWYgKGZyZXQudG9TdHJpbmcoKS50b1VwcGVyQ2FzZSgpID09IFwiWFwiKSB7XG4gICAgZ2x5cGggPSBcInY3ZlwiO1xuICAgIHdpZHRoID0gNztcbiAgICBzaGlmdF95ID0gLTQuNTtcbiAgfSBlbHNlIHtcbiAgICB3aWR0aCA9IFZleC5GbG93LnRleHRXaWR0aChmcmV0LnRvU3RyaW5nKCkpO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICB0ZXh0OiBmcmV0LFxuICAgIGNvZGU6IGdseXBoLFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBzaGlmdF95OiBzaGlmdF95XG4gIH07XG59O1xuXG5WZXguRmxvdy50ZXh0V2lkdGggPSBmdW5jdGlvbih0ZXh0KSB7XG4gIHJldHVybiA2ICogdGV4dC50b1N0cmluZygpLmxlbmd0aDtcbn07XG5cblZleC5GbG93LmFydGljdWxhdGlvbkNvZGVzID0gZnVuY3Rpb24oYXJ0aWMpIHtcbiAgcmV0dXJuIFZleC5GbG93LmFydGljdWxhdGlvbkNvZGVzLmFydGljdWxhdGlvbnNbYXJ0aWNdO1xufTtcblxuVmV4LkZsb3cuYXJ0aWN1bGF0aW9uQ29kZXMuYXJ0aWN1bGF0aW9ucyA9IHtcbiAgXCJhLlwiOiB7ICAgLy8gU3RhY2NhdG9cbiAgICBjb2RlOiBcInYyM1wiLFxuICAgIHdpZHRoOiA0LFxuICAgIHNoaWZ0X3JpZ2h0OiAtMixcbiAgICBzaGlmdF91cDogOCxcbiAgICBzaGlmdF9kb3duOiAwLFxuICAgIGJldHdlZW5fbGluZXM6IHRydWVcbiAgfSxcbiAgXCJhdlwiOiB7ICAgLy8gU3RhY2NhdGlzc2ltb1xuICAgIGNvZGU6IFwidjI4XCIsXG4gICAgd2lkdGg6IDQsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfdXA6IDExLFxuICAgIHNoaWZ0X2Rvd246IDUsXG4gICAgYmV0d2Vlbl9saW5lczogdHJ1ZVxuICB9LFxuICBcImE+XCI6IHsgICAvLyBBY2NlbnRcbiAgICBjb2RlOiBcInY0MlwiLFxuICAgIHdpZHRoOiAxMCxcbiAgICBzaGlmdF9yaWdodDogNSxcbiAgICBzaGlmdF91cDogOCxcbiAgICBzaGlmdF9kb3duOiAxLFxuICAgIGJldHdlZW5fbGluZXM6IHRydWVcbiAgfSxcbiAgXCJhLVwiOiB7ICAgLy8gVGVudXRvXG4gICAgY29kZTogXCJ2MjVcIixcbiAgICB3aWR0aDogOSxcbiAgICBzaGlmdF9yaWdodDogLTQsXG4gICAgc2hpZnRfdXA6IDE3LFxuICAgIHNoaWZ0X2Rvd246IDEwLFxuICAgIGJldHdlZW5fbGluZXM6IHRydWVcbiAgfSxcbiAgXCJhXlwiOiB7ICAgLy8gTWFyY2F0b1xuICAgIGNvZGU6IFwidmFcIixcbiAgICB3aWR0aDogOCxcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF91cDogLTQsXG4gICAgc2hpZnRfZG93bjogLTIsXG4gICAgYmV0d2Vlbl9saW5lczogZmFsc2VcbiAgfSxcbiAgXCJhK1wiOiB7ICAgLy8gTGVmdCBoYW5kIHBpenppY2F0b1xuICAgIGNvZGU6IFwidjhiXCIsXG4gICAgd2lkdGg6IDksXG4gICAgc2hpZnRfcmlnaHQ6IC00LFxuICAgIHNoaWZ0X3VwOiAxMixcbiAgICBzaGlmdF9kb3duOiAxMixcbiAgICBiZXR3ZWVuX2xpbmVzOiBmYWxzZVxuICB9LFxuICBcImFvXCI6IHsgICAvLyBTbmFwIHBpenppY2F0b1xuICAgIGNvZGU6IFwidjk0XCIsXG4gICAgd2lkdGg6IDgsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfdXA6IC00LFxuICAgIHNoaWZ0X2Rvd246IDYsXG4gICAgYmV0d2Vlbl9saW5lczogZmFsc2VcbiAgfSxcbiAgXCJhaFwiOiB7ICAgLy8gTmF0dXJhbCBoYXJtb25pYyBvciBvcGVuIG5vdGVcbiAgICBjb2RlOiBcInZiOVwiLFxuICAgIHdpZHRoOiA3LFxuICAgIHNoaWZ0X3JpZ2h0OiAwLFxuICAgIHNoaWZ0X3VwOiAtNCxcbiAgICBzaGlmdF9kb3duOiA0LFxuICAgIGJldHdlZW5fbGluZXM6IGZhbHNlXG4gIH0sXG4gIFwiYUBhXCI6IHsgICAvLyBGZXJtYXRhIGFib3ZlIHN0YWZmXG4gICAgY29kZTogXCJ2NDNcIixcbiAgICB3aWR0aDogMjUsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfdXA6IDgsXG4gICAgc2hpZnRfZG93bjogMTAsXG4gICAgYmV0d2Vlbl9saW5lczogZmFsc2VcbiAgfSxcbiAgXCJhQHVcIjogeyAgIC8vIEZlcm1hdGEgYmVsb3cgc3RhZmZcbiAgICBjb2RlOiBcInY1YlwiLFxuICAgIHdpZHRoOiAyNSxcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF91cDogMCxcbiAgICBzaGlmdF9kb3duOiAtNCxcbiAgICBiZXR3ZWVuX2xpbmVzOiBmYWxzZVxuICB9LFxuICBcImF8XCI6IHsgICAvLyBCb3cgdXAgLSB1cCBzdHJva2VcbiAgICBjb2RlOiBcInY3NVwiLFxuICAgIHdpZHRoOiA4LFxuICAgIHNoaWZ0X3JpZ2h0OiAwLFxuICAgIHNoaWZ0X3VwOiA4LFxuICAgIHNoaWZ0X2Rvd246IDEwLFxuICAgIGJldHdlZW5fbGluZXM6IGZhbHNlXG4gIH0sXG4gIFwiYW1cIjogeyAgIC8vIEJvdyBkb3duIC0gZG93biBzdHJva2VcbiAgICBjb2RlOiBcInY5N1wiLFxuICAgIHdpZHRoOiAxMyxcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF91cDogMTAsXG4gICAgc2hpZnRfZG93bjogMTIsXG4gICAgYmV0d2Vlbl9saW5lczogZmFsc2VcbiAgfSxcbiAgXCJhLFwiOiB7ICAgLy8gQ2hva2VkXG4gICAgY29kZTogXCJ2YjNcIixcbiAgICB3aWR0aDogNixcbiAgICBzaGlmdF9yaWdodDogOCxcbiAgICBzaGlmdF91cDogLTQsXG4gICAgc2hpZnRfZG93bjogNCxcbiAgICBiZXR3ZWVuX2xpbmVzOiBmYWxzZVxuICB9XG59O1xuXG5WZXguRmxvdy5hY2NpZGVudGFsQ29kZXMgPSBmdW5jdGlvbihhY2MpIHtcbiAgcmV0dXJuIFZleC5GbG93LmFjY2lkZW50YWxDb2Rlcy5hY2NpZGVudGFsc1thY2NdO1xufTtcblxuVmV4LkZsb3cuYWNjaWRlbnRhbENvZGVzLmFjY2lkZW50YWxzID0ge1xuICBcIiNcIjoge1xuICAgIGNvZGU6IFwidjE4XCIsXG4gICAgd2lkdGg6IDEwLFxuICAgIGdyYWNlbm90ZV93aWR0aDogNC41LFxuICAgIHNoaWZ0X3JpZ2h0OiAwLFxuICAgIHNoaWZ0X2Rvd246IDBcbiAgfSxcbiAgXCIjI1wiOiB7XG4gICAgY29kZTogXCJ2N2ZcIixcbiAgICB3aWR0aDogMTMsXG4gICAgZ3JhY2Vub3RlX3dpZHRoOiA2LFxuICAgIHNoaWZ0X3JpZ2h0OiAtMSxcbiAgICBzaGlmdF9kb3duOiAwXG4gIH0sXG4gIFwiYlwiOiB7XG4gICAgY29kZTogXCJ2NDRcIixcbiAgICB3aWR0aDogOCxcbiAgICBncmFjZW5vdGVfd2lkdGg6IDQuNSxcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF9kb3duOiAwXG4gIH0sXG4gIFwiYmJcIjoge1xuICAgIGNvZGU6IFwidjI2XCIsXG4gICAgd2lkdGg6IDE0LFxuICAgIGdyYWNlbm90ZV93aWR0aDogOCxcbiAgICBzaGlmdF9yaWdodDogLTMsXG4gICAgc2hpZnRfZG93bjogMFxuICB9LFxuICBcIm5cIjoge1xuICAgIGNvZGU6IFwidjRlXCIsXG4gICAgd2lkdGg6IDgsXG4gICAgZ3JhY2Vub3RlX3dpZHRoOiA0LjUsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfZG93bjogMFxuICB9LFxuICBcIntcIjogeyAgIC8vIExlZnQgcGFyZW4gZm9yIGNhdXRpb25hcnkgYWNjaWRlbnRhbHNcbiAgICBjb2RlOiBcInY5Y1wiLFxuICAgIHdpZHRoOiA1LFxuICAgIHNoaWZ0X3JpZ2h0OiAyLFxuICAgIHNoaWZ0X2Rvd246IDBcbiAgfSxcbiAgXCJ9XCI6IHsgICAvLyBSaWdodCBwYXJlbiBmb3IgY2F1dGlvbmFyeSBhY2NpZGVudGFsc1xuICAgIGNvZGU6IFwidjg0XCIsXG4gICAgd2lkdGg6IDUsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfZG93bjogMFxuICB9LFxuICBcImRiXCI6IHtcbiAgICBjb2RlOiBcInY5ZVwiLFxuICAgIHdpZHRoOiAxNixcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF9kb3duOiAwXG4gIH0sXG4gIFwiZFwiOiB7XG4gICAgY29kZTogXCJ2YWJcIixcbiAgICB3aWR0aDogMTAsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfZG93bjogMFxuICB9LFxuICBcImJic1wiOiB7XG4gICAgY29kZTogXCJ2OTBcIixcbiAgICB3aWR0aDogMTMsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfZG93bjogMFxuICB9LFxuICBcIisrXCI6IHtcbiAgICBjb2RlOiBcInY1MVwiLFxuICAgIHdpZHRoOiAxMyxcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF9kb3duOiAwXG4gIH0sXG4gIFwiK1wiOiB7XG4gICAgY29kZTogXCJ2NzhcIixcbiAgICB3aWR0aDogOCxcbiAgICBzaGlmdF9yaWdodDogMCxcbiAgICBzaGlmdF9kb3duOiAwXG4gIH1cbn07XG5cblZleC5GbG93LmFjY2lkZW50YWxDb2x1bW5zVGFibGUgPSB7XG4gIDEgOiB7IGEgOiBbMV0sIGIgOiBbMV19LFxuICAyIDogeyBhIDogWzEsIDJdIH0sXG4gIDMgOiB7IGEgOiBbMSwgMywgMl0sIGIgOiBbMSwgMiwgMV0sIHNlY29uZF9vbl9ib3R0b20gOiBbMSwgMiwgM10gfSxcbiAgNCA6IHsgYSA6IFsxLCAzLCA0LCAyXSwgYiA6IFsxLCAyLCAzLCAxXSwgc3BhY2VkX291dF90ZXRyYWNob3JkIDogWzEsIDIsIDEsIDJdIH0sXG4gIDUgOiB7IGEgOiBbMSwgMywgNSwgNCwgMl0sIGIgOiBbMSwgMiwgNCwgMywgMV0sXG4gICAgICAgIHNwYWNlZF9vdXRfcGVudGFjaG9yZCA6IFsxLCAyLCAzLCAyLCAxXSxcbiAgICAgICAgdmVyeV9zcGFjZWRfb3V0X3BlbnRhY2hvcmQgOiBbMSwgMiwgMSwgMiwgMV0gfSxcbiAgNiA6IHsgYSA6IFsxLCAzLCA1LCA2LCA0LCAyXSwgYiA6IFsxLCAyLCA0LCA1LCAzLCAxXSxcbiAgICAgICAgc3BhY2VkX291dF9oZXhhY2hvcmQgOiBbMSwgMywgMiwgMSwgMywgMl0sXG4gICAgICAgIHZlcnlfc3BhY2VkX291dF9oZXhhY2hvcmQgOiBbMSwgMiwgMSwgMiwgMSwgMl0gfVxufTtcblxuVmV4LkZsb3cub3JuYW1lbnRDb2RlcyA9IGZ1bmN0aW9uKGFjYykge1xuICByZXR1cm4gVmV4LkZsb3cub3JuYW1lbnRDb2Rlcy5vcm5hbWVudHNbYWNjXTtcbn07XG5cblZleC5GbG93Lm9ybmFtZW50Q29kZXMub3JuYW1lbnRzID0ge1xuICBcIm1vcmRlbnRcIjoge1xuICAgIGNvZGU6IFwidjFlXCIsXG4gICAgc2hpZnRfcmlnaHQ6IDEsXG4gICAgc2hpZnRfdXA6IDAsXG4gICAgc2hpZnRfZG93bjogNSxcbiAgICB3aWR0aDogMTQsXG4gIH0sXG4gIFwibW9yZGVudF9pbnZlcnRlZFwiOiB7XG4gICAgY29kZTogXCJ2NDVcIixcbiAgICBzaGlmdF9yaWdodDogMSxcbiAgICBzaGlmdF91cDogMCxcbiAgICBzaGlmdF9kb3duOiA1LFxuICAgIHdpZHRoOiAxNCxcbiAgfSxcbiAgXCJ0dXJuXCI6IHtcbiAgICBjb2RlOiBcInY3MlwiLFxuICAgIHNoaWZ0X3JpZ2h0OiAxLFxuICAgIHNoaWZ0X3VwOiAwLFxuICAgIHNoaWZ0X2Rvd246IDUsXG4gICAgd2lkdGg6IDIwLFxuICB9LFxuICBcInR1cm5faW52ZXJ0ZWRcIjoge1xuICAgIGNvZGU6IFwidjMzXCIsXG4gICAgc2hpZnRfcmlnaHQ6IDEsXG4gICAgc2hpZnRfdXA6IDAsXG4gICAgc2hpZnRfZG93bjogNixcbiAgICB3aWR0aDogMjAsXG4gIH0sXG4gIFwidHJcIjoge1xuICAgIGNvZGU6IFwidjFmXCIsXG4gICAgc2hpZnRfcmlnaHQ6IDAsXG4gICAgc2hpZnRfdXA6IDUsXG4gICAgc2hpZnRfZG93bjogMTUsXG4gICAgd2lkdGg6IDEwLFxuICB9LFxuICBcInVwcHJhbGxcIjoge1xuICAgIGNvZGU6IFwidjYwXCIsXG4gICAgc2hpZnRfcmlnaHQ6IDEsXG4gICAgc2hpZnRfdXA6IC0zLFxuICAgIHNoaWZ0X2Rvd246IDYsXG4gICAgd2lkdGg6IDIwLFxuICB9LFxuICBcImRvd25wcmFsbFwiOiB7XG4gICAgY29kZTogXCJ2YjRcIixcbiAgICBzaGlmdF9yaWdodDogMSxcbiAgICBzaGlmdF91cDogLTMsXG4gICAgc2hpZnRfZG93bjogNixcbiAgICB3aWR0aDogMjAsXG4gIH0sXG4gIFwicHJhbGx1cFwiOiB7XG4gICAgY29kZTogXCJ2NmRcIixcbiAgICBzaGlmdF9yaWdodDogMSxcbiAgICBzaGlmdF91cDogLTMsXG4gICAgc2hpZnRfZG93bjogNixcbiAgICB3aWR0aDogMjAsXG4gIH0sXG4gIFwicHJhbGxkb3duXCI6IHtcbiAgICBjb2RlOiBcInYyY1wiLFxuICAgIHNoaWZ0X3JpZ2h0OiAxLFxuICAgIHNoaWZ0X3VwOiAtMyxcbiAgICBzaGlmdF9kb3duOiA2LFxuICAgIHdpZHRoOiAyMCxcbiAgfSxcbiAgXCJ1cG1vcmRlbnRcIjoge1xuICAgIGNvZGU6IFwidjI5XCIsXG4gICAgc2hpZnRfcmlnaHQ6IDEsXG4gICAgc2hpZnRfdXA6IC0zLFxuICAgIHNoaWZ0X2Rvd246IDYsXG4gICAgd2lkdGg6IDIwLFxuICB9LFxuICBcImRvd25tb3JkZW50XCI6IHtcbiAgICBjb2RlOiBcInY2OFwiLFxuICAgIHNoaWZ0X3JpZ2h0OiAxLFxuICAgIHNoaWZ0X3VwOiAtMyxcbiAgICBzaGlmdF9kb3duOiA2LFxuICAgIHdpZHRoOiAyMCxcbiAgfSxcbiAgXCJsaW5lcHJhbGxcIjoge1xuICAgIGNvZGU6IFwidjIwXCIsXG4gICAgc2hpZnRfcmlnaHQ6IDEsXG4gICAgc2hpZnRfdXA6IC0zLFxuICAgIHNoaWZ0X2Rvd246IDYsXG4gICAgd2lkdGg6IDIwLFxuICB9LFxuICBcInByYWxscHJhbGxcIjoge1xuICAgIGNvZGU6IFwidjg2XCIsXG4gICAgc2hpZnRfcmlnaHQ6IDEsXG4gICAgc2hpZnRfdXA6IC0zLFxuICAgIHNoaWZ0X2Rvd246IDYsXG4gICAgd2lkdGg6IDIwLFxuICB9XG59O1xuXG5WZXguRmxvdy5rZXlTaWduYXR1cmUgPSBmdW5jdGlvbihzcGVjKSB7XG4gIHZhciBrZXlTcGVjID0gVmV4LkZsb3cua2V5U2lnbmF0dXJlLmtleVNwZWNzW3NwZWNdO1xuXG4gIGlmICgha2V5U3BlYykge1xuICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEtleVNpZ25hdHVyZVwiLFxuICAgICAgICBcIkJhZCBrZXkgc2lnbmF0dXJlIHNwZWM6ICdcIiArIHNwZWMgKyBcIidcIik7XG4gIH1cblxuICBpZiAoIWtleVNwZWMuYWNjKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG5cbiAgdmFyIG5vdGVzID0gVmV4LkZsb3cua2V5U2lnbmF0dXJlLmFjY2lkZW50YWxMaXN0KGtleVNwZWMuYWNjKTtcblxuICB2YXIgYWNjX2xpc3QgPSBbXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlTcGVjLm51bTsgKytpKSB7XG4gICAgdmFyIGxpbmUgPSBub3Rlc1tpXTtcbiAgICBhY2NfbGlzdC5wdXNoKHt0eXBlOiBrZXlTcGVjLmFjYywgbGluZTogbGluZX0pO1xuICB9XG5cbiAgcmV0dXJuIGFjY19saXN0O1xufTtcblxuVmV4LkZsb3cua2V5U2lnbmF0dXJlLmtleVNwZWNzID0ge1xuICBcIkNcIjoge2FjYzogbnVsbCwgbnVtOiAwfSxcbiAgXCJBbVwiOiB7YWNjOiBudWxsLCBudW06IDB9LFxuICBcIkZcIjoge2FjYzogXCJiXCIsIG51bTogMX0sXG4gIFwiRG1cIjoge2FjYzogXCJiXCIsIG51bTogMX0sXG4gIFwiQmJcIjoge2FjYzogXCJiXCIsIG51bTogMn0sXG4gIFwiR21cIjoge2FjYzogXCJiXCIsIG51bTogMn0sXG4gIFwiRWJcIjoge2FjYzogXCJiXCIsIG51bTogM30sXG4gIFwiQ21cIjoge2FjYzogXCJiXCIsIG51bTogM30sXG4gIFwiQWJcIjoge2FjYzogXCJiXCIsIG51bTogNH0sXG4gIFwiRm1cIjoge2FjYzogXCJiXCIsIG51bTogNH0sXG4gIFwiRGJcIjoge2FjYzogXCJiXCIsIG51bTogNX0sXG4gIFwiQmJtXCI6IHthY2M6IFwiYlwiLCBudW06IDV9LFxuICBcIkdiXCI6IHthY2M6IFwiYlwiLCBudW06IDZ9LFxuICBcIkVibVwiOiB7YWNjOiBcImJcIiwgbnVtOiA2fSxcbiAgXCJDYlwiOiB7YWNjOiBcImJcIiwgbnVtOiA3fSxcbiAgXCJBYm1cIjoge2FjYzogXCJiXCIsIG51bTogN30sXG4gIFwiR1wiOiB7YWNjOiBcIiNcIiwgbnVtOiAxfSxcbiAgXCJFbVwiOiB7YWNjOiBcIiNcIiwgbnVtOiAxfSxcbiAgXCJEXCI6IHthY2M6IFwiI1wiLCBudW06IDJ9LFxuICBcIkJtXCI6IHthY2M6IFwiI1wiLCBudW06IDJ9LFxuICBcIkFcIjoge2FjYzogXCIjXCIsIG51bTogM30sXG4gIFwiRiNtXCI6IHthY2M6IFwiI1wiLCBudW06IDN9LFxuICBcIkVcIjoge2FjYzogXCIjXCIsIG51bTogNH0sXG4gIFwiQyNtXCI6IHthY2M6IFwiI1wiLCBudW06IDR9LFxuICBcIkJcIjoge2FjYzogXCIjXCIsIG51bTogNX0sXG4gIFwiRyNtXCI6IHthY2M6IFwiI1wiLCBudW06IDV9LFxuICBcIkYjXCI6IHthY2M6IFwiI1wiLCBudW06IDZ9LFxuICBcIkQjbVwiOiB7YWNjOiBcIiNcIiwgbnVtOiA2fSxcbiAgXCJDI1wiOiB7YWNjOiBcIiNcIiwgbnVtOiA3fSxcbiAgXCJBI21cIjoge2FjYzogXCIjXCIsIG51bTogN31cbn07XG5cblZleC5GbG93LnVuaWNvZGUgPSB7XG4gIC8vIFVuaWNvZGUgYWNjaWRlbnRhbHNcbiAgXCJzaGFycFwiOiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KCcyNjZGJywgMTYpKSxcbiAgXCJmbGF0XCIgOiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KCcyNjZEJywgMTYpKSxcbiAgXCJuYXR1cmFsXCI6IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoJzI2NkUnLCAxNikpLFxuICAvLyBNYWpvciBDaG9yZFxuICBcInRyaWFuZ2xlXCI6IFN0cmluZy5mcm9tQ2hhckNvZGUocGFyc2VJbnQoJzI1QjMnLCAxNikpLFxuICAvLyBoYWxmLWRpbWluaXNoZWRcbiAgXCJvLXdpdGgtc2xhc2hcIjogU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCgnMDBGOCcsIDE2KSksXG4gICAvLyBEaW1pbmlzaGVkXG4gIFwiZGVncmVlc1wiOiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KCcwMEIwJywgMTYpKSxcbiAgXCJjaXJjbGVcIjogU3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludCgnMjVDQicsIDE2KSlcbn07XG5cblZleC5GbG93LmtleVNpZ25hdHVyZS5hY2NpZGVudGFsTGlzdCA9IGZ1bmN0aW9uKGFjYykge1xuICBpZiAoYWNjID09IFwiYlwiKSB7XG4gICAgcmV0dXJuIFsyLCAwLjUsIDIuNSwgMSwgMywgMS41LCAzLjVdO1xuICB9XG4gIGVsc2UgaWYgKGFjYyA9PSBcIiNcIikge1xuICAgIHJldHVybiBbMCwgMS41LCAtMC41LCAxLCAyLjUsIDAuNSwgMl07IH1cbn07XG5cblZleC5GbG93LnBhcnNlTm90ZUR1cmF0aW9uU3RyaW5nID0gZnVuY3Rpb24oZHVyYXRpb25TdHJpbmcpIHtcbiAgaWYgKHR5cGVvZihkdXJhdGlvblN0cmluZykgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciByZWdleHAgPSAvKFxcZCpcXC8/XFxkK3xbYS16XSkoZCopKFtucmhtc118JCkvO1xuXG4gIHZhciByZXN1bHQgPSByZWdleHAuZXhlYyhkdXJhdGlvblN0cmluZyk7XG4gIGlmICghcmVzdWx0KSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICB2YXIgZHVyYXRpb24gPSByZXN1bHRbMV07XG4gIHZhciBkb3RzID0gcmVzdWx0WzJdLmxlbmd0aDtcbiAgdmFyIHR5cGUgPSByZXN1bHRbM107XG5cbiAgaWYgKHR5cGUubGVuZ3RoID09PSAwKSB7XG4gICAgdHlwZSA9IFwiblwiO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBkdXJhdGlvbjogZHVyYXRpb24sXG4gICAgZG90czogZG90cyxcbiAgICB0eXBlOiB0eXBlXG4gIH07XG59O1xuXG5WZXguRmxvdy5wYXJzZU5vdGVEYXRhID0gZnVuY3Rpb24obm90ZURhdGEpIHtcbiAgdmFyIGR1cmF0aW9uID0gbm90ZURhdGEuZHVyYXRpb247XG5cbiAgLy8gUHJlc2VydmUgYmFja3dhcmRzLWNvbXBhdGliaWxpdHlcbiAgdmFyIGR1cmF0aW9uU3RyaW5nRGF0YSA9IFZleC5GbG93LnBhcnNlTm90ZUR1cmF0aW9uU3RyaW5nKGR1cmF0aW9uKTtcbiAgaWYgKCFkdXJhdGlvblN0cmluZ0RhdGEpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciB0aWNrcyA9IFZleC5GbG93LmR1cmF0aW9uVG9UaWNrcyhkdXJhdGlvblN0cmluZ0RhdGEuZHVyYXRpb24pO1xuICBpZiAodGlja3MgPT0gbnVsbCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIHR5cGUgPSBub3RlRGF0YS50eXBlO1xuXG4gIGlmICh0eXBlKSB7XG4gICAgaWYgKCEodHlwZSA9PT0gXCJuXCIgfHwgdHlwZSA9PT0gXCJyXCIgfHwgdHlwZSA9PT0gXCJoXCIgfHxcbiAgICAgICAgICB0eXBlID09PSBcIm1cIiB8fCB0eXBlID09PSBcInNcIikpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB0eXBlID0gZHVyYXRpb25TdHJpbmdEYXRhLnR5cGU7XG4gICAgaWYgKCF0eXBlKSB7XG4gICAgICB0eXBlID0gXCJuXCI7XG4gICAgfVxuICB9XG5cbiAgdmFyIGRvdHMgPSAwO1xuICBpZiAobm90ZURhdGEuZG90cykge1xuICAgIGRvdHMgPSBub3RlRGF0YS5kb3RzO1xuICB9IGVsc2Uge1xuICAgIGRvdHMgPSBkdXJhdGlvblN0cmluZ0RhdGEuZG90cztcbiAgfVxuXG4gIGlmICh0eXBlb2YoZG90cykgIT09IFwibnVtYmVyXCIpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjdXJyZW50VGlja3MgPSB0aWNrcztcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IGRvdHM7IGkrKykge1xuICAgIGlmIChjdXJyZW50VGlja3MgPD0gMSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgY3VycmVudFRpY2tzID0gY3VycmVudFRpY2tzIC8gMjtcbiAgICB0aWNrcyArPSBjdXJyZW50VGlja3M7XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGR1cmF0aW9uOiBkdXJhdGlvblN0cmluZ0RhdGEuZHVyYXRpb24sXG4gICAgdHlwZTogdHlwZSxcbiAgICBkb3RzOiBkb3RzLFxuICAgIHRpY2tzOiB0aWNrc1xuICB9O1xufTtcblxuLy8gVXNlZCB0byBjb252ZXJ0IGR1cmF0aW9uIGFsaWFzZXMgdG8gdGhlIG51bWJlciBiYXNlZCBkdXJhdGlvbi5cbi8vIElmIHRoZSBpbnB1dCBpc24ndCBhbiBhbGlhcywgc2ltcGx5IHJldHVybiB0aGUgaW5wdXQuXG4vL1xuLy8gZXhhbXBsZTogJ3EnIC0+ICc0JywgJzgnIC0+ICc4J1xuVmV4LkZsb3cuc2FuaXRpemVEdXJhdGlvbiA9IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gIHZhciBhbGlhcyA9IFZleC5GbG93LmR1cmF0aW9uQWxpYXNlc1tkdXJhdGlvbl07XG4gIGlmIChhbGlhcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZHVyYXRpb24gPSBhbGlhcztcbiAgfVxuXG4gIGlmIChWZXguRmxvdy5kdXJhdGlvblRvVGlja3MuZHVyYXRpb25zW2R1cmF0aW9uXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgdGhyb3cgbmV3IFZleC5SRVJSKCdCYWRBcmd1bWVudHMnLFxuICAgICAgJ1RoZSBwcm92aWRlZCBkdXJhdGlvbiBpcyBub3QgdmFsaWQnKTtcbiAgfVxuXG4gIHJldHVybiBkdXJhdGlvbjtcbn07XG5cbi8vIENvbnZlcnQgdGhlIGBkdXJhdGlvbmAgdG8gYW4gZnJhY3Rpb25cblZleC5GbG93LmR1cmF0aW9uVG9GcmFjdGlvbiA9IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gIHJldHVybiBuZXcgVmV4LkZsb3cuRnJhY3Rpb24oKS5wYXJzZShWZXguRmxvdy5zYW5pdGl6ZUR1cmF0aW9uKGR1cmF0aW9uKSk7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBgZHVyYXRpb25gIHRvIGFuIG51bWJlclxuVmV4LkZsb3cuZHVyYXRpb25Ub051bWJlciA9IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gIHJldHVybiBWZXguRmxvdy5kdXJhdGlvblRvRnJhY3Rpb24oZHVyYXRpb24pLnZhbHVlKCk7XG59O1xuXG4vLyBDb252ZXJ0IHRoZSBgZHVyYXRpb25gIHRvIHRvdGFsIHRpY2tzXG5WZXguRmxvdy5kdXJhdGlvblRvVGlja3MgPSBmdW5jdGlvbihkdXJhdGlvbikge1xuICBkdXJhdGlvbiA9IFZleC5GbG93LnNhbml0aXplRHVyYXRpb24oZHVyYXRpb24pO1xuXG4gIHZhciB0aWNrcyA9IFZleC5GbG93LmR1cmF0aW9uVG9UaWNrcy5kdXJhdGlvbnNbZHVyYXRpb25dO1xuICBpZiAodGlja3MgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIHRpY2tzO1xufTtcblxuVmV4LkZsb3cuZHVyYXRpb25Ub1RpY2tzLmR1cmF0aW9ucyA9IHtcbiAgXCIxLzJcIjogIFZleC5GbG93LlJFU09MVVRJT04gKiAyLFxuICBcIjFcIjogICAgVmV4LkZsb3cuUkVTT0xVVElPTiAvIDEsXG4gIFwiMlwiOiAgICBWZXguRmxvdy5SRVNPTFVUSU9OIC8gMixcbiAgXCI0XCI6ICAgIFZleC5GbG93LlJFU09MVVRJT04gLyA0LFxuICBcIjhcIjogICAgVmV4LkZsb3cuUkVTT0xVVElPTiAvIDgsXG4gIFwiMTZcIjogICBWZXguRmxvdy5SRVNPTFVUSU9OIC8gMTYsXG4gIFwiMzJcIjogICBWZXguRmxvdy5SRVNPTFVUSU9OIC8gMzIsXG4gIFwiNjRcIjogICBWZXguRmxvdy5SRVNPTFVUSU9OIC8gNjQsXG4gIFwiMTI4XCI6ICBWZXguRmxvdy5SRVNPTFVUSU9OIC8gMTI4LFxuICBcIjI1NlwiOiAgVmV4LkZsb3cuUkVTT0xVVElPTiAvIDI1NlxufTtcblxuVmV4LkZsb3cuZHVyYXRpb25BbGlhc2VzID0ge1xuICBcIndcIjogXCIxXCIsXG4gIFwiaFwiOiBcIjJcIixcbiAgXCJxXCI6IFwiNFwiLFxuXG4gIC8vIFRoaXMgaXMgdGhlIGRlZmF1bHQgZHVyYXRpb24gdXNlZCB0byByZW5kZXIgYmFycyAoQmFyTm90ZSkuIEJhcnMgbm8gbG9uZ2VyXG4gIC8vIGNvbnN1bWUgdGlja3MsIHNvIHRoaXMgc2hvdWxkIGJlIGEgbm8tb3AuXG4gIC8vXG4gIC8vIFRPRE8oMHhmZSk6IFRoaXMgbmVlZHMgdG8gYmUgY2xlYW5lZCB1cC5cbiAgXCJiXCI6IFwiMjU2XCJcbn07XG5cblZleC5GbG93LmR1cmF0aW9uVG9HbHlwaCA9IGZ1bmN0aW9uKGR1cmF0aW9uLCB0eXBlKSB7XG4gIGR1cmF0aW9uID0gVmV4LkZsb3cuc2FuaXRpemVEdXJhdGlvbihkdXJhdGlvbik7XG5cbiAgdmFyIGNvZGUgPSBWZXguRmxvdy5kdXJhdGlvblRvR2x5cGguZHVyYXRpb25fY29kZXNbZHVyYXRpb25dO1xuICBpZiAoY29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBpZiAoIXR5cGUpIHtcbiAgICB0eXBlID0gXCJuXCI7XG4gIH1cblxuICB2YXIgZ2x5cGhUeXBlUHJvcGVydGllcyA9IGNvZGUudHlwZVt0eXBlXTtcbiAgaWYgKGdseXBoVHlwZVByb3BlcnRpZXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgcmV0dXJuIFZleC5NZXJnZShWZXguTWVyZ2Uoe30sIGNvZGUuY29tbW9uKSwgZ2x5cGhUeXBlUHJvcGVydGllcyk7XG59O1xuXG5WZXguRmxvdy5kdXJhdGlvblRvR2x5cGguZHVyYXRpb25fY29kZXMgPSB7XG4gIFwiMS8yXCI6IHtcbiAgICBjb21tb246IHtcbiAgICAgIGhlYWRfd2lkdGg6IDIyLFxuICAgICAgc3RlbTogZmFsc2UsXG4gICAgICBzdGVtX29mZnNldDogMCxcbiAgICAgIGZsYWc6IGZhbHNlLFxuICAgICAgc3RlbV91cF9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIHN0ZW1fZG93bl9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIGdyYWNlbm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogLVZleC5GbG93LlNURU1fSEVJR0hULFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fZG93bl9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIHRhYm5vdGVfc3RlbV91cF9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIHRhYm5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLVZleC5GbG93LlNURU1fSEVJR0hULFxuICAgICAgZG90X3NoaWZ0WTogMCxcbiAgICAgIGxpbmVfYWJvdmU6IDAsXG4gICAgICBsaW5lX2JlbG93OiAwXG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICBcIm5cIjogeyAvLyBCcmV2ZSBub3RlXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2NTNcIlxuICAgICAgfSxcbiAgICAgIFwiaFwiOiB7IC8vIEJyZXZlIG5vdGUgaGFybW9uaWNcbiAgICAgICAgY29kZV9oZWFkOiBcInY1OVwiXG4gICAgICB9LFxuICAgICAgXCJtXCI6IHsgLy8gQnJldmUgbm90ZSBtdXRlZCAtXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2ZlwiLFxuICAgICAgICBzdGVtX29mZnNldDogMFxuICAgICAgfSxcbiAgICAgIFwiclwiOiB7IC8vIEJyZXZlIHJlc3RcbiAgICAgICAgY29kZV9oZWFkOiBcInYzMVwiLFxuICAgICAgICBoZWFkX3dpZHRoOiAyNCxcbiAgICAgICAgcmVzdDogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246IFwiQi81XCIsXG4gICAgICAgIGRvdF9zaGlmdFk6IDAuNVxuICAgICAgfSxcbiAgICAgIFwic1wiOiB7IC8vIEJyZXZlIG5vdGUgc2xhc2ggLVxuICAgICAgICAvLyBEcmF3biB3aXRoIGNhbnZhcyBwcmltaXRpdmVzXG4gICAgICAgIGhlYWRfd2lkdGg6IDE1LFxuICAgICAgICBwb3NpdGlvbjogXCJCLzRcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCIxXCI6IHtcbiAgICBjb21tb246IHtcbiAgICAgIGhlYWRfd2lkdGg6IDE2LFxuICAgICAgc3RlbTogZmFsc2UsXG4gICAgICBzdGVtX29mZnNldDogMCxcbiAgICAgIGZsYWc6IGZhbHNlLFxuICAgICAgc3RlbV91cF9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIHN0ZW1fZG93bl9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIGdyYWNlbm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogLVZleC5GbG93LlNURU1fSEVJR0hULFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fZG93bl9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIHRhYm5vdGVfc3RlbV91cF9leHRlbnNpb246IC1WZXguRmxvdy5TVEVNX0hFSUdIVCxcbiAgICAgIHRhYm5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLVZleC5GbG93LlNURU1fSEVJR0hULFxuICAgICAgZG90X3NoaWZ0WTogMCxcbiAgICAgIGxpbmVfYWJvdmU6IDAsXG4gICAgICBsaW5lX2JlbG93OiAwXG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICBcIm5cIjogeyAvLyBXaG9sZSBub3RlXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2MWRcIlxuICAgICAgfSxcbiAgICAgIFwiaFwiOiB7IC8vIFdob2xlIG5vdGUgaGFybW9uaWNcbiAgICAgICAgY29kZV9oZWFkOiBcInY0NlwiXG4gICAgICB9LFxuICAgICAgXCJtXCI6IHsgLy8gV2hvbGUgbm90ZSBtdXRlZFxuICAgICAgICBjb2RlX2hlYWQ6IFwidjkyXCIsXG4gICAgICAgIHN0ZW1fb2Zmc2V0OiAtM1xuICAgICAgfSxcbiAgICAgIFwiclwiOiB7IC8vIFdob2xlIHJlc3RcbiAgICAgICAgY29kZV9oZWFkOiBcInY1Y1wiLFxuICAgICAgICBoZWFkX3dpZHRoOiAxMixcbiAgICAgICAgcmVzdDogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246IFwiRC81XCIsXG4gICAgICAgIGRvdF9zaGlmdFk6IDAuNVxuICAgICAgfSxcbiAgICAgIFwic1wiOiB7IC8vIFdob2xlIG5vdGUgc2xhc2hcbiAgICAgICAgLy8gRHJhd24gd2l0aCBjYW52YXMgcHJpbWl0aXZlc1xuICAgICAgICBoZWFkX3dpZHRoOiAxNSxcbiAgICAgICAgcG9zaXRpb246IFwiQi80XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiMlwiOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICBoZWFkX3dpZHRoOiAxMCxcbiAgICAgIHN0ZW06IHRydWUsXG4gICAgICBzdGVtX29mZnNldDogMCxcbiAgICAgIGZsYWc6IGZhbHNlLFxuICAgICAgc3RlbV91cF9leHRlbnNpb246IDAsXG4gICAgICBzdGVtX2Rvd25fZXh0ZW5zaW9uOiAwLFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fdXBfZXh0ZW5zaW9uOiAtMTQsXG4gICAgICBncmFjZW5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLTE0LFxuICAgICAgdGFibm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogMCxcbiAgICAgIHRhYm5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogMCxcbiAgICAgIGRvdF9zaGlmdFk6IDAsXG4gICAgICBsaW5lX2Fib3ZlOiAwLFxuICAgICAgbGluZV9iZWxvdzogMFxuICAgIH0sXG4gICAgdHlwZToge1xuICAgICAgXCJuXCI6IHsgLy8gSGFsZiBub3RlXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2ODFcIlxuICAgICAgfSxcbiAgICAgIFwiaFwiOiB7IC8vIEhhbGYgbm90ZSBoYXJtb25pY1xuICAgICAgICBjb2RlX2hlYWQ6IFwidjJkXCJcbiAgICAgIH0sXG4gICAgICBcIm1cIjogeyAvLyBIYWxmIG5vdGUgbXV0ZWRcbiAgICAgICAgY29kZV9oZWFkOiBcInY5NVwiLFxuICAgICAgICBzdGVtX29mZnNldDogLTNcbiAgICAgIH0sXG4gICAgICBcInJcIjogeyAvLyBIYWxmIHJlc3RcbiAgICAgICAgY29kZV9oZWFkOiBcInZjXCIsXG4gICAgICAgIGhlYWRfd2lkdGg6IDEyLFxuICAgICAgICBzdGVtOiBmYWxzZSxcbiAgICAgICAgcmVzdDogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246IFwiQi80XCIsXG4gICAgICAgIGRvdF9zaGlmdFk6IC0wLjVcbiAgICAgIH0sXG4gICAgICBcInNcIjogeyAvLyBIYWxmIG5vdGUgc2xhc2hcbiAgICAgICAgLy8gRHJhd24gd2l0aCBjYW52YXMgcHJpbWl0aXZlc1xuICAgICAgICBoZWFkX3dpZHRoOiAxNSxcbiAgICAgICAgcG9zaXRpb246IFwiQi80XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiNFwiOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICBoZWFkX3dpZHRoOiAxMCxcbiAgICAgIHN0ZW06IHRydWUsXG4gICAgICBzdGVtX29mZnNldDogMCxcbiAgICAgIGZsYWc6IGZhbHNlLFxuICAgICAgc3RlbV91cF9leHRlbnNpb246IDAsXG4gICAgICBzdGVtX2Rvd25fZXh0ZW5zaW9uOiAwLFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fdXBfZXh0ZW5zaW9uOiAtMTQsXG4gICAgICBncmFjZW5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLTE0LFxuICAgICAgdGFibm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogMCxcbiAgICAgIHRhYm5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogMCxcbiAgICAgIGRvdF9zaGlmdFk6IDAsXG4gICAgICBsaW5lX2Fib3ZlOiAwLFxuICAgICAgbGluZV9iZWxvdzogMFxuICAgIH0sXG4gICAgdHlwZToge1xuICAgICAgXCJuXCI6IHsgLy8gUXVhcnRlciBub3RlXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2YlwiXG4gICAgICB9LFxuICAgICAgXCJoXCI6IHsgLy8gUXVhcnRlciBoYXJtb25pY1xuICAgICAgICBjb2RlX2hlYWQ6IFwidjIyXCJcbiAgICAgIH0sXG4gICAgICBcIm1cIjogeyAvLyBRdWFydGVyIG11dGVkXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2M2VcIixcbiAgICAgICAgc3RlbV9vZmZzZXQ6IC0zXG4gICAgICB9LFxuICAgICAgXCJyXCI6IHsgLy8gUXVhcnRlciByZXN0XG4gICAgICAgIGNvZGVfaGVhZDogXCJ2N2NcIixcbiAgICAgICAgaGVhZF93aWR0aDogOCxcbiAgICAgICAgc3RlbTogZmFsc2UsXG4gICAgICAgIHJlc3Q6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBcIkIvNFwiLFxuICAgICAgICBkb3Rfc2hpZnRZOiAtMC41LFxuICAgICAgICBsaW5lX2Fib3ZlOiAxLjUsXG4gICAgICAgIGxpbmVfYmVsb3c6IDEuNVxuICAgICAgfSxcbiAgICAgIFwic1wiOiB7IC8vIFF1YXJ0ZXIgc2xhc2hcbiAgICAgICAgIC8vIERyYXduIHdpdGggY2FudmFzIHByaW1pdGl2ZXNcbiAgICAgICAgIGhlYWRfd2lkdGg6IDE1LFxuICAgICAgICAgcG9zaXRpb246IFwiQi80XCJcbiAgICAgIH1cbiAgICB9XG4gIH0sXG4gIFwiOFwiOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICBoZWFkX3dpZHRoOiAxMCxcbiAgICAgIHN0ZW06IHRydWUsXG4gICAgICBzdGVtX29mZnNldDogMCxcbiAgICAgIGZsYWc6IHRydWUsXG4gICAgICBiZWFtX2NvdW50OiAxLFxuICAgICAgY29kZV9mbGFnX3Vwc3RlbTogXCJ2NTRcIixcbiAgICAgIGNvZGVfZmxhZ19kb3duc3RlbTogXCJ2OWFcIixcbiAgICAgIHN0ZW1fdXBfZXh0ZW5zaW9uOiAwLFxuICAgICAgc3RlbV9kb3duX2V4dGVuc2lvbjogMCxcbiAgICAgIGdyYWNlbm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogLTE0LFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fZG93bl9leHRlbnNpb246IC0xNCxcbiAgICAgIHRhYm5vdGVfc3RlbV91cF9leHRlbnNpb246IDAsXG4gICAgICB0YWJub3RlX3N0ZW1fZG93bl9leHRlbnNpb246IDAsXG4gICAgICBkb3Rfc2hpZnRZOiAwLFxuICAgICAgbGluZV9hYm92ZTogMCxcbiAgICAgIGxpbmVfYmVsb3c6IDBcbiAgICB9LFxuICAgIHR5cGU6IHtcbiAgICAgIFwiblwiOiB7IC8vIEVpZ2h0aCBub3RlXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2YlwiXG4gICAgICB9LFxuICAgICAgXCJoXCI6IHsgLy8gRWlnaHRoIG5vdGUgaGFybW9uaWNcbiAgICAgICAgY29kZV9oZWFkOiBcInYyMlwiXG4gICAgICB9LFxuICAgICAgXCJtXCI6IHsgLy8gRWlnaHRoIG5vdGUgbXV0ZWRcbiAgICAgICAgY29kZV9oZWFkOiBcInYzZVwiXG4gICAgICB9LFxuICAgICAgXCJyXCI6IHsgLy8gRWlnaHRoIHJlc3RcbiAgICAgICAgY29kZV9oZWFkOiBcInZhNVwiLFxuICAgICAgICBzdGVtOiBmYWxzZSxcbiAgICAgICAgZmxhZzogZmFsc2UsXG4gICAgICAgIHJlc3Q6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBcIkIvNFwiLFxuICAgICAgICBkb3Rfc2hpZnRZOiAtMC41LFxuICAgICAgICBsaW5lX2Fib3ZlOiAxLjAsXG4gICAgICAgIGxpbmVfYmVsb3c6IDEuMFxuICAgICAgfSxcbiAgICAgIFwic1wiOiB7IC8vIEVpZ2h0IHNsYXNoXG4gICAgICAgIC8vIERyYXduIHdpdGggY2FudmFzIHByaW1pdGl2ZXNcbiAgICAgICAgaGVhZF93aWR0aDogMTUsXG4gICAgICAgIHBvc2l0aW9uOiBcIkIvNFwiXG4gICAgICB9XG4gICAgfVxuICB9LFxuICBcIjE2XCI6IHtcbiAgICBjb21tb246IHtcbiAgICAgIGJlYW1fY291bnQ6IDIsXG4gICAgICBoZWFkX3dpZHRoOiAxMCxcbiAgICAgIHN0ZW06IHRydWUsXG4gICAgICBzdGVtX29mZnNldDogMCxcbiAgICAgIGZsYWc6IHRydWUsXG4gICAgICBjb2RlX2ZsYWdfdXBzdGVtOiBcInYzZlwiLFxuICAgICAgY29kZV9mbGFnX2Rvd25zdGVtOiBcInY4ZlwiLFxuICAgICAgc3RlbV91cF9leHRlbnNpb246IDQsXG4gICAgICBzdGVtX2Rvd25fZXh0ZW5zaW9uOiAwLFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fdXBfZXh0ZW5zaW9uOiAtMTQsXG4gICAgICBncmFjZW5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLTE0LFxuICAgICAgdGFibm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogMCxcbiAgICAgIHRhYm5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogMCxcbiAgICAgIGRvdF9zaGlmdFk6IDAsXG4gICAgICBsaW5lX2Fib3ZlOiAwLFxuICAgICAgbGluZV9iZWxvdzogMFxuICAgIH0sXG4gICAgdHlwZToge1xuICAgICAgXCJuXCI6IHsgLy8gU2l4dGVlbnRoIG5vdGVcbiAgICAgICAgY29kZV9oZWFkOiBcInZiXCJcbiAgICAgIH0sXG4gICAgICBcImhcIjogeyAvLyBTaXh0ZWVudGggbm90ZSBoYXJtb25pY1xuICAgICAgICBjb2RlX2hlYWQ6IFwidjIyXCJcbiAgICAgIH0sXG4gICAgICBcIm1cIjogeyAvLyBTaXh0ZWVudGggbm90ZSBtdXRlZFxuICAgICAgICBjb2RlX2hlYWQ6IFwidjNlXCJcbiAgICAgIH0sXG4gICAgICBcInJcIjogeyAvLyBTaXh0ZWVudGggcmVzdFxuICAgICAgICBjb2RlX2hlYWQ6IFwidjNjXCIsXG4gICAgICAgIGhlYWRfd2lkdGg6IDEzLFxuICAgICAgICBzdGVtOiBmYWxzZSxcbiAgICAgICAgZmxhZzogZmFsc2UsXG4gICAgICAgIHJlc3Q6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBcIkIvNFwiLFxuICAgICAgICBkb3Rfc2hpZnRZOiAtMC41LFxuICAgICAgICBsaW5lX2Fib3ZlOiAxLjAsXG4gICAgICAgIGxpbmVfYmVsb3c6IDIuMFxuICAgICAgfSxcbiAgICAgIFwic1wiOiB7IC8vIFNpeHRlZW50aCBzbGFzaFxuICAgICAgICAvLyBEcmF3biB3aXRoIGNhbnZhcyBwcmltaXRpdmVzXG4gICAgICAgIGhlYWRfd2lkdGg6IDE1LFxuICAgICAgICBwb3NpdGlvbjogXCJCLzRcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCIzMlwiOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICBiZWFtX2NvdW50OiAzLFxuICAgICAgaGVhZF93aWR0aDogMTAsXG4gICAgICBzdGVtOiB0cnVlLFxuICAgICAgc3RlbV9vZmZzZXQ6IDAsXG4gICAgICBmbGFnOiB0cnVlLFxuICAgICAgY29kZV9mbGFnX3Vwc3RlbTogXCJ2NDdcIixcbiAgICAgIGNvZGVfZmxhZ19kb3duc3RlbTogXCJ2MmFcIixcbiAgICAgIHN0ZW1fdXBfZXh0ZW5zaW9uOiAxMyxcbiAgICAgIHN0ZW1fZG93bl9leHRlbnNpb246IDksXG4gICAgICBncmFjZW5vdGVfc3RlbV91cF9leHRlbnNpb246IC0xMixcbiAgICAgIGdyYWNlbm90ZV9zdGVtX2Rvd25fZXh0ZW5zaW9uOiAtMTIsXG4gICAgICB0YWJub3RlX3N0ZW1fdXBfZXh0ZW5zaW9uOiA5LFxuICAgICAgdGFibm90ZV9zdGVtX2Rvd25fZXh0ZW5zaW9uOiA1LFxuICAgICAgZG90X3NoaWZ0WTogMCxcbiAgICAgIGxpbmVfYWJvdmU6IDAsXG4gICAgICBsaW5lX2JlbG93OiAwXG4gICAgfSxcbiAgICB0eXBlOiB7XG4gICAgICBcIm5cIjogeyAvLyBUaGlydHktc2Vjb25kIG5vdGVcbiAgICAgICAgY29kZV9oZWFkOiBcInZiXCJcbiAgICAgIH0sXG4gICAgICBcImhcIjogeyAvLyBUaGlydHktc2Vjb25kIGhhcm1vbmljXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2MjJcIlxuICAgICAgfSxcbiAgICAgIFwibVwiOiB7IC8vIFRoaXJ0eS1zZWNvbmQgbXV0ZWRcbiAgICAgICAgY29kZV9oZWFkOiBcInYzZVwiXG4gICAgICB9LFxuICAgICAgXCJyXCI6IHsgLy8gVGhpcnR5LXNlY29uZCByZXN0XG4gICAgICAgIGNvZGVfaGVhZDogXCJ2NTVcIixcbiAgICAgICAgaGVhZF93aWR0aDogMTYsXG4gICAgICAgIHN0ZW06IGZhbHNlLFxuICAgICAgICBmbGFnOiBmYWxzZSxcbiAgICAgICAgcmVzdDogdHJ1ZSxcbiAgICAgICAgcG9zaXRpb246IFwiQi80XCIsXG4gICAgICAgIGRvdF9zaGlmdFk6IC0xLjUsXG4gICAgICAgIGxpbmVfYWJvdmU6IDIuMCxcbiAgICAgICAgbGluZV9iZWxvdzogMi4wXG4gICAgICB9LFxuICAgICAgXCJzXCI6IHsgLy8gVGhpcnR5LXNlY29uZCBzbGFzaFxuICAgICAgICAvLyBEcmF3biB3aXRoIGNhbnZhcyBwcmltaXRpdmVzXG4gICAgICAgIGhlYWRfd2lkdGg6IDE1LFxuICAgICAgICBwb3NpdGlvbjogXCJCLzRcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCI2NFwiOiB7XG4gICAgY29tbW9uOiB7XG4gICAgICBiZWFtX2NvdW50OiA0LFxuICAgICAgaGVhZF93aWR0aDogMTAsXG4gICAgICBzdGVtOiB0cnVlLFxuICAgICAgc3RlbV9vZmZzZXQ6IDAsXG4gICAgICBmbGFnOiB0cnVlLFxuICAgICAgY29kZV9mbGFnX3Vwc3RlbTogXCJ2YTlcIixcbiAgICAgIGNvZGVfZmxhZ19kb3duc3RlbTogXCJ2NThcIixcbiAgICAgIHN0ZW1fdXBfZXh0ZW5zaW9uOiAxNyxcbiAgICAgIHN0ZW1fZG93bl9leHRlbnNpb246IDEzLFxuICAgICAgZ3JhY2Vub3RlX3N0ZW1fdXBfZXh0ZW5zaW9uOiAtMTAsXG4gICAgICBncmFjZW5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLTEwLFxuICAgICAgdGFibm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogMTMsXG4gICAgICB0YWJub3RlX3N0ZW1fZG93bl9leHRlbnNpb246IDksXG4gICAgICBkb3Rfc2hpZnRZOiAwLFxuICAgICAgbGluZV9hYm92ZTogMCxcbiAgICAgIGxpbmVfYmVsb3c6IDBcbiAgICB9LFxuICAgIHR5cGU6IHtcbiAgICAgIFwiblwiOiB7IC8vIFNpeHR5LWZvdXJ0aCBub3RlXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2YlwiXG4gICAgICB9LFxuICAgICAgXCJoXCI6IHsgLy8gU2l4dHktZm91cnRoIGhhcm1vbmljXG4gICAgICAgIGNvZGVfaGVhZDogXCJ2MjJcIlxuICAgICAgfSxcbiAgICAgIFwibVwiOiB7IC8vIFNpeHR5LWZvdXJ0aCBtdXRlZFxuICAgICAgICBjb2RlX2hlYWQ6IFwidjNlXCJcbiAgICAgIH0sXG4gICAgICBcInJcIjogeyAvLyBTaXh0eS1mb3VydGggcmVzdFxuICAgICAgICBjb2RlX2hlYWQ6IFwidjM4XCIsXG4gICAgICAgIGhlYWRfd2lkdGg6IDE4LFxuICAgICAgICBzdGVtOiBmYWxzZSxcbiAgICAgICAgZmxhZzogZmFsc2UsXG4gICAgICAgIHJlc3Q6IHRydWUsXG4gICAgICAgIHBvc2l0aW9uOiBcIkIvNFwiLFxuICAgICAgICBkb3Rfc2hpZnRZOiAtMS41LFxuICAgICAgICBsaW5lX2Fib3ZlOiAyLjAsXG4gICAgICAgIGxpbmVfYmVsb3c6IDMuMFxuICAgICAgfSxcbiAgICAgIFwic1wiOiB7IC8vIFNpeHR5LWZvdXJ0aCBzbGFzaFxuICAgICAgICAvLyBEcmF3biB3aXRoIGNhbnZhcyBwcmltaXRpdmVzXG4gICAgICAgIGhlYWRfd2lkdGg6IDE1LFxuICAgICAgICBwb3NpdGlvbjogXCJCLzRcIlxuICAgICAgfVxuICAgIH1cbiAgfSxcbiAgXCIxMjhcIjoge1xuICAgICAgY29tbW9uOiB7XG4gICAgICAgICAgYmVhbV9jb3VudDogNSxcbiAgICAgICAgICBoZWFkX3dpZHRoOiAxMCxcbiAgICAgICAgICBzdGVtOiB0cnVlLFxuICAgICAgICAgIHN0ZW1fb2Zmc2V0OjAsXG4gICAgICAgICAgZmxhZzogdHJ1ZSxcbiAgICAgICAgICBjb2RlX2ZsYWdfdXBzdGVtOiBcInY5YlwiLFxuICAgICAgICAgIGNvZGVfZmxhZ19kb3duc3RlbTogXCJ2MzBcIixcbiAgICAgICAgICBzdGVtX3VwX2V4dGVuc2lvbjogMjYsXG4gICAgICAgICAgc3RlbV9kb3duX2V4dGVuc2lvbjogMjIsXG4gICAgICAgICAgZ3JhY2Vub3RlX3N0ZW1fdXBfZXh0ZW5zaW9uOiAtOCxcbiAgICAgICAgICBncmFjZW5vdGVfc3RlbV9kb3duX2V4dGVuc2lvbjogLTgsXG4gICAgICAgICAgdGFibm90ZV9zdGVtX3VwX2V4dGVuc2lvbjogMjIsXG4gICAgICAgICAgdGFibm90ZV9zdGVtX2Rvd25fZXh0ZW5zaW9uOiAxOCxcbiAgICAgICAgICBkb3Rfc2hpZnRZOiAwLFxuICAgICAgICAgIGxpbmVfYWJvdmU6IDAsXG4gICAgICAgICAgbGluZV9iZWxvdzogMFxuICAgICAgfSxcbiAgICAgIHR5cGU6IHtcbiAgICAgICAgICBcIm5cIjogeyAgLy8gSHVuZHJlZC10d2VudHktZWlnaHQgbm90ZVxuICAgICAgICAgICAgICBjb2RlX2hlYWQ6IFwidmJcIlxuICAgICAgICAgIH0sXG4gICAgICAgICAgXCJoXCI6IHsgLy8gSHVuZHJlZC10d2VudHktZWlnaHQgaGFybW9uaWNcbiAgICAgICAgICAgICAgY29kZV9oZWFkOiBcInYyMlwiXG4gICAgICAgICAgfSxcbiAgICAgICAgICBcIm1cIjogeyAvLyBIdW5kcmVkLXR3ZW50eS1laWdodCBtdXRlZFxuICAgICAgICAgICAgICBjb2RlX2hlYWQ6IFwidjNlXCJcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwiclwiOiB7ICAvLyBIdW5kcmVkLXR3ZW50eS1laWdodCByZXN0XG4gICAgICAgICAgICAgIGNvZGVfaGVhZDogXCJ2YWFcIixcbiAgICAgICAgICAgICAgaGVhZF93aWR0aDogMjAsXG4gICAgICAgICAgICAgIHN0ZW06IGZhbHNlLFxuICAgICAgICAgICAgICBmbGFnOiBmYWxzZSxcbiAgICAgICAgICAgICAgcmVzdDogdHJ1ZSxcbiAgICAgICAgICAgICAgcG9zaXRpb246IFwiQi80XCIsXG4gICAgICAgICAgICAgIGRvdF9zaGlmdFk6IDEuNSxcbiAgICAgICAgICAgICAgbGluZV9hYm92ZTogMy4wLFxuICAgICAgICAgICAgICBsaW5lX2JlbG93OiAzLjBcbiAgICAgICAgICB9LFxuICAgICAgICAgIFwic1wiOiB7IC8vIEh1bmRyZWQtdHdlbnR5LWVpZ2h0IHJlc3RcbiAgICAgICAgICAgICAgLy8gRHJhd24gd2l0aCBjYW52YXMgcHJpbWl0aXZlc1xuICAgICAgICAgICAgICBoZWFkX3dpZHRoOiAxNSxcbiAgICAgICAgICAgICAgcG9zaXRpb246IFwiQi80XCJcbiAgICAgICAgICB9XG4gICAgICB9XG4gIH1cbn07XG5cbi8vIFNvbWUgZGVmYXVsdHNcblZleC5GbG93LlRJTUU0XzQgPSB7XG4gIG51bV9iZWF0czogNCxcbiAgYmVhdF92YWx1ZTogNCxcbiAgcmVzb2x1dGlvbjogVmV4LkZsb3cuUkVTT0xVVElPTlxufTtcblxuVmV4LkZsb3cuRm9udCA9IHtcImdseXBoc1wiOntcInYwXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo1MTQuNSxcImhhXCI6NTI1LFwib1wiOlwibSAyMzYgNjQ4IGIgMjQ2IDY0OCAyMzggNjQ4IDI0MiA2NDggYiAyODggNjQ2IDI2MSA2NDggMjgzIDY0OCBiIDQ3MiA1MTMgMzY0IDYzNCA0MjggNTg3IGIgNTE0IDM0NyA1MDIgNDY0IDUxNCA0MTMgYiA0NjIgMTYzIDUxNCAyNzIgNDk5IDIxNyBiIDI1NyA0NCA0MDkgODMgMzMzIDQ0IGIgNTAgMTYzIDE4MSA0NCAxMDMgODMgYiAwIDM0NyAxNCAyMTcgMCAyNzIgYiA0MCA1MTMgMCA0MTMgMTIgNDY0IGIgMjM2IDY0OCA4NyA1OTEgMTU1IDYzOCBtIDI3NyA2MTQgYiAyNTMgNjE2IDI3MyA2MTYgMjYxIDYxNiBiIDI0MiA2MTYgMjQ3IDYxNiAyNDMgNjE2IGIgMTcwIDQ5OSAxOTMgNjA5IDE4MSA1ODkgYiAxNTkgMzQ4IDE2MyA0NDYgMTU5IDM5OCBiIDE2NiAyMjIgMTU5IDMwOCAxNjEgMjY2IGIgMjAxIDkxIDE3NCAxMzggMTgzIDEwNiBiIDI1NyA3NiAyMTUgODEgMjM1IDc2IGIgMzExIDkxIDI3NyA3NiAyOTkgODEgYiAzNDcgMjIyIDMzMCAxMDYgMzM4IDEzOCBiIDM1MyAzNDggMzUyIDI2NiAzNTMgMzA4IGIgMzQ0IDQ5OSAzNTMgMzk4IDM1MSA0NDYgYiAyNzcgNjE0IDMzMyA1ODcgMzIyIDYwNiBtIDI1NyAtMSBsIDI1OCAtMSBsIDI1NSAtMSBsIDI1NyAtMSBtIDI1NyA2NzMgbCAyNTggNjczIGwgMjU1IDY3MyBsIDI1NyA2NzMgXCJ9LFwidjFcIjp7XCJ4X21pblwiOi0xLjM1OTM3NSxcInhfbWF4XCI6MzQ0LjM1OTM3NSxcImhhXCI6MzUxLFwib1wiOlwibSAxMjYgNjM3IGwgMTI5IDYzOCBsIDE5OCA2MzggbCAyNjYgNjM4IGwgMjY5IDYzNSBiIDI3NCA2MzEgMjcyIDYzNCAyNzMgNjMyIGwgMjc3IDYyNyBsIDI3NyAzOTUgYiAyNzkgMTU2IDI3NyAyMzAgMjc3IDE2MSBiIDMyOSA4OCAyODEgMTIzIDI5NSAxMDYgYiAzNDQgNjkgMzQxIDgxIDM0NCA3OSBiIDMzNyA1NSAzNDQgNjIgMzQzIDU5IGwgMzMzIDU0IGwgMTk3IDU0IGwgNjEgNTQgbCA1OCA1NSBiIDUwIDY5IDUzIDU5IDUwIDYyIGIgNjUgODggNTAgNzkgNTMgODEgYiA4MCA5NyA3MiA5MSA3NCA5MyBiIDExNyAxNTYgMTAzIDExMyAxMTIgMTI5IGIgMTE3IDM0NSAxMTcgMTYxIDExNyAyMjIgbCAxMTcgNTI4IGwgMTAwIDUwMyBsIDM4IDQwNiBiIDE0IDM4MyAyNCAzODQgMjMgMzgzIGIgLTEgMzk4IDUgMzgzIC0xIDM5MCBiIDQgNDE1IC0xIDQwMyAxIDQwOSBiIDE2IDQzNyA1IDQxNiAxMCA0MjYgbCA3MiA1MzkgbCAxMDAgNTk2IGIgMTIxIDYzMiAxMTkgNjMxIDExOSA2MzEgYiAxMjYgNjM3IDEyMiA2MzQgMTI1IDYzNSBtIDE3MSAtMSBsIDE3MiAtMSBsIDE3MCAtMSBsIDE3MSAtMSBtIDE3MSA2NzMgbCAxNzIgNjczIGwgMTcwIDY3MyBsIDE3MSA2NzMgXCJ9LFwidjJcIjp7XCJ4X21pblwiOi0xLjM1OTM3NSxcInhfbWF4XCI6NDU4LjY4NzUsXCJoYVwiOjQ2OCxcIm9cIjpcIm0gMTk3IDY0OCBiIDIxNiA2NDggMjAxIDY0OCAyMDggNjQ4IGIgMjU4IDY0NiAyMzIgNjQ4IDI1MyA2NDggYiA0MTkgNTQ2IDMzMyA2MzcgMzkzIDU5OSBiIDQzMiA0ODkgNDI4IDUyOCA0MzIgNTA5IGIgMzU2IDM0MiA0MzIgNDQwIDQwNSAzODQgYiAyMzUgMjc4IDMyMiAzMTMgMjg4IDI5NSBiIDY5IDE3MCAxNjYgMjU2IDEwNyAyMTcgYiA2OSAxNjkgNjkgMTcwIDY5IDE2OSBiIDY5IDE2OSA2OSAxNjkgNjkgMTY5IGIgNzQgMTczIDY5IDE2OSA3MiAxNzAgYiAyMDkgMjIyIDExMiAyMDQgMTYzIDIyMiBiIDMxMCAxOTUgMjQ3IDIyMiAyNzQgMjE1IGIgMzcxIDE3OSAzMzIgMTg0IDM1MiAxNzkgYiAzOTYgMTgxIDM3OSAxNzkgMzg3IDE3OSBiIDQyOCAyMDIgNDA5IDE4NCA0MjMgMTk0IGIgNDQyIDIxMiA0MzEgMjA5IDQzNiAyMTIgYiA0NTggMTk3IDQ1MCAyMTIgNDU4IDIwNiBiIDQ0MSAxNDggNDU4IDE5MCA0NDkgMTY1IGIgMjk5IDQ0IDQwOSA4NCAzNTMgNDQgYiAyODggNDUgMjk1IDQ0IDI5MiA0NCBiIDI1MCA2MSAyNzQgNDUgMjY4IDQ5IGIgMTIyIDk5IDIxMiA4NiAxNjQgOTkgYiA3MyA5MSAxMDQgOTkgODggOTcgYiAyOCA2MyA1MyA4NCAzNCA3MiBiIDE0IDU0IDI1IDU2IDIwIDU0IGIgMSA2MiA5IDU0IDQgNTYgbCAtMSA2NSBsIC0xIDc5IGIgMCA5OSAtMSA5MSAwIDk1IGIgMiAxMTMgMSAxMDIgMiAxMDggYiAxNjQgMzA5IDIwIDE5NyA4MSAyNzIgYiAyODUgNDcwIDIzMiAzNDEgMjc3IDM5OCBiIDI4NyA0ODcgMjg3IDQ3NiAyODcgNDgxIGIgMTcxIDU5NSAyODcgNTUxIDIzOSA1OTUgYiAxNTUgNTk1IDE2NiA1OTUgMTYwIDU5NSBiIDE0MiA1OTIgMTQ1IDU5NCAxNDIgNTk0IGIgMTQ1IDU4OSAxNDIgNTkyIDE0MiA1OTEgYiAxNzkgNTI3IDE2OCA1NzYgMTc5IDU1MSBiIDEzMiA0NTUgMTc5IDQ5NiAxNjMgNDY3IGIgMTA0IDQ1MSAxMjIgNDUyIDExMiA0NTEgYiAyNyA1MzAgNjIgNDUxIDI3IDQ4NyBiIDI5IDU1NSAyNyA1MzggMjcgNTQ2IGIgMTk3IDY0OCA0NCA2MDEgMTE1IDYzOSBtIDIyOCAtMSBsIDIzMCAtMSBsIDIyNyAtMSBsIDIyOCAtMSBtIDIyOCA2NzMgbCAyMzAgNjczIGwgMjI3IDY3MyBsIDIyOCA2NzMgXCJ9LFwidjNcIjp7XCJ4X21pblwiOi0xLjM1OTM3NSxcInhfbWF4XCI6NDA5LjY4NzUsXCJoYVwiOjQxOCxcIm9cIjpcIm0gMTc0IDY0OCBiIDE5MSA2NDggMTc2IDY0OCAxODMgNjQ4IGIgMjI1IDY0OCAyMDQgNjQ4IDIyMCA2NDggYiA0MDIgNTIzIDMxNyA2MzggMzg5IDU4OCBiIDQwNCA1MDMgNDA0IDUxNyA0MDQgNTEwIGIgNDAyIDQ4NCA0MDQgNDk1IDQwNCA0ODggYiAyNjQgMzczIDM4OSA0MzcgMzM0IDM5NCBiIDI1NyAzNzAgMjU5IDM3MSAyNTcgMzcxIGIgMjU3IDM3MCAyNTcgMzcwIDI1NyAzNzAgYiAyNjQgMzY5IDI1OCAzNzAgMjYxIDM2OSBiIDQwOSAyMDIgMzU5IDMzNCA0MDkgMjY3IGIgMzE4IDcyIDQwOSAxNTIgMzgxIDEwNCBiIDIwMCA0MyAyODEgNTIgMjQwIDQzIGIgMjMgMTEzIDEzNCA0MyA2OSA2OCBiIDAgMTY5IDYgMTI5IDAgMTQ5IGIgNzcgMjQ5IDAgMjEwIDI5IDI0OSBsIDc3IDI0OSBiIDE1MiAxNzQgMTI1IDI0OSAxNTIgMjEyIGIgMTAzIDEwMiAxNTIgMTQ1IDEzNyAxMTYgYiAxMDMgMTAyIDEwMyAxMDIgMTAzIDEwMiBiIDE0NyA5NCAxMDMgMTAxIDEzMiA5NSBiIDE1MyA5NCAxNDkgOTQgMTUxIDk0IGIgMjY1IDIwNiAyMTkgOTQgMjY1IDE0MSBiIDI2NCAyMjYgMjY1IDIxMyAyNjUgMjE5IGIgMTQ3IDM1NSAyNTMgMjk5IDIwNCAzNTMgYiAxMjYgMzcxIDEzMyAzNTYgMTI2IDM2MiBiIDE0NyAzODggMTI2IDM4MyAxMzIgMzg4IGIgMjU0IDQ3NCAxOTYgMzkxIDIzOCA0MjQgYiAyNTkgNTAyIDI1OCA0ODQgMjU5IDQ5NCBiIDE4MiA1OTIgMjU5IDU0NCAyMjggNTgyIGIgMTU2IDU5NSAxNzUgNTk1IDE2NiA1OTUgYiAxMTUgNTkyIDE0MiA1OTUgMTI5IDU5NCBsIDExMSA1OTEgbCAxMTUgNTg4IGIgMTUyIDUyNCAxNDEgNTc0IDE1MiA1NDkgYiA5MiA0NDkgMTUyIDQ5MSAxMzAgNDU4IGIgNzYgNDQ4IDg3IDQ0OCA4MSA0NDggYiAtMSA1MzAgMzIgNDQ4IC0xIDQ4OCBiIDIwIDU4MSAtMSA1NDggNSA1NjYgYiAxNzQgNjQ4IDU1IDYxOSAxMDggNjQxIG0gMjA0IC0xIGwgMjA1IC0xIGwgMjAyIC0xIGwgMjA0IC0xIG0gMjA0IDY3MyBsIDIwNSA2NzMgbCAyMDIgNjczIGwgMjA0IDY3MyBcIn0sXCJ2NFwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NDY4LjIxODc1LFwiaGFcIjo0NzgsXCJvXCI6XCJtIDE3NCA2MzcgYiAyMzIgNjM4IDE3NSA2MzggMTg5IDYzOCBiIDI3NyA2MzggMjQ1IDYzOCAyNTkgNjM4IGwgMzc4IDYzOCBsIDM4MSA2MzUgYiAzODkgNjIzIDM4NiA2MzIgMzg5IDYyNyBiIDM4MiA2MDkgMzg5IDYxNyAzODYgNjEzIGIgMzY2IDU4OSAzODEgNjA2IDM3MiA1OTggbCAzMTMgNTI4IGwgMjQ1IDQ1MSBsIDIwOSA0MTAgbCAxNTUgMzQ4IGwgODQgMjY3IGIgNTkgMjQwIDcyIDI1MiA1OSAyNDAgYiA1OSAyNDAgNTkgMjQwIDU5IDI0MCBiIDE1MSAyMzggNTkgMjM4IDY4IDIzOCBsIDI0MiAyMzggbCAyNDIgMzAzIGIgMjQzIDM3MSAyNDIgMzY5IDI0MiAzNzAgYiAyODkgNDI2IDI0NSAzNzQgMjU0IDM4NSBsIDMwMyA0NDEgbCAzMTcgNDU2IGwgMzM4IDQ4MyBsIDM2MCA1MDYgbCAzNzEgNTIwIGIgMzg2IDUyNyAzNzUgNTI2IDM4MSA1MjcgYiA0MDAgNTE5IDM5MiA1MjcgMzk3IDUyNCBiIDQwMSA0NDAgNDAxIDUxNiA0MDEgNTE0IGIgNDAxIDM3NyA0MDEgNDIzIDQwMSA0MDIgbCA0MDEgMjM4IGwgNDI2IDIzOCBiIDQ1MyAyMzcgNDQ5IDIzOCA0NTAgMjM4IGIgNDY1IDIxNyA0NjEgMjM0IDQ2NSAyMjYgYiA0NjAgMjAyIDQ2NSAyMTIgNDY0IDIwNiBiIDQyNiAxOTcgNDU0IDE5NyA0NTMgMTk3IGwgNDAxIDE5NyBsIDQwMSAxODAgYiA0NTEgODggNDAyIDEyOSA0MTIgMTA5IGIgNDY4IDY5IDQ2NSA4MSA0NjggNzkgYiA0NjEgNTUgNDY4IDYyIDQ2NiA1OSBsIDQ1OCA1NCBsIDMyMSA1NCBsIDE4NSA1NCBsIDE4MiA1NSBiIDE3NSA2OSAxNzYgNTkgMTc1IDYyIGIgMTkxIDg4IDE3NSA3OSAxNzYgODEgYiAyNDAgMTgwIDIzMCAxMDkgMjQwIDEyOSBsIDI0MCAxOTcgbCAxMjUgMTk3IGIgNzMgMTk1IDEwNCAxOTUgODcgMTk1IGIgOCAxOTcgMTAgMTk1IDkgMTk3IGIgMCAyMTIgMiAxOTkgMCAyMDUgYiAwIDIxMiAwIDIxMiAwIDIxMiBiIDIwIDI0MiAwIDIxOSAwIDIxOSBiIDE2MyA2MTAgMTA0IDM0NCAxNjMgNDkyIGIgMTc0IDYzNyAxNjMgNjI4IDE2NiA2MzQgbSAyMzQgLTEgbCAyMzUgLTEgbCAyMzIgLTEgbCAyMzQgLTEgbSAyMzQgNjczIGwgMjM1IDY3MyBsIDIzMiA2NzMgbCAyMzQgNjczIFwifSxcInY1XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0MDkuNjg3NSxcImhhXCI6NDE4LFwib1wiOlwibSA0NyA2MzcgYiA1MyA2MzggNDkgNjM4IDUwIDYzOCBiIDY5IDYzNCA1NSA2MzggNjEgNjM3IGIgMjEwIDYxMCAxMTQgNjE5IDE2MSA2MTAgYiAzNjMgNjM0IDI1OSA2MTAgMzExIDYxOSBiIDM4MiA2MzggMzcyIDYzNyAzNzggNjM4IGIgMzkyIDYzNCAzODYgNjM4IDM4OSA2MzcgYiAzOTcgNjIzIDM5NiA2MzAgMzk3IDYyNyBiIDM5MyA2MTAgMzk3IDYyMCAzOTYgNjE2IGIgMjk4IDUwNSAzNjggNTUyIDMzOCA1MjAgYiAyMTIgNDk0IDI3NyA0OTggMjQ2IDQ5NCBiIDY1IDUxNyAxNjMgNDk0IDEwNiA1MDIgYiA2MSA1MTcgNjIgNTE3IDYxIDUxNyBiIDYxIDUxNyA2MSA1MTcgNjEgNTE3IGIgNTEgNDA4IDYxIDUxNyA1MSA0MTIgYiA1MSA0MDggNTEgNDA4IDUxIDQwOCBiIDUxIDQwOCA1MSA0MDggNTEgNDA4IGIgNjEgNDEyIDUzIDQwOCA1NSA0MDkgYiAxMjUgNDM0IDgwIDQyMSAxMDMgNDMwIGIgMTg1IDQ0MSAxNDUgNDQwIDE2NiA0NDEgYiA0MDkgMjQ0IDMxMCA0NDEgNDA5IDM1MyBiIDQwMSAxOTEgNDA5IDIyNyA0MDYgMjA5IGIgMTk3IDQzIDM3NSAxMDUgMjg3IDQzIGIgMTU5IDQ3IDE4MyA0MyAxNzEgNDQgYiAyMyAxMjMgMTEyIDU2IDYxIDg2IGIgMCAxODAgNiAxNDAgMCAxNTkgYiA3NiAyNjAgMCAyMjAgMzEgMjYwIGIgOTIgMjU5IDgxIDI2MCA4NyAyNTkgYiAxNTIgMTgzIDEzMiAyNTEgMTUyIDIxNiBiIDEwMCAxMTIgMTUyIDE1MiAxMzQgMTIyIGIgOTUgMTExIDk4IDExMiA5NSAxMTEgYiA5NSAxMTEgOTUgMTExIDk1IDExMSBiIDEyOSA5OCA5NSAxMDkgMTE5IDEwMSBiIDE0OCA5NyAxMzYgOTcgMTQxIDk3IGIgMjY0IDIzNSAyMDYgOTcgMjYxIDE1OCBiIDI2NSAyNDggMjY1IDI0MCAyNjUgMjQ0IGIgMjEwIDM5OCAyNjUgMzEyIDI0MyAzNzMgYiAxNzkgNDA4IDIwMSA0MDYgMTk0IDQwOCBiIDE3NCA0MDggMTc4IDQwOCAxNzYgNDA4IGIgNTMgMzY5IDEzMCA0MDggODggMzk0IGIgMzQgMzU5IDM5IDM1OSAzOCAzNTkgYiAxNyAzNzQgMjQgMzU5IDE3IDM2NSBiIDM5IDYyOCAxNyAzODQgMzggNjI1IGIgNDcgNjM3IDQwIDYzMSA0MyA2MzUgbSAyMDQgLTEgbCAyMDUgLTEgbCAyMDIgLTEgbCAyMDQgLTEgbSAyMDQgNjczIGwgMjA1IDY3MyBsIDIwMiA2NzMgbCAyMDQgNjczIFwifSxcInY2XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0NzUuMDMxMjUsXCJoYVwiOjQ4NSxcIm9cIjpcIm0gMjU1IDY0OCBiIDI3NCA2NDggMjU5IDY0OCAyNjYgNjQ4IGIgMzE0IDY0NiAyODggNjQ4IDMwNyA2NDggYiA0NTAgNTU1IDM3NCA2MzcgNDM4IDU5NCBiIDQ1NCA1MzAgNDUzIDU0NiA0NTQgNTM4IGIgMzc1IDQ1MSA0NTQgNDg1IDQxNiA0NTEgYiAzMjggNDY3IDM1OSA0NTEgMzQzIDQ1NSBiIDMwMCA1MjYgMzEwIDQ4MyAzMDAgNTAzIGIgMzUyIDU5OCAzMDAgNTU3IDMxOSA1ODkgYiAzNTYgNTk5IDM1NSA1OTggMzU2IDU5OSBiIDM1MiA2MDIgMzU2IDU5OSAzNTUgNjAxIGIgMjg4IDYxNiAzMzAgNjEyIDMwOCA2MTYgYiAyMTAgNTg0IDI1NyA2MTYgMjMwIDYwNSBiIDE2NCA0MzMgMTg5IDU1OSAxNzQgNTA4IGIgMTYwIDM3NCAxNjMgNDE1IDE2MCAzODEgYiAxNjAgMzc0IDE2MCAzNzQgMTYwIDM3NCBiIDE2MCAzNzQgMTYwIDM3NCAxNjAgMzc0IGIgMTY4IDM3NyAxNjAgMzc0IDE2NCAzNzYgYiAyNTggMzk1IDIwMCAzOTAgMjI4IDM5NSBiIDM2NiAzNjcgMjk0IDM5NSAzMjggMzg3IGIgNDc1IDIyMyA0MzYgMzMzIDQ3NSAyODMgYiA0NzIgMTk3IDQ3NSAyMTUgNDczIDIwNiBiIDM0OSA2NSA0NjIgMTQxIDQxOSA5NSBiIDI1OSA0MyAzMTcgNTEgMjg4IDQzIGIgMTY3IDY5IDIzMCA0MyAyMDAgNTIgYiA0IDI5MCA4MCAxMTMgMjAgMTk1IGIgMCAzNDkgMSAzMDkgMCAzMjggYiAyMCA0NjcgMCAzOTEgNiA0MzMgYiAyNTUgNjQ4IDU4IDU2MyAxNTUgNjM3IG0gMjY5IDM2MyBiIDI1NyAzNjMgMjY1IDM2MyAyNjEgMzYzIGIgMjEwIDM0NSAyMzYgMzYzIDIyMCAzNTYgYiAxODYgMjI2IDE5NiAzMjQgMTg2IDI3MiBiIDE4NyAxOTggMTg2IDIxNiAxODYgMjA2IGIgMjEzIDk1IDE5MSAxNTEgMjAyIDExMiBiIDI1NyA3NiAyMjEgODMgMjM4IDc2IGIgMjcwIDc3IDI2MSA3NiAyNjYgNzYgYiAzMjEgMTU2IDI5OSA4MSAzMTAgOTkgYiAzMjkgMjI5IDMyNiAxODMgMzI5IDIwNiBiIDMyMSAzMDEgMzI5IDI1MiAzMjYgMjc0IGIgMjY5IDM2MyAzMTEgMzQyIDI5OCAzNTkgbSAyMzYgLTEgbCAyMzggLTEgbCAyMzUgLTEgbCAyMzYgLTEgbSAyMzYgNjczIGwgMjM4IDY3MyBsIDIzNSA2NzMgbCAyMzYgNjczIFwifSxcInY3XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0NDIuMzU5Mzc1LFwiaGFcIjo0NTEsXCJvXCI6XCJtIDE0NyA2NDggYiAxNjYgNjQ5IDE1MyA2NDkgMTYwIDY0OSBiIDMxMyA1OTggMjE3IDY0OSAyNzMgNjMwIGIgMzQwIDU4NyAzMjMgNTg4IDMyOCA1ODcgbCAzNDEgNTg3IGIgNDEyIDYyOCAzNjcgNTg3IDM5MCA2MDEgYiA0MjcgNjM4IDQxNiA2MzUgNDIxIDYzOCBiIDQzOSA2MzIgNDMxIDYzOCA0MzUgNjM3IGIgNDQyIDYyMyA0NDEgNjMwIDQ0MiA2MjggYiA0MzAgNTY5IDQ0MiA2MTYgNDM5IDYwMyBiIDM1MiAzNjkgNDA4IDQ5MiAzNzcgNDEwIGIgMzAwIDI1OSAzMjUgMzI0IDMxMyAyOTggYiAyNzMgODQgMjgzIDIwNSAyNzMgMTQwIGIgMjY1IDU1IDI3MyA2NSAyNzIgNTkgbCAyNjEgNTQgbCAxODEgNTQgbCA5OSA1NCBsIDk2IDU1IGIgOTEgNjEgOTUgNTYgOTIgNTkgbCA4OSA2MyBsIDg5IDc3IGIgMTQ3IDI2MyA4OSAxMzMgMTExIDIwMiBiIDI2MSA0MDEgMTc2IDMxMyAyMTIgMzU1IGIgMzc4IDU0MSAzMTUgNDQ5IDM0OSA0ODkgbCAzODIgNTQ4IGwgMzc1IDU0NCBiIDI0MCA0OTUgMzMzIDUxMiAyODUgNDk1IGIgMTI5IDUzNSAxOTggNDk1IDE2MCA1MDkgYiA4NCA1NjAgMTA4IDU1MiA5NSA1NjAgYiA3NiA1NTkgODEgNTYwIDc4IDU2MCBiIDMxIDQ4NyA1OSA1NTUgNDMgNTMwIGIgMTQgNDcwIDI3IDQ3MyAyNCA0NzAgYiAxIDQ3NyA4IDQ3MCA0IDQ3MSBsIDAgNDgwIGwgMCA1NTMgbCAwIDYyNyBsIDEgNjMwIGIgMTYgNjM4IDQgNjM1IDkgNjM4IGIgMjMgNjM1IDE3IDYzOCAyMCA2MzcgYiA0OSA2MjYgMzYgNjI2IDM5IDYyNiBiIDk2IDYzOCA1OSA2MjYgODAgNjMwIGIgMTA0IDYzOSA5OSA2MzggMTAyIDYzOSBiIDExNyA2NDQgMTA3IDY0MSAxMTIgNjQyIGIgMTQ3IDY0OCAxMjUgNjQ1IDEzNyA2NDggbSAyMjAgLTEgbCAyMjEgLTEgbCAyMTkgLTEgbCAyMjAgLTEgbSAyMjAgNjczIGwgMjIxIDY3MyBsIDIxOSA2NzMgbCAyMjAgNjczIFwifSxcInY4XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0ODguNjQwNjI1LFwiaGFcIjo0OTksXCJvXCI6XCJtIDIxNyA2NDggYiAyNDUgNjQ5IDIyNSA2NDggMjM1IDY0OSBiIDQ1MyA1MTYgMzQzIDY0OSA0MzAgNTk1IGIgNDU4IDQ3OCA0NTUgNTAzIDQ1OCA0OTEgYiA0MTIgMzcwIDQ1OCA0NDAgNDQxIDM5OCBiIDQxMSAzNjkgNDEyIDM2OSA0MTEgMzY5IGIgNDE1IDM2NSA0MTEgMzY3IDQxMiAzNjcgYiA0ODggMjMxIDQ2MiAzMzEgNDg4IDI4MSBiIDQ3MiAxNjUgNDg4IDIwOCA0ODMgMTg2IGIgMjQzIDQzIDQzNCA4NiAzMzggNDMgYiA2MyAxMDQgMTc4IDQzIDExMiA2MiBiIDAgMjMzIDIwIDE0MCAwIDE4NiBiIDczIDM2NSAwIDI4MyAyNCAzMzEgbCA3NyAzNjkgbCA3MiAzNzQgYiAyOSA0NzYgNDIgNDA2IDI5IDQ0MSBiIDIxNyA2NDggMjkgNTU3IDEwMyA2MzUgbSAyNTggNjA1IGIgMjQyIDYwNiAyNTMgNjA1IDI0NyA2MDYgYiAxNTcgNTUyIDE5OCA2MDYgMTU3IDU4MCBiIDE2MCA1NDEgMTU3IDU0OCAxNTkgNTQ0IGIgMzE5IDQxMyAxNzYgNTAzIDI0MiA0NTIgbCAzMzcgNDAzIGwgMzM4IDQwNiBiIDM1OSA0NzYgMzUyIDQyOCAzNTkgNDUyIGIgMjU4IDYwNSAzNTkgNTM3IDMxOCA1OTUgbSAxMzggMzI2IGIgMTMwIDMzMCAxMzQgMzI4IDEzMCAzMzAgYiAxMzAgMzMwIDEzMCAzMzAgMTMwIDMzMCBiIDEwNyAzMDUgMTI3IDMzMCAxMTIgMzEzIGIgODQgMjMxIDkxIDI4MSA4NCAyNTYgYiAyNDMgODYgODQgMTU2IDE1MSA4NiBiIDI0OSA4NyAyNDUgODYgMjQ2IDg3IGIgMzQ3IDE1NiAzMDMgODggMzQ3IDEyMCBiIDM0NCAxNzIgMzQ3IDE2MiAzNDUgMTY3IGIgMTU2IDMxOSAzMjUgMjI3IDI1NyAyODEgYiAxMzggMzI2IDE1MSAzMjIgMTQ0IDMyNCBtIDI0MyAtMSBsIDI0NSAtMSBsIDI0MiAtMSBsIDI0MyAtMSBtIDI0MyA2NzMgbCAyNDUgNjczIGwgMjQyIDY3MyBsIDI0MyA2NzMgXCJ9LFwidjlcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ3NS4wMzEyNSxcImhhXCI6NDg1LFwib1wiOlwibSAxOTEgNjQ2IGIgMjEyIDY0OSAxOTggNjQ4IDIwNSA2NDkgYiAyNTUgNjQ0IDIyNyA2NDkgMjQzIDY0NiBiIDQ1OCA0NDggMzQ4IDYxNiA0MjggNTM5IGIgNDc1IDM0MiA0NjkgNDE1IDQ3NSAzNzggYiA0NjAgMjQ0IDQ3NSAzMDggNDY5IDI3NCBiIDE5MyA0NCA0MjEgMTI0IDMwMyA0NCBiIDkxIDY5IDE1NyA0NCAxMjIgNTEgYiAxOSAxNjEgNDMgOTcgMTkgMTI2IGIgMjEgMTgxIDE5IDE2NyAyMCAxNzQgYiA5OCAyNDEgMzIgMjIwIDY1IDI0MSBiIDE3MCAxODYgMTI5IDI0MSAxNjAgMjIzIGIgMTcyIDE2NiAxNzEgMTc5IDE3MiAxNzMgYiAxMjEgOTQgMTcyIDEzNCAxNTIgMTAyIGIgMTE3IDkzIDExOCA5NCAxMTcgOTMgYiAxMjEgOTAgMTE3IDkzIDExOCA5MSBiIDE4NSA3NiAxNDIgODAgMTY0IDc2IGIgMjcwIDExOSAyMjAgNzYgMjUxIDkxIGIgMzA4IDI1OSAyODcgMTQ1IDMwMCAxOTQgYiAzMTMgMzE3IDMxMCAyNzcgMzEzIDMxMCBiIDMxMyAzMTcgMzEzIDMxNyAzMTMgMzE3IGIgMzEzIDMxNyAzMTMgMzE3IDMxMyAzMTcgYiAzMDQgMzE1IDMxMyAzMTcgMzA4IDMxNiBiIDIxNiAyOTUgMjczIDMwMiAyNDUgMjk1IGIgMTQ1IDMwOCAxOTMgMjk1IDE3MCAyOTkgYiAxOSAzOTggODggMzI3IDQyIDM2MCBiIDAgNDY5IDUgNDIwIDAgNDQ0IGIgMjQgNTUxIDAgNDk2IDggNTI2IGIgMTkxIDY0NiA1NCA1OTYgMTI1IDYzNyBtIDIyNyA2MTQgYiAyMTUgNjE2IDIyNCA2MTYgMjIwIDYxNiBiIDIwMiA2MTQgMjEwIDYxNiAyMDYgNjE2IGIgMTUyIDUzNSAxNzQgNjEwIDE2MyA1OTIgYiAxNDQgNDYzIDE0NyA1MDkgMTQ0IDQ4NSBiIDE1MiAzOTEgMTQ0IDQ0MCAxNDcgNDE3IGIgMjE2IDMyOCAxNjMgMzQ0IDE3OSAzMjggYiAyODAgMzkxIDI1MyAzMjggMjY5IDM0NCBiIDI4OCA0NjMgMjg1IDQxNyAyODggNDQwIGIgMjgwIDUzNSAyODggNDg1IDI4NSA1MDkgYiAyMjcgNjE0IDI2OSA1OTQgMjU4IDYxMCBtIDIzNiAtMSBsIDIzOCAtMSBsIDIzNSAtMSBsIDIzNiAtMSBtIDIzNiA2NzMgbCAyMzggNjczIGwgMjM1IDY3MyBsIDIzNiA2NzMgXCJ9LFwidmFcIjp7XCJ4X21pblwiOi0xNDkuNzE4NzUsXCJ4X21heFwiOjE0OC4zNTkzNzUsXCJoYVwiOjE1MSxcIm9cIjpcIm0gLTggLTEgYiAtMSAwIC01IC0xIC00IDAgYiAxNiAtMTEgNSAwIDEzIC00IGIgODMgLTE4NiAxNyAtMTIgNDcgLTkwIGwgMTQ4IC0zNTggbCAxNDggLTM2MyBiIDEyNyAtMzg1IDE0OCAtMzc2IDEzOCAtMzg1IGIgMTEyIC0zNzggMTIyIC0zODUgMTE4IC0zODMgYiA1NCAtMjI2IDExMCAtMzc0IDExNCAtMzg1IGIgMCAtODEgMjQgLTE0NyAwIC04MSBiIC01NSAtMjI2IC0xIC04MSAtMjUgLTE0NyBiIC0xMTQgLTM3OCAtMTE1IC0zODUgLTExMSAtMzc0IGIgLTEyOSAtMzg1IC0xMTkgLTM4MyAtMTIzIC0zODUgYiAtMTQ5IC0zNjMgLTE0MCAtMzg1IC0xNDkgLTM3NiBsIC0xNDkgLTM1OCBsIC04NCAtMTg2IGIgLTE5IC0xMSAtNDkgLTkwIC0xOSAtMTIgYiAtOCAtMSAtMTcgLTggLTEyIC00IFwifSxcInZiXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0MjguNzUsXCJoYVwiOjQzOCxcIm9cIjpcIm0gMjYyIDE4NiBiIDI3MyAxODYgMjY2IDE4NiAyNzIgMTg2IGIgMjc0IDE4NiAyNzMgMTg2IDI3NCAxODYgYiAyODUgMTg2IDI3NCAxODYgMjgwIDE4NiBiIDQyOCA0OCAzNzUgMTgxIDQyOCAxMjIgYiAzODYgLTY4IDQyOCAxMiA0MTYgLTI5IGIgMTU1IC0xODcgMzI5IC0xNDUgMjM2IC0xODcgYiAxMiAtMTExIDkyIC0xODcgMzggLTE2MiBiIDAgLTUxIDQgLTkxIDAgLTcyIGIgMjYyIDE4NiAwIDU4IDEyMiAxNzkgXCJ9LFwidmNcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ0Ny44MTI1LFwiaGFcIjo0NTcsXCJvXCI6XCJtIDAgODYgbCAwIDE3MyBsIDIyMyAxNzMgbCA0NDcgMTczIGwgNDQ3IDg2IGwgNDQ3IDAgbCAyMjMgMCBsIDAgMCBsIDAgODYgXCJ9LFwidmZcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjM3MC4yMTg3NSxcImhhXCI6Mzc4LFwib1wiOlwibSAwIDAgbCAwIDI3NyBsIDYxIDI3NyBsIDEyMiAyNzcgbCAxMjIgMCBsIDEyMiAtMjc4IGwgNjEgLTI3OCBsIDAgLTI3OCBsIDAgMCBtIDI0NiAtMSBsIDI0NiAyNzcgbCAzMDggMjc3IGwgMzcwIDI3NyBsIDM3MCAtMSBsIDM3MCAtMjc4IGwgMzA4IC0yNzggbCAyNDYgLTI3OCBsIDI0NiAtMSBcIn0sXCJ2MTBcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjU1OS40MjE4NzUsXCJoYVwiOjU3MSxcIm9cIjpcIm0gNSAxMjcgYiAxNCAxMjcgNiAxMjcgOSAxMjcgYiA1MSAxMjYgMjUgMTI3IDQzIDEyNyBiIDE3NSA5OCA5MyAxMjIgMTM4IDExMiBsIDE4NiA5NCBiIDI3OSA1MSAyMTAgODYgMjU1IDY1IGIgMjg1IDQ3IDI4MCA1MSAyODMgNDggYiAzMTkgMjcgMjkxIDQ0IDMxMSAzMSBsIDMyNiAyMiBiIDM1OSAwIDMzMiAxOSAzNTIgNCBsIDM2NyAtNiBiIDM3MSAtOSAzNjggLTYgMzcwIC04IGwgMzc5IC0xNSBiIDM4NyAtMjIgMzgzIC0xOCAzODYgLTIwIGwgMzk4IC0zMCBsIDQxMSAtNDAgbCA0MTcgLTQ3IGwgNDI3IC01NSBsIDQzNCAtNjEgYiA0NDEgLTY2IDQzNiAtNjIgNDM5IC02NSBsIDQ0NiAtNzIgbCA0NTMgLTc3IGwgNDYyIC04NyBiIDU1OCAtMTg4IDQ5MCAtMTEzIDU0OSAtMTc2IGIgNTU5IC0xOTUgNTU5IC0xOTEgNTU5IC0xOTQgYiA1NDggLTIwNSA1NTkgLTIwMSA1NTUgLTIwNSBiIDU0MSAtMjA0IDU0NyAtMjA1IDU0NCAtMjA1IGIgNTM0IC0xOTggNTM5IC0yMDEgNTM2IC0xOTkgbCA1MjUgLTE5MSBiIDQ4MSAtMTYyIDUxOCAtMTg3IDQ5MCAtMTY3IGIgNDcyIC0xNTUgNDc3IC0xNTkgNDcyIC0xNTYgYiA0NjggLTE1MiA0NzAgLTE1NSA0NjkgLTE1NCBiIDQ2MSAtMTQ5IDQ2NiAtMTUyIDQ2NCAtMTUxIGIgNDI4IC0xMzAgNDU0IC0xNDUgNDQxIC0xMzcgYiAzNzEgLTk5IDQxMyAtMTIyIDM3MiAtOTkgYiAzNjMgLTk1IDM3MSAtOTkgMzY3IC05OCBiIDM1MyAtOTEgMzU3IC05NCAzNTMgLTkxIGIgMzQ4IC05MCAzNTMgLTkxIDM1MiAtOTEgYiAzMzIgLTgxIDM0MyAtODcgMzQxIC04NiBiIDI3IC0xMiAyMzAgLTM3IDEyNyAtMTMgYiAwIC01IDQgLTExIDIgLTExIGIgMCA1OCAwIC0yIDAgMjcgYiAwIDEyMiAwIDg4IDAgMTIwIGIgNSAxMjcgMSAxMjQgNCAxMjYgXCJ9LFwidjExXCI6e1wieF9taW5cIjotMTU1LjE3MTg3NSxcInhfbWF4XCI6MTUzLjgxMjUsXCJoYVwiOjE1NyxcIm9cIjpcIm0gLTEzNyAzNTMgYiAtMTMwIDM1MyAtMTM2IDM1MyAtMTMzIDM1MyBiIC0xMTIgMzQ5IC0xMjUgMzUzIC0xMTkgMzUyIGIgLTEwMCAzNDIgLTExMCAzNDcgLTEwNCAzNDQgYiAwIDMxNyAtNjkgMzI2IC0zNSAzMTcgYiAxMTEgMzQ5IDM4IDMxNyA3NiAzMjggYiAxMjkgMzUzIDExNyAzNTIgMTIzIDM1MyBiIDE1MyAzMjcgMTQyIDM1MyAxNTMgMzQ0IGIgMTQ0IDMwMiAxNTMgMzIwIDE1MyAzMTcgYiAyNyA2IDkzIDIyNiA1MCAxMTMgYiAyMSAtMTMgMjQgLTExIDI0IC0xMSBiIDAgLTI2IDE3IC0yMiA4IC0yNiBiIC0yNCAtMTIgLTkgLTI2IC0xOSAtMjIgYiAtMjggNSAtMjQgLTkgLTI3IC0yIGIgLTE0NSAzMDIgLTUzIDExNyAtOTUgMjI0IGIgLTE1NSAzMjcgLTE1NSAzMTcgLTE1NSAzMjAgYiAtMTM3IDM1MyAtMTU1IDM0MCAtMTQ4IDM0OSBcIn0sXCJ2MThcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjMyMy45Mzc1LFwiaGFcIjozMzEsXCJvXCI6XCJtIDIxNyA1MzUgYiAyMjUgNTM3IDIyMCA1MzcgMjIxIDUzNyBiIDI0NSA1MjQgMjM1IDUzNyAyNDIgNTMzIGwgMjQ2IDUyMSBsIDI0NyAzOTAgbCAyNDcgMjU4IGwgMjczIDI2NSBiIDMwNiAyNzAgMjg4IDI2OSAyOTkgMjcwIGIgMzIyIDI1OSAzMTUgMjcwIDMxOSAyNjcgYiAzMjMgMjA4IDMyMyAyNTYgMzIzIDIzMyBiIDMyMiAxNTggMzIzIDE4NCAzMjMgMTU5IGIgMjg4IDE0MCAzMTggMTQ4IDMxNSAxNDcgYiAyNDcgMTMwIDI1NCAxMzEgMjQ3IDEzMCBiIDI0NyA2NSAyNDcgMTMwIDI0NyAxMDQgYiAyNDcgMjAgMjQ3IDUxIDI0NyAzNiBsIDI0NyAtODggbCAyNzMgLTgxIGIgMzA2IC03NiAyODkgLTc3IDI5OSAtNzYgYiAzMTggLTgxIDMxMSAtNzYgMzE1IC03NyBiIDMyMyAtMTIzIDMyMyAtODcgMzIzIC04NiBsIDMyMyAtMTM4IGwgMzIzIC0xNTQgYiAzMTggLTE5NSAzMjMgLTE5MSAzMjMgLTE5MCBiIDI2OSAtMjEwIDMxNCAtMTk5IDMxNSAtMTk5IGIgMjQ5IC0yMTYgMjU5IC0yMTMgMjUwIC0yMTYgbCAyNDcgLTIxNiBsIDI0NyAtMzQ5IGwgMjQ2IC00ODMgbCAyNDUgLTQ4NyBiIDIyNSAtNDk5IDI0MiAtNDk1IDIzNCAtNDk5IGIgMjA2IC00ODcgMjE5IC00OTkgMjEwIC00OTUgbCAyMDUgLTQ4MyBsIDIwNSAtMzU1IGwgMjA1IC0yMjcgbCAyMDQgLTIyNyBsIDE4MSAtMjMzIGwgMTM4IC0yNDQgYiAxMTcgLTI0OSAxMjcgLTI0NyAxMTcgLTI0OSBiIDExNSAtMzg1IDExNSAtMjQ5IDExNSAtMjU2IGwgMTE1IC01MjMgbCAxMTQgLTUyNiBiIDk1IC01MzggMTEwIC01MzQgMTAyIC01MzggYiA3NCAtNTI2IDg3IC01MzggNzggLTUzNCBsIDczIC01MjMgbCA3MyAtMzkxIGIgNzIgLTI2MCA3MyAtMjY5IDczIC0yNjAgYiA3MiAtMjYwIDcyIC0yNjAgNzIgLTI2MCBiIDE5IC0yNzMgNjEgLTI2MyAyMyAtMjczIGIgMCAtMjYwIDEwIC0yNzMgNCAtMjY3IGIgMCAtMjA5IDAgLTI1NiAwIC0yNTYgbCAwIC0xNjIgbCAxIC0xNTggYiA2MSAtMTM0IDUgLTE0OCA1IC0xNDggbCA3MyAtMTMxIGwgNzMgLTIyIGIgNzIgODYgNzMgNzkgNzMgODYgYiA3MiA4NiA3MiA4NiA3MiA4NiBiIDE5IDc0IDYxIDgzIDIzIDc0IGIgMCA4NiAxMCA3NCA0IDc5IGIgMCAxMzcgMCA5MCAwIDkwIGwgMCAxODQgbCAxIDE4OCBiIDYxIDIxMiA1IDE5OCA1IDE5OCBsIDczIDIxNSBsIDczIDM0OCBsIDczIDQ4MSBsIDc0IDQ4NSBiIDk1IDQ5OCA3OCA0OTIgODcgNDk4IGIgMTAzIDQ5NSA5OCA0OTggMTAwIDQ5NiBiIDExNCA0ODUgMTA3IDQ5NCAxMTEgNDg5IGwgMTE1IDQ4MSBsIDExNSAzNTMgbCAxMTUgMjI2IGwgMTIxIDIyNiBiIDE1OSAyMzUgMTIzIDIyNyAxNDEgMjMxIGwgMTk4IDI0NyBsIDIwNSAyNDggbCAyMDUgMzg0IGwgMjA1IDUyMSBsIDIwNiA1MjQgYiAyMTcgNTM1IDIwOSA1MjggMjEyIDUzMyBtIDIwNSA5IGIgMjA1IDExOSAyMDUgNzAgMjA1IDExOSBsIDIwNSAxMTkgYiAxODIgMTEzIDIwNCAxMTkgMTk0IDExNiBsIDEzOCAxMDIgYiAxMTcgOTcgMTI3IDk5IDExNyA5NyBiIDExNSAtMTIgMTE1IDk3IDExNSA5MSBsIDExNSAtMTIyIGwgMTIxIC0xMjAgYiAxNTkgLTExMSAxMjMgLTExOSAxNDEgLTExNSBsIDE5OCAtMTAxIGwgMjA1IC05OCBsIDIwNSA5IFwifSxcInYxYlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NTU5LjQyMTg3NSxcImhhXCI6NTcxLFwib1wiOlwibSA1NDQgMjA0IGIgNTQ4IDIwNCA1NDUgMjA0IDU0NyAyMDQgYiA1NTkgMTk0IDU1NSAyMDQgNTU5IDE5OSBiIDU1OSAxOTAgNTU5IDE5MiA1NTkgMTkxIGIgNTMwIDE1NiA1NTkgMTg4IDU1NiAxODQgYiA0NjIgODYgNTEwIDEzNCA0ODEgMTA0IGIgNDUzIDc2IDQ1OCA4MSA0NTQgNzcgbCA0NDYgNzAgbCA0NDEgNjUgYiA0MzQgNTkgNDM5IDYzIDQzNiA2MSBsIDQyNyA1NCBiIDQwOSAzNyA0MjYgNTEgNDE2IDQ0IGIgMzkyIDIzIDM5OCAyOSAzOTQgMjYgYiAzODcgMTkgMzg5IDIyIDM4NyAyMCBiIDM3OSAxMyAzODYgMTkgMzgzIDE2IGwgMzcxIDggbCAzNjcgNSBsIDM1OSAtMSBsIDMzNyAtMTYgYiAyODUgLTQ4IDMxOSAtMjkgMjk4IC00MSBsIDI3OSAtNTIgYiAxODYgLTk1IDI1NSAtNjYgMjEwIC04NyBsIDE3NSAtOTkgYiAyMyAtMTI5IDEyNyAtMTE3IDY4IC0xMjkgYiAxNyAtMTI5IDIwIC0xMjkgMTkgLTEyOSBiIDEgLTEyMyAyIC0xMjkgMiAtMTI5IGIgMCAtNDkgMCAtMTIyIDAgLTgzIGIgMCA0IDAgLTIyIDAgMSBiIDI3IDExIDIgOSA0IDkgYiAxODUgMzEgNzggMTIgMTQ1IDIwIGIgMTk4IDM0IDE4NiAzMSAxOTMgMzMgYiAzMTQgNzMgMjM0IDQ0IDI3NyA1OCBiIDM0OSA4OCAzMjggNzkgMzQwIDg0IGIgMzUzIDkwIDM1MiA5MCAzNTMgOTAgYiAzNjMgOTQgMzUzIDkwIDM1NyA5MyBiIDM3MSA5OCAzNjcgOTcgMzcxIDk4IGIgNDI4IDEyOSAzNzIgOTggNDEzIDEyMCBiIDQ2MSAxNDggNDQxIDEzNiA0NTQgMTQ0IGIgNDY4IDE1MSA0NjQgMTQ5IDQ2NiAxNTEgYiA0NzIgMTU0IDQ2OSAxNTIgNDcwIDE1NCBiIDQ4MSAxNjEgNDczIDE1NSA0NzcgMTU4IGIgNTI1IDE5MCA0OTAgMTY2IDUxOCAxODYgbCA1MzQgMTk3IGIgNTQwIDIwMSA1MzYgMTk4IDUzOSAxOTkgYiA1NDQgMjA0IDU0MSAyMDIgNTQ0IDIwNCBcIn0sXCJ2MWRcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjYxOS4zMTI1LFwiaGFcIjo2MzIsXCJvXCI6XCJtIDI3NCAxODQgYiAzMDcgMTg2IDI4NSAxODYgMjk2IDE4NiBiIDYxNiAyMiA0NjUgMTg2IDU5NyAxMTYgYiA2MTkgLTEgNjE3IDEzIDYxOSA1IGIgMzA4IC0xODcgNjE5IC0xMDQgNDgzIC0xODcgYiAwIC0xIDEzMyAtMTg3IDAgLTEwMiBiIDUgMzYgMCAxMSAxIDIzIGIgMjc0IDE4NCAyOSAxMTUgMTQxIDE3NiBtIDI4OSAxNjEgYiAyNzIgMTYyIDI4NCAxNjIgMjc3IDE2MiBiIDE3MSA0MSAyMDkgMTYyIDE3MSAxMDggYiAyMDUgLTczIDE3MSA1IDE4MiAtMzQgYiAzNDUgLTE2MyAyNDMgLTEzMyAyOTggLTE2MyBiIDQzNiAtOTggMzg1IC0xNjMgNDIwIC0xNDIgYiA0NDYgLTQzIDQ0MyAtODAgNDQ2IC02MiBiIDI4OSAxNjEgNDQ2IDQ3IDM3NyAxNDcgXCJ9LFwidjFlXCI6e1wieF9taW5cIjotNDAyLjg5MDYyNSxcInhfbWF4XCI6NDAxLjUzMTI1LFwiaGFcIjo0MTAsXCJvXCI6XCJtIC0yMTkgMTczIGIgLTIxMyAxNzQgLTIxNyAxNzQgLTIxNSAxNzQgYiAtMjAyIDE3MyAtMjA5IDE3NCAtMjA1IDE3MyBiIC0xMTQgODYgLTIwMCAxNzIgLTE3OSAxNTEgYiAtMjggMCAtNjYgMzcgLTI4IDAgYiA0MCA4NCAtMjggMCAyIDM3IGIgMTE3IDE3NCAxMTEgMTczIDExMCAxNzIgYiAxMjIgMTc0IDExOCAxNzQgMTE5IDE3NCBiIDEzMiAxNzMgMTI1IDE3NCAxMjkgMTczIGIgMjk1IDExIDEzNCAxNzIgMTcxIDEzNCBsIDMwNyAtMSBsIDMzNiAzNCBiIDM3NCA3NiAzNjYgNzIgMzY4IDc0IGIgMzgxIDc3IDM3NSA3NyAzNzggNzcgYiA0MDEgNTYgMzkyIDc3IDQwMSA2OCBiIDQwMCA0OCA0MDEgNTQgNDAxIDUxIGIgMjIzIC0xNzIgMzk3IDQxIDIzMCAtMTY2IGIgMjEwIC0xNzYgMjIwIC0xNzQgMjE1IC0xNzYgYiAyMDEgLTE3NCAyMDYgLTE3NiAyMDQgLTE3NiBiIDExMiAtODcgMTk4IC0xNzMgMTc4IC0xNTIgYiAyNyAwIDY1IC0zOCAyNyAwIGIgLTQyIC04NiAyNyAwIC00IC0zOCBiIC0xMTggLTE3NCAtMTEyIC0xNzQgLTExMSAtMTczIGIgLTEyMyAtMTc2IC0xMTkgLTE3NiAtMTIxIC0xNzYgYiAtMTMzIC0xNzQgLTEyNiAtMTc2IC0xMzAgLTE3NCBiIC0yOTYgLTEyIC0xMzYgLTE3MyAtMTcyIC0xMzcgbCAtMzA4IDAgbCAtMzM3IC0zNCBiIC0zNzUgLTc3IC0zNjcgLTczIC0zNzAgLTc2IGIgLTM4MiAtNzkgLTM3NyAtNzkgLTM3OSAtNzkgYiAtNDAyIC01OCAtMzkzIC03OSAtNDAyIC02OSBiIC00MDEgLTQ5IC00MDIgLTU1IC00MDIgLTUyIGIgLTIyNCAxNzIgLTM5OCAtNDMgLTIyOCAxNjcgYiAtMjE5IDE3MyAtMjIzIDE3MiAtMjIwIDE3MyBcIn0sXCJ2MWZcIjp7XCJ4X21pblwiOi0zNDAuMjgxMjUsXCJ4X21heFwiOjMzOC45MjE4NzUsXCJoYVwiOjM0NixcIm9cIjpcIm0gLTMyIDUyMCBiIC0yOSA1MjEgLTMxIDUyMCAtMzEgNTIxIGIgLTIzIDUxOSAtMjcgNTIxIC0yNCA1MjAgYiAtMjAgNTEzIC0yMSA1MTcgLTIwIDUxNiBiIC0yMSA1MDYgLTIwIDUxMiAtMjAgNTA5IGIgLTMxIDQ3NCAtMjMgNTAyIC0yNyA0ODggbCAtNTMgNDAyIGwgLTY2IDM1MiBsIC02OCAzNDkgbCAtNTcgMzQ5IGIgLTMyIDM1MSAtNTEgMzQ5IC00MCAzNTEgYiAxMjMgMzcwIDE5IDM1MiA3NCAzNTkgYiAxMzcgMzcxIDEyNyAzNzAgMTMzIDM3MSBiIDE3MCAzNTYgMTUyIDM3MSAxNjQgMzY2IGIgMTcxIDM1NSAxNzAgMzU1IDE3MCAzNTUgYiAyMTYgMzY2IDE3NCAzNTUgMTgzIDM1OCBiIDI4MCAzNzggMjY4IDM3NyAyNjYgMzc3IGIgMjg3IDM3OCAyODMgMzc4IDI4NCAzNzggYiAzMzIgMzQ5IDMwNyAzNzggMzIyIDM2OSBiIDMzOCAzMTkgMzM2IDM0MSAzMzggMzMwIGIgMzMyIDMwMSAzMzggMzEwIDMzNiAzMDIgYiAyNDIgMjgwIDMyOSAyOTkgMjQ2IDI4MCBiIDI0MiAyODAgMjQyIDI4MCAyNDIgMjgwIGIgMjM1IDI4OCAyMzYgMjgwIDIzNSAyODMgYiAyMzUgMjkyIDIzNSAyOTAgMjM1IDI5MSBiIDIzNiAzMDIgMjM2IDI5NyAyMzYgMjk5IGIgMjIwIDMzNyAyMzYgMzE2IDIzMCAzMzAgbCAyMTYgMzQwIGwgMjEwIDMzNSBiIDE1OSAyNzYgMTg5IDMyMiAxNzIgMzAxIGIgMTE4IDE0OSAxNTIgMjY1IDE1NiAyNzQgYiA4MSAzNCA4NCAzNiA4NSAzNiBiIC04IDEzIDc4IDMzIC00IDEzIGIgLTggMTMgLTggMTMgLTggMTMgYiAtMTQgMjAgLTEyIDE1IC0xNCAxNSBiIC04IDQ0IC0xNCAyNCAtMTIgMzEgYiAtMiA2NiAtNSA1NSAtMiA2NSBiIC0yIDY2IC0yIDY2IC0yIDY2IGwgLTIgNjYgYiAtNDMgNDEgLTIgNjYgLTIxIDU1IGIgLTExNCA0IC05OCA4IC05OCA4IGIgLTE0NCAwIC0xMjMgMCAtMTM0IDAgYiAtMjQyIDk5IC0xOTcgMCAtMjQyIDQzIGIgLTI0MiAxMDkgLTI0MiAxMDIgLTI0MiAxMDUgYiAtMjEyIDIxOSAtMjQwIDEyMiAtMjQyIDExNiBiIC0xODUgMzEyIC0xOTcgMjcwIC0xODUgMzEyIGwgLTE4NSAzMTIgYiAtMTg5IDMxMiAtMTg1IDMxMiAtMTg2IDMxMiBiIC0yNTkgMzEyIC0yMDAgMzEyIC0yMjcgMzEyIGIgLTMyMSAzMTAgLTI5MSAzMTIgLTMxMCAzMTAgYiAtMzM0IDMxMiAtMzMwIDMxMCAtMzM0IDMxMiBiIC0zNDAgMzE5IC0zMzggMzEzIC0zNDAgMzE2IGIgLTMzNiAzMjYgLTM0MCAzMjIgLTMzOCAzMjQgYiAtMjkxIDMzNyAtMzM0IDMyNiAtMzE0IDMzMSBsIC0yNDcgMzQ3IGwgLTIxMCAzNDggYiAtMTcyIDM0OCAtMTkwIDM0OCAtMTcyIDM0OCBiIC0xNjggMzYzIC0xNzIgMzQ4IC0xNzEgMzU1IGIgLTE0NSA0NDIgLTE1MSA0MjQgLTE0NSA0NDEgYiAtMTMzIDQ1MiAtMTQ0IDQ0NCAtMTQwIDQ0NiBsIC03NyA0ODkgYiAtMzIgNTIwIC01MyA1MDYgLTMyIDUyMCBtIDU3IDMzNCBiIDUzIDMzNSA1NSAzMzUgNTQgMzM1IGIgNDQgMzM0IDUwIDMzNSA0OSAzMzUgYiAtNzAgMzE2IDggMzI2IC0yOCAzMjAgYiAtNzggMzA5IC03OCAzMTYgLTc4IDMxNiBiIC0xMDggMjAyIC04MCAzMDUgLTg4IDI3NCBiIC0xNDEgODEgLTEzNiAxMTIgLTE0MSA5MyBiIC0xNDAgNzQgLTE0MSA3OSAtMTQxIDc3IGIgLTExNyA0OSAtMTM3IDU5IC0xMjcgNDkgYiAtMTA3IDUyIC0xMTQgNDkgLTExMCA1MSBiIDE2IDEyNyAtMTA2IDU0IDE0IDEyNiBiIDQyIDIxNyAxNiAxMjcgNDIgMjE1IGIgNDkgMjQxIDQyIDIyMiA0NCAyMjkgYiA3MyAzMjAgNTMgMjUxIDczIDMxNyBiIDU3IDMzNCA3MyAzMjcgNjUgMzMzIFwifSxcInYyMFwiOntcInhfbWluXCI6LTU3MS42NzE4NzUsXCJ4X21heFwiOjU3MC4zMTI1LFwiaGFcIjo1ODIsXCJvXCI6XCJtIC01NTkgMzUxIGIgLTU1MSAzNTIgLTU1NiAzNTIgLTU1MyAzNTIgYiAtNTMwIDMzOCAtNTQzIDM1MiAtNTMzIDM0OCBiIC01MjkgMTY5IC01MzAgMzM3IC01MjkgMjkxIGwgLTUyOSAxIGwgLTUwNyAyNyBsIC00NDEgMTEyIGIgLTM4MiAxNzQgLTM5NCAxNjkgLTM5MCAxNzQgYiAtMzc4IDE3NCAtMzgxIDE3NCAtMzc5IDE3NCBiIC0yODEgODYgLTM3MCAxNzQgLTM3NSAxNzkgYiAtMTk2IDAgLTIzNCAzNyAtMTk2IDAgYiAtMTI2IDg0IC0xOTYgMCAtMTY0IDM3IGIgLTUwIDE3NCAtNTUgMTczIC01NyAxNzIgYiAtNDQgMTc0IC00OSAxNzQgLTQ3IDE3NCBiIC0zNSAxNzMgLTQyIDE3NCAtMzggMTczIGIgNTMgODYgLTMyIDE3MiAtMTIgMTUxIGIgMTM4IDAgMTAwIDM3IDEzOCAwIGIgMjA4IDg0IDE0MCAwIDE3MCAzNyBiIDI4NCAxNzQgMjc5IDE3MyAyNzkgMTcyIGIgMjg5IDE3NCAyODUgMTc0IDI4OCAxNzQgYiAzMDAgMTczIDI5NCAxNzQgMjk4IDE3MyBiIDQ2MiAxMSAzMDMgMTcyIDM0MCAxMzQgbCA0NzUgLTEgbCA1MDMgMzQgYiA1NDEgNzYgNTM0IDcyIDUzNiA3NCBiIDU0OCA3NyA1NDQgNzcgNTQ1IDc3IGIgNTcwIDU2IDU2MCA3NyA1NzAgNjggYiA1NjcgNDggNTcwIDU0IDU2OCA1MSBiIDM5MiAtMTcyIDU2NCA0MSAzOTcgLTE2NiBiIDM3OCAtMTc2IDM4NyAtMTc0IDM4MiAtMTc2IGIgMzY4IC0xNzQgMzc1IC0xNzYgMzcxIC0xNzYgYiAyODAgLTg3IDM2NyAtMTczIDM0NyAtMTUyIGIgMTk0IDAgMjM0IC0zOCAxOTQgMCBiIDEyNiAtODYgMTk0IDAgMTYzIC0zOCBiIDQ5IC0xNzQgNTQgLTE3NCA1NSAtMTczIGIgNDQgLTE3NiA0NyAtMTc2IDQ2IC0xNzYgYiAzNCAtMTc0IDQwIC0xNzYgMzYgLTE3NCBiIC01NCAtODcgMzEgLTE3MyAxMCAtMTUyIGIgLTE0MCAwIC0xMDIgLTM4IC0xNDAgMCBiIC0yMDkgLTg2IC0xNDAgMCAtMTcxIC0zOCBiIC0yODUgLTE3NCAtMjgwIC0xNzQgLTI3OSAtMTczIGIgLTI5MSAtMTc2IC0yODcgLTE3NiAtMjg4IC0xNzYgYiAtMzAwIC0xNzQgLTI5NCAtMTc2IC0yOTggLTE3NCBiIC00NjQgLTExIC0zMDMgLTE3MyAtMzc0IC0xMDIgbCAtNDc2IDAgbCAtNTA2IC0zNyBiIC01MzkgLTc2IC01MjggLTY1IC01MzcgLTc0IGIgLTU1MSAtODAgLTU0MyAtNzkgLTU0NyAtODAgYiAtNTcwIC02OCAtNTU4IC04MCAtNTY2IC03NiBsIC01NzEgLTY1IGwgLTU3MSAxMzYgYiAtNTcwIDM0MCAtNTcxIDMzMSAtNTcxIDMzNyBiIC01NTkgMzUxIC01NjggMzQ0IC01NjQgMzQ4IFwifSxcInYyMlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NDMyLjgyODEyNSxcImhhXCI6NDQyLFwib1wiOlwibSAyMDkgMTg2IGIgMjEzIDE4NyAyMTAgMTg3IDIxMiAxODcgYiAyMTYgMTg3IDIxNSAxODcgMjE2IDE4NyBiIDIyNCAxNzQgMjE2IDE4NiAyMjAgMTgwIGIgNDIwIC0xIDI2OSAxMDUgMzM4IDQzIGIgNDMyIC0xMiA0MzEgLTggNDMyIC05IGIgNDIxIC0yMyA0MzIgLTE1IDQzMiAtMTYgYiAyMjggLTE4MCAzNDUgLTcwIDI2NCAtMTM3IGIgMjE5IC0xODggMjIxIC0xODggMjIxIC0xODggbCAyMTkgLTE4OCBiIDIwOCAtMTc3IDIxNSAtMTg4IDIxNSAtMTg4IGIgMTAgMSAxNjMgLTEwNiA5MyAtNDQgYiAwIDExIDAgNiAwIDggYiAxMCAyMiAwIDEzIDAgMTUgYiAyMDIgMTc5IDg3IDY5IDE2NyAxMzYgYiAyMDkgMTg2IDIwNiAxODMgMjA5IDE4NiBcIn0sXCJ2MjNcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjEzMy4zOTA2MjUsXCJoYVwiOjEzNixcIm9cIjpcIm0gNTQgNjYgYiA2NSA2OCA1OCA2OCA2MSA2OCBiIDEyMiAzNyA4OCA2OCAxMTAgNTYgYiAxMzMgLTEgMTMwIDI2IDEzMyAxMiBiIDEwNCAtNTggMTMzIC0yMyAxMjMgLTQ0IGIgNjYgLTY5IDkyIC02NSA3OCAtNjkgYiAxMCAtMzggNDQgLTY5IDIzIC01OCBiIDAgLTEgMiAtMjcgMCAtMTMgYiA1NCA2NiAwIDMwIDIwIDYxIFwifSxcInYyNVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MzE4LjUsXCJoYVwiOjMyNSxcIm9cIjpcIm0gMjAgMzc2IGIgMTY3IDM3NyAyMyAzNzcgOTYgMzc3IGIgMjk2IDM3NiAyMzEgMzc3IDI5NCAzNzcgYiAzMTggMzQ3IDMxMSAzNzEgMzE4IDM1OSBiIDI5NiAzMTYgMzE4IDMzMyAzMTEgMzIwIGIgMTU5IDMxNSAyOTQgMzE1IDIyNyAzMTUgYiAyMSAzMTYgOTEgMzE1IDI0IDMxNSBiIDAgMzQ1IDYgMzIwIDAgMzMzIGIgMjAgMzc2IDAgMzU5IDYgMzcxIFwifSxcInYyNlwiOntcInhfbWluXCI6LTIxLjc4MTI1LFwieF9tYXhcIjo0ODMuMTg3NSxcImhhXCI6NDkzLFwib1wiOlwibSAtOCA2MzEgYiAtMSA2MzIgLTYgNjMyIC00IDYzMiBiIDE5IDYyMCA4IDYzMiAxNiA2MjggYiAyMCAzODMgMjAgNjE2IDIwIDYxNiBsIDIwIDE0OCBsIDIxIDE1MSBiIDE0MCAxOTkgNTkgMTgzIDEwMiAxOTkgYiAyMDYgMTc5IDE2NCAxOTkgMTg3IDE5MiBsIDIxMCAxNzYgbCAyMTAgMzk2IGwgMjEwIDYxNyBsIDIxMiA2MjEgYiAyMzEgNjMyIDIxNiA2MjggMjIzIDYzMiBiIDI1MCA2MjAgMjM5IDYzMiAyNDcgNjI4IGIgMjUxIDM4MyAyNTEgNjE2IDI1MSA2MTYgbCAyNTEgMTQ4IGwgMjU0IDE1MSBiIDM3MCAxOTkgMjkxIDE4MyAzMzIgMTk5IGIgNDE1IDE5MSAzODUgMTk5IDQwMCAxOTcgYiA0ODMgODQgNDU4IDE3NiA0ODMgMTM0IGIgNDYxIDAgNDgzIDU4IDQ3NiAyOSBiIDMzMiAtMTQyIDQzOSAtNDAgNDExIC03MiBsIDI1NSAtMjE1IGIgMjMxIC0yMjkgMjQwIC0yMjkgMjM5IC0yMjkgYiAyMTYgLTIyMyAyMjQgLTIyOSAyMjAgLTIyNyBiIDIxMCAtMTU4IDIxMCAtMjE3IDIxMCAtMjIzIGIgMjEwIC0xMjAgMjEwIC0xNDggMjEwIC0xMzYgbCAyMTAgLTI5IGwgMjA1IC0zNCBiIDEwMCAtMTQyIDE4MiAtNjUgMTU5IC04OCBsIDIzIC0yMTUgYiAtMSAtMjI5IDkgLTIyOSA2IC0yMjkgYiAtMjAgLTIxNiAtOSAtMjI5IC0xNyAtMjI0IGwgLTIxIC0yMTIgbCAtMjEgMjAxIGwgLTIxIDYxNiBsIC0yMCA2MjAgYiAtOCA2MzEgLTE3IDYyNCAtMTMgNjMwIG0gMTEwIDEzMSBiIDk2IDEzMyAxMDYgMTMzIDEwMCAxMzMgYiA4OSAxMzMgOTMgMTMzIDkxIDEzMyBiIDI0IDg3IDYzIDEyOSA0MCAxMTMgbCAyMCA4MCBsIDIwIC0zNyBsIDIwIC0xNTYgbCAyMyAtMTUyIGIgMTQ0IDgxIDk2IC03MiAxNDQgMjAgbCAxNDQgODMgYiAxMTAgMTMxIDE0NCAxMTMgMTM0IDEyNiBtIDM0MSAxMzEgYiAzMjggMTMzIDMzNyAxMzMgMzMyIDEzMyBiIDMyMiAxMzMgMzI2IDEzMyAzMjMgMTMzIGIgMjU3IDg3IDI5NiAxMjkgMjczIDExMyBsIDI1MSA4MCBsIDI1MSAtMzcgbCAyNTEgLTE1NiBsIDI1NSAtMTUyIGIgMzc1IDgxIDMyOCAtNzIgMzc1IDIwIGwgMzc1IDgzIGIgMzQxIDEzMSAzNzUgMTEzIDM2NyAxMjYgXCJ9LFwidjI3XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0MzIuODI4MTI1LFwiaGFcIjo0NDIsXCJvXCI6XCJtIDIwOCAxODQgYiAyMTMgMTg3IDIwOSAxODYgMjEyIDE4NyBiIDIyNCAxNzYgMjE3IDE4NyAyMjEgMTgzIGIgMjQ1IDE0NyAyMjUgMTcyIDIzNSAxNTkgYiA0MTkgLTEgMjg4IDkwIDM0NyAzOCBiIDQzMSAtOCA0MjQgLTQgNDMxIC04IGIgNDMyIC0xMiA0MzIgLTkgNDMyIC0xMSBiIDQzMCAtMTggNDMyIC0xMyA0MzIgLTE2IGIgMzY0IC02MSA0MjQgLTIwIDM4MyAtNDcgYiAyMjUgLTE4MyAzMDcgLTEwMiAyNTAgLTE1MiBiIDIyMyAtMTg3IDIyNCAtMTg0IDIyMyAtMTg3IGIgMjIwIC0xODggMjIxIC0xODggMjIwIC0xODggYiAyMDggLTE3NiAyMTYgLTE4OCAyMTAgLTE4NCBiIDE4NyAtMTQ4IDIwNSAtMTczIDE5NyAtMTU5IGIgMTIgMCAxNDQgLTkwIDg0IC0zOCBiIDAgMTEgNCA1IDAgOCBiIDE2IDI0IDAgMTMgNCAxOCBiIDE4MyAxNTggODMgNjkgMTQxIDExNSBiIDIwOCAxODQgMTk0IDE2OSAxOTggMTczIG0gMTgzIDEwNSBiIDE3NiAxMTMgMTgxIDEwOSAxNzYgMTEzIGIgMTcyIDEwOSAxNzYgMTEzIDE3NSAxMTIgYiA5MiA0NSAxNDkgOTAgMTE3IDYyIGwgODggNDEgbCAxMDIgMzEgYiAyNDcgLTEwNSAxNjAgLTYgMjEwIC01NSBsIDI1NCAtMTE1IGwgMjU3IC0xMTIgbCAyNjkgLTEwMiBiIDM0MCAtNDUgMjg3IC04NyAzMTkgLTYxIGwgMzQ0IC00MyBsIDMzMCAtMzMgYiAxODMgMTA1IDI3MiA2IDIyMSA1NCBcIn0sXCJ2MjhcIjp7XCJ4X21pblwiOi03My41LFwieF9tYXhcIjo3Mi4xNDA2MjUsXCJoYVwiOjc0LFwib1wiOlwibSAtNzIgMjUyIGwgLTczIDI1NCBsIDAgMjU0IGwgNzIgMjU0IGwgNzAgMjUyIGIgMCAtMSA3MCAyNDggMCAtMSBiIC03MiAyNTIgLTEgLTEgLTcyIDI0OCBcIn0sXCJ2MjlcIjp7XCJ4X21pblwiOi01OTAuNzE4NzUsXCJ4X21heFwiOjU4OS4zNTkzNzUsXCJoYVwiOjYwMSxcIm9cIjpcIm0gMTc1IDI3MyBiIDE4MiAyNzQgMTc4IDI3MyAxODEgMjc0IGIgMjAyIDI2MiAxOTAgMjc0IDE5OCAyNjkgYiAyMDQgMTU4IDIwNCAyNTkgMjA0IDI1OSBsIDIwNCA1NiBsIDI1MCAxMTIgYiAzMDMgMTc0IDI5NiAxNzIgMjk4IDE3MiBiIDMwOCAxNzQgMzA0IDE3NCAzMDcgMTc0IGIgMzE4IDE3MyAzMTMgMTc0IDMxNyAxNzMgYiA0ODEgMTEgMzIyIDE3MiAzNTcgMTM0IGwgNDk0IC0xIGwgNTIyIDM0IGIgNTYwIDc2IDU1MyA3MiA1NTUgNzQgYiA1NjcgNzcgNTYzIDc3IDU2NCA3NyBiIDU4OSA1NiA1NzkgNzcgNTg5IDY4IGIgNTg2IDQ4IDU4OSA1NCA1ODggNTEgYiA0MTEgLTE3MiA1ODMgNDEgNDE2IC0xNjYgYiAzOTcgLTE3NiA0MDYgLTE3NCA0MDEgLTE3NiBiIDM4NyAtMTc0IDM5MyAtMTc2IDM5MCAtMTc2IGIgMjk5IC04NyAzODYgLTE3MyAzNjYgLTE1MiBiIDIxMyAwIDI1MyAtMzggMjEzIDAgYiAyMDggLTYgMjEzIDAgMjEwIC0yIGwgMjA0IC0xMiBsIDIwNCAtMTQ3IGIgMjA0IC0yMTAgMjA0IC0xNzMgMjA0IC0xOTQgYiAxOTggLTI5MiAyMDQgLTI5NyAyMDQgLTI4NyBiIDE4MyAtMjk5IDE5NCAtMjk3IDE4OSAtMjk5IGIgMTY0IC0yODcgMTc1IC0yOTkgMTY3IC0yOTUgYiAxNjMgLTE3NCAxNjMgLTI4NCAxNjMgLTI4NCBsIDE2MSAtNjMgbCAxMTkgLTExNyBiIDY1IC0xNzYgNzYgLTE3MCA3MyAtMTc2IGIgNjEgLTE3NiA2MyAtMTc2IDYyIC0xNzYgYiAtMzUgLTg3IDUxIC0xNzQgNTcgLTE4MCBiIC0xMjEgMCAtODMgLTM4IC0xMjEgMCBiIC0xOTAgLTg2IC0xMjIgMCAtMTUyIC0zOCBiIC0yNjYgLTE3NCAtMjYxIC0xNzQgLTI1OSAtMTczIGIgLTI3MiAtMTc2IC0yNjggLTE3NiAtMjcwIC0xNzYgYiAtMjgxIC0xNzQgLTI3NiAtMTc2IC0yODAgLTE3NCBiIC0zNzEgLTg2IC0yODQgLTE3MyAtMzA0IC0xNTIgYiAtNDU3IDAgLTQxNyAtMzggLTQ1NyAwIGwgLTQ1NyAwIGIgLTQ3NyAtMjYgLTQ1NyAwIC00NzAgLTE2IGIgLTU0OCAtMjI3IC01MjQgLTg4IC01NDggLTE2MSBiIC01MzYgLTMwMyAtNTQ4IC0yNTQgLTU0NCAtMjgwIGIgLTUzMyAtMzE3IC01MzQgLTMwOSAtNTMzIC0zMTMgYiAtNTUzIC0zMzggLTUzMyAtMzMwIC01NDEgLTMzOCBiIC01NzcgLTMxNSAtNTY2IC0zMzggLTU3MSAtMzMzIGIgLTU5MCAtMjI3IC01ODYgLTI4NyAtNTkwIC0yNTggYiAtNTE4IC05IC01OTAgLTE1NCAtNTY0IC03NyBiIC00NjUgNTYgLTUwOSAyIC01MDQgOCBsIC00MDIgMTM0IGIgLTM2MyAxNzQgLTM3NCAxNzAgLTM3MSAxNzQgYiAtMzU5IDE3NCAtMzYyIDE3NCAtMzYwIDE3NCBiIC0yNjIgODYgLTM1MSAxNzQgLTM1NiAxNzkgYiAtMTc2IDAgLTIxNiAzNyAtMTc2IDAgYiAtMTA3IDg0IC0xNzYgMCAtMTQ1IDM3IGIgLTMxIDE3NCAtMzYgMTczIC0zOCAxNzIgYiAtMjUgMTc0IC0yOSAxNzQgLTI4IDE3NCBiIC0xNiAxNzMgLTIzIDE3NCAtMTkgMTczIGIgMTQ3IDExIC0xMyAxNzIgMzUgMTIzIGwgMTU3IC0xIGwgMTYwIDEgbCAxNjMgNCBsIDE2MyAxMzAgYiAxNjQgMjYwIDE2MyAyNTYgMTYzIDI1OCBiIDE3NSAyNzMgMTY2IDI2NiAxNzAgMjcwIFwifSxcInYyYVwiOntcInhfbWluXCI6LTIxLjc4MTI1LFwieF9tYXhcIjozNjYuMTQwNjI1LFwiaGFcIjozNzQsXCJvXCI6XCJtIDI3NiAxMzc4IGIgMjg0IDEzNzkgMjc5IDEzNzkgMjgxIDEzNzkgYiAzMDYgMTM2MCAyOTIgMTM3OSAyOTggMTM3NCBiIDM1MiAxMjQ3IDMyNiAxMzI2IDM0MyAxMjg2IGIgMzY2IDExMzkgMzYyIDEyMTMgMzY2IDExNzUgYiAzNDcgMTAwOSAzNjYgMTA5MyAzNTkgMTA0OSBsIDM0NCAxMDAyIGwgMzQ3IDk5MiBiIDM1MiA5NzEgMzQ4IDk4NiAzNTEgOTc3IGIgMzY2IDg2MyAzNjIgOTM2IDM2NiA4OTkgYiAzNDcgNzMyIDM2NiA4MTggMzU5IDc3MyBsIDM0NCA3MjUgbCAzNDcgNzE2IGIgMzUyIDY5NSAzNDggNzEwIDM1MSA3MDAgYiAzNjYgNTg4IDM2MiA2NTkgMzY2IDYyMyBiIDIyMyAyNjIgMzY2IDQ2NCAzMTQgMzQ1IGIgMTg5IDIzMyAyMTIgMjUyIDIxMiAyNTIgYiAzNSA3NiAxMjYgMTgzIDczIDEyOSBiIC0xIDE2IDIwIDU2IDIgMjcgYiAtMTkgNCAtNCA5IC0xMiA0IGwgLTIxIDQgbCAtMjEgMTM3IGwgLTIxIDI3MCBsIC0xNyAyNzAgYiAxODYgMzQ0IDU5IDI4MSAxMzQgMzA4IGIgMzE5IDYwNiAyNzAgMzk5IDMxOSA0OTkgYiAzMTcgNjUwIDMxOSA2MjAgMzE5IDYzNSBsIDMxNSA2NTkgbCAzMTQgNjU1IGIgMjIzIDUzNyAyODggNjA3IDI1OCA1NzAgYiAxODkgNTA5IDIxMiA1MjggMjEyIDUyOCBiIDM1IDM1MiAxMjYgNDU5IDczIDQwNSBiIC0xIDI5MiAyMCAzMzMgMiAzMDMgYiAtMTkgMjgwIC00IDI4NSAtMTIgMjgwIGwgLTIxIDI4MCBsIC0yMSA0MTMgbCAtMjEgNTQ2IGwgLTE3IDU0NiBiIDE4NiA2MjAgNTkgNTU3IDEzNCA1ODQgYiAzMTkgODgyIDI3MCA2NzUgMzE5IDc3NSBiIDMxNyA5MjUgMzE5IDg5NiAzMTkgOTExIGwgMzE1IDkzNSBsIDMxNCA5MzEgYiAyMjMgODEzIDI4OCA4ODQgMjU4IDg0NiBiIDE4OSA3ODUgMjEyIDgwNSAyMTIgODA1IGIgMzUgNjI4IDEyNiA3MzUgNzMgNjgxIGIgLTEgNTY5IDIwIDYwOSAyIDU4MCBiIC0xOSA1NTYgLTQgNTYyIC0xMiA1NTYgbCAtMjEgNTU2IGwgLTIxIDY4OSBsIC0yMSA4MjMgbCAtMTcgODIzIGIgMjAyIDkwNyA2OCA4MzUgMTUyIDg2NyBiIDMxOSAxMTU3IDI4MCA5NjggMzE5IDEwNjEgYiAyNzAgMTMzOCAzMTkgMTIxOCAzMDMgMTI4MSBiIDI2MiAxMzU4IDI2NCAxMzQ5IDI2MiAxMzUzIGIgMjYyIDEzNjQgMjYyIDEzNjAgMjYyIDEzNjMgYiAyNzYgMTM3OCAyNjUgMTM3MSAyNjkgMTM3NiBcIn0sXCJ2MmNcIjp7XCJ4X21pblwiOi01OTcuNTMxMjUsXCJ4X21heFwiOjU5Ni4xNzE4NzUsXCJoYVwiOjYwOCxcIm9cIjpcIm0gLTQxMyAxNzMgYiAtNDA4IDE3NCAtNDEyIDE3NCAtNDA5IDE3NCBiIC0zOTcgMTczIC00MDQgMTc0IC00MDAgMTczIGIgLTMwOCA4NiAtMzk0IDE3MiAtMzc0IDE1MSBiIC0yMjMgMCAtMjYxIDM3IC0yMjMgMCBiIC0xNTMgODQgLTIyMyAwIC0xOTEgMzcgYiAtNzcgMTc0IC04MyAxNzMgLTg0IDE3MiBiIC03MiAxNzQgLTc2IDE3NCAtNzQgMTc0IGIgLTYyIDE3MyAtNjggMTc0IC02MyAxNzMgYiAyNSA4NiAtNTkgMTcyIC0zOSAxNTEgYiAxMTIgMCA3MyAzNyAxMTEgMCBiIDE4MSA4NCAxMTIgMCAxNDQgMzcgYiAyNTcgMTc0IDI1MSAxNzMgMjUxIDE3MiBiIDI2MiAxNzQgMjU4IDE3NCAyNjEgMTc0IGIgMjczIDE3MyAyNjYgMTc0IDI3MCAxNzMgYiA0MzYgOSAyNzYgMTcyIDM0NyAxMDEgbCA0NDcgLTEgbCA0NzcgMzYgYiA1MjIgNzkgNTExIDc5IDUxMyA3OSBsIDUyMiA3OSBiIDU1MiA1MSA1MzMgNzkgNTM5IDczIGIgNTk2IC0xMTIgNTgyIDYgNTk2IC01MSBiIDU2NyAtMjYyIDU5NiAtMTYxIDU4NiAtMjEzIGIgNTM5IC0zMjIgNTU4IC0yODcgNTQ0IC0zMTYgYiA1MjQgLTMyNyA1MzQgLTMyNiA1MjkgLTMyNyBiIDUwNCAtMzE1IDUxNSAtMzI3IDUwNyAtMzIzIGIgNTAzIC0zMDggNTAzIC0zMTIgNTAzIC0zMDkgYiA1MTEgLTI4NSA1MDMgLTMwMiA1MDQgLTI5NyBiIDU1NSAtMTEzIDU0MCAtMjI3IDU1NSAtMTY5IGIgNTQ0IC0zNCA1NTUgLTg2IDU1MSAtNTkgYiA1MjIgMTkgNTQwIC0xNiA1MzAgOCBsIDUyMSAyMiBsIDQ4MSAtMjYgbCA0MDUgLTEyMiBiIDM1MyAtMTc2IDM2NiAtMTcyIDM2MiAtMTc2IGIgMzQ5IC0xNzYgMzUyIC0xNzYgMzUxIC0xNzYgYiAyNTMgLTg3IDM0MSAtMTc2IDM0NyAtMTgwIGIgMTY3IDAgMjA2IC0zOCAxNjcgMCBiIDk5IC04NiAxNjcgMCAxMzYgLTM4IGIgMjEgLTE3NCAyNyAtMTc0IDI4IC0xNzMgYiAxNyAtMTc2IDIwIC0xNzYgMTkgLTE3NiBiIDYgLTE3NCAxMyAtMTc2IDkgLTE3NCBiIC04MSAtODcgNCAtMTczIC0xNCAtMTUyIGIgLTE2NyAwIC0xMjkgLTM4IC0xNjcgMCBiIC0yMzYgLTg2IC0xNjcgMCAtMTk4IC0zOCBiIC0zMTMgLTE3NCAtMzA3IC0xNzQgLTMwNiAtMTczIGIgLTMxOCAtMTc2IC0zMTQgLTE3NiAtMzE1IC0xNzYgYiAtMzI4IC0xNzQgLTMyMSAtMTc2IC0zMjUgLTE3NCBiIC00OTEgLTEyIC0zMzAgLTE3MyAtMzY3IC0xMzcgbCAtNTAzIDAgbCAtNTMwIC0zNCBiIC01NzAgLTc3IC01NjIgLTczIC01NjQgLTc2IGIgLTU3NyAtNzkgLTU3MSAtNzkgLTU3NCAtNzkgYiAtNTk3IC01OCAtNTg4IC03OSAtNTk3IC02OSBiIC01OTYgLTQ5IC01OTcgLTU1IC01OTcgLTUyIGIgLTQxNyAxNzIgLTU5MyAtNDMgLTQyMyAxNjcgYiAtNDEzIDE3MyAtNDE3IDE3MiAtNDE1IDE3MyBcIn0sXCJ2MmRcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQzOC4yODEyNSxcImhhXCI6NDQ3LFwib1wiOlwibSAyMTIgMTkwIGIgMjE5IDE5MSAyMTMgMTkxIDIxNiAxOTEgYiAyMzYgMTc2IDIyNSAxOTEgMjI4IDE5MCBiIDQxOSAxOCAyNzcgMTA1IDM0MSA0OSBiIDQzNiA1IDQzMSAxMyA0MzQgMTEgYiA0MzggLTEgNDM4IDQgNDM4IDEgYiA0MjQgLTE2IDQzOCAtOCA0MzIgLTEzIGIgMzU2IC00OSA0MDkgLTIwIDM3OSAtMzYgYiAyMzQgLTE4MCAzMDYgLTgzIDI1OCAtMTMzIGIgMjE5IC0xOTIgMjMwIC0xODggMjI0IC0xOTIgYiAyMDAgLTE3NiAyMTMgLTE5MiAyMDYgLTE4NyBiIDkgLTE1IDE1NyAtMTAyIDg5IC00NSBiIDAgMCAyIC0xMiAwIC02IGIgMTYgMTggMCA5IDIgMTIgYiAyMDAgMTc2IDkzIDQ4IDE1OSAxMDQgYiAyMTIgMTkwIDIwNSAxODYgMjA4IDE4OCBtIDIzOSAxMTMgYiAyMzYgMTE3IDIzOCAxMTYgMjM4IDExNyBiIDIzMCAxMDggMjM1IDExNyAyMzQgMTE1IGIgOTIgLTE1IDE5NiA1OCAxNDAgOCBiIDg4IC0xOCA5MSAtMTYgODggLTE4IGIgOTIgLTIwIDg4IC0xOCA5MSAtMTkgYiAxOTggLTExNiAxMzAgLTQzIDE2NiAtNzQgYiAyMDAgLTExNyAyMDAgLTExNyAyMDAgLTExNyBiIDIwMSAtMTE3IDIwMCAtMTE3IDIwMSAtMTE3IGIgMjY0IC00MyAyMTIgLTk4IDI0MiAtNjIgYiAzNDUgMTUgMjg4IC0xOSAzMjEgNCBiIDM0OCAxOCAzNDcgMTYgMzQ4IDE2IGIgMzQ0IDIwIDM0OCAxOCAzNDcgMTkgYiAyMzkgMTEzIDMwNyA0MSAyNjYgNzkgXCJ9LFwidjJmXCI6e1wieF9taW5cIjotMS4zNTkzNzUsXCJ4X21heFwiOjY4MC41NjI1LFwiaGFcIjo2OTQsXCJvXCI6XCJtIDU5NyAxMDQyIGIgNjA0IDEwNDIgNjAwIDEwNDIgNjAyIDEwNDIgYiA2NDIgMTAwMiA2MjcgMTA0MiA2NDIgMTAyMiBiIDYxOSA5NjYgNjQyIDk4OCA2MzUgOTc0IGIgNDM5IDkyNyA1NzQgOTQyIDUwMyA5MjcgbCA0MjYgOTI3IGwgNDI2IDkyMSBiIDQzMCA4MzggNDI4IDg5MyA0MzAgODY2IGIgMzQ1IDQ4MCA0MzAgNjk2IDM5OCA1NjAgYiAxNzkgMzkxIDMwNyA0MjMgMjQ5IDM5MSBiIDE1NiAzOTIgMTcxIDM5MSAxNjQgMzkyIGIgMTM4IDM5NCAxNDkgMzk0IDE0MiAzOTQgYiAxMDMgNDM0IDExNSAzOTYgMTAzIDQxNiBiIDEyOSA0NzEgMTAzIDQ1MSAxMTEgNDY2IGIgMTQxIDQ3NCAxMzMgNDczIDEzNyA0NzQgYiAxNzIgNDU5IDE1MyA0NzQgMTY0IDQ2OSBiIDE4MSA0NTUgMTc1IDQ1NiAxNzYgNDU1IGIgMTg3IDQ1NiAxODIgNDU1IDE4NSA0NTUgYiAyNTMgNTIwIDIxMiA0NjAgMjM0IDQ4MyBiIDMxNSA4MzYgMjk0IDYwNSAzMTUgNzE0IGIgMzExIDkyOCAzMTUgODY3IDMxNCA4OTggYiAzMDIgOTQ1IDMxMCA5NDMgMzExIDk0MiBiIDI0NSA5NTMgMjgzIDk1MCAyNjIgOTUzIGIgMTMwIDg5MSAxOTMgOTUzIDE0OSA5MzEgYiA4NCA4NjAgMTE5IDg3MCAxMDIgODYwIGIgMzYgOTA1IDYxIDg2MCAzOSA4NzcgYiAzNiA5MTAgMzYgOTA3IDM2IDkwOSBiIDgwIDk3MCAzNiA5MzEgNTAgOTQ5IGIgMjQ5IDEwMTcgMTI1IDEwMDAgMTg3IDEwMTcgYiAzMjIgMTAwOSAyNzMgMTAxNyAyOTkgMTAxNCBsIDM0MSAxMDAzIGIgNDM2IDk5MSAzNzIgOTk1IDQwNiA5OTEgYiA1NzcgMTAzMSA0OTUgOTkxIDU0NSAxMDA0IGIgNTk3IDEwNDIgNTgzIDEwMzggNTkwIDEwNDEgbSA0MTYgMzYwIGIgNDI0IDM2MCA0MTkgMzYwIDQyMSAzNjAgYiA0ODEgMzA5IDQ1NCAzNjAgNDc5IDMzOCBiIDUwMyAxNDUgNDg0IDI4MCA0OTUgMTk5IGIgNTg1IC0xODUgNTI1IDE2IDU1NSAtMTA2IGIgNjMwIC0yNDUgNTk2IC0yMTMgNjEzIC0yMzcgbCA2MzQgLTI0NyBsIDYzOCAtMjQ1IGIgNjQ3IC0yNDQgNjQxIC0yNDUgNjQ1IC0yNDQgYiA2ODAgLTI3OCA2NjYgLTI0NCA2ODAgLTI2MiBiIDY2NCAtMzA4IDY4MCAtMjkwIDY3NSAtMzAxIGIgNjM4IC0zMTIgNjU4IC0zMTAgNjUwIC0zMTIgYiA2MTMgLTMwOSA2MzEgLTMxMiA2MjMgLTMxMCBiIDQ3NyAtMjAxIDU1NSAtMzAzIDUwMiAtMjYwIGIgNDE3IC0yIDQ2MCAtMTU5IDQzNCAtNzIgYiA0MTYgNSA0MTcgMSA0MTYgNSBiIDQxNiA1IDQxNiA1IDQxNiA1IGIgNDExIC01IDQxNSA1IDQxMyAwIGIgMzU5IC05NyAzOTcgLTMzIDM3NyAtNzAgYiAzNTMgLTEwNiAzNTUgLTEwMiAzNTMgLTEwNSBiIDM1OSAtMTEyIDM1MyAtMTA4IDM1NSAtMTA5IGIgNDA5IC0xMzAgMzc1IC0xMjMgMzkwIC0xMjkgYiA0MjYgLTEzNCA0MjAgLTEzMCA0MjEgLTEzMSBiIDQzMSAtMTQ3IDQyOCAtMTM3IDQzMSAtMTQxIGIgNDIwIC0xNjIgNDMxIC0xNTIgNDI3IC0xNTkgYiAzODIgLTE2OSA0MDkgLTE2NiAzOTYgLTE2OSBiIDMyMyAtMTU1IDM2MyAtMTY5IDM0MSAtMTY1IGwgMzE3IC0xNTIgbCAzMTQgLTE1NSBiIDYyIC0zMDMgMjQwIC0yNDAgMTQ4IC0yOTUgYiAzNiAtMzA1IDU1IC0zMDUgNDQgLTMwNSBiIDIzIC0zMDMgMjkgLTMwNSAyNCAtMzA1IGIgLTEgLTI3MyA2IC0yOTkgLTEgLTI4NyBiIDMxIC0yNDAgLTEgLTI1NiAxMCAtMjQwIGIgMzYgLTI0MCAzMiAtMjQwIDM0IC0yNDAgYiA0MiAtMjQxIDM4IC0yNDEgMzkgLTI0MSBiIDEzNCAtMjA0IDYzIC0yNDEgOTkgLTIyNiBiIDM2NyAyODggMjY1IC0xMTUgMzU3IDgxIGIgMzc1IDMzMCAzNjggMzEzIDM3MCAzMjAgYiA0MTYgMzYwIDM4MyAzNDcgNDAwIDM1OCBtIDM2MCAtMzU5IGIgMzc5IC0zNTkgMzYzIC0zNTkgMzcxIC0zNTkgYiA0MjQgLTM2MCAzOTYgLTM1OSA0MTYgLTM1OSBiIDY0NiAtNTAyIDUzNiAtMzczIDYyNCAtNDMwIGIgNjQ5IC01MjcgNjQ5IC01MTAgNjQ5IC01MTkgYiA1MzAgLTY3MyA2NDkgLTU3OCA2MDQgLTYzNSBsIDUyMSAtNjc3IGwgNTI5IC02ODEgYiA2NTMgLTgxMSA1OTIgLTcxNCA2MzcgLTc2MiBiIDY2MCAtODUzIDY1OCAtODI3IDY2MCAtODM5IGIgNjQ1IC05MTEgNjYwIC04NzMgNjU2IC04OTIgYiA0MjYgLTEwMjEgNjA4IC05ODEgNTE5IC0xMDIxIGIgMjgzIC05ODkgMzc3IC0xMDIxIDMyOCAtMTAxMSBiIDIzNSAtOTQ5IDI0OSAtOTcyIDIzOSAtOTY0IGIgMjM0IC05MzYgMjM0IC05NDYgMjM0IC05NDEgYiAyMzQgLTkyOCAyMzQgLTkzNCAyMzQgLTkzMSBsIDIzNSAtOTI1IGwgMjM0IC05MjcgbCAyMjUgLTkzNCBiIDg3IC05ODIgMTg2IC05NjYgMTM4IC05ODIgYiA4MCAtOTgyIDg1IC05ODIgODMgLTk4MiBiIDU1IC05ODEgNzAgLTk4MSA1OCAtOTgxIGIgMTcgLTk0MyAzMiAtOTgxIDE3IC05NjQgYiA1NCAtOTA0IDE3IC05MjEgMzUgLTkwNCBiIDc4IC05MTQgNjIgLTkwNCA3MiAtOTA5IGwgODMgLTkxOCBsIDg4IC05MTggYiAxOTAgLTgzMSAxMjIgLTkxOCAxNjYgLTg4MSBiIDI2OSAtNTA2IDI0MiAtNzI3IDI2OSAtNjEyIGIgMjY4IC00NjIgMjY5IC00OTIgMjY5IC00NzcgYiAyNjYgLTQ0OSAyNjYgLTQ1OCAyNjYgLTQ1MiBiIDI2NSAtNDQ0IDI2NiAtNDQ1IDI2NiAtNDQ0IGIgMjU3IC00NDYgMjY0IC00NDQgMjYxIC00NDUgYiAxMzIgLTU0NSAxOTYgLTQ3MCAxNTIgLTUwNSBiIDg4IC01NzMgMTIyIC01NjMgMTA0IC01NzMgYiAzOSAtNTIzIDYzIC01NzMgMzkgLTU1MyBiIDYzIC00NzYgMzkgLTUwNSA0NCAtNDk0IGIgMzYwIC0zNTkgMTM2IC00MDggMjM1IC0zNjkgbSA0MTkgLTQyNCBiIDM5MyAtNDIzIDQxMSAtNDIzIDQwNiAtNDIzIGwgMzc1IC00MjMgbCAzNzcgLTQyNiBiIDM3OSAtNDM5IDM3NyAtNDI3IDM3OCAtNDM0IGIgMzgzIC01MTAgMzgyIC00NjMgMzgzIC00ODcgYiAzMTQgLTgxMSAzODMgLTYwOSAzNjAgLTcxMCBiIDI2NiAtODkzIDI5NiAtODUwIDI4NSAtODcwIGIgMjY0IC04OTggMjY1IC04OTYgMjY0IC04OTggbCAyNjQgLTg5OCBiIDI2NCAtODk4IDI2NCAtODk4IDI2NCAtODk4IGIgMjY4IC04OTggMjY0IC04OTggMjY2IC04OTggYiAyNzMgLTg5OCAyNzAgLTg5OCAyNzIgLTg5OCBiIDMwMCAtOTA5IDI4MyAtODk4IDI5MSAtOTAwIGIgNDI2IC05NTcgMzQwIC05NDEgMzg1IC05NTcgYiA0NzYgLTk0OSA0NDMgLTk1NyA0NjAgLTk1NCBiIDU0NyAtODUzIDUyMiAtOTMxIDU0NyAtODkzIGIgNDg1IC03NDUgNTQ3IC04MTYgNTI2IC03NzUgYiAzOTcgLTcwNyA0NjAgLTcyNyA0MzIgLTcxNCBiIDM2NiAtNjc1IDM3NSAtNzAzIDM2NiAtNjkyIGIgMzk2IC02NDIgMzY2IC02NTcgMzc3IC02NDUgYiA1MzAgLTU1NyA0NTUgLTYzNyA1MTEgLTYwMSBiIDUzNiAtNTI3IDUzNCAtNTQ4IDUzNiAtNTM3IGIgNDE5IC00MjQgNTM2IC00ODAgNDkwIC00MzcgXCJ9LFwidjMwXCI6e1wieF9taW5cIjotMjEuNzgxMjUsXCJ4X21heFwiOjM2Ny41LFwiaGFcIjozNzUsXCJvXCI6XCJtIDI3NiAxOTAwIGIgMjg0IDE5MDEgMjc5IDE5MDAgMjgxIDE5MDEgYiAzMDYgMTg4MyAyOTEgMTkwMSAyOTggMTg5NiBiIDM2NyAxNjg2IDM0NyAxODI1IDM2NyAxNzU3IGIgMzQzIDE1NTggMzY3IDE2NDMgMzU5IDE2MDAgbCAzMzggMTU0OSBsIDM0MyAxNTM3IGIgMzY3IDE0MTEgMzU5IDE0OTcgMzY3IDE0NTQgYiAzNDMgMTI4MiAzNjcgMTM2NyAzNTkgMTMyNCBsIDMzOCAxMjcyIGwgMzQzIDEyNjEgYiAzNjcgMTEzNSAzNTkgMTIyMSAzNjcgMTE3OCBiIDM0MyAxMDA3IDM2NyAxMDkwIDM1OSAxMDQ3IGwgMzM4IDk5NiBsIDM0MyA5ODUgYiAzNjcgODU5IDM1OSA5NDUgMzY3IDkwMiBiIDM0MyA3MzEgMzY3IDgxNCAzNTkgNzcxIGwgMzM4IDcyMCBsIDM0MyA3MDkgYiAzNjcgNTgyIDM1OSA2NjcgMzY3IDYyNiBiIDI4OSAzNjIgMzY3IDUwMyAzNDAgNDI2IGIgMjM5IDMxMiAyNzYgMzQ1IDI1OSAzMzAgYiAyOSA3NyAxNTIgMjM3IDc2IDE1MiBiIC0xIDE4IDE0IDU0IDIgMzAgYiAtMTkgNCAtNCAxMSAtMTIgNCBsIC0yMSA0IGwgLTIxIDEzMyBsIC0yMCAyNjAgbCAtMTMgMjYyIGIgOTggMjk5IDE3IDI2OSA2MiAyODQgYiAxMTEgMzA1IDEwMyAzMDIgMTEwIDMwNSBiIDE2NyAzMzQgMTIzIDMxMCAxNTYgMzI3IGIgMzE5IDU5NSAyNjQgMzkxIDMxOSA0OTEgYiAzMTMgNjU5IDMxOSA2MTYgMzE4IDYzOCBiIDMxMCA2NjcgMzExIDY2NCAzMTEgNjY3IGIgMzA3IDY2MyAzMTAgNjY3IDMwOCA2NjYgYiAyNDAgNTg4IDI4OSA2MzcgMjY5IDYxNCBiIDE2IDMzMSAxNDEgNTA1IDYyIDQxMyBiIC0xIDI5NCA4IDMxNiAxIDMwMiBiIC0xOSAyODAgLTQgMjg3IC0xMiAyODAgbCAtMjEgMjgwIGwgLTIxIDQwOCBsIC0yMCA1MzcgbCAtMTMgNTM4IGIgOTggNTc2IDE3IDU0NSA2MiA1NjAgYiAxMTEgNTgxIDEwMyA1NzggMTEwIDU4MSBiIDE2NyA2MTAgMTIzIDU4NyAxNTYgNjAzIGIgMzE5IDg3MSAyNjQgNjY3IDMxOSA3NjcgYiAzMTMgOTM1IDMxOSA4OTIgMzE4IDkxMyBiIDMxMCA5NDIgMzExIDk0MSAzMTEgOTQyIGIgMzA3IDkzOSAzMTAgOTQyIDMwOCA5NDEgYiAyNDAgODY0IDI4OSA5MTMgMjY5IDg4OSBiIDE2IDYwNyAxNDEgNzgxIDYyIDY4OSBiIC0xIDU3MCA4IDU5MiAxIDU3OCBiIC0xOSA1NTYgLTQgNTYzIC0xMiA1NTYgbCAtMjEgNTU2IGwgLTIxIDY4NCBsIC0yMCA4MTMgbCAtMTMgODE0IGIgOTggODUyIDE3IDgyMSA2MiA4MzYgYiAxMTEgODU3IDEwMyA4NTUgMTEwIDg1NyBiIDE2NyA4ODYgMTIzIDg2MyAxNTYgODgwIGIgMzE5IDExNDcgMjY0IDk0MyAzMTkgMTA0MyBiIDMxMyAxMjExIDMxOSAxMTY4IDMxOCAxMTg5IGIgMzEwIDEyMTggMzExIDEyMTcgMzExIDEyMTggYiAzMDcgMTIxNSAzMTAgMTIxOCAzMDggMTIxNyBiIDI0MCAxMTQwIDI4OSAxMTg4IDI2OSAxMTY1IGIgMTYgODg0IDE0MSAxMDU3IDYyIDk2NiBiIC0xIDg0NiA4IDg2OCAxIDg1NSBiIC0xOSA4MzIgLTQgODM5IC0xMiA4MzIgbCAtMjEgODMyIGwgLTIxIDk2MCBsIC0yMCAxMDg5IGwgLTEzIDEwOTAgYiA5OCAxMTI4IDE3IDEwOTcgNjIgMTExMSBiIDExMSAxMTM0IDEwMyAxMTMxIDExMCAxMTM0IGIgMTY3IDExNjMgMTIzIDExMzkgMTU2IDExNTYgYiAzMTkgMTQyNCAyNjQgMTIyMCAzMTkgMTMyMCBiIDMxMyAxNDg2IDMxOSAxNDQ0IDMxOCAxNDY1IGIgMzEwIDE0OTQgMzExIDE0OTMgMzExIDE0OTQgYiAzMDcgMTQ5MiAzMTAgMTQ5NCAzMDggMTQ5MyBiIDI0MCAxNDE3IDI4OSAxNDY0IDI2OSAxNDQyIGIgMTYgMTE2MCAxNDEgMTMzMyA2MiAxMjQyIGIgLTEgMTEyMSA4IDExNDUgMSAxMTMxIGIgLTE5IDExMDkgLTQgMTExNSAtMTIgMTEwOSBsIC0yMSAxMTA5IGwgLTIxIDEyMzYgbCAtMjAgMTM2NSBsIC0xMyAxMzY3IGIgOTggMTQwNCAxNyAxMzc0IDYyIDEzODggYiAxMTEgMTQxMCAxMDMgMTQwNyAxMTAgMTQxMCBiIDI1MCAxNTA4IDE3MiAxNDM3IDIxNSAxNDY3IGIgMzE5IDE3MDEgMjk2IDE1NjQgMzE5IDE2MzMgYiAyNzAgMTg1OSAzMTkgMTc1NyAzMDMgMTgxNCBiIDI2MiAxODgyIDI2NSAxODY4IDI2MiAxODc1IGIgMjc2IDE5MDAgMjYyIDE4OTAgMjY2IDE4OTYgXCJ9LFwidjMxXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjozODYuNTYyNSxcImhhXCI6Mzk0LFwib1wiOlwibSAwIDE3MyBsIDAgMzQ3IGwgMTkzIDM0NyBsIDM4NiAzNDcgbCAzODYgMTczIGwgMzg2IDAgbCAxOTMgMCBsIDAgMCBsIDAgMTczIFwifSxcInYzM1wiOntcInhfbWluXCI6LTQyMy4zMTI1LFwieF9tYXhcIjo0MjEuOTM3NSxcImhhXCI6NDMxLFwib1wiOlwibSAtMTAgMjc2IGIgLTIgMjc3IC04IDI3NyAtNSAyNzcgYiAxNyAyNjUgNSAyNzcgMTMgMjczIGIgMTkgMTYzIDE5IDI2MCAxOSAyNjAgbCAxOSA2OCBsIDM5IDQ1IGIgMjc3IC05NSAxMjIgLTM0IDIwMCAtODEgYiAyODkgLTk3IDI4MSAtOTcgMjg1IC05NyBiIDM3OCAwIDMzMiAtOTcgMzcxIC01NCBiIDM3OCAxMSAzNzggNCAzNzggNiBiIDMwMiA4MyAzNzggNTUgMzQ1IDgzIGIgMjQyIDY2IDI4MyA4MyAyNjIgNzcgYiAyMDggNTYgMjMxIDU5IDIxOSA1NiBiIDE0OCAxMjAgMTc1IDU2IDE0OCA4MSBiIDIwMCAxODYgMTQ4IDE1MSAxNjQgMTcyIGIgMjYxIDE5OCAyMjAgMTk0IDI0MCAxOTggYiA0MjAgNDUgMzQxIDE5OCA0MTEgMTM3IGIgNDIxIDIyIDQyMSAzNyA0MjEgMjkgYiAyNTcgLTE5OCA0MjEgLTg2IDM0NyAtMTg4IGIgMjQyIC0xOTggMjUxIC0xOTggMjQ3IC0xOTggYiAyMCAtMTA1IDE4MSAtMTk4IDk1IC0xNjMgbCAxOSAtMTA0IGwgMTkgLTE4MyBiIDE5IC0yMTYgMTkgLTE5NSAxOSAtMjA2IGIgMTIgLTI3MyAxOSAtMjcyIDE3IC0yNjcgYiAtMiAtMjc4IDggLTI3NyAyIC0yNzggYiAtMjEgLTI2NiAtMTAgLTI3OCAtMTkgLTI3NCBiIC0yMyAtMTY1IC0yMyAtMjYzIC0yMyAtMjYyIGwgLTIzIC02OSBsIC00NCAtNDcgYiAtMjUwIDg2IC0xMTcgMjMgLTE4MyA2NiBiIC0yOTUgOTQgLTI3MCA5MyAtMjg0IDk0IGIgLTMxNSA5MSAtMzAyIDk0IC0zMDggOTQgYiAtMzgxIDUgLTM1NiA4MSAtMzgxIDQzIGIgLTM1NSAtNTYgLTM4MSAtMTYgLTM3MiAtNDAgYiAtMjk5IC04MSAtMzM4IC03MyAtMzE5IC04MSBiIC0yNDYgLTY4IC0yODMgLTgxIC0yNjUgLTc3IGIgLTIxMiAtNTggLTIzNCAtNjEgLTIyMyAtNTggYiAtMTY4IC03NyAtMTk2IC01OCAtMTc5IC02NSBiIC0xNTEgLTEyMiAtMTU2IC05MCAtMTUxIC0xMDUgYiAtMTc5IC0xNzQgLTE1MSAtMTQxIC0xNjAgLTE2MiBiIC0yMzkgLTE5NSAtMTk0IC0xODQgLTIxNyAtMTkyIGIgLTI1NyAtMTk3IC0yNDUgLTE5NSAtMjUwIC0xOTcgYiAtNDIzIC01IC0zNDkgLTE5NyAtNDIzIC0xMTMgYiAtNDIzIDAgLTQyMyAtNCAtNDIzIC0xIGIgLTI3NyAxOTQgLTQyMCA5NyAtMzYyIDE3MyBiIC0yNDcgMTk3IC0yNjggMTk3IC0yNTggMTk3IGIgLTI0IDEwNCAtMTg1IDE5NyAtMTAwIDE2MiBsIC0yMyAxMDIgbCAtMjMgMTgxIGIgLTIxIDI2NSAtMjMgMjYwIC0yMyAyNjAgYiAtMTAgMjc2IC0yMCAyNjkgLTE0IDI3NCBcIn0sXCJ2MzRcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjYyMi4wMzEyNSxcImhhXCI6NjM1LFwib1wiOlwibSAzOTggNDE3IGIgNDA2IDQxOSA0MDEgNDE5IDQwNCA0MTkgYiA0MjcgMzk4IDQxNyA0MTkgNDI3IDQwOSBiIDQyNyAzOTEgNDI3IDM5NSA0MjcgMzkyIGIgMzQgLTI3NCA0MjQgMzg1IDM4IC0yNzIgYiAyMCAtMjgwIDI5IC0yNzggMjUgLTI4MCBiIDAgLTI1OSA5IC0yODAgMCAtMjcwIGIgMCAtMjUyIDAgLTI1NiAwIC0yNTQgYiAzOTMgNDEzIDIgLTI0NyAzODkgNDEwIGIgMzk4IDQxNyAzOTQgNDE1IDM5NyA0MTYgbSA1OTIgNDE3IGIgNjAwIDQxOSA1OTQgNDE5IDU5NyA0MTkgYiA2MjIgMzk4IDYxMSA0MTkgNjIyIDQwOSBiIDYyMCAzOTEgNjIyIDM5NSA2MjAgMzkyIGIgMjI3IC0yNzQgNjE3IDM4NSAyMzEgLTI3MiBiIDIxMyAtMjgwIDIyMyAtMjc4IDIxOSAtMjgwIGIgMTkzIC0yNTkgMjAyIC0yODAgMTkzIC0yNzAgYiAxOTQgLTI1MiAxOTMgLTI1NiAxOTMgLTI1NCBiIDU4NiA0MTMgMTk2IC0yNDcgNTgyIDQxMCBiIDU5MiA0MTcgNTg4IDQxNSA1OTAgNDE2IFwifSxcInYzNlwiOntcInhfbWluXCI6LTEuMzU5Mzc1LFwieF9tYXhcIjoxMDY0LjM5MDYyNSxcImhhXCI6MTA4NixcIm9cIjpcIm0gMjk2IDY5MiBiIDMxNCA2OTQgMzAyIDY5NCAzMDcgNjk0IGIgMzg2IDY4NSAzMzcgNjk0IDM2NiA2ODkgYiA1NDggNDk4IDQ4MCA2NjAgNTQ4IDU4MCBiIDU0OCA0ODEgNTQ4IDQ5MiA1NDggNDg3IGIgNDU1IDM5NSA1NDEgNDI2IDQ5OSAzOTUgYiAzNzAgNDYyIDQyMCAzOTUgMzgzIDQxNyBiIDM2MiA0OTYgMzY0IDQ3NyAzNjIgNDg4IGIgMzc3IDUxNCAzNjIgNTA5IDM2NyA1MTQgYiAzOTMgNTAxIDM4NiA1MTQgMzkwIDUxMCBiIDQzMiA0NzQgMzk3IDQ4NCA0MTMgNDc0IGIgNDcwIDQ4NyA0NDUgNDc0IDQ1OCA0NzggYiA0OTEgNTMwIDQ4NCA0OTYgNDkxIDUxMCBiIDQ5MCA1NDQgNDkxIDUzNCA0OTEgNTM5IGIgMzMzIDY2MCA0NzkgNjA2IDQxMSA2NTcgbCAzMjMgNjYyIGwgMzE1IDY0NiBiIDI2OSA1MjQgMjg1IDU5MSAyNjkgNTU2IGIgMzIxIDQzMSAyNjkgNDkyIDI4NyA0NjYgYiAzNDkgMzk1IDMzOCA0MTMgMzQzIDQwOCBiIDM2MyAzNDIgMzU5IDM3OCAzNjMgMzYyIGIgMzU5IDMxMiAzNjMgMzMzIDM2MiAzMjIgYiAyODUgMTU4IDM0OCAyNjYgMzE4IDIwNiBiIDI4MSAxNTIgMjgzIDE1NSAyODEgMTUyIGIgMjgxIDE1MiAyODEgMTUyIDI4MSAxNTIgYiAyODcgMTU0IDI4MyAxNTIgMjg0IDE1MiBiIDMxOCAxNTUgMjk4IDE1NCAzMDggMTU1IGIgNDYxIDk4IDM3MSAxNTUgNDE5IDEzNiBsIDQ2NCA5NyBsIDQ4MyAxMTIgYiA1MDMgMTI5IDQ5NCAxMjAgNTAzIDEyNyBiIDUwNCAxMzAgNTAzIDEyOSA1MDQgMTI5IGIgNTAzIDEzOCA1MDQgMTMxIDUwMyAxMzQgYiA1MDAgMTgwIDUwMCAxNTIgNTAwIDE2NiBiIDU1MyAzMjYgNTAwIDIzOCA1MTggMjg4IGIgNjA0IDM2NiA1NjAgMzMxIDU5MiAzNTggYiA2NDkgMzgxIDYxNyAzNzYgNjMyIDM4MSBiIDY5NiAzNjIgNjY1IDM4MSA2ODEgMzc0IGIgNzI0IDMwMiA3MTQgMzQ3IDcyNCAzMjQgYiA2OTUgMjM4IDcyNCAyNzggNzE0IDI1NSBiIDY2MCAyMTAgNjkxIDIzNCA2NjIgMjEyIGIgNTc5IDE0OCA2NTggMjA5IDU4MiAxNTEgYiA1NzkgMTQ4IDU3OSAxNDggNTc5IDE0OCBiIDU5NiAxMDYgNTc5IDE0NCA1ODkgMTE5IGIgNjIyIDc3IDYwNCA4OCA2MDkgODMgYiA2NTcgNjkgNjMyIDcyIDY0NSA2OSBiIDc0OCAxMTIgNjg4IDY5IDcyMSA4NCBiIDc1NSAxMjMgNzU0IDExNyA3NTUgMTIwIGIgNzU1IDEyNyA3NTUgMTI0IDc1NSAxMjYgYiA3NTEgMTY1IDc1MiAxMzcgNzUxIDE1MSBiIDc1OCAyMTkgNzUxIDE4MyA3NTQgMjAyIGIgODk0IDM4NyA3NzQgMjkwIDgyMCAzNDcgYiA4OTYgMzkwIDg5NiAzODggODk2IDM4OCBiIDg5MSAzOTggODk2IDM5MSA4OTUgMzkyIGIgNjIyIDU2MCA4MjcgNDc3IDczMCA1MzUgYiA2MDAgNTgwIDYwNSA1NjQgNjAwIDU2OSBiIDYxNyA1OTYgNjAwIDU5MSA2MDcgNTk2IGIgNjI4IDU5NSA2MjIgNTk2IDYyNCA1OTYgYiAxMDU3IDI0OCA4NDYgNTUyIDEwMjAgNDEyIGIgMTA2NCAxOTEgMTA2MSAyMjkgMTA2NCAyMDkgYiA5MjIgMCAxMDY0IDk0IDEwMDUgOSBiIDkwMiAtMSA5MTYgLTEgOTA5IC0xIGIgNzc0IDc2IDg0NyAtMSA4MDAgMjYgYiA3NjkgODMgNzcwIDgxIDc3MCA4MyBiIDc2OSA4MSA3NjkgODMgNzY5IDgzIGIgNjI3IC0xIDczMyAyOSA2NzcgLTEgYiA1NDggMjcgNTk3IC0xIDU3MCA4IGIgNTE1IDg4IDUzNyAzNyA1MjUgNjEgbCA1MTMgOTUgbCA1MTAgOTMgbCA0NTMgNDUgYiAzOTAgMCAzOTYgMCAzOTYgMCBiIDM5MCAwIDM5MCAwIDM5MCAwIGIgMzc0IDE1IDM4MSAwIDM3NyA0IGIgMjY4IDEwNSAzNTkgNjkgMzE0IDEwNSBiIDI1MCAxMDQgMjYyIDEwNSAyNTcgMTA1IGwgMjQzIDEwMiBsIDIzNCA5MCBiIDE1NSAxIDIwMSA0OSAxNTkgMiBiIDE0NyAtMSAxNTIgMCAxNDkgLTEgYiAxMzAgMTUgMTM4IC0xIDEzMCA2IGIgMTMyIDIwIDEzMCAxOCAxMzIgMTkgYiAxMzYgMzEgMTMzIDIyIDEzNCAyNyBiIDIyMCAxMzEgMTQ5IDc0IDE3OCAxMDkgYiAyMzEgMTM3IDIyNSAxMzQgMjMwIDEzNiBiIDMwMiAyNzggMjgwIDIwMiAzMDIgMjQ0IGIgMjY1IDMzNSAzMDIgMjk5IDI5NSAzMDkgYiAyMDkgNDQyIDIzNCAzNjMgMjEzIDQwMiBiIDIwOSA0NTUgMjA5IDQ0NiAyMDkgNDUxIGIgMjc5IDY0OCAyMDkgNTAyIDIzMiA1NjQgbCAyODUgNjU5IGwgMjgzIDY1OSBiIDE3NiA2MjcgMjM4IDY1MyAyMTAgNjQ1IGIgNTcgNDc3IDExMSA1OTQgNjYgNTM4IGIgNTUgNDU5IDU1IDQ3MSA1NSA0NjQgYiA3MiA0MDkgNTUgNDM3IDYxIDQxNSBiIDkzIDQwMyA3OCA0MDUgODcgNDAzIGIgMTUyIDQ2NyAxMjMgNDAzIDE1MSA0MzEgYiAxNjggNDg4IDE1MyA0ODMgMTU3IDQ4OCBiIDE4NSA0NjIgMTgxIDQ4OCAxODUgNDgzIGwgMTg1IDQ2MCBiIDEzNyAzNDQgMTgzIDQwOSAxNjggMzY5IGIgNzggMzIyIDExOSAzMjggOTggMzIyIGIgMTMgMzYwIDUwIDMyMiAyNSAzMzUgYiAtMSA0MjYgNCAzODAgLTEgNDAyIGIgODkgNjEwIC0xIDQ4OCAzMiA1NTkgYiAyOTYgNjkyIDE0NyA2NTkgMjEwIDY4NSBtIDkyNiAzNDggYiA5MjEgMzUzIDkyNCAzNTEgOTIyIDM1MyBiIDkxNCAzNDggOTIwIDM1MyA5MTggMzUxIGIgODIzIDE2NyA4NTcgMzA2IDgyMyAyMzcgYiA4MjggMTI0IDgyMyAxNTQgODI2IDEzOCBiIDg5MCAzMSA4MzcgNzkgODYyIDQwIGIgODk2IDMxIDg5MiAzMSA4OTQgMzEgYiA5NTYgMTA0IDkxNiAzMSA5NDAgNTkgYiA5NzAgMTkxIDk2NSAxMjkgOTcwIDE1OSBiIDk2NiAyNDEgOTcwIDIwOCA5NjkgMjI0IGIgOTI2IDM0OCA5NTkgMjc3IDk0NSAzMTMgbSA2MjcgMzI2IGIgNjE5IDMyNiA2MjQgMzI2IDYyMiAzMjYgYiA1OTggMzE2IDYxMSAzMjYgNjA0IDMyMyBiIDU2OCAyMTUgNTc5IDI4OCA1NjggMjU1IGIgNTY4IDIwOCA1NjggMjEzIDU2OCAyMTAgYiA1NzEgMTgzIDU3MCAxOTUgNTcwIDE4NCBsIDU3MSAxODMgYiA1OTQgMjAxIDU3MSAxODMgNTgyIDE5MSBsIDYzNCAyMzEgYiA2NjAgMjU5IDY1MyAyNDcgNjU2IDI0OCBiIDY2NCAyNzggNjYyIDI2NiA2NjQgMjcyIGIgNjI3IDMyNiA2NjQgMjk5IDY0OSAzMjAgXCJ9LFwidjM4XCI6e1wieF9taW5cIjotMS4zNTkzNzUsXCJ4X21heFwiOjY1MS45Njg3NSxcImhhXCI6NjY1LFwib1wiOlwibSAzODkgNjQ0IGIgNDA1IDY0NSAzOTQgNjQ1IDQwMCA2NDUgYiA1MDQgNTY2IDQ1MCA2NDUgNDkyIDYxMyBiIDUwNyA1NDEgNTA2IDU1NyA1MDcgNTQ5IGIgNDgwIDQ3MSA1MDcgNTE0IDQ5OCA0ODkgbCA0NzcgNDY3IGwgNDgzIDQ3MCBiIDYwOSA1OTEgNTM5IDQ4NSA1ODYgNTMxIGIgNjEzIDYwMSA2MTEgNTk1IDYxMyA1OTkgYiA2MzEgNjA5IDYxOSA2MDcgNjI0IDYwOSBiIDY1MSA1ODggNjQxIDYwOSA2NTEgNjAyIGIgMjAwIC05NDYgNjUxIDU4NCAyMDQgLTk0MSBiIDE4MiAtOTU3IDE5NyAtOTUzIDE5MCAtOTU3IGIgMTYzIC05NDUgMTc0IC05NTcgMTY2IC05NTMgYiAxNjEgLTkzOSAxNjEgLTk0MiAxNjEgLTk0MiBiIDIxNyAtNzQzIDE2MSAtOTMxIDE3MCAtOTA0IGIgMjcyIC01NTUgMjQ3IC02MzkgMjcyIC01NTUgYiAyNzIgLTU1NSAyNzIgLTU1NSAyNzIgLTU1NSBiIDI2NCAtNTYwIDI3MiAtNTU1IDI2OCAtNTU3IGIgMTQwIC02MDMgMjI3IC01ODkgMTgyIC02MDMgYiAzNiAtNTY3IDEwMiAtNjAzIDY1IC01OTIgYiAtMSAtNDg3IDEyIC01NDggLTEgLTUxNyBiIDE3IC00MjcgLTEgLTQ2NiA1IC00NDUgYiAxMDMgLTM4MCAzOCAtMzk1IDcwIC0zODAgYiAxOTEgLTQzMyAxMzcgLTM4MCAxNzIgLTM5OCBiIDIwNSAtNDg0IDIwMSAtNDQ4IDIwNSAtNDY2IGIgMTc4IC01NTMgMjA1IC01MDkgMTk2IC01MzUgbCAxNzUgLTU1NyBsIDE4MiAtNTU1IGIgMzA3IC00MzUgMjM2IC01MzkgMjg0IC00OTQgYiAzNzIgLTIxMyAzMDggLTQzMCAzNzIgLTIxNSBiIDM3MiAtMjEzIDM3MiAtMjEzIDM3MiAtMjEzIGIgMzY0IC0yMTkgMzcyIC0yMTMgMzY4IC0yMTYgYiAyNDAgLTI2MiAzMjggLTI0NyAyODMgLTI2MiBiIDEzNyAtMjI2IDIwMiAtMjYyIDE2NiAtMjQ5IGIgOTkgLTE0NSAxMTIgLTIwNiA5OSAtMTc2IGIgMTE4IC04NCA5OSAtMTI0IDEwNiAtMTA0IGIgMjA0IC0zOCAxMzggLTU0IDE3MSAtMzggYiAyOTIgLTkxIDIzOCAtMzggMjczIC01NiBiIDMwNiAtMTQxIDMwMiAtMTA2IDMwNiAtMTI0IGIgMjc5IC0yMTIgMzA2IC0xNjcgMjk2IC0xOTQgbCAyNzYgLTIxNSBsIDI4MSAtMjEzIGIgNDA4IC05MyAzMzYgLTE5OCAzODUgLTE1MSBiIDQ3MyAxMjkgNDA5IC04OCA0NzMgMTI3IGIgNDczIDEyOSA0NzMgMTI5IDQ3MyAxMjkgYiA0NjUgMTIyIDQ3MyAxMjkgNDY5IDEyNiBiIDM0MSA4MCA0MjggOTQgMzgzIDgwIGIgMjM2IDExNSAzMDMgODAgMjY2IDkxIGIgMjAwIDE5NSAyMTMgMTM2IDIwMCAxNjUgYiAyMTcgMjU2IDIwMCAyMTcgMjA2IDIzOCBiIDMwNCAzMDMgMjM5IDI4NyAyNzIgMzAzIGIgMzkzIDI0OSAzMzggMzAzIDM3NCAyODUgYiA0MDYgMTk5IDQwMiAyMzQgNDA2IDIxNyBiIDM3OSAxMjkgNDA2IDE3MyAzOTcgMTQ4IGwgMzc3IDEyNiBsIDM4MiAxMjcgYiA1MDkgMjQ4IDQzNiAxNDIgNDg1IDE5MCBiIDU3NCA0NzAgNTEwIDI1NCA1NzQgNDY5IGIgNTc0IDQ3MCA1NzQgNDcwIDU3NCA0NzAgYiA1NjYgNDY0IDU3NCA0NzAgNTcwIDQ2NyBiIDQ0MiA0MjEgNTI5IDQzNSA0ODQgNDIxIGIgMzM3IDQ1OCA0MDQgNDIxIDM2NyA0MzMgYiAzMDAgNTM3IDMxMyA0NzggMzAwIDUwOCBiIDM4OSA2NDQgMzAwIDU4NSAzMzQgNjM1IFwifSxcInYzYlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NDg0LjU2MjUsXCJoYVwiOjQ5NCxcIm9cIjpcIm0gMjI4IDI0NSBiIDIzOSAyNDcgMjM0IDI0NyAyMzkgMjQ3IGIgMjQzIDI0NyAyNDAgMjQ3IDI0MiAyNDcgYiAzMDMgMjM4IDI1NyAyNDcgMjg3IDI0MiBiIDQ4NCAtMiA0MTcgMjA4IDQ4NCAxMDQgYiA0MTIgLTE3NyA0ODQgLTY1IDQ2MSAtMTI3IGIgMjQzIC0yNDggMzYzIC0yMjYgMzAzIC0yNDggYiA2IC02MyAxMzggLTI0OCAzNiAtMTgwIGIgMCAtMSAxIC00MSAwIC0yMCBiIDIyOCAyNDUgMCAxMjcgOTggMjQwIG0gMjU1IDE4MSBiIDI0MCAxODMgMjQ3IDE4MyAyNDUgMTgzIGIgMjMyIDE4MSAyMzggMTgzIDIzNSAxODMgYiAxNDIgMTUyIDIwMCAxODAgMTY4IDE3MCBsIDEzOCAxNDkgbCAxOTAgOTcgbCAyNDIgNDQgbCAyOTQgOTcgbCAzNDUgMTQ5IGwgMzQwIDE1MiBiIDI1NSAxODEgMzE1IDE2OSAyODQgMTgwIG0gMTQ3IC01NCBsIDE5NyAtMSBsIDE0NyA1MSBsIDk1IDEwNCBsIDkxIDk5IGIgNjIgLTEgNzIgNzAgNjIgMzQgYiA2NiAtNDMgNjIgLTE1IDYzIC0yOSBiIDkxIC0xMDEgNzIgLTYzIDgwIC04NCBsIDk1IC0xMDYgbCAxNDcgLTU0IG0gMzkzIDk5IGIgMzg5IDEwNCAzOTAgMTAyIDM4OSAxMDQgYiAzMzcgNTEgMzg5IDEwNCAzNjYgODAgbCAyODUgLTEgbCAzMzcgLTU0IGwgMzg5IC0xMDYgbCAzOTMgLTEwMSBiIDQyMSAtMSA0MTIgLTcyIDQyMSAtMzYgYiAzOTMgOTkgNDIxIDM0IDQxMiA2OSBtIDI5NCAtOTggYiAyNDIgLTQ1IDI2NSAtNjkgMjQyIC00NSBiIDE5MCAtOTggMjQyIC00NSAyMTkgLTY5IGwgMTM4IC0xNTEgbCAxNDIgLTE1NCBiIDI0MiAtMTg0IDE3MiAtMTc0IDIwNiAtMTg0IGIgMzQwIC0xNTQgMjc2IC0xODQgMzExIC0xNzQgbCAzNDUgLTE1MSBsIDI5NCAtOTggXCJ9LFwidjNjXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo0NTAuNTMxMjUsXCJoYVwiOjQ2MCxcIm9cIjpcIm0gMTg5IDMwMiBiIDIwNCAzMDMgMTkzIDMwMiAxOTggMzAzIGIgMzAzIDIyNCAyNTAgMzAzIDI5MiAyNzAgYiAzMDYgMTk5IDMwNCAyMTYgMzA2IDIwOCBiIDI3OSAxMjkgMzA2IDE3MyAyOTYgMTQ3IGwgMjc2IDEyNiBsIDI4MSAxMjcgYiA0MDggMjQ5IDMzNyAxNDIgMzg1IDE5MCBiIDQxMiAyNTkgNDA5IDI1NCA0MTIgMjU4IGIgNDMwIDI2NyA0MTcgMjY1IDQyMyAyNjcgYiA0NTAgMjQ3IDQ0MSAyNjcgNDUwIDI1OSBiIDIwMCAtNjA1IDQ1MCAyNDIgMjA0IC01OTkgYiAxODIgLTYxNiAxOTcgLTYxMiAxOTAgLTYxNiBiIDE2MyAtNjAyIDE3NCAtNjE2IDE2NiAtNjEwIGIgMTYxIC01OTggMTYxIC02MDEgMTYxIC02MDEgYiAyMTcgLTQwMiAxNjEgLTU4OSAxNzAgLTU2MiBiIDI3MiAtMjEzIDI0NyAtMjk4IDI3MiAtMjEzIGIgMjcyIC0yMTMgMjcyIC0yMTMgMjcyIC0yMTMgYiAyNjQgLTIxOSAyNzIgLTIxMyAyNjggLTIxNiBiIDE0MCAtMjYyIDIyNyAtMjQ3IDE4MiAtMjYyIGIgMzYgLTIyNiAxMDIgLTI2MiA2NSAtMjQ5IGIgMCAtMTQ1IDEyIC0yMDYgMCAtMTc2IGIgMTcgLTg0IDAgLTEyNCA1IC0xMDQgYiAxMDMgLTM4IDM4IC01NCA3MCAtMzggYiAxOTEgLTkxIDEzNyAtMzggMTcyIC01NiBiIDIwNSAtMTQxIDIwMSAtMTA2IDIwNSAtMTI0IGIgMTc4IC0yMTIgMjA1IC0xNjcgMTk2IC0xOTQgbCAxNzUgLTIxNSBsIDE4MiAtMjEzIGIgMzA3IC05MyAyMzYgLTE5OCAyODQgLTE1MSBiIDM3MiAxMjkgMzA4IC04OCAzNzIgMTI3IGIgMzcyIDEyOSAzNzIgMTI5IDM3MiAxMjkgYiAzNjQgMTIyIDM3MiAxMjkgMzY4IDEyNiBiIDI0MCA4MCAzMjggOTQgMjgzIDgwIGIgMTM3IDExNSAyMDIgODAgMTY2IDkxIGIgOTkgMTk0IDExMSAxMzYgOTkgMTY1IGIgMTg5IDMwMiA5OSAyNDQgMTMzIDI5MiBcIn0sXCJ2M2VcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQwNi45Njg3NSxcImhhXCI6NDE1LFwib1wiOlwibSAyMSAxODMgYiAyOCAxODMgMjQgMTgzIDI1IDE4MyBiIDQyIDE4MSAzNCAxODMgMzkgMTgzIGIgMTI3IDEwOCA0NyAxNzkgNDcgMTc5IGIgMjAyIDQxIDE2OCA3MiAyMDIgNDEgYiAyNzkgMTA4IDIwNCA0MSAyMzggNzIgYiAzNTcgMTc3IDMyMSAxNDUgMzU2IDE3NiBiIDM3NSAxODMgMzYzIDE4MSAzNzAgMTgzIGIgNDA2IDE1MSAzOTIgMTgzIDQwNiAxNjkgYiA0MDQgMTM3IDQwNiAxNDcgNDA1IDE0MSBiIDMyMiA2MiA0MDEgMTMxIDM5OCAxMjkgYiAyNTEgMCAyODQgMjcgMjUxIDAgYiAzMjIgLTYzIDI1MSAtMSAyODQgLTI5IGIgNDA0IC0xMzggMzk4IC0xMzAgNDAxIC0xMzMgYiA0MDYgLTE1MiA0MDUgLTE0MiA0MDYgLTE0OCBiIDM3NSAtMTg0IDQwNiAtMTcwIDM5MiAtMTg0IGIgMzU3IC0xNzkgMzcwIC0xODQgMzYzIC0xODMgYiAyNzkgLTEwOSAzNTYgLTE3NyAzMjEgLTE0NyBiIDIwMiAtNDMgMjM4IC03MyAyMDQgLTQzIGIgMTI3IC0xMDkgMjAyIC00MyAxNjggLTczIGIgNDkgLTE3OSA4NSAtMTQ3IDUwIC0xNzcgYiAzMSAtMTg0IDQzIC0xODMgMzYgLTE4NCBiIDAgLTE1MiAxMyAtMTg0IDAgLTE3MCBiIDIgLTEzOCAwIC0xNDggMCAtMTQyIGIgODMgLTYzIDUgLTEzMyA4IC0xMzAgYiAxNTUgMCAxMjIgLTI5IDE1NSAtMSBiIDgzIDYyIDE1NSAwIDEyMiAyNyBiIDggMTI5IDQzIDk3IDEwIDEyNyBiIDAgMTUxIDIgMTM2IDAgMTQ0IGIgMjEgMTgzIDAgMTY1IDggMTc3IFwifSxcInYzZlwiOntcInhfbWluXCI6LTI0LjUsXCJ4X21heFwiOjMxNy4xNDA2MjUsXCJoYVwiOjMyNCxcIm9cIjpcIm0gLTI0IC0xNDcgbCAtMjQgLTUgbCAtMjAgLTUgYiAtMSAtMTkgLTEyIC01IC00IC0xMSBiIDU4IC0xMjMgNiAtNDMgMzEgLTg2IGIgMTk2IC0yNzggOTMgLTE3MyAxMzQgLTIxOSBiIDMxNyAtNTcwIDI3NCAtMzU2IDMxNyAtNDYwIGIgMjk0IC03MTMgMzE3IC02MTcgMzA4IC02NjYgbCAyODkgLTcyNCBsIDI5NCAtNzM1IGIgMzE3IC04NzMgMzA4IC03ODAgMzE3IC04MjcgYiAyMzUgLTExMzIgMzE3IC05NjMgMjg4IC0xMDU0IGIgMjA5IC0xMTY1IDIyOCAtMTE0MCAyMjQgLTExNDYgYiAxODkgLTExNzcgMjA0IC0xMTcyIDE5NiAtMTE3NyBiIDE3MSAtMTE2NCAxODIgLTExNzcgMTc1IC0xMTcyIGIgMTY4IC0xMTU0IDE3MCAtMTE2MSAxNjggLTExNTkgYiAxODEgLTExMzIgMTY4IC0xMTQ5IDE3MiAtMTE0MiBiIDI2OSAtODkxIDIzOCAtMTA2NCAyNjkgLTk3NSBiIDI2OSAtODgxIDI2OSAtODg2IDI2OSAtODg0IGIgMjYyIC04MTQgMjY5IC04NTcgMjY1IC04MjcgYiAyNTggLTgwMCAyNjEgLTgxMSAyNTkgLTgwNiBiIDE0MiAtNjI4IDI0MCAtNzMxIDE5OCAtNjY3IGIgLTggLTU4OSAxMTIgLTYwNiA0NyAtNTg5IGIgLTIwIC01ODkgLTEzIC01ODkgLTE5IC01ODkgbCAtMjQgLTU4OSBsIC0yNCAtNDQ5IGwgLTI0IC0zMDggbCAtMjAgLTMwOCBiIC0xIC0zMjIgLTEyIC0zMDggLTQgLTMxMyBiIDU4IC00MjQgNiAtMzQ1IDMxIC0zODggYiAxOTQgLTU4MCA5MyAtNDc2IDEzNiAtNTIzIGIgMjU5IC02NjAgMjIxIC02MDYgMjQ1IC02MzUgYiAyNjEgLTY2MyAyNTkgLTY2MiAyNjEgLTY2MyBiIDI2NCAtNjU2IDI2MiAtNjYzIDI2MiAtNjYwIGIgMjY5IC01ODcgMjY4IC02MzIgMjY5IC02MTAgYiAyNjQgLTUyMSAyNjkgLTU2NiAyNjggLTU0NCBiIDI2MiAtNTEyIDI2NCAtNTE3IDI2MiAtNTEzIGIgMjU4IC00OTggMjYxIC01MDkgMjU5IC01MDMgYiAxNDIgLTMyNiAyNDAgLTQyOCAxOTggLTM2NSBiIC04IC0yODcgMTEyIC0zMDMgNDcgLTI4OCBiIC0yMCAtMjg3IC0xMyAtMjg3IC0xOSAtMjg3IGwgLTI0IC0yODcgbCAtMjQgLTE0NyBcIn0sXCJ2NDBcIjp7XCJ4X21pblwiOi0xLjM1OTM3NSxcInhfbWF4XCI6NDM2LjkyMTg3NSxcImhhXCI6NDQ2LFwib1wiOlwibSAyMTMgMjA1IGIgMjE3IDIwNSAyMTUgMjA1IDIxNiAyMDUgYiAyMzQgMTk0IDIyNCAyMDUgMjM0IDE5OSBiIDIzNiAxODcgMjM0IDE5NCAyMzUgMTkwIGwgMjQ1IDE2NyBsIDI2MSAxMjkgbCAyNzAgMTA2IGIgMzU1IC02MSAyOTQgNTQgMzI5IC0xMyBiIDQyMCAtMTYzIDM4MSAtMTA1IDQwMiAtMTM4IGIgNDM2IC0xODggNDM1IC0xODQgNDM2IC0xODQgYiA0MzYgLTE5MSA0MzYgLTE5MCA0MzYgLTE5MCBiIDQyMSAtMjA2IDQzNiAtMjAxIDQzMSAtMjA2IGwgNDIxIC0yMDYgbCA0MTYgLTIwNiBsIDQwNSAtMjAxIGIgMjE3IC0xNTggMzQ3IC0xNzIgMjgzIC0xNTggYiAzMSAtMjAxIDE1MyAtMTU4IDg4IC0xNzIgbCAyMCAtMjA2IGwgMTQgLTIwNiBsIDE0IC0yMDYgYiAwIC0xOTEgNSAtMjA2IDAgLTIwMSBiIC0xIC0xODggMCAtMTkwIC0xIC0xOTAgYiAxNCAtMTYzIC0xIC0xODYgMCAtMTg0IGIgOTUgLTM0IDM2IC0xMzYgNzIgLTc3IGIgMTY2IDEwNiAxMTkgOCAxNDggNjggbCAxNzUgMTI5IGwgMTgzIDE0OCBsIDIwMCAxODggYiAyMTMgMjA1IDIwNSAxOTkgMjA4IDIwMiBcIn0sXCJ2NDFcIjp7XCJ4X21pblwiOi0xLjM1OTM3NSxcInhfbWF4XCI6NTU2LjY4NzUsXCJoYVwiOjU2OCxcIm9cIjpcIm0gMjk0IDMyMiBiIDMxOCAzMjMgMjk5IDMyMiAzMDggMzIzIGIgMzYwIDMyMCAzMzQgMzIzIDM1MiAzMjIgYiA1MjYgMjE3IDQzMCAzMTAgNDkwIDI3MyBiIDU0MyAxNjYgNTM3IDIwMiA1NDMgMTg0IGIgNDQ3IDcwIDU0MyAxMTcgNTAzIDcwIGIgNDQ1IDcwIDQ0NyA3MCA0NDYgNzAgYiAzNTkgMTU5IDM5NCA3MiAzNTkgMTEzIGIgMzY4IDIwMSAzNTkgMTczIDM2MiAxODcgYiA0NDIgMjQ1IDM4MiAyMjkgNDEyIDI0NSBiIDQ1NSAyNDQgNDQ2IDI0NSA0NTEgMjQ1IGIgNDYwIDI0NCA0NTggMjQ0IDQ2MCAyNDQgYiA0NjAgMjQ0IDQ2MCAyNDQgNDYwIDI0NCBiIDQ1NCAyNDggNDYwIDI0NCA0NTggMjQ1IGIgMzI1IDI5MSA0MTcgMjc2IDM3MiAyOTEgYiAyODUgMjg3IDMxMyAyOTEgMjk5IDI5MCBiIDE0NCAtMiAxODMgMjY5IDE0NCAxOTAgYiAyODEgLTI5MCAxNDQgLTIwOCAxNzkgLTI4MCBiIDMwNCAtMjkxIDI4OSAtMjkxIDI5OCAtMjkxIGIgNTI0IC0xMDUgNDEyIC0yOTEgNTA2IC0yMTIgYiA1NDEgLTg0IDUyNiAtODggNTMwIC04NCBiIDU1NiAtMTAxIDU1MSAtODQgNTU2IC05MCBiIDU0OSAtMTM4IDU1NiAtMTExIDU1MyAtMTIyIGIgMzM0IC0zMjIgNTIxIC0yMzcgNDM1IC0zMTAgYiAzMDIgLTMyNCAzMjMgLTMyMyAzMTMgLTMyNCBiIDEzIC0xMDEgMTcyIC0zMjQgNTQgLTIzNCBiIC0xIC0xIDQgLTY4IC0xIC0zNCBiIDI5NCAzMjIgLTEgMTYxIDEyMSAzMDMgXCJ9LFwidjQyXCI6e1wieF9taW5cIjotMzQ4LjQzNzUsXCJ4X21heFwiOjI0LjUsXCJoYVwiOjI1LFwib1wiOlwibSAtMzMwIDE1NSBiIC0zMjIgMTU2IC0zMjkgMTU2IC0zMjYgMTU2IGIgLTMxNSAxNTYgLTMxOSAxNTYgLTMxNyAxNTYgYiAtMjk4IDE0NyAtMzExIDE1NSAtMzA4IDE1NCBiIC0xOSAzMCAtMjI0IDk4IC0xMjIgNTUgbCAyIDI2IGIgMjQgLTEgMTcgMjIgMjQgMTMgYiAyIC0yNyAyNCAtMTUgMTcgLTIzIGwgLTE5IC0zMSBiIC0yOTggLTE0OCAtMTIyIC01NiAtMjI0IC05OSBiIC0zMjIgLTE1OCAtMzEzIC0xNTggLTMxNSAtMTU4IGIgLTM0OCAtMTMxIC0zMzggLTE1OCAtMzQ4IC0xNDUgYiAtMzQ0IC0xMTcgLTM0OCAtMTI3IC0zNDcgLTEyMiBiIC0zMjggLTEwNCAtMzQxIC0xMTIgLTMzOCAtMTExIGIgLTEyNyAtOCAtMjY5IC02NSAtMjAyIC0zMyBiIC0xMDYgMCAtMTE1IC00IC0xMDYgLTEgYiAtMTI3IDYgLTEwNiAwIC0xMTUgMiBiIC0zMjggMTAyIC0yMDIgMzEgLTI2OSA2MyBiIC0zNDQgMTE2IC0zMzggMTA5IC0zNDEgMTExIGIgLTM0OCAxMzAgLTM0NyAxMjAgLTM0OCAxMjQgYiAtMzMwIDE1NSAtMzQ4IDE0MSAtMzQxIDE1MiBcIn0sXCJ2NDNcIjp7XCJ4X21pblwiOi00NDIuMzU5Mzc1LFwieF9tYXhcIjo0NDEsXCJoYVwiOjQ1MCxcIm9cIjpcIm0gLTMxIDQ4NyBiIC0xIDQ4OCAtMjEgNDg4IC0xMCA0ODggYiA0MzQgMTA0IDIxNiA0ODggMzk3IDMzMCBiIDQ0MSAyNyA0MzggNzkgNDQxIDQ3IGIgNDM5IDEyIDQ0MSAyMCA0MzkgMTUgYiA0MTkgMCA0MzUgNCA0MjcgMCBiIDQwNCA1IDQxMyAwIDQwOCAxIGIgMzk4IDMwIDQwMCAxMSAzOTggMTMgYiAwIDM1MSAzOTAgMjEzIDIxMyAzNTEgYiAtNTkgMzQ4IC0yMCAzNTEgLTM5IDM0OSBiIC00MDAgMzAgLTI1MSAzMjQgLTM5MyAxOTEgYiAtNDA1IDUgLTQwMCAxMyAtNDAxIDExIGIgLTQyMCAwIC00MDkgMSAtNDE1IDAgYiAtNDQxIDEyIC00MjggMCAtNDM2IDQgYiAtNDQyIDI3IC00NDEgMTUgLTQ0MiAyMCBiIC00MzUgMTA0IC00NDIgNDcgLTQzOSA3OSBiIC0zMSA0ODcgLTQwMSAzMTYgLTIzNSA0NzQgbSAtMTMgMTMxIGIgLTEgMTMzIC05IDEzMyAtNSAxMzMgYiA1MSAxMDUgMTkgMTMzIDM5IDEyMyBiIDYxIDcwIDU4IDk1IDYxIDgzIGIgNTEgMzQgNjEgNTggNTggNDUgYiAtMSA2IDM5IDE2IDE5IDYgYiAtNDYgMjcgLTE3IDYgLTM0IDEzIGIgLTYyIDY5IC01NyAzOCAtNjIgNTQgYiAtMTMgMTMxIC02MiA5OCAtNDQgMTI0IFwifSxcInY0NFwiOntcInhfbWluXCI6LTIxLjc4MTI1LFwieF9tYXhcIjoyNTEuODEyNSxcImhhXCI6MjU3LFwib1wiOlwibSAtOCA2MzEgYiAtMSA2MzIgLTYgNjMyIC00IDYzMiBiIDE5IDYyMCA4IDYzMiAxNiA2MjggYiAyMCAzODMgMjAgNjE2IDIwIDYxNiBsIDIwIDE0OCBsIDIxIDE1MSBiIDEzNyAxOTkgNTkgMTgzIDk5IDE5OSBiIDE4MiAxOTEgMTUyIDE5OSAxNjcgMTk3IGIgMjUxIDg0IDIyNyAxNzYgMjUxIDEzNCBiIDIyOCAwIDI1MSA1OCAyNDMgMjkgYiAxMDAgLTE0MiAyMDYgLTQwIDE3OCAtNzIgbCAyMyAtMjE1IGIgMCAtMjI5IDkgLTIyOSA2IC0yMjkgYiAtMjAgLTIxNiAtOSAtMjI5IC0xNyAtMjI0IGwgLTIxIC0yMTIgbCAtMjEgMjAxIGwgLTIxIDYxNiBsIC0yMCA2MjAgYiAtOCA2MzEgLTE3IDYyNCAtMTMgNjMwIG0gMTEwIDEzMSBiIDk2IDEzMyAxMDYgMTMzIDEwMCAxMzMgYiA4OSAxMzMgOTMgMTMzIDkxIDEzMyBiIDI0IDg3IDYzIDEyOSA0MCAxMTMgbCAyMCA4MCBsIDIwIC0zNyBsIDIwIC0xNTYgbCAyMyAtMTUyIGIgMTQ0IDgxIDk2IC03MiAxNDQgMjAgbCAxNDQgODMgYiAxMTAgMTMxIDE0NCAxMTMgMTM0IDEyNiBcIn0sXCJ2NDVcIjp7XCJ4X21pblwiOi00MDIuODkwNjI1LFwieF9tYXhcIjo0MDEuNTMxMjUsXCJoYVwiOjQxMCxcIm9cIjpcIm0gLTEwIDI3MyBiIC00IDI3NCAtOSAyNzMgLTYgMjc0IGIgMTYgMjYyIDQgMjc0IDEyIDI2OSBiIDE3IDE1OCAxNyAyNTkgMTcgMjU5IGwgMTcgNTYgbCA2MiAxMTIgYiAxMTcgMTc0IDExMCAxNzIgMTEwIDE3MiBiIDEyMiAxNzQgMTE4IDE3NCAxMTkgMTc0IGIgMTMyIDE3MyAxMjUgMTc0IDEyOSAxNzMgYiAyOTUgMTEgMTM0IDE3MiAxNzEgMTM0IGwgMzA3IC0xIGwgMzM2IDM0IGIgMzc0IDc2IDM2NiA3MiAzNjggNzQgYiAzODEgNzcgMzc1IDc3IDM3OCA3NyBiIDQwMSA1NiAzOTIgNzcgNDAxIDY4IGIgNDAwIDQ4IDQwMSA1NCA0MDEgNTEgYiAyMjMgLTE3MiAzOTcgNDEgMjMwIC0xNjYgYiAyMTAgLTE3NiAyMjAgLTE3NCAyMTUgLTE3NiBiIDIwMSAtMTc0IDIwNiAtMTc2IDIwNCAtMTc2IGIgMTEyIC04NyAxOTggLTE3MyAxNzggLTE1MiBiIDI3IDAgNjUgLTM4IDI3IDAgYiAyMSAtNiAyNyAwIDI0IC0yIGwgMTcgLTEyIGwgMTcgLTE0NyBiIDE3IC0yMTAgMTcgLTE3MyAxNyAtMTk0IGIgMTAgLTI5MiAxNyAtMjk3IDE2IC0yODcgYiAtMiAtMjk5IDYgLTI5NyAyIC0yOTkgYiAtMjEgLTI4NyAtMTAgLTI5OSAtMTkgLTI5NSBiIC0yNCAtMTc0IC0yMyAtMjg0IC0yMyAtMjg0IGwgLTI0IC02MyBsIC02NiAtMTE3IGIgLTEyMSAtMTc2IC0xMTAgLTE3MCAtMTE0IC0xNzYgYiAtMTI1IC0xNzYgLTEyMiAtMTc2IC0xMjMgLTE3NiBiIC0yOTYgLTEyIC0xMzQgLTE3NCAtMTI1IC0xODQgbCAtMzA4IDAgbCAtMzM3IC0zNCBiIC0zNzUgLTc3IC0zNjcgLTczIC0zNzAgLTc2IGIgLTM4MiAtNzkgLTM3NyAtNzkgLTM3OSAtNzkgYiAtNDAyIC01OCAtMzkzIC03OSAtNDAyIC02OSBiIC00MDEgLTQ5IC00MDIgLTU1IC00MDIgLTUyIGIgLTIyNCAxNzAgLTM5OCAtNDMgLTIzMSAxNjUgYiAtMjEyIDE3NCAtMjIxIDE3MyAtMjE2IDE3NCBiIC0yMDIgMTczIC0yMDggMTc0IC0yMDUgMTc0IGIgLTM5IDExIC0yMDAgMTcyIC0xNTEgMTIyIGwgLTI4IC0xIGwgLTI1IDEgbCAtMjQgNCBsIC0yNCAxMzAgYiAtMjMgMjYwIC0yNCAyNTYgLTI0IDI1OCBiIC0xMCAyNzMgLTIwIDI2NiAtMTYgMjcwIFwifSxcInY0NlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjI3LjQ2ODc1LFwiaGFcIjo2NDAsXCJvXCI6XCJtIDMwNiAxOTAgYiAzMTQgMTkxIDMwOCAxOTEgMzExIDE5MSBiIDMyNiAxODQgMzE4IDE5MSAzMjIgMTkwIGwgMzM2IDE3MyBiIDUxMCA1MiAzNzcgMTI3IDQ0MiA4MCBiIDUxNSA0OSA1MTMgNTEgNTE1IDQ5IGIgNjExIDE2IDUzNyA0MCA1NzkgMjQgYiA2MjcgMCA2MjQgMTMgNjI3IDkgYiA2MDcgLTE4IDYyNyAtMTEgNjI0IC0xMyBiIDMzMCAtMTgxIDQ5MCAtNDkgMzg5IC0xMDkgYiAzMTQgLTE5MiAzMjMgLTE5MCAzMTkgLTE5MiBiIDMwNiAtMTkxIDMxMSAtMTkyIDMwOCAtMTkyIGIgMjk0IC0xNzcgMzAyIC0xODggMzAyIC0xODggYiAyNTcgLTE0MCAyODcgLTE3MCAyNjUgLTE0OCBiIDE5IC0xOCAxOTMgLTg0IDExNCAtNDQgYiAwIDAgMiAtMTMgMCAtMTEgYiAxNiAxNiAwIDkgMiAxMyBiIDExMCA0OSA0NyAyNCA4OSA0MCBiIDExNyA1MiAxMTEgNDkgMTE0IDUxIGIgMTQ1IDY1IDEyNiA1NiAxMzAgNTggYiAyODEgMTYzIDIwMCA5MyAyNDUgMTI0IGIgMzAwIDE4NiAyODggMTcwIDI5MSAxNzQgYiAzMDYgMTkwIDMwMCAxODcgMzAzIDE4OCBtIDMxNyAxMzcgYiAzMTMgMTQyIDMxNSAxNDEgMzE0IDE0MiBiIDMwOCAxMzcgMzEzIDE0MiAzMTEgMTQxIGIgMTYxIDQgMjc2IDg0IDIyMCAzMyBiIDE1NSAwIDE1OSAxIDE1NSAwIGIgMTYzIC00IDE1NSAwIDE1OSAtMiBiIDMwOCAtMTM4IDIyMCAtMzQgMjc2IC04NCBiIDMxMyAtMTQyIDMxMSAtMTQxIDMxMyAtMTQyIGIgMzE3IC0xMzggMzE0IC0xNDIgMzE1IC0xNDEgYiA0NjQgLTQgMzUxIC04NCA0MDYgLTM0IGIgNDcwIDAgNDY4IC0yIDQ3MCAwIGIgNDY0IDQgNDcwIDAgNDY4IDEgYiAzMTcgMTM3IDQwNiAzMyAzNTEgODQgXCJ9LFwidjQ3XCI6e1wieF9taW5cIjotMjQuNSxcInhfbWF4XCI6MzE1Ljc4MTI1LFwiaGFcIjozMjIsXCJvXCI6XCJtIC0yNCAtMTQ1IGwgLTI0IC01IGwgLTIwIC01IGIgMSAtMjYgLTEwIC01IC02IC05IGIgMTc1IC0yNDEgMzEgLTg2IDk2IC0xNjYgYiAzMTQgLTU0OCAyNTkgLTMyMyAzMDQgLTQyMCBiIDMxNSAtNTg5IDMxNSAtNTU1IDMxNSAtNTcxIGIgMzE0IC02MzAgMzE1IC02MDYgMzE1IC02MjMgYiAyOTggLTczMCAzMTEgLTY2NCAzMDYgLTY5OSBsIDI5NSAtNzQyIGwgMjk2IC03NDggYiAzMTQgLTg1MCAzMDQgLTc3OCAzMTEgLTgxMyBiIDMxNSAtODkyIDMxNSAtODU3IDMxNSAtODc0IGIgMzE0IC05MzIgMzE1IC05MDkgMzE1IC05MjUgYiAyOTggLTEwMzIgMzExIC05NjcgMzA2IC0xMDAyIGwgMjk1IC0xMDQ1IGwgMjk2IC0xMDUwIGIgMzE0IC0xMTUzIDMwNCAtMTA4MSAzMTEgLTExMTUgYiAzMTUgLTExOTMgMzE1IC0xMTYwIDMxNSAtMTE3NyBiIDMxNCAtMTIzNSAzMTUgLTEyMTEgMzE1IC0xMjI4IGIgMjE3IC0xNTI2IDMwNiAtMTMzOCAyNzAgLTE0NDQgYiAyMDEgLTE1MzMgMjEzIC0xNTMyIDIwOCAtMTUzMyBiIDE4MiAtMTUyMiAxOTMgLTE1MzMgMTg1IC0xNTI5IGIgMTc5IC0xNTE0IDE4MSAtMTUxOCAxNzkgLTE1MTcgYiAxODkgLTE0ODkgMTc5IC0xNTA4IDE4MiAtMTUwMSBiIDI2NiAtMTIxNyAyNDAgLTE0MDMgMjY2IC0xMzA4IGIgMjYyIC0xMTU2IDI2NiAtMTE5NiAyNjUgLTExNzcgYiAxMTAgLTkwNyAyNDcgLTEwNDMgMTkwIC05NTAgYiAwIC04ODkgODcgLTg5NSA1MCAtODg5IGwgLTEgLTg4OSBsIC0yNCAtODg5IGwgLTI0IC03NDkgbCAtMjQgLTYxMCBsIC0yMCAtNjEwIGIgMSAtNjMxIC0xMCAtNjEwIC02IC02MTQgYiAxNzUgLTg0NiAzMSAtNjkxIDk2IC03NzEgYiAyNTkgLTk1NiAyMTMgLTg4NCAyMzYgLTkxNCBiIDI2NSAtOTY2IDI2MiAtOTYxIDI2NCAtOTY2IGIgMjY1IC05NjYgMjY1IC05NjYgMjY1IC05NjYgYiAyNjUgLTk1MyAyNjUgLTk2NCAyNjUgLTk1OSBiIDI2NiAtOTIwIDI2NiAtOTQzIDI2NiAtOTMyIGIgMjYyIC04NTMgMjY2IC04OTggMjY1IC04NzMgYiAxMTAgLTYwNSAyNDcgLTc0MSAxOTAgLTY0OCBiIDAgLTU4NyA4NyAtNTkyIDUwIC01ODcgbCAtMSAtNTg3IGwgLTI0IC01ODcgbCAtMjQgLTQ0OCBsIC0yNCAtMzA4IGwgLTIwIC0zMDggYiAxIC0zMjggLTEwIC0zMDggLTYgLTMxMiBiIDE3NSAtNTQ0IDMxIC0zODggOTYgLTQ2OSBiIDI1OSAtNjU1IDIxMyAtNTgxIDIzNiAtNjEyIGIgMjY1IC02NjMgMjYyIC02NTkgMjY0IC02NjMgYiAyNjUgLTY2MyAyNjUgLTY2MyAyNjUgLTY2MyBiIDI2NSAtNjUwIDI2NSAtNjYzIDI2NSAtNjU3IGIgMjY2IC02MTcgMjY2IC02NDEgMjY2IC02MzAgYiAyNjIgLTU1MSAyNjYgLTU5NSAyNjUgLTU3MCBiIDExMCAtMzAzIDI0NyAtNDM4IDE5MCAtMzQ1IGIgMCAtMjg0IDg3IC0yOTAgNTAgLTI4NCBsIC0xIC0yODQgbCAtMjQgLTI4NCBsIC0yNCAtMTQ1IFwifSxcInY0OVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjMwLjIwMzEyNSxcImhhXCI6NjQzLFwib1wiOlwibSAzMDggMjA0IGIgMzE0IDIwNSAzMTAgMjA1IDMxMyAyMDUgYiAzMjYgMjAxIDMxOSAyMDUgMzIzIDIwNCBiIDM1NSAxNTQgMzI4IDE5OSAzMzggMTgwIGIgNDAxIDgzIDM2MiAxNDIgMzkyIDk1IGwgNDA5IDcyIGIgNDMxIDQxIDQxMiA2NiA0MjQgNDkgYiA2MTkgLTE3NCA0OTggLTUxIDU3MCAtMTM0IGIgNjMwIC0xOTIgNjI2IC0xODAgNjMwIC0xODYgYiA2MjYgLTIwMiA2MzAgLTE5NSA2MjggLTE5OSBiIDYxNiAtMjA2IDYyMyAtMjA1IDYyMCAtMjA2IGIgNTUyIC0xODggNjA4IC0yMDYgNTkyIC0yMDIgYiAzMTAgLTE1NSA0ODggLTE2OSAzOTIgLTE1NSBiIDI2OCAtMTU2IDI5NSAtMTU1IDI4MSAtMTU1IGIgNzcgLTE4OCAxOTcgLTE2MSAxMjYgLTE3MyBiIDEzIC0yMDYgMzUgLTIwMiAyMCAtMjA2IGIgOSAtMjA2IDEyIC0yMDYgMTAgLTIwNiBiIDAgLTE5MSAyIC0yMDIgMCAtMTk3IGIgOCAtMTc2IDAgLTE4NiAyIC0xODAgYiAyMDQgNDkgNTggLTEzNiAxMzggLTQzIGwgMjIwIDcyIGwgMjI3IDgzIGIgMjk1IDE4OCAyNDUgMTA4IDI4MSAxNjYgYiAzMDggMjA0IDI5OSAxOTcgMzA0IDIwMiBtIDMxNSAxNDcgYiAzMTQgMTQ3IDMxNSAxNDcgMzE0IDE0NyBiIDMxNCAxNDcgMzE0IDE0NyAzMTQgMTQ3IGIgMzA2IDEyOSAzMTQgMTQ1IDMxMCAxMzggbCAyOTYgMTA1IGIgMjgxIDcyIDI5MiA5NyAyODQgNzcgbCAyNzQgNTYgYiAxODEgLTEyMyAyNDcgLTQgMjEyIC03MiBsIDE3NCAtMTM0IGwgMTc2IC0xMzMgYiAzMTQgLTEyMyAyMTUgLTEyNyAyNzIgLTEyMyBiIDQ1MSAtMTMzIDM1NiAtMTIzIDQxMyAtMTI3IGwgNDU0IC0xMzQgbCA0NDkgLTEyMyBiIDM1MyA1NiA0MTcgLTcyIDM4MSAtNCBsIDM0NyA3MiBiIDMzMiAxMDUgMzQ0IDc3IDMzNiA5NyBsIDMyMiAxMjkgYiAzMTUgMTQ3IDMxOCAxMzggMzE1IDE0NSBcIn0sXCJ2NGFcIjp7XCJ4X21pblwiOjcwLjc4MTI1LFwieF9tYXhcIjozNzguMzkwNjI1LFwiaGFcIjozMTUsXCJvXCI6XCJtIDI0NiAzNzMgYiAyNTQgMzczIDI0OSAzNzMgMjUxIDM3MyBiIDM3MiAzMjQgMzAzIDM3MyAzNjAgMzUxIGIgMzc4IDMwMiAzNzcgMzE3IDM3OCAzMDkgYiAzMzggMjUxIDM3OCAyNzggMzYyIDI1NSBiIDMyOCAyNDkgMzM0IDI0OSAzMzIgMjQ5IGIgMjgzIDI5NCAzMDMgMjQ5IDI4MyAyNzAgYiAyODggMzE1IDI4MyAzMDEgMjg0IDMwOCBiIDI4OSAzMTkgMjg5IDMxNyAyODkgMzE5IGIgMjg5IDMxOSAyODkgMzE5IDI4OSAzMTkgYiAyODMgMzIwIDI4OSAzMjAgMjg3IDMyMCBiIDI3MCAzMjIgMjc5IDMyMiAyNzQgMzIyIGIgMjA2IDI4OCAyNDIgMzIyIDIxNSAzMDggYiAyMDYgMjgzIDIwNiAyODcgMjA2IDI4NSBiIDI1NyAyMjMgMjA2IDI2NyAyMzAgMjM4IGIgMjg0IDIwNiAyNzIgMjEzIDI3NyAyMTAgYiAzNTEgOTAgMzI4IDE3MyAzNTEgMTMwIGIgMzQwIDQ3IDM1MSA3NCAzNDggNTkgYiAyMDUgLTMwIDMxNCAtMiAyNjQgLTMwIGIgMTgyIC0yOSAxOTggLTMwIDE5MCAtMzAgYiA4NCAxNSAxNDcgLTI0IDEwMyAtNSBiIDcwIDQ4IDc0IDI0IDcwIDM2IGIgMTA4IDk5IDcwIDcwIDg1IDk0IGIgMTIxIDEwMiAxMTIgMTAxIDExNyAxMDIgYiAxNjcgNTYgMTQ3IDEwMiAxNjcgODAgYiAxNTkgMzEgMTY3IDQ4IDE2NCA0MCBsIDE1NiAyNiBsIDE1NyAyNiBiIDE5MCAyMCAxNjcgMjIgMTc4IDIwIGIgMjIwIDI2IDIwMSAyMCAyMTIgMjIgYiAyNTggNjUgMjQzIDM0IDI1OCA1MSBiIDI1NyA3MCAyNTggNjYgMjU4IDY5IGIgMjA0IDEyNiAyNDkgOTQgMjM0IDEwOSBiIDExNCAyNTggMTQ4IDE1OCAxMTQgMjA5IGIgMTI1IDMwMiAxMTQgMjczIDExOCAyODggYiAyNDYgMzczIDE0NyAzNDIgMTkzIDM3MCBcIn0sXCJ2NGJcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjUwMy42MDkzNzUsXCJoYVwiOjUxNCxcIm9cIjpcIm0gMjc0IDQzMCBiIDI3NyA0MzAgMjc2IDQzMCAyNzcgNDMwIGIgMzEwIDM5NCAyOTYgNDMwIDMxMCA0MTUgYiAzMDggMzgzIDMxMCAzOTEgMzA4IDM4NyBiIDMwNiAzNjcgMzA3IDM4MSAzMDcgMzc0IGIgMjM2IDEyMCAyOTggMzA1IDI3MiAyMTAgYiA0MCAtMjczIDE4OSAtNSAxMjUgLTEzNCBiIDIwIC0yODcgMzUgLTI4MyAyNyAtMjg3IGIgNSAtMjgxIDE0IC0yODcgOSAtMjg1IGIgMCAtMjY3IDEgLTI3NyAwIC0yNzMgYiA5IC0yNDIgMCAtMjYyIDIgLTI1NSBiIDI0NiAzOTUgMTM3IC0xMiAyMzIgMjQyIGIgMjc0IDQzMCAyNDkgNDE2IDI1NyA0MjcgbSA0NjggNDMwIGIgNDcyIDQzMCA0NjkgNDMwIDQ3MCA0MzAgYiA1MDMgMzk0IDQ5MCA0MzAgNTAzIDQxNSBiIDUwMiAzODMgNTAzIDM5MSA1MDMgMzg3IGIgNDk5IDM2NyA1MDIgMzgxIDUwMCAzNzQgYiA0MzEgMTIwIDQ5MSAzMDUgNDY1IDIxMCBiIDIzNCAtMjczIDM4MiAtNSAzMTggLTEzNCBiIDIxMyAtMjg3IDIyOCAtMjgzIDIyMCAtMjg3IGIgMTk4IC0yODEgMjA4IC0yODcgMjAyIC0yODUgYiAxOTMgLTI2NyAxOTQgLTI3NyAxOTMgLTI3MyBiIDIwMiAtMjQyIDE5MyAtMjYyIDE5NiAtMjU1IGIgNDM5IDM5NSAzMzAgLTEyIDQyNiAyNDIgYiA0NjggNDMwIDQ0MiA0MTYgNDUxIDQyNyBcIn0sXCJ2NGRcIjp7XCJ4X21pblwiOi0zMTEuNjg3NSxcInhfbWF4XCI6MzEwLjMyODEyNSxcImhhXCI6MzE3LFwib1wiOlwibSAtOSAzODggYiAtMiAzOTAgLTggMzkwIC01IDM5MCBiIDUgMzg4IDEgMzkwIDQgMzkwIGIgMTkgMzc4IDEwIDM4NyAxNiAzODMgYiAyMyAzMzMgMjMgMzcxIDIzIDM3MSBiIDI0IDI5OCAyMyAyOTkgMjQgMjk4IGIgODEgMjc2IDM0IDI5OCA2NSAyODUgYiAyMTMgOTEgMTQ1IDI0MCAxOTAgMTc3IGIgMjI0IDI0IDIxNyA3NiAyMjQgMzYgYiAyNTcgMjQgMjI0IDI0IDIzNSAyNCBiIDI5OSAxOSAyOTIgMjQgMjkyIDI0IGIgMzEwIC0xIDMwNiAxNSAzMTAgNiBiIDI5OSAtMjMgMzEwIC0xMSAzMDYgLTE5IGIgMjU3IC0yNyAyOTIgLTI3IDI5MiAtMjcgYiAyMjQgLTI5IDIzNSAtMjcgMjI0IC0yOSBiIDIxMyAtOTUgMjI0IC00MCAyMTcgLTgwIGIgODEgLTI4MCAxOTAgLTE4MSAxNDUgLTI0NCBiIDI0IC0zMDEgNjUgLTI5MCAzNCAtMzAxIGIgMjMgLTMzNSAyNCAtMzAxIDIzIC0zMDMgbCAyMyAtMzQwIGIgMTcgLTM4MSAyMyAtMzc0IDIzIC0zNzQgYiAtMSAtMzkxIDEzIC0zODggNSAtMzkxIGIgLTIxIC0zODEgLTkgLTM5MSAtMTcgLTM4OCBiIC0yNyAtMzQwIC0yNyAtMzc0IC0yNyAtMzc0IGwgLTI3IC0zMzUgYiAtMjggLTMwMSAtMjcgLTMwMyAtMjcgLTMwMSBiIC04NSAtMjgwIC0zOCAtMzAxIC02OSAtMjkwIGIgLTIxNyAtOTUgLTE0OSAtMjQ0IC0xOTQgLTE4MSBiIC0yMjggLTI5IC0yMjEgLTgwIC0yMjggLTQwIGIgLTI1OSAtMjcgLTIyOCAtMjkgLTIzOCAtMjcgYiAtMzAwIC0yMyAtMjk0IC0yNyAtMjk0IC0yNyBiIC0zMTEgLTIgLTMwNyAtMTkgLTMxMSAtMTEgYiAtMjk0IDIzIC0zMTEgOCAtMzA0IDE5IGIgLTI1OSAyNCAtMjkxIDIzIC0yODQgMjQgYiAtMjI4IDI0IC0yMzkgMjQgLTIyOCAyNCBiIC0yMTcgOTEgLTIyOCAzNiAtMjIxIDc2IGIgLTg1IDI3NiAtMTk0IDE3NyAtMTQ5IDI0MCBiIC0yOCAyOTggLTY5IDI4NSAtMzggMjk4IGIgLTI3IDMzMyAtMjcgMjk4IC0yNyAyOTkgYiAtMjcgMzcxIC0yNyAzNjIgLTI3IDM2OSBiIC05IDM4OCAtMjQgMzc4IC0xNyAzODUgbSAtMjcgMTM2IGIgLTI4IDI0NyAtMjcgMTk3IC0yOCAyNDcgYiAtNjEgMjE2IC0zMSAyNDcgLTUzIDIyNiBiIC0xMjMgMzMgLTk1IDE3MiAtMTIxIDk4IGwgLTEyNSAyNCBsIC03NiAyNCBsIC0yNyAyNCBsIC0yNyAxMzYgbSAyOSAyNDIgYiAyNCAyNDcgMjcgMjQ1IDI0IDI0NyBiIDIzIDEzNiAyNCAyNDcgMjMgMTk3IGwgMjMgMjQgbCA3MiAyNCBsIDEyMSAyNCBsIDExOSAzMyBiIDI5IDI0MiAxMTUgMTE2IDc3IDIwNiBtIC0yNyAtMTQwIGwgLTI3IC0yNyBsIC03NiAtMjcgbCAtMTI1IC0yNyBsIC0xMjMgLTM2IGIgLTYxIC0yMjAgLTEyMSAtMTAyIC05NSAtMTc2IGIgLTI4IC0yNTEgLTUzIC0yMzAgLTMxIC0yNTEgYiAtMjcgLTE0MCAtMjggLTI1MSAtMjcgLTIwMSBtIDExOSAtMzYgbCAxMjEgLTI3IGwgNzIgLTI3IGwgMjMgLTI3IGwgMjMgLTE0MCBiIDI0IC0yNTEgMjMgLTIwMSAyNCAtMjUxIGIgNTcgLTIyMCAyNyAtMjUxIDQ5IC0yMzAgYiAxMTkgLTM2IDkxIC0xNzYgMTE3IC0xMDIgXCJ9LFwidjRlXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoyMzkuNTYyNSxcImhhXCI6MjQ0LFwib1wiOlwibSAxMCA0NjAgYiAyMCA0NjIgMTMgNDYyIDE0IDQ2MiBiIDM5IDQ0OSAyOCA0NjIgMzUgNDU4IGwgNDAgNDQ2IGwgNDAgMzI2IGIgNDAgMjA1IDQwIDI1OSA0MCAyMDUgYiAxMjcgMjI3IDQwIDIwNSA4MCAyMTUgYiAyMjAgMjQ5IDE5NiAyNDQgMjEzIDI0OSBiIDIyNyAyNDcgMjI0IDI0OSAyMjUgMjQ4IGIgMjM4IDIzNyAyMzEgMjQ1IDIzNSAyNDEgbCAyMzkgMjMzIGwgMjM5IC0xMDYgbCAyMzkgLTQ0OCBsIDIzOCAtNDUxIGIgMjE5IC00NjMgMjM0IC00NTkgMjI1IC00NjMgYiAxOTggLTQ1MSAyMTAgLTQ2MyAyMDIgLTQ1OSBsIDE5NyAtNDQ4IGwgMTk3IC0zMjQgYiAxOTcgLTIwMSAxOTcgLTI0OCAxOTcgLTIwMSBiIDExMCAtMjIzIDE5NiAtMjAxIDE1NyAtMjEwIGIgMTcgLTI0NSA0MiAtMjQwIDI0IC0yNDUgYiAxMCAtMjQyIDEzIC0yNDUgMTMgLTI0NCBiIDAgLTIzMyA2IC0yNDEgMiAtMjM3IGwgMCAtMjMwIGwgMCAxMDggbCAwIDQ0NiBsIDAgNDQ5IGIgMTAgNDYwIDIgNDUzIDYgNDU4IG0gMTk3IDIyIGIgMTk3IDcwIDE5NyA0MSAxOTcgNTggYiAxOTYgMTE2IDE5NyAxMTMgMTk3IDExNiBsIDE5NiAxMTYgYiAxMTggOTcgMTk2IDExNiAxNjAgMTA2IGwgNDAgNzcgbCA0MCAtMTggYiA0MCAtMTEyIDQwIC02OSA0MCAtMTEyIGwgMTE5IC05MyBsIDE5NyAtNzMgbCAxOTcgMjIgXCJ9LFwidjUxXCI6e1wieF9taW5cIjotMS4zNTkzNzUsXCJ4X21heFwiOjQ1NS45Njg3NSxcImhhXCI6NDY1LFwib1wiOlwibSAzNTIgNTQxIGIgMzU3IDU0MiAzNTMgNTQyIDM1NSA1NDIgYiAzNzcgNTMwIDM2NCA1NDIgMzcyIDUzNyBsIDM3OCA1MjYgbCAzNzggMzk0IGwgMzc5IDI2MiBsIDQwNCAyNjYgYiA0MzYgMjcwIDQyMCAyNjkgNDMwIDI3MCBiIDQ1MCAyNjUgNDQzIDI3MCA0NDYgMjY5IGIgNDU1IDIyMCA0NTUgMjU5IDQ1NSAyNjAgbCA0NTUgMjA4IGwgNDU1IDE2MSBsIDQ1NCAxNTYgYiA0MTEgMTQwIDQ0OSAxNDcgNDQ3IDE0NyBiIDM3OCAxMzMgMzkzIDEzNyAzNzkgMTM0IGIgMzc4IDY4IDM3OCAxMzMgMzc4IDEwNiBiIDM3OCAyMiAzNzggNTQgMzc4IDM4IGwgMzc5IC04NyBsIDQwNCAtODMgYiA0MzYgLTc5IDQyMCAtODAgNDMwIC03OSBiIDQ1MCAtODQgNDQzIC03OSA0NDYgLTgwIGIgNDU1IC0xMjkgNDU1IC05MCA0NTUgLTg4IGwgNDU1IC0xNDEgbCA0NTUgLTE4OCBsIDQ1NCAtMTkyIGIgNDEzIC0yMDkgNDQ5IC0yMDIgNDQ3IC0yMDIgYiAzODIgLTIxNSAzOTggLTIxMiAzODMgLTIxNSBsIDM3OCAtMjE1IGwgMzc4IC0zNDUgbCAzNzggLTM4MCBiIDM3NSAtNDg1IDM3OCAtNDg0IDM3OCAtNDgwIGIgMzU3IC00OTQgMzcxIC00OTEgMzY0IC00OTQgYiAzNDAgLTQ4NSAzNTEgLTQ5NCAzNDQgLTQ5MSBiIDMzNiAtMzgzIDMzNyAtNDgwIDMzNiAtNDg0IGwgMzM2IC0zNDkgbCAzMzYgLTIyMyBsIDMzNCAtMjIzIGIgMjkxIC0yMzEgMzM0IC0yMjMgMzE0IC0yMjcgbCAyNDcgLTI0MCBsIDI0NyAtMzcxIGwgMjQ2IC01MDMgbCAyNDUgLTUwNiBiIDIyNSAtNTE5IDI0MiAtNTE0IDIzNCAtNTE5IGIgMjA2IC01MDYgMjE5IC01MTkgMjEwIC01MTQgbCAyMDUgLTUwMyBsIDIwNSAtMzc2IGwgMjA1IC0yNDggbCAxNjAgLTI1NiBsIDExNSAtMjY1IGwgMTE1IC0zOTYgbCAxMTUgLTUyNyBsIDExNCAtNTMxIGIgOTUgLTU0NCAxMTAgLTUzOSAxMDIgLTU0NCBiIDc2IC01MzEgODcgLTU0NCA3OCAtNTM5IGwgNzMgLTUyNyBsIDczIC0zOTkgYiA3MyAtMjczIDczIC0zMzAgNzMgLTI3MyBiIDQ5IC0yNzcgNzMgLTI3MyA2MSAtMjc0IGIgMTcgLTI4MSAzMiAtMjgwIDI0IC0yODEgYiA0IC0yNzYgMTAgLTI4MSA4IC0yODAgYiAtMSAtMjM0IDAgLTI2OSAtMSAtMjcyIGIgMCAtMjE5IC0xIC0yMjkgMCAtMjI0IGwgMCAtMTcwIGwgMSAtMTY3IGIgMTAgLTE1OCAyIC0xNjMgNiAtMTU5IGIgNDkgLTE0OSAxMyAtMTU2IDE2IC0xNTUgbCA3MyAtMTQ1IGwgNzMgLTM0IGIgNzMgNzYgNzMgMjYgNzMgNzYgYiA0OSA3MiA3MyA3NiA2MSA3NCBiIDE3IDY4IDMyIDY5IDI0IDY4IGIgNCA3MyAxMCA2OCA4IDY5IGIgLTEgMTE1IDAgODAgLTEgNzcgYiAwIDEzMCAtMSAxMjAgMCAxMjQgbCAwIDE3OSBsIDEgMTgxIGIgMTAgMTkxIDIgMTg2IDYgMTkwIGIgNDkgMTk5IDEzIDE5MiAxNiAxOTQgbCA3MyAyMDQgbCA3MyAzMzggYiA3MyAzNzQgNzMgMzUyIDczIDM2NSBiIDc3IDQ4MyA3MyA0ODQgNzMgNDc3IGIgOTUgNDkyIDgxIDQ4OSA4OCA0OTIgYiAxMTEgNDgzIDEwMCA0OTIgMTA3IDQ4OSBiIDExNSAzNzggMTE1IDQ3NyAxMTUgNDgzIGwgMTE1IDM0MiBiIDExNyAyMTIgMTE1IDIyMyAxMTUgMjEyIGIgMjA0IDIyOSAxMTcgMjEyIDIwMCAyMjcgbCAyMDUgMjI5IGwgMjA1IDM2NSBsIDIwNSA1MDIgbCAyMDYgNTA1IGIgMjI1IDUxNyAyMTAgNTEzIDIxOSA1MTcgYiAyNDUgNTA1IDIzNCA1MTcgMjQyIDUxMyBsIDI0NiA1MDIgbCAyNDcgMzY5IGwgMjQ3IDIzNyBsIDI0OSAyMzcgYiAzMzYgMjU0IDI1MyAyMzggMzM2IDI1NCBiIDMzNyAzOTAgMzM2IDI1NCAzMzcgMzAyIGwgMzM3IDUyNiBsIDMzOCA1MzAgYiAzNTIgNTQxIDM0MSA1MzUgMzQ3IDUzOSBtIDMzNiAxNSBiIDMzNiAxMjYgMzM2IDEwMiAzMzYgMTI2IGwgMzM2IDEyNiBiIDI5MSAxMTcgMzM2IDEyNiAzMTUgMTIyIGwgMjQ3IDEwOSBsIDI0NyAtMSBsIDI0NyAtMTEyIGwgMjQ5IC0xMTIgYiAzMzYgLTk1IDI1MyAtMTExIDMzNiAtOTUgYiAzMzYgMTUgMzM2IC05NSAzMzYgLTU2IG0gMjA1IC0xMjAgYiAyMDUgLTU1IDIwNSAtMTIwIDIwNSAtOTMgYiAyMDUgLTkgMjA1IC00MSAyMDUgLTI0IGwgMjA1IDEwMSBsIDE2MCA5MyBsIDExNSA4NCBsIDExNSAtMjYgYiAxMTUgLTgzIDExNSAtNDkgMTE1IC02OSBiIDExNyAtMTM3IDExNSAtMTMzIDExNSAtMTM3IGIgMjA1IC0xMjAgMTE4IC0xMzcgMjA0IC0xMjAgXCJ9LFwidjUyXCI6e1wieF9taW5cIjotMTAuODkwNjI1LFwieF9tYXhcIjoyOTguMDc4MTI1LFwiaGFcIjoyOTQsXCJvXCI6XCJtIDEzOCA0NzMgYiAxNDIgNDc0IDE0MCA0NzMgMTQxIDQ3NCBiIDE2NCA0NTkgMTQ4IDQ3NCAxNTMgNDcwIGIgMTkxIDQwMiAxODMgNDQyIDE5MSA0MjMgYiAxODEgMzUzIDE5MSAzODggMTg3IDM3MSBiIDE3OCAzNDkgMTc5IDM1MiAxNzggMzQ5IGIgMTc5IDM0OCAxNzggMzQ4IDE3OSAzNDggYiAxODUgMzQ5IDE4MSAzNDggMTgyIDM0OCBiIDI1NSAzNzYgMjEwIDM1NSAyMzQgMzYzIGIgMjcyIDM4MSAyNjQgMzgxIDI2NiAzODEgYiAyOTggMzU1IDI4NyAzODEgMjk4IDM3MCBiIDI4OCAzMzAgMjk4IDM0OCAyOTggMzQ1IGIgMTcxIDM0IDIzOCAyNTQgMTk0IDE0MSBiIDE2NiAxMyAxNjggMTYgMTY4IDE2IGIgMTQ0IDEgMTYxIDUgMTUyIDEgYiAxMjEgMTUgMTM0IDEgMTI1IDUgYiAxMTUgMzMgMTE5IDE4IDExNyAyNCBiIDAgMzMwIDkxIDE0NSA0OSAyNTIgYiAtMTAgMzU1IC05IDM0NSAtMTAgMzQ4IGIgMTMgMzgxIC0xMCAzNzEgMCAzODEgYiAzMSAzNzYgMTkgMzgxIDI1IDM4MCBiIDEzMiAzNDUgNjEgMzU4IDEwMyAzNDUgbCAxMzYgMzQ1IGwgMTM3IDM1NSBiIDE0NSAzNzggMTM4IDM1OSAxNDIgMzcwIGIgMTUyIDQxNSAxNDkgMzk0IDE1MiA0MDUgYiAxMzcgNDUyIDE1MiA0MjcgMTQ4IDQzOCBiIDEzMyA0NjQgMTM0IDQ1OCAxMzMgNDYwIGIgMTM4IDQ3MyAxMzMgNDY3IDEzNCA0NzAgXCJ9LFwidjUzXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo5MDIuNDIxODc1LFwiaGFcIjo5MjEsXCJvXCI6XCJtIDE3IDI0MCBiIDI0IDI0MSAxOSAyNDEgMjEgMjQxIGIgMzIgMjQwIDI4IDI0MSAzMSAyNDEgYiA0NiAyMjkgMzggMjM4IDQzIDIzNCBiIDUwIDg4IDUwIDIyMyA1MCAyMzcgYiA1MCAtMSA1MCA2MyA1MCAzNCBiIDUwIC05MCA1MCAtMzYgNTAgLTY1IGIgNDYgLTIzMSA1MCAtMjM4IDUwIC0yMjQgYiAyNSAtMjQyIDQyIC0yMzggMzQgLTI0MiBiIDAgLTIyNCAxNCAtMjQyIDQgLTIzNSBiIDAgMiAwIC0yMjIgMCAtMTA4IGIgMCAyMjMgMCAxMTIgMCAyMjAgYiAxNyAyNDAgMiAyMzAgOSAyMzcgbSAxMTAgMjQwIGIgMTE4IDI0MSAxMTEgMjQxIDExNCAyNDEgYiAxMjYgMjQwIDEyMSAyNDEgMTIzIDI0MSBiIDE0MiAyMjMgMTMzIDIzNyAxNDAgMjMwIGIgMTQ0IDEyMyAxNDQgMjIwIDE0NCAyMDUgYiAxNDQgMjkgMTQ0IDQ1IDE0NCAyOSBiIDE0NCAyOSAxNDQgMjkgMTQ0IDI5IGIgMzkzIDE4MyAxNjYgMTA2IDI2NCAxNjcgYiA0NTAgMTg2IDQxMiAxODQgNDMxIDE4NiBiIDc1NiAyOSA2MDAgMTg2IDczMiAxMjAgYiA3NTYgMjkgNzU2IDI5IDc1NiAyOSBiIDc1OCAxMjMgNzU4IDI5IDc1OCA0NSBiIDc2MCAyMjcgNzU4IDIyNiA3NTggMjIzIGIgNzg0IDI0MSA3NjYgMjM3IDc3NCAyNDEgYiA4MDQgMjI5IDc5MiAyNDEgODAwIDIzNyBiIDgwOSA4OCA4MDggMjIzIDgwOSAyMzcgbCA4MDkgLTEgbCA4MDkgLTkwIGIgODA0IC0yMzEgODA5IC0yMzggODA4IC0yMjQgYiA3ODQgLTI0MiA4MDAgLTIzOCA3OTIgLTI0MiBiIDc2MiAtMjMxIDc3NSAtMjQyIDc2NiAtMjM4IGIgNzU4IC0xMjQgNzU2IC0yMjQgNzU4IC0yMzEgYiA3NTYgLTMwIDc1OCAtNDcgNzU4IC0zMCBiIDc1NiAtMzAgNzU2IC0zMCA3NTYgLTMwIGIgNTA5IC0xODQgNzM2IC0xMDggNjM3IC0xNjkgYiA0NTAgLTE4NyA0ODggLTE4NyA0NjkgLTE4NyBiIDE0NCAtMzAgMzAwIC0xODcgMTY4IC0xMjIgYiAxNDQgLTMwIDE0NCAtMzAgMTQ0IC0zMCBiIDE0NCAtMTI0IDE0NCAtMzAgMTQ0IC00NyBiIDE0MCAtMjMxIDE0NCAtMjMxIDE0NCAtMjI0IGIgMTE4IC0yNDIgMTM0IC0yMzggMTI2IC0yNDIgYiA5MiAtMjI0IDEwNyAtMjQyIDk2IC0yMzUgYiA5MiAyIDkyIC0yMjIgOTIgLTEwOCBiIDkyIDIyMyA5MiAxMTIgOTIgMjIwIGIgMTEwIDI0MCA5NSAyMzAgMTAyIDIzNyBtIDQzMiAxNjEgYiA0MTMgMTYyIDQyNiAxNjIgNDIwIDE2MiBiIDMxMyA0MSAzNTEgMTYyIDMxMyAxMDkgYiAzNDcgLTczIDMxMyA1IDMyMyAtMzQgYiA0ODcgLTE2MyAzODUgLTEzMyA0MzkgLTE2MyBiIDU3OCAtOTcgNTI2IC0xNjMgNTYyIC0xNDIgYiA1ODggLTQzIDU4NSAtODAgNTg4IC02MiBiIDQzMiAxNjEgNTg4IDQ3IDUxOCAxNDcgbSA4NjggMjQwIGIgODc2IDI0MSA4NjkgMjQxIDg3MiAyNDEgYiA4ODQgMjQwIDg3OSAyNDEgODgyIDI0MSBiIDg5OCAyMjkgODkwIDIzOCA4OTQgMjM0IGIgOTAyIDg4IDkwMiAyMjMgOTAyIDIzNyBsIDkwMiAtMSBsIDkwMiAtOTAgYiA4OTggLTIzMSA5MDIgLTIzOCA5MDIgLTIyNCBiIDg3NiAtMjQyIDg5MiAtMjM4IDg4NCAtMjQyIGIgODUyIC0yMjQgODY1IC0yNDIgODU0IC0yMzUgYiA4NTAgMiA4NTAgLTIyMiA4NTAgLTEwOCBiIDg1MiAyMjMgODUwIDExMiA4NTAgMjIwIGIgODY4IDI0MCA4NTMgMjMwIDg2MCAyMzcgXCJ9LFwidjU0XCI6e1wieF9taW5cIjotMjQuNSxcInhfbWF4XCI6MzE3LjE0MDYyNSxcImhhXCI6MzI0LFwib1wiOlwibSAtMjQgLTE2MSBsIC0yNCAtNSBsIC0yMCAtNSBiIDAgLTI0IC05IC01IC0yIC0xMiBiIDE3MSAtMzE1IDIxIC0xMjQgODQgLTIzMyBiIDMxNyAtNjYwIDI2OCAtNDA2IDMxNyAtNTMxIGIgMTg3IC0xMDE0IDMxNyAtNzgyIDI3NCAtOTA5IGIgMTYxIC0xMDM0IDE3MiAtMTAzNCAxNzEgLTEwMzQgYiAxNDEgLTEwMTMgMTQ5IC0xMDM0IDE0MSAtMTAyNSBiIDE1MiAtOTkxIDE0MSAtMTAwNCAxNDIgLTEwMDIgYiAyNjYgLTY4MiAyMjggLTg5OSAyNjYgLTc4OCBiIDE3NCAtNDMwIDI2NiAtNTg4IDIzNiAtNDk4IGIgLTIzIC0zMTcgMTM2IC0zODggNjYgLTM0OCBiIC0yNCAtMTYxIC0yMyAtMzE2IC0yNCAtMjg1IFwifSxcInY1NVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NTUxLjI1LFwiaGFcIjo1NjMsXCJvXCI6XCJtIDI4OSA2NDQgYiAzMDQgNjQ1IDI5NCA2NDUgMjk5IDY0NSBiIDQwNCA1NjYgMzQ5IDY0NSAzOTIgNjEzIGIgNDA2IDU0MSA0MDUgNTU3IDQwNiA1NDkgYiAzNzkgNDcxIDQwNiA1MTQgMzk3IDQ4OSBsIDM3NyA0NjcgbCAzODIgNDcwIGIgNTA5IDU5MSA0MzggNDg1IDQ4NSA1MzEgYiA1MTMgNjAxIDUxMCA1OTUgNTEzIDU5OSBiIDUzMCA2MDkgNTE4IDYwNyA1MjQgNjA5IGIgNTUxIDU4OCA1NDAgNjA5IDU1MSA2MDIgYiAyMDAgLTYwNSA1NTEgNTg0IDIwNCAtNTk5IGIgMTgyIC02MTYgMTk3IC02MTIgMTkwIC02MTYgYiAxNjMgLTYwMiAxNzQgLTYxNiAxNjYgLTYxMCBiIDE2MSAtNTk4IDE2MSAtNjAxIDE2MSAtNjAxIGIgMjE3IC00MDIgMTYxIC01ODkgMTcwIC01NjIgYiAyNzIgLTIxMyAyNDcgLTI5OCAyNzIgLTIxMyBiIDI3MiAtMjEzIDI3MiAtMjEzIDI3MiAtMjEzIGIgMjY0IC0yMTkgMjcyIC0yMTMgMjY4IC0yMTYgYiAxNDAgLTI2MiAyMjcgLTI0NyAxODIgLTI2MiBiIDM2IC0yMjYgMTAyIC0yNjIgNjUgLTI0OSBiIDAgLTE0NSAxMiAtMjA2IDAgLTE3NiBiIDE3IC04NCAwIC0xMjQgNSAtMTA0IGIgMTAzIC0zOCAzOCAtNTQgNzAgLTM4IGIgMTkxIC05MSAxMzcgLTM4IDE3MiAtNTYgYiAyMDUgLTE0MSAyMDEgLTEwNiAyMDUgLTEyNCBiIDE3OCAtMjEyIDIwNSAtMTY3IDE5NiAtMTk0IGwgMTc1IC0yMTUgbCAxODIgLTIxMyBiIDMwNyAtOTMgMjM2IC0xOTggMjg0IC0xNTEgYiAzNzIgMTI5IDMwOCAtODggMzcyIDEyNyBiIDM3MiAxMjkgMzcyIDEyOSAzNzIgMTI5IGIgMzY0IDEyMiAzNzIgMTI5IDM2OCAxMjYgYiAyNDAgODAgMzI4IDk0IDI4MyA4MCBiIDEzNyAxMTUgMjAyIDgwIDE2NiA5MSBiIDk5IDE5NSAxMTIgMTM2IDk5IDE2NSBiIDExOCAyNTYgOTkgMjE3IDEwNiAyMzggYiAyMDQgMzAzIDEzOCAyODcgMTcxIDMwMyBiIDI5MiAyNDkgMjM4IDMwMyAyNzMgMjg1IGIgMzA2IDE5OSAzMDIgMjM0IDMwNiAyMTcgYiAyNzkgMTI5IDMwNiAxNzMgMjk2IDE0OCBsIDI3NiAxMjYgbCAyODEgMTI3IGIgNDA4IDI0OCAzMzYgMTQyIDM4NSAxOTAgYiA0NzMgNDcwIDQwOSAyNTQgNDczIDQ2OSBiIDQ3MyA0NzAgNDczIDQ3MCA0NzMgNDcwIGIgNDY1IDQ2NCA0NzMgNDcwIDQ2OSA0NjcgYiAzNDEgNDIxIDQyOCA0MzUgMzgzIDQyMSBiIDIzNiA0NTggMzAzIDQyMSAyNjYgNDMzIGIgMjAwIDUzNyAyMTIgNDc4IDIwMCA1MDggYiAyODkgNjQ0IDIwMCA1ODUgMjM0IDYzNSBcIn0sXCJ2NThcIjp7XCJ4X21pblwiOi0yMS43ODEyNSxcInhfbWF4XCI6MzY3LjUsXCJoYVwiOjM3NSxcIm9cIjpcIm0gMjU5IDE1NTMgYiAyNjUgMTU1MyAyNjEgMTU1MyAyNjQgMTU1MyBiIDI4OCAxNTQwIDI3MiAxNTUzIDI3NyAxNTUwIGIgMzY3IDEzNTEgMzQwIDE0OTMgMzY3IDE0MjQgYiAzMzYgMTIyMSAzNjcgMTMwOCAzNTcgMTI2MyBsIDMzMiAxMjExIGwgMzMzIDEyMDggYiAzNjcgMTA3NyAzNTYgMTE3MCAzNjcgMTEyNCBiIDMzNiA5NDUgMzY3IDEwMzIgMzU3IDk4NiBsIDMzMiA5MzUgbCAzMzMgOTMyIGIgMzY3IDgwMCAzNTYgODkzIDM2NyA4NDggYiAzMzYgNjY5IDM2NyA3NTYgMzU3IDcxMCBsIDMzMiA2NTkgbCAzMzMgNjU2IGIgMzY3IDUyMyAzNTYgNjE3IDM2NyA1NzEgYiAzNDUgNDEyIDM2NyA0ODUgMzYwIDQ0NiBiIDIzMSAyNzMgMzIyIDM1NiAyODQgMzEwIGIgLTEgMTkgMTIxIDE5NSAyNyA5MyBiIC0xNyA0IC00IDExIC0xMCA1IGwgLTIxIDQgbCAtMjEgMTM0IGwgLTIxIDI2NSBsIC0xNyAyNjUgYiAxMzMgMjkxIDIwIDI2NSA5NiAyNzggYiAzMTggNTM3IDI0NSAzMjggMzE4IDQzMyBiIDMwNyA2MDMgMzE4IDU1OSAzMTUgNTgyIGIgMzAzIDYxNCAzMDQgNjEyIDMwNCA2MTQgYiAyOTggNjA5IDMwMiA2MTQgMzAwIDYxMyBiIDIzMSA1NDkgMjgxIDU4OSAyNTggNTY3IGIgLTEgMjk1IDEyMSA0NzEgMjcgMzY5IGIgLTE3IDI4MCAtNCAyODcgLTEwIDI4MSBsIC0yMSAyODAgbCAtMjEgNDEwIGwgLTIxIDU0MSBsIC0xNyA1NDEgYiAxMzMgNTY3IDIwIDU0MSA5NiA1NTUgYiAzMTggODEzIDI0NSA2MDUgMzE4IDcwOSBiIDMwNyA4ODAgMzE4IDgzNSAzMTUgODU5IGIgMzAzIDg5MSAzMDQgODg4IDMwNCA4OTEgYiAyOTggODg1IDMwMiA4OTEgMzAwIDg4OCBiIDIzMSA4MjUgMjgxIDg2NiAyNTggODQzIGIgLTEgNTcxIDEyMSA3NDggMjcgNjQ1IGIgLTE3IDU1NiAtNCA1NjMgLTEwIDU1NyBsIC0yMSA1NTYgbCAtMjEgNjg3IGwgLTIxIDgxNyBsIC0xNyA4MTcgYiAxMzMgODQzIDIwIDgxNyA5NiA4MzAgYiAzMTggMTA4OSAyNDUgODgxIDMxOCA5ODUgYiAzMDcgMTE1NiAzMTggMTExMSAzMTUgMTEzNCBiIDMwMyAxMTY3IDMwNCAxMTY0IDMwNCAxMTY3IGIgMjk4IDExNjEgMzAyIDExNjcgMzAwIDExNjQgYiAyMzEgMTEwMiAyODEgMTE0MCAyNTggMTEyMCBiIC0xIDg0OCAxMjEgMTAyNCAyNyA5MjEgYiAtMTcgODMyIC00IDgzOSAtMTAgODM0IGwgLTIxIDgzMiBsIC0yMSA5NjMgbCAtMjEgMTA5MyBsIC0xNyAxMDkzIGIgMTE0IDExMTMgMTIgMTA5MyA3OCAxMTAzIGIgMzEzIDEzMTQgMjE1IDExNDIgMjg5IDEyMTggYiAzMTggMTM2NCAzMTcgMTMzMSAzMTggMTM0NyBiIDI1NSAxNTExIDMxOCAxNDIyIDI5NSAxNDc4IGIgMjQzIDE1MzIgMjQ3IDE1MTkgMjQzIDE1MjUgYiAyNTkgMTU1MyAyNDMgMTU0MCAyNTAgMTU1MCBcIn0sXCJ2NTlcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ2NC4xNDA2MjUsXCJoYVwiOjQ3NCxcIm9cIjpcIm0gMCAwIGwgMCAzNDcgbCA3NiAzNDcgbCAxNTMgMzQ3IGwgMTUzIDAgbCAxNTMgLTM0OCBsIDc2IC0zNDggbCAwIC0zNDggbCAwIDAgbSAzMDggLTEgbCAzMDggMzQ3IGwgMzg2IDM0NyBsIDQ2NCAzNDcgbCA0NjQgLTEgbCA0NjQgLTM0OCBsIDM4NiAtMzQ4IGwgMzA4IC0zNDggbCAzMDggLTEgXCJ9LFwidjVhXCI6e1wieF9taW5cIjotMTcxLjUsXCJ4X21heFwiOjE3MC4xNDA2MjUsXCJoYVwiOjE3NCxcIm9cIjpcIm0gLTYgNTY2IGIgMCA1NjcgLTUgNTY3IC0yIDU2NyBiIDE0IDU1NiA2IDU2NyAxMiA1NjMgYiA5MiAyODUgMTQgNTU1IDUwIDQzMyBiIDE3MCAxMyAxNjYgMzMgMTcwIDE5IGIgMTY4IDEzIDE3MCAxMyAxNzAgMTMgYiAxNjEgMSAxNjggOCAxNjcgNCBsIDE1OSAwIGwgMTIyIDAgbCA4NCAwIGwgODEgMSBiIDIxIDE5NSA3NiA1IDc4IC01IGIgLTMyIDM4MSAtOCAyOTcgLTMyIDM4MSBiIC04NyAxOTcgLTMyIDM4MSAtNTcgMjk4IGIgLTE0MSA4IC0xMTUgOTQgLTE0MCA5IGIgLTE1NSAwIC0xNDIgMiAtMTQ5IDAgYiAtMTcxIDE1IC0xNjMgMCAtMTcxIDUgYiAtMTQgNTU2IC0xNzEgMTggLTI0IDUyOCBiIC02IDU2NiAtMTQgNTYwIC0xMCA1NjQgXCJ9LFwidjViXCI6e1wieF9taW5cIjotNDQxLFwieF9tYXhcIjo0MzkuNjQwNjI1LFwiaGFcIjo0NDksXCJvXCI6XCJtIC00MjggLTIgYiAtNDIxIDAgLTQyNyAtMSAtNDI0IDAgYiAtNDA2IC02IC00MTYgMCAtNDA5IC0yIGIgLTQwMCAtMzEgLTQwMSAtMTIgLTQwMCAtMTUgYiAtMSAtMzUyIC0zOTIgLTIxNSAtMjE1IC0zNTIgYiA1OCAtMzQ5IDE5IC0zNTIgMzggLTM1MSBiIDM5OCAtMzEgMjUwIC0zMjYgMzkyIC0xOTIgYiA0MDQgLTYgMzk4IC0xNSA0MDAgLTEyIGIgNDE5IC0xIDQwOCAtMiA0MTMgLTEgYiA0MzkgLTEzIDQyNyAtMSA0MzUgLTUgYiA0MzkgLTI5IDQzOSAtMTYgNDM5IC0yMiBiIDQzNCAtMTA1IDQzOSAtNDggNDM4IC04MCBiIDAgLTQ4OSAzOTcgLTMzMyAyMTMgLTQ4OSBiIC02OCAtNDg0IC0yMyAtNDg5IC00NCAtNDg4IGIgLTQ0MSAtMzYgLTI4MCAtNDUyIC00MzYgLTI2MyBiIC00NDEgLTMwIC00NDEgLTM0IC00NDEgLTMxIGIgLTQyOCAtMiAtNDQxIC0xMSAtNDM5IC01IG0gLTEzIC05IGIgLTEgLTggLTkgLTggLTUgLTggYiA1MCAtMzYgMTkgLTggMzkgLTE5IGIgNjEgLTcyIDU3IC00NyA2MSAtNTkgYiA1MCAtMTA2IDYxIC04NCA1NyAtOTcgYiAtMSAtMTM0IDM5IC0xMjQgMTkgLTEzNCBiIC00NiAtMTE1IC0xNyAtMTM0IC0zNCAtMTI5IGIgLTYyIC03MiAtNTcgLTEwMiAtNjIgLTg3IGIgLTEzIC05IC02MiAtNDQgLTQ0IC0xNiBcIn0sXCJ2NWNcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQ0Ny44MTI1LFwiaGFcIjo0NTcsXCJvXCI6XCJtIDAgLTg3IGwgMCAwIGwgMjIzIDAgbCA0NDcgMCBsIDQ0NyAtODcgbCA0NDcgLTE3NCBsIDIyMyAtMTc0IGwgMCAtMTc0IGwgMCAtODcgXCJ9LFwidjVkXCI6e1wieF9taW5cIjotMS4zNTkzNzUsXCJ4X21heFwiOjU5Mi4wNzgxMjUsXCJoYVwiOjYwNCxcIm9cIjpcIm0gMjgwIDY5MiBiIDI5NSA2OTQgMjgzIDY5MiAyODkgNjk0IGIgMzEwIDY5MiAzMDAgNjk0IDMwNyA2OTIgYiAzNTcgNjMwIDM0MCA2ODQgMzU3IDY1NyBiIDMzNiA1ODAgMzU3IDYxMiAzNTEgNTk0IGIgMzExIDUzOCAzMjEgNTY2IDMxMSA1NDkgYiAzNTIgNDkyIDMxMSA1MTIgMzMwIDQ5MiBiIDM2NiA0OTUgMzU3IDQ5MiAzNjIgNDkyIGIgMzk3IDU1MyAzOTAgNTAzIDM5NyA1MTcgYiA0MTUgNjAzIDM5NyA1NzYgNDAyIDU5MSBiIDQ2MCA2MjMgNDI3IDYxNyA0NDMgNjIzIGIgNTA5IDU5OSA0NzkgNjIzIDQ5OCA2MTQgYiA1MjIgNTU5IDUxOCA1ODcgNTIyIDU3MyBiIDQ5NCA1MDYgNTIyIDUzOCA1MTMgNTE5IGIgNDUxIDQ5NSA0ODEgNDk4IDQ3MyA0OTYgYiA0MTUgNDg4IDQzMiA0OTUgNDI2IDQ5NCBiIDM5NCA0NDkgNDA0IDQ4MyAzOTQgNDY0IGIgMzk0IDQ0OCAzOTQgNDQ4IDM5NCA0NDggbCAzOTQgNDQwIGwgMzk3IDQzMyBiIDQyOCA0MDkgNDA0IDQyMCA0MTMgNDEzIGIgNDM4IDQwOCA0MzEgNDA4IDQzNSA0MDggYiA0NzkgNDMxIDQ1MCA0MDggNDYyIDQxNSBiIDUyOCA0NTUgNDk1IDQ0OCA1MTAgNDU1IGIgNTQ4IDQ1MiA1MzQgNDU1IDU0MSA0NTMgYiA1OTIgMzkxIDU3NyA0NDIgNTkyIDQxNiBiIDU0OSAzMzEgNTkyIDM2NSA1NzcgMzQwIGIgNTI4IDMyNyA1NDEgMzI4IDUzNCAzMjcgYiA0NzkgMzUxIDUxMCAzMjcgNDk1IDMzNSBiIDQzOCAzNzQgNDY0IDM2NyA0NTAgMzc0IGIgNDE3IDM2OSA0MzEgMzc0IDQyNCAzNzMgYiAzOTQgMzMzIDQwMiAzNjAgMzk0IDM0OCBiIDQwMCAzMTIgMzk0IDMyNiAzOTYgMzE5IGIgNDUxIDI4NyA0MDggMjk0IDQyMCAyODggYiA1MTMgMjU4IDQ4NCAyODUgNDk5IDI3OCBiIDUyMiAyMjMgNTE5IDI0NyA1MjIgMjM0IGIgNDYxIDE1OSA1MjIgMTkwIDQ5NiAxNTkgYiA0NDkgMTYxIDQ1NyAxNTkgNDUzIDE1OSBiIDM5NyAyMjkgNDE2IDE2NyAzOTcgMTkxIGIgMzY2IDI4OCAzOTcgMjY1IDM5MCAyNzggYiAzNTIgMjkwIDM2MiAyOTAgMzU3IDI5MCBiIDMxNSAyNjIgMzM2IDI5MCAzMjEgMjgwIGIgMzExIDI0NSAzMTMgMjU2IDMxMSAyNTEgYiAzMzQgMjA0IDMxMSAyMzMgMzE4IDIyMCBiIDM1NSAxNzAgMzQ4IDE5MCAzNTEgMTg0IGIgMzU3IDE1MiAzNTYgMTY2IDM1NyAxNTkgYiAzNTUgMTM2IDM1NyAxNDcgMzU2IDE0MCBiIDI5NSA4OCAzNDUgMTA0IDMyMSA4OCBiIDIzMiAxNTIgMjY0IDg4IDIzMiAxMTIgYiAyNTUgMjA0IDIzMiAxNzQgMjM4IDE4NiBiIDI3OSAyNDQgMjczIDIyMiAyNzkgMjMxIGwgMjc5IDI0NSBiIDIzOCAyOTAgMjc5IDI3MCAyNTkgMjkwIGIgMjI0IDI4OCAyMzQgMjkwIDIyOCAyOTAgYiAxOTMgMjI5IDIwMCAyNzggMTkzIDI2NSBiIDE0MSAxNjEgMTkzIDE5MSAxNzQgMTY3IGIgMTI5IDE1OSAxMzcgMTU5IDEzMyAxNTkgYiA2OCAyMjMgOTMgMTU5IDY4IDE5MCBiIDc3IDI1OCA2OCAyMzQgNzAgMjQ3IGIgMTM4IDI4NyA5MSAyNzggMTA2IDI4NSBiIDE4NSAzMDIgMTY2IDI4NyAxNzUgMjkxIGIgMTk2IDMzMyAxOTMgMzEyIDE5NiAzMjMgYiAxNzQgMzY5IDE5NiAzNDcgMTg3IDM2MCBiIDE1MiAzNzQgMTY2IDM3MyAxNTkgMzc0IGIgMTExIDM1MSAxNDAgMzc0IDEyNiAzNjcgYiA2MiAzMjcgOTUgMzM1IDgwIDMyNyBiIDUxIDMyOCA1OCAzMjcgNTQgMzI3IGIgLTEgMzkxIDE2IDMzNCAtMSAzNjMgYiA1MyA0NTUgLTEgNDIwIDE3IDQ0OSBiIDYyIDQ1NSA1NyA0NTUgNTkgNDU1IGIgMTExIDQzMSA4MCA0NTUgOTUgNDQ4IGIgMTUyIDQwOCAxMjcgNDE1IDE0MCA0MDggYiAxNjEgNDA5IDE1NSA0MDggMTU5IDQwOCBiIDE5MyA0MzMgMTc2IDQxMyAxODYgNDIwIGwgMTk2IDQ0MCBsIDE5NiA0NDggYiAxOTYgNDUxIDE5NiA0NDkgMTk2IDQ0OSBiIDE5MCA0NzEgMTk2IDQ1OSAxOTQgNDYzIGIgMTM3IDQ5NSAxODIgNDg5IDE2NyA0OTUgbCAxMzQgNDk1IGwgMTM0IDQ5NSBiIDY4IDU2MCA5NSA0OTUgNjggNTIxIGIgMTI5IDYyMyA2OCA1OTYgOTUgNjIzIGIgMTQ0IDYyMSAxMzQgNjIzIDEzOCA2MjMgYiAxOTMgNTUzIDE3NSA2MTQgMTkzIDU4OSBiIDIyNCA0OTUgMTkzIDUxNyAyMDAgNTAzIGIgMjM4IDQ5MiAyMjggNDkyIDIzNCA0OTIgYiAyNzkgNTM4IDI1OSA0OTIgMjc5IDUxMiBiIDI1NCA1ODAgMjc5IDU0OSAyNjkgNTY2IGIgMjMyIDYzMCAyMzkgNTk0IDIzMiA2MTIgYiAyODAgNjkyIDIzMiA2NTcgMjUwIDY4NCBtIDMwNyA0NTYgYiAyOTUgNDU4IDMwMyA0NTggMjk5IDQ1OCBiIDIzMCAzOTEgMjU4IDQ1OCAyMzAgNDI2IGIgMjM2IDM2MCAyMzAgMzgxIDIzMSAzNzEgYiAyOTUgMzI0IDI0OSAzMzcgMjcyIDMyNCBiIDM1MyAzNjAgMzE4IDMyNCAzNDEgMzM3IGIgMzYwIDM5MSAzNTcgMzcwIDM2MCAzODEgYiAzMDcgNDU2IDM2MCA0MjEgMzQwIDQ1MSBcIn0sXCJ2NjBcIjp7XCJ4X21pblwiOi01OTAuNzE4NzUsXCJ4X21heFwiOjU4OS4zNTkzNzUsXCJoYVwiOjYwMSxcIm9cIjpcIm0gLTM2NyAxNzMgYiAtMzYyIDE3NCAtMzY2IDE3NCAtMzY0IDE3NCBiIC0zNTEgMTczIC0zNTcgMTc0IC0zNTMgMTczIGIgLTI2MiA4NiAtMzQ4IDE3MiAtMzI4IDE1MSBiIC0xNzYgMCAtMjE2IDM3IC0xNzYgMCBiIC0xMDcgODQgLTE3NiAwIC0xNDUgMzcgYiAtMzEgMTc0IC0zNiAxNzMgLTM4IDE3MiBiIC0yNSAxNzQgLTI5IDE3NCAtMjggMTc0IGIgLTE2IDE3MyAtMjMgMTc0IC0xOSAxNzMgYiA3MiA4NiAtMTMgMTcyIDYgMTUxIGIgMTU3IDAgMTE5IDM3IDE1NyAwIGIgMjI3IDg0IDE1OSAwIDE4OSAzNyBiIDMwMyAxNzQgMjk4IDE3MyAyOTYgMTcyIGIgMzA4IDE3NCAzMDQgMTc0IDMwNyAxNzQgYiAzMTggMTczIDMxMyAxNzQgMzE3IDE3MyBiIDQ4MSAxMSAzMjIgMTcyIDM1NyAxMzQgbCA0OTQgLTEgbCA1MjIgMzQgYiA1NjAgNzYgNTUzIDcyIDU1NSA3NCBiIDU2NyA3NyA1NjMgNzcgNTY0IDc3IGIgNTg5IDU2IDU3OSA3NyA1ODkgNjggYiA1ODYgNDggNTg5IDU0IDU4OCA1MSBiIDQxMSAtMTcyIDU4MyA0MSA0MTYgLTE2NiBiIDM5NyAtMTc2IDQwNiAtMTc0IDQwMSAtMTc2IGIgMzg3IC0xNzQgMzkzIC0xNzYgMzkwIC0xNzYgYiAyOTkgLTg3IDM4NiAtMTczIDM2NiAtMTUyIGIgMjEzIDAgMjUzIC0zOCAyMTMgMCBiIDE0NCAtODYgMjEzIDAgMTgyIC0zOCBiIDY4IC0xNzQgNzMgLTE3NCA3NCAtMTczIGIgNjIgLTE3NiA2NiAtMTc2IDY1IC0xNzYgYiA1MyAtMTc0IDU5IC0xNzYgNTUgLTE3NCBiIC0zNSAtODcgNTAgLTE3MyAyOSAtMTUyIGIgLTEyMSAwIC04MyAtMzggLTEyMSAwIGIgLTE5MCAtODYgLTEyMiAwIC0xNTIgLTM4IGIgLTI2NiAtMTc0IC0yNjEgLTE3NCAtMjU5IC0xNzMgYiAtMjcyIC0xNzYgLTI2OCAtMTc2IC0yNzAgLTE3NiBiIC0yODEgLTE3NCAtMjc2IC0xNzYgLTI4MCAtMTc0IGIgLTM3MSAtODYgLTI4NCAtMTczIC0zMDQgLTE1MiBiIC00NTcgMCAtNDE3IC0zOCAtNDU3IDAgbCAtNDU3IDAgYiAtNDc3IC0yNiAtNDU3IDAgLTQ3MCAtMTYgYiAtNTQ4IC0yMjcgLTUyNCAtODggLTU0OCAtMTYxIGIgLTUzNiAtMzAzIC01NDggLTI1NCAtNTQ0IC0yODAgYiAtNTMzIC0zMTcgLTUzNCAtMzA5IC01MzMgLTMxMyBiIC01NTMgLTMzOCAtNTMzIC0zMzAgLTU0MSAtMzM4IGIgLTU3NyAtMzE1IC01NjYgLTMzOCAtNTcxIC0zMzMgYiAtNTkwIC0yMjcgLTU4NiAtMjg3IC01OTAgLTI1OCBiIC01MTggLTkgLTU5MCAtMTU0IC01NjQgLTc3IGIgLTQ2NSA1NiAtNTA5IDIgLTUwNCA4IGwgLTQwMiAxMzQgYiAtMzY3IDE3MyAtMzc1IDE2OSAtMzcyIDE3MiBcIn0sXCJ2NjJcIjp7XCJ4X21pblwiOjQ2LjI4MTI1LFwieF9tYXhcIjo2NjkuNjcxODc1LFwiaGFcIjo1NjMsXCJvXCI6XCJtIDE4MyAzNzYgYiAxODkgMzc2IDE4NSAzNzYgMTg3IDM3NiBiIDIxMiAzNzQgMTk3IDM3NiAyMDggMzc2IGIgMjY1IDMzNyAyMzQgMzY5IDI1MyAzNTUgYiAyNzQgMzE3IDI2OCAzMzEgMjczIDMyMCBiIDI3NCAzMTYgMjc0IDMxNyAyNzQgMzE2IGIgMjgwIDMyMyAyNzYgMzE2IDI3NiAzMTkgYiAzMTEgMzU4IDI4OCAzMzcgMjk5IDM0OCBiIDMxOSAzNjYgMzE1IDM2MCAzMTggMzY1IGIgMzU2IDM3NiAzMjYgMzczIDM0MCAzNzYgYiAzODIgMzcxIDM2NCAzNzYgMzc0IDM3NCBiIDQyOCAzMzcgNDAwIDM2NiA0MTcgMzUyIGIgNDM2IDMxNyA0MzEgMzMxIDQzNiAzMjAgYiA0MzggMzE2IDQzNiAzMTcgNDM2IDMxNiBiIDQ0MiAzMjMgNDM4IDMxNiA0MzkgMzE5IGIgNDc1IDM1OCA0NTEgMzM3IDQ2MiAzNDggYiA0ODMgMzY2IDQ3NyAzNjAgNDgxIDM2NSBiIDUxOCAzNzYgNDg4IDM3MyA1MDMgMzc2IGIgNTQ0IDM3MyA1MjggMzc2IDUzNiAzNzYgYiA2MDQgMjg1IDU3OSAzNjAgNjA0IDMyNiBiIDU5NyAyNDkgNjA0IDI3MyA2MDEgMjU4IGIgNTQzIDYzIDU5NiAyNDcgNTQ0IDcwIGIgNTQxIDU0IDU0MyA2MSA1NDEgNTUgYiA1NDAgNDQgNTQwIDUxIDU0MCA0NyBiIDU1MiAyMyA1NDAgMzMgNTQ1IDIzIGIgNTUyIDIzIDU1MiAyMyA1NTIgMjMgYiA2NDcgMTI2IDU4NiAyOSA2MjcgNzIgYiA2NTggMTM4IDY1MSAxMzYgNjUzIDEzOCBiIDY2MCAxMzggNjYwIDEzOCA2NjAgMTM4IGIgNjY5IDEyOSA2NjYgMTM3IDY2OSAxMzYgYiA2NTQgODggNjY5IDEyMiA2NjUgMTA5IGIgNTYyIC0xMiA2MzEgNDMgNjAyIDkgbCA1NDkgLTE5IGIgNTIxIC0yNyA1NDAgLTI0IDUzMCAtMjcgYiA0NDcgMzAgNDkwIC0yNyA0NTggLTQgYiA0NDMgNTggNDQ1IDM4IDQ0MyA0OCBiIDQ1MCA5MyA0NDMgNzIgNDQ2IDg0IGIgNTA0IDI3OCA0NTMgOTcgNTA0IDI3MiBiIDUwNyAyODggNTA2IDI4MyA1MDYgMjg3IGIgNTA5IDI5OCA1MDcgMjkyIDUwOSAyOTUgYiA0OTEgMzI2IDUwOSAzMTAgNTAyIDMyMCBiIDQ4NyAzMjcgNDkwIDMyNyA0ODggMzI3IGIgNDc5IDMyNCA0ODQgMzI3IDQ4MyAzMjYgYiA0NDEgMjcwIDQ2MiAzMTYgNDQzIDI4OCBiIDQzNSAyNDkgNDQxIDI2NSA0MzYgMjU0IGIgMzk4IDEyNyA0MzQgMjQ4IDQxOSAxOTUgYiAzNjIgNCAzNzkgNjEgMzYyIDUgYiAzMjggLTEgMzU5IC0xIDM2MiAtMSBiIDMxNCAtMSAzMjMgLTEgMzE5IC0xIGIgMzAyIC0xIDMxMCAtMSAzMDYgLTEgYiAyNjYgNCAyNjYgLTEgMjY5IC0xIGIgMjY1IDYgMjY1IDUgMjY1IDUgYiAzMDMgMTQ0IDI2NSAxMyAyNzIgMzQgYiAzNDMgMjc4IDMyNSAyMTYgMzQzIDI3NiBiIDM0NCAyODggMzQzIDI4MSAzNDQgMjg1IGIgMzQ1IDI5OCAzNDUgMjkxIDM0NSAyOTUgYiAzMzAgMzI2IDM0NSAzMTAgMzQwIDMyMCBiIDMyMyAzMjcgMzI4IDMyNyAzMjUgMzI3IGIgMzE3IDMyNCAzMjIgMzI3IDMyMSAzMjYgYiAyNzkgMjcwIDMwMCAzMTYgMjgxIDI4OCBiIDI3MyAyNDkgMjc5IDI2NSAyNzQgMjU0IGIgMjM2IDEyNyAyNzIgMjQ4IDI1NSAxOTUgYiAyMDAgNCAyMTYgNjEgMjAwIDUgYiAxNjQgLTEgMTk3IC0xIDE5OCAtMSBiIDE1MSAtMSAxNjEgLTEgMTU2IC0xIGIgMTQwIC0xIDE0NyAtMSAxNDIgLTEgYiAxMDMgNCAxMDQgLTEgMTA2IC0xIGIgMTAzIDYgMTAzIDUgMTAzIDUgYiAxNDEgMTQ0IDEwMyAxMyAxMDggMzQgYiAxODEgMjc4IDE2MSAyMTYgMTc5IDI3NiBiIDE4MiAyODggMTgxIDI4MSAxODEgMjg1IGIgMTgzIDI5OCAxODIgMjkxIDE4MyAyOTUgYiAxNjggMzI0IDE4MyAzMTAgMTc4IDMyMCBiIDE2MCAzMjcgMTY2IDMyNiAxNjMgMzI3IGIgMTQxIDMyMCAxNTYgMzI3IDE1MSAzMjQgYiA2OSAyMzAgMTEyIDMwNSA4NSAyNzIgYiA1NyAyMTUgNjUgMjE3IDYyIDIxNSBiIDU1IDIxNSA1NyAyMTUgNTUgMjE1IGIgNDYgMjI0IDQ5IDIxNSA0NiAyMTcgYiA1OSAyNjAgNDYgMjMxIDUwIDI0MiBiIDE1MSAzNjMgODEgMzA2IDExMiAzNDEgYiAxNjEgMzY5IDE1NSAzNjUgMTYwIDM2NyBiIDE4MyAzNzYgMTY2IDM3MSAxNzQgMzc0IFwifSxcInY2OFwiOntcInhfbWluXCI6LTU5Ny41MzEyNSxcInhfbWF4XCI6NTk2LjE3MTg3NSxcImhhXCI6NjA4LFwib1wiOlwibSAtNTMzIDMyNCBiIC01MjUgMzI3IC01MzAgMzI2IC01MjggMzI3IGIgLTUwNCAzMDUgLTUxNCAzMjcgLTUwNCAzMTcgYiAtNTA0IDMwNSAtNTA0IDMwNSAtNTA0IDMwNSBiIC01MTMgMjg0IC01MDQgMjk5IC01MDQgMjk5IGIgLTU1NiAxMTIgLTU0MSAyMjYgLTU1NiAxNjcgYiAtNTQ1IDMzIC01NTYgODQgLTU1MiA1OCBiIC01MjQgLTIwIC01NDEgMTUgLTUzMiAtOSBsIC01MjIgLTIzIGwgLTQ5MSAxNSBsIC00MTMgMTExIGIgLTM1NSAxNzQgLTM2NyAxNjkgLTM2MyAxNzQgYiAtMzUxIDE3NCAtMzUzIDE3NCAtMzUyIDE3NCBiIC0yNTQgODYgLTM0MyAxNzQgLTM0OCAxNzkgYiAtMTY4IC0xIC0yMDggMzcgLTE2OCAtMSBiIC0xMDAgODQgLTE2OCAtMSAtMTM3IDM3IGIgLTIzIDE3MyAtMjggMTczIC0yOSAxNzIgYiAtMTkgMTc0IC0yMSAxNzQgLTIwIDE3NCBiIC04IDE3MyAtMTQgMTc0IC0xMCAxNzMgYiAxNTUgMTEgLTUgMTcyIDQzIDEyMyBsIDE2NiAtMSBsIDE2OCAxIGwgMTcwIDQgbCAxNzAgMTMwIGIgMTcxIDI2MCAxNzAgMjU2IDE3MCAyNTggYiAxOTEgMjc0IDE3NSAyNjkgMTgzIDI3NCBiIDIwNSAyNjcgMTk2IDI3NCAyMDEgMjcyIGIgMjEyIDE1OCAyMTIgMjYyIDIxMCAyNzMgbCAyMTIgNTYgbCAyNTcgMTEyIGIgMzExIDE3MyAzMDQgMTcyIDMwNCAxNzIgYiAzMTcgMTc0IDMxMyAxNzQgMzE0IDE3NCBiIDMyNiAxNzMgMzE5IDE3NCAzMjMgMTczIGIgNDkwIDExIDMyOSAxNzIgMzY2IDEzNCBsIDUwMiAtMSBsIDUzMCAzNCBiIDU2OCA3NiA1NjAgNzIgNTYzIDc0IGIgNTc1IDc3IDU3MCA3NyA1NzMgNzcgYiA1OTYgNTYgNTg2IDc3IDU5NiA2OCBiIDU5NCA0OCA1OTYgNTQgNTk2IDUxIGIgNDE3IC0xNzIgNTkyIDQxIDQyNCAtMTY2IGIgNDA1IC0xNzYgNDE1IC0xNzQgNDA5IC0xNzYgYiAzOTYgLTE3NCA0MDEgLTE3NiAzOTggLTE3NiBiIDMwNyAtODcgMzkzIC0xNzMgMzcyIC0xNTIgYiAyMjEgLTEgMjU5IC0zOCAyMjEgLTEgYiAyMTYgLTYgMjIxIC0xIDIxOSAtMiBsIDIxMiAtMTIgbCAyMTIgLTE0NyBiIDIxMiAtMjEwIDIxMiAtMTczIDIxMiAtMTk0IGIgMjA1IC0yOTIgMjEyIC0yOTcgMjEwIC0yODcgYiAxOTEgLTI5OSAyMDEgLTI5NyAxOTYgLTI5OSBiIDE3MiAtMjg3IDE4MyAtMjk5IDE3NSAtMjk1IGIgMTcwIC0xNzQgMTcxIC0yODQgMTcxIC0yODQgbCAxNzAgLTYzIGwgMTI3IC0xMTcgYiA3MyAtMTc2IDg0IC0xNzAgODAgLTE3NiBiIDY4IC0xNzYgNzIgLTE3NiA3MCAtMTc2IGIgLTI3IC04NyA1OSAtMTc0IDY1IC0xODAgYiAtMTE0IDAgLTc0IC0zOCAtMTEyIDAgYiAtMTgyIC04NiAtMTE0IDAgLTE0NSAtMzggYiAtMjU4IC0xNzQgLTI1MyAtMTc0IC0yNTMgLTE3MyBiIC0yNjQgLTE3NiAtMjU5IC0xNzYgLTI2MiAtMTc2IGIgLTI3NCAtMTc0IC0yNjggLTE3NiAtMjcyIC0xNzQgYiAtNDM4IC0xMSAtMjc3IC0xNzMgLTM0OCAtMTAyIGwgLTQ0OSAwIGwgLTQ3OSAtMzcgYiAtNTI0IC04MCAtNTEzIC04MCAtNTE0IC04MCBsIC01MjQgLTgwIGIgLTU1MyAtNTIgLTUzNCAtODAgLTU0MCAtNzQgYiAtNTk3IDEwOSAtNTgzIC04IC01OTcgNDggYiAtNTYwIDI4MCAtNTk3IDE2NSAtNTg1IDIyNCBiIC01MzMgMzI0IC01NDggMzEwIC01NDAgMzIyIFwifSxcInY2Y1wiOntcInhfbWluXCI6LTEuMzU5Mzc1LFwieF9tYXhcIjoxOTMuMjgxMjUsXCJoYVwiOjE5NyxcIm9cIjpcIm0gNzggMjMzIGIgODcgMjMzIDgxIDIzMyA4NCAyMzMgYiAxODcgMTQwIDEzMiAyMzMgMTc0IDE5NSBiIDE5MyAxMDIgMTkwIDEyNyAxOTMgMTE1IGIgNDMgLTExMyAxOTMgMjIgMTM2IC02MiBiIDI3IC0xMTkgMzYgLTExNiAzMSAtMTE5IGIgMTkgLTEwOCAyMSAtMTE5IDE5IC0xMTUgYiAyOSAtOTcgMTkgLTEwMiAyMCAtMTAxIGIgMTAyIDEzIDczIC03MiAxMDIgLTI3IGIgOTIgNTEgMTAyIDI2IDk4IDQwIGwgOTEgNTQgbCA4NCA1NCBiIDggMTA0IDUzIDU0IDIxIDc0IGIgLTEgMTQyIDEgMTE2IC0xIDEzMCBiIDc4IDIzMyAtMSAxODcgMzEgMjI3IFwifSxcInY2ZFwiOntcInhfbWluXCI6LTU5MC43MTg3NSxcInhfbWF4XCI6NTg5LjM1OTM3NSxcImhhXCI6NjAxLFwib1wiOlwibSA1NDQgMzM1IGIgNTUzIDMzNyA1NDggMzM3IDU1MSAzMzcgYiA1NzUgMzEzIDU2MyAzMzcgNTcwIDMzMCBiIDU4OSAyMjYgNTgzIDI4NSA1ODkgMjU2IGIgNTE3IDggNTg5IDE1MiA1NjMgNzYgYiA0NjQgLTU4IDUwNyAtNCA1MDMgLTkgbCA0MDEgLTEzNiBiIDM2MiAtMTc2IDM3MiAtMTcyIDM3MCAtMTc2IGIgMzU3IC0xNzYgMzYwIC0xNzYgMzU5IC0xNzYgYiAyNjEgLTg3IDM0OSAtMTc0IDM1NSAtMTgwIGIgMTc1IDAgMjE1IC0zOCAxNzUgMCBiIDEwNiAtODYgMTc1IDAgMTQ0IC0zOCBiIDI5IC0xNzQgMzUgLTE3NCAzNiAtMTczIGIgMjQgLTE3NiAyOCAtMTc2IDI3IC0xNzYgYiAxNCAtMTc0IDIxIC0xNzYgMTcgLTE3NCBiIC03MyAtODcgMTIgLTE3MyAtOCAtMTUyIGIgLTE1OSAwIC0xMjEgLTM4IC0xNTkgMCBiIC0yMjggLTg2IC0xNjAgMCAtMTkwIC0zOCBiIC0zMDQgLTE3NCAtMjk5IC0xNzQgLTI5OCAtMTczIGIgLTMxMCAtMTc2IC0zMDYgLTE3NiAtMzA4IC0xNzYgYiAtMzE5IC0xNzQgLTMxNCAtMTc2IC0zMTggLTE3NCBiIC00ODMgLTEyIC0zMjMgLTE3MyAtMzU5IC0xMzcgbCAtNDk1IDAgbCAtNTI0IC0zNCBiIC01NjIgLTc3IC01NTMgLTczIC01NTYgLTc2IGIgLTU2OCAtNzkgLTU2NCAtNzkgLTU2NiAtNzkgYiAtNTkwIC01OCAtNTgxIC03OSAtNTkwIC02OSBiIC01ODggLTQ5IC01OTAgLTU1IC01ODkgLTUyIGIgLTQxMiAxNzAgLTU4NSAtNDMgLTQxNyAxNjUgYiAtMzk4IDE3NCAtNDA4IDE3MyAtNDAyIDE3NCBiIC0zODkgMTczIC0zOTQgMTc0IC0zOTIgMTc0IGIgLTMwMCA4NiAtMzg3IDE3MiAtMzY2IDE1MSBiIC0yMTUgLTEgLTI1NCAzNyAtMjE1IC0xIGIgLTE0NSA4NCAtMjE1IC0xIC0xODMgMzcgYiAtNjkgMTczIC03NCAxNzMgLTc2IDE3MiBiIC02MyAxNzQgLTY4IDE3NCAtNjYgMTc0IGIgLTU0IDE3MyAtNjEgMTc0IC01NyAxNzMgYiAzNCA4NiAtNTEgMTcyIC0zMSAxNTEgYiAxMTkgLTEgODEgMzcgMTE5IC0xIGIgMTg5IDg0IDEyMSAtMSAxNTEgMzcgYiAyNjUgMTczIDI1OSAxNzMgMjU4IDE3MiBiIDI3MCAxNzQgMjY2IDE3NCAyNjkgMTc0IGIgMjgwIDE3MyAyNzQgMTc0IDI3OSAxNzMgYiAzNzAgODQgMjgzIDE3MiAzMDMgMTUxIGIgNDU1IC0xIDQxNiAzNyA0NTUgLTEgbCA0NTUgLTEgYiA0NzYgMjQgNDU1IC0xIDQ2OSAxNSBiIDU0NyAyMjYgNTIyIDg3IDU0NyAxNTkgYiA1MzQgMzAyIDU0NyAyNTIgNTQzIDI3OCBiIDUzMiAzMTcgNTMzIDMwOCA1MzIgMzEzIGIgNTQ0IDMzNSA1MzIgMzI2IDUzNiAzMzMgXCJ9LFwidjZmXCI6e1wieF9taW5cIjotODAuMzEyNSxcInhfbWF4XCI6NzguOTM3NSxcImhhXCI6ODEsXCJvXCI6XCJtIDYzIDE5MSBiIDY5IDE5MiA2NSAxOTIgNjYgMTkyIGIgNzcgMTg4IDcyIDE5MiA3NiAxOTEgYiA3OCAxODMgNzggMTg3IDc4IDE4NiBiIDc0IDE1OCA3OCAxNzkgNzcgMTcyIGwgNjYgMTE1IGIgOSAtMTYxIDQ5IDMwIDEwIC0xNTggYiAtMTAgLTE4NyA2IC0xNzIgLTEgLTE4MSBiIC0zNCAtMTk0IC0xNyAtMTkxIC0yNSAtMTk0IGIgLTgwIC0xNDcgLTU4IC0xOTQgLTgwIC0xNzQgYiAtODAgLTE0MSAtODAgLTE0NCAtODAgLTE0MiBiIDkgNzAgLTgwIC0xMzQgLTczIC0xMTcgbCA0OSAxNjMgYiA2MyAxOTEgNTkgMTg4IDYxIDE5MCBcIn0sXCJ2NzBcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQzNi45MjE4NzUsXCJoYVwiOjQ0NixcIm9cIjpcIm0gMjEzIDE5MCBiIDIxNyAxOTEgMjE1IDE5MSAyMTYgMTkxIGIgMjMxIDE4NCAyMjMgMTkxIDIyOCAxODggYiAyNDkgMTU0IDI0MCAxNjcgMjQ2IDE1OSBiIDQxOSAxOCAyOTIgOTEgMzQ4IDQ1IGIgNDM2IC0xIDQzNSAxMSA0MzYgOCBiIDQyNCAtMTYgNDM2IC05IDQzNCAtMTMgYiAzMDggLTg3IDM5NCAtMjYgMzQwIC01OSBiIDIzMSAtMTg2IDI3NiAtMTE3IDI1NyAtMTQyIGIgMjE5IC0xOTIgMjI4IC0xOTEgMjI1IC0xOTIgYiAxOTggLTE3NCAyMDkgLTE5MiAyMDggLTE5MSBiIDQ3IC0zMyAxNjEgLTExMyAxMTAgLTYzIGIgMTAgLTE2IDM0IC0yNiAxNyAtMTkgYiAwIC0xIDIgLTEzIDAgLTkgYiAxNyAxOCAwIDggMSAxMSBiIDE5OCAxNzMgOTUgNDggMTU2IDEwMSBiIDIxMyAxOTAgMjA2IDE4NyAyMDggMTg4IFwifSxcInY3MlwiOntcInhfbWluXCI6LTQyMy4zMTI1LFwieF9tYXhcIjo0MjEuOTM3NSxcImhhXCI6NDMxLFwib1wiOlwibSAtMjYyIDE5NyBiIC0yNDcgMTk3IC0yNTcgMTk3IC0yNTMgMTk3IGIgLTExOCAxNjIgLTIxMCAxOTcgLTE2MyAxODQgYiA0MCA0NSAtNjEgMTM0IC0xMyA5OCBiIDI3NyAtOTUgMTE5IC0zMyAyMDAgLTgxIGIgMjg5IC05NyAyODEgLTk3IDI4NSAtOTcgYiAzNzggMCAzMzIgLTk3IDM3MSAtNTUgYiAzNzggMTEgMzc4IDQgMzc4IDYgYiAzMDIgODMgMzc4IDU1IDM0NSA4MyBiIDI0MiA2NiAyODMgODMgMjYyIDc3IGIgMjA4IDU2IDIzMSA1OSAyMTkgNTYgYiAxNDggMTIwIDE3NSA1NiAxNDggODEgYiAyMDEgMTg2IDE0OCAxNTEgMTY0IDE3MiBiIDI2MSAxOTggMjIwIDE5NCAyNDAgMTk4IGIgNDIwIDQ1IDM0MSAxOTggNDExIDEzNiBiIDQyMSAyMiA0MjEgMzcgNDIxIDI5IGIgMjQ1IC0xOTkgNDIxIC05MyAzMzggLTE5OSBiIDIzOCAtMTk4IDI0MyAtMTk5IDI0MCAtMTk5IGIgLTQ0IC00NyAxNDggLTE5NCA1MCAtMTQxIGIgLTI1MCA4NiAtMTE0IDIyIC0xODMgNjYgYiAtMjk1IDk0IC0yNzAgOTEgLTI4MyA5NCBiIC0zMTUgOTEgLTMwMiA5NCAtMzA3IDk0IGIgLTM4MSA0IC0zNTYgODEgLTM4MSA0MyBiIC0zNTUgLTU2IC0zODEgLTE4IC0zNzIgLTQwIGIgLTI5OCAtODEgLTMzOCAtNzMgLTMxOSAtODEgYiAtMjQ2IC02OCAtMjgzIC04MSAtMjY1IC03NyBiIC0yMTIgLTU4IC0yMzQgLTYxIC0yMjMgLTU4IGIgLTE3OCAtNjkgLTIwMCAtNTggLTE4OSAtNjIgYiAtMTUxIC0xMjIgLTE2MCAtODEgLTE1MSAtMTAxIGIgLTE3MSAtMTY3IC0xNTEgLTEzOCAtMTU3IC0xNTUgYiAtMjM5IC0xOTUgLTE4NSAtMTgxIC0yMTMgLTE5MiBiIC0yNTcgLTE5NyAtMjQ1IC0xOTcgLTI1MCAtMTk3IGIgLTQyMyAtNSAtMzUyIC0xOTcgLTQyMyAtMTA5IGIgLTQxMiA2NSAtNDIzIDE2IC00MTkgNDAgYiAtMjYyIDE5NyAtMzg5IDEzNyAtMzI5IDE4OCBcIn0sXCJ2NzRcIjp7XCJ4X21pblwiOi0yMDYuODkwNjI1LFwieF9tYXhcIjo0MjguNzUsXCJoYVwiOjQzOCxcIm9cIjpcIm0gMzg5IC0zNTEgYiAzOTQgLTM1MSAzOTAgLTM1MSAzOTMgLTM1MSBiIDQyOCAtMzg1IDQxMyAtMzUxIDQyOCAtMzY3IGIgNDI4IC0zOTQgNDI4IC0zODggNDI4IC0zOTEgYiAzOTQgLTQyOCA0MjYgLTQwNiA0MjEgLTQxMCBsIDMzMiAtNDczIGwgMjY5IC01MTYgbCAyMDUgLTU2MCBsIDE0MSAtNjAzIGwgNzcgLTY0OCBsIDEzIC02OTIgbCAtNTAgLTczNyBsIC0xMTQgLTc4MCBsIC0xNDUgLTgwMiBiIC0xNzEgLTgxMyAtMTU3IC04MTAgLTE2MyAtODEzIGIgLTE3NSAtODEzIC0xNzIgLTgxMyAtMTc0IC04MTMgYiAtMjA2IC03NzcgLTE5NCAtODExIC0yMDYgLTc5NSBiIC0yMDIgLTc2MCAtMjA2IC03NzEgLTIwNSAtNzY2IGIgLTg3IC02NzUgLTE5NyAtNzUyIC0yMDYgLTc1NyBsIC0zNCAtNjM5IGwgODMgLTU1NyBsIDE0NSAtNTE0IGwgMjA5IC00NzAgbCAyNzIgLTQyNyBiIDM4OSAtMzUxIDM3NSAtMzU2IDM4MSAtMzUyIFwifSxcInY3NVwiOntcInhfbWluXCI6LTE0OS43MTg3NSxcInhfbWF4XCI6MTQ4LjM1OTM3NSxcImhhXCI6MTUxLFwib1wiOlwibSAtMTM3IDM4MSBiIC0xMzAgMzgzIC0xMzQgMzgzIC0xMzMgMzgzIGIgLTExMSAzNzEgLTEyMiAzODMgLTExNCAzNzggYiAtNTUgMjI0IC0xMTAgMzcwIC04NSAzMDUgYiAwIDgwIC0yNSAxNDUgLTEgODAgYiA1NCAyMjQgMCA4MCAyNCAxNDUgYiAxMTIgMzc3IDExNCAzODQgMTEwIDM3MyBiIDEyNyAzODQgMTE4IDM4MSAxMjIgMzg0IGIgMTQ4IDM2MiAxMzggMzg0IDE0OCAzNzQgbCAxNDggMzU2IGwgODMgMTgzIGIgMTYgOSA0NyA4OCAxNyAxMSBiIC0xIDAgMTIgMiA1IDAgYiAtMTQgNSAtNSAwIC0xMCAxIGIgLTg0IDE4MyAtMTkgOSAtMTMgLTYgbCAtMTQ5IDM1NiBsIC0xNDkgMzYyIGIgLTEzNyAzODEgLTE0OSAzNzEgLTE0NSAzNzggXCJ9LFwidjc4XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoxOTMuMjgxMjUsXCJoYVwiOjE5NyxcIm9cIjpcIm0gODUgNTE0IGIgOTUgNTE3IDg4IDUxNyA4OSA1MTcgYiAxMTQgNTA1IDEwMyA1MTcgMTEwIDUxMyBsIDExNSA1MDIgbCAxMTUgMzc2IGIgMTE1IDI0OSAxMTUgMzA2IDExNSAyNDkgYiAxNDEgMjU4IDExNyAyNDkgMTI3IDI1MiBsIDE2NyAyNjYgbCAxNzIgMjY2IGIgMTkwIDI1NCAxODEgMjY1IDE4NyAyNjIgbCAxOTMgMjUxIGwgMTkzIDIwMiBsIDE5MyAxODggYiAxODcgMTQ3IDE5MyAxNDkgMTkxIDE1MiBiIDE0NyAxMzAgMTgzIDE0MiAxODIgMTQxIGwgMTE1IDExOSBsIDExNSA5IGIgMTE1IC05OSAxMTUgLTUxIDExNSAtOTkgYiAxNDEgLTkxIDExNSAtOTkgMTI3IC05NSBiIDE3MSAtODEgMTY2IC04MSAxNjcgLTgxIGwgMTcxIC04MSBiIDE5MSAtOTQgMTgxIC04MSAxODkgLTg3IGIgMTkzIC0xNDIgMTkxIC05NyAxOTMgLTEyMCBiIDE5MSAtMTk1IDE5MyAtMTY3IDE5MSAtMTk0IGIgMTI1IC0yMjcgMTg3IC0yMDUgMTg3IC0yMDQgbCAxMTUgLTIzMCBsIDExNSAtMzY2IGwgMTE1IC01MDMgbCAxMTQgLTUwNiBiIDk1IC01MTkgMTEwIC01MTQgMTAyIC01MTkgYiA3NCAtNTA2IDg3IC01MTkgNzggLTUxNCBsIDczIC01MDMgbCA3MyAtMzc0IGIgNzMgLTI0NSA3MyAtMjYwIDczIC0yNDUgYiA3MyAtMjQ1IDczIC0yNDUgNzMgLTI0NSBiIDU1IC0yNTIgNzIgLTI0NSA2MyAtMjQ5IGwgMzIgLTI2MCBiIDE5IC0yNjMgMjcgLTI2MiAyMyAtMjYzIGIgNCAtMjU2IDEzIC0yNjMgOCAtMjYwIGIgMCAtMjE1IDAgLTI1MSAwIC0yNTQgYiAwIC0xOTkgMCAtMjEwIDAgLTIwNiBsIDAgLTE1MiBsIDEgLTE0OSBiIDggLTE0MCAyIC0xNDUgNSAtMTQxIGIgNDIgLTEyNyA5IC0xNDAgMjQgLTEzMyBsIDczIC0xMTYgbCA3MyAtNSBiIDczIDIzIDczIDQgNzMgMTUgYiA3MyAxMDUgNzMgNzAgNzMgMTA1IGIgNDkgOTcgNzMgMTA1IDYxIDEwMSBiIDE3IDg4IDMyIDkxIDIzIDg4IGIgNCA5NSAxMCA4OCA4IDkxIGIgMCAxMzcgMCAxMDEgMCA5OCBiIDAgMTUxIDAgMTQxIDAgMTQ1IGwgMCAxOTkgbCAxIDIwMiBiIDQzIDIyNCA1IDIxMiA1IDIxMiBsIDczIDIzNCBsIDczIDM2NyBsIDczIDUwMiBsIDc0IDUwNSBiIDg1IDUxNCA3NyA1MDkgODEgNTEzIFwifSxcInY3OVwiOntcInhfbWluXCI6LTEuMzU5Mzc1LFwieF9tYXhcIjo4OTkuNzAzMTI1LFwiaGFcIjo5MTgsXCJvXCI6XCJtIDMwNyAzNDkgYiAzMzIgMzUxIDMxNSAzNTEgMzIzIDM1MSBiIDQ0MyAzNDAgMzY3IDM1MSA0MDggMzQ3IGIgNzQxIDQ3IDYwNyAzMDYgNzIwIDE5NSBiIDc0NCAwIDc0MyAzMSA3NDQgMTYgYiA2NjAgLTMwMyA3NDQgLTkwIDcxMyAtMjA2IGIgMjggLTc1NSA1MzQgLTUzMSAzMDQgLTY5NSBiIDE0IC03NTYgMjMgLTc1NSAxOSAtNzU2IGIgLTEgLTc0MSA0IC03NTYgLTEgLTc1MCBiIDIxIC03MjAgLTEgLTczMSAxIC03MjggYiA1NjcgLTU2IDMzNyAtNjAxIDU0OCAtMzQ0IGIgNTY4IC0xMSA1NjggLTQxIDU2OCAtMjQgYiA0NDIgMjg1IDU2OCAxMjkgNTI1IDIzMyBiIDMyNSAzMTkgNDA2IDMwOCAzNjcgMzE5IGIgOTMgMTc3IDIzMiAzMTkgMTM3IDI2NiBiIDg0IDE1NCA5MSAxNzAgODQgMTU1IGIgODQgMTU0IDg0IDE1NCA4NCAxNTQgYiA4OCAxNTYgODQgMTU0IDg1IDE1NSBiIDE1OSAxNzcgMTEwIDE3MCAxMzQgMTc3IGIgMjU3IDEzNCAxOTQgMTc3IDIzMSAxNjIgYiAyOTQgNDEgMjgxIDEwOCAyOTQgNzMgYiAxNzEgLTk3IDI5NCAtMjQgMjQ2IC05MCBiIDE1NiAtOTggMTY2IC05NyAxNjEgLTk4IGIgNiA3NCA3MyAtOTggNiAtMjIgYiA2IDgwIDYgNzYgNiA3OSBiIDMwNyAzNDkgMTAgMjIzIDE0MSAzNDAgbSA4MzkgMjE1IGIgODQ1IDIxNiA4NDEgMjE2IDg0MiAyMTYgYiA4NjIgMjEzIDg1MiAyMTYgODYwIDIxNSBiIDg5OSAxNjMgODg3IDIwNiA4OTkgMTg0IGIgODcyIDExNyA4OTkgMTQ1IDg5MCAxMjcgYiA4NDcgMTExIDg2NSAxMTIgODU2IDExMSBiIDgwOCAxMzAgODMzIDExMSA4MTggMTE3IGIgNzk2IDE2MiA4MDAgMTQwIDc5NiAxNTEgYiA4MzkgMjE1IDc5NiAxODcgODEyIDIxMiBtIDgzOSAtMTEyIGIgODQ1IC0xMTIgODQxIC0xMTIgODQyIC0xMTIgYiA4NjIgLTExNSA4NTIgLTExMiA4NjAgLTExMyBiIDg5OSAtMTY1IDg4NyAtMTIyIDg5OSAtMTQ0IGIgODcyIC0yMTAgODk5IC0xODMgODkwIC0yMDEgYiA4NDcgLTIxNyA4NjUgLTIxNSA4NTYgLTIxNyBiIDgwOCAtMTk4IDgzMyAtMjE3IDgxOCAtMjEwIGIgNzk2IC0xNjUgODAwIC0xODggNzk2IC0xNzcgYiA4MzkgLTExMiA3OTYgLTE0MCA4MTIgLTExNiBcIn0sXCJ2N2NcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjMwMC44MTI1LFwiaGFcIjozMDcsXCJvXCI6XCJtIDQ5IDUwNSBiIDUzIDUwNiA1MCA1MDUgNTEgNTA2IGIgNzAgNDk2IDU4IDUwNiA2MiA1MDMgYiA4MSA0ODUgNzMgNDkyIDc4IDQ4OCBsIDk2IDQ3MyBsIDExMSA0NTkgbCAxMjIgNDQ5IGwgMTM0IDQzOCBsIDE4MiAzOTYgbCAyNTUgMzMwIGIgMjkyIDI5MSAyOTIgMjk4IDI5MiAyOTggbCAyOTIgMjkwIGwgMjkyIDI4NCBsIDI4MyAyNzAgYiAyMDkgMzYgMjM0IDE5NyAyMDkgMTEzIGIgMjg4IC0xNzAgMjA5IC00NCAyMzUgLTExOSBiIDI5OSAtMTg0IDI5NSAtMTc5IDI5OSAtMTgxIGIgMzAwIC0xOTEgMzAwIC0xODcgMzAwIC0xODggYiAyODUgLTIwNiAzMDAgLTE5OSAyOTQgLTIwNiBiIDI4MCAtMjA2IDI4MyAtMjA2IDI4MSAtMjA2IGIgMjQ3IC0yMDEgMjcwIC0yMDIgMjU5IC0yMDEgYiAxNzYgLTIyMiAyMjMgLTIwMSAxOTcgLTIwOCBiIDExNCAtMzQwIDEzNiAtMjQ5IDExNCAtMjkyIGIgMTcyIC00NzEgMTE0IC0zODQgMTM0IC00MzMgYiAxODUgLTQ5MiAxODIgLTQ4MSAxODUgLTQ4NyBiIDE4MSAtNTAyIDE4NSAtNDk2IDE4MyAtNDk5IGIgMTcxIC01MDggMTc2IC01MDUgMTc0IC01MDggYiAxNTIgLTQ5OCAxNjYgLTUwOCAxNjAgLTUwMyBiIDAgLTI4NCA2NSAtNDI4IDEyIC0zNTIgYiAwIC0yNjAgMCAtMjc4IDAgLTI3MCBiIDEgLTIzOCAwIC0yNTIgMCAtMjQyIGIgMTQ4IC0xNDAgMTYgLTE3NyA3MyAtMTQwIGIgMjA5IC0xNDggMTY3IC0xNDAgMTg5IC0xNDIgYiAyMTUgLTE0OSAyMTIgLTE0OCAyMTUgLTE0OSBiIDIxNSAtMTQ5IDIxNSAtMTQ5IDIxNSAtMTQ5IGwgMjE1IC0xNDkgYiAyMDEgLTEzNiAyMTUgLTE0OCAyMDkgLTE0MiBsIDE1NyAtOTcgbCA5NiAtNDEgYiAxNyAzNCAyMSAyNCAxNyAyOSBiIDE3IDM3IDE3IDM2IDE3IDM2IGIgMTcgMzggMTcgMzcgMTcgMzggYiAyNSA1NiAxNyA0NCAxNyA0NCBiIDExMCAyOTggODEgMTMxIDExMCAyMTkgYiA0NiA0NzQgMTEwIDM2NyA4OCA0MzEgYiAzOCA0OTEgNDAgNDgwIDM4IDQ4NyBiIDQ5IDUwNSAzOCA0OTggNDIgNTAyIFwifSxcInY3ZFwiOntcInhfbWluXCI6LTEuMzU5Mzc1LFwieF9tYXhcIjo0MzYuOTIxODc1LFwiaGFcIjo0NDYsXCJvXCI6XCJtIDIxMyAyMDUgYiAyMTcgMjA1IDIxNSAyMDUgMjE2IDIwNSBiIDIzNCAxOTQgMjI0IDIwNSAyMzQgMTk5IGIgMjM2IDE4NyAyMzQgMTk0IDIzNSAxOTAgbCAyNDUgMTY3IGwgMjYxIDEyOSBsIDI3MCAxMDYgYiAzNTUgLTYxIDI5NCA1NCAzMjkgLTEzIGIgNDIwIC0xNjMgMzgxIC0xMDUgNDAyIC0xMzggYiA0MzYgLTE4OCA0MzUgLTE4NCA0MzYgLTE4NCBiIDQzNiAtMTkxIDQzNiAtMTkwIDQzNiAtMTkwIGIgNDIxIC0yMDYgNDM2IC0yMDEgNDMxIC0yMDYgbCA0MjEgLTIwNiBsIDQxNiAtMjA2IGwgNDA1IC0yMDEgYiAyMTcgLTE1OCAzNDcgLTE3MiAyODMgLTE1OCBiIDMxIC0yMDEgMTUzIC0xNTggODggLTE3MiBsIDIwIC0yMDYgbCAxNCAtMjA2IGwgMTQgLTIwNiBiIDAgLTE5MSA1IC0yMDYgMCAtMjAxIGIgLTEgLTE4OCAwIC0xOTAgLTEgLTE5MCBiIDE0IC0xNjMgLTEgLTE4NiAwIC0xODQgYiA5NSAtMzQgMzYgLTEzNiA3MiAtNzcgYiAxNjYgMTA2IDExOSA4IDE0OCA2OCBsIDE3NSAxMjkgbCAxODMgMTQ4IGwgMjAwIDE4OCBiIDIxMyAyMDUgMjA1IDE5OSAyMDggMjAyIFwifSxcInY3ZlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MzY3LjUsXCJoYVwiOjM3NSxcIm9cIjpcIm0gMCAxMjQgbCAwIDE4NyBsIDYxIDE4NyBsIDEyMiAxODcgbCAxMjIgMTM4IGwgMTIyIDkxIGwgMTUzIDYxIGwgMTgzIDMwIGwgMjEzIDYxIGwgMjQzIDkxIGwgMjQzIDEzOCBsIDI0MyAxODcgbCAzMDYgMTg3IGwgMzY3IDE4NyBsIDM2NyAxMjQgbCAzNjcgNjEgbCAzMjEgNjEgbCAyNzQgNjEgbCAyNDMgMzAgbCAyMTMgMCBsIDI0MyAtMzEgbCAyNzQgLTYyIGwgMzIxIC02MiBsIDM2NyAtNjIgbCAzNjcgLTEyNCBsIDM2NyAtMTg4IGwgMzA2IC0xODggbCAyNDMgLTE4OCBsIDI0MyAtMTQwIGwgMjQzIC05MyBsIDIxMyAtNjIgbCAxODMgLTMxIGwgMTUzIC02MiBsIDEyMiAtOTMgbCAxMjIgLTE0MCBsIDEyMiAtMTg4IGwgNjEgLTE4OCBsIDAgLTE4OCBsIDAgLTEyNCBsIDAgLTYyIGwgNDYgLTYyIGwgOTIgLTYyIGwgMTIzIC0zMSBsIDE1MyAwIGwgMTIzIDMwIGwgOTIgNjEgbCA0NiA2MSBsIDAgNjEgbCAwIDEyNCBcIn0sXCJ2ODBcIjp7XCJ4X21pblwiOjI5LjkzNzUsXCJ4X21heFwiOjQyMC41NzgxMjUsXCJoYVwiOjM3MSxcIm9cIjpcIm0gMTE1IDM0NSBiIDIyMSAzNDcgMTE3IDM0NSAxNjYgMzQ3IGIgNDExIDM0NSAzMDYgMzQ3IDQwOSAzNDUgYiA0MjAgMzMwIDQxNiAzNDIgNDIwIDMzNSBiIDQxNSAzMTkgNDIwIDMyNiA0MTkgMzIxIGIgMTc4IDExOCAzOTcgMzAzIDE3OSAxMTggYiAxNzggMTE3IDE3OCAxMTggMTc4IDExNyBiIDE4MSAxMTcgMTc4IDExNyAxNzggMTE3IGIgMTg5IDExNyAxODIgMTE3IDE4NSAxMTcgYiAxOTMgMTE3IDE5MCAxMTcgMTkxIDExNyBiIDI0NyA5OCAyMTUgMTE3IDIzMiAxMTEgYiAyOTYgNzUgMjY2IDgzIDI4MCA3NiBiIDMwMiA3NSAyOTkgNzUgMzAwIDc1IGIgMzIyIDkxIDMxMSA3NSAzMTUgNzkgYiAzMjIgOTEgMzIyIDkxIDMyMiA5MSBiIDMyMiA5MSAzMjIgOTEgMzIyIDkxIGIgMzE5IDkxIDMyMiA5MSAzMjEgOTEgYiAzMTMgOTAgMzE4IDkwIDMxNSA5MCBiIDI4MyAxMDcgMzAwIDkwIDI4OCA5NyBiIDI3NyAxMjYgMjc5IDExNCAyNzcgMTIxIGIgMzE5IDE2NyAyNzcgMTQ5IDI5NSAxNjcgYiAzMTkgMTY3IDMxOSAxNjcgMzE5IDE2NyBiIDM2MiAxMTggMzQ3IDE2NyAzNjIgMTQ3IGIgMzU1IDgyIDM2MiAxMDggMzU5IDk2IGIgMzExIDMzIDM0OSA2NSAzNDAgNTUgYiAyMjQgMSAyODQgMTIgMjUzIDEgYiAxOTQgNSAyMTMgMSAyMDQgMiBiIDE2OCAxOCAxODMgOCAxNzggMTEgYiAxMTAgMzYgMTUxIDMwIDEzMCAzNiBiIDU3IDE1IDg4IDM2IDY4IDI5IGIgNDcgMTEgNTQgMTIgNTEgMTEgYiAzMSAyMCA0MCAxMSAzNCAxMyBiIDI5IDI2IDMxIDIyIDI5IDI1IGIgNjggNjYgMjkgMzYgMzkgNDUgYiAyODUgMjUwIDczIDcxIDI4MSAyNDggYiAyODUgMjUwIDI4NSAyNTAgMjg1IDI1MCBiIDIzMSAyNTIgMjg1IDI1MiAyNjEgMjUyIGIgMTM3IDI1MCAxOTAgMjUyIDE0MSAyNTAgYiA5MyAyMjcgMTIyIDI0OCAxMTAgMjQxIGIgNzggMjIwIDg4IDIyMiA4MyAyMjAgYiA2NiAyMjcgNzQgMjIwIDcwIDIyMiBiIDYzIDIzNCA2NSAyMjkgNjMgMjMxIGIgODUgMjkxIDYzIDI0MSA2OSAyNTIgYiAxMTUgMzQ1IDEwOCAzNDIgMTA4IDM0NCBcIn0sXCJ2ODFcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQyOC43NSxcImhhXCI6NDM4LFwib1wiOlwibSAyNjIgMTg2IGIgMjczIDE4NiAyNjYgMTg2IDI3MiAxODYgYiAyNzQgMTg2IDI3MyAxODYgMjc0IDE4NiBiIDI4NSAxODYgMjc0IDE4NiAyODAgMTg2IGIgNDI4IDQ4IDM3NSAxODEgNDI4IDEyMiBiIDM4NiAtNjggNDI4IDEyIDQxNiAtMjkgYiAxNTUgLTE4NyAzMjkgLTE0NSAyMzYgLTE4NyBiIDEyIC0xMTEgOTIgLTE4NyAzOCAtMTYyIGIgMCAtNTEgNCAtOTEgMCAtNzIgYiAyNjIgMTg2IDAgNTggMTIyIDE3OSBtIDM2NiAxMzEgYiAzNTIgMTM0IDM2MiAxMzMgMzU3IDEzNCBiIDIxOSA4MSAzMjEgMTM0IDI2OSAxMTUgYiA0NyAtMTExIDEyNiAyMyA1MCAtNjIgYiA0NyAtMTEyIDQ3IC0xMTEgNDcgLTExMiBiIDc3IC0xMzYgNDcgLTEyOSA1OCAtMTM2IGIgMjY0IC00NSAxMTggLTEzNiAxOTQgLTEwMSBiIDM4MiAxMDkgMzM2IDEyIDM4MiA3NiBiIDM2NiAxMzEgMzgyIDEyMCAzNzcgMTI5IFwifSxcInY4M1wiOntcInhfbWluXCI6LTEuMzU5Mzc1LFwieF9tYXhcIjo4NDcuOTY4NzUsXCJoYVwiOjg2NSxcIm9cIjpcIm0gNDg4IDE0OTkgYiA0OTUgMTUwMCA0OTAgMTUwMCA0OTIgMTUwMCBiIDU0MSAxNDY1IDUwNyAxNTAwIDUyMSAxNDkwIGIgNjc5IDEwNzggNjIyIDEzNzIgNjc5IDEyMTAgYiA2NzcgMTA1MCA2NzkgMTA2OCA2NzcgMTA2MCBiIDQ3NyA2NDIgNjY4IDg5MyA2MDQgNzY0IGwgNDQzIDYwOSBsIDQzMSA1OTYgbCA0MzEgNTkyIGwgNDM4IDU2MiBsIDQ0OSA1MDggbCA0NjAgNDU4IGIgNDgxIDM1NSA0NzUgMzkwIDQ4MSAzNTUgYiA0ODEgMzU1IDQ4MSAzNTUgNDgxIDM1NSBiIDQ5MCAzNTYgNDgxIDM1NSA0ODUgMzU1IGIgNTI4IDM1OCA0OTUgMzU2IDUxMSAzNTggYiA1NTggMzU2IDU0MCAzNTggNTUyIDM1NiBiIDgzOSA5NSA2OTkgMzM4IDgwOCAyMzcgYiA4NDcgMjIgODQ1IDcyIDg0NyA0NyBiIDYzMSAtMzAzIDg0NyAtMTEzIDc2NiAtMjQyIGIgNjIwIC0zMDkgNjIzIC0zMDggNjIwIC0zMDkgbCA2MjAgLTMxMCBiIDYzMSAtMzU5IDYyMCAtMzEwIDYyNiAtMzMzIGwgNjQ2IC00MzUgbCA2NjAgLTQ5NiBiIDY3MiAtNTg4IDY2OCAtNTM1IDY3MiAtNTYzIGIgNjY0IC02NTMgNjcyIC02MTAgNjY5IC02MzAgYiAzODMgLTg3NSA2MzAgLTc5MiA1MDkgLTg3NSBiIDIwMSAtODEwIDMyMSAtODc1IDI1NyAtODU1IGIgMTI5IC02ODAgMTUxIC03NjggMTI5IC03MzAgYiAyNzQgLTUzMCAxMjkgLTU5MiAyMDAgLTUzMCBiIDM1MSAtNTUzIDMwMCAtNTMwIDMyNiAtNTM4IGIgNDEyIC02NjkgMzkzIC01ODIgNDEyIC02MjYgYiAyODcgLTgwNSA0MTIgLTczNSAzNjYgLTgwMCBsIDI3OSAtODA1IGwgMjg1IC04MDkgYiAzODMgLTgzMCAzMTggLTgyMyAzNTEgLTgzMCBiIDU4NiAtNzE4IDQ2NCAtODMwIDU0MCAtNzg5IGIgNjI2IC01ODQgNjEyIC02NzggNjI2IC02MzEgYiA2MTkgLTUyOCA2MjYgLTU2NiA2MjMgLTU0OCBiIDYxMiAtNDk1IDYxOSAtNTI2IDYxNiAtNTEwIGIgNTc3IC0zMjQgNTkwIC0zODcgNTc3IC0zMjQgYiA1NzcgLTMyNCA1NzcgLTMyNCA1NzcgLTMyNCBiIDU2OCAtMzI2IDU3NSAtMzI0IDU3MSAtMzI0IGIgNTI4IC0zMzQgNTU4IC0zMjggNTM3IC0zMzMgYiA0NjUgLTMzOCA1MDYgLTMzNyA0ODUgLTMzOCBiIDI0IC0xMSAyNjkgLTMzOCA4NyAtMjA2IGIgLTEgMTQ1IDggNDEgLTEgOTMgYiA5NiA0NDIgLTEgMjQ5IDMyIDM1MSBiIDMyMiA3MTQgMTY2IDU0MSAyMzYgNjI2IGwgMzUyIDc0NSBsIDM0NSA3ODIgbCAzMzIgODQzIGwgMzE1IDkyMSBiIDMwMyA5ODQgMzEwIDk1MCAzMDQgOTc4IGIgMjk1IDEwODIgMjk4IDEwMTcgMjk1IDEwNDkgYiA0MTMgMTQyNiAyOTUgMTIwOCAzMzYgMTMyOSBiIDQ4OCAxNDk5IDQzNiAxNDU2IDQ3NyAxNDk2IG0gNTQ5IDEzMDEgYiA1NDEgMTMwMSA1NDcgMTMwMSA1NDQgMTMwMSBiIDQxMSAxMjA3IDUwMCAxMzAxIDQ0NyAxMjYzIGIgMzU1IDEwMDQgMzc0IDExNTIgMzU1IDEwNzkgYiAzNTkgOTQyIDM1NSA5ODQgMzU2IDk2MyBiIDM3MSA4ODEgMzYyIDkyNyAzNjMgOTE3IGwgMzg1IDgxOCBiIDM5MiA3ODIgMzg5IDc5OSAzOTIgNzg0IGwgMzkyIDc4MiBiIDQzNCA4MjggMzkzIDc4MiA0MjQgODE2IGIgNjA3IDExNjUgNTM0IDk0MSA1OTQgMTA2MCBiIDYwOCAxMTkzIDYwOCAxMTc1IDYwOCAxMTgzIGIgNTk3IDEyNzAgNjA4IDEyMjQgNjA0IDEyNTQgYiA1NDkgMTMwMSA1ODkgMTI4NiA1NzEgMTI5OSBtIDM5OCA1MjggYiAzOTMgNTU1IDM5NiA1NDIgMzkzIDU1MyBiIDM5MiA1NTUgMzkzIDU1NSAzOTMgNTU1IGIgMzE3IDQ3MCAzOTAgNTU1IDM0NyA1MDUgYiAxOTAgMjk4IDI2NiA0MDggMjEyIDMzNCBiIDEyNyA3MCAxNDggMjI3IDEyNyAxNDggYiAxNTUgLTc3IDEyNyAxOSAxMzcgLTMwIGIgNDY4IC0zMDMgMjA5IC0yMTYgMzMzIC0zMDMgYiA1MTkgLTI5OSA0ODQgLTMwMyA1MDIgLTMwMiBiIDU2OCAtMjg0IDU0MSAtMjk1IDU2OCAtMjg3IGwgNTY4IC0yODQgYiA1NjMgLTI2MyA1NjggLTI4NCA1NjYgLTI3NCBsIDUzNCAtMTIwIGwgNTExIC0xMyBsIDQ5NiA2MSBsIDQ4MCAxMzMgYiA0NjkgMTg3IDQ3MiAxNzYgNDY5IDE4NyBiIDQ2OCAxODggNDY5IDE4NyA0NjkgMTg4IGIgNDE2IDE2MiA0NjIgMTg4IDQzMCAxNzIgYiAzMzcgMTMgMzY0IDEyNiAzMzcgNjkgYiA0MTMgLTEyNCAzMzcgLTQwIDM2MyAtOTMgYiA0MjggLTE0NCA0MjQgLTEzMSA0MjggLTEzNyBiIDQyOCAtMTQ5IDQyOCAtMTQ1IDQyOCAtMTQ4IGIgNDA5IC0xNjYgNDI2IC0xNjEgNDE5IC0xNjYgYiAzOTQgLTE2MiA0MDUgLTE2NiA0MDAgLTE2NSBiIDI0MCA3NyAzMDIgLTEyMiAyNDAgLTI3IGwgMjQwIDc3IGIgNDMwIDM0MiAyNDAgMTk3IDMxNSAzMDEgbCA0MzYgMzQ0IGwgNDI2IDM5NCBsIDM5OCA1MjggbSA1NDggMTk0IGIgNTI2IDE5NSA1NDAgMTk1IDUzMiAxOTUgYiA1MTkgMTk1IDUyNCAxOTUgNTIxIDE5NSBsIDUxNCAxOTUgbCA1MTggMTc3IGwgNTM5IDc5IGwgNTUyIDE1IGwgNTY2IC00OCBsIDU5NCAtMTg3IGwgNjA1IC0yNDAgYiA2MTIgLTI2NiA2MDkgLTI1NCA2MTEgLTI2NiBiIDYxMiAtMjY2IDYxMiAtMjY2IDYxMiAtMjY2IGIgNjQxIC0yNDggNjEzIC0yNjYgNjMwIC0yNTYgYiA3NDQgLTk4IDY5MiAtMjEyIDczMCAtMTU2IGIgNzUxIC00MCA3NDkgLTc5IDc1MSAtNTkgYiA1NDggMTk0IDc1MSA3NiA2NjUgMTgxIFwifSxcInY4NFwiOntcInhfbWluXCI6MjUuODU5Mzc1LFwieF9tYXhcIjoxNjQuNjg3NSxcImhhXCI6MTY4LFwib1wiOlwibSAzNCAzNjkgYiA0MCAzNzAgMzUgMzcwIDM4IDM3MCBiIDU5IDM1MyA0OSAzNzAgNTAgMzY3IGIgMTY0IDQwIDEyMiAyNTQgMTU1IDE1OCBiIDE2NCAwIDE2NCAzMyAxNjQgMTYgYiAxNjQgLTQwIDE2NCAtMTYgMTY0IC0zNCBiIDU5IC0zNTMgMTU1IC0xNTggMTIyIC0yNTQgYiA0MCAtMzcxIDUzIC0zNjYgNDcgLTM3MSBiIDM0IC0zNzAgMzggLTM3MSAzNiAtMzcwIGIgMjUgLTM1OCAyOCAtMzY3IDI1IC0zNjMgYiAzMSAtMzM3IDI1IC0zNTIgMjcgLTM0NyBiIDkyIDAgNzIgLTIzNCA5MiAtMTE3IGIgMzEgMzM1IDkyIDExNiA3MiAyMzMgYiAyNSAzNTYgMjcgMzQ1IDI1IDM1MiBiIDM0IDM2OSAyNSAzNjMgMjggMzY2IFwifSxcInY4NlwiOntcInhfbWluXCI6LTU3MS42NzE4NzUsXCJ4X21heFwiOjU3MC4zMTI1LFwiaGFcIjo1ODIsXCJvXCI6XCJtIC0zODYgMTczIGIgLTM4MSAxNzQgLTM4NSAxNzQgLTM4MyAxNzQgYiAtMzcwIDE3MyAtMzc3IDE3NCAtMzcyIDE3MyBiIC0yODEgODYgLTM2NyAxNzIgLTM0NyAxNTEgYiAtMTk2IDAgLTIzNSAzNyAtMTk2IDAgYiAtMTI2IDg0IC0xOTYgMCAtMTY0IDM3IGIgLTUwIDE3NCAtNTUgMTczIC01NyAxNzIgYiAtNDQgMTc0IC00OSAxNzQgLTQ3IDE3NCBiIC0zNSAxNzMgLTQyIDE3NCAtMzggMTczIGIgNTMgODYgLTMyIDE3MiAtMTIgMTUxIGIgMTM4IDAgMTAwIDM3IDEzOCAwIGIgMjA4IDg0IDE0MCAwIDE3MCAzNyBiIDI4NCAxNzQgMjc5IDE3MyAyNzcgMTcyIGIgMjg5IDE3NCAyODUgMTc0IDI4OCAxNzQgYiAyOTkgMTczIDI5NCAxNzQgMjk4IDE3MyBiIDQ2MiAxMSAzMDMgMTcyIDMzOCAxMzQgbCA0NzUgLTEgbCA1MDMgMzQgYiA1NDEgNzYgNTM0IDcyIDUzNiA3NCBiIDU0OCA3NyA1NDQgNzcgNTQ1IDc3IGIgNTcwIDU2IDU2MCA3NyA1NzAgNjggYiA1NjcgNDggNTcwIDU0IDU2OCA1MSBiIDM5MiAtMTcyIDU2NCA0MSAzOTcgLTE2NiBiIDM3OCAtMTc2IDM4NyAtMTc0IDM4MiAtMTc2IGIgMzY4IC0xNzQgMzc0IC0xNzYgMzcxIC0xNzYgYiAyODAgLTg3IDM2NyAtMTczIDM0NSAtMTUyIGIgMTk0IDAgMjM0IC0zOCAxOTQgMCBiIDEyNSAtODYgMTk0IDAgMTYzIC0zOCBiIDQ5IC0xNzQgNTQgLTE3NCA1NSAtMTczIGIgNDMgLTE3NiA0NyAtMTc2IDQ2IC0xNzYgYiAzNCAtMTc0IDQwIC0xNzYgMzYgLTE3NCBiIC01NCAtODcgMzEgLTE3MyAxMCAtMTUyIGIgLTE0MCAwIC0xMDIgLTM4IC0xNDAgMCBiIC0yMDkgLTg2IC0xNDEgMCAtMTcxIC0zOCBiIC0yODUgLTE3NCAtMjgwIC0xNzQgLTI3OSAtMTczIGIgLTI5MSAtMTc2IC0yODcgLTE3NiAtMjg5IC0xNzYgYiAtMzAwIC0xNzQgLTI5NSAtMTc2IC0yOTkgLTE3NCBiIC00NjQgLTEyIC0zMDQgLTE3MyAtMzQwIC0xMzcgbCAtNDc2IDAgbCAtNTA0IC0zNCBiIC01NDMgLTc3IC01MzQgLTczIC01MzcgLTc2IGIgLTU0OSAtNzkgLTU0NSAtNzkgLTU0NyAtNzkgYiAtNTcxIC01OCAtNTYyIC03OSAtNTcxIC02OSBiIC01NjggLTQ5IC01NzEgLTU1IC01NzAgLTUyIGIgLTM5MiAxNzIgLTU2NiAtNDMgLTM5NiAxNjcgYiAtMzg2IDE3MyAtMzkwIDE3MiAtMzg3IDE3MyBcIn0sXCJ2OGFcIjp7XCJ4X21pblwiOi0xNzAuMTQwNjI1LFwieF9tYXhcIjoxNjguNzgxMjUsXCJoYVwiOjE3MixcIm9cIjpcIm0gLTE2MCA1NjcgYiAtMTIyIDU2NyAtMTU5IDU2NyAtMTQ5IDU2NyBsIC04NyA1NjcgbCAtODQgNTY2IGIgLTc0IDU1MyAtNzggNTYzIC03NyA1NjAgYiAtMjAgMzY2IC03MyA1NTEgLTQ5IDQ2NiBiIDMxIDE4NiA4IDI2NyAzMSAxODYgYiA4NSAzNzEgMzEgMTg2IDU1IDI2OSBiIDE0MCA1NTkgMTE0IDQ3MyAxMzggNTU3IGIgMTUzIDU2NyAxNDEgNTY0IDE0OCA1NjcgYiAxNjggNTU5IDE1OSA1NjcgMTY2IDU2NCBiIDE2OCA1NTUgMTY4IDU1NyAxNjggNTU3IGIgOTIgMjgxIDE2OCA1NDggMTU5IDUxMyBiIDE0IDEzIDUwIDEzNCAxNCAxMyBiIDAgMCAxNCA2IDYgMCBiIC0xNyAxNSAtOCAwIC0xNyA4IGIgLTkzIDI4MyAtMTcgMTUgLTUxIDEzNiBiIC0xNzAgNTUyIC0xNjYgNTMzIC0xNzAgNTQ4IGIgLTE3MCA1NTMgLTE3MCA1NTIgLTE3MCA1NTIgYiAtMTYwIDU2NyAtMTcwIDU2MCAtMTY3IDU2NCBcIn0sXCJ2OGJcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjMxOS44NTkzNzUsXCJoYVwiOjMyNixcIm9cIjpcIm0gMTQ5IDUwOCBiIDE1OSA1MDkgMTUyIDUwOSAxNTUgNTA5IGIgMTg2IDQ5NCAxNzAgNTA5IDE4MSA1MDMgYiAxOTAgNDQwIDE5MCA0ODcgMTkwIDQ4OCBsIDE5MCA0MzAgbCAxOTAgMzc3IGwgMjQyIDM3NyBsIDI1MSAzNzcgYiAzMDMgMzczIDI5OCAzNzcgMjk2IDM3NyBiIDMxOSAzNDUgMzE0IDM2NyAzMTkgMzU2IGIgMzA0IDMxOSAzMTkgMzM1IDMxNCAzMjQgYiAyNTAgMzE1IDI5NiAzMTUgMjk5IDMxNSBsIDI0MiAzMTUgbCAxOTAgMzE1IGwgMTkwIDI2MiBsIDE5MCAyNTIgYiAxODYgMTk4IDE5MCAyMDQgMTkwIDIwNSBiIDE1OSAxODMgMTc5IDE4OCAxNzAgMTgzIGIgMTMyIDE5OCAxNDggMTgzIDEzOCAxODggYiAxMjcgMjUyIDEyNyAyMDUgMTI3IDIwNCBsIDEyNyAyNjIgbCAxMjcgMzE1IGwgNzYgMzE1IGwgNjggMzE1IGIgMTQgMzE5IDIwIDMxNSAyMSAzMTUgYiAwIDM0NyA0IDMyNCAwIDMzNSBiIDE0IDM3MyAwIDM1NiA0IDM2NyBiIDY4IDM3NyAyMSAzNzcgMjAgMzc3IGwgNzYgMzc3IGwgMTI3IDM3NyBsIDEyNyA0MzAgbCAxMjcgNDQwIGIgMTMyIDQ5NCAxMjcgNDg4IDEyNyA0ODcgYiAxNDkgNTA4IDEzNiA1MDEgMTQyIDUwNSBcIn0sXCJ2OGNcIjp7XCJ4X21pblwiOi0zMzAuNzUsXCJ4X21heFwiOjMyOS4zOTA2MjUsXCJoYVwiOjMzNixcIm9cIjpcIm0gLTEzMyA0ODMgYiAtMTE3IDQ4NCAtMTI3IDQ4NCAtMTIyIDQ4NCBiIDMxIDM3MyAtNTEgNDg0IDkgNDQwIGIgMzUgMzQ4IDM0IDM2NSAzNSAzNTYgYiAtMjUgMjg1IDM1IDMxMyAxMCAyODUgYiAtODcgMzMxIC01NSAyODUgLTc2IDMwMiBiIC0xNjcgNDAyIC0xMDAgMzc2IC0xMzMgNDAyIGIgLTE5MSAzOTggLTE3NSA0MDIgLTE4MyA0MDEgYiAtMjI3IDM0MSAtMjE1IDM4OCAtMjI3IDM2OSBiIC0yMjUgMzIwIC0yMjcgMzM0IC0yMjcgMzI3IGIgLTEzIDc0IC0yMDkgMjMwIC0xMjUgMTMzIGIgNiA2NSAtNCA3MCA1IDY2IGwgOSA2MyBsIDEwIDY1IGIgMTE3IDIzMSAxMiA2OCA0MCAxMTIgbCAxODkgMzQxIGwgMjQyIDQyNCBiIDI2OCA0NjAgMjYyIDQ1NiAyNjQgNDU4IGIgMjgzIDQ2NCAyNzMgNDYzIDI3NyA0NjQgYiAzMDggNDM4IDI5NiA0NjQgMzA4IDQ1MyBsIDMwOCA0MzcgYiAyODcgMzk2IDMwOCA0MzAgMzA4IDQyOCBsIDk1IDk4IGwgNTkgNDMgbCA1OCA0MSBsIDY1IDM3IGIgMjUzIC0xNTYgMTUxIC04IDIxNyAtNzcgYiAyODEgLTI4NSAyNzIgLTE5OSAyODEgLTI0NCBiIDE0OCAtNDgxIDI4MSAtMzgxIDIzMSAtNDYzIGIgMTE1IC00ODUgMTM3IC00ODQgMTI2IC00ODUgYiAtMzIgLTM3NiA1MSAtNDg1IC05IC00NDIgYiAtMzYgLTM0OSAtMzUgLTM2NiAtMzYgLTM1OCBiIDI1IC0yODcgLTM2IC0zMTUgLTEyIC0yODcgYiA4NSAtMzMzIDU0IC0yODcgNzQgLTMwMiBiIDE2NiAtNDAzIDk5IC0zNzcgMTMzIC00MDMgYiAxOTAgLTM5OSAxNzQgLTQwMyAxODIgLTQwMiBiIDIyNSAtMzQyIDIxNSAtMzkwIDIyNSAtMzcwIGIgMjI0IC0zMjIgMjI1IC0zMzUgMjI1IC0zMjggYiAxMiAtNzYgMjA4IC0yMzEgMTI1IC0xMzQgYiAtOCAtNjYgMiAtNzIgLTYgLTY4IGwgLTEwIC02NSBsIC0xMiAtNjYgYiAtMTE4IC0yMzEgLTEzIC02OCAtNDIgLTExMyBsIC0xOTAgLTM0MiBsIC0yNDMgLTQyNiBiIC0yNjkgLTQ2MiAtMjY0IC00NTggLTI2NSAtNDU4IGIgLTI4NCAtNDY2IC0yNzQgLTQ2NCAtMjc5IC00NjYgYiAtMzEwIC00NDAgLTI5OCAtNDY2IC0zMTAgLTQ1NSBsIC0zMTAgLTQzOCBiIC0yODggLTM5OCAtMzEwIC00MzAgLTMwOCAtNDMwIGwgLTk2IC05OSBsIC01OSAtNDQgbCAtNTkgLTQzIGwgLTY2IC0zOCBiIC0yODEgMjg0IC0xOTggMzMgLTI4MSAxNTggbCAtMjgxIDI4NCBiIC0xMzMgNDgzIC0yODEgMzkyIC0yMjAgNDc0IG0gMjU0IDE3NyBiIDI2NiAxNzkgMjU4IDE3NyAyNjIgMTc5IGIgMzE5IDE0OSAyODcgMTc5IDMwNyAxNjcgYiAzMjkgMTE1IDMyNiAxNDAgMzI5IDEyNyBiIDMxOSA3OSAzMjkgMTAyIDMyNiA5MCBiIDI2OCA1MSAzMDcgNjEgMjg3IDUxIGIgMjIxIDcyIDI1MCA1MSAyMzQgNTggYiAyMDUgMTE1IDIxMCA4NCAyMDUgOTkgYiAyNTQgMTc3IDIwNSAxNDIgMjIzIDE3MCBtIC0yODEgLTU0IGIgLTI2OSAtNTIgLTI3NyAtNTIgLTI3MyAtNTIgYiAtMjIzIC03MyAtMjUzIC01MiAtMjM1IC01OSBiIC0yMDYgLTExNiAtMjEyIC04NCAtMjA2IC0xMDEgYiAtMjE2IC0xNTEgLTIwNiAtMTI5IC0yMDkgLTE0MSBiIC0yNjkgLTE3OSAtMjI4IC0xNzAgLTI0OSAtMTc5IGIgLTMxNCAtMTU5IC0yODUgLTE3OSAtMzAyIC0xNzMgYiAtMzMwIC0xMTYgLTMyNSAtMTQ3IC0zMzAgLTEzMSBiIC0yODEgLTU0IC0zMzAgLTg4IC0zMTMgLTYxIFwifSxcInY4ZlwiOntcInhfbWluXCI6LTIxLjc4MTI1LFwieF9tYXhcIjozNjIuMDYyNSxcImhhXCI6MzY5LFwib1wiOlwibSAzMDIgMTAzMSBiIDMwOCAxMDMyIDMwNCAxMDMyIDMwNyAxMDMyIGIgMzMwIDEwMTYgMzE4IDEwMzIgMzI1IDEwMjcgYiAzNjIgODY3IDM1MSA5NzAgMzYyIDkyMCBiIDM0MCA3MzggMzYyIDgyNCAzNTMgNzgwIGwgMzM2IDcyNyBsIDM0MCA3MTcgYiAzNjIgNTkxIDM1NSA2NzcgMzYyIDYzNCBiIDI1NyAzMjMgMzYyIDQ5NiAzMjUgNDAxIGIgMjA0IDI3MiAyNDMgMzA2IDIyNyAyOTAgYiAyMCA1NiAxMjkgMjA2IDY2IDEzMyBiIC0xIDE4IDEyIDQ0IDAgMjIgYiAtMTkgNCAtNCA5IC0xMiA0IGwgLTIxIDQgbCAtMjEgMTQwIGwgLTIxIDI3NiBsIC0xMiAyNzcgYiAxNjcgMzMzIDYxIDI4OCAxMjcgMzA5IGIgMzE5IDU5OCAyNjIgMzg4IDMxOSA0OTEgYiAzMTEgNjY0IDMxOSA2MjAgMzE3IDY0MiBsIDMxMCA2NzMgbCAzMDQgNjY0IGIgMjA0IDU0OCAyNzkgNjIwIDI1MCA1ODcgYiAyMCAzMzMgMTI5IDQ4MyA2NiA0MDkgYiAtMSAyOTIgMTIgMzIwIDAgMjk4IGIgLTE5IDI4MCAtNCAyODUgLTEyIDI4MCBsIC0yMSAyODAgbCAtMjEgNDE2IGwgLTIxIDU1MiBsIC0xMiA1NTMgYiAxNjcgNjA5IDYxIDU2NCAxMjcgNTg1IGIgMzE5IDg3NCAyNjQgNjY2IDMxOSA3NzAgYiAyOTQgOTkyIDMxOSA5MTQgMzExIDk1NCBiIDI4OCAxMDExIDI4OCAxMDA0IDI4OCAxMDA3IGIgMzAyIDEwMzEgMjg4IDEwMjEgMjk0IDEwMjggXCJ9LFwidjkwXCI6e1wieF9taW5cIjotMTcxLjUsXCJ4X21heFwiOjQ4My4xODc1LFwiaGFcIjo0OTMsXCJvXCI6XCJtIC04IDYzMSBiIC0xIDYzMiAtNiA2MzIgLTQgNjMyIGIgMTkgNjIwIDggNjMyIDE2IDYyOCBiIDIwIDQ5NSAyMCA2MTYgMjAgNjE2IGIgMjAgMzczIDIwIDQyNyAyMCAzNzMgYiAxMTUgNDEwIDIwIDM3MyA2MyAzOTAgbCAyMTAgNDQ4IGwgMjEwIDUzMSBiIDIxMiA2MjAgMjEwIDYxNCAyMTAgNjE2IGIgMjMxIDYzMiAyMTUgNjI4IDIyMyA2MzIgYiAyNDYgNjI3IDIzNiA2MzIgMjQyIDYzMSBiIDI1MSA1NDEgMjUxIDYyMCAyNTEgNjI4IGwgMjUxIDQ2MyBsIDMxNSA0ODkgYiAzODcgNTE0IDM2OCA1MDkgMzgxIDUxNCBiIDM5MyA1MTMgMzkwIDUxNCAzOTIgNTE0IGIgNDA2IDQ5NCA0MDIgNTEwIDQwNiA1MDIgYiAzOTcgNDc2IDQwNiA0ODcgNDA0IDQ4MCBiIDMyMyA0NDYgMzk2IDQ3NCAzNjMgNDYyIGwgMjUxIDQxNyBsIDI1MSAyODMgbCAyNTEgMTQ4IGwgMjU0IDE1MSBiIDM3MCAxOTkgMjkxIDE4MyAzMzIgMTk5IGIgNDE1IDE5MSAzODUgMTk5IDQwMCAxOTcgYiA0ODMgODQgNDU4IDE3NiA0ODMgMTM0IGIgNDYxIDAgNDgzIDU4IDQ3NiAyOSBiIDMzMiAtMTQyIDQzOSAtNDAgNDExIC03MiBsIDI1NSAtMjE1IGIgMjMxIC0yMjkgMjQwIC0yMjkgMjM5IC0yMjkgYiAyMTYgLTIyMyAyMjQgLTIyOSAyMjAgLTIyNyBiIDIxMCAtMTU4IDIxMCAtMjE3IDIxMCAtMjIzIGIgMjEwIC0xMjAgMjEwIC0xNDggMjEwIC0xMzYgbCAyMTAgLTI5IGwgMjA1IC0zNCBiIDEwMCAtMTQyIDE4MiAtNjUgMTU5IC04OCBsIDIzIC0yMTUgYiAtMSAtMjI5IDkgLTIyOSA2IC0yMjkgYiAtMTkgLTIxNyAtOSAtMjI5IC0xNiAtMjI0IGwgLTIwIC0yMTUgbCAtMjEgNDggbCAtMjEgMzEwIGwgLTgzIDI4NyBiIC0xNTIgMjYyIC0xMzMgMjY2IC0xNDUgMjYyIGIgLTE1NyAyNjMgLTE1MyAyNjIgLTE1NSAyNjIgYiAtMTcxIDI4MyAtMTY2IDI2NiAtMTcxIDI3NCBiIC0xNjEgMzAxIC0xNzEgMjkwIC0xNjcgMjk3IGIgLTkxIDMyOCAtMTYwIDMwMiAtMTI5IDMxNSBsIC0yMSAzNTYgbCAtMjEgNDg3IGwgLTIwIDYxNyBsIC0xOSA2MjEgYiAtOCA2MzEgLTE3IDYyNiAtMTIgNjMwIG0gMjEwIDI4OCBiIDIxMCA0MDEgMjEwIDM1MSAyMTAgNDAxIGIgMTE0IDM2NSAyMDkgNDAxIDE2NyAzODQgbCAyMCAzMjcgbCAyMCAyMzggbCAyMCAxNDggbCAyMSAxNTEgYiAxNDAgMTk5IDU5IDE4MyAxMDIgMTk5IGIgMjA2IDE4MCAxNjQgMTk5IDE4NyAxOTIgbCAyMDkgMTc3IGIgMjA5IDE3NyAyMDkgMTc3IDIwOSAxNzcgYiAyMTAgMjg4IDIxMCAxNzcgMjEwIDE5OSBtIDExMCAxMzEgYiA5NiAxMzMgMTA2IDEzMyAxMDAgMTMzIGIgODkgMTMzIDkzIDEzMyA5MSAxMzMgYiAyNCA4NyA2MyAxMjkgNDAgMTEzIGwgMjAgODAgbCAyMCAtMzcgbCAyMCAtMTU2IGwgMjMgLTE1MiBiIDE0NCA4MSA5NiAtNzIgMTQ0IDIwIGwgMTQ0IDgzIGIgMTEwIDEzMSAxNDQgMTEzIDEzNCAxMjYgbSAzNDEgMTMxIGIgMzI4IDEzMyAzMzcgMTMzIDMzMiAxMzMgYiAzMjIgMTMzIDMyNiAxMzMgMzIzIDEzMyBiIDI1NyA4NyAyOTYgMTI5IDI3MyAxMTMgbCAyNTEgODAgbCAyNTEgLTM3IGwgMjUxIC0xNTYgbCAyNTUgLTE1MiBiIDM3NSA4MSAzMjggLTcyIDM3NSAyMCBsIDM3NSA4MyBiIDM0MSAxMzEgMzc1IDExMyAzNjcgMTI2IFwifSxcInY5MlwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NTk4Ljg5MDYyNSxcImhhXCI6NjExLFwib1wiOlwibSA2MiAxODEgYiA3NyAxODMgNjYgMTgzIDcyIDE4MyBiIDkxIDE4MSA4MyAxODMgODggMTgzIGIgMjAyIDEzMSAxMDAgMTgwIDEwNiAxNzcgbCAyOTkgODcgbCAzOTQgMTMxIGIgNTE3IDE4MyA0OTkgMTgxIDUwMiAxODMgYiA1MTkgMTgzIDUxNyAxODMgNTE4IDE4MyBiIDU5OCAxMDQgNTY3IDE4MyA1OTggMTQ0IGIgNTc3IDQ5IDU5OCA4NCA1OTIgNjUgYiA1MTggMTUgNTY3IDM4IDU2MyAzNyBiIDQ4NCAwIDQ5OSA2IDQ4NCAwIGIgNTE4IC0xNiA0ODQgLTEgNDk5IC04IGIgNTc3IC01MSA1NjMgLTM4IDU2NyAtNDAgYiA1OTggLTEwNSA1OTIgLTY2IDU5OCAtODYgYiA1MTkgLTE4NCA1OTggLTE0NSA1NjcgLTE4NCBiIDUxNyAtMTg0IDUxOCAtMTg0IDUxNyAtMTg0IGIgMzk0IC0xMzMgNTAyIC0xODQgNDk5IC0xODMgbCAyOTkgLTg4IGwgMjAyIC0xMzMgYiA4MSAtMTg0IDk5IC0xODMgOTUgLTE4NCBiIDc3IC0xODQgODAgLTE4NCA3OCAtMTg0IGIgMCAtMTA1IDI5IC0xODQgMCAtMTQ1IGIgMjAgLTUxIDAgLTg2IDUgLTY2IGIgODAgLTE2IDI5IC00MCAzNCAtMzggYiAxMTQgLTEgOTggLTggMTE0IC0xIGIgODAgMTUgMTE0IDAgOTggNiBiIDIwIDQ5IDM0IDM3IDI5IDM4IGIgMCAxMDQgNiA2NSAwIDg0IGIgNjIgMTgxIDAgMTQwIDIzIDE3NCBtIDg4IDEzNCBiIDc0IDEzNiA4NSAxMzQgODAgMTM2IGIgNjggMTM0IDcyIDEzNiA2OSAxMzYgYiA0NiAxMDQgNTQgMTMwIDQ2IDExNyBiIDU1IDgxIDQ2IDk1IDQ5IDg4IGIgMTQ5IDM0IDU5IDc2IDUzIDgwIGIgMjI0IC0xIDE5MCAxNSAyMjQgMCBiIDE0NCAtMzggMjI0IC0xIDE4NyAtMTggYiA1NCAtODQgNTkgLTc5IDU4IC03OSBiIDQ2IC0xMDUgNDkgLTkwIDQ2IC05OCBiIDc2IC0xMzcgNDYgLTEyMiA1OCAtMTM3IGIgNzggLTEzNyA3NyAtMTM3IDc3IC0xMzcgYiAxOTQgLTg2IDg3IC0xMzcgNzYgLTE0MSBiIDI5OCAtMzYgMjUwIC01OCAyOTggLTM2IGIgMjk4IC0zNiAyOTggLTM2IDI5OCAtMzYgYiA0MDIgLTg0IDI5OSAtMzYgMzQ1IC01OCBiIDUxOCAtMTM3IDUyMiAtMTQxIDUxMCAtMTM3IGIgNTIxIC0xMzcgNTE5IC0xMzcgNTE5IC0xMzcgYiA1NTEgLTEwNSA1MzkgLTEzNyA1NTEgLTEyMiBiIDU0MSAtODMgNTUxIC05OCA1NDggLTkwIGIgNDQ3IC0zNiA1MzcgLTc3IDU0NCAtODEgYiAzNzQgLTEgNDA2IC0xNiAzNzQgLTEgYiA0NDcgMzQgMzc0IDAgNDA2IDE1IGIgNTQxIDgxIDU0NCA4MCA1MzcgNzYgYiA1NTEgMTA0IDU0OCA4OCA1NTEgOTcgYiA1MjEgMTM2IDU1MSAxMjAgNTM5IDEzNiBiIDUxOCAxMzYgNTE5IDEzNiA1MTkgMTM2IGIgNTE3IDEzNiA1MTggMTM2IDUxNyAxMzYgbCA1MTcgMTM2IGIgNDAyIDgzIDUxMSAxMzYgNTExIDEzNiBiIDI5OCAzNCAzNDUgNTYgMjk5IDM0IGIgMjk4IDM0IDI5OCAzNCAyOTggMzQgYiAxOTQgODQgMjk4IDM0IDI1MCA1NiBiIDg4IDEzNCAxMzcgMTExIDg5IDEzMyBcIn0sXCJ2OTNcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQzOC4yODEyNSxcImhhXCI6NDQ3LFwib1wiOlwibSAyMTIgMjA1IGIgMjE5IDIwNSAyMTMgMjA1IDIxNiAyMDUgYiAyMzkgMTgzIDIyOCAyMDUgMjMxIDIwNCBiIDQyMSAtMTYzIDI5OCA0MCAzNjMgLTgzIGIgNDM4IC0xOTEgNDM0IC0xODAgNDM4IC0xODYgYiA0MzYgLTE5NyA0MzggLTE5MiA0MzggLTE5NSBiIDQyNCAtMjA2IDQzNCAtMjA0IDQzMSAtMjA2IGIgNDA2IC0yMDEgNDIwIC0yMDYgNDE1IC0yMDUgYiAyMTYgLTE1NiAzNDcgLTE3MiAyODEgLTE1NiBiIDIzIC0yMDUgMTQ4IC0xNTYgODAgLTE3MyBiIDE0IC0yMDYgMjAgLTIwNiAxNyAtMjA2IGIgMCAtMTkxIDYgLTIwNiAwIC0yMDEgYiA2IC0xNzYgMCAtMTg3IDEgLTE4MyBiIDIwMiAxOTIgNjMgLTEwNCAxNDIgNDUgYiAyMTIgMjA1IDIwNSAxOTkgMjA4IDIwMiBtIDI2NCA0OCBsIDI0OSA4MSBsIDI0MyA5NCBsIDI0MiA5MSBiIDg5IC0xMjYgMjA4IDM2IDEzNyAtNjYgYiA4MSAtMTM4IDg1IC0xMzMgODEgLTEzOCBiIDgxIC0xMzggODEgLTEzOCA4MSAtMTM4IGIgODEgLTEzOCA4MSAtMTM4IDgxIC0xMzggYiA5NSAtMTMzIDgxIC0xMzggODcgLTEzNiBiIDI4MCAtOTQgMTU2IC0xMDggMjIxIC05NCBiIDMzNCAtOTggMjk5IC05NCAzMTcgLTk1IGIgMzQzIC05OSAzMzggLTk5IDM0MyAtOTkgYiAzNDMgLTk5IDM0MyAtOTkgMzQzIC05OSBiIDMzOCAtOTQgMzQzIC05OSAzNDEgLTk3IGIgMjY0IDQ4IDMxOCAtNTggMjg3IDEgXCJ9LFwidjk0XCI6e1wieF9taW5cIjotMTQ5LjcxODc1LFwieF9tYXhcIjoxNDguMzU5Mzc1LFwiaGFcIjoxNTEsXCJvXCI6XCJtIC05IDIxNSBiIDAgMjE3IC02IDIxNyAtNCAyMTcgYiAxOSAyMDUgOCAyMTcgMTQgMjEzIGIgMjAgMTQyIDIwIDIwMiAyMCAyMDEgbCAyMCA4NCBsIDIzIDg0IGIgMTQ0IC0yNyA4MSA3NCAxMjkgMzAgYiAxNDggLTY2IDE0NyAtNDAgMTQ4IC01NCBiIDM2IC0yMTMgMTQ4IC0xMzQgMTAzIC0xOTcgYiAwIC0yMTkgMjQgLTIxNyAxMiAtMjE5IGIgLTE0NSAtMTA0IC02OCAtMjE5IC0xMjkgLTE3MyBiIC0xNDkgLTY4IC0xNDggLTkxIC0xNDkgLTc5IGIgLTI0IDg0IC0xNDkgNiAtOTggNzQgbCAtMjEgODQgbCAtMjEgMTQyIGIgLTE5IDIwNSAtMjAgMjAxIC0yMCAyMDIgYiAtOSAyMTUgLTE3IDIwOSAtMTMgMjEzIG0gLTIxIC0xNSBiIC0yMyA0MSAtMjEgMzcgLTIxIDQxIGIgLTIzIDQxIC0yMyA0MSAtMjMgNDEgYiAtNzYgMTEgLTM1IDQwIC02MiAyNiBiIC0xMDggLTY1IC05OCAtMTEgLTEwOCAtMzggYiAtMSAtMTc2IC0xMDggLTEyMiAtNjUgLTE3NiBiIDEwNyAtNjUgNjMgLTE3NiAxMDcgLTEyMiBiIDc0IDExIDEwNyAtMzggOTYgLTExIGIgMjAgNDEgNjEgMjYgMzIgNDEgYiAyMCAtMTUgMjAgNDEgMjAgMTUgYiAxOSAtNzQgMjAgLTcyIDIwIC03MiBiIDAgLTg3IDE0IC04MyA2IC04NyBiIC0xOSAtNzQgLTggLTg3IC0xNiAtODMgYiAtMjEgLTE1IC0yMCAtNzIgLTIwIC03MiBcIn0sXCJ2OTVcIjp7XCJ4X21pblwiOjAsXCJ4X21heFwiOjQwNi45Njg3NSxcImhhXCI6NDE1LFwib1wiOlwibSA1NSAxODEgYiA3MCAxODMgNjEgMTgzIDY2IDE4MyBiIDExMSAxNzAgODUgMTgzIDk5IDE3OSBiIDE2MCAxMzAgMTE1IDE2NyAxMzcgMTQ5IGwgMjAyIDk1IGwgMjQ1IDEzMCBiIDMxOSAxODEgMjk5IDE3NiAzMDIgMTc5IGIgMzM0IDE4MyAzMjUgMTgzIDMzMCAxODMgYiA0MDYgMTA5IDM3NSAxODMgNDA2IDE0OCBiIDQwMSA4MSA0MDYgOTkgNDA1IDkxIGIgMzQ4IDI0IDM5NCA2NSAzOTAgNTkgYiAzMTggLTEgMzMyIDExIDMxOCAwIGIgMzQ4IC0yNiAzMTggLTEgMzMyIC0xMiBiIDQwMSAtODMgMzkwIC02MSAzOTQgLTY2IGIgNDA2IC0xMTEgNDA1IC05MyA0MDYgLTEwMSBiIDMzNCAtMTg0IDQwNiAtMTQ5IDM3NSAtMTg0IGIgMzE5IC0xODMgMzMwIC0xODQgMzI1IC0xODQgYiAyNDUgLTEzMSAzMDIgLTE4MCAyOTkgLTE3NyBsIDIwMiAtOTcgbCAxNjAgLTEzMSBiIDg1IC0xODMgMTA3IC0xNzcgMTAzIC0xODAgYiA3MCAtMTg0IDgwIC0xODQgNzYgLTE4NCBiIDAgLTExMSAzMSAtMTg0IDAgLTE0OSBiIDQgLTgzIDAgLTEwMSAxIC05MyBiIDU4IC0yNiAxMCAtNjYgMTYgLTYxIGIgODggLTEgNzQgLTEyIDg4IC0xIGIgNTggMjQgODggMCA3NCAxMSBiIDEwIDY5IDIzIDU0IDE3IDU5IGIgMCAxMDkgMiA4MSAwIDk1IGIgNTUgMTgxIDAgMTQyIDIxIDE3MyBtIDgzIDEzMyBiIDcyIDEzNiA3OCAxMzYgNzYgMTM2IGIgNTcgMTMxIDY2IDEzNiA2MSAxMzQgYiA0NiAxMDkgNDkgMTI2IDQ2IDExNyBiIDUwIDkzIDQ2IDEwNCA0NyA5OCBiIDEwNyA0NSA1MSA5MSA3NyA3MCBiIDE2MCAwIDEzNyAyMCAxNjAgMCBiIDEwNyAtNDcgMTYwIC0xIDEzNyAtMjIgYiA1MCAtOTQgNzcgLTcyIDUxIC05MyBiIDQ2IC0xMTEgNDcgLTk5IDQ2IC0xMDUgYiA1OSAtMTM0IDQ2IC0xMjAgNTAgLTEzMCBiIDcyIC0xMzcgNjIgLTEzNiA2OCAtMTM3IGIgODMgLTEzNiA3NiAtMTM3IDgwIC0xMzYgYiAxNDQgLTg0IDg0IC0xMzQgMTA3IC0xMTYgYiAyMDIgLTM2IDE3NiAtNTggMjAyIC0zNiBiIDI2MSAtODQgMjAyIC0zNiAyMzAgLTU4IGIgMzIzIC0xMzYgMjk5IC0xMTYgMzIxIC0xMzQgYiAzMzQgLTEzNyAzMjYgLTEzNiAzMzAgLTEzNyBiIDM0NSAtMTM0IDMzOCAtMTM3IDM0MyAtMTM2IGIgMzYwIC0xMTEgMzU1IC0xMzAgMzYwIC0xMjAgYiAzNTUgLTk0IDM2MCAtMTA1IDM1OSAtOTkgYiAyOTkgLTQ3IDM1MyAtOTMgMzI5IC03MiBiIDI0NSAwIDI2OSAtMjIgMjQ1IC0xIGIgMjk5IDQ1IDI0NSAwIDI2OSAyMCBiIDM1NSA5MyAzMjkgNzAgMzUzIDkxIGIgMzYwIDEwOSAzNTkgOTggMzYwIDEwNCBiIDM0NSAxMzMgMzYwIDExOSAzNTUgMTI5IGIgMzM0IDEzNiAzNDMgMTM0IDMzOCAxMzYgYiAzMjMgMTM0IDMzMCAxMzYgMzI2IDEzNCBiIDI2MSA4MyAzMjEgMTMzIDI5OSAxMTUgYiAyMDIgMzQgMjMwIDU2IDIwMiAzNCBiIDE0NCA4MyAyMDIgMzQgMTc2IDU2IGIgODMgMTMzIDEwNiAxMTUgODQgMTMzIFwifSxcInY5N1wiOntcInhfbWluXCI6LTIyOC42NzE4NzUsXCJ4X21heFwiOjIyNy4zMTI1LFwiaGFcIjoyMzIsXCJvXCI6XCJtIC0yMTcgNDg3IGwgLTIxMyA0ODggbCAwIDQ4OCBsIDIxMiA0ODggbCAyMTYgNDg3IGIgMjI1IDQ3NiAyMjAgNDg0IDIyNCA0ODAgbCAyMjcgNDczIGwgMjI3IDI0NCBsIDIyNyAxNSBsIDIyNSAxMiBiIDIwNiAwIDIyMyA0IDIxNSAwIGIgMTk3IDEgMjA0IDAgMjAwIDAgYiAxODcgMTIgMTkzIDQgMTg5IDYgbCAxODYgMTUgbCAxODYgMTM4IGwgMTg2IDI2MiBsIC0xIDI2MiBsIC0xODcgMjYyIGwgLTE4NyAxMzggbCAtMTg3IDE1IGwgLTE4OSAxMiBiIC0yMDggMCAtMTkzIDQgLTIwMCAwIGIgLTIyNyAxMiAtMjE2IDAgLTIyMyA0IGwgLTIyOCAxNSBsIC0yMjggMjQ0IGwgLTIyOCA0NzMgbCAtMjI3IDQ3NiBiIC0yMTcgNDg3IC0yMjUgNDgwIC0yMjEgNDg0IFwifSxcInY5YVwiOntcInhfbWluXCI6LTIxLjc4MTI1LFwieF9tYXhcIjozNjcuNSxcImhhXCI6Mzc1LFwib1wiOlwibSAyMzAgMTAzMSBiIDIzOCAxMDMyIDIzMiAxMDMyIDIzNSAxMDMyIGIgMjU5IDEwMTQgMjQ1IDEwMzIgMjUxIDEwMjcgYiAzNjcgNjYyIDMzMCA5MDYgMzY3IDc4MiBiIDM2NCA2MDIgMzY3IDY0MSAzNjcgNjIxIGIgMjMyIDMxNyAzNTIgNDg4IDMwNCAzODQgYiA1NyAxMjAgMTU1IDI0NSAxMDMgMTg3IGIgLTEgMTggMzEgODQgNiA0MCBiIC0xOSA0IC00IDExIC0xMiA0IGwgLTIxIDQgbCAtMjEgMTU5IGwgLTIxIDMxNSBsIC0xNiAzMTUgYiA5NiAzMzUgMTAgMzE1IDYyIDMyNCBiIDMxNSA2OTUgMjI3IDM4MCAzMTUgNTI3IGIgMzEzIDczOCAzMTUgNzA5IDMxNCA3MjQgYiAyMjQgOTkxIDMwNCA4MjUgMjczIDkxNiBiIDIxNiAxMDEzIDIxOSA5OTkgMjE2IDEwMDcgYiAyMzAgMTAzMSAyMTYgMTAyMSAyMjAgMTAyOCBcIn0sXCJ2OWJcIjp7XCJ4X21pblwiOi0yNC41LFwieF9tYXhcIjozMTMuMDYyNSxcImhhXCI6MzE5LFwib1wiOlwibSAtMjQgLTEzMyBsIC0yNCAtNSBsIC0yMCAtNSBiIC0xIC0xOSAtMTIgLTUgLTQgLTExIGIgMTQyIC0yMTMgMTMgLTYxIDc0IC0xNDQgYiAyNTggLTM3NiAxOTYgLTI2OSAyMzAgLTMxNSBiIDMxMyAtNjA1IDI5NSAtNDQ5IDMxMyAtNTI4IGIgMjkyIC03NDIgMzEzIC02NTIgMzA2IC02OTkgYiAyODggLTc1MiAyODkgLTc0OCAyODggLTc1MiBiIDI4OCAtNzUyIDI4OCAtNzUyIDI4OCAtNzUyIGIgMjkyIC03NjQgMjg5IC03NTMgMjkxIC03NTcgYiAzMTMgLTkwNyAzMDYgLTgxMSAzMTMgLTg2MCBiIDI5MiAtMTA0NSAzMTMgLTk1NCAzMDYgLTEwMDIgYiAyODggLTEwNTQgMjg5IC0xMDUwIDI4OCAtMTA1NCBiIDI4OCAtMTA1NCAyODggLTEwNTQgMjg4IC0xMDU0IGIgMjkyIC0xMDY3IDI4OSAtMTA1NCAyOTEgLTEwNjAgYiAzMTMgLTEyMTAgMzA2IC0xMTEzIDMxMyAtMTE2MSBiIDI5MiAtMTM0NiAzMTMgLTEyNTcgMzA2IC0xMzA0IGIgMjg4IC0xMzU3IDI4OSAtMTM1MyAyODggLTEzNTcgYiAyODggLTEzNTcgMjg4IC0xMzU3IDI4OCAtMTM1NyBiIDI5MiAtMTM2OCAyODkgLTEzNTcgMjkxIC0xMzYzIGIgMzEzIC0xNTEyIDMwNiAtMTQxNSAzMTMgLTE0NjQgYiAyOTIgLTE2NDggMzEzIC0xNTYwIDMwNiAtMTYwNSBiIDI4OCAtMTY2MCAyODkgLTE2NTQgMjg4IC0xNjYwIGIgMjg4IC0xNjYwIDI4OCAtMTY2MCAyODggLTE2NjAgYiAyOTIgLTE2NzEgMjg5IC0xNjYwIDI5MSAtMTY2NSBiIDMxMyAtMTgxNCAzMDYgLTE3MTkgMzEzIC0xNzY2IGIgMjUwIC0yMDQwIDMxMyAtMTg5NyAyOTEgLTE5NzcgYiAyMzIgLTIwNjIgMjM4IC0yMDU3IDIzNiAtMjA1OSBiIDIyMSAtMjA2NSAyMzAgLTIwNjMgMjI1IC0yMDY1IGIgMjAwIC0yMDQ1IDIxMCAtMjA2NSAyMDEgLTIwNTcgYiAyMDAgLTIwNDMgMjAwIC0yMDQ0IDIwMCAtMjA0NCBiIDIwOCAtMjAyNiAyMDAgLTIwMzcgMjAyIC0yMDM0IGIgMjY5IC0xODI2IDI0OSAtMTk2NiAyNjkgLTE4OTcgYiAxNTMgLTE1NDQgMjY5IC0xNzI2IDIzMCAtMTYyNSBiIC05IC0xNDcyIDExNSAtMTUwNiA1OCAtMTQ4MSBiIC0yMSAtMTQ3MSAtMTQgLTE0NzEgLTE5IC0xNDcxIGwgLTI0IC0xNDcxIGwgLTI0IC0xMzQzIGwgLTI0IC0xMjE1IGwgLTIwIC0xMjE1IGIgLTEgLTEyMjkgLTEyIC0xMjE1IC00IC0xMjIxIGIgMTQyIC0xNDI0IDEzIC0xMjcwIDc0IC0xMzUzIGIgMjU3IC0xNTgyIDE5NiAtMTQ3OCAyMjggLTE1MjQgYiAyNjQgLTE1OTQgMjYxIC0xNTg5IDI2NCAtMTU5NCBsIDI2NCAtMTU5NCBiIDI2NSAtMTU4MiAyNjQgLTE1OTQgMjY0IC0xNTg5IGIgMjcwIC0xNTI1IDI2OCAtMTU2MiAyNzAgLTE1NDQgYiAxNTMgLTEyNDMgMjcwIC0xNDI0IDIyOCAtMTMyMSBiIC05IC0xMTcwIDExNSAtMTIwMyA1OCAtMTE3OCBiIC0yMSAtMTE2OCAtMTQgLTExNzAgLTE5IC0xMTY4IGwgLTI0IC0xMTY4IGwgLTI0IC0xMDQxIGwgLTI0IC05MTMgbCAtMjAgLTkxMyBiIC0xIC05MjcgLTEyIC05MTMgLTQgLTkxOCBiIDE0MiAtMTEyMSAxMyAtOTY3IDc0IC0xMDUwIGIgMjU3IC0xMjgxIDE5NiAtMTE3NSAyMjggLTEyMjEgYiAyNjQgLTEyOTIgMjYxIC0xMjg2IDI2NCAtMTI5MiBsIDI2NCAtMTI5MiBiIDI2NSAtMTI3OSAyNjQgLTEyOTIgMjY0IC0xMjg2IGIgMjcwIC0xMjIyIDI2OCAtMTI2MSAyNzAgLTEyNDIgYiAxNTMgLTk0MSAyNzAgLTExMjEgMjI4IC0xMDE4IGIgLTkgLTg2NyAxMTUgLTkwMCA1OCAtODc1IGIgLTIxIC04NjYgLTE0IC04NjcgLTE5IC04NjYgbCAtMjQgLTg2NiBsIC0yNCAtNzM4IGwgLTI0IC02MTAgbCAtMjAgLTYxMCBiIC0xIC02MjQgLTEyIC02MTAgLTQgLTYxNiBiIDE0MiAtODE4IDEzIC02NjQgNzQgLTc0OSBiIDI1NyAtOTc4IDE5NiAtODczIDIyOCAtOTE4IGIgMjY0IC05ODkgMjYxIC05ODQgMjY0IC05ODkgbCAyNjQgLTk4OSBiIDI2NSAtOTc3IDI2NCAtOTg5IDI2NCAtOTg0IGIgMjcwIC05MjAgMjY4IC05NTkgMjcwIC05MzkgYiAxNTMgLTYzOCAyNzAgLTgxOCAyMjggLTcxNiBiIC05IC01NjQgMTE1IC01OTggNTggLTU3MyBiIC0yMSAtNTYzIC0xNCAtNTY0IC0xOSAtNTYzIGwgLTI0IC01NjMgbCAtMjQgLTQzNSBsIC0yNCAtMzA4IGwgLTIwIC0zMDggYiAtMSAtMzIyIC0xMiAtMzA4IC00IC0zMTMgYiAxNDIgLTUxNiAxMyAtMzYzIDc0IC00NDYgYiAyNTcgLTY3NSAxOTYgLTU3MSAyMjggLTYxNiBiIDI2NCAtNjg3IDI2MSAtNjgxIDI2NCAtNjg3IGwgMjY0IC02ODcgYiAyNjUgLTY3NCAyNjQgLTY4NyAyNjQgLTY4MSBiIDI3MCAtNjE3IDI2OCAtNjU2IDI3MCAtNjM3IGIgMTUzIC0zMzUgMjcwIC01MTYgMjI4IC00MTMgYiAtOSAtMjYyIDExNSAtMjk1IDU4IC0yNzAgYiAtMjEgLTI2MCAtMTQgLTI2MiAtMTkgLTI2MCBsIC0yNCAtMjYwIGwgLTI0IC0xMzMgXCJ9LFwidjljXCI6e1wieF9taW5cIjotMTY2LjA2MjUsXCJ4X21heFwiOi0yNS44NTkzNzUsXCJoYVwiOjAsXCJvXCI6XCJtIC00OSAzNjkgYiAtNDIgMzcwIC00NiAzNjkgLTQ0IDM3MCBiIC0yNyAzNjAgLTM2IDM3MCAtMjkgMzY2IGIgLTI1IDM1NSAtMjcgMzU5IC0yNSAzNTggYiAtMzIgMzM1IC0yNSAzNTEgLTI4IDM0NyBiIC05MiA1MiAtNjYgMjQ4IC04NyAxNTkgYiAtOTMgLTEgLTkzIDQzIC05MyAyMCBiIC05MiAtNTQgLTkzIC0yMyAtOTMgLTQ1IGIgLTMyIC0zMzcgLTg1IC0xNjIgLTY2IC0yNTEgYiAtMjUgLTM1NSAtMjcgLTM0OSAtMjUgLTM1MiBiIC00MiAtMzcxIC0yNSAtMzY1IC0zMiAtMzcxIGIgLTYxIC0zNTMgLTUwIC0zNzEgLTUxIC0zNjkgYiAtMTYzIC02MyAtMTE5IC0yNjIgLTE1MyAtMTY1IGIgLTE2NiAtMSAtMTY2IC0zNyAtMTY2IC0zMSBiIC0xNjMgNjIgLTE2NiAzMCAtMTY2IDM2IGIgLTYxIDM1MiAtMTUzIDE2MyAtMTE5IDI2MCBiIC00OSAzNjkgLTU0IDM2NSAtNTEgMzY2IFwifSxcInY5ZVwiOntcInhfbWluXCI6MCxcInhfbWF4XCI6NjA3LjA2MjUsXCJoYVwiOjYxOSxcIm9cIjpcIm0gMjQzIDYzMSBiIDI1MCA2MzIgMjQ2IDYzMiAyNDkgNjMyIGIgMjcwIDYyMCAyNTkgNjMyIDI2OCA2MjggbCAyNzIgNjE2IGwgMjcyIDIwMSBsIDI3MiAtMjEyIGwgMjcwIC0yMTYgYiAyNTEgLTIyOSAyNjggLTIyNCAyNTkgLTIyOSBiIDIyNyAtMjE1IDI0MyAtMjI5IDI0MCAtMjI5IGwgMTUxIC0xNDIgYiAzMiAtMTYgODEgLTgwIDUzIC00OSBiIDAgODQgOSAxOCAwIDUyIGIgMTExIDE5OSAwIDE0OSA0MiAxOTkgYiAxMzcgMTk3IDExOSAxOTkgMTI3IDE5OCBiIDIyOCAxNTEgMTY4IDE5MSAxOTcgMTc3IGwgMjMxIDE0OCBsIDIzMSAzODMgYiAyMzIgNjIwIDIzMSA2MTYgMjMxIDYxNiBiIDI0MyA2MzEgMjM0IDYyNCAyMzggNjMwIG0gMTY4IDEzMSBiIDE1MiAxMzMgMTYzIDEzMyAxNTcgMTMzIGIgMTA3IDEwMiAxMzAgMTMzIDExMSAxMjAgYiAxMDYgODYgMTA3IDk3IDEwNiA5MSBiIDExMSA0MSAxMDYgNzMgMTA4IDU2IGIgMjI3IC0xNTIgMTI1IC0xMyAxNzEgLTkwIGwgMjMxIC0xNTYgbCAyMzEgLTM3IGwgMjMxIDgwIGwgMjI1IDg3IGIgMTY4IDEzMSAyMTAgMTExIDE5MCAxMjYgbSAzNDcgNjMxIGIgMzUzIDYzMiAzNDggNjMyIDM1MSA2MzIgYiAzNzQgNjIwIDM2MyA2MzIgMzcxIDYyOCBiIDM3NSAzODMgMzc1IDYxNiAzNzUgNjE2IGwgMzc1IDE0OCBsIDM3NyAxNTEgYiA0OTIgMTk5IDQxNSAxODMgNDU0IDE5OSBiIDUzNyAxOTEgNTA3IDE5OSA1MjIgMTk3IGIgNjA3IDg0IDU4MiAxNzYgNjA3IDEzNCBiIDU4MyAwIDYwNyA1OCA1OTggMjkgYiA0NTUgLTE0MiA1NjIgLTQwIDUzMyAtNzIgbCAzNzggLTIxNSBiIDM1NSAtMjI5IDM2NCAtMjI5IDM2MiAtMjI5IGIgMzM0IC0yMTYgMzQ1IC0yMjkgMzM3IC0yMjQgbCAzMzMgLTIxMiBsIDMzMyAyMDEgbCAzMzMgNjE2IGwgMzM0IDYyMCBiIDM0NyA2MzEgMzM3IDYyNCAzNDEgNjMwIG0gNDY1IDEzMSBiIDQ1MSAxMzMgNDYxIDEzMyA0NTUgMTMzIGIgNDQ1IDEzMyA0NDkgMTMzIDQ0NiAxMzMgYiAzNzkgODcgNDE5IDEyOSAzOTYgMTEzIGwgMzc1IDgwIGwgMzc1IC0zNyBsIDM3NSAtMTU2IGwgMzc4IC0xNTIgYiA0OTkgODEgNDUxIC03MiA0OTkgMjAgbCA0OTkgODMgYiA0NjUgMTMxIDQ5OSAxMTMgNDkwIDEyNiBcIn0sXCJ2YTNcIjp7XCJ4X21pblwiOjU4LjUzMTI1LFwieF9tYXhcIjoyMjguNjcxODc1LFwiaGFcIjoyOTQsXCJvXCI6XCJtIDEzOCAzNzEgYiAxNDIgMzczIDE0MCAzNzEgMTQxIDM3MyBiIDE3OCAzNDIgMTQ5IDM3MyAxNTYgMzY2IGIgMjI4IDI1MSAyMTcgMjk3IDIyOCAyNzggYiAyMjggMjQ0IDIyOCAyNDggMjI4IDI0NyBiIDE3NiAxNDcgMjI3IDIxMiAyMTIgMTg0IGIgMTIzIDczIDE1MiAxMjIgMTMyIDkzIGIgMTIxIDYyIDEyMiA3MCAxMjEgNjYgYiAxNDUgMTMgMTIxIDQ4IDEyOSAzMSBiIDE1MyAtMiAxNTEgNiAxNTMgMSBiIDE0OSAtOSAxNTMgLTUgMTUyIC02IGIgMTQ0IC0xMSAxNDggLTExIDE0NSAtMTEgYiAxMjkgLTEgMTQwIC0xMSAxMzYgLTggYiA2MSA4NyA4OSAzNyA2OCA2OCBiIDU4IDExMyA1OSA5NSA1OCAxMDUgYiAxMTAgMjE1IDU4IDE0NCA3NCAxNzcgYiAxNjMgMjg3IDEzNCAyNDAgMTU1IDI2OSBiIDE2NiAyOTkgMTY2IDI5MSAxNjYgMjk1IGIgMTQxIDM0OCAxNjYgMzEzIDE1NyAzMzAgYiAxMzMgMzYwIDEzNCAzNTYgMTMzIDM1OCBiIDEzMyAzNjMgMTMzIDM2MiAxMzMgMzYyIGIgMTM4IDM3MSAxMzMgMzY3IDEzNiAzNzAgXCJ9LFwidmE1XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjozNDkuODEyNSxcImhhXCI6MzU3LFwib1wiOlwibSA4OCAzMDIgYiAxMDMgMzAzIDkzIDMwMiA5OCAzMDMgYiAyMDIgMjI0IDE0OSAzMDMgMTkxIDI3MCBiIDIwNSAxOTkgMjA0IDIxNiAyMDUgMjA4IGIgMTc4IDEyOSAyMDUgMTczIDE5NiAxNDcgbCAxNzUgMTI2IGwgMTgyIDEyNyBiIDMwNyAyNDkgMjM2IDE0MiAyODQgMTkwIGIgMzEzIDI1OSAzMDggMjU0IDMxMSAyNTggYiAzMjkgMjY3IDMxNyAyNjUgMzIzIDI2NyBiIDM0OSAyNDcgMzQwIDI2NyAzNDkgMjU5IGIgMjAxIC0yNjMgMzQ5IDI0MiAyMDQgLTI1OCBiIDE4MiAtMjczIDE5NyAtMjcwIDE5MCAtMjczIGIgMTYzIC0yNjAgMTc0IC0yNzMgMTY2IC0yNjkgYiAxNjEgLTI1NiAxNjEgLTI1OSAxNjEgLTI1OCBiIDIxNyAtNTkgMTYxIC0yNDggMTcwIC0yMjAgYiAyNzIgMTI5IDI0NyA0MyAyNzIgMTI3IGIgMjcyIDEyOSAyNzIgMTI5IDI3MiAxMjkgYiAyNjQgMTIyIDI3MiAxMjkgMjY4IDEyNiBiIDE0MCA4MCAyMjcgOTQgMTgzIDgwIGIgMzYgMTE1IDEwMiA4MCA2NSA5MSBiIDAgMTk0IDEwIDEzNiAwIDE2NSBiIDg4IDMwMiAwIDI0NCAzMiAyOTIgXCJ9LFwidmE5XCI6e1wieF9taW5cIjotMjQuNSxcInhfbWF4XCI6MzE0LjQyMTg3NSxcImhhXCI6MzIxLFwib1wiOlwibSAtMjQgLTE0NSBsIC0yNCAtNSBsIC0yMCAtNSBiIDAgLTIzIC05IC01IC0yIC0xMiBiIDI3IC04NyA0IC0zOCAxNCAtNjYgYiAxMzggLTIyMCA1MyAtMTM2IDg4IC0xNzcgYiAyMzUgLTMyOCAxNzkgLTI1NSAyMDggLTI4OCBiIDMxNCAtNTkyIDI4NyAtNDA5IDMxNCAtNTAxIGIgMjkyIC03MzIgMzE0IC02MzkgMzA3IC02ODcgbCAyODkgLTc0MiBsIDI5NCAtNzU2IGIgMzE0IC04OTYgMzA3IC04MDIgMzE0IC04NDkgYiAyOTIgLTEwMzUgMzE0IC05NDMgMzA3IC05OTEgbCAyODkgLTEwNDUgbCAyOTQgLTEwNTcgYiAzMTQgLTExOTcgMzA3IC0xMTA0IDMxNCAtMTE1MiBiIDI5MiAtMTMzOCAzMTQgLTEyNDYgMzA3IC0xMjkyIGwgMjg5IC0xMzQ3IGwgMjk0IC0xMzYwIGIgMzE0IC0xNTAwIDMwNyAtMTQwNyAzMTQgLTE0NTQgYiAyNzMgLTE2ODkgMzE0IC0xNTY1IDMwMCAtMTYyOCBiIDI1MCAtMTcxMiAyNjUgLTE3MTAgMjYxIC0xNzEyIGIgMjI4IC0xNjkxIDIzNiAtMTcxMiAyMjggLTE3MDQgbCAyMjggLTE2ODUgbCAyMzQgLTE2NzUgYiAyNzAgLTE1MDcgMjU4IC0xNjIxIDI3MCAtMTU2NCBiIDk4IC0xMTkzIDI3MCAtMTM4MSAyMDkgLTEyNjEgYiA0MCAtMTE3NCA3NiAtMTE3OSA1OCAtMTE3NCBiIC0xMCAtMTE4OSAyNCAtMTE3NCA4IC0xMTc4IGIgLTIwIC0xMTkyIC0xNCAtMTE5MiAtMTYgLTExOTIgbCAtMjQgLTExOTIgbCAtMjQgLTEwNTIgbCAtMjQgLTkxMyBsIC0yMCAtOTEzIGIgMCAtOTMxIC05IC05MTMgLTIgLTkyMCBiIDI3IC05OTUgNCAtOTQ2IDE0IC05NzQgYiAxMzggLTExMjggNTMgLTEwNDMgODggLTEwODUgYiAyNTcgLTEyNzUgMTkwIC0xMTcyIDIyOCAtMTIyMCBiIDI2MiAtMTI4MyAyNTkgLTEyNzkgMjYyIC0xMjgzIGwgMjYyIC0xMjgzIGIgMjY5IC0xMjQ5IDI2NCAtMTI4MiAyNjggLTEyNjAgYiAyNzAgLTEyMDYgMjcwIC0xMjMzIDI3MCAtMTIyMCBiIDk4IC04OTEgMjcwIC0xMDc1IDIwNiAtOTU3IGIgNDAgLTg3MSA3NiAtODc3IDU4IC04NzEgYiAtMTAgLTg4NiAyNCAtODcxIDggLTg3NSBiIC0yMCAtODg5IC0xNCAtODg5IC0xNiAtODg5IGwgLTI0IC04ODkgbCAtMjQgLTc0OSBsIC0yNCAtNjEwIGwgLTIwIC02MTAgYiAwIC02MjggLTkgLTYxMCAtMiAtNjE3IGIgMjcgLTY5MiA0IC02NDQgMTQgLTY3MSBiIDEzOCAtODI1IDUzIC03NDEgODggLTc4MiBiIDI1NyAtOTczIDE5MCAtODcwIDIyOCAtOTE3IGIgMjYyIC05ODEgMjU5IC05NzcgMjYyIC05ODEgbCAyNjIgLTk4MSBiIDI2OSAtOTQ2IDI2NCAtOTc5IDI2OCAtOTU3IGIgMjcwIC05MDMgMjcwIC05MzEgMjcwIC05MTcgYiA5OCAtNTg4IDI3MCAtNzc0IDIwNiAtNjU1IGIgNDAgLTU2OSA3NiAtNTc0IDU4IC01NjkgYiAtMTAgLTU4NCAyNCAtNTY5IDggLTU3NCBiIC0yMCAtNTg3IC0xNCAtNTg3IC0xNiAtNTg3IGwgLTI0IC01ODcgbCAtMjQgLTQ0OCBsIC0yNCAtMzA4IGwgLTIwIC0zMDggYiAwIC0zMjYgLTkgLTMwOCAtMiAtMzE1IGIgMjcgLTM5MCA0IC0zNDEgMTQgLTM2OSBiIDEzOCAtNTIzIDUzIC00MzggODggLTQ4MCBiIDI1NyAtNjcwIDE5MCAtNTY3IDIyOCAtNjE0IGIgMjYyIC02NzggMjU5IC02NzQgMjYyIC02NzggYiAyNjIgLTY3OCAyNjIgLTY3OCAyNjIgLTY3OCBiIDI2OSAtNjQ0IDI2NCAtNjc3IDI2OCAtNjU2IGIgMjcwIC02MDEgMjcwIC02MjggMjcwIC02MTQgYiA5OCAtMjg1IDI3MCAtNDcxIDIwNiAtMzUyIGIgNDAgLTI2NiA3NiAtMjczIDU4IC0yNjYgYiAtMTAgLTI4MSAyNCAtMjY2IDggLTI3MiBiIC0yMCAtMjg0IC0xNCAtMjg0IC0xNiAtMjg0IGwgLTI0IC0yODQgbCAtMjQgLTE0NSBcIn0sXCJ2YWFcIjp7XCJ4X21pblwiOi0xLjM1OTM3NSxcInhfbWF4XCI6NzUyLjcwMzEyNSxcImhhXCI6NzY4LFwib1wiOlwibSA0OTAgOTg1IGIgNTA0IDk4NiA0OTUgOTg2IDUwMCA5ODYgYiA2MDQgOTA3IDU1MSA5ODYgNTkzIDk1NCBiIDYwNyA4ODQgNjA3IDkwMCA2MDcgODkyIGIgNTgxIDgxMyA2MDcgODU3IDU5NyA4MzEgbCA1NzggODEwIGwgNTgzIDgxMSBiIDcxMCA5MzIgNjM4IDgyNyA2ODcgODczIGIgNzE0IDk0MyA3MTEgOTM2IDcxMyA5NDIgYiA3MzAgOTUyIDcyMCA5NDkgNzI1IDk1MiBiIDc1MiA5MzEgNzQxIDk1MiA3NTIgOTQzIGIgMjAwIC05NDYgNzUyIDkyNyAyMDQgLTk0MSBiIDE4MiAtOTU3IDE5NyAtOTUzIDE5MCAtOTU3IGIgMTYzIC05NDUgMTc0IC05NTcgMTY2IC05NTMgYiAxNjEgLTkzOSAxNjEgLTk0MiAxNjEgLTk0MiBiIDIxNyAtNzQzIDE2MSAtOTMxIDE3MCAtOTA0IGIgMjcyIC01NTUgMjQ3IC02MzkgMjcyIC01NTUgYiAyNzIgLTU1NSAyNzIgLTU1NSAyNzIgLTU1NSBiIDI2NCAtNTYwIDI3MiAtNTU1IDI2OCAtNTU3IGIgMTQwIC02MDMgMjI3IC01ODkgMTgyIC02MDMgYiAzNiAtNTY3IDEwMiAtNjAzIDY1IC01OTIgYiAtMSAtNDg3IDEyIC01NDggLTEgLTUxNyBiIDE3IC00MjcgLTEgLTQ2NiA1IC00NDUgYiAxMDMgLTM4MCAzOCAtMzk1IDcwIC0zODAgYiAxOTEgLTQzMyAxMzcgLTM4MCAxNzIgLTM5OCBiIDIwNSAtNDg0IDIwMSAtNDQ4IDIwNSAtNDY2IGIgMTc4IC01NTMgMjA1IC01MDkgMTk2IC01MzUgbCAxNzUgLTU1NyBsIDE4MiAtNTU1IGIgMzA3IC00MzUgMjM2IC01MzkgMjg0IC00OTQgYiAzNzIgLTIxMyAzMDggLTQzMCAzNzIgLTIxNSBiIDM3MiAtMjEzIDM3MiAtMjEzIDM3MiAtMjEzIGIgMzY0IC0yMTkgMzcyIC0yMTMgMzY4IC0yMTYgYiAyNDAgLTI2MiAzMjggLTI0NyAyODMgLTI2MiBiIDEzNyAtMjI2IDIwMiAtMjYyIDE2NiAtMjQ5IGIgOTkgLTE0NSAxMTIgLTIwNiA5OSAtMTc2IGIgMTE4IC04NCA5OSAtMTI0IDEwNiAtMTA0IGIgMjA0IC0zOCAxMzggLTU0IDE3MSAtMzggYiAyOTIgLTkxIDIzOCAtMzggMjczIC01NiBiIDMwNiAtMTQxIDMwMiAtMTA2IDMwNiAtMTI0IGIgMjc5IC0yMTIgMzA2IC0xNjcgMjk2IC0xOTQgbCAyNzYgLTIxNSBsIDI4MSAtMjEzIGIgNDA4IC05MyAzMzYgLTE5OCAzODUgLTE1MSBiIDQ3MyAxMjkgNDA5IC04OCA0NzMgMTI3IGIgNDczIDEyOSA0NzMgMTI5IDQ3MyAxMjkgYiA0NjUgMTIyIDQ3MyAxMjkgNDY5IDEyNiBiIDM0MSA4MCA0MjggOTQgMzgzIDgwIGIgMjM2IDExNSAzMDMgODAgMjY2IDkxIGIgMjAwIDE5NSAyMTMgMTM2IDIwMCAxNjUgYiAyMTcgMjU2IDIwMCAyMTcgMjA2IDIzOCBiIDMwNCAzMDMgMjM5IDI4NyAyNzIgMzAzIGIgMzkzIDI0OSAzMzggMzAzIDM3NCAyODUgYiA0MDYgMTk5IDQwMiAyMzQgNDA2IDIxNyBiIDM3OSAxMjkgNDA2IDE3MyAzOTcgMTQ4IGwgMzc3IDEyNiBsIDM4MiAxMjcgYiA1MDkgMjQ4IDQzNiAxNDIgNDg1IDE5MCBiIDU3NCA0NzAgNTEwIDI1NCA1NzQgNDY5IGIgNTc0IDQ3MCA1NzQgNDcwIDU3NCA0NzAgYiA1NjYgNDY0IDU3NCA0NzAgNTcwIDQ2NyBiIDQ0MiA0MjEgNTI5IDQzNSA0ODQgNDIxIGIgMzM3IDQ1OCA0MDQgNDIxIDM2NyA0MzMgYiAzMDAgNTM4IDMxNCA0NzcgMzAwIDUwOCBiIDMxOCA1OTggMzAwIDU1OSAzMDYgNTgwIGIgNDA0IDY0NSAzNDAgNjMwIDM3MiA2NDUgYiA0OTQgNTkyIDQzOSA2NDUgNDc1IDYyNyBiIDUwNyA1NDEgNTAyIDU3NyA1MDcgNTU5IGIgNDgwIDQ3MSA1MDcgNTE2IDQ5OCA0ODkgbCA0NzcgNDY3IGwgNDgzIDQ3MCBiIDYwOCA1ODkgNTM3IDQ4NSA1ODYgNTMxIGIgNjc1IDgxMSA2MTEgNTk1IDY3NSA4MTAgYiA2NzUgODExIDY3NSA4MTEgNjc1IDgxMSBiIDY2NiA4MDYgNjc1IDgxMSA2NzEgODA5IGIgNTQzIDc2MyA2MjggNzc3IDU4NSA3NjMgYiA0MzggNzk5IDUwNCA3NjMgNDY4IDc3NSBiIDQwMSA4NzggNDEyIDgyMCA0MDEgODQ5IGIgNDkwIDk4NSA0MDEgOTI4IDQzNCA5NzcgXCJ9LFwidmFiXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjoyNzIuMjE4NzUsXCJoYVwiOjI3OCxcIm9cIjpcIm0gMjQzIDYzMSBiIDI1MCA2MzIgMjQ2IDYzMiAyNDkgNjMyIGIgMjcwIDYyMCAyNTkgNjMyIDI2OCA2MjggbCAyNzIgNjE2IGwgMjcyIDIwMSBsIDI3MiAtMjEyIGwgMjcwIC0yMTYgYiAyNTEgLTIyOSAyNjggLTIyNCAyNTkgLTIyOSBiIDIyNyAtMjE1IDI0MyAtMjI5IDI0MCAtMjI5IGwgMTUxIC0xNDIgYiAzMiAtMTYgODEgLTgwIDUzIC00OSBiIDAgODQgOSAxOCAwIDUyIGIgMTExIDE5OSAwIDE0OSA0MiAxOTkgYiAxMzcgMTk3IDExOSAxOTkgMTI3IDE5OCBiIDIyOCAxNTEgMTY4IDE5MSAxOTcgMTc3IGwgMjMxIDE0OCBsIDIzMSAzODMgYiAyMzIgNjIwIDIzMSA2MTYgMjMxIDYxNiBiIDI0MyA2MzEgMjM0IDYyNCAyMzggNjMwIG0gMTY4IDEzMSBiIDE1MiAxMzMgMTYzIDEzMyAxNTcgMTMzIGIgMTA3IDEwMiAxMzAgMTMzIDExMSAxMjAgYiAxMDYgODYgMTA3IDk3IDEwNiA5MSBiIDExMSA0MSAxMDYgNzMgMTA4IDU2IGIgMjI3IC0xNTIgMTI1IC0xMyAxNzEgLTkwIGwgMjMxIC0xNTYgbCAyMzEgLTM3IGwgMjMxIDgwIGwgMjI1IDg3IGIgMTY4IDEzMSAyMTAgMTExIDE5MCAxMjYgXCJ9LFwidmFkXCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo4NzMuODI4MTI1LFwiaGFcIjo4OTIsXCJvXCI6XCJtIDAgMCBsIDAgNzAzIGwgODEgNzAzIGwgMTY0IDcwMyBsIDE2NCAwIGwgMTY0IC03MDUgbCA4MSAtNzA1IGwgMCAtNzA1IGwgMCAwIG0gMjI1IDAgbCAyMjUgNzAzIGwgMjQ2IDcwMyBsIDI2OCA3MDMgbCAyNjggMzY2IGwgMjY4IDMwIGwgMjc0IDM2IGIgMzE0IDc5IDI4NCA0NCAzMDIgNjMgYiA0MTMgMzAyIDM1NyAxMzcgMzkyIDIxMyBiIDQzMiAzMjcgNDE5IDMyNCA0MjEgMzI3IGIgNDQ5IDMwNiA0NDMgMzI3IDQ0NyAzMjIgYiA2MTEgMTE1IDQ1NyAxOTUgNTI5IDExNSBiIDY1MSAxMjIgNjI0IDExNSA2MzggMTE3IGIgNzI4IDMxNiA3MDUgMTQwIDcyNCAxODggYiA3MjkgMzg4IDcyOCAzNDIgNzI5IDM2NiBiIDY3MSA2MzUgNzI5IDUzMyA3MTEgNjAyIGIgNTgxIDY2MiA2NDkgNjUyIDYxNiA2NjIgYiA0NzcgNjM3IDU0NSA2NjIgNTEwIDY1MyBsIDQ3NSA2MzUgbCA0NzcgNjM0IGIgNTAzIDYyNyA0ODggNjMyIDQ5NSA2MzEgYiA1NDUgNTU2IDUzMiA2MTIgNTQ1IDU4NCBiIDQ5MSA0ODAgNTQ1IDUyNCA1MjYgNDkxIGIgNDY1IDQ3NCA0ODEgNDc2IDQ3MyA0NzQgYiAzNzkgNTYzIDQxNyA0NzQgMzc5IDUxNiBiIDM4OSA2MDIgMzc5IDU3NiAzODIgNTg4IGIgNTQxIDY5MSA0MDkgNjQxIDQ3OSA2ODEgYiA1ODIgNjk0IDU1NSA2OTIgNTY4IDY5NCBiIDg2NSA0NjIgNzE0IDY5NCA4MzQgNTk4IGIgODczIDM5MiA4NzEgNDQwIDg3MyA0MTYgYiA4NjUgMzE3IDg3MyAzNjcgODcxIDM0MSBiIDYzOSA4NCA4MzkgMTk0IDc0OCAxMDEgYiA2MTIgODMgNjMwIDgzIDYyMCA4MyBiIDUxMSAxMTYgNTc3IDgzIDU0MyA5NCBiIDUwNCAxMjAgNTA5IDExOSA1MDYgMTIwIGIgNTA0IDEyMCA1MDQgMTIwIDUwNCAxMjAgYiA0NjkgNTkgNTA0IDEyMCA0ODggOTMgbCA0MzIgLTEgbCA0NjkgLTYxIGIgNTA0IC0xMjIgNDg4IC05NCA1MDQgLTEyMiBiIDUwNCAtMTIyIDUwNCAtMTIyIDUwNCAtMTIyIGIgNTExIC0xMTcgNTA2IC0xMjIgNTA5IC0xMjAgYiA2MTIgLTg0IDU0MyAtOTUgNTc3IC04NCBiIDY2NSAtOTEgNjMwIC04NCA2NDcgLTg3IGIgODY5IC0zMzggNzcxIC0xMjIgODUwIC0yMTYgYiA4NzMgLTM5MiA4NzIgLTM1NiA4NzMgLTM3NCBiIDc5OCAtNTk1IDg3MyAtNDY5IDg0NyAtNTM5IGIgNTgxIC02OTUgNzQxIC02NjIgNjYwIC02OTUgYiA0MDYgLTYyNiA1MTcgLTY5NSA0NTQgLTY3MSBiIDM4MSAtNTYzIDM4OSAtNjA3IDM4MSAtNTg1IGIgNDY1IC00NzcgMzgxIC01MTkgNDEzIC00NzcgYiA1NDUgLTU1OSA1MTQgLTQ3NyA1NDUgLTUxOSBiIDUwMyAtNjI4IDU0NSAtNTg3IDUzMiAtNjEzIGIgNDc3IC02MzUgNDk1IC02MzIgNDg4IC02MzQgbCA0NzUgLTYzNyBsIDQ3NyAtNjM4IGIgNTgxIC02NjMgNTEwIC02NTUgNTQ1IC02NjMgYiA2NzEgLTYzNyA2MTYgLTY2MyA2NDkgLTY1MyBiIDcyOSAtMzkxIDcxMSAtNjAzIDcyOSAtNTM0IGIgNzI4IC0zMTcgNzI5IC0zNjcgNzI4IC0zNDQgYiA2MjMgLTExNyA3MjIgLTE3MyA2OTggLTEyNCBiIDYxMSAtMTE2IDYxOSAtMTE2IDYxNSAtMTE2IGIgNDQ5IC0zMDggNTI4IC0xMTYgNDU3IC0xOTggYiA0MzIgLTMyOCA0NDcgLTMyMyA0NDMgLTMyOCBiIDQxMyAtMzAzIDQyMSAtMzI4IDQxOSAtMzI2IGIgMzE0IC04MCAzOTIgLTIxNSAzNTcgLTEzOCBiIDI3NCAtMzcgMzAyIC02NSAyODQgLTQ1IGwgMjY4IC0zMSBsIDI2OCAtMzY3IGwgMjY4IC03MDUgbCAyNDYgLTcwNSBsIDIyNSAtNzA1IGwgMjI1IDAgXCJ9LFwidmIxXCI6e1wieF9taW5cIjo3OC45Mzc1LFwieF9tYXhcIjo0ODUuOTIxODc1LFwiaGFcIjo0MTcsXCJvXCI6XCJtIDM2MiAzNzggYiAzNzggMzgwIDM2NyAzODAgMzcyIDM4MCBiIDQ3MiAzNDggNDE1IDM4MCA0NTMgMzY3IGIgNDg1IDMxNSA0ODEgMzM4IDQ4NSAzMjcgYiA0NjIgMjczIDQ4NSAyOTggNDc3IDI4MSBiIDQzOSAyNjcgNDU0IDI2OSA0NDYgMjY3IGIgMzk4IDI5MCA0MjQgMjY3IDQwOSAyNzQgYiAzNDQgMzE5IDM4NSAzMDkgMzY0IDMxOSBiIDI4MSAyNjkgMzE1IDMxOSAyODkgMzAxIGIgMjc5IDI2MiAyODAgMjY2IDI3OSAyNjIgYiAyNzYgMjU2IDI3OSAyNjAgMjc3IDI1OCBiIDI3NCAyNDkgMjc2IDI1NCAyNzQgMjUxIGIgMjM4IDEyNyAyNzMgMjQ4IDI1NyAxOTIgYiAyMDEgNCAyMTcgNjEgMjAxIDUgYiAxNjYgLTEgMTk4IC0xIDIwMCAtMSBiIDE1MyAtMSAxNjMgLTEgMTU3IC0xIGIgMTQxIC0xIDE0OCAtMSAxNDQgLTEgYiAxMDQgNCAxMDYgLTEgMTA3IC0xIGIgMTA0IDYgMTA0IDUgMTA0IDUgYiAxNDIgMTQ0IDEwNCAxMyAxMTAgMzQgYiAxODIgMjc4IDE2NCAyMTkgMTgxIDI3NiBiIDE4MyAyODggMTgyIDI4MSAxODIgMjg1IGIgMTg1IDMwMiAxODUgMjkyIDE4NSAyOTggYiAxNjQgMzMwIDE4NSAzMTcgMTc2IDMyOCBiIDE1OSAzMzAgMTYzIDMzMCAxNjEgMzMwIGIgMTAyIDMwMiAxNDAgMzMwIDExOSAzMjAgYiA5MSAyOTQgOTUgMjk1IDkzIDI5NCBiIDg4IDI5NCA5MSAyOTQgODkgMjk0IGIgNzggMzAzIDgzIDI5NCA3OCAyOTggYiA4MSAzMTIgNzggMzA2IDc4IDMwOSBiIDIwMCAzNzMgMTA2IDM0NyAxNjAgMzczIGIgMjE1IDM3MSAyMDUgMzczIDIwOSAzNzEgYiAyNjYgMzM1IDIzNSAzNjcgMjU0IDM1MyBiIDI2OSAzMzEgMjY4IDMzMyAyNjkgMzMxIGIgMjY5IDMzMSAyNjkgMzMxIDI2OSAzMzEgYiAyNzMgMzM1IDI2OSAzMzEgMjcwIDMzNCBiIDM2MiAzNzggMjk4IDM1OSAzMzAgMzc2IFwifSxcInZiM1wiOntcInhfbWluXCI6MCxcInhfbWF4XCI6MjI3LjMxMjUsXCJoYVwiOjIzMixcIm9cIjpcIm0gOTEgMjEzIGIgMTAwIDIxNSA5MyAyMTUgOTYgMjE1IGIgMjI3IDU4IDE2NyAyMTUgMjI0IDE0NCBiIDIyNyA1MiAyMjcgNTYgMjI3IDU0IGIgNjEgLTIwMSAyMjcgLTQzIDE2NCAtMTM4IGIgMjkgLTIxNiA0NCAtMjEyIDM2IC0yMTYgYiAyMyAtMjEwIDI3IC0yMTYgMjQgLTIxMyBiIDIxIC0yMDUgMjEgLTIwOCAyMSAtMjA2IGIgMzQgLTE5MiAyMSAtMjAxIDI1IC0xOTcgYiAxMjIgLTU1IDg5IC0xNjEgMTIyIC0xMDYgYiAxMDQgNiAxMjIgLTMzIDExNyAtMTIgbCAxMDMgOSBsIDk2IDkgYiA0IDc5IDU3IDkgMTcgMzggYiAwIDExMiAxIDkwIDAgMTAxIGIgOTEgMjEzIDAgMTYzIDM2IDIwOSBcIn0sXCJ2YjRcIjp7XCJ4X21pblwiOi01OTcuNTMxMjUsXCJ4X21heFwiOjU5Ni4xNzE4NzUsXCJoYVwiOjYwOCxcIm9cIjpcIm0gLTUzMyAzMjQgYiAtNTI1IDMyNyAtNTMwIDMyNiAtNTI4IDMyNyBiIC01MDQgMzA1IC01MTQgMzI3IC01MDQgMzE3IGIgLTUwNCAzMDUgLTUwNCAzMDUgLTUwNCAzMDUgYiAtNTEzIDI4NCAtNTA0IDI5OSAtNTA0IDI5OSBiIC01NTYgMTEyIC01NDEgMjI2IC01NTYgMTY3IGIgLTU0NSAzMyAtNTU2IDg0IC01NTIgNTggYiAtNTI0IC0yMCAtNTQxIDE1IC01MzIgLTkgbCAtNTIyIC0yMyBsIC00OTEgMTUgbCAtNDEzIDExMSBiIC0zNTUgMTc0IC0zNjcgMTY5IC0zNjMgMTc0IGIgLTM1MSAxNzQgLTM1MyAxNzQgLTM1MiAxNzQgYiAtMjU0IDg2IC0zNDMgMTc0IC0zNDggMTc5IGIgLTE2OCAtMSAtMjA4IDM3IC0xNjggLTEgYiAtMTAwIDg0IC0xNjggLTEgLTEzNyAzNyBiIC0yMyAxNzMgLTI4IDE3MyAtMjkgMTcyIGIgLTE5IDE3NCAtMjEgMTc0IC0yMCAxNzQgYiAtOCAxNzMgLTE0IDE3NCAtMTAgMTczIGIgODAgODYgLTUgMTcyIDEzIDE1MSBiIDE2NiAtMSAxMjcgMzcgMTY2IC0xIGIgMjM1IDg0IDE2NiAtMSAxOTcgMzcgYiAzMTEgMTczIDMwNiAxNzMgMzA0IDE3MiBiIDMxNyAxNzQgMzEzIDE3NCAzMTQgMTc0IGIgMzI2IDE3MyAzMTkgMTc0IDMyMyAxNzMgYiA0OTAgMTEgMzI5IDE3MiAzNjYgMTM0IGwgNTAyIC0xIGwgNTMwIDM0IGIgNTY4IDc2IDU2MCA3MiA1NjMgNzQgYiA1NzUgNzcgNTcwIDc3IDU3MyA3NyBiIDU5NiA1NiA1ODYgNzcgNTk2IDY4IGIgNTk0IDQ4IDU5NiA1NCA1OTYgNTEgYiA0MTcgLTE3MiA1OTIgNDEgNDI0IC0xNjYgYiA0MDUgLTE3NiA0MTUgLTE3NCA0MDkgLTE3NiBiIDM5NiAtMTc0IDQwMSAtMTc2IDM5OCAtMTc2IGIgMzA3IC04NyAzOTMgLTE3MyAzNzIgLTE1MiBiIDIyMSAtMSAyNTkgLTM4IDIyMSAtMSBiIDE1MiAtODYgMjIxIC0xIDE5MCAtMzggYiA3NiAtMTc2IDgxIC0xNzQgODMgLTE3MyBiIDcwIC0xNzYgNzQgLTE3NiA3MyAtMTc2IGIgNjEgLTE3NCA2NiAtMTc2IDYyIC0xNzQgYiAtMjcgLTg3IDU4IC0xNzMgMzggLTE1MiBiIC0xMTQgLTEgLTc0IC0zOCAtMTEyIC0xIGIgLTE4MiAtODYgLTExNCAtMSAtMTQ1IC0zOCBiIC0yNTggLTE3NiAtMjUzIC0xNzQgLTI1MyAtMTczIGIgLTI2NCAtMTc2IC0yNTkgLTE3NiAtMjYyIC0xNzYgYiAtMjc0IC0xNzQgLTI2OCAtMTc2IC0yNzIgLTE3NCBiIC00MzggLTExIC0yNzcgLTE3MyAtMzQ4IC0xMDIgbCAtNDQ5IDAgbCAtNDc5IC0zNyBiIC01MjQgLTgwIC01MTMgLTgwIC01MTQgLTgwIGwgLTUyNCAtODAgYiAtNTUzIC01MiAtNTM0IC04MCAtNTQwIC03NCBiIC01OTcgMTA5IC01ODMgLTggLTU5NyA0OCBiIC01NjAgMjgwIC01OTcgMTY1IC01ODUgMjI0IGIgLTUzMyAzMjQgLTU0OCAzMTAgLTU0MCAzMjIgXCJ9LFwidmI2XCI6e1wieF9taW5cIjowLFwieF9tYXhcIjo1NTYuNjg3NSxcImhhXCI6NTY4LFwib1wiOlwibSAyODkgNTQ1IGIgMjk4IDU0NiAyOTIgNTQ1IDI5NSA1NDYgYiAzMTggNTMzIDMwNiA1NDYgMzE1IDU0MSBiIDMxOSA0MjggMzE5IDUzMCAzMTkgNTI4IGwgMzE5IDMyNyBsIDMzNCAzMjcgYiA1MjYgMjIzIDQxMiAzMjYgNDg1IDI4NSBiIDU0MyAxNzIgNTM3IDIwNiA1NDMgMTkwIGIgNDQ3IDc2IDU0MyAxMjIgNTAzIDc2IGIgNDQ1IDc2IDQ0NiA3NiA0NDYgNzYgYiAzNTkgMTY1IDM5NCA3NyAzNTkgMTE5IGIgMzY4IDIwNSAzNTkgMTc5IDM2MiAxOTIgYiA0NDEgMjUxIDM4MiAyMzMgNDEyIDI1MSBiIDQ1NSAyNDkgNDQ2IDI1MSA0NTEgMjUxIGIgNDYwIDI0OCA0NTggMjQ5IDQ2MCAyNDggYiA0NjAgMjQ4IDQ2MCAyNDggNDYwIDI0OCBiIDQ1NCAyNTQgNDYwIDI0OSA0NTggMjUxIGIgMzM0IDI5NSA0MTkgMjgwIDM3OCAyOTQgbCAzMTkgMjk1IGwgMzE5IDQgbCAzMTkgLTI4NyBsIDMyMSAtMjg1IGIgMzI4IC0yODUgMzIyIC0yODUgMzI1IC0yODUgYiA1MjQgLTk5IDQyNCAtMjc3IDUwNyAtMTk4IGIgNTQxIC03OSA1MjYgLTg0IDUzMCAtNzkgYiA1NTYgLTk3IDU1MSAtNzkgNTU2IC04NCBiIDU0OCAtMTMzIDU1NiAtMTA1IDU1MyAtMTE3IGIgMzM0IC0zMTcgNTIxIC0yMzMgNDM0IC0zMDYgYiAzMjIgLTMxOSAzMjkgLTMxNyAzMjMgLTMxNyBsIDMxOSAtMzE5IGwgMzE5IC00MjQgYiAzMTkgLTQ3MSAzMTkgLTQ0NCAzMTkgLTQ1OSBiIDMxMyAtNTQxIDMxOSAtNTQ0IDMxOCAtNTM1IGIgMjk4IC01NDggMzA4IC01NDUgMzAzIC01NDggYiAyNzkgLTUzNCAyODkgLTU0OCAyODEgLTU0MiBiIDI3NyAtNDI0IDI3NyAtNTMxIDI3NyAtNTMwIGwgMjc3IC0zMTcgbCAyNzMgLTMxNyBiIDEzIC05NSAxNTMgLTMwNSA1MSAtMjE3IGIgMCAyIDQgLTYyIDAgLTI5IGIgMTgyIDI5NSAwIDEyNiA2NiAyMzggYiAyNzQgMzI0IDIxMCAzMDkgMjQ5IDMyMCBsIDI3NyAzMjQgbCAyNzcgNDI3IGIgMjc5IDUzMyAyNzcgNTI4IDI3NyA1MzAgYiAyODkgNTQ1IDI4MSA1MzggMjg1IDU0MiBtIDI3NyAyIGIgMjc3IDI5MSAyNzcgMTYxIDI3NyAyOTEgYiAyNjggMjg4IDI3NyAyOTEgMjczIDI5MCBiIDE0NCAxIDE3OSAyNjUgMTQ0IDE4NCBiIDI3NiAtMjg0IDE0NCAtMTk5IDE3NSAtMjY3IGwgMjc3IC0yODUgbCAyNzcgMiBcIn0sXCJ2YjlcIjp7XCJ4X21pblwiOi0xMjIuNSxcInhfbWF4XCI6MTIxLjE0MDYyNSxcImhhXCI6MTI0LFwib1wiOlwibSAtMTYgMTQ1IGIgMCAxNDcgLTEwIDE0NyAtNSAxNDcgYiAxMjEgLTEgNjYgMTQ3IDEyMSA3NyBiIDExNCAtNDkgMTIxIC0xNiAxMTggLTMzIGIgLTEgLTE0OCA5NSAtMTEyIDQ3IC0xNDggYiAtODUgLTEwNiAtMzEgLTE0OCAtNjEgLTEzNCBiIC0xMjIgLTEgLTExMCAtNzYgLTEyMiAtMzggYiAtMTYgMTQ1IC0xMjIgNjggLTgxIDEzNCBtIDEyIDExMSBiIDAgMTEzIDggMTEzIDQgMTEzIGIgLTY4IDIyIC0yOSAxMTMgLTYxIDczIGIgLTcwIDAgLTY5IDE1IC03MCA2IGIgLTEzIC0xMTMgLTcwIC00OSAtNDcgLTk4IGIgLTEgLTExNSAtOSAtMTE1IC01IC0xMTUgYiA2MyAtNDAgMjQgLTExNSA1MyAtODMgYiA2OCAtMSA2NiAtMjcgNjggLTE1IGIgMTIgMTExIDY4IDQ4IDQ2IDk3IFwifSxcInZiYVwiOntcInhfbWluXCI6LTExOC40MjE4NzUsXCJ4X21heFwiOjU5Ny41MzEyNSxcImhhXCI6MzgxLFwib1wiOlwibSA0NjAgNTc0IGIgNDY0IDU3NCA0NjEgNTc0IDQ2MiA1NzQgYiA0ODggNTc0IDQ3MCA1NzQgNDgxIDU3NCBiIDUwMCA1NzMgNDkxIDU3NCA0OTggNTc0IGIgNTk0IDUwMyA1NDMgNTcwIDU4OCA1MzggYiA1OTcgNDg4IDU5NiA0OTggNTk3IDQ5NCBiIDUyOCA0MTcgNTk3IDQ0OSA1NjQgNDE3IGIgNTAyIDQyMyA1MTkgNDE3IDUxMCA0MTkgYiA0NjUgNDgxIDQ3NyA0MzQgNDY1IDQ1OCBiIDQ4OCA1MjggNDY1IDQ5OSA0NzIgNTE2IGIgNDkwIDUzMCA0OTAgNTMwIDQ5MCA1MzAgYiA0OTAgNTMwIDQ5MCA1MzAgNDkwIDUzMCBiIDQ2OCA1MTcgNDg4IDUzMCA0NzUgNTIzIGIgMzQ5IDM0MCA0MTkgNDg1IDM3NyA0MjAgYiAzNDcgMzMwIDM0OCAzMzQgMzQ3IDMzMCBiIDM4MyAzMjggMzQ3IDMyOCAzNjMgMzI4IGIgNDI4IDMyNiA0MjMgMzI4IDQyNCAzMjggYiA0NDIgMzAyIDQzOCAzMjAgNDQyIDMxMiBiIDQzMCAyODEgNDQyIDI5NCA0MzggMjg1IGIgMzg1IDI3NiA0MjQgMjc3IDQyNiAyNzYgbCAzNzcgMjc2IGwgMzMyIDI3NiBsIDMzMCAyNjkgYiAxNzggLTExNyAzMDMgMTI2IDI1MCAtOSBiIDEgLTI0OSAxMjkgLTE5NCA2OSAtMjM3IGIgLTIwIC0yNTEgLTYgLTI1MSAtMTMgLTI1MSBiIC0xMTQgLTE4NyAtNjUgLTI1MSAtMTAwIC0yMjcgYiAtMTE4IC0xNTYgLTExNyAtMTc3IC0xMTggLTE2NiBiIC01MSAtODQgLTExOCAtMTE2IC05MSAtODQgYiAtMzEgLTg3IC00NiAtODQgLTM5IC04NiBiIDE2IC0xNTIgMCAtOTUgMTYgLTEyNCBiIC0xMiAtMjA1IDE2IC0xNzMgOCAtMTk0IGIgLTE2IC0yMDggLTE0IC0yMDYgLTE2IC0yMDggYiAtMTQgLTIwOCAtMTYgLTIwOCAtMTQgLTIwOCBiIC05IC0yMDYgLTE0IC0yMDggLTEyIC0yMDggYiA3NCAtMTI0IDIzIC0xOTcgNTQgLTE2NiBiIDE3MiAyMjQgOTggLTc5IDEyNSAyMiBiIDE4NSAyNzYgMTc4IDI1MiAxODMgMjc0IGIgMTg1IDI3NiAxODUgMjc2IDE4NSAyNzYgYiAxNDEgMjc2IDE4NSAyNzYgMTgxIDI3NiBiIDkxIDI4MCA5NiAyNzYgOTYgMjc2IGIgNzcgMzAyIDgzIDI4NSA3NyAyOTQgYiA5MSAzMjYgNzcgMzEyIDgzIDMyMCBiIDE0OCAzMjggOTUgMzI4IDk2IDMyOCBsIDE5OCAzMzAgbCAyMDIgMzQxIGIgNDYwIDU3NCAyNDkgNDczIDM1MSA1NjYgXCJ9LFwidmJmXCI6e1wieF9taW5cIjotNTMuMDc4MTI1LFwieF9tYXhcIjo1MTMuMTQwNjI1LFwiaGFcIjo0ODUsXCJvXCI6XCJtIDE4NSAzODMgYiAxOTYgMzg0IDE4NyAzODMgMTkxIDM4NCBiIDI3NyAzMzQgMjMwIDM4NCAyNTkgMzY1IGIgMjg4IDMwMSAyODEgMzI0IDI4OCAzMDYgYiAyODggMjk3IDI4OCAyOTggMjg4IDI5NyBiIDI5NCAzMDIgMjg5IDI5NyAyOTEgMjk5IGIgMzk0IDM3MCAzMjMgMzM4IDM2NyAzNjcgYiA0MDQgMzcxIDM5OCAzNzAgNDAxIDM3MSBiIDUxMCAyNzIgNDUzIDM3MSA0OTggMzI4IGIgNTEzIDIzNyA1MTMgMjYyIDUxMyAyNTEgYiA1MDcgMTcyIDUxMyAyMTcgNTExIDE5MiBiIDMyNiAtMzQgNDg3IDU5IDQxMiAtMjYgYiAzMTQgLTM2IDMyMiAtMzYgMzE4IC0zNiBiIDI3NCAtMjQgMjk4IC0zNiAyODMgLTMxIGwgMjY1IC0xNiBiIDIyNCA0NCAyNDYgLTEgMjMyIDIwIGIgMjIzIDQ5IDIyNCA0NyAyMjMgNDkgYiAyMjMgNDkgMjIzIDQ5IDIyMyA0OSBiIDE0OSAtMTk3IDIyMSA0OCAxNDkgLTE5NCBiIDE0OSAtMTk4IDE0OSAtMTk3IDE0OSAtMTk4IGIgMTcwIC0yMTAgMTQ5IC0yMDIgMTU1IC0yMDUgYiAxODcgLTIxNSAxNzQgLTIxMCAxNzUgLTIxMiBiIDIwNCAtMjMxIDIwMSAtMjE5IDIwNCAtMjIyIGIgMTk3IC0yNDUgMjA0IC0yNDAgMjAyIC0yNDIgbCAxOTQgLTI0OCBsIDc2IC0yNDggbCAtNDIgLTI0OCBsIC00NiAtMjQ1IGIgLTUzIC0yMzEgLTUxIC0yNDIgLTUzIC0yNDAgYiAtMzUgLTIxNSAtNTMgLTIyMiAtNDkgLTIxNyBiIC0xMyAtMjEwIC0yMSAtMjEyIC0yMCAtMjEyIGIgLTYgLTIwOCAtMTAgLTIwOSAtOCAtMjA4IGIgMCAtMjA2IC02IC0yMDggLTIgLTIwNiBiIDI1IC0xODggMTMgLTIwMSAyMSAtMTk1IGIgMTYzIDI4MCAyOCAtMTgzIDE2MyAyNzYgYiAxNjYgMjkxIDE2MyAyODMgMTY0IDI4NyBiIDE2NyAzMDIgMTY3IDI5NSAxNjcgMjk5IGIgMTU1IDMyNCAxNjcgMzE1IDE2MSAzMjQgYiAxNTUgMzI0IDE1NSAzMjQgMTU1IDMyNCBiIDY1IDIzMCAxMjUgMzIyIDg1IDI4MCBiIDUzIDIxNSA2MSAyMTcgNTggMjE1IGIgNTEgMjE1IDUzIDIxNSA1MSAyMTUgYiA0MiAyMjQgNDYgMjE1IDQyIDIxNyBiIDU3IDI2MyA0MiAyMzEgNDcgMjQ0IGIgMTQwIDM2MCA3NyAzMDUgMTA0IDMzNyBiIDE1MiAzNzAgMTQ0IDM2NSAxNDkgMzY5IGIgMTg1IDM4MyAxNTcgMzc2IDE3MiAzODEgbSAzNzQgMzA2IGIgMzY2IDMwOCAzNzEgMzA4IDM2OCAzMDggYiAzMDAgMjczIDM0OCAzMDggMzIxIDI5NCBiIDI4NCAyNTQgMjg4IDI2MiAyODcgMjU5IGIgMjgwIDI0MiAyODMgMjQ5IDI4MSAyNDUgYiAyNTcgMTY5IDI3OSAyNDAgMjcwIDIxMyBsIDIzNiA5OCBsIDIzNiA5MyBiIDI1MSA0OCAyMzggNzcgMjQzIDYxIGIgMjc5IDI3IDI1OCAzNyAyNzIgMjcgYiAyODEgMjcgMjc5IDI3IDI4MCAyNyBiIDI5MSAzMSAyODEgMjcgMjg3IDMwIGIgMzk2IDE3MCAzMzQgNTIgMzc4IDEwOSBiIDQwNiAyNDcgNDAyIDE5NyA0MDYgMjI0IGIgNDAxIDI3NyA0MDYgMjU5IDQwNSAyNzAgYiAzNzQgMzA2IDM5NyAyOTAgMzgzIDMwMyBcIn0sXCJ2YzNcIjp7XCJ4X21pblwiOi0xMC44OTA2MjUsXCJ4X21heFwiOjI5OS40Mzc1LFwiaGFcIjoyOTQsXCJvXCI6XCJtIDEzNiA0NjAgYiAxNDIgNDYyIDEzNyA0NjIgMTQwIDQ2MiBiIDE2NiA0NDkgMTUyIDQ2MiAxNjEgNDU2IGIgMTcxIDQyOCAxNjggNDQ2IDE2OCA0NDUgYiAyODggMTMxIDE5NCAzMjIgMjM4IDIwOSBiIDI5OCAxMTUgMjk1IDEyMCAyOTYgMTE3IGIgMjk5IDEwNiAyOTggMTEyIDI5OSAxMDkgYiAyNzMgODEgMjk5IDkxIDI4NyA4MSBiIDI1NSA4NiAyNjggODEgMjYxIDgzIGIgMTU1IDExNiAyMjUgMTA0IDE4MyAxMTYgbCAxNTIgMTE2IGwgMTQ5IDEwOCBiIDE0MSA4MyAxNDggMTAyIDE0NCA5MSBiIDEzNCA0OCAxMzcgNjkgMTM0IDU4IGIgMTQ5IDkgMTM0IDM0IDE0MCAyNCBiIDE1MyAtMSAxNTIgNSAxNTMgMSBiIDE0OSAtOSAxNTMgLTUgMTUyIC02IGIgMTQ0IC0xMSAxNDggLTExIDE0NyAtMTEgYiAxMjIgMiAxMzggLTExIDEzMyAtNiBiIDk1IDYxIDEwNCAyMCA5NSAzOCBiIDEwNyAxMDggOTUgNzQgOTkgOTAgYiAxMDggMTEzIDEwNyAxMTEgMTA4IDExMiBiIDEwNyAxMTMgMTA4IDExMyAxMDggMTEzIGIgMTAyIDExMyAxMDYgMTEzIDEwNCAxMTMgYiAzMSA4NiA3NiAxMDggNTMgOTggYiAxNCA4MCAyNCA4MSAyMCA4MCBiIC0xMCAxMDYgMCA4MCAtMTAgOTEgYiAwIDEzMSAtMTAgMTE1IC05IDExNiBiIDExNSA0MzAgNDkgMjA5IDkxIDMxNyBiIDEzNiA0NjAgMTE5IDQ1MSAxMjMgNDU2IFwifX0sXCJjc3NGb250V2VpZ2h0XCI6XCJub3JtYWxcIixcImFzY2VuZGVyXCI6MTkwMyxcInVuZGVybGluZVBvc2l0aW9uXCI6LTEyNSxcImNzc0ZvbnRTdHlsZVwiOlwibm9ybWFsXCIsXCJib3VuZGluZ0JveFwiOntcInlNaW5cIjotMjA2NS4zNzUsXCJ4TWluXCI6LTY5NS41MzEyNSxcInlNYXhcIjoxOTAxLjU3ODEyNSxcInhNYXhcIjoxMTU5LjY3MTg3NX0sXCJyZXNvbHV0aW9uXCI6MTAwMCxcImRlc2NlbmRlclwiOi0yMDY2LFwiZmFtaWx5TmFtZVwiOlwiVmV4Rmxvdy0xOFwiLFwibGluZUhlaWdodFwiOjQwOTMsXCJ1bmRlcmxpbmVUaGlja25lc3NcIjo1MH07XG4vLyBWZXggRmxvd1xuLy8gTW9oaXQgTXV0aGFubmEgPG1vaGl0QG11dGhhbm5hLmNvbT5cbi8vXG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFJlcXVpcmVzIGEgZ2x5cGggZm9udCB0byBiZSBsb2FkZWQgYW5kIFZleC5GbG93LkZvbnQgdG8gYmUgc2V0LlxuXG4vKipcbiAqIEEgcXVpY2sgYW5kIGRpcnR5IHN0YXRpYyBnbHlwaCByZW5kZXJlci4gUmVuZGVycyBnbHlwaHMgZnJvbSB0aGUgZGVmYXVsdFxuICogZm9udCBkZWZpbmVkIGluIFZleC5GbG93LkZvbnQuXG4gKlxuICogQHBhcmFtIHshT2JqZWN0fSBjdHggVGhlIGNhbnZhcyBjb250ZXh0LlxuICogQHBhcmFtIHtudW1iZXJ9IHhfcG9zIFggY29vcmRpbmF0ZS5cbiAqIEBwYXJhbSB7bnVtYmVyfSB5X3BvcyBZIGNvb3JkaW5hdGUuXG4gKiBAcGFyYW0ge251bWJlcn0gcG9pbnQgVGhlIHBvaW50IHNpemUgdG8gdXNlLlxuICogQHBhcmFtIHtzdHJpbmd9IHZhbCBUaGUgZ2x5cGggY29kZSBpbiBWZXguRmxvdy5Gb250LlxuICogQHBhcmFtIHtib29sZWFufSBub2NhY2hlIElmIHNldCwgZGlzYWJsZXMgY2FjaGluZyBvZiBmb250IG91dGxpbmUuXG4gKi9cblZleC5GbG93LnJlbmRlckdseXBoID0gZnVuY3Rpb24oY3R4LCB4X3BvcywgeV9wb3MsIHBvaW50LCB2YWwsIG5vY2FjaGUpIHtcbiAgdmFyIHNjYWxlID0gcG9pbnQgKiA3Mi4wIC8gKFZleC5GbG93LkZvbnQucmVzb2x1dGlvbiAqIDEwMC4wKTtcbiAgdmFyIG1ldHJpY3MgPSBWZXguRmxvdy5HbHlwaC5sb2FkTWV0cmljcyhWZXguRmxvdy5Gb250LCB2YWwsICFub2NhY2hlKTtcbiAgVmV4LkZsb3cuR2x5cGgucmVuZGVyT3V0bGluZShjdHgsIG1ldHJpY3Mub3V0bGluZSwgc2NhbGUsIHhfcG9zLCB5X3Bvcyk7XG59O1xuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5WZXguRmxvdy5HbHlwaCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gR2x5cGgoY29kZSwgcG9pbnQsIG9wdGlvbnMpIHtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICAgIHRoaXMucG9pbnQgPSBwb2ludDtcbiAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIGNhY2hlOiB0cnVlLFxuICAgICAgZm9udDogVmV4LkZsb3cuRm9udFxuICAgIH07XG5cbiAgICB0aGlzLndpZHRoID0gbnVsbDtcbiAgICB0aGlzLm1ldHJpY3MgPSBudWxsO1xuICAgIHRoaXMueF9zaGlmdCA9IDA7XG4gICAgdGhpcy55X3NoaWZ0ID0gMDtcblxuICAgIGlmIChvcHRpb25zKSB0aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7IGVsc2UgdGhpcy5yZXNldCgpO1xuICB9XG5cbiAgR2x5cGgucHJvdG90eXBlID0ge1xuICAgIHNldE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIFZleC5NZXJnZSh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuICAgICAgdGhpcy5yZXNldCgpO1xuICAgIH0sXG5cbiAgICBzZXRTdGF2ZTogZnVuY3Rpb24oc3RhdmUpIHsgdGhpcy5zdGF2ZSA9IHN0YXZlOyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRYU2hpZnQ6IGZ1bmN0aW9uKHhfc2hpZnQpIHsgdGhpcy54X3NoaWZ0ID0geF9zaGlmdDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgc2V0WVNoaWZ0OiBmdW5jdGlvbih5X3NoaWZ0KSB7IHRoaXMueV9zaGlmdCA9IHlfc2hpZnQ7IHJldHVybiB0aGlzOyB9LFxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHsgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmNvbnRleHQ7IH0sXG5cbiAgICByZXNldDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm1ldHJpY3MgPSBWZXguRmxvdy5HbHlwaC5sb2FkTWV0cmljcyh0aGlzLm9wdGlvbnMuZm9udCwgdGhpcy5jb2RlLFxuICAgICAgICAgIHRoaXMub3B0aW9ucy5jYWNoZSk7XG4gICAgICB0aGlzLnNjYWxlID0gdGhpcy5wb2ludCAqIDcyIC8gKHRoaXMub3B0aW9ucy5mb250LnJlc29sdXRpb24gKiAxMDApO1xuICAgIH0sXG5cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIHRoaXMud2lkdGggPSAgd2lkdGg7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0TWV0cmljczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMubWV0cmljcykgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRHbHlwaFwiLCBcIkdseXBoIFwiICtcbiAgICAgICAgICB0aGlzLmNvZGUgKyBcIiBpcyBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeF9taW46IHRoaXMubWV0cmljcy54X21pbiAqIHRoaXMuc2NhbGUsXG4gICAgICAgIHhfbWF4OiB0aGlzLm1ldHJpY3MueF9tYXggKiB0aGlzLnNjYWxlLFxuICAgICAgICB3aWR0aDogdGhpcy53aWR0aCB8fCAodGhpcy5tZXRyaWNzLnhfbWF4IC0gdGhpcy5tZXRyaWNzLnhfbWluKSAqIHRoaXMuc2NhbGUsXG4gICAgICAgIGhlaWdodDogdGhpcy5tZXRyaWNzLmhhICogdGhpcy5zY2FsZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgcmVuZGVyOiBmdW5jdGlvbihjdHgsIHhfcG9zLCB5X3Bvcykge1xuICAgICAgaWYgKCF0aGlzLm1ldHJpY3MpIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiQmFkR2x5cGhcIiwgXCJHbHlwaCBcIiArXG4gICAgICAgICAgdGhpcy5jb2RlICsgXCIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcblxuICAgICAgdmFyIG91dGxpbmUgPSB0aGlzLm1ldHJpY3Mub3V0bGluZTtcbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuc2NhbGU7XG5cbiAgICAgIEdseXBoLnJlbmRlck91dGxpbmUoY3R4LCBvdXRsaW5lLCBzY2FsZSwgeF9wb3MsIHlfcG9zKTtcbiAgICB9LFxuXG4gICAgcmVuZGVyVG9TdGF2ZTogZnVuY3Rpb24oeCkge1xuICAgICAgaWYgKCF0aGlzLm1ldHJpY3MpIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiQmFkR2x5cGhcIiwgXCJHbHlwaCBcIiArXG4gICAgICAgICAgdGhpcy5jb2RlICsgXCIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICAgIGlmICghdGhpcy5zdGF2ZSkgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJHbHlwaEVycm9yXCIsIFwiTm8gdmFsaWQgc3RhdmVcIik7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiR2x5cGhFcnJvclwiLCBcIk5vIHZhbGlkIGNvbnRleHRcIik7XG5cbiAgICAgIHZhciBvdXRsaW5lID0gdGhpcy5tZXRyaWNzLm91dGxpbmU7XG4gICAgICB2YXIgc2NhbGUgPSB0aGlzLnNjYWxlO1xuXG4gICAgICBHbHlwaC5yZW5kZXJPdXRsaW5lKHRoaXMuY29udGV4dCwgb3V0bGluZSwgc2NhbGUsXG4gICAgICAgICAgeCArIHRoaXMueF9zaGlmdCwgdGhpcy5zdGF2ZS5nZXRZRm9yR2x5cGhzKCkgKyB0aGlzLnlfc2hpZnQpO1xuICAgIH1cbiAgfTtcblxuICAvKiBTdGF0aWMgbWV0aG9kcyB1c2VkIHRvIGltcGxlbWVudCBsb2FkaW5nIC8gdW5sb2FkaW5nIG9mIGdseXBocyAqL1xuICBHbHlwaC5sb2FkTWV0cmljcyA9IGZ1bmN0aW9uKGZvbnQsIGNvZGUsIGNhY2hlKSB7XG4gICAgdmFyIGdseXBoID0gZm9udC5nbHlwaHNbY29kZV07XG4gICAgaWYgKCFnbHlwaCkgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRHbHlwaFwiLCBcIkdseXBoIFwiICsgY29kZSArXG4gICAgICAgIFwiIGRvZXMgbm90IGV4aXN0IGluIGZvbnQuXCIpO1xuXG4gICAgdmFyIHhfbWluID0gZ2x5cGgueF9taW47XG4gICAgdmFyIHhfbWF4ID0gZ2x5cGgueF9tYXg7XG4gICAgdmFyIGhhID0gZ2x5cGguaGE7XG5cbiAgICB2YXIgb3V0bGluZTtcblxuICAgIGlmIChnbHlwaC5vKSB7XG4gICAgICBpZiAoY2FjaGUpIHtcbiAgICAgICAgaWYgKGdseXBoLmNhY2hlZF9vdXRsaW5lKSB7XG4gICAgICAgICAgb3V0bGluZSA9IGdseXBoLmNhY2hlZF9vdXRsaW5lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG91dGxpbmUgPSBnbHlwaC5vLnNwbGl0KCcgJyk7XG4gICAgICAgICAgZ2x5cGguY2FjaGVkX291dGxpbmUgPSBvdXRsaW5lO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoZ2x5cGguY2FjaGVkX291dGxpbmUpIGRlbGV0ZSBnbHlwaC5jYWNoZWRfb3V0bGluZTtcbiAgICAgICAgb3V0bGluZSA9IGdseXBoLm8uc3BsaXQoJyAnKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeF9taW46IHhfbWluLFxuICAgICAgICB4X21heDogeF9tYXgsXG4gICAgICAgIGhhOiBoYSxcbiAgICAgICAgb3V0bGluZTogb3V0bGluZVxuICAgICAgfTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRHbHlwaFwiLCBcIkdseXBoIFwiICsgdGhpcy5jb2RlICtcbiAgICAgICAgICBcIiBoYXMgbm8gb3V0bGluZSBkZWZpbmVkLlwiKTtcbiAgICB9XG4gIH07XG5cbiAgR2x5cGgucmVuZGVyT3V0bGluZSA9IGZ1bmN0aW9uKGN0eCwgb3V0bGluZSwgc2NhbGUsIHhfcG9zLCB5X3Bvcykge1xuICAgIHZhciBvdXRsaW5lTGVuZ3RoID0gb3V0bGluZS5sZW5ndGg7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBjdHgubW92ZVRvKHhfcG9zLCB5X3Bvcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG91dGxpbmVMZW5ndGg7ICkge1xuICAgICAgdmFyIGFjdGlvbiA9IG91dGxpbmVbaSsrXTtcblxuICAgICAgc3dpdGNoKGFjdGlvbikge1xuICAgICAgICBjYXNlICdtJzpcbiAgICAgICAgICBjdHgubW92ZVRvKHhfcG9zICsgb3V0bGluZVtpKytdICogc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICB5X3BvcyArIG91dGxpbmVbaSsrXSAqIC1zY2FsZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2wnOlxuICAgICAgICAgIGN0eC5saW5lVG8oeF9wb3MgKyBvdXRsaW5lW2krK10gKiBzY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgIHlfcG9zICsgb3V0bGluZVtpKytdICogLXNjYWxlKTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdxJzpcbiAgICAgICAgICB2YXIgY3B4ID0geF9wb3MgKyBvdXRsaW5lW2krK10gKiBzY2FsZTtcbiAgICAgICAgICB2YXIgY3B5ID0geV9wb3MgKyBvdXRsaW5lW2krK10gKiAtc2NhbGU7XG5cbiAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgeF9wb3MgKyBvdXRsaW5lW2krK10gKiBzY2FsZSxcbiAgICAgICAgICAgICAgeV9wb3MgKyBvdXRsaW5lW2krK10gKiAtc2NhbGUsIGNweCwgY3B5KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlICdiJzpcbiAgICAgICAgICB2YXIgeCA9IHhfcG9zICsgb3V0bGluZVtpKytdICogc2NhbGU7XG4gICAgICAgICAgdmFyIHkgPSB5X3BvcyArIG91dGxpbmVbaSsrXSAqIC1zY2FsZTtcblxuICAgICAgICAgIGN0eC5iZXppZXJDdXJ2ZVRvKFxuICAgICAgICAgICAgICB4X3BvcyArIG91dGxpbmVbaSsrXSAqIHNjYWxlLCB5X3BvcyArIG91dGxpbmVbaSsrXSAqIC1zY2FsZSxcbiAgICAgICAgICAgICAgeF9wb3MgKyBvdXRsaW5lW2krK10gKiBzY2FsZSwgeV9wb3MgKyBvdXRsaW5lW2krK10gKiAtc2NhbGUsXG4gICAgICAgICAgICAgIHgsIHkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjdHguZmlsbCgpO1xuICB9O1xuXG4gIHJldHVybiBHbHlwaDtcbn0oKSk7XG5cbi8vIFZleCBGbG93XG4vLyBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy9cbi8vIENvcHlyaWdodCBNb2hpdCBDaGVwcHVkaXJhIDIwMTBcblxuLyoqIEBjb25zdHJ1Y3RvciAqL1xuVmV4LkZsb3cuU3RhdmUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFN0YXZlKHgsIHksIHdpZHRoLCBvcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQoeCwgeSwgd2lkdGgsIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIFRISUNLTkVTUyA9IChWZXguRmxvdy5TVEFWRV9MSU5FX1RISUNLTkVTUyA+IDEgP1xuICAgICAgICBWZXguRmxvdy5TVEFWRV9MSU5FX1RISUNLTkVTUyA6IDApO1xuICBTdGF2ZS5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnkgPSB5O1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgICAgdGhpcy5nbHlwaF9zdGFydF94ID0geCArIDU7XG4gICAgICB0aGlzLmdseXBoX2VuZF94ID0geCArIHdpZHRoO1xuICAgICAgdGhpcy5zdGFydF94ID0gdGhpcy5nbHlwaF9zdGFydF94O1xuICAgICAgdGhpcy5lbmRfeCA9IHRoaXMuZ2x5cGhfZW5kX3g7XG4gICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy5nbHlwaHMgPSBbXTtcbiAgICAgIHRoaXMuZW5kX2dseXBocyA9IFtdO1xuICAgICAgdGhpcy5tb2RpZmllcnMgPSBbXTsgIC8vIG5vbi1nbHlwaCBzdGF2ZSBpdGVtcyAoYmFybGluZXMsIGNvZGEsIHNlZ25vLCBldGMuKVxuICAgICAgdGhpcy5tZWFzdXJlID0gMDtcbiAgICAgIHRoaXMuY2xlZiA9IFwidHJlYmxlXCI7XG4gICAgICB0aGlzLmZvbnQgPSB7XG4gICAgICAgIGZhbWlseTogXCJzYW5zLXNlcmlmXCIsXG4gICAgICAgIHNpemU6IDgsXG4gICAgICAgIHdlaWdodDogXCJcIlxuICAgICAgfTtcbiAgICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgICAgdmVydGljYWxfYmFyX3dpZHRoOiAxMCwgICAgICAgLy8gV2lkdGggYXJvdW5kIHZlcnRpY2FsIGJhciBlbmQtbWFya2VyXG4gICAgICAgIGdseXBoX3NwYWNpbmdfcHg6IDEwLFxuICAgICAgICBudW1fbGluZXM6IDUsXG4gICAgICAgIGZpbGxfc3R5bGU6IFwiIzk5OTk5OVwiLFxuICAgICAgICBzcGFjaW5nX2JldHdlZW5fbGluZXNfcHg6IDEwLCAvLyBpbiBwaXhlbHNcbiAgICAgICAgc3BhY2VfYWJvdmVfc3RhZmZfbG46IDQsICAgICAgLy8gaW4gc3RhZmYgbGluZXNcbiAgICAgICAgc3BhY2VfYmVsb3dfc3RhZmZfbG46IDQsICAgICAgLy8gaW4gc3RhZmYgbGluZXNcbiAgICAgICAgdG9wX3RleHRfcG9zaXRpb246IDEgICAgICAgICAgLy8gaW4gc3RhZmYgbGluZXNcbiAgICAgIH07XG4gICAgICB0aGlzLmJvdW5kcyA9IHt4OiB0aGlzLngsIHk6IHRoaXMueSwgdzogdGhpcy53aWR0aCwgaDogMH07XG4gICAgICBWZXguTWVyZ2UodGhpcy5vcHRpb25zLCBvcHRpb25zKTtcblxuICAgICAgdGhpcy5yZXNldExpbmVzKCk7XG5cbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2goXG4gICAgICAgICAgbmV3IFZleC5GbG93LkJhcmxpbmUoVmV4LkZsb3cuQmFybGluZS50eXBlLlNJTkdMRSwgdGhpcy54KSk7IC8vIGJlZyBiYXJcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2goXG4gICAgICAgICAgbmV3IFZleC5GbG93LkJhcmxpbmUoVmV4LkZsb3cuQmFybGluZS50eXBlLlNJTkdMRSxcbiAgICAgICAgICB0aGlzLnggKyB0aGlzLndpZHRoKSk7IC8vIGVuZCBiYXJcbiAgICB9LFxuXG4gICAgcmVzZXRMaW5lczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubGluZV9jb25maWcgPSBbXTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5vcHRpb25zLm51bV9saW5lczsgaSsrKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5saW5lX2NvbmZpZy5wdXNoKHt2aXNpYmxlOiB0cnVlfSk7XG4gICAgICB9XG4gICAgICB0aGlzLmhlaWdodCA9ICh0aGlzLm9wdGlvbnMubnVtX2xpbmVzICsgdGhpcy5vcHRpb25zLnNwYWNlX2Fib3ZlX3N0YWZmX2xuKSAqXG4gICAgICAgICB0aGlzLm9wdGlvbnMuc3BhY2luZ19iZXR3ZWVuX2xpbmVzX3B4O1xuICAgICAgdGhpcy5vcHRpb25zLmJvdHRvbV90ZXh0X3Bvc2l0aW9uID0gdGhpcy5vcHRpb25zLm51bV9saW5lcyArIDE7XG4gICAgfSxcblxuICAgIHNldE5vdGVTdGFydFg6IGZ1bmN0aW9uKHgpIHsgdGhpcy5zdGFydF94ID0geDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgZ2V0Tm90ZVN0YXJ0WDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhcnRfeCA9IHRoaXMuc3RhcnRfeDtcblxuICAgICAgLy8gQWRkIGFkZGl0aW9uYWwgc3BhY2UgaWYgbGVmdCBiYXJsaW5lIGlzIFJFUEVBVF9CRUdJTiBhbmQgdGhlcmUgYXJlIG90aGVyXG4gICAgICAvLyBzdGFydCBtb2RpZmllcnMgdGhhbiBiYXJsaW5lc1xuICAgICAgaWYgKHRoaXMubW9kaWZpZXJzWzBdLmJhcmxpbmUgPT0gVmV4LkZsb3cuQmFybGluZS50eXBlLlJFUEVBVF9CRUdJTiAmJlxuICAgICAgICAgIHRoaXMubW9kaWZpZXJzLmxlbmd0aCA+IDIpIHtcbiAgICAgICAgc3RhcnRfeCArPSAyMDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0YXJ0X3g7XG4gICAgfSxcblxuICAgIGdldE5vdGVFbmRYOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZW5kX3g7IH0sXG4gICAgZ2V0VGllU3RhcnRYOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc3RhcnRfeDsgfSxcbiAgICBnZXRUaWVFbmRYOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueCArIHRoaXMud2lkdGg7IH0sXG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcblx0Zm9yKHZhciBpPTA7IGk8dGhpcy5nbHlwaHMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgIGlmKHR5cGVvZih0aGlzLmdseXBoc1tpXS5zZXRDb250ZXh0KSA9PT0gXCJmdW5jdGlvblwiKXtcblx0ICAgIHRoaXMuZ2x5cGhzW2ldLnNldENvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgfVxuXHR9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0OyB9LFxuICAgIGdldFg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy54OyB9LFxuICAgIGdldE51bUxpbmVzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMub3B0aW9ucy5udW1fbGluZXM7IH0sXG4gICAgc2V0TnVtTGluZXM6IGZ1bmN0aW9uKGxpbmVzKSB7XG4gICAgICB0aGlzLm9wdGlvbnMubnVtX2xpbmVzID0gcGFyc2VJbnQobGluZXMsIDEwKTtcbiAgICAgIHRoaXMucmVzZXRMaW5lcygpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBzZXRZOiBmdW5jdGlvbih5KSB7IHRoaXMueSA9IHk7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgc2V0WDogZnVuY3Rpb24oeCl7XG4gICAgICB2YXIgc2hpZnQgPSB4IC0gdGhpcy54O1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMuZ2x5cGhfc3RhcnRfeCArPSBzaGlmdDtcbiAgICAgIHRoaXMuZ2x5cGhfZW5kX3ggKz0gc2hpZnQ7XG4gICAgICB0aGlzLnN0YXJ0X3ggKz0gc2hpZnQ7XG4gICAgICB0aGlzLmVuZF94ICs9IHNoaWZ0O1xuICAgICAgZm9yKHZhciBpPTA7IGk8dGhpcy5tb2RpZmllcnMubGVuZ3RoOyBpKyspIHtcbiAgICAgIFx0dmFyIG1vZCA9IHRoaXMubW9kaWZpZXJzW2ldO1xuICAgICAgICBpZiAobW9kLnggIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIG1vZC54ICs9IHNoaWZ0O1xuICAgICAgXHR9XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0V2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmdseXBoX2VuZF94ID0gdGhpcy54ICsgd2lkdGg7XG4gICAgICB0aGlzLmVuZF94ID0gdGhpcy5nbHlwaF9lbmRfeDtcblxuICAgICAgLy8gcmVzZXQgdGhlIHggcG9zaXRpb24gb2YgdGhlIGVuZCBiYXJsaW5lIChUT0RPKDB4ZmUpOiBUaGlzIG1ha2VzIG5vIHNlbnNlKVxuICAgICAgLy8gdGhpcy5tb2RpZmllcnNbMV0uc2V0WCh0aGlzLmVuZF94KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9LFxuXG4gICAgc2V0TWVhc3VyZTogZnVuY3Rpb24obWVhc3VyZSkgeyB0aGlzLm1lYXN1cmUgPSBtZWFzdXJlOyByZXR1cm4gdGhpczsgfSxcblxuICAgICAgLy8gQmFyIExpbmUgZnVuY3Rpb25zXG4gICAgc2V0QmVnQmFyVHlwZTogZnVuY3Rpb24odHlwZSkge1xuICAgICAgLy8gT25seSB2YWxpZCBiYXIgdHlwZXMgYXQgYmVnaW5uaW5nIG9mIHN0YXZlIGlzIG5vbmUsIHNpbmdsZSBvciBiZWdpbiByZXBlYXRcbiAgICAgIGlmICh0eXBlID09IFZleC5GbG93LkJhcmxpbmUudHlwZS5TSU5HTEUgfHxcbiAgICAgICAgICB0eXBlID09IFZleC5GbG93LkJhcmxpbmUudHlwZS5SRVBFQVRfQkVHSU4gfHxcbiAgICAgICAgICB0eXBlID09IFZleC5GbG93LkJhcmxpbmUudHlwZS5OT05FKSB7XG4gICAgICAgICAgdGhpcy5tb2RpZmllcnNbMF0gPSBuZXcgVmV4LkZsb3cuQmFybGluZSh0eXBlLCB0aGlzLngpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEVuZEJhclR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIC8vIFJlcGVhdCBlbmQgbm90IHZhbGlkIGF0IGVuZCBvZiBzdGF2ZVxuICAgICAgaWYgKHR5cGUgIT0gVmV4LkZsb3cuQmFybGluZS50eXBlLlJFUEVBVF9CRUdJTilcbiAgICAgICAgdGhpcy5tb2RpZmllcnNbMV0gPSBuZXcgVmV4LkZsb3cuQmFybGluZSh0eXBlLCB0aGlzLnggKyB0aGlzLndpZHRoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXRzIHRoZSBwaXhlbHMgdG8gc2hpZnQgZnJvbSB0aGUgYmVnaW5uaW5nIG9mIHRoZSBzdGF2ZVxuICAgICAqIGZvbGxvd2luZyB0aGUgbW9kaWZpZXIgYXQgdGhlIHByb3ZpZGVkIGluZGV4XG4gICAgICogQHBhcmFtICB7TnVtYmVyfSBpbmRleCBUaGUgaW5kZXggZnJvbSB3aGljaCB0byBkZXRlcm1pbmUgdGhlIHNoaWZ0XG4gICAgICogQHJldHVybiB7TnVtYmVyfSAgICAgICBUaGUgYW1vdW50IG9mIHBpeGVscyBzaGlmdGVkXG4gICAgICovXG4gICAgZ2V0TW9kaWZpZXJYU2hpZnQ6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ID09PSAndW5kZWZpbmVkJykgaW5kZXggPSB0aGlzLmdseXBocy5sZW5ndGggLTE7XG4gICAgICBpZiAodHlwZW9mIGluZGV4ICE9PSAnbnVtYmVyJykgbmV3IFZleC5SRVJSKFwiSW52YWxpZEluZGV4XCIsXG4gICAgICAgIFwiTXVzdCBiZSBvZiBudW1iZXIgdHlwZVwiKTtcblxuICAgICAgdmFyIHggPSB0aGlzLmdseXBoX3N0YXJ0X3g7XG4gICAgICB2YXIgYmFyX3hfc2hpZnQgPSAwO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGluZGV4ICsgMTsgKytpKSB7XG4gICAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2x5cGhzW2ldO1xuICAgICAgICB4ICs9IGdseXBoLmdldE1ldHJpY3MoKS53aWR0aDtcbiAgICAgICAgYmFyX3hfc2hpZnQgKz0gZ2x5cGguZ2V0TWV0cmljcygpLndpZHRoO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgcGFkZGluZyBhZnRlciBjbGVmLCB0aW1lIHNpZywga2V5IHNpZ1xuICAgICAgaWYgKGJhcl94X3NoaWZ0ID4gMCkgYmFyX3hfc2hpZnQgKz0gdGhpcy5vcHRpb25zLnZlcnRpY2FsX2Jhcl93aWR0aCArIDEwO1xuXG4gICAgICByZXR1cm4gYmFyX3hfc2hpZnQ7XG4gICAgfSxcblxuICAgIC8vIENvZGEgJiBTZWdubyBTeW1ib2wgZnVuY3Rpb25zXG4gICAgc2V0UmVwZXRpdGlvblR5cGVMZWZ0OiBmdW5jdGlvbih0eXBlLCB5KSB7XG4gICAgICB0aGlzLm1vZGlmaWVycy5wdXNoKG5ldyBWZXguRmxvdy5SZXBldGl0aW9uKHR5cGUsIHRoaXMueCwgeSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFJlcGV0aXRpb25UeXBlUmlnaHQ6IGZ1bmN0aW9uKHR5cGUsIHkpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobmV3IFZleC5GbG93LlJlcGV0aXRpb24odHlwZSwgdGhpcy54LCB5KSApO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFZvbHRhIGZ1bmN0aW9uc1xuICAgIHNldFZvbHRhVHlwZTogZnVuY3Rpb24odHlwZSwgbnVtYmVyX3QsIHkpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobmV3IFZleC5GbG93LlZvbHRhKHR5cGUsIG51bWJlcl90LCB0aGlzLngsIHkpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZWN0aW9uIGZ1bmN0aW9uc1xuICAgIHNldFNlY3Rpb246IGZ1bmN0aW9uKHNlY3Rpb24sIHkpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobmV3IFZleC5GbG93LlN0YXZlU2VjdGlvbihzZWN0aW9uLCB0aGlzLngsIHkpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUZW1wbyBmdW5jdGlvbnNcbiAgICBzZXRUZW1wbzogZnVuY3Rpb24odGVtcG8sIHkpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobmV3IFZleC5GbG93LlN0YXZlVGVtcG8odGVtcG8sIHRoaXMueCwgeSkpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRleHQgZnVuY3Rpb25zXG4gICAgc2V0VGV4dDogZnVuY3Rpb24odGV4dCwgcG9zaXRpb24sIG9wdGlvbnMpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobmV3IFZleC5GbG93LlN0YXZlVGV4dCh0ZXh0LCBwb3NpdGlvbiwgb3B0aW9ucykpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldEhlaWdodDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5oZWlnaHQ7XG4gICAgfSxcblxuICAgIGdldFNwYWNpbmdCZXR3ZWVuTGluZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zcGFjaW5nX2JldHdlZW5fbGluZXNfcHg7XG4gICAgfSxcblxuICAgIGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBuZXcgVmV4LkZsb3cuQm91bmRpbmdCb3godGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuZ2V0Qm90dG9tWSgpIC0gdGhpcy55KTtcbiAgICAgIC8vIGJvZHkuLi5cbiAgICB9LFxuXG4gICAgZ2V0Qm90dG9tWTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBzcGFjaW5nID0gb3B0aW9ucy5zcGFjaW5nX2JldHdlZW5fbGluZXNfcHg7XG4gICAgICB2YXIgc2NvcmVfYm90dG9tID0gdGhpcy5nZXRZRm9yTGluZShvcHRpb25zLm51bV9saW5lcykgK1xuICAgICAgICAgKG9wdGlvbnMuc3BhY2VfYmVsb3dfc3RhZmZfbG4gKiBzcGFjaW5nKTtcblxuICAgICAgcmV0dXJuIHNjb3JlX2JvdHRvbTtcbiAgICB9LFxuXG4gICAgZ2V0Qm90dG9tTGluZVk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0WUZvckxpbmUodGhpcy5vcHRpb25zLm51bV9saW5lcyk7XG4gICAgfSxcblxuICAgIGdldFlGb3JMaW5lOiBmdW5jdGlvbihsaW5lKSB7XG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMub3B0aW9ucztcbiAgICAgIHZhciBzcGFjaW5nID0gb3B0aW9ucy5zcGFjaW5nX2JldHdlZW5fbGluZXNfcHg7XG4gICAgICB2YXIgaGVhZHJvb20gPSBvcHRpb25zLnNwYWNlX2Fib3ZlX3N0YWZmX2xuO1xuXG4gICAgICB2YXIgeSA9IHRoaXMueSArICgobGluZSAqIHNwYWNpbmcpICsgKGhlYWRyb29tICogc3BhY2luZykpIC1cbiAgICAgICAgKFRISUNLTkVTUyAvIDIpO1xuXG4gICAgICByZXR1cm4geTtcbiAgICB9LFxuXG4gICAgZ2V0WUZvclRvcFRleHQ6IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBsID0gbGluZSB8fCAwO1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0WUZvckxpbmUoLWwgLSB0aGlzLm9wdGlvbnMudG9wX3RleHRfcG9zaXRpb24pO1xuICAgIH0sXG5cbiAgICBnZXRZRm9yQm90dG9tVGV4dDogZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIGwgPSBsaW5lIHx8IDA7XG4gICAgICByZXR1cm4gdGhpcy5nZXRZRm9yTGluZSh0aGlzLm9wdGlvbnMuYm90dG9tX3RleHRfcG9zaXRpb24gKyBsKTtcbiAgICB9LFxuXG4gICAgZ2V0WUZvck5vdGU6IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIHNwYWNpbmcgPSBvcHRpb25zLnNwYWNpbmdfYmV0d2Vlbl9saW5lc19weDtcbiAgICAgIHZhciBoZWFkcm9vbSA9IG9wdGlvbnMuc3BhY2VfYWJvdmVfc3RhZmZfbG47XG4gICAgICB2YXIgeSA9IHRoaXMueSArIChoZWFkcm9vbSAqIHNwYWNpbmcpICsgKDUgKiBzcGFjaW5nKSAtIChsaW5lICogc3BhY2luZyk7XG5cbiAgICAgIHJldHVybiB5O1xuICAgIH0sXG5cbiAgICBnZXRZRm9yR2x5cGhzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFlGb3JMaW5lKDMpO1xuICAgIH0sXG5cbiAgICBhZGRHbHlwaDogZnVuY3Rpb24oZ2x5cGgpIHtcbiAgICAgIGdseXBoLnNldFN0YXZlKHRoaXMpO1xuICAgICAgdGhpcy5nbHlwaHMucHVzaChnbHlwaCk7XG4gICAgICB0aGlzLnN0YXJ0X3ggKz0gZ2x5cGguZ2V0TWV0cmljcygpLndpZHRoO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFkZEVuZEdseXBoOiBmdW5jdGlvbihnbHlwaCkge1xuICAgICAgZ2x5cGguc2V0U3RhdmUodGhpcyk7XG4gICAgICB0aGlzLmVuZF9nbHlwaHMucHVzaChnbHlwaCk7XG4gICAgICB0aGlzLmVuZF94IC09IGdseXBoLmdldE1ldHJpY3MoKS53aWR0aDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhZGRNb2RpZmllcjogZnVuY3Rpb24obW9kaWZpZXIpIHtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgbW9kaWZpZXIuYWRkVG9TdGF2ZSh0aGlzLCAodGhpcy5nbHlwaHMubGVuZ3RoID09PSAwKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYWRkRW5kTW9kaWZpZXI6IGZ1bmN0aW9uKG1vZGlmaWVyKSB7XG4gICAgICB0aGlzLm1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgIG1vZGlmaWVyLmFkZFRvU3RhdmVFbmQodGhpcywgKHRoaXMuZW5kX2dseXBocy5sZW5ndGggPT09IDApKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhZGRLZXlTaWduYXR1cmU6IGZ1bmN0aW9uKGtleVNwZWMpIHtcbiAgICAgIHRoaXMuYWRkTW9kaWZpZXIobmV3IFZleC5GbG93LktleVNpZ25hdHVyZShrZXlTcGVjKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYWRkQ2xlZjogZnVuY3Rpb24oY2xlZiwgc2l6ZSwgYW5ub3RhdGlvbikge1xuICAgICAgdGhpcy5jbGVmID0gY2xlZjtcbiAgICAgIHRoaXMuYWRkTW9kaWZpZXIobmV3IFZleC5GbG93LkNsZWYoY2xlZiwgc2l6ZSwgYW5ub3RhdGlvbikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFkZEVuZENsZWY6IGZ1bmN0aW9uKGNsZWYsIHNpemUsIGFubm90YXRpb24pIHtcbiAgICAgIHRoaXMuYWRkRW5kTW9kaWZpZXIobmV3IFZleC5GbG93LkNsZWYoY2xlZiwgc2l6ZSwgYW5ub3RhdGlvbikpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFkZFRpbWVTaWduYXR1cmU6IGZ1bmN0aW9uKHRpbWVTcGVjLCBjdXN0b21QYWRkaW5nKSB7XG4gICAgICB0aGlzLmFkZE1vZGlmaWVyKG5ldyBWZXguRmxvdy5UaW1lU2lnbmF0dXJlKHRpbWVTcGVjLCBjdXN0b21QYWRkaW5nKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgYWRkRW5kVGltZVNpZ25hdHVyZTogZnVuY3Rpb24odGltZVNwZWMsIGN1c3RvbVBhZGRpbmcpIHtcbiAgICAgIHRoaXMuYWRkRW5kTW9kaWZpZXIobmV3IFZleC5GbG93LlRpbWVTaWduYXR1cmUodGltZVNwZWMsIGN1c3RvbVBhZGRpbmcpKTtcbiAgICB9LFxuXG4gICAgYWRkVHJlYmxlR2x5cGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5jbGVmID0gXCJ0cmVibGVcIjtcbiAgICAgIHRoaXMuYWRkR2x5cGgobmV3IFZleC5GbG93LkdseXBoKFwidjgzXCIsIDQwKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQWxsIGRyYXdpbmcgZnVuY3Rpb25zIGJlbG93IG5lZWQgdGhlIGNvbnRleHQgdG8gYmUgc2V0LlxuICAgICAqL1xuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ2FudmFzQ29udGV4dFwiLFxuICAgICAgICAgIFwiQ2FuJ3QgZHJhdyBzdGF2ZSB3aXRob3V0IGNhbnZhcyBjb250ZXh0LlwiKTtcblxuICAgICAgdmFyIG51bV9saW5lcyA9IHRoaXMub3B0aW9ucy5udW1fbGluZXM7XG4gICAgICB2YXIgd2lkdGggPSB0aGlzLndpZHRoO1xuICAgICAgdmFyIHggPSB0aGlzLng7XG4gICAgICB2YXIgeTtcbiAgICAgIHZhciBnbHlwaDtcblxuICAgICAgLy8gUmVuZGVyIGxpbmVzXG4gICAgICBmb3IgKHZhciBsaW5lPTA7IGxpbmUgPCBudW1fbGluZXM7IGxpbmUrKykge1xuICAgICAgICB5ID0gdGhpcy5nZXRZRm9yTGluZShsaW5lKTtcblxuICAgICAgICB0aGlzLmNvbnRleHQuc2F2ZSgpO1xuICAgICAgICB0aGlzLmNvbnRleHQuc2V0RmlsbFN0eWxlKHRoaXMub3B0aW9ucy5maWxsX3N0eWxlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnNldFN0cm9rZVN0eWxlKHRoaXMub3B0aW9ucy5maWxsX3N0eWxlKTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5saW5lX2NvbmZpZ1tsaW5lXS52aXNpYmxlKSB7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KHgsIHksIHdpZHRoLCBWZXguRmxvdy5TVEFWRV9MSU5FX1RISUNLTkVTUyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIGdseXBoc1xuICAgICAgeCA9IHRoaXMuZ2x5cGhfc3RhcnRfeDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5nbHlwaHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZ2x5cGggPSB0aGlzLmdseXBoc1tpXTtcbiAgICAgICAgaWYgKCFnbHlwaC5nZXRDb250ZXh0KCkpIHtcbiAgICAgICAgICBnbHlwaC5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIH1cbiAgICAgICAgZ2x5cGgucmVuZGVyVG9TdGF2ZSh4KTtcbiAgICAgICAgeCArPSBnbHlwaC5nZXRNZXRyaWNzKCkud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbmRlciBlbmQgZ2x5cGhzXG4gICAgICB4ID0gdGhpcy5nbHlwaF9lbmRfeDtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmVuZF9nbHlwaHMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgZ2x5cGggPSB0aGlzLmVuZF9nbHlwaHNbaV07XG4gICAgICAgIGlmICghZ2x5cGguZ2V0Q29udGV4dCgpKSB7XG4gICAgICAgICAgZ2x5cGguc2V0Q29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgICAgICB9XG4gICAgICAgIHggLT0gZ2x5cGguZ2V0TWV0cmljcygpLndpZHRoO1xuICAgICAgICBnbHlwaC5yZW5kZXJUb1N0YXZlKHgpO1xuICAgICAgfVxuXG4gICAgICAvLyBEcmF3IHRoZSBtb2RpZmllcnMgKGJhciBsaW5lcywgY29kYSwgc2Vnbm8sIHJlcGVhdCBicmFja2V0cywgZXRjLilcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLm1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAvLyBPbmx5IGRyYXcgbW9kaWZpZXIgaWYgaXQgaGFzIGEgZHJhdyBmdW5jdGlvblxuICAgICAgICBpZiAodHlwZW9mIHRoaXMubW9kaWZpZXJzW2ldLmRyYXcgPT0gXCJmdW5jdGlvblwiKVxuICAgICAgICAgIHRoaXMubW9kaWZpZXJzW2ldLmRyYXcodGhpcywgdGhpcy5nZXRNb2RpZmllclhTaGlmdCgpKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIG1lYXN1cmUgbnVtYmVyc1xuICAgICAgaWYgKHRoaXMubWVhc3VyZSA+IDApIHtcbiAgICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnNldEZvbnQodGhpcy5mb250LmZhbWlseSwgdGhpcy5mb250LnNpemUsIHRoaXMuZm9udC53ZWlnaHQpO1xuICAgICAgICB2YXIgdGV4dF93aWR0aCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dChcIlwiICsgdGhpcy5tZWFzdXJlKS53aWR0aDtcbiAgICAgICAgeSA9IHRoaXMuZ2V0WUZvclRvcFRleHQoMCkgKyAzO1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFRleHQoXCJcIiArIHRoaXMubWVhc3VyZSwgdGhpcy54IC0gdGV4dF93aWR0aCAvIDIsIHkpO1xuICAgICAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRHJhdyBTaW1wbGUgYmFybGluZXMgZm9yIGJhY2t3YXJkIGNvbXBhdGFiaWxpdHlcbiAgICAvLyBEbyBub3QgZGVsZXRlIC0gZHJhd3MgdGhlIGJlZ2lubmluZyBiYXIgb2YgdGhlIHN0YXZlXG4gICAgZHJhd1ZlcnRpY2FsOiBmdW5jdGlvbih4LCBpc0RvdWJsZSkge1xuICAgICAgdGhpcy5kcmF3VmVydGljYWxGaXhlZCh0aGlzLnggKyB4LCBpc0RvdWJsZSk7XG4gICAgfSxcblxuICAgIGRyYXdWZXJ0aWNhbEZpeGVkOiBmdW5jdGlvbih4LCBpc0RvdWJsZSkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ2FudmFzQ29udGV4dFwiLFxuICAgICAgICAgIFwiQ2FuJ3QgZHJhdyBzdGF2ZSB3aXRob3V0IGNhbnZhcyBjb250ZXh0LlwiKTtcblxuICAgICAgdmFyIHRvcF9saW5lID0gdGhpcy5nZXRZRm9yTGluZSgwKTtcbiAgICAgIHZhciBib3R0b21fbGluZSA9IHRoaXMuZ2V0WUZvckxpbmUodGhpcy5vcHRpb25zLm51bV9saW5lcyAtIDEpO1xuICAgICAgaWYgKGlzRG91YmxlKVxuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoeCAtIDMsIHRvcF9saW5lLCAxLCBib3R0b21fbGluZSAtIHRvcF9saW5lICsgMSk7XG4gICAgICB0aGlzLmNvbnRleHQuZmlsbFJlY3QoeCwgdG9wX2xpbmUsIDEsIGJvdHRvbV9saW5lIC0gdG9wX2xpbmUgKyAxKTtcbiAgICB9LFxuXG4gICAgZHJhd1ZlcnRpY2FsQmFyOiBmdW5jdGlvbih4KSB7XG4gICAgICB0aGlzLmRyYXdWZXJ0aWNhbEJhckZpeGVkKHRoaXMueCArIHgsIGZhbHNlKTtcbiAgICB9LFxuXG4gICAgZHJhd1ZlcnRpY2FsQmFyRml4ZWQ6IGZ1bmN0aW9uKHgpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgc3RhdmUgd2l0aG91dCBjYW52YXMgY29udGV4dC5cIik7XG5cbiAgICAgIHZhciB0b3BfbGluZSA9IHRoaXMuZ2V0WUZvckxpbmUoMCk7XG4gICAgICB2YXIgYm90dG9tX2xpbmUgPSB0aGlzLmdldFlGb3JMaW5lKHRoaXMub3B0aW9ucy5udW1fbGluZXMgLSAxKTtcbiAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCh4LCB0b3BfbGluZSwgMSwgYm90dG9tX2xpbmUgLSB0b3BfbGluZSArIDEpO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGN1cnJlbnQgY29uZmlndXJhdGlvbiBmb3IgdGhlIFN0YXZlLlxuICAgICAqIEByZXR1cm4ge0FycmF5fSBBbiBhcnJheSBvZiBjb25maWd1cmF0aW9uIG9iamVjdHMuXG4gICAgICovXG4gICAgZ2V0Q29uZmlnRm9yTGluZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5saW5lX2NvbmZpZztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogQ29uZmlndXJlIHByb3BlcnRpZXMgb2YgdGhlIGxpbmVzIGluIHRoZSBTdGF2ZVxuICAgICAqIEBwYXJhbSBsaW5lX251bWJlciBUaGUgaW5kZXggb2YgdGhlIGxpbmUgdG8gY29uZmlndXJlLlxuICAgICAqIEBwYXJhbSBsaW5lX2NvbmZpZyBBbiBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBsaW5lLlxuICAgICAqIEB0aHJvd3MgVmV4LlJFUlIgXCJTdGF2ZUNvbmZpZ0Vycm9yXCIgV2hlbiB0aGUgc3BlY2lmaWVkIGxpbmUgbnVtYmVyIGlzIG91dCBvZlxuICAgICAqICAgcmFuZ2Ugb2YgdGhlIG51bWJlciBvZiBsaW5lcyBzcGVjaWZpZWQgaW4gdGhlIGNvbnN0cnVjdG9yLlxuICAgICAqL1xuICAgIHNldENvbmZpZ0ZvckxpbmU6IGZ1bmN0aW9uKGxpbmVfbnVtYmVyLCBsaW5lX2NvbmZpZykge1xuICAgICAgaWYgKGxpbmVfbnVtYmVyID49IHRoaXMub3B0aW9ucy5udW1fbGluZXMgfHwgbGluZV9udW1iZXIgPCAwKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIlN0YXZlQ29uZmlnRXJyb3JcIixcbiAgICAgICAgICBcIlRoZSBsaW5lIG51bWJlciBtdXN0IGJlIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgdGhlIG51bWJlciBvZiBsaW5lcyBpbiB0aGUgU3RhdmUuXCIpO1xuICAgICAgfVxuICAgICAgaWYgKCFsaW5lX2NvbmZpZy5oYXNPd25Qcm9wZXJ0eSgndmlzaWJsZScpKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIlN0YXZlQ29uZmlnRXJyb3JcIixcbiAgICAgICAgICBcIlRoZSBsaW5lIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGlzIG1pc3NpbmcgdGhlICd2aXNpYmxlJyBwcm9wZXJ0eS5cIik7XG4gICAgICB9XG4gICAgICBpZiAodHlwZW9mKGxpbmVfY29uZmlnLnZpc2libGUpICE9PSAnYm9vbGVhbicpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiU3RhdmVDb25maWdFcnJvclwiLFxuICAgICAgICAgIFwiVGhlIGxpbmUgY29uZmlndXJhdGlvbiBvYmplY3RzICd2aXNpYmxlJyBwcm9wZXJ0eSBtdXN0IGJlIHRydWUgb3IgZmFsc2UuXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm9wdGlvbnMubGluZV9jb25maWdbbGluZV9udW1iZXJdID0gbGluZV9jb25maWc7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBTZXQgdGhlIHN0YWZmIGxpbmUgY29uZmlndXJhdGlvbiBhcnJheSBmb3IgYWxsIG9mIHRoZSBsaW5lcyBhdCBvbmNlLlxuICAgICAqIEBwYXJhbSBsaW5lc19jb25maWd1cmF0aW9uIEFuIGFycmF5IG9mIGxpbmUgY29uZmlndXJhdGlvbiBvYmplY3RzLiAgVGhlc2Ugb2JqZWN0c1xuICAgICAqICAgYXJlIG9mIHRoZSBzYW1lIGZvcm1hdCBhcyB0aGUgc2luZ2xlIG9uZSBwYXNzZWQgaW4gdG8gc2V0TGluZUNvbmZpZ3VyYXRpb24oKS5cbiAgICAgKiAgIFRoZSBjYWxsZXIgY2FuIHNldCBudWxsIGZvciBhbnkgbGluZSBjb25maWcgZW50cnkgaWYgaXQgaXMgZGVzaXJlZCB0aGF0IHRoZSBkZWZhdWx0IGJlIHVzZWRcbiAgICAgKiBAdGhyb3dzIFZleC5SRVJSIFwiU3RhdmVDb25maWdFcnJvclwiIFdoZW4gdGhlIGxpbmVzX2NvbmZpZ3VyYXRpb24gYXJyYXkgZG9lcyBub3QgaGF2ZVxuICAgICAqICAgZXhhY3RseSB0aGUgc2FtZSBudW1iZXIgb2YgZWxlbWVudHMgYXMgdGhlIG51bV9saW5lcyBjb25maWd1cmF0aW9uIG9iamVjdCBzZXQgaW5cbiAgICAgKiAgIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgKi9cbiAgICBzZXRDb25maWdGb3JMaW5lczogZnVuY3Rpb24obGluZXNfY29uZmlndXJhdGlvbikge1xuICAgICAgaWYgKGxpbmVzX2NvbmZpZ3VyYXRpb24ubGVuZ3RoICE9PSB0aGlzLm9wdGlvbnMubnVtX2xpbmVzKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIlN0YXZlQ29uZmlnRXJyb3JcIixcbiAgICAgICAgICBcIlRoZSBsZW5ndGggb2YgdGhlIGxpbmVzIGNvbmZpZ3VyYXRpb24gYXJyYXkgbXVzdCBtYXRjaCB0aGUgbnVtYmVyIG9mIGxpbmVzIGluIHRoZSBTdGF2ZVwiKTtcbiAgICAgIH1cblxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBkZWZhdWx0cyBhcmUgcHJlc2VudCBpbiBjYXNlIGFuIGluY29tcGxldGUgc2V0IG9mXG4gICAgICAvLyAgY29uZmlndXJhdGlvbiBvcHRpb25zIHdlcmUgc3VwcGxpZWQuXG4gICAgICBmb3IgKHZhciBsaW5lX2NvbmZpZyBpbiBsaW5lc19jb25maWd1cmF0aW9uKSB7XG4gICAgICAgIC8vIEFsbG93ICdudWxsJyB0byBiZSB1c2VkIGlmIHRoZSBjYWxsZXIganVzdCB3YW50cyB0aGUgZGVmYXVsdCBmb3IgYSBwYXJ0aWN1bGFyIG5vZGUuXG4gICAgICAgIGlmICghbGluZXNfY29uZmlndXJhdGlvbltsaW5lX2NvbmZpZ10pIHtcbiAgICAgICAgICBsaW5lc19jb25maWd1cmF0aW9uW2xpbmVfY29uZmlnXSA9IHRoaXMub3B0aW9ucy5saW5lX2NvbmZpZ1tsaW5lX2NvbmZpZ107XG4gICAgICAgIH1cbiAgICAgICAgVmV4Lk1lcmdlKHRoaXMub3B0aW9ucy5saW5lX2NvbmZpZ1tsaW5lX2NvbmZpZ10sIGxpbmVzX2NvbmZpZ3VyYXRpb25bbGluZV9jb25maWddKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zLmxpbmVfY29uZmlnID0gbGluZXNfY29uZmlndXJhdGlvbjtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBTdGF2ZTtcbn0oKSk7XG5cbi8vIFZleCBGbG93XG4vLyBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy8gU3BlbmNlciBIaXRjaGNvY2sgPHNwZW5jZXJoaXRjaEBnbWFpbC5jb20+XG4vLyBBIHN1cGVyY2xhc3MgZm9yIHN0YXZlcywgdGhpcyB3aWxsIGFsbG93IG11bHRpcGxlIGluc3RydW1lbnRzIHRvIGJlIHNjb3JlZCBhdCBvbmNlXG5cbi8qKiBAY29uc3RydWN0b3IgKi9cblZleC5GbG93LlN0YXZlR3JvdXAgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFN0YXZlR3JvdXAoeCwgeSwgd2lkdGgsIG9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdCh4LCB5LCB3aWR0aCwgb3B0aW9ucyk7XG4gIH1cblxuICBTdGF2ZUdyb3VwLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgb3B0aW9ucykge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmNvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy5zdGF2ZXMgPSBbXTtcbiAgICAgIHRoaXMuZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiBcInNhbnMtc2VyaWZcIixcbiAgICAgICAgc2l6ZTogOCxcbiAgICAgICAgd2VpZ2h0OiBcIlwiXG4gICAgICB9O1xuICAgICAgdGhpcy5vcHRpb25zID0ge1xuICAgICAgICBzcGFjaW5nX2JldHdlZW5fc3RhdmVzX3B4OiA2MCxcbiAgICAgICAgc3BhY2VfYWJvdmVfc3RhdmVncm91cDogNCwgICAgICAvLyBpbiBzdGFmZiBsaW5lc1xuICAgICAgICBzcGFjZV9iZWxvd19zdGF2ZWdyb3VwOiA0ICAgICAgLy8gaW4gc3RhZmYgbGluZXNcbiAgICAgIH07XG4gICAgICB0aGlzLmJvdW5kcyA9IHt4OiB0aGlzLngsIHk6IHRoaXMueSwgdzogdGhpcy53aWR0aCwgaDogMH07XG4gICAgLy8gIFZleC5NZXJnZSh0aGlzLm9wdGlvbnMsIG9wdGlvbnMpO1xuXG4gICAgICB0aGlzLnJlc2V0U3RhdmVzKCk7XG4gICAgfSxcbiAgICBhZGRTdGF2ZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbnVtX3N0YXZlcyA9IHRoaXMuc3RhdmVzLmxlbmd0aDtcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICB2YXIgeCA9IHRoaXMueDtcbiAgICAgIHZhciB5ID0gdGhpcy5nZXRZRm9yU3RhdmUobnVtX3N0YXZlcyk7XG4gICAgICB0aGlzLnN0YXZlcy5wdXNoKG5ldyBWZXguRmxvdy5TdGF2ZSh4LHksd2lkdGgpKTtcbiAgICAgIHRoaXMucmVzZXRTdGF2ZXMoKTtcbiAgICB9LFxuXG4gICAgZ2V0U3RhdmU6IGZ1bmN0aW9uKGkpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdmVzW2ldO1xuICAgIH0sXG5cbiAgICByZXNldFN0YXZlczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm9wdGlvbnMuc3RhdmVfY29uZmlnID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuc3RhdmVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHRoaXMub3B0aW9ucy5zdGF2ZV9jb25maWcucHVzaCh7dmlzaWJsZTogdHJ1ZX0pO1xuICAgICAgfVxuICAgICAgdGhpcy5oZWlnaHQgPSAodGhpcy5zdGF2ZXMubGVuZ3RoICsgdGhpcy5vcHRpb25zLnNwYWNlX2Fib3ZlX3N0YXZlZ3JvdXApICpcbiAgICAgICAgIHRoaXMub3B0aW9ucy5zcGFjaW5nX2JldHdlZW5fc3RhdmVzX3B4O1xuICAgICAgdGhpcy5vcHRpb25zLmJvdHRvbV90ZXh0X3Bvc2l0aW9uID0gdGhpcy5zdGF2ZXMubGVuZ3RoICsgMTtcbiAgICB9LFxuXG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIGZvcih2YXIgaT0wOyBpPHRoaXMuc3RhdmVzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGlmKHR5cGVvZih0aGlzLnN0YXZlc1tpXS5zZXRDb250ZXh0KSA9PT0gXCJmdW5jdGlvblwiKXtcbiAgICAgICAgICB0aGlzLnN0YXZlc1tpXS5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY29udGV4dDsgfSxcbiAgICBnZXRYOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMueDsgfSxcbiAgICBnZXROdW1TdGF2ZXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zdGF2ZXMubGVuZ3RoOyB9LFxuICAgIHNldE51bVN0YXZlczogZnVuY3Rpb24oc3RhdmVzKSB7XG4gICAgICB0aGlzLnN0YXZlcy5sZW5ndGggPSBwYXJzZUludChzdGF2ZXMsIDEwKTtcbiAgICAgIHRoaXMucmVzZXRTdGF2ZXMoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgc2V0WTogZnVuY3Rpb24oeSkgeyB0aGlzLnkgPSB5OyByZXR1cm4gdGhpczsgfSxcblxuICAgIHNldFg6IGZ1bmN0aW9uKHgpe1xuICAgICAgdmFyIHNoaWZ0ID0geCAtIHRoaXMueDtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICBmb3IodmFyIGk9MDsgaTx0aGlzLm1vZGlmaWVycy5sZW5ndGg7IGkrKykge1xuICAgICAgXHR2YXIgbW9kID0gdGhpcy5tb2RpZmllcnNbaV07XG4gICAgICAgIGlmIChtb2QueCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgbW9kLnggKz0gc2hpZnQ7XG4gICAgICBcdH1cbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHtcbiAgICAgIHRoaXMud2lkdGggPSB3aWR0aDtcblxuICAgICAgLy8gcmVzZXQgdGhlIHggcG9zaXRpb24gb2YgdGhlIGVuZCBiYXJsaW5lIChUT0RPKDB4ZmUpOiBUaGlzIG1ha2VzIG5vIHNlbnNlKVxuICAgICAgLy8gdGhpcy5tb2RpZmllcnNbMV0uc2V0WCh0aGlzLmVuZF94KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9LFxuXG4gICAgc2V0TWVhc3VyZTogZnVuY3Rpb24obWVhc3VyZSkgeyB0aGlzLm1lYXN1cmUgPSBtZWFzdXJlOyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8qKlxuICAgICAqIEdldHMgdGhlIHBpeGVscyB0byBzaGlmdCBmcm9tIHRoZSBiZWdpbm5pbmcgb2YgdGhlIHN0YXZlXG4gICAgICogZm9sbG93aW5nIHRoZSBtb2RpZmllciBhdCB0aGUgcHJvdmlkZWQgaW5kZXhcbiAgICAgKiBAcGFyYW0gIHtOdW1iZXJ9IGluZGV4IFRoZSBpbmRleCBmcm9tIHdoaWNoIHRvIGRldGVybWluZSB0aGUgc2hpZnRcbiAgICAgKiBAcmV0dXJuIHtOdW1iZXJ9ICAgICAgIFRoZSBhbW91bnQgb2YgcGl4ZWxzIHNoaWZ0ZWRcbiAgICAgKi9cbiAgICBnZXRNb2RpZmllclhTaGlmdDogZnVuY3Rpb24oaW5kZXgpIHtcbiAgICAgIGlmICh0eXBlb2YgaW5kZXggPT09ICd1bmRlZmluZWQnKSBpbmRleCA9IHRoaXMuZ2x5cGhzLmxlbmd0aCAtMTtcbiAgICAgIGlmICh0eXBlb2YgaW5kZXggIT09ICdudW1iZXInKSBuZXcgVmV4LlJFUlIoXCJJbnZhbGlkSW5kZXhcIixcbiAgICAgICAgXCJNdXN0IGJlIG9mIG51bWJlciB0eXBlXCIpO1xuXG4gICAgICB2YXIgeCA9IHRoaXMuZ2x5cGhfc3RhcnRfeDtcbiAgICAgIHZhciBiYXJfeF9zaGlmdCA9IDA7XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXggKyAxOyArK2kpIHtcbiAgICAgICAgdmFyIGdseXBoID0gdGhpcy5nbHlwaHNbaV07XG4gICAgICAgIHggKz0gZ2x5cGguZ2V0TWV0cmljcygpLndpZHRoO1xuICAgICAgICBiYXJfeF9zaGlmdCArPSBnbHlwaC5nZXRNZXRyaWNzKCkud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBwYWRkaW5nIGFmdGVyIGNsZWYsIHRpbWUgc2lnLCBrZXkgc2lnXG4gICAgICBpZiAoYmFyX3hfc2hpZnQgPiAwKSBiYXJfeF9zaGlmdCArPSB0aGlzLm9wdGlvbnMudmVydGljYWxfYmFyX3dpZHRoICsgMTA7XG5cbiAgICAgIHJldHVybiBiYXJfeF9zaGlmdDtcbiAgICB9LFxuXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmhlaWdodDtcbiAgICB9LFxuXG4gICAgZ2V0U3BhY2luZ0JldHdlZW5TdGF2ZXM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5zcGFjaW5nX2JldHdlZW5fc3RhdmVzX3B4O1xuICAgIH0sXG5cbiAgICBnZXRCb3R0b21ZOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIHNwYWNpbmcgPSBvcHRpb25zLnNwYWNpbmdfYmV0d2Vlbl9zdGF2ZXNfcHg7XG4gICAgICB2YXIgc2NvcmVfYm90dG9tID0gdGhpcy5nZXRZRm9yTGluZShzdGF2ZXMubGVuZ3RoKSArXG4gICAgICAgICAob3B0aW9ucy5zcGFjZV9iZWxvd19zdGFmZl9sbiAqIHNwYWNpbmcpO1xuXG4gICAgICByZXR1cm4gc2NvcmVfYm90dG9tO1xuICAgIH0sXG5cbiAgICBnZXRCb3R0b21TdGF2ZVk6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0WUZvclN0YXZlKHRoaXMuc3RhdmVzLmxlbmd0aCk7XG4gICAgfSxcblxuICAgIGdldFlGb3JTdGF2ZTogZnVuY3Rpb24oc3RhdmVfaW5kZXgpIHtcbiAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgdmFyIHNwYWNpbmcgPSBvcHRpb25zLnNwYWNpbmdfYmV0d2Vlbl9zdGF2ZXNfcHg7XG5cbiAgICAgIHZhciB5ID0gdGhpcy55ICsgKHN0YXZlX2luZGV4ICogc3BhY2luZyk7XG5cbiAgICAgIHJldHVybiB5O1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBBbGwgZHJhd2luZyBmdW5jdGlvbnMgYmVsb3cgbmVlZCB0aGUgY29udGV4dCB0byBiZSBzZXQuXG4gICAgICovXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHN0YXZlIHdpdGhvdXQgY2FudmFzIGNvbnRleHQuXCIpO1xuXG4gICAgICB2YXIgbnVtX3N0YXZlcyA9IHRoaXMuc3RhdmVzLmxlbmd0aDtcblxuICAgICAgLy8gUmVuZGVyIHN0YXZlcyBcbiAgICAgIGZvciAodmFyIHN0YXZlX2luZGV4PTA7IHN0YXZlX2luZGV4IDwgbnVtX3N0YXZlczsgc3RhdmVfaW5kZXgrKykge1xuXG4gICAgICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XG4gICAgICAgIHZhciBzdGF2ZSA9IHRoaXMuZ2V0U3RhdmUoc3RhdmVfaW5kZXgpO1xuICAgICAgICBjb25zb2xlLmxvZyhzdGF2ZSk7XG4gICAgICAgIHN0YXZlLmRyYXcoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgLy8gUmVuZGVyIG1lYXN1cmUgbnVtYmVyc1xuLy8gICAgICBpZiAodGhpcy5tZWFzdXJlID4gMCkge1xuLy8gICAgICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XG4vLyAgICAgICAgdGhpcy5jb250ZXh0LnNldEZvbnQodGhpcy5mb250LmZhbWlseSwgdGhpcy5mb250LnNpemUsIHRoaXMuZm9udC53ZWlnaHQpO1xuLy8gICAgICAgIHZhciB0ZXh0X3dpZHRoID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KFwiXCIgKyB0aGlzLm1lYXN1cmUpLndpZHRoO1xuLy8gICAgICAgIHkgPSB0aGlzLmdldFlGb3JUb3BUZXh0KDApICsgMztcbi8vICAgICAgICB0aGlzLmNvbnRleHQuZmlsbFRleHQoXCJcIiArIHRoaXMubWVhc3VyZSwgdGhpcy54IC0gdGV4dF93aWR0aCAvIDIsIHkpO1xuLy8gICAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XG4vLyAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEdldCB0aGUgY3VycmVudCBjb25maWd1cmF0aW9uIGZvciB0aGUgU3RhdmUuXG4gICAgICogQHJldHVybiB7QXJyYXl9IEFuIGFycmF5IG9mIGNvbmZpZ3VyYXRpb24gb2JqZWN0cy5cbiAgICAgKi9cbi8vICAgIGdldENvbmZpZ0ZvckxpbmVzOiBmdW5jdGlvbigpIHtcbi8vICAgICAgcmV0dXJuIHRoaXMub3B0aW9ucy5saW5lX2NvbmZpZztcbi8vICAgIH0sXG4vL1xuLy8gICAgLyoqXG4vLyAgICAgKiBDb25maWd1cmUgcHJvcGVydGllcyBvZiB0aGUgbGluZXMgaW4gdGhlIFN0YXZlXG4vLyAgICAgKiBAcGFyYW0gbGluZV9udW1iZXIgVGhlIGluZGV4IG9mIHRoZSBsaW5lIHRvIGNvbmZpZ3VyZS5cbi8vICAgICAqIEBwYXJhbSBsaW5lX2NvbmZpZyBBbiBjb25maWd1cmF0aW9uIG9iamVjdCBmb3IgdGhlIHNwZWNpZmllZCBsaW5lLlxuLy8gICAgICogQHRocm93cyBWZXguUkVSUiBcIlN0YXZlQ29uZmlnRXJyb3JcIiBXaGVuIHRoZSBzcGVjaWZpZWQgbGluZSBudW1iZXIgaXMgb3V0IG9mXG4vLyAgICAgKiAgIHJhbmdlIG9mIHRoZSBudW1iZXIgb2YgbGluZXMgc3BlY2lmaWVkIGluIHRoZSBjb25zdHJ1Y3Rvci5cbi8vICAgICAqL1xuLy8gICAgc2V0Q29uZmlnRm9yTGluZTogZnVuY3Rpb24obGluZV9udW1iZXIsIGxpbmVfY29uZmlnKSB7XG4vLyAgICAgIGlmIChsaW5lX251bWJlciA+PSB0aGlzLm9wdGlvbnMubnVtX2xpbmVzIHx8IGxpbmVfbnVtYmVyIDwgMCkge1xuLy8gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIlN0YXZlQ29uZmlnRXJyb3JcIixcbi8vICAgICAgICAgIFwiVGhlIGxpbmUgbnVtYmVyIG11c3QgYmUgd2l0aGluIHRoZSByYW5nZSBvZiB0aGUgbnVtYmVyIG9mIGxpbmVzIGluIHRoZSBTdGF2ZS5cIik7XG4vLyAgICAgIH1cbi8vICAgICAgaWYgKCFsaW5lX2NvbmZpZy5oYXNPd25Qcm9wZXJ0eSgndmlzaWJsZScpKSB7XG4vLyAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiU3RhdmVDb25maWdFcnJvclwiLFxuLy8gICAgICAgICAgXCJUaGUgbGluZSBjb25maWd1cmF0aW9uIG9iamVjdCBpcyBtaXNzaW5nIHRoZSAndmlzaWJsZScgcHJvcGVydHkuXCIpO1xuLy8gICAgICB9XG4vLyAgICAgIGlmICh0eXBlb2YobGluZV9jb25maWcudmlzaWJsZSkgIT09ICdib29sZWFuJykge1xuLy8gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIlN0YXZlQ29uZmlnRXJyb3JcIixcbi8vICAgICAgICAgIFwiVGhlIGxpbmUgY29uZmlndXJhdGlvbiBvYmplY3RzICd2aXNpYmxlJyBwcm9wZXJ0eSBtdXN0IGJlIHRydWUgb3IgZmFsc2UuXCIpO1xuLy8gICAgICB9XG4vL1xuLy8gICAgICB0aGlzLm9wdGlvbnMubGluZV9jb25maWdbbGluZV9udW1iZXJdID0gbGluZV9jb25maWc7XG4vL1xuLy8gICAgICByZXR1cm4gdGhpcztcbi8vICAgIH0sXG4vL1xuLy8gICAgLyoqXG4vLyAgICAgKiBTZXQgdGhlIHN0YWZmIGxpbmUgY29uZmlndXJhdGlvbiBhcnJheSBmb3IgYWxsIG9mIHRoZSBsaW5lcyBhdCBvbmNlLlxuLy8gICAgICogQHBhcmFtIGxpbmVzX2NvbmZpZ3VyYXRpb24gQW4gYXJyYXkgb2YgbGluZSBjb25maWd1cmF0aW9uIG9iamVjdHMuICBUaGVzZSBvYmplY3RzXG4vLyAgICAgKiAgIGFyZSBvZiB0aGUgc2FtZSBmb3JtYXQgYXMgdGhlIHNpbmdsZSBvbmUgcGFzc2VkIGluIHRvIHNldExpbmVDb25maWd1cmF0aW9uKCkuXG4vLyAgICAgKiAgIFRoZSBjYWxsZXIgY2FuIHNldCBudWxsIGZvciBhbnkgbGluZSBjb25maWcgZW50cnkgaWYgaXQgaXMgZGVzaXJlZCB0aGF0IHRoZSBkZWZhdWx0IGJlIHVzZWRcbi8vICAgICAqIEB0aHJvd3MgVmV4LlJFUlIgXCJTdGF2ZUNvbmZpZ0Vycm9yXCIgV2hlbiB0aGUgbGluZXNfY29uZmlndXJhdGlvbiBhcnJheSBkb2VzIG5vdCBoYXZlXG4vLyAgICAgKiAgIGV4YWN0bHkgdGhlIHNhbWUgbnVtYmVyIG9mIGVsZW1lbnRzIGFzIHRoZSBudW1fbGluZXMgY29uZmlndXJhdGlvbiBvYmplY3Qgc2V0IGluXG4vLyAgICAgKiAgIHRoZSBjb25zdHJ1Y3Rvci5cbi8vICAgICAqL1xuLy8gICAgc2V0Q29uZmlnRm9yTGluZXM6IGZ1bmN0aW9uKGxpbmVzX2NvbmZpZ3VyYXRpb24pIHtcbi8vICAgICAgaWYgKGxpbmVzX2NvbmZpZ3VyYXRpb24ubGVuZ3RoICE9PSB0aGlzLm9wdGlvbnMubnVtX2xpbmVzKSB7XG4vLyAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiU3RhdmVDb25maWdFcnJvclwiLFxuLy8gICAgICAgICAgXCJUaGUgbGVuZ3RoIG9mIHRoZSBsaW5lcyBjb25maWd1cmF0aW9uIGFycmF5IG11c3QgbWF0Y2ggdGhlIG51bWJlciBvZiBsaW5lcyBpbiB0aGUgU3RhdmVcIik7XG4vLyAgICAgIH1cbi8vXG4vLyAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgZGVmYXVsdHMgYXJlIHByZXNlbnQgaW4gY2FzZSBhbiBpbmNvbXBsZXRlIHNldCBvZlxuLy8gICAgICAvLyAgY29uZmlndXJhdGlvbiBvcHRpb25zIHdlcmUgc3VwcGxpZWQuXG4vLyAgICAgIGZvciAodmFyIGxpbmVfY29uZmlnIGluIGxpbmVzX2NvbmZpZ3VyYXRpb24pIHtcbi8vICAgICAgICAvLyBBbGxvdyAnbnVsbCcgdG8gYmUgdXNlZCBpZiB0aGUgY2FsbGVyIGp1c3Qgd2FudHMgdGhlIGRlZmF1bHQgZm9yIGEgcGFydGljdWxhciBub2RlLlxuLy8gICAgICAgIGlmICghbGluZXNfY29uZmlndXJhdGlvbltsaW5lX2NvbmZpZ10pIHtcbi8vICAgICAgICAgIGxpbmVzX2NvbmZpZ3VyYXRpb25bbGluZV9jb25maWddID0gdGhpcy5vcHRpb25zLmxpbmVfY29uZmlnW2xpbmVfY29uZmlnXTtcbi8vICAgICAgICB9XG4vLyAgICAgICAgVmV4Lk1lcmdlKHRoaXMub3B0aW9ucy5saW5lX2NvbmZpZ1tsaW5lX2NvbmZpZ10sIGxpbmVzX2NvbmZpZ3VyYXRpb25bbGluZV9jb25maWddKTtcbi8vICAgICAgfVxuLy9cbi8vICAgICAgdGhpcy5vcHRpb25zLmxpbmVfY29uZmlnID0gbGluZXNfY29uZmlndXJhdGlvbjtcbi8vXG4vLyAgICAgIHJldHVybiB0aGlzO1xuLy8gICAgfVxuICB9O1xuXG4gIHJldHVybiBTdGF2ZUdyb3VwO1xufSgpKTtcblxuLy8gVmV4IEZsb3cgTm90YXRpb25cbi8vIE1vaGl0IE11dGhhbm5hIDxtb2hpdEBtdXRoYW5uYS5jb20+XG4vL1xuLy8gQ29weXJpZ2h0IE1vaGl0IE11dGhhbm5hIDIwMTBcbi8vXG4vLyBSZXF1aXJlcyB2ZXguanMuXG5cbi8qKiBAY29uc3RydWN0b3IgKi9cblZleC5GbG93LlN0YXZlQ29ubmVjdG9yID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBTdGF2ZUNvbm5lY3Rvcih0b3Bfc3RhdmUsIGJvdHRvbV9zdGF2ZSkge1xuICAgIHRoaXMuaW5pdCh0b3Bfc3RhdmUsIGJvdHRvbV9zdGF2ZSk7XG4gIH1cblxuICAvLyBTSU5HTEVfTEVGVCBhbmQgU0lOR0xFIGFyZSB0aGUgc2FtZSB2YWx1ZSBmb3IgY29tcGF0aWJpbGl0eVxuICAvLyB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIHZleGZsb3cgd2hpY2ggZGlkbid0IGhhdmUgcmlnaHQgc2lkZWRcbiAgLy8gc3RhdmUgY29ubmVjdG9yc1xuICBTdGF2ZUNvbm5lY3Rvci50eXBlID0ge1xuICAgIFNJTkdMRV9SSUdIVCA6IDAsXG4gICAgU0lOR0xFX0xFRlQgOiAxLFxuICAgIFNJTkdMRTogMSxcbiAgICBET1VCTEU6IDIsXG4gICAgQlJBQ0U6IDMsXG4gICAgQlJBQ0tFVDogNCxcbiAgICBCT0xEX0RPVUJMRV9MRUZUOiA1LFxuICAgIEJPTERfRE9VQkxFX1JJR0hUOiA2LFxuICAgIFRISU5fRE9VQkxFOiA3XG4gIH07XG5cbiAgU3RhdmVDb25uZWN0b3IucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKHRvcF9zdGF2ZSwgYm90dG9tX3N0YXZlKSB7XG4gICAgICB0aGlzLnRoaWNrbmVzcyA9IFZleC5GbG93LlNUQVZFX0xJTkVfVEhJQ0tORVNTO1xuICAgICAgdGhpcy53aWR0aCA9IDM7XG4gICAgICB0aGlzLnRvcF9zdGF2ZSA9IHRvcF9zdGF2ZTtcbiAgICAgIHRoaXMuYm90dG9tX3N0YXZlID0gYm90dG9tX3N0YXZlO1xuICAgICAgdGhpcy50eXBlID0gU3RhdmVDb25uZWN0b3IudHlwZS5ET1VCTEU7XG4gICAgICB0aGlzLnhfc2hpZnQgPSAwOyAvLyBNYWlubHkgdXNlZCB0byBvZmZzZXQgQm9sZCBEb3VibGUgTGVmdCB0byBhbGlnbiB3aXRoIG9mZnNldCBSZXBlYXQgQmVnaW4gYmFyc1xuICAgIH0sXG5cbiAgICBzZXRDb250ZXh0OiBmdW5jdGlvbihjdHgpIHtcbiAgICAgIHRoaXMuY3R4ID0gY3R4O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIGlmICh0eXBlID49IFN0YXZlQ29ubmVjdG9yLnR5cGUuU0lOR0xFX1JJR0hUICYmXG4gICAgICAgICAgdHlwZSA8PSBTdGF2ZUNvbm5lY3Rvci50eXBlLlRISU5fRE9VQkxFKVxuICAgICAgICB0aGlzLnR5cGUgPSB0eXBlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFRleHQ6IGZ1bmN0aW9uKHRleHQsIHRleHRfb3B0aW9ucykge1xuICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgIHRoaXMudGV4dF9vcHRpb25zID0ge1xuICAgICAgICBzaGlmdF94OiAwLFxuICAgICAgICBzaGlmdF95OiAwXG4gICAgICB9O1xuICAgICAgVmV4Lk1lcmdlKHRoaXMudGV4dF9vcHRpb25zLCB0ZXh0X29wdGlvbnMpO1xuXG4gICAgICB0aGlzLmZvbnQgPSB7XG4gICAgICAgIGZhbWlseTogXCJ0aW1lc1wiLFxuICAgICAgICBzaXplOiAxNixcbiAgICAgICAgd2VpZ2h0OiBcIm5vcm1hbFwiXG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEZvbnQ6IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICAgIFZleC5NZXJnZSh0aGlzLmZvbnQsIGZvbnQpO1xuICAgIH0sXG5cbiAgICBzZXRYU2hpZnQ6IGZ1bmN0aW9uKHhfc2hpZnQpe1xuICAgICAgaWYgKHR5cGVvZiB4X3NoaWZ0ICE9PSAnbnVtYmVyJykge1xuICAgICAgICB0aHJvdyBWZXguUkVSUihcIkludmFsaWRUeXBlXCIsIFwieF9zaGlmdCBtdXN0IGJlIGEgTnVtYmVyXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnhfc2hpZnQgPSB4X3NoaWZ0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmN0eCkgdGhyb3cgbmV3IFZleC5SRVJSKFxuICAgICAgICAgIFwiTm9Db250ZXh0XCIsIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgY29udGV4dC5cIik7XG4gICAgICB2YXIgdG9wWSA9IHRoaXMudG9wX3N0YXZlLmdldFlGb3JMaW5lKDApO1xuICAgICAgdmFyIGJvdFkgPSB0aGlzLmJvdHRvbV9zdGF2ZS5nZXRZRm9yTGluZSh0aGlzLmJvdHRvbV9zdGF2ZS5nZXROdW1MaW5lcygpIC0gMSkgK1xuICAgICAgICB0aGlzLnRoaWNrbmVzcztcbiAgICAgIHZhciB3aWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICB2YXIgdG9wWCA9IHRoaXMudG9wX3N0YXZlLmdldFgoKTtcblxuICAgICAgdmFyIGlzUmlnaHRTaWRlZENvbm5lY3RvciA9IChcbiAgICAgICAgdGhpcy50eXBlID09PSBTdGF2ZUNvbm5lY3Rvci50eXBlLlNJTkdMRV9SSUdIVCB8fFxuICAgICAgICB0aGlzLnR5cGUgPT09IFN0YXZlQ29ubmVjdG9yLnR5cGUuQk9MRF9ET1VCTEVfUklHSFQgfHxcbiAgICAgICAgdGhpcy50eXBlID09PSBTdGF2ZUNvbm5lY3Rvci50eXBlLlRISU5fRE9VQkxFXG4gICAgICApO1xuXG4gICAgICBpZiAoaXNSaWdodFNpZGVkQ29ubmVjdG9yKXtcbiAgICAgICAgdG9wWCA9IHRoaXMudG9wX3N0YXZlLmdldFgoKSArIHRoaXMudG9wX3N0YXZlLndpZHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgYXR0YWNobWVudF9oZWlnaHQgPSBib3RZIC0gdG9wWTtcbiAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XG4gICAgICAgIGNhc2UgU3RhdmVDb25uZWN0b3IudHlwZS5TSU5HTEU6XG4gICAgICAgICAgd2lkdGggPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN0YXZlQ29ubmVjdG9yLnR5cGUuU0lOR0xFX0xFRlQ6XG4gICAgICAgICAgd2lkdGggPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN0YXZlQ29ubmVjdG9yLnR5cGUuU0lOR0xFX1JJR0hUOlxuICAgICAgICAgIHdpZHRoID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdGF2ZUNvbm5lY3Rvci50eXBlLkRPVUJMRTpcbiAgICAgICAgICB0b3BYIC09ICh0aGlzLndpZHRoICsgMik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3RhdmVDb25uZWN0b3IudHlwZS5CUkFDRTpcbiAgICAgICAgICB3aWR0aCA9IDEyO1xuICAgICAgICAgIC8vIE1heSBuZWVkIGFkZGl0aW9uYWwgY29kZSB0byBkcmF3IGJyYWNlXG4gICAgICAgICAgdmFyIHgxID0gdGhpcy50b3Bfc3RhdmUuZ2V0WCgpIC0gMjtcbiAgICAgICAgICB2YXIgeTEgPSB0b3BZO1xuICAgICAgICAgIHZhciB4MyA9IHgxO1xuICAgICAgICAgIHZhciB5MyA9IGJvdFk7XG4gICAgICAgICAgdmFyIHgyID0geDEgLSB3aWR0aDtcbiAgICAgICAgICB2YXIgeTIgPSB5MSArIGF0dGFjaG1lbnRfaGVpZ2h0LzIuMDtcbiAgICAgICAgICB2YXIgY3B4MSA9IHgyIC0gKDAuOTAgKiB3aWR0aCk7XG4gICAgICAgICAgdmFyIGNweTEgPSB5MSArICgwLjIgKiBhdHRhY2htZW50X2hlaWdodCk7XG4gICAgICAgICAgdmFyIGNweDIgPSB4MSArICgxLjEwICogd2lkdGgpO1xuICAgICAgICAgIHZhciBjcHkyID0geTIgLSAoMC4xMzUgKiBhdHRhY2htZW50X2hlaWdodCk7XG4gICAgICAgICAgdmFyIGNweDMgPSBjcHgyO1xuICAgICAgICAgIHZhciBjcHkzID0geTIgKyAoMC4xMzUgKiBhdHRhY2htZW50X2hlaWdodCk7XG4gICAgICAgICAgdmFyIGNweDQgPSBjcHgxO1xuICAgICAgICAgIHZhciBjcHk0ID0geTMgLSAoMC4yICogYXR0YWNobWVudF9oZWlnaHQpO1xuICAgICAgICAgIHZhciBjcHg1ID0geDIgLSB3aWR0aDtcbiAgICAgICAgICB2YXIgY3B5NSA9IGNweTQ7XG4gICAgICAgICAgdmFyIGNweDYgPSB4MSArICgwLjQwICogd2lkdGgpO1xuICAgICAgICAgIHZhciBjcHk2ID0geTIgKyAoMC4xMzUgKiBhdHRhY2htZW50X2hlaWdodCk7XG4gICAgICAgICAgdmFyIGNweDcgPSBjcHg2O1xuICAgICAgICAgIHZhciBjcHk3ID0geTIgLSAoMC4xMzUgKiBhdHRhY2htZW50X2hlaWdodCk7XG4gICAgICAgICAgdmFyIGNweDggPSBjcHg1O1xuICAgICAgICAgIHZhciBjcHk4ID0gY3B5MTtcbiAgICAgICAgICB0aGlzLmN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICB0aGlzLmN0eC5tb3ZlVG8oeDEsIHkxKTtcbiAgICAgICAgICB0aGlzLmN0eC5iZXppZXJDdXJ2ZVRvKGNweDEsIGNweTEsIGNweDIsIGNweTIsIHgyLCB5Mik7XG4gICAgICAgICAgdGhpcy5jdHguYmV6aWVyQ3VydmVUbyhjcHgzLCBjcHkzLCBjcHg0LCBjcHk0LCB4MywgeTMpO1xuICAgICAgICAgIHRoaXMuY3R4LmJlemllckN1cnZlVG8oY3B4NSwgY3B5NSwgY3B4NiwgY3B5NiwgeDIsIHkyKTtcbiAgICAgICAgICB0aGlzLmN0eC5iZXppZXJDdXJ2ZVRvKGNweDcsIGNweTcsIGNweDgsIGNweTgsIHgxLCB5MSk7XG4gICAgICAgICAgdGhpcy5jdHguZmlsbCgpO1xuICAgICAgICAgIHRoaXMuY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN0YXZlQ29ubmVjdG9yLnR5cGUuQlJBQ0tFVDpcbiAgICAgICAgICB0b3BZIC09IDQ7XG4gICAgICAgICAgYm90WSArPSA0O1xuICAgICAgICAgIGF0dGFjaG1lbnRfaGVpZ2h0ID0gYm90WSAtIHRvcFk7XG4gICAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgodGhpcy5jdHgsIHRvcFggLSA1LCB0b3BZIC0gMywgNDAsIFwidjFiXCIsIHRydWUpO1xuICAgICAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKHRoaXMuY3R4LCB0b3BYIC0gNSwgYm90WSArIDMsIDQwLCBcInYxMFwiLCB0cnVlKTtcbiAgICAgICAgICB0b3BYIC09ICh0aGlzLndpZHRoICsgMik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgU3RhdmVDb25uZWN0b3IudHlwZS5CT0xEX0RPVUJMRV9MRUZUOlxuICAgICAgICAgIGRyYXdCb2xkRG91YmxlTGluZSh0aGlzLmN0eCwgdGhpcy50eXBlLCB0b3BYICsgdGhpcy54X3NoaWZ0LCB0b3BZLCBib3RZKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdGF2ZUNvbm5lY3Rvci50eXBlLkJPTERfRE9VQkxFX1JJR0hUOlxuICAgICAgICAgIGRyYXdCb2xkRG91YmxlTGluZSh0aGlzLmN0eCwgdGhpcy50eXBlLCB0b3BYLCB0b3BZLCBib3RZKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBTdGF2ZUNvbm5lY3Rvci50eXBlLlRISU5fRE9VQkxFOlxuICAgICAgICAgIHdpZHRoID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMudHlwZSAhPT0gU3RhdmVDb25uZWN0b3IudHlwZS5CUkFDRSAmJlxuICAgICAgICB0aGlzLnR5cGUgIT09IFN0YXZlQ29ubmVjdG9yLnR5cGUuQk9MRF9ET1VCTEVfTEVGVCAmJlxuICAgICAgICB0aGlzLnR5cGUgIT09IFN0YXZlQ29ubmVjdG9yLnR5cGUuQk9MRF9ET1VCTEVfUklHSFQpIHtcbiAgICAgICAgdGhpcy5jdHguZmlsbFJlY3QodG9wWCAsIHRvcFksIHdpZHRoLCBhdHRhY2htZW50X2hlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIC8vIElmIHRoZSBjb25uZWN0b3IgaXMgYSB0aGluIGRvdWJsZSBiYXJsaW5lLCBkcmF3IHRoZSBwYXJhbGVsbCBsaW5lXG4gICAgICBpZiAodGhpcy50eXBlID09PSBTdGF2ZUNvbm5lY3Rvci50eXBlLlRISU5fRE9VQkxFKSB7XG4gICAgICAgIHRoaXMuY3R4LmZpbGxSZWN0KHRvcFggLSAzLCB0b3BZLCB3aWR0aCwgYXR0YWNobWVudF9oZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgc3RhdmUgY29ubmVjdG9yIHRleHRcbiAgICAgIGlmICh0aGlzLnRleHQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IDI7XG4gICAgICAgIHRoaXMuY3R4LnNldEZvbnQodGhpcy5mb250LmZhbWlseSwgdGhpcy5mb250LnNpemUsIHRoaXMuZm9udC53ZWlnaHQpO1xuICAgICAgICB2YXIgdGV4dF93aWR0aCA9IHRoaXMuY3R4Lm1lYXN1cmVUZXh0KFwiXCIgKyB0aGlzLnRleHQpLndpZHRoO1xuXG4gICAgICAgIHZhciB4ID0gdGhpcy50b3Bfc3RhdmUuZ2V0WCgpIC0gdGV4dF93aWR0aCAtIDI0ICsgdGhpcy50ZXh0X29wdGlvbnMuc2hpZnRfeDtcbiAgICAgICAgdmFyIHkgPSAodGhpcy50b3Bfc3RhdmUuZ2V0WUZvckxpbmUoMCkgKyB0aGlzLmJvdHRvbV9zdGF2ZS5nZXRCb3R0b21MaW5lWSgpKSAvIDIgK1xuICAgICAgICAgIHRoaXMudGV4dF9vcHRpb25zLnNoaWZ0X3k7XG5cbiAgICAgICAgdGhpcy5jdHguZmlsbFRleHQoXCJcIiArIHRoaXMudGV4dCwgeCwgeSArIDQpO1xuICAgICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIGZ1bmN0aW9uIGRyYXdCb2xkRG91YmxlTGluZShjdHgsIHR5cGUsIHRvcFgsIHRvcFksIGJvdFkpe1xuICAgIGlmICh0eXBlICE9PSBTdGF2ZUNvbm5lY3Rvci50eXBlLkJPTERfRE9VQkxFX0xFRlQgJiZcbiAgICAgICAgdHlwZSAhPT0gU3RhdmVDb25uZWN0b3IudHlwZS5CT0xEX0RPVUJMRV9SSUdIVCkge1xuICAgICAgdGhyb3cgVmV4LlJFUlIoXCJJbnZhbGlkQ29ubmVjdG9yXCIsXG4gICAgICAgIFwiQSBSRVBFQVRfQkVHSU4gb3IgUkVQRUFUX0VORCB0eXBlIG11c3QgYmUgcHJvdmlkZWQuXCIpO1xuICAgIH1cblxuICAgIHZhciB4X3NoaWZ0ID0gMztcbiAgICB2YXIgdmFyaWFibGVXaWR0aCA9IDMuNTsgLy8gV2lkdGggZm9yIGF2b2lkaW5nIGFudGktYWxpYXNpbmcgd2lkdGggaXNzdWVzXG4gICAgdmFyIHRoaWNrTGluZU9mZnNldCA9IDI7IC8vIEZvciBhZXN0aGV0aWNzXG5cbiAgICBpZiAodHlwZSA9PT0gU3RhdmVDb25uZWN0b3IudHlwZS5CT0xEX0RPVUJMRV9SSUdIVCkge1xuICAgICAgeF9zaGlmdCA9IC01OyAvLyBGbGlwcyB0aGUgc2lkZSBvZiB0aGUgdGhpbiBsaW5lXG4gICAgICB2YXJpYWJsZVdpZHRoID0gMztcbiAgICB9XG5cbiAgICAvLyBUaGluIGxpbmVcbiAgICBjdHguZmlsbFJlY3QodG9wWCArIHhfc2hpZnQsIHRvcFksIDEsIGJvdFkgLSB0b3BZKTtcbiAgICAvLyBUaGljayBsaW5lXG4gICAgY3R4LmZpbGxSZWN0KHRvcFggLSB0aGlja0xpbmVPZmZzZXQsIHRvcFksIHZhcmlhYmxlV2lkdGgsIGJvdFkgLSB0b3BZKTtcbiAgfVxuXG4gIHJldHVybiBTdGF2ZUNvbm5lY3Rvcjtcbn0oKSk7XG4vLyBWZXggRmxvd1xuLy8gTW9oaXQgTXV0aGFubmEgPG1vaGl0QG11dGhhbm5hLmNvbT5cbi8vXG4vLyBDb3B5cmlnaHQgTW9oaXQgQ2hlcHB1ZGlyYSAyMDEwXG5cbi8qKiBAY29uc3RydWN0b3IgKi9cblZleC5GbG93LlRhYlN0YXZlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUYWJTdGF2ZSh4LCB5LCB3aWR0aCwgb3B0aW9ucykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHgsIHksIHdpZHRoLCBvcHRpb25zKTtcbiAgfVxuXG4gIFZleC5Jbmhlcml0KFRhYlN0YXZlLCBWZXguRmxvdy5TdGF2ZSwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBvcHRpb25zKSB7XG4gICAgICB2YXIgdGFiX29wdGlvbnMgPSB7XG4gICAgICAgIHNwYWNpbmdfYmV0d2Vlbl9saW5lc19weDogMTMsXG4gICAgICAgIG51bV9saW5lczogNixcbiAgICAgICAgdG9wX3RleHRfcG9zaXRpb246IDFcbiAgICAgIH07XG5cbiAgICAgIFZleC5NZXJnZSh0YWJfb3B0aW9ucywgb3B0aW9ucyk7XG4gICAgICBUYWJTdGF2ZS5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCB4LCB5LCB3aWR0aCwgdGFiX29wdGlvbnMpO1xuICAgIH0sXG5cbiAgICBnZXRZRm9yR2x5cGhzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldFlGb3JMaW5lKDIuNSk7XG4gICAgfSxcblxuICAgIGFkZFRhYkdseXBoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBnbHlwaFNjYWxlO1xuICAgICAgdmFyIGdseXBoT2Zmc2V0O1xuXG4gICAgICBzd2l0Y2godGhpcy5vcHRpb25zLm51bV9saW5lcykge1xuICAgICAgICBjYXNlIDg6XG4gICAgICAgICAgZ2x5cGhTY2FsZSA9IDU1O1xuICAgICAgICAgIGdseXBoT2Zmc2V0ID0gMTQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgNzpcbiAgICAgICAgICBnbHlwaFNjYWxlID0gNDc7XG4gICAgICAgICAgZ2x5cGhPZmZzZXQgPSA4O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDY6XG4gICAgICAgICAgZ2x5cGhTY2FsZSA9IDQwO1xuICAgICAgICAgIGdseXBoT2Zmc2V0ID0gMTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA1OlxuICAgICAgICAgIGdseXBoU2NhbGUgPSAzMDtcbiAgICAgICAgICBnbHlwaE9mZnNldCA9IC02O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIDQ6XG4gICAgICAgICAgZ2x5cGhTY2FsZSA9IDIzO1xuICAgICAgICAgIGdseXBoT2Zmc2V0ID0gLTEyO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICB2YXIgdGFiR2x5cGggPSBuZXcgVmV4LkZsb3cuR2x5cGgoXCJ2MmZcIiwgZ2x5cGhTY2FsZSk7XG4gICAgICB0YWJHbHlwaC55X3NoaWZ0ID0gZ2x5cGhPZmZzZXQ7XG4gICAgICB0aGlzLmFkZEdseXBoKHRhYkdseXBoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFRhYlN0YXZlO1xufSgpKTtcbi8vIFZleCBGbG93XG4vLyBDb3B5cmlnaHQgTW9oaXQgQ2hlcHB1ZGlyYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy9cbi8vIEEgZm9ybWF0dGVyIGZvciBhYnN0cmFjdCB0aWNrYWJsZSBvYmplY3RzLCBzdWNoIGFzIG5vdGVzLCBjaG9yZHMsXG4vLyB0YWJzLCBldGMuXG5cbi8qKiBAY29uc3RydWN0b3IgKi9cblZleC5GbG93LlRpY2tDb250ZXh0ID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUaWNrQ29udGV4dCgpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIFRpY2tDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMuY3VycmVudFRpY2sgPSBuZXcgVmV4LkZsb3cuRnJhY3Rpb24oMCwgMSk7XG4gICAgICB0aGlzLm1heFRpY2tzID0gbmV3IFZleC5GbG93LkZyYWN0aW9uKDAsIDEpO1xuICAgICAgdGhpcy5taW5UaWNrcyA9IG51bGw7XG4gICAgICB0aGlzLndpZHRoID0gMDtcbiAgICAgIHRoaXMucGFkZGluZyA9IDM7ICAgICAvLyBwYWRkaW5nIG9uIGVhY2ggc2lkZSAod2lkdGggKz0gcGFkZGluZyAqIDIpXG4gICAgICB0aGlzLnBpeGVsc1VzZWQgPSAwO1xuICAgICAgdGhpcy54ID0gMDtcbiAgICAgIHRoaXMudGlja2FibGVzID0gW107ICAgLy8gTm90ZXMsIHRhYnMsIGNob3JkcywgbHlyaWNzLlxuICAgICAgdGhpcy5ub3RlUHggPSAwOyAgICAgICAvLyB3aWR0aCBvZiB3aWRlc3Qgbm90ZSBpbiB0aGlzIGNvbnRleHRcbiAgICAgIHRoaXMuZXh0cmFMZWZ0UHggPSAwOyAgLy8gRXh0cmEgbGVmdCBwaXhlbHMgZm9yIG1vZGlmZXJzICYgZGlzcGxhY2Ugbm90ZXNcbiAgICAgIHRoaXMuZXh0cmFSaWdodFB4ID0gMDsgLy8gRXh0cmEgcmlnaHQgcGl4ZWxzIGZvciBtb2RpZmVycyAmIGRpc3BsYWNlIG5vdGVzXG4gICAgICB0aGlzLmFsaWduX2NlbnRlciA9IGZhbHNlO1xuXG4gICAgICB0aGlzLnRDb250ZXh0cyA9IFtdOyAgIC8vIFBhcmVudCBhcnJheSBvZiB0aWNrIGNvbnRleHRzXG5cbiAgICAgIC8vIElnbm9yZSB0aGlzIHRpY2sgY29udGV4dCBmb3IgZm9ybWF0dGluZyBhbmQganVzdGlmaWNhdGlvblxuICAgICAgdGhpcy5pZ25vcmVfdGlja3MgPSB0cnVlO1xuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucG9zdEZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDsgLy8gUmVuZGVyaW5nIGNvbnRleHRcbiAgICB9LFxuXG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkgeyB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyByZXR1cm4gdGhpczsgfSxcbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY29udGV4dDsgfSxcbiAgICBzaG91bGRJZ25vcmVUaWNrczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlnbm9yZV90aWNrczsgfSxcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLndpZHRoICsgKHRoaXMucGFkZGluZyAqIDIpOyB9LFxuICAgIGdldFg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy54OyB9LFxuICAgIHNldFg6IGZ1bmN0aW9uKHgpIHsgdGhpcy54ID0geDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgZ2V0UGl4ZWxzVXNlZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnBpeGVsc1VzZWQ7IH0sXG4gICAgc2V0UGl4ZWxzVXNlZDogZnVuY3Rpb24ocGl4ZWxzVXNlZCkgeyB0aGlzLnBpeGVsc1VzZWQgPSBwaXhlbHNVc2VkOyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRQYWRkaW5nOiBmdW5jdGlvbihwYWRkaW5nKSB7IHRoaXMucGFkZGluZyA9IHBhZGRpbmc7IHJldHVybiB0aGlzOyB9LFxuICAgIGdldE1heFRpY2tzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubWF4VGlja3M7IH0sXG4gICAgZ2V0TWluVGlja3M6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5taW5UaWNrczsgfSxcbiAgICBnZXRUaWNrYWJsZXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50aWNrYWJsZXM7IH0sXG5cbiAgICBnZXRDZW50ZXJBbGlnbmVkVGlja2FibGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpY2thYmxlcy5maWx0ZXIoZnVuY3Rpb24odGlja2FibGUpIHtcbiAgICAgICAgcmV0dXJuIHRpY2thYmxlLmlzQ2VudGVyQWxpZ25lZCgpO1xuICAgICAgfSk7XG4gICAgfSxcblxuICAgIC8vIEdldCB3aWR0aHMgY29udGV4dCwgbm90ZSBhbmQgbGVmdC9yaWdodCBtb2RpZmllcnMgZm9yIGZvcm1hdHRpbmdcbiAgICBnZXRNZXRyaWNzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB7IHdpZHRoOiB0aGlzLndpZHRoLCBub3RlUHg6IHRoaXMubm90ZVB4LFxuICAgICAgICAgICAgICAgZXh0cmFMZWZ0UHg6IHRoaXMuZXh0cmFMZWZ0UHgsIGV4dHJhUmlnaHRQeDogdGhpcy5leHRyYVJpZ2h0UHggfTtcbiAgICB9LFxuXG4gICAgZ2V0Q3VycmVudFRpY2s6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jdXJyZW50VGljazsgfSxcbiAgICBzZXRDdXJyZW50VGljazogZnVuY3Rpb24odGljaykge1xuICAgICAgdGhpcy5jdXJyZW50VGljayA9IHRpY2s7XG4gICAgICB0aGlzLnByZUZvcm1hdHRlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgbGVmdCAmIHJpZ2h0IHBpeGVscyB1c2VkIGZvciBtb2RpZmllcnNcbiAgICBnZXRFeHRyYVB4OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBsZWZ0X3NoaWZ0ID0gMDtcbiAgICAgIHZhciByaWdodF9zaGlmdCA9IDA7XG4gICAgICB2YXIgZXh0cmFMZWZ0UHggPSAwO1xuICAgICAgdmFyIGV4dHJhUmlnaHRQeCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGlja2FibGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGV4dHJhTGVmdFB4ID0gTWF0aC5tYXgodGhpcy50aWNrYWJsZXNbaV0uZXh0cmFMZWZ0UHgsIGV4dHJhTGVmdFB4KTtcbiAgICAgICAgZXh0cmFSaWdodFB4ID0gTWF0aC5tYXgodGhpcy50aWNrYWJsZXNbaV0uZXh0cmFSaWdodFB4LCBleHRyYVJpZ2h0UHgpO1xuICAgICAgICB2YXIgbUNvbnRleHQgPSB0aGlzLnRpY2thYmxlc1tpXS5tb2RpZmllckNvbnRleHQ7XG4gICAgICAgIGlmIChtQ29udGV4dCAmJiBtQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgICAgbGVmdF9zaGlmdCA9IE1hdGgubWF4KCBsZWZ0X3NoaWZ0LCBtQ29udGV4dC5zdGF0ZS5sZWZ0X3NoaWZ0KTtcbiAgICAgICAgICByaWdodF9zaGlmdCA9IE1hdGgubWF4KCByaWdodF9zaGlmdCwgbUNvbnRleHQuc3RhdGUucmlnaHRfc2hpZnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBsZWZ0OiBsZWZ0X3NoaWZ0LCByaWdodDogcmlnaHRfc2hpZnQsXG4gICAgICAgICAgICAgICBleHRyYUxlZnQ6IGV4dHJhTGVmdFB4LCBleHRyYVJpZ2h0OiBleHRyYVJpZ2h0UHggfTtcbiAgICB9LFxuXG4gICAgYWRkVGlja2FibGU6IGZ1bmN0aW9uKHRpY2thYmxlKSB7XG4gICAgICBpZiAoIXRpY2thYmxlKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50XCIsIFwiSW52YWxpZCB0aWNrYWJsZSBhZGRlZC5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmICghdGlja2FibGUuc2hvdWxkSWdub3JlVGlja3MoKSkge1xuICAgICAgICB0aGlzLmlnbm9yZV90aWNrcyA9IGZhbHNlO1xuXG4gICAgICAgIHZhciB0aWNrcyA9IHRpY2thYmxlLmdldFRpY2tzKCk7XG5cbiAgICAgICAgaWYgKHRpY2tzLmdyZWF0ZXJUaGFuKHRoaXMubWF4VGlja3MpKSB7XG4gICAgICAgICAgdGhpcy5tYXhUaWNrcyA9IHRpY2tzLmNsb25lKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodGhpcy5taW5UaWNrcyA9PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy5taW5UaWNrcyA9IHRpY2tzLmNsb25lKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodGlja3MubGVzc1RoYW4odGhpcy5taW5UaWNrcykpIHtcbiAgICAgICAgICB0aGlzLm1pblRpY2tzID0gdGlja3MuY2xvbmUoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aWNrYWJsZS5zZXRUaWNrQ29udGV4dCh0aGlzKTtcbiAgICAgIHRoaXMudGlja2FibGVzLnB1c2godGlja2FibGUpO1xuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucHJlRm9ybWF0dGVkKSByZXR1cm47XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy50aWNrYWJsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHRpY2thYmxlID0gdGhpcy50aWNrYWJsZXNbaV07XG4gICAgICAgIHRpY2thYmxlLnByZUZvcm1hdCgpO1xuICAgICAgICB2YXIgbWV0cmljcyA9IHRpY2thYmxlLmdldE1ldHJpY3MoKTtcblxuICAgICAgICAvLyBNYWludGFpbiBtYXggZXh0cmEgcGl4ZWxzIGZyb20gYWxsIHRpY2thYmxlcyBpbiB0aGUgY29udGV4dFxuICAgICAgICB0aGlzLmV4dHJhTGVmdFB4ID0gTWF0aC5tYXgodGhpcy5leHRyYUxlZnRQeCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldHJpY3MuZXh0cmFMZWZ0UHggKyBtZXRyaWNzLm1vZExlZnRQeCk7XG4gICAgICAgIHRoaXMuZXh0cmFSaWdodFB4ID0gTWF0aC5tYXgodGhpcy5leHRyYVJpZ2h0UHgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0cmljcy5leHRyYVJpZ2h0UHggKyBtZXRyaWNzLm1vZFJpZ2h0UHgpO1xuXG4gICAgICAgIC8vIE1haW50YWluIHRoZSB3aWRlc3Qgbm90ZSBmb3IgYWxsIHRpY2thYmxlcyBpbiB0aGUgY29udGV4dFxuICAgICAgICB0aGlzLm5vdGVQeCA9IE1hdGgubWF4KHRoaXMubm90ZVB4LCBtZXRyaWNzLm5vdGVXaWR0aCk7XG5cbiAgICAgICAgLy8gUmVjYWxjdWxhdGUgdGhlIHRpY2sgY29udGV4dCB0b3RhbCB3aWR0aFxuICAgICAgICB0aGlzLndpZHRoID0gdGhpcy5ub3RlUHggK1xuICAgICAgICAgICAgICAgICAgICAgdGhpcy5leHRyYUxlZnRQeCArXG4gICAgICAgICAgICAgICAgICAgICB0aGlzLmV4dHJhUmlnaHRQeDtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHBvc3RGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucG9zdEZvcm1hdHRlZCkgcmV0dXJuIHRoaXM7XG4gICAgICB0aGlzLnBvc3RGb3JtYXR0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9O1xuXG4gIFRpY2tDb250ZXh0LmdldE5leHRDb250ZXh0ID0gZnVuY3Rpb24odENvbnRleHQpIHtcbiAgICB2YXIgY29udGV4dHMgPSB0Q29udGV4dC50Q29udGV4dHM7XG4gICAgdmFyIGluZGV4ID0gY29udGV4dHMuaW5kZXhPZih0Q29udGV4dCk7XG5cbiAgICByZXR1cm4gY29udGV4dHNbaW5kZXgrMV07XG4gIH07XG5cbiAgcmV0dXJuIFRpY2tDb250ZXh0O1xufSgpKTtcblxuLy8gVmV4IEZsb3dcbi8vIENvcHlyaWdodCBNb2hpdCBDaGVwcHVkaXJhIDxtb2hpdEBtdXRoYW5uYS5jb20+XG4vL1xuLy8gVGhlIHRpY2thYmxlIGludGVyZmFjZS4gVGlja2FibGVzIGFyZSB0aGluZ3MgdGhhdCBzaXQgb24gYSBzY29yZSBhbmRcbi8vIGhhdmUgYSBkdXJhdGlvbiwgaS5lLiwgdGhleSBvY2N1cHkgc3BhY2UgaW4gdGhlIG11c2ljYWwgcmVuZGVyaW5nIGRpbWVuc2lvbi5cblxuLyoqIEBjb25zdHJ1Y3RvciAqL1xuVmV4LkZsb3cuVGlja2FibGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRpY2thYmxlKCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgVGlja2FibGUucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5pbnRyaW5zaWNUaWNrcyA9IDA7XG4gICAgICB0aGlzLnRpY2tNdWx0aXBsaWVyID0gbmV3IFZleC5GbG93LkZyYWN0aW9uKDEsIDEpO1xuICAgICAgdGhpcy50aWNrcyA9IG5ldyBWZXguRmxvdy5GcmFjdGlvbigwLCAxKTtcbiAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgdGhpcy54X3NoaWZ0ID0gMDsgLy8gU2hpZnQgZnJvbSB0aWNrIGNvbnRleHRcbiAgICAgIHRoaXMudm9pY2UgPSBudWxsO1xuICAgICAgdGhpcy50aWNrQ29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLm1vZGlmaWVyQ29udGV4dCA9IG51bGw7XG4gICAgICB0aGlzLm1vZGlmaWVycyA9IFtdO1xuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgIHRoaXMucG9zdEZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy50dXBsZXQgPSBudWxsO1xuXG4gICAgICAvLyBGb3IgaW50ZXJhY3Rpdml0eVxuICAgICAgdGhpcy5pZCA9IG51bGw7XG4gICAgICB0aGlzLmVsZW0gPSBudWxsO1xuXG4gICAgICB0aGlzLmFsaWduX2NlbnRlciA9IGZhbHNlO1xuICAgICAgdGhpcy5jZW50ZXJfeF9zaGlmdCA9IDA7IC8vIFNoaWZ0IGZyb20gdGljayBjb250ZXh0IGlmIGNlbnRlciBhbGlnbmVkXG5cbiAgICAgIC8vIFRoaXMgZmxhZyB0ZWxscyB0aGUgZm9ybWF0dGVyIHRvIGlnbm9yZSB0aGlzIHRpY2thYmxlIGR1cmluZ1xuICAgICAgLy8gZm9ybWF0dGluZyBhbmQganVzdGlmaWNhdGlvbi4gSXQgaXMgc2V0IGJ5IHRpY2thYmxlcyBzdWNoIGFzIEJhck5vdGUuXG4gICAgICB0aGlzLmlnbm9yZV90aWNrcyA9IGZhbHNlO1xuICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICB9LFxuXG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkgeyB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyB9LFxuXG4gICAgLy8gU2V0IHRoZSBET00gSUQgb2YgdGhlIGVsZW1lbnQuIE11c3QgYmUgY2FsbGVkIGJlZm9yZSBkcmF3KCkuIFRPRE86IFVwZGF0ZVxuICAgIC8vIElEIG9mIGVsZW1lbnQgaWYgaGFzIGFscmVhZHkgYmVlbiByZW5kZXJlZC5cbiAgICBzZXRJZDogZnVuY3Rpb24oaWQpIHsgdGhpcy5pZCA9IGlkOyB9LFxuICAgIGdldElkOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaWQ7IH0sXG4gICAgZ2V0RWxlbTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmVsZW07IH0sXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbnVsbDsgfSxcbiAgICBnZXRUaWNrczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRpY2tzOyB9LFxuICAgIHNob3VsZElnbm9yZVRpY2tzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuaWdub3JlX3RpY2tzOyB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMud2lkdGg7IH0sXG4gICAgc2V0WFNoaWZ0OiBmdW5jdGlvbih4KSB7IHRoaXMueF9zaGlmdCA9IHg7IH0sXG4gICAgZ2V0Q2VudGVyWFNoaWZ0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLmlzQ2VudGVyQWxpZ25lZCgpKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNlbnRlcl94X3NoaWZ0O1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgaXNDZW50ZXJBbGlnbmVkOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuYWxpZ25fY2VudGVyOyB9LFxuICAgIHNldENlbnRlckFsaWdubWVudDogZnVuY3Rpb24oYWxpZ25fY2VudGVyKSB7XG4gICAgICB0aGlzLmFsaWduX2NlbnRlciA9IGFsaWduX2NlbnRlcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBFdmVyeSB0aWNrYWJsZSBtdXN0IGJlIGFzc29jaWF0ZWQgd2l0aCBhIHZvaWNlLiBUaGlzIGFsbG93cyBmb3JtYXR0ZXJzXG4gICAgLy8gYW5kIHByZUZvcm1hdHRlciB0byBhc3NvY2lhdGUgdGhlbSB3aXRoIHRoZSByaWdodCBtb2RpZmllckNvbnRleHRzLlxuICAgIGdldFZvaWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy52b2ljZSkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9Wb2ljZVwiLCBcIlRpY2thYmxlIGhhcyBubyB2b2ljZS5cIik7XG4gICAgICByZXR1cm4gdGhpcy52b2ljZTtcbiAgICB9LFxuICAgIHNldFZvaWNlOiBmdW5jdGlvbih2b2ljZSkgeyB0aGlzLnZvaWNlID0gdm9pY2U7IH0sXG5cbiAgICBnZXRUdXBsZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50dXBsZXQ7IH0sXG4gICAgc2V0VHVwbGV0OiBmdW5jdGlvbih0dXBsZXQpIHtcbiAgICAgIC8vIERldGFjaCBmcm9tIHByZXZpb3VzIHR1cGxldFxuICAgICAgdmFyIG5vdGVDb3VudCwgYmVhdHNPY2N1cGllZDtcblxuICAgICAgaWYgKHRoaXMudHVwbGV0KSB7XG4gICAgICAgIG5vdGVDb3VudCA9IHRoaXMudHVwbGV0LmdldE5vdGVDb3VudCgpO1xuICAgICAgICBiZWF0c09jY3VwaWVkID0gdGhpcy50dXBsZXQuZ2V0QmVhdHNPY2N1cGllZCgpO1xuXG4gICAgICAgIC8vIFJldmVydCBvbGQgbXVsdGlwbGllclxuICAgICAgICB0aGlzLmFwcGx5VGlja011bHRpcGxpZXIobm90ZUNvdW50LCBiZWF0c09jY3VwaWVkKTtcbiAgICAgIH1cblxuICAgICAgLy8gQXR0YWNoIHRvIG5ldyB0dXBsZXRcbiAgICAgIGlmICh0dXBsZXQpIHtcbiAgICAgICAgbm90ZUNvdW50ID0gdHVwbGV0LmdldE5vdGVDb3VudCgpO1xuICAgICAgICBiZWF0c09jY3VwaWVkID0gdHVwbGV0LmdldEJlYXRzT2NjdXBpZWQoKTtcblxuICAgICAgICB0aGlzLmFwcGx5VGlja011bHRpcGxpZXIoYmVhdHNPY2N1cGllZCwgbm90ZUNvdW50KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy50dXBsZXQgPSB0dXBsZXQ7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKiogb3B0aW9uYWwsIGlmIHRpY2thYmxlIGhhcyBtb2RpZmllcnMgKiovXG4gICAgYWRkVG9Nb2RpZmllckNvbnRleHQ6IGZ1bmN0aW9uKG1jKSB7XG4gICAgICB0aGlzLm1vZGlmaWVyQ29udGV4dCA9IG1jO1xuICAgICAgLy8gQWRkIG1vZGlmaWVycyB0byBtb2RpZmllciBjb250ZXh0IChpZiBhbnkpXG4gICAgICB0aGlzLnByZUZvcm1hdHRlZCA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvKiogb3B0aW9uYWwsIGlmIHRpY2thYmxlIGhhcyBtb2RpZmllcnMgKiovXG4gICAgYWRkTW9kaWZpZXI6IGZ1bmN0aW9uKG1vZCkge1xuICAgICAgdGhpcy5tb2RpZmllcnMucHVzaChtb2QpO1xuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRUaWNrQ29udGV4dDogZnVuY3Rpb24odGMpIHtcbiAgICAgIHRoaXMudGlja0NvbnRleHQgPSB0YztcbiAgICAgIHRoaXMucHJlRm9ybWF0dGVkID0gZmFsc2U7XG4gICAgfSxcblxuICAgIHByZUZvcm1hdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5wcmVGb3JtYXR0ZWQpIHJldHVybjtcblxuICAgICAgdGhpcy53aWR0aCA9IDA7XG4gICAgICBpZiAodGhpcy5tb2RpZmllckNvbnRleHQpIHtcbiAgICAgICAgdGhpcy5tb2RpZmllckNvbnRleHQucHJlRm9ybWF0KCk7XG4gICAgICAgIHRoaXMud2lkdGggKz0gdGhpcy5tb2RpZmllckNvbnRleHQuZ2V0V2lkdGgoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHBvc3RGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucG9zdEZvcm1hdHRlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5wb3N0Rm9ybWF0dGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gICAgZ2V0SW50cmluc2ljVGlja3M6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMuaW50cmluc2ljVGlja3M7XG4gICAgfSxcbiAgICBzZXRJbnRyaW5zaWNUaWNrczogZnVuY3Rpb24oaW50cmluc2ljVGlja3MpIHtcbiAgICAgIHRoaXMuaW50cmluc2ljVGlja3MgPSBpbnRyaW5zaWNUaWNrcztcbiAgICAgIHRoaXMudGlja3MgPSB0aGlzLnRpY2tNdWx0aXBsaWVyLmNsb25lKCkubXVsdGlwbHkodGhpcy5pbnRyaW5zaWNUaWNrcyk7XG4gICAgfSxcbiAgICBnZXRUaWNrTXVsdGlwbGllcjogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy50aWNrTXVsdGlwbGllcjtcbiAgICB9LFxuICAgIGFwcGx5VGlja011bHRpcGxpZXI6IGZ1bmN0aW9uKG51bWVyYXRvciwgZGVub21pbmF0b3IpIHtcbiAgICAgIHRoaXMudGlja011bHRpcGxpZXIubXVsdGlwbHkobnVtZXJhdG9yLCBkZW5vbWluYXRvcik7XG4gICAgICB0aGlzLnRpY2tzID0gdGhpcy50aWNrTXVsdGlwbGllci5jbG9uZSgpLm11bHRpcGx5KHRoaXMuaW50cmluc2ljVGlja3MpO1xuICAgIH0sXG4gICAgc2V0RHVyYXRpb246IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gICAgICB2YXIgdGlja3MgPSBkdXJhdGlvbi5udW1lcmF0b3IgKiAoVmV4LkZsb3cuUkVTT0xVVElPTiAvIGR1cmF0aW9uLmRlbm9taW5hdG9yKTtcbiAgICAgIHRoaXMudGlja3MgPSB0aGlzLnRpY2tNdWx0aXBsaWVyLmNsb25lKCkubXVsdGlwbHkodGlja3MpO1xuICAgICAgdGhpcy5pbnRyaW5zaWNUaWNrcyA9IHRoaXMudGlja3MudmFsdWUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRpY2thYmxlO1xufSgpKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgYW4gYWJzdHJhY3QgaW50ZXJmYWNlIGZvciBub3RlcyBhbmQgY2hvcmRzIHRoYXRcbi8vIGFyZSByZW5kZXJlZCBvbiBhIHN0YXZlLiBOb3RlcyBoYXZlIHNvbWUgY29tbW9uIHByb3BlcnRpZXM6IEFsbCBvZiB0aGVtXG4vLyBoYXZlIGEgdmFsdWUgKGUuZy4sIHBpdGNoLCBmcmV0LCBldGMuKSBhbmQgYSBkdXJhdGlvbiAocXVhcnRlciwgaGFsZiwgZXRjLilcbi8vXG4vLyBTb21lIG5vdGVzIGhhdmUgc3RlbXMsIGhlYWRzLCBkb3RzLCBldGMuIE1vc3Qgbm90YXRpb25hbCBlbGVtZW50cyB0aGF0XG4vLyBzdXJyb3VuZCBhIG5vdGUgYXJlIGNhbGxlZCAqbW9kaWZpZXJzKiwgYW5kIGV2ZXJ5IG5vdGUgaGFzIGFuIGFzc29jaWF0ZWRcbi8vIGFycmF5IG9mIHRoZW0uIEFsbCBub3RlcyBhbHNvIGhhdmUgYSByZW5kZXJpbmcgY29udGV4dCBhbmQgYmVsb25nIHRvIGEgc3RhdmUuXG5cblZleC5GbG93Lk5vdGUgPSAoZnVuY3Rpb24oKSB7XG4gIC8vIFRvIGNyZWF0ZSBhIG5ldyBub3RlIHlvdSBuZWVkIHRvIHByb3ZpZGUgYSBgbm90ZV9zdHJ1Y3RgLCB3aGljaCBjb25zaXN0c1xuICAvLyBvZiB0aGUgZm9sbG93aW5nIGZpZWxkczpcbiAgLy9cbiAgLy8gYHR5cGVgOiBUaGUgbm90ZSB0eXBlIChlLmcuLCBgcmAgZm9yIHJlc3QsIGBzYCBmb3Igc2xhc2ggbm90ZXMsIGV0Yy4pXG4gIC8vIGBkb3RzYDogVGhlIG51bWJlciBvZiBkb3RzLCB3aGljaCBhZmZlY3RzIHRoZSBkdXJhdGlvbi5cbiAgLy8gYGR1cmF0aW9uYDogVGhlIHRpbWUgbGVuZ3RoIChlLmcuLCBgcWAgZm9yIHF1YXJ0ZXIsIGBoYCBmb3IgaGFsZiwgYDhgIGZvciBlaWdodGggZXRjLilcbiAgLy9cbiAgLy8gVGhlIHJhbmdlIG9mIHZhbHVlcyBmb3IgdGhlc2UgcGFyYW1ldGVycyBhcmUgYXZhaWxhYmxlIGluIGBzcmMvdGFibGVzLmpzYC5cbiAgZnVuY3Rpb24gTm90ZShub3RlX3N0cnVjdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG5vdGVfc3RydWN0KTtcbiAgfVxuICBOb3RlLkNBVEVHT1JZID0gXCJub3RlXCI7XG5cbiAgLy8gRGVidWcgaGVscGVyLiBEaXNwbGF5cyB2YXJpb3VzIG5vdGUgbWV0cmljcyBmb3IgdGhlIGdpdmVuXG4gIC8vIG5vdGUuXG4gIE5vdGUucGxvdE1ldHJpY3MgPSBmdW5jdGlvbihjdHgsIG5vdGUsIHlQb3MpIHtcbiAgICB2YXIgbWV0cmljcyA9IG5vdGUuZ2V0TWV0cmljcygpO1xuICAgIHZhciB3ID0gbWV0cmljcy53aWR0aDtcbiAgICB2YXIgeFN0YXJ0ID0gbm90ZS5nZXRBYnNvbHV0ZVgoKSAtIG1ldHJpY3MubW9kTGVmdFB4IC0gbWV0cmljcy5leHRyYUxlZnRQeDtcbiAgICB2YXIgeFByZTEgPSBub3RlLmdldEFic29sdXRlWCgpIC0gbWV0cmljcy5leHRyYUxlZnRQeDtcbiAgICB2YXIgeEFicyA9IG5vdGUuZ2V0QWJzb2x1dGVYKCk7XG4gICAgdmFyIHhQb3N0MSA9IG5vdGUuZ2V0QWJzb2x1dGVYKCkgKyBtZXRyaWNzLm5vdGVXaWR0aDtcbiAgICB2YXIgeFBvc3QyID0gbm90ZS5nZXRBYnNvbHV0ZVgoKSArIG1ldHJpY3Mubm90ZVdpZHRoICsgbWV0cmljcy5leHRyYVJpZ2h0UHg7XG4gICAgdmFyIHhFbmQgPSBub3RlLmdldEFic29sdXRlWCgpICsgbWV0cmljcy5ub3RlV2lkdGggKyBtZXRyaWNzLmV4dHJhUmlnaHRQeCArIG1ldHJpY3MubW9kUmlnaHRQeDtcblxuICAgIHZhciB4V2lkdGggPSB4RW5kIC0geFN0YXJ0O1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnNldEZvbnQoXCJBcmlhbFwiLCA4LCBcIlwiKTtcbiAgICBjdHguZmlsbFRleHQoTWF0aC5yb3VuZCh4V2lkdGgpICsgXCJweFwiLCB4U3RhcnQgKyBub3RlLmdldFhTaGlmdCgpLCB5UG9zKTtcblxuICAgIHZhciB5ID0gKHlQb3MgKyA3KTtcbiAgICBmdW5jdGlvbiBzdHJva2UoeDEsIHgyLCBjb2xvcikge1xuICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgY3R4LnNldFN0cm9rZVN0eWxlKGNvbG9yKTtcbiAgICAgIGN0eC5zZXRGaWxsU3R5bGUoY29sb3IpO1xuICAgICAgY3R4LnNldExpbmVXaWR0aCgzKTtcbiAgICAgIGN0eC5tb3ZlVG8oeDEgKyBub3RlLmdldFhTaGlmdCgpLCB5KTtcbiAgICAgIGN0eC5saW5lVG8oeDIgKyBub3RlLmdldFhTaGlmdCgpLCB5KTtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICB9XG5cbiAgICBzdHJva2UoeFN0YXJ0LCB4UHJlMSwgXCJyZWRcIik7XG4gICAgc3Ryb2tlKHhQcmUxLCB4QWJzLCBcIiM5OTlcIik7XG4gICAgc3Ryb2tlKHhBYnMsIHhQb3N0MSwgXCJncmVlblwiKTtcbiAgICBzdHJva2UoeFBvc3QxLCB4UG9zdDIsIFwiIzk5OVwiKTtcbiAgICBzdHJva2UoeFBvc3QyLCB4RW5kLCBcInJlZFwiKTtcbiAgICBzdHJva2UoeFN0YXJ0IC0gbm90ZS5nZXRYU2hpZnQoKSwgeFN0YXJ0LCBcIiNERERcIik7IC8vIFNoaWZ0XG4gICAgVmV4LmRyYXdEb3QoY3R4LCB4QWJzICsgbm90ZS5nZXRYU2hpZnQoKSwgeSwgXCJibHVlXCIpO1xuICAgIGN0eC5yZXN0b3JlKCk7XG4gIH07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgLy9cbiAgLy8gRXZlcnkgbm90ZSBpcyBhIHRpY2thYmxlLCBpLmUuLCBpdCBjYW4gYmUgbXV0YXRlZCBieSB0aGUgYEZvcm1hdHRlcmAgY2xhc3MgZm9yXG4gIC8vIHBvc2l0aW9uaW5nIGFuZCBsYXlvdXQuXG4gIFZleC5Jbmhlcml0KE5vdGUsIFZleC5GbG93LlRpY2thYmxlLCB7XG4gICAgLy8gU2VlIGNvbnN0cnVjdG9yIGFib3ZlIGZvciBob3cgdG8gY3JlYXRlIGEgbm90ZS5cbiAgICBpbml0OiBmdW5jdGlvbihub3RlX3N0cnVjdCkge1xuICAgICAgTm90ZS5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgaWYgKCFub3RlX3N0cnVjdCkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLFxuICAgICAgICAgICAgXCJOb3RlIG11c3QgaGF2ZSB2YWxpZCBpbml0aWFsaXphdGlvbiBkYXRhIHRvIGlkZW50aWZ5IFwiICtcbiAgICAgICAgICAgIFwiZHVyYXRpb24gYW5kIHR5cGUuXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBQYXJzZSBgbm90ZV9zdHJ1Y3RgIGFuZCBnZXQgbm90ZSBwcm9wZXJ0aWVzLlxuICAgICAgdmFyIGluaXREYXRhID0gVmV4LkZsb3cucGFyc2VOb3RlRGF0YShub3RlX3N0cnVjdCk7XG4gICAgICBpZiAoIWluaXREYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiQmFkQXJndW1lbnRzXCIsXG4gICAgICAgICAgICBcIkludmFsaWQgbm90ZSBpbml0aWFsaXphdGlvbiBvYmplY3Q6IFwiICsgSlNPTi5zdHJpbmdpZnkobm90ZV9zdHJ1Y3QpKTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IG5vdGUgcHJvcGVydGllcyBmcm9tIHBhcmFtZXRlcnMuXG4gICAgICB0aGlzLmR1cmF0aW9uID0gaW5pdERhdGEuZHVyYXRpb247XG4gICAgICB0aGlzLmRvdHMgPSBpbml0RGF0YS5kb3RzO1xuICAgICAgdGhpcy5ub3RlVHlwZSA9IGluaXREYXRhLnR5cGU7XG5cbiAgICAgIGlmIChub3RlX3N0cnVjdC5kdXJhdGlvbl9vdmVycmlkZSkge1xuICAgICAgICAvLyBDdXN0b20gZHVyYXRpb25cbiAgICAgICAgdGhpcy5zZXREdXJhdGlvbihub3RlX3N0cnVjdC5kdXJhdGlvbl9vdmVycmlkZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBEZWZhdWx0IGR1cmF0aW9uXG4gICAgICAgIHRoaXMuc2V0SW50cmluc2ljVGlja3MoaW5pdERhdGEudGlja3MpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLm1vZGlmaWVycyA9IFtdO1xuXG4gICAgICAvLyBHZXQgdGhlIGdseXBoIGNvZGUgZm9yIHRoaXMgbm90ZSBmcm9tIHRoZSBmb250LlxuICAgICAgdGhpcy5nbHlwaCA9IFZleC5GbG93LmR1cmF0aW9uVG9HbHlwaCh0aGlzLmR1cmF0aW9uLCB0aGlzLm5vdGVUeXBlKTtcblxuICAgICAgaWYgKHRoaXMucG9zaXRpb25zICYmXG4gICAgICAgICAgKHR5cGVvZih0aGlzLnBvc2l0aW9ucykgIT0gXCJvYmplY3RcIiB8fCAhdGhpcy5wb3NpdGlvbnMubGVuZ3RoKSkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcbiAgICAgICAgICBcIkJhZEFyZ3VtZW50c1wiLCBcIk5vdGUga2V5cyBtdXN0IGJlIGFycmF5IHR5cGUuXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBOb3RlIHRvIHBsYXkgZm9yIGF1ZGlvIHBsYXllcnMuXG4gICAgICB0aGlzLnBsYXlOb3RlID0gbnVsbDtcblxuICAgICAgLy8gUG9zaXRpb25pbmcgY29udGV4dHMgdXNlZCBieSB0aGUgRm9ybWF0dGVyLlxuICAgICAgdGhpcy50aWNrQ29udGV4dCA9IG51bGw7ICAgIC8vIFRoZSBjdXJyZW50IHRpY2sgY29udGV4dC5cbiAgICAgIHRoaXMubW9kaWZpZXJDb250ZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMuaWdub3JlX3RpY2tzID0gZmFsc2U7XG5cbiAgICAgIC8vIFBvc2l0aW9uaW5nIHZhcmlhYmxlc1xuICAgICAgdGhpcy53aWR0aCA9IDA7ICAgICAgICAgICAgIC8vIFdpZHRoIGluIHBpeGVscyBjYWxjdWxhdGVkIGFmdGVyIHByZUZvcm1hdFxuICAgICAgdGhpcy5leHRyYUxlZnRQeCA9IDA7ICAgICAgIC8vIEV4dHJhIHJvb20gb24gbGVmdCBmb3Igb2Zmc2V0IG5vdGUgaGVhZFxuICAgICAgdGhpcy5leHRyYVJpZ2h0UHggPSAwOyAgICAgIC8vIEV4dHJhIHJvb20gb24gcmlnaHQgZm9yIG9mZnNldCBub3RlIGhlYWRcbiAgICAgIHRoaXMueF9zaGlmdCA9IDA7ICAgICAgICAgICAvLyBYIHNoaWZ0IGZyb20gdGljayBjb250ZXh0IFhcbiAgICAgIHRoaXMubGVmdF9tb2RQeCA9IDA7ICAgICAgICAvLyBNYXggd2lkdGggb2YgbGVmdCBtb2RpZmllcnNcbiAgICAgIHRoaXMucmlnaHRfbW9kUHggPSAwOyAgICAgICAvLyBNYXggd2lkdGggb2YgcmlnaHQgbW9kaWZpZXJzXG4gICAgICB0aGlzLnZvaWNlID0gbnVsbDsgICAgICAgICAgLy8gVGhlIHZvaWNlIHRoYXQgdGhpcyBub3RlIGlzIGluXG4gICAgICB0aGlzLnByZUZvcm1hdHRlZCA9IGZhbHNlOyAgLy8gSXMgdGhpcyBub3RlIHByZUZvcm1hdHRlZD9cbiAgICAgIHRoaXMueXMgPSBbXTsgICAgICAgICAgICAgICAvLyBsaXN0IG9mIHkgY29vcmRpbmF0ZXMgZm9yIGVhY2ggbm90ZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIHdlIG5lZWQgdG8gaG9sZCBvbiB0byB0aGVzZSBmb3IgdGllcyBhbmQgYmVhbXMuXG5cbiAgICAgIGlmIChub3RlX3N0cnVjdC5hbGlnbl9jZW50ZXIpIHtcbiAgICAgICAgdGhpcy5zZXRDZW50ZXJBbGlnbm1lbnQobm90ZV9zdHJ1Y3QuYWxpZ25fY2VudGVyKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlbmRlciBzdXJmYWNlLlxuICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMuc3RhdmUgPSBudWxsO1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgYW5ub3RhdGlvbl9zcGFjaW5nOiA1LFxuICAgICAgICBzdGF2ZV9wYWRkaW5nOiAxMlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFuZCBzZXQgdGhlIHBsYXkgbm90ZSwgd2hpY2ggaXMgYXJiaXRyYXJ5IGRhdGEgdGhhdCBjYW4gYmUgdXNlZCBieSBhblxuICAgIC8vIGF1ZGlvIHBsYXllci5cbiAgICBnZXRQbGF5Tm90ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnBsYXlOb3RlOyB9LFxuICAgIHNldFBsYXlOb3RlOiBmdW5jdGlvbihub3RlKSB7IHRoaXMucGxheU5vdGUgPSBub3RlOyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIERvbid0IHBsYXkgbm90ZXMgYnkgZGVmYXVsdCwgY2FsbCB0aGVtIHJlc3RzLiBUaGlzIGlzIGFsc28gdXNlZCBieSB0aGluZ3MgbGlrZVxuICAgIC8vIGJlYW1zIGFuZCBkb3RzIGZvciBwb3NpdGlvbmluZy5cbiAgICBpc1Jlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0sXG5cbiAgICAvLyBUT0RPKDB4ZmUpOiBXaHkgaXMgdGhpcyBtZXRob2QgaGVyZT9cbiAgICBhZGRTdHJva2U6IGZ1bmN0aW9uKGluZGV4LCBzdHJva2UpIHtcbiAgICAgIHN0cm9rZS5zZXROb3RlKHRoaXMpO1xuICAgICAgc3Ryb2tlLnNldEluZGV4KGluZGV4KTtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2goc3Ryb2tlKTtcbiAgICAgIHRoaXMuc2V0UHJlRm9ybWF0dGVkKGZhbHNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYW5kIHNldCB0aGUgdGFyZ2V0IHN0YXZlLlxuICAgIGdldFN0YXZlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc3RhdmU7IH0sXG4gICAgc2V0U3RhdmU6IGZ1bmN0aW9uKHN0YXZlKSB7XG4gICAgICB0aGlzLnN0YXZlID0gc3RhdmU7XG4gICAgICB0aGlzLnNldFlzKFtzdGF2ZS5nZXRZRm9yTGluZSgwKV0pOyAvLyBVcGRhdGUgWSB2YWx1ZXMgaWYgdGhlIHN0YXZlIGlzIGNoYW5nZWQuXG4gICAgICB0aGlzLmNvbnRleHQgPSB0aGlzLnN0YXZlLmNvbnRleHQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG5cbiAgICAvLyBgTm90ZWAgaXMgbm90IHJlYWxseSBhIG1vZGlmaWVyLCBidXQgaXMgdXNlZCBpblxuICAgIC8vIGEgYE1vZGlmaWVyQ29udGV4dGAuXG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5DQVRFR09SWTsgfSxcblxuICAgIC8vIFNldCB0aGUgcmVuZGVyaW5nIGNvbnRleHQgZm9yIHRoZSBub3RlLlxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHsgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBHZXQgYW5kIHNldCBzcGFjaW5nIHRvIHRoZSBsZWZ0IGFuZCByaWdodCBvZiB0aGUgbm90ZXMuXG4gICAgZ2V0RXh0cmFMZWZ0UHg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5leHRyYUxlZnRQeDsgfSxcbiAgICBnZXRFeHRyYVJpZ2h0UHg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5leHRyYVJpZ2h0UHg7IH0sXG4gICAgc2V0RXh0cmFMZWZ0UHg6IGZ1bmN0aW9uKHgpIHsgdGhpcy5leHRyYUxlZnRQeCA9IHg7IHJldHVybiB0aGlzOyB9LFxuICAgIHNldEV4dHJhUmlnaHRQeDogZnVuY3Rpb24oeCkgeyB0aGlzLmV4dHJhUmlnaHRQeCA9IHg7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gUmV0dXJucyB0cnVlIGlmIHRoaXMgbm90ZSBoYXMgbm8gZHVyYXRpb24gKGUuZy4sIGJhciBub3Rlcywgc3BhY2VycywgZXRjLilcbiAgICBzaG91bGRJZ25vcmVUaWNrczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmlnbm9yZV90aWNrczsgfSxcblxuICAgIC8vIEdldCB0aGUgc3RhdmUgbGluZSBudW1iZXIgZm9yIHRoZSBub3RlLlxuICAgIGdldExpbmVOdW1iZXI6IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfSxcblxuICAgIC8vIEdldCB0aGUgc3RhdmUgbGluZSBudW1iZXIgZm9yIHJlc3QuXG4gICAgZ2V0TGluZUZvclJlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfSxcblxuICAgIC8vIEdldCB0aGUgZ2x5cGggYXNzb2NpYXRlZCB3aXRoIHRoaXMgbm90ZS5cbiAgICBnZXRHbHlwaDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmdseXBoOyB9LFxuXG4gICAgLy8gU2V0IGFuZCBnZXQgWSBwb3NpdGlvbnMgZm9yIHRoaXMgbm90ZS4gRWFjaCBZIHZhbHVlIGlzIGFzc29jaWF0ZWQgd2l0aFxuICAgIC8vIGFuIGluZGl2aWR1YWwgcGl0Y2gva2V5IHdpdGhpbiB0aGUgbm90ZS9jaG9yZC5cbiAgICBzZXRZczogZnVuY3Rpb24oeXMpIHsgdGhpcy55cyA9IHlzOyByZXR1cm4gdGhpczsgfSxcbiAgICBnZXRZczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy55cy5sZW5ndGggPT09IDApIHRocm93IG5ldyBWZXguUkVSUihcIk5vWVZhbHVlc1wiLFxuICAgICAgICAgIFwiTm8gWS12YWx1ZXMgY2FsY3VsYXRlZCBmb3IgdGhpcyBub3RlLlwiKTtcbiAgICAgIHJldHVybiB0aGlzLnlzO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIFkgcG9zaXRpb24gb2YgdGhlIHNwYWNlIGFib3ZlIHRoZSBzdGF2ZSBvbnRvIHdoaWNoIHRleHQgY2FuXG4gICAgLy8gYmUgcmVuZGVyZWQuXG4gICAgZ2V0WUZvclRvcFRleHQ6IGZ1bmN0aW9uKHRleHRfbGluZSkge1xuICAgICAgaWYgKCF0aGlzLnN0YXZlKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1N0YXZlXCIsXG4gICAgICAgICAgXCJObyBzdGF2ZSBhdHRhY2hlZCB0byB0aGlzIG5vdGUuXCIpO1xuICAgICAgcmV0dXJuIHRoaXMuc3RhdmUuZ2V0WUZvclRvcFRleHQodGV4dF9saW5lKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGEgYEJvdW5kaW5nQm94YCBmb3IgdGhpcyBub3RlLlxuICAgIGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbigpIHsgcmV0dXJuIG51bGw7IH0sXG5cbiAgICAvLyBSZXR1cm5zIHRoZSB2b2ljZSB0aGF0IHRoaXMgbm90ZSBiZWxvbmdzIGluLlxuICAgIGdldFZvaWNlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy52b2ljZSkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9Wb2ljZVwiLCBcIk5vdGUgaGFzIG5vIHZvaWNlLlwiKTtcbiAgICAgIHJldHVybiB0aGlzLnZvaWNlO1xuICAgIH0sXG5cbiAgICAvLyBBdHRhY2ggdGhpcyBub3RlIHRvIGB2b2ljZWAuXG4gICAgc2V0Vm9pY2U6IGZ1bmN0aW9uKHZvaWNlKSB7XG4gICAgICB0aGlzLnZvaWNlID0gdm9pY2U7XG4gICAgICB0aGlzLnByZUZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEdldCBhbmQgc2V0IHRoZSBgVGlja0NvbnRleHRgIGZvciB0aGlzIG5vdGUuXG4gICAgZ2V0VGlja0NvbnRleHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50aWNrQ29udGV4dDsgfSxcbiAgICBzZXRUaWNrQ29udGV4dDogZnVuY3Rpb24odGMpIHtcbiAgICAgIHRoaXMudGlja0NvbnRleHQgPSB0YztcbiAgICAgIHRoaXMucHJlRm9ybWF0dGVkID0gZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQWNjZXNzb3JzIGZvciB0aGUgbm90ZSB0eXBlLlxuICAgIGdldER1cmF0aW9uOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuZHVyYXRpb247IH0sXG4gICAgaXNEb3R0ZWQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gKHRoaXMuZG90cyA+IDApOyB9LFxuICAgIGhhc1N0ZW06IGZ1bmN0aW9uKCkgeyByZXR1cm4gZmFsc2U7IH0sXG4gICAgZ2V0RG90czogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRvdHM7IH0sXG4gICAgZ2V0Tm90ZVR5cGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5ub3RlVHlwZTsgfSxcbiAgICBzZXRCZWFtOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0sIC8vIGlnbm9yZSBwYXJhbWV0ZXJzXG5cbiAgICAvLyBBdHRhY2ggdGhpcyBub3RlIHRvIGEgbW9kaWZpZXIgY29udGV4dC5cbiAgICBzZXRNb2RpZmllckNvbnRleHQ6IGZ1bmN0aW9uKG1jKSB7IHRoaXMubW9kaWZpZXJDb250ZXh0ID0gbWM7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gQXR0YWNoIGEgbW9kaWZpZXIgdG8gdGhpcyBub3RlLlxuICAgIGFkZE1vZGlmaWVyOiBmdW5jdGlvbihtb2RpZmllciwgaW5kZXgpIHtcbiAgICAgIG1vZGlmaWVyLnNldE5vdGUodGhpcyk7XG4gICAgICBtb2RpZmllci5zZXRJbmRleChpbmRleCB8fCAwKTtcbiAgICAgIHRoaXMubW9kaWZpZXJzLnB1c2gobW9kaWZpZXIpO1xuICAgICAgdGhpcy5zZXRQcmVGb3JtYXR0ZWQoZmFsc2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgY29vcmRpbmF0ZXMgZm9yIHdoZXJlIG1vZGlmaWVycyBiZWdpbi5cbiAgICBnZXRNb2RpZmllclN0YXJ0WFk6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnByZUZvcm1hdHRlZCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiVW5mb3JtYXR0ZWROb3RlXCIsXG4gICAgICAgICAgXCJDYW4ndCBjYWxsIEdldE1vZGlmaWVyU3RhcnRYWSBvbiBhbiB1bmZvcm1hdHRlZCBub3RlXCIpO1xuICAgICAgcmV0dXJuIHt4OiB0aGlzLmdldEFic29sdXRlWCgpLCB5OiB0aGlzLnlzWzBdfTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGJvdW5kcyBhbmQgbWV0cmljcyBmb3IgdGhpcyBub3RlLlxuICAgIC8vXG4gICAgLy8gUmV0dXJucyBhIHN0cnVjdCB3aXRoIGZpZWxkczpcbiAgICAvLyBgd2lkdGhgOiBUaGUgdG90YWwgd2lkdGggb2YgdGhlIG5vdGUgKGluY2x1ZGluZyBtb2RpZmllcnMuKVxuICAgIC8vIGBub3RlV2lkdGhgOiBUaGUgd2lkdGggb2YgdGhlIG5vdGUgaGVhZCBvbmx5LlxuICAgIC8vIGBsZWZ0X3NoaWZ0YDogVGhlIGhvcml6b250YWwgZGlzcGxhY2VtZW50IG9mIHRoZSBub3RlLlxuICAgIC8vIGBtb2RMZWZ0UHhgOiBTdGFydCBgWGAgZm9yIGxlZnQgbW9kaWZpZXJzLlxuICAgIC8vIGBtb2RSaWdodFB4YDogU3RhcnQgYFhgIGZvciByaWdodCBtb2RpZmllcnMuXG4gICAgLy8gYGV4dHJhTGVmdFB4YDogRXh0cmEgc3BhY2Ugb24gbGVmdCBvZiBub3RlLlxuICAgIC8vIGBleHRyYVJpZ2h0UHhgOiBFeHRyYSBzcGFjZSBvbiByaWdodCBvZiBub3RlLlxuICAgIGdldE1ldHJpY3M6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnByZUZvcm1hdHRlZCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiVW5mb3JtYXR0ZWROb3RlXCIsXG4gICAgICAgICAgXCJDYW4ndCBjYWxsIGdldE1ldHJpY3Mgb24gYW4gdW5mb3JtYXR0ZWQgbm90ZS5cIik7XG4gICAgICB2YXIgbW9kTGVmdFB4ID0gMDtcbiAgICAgIHZhciBtb2RSaWdodFB4ID0gMDtcbiAgICAgIGlmICh0aGlzLm1vZGlmaWVyQ29udGV4dCAhPSBudWxsKSB7XG4gICAgICAgIG1vZExlZnRQeCA9IHRoaXMubW9kaWZpZXJDb250ZXh0LnN0YXRlLmxlZnRfc2hpZnQ7XG4gICAgICAgIG1vZFJpZ2h0UHggPSB0aGlzLm1vZGlmaWVyQ29udGV4dC5zdGF0ZS5yaWdodF9zaGlmdDtcbiAgICAgIH1cblxuICAgICAgdmFyIHdpZHRoID0gdGhpcy5nZXRXaWR0aCgpO1xuICAgICAgcmV0dXJuIHsgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgbm90ZVdpZHRoOiB3aWR0aCAtXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG1vZExlZnRQeCAtIG1vZFJpZ2h0UHggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmV4dHJhTGVmdFB4IC0gdGhpcy5leHRyYVJpZ2h0UHgsXG4gICAgICAgICAgICAgICBsZWZ0X3NoaWZ0OiB0aGlzLnhfc2hpZnQsIC8vIFRPRE8oMHhmZSk6IE1ha2Ugc3R5bGUgY29uc2lzdGVudFxuXG5cbiAgICAgICAgICAgICAgIC8vIE1vZGlmaWVycywgYWNjaWRlbnRhbHMgZXRjLlxuICAgICAgICAgICAgICAgbW9kTGVmdFB4OiBtb2RMZWZ0UHgsXG4gICAgICAgICAgICAgICBtb2RSaWdodFB4OiBtb2RSaWdodFB4LFxuXG4gICAgICAgICAgICAgICAvLyBEaXNwbGFjZWQgbm90ZSBoZWFkIG9uIGxlZnQgb3IgcmlnaHQuXG4gICAgICAgICAgICAgICBleHRyYUxlZnRQeDogdGhpcy5leHRyYUxlZnRQeCxcbiAgICAgICAgICAgICAgIGV4dHJhUmlnaHRQeDogdGhpcy5leHRyYVJpZ2h0UHggfTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFuZCBzZXQgd2lkdGggb2Ygbm90ZS4gVXNlZCBieSB0aGUgZm9ybWF0dGVyIGZvciBwb3NpdGlvbmluZy5cbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpIHsgdGhpcy53aWR0aCA9IHdpZHRoOyB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5wcmVGb3JtYXR0ZWQpIHRocm93IG5ldyBWZXguUkVSUihcIlVuZm9ybWF0dGVkTm90ZVwiLFxuICAgICAgICAgIFwiQ2FuJ3QgY2FsbCBHZXRXaWR0aCBvbiBhbiB1bmZvcm1hdHRlZCBub3RlLlwiKTtcbiAgICAgIHJldHVybiB0aGlzLndpZHRoICtcbiAgICAgICAgKHRoaXMubW9kaWZpZXJDb250ZXh0ID8gIHRoaXMubW9kaWZpZXJDb250ZXh0LmdldFdpZHRoKCkgOiAwKTtcbiAgICB9LFxuXG4gICAgLy8gRGlzcGxhY2Ugbm90ZSBieSBgeGAgcGl4ZWxzLiBVc2VkIGJ5IHRoZSBmb3JtYXR0ZXIuXG4gICAgc2V0WFNoaWZ0OiBmdW5jdGlvbih4KSB7IHRoaXMueF9zaGlmdCA9IHg7IHJldHVybiB0aGlzOyB9LFxuICAgIGdldFhTaGlmdDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnhfc2hpZnQ7IH0sXG5cbiAgICAvLyBHZXQgYFhgIHBvc2l0aW9uIG9mIHRoaXMgdGljayBjb250ZXh0LlxuICAgIGdldFg6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnRpY2tDb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1RpY2tDb250ZXh0XCIsXG4gICAgICAgICAgXCJOb3RlIG5lZWRzIGEgVGlja0NvbnRleHQgYXNzaWduZWQgZm9yIGFuIFgtVmFsdWVcIik7XG4gICAgICByZXR1cm4gdGhpcy50aWNrQ29udGV4dC5nZXRYKCkgKyB0aGlzLnhfc2hpZnQ7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgYWJzb2x1dGUgYFhgIHBvc2l0aW9uIG9mIHRoaXMgbm90ZSdzIHRpY2sgY29udGV4dC4gVGhpc1xuICAgIC8vIGV4Y2x1ZGVzIHhfc2hpZnQsIHNvIHlvdSdsbCBuZWVkIHRvIGZhY3RvciBpdCBpbiBpZiB5b3UncmVcbiAgICAvLyBsb29raW5nIGZvciB0aGUgcG9zdC1mb3JtYXR0ZWQgeC1wb3NpdGlvbi5cbiAgICBnZXRBYnNvbHV0ZVg6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnRpY2tDb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1RpY2tDb250ZXh0XCIsXG4gICAgICAgICAgXCJOb3RlIG5lZWRzIGEgVGlja0NvbnRleHQgYXNzaWduZWQgZm9yIGFuIFgtVmFsdWVcIik7XG5cbiAgICAgIC8vIFBvc2l0aW9uIG5vdGUgdG8gbGVmdCBlZGdlIG9mIHRpY2sgY29udGV4dC5cbiAgICAgIHZhciB4ID0gdGhpcy50aWNrQ29udGV4dC5nZXRYKCk7XG4gICAgICBpZiAodGhpcy5zdGF2ZSkge1xuICAgICAgICB4ICs9IHRoaXMuc3RhdmUuZ2V0Tm90ZVN0YXJ0WCgpICsgdGhpcy5yZW5kZXJfb3B0aW9ucy5zdGF2ZV9wYWRkaW5nO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5pc0NlbnRlckFsaWduZWQoKSl7XG4gICAgICAgIHggKz0gdGhpcy5nZXRDZW50ZXJYU2hpZnQoKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHg7XG4gICAgfSxcblxuICAgIHNldFByZUZvcm1hdHRlZDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMucHJlRm9ybWF0dGVkID0gdmFsdWU7XG5cbiAgICAgIC8vIE1haW50YWluIHRoZSB3aWR0aCBvZiBsZWZ0IGFuZCByaWdodCBtb2RpZmllcnMgaW4gcGl4ZWxzLlxuICAgICAgaWYgKHRoaXMucHJlRm9ybWF0dGVkKSB7XG4gICAgICAgIHZhciBleHRyYSA9IHRoaXMudGlja0NvbnRleHQuZ2V0RXh0cmFQeCgpO1xuICAgICAgICB0aGlzLmxlZnRfbW9kUHggPSBNYXRoLm1heCh0aGlzLmxlZnRfbW9kUHgsIGV4dHJhLmxlZnQpO1xuICAgICAgICB0aGlzLnJpZ2h0X21vZFB4ID0gTWF0aC5tYXgodGhpcy5yaWdodF9tb2RQeCwgZXh0cmEucmlnaHQpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIE5vdGU7XG59KCkpO1xuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBUaGlzIGZpbGUgaW1wbGVtZW50cyBgTm90ZUhlYWRzYC4gYE5vdGVIZWFkc2AgYXJlIHR5cGljYWxseSBub3QgbWFuaXB1bGF0ZWRcbi8vIGRpcmVjdGx5LCBidXQgdXNlZCBpbnRlcm5hbGx5IGluIGBTdGF2ZU5vdGVgLlxuLy9cbi8vIFNlZSBgdGVzdHMvbm90ZWhlYWRfdGVzdHMuanNgIGZvciB1c2FnZSBleGFtcGxlcy5cblZleC5GbG93Lk5vdGVIZWFkID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgTm90ZUhlYWQgPSBmdW5jdGlvbihoZWFkX29wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChoZWFkX29wdGlvbnMpO1xuICB9O1xuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93Lk5vdGVIZWFkLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChOb3RlSGVhZC5ERUJVRykgVmV4LkwoXCJWZXguRmxvdy5Ob3RlSGVhZFwiLCBhcmd1bWVudHMpOyB9XG5cblxuICAvLyBEcmF3IHNsYXNobm90ZSBoZWFkIG1hbnVhbGx5LiBObyBnbHlwaCBleGlzdHMgZm9yIHRoaXMuXG4gIC8vXG4gIC8vIFBhcmFtZXRlcnM6XG4gIC8vICogYGN0eGA6IHRoZSBDYW52YXMgY29udGV4dFxuICAvLyAqIGBkdXJhdGlvbmA6IHRoZSBkdXJhdGlvbiBvZiB0aGUgbm90ZS4gZXg6IFwiNFwiXG4gIC8vICogYHhgOiB0aGUgeCBjb29yZGluYXRlIHRvIGRyYXcgYXRcbiAgLy8gKiBgeWA6IHRoZSB5IGNvb3JkaW5hdGUgdG8gZHJhdyBhdFxuICAvLyAqIGBzdGVtX2RpcmVjdGlvbmA6IHRoZSBkaXJlY3Rpb24gb2YgdGhlIHN0ZW1cbiAgZnVuY3Rpb24gZHJhd1NsYXNoTm90ZUhlYWQoY3R4LCBkdXJhdGlvbiwgeCwgeSwgc3RlbV9kaXJlY3Rpb24pIHtcbiAgICB2YXIgd2lkdGggPSAxNSArIChWZXguRmxvdy5TVEVNX1dJRFRIIC8gMik7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguc2V0TGluZVdpZHRoKFZleC5GbG93LlNURU1fV0lEVEgpO1xuXG4gICAgdmFyIGZpbGwgPSBmYWxzZTtcblxuICAgIGlmIChWZXguRmxvdy5kdXJhdGlvblRvTnVtYmVyKGR1cmF0aW9uKSA+IDIpIHtcbiAgICAgIGZpbGwgPSB0cnVlO1xuICAgIH1cblxuICAgIGlmICghZmlsbCkgeCAtPSAoVmV4LkZsb3cuU1RFTV9XSURUSCAvIDIpICogc3RlbV9kaXJlY3Rpb247XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgY3R4Lm1vdmVUbyh4LCB5ICsgMTEpO1xuICAgIGN0eC5saW5lVG8oeCwgeSArIDEpO1xuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5IC0gMTApO1xuICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5KTtcbiAgICBjdHgubGluZVRvKHgsIHkgKyAxMSk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgaWYgKGZpbGwpIHtcbiAgICAgICBjdHguZmlsbCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH1cblxuICAgIGlmIChWZXguRmxvdy5kdXJhdGlvblRvRnJhY3Rpb24oZHVyYXRpb24pLmVxdWFscygwLjUpKSB7XG4gICAgICB2YXIgYnJldmVfbGluZXMgPSBbLTMsIC0xLCB3aWR0aCArIDEsIHdpZHRoICsgM107XG4gICAgICBmb3IodmFyIGk9MDsgaTxicmV2ZV9saW5lcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCArIGJyZXZlX2xpbmVzW2ldLCB5IC0gMTApO1xuICAgICAgICAgIGN0eC5saW5lVG8oeCArIGJyZXZlX2xpbmVzW2ldLCB5ICsgMTEpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgVmV4LkluaGVyaXQoTm90ZUhlYWQsIFZleC5GbG93Lk5vdGUsIHtcbiAgICBpbml0OiBmdW5jdGlvbihoZWFkX29wdGlvbnMpIHtcbiAgICAgIE5vdGVIZWFkLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIGhlYWRfb3B0aW9ucyk7XG4gICAgICB0aGlzLmluZGV4ID0gaGVhZF9vcHRpb25zLmluZGV4O1xuICAgICAgdGhpcy54ID0gaGVhZF9vcHRpb25zLnggfHwgMDtcbiAgICAgIHRoaXMueSA9IGhlYWRfb3B0aW9ucy55IHx8IDA7XG4gICAgICB0aGlzLm5vdGVfdHlwZSA9IGhlYWRfb3B0aW9ucy5ub3RlX3R5cGU7XG4gICAgICB0aGlzLmR1cmF0aW9uID0gaGVhZF9vcHRpb25zLmR1cmF0aW9uO1xuICAgICAgdGhpcy5kaXNwbGFjZWQgPSBoZWFkX29wdGlvbnMuZGlzcGxhY2VkIHx8IGZhbHNlO1xuICAgICAgdGhpcy5zdGVtX2RpcmVjdGlvbiA9IGhlYWRfb3B0aW9ucy5zdGVtX2RpcmVjdGlvbiB8fCBWZXguRmxvdy5TdGF2ZU5vdGUuU1RFTV9VUDtcbiAgICAgIHRoaXMubGluZSA9IGhlYWRfb3B0aW9ucy5saW5lO1xuXG4gICAgICAvLyBHZXQgZ2x5cGggY29kZSBiYXNlZCBvbiBkdXJhdGlvbiBhbmQgbm90ZSB0eXBlLiBUaGlzIGNvdWxkIGJlXG4gICAgICAvLyByZWd1bGFyIG5vdGVzLCByZXN0cywgb3Igb3RoZXIgY3VzdG9tIGNvZGVzLlxuICAgICAgdGhpcy5nbHlwaCA9IFZleC5GbG93LmR1cmF0aW9uVG9HbHlwaCh0aGlzLmR1cmF0aW9uLCB0aGlzLm5vdGVfdHlwZSk7XG4gICAgICBpZiAoIXRoaXMuZ2x5cGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgIFwiTm8gZ2x5cGggZm91bmQgZm9yIGR1cmF0aW9uICdcIiArIHRoaXMuZHVyYXRpb24gK1xuICAgICAgICAgICAgXCInIGFuZCB0eXBlICdcIiArIHRoaXMubm90ZV90eXBlICsgXCInXCIpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmdseXBoX2NvZGUgPSB0aGlzLmdseXBoLmNvZGVfaGVhZDtcbiAgICAgIHRoaXMueF9zaGlmdCA9IGhlYWRfb3B0aW9ucy54X3NoaWZ0O1xuICAgICAgaWYgKGhlYWRfb3B0aW9ucy5jdXN0b21fZ2x5cGhfY29kZSkge1xuICAgICAgICB0aGlzLmN1c3RvbV9nbHlwaCA9IHRydWU7XG4gICAgICAgIHRoaXMuZ2x5cGhfY29kZSA9IGhlYWRfb3B0aW9ucy5jdXN0b21fZ2x5cGhfY29kZTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMuc3R5bGUgPSBoZWFkX29wdGlvbnMuc3R5bGU7XG4gICAgICB0aGlzLnNsYXNoZWQgPSBoZWFkX29wdGlvbnMuc2xhc2hlZDtcblxuICAgICAgVmV4Lk1lcmdlKHRoaXMucmVuZGVyX29wdGlvbnMsIHtcbiAgICAgICAgZ2x5cGhfZm9udF9zY2FsZTogMzUsIC8vIGZvbnQgc2l6ZSBmb3Igbm90ZSBoZWFkc1xuICAgICAgICBzdHJva2VfcHg6IDMgICAgICAgICAvLyBudW1iZXIgb2Ygc3Ryb2tlIHB4IHRvIHRoZSBsZWZ0IGFuZCByaWdodCBvZiBoZWFkXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhlYWRfb3B0aW9ucy5nbHlwaF9mb250X3NjYWxlKSB7XG4gICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuZ2x5cGhfZm9udF9zY2FsZSA9IGhlYWRfb3B0aW9ucy5nbHlwaF9mb250X3NjYWxlO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFdpZHRoKHRoaXMuZ2x5cGguaGVhZF93aWR0aCk7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgYE1vZGlmaWVyQ29udGV4dGAgY2F0ZWdvcnlcbiAgICBnZXRDYXRlZ29yeTogZnVuY3Rpb24oKSB7IHJldHVybiBcIm5vdGVoZWFkXCI7IH0sXG5cbiAgICAvLyBTZXQgdGhlIENhdm5hcyBjb250ZXh0IGZvciBkcmF3aW5nXG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkgeyB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyByZXR1cm4gdGhpczt9LFxuXG4gICAgLy8gR2V0IHRoZSB3aWR0aCBvZiB0aGUgbm90ZWhlYWRcbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLndpZHRoOyB9LFxuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSBub3RlaGVhZCBpcyBkaXNwbGFjZWRcbiAgICBpc0Rpc3BsYWNlZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmRpc3BsYWNlZCA9PT0gdHJ1ZTsgfSxcblxuICAgIC8vIEdldC9zZXQgdGhlIG5vdGVoZWFkJ3Mgc3R5bGVcbiAgICAvL1xuICAgIC8vIGBzdHlsZWAgaXMgYW4gYG9iamVjdGAgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IGBzaGFkb3dDb2xvcmAsXG4gICAgLy8gYHNoYWRvd0JsdXJgLCBgZmlsbFN0eWxlYCwgYHN0cm9rZVN0eWxlYFxuICAgIGdldFN0eWxlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc3R5bGU7IH0sXG4gICAgc2V0U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7IHRoaXMuc3R5bGUgPSBzdHlsZTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBHZXQgdGhlIGdseXBoIGRhdGFcbiAgICBnZXRHbHlwaDogZnVuY3Rpb24oKXsgcmV0dXJuIHRoaXMuZ2x5cGg7IH0sXG5cbiAgICAvLyBTZXQgdGhlIFggY29vcmRpbmF0ZVxuICAgIHNldFg6IGZ1bmN0aW9uKHgpeyB0aGlzLnggPSB4OyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIGdldC9zZXQgdGhlIFkgY29vcmRpbmF0ZVxuICAgIGdldFk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy55OyB9LFxuICAgIHNldFk6IGZ1bmN0aW9uKHkpIHsgdGhpcy55ID0geTsgIHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gR2V0L3NldCB0aGUgc3RhdmUgbGluZSB0aGUgbm90ZWhlYWQgaXMgcGxhY2VkIG9uXG4gICAgZ2V0TGluZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmxpbmU7IH0sXG4gICAgc2V0TGluZTogZnVuY3Rpb24obGluZSkgeyB0aGlzLmxpbmUgPSBsaW5lOyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIEdldCB0aGUgY2FudmFzIGB4YCBjb29yZGluYXRlIHBvc2l0aW9uIG9mIHRoZSBub3RlaGVhZC5cbiAgICBnZXRBYnNvbHV0ZVg6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGdldEFic29sdXRlWCA9IE5vdGVIZWFkLnN1cGVyY2xhc3MuZ2V0QWJzb2x1dGVYO1xuXG4gICAgICAvLyBJZiB0aGUgbm90ZSBoYXMgbm90IGJlZW4gcHJlZm9ybWF0dGVkLCB0aGVuIGdldCB0aGUgc3RhdGljIHggdmFsdWVcbiAgICAgIC8vIE90aGVyd2lzZSwgaXQncyBiZWVuIGZvcm1hdHRlZCBhbmQgd2Ugc2hvdWxkIHVzZSBpdCdzIHggdmFsdWUgcmVsYXRpdmVcbiAgICAgIC8vIHRvIGl0cyB0aWNrIGNvbnRleHRcbiAgICAgIHZhciB4ID0gIXRoaXMucHJlRm9ybWF0dGVkID8gdGhpcy54IDogZ2V0QWJzb2x1dGVYLmNhbGwodGhpcyk7XG5cbiAgICAgIHJldHVybiB4ICsgKHRoaXMuZGlzcGxhY2VkID8gdGhpcy53aWR0aCAqIHRoaXMuc3RlbV9kaXJlY3Rpb24gOiAwKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBgQm91bmRpbmdCb3hgIGZvciB0aGUgYE5vdGVIZWFkYFxuICAgIGdldEJvdW5kaW5nQm94OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5wcmVGb3JtYXR0ZWQpIHRocm93IG5ldyBWZXguUkVSUihcIlVuZm9ybWF0dGVkTm90ZVwiLFxuICAgICAgICAgIFwiQ2FuJ3QgY2FsbCBnZXRCb3VuZGluZ0JveCBvbiBhbiB1bmZvcm1hdHRlZCBub3RlLlwiKTtcblxuICAgICAgdmFyIHNwYWNpbmcgPSB0aGlzLnN0YXZlLmdldFNwYWNpbmdCZXR3ZWVuTGluZXMoKTtcbiAgICAgIHZhciBoYWxmX3NwYWNpbmcgPSBzcGFjaW5nLzI7XG4gICAgICB2YXIgbWluX3kgPSB0aGlzLnkgLSBoYWxmX3NwYWNpbmc7XG5cbiAgICAgIHJldHVybiBuZXcgVmV4LkZsb3cuQm91bmRpbmdCb3godGhpcy5nZXRBYnNvbHV0ZVgoKSwgbWluX3ksIHRoaXMud2lkdGgsIHNwYWNpbmcpO1xuICAgIH0sXG5cbiAgICAvLyBBcHBseSBjdXJyZW50IHN0eWxlIHRvIENhbnZhcyBgY29udGV4dGBcbiAgICBhcHBseVN0eWxlOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLmdldFN0eWxlKCk7XG4gICAgICBpZiAoc3R5bGUuc2hhZG93Q29sb3IpIGNvbnRleHQuc2V0U2hhZG93Q29sb3Ioc3R5bGUuc2hhZG93Q29sb3IpO1xuICAgICAgaWYgKHN0eWxlLnNoYWRvd0JsdXIpIGNvbnRleHQuc2V0U2hhZG93Qmx1cihzdHlsZS5zaGFkb3dCbHVyKTtcbiAgICAgIGlmIChzdHlsZS5maWxsU3R5bGUpIGNvbnRleHQuc2V0RmlsbFN0eWxlKHN0eWxlLmZpbGxTdHlsZSk7XG4gICAgICBpZiAoc3R5bGUuc3Ryb2tlU3R5bGUpIGNvbnRleHQuc2V0U3Ryb2tlU3R5bGUoc3R5bGUuc3Ryb2tlU3R5bGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFNldCBub3RlaGVhZCB0byBhIHByb3ZpZGVkIGBzdGF2ZWBcbiAgICBzZXRTdGF2ZTogZnVuY3Rpb24oc3RhdmUpe1xuICAgICAgdmFyIGxpbmUgPSB0aGlzLmdldExpbmUoKTtcblxuICAgICAgdGhpcy5zdGF2ZSA9IHN0YXZlO1xuICAgICAgdGhpcy5zZXRZKHN0YXZlLmdldFlGb3JOb3RlKGxpbmUpKTtcbiAgICAgIHRoaXMuY29udGV4dCA9IHRoaXMuc3RhdmUuY29udGV4dDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBQcmUtcmVuZGVyIGZvcm1hdHRpbmdcbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucHJlRm9ybWF0dGVkKSByZXR1cm4gdGhpcztcblxuICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaCgpO1xuICAgICAgdmFyIHdpZHRoID0gZ2x5cGguaGVhZF93aWR0aCArIHRoaXMuZXh0cmFMZWZ0UHggKyB0aGlzLmV4dHJhUmlnaHRQeDtcblxuICAgICAgdGhpcy5zZXRXaWR0aCh3aWR0aCk7XG4gICAgICB0aGlzLnNldFByZUZvcm1hdHRlZCh0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBEcmF3IHRoZSBub3RlaGVhZFxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ2FudmFzQ29udGV4dFwiLFxuICAgICAgICAgIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgY2FudmFzIGNvbnRleHQuXCIpO1xuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIGhlYWRfeCA9IHRoaXMuZ2V0QWJzb2x1dGVYKCk7XG4gICAgICB2YXIgeSA9IHRoaXMueTtcblxuICAgICAgTChcIkRyYXdpbmcgbm90ZSBoZWFkICdcIiwgdGhpcy5ub3RlX3R5cGUsIHRoaXMuZHVyYXRpb24sIFwiJyBhdFwiLCBoZWFkX3gsIHkpO1xuXG4gICAgICAvLyBCZWdpbiBhbmQgZW5kIHBvc2l0aW9ucyBmb3IgaGVhZC5cbiAgICAgIHZhciBzdGVtX2RpcmVjdGlvbiA9IHRoaXMuc3RlbV9kaXJlY3Rpb247XG4gICAgICB2YXIgZ2x5cGhfZm9udF9zY2FsZSA9IHRoaXMucmVuZGVyX29wdGlvbnMuZ2x5cGhfZm9udF9zY2FsZTtcblxuICAgICAgdmFyIGxpbmUgPSB0aGlzLmxpbmU7XG5cbiAgICAgIC8vIElmIG5vdGUgYWJvdmUvYmVsb3cgdGhlIHN0YWZmLCBkcmF3IHRoZSBzbWFsbCBzdGFmZlxuICAgICAgaWYgKGxpbmUgPD0gMCB8fCBsaW5lID49IDYpIHtcbiAgICAgICAgdmFyIGxpbmVfeSA9IHk7XG4gICAgICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3IobGluZSk7XG4gICAgICAgIGlmIChsaW5lIDwgMCAmJiBmbG9vciAtIGxpbmUgPT0gLTAuNSlcbiAgICAgICAgICBsaW5lX3kgLT0gNTtcbiAgICAgICAgZWxzZSBpZiAobGluZSA+IDYgJiYgIGZsb29yIC0gbGluZSA9PSAtMC41KVxuICAgICAgICAgIGxpbmVfeSArPSA1O1xuICAgICAgICBpZiAodGhpcy5ub3RlX3R5cGUgIT0gJ3InKSB7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KFxuICAgICAgICAgICAgaGVhZF94IC0gdGhpcy5yZW5kZXJfb3B0aW9ucy5zdHJva2VfcHgsIGxpbmVfeSxcbiAgICAgICAgICAgICh0aGlzLmdldEdseXBoKCkuaGVhZF93aWR0aCkgK1xuICAgICAgICAgICAgKHRoaXMucmVuZGVyX29wdGlvbnMuc3Ryb2tlX3B4ICogMiksIDEpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLm5vdGVfdHlwZSA9PSBcInNcIikge1xuICAgICAgICBkcmF3U2xhc2hOb3RlSGVhZChjdHgsIHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgaGVhZF94LCB5LCBzdGVtX2RpcmVjdGlvbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAodGhpcy5zdHlsZSkge1xuICAgICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgICAgdGhpcy5hcHBseVN0eWxlKGN0eCk7XG4gICAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgoY3R4LCBoZWFkX3gsIHksIGdseXBoX2ZvbnRfc2NhbGUsIHRoaXMuZ2x5cGhfY29kZSk7XG4gICAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBWZXguRmxvdy5yZW5kZXJHbHlwaChjdHgsIGhlYWRfeCwgeSwgZ2x5cGhfZm9udF9zY2FsZSwgdGhpcy5nbHlwaF9jb2RlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIE5vdGVIZWFkO1xufSgpKTtcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBUaGlzIGZpbGUgaW1wbGVtZW50cyB0aGUgYFN0ZW1gIG9iamVjdC4gR2VuZXJhbGx5IHRoaXMgb2JqZWN0IGlzIGhhbmRsZWRcbi8vIGJ5IGl0cyBwYXJlbnQgYFN0ZW1tYWJsZU5vdGVgLlxuLy9cblZleC5GbG93LlN0ZW0gPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBTdGVtID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG9wdGlvbnMpO1xuICB9O1xuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93LlN0ZW0uREVCVUdgIHRvIGB0cnVlYC5cbiAgZnVuY3Rpb24gTCgpIHsgaWYgKFN0ZW0uREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuU3RlbVwiLCBhcmd1bWVudHMpOyB9XG5cbiAgLy8gU3RlbSBkaXJlY3Rpb25zXG4gIFN0ZW0uVVAgPSAxO1xuICBTdGVtLkRPV04gPSAtMTtcblxuICAvLyBUaGVtZVxuICBTdGVtLldJRFRIID0gVmV4LkZsb3cuU1RFTV9XSURUSDtcbiAgU3RlbS5IRUlHSFQgPSBWZXguRmxvdy5TVEVNX0hFSUdIVDtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICBTdGVtLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbihvcHRpb25zKSB7XG4gICAgICAvLyBEZWZhdWx0IG5vdGVoZWFkIHggYm91bmRzXG4gICAgICB0aGlzLnhfYmVnaW4gPSBvcHRpb25zLnhfYmVnaW4gfHwgMDtcbiAgICAgIHRoaXMueF9lbmQgPSBvcHRpb25zLnhfZW5kIHx8IDA7XG5cbiAgICAgIC8vIFkgYm91bmRzIGZvciB0b3AvYm90dG9tIG1vc3Qgbm90ZWhlYWRcbiAgICAgIHRoaXMueV90b3AgPSBvcHRpb25zLnlfdG9wIHx8IDA7XG4gICAgICB0aGlzLnlfYm90dG9tID0gb3B0aW9ucy55X2JvdHRvbSB8fCAwO1xuXG4gICAgICAvLyBTdGVtIGJhc2UgZXh0ZW5zaW9uXG4gICAgICB0aGlzLnlfZXh0ZW5kID0gb3B0aW9ucy55X2V4dGVuZCB8fCAwO1xuICAgICAgLy8gU3RlbSB0b3AgZXh0ZW5zaW9uXG4gICAgICB0aGlzLnN0ZW1fZXh0ZW5zaW9uID0gb3B0aW9ucy5zdGVtX2V4dGVuc2lvbiB8fCAwO1xuXG4gICAgICAvLyBEaXJlY3Rpb24gb2YgdGhlIHN0ZW1cbiAgICAgIHRoaXMuc3RlbV9kaXJlY3Rpb24gPSBvcHRpb25zLnN0ZW1fZGlyZWN0aW9uIHx8IDA7XG5cbiAgICAgIC8vIEZsYWcgdG8gb3ZlcnJpZGUgYWxsIGRyYXcgY2FsbHNcbiAgICAgIHRoaXMuaGlkZSA9IGZhbHNlO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIHggYm91bmRzIGZvciB0aGUgZGVmYXVsdCBub3RlaGVhZFxuICAgIHNldE5vdGVIZWFkWEJvdW5kczogZnVuY3Rpb24oeF9iZWdpbiwgeF9lbmQpIHtcbiAgICAgIHRoaXMueF9iZWdpbiA9IHhfYmVnaW47XG4gICAgICB0aGlzLnhfZW5kID0geF9lbmQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2V0IHRoZSBkaXJlY3Rpb24gb2YgdGhlIHN0ZW0gaW4gcmVsYXRpb24gdG8gdGhlIG5vdGVoZWFkc1xuICAgIHNldERpcmVjdGlvbjogZnVuY3Rpb24oZGlyZWN0aW9uKXsgdGhpcy5zdGVtX2RpcmVjdGlvbiA9IGRpcmVjdGlvbjsgfSxcblxuICAgIC8vIFNldCB0aGUgZXh0ZW5zaW9uIGZvciB0aGUgc3RlbSwgZ2VuZXJhbGx5IGZvciBmbGFncyBvciBiZWFtc1xuICAgIHNldEV4dGVuc2lvbjogZnVuY3Rpb24oZXh0KSB7IHRoaXMuc3RlbV9leHRlbnNpb24gPSBleHQ7IH0sXG5cbiAgICAvLyBUaGUgdGhlIHkgYm91bmRzIGZvciB0aGUgdG9wIGFuZCBib3R0b20gbm90ZWhlYWRzXG4gICAgc2V0WUJvdW5kczogZnVuY3Rpb24oeV90b3AsIHlfYm90dG9tKSB7XG4gICAgICB0aGlzLnlfdG9wID0geV90b3A7XG4gICAgICB0aGlzLnlfYm90dG9tID0geV9ib3R0b207XG4gICAgfSxcblxuICAgIC8vIFRoZSBjYXRlZ29yeSBvZiB0aGUgb2JqZWN0XG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJzdGVtXCI7IH0sXG5cbiAgICAvLyBTZXQgdGhlIGNhbnZhcyBjb250ZXh0IHRvIHJlbmRlciBvblxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHsgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgcmV0dXJuIHRoaXM7fSxcblxuICAgIC8vIEdldHMgdGhlIGVudGlyZSBoZWlnaHQgZm9yIHRoZSBzdGVtXG4gICAgZ2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoKHRoaXMueV9ib3R0b20gLSB0aGlzLnlfdG9wKSAqIHRoaXMuc3RlbV9kaXJlY3Rpb24pICtcbiAgICAgICAgICAgICAoKFN0ZW0uSEVJR0hUICsgdGhpcy5zdGVtX2V4dGVuc2lvbikgKiB0aGlzLnN0ZW1fZGlyZWN0aW9uKTtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm90SW1wbGVtZW50ZWRcIiwgXCJnZXRCb3VuZGluZ0JveCgpIG5vdCBpbXBsZW1lbnRlZC5cIik7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgeSBjb29yZGluYXRlcyBmb3IgdGhlIHZlcnkgYmFzZSBvZiB0aGUgc3RlbSB0byB0aGUgdG9wIG9mXG4gICAgLy8gdGhlIGV4dGVuc2lvblxuICAgIGdldEV4dGVudHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHlzID0gW3RoaXMueV90b3AsIHRoaXMueV9ib3R0b21dO1xuXG4gICAgICB2YXIgdG9wX3BpeGVsID0gdGhpcy55X3RvcDtcbiAgICAgIHZhciBiYXNlX3BpeGVsID0gdGhpcy55X2JvdHRvbTtcbiAgICAgIHZhciBzdGVtX2hlaWdodCA9IFN0ZW0uSEVJR0hUICsgdGhpcy5zdGVtX2V4dGVuc2lvbjtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc3RlbV90b3AgPSB5c1tpXSArIChzdGVtX2hlaWdodCAqIC10aGlzLnN0ZW1fZGlyZWN0aW9uKTtcblxuICAgICAgICBpZiAodGhpcy5zdGVtX2RpcmVjdGlvbiA9PSBTdGVtLkRPV04pIHtcbiAgICAgICAgICB0b3BfcGl4ZWwgPSBNYXRoLm1heCh0b3BfcGl4ZWwsIHN0ZW1fdG9wKTtcbiAgICAgICAgICBiYXNlX3BpeGVsID0gTWF0aC5taW4oYmFzZV9waXhlbCwgeXNbaV0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRvcF9waXhlbCA9IE1hdGgubWluKHRvcF9waXhlbCwgc3RlbV90b3ApO1xuICAgICAgICAgIGJhc2VfcGl4ZWwgPSBNYXRoLm1heChiYXNlX3BpeGVsLCB5c1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgdG9wWTogdG9wX3BpeGVsLCBiYXNlWTogYmFzZV9waXhlbCB9O1xuICAgIH0sXG5cbiAgICAvLyBzZXQgdGhlIGRyYXcgc3R5bGUgb2YgYSBzdGVtOlxuICAgIHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkgeyB0aGlzLnN0eWxlID0gc3R5bGU7IHJldHVybiB0aGlzOyB9LFxuICAgIGdldFN0eWxlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc3R5bGU7IH0sXG5cbiAgICAvLyBBcHBseSBjdXJyZW50IHN0eWxlIHRvIENhbnZhcyBgY29udGV4dGBcbiAgICBhcHBseVN0eWxlOiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB2YXIgc3R5bGUgPSB0aGlzLmdldFN0eWxlKCk7XG4gICAgICBpZihzdHlsZSkge1xuICAgICAgICBpZiAoc3R5bGUuc2hhZG93Q29sb3IpIGNvbnRleHQuc2V0U2hhZG93Q29sb3Ioc3R5bGUuc2hhZG93Q29sb3IpO1xuICAgICAgICBpZiAoc3R5bGUuc2hhZG93Qmx1cikgY29udGV4dC5zZXRTaGFkb3dCbHVyKHN0eWxlLnNoYWRvd0JsdXIpO1xuICAgICAgICBpZiAoc3R5bGUuc3Ryb2tlU3R5bGUpIGNvbnRleHQuc2V0U3Ryb2tlU3R5bGUoc3R5bGUuc3Ryb2tlU3R5bGUpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbmRlciB0aGUgc3RlbSBvbnRvIHRoZSBjYW52YXNcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgd2l0aG91dCBhIGNhbnZhcyBjb250ZXh0LlwiKTtcblxuICAgICAgaWYgKHRoaXMuaGlkZSkgcmV0dXJuO1xuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIHN0ZW1feCwgc3RlbV95O1xuICAgICAgdmFyIHN0ZW1fZGlyZWN0aW9uID0gdGhpcy5zdGVtX2RpcmVjdGlvbjtcblxuICAgICAgaWYgKHN0ZW1fZGlyZWN0aW9uID09IFN0ZW0uRE9XTikge1xuICAgICAgICAvLyBEb3duIHN0ZW1zIGFyZSByZW5kZXJlZCB0byB0aGUgbGVmdCBvZiB0aGUgaGVhZC5cbiAgICAgICAgc3RlbV94ID0gdGhpcy54X2JlZ2luICsgKFN0ZW0uV0lEVEggLyAyKTtcbiAgICAgICAgc3RlbV95ID0gdGhpcy55X3RvcCArIDI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBVcCBzdGVtcyBhcmUgcmVuZGVyZWQgdG8gdGhlIHJpZ2h0IG9mIHRoZSBoZWFkLlxuICAgICAgICBzdGVtX3ggPSB0aGlzLnhfZW5kICsgKFN0ZW0uV0lEVEggLyAyKTtcbiAgICAgICAgc3RlbV95ID0gdGhpcy55X2JvdHRvbSAtIDI7XG4gICAgICB9XG5cbiAgICAgIHN0ZW1feSArPSB0aGlzLnlfZXh0ZW5kICogc3RlbV9kaXJlY3Rpb247XG5cbiAgICAgIEwoXCJSZW5kZXJpbmcgc3RlbSAtIFwiLCBcIlRvcCBZOiBcIiwgdGhpcy55X3RvcCwgXCJCb3R0b20gWTogXCIsIHRoaXMueV9ib3R0b20pO1xuXG4gICAgICAvLyBEcmF3IHRoZSBzdGVtXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5hcHBseVN0eWxlKGN0eCk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHguc2V0TGluZVdpZHRoKFN0ZW0uV0lEVEgpO1xuICAgICAgY3R4Lm1vdmVUbyhzdGVtX3gsIHN0ZW1feSk7XG4gICAgICBjdHgubGluZVRvKHN0ZW1feCwgc3RlbV95IC0gdGhpcy5nZXRIZWlnaHQoKSk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3RlbTtcbn0oKSk7XG5cbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gYFN0ZW1tYWJsZU5vdGVgIGlzIGFuIGFic3RyYWN0IGludGVyZmFjZSBmb3Igbm90ZXMgd2l0aCBvcHRpb25hbCBzdGVtcy5cbi8vIEV4YW1wbGVzIG9mIHN0ZW1tYWJsZSBub3RlcyBhcmUgYFN0YXZlTm90ZWAgYW5kIGBUYWJOb3RlYFxuVmV4LkZsb3cuU3RlbW1hYmxlTm90ZSA9IChmdW5jdGlvbigpe1xuICB2YXIgU3RlbW1hYmxlTm90ZSA9IGZ1bmN0aW9uKG5vdGVfc3RydWN0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQobm90ZV9zdHJ1Y3QpO1xuICB9O1xuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93LlN0ZW1tYWJsZU5vdGUuREVCVUdgIHRvIGB0cnVlYC5cbiAgZnVuY3Rpb24gTCgpIHsgaWYgKFN0ZW1tYWJsZU5vdGUuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuU3RlbW1hYmxlTm90ZVwiLCBhcmd1bWVudHMpOyB9XG5cbiAgdmFyIFN0ZW0gPSBWZXguRmxvdy5TdGVtO1xuXG4gIFZleC5Jbmhlcml0KFN0ZW1tYWJsZU5vdGUsIFZleC5GbG93Lk5vdGUsIHtcbiAgICBpbml0OiBmdW5jdGlvbihub3RlX3N0cnVjdCl7XG4gICAgICBTdGVtbWFibGVOb3RlLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIG5vdGVfc3RydWN0KTtcblxuICAgICAgdGhpcy5zdGVtID0gbnVsbDtcbiAgICAgIHRoaXMuc3RlbV9leHRlbnNpb25fb3ZlcnJpZGUgPSBudWxsO1xuICAgICAgdGhpcy5iZWFtID0gbnVsbDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFuZCBzZXQgdGhlIG5vdGUncyBgU3RlbWBcbiAgICBnZXRTdGVtOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zdGVtOyB9LFxuICAgIHNldFN0ZW06IGZ1bmN0aW9uKHN0ZW0pIHsgdGhpcy5zdGVtID0gc3RlbTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBCdWlsZHMgYW5kIHNldHMgYSBuZXcgc3RlbVxuICAgIGJ1aWxkU3RlbTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RlbSA9IG5ldyBTdGVtKCk7XG4gICAgICB0aGlzLnNldFN0ZW0oc3RlbSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBmdWxsIGxlbmd0aCBvZiBzdGVtXG4gICAgZ2V0U3RlbUxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gU3RlbS5IRUlHSFQgKyB0aGlzLmdldFN0ZW1FeHRlbnNpb24oKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBudW1iZXIgb2YgYmVhbXMgZm9yIHRoaXMgZHVyYXRpb25cbiAgICBnZXRCZWFtQ291bnQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZ2x5cGggPSB0aGlzLmdldEdseXBoKCk7XG5cbiAgICAgIGlmIChnbHlwaCkge1xuICAgICAgICByZXR1cm4gZ2x5cGguYmVhbV9jb3VudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiAwO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIG1pbmltdW0gbGVuZ3RoIG9mIHN0ZW1cbiAgICBnZXRTdGVtTWludW11bUxlbmd0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZnJhYyA9IFZleC5GbG93LmR1cmF0aW9uVG9GcmFjdGlvbih0aGlzLmR1cmF0aW9uKTtcbiAgICAgIHZhciBsZW5ndGggPSAoZnJhYy52YWx1ZSgpIDw9IDEpID8gMCA6IDIwO1xuICAgICAgLy8gaWYgbm90ZSBpcyBmbGFnZ2VkLCBjYW5ub3Qgc2hvcnRlbiBiZWFtXG4gICAgICBzd2l0Y2ggKHRoaXMuZHVyYXRpb24pIHtcbiAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICAgaWYgKHRoaXMuYmVhbSA9PSBudWxsKSBsZW5ndGggPSAzNTtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgIGNhc2UgXCIxNlwiOlxuICAgICAgICAgaWYgKHRoaXMuYmVhbSA9PSBudWxsKVxuICAgICAgICAgICBsZW5ndGggPSAzNTtcbiAgICAgICAgIGVsc2VcbiAgICAgICAgICAgbGVuZ3RoID0gMjU7XG4gICAgICAgICBicmVhaztcbiAgICAgICBjYXNlIFwiMzJcIjpcbiAgICAgICAgIGlmICh0aGlzLmJlYW0gPT0gbnVsbClcbiAgICAgICAgICAgbGVuZ3RoID0gNDU7XG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIGxlbmd0aCA9IDM1O1xuICAgICAgICAgYnJlYWs7XG4gICAgICAgY2FzZSBcIjY0XCI6XG4gICAgICAgICBpZiAodGhpcy5iZWFtID09IG51bGwpXG4gICAgICAgICAgIGxlbmd0aCA9IDUwO1xuICAgICAgICAgZWxzZVxuICAgICAgICAgICBsZW5ndGggPSA0MDtcbiAgICAgICAgIGJyZWFrO1xuICAgICAgIGNhc2UgXCIxMjhcIjpcbiAgICAgICAgIGlmICh0aGlzLmJlYW0gPT0gbnVsbClcbiAgICAgICAgICAgbGVuZ3RoID0gNTU7XG4gICAgICAgICBlbHNlXG4gICAgICAgICAgIGxlbmd0aCA9IDQ1O1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlbmd0aDtcbiAgICB9LFxuXG4gICAgLy8gR2V0L3NldCB0aGUgZGlyZWN0aW9uIG9mIHRoZSBzdGVtXG4gICAgZ2V0U3RlbURpcmVjdGlvbjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN0ZW1fZGlyZWN0aW9uOyB9LFxuICAgIHNldFN0ZW1EaXJlY3Rpb246IGZ1bmN0aW9uKGRpcmVjdGlvbikge1xuICAgICAgaWYgKCFkaXJlY3Rpb24pIGRpcmVjdGlvbiA9IFN0ZW0uVVA7XG4gICAgICBpZiAoZGlyZWN0aW9uICE9IFN0ZW0uVVAgJiZcbiAgICAgICAgICBkaXJlY3Rpb24gIT0gU3RlbS5ET1dOKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50XCIsIFwiSW52YWxpZCBzdGVtIGRpcmVjdGlvbjogXCIgK1xuICAgICAgICAgICAgZGlyZWN0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zdGVtX2RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgIGlmICh0aGlzLnN0ZW0pIHtcbiAgICAgICAgdGhpcy5zdGVtLnNldERpcmVjdGlvbihkaXJlY3Rpb24pO1xuICAgICAgICB0aGlzLnN0ZW0uc2V0RXh0ZW5zaW9uKHRoaXMuZ2V0U3RlbUV4dGVuc2lvbigpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5iZWFtID0gbnVsbDtcbiAgICAgIGlmICh0aGlzLnByZUZvcm1hdHRlZCkge1xuICAgICAgICB0aGlzLnByZUZvcm1hdCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgYHhgIGNvb3JkaW5hdGUgb2YgdGhlIHN0ZW1cbiAgICBnZXRTdGVtWDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgeF9iZWdpbiA9IHRoaXMuZ2V0QWJzb2x1dGVYKCkgKyB0aGlzLnhfc2hpZnQ7XG4gICAgICB2YXIgeF9lbmQgPSB0aGlzLmdldEFic29sdXRlWCgpICsgdGhpcy54X3NoaWZ0ICsgdGhpcy5nbHlwaC5oZWFkX3dpZHRoO1xuXG4gICAgICB2YXIgc3RlbV94ID0gdGhpcy5zdGVtX2RpcmVjdGlvbiA9PSBTdGVtLkRPV04gP1xuICAgICAgICB4X2JlZ2luIDogeF9lbmQ7XG5cbiAgICAgIHN0ZW1feCAtPSAoKFN0ZW0uV0lEVEggLyAyKSAqIHRoaXMuc3RlbV9kaXJlY3Rpb24pO1xuXG4gICAgICByZXR1cm4gc3RlbV94O1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGB4YCBjb29yZGluYXRlIGZvciB0aGUgY2VudGVyIG9mIHRoZSBnbHlwaC5cbiAgICAvLyBVc2VkIGZvciBgVGFiTm90ZWAgc3RlbXMgYW5kIHN0ZW1sZXRzIG92ZXIgcmVzdHNcbiAgICBnZXRDZW50ZXJHbHlwaFg6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy5nZXRBYnNvbHV0ZVgoKSArIHRoaXMueF9zaGlmdCArICh0aGlzLmdseXBoLmhlYWRfd2lkdGggLyAyKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBzdGVtIGV4dGVuc2lvbiBmb3IgdGhlIGN1cnJlbnQgZHVyYXRpb25cbiAgICBnZXRTdGVtRXh0ZW5zaW9uOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaCgpO1xuXG4gICAgICBpZiAodGhpcy5zdGVtX2V4dGVuc2lvbl9vdmVycmlkZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZW1fZXh0ZW5zaW9uX292ZXJyaWRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2x5cGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RlbURpcmVjdGlvbigpID09PSAxID8gZ2x5cGguc3RlbV91cF9leHRlbnNpb24gOlxuICAgICAgICAgIGdseXBoLnN0ZW1fZG93bl9leHRlbnNpb247XG4gICAgICB9XG5cbiAgICAgIHJldHVybiAwO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIHN0ZW0gbGVuZ3RoIHRvIGEgc3BlY2lmaWMuIFdpbGwgb3ZlcnJpZGUgdGhlIGRlZmF1bHQgbGVuZ3RoLlxuICAgIHNldFN0ZW1MZW5ndGg6IGZ1bmN0aW9uKGhlaWdodCkge1xuICAgICAgdGhpcy5zdGVtX2V4dGVuc2lvbl9vdmVycmlkZSA9IChoZWlnaHQgLSBTdGVtLkhFSUdIVCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSB0b3AgYW5kIGJvdHRvbSBgeWAgdmFsdWVzIG9mIHRoZSBzdGVtLlxuICAgIGdldFN0ZW1FeHRlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy55cyB8fCB0aGlzLnlzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9ZVmFsdWVzXCIsXG4gICAgICAgICAgXCJDYW4ndCBnZXQgdG9wIHN0ZW0gWSB3aGVuIG5vdGUgaGFzIG5vIFkgdmFsdWVzLlwiKTtcblxuICAgICAgdmFyIHRvcF9waXhlbCA9IHRoaXMueXNbMF07XG4gICAgICB2YXIgYmFzZV9waXhlbCA9IHRoaXMueXNbMF07XG4gICAgICB2YXIgc3RlbV9oZWlnaHQgPSBTdGVtLkhFSUdIVCArIHRoaXMuZ2V0U3RlbUV4dGVuc2lvbigpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMueXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIHN0ZW1fdG9wID0gdGhpcy55c1tpXSArIChzdGVtX2hlaWdodCAqIC10aGlzLnN0ZW1fZGlyZWN0aW9uKTtcblxuICAgICAgICBpZiAodGhpcy5zdGVtX2RpcmVjdGlvbiA9PSBTdGVtLkRPV04pIHtcbiAgICAgICAgICB0b3BfcGl4ZWwgPSBNYXRoLm1heCh0b3BfcGl4ZWwsIHN0ZW1fdG9wKTtcbiAgICAgICAgICBiYXNlX3BpeGVsID0gTWF0aC5taW4oYmFzZV9waXhlbCwgdGhpcy55c1tpXSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdG9wX3BpeGVsID0gTWF0aC5taW4odG9wX3BpeGVsLCBzdGVtX3RvcCk7XG4gICAgICAgICAgYmFzZV9waXhlbCA9IE1hdGgubWF4KGJhc2VfcGl4ZWwsIHRoaXMueXNbaV0pO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYodGhpcy5ub3RlVHlwZSA9PSBcInNcIiB8fCB0aGlzLm5vdGVUeXBlID09ICd4Jykge1xuICAgICAgICAgIHRvcF9waXhlbCAtPSB0aGlzLnN0ZW1fZGlyZWN0aW9uICogNztcbiAgICAgICAgICBiYXNlX3BpeGVsIC09IHRoaXMuc3RlbV9kaXJlY3Rpb24gKiA3O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIEwoXCJTdGVtIGV4dGVudHM6IFwiLCB0b3BfcGl4ZWwsIGJhc2VfcGl4ZWwpO1xuICAgICAgcmV0dXJuIHsgdG9wWTogdG9wX3BpeGVsLCBiYXNlWTogYmFzZV9waXhlbCB9O1xuICAgIH0sXG5cbiAgICAvLyBTZXRzIHRoZSBjdXJyZW50IG5vdGUncyBiZWFtXG4gICAgc2V0QmVhbTogZnVuY3Rpb24oYmVhbSkgeyB0aGlzLmJlYW0gPSBiZWFtOyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIEdldCB0aGUgYHlgIHZhbHVlIGZvciB0aGUgdG9wL2JvdHRvbSBtb2RpZmllcnMgYXQgYSBzcGVjaWZpYyBgdGV4dF9saW5lYFxuICAgIGdldFlGb3JUb3BUZXh0OiBmdW5jdGlvbih0ZXh0X2xpbmUpIHtcbiAgICAgIHZhciBleHRlbnRzID0gdGhpcy5nZXRTdGVtRXh0ZW50cygpO1xuICAgICAgaWYgKHRoaXMuaGFzU3RlbSgpKSB7XG4gICAgICAgIHJldHVybiBWZXguTWluKHRoaXMuc3RhdmUuZ2V0WUZvclRvcFRleHQodGV4dF9saW5lKSxcbiAgICAgICAgICAgIGV4dGVudHMudG9wWSAtICh0aGlzLnJlbmRlcl9vcHRpb25zLmFubm90YXRpb25fc3BhY2luZyAqICh0ZXh0X2xpbmUgKyAxKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdmUuZ2V0WUZvclRvcFRleHQodGV4dF9saW5lKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0WUZvckJvdHRvbVRleHQ6IGZ1bmN0aW9uKHRleHRfbGluZSkge1xuICAgICAgdmFyIGV4dGVudHMgPSB0aGlzLmdldFN0ZW1FeHRlbnRzKCk7XG4gICAgICBpZiAodGhpcy5oYXNTdGVtKCkpIHtcbiAgICAgICAgcmV0dXJuIFZleC5NYXgodGhpcy5zdGF2ZS5nZXRZRm9yVG9wVGV4dCh0ZXh0X2xpbmUpLFxuICAgICAgICAgIGV4dGVudHMuYmFzZVkgKyAodGhpcy5yZW5kZXJfb3B0aW9ucy5hbm5vdGF0aW9uX3NwYWNpbmcgKiAodGV4dF9saW5lKSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RhdmUuZ2V0WUZvckJvdHRvbVRleHQodGV4dF9saW5lKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaGFzRmxhZzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gVmV4LkZsb3cuZHVyYXRpb25Ub0dseXBoKHRoaXMuZHVyYXRpb24pLmZsYWc7XG4gICAgfSxcblxuICAgIC8vIFBvc3QgZm9ybWF0IHRoZSBub3RlXG4gICAgcG9zdEZvcm1hdDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAodGhpcy5iZWFtKSB7XG4gICAgICAgIHRoaXMuYmVhbS5wb3N0Rm9ybWF0KCk7XG4gICAgICB9XG4gICAgICB0aGlzLnBvc3RGb3JtYXR0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbmRlciB0aGUgc3RlbSBvbnRvIHRoZSBjYW52YXNcbiAgICBkcmF3U3RlbTogZnVuY3Rpb24oc3RlbV9zdHJ1Y3Qpe1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ2FudmFzQ29udGV4dFwiLFxuICAgICAgICAgIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgY2FudmFzIGNvbnRleHQuXCIpO1xuXG4gICAgICB0aGlzLnNldFN0ZW0obmV3IFN0ZW0oc3RlbV9zdHJ1Y3QpKTtcbiAgICAgIHRoaXMuc3RlbS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCkuZHJhdygpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFN0ZW1tYWJsZU5vdGU7XG59KCkpO1xuXG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIG5vdGVzIGZvciBzdGFuZGFyZCBub3RhdGlvbi4gVGhpcyBjb25zaXN0cyBvZiBvbmUgb3Jcbi8vIG1vcmUgYE5vdGVIZWFkc2AsIGFuIG9wdGlvbmFsIHN0ZW0sIGFuZCBhbiBvcHRpb25hbCBmbGFnLlxuLy9cbi8vICpUaHJvdWdob3V0IHRoZXNlIGNvbW1lbnRzLCBhIFwibm90ZVwiIHJlZmVycyB0byB0aGUgZW50aXJlIGBTdGF2ZU5vdGVgLFxuLy8gYW5kIGEgXCJrZXlcIiByZWZlcnMgdG8gYSBzcGVjaWZpYyBwaXRjaC9ub3RlaGVhZCB3aXRoaW4gYSBub3RlLipcbi8vXG4vLyBTZWUgYHRlc3RzL3N0YXZlbm90ZV90ZXN0cy5qc2AgZm9yIHVzYWdlIGV4YW1wbGVzLlxuVmV4LkZsb3cuU3RhdmVOb3RlID0gKGZ1bmN0aW9uKCkge1xuICB2YXIgU3RhdmVOb3RlID0gZnVuY3Rpb24obm90ZV9zdHJ1Y3QpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChub3RlX3N0cnVjdCk7XG4gIH07XG4gIFN0YXZlTm90ZS5DQVRFR09SWSA9IFwic3RhdmVub3Rlc1wiO1xuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93LlN0YXZlTm90ZS5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoU3RhdmVOb3RlLkRFQlVHKSBWZXguTChcIlZleC5GbG93LlN0YXZlTm90ZVwiLCBhcmd1bWVudHMpOyB9XG5cbiAgdmFyIFN0ZW0gPSBWZXguRmxvdy5TdGVtO1xuICB2YXIgTm90ZUhlYWQgPSBWZXguRmxvdy5Ob3RlSGVhZDtcblxuICAvLyBTdGVtIGRpcmVjdGlvbnNcbiAgU3RhdmVOb3RlLlNURU1fVVAgPSBTdGVtLlVQO1xuICBTdGF2ZU5vdGUuU1RFTV9ET1dOID0gU3RlbS5ET1dOO1xuXG4gIC8vIEhlbHBlciBtZXRob2RzIGZvciByZXN0IHBvc2l0aW9uaW5nIGluIE1vZGlmaWVyQ29udGV4dC5cbiAgdmFyIHNoaWZ0UmVzdFZlcnRpY2FsID0gZnVuY3Rpb24ocmVzdCwgbm90ZSwgZGlyKSB7XG4gICAgdmFyIGRlbHRhID0gKG5vdGUuaXNyZXN0ID8gMC4wIDogMS4wKSAqIGRpcjtcblxuICAgIHJlc3QubGluZSArPSBkZWx0YTtcbiAgICByZXN0Lm1heF9saW5lICs9IGRlbHRhO1xuICAgIHJlc3QubWluX2xpbmUgKz0gZGVsdGE7XG4gICAgcmVzdC5ub3RlLnNldEtleUxpbmUoMCwgcmVzdC5ub3RlLmdldEtleUxpbmUoMCkgKyAoZGVsdGEpKTtcbiAgfTtcblxuICAvLyBDYWxsZWQgZnJvbSBmb3JtYXROb3RlcyA6OiBjZW50ZXIgYSByZXN0IGJldHdlZW4gdHdvIG5vdGVzXG4gIHZhciBjZW50ZXJSZXN0ID0gZnVuY3Rpb24ocmVzdCwgbm90ZVUsIG5vdGVMKSB7XG4gICAgdmFyIGRlbHRhID0gcmVzdC5saW5lIC0gVmV4Lk1pZExpbmUobm90ZVUubWluX2xpbmUsIG5vdGVMLm1heF9saW5lKTtcbiAgICByZXN0Lm5vdGUuc2V0S2V5TGluZSgwLCByZXN0Lm5vdGUuZ2V0S2V5TGluZSgwKSAtIGRlbHRhKTtcbiAgICByZXN0LmxpbmUgLT0gZGVsdGE7XG4gICAgcmVzdC5tYXhfbGluZSAtPSBkZWx0YTtcbiAgICByZXN0Lm1pbl9saW5lIC09IGRlbHRhO1xuICB9O1xuXG4gIC8vICMjIFN0YXRpYyBNZXRob2RzXG4gIC8vXG4gIC8vIEZvcm1hdCBub3RlcyBpbnNpZGUgYSBNb2RpZmllckNvbnRleHQuXG4gIFN0YXZlTm90ZS5mb3JtYXQgPSBmdW5jdGlvbihub3Rlcywgc3RhdGUpIHtcbiAgICBpZiAoIW5vdGVzIHx8IG5vdGVzLmxlbmd0aCA8IDIpIHJldHVybiBmYWxzZTtcblxuICAgIGlmIChub3Rlc1swXS5nZXRTdGF2ZSgpICE9IG51bGwpIHJldHVybiBTdGF2ZU5vdGUuZm9ybWF0QnlZKG5vdGVzLCBzdGF0ZSk7XG5cbiAgICB2YXIgbm90ZXNfbGlzdD0gW107XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgcHJvcHMgPSBub3Rlc1tpXS5nZXRLZXlQcm9wcygpO1xuICAgICAgdmFyIGxpbmUgPSBwcm9wc1swXS5saW5lO1xuICAgICAgdmFyIG1pbkwgPSBwcm9wc1twcm9wcy5sZW5ndGggLTFdLmxpbmU7XG4gICAgICB2YXIgc3RlbV9kaXIgPSBub3Rlc1tpXS5nZXRTdGVtRGlyZWN0aW9uKCk7XG4gICAgICB2YXIgc3RlbV9tYXggPSBub3Rlc1tpXS5nZXRTdGVtTGVuZ3RoKCkgLyAxMDtcbiAgICAgIHZhciBzdGVtX21pbiA9IG5vdGVzW2ldLmdldFN0ZW1NaW51bXVtTGVuZ3RoKCkgLyAxMDtcblxuICAgICAgdmFyIG1heEw7XG4gICAgICBpZiAobm90ZXNbaV0uaXNSZXN0KCkpIHtcbiAgICAgICAgbWF4TCA9IGxpbmUgKyBub3Rlc1tpXS5nbHlwaC5saW5lX2Fib3ZlO1xuICAgICAgICBtaW5MID0gbGluZSAtIG5vdGVzW2ldLmdseXBoLmxpbmVfYmVsb3c7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtYXhMID0gc3RlbV9kaXIgPT0gMSA/IHByb3BzW3Byb3BzLmxlbmd0aCAtMV0ubGluZSArIHN0ZW1fbWF4XG4gICAgICAgICAgICAgOiBwcm9wc1twcm9wcy5sZW5ndGggLTFdLmxpbmU7XG4gICAgICAgIG1pbkwgPSBzdGVtX2RpciA9PSAxID8gcHJvcHNbMF0ubGluZVxuICAgICAgICAgICAgIDogcHJvcHNbMF0ubGluZSAtIHN0ZW1fbWF4O1xuICAgICAgfVxuICAgICAgbm90ZXNfbGlzdC5wdXNoKFxuICAgICAgICB7bGluZTogcHJvcHNbMF0ubGluZSwgICAgICAgICAvLyBub3RlL3Jlc3QgYmFzZSBsaW5lXG4gICAgICAgICBtYXhfbGluZTogbWF4TCwgICAgICAgICAgICAgIC8vIG5vdGUvcmVzdCB1cHBlciBib3VuZHMgbGluZVxuICAgICAgICAgbWluX2xpbmU6IG1pbkwsICAgICAgICAgICAgICAvLyBub3RlL3Jlc3QgbG93ZXIgYm91bmRzIGxpbmVcbiAgICAgICAgIGlzcmVzdDogbm90ZXNbaV0uaXNSZXN0KCksXG4gICAgICAgICBzdGVtX2Rpcjogc3RlbV9kaXIsXG4gICAgICAgICBzdGVtX21heDogc3RlbV9tYXgsICAgICAgICAgIC8vIE1heGltdW0gKGRlZmF1bHQpIG5vdGUgc3RlbSBsZW5ndGg7XG4gICAgICAgICBzdGVtX21pbjogc3RlbV9taW4sICAgICAgICAgIC8vIG1pbmltdW0gbm90ZSBzdGVtIGxlbmd0aFxuICAgICAgICAgdm9pY2Vfc2hpZnQ6IG5vdGVzW2ldLmdldFZvaWNlU2hpZnRXaWR0aCgpLFxuICAgICAgICAgaXNfZGlzcGxhY2VkOiBub3Rlc1tpXS5pc0Rpc3BsYWNlZCgpLCAgIC8vIG5vdGUgbWFudWFsbHkgZGlzcGxhY2VkXG4gICAgICAgICBub3RlOiBub3Rlc1tpXX0pO1xuICAgIH1cblxuICAgIHZhciB2b2ljZXMgPSBub3Rlc19saXN0Lmxlbmd0aDtcblxuICAgIHZhciBub3RlVSA9IG5vdGVzX2xpc3RbMF07XG4gICAgdmFyIG5vdGVNID0gdm9pY2VzID4gMiA/IG5vdGVzX2xpc3RbMV0gOiBudWxsO1xuICAgIHZhciBub3RlTCA9IHZvaWNlcyA+IDIgPyBub3Rlc19saXN0WzJdIDogbm90ZXNfbGlzdFsxXTtcblxuICAgIC8vIGZvciB0d28gdm9pY2UgYmFja3dhcmQgY29tcGF0aWJpbGl0eSwgZW5zdXJlIHVwcGVyIHZvaWNlIGlzIHN0ZW1zIHVwXG4gICAgLy8gZm9yIHRocmVlIHZvaWNlcywgdGhlIHZvaWNlcyBtdXN0IGJlIGluIG9yZGVyICh1cHBlciwgbWlkZGxlLCBsb3dlcilcbiAgICBpZiAodm9pY2VzID09IDIgJiYgbm90ZVUuc3RlbV9kaXIgPT0gLTEgJiYgbm90ZUwuc3RlbV9kaXIgPT0gMSkge1xuICAgICAgbm90ZVUgPSBub3Rlc19saXN0WzFdO1xuICAgICAgbm90ZUwgPSBub3Rlc19saXN0WzBdO1xuICAgIH1cblxuICAgIHZhciB2b2ljZV94X3NoaWZ0ID0gTWF0aC5tYXgobm90ZVUudm9pY2Vfc2hpZnQsIG5vdGVMLnZvaWNlX3NoaWZ0KTtcbiAgICB2YXIgeF9zaGlmdCA9IDA7XG4gICAgdmFyIHN0ZW1fZGVsdGE7XG5cbiAgICAvLyBUZXN0IGZvciB0d28gdm9pY2Ugbm90ZSBpbnRlcnNlY3Rpb25cbiAgICBpZiAodm9pY2VzID09IDIpIHtcbiAgICAgIHZhciBsaW5lX3NwYWNpbmcgPSBub3RlVS5zdGVtX2RpciA9PSBub3RlTC5zdGVtX2RpciA/IDAuMCA6IDAuNTtcbiAgICAgIC8vIGlmIHRvcCB2b2ljZSBpcyBhIG1pZGRsZSB2b2ljZSwgY2hlY2sgc3RlbSBpbnRlcnNlY3Rpb24gd2l0aCBsb3dlciB2b2ljZVxuICAgICAgaWYgKG5vdGVVLnN0ZW1fZGlyID09IG5vdGVMLnN0ZW1fZGlyICYmXG4gICAgICAgICAgbm90ZVUubWluX2xpbmUgPD0gbm90ZUwubWF4X2xpbmUpIHtcbiAgICAgICAgaWYgKCFub3RlVS5pc3Jlc3QpIHtcbiAgICAgICAgICBzdGVtX2RlbHRhID0gTWF0aC5hYnMobm90ZVUubGluZSAtIChub3RlTC5tYXhfbGluZSArIDAuNSkpO1xuICAgICAgICAgIHN0ZW1fZGVsdGEgPSBNYXRoLm1heChzdGVtX2RlbHRhLCBub3RlVS5zdGVtX21pbik7XG4gICAgICAgICAgbm90ZVUubWluX2xpbmUgPSBub3RlVS5saW5lIC0gc3RlbV9kZWx0YTtcbiAgICAgICAgICBub3RlVS5ub3RlLnNldFN0ZW1MZW5ndGgoc3RlbV9kZWx0YSAqIDEwKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG5vdGVVLm1pbl9saW5lIDw9IG5vdGVMLm1heF9saW5lICsgbGluZV9zcGFjaW5nKSB7XG4gICAgICAgIGlmIChub3RlVS5pc3Jlc3QpIHtcbiAgICAgICAgICAvLyBzaGlmdCByZXN0IHVwXG4gICAgICAgICAgc2hpZnRSZXN0VmVydGljYWwobm90ZVUsIG5vdGVMLCAxKTtcbiAgICAgICAgfSBlbHNlIGlmIChub3RlTC5pc3Jlc3QpIHtcbiAgICAgICAgICAvLyBzaGlmdCByZXN0IGRvd25cbiAgICAgICAgICBzaGlmdFJlc3RWZXJ0aWNhbChub3RlTCwgbm90ZVUsIC0xKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB4X3NoaWZ0ID0gdm9pY2VfeF9zaGlmdDtcbiAgICAgICAgICBpZiAobm90ZVUuc3RlbV9kaXIgPT0gbm90ZUwuc3RlbV9kaXIpXG4gICAgICAgICAgICAvLyB1cHBlciB2b2ljZSBpcyBtaWRkbGUgdm9pY2UsIHNvIHNoaWZ0IGl0IHJpZ2h0XG4gICAgICAgICAgICBub3RlVS5ub3RlLnNldFhTaGlmdCh4X3NoaWZ0ICsgMyk7XG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgLy8gc2hpZnQgbG93ZXIgdm9pY2UgcmlnaHRcbiAgICAgICAgICAgIG5vdGVMLm5vdGUuc2V0WFNoaWZ0KHhfc2hpZnQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGZvcm1hdCBjb21wbGV0ZVxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgbWlkZGxlIHZvaWNlIHN0ZW0gaW50ZXJzZWN0aW9uIHdpdGggbG93ZXIgdm9pY2VcbiAgICBpZiAobm90ZU0gIT0gbnVsbCAmJiBub3RlTS5taW5fbGluZSA8IG5vdGVMLm1heF9saW5lICsgMC41KSB7XG4gICAgICBpZiAoIW5vdGVNLmlzcmVzdCkge1xuICAgICAgICBzdGVtX2RlbHRhID0gTWF0aC5hYnMobm90ZU0ubGluZSAtIChub3RlTC5tYXhfbGluZSArIDAuNSkpO1xuICAgICAgICBzdGVtX2RlbHRhID0gTWF0aC5tYXgoc3RlbV9kZWx0YSwgbm90ZU0uc3RlbV9taW4pO1xuICAgICAgICBub3RlTS5taW5fbGluZSA9IG5vdGVNLmxpbmUgLSBzdGVtX2RlbHRhO1xuICAgICAgICBub3RlTS5ub3RlLnNldFN0ZW1MZW5ndGgoc3RlbV9kZWx0YSAqIDEwKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBGb3IgdGhyZWUgdm9pY2VzLCB0ZXN0IGlmIHJlc3RzIGNhbiBiZSByZXBvc2l0aW9uZWRcbiAgICAvL1xuICAgIC8vIFNwZWNpYWwgY2FzZSAxIDo6IG1pZGRsZSB2b2ljZSByZXN0IGJldHdlZW4gdHdvIG5vdGVzXG4gICAgLy9cbiAgICBpZiAobm90ZU0uaXNyZXN0ICYmICFub3RlVS5pc3Jlc3QgJiYgIW5vdGVMLmlzcmVzdCkge1xuICAgICAgaWYgKG5vdGVVLm1pbl9saW5lIDw9IG5vdGVNLm1heF9saW5lIHx8XG4gICAgICAgICAgbm90ZU0ubWluX2xpbmUgPD0gbm90ZUwubWF4X2xpbmUpIHtcbiAgICAgICAgIHZhciByZXN0X2hlaWdodCA9IG5vdGVNLm1heF9saW5lIC0gbm90ZU0ubWluX2xpbmU7XG4gICAgICAgICB2YXIgc3BhY2UgPSBub3RlVS5taW5fbGluZSAtIG5vdGVMLm1heF9saW5lO1xuICAgICAgICAgaWYgKHJlc3RfaGVpZ2h0IDwgc3BhY2UpXG4gICAgICAgICAgIC8vIGNlbnRlciBtaWRkbGUgdm9pY2UgcmVzdCBiZXR3ZWVuIHRoZSB1cHBlciBhbmQgbG93ZXIgdm9pY2VzXG4gICAgICAgICAgIGNlbnRlclJlc3Qobm90ZU0sIG5vdGVVLCBub3RlTCk7XG4gICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgeF9zaGlmdCA9IHZvaWNlX3hfc2hpZnQgKyAzOyAgICAvLyBzaGlmdCBtaWRkbGUgcmVzdCByaWdodFxuICAgICAgICAgICBub3RlTS5ub3RlLnNldFhTaGlmdCh4X3NoaWZ0KTtcbiAgICAgICAgIH1cbiAgICAgICAgIC8vIGZvcm1hdCBjb21wbGV0ZVxuICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU3BlY2lhbCBjYXNlIDIgOjogYWxsIHZvaWNlcyBhcmUgcmVzdHNcbiAgICBpZiAobm90ZVUuaXNyZXN0ICYmIG5vdGVNLmlzcmVzdCAmJiBub3RlTC5pc3Jlc3QpIHtcbiAgICAgIC8vIFNoaWZ0IHVwcGVyIHZvaWNlIHJlc3QgdXBcbiAgICAgIHNoaWZ0UmVzdFZlcnRpY2FsKG5vdGVVLCBub3RlTSwgMSk7XG4gICAgICAvLyBTaGlmdCBsb3dlciB2b2ljZSByZXN0IGRvd25cbiAgICAgIHNoaWZ0UmVzdFZlcnRpY2FsKG5vdGVMLCBub3RlTSwgLTEpO1xuICAgICAgLy8gZm9ybWF0IGNvbXBsZXRlXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBUZXN0IGlmIGFueSBvdGhlciByZXN0cyBjYW4gYmUgcmVwb3NpdGlvbmVkXG4gICAgaWYgKG5vdGVNLmlzcmVzdCAmJiBub3RlVS5pc3Jlc3QgJiYgbm90ZU0ubWluX2xpbmUgPD0gbm90ZUwubWF4X2xpbmUpXG4gICAgICAvLyBTaGlmdCBtaWRkbGUgdm9pY2UgcmVzdCB1cFxuICAgICAgc2hpZnRSZXN0VmVydGljYWwobm90ZU0sIG5vdGVMLCAxKTtcbiAgICBpZiAobm90ZU0uaXNyZXN0ICYmIG5vdGVMLmlzcmVzdCAmJiBub3RlVS5taW5fbGluZSA8PSBub3RlTS5tYXhfbGluZSlcbiAgICAgIC8vIFNoaWZ0IG1pZGRsZSB2b2ljZSByZXN0IGRvd25cbiAgICAgIHNoaWZ0UmVzdFZlcnRpY2FsKG5vdGVNLCBub3RlVSwgLTEpO1xuICAgIGlmIChub3RlVS5pc3Jlc3QgJiYgbm90ZVUubWluX2xpbmUgPD0gbm90ZU0ubWF4X2xpbmUpXG4gICAgICAvLyBzaGlmdCB1cHBlciB2b2ljZSByZXN0IHVwO1xuICAgICAgc2hpZnRSZXN0VmVydGljYWwobm90ZVUsIG5vdGVNLCAxKTtcbiAgICBpZiAobm90ZUwuaXNyZXN0ICYmIG5vdGVNLm1pbl9saW5lIDw9IG5vdGVMLm1heF9saW5lKVxuICAgICAgLy8gc2hpZnQgbG93ZXIgdm9pY2UgcmVzdCBkb3duXG4gICAgICBzaGlmdFJlc3RWZXJ0aWNhbChub3RlTCwgbm90ZU0sIC0xKTtcblxuICAgIC8vIElmIG1pZGRsZSB2b2ljZSBpbnRlcnNlY3RzIHVwcGVyIG9yIGxvd2VyIHZvaWNlXG4gICAgaWYgKCghbm90ZVUuaXNyZXN0ICYmICFub3RlTS5pc3Jlc3QgJiYgbm90ZVUubWluX2xpbmUgPD0gbm90ZU0ubWF4X2xpbmUgKyAwLjUpIHx8XG4gICAgICAgICghbm90ZU0uaXNyZXN0ICYmICFub3RlTC5pc3Jlc3QgJiYgbm90ZU0ubWluX2xpbmUgPD0gbm90ZUwubWF4X2xpbmUpKSB7XG4gICAgICB4X3NoaWZ0ID0gdm9pY2VfeF9zaGlmdCArIDM7ICAgICAgLy8gc2hpZnQgbWlkZGxlIG5vdGUgcmlnaHRcbiAgICAgIG5vdGVNLm5vdGUuc2V0WFNoaWZ0KHhfc2hpZnQpO1xuICAgIH1cblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIFN0YXZlTm90ZS5mb3JtYXRCeVkgPSBmdW5jdGlvbihub3Rlcywgc3RhdGUpIHtcbiAgICAvLyBOT1RFOiB0aGlzIGZ1bmN0aW9uIGRvZXMgbm90IHN1cHBvcnQgbW9yZSB0aGFuIHR3byB2b2ljZXMgcGVyIHN0YXZlXG4gICAgLy8gICAgICAgdXNlIHdpdGggY2FyZS5cbiAgICB2YXIgaGFzU3RhdmUgPSB0cnVlO1xuICAgIHZhciBpO1xuXG4gICAgZm9yIChpID0gMDsgaSA8IG5vdGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICBoYXNTdGF2ZSA9IGhhc1N0YXZlICYmIG5vdGVzW2ldLmdldFN0YXZlKCkgIT0gbnVsbDtcbiAgICB9XG5cbiAgICBpZiAoIWhhc1N0YXZlKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJTdGF2ZSBNaXNzaW5nXCIsXG4gICAgICBcIkFsbCBub3RlcyBtdXN0IGhhdmUgYSBzdGF2ZSAtIFZleC5GbG93Lk1vZGlmaWVyQ29udGV4dC5mb3JtYXRNdWx0aVZvaWNlIVwiKTtcblxuICAgIHZhciB4X3NoaWZ0ID0gMDtcblxuICAgIGZvciAoaSA9IDA7IGkgPCBub3Rlcy5sZW5ndGggLSAxOyBpKyspIHtcbiAgICAgIHZhciB0b3Bfbm90ZSA9IG5vdGVzW2ldO1xuICAgICAgdmFyIGJvdHRvbV9ub3RlID0gbm90ZXNbaSArIDFdO1xuXG4gICAgICBpZiAodG9wX25vdGUuZ2V0U3RlbURpcmVjdGlvbigpID09IFZleC5GbG93LlN0YXZlTm90ZS5TVEVNX0RPV04pIHtcbiAgICAgICAgdG9wX25vdGUgPSBub3Rlc1tpICsgMV07XG4gICAgICAgIGJvdHRvbV9ub3RlID0gbm90ZXNbaV07XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3Bfa2V5cyA9IHRvcF9ub3RlLmdldEtleVByb3BzKCk7XG4gICAgICB2YXIgYm90dG9tX2tleXMgPSBib3R0b21fbm90ZS5nZXRLZXlQcm9wcygpO1xuXG4gICAgICB2YXIgdG9wWSA9IHRvcF9ub3RlLmdldFN0YXZlKCkuZ2V0WUZvckxpbmUodG9wX2tleXNbMF0ubGluZSk7XG4gICAgICB2YXIgYm90dG9tWSA9IGJvdHRvbV9ub3RlLmdldFN0YXZlKCkuZ2V0WUZvckxpbmUoYm90dG9tX2tleXNbYm90dG9tX2tleXMubGVuZ3RoIC0gMV0ubGluZSk7XG5cbiAgICAgIHZhciBsaW5lX3NwYWNlID0gdG9wX25vdGUuZ2V0U3RhdmUoKS5vcHRpb25zLnNwYWNpbmdfYmV0d2Vlbl9saW5lc19weDtcbiAgICAgIGlmIChNYXRoLmFicyh0b3BZIC0gYm90dG9tWSkgPT0gbGluZV9zcGFjZSAvIDIpIHtcbiAgICAgICAgeF9zaGlmdCA9IHRvcF9ub3RlLmdldFZvaWNlU2hpZnRXaWR0aCgpO1xuICAgICAgICBib3R0b21fbm90ZS5zZXRYU2hpZnQoeF9zaGlmdCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3RhdGUucmlnaHRfc2hpZnQgKz0geF9zaGlmdDtcbiAgfTtcblxuICBTdGF2ZU5vdGUucG9zdEZvcm1hdCA9IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgaWYgKCFub3RlcykgcmV0dXJuIGZhbHNlO1xuXG4gICAgbm90ZXMuZm9yRWFjaChmdW5jdGlvbihub3RlKSB7XG4gICAgICBub3RlLnBvc3RGb3JtYXQoKTtcbiAgICB9KTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIC8vXG4gIFZleC5Jbmhlcml0KFN0YXZlTm90ZSwgVmV4LkZsb3cuU3RlbW1hYmxlTm90ZSwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG5vdGVfc3RydWN0KSB7XG4gICAgICBTdGF2ZU5vdGUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbm90ZV9zdHJ1Y3QpO1xuXG4gICAgICB0aGlzLmtleXMgPSBub3RlX3N0cnVjdC5rZXlzO1xuICAgICAgdGhpcy5jbGVmID0gbm90ZV9zdHJ1Y3QuY2xlZjtcbiAgICAgIHRoaXMub2N0YXZlX3NoaWZ0ID0gbm90ZV9zdHJ1Y3Qub2N0YXZlX3NoaWZ0O1xuICAgICAgdGhpcy5iZWFtID0gbnVsbDtcblxuICAgICAgLy8gUHVsbCBub3RlIHJlbmRlcmluZyBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLmdseXBoID0gVmV4LkZsb3cuZHVyYXRpb25Ub0dseXBoKHRoaXMuZHVyYXRpb24sIHRoaXMubm90ZVR5cGUpO1xuICAgICAgaWYgKCF0aGlzLmdseXBoKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiQmFkQXJndW1lbnRzXCIsXG4gICAgICAgICAgICBcIkludmFsaWQgbm90ZSBpbml0aWFsaXphdGlvbiBkYXRhIChObyBnbHlwaCBmb3VuZCk6IFwiICtcbiAgICAgICAgICAgIEpTT04uc3RyaW5naWZ5KG5vdGVfc3RydWN0KSk7XG4gICAgICB9XG5cbiAgICAgIC8vIGlmIHRydWUsIGRpc3BsYWNlIG5vdGUgdG8gcmlnaHRcbiAgICAgIHRoaXMuZGlzcGxhY2VkID0gZmFsc2U7XG4gICAgICB0aGlzLmRvdF9zaGlmdFkgPSAwO1xuICAgICAgLy8gcGVyLXBpdGNoIHByb3BlcnRpZXNcbiAgICAgIHRoaXMua2V5UHJvcHMgPSBbXTtcbiAgICAgIC8vIGZvciBkaXNwbGFjZWQgbGVkZ2VyIGxpbmVzXG4gICAgICB0aGlzLnVzZV9kZWZhdWx0X2hlYWRfeCA9IGZhbHNlO1xuXG4gICAgICAvLyBEcmF3aW5nXG4gICAgICB0aGlzLm5vdGVfaGVhZHMgPSBbXTtcbiAgICAgIHRoaXMubW9kaWZpZXJzID0gW107XG5cbiAgICAgIFZleC5NZXJnZSh0aGlzLnJlbmRlcl9vcHRpb25zLCB7XG4gICAgICAgIC8vIGZvbnQgc2l6ZSBmb3Igbm90ZSBoZWFkcyBhbmQgcmVzdHNcbiAgICAgICAgZ2x5cGhfZm9udF9zY2FsZTogMzUsXG4gICAgICAgIC8vIG51bWJlciBvZiBzdHJva2UgcHggdG8gdGhlIGxlZnQgYW5kIHJpZ2h0IG9mIGhlYWRcbiAgICAgICAgc3Ryb2tlX3B4OiAzXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5jYWxjdWxhdGVLZXlQcm9wcygpO1xuXG4gICAgICB0aGlzLmJ1aWxkU3RlbSgpO1xuXG4gICAgICAvLyBTZXQgdGhlIHN0ZW0gZGlyZWN0aW9uXG4gICAgICBpZiAobm90ZV9zdHJ1Y3QuYXV0b19zdGVtKSB7XG4gICAgICAgIHRoaXMuYXV0b1N0ZW0oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0U3RlbURpcmVjdGlvbihub3RlX3N0cnVjdC5zdGVtX2RpcmVjdGlvbik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVpbGROb3RlSGVhZHMoKTtcblxuICAgICAgLy8gQ2FsY3VsYXRlIGxlZnQvcmlnaHQgcGFkZGluZ1xuICAgICAgdGhpcy5jYWxjRXh0cmFQeCgpO1xuICAgIH0sXG5cbiAgICAvLyBCdWlsZHMgYSBgU3RlbWAgZm9yIHRoZSBub3RlXG4gICAgYnVpbGRTdGVtOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBnbHlwaCA9IHRoaXMuZ2V0R2x5cGgoKTtcblxuICAgICAgdmFyIHlfZXh0ZW5kID0gMDtcbiAgICAgIGlmIChnbHlwaC5jb2RlX2hlYWQgPT0gXCJ2OTVcIiB8fCBnbHlwaC5jb2RlX2hlYWQgPT0gXCJ2M2VcIikge1xuICAgICAgICAgeV9leHRlbmQgPSAtNDtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0ZW0gPSBuZXcgU3RlbSh7XG4gICAgICAgIHlfZXh0ZW5kOiB5X2V4dGVuZFxuICAgICAgfSk7XG5cbiAgICAgIGlmICh0aGlzLmlzUmVzdCgpKSB7XG4gICAgICAgIHN0ZW0uaGlkZSA9IHRydWU7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc2V0U3RlbShzdGVtKTtcbiAgICB9LFxuXG4gICAgLy8gQnVpbGRzIGEgYE5vdGVIZWFkYCBmb3IgZWFjaCBrZXkgaW4gdGhlIG5vdGVcbiAgICBidWlsZE5vdGVIZWFkczogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RlbV9kaXJlY3Rpb24gPSB0aGlzLmdldFN0ZW1EaXJlY3Rpb24oKTtcblxuICAgICAgdmFyIGtleXMgPSB0aGlzLmdldEtleXMoKTtcblxuICAgICAgdmFyIGxhc3RfbGluZSA9IG51bGw7XG4gICAgICB2YXIgbGluZV9kaWZmID0gbnVsbDtcbiAgICAgIHZhciBkaXNwbGFjZWQgPSBmYWxzZTtcblxuICAgICAgLy8gRHJhdyBub3RlcyBmcm9tIGJvdHRvbSB0byB0b3AuXG4gICAgICB2YXIgc3RhcnRfaSA9IDA7XG4gICAgICB2YXIgZW5kX2kgPSBrZXlzLmxlbmd0aDtcbiAgICAgIHZhciBzdGVwX2kgPSAxO1xuXG4gICAgICAvLyBGb3IgZG93bi1zdGVtIG5vdGVzLCB3ZSBkcmF3IGZyb20gdG9wIHRvIGJvdHRvbS5cbiAgICAgIGlmIChzdGVtX2RpcmVjdGlvbiA9PT0gU3RlbS5ET1dOKSB7XG4gICAgICAgIHN0YXJ0X2kgPSBrZXlzLmxlbmd0aCAtIDE7XG4gICAgICAgIGVuZF9pID0gLTE7XG4gICAgICAgIHN0ZXBfaSA9IC0xO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gc3RhcnRfaTsgaSAhPSBlbmRfaTsgaSArPSBzdGVwX2kpIHtcbiAgICAgICAgdmFyIG5vdGVfcHJvcHMgPSB0aGlzLmtleVByb3BzW2ldO1xuXG4gICAgICAgIHZhciBsaW5lID0gbm90ZV9wcm9wcy5saW5lO1xuXG4gICAgICAgIC8vIEtlZXAgdHJhY2sgb2YgbGFzdCBsaW5lIHdpdGggYSBub3RlIGhlYWQsIHNvIHRoYXQgY29uc2VjdXRpdmUgaGVhZHNcbiAgICAgICAgLy8gYXJlIGNvcnJlY3RseSBkaXNwbGFjZWQuXG4gICAgICAgIGlmIChsYXN0X2xpbmUgPT09IG51bGwpIHtcbiAgICAgICAgICBsYXN0X2xpbmUgPSBsaW5lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxpbmVfZGlmZiA9IE1hdGguYWJzKGxhc3RfbGluZSAtIGxpbmUpO1xuICAgICAgICAgIGlmIChsaW5lX2RpZmYgPT09IDAgfHwgbGluZV9kaWZmID09PSAwLjUpIHtcbiAgICAgICAgICAgIGRpc3BsYWNlZCA9ICFkaXNwbGFjZWQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGRpc3BsYWNlZCA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy51c2VfZGVmYXVsdF9oZWFkX3ggPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBsYXN0X2xpbmUgPSBsaW5lO1xuXG4gICAgICAgIHZhciBub3RlX2hlYWQgPSBuZXcgTm90ZUhlYWQoe1xuICAgICAgICAgIGR1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxuICAgICAgICAgIG5vdGVfdHlwZTogdGhpcy5ub3RlVHlwZSxcbiAgICAgICAgICBkaXNwbGFjZWQ6IGRpc3BsYWNlZCxcbiAgICAgICAgICBzdGVtX2RpcmVjdGlvbjogc3RlbV9kaXJlY3Rpb24sXG4gICAgICAgICAgY3VzdG9tX2dseXBoX2NvZGU6IG5vdGVfcHJvcHMuY29kZSxcbiAgICAgICAgICBnbHlwaF9mb250X3NjYWxlOiB0aGlzLnJlbmRlcl9vcHRpb25zLmdseXBoX2ZvbnRfc2NhbGUsXG4gICAgICAgICAgeF9zaGlmdDogbm90ZV9wcm9wcy5zaGlmdF9yaWdodCxcbiAgICAgICAgICBsaW5lOiBub3RlX3Byb3BzLmxpbmVcbiAgICAgICAgfSk7XG5cbiAgICAgICAgdGhpcy5ub3RlX2hlYWRzW2ldID0gbm90ZV9oZWFkO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBBdXRvbWF0aWNhbGx5IHNldHMgdGhlIHN0ZW0gZGlyZWN0aW9uIGJhc2VkIG9uIHRoZSBrZXlzIGluIHRoZSBub3RlXG4gICAgYXV0b1N0ZW06IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGF1dG9fc3RlbV9kaXJlY3Rpb247XG5cbiAgICAgIC8vIEZpZ3VyZSBvdXQgb3B0aW1hbCBzdGVtIGRpcmVjdGlvbiBiYXNlZCBvbiBnaXZlbiBub3Rlc1xuICAgICAgdGhpcy5taW5fbGluZSA9IHRoaXMua2V5UHJvcHNbMF0ubGluZTtcbiAgICAgIHRoaXMubWF4X2xpbmUgPSB0aGlzLmtleVByb3BzW3RoaXMua2V5UHJvcHMubGVuZ3RoIC0gMV0ubGluZTtcbiAgICAgIHZhciBkZWNpZGVyID0gKHRoaXMubWluX2xpbmUgKyB0aGlzLm1heF9saW5lKSAvIDI7XG5cbiAgICAgIGlmIChkZWNpZGVyIDwgMykge1xuICAgICAgICBhdXRvX3N0ZW1fZGlyZWN0aW9uID0gMTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGF1dG9fc3RlbV9kaXJlY3Rpb24gPSAtMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5zZXRTdGVtRGlyZWN0aW9uKGF1dG9fc3RlbV9kaXJlY3Rpb24pO1xuICAgIH0sXG5cbiAgICAvLyBDYWxjdWxhdGVzIGFuZCBzdG9yZXMgdGhlIHByb3BlcnRpZXMgZm9yIGVhY2gga2V5IGluIHRoZSBub3RlXG4gICAgY2FsY3VsYXRlS2V5UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3RfbGluZSA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMua2V5cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIga2V5ID0gdGhpcy5rZXlzW2ldO1xuXG4gICAgICAgIC8vIEFsbCByZXN0cyB1c2UgdGhlIHNhbWUgcG9zaXRpb24gb24gdGhlIGxpbmUuXG4gICAgICAgIC8vIGlmICh0aGlzLmdseXBoLnJlc3QpIGtleSA9IHRoaXMuZ2x5cGgucG9zaXRpb247XG4gICAgICAgIGlmICh0aGlzLmdseXBoLnJlc3QpIHRoaXMuZ2x5cGgucG9zaXRpb24gPSBrZXk7XG4gICAgICAgIHZhciBvcHRpb25zID0geyBvY3RhdmVfc2hpZnQ6IHRoaXMub2N0YXZlX3NoaWZ0IHx8IDAgfTtcbiAgICAgICAgdmFyIHByb3BzID0gVmV4LkZsb3cua2V5UHJvcGVydGllcyhrZXksIHRoaXMuY2xlZiwgb3B0aW9ucyk7XG4gICAgICAgIGlmICghcHJvcHMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLFxuICAgICAgICAgICAgICBcIkludmFsaWQga2V5IGZvciBub3RlIHByb3BlcnRpZXM6IFwiICsga2V5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIE92ZXJyaWRlIGxpbmUgcGxhY2VtZW50IGZvciBkZWZhdWx0IHJlc3RzXG4gICAgICAgIGlmIChwcm9wcy5rZXkgPT09IFwiUlwiKSB7XG4gICAgICAgICAgaWYgKHRoaXMuZHVyYXRpb24gPT09IFwiMVwiIHx8IHRoaXMuZHVyYXRpb24gPT09IFwid1wiKSB7XG4gICAgICAgICAgICBwcm9wcy5saW5lID0gNDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcHJvcHMubGluZSA9IDM7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gQ2FsY3VsYXRlIGRpc3BsYWNlbWVudCBvZiB0aGlzIG5vdGVcbiAgICAgICAgdmFyIGxpbmUgPSBwcm9wcy5saW5lO1xuICAgICAgICBpZiAobGFzdF9saW5lID09PSBudWxsKSB7XG4gICAgICAgICAgbGFzdF9saW5lID0gbGluZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAoTWF0aC5hYnMobGFzdF9saW5lIC0gbGluZSkgPT0gMC41KSB7XG4gICAgICAgICAgICB0aGlzLmRpc3BsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICBwcm9wcy5kaXNwbGFjZWQgPSB0cnVlO1xuXG4gICAgICAgICAgICAvLyBIYXZlIHRvIG1hcmsgdGhlIHByZXZpb3VzIG5vdGUgYXNcbiAgICAgICAgICAgIC8vIGRpc3BsYWNlZCBhcyB3ZWxsLCBmb3IgbW9kaWZpZXIgcGxhY2VtZW50XG4gICAgICAgICAgICBpZiAodGhpcy5rZXlQcm9wcy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5rZXlQcm9wc1tpLTFdLmRpc3BsYWNlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGFzdF9saW5lID0gbGluZTtcbiAgICAgICAgdGhpcy5rZXlQcm9wcy5wdXNoKHByb3BzKTtcbiAgICAgIH1cblxuICAgICAgLy8gU29ydCB0aGUgbm90ZXMgZnJvbSBsb3dlc3QgbGluZSB0byBoaWdoZXN0IGxpbmVcbiAgICAgIHZhciBzb3J0ZWQgPSB0cnVlO1xuICAgICAgdmFyIGxhc3RMaW5lID0gLTEwMDA7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGlzLmtleVByb3BzLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIGlmIChrZXkubGluZSA8IGxhc3RMaW5lKSB7XG4gICAgICAgICAgVmV4LlcoXCJVbnNvcnRlZCBrZXlzIGluIG5vdGUgd2lsbCBiZSBzb3J0ZWQuIFwiICtcbiAgICAgICAgICAgIFwiU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS8weGZlL3ZleGZsb3cvaXNzdWVzLzEwNCBmb3IgZGV0YWlscy5cIik7XG4gICAgICAgIH1cbiAgICAgICAgbGFzdExpbmUgPSBrZXkubGluZTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5rZXlQcm9wcy5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIGEubGluZSAtIGIubGluZTsgfSk7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgYEJvdW5kaW5nQm94YCBmb3IgdGhlIGVudGlyZSBub3RlXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnByZUZvcm1hdHRlZCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiVW5mb3JtYXR0ZWROb3RlXCIsXG4gICAgICAgICAgXCJDYW4ndCBjYWxsIGdldEJvdW5kaW5nQm94IG9uIGFuIHVuZm9ybWF0dGVkIG5vdGUuXCIpO1xuXG4gICAgICB2YXIgbWV0cmljcyA9IHRoaXMuZ2V0TWV0cmljcygpO1xuXG4gICAgICB2YXIgdyA9IG1ldHJpY3Mud2lkdGg7XG4gICAgICB2YXIgeCA9IHRoaXMuZ2V0QWJzb2x1dGVYKCkgLSBtZXRyaWNzLm1vZExlZnRQeCAtIG1ldHJpY3MuZXh0cmFMZWZ0UHg7XG5cbiAgICAgIHZhciBtaW5feSA9IDA7XG4gICAgICB2YXIgbWF4X3kgPSAwO1xuICAgICAgdmFyIGhhbGZfbGluZV9zcGFjaW5nID0gdGhpcy5nZXRTdGF2ZSgpLmdldFNwYWNpbmdCZXR3ZWVuTGluZXMoKSAvIDI7XG4gICAgICB2YXIgbGluZV9zcGFjaW5nID0gaGFsZl9saW5lX3NwYWNpbmcgKiAyO1xuXG4gICAgICBpZiAodGhpcy5pc1Jlc3QoKSkge1xuICAgICAgICB2YXIgeSA9IHRoaXMueXNbMF07XG4gICAgICAgIHZhciBmcmFjID0gVmV4LkZsb3cuZHVyYXRpb25Ub0ZyYWN0aW9uKHRoaXMuZHVyYXRpb24pO1xuICAgICAgICBpZiAoZnJhYy5lcXVhbHMoMSkgfHwgZnJhYy5lcXVhbHMoMikpIHtcbiAgICAgICAgICBtaW5feSA9IHkgLSBoYWxmX2xpbmVfc3BhY2luZztcbiAgICAgICAgICBtYXhfeSA9IHkgKyBoYWxmX2xpbmVfc3BhY2luZztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBtaW5feSA9IHkgLSAodGhpcy5nbHlwaC5saW5lX2Fib3ZlICogbGluZV9zcGFjaW5nKTtcbiAgICAgICAgICBtYXhfeSA9IHkgKyAodGhpcy5nbHlwaC5saW5lX2JlbG93ICogbGluZV9zcGFjaW5nKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0aGlzLmdseXBoLnN0ZW0pIHtcbiAgICAgICAgdmFyIHlzID0gdGhpcy5nZXRTdGVtRXh0ZW50cygpO1xuICAgICAgICB5cy5iYXNlWSArPSBoYWxmX2xpbmVfc3BhY2luZyAqIHRoaXMuc3RlbV9kaXJlY3Rpb247XG4gICAgICAgIG1pbl95ID0gVmV4Lk1pbih5cy50b3BZLCB5cy5iYXNlWSk7XG4gICAgICAgIG1heF95ID0gVmV4Lk1heCh5cy50b3BZLCB5cy5iYXNlWSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtaW5feSA9IG51bGw7XG4gICAgICAgIG1heF95ID0gbnVsbDtcblxuICAgICAgICBmb3IgKHZhciBpPTA7IGkgPCB0aGlzLnlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIHl5ID0gdGhpcy55c1tpXTtcbiAgICAgICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICAgICAgbWluX3kgPSB5eTtcbiAgICAgICAgICAgIG1heF95ID0geXk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIG1pbl95ID0gVmV4Lk1pbih5eSwgbWluX3kpO1xuICAgICAgICAgICAgbWF4X3kgPSBWZXguTWF4KHl5LCBtYXhfeSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG1pbl95IC09IGhhbGZfbGluZV9zcGFjaW5nO1xuICAgICAgICAgIG1heF95ICs9IGhhbGZfbGluZV9zcGFjaW5nO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBuZXcgVmV4LkZsb3cuQm91bmRpbmdCb3goeCwgbWluX3ksIHcsIG1heF95IC0gbWluX3kpO1xuICAgIH0sXG5cbiAgICAvLyBHZXRzIHRoZSBsaW5lIG51bWJlciBvZiB0aGUgdG9wIG9yIGJvdHRvbSBub3RlIGluIHRoZSBjaG9yZC5cbiAgICAvLyBJZiBgaXNfdG9wX25vdGVgIGlzIGB0cnVlYCB0aGVuIGdldCB0aGUgdG9wIG5vdGVcbiAgICBnZXRMaW5lTnVtYmVyOiBmdW5jdGlvbihpc190b3Bfbm90ZSkge1xuICAgICAgaWYoIXRoaXMua2V5UHJvcHMubGVuZ3RoKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0tleVByb3BzXCIsXG4gICAgICAgICAgXCJDYW4ndCBnZXQgYm90dG9tIG5vdGUgbGluZSwgYmVjYXVzZSBub3RlIGlzIG5vdCBpbml0aWFsaXplZCBwcm9wZXJseS5cIik7XG4gICAgICB2YXIgcmVzdWx0X2xpbmUgPSB0aGlzLmtleVByb3BzWzBdLmxpbmU7XG5cbiAgICAgIC8vIE5vIHByZWNvbmRpdGlvbiBhc3N1bWVkIGZvciBzb3J0ZWRuZXNzIG9mIGtleVByb3BzIGFycmF5XG4gICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5rZXlQcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgdGhpc19saW5lID0gdGhpcy5rZXlQcm9wc1tpXS5saW5lO1xuICAgICAgICBpZiAoaXNfdG9wX25vdGUpIHtcbiAgICAgICAgICBpZiAodGhpc19saW5lID4gcmVzdWx0X2xpbmUpIHJlc3VsdF9saW5lID0gdGhpc19saW5lO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmICh0aGlzX2xpbmUgPCByZXN1bHRfbGluZSkgcmVzdWx0X2xpbmUgPSB0aGlzX2xpbmU7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3VsdF9saW5lO1xuICAgIH0sXG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgY3VycmVudCBub3RlIGlzIGEgcmVzdFxuICAgIGlzUmVzdDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmdseXBoLnJlc3Q7IH0sXG5cbiAgICAvLyBEZXRlcm1pbmUgaWYgdGhlIGN1cnJlbnQgbm90ZSBpcyBhIGNob3JkXG4gICAgaXNDaG9yZDogZnVuY3Rpb24oKSB7IHJldHVybiAhdGhpcy5pc1Jlc3QoKSAmJiB0aGlzLmtleXMubGVuZ3RoID4gMTsgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgYFN0YXZlTm90ZWAgaGFzIGEgc3RlbVxuICAgIGhhc1N0ZW06IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5nbHlwaC5zdGVtOyB9LFxuXG4gICAgLy8gR2V0IHRoZSBgeWAgY29vcmRpbmF0ZSBmb3IgdGV4dCBwbGFjZWQgb24gdGhlIHRvcC9ib3R0b20gb2YgYVxuICAgIC8vIG5vdGUgYXQgYSBkZXNpcmVkIGB0ZXh0X2xpbmVgXG4gICAgZ2V0WUZvclRvcFRleHQ6IGZ1bmN0aW9uKHRleHRfbGluZSkge1xuICAgICAgdmFyIGV4dGVudHMgPSB0aGlzLmdldFN0ZW1FeHRlbnRzKCk7XG4gICAgICByZXR1cm4gVmV4Lk1pbih0aGlzLnN0YXZlLmdldFlGb3JUb3BUZXh0KHRleHRfbGluZSksXG4gICAgICAgICAgZXh0ZW50cy50b3BZIC0gKHRoaXMucmVuZGVyX29wdGlvbnMuYW5ub3RhdGlvbl9zcGFjaW5nICogKHRleHRfbGluZSArIDEpKSk7XG4gICAgfSxcbiAgICBnZXRZRm9yQm90dG9tVGV4dDogZnVuY3Rpb24odGV4dF9saW5lKSB7XG4gICAgICB2YXIgZXh0ZW50cyA9IHRoaXMuZ2V0U3RlbUV4dGVudHMoKTtcbiAgICAgIHJldHVybiBWZXguTWF4KHRoaXMuc3RhdmUuZ2V0WUZvclRvcFRleHQodGV4dF9saW5lKSxcbiAgICAgICAgICBleHRlbnRzLmJhc2VZICsgKHRoaXMucmVuZGVyX29wdGlvbnMuYW5ub3RhdGlvbl9zcGFjaW5nICogKHRleHRfbGluZSkpKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0cyB0aGUgY3VycmVudCBub3RlIHRvIHRoZSBwcm92aWRlZCBgc3RhdmVgLiBUaGlzIGFwcGxpZXNcbiAgICAvLyBgeWAgdmFsdWVzIHRvIHRoZSBgTm90ZUhlYWRzYC5cbiAgICBzZXRTdGF2ZTogZnVuY3Rpb24oc3RhdmUpIHtcbiAgICAgIHZhciBzdXBlcmNsYXNzID0gVmV4LkZsb3cuU3RhdmVOb3RlLnN1cGVyY2xhc3M7XG4gICAgICBzdXBlcmNsYXNzLnNldFN0YXZlLmNhbGwodGhpcywgc3RhdmUpO1xuXG4gICAgICB2YXIgeXMgPSB0aGlzLm5vdGVfaGVhZHMubWFwKGZ1bmN0aW9uKG5vdGVfaGVhZCkge1xuICAgICAgICBub3RlX2hlYWQuc2V0U3RhdmUoc3RhdmUpO1xuICAgICAgICByZXR1cm4gbm90ZV9oZWFkLmdldFkoKTtcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnNldFlzKHlzKTtcblxuICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Tm90ZUhlYWRCb3VuZHMoKTtcblx0ICAgIGlmICh0aGlzLmhhc1N0ZW0oKSkge1xuICAgICAgICB0aGlzLnN0ZW0uc2V0WUJvdW5kcyhib3VuZHMueV90b3AsIGJvdW5kcy55X2JvdHRvbSk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHBpdGNoZXMgaW4gdGhlIG5vdGVcbiAgICBnZXRLZXlzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMua2V5czsgfSxcblxuICAgIC8vIEdldCB0aGUgcHJvcGVydGllcyBmb3IgYWxsIHRoZSBrZXlzIGluIHRoZSBub3RlXG4gICAgZ2V0S2V5UHJvcHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5UHJvcHM7XG4gICAgfSxcblxuICAgIC8vIENoZWNrIGlmIG5vdGUgaXMgc2hpZnRlZCB0byB0aGUgcmlnaHRcbiAgICBpc0Rpc3BsYWNlZDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXNwbGFjZWQ7XG4gICAgfSxcblxuICAgIC8vIFNldHMgd2hldGhlciBzaGlmdCBub3RlIHRvIHRoZSByaWdodC4gYGRpc3BsYWNlZGAgaXMgYSBgYm9vbGVhbmBcbiAgICBzZXROb3RlRGlzcGxhY2VkOiBmdW5jdGlvbihkaXNwbGFjZWQpIHtcbiAgICAgIHRoaXMuZGlzcGxhY2VkID0gZGlzcGxhY2VkO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgc3RhcnRpbmcgYHhgIGNvb3JkaW5hdGUgZm9yIGEgYFN0YXZlVGllYFxuICAgIGdldFRpZVJpZ2h0WDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGllU3RhcnRYID0gdGhpcy5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgIHRpZVN0YXJ0WCArPSB0aGlzLmdseXBoLmhlYWRfd2lkdGggKyB0aGlzLnhfc2hpZnQgKyB0aGlzLmV4dHJhUmlnaHRQeDtcbiAgICAgIGlmICh0aGlzLm1vZGlmaWVyQ29udGV4dCkgdGllU3RhcnRYICs9IHRoaXMubW9kaWZpZXJDb250ZXh0LmdldEV4dHJhUmlnaHRQeCgpO1xuICAgICAgcmV0dXJuIHRpZVN0YXJ0WDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBlbmRpbmcgYHhgIGNvb3JkaW5hdGUgZm9yIGEgYFN0YXZlVGllYFxuICAgIGdldFRpZUxlZnRYOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aWVFbmRYID0gdGhpcy5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgIHRpZUVuZFggKz0gdGhpcy54X3NoaWZ0IC0gdGhpcy5leHRyYUxlZnRQeDtcbiAgICAgIHJldHVybiB0aWVFbmRYO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHN0YXZlIGxpbmUgb24gd2hpY2ggdG8gcGxhY2UgYSByZXN0XG4gICAgZ2V0TGluZUZvclJlc3Q6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHJlc3RfbGluZSA9IHRoaXMua2V5UHJvcHNbMF0ubGluZTtcbiAgICAgIGlmICh0aGlzLmtleVByb3BzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgdmFyIGxhc3RfbGluZSAgPSB0aGlzLmtleVByb3BzW3RoaXMua2V5UHJvcHMubGVuZ3RoIC0gMV0ubGluZTtcbiAgICAgICAgdmFyIHRvcCA9IFZleC5NYXgocmVzdF9saW5lLCBsYXN0X2xpbmUpO1xuICAgICAgICB2YXIgYm90ID0gVmV4Lk1pbihyZXN0X2xpbmUsIGxhc3RfbGluZSk7XG4gICAgICAgIHJlc3RfbGluZSA9IFZleC5NaWRMaW5lKHRvcCwgYm90KTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlc3RfbGluZTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IHRoZSBkZWZhdWx0IGB4YCBhbmQgYHlgIGNvb3JkaW5hdGVzIGZvciB0aGUgcHJvdmlkZWQgYHBvc2l0aW9uYFxuICAgIC8vIGFuZCBrZXkgYGluZGV4YFxuICAgIGdldE1vZGlmaWVyU3RhcnRYWTogZnVuY3Rpb24ocG9zaXRpb24sIGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMucHJlRm9ybWF0dGVkKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJVbmZvcm1hdHRlZE5vdGVcIixcbiAgICAgICAgICBcIkNhbid0IGNhbGwgR2V0TW9kaWZpZXJTdGFydFhZIG9uIGFuIHVuZm9ybWF0dGVkIG5vdGVcIik7XG5cbiAgICAgIGlmICh0aGlzLnlzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9ZVmFsdWVzXCIsXG4gICAgICAgICAgXCJObyBZLVZhbHVlcyBjYWxjdWxhdGVkIGZvciB0aGlzIG5vdGUuXCIpO1xuXG4gICAgICB2YXIgeCA9IDA7XG4gICAgICBpZiAocG9zaXRpb24gPT0gVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uTEVGVCkge1xuICAgICAgICAvLyBleHRyYV9sZWZ0X3B4XG4gICAgICAgIHggPSAtMSAqIDI7XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLlJJR0hUKSB7XG4gICAgICAgIC8vIGV4dHJhX3JpZ2h0X3B4XG4gICAgICAgIHggPSB0aGlzLmdseXBoLmhlYWRfd2lkdGggKyB0aGlzLnhfc2hpZnQgKyAyO1xuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PSBWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5CRUxPVyB8fFxuICAgICAgICAgICAgICAgICBwb3NpdGlvbiA9PSBWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5BQk9WRSkge1xuICAgICAgICB4ID0gdGhpcy5nbHlwaC5oZWFkX3dpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHsgeDogdGhpcy5nZXRBYnNvbHV0ZVgoKSArIHgsIHk6IHRoaXMueXNbaW5kZXhdIH07XG4gICAgfSxcblxuICAgIC8vIFNldHMgdGhlIHN0eWxlIG9mIHRoZSBjb21wbGV0ZSBTdGF2ZU5vdGUsIGluY2x1ZGluZyBhbGwga2V5c1xuICAgIC8vIGFuZCB0aGUgc3RlbS5cbiAgICBzZXRTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHRoaXMubm90ZV9oZWFkcy5mb3JFYWNoKGZ1bmN0aW9uKG5vdGVoZWFkKSB7XG4gICAgICAgIG5vdGVoZWFkLnNldFN0eWxlKHN0eWxlKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgICAgdGhpcy5zdGVtLnNldFN0eWxlKHN0eWxlKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0cyB0aGUgbm90ZWhlYWQgYXQgYGluZGV4YCB0byB0aGUgcHJvdmlkZWQgY29sb3JpbmcgYHN0eWxlYC5cbiAgICAvL1xuICAgIC8vIGBzdHlsZWAgaXMgYW4gYG9iamVjdGAgd2l0aCB0aGUgZm9sbG93aW5nIHByb3BlcnRpZXM6IGBzaGFkb3dDb2xvcmAsXG4gICAgLy8gYHNoYWRvd0JsdXJgLCBgZmlsbFN0eWxlYCwgYHN0cm9rZVN0eWxlYFxuICAgIHNldEtleVN0eWxlOiBmdW5jdGlvbihpbmRleCwgc3R5bGUpIHtcbiAgICAgIHRoaXMubm90ZV9oZWFkc1tpbmRleF0uc2V0U3R5bGUoc3R5bGUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEtleUxpbmU6IGZ1bmN0aW9uKGluZGV4LCBsaW5lKSB7XG4gICAgICB0aGlzLmtleVByb3BzW2luZGV4XS5saW5lID0gbGluZTtcbiAgICAgIHRoaXMubm90ZV9oZWFkc1tpbmRleF0uc2V0TGluZShsaW5lKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRLZXlMaW5lOiBmdW5jdGlvbihpbmRleCkge1xuICAgICAgcmV0dXJuIHRoaXMua2V5UHJvcHNbaW5kZXhdLmxpbmU7XG4gICAgfSxcblxuICAgIC8vIEFkZCBzZWxmIHRvIG1vZGlmaWVyIGNvbnRleHQuIGBtQ29udGV4dGAgaXMgdGhlIGBNb2RpZmllckNvbnRleHRgXG4gICAgLy8gdG8gYmUgYWRkZWQgdG8uXG4gICAgYWRkVG9Nb2RpZmllckNvbnRleHQ6IGZ1bmN0aW9uKG1Db250ZXh0KSB7XG4gICAgICB0aGlzLnNldE1vZGlmaWVyQ29udGV4dChtQ29udGV4dCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubW9kaWZpZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMubW9kaWZpZXJDb250ZXh0LmFkZE1vZGlmaWVyKHRoaXMubW9kaWZpZXJzW2ldKTtcbiAgICAgIH1cbiAgICAgIHRoaXMubW9kaWZpZXJDb250ZXh0LmFkZE1vZGlmaWVyKHRoaXMpO1xuICAgICAgdGhpcy5zZXRQcmVGb3JtYXR0ZWQoZmFsc2UpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEdlbmVyaWMgZnVuY3Rpb24gdG8gYWRkIG1vZGlmaWVycyB0byBhIG5vdGVcbiAgICAvL1xuICAgIC8vIFBhcmFtZXRlcnM6XG4gICAgLy8gKiBgaW5kZXhgOiBUaGUgaW5kZXggb2YgdGhlIGtleSB0aGF0IHdlJ3JlIG1vZGlmeWluZ1xuICAgIC8vICogYG1vZGlmaWVyYDogVGhlIG1vZGlmaWVyIHRvIGFkZFxuICAgIGFkZE1vZGlmaWVyOiBmdW5jdGlvbihpbmRleCwgbW9kaWZpZXIpIHtcbiAgICAgIG1vZGlmaWVyLnNldE5vdGUodGhpcyk7XG4gICAgICBtb2RpZmllci5zZXRJbmRleChpbmRleCk7XG4gICAgICB0aGlzLm1vZGlmaWVycy5wdXNoKG1vZGlmaWVyKTtcbiAgICAgIHRoaXMuc2V0UHJlRm9ybWF0dGVkKGZhbHNlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gYWRkIGFuIGFjY2lkZW50YWwgdG8gYSBrZXlcbiAgICBhZGRBY2NpZGVudGFsOiBmdW5jdGlvbihpbmRleCwgYWNjaWRlbnRhbCkge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkTW9kaWZpZXIoaW5kZXgsIGFjY2lkZW50YWwpO1xuICAgIH0sXG5cbiAgICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gYWRkIGFuIGFydGljdWxhdGlvbiB0byBhIGtleVxuICAgIGFkZEFydGljdWxhdGlvbjogZnVuY3Rpb24oaW5kZXgsIGFydGljdWxhdGlvbikge1xuICAgICAgcmV0dXJuIHRoaXMuYWRkTW9kaWZpZXIoaW5kZXgsIGFydGljdWxhdGlvbik7XG4gICAgfSxcblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBhZGQgYW4gYW5ub3RhdGlvbiB0byBhIGtleVxuICAgIGFkZEFubm90YXRpb246IGZ1bmN0aW9uKGluZGV4LCBhbm5vdGF0aW9uKSB7XG4gICAgICByZXR1cm4gdGhpcy5hZGRNb2RpZmllcihpbmRleCwgYW5ub3RhdGlvbik7XG4gICAgfSxcblxuICAgIC8vIEhlbHBlciBmdW5jdGlvbiB0byBhZGQgYSBkb3Qgb24gYSBzcGVjaWZpYyBrZXlcbiAgICBhZGREb3Q6IGZ1bmN0aW9uKGluZGV4KSB7XG4gICAgICB2YXIgZG90ID0gbmV3IFZleC5GbG93LkRvdCgpO1xuICAgICAgZG90LnNldERvdFNoaWZ0WSh0aGlzLmdseXBoLmRvdF9zaGlmdFkpO1xuICAgICAgdGhpcy5kb3RzKys7XG4gICAgICByZXR1cm4gdGhpcy5hZGRNb2RpZmllcihpbmRleCwgZG90KTtcbiAgICB9LFxuXG4gICAgLy8gQ29udmVuaWVuY2UgbWV0aG9kIHRvIGFkZCBkb3QgdG8gYWxsIGtleXMgaW4gbm90ZVxuICAgIGFkZERvdFRvQWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5rZXlzLmxlbmd0aDsgKytpKVxuICAgICAgICB0aGlzLmFkZERvdChpKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYWxsIGFjY2lkZW50YWxzIGluIHRoZSBgTW9kaWZpZXJDb250ZXh0YFxuICAgIGdldEFjY2lkZW50YWxzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm1vZGlmaWVyQ29udGV4dC5nZXRNb2RpZmllcnMoXCJhY2NpZGVudGFsc1wiKTtcbiAgICB9LFxuXG4gICAgLy8gR2V0IGFsbCBkb3RzIGluIHRoZSBgTW9kaWZpZXJDb250ZXh0YFxuICAgIGdldERvdHM6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubW9kaWZpZXJDb250ZXh0LmdldE1vZGlmaWVycyhcImRvdHNcIik7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgd2lkdGggb2YgdGhlIG5vdGUgaWYgaXQgaXMgZGlzcGxhY2VkLiBVc2VkIGZvciBgVm9pY2VgXG4gICAgLy8gZm9ybWF0dGluZ1xuICAgIGdldFZvaWNlU2hpZnRXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBUT0RPOiBtYXkgbmVlZCB0byBhY2NvbW9kYXRlIGZvciBkb3QgaGVyZS5cbiAgICAgIHJldHVybiB0aGlzLmdseXBoLmhlYWRfd2lkdGggKiAodGhpcy5kaXNwbGFjZWQgPyAyIDogMSk7XG4gICAgfSxcblxuICAgIC8vIENhbGN1bGF0ZXMgYW5kIHNldHMgdGhlIGV4dHJhIHBpeGVscyB0byB0aGUgbGVmdCBvciByaWdodFxuICAgIC8vIGlmIHRoZSBub3RlIGlzIGRpc3BsYWNlZC5cbiAgICBjYWxjRXh0cmFQeDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldEV4dHJhTGVmdFB4KCh0aGlzLmRpc3BsYWNlZCAmJiB0aGlzLnN0ZW1fZGlyZWN0aW9uID09IC0xKSA/XG4gICAgICAgICAgdGhpcy5nbHlwaC5oZWFkX3dpZHRoIDogMCk7XG5cbiAgICAgIC8vIEZvciB1cHN0ZW1zIHdpdGggZmxhZ3MsIHRoZSBleHRyYSBzcGFjZSBpcyB1bm5lY2Vzc2FyeSwgc2luY2UgaXQncyB0YWtlblxuICAgICAgLy8gdXAgYnkgdGhlIGZsYWcuXG4gICAgICB0aGlzLnNldEV4dHJhUmlnaHRQeCgoIXRoaXMuaGFzRmxhZygpICYmIHRoaXMuZGlzcGxhY2VkICYmIHRoaXMuc3RlbV9kaXJlY3Rpb24gPT0gMSkgP1xuICAgICAgICAgIHRoaXMuZ2x5cGguaGVhZF93aWR0aCA6IDApO1xuICAgIH0sXG5cbiAgICAvLyBQcmUtcmVuZGVyIGZvcm1hdHRpbmdcbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucHJlRm9ybWF0dGVkKSByZXR1cm47XG4gICAgICBpZiAodGhpcy5tb2RpZmllckNvbnRleHQpIHRoaXMubW9kaWZpZXJDb250ZXh0LnByZUZvcm1hdCgpO1xuXG4gICAgICB2YXIgd2lkdGggPSB0aGlzLmdseXBoLmhlYWRfd2lkdGggKyB0aGlzLmV4dHJhTGVmdFB4ICsgdGhpcy5leHRyYVJpZ2h0UHg7XG5cbiAgICAgIC8vIEZvciB1cHdhcmQgZmxhZ2dlZCBub3RlcywgdGhlIHdpZHRoIG9mIHRoZSBmbGFnIG5lZWRzIHRvIGJlIGFkZGVkXG4gICAgICBpZiAodGhpcy5nbHlwaC5mbGFnICYmIHRoaXMuYmVhbSA9PT0gbnVsbCAmJiB0aGlzLnN0ZW1fZGlyZWN0aW9uID09IDEpIHtcbiAgICAgICAgd2lkdGggKz0gdGhpcy5nbHlwaC5oZWFkX3dpZHRoO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFdpZHRoKHdpZHRoKTtcbiAgICAgIHRoaXMuc2V0UHJlRm9ybWF0dGVkKHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBHZXRzIHRoZSBzdGFmZiBsaW5lIGFuZCB5IHZhbHVlIGZvciB0aGUgaGlnaGVzdCBhbmQgbG93ZXN0IG5vdGVoZWFkc1xuICAgIGdldE5vdGVIZWFkQm91bmRzOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRvcCBhbmQgYm90dG9tIFkgdmFsdWVzIGZvciBzdGVtLlxuICAgICAgdmFyIHlfdG9wID0gbnVsbDtcbiAgICAgIHZhciB5X2JvdHRvbSA9IG51bGw7XG5cbiAgICAgIHZhciBoaWdoZXN0X2xpbmUgPSB0aGlzLnN0YXZlLmdldE51bUxpbmVzKCk7XG4gICAgICB2YXIgbG93ZXN0X2xpbmUgPSAxO1xuXG4gICAgICB0aGlzLm5vdGVfaGVhZHMuZm9yRWFjaChmdW5jdGlvbihub3RlX2hlYWQpIHtcbiAgICAgICAgdmFyIGxpbmUgPSBub3RlX2hlYWQuZ2V0TGluZSgpO1xuICAgICAgICB2YXIgeSA9IG5vdGVfaGVhZC5nZXRZKCk7XG5cbiAgICAgICAgaWYgKHlfdG9wID09PSBudWxsIHx8IHkgPCB5X3RvcCkgIHtcbiAgICAgICAgICB5X3RvcCA9IHk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoeV9ib3R0b20gPT09IG51bGwgfHwgeSA+IHlfYm90dG9tKSB7XG4gICAgICAgICAgeV9ib3R0b20gPSB5O1xuICAgICAgICB9XG5cbiAgICAgICAgaGlnaGVzdF9saW5lID0gbGluZSA+IGhpZ2hlc3RfbGluZSA/IGxpbmUgOiBoaWdoZXN0X2xpbmU7XG4gICAgICAgIGxvd2VzdF9saW5lID0gbGluZSA8IGxvd2VzdF9saW5lID8gbGluZSA6IGxvd2VzdF9saW5lO1xuXG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgeV90b3A6IHlfdG9wLFxuICAgICAgICB5X2JvdHRvbTogeV9ib3R0b20sXG4gICAgICAgIGhpZ2hlc3RfbGluZTogaGlnaGVzdF9saW5lLFxuICAgICAgICBsb3dlc3RfbGluZTogbG93ZXN0X2xpbmVcbiAgICAgIH07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgc3RhcnRpbmcgYHhgIGNvb3JkaW5hdGUgZm9yIHRoZSBub3RlaGVhZHNcbiAgICBnZXROb3RlSGVhZEJlZ2luWDogZnVuY3Rpb24oKXtcbiAgICAgIHJldHVybiB0aGlzLmdldEFic29sdXRlWCgpICsgdGhpcy54X3NoaWZ0O1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGVuZGluZyBgeGAgY29vcmRpbmF0ZSBmb3IgdGhlIG5vdGVoZWFkc1xuICAgIGdldE5vdGVIZWFkRW5kWDogZnVuY3Rpb24oKXtcbiAgICAgIHZhciB4X2JlZ2luID0gdGhpcy5nZXROb3RlSGVhZEJlZ2luWCgpO1xuICAgICAgcmV0dXJuIHhfYmVnaW4gKyB0aGlzLmdseXBoLmhlYWRfd2lkdGggLSAoVmV4LkZsb3cuU1RFTV9XSURUSCAvIDIpO1xuICAgIH0sXG5cbiAgICAvLyBEcmF3IHRoZSBsZWRnZXIgbGluZXMgYmV0d2VlbiB0aGUgc3RhdmUgYW5kIHRoZSBoaWdoZXN0L2xvd2VzdCBrZXlzXG4gICAgZHJhd0xlZGdlckxpbmVzOiBmdW5jdGlvbigpe1xuICAgICAgaWYgKHRoaXMuaXNSZXN0KCkpIHsgcmV0dXJuOyB9XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHdpdGhvdXQgYSBjYW52YXMgY29udGV4dC5cIik7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICB2YXIgYm91bmRzID0gdGhpcy5nZXROb3RlSGVhZEJvdW5kcygpO1xuICAgICAgdmFyIGhpZ2hlc3RfbGluZSA9IGJvdW5kcy5oaWdoZXN0X2xpbmU7XG4gICAgICB2YXIgbG93ZXN0X2xpbmUgPSBib3VuZHMubG93ZXN0X2xpbmU7XG4gICAgICB2YXIgaGVhZF94ID0gdGhpcy5ub3RlX2hlYWRzWzBdLmdldEFic29sdXRlWCgpO1xuXG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICBmdW5jdGlvbiBzdHJva2UoeSkge1xuICAgICAgICBpZiAodGhhdC51c2VfZGVmYXVsdF9oZWFkX3ggPT09IHRydWUpICB7XG4gICAgICAgICAgaGVhZF94ID0gdGhhdC5nZXRBYnNvbHV0ZVgoKSArIHRoYXQueF9zaGlmdDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgeCA9IGhlYWRfeCAtIHRoYXQucmVuZGVyX29wdGlvbnMuc3Ryb2tlX3B4O1xuICAgICAgICB2YXIgbGVuZ3RoID0gKChoZWFkX3ggKyB0aGF0LmdseXBoLmhlYWRfd2lkdGgpIC0gaGVhZF94KSArXG4gICAgICAgICAgKHRoYXQucmVuZGVyX29wdGlvbnMuc3Ryb2tlX3B4ICogMik7XG5cbiAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHksIGxlbmd0aCwgMSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lOyAvLyBpdGVyYXRvclxuICAgICAgZm9yIChsaW5lID0gNjsgbGluZSA8PSBoaWdoZXN0X2xpbmU7ICsrbGluZSkge1xuICAgICAgICBzdHJva2UodGhpcy5zdGF2ZS5nZXRZRm9yTm90ZShsaW5lKSk7XG4gICAgICB9XG5cbiAgICAgIGZvciAobGluZSA9IDA7IGxpbmUgPj0gbG93ZXN0X2xpbmU7IC0tbGluZSkge1xuICAgICAgICBzdHJva2UodGhpcy5zdGF2ZS5nZXRZRm9yTm90ZShsaW5lKSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIERyYXcgYWxsIGtleSBtb2RpZmllcnNcbiAgICBkcmF3TW9kaWZpZXJzOiBmdW5jdGlvbigpe1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ2FudmFzQ29udGV4dFwiLFxuICAgICAgICAgIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgY2FudmFzIGNvbnRleHQuXCIpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIGN0eC5vcGVuR3JvdXAoXCJtb2RpZmllcnNcIik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubW9kaWZpZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBtb2QgPSB0aGlzLm1vZGlmaWVyc1tpXTtcbiAgICAgICAgdmFyIG5vdGVfaGVhZCA9IHRoaXMubm90ZV9oZWFkc1ttb2QuZ2V0SW5kZXgoKV07XG4gICAgICAgIHZhciBrZXlfc3R5bGUgPSBub3RlX2hlYWQuZ2V0U3R5bGUoKTtcbiAgICAgICAgaWYoa2V5X3N0eWxlKSB7XG4gICAgICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICAgICAgbm90ZV9oZWFkLmFwcGx5U3R5bGUoY3R4KTtcbiAgICAgICAgfVxuICAgICAgICBtb2Quc2V0Q29udGV4dChjdHgpO1xuICAgICAgICBtb2QuZHJhdygpO1xuICAgICAgICBpZihrZXlfc3R5bGUpIHtcbiAgICAgICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGN0eC5jbG9zZUdyb3VwKCk7XG4gICAgfSxcblxuICAgIC8vIERyYXcgdGhlIGZsYWcgZm9yIHRoZSBub3RlXG4gICAgZHJhd0ZsYWc6IGZ1bmN0aW9uKCl7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHdpdGhvdXQgYSBjYW52YXMgY29udGV4dC5cIik7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaCgpO1xuICAgICAgdmFyIHJlbmRlcl9mbGFnID0gdGhpcy5iZWFtID09PSBudWxsO1xuICAgICAgdmFyIGJvdW5kcyA9IHRoaXMuZ2V0Tm90ZUhlYWRCb3VuZHMoKTtcblxuICAgICAgdmFyIHhfYmVnaW4gPSB0aGlzLmdldE5vdGVIZWFkQmVnaW5YKCk7XG4gICAgICB2YXIgeF9lbmQgPSB0aGlzLmdldE5vdGVIZWFkRW5kWCgpO1xuXG4gICAgICBpZiAoZ2x5cGguZmxhZyAmJiByZW5kZXJfZmxhZykge1xuICAgICAgICB2YXIgbm90ZV9zdGVtX2hlaWdodCA9IHRoaXMuc3RlbS5nZXRIZWlnaHQoKTtcbiAgICAgICAgdmFyIGZsYWdfeCwgZmxhZ195LCBmbGFnX2NvZGU7XG5cbiAgICAgICAgaWYgKHRoaXMuZ2V0U3RlbURpcmVjdGlvbigpID09PSBTdGVtLkRPV04pIHtcbiAgICAgICAgICAvLyBEb3duIHN0ZW1zIGhhdmUgZmxhZ3Mgb24gdGhlIGxlZnQuXG4gICAgICAgICAgZmxhZ194ID0geF9iZWdpbiArIDE7XG4gICAgICAgICAgZmxhZ195ID0gYm91bmRzLnlfdG9wIC0gbm90ZV9zdGVtX2hlaWdodCArIDI7XG4gICAgICAgICAgZmxhZ19jb2RlID0gZ2x5cGguY29kZV9mbGFnX2Rvd25zdGVtO1xuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gVXAgc3RlbXMgaGF2ZSBmbGFncyBvbiB0aGUgbGVmdC5cbiAgICAgICAgICBmbGFnX3ggPSB4X2VuZCArIDE7XG4gICAgICAgICAgZmxhZ195ID0gYm91bmRzLnlfYm90dG9tIC0gbm90ZV9zdGVtX2hlaWdodCAtIDI7XG4gICAgICAgICAgZmxhZ19jb2RlID0gZ2x5cGguY29kZV9mbGFnX3Vwc3RlbTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgdGhlIEZsYWdcbiAgICAgICAgdGhpcy5jb250ZXh0Lm9wZW5Hcm91cChcImZsYWdcIiwgbnVsbCwge3BvaW50ZXJCQm94OiB0cnVlfSk7XG4gICAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKGN0eCwgZmxhZ194LCBmbGFnX3ksXG4gICAgICAgICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLmdseXBoX2ZvbnRfc2NhbGUsIGZsYWdfY29kZSk7XG4gICAgICAgIHRoaXMuY29udGV4dC5jbG9zZUdyb3VwKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIERyYXcgdGhlIE5vdGVIZWFkc1xuICAgIGRyYXdOb3RlSGVhZHM6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG4gICAgICB0aGlzLm5vdGVfaGVhZHMuZm9yRWFjaChmdW5jdGlvbihub3RlX2hlYWQpIHtcbiAgICAgICAgdGhhdC5jb250ZXh0Lm9wZW5Hcm91cChcIm5vdGVoZWFkXCIsIG51bGwsIHtwb2ludGVyQkJveDogdHJ1ZX0pO1xuICAgICAgICBub3RlX2hlYWQuc2V0Q29udGV4dCh0aGF0LmNvbnRleHQpLmRyYXcoKTtcbiAgICAgICAgdGhhdC5jb250ZXh0LmNsb3NlR3JvdXAoKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBSZW5kZXIgdGhlIHN0ZW0gb250byB0aGUgY2FudmFzXG4gICAgZHJhd1N0ZW06IGZ1bmN0aW9uKHN0ZW1fc3RydWN0KXtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgd2l0aG91dCBhIGNhbnZhcyBjb250ZXh0LlwiKTtcblxuICAgICAgaWYgKHN0ZW1fc3RydWN0KSB7XG4gICAgICAgIHRoaXMuc2V0U3RlbShuZXcgU3RlbShzdGVtX3N0cnVjdCkpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmNvbnRleHQub3Blbkdyb3VwKFwic3RlbVwiLCBudWxsLCB7cG9pbnRlckJCb3g6IHRydWV9KTtcbiAgICAgIHRoaXMuc3RlbS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCkuZHJhdygpO1xuICAgICAgdGhpcy5jb250ZXh0LmNsb3NlR3JvdXAoKTtcbiAgICB9LFxuXG4gICAgLy8gRHJhd3MgYWxsIHRoZSBgU3RhdmVOb3RlYCBwYXJ0cy4gVGhpcyBpcyB0aGUgbWFpbiBkcmF3aW5nIG1ldGhvZC5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgd2l0aG91dCBhIGNhbnZhcyBjb250ZXh0LlwiKTtcbiAgICAgIGlmICghdGhpcy5zdGF2ZSkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9TdGF2ZVwiLFxuICAgICAgICAgIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgc3RhdmUuXCIpO1xuICAgICAgaWYgKHRoaXMueXMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1lWYWx1ZXNcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgbm90ZSB3aXRob3V0IFkgdmFsdWVzLlwiKTtcblxuICAgICAgdmFyIHhfYmVnaW4gPSB0aGlzLmdldE5vdGVIZWFkQmVnaW5YKCk7XG4gICAgICB2YXIgeF9lbmQgPSB0aGlzLmdldE5vdGVIZWFkRW5kWCgpO1xuXG4gICAgICB2YXIgcmVuZGVyX3N0ZW0gPSB0aGlzLmhhc1N0ZW0oKSAmJiAhdGhpcy5iZWFtO1xuXG4gICAgICAvLyBGb3JtYXQgbm90ZSBoZWFkIHggcG9zaXRpb25zXG4gICAgICB0aGlzLm5vdGVfaGVhZHMuZm9yRWFjaChmdW5jdGlvbihub3RlX2hlYWQpIHtcbiAgICAgICAgbm90ZV9oZWFkLnNldFgoeF9iZWdpbik7XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgLy8gRm9ybWF0IHN0ZW0geCBwb3NpdGlvbnNcbiAgICAgIHRoaXMuc3RlbS5zZXROb3RlSGVhZFhCb3VuZHMoeF9iZWdpbiwgeF9lbmQpO1xuXG4gICAgICBMKFwiUmVuZGVyaW5nIFwiLCB0aGlzLmlzQ2hvcmQoKSA/IFwiY2hvcmQgOlwiIDogXCJub3RlIDpcIiwgdGhpcy5rZXlzKTtcblxuICAgICAgLy8gRHJhdyBlYWNoIHBhcnQgb2YgdGhlIG5vdGVcbiAgICAgIHRoaXMuZHJhd0xlZGdlckxpbmVzKCk7XG5cbiAgICAgIHRoaXMuZWxlbSA9IHRoaXMuY29udGV4dC5vcGVuR3JvdXAoXCJzdGF2ZW5vdGVcIiwgdGhpcy5pZCk7XG4gICAgICB0aGlzLmNvbnRleHQub3Blbkdyb3VwKFwibm90ZVwiLCBudWxsLCB7cG9pbnRlckJCb3g6IHRydWV9KTtcbiAgICAgICAgaWYgKHJlbmRlcl9zdGVtKSB0aGlzLmRyYXdTdGVtKCk7XG4gICAgICAgIHRoaXMuZHJhd05vdGVIZWFkcygpO1xuICAgICAgICB0aGlzLmRyYXdGbGFnKCk7XG4gICAgICB0aGlzLmNvbnRleHQuY2xvc2VHcm91cCgpO1xuICAgICAgdGhpcy5kcmF3TW9kaWZpZXJzKCk7XG4gICAgICB0aGlzLmNvbnRleHQuY2xvc2VHcm91cCgpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFN0YXZlTm90ZTtcbn0oKSk7XG5cbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhlIGZpbGUgaW1wbGVtZW50cyBub3RlcyBmb3IgVGFibGF0dXJlIG5vdGF0aW9uLiBUaGlzIGNvbnNpc3RzIG9mIG9uZSBvclxuLy8gbW9yZSBmcmV0IHBvc2l0aW9ucywgYW5kIGNhbiBlaXRoZXIgYmUgZHJhd24gd2l0aCBvciB3aXRob3V0IHN0ZW1zLlxuLy9cbi8vIFNlZSBgdGVzdHMvdGFibm90ZV90ZXN0cy5qc2AgZm9yIHVzYWdlIGV4YW1wbGVzXG5WZXguRmxvdy5UYWJOb3RlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUYWJOb3RlKHRhYl9zdHJ1Y3QsIGRyYXdfc3RlbSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHRhYl9zdHJ1Y3QsIGRyYXdfc3RlbSk7XG4gIH1cblxuICB2YXIgU3RlbSA9IFZleC5GbG93LlN0ZW07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgVmV4LkluaGVyaXQoVGFiTm90ZSwgVmV4LkZsb3cuU3RlbW1hYmxlTm90ZSwge1xuICAgIC8vIEluaXRpYWxpemUgdGhlIFRhYk5vdGUgd2l0aCBhIGB0YWJfc3RydWN0YCBmdWxsIG9mIHByb3BlcnRpZXNcbiAgICAvLyBhbmQgd2hldGhlciB0byBgZHJhd19zdGVtYCB3aGVuIHJlbmRlcmluZyB0aGUgbm90ZVxuICAgIGluaXQ6IGZ1bmN0aW9uKHRhYl9zdHJ1Y3QsIGRyYXdfc3RlbSkge1xuICAgICAgdmFyIHN1cGVyY2xhc3MgPSBWZXguRmxvdy5UYWJOb3RlLnN1cGVyY2xhc3M7XG4gICAgICBzdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCB0YWJfc3RydWN0KTtcblxuICAgICAgdGhpcy5naG9zdCA9IGZhbHNlOyAvLyBSZW5kZXJzIHBhcmVudGhlc2lzIGFyb3VuZCBub3Rlc1xuICAgICAgLy8gTm90ZSBwcm9wZXJ0aWVzXG4gICAgICAvL1xuICAgICAgLy8gVGhlIGZyZXQgcG9zaXRpb25zIGluIHRoZSBub3RlLiBBbiBhcnJheSBvZiBgeyBzdHI6IFgsIGZyZXQ6IFggfWBcbiAgICAgIHRoaXMucG9zaXRpb25zID0gdGFiX3N0cnVjdC5wb3NpdGlvbnM7XG5cbiAgICAgIC8vIFJlbmRlciBPcHRpb25zXG4gICAgICBWZXguTWVyZ2UodGhpcy5yZW5kZXJfb3B0aW9ucywge1xuICAgICAgICAvLyBmb250IHNpemUgZm9yIG5vdGUgaGVhZHMgYW5kIHJlc3RzXG4gICAgICAgIGdseXBoX2ZvbnRfc2NhbGU6IDMwLFxuICAgICAgICAvLyBGbGFnIHRvIGRyYXcgYSBzdGVtXG4gICAgICAgIGRyYXdfc3RlbTogZHJhd19zdGVtLFxuICAgICAgICAvLyBGbGFnIHRvIGRyYXcgZG90IG1vZGlmaWVyc1xuICAgICAgICBkcmF3X2RvdHM6IGRyYXdfc3RlbSxcbiAgICAgICAgLy8gRmxhZyB0byBleHRlbmQgdGhlIG1haW4gc3RlbSB0aHJvdWdoIHRoZSBzdGF2ZSBhbmQgZnJldCBwb3NpdGlvbnNcbiAgICAgICAgZHJhd19zdGVtX3Rocm91Z2hfc3RhdmU6IGZhbHNlXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5nbHlwaCA9XG4gICAgICAgIFZleC5GbG93LmR1cmF0aW9uVG9HbHlwaCh0aGlzLmR1cmF0aW9uLCB0aGlzLm5vdGVUeXBlKTtcbiAgICAgIGlmICghdGhpcy5nbHlwaCkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLFxuICAgICAgICAgICAgXCJJbnZhbGlkIG5vdGUgaW5pdGlhbGl6YXRpb24gZGF0YSAoTm8gZ2x5cGggZm91bmQpOiBcIiArXG4gICAgICAgICAgICBKU09OLnN0cmluZ2lmeSh0YWJfc3RydWN0KSk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuYnVpbGRTdGVtKCk7XG5cbiAgICAgIGlmICh0YWJfc3RydWN0LnN0ZW1fZGlyZWN0aW9uKXtcbiAgICAgICAgdGhpcy5zZXRTdGVtRGlyZWN0aW9uKHRhYl9zdHJ1Y3Quc3RlbV9kaXJlY3Rpb24pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5zZXRTdGVtRGlyZWN0aW9uKFN0ZW0uVVApO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW5kZXJzIHBhcmVudGhlc2lzIGFyb3VuZCBub3Rlc1xuICAgICAgdGhpcy5naG9zdCA9IGZhbHNlO1xuICAgICAgdGhpcy51cGRhdGVXaWR0aCgpO1xuICAgIH0sXG5cbiAgICAvLyBUaGUgTW9kaWZpZXJDb250ZXh0IGNhdGVnb3J5XG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJ0YWJub3Rlc1wiOyB9LFxuXG4gICAgLy8gU2V0IGFzIGdob3N0IGBUYWJOb3RlYCwgc3Vycm91bmRzIHRoZSBmcmV0IHBvc2l0aW9ucyB3aXRoIHBhcmVudGhlc2lzLlxuICAgIC8vIE9mdGVuIHVzZWQgZm9yIGluZGljYXRpbmcgZnJldHMgdGhhdCBhcmUgYmVpbmcgYmVudCB0b1xuICAgIHNldEdob3N0OiBmdW5jdGlvbihnaG9zdCkge1xuICAgICAgdGhpcy5naG9zdCA9IGdob3N0O1xuICAgICAgdGhpcy51cGRhdGVXaWR0aCgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIERldGVybWluZSBpZiB0aGUgbm90ZSBoYXMgYSBzdGVtXG4gICAgaGFzU3RlbTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnJlbmRlcl9vcHRpb25zLmRyYXdfc3RlbTsgfSxcblxuICAgIC8vIEdldCB0aGUgZGVmYXVsdCBzdGVtIGV4dGVuc2lvbiBmb3IgdGhlIG5vdGVcbiAgICBnZXRTdGVtRXh0ZW5zaW9uOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGdseXBoID0gdGhpcy5nZXRHbHlwaCgpO1xuXG4gICAgICBpZiAodGhpcy5zdGVtX2V4dGVuc2lvbl9vdmVycmlkZSAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0ZW1fZXh0ZW5zaW9uX292ZXJyaWRlO1xuICAgICAgfVxuXG4gICAgICBpZiAoZ2x5cGgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0U3RlbURpcmVjdGlvbigpID09PSAxID8gZ2x5cGgudGFibm90ZV9zdGVtX3VwX2V4dGVuc2lvbiA6XG4gICAgICAgICAgZ2x5cGgudGFibm90ZV9zdGVtX2Rvd25fZXh0ZW5zaW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgLy8gQWRkIGEgZG90IHRvIHRoZSBub3RlXG4gICAgYWRkRG90OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBkb3QgPSBuZXcgVmV4LkZsb3cuRG90KCk7XG4gICAgICB0aGlzLmRvdHMrKztcbiAgICAgIHJldHVybiB0aGlzLmFkZE1vZGlmaWVyKGRvdCwgMCk7XG4gICAgfSxcblxuICAgIC8vIENhbGN1bGF0ZSBhbmQgc3RvcmUgdGhlIHdpZHRoIG9mIHRoZSBub3RlXG4gICAgdXBkYXRlV2lkdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5nbHlwaHMgPSBbXTtcbiAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvc2l0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgZnJldCA9IHRoaXMucG9zaXRpb25zW2ldLmZyZXQ7XG4gICAgICAgIGlmICh0aGlzLmdob3N0KSBmcmV0ID0gXCIoXCIgKyBmcmV0ICsgXCIpXCI7XG4gICAgICAgIHZhciBnbHlwaCA9IFZleC5GbG93LnRhYlRvR2x5cGgoZnJldCk7XG4gICAgICAgIHRoaXMuZ2x5cGhzLnB1c2goZ2x5cGgpO1xuICAgICAgICB0aGlzLndpZHRoID0gKGdseXBoLndpZHRoID4gdGhpcy53aWR0aCkgPyBnbHlwaC53aWR0aCA6IHRoaXMud2lkdGg7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFNldCB0aGUgYHN0YXZlYCB0byB0aGUgbm90ZVxuICAgIHNldFN0YXZlOiBmdW5jdGlvbihzdGF2ZSkge1xuICAgICAgdmFyIHN1cGVyY2xhc3MgPSBWZXguRmxvdy5UYWJOb3RlLnN1cGVyY2xhc3M7XG4gICAgICBzdXBlcmNsYXNzLnNldFN0YXZlLmNhbGwodGhpcywgc3RhdmUpO1xuICAgICAgdGhpcy5jb250ZXh0ID0gc3RhdmUuY29udGV4dDtcbiAgICAgIHRoaXMud2lkdGggPSAwO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIGZyZXQgbnVtYmVyIHdpZHRoIGJhc2VkIG9uIGZvbnQgdXNlZFxuICAgICAgdmFyIGk7XG4gICAgICBpZiAodGhpcy5jb250ZXh0KSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmdseXBocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciB0ZXh0ID0gXCJcIiArIHRoaXMuZ2x5cGhzW2ldLnRleHQ7XG4gICAgICAgICAgaWYgKHRleHQudG9VcHBlckNhc2UoKSAhPSBcIlhcIilcbiAgICAgICAgICAgIHRoaXMuZ2x5cGhzW2ldLndpZHRoID0gdGhpcy5jb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoO1xuICAgICAgICAgIHRoaXMud2lkdGggPSAodGhpcy5nbHlwaHNbaV0ud2lkdGggPiB0aGlzLndpZHRoKSA/XG4gICAgICAgICAgICB0aGlzLmdseXBoc1tpXS53aWR0aCA6IHRoaXMud2lkdGg7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIHlzID0gW107XG5cbiAgICAgIC8vIFNldHVwIHkgY29vcmRpbmF0ZXMgZm9yIHNjb3JlLlxuICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMucG9zaXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBsaW5lID0gdGhpcy5wb3NpdGlvbnNbaV0uc3RyO1xuICAgICAgICB5cy5wdXNoKHRoaXMuc3RhdmUuZ2V0WUZvckxpbmUobGluZSAtIDEpKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMuc2V0WXMoeXMpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIGZyZXQgcG9zaXRpb25zIGZvciB0aGUgbm90ZVxuICAgIGdldFBvc2l0aW9uczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnBvc2l0aW9uczsgfSxcblxuICAgIC8vIEFkZCBzZWxmIHRvIHRoZSBwcm92aWRlZCBtb2RpZmllciBjb250ZXh0IGBtY2BcbiAgICBhZGRUb01vZGlmaWVyQ29udGV4dDogZnVuY3Rpb24obWMpIHtcbiAgICAgIHRoaXMuc2V0TW9kaWZpZXJDb250ZXh0KG1jKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5tb2RpZmllcnMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5tb2RpZmllckNvbnRleHQuYWRkTW9kaWZpZXIodGhpcy5tb2RpZmllcnNbaV0pO1xuICAgICAgfVxuICAgICAgdGhpcy5tb2RpZmllckNvbnRleHQuYWRkTW9kaWZpZXIodGhpcyk7XG4gICAgICB0aGlzLnByZUZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgYHhgIGNvb3JkaW5hdGUgdG8gdGhlIHJpZ2h0IG9mIHRoZSBub3RlXG4gICAgZ2V0VGllUmlnaHRYOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0aWVTdGFydFggPSB0aGlzLmdldEFic29sdXRlWCgpO1xuICAgICAgdmFyIG5vdGVfZ2x5cGhfd2lkdGggPSB0aGlzLmdseXBoLmhlYWRfd2lkdGg7XG4gICAgICB0aWVTdGFydFggKz0gKG5vdGVfZ2x5cGhfd2lkdGggLyAyKTtcbiAgICAgIHRpZVN0YXJ0WCArPSAoKC10aGlzLndpZHRoIC8gMikgKyB0aGlzLndpZHRoICsgMik7XG5cbiAgICAgIHJldHVybiB0aWVTdGFydFg7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgYHhgIGNvb3JkaW5hdGUgdG8gdGhlIGxlZnQgb2YgdGhlIG5vdGVcbiAgICBnZXRUaWVMZWZ0WDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGllRW5kWCA9IHRoaXMuZ2V0QWJzb2x1dGVYKCk7XG4gICAgICB2YXIgbm90ZV9nbHlwaF93aWR0aCA9IHRoaXMuZ2x5cGguaGVhZF93aWR0aDtcbiAgICAgIHRpZUVuZFggKz0gKG5vdGVfZ2x5cGhfd2lkdGggLyAyKTtcbiAgICAgIHRpZUVuZFggLT0gKCh0aGlzLndpZHRoIC8gMikgKyAyKTtcblxuICAgICAgcmV0dXJuIHRpZUVuZFg7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgZGVmYXVsdCBgeGAgYW5kIGB5YCBjb29yZGluYXRlcyBmb3IgYSBtb2RpZmllciBhdCBhIHNwZWNpZmljXG4gICAgLy8gYHBvc2l0aW9uYCBhdCBhIGZyZXQgcG9zaXRpb24gYGluZGV4YFxuICAgIGdldE1vZGlmaWVyU3RhcnRYWTogZnVuY3Rpb24ocG9zaXRpb24sIGluZGV4KSB7XG4gICAgICBpZiAoIXRoaXMucHJlRm9ybWF0dGVkKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJVbmZvcm1hdHRlZE5vdGVcIixcbiAgICAgICAgICBcIkNhbid0IGNhbGwgR2V0TW9kaWZpZXJTdGFydFhZIG9uIGFuIHVuZm9ybWF0dGVkIG5vdGVcIik7XG5cbiAgICAgIGlmICh0aGlzLnlzLmxlbmd0aCA9PT0gMCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9ZVmFsdWVzXCIsXG4gICAgICAgICAgXCJObyBZLVZhbHVlcyBjYWxjdWxhdGVkIGZvciB0aGlzIG5vdGUuXCIpO1xuXG4gICAgICB2YXIgeCA9IDA7XG4gICAgICBpZiAocG9zaXRpb24gPT0gVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uTEVGVCkge1xuICAgICAgICB4ID0gLTEgKiAyOyAgLy8gZXh0cmFfbGVmdF9weFxuICAgICAgfSBlbHNlIGlmIChwb3NpdGlvbiA9PSBWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5SSUdIVCkge1xuICAgICAgICB4ID0gdGhpcy53aWR0aCArIDI7IC8vIGV4dHJhX3JpZ2h0X3B4XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uID09IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLkJFTE9XIHx8XG4gICAgICAgICAgICAgICAgIHBvc2l0aW9uID09IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFKSB7XG4gICAgICAgICAgdmFyIG5vdGVfZ2x5cGhfd2lkdGggPSB0aGlzLmdseXBoLmhlYWRfd2lkdGg7XG4gICAgICAgICAgeCA9IG5vdGVfZ2x5cGhfd2lkdGggLyAyO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4ge3g6IHRoaXMuZ2V0QWJzb2x1dGVYKCkgKyB4LCB5OiB0aGlzLnlzW2luZGV4XX07XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgZGVmYXVsdCBsaW5lIGZvciByZXN0XG4gICAgZ2V0TGluZUZvclJlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5wb3NpdGlvbnNbMF0uc3RyOyB9LFxuXG4gICAgLy8gUHJlLXJlbmRlciBmb3JtYXR0aW5nXG4gICAgcHJlRm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnByZUZvcm1hdHRlZCkgcmV0dXJuO1xuICAgICAgaWYgKHRoaXMubW9kaWZpZXJDb250ZXh0KSB0aGlzLm1vZGlmaWVyQ29udGV4dC5wcmVGb3JtYXQoKTtcbiAgICAgIC8vIHdpZHRoIGlzIGFscmVhZHkgc2V0IGR1cmluZyBpbml0KClcbiAgICAgIHRoaXMuc2V0UHJlRm9ybWF0dGVkKHRydWUpO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHggcG9zaXRpb24gZm9yIHRoZSBzdGVtXG4gICAgZ2V0U3RlbVg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5nZXRDZW50ZXJHbHlwaFgoKTsgfSxcblxuICAgIC8vIEdldCB0aGUgeSBwb3NpdGlvbiBmb3IgdGhlIHN0ZW1cbiAgICBnZXRTdGVtWTogZnVuY3Rpb24oKXtcbiAgICAgIHZhciBudW1fbGluZXMgPSB0aGlzLnN0YXZlLmdldE51bUxpbmVzKCk7XG5cbiAgICAgIC8vIFRoZSBkZWNpbWFsIHN0YWZmIGxpbmUgYW1vdW50cyBwcm92aWRlIG9wdGltYWwgc3BhY2luZyBiZXR3ZWVuIHRoZVxuICAgICAgLy8gZnJldCBudW1iZXIgYW5kIHRoZSBzdGVtXG4gICAgICB2YXIgc3RlbVVwTGluZSA9IC0wLjU7XG4gICAgICB2YXIgc3RlbURvd25MaW5lID0gbnVtX2xpbmVzIC0gMC41O1xuICAgICAgdmFyIHN0ZW1TdGFydExpbmUgPSBTdGVtLlVQID09PSB0aGlzLnN0ZW1fZGlyZWN0aW9uID8gc3RlbVVwTGluZSA6IHN0ZW1Eb3duTGluZTtcblxuICAgICAgcmV0dXJuIHRoaXMuc3RhdmUuZ2V0WUZvckxpbmUoc3RlbVN0YXJ0TGluZSk7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgc3RlbSBleHRlbnRzIGZvciB0aGUgdGFibm90ZVxuICAgIGdldFN0ZW1FeHRlbnRzOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdGVtX2Jhc2VfeSA9IHRoaXMuZ2V0U3RlbVkoKTtcbiAgICAgIHZhciBzdGVtX3RvcF95ID0gc3RlbV9iYXNlX3kgKyAoU3RlbS5IRUlHSFQgKiAtdGhpcy5zdGVtX2RpcmVjdGlvbik7XG5cbiAgICAgIHJldHVybiB7IHRvcFk6IHN0ZW1fdG9wX3kgLCBiYXNlWTogc3RlbV9iYXNlX3l9O1xuICAgIH0sXG5cbiAgICAvLyBEcmF3IHRoZSBmYWwgb250byB0aGUgY29udGV4dFxuICAgIGRyYXdGbGFnOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciByZW5kZXJfc3RlbSA9IHRoaXMuYmVhbSA9PSBudWxsICYmIHRoaXMucmVuZGVyX29wdGlvbnMuZHJhd19zdGVtO1xuICAgICAgdmFyIHJlbmRlcl9mbGFnID0gdGhpcy5iZWFtID09IG51bGwgJiYgcmVuZGVyX3N0ZW07XG5cbiAgICAgIC8vIE5vdyBpdCdzIHRoZSBmbGFnJ3MgdHVybi5cbiAgICAgIGlmICh0aGlzLmdseXBoLmZsYWcgJiYgcmVuZGVyX2ZsYWcpIHtcbiAgICAgICAgdmFyIGZsYWdfeCA9IHRoaXMuZ2V0U3RlbVgoKSArIDEgO1xuICAgICAgICB2YXIgZmxhZ195ID0gdGhpcy5nZXRTdGVtWSgpIC0gKHRoaXMuc3RlbS5nZXRIZWlnaHQoKSk7XG4gICAgICAgIHZhciBmbGFnX2NvZGU7XG5cbiAgICAgICAgaWYgKHRoaXMuc3RlbV9kaXJlY3Rpb24gPT0gU3RlbS5ET1dOKSB7XG4gICAgICAgICAgLy8gRG93biBzdGVtcyBoYXZlIGZsYWdzIG9uIHRoZSBsZWZ0LlxuICAgICAgICAgIGZsYWdfY29kZSA9IHRoaXMuZ2x5cGguY29kZV9mbGFnX2Rvd25zdGVtO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIFVwIHN0ZW1zIGhhdmUgZmxhZ3Mgb24gdGhlIGxlZnQuXG4gICAgICAgICAgZmxhZ19jb2RlID0gdGhpcy5nbHlwaC5jb2RlX2ZsYWdfdXBzdGVtO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRHJhdyB0aGUgRmxhZ1xuICAgICAgICBWZXguRmxvdy5yZW5kZXJHbHlwaCh0aGlzLmNvbnRleHQsIGZsYWdfeCwgZmxhZ195LFxuICAgICAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5nbHlwaF9mb250X3NjYWxlLCBmbGFnX2NvZGUpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBSZW5kZXIgdGhlIG1vZGlmaWVycyBvbnRvIHRoZSBjb250ZXh0XG4gICAgZHJhd01vZGlmaWVyczogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBEcmF3IHRoZSBtb2RpZmllcnNcbiAgICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24obW9kaWZpZXIpIHtcbiAgICAgICAgLy8gT25seSBkcmF3IHRoZSBkb3RzIGlmIGVuYWJsZWRcbiAgICAgICAgaWYgKG1vZGlmaWVyLmdldENhdGVnb3J5KCkgPT09ICdkb3RzJyAmJiAhdGhpcy5yZW5kZXJfb3B0aW9ucy5kcmF3X2RvdHMpIHJldHVybjtcblxuICAgICAgICBtb2RpZmllci5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIG1vZGlmaWVyLmRyYXcoKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH0sXG5cbiAgICAvLyBSZW5kZXIgdGhlIHN0ZW0gZXh0ZW5zaW9uIHRocm91Z2ggdGhlIGZyZXQgcG9zaXRpb25zXG4gICAgZHJhd1N0ZW1UaHJvdWdoOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBzdGVtX3ggPSB0aGlzLmdldFN0ZW1YKCk7XG4gICAgICB2YXIgc3RlbV95ID0gdGhpcy5nZXRTdGVtWSgpO1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcblxuICAgICAgdmFyIHN0ZW1fdGhyb3VnaCA9IHRoaXMucmVuZGVyX29wdGlvbnMuZHJhd19zdGVtX3Rocm91Z2hfc3RhdmU7XG4gICAgICB2YXIgZHJhd19zdGVtID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5kcmF3X3N0ZW07XG4gICAgICBpZiAoZHJhd19zdGVtICYmIHN0ZW1fdGhyb3VnaCkge1xuICAgICAgICB2YXIgdG90YWxfbGluZXMgPSB0aGlzLnN0YXZlLmdldE51bUxpbmVzKCk7XG4gICAgICAgIHZhciBzdHJpbmdzX3VzZWQgPSB0aGlzLnBvc2l0aW9ucy5tYXAoZnVuY3Rpb24ocG9zaXRpb24pIHtcbiAgICAgICAgICByZXR1cm4gcG9zaXRpb24uc3RyO1xuICAgICAgICB9KTtcblxuICAgICAgICB2YXIgdW51c2VkX3N0cmluZ3MgPSBnZXRVbnVzZWRTdHJpbmdHcm91cHModG90YWxfbGluZXMsIHN0cmluZ3NfdXNlZCk7XG4gICAgICAgIHZhciBzdGVtX2xpbmVzID0gZ2V0UGFydGlhbFN0ZW1MaW5lcyhzdGVtX3ksIHVudXNlZF9zdHJpbmdzLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5nZXRTdGF2ZSgpLCB0aGlzLmdldFN0ZW1EaXJlY3Rpb24oKSk7XG5cbiAgICAgICAgLy8gRmluZSB0dW5lIHggcG9zaXRpb24gdG8gbWF0Y2ggZGVmYXVsdCBzdGVtXG4gICAgICAgIGlmICghdGhpcy5iZWFtIHx8IHRoaXMuZ2V0U3RlbURpcmVjdGlvbigpID09PSAxKSB7XG4gICAgICAgICAgc3RlbV94ICs9IChTdGVtLldJRFRIIC8gMik7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc2V0TGluZVdpZHRoKFN0ZW0uV0lEVEgpO1xuICAgICAgICBzdGVtX2xpbmVzLmZvckVhY2goZnVuY3Rpb24oYm91bmRzKSB7XG4gICAgICAgICAgaWYgKGJvdW5kcy5sZW5ndGggPT09IDApIHJldHVybjtcblxuICAgICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgICBjdHgubW92ZVRvKHN0ZW1feCwgYm91bmRzWzBdKTtcbiAgICAgICAgICBjdHgubGluZVRvKHN0ZW1feCwgYm91bmRzW2JvdW5kcy5sZW5ndGggLSAxXSk7XG4gICAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFJlbmRlciB0aGUgZnJldCBwb3NpdGlvbnMgb250byB0aGUgY29udGV4dFxuICAgIGRyYXdQb3NpdGlvbnM6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciB4ID0gdGhpcy5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgIHZhciB5cyA9IHRoaXMueXM7XG4gICAgICB2YXIgeTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLnBvc2l0aW9ucy5sZW5ndGg7ICsraSkge1xuICAgICAgICB5ID0geXNbaV07XG5cbiAgICAgICAgdmFyIGdseXBoID0gdGhpcy5nbHlwaHNbaV07XG5cbiAgICAgICAgLy8gQ2VudGVyIHRoZSBmcmV0IHRleHQgYmVuZWF0aCB0aGUgbm90YXRpb24gbm90ZSBoZWFkXG4gICAgICAgIHZhciBub3RlX2dseXBoX3dpZHRoID0gdGhpcy5nbHlwaC5oZWFkX3dpZHRoO1xuICAgICAgICB2YXIgdGFiX3ggPSB4ICsgKG5vdGVfZ2x5cGhfd2lkdGggLyAyKSAtIChnbHlwaC53aWR0aCAvIDIpO1xuXG4gICAgICAgIGN0eC5jbGVhclJlY3QodGFiX3ggLSAyLCB5IC0gMywgZ2x5cGgud2lkdGggKyA0LCA2KTtcblxuICAgICAgICBpZiAoZ2x5cGguY29kZSkge1xuICAgICAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKGN0eCwgdGFiX3gsIHkgKyA1ICsgZ2x5cGguc2hpZnRfeSxcbiAgICAgICAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5nbHlwaF9mb250X3NjYWxlLCBnbHlwaC5jb2RlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdGV4dCA9IGdseXBoLnRleHQudG9TdHJpbmcoKTtcbiAgICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgdGFiX3gsIHkgKyA1KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBUaGUgbWFpbiByZW5kZXJpbmcgZnVuY3Rpb24gZm9yIHRoZSBlbnRpcmUgbm90ZVxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ2FudmFzQ29udGV4dFwiLFxuICAgICAgICAgIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgY2FudmFzIGNvbnRleHQuXCIpO1xuICAgICAgaWYgKCF0aGlzLnN0YXZlKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1N0YXZlXCIsIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgc3RhdmUuXCIpO1xuICAgICAgaWYgKHRoaXMueXMubGVuZ3RoID09PSAwKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1lWYWx1ZXNcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgbm90ZSB3aXRob3V0IFkgdmFsdWVzLlwiKTtcblxuICAgICAgdmFyIHJlbmRlcl9zdGVtID0gdGhpcy5iZWFtID09IG51bGwgJiYgdGhpcy5yZW5kZXJfb3B0aW9ucy5kcmF3X3N0ZW07XG5cbiAgICAgIHRoaXMuZHJhd1Bvc2l0aW9ucygpO1xuICAgICAgdGhpcy5kcmF3U3RlbVRocm91Z2goKTtcblxuICAgICAgdmFyIHN0ZW1feCA9IHRoaXMuZ2V0U3RlbVgoKTtcbiAgICAgIHZhciBzdGVtX3kgPSB0aGlzLmdldFN0ZW1ZKCk7XG4gICAgICBpZiAocmVuZGVyX3N0ZW0pIHtcbiAgICAgICAgdGhpcy5kcmF3U3RlbSh7XG4gICAgICAgICAgeF9iZWdpbjogc3RlbV94LFxuICAgICAgICAgIHhfZW5kOiBzdGVtX3gsXG4gICAgICAgICAgeV90b3A6IHN0ZW1feSxcbiAgICAgICAgICB5X2JvdHRvbTogc3RlbV95LFxuICAgICAgICAgIHlfZXh0ZW5kOiAwLFxuICAgICAgICAgIHN0ZW1fZXh0ZW5zaW9uOiB0aGlzLmdldFN0ZW1FeHRlbnNpb24oKSxcbiAgICAgICAgICBzdGVtX2RpcmVjdGlvbjogdGhpcy5zdGVtX2RpcmVjdGlvblxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kcmF3RmxhZygpO1xuICAgICAgdGhpcy5kcmF3TW9kaWZpZXJzKCk7XG4gICAgfVxuICB9KTtcblxuICAvLyAjIyBQcml2YXRlIEhlbHBlcnNcbiAgLy9cbiAgLy8gR2V0cyB0aGUgdW51c2VkIHN0cmluZ3MgZ3JvdXBlZCB0b2dldGhlciBpZiBjb25zZWN1dGl2ZS5cbiAgLy9cbiAgLy8gUGFyYW1ldGVyczpcbiAgLy8gKiBudW1fbGluZXMgLSBUaGUgbnVtYmVyIG9mIGxpbmVzXG4gIC8vICogc3RyaW5nc191c2VkIC0gQW4gYXJyYXkgb2YgbnVtYmVycyByZXByZXNlbnRpbmcgd2hpY2ggc3RyaW5ncyBoYXZlIGZyZXQgcG9zaXRpb25zXG4gIGZ1bmN0aW9uIGdldFVudXNlZFN0cmluZ0dyb3VwcyhudW1fbGluZXMsIHN0cmluZ3NfdXNlZCkge1xuICAgIHZhciBzdGVtX3Rocm91Z2ggPSBbXTtcbiAgICB2YXIgZ3JvdXAgPSBbXTtcbiAgICBmb3IgKHZhciBzdHJpbmcgPSAxOyBzdHJpbmcgPD0gbnVtX2xpbmVzIDsgc3RyaW5nKyspIHtcbiAgICAgIHZhciBpc191c2VkID0gc3RyaW5nc191c2VkLmluZGV4T2Yoc3RyaW5nKSA+IC0xO1xuXG4gICAgICBpZiAoIWlzX3VzZWQpIHtcbiAgICAgICAgZ3JvdXAucHVzaChzdHJpbmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc3RlbV90aHJvdWdoLnB1c2goZ3JvdXApO1xuICAgICAgICBncm91cCA9IFtdO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoZ3JvdXAubGVuZ3RoID4gMCkgc3RlbV90aHJvdWdoLnB1c2goZ3JvdXApO1xuXG4gICAgcmV0dXJuIHN0ZW1fdGhyb3VnaDtcbiAgfVxuXG4gIC8vIEdldHMgZ3JvdXBzIG9mIHBvaW50cyB0aGF0IG91dGxpbmUgdGhlIHBhcnRpYWwgc3RlbSBsaW5lc1xuICAvLyBiZXR3ZWVuIGZyZXQgcG9zaXRpb25zXG4gIC8vXG4gIC8vIFBhcmFtZXRlcnM6XG4gIC8vICogc3RlbV9ZIC0gVGhlIGB5YCBjb29yZGluYXRlIHRoZSBzdGVtIGlzIGxvY2F0ZWQgb25cbiAgLy8gKiB1bnVzZWRfc3RyaW5ncyAtIEFuIGFycmF5IG9mIGdyb3VwcyBvZiB1bnVzZWQgc3RyaW5nc1xuICAvLyAqIHN0YXZlIC0gVGhlIHN0YXZlIHRvIHVzZSBmb3IgcmVmZXJlbmNlXG4gIC8vICogc3RlbV9kaXJlY3Rpb24gLSBUaGUgZGlyZWN0aW9uIG9mIHRoZSBzdGVtXG4gIGZ1bmN0aW9uIGdldFBhcnRpYWxTdGVtTGluZXMgKHN0ZW1feSwgdW51c2VkX3N0cmluZ3MsIHN0YXZlLCBzdGVtX2RpcmVjdGlvbikge1xuICAgIHZhciB1cF9zdGVtID0gc3RlbV9kaXJlY3Rpb24gIT09IDE7XG4gICAgdmFyIGRvd25fc3RlbSA9IHN0ZW1fZGlyZWN0aW9uICE9PSAtMTtcblxuICAgIHZhciBsaW5lX3NwYWNpbmcgPSBzdGF2ZS5nZXRTcGFjaW5nQmV0d2VlbkxpbmVzKCk7XG4gICAgdmFyIHRvdGFsX2xpbmVzID0gc3RhdmUuZ2V0TnVtTGluZXMoKTtcblxuICAgIHZhciBzdGVtX2xpbmVzID0gW107XG5cbiAgICB1bnVzZWRfc3RyaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKHN0cmluZ3MpIHtcbiAgICAgIHZhciBjb250YWluc0xhc3RTdHJpbmcgPSBzdHJpbmdzLmluZGV4T2YodG90YWxfbGluZXMpID4gLTE7XG4gICAgICB2YXIgY29udGFpbnNGaXJzdFN0cmluZyA9ICBzdHJpbmdzLmluZGV4T2YoMSkgPiAtMTtcblxuICAgICAgaWYgKCh1cF9zdGVtICYmIGNvbnRhaW5zRmlyc3RTdHJpbmcpIHx8XG4gICAgICAgICAoZG93bl9zdGVtICYmIGNvbnRhaW5zTGFzdFN0cmluZykpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIG9ubHkgb25lIHN0cmluZyBpbiB0aGUgZ3JvdXAsIHB1c2ggYSBkdXBsaWNhdGUgdmFsdWUuXG4gICAgICAvLyBXZSBkbyB0aGlzIGJlY2F1c2Ugd2UgbmVlZCAyIHN0cmluZ3MgdG8gY29udmVydCBpbnRvIHVwcGVyL2xvd2VyIHlcbiAgICAgIC8vIHZhbHVlcy5cbiAgICAgIGlmIChzdHJpbmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICBzdHJpbmdzLnB1c2goc3RyaW5nc1swXSk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsaW5lX3lzID0gW107XG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBncm91cCBzdHJpbmcgYW5kIHN0b3JlIGl0J3MgeSBwb3NpdGlvblxuICAgICAgc3RyaW5ncy5mb3JFYWNoKGZ1bmN0aW9uKHN0cmluZywgaW5kZXgsIHN0cmluZ3MpIHtcbiAgICAgICAgdmFyIGlzVG9wQm91bmQgPSBzdHJpbmcgPT09IDE7XG4gICAgICAgIHZhciBpc0JvdHRvbUJvdW5kID0gc3RyaW5nID09PSB0b3RhbF9saW5lcztcblxuICAgICAgICAvLyBHZXQgdGhlIHkgdmFsdWUgZm9yIHRoZSBhcHByb3ByaWF0ZSBzdGFmZiBsaW5lLFxuICAgICAgICAvLyB3ZSBhZGp1c3QgZm9yIGEgMCBpbmRleCBhcnJheSwgc2luY2Ugc3RyaW5nIG51bWJlcnMgYXJlIGluZGV4IDFcbiAgICAgICAgdmFyIHkgPSBzdGF2ZS5nZXRZRm9yTGluZShzdHJpbmcgLSAxKTtcblxuICAgICAgICAvLyBVbmxlc3MgdGhlIHN0cmluZyBpcyB0aGUgZmlyc3Qgb3IgbGFzdCwgYWRkIHBhZGRpbmcgdG8gZWFjaCBzaWRlXG4gICAgICAgIC8vIG9mIHRoZSBsaW5lXG4gICAgICAgIGlmIChpbmRleCA9PT0gMCAmJiAhaXNUb3BCb3VuZCkge1xuICAgICAgICAgIHkgLT0gbGluZV9zcGFjaW5nLzIgLSAxO1xuICAgICAgICB9IGVsc2UgaWYgKGluZGV4ID09PSBzdHJpbmdzLmxlbmd0aCAtIDEgJiYgIWlzQm90dG9tQm91bmQpe1xuICAgICAgICAgIHkgKz0gbGluZV9zcGFjaW5nLzIgLSAxO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIHkgdmFsdWVcbiAgICAgICAgbGluZV95cy5wdXNoKHkpO1xuXG4gICAgICAgIC8vIFN0b3JlIGEgc3Vic2VxdWVudCB5IHZhbHVlIGNvbm5lY3RpbmcgdGhpcyBncm91cCB0byB0aGUgbWFpblxuICAgICAgICAvLyBzdGVtIGFib3ZlL2JlbG93IHRoZSBzdGF2ZSBpZiBpdCdzIHRoZSB0b3AvYm90dG9tIHN0cmluZ1xuICAgICAgICBpZiAoc3RlbV9kaXJlY3Rpb24gPT09IDEgJiYgaXNUb3BCb3VuZCkge1xuICAgICAgICAgIGxpbmVfeXMucHVzaChzdGVtX3kgLSAyKTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGVtX2RpcmVjdGlvbiA9PT0gLTEgJiYgaXNCb3R0b21Cb3VuZCkge1xuICAgICAgICAgIGxpbmVfeXMucHVzaChzdGVtX3kgKyAyKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIC8vIEFkZCB0aGUgc29ydGVkIHkgdmFsdWVzIHRvIHRoZVxuICAgICAgc3RlbV9saW5lcy5wdXNoKGxpbmVfeXMuc29ydChmdW5jdGlvbihhLCBiKSB7XG4gICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgIH0pKTtcbiAgICB9KTtcblxuICAgIHJldHVybiBzdGVtX2xpbmVzO1xuICB9XG5cbiAgcmV0dXJuIFRhYk5vdGU7XG59KCkpO1xuXG4vLyBWZXggRmxvdyBOb3RhdGlvblxuLy8gTW9oaXQgTXV0aGFubmEgPG1vaGl0QG11dGhhbm5hLmNvbT5cbi8vXG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFJlcXVpcmVzIHZleC5qcy5cblxuLyoqIEBjb25zdHJ1Y3RvciAqL1xuVmV4LkZsb3cuR2hvc3ROb3RlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBHaG9zdE5vdGUoZHVyYXRpb24pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChkdXJhdGlvbik7XG4gIH1cblxuICBWZXguSW5oZXJpdChHaG9zdE5vdGUsIFZleC5GbG93LlN0ZW1tYWJsZU5vdGUsIHtcbiAgICBpbml0OiBmdW5jdGlvbihwYXJhbWV0ZXIpIHtcbiAgICAgIC8vIFNhbml0eSBjaGVja1xuICAgICAgaWYgKCFwYXJhbWV0ZXIpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgIFwiR2hvc3Qgbm90ZSBtdXN0IGhhdmUgdmFsaWQgaW5pdGlhbGl6YXRpb24gZGF0YSB0byBpZGVudGlmeSBcIiArXG4gICAgICAgICAgICBcImR1cmF0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIG5vdGVfc3RydWN0O1xuXG4gICAgICAvLyBQcmVzZXJ2ZSBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eVxuICAgICAgaWYgKHR5cGVvZihwYXJhbWV0ZXIpID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgIG5vdGVfc3RydWN0ID0geyBkdXJhdGlvbjogcGFyYW1ldGVyIH07XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZihwYXJhbWV0ZXIpID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgIG5vdGVfc3RydWN0ID0gcGFyYW1ldGVyO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgIFwiR2hvc3Qgbm90ZSBtdXN0IGhhdmUgdmFsaWQgaW5pdGlhbGl6YXRpb24gZGF0YSB0byBpZGVudGlmeSBcIiArXG4gICAgICAgICAgICBcImR1cmF0aW9uLlwiKTtcbiAgICAgIH1cblxuICAgICAgR2hvc3ROb3RlLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIG5vdGVfc3RydWN0KTtcblxuICAgICAgLy8gTm90ZSBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLnNldFdpZHRoKDApO1xuICAgIH0sXG5cbiAgICBpc1Jlc3Q6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSxcblxuICAgIHNldFN0YXZlOiBmdW5jdGlvbihzdGF2ZSkgeyBHaG9zdE5vdGUuc3VwZXJjbGFzcy5zZXRTdGF2ZS5jYWxsKHRoaXMsIHN0YXZlKTsgfSxcblxuICAgIGFkZFRvTW9kaWZpZXJDb250ZXh0OiBmdW5jdGlvbigpXG4gICAgICB7IC8qIGludGVudGlvbmFsbHkgb3ZlcnJpZGRlbiAqLyByZXR1cm4gdGhpczsgfSxcblxuICAgIHByZUZvcm1hdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnNldFByZUZvcm1hdHRlZCh0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5zdGF2ZSkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9TdGF2ZVwiLCBcIkNhbid0IGRyYXcgd2l0aG91dCBhIHN0YXZlLlwiKTtcblxuICAgICAgLy8gRHJhdyB0aGUgbW9kaWZpZXJzXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubW9kaWZpZXJzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBtb2RpZmllciA9IHRoaXMubW9kaWZpZXJzW2ldO1xuICAgICAgICBtb2RpZmllci5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICAgIG1vZGlmaWVyLmRyYXcoKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBHaG9zdE5vdGU7XG59KCkpO1xuXG4vLyBWZXggRmxvdyBOb3RhdGlvblxuLy8gQ29weXJpZ2h0IE1vaGl0IE11dGhhbm5hIDIwMTBcbi8vXG4vLyBBdXRob3IgVGFlaG9vbiBNb29uIDIwMTRcblxuLyoqIEBjb25zdHJ1Y3RvciAqL1xuVmV4LkZsb3cuQ2xlZk5vdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIENsZWZOb3RlKGNsZWYsIHNpemUsIGFubm90YXRpb24pIHsgdGhpcy5pbml0KGNsZWYsIHNpemUsIGFubm90YXRpb24pOyB9XG5cbiAgVmV4LkluaGVyaXQoQ2xlZk5vdGUsIFZleC5GbG93Lk5vdGUsIHtcbiAgICBpbml0OiBmdW5jdGlvbihjbGVmLCBzaXplLCBhbm5vdGF0aW9uKSB7XG4gICAgICBDbGVmTm90ZS5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCB7ZHVyYXRpb246IFwiYlwifSk7XG4gICAgICBcbiAgICAgIHRoaXMuc2V0Q2xlZihjbGVmLCBzaXplLCBhbm5vdGF0aW9uKTtcblxuICAgICAgLy8gTm90ZSBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLmlnbm9yZV90aWNrcyA9IHRydWU7XG4gICAgfSxcblxuICAgIHNldENsZWY6IGZ1bmN0aW9uKGNsZWYsIHNpemUsIGFubm90YXRpb24pIHtcbiAgICAgIHRoaXMuY2xlZl9vYmogPSBuZXcgVmV4LkZsb3cuQ2xlZihjbGVmLCBzaXplLCBhbm5vdGF0aW9uKTtcbiAgICAgIHRoaXMuY2xlZiA9IHRoaXMuY2xlZl9vYmouY2xlZjtcbiAgICAgIHRoaXMuZ2x5cGggPSBuZXcgVmV4LkZsb3cuR2x5cGgodGhpcy5jbGVmLmNvZGUsIHRoaXMuY2xlZi5wb2ludCk7XG4gICAgICB0aGlzLnNldFdpZHRoKHRoaXMuZ2x5cGguZ2V0TWV0cmljcygpLndpZHRoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRDbGVmOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmNsZWY7XG4gICAgfSxcblxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpe1xuICAgICAgdGhpcy5jb250ZXh0ID0gY29udGV4dDtcbiAgICAgIHRoaXMuZ2x5cGguc2V0Q29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFN0YXZlOiBmdW5jdGlvbihzdGF2ZSkge1xuICAgICAgdmFyIHN1cGVyY2xhc3MgPSBWZXguRmxvdy5DbGVmTm90ZS5zdXBlcmNsYXNzO1xuICAgICAgc3VwZXJjbGFzcy5zZXRTdGF2ZS5jYWxsKHRoaXMsIHN0YXZlKTtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBWZXguRmxvdy5Cb3VuZGluZ0JveCgwLCAwLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgYWRkVG9Nb2RpZmllckNvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLyogb3ZlcnJpZGRlbiB0byBpZ25vcmUgKi9cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRDYXRlZ29yeTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gXCJjbGVmbm90ZVwiO1xuICAgIH0sXG5cbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRQcmVGb3JtYXR0ZWQodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuc3RhdmUpIHRocm93IG5ldyBWZXguUkVSUihcIk5vU3RhdmVcIiwgXCJDYW4ndCBkcmF3IHdpdGhvdXQgYSBzdGF2ZS5cIik7XG4gICAgICBcbiAgICAgIGlmICghdGhpcy5nbHlwaC5nZXRDb250ZXh0KCkpIHtcbiAgICAgICAgdGhpcy5nbHlwaC5zZXRDb250ZXh0KHRoaXMuY29udGV4dCk7XG4gICAgICB9XG4gICAgICB2YXIgYWJzX3ggPSB0aGlzLmdldEFic29sdXRlWCgpO1xuXG4gICAgICB0aGlzLmdseXBoLnNldFN0YXZlKHRoaXMuc3RhdmUpO1xuICAgICAgdGhpcy5nbHlwaC5zZXRZU2hpZnQoXG4gICAgICAgIHRoaXMuc3RhdmUuZ2V0WUZvckxpbmUodGhpcy5jbGVmLmxpbmUpIC0gdGhpcy5zdGF2ZS5nZXRZRm9yR2x5cGhzKCkpO1xuICAgICAgdGhpcy5nbHlwaC5yZW5kZXJUb1N0YXZlKGFic194KTtcbiAgICAgIFxuICAgICAgLy8gSWYgdGhlIFZleC5GbG93LkNsZWYgaGFzIGFuIGFubm90YXRpb24sIHN1Y2ggYXMgOHZhLCBkcmF3IGl0LlxuICAgICAgaWYgKHRoaXMuY2xlZl9vYmouYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBhdHRhY2htZW50ID0gbmV3IFZleC5GbG93LkdseXBoKHRoaXMuY2xlZl9vYmouYW5ub3RhdGlvbi5jb2RlLCB0aGlzLmNsZWZfb2JqLmFubm90YXRpb24ucG9pbnQpO1xuICAgICAgICBpZiAoIWF0dGFjaG1lbnQuZ2V0Q29udGV4dCgpKSB7XG4gICAgICAgICAgICBhdHRhY2htZW50LnNldENvbnRleHQodGhpcy5jb250ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBhdHRhY2htZW50LnNldFN0YXZlKHRoaXMuc3RhdmUpO1xuICAgICAgICBhdHRhY2htZW50LnNldFlTaGlmdChcbiAgICAgICAgICB0aGlzLnN0YXZlLmdldFlGb3JMaW5lKHRoaXMuY2xlZl9vYmouYW5ub3RhdGlvbi5saW5lKSAtIHRoaXMuc3RhdmUuZ2V0WUZvckdseXBocygpKTtcbiAgICAgICAgYXR0YWNobWVudC5zZXRYU2hpZnQodGhpcy5jbGVmX29iai5hbm5vdGF0aW9uLnhfc2hpZnQpO1xuICAgICAgICBhdHRhY2htZW50LnJlbmRlclRvU3RhdmUoYWJzX3gpO1xuICAgICAgfVxuICAgICAgXG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQ2xlZk5vdGU7XG59KCkpO1xuXG4vLyBWZXggRmxvdyBOb3RhdGlvblxuLy8gQ29weXJpZ2h0IE1vaGl0IE11dGhhbm5hIDIwMTBcbi8vXG4vLyBBdXRob3IgVGFlaG9vbiBNb29uIDIwMTRcblxuLyoqIEBjb25zdHJ1Y3RvciAqL1xuVmV4LkZsb3cuVGltZVNpZ05vdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRpbWVTaWdOb3RlKHRpbWVTcGVjLCBjdXN0b21QYWRkaW5nKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGltZVNwZWMsIGN1c3RvbVBhZGRpbmcpO1xuICB9XG5cbiAgVmV4LkluaGVyaXQoVGltZVNpZ05vdGUsIFZleC5GbG93Lk5vdGUsIHtcbiAgICBpbml0OiBmdW5jdGlvbih0aW1lU3BlYywgY3VzdG9tUGFkZGluZykge1xuICAgICAgVGltZVNpZ05vdGUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywge2R1cmF0aW9uOiBcImJcIn0pO1xuXG4gICAgICB2YXIgdGltZVNpZ25hdHVyZSA9IG5ldyBWZXguRmxvdy5UaW1lU2lnbmF0dXJlKHRpbWVTcGVjLCBjdXN0b21QYWRkaW5nKTtcbiAgICAgIHRoaXMudGltZVNpZyA9IHRpbWVTaWduYXR1cmUuZ2V0VGltZVNpZygpO1xuICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLnRpbWVTaWcuZ2x5cGguZ2V0TWV0cmljcygpLndpZHRoKTtcblxuICAgICAgLy8gTm90ZSBwcm9wZXJ0aWVzXG4gICAgICB0aGlzLmlnbm9yZV90aWNrcyA9IHRydWU7XG4gICAgfSxcblxuICAgIHNldFN0YXZlOiBmdW5jdGlvbihzdGF2ZSkge1xuICAgICAgdmFyIHN1cGVyY2xhc3MgPSBWZXguRmxvdy5UaW1lU2lnTm90ZS5zdXBlcmNsYXNzO1xuICAgICAgc3VwZXJjbGFzcy5zZXRTdGF2ZS5jYWxsKHRoaXMsIHN0YXZlKTtcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBWZXguRmxvdy5Cb3VuZGluZ0JveCgwLCAwLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgYWRkVG9Nb2RpZmllckNvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLyogb3ZlcnJpZGRlbiB0byBpZ25vcmUgKi9cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5zZXRQcmVGb3JtYXR0ZWQodHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuc3RhdmUpIHRocm93IG5ldyBWZXguUkVSUihcIk5vU3RhdmVcIiwgXCJDYW4ndCBkcmF3IHdpdGhvdXQgYSBzdGF2ZS5cIik7XG4gICAgICBcbiAgICAgIGlmICghdGhpcy50aW1lU2lnLmdseXBoLmdldENvbnRleHQoKSkge1xuICAgICAgICB0aGlzLnRpbWVTaWcuZ2x5cGguc2V0Q29udGV4dCh0aGlzLmNvbnRleHQpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnRpbWVTaWcuZ2x5cGguc2V0U3RhdmUodGhpcy5zdGF2ZSk7XG4gICAgICB0aGlzLnRpbWVTaWcuZ2x5cGguc2V0WVNoaWZ0KFxuICAgICAgICB0aGlzLnN0YXZlLmdldFlGb3JMaW5lKHRoaXMudGltZVNpZy5saW5lKSAtIHRoaXMuc3RhdmUuZ2V0WUZvckdseXBocygpKTtcbiAgICAgIHRoaXMudGltZVNpZy5nbHlwaC5yZW5kZXJUb1N0YXZlKHRoaXMuZ2V0QWJzb2x1dGVYKCkpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFRpbWVTaWdOb3RlO1xufSgpKTtcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBUaGlzIGZpbGUgaW1wbGVtZW50cyBgQmVhbXNgIHRoYXQgc3BhbiBvdmVyIGEgc2V0IG9mIGBTdGVtbWFibGVOb3Rlc2AuXG4vL1xuLy8gUmVxdWlyZXM6IHZleC5qcywgdmV4bXVzaWMuanMsIG5vdGUuanNcblZleC5GbG93LkJlYW0gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEJlYW0obm90ZXMsIGF1dG9fc3RlbSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG5vdGVzLCBhdXRvX3N0ZW0pO1xuICB9XG5cbiAgdmFyIFN0ZW0gPSBWZXguRmxvdy5TdGVtO1xuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIEJlYW0ucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG5vdGVzLCBhdXRvX3N0ZW0pIHtcbiAgICAgIGlmICghbm90ZXMgfHwgbm90ZXMgPT0gW10pIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIiwgXCJObyBub3RlcyBwcm92aWRlZCBmb3IgYmVhbS5cIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChub3Rlcy5sZW5ndGggPT0gMSkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLCBcIlRvbyBmZXcgbm90ZXMgZm9yIGJlYW0uXCIpO1xuICAgICAgfVxuXG4gICAgICAvLyBWYWxpZGF0ZSBiZWFtIGxpbmUsIGRpcmVjdGlvbiBhbmQgdGlja3MuXG4gICAgICB0aGlzLnRpY2tzID0gbm90ZXNbMF0uZ2V0SW50cmluc2ljVGlja3MoKTtcblxuICAgICAgaWYgKHRoaXMudGlja3MgPj0gVmV4LkZsb3cuZHVyYXRpb25Ub1RpY2tzKFwiNFwiKSkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLFxuICAgICAgICAgICAgXCJCZWFtcyBjYW4gb25seSBiZSBhcHBsaWVkIHRvIG5vdGVzIHNob3J0ZXIgdGhhbiBhIHF1YXJ0ZXIgbm90ZS5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBpOyAvLyBzaGFyZWQgaXRlcmF0b3JcbiAgICAgIHZhciBub3RlO1xuXG4gICAgICB0aGlzLnN0ZW1fZGlyZWN0aW9uID0gU3RlbS5VUDtcblxuICAgICAgZm9yIChpID0gMDsgaSA8IG5vdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG5vdGUgPSBub3Rlc1tpXTtcbiAgICAgICAgaWYgKG5vdGUuaGFzU3RlbSgpKSB7XG4gICAgICAgICAgdGhpcy5zdGVtX2RpcmVjdGlvbiA9IG5vdGUuZ2V0U3RlbURpcmVjdGlvbigpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBzdGVtX2RpcmVjdGlvbiA9IHRoaXMuc3RlbV9kaXJlY3Rpb247XG4gICAgICAvLyBGaWd1cmUgb3V0IG9wdGltYWwgc3RlbSBkaXJlY3Rpb24gYmFzZWQgb24gZ2l2ZW4gbm90ZXNcbiAgICAgIGlmIChhdXRvX3N0ZW0gJiYgbm90ZXNbMF0uZ2V0Q2F0ZWdvcnkoKSA9PT0gJ3N0YXZlbm90ZXMnKSAge1xuICAgICAgICBzdGVtX2RpcmVjdGlvbiA9IGNhbGN1bGF0ZVN0ZW1EaXJlY3Rpb24obm90ZXMpO1xuICAgICAgfSBlbHNlIGlmIChhdXRvX3N0ZW0gJiYgbm90ZXNbMF0uZ2V0Q2F0ZWdvcnkoKSA9PT0gJ3RhYm5vdGVzJykge1xuICAgICAgICAvLyBBdXRvIFN0ZW0gVGFiTm90ZXNcbiAgICAgICAgdmFyIHN0ZW1fd2VpZ2h0ID0gbm90ZXMucmVkdWNlKGZ1bmN0aW9uKG1lbW8sIG5vdGUpIHtcbiAgICAgICAgICByZXR1cm4gbWVtbyArIG5vdGUuc3RlbV9kaXJlY3Rpb247XG4gICAgICAgIH0sIDApO1xuXG4gICAgICAgIHN0ZW1fZGlyZWN0aW9uID0gc3RlbV93ZWlnaHQgPiAtMSA/IFN0ZW0uVVAgOiBTdGVtLkRPV047XG4gICAgICB9XG5cbiAgICAgIC8vIEFwcGx5IHN0ZW0gZGlyZWN0aW9ucyBhbmQgYXR0YWNoIGJlYW0gdG8gbm90ZXNcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBub3Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBub3RlID0gbm90ZXNbaV07XG4gICAgICAgIGlmIChhdXRvX3N0ZW0pIHtcbiAgICAgICAgICBub3RlLnNldFN0ZW1EaXJlY3Rpb24oc3RlbV9kaXJlY3Rpb24pO1xuICAgICAgICAgIHRoaXMuc3RlbV9kaXJlY3Rpb24gPSBzdGVtX2RpcmVjdGlvbjtcbiAgICAgICAgfVxuICAgICAgICBub3RlLnNldEJlYW0odGhpcyk7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucG9zdEZvcm1hdHRlZCA9IGZhbHNlO1xuICAgICAgdGhpcy5ub3RlcyA9IG5vdGVzO1xuICAgICAgdGhpcy5iZWFtX2NvdW50ID0gdGhpcy5nZXRCZWFtQ291bnQoKTtcbiAgICAgIHRoaXMuYnJlYWtfb25faW5kaWNlcyA9IFtdO1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgYmVhbV93aWR0aDogNSxcbiAgICAgICAgbWF4X3Nsb3BlOiAwLjI1LFxuICAgICAgICBtaW5fc2xvcGU6IC0wLjI1LFxuICAgICAgICBzbG9wZV9pdGVyYXRpb25zOiAyMCxcbiAgICAgICAgc2xvcGVfY29zdDogMTAwLFxuICAgICAgICBzaG93X3N0ZW1sZXRzOiBmYWxzZSxcbiAgICAgICAgc3RlbWxldF9leHRlbnNpb246IDcsXG4gICAgICAgIHBhcnRpYWxfYmVhbV9sZW5ndGg6IDEwLFxuICAgICAgICBmbGF0X2JlYW1zOiBmYWxzZSxcbiAgICAgICAgbWluX2ZsYXRfYmVhbV9vZmZzZXQ6IDE1XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBUaGUgdGhlIHJlbmRlcmluZyBgY29udGV4dGBcbiAgICBzZXRDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7IHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gR2V0IHRoZSBub3RlcyBpbiB0aGlzIGJlYW1cbiAgICBnZXROb3RlczogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5vdGVzOyB9LFxuXG4gICAgLy8gR2V0IHRoZSBtYXggbnVtYmVyIG9mIGJlYW1zIGluIHRoZSBzZXQgb2Ygbm90ZXNcbiAgICBnZXRCZWFtQ291bnQ6IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgYmVhbUNvdW50cyA9ICB0aGlzLm5vdGVzLm1hcChmdW5jdGlvbihub3RlKSB7XG4gICAgICAgIHJldHVybiBub3RlLmdldEdseXBoKCkuYmVhbV9jb3VudDtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgbWF4QmVhbUNvdW50ID0gIGJlYW1Db3VudHMucmVkdWNlKGZ1bmN0aW9uKG1heCwgYmVhbUNvdW50KSB7XG4gICAgICAgICAgcmV0dXJuIGJlYW1Db3VudCA+IG1heCA/IGJlYW1Db3VudCA6IG1heDtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gbWF4QmVhbUNvdW50O1xuICAgIH0sXG5cbiAgICAvLyBTZXQgd2hpY2ggbm90ZSBgaW5kaWNlc2AgdG8gYnJlYWsgdGhlIHNlY29uZGFyeSBiZWFtIGF0XG4gICAgYnJlYWtTZWNvbmRhcnlBdDogZnVuY3Rpb24oaW5kaWNlcykge1xuICAgICAgdGhpcy5icmVha19vbl9pbmRpY2VzID0gaW5kaWNlcztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZXR1cm4gdGhlIHkgY29vcmRpbmF0ZSBmb3IgbGluZWFyIGZ1bmN0aW9uXG4gICAgZ2V0U2xvcGVZOiBmdW5jdGlvbih4LCBmaXJzdF94X3B4LCBmaXJzdF95X3B4LCBzbG9wZSkge1xuICAgICAgcmV0dXJuIGZpcnN0X3lfcHggKyAoKHggLSBmaXJzdF94X3B4KSAqIHNsb3BlKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FsY3VsYXRlIHRoZSBiZXN0IHBvc3NpYmxlIHNsb3BlIGZvciB0aGUgcHJvdmlkZWQgbm90ZXNcbiAgICBjYWxjdWxhdGVTbG9wZTogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZmlyc3Rfbm90ZSA9IHRoaXMubm90ZXNbMF07XG4gICAgICB2YXIgZmlyc3RfeV9weCA9IGZpcnN0X25vdGUuZ2V0U3RlbUV4dGVudHMoKS50b3BZO1xuICAgICAgdmFyIGZpcnN0X3hfcHggPSBmaXJzdF9ub3RlLmdldFN0ZW1YKCk7XG5cbiAgICAgIHZhciBpbmMgPSAodGhpcy5yZW5kZXJfb3B0aW9ucy5tYXhfc2xvcGUgLSB0aGlzLnJlbmRlcl9vcHRpb25zLm1pbl9zbG9wZSkgL1xuICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuc2xvcGVfaXRlcmF0aW9ucztcbiAgICAgIHZhciBtaW5fY29zdCA9IE51bWJlci5NQVhfVkFMVUU7XG4gICAgICB2YXIgYmVzdF9zbG9wZSA9IDA7XG4gICAgICB2YXIgeV9zaGlmdCA9IDA7XG5cbiAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBzbG9wZSB2YWx1ZXMgdG8gZmluZCBiZXN0IHdlaWdodGVkIGZpdFxuICAgICAgZm9yICh2YXIgc2xvcGUgPSB0aGlzLnJlbmRlcl9vcHRpb25zLm1pbl9zbG9wZTtcbiAgICAgICAgICAgc2xvcGUgPD0gdGhpcy5yZW5kZXJfb3B0aW9ucy5tYXhfc2xvcGU7XG4gICAgICAgICAgIHNsb3BlICs9IGluYykge1xuICAgICAgICB2YXIgdG90YWxfc3RlbV9leHRlbnNpb24gPSAwO1xuICAgICAgICB2YXIgeV9zaGlmdF90bXAgPSAwO1xuXG4gICAgICAgIC8vIGl0ZXJhdGUgdGhyb3VnaCBub3RlcywgY2FsY3VsYXRpbmcgeSBzaGlmdCBhbmQgc3RlbSBleHRlbnNpb25cbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCB0aGlzLm5vdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIG5vdGUgPSB0aGlzLm5vdGVzW2ldO1xuXG4gICAgICAgICAgdmFyIHhfcHggPSBub3RlLmdldFN0ZW1YKCk7XG4gICAgICAgICAgdmFyIHlfcHggPSBub3RlLmdldFN0ZW1FeHRlbnRzKCkudG9wWTtcbiAgICAgICAgICB2YXIgc2xvcGVfeV9weCA9IHRoaXMuZ2V0U2xvcGVZKHhfcHgsIGZpcnN0X3hfcHgsIGZpcnN0X3lfcHgsIHNsb3BlKSArIHlfc2hpZnRfdG1wO1xuXG4gICAgICAgICAgLy8gYmVhbSBuZWVkcyB0byBiZSBzaGlmdGVkIHVwIHRvIGFjY29tbW9kYXRlIG5vdGVcbiAgICAgICAgICBpZiAoeV9weCAqIHRoaXMuc3RlbV9kaXJlY3Rpb24gPCBzbG9wZV95X3B4ICogdGhpcy5zdGVtX2RpcmVjdGlvbikge1xuICAgICAgICAgICAgdmFyIGRpZmYgPSAgTWF0aC5hYnMoeV9weCAtIHNsb3BlX3lfcHgpO1xuICAgICAgICAgICAgeV9zaGlmdF90bXAgKz0gZGlmZiAqIC10aGlzLnN0ZW1fZGlyZWN0aW9uO1xuICAgICAgICAgICAgdG90YWxfc3RlbV9leHRlbnNpb24gKz0gKGRpZmYgKiBpKTtcbiAgICAgICAgICB9IGVsc2UgeyAvLyBiZWFtIG92ZXJzaG9vdHMgbm90ZSwgYWNjb3VudCBmb3IgdGhlIGRpZmZlcmVuY2VcbiAgICAgICAgICAgIHRvdGFsX3N0ZW1fZXh0ZW5zaW9uICs9ICh5X3B4IC0gc2xvcGVfeV9weCkgKiB0aGlzLnN0ZW1fZGlyZWN0aW9uO1xuICAgICAgICAgIH1cblxuICAgICAgICB9XG5cbiAgICAgICAgdmFyIGxhc3Rfbm90ZSA9IHRoaXMubm90ZXNbdGhpcy5ub3Rlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgdmFyIGZpcnN0X2xhc3Rfc2xvcGUgPSAoKGxhc3Rfbm90ZS5nZXRTdGVtRXh0ZW50cygpLnRvcFkgLSBmaXJzdF95X3B4KSAvXG4gICAgICAgICAgICAgICAgKGxhc3Rfbm90ZS5nZXRTdGVtWCgpIC0gZmlyc3RfeF9weCkpO1xuICAgICAgICAvLyBtb3N0IGVuZ3JhdmluZyBib29rcyBzdWdnZXN0IGFpbWluZyBmb3IgYSBzbG9wZSBhYm91dCBoYWxmIHRoZSBhbmdsZSBvZiB0aGVcbiAgICAgICAgLy8gZGlmZmVyZW5jZSBiZXR3ZWVuIHRoZSBmaXJzdCBhbmQgbGFzdCBub3Rlcycgc3RlbSBsZW5ndGg7XG4gICAgICAgIHZhciBpZGVhbF9zbG9wZSA9IGZpcnN0X2xhc3Rfc2xvcGUgLyAyO1xuICAgICAgICB2YXIgZGlzdGFuY2VfZnJvbV9pZGVhbCA9IE1hdGguYWJzKGlkZWFsX3Nsb3BlIC0gc2xvcGUpO1xuXG4gICAgICAgIC8vIFRoaXMgdHJpZXMgdG8gYWxpZ24gbW9zdCBiZWFtcyB0byBzb21ldGhpbmcgY2xvc2VyIHRvIHRoZSBpZGVhbF9zbG9wZSwgYnV0XG4gICAgICAgIC8vIGRvZXNuJ3QgZ28gY3JhenkuIFRvIGRpc2FibGUsIHNldCB0aGlzLnJlbmRlcl9vcHRpb25zLnNsb3BlX2Nvc3QgPSAwXG4gICAgICAgIHZhciBjb3N0ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5zbG9wZV9jb3N0ICogZGlzdGFuY2VfZnJvbV9pZGVhbCArXG4gICAgICAgICAgICBNYXRoLmFicyh0b3RhbF9zdGVtX2V4dGVuc2lvbik7XG5cbiAgICAgICAgLy8gdXBkYXRlIHN0YXRlIHdoZW4gYSBtb3JlIGlkZWFsIHNsb3BlIGlzIGZvdW5kXG4gICAgICAgIGlmIChjb3N0IDwgbWluX2Nvc3QpIHtcbiAgICAgICAgICBtaW5fY29zdCA9IGNvc3Q7XG4gICAgICAgICAgYmVzdF9zbG9wZSA9IHNsb3BlO1xuICAgICAgICAgIHlfc2hpZnQgPSB5X3NoaWZ0X3RtcDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNsb3BlID0gYmVzdF9zbG9wZTtcbiAgICAgIHRoaXMueV9zaGlmdCA9IHlfc2hpZnQ7XG4gICAgfSxcblxuICAgIC8vIENhbGN1bGF0ZSBhIHNsb3BlIGFuZCB5LXNoaWZ0IGZvciBmbGF0IGJlYW1zXG4gICAgY2FsY3VsYXRlRmxhdFNsb3BlOiBmdW5jdGlvbigpIHtcblxuICAgICAgLy8gSWYgYSBmbGF0IGJlYW0gb2Zmc2V0IGhhcyBub3QgeWV0IGJlZW4gc3VwcGxpZWQgb3IgY2FsY3VsYXRlZCxcbiAgICAgIC8vIGdlbmVyYXRlIG9uZSBiYXNlZCBvbiB0aGUgbm90ZXMgaW4gdGhpcyBwYXJ0aWN1bGFyIG5vdGUgZ3JvdXBcbiAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICB2YXIgZXh0cmVtZV95ID0gMDsgIC8vIFN0b3JlIHRoZSBoaWdoZXN0IG9yIGxvd2VzdCBub3RlIGhlcmVcbiAgICAgIHZhciBleHRyZW1lX2JlYW1fY291bnQgPSAwOyAgLy8gVGhlIGJlYW0gY291bnQgb2YgdGhlIGV4dHJlbWUgbm90ZVxuICAgICAgdmFyIGN1cnJlbnRfZXh0cmVtZSA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubm90ZXMubGVuZ3RoOyBpKyspIHtcblxuICAgICAgICAvLyBUb3RhbCB1cCBhbGwgb2YgdGhlIG9mZnNldHMgc28gd2UgY2FuIGF2ZXJhZ2UgdGhlbSBvdXQgbGF0ZXJcbiAgICAgICAgdmFyIG5vdGUgPSB0aGlzLm5vdGVzW2ldO1xuICAgICAgICB2YXIgdG9wX3kgPSBub3RlLmdldFN0ZW1FeHRlbnRzKCkudG9wWTtcbiAgICAgICAgdG90YWwgKz0gdG9wX3k7XG5cbiAgICAgICAgLy8gU3RvcmUgdGhlIGhpZ2hlc3QgKHN0ZW1zLXVwKSBvciBsb3dlc3QgKHN0ZW1zLWRvd24pIG5vdGUgc28gdGhlXG4gICAgICAgIC8vICBvZmZzZXQgY2FuIGJlIGFkanVzdGVkIGluIGNhc2UgdGhlIGF2ZXJhZ2UgaXNuJ3QgZW5vdWdoXG4gICAgICAgIGlmICh0aGlzLnN0ZW1fZGlyZWN0aW9uID09PSBTdGVtLkRPV04gJiYgY3VycmVudF9leHRyZW1lIDwgdG9wX3kpIHtcbiAgICAgICAgICBjdXJyZW50X2V4dHJlbWUgPSB0b3BfeTtcbiAgICAgICAgICBleHRyZW1lX3kgPSBub3RlLmdldE5vdGVIZWFkQm91bmRzKCkueV9ib3R0b207XG4gICAgICAgICAgZXh0cmVtZV9iZWFtX2NvdW50ID0gbm90ZS5nZXRCZWFtQ291bnQoKTtcbiAgICAgICAgfSBlbHNlIGlmICh0aGlzLnN0ZW1fZGlyZWN0aW9uID09PSBTdGVtLlVQICYmIChjdXJyZW50X2V4dHJlbWUgPT09IDAgfHwgY3VycmVudF9leHRyZW1lID4gdG9wX3kpKSB7XG4gICAgICAgICAgY3VycmVudF9leHRyZW1lID0gdG9wX3k7XG4gICAgICAgICAgZXh0cmVtZV95ID0gbm90ZS5nZXROb3RlSGVhZEJvdW5kcygpLnlfdG9wO1xuICAgICAgICAgIGV4dHJlbWVfYmVhbV9jb3VudCA9IG5vdGUuZ2V0QmVhbUNvdW50KCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQXZlcmFnZSB0aGUgb2Zmc2V0cyB0byB0cnkgYW5kIGNvbWUgdXAgd2l0aCBhIHJlYXNvbmFibGUgb25lIHRoYXRcbiAgICAgIC8vICB3b3JrcyBmb3IgYWxsIG9mIHRoZSBub3RlcyBpbiB0aGUgYmVhbSBncm91cC5cbiAgICAgIHZhciBvZmZzZXQgPSB0b3RhbCAvIHRoaXMubm90ZXMubGVuZ3RoO1xuXG4gICAgICAvLyBJbiBjYXNlIHRoZSBhdmVyYWdlIGlzbid0IGxvbmcgZW5vdWdoLCBhZGQgb3Igc3VidHJhY3Qgc29tZSBtb3JlXG4gICAgICAvLyAgYmFzZWQgb24gdGhlIGhpZ2hlc3Qgb3IgbG93ZXN0IG5vdGUgKGFnYWluLCBiYXNlZCBvbiB0aGUgc3RlbVxuICAgICAgLy8gIGRpcmVjdGlvbikuIFRoaXMgYWxzbyB0YWtlcyBpbnRvIGFjY291bnQgdGhlIGFkZGVkIGhlaWdodCBkdWUgdG9cbiAgICAgIC8vICB0aGUgd2lkdGggb2YgdGhlIGJlYW1zLlxuICAgICAgdmFyIGJlYW1fd2lkdGggPSB0aGlzLnJlbmRlcl9vcHRpb25zLmJlYW1fd2lkdGggKiAxLjU7XG4gICAgICB2YXIgZXh0cmVtZV90ZXN0ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5taW5fZmxhdF9iZWFtX29mZnNldCArIChleHRyZW1lX2JlYW1fY291bnQgKiBiZWFtX3dpZHRoKTtcbiAgICAgIHZhciBuZXdfb2Zmc2V0ID0gZXh0cmVtZV95ICsgKGV4dHJlbWVfdGVzdCAqIC10aGlzLnN0ZW1fZGlyZWN0aW9uKTtcbiAgICAgIGlmICh0aGlzLnN0ZW1fZGlyZWN0aW9uID09PSBTdGVtLkRPV04gJiYgb2Zmc2V0IDwgbmV3X29mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBleHRyZW1lX3kgKyBleHRyZW1lX3Rlc3Q7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3RlbV9kaXJlY3Rpb24gPT09IFN0ZW0uVVAgJiYgb2Zmc2V0ID4gbmV3X29mZnNldCkge1xuICAgICAgICBvZmZzZXQgPSBleHRyZW1lX3kgLSBleHRyZW1lX3Rlc3Q7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtX29mZnNldCkge1xuXG4gICAgICAgIC8vIFNldCB0aGUgb2Zmc2V0IGZvciB0aGUgZ3JvdXAgYmFzZWQgb24gdGhlIGNhbGN1bGF0aW9ucyBhYm92ZS5cbiAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5mbGF0X2JlYW1fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0ZW1fZGlyZWN0aW9uID09PSBTdGVtLkRPV04gJiYgb2Zmc2V0ID4gdGhpcy5yZW5kZXJfb3B0aW9ucy5mbGF0X2JlYW1fb2Zmc2V0KSB7XG4gICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtX29mZnNldCA9IG9mZnNldDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5zdGVtX2RpcmVjdGlvbiA9PT0gU3RlbS5VUCAmJiBvZmZzZXQgPCB0aGlzLnJlbmRlcl9vcHRpb25zLmZsYXRfYmVhbV9vZmZzZXQpIHtcbiAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5mbGF0X2JlYW1fb2Zmc2V0ID0gb2Zmc2V0O1xuICAgICAgfVxuXG4gICAgICAvLyBmb3IgZmxhdCBiZWFtcywgdGhlIHNsb3BlIGFuZCB5X3NoaWZ0IGFyZSBzaW1wbHkgMFxuICAgICAgdGhpcy5zbG9wZSA9IDA7XG4gICAgICB0aGlzLnlfc2hpZnQgPSAwO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgbmV3IHN0ZW1zIGZvciB0aGUgbm90ZXMgaW4gdGhlIGJlYW0sIHNvIHRoYXQgZWFjaCBzdGVtXG4gICAgLy8gZXh0ZW5kcyBpbnRvIHRoZSBiZWFtcy5cbiAgICBhcHBseVN0ZW1FeHRlbnNpb25zOiBmdW5jdGlvbigpe1xuICAgICAgdmFyIGZpcnN0X25vdGUgPSB0aGlzLm5vdGVzWzBdO1xuICAgICAgdmFyIGZpcnN0X3lfcHggPSBmaXJzdF9ub3RlLmdldFN0ZW1FeHRlbnRzKCkudG9wWTtcblxuICAgICAgLy8gSWYgcmVuZGVyaW5nIGZsYXQgYmVhbXMsIGFuZCBhbiBvZmZzZXQgZXhpc3RzLCBzZXQgdGhlIHktY29vcmRpbmF0ZSB0b1xuICAgICAgLy8gIHRoZSBvZmZzZXQgc28gdGhlIHN0ZW1zIGFsbCBlbmQgYXQgdGhlIGJlYW0gb2Zmc2V0LlxuICAgICAgaWYgKHRoaXMucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtcyAmJiB0aGlzLnJlbmRlcl9vcHRpb25zLmZsYXRfYmVhbV9vZmZzZXQpIHtcbiAgICAgICAgZmlyc3RfeV9weCA9IHRoaXMucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtX29mZnNldDtcbiAgICAgIH1cbiAgICAgIHZhciBmaXJzdF94X3B4ID0gZmlyc3Rfbm90ZS5nZXRTdGVtWCgpO1xuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubm90ZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIG5vdGUgPSB0aGlzLm5vdGVzW2ldO1xuXG4gICAgICAgIHZhciB4X3B4ID0gbm90ZS5nZXRTdGVtWCgpO1xuICAgICAgICB2YXIgeV9leHRlbnRzID0gbm90ZS5nZXRTdGVtRXh0ZW50cygpO1xuICAgICAgICB2YXIgYmFzZV95X3B4ID0geV9leHRlbnRzLmJhc2VZO1xuICAgICAgICB2YXIgdG9wX3lfcHggPSB5X2V4dGVudHMudG9wWTtcblxuICAgICAgICAvLyBJZiBmbGF0IGJlYW1zLCBzZXQgdGhlIHRvcCBvZiB0aGUgc3RlbSB0byB0aGUgb2Zmc2V0LCByYXRoZXIgdGhhblxuICAgICAgICAvLyAgcmVseWluZyBvbiB0aGUgdG9wWSB2YWx1ZSBmcm9tIGFib3ZlLlxuICAgICAgICBpZiAodGhpcy5yZW5kZXJfb3B0aW9ucy5mbGF0X2JlYW1zKSB7XG4gICAgICAgICAgdG9wX3lfcHggPSBmaXJzdF95X3B4O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRm9yIGhhcm1vbmljIG5vdGUgaGVhZHMsIHNob3J0ZW4gc3RlbSBsZW5ndGggYnkgMyBwaXhlbHNcbiAgICAgICAgYmFzZV95X3B4ICs9IHRoaXMuc3RlbV9kaXJlY3Rpb24gKiBub3RlLmdseXBoLnN0ZW1fb2Zmc2V0O1xuXG4gICAgICAgIC8vIERvbid0IGdvIGFsbCB0aGUgd2F5IHRvIHRoZSB0b3AgKGZvciB0aGlja2VyIHN0ZW1zKVxuICAgICAgICB2YXIgeV9kaXNwbGFjZW1lbnQgPSBWZXguRmxvdy5TVEVNX1dJRFRIO1xuXG4gICAgICAgIGlmICghbm90ZS5oYXNTdGVtKCkpIHtcbiAgICAgICAgICBpZiAobm90ZS5pc1Jlc3QoKSAmJiB0aGlzLnJlbmRlcl9vcHRpb25zLnNob3dfc3RlbWxldHMpIHtcbiAgICAgICAgICAgIHZhciBjZW50ZXJHbHlwaFggPSBub3RlLmdldENlbnRlckdseXBoWCgpO1xuXG4gICAgICAgICAgICB2YXIgd2lkdGggPSB0aGlzLnJlbmRlcl9vcHRpb25zLmJlYW1fd2lkdGg7XG4gICAgICAgICAgICB2YXIgdG90YWxfd2lkdGggPSAoKHRoaXMuYmVhbV9jb3VudCAtIDEpKiB3aWR0aCAqIDEuNSkgKyB3aWR0aDtcblxuICAgICAgICAgICAgdmFyIHN0ZW1sZXRfaGVpZ2h0ID0gKHRvdGFsX3dpZHRoIC0geV9kaXNwbGFjZW1lbnQgK1xuICAgICAgICAgICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLnN0ZW1sZXRfZXh0ZW5zaW9uKTtcblxuICAgICAgICAgICAgdmFyIGJlYW1feSA9IHRoaXMuZ2V0U2xvcGVZKGNlbnRlckdseXBoWCwgZmlyc3RfeF9weCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF95X3B4LCB0aGlzLnNsb3BlKSArIHRoaXMueV9zaGlmdDtcbiAgICAgICAgICAgIHZhciBzdGFydF95ID0gYmVhbV95ICsgKFZleC5GbG93LlN0ZW0uSEVJR0hUICogdGhpcy5zdGVtX2RpcmVjdGlvbik7XG4gICAgICAgICAgICB2YXIgZW5kX3kgPSBiZWFtX3kgKyAoc3RlbWxldF9oZWlnaHQgKiB0aGlzLnN0ZW1fZGlyZWN0aW9uKTtcblxuICAgICAgICAgICAgLy8gRHJhdyBTdGVtbGV0XG4gICAgICAgICAgICBub3RlLnNldFN0ZW0obmV3IFZleC5GbG93LlN0ZW0oe1xuICAgICAgICAgICAgICB4X2JlZ2luOiBjZW50ZXJHbHlwaFgsXG4gICAgICAgICAgICAgIHhfZW5kOiBjZW50ZXJHbHlwaFgsXG4gICAgICAgICAgICAgIHlfYm90dG9tOiB0aGlzLnN0ZW1fZGlyZWN0aW9uID09PSBTdGVtLlVQID8gZW5kX3kgOiBzdGFydF95LFxuICAgICAgICAgICAgICB5X3RvcDogdGhpcy5zdGVtX2RpcmVjdGlvbiA9PT0gU3RlbS5VUCA/IHN0YXJ0X3kgOiBlbmRfeSxcbiAgICAgICAgICAgICAgeV9leHRlbmQ6IHlfZGlzcGxhY2VtZW50LFxuICAgICAgICAgICAgICBzdGVtX2V4dGVuc2lvbjogLTEsIC8vIFRvIGF2b2lkIHByb3RydWRpbmcgdGhyb3VnaCB0aGUgYmVhbVxuICAgICAgICAgICAgICBzdGVtX2RpcmVjdGlvbjogdGhpcy5zdGVtX2RpcmVjdGlvblxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHNsb3BlX3kgPSB0aGlzLmdldFNsb3BlWSh4X3B4LCBmaXJzdF94X3B4LCBmaXJzdF95X3B4LFxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5zbG9wZSkgKyB0aGlzLnlfc2hpZnQ7XG5cbiAgICAgICAgbm90ZS5zZXRTdGVtKG5ldyBWZXguRmxvdy5TdGVtKHtcbiAgICAgICAgICB4X2JlZ2luOiB4X3B4IC0gKFZleC5GbG93LlNURU1fV0lEVEgvMiksXG4gICAgICAgICAgeF9lbmQ6IHhfcHgsXG4gICAgICAgICAgeV90b3A6IHRoaXMuc3RlbV9kaXJlY3Rpb24gPT09IFN0ZW0uVVAgPyB0b3BfeV9weCA6IGJhc2VfeV9weCxcbiAgICAgICAgICB5X2JvdHRvbTogdGhpcy5zdGVtX2RpcmVjdGlvbiA9PT0gU3RlbS5VUCA/IGJhc2VfeV9weCA6ICB0b3BfeV9weCxcbiAgICAgICAgICB5X2V4dGVuZDogeV9kaXNwbGFjZW1lbnQsXG4gICAgICAgICAgc3RlbV9leHRlbnNpb246IE1hdGguYWJzKHRvcF95X3B4IC0gc2xvcGVfeSkgLSBTdGVtLkhFSUdIVCAtIDEsXG4gICAgICAgICAgc3RlbV9kaXJlY3Rpb246IHRoaXMuc3RlbV9kaXJlY3Rpb25cbiAgICAgICAgfSkpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHggY29vcmRpbmF0ZXMgZm9yIHRoZSBiZWFtIGxpbmVzIG9mIHNwZWNpZmljIGBkdXJhdGlvbmBcbiAgICBnZXRCZWFtTGluZXM6IGZ1bmN0aW9uKGR1cmF0aW9uKSB7XG4gICAgICB2YXIgYmVhbV9saW5lcyA9IFtdO1xuICAgICAgdmFyIGJlYW1fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgdmFyIGN1cnJlbnRfYmVhbSA9IG51bGw7XG4gICAgICB2YXIgcGFydGlhbF9iZWFtX2xlbmd0aCA9IHRoaXMucmVuZGVyX29wdGlvbnMucGFydGlhbF9iZWFtX2xlbmd0aDtcbiAgICAgIHZhciBwcmV2aW91c19zaG91bGRfYnJlYWsgPSBmYWxzZTtcbiAgICAgIHZhciB0aWNrX3RhbGx5ID0gMDtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub3Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgbm90ZSA9IHRoaXMubm90ZXNbaV07XG5cbiAgICAgICAgLy8gU2VlIGlmIHdlIG5lZWQgdG8gYnJlYWsgc2Vjb25kYXJ5IGJlYW1zIG9uIHRoaXMgbm90ZS5cbiAgICAgICAgdmFyIHRpY2tzID0gbm90ZS5nZXRJbnRyaW5zaWNUaWNrcygpO1xuICAgICAgICB0aWNrX3RhbGx5ICs9IHRpY2tzO1xuICAgICAgICB2YXIgc2hvdWxkX2JyZWFrID0gZmFsc2U7XG5cbiAgICAgICAgLy8gOHRoIG5vdGUgYmVhbXMgYXJlIGFsd2F5cyBkcmF3bi5cbiAgICAgICAgaWYgKHBhcnNlSW50KGR1cmF0aW9uKSA+PSA4KSB7XG5cbiAgICAgICAgICAvLyBGaXJzdCwgY2hlY2sgdG8gc2VlIGlmIGFueSBpbmRpY2VzIHdlcmUgc2V0IHVwIHRocm91Z2ggYnJlYWtTZWNvbmRhcnlBdCgpXG4gICAgICAgICAgc2hvdWxkX2JyZWFrID0gdGhpcy5icmVha19vbl9pbmRpY2VzLmluZGV4T2YoaSkgIT09IC0xO1xuXG4gICAgICAgICAgLy8gSWYgdGhlIHNlY29uZGFyeSBicmVha3Mgd2VyZSBhdXRvLWNvbmZpZ3VyZWQgaW4gdGhlIHJlbmRlciBvcHRpb25zLFxuICAgICAgICAgIC8vICBoYW5kbGUgdGhhdCBhcyB3ZWxsLlxuICAgICAgICAgIGlmICh0aGlzLnJlbmRlcl9vcHRpb25zLnNlY29uZGFyeV9icmVha190aWNrcyAmJiB0aWNrX3RhbGx5ID49IHRoaXMucmVuZGVyX29wdGlvbnMuc2Vjb25kYXJ5X2JyZWFrX3RpY2tzKSB7XG4gICAgICAgICAgICB0aWNrX3RhbGx5ID0gMDtcbiAgICAgICAgICAgIHNob3VsZF9icmVhayA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBub3RlX2dldHNfYmVhbSA9IHRpY2tzIDwgVmV4LkZsb3cuZHVyYXRpb25Ub1RpY2tzKGR1cmF0aW9uKTtcbiAgICAgICAgdmFyIHN0ZW1feCA9IG5vdGUuaXNSZXN0KCkgPyBub3RlLmdldENlbnRlckdseXBoWCgpIDogbm90ZS5nZXRTdGVtWCgpO1xuXG4gICAgICAgIC8vIENoZWNrIHRvIHNlZSBpZiB0aGUgbmV4dCBub3RlIGluIHRoZSBncm91cCB3aWxsIGdldCBhIGJlYW0gYXQgdGhpc1xuICAgICAgICAvLyAgbGV2ZWwuIFRoaXMgd2lsbCBoZWxwIHRvIGluZm9ybSB0aGUgcGFydGlhbCBiZWFtIGxvZ2ljIGJlbG93LlxuICAgICAgICB2YXIgbmV4dF9ub3RlID0gdGhpcy5ub3Rlc1tpICsgMV07XG4gICAgICAgIHZhciBiZWFtX25leHQgPSBuZXh0X25vdGUgJiYgbmV4dF9ub3RlLmdldEludHJpbnNpY1RpY2tzKCkgPCBWZXguRmxvdy5kdXJhdGlvblRvVGlja3MoZHVyYXRpb24pO1xuICAgICAgICBpZiAobm90ZV9nZXRzX2JlYW0pIHtcblxuICAgICAgICAgIC8vIFRoaXMgbm90ZSBnZXRzIGEgYmVhbSBhdCB0aGUgY3VycmVudCBsZXZlbFxuICAgICAgICAgIGlmIChiZWFtX3N0YXJ0ZWQpIHtcblxuICAgICAgICAgICAgLy8gV2UncmUgY3VycmVudGx5IGluIHRoZSBtaWRkbGUgb2YgYSBiZWFtLiBKdXN0IGNvbnRpbnVlIGl0IG9uIHRvXG4gICAgICAgICAgICAvLyAgdGhlIHN0ZW0gWCBvZiB0aGUgY3VycmVudCBub3RlLlxuICAgICAgICAgICAgY3VycmVudF9iZWFtID0gYmVhbV9saW5lc1tiZWFtX2xpbmVzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgY3VycmVudF9iZWFtLmVuZCA9IHN0ZW1feDtcblxuICAgICAgICAgICAgLy8gSWYgYSBzZWNvbmRhcnkgYmVhbSBicmVhayBpcyBzZXQgdXAsIGVuZCB0aGUgYmVhbSByaWdodCBub3cuXG4gICAgICAgICAgICBpZiAoc2hvdWxkX2JyZWFrKSB7XG4gICAgICAgICAgICAgIGJlYW1fc3RhcnRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICBpZiAobmV4dF9ub3RlICYmICFiZWFtX25leHQgJiYgY3VycmVudF9iZWFtLmVuZCA9PT0gbnVsbCkge1xuXG4gICAgICAgICAgICAgICAgLy8gVGhpcyBub3RlIGdldHMgYSBiZWFtLC5idXQgdGhlIG5leHQgb25lIGRvZXMgbm90LiBUaGlzIG1lYW5zXG4gICAgICAgICAgICAgICAgLy8gIHdlIG5lZWQgYSBwYXJ0aWFsIHBvaW50aW5nIHJpZ2h0LlxuICAgICAgICAgICAgICAgIGN1cnJlbnRfYmVhbS5lbmQgPSBjdXJyZW50X2JlYW0uc3RhcnQgLSBwYXJ0aWFsX2JlYW1fbGVuZ3RoO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgICAgLy8gTm8gYmVhbSBzdGFydGVkIHlldC4gU3RhcnQgYSBuZXcgb25lLlxuICAgICAgICAgICAgY3VycmVudF9iZWFtID0geyBzdGFydDogc3RlbV94LCBlbmQ6IG51bGwgfTtcbiAgICAgICAgICAgIGJlYW1fc3RhcnRlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIWJlYW1fbmV4dCkge1xuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG5vdGUgZG9lc24ndCBnZXQgYSBiZWFtLiBEcmF3IGEgcGFydGlhbC5cbiAgICAgICAgICAgICAgaWYoKHByZXZpb3VzX3Nob3VsZF9icmVhayB8fCBpID09PSAwKSAmJiBuZXh0X25vdGUpIHtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgdGhlIGZpcnN0IG5vdGUgKGJ1dCBub3QgdGhlIGxhc3Qgb25lKSwgb3IgaXQgaXNcbiAgICAgICAgICAgICAgICAvLyAgZm9sbG93aW5nIGEgc2Vjb25kYXJ5IGJyZWFrLiBEcmF3IGEgcGFydGlhbCB0byB0aGUgcmlnaHQuXG4gICAgICAgICAgICAgICAgY3VycmVudF9iZWFtLmVuZCA9IGN1cnJlbnRfYmVhbS5zdGFydCArIHBhcnRpYWxfYmVhbV9sZW5ndGg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG5cbiAgICAgICAgICAgICAgICAvLyBCeSBkZWZhdWx0LCBkcmF3IGEgcGFydGlhbCB0byB0aGUgbGVmdC5cbiAgICAgICAgICAgICAgICBjdXJyZW50X2JlYW0uZW5kID0gY3VycmVudF9iZWFtLnN0YXJ0IC0gcGFydGlhbF9iZWFtX2xlbmd0aDtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIGlmIChzaG91bGRfYnJlYWspIHtcblxuICAgICAgICAgICAgICAvLyBUaGlzIG5vdGUgc2hvdWxkIGhhdmUgYSBzZWNvbmRhcnkgYnJlYWsgYWZ0ZXIgaXQuIEV2ZW4gdGhvdWdoXG4gICAgICAgICAgICAgIC8vICB3ZSBqdXN0IHN0YXJ0ZWQgYSBiZWFtLCBpdCBuZWVkcyB0byBlbmQgaW1tZWRpYXRlbHkuXG4gICAgICAgICAgICAgIGN1cnJlbnRfYmVhbS5lbmQgPSBjdXJyZW50X2JlYW0uc3RhcnQgLSBwYXJ0aWFsX2JlYW1fbGVuZ3RoO1xuICAgICAgICAgICAgICBiZWFtX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJlYW1fbGluZXMucHVzaChjdXJyZW50X2JlYW0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcblxuICAgICAgICAgIC8vIFRoZSBjdXJyZW50IG5vdGUgZG9lcyBub3QgZ2V0IGEgYmVhbS5cbiAgICAgICAgICBiZWFtX3N0YXJ0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0b3JlIHRoZSBzZWNvbmRhcnkgYnJlYWsgZmxhZyB0byBpbmZvcm0gdGhlIHBhcnRpYWwgYmVhbSBsb2dpYyBpblxuICAgICAgICAvLyAgdGhlIG5leHQgaXRlcmF0aW9uIG9mIHRoZSBsb29wLlxuICAgICAgICBwcmV2aW91c19zaG91bGRfYnJlYWsgPSBzaG91bGRfYnJlYWs7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkZCBhIHBhcnRpYWwgYmVhbSBwb2ludGluZyBsZWZ0IGlmIHRoaXMgaXMgdGhlIGxhc3Qgbm90ZSBpbiB0aGUgZ3JvdXBcbiAgICAgIHZhciBsYXN0X2JlYW0gPSBiZWFtX2xpbmVzW2JlYW1fbGluZXMubGVuZ3RoIC0gMV07XG4gICAgICBpZiAobGFzdF9iZWFtICYmIGxhc3RfYmVhbS5lbmQgPT09IG51bGwpIHtcbiAgICAgICAgbGFzdF9iZWFtLmVuZCA9IGxhc3RfYmVhbS5zdGFydCAtIHBhcnRpYWxfYmVhbV9sZW5ndGg7XG4gICAgICB9XG4gICAgICByZXR1cm4gYmVhbV9saW5lcztcbiAgICB9LFxuXG4gICAgLy8gUmVuZGVyIHRoZSBzdGVtcyBmb3IgZWFjaCBub3Rlc1xuICAgIGRyYXdTdGVtczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm5vdGVzLmZvckVhY2goZnVuY3Rpb24obm90ZSkge1xuICAgICAgICBpZiAobm90ZS5nZXRTdGVtKCkpIHtcbiAgICAgICAgICBub3RlLmdldFN0ZW0oKS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCkuZHJhdygpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcbiAgICB9LFxuXG4gICAgLy8gUmVuZGVyIHRoZSBiZWFtIGxpbmVzXG4gICAgZHJhd0JlYW1MaW5lczogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHdpdGhvdXQgYSBjYW52YXMgY29udGV4dC5cIik7XG5cbiAgICAgIHZhciB2YWxpZF9iZWFtX2R1cmF0aW9ucyA9IFtcIjRcIiwgXCI4XCIsIFwiMTZcIiwgXCIzMlwiLCBcIjY0XCJdO1xuXG4gICAgICB2YXIgZmlyc3Rfbm90ZSA9IHRoaXMubm90ZXNbMF07XG4gICAgICB2YXIgbGFzdF9ub3RlID0gdGhpcy5ub3Rlc1t0aGlzLm5vdGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICB2YXIgZmlyc3RfeV9weCA9IGZpcnN0X25vdGUuZ2V0U3RlbUV4dGVudHMoKS50b3BZO1xuICAgICAgdmFyIGxhc3RfeV9weCA9IGxhc3Rfbm90ZS5nZXRTdGVtRXh0ZW50cygpLnRvcFk7XG5cbiAgICAgIC8vIEZvciBmbGF0IGJlYW1zLCBzZXQgdGhlIGZpcnN0IGFuZCBsYXN0IFkgdG8gdGhlIG9mZnNldCwgcmF0aGVyIHRoYW5cbiAgICAgIC8vICB1c2luZyB0aGUgbm90ZSdzIHN0ZW0gZXh0ZW50cy5cbiAgICAgIGlmICh0aGlzLnJlbmRlcl9vcHRpb25zLmZsYXRfYmVhbXMgJiYgdGhpcy5yZW5kZXJfb3B0aW9ucy5mbGF0X2JlYW1fb2Zmc2V0KSB7XG4gICAgICAgIGZpcnN0X3lfcHggPSB0aGlzLnJlbmRlcl9vcHRpb25zLmZsYXRfYmVhbV9vZmZzZXQ7XG4gICAgICAgIGxhc3RfeV9weCA9IHRoaXMucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtX29mZnNldDtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0X3hfcHggPSBmaXJzdF9ub3RlLmdldFN0ZW1YKCk7XG5cbiAgICAgIHZhciBiZWFtX3dpZHRoID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5iZWFtX3dpZHRoICogdGhpcy5zdGVtX2RpcmVjdGlvbjtcblxuICAgICAgLy8gRHJhdyB0aGUgYmVhbXMuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbGlkX2JlYW1fZHVyYXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBkdXJhdGlvbiA9IHZhbGlkX2JlYW1fZHVyYXRpb25zW2ldO1xuICAgICAgICB2YXIgYmVhbV9saW5lcyA9IHRoaXMuZ2V0QmVhbUxpbmVzKGR1cmF0aW9uKTtcblxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGJlYW1fbGluZXMubGVuZ3RoOyArK2opIHtcbiAgICAgICAgICB2YXIgYmVhbV9saW5lID0gYmVhbV9saW5lc1tqXTtcbiAgICAgICAgICB2YXIgZmlyc3RfeCA9IGJlYW1fbGluZS5zdGFydCAtICh0aGlzLnN0ZW1fZGlyZWN0aW9uID09IFN0ZW0uRE9XTiA/IFZleC5GbG93LlNURU1fV0lEVEgvMjowKTtcbiAgICAgICAgICB2YXIgZmlyc3RfeSA9IHRoaXMuZ2V0U2xvcGVZKGZpcnN0X3gsIGZpcnN0X3hfcHgsIGZpcnN0X3lfcHgsIHRoaXMuc2xvcGUpO1xuXG4gICAgICAgICAgdmFyIGxhc3RfeCA9IGJlYW1fbGluZS5lbmQgK1xuICAgICAgICAgICAgKHRoaXMuc3RlbV9kaXJlY3Rpb24gPT0gMSA/IChWZXguRmxvdy5TVEVNX1dJRFRILzMpOigtVmV4LkZsb3cuU1RFTV9XSURUSC8zKSk7XG4gICAgICAgICAgdmFyIGxhc3RfeSA9IHRoaXMuZ2V0U2xvcGVZKGxhc3RfeCwgZmlyc3RfeF9weCwgZmlyc3RfeV9weCwgdGhpcy5zbG9wZSk7XG5cbiAgICAgICAgICB0aGlzLmNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgICAgICAgdGhpcy5jb250ZXh0Lm1vdmVUbyhmaXJzdF94LCBmaXJzdF95ICsgdGhpcy55X3NoaWZ0KTtcbiAgICAgICAgICB0aGlzLmNvbnRleHQubGluZVRvKGZpcnN0X3gsIGZpcnN0X3kgKyBiZWFtX3dpZHRoICsgdGhpcy55X3NoaWZ0KTtcbiAgICAgICAgICB0aGlzLmNvbnRleHQubGluZVRvKGxhc3RfeCArIDEsIGxhc3RfeSArIGJlYW1fd2lkdGggKyB0aGlzLnlfc2hpZnQpO1xuICAgICAgICAgIHRoaXMuY29udGV4dC5saW5lVG8obGFzdF94ICsgMSwgbGFzdF95ICsgdGhpcy55X3NoaWZ0KTtcbiAgICAgICAgICB0aGlzLmNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGwoKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGZpcnN0X3lfcHggKz0gYmVhbV93aWR0aCAqIDEuNTtcbiAgICAgICAgbGFzdF95X3B4ICs9IGJlYW1fd2lkdGggKiAxLjU7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFByZS1mb3JtYXQgdGhlIGJlYW1cbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIFBvc3QtZm9ybWF0IHRoZSBiZWFtLiBUaGlzIGNhbiBvbmx5IGJlIGNhbGxlZCBhZnRlclxuICAgIC8vIHRoZSBub3RlcyBpbiB0aGUgYmVhbSBoYXZlIGJvdGggYHhgIGFuZCBgeWAgdmFsdWVzLiBpZTogdGhleSd2ZVxuICAgIC8vIGJlZW4gZm9ybWF0dGVkIGFuZCBoYXZlIHN0YXZlc1xuICAgIHBvc3RGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHRoaXMucG9zdEZvcm1hdHRlZCkgcmV0dXJuO1xuXG4gICAgICAvLyBDYWxjdWxhdGUgYSBzbWFydCBzbG9wZSBpZiB3ZSdyZSBub3QgZm9yY2luZyB0aGUgYmVhbXMgdG8gYmUgZmxhdC5cbiAgICAgIGlmKHRoaXMucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtcykge1xuICAgICAgICB0aGlzLmNhbGN1bGF0ZUZsYXRTbG9wZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYWxjdWxhdGVTbG9wZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5hcHBseVN0ZW1FeHRlbnNpb25zKCk7XG5cbiAgICAgIHRoaXMucG9zdEZvcm1hdHRlZCA9IHRydWU7XG4gICAgfSxcblxuICAgIC8vIFJlbmRlciB0aGUgYmVhbSB0byB0aGUgY2FudmFzIGNvbnRleHRcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgd2l0aG91dCBhIGNhbnZhcyBjb250ZXh0LlwiKTtcblxuICAgICAgaWYgKHRoaXMudW5iZWFtYWJsZSkgcmV0dXJuO1xuXG4gICAgICBpZiAoIXRoaXMucG9zdEZvcm1hdHRlZCkge1xuICAgICAgICB0aGlzLnBvc3RGb3JtYXQoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kcmF3U3RlbXMoKTtcbiAgICAgIHRoaXMuZHJhd0JlYW1MaW5lcygpO1xuXG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgZnVuY3Rpb24gY2FsY3VsYXRlU3RlbURpcmVjdGlvbihub3Rlcykge1xuICAgIHZhciBsaW5lU3VtID0gMDtcbiAgICBub3Rlcy5mb3JFYWNoKGZ1bmN0aW9uKG5vdGUpIHtcbiAgICAgIGlmIChub3RlLmtleVByb3BzKSB7XG4gICAgICAgIG5vdGUua2V5UHJvcHMuZm9yRWFjaChmdW5jdGlvbihrZXlQcm9wKXtcbiAgICAgICAgICBsaW5lU3VtICs9IChrZXlQcm9wLmxpbmUgLSAzKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAobGluZVN1bSA+PSAwKVxuICAgICAgcmV0dXJuIFN0ZW0uRE9XTjtcbiAgICByZXR1cm4gU3RlbS5VUDtcbiAgfVxuXG4gIC8vICMjIFN0YXRpYyBNZXRob2RzXG4gIC8vXG4gIC8vIEdldHMgdGhlIGRlZmF1bHQgYmVhbSBncm91cHMgZm9yIGEgcHJvdmlkZWQgdGltZSBzaWduYXR1cmUuXG4gIC8vIEF0dGVtcHRzIHRvIGd1ZXNzIGlmIHRoZSB0aW1lIHNpZ25hdHVyZSBpcyBub3QgZm91bmQgaW4gdGFibGUuXG4gIC8vIEN1cnJlbnRseSB0aGlzIGlzIGZhaXJseSBuYWl2ZS5cbiAgQmVhbS5nZXREZWZhdWx0QmVhbUdyb3VwcyA9IGZ1bmN0aW9uKHRpbWVfc2lnKXtcbiAgICBpZiAoIXRpbWVfc2lnIHx8IHRpbWVfc2lnID09IFwiY1wiKSB0aW1lX3NpZyA9IFwiNC80XCI7XG5cbiAgICB2YXIgZGVmYXVsdHMgPSB7XG4gICAgICAnMS8yJyA6ICBbJzEvMiddLFxuICAgICAgJzIvMicgOiAgWycxLzInXSxcbiAgICAgICczLzInIDogIFsnMS8yJ10sXG4gICAgICAnNC8yJyA6ICBbJzEvMiddLFxuXG4gICAgICAnMS80JyA6ICBbJzEvNCddLFxuICAgICAgJzIvNCcgOiAgWycxLzQnXSxcbiAgICAgICczLzQnIDogIFsnMS80J10sXG4gICAgICAnNC80JyA6ICBbJzEvNCddLFxuXG4gICAgICAnMS84JyA6ICBbJzEvOCddLFxuICAgICAgJzIvOCcgOiAgWycyLzgnXSxcbiAgICAgICczLzgnIDogIFsnMy84J10sXG4gICAgICAnNC84JyA6ICBbJzIvOCddLFxuXG4gICAgICAnMS8xNicgOiBbJzEvMTYnXSxcbiAgICAgICcyLzE2JyA6IFsnMi8xNiddLFxuICAgICAgJzMvMTYnIDogWyczLzE2J10sXG4gICAgICAnNC8xNicgOiBbJzIvMTYnXVxuICAgIH07XG5cbiAgICB2YXIgRnJhY3Rpb24gPSBWZXguRmxvdy5GcmFjdGlvbjtcbiAgICB2YXIgZ3JvdXBzID0gZGVmYXVsdHNbdGltZV9zaWddO1xuXG4gICAgaWYgKCFncm91cHMpIHtcbiAgICAgIC8vIElmIG5vIGJlYW0gZ3JvdXBzIGZvdW5kLCBuYWl2ZWx5IGRldGVybWluZVxuICAgICAgLy8gdGhlIGJlYW0gZ3JvdXBpbmdzIGZyb20gdGhlIHRpbWUgc2lnbmF0dXJlXG4gICAgICB2YXIgYmVhdFRvdGFsID0gcGFyc2VJbnQodGltZV9zaWcuc3BsaXQoJy8nKVswXSwgMTApO1xuICAgICAgdmFyIGJlYXRWYWx1ZSA9IHBhcnNlSW50KHRpbWVfc2lnLnNwbGl0KCcvJylbMV0sIDEwKTtcblxuICAgICAgdmFyIHRyaXBsZU1ldGVyID0gYmVhdFRvdGFsICUgMyA9PT0gMDtcblxuICAgICAgaWYgKHRyaXBsZU1ldGVyKSB7XG4gICAgICAgIHJldHVybiBbbmV3IEZyYWN0aW9uKDMsIGJlYXRWYWx1ZSldO1xuICAgICAgfSBlbHNlIGlmIChiZWF0VmFsdWUgPiA0KSB7XG4gICAgICAgIHJldHVybiBbbmV3IEZyYWN0aW9uKDIsIGJlYXRWYWx1ZSldO1xuICAgICAgfSBlbHNlIGlmIChiZWF0VmFsdWUgPD0gNCkge1xuICAgICAgICByZXR1cm4gW25ldyBGcmFjdGlvbigxLCBiZWF0VmFsdWUpXTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGdyb3Vwcy5tYXAoZnVuY3Rpb24oZ3JvdXApIHtcbiAgICAgICAgcmV0dXJuIG5ldyBGcmFjdGlvbigpLnBhcnNlKGdyb3VwKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcblxuICAvLyBBIGhlbHBlciBmdW5jdGlvbiB0byBhdXRvbWF0aWNhbGx5IGJ1aWxkIGJhc2ljIGJlYW1zIGZvciBhIHZvaWNlLiBGb3IgbW9yZVxuICAvLyBjb21wbGV4IGF1dG8tYmVhbWluZyB1c2UgYEJlYW0uZ2VuZXJhdGVCZWFtcygpYC5cbiAgLy9cbiAgLy8gUGFyYW1ldGVyczpcbiAgLy8gKiBgdm9pY2VgIC0gVGhlIHZvaWNlIHRvIGdlbmVyYXRlIHRoZSBiZWFtcyBmb3JcbiAgLy8gKiBgc3RlbV9kaXJlY3Rpb25gIC0gQSBzdGVtIGRpcmVjdGlvbiB0byBhcHBseSB0byB0aGUgZW50aXJlIHZvaWNlXG4gIC8vICogYGdyb3Vwc2AgLSBBbiBhcnJheSBvZiBgRnJhY3Rpb25gIHJlcHJlc2VudGluZyBiZWF0IGdyb3VwaW5ncyBmb3IgdGhlIGJlYW1cbiAgQmVhbS5hcHBseUFuZEdldEJlYW1zID0gZnVuY3Rpb24odm9pY2UsIHN0ZW1fZGlyZWN0aW9uLCBncm91cHMpIHtcbiAgICByZXR1cm4gQmVhbS5nZW5lcmF0ZUJlYW1zKHZvaWNlLmdldFRpY2thYmxlcygpLCB7XG4gICAgICBncm91cHM6IGdyb3VwcyxcbiAgICAgIHN0ZW1fZGlyZWN0aW9uOiBzdGVtX2RpcmVjdGlvblxuICAgIH0pO1xuICB9O1xuXG4gIC8vIEEgaGVscGVyIGZ1bmN0aW9uIHRvIGF1dGltYXRpY2FsbHkgYnVpbGQgYmVhbXMgZm9yIGEgdm9pY2Ugd2l0aFxuICAvLyBjb25maWd1cmF0aW9uIG9wdGlvbnMuXG4gIC8vXG4gIC8vIEV4YW1wbGUgY29uZmlndXJhdGlvbiBvYmplY3Q6XG4gIC8vXG4gIC8vIGBgYFxuICAvLyBjb25maWcgPSB7XG4gIC8vICAgZ3JvdXBzOiBbbmV3IFZleC5GbG93LkZyYWN0aW9uKDIsIDgpXSxcbiAgLy8gICBzdGVtX2RpcmVjdGlvbjogLTEsXG4gIC8vICAgYmVhbV9yZXN0czogdHJ1ZSxcbiAgLy8gICBiZWFtX21pZGRsZV9vbmx5OiB0cnVlLFxuICAvLyAgIHNob3dfc3RlbWxldHM6IGZhbHNlXG4gIC8vIH07XG4gIC8vIGBgYFxuICAvL1xuICAvLyBQYXJhbWV0ZXJzOlxuICAvLyAqIGBub3Rlc2AgLSBBbiBhcnJheSBvZiBub3RlcyB0byBjcmVhdGUgdGhlIGJlYW1zIGZvclxuICAvLyAqIGBjb25maWdgIC0gVGhlIGNvbmZpZ3VyYXRpb24gb2JqZWN0XG4gIC8vICAgICogYGdyb3Vwc2AgLSBBcnJheSBvZiBgRnJhY3Rpb25zYCB0aGF0IHJlcHJlc2VudCB0aGUgYmVhdCBzdHJ1Y3R1cmUgdG8gYmVhbSB0aGUgbm90ZXNcbiAgLy8gICAgKiBgc3RlbV9kaXJlY3Rpb25gIC0gU2V0IHRvIGFwcGx5IHRoZSBzYW1lIGRpcmVjdGlvbiB0byBhbGwgbm90ZXNcbiAgLy8gICAgKiBgYmVhbV9yZXN0c2AgLSBTZXQgdG8gYHRydWVgIHRvIGluY2x1ZGUgcmVzdHMgaW4gdGhlIGJlYW1zXG4gIC8vICAgICogYGJlYW1fbWlkZGxlX29ubHlgIC0gU2V0IHRvIGB0cnVlYCB0byBvbmx5IGJlYW0gcmVzdHMgaW4gdGhlIG1pZGRsZSBvZiB0aGUgYmVhdFxuICAvLyAgICAqIGBzaG93X3N0ZW1sZXRzYCAtIFNldCB0byBgdHJ1ZWAgdG8gZHJhdyBzdGVtbGV0cyBmb3IgcmVzdHNcbiAgLy8gICAgKiBgbWFpbnRhaW5fc3RlbV9kaXJlY3Rpb25zYCAtIFNldCB0byBgdHJ1ZWAgdG8gbm90IGFwcGx5IG5ldyBzdGVtIGRpcmVjdGlvbnNcbiAgLy9cbiAgQmVhbS5nZW5lcmF0ZUJlYW1zID0gZnVuY3Rpb24obm90ZXMsIGNvbmZpZykge1xuXG4gICAgaWYgKCFjb25maWcpIGNvbmZpZyA9IHt9O1xuXG4gICAgaWYgKCFjb25maWcuZ3JvdXBzIHx8ICFjb25maWcuZ3JvdXBzLmxlbmd0aCkge1xuICAgICAgY29uZmlnLmdyb3VwcyA9IFtuZXcgVmV4LkZsb3cuRnJhY3Rpb24oMiwgOCldO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgYmVhbSBncm91cHMgdG8gdGljayBhbW91bnRzXG4gICAgdmFyIHRpY2tHcm91cHMgPSBjb25maWcuZ3JvdXBzLm1hcChmdW5jdGlvbihncm91cCkge1xuICAgICAgaWYgKCFncm91cC5tdWx0aXBseSkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkludmFsaWRCZWFtR3JvdXBzXCIsXG4gICAgICAgICAgXCJUaGUgYmVhbSBncm91cHMgbXVzdCBiZSBhbiBhcnJheSBvZiBWZXguRmxvdy5GcmFjdGlvbnNcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXAuY2xvbmUoKS5tdWx0aXBseShWZXguRmxvdy5SRVNPTFVUSU9OLCAxKTtcbiAgICB9KTtcblxuICAgIHZhciB1bnByb2Nlc3NlZE5vdGVzID0gbm90ZXM7XG4gICAgdmFyIGN1cnJlbnRUaWNrR3JvdXAgPSAwO1xuICAgIHZhciBub3RlR3JvdXBzICAgICAgID0gW107XG4gICAgdmFyIGN1cnJlbnRHcm91cCAgICAgPSBbXTtcblxuICAgIGZ1bmN0aW9uIGdldFRvdGFsVGlja3ModmZfbm90ZXMpe1xuICAgICAgcmV0dXJuIHZmX25vdGVzLnJlZHVjZShmdW5jdGlvbihtZW1vLG5vdGUpe1xuICAgICAgICByZXR1cm4gbm90ZS5nZXRUaWNrcygpLmNsb25lKCkuYWRkKG1lbW8pO1xuICAgICAgfSwgbmV3IFZleC5GbG93LkZyYWN0aW9uKDAsIDEpKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZXh0VGlja0dyb3VwKCkge1xuICAgICAgaWYgKHRpY2tHcm91cHMubGVuZ3RoIC0gMSA+IGN1cnJlbnRUaWNrR3JvdXApIHtcbiAgICAgICAgY3VycmVudFRpY2tHcm91cCArPSAxO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3VycmVudFRpY2tHcm91cCA9IDA7XG4gICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY3JlYXRlR3JvdXBzKCl7XG4gICAgICB2YXIgbmV4dEdyb3VwID0gW107XG5cbiAgICAgIHVucHJvY2Vzc2VkTm90ZXMuZm9yRWFjaChmdW5jdGlvbih1bnByb2Nlc3NlZE5vdGUpe1xuICAgICAgICBuZXh0R3JvdXAgICAgPSBbXTtcbiAgICAgICAgaWYgKHVucHJvY2Vzc2VkTm90ZS5zaG91bGRJZ25vcmVUaWNrcygpKSB7XG4gICAgICAgICAgbm90ZUdyb3Vwcy5wdXNoKGN1cnJlbnRHcm91cCk7XG4gICAgICAgICAgY3VycmVudEdyb3VwID0gbmV4dEdyb3VwO1xuICAgICAgICAgIHJldHVybjsgLy8gSWdub3JlIHVudGlja2FibGVzIChsaWtlIGJhciBub3RlcylcbiAgICAgICAgfVxuXG4gICAgICAgIGN1cnJlbnRHcm91cC5wdXNoKHVucHJvY2Vzc2VkTm90ZSk7XG4gICAgICAgIHZhciB0aWNrc1Blckdyb3VwID0gdGlja0dyb3Vwc1tjdXJyZW50VGlja0dyb3VwXS5jbG9uZSgpO1xuICAgICAgICB2YXIgdG90YWxUaWNrcyA9IGdldFRvdGFsVGlja3MoY3VycmVudEdyb3VwKTtcblxuICAgICAgICAvLyBEb3VibGUgdGhlIGFtb3VudCBvZiB0aWNrcyBpbiBhIGdyb3VwLCBpZiBpdCdzIGFuIHVuYmVhbWFibGUgdHVwbGV0XG4gICAgICAgIHZhciB1bmJlYW1hYmxlID0gVmV4LkZsb3cuZHVyYXRpb25Ub051bWJlcih1bnByb2Nlc3NlZE5vdGUuZHVyYXRpb24pIDwgODtcbiAgICAgICAgaWYgKHVuYmVhbWFibGUgJiYgdW5wcm9jZXNzZWROb3RlLnR1cGxldCkge1xuICAgICAgICAgIHRpY2tzUGVyR3JvdXAubnVtZXJhdG9yICo9IDI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBJZiB0aGUgbm90ZSB0aGF0IHdhcyBqdXN0IGFkZGVkIG92ZXJmbG93cyB0aGUgZ3JvdXAgdGljayB0b3RhbFxuICAgICAgICBpZiAodG90YWxUaWNrcy5ncmVhdGVyVGhhbih0aWNrc1Blckdyb3VwKSkge1xuICAgICAgICAgIC8vIElmIHRoZSBvdmVyZmxvdyBub3RlIGNhbiBiZSBiZWFtZWQsIHN0YXJ0IHRoZSBuZXh0IGdyb3VwXG4gICAgICAgICAgLy8gd2l0aCBpdC4gVW5iZWFtYWJsZSBub3RlcyBsZWF2ZSB0aGUgZ3JvdXAgb3ZlcmZsb3dlZC5cbiAgICAgICAgICBpZiAoIXVuYmVhbWFibGUpIHtcbiAgICAgICAgICAgIG5leHRHcm91cC5wdXNoKGN1cnJlbnRHcm91cC5wb3AoKSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIG5vdGVHcm91cHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgICAgICAgIGN1cnJlbnRHcm91cCA9IG5leHRHcm91cDtcbiAgICAgICAgICBuZXh0VGlja0dyb3VwKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodG90YWxUaWNrcy5lcXVhbHModGlja3NQZXJHcm91cCkpIHtcbiAgICAgICAgICBub3RlR3JvdXBzLnB1c2goY3VycmVudEdyb3VwKTtcbiAgICAgICAgICBjdXJyZW50R3JvdXAgPSBuZXh0R3JvdXA7XG4gICAgICAgICAgbmV4dFRpY2tHcm91cCgpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQWRkcyBhbnkgcmVtYWluZGVyIG5vdGVzXG4gICAgICBpZiAoY3VycmVudEdyb3VwLmxlbmd0aCA+IDApXG4gICAgICAgIG5vdGVHcm91cHMucHVzaChjdXJyZW50R3JvdXApO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGdldEJlYW1Hcm91cHMoKSB7XG4gICAgICByZXR1cm4gbm90ZUdyb3Vwcy5maWx0ZXIoZnVuY3Rpb24oZ3JvdXApe1xuICAgICAgICAgIGlmIChncm91cC5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICB2YXIgYmVhbWFibGUgPSB0cnVlO1xuICAgICAgICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbihub3RlKSB7XG4gICAgICAgICAgICAgIGlmIChub3RlLmdldEludHJpbnNpY1RpY2tzKCkgPj0gVmV4LkZsb3cuZHVyYXRpb25Ub1RpY2tzKFwiNFwiKSkge1xuICAgICAgICAgICAgICAgIGJlYW1hYmxlID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgcmV0dXJuIGJlYW1hYmxlO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICAvLyBTcGxpdHMgdXAgZ3JvdXBzIGJ5IFJlc3RcbiAgICBmdW5jdGlvbiBzYW5pdGl6ZUdyb3VwcygpIHtcbiAgICAgIHZhciBzYW5pdGl6ZWRHcm91cHMgPSBbXTtcbiAgICAgIG5vdGVHcm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCkge1xuICAgICAgICB2YXIgdGVtcEdyb3VwID0gW107XG4gICAgICAgIGdyb3VwLmZvckVhY2goZnVuY3Rpb24obm90ZSwgaW5kZXgsIGdyb3VwKSB7XG4gICAgICAgICAgdmFyIGlzRmlyc3RPckxhc3QgPSBpbmRleCA9PT0gMCB8fCBpbmRleCA9PT0gZ3JvdXAubGVuZ3RoIC0gMTtcbiAgICAgICAgICB2YXIgcHJldk5vdGUgPSBncm91cFtpbmRleC0xXTtcblxuICAgICAgICAgIHZhciBicmVha3NPbkVhY2hSZXN0ID0gIWNvbmZpZy5iZWFtX3Jlc3RzICYmIG5vdGUuaXNSZXN0KCk7XG4gICAgICAgICAgdmFyIGJyZWFrc09uRmlyc3RPckxhc3RSZXN0ID0gKGNvbmZpZy5iZWFtX3Jlc3RzICYmXG4gICAgICAgICAgICBjb25maWcuYmVhbV9taWRkbGVfb25seSAmJiBub3RlLmlzUmVzdCgpICYmIGlzRmlyc3RPckxhc3QpO1xuXG4gICAgICAgICAgdmFyIGJyZWFrT25TdGVtQ2hhbmdlID0gZmFsc2U7XG4gICAgICAgICAgaWYgKGNvbmZpZy5tYWludGFpbl9zdGVtX2RpcmVjdGlvbnMgJiYgcHJldk5vdGUgJiZcbiAgICAgICAgICAgICAgIW5vdGUuaXNSZXN0KCkgJiYgIXByZXZOb3RlLmlzUmVzdCgpKSB7XG4gICAgICAgICAgICB2YXIgcHJldkRpcmVjdGlvbiA9IHByZXZOb3RlLmdldFN0ZW1EaXJlY3Rpb24oKTtcbiAgICAgICAgICAgIHZhciBjdXJyZW50RGlyZWN0aW9uID0gbm90ZS5nZXRTdGVtRGlyZWN0aW9uKCk7XG4gICAgICAgICAgICBicmVha09uU3RlbUNoYW5nZSA9IGN1cnJlbnREaXJlY3Rpb24gIT09IHByZXZEaXJlY3Rpb247XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgdmFyIGlzVW5iZWFtYWJsZUR1cmF0aW9uID0gcGFyc2VJbnQobm90ZS5kdXJhdGlvbiwgMTApIDwgODtcblxuICAgICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgZ3JvdXAgc2hvdWxkIGJlIGJyb2tlbiBhdCB0aGlzIG5vdGVcbiAgICAgICAgICB2YXIgc2hvdWxkQnJlYWsgPSBicmVha3NPbkVhY2hSZXN0IHx8IGJyZWFrc09uRmlyc3RPckxhc3RSZXN0IHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWtPblN0ZW1DaGFuZ2UgfHwgaXNVbmJlYW1hYmxlRHVyYXRpb247XG5cbiAgICAgICAgICBpZiAoc2hvdWxkQnJlYWspIHtcbiAgICAgICAgICAgIC8vIEFkZCBjdXJyZW50IGdyb3VwXG4gICAgICAgICAgICBpZiAodGVtcEdyb3VwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgICAgc2FuaXRpemVkR3JvdXBzLnB1c2godGVtcEdyb3VwKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgLy8gU3RhcnQgYSBuZXcgZ3JvdXAuIEluY2x1ZGUgdGhlIGN1cnJlbnQgbm90ZSBpZiB0aGUgZ3JvdXBcbiAgICAgICAgICAgIC8vIHdhcyBicm9rZW4gdXAgYnkgc3RlbSBkaXJlY3Rpb24sIGFzIHRoYXQgbm90ZSBuZWVkcyB0byBzdGFydFxuICAgICAgICAgICAgLy8gdGhlIG5leHQgZ3JvdXAgb2Ygbm90ZXNcbiAgICAgICAgICAgIHRlbXBHcm91cCA9IGJyZWFrT25TdGVtQ2hhbmdlID8gW25vdGVdIDogW107XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIEFkZCBub3RlIHRvIGdyb3VwXG4gICAgICAgICAgICB0ZW1wR3JvdXAucHVzaChub3RlKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIElmIHRoZXJlIGlzIGEgcmVtYWluaW5nIGdyb3VwLCBhZGQgaXQgYXMgd2VsbFxuICAgICAgICBpZiAodGVtcEdyb3VwLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICBzYW5pdGl6ZWRHcm91cHMucHVzaCh0ZW1wR3JvdXApO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgbm90ZUdyb3VwcyA9IHNhbml0aXplZEdyb3VwcztcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmb3JtYXRTdGVtcygpIHtcbiAgICAgIG5vdGVHcm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCl7XG4gICAgICAgIHZhciBzdGVtRGlyZWN0aW9uO1xuICAgICAgICBpZiAoY29uZmlnLm1haW50YWluX3N0ZW1fZGlyZWN0aW9ucykge1xuICAgICAgICAgIHZhciBub3RlID0gZmluZEZpcnN0Tm90ZShncm91cCk7XG4gICAgICAgICAgc3RlbURpcmVjdGlvbiA9IG5vdGUgPyBub3RlLmdldFN0ZW1EaXJlY3Rpb24oKSA6IFN0ZW0uVVA7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKGNvbmZpZy5zdGVtX2RpcmVjdGlvbil7XG4gICAgICAgICAgICBzdGVtRGlyZWN0aW9uID0gY29uZmlnLnN0ZW1fZGlyZWN0aW9uO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdGVtRGlyZWN0aW9uID0gY2FsY3VsYXRlU3RlbURpcmVjdGlvbihncm91cCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGFwcGx5U3RlbURpcmVjdGlvbihncm91cCwgc3RlbURpcmVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBmaW5kRmlyc3ROb3RlKGdyb3VwKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGdyb3VwLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBub3RlID0gZ3JvdXBbaV07XG4gICAgICAgIGlmICghbm90ZS5pc1Jlc3QoKSkge1xuICAgICAgICAgIHJldHVybiBub3RlO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBhcHBseVN0ZW1EaXJlY3Rpb24oZ3JvdXAsIGRpcmVjdGlvbikge1xuICAgICAgZ3JvdXAuZm9yRWFjaChmdW5jdGlvbihub3RlKXtcbiAgICAgICAgbm90ZS5zZXRTdGVtRGlyZWN0aW9uKGRpcmVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBnZXRUdXBsZXRHcm91cHMoKSB7XG4gICAgICByZXR1cm4gbm90ZUdyb3Vwcy5maWx0ZXIoZnVuY3Rpb24oZ3JvdXApe1xuICAgICAgICBpZiAoZ3JvdXBbMF0pIHJldHVybiBncm91cFswXS50dXBsZXQ7XG4gICAgICB9KTtcbiAgICB9XG5cblxuICAgIC8vIFVzaW5nIGNsb3N1cmVzIHRvIHN0b3JlIHRoZSB2YXJpYWJsZXMgdGhyb3VnaG91dCB0aGUgdmFyaW91cyBmdW5jdGlvbnNcbiAgICAvLyBJTU8gS2VlcHMgaXQgdGhpcyBwcm9jZXNzIGxvdCBjbGVhbmVyIC0gYnV0IG5vdCBzdXBlciBjb25zaXN0ZW50IHdpdGhcbiAgICAvLyB0aGUgcmVzdCBvZiB0aGUgQVBJJ3Mgc3R5bGUgLSBTaWx2ZXJ3b2xmOTAgKEN5cmlsKVxuICAgIGNyZWF0ZUdyb3VwcygpO1xuICAgIHNhbml0aXplR3JvdXBzKCk7XG4gICAgZm9ybWF0U3RlbXMoKTtcblxuICAgIC8vIEdldCB0aGUgbm90ZXMgdG8gYmUgYmVhbWVkXG4gICAgdmFyIGJlYW1lZE5vdGVHcm91cHMgPSBnZXRCZWFtR3JvdXBzKCk7XG5cbiAgICAvLyBHZXQgdGhlIHR1cGxldHMgaW4gb3JkZXIgdG8gZm9ybWF0IHRoZW0gYWNjdXJhdGVseVxuICAgIHZhciB0dXBsZXRHcm91cHMgPSBnZXRUdXBsZXRHcm91cHMoKTtcblxuICAgIC8vIENyZWF0ZSBhIFZleC5GbG93LkJlYW0gZnJvbSBlYWNoIGdyb3VwIG9mIG5vdGVzIHRvIGJlIGJlYW1lZFxuICAgIHZhciBiZWFtcyA9IFtdO1xuICAgIGJlYW1lZE5vdGVHcm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCl7XG4gICAgICB2YXIgYmVhbSA9IG5ldyBWZXguRmxvdy5CZWFtKGdyb3VwKTtcblxuICAgICAgaWYgKGNvbmZpZy5zaG93X3N0ZW1sZXRzKSB7XG4gICAgICAgIGJlYW0ucmVuZGVyX29wdGlvbnMuc2hvd19zdGVtbGV0cyA9IHRydWU7XG4gICAgICB9XG4gICAgICBpZiAoY29uZmlnLnNlY29uZGFyeV9icmVha3MpIHtcbiAgICAgICAgYmVhbS5yZW5kZXJfb3B0aW9ucy5zZWNvbmRhcnlfYnJlYWtfdGlja3MgPSBWZXguRmxvdy5kdXJhdGlvblRvVGlja3MoY29uZmlnLnNlY29uZGFyeV9icmVha3MpO1xuICAgICAgfVxuICAgICAgaWYgKGNvbmZpZy5mbGF0X2JlYW1zID09PSB0cnVlKSB7XG4gICAgICAgIGJlYW0ucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtcyA9IHRydWU7XG4gICAgICAgIGJlYW0ucmVuZGVyX29wdGlvbnMuZmxhdF9iZWFtX29mZnNldCA9IGNvbmZpZy5mbGF0X2JlYW1fb2Zmc2V0O1xuICAgICAgfVxuICAgICAgYmVhbXMucHVzaChiZWFtKTtcbiAgICB9KTtcblxuICAgIC8vIFJlZm9ybWF0IHR1cGxldHNcbiAgICB0dXBsZXRHcm91cHMuZm9yRWFjaChmdW5jdGlvbihncm91cCl7XG4gICAgICB2YXIgZmlyc3ROb3RlID0gZ3JvdXBbMF07XG4gICAgICBmb3IgKHZhciBpPTA7IGk8Z3JvdXAubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgaWYgKGdyb3VwW2ldLmhhc1N0ZW0oKSkge1xuICAgICAgICAgIGZpcnN0Tm90ZSA9IGdyb3VwW2ldO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciB0dXBsZXQgPSBmaXJzdE5vdGUudHVwbGV0O1xuXG4gICAgICBpZiAoZmlyc3ROb3RlLmJlYW0pIHR1cGxldC5zZXRCcmFja2V0ZWQoZmFsc2UpO1xuICAgICAgaWYgKGZpcnN0Tm90ZS5zdGVtX2RpcmVjdGlvbiA9PSBTdGVtLkRPV04pIHtcbiAgICAgICAgdHVwbGV0LnNldFR1cGxldExvY2F0aW9uKFZleC5GbG93LlR1cGxldC5MT0NBVElPTl9CT1RUT00pO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgcmV0dXJuIGJlYW1zO1xuICB9O1xuXG4gIHJldHVybiBCZWFtO1xufSgpKTtcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBUaGlzIGZpbGUgaW1wbGVtZW50cyB0aGUgbWFpbiBWb2ljZSBjbGFzcy4gSXQncyBtYWlubHkgYSBjb250YWluZXJcbi8vIG9iamVjdCB0byBncm91cCBgVGlja2FibGVzYCBmb3IgZm9ybWF0dGluZy5cblZleC5GbG93LlZvaWNlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBWb2ljZSh0aW1lKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGltZSk7XG4gIH1cblxuICAvLyBNb2RlcyBhbGxvdyB0aGUgYWRkaXRpb24gb2YgdGlja3MgaW4gdGhyZWUgZGlmZmVyZW50IHdheXM6XG4gIC8vXG4gIC8vIFNUUklDVDogVGhpcyBpcyB0aGUgZGVmYXVsdC4gVGlja3MgbXVzdCBmaWxsIHRoZSB2b2ljZS5cbiAgLy8gU09GVDogICBUaWNrcyBjYW4gYmUgYWRkZWQgd2l0aG91dCByZXN0cmljdGlvbnMuXG4gIC8vIEZVTEw6ICAgVGlja3MgZG8gbm90IG5lZWQgdG8gZmlsbCB0aGUgdm9pY2UsIGJ1dCBjYW4ndCBleGNlZWQgdGhlIG1heGltdW1cbiAgLy8gICAgICAgICB0aWNrIGxlbmd0aC5cbiAgVm9pY2UuTW9kZSA9IHtcbiAgICBTVFJJQ1Q6IDEsXG4gICAgU09GVDogICAyLFxuICAgIEZVTEw6ICAgM1xuICB9O1xuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIFZvaWNlLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbih0aW1lKSB7XG4gICAgICB0aGlzLnRpbWUgPSBWZXguTWVyZ2Uoe1xuICAgICAgICBudW1fYmVhdHM6IDQsXG4gICAgICAgIGJlYXRfdmFsdWU6IDQsXG4gICAgICAgIHJlc29sdXRpb246IFZleC5GbG93LlJFU09MVVRJT05cbiAgICAgIH0sIHRpbWUpO1xuXG4gICAgICAvLyBSZWNhbGN1bGF0ZSB0b3RhbCB0aWNrcy5cbiAgICAgIHRoaXMudG90YWxUaWNrcyA9IG5ldyBWZXguRmxvdy5GcmFjdGlvbihcbiAgICAgICAgdGhpcy50aW1lLm51bV9iZWF0cyAqICh0aGlzLnRpbWUucmVzb2x1dGlvbiAvIHRoaXMudGltZS5iZWF0X3ZhbHVlKSwgMSk7XG5cbiAgICAgIHRoaXMucmVzb2x1dGlvbk11bHRpcGxpZXIgPSAxO1xuXG4gICAgICAvLyBTZXQgZGVmYXVsdHNcbiAgICAgIHRoaXMudGlja2FibGVzID0gW107XG4gICAgICB0aGlzLnRpY2tzVXNlZCA9IG5ldyBWZXguRmxvdy5GcmFjdGlvbigwLCAxKTtcbiAgICAgIHRoaXMuc21hbGxlc3RUaWNrQ291bnQgPSB0aGlzLnRvdGFsVGlja3MuY2xvbmUoKTtcbiAgICAgIHRoaXMubGFyZ2VzdFRpY2tXaWR0aCA9IDA7XG4gICAgICB0aGlzLnN0YXZlID0gbnVsbDtcbiAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBudWxsO1xuICAgICAgLy8gRG8gd2UgY2FyZSBhYm91dCBzdHJpY3RseSB0aW1lZCBub3Rlc1xuICAgICAgdGhpcy5tb2RlID0gVmV4LkZsb3cuVm9pY2UuTW9kZS5TVFJJQ1Q7XG5cbiAgICAgIC8vIFRoaXMgbXVzdCBiZWxvbmcgdG8gYSBWb2ljZUdyb3VwXG4gICAgICB0aGlzLnZvaWNlR3JvdXAgPSBudWxsO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgdGhlIHRvdGFsIHRpY2tzIGluIHRoZSB2b2ljZVxuICAgIGdldFRvdGFsVGlja3M6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50b3RhbFRpY2tzOyB9LFxuXG4gICAgLy8gR2V0IHRoZSB0b3RhbCB0aWNrcyB1c2VkIGluIHRoZSB2b2ljZSBieSBhbGwgdGhlIHRpY2thYmxlc1xuICAgIGdldFRpY2tzVXNlZDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRpY2tzVXNlZDsgfSxcblxuICAgIC8vIEdldCB0aGUgbGFyZ2VzdCB3aWR0aCBvZiBhbGwgdGhlIHRpY2thYmxlc1xuICAgIGdldExhcmdlc3RUaWNrV2lkdGg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5sYXJnZXN0VGlja1dpZHRoOyB9LFxuXG4gICAgLy8gR2V0IHRoZSB0aWNrIGNvdW50IGZvciB0aGUgc2hvcnRlc3QgdGlja2FibGVcbiAgICBnZXRTbWFsbGVzdFRpY2tDb3VudDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnNtYWxsZXN0VGlja0NvdW50OyB9LFxuXG4gICAgLy8gR2V0IHRoZSB0aWNrYWJsZXMgaW4gdGhlIHZvaWNlXG4gICAgZ2V0VGlja2FibGVzOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMudGlja2FibGVzOyB9LFxuXG4gICAgLy8gR2V0L3NldCB0aGUgdm9pY2UgbW9kZSwgdXNlIGEgdmFsdWUgZnJvbSBgVm9pY2UuTW9kZWBcbiAgICBnZXRNb2RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubW9kZTsgfSxcbiAgICBzZXRNb2RlOiBmdW5jdGlvbihtb2RlKSB7IHRoaXMubW9kZSA9IG1vZGU7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gR2V0IHRoZSByZXNvbHV0aW9uIG11bHRpcGxpZXIgZm9yIHRoZSB2b2ljZVxuICAgIGdldFJlc29sdXRpb25NdWx0aXBsaWVyOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucmVzb2x1dGlvbk11bHRpcGxpZXI7IH0sXG5cbiAgICAvLyBHZXQgdGhlIGFjdHVhbCB0aWNrIHJlc29sdXRpb24gZm9yIHRoZSB2b2ljZVxuICAgIGdldEFjdHVhbFJlc29sdXRpb246IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5yZXNvbHV0aW9uTXVsdGlwbGllciAqIHRoaXMudGltZS5yZXNvbHV0aW9uOyB9LFxuXG4gICAgLy8gU2V0IHRoZSB2b2ljZSdzIHN0YXZlXG4gICAgc2V0U3RhdmU6IGZ1bmN0aW9uKHN0YXZlKSB7XG4gICAgICB0aGlzLnN0YXZlID0gc3RhdmU7XG4gICAgICB0aGlzLmJvdW5kaW5nQm94ID0gbnVsbDsgLy8gUmVzZXQgYm91bmRpbmcgYm94IHNvIHdlIGNhbiByZWZvcm1hdFxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEdldCB0aGUgYm91bmRpbmcgYm94IGZvciB0aGUgdm9pY2VcbiAgICBnZXRCb3VuZGluZ0JveDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgc3RhdmUsIGJvdW5kaW5nQm94LCBiYiwgaTtcblxuICAgICAgaWYgKCF0aGlzLmJvdW5kaW5nQm94KSB7XG4gICAgICAgIGlmICghdGhpcy5zdGF2ZSkgdGhyb3cgVmV4LlJFUlIoXCJOb1N0YXZlXCIsIFwiQ2FuJ3QgZ2V0IGJvdW5kaW5nIGJveCB3aXRob3V0IHN0YXZlLlwiKTtcbiAgICAgICAgc3RhdmUgPSB0aGlzLnN0YXZlO1xuICAgICAgICBib3VuZGluZ0JveCA9IG51bGw7XG5cbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMudGlja2FibGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdGhpcy50aWNrYWJsZXNbaV0uc2V0U3RhdmUoc3RhdmUpO1xuXG4gICAgICAgICAgYmIgPSB0aGlzLnRpY2thYmxlc1tpXS5nZXRCb3VuZGluZ0JveCgpO1xuICAgICAgICAgIGlmICghYmIpIGNvbnRpbnVlO1xuXG4gICAgICAgICAgYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveCA/IGJvdW5kaW5nQm94Lm1lcmdlV2l0aChiYikgOiBiYjtcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuYm91bmRpbmdCb3ggPSBib3VuZGluZ0JveDtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmJvdW5kaW5nQm94O1xuICAgIH0sXG5cbiAgICAvLyBFdmVyeSB0aWNrYWJsZSBtdXN0IGJlIGFzc29jaWF0ZWQgd2l0aCBhIHZvaWNlR3JvdXAuIFRoaXMgYWxsb3dzIGZvcm1hdHRlcnNcbiAgICAvLyBhbmQgcHJlZm9ybWF0dGVycyB0byBhc3NvY2lhdGUgdGhlbSB3aXRoIHRoZSByaWdodCBtb2RpZmllckNvbnRleHRzLlxuICAgIGdldFZvaWNlR3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnZvaWNlR3JvdXApXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIk5vVm9pY2VHcm91cFwiLCBcIk5vIHZvaWNlIGdyb3VwIGZvciB2b2ljZS5cIik7XG4gICAgICByZXR1cm4gdGhpcy52b2ljZUdyb3VwO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIHZvaWNlIGdyb3VwXG4gICAgc2V0Vm9pY2VHcm91cDogZnVuY3Rpb24oZykgeyB0aGlzLnZvaWNlR3JvdXAgPSBnOyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIFNldCB0aGUgdm9pY2UgbW9kZSB0byBzdHJpY3Qgb3Igc29mdCBcbiAgICBzZXRTdHJpY3Q6IGZ1bmN0aW9uKHN0cmljdCkge1xuICAgICAgdGhpcy5tb2RlID0gc3RyaWN0ID8gVmV4LkZsb3cuVm9pY2UuTW9kZS5TVFJJQ1QgOiBWZXguRmxvdy5Wb2ljZS5Nb2RlLlNPRlQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gRGV0ZXJtaW5lIGlmIHRoZSB2b2ljZSBpcyBjb21wbGV0ZSBhY2NvcmRpbmcgdG8gdGhlIHZvaWNlIG1vZGVcbiAgICBpc0NvbXBsZXRlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLm1vZGUgPT0gVmV4LkZsb3cuVm9pY2UuTW9kZS5TVFJJQ1QgfHxcbiAgICAgICAgICB0aGlzLm1vZGUgPT0gVmV4LkZsb3cuVm9pY2UuTW9kZS5GVUxMKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnRpY2tzVXNlZC5lcXVhbHModGhpcy50b3RhbFRpY2tzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBBZGQgYSB0aWNrYWJsZSB0byB0aGUgdm9pY2VcbiAgICBhZGRUaWNrYWJsZTogZnVuY3Rpb24odGlja2FibGUpIHtcbiAgICAgIGlmICghdGlja2FibGUuc2hvdWxkSWdub3JlVGlja3MoKSkge1xuICAgICAgICB2YXIgdGlja3MgPSB0aWNrYWJsZS5nZXRUaWNrcygpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgdG90YWwgdGlja3MgZm9yIHRoaXMgbGluZS5cbiAgICAgICAgdGhpcy50aWNrc1VzZWQuYWRkKHRpY2tzKTtcblxuICAgICAgICBpZiAoKHRoaXMubW9kZSA9PSBWZXguRmxvdy5Wb2ljZS5Nb2RlLlNUUklDVCB8fFxuICAgICAgICAgICAgIHRoaXMubW9kZSA9PSBWZXguRmxvdy5Wb2ljZS5Nb2RlLkZVTEwpICYmXG4gICAgICAgICAgICAgdGhpcy50aWNrc1VzZWQuZ3JlYXRlclRoYW4odGhpcy50b3RhbFRpY2tzKSkge1xuICAgICAgICAgIHRoaXMudG90YWxUaWNrcy5zdWJ0cmFjdCh0aWNrcyk7XG4gICAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRcIiwgXCJUb28gbWFueSB0aWNrcy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBUcmFjayB0aGUgc21hbGxlc3QgdGlja2FibGUgZm9yIGZvcm1hdHRpbmcuXG4gICAgICAgIGlmICh0aWNrcy5sZXNzVGhhbih0aGlzLnNtYWxsZXN0VGlja0NvdW50KSkge1xuICAgICAgICAgIHRoaXMuc21hbGxlc3RUaWNrQ291bnQgPSB0aWNrcy5jbG9uZSgpO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5yZXNvbHV0aW9uTXVsdGlwbGllciA9IHRoaXMudGlja3NVc2VkLmRlbm9taW5hdG9yO1xuXG4gICAgICAgIC8vIEV4cGFuZCB0b3RhbCB0aWNrcyB1c2luZyBkZW5vbWluYXRvciBmcm9tIHRpY2tzIHVzZWQuXG4gICAgICAgIHRoaXMudG90YWxUaWNrcy5hZGQoMCwgdGhpcy50aWNrc1VzZWQuZGVub21pbmF0b3IpO1xuICAgICAgfVxuXG4gICAgICAvLyBBZGQgdGhlIHRpY2thYmxlIHRvIHRoZSBsaW5lLlxuICAgICAgdGhpcy50aWNrYWJsZXMucHVzaCh0aWNrYWJsZSk7XG4gICAgICB0aWNrYWJsZS5zZXRWb2ljZSh0aGlzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYW4gYXJyYXkgb2YgdGlja2FibGVzIHRvIHRoZSB2b2ljZS5cbiAgICBhZGRUaWNrYWJsZXM6IGZ1bmN0aW9uKHRpY2thYmxlcykge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aWNrYWJsZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdGhpcy5hZGRUaWNrYWJsZSh0aWNrYWJsZXNbaV0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUHJlZm9ybWF0cyB0aGUgdm9pY2UgYnkgYXBwbHlpbmcgdGhlIHZvaWNlJ3Mgc3RhdmUgdG8gZWFjaCBub3RlLlxuICAgIHByZUZvcm1hdDogZnVuY3Rpb24oKXtcbiAgICAgIGlmICh0aGlzLnByZUZvcm1hdHRlZCkgcmV0dXJuO1xuXG4gICAgICB0aGlzLnRpY2thYmxlcy5mb3JFYWNoKGZ1bmN0aW9uKHRpY2thYmxlKSB7XG4gICAgICAgIGlmICghdGlja2FibGUuZ2V0U3RhdmUoKSkge1xuICAgICAgICAgIHRpY2thYmxlLnNldFN0YXZlKHRoaXMuc3RhdmUpO1xuICAgICAgICB9XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSB0cnVlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbmRlciB0aGUgdm9pY2Ugb250byB0aGUgY2FudmFzIGBjb250ZXh0YCBhbmQgYW4gb3B0aW9uYWwgYHN0YXZlYC5cbiAgICAvLyBJZiBgc3RhdmVgIGlzIG9taXR0ZWQsIGl0IGlzIGV4cGVjdGVkIHRoYXQgdGhlIG5vdGVzIGhhdmUgc3RhdmVzXG4gICAgLy8gYWxyZWFkeSBzZXQuXG4gICAgZHJhdzogZnVuY3Rpb24oY29udGV4dCwgc3RhdmUpIHtcbiAgICAgIHZhciBib3VuZGluZ0JveCA9IG51bGw7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMudGlja2FibGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciB0aWNrYWJsZSA9IHRoaXMudGlja2FibGVzW2ldO1xuXG4gICAgICAgIC8vIFNldCB0aGUgc3RhdmUgaWYgcHJvdmlkZWRcbiAgICAgICAgaWYgKHN0YXZlKSB0aWNrYWJsZS5zZXRTdGF2ZShzdGF2ZSk7XG5cbiAgICAgICAgaWYgKCF0aWNrYWJsZS5nZXRTdGF2ZSgpKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJNaXNzaW5nU3RhdmVcIixcbiAgICAgICAgICAgIFwiVGhlIHZvaWNlIGNhbm5vdCBkcmF3IHRpY2thYmxlcyB3aXRob3V0IHN0YXZlcy5cIik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaSA9PT0gMCkgYm91bmRpbmdCb3ggPSB0aWNrYWJsZS5nZXRCb3VuZGluZ0JveCgpO1xuXG4gICAgICAgIGlmIChpID4gMCAmJiBib3VuZGluZ0JveCkge1xuICAgICAgICAgIHZhciB0aWNrYWJsZV9iYiA9IHRpY2thYmxlLmdldEJvdW5kaW5nQm94KCk7XG4gICAgICAgICAgaWYgKHRpY2thYmxlX2JiKSBib3VuZGluZ0JveC5tZXJnZVdpdGgodGlja2FibGVfYmIpO1xuICAgICAgICB9XG5cbiAgICAgICB0aWNrYWJsZS5zZXRDb250ZXh0KGNvbnRleHQpO1xuICAgICAgIHRpY2thYmxlLmRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5ib3VuZGluZ0JveCA9IGJvdW5kaW5nQm94O1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gVm9pY2U7XG59KCkpO1xuLy8gVmV4IE11c2ljIE5vdGF0aW9uXG4vLyBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy9cbi8vIENvcHlyaWdodCBNb2hpdCBNdXRoYW5uYSAyMDEwXG5cbi8qKiBAY29uc3RydWN0b3IgKi9cblZleC5GbG93LlZvaWNlR3JvdXAgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFZvaWNlR3JvdXAoKSB7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cblxuICBWb2ljZUdyb3VwLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMudm9pY2VzID0gW107XG4gICAgICB0aGlzLm1vZGlmaWVyQ29udGV4dHMgPSBbXTtcbiAgICB9LFxuXG4gICAgLy8gRXZlcnkgdGlja2FibGUgbXVzdCBiZSBhc3NvY2lhdGVkIHdpdGggYSB2b2ljZUdyb3VwLiBUaGlzIGFsbG93cyBmb3JtYXR0ZXJzXG4gICAgLy8gYW5kIHByZWZvcm1hdHRlcnMgdG8gYXNzb2NpYXRlIHRoZW0gd2l0aCB0aGUgcmlnaHQgbW9kaWZpZXJDb250ZXh0cy5cbiAgICBnZXRWb2ljZXM6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy52b2ljZXM7IH0sXG4gICAgZ2V0TW9kaWZpZXJDb250ZXh0czogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm1vZGlmaWVyQ29udGV4dHM7IH0sXG5cbiAgICBhZGRWb2ljZTogZnVuY3Rpb24odm9pY2UpIHtcbiAgICAgIGlmICghdm9pY2UpIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIlZvaWNlIGNhbm5vdCBiZSBudWxsLlwiKTtcbiAgICAgIHRoaXMudm9pY2VzLnB1c2godm9pY2UpO1xuICAgICAgdm9pY2Uuc2V0Vm9pY2VHcm91cCh0aGlzKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFZvaWNlR3JvdXA7XG59KCkpO1xuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBgTW9kaWZpZXJgIGlzIGFuIGFic3RyYWN0IGludGVyZmFjZSBmb3Igbm90YXRpb25hbCBlbGVtZW50cyB0aGF0IG1vZGlmeVxuLy8gYSBgTm90ZWAuIEV4YW1wbGVzIG9mIG1vZGlmaWVycyBhcmUgYEFjY2lkZW50YWxgLCBgQW5ub3RhdGlvbmAsIGBTdHJva2VgLCBldGMuXG4vL1xuLy8gRm9yIGEgYE1vZGlmaWVyYCBpbnN0YW5jZSB0byBiZSBwb3NpdGlvbmVkIGNvcnJlY3RseSwgaXQgbXVzdCBiZSBwYXJ0IG9mXG4vLyBhIGBNb2RpZmllckNvbnRleHRgLiBBbGwgbW9kaWZpZXJzIGluIHRoZSBzYW1lIGNvbnRleHQgYXJlIHJlbmRlcmVkIHJlbGF0aXZlIHRvXG4vLyBvbmUgYW5vdGhlci5cbi8vXG4vLyBUeXBpY2FsbHksIGFsbCBtb2RpZmllcnMgdG8gYSBub3RlIGFyZSBwYXJ0IG9mIHRoZSBzYW1lIGBNb2RpZmllckNvbnRleHRgIGluc3RhbmNlLiBBbHNvLFxuLy8gaW4gbXVsdGktdm9pY2Ugc3RhdmVzLCBhbGwgbW9kaWZpZXJzIHRvIG5vdGVzIG9uIHRoZSBzYW1lIGB0aWNrYCBhcmUgcGFydCBvZiB0aGUgc2FtZVxuLy8gYE1vZGlmaWVyQ29udGV4dGAuIFRoaXMgZW5zdXJlcyB0aGF0IG11bHRpcGxlIHZvaWNlcyBkb24ndCB0cmFtcGxlIGFsbCBvdmVyIGVhY2ggb3RoZXIuXG5cblZleC5GbG93Lk1vZGlmaWVyID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBNb2RpZmllcigpIHtcbiAgICB0aGlzLmNvbnN0cnVjdG9yID0gTW9kaWZpZXI7XG4gICAgdGhpcy5pbml0KCk7XG4gIH1cbiAgTW9kaWZpZXIuQ0FURUdPUlkgPSBcIm5vbmVcIjtcblxuICAgIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93Lk1vZGlmaWVyLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChNb2RpZmllci5ERUJVRykgVmV4LkwoXCJWZXguRmxvdy5Nb2RpZmllclwiLCBhcmd1bWVudHMpOyB9XG5cbiAgLy8gTW9kaWZpZXJzIGNhbiBiZSBwb3NpdGlvbmVkIGFsbW9zdCBhbnl3aGVyZSwgcmVsYXRpdmUgdG8gYSBub3RlLlxuICBNb2RpZmllci5Qb3NpdGlvbiA9IHtcbiAgICBMRUZUOiAxLFxuICAgIFJJR0hUOiAyLFxuICAgIEFCT1ZFOiAzLFxuICAgIEJFTE9XOiA0XG4gIH07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgTW9kaWZpZXIucHJvdG90eXBlID0ge1xuXG4gICAgLy8gVGhlIGNvbnN0cnVjdG9yIHNldHMgaW5pdGlhbCB3aWR0aHMgYW5kIGNvbnN0YW50cy5cbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMud2lkdGggPSAwO1xuICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgICAgLy8gTW9kaWZpZXJzIGFyZSBhdHRhY2hlZCB0byBhIG5vdGUgYW5kIGFuIGluZGV4LiBBbiBpbmRleCBpcyBhXG4gICAgICAvLyBzcGVjaWZpYyBoZWFkIGluIGEgY2hvcmQuXG4gICAgICB0aGlzLm5vdGUgPSBudWxsO1xuICAgICAgdGhpcy5pbmRleCA9IG51bGw7XG5cbiAgICAgIC8vIFRoZSBgdGV4dF9saW5lYCBpcyByZXNlcnZlZCBzcGFjZSBhYm92ZSBvciBiZWxvdyBhIHN0YXZlLlxuICAgICAgdGhpcy50ZXh0X2xpbmUgPSAwO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IE1vZGlmaWVyLlBvc2l0aW9uLkxFRlQ7XG4gICAgICB0aGlzLm1vZGlmaWVyX2NvbnRleHQgPSBudWxsO1xuICAgICAgdGhpcy54X3NoaWZ0ID0gMDtcbiAgICAgIHRoaXMueV9zaGlmdCA9IDA7XG4gICAgICB0aGlzLnNwYWNpbmdGcm9tTmV4dE1vZGlmaWVyID0gMDtcbiAgICAgIEwoXCJDcmVhdGVkIG5ldyBtb2RpZmllclwiKTtcbiAgICB9LFxuXG4gICAgLy8gRXZlcnkgbW9kaWZpZXIgaGFzIGEgY2F0ZWdvcnkuIFRoZSBgTW9kaWZpZXJDb250ZXh0YCB1c2VzIHRoaXMgdG8gZGV0ZXJtaW5lXG4gICAgLy8gdGhlIHR5cGUgYW5kIG9yZGVyIG9mIHRoZSBtb2RpZmllcnMuXG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jb25zdHJ1Y3Rvci5DQVRFR09SWTsgfSxcblxuICAgIC8vIEdldCBhbmQgc2V0IG1vZGlmaWVyIHdpZHRocy5cbiAgICBnZXRXaWR0aDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLndpZHRoOyB9LFxuICAgIHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkgeyB0aGlzLndpZHRoID0gd2lkdGg7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gR2V0IGFuZCBzZXQgYXR0YWNoZWQgbm90ZSAoYFN0YXZlTm90ZWAsIGBUYWJOb3RlYCwgZXRjLilcbiAgICBnZXROb3RlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMubm90ZTsgfSxcbiAgICBzZXROb3RlOiBmdW5jdGlvbihub3RlKSB7IHRoaXMubm90ZSA9IG5vdGU7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gR2V0IGFuZCBzZXQgbm90ZSBpbmRleCwgd2hpY2ggaXMgYSBzcGVjaWZpYyBub3RlIGluIGEgY2hvcmQuXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfSxcbiAgICBzZXRJbmRleDogZnVuY3Rpb24oaW5kZXgpIHsgdGhpcy5pbmRleCA9IGluZGV4OyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIEdldCBhbmQgc2V0IHJlbmRlcmluZyBjb250ZXh0LlxuICAgIGdldENvbnRleHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5jb250ZXh0OyB9LFxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHsgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBFdmVyeSBtb2RpZmllciBtdXN0IGJlIHBhcnQgb2YgYSBgTW9kaWZpZXJDb250ZXh0YC5cbiAgICBnZXRNb2RpZmllckNvbnRleHQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5tb2RpZmllcl9jb250ZXh0OyB9LFxuICAgIHNldE1vZGlmaWVyQ29udGV4dDogZnVuY3Rpb24oYykgeyB0aGlzLm1vZGlmaWVyX2NvbnRleHQgPSBjOyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIEdldCBhbmQgc2V0IGFydGljdWxhdGlvbiBwb3NpdGlvbi5cbiAgICBnZXRQb3NpdGlvbjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnBvc2l0aW9uOyB9LFxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbihwb3NpdGlvbikgeyB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247IHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gU2V0IHRoZSBgdGV4dF9saW5lYCBmb3IgdGhlIG1vZGlmaWVyLlxuICAgIHNldFRleHRMaW5lOiBmdW5jdGlvbihsaW5lKSB7IHRoaXMudGV4dF9saW5lID0gbGluZTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBTaGlmdCBtb2RpZmllciBkb3duIGB5YCBwaXhlbHMuIE5lZ2F0aXZlIHZhbHVlcyBzaGlmdCB1cC5cbiAgICBzZXRZU2hpZnQ6IGZ1bmN0aW9uKHkpIHsgdGhpcy55X3NoaWZ0ID0geTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICBzZXRTcGFjaW5nRnJvbU5leHRNb2RpZmllcjogZnVuY3Rpb24oeCkge1xuICAgICAgdGhpcy5zcGFjaW5nRnJvbU5leHRNb2RpZmllciA9IHg7XG4gICAgfSxcblxuICAgIGdldFNwYWNpbmdGcm9tTmV4dE1vZGlmaWVyOiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy5zcGFjaW5nRnJvbU5leHRNb2RpZmllcjsgfSxcblxuICAgIC8vIFNoaWZ0IG1vZGlmaWVyIGB4YCBwaXhlbHMgaW4gdGhlIGRpcmVjdGlvbiBvZiB0aGUgbW9kaWZpZXIuIE5lZ2F0aXZlIHZhbHVlc1xuICAgIC8vIHNoaWZ0IHJldmVyc2UuXG4gICAgc2V0WFNoaWZ0OiBmdW5jdGlvbih4KSB7XG4gICAgICB0aGlzLnhfc2hpZnQgPSAwO1xuICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gTW9kaWZpZXIuUG9zaXRpb24uTEVGVCkge1xuICAgICAgICB0aGlzLnhfc2hpZnQgLT0geDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMueF9zaGlmdCArPSB4O1xuICAgICAgfVxuICAgIH0sXG4gICAgZ2V0WFNoaWZ0OiBmdW5jdGlvbigpIHtyZXR1cm4gdGhpcy54X3NoaWZ0O30sXG5cbiAgICAvLyBSZW5kZXIgdGhlIG1vZGlmaWVyIG9udG8gdGhlIGNhbnZhcy5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgd2l0aG91dCBhIGNhbnZhcyBjb250ZXh0LlwiKTtcbiAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIk1ldGhvZE5vdEltcGxlbWVudGVkXCIsXG4gICAgICAgICAgXCJEcmF3KCkgbm90IGltcGxlbWVudGVkIGZvciB0aGlzIG1vZGlmaWVyLlwiKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIE1vZGlmaWVyO1xufSgpKTtcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBUaGlzIGNsYXNzIGltcGxlbWVudHMgdmFyaW91cyB0eXBlcyBvZiBtb2RpZmllcnMgdG8gbm90ZXMgKGUuZy4gYmVuZHMsXG4vLyBmaW5nZXJpbmcgcG9zaXRpb25zIGV0Yy4pXG5cblZleC5GbG93Lk1vZGlmaWVyQ29udGV4dCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gTW9kaWZpZXJDb250ZXh0KCkge1xuICAgIC8vIEN1cnJlbnQgbW9kaWZpZXJzXG4gICAgdGhpcy5tb2RpZmllcnMgPSB7fTtcblxuICAgIC8vIEZvcm1hdHRpbmcgZGF0YS5cbiAgICB0aGlzLnByZUZvcm1hdHRlZCA9IGZhbHNlO1xuICAgIHRoaXMucG9zdEZvcm1hdHRlZCA9IGZhbHNlO1xuICAgIHRoaXMud2lkdGggPSAwO1xuICAgIHRoaXMuc3BhY2luZyA9IDA7XG4gICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgIGxlZnRfc2hpZnQ6IDAsXG4gICAgICByaWdodF9zaGlmdDogMCxcbiAgICAgIHRleHRfbGluZTogMCxcbiAgICAgIHRvcF90ZXh0X2xpbmU6IDBcbiAgICB9O1xuXG4gICAgLy8gQWRkIG5ldyBtb2RpZmllcnMgdG8gdGhpcyBhcnJheS4gVGhlIG9yZGVyaW5nIGlzIHNpZ25pZmljYW50IC0tIGxvd2VyXG4gICAgLy8gbW9kaWZpZXJzIGFyZSBmb3JtYXR0ZWQgYW5kIHJlbmRlcmVkIGJlZm9yZSBoaWdoZXIgb25lcy5cbiAgICB0aGlzLlBSRUZPUk1BVCA9IFtcbiAgICAgIFZleC5GbG93LlN0YXZlTm90ZSxcbiAgICAgIFZleC5GbG93LkRvdCxcbiAgICAgIFZleC5GbG93LkZyZXRIYW5kRmluZ2VyLFxuICAgICAgVmV4LkZsb3cuQWNjaWRlbnRhbCxcbiAgICAgIFZleC5GbG93LkdyYWNlTm90ZUdyb3VwLFxuICAgICAgVmV4LkZsb3cuU3Ryb2tlLFxuICAgICAgVmV4LkZsb3cuU3RyaW5nTnVtYmVyLFxuICAgICAgVmV4LkZsb3cuQXJ0aWN1bGF0aW9uLFxuICAgICAgVmV4LkZsb3cuT3JuYW1lbnQsXG4gICAgICBWZXguRmxvdy5Bbm5vdGF0aW9uLFxuICAgICAgVmV4LkZsb3cuQmVuZCxcbiAgICAgIFZleC5GbG93LlZpYnJhdG9cbiAgICBdO1xuXG4gICAgLy8gSWYgcG9zdC1mb3JtYXR0aW5nIGlzIHJlcXVpcmVkIGZvciBhbiBlbGVtZW50LCBhZGQgaXQgdG8gdGhpcyBhcnJheS5cbiAgICB0aGlzLlBPU1RGT1JNQVQgPSBbIFZleC5GbG93LlN0YXZlTm90ZSBdO1xuICB9XG5cbiAgLy8gVG8gZW5hYmxlIGxvZ2dpbmcgZm9yIHRoaXMgY2xhc3MuIFNldCBgVmV4LkZsb3cuTW9kaWZpZXJDb250ZXh0LkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChNb2RpZmllckNvbnRleHQuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuTW9kaWZpZXJDb250ZXh0XCIsIGFyZ3VtZW50cyk7IH1cblxuICBNb2RpZmllckNvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGFkZE1vZGlmaWVyOiBmdW5jdGlvbihtb2RpZmllcikge1xuICAgICAgdmFyIHR5cGUgPSBtb2RpZmllci5nZXRDYXRlZ29yeSgpO1xuICAgICAgaWYgKCF0aGlzLm1vZGlmaWVyc1t0eXBlXSkgdGhpcy5tb2RpZmllcnNbdHlwZV0gPSBbXTtcbiAgICAgIHRoaXMubW9kaWZpZXJzW3R5cGVdLnB1c2gobW9kaWZpZXIpO1xuICAgICAgbW9kaWZpZXIuc2V0TW9kaWZpZXJDb250ZXh0KHRoaXMpO1xuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSBmYWxzZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRNb2RpZmllcnM6IGZ1bmN0aW9uKHR5cGUpIHsgcmV0dXJuIHRoaXMubW9kaWZpZXJzW3R5cGVdOyB9LFxuICAgIGdldFdpZHRoOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMud2lkdGg7IH0sXG4gICAgZ2V0RXh0cmFMZWZ0UHg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5zdGF0ZS5sZWZ0X3NoaWZ0OyB9LFxuICAgIGdldEV4dHJhUmlnaHRQeDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnN0YXRlLnJpZ2h0X3NoaWZ0OyB9LFxuICAgIGdldFN0YXRlOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuc3RhdGU7IH0sXG5cbiAgICBnZXRNZXRyaWNzOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5mb3JtYXR0ZWQpIHRocm93IG5ldyBWZXguUkVSUihcIlVuZm9ybWF0dGVkTW9kaWZpZXJcIixcbiAgICAgICAgICBcIlVuZm9ybWF0dGVkIG1vZGlmaWVyIGhhcyBubyBtZXRyaWNzLlwiKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgd2lkdGg6IHRoaXMuc3RhdGUubGVmdF9zaGlmdCArIHRoaXMuc3RhdGUucmlnaHRfc2hpZnQgKyB0aGlzLnNwYWNpbmcsXG4gICAgICAgIHNwYWNpbmc6IHRoaXMuc3BhY2luZyxcbiAgICAgICAgZXh0cmFfbGVmdF9weDogdGhpcy5zdGF0ZS5sZWZ0X3NoaWZ0LFxuICAgICAgICBleHRyYV9yaWdodF9weDogdGhpcy5zdGF0ZS5yaWdodF9zaGlmdFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgcHJlRm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnByZUZvcm1hdHRlZCkgcmV0dXJuO1xuICAgICAgdGhpcy5QUkVGT1JNQVQuZm9yRWFjaChmdW5jdGlvbihtb2RpZmllcikge1xuICAgICAgICBMKFwiUHJlZm9ybWF0dGluZyBNb2RpZmllckNvbnRleHQ6IFwiLCBtb2RpZmllci5DQVRFR09SWSk7XG4gICAgICAgIG1vZGlmaWVyLmZvcm1hdCh0aGlzLmdldE1vZGlmaWVycyhtb2RpZmllci5DQVRFR09SWSksIHRoaXMuc3RhdGUsIHRoaXMpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIC8vIFVwZGF0ZSB3aWR0aCBvZiB0aGlzIG1vZGlmaWVyIGNvbnRleHRcbiAgICAgIHRoaXMud2lkdGggPSB0aGlzLnN0YXRlLmxlZnRfc2hpZnQgKyB0aGlzLnN0YXRlLnJpZ2h0X3NoaWZ0O1xuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSB0cnVlO1xuICAgIH0sXG5cbiAgICBwb3N0Rm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0aGlzLnBvc3RGb3JtYXR0ZWQpIHJldHVybjtcbiAgICAgIHRoaXMuUE9TVEZPUk1BVC5mb3JFYWNoKGZ1bmN0aW9uKG1vZGlmaWVyKSB7XG4gICAgICAgIEwoXCJQb3N0Zm9ybWF0dGluZyBNb2RpZmllckNvbnRleHQ6IFwiLCBtb2RpZmllci5DQVRFR09SWSk7XG4gICAgICAgIG1vZGlmaWVyLnBvc3RGb3JtYXQodGhpcy5nZXRNb2RpZmllcnMobW9kaWZpZXIuQ0FURUdPUlkpLCB0aGlzKTtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gTW9kaWZpZXJDb250ZXh0O1xufSgpKTtcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vLyBAYXV0aG9yIE1vaGl0IENoZXBwdWRpcmFcbi8vIEBhdXRob3IgR3JlZyBSaXN0b3cgKG1vZGlmaWNhdGlvbnMpXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBUaGlzIGZpbGUgaW1wbGVtZW50cyBhY2NpZGVudGFscyBhcyBtb2RpZmllcnMgdGhhdCBjYW4gYmUgYXR0YWNoZWQgdG9cbi8vIG5vdGVzLiBTdXBwb3J0IGlzIGluY2x1ZGVkIGZvciBib3RoIHdlc3Rlcm4gYW5kIG1pY3JvdG9uYWwgYWNjaWRlbnRhbHMuXG4vL1xuLy8gU2VlIGB0ZXN0cy9hY2NpZGVudGFsX3Rlc3RzLmpzYCBmb3IgdXNhZ2UgZXhhbXBsZXMuXG5cblZleC5GbG93LkFjY2lkZW50YWwgPSAoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gQWNjaWRlbnRhbCh0eXBlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodHlwZSk7XG4gIH1cbiAgQWNjaWRlbnRhbC5DQVRFR09SWSA9IFwiYWNjaWRlbnRhbHNcIjtcblxuICAvLyBUbyBlbmFibGUgbG9nZ2luZyBmb3IgdGhpcyBjbGFzcy4gU2V0IGBWZXguRmxvdy5BY2NpZGVudGFsLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChBY2NpZGVudGFsLkRFQlVHKSBWZXguTChcIlZleC5GbG93LkFjY2lkZW50YWxcIiwgYXJndW1lbnRzKTsgfVxuXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xuXG4gIC8vICMjIFN0YXRpYyBNZXRob2RzXG4gIC8vXG4gIC8vIEFycmFuZ2UgYWNjaWRlbnRhbHMgaW5zaWRlIGEgTW9kaWZpZXJDb250ZXh0LlxuICBBY2NpZGVudGFsLmZvcm1hdCA9IGZ1bmN0aW9uKGFjY2lkZW50YWxzLCBzdGF0ZSkge1xuICAgIHZhciBsZWZ0X3NoaWZ0ID0gc3RhdGUubGVmdF9zaGlmdDtcbiAgICB2YXIgYWNjaWRlbnRhbF9zcGFjaW5nID0gMjtcblxuICAgIC8vIElmIHRoZXJlIGFyZSBubyBhY2NpZGVudGFscywgd2UgbmVlZG4ndCBmb3JtYXQgdGhlaXIgcG9zaXRpb25zXG4gICAgaWYgKCFhY2NpZGVudGFscyB8fCBhY2NpZGVudGFscy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgIHZhciBhY2NfbGlzdCA9IFtdO1xuICAgIHZhciBoYXNTdGF2ZSA9IGZhbHNlO1xuICAgIHZhciBwcmV2X25vdGUgPSBudWxsO1xuICAgIHZhciBzaGlmdEwgPSAwO1xuXG4gICAgLy8gRmlyc3QgZGV0ZXJtaW5lIHRoZSBhY2NpZGVudGFscycgWSBwb3NpdGlvbnMgZnJvbSB0aGUgbm90ZS5rZXlzXG4gICAgdmFyIGksIGFjYywgcHJvcHNfdG1wO1xuICAgIGZvciAoaSA9IDA7IGkgPCBhY2NpZGVudGFscy5sZW5ndGg7ICsraSkge1xuICAgICAgYWNjID0gYWNjaWRlbnRhbHNbaV07XG4gICAgICB2YXIgbm90ZSA9IGFjYy5nZXROb3RlKCk7XG4gICAgICB2YXIgc3RhdmUgPSBub3RlLmdldFN0YXZlKCk7XG4gICAgICB2YXIgcHJvcHMgPSBub3RlLmdldEtleVByb3BzKClbYWNjLmdldEluZGV4KCldO1xuICAgICAgaWYgKG5vdGUgIT0gcHJldl9ub3RlKSB7XG4gICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIG5vdGVzIHRvIGdldCB0aGUgZGlzcGxhY2VkIHBpeGVsc1xuICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub3RlLmtleXMubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICAgIHByb3BzX3RtcCA9IG5vdGUuZ2V0S2V5UHJvcHMoKVtuXTtcbiAgICAgICAgICAgIHNoaWZ0TCA9IChwcm9wc190bXAuZGlzcGxhY2VkID8gbm90ZS5nZXRFeHRyYUxlZnRQeCgpIDogc2hpZnRMKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldl9ub3RlID0gbm90ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF2ZSAhPT0gbnVsbCkge1xuICAgICAgICBoYXNTdGF2ZSA9IHRydWU7XG4gICAgICAgIHZhciBsaW5lX3NwYWNlID0gc3RhdmUub3B0aW9ucy5zcGFjaW5nX2JldHdlZW5fbGluZXNfcHg7XG4gICAgICAgIHZhciB5ID0gc3RhdmUuZ2V0WUZvckxpbmUocHJvcHMubGluZSk7XG4gICAgICAgIHZhciBhY2NfbGluZSA9IE1hdGgucm91bmQoeSAvIGxpbmVfc3BhY2UgKiAyKS8yO1xuICAgICAgICBhY2NfbGlzdC5wdXNoKHsgeTogeSwgbGluZTogYWNjX2xpbmUsIHNoaWZ0OiBzaGlmdEwsIGFjYzogYWNjLCBsaW5lU3BhY2U6IGxpbmVfc3BhY2UgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY2NfbGlzdC5wdXNoKHsgbGluZTogcHJvcHMubGluZSwgc2hpZnQ6IHNoaWZ0TCwgYWNjOiBhY2MgfSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gU29ydCBhY2NpZGVudGFscyBieSBsaW5lIG51bWJlci5cbiAgICBhY2NfbGlzdC5zb3J0KGZ1bmN0aW9uKGEsIGIpIHsgcmV0dXJuIChiLmxpbmUgLSBhLmxpbmUpOyB9KTtcblxuICAgIC8vIENyZWF0ZSBhbiBhcnJheSBvZiB1bmlxdWUgbGluZSBudW1iZXJzIChsaW5lX2xpc3QpIGZyb20gYWNjX2xpc3RcbiAgICB2YXIgbGluZV9saXN0ID0gW107IC8vIGFuIGFycmF5IG9mIHVuaXF1ZSBsaW5lIG51bWJlcnNcbiAgICB2YXIgYWNjX3NoaWZ0ID0gMDsgLy8gYW1vdW50IGJ5IHdoaWNoIGFsbCBhY2NpZGVudGFscyBtdXN0IGJlIHNoaWZ0ZWQgcmlnaHQgb3IgbGVmdCBmb3Igc3RlbSBmbGlwcGluZywgbm90ZWhlYWQgc2hpZnRpbmcgY29uY2VybnMuXG4gICAgdmFyIHByZXZpb3VzX2xpbmUgPSBudWxsO1xuXG4gICAgZm9yKGkgPSAwOyBpPGFjY19saXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBhY2MgPSBhY2NfbGlzdFtpXTtcblxuICAgICAgLy8gaWYgdGhpcyBpcyB0aGUgZmlyc3QgbGluZSwgb3IgYSBuZXcgbGluZSwgYWRkIGEgbGluZV9saXN0XG4gICAgICBpZiggKHByZXZpb3VzX2xpbmUgPT09IG51bGwpIHx8IChwcmV2aW91c19saW5lICE9IGFjYy5saW5lKSApIHtcbiAgICAgICAgbGluZV9saXN0LnB1c2goe2xpbmUgOiBhY2MubGluZSwgZmxhdF9saW5lIDogdHJ1ZSwgZGJsX3NoYXJwX2xpbmU6IHRydWUsIG51bV9hY2MgOiAwLCB3aWR0aCA6IDB9KTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoaXMgYWNjaWRlbnRhbCBpcyBub3QgYSBmbGF0LCB0aGUgYWNjaWRlbnRhbCBuZWVkcyAzLjAgbGluZXMgbG93ZXJcbiAgICAgIC8vIGNsZWFyYW5jZSBpbnN0ZWFkIG9mIDIuNSBsaW5lcyBmb3IgYiBvciBiYi5cbiAgICAgIGlmKCAoYWNjLmFjYy50eXBlICE9IFwiYlwiKSAmJiAoYWNjLmFjYy50eXBlICE9XCJiYlwiKSApIHtcbiAgICAgICAgbGluZV9saXN0W2xpbmVfbGlzdC5sZW5ndGggLSAxXS5mbGF0X2xpbmUgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIGlmIHRoaXMgYWNjaWRlbnRhbCBpcyBub3QgYSBkb3VibGUgc2hhcnAsIHRoZSBhY2NpZGVudGFsIG5lZWRzIDMuMCBsaW5lcyBhYm92ZVxuICAgICAgaWYoIGFjYy5hY2MudHlwZSAhPSBcIiMjXCIpXG4gICAgICAgIGxpbmVfbGlzdFtsaW5lX2xpc3QubGVuZ3RoIC0gMV0uZGJsX3NoYXJwX2xpbmUgPSBmYWxzZTtcblxuICAgICAgLy8gVHJhY2sgaG93IG1hbnkgYWNjaWRlbnRhbHMgYXJlIG9uIHRoaXMgbGluZTpcbiAgICAgIGxpbmVfbGlzdFtsaW5lX2xpc3QubGVuZ3RoIC0gMV0ubnVtX2FjYysrO1xuXG4gICAgICAvLyBUcmFjayB0aGUgdG90YWwgeF9vZmZzZXQgbmVlZGVkIGZvciB0aGlzIGxpbmUgd2hpY2ggd2lsbCBiZSBuZWVkZWRcbiAgICAgIC8vIGZvciBmb3JtYXR0aW5nIGxpbmVzIHcvIG11bHRpcGxlIGFjY2lkZW50YWxzOlxuXG4gICAgICAvL3dpZHRoID0gYWNjaWRlbnRhbCB3aWR0aCArIHVuaXZlcnNhbCBzcGFjaW5nIGJldHdlZW4gYWNjaWRlbnRhbHNcbiAgICAgIGxpbmVfbGlzdFtsaW5lX2xpc3QubGVuZ3RoIC0gMV0ud2lkdGggKz0gYWNjLmFjYy5nZXRXaWR0aCgpICsgYWNjaWRlbnRhbF9zcGFjaW5nO1xuXG4gICAgICAvLyBpZiB0aGlzIGFjY19zaGlmdCBpcyBsYXJnZXIsIHVzZSBpdCB0byBrZWVwIGZpcnN0IGNvbHVtbiBhY2NpZGVudGFscyBpbiB0aGUgc2FtZSBsaW5lXG4gICAgICBhY2Nfc2hpZnQgPSAoIChhY2Muc2hpZnQgPiBhY2Nfc2hpZnQpID8gYWNjLnNoaWZ0IDogYWNjX3NoaWZ0KTtcblxuICAgICAgcHJldmlvdXNfbGluZSA9IGFjYy5saW5lO1xuICAgIH1cblxuICAgIC8vICMjIyBQbGFjZSBBY2NpZGVudGFscyBpbiBDb2x1bW5zXG4gICAgLy9cbiAgICAvLyBEZWZhdWx0IHRvIGEgY2xhc3NpYyB0cmlhbmd1bGFyIGxheW91dCAobWlkZGxlIGFjY2lkZW50YWwgZmFydGhlc3QgbGVmdCksXG4gICAgLy8gYnV0IGZvbGxvdyBleGNlcHRpb25zIGFzIG91dGxpbmVkIGluIEcuIFJlYWQncyBfTXVzaWMgTm90YXRpb25fIGFuZFxuICAgIC8vIEVsYWluZSBHb3VsZCdzIF9CZWhpbmQgQmFyc18uXG4gICAgLy9cbiAgICAvLyBBZGRpdGlvbmFsbHksIHRoaXMgaW1wbGVtZW50cyBkaWZmZXJlbnQgdmVydGljYWwgY29saXNzaW9uIHJ1bGVzIGZvclxuICAgIC8vIGZsYXRzIChvbmx5IG5lZWQgMi41IGxpbmVzIGNsZWFyYW5jZSBiZWxvdykgYW5kIGRvdWJsZSBzaGFycHMgKG9ubHlcbiAgICAvLyBuZWVkIDIuNSBsaW5lcyBvZiBjbGVhcmFuY2UgYWJvdmUgb3IgYmVsb3cpLlxuICAgIC8vXG4gICAgLy8gQ2xhc3NpYyBsYXlvdXRzIGFuZCBleGNlcHRpb24gcGF0dGVybnMgYXJlIGZvdW5kIGluIHRoZSAndGFibGVzLmpzJ1xuICAgIC8vIGluICdWZXguRmxvdy5hY2NpZGVudGFsQ29sdW1uc1RhYmxlJ1xuICAgIC8vXG4gICAgLy8gQmV5b25kIDYgdmVydGljYWwgYWNjaWRlbnRhbHMsIGRlZmF1bHQgdG8gdGhlIHBhcmFsbGVsIGFzY2VuZGluZyBsaW5lcyBhcHByb2FjaCxcbiAgICAvLyB1c2luZyBhcyBmZXcgY29sdW1ucyBhcyBwb3NzaWJsZSBmb3IgdGhlIHZlcnRpY2xlIHN0cnVjdHVyZS5cbiAgICAvL1xuICAgIC8vIFRPRE8gKD8pOiBBbGxvdyBjb2x1bW4gdG8gYmUgc3BlY2lmaWVkIGZvciBhbiBhY2NpZGVudGFsIGF0IHJ1bi10aW1lP1xuXG4gICAgdmFyIHRvdGFsX2NvbHVtbnMgPSAwO1xuXG4gICAgLy8gZXN0YWJsaXNoIHRoZSBib3VuZGFyaWVzIGZvciBhIGdyb3VwIG9mIG5vdGVzIHdpdGggY2xhc2hpbmcgYWNjaWRlbnRhbHM6XG4gICAgZm9yKGkgPSAwOyBpPGxpbmVfbGlzdC5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIG5vX2Z1cnRoZXJfY29uZmxpY3RzID0gZmFsc2U7XG4gICAgICB2YXIgZ3JvdXBfc3RhcnQgPSBpO1xuICAgICAgdmFyIGdyb3VwX2VuZCA9IGk7XG5cbiAgICAgIGdyb3VwX2NoZWNrX3doaWxlIDogd2hpbGUoIChncm91cF9lbmQrMSA8IGxpbmVfbGlzdC5sZW5ndGgpICYmICghbm9fZnVydGhlcl9jb25mbGljdHMpICkge1xuICAgICAgICAvLyBpZiB0aGlzIG5vdGUgY29uZmxpY3RzIHdpdGggdGhlIG5leHQ6XG4gICAgICAgIGlmKHRoaXMuY2hlY2tDb2xsaXNpb24obGluZV9saXN0W2dyb3VwX2VuZF0sIGxpbmVfbGlzdFtncm91cF9lbmQgKyAxXSkpIHtcbiAgICAgICAgLy8gaW5jbHVkZSB0aGUgbmV4dCBub3RlIGluIHRoZSBncm91cDpcbiAgICAgICAgICBncm91cF9lbmQrKztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIG5vX2Z1cnRoZXJfY29uZmxpY3RzID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IGNvbHVtbnMgZm9yIHRoZSBsaW5lcyBpbiB0aGlzIGdyb3VwOlxuICAgICAgdmFyIGdyb3VwX2xlbmd0aCA9IGdyb3VwX2VuZCAtIGdyb3VwX3N0YXJ0ICsgMTtcblxuICAgICAgLy8gU2V0IHRoZSBhY2NpZGVudGFsIGNvbHVtbiBmb3IgZWFjaCBsaW5lIG9mIHRoZSBncm91cFxuICAgICAgdmFyIGVuZF9jYXNlID0gKHRoaXMuY2hlY2tDb2xsaXNpb24obGluZV9saXN0W2dyb3VwX3N0YXJ0XSwgbGluZV9saXN0W2dyb3VwX2VuZF0pKSA/IFwiYVwiIDogXCJiXCI7XG5cblxuICAgICAgICB2YXIgY2hlY2tDb2xsaXNpb24gPSB0aGlzLmNoZWNrQ29sbGlzaW9uO1xuICAgICAgICBzd2l0Y2goZ3JvdXBfbGVuZ3RoKSB7XG4gICAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgaWYoIChlbmRfY2FzZSA9PSBcImFcIikgJiZcbiAgICAgICAgICAgICAgICAobGluZV9saXN0W2dyb3VwX3N0YXJ0KzFdLmxpbmUgLSBsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrMl0ubGluZSA9PSAwLjUpICYmXG4gICAgICAgICAgICAgICAgKGxpbmVfbGlzdFtncm91cF9zdGFydF0ubGluZSAtIGxpbmVfbGlzdFtncm91cF9zdGFydCArIDFdLmxpbmUgIT0gMC41KSApXG4gICAgICAgICAgICAgIGVuZF9jYXNlID0gXCJzZWNvbmRfb25fYm90dG9tXCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNDpcbiAgICAgICAgICAgIGlmKCAoIWNoZWNrQ29sbGlzaW9uKGxpbmVfbGlzdFtncm91cF9zdGFydF0sIGxpbmVfbGlzdFtncm91cF9zdGFydCsyXSkpICYmXG4gICAgICAgICAgICAgICAgKCFjaGVja0NvbGxpc2lvbihsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrMV0sIGxpbmVfbGlzdFtncm91cF9zdGFydCszXSkpIClcbiAgICAgICAgICAgICAgZW5kX2Nhc2UgPSBcInNwYWNlZF9vdXRfdGV0cmFjaG9yZFwiO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDU6XG4gICAgICAgICAgICBpZiggKGVuZF9jYXNlID09IFwiYlwiKSAmJlxuICAgICAgICAgICAgICAgICghY2hlY2tDb2xsaXNpb24obGluZV9saXN0W2dyb3VwX3N0YXJ0KzFdLCBsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrM10pKSApXG4gICAgICAgICAgICAgIGVuZF9jYXNlID0gXCJzcGFjZWRfb3V0X3BlbnRhY2hvcmRcIjtcbiAgICAgICAgICAgIGlmKCAoZW5kX2Nhc2UgPT0gXCJzcGFjZWRfb3V0X3BlbnRhY2hvcmRcIikgJiZcbiAgICAgICAgICAgICAgICAoIWNoZWNrQ29sbGlzaW9uKGxpbmVfbGlzdFtncm91cF9zdGFydF0sIGxpbmVfbGlzdFtncm91cF9zdGFydCsyXSkpICYmXG4gICAgICAgICAgICAgICAgKCFjaGVja0NvbGxpc2lvbihsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrMl0sIGxpbmVfbGlzdFtncm91cF9zdGFydCs0XSkpIClcbiAgICAgICAgICAgICAgZW5kX2Nhc2UgPSBcInZlcnlfc3BhY2VkX291dF9wZW50YWNob3JkXCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgNjpcbiAgICAgICAgICAgIGlmKCAoIWNoZWNrQ29sbGlzaW9uKGxpbmVfbGlzdFtncm91cF9zdGFydF0sIGxpbmVfbGlzdFtncm91cF9zdGFydCszXSkpICYmXG4gICAgICAgICAgICAgICAgKCFjaGVja0NvbGxpc2lvbihsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrMV0sIGxpbmVfbGlzdFtncm91cF9zdGFydCs0XSkpICYmXG4gICAgICAgICAgICAgICAgKCFjaGVja0NvbGxpc2lvbihsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrMl0sIGxpbmVfbGlzdFtncm91cF9zdGFydCs1XSkpIClcbiAgICAgICAgICAgICAgZW5kX2Nhc2UgPSBcInNwYWNlZF9vdXRfaGV4YWNob3JkXCI7XG4gICAgICAgICAgICBpZiggKCFjaGVja0NvbGxpc2lvbihsaW5lX2xpc3RbZ3JvdXBfc3RhcnRdLCBsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrMl0pKSAmJlxuICAgICAgICAgICAgICAgICghY2hlY2tDb2xsaXNpb24obGluZV9saXN0W2dyb3VwX3N0YXJ0KzJdLCBsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrNF0pKSAmJlxuICAgICAgICAgICAgICAgICghY2hlY2tDb2xsaXNpb24obGluZV9saXN0W2dyb3VwX3N0YXJ0KzFdLCBsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrM10pKSAmJlxuICAgICAgICAgICAgICAgICghY2hlY2tDb2xsaXNpb24obGluZV9saXN0W2dyb3VwX3N0YXJ0KzNdLCBsaW5lX2xpc3RbZ3JvdXBfc3RhcnQrNV0pKSApXG4gICAgICAgICAgICAgIGVuZF9jYXNlID0gXCJ2ZXJ5X3NwYWNlZF9vdXRfaGV4YWNob3JkXCI7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgIHZhciBncm91cF9tZW1iZXI7XG4gICAgICB2YXIgY29sdW1uO1xuICAgICAgLy8gSWYgdGhlIGdyb3VwIGNvbnRhaW5zIG1vcmUgdGhhbiBzZXZlbiBtZW1iZXJzLCB1c2UgYXNjZW5kaW5nIHBhcmFsbGVsIGxpbmVzXG4gICAgICAvLyBvZiBhY2NpZGVudGFscywgdXNpbmcgYXMgZmV3IGNvbHVtbnMgYXMgcG9zc2libGUgd2hpbGUgYXZvaWRpbmcgY29sbGlzaW9ucy5cbiAgICAgIGlmIChncm91cF9sZW5ndGg+PTcpIHtcbiAgICAgICAgLy8gRmlyc3QsIGRldGVybWluZSBob3cgbWFueSBjb2x1bW5zIHRvIHVzZTpcbiAgICAgICAgdmFyIHBhdHRlcm5fbGVuZ3RoID0gMjtcbiAgICAgICAgdmFyIGNvbGlzc2lvbl9kZXRlY3RlZCA9IHRydWU7XG4gICAgICAgIHdoaWxlKGNvbGlzc2lvbl9kZXRlY3RlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgIGNvbGlzc2lvbl9kZXRlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgIGNvbGlzc2lvbl9kZXRlY3RlciA6IGZvcih2YXIgbGluZSA9IDA7IGxpbmUgKyBwYXR0ZXJuX2xlbmd0aCA8IGxpbmVfbGlzdC5sZW5ndGg7IGxpbmUrKykge1xuICAgICAgICAgICAgaWYodGhpcy5jaGVja0NvbGxpc2lvbihsaW5lX2xpc3RbbGluZV0sIGxpbmVfbGlzdFtsaW5lK3BhdHRlcm5fbGVuZ3RoXSkpIHtcbiAgICAgICAgICAgICAgY29saXNzaW9uX2RldGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgcGF0dGVybl9sZW5ndGgrKztcbiAgICAgICAgICAgICAgYnJlYWsgY29saXNzaW9uX2RldGVjdGVyO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBUaGVuLCBhc3NpZ24gYSBjb2x1bW4gdG8gZWFjaCBsaW5lIG9mIGFjY2lkZW50YWxzXG4gICAgICAgIGZvcihncm91cF9tZW1iZXIgPSBpOyBncm91cF9tZW1iZXIgPD0gZ3JvdXBfZW5kOyBncm91cF9tZW1iZXIrKykge1xuICAgICAgICAgIGNvbHVtbiA9ICgoZ3JvdXBfbWVtYmVyLWkpICUgcGF0dGVybl9sZW5ndGgpICsgMTtcbiAgICAgICAgICBsaW5lX2xpc3RbZ3JvdXBfbWVtYmVyXS5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgdG90YWxfY29sdW1ucyA9ICh0b3RhbF9jb2x1bW5zID4gY29sdW1uKSA/IHRvdGFsX2NvbHVtbnMgOiBjb2x1bW47XG4gICAgICAgIH1cblxuICAgICAgLy8gT3RoZXJ3aXNlLCBpZiB0aGUgZ3JvdXAgY29udGFpbnMgZmV3ZXIgdGhhbiBzZXZlbiBtZW1iZXJzLCB1c2UgdGhlIGxheW91dHMgZnJvbVxuICAgICAgLy8gdGhlIGFjY2lkZW50YWxzQ29sdW1uc1RhYmxlIGhvdXNlZCBpbiB0YWJsZXMuanMuXG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IoZ3JvdXBfbWVtYmVyID0gaTsgZ3JvdXBfbWVtYmVyIDw9IGdyb3VwX2VuZDsgZ3JvdXBfbWVtYmVyKyspIHtcbiAgICAgICAgICBjb2x1bW4gPSBWZXguRmxvdy5hY2NpZGVudGFsQ29sdW1uc1RhYmxlW2dyb3VwX2xlbmd0aF1bZW5kX2Nhc2VdW2dyb3VwX21lbWJlci1pXTtcbiAgICAgICAgICBsaW5lX2xpc3RbZ3JvdXBfbWVtYmVyXS5jb2x1bW4gPSBjb2x1bW47XG4gICAgICAgICAgdG90YWxfY29sdW1ucyA9ICh0b3RhbF9jb2x1bW5zID4gY29sdW1uKSA/IHRvdGFsX2NvbHVtbnMgOiBjb2x1bW47XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gSW5jcmVtZW50IGkgdG8gdGhlIGxhc3Qgbm90ZSB0aGF0IHdhcyBzZXQsIHNvIHRoYXQgaWYgYSBsb3dlciBzZXQgb2Ygbm90ZXNcbiAgICAgIC8vIGRvZXMgbm90IGNvbmZsaWN0IGF0IGFsbCB3aXRoIHRoaXMgZ3JvdXAsIGl0IGNhbiBoYXZlIGl0cyBvd24gY2xhc3NpYyBzaGFwZS5cbiAgICAgIGkgPSBncm91cF9lbmQ7XG4gICAgfVxuXG4gICAgLy8gIyMjIENvbnZlcnQgQ29sdW1ucyB0byB4X29mZnNldHNcbiAgICAvL1xuICAgIC8vIFRoaXMga2VlcHMgY29sdW1ucyBhbGlnbmVkLCBldmVuIGlmIHRoZXkgaGF2ZSBkaWZmZXJlbnQgYWNjaWRlbnRhbHMgd2l0aGluIHRoZW1cbiAgICAvLyB3aGljaCBzb21ldGltZXMgcmVzdWx0cyBpbiBhIGxhcmdlciB4X29mZnNldCB0aGFuIGlzIGFuIGFjY2lkZW50YWwgbWlnaHQgbmVlZFxuICAgIC8vIHRvIHByZXNlcnZlIHRoZSBzeW1tZXRyeSBvZiB0aGUgYWNjaWRlbnRhbCBzaGFwZS5cbiAgICAvL1xuICAgIC8vIE5laXRoZXIgQS5DLiBWaW5jaSBub3IgRy4gUmVhZCBhZGRyZXNzIHRoaXMsIGFuZCBpdCB0eXBpY2FsbHkgb25seSBoYXBwZW5zIGluXG4gICAgLy8gbXVzaWMgd2l0aCBjb21wbGV4IGNob3JkIGNsdXN0ZXJzLlxuICAgIC8vXG4gICAgLy8gVE9ETyAoPyk6IE9wdGlvbmFsbHkgYWxsb3cgY2xvc2VyIGNvbXByZXNzaW9uIG9mIGFjY2lkZW50YWxzLCBpbnN0ZWFkIG9mIGZvcmNpbmdcbiAgICAvLyBwYXJhbGxlbCBjb2x1bW5zLlxuXG4gICAgLy8gdHJhY2sgZWFjaCBjb2x1bW4ncyBtYXggd2lkdGgsIHdoaWNoIHdpbGwgYmUgdXNlZCBhcyBpbml0aWFsIHNoaWZ0IG9mIGxhdGVyIGNvbHVtbnM6XG4gICAgdmFyIGNvbHVtbl93aWR0aHMgPSBbXTtcbiAgICB2YXIgY29sdW1uX3hfb2Zmc2V0cyA9IFtdO1xuICAgIGZvcihpPTA7IGk8PXRvdGFsX2NvbHVtbnM7IGkrKykge1xuICAgICAgY29sdW1uX3dpZHRoc1tpXSA9IDA7XG4gICAgICBjb2x1bW5feF9vZmZzZXRzW2ldID0gMDtcbiAgICB9XG5cbiAgICBjb2x1bW5fd2lkdGhzWzBdID0gYWNjX3NoaWZ0ICsgbGVmdF9zaGlmdDtcbiAgICBjb2x1bW5feF9vZmZzZXRzWzBdID0gYWNjX3NoaWZ0ICsgbGVmdF9zaGlmdDtcblxuICAgIC8vIEZpbGwgY29sdW1uX3dpZHRocyB3aXRoIHdpZGVzdCBuZWVkZWQgeC1zcGFjZTtcbiAgICAvLyB0aGlzIGlzIHdoYXQga2VlcHMgdGhlIGNvbHVtbnMgcGFyYWxsZWwuXG4gICAgbGluZV9saXN0LmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgaWYobGluZS53aWR0aCA+IGNvbHVtbl93aWR0aHNbbGluZS5jb2x1bW5dKSBjb2x1bW5fd2lkdGhzW2xpbmUuY29sdW1uXSA9IGxpbmUud2lkdGg7XG4gICAgfSk7XG5cbiAgICBmb3IoaT0xOyBpPGNvbHVtbl93aWR0aHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIC8vIHRoaXMgY29sdW1uJ3Mgb2Zmc2V0ID0gdGhpcyBjb2x1bW4ncyB3aWR0aCArIHByZXZpb3VzIGNvbHVtbidzIG9mZnNldFxuICAgICAgY29sdW1uX3hfb2Zmc2V0c1tpXSA9IGNvbHVtbl93aWR0aHNbaV0gKyBjb2x1bW5feF9vZmZzZXRzW2ktMV07XG4gICAgfVxuXG4gICAgdmFyIHRvdGFsX3NoaWZ0ID0gY29sdW1uX3hfb2Zmc2V0c1tjb2x1bW5feF9vZmZzZXRzLmxlbmd0aC0xXTtcbiAgICAvLyBTZXQgdGhlIHhfc2hpZnQgZm9yIGVhY2ggYWNjaWRlbnRhbCBhY2NvcmRpbmcgdG8gY29sdW1uIG9mZnNldHM6XG4gICAgdmFyIGFjY19jb3VudCA9IDA7XG4gICAgbGluZV9saXN0LmZvckVhY2goZnVuY3Rpb24obGluZSkge1xuICAgICAgdmFyIGxpbmVfd2lkdGggPSAwO1xuICAgICAgdmFyIGxhc3RfYWNjX29uX2xpbmUgPSBhY2NfY291bnQgKyBsaW5lLm51bV9hY2M7XG4gICAgICAvLyBoYW5kbGUgYWxsIG9mIHRoZSBhY2NpZGVudGFscyBvbiBhIGdpdmVuIGxpbmU6XG4gICAgICBmb3IoYWNjX2NvdW50OyBhY2NfY291bnQ8bGFzdF9hY2Nfb25fbGluZTsgYWNjX2NvdW50KyspIHtcbiAgICAgICAgdmFyIHhfc2hpZnQgPSAoY29sdW1uX3hfb2Zmc2V0c1tsaW5lLmNvbHVtbi0xXSArIGxpbmVfd2lkdGgpO1xuICAgICAgICBhY2NfbGlzdFthY2NfY291bnRdLmFjYy5zZXRYU2hpZnQoeF9zaGlmdCk7XG4gICAgICAgIC8vIGtlZXAgdHJhY2sgb2YgdGhlIHdpZHRoIG9mIGFjY2lkZW50YWxzIHdlJ3ZlIGFkZGVkIHNvIGZhciwgc28gdGhhdCB3aGVuXG4gICAgICAgIC8vIHdlIGxvb3AsIHdlIGFkZCBzcGFjZSBmb3IgdGhlbS5cbiAgICAgICAgbGluZV93aWR0aCArPSBhY2NfbGlzdFthY2NfY291bnRdLmFjYy5nZXRXaWR0aCgpICsgYWNjaWRlbnRhbF9zcGFjaW5nO1xuICAgICAgICBMKFwiTGluZSwgYWNjX2NvdW50LCBzaGlmdDogXCIsIGxpbmUubGluZSwgYWNjX2NvdW50LCB4X3NoaWZ0KTtcbiAgICAgIH1cbiAgICB9KTtcblxuICAgIC8vIHVwZGF0ZSB0aGUgb3ZlcmFsbCBsYXlvdXQgd2l0aCB0aGUgZnVsbCB3aWR0aCBvZiB0aGUgYWNjaWRlbnRhbCBzaGFwZXM6XG4gICAgc3RhdGUubGVmdF9zaGlmdCArPSB0b3RhbF9zaGlmdDtcbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdHdvIGxpbmVzIG9mIGFjY2lkZW50YWxzIGNvbGxpZGUgdmVydGljYWxseVxuICBBY2NpZGVudGFsLmNoZWNrQ29sbGlzaW9uID0gZnVuY3Rpb24obGluZV8xLCBsaW5lXzIpIHtcbiAgICB2YXIgY2xlYXJhbmNlID0gbGluZV8yLmxpbmUgLSBsaW5lXzEubGluZTtcbiAgICB2YXIgY2xlYXJhbmNlX3JlcXVpcmVkID0gMztcbiAgICAvLyBCdXQgbGVzcyBjbGVhcmFuY2UgaXMgcmVxdWlyZWQgZm9yIGNlcnRhaW4gYWNjaWRlbnRhbHM6IGIsIGJiIGFuZCAjIy5cbiAgICBpZihjbGVhcmFuY2U+MCkgeyAvLyB0aGVuIGxpbmUgMiBpcyBvbiB0b3BcbiAgICAgIGNsZWFyYW5jZV9yZXF1aXJlZCA9IChsaW5lXzIuZmxhdF9saW5lIHx8IGxpbmVfMi5kYmxfc2hhcnBfbGluZSkgPyAyLjUgOiAzLjA7XG4gICAgICBpZihsaW5lXzEuZGJsX3NoYXJwX2xpbmUpIGNsZWFyYW5jZSAtPSAwLjU7XG4gICAgfSBlbHNlIHsgLy8gbGluZSAxIGlzIG9uIHRvcFxuICAgICAgY2xlYXJhbmNlX3JlcXVpcmVkID0gKGxpbmVfMS5mbGF0X2xpbmUgfHwgbGluZV8xLmRibF9zaGFycF9saW5lKSA/IDIuNSA6IDMuMDtcbiAgICAgIGlmKGxpbmVfMi5kYmxfc2hhcnBfbGluZSkgY2xlYXJhbmNlIC09IDAuNTtcbiAgICB9XG4gICAgdmFyIGNvbGlzc2lvbiA9IChNYXRoLmFicyhjbGVhcmFuY2UpIDwgY2xlYXJhbmNlX3JlcXVpcmVkKTtcbiAgICBMKFwiTGluZV8xLCBMaW5lXzIsIENvbGxpc2lvbjogXCIsIGxpbmVfMS5saW5lLCBsaW5lXzIubGluZSwgY29saXNzaW9uKTtcbiAgICByZXR1cm4oY29saXNzaW9uKTtcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICAvL1xuICAvLyBBbiBgQWNjaWRlbnRhbGAgaW5oZXJpdHMgZnJvbSBgTW9kaWZpZXJgLCBhbmQgaXMgZm9ybWF0dGVkIHdpdGhpbiBhXG4gIC8vIGBNb2RpZmllckNvbnRleHRgLlxuICBWZXguSW5oZXJpdChBY2NpZGVudGFsLCBNb2RpZmllciwge1xuICAgIC8vIENyZWF0ZSBhY2NpZGVudGFsLiBgdHlwZWAgY2FuIGJlIGEgdmFsdWUgZnJvbSB0aGVcbiAgICAvLyBgVmV4LkZsb3cuYWNjaWRlbnRhbENvZGVzLmFjY2lkZW50YWxzYCB0YWJsZSBpbiBgdGFibGVzLmpzYC4gRm9yXG4gICAgLy8gZXhhbXBsZTogYCNgLCBgIyNgLCBgYmAsIGBuYCwgZXRjLlxuICAgIGluaXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIEFjY2lkZW50YWwuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcyk7XG4gICAgICBMKFwiTmV3IGFjY2lkZW50YWw6IFwiLCB0eXBlKTtcblxuICAgICAgdGhpcy5ub3RlID0gbnVsbDtcbiAgICAgIC8vIFRoZSBgaW5kZXhgIHBvaW50cyB0byBhIHNwZWNpZmljIG5vdGUgaW4gYSBjaG9yZC5cbiAgICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBNb2RpZmllci5Qb3NpdGlvbi5MRUZUO1xuXG4gICAgICB0aGlzLnJlbmRlcl9vcHRpb25zID0ge1xuICAgICAgICAvLyBGb250IHNpemUgZm9yIGdseXBoc1xuICAgICAgICBmb250X3NjYWxlOiAzOCxcblxuICAgICAgICAvLyBMZW5ndGggb2Ygc3Ryb2tlIGFjcm9zcyBoZWFkcyBhYm92ZSBvciBiZWxvdyB0aGUgc3RhdmUuXG4gICAgICAgIHN0cm9rZV9weDogM1xuICAgICAgfTtcblxuICAgICAgdGhpcy5hY2NpZGVudGFsID0gVmV4LkZsb3cuYWNjaWRlbnRhbENvZGVzKHRoaXMudHlwZSk7XG4gICAgICBpZiAoIXRoaXMuYWNjaWRlbnRhbCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiQXJndW1lbnRFcnJvclwiLCBcIlVua25vd24gYWNjaWRlbnRhbCB0eXBlOiBcIiArIHR5cGUpO1xuXG4gICAgICAvLyBDYXV0aW9uYXJ5IGFjY2lkZW50YWxzIGhhdmUgcGFyZW50aGVzZXMgYXJvdW5kIHRoZW1cbiAgICAgIHRoaXMuY2F1dGlvbmFyeSA9IGZhbHNlO1xuICAgICAgdGhpcy5wYXJlbl9sZWZ0ID0gbnVsbDtcbiAgICAgIHRoaXMucGFyZW5fcmlnaHQgPSBudWxsO1xuXG4gICAgICAvLyBJbml0aWFsIHdpZHRoIGlzIHNldCBmcm9tIHRhYmxlLlxuICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLmFjY2lkZW50YWwud2lkdGgpO1xuICAgIH0sXG5cbiAgICAvLyBBdHRhY2ggdGhpcyBhY2NpZGVudGFsIHRvIGBub3RlYCwgd2hpY2ggbXVzdCBiZSBhIGBTdGF2ZU5vdGVgLlxuICAgIHNldE5vdGU6IGZ1bmN0aW9uKG5vdGUpe1xuICAgICAgaWYgKCFub3RlKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJBcmd1bWVudEVycm9yXCIsIFwiQmFkIG5vdGUgdmFsdWU6IFwiICsgbm90ZSk7XG4gICAgICB0aGlzLm5vdGUgPSBub3RlO1xuXG4gICAgICAvLyBBY2NpZGVudGFscyBhdHRhY2hlZCB0byBncmFjZSBub3RlcyBhcmUgcmVuZGVyZWQgc21hbGxlci5cbiAgICAgIGlmICh0aGlzLm5vdGUuZ2V0Q2F0ZWdvcnkoKSA9PT0gJ2dyYWNlbm90ZXMnKSB7XG4gICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuZm9udF9zY2FsZSA9IDI1O1xuICAgICAgICB0aGlzLnNldFdpZHRoKHRoaXMuYWNjaWRlbnRhbC5ncmFjZW5vdGVfd2lkdGgpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBJZiBjYWxsZWQsIGRyYXdzIHBhcmVudGhlc2lzIGFyb3VuZCBhY2NpZGVudGFsLlxuICAgIHNldEFzQ2F1dGlvbmFyeTogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmNhdXRpb25hcnkgPSB0cnVlO1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5mb250X3NjYWxlID0gMjg7XG4gICAgICB0aGlzLnBhcmVuX2xlZnQgPSBWZXguRmxvdy5hY2NpZGVudGFsQ29kZXMoXCJ7XCIpO1xuICAgICAgdGhpcy5wYXJlbl9yaWdodCA9IFZleC5GbG93LmFjY2lkZW50YWxDb2RlcyhcIn1cIik7XG4gICAgICB2YXIgd2lkdGhfYWRqdXN0ID0gKHRoaXMudHlwZSA9PSBcIiMjXCIgfHwgdGhpcy50eXBlID09IFwiYmJcIikgPyA2IDogNDtcblxuICAgICAgLy8gTWFrZSBzdXJlIGB3aWR0aGAgYWNjb21vZGF0ZXMgZm9yIHBhcmVudGhlc2VzLlxuICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLnBhcmVuX2xlZnQud2lkdGggKyB0aGlzLmFjY2lkZW50YWwud2lkdGggKyB0aGlzLnBhcmVuX3JpZ2h0LndpZHRoIC0gd2lkdGhfYWRqdXN0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBSZW5kZXIgYWNjaWRlbnRhbCBvbnRvIGNhbnZhcy5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IGFjY2lkZW50YWwgd2l0aG91dCBhIGNvbnRleHQuXCIpO1xuICAgICAgaWYgKCEodGhpcy5ub3RlICYmICh0aGlzLmluZGV4ICE9IG51bGwpKSkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9BdHRhY2hlZE5vdGVcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IGFjY2lkZW50YWwgd2l0aG91dCBhIG5vdGUgYW5kIGluZGV4LlwiKTtcblxuICAgICAgLy8gRmlndXJlIG91dCB0aGUgc3RhcnQgYHhgIGFuZCBgeWAgY29vcmRpbmF0ZXMgZm9yIHRoaXMgbm90ZSBhbmQgaW5kZXguXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLm5vdGUuZ2V0TW9kaWZpZXJTdGFydFhZKHRoaXMucG9zaXRpb24sIHRoaXMuaW5kZXgpO1xuICAgICAgdmFyIGFjY194ID0gKChzdGFydC54ICsgdGhpcy54X3NoaWZ0KSAtIHRoaXMud2lkdGgpO1xuICAgICAgdmFyIGFjY195ID0gc3RhcnQueSArIHRoaXMueV9zaGlmdDtcbiAgICAgIEwoXCJSZW5kZXJpbmc6IFwiLCB0aGlzLnR5cGUsIGFjY194LCBhY2NfeSk7XG5cbiAgICAgIGlmICghdGhpcy5jYXV0aW9uYXJ5KSB7XG4gICAgICAgIC8vIFJlbmRlciB0aGUgYWNjaWRlbnRhbCBhbG9uZS5cbiAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgodGhpcy5jb250ZXh0LCBhY2NfeCwgYWNjX3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuZm9udF9zY2FsZSwgdGhpcy5hY2NpZGVudGFsLmNvZGUpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gUmVuZGVyIHRoZSBhY2NpZGVudGFsIGluIHBhcmVudGhlc2VzLlxuICAgICAgICBhY2NfeCArPSAzO1xuICAgICAgICBWZXguRmxvdy5yZW5kZXJHbHlwaCh0aGlzLmNvbnRleHQsIGFjY194LCBhY2NfeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5mb250X3NjYWxlLCB0aGlzLnBhcmVuX2xlZnQuY29kZSk7XG4gICAgICAgIGFjY194ICs9IDI7XG4gICAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKHRoaXMuY29udGV4dCwgYWNjX3gsIGFjY195LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLmZvbnRfc2NhbGUsIHRoaXMuYWNjaWRlbnRhbC5jb2RlKTtcbiAgICAgICAgYWNjX3ggKz0gdGhpcy5hY2NpZGVudGFsLndpZHRoIC0gMjtcbiAgICAgICAgaWYgKHRoaXMudHlwZSA9PSBcIiMjXCIgfHwgdGhpcy50eXBlID09IFwiYmJcIikgYWNjX3ggLT0gMjtcbiAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgodGhpcy5jb250ZXh0LCBhY2NfeCwgYWNjX3ksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuZm9udF9zY2FsZSwgdGhpcy5wYXJlbl9yaWdodC5jb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIC8vICMjIFN0YXRpYyBNZXRob2RzXG4gIC8vXG4gIC8vIFVzZSB0aGlzIG1ldGhvZCB0byBhdXRvbWF0aWNhbGx5IGFwcGx5IGFjY2lkZW50YWxzIHRvIGEgc2V0IG9mIGB2b2ljZXNgLlxuICAvLyBUaGUgYWNjaWRlbnRhbHMgd2lsbCBiZSByZW1lbWJlcmVkIGJldHdlZW4gYWxsIHRoZSB2b2ljZXMgcHJvdmlkZWQuXG4gIC8vIE9wdGlvbmFsbHksIHlvdSBjYW4gYWxzbyBwcm92aWRlIGFuIGluaXRpYWwgYGtleVNpZ25hdHVyZWAuXG4gIEFjY2lkZW50YWwuYXBwbHlBY2NpZGVudGFscyA9IGZ1bmN0aW9uKHZvaWNlcywga2V5U2lnbmF0dXJlKSB7XG4gICAgdmFyIHRpY2tQb3NpdGlvbnMgPSBbXTtcbiAgICB2YXIgdGlja05vdGVNYXAgPSB7fTtcblxuICAgIC8vIFNvcnQgdGhlIHRpY2thYmxlcyBpbiBlYWNoIHZvaWNlIGJ5IHRoZWlyIHRpY2sgcG9zaXRpb24gaW4gdGhlIHZvaWNlXG4gICAgdm9pY2VzLmZvckVhY2goZnVuY3Rpb24odm9pY2UpIHtcbiAgICAgIHZhciB0aWNrUG9zaXRpb24gPSBuZXcgVmV4LkZsb3cuRnJhY3Rpb24oMCwgMSk7XG4gICAgICB2YXIgbm90ZXMgPSB2b2ljZS5nZXRUaWNrYWJsZXMoKTtcbiAgICAgIG5vdGVzLmZvckVhY2goZnVuY3Rpb24obm90ZSkge1xuICAgICAgICB2YXIgbm90ZXNBdFBvc2l0aW9uID0gdGlja05vdGVNYXBbdGlja1Bvc2l0aW9uLnZhbHVlKCldO1xuXG4gICAgICAgIGlmICghbm90ZXNBdFBvc2l0aW9uKSB7XG4gICAgICAgICAgdGlja1Bvc2l0aW9ucy5wdXNoKHRpY2tQb3NpdGlvbi52YWx1ZSgpKTtcbiAgICAgICAgICB0aWNrTm90ZU1hcFt0aWNrUG9zaXRpb24udmFsdWUoKV0gPSBbbm90ZV07XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgbm90ZXNBdFBvc2l0aW9uLnB1c2gobm90ZSk7XG4gICAgICAgIH1cblxuICAgICAgICB0aWNrUG9zaXRpb24uYWRkKG5vdGUuZ2V0VGlja3MoKSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHZhciBtdXNpYyA9IG5ldyBWZXguRmxvdy5NdXNpYygpO1xuXG4gICAgLy8gRGVmYXVsdCBrZXkgc2lnbmF0dXJlIGlzIEMgbWFqb3JcbiAgICBpZiAoIWtleVNpZ25hdHVyZSkga2V5U2lnbmF0dXJlID0gXCJDXCI7XG5cbiAgICAvLyBHZXQgdGhlIHNjYWxlIG1hcCwgd2hpY2ggcmVwcmVzZW50cyB0aGUgY3VycmVudCBzdGF0ZSBvZiBlYWNoIHBpdGNoXG4gICAgdmFyIHNjYWxlTWFwID0gbXVzaWMuY3JlYXRlU2NhbGVNYXAoa2V5U2lnbmF0dXJlKTtcblxuICAgIHRpY2tQb3NpdGlvbnMuZm9yRWFjaChmdW5jdGlvbih0aWNrKSB7XG4gICAgICB2YXIgbm90ZXMgPSB0aWNrTm90ZU1hcFt0aWNrXTtcblxuICAgICAgLy8gQXJyYXkgdG8gc3RvcmUgYWxsIHBpdGNoZXMgdGhhdCBtb2RpZmllZCBhY2NpZGVudGFsIHN0YXRlc1xuICAgICAgLy8gYXQgdGhpcyB0aWNrIHBvc2l0aW9uXG4gICAgICB2YXIgbW9kaWZpZWRQaXRjaGVzID0gW107XG5cbiAgICAgIG5vdGVzLmZvckVhY2goZnVuY3Rpb24obm90ZSkge1xuICAgICAgICAgIGlmIChub3RlLmlzUmVzdCgpKSByZXR1cm47XG5cbiAgICAgICAgICAvLyBHbyB0aHJvdWdoIGVhY2gga2V5IGFuZCBkZXRlcm1pbmUgaWYgYW4gYWNjaWRlbnRhbCBzaG91bGQgYmVcbiAgICAgICAgICAvLyBhcHBsaWVkXG4gICAgICAgICAgbm90ZS5rZXlzLmZvckVhY2goZnVuY3Rpb24oa2V5U3RyaW5nLCBrZXlJbmRleCkge1xuICAgICAgICAgICAgICB2YXIga2V5ID0gbXVzaWMuZ2V0Tm90ZVBhcnRzKGtleVN0cmluZy5zcGxpdCgnLycpWzBdKTtcblxuICAgICAgICAgICAgICAvLyBGb3JjZSBhIG5hdHVyYWwgZm9yIGV2ZXJ5IGtleSB3aXRob3V0IGFuIGFjY2lkZW50YWxcbiAgICAgICAgICAgICAgdmFyIGFjY2lkZW50YWxTdHJpbmcgPSBrZXkuYWNjaWRlbnRhbCB8fCBcIm5cIjtcbiAgICAgICAgICAgICAgdmFyIHBpdGNoID0ga2V5LnJvb3QgKyBhY2NpZGVudGFsU3RyaW5nO1xuXG4gICAgICAgICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgY3VycmVudCBwaXRjaCBoYXMgdGhlIHNhbWUgYWNjaWRlbnRhbFxuICAgICAgICAgICAgICAvLyBhcyB0aGUgc2NhbGUgc3RhdGVcbiAgICAgICAgICAgICAgdmFyIHNhbWVBY2NpZGVudGFsID0gc2NhbGVNYXBba2V5LnJvb3RdID09PSBwaXRjaDtcblxuICAgICAgICAgICAgICAvLyBEZXRlcm1pbmUgaWYgYW4gaWRlbnRpY2FsIHBpdGNoIGluIHRoZSBjaG9yZCBhbHJlYWR5XG4gICAgICAgICAgICAgIC8vIG1vZGlmaWVkIHRoZSBhY2NpZGVudGFsIHN0YXRlXG4gICAgICAgICAgICAgIHZhciBwcmV2aW91c2x5TW9kaWZpZWQgPSBtb2RpZmllZFBpdGNoZXMuaW5kZXhPZihwaXRjaCkgPiAtMTtcblxuICAgICAgICAgICAgICAvLyBBZGQgdGhlIGFjY2lkZW50YWwgdG8gdGhlIFN0YXZlTm90ZVxuICAgICAgICAgICAgICBpZiAoIXNhbWVBY2NpZGVudGFsIHx8IChzYW1lQWNjaWRlbnRhbCAmJiBwcmV2aW91c2x5TW9kaWZpZWQpKSB7XG4gICAgICAgICAgICAgICAgICAvLyBNb2RpZnkgdGhlIHNjYWxlIG1hcCBzbyB0aGF0IHRoZSByb290IHBpdGNoIGhhcyBhblxuICAgICAgICAgICAgICAgICAgLy8gdXBkYXRlZCBzdGF0ZVxuICAgICAgICAgICAgICAgICAgc2NhbGVNYXBba2V5LnJvb3RdID0gcGl0Y2g7XG5cbiAgICAgICAgICAgICAgICAgIC8vIENyZWF0ZSB0aGUgYWNjaWRlbnRhbFxuICAgICAgICAgICAgICAgICAgdmFyIGFjY2lkZW50YWwgPSBuZXcgVmV4LkZsb3cuQWNjaWRlbnRhbChhY2NpZGVudGFsU3RyaW5nKTtcblxuICAgICAgICAgICAgICAgICAgLy8gQXR0YWNoIHRoZSBhY2NpZGVudGFsIHRvIHRoZSBTdGF2ZU5vdGVcbiAgICAgICAgICAgICAgICAgIG5vdGUuYWRkQWNjaWRlbnRhbChrZXlJbmRleCwgYWNjaWRlbnRhbCk7XG5cbiAgICAgICAgICAgICAgICAgIC8vIEFkZCB0aGUgcGl0Y2ggdG8gbGlzdCBvZiBwaXRjaGVzIHRoYXQgbW9kaWZpZWQgYWNjaWRlbnRhbHNcbiAgICAgICAgICAgICAgICAgIG1vZGlmaWVkUGl0Y2hlcy5wdXNoKHBpdGNoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH07XG5cbiAgcmV0dXJuIEFjY2lkZW50YWw7XG59KCkpO1xuXG4vLyBWZXhGbG93IC0gTXVzaWMgRW5ncmF2aW5nIGZvciBIVE1MNVxyXG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxyXG4vL1xyXG4vLyBUaGlzIGNsYXNzIGltcGxlbWVudHMgZG90IG1vZGlmaWVycyBmb3Igbm90ZXMuXHJcblxyXG4vKipcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5WZXguRmxvdy5Eb3QgPSAoZnVuY3Rpb24oKSB7XHJcbiAgZnVuY3Rpb24gRG90KCkge1xyXG4gICAgdGhpcy5pbml0KCk7XHJcbiAgfVxyXG5cclxuICBEb3QuQ0FURUdPUlkgPSBcImRvdHNcIjtcclxuXHJcbiAgdmFyIE1vZGlmaWVyID0gVmV4LkZsb3cuTW9kaWZpZXI7XHJcblxyXG4gIC8vIEFycmFuZ2UgZG90cyBpbnNpZGUgYSBNb2RpZmllckNvbnRleHQuXHJcbiAgRG90LmZvcm1hdCA9IGZ1bmN0aW9uKGRvdHMsIHN0YXRlKSB7XHJcbiAgICB2YXIgcmlnaHRfc2hpZnQgPSBzdGF0ZS5yaWdodF9zaGlmdDtcclxuICAgIHZhciBkb3Rfc3BhY2luZyA9IDE7XHJcblxyXG4gICAgaWYgKCFkb3RzIHx8IGRvdHMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XHJcblxyXG4gICAgdmFyIGksIGRvdCwgbm90ZSwgc2hpZnQ7XHJcbiAgICB2YXIgZG90X2xpc3QgPSBbXTtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBkb3RzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIGRvdCA9IGRvdHNbaV07XHJcbiAgICAgIG5vdGUgPSBkb3QuZ2V0Tm90ZSgpO1xyXG5cclxuICAgICAgdmFyIHByb3BzO1xyXG4gICAgICAvLyBPbmx5IFN0YXZlTm90ZSBoYXMgLmdldEtleVByb3BzKClcclxuICAgICAgaWYgKHR5cGVvZiBub3RlLmdldEtleVByb3BzID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgcHJvcHMgPSBub3RlLmdldEtleVByb3BzKClbZG90LmdldEluZGV4KCldO1xyXG4gICAgICAgIHNoaWZ0ID0gKHByb3BzLmRpc3BsYWNlZCA/IG5vdGUuZ2V0RXh0cmFSaWdodFB4KCkgOiAwKTtcclxuICAgICAgfSBlbHNlIHsgLy8gRWxzZSBpdCdzIGEgVGFiTm90ZVxyXG4gICAgICAgIHByb3BzID0geyBsaW5lOiAwLjUgfTsgLy8gU2hpbSBrZXkgcHJvcHMgZm9yIGRvdCBwbGFjZW1lbnRcclxuICAgICAgICBzaGlmdCA9IDA7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGRvdF9saXN0LnB1c2goeyBsaW5lOiBwcm9wcy5saW5lLCBzaGlmdDogc2hpZnQsIG5vdGU6IG5vdGUsIGRvdDogZG90IH0pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFNvcnQgZG90cyBieSBsaW5lIG51bWJlci5cclxuICAgIGRvdF9saXN0LnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gKGIubGluZSAtIGEubGluZSk7IH0pO1xyXG5cclxuICAgIHZhciBkb3Rfc2hpZnQgPSByaWdodF9zaGlmdDtcclxuICAgIHZhciB4X3dpZHRoID0gMDtcclxuICAgIHZhciBsYXN0X2xpbmUgPSBudWxsO1xyXG4gICAgdmFyIGxhc3Rfbm90ZSA9IG51bGw7XHJcbiAgICB2YXIgcHJldl9kb3R0ZWRfc3BhY2UgPSBudWxsO1xyXG4gICAgdmFyIGhhbGZfc2hpZnRZID0gMDtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgZG90X2xpc3QubGVuZ3RoOyArK2kpIHtcclxuICAgICAgZG90ID0gZG90X2xpc3RbaV0uZG90O1xyXG4gICAgICBub3RlID0gZG90X2xpc3RbaV0ubm90ZTtcclxuICAgICAgc2hpZnQgPSBkb3RfbGlzdFtpXS5zaGlmdDtcclxuICAgICAgdmFyIGxpbmUgPSBkb3RfbGlzdFtpXS5saW5lO1xyXG5cclxuICAgICAgLy8gUmVzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBkb3QgZXZlcnkgbGluZS5cclxuICAgICAgaWYgKGxpbmUgIT0gbGFzdF9saW5lIHx8IG5vdGUgIT0gbGFzdF9ub3RlKSB7XHJcbiAgICAgICAgZG90X3NoaWZ0ID0gc2hpZnQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGlmICghbm90ZS5pc1Jlc3QoKSAmJiBsaW5lICE9IGxhc3RfbGluZSkge1xyXG4gICAgICAgIGlmIChNYXRoLmFicyhsaW5lICUgMSkgPT0gMC41KSB7XHJcbiAgICAgICAgICAvLyBub3RlIGlzIG9uIGEgc3BhY2UsIHNvIG5vIGRvdCBzaGlmdFxyXG4gICAgICAgICAgaGFsZl9zaGlmdFkgPSAwO1xyXG4gICAgICAgIH0gZWxzZSBpZiAoIW5vdGUuaXNSZXN0KCkpIHtcclxuICAgICAgICAgIC8vIG5vdGUgaXMgb24gYSBsaW5lLCBzbyBzaGlmdCBkb3QgdG8gc3BhY2UgYWJvdmUgdGhlIGxpbmVcclxuICAgICAgICAgIGhhbGZfc2hpZnRZID0gMC41O1xyXG4gICAgICAgICAgaWYgKGxhc3Rfbm90ZSAhPSBudWxsICYmXHJcbiAgICAgICAgICAgICAgIWxhc3Rfbm90ZS5pc1Jlc3QoKSAmJiBsYXN0X2xpbmUgLSBsaW5lID09IDAuNSkge1xyXG4gICAgICAgICAgICAvLyBwcmV2aW91cyBub3RlIG9uIGEgc3BhY2UsIHNvIHNoaWZ0IGRvdCB0byBzcGFjZSBiZWxvdyB0aGUgbGluZVxyXG4gICAgICAgICAgICBoYWxmX3NoaWZ0WSA9IC0wLjU7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGxpbmUgKyBoYWxmX3NoaWZ0WSA9PSBwcmV2X2RvdHRlZF9zcGFjZSkge1xyXG4gICAgICAgICAgICAvLyBwcmV2aW91cyBzcGFjZSBpcyBkb3R0ZWQsIHNvIHNoaWZ0IGRvdCB0byBzcGFjZSBiZWxvdyB0aGUgbGluZVxyXG4gICAgICAgICAgICAgaGFsZl9zaGlmdFkgPSAtMC41O1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gY29udmVydCBoYWxmX3NoaWZ0WSB0byBhIG11bHRpcGxpZXIgZm9yIGRvdHMuZHJhdygpXHJcbiAgICAgIGRvdC5kb3Rfc2hpZnRZID0gKC1oYWxmX3NoaWZ0WSk7XHJcbiAgICAgIHByZXZfZG90dGVkX3NwYWNlID0gbGluZSArIGhhbGZfc2hpZnRZO1xyXG5cclxuICAgICAgZG90LnNldFhTaGlmdChkb3Rfc2hpZnQpO1xyXG4gICAgICBkb3Rfc2hpZnQgKz0gZG90LmdldFdpZHRoKCkgKyBkb3Rfc3BhY2luZzsgLy8gc3BhY2luZ1xyXG4gICAgICB4X3dpZHRoID0gKGRvdF9zaGlmdCA+IHhfd2lkdGgpID8gZG90X3NoaWZ0IDogeF93aWR0aDtcclxuICAgICAgbGFzdF9saW5lID0gbGluZTtcclxuICAgICAgbGFzdF9ub3RlID0gbm90ZTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBVcGRhdGUgc3RhdGUuXHJcbiAgICBzdGF0ZS5yaWdodF9zaGlmdCArPSB4X3dpZHRoO1xyXG4gIH07XHJcblxyXG4gIFZleC5Jbmhlcml0KERvdCwgTW9kaWZpZXIsIHtcclxuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xyXG4gICAgICBEb3Quc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICB0aGlzLm5vdGUgPSBudWxsO1xyXG4gICAgICB0aGlzLmluZGV4ID0gbnVsbDtcclxuICAgICAgdGhpcy5wb3NpdGlvbiA9IE1vZGlmaWVyLlBvc2l0aW9uLlJJR0hUO1xyXG5cclxuICAgICAgdGhpcy5yYWRpdXMgPSAyO1xyXG4gICAgICB0aGlzLnNldFdpZHRoKDUpO1xyXG4gICAgICB0aGlzLmRvdF9zaGlmdFkgPSAwO1xyXG4gICAgfSxcclxuXHJcbiAgICBzZXROb3RlOiBmdW5jdGlvbihub3RlKXtcclxuICAgICAgdGhpcy5ub3RlID0gbm90ZTtcclxuXHJcbiAgICAgIGlmICh0aGlzLm5vdGUuZ2V0Q2F0ZWdvcnkoKSA9PT0gJ2dyYWNlbm90ZXMnKSB7XHJcbiAgICAgICAgdGhpcy5yYWRpdXMgKj0gMC41MDtcclxuICAgICAgICB0aGlzLnNldFdpZHRoKDMpO1xyXG4gICAgICB9XHJcbiAgICB9LFxyXG5cclxuICAgIHNldERvdFNoaWZ0WTogZnVuY3Rpb24oeSkgeyB0aGlzLmRvdF9zaGlmdFkgPSB5OyByZXR1cm4gdGhpczsgfSxcclxuXHJcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxyXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBkb3Qgd2l0aG91dCBhIGNvbnRleHQuXCIpO1xyXG4gICAgICBpZiAoISh0aGlzLm5vdGUgJiYgKHRoaXMuaW5kZXggIT0gbnVsbCkpKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0F0dGFjaGVkTm90ZVwiLFxyXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBkb3Qgd2l0aG91dCBhIG5vdGUgYW5kIGluZGV4LlwiKTtcclxuXHJcbiAgICAgIHZhciBsaW5lX3NwYWNlID0gdGhpcy5ub3RlLnN0YXZlLm9wdGlvbnMuc3BhY2luZ19iZXR3ZWVuX2xpbmVzX3B4O1xyXG5cclxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5ub3RlLmdldE1vZGlmaWVyU3RhcnRYWSh0aGlzLnBvc2l0aW9uLCB0aGlzLmluZGV4KTtcclxuXHJcbiAgICAgIC8vIFNldCB0aGUgc3RhcnRpbmcgeSBjb29yZGluYXRlIHRvIHRoZSBiYXNlIG9mIHRoZSBzdGVtIGZvciBUYWJOb3Rlc1xyXG4gICAgICBpZiAodGhpcy5ub3RlLmdldENhdGVnb3J5KCkgPT09ICd0YWJub3RlcycpIHtcclxuICAgICAgICBzdGFydC55ID0gdGhpcy5ub3RlLmdldFN0ZW1FeHRlbnRzKCkuYmFzZVk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBkb3RfeCA9IChzdGFydC54ICsgdGhpcy54X3NoaWZ0KSArIHRoaXMud2lkdGggLSB0aGlzLnJhZGl1cztcclxuICAgICAgdmFyIGRvdF95ID0gc3RhcnQueSArIHRoaXMueV9zaGlmdCArICh0aGlzLmRvdF9zaGlmdFkgKiBsaW5lX3NwYWNlKTtcclxuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuXHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgY3R4LmFyYyhkb3RfeCwgZG90X3ksIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xyXG4gICAgICBjdHguZmlsbCgpO1xyXG4gICAgfVxyXG4gIH0pO1xyXG5cclxuICByZXR1cm4gRG90O1xyXG59KCkpO1xyXG5cbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgdGhlIGZvcm1hdHRpbmcgYW5kIGxheW91dCBhbGdvcml0aG1zIHRoYXQgYXJlIHVzZWRcbi8vIHRvIHBvc2l0aW9uIG5vdGVzIGluIGEgdm9pY2UuIFRoZSBhbGdvcml0aG0gY2FuIGFsaWduIG11bHRpcGxlIHZvaWNlcyBib3RoXG4vLyB3aXRoaW4gYSBzdGF2ZSwgYW5kIGFjcm9zcyBtdWx0aXBsZSBzdGF2ZXMuXG4vL1xuLy8gVG8gZG8gdGhpcywgdGhlIGZvcm1hdHRlciBicmVha3MgdXAgdm9pY2VzIGludG8gYSBncmlkIG9mIHJhdGlvbmFsLXZhbHVlZFxuLy8gYHRpY2tzYCwgdG8gd2hpY2ggZWFjaCBub3RlIGlzIGFzc2lnbmVkLiBUaGVuLCBtaW5pbXVtIHdpZHRocyBhcmUgYXNzaWduZWRcbi8vIHRvIGVhY2ggdGljayBiYXNlZCBvbiB0aGUgd2lkdGhzIG9mIHRoZSBub3RlcyBhbmQgbW9kaWZpZXJzIGluIHRoYXQgdGljay4gVGhpc1xuLy8gZXN0YWJsaXNoZXMgdGhlIHNtYWxsZXN0IGFtb3VudCBvZiBzcGFjZSByZXF1aXJlZCBmb3IgZWFjaCB0aWNrLlxuLy9cbi8vIEZpbmFsbHksIHRoZSBmb3JtYXR0ZXIgZGlzdHJpYnV0ZXMgdGhlIGxlZnQgb3ZlciBzcGFjZSBwcm9wb3J0aW9uYWxseSB0b1xuLy8gYWxsIHRoZSB0aWNrcywgc2V0dGluZyB0aGUgYHhgIHZhbHVlcyBvZiB0aGUgbm90ZXMgaW4gZWFjaCB0aWNrLlxuLy9cbi8vIFNlZSBgdGVzdHMvZm9ybWF0dGVyX3Rlc3RzLmpzYCBmb3IgdXNhZ2UgZXhhbXBsZXMuIFRoZSBoZWxwZXIgZnVuY3Rpb25zIGluY2x1ZGVkXG4vLyBoZXJlIChgRm9ybWF0QW5kRHJhd2AsIGBGb3JtYXRBbmREcmF3VGFiYCkgYWxzbyBzZXJ2ZSBhcyB1c2VmdWwgdXNhZ2UgZXhhbXBsZXMuXG5cblZleC5GbG93LkZvcm1hdHRlciA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gRm9ybWF0dGVyKCkge1xuICAgIC8vIE1pbmltdW0gd2lkdGggcmVxdWlyZWQgdG8gcmVuZGVyIGFsbCB0aGUgbm90ZXMgaW4gdGhlIHZvaWNlcy5cbiAgICB0aGlzLm1pblRvdGFsV2lkdGggPSAwO1xuXG4gICAgLy8gVGhpcyBpcyBzZXQgdG8gYHRydWVgIGFmdGVyIGBtaW5Ub3RhbFdpZHRoYCBpcyBjYWxjdWxhdGVkLlxuICAgIHRoaXMuaGFzTWluVG90YWxXaWR0aCA9IGZhbHNlO1xuXG4gICAgLy8gVGhlIHN1Z2dlc3RlZCBhbW91bnQgb2Ygc3BhY2UgZm9yIGVhY2ggdGljay5cbiAgICB0aGlzLnBpeGVsc1BlclRpY2sgPSAwO1xuXG4gICAgLy8gVG90YWwgbnVtYmVyIG9mIHRpY2tzIGluIHRoZSB2b2ljZS5cbiAgICB0aGlzLnRvdGFsVGlja3MgPSBuZXcgVmV4LkZsb3cuRnJhY3Rpb24oMCwgMSk7XG5cbiAgICAvLyBBcnJheXMgb2YgdGljayBhbmQgbW9kaWZpZXIgY29udGV4dHMuXG4gICAgdGhpcy50Q29udGV4dHMgPSBudWxsO1xuICAgIHRoaXMubUNvbnRleHRzID0gbnVsbDtcbiAgfVxuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93LkZvcm1hdHRlci5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoRm9ybWF0dGVyLkRFQlVHKSBWZXguTChcIlZleC5GbG93LkZvcm1hdHRlclwiLCBhcmd1bWVudHMpOyB9XG5cbiAgLy8gIyMgUHJpdmF0ZSBIZWxwZXJzXG4gIC8vXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBsb2NhdGUgdGhlIG5leHQgbm9uLXJlc3Qgbm90ZShzKS5cbiAgZnVuY3Rpb24gbG9va0FoZWFkKG5vdGVzLCByZXN0X2xpbmUsIGksIGNvbXBhcmUpIHtcbiAgICAvLyBJZiBubyB2YWxpZCBuZXh0IG5vdGUgZ3JvdXAsIG5leHRfcmVzdF9saW5lIGlzIHNhbWUgYXMgY3VycmVudC5cbiAgICB2YXIgbmV4dF9yZXN0X2xpbmUgPSByZXN0X2xpbmU7XG5cbiAgICAvLyBHZXQgdGhlIHJlc3QgbGluZSBmb3IgbmV4dCB2YWxpZCBub24tcmVzdCBub3RlIGdyb3VwLlxuICAgIGkrKztcbiAgICB3aGlsZSAoaSA8IG5vdGVzLmxlbmd0aCkge1xuICAgICAgaWYgKCFub3Rlc1tpXS5pc1Jlc3QoKSAmJiAhbm90ZXNbaV0uc2hvdWxkSWdub3JlVGlja3MoKSkge1xuICAgICAgICBuZXh0X3Jlc3RfbGluZSA9IG5vdGVzW2ldLmdldExpbmVGb3JSZXN0KCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaSsrO1xuICAgIH1cblxuICAgIC8vIExvY2F0ZSB0aGUgbWlkIHBvaW50IGJldHdlZW4gdHdvIGxpbmVzLlxuICAgIGlmIChjb21wYXJlICYmIHJlc3RfbGluZSAhPSBuZXh0X3Jlc3RfbGluZSkge1xuICAgICAgdmFyIHRvcCA9IFZleC5NYXgocmVzdF9saW5lLCBuZXh0X3Jlc3RfbGluZSk7XG4gICAgICB2YXIgYm90ID0gVmV4Lk1pbihyZXN0X2xpbmUsIG5leHRfcmVzdF9saW5lKTtcbiAgICAgIG5leHRfcmVzdF9saW5lID0gVmV4Lk1pZExpbmUodG9wLCBib3QpO1xuICAgIH1cbiAgICByZXR1cm4gbmV4dF9yZXN0X2xpbmU7XG4gIH1cblxuICAvLyBUYWtlIGFuIGFycmF5IG9mIGB2b2ljZXNgIGFuZCBwbGFjZSBhbGlnbmVkIHRpY2thYmxlcyBpbiB0aGUgc2FtZSBjb250ZXh0LiBSZXR1cm5zXG4gIC8vIGEgbWFwcGluZyBmcm9tIGB0aWNrYCB0byBgY29udGV4dF90eXBlYCwgYSBsaXN0IG9mIGB0aWNrYHMsIGFuZCB0aGUgcmVzb2x1dGlvblxuICAvLyBtdWx0aXBsaWVyLlxuICAvL1xuICAvLyBQYXJhbXM6XG4gIC8vICogYHZvaWNlc2A6IEFycmF5IG9mIGBWb2ljZWAgaW5zdGFuY2VzLlxuICAvLyAqIGBjb250ZXh0X3R5cGVgOiBBIGNvbnRleHQgY2xhc3MgKGUuZy4sIGBNb2RpZmllckNvbnRleHRgLCBgVGlja0NvbnRleHRgKVxuICAvLyAqIGBhZGRfZm5gOiBGdW5jdGlvbiB0byBhZGQgdGlja2FibGUgdG8gY29udGV4dC5cbiAgZnVuY3Rpb24gY3JlYXRlQ29udGV4dHModm9pY2VzLCBjb250ZXh0X3R5cGUsIGFkZF9mbikge1xuICAgIGlmICghdm9pY2VzIHx8ICF2b2ljZXMubGVuZ3RoKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudFwiLFxuICAgICAgICBcIk5vIHZvaWNlcyB0byBmb3JtYXRcIik7XG5cbiAgICAvLyBJbml0aWFsaXplIHRpY2sgbWFwcy5cbiAgICB2YXIgdG90YWxUaWNrcyA9IHZvaWNlc1swXS5nZXRUb3RhbFRpY2tzKCk7XG4gICAgdmFyIHRpY2tUb0NvbnRleHRNYXAgPSB7fTtcbiAgICB2YXIgdGlja0xpc3QgPSBbXTtcbiAgICB2YXIgY29udGV4dHMgPSBbXTtcblxuICAgIHZhciByZXNvbHV0aW9uTXVsdGlwbGllciA9IDE7XG5cbiAgICAvLyBGaW5kIG91dCBoaWdoZXN0IGNvbW1vbiBtdWx0aXBsZSBvZiByZXNvbHV0aW9uIG11bHRpcGxpZXJzLlxuICAgIC8vIFRoZSBwdXJwb3NlIG9mIHRoaXMgaXMgdG8gZmluZCBvdXQgYSBjb21tb24gZGVub21pbmF0b3JcbiAgICAvLyBmb3IgYWxsIGZyYWN0aW9uYWwgdGljayB2YWx1ZXMgaW4gYWxsIHRpY2thYmxlcyBvZiBhbGwgdm9pY2VzLFxuICAgIC8vIHNvIHRoYXQgdGhlIHZhbHVlcyBjYW4gYmUgZXhwYW5kZWQgYW5kIHRoZSBudW1lcmF0b3IgdXNlZFxuICAgIC8vIGFzIGFuIGludGVnZXIgdGljayB2YWx1ZS5cbiAgICB2YXIgaTsgLy8gc2hhcmVkIGl0ZXJhdG9yXG4gICAgdmFyIHZvaWNlO1xuICAgIGZvciAoaSA9IDA7IGkgPCB2b2ljZXMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZvaWNlID0gdm9pY2VzW2ldO1xuICAgICAgaWYgKCEodm9pY2UuZ2V0VG90YWxUaWNrcygpLmVxdWFscyh0b3RhbFRpY2tzKSkpIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiVGlja01pc21hdGNoXCIsXG4gICAgICAgICAgICBcIlZvaWNlcyBzaG91bGQgaGF2ZSBzYW1lIHRvdGFsIG5vdGUgZHVyYXRpb24gaW4gdGlja3MuXCIpO1xuICAgICAgfVxuXG4gICAgICBpZiAodm9pY2UuZ2V0TW9kZSgpID09IFZleC5GbG93LlZvaWNlLk1vZGUuU1RSSUNUICYmICF2b2ljZS5pc0NvbXBsZXRlKCkpXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkluY29tcGxldGVWb2ljZVwiLFxuICAgICAgICAgIFwiVm9pY2UgZG9lcyBub3QgaGF2ZSBlbm91Z2ggbm90ZXMuXCIpO1xuXG4gICAgICB2YXIgbGNtID0gVmV4LkZsb3cuRnJhY3Rpb24uTENNKHJlc29sdXRpb25NdWx0aXBsaWVyLFxuICAgICAgICAgIHZvaWNlLmdldFJlc29sdXRpb25NdWx0aXBsaWVyKCkpO1xuICAgICAgaWYgKHJlc29sdXRpb25NdWx0aXBsaWVyIDwgbGNtKSB7XG4gICAgICAgIHJlc29sdXRpb25NdWx0aXBsaWVyID0gbGNtO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIEZvciBlYWNoIHZvaWNlLCBleHRyYWN0IG5vdGVzIGFuZCBjcmVhdGUgYSBjb250ZXh0IGZvciBldmVyeVxuICAgIC8vIG5ldyB0aWNrIHRoYXQgaGFzbid0IGJlZW4gc2VlbiBiZWZvcmUuXG4gICAgZm9yIChpID0gMDsgaSA8IHZvaWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgdm9pY2UgPSB2b2ljZXNbaV07XG5cbiAgICAgIHZhciB0aWNrYWJsZXMgPSB2b2ljZS5nZXRUaWNrYWJsZXMoKTtcblxuICAgICAgLy8gVXNlIHJlc29sdXRpb24gbXVsdGlwbGllciBhcyBkZW5vbWluYXRvciB0byBleHBhbmQgdGlja3NcbiAgICAgIC8vIHRvIHN1aXRhYmxlIGludGVnZXIgdmFsdWVzLCBzbyB0aGF0IG5vIGFkZGl0aW9uYWwgZXhwYW5zaW9uXG4gICAgICAvLyBvZiBmcmFjdGlvbmFsIHRpY2sgdmFsdWVzIGlzIG5lZWRlZC5cbiAgICAgIHZhciB0aWNrc1VzZWQgPSBuZXcgVmV4LkZsb3cuRnJhY3Rpb24oMCwgcmVzb2x1dGlvbk11bHRpcGxpZXIpO1xuXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHRpY2thYmxlcy5sZW5ndGg7ICsraikge1xuICAgICAgICB2YXIgdGlja2FibGUgPSB0aWNrYWJsZXNbal07XG4gICAgICAgIHZhciBpbnRlZ2VyVGlja3MgPSB0aWNrc1VzZWQubnVtZXJhdG9yO1xuXG4gICAgICAgIC8vIElmIHdlIGhhdmUgbm8gdGljayBjb250ZXh0IGZvciB0aGlzIHRpY2ssIGNyZWF0ZSBvbmUuXG4gICAgICAgIGlmICghdGlja1RvQ29udGV4dE1hcFtpbnRlZ2VyVGlja3NdKSB7XG4gICAgICAgICAgdmFyIG5ld0NvbnRleHQgPSBuZXcgY29udGV4dF90eXBlKCk7XG4gICAgICAgICAgY29udGV4dHMucHVzaChuZXdDb250ZXh0KTtcbiAgICAgICAgICB0aWNrVG9Db250ZXh0TWFwW2ludGVnZXJUaWNrc10gPSBuZXdDb250ZXh0O1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQWRkIHRoaXMgdGlja2FibGUgdG8gdGhlIFRpY2tDb250ZXh0LlxuICAgICAgICBhZGRfZm4odGlja2FibGUsIHRpY2tUb0NvbnRleHRNYXBbaW50ZWdlclRpY2tzXSk7XG5cbiAgICAgICAgLy8gTWFpbnRhaW4gYSBzb3J0ZWQgbGlzdCBvZiB0aWNrIGNvbnRleHRzLlxuICAgICAgICB0aWNrTGlzdC5wdXNoKGludGVnZXJUaWNrcyk7XG4gICAgICAgIHRpY2tzVXNlZC5hZGQodGlja2FibGUuZ2V0VGlja3MoKSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIG1hcDogdGlja1RvQ29udGV4dE1hcCxcbiAgICAgIGFycmF5OiBjb250ZXh0cyxcbiAgICAgIGxpc3Q6IFZleC5Tb3J0QW5kVW5pcXVlKHRpY2tMaXN0LCBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhIC0gYjsgfSxcbiAgICAgICAgICBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhID09PSBiOyB9ICksXG4gICAgICByZXNvbHV0aW9uTXVsdGlwbGllcjogcmVzb2x1dGlvbk11bHRpcGxpZXJcbiAgICB9O1xuICB9XG5cblxuICAvLyAjIyBTdGF0aWMgTWV0aG9kc1xuICAvL1xuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZm9ybWF0IGFuZCBkcmF3IGEgc2luZ2xlIHZvaWNlLiBSZXR1cm5zIGEgYm91bmRpbmdcbiAgLy8gYm94IGZvciB0aGUgbm90YXRpb24uXG4gIC8vXG4gIC8vIFBhcmFtZXRlcnM6XG4gIC8vICogYGN0eGAgLSBUaGUgcmVuZGVyaW5nIGNvbnRleHRcbiAgLy8gKiBgc3RhdmVgIC0gVGhlIHN0YXZlIHRvIHdoaWNoIHRvIGRyYXcgKGBTdGF2ZWAgb3IgYFRhYlN0YXZlYClcbiAgLy8gKiBgbm90ZXNgIC0gQXJyYXkgb2YgYE5vdGVgIGluc3RhbmNlcyAoYFN0YXZlTm90ZWAsIGBUZXh0Tm90ZWAsIGBUYWJOb3RlYCwgZXRjLilcbiAgLy8gKiBgcGFyYW1zYCAtIE9uZSBvZiBiZWxvdzpcbiAgLy8gICAgKiBTZXR0aW5nIGBhdXRvYmVhbWAgb25seSBgKGNvbnRleHQsIHN0YXZlLCBub3RlcywgdHJ1ZSlgIG9yIGAoY3R4LCBzdGF2ZSwgbm90ZXMsIHthdXRvYmVhbTogdHJ1ZX0pYFxuICAvLyAgICAqIFNldHRpbmcgYGFsaWduX3Jlc3RzYCBhIHN0cnVjdCBpcyBuZWVkZWQgYChjb250ZXh0LCBzdGF2ZSwgbm90ZXMsIHthbGlnbl9yZXN0czogdHJ1ZX0pYFxuICAvLyAgICAqIFNldHRpbmcgYm90aCBhIHN0cnVjdCBpcyBuZWVkZWQgYChjb250ZXh0LCBzdGF2ZSwgbm90ZXMsIHthdXRvYmVhbTogdHJ1ZSwgYWxpZ25fcmVzdHM6IHRydWV9KWBcbiAgLy9cbiAgLy8gYGF1dG9iZWFtYCBhdXRvbWF0aWNhbGx5IGdlbmVyYXRlcyBiZWFtcyBmb3IgdGhlIG5vdGVzLlxuICAvLyBgYWxpZ25fcmVzdHNgIGFsaWducyByZXN0cyB3aXRoIG5lYXJieSBub3Rlcy5cbiAgRm9ybWF0dGVyLkZvcm1hdEFuZERyYXcgPSBmdW5jdGlvbihjdHgsIHN0YXZlLCBub3RlcywgcGFyYW1zKSB7XG4gICAgdmFyIG9wdHMgPSB7XG4gICAgICBhdXRvX2JlYW06IGZhbHNlLFxuICAgICAgYWxpZ25fcmVzdHM6IGZhbHNlXG4gICAgfTtcblxuICAgIGlmICh0eXBlb2YgcGFyYW1zID09IFwib2JqZWN0XCIpIHtcbiAgICAgIFZleC5NZXJnZShvcHRzLCBwYXJhbXMpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBhcmFtcyA9PSBcImJvb2xlYW5cIikge1xuICAgICAgb3B0cy5hdXRvX2JlYW0gPSBwYXJhbXM7XG4gICAgfVxuXG4gICAgLy8gU3RhcnQgYnkgY3JlYXRpbmcgYSB2b2ljZSBhbmQgYWRkaW5nIGFsbCB0aGUgbm90ZXMgdG8gaXQuXG4gICAgdmFyIHZvaWNlID0gbmV3IFZleC5GbG93LlZvaWNlKFZleC5GbG93LlRJTUU0XzQpLlxuICAgICAgc2V0TW9kZShWZXguRmxvdy5Wb2ljZS5Nb2RlLlNPRlQpO1xuICAgIHZvaWNlLmFkZFRpY2thYmxlcyhub3Rlcyk7XG5cbiAgICAvLyBUaGVuIGNyZWF0ZSBiZWFtcywgaWYgcmVxdWVzdGVkLlxuICAgIHZhciBiZWFtcyA9IG51bGw7XG4gICAgaWYgKG9wdHMuYXV0b19iZWFtKSB7XG4gICAgICBiZWFtcyA9IFZleC5GbG93LkJlYW0uYXBwbHlBbmRHZXRCZWFtcyh2b2ljZSk7XG4gICAgfVxuXG4gICAgLy8gSW5zdGFudGlhdGUgYSBgRm9ybWF0dGVyYCBhbmQgZm9ybWF0IHRoZSBub3Rlcy5cbiAgICBuZXcgRm9ybWF0dGVyKCkuXG4gICAgICBqb2luVm9pY2VzKFt2b2ljZV0sIHthbGlnbl9yZXN0czogb3B0cy5hbGlnbl9yZXN0c30pLlxuICAgICAgZm9ybWF0VG9TdGF2ZShbdm9pY2VdLCBzdGF2ZSwge2FsaWduX3Jlc3RzOiBvcHRzLmFsaWduX3Jlc3RzfSk7XG5cbiAgICAvLyBSZW5kZXIgdGhlIHZvaWNlIGFuZCBiZWFtcyB0byB0aGUgc3RhdmUuXG4gICAgdm9pY2Uuc2V0U3RhdmUoc3RhdmUpO1xuICAgIHZvaWNlLmRyYXcoY3R4LCBzdGF2ZSk7XG4gICAgaWYgKGJlYW1zICE9IG51bGwpIHtcbiAgICAgIGZvciAodmFyIGk9MDsgaTxiZWFtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBiZWFtc1tpXS5zZXRDb250ZXh0KGN0eCkuZHJhdygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiB0aGUgYm91bmRpbmcgYm94IG9mIHRoZSB2b2ljZS5cbiAgICByZXR1cm4gdm9pY2UuZ2V0Qm91bmRpbmdCb3goKTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZnVuY3Rpb24gdG8gZm9ybWF0IGFuZCBkcmF3IGFsaWduZWQgdGFiIGFuZCBzdGF2ZSBub3RlcyBpbiB0d29cbiAgLy8gc2VwYXJhdGUgc3RhdmVzLlxuICAvL1xuICAvLyBQYXJhbWV0ZXJzOlxuICAvLyAqIGBjdHhgIC0gVGhlIHJlbmRlcmluZyBjb250ZXh0XG4gIC8vICogYHRhYnN0YXZlYCAtIEEgYFRhYlN0YXZlYCBpbnN0YW5jZSBvbiB3aGljaCB0byByZW5kZXIgYFRhYk5vdGVgcy5cbiAgLy8gKiBgc3RhdmVgIC0gQSBgU3RhdmVgIGluc3RhbmNlIG9uIHdoaWNoIHRvIHJlbmRlciBgTm90ZWBzLlxuICAvLyAqIGBub3Rlc2AgLSBBcnJheSBvZiBgTm90ZWAgaW5zdGFuY2VzIGZvciB0aGUgc3RhdmUgKGBTdGF2ZU5vdGVgLCBgQmFyTm90ZWAsIGV0Yy4pXG4gIC8vICogYHRhYm5vdGVzYCAtIEFycmF5IG9mIGBOb3RlYCBpbnN0YW5jZXMgZm9yIHRoZSB0YWIgc3RhdmUgKGBUYWJOb3RlYCwgYEJhck5vdGVgLCBldGMuKVxuICAvLyAqIGBhdXRvYmVhbWAgLSBBdXRvbWF0aWNhbGx5IGdlbmVyYXRlIGJlYW1zLlxuICAvLyAqIGBwYXJhbXNgIC0gQSBjb25maWd1cmF0aW9uIG9iamVjdDpcbiAgLy8gICAgKiBgYXV0b2JlYW1gIGF1dG9tYXRpY2FsbHkgZ2VuZXJhdGVzIGJlYW1zIGZvciB0aGUgbm90ZXMuXG4gIC8vICAgICogYGFsaWduX3Jlc3RzYCBhbGlnbnMgcmVzdHMgd2l0aCBuZWFyYnkgbm90ZXMuXG4gIEZvcm1hdHRlci5Gb3JtYXRBbmREcmF3VGFiID0gZnVuY3Rpb24oY3R4LFxuICAgICAgdGFic3RhdmUsIHN0YXZlLCB0YWJub3Rlcywgbm90ZXMsIGF1dG9iZWFtLCBwYXJhbXMpIHtcbiAgICB2YXIgb3B0cyA9IHtcbiAgICAgIGF1dG9fYmVhbTogYXV0b2JlYW0sXG4gICAgICBhbGlnbl9yZXN0czogZmFsc2VcbiAgICB9O1xuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gXCJvYmplY3RcIikge1xuICAgICAgVmV4Lk1lcmdlKG9wdHMsIHBhcmFtcyk7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgcGFyYW1zID09IFwiYm9vbGVhblwiKSB7XG4gICAgICBvcHRzLmF1dG9fYmVhbSA9IHBhcmFtcztcbiAgICB9XG5cbiAgICAvLyBDcmVhdGUgYSBgNC80YCB2b2ljZSBmb3IgYG5vdGVzYC5cbiAgICB2YXIgbm90ZXZvaWNlID0gbmV3IFZleC5GbG93LlZvaWNlKFZleC5GbG93LlRJTUU0XzQpLlxuICAgICAgc2V0TW9kZShWZXguRmxvdy5Wb2ljZS5Nb2RlLlNPRlQpO1xuICAgIG5vdGV2b2ljZS5hZGRUaWNrYWJsZXMobm90ZXMpO1xuXG4gICAgLy8gQ3JlYXRlIGEgYDQvNGAgdm9pY2UgZm9yIGB0YWJub3Rlc2AuXG4gICAgdmFyIHRhYnZvaWNlID0gbmV3IFZleC5GbG93LlZvaWNlKFZleC5GbG93LlRJTUU0XzQpLlxuICAgICAgc2V0TW9kZShWZXguRmxvdy5Wb2ljZS5Nb2RlLlNPRlQpO1xuICAgIHRhYnZvaWNlLmFkZFRpY2thYmxlcyh0YWJub3Rlcyk7XG5cbiAgICAvLyBHZW5lcmF0ZSBiZWFtcyBpZiByZXF1ZXN0ZWQuXG4gICAgdmFyIGJlYW1zID0gbnVsbDtcbiAgICBpZiAob3B0cy5hdXRvX2JlYW0pIHtcbiAgICAgIGJlYW1zID0gVmV4LkZsb3cuQmVhbS5hcHBseUFuZEdldEJlYW1zKG5vdGV2b2ljZSk7XG4gICAgfVxuXG5cbiAgICAvLyBJbnN0YW50aWF0ZSBhIGBGb3JtYXR0ZXJgIGFuZCBhbGlnbiB0YWIgYW5kIHN0YXZlIG5vdGVzLlxuICAgIG5ldyBGb3JtYXR0ZXIoKS5cbiAgICAgIGpvaW5Wb2ljZXMoW25vdGV2b2ljZV0sIHthbGlnbl9yZXN0czogb3B0cy5hbGlnbl9yZXN0c30pLlxuICAgICAgam9pblZvaWNlcyhbdGFidm9pY2VdKS5cbiAgICAgIGZvcm1hdFRvU3RhdmUoW25vdGV2b2ljZSx0YWJ2b2ljZV0sIHN0YXZlLCB7YWxpZ25fcmVzdHM6IG9wdHMuYWxpZ25fcmVzdHN9KTtcblxuICAgIC8vIFJlbmRlciB2b2ljZXMgYW5kIGJlYW1zIHRvIHN0YXZlcy5cbiAgICBub3Rldm9pY2UuZHJhdyhjdHgsIHN0YXZlKTtcbiAgICB0YWJ2b2ljZS5kcmF3KGN0eCwgdGFic3RhdmUpO1xuICAgIGlmIChiZWFtcyAhPSBudWxsKSB7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8YmVhbXMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYmVhbXNbaV0uc2V0Q29udGV4dChjdHgpLmRyYXcoKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBEcmF3IGEgY29ubmVjdG9yIGJldHdlZW4gdGFiIGFuZCBub3RlIHN0YXZlcy5cbiAgICAobmV3IFZleC5GbG93LlN0YXZlQ29ubmVjdG9yKHN0YXZlLCB0YWJzdGF2ZSkpLnNldENvbnRleHQoY3R4KS5kcmF3KCk7XG4gIH07XG5cbiAgLy8gQXV0byBwb3NpdGlvbiByZXN0cyBiYXNlZCBvbiBwcmV2aW91cy9uZXh0IG5vdGUgcG9zaXRpb25zLlxuICAvL1xuICAvLyBQYXJhbXM6XG4gIC8vICogYG5vdGVzYDogQW4gYXJyYXkgb2Ygbm90ZXMuXG4gIC8vICogYGFsaWduX2FsbF9ub3Rlc2A6IElmIHNldCB0byBmYWxzZSwgb25seSBhbGlnbnMgbm9uLWJlYW1lZCBub3Rlcy5cbiAgLy8gKiBgYWxpZ25fdHVwbGV0c2A6IElmIHNldCB0byBmYWxzZSwgaWdub3JlcyB0dXBsZXRzLlxuICBGb3JtYXR0ZXIuQWxpZ25SZXN0c1RvTm90ZXMgPSBmdW5jdGlvbihub3RlcywgYWxpZ25fYWxsX25vdGVzLCBhbGlnbl90dXBsZXRzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub3Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgaWYgKG5vdGVzW2ldIGluc3RhbmNlb2YgVmV4LkZsb3cuU3RhdmVOb3RlICYmIG5vdGVzW2ldLmlzUmVzdCgpKSB7XG4gICAgICAgIHZhciBub3RlID0gbm90ZXNbaV07XG5cbiAgICAgICAgaWYgKG5vdGUudHVwbGV0ICYmICFhbGlnbl90dXBsZXRzKSBjb250aW51ZTtcblxuICAgICAgICAvLyBJZiBhY3RpdmF0ZWQgcmVzdHMgbm90IG9uIGRlZmF1bHQgY2FuIGJlIHJlbmRlcmVkIGFzIHNwZWNpZmllZC5cbiAgICAgICAgdmFyIHBvc2l0aW9uID0gbm90ZS5nZXRHbHlwaCgpLnBvc2l0aW9uLnRvVXBwZXJDYXNlKCk7XG4gICAgICAgIGlmIChwb3NpdGlvbiAhPSBcIlIvNFwiICYmIHBvc2l0aW9uICE9IFwiQi80XCIpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChhbGlnbl9hbGxfbm90ZXMgfHwgbm90ZS5iZWFtICE9IG51bGwpIHtcbiAgICAgICAgICAvLyBBbGlnbiByZXN0cyB3aXRoIHByZXZpb3VzL25leHQgbm90ZXMuXG4gICAgICAgICAgdmFyIHByb3BzID0gbm90ZS5nZXRLZXlQcm9wcygpWzBdO1xuICAgICAgICAgIGlmIChpID09PSAwKSB7XG4gICAgICAgICAgICBwcm9wcy5saW5lID0gbG9va0FoZWFkKG5vdGVzLCBwcm9wcy5saW5lLCBpLCBmYWxzZSk7XG4gICAgICAgICAgICBub3RlLnNldEtleUxpbmUoMCwgcHJvcHMubGluZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChpID4gMCAmJiBpIDwgbm90ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAvLyBJZiBwcmV2aW91cyBub3RlIGlzIGEgcmVzdCwgdXNlIGl0cyBsaW5lIG51bWJlci5cbiAgICAgICAgICAgIHZhciByZXN0X2xpbmU7XG4gICAgICAgICAgICBpZiAobm90ZXNbaS0xXS5pc1Jlc3QoKSkge1xuICAgICAgICAgICAgICByZXN0X2xpbmUgPSBub3Rlc1tpLTFdLmdldEtleVByb3BzKClbMF0ubGluZTtcbiAgICAgICAgICAgICAgcHJvcHMubGluZSA9IHJlc3RfbGluZTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3RfbGluZSA9IG5vdGVzW2ktMV0uZ2V0TGluZUZvclJlc3QoKTtcbiAgICAgICAgICAgICAgLy8gR2V0IHRoZSByZXN0IGxpbmUgZm9yIG5leHQgdmFsaWQgbm9uLXJlc3Qgbm90ZSBncm91cC5cbiAgICAgICAgICAgICAgcHJvcHMubGluZSA9IGxvb2tBaGVhZChub3RlcywgcmVzdF9saW5lLCBpLCB0cnVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG5vdGUuc2V0S2V5TGluZSgwLCBwcm9wcy5saW5lKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICBGb3JtYXR0ZXIucHJvdG90eXBlID0ge1xuICAgIC8vIEZpbmQgYWxsIHRoZSByZXN0cyBpbiBlYWNoIG9mIHRoZSBgdm9pY2VzYCBhbmQgYWxpZ24gdGhlbVxuICAgIC8vIHRvIG5laWdoYm9yaW5nIG5vdGVzLiBJZiBgYWxpZ25fYWxsX25vdGVzYCBpcyBgZmFsc2VgLCB0aGVuIG9ubHlcbiAgICAvLyBhbGlnbiBub24tYmVhbWVkIG5vdGVzLlxuICAgIGFsaWduUmVzdHM6IGZ1bmN0aW9uKHZvaWNlcywgYWxpZ25fYWxsX25vdGVzKSB7XG4gICAgICBpZiAoIXZvaWNlcyB8fCAhdm9pY2VzLmxlbmd0aCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRcIixcbiAgICAgICAgICBcIk5vIHZvaWNlcyB0byBmb3JtYXQgcmVzdHNcIik7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZvaWNlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBuZXcgRm9ybWF0dGVyLkFsaWduUmVzdHNUb05vdGVzKHZvaWNlc1tpXS50aWNrYWJsZXMsIGFsaWduX2FsbF9ub3Rlcyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIENhbGN1bGF0ZSB0aGUgbWluaW11bSB3aWR0aCByZXF1aXJlZCB0byBhbGlnbiBhbmQgZm9ybWF0IGB2b2ljZXNgLlxuICAgIHByZUNhbGN1bGF0ZU1pblRvdGFsV2lkdGg6IGZ1bmN0aW9uKHZvaWNlcykge1xuICAgICAgLy8gQ2FjaGUgcmVzdWx0cy5cbiAgICAgIGlmICh0aGlzLmhhc01pblRvdGFsV2lkdGgpIHJldHVybjtcblxuICAgICAgLy8gQ3JlYXRlIHRpY2sgY29udGV4dHMgaWYgbm90IGFscmVhZHkgY3JlYXRlZC5cbiAgICAgIGlmICghdGhpcy50Q29udGV4dHMpIHtcbiAgICAgICAgaWYgKCF2b2ljZXMpIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIid2b2ljZXMnIHJlcXVpcmVkIHRvIHJ1biBwcmVDYWxjdWxhdGVNaW5Ub3RhbFdpZHRoXCIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY3JlYXRlVGlja0NvbnRleHRzKHZvaWNlcyk7XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0cyA9IHRoaXMudENvbnRleHRzO1xuICAgICAgdmFyIGNvbnRleHRMaXN0ID0gY29udGV4dHMubGlzdDtcbiAgICAgIHZhciBjb250ZXh0TWFwID0gY29udGV4dHMubWFwO1xuXG4gICAgICB0aGlzLm1pblRvdGFsV2lkdGggPSAwO1xuXG4gICAgICAvLyBHbyB0aHJvdWdoIGVhY2ggdGljayBjb250ZXh0IGFuZCBjYWxjdWxhdGUgdG90YWwgd2lkdGguXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNvbnRleHRMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gY29udGV4dE1hcFtjb250ZXh0TGlzdFtpXV07XG5cbiAgICAgICAgLy8gYHByZUZvcm1hdGAgZ2V0cyB0aGVtIHRvIGRlc2NlbmQgZG93biB0byB0aGVpciB0aWNrYWJsZXMgYW5kIG1vZGlmaWVyXG4gICAgICAgIC8vIGNvbnRleHRzLCBhbmQgY2FsY3VsYXRlIHRoZWlyIHdpZHRocy5cbiAgICAgICAgY29udGV4dC5wcmVGb3JtYXQoKTtcbiAgICAgICAgdGhpcy5taW5Ub3RhbFdpZHRoICs9IGNvbnRleHQuZ2V0V2lkdGgoKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5oYXNNaW5Ub3RhbFdpZHRoID0gdHJ1ZTtcblxuICAgICAgcmV0dXJuIHRoaXMubWluVG90YWxXaWR0aDtcbiAgICB9LFxuXG4gICAgLy8gR2V0IG1pbmltdW0gd2lkdGggcmVxdWlyZWQgdG8gcmVuZGVyIGFsbCB2b2ljZXMuIEVpdGhlciBgZm9ybWF0YCBvclxuICAgIC8vIGBwcmVDYWxjdWxhdGVNaW5Ub3RhbFdpZHRoYCBtdXN0IGJlIGNhbGxlZCBiZWZvcmUgdGhpcyBtZXRob2QuXG4gICAgZ2V0TWluVG90YWxXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuaGFzTWluVG90YWxXaWR0aCkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb01pblRvdGFsV2lkdGhcIixcbiAgICAgICAgICAgIFwiTmVlZCB0byBjYWxsICdwcmVDYWxjdWxhdGVNaW5Ub3RhbFdpZHRoJyBvciAncHJlRm9ybWF0JyBiZWZvcmVcIiArXG4gICAgICAgICAgICBcIiBjYWxsaW5nICdnZXRNaW5Ub3RhbFdpZHRoJ1wiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMubWluVG90YWxXaWR0aDtcbiAgICB9LFxuXG4gICAgLy8gQ3JlYXRlIGBNb2RpZmllckNvbnRleHRgcyBmb3IgZWFjaCB0aWNrIGluIGB2b2ljZXNgLlxuICAgIGNyZWF0ZU1vZGlmaWVyQ29udGV4dHM6IGZ1bmN0aW9uKHZvaWNlcykge1xuICAgICAgdmFyIGNvbnRleHRzID0gY3JlYXRlQ29udGV4dHModm9pY2VzLFxuICAgICAgICAgIFZleC5GbG93Lk1vZGlmaWVyQ29udGV4dCxcbiAgICAgICAgICBmdW5jdGlvbih0aWNrYWJsZSwgY29udGV4dCkge1xuICAgICAgICAgICAgdGlja2FibGUuYWRkVG9Nb2RpZmllckNvbnRleHQoY29udGV4dCk7XG4gICAgICAgICAgfSk7XG4gICAgICB0aGlzLm1Db250ZXh0cyA9IGNvbnRleHRzO1xuICAgICAgcmV0dXJuIGNvbnRleHRzO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYFRpY2tDb250ZXh0YHMgZm9yIGVhY2ggdGljayBpbiBgdm9pY2VzYC4gQWxzbyBjYWxjdWxhdGUgdGhlXG4gICAgLy8gdG90YWwgbnVtYmVyIG9mIHRpY2tzIGluIHZvaWNlcy5cbiAgICBjcmVhdGVUaWNrQ29udGV4dHM6IGZ1bmN0aW9uKHZvaWNlcykge1xuICAgICAgdmFyIGNvbnRleHRzID0gY3JlYXRlQ29udGV4dHModm9pY2VzLFxuICAgICAgICAgIFZleC5GbG93LlRpY2tDb250ZXh0LFxuICAgICAgICAgIGZ1bmN0aW9uKHRpY2thYmxlLCBjb250ZXh0KSB7IGNvbnRleHQuYWRkVGlja2FibGUodGlja2FibGUpOyB9KTtcblxuICAgICAgY29udGV4dHMuYXJyYXkuZm9yRWFjaChmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICAgIGNvbnRleHQudENvbnRleHRzID0gY29udGV4dHMuYXJyYXk7XG4gICAgICB9KTtcblxuICAgICAgdGhpcy50b3RhbFRpY2tzID0gdm9pY2VzWzBdLmdldFRpY2tzVXNlZCgpLmNsb25lKCk7XG4gICAgICB0aGlzLnRDb250ZXh0cyA9IGNvbnRleHRzO1xuICAgICAgcmV0dXJuIGNvbnRleHRzO1xuICAgIH0sXG5cbiAgICAvLyBUaGlzIGlzIHRoZSBjb3JlIGZvcm1hdHRlciBsb2dpYy4gRm9ybWF0IHZvaWNlcyBhbmQganVzdGlmeSB0aGVtXG4gICAgLy8gdG8gYGp1c3RpZnlXaWR0aGAgcGl4ZWxzLiBgcmVuZGVyaW5nX2NvbnRleHRgIGlzIHJlcXVpcmVkIHRvIGp1c3RpZnkgZWxlbWVudHNcbiAgICAvLyB0aGF0IGNhbid0IHJldHJlaXZlIHdpZHRocyB3aXRob3V0IGEgY2FudmFzLiBUaGlzIG1ldGhvZCBzZXRzIHRoZSBgeGAgcG9zaXRpb25zXG4gICAgLy8gb2YgYWxsIHRoZSB0aWNrYWJsZXMvbm90ZXMgaW4gdGhlIGZvcm1hdHRlci5cbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKGp1c3RpZnlXaWR0aCwgcmVuZGVyaW5nX2NvbnRleHQsIHZvaWNlcywgc3RhdmUpIHtcbiAgICAgIC8vIEluaXRpYWxpemUgY29udGV4dCBtYXBzLlxuICAgICAgdmFyIGNvbnRleHRzID0gdGhpcy50Q29udGV4dHM7XG4gICAgICB2YXIgY29udGV4dExpc3QgPSBjb250ZXh0cy5saXN0O1xuICAgICAgdmFyIGNvbnRleHRNYXAgPSBjb250ZXh0cy5tYXA7XG5cbiAgICAgIC8vIElmIHZvaWNlcyBhbmQgYSBzdGF2ZSB3ZXJlIHByb3ZpZGVkLCBzZXQgdGhlIFN0YXZlIGZvciBlYWNoIHZvaWNlXG4gICAgICAvLyBhbmQgcHJlRm9ybWF0IHRvIGFwcGx5IFkgdmFsdWVzIHRvIHRoZSBub3RlcztcbiAgICAgIGlmICh2b2ljZXMgJiYgc3RhdmUpIHtcbiAgICAgICAgdm9pY2VzLmZvckVhY2goZnVuY3Rpb24odm9pY2UpIHtcbiAgICAgICAgICB2b2ljZS5zZXRTdGF2ZShzdGF2ZSk7XG4gICAgICAgICAgdm9pY2UucHJlRm9ybWF0KCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBGaWd1cmUgb3V0IGhvdyBtYW55IHBpeGVscyB0byBhbGxvY2F0ZSBwZXIgdGljay5cbiAgICAgIGlmICghanVzdGlmeVdpZHRoKSB7XG4gICAgICAgIGp1c3RpZnlXaWR0aCA9IDA7XG4gICAgICAgIHRoaXMucGl4ZWxzUGVyVGljayA9IDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBpeGVsc1BlclRpY2sgPSBqdXN0aWZ5V2lkdGggLyAodGhpcy50b3RhbFRpY2tzLnZhbHVlKCkgKiBjb250ZXh0cy5yZXNvbHV0aW9uTXVsdGlwbGllcik7XG4gICAgICB9XG5cbiAgICAgIC8vIE5vdyBkaXN0cmlidXRlIHRoZSB0aWNrcyB0byBlYWNoIHRpY2sgY29udGV4dCwgYW5kIGFzc2lnbiB0aGVtIHRoZWlyXG4gICAgICAvLyBvd24gWCBwb3NpdGlvbnMuXG4gICAgICB2YXIgeCA9IDA7XG4gICAgICB2YXIgY2VudGVyX3ggPSBqdXN0aWZ5V2lkdGggLyAyO1xuICAgICAgdmFyIHdoaXRlX3NwYWNlID0gMDsgLy8gV2hpdGUgc3BhY2UgdG8gcmlnaHQgb2YgcHJldmlvdXMgbm90ZVxuICAgICAgdmFyIHRpY2tfc3BhY2UgPSAwOyAgLy8gUGl4ZWxzIGZyb20gcHJldiBub3RlIHgtcG9zIHRvIGN1cmVudCBub3RlIHgtcG9zXG4gICAgICB2YXIgcHJldl90aWNrID0gMDtcbiAgICAgIHZhciBwcmV2X3dpZHRoID0gMDtcbiAgICAgIHZhciBsYXN0TWV0cmljcyA9IG51bGw7XG4gICAgICB2YXIgaW5pdGlhbF9qdXN0aWZ5X3dpZHRoID0ganVzdGlmeVdpZHRoO1xuICAgICAgdGhpcy5taW5Ub3RhbFdpZHRoID0gMDtcblxuICAgICAgdmFyIGksIHRpY2ssIGNvbnRleHQ7XG5cbiAgICAgIC8vIFBhc3MgMTogR2l2ZSBlYWNoIG5vdGUgbWF4aW11bSB3aWR0aCByZXF1ZXN0ZWQgYnkgY29udGV4dC5cbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250ZXh0TGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICB0aWNrID0gY29udGV4dExpc3RbaV07XG4gICAgICAgIGNvbnRleHQgPSBjb250ZXh0TWFwW3RpY2tdO1xuICAgICAgICBpZiAocmVuZGVyaW5nX2NvbnRleHQpIGNvbnRleHQuc2V0Q29udGV4dChyZW5kZXJpbmdfY29udGV4dCk7XG5cbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoYXQgYWxsIHRpY2thYmxlcyBpbiB0aGlzIGNvbnRleHQgaGF2ZSBjYWxjdWxhdGVkIHRoZWlyXG4gICAgICAgIC8vIHNwYWNlIHJlcXVpcmVtZW50cy5cbiAgICAgICAgY29udGV4dC5wcmVGb3JtYXQoKTtcblxuICAgICAgICB2YXIgdGhpc01ldHJpY3MgPSBjb250ZXh0LmdldE1ldHJpY3MoKTtcbiAgICAgICAgdmFyIHdpZHRoID0gY29udGV4dC5nZXRXaWR0aCgpO1xuICAgICAgICB0aGlzLm1pblRvdGFsV2lkdGggKz0gd2lkdGg7XG4gICAgICAgIHZhciBtaW5feCA9IDA7XG4gICAgICAgIHZhciBwaXhlbHNfdXNlZCA9IHdpZHRoO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSBzcGFjZSBiZXR3ZWVuIGxhc3Qgbm90ZSBhbmQgbmV4dCBub3RlLlxuICAgICAgICB0aWNrX3NwYWNlID0gTWF0aC5taW4oKHRpY2sgLSBwcmV2X3RpY2spICogdGhpcy5waXhlbHNQZXJUaWNrLCBwaXhlbHNfdXNlZCk7XG5cbiAgICAgICAgLy8gU2hpZnQgbmV4dCBub3RlIHVwIGB0aWNrX3NwYWNlYCBwaXhlbHMuXG4gICAgICAgIHZhciBzZXRfeCA9IHggKyB0aWNrX3NwYWNlO1xuXG4gICAgICAgIC8vIENhbGN1bGF0ZSB0aGUgbWluaW11bSBuZXh0IG5vdGUgcG9zaXRpb24gdG8gYWxsb3cgZm9yIHJpZ2h0IG1vZGlmaWVycy5cbiAgICAgICAgaWYgKGxhc3RNZXRyaWNzICE9IG51bGwpIHtcbiAgICAgICAgICBtaW5feCA9IHggKyBwcmV2X3dpZHRoIC0gbGFzdE1ldHJpY3MuZXh0cmFMZWZ0UHg7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgdGhlIHNwYWNlIHJlcXVpcmVkIGZvciB0aGUgcHJldmlvdXMgdGljay5cbiAgICAgICAgLy8gVGhlIGBzaG91bGRJZ25vcmVUaWNrc2AgYm9vbCBpcyB0cnVlIGZvciBlbGVtZW50cyBpbiB0aGUgc3RhdmVcbiAgICAgICAgLy8gdGhhdCBkb24ndCBjb25zdW1lIHRpY2tzIChiYXIgbGluZXMsIGtleSBhbmQgdGltZSBzaWduYXR1cmVzLCBldGMuKVxuICAgICAgICBzZXRfeCA9IGNvbnRleHQuc2hvdWxkSWdub3JlVGlja3MoKSA/XG4gICAgICAgICAgICAobWluX3ggKyBjb250ZXh0LmdldFdpZHRoKCkpIDogTWF0aC5tYXgoc2V0X3gsIG1pbl94KTtcblxuICAgICAgICBpZiAoY29udGV4dC5zaG91bGRJZ25vcmVUaWNrcygpICYmIGp1c3RpZnlXaWR0aCkge1xuICAgICAgICAgICAgLy8gVGhpcyBub3RlIHN0b2xlIHJvb20uLi4gcmVjYWxjdWxhdGUgd2l0aCBuZXcganVzdGlmaWNhdGlvbiB3aWR0aC5cbiAgICAgICAgICAgIGp1c3RpZnlXaWR0aCAtPSBjb250ZXh0LmdldFdpZHRoKCk7XG4gICAgICAgICAgICB0aGlzLnBpeGVsc1BlclRpY2sgPSBqdXN0aWZ5V2lkdGggL1xuICAgICAgICAgICAgICAodGhpcy50b3RhbFRpY2tzLnZhbHVlKCkgKiBjb250ZXh0cy5yZXNvbHV0aW9uTXVsdGlwbGllcik7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBEZXRlcm1pbmUgcGl4ZWxzIG5lZWRlZCBmb3IgbGVmdCBtb2RpZmllcnMuXG4gICAgICAgIHZhciBsZWZ0X3B4ID0gdGhpc01ldHJpY3MuZXh0cmFMZWZ0UHg7XG5cbiAgICAgICAgLy8gRGV0ZXJtaW5lIHdoaXRlIHNwYWNlIHRvIHJpZ2h0IG9mIHByZXZpb3VzIHRpY2sgKGZyb20gcmlnaHQgbW9kaWZpZXJzLilcbiAgICAgICAgaWYgKGxhc3RNZXRyaWNzICE9IG51bGwpIHtcbiAgICAgICAgICB3aGl0ZV9zcGFjZSA9IChzZXRfeCAtIHgpIC0gKHByZXZfd2lkdGggLVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGFzdE1ldHJpY3MuZXh0cmFMZWZ0UHgpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRGVkdWN0IHBpeGVscyBmcm9tIHdoaXRlIHNwYWNlIHF1b3RhLlxuICAgICAgICBpZiAoaSA+IDApIHtcbiAgICAgICAgICBpZiAod2hpdGVfc3BhY2UgPiAwKSB7XG4gICAgICAgICAgICBpZiAod2hpdGVfc3BhY2UgPj0gbGVmdF9weCkge1xuICAgICAgICAgICAgICAvLyBIYXZlIGVub3VnaCB3aGl0ZSBzcGFjZSBmb3IgbGVmdCBtb2RpZmllcnMgLSBubyBvZmZzZXQgbmVlZGVkLlxuICAgICAgICAgICAgICBsZWZ0X3B4ID0gMDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIC8vIERlY3JlYXNlIGxlZnQgbW9kaWZpZXIgb2Zmc2V0IGJ5IGFtb3VudCBvZiB3aGl0ZSBzcGFjZS5cbiAgICAgICAgICAgICAgbGVmdF9weCAtPSB3aGl0ZV9zcGFjZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGp1c3QgdGhlIHRpY2sgeCBwb3NpdGlvbiB3aXRoIHRoZSBsZWZ0IG1vZGlmaWVyIG9mZnNldC5cbiAgICAgICAgc2V0X3ggKz0gbGVmdF9weDtcblxuICAgICAgICAvLyBTZXQgdGhlIGB4YCB2YWx1ZSBmb3IgdGhlIGNvbnRleHQsIHdoaWNoIHNldHMgdGhlIGB4YCB2YWx1ZSBmb3IgYWxsXG4gICAgICAgIC8vIHRpY2thYmxlcyBpbiB0aGlzIGNvbnRleHQuXG4gICAgICAgIGNvbnRleHQuc2V0WChzZXRfeCk7XG4gICAgICAgIGNvbnRleHQuc2V0UGl4ZWxzVXNlZChwaXhlbHNfdXNlZCk7ICAvLyA/Pz8gUmVtb3ZlIHRoaXMgaWYgbm90aGluZyBicmVha3NcblxuICAgICAgICBsYXN0TWV0cmljcyA9IHRoaXNNZXRyaWNzO1xuICAgICAgICBwcmV2X3dpZHRoID0gd2lkdGg7XG4gICAgICAgIHByZXZfdGljayA9IHRpY2s7XG4gICAgICAgIHggPSBzZXRfeDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5oYXNNaW5Ub3RhbFdpZHRoID0gdHJ1ZTtcbiAgICAgIGlmIChqdXN0aWZ5V2lkdGggPiAwKSB7XG4gICAgICAgIC8vIFBhc3MgMjogVGFrZSBsZWZ0b3ZlciB3aWR0aCwgYW5kIGRpc3RyaWJ1dGUgaXQgdG8gcHJvcG9ydGlvbmF0ZWx5IHRvXG4gICAgICAgIC8vIGFsbCBub3Rlcy5cbiAgICAgICAgdmFyIHJlbWFpbmluZ194ID0gaW5pdGlhbF9qdXN0aWZ5X3dpZHRoIC0gKHggKyBwcmV2X3dpZHRoKTtcbiAgICAgICAgdmFyIGxlZnRvdmVyX3BpeGVsc19wZXJfdGljayA9IHJlbWFpbmluZ194IC8gKHRoaXMudG90YWxUaWNrcy52YWx1ZSgpICogY29udGV4dHMucmVzb2x1dGlvbk11bHRpcGxpZXIpO1xuICAgICAgICB2YXIgYWNjdW11bGF0ZWRfc3BhY2UgPSAwO1xuICAgICAgICBwcmV2X3RpY2sgPSAwO1xuXG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjb250ZXh0TGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHRpY2sgPSBjb250ZXh0TGlzdFtpXTtcbiAgICAgICAgICBjb250ZXh0ID0gY29udGV4dE1hcFt0aWNrXTtcbiAgICAgICAgICB0aWNrX3NwYWNlID0gKHRpY2sgLSBwcmV2X3RpY2spICogbGVmdG92ZXJfcGl4ZWxzX3Blcl90aWNrO1xuICAgICAgICAgIGFjY3VtdWxhdGVkX3NwYWNlID0gYWNjdW11bGF0ZWRfc3BhY2UgKyB0aWNrX3NwYWNlO1xuICAgICAgICAgIGNvbnRleHQuc2V0WChjb250ZXh0LmdldFgoKSArIGFjY3VtdWxhdGVkX3NwYWNlKTtcbiAgICAgICAgICBwcmV2X3RpY2sgPSB0aWNrO1xuXG4gICAgICAgICAgLy8gTW92ZSBjZW50ZXIgYWxpZ25lZCB0aWNrYWJsZXMgdG8gbWlkZGxlXG4gICAgICAgICAgdmFyIGNlbnRlcmVkVGlja2FibGVzID0gY29udGV4dC5nZXRDZW50ZXJBbGlnbmVkVGlja2FibGVzKCk7XG5cbiAgICAgICAgICAvKmpzaGludCAtVzA4MyAqL1xuICAgICAgICAgIGNlbnRlcmVkVGlja2FibGVzLmZvckVhY2goZnVuY3Rpb24odGlja2FibGUpIHtcbiAgICAgICAgICAgIHRpY2thYmxlLmNlbnRlcl94X3NoaWZ0ID0gY2VudGVyX3ggLSBjb250ZXh0LmdldFgoKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyBUaGlzIGlzIHRoZSB0b3AtbGV2ZWwgY2FsbCBmb3IgYWxsIGZvcm1hdHRpbmcgbG9naWMgY29tcGxldGVkXG4gICAgLy8gYWZ0ZXIgYHhgICphbmQqIGB5YCB2YWx1ZXMgaGF2ZSBiZWVuIGNvbXB1dGVkIGZvciB0aGUgbm90ZXNcbiAgICAvLyBpbiB0aGUgdm9pY2VzLlxuICAgIHBvc3RGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gUG9zdGZvcm1hdCBtb2RpZmllciBjb250ZXh0c1xuICAgICAgdGhpcy5tQ29udGV4dHMubGlzdC5mb3JFYWNoKGZ1bmN0aW9uKG1Db250ZXh0KSB7XG4gICAgICAgIHRoaXMubUNvbnRleHRzLm1hcFttQ29udGV4dF0ucG9zdEZvcm1hdCgpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIC8vIFBvc3Rmb3JtYXQgdGljayBjb250ZXh0c1xuICAgICAgdGhpcy50Q29udGV4dHMubGlzdC5mb3JFYWNoKGZ1bmN0aW9uKHRDb250ZXh0KSB7XG4gICAgICAgIHRoaXMudENvbnRleHRzLm1hcFt0Q29udGV4dF0ucG9zdEZvcm1hdCgpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBUYWtlIGFsbCBgdm9pY2VzYCBhbmQgY3JlYXRlIGBNb2RpZmllckNvbnRleHRgcyBvdXQgb2YgdGhlbS4gVGhpcyB0ZWxsc1xuICAgIC8vIHRoZSBmb3JtYXR0ZXJzIHRoYXQgdGhlIHZvaWNlcyBiZWxvbmcgb24gYSBzaW5nbGUgc3RhdmUuXG4gICAgam9pblZvaWNlczogZnVuY3Rpb24odm9pY2VzKSB7XG4gICAgICB0aGlzLmNyZWF0ZU1vZGlmaWVyQ29udGV4dHModm9pY2VzKTtcbiAgICAgIHRoaXMuaGFzTWluVG90YWxXaWR0aCA9IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIEFsaWduIHJlc3RzIGluIHZvaWNlcywganVzdGlmeSB0aGUgY29udGV4dHMsIGFuZCBwb3NpdGlvbiB0aGUgbm90ZXNcbiAgICAvLyBzbyB2b2ljZXMgYXJlIGFsaWduZWQgYW5kIHJlYWR5IHRvIHJlbmRlciBvbnRvIHRoZSBzdGF2ZS4gVGhpcyBtZXRob2RcbiAgICAvLyBtdXRhdGVzIHRoZSBgeGAgcG9zaXRpb25zIG9mIGFsbCB0aWNrYWJsZXMgaW4gYHZvaWNlc2AuXG4gICAgLy9cbiAgICAvLyBWb2ljZXMgYXJlIGZ1bGwganVzdGlmaWVkIHRvIGZpdCBpbiBganVzdGlmeVdpZHRoYCBwaXhlbHMuXG4gICAgLy9cbiAgICAvLyBTZXQgYG9wdGlvbnMuY29udGV4dGAgdG8gdGhlIHJlbmRlcmluZyBjb250ZXh0LiBTZXQgYG9wdGlvbnMuYWxpZ25fcmVzdHNgXG4gICAgLy8gdG8gdHJ1ZSB0byBlbmFibGUgcmVzdCBhbGlnbm1lbnQuXG4gICAgZm9ybWF0OiBmdW5jdGlvbih2b2ljZXMsIGp1c3RpZnlXaWR0aCwgb3B0aW9ucykge1xuICAgICAgdmFyIG9wdHMgPSB7XG4gICAgICAgIGFsaWduX3Jlc3RzOiBmYWxzZSxcbiAgICAgICAgY29udGV4dDogbnVsbCxcbiAgICAgICAgc3RhdmU6IG51bGxcbiAgICAgIH07XG5cbiAgICAgIFZleC5NZXJnZShvcHRzLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuYWxpZ25SZXN0cyh2b2ljZXMsIG9wdHMuYWxpZ25fcmVzdHMpO1xuICAgICAgdGhpcy5jcmVhdGVUaWNrQ29udGV4dHModm9pY2VzKTtcbiAgICAgIHRoaXMucHJlRm9ybWF0KGp1c3RpZnlXaWR0aCwgb3B0cy5jb250ZXh0LCB2b2ljZXMsIG9wdHMuc3RhdmUpO1xuXG4gICAgICAvLyBPbmx5IHBvc3RGb3JtYXQgaWYgYSBzdGF2ZSB3YXMgc3VwcGxpZWQgZm9yIHkgdmFsdWUgZm9ybWF0dGluZ1xuICAgICAgaWYgKG9wdHMuc3RhdmUpIHRoaXMucG9zdEZvcm1hdCgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gVGhpcyBtZXRob2QgaXMganVzdCBsaWtlIGBmb3JtYXRgIGV4Y2VwdCB0aGF0IHRoZSBganVzdGlmeVdpZHRoYCBpcyBpbmZlcnJlZFxuICAgIC8vIGZyb20gdGhlIGBzdGF2ZWAuXG4gICAgZm9ybWF0VG9TdGF2ZTogZnVuY3Rpb24odm9pY2VzLCBzdGF2ZSwgb3B0aW9ucykge1xuICAgICAgdmFyIGp1c3RpZnlXaWR0aCA9IHN0YXZlLmdldE5vdGVFbmRYKCkgLSBzdGF2ZS5nZXROb3RlU3RhcnRYKCkgLSAxMDtcbiAgICAgIEwoXCJGb3JtYXR0aW5nIHZvaWNlcyB0byB3aWR0aDogXCIsIGp1c3RpZnlXaWR0aCk7XG4gICAgICB2YXIgb3B0cyA9IHtjb250ZXh0OiBzdGF2ZS5nZXRDb250ZXh0KCl9O1xuICAgICAgVmV4Lk1lcmdlKG9wdHMsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRoaXMuZm9ybWF0KHZvaWNlcywganVzdGlmeVdpZHRoLCBvcHRzKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEZvcm1hdHRlcjtcbn0oKSk7XG5cbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB2YXJpZXMgdHlwZXMgb2YgdGllcyBiZXR3ZWVuIGNvbnRpZ3VvdXMgbm90ZXMuIFRoZVxuLy8gdGllcyBpbmNsdWRlOiByZWd1bGFyIHRpZXMsIGhhbW1lciBvbnMsIHB1bGwgb2ZmcywgYW5kIHNsaWRlcy5cblxuLyoqXG4gKiBDcmVhdGUgYSBuZXcgdGllIGZyb20gdGhlIHNwZWNpZmllZCBub3Rlcy4gVGhlIG5vdGVzIG11c3RcbiAqIGJlIHBhcnQgb2YgdGhlIHNhbWUgbGluZSwgYW5kIGhhdmUgdGhlIHNhbWUgZHVyYXRpb24gKGluIHRpY2tzKS5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7IU9iamVjdH0gY29udGV4dCBUaGUgY2FudmFzIGNvbnRleHQuXG4gKiBAcGFyYW0geyFPYmplY3R9IG5vdGVzIFRoZSBub3RlcyB0byB0aWUgdXAuXG4gKiBAcGFyYW0geyFPYmplY3R9IE9wdGlvbnNcbiAqL1xuVmV4LkZsb3cuU3RhdmVUaWUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFN0YXZlVGllKG5vdGVzLCB0ZXh0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQobm90ZXMsIHRleHQpO1xuICB9XG5cbiAgU3RhdmVUaWUucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG5vdGVzLCB0ZXh0KSB7XG4gICAgICAvKipcbiAgICAgICAqIE5vdGVzIGlzIGEgc3RydWN0IHRoYXQgaGFzOlxuICAgICAgICpcbiAgICAgICAqICB7XG4gICAgICAgKiAgICBmaXJzdF9ub3RlOiBOb3RlLFxuICAgICAgICogICAgbGFzdF9ub3RlOiBOb3RlLFxuICAgICAgICogICAgZmlyc3RfaW5kaWNlczogW24xLCBuMiwgbjNdLFxuICAgICAgICogICAgbGFzdF9pbmRpY2VzOiBbbjEsIG4yLCBuM11cbiAgICAgICAqICB9XG4gICAgICAgKlxuICAgICAgICoqL1xuICAgICAgdGhpcy5ub3RlcyA9IG5vdGVzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcbiAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG5cbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMgPSB7XG4gICAgICAgICAgY3AxOiA4LCAgICAgIC8vIEN1cnZlIGNvbnRyb2wgcG9pbnQgMVxuICAgICAgICAgIGNwMjogMTIsICAgICAgLy8gQ3VydmUgY29udHJvbCBwb2ludCAyXG4gICAgICAgICAgdGV4dF9zaGlmdF94OiAwLFxuICAgICAgICAgIGZpcnN0X3hfc2hpZnQ6IDAsXG4gICAgICAgICAgbGFzdF94X3NoaWZ0OiAwLFxuICAgICAgICAgIHlfc2hpZnQ6IDcsXG4gICAgICAgICAgdGllX3NwYWNpbmc6IDAsXG4gICAgICAgICAgZm9udDogeyBmYW1pbHk6IFwiQXJpYWxcIiwgc2l6ZTogMTAsIHN0eWxlOiBcIlwiIH1cbiAgICAgICAgfTtcblxuICAgICAgdGhpcy5mb250ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5mb250O1xuICAgICAgdGhpcy5zZXROb3Rlcyhub3Rlcyk7XG4gICAgfSxcblxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHsgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgc2V0Rm9udDogZnVuY3Rpb24oZm9udCkgeyB0aGlzLmZvbnQgPSBmb250OyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbm90ZXMgdG8gYXR0YWNoIHRoaXMgdGllIHRvLlxuICAgICAqXG4gICAgICogQHBhcmFtIHshT2JqZWN0fSBub3RlcyBUaGUgbm90ZXMgdG8gdGllIHVwLlxuICAgICAqL1xuICAgIHNldE5vdGVzOiBmdW5jdGlvbihub3Rlcykge1xuICAgICAgaWYgKCFub3Rlcy5maXJzdF9ub3RlICYmICFub3Rlcy5sYXN0X25vdGUpXG4gICAgICAgIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiQmFkQXJndW1lbnRzXCIsXG4gICAgICAgICAgICBcIlRpZSBuZWVkcyB0byBoYXZlIGVpdGhlciBmaXJzdF9ub3RlIG9yIGxhc3Rfbm90ZSBzZXQuXCIpO1xuXG4gICAgICBpZiAoIW5vdGVzLmZpcnN0X2luZGljZXMpIG5vdGVzLmZpcnN0X2luZGljZXMgPSBbMF07XG4gICAgICBpZiAoIW5vdGVzLmxhc3RfaW5kaWNlcykgbm90ZXMubGFzdF9pbmRpY2VzID0gWzBdO1xuXG4gICAgICBpZiAobm90ZXMuZmlyc3RfaW5kaWNlcy5sZW5ndGggIT0gbm90ZXMubGFzdF9pbmRpY2VzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIiwgXCJUaWVkIG5vdGVzIG11c3QgaGF2ZSBzaW1pbGFyXCIgK1xuICAgICAgICAgIFwiIGluZGV4IHNpemVzXCIpO1xuXG4gICAgICAvLyBTdWNjZXNzLiBMZXRzIGdyYWIgJ2VtIG5vdGVzLlxuICAgICAgdGhpcy5maXJzdF9ub3RlID0gbm90ZXMuZmlyc3Rfbm90ZTtcbiAgICAgIHRoaXMuZmlyc3RfaW5kaWNlcyA9IG5vdGVzLmZpcnN0X2luZGljZXM7XG4gICAgICB0aGlzLmxhc3Rfbm90ZSA9IG5vdGVzLmxhc3Rfbm90ZTtcbiAgICAgIHRoaXMubGFzdF9pbmRpY2VzID0gbm90ZXMubGFzdF9pbmRpY2VzO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIEByZXR1cm4ge2Jvb2xlYW59IFJldHVybnMgdHJ1ZSBpZiB0aGlzIGlzIGEgcGFydGlhbCBiYXIuXG4gICAgICovXG4gICAgaXNQYXJ0aWFsOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoIXRoaXMuZmlyc3Rfbm90ZSB8fCAhdGhpcy5sYXN0X25vdGUpO1xuICAgIH0sXG5cbiAgICByZW5kZXJUaWU6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgaWYgKHBhcmFtcy5maXJzdF95cy5sZW5ndGggPT09IDAgfHwgcGFyYW1zLmxhc3RfeXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJObyBZLXZhbHVlcyB0byByZW5kZXJcIik7XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgY3AxID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5jcDE7XG4gICAgICB2YXIgY3AyID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5jcDI7XG5cbiAgICAgIGlmIChNYXRoLmFicyhwYXJhbXMubGFzdF94X3B4IC0gcGFyYW1zLmZpcnN0X3hfcHgpIDwgMTApIHtcbiAgICAgICAgY3AxID0gMjsgY3AyID0gODtcbiAgICAgIH1cblxuICAgICAgdmFyIGZpcnN0X3hfc2hpZnQgPSB0aGlzLnJlbmRlcl9vcHRpb25zLmZpcnN0X3hfc2hpZnQ7XG4gICAgICB2YXIgbGFzdF94X3NoaWZ0ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5sYXN0X3hfc2hpZnQ7XG4gICAgICB2YXIgeV9zaGlmdCA9IHRoaXMucmVuZGVyX29wdGlvbnMueV9zaGlmdCAqIHBhcmFtcy5kaXJlY3Rpb247XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5maXJzdF9pbmRpY2VzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBjcF94ID0gKChwYXJhbXMubGFzdF94X3B4ICsgbGFzdF94X3NoaWZ0KSArXG4gICAgICAgICAgICAgICAgICAgIChwYXJhbXMuZmlyc3RfeF9weCArIGZpcnN0X3hfc2hpZnQpKSAvIDI7XG4gICAgICAgIHZhciBmaXJzdF95X3B4ID0gcGFyYW1zLmZpcnN0X3lzW3RoaXMuZmlyc3RfaW5kaWNlc1tpXV0gKyB5X3NoaWZ0O1xuICAgICAgICB2YXIgbGFzdF95X3B4ID0gcGFyYW1zLmxhc3RfeXNbdGhpcy5sYXN0X2luZGljZXNbaV1dICsgeV9zaGlmdDtcblxuICAgICAgICBpZiAoaXNOYU4oZmlyc3RfeV9weCkgfHwgaXNOYU4obGFzdF95X3B4KSlcbiAgICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJCYWQgaW5kaWNlcyBmb3IgdGllIHJlbmRlcmluZy5cIik7XG5cbiAgICAgICAgdmFyIHRvcF9jcF95ID0gKChmaXJzdF95X3B4ICsgbGFzdF95X3B4KSAvIDIpICsgKGNwMSAqIHBhcmFtcy5kaXJlY3Rpb24pO1xuICAgICAgICB2YXIgYm90dG9tX2NwX3kgPSAoKGZpcnN0X3lfcHggKyBsYXN0X3lfcHgpIC8gMikgKyAoY3AyICogcGFyYW1zLmRpcmVjdGlvbik7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHBhcmFtcy5maXJzdF94X3B4ICsgZmlyc3RfeF9zaGlmdCwgZmlyc3RfeV9weCk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKGNwX3gsIHRvcF9jcF95LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXMubGFzdF94X3B4ICsgbGFzdF94X3NoaWZ0LCBsYXN0X3lfcHgpO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjcF94LCBib3R0b21fY3BfeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGFyYW1zLmZpcnN0X3hfcHggKyBmaXJzdF94X3NoaWZ0LCBmaXJzdF95X3B4KTtcblxuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIHJlbmRlclRleHQ6IGZ1bmN0aW9uKGZpcnN0X3hfcHgsIGxhc3RfeF9weCkge1xuICAgICAgaWYgKCF0aGlzLnRleHQpIHJldHVybjtcbiAgICAgIHZhciBjZW50ZXJfeCA9IChmaXJzdF94X3B4ICsgbGFzdF94X3B4KSAvIDI7XG4gICAgICBjZW50ZXJfeCAtPSB0aGlzLmNvbnRleHQubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aCAvIDI7XG5cbiAgICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XG4gICAgICB0aGlzLmNvbnRleHQuc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSwgdGhpcy5mb250LnN0eWxlKTtcbiAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dChcbiAgICAgICAgICB0aGlzLnRleHQsIGNlbnRlcl94ICsgdGhpcy5yZW5kZXJfb3B0aW9ucy50ZXh0X3NoaWZ0X3gsXG4gICAgICAgICAgKHRoaXMuZmlyc3Rfbm90ZSB8fCB0aGlzLmxhc3Rfbm90ZSkuZ2V0U3RhdmUoKS5nZXRZRm9yVG9wVGV4dCgpIC0gMSk7XG4gICAgICB0aGlzLmNvbnRleHQucmVzdG9yZSgpO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIiwgXCJObyBjb250ZXh0IHRvIHJlbmRlciB0aWUuXCIpO1xuICAgICAgdmFyIGZpcnN0X25vdGUgPSB0aGlzLmZpcnN0X25vdGU7XG4gICAgICB2YXIgbGFzdF9ub3RlID0gdGhpcy5sYXN0X25vdGU7XG4gICAgICB2YXIgZmlyc3RfeF9weCwgbGFzdF94X3B4LCBmaXJzdF95cywgbGFzdF95cywgc3RlbV9kaXJlY3Rpb247XG5cbiAgICAgIGlmIChmaXJzdF9ub3RlKSB7XG4gICAgICAgIGZpcnN0X3hfcHggPSBmaXJzdF9ub3RlLmdldFRpZVJpZ2h0WCgpICsgdGhpcy5yZW5kZXJfb3B0aW9ucy50aWVfc3BhY2luZztcbiAgICAgICAgc3RlbV9kaXJlY3Rpb24gPSBmaXJzdF9ub3RlLmdldFN0ZW1EaXJlY3Rpb24oKTtcbiAgICAgICAgZmlyc3RfeXMgPSBmaXJzdF9ub3RlLmdldFlzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdF94X3B4ID0gbGFzdF9ub3RlLmdldFN0YXZlKCkuZ2V0VGllU3RhcnRYKCk7XG4gICAgICAgIGZpcnN0X3lzID0gbGFzdF9ub3RlLmdldFlzKCk7XG4gICAgICAgIHRoaXMuZmlyc3RfaW5kaWNlcyA9IHRoaXMubGFzdF9pbmRpY2VzO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdF9ub3RlKSB7XG4gICAgICAgIGxhc3RfeF9weCA9IGxhc3Rfbm90ZS5nZXRUaWVMZWZ0WCgpICsgdGhpcy5yZW5kZXJfb3B0aW9ucy50aWVfc3BhY2luZztcbiAgICAgICAgc3RlbV9kaXJlY3Rpb24gPSBsYXN0X25vdGUuZ2V0U3RlbURpcmVjdGlvbigpO1xuICAgICAgICBsYXN0X3lzID0gbGFzdF9ub3RlLmdldFlzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0X3hfcHggPSBmaXJzdF9ub3RlLmdldFN0YXZlKCkuZ2V0VGllRW5kWCgpO1xuICAgICAgICBsYXN0X3lzID0gZmlyc3Rfbm90ZS5nZXRZcygpO1xuICAgICAgICB0aGlzLmxhc3RfaW5kaWNlcyA9IHRoaXMuZmlyc3RfaW5kaWNlcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJUaWUoe1xuICAgICAgICBmaXJzdF94X3B4OiBmaXJzdF94X3B4LFxuICAgICAgICBsYXN0X3hfcHg6IGxhc3RfeF9weCxcbiAgICAgICAgZmlyc3RfeXM6IGZpcnN0X3lzLFxuICAgICAgICBsYXN0X3lzOiBsYXN0X3lzLFxuICAgICAgICBkaXJlY3Rpb246IHN0ZW1fZGlyZWN0aW9uXG4gICAgICB9KTtcblxuICAgICAgdGhpcy5yZW5kZXJUZXh0KGZpcnN0X3hfcHgsIGxhc3RfeF9weCk7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFN0YXZlVGllO1xufSgpKTtcblxuLy8gVmV4RmxvdyAtIE11c2ljIEVuZ3JhdmluZyBmb3IgSFRNTDVcbi8vIENvcHlyaWdodCBNb2hpdCBNdXRoYW5uYSAyMDEwXG4vL1xuLy8gVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHZhcmllcyB0eXBlcyBvZiB0aWVzIGJldHdlZW4gY29udGlndW91cyBub3Rlcy4gVGhlXG4vLyB0aWVzIGluY2x1ZGU6IHJlZ3VsYXIgdGllcywgaGFtbWVyIG9ucywgcHVsbCBvZmZzLCBhbmQgc2xpZGVzLlxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0aWUgZnJvbSB0aGUgc3BlY2lmaWVkIG5vdGVzLiBUaGUgbm90ZXMgbXVzdFxuICogYmUgcGFydCBvZiB0aGUgc2FtZSBsaW5lLCBhbmQgaGF2ZSB0aGUgc2FtZSBkdXJhdGlvbiAoaW4gdGlja3MpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHshT2JqZWN0fSBjb250ZXh0IFRoZSBjYW52YXMgY29udGV4dC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gbm90ZXMgVGhlIG5vdGVzIHRvIHRpZSB1cC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gT3B0aW9uc1xuICovXG5WZXguRmxvdy5UYWJUaWUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRhYlRpZShub3RlcywgdGV4dCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG5vdGVzLCB0ZXh0KTtcbiAgfVxuXG4gIFRhYlRpZS5jcmVhdGVIYW1tZXJvbiA9IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJUaWUobm90ZXMsIFwiSFwiKTtcbiAgfTtcblxuICBUYWJUaWUuY3JlYXRlUHVsbG9mZiA9IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJUaWUobm90ZXMsIFwiUFwiKTtcbiAgfTtcblxuICBWZXguSW5oZXJpdChUYWJUaWUsIFZleC5GbG93LlN0YXZlVGllLCB7XG4gICAgaW5pdDogZnVuY3Rpb24obm90ZXMsIHRleHQpIHtcbiAgICAgIC8qKlxuICAgICAgICogTm90ZXMgaXMgYSBzdHJ1Y3QgdGhhdCBoYXM6XG4gICAgICAgKlxuICAgICAgICogIHtcbiAgICAgICAqICAgIGZpcnN0X25vdGU6IE5vdGUsXG4gICAgICAgKiAgICBsYXN0X25vdGU6IE5vdGUsXG4gICAgICAgKiAgICBmaXJzdF9pbmRpY2VzOiBbbjEsIG4yLCBuM10sXG4gICAgICAgKiAgICBsYXN0X2luZGljZXM6IFtuMSwgbjIsIG4zXVxuICAgICAgICogIH1cbiAgICAgICAqXG4gICAgICAgKiovXG4gICAgICBUYWJUaWUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbm90ZXMsIHRleHQpO1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5jcDEgPSA5O1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5jcDIgPSAxMTtcbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMueV9zaGlmdCA9IDM7XG5cbiAgICAgIHRoaXMuc2V0Tm90ZXMobm90ZXMpO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIiwgXCJObyBjb250ZXh0IHRvIHJlbmRlciB0aWUuXCIpO1xuICAgICAgdmFyIGZpcnN0X25vdGUgPSB0aGlzLmZpcnN0X25vdGU7XG4gICAgICB2YXIgbGFzdF9ub3RlID0gdGhpcy5sYXN0X25vdGU7XG4gICAgICB2YXIgZmlyc3RfeF9weCwgbGFzdF94X3B4LCBmaXJzdF95cywgbGFzdF95cztcblxuICAgICAgaWYgKGZpcnN0X25vdGUpIHtcbiAgICAgICAgZmlyc3RfeF9weCA9IGZpcnN0X25vdGUuZ2V0VGllUmlnaHRYKCkgKyB0aGlzLnJlbmRlcl9vcHRpb25zLnRpZV9zcGFjaW5nO1xuICAgICAgICBmaXJzdF95cyA9IGZpcnN0X25vdGUuZ2V0WXMoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGZpcnN0X3hfcHggPSBsYXN0X25vdGUuZ2V0U3RhdmUoKS5nZXRUaWVTdGFydFgoKTtcbiAgICAgICAgZmlyc3RfeXMgPSBsYXN0X25vdGUuZ2V0WXMoKTtcbiAgICAgICAgdGhpcy5maXJzdF9pbmRpY2VzID0gdGhpcy5sYXN0X2luZGljZXM7XG4gICAgICB9XG5cbiAgICAgIGlmIChsYXN0X25vdGUpIHtcbiAgICAgICAgbGFzdF94X3B4ID0gbGFzdF9ub3RlLmdldFRpZUxlZnRYKCkgKyB0aGlzLnJlbmRlcl9vcHRpb25zLnRpZV9zcGFjaW5nO1xuICAgICAgICBsYXN0X3lzID0gbGFzdF9ub3RlLmdldFlzKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBsYXN0X3hfcHggPSBmaXJzdF9ub3RlLmdldFN0YXZlKCkuZ2V0VGllRW5kWCgpO1xuICAgICAgICBsYXN0X3lzID0gZmlyc3Rfbm90ZS5nZXRZcygpO1xuICAgICAgICB0aGlzLmxhc3RfaW5kaWNlcyA9IHRoaXMuZmlyc3RfaW5kaWNlcztcbiAgICAgIH1cblxuICAgICAgdGhpcy5yZW5kZXJUaWUoe1xuICAgICAgICBmaXJzdF94X3B4OiBmaXJzdF94X3B4LFxuICAgICAgICBsYXN0X3hfcHg6IGxhc3RfeF9weCxcbiAgICAgICAgZmlyc3RfeXM6IGZpcnN0X3lzLFxuICAgICAgICBsYXN0X3lzOiBsYXN0X3lzLFxuICAgICAgICBkaXJlY3Rpb246IC0xICAgICAgICAgICAvLyBUYWIgdGllJ3MgYXJlIGFsd2F5cyBmYWNlIHVwLlxuICAgICAgfSk7XG5cbiAgICAgIHRoaXMucmVuZGVyVGV4dChmaXJzdF94X3B4LCBsYXN0X3hfcHgpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gVGFiVGllO1xufSgpKTtcblxuLy8gVmV4RmxvdyAtIE11c2ljIEVuZ3JhdmluZyBmb3IgSFRNTDVcbi8vIENvcHlyaWdodCBNb2hpdCBNdXRoYW5uYSAyMDEwXG4vL1xuLy8gVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHZhcmllcyB0eXBlcyBvZiB0aWVzIGJldHdlZW4gY29udGlndW91cyBub3Rlcy4gVGhlXG4vLyB0aWVzIGluY2x1ZGU6IHJlZ3VsYXIgdGllcywgaGFtbWVyIG9ucywgcHVsbCBvZmZzLCBhbmQgc2xpZGVzLlxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyB0aWUgZnJvbSB0aGUgc3BlY2lmaWVkIG5vdGVzLiBUaGUgbm90ZXMgbXVzdFxuICogYmUgcGFydCBvZiB0aGUgc2FtZSBsaW5lLCBhbmQgaGF2ZSB0aGUgc2FtZSBkdXJhdGlvbiAoaW4gdGlja3MpLlxuICpcbiAqIEBjb25zdHJ1Y3RvclxuICogQHBhcmFtIHshT2JqZWN0fSBjb250ZXh0IFRoZSBjYW52YXMgY29udGV4dC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gbm90ZXMgVGhlIG5vdGVzIHRvIHRpZSB1cC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gT3B0aW9uc1xuICovXG5WZXguRmxvdy5UYWJTbGlkZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gVGFiU2xpZGUobm90ZXMsIGRpcmVjdGlvbikge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG5vdGVzLCBkaXJlY3Rpb24pO1xuICB9XG5cbiAgVGFiU2xpZGUuU0xJREVfVVAgPSAxO1xuICBUYWJTbGlkZS5TTElERV9ET1dOID0gLTE7XG5cbiAgVGFiU2xpZGUuY3JlYXRlU2xpZGVVcCA9IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJTbGlkZShub3RlcywgVGFiU2xpZGUuU0xJREVfVVApO1xuICB9O1xuXG4gIFRhYlNsaWRlLmNyZWF0ZVNsaWRlRG93biA9IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgcmV0dXJuIG5ldyBUYWJTbGlkZShub3RlcywgVGFiU2xpZGUuU0xJREVfRE9XTik7XG4gIH07XG5cbiAgVmV4LkluaGVyaXQoVGFiU2xpZGUsIFZleC5GbG93LlRhYlRpZSwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG5vdGVzLCBkaXJlY3Rpb24pIHtcbiAgICAgIC8qKlxuICAgICAgICogTm90ZXMgaXMgYSBzdHJ1Y3QgdGhhdCBoYXM6XG4gICAgICAgKlxuICAgICAgICogIHtcbiAgICAgICAqICAgIGZpcnN0X25vdGU6IE5vdGUsXG4gICAgICAgKiAgICBsYXN0X25vdGU6IE5vdGUsXG4gICAgICAgKiAgICBmaXJzdF9pbmRpY2VzOiBbbjEsIG4yLCBuM10sXG4gICAgICAgKiAgICBsYXN0X2luZGljZXM6IFtuMSwgbjIsIG4zXVxuICAgICAgICogIH1cbiAgICAgICAqXG4gICAgICAgKiovXG4gICAgICBUYWJTbGlkZS5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzLCBub3RlcywgXCJzbC5cIik7XG4gICAgICBpZiAoIWRpcmVjdGlvbikge1xuICAgICAgICB2YXIgZmlyc3RfZnJldCA9IG5vdGVzLmZpcnN0X25vdGUuZ2V0UG9zaXRpb25zKClbMF0uZnJldDtcbiAgICAgICAgdmFyIGxhc3RfZnJldCA9IG5vdGVzLmxhc3Rfbm90ZS5nZXRQb3NpdGlvbnMoKVswXS5mcmV0O1xuXG4gICAgICAgIGRpcmVjdGlvbiA9ICgocGFyc2VJbnQoZmlyc3RfZnJldCwgMTApID4gcGFyc2VJbnQobGFzdF9mcmV0LCAxMCkpID9cbiAgICAgICAgICBUYWJTbGlkZS5TTElERV9ET1dOIDogVGFiU2xpZGUuU0xJREVfVVApO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNsaWRlX2RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuY3AxID0gMTE7XG4gICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLmNwMiA9IDE0O1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy55X3NoaWZ0ID0gMC41O1xuXG4gICAgICB0aGlzLnNldEZvbnQoe2ZvbnQ6IFwiVGltZXNcIiwgc2l6ZTogMTAsIHN0eWxlOiBcImJvbGQgaXRhbGljXCJ9KTtcbiAgICAgIHRoaXMuc2V0Tm90ZXMobm90ZXMpO1xuICAgIH0sXG5cbiAgICByZW5kZXJUaWU6IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgaWYgKHBhcmFtcy5maXJzdF95cy5sZW5ndGggPT09IDAgfHwgcGFyYW1zLmxhc3RfeXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJObyBZLXZhbHVlcyB0byByZW5kZXJcIik7XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgZmlyc3RfeF9weCA9IHBhcmFtcy5maXJzdF94X3B4O1xuICAgICAgdmFyIGZpcnN0X3lzID0gcGFyYW1zLmZpcnN0X3lzO1xuICAgICAgdmFyIGxhc3RfeF9weCA9IHBhcmFtcy5sYXN0X3hfcHg7XG5cbiAgICAgIHZhciBkaXJlY3Rpb24gPSB0aGlzLnNsaWRlX2RpcmVjdGlvbjtcbiAgICAgIGlmIChkaXJlY3Rpb24gIT0gVGFiU2xpZGUuU0xJREVfVVAgJiZcbiAgICAgICAgICBkaXJlY3Rpb24gIT0gVGFiU2xpZGUuU0xJREVfRE9XTikge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRTbGlkZVwiLCBcIkludmFsaWQgc2xpZGUgZGlyZWN0aW9uXCIpO1xuICAgICAgfVxuXG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuZmlyc3RfaW5kaWNlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgc2xpZGVfeSA9IGZpcnN0X3lzW3RoaXMuZmlyc3RfaW5kaWNlc1tpXV0gK1xuICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMueV9zaGlmdDtcblxuICAgICAgICBpZiAoaXNOYU4oc2xpZGVfeSkpXG4gICAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsIFwiQmFkIGluZGljZXMgZm9yIHNsaWRlIHJlbmRlcmluZy5cIik7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKGZpcnN0X3hfcHgsIHNsaWRlX3kgKyAoMyAqIGRpcmVjdGlvbikpO1xuICAgICAgICBjdHgubGluZVRvKGxhc3RfeF9weCwgc2xpZGVfeSAtICgzICogZGlyZWN0aW9uKSk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFRhYlNsaWRlO1xufSgpKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgdGFibGF0dXJlIGJlbmRzLlxuXG4vKipcbiAgIEBwYXJhbSB0ZXh0IFRleHQgZm9yIGJlbmQgKFwiRnVsbFwiLCBcIkhhbGZcIiwgZXRjLikgKERFUFJFQ0FURUQpXG4gICBAcGFyYW0gcmVsZWFzZSBJZiB0cnVlLCByZW5kZXIgYSByZWxlYXNlLiAoREVQUkVDQVRFRClcbiAgIEBwYXJhbSBwaHJhc2UgSWYgc2V0LCBpZ25vcmUgXCJ0ZXh0XCIgYW5kIFwicmVsZWFzZVwiLCBhbmQgdXNlIHRoZSBtb3JlXG4gICAgICAgICAgICAgICAgIHNvcGhpc3RpY2F0ZWQgcGhyYXNlIHNwZWNpZmllZC5cblxuICAgRXhhbXBsZSBvZiBhIHBocmFzZTpcblxuICAgICBbe1xuICAgICAgIHR5cGU6IFVQLFxuICAgICAgIHRleHQ6IFwid2hvbGVcIlxuICAgICAgIHdpZHRoOiA4O1xuICAgICB9LFxuICAgICB7XG4gICAgICAgdHlwZTogRE9XTixcbiAgICAgICB0ZXh0OiBcIndob2xlXCJcbiAgICAgICB3aWR0aDogODtcbiAgICAgfSxcbiAgICAge1xuICAgICAgIHR5cGU6IFVQLFxuICAgICAgIHRleHQ6IFwiaGFsZlwiXG4gICAgICAgd2lkdGg6IDg7XG4gICAgIH0sXG4gICAgIHtcbiAgICAgICB0eXBlOiBVUCxcbiAgICAgICB0ZXh0OiBcIndob2xlXCJcbiAgICAgICB3aWR0aDogODtcbiAgICAgfSxcbiAgICAge1xuICAgICAgIHR5cGU6IERPV04sXG4gICAgICAgdGV4dDogXCIxIDEvMlwiXG4gICAgICAgd2lkdGg6IDg7XG4gICAgIH1dXG4gKi9cblZleC5GbG93LkJlbmQgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEJlbmQodGV4dCwgcmVsZWFzZSwgcGhyYXNlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGV4dCwgcmVsZWFzZSwgcGhyYXNlKTtcbiAgfVxuICBCZW5kLkNBVEVHT1JZID0gXCJiZW5kc1wiO1xuXG4gIEJlbmQuVVAgPSAwO1xuICBCZW5kLkRPV04gPSAxO1xuXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xuXG4gIC8vICMjIFN0YXRpYyBNZXRob2RzXG4gIC8vIEFycmFuZ2UgYmVuZHMgaW4gYE1vZGlmaWVyQ29udGV4dGBcbiAgQmVuZC5mb3JtYXQgPSBmdW5jdGlvbihiZW5kcywgc3RhdGUpIHtcbiAgICBpZiAoIWJlbmRzIHx8IGJlbmRzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgdmFyIGxhc3Rfd2lkdGggPSAwO1xuICAgIC8vIEJlbmRzIGFyZSBhbHdheXMgb24gdG9wLlxuICAgIHZhciB0ZXh0X2xpbmUgPSBzdGF0ZS50b3BfdGV4dF9saW5lO1xuXG4gICAgLy8gRm9ybWF0IEJlbmRzXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiZW5kcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIGJlbmQgPSBiZW5kc1tpXTtcbiAgICAgIGJlbmQuc2V0WFNoaWZ0KGxhc3Rfd2lkdGgpO1xuICAgICAgbGFzdF93aWR0aCA9IGJlbmQuZ2V0V2lkdGgoKTtcbiAgICAgIGJlbmQuc2V0VGV4dExpbmUodGV4dF9saW5lKTtcbiAgICB9XG5cbiAgICBzdGF0ZS5yaWdodF9zaGlmdCArPSBsYXN0X3dpZHRoO1xuICAgIHN0YXRlLnRvcF90ZXh0X2xpbmUgKz0gMTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICBWZXguSW5oZXJpdChCZW5kLCBNb2RpZmllciwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKHRleHQsIHJlbGVhc2UsIHBocmFzZSkge1xuICAgICAgdmFyIHN1cGVyY2xhc3MgPSBWZXguRmxvdy5CZW5kLnN1cGVyY2xhc3M7XG4gICAgICBzdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgIHRoaXMueF9zaGlmdCA9IDA7XG4gICAgICB0aGlzLnJlbGVhc2UgPSByZWxlYXNlIHx8IGZhbHNlO1xuICAgICAgdGhpcy5mb250ID0gXCIxMHB0IEFyaWFsXCI7XG4gICAgICB0aGlzLnJlbmRlcl9vcHRpb25zID0ge1xuICAgICAgICBsaW5lX3dpZHRoOiAxLjUsXG4gICAgICAgIGxpbmVfc3R5bGU6IFwiIzc3Nzc3N1wiLFxuICAgICAgICBiZW5kX3dpZHRoOiA4LFxuICAgICAgICByZWxlYXNlX3dpZHRoOiA4XG4gICAgICB9O1xuXG4gICAgICBpZiAocGhyYXNlKSB7XG4gICAgICAgIHRoaXMucGhyYXNlID0gcGhyYXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gQmFja3dhcmQgY29tcGF0aWJpbGl0eVxuICAgICAgICB0aGlzLnBocmFzZSA9IFt7dHlwZTogQmVuZC5VUCwgdGV4dDogdGhpcy50ZXh0fV07XG4gICAgICAgIGlmICh0aGlzLnJlbGVhc2UpIHRoaXMucGhyYXNlLnB1c2goe3R5cGU6IEJlbmQuRE9XTiwgdGV4dDogXCJcIn0pO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnVwZGF0ZVdpZHRoKCk7XG4gICAgfSxcblxuICAgIHNldFhTaGlmdDogZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHRoaXMueF9zaGlmdCA9IHZhbHVlO1xuICAgICAgdGhpcy51cGRhdGVXaWR0aCgpO1xuICAgIH0sXG5cbiAgICBzZXRGb250OiBmdW5jdGlvbihmb250KSB7IHRoaXMuZm9udCA9IGZvbnQ7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgZ2V0VGV4dDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnRleHQ7IH0sXG5cbiAgICB1cGRhdGVXaWR0aDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIG1lYXN1cmVfdGV4dCh0ZXh0KSB7XG4gICAgICAgIHZhciB0ZXh0X3dpZHRoO1xuICAgICAgICBpZiAodGhhdC5jb250ZXh0KSB7XG4gICAgICAgICAgdGV4dF93aWR0aCA9IHRoYXQuY29udGV4dC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0ZXh0X3dpZHRoID0gVmV4LkZsb3cudGV4dFdpZHRoKHRleHQpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIHRleHRfd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciB0b3RhbF93aWR0aCA9IDA7XG4gICAgICBmb3IgKHZhciBpPTA7IGk8dGhpcy5waHJhc2UubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgdmFyIGJlbmQgPSB0aGlzLnBocmFzZVtpXTtcbiAgICAgICAgaWYgKCd3aWR0aCcgaW4gYmVuZCkge1xuICAgICAgICAgIHRvdGFsX3dpZHRoICs9IGJlbmQud2lkdGg7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdmFyIGFkZGl0aW9uYWxfd2lkdGggPSAoYmVuZC50eXBlID09IEJlbmQuVVApID9cbiAgICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuYmVuZF93aWR0aCA6IHRoaXMucmVuZGVyX29wdGlvbnMucmVsZWFzZV93aWR0aDtcblxuICAgICAgICAgIGJlbmQud2lkdGggPSBWZXguTWF4KGFkZGl0aW9uYWxfd2lkdGgsIG1lYXN1cmVfdGV4dChiZW5kLnRleHQpKSArIDM7XG4gICAgICAgICAgYmVuZC5kcmF3X3dpZHRoID0gYmVuZC53aWR0aCAvIDI7XG4gICAgICAgICAgdG90YWxfd2lkdGggKz0gYmVuZC53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFdpZHRoKHRvdGFsX3dpZHRoICsgdGhpcy54X3NoaWZ0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgYmVuZCB3aXRob3V0IGEgY29udGV4dC5cIik7XG4gICAgICBpZiAoISh0aGlzLm5vdGUgJiYgKHRoaXMuaW5kZXggIT0gbnVsbCkpKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb05vdGVGb3JCZW5kXCIsXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBiZW5kIHdpdGhvdXQgYSBub3RlIG9yIGluZGV4LlwiKTtcblxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5ub3RlLmdldE1vZGlmaWVyU3RhcnRYWShNb2RpZmllci5Qb3NpdGlvbi5SSUdIVCxcbiAgICAgICAgICB0aGlzLmluZGV4KTtcbiAgICAgIHN0YXJ0LnggKz0gMztcbiAgICAgIHN0YXJ0LnkgKz0gMC41O1xuICAgICAgdmFyIHhfc2hpZnQgPSB0aGlzLnhfc2hpZnQ7XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgYmVuZF9oZWlnaHQgPSB0aGlzLm5vdGUuZ2V0U3RhdmUoKS5nZXRZRm9yVG9wVGV4dCh0aGlzLnRleHRfbGluZSkgKyAzO1xuICAgICAgdmFyIGFubm90YXRpb25feSA9IHRoaXMubm90ZS5nZXRTdGF2ZSgpLmdldFlGb3JUb3BUZXh0KHRoaXMudGV4dF9saW5lKSAtIDE7XG4gICAgICB2YXIgdGhhdCA9IHRoaXM7XG5cbiAgICAgIGZ1bmN0aW9uIHJlbmRlckJlbmQoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgICB2YXIgY3BfeCA9IHggKyB3aWR0aDtcbiAgICAgICAgdmFyIGNwX3kgPSB5O1xuXG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnNldExpbmVXaWR0aCh0aGF0LnJlbmRlcl9vcHRpb25zLmxpbmVfd2lkdGgpO1xuICAgICAgICBjdHguc2V0U3Ryb2tlU3R5bGUodGhhdC5yZW5kZXJfb3B0aW9ucy5saW5lX3N0eWxlKTtcbiAgICAgICAgY3R4LnNldEZpbGxTdHlsZSh0aGF0LnJlbmRlcl9vcHRpb25zLmxpbmVfc3R5bGUpO1xuICAgICAgICBjdHgubW92ZVRvKHgsIHkpO1xuICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhjcF94LCBjcF95LCB4ICsgd2lkdGgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gcmVuZGVyUmVsZWFzZSh4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4LnNldExpbmVXaWR0aCh0aGF0LnJlbmRlcl9vcHRpb25zLmxpbmVfd2lkdGgpO1xuICAgICAgICBjdHguc2V0U3Ryb2tlU3R5bGUodGhhdC5yZW5kZXJfb3B0aW9ucy5saW5lX3N0eWxlKTtcbiAgICAgICAgY3R4LnNldEZpbGxTdHlsZSh0aGF0LnJlbmRlcl9vcHRpb25zLmxpbmVfc3R5bGUpO1xuICAgICAgICBjdHgubW92ZVRvKHgsIGhlaWdodCk7XG4gICAgICAgIGN0eC5xdWFkcmF0aWNDdXJ2ZVRvKFxuICAgICAgICAgICAgeCArIHdpZHRoLCBoZWlnaHQsXG4gICAgICAgICAgICB4ICsgd2lkdGgsIHkpO1xuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbmRlckFycm93SGVhZCh4LCB5LCBkaXJlY3Rpb24pIHtcbiAgICAgICAgdmFyIHdpZHRoID0gNDtcbiAgICAgICAgdmFyIGRpciA9IGRpcmVjdGlvbiB8fCAxO1xuXG4gICAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgICAgY3R4Lm1vdmVUbyh4LCB5KTtcbiAgICAgICAgY3R4LmxpbmVUbyh4IC0gd2lkdGgsIHkgKyB3aWR0aCAqIGRpcik7XG4gICAgICAgIGN0eC5saW5lVG8oeCArIHdpZHRoLCB5ICsgd2lkdGggKiBkaXIpO1xuICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIGN0eC5maWxsKCk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIHJlbmRlclRleHQoeCwgdGV4dCkge1xuICAgICAgICBjdHguc2F2ZSgpO1xuICAgICAgICBjdHguc2V0UmF3Rm9udCh0aGF0LmZvbnQpO1xuICAgICAgICB2YXIgcmVuZGVyX3ggPSB4IC0gKGN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCAvIDIpO1xuICAgICAgICBjdHguZmlsbFRleHQodGV4dCwgcmVuZGVyX3gsIGFubm90YXRpb25feSk7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciBsYXN0X2JlbmQgPSBudWxsO1xuICAgICAgdmFyIGxhc3RfZHJhd25fd2lkdGggPSAwO1xuICAgICAgZm9yICh2YXIgaT0wOyBpPHRoaXMucGhyYXNlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBiZW5kID0gdGhpcy5waHJhc2VbaV07XG4gICAgICAgIGlmIChpID09PSAwKSBiZW5kLmRyYXdfd2lkdGggKz0geF9zaGlmdDtcblxuICAgICAgICBsYXN0X2RyYXduX3dpZHRoID0gYmVuZC5kcmF3X3dpZHRoICsgKGxhc3RfYmVuZD9sYXN0X2JlbmQuZHJhd193aWR0aDowKSAtIChpPT0xP3hfc2hpZnQ6MCk7XG4gICAgICAgIGlmIChiZW5kLnR5cGUgPT0gQmVuZC5VUCkge1xuICAgICAgICAgIGlmIChsYXN0X2JlbmQgJiYgbGFzdF9iZW5kLnR5cGUgPT0gQmVuZC5VUCkge1xuICAgICAgICAgICAgcmVuZGVyQXJyb3dIZWFkKHN0YXJ0LngsIGJlbmRfaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICByZW5kZXJCZW5kKHN0YXJ0LngsIHN0YXJ0LnksIGxhc3RfZHJhd25fd2lkdGgsIGJlbmRfaGVpZ2h0KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChiZW5kLnR5cGUgPT0gQmVuZC5ET1dOKSB7XG4gICAgICAgICAgaWYgKGxhc3RfYmVuZCAmJiBsYXN0X2JlbmQudHlwZSA9PSBCZW5kLlVQKSB7XG4gICAgICAgICAgICByZW5kZXJSZWxlYXNlKHN0YXJ0LngsIHN0YXJ0LnksIGxhc3RfZHJhd25fd2lkdGgsIGJlbmRfaGVpZ2h0KTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAobGFzdF9iZW5kICYmIGxhc3RfYmVuZC50eXBlID09IEJlbmQuRE9XTikge1xuICAgICAgICAgICAgcmVuZGVyQXJyb3dIZWFkKHN0YXJ0LngsIHN0YXJ0LnksIC0xKTtcbiAgICAgICAgICAgIHJlbmRlclJlbGVhc2Uoc3RhcnQueCwgc3RhcnQueSwgbGFzdF9kcmF3bl93aWR0aCwgYmVuZF9oZWlnaHQpO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGlmIChsYXN0X2JlbmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgbGFzdF9kcmF3bl93aWR0aCA9IGJlbmQuZHJhd193aWR0aDtcbiAgICAgICAgICAgIHJlbmRlclJlbGVhc2Uoc3RhcnQueCwgc3RhcnQueSwgbGFzdF9kcmF3bl93aWR0aCwgYmVuZF9oZWlnaHQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJlbmRlclRleHQoc3RhcnQueCArIGxhc3RfZHJhd25fd2lkdGgsIGJlbmQudGV4dCk7XG4gICAgICAgIGxhc3RfYmVuZCA9IGJlbmQ7XG4gICAgICAgIGxhc3RfYmVuZC54ID0gc3RhcnQueDtcblxuICAgICAgICBzdGFydC54ICs9IGxhc3RfZHJhd25fd2lkdGg7XG4gICAgICB9XG5cbiAgICAgIC8vIEZpbmFsIGFycm93aGVhZCBhbmQgdGV4dFxuICAgICAgaWYgKGxhc3RfYmVuZC50eXBlID09IEJlbmQuVVApIHtcbiAgICAgICAgcmVuZGVyQXJyb3dIZWFkKGxhc3RfYmVuZC54ICsgbGFzdF9kcmF3bl93aWR0aCwgYmVuZF9oZWlnaHQpO1xuICAgICAgfSBlbHNlIGlmIChsYXN0X2JlbmQudHlwZSA9PSBCZW5kLkRPV04pIHtcbiAgICAgICAgcmVuZGVyQXJyb3dIZWFkKGxhc3RfYmVuZC54ICsgbGFzdF9kcmF3bl93aWR0aCwgc3RhcnQueSwgLTEpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIEJlbmQ7XG59KCkpO1xuXG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB2aWJyYXRvcy5cblxuVmV4LkZsb3cuVmlicmF0byA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gVmlicmF0bygpIHsgdGhpcy5pbml0KCk7IH1cbiAgVmlicmF0by5DQVRFR09SWSA9IFwidmlicmF0b3NcIjtcblxuICB2YXIgTW9kaWZpZXIgPSBWZXguRmxvdy5Nb2RpZmllcjtcblxuICAvLyAjIyBTdGF0aWMgTWV0aG9kc1xuICAvLyBBcnJhbmdlIHZpYnJhdG9zIGluc2lkZSBhIGBNb2RpZmllckNvbnRleHRgLlxuICBWaWJyYXRvLmZvcm1hdCA9IGZ1bmN0aW9uKHZpYnJhdG9zLCBzdGF0ZSwgY29udGV4dCkge1xuICAgIGlmICghdmlicmF0b3MgfHwgdmlicmF0b3MubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBWaWJyYXRvcyBhcmUgYWx3YXlzIG9uIHRvcC5cbiAgICB2YXIgdGV4dF9saW5lID0gc3RhdGUudG9wX3RleHRfbGluZTtcbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIHZhciBzaGlmdCA9IHN0YXRlLnJpZ2h0X3NoaWZ0IC0gNztcblxuICAgIC8vIElmIHRoZXJlJ3MgYSBiZW5kLCBkcm9wIHRoZSB0ZXh0IGxpbmVcbiAgICB2YXIgYmVuZHMgPSBjb250ZXh0LmdldE1vZGlmaWVycyhWZXguRmxvdy5CZW5kLkNBVEVHT1JZKTtcbiAgICBpZiAoYmVuZHMgJiYgYmVuZHMubGVuZ3RoID4gMCkge1xuICAgICAgdGV4dF9saW5lLS07XG4gICAgfVxuXG4gICAgLy8gRm9ybWF0IFZpYnJhdG9zXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2aWJyYXRvcy5sZW5ndGg7ICsraSkge1xuICAgICAgdmFyIHZpYnJhdG8gPSB2aWJyYXRvc1tpXTtcbiAgICAgIHZpYnJhdG8uc2V0WFNoaWZ0KHNoaWZ0KTtcbiAgICAgIHZpYnJhdG8uc2V0VGV4dExpbmUodGV4dF9saW5lKTtcbiAgICAgIHdpZHRoICs9IHZpYnJhdG8uZ2V0V2lkdGgoKTtcbiAgICAgIHNoaWZ0ICs9IHdpZHRoO1xuICAgIH1cblxuICAgIHN0YXRlLnJpZ2h0X3NoaWZ0ICs9IHdpZHRoO1xuICAgIHN0YXRlLnRvcF90ZXh0X2xpbmUgKz0gMTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICBWZXguSW5oZXJpdChWaWJyYXRvLCBNb2RpZmllciwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHN1cGVyY2xhc3MgPSBWZXguRmxvdy5WaWJyYXRvLnN1cGVyY2xhc3M7XG4gICAgICBzdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5oYXJzaCA9IGZhbHNlO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLlJJR0hUO1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgdmlicmF0b193aWR0aDogMjAsXG4gICAgICAgIHdhdmVfaGVpZ2h0OiA2LFxuICAgICAgICB3YXZlX3dpZHRoOiA0LFxuICAgICAgICB3YXZlX2dpcnRoOiAyXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNldFZpYnJhdG9XaWR0aCh0aGlzLnJlbmRlcl9vcHRpb25zLnZpYnJhdG9fd2lkdGgpO1xuICAgIH0sXG5cbiAgICBzZXRIYXJzaDogZnVuY3Rpb24oaGFyc2gpIHsgdGhpcy5oYXJzaCA9IGhhcnNoOyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRWaWJyYXRvV2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICB0aGlzLnZpYnJhdG9fd2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMuc2V0V2lkdGgodGhpcy52aWJyYXRvX3dpZHRoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IHZpYnJhdG8gd2l0aG91dCBhIGNvbnRleHQuXCIpO1xuICAgICAgaWYgKCF0aGlzLm5vdGUpIHRocm93IG5ldyBWZXguUkVSUihcIk5vTm90ZUZvclZpYnJhdG9cIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IHZpYnJhdG8gd2l0aG91dCBhbiBhdHRhY2hlZCBub3RlLlwiKTtcblxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5ub3RlLmdldE1vZGlmaWVyU3RhcnRYWShWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5SSUdIVCxcbiAgICAgICAgICB0aGlzLmluZGV4KTtcblxuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIHZhciB2aWJyYXRvX3dpZHRoID0gdGhpcy52aWJyYXRvX3dpZHRoO1xuXG4gICAgICBmdW5jdGlvbiByZW5kZXJWaWJyYXRvKHgsIHkpIHtcbiAgICAgICAgdmFyIHdhdmVfd2lkdGggPSB0aGF0LnJlbmRlcl9vcHRpb25zLndhdmVfd2lkdGg7XG4gICAgICAgIHZhciB3YXZlX2dpcnRoID0gdGhhdC5yZW5kZXJfb3B0aW9ucy53YXZlX2dpcnRoO1xuICAgICAgICB2YXIgd2F2ZV9oZWlnaHQgPSB0aGF0LnJlbmRlcl9vcHRpb25zLndhdmVfaGVpZ2h0O1xuICAgICAgICB2YXIgbnVtX3dhdmVzID0gdmlicmF0b193aWR0aCAvIHdhdmVfd2lkdGg7XG5cbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHZhciBpO1xuICAgICAgICBpZiAodGhhdC5oYXJzaCkge1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSArIHdhdmVfZ2lydGggKyAxKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtX3dhdmVzIC8gMjsgKytpKSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB3YXZlX3dpZHRoLCB5IC0gKHdhdmVfaGVpZ2h0IC8gMikpO1xuICAgICAgICAgICAgeCArPSB3YXZlX3dpZHRoO1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4ICsgd2F2ZV93aWR0aCwgeSArICh3YXZlX2hlaWdodCAvIDIpKTtcbiAgICAgICAgICAgIHggKz0gd2F2ZV93aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bV93YXZlcyAvIDI7ICsraSkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4IC0gd2F2ZV93aWR0aCwgKHkgLSAod2F2ZV9oZWlnaHQgLyAyKSkgKyB3YXZlX2dpcnRoICsgMSk7XG4gICAgICAgICAgICB4IC09IHdhdmVfd2lkdGg7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggLSB3YXZlX3dpZHRoLCAoeSArICh3YXZlX2hlaWdodCAvIDIpKSArIHdhdmVfZ2lydGggKyAxKTtcbiAgICAgICAgICAgIHggLT0gd2F2ZV93aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjdHgubW92ZVRvKHgsIHkgKyB3YXZlX2dpcnRoKTtcbiAgICAgICAgICBmb3IgKGkgPSAwOyBpIDwgbnVtX3dhdmVzIC8gMjsgKytpKSB7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgKHdhdmVfd2lkdGggLyAyKSwgeSAtICh3YXZlX2hlaWdodCAvIDIpLFxuICAgICAgICAgICAgICB4ICsgd2F2ZV93aWR0aCwgeSk7XG4gICAgICAgICAgICB4ICs9IHdhdmVfd2lkdGg7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyh4ICsgKHdhdmVfd2lkdGggLyAyKSwgeSArICh3YXZlX2hlaWdodCAvIDIpLFxuICAgICAgICAgICAgICB4ICsgd2F2ZV93aWR0aCwgeSk7XG4gICAgICAgICAgICB4ICs9IHdhdmVfd2lkdGg7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZm9yIChpID0gMDsgaSA8IG51bV93YXZlcyAvIDI7ICsraSkge1xuICAgICAgICAgICAgY3R4LnF1YWRyYXRpY0N1cnZlVG8oXG4gICAgICAgICAgICAgICAgeCAtICh3YXZlX3dpZHRoIC8gMiksXG4gICAgICAgICAgICAgICAgKHkgKyAod2F2ZV9oZWlnaHQgLyAyKSkgKyB3YXZlX2dpcnRoLFxuICAgICAgICAgICAgICAgIHggLSB3YXZlX3dpZHRoLCB5ICsgd2F2ZV9naXJ0aCk7XG4gICAgICAgICAgICB4IC09IHdhdmVfd2lkdGg7XG4gICAgICAgICAgICBjdHgucXVhZHJhdGljQ3VydmVUbyhcbiAgICAgICAgICAgICAgICB4IC0gKHdhdmVfd2lkdGggLyAyKSxcbiAgICAgICAgICAgICAgICAoeSAtICh3YXZlX2hlaWdodCAvIDIpKSArIHdhdmVfZ2lydGgsXG4gICAgICAgICAgICAgICAgeCAtIHdhdmVfd2lkdGgsIHkgKyB3YXZlX2dpcnRoKTtcbiAgICAgICAgICAgIHggLT0gd2F2ZV93aWR0aDtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdnggPSBzdGFydC54ICsgdGhpcy54X3NoaWZ0O1xuICAgICAgdmFyIHZ5ID0gdGhpcy5ub3RlLmdldFlGb3JUb3BUZXh0KHRoaXMudGV4dF9saW5lKSArIDI7XG5cbiAgICAgIHJlbmRlclZpYnJhdG8odngsIHZ5KTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBWaWJyYXRvO1xufSgpKTtcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vL1xuLy8gIyMgRGVzY3JpcHRpb25cbi8vXG4vLyBUaGlzIGZpbGUgaW1wbGVtZW50cyB0ZXh0IGFubm90YXRpb25zIGFzIG1vZGlmaWVycyB0aGF0IGNhbiBiZSBhdHRhY2hlZCB0b1xuLy8gbm90ZXMuXG4vL1xuLy8gU2VlIGB0ZXN0cy9hbm5vdGF0aW9uX3Rlc3RzLmpzYCBmb3IgdXNhZ2UgZXhhbXBsZXMuXG5cblZleC5GbG93LkFubm90YXRpb24gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEFubm90YXRpb24odGV4dCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHRleHQpO1xuICB9XG5cbiAgQW5ub3RhdGlvbi5DQVRFR09SWSA9IFwiYW5ub3RhdGlvbnNcIjtcbiAgdmFyIE1vZGlmaWVyID0gVmV4LkZsb3cuTW9kaWZpZXI7XG5cbiAgLy8gVG8gZW5hYmxlIGxvZ2dpbmcgZm9yIHRoaXMgY2xhc3MuIFNldCBgVmV4LkZsb3cuQW5ub3RhdGlvbi5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoQW5ub3RhdGlvbi5ERUJVRykgVmV4LkwoXCJWZXguRmxvdy5Bbm5vdGF0aW9uXCIsIGFyZ3VtZW50cyk7IH1cblxuICAvLyBUZXh0IGFubm90YXRpb25zIGNhbiBiZSBwb3NpdGlvbmVkIGFuZCBqdXN0aWZpZWQgcmVsYXRpdmUgdG8gdGhlIG5vdGUuXG4gIEFubm90YXRpb24uSnVzdGlmeSA9IHtcbiAgICBMRUZUOiAxLFxuICAgIENFTlRFUjogMixcbiAgICBSSUdIVDogMyxcbiAgICBDRU5URVJfU1RFTTogNFxuICB9O1xuXG4gIEFubm90YXRpb24uVmVydGljYWxKdXN0aWZ5ID0ge1xuICAgIFRPUDogMSxcbiAgICBDRU5URVI6IDIsXG4gICAgQk9UVE9NOiAzLFxuICAgIENFTlRFUl9TVEVNOiA0XG4gIH07XG5cbiAgLy8gQXJyYW5nZSBhbm5vdGF0aW9ucyB3aXRoaW4gYSBgTW9kaWZpZXJDb250ZXh0YFxuICBBbm5vdGF0aW9uLmZvcm1hdCA9IGZ1bmN0aW9uKGFubm90YXRpb25zLCBzdGF0ZSkge1xuICAgIGlmICghYW5ub3RhdGlvbnMgfHwgYW5ub3RhdGlvbnMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYW5ub3RhdGlvbnMubGVuZ3RoOyArK2kpIHtcbiAgICAgIHZhciBhbm5vdGF0aW9uID0gYW5ub3RhdGlvbnNbaV07XG4gICAgICB3aWR0aCA9IE1hdGgubWF4KGFubm90YXRpb24uZ2V0V2lkdGgoKSwgd2lkdGgpO1xuICAgICAgaWYgKGFubm90YXRpb24uZ2V0UG9zaXRpb24oKSA9PT0gTW9kaWZpZXIuUG9zaXRpb24uQUJPVkUpIHtcbiAgICAgICAgYW5ub3RhdGlvbi5zZXRUZXh0TGluZShzdGF0ZS50b3BfdGV4dF9saW5lKTtcbiAgICAgICAgc3RhdGUudG9wX3RleHRfbGluZSsrO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYW5ub3RhdGlvbi5zZXRUZXh0TGluZShzdGF0ZS50ZXh0X2xpbmUpO1xuICAgICAgICBzdGF0ZS50ZXh0X2xpbmUrKztcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5sZWZ0X3NoaWZ0ICs9IHdpZHRoIC8gMjtcbiAgICBzdGF0ZS5yaWdodF9zaGlmdCArPSB3aWR0aCAvIDI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgLy9cbiAgLy8gQW5ub3RhdGlvbnMgaW5oZXJpdCBmcm9tIGBNb2RpZmllcmAgYW5kIGlzIHBvc2l0aW9uZWQgY29ycmVjdGx5IHdoZW5cbiAgLy8gaW4gYSBgTW9kaWZpZXJDb250ZXh0YC5cbiAgVmV4LkluaGVyaXQoQW5ub3RhdGlvbiwgTW9kaWZpZXIsIHtcbiAgICAvLyBDcmVhdGUgYSBuZXcgYEFubm90YXRpb25gIHdpdGggdGhlIHN0cmluZyBgdGV4dGAuXG4gICAgaW5pdDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgQW5ub3RhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5ub3RlID0gbnVsbDtcbiAgICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICAgIHRoaXMuanVzdGlmaWNhdGlvbiA9IEFubm90YXRpb24uSnVzdGlmeS5DRU5URVI7XG4gICAgICB0aGlzLnZlcnRfanVzdGlmaWNhdGlvbiA9IEFubm90YXRpb24uVmVydGljYWxKdXN0aWZ5LlRPUDtcbiAgICAgIHRoaXMuZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiBcIkFyaWFsXCIsXG4gICAgICAgIHNpemU6IDEwLFxuICAgICAgICB3ZWlnaHQ6IFwiXCJcbiAgICAgIH07XG5cbiAgICAgIC8vIFRoZSBkZWZhdWx0IHdpZHRoIGlzIGNhbGN1bGF0ZWQgZnJvbSB0aGUgdGV4dC5cbiAgICAgIHRoaXMuc2V0V2lkdGgoVmV4LkZsb3cudGV4dFdpZHRoKHRleHQpKTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IGZvbnQgZmFtaWx5LCBzaXplLCBhbmQgd2VpZ2h0LiBFLmcuLCBgQXJpYWxgLCBgMTBwdGAsIGBCb2xkYC5cbiAgICBzZXRGb250OiBmdW5jdGlvbihmYW1pbHksIHNpemUsIHdlaWdodCkge1xuICAgICAgdGhpcy5mb250ID0geyBmYW1pbHk6IGZhbWlseSwgc2l6ZTogc2l6ZSwgd2VpZ2h0OiB3ZWlnaHQgfTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdmVydGljYWwgcG9zaXRpb24gb2YgdGV4dCAoYWJvdmUgb3IgYmVsb3cgc3RhdmUpLiBganVzdGAgbXVzdCBiZVxuICAgIC8vIGEgdmFsdWUgaW4gYEFubm90YXRpb24uVmVydGljYWxKdXN0aWZ5YC5cbiAgICBzZXRWZXJ0aWNhbEp1c3RpZmljYXRpb246IGZ1bmN0aW9uKGp1c3QpIHtcbiAgICAgIHRoaXMudmVydF9qdXN0aWZpY2F0aW9uID0ganVzdDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYW5kIHNldCBob3Jpem9udGFsIGp1c3RpZmljYXRpb24uIGBqdXN0aWZpY2F0aW9uYCBpcyBhIHZhbHVlIGluXG4gICAgLy8gYEFubm90YXRpb24uSnVzdGlmeWAuXG4gICAgZ2V0SnVzdGlmaWNhdGlvbjogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmp1c3RpZmljYXRpb247IH0sXG4gICAgc2V0SnVzdGlmaWNhdGlvbjogZnVuY3Rpb24oanVzdGlmaWNhdGlvbikge1xuICAgICAgdGhpcy5qdXN0aWZpY2F0aW9uID0ganVzdGlmaWNhdGlvbjsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBSZW5kZXIgdGV4dCBiZXNpZGUgdGhlIG5vdGUuXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9Db250ZXh0XCIsXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyB0ZXh0IGFubm90YXRpb24gd2l0aG91dCBhIGNvbnRleHQuXCIpO1xuICAgICAgaWYgKCF0aGlzLm5vdGUpIHRocm93IG5ldyBWZXguUkVSUihcIk5vTm90ZUZvckFubm90YXRpb25cIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IHRleHQgYW5ub3RhdGlvbiB3aXRob3V0IGFuIGF0dGFjaGVkIG5vdGUuXCIpO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLm5vdGUuZ2V0TW9kaWZpZXJTdGFydFhZKE1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFLFxuICAgICAgICAgIHRoaXMuaW5kZXgpO1xuXG4gICAgICAvLyBXZSdyZSBjaGFuZ2luZyBjb250ZXh0IHBhcmFtZXRlcnMuIFNhdmUgY3VycmVudCBzdGF0ZS5cbiAgICAgIHRoaXMuY29udGV4dC5zYXZlKCk7XG4gICAgICB0aGlzLmNvbnRleHQuc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSwgdGhpcy5mb250LndlaWdodCk7XG4gICAgICB2YXIgdGV4dF93aWR0aCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dCh0aGlzLnRleHQpLndpZHRoO1xuXG4gICAgICAvLyBFc3RpbWF0ZSB0ZXh0IGhlaWdodCB0byBiZSB0aGUgc2FtZSBhcyB0aGUgd2lkdGggb2YgYW4gJ20nLlxuICAgICAgLy9cbiAgICAgIC8vIFRoaXMgaXMgYSBoYWNrIHRvIHdvcmsgYXJvdW5kIHRoZSBpbmFiaWxpdHkgdG8gbWVhc3VyZSB0ZXh0IGhlaWdodFxuICAgICAgLy8gaW4gSFRNTDUgQ2FudmFzIChhbmQgU1ZHKS5cbiAgICAgIHZhciB0ZXh0X2hlaWdodCA9IHRoaXMuY29udGV4dC5tZWFzdXJlVGV4dChcIm1cIikud2lkdGg7XG4gICAgICB2YXIgeCwgeTtcblxuICAgICAgaWYgKHRoaXMuanVzdGlmaWNhdGlvbiA9PSBBbm5vdGF0aW9uLkp1c3RpZnkuTEVGVCkge1xuICAgICAgICB4ID0gc3RhcnQueDtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5qdXN0aWZpY2F0aW9uID09IEFubm90YXRpb24uSnVzdGlmeS5SSUdIVCkge1xuICAgICAgICB4ID0gc3RhcnQueCAtIHRleHRfd2lkdGg7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuanVzdGlmaWNhdGlvbiA9PSBBbm5vdGF0aW9uLkp1c3RpZnkuQ0VOVEVSKSB7XG4gICAgICAgIHggPSBzdGFydC54IC0gdGV4dF93aWR0aCAvIDI7XG4gICAgICB9IGVsc2UgLyogQ0VOVEVSX1NURU0gKi8ge1xuICAgICAgICB4ID0gdGhpcy5ub3RlLmdldFN0ZW1YKCkgLSB0ZXh0X3dpZHRoIC8gMjtcbiAgICAgIH1cblxuICAgICAgdmFyIHN0ZW1fZXh0LCBzcGFjaW5nO1xuICAgICAgdmFyIGhhc19zdGVtID0gdGhpcy5ub3RlLmhhc1N0ZW0oKTtcbiAgICAgIHZhciBzdGF2ZSA9IHRoaXMubm90ZS5nZXRTdGF2ZSgpO1xuXG4gICAgICAvLyBUaGUgcG9zaXRpb24gb2YgdGhlIHRleHQgdmFyaWVzIGJhc2VkIG9uIHdoZXRoZXIgb3Igbm90IHRoZSBub3RlXG4gICAgICAvLyBoYXMgYSBzdGVtLlxuICAgICAgaWYgKGhhc19zdGVtKSB7XG4gICAgICAgIHN0ZW1fZXh0ID0gdGhpcy5ub3RlLmdldFN0ZW0oKS5nZXRFeHRlbnRzKCk7XG4gICAgICAgIHNwYWNpbmcgPSBzdGF2ZS5nZXRTcGFjaW5nQmV0d2VlbkxpbmVzKCk7XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnZlcnRfanVzdGlmaWNhdGlvbiA9PSBBbm5vdGF0aW9uLlZlcnRpY2FsSnVzdGlmeS5CT1RUT00pIHtcbiAgICAgICAgeSA9IHN0YXZlLmdldFlGb3JCb3R0b21UZXh0KHRoaXMudGV4dF9saW5lKTtcbiAgICAgICAgaWYgKGhhc19zdGVtKSB7XG4gICAgICAgICAgdmFyIHN0ZW1fYmFzZSA9ICh0aGlzLm5vdGUuZ2V0U3RlbURpcmVjdGlvbigpID09PSAxID8gc3RlbV9leHQuYmFzZVkgOiBzdGVtX2V4dC50b3BZKTtcbiAgICAgICAgICB5ID0gTWF0aC5tYXgoeSwgc3RlbV9iYXNlICsgKHNwYWNpbmcgKiAodGhpcy50ZXh0X2xpbmUgKyAyKSkpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudmVydF9qdXN0aWZpY2F0aW9uID09XG4gICAgICAgICAgICAgICAgIEFubm90YXRpb24uVmVydGljYWxKdXN0aWZ5LkNFTlRFUikge1xuICAgICAgICB2YXIgeXQgPSB0aGlzLm5vdGUuZ2V0WUZvclRvcFRleHQodGhpcy50ZXh0X2xpbmUpIC0gMTtcbiAgICAgICAgdmFyIHliID0gc3RhdmUuZ2V0WUZvckJvdHRvbVRleHQodGhpcy50ZXh0X2xpbmUpO1xuICAgICAgICB5ID0geXQgKyAoIHliIC0geXQgKSAvIDIgKyB0ZXh0X2hlaWdodCAvIDI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMudmVydF9qdXN0aWZpY2F0aW9uID09XG4gICAgICAgICAgICAgICAgIEFubm90YXRpb24uVmVydGljYWxKdXN0aWZ5LlRPUCkge1xuICAgICAgICB5ID0gTWF0aC5taW4oc3RhdmUuZ2V0WUZvclRvcFRleHQodGhpcy50ZXh0X2xpbmUpLCB0aGlzLm5vdGUuZ2V0WXMoKVswXSAtIDEwKTtcbiAgICAgICAgaWYgKGhhc19zdGVtKSB7XG4gICAgICAgICAgeSA9IE1hdGgubWluKHksIChzdGVtX2V4dC50b3BZIC0gNSkgLSAoc3BhY2luZyAqIHRoaXMudGV4dF9saW5lKSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSAvKiBDRU5URVJfU1RFTSAqL3tcbiAgICAgICAgdmFyIGV4dGVudHMgPSB0aGlzLm5vdGUuZ2V0U3RlbUV4dGVudHMoKTtcbiAgICAgICAgeSA9IGV4dGVudHMudG9wWSArIChleHRlbnRzLmJhc2VZIC0gZXh0ZW50cy50b3BZKSAvIDIgK1xuICAgICAgICAgIHRleHRfaGVpZ2h0IC8gMjtcbiAgICAgIH1cblxuICAgICAgTChcIlJlbmRlcmluZyBhbm5vdGF0aW9uOiBcIiwgdGhpcy50ZXh0LCB4LCB5KTtcbiAgICAgIHRoaXMuY29udGV4dC5maWxsVGV4dCh0aGlzLnRleHQsIHgsIHkpO1xuICAgICAgdGhpcy5jb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBBbm5vdGF0aW9uO1xufSgpKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy8gQXV0aG9yOiBMYXJyeSBLdWhucy5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIGFydGljdWxhdGlvbnMgYW5kIGFjY2VudHMgYXMgbW9kaWZpZXJzIHRoYXQgY2FuIGJlXG4vLyBhdHRhY2hlZCB0byBub3Rlcy4gVGhlIGNvbXBsZXRlIGxpc3Qgb2YgYXJ0aWN1bGF0aW9ucyBpcyBhdmFpbGFibGUgaW5cbi8vIGB0YWJsZXMuanNgIHVuZGVyIGBWZXguRmxvdy5hcnRpY3VsYXRpb25Db2Rlc2AuXG4vL1xuLy8gU2VlIGB0ZXN0cy9hcnRpY3VsYXRpb25fdGVzdHMuanNgIGZvciB1c2FnZSBleGFtcGxlcy5cblxuVmV4LkZsb3cuQXJ0aWN1bGF0aW9uID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBBcnRpY3VsYXRpb24odHlwZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHR5cGUpO1xuICB9XG4gIEFydGljdWxhdGlvbi5DQVRFR09SWSA9IFwiYXJ0aWN1bGF0aW9uc1wiO1xuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93LkFydGljdWxhdGlvbi5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoQXJ0aWN1bGF0aW9uLkRFQlVHKSBWZXguTChcIlZleC5GbG93LkFydGljdWxhdGlvblwiLCBhcmd1bWVudHMpOyB9XG5cbiAgdmFyIE1vZGlmaWVyID0gVmV4LkZsb3cuTW9kaWZpZXI7XG5cbiAgLy8gIyMgU3RhdGljIE1ldGhvZHNcbiAgLy8gQXJyYW5nZSBhcnRpY3VsYXRpb25zIGluc2lkZSBgTW9kaWZpZXJDb250ZXh0YFxuICBBcnRpY3VsYXRpb24uZm9ybWF0ID0gZnVuY3Rpb24oYXJ0aWN1bGF0aW9ucywgc3RhdGUpIHtcbiAgICBpZiAoIWFydGljdWxhdGlvbnMgfHwgYXJ0aWN1bGF0aW9ucy5sZW5ndGggPT09IDApIHJldHVybiBmYWxzZTtcblxuICAgIHZhciB3aWR0aCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnRpY3VsYXRpb25zLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgaW5jcmVtZW50ID0gMTtcbiAgICAgIHZhciBhcnRpY3VsYXRpb24gPSBhcnRpY3VsYXRpb25zW2ldO1xuICAgICAgd2lkdGggPSBNYXRoLm1heChhcnRpY3VsYXRpb24uZ2V0V2lkdGgoKSwgd2lkdGgpO1xuXG4gICAgICB2YXIgdHlwZSA9IFZleC5GbG93LmFydGljdWxhdGlvbkNvZGVzKGFydGljdWxhdGlvbi50eXBlKTtcblxuICAgICAgaWYgKCF0eXBlLmJldHdlZW5fbGluZXMpIGluY3JlbWVudCArPSAxLjU7XG5cbiAgICAgIGlmIChhcnRpY3VsYXRpb24uZ2V0UG9zaXRpb24oKSA9PT0gTW9kaWZpZXIuUG9zaXRpb24uQUJPVkUpIHtcbiAgICAgICAgYXJ0aWN1bGF0aW9uLnNldFRleHRMaW5lKHN0YXRlLnRvcF90ZXh0X2xpbmUpO1xuICAgICAgICBzdGF0ZS50b3BfdGV4dF9saW5lICs9IGluY3JlbWVudDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGFydGljdWxhdGlvbi5zZXRUZXh0TGluZShzdGF0ZS50ZXh0X2xpbmUpO1xuICAgICAgICBzdGF0ZS50ZXh0X2xpbmUgKz0gaW5jcmVtZW50O1xuICAgICAgfVxuICAgIH1cblxuICAgIHN0YXRlLmxlZnRfc2hpZnQgKz0gd2lkdGggLyAyO1xuICAgIHN0YXRlLnJpZ2h0X3NoaWZ0ICs9IHdpZHRoIC8gMjtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICBWZXguSW5oZXJpdChBcnRpY3VsYXRpb24sIE1vZGlmaWVyLCB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IGFydGljdWxhdGlvbiBvZiB0eXBlIGB0eXBlYCwgd2hpY2ggaXMgYW4gZW50cnkgaW5cbiAgICAvLyBgVmV4LkZsb3cuYXJ0aWN1bGF0aW9uQ29kZXNgIGluIGB0YWJsZXMuanNgLlxuICAgIGluaXQ6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIEFydGljdWxhdGlvbi5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5ub3RlID0gbnVsbDtcbiAgICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBNb2RpZmllci5Qb3NpdGlvbi5CRUxPVztcblxuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgZm9udF9zY2FsZTogMzhcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXJ0aWN1bGF0aW9uID0gVmV4LkZsb3cuYXJ0aWN1bGF0aW9uQ29kZXModGhpcy50eXBlKTtcbiAgICAgIGlmICghdGhpcy5hcnRpY3VsYXRpb24pIHRocm93IG5ldyBWZXguUkVSUihcIkFyZ3VtZW50RXJyb3JcIixcbiAgICAgICAgIFwiQXJ0aWN1bGF0aW9uIG5vdCBmb3VuZDogJ1wiICsgdGhpcy50eXBlICsgXCInXCIpO1xuXG4gICAgICAvLyBEZWZhdWx0IHdpZHRoIGNvbWVzIGZyb20gYXJ0aWN1bGF0aW9uIHRhYmxlLlxuICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLmFydGljdWxhdGlvbi53aWR0aCk7XG4gICAgfSxcblxuICAgIC8vIFJlbmRlciBhcnRpY3VsYXRpb24gaW4gcG9zaXRpb24gbmV4dCB0byBub3RlLlxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgQXJ0aWN1bGF0aW9uIHdpdGhvdXQgYSBjb250ZXh0LlwiKTtcbiAgICAgIGlmICghKHRoaXMubm90ZSAmJiAodGhpcy5pbmRleCAhPT0gbnVsbCkpKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0F0dGFjaGVkTm90ZVwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgQXJ0aWN1bGF0aW9uIHdpdGhvdXQgYSBub3RlIGFuZCBpbmRleC5cIik7XG5cbiAgICAgIHZhciBzdGVtX2RpcmVjdGlvbiA9IHRoaXMubm90ZS5nZXRTdGVtRGlyZWN0aW9uKCk7XG4gICAgICB2YXIgc3RhdmUgPSB0aGlzLm5vdGUuZ2V0U3RhdmUoKTtcblxuICAgICAgdmFyIGlzX29uX2hlYWQgPSAodGhpcy5wb3NpdGlvbiA9PT0gTW9kaWZpZXIuUG9zaXRpb24uQUJPVkUgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZW1fZGlyZWN0aW9uID09PSBWZXguRmxvdy5TdGF2ZU5vdGUuU1RFTV9ET1dOKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAodGhpcy5wb3NpdGlvbiA9PT0gTW9kaWZpZXIuUG9zaXRpb24uQkVMT1cgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIHN0ZW1fZGlyZWN0aW9uID09PSBWZXguRmxvdy5TdGF2ZU5vdGUuU1RFTV9VUCk7XG5cbiAgICAgIHZhciBuZWVkc0xpbmVBZGp1c3RtZW50ID0gZnVuY3Rpb24oYXJ0aWN1bGF0aW9uLCBub3RlX2xpbmUsIGxpbmVfc3BhY2luZykge1xuICAgICAgICB2YXIgb2Zmc2V0X2RpcmVjdGlvbiA9IChhcnRpY3VsYXRpb24ucG9zaXRpb24gPT09IE1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFKSA/IDEgOiAtMTtcbiAgICAgICAgdmFyIGR1cmF0aW9uID0gYXJ0aWN1bGF0aW9uLmdldE5vdGUoKS5nZXREdXJhdGlvbigpO1xuICAgICAgICBpZighaXNfb25faGVhZCAmJiBWZXguRmxvdy5kdXJhdGlvblRvTnVtYmVyKGR1cmF0aW9uKSA8PSAxKXtcbiAgICAgICAgICAvLyBBZGQgc3RlbSBsZW5ndGgsIHVubGVzcyBpdCdzIG9uIGEgd2hvbGUgbm90ZS5cbiAgICAgICAgICBub3RlX2xpbmUgKz0gb2Zmc2V0X2RpcmVjdGlvbiAqIDMuNTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhcnRpY3VsYXRpb25fbGluZSA9IG5vdGVfbGluZSArIChvZmZzZXRfZGlyZWN0aW9uICogbGluZV9zcGFjaW5nKTtcblxuICAgICAgICBpZihhcnRpY3VsYXRpb25fbGluZSA+PSAxICYmXG4gICAgICAgICAgIGFydGljdWxhdGlvbl9saW5lIDw9IDUgJiZcbiAgICAgICAgICAgYXJ0aWN1bGF0aW9uX2xpbmUgJSAxID09PSAwKXtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG5cbiAgICAgIC8vIEFydGljdWxhdGlvbnMgYXJlIGNlbnRlcmVkIG92ZXIvdW5kZXIgdGhlIG5vdGUgaGVhZC5cbiAgICAgIHZhciBzdGFydCA9IHRoaXMubm90ZS5nZXRNb2RpZmllclN0YXJ0WFkodGhpcy5wb3NpdGlvbiwgdGhpcy5pbmRleCk7XG4gICAgICB2YXIgZ2x5cGhfeSA9IHN0YXJ0Lnk7XG4gICAgICB2YXIgc2hpZnRZID0gMDtcbiAgICAgIHZhciBsaW5lX3NwYWNpbmcgPSAxO1xuICAgICAgdmFyIHNwYWNpbmcgPSBzdGF2ZS5nZXRTcGFjaW5nQmV0d2VlbkxpbmVzKCk7XG4gICAgICB2YXIgaXNfdGFibm90ZSA9IHRoaXMubm90ZS5nZXRDYXRlZ29yeSgpID09PSAndGFibm90ZXMnO1xuICAgICAgdmFyIHN0ZW1fZXh0ID0gdGhpcy5ub3RlLmdldFN0ZW0oKS5nZXRFeHRlbnRzKCk7XG5cbiAgICAgIHZhciB0b3AgPSBzdGVtX2V4dC50b3BZO1xuICAgICAgdmFyIGJvdHRvbSA9IHN0ZW1fZXh0LmJhc2VZO1xuXG4gICAgICBpZiAoc3RlbV9kaXJlY3Rpb24gPT09IFZleC5GbG93LlN0YXZlTm90ZS5TVEVNX0RPV04pIHtcbiAgICAgICAgdG9wID0gc3RlbV9leHQuYmFzZVk7XG4gICAgICAgIGJvdHRvbSA9IHN0ZW1fZXh0LnRvcFk7XG4gICAgICB9XG5cbiAgICAgIC8vIFRhYk5vdGVzIGRvbid0IGhhdmUgc3RlbXMgYXR0YWNoZWQgdG8gdGhlbS4gVGFiIHN0ZW1zIGFyZSByZW5kZXJlZFxuICAgICAgLy8gb3V0c2lkZSB0aGUgc3RhdmUuXG4gICAgICBpZiAoaXNfdGFibm90ZSkge1xuICAgICAgICBpZiAodGhpcy5ub3RlLmhhc1N0ZW0oKSl7XG4gICAgICAgICAgaWYgKHN0ZW1fZGlyZWN0aW9uID09PSBWZXguRmxvdy5TdGF2ZU5vdGUuU1RFTV9VUCkge1xuICAgICAgICAgICAgYm90dG9tID0gc3RhdmUuZ2V0WUZvckJvdHRvbVRleHQodGhpcy50ZXh0X2xpbmUgLSAyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0ZW1fZGlyZWN0aW9uID09PSBWZXguRmxvdy5TdGF2ZU5vdGUuU1RFTV9ET1dOICkge1xuICAgICAgICAgICAgdG9wID0gc3RhdmUuZ2V0WUZvclRvcFRleHQodGhpcy50ZXh0X2xpbmUgLSAxLjUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gV2l0aG91dCBhIHN0ZW1cbiAgICAgICAgICB0b3AgPSBzdGF2ZS5nZXRZRm9yVG9wVGV4dCh0aGlzLnRleHRfbGluZSAtIDEpO1xuICAgICAgICAgIGJvdHRvbSA9IHN0YXZlLmdldFlGb3JCb3R0b21UZXh0KHRoaXMudGV4dF9saW5lIC0gMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGlzX2Fib3ZlID0gKHRoaXMucG9zaXRpb24gPT09IE1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFKSA/IHRydWUgOiBmYWxzZTtcbiAgICAgIHZhciBub3RlX2xpbmUgPSB0aGlzLm5vdGUuZ2V0TGluZU51bWJlcihpc19hYm92ZSk7XG5cbiAgICAgIC8vIEJlYW1lZCBzdGVtcyBhcmUgbG9uZ2VyIHRoYW4gcXVhcnRlciBub3RlIHN0ZW1zLlxuICAgICAgaWYgKCFpc19vbl9oZWFkICYmIHRoaXMubm90ZS5iZWFtKSBsaW5lX3NwYWNpbmcgKz0gMC41O1xuXG4gICAgICAvLyBJZiBhcnRpY3VsYXRpb24gd2lsbCBvdmVybGFwIGEgbGluZSwgcmVwb3NpdGlvbiBpdC5cbiAgICAgIGlmIChuZWVkc0xpbmVBZGp1c3RtZW50KHRoaXMsIG5vdGVfbGluZSwgbGluZV9zcGFjaW5nKSkgbGluZV9zcGFjaW5nICs9IDAuNTtcblxuICAgICAgdmFyIGdseXBoX3lfYmV0d2Vlbl9saW5lcztcbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09PSBNb2RpZmllci5Qb3NpdGlvbi5BQk9WRSkge1xuICAgICAgICBzaGlmdFkgPSB0aGlzLmFydGljdWxhdGlvbi5zaGlmdF91cDtcbiAgICAgICAgZ2x5cGhfeV9iZXR3ZWVuX2xpbmVzID0gKHRvcCAtIDcpIC0gKHNwYWNpbmcgKiAodGhpcy50ZXh0X2xpbmUgKyBsaW5lX3NwYWNpbmcpKTtcblxuICAgICAgICBpZiAodGhpcy5hcnRpY3VsYXRpb24uYmV0d2Vlbl9saW5lcykge1xuICAgICAgICAgIGdseXBoX3kgPSBnbHlwaF95X2JldHdlZW5fbGluZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2x5cGhfeSA9IE1hdGgubWluKHN0YXZlLmdldFlGb3JUb3BUZXh0KHRoaXMudGV4dF9saW5lKSAtIDMsIGdseXBoX3lfYmV0d2Vlbl9saW5lcyk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNoaWZ0WSA9IHRoaXMuYXJ0aWN1bGF0aW9uLnNoaWZ0X2Rvd24gLSAxMDtcblxuICAgICAgICBnbHlwaF95X2JldHdlZW5fbGluZXMgPSBib3R0b20gKyAxMCArIHNwYWNpbmcgKiAodGhpcy50ZXh0X2xpbmUgKyBsaW5lX3NwYWNpbmcpO1xuICAgICAgICBpZiAodGhpcy5hcnRpY3VsYXRpb24uYmV0d2Vlbl9saW5lcykge1xuICAgICAgICAgIGdseXBoX3kgPSBnbHlwaF95X2JldHdlZW5fbGluZXM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZ2x5cGhfeSA9IE1hdGgubWF4KHN0YXZlLmdldFlGb3JCb3R0b21UZXh0KHRoaXMudGV4dF9saW5lKSwgZ2x5cGhfeV9iZXR3ZWVuX2xpbmVzKTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgZ2x5cGhfeCA9IHN0YXJ0LnggKyB0aGlzLmFydGljdWxhdGlvbi5zaGlmdF9yaWdodDtcbiAgICAgIGdseXBoX3kgKz0gc2hpZnRZICsgdGhpcy55X3NoaWZ0O1xuXG4gICAgICBMKFwiUmVuZGVyaW5nIGFydGljdWxhdGlvbjogXCIsIHRoaXMuYXJ0aWN1bGF0aW9uLCBnbHlwaF94LCBnbHlwaF95KTtcbiAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKHRoaXMuY29udGV4dCwgZ2x5cGhfeCwgZ2x5cGhfeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuZm9udF9zY2FsZSwgdGhpcy5hcnRpY3VsYXRpb24uY29kZSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQXJ0aWN1bGF0aW9uO1xufSgpKTtcbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyB2YXJpZXMgdHlwZXMgb2YgdHVuaW5ncyBmb3IgdGFibGF0dXJlLlxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5WZXguRmxvdy5UdW5pbmcgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFR1bmluZyh0dW5pbmdTdHJpbmcpIHtcbiAgICB0aGlzLmluaXQodHVuaW5nU3RyaW5nKTtcbiAgfVxuXG4gIFR1bmluZy5uYW1lcyA9IHtcbiAgICBcInN0YW5kYXJkXCI6IFwiRS81LEIvNCxHLzQsRC80LEEvMyxFLzNcIixcbiAgICBcImRhZ2RhZFwiOiBcIkQvNSxBLzQsRy80LEQvNCxBLzMsRC8zXCIsXG4gICAgXCJkcm9wZFwiOiBcIkUvNSxCLzQsRy80LEQvNCxBLzMsRC8zXCIsXG4gICAgXCJlYlwiOiBcIkViLzUsQmIvNCxHYi80LERiLzQsQWIvMyxEYi8zXCIsXG4gICAgXCJzdGFuZGFyZEJhbmpvXCI6IFwiRC81LEIvNCxHLzQsRC80LEcvNVwiXG4gIH07XG5cbiAgVHVuaW5nLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbih0dW5pbmdTdHJpbmcpIHtcbiAgICAgIC8vIERlZmF1bHQgdG8gc3RhbmRhcmQgdHVuaW5nLlxuICAgICAgdGhpcy5zZXRUdW5pbmcodHVuaW5nU3RyaW5nIHx8IFwiRS81LEIvNCxHLzQsRC80LEEvMyxFLzMsQi8yLEUvMlwiKTtcbiAgICB9LFxuXG4gICAgbm90ZVRvSW50ZWdlcjogZnVuY3Rpb24obm90ZVN0cmluZykge1xuICAgICAgcmV0dXJuIFZleC5GbG93LmtleVByb3BlcnRpZXMobm90ZVN0cmluZykuaW50X3ZhbHVlO1xuICAgIH0sXG5cbiAgICBzZXRUdW5pbmc6IGZ1bmN0aW9uKG5vdGVTdHJpbmcpIHtcbiAgICAgIGlmIChWZXguRmxvdy5UdW5pbmcubmFtZXNbbm90ZVN0cmluZ10pXG4gICAgICAgIG5vdGVTdHJpbmcgPSBWZXguRmxvdy5UdW5pbmcubmFtZXNbbm90ZVN0cmluZ107XG5cbiAgICAgIHRoaXMudHVuaW5nU3RyaW5nID0gbm90ZVN0cmluZztcbiAgICAgIHRoaXMudHVuaW5nVmFsdWVzID0gW107XG4gICAgICB0aGlzLm51bVN0cmluZ3MgPSAwO1xuXG4gICAgICB2YXIga2V5cyA9IG5vdGVTdHJpbmcuc3BsaXQoL1xccyosXFxzKi8pO1xuICAgICAgaWYgKGtleXMubGVuZ3RoID09PSAwKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJJbnZhbGlkIHR1bmluZyBzdHJpbmc6IFwiICsgbm90ZVN0cmluZyk7XG5cbiAgICAgIHRoaXMubnVtU3RyaW5ncyA9IGtleXMubGVuZ3RoO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLm51bVN0cmluZ3M7ICsraSkge1xuICAgICAgICB0aGlzLnR1bmluZ1ZhbHVlc1tpXSA9IHRoaXMubm90ZVRvSW50ZWdlcihrZXlzW2ldKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0VmFsdWVGb3JTdHJpbmc6IGZ1bmN0aW9uKHN0cmluZ051bSkge1xuICAgICAgdmFyIHMgPSBwYXJzZUludChzdHJpbmdOdW0sIDEwKTtcbiAgICAgIGlmIChzIDwgMSB8fCBzID4gdGhpcy5udW1TdHJpbmdzKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJTdHJpbmcgbnVtYmVyIG11c3QgYmUgYmV0d2VlbiAxIGFuZCBcIiArXG4gICAgICAgICAgICB0aGlzLm51bVN0cmluZ3MgKyBcIjogXCIgKyBzdHJpbmdOdW0pO1xuXG4gICAgICByZXR1cm4gdGhpcy50dW5pbmdWYWx1ZXNbcyAtIDFdO1xuICAgIH0sXG5cbiAgICBnZXRWYWx1ZUZvckZyZXQ6IGZ1bmN0aW9uKGZyZXROdW0sIHN0cmluZ051bSkge1xuICAgICAgdmFyIHN0cmluZ1ZhbHVlID0gdGhpcy5nZXRWYWx1ZUZvclN0cmluZyhzdHJpbmdOdW0pO1xuICAgICAgdmFyIGYgPSBwYXJzZUludChmcmV0TnVtLCAxMCk7XG5cbiAgICAgIGlmIChmIDwgMCkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJGcmV0IG51bWJlciBtdXN0IGJlIDAgb3IgaGlnaGVyOiBcIiArXG4gICAgICAgICAgICBmcmV0TnVtKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHN0cmluZ1ZhbHVlICsgZjtcbiAgICB9LFxuXG4gICAgZ2V0Tm90ZUZvckZyZXQ6IGZ1bmN0aW9uKGZyZXROdW0sIHN0cmluZ051bSkge1xuICAgICAgdmFyIG5vdGVWYWx1ZSA9IHRoaXMuZ2V0VmFsdWVGb3JGcmV0KGZyZXROdW0sIHN0cmluZ051bSk7XG5cbiAgICAgIHZhciBvY3RhdmUgPSBNYXRoLmZsb29yKG5vdGVWYWx1ZSAvIDEyKTtcbiAgICAgIHZhciB2YWx1ZSA9IG5vdGVWYWx1ZSAlIDEyO1xuXG4gICAgICByZXR1cm4gVmV4LkZsb3cuaW50ZWdlclRvTm90ZSh2YWx1ZSkgKyBcIi9cIiArIG9jdGF2ZTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFR1bmluZztcbn0oKSk7XG5cbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vL1xuLy8gQSBiYXNlIGNsYXNzIGZvciBzdGF2ZSBtb2RpZmllcnMgKGUuZy4gY2xlZnMsIGtleSBzaWduYXR1cmVzKVxuLy9cblxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5WZXguRmxvdy5TdGF2ZU1vZGlmaWVyID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBTdGF2ZU1vZGlmaWVyKCkge1xuICAgIHRoaXMuaW5pdCgpO1xuICB9XG5cbiAgU3RhdmVNb2RpZmllci5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBhZGRpbmcgPSAxMDtcbiAgICB9LFxuXG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkge3JldHVybiBcIlwiO30sXG4gICAgbWFrZVNwYWNlcjogZnVuY3Rpb24ocGFkZGluZykge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZ2V0Q29udGV4dDogZnVuY3Rpb24oKSB7cmV0dXJuIHRydWU7fSxcbiAgICAgICAgc2V0U3RhdmU6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIHJlbmRlclRvU3RhdmU6IGZ1bmN0aW9uKCkge30sXG4gICAgICAgIGdldE1ldHJpY3M6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgIHJldHVybiB7d2lkdGg6IHBhZGRpbmd9O1xuICAgICAgICB9XG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBwbGFjZUdseXBoT25MaW5lOiBmdW5jdGlvbihnbHlwaCwgc3RhdmUsIGxpbmUpIHtcbiAgICAgIGdseXBoLnNldFlTaGlmdChzdGF2ZS5nZXRZRm9yTGluZShsaW5lKSAtIHN0YXZlLmdldFlGb3JHbHlwaHMoKSk7XG4gICAgfSxcblxuICAgIHNldFBhZGRpbmc6IGZ1bmN0aW9uKHBhZGRpbmcpIHtcbiAgICAgIHRoaXMucGFkZGluZyA9IHBhZGRpbmc7XG4gICAgfSxcblxuICAgIGFkZFRvU3RhdmU6IGZ1bmN0aW9uKHN0YXZlLCBmaXJzdEdseXBoKSB7XG4gICAgICBpZiAoIWZpcnN0R2x5cGgpIHtcbiAgICAgICAgc3RhdmUuYWRkR2x5cGgodGhpcy5tYWtlU3BhY2VyKHRoaXMucGFkZGluZykpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZE1vZGlmaWVyKHN0YXZlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhZGRUb1N0YXZlRW5kOiBmdW5jdGlvbihzdGF2ZSwgZmlyc3RHbHlwaCkge1xuICAgICAgaWYgKCFmaXJzdEdseXBoKSB7XG4gICAgICAgIHN0YXZlLmFkZEVuZEdseXBoKHRoaXMubWFrZVNwYWNlcih0aGlzLnBhZGRpbmcpKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBzdGF2ZS5hZGRFbmRHbHlwaCh0aGlzLm1ha2VTcGFjZXIoMikpO1xuICAgICAgfVxuXG4gICAgICB0aGlzLmFkZEVuZE1vZGlmaWVyKHN0YXZlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBhZGRNb2RpZmllcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJNZXRob2ROb3RJbXBsZW1lbnRlZFwiLFxuICAgICAgICAgIFwiYWRkTW9kaWZpZXIoKSBub3QgaW1wbGVtZW50ZWQgZm9yIHRoaXMgc3RhdmUgbW9kaWZpZXIuXCIpO1xuICAgIH0sXG5cbiAgICBhZGRFbmRNb2RpZmllcjogZnVuY3Rpb24oKSB7XG4gICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJNZXRob2ROb3RJbXBsZW1lbnRlZFwiLFxuICAgICAgICAgIFwiYWRkRW5kTW9kaWZpZXIoKSBub3QgaW1wbGVtZW50ZWQgZm9yIHRoaXMgc3RhdmUgbW9kaWZpZXIuXCIpO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU3RhdmVNb2RpZmllcjtcbn0oKSk7XG5cblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXG4vLyBBdXRob3I6IEN5cmlsIFNpbHZlcm1hblxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMga2V5IHNpZ25hdHVyZXMuIEEga2V5IHNpZ25hdHVyZSBzaXRzIG9uIGEgc3RhdmVcbi8vIGFuZCBpbmRpY2F0ZXMgdGhlIG5vdGVzIHdpdGggaW1wbGljaXQgYWNjaWRlbnRhbHMuXG5WZXguRmxvdy5LZXlTaWduYXR1cmUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEtleVNpZ25hdHVyZShrZXlTcGVjKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQoa2V5U3BlYyk7XG4gIH1cblxuICAvLyBTcGFjZSBiZXR3ZWVuIG5hdHVyYWwgYW5kIGZvbGxvd2luZyBhY2NpZGVudGFsIGRlcGVuZGluZ1xuICAvLyBvbiB2ZXJ0aWNhbCBwb3NpdGlvblxuICBLZXlTaWduYXR1cmUuYWNjaWRlbnRhbFNwYWNpbmcgPSB7XG4gICAgJyMnOiB7XG4gICAgICBhYm92ZTogNixcbiAgICAgIGJlbG93OiA0XG4gICAgfSxcbiAgICAnYic6IHtcbiAgICAgIGFib3ZlOiA0LFxuICAgICAgYmVsb3c6IDdcbiAgICB9LFxuICAgICduJzoge1xuICAgICAgYWJvdmU6IDMsXG4gICAgICBiZWxvdzogLTFcbiAgICB9XG4gIH07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgVmV4LkluaGVyaXQoS2V5U2lnbmF0dXJlLCBWZXguRmxvdy5TdGF2ZU1vZGlmaWVyLCB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IEtleSBTaWduYXR1cmUgYmFzZWQgb24gYSBga2V5X3NwZWNgXG4gICAgaW5pdDogZnVuY3Rpb24oa2V5X3NwZWMpIHtcbiAgICAgIEtleVNpZ25hdHVyZS5zdXBlcmNsYXNzLmluaXQoKTtcblxuICAgICAgdGhpcy5nbHlwaEZvbnRTY2FsZSA9IDM4OyAvLyBUT0RPKDB4RkUpOiBTaG91bGQgdGhpcyBtYXRjaCBTdGF2ZU5vdGU/XG4gICAgICB0aGlzLmFjY0xpc3QgPSBWZXguRmxvdy5rZXlTaWduYXR1cmUoa2V5X3NwZWMpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgYW4gYWNjaWRlbnRhbCBnbHlwaCB0byB0aGUgYHN0YXZlYC4gYGFjY2AgaXMgdGhlIGRhdGEgb2YgdGhlXG4gICAgLy8gYWNjaWRlbnRhbCB0byBhZGQuIElmIHRoZSBgbmV4dGAgYWNjaWRlbnRhbCBpcyBhbHNvIHByb3ZpZGVkLCBleHRyYVxuICAgIC8vIHdpZHRoIHdpbGwgYmUgYWRkZWQgdG8gdGhlIGluaXRpYWwgYWNjaWRlbnRhbCBmb3Igb3B0aW1hbCBzcGFjaW5nLlxuICAgIGFkZEFjY1RvU3RhdmU6IGZ1bmN0aW9uKHN0YXZlLCBhY2MsIG5leHQpIHtcbiAgICAgIHZhciBnbHlwaF9kYXRhID0gVmV4LkZsb3cuYWNjaWRlbnRhbENvZGVzKGFjYy50eXBlKTtcbiAgICAgIHZhciBnbHlwaCA9IG5ldyBWZXguRmxvdy5HbHlwaChnbHlwaF9kYXRhLmNvZGUsIHRoaXMuZ2x5cGhGb250U2NhbGUpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgc3BhY2luZyBiZXR3ZWVuIGN1cnJlbnQgYWNjaWRlbnRhbCBhbmQgdGhlIG5leHQgYWNjaWRlbnRhbFxuICAgICAgdmFyIGV4dHJhX3dpZHRoID0gMDtcbiAgICAgIGlmIChhY2MudHlwZSA9PT0gXCJuXCIgJiYgbmV4dCkge1xuICAgICAgICB2YXIgYWJvdmUgPSBuZXh0LmxpbmUgPj0gYWNjLmxpbmU7XG4gICAgICAgIHZhciBzcGFjZSA9IEtleVNpZ25hdHVyZS5hY2NpZGVudGFsU3BhY2luZ1tuZXh0LnR5cGVdO1xuICAgICAgICBleHRyYV93aWR0aCA9IGFib3ZlID8gc3BhY2UuYWJvdmUgOiBzcGFjZS5iZWxvdztcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHRoZSB3aWR0aCBhbmQgcGxhY2UgdGhlIGdseXBoIG9uIHRoZSBzdGF2ZVxuICAgICAgZ2x5cGguc2V0V2lkdGgoZ2x5cGhfZGF0YS53aWR0aCArIGV4dHJhX3dpZHRoKTtcbiAgICAgIHRoaXMucGxhY2VHbHlwaE9uTGluZShnbHlwaCwgc3RhdmUsIGFjYy5saW5lKTtcbiAgICAgIHN0YXZlLmFkZEdseXBoKGdseXBoKTtcbiAgICB9LFxuXG4gICAgLy8gQ2FuY2VsIG91dCBhIGtleSBzaWduYXR1cmUgcHJvdmlkZWQgaW4gdGhlIGBzcGVjYCBwYXJhbWV0ZXIuIFRoaXMgd2lsbFxuICAgIC8vIHBsYWNlIGFwcHJvcHJpYXRlIG5hdHVyYWwgYWNjaWRlbnRhbHMgYmVmb3JlIHRoZSBrZXkgc2lnbmF0dXJlLlxuICAgIGNhbmNlbEtleTogZnVuY3Rpb24oc3BlYykge1xuICAgICAgLy8gR2V0IHRoZSBhY2NpZGVudGFsIGxpc3QgZm9yIHRoZSBjYW5jZWxsZWQga2V5IHNpZ25hdHVyZVxuICAgICAgdmFyIGNhbmNlbF9hY2NMaXN0ID0gVmV4LkZsb3cua2V5U2lnbmF0dXJlKHNwZWMpO1xuXG4gICAgICAvLyBJZiB0aGUgY2FuY2VsbGVkIGtleSBoYXMgYSBkaWZmZXJlbnQgYWNjaWRlbnRhbCB0eXBlLCBpZTogIyB2cyBiXG4gICAgICB2YXIgZGlmZmVyZW50X3R5cGVzID0gdGhpcy5hY2NMaXN0Lmxlbmd0aCA+IDAgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYW5jZWxfYWNjTGlzdFswXS50eXBlICE9PSB0aGlzLmFjY0xpc3RbMF0udHlwZTtcblxuICAgICAgLy8gRGV0ZXJtaW5lIGhvdyBtYW55IG5hdHVyYWxzIG5lZWRlZCB0byBhZGRcbiAgICAgIHZhciBuYXR1cmFscyA9IDA7XG4gICAgICBpZiAoZGlmZmVyZW50X3R5cGVzKSB7XG4gICAgICAgIG5hdHVyYWxzID0gY2FuY2VsX2FjY0xpc3QubGVuZ3RoO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbmF0dXJhbHMgPSBjYW5jZWxfYWNjTGlzdC5sZW5ndGggLSB0aGlzLmFjY0xpc3QubGVuZ3RoO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXR1cm4gaWYgbm8gbmF0dXJhbHMgbmVlZGVkXG4gICAgICBpZiAobmF0dXJhbHMgPCAxKSByZXR1cm47XG5cbiAgICAgIC8vIEdldCB0aGUgbGluZSBwb3NpdGlvbiBmb3IgZWFjaCBuYXR1cmFsXG4gICAgICB2YXIgY2FuY2VsbGVkID0gW107XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5hdHVyYWxzOyBpKyspIHtcbiAgICAgICAgdmFyIGluZGV4ID0gaTtcbiAgICAgICAgaWYgKCFkaWZmZXJlbnRfdHlwZXMpIHtcbiAgICAgICAgICBpbmRleCA9IGNhbmNlbF9hY2NMaXN0Lmxlbmd0aCAtIG5hdHVyYWxzICsgaTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciBhY2MgPSBjYW5jZWxfYWNjTGlzdFtpbmRleF07XG4gICAgICAgIGNhbmNlbGxlZC5wdXNoKHt0eXBlOiBcIm5cIiwgbGluZTogYWNjLmxpbmV9KTtcbiAgICAgIH1cblxuICAgICAgLy8gQ29tYmluZSBuYXR1cmFscyB3aXRoIG1haW4gYWNjaWRlbnRhbCBsaXN0IGZvciB0aGUga2V5IHNpZ25hdHVyZVxuICAgICAgdGhpcy5hY2NMaXN0ID0gY2FuY2VsbGVkLmNvbmNhdCh0aGlzLmFjY0xpc3QpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQWRkIHRoZSBrZXkgc2lnbmF0dXJlIHRvIHRoZSBgc3RhdmVgLiBZb3UgcHJvYmFibHkgd2FudCB0byB1c2UgdGhlIFxuICAgIC8vIGhlbHBlciBtZXRob2QgYC5hZGRUb1N0YXZlKClgIGluc3RlYWRcbiAgICBhZGRNb2RpZmllcjogZnVuY3Rpb24oc3RhdmUpIHtcbiAgICAgIHRoaXMuY29udmVydEFjY0xpbmVzKHN0YXZlLmNsZWYsIHRoaXMuYWNjTGlzdFswXS50eXBlKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5hY2NMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHRoaXMuYWRkQWNjVG9TdGF2ZShzdGF2ZSwgdGhpcy5hY2NMaXN0W2ldLCB0aGlzLmFjY0xpc3RbaSsxXSk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIEFkZCB0aGUga2V5IHNpZ25hdHVyZSB0byB0aGUgYHN0YXZlYCwgaWYgaXQncyB0aGUgbm90IHRoZSBgZmlyc3RHbHlwaGBcbiAgICAvLyBhIHNwYWNlciB3aWxsIGJlIGFkZGVkIGFzIHdlbGwuXG4gICAgYWRkVG9TdGF2ZTogZnVuY3Rpb24oc3RhdmUsIGZpcnN0R2x5cGgpIHtcbiAgICAgIGlmICh0aGlzLmFjY0xpc3QubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgaWYgKCFmaXJzdEdseXBoKSB7XG4gICAgICAgIHN0YXZlLmFkZEdseXBoKHRoaXMubWFrZVNwYWNlcih0aGlzLnBhZGRpbmcpKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5hZGRNb2RpZmllcihzdGF2ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQXBwbHkgdGhlIGFjY2lkZW50YWwgc3RhZmYgbGluZSBwbGFjZW1lbnQgYmFzZWQgb24gdGhlIGBjbGVmYCBhbmRcbiAgICAvLyB0aGUgIGFjY2lkZW50YWwgYHR5cGVgIGZvciB0aGUga2V5IHNpZ25hdHVyZSAoJyMgb3IgJ2InKS5cbiAgICBjb252ZXJ0QWNjTGluZXM6IGZ1bmN0aW9uKGNsZWYsIHR5cGUpIHtcbiAgICAgIHZhciBvZmZzZXQgPSAwLjA7IC8vIGlmIGNsZWYgPT09IFwidHJlYmxlXCJcbiAgICAgIHZhciBjdXN0b21MaW5lczsgLy8gd2hlbiBjbGVmIGRvZXNuJ3QgZm9sbG93IHRyZWJsZSBrZXkgc2lnIHNoYXBlXG5cbiAgICAgIHN3aXRjaCAoY2xlZikge1xuICAgICAgICAvLyBUcmVibGUgJiBTdWJiYXNzIGJvdGggaGF2ZSBvZmZzZXRzIG9mIDAsIHNvIGFyZSBub3QgaW5jbHVkZWQuXG4gICAgICAgIGNhc2UgXCJzb3ByYW5vXCI6XG4gICAgICAgICAgaWYodHlwZSA9PT0gXCIjXCIpIGN1c3RvbUxpbmVzID0gWzIuNSwwLjUsMiwwLDEuNSwtMC41LDFdO1xuICAgICAgICAgIGVsc2Ugb2Zmc2V0ID0gLTE7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJtZXp6by1zb3ByYW5vXCI6XG4gICAgICAgICAgaWYodHlwZSA9PT0gXCJiXCIpIGN1c3RvbUxpbmVzID0gWzAsMiwwLjUsMi41LDEsMywxLjVdO1xuICAgICAgICAgIGVsc2Ugb2Zmc2V0ID0gMS41O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiYWx0b1wiOlxuICAgICAgICAgIG9mZnNldCA9IDAuNTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcInRlbm9yXCI6XG4gICAgICAgICAgaWYodHlwZSA9PT0gXCIjXCIpIGN1c3RvbUxpbmVzID0gWzMsIDEsIDIuNSwgMC41LCAyLCAwLCAxLjVdO1xuICAgICAgICAgIGVsc2Ugb2Zmc2V0ID0gLTAuNTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImJhcml0b25lLWZcIjpcbiAgICAgICAgY2FzZSBcImJhcml0b25lLWNcIjpcbiAgICAgICAgICBpZih0eXBlID09PSBcImJcIikgY3VzdG9tTGluZXMgPSBbMC41LDIuNSwxLDMsMS41LDMuNSwyXTtcbiAgICAgICAgICBlbHNlIG9mZnNldCA9IDI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJiYXNzXCI6XG4gICAgICAgIGNhc2UgXCJmcmVuY2hcIjpcbiAgICAgICAgICBvZmZzZXQgPSAxO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiB0aGVyZSdzIGEgc3BlY2lhbCBjYXNlLCBhc3NpZ24gdGhvc2UgbGluZXMvc3BhY2VzOlxuICAgICAgdmFyIGk7XG4gICAgICBpZiAodHlwZW9mIGN1c3RvbUxpbmVzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLmFjY0xpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICB0aGlzLmFjY0xpc3RbaV0ubGluZSA9IGN1c3RvbUxpbmVzW2ldO1xuICAgICAgICB9XG4gICAgICB9IGVsc2UgaWYgKG9mZnNldCAhPT0gMCkge1xuICAgICAgICBmb3IgKGkgPSAwOyBpIDwgdGhpcy5hY2NMaXN0Lmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdGhpcy5hY2NMaXN0W2ldLmxpbmUgKz0gb2Zmc2V0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gS2V5U2lnbmF0dXJlO1xufSgpKTtcbi8vIFZleCBGbG93IE5vdGF0aW9uXG4vLyBJbXBsZW1lbnRzIHRpbWUgc2lnbmF0dXJlcyBnbHlwaHMgZm9yIHN0YWZmc1xuLy8gU2VlIHRhYmxlcy5qcyBmb3IgdGhlIGludGVybmFsIHRpbWUgc2lnbmF0dXJlc1xuLy8gcmVwcmVzZW50YXRpb25cbi8vXG5cbi8qKlxuICogQHBhcmFtIHtzdHJpbmd9IHRpbWVTcGVjIHRpbWUgc2lnbmF0dXJlLCBpLmUuIFwiNC80XCJcbiAqIEBwYXJhbSB7bnVtYmVyfSBbY3VzdG9tUGFkZGluZ10gY3VzdG9tIHBhZGRpbmcgd2hlbiB1c2luZyBtdWx0aS1zdGF2ZS9tdWx0aS1pbnN0cnVtZW50IHNldHRpbmdcbiAqIHRvIGFsaWduIGtleS90aW1lIHNpZ25hdHVyZSAoaW4gcGl4ZWxzKSwgb3B0aW9uYWxcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5WZXguRmxvdy5UaW1lU2lnbmF0dXJlID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUaW1lU2lnbmF0dXJlKHRpbWVTcGVjLCBjdXN0b21QYWRkaW5nKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGltZVNwZWMsIGN1c3RvbVBhZGRpbmcpO1xuICB9XG5cbiAgVGltZVNpZ25hdHVyZS5nbHlwaHMgPSB7XG4gICAgXCJDXCI6IHtcbiAgICAgIGNvZGU6IFwidjQxXCIsXG4gICAgICBwb2ludDogNDAsXG4gICAgICBsaW5lOiAyXG4gICAgfSxcbiAgICBcIkN8XCI6IHtcbiAgICAgIGNvZGU6IFwidmI2XCIsXG4gICAgICBwb2ludDogNDAsXG4gICAgICBsaW5lOiAyXG4gICAgfVxuICB9O1xuXG4gIFZleC5Jbmhlcml0KFRpbWVTaWduYXR1cmUsIFZleC5GbG93LlN0YXZlTW9kaWZpZXIsIHtcbiAgICBpbml0OiBmdW5jdGlvbih0aW1lU3BlYywgY3VzdG9tUGFkZGluZykge1xuICAgICAgVGltZVNpZ25hdHVyZS5zdXBlcmNsYXNzLmluaXQoKTtcbiAgICAgICB2YXIgcGFkZGluZyA9IGN1c3RvbVBhZGRpbmcgfHwgMTU7XG5cbiAgICAgIHRoaXMuc2V0UGFkZGluZyhwYWRkaW5nKTtcbiAgICAgIHRoaXMucG9pbnQgPSA0MDtcbiAgICAgIHRoaXMudG9wTGluZSA9IDI7XG4gICAgICB0aGlzLmJvdHRvbUxpbmUgPSA0O1xuICAgICAgdGhpcy50aW1lU2lnID0gdGhpcy5wYXJzZVRpbWVTcGVjKHRpbWVTcGVjKTtcbiAgICB9LFxuXG4gICAgcGFyc2VUaW1lU3BlYzogZnVuY3Rpb24odGltZVNwZWMpIHtcbiAgICAgIGlmICh0aW1lU3BlYyA9PSBcIkNcIiB8fCB0aW1lU3BlYyA9PSBcIkN8XCIpIHtcbiAgICAgICAgdmFyIGdseXBoSW5mbyA9IFRpbWVTaWduYXR1cmUuZ2x5cGhzW3RpbWVTcGVjXTtcbiAgICAgICAgcmV0dXJuIHtudW06IGZhbHNlLCBsaW5lOiBnbHlwaEluZm8ubGluZSxcbiAgICAgICAgICBnbHlwaDogbmV3IFZleC5GbG93LkdseXBoKGdseXBoSW5mby5jb2RlLCBnbHlwaEluZm8ucG9pbnQpfTtcbiAgICAgIH1cblxuICAgICAgdmFyIHRvcE51bXMgPSBbXTtcbiAgICAgIHZhciBpLCBjO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHRpbWVTcGVjLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGMgPSB0aW1lU3BlYy5jaGFyQXQoaSk7XG4gICAgICAgIGlmIChjID09IFwiL1wiKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoL1swLTldLy50ZXN0KGMpKSB7XG4gICAgICAgICAgdG9wTnVtcy5wdXNoKGMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZFRpbWVTaWduYXR1cmVcIixcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIHRpbWUgc3BlYzogXCIgKyB0aW1lU3BlYyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGkgPT09IDApIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkVGltZVNpZ25hdHVyZVwiLFxuICAgICAgICAgICAgICBcIkludmFsaWQgdGltZSBzcGVjOiBcIiArIHRpbWVTcGVjKTtcbiAgICAgIH1cblxuICAgICAgLy8gc2tpcCB0aGUgXCIvXCJcbiAgICAgICsraTtcblxuICAgICAgaWYgKGkgPT0gdGltZVNwZWMubGVuZ3RoKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZFRpbWVTaWduYXR1cmVcIixcbiAgICAgICAgICAgICAgXCJJbnZhbGlkIHRpbWUgc3BlYzogXCIgKyB0aW1lU3BlYyk7XG4gICAgICB9XG5cblxuICAgICAgdmFyIGJvdE51bXMgPSBbXTtcbiAgICAgIGZvciAoOyBpIDwgdGltZVNwZWMubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgYyA9IHRpbWVTcGVjLmNoYXJBdChpKTtcbiAgICAgICAgaWYgKC9bMC05XS8udGVzdChjKSkge1xuICAgICAgICAgIGJvdE51bXMucHVzaChjKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRUaW1lU2lnbmF0dXJlXCIsXG4gICAgICAgICAgICAgIFwiSW52YWxpZCB0aW1lIHNwZWM6IFwiICsgdGltZVNwZWMpO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgcmV0dXJuIHtudW06IHRydWUsIGdseXBoOiB0aGlzLm1ha2VUaW1lU2lnbmF0dXJlR2x5cGgodG9wTnVtcywgYm90TnVtcyl9O1xuICAgIH0sXG5cbiAgICBtYWtlVGltZVNpZ25hdHVyZUdseXBoOiBmdW5jdGlvbih0b3BOdW1zLCBib3ROdW1zKSB7XG4gICAgICB2YXIgZ2x5cGggPSBuZXcgVmV4LkZsb3cuR2x5cGgoXCJ2MFwiLCB0aGlzLnBvaW50KTtcbiAgICAgIGdseXBoW1widG9wR2x5cGhzXCJdID0gW107XG4gICAgICBnbHlwaFtcImJvdEdseXBoc1wiXSA9IFtdO1xuXG4gICAgICB2YXIgdG9wV2lkdGggPSAwO1xuICAgICAgdmFyIGksIG51bTtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCB0b3BOdW1zLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIG51bSA9IHRvcE51bXNbaV07XG4gICAgICAgIHZhciB0b3BHbHlwaCA9IG5ldyBWZXguRmxvdy5HbHlwaChcInZcIiArIG51bSwgdGhpcy5wb2ludCk7XG5cbiAgICAgICAgZ2x5cGgudG9wR2x5cGhzLnB1c2godG9wR2x5cGgpO1xuICAgICAgICB0b3BXaWR0aCArPSB0b3BHbHlwaC5nZXRNZXRyaWNzKCkud2lkdGg7XG4gICAgICB9XG5cbiAgICAgIHZhciBib3RXaWR0aCA9IDA7XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgYm90TnVtcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBudW0gPSBib3ROdW1zW2ldO1xuICAgICAgICB2YXIgYm90R2x5cGggPSBuZXcgVmV4LkZsb3cuR2x5cGgoXCJ2XCIgKyBudW0sIHRoaXMucG9pbnQpO1xuXG4gICAgICAgIGdseXBoLmJvdEdseXBocy5wdXNoKGJvdEdseXBoKTtcbiAgICAgICAgYm90V2lkdGggKz0gYm90R2x5cGguZ2V0TWV0cmljcygpLndpZHRoO1xuICAgICAgfVxuXG4gICAgICB2YXIgd2lkdGggPSAodG9wV2lkdGggPiBib3RXaWR0aCA/IHRvcFdpZHRoIDogYm90V2lkdGgpO1xuICAgICAgdmFyIHhNaW4gPSBnbHlwaC5nZXRNZXRyaWNzKCkueF9taW47XG5cbiAgICAgIGdseXBoLmdldE1ldHJpY3MgPSBmdW5jdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB4X21pbjogeE1pbixcbiAgICAgICAgICB4X21heDogeE1pbiArIHdpZHRoLFxuICAgICAgICAgIHdpZHRoOiB3aWR0aFxuICAgICAgICB9O1xuICAgICAgfTtcblxuICAgICAgdmFyIHRvcFN0YXJ0WCA9ICh3aWR0aCAtIHRvcFdpZHRoKSAvIDIuMDtcbiAgICAgIHZhciBib3RTdGFydFggPSAod2lkdGggLSBib3RXaWR0aCkgLyAyLjA7XG5cbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIGdseXBoLnJlbmRlclRvU3RhdmUgPSBmdW5jdGlvbih4KSB7XG4gICAgICAgIHZhciBzdGFydF94ID0geCArIHRvcFN0YXJ0WDtcbiAgICAgICAgdmFyIGksIGc7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCB0aGlzLnRvcEdseXBocy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIGcgPSB0aGlzLnRvcEdseXBoc1tpXTtcbiAgICAgICAgICBWZXguRmxvdy5HbHlwaC5yZW5kZXJPdXRsaW5lKHRoaXMuY29udGV4dCwgZy5tZXRyaWNzLm91dGxpbmUsXG4gICAgICAgICAgICAgIGcuc2NhbGUsIHN0YXJ0X3ggKyBnLnhfc2hpZnQsIHRoaXMuc3RhdmUuZ2V0WUZvckxpbmUodGhhdC50b3BMaW5lKSArIDEpO1xuICAgICAgICAgIHN0YXJ0X3ggKz0gZy5nZXRNZXRyaWNzKCkud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICBzdGFydF94ID0geCArIGJvdFN0YXJ0WDtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHRoaXMuYm90R2x5cGhzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgZyA9IHRoaXMuYm90R2x5cGhzW2ldO1xuICAgICAgICAgIHRoYXQucGxhY2VHbHlwaE9uTGluZShnLCB0aGlzLnN0YXZlLCBnLmxpbmUpO1xuICAgICAgICAgIFZleC5GbG93LkdseXBoLnJlbmRlck91dGxpbmUodGhpcy5jb250ZXh0LCBnLm1ldHJpY3Mub3V0bGluZSxcbiAgICAgICAgICAgICAgZy5zY2FsZSwgc3RhcnRfeCArIGcueF9zaGlmdCwgdGhpcy5zdGF2ZS5nZXRZRm9yTGluZSh0aGF0LmJvdHRvbUxpbmUpICsgMSk7XG4gICAgICAgICAgc3RhcnRfeCArPSBnLmdldE1ldHJpY3MoKS53aWR0aDtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgcmV0dXJuIGdseXBoO1xuICAgIH0sXG5cbiAgICBnZXRUaW1lU2lnOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnRpbWVTaWc7XG4gICAgfSxcblxuICAgIGFkZE1vZGlmaWVyOiBmdW5jdGlvbihzdGF2ZSkge1xuICAgICAgaWYgKCF0aGlzLnRpbWVTaWcubnVtKSB7XG4gICAgICAgIHRoaXMucGxhY2VHbHlwaE9uTGluZSh0aGlzLnRpbWVTaWcuZ2x5cGgsIHN0YXZlLCB0aGlzLnRpbWVTaWcubGluZSk7XG4gICAgICB9XG4gICAgICBzdGF2ZS5hZGRHbHlwaCh0aGlzLnRpbWVTaWcuZ2x5cGgpO1xuICAgIH0sXG5cbiAgICBhZGRFbmRNb2RpZmllcjogZnVuY3Rpb24oc3RhdmUpIHtcbiAgICAgIGlmICghdGhpcy50aW1lU2lnLm51bSkge1xuICAgICAgICB0aGlzLnBsYWNlR2x5cGhPbkxpbmUodGhpcy50aW1lU2lnLmdseXBoLCBzdGF2ZSwgdGhpcy50aW1lU2lnLmxpbmUpO1xuICAgICAgfVxuICAgICAgc3RhdmUuYWRkRW5kR2x5cGgodGhpcy50aW1lU2lnLmdseXBoKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBUaW1lU2lnbmF0dXJlO1xufSgpKTtcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIENoZXBwdWRpcmEgMjAxMy5cbi8vIENvLWF1dGhvcjogQmVuamFtaW4gVy4gQm9obFxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgdmFyaW91cyB0eXBlcyBvZiBjbGVmcyB0aGF0IGNhbiBiZSByZW5kZXJlZCBvbiBhIHN0YXZlLlxuLy9cbi8vIFNlZSBgdGVzdHMvY2xlZl90ZXN0cy5qc2AgZm9yIHVzYWdlIGV4YW1wbGVzLlxuXG5WZXguRmxvdy5DbGVmID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBDbGVmKGNsZWYsIHNpemUsIGFubm90YXRpb24pIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChjbGVmLCBzaXplLCBhbm5vdGF0aW9uKTtcbiAgfVxuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLCBzZXQgYFZleC5GbG93LkNsZWYuREVCVUdgIHRvIGB0cnVlYC5cbiAgZnVuY3Rpb24gTCgpIHsgaWYgKFZleC5GbG93LkNsZWYuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuQ2xlZlwiLCBhcmd1bWVudHMpOyB9XG5cbiAgLy8gRXZlcnkgY2xlZiBuYW1lIGlzIGFzc29jaWF0ZWQgd2l0aCBhIGdseXBoIGNvZGUgZnJvbSB0aGUgZm9udCBmaWxlXG4gIC8vIGFuZCBhIGRlZmF1bHQgc3RhdmUgbGluZSBudW1iZXIuXG4gIENsZWYudHlwZXMgPSB7XG4gICAgXCJ0cmVibGVcIjoge1xuICAgICAgY29kZTogXCJ2ODNcIixcbiAgICAgIGxpbmU6IDNcbiAgICB9LFxuICAgIFwiYmFzc1wiOiB7XG4gICAgICBjb2RlOiBcInY3OVwiLFxuICAgICAgbGluZTogMVxuICAgIH0sXG4gICAgXCJhbHRvXCI6IHtcbiAgICAgIGNvZGU6IFwidmFkXCIsXG4gICAgICBsaW5lOiAyXG4gICAgfSxcbiAgICBcInRlbm9yXCI6IHtcbiAgICAgIGNvZGU6IFwidmFkXCIsXG4gICAgICBsaW5lOiAxXG4gICAgfSxcbiAgICBcInBlcmN1c3Npb25cIjoge1xuICAgICAgY29kZTogXCJ2NTlcIixcbiAgICAgIGxpbmU6IDJcbiAgICB9LFxuICAgIFwic29wcmFub1wiOiB7XG4gICAgICBjb2RlOiBcInZhZFwiLFxuICAgICAgbGluZTogNFxuICAgIH0sXG4gICAgXCJtZXp6by1zb3ByYW5vXCI6IHtcbiAgICAgIGNvZGU6IFwidmFkXCIsXG4gICAgICBsaW5lOiAzXG4gICAgfSxcbiAgICBcImJhcml0b25lLWNcIjoge1xuICAgICAgY29kZTogXCJ2YWRcIixcbiAgICAgIGxpbmU6IDBcbiAgICB9LFxuICAgIFwiYmFyaXRvbmUtZlwiOiB7XG4gICAgICBjb2RlOiBcInY3OVwiLFxuICAgICAgbGluZTogMlxuICAgIH0sXG4gICAgXCJzdWJiYXNzXCI6IHtcbiAgICAgIGNvZGU6IFwidjc5XCIsXG4gICAgICBsaW5lOiAwXG4gICAgfSxcbiAgICBcImZyZW5jaFwiOiB7XG4gICAgICBjb2RlOiBcInY4M1wiLFxuICAgICAgbGluZTogNFxuICAgIH0sXG4gIH07XG4gIC8vIFNpemVzIGFmZmVjdCB0aGUgcG9pbnQtc2l6ZSBvZiB0aGUgY2xlZi5cbiAgQ2xlZi5zaXplcyA9IHtcbiAgICBcImRlZmF1bHRcIjogNDAsXG4gICAgXCJzbWFsbFwiOiAzMlxuICB9O1xuXG4gIC8vIEFubm90YXRpb25zIGF0dGFjaCB0byBjbGVmcyAtLSBzdWNoIGFzIFwiOFwiIGZvciBvY3RhdmUgdXAgb3IgZG93bi5cbiAgQ2xlZi5hbm5vdGF0aW9ucyA9IHtcbiAgICBcIjh2YVwiOiB7XG4gICAgICBjb2RlOiBcInY4XCIsXG4gICAgICBzaXplczoge1xuICAgICAgICBcImRlZmF1bHRcIjoge1xuICAgICAgICAgIHBvaW50OiAyMCxcbiAgICAgICAgICBhdHRhY2htZW50czoge1xuICAgICAgICAgICAgXCJ0cmVibGVcIjoge1xuICAgICAgICAgICAgICBsaW5lOiAtMS4yLFxuICAgICAgICAgICAgICB4X3NoaWZ0OiAxMVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgXCJzbWFsbFwiOiB7XG4gICAgICAgICAgcG9pbnQ6IDE4LFxuICAgICAgICAgIGF0dGFjaG1lbnRzOiB7XG4gICAgICAgICAgICBcInRyZWJsZVwiOiB7XG4gICAgICAgICAgICAgIGxpbmU6IC0wLjQsXG4gICAgICAgICAgICAgIHhfc2hpZnQ6IDhcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIFwiOHZiXCI6IHtcbiAgICAgIGNvZGU6IFwidjhcIixcbiAgICAgIHNpemVzOiB7XG4gICAgICAgIFwiZGVmYXVsdFwiOiB7XG4gICAgICAgICAgcG9pbnQ6IDIwLFxuICAgICAgICAgIGF0dGFjaG1lbnRzOiB7XG4gICAgICAgICAgICBcInRyZWJsZVwiOiB7XG4gICAgICAgICAgICAgIGxpbmU6IDYuMyxcbiAgICAgICAgICAgICAgeF9zaGlmdDogMTBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImJhc3NcIjoge1xuICAgICAgICAgICAgICBsaW5lOiA0LFxuICAgICAgICAgICAgICB4X3NoaWZ0OiAxXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBcInNtYWxsXCI6IHtcbiAgICAgICAgICBwb2ludDogMTgsXG4gICAgICAgICAgYXR0YWNobWVudHM6IHtcbiAgICAgICAgICAgIFwidHJlYmxlXCI6IHtcbiAgICAgICAgICAgICAgbGluZTogNS44LFxuICAgICAgICAgICAgICB4X3NoaWZ0OiA2XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJiYXNzXCI6IHtcbiAgICAgICAgICAgICAgbGluZTogMy41LFxuICAgICAgICAgICAgICB4X3NoaWZ0OiAwLjVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICB9O1xuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICBWZXguSW5oZXJpdChDbGVmLCBWZXguRmxvdy5TdGF2ZU1vZGlmaWVyLCB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IGNsZWYuIFRoZSBwYXJhbWV0ZXIgYGNsZWZgIG11c3QgYmUgYSBrZXkgZnJvbVxuICAgIC8vIGBDbGVmLnR5cGVzYC5cbiAgICBpbml0OiBmdW5jdGlvbihjbGVmLCBzaXplLCBhbm5vdGF0aW9uKSB7XG4gICAgICB2YXIgc3VwZXJjbGFzcyA9IFZleC5GbG93LkNsZWYuc3VwZXJjbGFzcztcbiAgICAgIHN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLmNsZWYgPSBWZXguRmxvdy5DbGVmLnR5cGVzW2NsZWZdO1xuICAgICAgaWYgKHNpemUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICB0aGlzLnNpemUgPSBcImRlZmF1bHRcIjtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2l6ZSA9IHNpemU7XG4gICAgICB9XG4gICAgICB0aGlzLmNsZWYucG9pbnQgPSBWZXguRmxvdy5DbGVmLnNpemVzW3RoaXMuc2l6ZV07XG5cbiAgICAgIC8vIElmIGFuIGFubm90YXRpb24sIHN1Y2ggYXMgOHZhLCBpcyBzcGVjaWZpZWQsIGFkZCBpdCB0byB0aGUgQ2xlZiBvYmplY3QuXG4gICAgICBpZiAoYW5ub3RhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBhbm5vX2RpY3QgPSBWZXguRmxvdy5DbGVmLmFubm90YXRpb25zW2Fubm90YXRpb25dO1xuICAgICAgICB0aGlzLmFubm90YXRpb24gPSB7XG4gICAgICAgICAgY29kZTogYW5ub19kaWN0LmNvZGUsXG4gICAgICAgICAgcG9pbnQ6IGFubm9fZGljdC5zaXplc1t0aGlzLnNpemVdLnBvaW50LFxuICAgICAgICAgIGxpbmU6IGFubm9fZGljdC5zaXplc1t0aGlzLnNpemVdLmF0dGFjaG1lbnRzW2NsZWZdLmxpbmUsXG4gICAgICAgICAgeF9zaGlmdDogYW5ub19kaWN0LnNpemVzW3RoaXMuc2l6ZV0uYXR0YWNobWVudHNbY2xlZl0ueF9zaGlmdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgTChcIkNyZWF0aW5nIGNsZWY6XCIsIGNsZWYpO1xuICAgIH0sXG5cbiAgICAvLyBBZGQgdGhpcyBjbGVmIHRvIHRoZSBzdGFydCBvZiB0aGUgZ2l2ZW4gYHN0YXZlYC5cbiAgICBhZGRNb2RpZmllcjogZnVuY3Rpb24oc3RhdmUpIHtcbiAgICAgIHZhciBnbHlwaCA9IG5ldyBWZXguRmxvdy5HbHlwaCh0aGlzLmNsZWYuY29kZSwgdGhpcy5jbGVmLnBvaW50KTtcbiAgICAgIHRoaXMucGxhY2VHbHlwaE9uTGluZShnbHlwaCwgc3RhdmUsIHRoaXMuY2xlZi5saW5lKTtcbiAgICAgIGlmICh0aGlzLmFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgYXR0YWNobWVudCA9IG5ldyBWZXguRmxvdy5HbHlwaCh0aGlzLmFubm90YXRpb24uY29kZSwgdGhpcy5hbm5vdGF0aW9uLnBvaW50KTtcbiAgICAgICAgYXR0YWNobWVudC5tZXRyaWNzLnhfbWF4ID0gMDtcbiAgICAgICAgYXR0YWNobWVudC5zZXRYU2hpZnQodGhpcy5hbm5vdGF0aW9uLnhfc2hpZnQpO1xuICAgICAgICB0aGlzLnBsYWNlR2x5cGhPbkxpbmUoYXR0YWNobWVudCwgc3RhdmUsIHRoaXMuYW5ub3RhdGlvbi5saW5lKTtcbiAgICAgICAgc3RhdmUuYWRkR2x5cGgoYXR0YWNobWVudCk7XG4gICAgICB9XG4gICAgICBzdGF2ZS5hZGRHbHlwaChnbHlwaCk7XG4gICAgfSxcblxuICAgIC8vIEFkZCB0aGlzIGNsZWYgdG8gdGhlIGVuZCBvZiB0aGUgZ2l2ZW4gYHN0YXZlYC5cbiAgICBhZGRFbmRNb2RpZmllcjogZnVuY3Rpb24oc3RhdmUpIHtcbiAgICAgIHZhciBnbHlwaCA9IG5ldyBWZXguRmxvdy5HbHlwaCh0aGlzLmNsZWYuY29kZSwgdGhpcy5jbGVmLnBvaW50KTtcbiAgICAgIHRoaXMucGxhY2VHbHlwaE9uTGluZShnbHlwaCwgc3RhdmUsIHRoaXMuY2xlZi5saW5lKTtcbiAgICAgIHN0YXZlLmFkZEVuZEdseXBoKGdseXBoKTtcbiAgICAgIGlmICh0aGlzLmFubm90YXRpb24gIT09IHVuZGVmaW5lZCkge1xuICAgICAgICB2YXIgYXR0YWNobWVudCA9IG5ldyBWZXguRmxvdy5HbHlwaCh0aGlzLmFubm90YXRpb24uY29kZSwgdGhpcy5hbm5vdGF0aW9uLnBvaW50KTtcbiAgICAgICAgYXR0YWNobWVudC5tZXRyaWNzLnhfbWF4ID0gMDtcbiAgICAgICAgYXR0YWNobWVudC5zZXRYU2hpZnQodGhpcy5hbm5vdGF0aW9uLnhfc2hpZnQpO1xuICAgICAgICB0aGlzLnBsYWNlR2x5cGhPbkxpbmUoYXR0YWNobWVudCwgc3RhdmUsIHRoaXMuYW5ub3RhdGlvbi5saW5lKTtcbiAgICAgICAgc3RhdmUuYWRkRW5kR2x5cGgoYXR0YWNobWVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQ2xlZjtcbn0oKSk7XG5cbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBzb21lIHN0YW5kYXJkIG11c2ljIHRoZW9yeSByb3V0aW5lcy5cbi8vXG4vLyByZXF1aXJlczogdmV4LmpzICAgKFZleClcbi8vIHJlcXVpcmVzOiBmbG93LmpzICAoVmV4LkZsb3cpXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblZleC5GbG93Lk11c2ljID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBNdXNpYygpIHtcbiAgICB0aGlzLmluaXQoKTtcbiAgfVxuXG4gIE11c2ljLk5VTV9UT05FUyA9IDEyO1xuICBNdXNpYy5yb290cyA9IFsgXCJjXCIsIFwiZFwiLCBcImVcIiwgXCJmXCIsIFwiZ1wiLCBcImFcIiwgXCJiXCIgXTtcbiAgTXVzaWMucm9vdF92YWx1ZXMgPSBbIDAsIDIsIDQsIDUsIDcsIDksIDExIF07XG4gIE11c2ljLnJvb3RfaW5kaWNlcyA9IHtcbiAgICBcImNcIjogMCxcbiAgICBcImRcIjogMSxcbiAgICBcImVcIjogMixcbiAgICBcImZcIjogMyxcbiAgICBcImdcIjogNCxcbiAgICBcImFcIjogNSxcbiAgICBcImJcIjogNlxuICB9O1xuXG4gIE11c2ljLmNhbm9uaWNhbF9ub3RlcyA9IFtcbiAgICBcImNcIiwgXCJjI1wiLCBcImRcIiwgXCJkI1wiLFxuICAgIFwiZVwiLCBcImZcIiwgXCJmI1wiLCBcImdcIixcbiAgICBcImcjXCIsIFwiYVwiLCBcImEjXCIsIFwiYlwiXG4gIF07XG5cbiAgTXVzaWMuZGlhdG9uaWNfaW50ZXJ2YWxzID0gW1xuICAgIFwidW5pc29uXCIsIFwibTJcIiwgXCJNMlwiLCBcIm0zXCIsIFwiTTNcIixcbiAgICBcInA0XCIsIFwiZGltNVwiLCBcInA1XCIsIFwibTZcIiwgXCJNNlwiLFxuICAgIFwiYjdcIiwgXCJNN1wiLCBcIm9jdGF2ZVwiXG4gIF07XG5cbiAgTXVzaWMuZGlhdG9uaWNfYWNjaWRlbnRhbHMgPSB7XG4gICAgXCJ1bmlzb25cIjoge25vdGU6IDAsIGFjY2lkZW50YWw6IDB9LFxuICAgIFwibTJcIjogICAgIHtub3RlOiAxLCBhY2NpZGVudGFsOiAtMX0sXG4gICAgXCJNMlwiOiAgICAge25vdGU6IDEsIGFjY2lkZW50YWw6IDB9LFxuICAgIFwibTNcIjogICAgIHtub3RlOiAyLCBhY2NpZGVudGFsOiAtMX0sXG4gICAgXCJNM1wiOiAgICAge25vdGU6IDIsIGFjY2lkZW50YWw6IDB9LFxuICAgIFwicDRcIjogICAgIHtub3RlOiAzLCBhY2NpZGVudGFsOiAwfSxcbiAgICBcImRpbTVcIjogICB7bm90ZTogNCwgYWNjaWRlbnRhbDogLTF9LFxuICAgIFwicDVcIjogICAgIHtub3RlOiA0LCBhY2NpZGVudGFsOiAwfSxcbiAgICBcIm02XCI6ICAgICB7bm90ZTogNSwgYWNjaWRlbnRhbDogLTF9LFxuICAgIFwiTTZcIjogICAgIHtub3RlOiA1LCBhY2NpZGVudGFsOiAwfSxcbiAgICBcImI3XCI6ICAgICB7bm90ZTogNiwgYWNjaWRlbnRhbDogLTF9LFxuICAgIFwiTTdcIjogICAgIHtub3RlOiA2LCBhY2NpZGVudGFsOiAwfSxcbiAgICBcIm9jdGF2ZVwiOiB7bm90ZTogNywgYWNjaWRlbnRhbDogMH1cbiAgfTtcblxuICBNdXNpYy5pbnRlcnZhbHMgPSB7XG4gICAgXCJ1XCI6ICAwLCBcInVuaXNvblwiOiAwLFxuICAgIFwibTJcIjogMSwgXCJiMlwiOiAxLCBcIm1pbjJcIjogMSwgXCJTXCI6IDEsIFwiSFwiOiAxLFxuICAgIFwiMlwiOiAyLCBcIk0yXCI6IDIsIFwibWFqMlwiOiAyLCBcIlRcIjogMiwgXCJXXCI6IDIsXG4gICAgXCJtM1wiOiAzLCBcImIzXCI6IDMsIFwibWluM1wiOiAzLFxuICAgIFwiTTNcIjogNCwgXCIzXCI6IDQsIFwibWFqM1wiOiA0LFxuICAgIFwiNFwiOiAgNSwgXCJwNFwiOiAgNSxcbiAgICBcIiM0XCI6IDYsIFwiYjVcIjogNiwgXCJhdWc0XCI6IDYsIFwiZGltNVwiOiA2LFxuICAgIFwiNVwiOiAgNywgXCJwNVwiOiAgNyxcbiAgICBcIiM1XCI6IDgsIFwiYjZcIjogOCwgXCJhdWc1XCI6IDgsXG4gICAgXCI2XCI6ICA5LCBcIk02XCI6ICA5LCBcIm1hajZcIjogOSxcbiAgICBcImI3XCI6IDEwLCBcIm03XCI6IDEwLCBcIm1pbjdcIjogMTAsIFwiZG9tN1wiOiAxMCxcbiAgICBcIk03XCI6IDExLCBcIm1hajdcIjogMTEsXG4gICAgXCI4XCI6IDEyLCBcIm9jdGF2ZVwiOiAxMlxuICB9O1xuXG4gIE11c2ljLnNjYWxlcyA9IHtcbiAgICBtYWpvcjogWzIsIDIsIDEsIDIsIDIsIDIsIDFdLFxuICAgIGRvcmlhbjogWzIsIDEsIDIsIDIsIDIsIDEsIDJdLFxuICAgIG1peG9seWRpYW46IFsyLCAyLCAxLCAyLCAyLCAxLCAyXSxcbiAgICBtaW5vcjogWzIsIDEsIDIsIDIsIDEsIDIsIDJdXG4gIH07XG5cbiAgTXVzaWMuYWNjaWRlbnRhbHMgPSBbIFwiYmJcIiwgXCJiXCIsIFwiblwiLCBcIiNcIiwgXCIjI1wiIF07XG5cbiAgTXVzaWMubm90ZVZhbHVlcyA9IHtcbiAgICAnYyc6ICAgeyByb290X2luZGV4OiAwLCBpbnRfdmFsOiAwIH0sXG4gICAgJ2NuJzogIHsgcm9vdF9pbmRleDogMCwgaW50X3ZhbDogMCB9LFxuICAgICdjIyc6ICB7IHJvb3RfaW5kZXg6IDAsIGludF92YWw6IDEgfSxcbiAgICAnYyMjJzogeyByb290X2luZGV4OiAwLCBpbnRfdmFsOiAyIH0sXG4gICAgJ2NiJzogIHsgcm9vdF9pbmRleDogMCwgaW50X3ZhbDogMTEgfSxcbiAgICAnY2JiJzogeyByb290X2luZGV4OiAwLCBpbnRfdmFsOiAxMCB9LFxuICAgICdkJzogICB7IHJvb3RfaW5kZXg6IDEsIGludF92YWw6IDIgfSxcbiAgICAnZG4nOiAgeyByb290X2luZGV4OiAxLCBpbnRfdmFsOiAyIH0sXG4gICAgJ2QjJzogIHsgcm9vdF9pbmRleDogMSwgaW50X3ZhbDogMyB9LFxuICAgICdkIyMnOiB7IHJvb3RfaW5kZXg6IDEsIGludF92YWw6IDQgfSxcbiAgICAnZGInOiAgeyByb290X2luZGV4OiAxLCBpbnRfdmFsOiAxIH0sXG4gICAgJ2RiYic6IHsgcm9vdF9pbmRleDogMSwgaW50X3ZhbDogMCB9LFxuICAgICdlJzogICB7IHJvb3RfaW5kZXg6IDIsIGludF92YWw6IDQgfSxcbiAgICAnZW4nOiAgeyByb290X2luZGV4OiAyLCBpbnRfdmFsOiA0IH0sXG4gICAgJ2UjJzogIHsgcm9vdF9pbmRleDogMiwgaW50X3ZhbDogNSB9LFxuICAgICdlIyMnOiB7IHJvb3RfaW5kZXg6IDIsIGludF92YWw6IDYgfSxcbiAgICAnZWInOiAgeyByb290X2luZGV4OiAyLCBpbnRfdmFsOiAzIH0sXG4gICAgJ2ViYic6IHsgcm9vdF9pbmRleDogMiwgaW50X3ZhbDogMiB9LFxuICAgICdmJzogICB7IHJvb3RfaW5kZXg6IDMsIGludF92YWw6IDUgfSxcbiAgICAnZm4nOiAgeyByb290X2luZGV4OiAzLCBpbnRfdmFsOiA1IH0sXG4gICAgJ2YjJzogIHsgcm9vdF9pbmRleDogMywgaW50X3ZhbDogNiB9LFxuICAgICdmIyMnOiB7IHJvb3RfaW5kZXg6IDMsIGludF92YWw6IDcgfSxcbiAgICAnZmInOiAgeyByb290X2luZGV4OiAzLCBpbnRfdmFsOiA0IH0sXG4gICAgJ2ZiYic6IHsgcm9vdF9pbmRleDogMywgaW50X3ZhbDogMyB9LFxuICAgICdnJzogICB7IHJvb3RfaW5kZXg6IDQsIGludF92YWw6IDcgfSxcbiAgICAnZ24nOiAgeyByb290X2luZGV4OiA0LCBpbnRfdmFsOiA3IH0sXG4gICAgJ2cjJzogIHsgcm9vdF9pbmRleDogNCwgaW50X3ZhbDogOCB9LFxuICAgICdnIyMnOiB7IHJvb3RfaW5kZXg6IDQsIGludF92YWw6IDkgfSxcbiAgICAnZ2InOiAgeyByb290X2luZGV4OiA0LCBpbnRfdmFsOiA2IH0sXG4gICAgJ2diYic6IHsgcm9vdF9pbmRleDogNCwgaW50X3ZhbDogNSB9LFxuICAgICdhJzogICB7IHJvb3RfaW5kZXg6IDUsIGludF92YWw6IDkgfSxcbiAgICAnYW4nOiAgeyByb290X2luZGV4OiA1LCBpbnRfdmFsOiA5IH0sXG4gICAgJ2EjJzogIHsgcm9vdF9pbmRleDogNSwgaW50X3ZhbDogMTAgfSxcbiAgICAnYSMjJzogeyByb290X2luZGV4OiA1LCBpbnRfdmFsOiAxMSB9LFxuICAgICdhYic6ICB7IHJvb3RfaW5kZXg6IDUsIGludF92YWw6IDggfSxcbiAgICAnYWJiJzogeyByb290X2luZGV4OiA1LCBpbnRfdmFsOiA3IH0sXG4gICAgJ2InOiAgIHsgcm9vdF9pbmRleDogNiwgaW50X3ZhbDogMTEgfSxcbiAgICAnYm4nOiAgeyByb290X2luZGV4OiA2LCBpbnRfdmFsOiAxMSB9LFxuICAgICdiIyc6ICB7IHJvb3RfaW5kZXg6IDYsIGludF92YWw6IDAgfSxcbiAgICAnYiMjJzogeyByb290X2luZGV4OiA2LCBpbnRfdmFsOiAxIH0sXG4gICAgJ2JiJzogIHsgcm9vdF9pbmRleDogNiwgaW50X3ZhbDogMTAgfSxcbiAgICAnYmJiJzogeyByb290X2luZGV4OiA2LCBpbnRfdmFsOiA5IH1cbiAgfTtcblxuICBNdXNpYy5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oKSB7fSxcblxuICAgIGlzVmFsaWROb3RlVmFsdWU6IGZ1bmN0aW9uKG5vdGUpIHtcbiAgICAgIGlmIChub3RlID09IG51bGwgfHwgbm90ZSA8IDAgfHwgbm90ZSA+PSBWZXguRmxvdy5NdXNpYy5OVU1fVE9ORVMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0sXG5cbiAgICBpc1ZhbGlkSW50ZXJ2YWxWYWx1ZTogZnVuY3Rpb24oaW50ZXJ2YWwpIHtcbiAgICAgIHJldHVybiB0aGlzLmlzVmFsaWROb3RlVmFsdWUoaW50ZXJ2YWwpO1xuICAgIH0sXG5cbiAgICBnZXROb3RlUGFydHM6IGZ1bmN0aW9uKG5vdGVTdHJpbmcpIHtcbiAgICAgIGlmICghbm90ZVN0cmluZyB8fCBub3RlU3RyaW5nLmxlbmd0aCA8IDEpXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIkludmFsaWQgbm90ZSBuYW1lOiBcIiArIG5vdGVTdHJpbmcpO1xuXG4gICAgICBpZiAobm90ZVN0cmluZy5sZW5ndGggPiAzKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJJbnZhbGlkIG5vdGUgbmFtZTogXCIgKyBub3RlU3RyaW5nKTtcblxuICAgICAgdmFyIG5vdGUgPSBub3RlU3RyaW5nLnRvTG93ZXJDYXNlKCk7XG5cbiAgICAgIHZhciByZWdleCA9IC9eKFtjZGVmZ2FiXSkoYnxiYnxufCN8IyMpPyQvO1xuICAgICAgdmFyIG1hdGNoID0gcmVnZXguZXhlYyhub3RlKTtcblxuICAgICAgaWYgKG1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBtYXRjaFsxXTtcbiAgICAgICAgdmFyIGFjY2lkZW50YWwgPSBtYXRjaFsyXTtcblxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICdyb290Jzogcm9vdCxcbiAgICAgICAgICAnYWNjaWRlbnRhbCc6IGFjY2lkZW50YWxcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIkludmFsaWQgbm90ZSBuYW1lOiBcIiArIG5vdGVTdHJpbmcpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBnZXRLZXlQYXJ0czogZnVuY3Rpb24oa2V5U3RyaW5nKSB7XG4gICAgICBpZiAoIWtleVN0cmluZyB8fCBrZXlTdHJpbmcubGVuZ3RoIDwgMSlcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsIFwiSW52YWxpZCBrZXk6IFwiICsga2V5U3RyaW5nKTtcblxuICAgICAgdmFyIGtleSA9IGtleVN0cmluZy50b0xvd2VyQ2FzZSgpO1xuXG4gICAgICAvLyBTdXBwb3J0IE1ham9yLCBNaW5vciwgTWVsb2RpYyBNaW5vciwgYW5kIEhhcm1vbmljIE1pbm9yIGtleSB0eXBlcy5cbiAgICAgIHZhciByZWdleCA9IC9eKFtjZGVmZ2FiXSkoYnwjKT8obWVsfGhhcm18bXxNKT8kLztcbiAgICAgIHZhciBtYXRjaCA9IHJlZ2V4LmV4ZWMoa2V5KTtcblxuICAgICAgaWYgKG1hdGNoICE9IG51bGwpIHtcbiAgICAgICAgdmFyIHJvb3QgPSBtYXRjaFsxXTtcbiAgICAgICAgdmFyIGFjY2lkZW50YWwgPSBtYXRjaFsyXTtcbiAgICAgICAgdmFyIHR5cGUgPSBtYXRjaFszXTtcblxuICAgICAgICAvLyBVbnNwZWNpZmllZCB0eXBlIGltcGxpZXMgbWFqb3JcbiAgICAgICAgaWYgKCF0eXBlKSB0eXBlID0gXCJNXCI7XG5cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAncm9vdCc6IHJvb3QsXG4gICAgICAgICAgJ2FjY2lkZW50YWwnOiBhY2NpZGVudGFsLFxuICAgICAgICAgICd0eXBlJzogdHlwZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsIFwiSW52YWxpZCBrZXk6IFwiICsga2V5U3RyaW5nKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZ2V0Tm90ZVZhbHVlOiBmdW5jdGlvbihub3RlU3RyaW5nKSB7XG4gICAgICB2YXIgdmFsdWUgPSBNdXNpYy5ub3RlVmFsdWVzW25vdGVTdHJpbmddO1xuICAgICAgaWYgKHZhbHVlID09IG51bGwpXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIkludmFsaWQgbm90ZSBuYW1lOiBcIiArIG5vdGVTdHJpbmcpO1xuXG4gICAgICByZXR1cm4gdmFsdWUuaW50X3ZhbDtcbiAgICB9LFxuXG4gICAgZ2V0SW50ZXJ2YWxWYWx1ZTogZnVuY3Rpb24oaW50ZXJ2YWxTdHJpbmcpIHtcbiAgICAgIHZhciB2YWx1ZSA9IE11c2ljLmludGVydmFsc1tpbnRlcnZhbFN0cmluZ107XG4gICAgICBpZiAodmFsdWUgPT0gbnVsbClcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcIkludmFsaWQgaW50ZXJ2YWwgbmFtZTogXCIgKyBpbnRlcnZhbFN0cmluZyk7XG5cbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9LFxuXG4gICAgZ2V0Q2Fub25pY2FsTm90ZU5hbWU6IGZ1bmN0aW9uKG5vdGVWYWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWROb3RlVmFsdWUobm90ZVZhbHVlKSlcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICBcIkludmFsaWQgbm90ZSB2YWx1ZTogXCIgKyBub3RlVmFsdWUpO1xuXG4gICAgICByZXR1cm4gTXVzaWMuY2Fub25pY2FsX25vdGVzW25vdGVWYWx1ZV07XG4gICAgfSxcblxuICAgIGdldENhbm9uaWNhbEludGVydmFsTmFtZTogZnVuY3Rpb24oaW50ZXJ2YWxWYWx1ZSkge1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWRJbnRlcnZhbFZhbHVlKGludGVydmFsVmFsdWUpKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSW52YWxpZCBpbnRlcnZhbCB2YWx1ZTogXCIgKyBpbnRlcnZhbFZhbHVlKTtcblxuICAgICAgcmV0dXJuIE11c2ljLmRpYXRvbmljX2ludGVydmFsc1tpbnRlcnZhbFZhbHVlXTtcbiAgICB9LFxuXG4gICAgLyogR2l2ZW4gYSBub3RlLCBpbnRlcnZhbCwgYW5kIGludGVydmFsIGRpcmVjdGlvbiwgcHJvZHVjdCB0aGVcbiAgICAgKiByZWxhdGl2ZSBub3RlLlxuICAgICAqL1xuICAgIGdldFJlbGF0aXZlTm90ZVZhbHVlOiBmdW5jdGlvbihub3RlVmFsdWUsIGludGVydmFsVmFsdWUsIGRpcmVjdGlvbikge1xuICAgICAgaWYgKGRpcmVjdGlvbiA9PSBudWxsKSBkaXJlY3Rpb24gPSAxO1xuICAgICAgaWYgKGRpcmVjdGlvbiAhPSAxICYmIGRpcmVjdGlvbiAhPSAtMSlcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQmFkQXJndW1lbnRzXCIsIFwiSW52YWxpZCBkaXJlY3Rpb246IFwiICsgZGlyZWN0aW9uKTtcblxuICAgICAgdmFyIHN1bSA9IChub3RlVmFsdWUgKyAoZGlyZWN0aW9uICogaW50ZXJ2YWxWYWx1ZSkpICUgTXVzaWMuTlVNX1RPTkVTO1xuICAgICAgaWYgKHN1bSA8IDApIHN1bSArPSBNdXNpYy5OVU1fVE9ORVM7XG5cbiAgICAgIHJldHVybiBzdW07XG4gICAgfSxcblxuICAgIGdldFJlbGF0aXZlTm90ZU5hbWU6IGZ1bmN0aW9uKHJvb3QsIG5vdGVWYWx1ZSkge1xuICAgICAgdmFyIHBhcnRzID0gdGhpcy5nZXROb3RlUGFydHMocm9vdCk7XG4gICAgICB2YXIgcm9vdFZhbHVlID0gdGhpcy5nZXROb3RlVmFsdWUocGFydHMucm9vdCk7XG4gICAgICB2YXIgaW50ZXJ2YWwgPSBub3RlVmFsdWUgLSByb290VmFsdWU7XG5cbiAgICAgIGlmIChNYXRoLmFicyhpbnRlcnZhbCkgPiBNdXNpYy5OVU1fVE9ORVMgLSAzKSB7XG4gICAgICAgIHZhciBtdWx0aXBsaWVyID0gMTtcbiAgICAgICAgaWYgKGludGVydmFsID4gMCApIG11bHRpcGxpZXIgPSAtMTtcblxuICAgICAgICAvLyBQb3NzaWJseSB3cmFwIGFyb3VuZC4gKEFkZCArMSBmb3IgbW9kdWxvIG9wZXJhdG9yKVxuICAgICAgICB2YXIgcmV2ZXJzZV9pbnRlcnZhbCA9ICgoKG5vdGVWYWx1ZSArIDEpICsgKHJvb3RWYWx1ZSArIDEpKSAlXG4gICAgICAgICAgTXVzaWMuTlVNX1RPTkVTKSAqIG11bHRpcGxpZXI7XG5cbiAgICAgICAgaWYgKE1hdGguYWJzKHJldmVyc2VfaW50ZXJ2YWwpID4gMikge1xuICAgICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIk5vdGVzIG5vdCByZWxhdGVkOiBcIiArIHJvb3QgKyBcIiwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVWYWx1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaW50ZXJ2YWwgPSByZXZlcnNlX2ludGVydmFsO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmIChNYXRoLmFicyhpbnRlcnZhbCkgPiAyKVxuICAgICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIk5vdGVzIG5vdCByZWxhdGVkOiBcIiArIHJvb3QgKyBcIiwgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vdGVWYWx1ZSk7XG5cbiAgICAgIHZhciByZWxhdGl2ZU5vdGVOYW1lID0gcGFydHMucm9vdDtcbiAgICAgIHZhciBpO1xuICAgICAgaWYgKGludGVydmFsID4gMCkge1xuICAgICAgICBmb3IgKGkgPSAxOyBpIDw9IGludGVydmFsOyArK2kpXG4gICAgICAgICAgcmVsYXRpdmVOb3RlTmFtZSArPSBcIiNcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJ2YWwgPCAwKSB7XG4gICAgICAgIGZvciAoaSA9IC0xOyBpID49IGludGVydmFsOyAtLWkpXG4gICAgICAgICAgcmVsYXRpdmVOb3RlTmFtZSArPSBcImJcIjtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHJlbGF0aXZlTm90ZU5hbWU7XG4gICAgfSxcblxuICAgIC8qIFJldHVybiBzY2FsZSB0b25lcywgZ2l2ZW4gaW50ZXJ2YWxzLiBFYWNoIHN1Y2Nlc3NpdmUgaW50ZXJ2YWwgaXNcbiAgICAgKiByZWxhdGl2ZSB0byB0aGUgcHJldmlvdXMgb25lLCBlLmcuLCBNYWpvciBTY2FsZTpcbiAgICAgKlxuICAgICAqICAgVFRTVFRUUyA9IFsyLDIsMSwyLDIsMiwxXVxuICAgICAqXG4gICAgICogV2hlbiB1c2VkIHdpdGgga2V5ID0gMCwgcmV0dXJucyBDIHNjYWxlICh3aGljaCBpcyBpc29tb3JwaGljIHRvXG4gICAgICogaW50ZXJ2YWwgbGlzdCkuXG4gICAgICovXG4gICAgZ2V0U2NhbGVUb25lczogZnVuY3Rpb24oa2V5LCBpbnRlcnZhbHMpIHtcbiAgICAgIHZhciB0b25lcyA9IFtdO1xuICAgICAgdG9uZXMucHVzaChrZXkpO1xuXG4gICAgICB2YXIgbmV4dE5vdGUgPSBrZXk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGludGVydmFscy5sZW5ndGg7ICsraSkge1xuICAgICAgICBuZXh0Tm90ZSA9IHRoaXMuZ2V0UmVsYXRpdmVOb3RlVmFsdWUobmV4dE5vdGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbHNbaV0pO1xuICAgICAgICBpZiAobmV4dE5vdGUgIT0ga2V5KSB0b25lcy5wdXNoKG5leHROb3RlKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRvbmVzO1xuICAgIH0sXG5cbiAgICAvKiBSZXR1cm5zIHRoZSBpbnRlcnZhbCBvZiBhIG5vdGUsIGdpdmVuIGEgZGlhdG9uaWMgc2NhbGUuXG4gICAgICpcbiAgICAgKiBFLmcuLCBHaXZlbiB0aGUgc2NhbGUgQywgYW5kIHRoZSBub3RlIEUsIHJldHVybnMgTTNcbiAgICAgKi9cbiAgICBnZXRJbnRlcnZhbEJldHdlZW46IGZ1bmN0aW9uKG5vdGUxLCBub3RlMiwgZGlyZWN0aW9uKSB7XG4gICAgICBpZiAoZGlyZWN0aW9uID09IG51bGwpIGRpcmVjdGlvbiA9IDE7XG4gICAgICBpZiAoZGlyZWN0aW9uICE9IDEgJiYgZGlyZWN0aW9uICE9IC0xKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIiwgXCJJbnZhbGlkIGRpcmVjdGlvbjogXCIgKyBkaXJlY3Rpb24pO1xuICAgICAgaWYgKCF0aGlzLmlzVmFsaWROb3RlVmFsdWUobm90ZTEpIHx8ICF0aGlzLmlzVmFsaWROb3RlVmFsdWUobm90ZTIpKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiSW52YWxpZCBub3RlczogXCIgKyBub3RlMSArIFwiLCBcIiArIG5vdGUyKTtcblxuICAgICAgdmFyIGRpZmZlcmVuY2U7XG4gICAgICBpZiAoZGlyZWN0aW9uID09IDEpXG4gICAgICAgIGRpZmZlcmVuY2UgPSBub3RlMiAtIG5vdGUxO1xuICAgICAgZWxzZVxuICAgICAgICBkaWZmZXJlbmNlID0gbm90ZTEgLSBub3RlMjtcblxuICAgICAgaWYgKGRpZmZlcmVuY2UgPCAwKSBkaWZmZXJlbmNlICs9IE11c2ljLk5VTV9UT05FUztcbiAgICAgIHJldHVybiBkaWZmZXJlbmNlO1xuICAgIH0sXG5cbiAgICAvLyBDcmVhdGUgYSBzY2FsZSBtYXAgdGhhdCByZXByZXNlbnRzIHRoZSBwaXRjaCBzdGF0ZSBmb3IgYVxuICAgIC8vIGBrZXlTaWduYXR1cmVgLiBGb3IgZXhhbXBsZSwgcGFzc2luZyBhIGBHYCB0byBga2V5U2lnbmF0dXJlYCB3b3VsZCBcbiAgICAvLyByZXR1cm4gYSBzY2FsZSBtYXAgd2l0aCBldmVyeSBub3RlIG5hdHVyYWxpemVkIGV4Y2VwdCBmb3IgYEZgIHdoaWNoXG4gICAgLy8gaGFzIGFuIGBGI2Agc3RhdGUuXG4gICAgY3JlYXRlU2NhbGVNYXA6IGZ1bmN0aW9uKGtleVNpZ25hdHVyZSkge1xuICAgICAgdmFyIGtleVNpZ1BhcnRzID0gdGhpcy5nZXRLZXlQYXJ0cyhrZXlTaWduYXR1cmUpO1xuICAgICAgdmFyIHNjYWxlTmFtZSA9IFZleC5GbG93LktleU1hbmFnZXIuc2NhbGVzW2tleVNpZ1BhcnRzLnR5cGVdO1xuXG4gICAgICB2YXIga2V5U2lnU3RyaW5nID0ga2V5U2lnUGFydHMucm9vdDtcbiAgICAgIGlmIChrZXlTaWdQYXJ0cy5hY2NpZGVudGFsKSBrZXlTaWdTdHJpbmcgKz0ga2V5U2lnUGFydHMuYWNjaWRlbnRhbDtcblxuICAgICAgaWYgKCFzY2FsZU5hbWUpIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIlVuc3VwcG9ydGVkIGtleSB0eXBlOiBcIiArIGtleVNpZ25hdHVyZSk7XG5cbiAgICAgIHZhciBzY2FsZSA9IHRoaXMuZ2V0U2NhbGVUb25lcyh0aGlzLmdldE5vdGVWYWx1ZShrZXlTaWdTdHJpbmcpLCBzY2FsZU5hbWUpO1xuICAgICAgdmFyIG5vdGVMb2NhdGlvbiA9IFZleC5GbG93Lk11c2ljLnJvb3RfaW5kaWNlc1trZXlTaWdQYXJ0cy5yb290XTtcblxuICAgICAgdmFyIHNjYWxlTWFwID0ge307XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IFZleC5GbG93Lk11c2ljLnJvb3RzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHZhciBpbmRleCA9IChub3RlTG9jYXRpb24gKyBpKSAlIFZleC5GbG93Lk11c2ljLnJvb3RzLmxlbmd0aDtcbiAgICAgICAgdmFyIHJvb3ROYW1lID0gVmV4LkZsb3cuTXVzaWMucm9vdHNbaW5kZXhdO1xuICAgICAgICB2YXIgbm90ZU5hbWUgPSB0aGlzLmdldFJlbGF0aXZlTm90ZU5hbWUocm9vdE5hbWUsIHNjYWxlW2ldKTtcblxuICAgICAgICBpZiAobm90ZU5hbWUubGVuZ3RoID09PSAxKSB7XG4gICAgICAgICAgbm90ZU5hbWUgKz0gXCJuXCI7XG4gICAgICAgIH1cblxuICAgICAgICBzY2FsZU1hcFtyb290TmFtZV0gPSBub3RlTmFtZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHNjYWxlTWFwO1xuICAgIH1cblxuICB9O1xuXG4gIHJldHVybiBNdXNpYztcbn0oKSk7XG5cbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBkaWF0b25pYyBrZXkgbWFuYWdlbWVudC5cbi8vXG4vLyByZXF1aXJlczogdmV4LmpzICAgKFZleClcbi8vIHJlcXVpcmVzOiBmbG93LmpzICAoVmV4LkZsb3cpXG4vLyByZXF1aXJlczogbXVzaWMuanMgKFZleC5GbG93Lk11c2ljKVxuXG4vKipcbiAqIEBjb25zdHJ1Y3RvclxuICovXG5WZXguRmxvdy5LZXlNYW5hZ2VyID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBLZXlNYW5hZ2VyKGtleSkge1xuICAgIHRoaXMuaW5pdChrZXkpO1xuICB9XG5cbiAgS2V5TWFuYWdlci5zY2FsZXMgPSB7XG4gICAgXCJNXCI6IFZleC5GbG93Lk11c2ljLnNjYWxlcy5tYWpvcixcbiAgICBcIm1cIjogVmV4LkZsb3cuTXVzaWMuc2NhbGVzLm1pbm9yXG4gIH07XG5cbiAgS2V5TWFuYWdlci5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICB0aGlzLm11c2ljID0gbmV3IFZleC5GbG93Lk11c2ljKCk7XG4gICAgICB0aGlzLnNldEtleShrZXkpO1xuICAgIH0sXG5cbiAgICBzZXRLZXk6IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdGhpcy5rZXkgPSBrZXk7XG4gICAgICB0aGlzLnJlc2V0KCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0S2V5OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMua2V5OyB9LFxuXG4gICAgcmVzZXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5rZXlQYXJ0cyA9IHRoaXMubXVzaWMuZ2V0S2V5UGFydHModGhpcy5rZXkpO1xuXG4gICAgICB0aGlzLmtleVN0cmluZyA9IHRoaXMua2V5UGFydHMucm9vdDtcbiAgICAgIGlmICh0aGlzLmtleVBhcnRzLmFjY2lkZW50YWwpIHRoaXMua2V5U3RyaW5nICs9IHRoaXMua2V5UGFydHMuYWNjaWRlbnRhbDtcblxuICAgICAgdmFyIGlzX3N1cHBvcnRlZF90eXBlID0gS2V5TWFuYWdlci5zY2FsZXNbdGhpcy5rZXlQYXJ0cy50eXBlXTtcbiAgICAgIGlmICghaXNfc3VwcG9ydGVkX3R5cGUpXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50c1wiLCBcIlVuc3VwcG9ydGVkIGtleSB0eXBlOiBcIiArIHRoaXMua2V5KTtcblxuICAgICAgdGhpcy5zY2FsZSA9IHRoaXMubXVzaWMuZ2V0U2NhbGVUb25lcyhcbiAgICAgICAgICB0aGlzLm11c2ljLmdldE5vdGVWYWx1ZSh0aGlzLmtleVN0cmluZyksXG4gICAgICAgICAgVmV4LkZsb3cuS2V5TWFuYWdlci5zY2FsZXNbdGhpcy5rZXlQYXJ0cy50eXBlXSk7XG5cbiAgICAgIHRoaXMuc2NhbGVNYXAgPSB7fTtcbiAgICAgIHRoaXMuc2NhbGVNYXBCeVZhbHVlID0ge307XG4gICAgICB0aGlzLm9yaWdpbmFsU2NhbGVNYXBCeVZhbHVlID0ge307XG5cbiAgICAgIHZhciBub3RlTG9jYXRpb24gPSBWZXguRmxvdy5NdXNpYy5yb290X2luZGljZXNbdGhpcy5rZXlQYXJ0cy5yb290XTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBWZXguRmxvdy5NdXNpYy5yb290cy5sZW5ndGg7ICsraSkge1xuICAgICAgICB2YXIgaW5kZXggPSAobm90ZUxvY2F0aW9uICsgaSkgJSBWZXguRmxvdy5NdXNpYy5yb290cy5sZW5ndGg7XG4gICAgICAgIHZhciByb290TmFtZSA9IFZleC5GbG93Lk11c2ljLnJvb3RzW2luZGV4XTtcblxuICAgICAgICB2YXIgbm90ZU5hbWUgPSB0aGlzLm11c2ljLmdldFJlbGF0aXZlTm90ZU5hbWUocm9vdE5hbWUsIHRoaXMuc2NhbGVbaV0pO1xuICAgICAgICB0aGlzLnNjYWxlTWFwW3Jvb3ROYW1lXSA9IG5vdGVOYW1lO1xuICAgICAgICB0aGlzLnNjYWxlTWFwQnlWYWx1ZVt0aGlzLnNjYWxlW2ldXSA9IG5vdGVOYW1lO1xuICAgICAgICB0aGlzLm9yaWdpbmFsU2NhbGVNYXBCeVZhbHVlW3RoaXMuc2NhbGVbaV1dID0gbm90ZU5hbWU7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRBY2NpZGVudGFsOiBmdW5jdGlvbihrZXkpIHtcbiAgICAgIHZhciByb290ID0gdGhpcy5tdXNpYy5nZXRLZXlQYXJ0cyhrZXkpLnJvb3Q7XG4gICAgICB2YXIgcGFydHMgPSB0aGlzLm11c2ljLmdldE5vdGVQYXJ0cyh0aGlzLnNjYWxlTWFwW3Jvb3RdKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbm90ZTogdGhpcy5zY2FsZU1hcFtyb290XSxcbiAgICAgICAgYWNjaWRlbnRhbDogcGFydHMuYWNjaWRlbnRhbFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgc2VsZWN0Tm90ZTogZnVuY3Rpb24obm90ZSkge1xuICAgICAgbm90ZSA9IG5vdGUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciBwYXJ0cyA9IHRoaXMubXVzaWMuZ2V0Tm90ZVBhcnRzKG5vdGUpO1xuXG4gICAgICAvLyBGaXJzdCBsb29rIGZvciBtYXRjaGluZyBub3RlIGluIG91ciBhbHRlcmVkIHNjYWxlXG4gICAgICB2YXIgc2NhbGVOb3RlID0gdGhpcy5zY2FsZU1hcFtwYXJ0cy5yb290XTtcbiAgICAgIHZhciBtb2RwYXJ0cyA9IHRoaXMubXVzaWMuZ2V0Tm90ZVBhcnRzKHNjYWxlTm90ZSk7XG5cbiAgICAgIGlmIChzY2FsZU5vdGUgPT0gbm90ZSkgcmV0dXJuIHtcbiAgICAgICAgXCJub3RlXCI6IHNjYWxlTm90ZSxcbiAgICAgICAgXCJhY2NpZGVudGFsXCI6IHBhcnRzLmFjY2lkZW50YWwsXG4gICAgICAgIFwiY2hhbmdlXCI6IGZhbHNlXG4gICAgICB9O1xuXG4gICAgICAvLyBUaGVuIHNlYXJjaCBmb3IgYSBub3RlIG9mIGVxdWl2YWxlbnQgdmFsdWUgaW4gb3VyIGFsdGVyZWQgc2NhbGVcbiAgICAgIHZhciB2YWx1ZU5vdGUgPSB0aGlzLnNjYWxlTWFwQnlWYWx1ZVt0aGlzLm11c2ljLmdldE5vdGVWYWx1ZShub3RlKV07XG4gICAgICBpZiAodmFsdWVOb3RlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBcIm5vdGVcIjogdmFsdWVOb3RlLFxuICAgICAgICAgIFwiYWNjaWRlbnRhbFwiOiB0aGlzLm11c2ljLmdldE5vdGVQYXJ0cyh2YWx1ZU5vdGUpLmFjY2lkZW50YWwsXG4gICAgICAgICAgXCJjaGFuZ2VcIjogZmFsc2VcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlbiBzZWFyY2ggZm9yIGEgbm90ZSBvZiBlcXVpdmFsZW50IHZhbHVlIGluIHRoZSBvcmlnaW5hbCBzY2FsZVxuICAgICAgdmFyIG9yaWdpbmFsVmFsdWVOb3RlID0gdGhpcy5vcmlnaW5hbFNjYWxlTWFwQnlWYWx1ZVtcbiAgICAgICAgdGhpcy5tdXNpYy5nZXROb3RlVmFsdWUobm90ZSldO1xuICAgICAgaWYgKG9yaWdpbmFsVmFsdWVOb3RlICE9IG51bGwpIHtcbiAgICAgICAgdGhpcy5zY2FsZU1hcFttb2RwYXJ0cy5yb290XSA9IG9yaWdpbmFsVmFsdWVOb3RlO1xuICAgICAgICBkZWxldGUgdGhpcy5zY2FsZU1hcEJ5VmFsdWVbdGhpcy5tdXNpYy5nZXROb3RlVmFsdWUoc2NhbGVOb3RlKV07XG4gICAgICAgIHRoaXMuc2NhbGVNYXBCeVZhbHVlW3RoaXMubXVzaWMuZ2V0Tm90ZVZhbHVlKG5vdGUpXSA9IG9yaWdpbmFsVmFsdWVOb3RlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFwibm90ZVwiOiBvcmlnaW5hbFZhbHVlTm90ZSxcbiAgICAgICAgICBcImFjY2lkZW50YWxcIjogdGhpcy5tdXNpYy5nZXROb3RlUGFydHMob3JpZ2luYWxWYWx1ZU5vdGUpLmFjY2lkZW50YWwsXG4gICAgICAgICAgXCJjaGFuZ2VcIjogdHJ1ZVxuICAgICAgICB9O1xuICAgICAgfVxuXG4gICAgICAvLyBUaGVuIHRyeSB0byB1bm1vZGlmeSBhIGN1cnJlbnRseSBtb2RpZmllZCBub3RlLlxuICAgICAgaWYgKG1vZHBhcnRzLnJvb3QgPT0gbm90ZSkge1xuICAgICAgICBkZWxldGUgdGhpcy5zY2FsZU1hcEJ5VmFsdWVbXG4gICAgICAgICAgdGhpcy5tdXNpYy5nZXROb3RlVmFsdWUodGhpcy5zY2FsZU1hcFtwYXJ0cy5yb290XSldO1xuICAgICAgICB0aGlzLnNjYWxlTWFwQnlWYWx1ZVt0aGlzLm11c2ljLmdldE5vdGVWYWx1ZShtb2RwYXJ0cy5yb290KV0gPVxuICAgICAgICAgIG1vZHBhcnRzLnJvb3Q7XG4gICAgICAgIHRoaXMuc2NhbGVNYXBbbW9kcGFydHMucm9vdF0gPSBtb2RwYXJ0cy5yb290O1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIFwibm90ZVwiOiBtb2RwYXJ0cy5yb290LFxuICAgICAgICAgIFwiYWNjaWRlbnRhbFwiOiBudWxsLFxuICAgICAgICAgIFwiY2hhbmdlXCI6IHRydWVcbiAgICAgICAgfTtcbiAgICAgIH1cblxuICAgICAgLy8gTGFzdCByZXNvcnQgLS0gc2hpdHNob290XG4gICAgICBkZWxldGUgdGhpcy5zY2FsZU1hcEJ5VmFsdWVbXG4gICAgICAgIHRoaXMubXVzaWMuZ2V0Tm90ZVZhbHVlKHRoaXMuc2NhbGVNYXBbcGFydHMucm9vdF0pXTtcbiAgICAgIHRoaXMuc2NhbGVNYXBCeVZhbHVlW3RoaXMubXVzaWMuZ2V0Tm90ZVZhbHVlKG5vdGUpXSA9IG5vdGU7XG5cbiAgICAgIGRlbGV0ZSB0aGlzLnNjYWxlTWFwW21vZHBhcnRzLnJvb3RdO1xuICAgICAgdGhpcy5zY2FsZU1hcFttb2RwYXJ0cy5yb290XSA9IG5vdGU7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIFwibm90ZVwiOiBub3RlLFxuICAgICAgICBcImFjY2lkZW50YWxcIjogcGFydHMuYWNjaWRlbnRhbCxcbiAgICAgICAgXCJjaGFuZ2VcIjogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIEtleU1hbmFnZXI7XG59KCkpO1xuXG4vLyBWZXggRmxvd1xuLy8gTW9oaXQgTXV0aGFubmEgPG1vaGl0QG11dGhhbm5hLmNvbT5cbi8vXG4vLyBTdXBwb3J0IGZvciBkaWZmZXJlbnQgcmVuZGVyaW5nIGNvbnRleHRzOiBDYW52YXMsIFJhcGhhZWxcbi8vXG4vLyBDb3B5cmlnaHQgTW9oaXQgQ2hlcHB1ZGlyYSAyMDEwXG5cbi8qIGdsb2JhbCBkb2N1bWVudDogZmFsc2UgKi9cblxuVmV4LkZsb3cuUmVuZGVyZXIgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFJlbmRlcmVyKHNlbCwgYmFja2VuZCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHNlbCwgYmFja2VuZCk7XG4gIH1cblxuICBSZW5kZXJlci5CYWNrZW5kcyA9IHtcbiAgICBDQU5WQVM6IDEsXG4gICAgUkFQSEFFTDogMixcbiAgICBTVkc6IDMsXG4gICAgVk1MOiA0XG4gIH07XG5cbiAgLy9FbmQgb2YgbGluZSB0eXBlc1xuICBSZW5kZXJlci5MaW5lRW5kVHlwZSA9IHtcbiAgICAgIE5PTkU6IDEsICAgICAgICAvLyBObyBsZWdcbiAgICAgIFVQOiAyLCAgICAgICAgICAvLyBVcHdhcmQgbGVnXG4gICAgICBET1dOOiAzICAgICAgICAgLy8gRG93bndhcmQgbGVnXG4gIH07XG5cbiAgLy8gU2V0IHRoaXMgdG8gdHJ1ZSBpZiB5b3UncmUgdXNpbmcgVmV4RmxvdyBpbnNpZGUgYSBydW50aW1lXG4gIC8vIHRoYXQgZG9lcyBub3QgYWxsb3cgbW9kaWZpeWluZyBjYW52YXMgb2JqZWN0cy4gVGhlcmUgaXMgYSBzbWFsbFxuICAvLyBwZXJmb3JtYW5jZSBkZWdyYWRhdGlvbiBkdWUgdG8gdGhlIGV4dHJhIGluZGlyZWN0aW9uLlxuICBSZW5kZXJlci5VU0VfQ0FOVkFTX1BST1hZID0gZmFsc2U7XG4gIFJlbmRlcmVyLmxhc3RDb250ZXh0ID0gbnVsbDtcblxuICBSZW5kZXJlci5idWlsZENvbnRleHQgPSBmdW5jdGlvbihzZWwsXG4gICAgICBiYWNrZW5kLCB3aWR0aCwgaGVpZ2h0LCBiYWNrZ3JvdW5kKSB7XG5cbiAgICB2YXIgcmVuZGVyZXIgPSBuZXcgUmVuZGVyZXIoc2VsLCBiYWNrZW5kKTtcbiAgICBpZiAod2lkdGggJiYgaGVpZ2h0KSB7IHJlbmRlcmVyLnJlc2l6ZSh3aWR0aCwgaGVpZ2h0KTsgfVxuXG4gICAgaWYgKCFiYWNrZ3JvdW5kKSBiYWNrZ3JvdW5kID0gXCIjRkZGXCI7XG4gICAgdmFyIGN0eCA9IHJlbmRlcmVyLmdldENvbnRleHQoKTtcbiAgICBjdHguc2V0QmFja2dyb3VuZEZpbGxTdHlsZShiYWNrZ3JvdW5kKTtcbiAgICBSZW5kZXJlci5sYXN0Q29udGV4dCA9IGN0eDtcbiAgICByZXR1cm4gY3R4O1xuICB9O1xuXG4gIFJlbmRlcmVyLmdldENhbnZhc0NvbnRleHQgPSBmdW5jdGlvbihzZWwsIHdpZHRoLCBoZWlnaHQsIGJhY2tncm91bmQpIHtcbiAgICByZXR1cm4gUmVuZGVyZXIuYnVpbGRDb250ZXh0KHNlbCwgUmVuZGVyZXIuQmFja2VuZHMuQ0FOVkFTLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LCBiYWNrZ3JvdW5kKTtcbiAgfTtcblxuICBSZW5kZXJlci5nZXRSYXBoYWVsQ29udGV4dCA9IGZ1bmN0aW9uKHNlbCwgd2lkdGgsIGhlaWdodCwgYmFja2dyb3VuZCkge1xuICAgIHJldHVybiBSZW5kZXJlci5idWlsZENvbnRleHQoc2VsLCBSZW5kZXJlci5CYWNrZW5kcy5SQVBIQUVMLFxuICAgICAgICB3aWR0aCwgaGVpZ2h0LCBiYWNrZ3JvdW5kKTtcbiAgfTtcblxuICBSZW5kZXJlci5nZXRTVkdDb250ZXh0ID0gZnVuY3Rpb24oc2VsLCB3aWR0aCwgaGVpZ2h0LCBiYWNrZ3JvdW5kKSB7XG4gICAgcmV0dXJuIFJlbmRlcmVyLmJ1aWxkQ29udGV4dChzZWwsIFJlbmRlcmVyLkJhY2tlbmRzLlNWRyxcbiAgICAgICAgd2lkdGgsIGhlaWdodCwgYmFja2dyb3VuZCk7XG4gIH07XG5cblxuICBSZW5kZXJlci5ib2xzdGVyQ2FudmFzQ29udGV4dCA9IGZ1bmN0aW9uKGN0eCkge1xuICAgIGlmIChSZW5kZXJlci5VU0VfQ0FOVkFTX1BST1hZKSB7XG4gICAgICByZXR1cm4gbmV3IFZleC5GbG93LkNhbnZhc0NvbnRleHQoY3R4KTtcbiAgICB9XG5cbiAgICB2YXIgbWV0aG9kcyA9IFtcImNsZWFyXCIsIFwic2V0Rm9udFwiLCBcInNldFJhd0ZvbnRcIiwgXCJzZXRGaWxsU3R5bGVcIiwgXCJzZXRCYWNrZ3JvdW5kRmlsbFN0eWxlXCIsXG4gICAgICAgICAgICAgICAgICAgXCJzZXRTdHJva2VTdHlsZVwiLCBcInNldFNoYWRvd0NvbG9yXCIsIFwic2V0U2hhZG93Qmx1clwiLCBcInNldExpbmVXaWR0aFwiLFxuICAgICAgICAgICAgICAgICAgIFwic2V0TGluZUNhcFwiLCBcInNldExpbmVEYXNoXCIsIFwib3Blbkdyb3VwXCIsIFwiY2xvc2VHcm91cFwiLCBcImdldEdyb3VwXCJdO1xuICAgIGN0eC52ZXhGbG93Q2FudmFzQ29udGV4dCA9IGN0eDtcblxuICAgIGZvciAodmFyIGkgaW4gbWV0aG9kcykge1xuICAgICAgdmFyIG1ldGhvZCA9IG1ldGhvZHNbaV07XG4gICAgICBjdHhbbWV0aG9kXSA9IFZleC5GbG93LkNhbnZhc0NvbnRleHQucHJvdG90eXBlW21ldGhvZF07XG4gICAgfVxuXG4gICAgcmV0dXJuIGN0eDtcbiAgfTtcblxuICAvL0RyYXcgYSBkYXNoZWQgbGluZSAoaG9yaXpvbnRhbCwgdmVydGljYWwgb3IgZGlhZ29uYWxcbiAgLy9kYXNoUGF0dGVybiA9IFszLDNdIGRyYXdzIGEgMyBwaXhlbCBkYXNoIGZvbGxvd2VkIGJ5IGEgdGhyZWUgcGl4ZWwgc3BhY2UuXG4gIC8vc2V0dGluZyB0aGUgc2Vjb25kIG51bWJlciB0byAwIGRyYXdzIGEgc29saWQgbGluZS5cbiAgUmVuZGVyZXIuZHJhd0Rhc2hlZExpbmUgPSBmdW5jdGlvbihjb250ZXh0LCBmcm9tWCwgZnJvbVksIHRvWCwgdG9ZLCBkYXNoUGF0dGVybikge1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG5cbiAgICB2YXIgZHggPSB0b1ggLSBmcm9tWDtcbiAgICB2YXIgZHkgPSB0b1kgLSBmcm9tWTtcbiAgICB2YXIgYW5nbGUgPSBNYXRoLmF0YW4yKGR5LCBkeCk7XG4gICAgdmFyIHggPSBmcm9tWDtcbiAgICB2YXIgeSA9IGZyb21ZO1xuICAgIGNvbnRleHQubW92ZVRvKGZyb21YLCBmcm9tWSk7XG4gICAgdmFyIGlkeCA9IDA7XG4gICAgdmFyIGRyYXcgPSB0cnVlO1xuICAgIHdoaWxlICghKChkeCA8IDAgPyB4IDw9IHRvWCA6IHggPj0gdG9YKSAmJiAoZHkgPCAwID8geSA8PSB0b1kgOiB5ID49IHRvWSkpKSB7XG4gICAgICB2YXIgZGFzaExlbmd0aCA9IGRhc2hQYXR0ZXJuW2lkeCsrICUgZGFzaFBhdHRlcm4ubGVuZ3RoXTtcbiAgICAgIHZhciBueCA9IHggKyAoTWF0aC5jb3MoYW5nbGUpICogZGFzaExlbmd0aCk7XG4gICAgICB4ID0gZHggPCAwID8gTWF0aC5tYXgodG9YLCBueCkgOiBNYXRoLm1pbih0b1gsIG54KTtcbiAgICAgIHZhciBueSA9IHkgKyAoTWF0aC5zaW4oYW5nbGUpICogZGFzaExlbmd0aCk7XG4gICAgICB5ID0gZHkgPCAwID8gTWF0aC5tYXgodG9ZLCBueSkgOiBNYXRoLm1pbih0b1ksIG55KTtcbiAgICAgIGlmIChkcmF3KSB7XG4gICAgICAgIGNvbnRleHQubGluZVRvKHgsIHkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udGV4dC5tb3ZlVG8oeCwgeSk7XG4gICAgICB9XG4gICAgICAgIGRyYXcgPSAhZHJhdztcbiAgICB9XG5cbiAgICBjb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgIGNvbnRleHQuc3Ryb2tlKCk7XG4gIH07XG5cbiAgUmVuZGVyZXIucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKHNlbCwgYmFja2VuZCkge1xuICAgICAgLy8gVmVyaWZ5IHNlbGVjdG9yXG4gICAgICB0aGlzLnNlbCA9IHNlbDtcbiAgICAgIGlmICghdGhpcy5zZWwpIHRocm93IG5ldyBWZXguUkVSUihcIkJhZEFyZ3VtZW50XCIsXG4gICAgICAgICAgXCJJbnZhbGlkIHNlbGVjdG9yIGZvciByZW5kZXJlci5cIik7XG5cbiAgICAgIC8vIEdldCBlbGVtZW50IGZyb20gc2VsZWN0b3JcbiAgICAgIHRoaXMuZWxlbWVudCA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNlbCk7XG4gICAgICBpZiAoIXRoaXMuZWxlbWVudCkgdGhpcy5lbGVtZW50ID0gc2VsO1xuXG4gICAgICAvLyBWZXJpZnkgYmFja2VuZCBhbmQgY3JlYXRlIGNvbnRleHRcbiAgICAgIHRoaXMuY3R4ID0gbnVsbDtcbiAgICAgIHRoaXMucGFwZXIgPSBudWxsO1xuICAgICAgdGhpcy5iYWNrZW5kID0gYmFja2VuZDtcbiAgICAgIGlmICh0aGlzLmJhY2tlbmQgPT0gUmVuZGVyZXIuQmFja2VuZHMuQ0FOVkFTKSB7XG4gICAgICAgIC8vIENyZWF0ZSBjb250ZXh0LlxuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudC5nZXRDb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRFbGVtZW50XCIsXG4gICAgICAgICAgXCJDYW4ndCBnZXQgY2FudmFzIGNvbnRleHQgZnJvbSBlbGVtZW50OiBcIiArIHNlbCk7XG4gICAgICAgIHRoaXMuY3R4ID0gUmVuZGVyZXIuYm9sc3RlckNhbnZhc0NvbnRleHQoXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKSk7XG5cbiAgICAgIH0gZWxzZSBpZiAodGhpcy5iYWNrZW5kID09IFJlbmRlcmVyLkJhY2tlbmRzLlJBUEhBRUwpIHtcbiAgICAgICAgdGhpcy5jdHggPSBuZXcgVmV4LkZsb3cuUmFwaGFlbENvbnRleHQodGhpcy5lbGVtZW50KTtcblxuICAgICAgfSBlbHNlIGlmICh0aGlzLmJhY2tlbmQgPT0gUmVuZGVyZXIuQmFja2VuZHMuU1ZHKSB7XG4gICAgICAgIHRoaXMuY3R4ID0gbmV3IFZleC5GbG93LlNWR0NvbnRleHQodGhpcy5lbGVtZW50KTtcblxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiSW52YWxpZEJhY2tlbmRcIixcbiAgICAgICAgICBcIk5vIHN1cHBvcnQgZm9yIGJhY2tlbmQ6IFwiICsgdGhpcy5iYWNrZW5kKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAodGhpcy5iYWNrZW5kID09IFJlbmRlcmVyLkJhY2tlbmRzLkNBTlZBUykge1xuICAgICAgICBpZiAoIXRoaXMuZWxlbWVudC5nZXRDb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRFbGVtZW50XCIsXG4gICAgICAgICAgXCJDYW4ndCBnZXQgY2FudmFzIGNvbnRleHQgZnJvbSBlbGVtZW50OiBcIiArIHRoaXMuc2VsKTtcbiAgICAgICAgdGhpcy5lbGVtZW50LndpZHRoID0gd2lkdGg7XG4gICAgICAgIHRoaXMuZWxlbWVudC5oZWlnaHQgPSBoZWlnaHQ7XG4gICAgICAgIHRoaXMuY3R4ID0gUmVuZGVyZXIuYm9sc3RlckNhbnZhc0NvbnRleHQoXG4gICAgICAgICAgICB0aGlzLmVsZW1lbnQuZ2V0Q29udGV4dCgnMmQnKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmN0eC5yZXNpemUod2lkdGgsIGhlaWdodCk7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBnZXRDb250ZXh0OiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMuY3R4OyB9XG4gIH07XG5cbiAgcmV0dXJuIFJlbmRlcmVyO1xufSgpKTtcblxuXG5cbi8vIFZleCBGbG93XG4vLyBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy9cbi8vIEEgcmVuZGVyaW5nIGNvbnRleHQgZm9yIHRoZSBSYXBoYWVsIGJhY2tlbmQuXG4vL1xuLy8gQ29weXJpZ2h0IE1vaGl0IENoZXBwdWRpcmEgMjAxMFxuXG4vLyAjIyBXYXJuaW5nOiBEZXByZWNhdGVkIGZvciBTVkdDb250ZXh0XG4vLyBFeGNlcHQgaW4gaW5zdGFuY2VzIHdoZXJlIFNWRyBzdXBwb3J0IGZvciBJRSA8IDkuMCBpc1xuLy8gbmVlZGVkLCBTVkdDb250ZXh0IGlzIHJlY29tbWVuZGVkLlxuXG4vKiogQGNvbnN0cnVjdG9yICovXG5WZXguRmxvdy5SYXBoYWVsQ29udGV4dCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gUmFwaGFlbENvbnRleHQoZWxlbWVudCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KGVsZW1lbnQpO1xuICB9XG5cbiAgUmFwaGFlbENvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIHRoaXMuZWxlbWVudCA9IGVsZW1lbnQ7XG4gICAgICB0aGlzLnBhcGVyID0gUmFwaGFlbChlbGVtZW50KTtcbiAgICAgIHRoaXMucGF0aCA9IFwiXCI7XG4gICAgICB0aGlzLnBlbiA9IHt4OiAwLCB5OiAwfTtcbiAgICAgIHRoaXMubGluZVdpZHRoID0gMS4wO1xuICAgICAgdGhpcy5zdGF0ZSA9IHtcbiAgICAgICAgc2NhbGU6IHsgeDogMSwgeTogMSB9LFxuICAgICAgICBmb250X2ZhbWlseTogXCJBcmlhbFwiLFxuICAgICAgICBmb250X3NpemU6IDgsXG4gICAgICAgIGZvbnRfd2VpZ2h0OiA4MDBcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHtcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMC4zLFxuICAgICAgICBcImZpbGxcIjogXCJibGFja1wiLFxuICAgICAgICBcInN0cm9rZVwiOiBcImJsYWNrXCIsXG4gICAgICAgIFwiZm9udFwiOiBcIjEwcHQgQXJpYWxcIlxuICAgICAgfTtcblxuICAgICAgdGhpcy5iYWNrZ3JvdW5kX2F0dHJpYnV0ZXMgPSB7XG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDAsXG4gICAgICAgIFwiZmlsbFwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwic3Ryb2tlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJmb250XCI6IFwiMTBwdCBBcmlhbFwiXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnNoYWRvd19hdHRyaWJ1dGVzID0ge1xuICAgICAgICB3aWR0aDogMCxcbiAgICAgICAgY29sb3I6IFwiYmxhY2tcIlxuICAgICAgfTtcblxuICAgICAgdGhpcy5zdGF0ZV9zdGFjaz0gW107XG4gICAgfSxcblxuICAgIC8vIENvbnRhaW5lcnMgbm90IGltcGxlbWVudGVkXG4gICAgb3Blbkdyb3VwOiBmdW5jdGlvbihjbHMsIGlkLCBhdHRycykge30sXG4gICAgY2xvc2VHcm91cDogZnVuY3Rpb24oKSB7fSxcbiAgICBhZGQ6IGZ1bmN0aW9uKGVsZW0pIHt9LFxuXG4gICAgc2V0Rm9udDogZnVuY3Rpb24oZmFtaWx5LCBzaXplLCB3ZWlnaHQpIHtcbiAgICAgIHRoaXMuc3RhdGUuZm9udF9mYW1pbHkgPSBmYW1pbHk7XG4gICAgICB0aGlzLnN0YXRlLmZvbnRfc2l6ZSA9IHNpemU7XG4gICAgICB0aGlzLnN0YXRlLmZvbnRfd2VpZ2h0ID0gd2VpZ2h0O1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzLmZvbnQgPSAodGhpcy5zdGF0ZS5mb250X3dlaWdodCB8fCBcIlwiKSArIFwiIFwiICtcbiAgICAgICAgKHRoaXMuc3RhdGUuZm9udF9zaXplICogdGhpcy5zdGF0ZS5zY2FsZS54KSArIFwicHQgXCIgK1xuICAgICAgICB0aGlzLnN0YXRlLmZvbnRfZmFtaWx5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFJhd0ZvbnQ6IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICAgIHRoaXMuYXR0cmlidXRlcy5mb250ID0gZm9udDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRGaWxsU3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuZmlsbCA9IHN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEJhY2tncm91bmRGaWxsU3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICB0aGlzLmJhY2tncm91bmRfYXR0cmlidXRlcy5maWxsID0gc3R5bGU7XG4gICAgICB0aGlzLmJhY2tncm91bmRfYXR0cmlidXRlcy5zdHJva2UgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTdHJva2VTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHRoaXMuYXR0cmlidXRlcy5zdHJva2UgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3dDb2xvcjogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHRoaXMuc2hhZG93X2F0dHJpYnV0ZXMuY29sb3IgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3dCbHVyOiBmdW5jdGlvbihibHVyKSB7XG4gICAgICB0aGlzLnNoYWRvd19hdHRyaWJ1dGVzLndpZHRoID0gYmx1cjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRMaW5lV2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbXCJzdHJva2Utd2lkdGhcIl0gPSB3aWR0aDtcbiAgICAgIHRoaXMubGluZVdpZHRoID0gd2lkdGg7XG4gICAgfSxcblxuICAgIC8vIEVtcHR5IGJlY2F1c2UgdGhlcmUgaXMgbm8gZXF1aXZhbGVudCBpbiBTVkdcbiAgICBzZXRMaW5lRGFzaDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9LFxuICAgIHNldExpbmVDYXA6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSxcblxuICAgIHNjYWxlOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnN0YXRlLnNjYWxlID0geyB4OiB4LCB5OiB5IH07XG4gICAgICAvLyBUaGUgc2NhbGUoKSBtZXRob2QgaXMgZGVwcmVjYXRlZCBhcyBvZiBSYXBoYWVsLkpTIDIuMCwgYW5kXG4gICAgICAvLyBjYW4gbm8gbG9uZ2VyIGJlIHVzZWQgYXMgYW4gb3B0aW9uIGluIGFuIEVsZW1lbnQuYXR0cigpIGNhbGwuXG4gICAgICAvLyBJdCBpcyBwcmVzZXJ2ZWQgaGVyZSBmb3IgdXNlcnMgcnVubmluZyBlYXJsaWVyIHZlcnNpb25zIG9mXG4gICAgICAvLyBSYXBoYWVsLkpTLCB0aG91Z2ggaXQgaGFzIG5vIGVmZmVjdCBvbiB0aGUgU1ZHIG91dHB1dCBpblxuICAgICAgLy8gUmFwaGFlbCAyIGFuZCBoaWdoZXIuXG4gICAgICB0aGlzLmF0dHJpYnV0ZXMudHJhbnNmb3JtID0gXCJTXCIgKyB4ICsgXCIsXCIgKyB5ICsgXCIsMCwwXCI7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuc2NhbGUgPSB4ICsgXCIsXCIgKyB5ICsgXCIsMCwwXCI7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuZm9udCA9IHRoaXMuc3RhdGUuZm9udF9zaXplICogdGhpcy5zdGF0ZS5zY2FsZS54ICsgXCJwdCBcIiArXG4gICAgICAgIHRoaXMuc3RhdGUuZm9udF9mYW1pbHk7XG4gICAgICB0aGlzLmJhY2tncm91bmRfYXR0cmlidXRlcy50cmFuc2Zvcm0gPSBcIlNcIiArIHggKyBcIixcIiArIHkgKyBcIiwwLDBcIjtcbiAgICAgIHRoaXMuYmFja2dyb3VuZF9hdHRyaWJ1dGVzLmZvbnQgPSB0aGlzLnN0YXRlLmZvbnRfc2l6ZSAqXG4gICAgICAgIHRoaXMuc3RhdGUuc2NhbGUueCArIFwicHQgXCIgK1xuICAgICAgICB0aGlzLnN0YXRlLmZvbnRfZmFtaWx5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGNsZWFyOiBmdW5jdGlvbigpIHsgdGhpcy5wYXBlci5jbGVhcigpOyB9LFxuXG4gICAgcmVzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLmVsZW1lbnQuc3R5bGUud2lkdGggPSB3aWR0aDtcbiAgICAgIHRoaXMucGFwZXIuc2V0U2l6ZSh3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXRzIHRoZSBTVkcgYHZpZXdCb3hgIHByb3BlcnR5LCB3aGljaCByZXN1bHRzIGluIGF1dG8gc2NhbGluZyBpbWFnZXMgd2hlbiBpdHMgY29udGFpbmVyXG4gICAgLy8gaXMgcmVzaXplZC5cbiAgICAvL1xuICAgIC8vIFVzYWdlOiBgY3R4LnNldFZpZXdCb3goXCIwIDAgNjAwIDQwMFwiKWBcbiAgICBzZXRWaWV3Qm94OiBmdW5jdGlvbih2aWV3Qm94KSB7XG4gICAgICB0aGlzLnBhcGVyLmNhbnZhcy5zZXRBdHRyaWJ1dGUoJ3ZpZXdCb3gnLCB2aWV3Qm94KTtcbiAgICB9LFxuXG4gICAgcmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgaWYgKGhlaWdodCA8IDApIHtcbiAgICAgICAgeSArPSBoZWlnaHQ7XG4gICAgICAgIGhlaWdodCA9IC1oZWlnaHQ7XG4gICAgICB9XG5cbiAgICAgIHRoaXMucGFwZXIucmVjdCh4LCB5LCB3aWR0aCAtIDAuNSwgaGVpZ2h0IC0gMC41KS5cbiAgICAgICAgYXR0cih0aGlzLmF0dHJpYnV0ZXMpLlxuICAgICAgICBhdHRyKFwiZmlsbFwiLCBcIm5vbmVcIikuXG4gICAgICAgIGF0dHIoXCJzdHJva2Utd2lkdGhcIiwgdGhpcy5saW5lV2lkdGgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZpbGxSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICB5ICs9IGhlaWdodDtcbiAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXBlci5yZWN0KHgsIHksIHdpZHRoIC0gMC41LCBoZWlnaHQgLSAwLjUpLlxuICAgICAgICBhdHRyKHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xlYXJSZWN0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICBpZiAoaGVpZ2h0IDwgMCkge1xuICAgICAgICB5ICs9IGhlaWdodDtcbiAgICAgICAgaGVpZ2h0ID0gLWhlaWdodDtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXBlci5yZWN0KHgsIHksIHdpZHRoIC0gMC41LCBoZWlnaHQgLSAwLjUpLlxuICAgICAgICBhdHRyKHRoaXMuYmFja2dyb3VuZF9hdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBiZWdpblBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYXRoID0gXCJcIjtcbiAgICAgIHRoaXMucGVuLnggPSAwO1xuICAgICAgdGhpcy5wZW4ueSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJNXCIgKyB4ICsgXCIsXCIgKyB5O1xuICAgICAgdGhpcy5wZW4ueCA9IHg7XG4gICAgICB0aGlzLnBlbi55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMucGF0aCArPSBcIkxcIiArIHggKyBcIixcIiArIHk7XG4gICAgICB0aGlzLnBlbi54ID0geDtcbiAgICAgIHRoaXMucGVuLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJDXCIgK1xuICAgICAgICB4MSArIFwiLFwiICtcbiAgICAgICAgeTEgKyBcIixcIiArXG4gICAgICAgIHgyICsgXCIsXCIgK1xuICAgICAgICB5MiArIFwiLFwiICtcbiAgICAgICAgeCArIFwiLFwiICtcbiAgICAgICAgeTtcbiAgICAgIHRoaXMucGVuLnggPSB4O1xuICAgICAgdGhpcy5wZW4ueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4LCB5KSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJRXCIgK1xuICAgICAgICB4MSArIFwiLFwiICtcbiAgICAgICAgeTEgKyBcIixcIiArXG4gICAgICAgIHggKyBcIixcIiArXG4gICAgICAgIHk7XG4gICAgICB0aGlzLnBlbi54ID0geDtcbiAgICAgIHRoaXMucGVuLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRoaXMgaXMgYW4gYXR0ZW1wdCAoaGFjaykgdG8gc2ltdWxhdGUgdGhlIEhUTUw1IGNhbnZhc1xuICAgIC8vIGFyYyBtZXRob2QuXG4gICAgYXJjOiBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpQ2xvY2t3aXNlKSB7XG4gICAgICBmdW5jdGlvbiBub3JtYWxpemVBbmdsZShhbmdsZSkge1xuICAgICAgICB3aGlsZSAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoYW5nbGUgPiBNYXRoLlBJICogMikge1xuICAgICAgICAgIGFuZ2xlIC09IE1hdGguUEkgKiAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmdsZTtcbiAgICAgIH1cblxuICAgICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlKHN0YXJ0QW5nbGUpO1xuICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVBbmdsZShlbmRBbmdsZSk7XG5cbiAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICAgICAgZW5kQW5nbGUgPSB0bXA7XG4gICAgICAgICAgYW50aUNsb2Nrd2lzZSA9ICFhbnRpQ2xvY2t3aXNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVsdGEgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG5cbiAgICAgIGlmIChkZWx0YSA+IE1hdGguUEkpIHtcbiAgICAgICAgICB0aGlzLmFyY0hlbHBlcih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIHN0YXJ0QW5nbGUgKyBkZWx0YSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgYW50aUNsb2Nrd2lzZSk7XG4gICAgICAgICAgdGhpcy5hcmNIZWxwZXIoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlICsgZGVsdGEgLyAyLCBlbmRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhbnRpQ2xvY2t3aXNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXJjSGVscGVyKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGlDbG9ja3dpc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFyY0hlbHBlcjogZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aUNsb2Nrd2lzZSkge1xuICAgICAgdmFyIHgxID0geCArIHJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgdmFyIHkxID0geSArIHJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuXG4gICAgICB2YXIgeDIgPSB4ICsgcmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgICAgdmFyIHkyID0geSArIHJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKTtcblxuICAgICAgdmFyIGxhcmdlQXJjRmxhZyA9IDA7XG4gICAgICB2YXIgc3dlZXBGbGFnID0gMDtcbiAgICAgIGlmIChhbnRpQ2xvY2t3aXNlKSB7XG4gICAgICAgIHN3ZWVwRmxhZyA9IDE7XG4gICAgICAgIGlmIChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPCBNYXRoLlBJKVxuICAgICAgICAgIGxhcmdlQXJjRmxhZyA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPiBNYXRoLlBJKSB7XG4gICAgICAgICAgbGFyZ2VBcmNGbGFnID0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXRoICs9IFwiTVwiICsgeDEgKyBcIixcIiArIHkxICsgXCIsXCIgKyBcIkFcIiArXG4gICAgICAgIHJhZGl1cyArIFwiLFwiICsgcmFkaXVzICsgXCIsXCIgKyBcIjAsXCIgKyBsYXJnZUFyY0ZsYWcgKyBcIixcIiArIHN3ZWVwRmxhZyArIFwiLFwiICtcbiAgICAgICAgeDIgKyBcIixcIiArIHkyICsgXCJNXCIgKyB0aGlzLnBlbi54ICsgXCIsXCIgKyB0aGlzLnBlbi55O1xuICAgIH0sXG5cbiAgICAvLyBBZGFwdGVkIGZyb20gdGhlIHNvdXJjZSBmb3IgUmFwaGFlbCdzIEVsZW1lbnQuZ2xvd1xuICAgIGdsb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG91dCA9IHRoaXMucGFwZXIuc2V0KCk7XG4gICAgICBpZiAodGhpcy5zaGFkb3dfYXR0cmlidXRlcy53aWR0aCA+IDApIHtcbiAgICAgICAgdmFyIHNhID0gdGhpcy5zaGFkb3dfYXR0cmlidXRlcztcbiAgICAgICAgdmFyIG51bV9wYXRocyA9IHNhLndpZHRoIC8gMjtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPD0gbnVtX3BhdGhzOyBpKyspIHtcbiAgICAgICAgICBvdXQucHVzaCh0aGlzLnBhcGVyLnBhdGgodGhpcy5wYXRoKS5hdHRyKHtcbiAgICAgICAgICAgIHN0cm9rZTogc2EuY29sb3IsXG4gICAgICAgICAgICBcInN0cm9rZS1saW5lam9pblwiOiBcInJvdW5kXCIsXG4gICAgICAgICAgICBcInN0cm9rZS1saW5lY2FwXCI6IFwicm91bmRcIixcbiAgICAgICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6ICsoc2Eud2lkdGggLyBudW1fcGF0aHMgKiBpKS50b0ZpeGVkKDMpLFxuICAgICAgICAgICAgb3BhY2l0eTogKygoc2Eub3BhY2l0eSB8fCAwLjMpIC8gbnVtX3BhdGhzKS50b0ZpeGVkKDMpLFxuICAgICAgICAgICAgLy8gU2VlIG5vdGUgaW4gdGhpcy5zY2FsZSgpOiBJbiBSYXBoYWVsIHRoZSBzY2FsZSgpIG1ldGhvZFxuICAgICAgICAgICAgLy8gaXMgZGVwcmVjYXRlZCBhbmQgcmVtb3ZlZCBhcyBvZiBSYXBoYWVsIDIuMCBhbmQgcmVwbGFjZWRcbiAgICAgICAgICAgIC8vIGJ5IHRoZSB0cmFuc2Zvcm0oKSBtZXRob2QuICBJdCBpcyBwcmVzZXJ2ZWQgaGVyZSBmb3JcbiAgICAgICAgICAgIC8vIHVzZXJzIHdpdGggZWFybGllciB2ZXJzaW9ucyBvZiBSYXBoYWVsLCBidXQgaGFzIG5vIGVmZmVjdFxuICAgICAgICAgICAgLy8gb24gdGhlIG91dHB1dCBTVkcgaW4gUmFwaGFlbCAyLjArLlxuICAgICAgICAgICAgdHJhbnNmb3JtOiB0aGlzLmF0dHJpYnV0ZXMudHJhbnNmb3JtLFxuICAgICAgICAgICAgc2NhbGU6IHRoaXMuYXR0cmlidXRlcy5zY2FsZVxuICAgICAgICAgIH0pKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIG91dDtcbiAgICB9LFxuXG4gICAgZmlsbDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgZWxlbSA9IHRoaXMucGFwZXIucGF0aCh0aGlzLnBhdGgpLlxuICAgICAgICBhdHRyKHRoaXMuYXR0cmlidXRlcykuXG4gICAgICAgIGF0dHIoXCJzdHJva2Utd2lkdGhcIiwgMCk7XG4gICAgICB0aGlzLmdsb3coZWxlbSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc3Ryb2tlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRoZSBmaXJzdCBsaW5lIG9mIGNvZGUgYmVsb3cgaXMsIHVuZm9ydHVuYXRlbHksIGEgYml0IG9mIGEgaGFjazpcbiAgICAgIC8vIFJhcGhhZWwncyB0cmFuc2Zvcm0oKSBzY2FsaW5nIGRvZXMgbm90IHNjYWxlIHRoZSBzdHJva2Utd2lkdGgsIHNvXG4gICAgICAvLyBpbiBvcmRlciB0byBzY2FsZSBhIHN0cm9rZSwgd2UgaGF2ZSB0byBtYW51YWxseSBzY2FsZSB0aGVcbiAgICAgIC8vIHN0cm9rZS13aWR0aC5cbiAgICAgIC8vXG4gICAgICAvLyBUaGlzIHdvcmtzIHdlbGwgc28gbG9uZyBhcyB0aGUgWCAmIFkgc3RhdGVzIGZvciB0aGlzLnNjYWxlKCkgYXJlXG4gICAgICAvLyByZWxhdGl2ZWx5IHNpbWlsYXIuICBIb3dldmVyLCBpZiB0aGV5IGFyZSB2ZXJ5IGRpZmZlcmVudCwgd2VcbiAgICAgIC8vIHdvdWxkIGV4cGVjdCBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBsaW5lcyB0byBoYXZlIGRpZmZlcmVudFxuICAgICAgLy8gc3Ryb2tlLXdpZHRocy5cbiAgICAgIC8vXG4gICAgICAvLyBJbiB0aGUgZnV0dXJlLCBpZiB3ZSB3YW50IHRvIHN1cHBvcnQgdmVyeSBkaXZlcmdlbnQgdmFsdWVzIGZvclxuICAgICAgLy8gaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgc2NhbGluZywgd2UgbWF5IHdhbnQgdG8gY29uc2lkZXJcbiAgICAgIC8vIGltcGxlbWVudGluZyBTVkcgc2NhbGluZyB3aXRoIHByb3BlcnRpZXMgb2YgdGhlIFNWRyB2aWV3Qm94ICZcbiAgICAgIC8vIHZpZXdQb3J0IGFuZCByZW1vdmluZyBpdCBlbnRpcmVseSBmcm9tIHRoZSBFbGVtZW50LmF0dHIoKSBjYWxscy5cbiAgICAgIC8vIFRoaXMgd291bGQgbW9yZSBjbG9zZWx5IHBhcmFsbGVsIHRoZSBhcHByb2FjaCB0YWtlbiBpblxuICAgICAgLy8gY2FudmFzY29udGV4dC5qcyBhcyB3ZWxsLlxuXG4gICAgICB2YXIgc3Ryb2tlV2lkdGggPSB0aGlzLmxpbmVXaWR0aCAqICh0aGlzLnN0YXRlLnNjYWxlLnggKyB0aGlzLnN0YXRlLnNjYWxlLnkpLzI7XG4gICAgICB2YXIgZWxlbSA9IHRoaXMucGFwZXIucGF0aCh0aGlzLnBhdGgpLlxuICAgICAgICBhdHRyKHRoaXMuYXR0cmlidXRlcykuXG4gICAgICAgIGF0dHIoXCJmaWxsXCIsIFwibm9uZVwiKS5cbiAgICAgICAgYXR0cihcInN0cm9rZS13aWR0aFwiLCBzdHJva2VXaWR0aCk7XG4gICAgICB0aGlzLmdsb3coZWxlbSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgY2xvc2VQYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHRoaXMucGF0aCArPSBcIlpcIjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBtZWFzdXJlVGV4dDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgdmFyIHR4dCA9IHRoaXMucGFwZXIudGV4dCgwLCAwLCB0ZXh0KS5cbiAgICAgICAgYXR0cih0aGlzLmF0dHJpYnV0ZXMpLlxuICAgICAgICBhdHRyKFwiZmlsbFwiLCBcIm5vbmVcIikuXG4gICAgICAgIGF0dHIoXCJzdHJva2VcIiwgXCJub25lXCIpO1xuICAgICAgdmFyIGJvdW5kcyA9IHR4dC5nZXRCQm94KCk7XG4gICAgICB0eHQucmVtb3ZlKCk7XG5cbiAgICAgIHJldHVybiB7XG4gICAgICAgIHdpZHRoOiBib3VuZHMud2lkdGgsXG4gICAgICAgIGhlaWdodDogYm91bmRzLmhlaWdodFxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgZmlsbFRleHQ6IGZ1bmN0aW9uKHRleHQsIHgsIHkpIHtcbiAgICAgIHRoaXMucGFwZXIudGV4dCh4ICsgKHRoaXMubWVhc3VyZVRleHQodGV4dCkud2lkdGggLyAyKSxcbiAgICAgICAgICAoeSAtICh0aGlzLnN0YXRlLmZvbnRfc2l6ZSAvICgyLjI1ICogdGhpcy5zdGF0ZS5zY2FsZS55KSkpLCB0ZXh0KS5cbiAgICAgICAgYXR0cih0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNhdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gVE9ETyhtbXV0aGFubmEpOiBTdGF0ZSBuZWVkcyB0byBiZSBkZWVwLWNvcGllZC5cbiAgICAgIHRoaXMuc3RhdGVfc3RhY2sucHVzaCh7XG4gICAgICAgIHN0YXRlOiB7XG4gICAgICAgICAgZm9udF9mYW1pbHk6IHRoaXMuc3RhdGUuZm9udF9mYW1pbHlcbiAgICAgICAgfSxcbiAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgIGZvbnQ6IHRoaXMuYXR0cmlidXRlcy5mb250LFxuICAgICAgICAgIGZpbGw6IHRoaXMuYXR0cmlidXRlcy5maWxsLFxuICAgICAgICAgIHN0cm9rZTogdGhpcy5hdHRyaWJ1dGVzLnN0cm9rZSxcbiAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlzLmF0dHJpYnV0ZXNbXCJzdHJva2Utd2lkdGhcIl1cbiAgICAgICAgfSxcbiAgICAgICAgc2hhZG93X2F0dHJpYnV0ZXM6IHtcbiAgICAgICAgICB3aWR0aDogdGhpcy5zaGFkb3dfYXR0cmlidXRlcy53aWR0aCxcbiAgICAgICAgICBjb2xvcjogdGhpcy5zaGFkb3dfYXR0cmlidXRlcy5jb2xvclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZXN0b3JlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRPRE8oMHhmZSk6IFN0YXRlIG5lZWRzIHRvIGJlIGRlZXAtcmVzdG9yZWQuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlX3N0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5zdGF0ZS5mb250X2ZhbWlseSA9IHN0YXRlLnN0YXRlLmZvbnRfZmFtaWx5O1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzLmZvbnQgPSBzdGF0ZS5hdHRyaWJ1dGVzLmZvbnQ7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuZmlsbCA9IHN0YXRlLmF0dHJpYnV0ZXMuZmlsbDtcbiAgICAgIHRoaXMuYXR0cmlidXRlcy5zdHJva2UgPSBzdGF0ZS5hdHRyaWJ1dGVzLnN0cm9rZTtcbiAgICAgIHRoaXMuYXR0cmlidXRlc1tcInN0cm9rZS13aWR0aFwiXSA9IHN0YXRlLmF0dHJpYnV0ZXNbXCJzdHJva2Utd2lkdGhcIl07XG4gICAgICB0aGlzLnNoYWRvd19hdHRyaWJ1dGVzLndpZHRoID0gc3RhdGUuc2hhZG93X2F0dHJpYnV0ZXMud2lkdGg7XG4gICAgICB0aGlzLnNoYWRvd19hdHRyaWJ1dGVzLmNvbG9yID0gc3RhdGUuc2hhZG93X2F0dHJpYnV0ZXMuY29sb3I7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFJhcGhhZWxDb250ZXh0O1xufSgpKTtcblxuLy8gVmV4IEZsb3dcbi8vIE1vaGl0IE11dGhhbm5hIDxtb2hpdEBtdXRoYW5uYS5jb20+XG4vL1xuLy8gQSByZW5kZXJpbmcgY29udGV4dCBmb3IgU1ZHLlxuLy9cbi8vIENvcHlyaWdodCBNb2hpdCBNdXRoYW5uYSAyMDE1XG4vLyBAYXV0aG9yIEdyZWdvcnkgUmlzdG93ICgyMDE1KVxuXG4vKiogQGNvbnN0cnVjdG9yICovXG5WZXguRmxvdy5TVkdDb250ZXh0ID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBTVkdDb250ZXh0KGVsZW1lbnQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChlbGVtZW50KTtcbiAgfVxuXG4gIC8vIFRoZSBtZWFzdXJlVGV4dENhY2hlIGlzIHVzZWQgaW4gSmF2YXNjcmlwdCBydW50aW1lcyB3aGVyZVxuICAvLyB0aGVyZSBpcyBubyBwcm9wZXIgRE9NIHN1cHBvcnQgZm9yIFNWRyBib3VuZGluZyBib3hlcy4gVGhpc1xuICAvLyBpcyBjdXJyZW50bHkgb25seSB1c2VmdWwgaW4gdGhlIE5vZGVKUyB2aXN1YWwgcmVncmVzc2lvbiB0ZXN0cy5cbiAgU1ZHQ29udGV4dC5tZWFzdXJlVGV4dENhY2hlID0ge307XG5cbiAgLy8gSWYgZW5hYmxlZCwgd2lsbCBzdGFydCBjb2xsZWN0aW5nIGFuZCBpbmRleGluZyBnZXRCQm94IGRhdGEgYnlcbiAgLy8gZm9udCBuYW1lLCBzaXplLCB3ZWlnaHQsIGFuZCBzdHlsZS4gVGhpcyBzaG91bGQgYmUgZGlzYWJsZWQgYnlcbiAgLy8gZGVmYXVsdCAob3IgeW91IHdpbGwgZmluZCB5b3Vyc2VsZiBzbG93bHkgbGVha2luZyBSQU0uKVxuICBTVkdDb250ZXh0LmNvbGxlY3RNZWFzdXJlbWVudHMgPSBmYWxzZTtcblxuICAvLyBJZiBlbmFibGVkLCB3aWxsIHdhcm4gaWYgdGhlcmUgYXJlIG5ldyBnZXRCQm94IHJlcXVlc3RzIHRoYXQgYXJlXG4gIC8vIG5vdCBpbiB0aGUgY2FjaGUuIFRoaXMgaXMgZW5hYmxlZCBpbiB0aGUgVmV4RmxvdyB0ZXN0cywgYW5kIGlmIHlvdVxuICAvLyBzZWUgYSB3YXJuaW5nIG9uIHRoZSBjb25zb2xlLCB5b3Ugd2lsbCBuZWVkIHRvIGVuYWJsZSBjb2xsZWN0TWVhc3VyZW1lbnRzXG4gIC8vIGFib3ZlLCB0aGVuIHVwZGF0ZSBtZWFzdXJlVGV4dENhY2hlIHdpdGggdGhlIG5ldyB2YWx1ZXMuIFNlZVxuICAvLyB0ZXN0cy9tZWFzdXJlX3RleHRfY2FjaGUuanMgZm9yIGluc3RydWN0aW9ucyBvbiBob3cgdG8gZG8gdGhpcy5cbiAgU1ZHQ29udGV4dC52YWxpZGF0ZU1lYXN1cmVtZW50ID0gZmFsc2U7XG5cbiAgU1ZHQ29udGV4dC5hZGRQcmVmaXggPSBWZXguUHJlZml4O1xuXG4gIFNWR0NvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGVsZW1lbnQpIHtcbiAgICAgIC8vIGVsZW1lbnQgaXMgdGhlIHBhcmVudCBET00gb2JqZWN0XG4gICAgICB0aGlzLmVsZW1lbnQgPSBlbGVtZW50O1xuICAgICAgLy8gQ3JlYXRlIHRoZSBTVkcgaW4gdGhlIFNWRyBuYW1lc3BhY2U6XG4gICAgICB0aGlzLnN2Z05TID0gXCJodHRwOi8vd3d3LnczLm9yZy8yMDAwL3N2Z1wiO1xuICAgICAgdmFyIHN2ZyA9IHRoaXMuY3JlYXRlKFwic3ZnXCIpO1xuICAgICAgLy8gQWRkIGl0IHRvIHRoZSBjYW52YXM6XG4gICAgICB0aGlzLmVsZW1lbnQuYXBwZW5kQ2hpbGQoc3ZnKTtcblxuICAgICAgLy8gUG9pbnQgdG8gaXQ6XG4gICAgICB0aGlzLnN2ZyA9IHN2ZztcbiAgICAgIHRoaXMuZ3JvdXBzID0gW3RoaXMuc3ZnXTsgLy8gQ3JlYXRlIHRoZSBncm91cCBzdGFja1xuICAgICAgdGhpcy5wYXJlbnQgPSB0aGlzLnN2ZztcblxuICAgICAgdGhpcy5wYXRoID0gXCJcIjtcbiAgICAgIHRoaXMucGVuID0ge3g6IDAsIHk6IDB9O1xuICAgICAgdGhpcy5saW5lV2lkdGggPSAxLjA7XG4gICAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgICBzY2FsZTogeyB4OiAxLCB5OiAxIH0sXG4gICAgICAgIFwiZm9udC1mYW1pbHlcIjogXCJBcmlhbFwiLFxuICAgICAgICBcImZvbnQtc2l6ZVwiOiBcIjhwdFwiLFxuICAgICAgICBcImZvbnQtd2VpZ2h0XCI6IFwibm9ybWFsXCJcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuYXR0cmlidXRlcyA9IHtcbiAgICAgICAgXCJzdHJva2Utd2lkdGhcIjogMC4zLFxuICAgICAgICBcImZpbGxcIjogXCJibGFja1wiLFxuICAgICAgICBcInN0cm9rZVwiOiBcImJsYWNrXCIsXG4gICAgICAgIFwiZm9udC1mYW1pbHlcIjogXCJBcmlhbFwiLFxuICAgICAgICBcImZvbnQtc2l6ZVwiIDogXCIxMHB0XCIsXG4gICAgICAgIFwiZm9udC13ZWlnaHRcIiA6IFwibm9ybWFsXCIsXG4gICAgICAgIFwiZm9udC1zdHlsZVwiIDogXCJub3JtYWxcIlxuICAgICAgfTtcblxuICAgICAgdGhpcy5iYWNrZ3JvdW5kX2F0dHJpYnV0ZXMgPSB7XG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IDAsXG4gICAgICAgIFwiZmlsbFwiOiBcIndoaXRlXCIsXG4gICAgICAgIFwic3Ryb2tlXCI6IFwid2hpdGVcIixcbiAgICAgICAgXCJmb250LWZhbWlseVwiOiBcIkFyaWFsXCIsXG4gICAgICAgIFwiZm9udC1zaXplXCIgOiBcIjEwcHRcIixcbiAgICAgICAgXCJmb250LXdlaWdodFwiOiBcIm5vcm1hbFwiLFxuICAgICAgICBcImZvbnQtc3R5bGVcIjogXCJub3JtYWxcIlxuICAgICAgfTtcblxuICAgICAgdGhpcy5zaGFkb3dfYXR0cmlidXRlcyA9IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGNvbG9yOiBcImJsYWNrXCJcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuc3RhdGVfc3RhY2s9IFtdO1xuXG4gICAgICAvLyBUZXN0IGZvciBJbnRlcm5ldCBFeHBsb3JlclxuICAgICAgdGhpcy5pZVBvbHlmaWxsKCk7XG4gICAgfSxcblxuICAgIGNyZWF0ZTogZnVuY3Rpb24oc3ZnRWxlbWVudFR5cGUpIHtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlModGhpcy5zdmdOUywgc3ZnRWxlbWVudFR5cGUpO1xuICAgIH0sXG5cbiAgICAvLyBBbGxvdyBncm91cGluZyBlbGVtZW50cyBpbiBjb250YWluZXJzIGZvciBpbnRlcmFjdGl2aXR5LlxuICAgIG9wZW5Hcm91cDogZnVuY3Rpb24oY2xzLCBpZCwgYXR0cnMpIHtcbiAgICAgIHZhciBncm91cCA9IHRoaXMuY3JlYXRlKFwiZ1wiKTtcbiAgICAgIHRoaXMuZ3JvdXBzLnB1c2goZ3JvdXApO1xuICAgICAgdGhpcy5wYXJlbnQuYXBwZW5kQ2hpbGQoZ3JvdXApO1xuICAgICAgdGhpcy5wYXJlbnQgPSBncm91cDtcbiAgICAgIGlmIChjbHMpIGdyb3VwLnNldEF0dHJpYnV0ZShcImNsYXNzXCIsIFNWR0NvbnRleHQuYWRkUHJlZml4KGNscykpO1xuICAgICAgaWYgKGlkKSBncm91cC5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBTVkdDb250ZXh0LmFkZFByZWZpeChpZCkpO1xuXG4gICAgICBpZiAoYXR0cnMgJiYgYXR0cnMucG9pbnRlckJCb3gpIHtcbiAgICAgICAgZ3JvdXAuc2V0QXR0cmlidXRlKFwicG9pbnRlci1ldmVudHNcIiwgXCJib3VuZGluZy1ib3hcIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gZ3JvdXA7XG4gICAgfSxcblxuICAgIGNsb3NlR3JvdXA6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGdyb3VwID0gdGhpcy5ncm91cHMucG9wKCk7XG4gICAgICB0aGlzLnBhcmVudCA9IHRoaXMuZ3JvdXBzW3RoaXMuZ3JvdXBzLmxlbmd0aCAtIDFdO1xuICAgIH0sXG5cbiAgICBhZGQ6IGZ1bmN0aW9uKGVsZW0pIHtcbiAgICAgIHRoaXMucGFyZW50LmFwcGVuZENoaWxkKGVsZW0pO1xuICAgIH0sXG5cbiAgICAvLyBUZXN0cyBpZiB0aGUgYnJvd3NlciBpcyBJbnRlcm5ldCBFeHBsb3JlcjsgaWYgaXQgaXMsXG4gICAgLy8gd2UgZG8gc29tZSB0cmlja3MgdG8gaW1wcm92ZSB0ZXh0IGxheW91dC4gIFNlZSB0aGVcbiAgICAvLyBub3RlIGF0IGllTWVhc3VyZVRleHRGaXgoKSBmb3IgZGV0YWlscy5cbiAgICBpZVBvbHlmaWxsOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICh0eXBlb2YobmF2aWdhdG9yKSAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICB0aGlzLmllID0gKCAgL01TSUUgOS9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvTVNJRSAxMC9pLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvcnY6MTFcXC4wL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC9UcmlkZW50L2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSApO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICAvLyAjIyMgU3R5bGluZyAmIFN0YXRlIE1ldGhvZHM6XG5cbiAgICBzZXRGb250OiBmdW5jdGlvbihmYW1pbHksIHNpemUsIHdlaWdodCkge1xuICAgICAgLy8gVW5saWtlIGNhbnZhcywgaW4gU1ZHIGl0YWxpYyBpcyBoYW5kbGVkIGJ5IGZvbnQtc3R5bGUsXG4gICAgICAvLyBub3Qgd2VpZ2h0LiBTbzogd2Ugc2VhcmNoIHRoZSB3ZWlnaHQgYXJndW1lbnQgYW5kXG4gICAgICAvLyBhcHBseSBib2xkIGFuZCBpdGFsaWMgdG8gd2VpZ2h0IGFuZCBzdHlsZSByZXNwZWN0aXZlbHkuXG4gICAgICB2YXIgYm9sZCA9IGZhbHNlO1xuICAgICAgdmFyIGl0YWxpYyA9IGZhbHNlO1xuICAgICAgdmFyIHN0eWxlID0gXCJub3JtYWxcIjtcbiAgICAgIC8vIFdlaWdodCBtaWdodCBhbHNvIGJlIGEgbnVtYmVyICgyMDAsIDQwMCwgZXRjLi4uKSBzbyB3ZVxuICAgICAgLy8gdGVzdCBpdHMgdHlwZSB0byBiZSBzdXJlIHdlIGhhdmUgYWNjZXNzIHRvIFN0cmluZyBtZXRob2RzLlxuICAgICAgaWYoIHR5cGVvZiB3ZWlnaHQgPT0gXCJzdHJpbmdcIiApIHtcbiAgICAgICAgICAvLyBsb29rIGZvciBcIml0YWxpY1wiIGluIHRoZSB3ZWlnaHQ6XG4gICAgICAgICAgaWYod2VpZ2h0LmluZGV4T2YoXCJpdGFsaWNcIikgIT09IC0xKSB7XG4gICAgICAgICAgICB3ZWlnaHQgPSB3ZWlnaHQucmVwbGFjZSgvaXRhbGljL2csIFwiXCIpO1xuICAgICAgICAgICAgaXRhbGljID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gbG9vayBmb3IgXCJib2xkXCIgaW4gd2VpZ2h0XG4gICAgICAgICAgaWYod2VpZ2h0LmluZGV4T2YoXCJib2xkXCIpICE9PSAtMSkge1xuICAgICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0LnJlcGxhY2UoL2JvbGQvZywgXCJcIik7XG4gICAgICAgICAgICBib2xkID0gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgLy8gcmVtb3ZlIGFueSByZW1haW5pbmcgc3BhY2VzXG4gICAgICAgICAgd2VpZ2h0ID0gd2VpZ2h0LnJlcGxhY2UoLyAvZywgXCJcIik7XG4gICAgICB9XG4gICAgICB3ZWlnaHQgPSBib2xkID8gXCJib2xkXCIgOiB3ZWlnaHQ7XG4gICAgICB3ZWlnaHQgPSAodHlwZW9mIHdlaWdodCA9PT0gXCJ1bmRlZmluZWRcIiB8fCB3ZWlnaHQgPT09IFwiXCIpID8gXCJub3JtYWxcIiA6IHdlaWdodDtcblxuICAgICAgc3R5bGUgPSBpdGFsaWMgPyBcIml0YWxpY1wiIDogc3R5bGU7XG5cbiAgICAgIHZhciBmb250QXR0cmlidXRlcyA9IHtcbiAgICAgICAgXCJmb250LWZhbWlseVwiOiBmYW1pbHksXG4gICAgICAgIFwiZm9udC1zaXplXCI6IHNpemUgKyBcInB0XCIsXG4gICAgICAgIFwiZm9udC13ZWlnaHRcIjogd2VpZ2h0LFxuICAgICAgICBcImZvbnQtc3R5bGVcIiA6IHN0eWxlXG4gICAgICB9O1xuXG4gICAgICAvLyBTdG9yZSB0aGUgZm9udCBzaXplIHNvIHRoYXQgaWYgdGhlIGJyb3dzZXIgaXMgSW50ZXJuZXRcbiAgICAgIC8vIEV4cGxvcmVyIHdlIGNhbiBmaXggaXRzIGNhbGN1bGF0aW9ucyBvZiB0ZXh0IHdpZHRoLlxuICAgICAgdGhpcy5mb250U2l6ZSA9IE51bWJlcihzaXplKTtcblxuICAgICAgVmV4Lk1lcmdlKHRoaXMuYXR0cmlidXRlcywgZm9udEF0dHJpYnV0ZXMpO1xuICAgICAgVmV4Lk1lcmdlKHRoaXMuc3RhdGUsIGZvbnRBdHRyaWJ1dGVzKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFJhd0ZvbnQ6IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICAgIGZvbnQ9Zm9udC50cmltKCk7XG4gICAgICAvLyBBc3N1bWVzIHNpemUgZmlyc3QsIHNwbGl0cyBvbiBzcGFjZSAtLSB3aGljaCBpcyBwcmVzZW50bHlcbiAgICAgIC8vIGhvdyBhbGwgZXhpc3RpbmcgbW9kdWxlcyBhcmUgY2FsbGluZyB0aGlzLlxuICAgICAgdmFyIGZvbnRBcnJheSA9IGZvbnQuc3BsaXQoXCIgXCIpO1xuXG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbXCJmb250LWZhbWlseVwiXSA9IGZvbnRBcnJheVsxXTtcbiAgICAgIHRoaXMuc3RhdGVbXCJmb250LWZhbWlseVwiXSA9IGZvbnRBcnJheVsxXTtcblxuICAgICAgdGhpcy5hdHRyaWJ1dGVzW1wiZm9udC1zaXplXCJdID0gZm9udEFycmF5WzBdO1xuICAgICAgdGhpcy5zdGF0ZVtcImZvbnQtc2l6ZVwiXSA9IGZvbnRBcnJheVswXTtcblxuICAgICAgLy8gU2F2ZXMgZm9udFNpemUgZm9yIElFIHBvbHlmaWxsXG4gICAgICB0aGlzLmZvbnRTaXplID0gTnVtYmVyKGZvbnRBcnJheVswXS5tYXRjaCgvXFxkKy8pKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRGaWxsU3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXMuZmlsbCA9IHN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldEJhY2tncm91bmRGaWxsU3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG4gICAgICB0aGlzLmJhY2tncm91bmRfYXR0cmlidXRlcy5maWxsID0gc3R5bGU7XG4gICAgICB0aGlzLmJhY2tncm91bmRfYXR0cmlidXRlcy5zdHJva2UgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTdHJva2VTdHlsZTogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHRoaXMuYXR0cmlidXRlcy5zdHJva2UgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3dDb2xvcjogZnVuY3Rpb24oc3R5bGUpIHtcbiAgICAgIHRoaXMuc2hhZG93X2F0dHJpYnV0ZXMuY29sb3IgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRTaGFkb3dCbHVyOiBmdW5jdGlvbihibHVyKSB7XG4gICAgICB0aGlzLnNoYWRvd19hdHRyaWJ1dGVzLndpZHRoID0gYmx1cjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRMaW5lV2lkdGg6IGZ1bmN0aW9uKHdpZHRoKSB7XG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbXCJzdHJva2Utd2lkdGhcIl0gPSB3aWR0aDtcbiAgICAgIHRoaXMubGluZVdpZHRoID0gd2lkdGg7XG4gICAgfSxcblxuICAgIHNldExpbmVEYXNoOiBmdW5jdGlvbihsaW5lRGFzaCkge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW1wic3Ryb2tlLWxpbmVkYXNoXCJdID0gbGluZURhc2g7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0TGluZUNhcDogZnVuY3Rpb24obGluZUNhcCkge1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW1wic3Ryb2tlLWxpbmVjYXBcIl0gPSBsaW5lQ2FwO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vICMjIyBTaXppbmcgJiBTY2FsaW5nIE1ldGhvZHM6XG5cbiAgICAvLyBUT0RPIChHQ1IpOiBTZWUgbm90ZSBhdCBzY2FsZSgpIC0tIHNlcGVyYXRlIG91ciBpbnRlcm5hbFxuICAgIC8vIGNvbmNlcHRpb24gb2YgcGl4ZWwtYmFzZWQgd2lkdGgvaGVpZ2h0IGZyb20gdGhlIHN0eWxlLndpZHRoXG4gICAgLy8gYW5kIHN0eWxlLmhlaWdodCBwcm9wZXJ0aWVzIGV2ZW50dWFsbHkgdG8gYWxsb3cgdXNlcnMgdG9cbiAgICAvLyBhcHBseSByZXNwb25zaXZlIHNpemluZyBhdHRyaWJ1dGVzIHRvIHRoZSBTVkcuXG4gICAgcmVzaXplOiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgICB0aGlzLndpZHRoID0gd2lkdGg7XG4gICAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgICAgIHRoaXMuZWxlbWVudC5zdHlsZS53aWR0aCA9IHdpZHRoO1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgICAgIHdpZHRoIDogd2lkdGgsXG4gICAgICAgIGhlaWdodCA6IGhlaWdodFxuICAgICAgfTtcbiAgICAgIHRoaXMuYXBwbHlBdHRyaWJ1dGVzKHRoaXMuc3ZnLCBhdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgLy8gdXNlcyB2aWV3Qm94IHRvIHNjYWxlXG4gICAgICAvLyBUT0RPIChHQ1IpOiB3ZSBtYXkgYXQgc29tZSBwb2ludCB3YW50IHRvIGRpc3Rpbmd1aXNoIHRoZVxuICAgICAgLy8gc3R5bGUud2lkdGggLyBzdHlsZS5oZWlnaHQgcHJvcGVydGllcyB0aGF0IGFyZSBhcHBsaWVkIHRvXG4gICAgICAvLyB0aGUgU1ZHIG9iamVjdCBmcm9tIG91ciBpbnRlcm5hbCBjb25jZXB0aW9uIG9mIHRoZSBTVkdcbiAgICAgIC8vIHdpZHRoL2hlaWdodC4gIFRoaXMgd291bGQgYWxsb3cgdXMgdG8gY3JlYXRlIGF1dG9tYXRpY2FsbHlcbiAgICAgIC8vIHNjYWxpbmcgU1ZHJ3MgdGhhdCBmaWxsZWQgdGhlaXIgY29udGFpbmVycywgZm9yIGluc3RhbmNlLlxuICAgICAgLy9cbiAgICAgIC8vIEFzIHRoaXMgaXNuJ3QgaW1wbGVtZW50ZWQgaW4gQ2FudmFzIG9yIFJhcGhhZWwgY29udGV4dHMsXG4gICAgICAvLyBJJ3ZlIGxlZnQgYXMgaXMgZm9yIG5vdywgYnV0IGluIHVzaW5nIHRoZSB2aWV3Qm94IHRvXG4gICAgICAvLyBoYW5kbGUgaW50ZXJuYWwgc2NhbGluZywgYW0gdHJ5aW5nIHRvIG1ha2UgaXQgcG9zc2libGVcbiAgICAgIC8vIGZvciB1cyB0byBldmVudHVhbGx5IG1vdmUgaW4gdGhhdCBkaXJlY3Rpb24uXG5cbiAgICAgIHRoaXMuc3RhdGUuc2NhbGUgPSB7IHg6IHgsIHk6IHkgfTtcbiAgICAgIHZhciB2aXNpYmxlV2lkdGggPSB0aGlzLndpZHRoIC8geDtcbiAgICAgIHZhciB2aXNpYmxlSGVpZ2h0ID0gdGhpcy5oZWlnaHQgLyB5O1xuICAgICAgdGhpcy5zZXRWaWV3Qm94KDAsMCwgdmlzaWJsZVdpZHRoLCB2aXNpYmxlSGVpZ2h0KTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFZpZXdCb3g6IGZ1bmN0aW9uKHhNaW4sIHlNaW4sIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIC8vIE92ZXJyaWRlIGZvciBcInggeSB3IGhcIiBzdHlsZTpcbiAgICAgIGlmKGFyZ3VtZW50cy5sZW5ndGggPT0gMSkgdGhpcy5zdmcuc2V0QXR0cmlidXRlKFwidmlld0JveFwiLCB2aWV3Qm94KTtcbiAgICAgIGVsc2Uge1xuICAgICAgICB2YXIgdmlld0JveFN0cmluZyA9IHhNaW4gKyBcIiBcIiArIHlNaW4gKyBcIiBcIiArIHdpZHRoICsgXCIgXCIgKyBoZWlnaHQ7XG4gICAgICAgIHRoaXMuc3ZnLnNldEF0dHJpYnV0ZShcInZpZXdCb3hcIiwgdmlld0JveFN0cmluZyk7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vICMjIyBEcmF3aW5nIGhlbHBlciBtZXRob2RzOlxuXG4gICAgYXBwbHlBdHRyaWJ1dGVzOiBmdW5jdGlvbihlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gICAgICBmb3IodmFyIHByb3BlcnR5TmFtZSBpbiBhdHRyaWJ1dGVzKSB7XG4gICAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgcHJvcGVydHlOYW1lLCBhdHRyaWJ1dGVzW3Byb3BlcnR5TmFtZV0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGVsZW1lbnQ7XG4gICAgfSxcblxuICAgIGZsaXBSZWN0YW5nbGU6IGZ1bmN0aW9uKGFyZ3MpIHtcbiAgICAgIC8vIEF2b2lkIGludmFsaWQgbmVnYXRpdmUgaGVpZ2h0IGF0dHJpYnV0ZXMgYnlcbiAgICAgIC8vIGZsaXBwaW5nIGEgcmVjdGFuZ2xlIHcvIG5lZ2F0aXZlIGhlaWdodCBvbiBpdHMgaGVhZC5cbiAgICAgIC8vIFNpbmNlIGFyZ3MgaXMgdGhlIGFjdHVhbCBhcmd1bWVudHMgb2JqZWN0IGZyb21cbiAgICAgIC8vIG9uZSBvZiB0aGUgcmVjdGFuZ2xlIGZ1bmN0aW9ucywgd2UgZG9uJ3QgbmVlZCB0b1xuICAgICAgLy8gcmV0dXJuIGl0LlxuXG4gICAgICAvLyBBZGQgbmVnYXRpdmUgaGVpZ2h0IHRvIFlcbiAgICAgIGFyZ3NbMV0gKz0gYXJnc1szXTtcbiAgICAgIC8vIE1ha2UgdGhlIG5lZ2F0aXZlIGhlaWdodCBwb3NpdGl2ZS5cbiAgICAgIGFyZ3NbM10gPSAtYXJnc1szXTtcbiAgICB9LFxuXG4gICAgLy8gIyMjIFNoYXBlICYgUGF0aCBNZXRob2RzOlxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2xlYXIgdGhlIFNWRyBieSByZW1vdmluZyBhbGwgaW5uZXIgY2hpbGRyZW4uXG5cbiAgICAgIC8vIChUaGlzIGFwcHJvYWNoIGlzIHVzdWFsbHkgc2xpZ2h0bHkgbW9yZSBlZmZpY2llbnRcbiAgICAgIC8vIHRoYW4gcmVtb3ZpbmcgdGhlIG9sZCBTVkcgJiBhZGRpbmcgYSBuZXcgb25lIHRvXG4gICAgICAvLyB0aGUgY29udGFpbmVyIGVsZW1lbnQsIHNpbmNlIGl0IGRvZXMgbm90IGNhdXNlIHRoZVxuICAgICAgLy8gY29udGFpbmVyIHRvIHJlc2l6ZSB0d2ljZS4gIEFsc28sIHRoZSByZXNpemVcbiAgICAgIC8vIHRyaWdnZXJlZCBieSByZW1vdmluZyB0aGUgZW50aXJlIFNWRyBjYW4gdHJpZ2dlclxuICAgICAgLy8gYSB0b3VjaGNhbmNlbCBldmVudCB3aGVuIHRoZSBlbGVtZW50IHJlc2l6ZXMgYXdheVxuICAgICAgLy8gZnJvbSBhIHRvdWNoIHBvaW50LilcblxuICAgICAgd2hpbGUgKHRoaXMuc3ZnLmxhc3RDaGlsZCkge1xuICAgICAgICB0aGlzLnN2Zy5yZW1vdmVDaGlsZCh0aGlzLnN2Zy5sYXN0Q2hpbGQpO1xuICAgICAgfVxuXG4gICAgICAvLyBSZXBsYWNlIHRoZSB2aWV3Ym94IGF0dHJpYnV0ZSB3ZSBqdXN0IHJlbW92ZWQ6XG4gICAgICB0aGlzLnNjYWxlKHRoaXMuc3RhdGUuc2NhbGUueCwgdGhpcy5zdGF0ZS5zY2FsZS55KTtcbiAgICB9LFxuXG4gICAgLy8gIyMgUmVjdGFuZ2xlczpcblxuICAgIHJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQsIGF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vIEF2b2lkIGludmFsaWQgbmVnYXRpdmUgaGVpZ2h0IGF0dHJpYnMgYnlcbiAgICAgIC8vIGZsaXBwaW5nIHRoZSByZWN0YW5nbGUgb24gaXRzIGhlYWQ6XG4gICAgICBpZiAoaGVpZ2h0IDwgMCkgdGhpcy5mbGlwUmVjdGFuZ2xlKGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIENyZWF0ZSB0aGUgcmVjdCAmIHN0eWxlIGl0OlxuICAgICAgdmFyIHJlY3QgPSB0aGlzLmNyZWF0ZShcInJlY3RcIik7XG4gICAgICBpZih0eXBlb2YgYXR0cmlidXRlcyA9PT0gXCJ1bmRlZmluZWRcIikgYXR0cmlidXRlcyA9IHtcbiAgICAgICAgZmlsbDogXCJub25lXCIsXG4gICAgICAgIFwic3Ryb2tlLXdpZHRoXCI6IHRoaXMubGluZVdpZHRoLFxuICAgICAgICBzdHJva2U6IFwiYmxhY2tcIlxuICAgICAgfTtcbiAgICAgIFZleC5NZXJnZShhdHRyaWJ1dGVzLCB7XG4gICAgICAgIHg6IHgsXG4gICAgICAgIHk6IHksXG4gICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBoZWlnaHRcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLmFwcGx5QXR0cmlidXRlcyhyZWN0LCBhdHRyaWJ1dGVzKTtcblxuICAgICAgdGhpcy5hZGQocmVjdCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZmlsbFJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIGlmKGhlaWdodCA8IDApIHRoaXMuZmxpcFJlY3RhbmdsZShhcmd1bWVudHMpO1xuXG4gICAgICB0aGlzLnJlY3QoeCwgeSwgd2lkdGggLSAwLjUsIGhlaWdodCAtIDAuNSwgdGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBjbGVhclJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIC8vIFRPRE8oR0NSKTogSW1wcm92ZSBpbXBsZW1lbnRhdGlvbiBvZiB0aGlzLi4uXG4gICAgICAvLyBDdXJyZW50bHkgaXQgZHJhd3MgYSBib3ggb2YgdGhlIGJhY2tncm91bmQgY29sb3IsIHJhdGhlclxuICAgICAgLy8gdGhhbiBjcmVhdGluZyBhbHBoYSB0aHJvdWdoIGxvd2VyIHotbGV2ZWxzLlxuICAgICAgLy9cbiAgICAgIC8vIFNlZSB0aGUgaW1wbGVtZW50YXRpb24gb2YgdGhpcyBpbiBTVkdLaXQ6XG4gICAgICAvLyBodHRwOi8vc291cmNlZm9yZ2UubmV0L3Byb2plY3RzL3N2Z2tpdC9cbiAgICAgIC8vIGFzIGEgc3RhcnRpbmcgcG9pbnQuXG4gICAgICAvL1xuICAgICAgLy8gQWRkaW5nIGEgbGFyZ2UgbnVtYmVyIG9mIHRyYW5zZm9ybSBwYXRocyAoYXMgd2Ugd291bGRcbiAgICAgIC8vIGhhdmUgdG8gZG8pIGNvdWxkIGJlIGEgcmVhbCBwZXJmb3JtYW5jZSBoaXQuICBTaW5jZVxuICAgICAgLy8gdGFiTm90ZSBzZWVtcyB0byBiZSB0aGUgb25seSBtb2R1bGUgdGhhdCBtYWtlcyB1c2Ugb2YgdGhpc1xuICAgICAgLy8gaXQgbWF5IGJlIHdvcnRoIGNyZWF0aW5nIGEgc2VwZXJhdGUgdGFiU3RhdmUgdGhhdCB3b3VsZFxuICAgICAgLy8gZHJhdyBsaW5lcyBhcm91bmQgbG9jYXRpb25zIG9mIHRhYmxhdHVyZSBmaW5nZXJpbmcuXG4gICAgICAvL1xuXG4gICAgICBpZiAoaGVpZ2h0IDwgMCkgdGhpcy5mbGlwUmVjdGFuZ2xlKGFyZ3VtZW50cyk7XG5cbiAgICAgIHRoaXMucmVjdCh4LCB5LCB3aWR0aCAtIDAuNSwgaGVpZ2h0IC0gMC41LCB0aGlzLmJhY2tncm91bmRfYXR0cmlidXRlcyk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gIyMgUGF0aHM6XG5cbiAgICBiZWdpblBhdGg6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy5wYXRoID0gXCJcIjtcbiAgICAgIHRoaXMucGVuLnggPSAwO1xuICAgICAgdGhpcy5wZW4ueSA9IDA7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgbW92ZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJNXCIgKyB4ICsgXCIgXCIgKyB5O1xuICAgICAgdGhpcy5wZW4ueCA9IHg7XG4gICAgICB0aGlzLnBlbi55ID0geTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBsaW5lVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHRoaXMucGF0aCArPSBcIkxcIiArIHggKyBcIiBcIiArIHk7XG4gICAgICB0aGlzLnBlbi54ID0geDtcbiAgICAgIHRoaXMucGVuLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJDXCIgK1xuICAgICAgICB4MSArIFwiIFwiICtcbiAgICAgICAgeTEgKyBcIixcIiArXG4gICAgICAgIHgyICsgXCIgXCIgK1xuICAgICAgICB5MiArIFwiLFwiICtcbiAgICAgICAgeCArIFwiIFwiICtcbiAgICAgICAgeTtcbiAgICAgIHRoaXMucGVuLnggPSB4O1xuICAgICAgdGhpcy5wZW4ueSA9IHk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4LCB5KSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJRXCIgK1xuICAgICAgICB4MSArIFwiIFwiICtcbiAgICAgICAgeTEgKyBcIixcIiArXG4gICAgICAgIHggKyBcIiBcIiArXG4gICAgICAgIHk7XG4gICAgICB0aGlzLnBlbi54ID0geDtcbiAgICAgIHRoaXMucGVuLnkgPSB5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFRoaXMgaXMgYW4gYXR0ZW1wdCAoaGFjaykgdG8gc2ltdWxhdGUgdGhlIEhUTUw1IGNhbnZhc1xuICAgIC8vIGFyYyBtZXRob2QuXG4gICAgYXJjOiBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpQ2xvY2t3aXNlKSB7XG4gICAgICBmdW5jdGlvbiBub3JtYWxpemVBbmdsZShhbmdsZSkge1xuICAgICAgICB3aGlsZSAoYW5nbGUgPCAwKSB7XG4gICAgICAgICAgYW5nbGUgKz0gTWF0aC5QSSAqIDI7XG4gICAgICAgIH1cblxuICAgICAgICB3aGlsZSAoYW5nbGUgPiBNYXRoLlBJICogMikge1xuICAgICAgICAgIGFuZ2xlIC09IE1hdGguUEkgKiAyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhbmdsZTtcbiAgICAgIH1cblxuICAgICAgc3RhcnRBbmdsZSA9IG5vcm1hbGl6ZUFuZ2xlKHN0YXJ0QW5nbGUpO1xuICAgICAgZW5kQW5nbGUgPSBub3JtYWxpemVBbmdsZShlbmRBbmdsZSk7XG5cbiAgICAgIGlmIChzdGFydEFuZ2xlID4gZW5kQW5nbGUpIHtcbiAgICAgICAgICB2YXIgdG1wID0gc3RhcnRBbmdsZTtcbiAgICAgICAgICBzdGFydEFuZ2xlID0gZW5kQW5nbGU7XG4gICAgICAgICAgZW5kQW5nbGUgPSB0bXA7XG4gICAgICAgICAgYW50aUNsb2Nrd2lzZSA9ICFhbnRpQ2xvY2t3aXNlO1xuICAgICAgfVxuXG4gICAgICB2YXIgZGVsdGEgPSBlbmRBbmdsZSAtIHN0YXJ0QW5nbGU7XG5cbiAgICAgIGlmIChkZWx0YSA+IE1hdGguUEkpIHtcbiAgICAgICAgICB0aGlzLmFyY0hlbHBlcih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIHN0YXJ0QW5nbGUgKyBkZWx0YSAvIDIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgYW50aUNsb2Nrd2lzZSk7XG4gICAgICAgICAgdGhpcy5hcmNIZWxwZXIoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlICsgZGVsdGEgLyAyLCBlbmRBbmdsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICBhbnRpQ2xvY2t3aXNlKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICAgIHRoaXMuYXJjSGVscGVyKHgsIHksIHJhZGl1cywgc3RhcnRBbmdsZSwgZW5kQW5nbGUsIGFudGlDbG9ja3dpc2UpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGFyY0hlbHBlcjogZnVuY3Rpb24oeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aUNsb2Nrd2lzZSkge1xuICAgICAgdmFyIHgxID0geCArIHJhZGl1cyAqIE1hdGguY29zKHN0YXJ0QW5nbGUpO1xuICAgICAgdmFyIHkxID0geSArIHJhZGl1cyAqIE1hdGguc2luKHN0YXJ0QW5nbGUpO1xuXG4gICAgICB2YXIgeDIgPSB4ICsgcmFkaXVzICogTWF0aC5jb3MoZW5kQW5nbGUpO1xuICAgICAgdmFyIHkyID0geSArIHJhZGl1cyAqIE1hdGguc2luKGVuZEFuZ2xlKTtcblxuICAgICAgdmFyIGxhcmdlQXJjRmxhZyA9IDA7XG4gICAgICB2YXIgc3dlZXBGbGFnID0gMDtcbiAgICAgIGlmIChhbnRpQ2xvY2t3aXNlKSB7XG4gICAgICAgIHN3ZWVwRmxhZyA9IDE7XG4gICAgICAgIGlmIChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPCBNYXRoLlBJKVxuICAgICAgICAgIGxhcmdlQXJjRmxhZyA9IDE7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChlbmRBbmdsZSAtIHN0YXJ0QW5nbGUgPiBNYXRoLlBJKSB7XG4gICAgICAgICAgbGFyZ2VBcmNGbGFnID0gMTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5wYXRoICs9IFwiTVwiICsgeDEgKyBcIiBcIiArIHkxICsgXCIgXCIgKyBcIkFcIiArXG4gICAgICAgIHJhZGl1cyArIFwiIFwiICsgcmFkaXVzICsgXCIgXCIgKyBcIjAgXCIgKyBsYXJnZUFyY0ZsYWcgKyBcIiBcIiArIHN3ZWVwRmxhZyArIFwiIFwiICtcbiAgICAgICAgeDIgKyBcIiBcIiArIHkyICsgXCJNXCIgKyB0aGlzLnBlbi54ICsgXCIgXCIgKyB0aGlzLnBlbi55O1xuXG4gICAgfSxcblxuICAgIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLnBhdGggKz0gXCJaXCI7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBBZGFwdGVkIGZyb20gdGhlIHNvdXJjZSBmb3IgUmFwaGFlbCdzIEVsZW1lbnQuZ2xvd1xuICAgIGdsb3c6IGZ1bmN0aW9uKCkge1xuICAgICAgLy8gQ2FsY3VsYXRlIHRoZSB3aWR0aCAmIHBhdGhzIG9mIHRoZSBnbG93OlxuICAgICAgaWYgKHRoaXMuc2hhZG93X2F0dHJpYnV0ZXMud2lkdGggPiAwKSB7XG4gICAgICAgIHZhciBzYSA9IHRoaXMuc2hhZG93X2F0dHJpYnV0ZXM7XG4gICAgICAgIHZhciBudW1fcGF0aHMgPSBzYS53aWR0aCAvIDI7XG4gICAgICAgIC8vIFN0cm9rZSBhdCB2YXJ5aW5nIHdpZHRocyB0byBjcmVhdGUgZWZmZWN0IG9mIGdhdXNzaWFuIGJsdXI6XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDw9IG51bV9wYXRoczsgaSsrKSB7XG4gICAgICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7XG4gICAgICAgICAgICBzdHJva2U6IHNhLmNvbG9yLFxuICAgICAgICAgICAgXCJzdHJva2UtbGluZWpvaW5cIjogXCJyb3VuZFwiLFxuICAgICAgICAgICAgXCJzdHJva2UtbGluZWNhcFwiOiBcInJvdW5kXCIsXG4gICAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiArKChzYS53aWR0aCAqMC40KSAvIG51bV9wYXRocyAqIGkpLnRvRml4ZWQoMyksXG4gICAgICAgICAgICBvcGFjaXR5OiArKChzYS5vcGFjaXR5IHx8IDAuMykgLyBudW1fcGF0aHMpLnRvRml4ZWQoMyksXG4gICAgICAgICAgfTtcblxuICAgICAgICAgIHZhciBwYXRoID0gdGhpcy5jcmVhdGUoXCJwYXRoXCIpO1xuICAgICAgICAgIGF0dHJpYnV0ZXMuZCA9IHRoaXMucGF0aDtcbiAgICAgICAgICB0aGlzLmFwcGx5QXR0cmlidXRlcyhwYXRoLCBhdHRyaWJ1dGVzKTtcbiAgICAgICAgICB0aGlzLmFkZChwYXRoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGZpbGw6IGZ1bmN0aW9uKGF0dHJpYnV0ZXMpIHtcbiAgICAgIC8vIElmIG91ciBjdXJyZW50IHBhdGggaXMgc2V0IHRvIGdsb3csIG1ha2UgaXQgZ2xvd1xuICAgICAgdGhpcy5nbG93KCk7XG5cbiAgICAgIHZhciBwYXRoID0gdGhpcy5jcmVhdGUoXCJwYXRoXCIpO1xuICAgICAgaWYodHlwZW9mIGF0dHJpYnV0ZXMgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgICBWZXguTWVyZ2UoYXR0cmlidXRlcywgdGhpcy5hdHRyaWJ1dGVzKTtcbiAgICAgICAgYXR0cmlidXRlcy5zdHJva2UgPSBcIm5vbmVcIjtcbiAgICAgIH1cblxuICAgICAgYXR0cmlidXRlcy5kID0gdGhpcy5wYXRoO1xuXG4gICAgICB0aGlzLmFwcGx5QXR0cmlidXRlcyhwYXRoLCBhdHRyaWJ1dGVzKTtcbiAgICAgIHRoaXMuYWRkKHBhdGgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHN0cm9rZTogZnVuY3Rpb24oKSB7XG4gICAgICAvLyBJZiBvdXIgY3VycmVudCBwYXRoIGlzIHNldCB0byBnbG93LCBtYWtlIGl0IGdsb3cuXG4gICAgICB0aGlzLmdsb3coKTtcblxuICAgICAgdmFyIHBhdGggPSB0aGlzLmNyZWF0ZShcInBhdGhcIik7XG4gICAgICB2YXIgYXR0cmlidXRlcyA9IHt9O1xuICAgICAgVmV4Lk1lcmdlKGF0dHJpYnV0ZXMsIHRoaXMuYXR0cmlidXRlcyk7XG4gICAgICBhdHRyaWJ1dGVzLmZpbGwgPSBcIm5vbmVcIjtcbiAgICAgIGF0dHJpYnV0ZXNbXCJzdHJva2Utd2lkdGhcIl0gPSB0aGlzLmxpbmVXaWR0aDtcbiAgICAgIGF0dHJpYnV0ZXMuZCA9IHRoaXMucGF0aDtcblxuICAgICAgdGhpcy5hcHBseUF0dHJpYnV0ZXMocGF0aCwgYXR0cmlidXRlcyk7XG4gICAgICB0aGlzLmFkZChwYXRoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyAjIyBUZXh0IE1ldGhvZHM6XG4gICAgbWVhc3VyZVRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHZhciBpbmRleCA9IHRleHQgKyB0aGlzLmF0dHJpYnV0ZXNbXCJmb250LXN0eWxlXCJdICsgdGhpcy5hdHRyaWJ1dGVzW1wiZm9udC1mYW1pbHlcIl0gK1xuICAgICAgICAgICAgICAgICAgdGhpcy5hdHRyaWJ1dGVzW1wiZm9udC13ZWlnaHRcIl0gKyB0aGlzLmF0dHJpYnV0ZXNbXCJmb250LXNpemVcIl07XG5cbiAgICAgIHZhciB0eHQgPSB0aGlzLmNyZWF0ZShcInRleHRcIik7XG4gICAgICBpZiAodHlwZW9mKHR4dC5nZXRCQm94KSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHR4dC50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgICAgIHRoaXMuYXBwbHlBdHRyaWJ1dGVzKHR4dCwgdGhpcy5hdHRyaWJ1dGVzKTtcblxuICAgICAgICAvLyBUZW1wb3JhcmlseSBhZGQgaXQgdG8gdGhlIGRvY3VtZW50IGZvciBtZWFzdXJlbWVudC5cbiAgICAgICAgdGhpcy5zdmcuYXBwZW5kQ2hpbGQodHh0KTtcblxuICAgICAgICB2YXIgYmJveCA9IHR4dC5nZXRCQm94KCk7XG4gICAgICAgIGlmKCB0aGlzLmllICYmXG4gICAgICAgICAgICB0ZXh0ICE9PSBcIlwiICYmXG4gICAgICAgICAgICB0aGlzLmF0dHJpYnV0ZXNbXCJmb250LXN0eWxlXCJdID09IFwiaXRhbGljXCIpIGJib3ggPSB0aGlzLmllTWVhc3VyZVRleHRGaXgoYmJveCwgdGV4dCk7XG4gICAgICAgIHRoaXMuc3ZnLnJlbW92ZUNoaWxkKHR4dCk7XG5cbiAgICAgICAgLy8gRm9yIHJ1bnRpbWVzIHRoYXQgZG8gbm90IGhhdmUgZnVsbCBzdXBwb3J0IG9mIGJvdW5kaW5nIGJveGVzLCBjb2xsZWN0XG4gICAgICAgIC8vIHNvbWUgZGF0YSB3aGljaCBjYW4gYmUgdXNlZCBsYXRlciB0byBleHRyYXBvbGF0ZSB0aGVtLlxuICAgICAgICBpZiAoU1ZHQ29udGV4dC5jb2xsZWN0TWVhc3VyZW1lbnRzKSB7XG4gICAgICAgICAgU1ZHQ29udGV4dC5tZWFzdXJlVGV4dENhY2hlW2luZGV4XSA9IHtcbiAgICAgICAgICAgIHg6IGJib3gueCxcbiAgICAgICAgICAgIHk6IGJib3gueSxcbiAgICAgICAgICAgIHdpZHRoOiBiYm94LndpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBiYm94LmhlaWdodFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFNWR0NvbnRleHQudmFsaWRhdGVNZWFzdXJlbWVudHMpIHtcbiAgICAgICAgICBpZiAoIShpbmRleCBpbiBTVkdDb250ZXh0Lm1lYXN1cmVUZXh0Q2FjaGUpKSB7XG4gICAgICAgICAgICBWZXguVyhcIm1lYXN1cmVUZXh0Q2FjaGUgaXMgc3RhbGUuIFBsZWFzZSB1cGRhdGUgdGVzdHMvbWVhc3VyZV90ZXh0X2NhY2hlLmpzOiBcIiwgaW5kZXgpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gYmJveDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIEluc2lkZSBOb2RlSlMgb3Igb3RoZXIgcnVudGltZXMgdGhhdCBkb24ndCBzdXBwb3J0IGdldEJCb3guIFRoaXNcbiAgICAgICAgLy8gaXMgY3VycmVudGx5IG9ubHkgdXNlZnVsIGZvciB0aGUgTm9kZUpTIHZpc3VhbCByZWdyZXNzaW9uIHRlc3RzLlxuICAgICAgICByZXR1cm4gU1ZHQ29udGV4dC5tZWFzdXJlVGV4dENhY2hlW2luZGV4XTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgaWVNZWFzdXJlVGV4dEZpeDogZnVuY3Rpb24oYmJveCwgdGV4dCkge1xuICAgIC8vIEludGVybmV0IEV4cGxvcmVyIG92ZXItcGFkcyB0ZXh0IGluIGl0YWxpY3MsXG4gICAgLy8gcmVzdWx0aW5nIGluIGdpYW50IHdpZHRoIGVzdGltYXRlcyBmb3IgbWVhc3VyZVRleHQuXG4gICAgLy8gVG8gZml4IHRoaXMsIHdlIHVzZSB0aGlzIGZvcm11bGEsIHRlc3RlZCBhZ2FpbnN0XG4gICAgLy8gaWUgMTE6XG4gICAgLy8gb3ZlcmVzdGltYXRlIChpbiBwaXhlbHMpID0gRm9udFNpemUoaW4gcHQpICogMS4xOTYgKyAxLjk2XG4gICAgLy8gQW5kIHRoZW4gc3VidHJhY3QgdGhlIG92ZXJlc3RpbWF0ZSBmcm9tIGNhbGN1bGF0ZWQgd2lkdGguXG5cbiAgICAgIHZhciBmb250U2l6ZSA9IE51bWJlcih0aGlzLmZvbnRTaXplKTtcbiAgICAgIHZhciBtID0gMS4xOTY7XG4gICAgICB2YXIgYiA9IDEuOTU5ODtcbiAgICAgIHZhciB3aWR0aENvcnJlY3Rpb24gPSAobSAqIGZvbnRTaXplKSArIGI7XG4gICAgICB2YXIgd2lkdGggPSBiYm94LndpZHRoIC0gd2lkdGhDb3JyZWN0aW9uO1xuICAgICAgdmFyIGhlaWdodCA9IGJib3guaGVpZ2h0IC0gMS41O1xuXG4gICAgICAvLyBHZXQgbm9uLXByb3RlY3RlZCBjb3B5OlxuICAgICAgdmFyIGJveCA9IHtcbiAgICAgICAgeCA6IGJib3gueCxcbiAgICAgICAgeSA6IGJib3gueSxcbiAgICAgICAgd2lkdGggOiB3aWR0aCxcbiAgICAgICAgaGVpZ2h0IDogaGVpZ2h0XG4gICAgICB9O1xuXG4gICAgICByZXR1cm4gYm94O1xuICAgIH0sXG5cbiAgICBmaWxsVGV4dDogZnVuY3Rpb24odGV4dCwgeCwgeSkge1xuICAgICAgdmFyIGF0dHJpYnV0ZXMgPSB7fTtcbiAgICAgIFZleC5NZXJnZShhdHRyaWJ1dGVzLCB0aGlzLmF0dHJpYnV0ZXMpO1xuICAgICAgYXR0cmlidXRlcy5zdHJva2UgPSBcIm5vbmVcIjtcbiAgICAgIGF0dHJpYnV0ZXMueCA9IHg7XG4gICAgICBhdHRyaWJ1dGVzLnkgPSB5O1xuXG4gICAgICB2YXIgdHh0ID0gdGhpcy5jcmVhdGUoXCJ0ZXh0XCIpO1xuICAgICAgdHh0LnRleHRDb250ZW50ID0gdGV4dDtcbiAgICAgIHRoaXMuYXBwbHlBdHRyaWJ1dGVzKHR4dCwgYXR0cmlidXRlcyk7XG4gICAgICB0aGlzLmFkZCh0eHQpO1xuICAgIH0sXG5cbiAgICBzYXZlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRPRE8obW11dGhhbm5hKTogU3RhdGUgbmVlZHMgdG8gYmUgZGVlcC1jb3BpZWQuXG4gICAgICB0aGlzLnN0YXRlX3N0YWNrLnB1c2goe1xuICAgICAgICBzdGF0ZToge1xuICAgICAgICAgIFwiZm9udC1mYW1pbHlcIjogdGhpcy5zdGF0ZVtcImZvbnQtZmFtaWx5XCJdLFxuICAgICAgICAgIFwiZm9udC13ZWlnaHRcIjogdGhpcy5zdGF0ZVtcImZvbnQtd2VpZ2h0XCJdLFxuICAgICAgICAgIFwiZm9udC1zdHlsZVwiOiB0aGlzLnN0YXRlW1wiZm9udC1zdHlsZVwiXSxcbiAgICAgICAgICBcImZvbnQtc2l6ZVwiOiB0aGlzLnN0YXRlW1wiZm9udC1zaXplXCJdXG4gICAgICAgIH0sXG4gICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICBcImZvbnQtZmFtaWx5XCI6IHRoaXMuYXR0cmlidXRlc1tcImZvbnQtZmFtaWx5XCJdLFxuICAgICAgICAgIFwiZm9udC13ZWlnaHRcIjogdGhpcy5hdHRyaWJ1dGVzW1wiZm9udC13ZWlnaHRcIl0sXG4gICAgICAgICAgXCJmb250LXN0eWxlXCI6IHRoaXMuYXR0cmlidXRlc1tcImZvbnQtc3R5bGVcIl0sXG4gICAgICAgICAgXCJmb250LXNpemVcIjogdGhpcy5hdHRyaWJ1dGVzW1wiZm9udC1zaXplXCJdLFxuICAgICAgICAgIGZpbGw6IHRoaXMuYXR0cmlidXRlcy5maWxsLFxuICAgICAgICAgIHN0cm9rZTogdGhpcy5hdHRyaWJ1dGVzLnN0cm9rZSxcbiAgICAgICAgICBcInN0cm9rZS13aWR0aFwiOiB0aGlzLmF0dHJpYnV0ZXNbXCJzdHJva2Utd2lkdGhcIl1cbiAgICAgICAgfSxcbiAgICAgICAgc2hhZG93X2F0dHJpYnV0ZXM6IHtcbiAgICAgICAgICB3aWR0aDogdGhpcy5zaGFkb3dfYXR0cmlidXRlcy53aWR0aCxcbiAgICAgICAgICBjb2xvcjogdGhpcy5zaGFkb3dfYXR0cmlidXRlcy5jb2xvclxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICByZXN0b3JlOiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIFRPRE8oMHhmZSk6IFN0YXRlIG5lZWRzIHRvIGJlIGRlZXAtcmVzdG9yZWQuXG4gICAgICB2YXIgc3RhdGUgPSB0aGlzLnN0YXRlX3N0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5zdGF0ZVtcImZvbnQtZmFtaWx5XCJdID0gc3RhdGUuc3RhdGVbXCJmb250LWZhbWlseVwiXTtcbiAgICAgIHRoaXMuc3RhdGVbXCJmb250LXdlaWdodFwiXSA9IHN0YXRlLnN0YXRlW1wiZm9udC13ZWlnaHRcIl07XG4gICAgICB0aGlzLnN0YXRlW1wiZm9udC1zdHlsZVwiXSA9IHN0YXRlLnN0YXRlW1wiZm9udC1zdHlsZVwiXTtcbiAgICAgIHRoaXMuc3RhdGVbXCJmb250LXNpemVcIl0gPSBzdGF0ZS5zdGF0ZVtcImZvbnQtc2l6ZVwiXTtcblxuICAgICAgdGhpcy5hdHRyaWJ1dGVzW1wiZm9udC1mYW1pbHlcIl0gPSBzdGF0ZS5hdHRyaWJ1dGVzW1wiZm9udC1mYW1pbHlcIl07XG4gICAgICB0aGlzLmF0dHJpYnV0ZXNbXCJmb250LXdlaWdodFwiXSA9IHN0YXRlLmF0dHJpYnV0ZXNbXCJmb250LXdlaWdodFwiXTtcbiAgICAgIHRoaXMuYXR0cmlidXRlc1tcImZvbnQtc3R5bGVcIl0gPSBzdGF0ZS5hdHRyaWJ1dGVzW1wiZm9udC1zdHlsZVwiXTtcbiAgICAgIHRoaXMuYXR0cmlidXRlc1tcImZvbnQtc2l6ZVwiXSA9IHN0YXRlLmF0dHJpYnV0ZXNbXCJmb250LXNpemVcIl07XG5cbiAgICAgIHRoaXMuYXR0cmlidXRlcy5maWxsID0gc3RhdGUuYXR0cmlidXRlcy5maWxsO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzLnN0cm9rZSA9IHN0YXRlLmF0dHJpYnV0ZXMuc3Ryb2tlO1xuICAgICAgdGhpcy5hdHRyaWJ1dGVzW1wic3Ryb2tlLXdpZHRoXCJdID0gc3RhdGUuYXR0cmlidXRlc1tcInN0cm9rZS13aWR0aFwiXTtcbiAgICAgIHRoaXMuc2hhZG93X2F0dHJpYnV0ZXMud2lkdGggPSBzdGF0ZS5zaGFkb3dfYXR0cmlidXRlcy53aWR0aDtcbiAgICAgIHRoaXMuc2hhZG93X2F0dHJpYnV0ZXMuY29sb3IgPSBzdGF0ZS5zaGFkb3dfYXR0cmlidXRlcy5jb2xvcjtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gU1ZHQ29udGV4dDtcbn0oKSk7XG5cbi8vIFZleCBGbG93XG4vLyBNb2hpdCBNdXRoYW5uYSA8bW9oaXRAbXV0aGFubmEuY29tPlxuLy9cbi8vIEEgcmVuZGVyaW5nIGNvbnRleHQgZm9yIHRoZSBSYXBoYWVsIGJhY2tlbmQuXG4vL1xuLy8gQ29weXJpZ2h0IE1vaGl0IENoZXBwdWRpcmEgMjAxMFxuXG4vKiogQGNvbnN0cnVjdG9yICovXG5WZXguRmxvdy5DYW52YXNDb250ZXh0ID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBDYW52YXNDb250ZXh0KGNvbnRleHQpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChjb250ZXh0KTtcbiAgfVxuXG4gIENhbnZhc0NvbnRleHQuV0lEVEggPSA2MDA7XG4gIENhbnZhc0NvbnRleHQuSEVJR0hUID0gNDAwO1xuXG4gIENhbnZhc0NvbnRleHQucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIC8vIFVzZSBhIG5hbWUgdGhhdCBpcyB1bmxpa2VseSB0byBjbGFzaCB3aXRoIGEgY2FudmFzIGNvbnRleHRcbiAgICAgIC8vIHByb3BlcnR5XG4gICAgICB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0ID0gY29udGV4dDtcbiAgICAgIGlmICghY29udGV4dC5jYW52YXMpIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSB7XG4gICAgICAgICAgd2lkdGg6IENhbnZhc0NvbnRleHQuV0lEVEgsXG4gICAgICAgICAgaGVpZ2h0OiBDYW52YXNDb250ZXh0LkhFSUdIVFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYW52YXMgPSBjb250ZXh0LmNhbnZhcztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgY2xlYXI6IGZ1bmN0aW9uKCkge1xuICAgICAgdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5jbGVhclJlY3QoMCwgMCwgdGhpcy5jYW52YXMud2lkdGgsIHRoaXMuY2FudmFzLmhlaWdodCk7XG4gICAgfSxcblxuICAgIC8vIENvbnRhaW5lcnMgbm90IGltcGxlbWVudGVkXG4gICAgb3Blbkdyb3VwOiBmdW5jdGlvbihjbHMsIGlkLCBhdHRycykge30sXG4gICAgY2xvc2VHcm91cDogZnVuY3Rpb24oKSB7fSxcbiAgICBhZGQ6IGZ1bmN0aW9uKGVsZW0pIHt9LFxuXG4gICAgc2V0Rm9udDogZnVuY3Rpb24oZmFtaWx5LCBzaXplLCB3ZWlnaHQpIHtcbiAgICAgIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuZm9udCA9ICh3ZWlnaHQgfHwgXCJcIikgKyBcIiBcIiArIHNpemUgKyBcInB0IFwiICsgZmFtaWx5O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFJhd0ZvbnQ6IGZ1bmN0aW9uKGZvbnQpIHtcbiAgICAgIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuZm9udCA9IGZvbnQ7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0RmlsbFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5maWxsU3R5bGUgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRCYWNrZ3JvdW5kRmlsbFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdGhpcy5iYWNrZ3JvdW5kX2ZpbGxTdHlsZSA9IHN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFN0cm9rZVN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5zdHJva2VTdHlsZSA9IHN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFNoYWRvd0NvbG9yOiBmdW5jdGlvbihzdHlsZSkge1xuICAgICAgdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5zaGFkb3dDb2xvciA9IHN0eWxlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFNoYWRvd0JsdXI6IGZ1bmN0aW9uKGJsdXIpIHtcbiAgICAgIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuc2hhZG93Qmx1ciA9IGJsdXI7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0TGluZVdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuICAgICAgdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5saW5lV2lkdGggPSB3aWR0aDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBzZXRMaW5lQ2FwOiBmdW5jdGlvbihjYXBfdHlwZSkge1xuICAgICAgdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5saW5lQ2FwID0gY2FwX3R5cGU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgc2V0TGluZURhc2g6IGZ1bmN0aW9uKGRhc2gpIHtcbiAgICAgIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQubGluZURhc2ggPSBkYXNoO1xuICAgIH0sXG5cbiAgICBzY2FsZTogZnVuY3Rpb24oeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuc2NhbGUocGFyc2VGbG9hdCh4KSwgcGFyc2VGbG9hdCh5KSk7XG4gICAgfSxcblxuICAgIHJlc2l6ZTogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQucmVzaXplKFxuICAgICAgICAgIHBhcnNlSW50KHdpZHRoLCAxMCksIHBhcnNlSW50KGhlaWdodCwgMTApKTtcbiAgICB9LFxuXG4gICAgcmVjdDogZnVuY3Rpb24oeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgZmlsbFJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0LmZpbGxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sXG5cbiAgICBjbGVhclJlY3Q6IGZ1bmN0aW9uKHgsIHksIHdpZHRoLCBoZWlnaHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0LmNsZWFyUmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9LFxuXG4gICAgYmVnaW5QYXRoOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgIH0sXG5cbiAgICBtb3ZlVG86IGZ1bmN0aW9uKHgsIHkpIHtcbiAgICAgIHJldHVybiB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0Lm1vdmVUbyh4LCB5KTtcbiAgICB9LFxuXG4gICAgbGluZVRvOiBmdW5jdGlvbih4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5saW5lVG8oeCwgeSk7XG4gICAgfSxcblxuICAgIGJlemllckN1cnZlVG86IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyLCB4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5iZXppZXJDdXJ2ZVRvKHgxLCB5MSwgeDIsIHkyLCB4LCB5KTtcbiAgICB9LFxuXG4gICAgcXVhZHJhdGljQ3VydmVUbzogZnVuY3Rpb24oeDEsIHkxLCB4LCB5KSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5xdWFkcmF0aWNDdXJ2ZVRvKHgxLCB5MSwgeCwgeSk7XG4gICAgfSxcblxuICAgIC8vIFRoaXMgaXMgYW4gYXR0ZW1wdCAoaGFjaykgdG8gc2ltdWxhdGUgdGhlIEhUTUw1IGNhbnZhc1xuICAgIC8vIGFyYyBtZXRob2QuXG4gICAgYXJjOiBmdW5jdGlvbih4LCB5LCByYWRpdXMsIHN0YXJ0QW5nbGUsIGVuZEFuZ2xlLCBhbnRpQ2xvY2t3aXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5hcmMoeCwgeSwgcmFkaXVzLCBzdGFydEFuZ2xlLCBlbmRBbmdsZSwgYW50aUNsb2Nrd2lzZSk7XG4gICAgfSxcblxuICAgIC8vIEFkYXB0ZWQgZnJvbSB0aGUgc291cmNlIGZvciBSYXBoYWVsJ3MgRWxlbWVudC5nbG93XG4gICAgZ2xvdzogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5nbG93KCk7XG4gICAgfSxcblxuICAgIGZpbGw6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuZmlsbCgpO1xuICAgIH0sXG5cbiAgICBzdHJva2U6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuc3Ryb2tlKCk7XG4gICAgfSxcblxuICAgIGNsb3NlUGF0aDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdGhpcy52ZXhGbG93Q2FudmFzQ29udGV4dC5jbG9zZVBhdGgoKTtcbiAgICB9LFxuXG4gICAgbWVhc3VyZVRleHQ6IGZ1bmN0aW9uKHRleHQpIHtcbiAgICAgIHJldHVybiB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0Lm1lYXN1cmVUZXh0KHRleHQpO1xuICAgIH0sXG5cbiAgICBmaWxsVGV4dDogZnVuY3Rpb24odGV4dCwgeCwgeSkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuZmlsbFRleHQodGV4dCwgeCwgeSk7XG4gICAgfSxcblxuICAgIHNhdmU6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMudmV4Rmxvd0NhbnZhc0NvbnRleHQuc2F2ZSgpO1xuICAgIH0sXG5cbiAgICByZXN0b3JlOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLnZleEZsb3dDYW52YXNDb250ZXh0LnJlc3RvcmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIENhbnZhc0NvbnRleHQ7XG59KCkpO1xuXG4vLyBWZXggRmxvdyBOb3RhdGlvblxuLy8gQXV0aG9yIExhcnJ5IEt1aG5zIDIwMTFcbi8vIEltcGxlbWVudHMgYmFybGluZXMgKHNpbmdsZSwgZG91YmxlLCByZXBlYXQsIGVuZClcbi8vXG4vLyBSZXF1aXJlcyB2ZXguanMuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblZleC5GbG93LkJhcmxpbmUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIEJhcmxpbmUodHlwZSwgeCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHR5cGUsIHgpO1xuICB9XG5cbiAgQmFybGluZS50eXBlID0ge1xuICAgIFNJTkdMRTogMSxcbiAgICBET1VCTEU6IDIsXG4gICAgRU5EOiAzLFxuICAgIFJFUEVBVF9CRUdJTjogNCxcbiAgICBSRVBFQVRfRU5EOiA1LFxuICAgIFJFUEVBVF9CT1RIOiA2LFxuICAgIE5PTkU6IDdcbiAgfTtcblxuICBWZXguSW5oZXJpdChCYXJsaW5lLCBWZXguRmxvdy5TdGF2ZU1vZGlmaWVyLCB7XG4gICAgaW5pdDogZnVuY3Rpb24odHlwZSwgeCkge1xuICAgICAgQmFybGluZS5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcbiAgICAgIHRoaXMudGhpY2tuZXNzID0gVmV4LkZsb3cuU1RBVkVfTElORV9USElDS05FU1M7XG4gICAgICB0aGlzLmJhcmxpbmUgPSB0eXBlO1xuICAgICAgdGhpcy54ID0geDsgICAgLy8gTGVmdCBtb3N0IHggZm9yIHRoZSBzdGF2ZVxuICAgIH0sXG5cbiAgICBnZXRDYXRlZ29yeTogZnVuY3Rpb24oKSB7IHJldHVybiBcImJhcmxpbmVzXCI7IH0sXG4gICAgc2V0WDogZnVuY3Rpb24oeCkgeyB0aGlzLnggPSB4OyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIERyYXcgYmFybGluZXNcbiAgICBkcmF3OiBmdW5jdGlvbihzdGF2ZSwgeF9zaGlmdCkge1xuICAgICAgeF9zaGlmdCA9IHR5cGVvZiB4X3NoaWZ0ICE9PSAnbnVtYmVyJyA/IDAgOiB4X3NoaWZ0O1xuXG4gICAgICBzd2l0Y2ggKHRoaXMuYmFybGluZSkge1xuICAgICAgICBjYXNlIEJhcmxpbmUudHlwZS5TSU5HTEU6XG4gICAgICAgICAgdGhpcy5kcmF3VmVydGljYWxCYXIoc3RhdmUsIHRoaXMueCwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIEJhcmxpbmUudHlwZS5ET1VCTEU6XG4gICAgICAgICAgdGhpcy5kcmF3VmVydGljYWxCYXIoc3RhdmUsIHRoaXMueCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQmFybGluZS50eXBlLkVORDpcbiAgICAgICAgICB0aGlzLmRyYXdWZXJ0aWNhbEVuZEJhcihzdGF2ZSwgdGhpcy54KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCYXJsaW5lLnR5cGUuUkVQRUFUX0JFR0lOOlxuICAgICAgICAgIC8vIElmIHRoZSBiYXJsaW5lIGlzIHNoaWZ0ZWQgb3ZlciAoaW4gZnJvbnQgb2YgY2xlZi90aW1lL2tleSlcbiAgICAgICAgICAvLyBEcmF3IHZlcnRpY2FsIGJhciBhdCB0aGUgYmVnaW5uaW5nLlxuICAgICAgICAgIGlmICh4X3NoaWZ0ID4gMCkge1xuICAgICAgICAgICAgdGhpcy5kcmF3VmVydGljYWxCYXIoc3RhdmUsIHRoaXMueCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIHRoaXMuZHJhd1JlcGVhdEJhcihzdGF2ZSwgdGhpcy54ICsgeF9zaGlmdCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgQmFybGluZS50eXBlLlJFUEVBVF9FTkQ6XG4gICAgICAgICAgdGhpcy5kcmF3UmVwZWF0QmFyKHN0YXZlLCB0aGlzLngsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBCYXJsaW5lLnR5cGUuUkVQRUFUX0JPVEg6XG4gICAgICAgICAgdGhpcy5kcmF3UmVwZWF0QmFyKHN0YXZlLCB0aGlzLngsIGZhbHNlKTtcbiAgICAgICAgICB0aGlzLmRyYXdSZXBlYXRCYXIoc3RhdmUsIHRoaXMueCwgdHJ1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gRGVmYXVsdCBpcyBOT05FLCBzbyBub3RoaW5nIHRvIGRyYXdcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZHJhd1ZlcnRpY2FsQmFyOiBmdW5jdGlvbihzdGF2ZSwgeCwgZG91YmxlX2Jhcikge1xuICAgICAgaWYgKCFzdGF2ZS5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgc3RhdmUgd2l0aG91dCBjYW52YXMgY29udGV4dC5cIik7XG4gICAgICB2YXIgdG9wWSA9IHN0YXZlLmdldFlGb3JMaW5lKDApO1xuICAgICAgdmFyIGJvdFkgPSBzdGF2ZS5nZXRZRm9yTGluZShzdGF2ZS5nZXROdW1MaW5lcygpIC0gMSkgKyB0aGlzLnRoaWNrbmVzcztcbiAgICAgIGlmIChkb3VibGVfYmFyKVxuICAgICAgICBzdGF2ZS5jb250ZXh0LmZpbGxSZWN0KHggLSAzLCB0b3BZLCAxLCBib3RZIC0gdG9wWSk7XG4gICAgICBzdGF2ZS5jb250ZXh0LmZpbGxSZWN0KHgsIHRvcFksIDEsIGJvdFkgLSB0b3BZKTtcbiAgICB9LFxuXG4gICAgZHJhd1ZlcnRpY2FsRW5kQmFyOiBmdW5jdGlvbihzdGF2ZSwgeCkge1xuICAgICAgaWYgKCFzdGF2ZS5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgc3RhdmUgd2l0aG91dCBjYW52YXMgY29udGV4dC5cIik7XG5cbiAgICAgIHZhciB0b3BZID0gc3RhdmUuZ2V0WUZvckxpbmUoMCk7XG4gICAgICB2YXIgYm90WSA9IHN0YXZlLmdldFlGb3JMaW5lKHN0YXZlLmdldE51bUxpbmVzKCkgLSAxKSArIHRoaXMudGhpY2tuZXNzO1xuICAgICAgc3RhdmUuY29udGV4dC5maWxsUmVjdCh4IC0gNSwgdG9wWSwgMSwgYm90WSAtIHRvcFkpO1xuICAgICAgc3RhdmUuY29udGV4dC5maWxsUmVjdCh4IC0gMiwgdG9wWSwgMywgYm90WSAtIHRvcFkpO1xuICAgIH0sXG5cbiAgICBkcmF3UmVwZWF0QmFyOiBmdW5jdGlvbihzdGF2ZSwgeCwgYmVnaW4pIHtcbiAgICAgIGlmICghc3RhdmUuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHN0YXZlIHdpdGhvdXQgY2FudmFzIGNvbnRleHQuXCIpO1xuXG4gICAgICB2YXIgdG9wWSA9IHN0YXZlLmdldFlGb3JMaW5lKDApO1xuICAgICAgdmFyIGJvdFkgPSBzdGF2ZS5nZXRZRm9yTGluZShzdGF2ZS5nZXROdW1MaW5lcygpIC0gMSkgKyB0aGlzLnRoaWNrbmVzcztcbiAgICAgIHZhciB4X3NoaWZ0ID0gMztcblxuICAgICAgaWYgKCFiZWdpbikge1xuICAgICAgICB4X3NoaWZ0ID0gLTU7XG4gICAgICB9XG5cbiAgICAgIHN0YXZlLmNvbnRleHQuZmlsbFJlY3QoeCArIHhfc2hpZnQsIHRvcFksIDEsIGJvdFkgLSB0b3BZKTtcbiAgICAgIHN0YXZlLmNvbnRleHQuZmlsbFJlY3QoeCAtIDIsIHRvcFksIDMsIGJvdFkgLSB0b3BZKTtcblxuICAgICAgdmFyIGRvdF9yYWRpdXMgPSAyO1xuXG4gICAgICAvLyBTaGlmdCBkb3RzIGxlZnQgb3IgcmlnaHRcbiAgICAgIGlmIChiZWdpbikge1xuICAgICAgICB4X3NoaWZ0ICs9IDQ7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB4X3NoaWZ0IC09IDQ7XG4gICAgICB9XG5cbiAgICAgIHZhciBkb3RfeCA9ICh4ICsgeF9zaGlmdCkgKyAoZG90X3JhZGl1cyAvIDIpO1xuXG4gICAgICAvLyBjYWxjdWxhdGUgdGhlIHkgb2Zmc2V0IGJhc2VkIG9uIG51bWJlciBvZiBzdGF2ZSBsaW5lc1xuICAgICAgdmFyIHlfb2Zmc2V0ID0gKHN0YXZlLmdldE51bUxpbmVzKCkgLSAxKSAqXG4gICAgICAgIHN0YXZlLmdldFNwYWNpbmdCZXR3ZWVuTGluZXMoKTtcbiAgICAgIHlfb2Zmc2V0ID0gKHlfb2Zmc2V0IC8gMikgLVxuICAgICAgICAgICAgICAgICAoc3RhdmUuZ2V0U3BhY2luZ0JldHdlZW5MaW5lcygpIC8gMik7XG4gICAgICB2YXIgZG90X3kgPSB0b3BZICsgeV9vZmZzZXQgKyAoZG90X3JhZGl1cyAvIDIpO1xuXG4gICAgICAvLyBkcmF3IHRoZSB0b3AgcmVwZWF0IGRvdFxuICAgICAgc3RhdmUuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgIHN0YXZlLmNvbnRleHQuYXJjKGRvdF94LCBkb3RfeSwgZG90X3JhZGl1cywgMCwgTWF0aC5QSSAqIDIsIGZhbHNlKTtcbiAgICAgIHN0YXZlLmNvbnRleHQuZmlsbCgpO1xuXG4gICAgICAvL2RyYXcgdGhlIGJvdHRvbSByZXBlYXQgZG90XG4gICAgICBkb3RfeSArPSBzdGF2ZS5nZXRTcGFjaW5nQmV0d2VlbkxpbmVzKCk7XG4gICAgICBzdGF2ZS5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgc3RhdmUuY29udGV4dC5hcmMoZG90X3gsIGRvdF95LCBkb3RfcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgc3RhdmUuY29udGV4dC5maWxsKCk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQmFybGluZTtcbn0oKSk7XG5cbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy8gVGhpcyBjbGFzcyBieSBSYWZmYWVsZSBWaWdsaWFudGksIDIwMTIgaHR0cDovL2l0aXNub3Rzb3VuZC53b3JkcHJlc3MuY29tL1xuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBoYWlycGlucyBiZXR3ZWVuIG5vdGVzLlxuLy8gSGFpcnBpbnMgY2FuIGJlIGVpdGhlciBDcmVzY2VuZG8gb3IgRGVzY3Jlc2NlbmRvLlxuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBoYWlycGluIGZyb20gdGhlIHNwZWNpZmllZCBub3Rlcy5cbiAqXG4gKiBAY29uc3RydWN0b3JcbiAqIEBwYXJhbSB7IU9iamVjdH0gbm90ZXMgVGhlIG5vdGVzIHRvIHRpZSB1cC5cbiAqIEBwYXJhbSB7IU9iamVjdH0gdHlwZSBUaGUgdHlwZSBvZiBoYWlycGluXG4gKi9cblZleC5GbG93LlN0YXZlSGFpcnBpbiA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gU3RhdmVIYWlycGluKG5vdGVzLCB0eXBlKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQobm90ZXMsIHR5cGUpO1xuICB9XG5cbiAgU3RhdmVIYWlycGluLnR5cGUgPSB7XG4gICAgQ1JFU0M6IDEsXG4gICAgREVDUkVTQzogMlxuICB9O1xuXG4gIC8qIEhlbHBlciBmdW5jdGlvbiB0byBjb252ZXJ0IHRpY2tzIGludG8gcGl4ZWxzLlxuICAgKiBSZXF1aXJlcyBhIEZvcm1hdHRlciB3aXRoIHZvaWNlcyBqb2luZWQgYW5kIGZvcm1hdHRlZCAodG9cbiAgICogZ2V0IHBpeGVscyBwZXIgdGljaylcbiAgICpcbiAgICogb3B0aW9ucyBpcyBzdHJ1Y3QgdGhhdCBoYXM6XG4gICAqXG4gICAqICB7XG4gICAqICAgaGVpZ2h0OiBweCxcbiAgICogICB5X3NoaWZ0OiBweCwgLy92ZXJ0aWNhbCBvZmZzZXRcbiAgICogICBsZWZ0X3NoaWZ0X3RpY2tzOiAwLCAvL2xlZnQgaG9yaXpvbnRhbCBvZmZzZXQgZXhwcmVzc2VkIGluIHRpY2tzXG4gICAqICAgcmlnaHRfc2hpZnRfdGlja3M6IDAgLy8gcmlnaHQgaG9yaXpvbnRhbCBvZmZzZXQgZXhwcmVzc2VkIGluIHRpY2tzXG4gICAqICB9XG4gICAqXG4gICAqKi9cbiAgU3RhdmVIYWlycGluLkZvcm1hdEJ5VGlja3NBbmREcmF3ID0gZnVuY3Rpb24oY3R4LCBmb3JtYXR0ZXIsIG5vdGVzLCB0eXBlLCBwb3NpdGlvbiwgb3B0aW9ucykge1xuICAgIHZhciBwcHQgPSBmb3JtYXR0ZXIucGl4ZWxzUGVyVGljaztcblxuICAgIGlmIChwcHQgPT0gbnVsbCl7XG4gICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLFxuICAgICAgICAgIFwiQSB2YWxpZCBGb3JtYXR0ZXIgbXVzdCBiZSBwcm92aWRlIHRvIGRyYXcgb2Zmc2V0cyBieSB0aWNrcy5cIik7fVxuXG4gICAgdmFyIGxfc2hpZnRfcHggPSBwcHQgKiBvcHRpb25zLmxlZnRfc2hpZnRfdGlja3M7XG4gICAgdmFyIHJfc2hpZnRfcHggPSBwcHQgKiBvcHRpb25zLnJpZ2h0X3NoaWZ0X3RpY2tzO1xuXG4gICAgdmFyIGhhaXJwaW5fb3B0aW9ucyA9IHtcbiAgICAgIGhlaWdodDogb3B0aW9ucy5oZWlnaHQsXG4gICAgICB5X3NoaWZ0Om9wdGlvbnMueV9zaGlmdCxcbiAgICAgIGxlZnRfc2hpZnRfcHg6bF9zaGlmdF9weCxcbiAgICAgIHJpZ2h0X3NoaWZ0X3B4OnJfc2hpZnRfcHh9O1xuXG4gICAgbmV3IFN0YXZlSGFpcnBpbih7XG4gICAgICBmaXJzdF9ub3RlOiBub3Rlcy5maXJzdF9ub3RlLFxuICAgICAgbGFzdF9ub3RlOiBub3Rlcy5sYXN0X25vdGVcbiAgICB9LCB0eXBlKVxuICAgICAgLnNldENvbnRleHQoY3R4KVxuICAgICAgLnNldFJlbmRlck9wdGlvbnMoaGFpcnBpbl9vcHRpb25zKVxuICAgICAgLnNldFBvc2l0aW9uKHBvc2l0aW9uKVxuICAgICAgLmRyYXcoKTtcbiAgfTtcblxuICBTdGF2ZUhhaXJwaW4ucHJvdG90eXBlID0ge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG5vdGVzLCB0eXBlKSB7XG4gICAgICAvKipcbiAgICAgICAqIE5vdGVzIGlzIGEgc3RydWN0IHRoYXQgaGFzOlxuICAgICAgICpcbiAgICAgICAqICB7XG4gICAgICAgKiAgICBmaXJzdF9ub3RlOiBOb3RlLFxuICAgICAgICogICAgbGFzdF9ub3RlOiBOb3RlLFxuICAgICAgICogIH1cbiAgICAgICAqXG4gICAgICAgKiovXG5cbiAgICAgIHRoaXMubm90ZXMgPSBub3RlcztcbiAgICAgIHRoaXMuaGFpcnBpbiA9IHR5cGU7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uQkVMT1c7XG5cbiAgICAgIHRoaXMuY29udGV4dCA9IG51bGw7XG5cbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMgPSB7XG4gICAgICAgICAgaGVpZ2h0OiAxMCxcbiAgICAgICAgICB5X3NoaWZ0OiAwLCAvL3ZlcnRpY2FsIG9mZnNldFxuICAgICAgICAgIGxlZnRfc2hpZnRfcHg6IDAsIC8vbGVmdCBob3Jpem9udGFsIG9mZnNldFxuICAgICAgICAgIHJpZ2h0X3NoaWZ0X3B4OiAwIC8vIHJpZ2h0IGhvcml6b250YWwgb2Zmc2V0XG4gICAgICAgIH07XG5cbiAgICAgIHRoaXMuc2V0Tm90ZXMobm90ZXMpO1xuICAgIH0sXG5cbiAgICBzZXRDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7IHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgc2V0UG9zaXRpb246IGZ1bmN0aW9uKHBvc2l0aW9uKSB7XG4gICAgICBpZiAocG9zaXRpb24gPT0gVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uQUJPVkUgfHxcbiAgICAgICAgICBwb3NpdGlvbiA9PSBWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5CRUxPVylcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldFJlbmRlck9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcbiAgICAgIGlmIChvcHRpb25zLmhlaWdodCAhPSBudWxsICYmXG4gICAgICAgICAgb3B0aW9ucy55X3NoaWZ0ICE9IG51bGwgJiZcbiAgICAgICAgICBvcHRpb25zLmxlZnRfc2hpZnRfcHggIT0gbnVsbCAmJlxuICAgICAgICAgIG9wdGlvbnMucmlnaHRfc2hpZnRfcHggIT0gbnVsbCl7XG4gICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgbm90ZXMgdG8gYXR0YWNoIHRoaXMgaGFpcnBpbiB0by5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7IU9iamVjdH0gbm90ZXMgVGhlIHN0YXJ0IGFuZCBlbmQgbm90ZXMuXG4gICAgICovXG4gICAgc2V0Tm90ZXM6IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgICBpZiAoIW5vdGVzLmZpcnN0X25vdGUgJiYgIW5vdGVzLmxhc3Rfbm90ZSlcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgIFwiSGFpcnBpbiBuZWVkcyB0byBoYXZlIGVpdGhlciBmaXJzdF9ub3RlIG9yIGxhc3Rfbm90ZSBzZXQuXCIpO1xuXG4gICAgICAvLyBTdWNjZXNzLiBMZXRzIGdyYWIgJ2VtIG5vdGVzLlxuICAgICAgdGhpcy5maXJzdF9ub3RlID0gbm90ZXMuZmlyc3Rfbm90ZTtcbiAgICAgIHRoaXMubGFzdF9ub3RlID0gbm90ZXMubGFzdF9ub3RlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHJlbmRlckhhaXJwaW46IGZ1bmN0aW9uKHBhcmFtcykge1xuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciBkaXMgPSB0aGlzLnJlbmRlcl9vcHRpb25zLnlfc2hpZnQgKyAyMDtcbiAgICAgIHZhciB5X3NoaWZ0ID0gcGFyYW1zLmZpcnN0X3k7XG5cbiAgICAgIGlmICh0aGlzLnBvc2l0aW9uID09IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFKSB7XG4gICAgICAgIGRpcyA9IC1kaXMgKzMwO1xuICAgICAgICB5X3NoaWZ0ID0gcGFyYW1zLmZpcnN0X3kgLSBwYXJhbXMuc3RhZmZfaGVpZ2h0O1xuICAgICAgfVxuXG4gICAgICB2YXIgbF9zaGlmdCA9IHRoaXMucmVuZGVyX29wdGlvbnMubGVmdF9zaGlmdF9weDtcbiAgICAgIHZhciByX3NoaWZ0ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5yaWdodF9zaGlmdF9weDtcblxuICAgICAgc3dpdGNoICh0aGlzLmhhaXJwaW4pIHtcbiAgICAgICAgY2FzZSBTdGF2ZUhhaXJwaW4udHlwZS5DUkVTQzpcbiAgICAgICAgICBjdHgubW92ZVRvKHBhcmFtcy5sYXN0X3ggKyByX3NoaWZ0LCB5X3NoaWZ0ICsgZGlzKTtcbiAgICAgICAgICBjdHgubGluZVRvKHBhcmFtcy5maXJzdF94ICsgbF9zaGlmdCwgeV9zaGlmdCArKHRoaXMucmVuZGVyX29wdGlvbnMuaGVpZ2h0LzIpICsgZGlzKTtcbiAgICAgICAgICBjdHgubGluZVRvKHBhcmFtcy5sYXN0X3ggKyByX3NoaWZ0LCB5X3NoaWZ0ICsgdGhpcy5yZW5kZXJfb3B0aW9ucy5oZWlnaHQgKyBkaXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFN0YXZlSGFpcnBpbi50eXBlLkRFQ1JFU0M6XG4gICAgICAgICAgY3R4Lm1vdmVUbyhwYXJhbXMuZmlyc3RfeCArIGxfc2hpZnQsIHlfc2hpZnQgKyBkaXMpO1xuICAgICAgICAgIGN0eC5saW5lVG8ocGFyYW1zLmxhc3RfeCArIHJfc2hpZnQsIHlfc2hpZnQgKyh0aGlzLnJlbmRlcl9vcHRpb25zLmhlaWdodC8yKSArIGRpcyk7XG4gICAgICAgICAgY3R4LmxpbmVUbyhwYXJhbXMuZmlyc3RfeCArIGxfc2hpZnQsIHlfc2hpZnQgKyB0aGlzLnJlbmRlcl9vcHRpb25zLmhlaWdodCArIGRpcyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgLy8gRGVmYXVsdCBpcyBOT05FLCBzbyBub3RoaW5nIHRvIGRyYXdcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgIH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IEhhaXJwaW4gd2l0aG91dCBhIGNvbnRleHQuXCIpO1xuXG4gICAgICB2YXIgZmlyc3Rfbm90ZSA9IHRoaXMuZmlyc3Rfbm90ZTtcbiAgICAgIHZhciBsYXN0X25vdGUgPSB0aGlzLmxhc3Rfbm90ZTtcblxuICAgICAgdmFyIHN0YXJ0ID0gZmlyc3Rfbm90ZS5nZXRNb2RpZmllclN0YXJ0WFkodGhpcy5wb3NpdGlvbiwgMCk7XG4gICAgICB2YXIgZW5kID0gbGFzdF9ub3RlLmdldE1vZGlmaWVyU3RhcnRYWSh0aGlzLnBvc2l0aW9uLCAwKTtcblxuICAgICAgdGhpcy5yZW5kZXJIYWlycGluKHtcbiAgICAgICAgZmlyc3RfeDogc3RhcnQueCxcbiAgICAgICAgbGFzdF94OiBlbmQueCxcbiAgICAgICAgZmlyc3RfeTogZmlyc3Rfbm90ZS5nZXRTdGF2ZSgpLnkgKyBmaXJzdF9ub3RlLmdldFN0YXZlKCkuaGVpZ2h0LFxuICAgICAgICBsYXN0X3k6IGxhc3Rfbm90ZS5nZXRTdGF2ZSgpLnkgKyBsYXN0X25vdGUuZ2V0U3RhdmUoKS5oZWlnaHQsXG4gICAgICAgIHN0YWZmX2hlaWdodDogZmlyc3Rfbm90ZS5nZXRTdGF2ZSgpLmhlaWdodFxuICAgICAgfSk7XG4gICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIFN0YXZlSGFpcnBpbjtcbn0oKSk7XG5cblxuLy8gVmV4IEZsb3cgTm90YXRpb25cbi8vIEF1dGhvciBMYXJyeSBLdWhucyAyMDExXG4vLyBJbXBsZW1lbnRzIHZvbHRhcyAocmVwZWF0IGJyYWNrZXRzKVxuLy9cbi8vIFJlcXVpcmVzIHZleC5qcy5cblxuVmV4LkZsb3cuVm9sdGEgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFZvbHRhKHR5cGUsIG51bWJlciwgeCwgeV9zaGlmdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHR5cGUsIG51bWJlciwgeCwgeV9zaGlmdCk7XG4gIH1cblxuICBWb2x0YS50eXBlID0ge1xuICAgIE5PTkU6IDEsXG4gICAgQkVHSU46IDIsXG4gICAgTUlEOiAzLFxuICAgIEVORDogNCxcbiAgICBCRUdJTl9FTkQ6IDVcbiAgfTtcblxuICBWZXguSW5oZXJpdChWb2x0YSwgVmV4LkZsb3cuU3RhdmVNb2RpZmllciwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKHR5cGUsIG51bWJlciwgeCwgeV9zaGlmdCkge1xuICAgICAgVm9sdGEuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcyk7XG5cbiAgICAgIHRoaXMudm9sdGEgPSB0eXBlO1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueV9zaGlmdCA9IHlfc2hpZnQ7XG4gICAgICB0aGlzLm51bWJlciA9IG51bWJlcjtcbiAgICAgIHRoaXMuZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiBcInNhbnMtc2VyaWZcIixcbiAgICAgICAgc2l6ZTogOSxcbiAgICAgICAgd2VpZ2h0OiBcImJvbGRcIlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJ2b2x0YXNcIjsgfSxcbiAgICBzZXRTaGlmdFk6IGZ1bmN0aW9uKHkpIHsgdGhpcy55X3NoaWZ0ID0geTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbihzdGF2ZSwgeCkge1xuICAgICAgaWYgKCFzdGF2ZS5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IHN0YXZlIHdpdGhvdXQgY2FudmFzIGNvbnRleHQuXCIpO1xuICAgICAgdmFyIGN0eCA9IHN0YXZlLmNvbnRleHQ7XG4gICAgICB2YXIgd2lkdGggPSBzdGF2ZS53aWR0aDtcbiAgICAgIHZhciB0b3BfeSA9IHN0YXZlLmdldFlGb3JUb3BUZXh0KHN0YXZlLm9wdGlvbnMubnVtX2xpbmVzKSArIHRoaXMueV9zaGlmdDtcbiAgICAgIHZhciB2ZXJ0X2hlaWdodCA9IDEuNSAqIHN0YXZlLm9wdGlvbnMuc3BhY2luZ19iZXR3ZWVuX2xpbmVzX3B4O1xuICAgICAgc3dpdGNoKHRoaXMudm9sdGEpIHtcbiAgICAgICAgY2FzZSBWZXguRmxvdy5Wb2x0YS50eXBlLkJFR0lOOlxuICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnggKyB4LCB0b3BfeSwgMSwgdmVydF9oZWlnaHQpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFZleC5GbG93LlZvbHRhLnR5cGUuRU5EOlxuICAgICAgICAgIHdpZHRoIC09IDU7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHRoaXMueCArIHggKyB3aWR0aCwgdG9wX3ksIDEsIHZlcnRfaGVpZ2h0KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBWZXguRmxvdy5Wb2x0YS50eXBlLkJFR0lOX0VORDpcbiAgICAgICAgICB3aWR0aCAtPSAzO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnggKyB4LCB0b3BfeSwgMSwgdmVydF9oZWlnaHQpO1xuICAgICAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnggKyB4ICsgd2lkdGgsIHRvcF95LCAxLCB2ZXJ0X2hlaWdodCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICAgIC8vIElmIHRoZSBiZWdpbm5pbmcgb2YgYSB2b2x0YSwgZHJhdyBtZWFzdXJlIG51bWJlclxuICAgICAgaWYgKHRoaXMudm9sdGEgPT0gVm9sdGEudHlwZS5CRUdJTiB8fFxuICAgICAgICAgIHRoaXMudm9sdGEgPT0gVm9sdGEudHlwZS5CRUdJTl9FTkQpIHtcbiAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgY3R4LnNldEZvbnQodGhpcy5mb250LmZhbWlseSwgdGhpcy5mb250LnNpemUsIHRoaXMuZm9udC53ZWlnaHQpO1xuICAgICAgICBjdHguZmlsbFRleHQodGhpcy5udW1iZXIsIHRoaXMueCArIHggKyA1LCB0b3BfeSArIDE1KTtcbiAgICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5maWxsUmVjdCh0aGlzLnggKyB4LCB0b3BfeSwgd2lkdGgsIDEpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gVm9sdGE7XG59KCkpO1xuLy8gVmV4IEZsb3cgTm90YXRpb25cbi8vIEF1dGhvciBMYXJyeSBLdWhucyAyMDExXG4vLyBJbXBsZW1lbnRzIFJlcGV0aXRpb25zIChDb2RhLCBzaWdubywgRC5DLiwgZXRjLilcbi8vXG4vLyBSZXF1aXJlcyB2ZXguanMuXG5cblZleC5GbG93LlJlcGV0aXRpb24gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFJlcGV0aXRpb24odHlwZSwgeCwgeV9zaGlmdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHR5cGUsIHgsIHlfc2hpZnQpO1xuICB9XG5cbiAgUmVwZXRpdGlvbi50eXBlID0ge1xuICAgIE5PTkU6IDEsICAgICAgICAgLy8gbm8gY29kYSBvciBzZWdub1xuICAgIENPREFfTEVGVDogMiwgICAgLy8gY29kYSBhdCBiZWdpbm5pbmcgb2Ygc3RhdmVcbiAgICBDT0RBX1JJR0hUOiAzLCAgIC8vIGNvZGEgYXQgZW5kIG9mIHN0YXZlXG4gICAgU0VHTk9fTEVGVDogNCwgICAvLyBzZWdubyBhdCBiZWdpbm5pbmcgb2Ygc3RhdmVcbiAgICBTRUdOT19SSUdIVDogNSwgIC8vIHNlZ25vIGF0IGVuZCBvZiBzdGF2ZVxuICAgIERDOiA2LCAgICAgICAgICAgLy8gRC5DLiBhdCBlbmQgb2Ygc3RhdmVcbiAgICBEQ19BTF9DT0RBOiA3LCAgIC8vIEQuQy4gYWwgY29kYSBhdCBlbmQgb2Ygc3RhdmVcbiAgICBEQ19BTF9GSU5FOiA4LCAgIC8vIEQuQy4gYWwgRmluZSBlbmQgb2Ygc3RhdmVcbiAgICBEUzogOSwgICAgICAgICAgIC8vIEQuUy4gYXQgZW5kIG9mIHN0YXZlXG4gICAgRFNfQUxfQ09EQTogMTAsICAvLyBELlMuIGFsIGNvZGEgYXQgZW5kIG9mIHN0YXZlXG4gICAgRFNfQUxfRklORTogMTEsICAvLyBELlMuIGFsIEZpbmUgYXQgZW5kIG9mIHN0YXZlXG4gICAgRklORTogMTIgICAgICAgICAvLyBGaW5lIGF0IGVuZCBvZiBzdGF2ZVxuICB9O1xuXG4gIFZleC5Jbmhlcml0KFJlcGV0aXRpb24sIFZleC5GbG93LlN0YXZlTW9kaWZpZXIsIHtcbiAgICBpbml0OiBmdW5jdGlvbih0eXBlLCB4LCB5X3NoaWZ0KSB7XG4gICAgICBSZXBldGl0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLnN5bWJvbF90eXBlID0gdHlwZTtcbiAgICAgIHRoaXMueCA9IHg7XG4gICAgICB0aGlzLnhfc2hpZnQgPSAwO1xuICAgICAgdGhpcy55X3NoaWZ0ID0geV9zaGlmdDtcbiAgICAgIHRoaXMuZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiBcInRpbWVzXCIsXG4gICAgICAgIHNpemU6IDEyLFxuICAgICAgICB3ZWlnaHQ6IFwiYm9sZCBpdGFsaWNcIlxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJyZXBldGl0aW9uc1wiOyB9LFxuICAgIHNldFNoaWZ0WDogZnVuY3Rpb24oeCkgeyB0aGlzLnhfc2hpZnQgPSB4OyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRTaGlmdFk6IGZ1bmN0aW9uKHkpIHsgdGhpcy55X3NoaWZ0ID0geTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICBkcmF3OiBmdW5jdGlvbihzdGF2ZSwgeCkge1xuICAgICAgc3dpdGNoICh0aGlzLnN5bWJvbF90eXBlKSB7XG4gICAgICAgIGNhc2UgUmVwZXRpdGlvbi50eXBlLkNPREFfUklHSFQ6XG4gICAgICAgICAgdGhpcy5kcmF3Q29kYUZpeGVkKHN0YXZlLCB4ICsgc3RhdmUud2lkdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlcGV0aXRpb24udHlwZS5DT0RBX0xFRlQ6XG4gICAgICAgICAgdGhpcy5kcmF3U3ltYm9sVGV4dChzdGF2ZSwgeCwgXCJDb2RhXCIsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlcGV0aXRpb24udHlwZS5TRUdOT19MRUZUOlxuICAgICAgICAgIHRoaXMuZHJhd1NpZ25vRml4ZWQoc3RhdmUsIHgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlcGV0aXRpb24udHlwZS5TRUdOT19SSUdIVDpcbiAgICAgICAgICB0aGlzLmRyYXdTaWdub0ZpeGVkKHN0YXZlLCB4ICsgc3RhdmUud2lkdGgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlcGV0aXRpb24udHlwZS5EQzpcbiAgICAgICAgICB0aGlzLmRyYXdTeW1ib2xUZXh0KHN0YXZlLCB4LCBcIkQuQy5cIiwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlcGV0aXRpb24udHlwZS5EQ19BTF9DT0RBOlxuICAgICAgICAgIHRoaXMuZHJhd1N5bWJvbFRleHQoc3RhdmUsIHgsIFwiRC5DLiBhbFwiLCB0cnVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZXBldGl0aW9uLnR5cGUuRENfQUxfRklORTpcbiAgICAgICAgICB0aGlzLmRyYXdTeW1ib2xUZXh0KHN0YXZlLCB4LCBcIkQuQy4gYWwgRmluZVwiLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVwZXRpdGlvbi50eXBlLkRTOlxuICAgICAgICAgIHRoaXMuZHJhd1N5bWJvbFRleHQoc3RhdmUsIHgsIFwiRC5TLlwiLCBmYWxzZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgUmVwZXRpdGlvbi50eXBlLkRTX0FMX0NPREE6XG4gICAgICAgICAgdGhpcy5kcmF3U3ltYm9sVGV4dChzdGF2ZSwgeCwgXCJELlMuIGFsXCIsIHRydWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFJlcGV0aXRpb24udHlwZS5EU19BTF9GSU5FOlxuICAgICAgICAgIHRoaXMuZHJhd1N5bWJvbFRleHQoc3RhdmUsIHgsIFwiRC5TLiBhbCBGaW5lXCIsIGZhbHNlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBSZXBldGl0aW9uLnR5cGUuRklORTpcbiAgICAgICAgICB0aGlzLmRyYXdTeW1ib2xUZXh0KHN0YXZlLCB4LCBcIkZpbmVcIiwgZmFsc2UpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZHJhd0NvZGFGaXhlZDogZnVuY3Rpb24oc3RhdmUsIHgpIHtcbiAgICAgIGlmICghc3RhdmUuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHN0YXZlIHdpdGhvdXQgY2FudmFzIGNvbnRleHQuXCIpO1xuXG4gICAgICB2YXIgeSA9IHN0YXZlLmdldFlGb3JUb3BUZXh0KHN0YXZlLm9wdGlvbnMubnVtX2xpbmVzKSArIHRoaXMueV9zaGlmdDtcbiAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKHN0YXZlLmNvbnRleHQsIHRoaXMueCArIHggKyB0aGlzLnhfc2hpZnQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB5ICsgMjUsIDQwLCBcInY0ZFwiLCB0cnVlKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBkcmF3U2lnbm9GaXhlZDogZnVuY3Rpb24oc3RhdmUsIHgpIHtcbiAgICAgIGlmICghc3RhdmUuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHN0YXZlIHdpdGhvdXQgY2FudmFzIGNvbnRleHQuXCIpO1xuICAgICAgdmFyIHkgPSBzdGF2ZS5nZXRZRm9yVG9wVGV4dChzdGF2ZS5vcHRpb25zLm51bV9saW5lcykgKyB0aGlzLnlfc2hpZnQ7XG4gICAgICBWZXguRmxvdy5yZW5kZXJHbHlwaChzdGF2ZS5jb250ZXh0LCB0aGlzLnggKyB4ICsgdGhpcy54X3NoaWZ0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgeSArIDI1LCAzMCwgXCJ2OGNcIiwgdHJ1ZSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZHJhd1N5bWJvbFRleHQ6IGZ1bmN0aW9uKHN0YXZlLCB4LCB0ZXh0LCBkcmF3X2NvZGEpIHtcbiAgICAgIGlmICghc3RhdmUuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHN0YXZlIHdpdGhvdXQgY2FudmFzIGNvbnRleHQuXCIpO1xuXG4gICAgICB2YXIgY3R4ID0gc3RhdmUuY29udGV4dDtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHguc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSwgdGhpcy5mb250LndlaWdodCk7XG4gICAgICAgIC8vIERlZmF1bHQgdG8gcmlnaHQgc3ltYm9sXG4gICAgICB2YXIgdGV4dF94ID0gMCArIHRoaXMueF9zaGlmdDtcbiAgICAgIHZhciBzeW1ib2xfeCA9IHggKyB0aGlzLnhfc2hpZnQ7XG4gICAgICBpZiAodGhpcy5zeW1ib2xfdHlwZSA9PSBWZXguRmxvdy5SZXBldGl0aW9uLnR5cGUuQ09EQV9MRUZUKSB7XG4gICAgICAgICAgLy8gT2Zmc2V0IENvZGEgdGV4dCB0byByaWdodCBvZiBzdGF2ZSBiZWdpbm5pbmdcbiAgICAgICAgdGV4dF94ID0gdGhpcy54ICsgc3RhdmUub3B0aW9ucy52ZXJ0aWNhbF9iYXJfd2lkdGg7XG4gICAgICAgIHN5bWJvbF94ID0gdGV4dF94ICsgY3R4Lm1lYXN1cmVUZXh0KHRleHQpLndpZHRoICsgMTI7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE9mZnNldCBTaWdubyB0ZXh0IHRvIGxlZnQgc3RhdmUgZW5kXG4gICAgICAgIHN5bWJvbF94ID0gdGhpcy54ICsgeCArIHN0YXZlLndpZHRoIC0gNSArIHRoaXMueF9zaGlmdDtcbiAgICAgICAgdGV4dF94ID0gc3ltYm9sX3ggLSArIGN0eC5tZWFzdXJlVGV4dCh0ZXh0KS53aWR0aCAtIDEyO1xuICAgICAgfVxuICAgICAgdmFyIHkgPSBzdGF2ZS5nZXRZRm9yVG9wVGV4dChzdGF2ZS5vcHRpb25zLm51bV9saW5lcykgKyB0aGlzLnlfc2hpZnQ7XG4gICAgICBpZiAoZHJhd19jb2RhKSB7XG4gICAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKGN0eCwgc3ltYm9sX3gsIHksIDQwLCBcInY0ZFwiLCB0cnVlKTtcbiAgICAgIH1cblxuICAgICAgY3R4LmZpbGxUZXh0KHRleHQsIHRleHRfeCwgeSArIDUpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gUmVwZXRpdGlvbjtcbn0oKSk7XG4vLyBWZXhGbG93IC0gTXVzaWMgRW5ncmF2aW5nIGZvciBIVE1MNVxuLy8gQ29weXJpZ2h0IE1vaGl0IE11dGhhbm5hIDIwMTBcbi8vIEF1dGhvciBMYXJyeSBLdWhucyAyMDExXG4vLyBJbXBsZW1lbnRzIHN0YXZlIHNlY3Rpb24gbmFtZXMuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblZleC5GbG93LlN0YXZlU2VjdGlvbiA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gU3RhdmVTZWN0aW9uKHNlY3Rpb24sIHgsIHNoaWZ0X3kpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChzZWN0aW9uLCB4LCBzaGlmdF95KTtcbiAgfVxuXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xuICBWZXguSW5oZXJpdChTdGF2ZVNlY3Rpb24sIE1vZGlmaWVyLCB7XG4gICAgaW5pdDogZnVuY3Rpb24oc2VjdGlvbiwgeCwgc2hpZnRfeSkge1xuICAgICAgU3RhdmVTZWN0aW9uLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLnNldFdpZHRoKDE2KTtcbiAgICAgIHRoaXMuc2VjdGlvbiA9IHNlY3Rpb247XG4gICAgICB0aGlzLnBvc2l0aW9uID0gTW9kaWZpZXIuUG9zaXRpb24uQUJPVkU7XG4gICAgICB0aGlzLnggPSB4O1xuICAgICAgdGhpcy5zaGlmdF94ID0gMDtcbiAgICAgIHRoaXMuc2hpZnRfeSA9IHNoaWZ0X3k7XG4gICAgICB0aGlzLmZvbnQgPSB7XG4gICAgICAgIGZhbWlseTogXCJzYW5zLXNlcmlmXCIsXG4gICAgICAgIHNpemU6IDEyLFxuICAgICAgICB3ZWlnaHQ6IFwiYm9sZFwiXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRDYXRlZ29yeTogZnVuY3Rpb24oKSB7IHJldHVybiBcInN0YXZlc2VjdGlvblwiOyB9LFxuICAgIHNldFN0YXZlU2VjdGlvbjogZnVuY3Rpb24oc2VjdGlvbikgeyB0aGlzLnNlY3Rpb24gPSBzZWN0aW9uOyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRTaGlmdFg6IGZ1bmN0aW9uKHgpIHsgdGhpcy5zaGlmdF94ID0geDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgc2V0U2hpZnRZOiBmdW5jdGlvbih5KSB7IHRoaXMuc2hpZnRfeSA9IHk7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oc3RhdmUsIHNoaWZ0X3gpIHtcbiAgICAgIGlmICghc3RhdmUuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9Db250ZXh0XCIsXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBzdGF2ZSBzZWN0aW9uIHdpdGhvdXQgYSBjb250ZXh0LlwiKTtcblxuICAgICAgdmFyIGN0eCA9IHN0YXZlLmNvbnRleHQ7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgIGN0eC5zZXRGb250KHRoaXMuZm9udC5mYW1pbHksIHRoaXMuZm9udC5zaXplLCB0aGlzLmZvbnQud2VpZ2h0KTtcbiAgICAgIHZhciB0ZXh0X3dpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KFwiXCIgKyB0aGlzLnNlY3Rpb24pLndpZHRoO1xuICAgICAgdmFyIHdpZHRoID0gdGV4dF93aWR0aCArIDY7ICAvLyBhZGQgbGVmdCAmIHJpZ2h0IHBhZGRpbmdcbiAgICAgIGlmICh3aWR0aCA8IDE4KSB3aWR0aCA9IDE4O1xuICAgICAgdmFyIGhlaWdodCA9IDIwO1xuICAgICAgICAvLyAgU2VlbXMgdG8gYmUgYSBnb29kIGRlZmF1bHQgeVxuICAgICAgdmFyIHkgPSBzdGF2ZS5nZXRZRm9yVG9wVGV4dCgzKSArIHRoaXMuc2hpZnRfeTtcbiAgICAgIHZhciB4ID0gdGhpcy54ICsgc2hpZnRfeDtcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICAgIGN0eC5saW5lV2lkdGggPSAyO1xuICAgICAgY3R4LnJlY3QoeCwgeSwgd2lkdGgsIGhlaWdodCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICB4ICs9ICh3aWR0aCAtIHRleHRfd2lkdGgpIC8gMjtcbiAgICAgIGN0eC5maWxsVGV4dChcIlwiICsgdGhpcy5zZWN0aW9uLCB4LCB5ICsgMTYpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFN0YXZlU2VjdGlvbjtcbn0oKSk7XG4vLyBWZXhGbG93IC0gTXVzaWMgRW5ncmF2aW5nIGZvciBIVE1MNVxuLy8gQ29weXJpZ2h0IE1vaGl0IE11dGhhbm5hIDIwMTBcbi8vIEF1dGhvciBSYWRvc2F3IEVpY2hsZXIgMjAxMlxuLy8gSW1wbGVtZW50cyB0ZW1wbyBtYXJrZXIuXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge09iamVjdH0gdGVtcG8gVGVtcG8gcGFyYW1ldGVyczogeyBuYW1lLCBkdXJhdGlvbiwgZG90cywgYnBtIH1cbiAqL1xuVmV4LkZsb3cuU3RhdmVUZW1wbyA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gU3RhdmVUZW1wbyh0ZW1wbywgeCwgc2hpZnRfeSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHRlbXBvLCB4LCBzaGlmdF95KTtcbiAgfVxuXG4gIFZleC5Jbmhlcml0KFN0YXZlVGVtcG8sIFZleC5GbG93LlN0YXZlTW9kaWZpZXIsIHtcbiAgICBpbml0OiBmdW5jdGlvbih0ZW1wbywgeCwgc2hpZnRfeSkge1xuICAgICAgU3RhdmVUZW1wby5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy50ZW1wbyA9IHRlbXBvO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFO1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMuc2hpZnRfeCA9IDEwO1xuICAgICAgdGhpcy5zaGlmdF95ID0gc2hpZnRfeTtcbiAgICAgIHRoaXMuZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiBcInRpbWVzXCIsXG4gICAgICAgIHNpemU6IDE0LFxuICAgICAgICB3ZWlnaHQ6IFwiYm9sZFwiXG4gICAgICB9O1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgZ2x5cGhfZm9udF9zY2FsZTogMzAgIC8vIGZvbnQgc2l6ZSBmb3Igbm90ZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gXCJzdGF2ZXRlbXBvXCI7IH0sXG4gICAgc2V0VGVtcG86IGZ1bmN0aW9uKHRlbXBvKSB7IHRoaXMudGVtcG8gPSB0ZW1wbzsgcmV0dXJuIHRoaXM7IH0sXG4gICAgc2V0U2hpZnRYOiBmdW5jdGlvbih4KSB7IHRoaXMuc2hpZnRfeCA9IHg7IHJldHVybiB0aGlzOyB9LFxuICAgIHNldFNoaWZ0WTogZnVuY3Rpb24oeSkgeyB0aGlzLnNoaWZ0X3kgPSB5OyByZXR1cm4gdGhpczsgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKHN0YXZlLCBzaGlmdF94KSB7XG4gICAgICBpZiAoIXN0YXZlLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgc3RhdmUgdGVtcG8gd2l0aG91dCBhIGNvbnRleHQuXCIpO1xuXG4gICAgICB2YXIgb3B0aW9ucyA9IHRoaXMucmVuZGVyX29wdGlvbnM7XG4gICAgICB2YXIgc2NhbGUgPSBvcHRpb25zLmdseXBoX2ZvbnRfc2NhbGUgLyAzODtcbiAgICAgIHZhciBuYW1lID0gdGhpcy50ZW1wby5uYW1lO1xuICAgICAgdmFyIGR1cmF0aW9uID0gdGhpcy50ZW1wby5kdXJhdGlvbjtcbiAgICAgIHZhciBkb3RzID0gdGhpcy50ZW1wby5kb3RzO1xuICAgICAgdmFyIGJwbSA9IHRoaXMudGVtcG8uYnBtO1xuICAgICAgdmFyIGZvbnQgPSB0aGlzLmZvbnQ7XG4gICAgICB2YXIgY3R4ID0gc3RhdmUuY29udGV4dDtcbiAgICAgIHZhciB4ID0gdGhpcy54ICsgdGhpcy5zaGlmdF94ICsgc2hpZnRfeDtcbiAgICAgIHZhciB5ID0gc3RhdmUuZ2V0WUZvclRvcFRleHQoMSkgKyB0aGlzLnNoaWZ0X3k7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG5cbiAgICAgIGlmIChuYW1lKSB7XG4gICAgICAgIGN0eC5zZXRGb250KGZvbnQuZmFtaWx5LCBmb250LnNpemUsIGZvbnQud2VpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KG5hbWUsIHgsIHkpO1xuICAgICAgICB4ICs9IGN0eC5tZWFzdXJlVGV4dChuYW1lKS53aWR0aDtcbiAgICAgIH1cblxuICAgICAgaWYgKGR1cmF0aW9uICYmIGJwbSkge1xuICAgICAgICBjdHguc2V0Rm9udChmb250LmZhbWlseSwgZm9udC5zaXplLCAnbm9ybWFsJyk7XG5cbiAgICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgICB4ICs9IGN0eC5tZWFzdXJlVGV4dChcIiBcIikud2lkdGg7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KFwiKFwiLCB4LCB5KTtcbiAgICAgICAgICB4ICs9IGN0eC5tZWFzdXJlVGV4dChcIihcIikud2lkdGg7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgY29kZSA9IFZleC5GbG93LmR1cmF0aW9uVG9HbHlwaChkdXJhdGlvbik7XG5cbiAgICAgICAgeCArPSAzICogc2NhbGU7XG4gICAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKGN0eCwgeCwgeSwgb3B0aW9ucy5nbHlwaF9mb250X3NjYWxlLCBjb2RlLmNvZGVfaGVhZCk7XG4gICAgICAgIHggKz0gY29kZS5oZWFkX3dpZHRoICogc2NhbGU7XG5cbiAgICAgICAgLy8gRHJhdyBzdGVtIGFuZCBmbGFnc1xuICAgICAgICBpZiAoY29kZS5zdGVtKSB7XG4gICAgICAgICAgdmFyIHN0ZW1faGVpZ2h0ID0gMzA7XG5cbiAgICAgICAgICBpZiAoY29kZS5iZWFtX2NvdW50KSBzdGVtX2hlaWdodCArPSAzICogKGNvZGUuYmVhbV9jb3VudCAtIDEpO1xuXG4gICAgICAgICAgc3RlbV9oZWlnaHQgKj0gc2NhbGU7XG5cbiAgICAgICAgICB2YXIgeV90b3AgPSB5IC0gc3RlbV9oZWlnaHQ7XG4gICAgICAgICAgY3R4LmZpbGxSZWN0KHgsIHlfdG9wLCBzY2FsZSwgc3RlbV9oZWlnaHQpO1xuXG4gICAgICAgICAgaWYgKGNvZGUuZmxhZykge1xuICAgICAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgoY3R4LCB4ICsgc2NhbGUsIHlfdG9wLCBvcHRpb25zLmdseXBoX2ZvbnRfc2NhbGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlLmNvZGVfZmxhZ191cHN0ZW0pO1xuXG4gICAgICAgICAgICBpZiAoIWRvdHMpIHggKz0gNiAqIHNjYWxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERyYXcgZG90XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZG90czsgaSsrKSB7XG4gICAgICAgICAgeCArPSA2ICogc2NhbGU7XG4gICAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICAgIGN0eC5hcmMoeCwgeSArIDIgKiBzY2FsZSwgMiAqIHNjYWxlLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xuICAgICAgICAgIGN0eC5maWxsKCk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHguZmlsbFRleHQoXCIgPSBcIiArIGJwbSArIChuYW1lID8gXCIpXCIgOiBcIlwiKSwgeCArIDMgKiBzY2FsZSwgeSk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBTdGF2ZVRlbXBvO1xufSgpKTtcblxuLy8gVmV4RmxvdyAtIE11c2ljIEVuZ3JhdmluZyBmb3IgSFRNTDVcbi8vIENvcHlyaWdodCBNb2hpdCBNdXRoYW5uYSAyMDEwXG4vL1xuLy8gQXV0aG9yIFRhZWhvb24gTW9vbiAyMDE0XG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblZleC5GbG93LlN0YXZlVGV4dCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gU3RhdmVUZXh0KHRleHQsIHBvc2l0aW9uLCBvcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGV4dCwgcG9zaXRpb24sIG9wdGlvbnMpO1xuICB9XG5cbiAgdmFyIE1vZGlmaWVyID0gVmV4LkZsb3cuTW9kaWZpZXI7XG4gIFZleC5Jbmhlcml0KFN0YXZlVGV4dCwgTW9kaWZpZXIsIHtcbiAgICBpbml0OiBmdW5jdGlvbih0ZXh0LCBwb3NpdGlvbiwgb3B0aW9ucykge1xuICAgICAgU3RhdmVUZXh0LnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMpO1xuXG4gICAgICB0aGlzLnNldFdpZHRoKDE2KTtcbiAgICAgIHRoaXMudGV4dCA9IHRleHQ7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gcG9zaXRpb247XG4gICAgICB0aGlzLm9wdGlvbnMgPSB7XG4gICAgICAgIHNoaWZ0X3g6IDAsXG4gICAgICAgIHNoaWZ0X3k6IDAsXG4gICAgICAgIGp1c3RpZmljYXRpb246IFZleC5GbG93LlRleHROb3RlLkp1c3RpZmljYXRpb24uQ0VOVEVSXG4gICAgICB9O1xuICAgICAgVmV4Lk1lcmdlKHRoaXMub3B0aW9ucywgb3B0aW9ucyk7XG5cbiAgICAgIHRoaXMuZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiBcInRpbWVzXCIsXG4gICAgICAgIHNpemU6IDE2LFxuICAgICAgICB3ZWlnaHQ6IFwibm9ybWFsXCJcbiAgICAgIH07XG4gICAgfSxcblxuICAgIGdldENhdGVnb3J5OiBmdW5jdGlvbigpIHsgcmV0dXJuIFwic3RhdmV0ZXh0XCI7IH0sXG4gICAgc2V0U3RhdmVUZXh0OiBmdW5jdGlvbih0ZXh0KSB7IHRoaXMudGV4dCA9IHRleHQ7IHJldHVybiB0aGlzOyB9LFxuICAgIHNldFNoaWZ0WDogZnVuY3Rpb24oeCkgeyB0aGlzLnNoaWZ0X3ggPSB4OyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRTaGlmdFk6IGZ1bmN0aW9uKHkpIHsgdGhpcy5zaGlmdF95ID0geTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICBzZXRGb250OiBmdW5jdGlvbihmb250KSB7XG4gICAgICBWZXguTWVyZ2UodGhpcy5mb250LCBmb250KTtcbiAgICB9LFxuXG4gICAgc2V0VGV4dDogZnVuY3Rpb24odGV4dCkge1xuICAgICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oc3RhdmUpIHtcbiAgICAgIGlmICghc3RhdmUuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9Db250ZXh0XCIsXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBzdGF2ZSB0ZXh0IHdpdGhvdXQgYSBjb250ZXh0LlwiKTtcblxuICAgICAgdmFyIGN0eCA9IHN0YXZlLmNvbnRleHQ7XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgubGluZVdpZHRoID0gMjtcbiAgICAgIGN0eC5zZXRGb250KHRoaXMuZm9udC5mYW1pbHksIHRoaXMuZm9udC5zaXplLCB0aGlzLmZvbnQud2VpZ2h0KTtcbiAgICAgIHZhciB0ZXh0X3dpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KFwiXCIgKyB0aGlzLnRleHQpLndpZHRoO1xuXG4gICAgICB2YXIgeCwgeTtcbiAgICAgIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xuICAgICAgc3dpdGNoKHRoaXMucG9zaXRpb24pIHtcbiAgICAgICAgY2FzZSBNb2RpZmllci5Qb3NpdGlvbi5MRUZUOlxuICAgICAgICBjYXNlIE1vZGlmaWVyLlBvc2l0aW9uLlJJR0hUOlxuICAgICAgICAgIHkgPSAoc3RhdmUuZ2V0WUZvckxpbmUoMCkgKyBzdGF2ZS5nZXRCb3R0b21MaW5lWSgpKSAvIDIgKyB0aGlzLm9wdGlvbnMuc2hpZnRfeTtcbiAgICAgICAgICBpZih0aGlzLnBvc2l0aW9uID09IE1vZGlmaWVyLlBvc2l0aW9uLkxFRlQpIHtcbiAgICAgICAgICAgIHggPSBzdGF2ZS5nZXRYKCkgLSB0ZXh0X3dpZHRoIC0gMjQgKyB0aGlzLm9wdGlvbnMuc2hpZnRfeDtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB4ID0gc3RhdmUuZ2V0WCgpICsgc3RhdmUuZ2V0V2lkdGgoKSArIDI0ICsgdGhpcy5vcHRpb25zLnNoaWZ0X3g7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIE1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFOlxuICAgICAgICBjYXNlIE1vZGlmaWVyLlBvc2l0aW9uLkJFTE9XOlxuICAgICAgICAgIHZhciBKdXN0aWZpY2F0aW9uID0gVmV4LkZsb3cuVGV4dE5vdGUuSnVzdGlmaWNhdGlvbjtcbiAgICAgICAgICB4ID0gc3RhdmUuZ2V0WCgpICsgdGhpcy5vcHRpb25zLnNoaWZ0X3g7XG4gICAgICAgICAgaWYodGhpcy5vcHRpb25zLmp1c3RpZmljYXRpb24gPT0gSnVzdGlmaWNhdGlvbi5DRU5URVIpIHtcbiAgICAgICAgICAgIHggKz0gc3RhdmUuZ2V0V2lkdGgoKSAvIDIgLSB0ZXh0X3dpZHRoIC8gMjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSBpZih0aGlzLm9wdGlvbnMuanVzdGlmaWNhdGlvbiA9PSBKdXN0aWZpY2F0aW9uLlJJR0hUKSB7XG4gICAgICAgICAgICB4ICs9IHN0YXZlLmdldFdpZHRoKCkgLSB0ZXh0X3dpZHRoO1xuICAgICAgICAgIH1cbiAgICAgICAgICBcbiAgICAgICAgICBpZih0aGlzLnBvc2l0aW9uID09IE1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFKSB7XG4gICAgICAgICAgICB5ID0gc3RhdmUuZ2V0WUZvclRvcFRleHQoMikgKyB0aGlzLm9wdGlvbnMuc2hpZnRfeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB5ID0gc3RhdmUuZ2V0WUZvckJvdHRvbVRleHQoMikgKyB0aGlzLm9wdGlvbnMuc2hpZnRfeTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiSW52YWxpZFBvc2l0aW9uXCIsXG4gICAgICAgICAgICBcIlZhbHVlIE11c3QgYmUgaW4gTW9kaWZpZXIuUG9zaXRpb24uXCIpO1xuICAgICAgfVxuXG4gICAgICBjdHguZmlsbFRleHQoXCJcIiArIHRoaXMudGV4dCwgeCwgeSArIDQpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFN0YXZlVGV4dDtcbn0oKSk7XG5cbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gQSBgQmFyTm90ZWAgaXMgdXNlZCB0byByZW5kZXIgYmFyIGxpbmVzIChmcm9tIGBiYXJsaW5lLmpzYCkuIGBCYXJOb3RlYHMgY2FuXG4vLyBiZSBhZGRlZCB0byBhIHZvaWNlIGFuZCByZW5kZXJlZCBpbiB0aGUgbWlkZGxlIG9mIGEgc3RhdmUuIFNpbmNlIGl0IGhhcyBub1xuLy8gZHVyYXRpb24sIGl0IGNvbnN1bWVzIG5vIGB0aWNrYHMsIGFuZCBpcyBkZWFsdCB3aXRoIGFwcHJvcHJpYXRlbHkgYnkgdGhlIGZvcm1hdHRlci5cbi8vXG4vLyBTZWUgYHRlc3RzL2Jhcm5vdGVfdGVzdHMuanNgIGZvciB1c2FnZSBleGFtcGxlcy5cblxuVmV4LkZsb3cuQmFyTm90ZSA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gQmFyTm90ZSgpIHsgdGhpcy5pbml0KCk7IH1cblxuICAvLyBUbyBlbmFibGUgbG9nZ2luZyBmb3IgdGhpcyBjbGFzcy4gU2V0IGBWZXguRmxvdy5CYXJOb3RlLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChCYXJOb3RlLkRFQlVHKSBWZXguTChcIlZleC5GbG93LkJhck5vdGVcIiwgYXJndW1lbnRzKTsgfVxuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIFZleC5Jbmhlcml0KEJhck5vdGUsIFZleC5GbG93Lk5vdGUsIHtcbiAgICBpbml0OiBmdW5jdGlvbigpIHtcbiAgICAgIEJhck5vdGUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywge2R1cmF0aW9uOiBcImJcIn0pO1xuXG4gICAgICB2YXIgVFlQRSA9IFZleC5GbG93LkJhcmxpbmUudHlwZTtcbiAgICAgIHRoaXMubWV0cmljcyA9IHtcbiAgICAgICAgd2lkdGhzOiB7fVxuICAgICAgfTtcblxuICAgICAgLy8gRGVmaW5lZCB0aGlzIHdheSB0byBwcmV2ZW50IGxpbnQgZXJyb3JzLlxuICAgICAgdGhpcy5tZXRyaWNzLndpZHRoc1tUWVBFLlNJTkdMRV0gPSA4O1xuICAgICAgdGhpcy5tZXRyaWNzLndpZHRoc1tUWVBFLkRPVUJMRV0gPSAxMjtcbiAgICAgIHRoaXMubWV0cmljcy53aWR0aHNbVFlQRS5FTkRdID0gMTU7XG4gICAgICB0aGlzLm1ldHJpY3Mud2lkdGhzW1RZUEUuUkVQRUFUX0JFR0lOXSA9IDE0O1xuICAgICAgdGhpcy5tZXRyaWNzLndpZHRoc1tUWVBFLlJFUEVBVF9FTkRdID0gMTQ7XG4gICAgICB0aGlzLm1ldHJpY3Mud2lkdGhzW1RZUEUuUkVQRUFUX0JPVEhdID0gMTg7XG4gICAgICB0aGlzLm1ldHJpY3Mud2lkdGhzW1RZUEUuTk9ORV0gPSAwO1xuXG4gICAgICAvLyBUZWxsIHRoZSBmb3JtYXR0ZXIgdGhhdCBiYXIgbm90ZXMgaGF2ZSBubyBkdXJhdGlvbi5cbiAgICAgIHRoaXMuaWdub3JlX3RpY2tzID0gdHJ1ZTtcbiAgICAgIHRoaXMudHlwZSA9IFRZUEUuU0lOR0xFO1xuXG4gICAgICAvLyBTZXQgd2lkdGggdG8gd2lkdGggb2YgcmVsZXZhbnQgYEJhcmxpbmVgLlxuICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLm1ldHJpY3Mud2lkdGhzW3RoaXMudHlwZV0pO1xuICAgIH0sXG5cbiAgICAvLyBHZXQgYW5kIHNldCB0aGUgdHlwZSBvZiBCYXIgbm90ZS4gYHR5cGVgIG11c3QgYmUgb25lIG9mIGBWZXguRmxvdy5CYXJsaW5lLnR5cGVgLlxuICAgIGdldFR5cGU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy50eXBlOyB9LFxuICAgIHNldFR5cGU6IGZ1bmN0aW9uKHR5cGUpIHtcbiAgICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgICB0aGlzLnNldFdpZHRoKHRoaXMubWV0cmljcy53aWR0aHNbdGhpcy50eXBlXSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgZ2V0Qm91bmRpbmdCb3g6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIG5ldyBWZXguRmxvdy5Cb3VuZGluZ0JveCgwLCAwLCAwLCAwKTtcbiAgICB9LFxuXG4gICAgYWRkVG9Nb2RpZmllckNvbnRleHQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLyogb3ZlcnJpZGRlbiB0byBpZ25vcmUgKi9cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICBwcmVGb3JtYXQ6IGZ1bmN0aW9uKCkge1xuICAgICAgLyogb3ZlcnJpZGRlbiB0byBpZ25vcmUgKi9cbiAgICAgIHRoaXMuc2V0UHJlRm9ybWF0dGVkKHRydWUpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFJlbmRlciBub3RlIHRvIHN0YXZlLlxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLnN0YXZlKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1N0YXZlXCIsIFwiQ2FuJ3QgZHJhdyB3aXRob3V0IGEgc3RhdmUuXCIpO1xuICAgICAgTChcIlJlbmRlcmluZyBiYXIgbGluZSBhdDogXCIsIHRoaXMuZ2V0QWJzb2x1dGVYKCkpO1xuICAgICAgdmFyIGJhcmxpbmUgPSBuZXcgVmV4LkZsb3cuQmFybGluZSh0aGlzLnR5cGUsIHRoaXMuZ2V0QWJzb2x1dGVYKCkpO1xuICAgICAgYmFybGluZS5kcmF3KHRoaXMuc3RhdmUpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIEJhck5vdGU7XG59KCkpO1xuXG4vLyBWZXhGbG93IC0gTXVzaWMgRW5ncmF2aW5nIGZvciBIVE1MNVxuLy8gQXV0aG9yOiBNaWtlIENvcnJpZ2FuIDxjb3JyaWdhbkBnbWFpbC5jb20+XG4vL1xuLy8gVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRyZW1vbG8gbm90YXRpb24uXG5cbi8qKlxuICogQGNvbnN0cnVjdG9yXG4gKi9cblZleC5GbG93LlRyZW1vbG8gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRyZW1vbG8obnVtKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQobnVtKTtcbiAgfVxuXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xuICBWZXguSW5oZXJpdChUcmVtb2xvLCBNb2RpZmllciwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG51bSkge1xuICAgICAgVHJlbW9sby5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5udW0gPSBudW07XG4gICAgICB0aGlzLm5vdGUgPSBudWxsO1xuICAgICAgdGhpcy5pbmRleCA9IG51bGw7XG4gICAgICB0aGlzLnBvc2l0aW9uID0gTW9kaWZpZXIuUG9zaXRpb24uQ0VOVEVSO1xuICAgICAgdGhpcy5jb2RlID0gXCJ2NzRcIjtcbiAgICAgIHRoaXMuc2hpZnRfcmlnaHQgPSAtMjtcbiAgICAgIHRoaXMueV9zcGFjaW5nID0gNDtcblxuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgZm9udF9zY2FsZTogMzUsXG4gICAgICAgIHN0cm9rZV9weDogMyxcbiAgICAgICAgc3Ryb2tlX3NwYWNpbmc6IDEwXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmZvbnQgPSB7XG4gICAgICAgIGZhbWlseTogXCJBcmlhbFwiLFxuICAgICAgICBzaXplOiAxNixcbiAgICAgICAgd2VpZ2h0OiBcIlwiXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICBnZXRDYXRlZ29yeTogZnVuY3Rpb24oKSB7IHJldHVybiBcInRyZW1vbG9cIjsgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgVHJlbW9sbyB3aXRob3V0IGEgY29udGV4dC5cIik7XG4gICAgICBpZiAoISh0aGlzLm5vdGUgJiYgKHRoaXMuaW5kZXggIT0gbnVsbCkpKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0F0dGFjaGVkTm90ZVwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgVHJlbW9sbyB3aXRob3V0IGEgbm90ZSBhbmQgaW5kZXguXCIpO1xuXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLm5vdGUuZ2V0TW9kaWZpZXJTdGFydFhZKHRoaXMucG9zaXRpb24sIHRoaXMuaW5kZXgpO1xuICAgICAgdmFyIHggPSBzdGFydC54O1xuICAgICAgdmFyIHkgPSBzdGFydC55O1xuXG4gICAgICB4ICs9IHRoaXMuc2hpZnRfcmlnaHQ7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMubnVtOyArK2kpIHtcbiAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgodGhpcy5jb250ZXh0LCB4LCB5LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLmZvbnRfc2NhbGUsIHRoaXMuY29kZSk7XG4gICAgICAgIHkgKz0gdGhpcy55X3NwYWNpbmc7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gVHJlbW9sbztcbn0oKSk7XG5cbi8qKlxuICogQ3JlYXRlIGEgbmV3IHR1cGxldCBmcm9tIHRoZSBzcGVjaWZpZWQgbm90ZXMuIFRoZSBub3RlcyBtdXN0XG4gKiBiZSBwYXJ0IG9mIHRoZSBzYW1lIGxpbmUsIGFuZCBoYXZlIHRoZSBzYW1lIGR1cmF0aW9uIChpbiB0aWNrcykuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge0FycmF5LjxWZXguRmxvdy5TdGF2ZU5vdGU+fSBBIHNldCBvZiBub3Rlcy5cbiAqL1xuVmV4LkZsb3cuVHVwbGV0ID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBUdXBsZXQobm90ZXMsIG9wdGlvbnMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChub3Rlcywgb3B0aW9ucyk7XG4gIH1cblxuICBUdXBsZXQuTE9DQVRJT05fVE9QID0gMTtcbiAgVHVwbGV0LkxPQ0FUSU9OX0JPVFRPTSA9IC0xO1xuXG4gIFR1cGxldC5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24obm90ZXMsIG9wdGlvbnMpIHtcbiAgICAgIGlmICghbm90ZXMgfHwgbm90ZXMgPT0gW10pIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIiwgXCJObyBub3RlcyBwcm92aWRlZCBmb3IgdHVwbGV0LlwiKTtcbiAgICAgIH1cblxuICAgICAgaWYgKG5vdGVzLmxlbmd0aCA9PSAxKSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiQmFkQXJndW1lbnRzXCIsIFwiVG9vIGZldyBub3RlcyBmb3IgdHVwbGV0LlwiKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5vcHRpb25zID0gVmV4Lk1lcmdlKHt9LCBvcHRpb25zKTtcbiAgICAgIHRoaXMubm90ZXMgPSBub3RlcztcbiAgICAgIHRoaXMubnVtX25vdGVzID0gJ251bV9ub3RlcycgaW4gdGhpcy5vcHRpb25zID9cbiAgICAgICAgdGhpcy5vcHRpb25zLm51bV9ub3RlcyA6IG5vdGVzLmxlbmd0aDtcbiAgICAgIHRoaXMuYmVhdHNfb2NjdXBpZWQgPSAnYmVhdHNfb2NjdXBpZWQnIGluIHRoaXMub3B0aW9ucyA/XG4gICAgICAgIHRoaXMub3B0aW9ucy5iZWF0c19vY2N1cGllZCA6IDI7XG4gICAgICB0aGlzLmJyYWNrZXRlZCA9IChub3Rlc1swXS5iZWFtID09IG51bGwpO1xuICAgICAgdGhpcy5yYXRpb2VkID0gZmFsc2U7XG4gICAgICB0aGlzLnBvaW50ID0gMjg7XG4gICAgICB0aGlzLnlfcG9zID0gMTY7XG4gICAgICB0aGlzLnhfcG9zID0gMTAwO1xuICAgICAgdGhpcy53aWR0aCA9IDIwMDtcbiAgICAgIHRoaXMubG9jYXRpb24gPSBUdXBsZXQuTE9DQVRJT05fVE9QO1xuXG4gICAgICBWZXguRmxvdy5Gb3JtYXR0ZXIuQWxpZ25SZXN0c1RvTm90ZXMobm90ZXMsIHRydWUsIHRydWUpO1xuICAgICAgdGhpcy5yZXNvbHZlR2x5cGhzKCk7XG4gICAgICB0aGlzLmF0dGFjaCgpO1xuICAgIH0sXG5cbiAgICBhdHRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub3Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm90ZSA9IHRoaXMubm90ZXNbaV07XG4gICAgICAgIG5vdGUuc2V0VHVwbGV0KHRoaXMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBkZXRhY2g6IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5ub3Rlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbm90ZSA9IHRoaXMubm90ZXNbaV07XG4gICAgICAgIG5vdGUuc2V0VHVwbGV0KG51bGwpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBzZXRDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7XG4gICAgICB0aGlzLmNvbnRleHQgPSBjb250ZXh0O1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB3aGV0aGVyIG9yIG5vdCB0aGUgYnJhY2tldCBpcyBkcmF3bi5cbiAgICAgKi9cbiAgICBzZXRCcmFja2V0ZWQ6IGZ1bmN0aW9uKGJyYWNrZXRlZCkge1xuICAgICAgdGhpcy5icmFja2V0ZWQgPSBicmFja2V0ZWQgPyB0cnVlIDogZmFsc2U7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLyoqXG4gICAgICogU2V0IHdoZXRoZXIgb3Igbm90IHRoZSByYXRpbyBpcyBzaG93bi5cbiAgICAgKi9cbiAgICBzZXRSYXRpb2VkOiBmdW5jdGlvbihyYXRpb2VkKSB7XG4gICAgICB0aGlzLnJhdGlvZWQgPSByYXRpb2VkID8gdHJ1ZSA6IGZhbHNlO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8qKlxuICAgICAqIFNldCB0aGUgdHVwbGV0IHRvIGJlIGRpc3BsYXllZCBlaXRoZXIgb24gdGhlIHRvcCBvciBib3R0b20gb2YgdGhlIHN0YXZlXG4gICAgICovXG4gICAgc2V0VHVwbGV0TG9jYXRpb246IGZ1bmN0aW9uKGxvY2F0aW9uKSB7XG4gICAgICBpZiAoIWxvY2F0aW9uKSBsb2NhdGlvbiA9IFR1cGxldC5MT0NBVElPTl9UT1A7XG4gICAgICBlbHNlIGlmIChsb2NhdGlvbiAhPSBUdXBsZXQuTE9DQVRJT05fVE9QICYmXG4gICAgICAgICAgbG9jYXRpb24gIT0gVHVwbGV0LkxPQ0FUSU9OX0JPVFRPTSkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJCYWRBcmd1bWVudFwiLCBcIkludmFsaWQgdHVwbGV0IGxvY2F0aW9uOiBcIiArIGxvY2F0aW9uKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5sb2NhdGlvbiA9IGxvY2F0aW9uO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGdldE5vdGVzOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLm5vdGVzO1xuICAgIH0sXG5cbiAgICBnZXROb3RlQ291bnQ6IGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIHRoaXMubnVtX25vdGVzO1xuICAgIH0sXG5cbiAgICBnZXRCZWF0c09jY3VwaWVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiB0aGlzLmJlYXRzX29jY3VwaWVkO1xuICAgIH0sXG5cbiAgICBzZXRCZWF0c09jY3VwaWVkOiBmdW5jdGlvbihiZWF0cykge1xuICAgICAgdGhpcy5kZXRhY2goKTtcbiAgICAgIHRoaXMuYmVhdHNfb2NjdXBpZWQgPSBiZWF0cztcbiAgICAgIHRoaXMucmVzb2x2ZUdseXBocygpO1xuICAgICAgdGhpcy5hdHRhY2goKTtcbiAgICB9LFxuXG4gICAgcmVzb2x2ZUdseXBoczogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLm51bV9nbHlwaHMgPSBbXTtcbiAgICAgIHZhciBuID0gdGhpcy5udW1fbm90ZXM7XG4gICAgICB3aGlsZSAobiA+PSAxKSB7XG4gICAgICAgIHRoaXMubnVtX2dseXBocy5wdXNoKG5ldyBWZXguRmxvdy5HbHlwaChcInZcIiArIChuICUgMTApLCB0aGlzLnBvaW50KSk7XG4gICAgICAgIG4gPSBwYXJzZUludChuIC8gMTAsIDEwKTtcbiAgICAgIH1cblxuICAgICAgdGhpcy5kZW5vbV9nbHlwaHMgPSBbXTtcbiAgICAgIG4gPSB0aGlzLmJlYXRzX29jY3VwaWVkO1xuICAgICAgd2hpbGUgKG4gPj0gMSkge1xuICAgICAgICB0aGlzLmRlbm9tX2dseXBocy5wdXNoKG5ldyBWZXguRmxvdy5HbHlwaChcInZcIiArIChuICUgMTApLCB0aGlzLnBvaW50KSk7XG4gICAgICAgIG4gPSBwYXJzZUludChuIC8gMTAsIDEwKTtcbiAgICAgIH1cbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9DYW52YXNDb250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IHdpdGhvdXQgYSBjYW52YXMgY29udGV4dC5cIik7XG5cbiAgICAgIC8vIGRldGVybWluZSB4IHZhbHVlIG9mIGxlZnQgYm91bmQgb2YgdHVwbGV0XG4gICAgICB2YXIgZmlyc3Rfbm90ZSA9IHRoaXMubm90ZXNbMF07XG4gICAgICB2YXIgbGFzdF9ub3RlID0gdGhpcy5ub3Rlc1t0aGlzLm5vdGVzLmxlbmd0aCAtIDFdO1xuXG4gICAgICBpZiAoIXRoaXMuYnJhY2tldGVkKSB7XG4gICAgICAgIHRoaXMueF9wb3MgPSBmaXJzdF9ub3RlLmdldFN0ZW1YKCk7XG4gICAgICAgIHRoaXMud2lkdGggPSBsYXN0X25vdGUuZ2V0U3RlbVgoKSAtIHRoaXMueF9wb3M7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgdGhpcy54X3BvcyA9IGZpcnN0X25vdGUuZ2V0VGllTGVmdFgoKSAtIDU7XG4gICAgICAgIHRoaXMud2lkdGggPSBsYXN0X25vdGUuZ2V0VGllUmlnaHRYKCkgLSB0aGlzLnhfcG9zICsgNTtcbiAgICAgIH1cblxuICAgICAgLy8gZGV0ZXJtaW5lIHkgdmFsdWUgZm9yIHR1cGxldFxuICAgICAgdmFyIGk7XG4gICAgICBpZiAodGhpcy5sb2NhdGlvbiA9PSBUdXBsZXQuTE9DQVRJT05fVE9QKSB7XG4gICAgICAgIHRoaXMueV9wb3MgPSBmaXJzdF9ub3RlLmdldFN0YXZlKCkuZ2V0WUZvckxpbmUoMCkgLSAxNTtcbiAgICAgICAgLy90aGlzLnlfcG9zID0gZmlyc3Rfbm90ZS5nZXRTdGVtRXh0ZW50cygpLnRvcFkgLSAxMDtcblxuICAgICAgICBmb3IgKGk9MDsgaTx0aGlzLm5vdGVzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAgdmFyIHRvcF95ID0gdGhpcy5ub3Rlc1tpXS5nZXRTdGVtRGlyZWN0aW9uKCkgPT09IFZleC5GbG93LlN0ZW0uVVAgP1xuICAgICAgICAgICAgICB0aGlzLm5vdGVzW2ldLmdldFN0ZW1FeHRlbnRzKCkudG9wWSAtIDEwXG4gICAgICAgICAgICA6IHRoaXMubm90ZXNbaV0uZ2V0U3RlbUV4dGVudHMoKS5iYXNlWSAtIDIwO1xuICAgICAgICAgIGlmICh0b3BfeSA8IHRoaXMueV9wb3MpXG4gICAgICAgICAgICB0aGlzLnlfcG9zID0gdG9wX3k7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnlfcG9zID0gZmlyc3Rfbm90ZS5nZXRTdGF2ZSgpLmdldFlGb3JMaW5lKDQpICsgMjA7XG5cbiAgICAgICAgZm9yIChpPTA7IGk8dGhpcy5ub3Rlcy5sZW5ndGg7ICsraSkge1xuICAgICAgICAgIHZhciBib3R0b21feSA9IHRoaXMubm90ZXNbaV0uZ2V0U3RlbURpcmVjdGlvbigpID09PSBWZXguRmxvdy5TdGVtLlVQID9cbiAgICAgICAgICAgICAgdGhpcy5ub3Rlc1tpXS5nZXRTdGVtRXh0ZW50cygpLmJhc2VZICsgMjBcbiAgICAgICAgICAgIDogdGhpcy5ub3Rlc1tpXS5nZXRTdGVtRXh0ZW50cygpLnRvcFkgKyAxMDtcbiAgICAgICAgICBpZiAoYm90dG9tX3kgPiB0aGlzLnlfcG9zKVxuICAgICAgICAgICAgdGhpcy55X3BvcyA9IGJvdHRvbV95O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIGNhbGN1bGF0ZSB0b3RhbCB3aWR0aCBvZiB0dXBsZXQgbm90YXRpb25cbiAgICAgIHZhciB3aWR0aCA9IDA7XG4gICAgICB2YXIgZ2x5cGg7XG4gICAgICBmb3IgKGdseXBoIGluIHRoaXMubnVtX2dseXBocykge1xuICAgICAgICB3aWR0aCArPSB0aGlzLm51bV9nbHlwaHNbZ2x5cGhdLmdldE1ldHJpY3MoKS53aWR0aDtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLnJhdGlvZWQpIHtcbiAgICAgICAgZm9yIChnbHlwaCBpbiB0aGlzLmRlbm9tX2dseXBocykge1xuICAgICAgICAgIHdpZHRoICs9IHRoaXMuZGVub21fZ2x5cGhzW2dseXBoXS5nZXRNZXRyaWNzKCkud2lkdGg7XG4gICAgICAgIH1cbiAgICAgICAgd2lkdGggKz0gdGhpcy5wb2ludCAqIDAuMzI7XG4gICAgICB9XG5cbiAgICAgIHZhciBub3RhdGlvbl9jZW50ZXJfeCA9IHRoaXMueF9wb3MgKyAodGhpcy53aWR0aC8yKTtcbiAgICAgIHZhciBub3RhdGlvbl9zdGFydF94ID0gbm90YXRpb25fY2VudGVyX3ggLSAod2lkdGgvMik7XG5cbiAgICAgIC8vIGRyYXcgYnJhY2tldCBpZiB0aGUgdHVwbGV0IGlzIG5vdCBiZWFtZWRcbiAgICAgIGlmICh0aGlzLmJyYWNrZXRlZCkge1xuICAgICAgICB2YXIgbGluZV93aWR0aCA9IHRoaXMud2lkdGgvMiAtIHdpZHRoLzIgLSA1O1xuXG4gICAgICAgIC8vIG9ubHkgZHJhdyB0aGUgYnJhY2tldCBpZiBpdCBoYXMgcG9zaXRpdmUgbGVuZ3RoXG4gICAgICAgIGlmIChsaW5lX3dpZHRoID4gMCkge1xuICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCh0aGlzLnhfcG9zLCB0aGlzLnlfcG9zLGxpbmVfd2lkdGgsIDEpO1xuICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCh0aGlzLnhfcG9zICsgdGhpcy53aWR0aCAvIDIgKyB3aWR0aCAvIDIgKyA1LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnlfcG9zLGxpbmVfd2lkdGgsIDEpO1xuICAgICAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCh0aGlzLnhfcG9zLFxuICAgICAgICAgICAgICB0aGlzLnlfcG9zICsgKHRoaXMubG9jYXRpb24gPT0gVHVwbGV0LkxPQ0FUSU9OX0JPVFRPTSksXG4gICAgICAgICAgICAgIDEsIHRoaXMubG9jYXRpb24gKiAxMCk7XG4gICAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxSZWN0KHRoaXMueF9wb3MgKyB0aGlzLndpZHRoLFxuICAgICAgICAgICAgICB0aGlzLnlfcG9zICsgKHRoaXMubG9jYXRpb24gPT0gVHVwbGV0LkxPQ0FUSU9OX0JPVFRPTSksXG4gICAgICAgICAgICAgIDEsIHRoaXMubG9jYXRpb24gKiAxMCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gZHJhdyBudW1lcmF0b3IgZ2x5cGhzXG4gICAgICB2YXIgeF9vZmZzZXQgPSAwO1xuICAgICAgdmFyIHNpemUgPSB0aGlzLm51bV9nbHlwaHMubGVuZ3RoO1xuICAgICAgZm9yIChnbHlwaCBpbiB0aGlzLm51bV9nbHlwaHMpIHtcbiAgICAgICAgdGhpcy5udW1fZ2x5cGhzW3NpemUtZ2x5cGgtMV0ucmVuZGVyKFxuICAgICAgICAgICAgdGhpcy5jb250ZXh0LCBub3RhdGlvbl9zdGFydF94ICsgeF9vZmZzZXQsXG4gICAgICAgICAgICB0aGlzLnlfcG9zICsgKHRoaXMucG9pbnQvMykgLSAyKTtcbiAgICAgICAgeF9vZmZzZXQgKz0gdGhpcy5udW1fZ2x5cGhzW3NpemUtZ2x5cGgtMV0uZ2V0TWV0cmljcygpLndpZHRoO1xuICAgICAgfVxuXG4gICAgICAvLyBkaXNwbGF5IGNvbG9uIGFuZCBkZW5vbWluYXRvciBpZiB0aGUgcmF0aW8gaXMgdG8gYmUgc2hvd25cbiAgICAgIGlmICh0aGlzLnJhdGlvZWQpIHtcbiAgICAgICAgdmFyIGNvbG9uX3ggPSBub3RhdGlvbl9zdGFydF94ICsgeF9vZmZzZXQgKyB0aGlzLnBvaW50KjAuMTY7XG4gICAgICAgIHZhciBjb2xvbl9yYWRpdXMgPSB0aGlzLnBvaW50ICogMC4wNjtcbiAgICAgICAgdGhpcy5jb250ZXh0LmJlZ2luUGF0aCgpO1xuICAgICAgICB0aGlzLmNvbnRleHQuYXJjKGNvbG9uX3gsIHRoaXMueV9wb3MgLSB0aGlzLnBvaW50KjAuMDgsXG4gICAgICAgICAgICAgICAgICAgICAgICAgY29sb25fcmFkaXVzLCAwLCBNYXRoLlBJKjIsIHRydWUpO1xuICAgICAgICB0aGlzLmNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5maWxsKCk7XG4gICAgICAgIHRoaXMuY29udGV4dC5iZWdpblBhdGgoKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmFyYyhjb2xvbl94LCB0aGlzLnlfcG9zICsgdGhpcy5wb2ludCowLjEyLFxuICAgICAgICAgICAgICAgICAgICAgICAgIGNvbG9uX3JhZGl1cywgMCwgTWF0aC5QSSoyLCB0cnVlKTtcbiAgICAgICAgdGhpcy5jb250ZXh0LmNsb3NlUGF0aCgpO1xuICAgICAgICB0aGlzLmNvbnRleHQuZmlsbCgpO1xuICAgICAgICB4X29mZnNldCArPSB0aGlzLnBvaW50KjAuMzI7XG4gICAgICAgIHNpemUgPSB0aGlzLmRlbm9tX2dseXBocy5sZW5ndGg7XG4gICAgICAgIGZvciAoZ2x5cGggaW4gdGhpcy5kZW5vbV9nbHlwaHMpIHtcbiAgICAgICAgICB0aGlzLmRlbm9tX2dseXBoc1tzaXplLWdseXBoLTFdLnJlbmRlcihcbiAgICAgICAgICAgICAgdGhpcy5jb250ZXh0LCBub3RhdGlvbl9zdGFydF94ICsgeF9vZmZzZXQsXG4gICAgICAgICAgICAgIHRoaXMueV9wb3MgKyAodGhpcy5wb2ludC8zKSAtIDIpO1xuICAgICAgICAgIHhfb2Zmc2V0ICs9IHRoaXMuZGVub21fZ2x5cGhzW3NpemUtZ2x5cGgtMV0uZ2V0TWV0cmljcygpLndpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBUdXBsZXQ7XG59KCkpO1xuXG4vLyBWZXggTXVzaWMgTm90YXRpb25cbi8vIE1vaGl0IE11dGhhbm5hIDxtb2hpdEBtdXRoYW5uYS5jb20+XG4vL1xuLy8gQ29weXJpZ2h0IE1vaGl0IE11dGhhbm5hIDIwMTBcblxuLy8gQm91bmRpbmcgYm94ZXMgZm9yIGludGVyYWN0aXZlIG5vdGF0aW9uXG5cbi8qKiBAY29uc3RydWN0b3IgKi9cblZleC5GbG93LkJvdW5kaW5nQm94ID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBCb3VuZGluZ0JveCh4LCB5LCB3LCBoKSB7IHRoaXMuaW5pdCh4LCB5LCB3LCBoKTsgfVxuICBCb3VuZGluZ0JveC5jb3B5ID0gZnVuY3Rpb24odGhhdCkge1xuICAgIHJldHVybiBuZXcgQm91bmRpbmdCb3godGhhdC54LCB0aGF0LnksIHRoYXQudywgdGhhdC5oKTsgfTtcblxuICBCb3VuZGluZ0JveC5wcm90b3R5cGUgPSB7XG4gICAgaW5pdDogZnVuY3Rpb24oeCwgeSwgdywgaCkge1xuICAgICAgdGhpcy54ID0geDtcbiAgICAgIHRoaXMueSA9IHk7XG4gICAgICB0aGlzLncgPSB3O1xuICAgICAgdGhpcy5oID0gaDtcbiAgICB9LFxuXG4gICAgZ2V0WDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLng7IH0sXG4gICAgZ2V0WTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnk7IH0sXG4gICAgZ2V0VzogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLnc7IH0sXG4gICAgZ2V0SDogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLmg7IH0sXG5cbiAgICBzZXRYOiBmdW5jdGlvbih4KSB7IHRoaXMueCA9IHg7IHJldHVybiB0aGlzOyB9LFxuICAgIHNldFk6IGZ1bmN0aW9uKHkpIHsgdGhpcy55ID0geTsgcmV0dXJuIHRoaXM7IH0sXG4gICAgc2V0VzogZnVuY3Rpb24odykgeyB0aGlzLncgPSB3OyByZXR1cm4gdGhpczsgfSxcbiAgICBzZXRIOiBmdW5jdGlvbihoKSB7IHRoaXMuaCA9IGg7IHJldHVybiB0aGlzOyB9LFxuXG4gICAgbW92ZTogZnVuY3Rpb24oeCwgeSkgeyB0aGlzLnggKz0geDsgdGhpcy55ICs9IHk7IH0sXG4gICAgY2xvbmU6IGZ1bmN0aW9uKCkgeyByZXR1cm4gQm91bmRpbmdCb3guY29weSh0aGlzKTsgfSxcblxuICAgIC8vIE1lcmdlIG15IGJveCB3aXRoIGdpdmVuIGJveC4gQ3JlYXRlcyBhIGJpZ2dlciBib3VuZGluZyBib3ggdW5sZXNzXG4gICAgLy8gdGhlIGdpdmVuIGJveCBpcyBjb250YWluZWQgaW4gdGhpcyBvbmUuXG4gICAgbWVyZ2VXaXRoOiBmdW5jdGlvbihib3VuZGluZ0JveCwgY3R4KSB7XG4gICAgICB2YXIgdGhhdCA9IGJvdW5kaW5nQm94O1xuXG4gICAgICB2YXIgbmV3X3ggPSB0aGlzLnggPCB0aGF0LnggPyB0aGlzLnggOiB0aGF0Lng7XG4gICAgICB2YXIgbmV3X3kgPSB0aGlzLnkgPCB0aGF0LnkgPyB0aGlzLnkgOiB0aGF0Lnk7XG4gICAgICB2YXIgbmV3X3cgPSAodGhpcy54ICsgdGhpcy53KSA8ICh0aGF0LnggKyB0aGF0LncpID8gKHRoYXQueCArIHRoYXQudykgLSB0aGlzLnggOiAodGhpcy54ICsgdGhpcy53KSAtIFZleC5NaW4odGhpcy54LCB0aGF0LngpO1xuICAgICAgdmFyIG5ld19oID0gKHRoaXMueSArIHRoaXMuaCkgPCAodGhhdC55ICsgdGhhdC5oKSA/ICh0aGF0LnkgKyB0aGF0LmgpIC0gdGhpcy55IDogKHRoaXMueSArIHRoaXMuaCkgLSBWZXguTWluKHRoaXMueSwgdGhhdC55KTtcblxuICAgICAgdGhpcy54ID0gbmV3X3g7XG4gICAgICB0aGlzLnkgPSBuZXdfeTtcbiAgICAgIHRoaXMudyA9IG5ld193O1xuICAgICAgdGhpcy5oID0gbmV3X2g7XG5cbiAgICAgIGlmIChjdHgpIHRoaXMuZHJhdyhjdHgpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIGRyYXc6IGZ1bmN0aW9uKGN0eCwgeCwgeSkge1xuICAgICAgaWYgKCF4KSB4ID0gMDtcbiAgICAgIGlmICgheSkgeSA9IDA7XG4gICAgICBjdHgucmVjdCh0aGlzLnggKyB4LCB0aGlzLnkgKyB5LCB0aGlzLncsIHRoaXMuaCk7XG4gICAgICBjdHguc3Ryb2tlKCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiBCb3VuZGluZ0JveDtcbn0oKSk7XG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIGBUZXh0Tm90ZWAgaXMgYSBub3RhdGlvbiBlbGVtZW50IHRoYXQgaXMgcG9zaXRpb25lZCBpbiB0aW1lLiBHZW5lcmFsbHkgXG4vLyBtZWFudCBmb3Igb2JqZWN0cyB0aGF0IHNpdCBhYm92ZS9iZWxvdyB0aGUgc3RhZmYgYW5kIGlubGluZSB3aXRoIGVhY2ggb3RoZXIuXG4vLyBFeGFtcGxlcyBvZiB0aGlzIHdvdWxkIGJlIHN1Y2ggYXMgZHluYW1pY3MsIGx5cmljcywgY2hvcmQgY2hhbmdlcywgZXRjLlxuVmV4LkZsb3cuVGV4dE5vdGUgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRleHROb3RlKHRleHRfc3RydWN0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGV4dF9zdHJ1Y3QpO1xuICB9XG5cbiAgVGV4dE5vdGUuSnVzdGlmaWNhdGlvbiA9IHtcbiAgICBMRUZUOiAxLFxuICAgIENFTlRFUjogMixcbiAgICBSSUdIVDogM1xuICB9O1xuXG4gIC8vIEdseXBoIGRhdGFcbiAgVGV4dE5vdGUuR0xZUEhTID0ge1xuICAgIFwic2Vnbm9cIjoge1xuICAgICAgY29kZTogXCJ2OGNcIixcbiAgICAgIHBvaW50OiA0MCxcbiAgICAgIHhfc2hpZnQ6IDAsXG4gICAgICB5X3NoaWZ0OiAtMTBcbiAgICAgIC8vIHdpZHRoOiAxMCAvLyBvcHRpb25hbFxuICAgIH0sXG4gICAgXCJ0clwiOiB7XG4gICAgICBjb2RlOiBcInYxZlwiLFxuICAgICAgcG9pbnQ6IDQwLFxuICAgICAgeF9zaGlmdDogMCxcbiAgICAgIHlfc2hpZnQ6IDBcbiAgICAgIC8vIHdpZHRoOiAxMCAvLyBvcHRpb25hbFxuICAgIH0sXG4gICAgXCJtb3JkZW50X3VwcGVyXCI6IHtcbiAgICAgIGNvZGU6IFwidjFlXCIsXG4gICAgICBwb2ludDogNDAsXG4gICAgICB4X3NoaWZ0OiAwLFxuICAgICAgeV9zaGlmdDogMFxuICAgICAgLy8gd2lkdGg6IDEwIC8vIG9wdGlvbmFsXG4gICAgfSxcbiAgICBcIm1vcmRlbnRfbG93ZXJcIjoge1xuICAgICAgY29kZTogXCJ2NDVcIixcbiAgICAgIHBvaW50OiA0MCxcbiAgICAgIHhfc2hpZnQ6IDAsXG4gICAgICB5X3NoaWZ0OiAwXG4gICAgICAvLyB3aWR0aDogMTAgLy8gb3B0aW9uYWxcbiAgICB9LFxuICAgIFwiZlwiOiB7XG4gICAgICBjb2RlOiBcInZiYVwiLFxuICAgICAgcG9pbnQ6IDQwLFxuICAgICAgeF9zaGlmdDogMCxcbiAgICAgIHlfc2hpZnQ6IDBcbiAgICAgIC8vIHdpZHRoOiAxMCAvLyBvcHRpb25hbFxuICAgIH0sXG4gICAgXCJwXCI6IHtcbiAgICAgIGNvZGU6IFwidmJmXCIsXG4gICAgICBwb2ludDogNDAsXG4gICAgICB4X3NoaWZ0OiAwLFxuICAgICAgeV9zaGlmdDogMFxuICAgICAgLy8gd2lkdGg6IDEwIC8vIG9wdGlvbmFsXG4gICAgfSxcbiAgICBcIm1cIjoge1xuICAgICAgY29kZTogXCJ2NjJcIixcbiAgICAgIHBvaW50OiA0MCxcbiAgICAgIHhfc2hpZnQ6IDAsXG4gICAgICB5X3NoaWZ0OiAwXG4gICAgICAvLyB3aWR0aDogMTAgLy8gb3B0aW9uYWxcbiAgICB9LFxuICAgIFwic1wiOiB7XG4gICAgICBjb2RlOiBcInY0YVwiLFxuICAgICAgcG9pbnQ6IDQwLFxuICAgICAgeF9zaGlmdDogMCxcbiAgICAgIHlfc2hpZnQ6IDBcbiAgICAgIC8vIHdpZHRoOiAxMCAvLyBvcHRpb25hbFxuICAgIH0sXG4gICAgXCJ6XCI6IHtcbiAgICAgIGNvZGU6IFwidjgwXCIsXG4gICAgICBwb2ludDogNDAsXG4gICAgICB4X3NoaWZ0OiAwLFxuICAgICAgeV9zaGlmdDogMFxuICAgICAgLy8gd2lkdGg6IDEwIC8vIG9wdGlvbmFsXG4gICAgfSxcbiAgICBcImNvZGFcIjoge1xuICAgICAgY29kZTogXCJ2NGRcIixcbiAgICAgIHBvaW50OiA0MCxcbiAgICAgIHhfc2hpZnQ6IDAsXG4gICAgICB5X3NoaWZ0OiAtOFxuICAgICAgLy8gd2lkdGg6IDEwIC8vIG9wdGlvbmFsXG4gICAgfSxcbiAgICBcInBlZGFsX29wZW5cIjoge1xuICAgICAgY29kZTogXCJ2MzZcIixcbiAgICAgIHBvaW50OjQwLFxuICAgICAgeF9zaGlmdDowLFxuICAgICAgeV9zaGlmdDowXG4gICAgfSxcbiAgICBcInBlZGFsX2Nsb3NlXCI6IHtcbiAgICAgIGNvZGU6IFwidjVkXCIsXG4gICAgICBwb2ludDo0MCxcbiAgICAgIHhfc2hpZnQ6MCxcbiAgICAgIHlfc2hpZnQ6M1xuICAgIH0sXG4gICAgXCJjYWVzdXJhX3N0cmFpZ2h0XCI6IHtcbiAgICAgIGNvZGU6IFwidjM0XCIsXG4gICAgICBwb2ludDo0MCxcbiAgICAgIHhfc2hpZnQ6MCxcbiAgICAgIHlfc2hpZnQ6MlxuICAgIH0sXG4gICAgXCJjYWVzdXJhX2N1cnZlZFwiOiB7XG4gICAgICBjb2RlOiBcInY0YlwiLFxuICAgICAgcG9pbnQ6NDAsXG4gICAgICB4X3NoaWZ0OjAsXG4gICAgICB5X3NoaWZ0OjJcbiAgICB9LFxuICAgIFwiYnJlYXRoXCI6IHtcbiAgICAgIGNvZGU6IFwidjZjXCIsXG4gICAgICBwb2ludDo0MCxcbiAgICAgIHhfc2hpZnQ6MCxcbiAgICAgIHlfc2hpZnQ6MFxuICAgIH0sXG4gICAgXCJ0aWNrXCI6IHtcbiAgICAgIGNvZGU6IFwidjZmXCIsXG4gICAgICBwb2ludDo1MCxcbiAgICAgIHhfc2hpZnQ6MCxcbiAgICAgIHlfc2hpZnQ6MFxuICAgIH0sXG4gICAgXCJ0dXJuXCI6IHtcbiAgICAgIGNvZGU6IFwidjcyXCIsXG4gICAgICBwb2ludDo0MCxcbiAgICAgIHhfc2hpZnQ6MCxcbiAgICAgIHlfc2hpZnQ6MFxuICAgIH0sXG4gICAgXCJ0dXJuX2ludmVydGVkXCI6IHtcbiAgICAgIGNvZGU6IFwidjMzXCIsXG4gICAgICBwb2ludDo0MCxcbiAgICAgIHhfc2hpZnQ6MCxcbiAgICAgIHlfc2hpZnQ6MFxuICAgIH0sXG5cbiAgICAvLyBERVBSRUNBVEVEIC0gcGxlYXNlIHVzZSBcIm1vcmRlbnRfdXBwZXJcIiBvciBcIm1vcmRlbnRfbG93ZXJcIlxuICAgIFwibW9yZGVudFwiOiB7XG4gICAgICBjb2RlOiBcInYxZVwiLFxuICAgICAgcG9pbnQ6IDQwLFxuICAgICAgeF9zaGlmdDogMCxcbiAgICAgIHlfc2hpZnQ6IDBcbiAgICAgIC8vIHdpZHRoOiAxMCAvLyBvcHRpb25hbFxuICAgIH0sXG4gIH07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgVmV4LkluaGVyaXQoVGV4dE5vdGUsIFZleC5GbG93Lk5vdGUsIHtcbiAgICBpbml0OiBmdW5jdGlvbih0ZXh0X3N0cnVjdCkge1xuICAgICAgVGV4dE5vdGUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgdGV4dF9zdHJ1Y3QpO1xuXG4gICAgICAvLyBOb3RlIHByb3BlcnRpZXNcbiAgICAgIHRoaXMudGV4dCA9IHRleHRfc3RydWN0LnRleHQ7XG4gICAgICB0aGlzLnN1cGVyc2NyaXB0ID0gdGV4dF9zdHJ1Y3Quc3VwZXJzY3JpcHQ7XG4gICAgICB0aGlzLnN1YnNjcmlwdCA9IHRleHRfc3RydWN0LnN1YnNjcmlwdDtcbiAgICAgIHRoaXMuZ2x5cGhfdHlwZSA9IHRleHRfc3RydWN0LmdseXBoO1xuICAgICAgdGhpcy5nbHlwaCA9IG51bGw7XG4gICAgICB0aGlzLmZvbnQgPSB7XG4gICAgICAgIGZhbWlseTogXCJBcmlhbFwiLFxuICAgICAgICBzaXplOiAxMixcbiAgICAgICAgd2VpZ2h0OiBcIlwiXG4gICAgICB9O1xuXG4gICAgICAvLyBTZXQgZm9udFxuICAgICAgaWYgKHRleHRfc3RydWN0LmZvbnQpIHRoaXMuZm9udCA9IHRleHRfc3RydWN0LmZvbnQ7XG5cbiAgICAgIC8vIERldGVybWluZSBhbmQgc2V0IGluaXRpYWwgbm90ZSB3aWR0aC4gTm90ZSB0aGF0IHRoZSB0ZXh0IHdpZHRoIGlzIFxuICAgICAgLy8gYW4gYXBwcm94aW1hdGlvbiBhbmQgaXNuJ3QgdmVyeSBhY2N1cmF0ZS4gVGhlIG9ubHkgd2F5IHRvIGFjY3VyYXRlbHlcbiAgICAgIC8vIG1lYXN1cmUgdGhlIGxlbmd0aCBvZiB0ZXh0IGlzIHdpdGggYGNhbnZhc0NvbnRleHQubWVhc3VyZVRleHQoKWBcbiAgICAgIGlmICh0aGlzLmdseXBoX3R5cGUpIHtcbiAgICAgICAgdmFyIHN0cnVjdCA9IFRleHROb3RlLkdMWVBIU1t0aGlzLmdseXBoX3R5cGVdO1xuICAgICAgICBpZiAoIXN0cnVjdCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiSW52YWxpZCBnbHlwaCB0eXBlOiBcIiArIHRoaXMuZ2x5cGhfdHlwZSk7XG5cbiAgICAgICAgdGhpcy5nbHlwaCA9IG5ldyBWZXguRmxvdy5HbHlwaChzdHJ1Y3QuY29kZSwgc3RydWN0LnBvaW50LCB7Y2FjaGU6IGZhbHNlfSk7XG5cbiAgICAgICAgaWYgKHN0cnVjdC53aWR0aClcbiAgICAgICAgICB0aGlzLnNldFdpZHRoKHN0cnVjdC53aWR0aCk7XG4gICAgICAgIGVsc2VcbiAgICAgICAgICB0aGlzLnNldFdpZHRoKHRoaXMuZ2x5cGguZ2V0TWV0cmljcygpLndpZHRoKTtcblxuICAgICAgICB0aGlzLmdseXBoX3N0cnVjdCA9IHN0cnVjdDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuc2V0V2lkdGgoVmV4LkZsb3cudGV4dFdpZHRoKHRoaXMudGV4dCkpO1xuICAgICAgfVxuICAgICAgdGhpcy5saW5lID0gdGV4dF9zdHJ1Y3QubGluZSB8fCAwO1xuICAgICAgdGhpcy5zbW9vdGggPSB0ZXh0X3N0cnVjdC5zbW9vdGggfHwgZmFsc2U7XG4gICAgICB0aGlzLmlnbm9yZV90aWNrcyA9IHRleHRfc3RydWN0Lmlnbm9yZV90aWNrcyB8fCBmYWxzZTtcbiAgICAgIHRoaXMuanVzdGlmaWNhdGlvbiA9IFRleHROb3RlLkp1c3RpZmljYXRpb24uTEVGVDtcbiAgICB9LFxuXG4gICAgLy8gU2V0IHRoZSBob3Jpem9udGFsIGp1c3RpZmljYXRpb24gb2YgdGhlIFRleHROb3RlXG4gICAgc2V0SnVzdGlmaWNhdGlvbjogZnVuY3Rpb24oanVzdCkge1xuICAgICAgdGhpcy5qdXN0aWZpY2F0aW9uID0ganVzdDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIFN0YXZlIGxpbmUgb24gd2hpY2ggdGhlIG5vdGUgc2hvdWxkIGJlIHBsYWNlZFxuICAgIHNldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHtcbiAgICAgIHRoaXMubGluZSA9IGxpbmU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUHJlLXJlbmRlciBmb3JtYXR0aW5nXG4gICAgcHJlRm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb1JlbmRlckNvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IG1lYXN1cmUgdGV4dCB3aXRob3V0IHJlbmRlcmluZyBjb250ZXh0LlwiKTtcbiAgICAgIGlmICh0aGlzLnByZUZvcm1hdHRlZCkgcmV0dXJuO1xuXG4gICAgICBpZiAodGhpcy5zbW9vdGgpIHtcbiAgICAgICAgdGhpcy5zZXRXaWR0aCgwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmICh0aGlzLmdseXBoKSB7XG4gICAgICAgICAgLy8gV2lkdGggYWxyZWFkeSBzZXQuXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZXRXaWR0aCh0aGlzLmNvbnRleHQubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuanVzdGlmaWNhdGlvbiA9PSBUZXh0Tm90ZS5KdXN0aWZpY2F0aW9uLkNFTlRFUikge1xuICAgICAgICB0aGlzLmV4dHJhTGVmdFB4ID0gdGhpcy53aWR0aCAvIDI7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuanVzdGlmaWNhdGlvbiA9PSBUZXh0Tm90ZS5KdXN0aWZpY2F0aW9uLlJJR0hUKSB7XG4gICAgICAgIHRoaXMuZXh0cmFMZWZ0UHggPSB0aGlzLndpZHRoO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnNldFByZUZvcm1hdHRlZCh0cnVlKTtcbiAgICB9LFxuXG4gICAgLy8gUmVuZGVycyB0aGUgVGV4dE5vdGVcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NhbnZhc0NvbnRleHRcIixcbiAgICAgICAgICBcIkNhbid0IGRyYXcgd2l0aG91dCBhIGNhbnZhcyBjb250ZXh0LlwiKTtcbiAgICAgIGlmICghdGhpcy5zdGF2ZSkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9TdGF2ZVwiLCBcIkNhbid0IGRyYXcgd2l0aG91dCBhIHN0YXZlLlwiKTtcblxuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciB4ID0gdGhpcy5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgIGlmICh0aGlzLmp1c3RpZmljYXRpb24gPT0gVGV4dE5vdGUuSnVzdGlmaWNhdGlvbi5DRU5URVIpIHtcbiAgICAgICAgeCAtPSB0aGlzLmdldFdpZHRoKCkgLyAyO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLmp1c3RpZmljYXRpb24gPT0gVGV4dE5vdGUuSnVzdGlmaWNhdGlvbi5SSUdIVCkge1xuICAgICAgICB4IC09IHRoaXMuZ2V0V2lkdGgoKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHk7XG4gICAgICBpZiAodGhpcy5nbHlwaCkge1xuICAgICAgICB5ID0gdGhpcy5zdGF2ZS5nZXRZRm9yTGluZSh0aGlzLmxpbmUgKyAoLTMpKTtcbiAgICAgICAgdGhpcy5nbHlwaC5yZW5kZXIodGhpcy5jb250ZXh0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICB4ICsgdGhpcy5nbHlwaF9zdHJ1Y3QueF9zaGlmdCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgeSArIHRoaXMuZ2x5cGhfc3RydWN0Lnlfc2hpZnQpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgeSA9IHRoaXMuc3RhdmUuZ2V0WUZvckxpbmUodGhpcy5saW5lICsgKC0zKSk7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zZXRGb250KHRoaXMuZm9udC5mYW1pbHksIHRoaXMuZm9udC5zaXplLCB0aGlzLmZvbnQud2VpZ2h0KTtcbiAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMudGV4dCwgeCwgeSk7XG5cbiAgICAgICAgLy8gV2lkdGggb2YgdGhlIGxldHRlciBNIGdpdmVzIHVzIHRoZSBhcHByb3hpbWF0ZSBoZWlnaHQgb2YgdGhlIHRleHRcbiAgICAgICAgdmFyIGhlaWdodCA9IGN0eC5tZWFzdXJlVGV4dChcIk1cIikud2lkdGg7XG4gICAgICAgIC8vIEdldCBhY2N1cmF0ZSB3aWR0aCBvZiB0ZXh0XG4gICAgICAgIHZhciB3aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLnRleHQpLndpZHRoO1xuXG4gICAgICAgIC8vIFdyaXRlIHN1cGVyc2NyaXB0XG4gICAgICAgIGlmICh0aGlzLnN1cGVyc2NyaXB0KSB7XG4gICAgICAgICAgY3R4LnNldEZvbnQodGhpcy5mb250LmZhbWlseSwgdGhpcy5mb250LnNpemUgLyAxLjMsIHRoaXMuZm9udC53ZWlnaHQpO1xuICAgICAgICAgIGN0eC5maWxsVGV4dCh0aGlzLnN1cGVyc2NyaXB0LCB4ICsgd2lkdGggKyAyLCB5IC0gKGhlaWdodC8yLjIpKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFdyaXRlIHN1YnNjcmlwdFxuICAgICAgICBpZiAodGhpcy5zdWJzY3JpcHQpIHtcbiAgICAgICAgICBjdHguc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSAvIDEuMywgdGhpcy5mb250LndlaWdodCk7XG4gICAgICAgICAgY3R4LmZpbGxUZXh0KHRoaXMuc3Vic2NyaXB0LCB4ICsgd2lkdGggKyAyLCB5ICsgKGhlaWdodC8yLjIpIC0gMSk7XG4gICAgICAgIH1cblxuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFRleHROb3RlO1xufSgpKTtcblxuLy8gVmV4RmxvdyAtIE11c2ljIEVuZ3JhdmluZyBmb3IgSFRNTDVcclxuLy8gQ29weXJpZ2h0IE1vaGl0IE11dGhhbm5hIDIwMTBcclxuLy8gQXV0aG9yIExhcnJ5IEt1aG5zIDIwMTNcclxuLy8gQ2xhc3MgdG8gZHJhd3Mgc3RyaW5nIG51bWJlcnMgaW50byB0aGUgbm90YXRpb24uXHJcblxyXG4vKipcclxuICogQGNvbnN0cnVjdG9yXHJcbiAqL1xyXG5WZXguRmxvdy5GcmV0SGFuZEZpbmdlciA9IChmdW5jdGlvbigpIHtcclxuICBmdW5jdGlvbiBGcmV0SGFuZEZpbmdlcihudW1iZXIpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG51bWJlcik7XHJcbiAgfVxyXG4gIEZyZXRIYW5kRmluZ2VyLkNBVEVHT1JZID0gXCJmcmV0aGFuZGZpbmdlclwiO1xyXG5cclxuICB2YXIgTW9kaWZpZXIgPSBWZXguRmxvdy5Nb2RpZmllcjtcclxuXHJcbiAgLy8gQXJyYW5nZSBmaW5nZXJpbmdzIGluc2lkZSBhIE1vZGlmaWVyQ29udGV4dC5cclxuICBGcmV0SGFuZEZpbmdlci5mb3JtYXQgPSBmdW5jdGlvbihudW1zLCBzdGF0ZSkge1xyXG4gICAgdmFyIGxlZnRfc2hpZnQgPSBzdGF0ZS5sZWZ0X3NoaWZ0O1xyXG4gICAgdmFyIHJpZ2h0X3NoaWZ0ID0gc3RhdGUucmlnaHRfc2hpZnQ7XHJcbiAgICB2YXIgbnVtX3NwYWNpbmcgPSAxO1xyXG5cclxuICAgIGlmICghbnVtcyB8fCBudW1zLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGZhbHNlO1xyXG5cclxuICAgIHZhciBudW1zX2xpc3QgPSBbXTtcclxuICAgIHZhciBwcmV2X25vdGUgPSBudWxsO1xyXG4gICAgdmFyIHNoaWZ0X2xlZnQgPSAwO1xyXG4gICAgdmFyIHNoaWZ0X3JpZ2h0ID0gMDtcclxuXHJcbiAgICB2YXIgaSwgbnVtLCBub3RlLCBwb3MsIHByb3BzX3RtcDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIG51bSA9IG51bXNbaV07XHJcbiAgICAgIG5vdGUgPSBudW0uZ2V0Tm90ZSgpO1xyXG4gICAgICBwb3MgPSBudW0uZ2V0UG9zaXRpb24oKTtcclxuICAgICAgdmFyIHByb3BzID0gbm90ZS5nZXRLZXlQcm9wcygpW251bS5nZXRJbmRleCgpXTtcclxuICAgICAgaWYgKG5vdGUgIT0gcHJldl9ub3RlKSB7XHJcbiAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub3RlLmtleXMubGVuZ3RoOyArK24pIHtcclxuICAgICAgICAgIHByb3BzX3RtcCA9IG5vdGUuZ2V0S2V5UHJvcHMoKVtuXTtcclxuICAgICAgICAgIGlmIChsZWZ0X3NoaWZ0ID09PSAwKVxyXG4gICAgICAgICAgICBzaGlmdF9sZWZ0ID0gKHByb3BzX3RtcC5kaXNwbGFjZWQgPyBub3RlLmdldEV4dHJhTGVmdFB4KCkgOiBzaGlmdF9sZWZ0KTtcclxuICAgICAgICAgIGlmIChyaWdodF9zaGlmdCA9PT0gMClcclxuICAgICAgICAgICAgc2hpZnRfcmlnaHQgPSAocHJvcHNfdG1wLmRpc3BsYWNlZCA/IG5vdGUuZ2V0RXh0cmFSaWdodFB4KCkgOiBzaGlmdF9yaWdodCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHByZXZfbm90ZSA9IG5vdGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIG51bXNfbGlzdC5wdXNoKHsgbGluZTogcHJvcHMubGluZSwgcG9zOiBwb3MsIHNoaWZ0TDogc2hpZnRfbGVmdCwgc2hpZnRSOiBzaGlmdF9yaWdodCwgbm90ZTogbm90ZSwgbnVtOiBudW0gfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU29ydCBmaW5nZXJudW1iZXJzIGJ5IGxpbmUgbnVtYmVyLlxyXG4gICAgbnVtc19saXN0LnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gKGIubGluZSAtIGEubGluZSk7IH0pO1xyXG5cclxuICAgIHZhciBudW1fc2hpZnRMID0gMDtcclxuICAgIHZhciBudW1fc2hpZnRSID0gMDtcclxuICAgIHZhciB4X3dpZHRoTCA9IDA7XHJcbiAgICB2YXIgeF93aWR0aFIgPSAwO1xyXG4gICAgdmFyIGxhc3RfbGluZSA9IG51bGw7XHJcbiAgICB2YXIgbGFzdF9ub3RlID0gbnVsbDtcclxuXHJcbiAgICBmb3IgKGkgPSAwOyBpIDwgbnVtc19saXN0Lmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHZhciBudW1fc2hpZnQgPSAwO1xyXG4gICAgICBub3RlID0gbnVtc19saXN0W2ldLm5vdGU7XHJcbiAgICAgIHBvcyA9IG51bXNfbGlzdFtpXS5wb3M7XHJcbiAgICAgIG51bSA9IG51bXNfbGlzdFtpXS5udW07XHJcbiAgICAgIHZhciBsaW5lID0gbnVtc19saXN0W2ldLmxpbmU7XHJcbiAgICAgIHZhciBzaGlmdEwgPSBudW1zX2xpc3RbaV0uc2hpZnRMO1xyXG4gICAgICB2YXIgc2hpZnRSID0gbnVtc19saXN0W2ldLnNoaWZ0UjtcclxuXHJcbiAgICAgIC8vIFJlc2V0IHRoZSBwb3NpdGlvbiBvZiB0aGUgc3RyaW5nIG51bWJlciBldmVyeSBsaW5lLlxyXG4gICAgICBpZiAobGluZSAhPSBsYXN0X2xpbmUgfHwgbm90ZSAhPSBsYXN0X25vdGUpIHtcclxuICAgICAgICBudW1fc2hpZnRMID0gbGVmdF9zaGlmdCArIHNoaWZ0TDtcclxuICAgICAgICBudW1fc2hpZnRSID0gcmlnaHRfc2hpZnQgKyBzaGlmdFI7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBudW1fd2lkdGggPSBudW0uZ2V0V2lkdGgoKSArIG51bV9zcGFjaW5nO1xyXG4gICAgICBpZiAocG9zID09IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLkxFRlQpIHtcclxuICAgICAgICBudW0uc2V0WFNoaWZ0KGxlZnRfc2hpZnQgKyBudW1fc2hpZnRMKTtcclxuICAgICAgICBudW1fc2hpZnQgPSBsZWZ0X3NoaWZ0ICsgbnVtX3dpZHRoOyAvLyBzcGFjaW5nXHJcbiAgICAgICAgeF93aWR0aEwgPSAobnVtX3NoaWZ0ID4geF93aWR0aEwpID8gbnVtX3NoaWZ0IDogeF93aWR0aEw7XHJcbiAgICAgIH0gZWxzZSBpZiAocG9zID09IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLlJJR0hUKSB7XHJcbiAgICAgICAgbnVtLnNldFhTaGlmdChudW1fc2hpZnRSKTtcclxuICAgICAgICBudW1fc2hpZnQgPSBzaGlmdF9yaWdodCArIG51bV93aWR0aDsgLy8gc3BhY2luZ1xyXG4gICAgICAgIHhfd2lkdGhSID0gKG51bV9zaGlmdCA+IHhfd2lkdGhSKSA/IG51bV9zaGlmdCA6IHhfd2lkdGhSO1xyXG4gICAgICB9XHJcbiAgICAgIGxhc3RfbGluZSA9IGxpbmU7XHJcbiAgICAgIGxhc3Rfbm90ZSA9IG5vdGU7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGUubGVmdF9zaGlmdCArPSB4X3dpZHRoTDtcclxuICAgIHN0YXRlLnJpZ2h0X3NoaWZ0ICs9IHhfd2lkdGhSO1xyXG4gIH07XHJcblxyXG4gIFZleC5Jbmhlcml0KEZyZXRIYW5kRmluZ2VyLCBNb2RpZmllciwge1xyXG4gICAgaW5pdDogZnVuY3Rpb24obnVtYmVyKSB7XHJcbiAgICAgIHZhciBzdXBlcmNsYXNzID0gVmV4LkZsb3cuRnJldEhhbmRGaW5nZXIuc3VwZXJjbGFzcztcclxuICAgICAgc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICB0aGlzLm5vdGUgPSBudWxsO1xyXG4gICAgICB0aGlzLmluZGV4ID0gbnVsbDtcclxuICAgICAgdGhpcy5maW5nZXIgPSBudW1iZXI7XHJcbiAgICAgIHRoaXMud2lkdGggPSA3O1xyXG4gICAgICB0aGlzLnBvc2l0aW9uID0gTW9kaWZpZXIuUG9zaXRpb24uTEVGVDsgIC8vIERlZmF1bHQgcG9zaXRpb24gYWJvdmUgc3RlbSBvciBub3RlIGhlYWRcclxuICAgICAgdGhpcy54X3NoaWZ0ID0gMDtcclxuICAgICAgdGhpcy55X3NoaWZ0ID0gMDtcclxuICAgICAgdGhpcy54X29mZnNldCA9IDA7ICAgICAgIC8vIEhvcml6b250YWwgb2Zmc2V0IGZyb20gZGVmYXVsdFxyXG4gICAgICB0aGlzLnlfb2Zmc2V0ID0gMDsgICAgICAgLy8gVmVydGljYWwgb2Zmc2V0IGZyb20gZGVmYXVsdFxyXG4gICAgICB0aGlzLmZvbnQgPSB7XHJcbiAgICAgICAgZmFtaWx5OiBcInNhbnMtc2VyaWZcIixcclxuICAgICAgICBzaXplOiA5LFxyXG4gICAgICAgIHdlaWdodDogXCJib2xkXCJcclxuICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Tm90ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5vdGU7IH0sXHJcbiAgICBzZXROb3RlOiBmdW5jdGlvbihub3RlKSB7IHRoaXMubm90ZSA9IG5vdGU7IHJldHVybiB0aGlzOyB9LFxyXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfSxcclxuICAgIHNldEluZGV4OiBmdW5jdGlvbihpbmRleCkgeyB0aGlzLmluZGV4ID0gaW5kZXg7IHJldHVybiB0aGlzOyB9LFxyXG4gICAgZ2V0UG9zaXRpb246IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5wb3NpdGlvbjsgfSxcclxuICAgIHNldFBvc2l0aW9uOiBmdW5jdGlvbihwb3NpdGlvbikge1xyXG4gICAgICBpZiAocG9zaXRpb24gPj0gTW9kaWZpZXIuUG9zaXRpb24uTEVGVCAmJlxyXG4gICAgICAgICAgcG9zaXRpb24gPD0gTW9kaWZpZXIuUG9zaXRpb24uQkVMT1cpXHJcbiAgICAgICAgdGhpcy5wb3NpdGlvbiA9IHBvc2l0aW9uO1xyXG4gICAgICByZXR1cm4gdGhpcztcclxuICAgIH0sXHJcbiAgICBzZXRGcmV0SGFuZEZpbmdlcjogZnVuY3Rpb24obnVtYmVyKSB7IHRoaXMuZmluZ2VyID0gbnVtYmVyOyByZXR1cm4gdGhpczsgfSxcclxuICAgIHNldE9mZnNldFg6IGZ1bmN0aW9uKHgpIHsgdGhpcy54X29mZnNldCA9IHg7IHJldHVybiB0aGlzOyB9LFxyXG4gICAgc2V0T2Zmc2V0WTogZnVuY3Rpb24oeSkgeyB0aGlzLnlfb2Zmc2V0ID0geTsgcmV0dXJuIHRoaXM7IH0sXHJcblxyXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XHJcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcclxuICAgICAgICBcIkNhbid0IGRyYXcgc3RyaW5nIG51bWJlciB3aXRob3V0IGEgY29udGV4dC5cIik7XHJcbiAgICAgIGlmICghKHRoaXMubm90ZSAmJiAodGhpcy5pbmRleCAhPSBudWxsKSkpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQXR0YWNoZWROb3RlXCIsXHJcbiAgICAgICAgXCJDYW4ndCBkcmF3IHN0cmluZyBudW1iZXIgd2l0aG91dCBhIG5vdGUgYW5kIGluZGV4LlwiKTtcclxuXHJcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XHJcbiAgICAgIHZhciBzdGFydCA9IHRoaXMubm90ZS5nZXRNb2RpZmllclN0YXJ0WFkodGhpcy5wb3NpdGlvbiwgdGhpcy5pbmRleCk7XHJcbiAgICAgIHZhciBkb3RfeCA9IChzdGFydC54ICsgdGhpcy54X3NoaWZ0ICsgdGhpcy54X29mZnNldCk7XHJcbiAgICAgIHZhciBkb3RfeSA9IHN0YXJ0LnkgKyB0aGlzLnlfc2hpZnQgKyB0aGlzLnlfb2Zmc2V0ICsgNTtcclxuXHJcbiAgICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xyXG4gICAgICAgIGNhc2UgTW9kaWZpZXIuUG9zaXRpb24uQUJPVkU6XHJcbiAgICAgICAgICBkb3RfeCAtPSA0O1xyXG4gICAgICAgICAgZG90X3kgLT0gMTI7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIE1vZGlmaWVyLlBvc2l0aW9uLkJFTE9XOlxyXG4gICAgICAgICAgZG90X3ggLT0gMjtcclxuICAgICAgICAgIGRvdF95ICs9IDEwO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBNb2RpZmllci5Qb3NpdGlvbi5MRUZUOlxyXG4gICAgICAgICAgZG90X3ggLT0gdGhpcy53aWR0aDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgTW9kaWZpZXIuUG9zaXRpb24uUklHSFQ6XHJcbiAgICAgICAgICBkb3RfeCArPSAxO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgIGN0eC5zZXRGb250KHRoaXMuZm9udC5mYW1pbHksIHRoaXMuZm9udC5zaXplLCB0aGlzLmZvbnQud2VpZ2h0KTtcclxuICAgICAgY3R4LmZpbGxUZXh0KFwiXCIgKyB0aGlzLmZpbmdlciwgZG90X3gsIGRvdF95KTtcclxuXHJcbiAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBGcmV0SGFuZEZpbmdlcjtcclxufSgpKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxyXG4vLyBBdXRob3I6IExhcnJ5IEt1aG5zXHJcbi8vXHJcbi8vICMjIERlc2NyaXB0aW9uXHJcbi8vXHJcbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIHRoZSBgU3RyaW5nTnVtYmVyYCBjbGFzcyB3aGljaCByZW5kZXJzIHN0cmluZ1xyXG4vLyBudW1iZXIgYW5ub3RhdGlvbnMgYmVzaWRlIG5vdGVzLlxyXG5cclxuVmV4LkZsb3cuU3RyaW5nTnVtYmVyID0gKGZ1bmN0aW9uKCkge1xyXG4gIGZ1bmN0aW9uIFN0cmluZ051bWJlcihudW1iZXIpIHtcclxuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG51bWJlcik7XHJcbiAgfVxyXG4gIFN0cmluZ051bWJlci5DQVRFR09SWSA9IFwic3RyaW5nbnVtYmVyXCI7XHJcblxyXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xyXG5cclxuICAvLyAjIyBTdGF0aWMgTWV0aG9kc1xyXG4gIC8vIEFycmFuZ2Ugc3RyaW5nIG51bWJlcnMgaW5zaWRlIGEgYE1vZGlmaWVyQ29udGV4dGBcclxuICBTdHJpbmdOdW1iZXIuZm9ybWF0ID0gZnVuY3Rpb24obnVtcywgc3RhdGUpIHtcclxuICAgIHZhciBsZWZ0X3NoaWZ0ID0gc3RhdGUubGVmdF9zaGlmdDtcclxuICAgIHZhciByaWdodF9zaGlmdCA9IHN0YXRlLnJpZ2h0X3NoaWZ0O1xyXG4gICAgdmFyIG51bV9zcGFjaW5nID0gMTtcclxuXHJcbiAgICBpZiAoIW51bXMgfHwgbnVtcy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzO1xyXG5cclxuICAgIHZhciBudW1zX2xpc3QgPSBbXTtcclxuICAgIHZhciBwcmV2X25vdGUgPSBudWxsO1xyXG4gICAgdmFyIHNoaWZ0X2xlZnQgPSAwO1xyXG4gICAgdmFyIHNoaWZ0X3JpZ2h0ID0gMDtcclxuXHJcbiAgICB2YXIgaSwgbnVtLCBub3RlLCBwb3MsIHByb3BzX3RtcDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBudW1zLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIG51bSA9IG51bXNbaV07XHJcbiAgICAgIG5vdGUgPSBudW0uZ2V0Tm90ZSgpO1xyXG5cclxuICAgICAgZm9yIChpID0gMDsgaSA8IG51bXMubGVuZ3RoOyArK2kpIHtcclxuICAgICAgICBudW0gPSBudW1zW2ldO1xyXG4gICAgICAgIG5vdGUgPSBudW0uZ2V0Tm90ZSgpO1xyXG4gICAgICAgIHBvcyA9IG51bS5nZXRQb3NpdGlvbigpO1xyXG4gICAgICAgIHZhciBwcm9wcyA9IG5vdGUuZ2V0S2V5UHJvcHMoKVtudW0uZ2V0SW5kZXgoKV07XHJcblxyXG4gICAgICAgIGlmIChub3RlICE9IHByZXZfbm90ZSkge1xyXG4gICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub3RlLmtleXMubGVuZ3RoOyArK24pIHtcclxuICAgICAgICAgICAgcHJvcHNfdG1wID0gbm90ZS5nZXRLZXlQcm9wcygpW25dO1xyXG4gICAgICAgICAgICBpZiAobGVmdF9zaGlmdCA9PT0gMClcclxuICAgICAgICAgICAgICBzaGlmdF9sZWZ0ID0gKHByb3BzX3RtcC5kaXNwbGFjZWQgPyBub3RlLmdldEV4dHJhTGVmdFB4KCkgOiBzaGlmdF9sZWZ0KTtcclxuICAgICAgICAgICAgaWYgKHJpZ2h0X3NoaWZ0ID09PSAwKVxyXG4gICAgICAgICAgICAgIHNoaWZ0X3JpZ2h0ID0gKHByb3BzX3RtcC5kaXNwbGFjZWQgPyBub3RlLmdldEV4dHJhUmlnaHRQeCgpIDogc2hpZnRfcmlnaHQpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgcHJldl9ub3RlID0gbm90ZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG51bXNfbGlzdC5wdXNoKHsgbGluZTogcHJvcHMubGluZSwgcG9zOiBwb3MsIHNoaWZ0TDogc2hpZnRfbGVmdCwgc2hpZnRSOiBzaGlmdF9yaWdodCwgbm90ZTogbm90ZSwgbnVtOiBudW0gfSk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTb3J0IHN0cmluZyBudW1iZXJzIGJ5IGxpbmUgbnVtYmVyLlxyXG4gICAgbnVtc19saXN0LnNvcnQoZnVuY3Rpb24oYSwgYikgeyByZXR1cm4gKGIubGluZSAtIGEubGluZSk7IH0pO1xyXG5cclxuICAgIHZhciBudW1fc2hpZnRMID0gMDtcclxuICAgIHZhciBudW1fc2hpZnRSID0gMDtcclxuICAgIHZhciB4X3dpZHRoTCA9IDA7XHJcbiAgICB2YXIgeF93aWR0aFIgPSAwO1xyXG4gICAgdmFyIGxhc3RfbGluZSA9IG51bGw7XHJcbiAgICB2YXIgbGFzdF9ub3RlID0gbnVsbDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBudW1zX2xpc3QubGVuZ3RoOyArK2kpIHtcclxuICAgICAgdmFyIG51bV9zaGlmdCA9IDA7XHJcbiAgICAgIG5vdGUgPSBudW1zX2xpc3RbaV0ubm90ZTtcclxuICAgICAgcG9zID0gbnVtc19saXN0W2ldLnBvcztcclxuICAgICAgbnVtID0gbnVtc19saXN0W2ldLm51bTtcclxuICAgICAgdmFyIGxpbmUgPSBudW1zX2xpc3RbaV0ubGluZTtcclxuICAgICAgdmFyIHNoaWZ0TCA9IG51bXNfbGlzdFtpXS5zaGlmdEw7XHJcbiAgICAgIHZhciBzaGlmdFIgPSBudW1zX2xpc3RbaV0uc2hpZnRSO1xyXG5cclxuICAgICAgLy8gUmVzZXQgdGhlIHBvc2l0aW9uIG9mIHRoZSBzdHJpbmcgbnVtYmVyIGV2ZXJ5IGxpbmUuXHJcbiAgICAgIGlmIChsaW5lICE9IGxhc3RfbGluZSB8fCBub3RlICE9IGxhc3Rfbm90ZSkge1xyXG4gICAgICAgIG51bV9zaGlmdEwgPSBsZWZ0X3NoaWZ0ICsgc2hpZnRMO1xyXG4gICAgICAgIG51bV9zaGlmdFIgPSByaWdodF9zaGlmdCArIHNoaWZ0UjtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFyIG51bV93aWR0aCA9IG51bS5nZXRXaWR0aCgpICsgbnVtX3NwYWNpbmc7XHJcbiAgICAgIGlmIChwb3MgPT0gVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb24uTEVGVCkge1xyXG4gICAgICAgIG51bS5zZXRYU2hpZnQobGVmdF9zaGlmdCk7XHJcbiAgICAgICAgbnVtX3NoaWZ0ID0gc2hpZnRfbGVmdCArIG51bV93aWR0aDsgLy8gc3BhY2luZ1xyXG4gICAgICAgIHhfd2lkdGhMID0gKG51bV9zaGlmdCA+IHhfd2lkdGhMKSA/IG51bV9zaGlmdCA6IHhfd2lkdGhMO1xyXG4gICAgICB9IGVsc2UgaWYgKHBvcyA9PSBWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5SSUdIVCkge1xyXG4gICAgICAgIG51bS5zZXRYU2hpZnQobnVtX3NoaWZ0Uik7XHJcbiAgICAgICAgbnVtX3NoaWZ0ICs9IG51bV93aWR0aDsgLy8gc3BhY2luZ1xyXG4gICAgICAgIHhfd2lkdGhSID0gKG51bV9zaGlmdCA+IHhfd2lkdGhSKSA/IG51bV9zaGlmdCA6IHhfd2lkdGhSO1xyXG4gICAgICB9XHJcbiAgICAgIGxhc3RfbGluZSA9IGxpbmU7XHJcbiAgICAgIGxhc3Rfbm90ZSA9IG5vdGU7XHJcbiAgICB9XHJcblxyXG4gICAgc3RhdGUubGVmdF9zaGlmdCArPSB4X3dpZHRoTDtcclxuICAgIHN0YXRlLnJpZ2h0X3NoaWZ0ICs9IHhfd2lkdGhSO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfTtcclxuXHJcbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcclxuICBWZXguSW5oZXJpdChTdHJpbmdOdW1iZXIsIE1vZGlmaWVyLCB7XHJcbiAgICBpbml0OiBmdW5jdGlvbihudW1iZXIpIHtcclxuICAgICAgU3RyaW5nTnVtYmVyLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMpO1xyXG5cclxuICAgICAgdGhpcy5ub3RlID0gbnVsbDtcclxuICAgICAgdGhpcy5sYXN0X25vdGUgPSBudWxsO1xyXG4gICAgICB0aGlzLmluZGV4ID0gbnVsbDtcclxuICAgICAgdGhpcy5zdHJpbmdfbnVtYmVyID0gbnVtYmVyO1xyXG4gICAgICB0aGlzLnNldFdpZHRoKDIwKTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyA/Pz9cclxuICAgICAgdGhpcy5wb3NpdGlvbiA9IE1vZGlmaWVyLlBvc2l0aW9uLkFCT1ZFOyAgLy8gRGVmYXVsdCBwb3NpdGlvbiBhYm92ZSBzdGVtIG9yIG5vdGUgaGVhZFxyXG4gICAgICB0aGlzLnhfc2hpZnQgPSAwO1xyXG4gICAgICB0aGlzLnlfc2hpZnQgPSAwO1xyXG4gICAgICB0aGlzLnhfb2Zmc2V0ID0gMDsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gSG9yaXpvbnRhbCBvZmZzZXQgZnJvbSBkZWZhdWx0XHJcbiAgICAgIHRoaXMueV9vZmZzZXQgPSAwOyAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBWZXJ0aWNhbCBvZmZzZXQgZnJvbSBkZWZhdWx0XHJcbiAgICAgIHRoaXMuZGFzaGVkID0gdHJ1ZTsgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyB0cnVlIC0gZHJhdyBkYXNoZWQgZXh0ZW5zaW9uICBmYWxzZSAtIG5vIGV4dGVuc2lvblxyXG4gICAgICB0aGlzLmxlZyA9IFZleC5GbG93LlJlbmRlcmVyLkxpbmVFbmRUeXBlLk5PTkU7ICAgLy8gZHJhdyB1cHdhcmQvZG93bndhcmQgbGVnIGF0IHRoZSBvZiBleHRlbnNpb24gbGluZVxyXG4gICAgICB0aGlzLnJhZGl1cyA9IDg7XHJcbiAgICAgIHRoaXMuZm9udCA9IHtcclxuICAgICAgICBmYW1pbHk6IFwic2Fucy1zZXJpZlwiLFxyXG4gICAgICAgIHNpemU6IDEwLFxyXG4gICAgICAgIHdlaWdodDogXCJib2xkXCJcclxuICAgICAgfTtcclxuICAgIH0sXHJcblxyXG4gICAgZ2V0Tm90ZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLm5vdGU7IH0sXHJcbiAgICBzZXROb3RlOiBmdW5jdGlvbihub3RlKSB7IHRoaXMubm90ZSA9IG5vdGU7IHJldHVybiB0aGlzOyB9LFxyXG4gICAgZ2V0SW5kZXg6IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpcy5pbmRleDsgfSxcclxuICAgIHNldEluZGV4OiBmdW5jdGlvbihpbmRleCkgeyB0aGlzLmluZGV4ID0gaW5kZXg7IHJldHVybiB0aGlzOyB9LFxyXG5cclxuICAgIHNldExpbmVFbmRUeXBlOiBmdW5jdGlvbihsZWcpIHtcclxuICAgICAgaWYgKGxlZyA+PSBWZXguRmxvdy5SZW5kZXJlci5MaW5lRW5kVHlwZS5OT05FICYmXHJcbiAgICAgICAgICBsZWcgPD0gVmV4LkZsb3cuUmVuZGVyZXIuTGluZUVuZFR5cGUuRE9XTilcclxuICAgICAgICB0aGlzLmxlZyA9IGxlZztcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucG9zaXRpb247IH0sXHJcbiAgICBzZXRQb3NpdGlvbjogZnVuY3Rpb24ocG9zaXRpb24pIHtcclxuICAgICAgaWYgKHBvc2l0aW9uID49IE1vZGlmaWVyLlBvc2l0aW9uLkxFRlQgJiZcclxuICAgICAgICAgIHBvc2l0aW9uIDw9IE1vZGlmaWVyLlBvc2l0aW9uLkJFTE9XKVxyXG4gICAgICAgIHRoaXMucG9zaXRpb24gPSBwb3NpdGlvbjtcclxuICAgICAgcmV0dXJuIHRoaXM7XHJcbiAgICB9LFxyXG5cclxuICAgIHNldFN0cmluZ051bWJlcjogZnVuY3Rpb24obnVtYmVyKSB7IHRoaXMuc3RyaW5nX251bWJlciA9IG51bWJlcjsgcmV0dXJuIHRoaXM7IH0sXHJcbiAgICBzZXRPZmZzZXRYOiBmdW5jdGlvbih4KSB7IHRoaXMueF9vZmZzZXQgPSB4OyByZXR1cm4gdGhpczsgfSxcclxuICAgIHNldE9mZnNldFk6IGZ1bmN0aW9uKHkpIHsgdGhpcy55X29mZnNldCA9IHk7IHJldHVybiB0aGlzOyB9LFxyXG4gICAgc2V0TGFzdE5vdGU6IGZ1bmN0aW9uKG5vdGUpIHsgdGhpcy5sYXN0X25vdGUgPSBub3RlOyByZXR1cm4gdGhpczsgfSxcclxuICAgIHNldERhc2hlZDogZnVuY3Rpb24oZGFzaGVkKSB7IHRoaXMuZGFzaGVkID0gZGFzaGVkOyByZXR1cm4gdGhpczsgfSxcclxuXHJcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxyXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBzdHJpbmcgbnVtYmVyIHdpdGhvdXQgYSBjb250ZXh0LlwiKTtcclxuICAgICAgaWYgKCEodGhpcy5ub3RlICYmICh0aGlzLmluZGV4ICE9IG51bGwpKSkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9BdHRhY2hlZE5vdGVcIixcclxuICAgICAgICBcIkNhbid0IGRyYXcgc3RyaW5nIG51bWJlciB3aXRob3V0IGEgbm90ZSBhbmQgaW5kZXguXCIpO1xyXG5cclxuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcclxuICAgICAgdmFyIGxpbmVfc3BhY2UgPSB0aGlzLm5vdGUuc3RhdmUub3B0aW9ucy5zcGFjaW5nX2JldHdlZW5fbGluZXNfcHg7XHJcblxyXG4gICAgICB2YXIgc3RhcnQgPSB0aGlzLm5vdGUuZ2V0TW9kaWZpZXJTdGFydFhZKHRoaXMucG9zaXRpb24sIHRoaXMuaW5kZXgpO1xyXG4gICAgICB2YXIgZG90X3ggPSAoc3RhcnQueCArIHRoaXMueF9zaGlmdCArIHRoaXMueF9vZmZzZXQpO1xyXG4gICAgICB2YXIgZG90X3kgPSBzdGFydC55ICsgdGhpcy55X3NoaWZ0ICsgdGhpcy55X29mZnNldDtcclxuXHJcbiAgICAgIHN3aXRjaCAodGhpcy5wb3NpdGlvbikge1xyXG4gICAgICAgIGNhc2UgTW9kaWZpZXIuUG9zaXRpb24uQUJPVkU6XHJcbiAgICAgICAgY2FzZSBNb2RpZmllci5Qb3NpdGlvbi5CRUxPVzpcclxuICAgICAgICAgIHZhciBzdGVtX2V4dCA9IHRoaXMubm90ZS5nZXRTdGVtRXh0ZW50cygpO1xyXG4gICAgICAgICAgdmFyIHRvcCA9IHN0ZW1fZXh0LnRvcFk7XHJcbiAgICAgICAgICB2YXIgYm90dG9tID0gc3RlbV9leHQuYmFzZVkgKyAyO1xyXG5cclxuICAgICAgICAgIGlmICh0aGlzLm5vdGUuc3RlbV9kaXJlY3Rpb24gPT0gVmV4LkZsb3cuU3RhdmVOb3RlLlNURU1fRE9XTikge1xyXG4gICAgICAgICAgICB0b3AgPSBzdGVtX2V4dC5iYXNlWTtcclxuICAgICAgICAgICAgYm90dG9tID0gc3RlbV9leHQudG9wWSAtIDI7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMucG9zaXRpb24gPT0gTW9kaWZpZXIuUG9zaXRpb24uQUJPVkUpIHtcclxuICAgICAgICAgICAgZG90X3kgPSB0aGlzLm5vdGUuaGFzU3RlbSgpID8gdG9wIC0gKGxpbmVfc3BhY2UgKiAxLjc1KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzdGFydC55IC0gKGxpbmVfc3BhY2UgKiAxLjc1KTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICBkb3RfeSA9IHRoaXMubm90ZS5oYXNTdGVtKCkgPyBib3R0b20gKyAobGluZV9zcGFjZSAqIDEuNSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogc3RhcnQueSArIChsaW5lX3NwYWNlICogMS43NSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgZG90X3kgKz0gdGhpcy55X3NoaWZ0ICsgdGhpcy55X29mZnNldDtcclxuXHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIE1vZGlmaWVyLlBvc2l0aW9uLkxFRlQ6XHJcbiAgICAgICAgICBkb3RfeCAtPSAodGhpcy5yYWRpdXMgLyAyKSArIDU7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIE1vZGlmaWVyLlBvc2l0aW9uLlJJR0hUOlxyXG4gICAgICAgICAgZG90X3ggKz0gKHRoaXMucmFkaXVzIC8gMikgKyA2O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN0eC5zYXZlKCk7XHJcbiAgICAgIGN0eC5iZWdpblBhdGgoKTtcclxuICAgICAgY3R4LmFyYyhkb3RfeCwgZG90X3ksIHRoaXMucmFkaXVzLCAwLCBNYXRoLlBJICogMiwgZmFsc2UpO1xyXG4gICAgICBjdHgubGluZVdpZHRoID0gMS41O1xyXG4gICAgICBjdHguc3Ryb2tlKCk7XHJcbiAgICAgIGN0eC5zZXRGb250KHRoaXMuZm9udC5mYW1pbHksIHRoaXMuZm9udC5zaXplLCB0aGlzLmZvbnQud2VpZ2h0KTtcclxuICAgICAgdmFyIHggPSBkb3RfeCAtIGN0eC5tZWFzdXJlVGV4dCh0aGlzLnN0cmluZ19udW1iZXIpLndpZHRoIC8gMjtcclxuICAgICAgY3R4LmZpbGxUZXh0KFwiXCIgKyB0aGlzLnN0cmluZ19udW1iZXIsIHgsIGRvdF95ICsgNC41KTtcclxuXHJcbiAgICAgIGlmICh0aGlzLmxhc3Rfbm90ZSAhPSBudWxsKSB7XHJcbiAgICAgICAgdmFyIGVuZCA9IHRoaXMubGFzdF9ub3RlLmdldFN0ZW1YKCkgLSB0aGlzLm5vdGUuZ2V0WCgpICsgNTtcclxuICAgICAgICBjdHguc3Ryb2tlU3R5bGU9XCIjMDAwMDAwXCI7XHJcbiAgICAgICAgY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XHJcbiAgICAgICAgY3R4LmxpbmVXaWR0aCA9IDAuNjtcclxuICAgICAgICBpZiAodGhpcy5kYXNoZWQpXHJcbiAgICAgICAgICBWZXguRmxvdy5SZW5kZXJlci5kcmF3RGFzaGVkTGluZShjdHgsIGRvdF94ICsgMTAsIGRvdF95LCBkb3RfeCArIGVuZCwgZG90X3ksIFszLDNdKTtcclxuICAgICAgICBlbHNlXHJcbiAgICAgICAgICBWZXguRmxvdy5SZW5kZXJlci5kcmF3RGFzaGVkTGluZShjdHgsIGRvdF94ICsgMTAsIGRvdF95LCBkb3RfeCArIGVuZCwgZG90X3ksIFszLDBdKTtcclxuXHJcbiAgICAgICAgdmFyIGxlbiwgcGF0dGVybjtcclxuICAgICAgICBzd2l0Y2ggKHRoaXMubGVnKSB7XHJcbiAgICAgICAgICBjYXNlIFZleC5GbG93LlJlbmRlcmVyLkxpbmVFbmRUeXBlLlVQOlxyXG4gICAgICAgICAgICBsZW4gPSAtMTA7XHJcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLmRhc2hlZCA/IFszLDNdIDogWzMsMF07XHJcbiAgICAgICAgICAgIFZleC5GbG93LlJlbmRlcmVyLmRyYXdEYXNoZWRMaW5lKGN0eCwgZG90X3ggKyBlbmQsIGRvdF95LCBkb3RfeCArIGVuZCwgZG90X3kgKyBsZW4sIHBhdHRlcm4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICAgIGNhc2UgVmV4LkZsb3cuUmVuZGVyZXIuTGluZUVuZFR5cGUuRE9XTjpcclxuICAgICAgICAgICAgbGVuID0gMTA7XHJcbiAgICAgICAgICAgIHBhdHRlcm4gPSB0aGlzLmRhc2hlZCA/IFszLDNdIDogWzMsMF07XHJcbiAgICAgICAgICAgIFZleC5GbG93LlJlbmRlcmVyLmRyYXdEYXNoZWRMaW5lKGN0eCwgZG90X3ggKyBlbmQsIGRvdF95LCBkb3RfeCArIGVuZCwgZG90X3kgKyBsZW4sIHBhdHRlcm4pO1xyXG4gICAgICAgICAgICBicmVhaztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGN0eC5yZXN0b3JlKCk7XHJcbiAgICB9XHJcbiAgfSk7XHJcblxyXG4gIHJldHVybiBTdHJpbmdOdW1iZXI7XHJcbn0oKSk7XHJcblxuLy8gW1ZleEZsb3ddKGh0dHA6Ly92ZXhmbG93LmNvbSkgLSBDb3B5cmlnaHQgKGMpIE1vaGl0IE11dGhhbm5hIDIwMTAuXHJcbi8vIEF1dGhvcjogTGFycnkgS3VobnNcclxuLy9cclxuLy8gIyMgRGVzY3JpcHRpb25cclxuLy9cclxuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgdGhlIGBTdHJva2VgIGNsYXNzIHdoaWNoIHJlbmRlcnMgY2hvcmQgc3Ryb2tlc1xyXG4vLyB0aGF0IGNhbiBiZSBhcnBlZ2dpYXRlZCwgYnJ1c2hlZCwgcmFzcXVlZG8sIGV0Yy5cclxuXHJcblZleC5GbG93LlN0cm9rZSA9IChmdW5jdGlvbigpIHtcclxuICBmdW5jdGlvbiBTdHJva2UodHlwZSwgb3B0aW9ucykge1xyXG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodHlwZSwgb3B0aW9ucyk7XHJcbiAgfVxyXG4gIFN0cm9rZS5DQVRFR09SWSA9IFwic3Ryb2tlc1wiO1xyXG5cclxuICBTdHJva2UuVHlwZSA9IHtcclxuICAgIEJSVVNIX0RPV046IDEsXHJcbiAgICBCUlVTSF9VUDogMixcclxuICAgIFJPTExfRE9XTjogMywgICAgICAgIC8vIEFycGVnaWF0ZWQgY2hvcmRcclxuICAgIFJPTExfVVA6IDQsICAgICAgICAgIC8vIEFycGVnaWF0ZWQgY2hvcmRcclxuICAgIFJBU1FVRURPX0RPV046IDUsXHJcbiAgICBSQVNRVUVET19VUDogNlxyXG4gIH07XHJcblxyXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xyXG5cclxuICAvLyAjIyBTdGF0aWMgTWV0aG9kc1xyXG5cclxuICAvLyBBcnJhbmdlIHN0cm9rZXMgaW5zaWRlIGBNb2RpZmllckNvbnRleHRgXHJcbiAgU3Ryb2tlLmZvcm1hdCA9IGZ1bmN0aW9uKHN0cm9rZXMsIHN0YXRlKSB7XHJcbiAgICB2YXIgbGVmdF9zaGlmdCA9IHN0YXRlLmxlZnRfc2hpZnQ7XHJcbiAgICB2YXIgc3Ryb2tlX3NwYWNpbmcgPSAwO1xyXG5cclxuICAgIGlmICghc3Ryb2tlcyB8fCBzdHJva2VzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRoaXM7XHJcblxyXG4gICAgdmFyIHN0cl9saXN0ID0gW107XHJcbiAgICB2YXIgaSwgc3RyLCBzaGlmdDtcclxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJva2VzLmxlbmd0aDsgKytpKSB7XHJcbiAgICAgIHN0ciA9IHN0cm9rZXNbaV07XHJcbiAgICAgIHZhciBub3RlID0gc3RyLmdldE5vdGUoKTtcclxuICAgICAgdmFyIHByb3BzO1xyXG4gICAgICBpZiAobm90ZSBpbnN0YW5jZW9mIFZleC5GbG93LlN0YXZlTm90ZSkge1xyXG4gICAgICAgIHByb3BzID0gbm90ZS5nZXRLZXlQcm9wcygpW3N0ci5nZXRJbmRleCgpXTtcclxuICAgICAgICBzaGlmdCA9IChwcm9wcy5kaXNwbGFjZWQgPyBub3RlLmdldEV4dHJhTGVmdFB4KCkgOiAwKTtcclxuICAgICAgICBzdHJfbGlzdC5wdXNoKHsgbGluZTogcHJvcHMubGluZSwgc2hpZnQ6IHNoaWZ0LCBzdHI6IHN0ciB9KTtcclxuICAgICAgfSBlbHNlIHtcclxuICAgICAgICBwcm9wcyA9IG5vdGUuZ2V0UG9zaXRpb25zKClbc3RyLmdldEluZGV4KCldO1xyXG4gICAgICAgIHN0cl9saXN0LnB1c2goeyBsaW5lOiBwcm9wcy5zdHIsIHNoaWZ0OiAwLCBzdHI6IHN0ciB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIHZhciBzdHJfc2hpZnQgPSBsZWZ0X3NoaWZ0O1xyXG4gICAgdmFyIHhfc2hpZnQgPSAwO1xyXG5cclxuICAgIC8vIFRoZXJlIGNhbiBvbmx5IGJlIG9uZSBzdHJva2UgLi4gaWYgbW9yZSB0aGFuIG9uZSwgdGhleSBvdmVybGF5IGVhY2ggb3RoZXJcclxuICAgIGZvciAoaSA9IDA7IGkgPCBzdHJfbGlzdC5sZW5ndGg7ICsraSkge1xyXG4gICAgICBzdHIgPSBzdHJfbGlzdFtpXS5zdHI7XHJcbiAgICAgIHNoaWZ0ID0gc3RyX2xpc3RbaV0uc2hpZnQ7XHJcblxyXG4gICAgICBzdHIuc2V0WFNoaWZ0KHN0cl9zaGlmdCArIHNoaWZ0KTtcclxuICAgICAgeF9zaGlmdCA9IE1hdGgubWF4KHN0ci5nZXRXaWR0aCgpICsgc3Ryb2tlX3NwYWNpbmcsIHhfc2hpZnQpO1xyXG4gICAgfVxyXG5cclxuICAgIHN0YXRlLmxlZnRfc2hpZnQgKz0geF9zaGlmdDtcclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH07XHJcblxyXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXHJcbiAgVmV4LkluaGVyaXQoU3Ryb2tlLCBNb2RpZmllciwge1xyXG4gICAgaW5pdDogZnVuY3Rpb24odHlwZSwgb3B0aW9ucykge1xyXG4gICAgICBTdHJva2Uuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcyk7XHJcblxyXG4gICAgICB0aGlzLm5vdGUgPSBudWxsO1xyXG4gICAgICB0aGlzLm9wdGlvbnMgPSBWZXguTWVyZ2Uoe30sIG9wdGlvbnMpO1xyXG5cclxuICAgICAgLy8gbXVsdGkgdm9pY2UgLSBzcGFuIHN0cm9rZSBhY3Jvc3MgYWxsIHZvaWNlcyBpZiB0cnVlXHJcbiAgICAgIHRoaXMuYWxsX3ZvaWNlcyA9ICdhbGxfdm9pY2VzJyBpbiB0aGlzLm9wdGlvbnMgP1xyXG4gICAgICAgIHRoaXMub3B0aW9ucy5hbGxfdm9pY2VzIDogdHJ1ZTtcclxuXHJcbiAgICAgIC8vIG11bHRpIHZvaWNlIC0gZW5kIG5vdGUgb2Ygc3Ryb2tlLCBzZXQgaW4gZHJhdygpXHJcbiAgICAgIHRoaXMubm90ZV9lbmQgPSBudWxsO1xyXG4gICAgICB0aGlzLmluZGV4ID0gbnVsbDtcclxuICAgICAgdGhpcy50eXBlID0gdHlwZTtcclxuICAgICAgdGhpcy5wb3NpdGlvbiA9IE1vZGlmaWVyLlBvc2l0aW9uLkxFRlQ7XHJcblxyXG4gICAgICB0aGlzLnJlbmRlcl9vcHRpb25zID0ge1xyXG4gICAgICAgIGZvbnRfc2NhbGU6IDM4LFxyXG4gICAgICAgIHN0cm9rZV9weDogMyxcclxuICAgICAgICBzdHJva2Vfc3BhY2luZzogMTBcclxuICAgICAgfTtcclxuXHJcbiAgICAgIHRoaXMuZm9udCA9IHtcclxuICAgICAgIGZhbWlseTogXCJzZXJpZlwiLFxyXG4gICAgICAgc2l6ZTogMTAsXHJcbiAgICAgICB3ZWlnaHQ6IFwiYm9sZCBpdGFsaWNcIlxyXG4gICAgIH07XHJcblxyXG4gICAgICB0aGlzLnNldFhTaGlmdCgwKTtcclxuICAgICAgdGhpcy5zZXRXaWR0aCgxMCk7XHJcbiAgICB9LFxyXG5cclxuICAgIGdldFBvc2l0aW9uOiBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXMucG9zaXRpb247IH0sXHJcbiAgICBhZGRFbmROb3RlOiBmdW5jdGlvbihub3RlKSB7IHRoaXMubm90ZV9lbmQgPSBub3RlOyByZXR1cm4gdGhpczsgfSxcclxuXHJcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcclxuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFxyXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBzdHJva2Ugd2l0aG91dCBhIGNvbnRleHQuXCIpO1xyXG4gICAgICBpZiAoISh0aGlzLm5vdGUgJiYgKHRoaXMuaW5kZXggIT0gbnVsbCkpKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0F0dGFjaGVkTm90ZVwiLFxyXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBzdHJva2Ugd2l0aG91dCBhIG5vdGUgYW5kIGluZGV4LlwiKTtcclxuICAgICAgdmFyIHN0YXJ0ID0gdGhpcy5ub3RlLmdldE1vZGlmaWVyU3RhcnRYWSh0aGlzLnBvc2l0aW9uLCB0aGlzLmluZGV4KTtcclxuICAgICAgdmFyIHlzID0gdGhpcy5ub3RlLmdldFlzKCk7XHJcbiAgICAgIHZhciB0b3BZID0gc3RhcnQueTtcclxuICAgICAgdmFyIGJvdFkgPSBzdGFydC55O1xyXG4gICAgICB2YXIgeCA9IHN0YXJ0LnggLSA1O1xyXG4gICAgICB2YXIgbGluZV9zcGFjZSA9IHRoaXMubm90ZS5zdGF2ZS5vcHRpb25zLnNwYWNpbmdfYmV0d2Vlbl9saW5lc19weDtcclxuXHJcbiAgICAgIHZhciBub3RlcyA9IHRoaXMuZ2V0TW9kaWZpZXJDb250ZXh0KCkuZ2V0TW9kaWZpZXJzKHRoaXMubm90ZS5nZXRDYXRlZ29yeSgpKTtcclxuICAgICAgdmFyIGk7XHJcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBub3Rlcy5sZW5ndGg7IGkrKykge1xyXG4gICAgICAgIHlzID0gbm90ZXNbaV0uZ2V0WXMoKTtcclxuICAgICAgICBmb3IgKHZhciBuID0gMDsgbiA8IHlzLmxlbmd0aDsgbisrKSB7XHJcbiAgICAgICAgICBpZiAodGhpcy5ub3RlID09IG5vdGVzW2ldIHx8IHRoaXMuYWxsX3ZvaWNlcykge1xyXG4gICAgICAgICAgICB0b3BZID0gVmV4Lk1pbih0b3BZLCB5c1tuXSk7XHJcbiAgICAgICAgICAgIGJvdFkgPSBWZXguTWF4KGJvdFksIHlzW25dKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHZhciBhcnJvdywgYXJyb3dfc2hpZnRfeCwgYXJyb3dfeSwgdGV4dF9zaGlmdF94LCB0ZXh0X3k7XHJcbiAgICAgIHN3aXRjaCAodGhpcy50eXBlKSB7XHJcbiAgICAgICAgY2FzZSBTdHJva2UuVHlwZS5CUlVTSF9ET1dOOlxyXG4gICAgICAgICAgYXJyb3cgPSBcInZjM1wiO1xyXG4gICAgICAgICAgYXJyb3dfc2hpZnRfeCA9IC0zO1xyXG4gICAgICAgICAgYXJyb3dfeSA9IHRvcFkgLSAobGluZV9zcGFjZSAvIDIpICsgMTA7XHJcbiAgICAgICAgICBib3RZICs9IChsaW5lX3NwYWNlIC8gMik7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgICBjYXNlIFN0cm9rZS5UeXBlLkJSVVNIX1VQOlxyXG4gICAgICAgICAgYXJyb3cgPSBcInYxMVwiO1xyXG4gICAgICAgICAgYXJyb3dfc2hpZnRfeCA9IDAuNTtcclxuICAgICAgICAgIGFycm93X3kgPSBib3RZICsgKGxpbmVfc3BhY2UgLyAyKTtcclxuICAgICAgICAgIHRvcFkgLT0gKGxpbmVfc3BhY2UgLyAyKTtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgU3Ryb2tlLlR5cGUuUk9MTF9ET1dOOlxyXG4gICAgICAgIGNhc2UgU3Ryb2tlLlR5cGUuUkFTUVVFRE9fRE9XTjpcclxuICAgICAgICAgIGFycm93ID0gXCJ2YzNcIjtcclxuICAgICAgICAgIGFycm93X3NoaWZ0X3ggPSAtMztcclxuICAgICAgICAgIHRleHRfc2hpZnRfeCA9IHRoaXMueF9zaGlmdCArIGFycm93X3NoaWZ0X3ggLSAyO1xyXG4gICAgICAgICAgaWYgKHRoaXMubm90ZSBpbnN0YW5jZW9mIFZleC5GbG93LlN0YXZlTm90ZSkge1xyXG4gICAgICAgICAgICB0b3BZICs9IDEuNSAqIGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICAgIGlmICgoYm90WSAtIHRvcFkpICUgMiAhPT0gMCkge1xyXG4gICAgICAgICAgICAgIGJvdFkgKz0gMC41ICogbGluZV9zcGFjZTtcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBib3RZICs9IGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJyb3dfeSA9IHRvcFkgLSBsaW5lX3NwYWNlO1xyXG4gICAgICAgICAgICB0ZXh0X3kgPSBib3RZICsgbGluZV9zcGFjZSArIDI7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0b3BZICs9IDEuNSAqIGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICAgIGJvdFkgKz0gbGluZV9zcGFjZTtcclxuICAgICAgICAgICAgYXJyb3dfeSA9IHRvcFkgLSAwLjc1ICogbGluZV9zcGFjZTtcclxuICAgICAgICAgICAgdGV4dF95ID0gYm90WSArIDAuMjUgKiBsaW5lX3NwYWNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSBTdHJva2UuVHlwZS5ST0xMX1VQOlxyXG4gICAgICAgIGNhc2UgU3Ryb2tlLlR5cGUuUkFTUVVFRE9fVVA6XHJcbiAgICAgICAgICBhcnJvdyA9IFwidjUyXCI7XHJcbiAgICAgICAgICBhcnJvd19zaGlmdF94ID0gLTQ7XHJcbiAgICAgICAgICB0ZXh0X3NoaWZ0X3ggPSB0aGlzLnhfc2hpZnQgKyBhcnJvd19zaGlmdF94IC0gMTtcclxuICAgICAgICAgIGlmICh0aGlzLm5vdGUgaW5zdGFuY2VvZiBWZXguRmxvdy5TdGF2ZU5vdGUpIHtcclxuICAgICAgICAgICAgYXJyb3dfeSA9IGxpbmVfc3BhY2UgLyAyO1xyXG4gICAgICAgICAgICB0b3BZICs9IDAuNSAqIGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICAgIGlmICgoYm90WSAtIHRvcFkpICUgMiA9PT0gMCkge1xyXG4gICAgICAgICAgICAgIGJvdFkgKz0gbGluZV9zcGFjZSAvIDI7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgYXJyb3dfeSA9IGJvdFkgKyAwLjUgKiBsaW5lX3NwYWNlO1xyXG4gICAgICAgICAgICB0ZXh0X3kgPSB0b3BZIC0gMS4yNSAqIGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgICB0b3BZICs9IDAuMjUgKiBsaW5lX3NwYWNlO1xyXG4gICAgICAgICAgICBib3RZICs9IDAuNSAqIGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICAgIGFycm93X3kgPSBib3RZICsgMC4yNSAqIGxpbmVfc3BhY2U7XHJcbiAgICAgICAgICAgIHRleHRfeSA9IHRvcFkgLSBsaW5lX3NwYWNlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIERyYXcgdGhlIHN0cm9rZVxyXG4gICAgICBpZiAodGhpcy50eXBlID09IFN0cm9rZS5UeXBlLkJSVVNIX0RPV04gfHxcclxuICAgICAgICAgIHRoaXMudHlwZSA9PSBTdHJva2UuVHlwZS5CUlVTSF9VUCkge1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5maWxsUmVjdCh4ICsgdGhpcy54X3NoaWZ0LCB0b3BZLCAxLCBib3RZIC0gdG9wWSk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgaWYgKHRoaXMubm90ZSBpbnN0YW5jZW9mIFZleC5GbG93LlN0YXZlTm90ZSkge1xyXG4gICAgICAgICAgZm9yIChpID0gdG9wWTsgaSA8PSBib3RZOyBpICs9IGxpbmVfc3BhY2UpIHtcclxuICAgICAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgodGhpcy5jb250ZXh0LCB4ICsgdGhpcy54X3NoaWZ0IC0gNCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5mb250X3NjYWxlLCBcInZhM1wiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgZm9yIChpID0gdG9wWTsgaSA8PSBib3RZOyBpKz0gMTApIHtcclxuICAgICAgICAgICAgVmV4LkZsb3cucmVuZGVyR2x5cGgodGhpcy5jb250ZXh0LCB4ICsgdGhpcy54X3NoaWZ0IC0gNCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5mb250X3NjYWxlLCBcInZhM1wiKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICAgIGlmICh0aGlzLnR5cGUgPT0gVmV4LkZsb3cuU3Ryb2tlLlR5cGUuUkFTUVVFRE9fRE9XTilcclxuICAgICAgICAgICAgdGV4dF95ID0gaSArIDAuMjUgKiBsaW5lX3NwYWNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gRHJhdyB0aGUgYXJyb3cgaGVhZFxyXG4gICAgICBWZXguRmxvdy5yZW5kZXJHbHlwaCh0aGlzLmNvbnRleHQsIHggKyB0aGlzLnhfc2hpZnQgKyBhcnJvd19zaGlmdF94LCBhcnJvd195LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLmZvbnRfc2NhbGUsIGFycm93KTtcclxuXHJcbiAgICAgIC8vIERyYXcgdGhlIHJhc3F1ZWRvIFwiUlwiXHJcbiAgICAgIGlmICh0aGlzLnR5cGUgPT0gU3Ryb2tlLlR5cGUuUkFTUVVFRE9fRE9XTiB8fFxyXG4gICAgICAgICAgdGhpcy50eXBlID09IFN0cm9rZS5UeXBlLlJBU1FVRURPX1VQKSB7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LnNhdmUoKTtcclxuICAgICAgICB0aGlzLmNvbnRleHQuc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSwgdGhpcy5mb250LndlaWdodCk7XHJcbiAgICAgICAgdGhpcy5jb250ZXh0LmZpbGxUZXh0KFwiUlwiLCB4ICsgdGV4dF9zaGlmdF94LCB0ZXh0X3kpO1xyXG4gICAgICAgIHRoaXMuY29udGV4dC5yZXN0b3JlKCk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgcmV0dXJuIFN0cm9rZTtcclxufSgpKTtcbi8vIFZleEZsb3cgLSBNdXNpYyBFbmdyYXZpbmcgZm9yIEhUTUw1XG4vLyBDb3B5cmlnaHQgTW9oaXQgTXV0aGFubmEgMjAxMFxuLy9cbi8vIFRoaXMgY2xhc3MgaW1wbGVtZW50cyBjdXJ2ZXMgKGZvciBzbHVycylcblxuVmV4LkZsb3cuQ3VydmUgPSAoZnVuY3Rpb24oKSB7XG4gIC8vIGZyb206IFN0YXJ0IG5vdGVcbiAgLy8gdG86IEVuZCBub3RlXG4gIC8vIG9wdGlvbnM6XG4gIC8vICAgIGNwczogTGlzdCBvZiBjb250cm9sIHBvaW50c1xuICAvLyAgICB4X3NoaWZ0OiBwaXhlbHMgdG8gc2hpZnRcbiAgLy8gICAgeV9zaGlmdDogcGl4ZWxzIHRvIHNoaWZ0XG4gIGZ1bmN0aW9uIEN1cnZlKGZyb20sIHRvLCBvcHRpb25zKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQoZnJvbSwgdG8sIG9wdGlvbnMpO1xuICB9XG5cbiAgQ3VydmUuUG9zaXRpb24gPSB7XG4gICAgTkVBUl9IRUFEOiAxLFxuICAgIE5FQVJfVE9QOiAyXG4gIH07XG5cbiAgQ3VydmUuREVCVUcgPSB0cnVlO1xuXG4gIEN1cnZlLnByb3RvdHlwZSA9IHtcbiAgICBpbml0OiBmdW5jdGlvbihmcm9tLCB0bywgb3B0aW9ucykge1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgc3BhY2luZzogMixcbiAgICAgICAgdGhpY2tuZXNzOiAyLFxuICAgICAgICB4X3NoaWZ0OiAwLFxuICAgICAgICB5X3NoaWZ0OiAxMCxcbiAgICAgICAgcG9zaXRpb246IEN1cnZlLlBvc2l0aW9uLk5FQVJfSEVBRCxcbiAgICAgICAgaW52ZXJ0OiBmYWxzZSxcbiAgICAgICAgY3BzOiBbe3g6IDAsIHk6IDEwfSwge3g6IDAsIHk6IDEwfV1cbiAgICAgIH07XG5cbiAgICAgIFZleC5NZXJnZSh0aGlzLnJlbmRlcl9vcHRpb25zLCBvcHRpb25zKTtcbiAgICAgIHRoaXMuc2V0Tm90ZXMoZnJvbSwgdG8pO1xuICAgIH0sXG5cbiAgICBzZXRDb250ZXh0OiBmdW5jdGlvbihjb250ZXh0KSB7IHRoaXMuY29udGV4dCA9IGNvbnRleHQ7IHJldHVybiB0aGlzOyB9LFxuICAgIHNldE5vdGVzOiBmdW5jdGlvbihmcm9tLCB0bykge1xuICAgICAgaWYgKCFmcm9tICYmICF0bylcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIixcbiAgICAgICAgICAgIFwiQ3VydmUgbmVlZHMgdG8gaGF2ZSBlaXRoZXIgZmlyc3Rfbm90ZSBvciBsYXN0X25vdGUgc2V0LlwiKTtcblxuICAgICAgdGhpcy5mcm9tID0gZnJvbTtcbiAgICAgIHRoaXMudG8gPSB0bztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvKipcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufSBSZXR1cm5zIHRydWUgaWYgdGhpcyBpcyBhIHBhcnRpYWwgYmFyLlxuICAgICAqL1xuICAgIGlzUGFydGlhbDogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gKCF0aGlzLmZyb20gfHwgIXRoaXMudG8pO1xuICAgIH0sXG5cbiAgICByZW5kZXJDdXJ2ZTogZnVuY3Rpb24ocGFyYW1zKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIGNwcyA9IHRoaXMucmVuZGVyX29wdGlvbnMuY3BzO1xuXG4gICAgICB2YXIgeF9zaGlmdCA9IHRoaXMucmVuZGVyX29wdGlvbnMueF9zaGlmdDtcbiAgICAgIHZhciB5X3NoaWZ0ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy55X3NoaWZ0ICogcGFyYW1zLmRpcmVjdGlvbjtcblxuICAgICAgdmFyIGZpcnN0X3ggPSBwYXJhbXMuZmlyc3RfeCArIHhfc2hpZnQ7XG4gICAgICB2YXIgZmlyc3RfeSA9IHBhcmFtcy5maXJzdF95ICsgeV9zaGlmdDtcbiAgICAgIHZhciBsYXN0X3ggPSBwYXJhbXMubGFzdF94IC0geF9zaGlmdDtcbiAgICAgIHZhciBsYXN0X3kgPSBwYXJhbXMubGFzdF95ICsgeV9zaGlmdDtcbiAgICAgIHZhciB0aGlja25lc3MgPSB0aGlzLnJlbmRlcl9vcHRpb25zLnRoaWNrbmVzcztcblxuICAgICAgdmFyIGNwX3NwYWNpbmcgPSAobGFzdF94IC0gZmlyc3RfeCkgLyAoY3BzLmxlbmd0aCArIDIpO1xuXG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBjdHgubW92ZVRvKGZpcnN0X3gsIGZpcnN0X3kpO1xuICAgICAgY3R4LmJlemllckN1cnZlVG8oZmlyc3RfeCArIGNwX3NwYWNpbmcgKyBjcHNbMF0ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X3kgKyAoY3BzWzBdLnkgKiBwYXJhbXMuZGlyZWN0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfeCAtIGNwX3NwYWNpbmcgKyBjcHNbMV0ueCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGxhc3RfeSArIChjcHNbMV0ueSAqIHBhcmFtcy5kaXJlY3Rpb24pLFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF94LCBsYXN0X3kpO1xuICAgICAgY3R4LmJlemllckN1cnZlVG8obGFzdF94IC0gY3Bfc3BhY2luZyArIGNwc1sxXS54LFxuICAgICAgICAgICAgICAgICAgICAgICAgbGFzdF95ICsgKChjcHNbMV0ueSArIHRoaWNrbmVzcykgKiBwYXJhbXMuZGlyZWN0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X3ggKyBjcF9zcGFjaW5nICsgY3BzWzBdLngsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaXJzdF95ICsgKChjcHNbMF0ueSArIHRoaWNrbmVzcykgKiBwYXJhbXMuZGlyZWN0aW9uKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIGZpcnN0X3gsIGZpcnN0X3kpO1xuICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgY3R4LmZpbGwoKTtcbiAgICB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dClcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9Db250ZXh0XCIsIFwiTm8gY29udGV4dCB0byByZW5kZXIgdGllLlwiKTtcbiAgICAgIHZhciBmaXJzdF9ub3RlID0gdGhpcy5mcm9tO1xuICAgICAgdmFyIGxhc3Rfbm90ZSA9IHRoaXMudG87XG4gICAgICB2YXIgZmlyc3RfeCwgbGFzdF94LCBmaXJzdF95LCBsYXN0X3ksIHN0ZW1fZGlyZWN0aW9uO1xuXG4gICAgICB2YXIgbWV0cmljID0gXCJiYXNlWVwiO1xuICAgICAgdmFyIGVuZF9tZXRyaWMgPSBcImJhc2VZXCI7XG4gICAgICB2YXIgcG9zaXRpb24gPSB0aGlzLnJlbmRlcl9vcHRpb25zLnBvc2l0aW9uO1xuICAgICAgdmFyIHBvc2l0aW9uX2VuZCA9IHRoaXMucmVuZGVyX29wdGlvbnMucG9zaXRpb25fZW5kO1xuXG4gICAgICBpZiAocG9zaXRpb24gPT09IEN1cnZlLlBvc2l0aW9uLk5FQVJfVE9QKSB7XG4gICAgICAgIG1ldHJpYyA9IFwidG9wWVwiO1xuICAgICAgICBlbmRfbWV0cmljID0gXCJ0b3BZXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChwb3NpdGlvbl9lbmQgPT0gQ3VydmUuUG9zaXRpb24uTkVBUl9IRUFEKSB7XG4gICAgICAgIGVuZF9tZXRyaWMgPSBcImJhc2VZXCI7XG4gICAgICB9IGVsc2UgaWYgKHBvc2l0aW9uX2VuZCA9PSBDdXJ2ZS5Qb3NpdGlvbi5ORUFSX1RPUCkge1xuICAgICAgICBlbmRfbWV0cmljID0gXCJ0b3BZXCI7XG4gICAgICB9XG5cbiAgICAgIGlmIChmaXJzdF9ub3RlKSB7XG4gICAgICAgIGZpcnN0X3ggPSBmaXJzdF9ub3RlLmdldFRpZVJpZ2h0WCgpO1xuICAgICAgICBzdGVtX2RpcmVjdGlvbiA9IGZpcnN0X25vdGUuZ2V0U3RlbURpcmVjdGlvbigpO1xuICAgICAgICBmaXJzdF95ID0gZmlyc3Rfbm90ZS5nZXRTdGVtRXh0ZW50cygpW21ldHJpY107XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdF94ID0gbGFzdF9ub3RlLmdldFN0YXZlKCkuZ2V0VGllU3RhcnRYKCk7XG4gICAgICAgIGZpcnN0X3kgPSBsYXN0X25vdGUuZ2V0U3RlbUV4dGVudHMoKVttZXRyaWNdO1xuICAgICAgfVxuXG4gICAgICBpZiAobGFzdF9ub3RlKSB7XG4gICAgICAgIGxhc3RfeCA9IGxhc3Rfbm90ZS5nZXRUaWVMZWZ0WCgpO1xuICAgICAgICBzdGVtX2RpcmVjdGlvbiA9IGxhc3Rfbm90ZS5nZXRTdGVtRGlyZWN0aW9uKCk7XG4gICAgICAgIGxhc3RfeSA9IGxhc3Rfbm90ZS5nZXRTdGVtRXh0ZW50cygpW2VuZF9tZXRyaWNdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGFzdF94ID0gZmlyc3Rfbm90ZS5nZXRTdGF2ZSgpLmdldFRpZUVuZFgoKTtcbiAgICAgICAgbGFzdF95ID0gZmlyc3Rfbm90ZS5nZXRTdGVtRXh0ZW50cygpW2VuZF9tZXRyaWNdO1xuICAgICAgfVxuXG4gICAgICB0aGlzLnJlbmRlckN1cnZlKHtcbiAgICAgICAgZmlyc3RfeDogZmlyc3RfeCxcbiAgICAgICAgbGFzdF94OiBsYXN0X3gsXG4gICAgICAgIGZpcnN0X3k6IGZpcnN0X3ksXG4gICAgICAgIGxhc3RfeTogbGFzdF95LFxuICAgICAgICBkaXJlY3Rpb246IHN0ZW1fZGlyZWN0aW9uICpcbiAgICAgICAgICAodGhpcy5yZW5kZXJfb3B0aW9ucy5pbnZlcnQgPT09IHRydWUgPyAtMSA6IDEpXG4gICAgICB9KTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgfTtcblxuICByZXR1cm4gQ3VydmU7XG59KCkpO1xuXG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIGBTdGF2ZUxpbmVgIHdoaWNoIGFyZSBzaW1wbHkgbGluZXMgdGhhdCBjb25uZWN0XG4vLyB0d28gbm90ZXMuIFRoaXMgb2JqZWN0IGlzIGhpZ2hseSBjb25maWd1cmFibGUsIHNlZSB0aGUgYHJlbmRlcl9vcHRpb25zYC5cbi8vIEEgc2ltcGxlIGxpbmUgaXMgb2Z0ZW4gdXNlZCBmb3Igbm90YXRpbmcgZ2xpc3NhbmRvIGFydGljdWxhdGlvbnMsIGJ1dCB5b3Vcbi8vIGNhbiBmb3JtYXQgYSBgU3RhdmVMaW5lYCB3aXRoIGFycm93cyBvciBjb2xvcnMgZm9yIG1vcmUgcGVkYWdvZ2ljYWxcbi8vIHB1cnBvc2VzLCBzdWNoIGFzIGRpYWdyYW1zLlxuVmV4LkZsb3cuU3RhdmVMaW5lID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBTdGF2ZUxpbmUobm90ZXMpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDApIHRoaXMuaW5pdChub3Rlcyk7XG4gIH1cblxuICAvLyBUZXh0IFBvc2l0aW9uaW5nXG4gIFN0YXZlTGluZS5UZXh0VmVydGljYWxQb3NpdGlvbiA9IHtcbiAgICBUT1A6IDEsXG4gICAgQk9UVE9NOiAyXG4gIH07XG5cbiAgU3RhdmVMaW5lLlRleHRKdXN0aWZpY2F0aW9uID0ge1xuICAgIExFRlQ6IDEsXG4gICAgQ0VOVEVSOiAyLFxuICAgIFJJR0hUOiAzXG4gIH07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgU3RhdmVMaW5lLnByb3RvdHlwZSA9IHtcbiAgICAvLyBJbml0aWFsaXplIHRoZSBTdGF2ZUxpbmUgd2l0aCB0aGUgZ2l2ZW4gYG5vdGVzYC5cbiAgICAvL1xuICAgIC8vIGBub3Rlc2AgaXMgYSBzdHJ1Y3QgdGhhdCBoYXM6XG4gICAgLy9cbiAgICAvLyAgYGBgXG4gICAgLy8gIHtcbiAgICAvLyAgICBmaXJzdF9ub3RlOiBOb3RlLFxuICAgIC8vICAgIGxhc3Rfbm90ZTogTm90ZSxcbiAgICAvLyAgICBmaXJzdF9pbmRpY2VzOiBbbjEsIG4yLCBuM10sXG4gICAgLy8gICAgbGFzdF9pbmRpY2VzOiBbbjEsIG4yLCBuM11cbiAgICAvLyAgfVxuICAgIC8vICBgYGBcbiAgICBpbml0OiBmdW5jdGlvbihub3Rlcykge1xuICAgICAgdGhpcy5ub3RlcyA9IG5vdGVzO1xuICAgICAgdGhpcy5jb250ZXh0ID0gbnVsbDtcblxuICAgICAgdGhpcy50ZXh0ID0gXCJcIjtcblxuICAgICAgdGhpcy5mb250ID0ge1xuICAgICAgICBmYW1pbHk6IFwiQXJpYWxcIixcbiAgICAgICAgc2l6ZTogMTAsXG4gICAgICAgIHdlaWdodDogXCJcIlxuICAgICAgfTtcblxuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgLy8gU3BhY2UgdG8gYWRkIHRvIHRoZSBsZWZ0IG9yIHRoZSByaWdodFxuICAgICAgICBwYWRkaW5nX2xlZnQ6IDQsXG4gICAgICAgIHBhZGRpbmdfcmlnaHQ6IDMsXG5cbiAgICAgICAgLy8gVGhlIHdpZHRoIG9mIHRoZSBsaW5lIGluIHBpeGVsc1xuICAgICAgICBsaW5lX3dpZHRoOiAxLFxuICAgICAgICAvLyBBbiBhcnJheSBvZiBsaW5lL3NwYWNlIGxlbmd0aHMuIFVuc3VwcG9ydGVkIHdpdGggUmFwaGFlbCAoU1ZHKVxuICAgICAgICBsaW5lX2Rhc2g6IG51bGwsXG4gICAgICAgIC8vIENhbiBkcmF3IHJvdW5kZWQgbGluZSBlbmQsIGluc3RlYWQgb2YgYSBzcXVhcmUuIFVuc3VwcG9ydGVkIHdpdGggUmFwaGFlbCAoU1ZHKVxuICAgICAgICByb3VuZGVkX2VuZDogdHJ1ZSxcbiAgICAgICAgLy8gVGhlIGNvbG9yIG9mIHRoZSBsaW5lIGFuZCBhcnJvd2hlYWRzXG4gICAgICAgIGNvbG9yOiBudWxsLFxuXG4gICAgICAgIC8vIEZsYWdzIHRvIGRyYXcgYXJyb3dzIG9uIGVhY2ggZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgIGRyYXdfc3RhcnRfYXJyb3c6IGZhbHNlLFxuICAgICAgICBkcmF3X2VuZF9hcnJvdzogZmFsc2UsXG5cbiAgICAgICAgLy8gVGhlIGxlbmd0aCBvZiB0aGUgYXJyb3doZWFkIHNpZGVzXG4gICAgICAgIGFycm93aGVhZF9sZW5ndGg6IDEwLFxuICAgICAgICAvLyBUaGUgYW5nbGUgb2YgdGhlIGFycm93aGVhZFxuICAgICAgICBhcnJvd2hlYWRfYW5nbGU6IE1hdGguUEkgLyA4LFxuXG4gICAgICAgIC8vIFRoZSBwb3NpdGlvbiBvZiB0aGUgdGV4dFxuICAgICAgICB0ZXh0X3Bvc2l0aW9uX3ZlcnRpY2FsOiBTdGF2ZUxpbmUuVGV4dFZlcnRpY2FsUG9zaXRpb24uVE9QLFxuICAgICAgICB0ZXh0X2p1c3RpZmljYXRpb246IFN0YXZlTGluZS5UZXh0SnVzdGlmaWNhdGlvbi5DRU5URVJcbiAgICAgIH07XG5cbiAgICAgIHRoaXMuc2V0Tm90ZXMobm90ZXMpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIHJlbmRlcmluZyBjb250ZXh0XG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkgeyB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyByZXR1cm4gdGhpczsgfSxcbiAgICAvLyBTZXQgdGhlIGZvbnQgZm9yIHRoZSBgU3RhdmVMaW5lYCB0ZXh0XG4gICAgc2V0Rm9udDogZnVuY3Rpb24oZm9udCkgeyB0aGlzLmZvbnQgPSBmb250OyByZXR1cm4gdGhpczsgfSxcbiAgICAvLyBUaGUgdGhlIGFubm90YXRpb24gZm9yIHRoZSBgU3RhdmVMaW5lYFxuICAgIHNldFRleHQ6IGZ1bmN0aW9uKHRleHQpIHsgdGhpcy50ZXh0ID0gdGV4dDsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBTZXQgdGhlIG5vdGVzIGZvciB0aGUgYFN0YXZlTGluZWBcbiAgICBzZXROb3RlczogZnVuY3Rpb24obm90ZXMpIHtcbiAgICAgIGlmICghbm90ZXMuZmlyc3Rfbm90ZSAmJiAhbm90ZXMubGFzdF9ub3RlKVxuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIkJhZEFyZ3VtZW50c1wiLFxuICAgICAgICAgICAgXCJOb3RlcyBuZWVkcyB0byBoYXZlIGVpdGhlciBmaXJzdF9ub3RlIG9yIGxhc3Rfbm90ZSBzZXQuXCIpO1xuXG4gICAgICBpZiAoIW5vdGVzLmZpcnN0X2luZGljZXMpIG5vdGVzLmZpcnN0X2luZGljZXMgPSBbMF07XG4gICAgICBpZiAoIW5vdGVzLmxhc3RfaW5kaWNlcykgbm90ZXMubGFzdF9pbmRpY2VzID0gWzBdO1xuXG4gICAgICBpZiAobm90ZXMuZmlyc3RfaW5kaWNlcy5sZW5ndGggIT0gbm90ZXMubGFzdF9pbmRpY2VzLmxlbmd0aClcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SdW50aW1lRXJyb3IoXCJCYWRBcmd1bWVudHNcIiwgXCJDb25uZWN0ZWQgbm90ZXMgbXVzdCBoYXZlIHNpbWlsYXJcIiArXG4gICAgICAgICAgXCIgaW5kZXggc2l6ZXNcIik7XG5cbiAgICAgIC8vIFN1Y2Nlc3MuIExldHMgZ3JhYiAnZW0gbm90ZXMuXG4gICAgICB0aGlzLmZpcnN0X25vdGUgPSBub3Rlcy5maXJzdF9ub3RlO1xuICAgICAgdGhpcy5maXJzdF9pbmRpY2VzID0gbm90ZXMuZmlyc3RfaW5kaWNlcztcbiAgICAgIHRoaXMubGFzdF9ub3RlID0gbm90ZXMubGFzdF9ub3RlO1xuICAgICAgdGhpcy5sYXN0X2luZGljZXMgPSBub3Rlcy5sYXN0X2luZGljZXM7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gQXBwbHkgdGhlIHN0eWxlIG9mIHRoZSBgU3RhdmVMaW5lYCB0byB0aGUgY29udGV4dFxuICAgIGFwcGx5TGluZVN0eWxlOiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIk5vQ29udGV4dFwiLFwiTm8gY29udGV4dCB0byBhcHBseSB0aGUgc3R5bGluZyB0b1wiKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHJlbmRlcl9vcHRpb25zID0gdGhpcy5yZW5kZXJfb3B0aW9ucztcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmIChyZW5kZXJfb3B0aW9ucy5saW5lX2Rhc2gpIHtcbiAgICAgICAgY3R4LnNldExpbmVEYXNoKHJlbmRlcl9vcHRpb25zLmxpbmVfZGFzaCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW5kZXJfb3B0aW9ucy5saW5lX3dpZHRoKSB7XG4gICAgICAgIGN0eC5zZXRMaW5lV2lkdGgocmVuZGVyX29wdGlvbnMubGluZV93aWR0aCk7XG4gICAgICB9XG5cbiAgICAgIGlmIChyZW5kZXJfb3B0aW9ucy5yb3VuZGVkX2VuZCkge1xuICAgICAgICBjdHguc2V0TGluZUNhcChcInJvdW5kXCIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LnNldExpbmVDYXAoXCJzcXVhcmVcIik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIEFwcGx5IHRoZSB0ZXh0IHN0eWxpbmcgdG8gdGhlIGNvbnRleHRcbiAgICBhcHBseUZvbnRTdHlsZTogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcIk5vIGNvbnRleHQgdG8gYXBwbHkgdGhlIHN0eWxpbmcgdG9cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIGlmICh0aGlzLmZvbnQpIHtcbiAgICAgICAgY3R4LnNldEZvbnQodGhpcy5mb250LmZhbWlseSwgdGhpcy5mb250LnNpemUsIHRoaXMuZm9udC53ZWlnaHQpO1xuICAgICAgfVxuXG4gICAgICBpZiAodGhpcy5yZW5kZXJfb3B0aW9ucy5jb2xvcikge1xuICAgICAgICBjdHguc2V0U3Ryb2tlU3R5bGUodGhpcy5yZW5kZXJfb3B0aW9ucy5jb2xvcik7XG4gICAgICAgIGN0eC5zZXRGaWxsU3R5bGUodGhpcy5yZW5kZXJfb3B0aW9ucy5jb2xvcik7XG4gICAgICB9XG4gICAgfSxcblxuICAgIC8vIFJlbmRlcnMgdGhlIGBTdGF2ZUxpbmVgIG9uIHRoZSBjb250ZXh0XG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIiwgXCJObyBjb250ZXh0IHRvIHJlbmRlciBTdGF2ZUxpbmUuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIGZpcnN0X25vdGUgPSB0aGlzLmZpcnN0X25vdGU7XG4gICAgICB2YXIgbGFzdF9ub3RlID0gdGhpcy5sYXN0X25vdGU7XG4gICAgICB2YXIgcmVuZGVyX29wdGlvbnMgPSB0aGlzLnJlbmRlcl9vcHRpb25zO1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgdGhpcy5hcHBseUxpbmVTdHlsZSgpO1xuXG4gICAgICAvLyBDeWNsZSB0aHJvdWdoIGVhY2ggc2V0IG9mIGluZGljZXMgYW5kIGRyYXcgbGluZXNcbiAgICAgIHZhciBzdGFydF9wb3NpdGlvbjtcbiAgICAgIHZhciBlbmRfcG9zaXRpb247XG4gICAgICB0aGlzLmZpcnN0X2luZGljZXMuZm9yRWFjaChmdW5jdGlvbihmaXJzdF9pbmRleCwgaSkge1xuICAgICAgICB2YXIgbGFzdF9pbmRleCA9IHRoaXMubGFzdF9pbmRpY2VzW2ldO1xuXG4gICAgICAgIC8vIEdldCBpbml0aWFsIGNvb3JkaW5hdGVzIGZvciB0aGUgc3RhcnQvZW5kIG9mIHRoZSBsaW5lXG4gICAgICAgIHN0YXJ0X3Bvc2l0aW9uID0gZmlyc3Rfbm90ZS5nZXRNb2RpZmllclN0YXJ0WFkoMiwgZmlyc3RfaW5kZXgpO1xuICAgICAgICBlbmRfcG9zaXRpb24gPSBsYXN0X25vdGUuZ2V0TW9kaWZpZXJTdGFydFhZKDEsIGxhc3RfaW5kZXgpO1xuICAgICAgICB2YXIgdXB3YXJkc19zbG9wZSA9IHN0YXJ0X3Bvc2l0aW9uLnkgPiBlbmRfcG9zaXRpb24ueTtcblxuICAgICAgICAvLyBBZGp1c3QgYHhgIGNvb3JkaW5hdGVzIGZvciBtb2RpZmllcnNcbiAgICAgICAgc3RhcnRfcG9zaXRpb24ueCArPSBmaXJzdF9ub3RlLmdldE1ldHJpY3MoKS5tb2RSaWdodFB4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW5kZXJfb3B0aW9ucy5wYWRkaW5nX2xlZnQ7XG4gICAgICAgIGVuZF9wb3NpdGlvbi54IC09IGxhc3Rfbm90ZS5nZXRNZXRyaWNzKCkubW9kTGVmdFB4ICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmVuZGVyX29wdGlvbnMucGFkZGluZ19yaWdodDtcblxuXG4gICAgICAgIC8vIEFkanVzdCBmaXJzdCBgeGAgY29vcmRpbmF0ZXMgZm9yIGRpc3BsYWNlbWVudHNcbiAgICAgICAgdmFyIG5vdGVoZWFkX3dpZHRoID0gZmlyc3Rfbm90ZS5nZXRHbHlwaCgpLmhlYWRfd2lkdGg7XG4gICAgICAgIHZhciBmaXJzdF9kaXNwbGFjZWQgPSBmaXJzdF9ub3RlLmdldEtleVByb3BzKClbZmlyc3RfaW5kZXhdLmRpc3BsYWNlZDtcbiAgICAgICAgaWYgKGZpcnN0X2Rpc3BsYWNlZCAmJiBmaXJzdF9ub3RlLmdldFN0ZW1EaXJlY3Rpb24oKSA9PT0gMSkge1xuICAgICAgICAgIHN0YXJ0X3Bvc2l0aW9uLnggKz0gbm90ZWhlYWRfd2lkdGggKyByZW5kZXJfb3B0aW9ucy5wYWRkaW5nX2xlZnQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGp1c3QgbGFzdCBgeGAgY29vcmRpbmF0ZXMgZm9yIGRpc3BsYWNlbWVudHNcbiAgICAgICAgdmFyIGxhc3RfZGlzcGxhY2VkID0gbGFzdF9ub3RlLmdldEtleVByb3BzKClbbGFzdF9pbmRleF0uZGlzcGxhY2VkO1xuICAgICAgICBpZiAobGFzdF9kaXNwbGFjZWQgJiYgbGFzdF9ub3RlLmdldFN0ZW1EaXJlY3Rpb24oKSA9PT0gLTEpIHtcbiAgICAgICAgICBlbmRfcG9zaXRpb24ueCAtPSBub3RlaGVhZF93aWR0aCArIHJlbmRlcl9vcHRpb25zLnBhZGRpbmdfcmlnaHQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBBZGp1c3QgeSBwb3NpdGlvbiBiZXR0ZXIgaWYgaXQncyBub3QgY29taW5nIGZyb20gdGhlIGNlbnRlciBvZiB0aGUgbm90ZVxuICAgICAgICBzdGFydF9wb3NpdGlvbi55ICs9IHVwd2FyZHNfc2xvcGUgPyAtMyA6IDE7XG4gICAgICAgIGVuZF9wb3NpdGlvbi55ICs9IHVwd2FyZHNfc2xvcGUgPyAyIDogMDtcblxuICAgICAgICBkcmF3QXJyb3dMaW5lKGN0eCwgc3RhcnRfcG9zaXRpb24sIGVuZF9wb3NpdGlvbiwgdGhpcy5yZW5kZXJfb3B0aW9ucyk7XG5cbiAgICAgIH0sIHRoaXMpO1xuXG4gICAgICBjdHgucmVzdG9yZSgpO1xuXG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIHggY29vcmRpbmF0ZSB3aGVyZSB0byBzdGFydCB0aGUgdGV4dFxuICAgICAgdmFyIHRleHRfd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aDtcbiAgICAgIHZhciBqdXN0aWZpY2F0aW9uID0gcmVuZGVyX29wdGlvbnMudGV4dF9qdXN0aWZpY2F0aW9uO1xuICAgICAgdmFyIHggPSAwO1xuICAgICAgaWYgKGp1c3RpZmljYXRpb24gPT09IFN0YXZlTGluZS5UZXh0SnVzdGlmaWNhdGlvbi5MRUZUKSB7XG4gICAgICAgIHggPSBzdGFydF9wb3NpdGlvbi54O1xuICAgICAgfSBlbHNlIGlmIChqdXN0aWZpY2F0aW9uID09PSBTdGF2ZUxpbmUuVGV4dEp1c3RpZmljYXRpb24uQ0VOVEVSKSB7XG4gICAgICAgIHZhciBkZWx0YV94ID0gKGVuZF9wb3NpdGlvbi54IC0gc3RhcnRfcG9zaXRpb24ueCk7XG4gICAgICAgIHZhciBjZW50ZXJfeCA9IChkZWx0YV94IC8gMiApICsgc3RhcnRfcG9zaXRpb24ueDtcbiAgICAgICAgeCA9IGNlbnRlcl94IC0gKHRleHRfd2lkdGggLyAyKTtcbiAgICAgIH0gZWxzZSBpZiAoanVzdGlmaWNhdGlvbiA9PT0gU3RhdmVMaW5lLlRleHRKdXN0aWZpY2F0aW9uLlJJR0hUKSB7XG4gICAgICAgIHggPSBlbmRfcG9zaXRpb24ueCAgLSAgdGV4dF93aWR0aDtcbiAgICAgIH1cblxuICAgICAgLy8gRGV0ZXJtaW5lIHRoZSB5IHZhbHVlIHRvIHN0YXJ0IHRoZSB0ZXh0XG4gICAgICB2YXIgeTtcbiAgICAgIHZhciB2ZXJ0aWNhbF9wb3NpdGlvbiA9IHJlbmRlcl9vcHRpb25zLnRleHRfcG9zaXRpb25fdmVydGljYWw7XG4gICAgICBpZiAodmVydGljYWxfcG9zaXRpb24gPT09IFN0YXZlTGluZS5UZXh0VmVydGljYWxQb3NpdGlvbi5UT1ApIHtcbiAgICAgICAgeSA9IGZpcnN0X25vdGUuZ2V0U3RhdmUoKS5nZXRZRm9yVG9wVGV4dCgpO1xuICAgICAgfSBlbHNlIGlmICh2ZXJ0aWNhbF9wb3NpdGlvbiA9PT0gU3RhdmVMaW5lLlRleHRWZXJ0aWNhbFBvc2l0aW9uLkJPVFRPTSkge1xuICAgICAgICB5ID0gZmlyc3Rfbm90ZS5nZXRTdGF2ZSgpLmdldFlGb3JCb3R0b21UZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIC8vIERyYXcgdGhlIHRleHRcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmFwcGx5Rm9udFN0eWxlKCk7XG4gICAgICBjdHguZmlsbFRleHQodGhpcy50ZXh0LCB4LCB5KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG5cbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH1cbiAgfTtcblxuICAvLyAjIyBQcml2YXRlIEhlbHBlcnNcbiAgLy8gXG4gIC8vIEF0dHJpYnV0aW9uOiBBcnJvdyByZW5kZXJpbmcgaW1wbGVtZW50YXRpb25zIGJhc2VkIG9mZiBvZlxuICAvLyBQYXRyaWNrIEhvcmdhbidzIGFydGljbGUsIFwiRHJhd2luZyBsaW5lcyBhbmQgYXJjcyB3aXRoIFxuICAvLyBhcnJvdyBoZWFkcyBvbiAgSFRNTDUgQ2FudmFzXCJcbiAgLy8gXG4gIC8vIERyYXcgYW4gYXJyb3cgaGVhZCB0aGF0IGNvbm5lY3RzIGJldHdlZW4gMyBjb29yZGluYXRlc1xuICBmdW5jdGlvbiBkcmF3QXJyb3dIZWFkKGN0eCwgeDAsIHkwLCB4MSwgeTEsIHgyLCB5Mikge1xuICAgIC8vIGFsbCBjYXNlcyBkbyB0aGlzLlxuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHgwLHkwKTtcbiAgICBjdHgubGluZVRvKHgxLHkxKTtcbiAgICBjdHgubGluZVRvKHgyLHkyKTtcbiAgICBjdHgubGluZVRvKHgwLCB5MCk7XG4gICAgY3R4LmNsb3NlUGF0aCgpO1xuXG4gICAgY3R4LmZpbGwoKTtcbiAgfVxuXG4gIC8vIEhlbHBlciBmdW5jdGlvbiB0byBkcmF3IGEgbGluZSB3aXRoIGFycm93IGhlYWRzXG4gIGZ1bmN0aW9uIGRyYXdBcnJvd0xpbmUoY3R4LCBwb2ludDEsIHBvaW50MiwgY29uZmlnKSB7XG4gICAgdmFyIGJvdGhfYXJyb3dzID0gY29uZmlnLmRyYXdfc3RhcnRfYXJyb3cgJiYgY29uZmlnLmRyYXdfZW5kX2Fycm93O1xuXG4gICAgdmFyIHgxID0gcG9pbnQxLng7XG4gICAgdmFyIHkxID0gcG9pbnQxLnk7XG4gICAgdmFyIHgyID0gcG9pbnQyLng7XG4gICAgdmFyIHkyID0gcG9pbnQyLnk7XG5cbiAgICAvLyBGb3IgZW5kcyB3aXRoIGFycm93IHdlIGFjdHVhbGx5IHdhbnQgdG8gc3RvcCBiZWZvcmUgd2UgZ2V0IHRvIHRoZSBhcnJvd1xuICAgIC8vIHNvIHRoYXQgd2lkZSBsaW5lcyB3b24ndCBwdXQgYSBmbGF0IGVuZCBvbiB0aGUgYXJyb3cuXG4gICAgdmFyIGRpc3RhbmNlID0gTWF0aC5zcXJ0KCh4Mi14MSkqKHgyLXgxKSsoeTIteTEpKih5Mi15MSkpO1xuICAgIHZhciByYXRpbyA9IChkaXN0YW5jZSAtIGNvbmZpZy5hcnJvd2hlYWRfbGVuZ3RoLzMpIC8gZGlzdGFuY2U7XG4gICAgdmFyIGVuZF94LCBlbmRfeSwgc3RhcnRfeCwgc3RhcnRfeTtcbiAgICBpZiAoY29uZmlnLmRyYXdfZW5kX2Fycm93IHx8IGJvdGhfYXJyb3dzKSB7XG4gICAgICBlbmRfeCA9IE1hdGgucm91bmQoeDEgKyAoeDIgLSB4MSkgKiByYXRpbyk7XG4gICAgICBlbmRfeSA9IE1hdGgucm91bmQoeTEgKyAoeTIgLSB5MSkgKiByYXRpbyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVuZF94ID0geDI7XG4gICAgICBlbmRfeSA9IHkyO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuZHJhd19zdGFydF9hcnJvdyB8fCBib3RoX2Fycm93cykge1xuICAgICAgc3RhcnRfeCA9IHgxICsgKHgyIC0geDEpICogKDEgLSByYXRpbyk7XG4gICAgICBzdGFydF95ID0geTEgKyAoeTIgLSB5MSkgKiAoMSAtIHJhdGlvKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc3RhcnRfeCA9IHgxO1xuICAgICAgc3RhcnRfeSA9IHkxO1xuICAgIH1cblxuICAgIGlmIChjb25maWcuY29sb3IpIHtcbiAgICAgIGN0eC5zZXRTdHJva2VTdHlsZShjb25maWcuY29sb3IpO1xuICAgICAgY3R4LnNldEZpbGxTdHlsZShjb25maWcuY29sb3IpO1xuICAgIH1cblxuICAgIC8vIERyYXcgdGhlIHNoYWZ0IG9mIHRoZSBhcnJvd1xuICAgIGN0eC5iZWdpblBhdGgoKTtcbiAgICBjdHgubW92ZVRvKHN0YXJ0X3gsIHN0YXJ0X3kpO1xuICAgIGN0eC5saW5lVG8oZW5kX3gsZW5kX3kpO1xuICAgIGN0eC5zdHJva2UoKTtcbiAgICBjdHguY2xvc2VQYXRoKCk7XG5cbiAgICAvLyBjYWxjdWxhdGUgdGhlIGFuZ2xlIG9mIHRoZSBsaW5lXG4gICAgdmFyIGxpbmVfYW5nbGUgPSBNYXRoLmF0YW4yKHkyIC0geTEsIHgyIC0geDEpO1xuICAgIC8vIGggaXMgdGhlIGxpbmUgbGVuZ3RoIG9mIGEgc2lkZSBvZiB0aGUgYXJyb3cgaGVhZFxuICAgIHZhciBoID0gTWF0aC5hYnMoY29uZmlnLmFycm93aGVhZF9sZW5ndGggLyBNYXRoLmNvcyhjb25maWcuYXJyb3doZWFkX2FuZ2xlKSk7XG5cbiAgICB2YXIgYW5nbGUxLCBhbmdsZTI7XG4gICAgdmFyIHRvcF94LCB0b3BfeTtcbiAgICB2YXIgYm90dG9tX3gsIGJvdHRvbV95O1xuXG4gICAgaWYgKGNvbmZpZy5kcmF3X2VuZF9hcnJvdyB8fCBib3RoX2Fycm93cykge1xuICAgICAgYW5nbGUxID0gbGluZV9hbmdsZSArIE1hdGguUEkgKyBjb25maWcuYXJyb3doZWFkX2FuZ2xlO1xuICAgICAgdG9wX3ggPSB4MiArIE1hdGguY29zKGFuZ2xlMSkgKiBoO1xuICAgICAgdG9wX3kgPSB5MiArIE1hdGguc2luKGFuZ2xlMSkgKiBoO1xuXG4gICAgICBhbmdsZTIgPSBsaW5lX2FuZ2xlICsgTWF0aC5QSSAtIGNvbmZpZy5hcnJvd2hlYWRfYW5nbGU7XG4gICAgICBib3R0b21feCA9IHgyICsgTWF0aC5jb3MoYW5nbGUyKSAqIGg7XG4gICAgICBib3R0b21feSA9IHkyICsgTWF0aC5zaW4oYW5nbGUyKSAqIGg7XG5cbiAgICAgIGRyYXdBcnJvd0hlYWQoY3R4LCB0b3BfeCwgdG9wX3ksIHgyLCB5MiwgYm90dG9tX3gsIGJvdHRvbV95KTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmRyYXdfc3RhcnRfYXJyb3cgfHwgYm90aF9hcnJvd3MpIHtcbiAgICAgIGFuZ2xlMSA9IGxpbmVfYW5nbGUgKyBjb25maWcuYXJyb3doZWFkX2FuZ2xlO1xuICAgICAgdG9wX3ggPSB4MSArIE1hdGguY29zKGFuZ2xlMSkgKiBoO1xuICAgICAgdG9wX3kgPSB5MSArIE1hdGguc2luKGFuZ2xlMSkgKiBoO1xuXG4gICAgICBhbmdsZTIgPSBsaW5lX2FuZ2xlIC0gY29uZmlnLmFycm93aGVhZF9hbmdsZTtcbiAgICAgIGJvdHRvbV94ID0geDEgKyBNYXRoLmNvcyhhbmdsZTIpICogaDtcbiAgICAgIGJvdHRvbV95ID0geTEgKyBNYXRoLnNpbihhbmdsZTIpICogaDtcblxuICAgICAgZHJhd0Fycm93SGVhZChjdHgsIHRvcF94LCB0b3BfeSwgeDEsIHkxLCBib3R0b21feCwgYm90dG9tX3kpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBTdGF2ZUxpbmU7XG59KCkpO1xuXG4vLyBbVmV4Rmxvd10oaHR0cDovL3ZleGZsb3cuY29tKSAtIENvcHlyaWdodCAoYykgTW9oaXQgTXV0aGFubmEgMjAxMC5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIHRoZSBgQ3Jlc2NlbmRvYCBvYmplY3Qgd2hpY2ggZHJhd3MgY3Jlc2NlbmRvcyBhbmRcbi8vIGRlY3Jlc2NlbmRvIGR5bmFtaWNzIG1hcmtpbmdzLiBBIGBDcmVzY2VuZG9gIGlzIGluaXRpYWxpemVkIHdpdGggYVxuLy8gZHVyYXRpb24gYW5kIGZvcm1hdHRlZCBhcyBwYXJ0IG9mIGEgYFZvaWNlYCBsaWtlIGFueSBvdGhlciBgTm90ZWBcbi8vIHR5cGUgaW4gVmV4Rmxvdy4gVGhpcyBvYmplY3Qgd291bGQgbW9zdCBsaWtlbHkgYmUgZm9ybWF0dGVkIGluIGEgVm9pY2Vcbi8vIHdpdGggYFRleHROb3Rlc2AgLSB3aGljaCBhcmUgdXNlZCB0byByZXByZXNlbnQgb3RoZXIgZHluYW1pY3MgbWFya2luZ3MuXG5WZXguRmxvdy5DcmVzY2VuZG8gPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIENyZXNjZW5kbyhub3RlX3N0cnVjdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG5vdGVfc3RydWN0KTtcbiAgfVxuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93LkNyZXNjZW5kby5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoQ3Jlc2NlbmRvLkRFQlVHKSBWZXguTChcIlZleC5GbG93LkNyZXNjZW5kb1wiLCBhcmd1bWVudHMpOyB9XG5cbiAgLy8gUHJpdmF0ZSBoZWxwZXIgdG8gZHJhdyB0aGUgaGFpcnBpblxuICBmdW5jdGlvbiByZW5kZXJIYWlycGluKGN0eCwgcGFyYW1zKSB7XG4gICAgdmFyIGJlZ2luX3ggPSBwYXJhbXMuYmVnaW5feDtcbiAgICB2YXIgZW5kX3ggPSBwYXJhbXMuZW5kX3g7XG4gICAgdmFyIHkgPSBwYXJhbXMueTtcbiAgICB2YXIgaGFsZl9oZWlnaHQgPSAgcGFyYW1zLmhlaWdodCAvIDI7XG5cbiAgICBjdHguYmVnaW5QYXRoKCk7XG5cbiAgICBpZiAocGFyYW1zLnJldmVyc2UpIHtcbiAgICAgICAgY3R4Lm1vdmVUbyhiZWdpbl94LCB5IC0gaGFsZl9oZWlnaHQpO1xuICAgICAgICBjdHgubGluZVRvKGVuZF94LCAgeSk7XG4gICAgICAgIGN0eC5saW5lVG8oYmVnaW5feCwgeSArIGhhbGZfaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjdHgubW92ZVRvKGVuZF94LCAgeSAtIGhhbGZfaGVpZ2h0KTtcbiAgICAgICAgY3R4LmxpbmVUbyhiZWdpbl94LCB5KTtcbiAgICAgICAgY3R4LmxpbmVUbyhlbmRfeCwgIHkgKyBoYWxmX2hlaWdodCk7XG4gICAgfVxuXG4gICAgY3R4LnN0cm9rZSgpO1xuICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgfVxuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIFZleC5Jbmhlcml0KENyZXNjZW5kbywgVmV4LkZsb3cuTm90ZSwge1xuICAgIC8vIEluaXRpYWxpemUgdGhlIGNyZXNjZW5kbydzIHByb3BlcnRpZXNcbiAgICBpbml0OiBmdW5jdGlvbihub3RlX3N0cnVjdCkge1xuICAgICAgQ3Jlc2NlbmRvLnN1cGVyY2xhc3MuaW5pdC5jYWxsKHRoaXMsIG5vdGVfc3RydWN0KTtcblxuICAgICAgLy8gV2hldGhlciB0aGUgb2JqZWN0IGlzIGEgZGVjcmVzY2VuZG9cbiAgICAgIHRoaXMuZGVjcmVzY2VuZG8gPSBmYWxzZTtcblxuICAgICAgLy8gVGhlIHN0YWZmIGxpbmUgdG8gYmUgcGxhY2VkIG9uXG4gICAgICB0aGlzLmxpbmUgPSBub3RlX3N0cnVjdC5saW5lIHx8IDA7XG5cbiAgICAgIC8vIFRoZSBoZWlnaHQgYXQgdGhlIG9wZW4gZW5kIG9mIHRoZSBjcmVzYy9kZWNyZXNjXG4gICAgICB0aGlzLmhlaWdodCA9IDE1O1xuXG4gICAgICBWZXguTWVyZ2UodGhpcy5yZW5kZXJfb3B0aW9ucywge1xuICAgICAgICAvLyBFeHRlbnNpb25zIHRvIHRoZSBsZW5ndGggb2YgdGhlIGNyZXNjZW5kbyBvbiBlaXRoZXIgc2lkZVxuICAgICAgICBleHRlbmRfbGVmdDogMCxcbiAgICAgICAgZXh0ZW5kX3JpZ2h0OiAwLFxuICAgICAgICAvLyBWZXJ0aWNhbCBzaGlmdFxuICAgICAgICB5X3NoaWZ0OiAwXG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gU2V0IHRoZSBsaW5lIHRvIGNlbnRlciB0aGUgZWxlbWVudCBvblxuICAgIHNldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHsgdGhpcy5saW5lID0gbGluZTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBTZXQgdGhlIGZ1bGwgaGVpZ2h0IGF0IHRoZSBvcGVuIGVuZFxuICAgIHNldEhlaWdodDogZnVuY3Rpb24oaGVpZ2h0KSB7IHRoaXMuaGVpZ2h0ID0gaGVpZ2h0OyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIFNldCB3aGV0aGVyIHRoZSBzaWduIHNob3VsZCBiZSBhIGRlc2NyZXNlbmRvIGJ5IHBhc3NpbmcgYSBib29sXG4gICAgLy8gdG8gYGRlY3Jlc2NgXG4gICAgc2V0RGVjcmVzY2VuZG86IGZ1bmN0aW9uKGRlY3Jlc2MpIHtcbiAgICAgIHRoaXMuZGVjcmVzY2VuZG8gPSBkZWNyZXNjO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFByZWZvcm1hdCB0aGUgbm90ZVxuICAgIHByZUZvcm1hdDogZnVuY3Rpb24oKSB7IHRoaXMucHJlRm9ybWF0dGVkID0gdHJ1ZTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBSZW5kZXIgdGhlIENyZXNjZW5kbyBvYmplY3Qgb250byB0aGUgY2FudmFzXG4gICAgZHJhdzogZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoIXRoaXMuY29udGV4dCkgdGhyb3cgbmV3IFZleC5SRVJSKFwiTm9Db250ZXh0XCIsXG4gICAgICAgIFwiQ2FuJ3QgZHJhdyBIYWlycGluIHdpdGhvdXQgYSBjb250ZXh0LlwiKTtcblxuICAgICAgdmFyIHRpY2tfY29udGV4dCA9IHRoaXMuZ2V0VGlja0NvbnRleHQoKTtcbiAgICAgIHZhciBuZXh0X2NvbnRleHQgPSBWZXguRmxvdy5UaWNrQ29udGV4dC5nZXROZXh0Q29udGV4dCh0aWNrX2NvbnRleHQpO1xuXG4gICAgICB2YXIgYmVnaW5feCA9IHRoaXMuZ2V0QWJzb2x1dGVYKCk7XG4gICAgICB2YXIgZW5kX3g7XG4gICAgICBpZiAobmV4dF9jb250ZXh0KSB7XG4gICAgICAgIGVuZF94ID0gbmV4dF9jb250ZXh0LmdldFgoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZF94ID0gdGhpcy5zdGF2ZS54ICsgdGhpcy5zdGF2ZS53aWR0aDtcbiAgICAgIH1cblxuICAgICAgdmFyIHkgPSB0aGlzLnN0YXZlLmdldFlGb3JMaW5lKHRoaXMubGluZSArICgtMykpICsgMTtcblxuICAgICAgTChcIkRyYXdpbmcgXCIsICB0aGlzLmRlY3Jlc2NlbmRvID8gXCJkZWNyZXNjZW5kbyBcIiA6IFwiY3Jlc2NlbmRvIFwiLFxuICAgICAgICB0aGlzLmhlaWdodCwgXCJ4XCIsIGJlZ2luX3ggLSBlbmRfeCk7XG5cbiAgICAgIHJlbmRlckhhaXJwaW4odGhpcy5jb250ZXh0LCB7XG4gICAgICAgIGJlZ2luX3g6IGJlZ2luX3ggLSB0aGlzLnJlbmRlcl9vcHRpb25zLmV4dGVuZF9sZWZ0LFxuICAgICAgICBlbmRfeDogZW5kX3ggKyB0aGlzLnJlbmRlcl9vcHRpb25zLmV4dGVuZF9yaWdodCxcbiAgICAgICAgeTogeSArIHRoaXMucmVuZGVyX29wdGlvbnMueV9zaGlmdCxcbiAgICAgICAgaGVpZ2h0OiB0aGlzLmhlaWdodCxcbiAgICAgICAgcmV2ZXJzZTogdGhpcy5kZWNyZXNjZW5kb1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcblxuICByZXR1cm4gQ3Jlc2NlbmRvO1xufSkoKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy8gQXV0aG9yOiBDeXJpbCBTaWx2ZXJtYW5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnRzIG9ybmFtZW50cyBhcyBtb2RpZmllcnMgdGhhdCBjYW4gYmVcbi8vIGF0dGFjaGVkIHRvIG5vdGVzLiBUaGUgY29tcGxldGUgbGlzdCBvZiBvcm5hbWVudHMgaXMgYXZhaWxhYmxlIGluXG4vLyBgdGFibGVzLmpzYCB1bmRlciBgVmV4LkZsb3cub3JuYW1lbnRDb2Rlc2AuXG4vL1xuLy8gU2VlIGB0ZXN0cy9vcm5hbWVudF90ZXN0cy5qc2AgZm9yIHVzYWdlIGV4YW1wbGVzLlxuXG5WZXguRmxvdy5Pcm5hbWVudCA9IChmdW5jdGlvbigpIHtcbiAgZnVuY3Rpb24gT3JuYW1lbnQodHlwZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHR5cGUpO1xuICB9XG4gIE9ybmFtZW50LkNBVEVHT1JZID0gXCJvcm5hbWVudHNcIjtcblxuICAvLyBBY2NpZGVudGFsIHBvc2l0aW9uIG1vZGlmaWNhdGlvbnMgZm9yIGVhY2ggZ2x5cGhcbiAgdmFyIGFjY19tb2RzID0ge1xuICAgIFwiblwiOiB7XG4gICAgICBzaGlmdF94OiAxLFxuICAgICAgc2hpZnRfeV91cHBlcjowLFxuICAgICAgc2hpZnRfeV9sb3dlcjowLFxuICAgICAgaGVpZ2h0OiAxN1xuICAgIH0sXG4gICAgXCIjXCI6IHtcbiAgICAgIHNoaWZ0X3g6IDAsXG4gICAgICBzaGlmdF95X3VwcGVyOiAtMixcbiAgICAgIHNoaWZ0X3lfbG93ZXI6IC0yLFxuICAgICAgaGVpZ2h0OiAyMFxuICAgIH0sXG4gICAgXCJiXCI6IHtcbiAgICAgIHNoaWZ0X3g6IDEsXG4gICAgICBzaGlmdF95X3VwcGVyOiAwLFxuICAgICAgc2hpZnRfeV9sb3dlcjogMyxcbiAgICAgIGhlaWdodDogMThcbiAgICB9LFxuICAgIFwiIyNcIjoge1xuICAgICAgc2hpZnRfeDogMCxcbiAgICAgIHNoaWZ0X3lfdXBwZXI6IDAsXG4gICAgICBzaGlmdF95X2xvd2VyOiAwLFxuICAgICAgaGVpZ2h0OiAxMixcbiAgICB9LFxuICAgIFwiYmJcIjoge1xuICAgICAgc2hpZnRfeDogMCxcbiAgICAgIHNoaWZ0X3lfdXBwZXI6IDAsXG4gICAgICBzaGlmdF95X2xvd2VyOiA0LFxuICAgICAgaGVpZ2h0OiAxN1xuICAgIH0sXG4gICAgXCJkYlwiOiB7XG4gICAgICBzaGlmdF94OiAtMyxcbiAgICAgIHNoaWZ0X3lfdXBwZXI6IDAsXG4gICAgICBzaGlmdF95X2xvd2VyOiA0LFxuICAgICAgaGVpZ2h0OiAxN1xuICAgIH0sXG4gICAgXCJiYnNcIjoge1xuICAgICAgc2hpZnRfeDogMCxcbiAgICAgIHNoaWZ0X3lfdXBwZXI6IDAsXG4gICAgICBzaGlmdF95X2xvd2VyOiA0LFxuICAgICAgaGVpZ2h0OiAxN1xuICAgIH0sXG4gICAgXCJkXCI6IHtcbiAgICAgIHNoaWZ0X3g6IDAsXG4gICAgICBzaGlmdF95X3VwcGVyOiAwLFxuICAgICAgc2hpZnRfeV9sb3dlcjogMCxcbiAgICAgIGhlaWdodDogMTdcbiAgICB9LFxuICAgIFwiKytcIjoge1xuICAgICAgc2hpZnRfeDogLTIsXG4gICAgICBzaGlmdF95X3VwcGVyOiAtNixcbiAgICAgIHNoaWZ0X3lfbG93ZXI6IC0zLFxuICAgICAgaGVpZ2h0OiAyMlxuICAgIH0sXG4gICAgXCIrXCI6IHtcbiAgICAgIHNoaWZ0X3g6IDEsXG4gICAgICBzaGlmdF95X3VwcGVyOiAtNCxcbiAgICAgIHNoaWZ0X3lfbG93ZXI6IC0yLFxuICAgICAgaGVpZ2h0OiAyMFxuICAgIH1cbiAgfTtcblxuICAvLyBUbyBlbmFibGUgbG9nZ2luZyBmb3IgdGhpcyBjbGFzcy4gU2V0IGBWZXguRmxvdy5Pcm5hbWVudC5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoT3JuYW1lbnQuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuT3JuYW1lbnRcIiwgYXJndW1lbnRzKTsgfVxuXG4gIHZhciBNb2RpZmllciA9IFZleC5GbG93Lk1vZGlmaWVyO1xuXG4gIC8vICMjIFN0YXRpYyBNZXRob2RzXG4gIC8vIEFycmFuZ2Ugb3JuYW1lbnRzIGluc2lkZSBgTW9kaWZpZXJDb250ZXh0YFxuICBPcm5hbWVudC5mb3JtYXQgPSBmdW5jdGlvbihvcm5hbWVudHMsIHN0YXRlKSB7XG4gICBpZiAoIW9ybmFtZW50cyB8fCBvcm5hbWVudHMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgd2lkdGggPSAwO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb3JuYW1lbnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICB2YXIgb3JuYW1lbnQgPSBvcm5hbWVudHNbaV07XG4gICAgICB2YXIgaW5jcmVtZW50ID0gMTtcbiAgICAgIHdpZHRoID0gTWF0aC5tYXgob3JuYW1lbnQuZ2V0V2lkdGgoKSwgd2lkdGgpO1xuXG4gICAgICB2YXIgdHlwZSA9IFZleC5GbG93Lm9ybmFtZW50Q29kZXMob3JuYW1lbnQudHlwZSk7XG5cbiAgICAgIGlmICghdHlwZS5iZXR3ZWVuX2xpbmVzKSBpbmNyZW1lbnQgKz0gMS41O1xuXG4gICAgICBpZiAob3JuYW1lbnQuZ2V0UG9zaXRpb24oKSA9PT0gTW9kaWZpZXIuUG9zaXRpb24uQUJPVkUpIHtcbiAgICAgICAgb3JuYW1lbnQuc2V0VGV4dExpbmUoc3RhdGUudG9wX3RleHRfbGluZSk7XG4gICAgICAgIHN0YXRlLnRvcF90ZXh0X2xpbmUgKz0gaW5jcmVtZW50O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgb3JuYW1lbnQuc2V0VGV4dExpbmUoc3RhdGUudGV4dF9saW5lKTtcbiAgICAgICAgc3RhdGUudGV4dF9saW5lICs9IGluY3JlbWVudDtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBzdGF0ZS5sZWZ0X3NoaWZ0ICs9IHdpZHRoIC8gMjtcbiAgICBzdGF0ZS5yaWdodF9zaGlmdCArPSB3aWR0aCAvIDI7XG4gICAgcmV0dXJuIHRydWU7XG4gIH07XG5cbiAgLy8gIyMgUHJvdG90eXBlIE1ldGhvZHNcbiAgVmV4LkluaGVyaXQoT3JuYW1lbnQsIE1vZGlmaWVyLCB7XG4gICAgLy8gQ3JlYXRlIGEgbmV3IG9ybmFtZW50IG9mIHR5cGUgYHR5cGVgLCB3aGljaCBpcyBhbiBlbnRyeSBpblxuICAgIC8vIGBWZXguRmxvdy5vcm5hbWVudENvZGVzYCBpbiBgdGFibGVzLmpzYC5cbiAgICBpbml0OiBmdW5jdGlvbih0eXBlKSB7XG4gICAgICBPcm5hbWVudC5zdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5ub3RlID0gbnVsbDtcbiAgICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgICAgdGhpcy50eXBlID0gdHlwZTtcbiAgICAgIHRoaXMucG9zaXRpb24gPSBNb2RpZmllci5Qb3NpdGlvbi5BQk9WRTtcbiAgICAgIHRoaXMuZGVsYXllZCA9IGZhbHNlO1xuXG4gICAgICB0aGlzLmFjY2lkZW50YWxfdXBwZXIgPSBcIlwiO1xuICAgICAgdGhpcy5hY2NpZGVudGFsX2xvd2VyID0gXCJcIjtcblxuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucyA9IHtcbiAgICAgICAgZm9udF9zY2FsZTogMzhcbiAgICAgIH07XG5cbiAgICAgIHRoaXMub3JuYW1lbnQgPSBWZXguRmxvdy5vcm5hbWVudENvZGVzKHRoaXMudHlwZSk7XG4gICAgICBpZiAoIXRoaXMub3JuYW1lbnQpIHRocm93IG5ldyBWZXguUkVSUihcIkFyZ3VtZW50RXJyb3JcIixcbiAgICAgICAgIFwiT3JuYW1lbnQgbm90IGZvdW5kOiAnXCIgKyB0aGlzLnR5cGUgKyBcIidcIik7XG5cbiAgICAgIC8vIERlZmF1bHQgd2lkdGggY29tZXMgZnJvbSBvcm5hbWVudCB0YWJsZS5cbiAgICAgIHRoaXMuc2V0V2lkdGgodGhpcy5vcm5hbWVudC53aWR0aCk7XG4gICAgfSxcblxuICAgIC8vIFNldCB3aGV0aGVyIHRoZSBvcm5hbWVudCBpcyB0byBiZSBkZWxheWVkXG4gICAgc2V0RGVsYXllZDogZnVuY3Rpb24oZGVsYXllZCkgeyB0aGlzLmRlbGF5ZWQgPSBkZWxheWVkOyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIFNldCB0aGUgdXBwZXIgYWNjaWRlbnRhbCBmb3IgdGhlIG9ybmFtZW50XG4gICAgc2V0VXBwZXJBY2NpZGVudGFsOiBmdW5jdGlvbihhY2MpIHtcbiAgICAgIHRoaXMuYWNjaWRlbnRhbF91cHBlciA9IGFjYztcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIGxvd2VyIGFjY2lkZW50YWwgZm9yIHRoZSBvcm5hbWVudFxuICAgIHNldExvd2VyQWNjaWRlbnRhbDogZnVuY3Rpb24oYWNjKSB7XG4gICAgICB0aGlzLmFjY2lkZW50YWxfbG93ZXIgPSBhY2M7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gUmVuZGVyIG9ybmFtZW50IGluIHBvc2l0aW9uIG5leHQgdG8gbm90ZS5cbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IE9ybmFtZW50IHdpdGhvdXQgYSBjb250ZXh0LlwiKTtcbiAgICAgIGlmICghKHRoaXMubm90ZSAmJiAodGhpcy5pbmRleCAhPT0gbnVsbCkpKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0F0dGFjaGVkTm90ZVwiLFxuICAgICAgICBcIkNhbid0IGRyYXcgT3JuYW1lbnQgd2l0aG91dCBhIG5vdGUgYW5kIGluZGV4LlwiKTtcblxuICAgICAgdmFyIGN0eCA9IHRoaXMuY29udGV4dDtcbiAgICAgIHZhciBzdGVtX2RpcmVjdGlvbiA9IHRoaXMubm90ZS5nZXRTdGVtRGlyZWN0aW9uKCk7XG4gICAgICB2YXIgc3RhdmUgPSB0aGlzLm5vdGUuZ2V0U3RhdmUoKTtcblxuICAgICAgLy8gR2V0IHN0ZW0gZXh0ZW50c1xuICAgICAgdmFyIHN0ZW1fZXh0ID0gdGhpcy5ub3RlLmdldFN0ZW0oKS5nZXRFeHRlbnRzKCk7XG4gICAgICB2YXIgdG9wLCBib3R0b207XG4gICAgICBpZiAoc3RlbV9kaXJlY3Rpb24gPT09IFZleC5GbG93LlN0YXZlTm90ZS5TVEVNX0RPV04pIHtcbiAgICAgICAgdG9wID0gc3RlbV9leHQuYmFzZVk7XG4gICAgICAgIGJvdHRvbSA9IHN0ZW1fZXh0LnRvcFk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0b3AgPSBzdGVtX2V4dC50b3BZO1xuICAgICAgICBib3R0b20gPSBzdGVtX2V4dC5iYXNlWTtcbiAgICAgIH1cblxuICAgICAgLy8gVGFiTm90ZXMgZG9uJ3QgaGF2ZSBzdGVtcyBhdHRhY2hlZCB0byB0aGVtLiBUYWIgc3RlbXMgYXJlIHJlbmRlcmVkXG4gICAgICAvLyBvdXRzaWRlIHRoZSBzdGF2ZS5cbiAgICAgIHZhciBpc190YWJub3RlID0gdGhpcy5ub3RlLmdldENhdGVnb3J5KCkgPT09ICd0YWJub3Rlcyc7XG4gICAgICBpZiAoaXNfdGFibm90ZSkge1xuICAgICAgICBpZiAodGhpcy5ub3RlLmhhc1N0ZW0oKSl7XG4gICAgICAgICAgaWYgKHN0ZW1fZGlyZWN0aW9uID09PSBWZXguRmxvdy5TdGF2ZU5vdGUuU1RFTV9VUCkge1xuICAgICAgICAgICAgYm90dG9tID0gc3RhdmUuZ2V0WUZvckJvdHRvbVRleHQodGhpcy50ZXh0X2xpbmUgLSAyKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0ZW1fZGlyZWN0aW9uID09PSBWZXguRmxvdy5TdGF2ZU5vdGUuU1RFTV9ET1dOICkge1xuICAgICAgICAgICAgdG9wID0gc3RhdmUuZ2V0WUZvclRvcFRleHQodGhpcy50ZXh0X2xpbmUgLSAxLjUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHsgLy8gV2l0aG91dCBhIHN0ZW1cbiAgICAgICAgICB0b3AgPSBzdGF2ZS5nZXRZRm9yVG9wVGV4dCh0aGlzLnRleHRfbGluZSAtIDEpO1xuICAgICAgICAgIGJvdHRvbSA9IHN0YXZlLmdldFlGb3JCb3R0b21UZXh0KHRoaXMudGV4dF9saW5lIC0gMik7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIGlzX29uX2hlYWQgPSBzdGVtX2RpcmVjdGlvbiA9PT0gVmV4LkZsb3cuU3RhdmVOb3RlLlNURU1fRE9XTjtcbiAgICAgIHZhciBzcGFjaW5nID0gc3RhdmUuZ2V0U3BhY2luZ0JldHdlZW5MaW5lcygpO1xuICAgICAgdmFyIGxpbmVfc3BhY2luZyA9IDE7XG5cbiAgICAgIC8vIEJlYW1lZCBzdGVtcyBhcmUgbG9uZ2VyIHRoYW4gcXVhcnRlciBub3RlIHN0ZW1zLCBhZGp1c3QgYWNjb3JkaW5nbHlcbiAgICAgIGlmICghaXNfb25faGVhZCAmJiB0aGlzLm5vdGUuYmVhbSkge1xuICAgICAgICBsaW5lX3NwYWNpbmcgKz0gMC41O1xuICAgICAgfVxuXG4gICAgICB2YXIgdG90YWxfc3BhY2luZyA9IHNwYWNpbmcgKiAodGhpcy50ZXh0X2xpbmUgKyBsaW5lX3NwYWNpbmcpO1xuICAgICAgdmFyIGdseXBoX3lfYmV0d2Vlbl9saW5lcyA9ICh0b3AgLSA3KSAtIHRvdGFsX3NwYWNpbmc7XG5cbiAgICAgIC8vIEdldCBpbml0aWFsIGNvb3JkaW5hdGVzIGZvciB0aGUgbW9kaWZpZXIgcG9zaXRpb25cbiAgICAgIHZhciBzdGFydCA9IHRoaXMubm90ZS5nZXRNb2RpZmllclN0YXJ0WFkodGhpcy5wb3NpdGlvbiwgdGhpcy5pbmRleCk7XG4gICAgICB2YXIgZ2x5cGhfeCA9IHN0YXJ0LnggKyB0aGlzLm9ybmFtZW50LnNoaWZ0X3JpZ2h0O1xuICAgICAgdmFyIGdseXBoX3kgPSBNYXRoLm1pbihzdGF2ZS5nZXRZRm9yVG9wVGV4dCh0aGlzLnRleHRfbGluZSkgLSAzLCBnbHlwaF95X2JldHdlZW5fbGluZXMpO1xuICAgICAgZ2x5cGhfeSArPSB0aGlzLm9ybmFtZW50LnNoaWZ0X3VwICsgdGhpcy55X3NoaWZ0O1xuXG4gICAgICAvLyBBamR1c3QgeCBwb3NpdGlvbiBpZiBvcm5hbWVudCBpcyBkZWxheWVkXG4gICAgICBpZiAodGhpcy5kZWxheWVkKSB7XG4gICAgICAgIGdseXBoX3ggKz0gdGhpcy5vcm5hbWVudC53aWR0aDtcbiAgICAgICAgdmFyIG5leHRfY29udGV4dCA9IFZleC5GbG93LlRpY2tDb250ZXh0LmdldE5leHRDb250ZXh0KHRoaXMubm90ZS5nZXRUaWNrQ29udGV4dCgpKTtcbiAgICAgICAgaWYgKG5leHRfY29udGV4dCkge1xuICAgICAgICAgIGdseXBoX3ggKz0gKG5leHRfY29udGV4dC5nZXRYKCkgLSBnbHlwaF94KSAqIDAuNTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBnbHlwaF94ICs9IChzdGF2ZS54ICsgc3RhdmUud2lkdGggLSBnbHlwaF94KSAqIDAuNTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgb3JuYW1lbnQgPSB0aGlzO1xuICAgICAgZnVuY3Rpb24gZHJhd0FjY2lkZW50YWwoY3R4LCBjb2RlLCB1cHBlcikge1xuICAgICAgICB2YXIgYWNjaWRlbnRhbCA9IFZleC5GbG93LmFjY2lkZW50YWxDb2Rlcyhjb2RlKTtcblxuICAgICAgICB2YXIgYWNjX3ggPSBnbHlwaF94IC0gMztcbiAgICAgICAgdmFyIGFjY195ID0gZ2x5cGhfeSArIDI7XG5cbiAgICAgICAgLy8gU3BlY2lhbCBhZGp1c3RtZW50cyBmb3IgdHJpbGwgZ2x5cGhcbiAgICAgICAgaWYgKHVwcGVyKSB7XG4gICAgICAgICAgYWNjX3kgLT0gbW9kcyA/IG1vZHMuaGVpZ2h0IDogMTg7XG4gICAgICAgICAgYWNjX3kgKz0gIG9ybmFtZW50LnR5cGUgPT09IFwidHJcIiA/IC04IDogMDtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhY2NfeSArPSAgb3JuYW1lbnQudHlwZSA9PT0gXCJ0clwiID8gLTYgOiAwO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gRmluZSB0dW5lIHBvc2l0aW9uIG9mIGFjY2lkZW50YWwgZ2x5cGhcbiAgICAgICAgdmFyIG1vZHMgPSBhY2NfbW9kc1tjb2RlXTtcbiAgICAgICAgaWYgKG1vZHMpIHtcbiAgICAgICAgICBhY2NfeCArPSBtb2RzLnNoaWZ0X3g7XG4gICAgICAgICAgYWNjX3kgKz0gdXBwZXIgPyBtb2RzLnNoaWZ0X3lfdXBwZXIgOiBtb2RzLnNoaWZ0X3lfbG93ZXI7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBSZW5kZXIgdGhlIGdseXBoXG4gICAgICAgIHZhciBzY2FsZSA9IG9ybmFtZW50LnJlbmRlcl9vcHRpb25zLmZvbnRfc2NhbGUvMS4zO1xuICAgICAgICBWZXguRmxvdy5yZW5kZXJHbHlwaChjdHgsIGFjY194LCBhY2NfeSwgc2NhbGUsIGFjY2lkZW50YWwuY29kZSk7XG5cbiAgICAgICAgLy8gSWYgcmVuZGVyZWQgYSBib3R0b20gYWNjaWRlbnRhbCwgaW5jcmVhc2UgdGhlIHkgdmFsdWUgYnkgdGhlXG4gICAgICAgIC8vIGFjY2lkZW50YWwgaGVpZ2h0IHNvIHRoYXQgdGhlIG9ybmFtZW50J3MgZ2x5cGggaXMgc2hpZnRlZCB1cFxuICAgICAgICBpZiAoIXVwcGVyKSB7XG4gICAgICAgICAgZ2x5cGhfeSAtPSBtb2RzID8gbW9kcy5oZWlnaHQgOiAxODtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBEcmF3IGxvd2VyIGFjY2lkZW50YWwgZm9yIG9ybmFtZW50XG4gICAgICBpZiAodGhpcy5hY2NpZGVudGFsX2xvd2VyKSB7XG4gICAgICAgIGRyYXdBY2NpZGVudGFsKGN0eCwgdGhpcy5hY2NpZGVudGFsX2xvd2VyLCBmYWxzZSwgZ2x5cGhfeCwgZ2x5cGhfeSk7XG4gICAgICB9XG5cbiAgICAgIEwoXCJSZW5kZXJpbmcgb3JuYW1lbnQ6IFwiLCB0aGlzLm9ybmFtZW50LCBnbHlwaF94LCBnbHlwaF95KTtcbiAgICAgIFZleC5GbG93LnJlbmRlckdseXBoKGN0eCwgZ2x5cGhfeCwgZ2x5cGhfeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuZm9udF9zY2FsZSwgdGhpcy5vcm5hbWVudC5jb2RlKTtcblxuICAgICAgLy8gRHJhdyB1cHBlciBhY2NpZGVudGFsIGZvciBvcm5hbWVudFxuICAgICAgaWYgKHRoaXMuYWNjaWRlbnRhbF91cHBlcikge1xuICAgICAgICBkcmF3QWNjaWRlbnRhbChjdHgsIHRoaXMuYWNjaWRlbnRhbF91cHBlciwgdHJ1ZSwgZ2x5cGhfeCwgZ2x5cGhfeSk7XG4gICAgICB9XG5cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBPcm5hbWVudDtcbn0oKSk7XG5cbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgZGlmZmVyZW50IHR5cGVzIG9mIHBlZGFsIG1hcmtpbmdzLiBUaGVzZSBub3RhdGlvblxuLy8gZWxlbWVudHMgaW5kaWNhdGUgdG8gdGhlIHBlcmZvcm1lciB3aGVuIHRvIGRlcHJlc3MgYW5kIHJlbGVhc2UgdGhlIGEgcGVkYWwuXG4vL1xuLy8gSW4gb3JkZXIgdG8gY3JlYXRlIFwiU29zdGVudXRvXCIsIGFuZCBcInVuYSBjb3JkYVwiIG1hcmtpbmdzLCB5b3UgbXVzdCBzZXRcbi8vIGN1c3RvbSB0ZXh0IGZvciB0aGUgcmVsZWFzZS9kZXByZXNzIHBlZGFsIG1hcmtpbmdzLlxuVmV4LkZsb3cuUGVkYWxNYXJraW5nID0gKGZ1bmN0aW9uKCkge1xuICBmdW5jdGlvbiBQZWRhbE1hcmtpbmcodHlwZSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KHR5cGUpO1xuICB9XG5cbiAgLy8gVG8gZW5hYmxlIGxvZ2dpbmcgZm9yIHRoaXMgY2xhc3MuIFNldCBgVmV4LkZsb3cuUGVkYWxNYXJraW5nLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChQZWRhbE1hcmtpbmcuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuUGVkYWxNYXJraW5nXCIsIGFyZ3VtZW50cyk7IH1cblxuICAvLyBHbHlwaCBkYXRhXG4gIFBlZGFsTWFya2luZy5HTFlQSFMgPSB7XG4gICAgXCJwZWRhbF9kZXByZXNzXCI6IHtcbiAgICAgIGNvZGU6IFwidjM2XCIsXG4gICAgICB4X3NoaWZ0Oi0xMCxcbiAgICAgIHlfc2hpZnQ6MFxuICAgIH0sXG4gICAgXCJwZWRhbF9yZWxlYXNlXCI6IHtcbiAgICAgIGNvZGU6IFwidjVkXCIsXG4gICAgICB4X3NoaWZ0Oi0yLFxuICAgICAgeV9zaGlmdDozXG4gICAgfSxcbiAgfTtcblxuICBQZWRhbE1hcmtpbmcuU3R5bGVzID0ge1xuICAgIFRFWFQ6IDEsXG4gICAgQlJBQ0tFVDogMixcbiAgICBNSVhFRDogM1xuICB9O1xuXG5cbiAgLy8gIyMgUHVibGljIGhlbHBlcnNcbiAgLy9cbiAgLy8gQ3JlYXRlIGEgc3VzdGFpbiBwZWRhbCBtYXJraW5nLiBSZXR1cm5zIHRoZSBkZWZhdWx0cyBQZWRhbE1hcmtpbmcuXG4gIC8vIFdoaWNoIHVzZXMgdGhlIHRyYWRpdGlvbmFsIFwiUGVkXCIgYW5kIFwiKlwiXCIgbWFya2luZ3MuXG4gIFBlZGFsTWFya2luZy5jcmVhdGVTdXN0YWluID0gZnVuY3Rpb24obm90ZXMpIHtcbiAgICB2YXIgcGVkYWwgPSBuZXcgUGVkYWxNYXJraW5nKG5vdGVzKTtcbiAgICByZXR1cm4gcGVkYWw7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgc29zdGVudXRvIHBlZGFsIG1hcmtpbmdcbiAgUGVkYWxNYXJraW5nLmNyZWF0ZVNvc3RlbnV0byA9IGZ1bmN0aW9uKG5vdGVzKSB7XG4gICAgdmFyIHBlZGFsID0gbmV3IFBlZGFsTWFya2luZyhub3Rlcyk7XG4gICAgcGVkYWwuc2V0U3R5bGUoUGVkYWxNYXJraW5nLlN0eWxlcy5NSVhFRCk7XG4gICAgcGVkYWwuc2V0Q3VzdG9tVGV4dChcIlNvc3QuIFBlZC5cIik7XG4gICAgcmV0dXJuIHBlZGFsO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhbiB1bmEgY29yZGEgcGVkYWwgbWFya2luZ1xuICBQZWRhbE1hcmtpbmcuY3JlYXRlVW5hQ29yZGEgPSBmdW5jdGlvbihub3Rlcyl7XG4gICAgdmFyIHBlZGFsID0gbmV3IFBlZGFsTWFya2luZyhub3Rlcyk7XG4gICAgcGVkYWwuc2V0U3R5bGUoUGVkYWxNYXJraW5nLlN0eWxlcy5URVhUKTtcbiAgICBwZWRhbC5zZXRDdXN0b21UZXh0KFwidW5hIGNvcmRhXCIsIFwidHJlIGNvcmRhXCIpO1xuICAgIHJldHVybiBwZWRhbDtcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICBQZWRhbE1hcmtpbmcucHJvdG90eXBlID0gIHtcbiAgICBpbml0OiBmdW5jdGlvbihub3Rlcykge1xuICAgICAgdGhpcy5ub3RlcyA9IG5vdGVzO1xuICAgICAgdGhpcy5zdHlsZSA9IFZleC5GbG93LlBlZGFsTWFya2luZy5URVhUO1xuICAgICAgdGhpcy5saW5lID0gMDtcblxuICAgICAgLy8gQ3VzdG9tIHRleHQgZm9yIHRoZSByZWxlYXNlL2RlcHJlc3MgbWFya2luZ3NcbiAgICAgIHRoaXMuY3VzdG9tX2RlcHJlc3NfdGV4dCA9IFwiXCI7XG4gICAgICB0aGlzLmN1c3RvbV9yZWxlYXNlX3RleHQgPSBcIlwiO1xuXG4gICAgICB0aGlzLmZvbnQgPSB7XG4gICAgICAgIGZhbWlseTogXCJUaW1lcyBOZXcgUm9tYW5cIixcbiAgICAgICAgc2l6ZTogMTIsXG4gICAgICAgIHdlaWdodDogXCJpdGFsaWMgYm9sZFwiXG4gICAgICB9O1xuXG4gICAgICB0aGlzLnJlbmRlcl9vcHRpb25zID0ge1xuICAgICAgICBicmFja2V0X2hlaWdodDogMTAsXG4gICAgICAgIHRleHRfbWFyZ2luX3JpZ2h0OiA2LFxuICAgICAgICBicmFja2V0X2xpbmVfd2lkdGg6IDEsXG4gICAgICAgIGdseXBoX3BvaW50X3NpemU6IDQwLFxuICAgICAgICBjb2xvcjogXCJibGFja1wiXG4gICAgICB9O1xuICAgIH0sXG5cbiAgICAvLyBTZXQgY3VzdG9tIHRleHQgZm9yIHRoZSBgZGVwcmVzc2AvYHJlbGVhc2VgIHBlZGFsIG1hcmtpbmdzLiBObyB0ZXh0IGlzXG4gICAgLy8gc2V0IGlmIHRoZSBwYXJhbWV0ZXIgaXMgZmFsc3kuXG4gICAgc2V0Q3VzdG9tVGV4dDogZnVuY3Rpb24oZGVwcmVzcywgcmVsZWFzZSkge1xuICAgICAgdGhpcy5jdXN0b21fZGVwcmVzc190ZXh0ID0gZGVwcmVzcyB8fCBcIlwiO1xuICAgICAgdGhpcy5jdXN0b21fcmVsZWFzZV90ZXh0ID0gcmVsZWFzZSB8fCBcIlwiO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIC8vIFNldCB0aGUgcGVkYWwgbWFya2luZyBzdHlsZVxuICAgIHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSl7XG4gICAgICBpZiAoc3R5bGUgPCAxICYmIHN0eWxlID4gMykgIHtcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiSW52YWxpZFBhcmFtZXRlclwiLFxuICAgICAgICAgIFwiVGhlIHN0eWxlIG11c3QgYmUgb25lIGZvdW5kIGluIFBlZGFsTWFya2luZy5TdHlsZXNcIik7XG4gICAgICB9XG5cbiAgICAgIHRoaXMuc3R5bGUgPSBzdHlsZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIHN0YWZmIGxpbmUgdG8gcmVuZGVyIHRoZSBtYXJraW5ncyBvblxuICAgIHNldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHsgdGhpcy5saW5lID0gbGluZTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBTZXQgdGhlIHJlbmRlcmluZyBjb250ZXh0XG4gICAgc2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkgeyB0aGlzLmNvbnRleHQgPSBjb250ZXh0OyByZXR1cm4gdGhpczsgfSxcblxuICAgIC8vIERyYXcgdGhlIGJyYWNrZXQgYmFzZWQgcGVkYWwgbWFya2luZ3NcbiAgICBkcmF3QnJhY2tldGVkOiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgaXNfcGVkYWxfZGVwcmVzc2VkID0gZmFsc2U7XG4gICAgICB2YXIgcHJldl94O1xuICAgICAgdmFyIHByZXZfeTtcbiAgICAgIHZhciBwZWRhbCA9IHRoaXM7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIG5vdGVcbiAgICAgIHRoaXMubm90ZXMuZm9yRWFjaChmdW5jdGlvbihub3RlLCBpbmRleCwgbm90ZXMpIHtcbiAgICAgICAgLy8gRWFjaCBub3RlIHRyaWdnZXJzIHRoZSBvcHBvc2l0ZSBwZWRhbCBhY3Rpb25cbiAgICAgICAgaXNfcGVkYWxfZGVwcmVzc2VkID0gIWlzX3BlZGFsX2RlcHJlc3NlZDtcblxuICAgICAgICAvLyBHZXQgdGhlIGluaXRpYWwgY29vcmRpbmF0ZXMgZm9yIHRoZSBub3RlXG4gICAgICAgIHZhciB4ID0gbm90ZS5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgICAgdmFyIHkgPSBub3RlLmdldFN0YXZlKCkuZ2V0WUZvckJvdHRvbVRleHQocGVkYWwubGluZSArIDMpO1xuXG4gICAgICAgIC8vIFRocm93IGlmIGN1cnJlbnQgbm90ZSBpcyBwb3NpdGlvbmVkIGJlZm9yZSB0aGUgcHJldmlvdXMgbm90ZVxuICAgICAgICBpZiAoeCA8IHByZXZfeCkgdGhyb3cgbmV3IFZleC5SRVJSKCdJbnZhbGlkQ29uZmlndXJhdGlvbicsXG4gICAgICAgICAgJ1RoZSBub3RlcyBwcm92aWRlZCBtdXN0IGJlIGluIG9yZGVyIG9mIGFzY2VuZGluZyB4IHBvc2l0aW9ucycpO1xuXG4gICAgICAgIC8vIERldGVybWluZSBpZiB0aGUgcHJldmlvdXMgb3IgbmV4dCBub3RlIGFyZSB0aGUgc2FtZVxuICAgICAgICAvLyBhcyB0aGUgY3VycmVudCBub3RlLiBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgdGhpcyBmb3JcbiAgICAgICAgLy8gd2hlbiBhZGp1c3RtZW50cyBhcmUgbWFkZSBmb3IgdGhlIHJlbGVhc2UrZGVwcmVzcyBhY3Rpb25cbiAgICAgICAgdmFyIG5leHRfaXNfc2FtZSA9IG5vdGVzW2luZGV4KzFdID09PSBub3RlO1xuICAgICAgICB2YXIgcHJldl9pc19zYW1lID0gbm90ZXNbaW5kZXgtMV0gPT09IG5vdGU7XG5cbiAgICAgICAgdmFyIHhfc2hpZnQgPSAwO1xuICAgICAgICBpZiAoaXNfcGVkYWxfZGVwcmVzc2VkKSB7XG4gICAgICAgICAgLy8gQWRqdXN0bWVudCBmb3IgcmVsZWFzZStkZXByZXNzXG4gICAgICAgICAgeF9zaGlmdCA9ICBwcmV2X2lzX3NhbWUgPyA1IDogMDtcblxuICAgICAgICAgIGlmIChwZWRhbC5zdHlsZSA9PT0gUGVkYWxNYXJraW5nLlN0eWxlcy5NSVhFRCAmJiAhcHJldl9pc19zYW1lKSB7XG4gICAgICAgICAgICAvLyBGb3IgTUlYRUQgc3R5bGUsIHN0YXJ0IHdpdGggdGV4dCBpbnN0ZWFkIG9mIGJyYWNrZXRcbiAgICAgICAgICAgIGlmIChwZWRhbC5jdXN0b21fZGVwcmVzc190ZXh0KSB7XG4gICAgICAgICAgICAgIC8vIElmIHdlIGhhdmUgY3VzdG9tIHRleHQsIHVzZSBpbnN0ZWFkIG9mIHRoZSBkZWZhdWx0IFwiUGVkXCIgZ2x5cGhcbiAgICAgICAgICAgICAgdmFyIHRleHRfd2lkdGggPSBjdHgubWVhc3VyZVRleHQocGVkYWwuY3VzdG9tX2RlcHJlc3NfdGV4dCkud2lkdGg7XG4gICAgICAgICAgICAgIGN0eC5maWxsVGV4dChwZWRhbC5jdXN0b21fZGVwcmVzc190ZXh0LCB4IC0gKHRleHRfd2lkdGgvMiksIHkpO1xuICAgICAgICAgICAgICB4X3NoaWZ0ID0gKHRleHRfd2lkdGggLyAyKSArIHBlZGFsLnJlbmRlcl9vcHRpb25zLnRleHRfbWFyZ2luX3JpZ2h0O1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgLy8gUmVuZGVyIHRoZSBQZWQgZ2x5cGggaW4gcG9zaXRpb25cbiAgICAgICAgICAgICAgZHJhd1BlZGFsR2x5cGgoJ3BlZGFsX2RlcHJlc3MnLCBjdHgsIHgsIHksIHBlZGFsLnJlbmRlcl9vcHRpb25zLmdseXBoX3BvaW50X3NpemUpO1xuICAgICAgICAgICAgICB4X3NoaWZ0ID0gMjAgKyBwZWRhbC5yZW5kZXJfb3B0aW9ucy50ZXh0X21hcmdpbl9yaWdodDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gRHJhdyBzdGFydCBicmFja2V0XG4gICAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgICBjdHgubW92ZVRvKHgsIHkgLSBwZWRhbC5yZW5kZXJfb3B0aW9ucy5icmFja2V0X2hlaWdodCk7XG4gICAgICAgICAgICBjdHgubGluZVRvKHggKyB4X3NoaWZ0LCB5KTtcbiAgICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gQWRqdXN0bWVudCBmb3IgcmVsZWFzZStkZXByZXNzXG4gICAgICAgICAgeF9zaGlmdCA9IG5leHRfaXNfc2FtZSA/IC01IDogMDtcblxuICAgICAgICAgIC8vIERyYXcgZW5kIGJyYWNrZXRcbiAgICAgICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICAgICAgY3R4Lm1vdmVUbyhwcmV2X3gsIHByZXZfeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4ICsgeF9zaGlmdCwgeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5IC0gcGVkYWwucmVuZGVyX29wdGlvbnMuYnJhY2tldF9oZWlnaHQpO1xuICAgICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBTdG9yZSBwcmV2aW91cyBjb29yZGluYXRlc1xuICAgICAgICBwcmV2X3ggPSB4ICsgeF9zaGlmdDtcbiAgICAgICAgcHJldl95ID0geTtcbiAgICAgIH0pO1xuICAgIH0sXG5cbiAgICAvLyBEcmF3IHRoZSB0ZXh0IGJhc2VkIHBlZGFsIG1hcmtpbmdzLiBUaGlzIGRlZmF1bHRzIHRvIHRoZSB0cmFkaXRpb25hbFxuICAgIC8vIFwiUGVkXCIgYW5kIFwiKlwiXCIgc3ltYm9scyBpZiBubyBjdXN0b20gdGV4dCBoYXMgYmVlbiBwcm92aWRlZC5cbiAgICBkcmF3VGV4dDogZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuICAgICAgdmFyIGlzX3BlZGFsX2RlcHJlc3NlZCA9IGZhbHNlO1xuICAgICAgdmFyIHBlZGFsID0gdGhpcztcblxuICAgICAgLy8gVGhlIGdseXBoIHBvaW50IHNpemVcbiAgICAgIHZhciBwb2ludCA9IHBlZGFsLnJlbmRlcl9vcHRpb25zLmdseXBoX3BvaW50X3NpemU7XG5cbiAgICAgIC8vIEl0ZXJhdGUgdGhyb3VnaCBlYWNoIG5vdGUsIHBsYWNpbmcgZ2x5cGhzIG9yIGN1c3RvbSB0ZXh0IGFjY29yZGluZ2x5XG4gICAgICB0aGlzLm5vdGVzLmZvckVhY2goZnVuY3Rpb24obm90ZSkge1xuICAgICAgICBpc19wZWRhbF9kZXByZXNzZWQgPSAhaXNfcGVkYWxfZGVwcmVzc2VkO1xuICAgICAgICB2YXIgc3RhdmUgPSBub3RlLmdldFN0YXZlKCk7XG4gICAgICAgIHZhciB4ID0gbm90ZS5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgICAgdmFyIHkgPSBzdGF2ZS5nZXRZRm9yQm90dG9tVGV4dChwZWRhbC5saW5lICsgMyk7XG5cbiAgICAgICAgdmFyIHRleHRfd2lkdGggPSAwO1xuICAgICAgICBpZiAoaXNfcGVkYWxfZGVwcmVzc2VkKSB7XG4gICAgICAgICAgaWYgKHBlZGFsLmN1c3RvbV9kZXByZXNzX3RleHQpIHtcbiAgICAgICAgICAgIHRleHRfd2lkdGggPSBjdHgubWVhc3VyZVRleHQocGVkYWwuY3VzdG9tX2RlcHJlc3NfdGV4dCkud2lkdGg7XG4gICAgICAgICAgICBjdHguZmlsbFRleHQocGVkYWwuY3VzdG9tX2RlcHJlc3NfdGV4dCwgeCAtICh0ZXh0X3dpZHRoLzIpLCB5KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZHJhd1BlZGFsR2x5cGgoXCJwZWRhbF9kZXByZXNzXCIsIGN0eCwgeCwgeSwgcG9pbnQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBpZiAocGVkYWwuY3VzdG9tX3JlbGVhc2VfdGV4dCkge1xuICAgICAgICAgICAgdGV4dF93aWR0aCA9IGN0eC5tZWFzdXJlVGV4dChwZWRhbC5jdXN0b21fcmVsZWFzZV90ZXh0KS53aWR0aDtcbiAgICAgICAgICAgIGN0eC5maWxsVGV4dChwZWRhbC5jdXN0b21fcmVsZWFzZV90ZXh0LCB4IC0gKHRleHRfd2lkdGgvMiksIHkpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBkcmF3UGVkYWxHbHlwaChcInBlZGFsX3JlbGVhc2VcIiwgY3R4LCB4LCB5LCBwb2ludCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9LFxuXG4gICAgLy8gUmVuZGVyIHRoZSBwZWRhbCBtYXJraW5nIGluIHBvc2l0aW9uIG9uIHRoZSByZW5kZXJpbmcgY29udGV4dCBcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICghdGhpcy5jb250ZXh0KSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJOb0NvbnRleHRcIixcbiAgICAgICAgXCJDYW4ndCBkcmF3IFBlZGFsTWFya2luZyB3aXRob3V0IGEgY29udGV4dC5cIik7XG4gICAgICB2YXIgY3R4ID0gdGhpcy5jb250ZXh0O1xuXG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnNldFN0cm9rZVN0eWxlKHRoaXMucmVuZGVyX29wdGlvbnMuY29sb3IpO1xuICAgICAgY3R4LnNldEZpbGxTdHlsZSh0aGlzLnJlbmRlcl9vcHRpb25zLmNvbG9yKTtcbiAgICAgIGN0eC5zZXRGb250KHRoaXMuZm9udC5mYW1pbHksIHRoaXMuZm9udC5zaXplLCB0aGlzLmZvbnQud2VpZ2h0KTtcblxuICAgICAgTChcIlJlbmRlcmluZyBQZWRhbCBNYXJraW5nXCIpO1xuXG4gICAgICBpZiAodGhpcy5zdHlsZSA9PT0gUGVkYWxNYXJraW5nLlN0eWxlcy5CUkFDS0VUIHx8XG4gICAgICAgICAgdGhpcy5zdHlsZSA9PT0gUGVkYWxNYXJraW5nLlN0eWxlcy5NSVhFRCkge1xuICAgICAgICBjdHguc2V0TGluZVdpZHRoKHRoaXMucmVuZGVyX29wdGlvbnMuYnJhY2tldF9saW5lX3dpZHRoKTtcbiAgICAgICAgdGhpcy5kcmF3QnJhY2tldGVkKCk7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMuc3R5bGUgPT09IFZleC5GbG93LlBlZGFsTWFya2luZy5TdHlsZXMuVEVYVCkge1xuICAgICAgICB0aGlzLmRyYXdUZXh0KCk7XG4gICAgICB9XG5cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfVxuICB9O1xuXG4gIC8vICMjIFByaXZhdGUgSGVscGVyXG4gIC8vIFxuICAvLyBEcmF3cyBhIHBlZGFsIGdseXBoIHdpdGggdGhlIHByb3ZpZGVkIGBuYW1lYCBvbiBhIHJlbmRlcmluZyBgY29udGV4dGAgXG4gIC8vIGF0IHRoZSBjb29yZGluYXRlcyBgeGAgYW5kIGB5LiBUYWtlcyBpbnRvIGFjY291bnQgdGhlIGdseXBoIGRhdGFcbiAgLy8gY29vcmRpbmF0ZSBzaGlmdHMuXG4gIGZ1bmN0aW9uIGRyYXdQZWRhbEdseXBoKG5hbWUsIGNvbnRleHQsIHgsIHksIHBvaW50KSB7XG4gICAgdmFyIGdseXBoX2RhdGEgPSBQZWRhbE1hcmtpbmcuR0xZUEhTW25hbWVdO1xuICAgIHZhciBnbHlwaCA9IG5ldyBWZXguRmxvdy5HbHlwaChnbHlwaF9kYXRhLmNvZGUsIHBvaW50KTtcbiAgICBnbHlwaC5yZW5kZXIoY29udGV4dCwgeCArIGdseXBoX2RhdGEueF9zaGlmdCwgeSArIGdseXBoX2RhdGEueV9zaGlmdCk7XG4gIH1cblxuICByZXR1cm4gUGVkYWxNYXJraW5nO1xufSgpKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy8gQXV0aG9yOiBDeXJpbCBTaWx2ZXJtYW5cbi8vXG4vLyAjIyBEZXNjcmlwdGlvblxuLy9cbi8vIFRoaXMgZmlsZSBpbXBsZW1lbnQgYFRleHRCcmFja2V0c2Agd2hpY2ggZXh0ZW5kIGJldHdlZW4gdHdvIG5vdGVzLlxuLy8gVGhlIG9jdGF2ZSB0cmFuc3Bvc2l0aW9uIG1hcmtpbmdzICg4dmEsIDh2YiwgMTV2YSwgMTV2YikgY2FuIGJlIGNyZWF0ZWRcbi8vIHVzaW5nIHRoaXMgY2xhc3MuXG4vL1xuVmV4LkZsb3cuVGV4dEJyYWNrZXQgPSAoZnVuY3Rpb24oKSB7XG4gIGZ1bmN0aW9uIFRleHRCcmFja2V0KGJyYWNrZXRfZGF0YSkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KGJyYWNrZXRfZGF0YSk7XG4gIH1cblxuICAvLyBUbyBlbmFibGUgbG9nZ2luZyBmb3IgdGhpcyBjbGFzcy4gU2V0IGBWZXguRmxvdy5UZXh0QnJhY2tldC5ERUJVR2AgdG8gYHRydWVgLlxuICBmdW5jdGlvbiBMKCkgeyBpZiAoVGV4dEJyYWNrZXQuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuVGV4dEJyYWNrZXRcIiwgYXJndW1lbnRzKTsgfVxuXG4gIFRleHRCcmFja2V0LlBvc2l0aW9ucyA9IHtcbiAgICBUT1A6IDEsXG4gICAgQk9UVE9NOiAtMVxuICB9O1xuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIFRleHRCcmFja2V0LnByb3RvdHlwZSA9ICB7XG4gICAgaW5pdDogZnVuY3Rpb24oYnJhY2tldF9kYXRhKSB7XG4gICAgICB0aGlzLnN0YXJ0ID0gYnJhY2tldF9kYXRhLnN0YXJ0O1xuICAgICAgdGhpcy5zdG9wID0gYnJhY2tldF9kYXRhLnN0b3A7XG5cbiAgICAgIHRoaXMudGV4dCA9IGJyYWNrZXRfZGF0YS50ZXh0IHx8IFwiXCI7XG4gICAgICB0aGlzLnN1cGVyc2NyaXB0ID0gYnJhY2tldF9kYXRhLnN1cGVyc2NyaXB0IHx8IFwiXCI7XG5cbiAgICAgIHRoaXMucG9zaXRpb24gPSBicmFja2V0X2RhdGEucG9zaXRpb24gfHwgVGV4dEJyYWNrZXQuUG9zaXRpb25zLlRPUDtcbiAgICAgIHRoaXMubGluZSA9IDE7XG5cbiAgICAgIHRoaXMuZm9udCA9IHtcbiAgICAgICAgZmFtaWx5OiBcIlNlcmlmXCIsXG4gICAgICAgIHNpemU6IDE1LFxuICAgICAgICB3ZWlnaHQ6IFwiaXRhbGljXCJcbiAgICAgIH07XG5cbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMgPSB7XG4gICAgICAgIGRhc2hlZDogdHJ1ZSxcbiAgICAgICAgZGFzaDogWzVdLFxuICAgICAgICBjb2xvcjogXCJibGFja1wiLFxuICAgICAgICBsaW5lX3dpZHRoOiAxLFxuICAgICAgICBzaG93X2JyYWNrZXQ6IHRydWUsXG4gICAgICAgIGJyYWNrZXRfaGVpZ2h0OiA4LFxuXG4gICAgICAgIC8vIEluIHRoZSBCT1RUT00gcG9zaXRpb24sIHRoZSBicmFja2V0IGxpbmUgY2FuIGV4dGVuZFxuICAgICAgICAvLyB1bmRlciB0aGUgc3VwZXJzY3JpcHQuXG4gICAgICAgIHVuZGVybGluZV9zdXBlcnNjcmlwdDogdHJ1ZVxuICAgICAgfTtcbiAgICB9LFxuXG4gICAgLy8gQXBwbHkgdGhlIHRleHQgYmFja2V0IHN0eWxpbmcgdG8gdGhlIHByb3ZpZGVkIGBjb250ZXh0YFxuICAgIGFwcGx5U3R5bGU6IGZ1bmN0aW9uKGNvbnRleHQpIHtcbiAgICAgIC8vIEFwcGx5IHN0eWxlIGZvciB0aGUgb2N0YXZlIGJyYWNrZXRcbiAgICAgIGNvbnRleHQuc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSwgdGhpcy5mb250LndlaWdodCk7XG4gICAgICBjb250ZXh0LnNldFN0cm9rZVN0eWxlKHRoaXMucmVuZGVyX29wdGlvbnMuY29sb3IpO1xuICAgICAgY29udGV4dC5zZXRGaWxsU3R5bGUodGhpcy5yZW5kZXJfb3B0aW9ucy5jb2xvcik7XG4gICAgICBjb250ZXh0LnNldExpbmVXaWR0aCh0aGlzLnJlbmRlcl9vcHRpb25zLmxpbmVfd2lkdGgpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgLy8gU2V0IHdoZXRoZXIgdGhlIGJyYWNrZXQgbGluZSBzaG91bGQgYmUgYGRhc2hlZGAuIFlvdSBjYW4gYWxzb1xuICAgIC8vIG9wdGlvbmFsbHkgc2V0IHRoZSBgZGFzaGAgcGF0dGVybiBieSBwYXNzaW5nIGluIGFuIGFycmF5IG9mIG51bWJlcnNcbiAgICBzZXREYXNoZWQ6IGZ1bmN0aW9uKGRhc2hlZCwgZGFzaCkge1xuICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5kYXNoZWQgPSBkYXNoZWQ7XG4gICAgICBpZiAoZGFzaCkgdGhpcy5yZW5kZXJfb3B0aW9ucy5kYXNoID0gZGFzaDtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIGZvbnQgZm9yIHRoZSB0ZXh0XG4gICAgc2V0Rm9udDogZnVuY3Rpb24oZm9udCkgeyB0aGlzLmZvbnQgPSBmb250OyByZXR1cm4gdGhpczsgfSxcbiAgICAvLyBTZXQgdGhlIHJlbmRlcmluZyBgY29udGV4dGAgZm9yIHRoZSBvY3RhdmUgYnJhY2tldFxuICAgIHNldENvbnRleHQ6IGZ1bmN0aW9uKGNvbnRleHQpIHsgdGhpcy5jb250ZXh0ID0gY29udGV4dDsgcmV0dXJuIHRoaXM7IH0sXG4gICAgLy8gU2V0IHRoZSBzdGFmZiBsaW5lIHRvIHJlbmRlciB0aGUgYnJhY2tldCBvblxuICAgIHNldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHsgdGhpcy5saW5lID0gbGluZTsgcmV0dXJuIHRoaXM7IH0sXG5cbiAgICAvLyBEcmF3IHRoZSBvY3RhdmUgYnJhY2tldCBvbiB0aGUgcmVuZGVyaW5nIGNvbnRleHRcbiAgICBkcmF3OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG5cbiAgICAgIHZhciB5ID0gMDtcbiAgICAgIHN3aXRjaCh0aGlzLnBvc2l0aW9uKSB7XG4gICAgICAgIGNhc2UgVGV4dEJyYWNrZXQuUG9zaXRpb25zLlRPUDpcbiAgICAgICAgICB5ID0gIHRoaXMuc3RhcnQuZ2V0U3RhdmUoKS5nZXRZRm9yVG9wVGV4dCh0aGlzLmxpbmUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFRleHRCcmFja2V0LlBvc2l0aW9ucy5CT1RUT006XG4gICAgICAgICAgeSA9ICB0aGlzLnN0YXJ0LmdldFN0YXZlKCkuZ2V0WUZvckJvdHRvbVRleHQodGhpcy5saW5lKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgLy8gR2V0IHRoZSBwcmVsaW1pbmFyeSBzdGFydCBhbmQgc3RvcCBjb29yZGludGF0ZXMgZm9yIHRoZSBicmFja2V0XG4gICAgICB2YXIgc3RhcnQgPSB7IHg6IHRoaXMuc3RhcnQuZ2V0QWJzb2x1dGVYKCksIHk6IHl9O1xuICAgICAgdmFyIHN0b3AgPSB7IHg6IHRoaXMuc3RvcC5nZXRBYnNvbHV0ZVgoKSwgeTogeSB9O1xuXG4gICAgICBMKFwiUmVuZGVyaW5nIFRleHRCcmFja2V0OiBzdGFydDpcIiwgc3RhcnQsIFwic3RvcDpcIiwgc3RvcCwgXCJ5OlwiLCB5KTtcblxuICAgICAgdmFyIGJyYWNrZXRfaGVpZ2h0ID0gdGhpcy5yZW5kZXJfb3B0aW9ucy5icmFja2V0X2hlaWdodCAqIHRoaXMucG9zaXRpb247XG5cbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmFwcGx5U3R5bGUoY3R4KTtcblxuICAgICAgLy8gRHJhdyB0ZXh0XG4gICAgICBjdHguZmlsbFRleHQodGhpcy50ZXh0LCBzdGFydC54LCBzdGFydC55KTtcblxuICAgICAgLy8gR2V0IHRoZSB3aWR0aCBhbmQgaGVpZ2h0IGZvciB0aGUgb2N0YXZlIG51bWJlclxuICAgICAgdmFyIG1haW5fd2lkdGggPSBjdHgubWVhc3VyZVRleHQodGhpcy50ZXh0KS53aWR0aDtcbiAgICAgIHZhciBtYWluX2hlaWdodCA9IGN0eC5tZWFzdXJlVGV4dChcIk1cIikud2lkdGg7XG5cbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgeSBwb3NpdGlvbiBmb3IgdGhlIHN1cGVyIHNjcmlwdFxuICAgICAgdmFyIHN1cGVyX3kgPSBzdGFydC55IC0gKG1haW5faGVpZ2h0LzIuNSk7XG5cbiAgICAgIC8vIERyYXcgdGhlIHN1cGVyc2NyaXB0XG4gICAgICBjdHguc2V0Rm9udCh0aGlzLmZvbnQuZmFtaWx5LCB0aGlzLmZvbnQuc2l6ZSAvIDEuNCwgdGhpcy5mb250LndlaWdodCk7XG4gICAgICBjdHguZmlsbFRleHQodGhpcy5zdXBlcnNjcmlwdCwgc3RhcnQueCArIG1haW5fd2lkdGggKyAxLCBzdXBlcl95KTtcblxuXG4gICAgICAvLyBEZXRlcm1pbmUgd2lkdGggYW5kIGhlaWdodCBvZiB0aGUgc3VwZXJzY3JpcHRcbiAgICAgIHZhciBzdXBlcnNjcmlwdF93aWR0aCA9IGN0eC5tZWFzdXJlVGV4dCh0aGlzLnN1cGVyc2NyaXB0KS53aWR0aDtcbiAgICAgIHZhciBzdXBlcl9oZWlnaHQgPSBjdHgubWVhc3VyZVRleHQoXCJNXCIpLndpZHRoO1xuXG4gICAgICAvLyBTZXR1cCBpbml0aWFsIGNvb3JkaW5hdGVzIGZvciB0aGUgYnJhY2tldCBsaW5lXG4gICAgICB2YXIgc3RhcnRfeCA9IHN0YXJ0Lng7XG4gICAgICB2YXIgbGluZV95ID0gc3VwZXJfeTtcbiAgICAgIHZhciBlbmRfeCA9IHN0b3AueCArIHRoaXMuc3RvcC5nZXRHbHlwaCgpLmhlYWRfd2lkdGg7XG5cbiAgICAgIC8vIEFkanVzdCB4IGFuZCB5IGNvb3JkaW5hdGVzIGJhc2VkIG9uIHBvc2l0aW9uXG4gICAgICBpZiAodGhpcy5wb3NpdGlvbiA9PT0gVGV4dEJyYWNrZXQuUG9zaXRpb25zLlRPUCkge1xuICAgICAgICBzdGFydF94ICs9IG1haW5fd2lkdGggKyBzdXBlcnNjcmlwdF93aWR0aCArIDU7XG4gICAgICAgIGxpbmVfeSAtPSBzdXBlcl9oZWlnaHQvMi43O1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnBvc2l0aW9uID09PSBUZXh0QnJhY2tldC5Qb3NpdGlvbnMuQk9UVE9NKSB7XG4gICAgICAgIGxpbmVfeSArPSBzdXBlcl9oZWlnaHQvMi43O1xuICAgICAgICBzdGFydF94ICs9IG1haW5fd2lkdGggKyAyO1xuXG4gICAgICAgIGlmICghdGhpcy5yZW5kZXJfb3B0aW9ucy51bmRlcmxpbmVfc3VwZXJzY3JpcHQpIHtcbiAgICAgICAgICBzdGFydF94ICs9IHN1cGVyc2NyaXB0X3dpZHRoO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGlmICh0aGlzLnJlbmRlcl9vcHRpb25zLmRhc2hlZCkge1xuICAgICAgICAvLyBNYWluIGxpbmVcbiAgICAgICAgVmV4LkZsb3cuUmVuZGVyZXIuZHJhd0Rhc2hlZExpbmUoY3R4LCBzdGFydF94LCBsaW5lX3ksIGVuZF94LCBsaW5lX3ksXG4gICAgICAgICAgdGhpcy5yZW5kZXJfb3B0aW9ucy5kYXNoKTtcbiAgICAgICAgLy8gRW5kaW5nIEJyYWNrZXRcbiAgICAgICAgaWYgKHRoaXMucmVuZGVyX29wdGlvbnMuc2hvd19icmFja2V0KSB7XG4gICAgICAgICAgVmV4LkZsb3cuUmVuZGVyZXIuZHJhd0Rhc2hlZExpbmUoY3R4LCBlbmRfeCwgbGluZV95ICsgKDEgKiB0aGlzLnBvc2l0aW9uKSxcbiAgICAgICAgICAgIGVuZF94LCBsaW5lX3kgKyBicmFja2V0X2hlaWdodCwgdGhpcy5yZW5kZXJfb3B0aW9ucy5kYXNoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgICAgICBjdHgubW92ZVRvKHN0YXJ0X3gsIGxpbmVfeSk7XG4gICAgICAgIC8vIE1haW4gbGluZVxuICAgICAgICBjdHgubGluZVRvKGVuZF94LCBsaW5lX3kpO1xuICAgICAgICBpZiAodGhpcy5yZW5kZXJfb3B0aW9ucy5zaG93X2JyYWNrZXQpIHtcbiAgICAgICAgICAvLyBFbmRpbmcgYnJhY2tldFxuICAgICAgICAgIGN0eC5saW5lVG8oZW5kX3gsIGxpbmVfeSArIGJyYWNrZXRfaGVpZ2h0KTtcbiAgICAgICAgfVxuICAgICAgICBjdHguc3Ryb2tlKCk7XG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgIH1cblxuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIFRleHRCcmFja2V0O1xufSkoKTtcbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgdGhlIGBUZXh0RHluYW1pY3NgIHdoaWNoIHJlbmRlcnMgdHJhZGl0aW9uYWxcbi8vIHRleHQgZHluYW1pY3MgbWFya2luZ3MsICoqaWU6IHAsIGYsIHNmeiwgcmZ6LCBwcHAqKlxuLy9cbi8vIFlvdSBjYW4gcmVuZGVyIGFueSBkeW5hbWljcyBzdHJpbmcgdGhhdCBjb250YWlucyBhIGNvbWJpbmF0aW9uIG9mXG4vLyB0aGUgZm9sbG93aW5nIGxldHRlcnM6ICBQLCBNLCBGLCBaLCBSLCBTXG5WZXguRmxvdy5UZXh0RHluYW1pY3MgPSAoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gVGV4dER5bmFtaWNzKHRleHRfc3RydWN0KSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB0aGlzLmluaXQodGV4dF9zdHJ1Y3QpO1xuICB9XG5cbiAgLy8gVG8gZW5hYmxlIGxvZ2dpbmcgZm9yIHRoaXMgY2xhc3MuIFNldCBgVmV4LkZsb3cuVGV4dER5bmFtaWNzLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChUZXh0RHluYW1pY3MuREVCVUcpIFZleC5MKFwiVmV4LkZsb3cuVGV4dER5bmFtaWNzXCIsIGFyZ3VtZW50cyk7IH1cblxuICAvLyBUaGUgZ2x5cGggZGF0YSBmb3IgZWFjaCBkeW5hbWljcyBsZXR0ZXJcbiAgVGV4dER5bmFtaWNzLkdMWVBIUyA9IHtcbiAgICBcImZcIjoge1xuICAgICAgY29kZTogXCJ2YmFcIixcbiAgICAgIHdpZHRoOiAxMlxuICAgIH0sXG4gICAgXCJwXCI6IHtcbiAgICAgIGNvZGU6IFwidmJmXCIsXG4gICAgICB3aWR0aDogMTRcbiAgICB9LFxuICAgIFwibVwiOiB7XG4gICAgICBjb2RlOiBcInY2MlwiLFxuICAgICAgd2lkdGg6IDE3XG4gICAgfSxcbiAgICBcInNcIjoge1xuICAgICAgY29kZTogXCJ2NGFcIixcbiAgICAgIHdpZHRoOiAxMFxuICAgIH0sXG4gICAgXCJ6XCI6IHtcbiAgICAgIGNvZGU6IFwidjgwXCIsXG4gICAgICB3aWR0aDogMTJcbiAgICB9LFxuICAgIFwiclwiOiB7XG4gICAgICBjb2RlOiBcInZiMVwiLFxuICAgICAgd2lkdGg6IDEyXG4gICAgfVxuICB9O1xuXG4gIC8vICMjIFByb3RvdHlwZSBNZXRob2RzXG4gIC8vXG4gIC8vIEEgYFRleHREeW5hbWljc2Agb2JqZWN0IGluaGVyaXRzIGZyb20gYE5vdGVgIHNvIHRoYXQgaXQgY2FuIGJlIGZvcm1hdHRlZFxuICAvLyB3aXRoaW4gYSBgVm9pY2VgLlxuICBWZXguSW5oZXJpdChUZXh0RHluYW1pY3MsIFZleC5GbG93Lk5vdGUsIHtcbiAgICAvLyBDcmVhdGUgdGhlIGR5bmFtaWNzIG1hcmtpbmcuIGB0ZXh0X3N0cnVjdGAgaXMgYW4gb2JqZWN0XG4gICAgLy8gdGhhdCBjb250YWlucyBhIGBkdXJhdGlvbmAgcHJvcGVydHkgYW5kIGEgYHNlcXVlbmNlYCBvZlxuICAgIC8vIGxldHRlcnMgdGhhdCByZXByZXNlbnRzIHRoZSBsZXR0ZXJzIHRvIHJlbmRlclxuICAgIGluaXQ6IGZ1bmN0aW9uKHRleHRfc3RydWN0KSB7XG4gICAgICBUZXh0RHluYW1pY3Muc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgdGV4dF9zdHJ1Y3QpO1xuXG4gICAgICB0aGlzLnNlcXVlbmNlID0gdGV4dF9zdHJ1Y3QudGV4dC50b0xvd2VyQ2FzZSgpO1xuICAgICAgdGhpcy5saW5lID0gdGV4dF9zdHJ1Y3QubGluZSB8fCAwO1xuICAgICAgdGhpcy5nbHlwaHMgPSBbXTtcblxuICAgICAgVmV4Lk1lcmdlKHRoaXMucmVuZGVyX29wdGlvbnMsIHtcbiAgICAgICAgZ2x5cGhfZm9udF9zaXplOiA0MFxuICAgICAgfSk7XG5cbiAgICAgIEwoXCJOZXcgRHluYW1pY3MgVGV4dDogXCIsIHRoaXMuc2VxdWVuY2UpO1xuICAgIH0sXG5cbiAgICAvLyBTZXQgdGhlIFN0YXZlIGxpbmUgb24gd2hpY2ggdGhlIG5vdGUgc2hvdWxkIGJlIHBsYWNlZFxuICAgIHNldExpbmU6IGZ1bmN0aW9uKGxpbmUpIHsgdGhpcy5saW5lID0gbGluZTsgIHJldHVybiB0aGlzOyB9LFxuXG4gICAgLy8gUHJlZm9ybWF0IHRoZSBkeW5hbWljcyB0ZXh0XG4gICAgcHJlRm9ybWF0OiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciB0b3RhbF93aWR0aCA9IDA7XG4gICAgICAvLyBJdGVyYXRlIHRocm91Z2ggZWFjaCBsZXR0ZXJcbiAgICAgIHRoaXMuc2VxdWVuY2Uuc3BsaXQoJycpLmZvckVhY2goZnVuY3Rpb24obGV0dGVyKSB7XG4gICAgICAgIC8vIEdldCB0aGUgZ2x5cGggZGF0YSBmb3IgdGhlIGxldHRlclxuICAgICAgICB2YXIgZ2x5cGhfZGF0YSA9IFRleHREeW5hbWljcy5HTFlQSFNbbGV0dGVyXTtcbiAgICAgICAgaWYgKCFnbHlwaF9kYXRhKSB0aHJvdyBuZXcgVmV4LlJFUlIoXCJJbnZhbGlkIGR5bmFtaWNzIGNoYXJhY3RlcjogXCIgKyBsZXR0ZXIpO1xuXG4gICAgICAgIHZhciBzaXplID0gIHRoaXMucmVuZGVyX29wdGlvbnMuZ2x5cGhfZm9udF9zaXplO1xuICAgICAgICB2YXIgZ2x5cGggPSBuZXcgVmV4LkZsb3cuR2x5cGgoZ2x5cGhfZGF0YS5jb2RlLCBzaXplKTtcblxuICAgICAgICAvLyBBZGQgdGhlIGdseXBoXG4gICAgICAgIHRoaXMuZ2x5cGhzLnB1c2goZ2x5cGgpO1xuXG4gICAgICAgIHRvdGFsX3dpZHRoICs9IGdseXBoX2RhdGEud2lkdGg7XG4gICAgICB9LCB0aGlzKTtcblxuICAgICAgLy8gU3RvcmUgdGhlIHdpZHRoIG9mIHRoZSB0ZXh0XG4gICAgICB0aGlzLnNldFdpZHRoKHRvdGFsX3dpZHRoKTtcbiAgICAgIHRoaXMucHJlRm9ybWF0dGVkID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbiAgICAvLyBEcmF3IHRoZSBkeW5hbWljcyB0ZXh0IG9uIHRoZSByZW5kZXJpbmcgY29udGV4dFxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHggPSB0aGlzLmdldEFic29sdXRlWCgpO1xuICAgICAgdmFyIHkgPSB0aGlzLnN0YXZlLmdldFlGb3JMaW5lKHRoaXMubGluZSArICgtMykpO1xuXG4gICAgICBMKFwiUmVuZGVyaW5nIER5bmFtaWNzOiBcIiwgdGhpcy5zZXF1ZW5jZSk7XG5cbiAgICAgIHZhciBsZXR0ZXJfeCA9IHg7XG4gICAgICB0aGlzLmdseXBocy5mb3JFYWNoKGZ1bmN0aW9uKGdseXBoLCBpbmRleCkge1xuICAgICAgICB2YXIgY3VycmVudF9sZXR0ZXIgPSB0aGlzLnNlcXVlbmNlW2luZGV4XTtcbiAgICAgICAgZ2x5cGgucmVuZGVyKHRoaXMuY29udGV4dCwgbGV0dGVyX3gsIHkpO1xuICAgICAgICBsZXR0ZXJfeCArPSBUZXh0RHluYW1pY3MuR0xZUEhTW2N1cnJlbnRfbGV0dGVyXS53aWR0aDtcbiAgICAgIH0sIHRoaXMpO1xuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIFRleHREeW5hbWljcztcbn0pKCk7XG5WZXguRmxvdy5HcmFjZU5vdGUgPSAoZnVuY3Rpb24oKSB7XG4gIHZhciBHcmFjZU5vdGUgPSBmdW5jdGlvbihub3RlX3N0cnVjdCkge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KG5vdGVfc3RydWN0KTtcbiAgfTtcblxuICBWZXguSW5oZXJpdChHcmFjZU5vdGUsIFZleC5GbG93LlN0YXZlTm90ZSwge1xuICAgIGluaXQ6IGZ1bmN0aW9uKG5vdGVfc3RydWN0KSB7XG4gICAgICBHcmFjZU5vdGUuc3VwZXJjbGFzcy5pbml0LmNhbGwodGhpcywgbm90ZV9zdHJ1Y3QpO1xuXG4gICAgICB0aGlzLnJlbmRlcl9vcHRpb25zLmdseXBoX2ZvbnRfc2NhbGUgPSAyMjtcbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuc3RlbV9oZWlnaHQgPSAyMDtcbiAgICAgIHRoaXMucmVuZGVyX29wdGlvbnMuc3Ryb2tlX3B4ID0gMjtcbiAgICAgIHRoaXMuZ2x5cGguaGVhZF93aWR0aCA9IDY7XG5cbiAgICAgIHRoaXMuc2xhc2ggPSBub3RlX3N0cnVjdC5zbGFzaDtcbiAgICAgIHRoaXMuc2x1ciA9IHRydWU7XG5cbiAgICAgIHRoaXMuYnVpbGROb3RlSGVhZHMoKTtcblxuICAgICAgdGhpcy53aWR0aCA9IDM7XG4gICAgfSxcblxuICAgIGdldFN0ZW1FeHRlbnNpb246IGZ1bmN0aW9uKCl7XG4gICAgICB2YXIgZ2x5cGggPSB0aGlzLmdldEdseXBoKCk7XG5cbiAgICAgIGlmICh0aGlzLnN0ZW1fZXh0ZW5zaW9uX292ZXJyaWRlICE9IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RlbV9leHRlbnNpb25fb3ZlcnJpZGU7XG4gICAgICB9XG5cbiAgICAgIGlmIChnbHlwaCkge1xuICAgICAgICByZXR1cm4gdGhpcy5nZXRTdGVtRGlyZWN0aW9uKCkgPT09IDEgPyBnbHlwaC5ncmFjZW5vdGVfc3RlbV91cF9leHRlbnNpb24gOlxuICAgICAgICAgIGdseXBoLmdyYWNlbm90ZV9zdGVtX2Rvd25fZXh0ZW5zaW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gMDtcbiAgICB9LFxuXG4gICAgZ2V0Q2F0ZWdvcnk6IGZ1bmN0aW9uKCkgeyByZXR1cm4gJ2dyYWNlbm90ZXMnOyB9LFxuXG4gICAgZHJhdzogZnVuY3Rpb24oKXtcbiAgICAgIEdyYWNlTm90ZS5zdXBlcmNsYXNzLmRyYXcuY2FsbCh0aGlzKTtcbiAgICAgIHZhciBjdHggPSB0aGlzLmNvbnRleHQ7XG4gICAgICB2YXIgc3RlbV9kaXJlY3Rpb24gPSB0aGlzLmdldFN0ZW1EaXJlY3Rpb24oKTtcblxuICAgICAgaWYgKHRoaXMuc2xhc2gpIHtcbiAgICAgICAgY3R4LmJlZ2luUGF0aCgpO1xuXG4gICAgICAgIHZhciB4ID0gdGhpcy5nZXRBYnNvbHV0ZVgoKTtcbiAgICAgICAgdmFyIHkgPSB0aGlzLmdldFlzKClbMF0gLSAodGhpcy5zdGVtLmdldEhlaWdodCgpIC8gMi44KTtcbiAgICAgICAgaWYgKHN0ZW1fZGlyZWN0aW9uID09PSAxKSB7XG4gICAgICAgICAgeCArPSAxO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4ICsgMTMsIHkgLSA5KTtcbiAgICAgICAgfSBlbHNlIGlmIChzdGVtX2RpcmVjdGlvbiA9PT0gLTEpIHtcbiAgICAgICAgICB4IC09IDQ7XG4gICAgICAgICAgeSArPSAxO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgY3R4LmxpbmVUbyh4ICsgMTMsIHkgKyA5KTtcbiAgICAgICAgfVxuXG4gICAgICAgIGN0eC5jbG9zZVBhdGgoKTtcbiAgICAgICAgY3R4LnN0cm9rZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfSk7XG5cbiAgcmV0dXJuIEdyYWNlTm90ZTtcbn0oKSk7XG5cbi8vIFtWZXhGbG93XShodHRwOi8vdmV4Zmxvdy5jb20pIC0gQ29weXJpZ2h0IChjKSBNb2hpdCBNdXRoYW5uYSAyMDEwLlxuLy9cbi8vICMjIERlc2NyaXB0aW9uXG4vL1xuLy8gVGhpcyBmaWxlIGltcGxlbWVudHMgYEdyYWNlTm90ZUdyb3VwYCB3aGljaCBpcyB1c2VkIHRvIGZvcm1hdCBhbmRcbi8vIHJlbmRlciBncmFjZSBub3Rlcy5cblxuVmV4LkZsb3cuR3JhY2VOb3RlR3JvdXAgPSAoZnVuY3Rpb24oKXtcbiAgZnVuY3Rpb24gR3JhY2VOb3RlR3JvdXAoZ3JhY2Vfbm90ZXMsIGNvbmZpZykge1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkgdGhpcy5pbml0KGdyYWNlX25vdGVzLCBjb25maWcpO1xuICB9XG5cbiAgR3JhY2VOb3RlR3JvdXAuQ0FURUdPUlkgPSBcImdyYWNlbm90ZWdyb3Vwc1wiO1xuXG4gIC8vIFRvIGVuYWJsZSBsb2dnaW5nIGZvciB0aGlzIGNsYXNzLiBTZXQgYFZleC5GbG93LkdyYWNlTm90ZUdyb3VwLkRFQlVHYCB0byBgdHJ1ZWAuXG4gIGZ1bmN0aW9uIEwoKSB7IGlmIChHcmFjZU5vdGVHcm91cC5ERUJVRykgVmV4LkwoXCJWZXguRmxvdy5HcmFjZU5vdGVHcm91cFwiLCBhcmd1bWVudHMpOyB9XG5cbiAgLy8gQXJyYW5nZSBncm91cHMgaW5zaWRlIGEgYE1vZGlmaWVyQ29udGV4dGBcbiAgR3JhY2VOb3RlR3JvdXAuZm9ybWF0ID0gZnVuY3Rpb24oZ3JhY2Vub3RlX2dyb3Vwcywgc3RhdGUpIHtcbiAgICB2YXIgZ3JhY2Vub3RlX3NwYWNpbmcgPSA0O1xuXG4gICAgaWYgKCFncmFjZW5vdGVfZ3JvdXBzIHx8IGdyYWNlbm90ZV9ncm91cHMubGVuZ3RoID09PSAwKSByZXR1cm4gZmFsc2U7XG5cbiAgICB2YXIgZ3JvdXBfbGlzdCA9IFtdO1xuICAgIHZhciBoYXNTdGF2ZSA9IGZhbHNlO1xuICAgIHZhciBwcmV2X25vdGUgPSBudWxsO1xuICAgIHZhciBzaGlmdEwgPSAwO1xuXG4gICAgdmFyIGksIGdyYWNlbm90ZV9ncm91cCwgcHJvcHNfdG1wO1xuICAgIGZvciAoaSA9IDA7IGkgPCBncmFjZW5vdGVfZ3JvdXBzLmxlbmd0aDsgKytpKSB7XG4gICAgICBncmFjZW5vdGVfZ3JvdXAgPSBncmFjZW5vdGVfZ3JvdXBzW2ldO1xuICAgICAgdmFyIG5vdGUgPSBncmFjZW5vdGVfZ3JvdXAuZ2V0Tm90ZSgpO1xuICAgICAgdmFyIHN0YXZlID0gbm90ZS5nZXRTdGF2ZSgpO1xuICAgICAgaWYgKG5vdGUgIT0gcHJldl9ub3RlKSB7XG4gICAgICAgICAvLyBJdGVyYXRlIHRocm91Z2ggYWxsIG5vdGVzIHRvIGdldCB0aGUgZGlzcGxhY2VkIHBpeGVsc1xuICAgICAgICAgZm9yICh2YXIgbiA9IDA7IG4gPCBub3RlLmtleXMubGVuZ3RoOyArK24pIHtcbiAgICAgICAgICAgIHByb3BzX3RtcCA9IG5vdGUuZ2V0S2V5UHJvcHMoKVtuXTtcbiAgICAgICAgICAgIHNoaWZ0TCA9IChwcm9wc190bXAuZGlzcGxhY2VkID8gbm90ZS5nZXRFeHRyYUxlZnRQeCgpIDogc2hpZnRMKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcHJldl9ub3RlID0gbm90ZTtcbiAgICAgIH1cbiAgICAgIGlmIChzdGF2ZSAhPSBudWxsKSB7XG4gICAgICAgIGhhc1N0YXZlID0gdHJ1ZTtcbiAgICAgICAgZ3JvdXBfbGlzdC5wdXNoKHtzaGlmdDogc2hpZnRMLCBncmFjZW5vdGVfZ3JvdXA6IGdyYWNlbm90ZV9ncm91cH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZ3JvdXBfbGlzdC5wdXNoKHtzaGlmdDogc2hpZnRMLCBncmFjZW5vdGVfZ3JvdXA6IGdyYWNlbm90ZV9ncm91cCB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBJZiBmaXJzdCBub3RlIGxlZnQgc2hpZnQgaW4gY2FzZSBpdCBpcyBkaXNwbGFjZWRcbiAgICB2YXIgZ3JvdXBfc2hpZnQgPSBncm91cF9saXN0WzBdLnNoaWZ0O1xuICAgIHZhciBmb3JtYXRXaWR0aDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ3JvdXBfbGlzdC5sZW5ndGg7ICsraSkge1xuICAgICAgZ3JhY2Vub3RlX2dyb3VwID0gZ3JvdXBfbGlzdFtpXS5ncmFjZW5vdGVfZ3JvdXA7XG4gICAgICBncmFjZW5vdGVfZ3JvdXAucHJlRm9ybWF0KCk7XG4gICAgICBmb3JtYXRXaWR0aCA9IGdyYWNlbm90ZV9ncm91cC5nZXRXaWR0aCgpICsgZ3JhY2Vub3RlX3NwYWNpbmc7XG4gICAgICBncm91cF9zaGlmdCA9IE1hdGgubWF4KGZvcm1hdFdpZHRoLCBncm91cF9zaGlmdCk7XG4gICAgfVxuXG4gICAgZm9yIChpID0gMDsgaSA8IGdyb3VwX2xpc3QubGVuZ3RoOyArK2kpIHtcbiAgICAgIGdyYWNlbm90ZV9ncm91cCA9IGdyb3VwX2xpc3RbaV0uZ3JhY2Vub3RlX2dyb3VwO1xuICAgICAgZm9ybWF0V2lkdGggPSBncmFjZW5vdGVfZ3JvdXAuZ2V0V2lkdGgoKSArIGdyYWNlbm90ZV9zcGFjaW5nO1xuICAgICAgZ3JhY2Vub3RlX2dyb3VwLnNldFNwYWNpbmdGcm9tTmV4dE1vZGlmaWVyKGdyb3VwX3NoaWZ0IC0gTWF0aC5taW4oZm9ybWF0V2lkdGgsIGdyb3VwX3NoaWZ0KSk7XG4gICAgfVxuXG4gICAgc3RhdGUubGVmdF9zaGlmdCArPSBncm91cF9zaGlmdDtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyAjIyBQcm90b3R5cGUgTWV0aG9kc1xuICAvL1xuICAvLyBgR3JhY2VOb3RlR3JvdXBgIGluaGVyaXRzIGZyb20gYE1vZGlmaWVyYCBhbmQgaXMgcGxhY2VkIGluc2lkZSBhXG4gIC8vIGBNb2RpZmllckNvbnRleHRgLlxuICBWZXguSW5oZXJpdChHcmFjZU5vdGVHcm91cCwgVmV4LkZsb3cuTW9kaWZpZXIsIHtcbiAgICBpbml0OiBmdW5jdGlvbihncmFjZV9ub3Rlcywgc2hvd19zbHVyKSB7XG4gICAgICB2YXIgc3VwZXJjbGFzcyA9IEdyYWNlTm90ZUdyb3VwLnN1cGVyY2xhc3M7XG4gICAgICBzdXBlcmNsYXNzLmluaXQuY2FsbCh0aGlzKTtcblxuICAgICAgdGhpcy5ub3RlID0gbnVsbDtcbiAgICAgIHRoaXMuaW5kZXggPSBudWxsO1xuICAgICAgdGhpcy5wb3NpdGlvbiA9IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uLkxFRlQ7XG4gICAgICB0aGlzLmdyYWNlX25vdGVzID0gZ3JhY2Vfbm90ZXM7XG4gICAgICB0aGlzLndpZHRoID0gMDtcblxuICAgICAgdGhpcy5wcmVGb3JtYXR0ZWQgPSBmYWxzZTtcblxuICAgICAgdGhpcy5zaG93X3NsdXIgPSBzaG93X3NsdXI7XG4gICAgICB0aGlzLnNsdXIgPSBudWxsO1xuXG4gICAgICB0aGlzLmZvcm1hdHRlciA9IG5ldyBWZXguRmxvdy5Gb3JtYXR0ZXIoKTtcbiAgICAgIHRoaXMudm9pY2UgPSBuZXcgVmV4LkZsb3cuVm9pY2Uoe1xuICAgICAgICBudW1fYmVhdHM6IDQsXG4gICAgICAgIGJlYXRfdmFsdWU6IDQsXG4gICAgICAgIHJlc29sdXRpb246IFZleC5GbG93LlJFU09MVVRJT05cbiAgICAgIH0pLnNldFN0cmljdChmYWxzZSk7XG5cbiAgICAgIHRoaXMudm9pY2UuYWRkVGlja2FibGVzKHRoaXMuZ3JhY2Vfbm90ZXMpO1xuXG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4gICAgcHJlRm9ybWF0OiBmdW5jdGlvbigpe1xuICAgICAgaWYgKHRoaXMucHJlRm9ybWF0dGVkKSByZXR1cm47XG5cbiAgICAgIHRoaXMuZm9ybWF0dGVyLmpvaW5Wb2ljZXMoW3RoaXMudm9pY2VdKS5mb3JtYXQoW3RoaXMudm9pY2VdLCAwKTtcbiAgICAgIHRoaXMuc2V0V2lkdGgodGhpcy5mb3JtYXR0ZXIuZ2V0TWluVG90YWxXaWR0aCgpKTtcbiAgICAgIHRoaXMucHJlRm9ybWF0dGVkID0gdHJ1ZTtcbiAgICB9LFxuXG4gICAgYmVhbU5vdGVzOiBmdW5jdGlvbigpe1xuICAgICAgaWYgKHRoaXMuZ3JhY2Vfbm90ZXMubGVuZ3RoID4gMSkge1xuICAgICAgICB2YXIgYmVhbSA9IG5ldyBWZXguRmxvdy5CZWFtKHRoaXMuZ3JhY2Vfbm90ZXMpO1xuXG4gICAgICAgIGJlYW0ucmVuZGVyX29wdGlvbnMuYmVhbV93aWR0aCA9IDM7XG4gICAgICAgIGJlYW0ucmVuZGVyX29wdGlvbnMucGFydGlhbF9iZWFtX2xlbmd0aCA9IDQ7XG5cbiAgICAgICAgdGhpcy5iZWFtID0gYmVhbTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuICAgIHNldE5vdGU6IGZ1bmN0aW9uKG5vdGUpIHtcbiAgICAgIHRoaXMubm90ZSA9IG5vdGU7XG4gICAgfSxcbiAgICBzZXRXaWR0aDogZnVuY3Rpb24od2lkdGgpe1xuICAgICAgdGhpcy53aWR0aCA9IHdpZHRoO1xuICAgIH0sXG4gICAgZ2V0V2lkdGg6IGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gdGhpcy53aWR0aDtcbiAgICB9LFxuICAgIGRyYXc6IGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKCF0aGlzLmNvbnRleHQpICB7XG4gICAgICAgIHRocm93IG5ldyBWZXguUnVudGltZUVycm9yKFwiTm9Db250ZXh0XCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IEdyYWNlIG5vdGUgd2l0aG91dCBhIGNvbnRleHQuXCIpO1xuICAgICAgfVxuXG4gICAgICB2YXIgbm90ZSA9IHRoaXMuZ2V0Tm90ZSgpO1xuXG4gICAgICBMKFwiRHJhd2luZyBncmFjZSBub3RlIGdyb3VwIGZvcjpcIiwgbm90ZSk7XG5cbiAgICAgIGlmICghKG5vdGUgJiYgKHRoaXMuaW5kZXggIT09IG51bGwpKSkge1xuICAgICAgICB0aHJvdyBuZXcgVmV4LlJ1bnRpbWVFcnJvcihcIk5vQXR0YWNoZWROb3RlXCIsXG4gICAgICAgICAgXCJDYW4ndCBkcmF3IGdyYWNlIG5vdGUgd2l0aG91dCBhIHBhcmVudCBub3RlIGFuZCBwYXJlbnQgbm90ZSBpbmRleC5cIik7XG4gICAgICB9XG5cbiAgICAgIHZhciB0aGF0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGFsaWduR3JhY2VOb3Rlc1dpdGhOb3RlKGdyYWNlX25vdGVzLCBub3RlLCBncm91cFdpZHRoKSB7XG4gICAgICAgIC8vIFNoaWZ0IG92ZXIgdGhlIHRpY2sgY29udGV4dHMgb2YgZWFjaCBub3RlXG4gICAgICAgIC8vIFNvIHRoYXQgdGggYWxpZ25lZCB3aXRoIHRoZSBub3RlXG4gICAgICAgIHZhciB0aWNrQ29udGV4dCA9IG5vdGUuZ2V0VGlja0NvbnRleHQoKTtcbiAgICAgICAgdmFyIGV4dHJhUHggPSB0aWNrQ29udGV4dC5nZXRFeHRyYVB4KCk7XG4gICAgICAgIHZhciB4ID0gdGlja0NvbnRleHQuZ2V0WCgpIC0gZXh0cmFQeC5sZWZ0IC0gZXh0cmFQeC5leHRyYUxlZnQgKyB0aGF0LmdldFNwYWNpbmdGcm9tTmV4dE1vZGlmaWVyKCk7XG4gICAgICAgIGdyYWNlX25vdGVzLmZvckVhY2goZnVuY3Rpb24oZ3JhY2VOb3RlKSB7XG4gICAgICAgICAgICB2YXIgdGlja19jb250ZXh0ID0gZ3JhY2VOb3RlLmdldFRpY2tDb250ZXh0KCk7XG4gICAgICAgICAgICB2YXIgeF9vZmZzZXQgPSB0aWNrX2NvbnRleHQuZ2V0WCgpO1xuICAgICAgICAgICAgZ3JhY2VOb3RlLnNldFN0YXZlKG5vdGUuc3RhdmUpO1xuICAgICAgICAgICAgdGlja19jb250ZXh0LnNldFgoeCArIHhfb2Zmc2V0KTtcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIGFsaWduR3JhY2VOb3Rlc1dpdGhOb3RlKHRoaXMuZ3JhY2Vfbm90ZXMsIG5vdGUsIHRoaXMud2lkdGgpO1xuXG4gICAgICAvLyBEcmF3IG5vdGVzXG4gICAgICB0aGlzLmdyYWNlX25vdGVzLmZvckVhY2goZnVuY3Rpb24oZ3JhY2VOb3RlKSB7XG4gICAgICAgIGdyYWNlTm90ZS5zZXRDb250ZXh0KHRoaXMuY29udGV4dCkuZHJhdygpO1xuICAgICAgfSwgdGhpcyk7XG5cbiAgICAgIC8vIERyYXcgYmVhbVxuICAgICAgaWYgKHRoaXMuYmVhbSkge1xuICAgICAgICB0aGlzLmJlYW0uc2V0Q29udGV4dCh0aGlzLmNvbnRleHQpLmRyYXcoKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRoaXMuc2hvd19zbHVyKSB7XG4gICAgICAgIC8vIENyZWF0ZSBhbmQgZHJhdyBzbHVyXG4gICAgICAgIHRoaXMuc2x1ciA9IG5ldyBWZXguRmxvdy5TdGF2ZVRpZSh7XG4gICAgICAgICAgbGFzdF9ub3RlOiB0aGlzLmdyYWNlX25vdGVzWzBdLFxuICAgICAgICAgIGZpcnN0X25vdGU6IG5vdGUsXG4gICAgICAgICAgZmlyc3RfaW5kaWNlczogWzBdLFxuICAgICAgICAgIGxhc3RfaW5kaWNlczogWzBdXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuc2x1ci5yZW5kZXJfb3B0aW9ucy5jcDIgPSAxMjtcbiAgICAgICAgdGhpcy5zbHVyLnNldENvbnRleHQodGhpcy5jb250ZXh0KS5kcmF3KCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxucmV0dXJuIEdyYWNlTm90ZUdyb3VwO1xufSgpKTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXZleGZsb3ctZGVidWcuanMubWFwIiwiLyogcGFyc2VyIGdlbmVyYXRlZCBieSBqaXNvbiAwLjQuMTYgKi9cbi8qXG4gIFJldHVybnMgYSBQYXJzZXIgb2JqZWN0IG9mIHRoZSBmb2xsb3dpbmcgc3RydWN0dXJlOlxuXG4gIFBhcnNlcjoge1xuICAgIHl5OiB7fVxuICB9XG5cbiAgUGFyc2VyLnByb3RvdHlwZToge1xuICAgIHl5OiB7fSxcbiAgICB0cmFjZTogZnVuY3Rpb24oKSxcbiAgICBzeW1ib2xzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG5hbWUgPT0+IG51bWJlcn0sXG4gICAgdGVybWluYWxzXzoge2Fzc29jaWF0aXZlIGxpc3Q6IG51bWJlciA9PT4gbmFtZX0sXG4gICAgcHJvZHVjdGlvbnNfOiBbLi4uXSxcbiAgICBwZXJmb3JtQWN0aW9uOiBmdW5jdGlvbiBhbm9ueW1vdXMoeXl0ZXh0LCB5eWxlbmcsIHl5bGluZW5vLCB5eSwgeXlzdGF0ZSwgJCQsIF8kKSxcbiAgICB0YWJsZTogWy4uLl0sXG4gICAgZGVmYXVsdEFjdGlvbnM6IHsuLi59LFxuICAgIHBhcnNlRXJyb3I6IGZ1bmN0aW9uKHN0ciwgaGFzaCksXG4gICAgcGFyc2U6IGZ1bmN0aW9uKGlucHV0KSxcblxuICAgIGxleGVyOiB7XG4gICAgICAgIEVPRjogMSxcbiAgICAgICAgcGFyc2VFcnJvcjogZnVuY3Rpb24oc3RyLCBoYXNoKSxcbiAgICAgICAgc2V0SW5wdXQ6IGZ1bmN0aW9uKGlucHV0KSxcbiAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCksXG4gICAgICAgIHVucHV0OiBmdW5jdGlvbihzdHIpLFxuICAgICAgICBtb3JlOiBmdW5jdGlvbigpLFxuICAgICAgICBsZXNzOiBmdW5jdGlvbihuKSxcbiAgICAgICAgcGFzdElucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICB1cGNvbWluZ0lucHV0OiBmdW5jdGlvbigpLFxuICAgICAgICBzaG93UG9zaXRpb246IGZ1bmN0aW9uKCksXG4gICAgICAgIHRlc3RfbWF0Y2g6IGZ1bmN0aW9uKHJlZ2V4X21hdGNoX2FycmF5LCBydWxlX2luZGV4KSxcbiAgICAgICAgbmV4dDogZnVuY3Rpb24oKSxcbiAgICAgICAgbGV4OiBmdW5jdGlvbigpLFxuICAgICAgICBiZWdpbjogZnVuY3Rpb24oY29uZGl0aW9uKSxcbiAgICAgICAgcG9wU3RhdGU6IGZ1bmN0aW9uKCksXG4gICAgICAgIF9jdXJyZW50UnVsZXM6IGZ1bmN0aW9uKCksXG4gICAgICAgIHRvcFN0YXRlOiBmdW5jdGlvbigpLFxuICAgICAgICBwdXNoU3RhdGU6IGZ1bmN0aW9uKGNvbmRpdGlvbiksXG5cbiAgICAgICAgb3B0aW9uczoge1xuICAgICAgICAgICAgcmFuZ2VzOiBib29sZWFuICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IHRva2VuIGxvY2F0aW9uIGluZm8gd2lsbCBpbmNsdWRlIGEgLnJhbmdlW10gbWVtYmVyKVxuICAgICAgICAgICAgZmxleDogYm9vbGVhbiAgICAgICAgICAgICAob3B0aW9uYWw6IHRydWUgPT0+IGZsZXgtbGlrZSBsZXhpbmcgYmVoYXZpb3VyIHdoZXJlIHRoZSBydWxlcyBhcmUgdGVzdGVkIGV4aGF1c3RpdmVseSB0byBmaW5kIHRoZSBsb25nZXN0IG1hdGNoKVxuICAgICAgICAgICAgYmFja3RyYWNrX2xleGVyOiBib29sZWFuICAob3B0aW9uYWw6IHRydWUgPT0+IGxleGVyIHJlZ2V4ZXMgYXJlIHRlc3RlZCBpbiBvcmRlciBhbmQgZm9yIGVhY2ggbWF0Y2hpbmcgcmVnZXggdGhlIGFjdGlvbiBjb2RlIGlzIGludm9rZWQ7IHRoZSBsZXhlciB0ZXJtaW5hdGVzIHRoZSBzY2FuIHdoZW4gYSB0b2tlbiBpcyByZXR1cm5lZCBieSB0aGUgYWN0aW9uIGNvZGUpXG4gICAgICAgIH0sXG5cbiAgICAgICAgcGVyZm9ybUFjdGlvbjogZnVuY3Rpb24oeXksIHl5XywgJGF2b2lkaW5nX25hbWVfY29sbGlzaW9ucywgWVlfU1RBUlQpLFxuICAgICAgICBydWxlczogWy4uLl0sXG4gICAgICAgIGNvbmRpdGlvbnM6IHthc3NvY2lhdGl2ZSBsaXN0OiBuYW1lID09PiBzZXR9LFxuICAgIH1cbiAgfVxuXG5cbiAgdG9rZW4gbG9jYXRpb24gaW5mbyAoQCQsIF8kLCBldGMuKToge1xuICAgIGZpcnN0X2xpbmU6IG4sXG4gICAgbGFzdF9saW5lOiBuLFxuICAgIGZpcnN0X2NvbHVtbjogbixcbiAgICBsYXN0X2NvbHVtbjogbixcbiAgICByYW5nZTogW3N0YXJ0X251bWJlciwgZW5kX251bWJlcl0gICAgICAgKHdoZXJlIHRoZSBudW1iZXJzIGFyZSBpbmRleGVzIGludG8gdGhlIGlucHV0IHN0cmluZywgcmVndWxhciB6ZXJvLWJhc2VkKVxuICB9XG5cblxuICB0aGUgcGFyc2VFcnJvciBmdW5jdGlvbiByZWNlaXZlcyBhICdoYXNoJyBvYmplY3Qgd2l0aCB0aGVzZSBtZW1iZXJzIGZvciBsZXhlciBhbmQgcGFyc2VyIGVycm9yczoge1xuICAgIHRleHQ6ICAgICAgICAobWF0Y2hlZCB0ZXh0KVxuICAgIHRva2VuOiAgICAgICAodGhlIHByb2R1Y2VkIHRlcm1pbmFsIHRva2VuLCBpZiBhbnkpXG4gICAgbGluZTogICAgICAgICh5eWxpbmVubylcbiAgfVxuICB3aGlsZSBwYXJzZXIgKGdyYW1tYXIpIGVycm9ycyB3aWxsIGFsc28gcHJvdmlkZSB0aGVzZSBtZW1iZXJzLCBpLmUuIHBhcnNlciBlcnJvcnMgZGVsaXZlciBhIHN1cGVyc2V0IG9mIGF0dHJpYnV0ZXM6IHtcbiAgICBsb2M6ICAgICAgICAgKHl5bGxvYylcbiAgICBleHBlY3RlZDogICAgKHN0cmluZyBkZXNjcmliaW5nIHRoZSBzZXQgb2YgZXhwZWN0ZWQgdG9rZW5zKVxuICAgIHJlY292ZXJhYmxlOiAoYm9vbGVhbjogVFJVRSB3aGVuIHRoZSBwYXJzZXIgaGFzIGEgZXJyb3IgcmVjb3ZlcnkgcnVsZSBhdmFpbGFibGUgZm9yIHRoaXMgcGFydGljdWxhciBlcnJvcilcbiAgfVxuKi9cbnZhciBwYXJzZXIgPSAoZnVuY3Rpb24oKXtcbnZhciBvPWZ1bmN0aW9uKGssdixvLGwpe2ZvcihvPW98fHt9LGw9ay5sZW5ndGg7bC0tO29ba1tsXV09dik7cmV0dXJuIG99LCRWMD1bMSw1XSwkVjE9WzEsNl0sJFYyPVs1LDgsMTBdLCRWMz1bMSwxMl0sJFY0PVsxLDEzXSwkVjU9WzEsMTRdLCRWNj1bMSwxNl0sJFY3PVs1LDgsMTAsMTYsMTcsMThdLCRWOD1bNSw4LDEwLDE2LDE3LDE4LDIwLDIyLDI0XSwkVjk9WzIsMjBdLCRWYT1bNSw4LDEwLDE2LDE3LDE4LDIwLDIyLDI0LDI1XSwkVmI9WzEsMjBdLCRWYz1bMSwyNF0sJFZkPVsxLDI1XSwkVmU9WzEsMjZdLCRWZj1bMSw0OV0sJFZnPVsxLDM4XSwkVmg9WzEsMzldLCRWaT1bMSw0OF0sJFZqPVsxLDQ3XSwkVms9WzEsNDVdLCRWbD1bMSw1NF0sJFZtPVsxLDYxXSwkVm49WzEsNTZdLCRWbz1bMSw1N10sJFZwPVsxLDU4XSwkVnE9WzEsNTldLCRWcj1bMSw2MF0sJFZzPVsxLDYyXSwkVnQ9WzEsNTBdLCRWdT1bMSw1MV0sJFZ2PVsxLDUyXSwkVnc9WzEsNTNdLCRWeD1bMSw2M10sJFZ5PVs1LDgsMTAsMTYsMTcsMTgsMjAsMjIsMjQsMjhdLCRWej1bNSw4LDEwLDE2LDE3LDE4LDIwLDIyLDI0LDI2LDM0LDM1LDQwLDQxLDQ4LDUxLDYwLDY0LDY1LDY2LDY3LDY4LDY5LDczLDc0LDc2LDc4LDc5XSwkVkE9WzIsODJdLCRWQj1bMSw3Ml0sJFZDPVsxLDY5XSwkVkQ9WzEsNzBdLCRWRT1bMSw3MV0sJFZGPVsxLDc4XSwkVkc9WzEsNzldLCRWSD1bMSw4M10sJFZJPVsxLDg0XSwkVko9WzEsODVdLCRWSz1bMSw4Nl0sJFZMPVs0NCw2MCw2Miw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Ml0sJFZNPVs0MSw0OCw1MSw3OV0sJFZOPVs0NCw1MSw2MCw2Miw2NCw2NSw2Niw2Nyw2OCw2OSw3MCw3MSw3Miw4NF0sJFZPPVs1LDgsMTAsMTYsMTcsMTgsMjAsMjIsMjQsMjYsMzQsMzUsNDAsNDEsNDQsNDgsNTEsNjAsNjQsNjUsNjYsNjcsNjgsNjksNzMsNzQsNzYsNzgsNzldLCRWUD1bMSwxMDVdLCRWUT1bNDcsNDldLCRWUj1bMiw2Nl0sJFZTPVsxLDExMF0sJFZUPVs1LDgsMTAsMTYsMTcsMTgsMjAsMjIsMjQsMjYsMzQsMzUsNDAsNDEsNDgsNTEsNjAsNjIsNjQsNjUsNjYsNjcsNjgsNjksNzMsNzQsNzYsNzgsNzldLCRWVT1bNSw4LDEwLDE2LDE3LDE4LDIwLDIyLDI0LDI2LDM0LDM1LDQwLDQxLDQ4LDUxLDYwLDYyLDYzLDY0LDY1LDY2LDY3LDY4LDY5LDczLDc0LDc2LDc4LDc5XSwkVlY9WzI4LDc0XSwkVlc9WzQ0LDUxLDYwLDYyLDY0LDY1LDY2LDY3LDY4LDY5LDcwLDcxLDcyXSwkVlg9WzUsOCwxMCwxNiwxNywxOCwyMCwyMiwyNCwyNiwzNCwzNSw0MCw0MSw0Nyw0OCw0OSw1MSw2MCw2NCw2NSw2Niw2Nyw2OCw2OSw3Myw3NCw3Niw3OCw3OV07XG52YXIgcGFyc2VyID0ge3RyYWNlOiBmdW5jdGlvbiB0cmFjZSgpIHsgfSxcbnl5OiB7fSxcbnN5bWJvbHNfOiB7XCJlcnJvclwiOjIsXCJlXCI6MyxcIm1heWJlX3ZleHRhYlwiOjQsXCJFT0ZcIjo1LFwidmV4dGFiXCI6NixcInN0YXZlZ3JvdXBcIjo3LFwiU1RBVkVHUk9VUFwiOjgsXCJzdGF2ZWxpc3RcIjo5LFwiT1BUSU9OU1wiOjEwLFwib3B0aW9uc1wiOjExLFwic3RhdmVcIjoxMixcInZvaWNlXCI6MTMsXCJtYXliZV9vcHRpb25zXCI6MTQsXCJzdGF2ZV9kYXRhXCI6MTUsXCJUQUJTVEFWRVwiOjE2LFwiU1RBVkVcIjoxNyxcIlZPSUNFXCI6MTgsXCJzdGF2ZV9hZGRpdGlvbnNcIjoxOSxcIlRFWFRcIjoyMCxcInRleHRcIjoyMSxcIk5PVEVTXCI6MjIsXCJub3Rlc1wiOjIzLFwiU0xVUlwiOjI0LFwiV09SRFwiOjI1LFwiPVwiOjI2LFwiU1RSXCI6MjcsXCIsXCI6MjgsXCJsaW5nb1wiOjI5LFwibGluZVwiOjMwLFwiY2hvcmRcIjozMSxcInRpbWVcIjozMixcImJhclwiOjMzLFwiW1wiOjM0LFwiXVwiOjM1LFwidHVwbGV0c1wiOjM2LFwiYW5ub3RhdGlvbnNcIjozNyxcImNvbW1hbmRcIjozOCxcInJlc3RcIjozOSxcInxcIjo0MCxcIjpcIjo0MSxcImZyZXRzXCI6NDIsXCJtYXliZV9kZWNvcmF0b3JcIjo0MyxcIi9cIjo0NCxcInN0cmluZ1wiOjQ1LFwiY2hvcmRfbGluZVwiOjQ2LFwiLlwiOjQ3LFwiKFwiOjQ4LFwiKVwiOjQ5LFwiYXJ0aWN1bGF0aW9uXCI6NTAsXCJOVU1CRVJcIjo1MSxcImFiY1wiOjUyLFwiX1wiOjUzLFwidGltZWRfZnJldFwiOjU0LFwidGltZV92YWx1ZXNcIjo1NSxcIm1heWJlX2RvdFwiOjU2LFwidGltZV91bml0XCI6NTcsXCJtYXliZV9zbGFzaFwiOjU4LFwid1wiOjU5LFwiaFwiOjYwLFwicVwiOjYxLFwiZFwiOjYyLFwiU1wiOjYzLFwiLVwiOjY0LFwic1wiOjY1LFwidFwiOjY2LFwiVFwiOjY3LFwiYlwiOjY4LFwicFwiOjY5LFwidlwiOjcwLFwiVlwiOjcxLFwidVwiOjcyLFwiXlwiOjczLFwiJFwiOjc0LFwiYW5ub3RhdGlvbl93b3Jkc1wiOjc1LFwiIVwiOjc2LFwiQ09NTUFORFwiOjc3LFwiI1wiOjc4LFwiQUJDXCI6NzksXCJhYmNfYWNjaWRlbnRhbFwiOjgwLFwiYWNjaWRlbnRhbF90eXBlXCI6ODEsXCJAXCI6ODIsXCJuXCI6ODMsXCJ+XCI6ODQsXCIkYWNjZXB0XCI6MCxcIiRlbmRcIjoxfSxcbnRlcm1pbmFsc186IHsyOlwiZXJyb3JcIiw1OlwiRU9GXCIsODpcIlNUQVZFR1JPVVBcIiwxMDpcIk9QVElPTlNcIiwxNjpcIlRBQlNUQVZFXCIsMTc6XCJTVEFWRVwiLDE4OlwiVk9JQ0VcIiwyMDpcIlRFWFRcIiwyMjpcIk5PVEVTXCIsMjQ6XCJTTFVSXCIsMjU6XCJXT1JEXCIsMjY6XCI9XCIsMjc6XCJTVFJcIiwyODpcIixcIiwzNDpcIltcIiwzNTpcIl1cIiw0MDpcInxcIiw0MTpcIjpcIiw0NDpcIi9cIiw0NzpcIi5cIiw0ODpcIihcIiw0OTpcIilcIiw1MTpcIk5VTUJFUlwiLDUzOlwiX1wiLDU5Olwid1wiLDYwOlwiaFwiLDYxOlwicVwiLDYyOlwiZFwiLDYzOlwiU1wiLDY0OlwiLVwiLDY1Olwic1wiLDY2OlwidFwiLDY3OlwiVFwiLDY4OlwiYlwiLDY5OlwicFwiLDcwOlwidlwiLDcxOlwiVlwiLDcyOlwidVwiLDczOlwiXlwiLDc0OlwiJFwiLDc2OlwiIVwiLDc3OlwiQ09NTUFORFwiLDc4OlwiI1wiLDc5OlwiQUJDXCIsODI6XCJAXCIsODM6XCJuXCIsODQ6XCJ+XCJ9LFxucHJvZHVjdGlvbnNfOiBbMCxbMywyXSxbNCwwXSxbNCwxXSxbNiwxXSxbNiwyXSxbNywyXSxbNywyXSxbOSwxXSxbOSwyXSxbMTIsM10sWzEyLDJdLFsxMywxXSxbMTMsMV0sWzEzLDFdLFsxNSwxXSxbMTUsMl0sWzE5LDJdLFsxOSwyXSxbMTksMl0sWzE0LDBdLFsxNCwxXSxbMTEsM10sWzExLDRdLFsyMSwxXSxbMjEsM10sWzIzLDFdLFsyMywyXSxbMjksMV0sWzI5LDFdLFsyOSwxXSxbMjksMV0sWzI5LDFdLFsyOSwxXSxbMjksMV0sWzI5LDFdLFsyOSwxXSxbMjksMV0sWzMzLDFdLFszMywzXSxbMzMsM10sWzMzLDNdLFszMywzXSxbMzMsM10sWzMwLDRdLFs0NiwxXSxbNDYsM10sWzMxLDRdLFszMSw1XSxbNDIsMV0sWzQyLDFdLFs0Miw0XSxbNDIsMl0sWzQyLDRdLFs1NCw1XSxbNTQsMV0sWzU0LDVdLFs1NCw4XSxbNTQsMV0sWzU0LDRdLFszMiwzXSxbNTUsMl0sWzU3LDFdLFs1NywxXSxbNTcsMV0sWzU3LDFdLFs1NiwwXSxbNTYsMV0sWzU4LDBdLFs1OCwxXSxbNDUsMV0sWzUwLDFdLFs1MCwxXSxbNTAsMV0sWzUwLDFdLFs1MCwxXSxbNTAsMV0sWzUwLDFdLFs0MywxXSxbNDMsMV0sWzQzLDFdLFs0MywxXSxbNDMsMF0sWzM2LDNdLFszNiw1XSxbMzcsM10sWzc1LDFdLFs3NSwzXSxbMzgsM10sWzM5LDJdLFszOSwzXSxbMzksNF0sWzUyLDNdLFs4MCwxXSxbODAsMl0sWzgwLDFdLFs4MCwyXSxbODAsMV0sWzgwLDBdLFs4MSwwXSxbODEsMV1dLFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5dGV4dCwgeXlsZW5nLCB5eWxpbmVubywgeXksIHl5c3RhdGUgLyogYWN0aW9uWzFdICovLCAkJCAvKiB2c3RhY2sgKi8sIF8kIC8qIGxzdGFjayAqLykge1xuLyogdGhpcyA9PSB5eXZhbCAqL1xuXG52YXIgJDAgPSAkJC5sZW5ndGggLSAxO1xuc3dpdGNoICh5eXN0YXRlKSB7XG5jYXNlIDE6XG5cbiAgICAgIHJldHVybiAkJFskMC0xXTtcbiAgICBcbmJyZWFrO1xuY2FzZSAyOiBjYXNlIDIwOiBjYXNlIDgyOlxuIHRoaXMuJCA9IG51bGwgXG5icmVhaztcbmNhc2UgMzogY2FzZSAxNTogY2FzZSAyMTogY2FzZSAyNjogY2FzZSAyODogY2FzZSAyOTogY2FzZSAzMDogY2FzZSA0NTogY2FzZSA2MjogY2FzZSA2MzogY2FzZSA2NDogY2FzZSA2NTogY2FzZSA3MDpcbiB0aGlzLiQgPSAkJFskMF0gXG5icmVhaztcbmNhc2UgNDogY2FzZSA4OiBjYXNlIDg2OlxuIHRoaXMuJCA9IFskJFskMF1dIFxuYnJlYWs7XG5jYXNlIDU6IGNhc2UgOTpcbiB0aGlzLiQgPSBbXS5jb25jYXQoJCRbJDAtMV0sICQkWyQwXSkgXG5icmVhaztcbmNhc2UgNjpcbiB0aGlzLiQgPSB7XG4gICAgICAgIGVsZW1lbnQ6IFwic3RhdmVncm91cFwiLFxuICAgICAgICBzdGF2ZWxpc3Q6ICQkWyQwXSxcbiAgICAgICAgX2w6IF8kWyQwLTFdLmZpcnN0X2xpbmUsXG4gICAgICAgIF9jOiBfJFskMC0xXS5maXJzdF9jb2x1bW5cbiAgICAgIH1cbiAgICBcbmJyZWFrO1xuY2FzZSA3OlxuXG4gICAgICB0aGlzLiQgPSB7XG4gICAgICAgIGVsZW1lbnQ6IFwib3B0aW9uc1wiLFxuICAgICAgICBwYXJhbXM6ICQkWyQwXSxcbiAgICAgICAgX2w6IF8kWyQwLTFdLmZpcnN0X2xpbmUsXG4gICAgICAgIF9jOiBfJFskMC0xXS5maXJzdF9jb2x1bW5cbiAgICAgIH1cbiAgICBcbmJyZWFrO1xuY2FzZSAxMDpcbiB0aGlzLiQgPSB7XG4gICAgICAgIGVsZW1lbnQ6ICQkWyQwLTJdLFxuICAgICAgICBvcHRpb25zOiAkJFskMC0xXSxcbiAgICAgICAgbm90ZXM6ICQkWyQwXS5ub3RlcyxcbiAgICAgICAgdGV4dDogJCRbJDBdLnRleHQsXG4gICAgICAgIF9sOiBfJFskMC0yXS5maXJzdF9saW5lLFxuICAgICAgICBfYzogXyRbJDAtMl0uZmlyc3RfY29sdW1uXG4gICAgICB9XG4gICAgXG5icmVhaztcbmNhc2UgMTE6XG4gdGhpcy4kID0ge1xuICAgICAgICBlbGVtZW50OiAkJFskMC0xXSxcbiAgICAgICAgb3B0aW9uczogJCRbJDBdLFxuICAgICAgICBfbDogXyRbJDAtMV0uZmlyc3RfbGluZSxcbiAgICAgICAgX2M6IF8kWyQwLTFdLmZpcnN0X2NvbHVtblxuICAgICAgfVxuICAgIFxuYnJlYWs7XG5jYXNlIDE2OlxuXG4gICAgICB2YXIgdGV4dCA9IFtdLmNvbmNhdCgkJFskMC0xXS50ZXh0LCAkJFskMF0udGV4dCk7XG4gICAgICB2YXIgbm90ZXMgPSBbXS5jb25jYXQoJCRbJDAtMV0ubm90ZXMsICQkWyQwXS5ub3Rlcyk7XG4gICAgICB2YXIgc2x1cnMgPSBbXS5jb25jYXQoJCRbJDAtMV0uc2x1cnMsICQkWyQwXS5zbHVycylcbiAgICAgIHRoaXMuJCA9IHt0ZXh0OiB0ZXh0LCBub3Rlczogbm90ZXMsIHNsdXJzOiBzbHVyc307XG4gICAgXG5icmVhaztcbmNhc2UgMTc6XG50aGlzLiQgPSB7dGV4dDogJCRbJDBdLCBub3RlczogW10sIHNsdXJzOiBbXX1cbmJyZWFrO1xuY2FzZSAxODpcbnRoaXMuJCA9IHtub3RlczogJCRbJDBdLCB0ZXh0OiBbXSwgc2x1cnM6IFtdfVxuYnJlYWs7XG5jYXNlIDE5OlxudGhpcy4kID0ge3NsdXJzOiAkJFskMF0sIG5vdGVzOiBbXSwgdGV4dDogW119XG5icmVhaztcbmNhc2UgMjI6XG4gdGhpcy4kID0gW3tcbiAgICAgICAga2V5OiAkJFskMC0yXSxcbiAgICAgICAgdmFsdWU6ICQkWyQwXSxcbiAgICAgICAgX2w6IF8kWyQwLTJdLmZpcnN0X2xpbmUsXG4gICAgICAgIF9jOiBfJFskMC0yXS5maXJzdF9jb2x1bW5cbiAgICAgIH1dXG4gICAgXG5icmVhaztcbmNhc2UgMjM6XG4gdGhpcy4kID0gW10uY29uY2F0KCQkWyQwLTNdLCBbe1xuICAgICAgICBrZXk6ICQkWyQwLTJdLFxuICAgICAgICB2YWx1ZTogJCRbJDBdLFxuICAgICAgICBfbDogXyRbJDAtMl0uZmlyc3RfbGluZSxcbiAgICAgICAgX2M6IF8kWyQwLTJdLmZpcnN0X2NvbHVtblxuICAgICAgICB9XSlcbiAgICBcbmJyZWFrO1xuY2FzZSAyNDpcbiB0aGlzLiQgPSBbe3RleHQ6ICQkWyQwXSwgX2w6IF8kWyQwXS5maXJzdF9saW5lLCBfYzogXyRbJDBdLmZpcnN0X2NvbHVtbn1dIFxuYnJlYWs7XG5jYXNlIDI1OlxuIHRoaXMuJCA9IFtdLmNvbmNhdCgkJFskMC0yXSwge3RleHQ6ICQkWyQwXSwgX2w6IF8kWyQwXS5maXJzdF9saW5lLCBfYzogXyRbJDBdLmZpcnN0X2NvbHVtbn0pIFxuYnJlYWs7XG5jYXNlIDI3OlxuIHRoaXMuJCA9IFtdLmNvbmNhdCgkJFskMC0xXSwgJCRbJDBdKSAgXG5icmVhaztcbmNhc2UgMzE6XG4gdGhpcy4kID0gW3tcbiAgICAgICAgY29tbWFuZDogXCJiYXJcIixcbiAgICAgICAgdHlwZTogJCRbJDBdLFxuICAgICAgICBfbDogXyRbJDBdLmZpcnN0X2xpbmUsXG4gICAgICAgIF9jOiBfJFskMF0uZmlyc3RfY29sdW1uXG4gICAgICAgIH1dXG4gICAgXG5icmVhaztcbmNhc2UgMzI6XG4gdGhpcy4kID0gW3tcbiAgICAgICAgY29tbWFuZDogXCJvcGVuX2JlYW1cIixcbiAgICAgICAgX2w6IF8kWyQwXS5maXJzdF9saW5lLFxuICAgICAgICBfYzogXyRbJDBdLmZpcnN0X2NvbHVtblxuICAgICAgfV1cbiAgICBcbmJyZWFrO1xuY2FzZSAzMzpcbiB0aGlzLiQgPSBbe1xuICAgICAgICBjb21tYW5kOiBcImNsb3NlX2JlYW1cIixcbiAgICAgICAgX2w6IF8kWyQwXS5maXJzdF9saW5lLFxuICAgICAgICBfYzogXyRbJDBdLmZpcnN0X2NvbHVtblxuICAgICAgfV1cbiAgICBcbmJyZWFrO1xuY2FzZSAzNDpcbiB0aGlzLiQgPSBbe1xuICAgICAgICBjb21tYW5kOiBcInR1cGxldFwiLFxuICAgICAgICBwYXJhbXM6ICQkWyQwXSxcbiAgICAgICAgX2w6IF8kWyQwXS5maXJzdF9saW5lLFxuICAgICAgICBfYzogXyRbJDBdLmZpcnN0X2NvbHVtblxuICAgICAgfV1cbiAgICBcbmJyZWFrO1xuY2FzZSAzNTpcbiB0aGlzLiQgPSBbe1xuICAgICAgICBjb21tYW5kOiBcImFubm90YXRpb25zXCIsXG4gICAgICAgIHBhcmFtczogJCRbJDBdLFxuICAgICAgICBfbDogXyRbJDBdLmZpcnN0X2xpbmUsXG4gICAgICAgIF9jOiBfJFskMF0uZmlyc3RfY29sdW1uXG4gICAgICB9XVxuICAgIFxuYnJlYWs7XG5jYXNlIDM2OlxuIHRoaXMuJCA9IFt7XG4gICAgICAgIGNvbW1hbmQ6IFwiY29tbWFuZFwiLFxuICAgICAgICBwYXJhbXM6ICQkWyQwXSxcbiAgICAgICAgX2w6IF8kWyQwXS5maXJzdF9saW5lLFxuICAgICAgICBfYzogXyRbJDBdLmZpcnN0X2NvbHVtblxuICAgICAgfV1cbiAgICBcbmJyZWFrO1xuY2FzZSAzNzpcblxuICAgIHRoaXMuJCA9IFt7XG4gICAgICAgIGNvbW1hbmQ6IFwicmVzdFwiLFxuICAgICAgICBwYXJhbXM6ICQkWyQwXVxuICAgICAgfV1cbiAgICBcbmJyZWFrO1xuY2FzZSAzODpcbiB0aGlzLiQgPSAnc2luZ2xlJyBcbmJyZWFrO1xuY2FzZSAzOTpcbiB0aGlzLiQgPSAnZG91YmxlJyBcbmJyZWFrO1xuY2FzZSA0MDpcbiB0aGlzLiQgPSAnZW5kJyBcbmJyZWFrO1xuY2FzZSA0MTpcbiB0aGlzLiQgPSAncmVwZWF0LWVuZCcgXG5icmVhaztcbmNhc2UgNDI6XG4gdGhpcy4kID0gJ3JlcGVhdC1iZWdpbicgXG5icmVhaztcbmNhc2UgNDM6XG4gdGhpcy4kID0gJ3JlcGVhdC1ib3RoJyBcbmJyZWFrO1xuY2FzZSA0NDpcblxuICAgICAgXy5leHRlbmQoXy5sYXN0KCQkWyQwLTNdKSwge2RlY29yYXRvcjogJCRbJDAtMl19KVxuICAgICAgXy5lYWNoKCQkWyQwLTNdLCBmdW5jdGlvbihmcmV0KSB7IGZyZXRbJ3N0cmluZyddID0gJCRbJDBdIH0pXG4gICAgICB0aGlzLiQgPSAkJFskMC0zXVxuICAgIFxuYnJlYWs7XG5jYXNlIDQ2OiBjYXNlIDg3OlxuIHRoaXMuJCA9IFtdLmNvbmNhdCgkJFskMC0yXSwgJCRbJDBdKSBcbmJyZWFrO1xuY2FzZSA0NzpcbiB0aGlzLiQgPSBbe2Nob3JkOiAkJFskMC0yXSwgZGVjb3JhdG9yOiAkJFskMF19XSBcbmJyZWFrO1xuY2FzZSA0ODpcbiB0aGlzLiQgPSBbe2Nob3JkOiAkJFskMC0yXSwgYXJ0aWN1bGF0aW9uOiAkJFskMC00XSwgZGVjb3JhdG9yOiAkJFskMF19XSBcbmJyZWFrO1xuY2FzZSA0OTpcbiB0aGlzLiQgPSBbe1xuICAgICAgICBmcmV0OiAkJFskMF0sXG4gICAgICAgIF9sOiBfJFskMF0uZmlyc3RfbGluZSxcbiAgICAgICAgX2M6IF8kWyQwXS5maXJzdF9jb2x1bW59XVxuICAgIFxuYnJlYWs7XG5jYXNlIDUwOlxuIHRoaXMuJCA9IFt7YWJjOiAkJFskMF0sIF9sOiBfJFskMF0uZmlyc3RfbGluZSwgX2M6IF8kWyQwXS5maXJzdF9jb2x1bW59XVxuYnJlYWs7XG5jYXNlIDUxOlxuIHRoaXMuJCA9IFt7YWJjOiAkJFskMC0zXSwgb2N0YXZlOiAkJFskMC0yXSxcbiAgICAgICAgICAgICBmcmV0OiAkJFskMF0sIF9sOiBfJFskMC0zXS5maXJzdF9saW5lLCBfYzogXyRbJDAtM10uZmlyc3RfY29sdW1ufV1cbmJyZWFrO1xuY2FzZSA1MjpcbiB0aGlzLiQgPSBbXy5leHRlbmQoJCRbJDBdLCB7YXJ0aWN1bGF0aW9uOiAkJFskMC0xXX0pXSBcbmJyZWFrO1xuY2FzZSA1MzpcblxuICAgICAgXy5leHRlbmQoXy5sYXN0KCQkWyQwLTNdKSwge2RlY29yYXRvcjogJCRbJDAtMl19KVxuICAgICAgXy5leHRlbmQoJCRbJDBdLCB7YXJ0aWN1bGF0aW9uOiAkJFskMC0xXX0pXG4gICAgICAkJFskMC0zXS5wdXNoKCQkWyQwXSlcbiAgICAgIHRoaXMuJCA9ICQkWyQwLTNdXG4gICAgXG5icmVhaztcbmNhc2UgNTQ6XG4gdGhpcy4kID0ge1xuICAgICAgdGltZTogJCRbJDAtM10sIGRvdDogJCRbJDAtMl0sIGZyZXQ6ICQkWyQwXSxcbiAgICAgIF9sOiBfJFskMC00XS5maXJzdF9saW5lLCBfYzogXyRbJDAtNF0uZmlyc3RfY29sdW1ufVxuYnJlYWs7XG5jYXNlIDU1OlxuIHRoaXMuJCA9IHtmcmV0OiAkJFskMF0sIF9sOiBfJFskMF0uZmlyc3RfbGluZSwgX2M6IF8kWyQwXS5maXJzdF9jb2x1bW59IFxuYnJlYWs7XG5jYXNlIDU2OlxuIHRoaXMuJCA9IHt0aW1lOiAkJFskMC0zXSwgZG90OiAkJFskMC0yXSwgYWJjOiAkJFskMF19XG5icmVhaztcbmNhc2UgNTc6XG4gdGhpcy4kID0ge3RpbWU6ICQkWyQwLTZdLCBkb3Q6ICQkWyQwLTVdLCBhYmM6ICQkWyQwLTNdLCBvY3RhdmU6ICQkWyQwLTJdLCBmcmV0OiAkJFskMF19XG5icmVhaztcbmNhc2UgNTg6XG4gdGhpcy4kID0ge2FiYzogJCRbJDBdLCBfbDogXyRbJDBdLmZpcnN0X2xpbmUsIF9jOiBfJFskMF0uZmlyc3RfY29sdW1ufSBcbmJyZWFrO1xuY2FzZSA1OTpcbiB0aGlzLiQgPSB7YWJjOiAkJFskMC0zXSwgb2N0YXZlOiAkJFskMC0yXSxcbiAgICAgICAgICAgIGZyZXQ6ICQkWyQwXSwgX2w6IF8kWyQwLTNdLmZpcnN0X2xpbmUsIF9jOiBfJFskMC0zXS5maXJzdF9jb2x1bW59IFxuYnJlYWs7XG5jYXNlIDYwOlxuIHRoaXMuJCA9IHt0aW1lOiAkJFskMC0xXSwgZG90OiAkJFskMF19IFxuYnJlYWs7XG5jYXNlIDYxOlxuIHRoaXMuJCA9ICQkWyQwLTFdICsgJCRbJDBdIFxuYnJlYWs7XG5jYXNlIDY2OlxuIHRoaXMuJCA9IGZhbHNlIFxuYnJlYWs7XG5jYXNlIDY3OlxuIHRoaXMuJCA9IHRydWUgXG5icmVhaztcbmNhc2UgNjg6XG4gdGhpcy4kID0gJycgXG5icmVhaztcbmNhc2UgNjk6IGNhc2UgNzI6XG4gdGhpcy4kID0gJ3MnIFxuYnJlYWs7XG5jYXNlIDcxOlxuIHRoaXMuJCA9ICctJyBcbmJyZWFrO1xuY2FzZSA3MzpcbiB0aGlzLiQgPSAndCcgXG5icmVhaztcbmNhc2UgNzQ6XG4gdGhpcy4kID0gJ1QnIFxuYnJlYWs7XG5jYXNlIDc1OlxuIHRoaXMuJCA9ICdiJyBcbmJyZWFrO1xuY2FzZSA3NjpcbiB0aGlzLiQgPSAnaCcgXG5icmVhaztcbmNhc2UgNzc6XG4gdGhpcy4kID0gJ3AnIFxuYnJlYWs7XG5jYXNlIDc4OlxuIHRoaXMuJCA9ICd2JyBcbmJyZWFrO1xuY2FzZSA3OTpcbiB0aGlzLiQgPSAnVicgXG5icmVhaztcbmNhc2UgODA6XG4gdGhpcy4kID0gJ3UnIFxuYnJlYWs7XG5jYXNlIDgxOlxuIHRoaXMuJCA9ICdkJyBcbmJyZWFrO1xuY2FzZSA4MzpcbiB0aGlzLiQgPSB7dHVwbGV0OiAkJFskMC0xXX0gXG5icmVhaztcbmNhc2UgODQ6XG4gdGhpcy4kID0ge3R1cGxldDogJCRbJDAtM10sIG5vdGVzOiAkJFskMC0xXX0gXG5icmVhaztcbmNhc2UgODU6IGNhc2UgODg6XG4gdGhpcy4kID0gJCRbJDAtMV0gXG5icmVhaztcbmNhc2UgODk6XG4gdGhpcy4kID0ge3Bvc2l0aW9uOiAwfSBcbmJyZWFrO1xuY2FzZSA5MDpcbiB0aGlzLiQgPSB7cG9zaXRpb246ICQkWyQwLTFdfSBcbmJyZWFrO1xuY2FzZSA5MTpcbiB0aGlzLiQgPSB7cG9zaXRpb246ICQkWyQwLTFdICogLTF9IFxuYnJlYWs7XG5jYXNlIDkyOlxuIHRoaXMuJCA9IHtrZXk6ICQkWyQwLTJdLCBhY2NpZGVudGFsOiAkJFskMC0xXSwgYWNjaWRlbnRhbF90eXBlOiAkJFskMF19IFxuYnJlYWs7XG5jYXNlIDkzOlxuIHRoaXMuJCA9IFwiI1wiIFxuYnJlYWs7XG5jYXNlIDk0OlxuIHRoaXMuJCA9IFwiIyNcIiBcbmJyZWFrO1xuY2FzZSA5NTpcbiB0aGlzLiQgPSBcImJcIiBcbmJyZWFrO1xuY2FzZSA5NjpcbiB0aGlzLiQgPSBcImJiXCIgXG5icmVhaztcbmNhc2UgOTc6XG4gdGhpcy4kID0gXCJuXCIgXG5icmVhaztcbmNhc2UgOTk6XG4gdGhpcy4kID0gbnVsbDsgXG5icmVhaztcbmNhc2UgMTAwOlxuIHRoaXMuJCA9IFwiY1wiIFxuYnJlYWs7XG59XG59LFxudGFibGU6IFt7MzoxLDQ6Miw1OlsyLDJdLDY6Myw3OjQsODokVjAsMTA6JFYxfSx7MTpbM119LHs1OlsxLDddfSx7NTpbMiwzXSw3OjgsODokVjAsMTA6JFYxfSxvKCRWMixbMiw0XSksezk6OSwxMjoxMCwxMzoxMSwxNjokVjMsMTc6JFY0LDE4OiRWNX0sezExOjE1LDI1OiRWNn0sezE6WzIsMV19LG8oJFYyLFsyLDVdKSxvKCRWMixbMiw2XSx7MTM6MTEsMTI6MTcsMTY6JFYzLDE3OiRWNCwxODokVjV9KSxvKCRWNyxbMiw4XSksbygkVjgsJFY5LHsxNDoxOCwxMToxOSwyNTokVjZ9KSxvKCRWYSxbMiwxMl0pLG8oJFZhLFsyLDEzXSksbygkVmEsWzIsMTRdKSxvKCRWMixbMiw3XSx7MjU6JFZifSksezI2OlsxLDIxXX0sbygkVjcsWzIsOV0pLG8oJFY3LFsyLDExXSx7MTU6MjIsMTk6MjMsMjA6JFZjLDIyOiRWZCwyNDokVmV9KSxvKCRWOCxbMiwyMV0sezI1OiRWYn0pLHsyNjpbMSwyN119LHsyNTpbMSwyOF19LG8oJFY3LFsyLDEwXSx7MTk6MjksMjA6JFZjLDIyOiRWZCwyNDokVmV9KSxvKCRWOCxbMiwxNV0pLHsyMTozMCwyNzpbMSwzMV19LHsyMzozMiwyNjokVmYsMjk6MzMsMzA6MzQsMzE6MzUsMzI6MzYsMzM6MzcsMzQ6JFZnLDM1OiRWaCwzNjo0MCwzNzo0MSwzODo0MiwzOTo0Myw0MDokVmksNDE6JFZqLDQyOjQ0LDQ4OiRWayw1MDo0Niw1MTokVmwsNTI6NTUsNjA6JFZtLDY0OiRWbiw2NTokVm8sNjY6JFZwLDY3OiRWcSw2ODokVnIsNjk6JFZzLDczOiRWdCw3NDokVnUsNzY6JFZ2LDc4OiRWdyw3OTokVnh9LG8oJFY4LCRWOSx7MTE6MTksMTQ6NjQsMjU6JFY2fSksezI1OlsxLDY1XX0sbygkVmEsWzIsMjJdKSxvKCRWOCxbMiwxNl0pLG8oJFY4LFsyLDE3XSx7Mjg6WzEsNjZdfSksbygkVnksWzIsMjRdKSxvKCRWOCxbMiwxOF0sezMwOjM0LDMxOjM1LDMyOjM2LDMzOjM3LDM2OjQwLDM3OjQxLDM4OjQyLDM5OjQzLDQyOjQ0LDUwOjQ2LDUyOjU1LDI5OjY3LDI2OiRWZiwzNDokVmcsMzU6JFZoLDQwOiRWaSw0MTokVmosNDg6JFZrLDUxOiRWbCw2MDokVm0sNjQ6JFZuLDY1OiRWbyw2NjokVnAsNjc6JFZxLDY4OiRWciw2OTokVnMsNzM6JFZ0LDc0OiRWdSw3NjokVnYsNzg6JFZ3LDc5OiRWeH0pLG8oJFZ6LFsyLDI2XSksbygkVnosWzIsMjhdKSxvKCRWeixbMiwyOV0pLG8oJFZ6LFsyLDMwXSksbygkVnosWzIsMzFdKSxvKCRWeixbMiwzMl0pLG8oJFZ6LFsyLDMzXSksbygkVnosWzIsMzRdKSxvKCRWeixbMiwzNV0pLG8oJFZ6LFsyLDM2XSksbygkVnosWzIsMzddKSxvKFs0NCw2MCw2NCw2NSw2Niw2Nyw2OCw2OV0sJFZBLHs0Mzo2OCw2MjokVkIsNzA6JFZDLDcxOiRWRCw3MjokVkV9KSx7MzA6NzQsNDI6NDQsNDY6NzMsNTA6NzUsNTE6JFZsLDUyOjU1LDYwOiRWbSw2NDokVm4sNjU6JFZvLDY2OiRWcCw2NzokVnEsNjg6JFZyLDY5OiRWcyw3OTokVnh9LHs0MTokVkYsNDg6WzEsNzZdLDUxOiRWRyw1Mjo4MCw1NDo3Nyw3OTokVnh9LHs1MTokVkgsNTU6ODEsNTc6ODIsNTk6JFZJLDYwOiRWSiw2MTokVkt9LG8oJFZ6LFsyLDM4XSksezQwOlsxLDg3XSw0MTpbMSw4OF19LHs1MTpbMSw4OV19LHsyNTpbMSw5MV0sNzU6OTB9LHs3NzpbMSw5Ml19LHs1MTpbMSw5NF0sNjQ6WzEsOTVdLDc4OlsxLDkzXX0sbygkVkwsWzIsNDldKSxvKCRWTCxbMiw1MF0sezUxOlsxLDk2XX0pLG8oJFZNLFsyLDcxXSksbygkVk0sWzIsNzJdKSxvKCRWTSxbMiw3M10pLG8oJFZNLFsyLDc0XSksbygkVk0sWzIsNzVdKSxvKCRWTSxbMiw3Nl0pLG8oJFZNLFsyLDc3XSksbygkVk4sWzIsOThdLHs4MDo5Nyw3ODpbMSw5OF0sODI6WzEsOTldLDgzOlsxLDEwMF19KSxvKCRWOCxbMiwxOV0pLG8oJFZhLFsyLDIzXSksezI3OlsxLDEwMV19LG8oJFZ6LFsyLDI3XSksezQ0OlsxLDEwMl0sNTA6MTAzLDYwOiRWbSw2NDokVm4sNjU6JFZvLDY2OiRWcCw2NzokVnEsNjg6JFZyLDY5OiRWc30sbygkVk8sWzIsNzhdKSxvKCRWTyxbMiw3OV0pLG8oJFZPLFsyLDgwXSksbygkVk8sWzIsODFdKSx7NDc6JFZQLDQ5OlsxLDEwNF19LG8oJFZRLFsyLDQ1XSksezQxOiRWRiw1MTokVkcsNTI6ODAsNTQ6NzcsNzk6JFZ4fSx7MzA6NzQsNDI6NDQsNDY6MTA2LDUwOjc1LDUxOiRWbCw1Mjo1NSw2MDokVm0sNjQ6JFZuLDY1OiRWbyw2NjokVnAsNjc6JFZxLDY4OiRWciw2OTokVnMsNzk6JFZ4fSxvKCRWTCxbMiw1Ml0pLHs1MTokVkgsNTU6MTA3LDU3OjgyLDU5OiRWSSw2MDokVkosNjE6JFZLfSxvKCRWTCxbMiw1NV0pLG8oJFZMLFsyLDU4XSx7NTE6WzEsMTA4XX0pLG8oJFZ6LCRWUix7NTY6MTA5LDYyOiRWU30pLG8oJFZULFsyLDY4XSx7NTg6MTExLDYzOlsxLDExMl19KSxvKCRWVSxbMiw2Ml0pLG8oJFZVLFsyLDYzXSksbygkVlUsWzIsNjRdKSxvKCRWVSxbMiw2NV0pLHsyNjpbMSwxMTRdLDQwOlsxLDExM10sNDE6WzEsMTE1XX0sezQwOlsxLDExNl0sNDE6WzEsMTE3XX0sezI4OlsxLDExOV0sNzM6WzEsMTE4XX0sezI4OlsxLDEyMV0sNzQ6WzEsMTIwXX0sbygkVlYsWzIsODZdKSx7NzY6WzEsMTIyXX0sbygkVnosWzIsODldKSx7Nzg6WzEsMTIzXX0sezUxOlsxLDEyNF19LHs1MzpbMSwxMjVdfSxvKCRWVyxbMiw5OV0sezgxOjEyNiw4NDpbMSwxMjddfSksbygkVk4sWzIsOTNdLHs3ODpbMSwxMjhdfSksbygkVk4sWzIsOTVdLHs4MjpbMSwxMjldfSksbygkVk4sWzIsOTddKSxvKCRWeSxbMiwyNV0pLHs0NToxMzAsNTE6WzEsMTMxXX0sezQxOiRWRiw1MTokVkcsNTI6ODAsNTQ6MTMyLDc5OiRWeH0sbygkVnosJFZBLHs0MzoxMzMsNjI6JFZCLDcwOiRWQyw3MTokVkQsNzI6JFZFfSksezMwOjEzNCw0Mjo0NCw1MDo3NSw1MTokVmwsNTI6NTUsNjA6JFZtLDY0OiRWbiw2NTokVm8sNjY6JFZwLDY3OiRWcSw2ODokVnIsNjk6JFZzLDc5OiRWeH0sezQ3OiRWUCw0OTpbMSwxMzVdfSx7NDE6JFZSLDU2OjEzNiw2MjokVlN9LHs1MzpbMSwxMzddfSxvKCRWeixbMiw2MF0pLG8oJFZ6LFsyLDY3XSksbygkVlQsWzIsNjFdKSxvKCRWVCxbMiw2OV0pLG8oJFZ6LFsyLDM5XSksbygkVnosWzIsNDBdKSxvKCRWeixbMiw0Ml0pLG8oJFZ6LFsyLDQxXSksbygkVnosWzIsNDNdKSxvKCRWeixbMiw4M10pLHs1MTpbMSwxMzhdfSxvKCRWeixbMiw4NV0pLHsyNTpbMSwxMzldfSxvKCRWeixbMiw4OF0pLG8oJFZ6LFsyLDkwXSksezc4OlsxLDE0MF19LHs1MTpbMSwxNDFdfSxvKCRWVyxbMiw5Ml0pLG8oJFZXLFsyLDEwMF0pLG8oJFZOLFsyLDk0XSksbygkVk4sWzIsOTZdKSxvKCRWWCxbMiw0NF0pLG8oJFZYLFsyLDcwXSksbygkVkwsWzIsNTNdKSxvKCRWeixbMiw0N10pLG8oJFZRLFsyLDQ2XSksbygkVnosJFZBLHs0MzoxNDIsNjI6JFZCLDcwOiRWQyw3MTokVkQsNzI6JFZFfSksezQxOlsxLDE0M119LHs1MTpbMSwxNDRdfSx7NzM6WzEsMTQ1XX0sbygkVlYsWzIsODddKSxvKCRWeixbMiw5MV0pLG8oJFZMLFsyLDUxXSksbygkVnosWzIsNDhdKSx7NTE6WzEsMTQ2XSw1MjoxNDcsNzk6JFZ4fSxvKCRWTCxbMiw1OV0pLG8oJFZ6LFsyLDg0XSksbygkVkwsWzIsNTRdKSxvKCRWTCxbMiw1Nl0sezUxOlsxLDE0OF19KSx7NTM6WzEsMTQ5XX0sezUxOlsxLDE1MF19LG8oJFZMLFsyLDU3XSldLFxuZGVmYXVsdEFjdGlvbnM6IHs3OlsyLDFdfSxcbnBhcnNlRXJyb3I6IGZ1bmN0aW9uIHBhcnNlRXJyb3Ioc3RyLCBoYXNoKSB7XG4gICAgaWYgKGhhc2gucmVjb3ZlcmFibGUpIHtcbiAgICAgICAgdGhpcy50cmFjZShzdHIpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGZ1bmN0aW9uIF9wYXJzZUVycm9yIChtc2csIGhhc2gpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZSA9IG1zZztcbiAgICAgICAgICAgIHRoaXMuaGFzaCA9IGhhc2g7XG4gICAgICAgIH1cbiAgICAgICAgX3BhcnNlRXJyb3IucHJvdG90eXBlID0gbmV3IEVycm9yKCk7XG5cbiAgICAgICAgdGhyb3cgbmV3IF9wYXJzZUVycm9yKHN0ciwgaGFzaCk7XG4gICAgfVxufSxcbnBhcnNlOiBmdW5jdGlvbiBwYXJzZShpbnB1dCkge1xuICAgIHZhciBzZWxmID0gdGhpcywgc3RhY2sgPSBbMF0sIHRzdGFjayA9IFtdLCB2c3RhY2sgPSBbbnVsbF0sIGxzdGFjayA9IFtdLCB0YWJsZSA9IHRoaXMudGFibGUsIHl5dGV4dCA9ICcnLCB5eWxpbmVubyA9IDAsIHl5bGVuZyA9IDAsIHJlY292ZXJpbmcgPSAwLCBURVJST1IgPSAyLCBFT0YgPSAxO1xuICAgIHZhciBhcmdzID0gbHN0YWNrLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgbGV4ZXIgPSBPYmplY3QuY3JlYXRlKHRoaXMubGV4ZXIpO1xuICAgIHZhciBzaGFyZWRTdGF0ZSA9IHsgeXk6IHt9IH07XG4gICAgZm9yICh2YXIgayBpbiB0aGlzLnl5KSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwodGhpcy55eSwgaykpIHtcbiAgICAgICAgICAgIHNoYXJlZFN0YXRlLnl5W2tdID0gdGhpcy55eVtrXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBsZXhlci5zZXRJbnB1dChpbnB1dCwgc2hhcmVkU3RhdGUueXkpO1xuICAgIHNoYXJlZFN0YXRlLnl5LmxleGVyID0gbGV4ZXI7XG4gICAgc2hhcmVkU3RhdGUueXkucGFyc2VyID0gdGhpcztcbiAgICBpZiAodHlwZW9mIGxleGVyLnl5bGxvYyA9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsZXhlci55eWxsb2MgPSB7fTtcbiAgICB9XG4gICAgdmFyIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgIGxzdGFjay5wdXNoKHl5bG9jKTtcbiAgICB2YXIgcmFuZ2VzID0gbGV4ZXIub3B0aW9ucyAmJiBsZXhlci5vcHRpb25zLnJhbmdlcztcbiAgICBpZiAodHlwZW9mIHNoYXJlZFN0YXRlLnl5LnBhcnNlRXJyb3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5wYXJzZUVycm9yID0gc2hhcmVkU3RhdGUueXkucGFyc2VFcnJvcjtcbiAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnBhcnNlRXJyb3IgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykucGFyc2VFcnJvcjtcbiAgICB9XG4gICAgZnVuY3Rpb24gcG9wU3RhY2sobikge1xuICAgICAgICBzdGFjay5sZW5ndGggPSBzdGFjay5sZW5ndGggLSAyICogbjtcbiAgICAgICAgdnN0YWNrLmxlbmd0aCA9IHZzdGFjay5sZW5ndGggLSBuO1xuICAgICAgICBsc3RhY2subGVuZ3RoID0gbHN0YWNrLmxlbmd0aCAtIG47XG4gICAgfVxuICAgIF90b2tlbl9zdGFjazpcbiAgICAgICAgdmFyIGxleCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0b2tlbjtcbiAgICAgICAgICAgIHRva2VuID0gbGV4ZXIubGV4KCkgfHwgRU9GO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0b2tlbiAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICB0b2tlbiA9IHNlbGYuc3ltYm9sc19bdG9rZW5dIHx8IHRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9O1xuICAgIHZhciBzeW1ib2wsIHByZUVycm9yU3ltYm9sLCBzdGF0ZSwgYWN0aW9uLCBhLCByLCB5eXZhbCA9IHt9LCBwLCBsZW4sIG5ld1N0YXRlLCBleHBlY3RlZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBzdGF0ZSA9IHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdO1xuICAgICAgICBpZiAodGhpcy5kZWZhdWx0QWN0aW9uc1tzdGF0ZV0pIHtcbiAgICAgICAgICAgIGFjdGlvbiA9IHRoaXMuZGVmYXVsdEFjdGlvbnNbc3RhdGVdO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN5bWJvbCA9PT0gbnVsbCB8fCB0eXBlb2Ygc3ltYm9sID09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgc3ltYm9sID0gbGV4KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhY3Rpb24gPSB0YWJsZVtzdGF0ZV0gJiYgdGFibGVbc3RhdGVdW3N5bWJvbF07XG4gICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBhY3Rpb24gPT09ICd1bmRlZmluZWQnIHx8ICFhY3Rpb24ubGVuZ3RoIHx8ICFhY3Rpb25bMF0pIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyU3RyID0gJyc7XG4gICAgICAgICAgICAgICAgZXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICBmb3IgKHAgaW4gdGFibGVbc3RhdGVdKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLnRlcm1pbmFsc19bcF0gJiYgcCA+IFRFUlJPUikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZXhwZWN0ZWQucHVzaCgnXFwnJyArIHRoaXMudGVybWluYWxzX1twXSArICdcXCcnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAobGV4ZXIuc2hvd1Bvc2l0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIGVyclN0ciA9ICdQYXJzZSBlcnJvciBvbiBsaW5lICcgKyAoeXlsaW5lbm8gKyAxKSArICc6XFxuJyArIGxleGVyLnNob3dQb3NpdGlvbigpICsgJ1xcbkV4cGVjdGluZyAnICsgZXhwZWN0ZWQuam9pbignLCAnKSArICcsIGdvdCBcXCcnICsgKHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCkgKyAnXFwnJztcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBlcnJTdHIgPSAnUGFyc2UgZXJyb3Igb24gbGluZSAnICsgKHl5bGluZW5vICsgMSkgKyAnOiBVbmV4cGVjdGVkICcgKyAoc3ltYm9sID09IEVPRiA/ICdlbmQgb2YgaW5wdXQnIDogJ1xcJycgKyAodGhpcy50ZXJtaW5hbHNfW3N5bWJvbF0gfHwgc3ltYm9sKSArICdcXCcnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJzZUVycm9yKGVyclN0ciwge1xuICAgICAgICAgICAgICAgICAgICB0ZXh0OiBsZXhlci5tYXRjaCxcbiAgICAgICAgICAgICAgICAgICAgdG9rZW46IHRoaXMudGVybWluYWxzX1tzeW1ib2xdIHx8IHN5bWJvbCxcbiAgICAgICAgICAgICAgICAgICAgbGluZTogbGV4ZXIueXlsaW5lbm8sXG4gICAgICAgICAgICAgICAgICAgIGxvYzogeXlsb2MsXG4gICAgICAgICAgICAgICAgICAgIGV4cGVjdGVkOiBleHBlY3RlZFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICBpZiAoYWN0aW9uWzBdIGluc3RhbmNlb2YgQXJyYXkgJiYgYWN0aW9uLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGFyc2UgRXJyb3I6IG11bHRpcGxlIGFjdGlvbnMgcG9zc2libGUgYXQgc3RhdGU6ICcgKyBzdGF0ZSArICcsIHRva2VuOiAnICsgc3ltYm9sKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKGFjdGlvblswXSkge1xuICAgICAgICBjYXNlIDE6XG4gICAgICAgICAgICBzdGFjay5wdXNoKHN5bWJvbCk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaChsZXhlci55eXRleHQpO1xuICAgICAgICAgICAgbHN0YWNrLnB1c2gobGV4ZXIueXlsbG9jKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goYWN0aW9uWzFdKTtcbiAgICAgICAgICAgIHN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICBpZiAoIXByZUVycm9yU3ltYm9sKSB7XG4gICAgICAgICAgICAgICAgeXlsZW5nID0gbGV4ZXIueXlsZW5nO1xuICAgICAgICAgICAgICAgIHl5dGV4dCA9IGxleGVyLnl5dGV4dDtcbiAgICAgICAgICAgICAgICB5eWxpbmVubyA9IGxleGVyLnl5bGluZW5vO1xuICAgICAgICAgICAgICAgIHl5bG9jID0gbGV4ZXIueXlsbG9jO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvdmVyaW5nID4gMCkge1xuICAgICAgICAgICAgICAgICAgICByZWNvdmVyaW5nLS07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICBzeW1ib2wgPSBwcmVFcnJvclN5bWJvbDtcbiAgICAgICAgICAgICAgICBwcmVFcnJvclN5bWJvbCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgbGVuID0gdGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVsxXTtcbiAgICAgICAgICAgIHl5dmFsLiQgPSB2c3RhY2tbdnN0YWNrLmxlbmd0aCAtIGxlbl07XG4gICAgICAgICAgICB5eXZhbC5fJCA9IHtcbiAgICAgICAgICAgICAgICBmaXJzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICAgICAgbGFzdF9saW5lOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICBmaXJzdF9jb2x1bW46IGxzdGFja1tsc3RhY2subGVuZ3RoIC0gKGxlbiB8fCAxKV0uZmlyc3RfY29sdW1uLFxuICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLmxhc3RfY29sdW1uXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgaWYgKHJhbmdlcykge1xuICAgICAgICAgICAgICAgIHl5dmFsLl8kLnJhbmdlID0gW1xuICAgICAgICAgICAgICAgICAgICBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIChsZW4gfHwgMSldLnJhbmdlWzBdLFxuICAgICAgICAgICAgICAgICAgICBsc3RhY2tbbHN0YWNrLmxlbmd0aCAtIDFdLnJhbmdlWzFdXG4gICAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHIgPSB0aGlzLnBlcmZvcm1BY3Rpb24uYXBwbHkoeXl2YWwsIFtcbiAgICAgICAgICAgICAgICB5eXRleHQsXG4gICAgICAgICAgICAgICAgeXlsZW5nLFxuICAgICAgICAgICAgICAgIHl5bGluZW5vLFxuICAgICAgICAgICAgICAgIHNoYXJlZFN0YXRlLnl5LFxuICAgICAgICAgICAgICAgIGFjdGlvblsxXSxcbiAgICAgICAgICAgICAgICB2c3RhY2ssXG4gICAgICAgICAgICAgICAgbHN0YWNrXG4gICAgICAgICAgICBdLmNvbmNhdChhcmdzKSk7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHIgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobGVuKSB7XG4gICAgICAgICAgICAgICAgc3RhY2sgPSBzdGFjay5zbGljZSgwLCAtMSAqIGxlbiAqIDIpO1xuICAgICAgICAgICAgICAgIHZzdGFjayA9IHZzdGFjay5zbGljZSgwLCAtMSAqIGxlbik7XG4gICAgICAgICAgICAgICAgbHN0YWNrID0gbHN0YWNrLnNsaWNlKDAsIC0xICogbGVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0YWNrLnB1c2godGhpcy5wcm9kdWN0aW9uc19bYWN0aW9uWzFdXVswXSk7XG4gICAgICAgICAgICB2c3RhY2sucHVzaCh5eXZhbC4kKTtcbiAgICAgICAgICAgIGxzdGFjay5wdXNoKHl5dmFsLl8kKTtcbiAgICAgICAgICAgIG5ld1N0YXRlID0gdGFibGVbc3RhY2tbc3RhY2subGVuZ3RoIC0gMl1dW3N0YWNrW3N0YWNrLmxlbmd0aCAtIDFdXTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2gobmV3U3RhdGUpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgMzpcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xufX07XG5cbiAgdmFyIF8gPSByZXF1aXJlKFwibG9kYXNoXCIpO1xuLyogZ2VuZXJhdGVkIGJ5IGppc29uLWxleCAwLjMuNCAqL1xudmFyIGxleGVyID0gKGZ1bmN0aW9uKCl7XG52YXIgbGV4ZXIgPSAoe1xuXG5FT0Y6MSxcblxucGFyc2VFcnJvcjpmdW5jdGlvbiBwYXJzZUVycm9yKHN0ciwgaGFzaCkge1xuICAgICAgICBpZiAodGhpcy55eS5wYXJzZXIpIHtcbiAgICAgICAgICAgIHRoaXMueXkucGFyc2VyLnBhcnNlRXJyb3Ioc3RyLCBoYXNoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihzdHIpO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcmVzZXRzIHRoZSBsZXhlciwgc2V0cyBuZXcgaW5wdXRcbnNldElucHV0OmZ1bmN0aW9uIChpbnB1dCwgeXkpIHtcbiAgICAgICAgdGhpcy55eSA9IHl5IHx8IHRoaXMueXkgfHwge307XG4gICAgICAgIHRoaXMuX2lucHV0ID0gaW5wdXQ7XG4gICAgICAgIHRoaXMuX21vcmUgPSB0aGlzLl9iYWNrdHJhY2sgPSB0aGlzLmRvbmUgPSBmYWxzZTtcbiAgICAgICAgdGhpcy55eWxpbmVubyA9IHRoaXMueXlsZW5nID0gMDtcbiAgICAgICAgdGhpcy55eXRleHQgPSB0aGlzLm1hdGNoZWQgPSB0aGlzLm1hdGNoID0gJyc7XG4gICAgICAgIHRoaXMuY29uZGl0aW9uU3RhY2sgPSBbJ0lOSVRJQUwnXTtcbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiAwLFxuICAgICAgICAgICAgbGFzdF9saW5lOiAxLFxuICAgICAgICAgICAgbGFzdF9jb2x1bW46IDBcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5yYW5nZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLnJhbmdlID0gWzAsMF07XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vZmZzZXQgPSAwO1xuICAgICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuXG4vLyBjb25zdW1lcyBhbmQgcmV0dXJucyBvbmUgY2hhciBmcm9tIHRoZSBpbnB1dFxuaW5wdXQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgY2ggPSB0aGlzLl9pbnB1dFswXTtcbiAgICAgICAgdGhpcy55eXRleHQgKz0gY2g7XG4gICAgICAgIHRoaXMueXlsZW5nKys7XG4gICAgICAgIHRoaXMub2Zmc2V0Kys7XG4gICAgICAgIHRoaXMubWF0Y2ggKz0gY2g7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBjaDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2gubWF0Y2goLyg/Olxcclxcbj98XFxuKS4qL2cpO1xuICAgICAgICBpZiAobGluZXMpIHtcbiAgICAgICAgICAgIHRoaXMueXlsaW5lbm8rKztcbiAgICAgICAgICAgIHRoaXMueXlsbG9jLmxhc3RfbGluZSsrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MubGFzdF9jb2x1bW4rKztcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2VbMV0rKztcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMuX2lucHV0ID0gdGhpcy5faW5wdXQuc2xpY2UoMSk7XG4gICAgICAgIHJldHVybiBjaDtcbiAgICB9LFxuXG4vLyB1bnNoaWZ0cyBvbmUgY2hhciAob3IgYSBzdHJpbmcpIGludG8gdGhlIGlucHV0XG51bnB1dDpmdW5jdGlvbiAoY2gpIHtcbiAgICAgICAgdmFyIGxlbiA9IGNoLmxlbmd0aDtcbiAgICAgICAgdmFyIGxpbmVzID0gY2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcblxuICAgICAgICB0aGlzLl9pbnB1dCA9IGNoICsgdGhpcy5faW5wdXQ7XG4gICAgICAgIHRoaXMueXl0ZXh0ID0gdGhpcy55eXRleHQuc3Vic3RyKDAsIHRoaXMueXl0ZXh0Lmxlbmd0aCAtIGxlbik7XG4gICAgICAgIC8vdGhpcy55eWxlbmcgLT0gbGVuO1xuICAgICAgICB0aGlzLm9mZnNldCAtPSBsZW47XG4gICAgICAgIHZhciBvbGRMaW5lcyA9IHRoaXMubWF0Y2guc3BsaXQoLyg/Olxcclxcbj98XFxuKS9nKTtcbiAgICAgICAgdGhpcy5tYXRjaCA9IHRoaXMubWF0Y2guc3Vic3RyKDAsIHRoaXMubWF0Y2gubGVuZ3RoIC0gMSk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCA9IHRoaXMubWF0Y2hlZC5zdWJzdHIoMCwgdGhpcy5tYXRjaGVkLmxlbmd0aCAtIDEpO1xuXG4gICAgICAgIGlmIChsaW5lcy5sZW5ndGggLSAxKSB7XG4gICAgICAgICAgICB0aGlzLnl5bGluZW5vIC09IGxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHIgPSB0aGlzLnl5bGxvYy5yYW5nZTtcblxuICAgICAgICB0aGlzLnl5bGxvYyA9IHtcbiAgICAgICAgICAgIGZpcnN0X2xpbmU6IHRoaXMueXlsbG9jLmZpcnN0X2xpbmUsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICBsYXN0X2NvbHVtbjogbGluZXMgP1xuICAgICAgICAgICAgICAgIChsaW5lcy5sZW5ndGggPT09IG9sZExpbmVzLmxlbmd0aCA/IHRoaXMueXlsbG9jLmZpcnN0X2NvbHVtbiA6IDApXG4gICAgICAgICAgICAgICAgICsgb2xkTGluZXNbb2xkTGluZXMubGVuZ3RoIC0gbGluZXMubGVuZ3RoXS5sZW5ndGggLSBsaW5lc1swXS5sZW5ndGggOlxuICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4gLSBsZW5cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbclswXSwgclswXSArIHRoaXMueXlsZW5nIC0gbGVuXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnl5bGVuZyA9IHRoaXMueXl0ZXh0Lmxlbmd0aDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIGNhY2hlcyBtYXRjaGVkIHRleHQgYW5kIGFwcGVuZHMgaXQgb24gbmV4dCBhY3Rpb25cbm1vcmU6ZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLl9tb3JlID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfSxcblxuLy8gV2hlbiBjYWxsZWQgZnJvbSBhY3Rpb24sIHNpZ25hbHMgdGhlIGxleGVyIHRoYXQgdGhpcyBydWxlIGZhaWxzIHRvIG1hdGNoIHRoZSBpbnB1dCwgc28gdGhlIG5leHQgbWF0Y2hpbmcgcnVsZSAocmVnZXgpIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbnJlamVjdDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICB0aGlzLl9iYWNrdHJhY2sgPSB0cnVlO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyc2VFcnJvcignTGV4aWNhbCBlcnJvciBvbiBsaW5lICcgKyAodGhpcy55eWxpbmVubyArIDEpICsgJy4gWW91IGNhbiBvbmx5IGludm9rZSByZWplY3QoKSBpbiB0aGUgbGV4ZXIgd2hlbiB0aGUgbGV4ZXIgaXMgb2YgdGhlIGJhY2t0cmFja2luZyBwZXJzdWFzaW9uIChvcHRpb25zLmJhY2t0cmFja19sZXhlciA9IHRydWUpLlxcbicgKyB0aGlzLnNob3dQb3NpdGlvbigpLCB7XG4gICAgICAgICAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgICAgICAgICB0b2tlbjogbnVsbCxcbiAgICAgICAgICAgICAgICBsaW5lOiB0aGlzLnl5bGluZW5vXG4gICAgICAgICAgICB9KTtcblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG5cbi8vIHJldGFpbiBmaXJzdCBuIGNoYXJhY3RlcnMgb2YgdGhlIG1hdGNoXG5sZXNzOmZ1bmN0aW9uIChuKSB7XG4gICAgICAgIHRoaXMudW5wdXQodGhpcy5tYXRjaC5zbGljZShuKSk7XG4gICAgfSxcblxuLy8gZGlzcGxheXMgYWxyZWFkeSBtYXRjaGVkIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xucGFzdElucHV0OmZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHBhc3QgPSB0aGlzLm1hdGNoZWQuc3Vic3RyKDAsIHRoaXMubWF0Y2hlZC5sZW5ndGggLSB0aGlzLm1hdGNoLmxlbmd0aCk7XG4gICAgICAgIHJldHVybiAocGFzdC5sZW5ndGggPiAyMCA/ICcuLi4nOicnKSArIHBhc3Quc3Vic3RyKC0yMCkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIHVwY29taW5nIGlucHV0LCBpLmUuIGZvciBlcnJvciBtZXNzYWdlc1xudXBjb21pbmdJbnB1dDpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBuZXh0ID0gdGhpcy5tYXRjaDtcbiAgICAgICAgaWYgKG5leHQubGVuZ3RoIDwgMjApIHtcbiAgICAgICAgICAgIG5leHQgKz0gdGhpcy5faW5wdXQuc3Vic3RyKDAsIDIwLW5leHQubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gKG5leHQuc3Vic3RyKDAsMjApICsgKG5leHQubGVuZ3RoID4gMjAgPyAnLi4uJyA6ICcnKSkucmVwbGFjZSgvXFxuL2csIFwiXCIpO1xuICAgIH0sXG5cbi8vIGRpc3BsYXlzIHRoZSBjaGFyYWN0ZXIgcG9zaXRpb24gd2hlcmUgdGhlIGxleGluZyBlcnJvciBvY2N1cnJlZCwgaS5lLiBmb3IgZXJyb3IgbWVzc2FnZXNcbnNob3dQb3NpdGlvbjpmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBwcmUgPSB0aGlzLnBhc3RJbnB1dCgpO1xuICAgICAgICB2YXIgYyA9IG5ldyBBcnJheShwcmUubGVuZ3RoICsgMSkuam9pbihcIi1cIik7XG4gICAgICAgIHJldHVybiBwcmUgKyB0aGlzLnVwY29taW5nSW5wdXQoKSArIFwiXFxuXCIgKyBjICsgXCJeXCI7XG4gICAgfSxcblxuLy8gdGVzdCB0aGUgbGV4ZWQgdG9rZW46IHJldHVybiBGQUxTRSB3aGVuIG5vdCBhIG1hdGNoLCBvdGhlcndpc2UgcmV0dXJuIHRva2VuXG50ZXN0X21hdGNoOmZ1bmN0aW9uIChtYXRjaCwgaW5kZXhlZF9ydWxlKSB7XG4gICAgICAgIHZhciB0b2tlbixcbiAgICAgICAgICAgIGxpbmVzLFxuICAgICAgICAgICAgYmFja3VwO1xuXG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICAvLyBzYXZlIGNvbnRleHRcbiAgICAgICAgICAgIGJhY2t1cCA9IHtcbiAgICAgICAgICAgICAgICB5eWxpbmVubzogdGhpcy55eWxpbmVubyxcbiAgICAgICAgICAgICAgICB5eWxsb2M6IHtcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfbGluZTogdGhpcy55eWxsb2MuZmlyc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgbGFzdF9saW5lOiB0aGlzLmxhc3RfbGluZSxcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5maXJzdF9jb2x1bW4sXG4gICAgICAgICAgICAgICAgICAgIGxhc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtblxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgeXl0ZXh0OiB0aGlzLnl5dGV4dCxcbiAgICAgICAgICAgICAgICBtYXRjaDogdGhpcy5tYXRjaCxcbiAgICAgICAgICAgICAgICBtYXRjaGVzOiB0aGlzLm1hdGNoZXMsXG4gICAgICAgICAgICAgICAgbWF0Y2hlZDogdGhpcy5tYXRjaGVkLFxuICAgICAgICAgICAgICAgIHl5bGVuZzogdGhpcy55eWxlbmcsXG4gICAgICAgICAgICAgICAgb2Zmc2V0OiB0aGlzLm9mZnNldCxcbiAgICAgICAgICAgICAgICBfbW9yZTogdGhpcy5fbW9yZSxcbiAgICAgICAgICAgICAgICBfaW5wdXQ6IHRoaXMuX2lucHV0LFxuICAgICAgICAgICAgICAgIHl5OiB0aGlzLnl5LFxuICAgICAgICAgICAgICAgIGNvbmRpdGlvblN0YWNrOiB0aGlzLmNvbmRpdGlvblN0YWNrLnNsaWNlKDApLFxuICAgICAgICAgICAgICAgIGRvbmU6IHRoaXMuZG9uZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucmFuZ2VzKSB7XG4gICAgICAgICAgICAgICAgYmFja3VwLnl5bGxvYy5yYW5nZSA9IHRoaXMueXlsbG9jLnJhbmdlLnNsaWNlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgbGluZXMgPSBtYXRjaFswXS5tYXRjaCgvKD86XFxyXFxuP3xcXG4pLiovZyk7XG4gICAgICAgIGlmIChsaW5lcykge1xuICAgICAgICAgICAgdGhpcy55eWxpbmVubyArPSBsaW5lcy5sZW5ndGg7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy55eWxsb2MgPSB7XG4gICAgICAgICAgICBmaXJzdF9saW5lOiB0aGlzLnl5bGxvYy5sYXN0X2xpbmUsXG4gICAgICAgICAgICBsYXN0X2xpbmU6IHRoaXMueXlsaW5lbm8gKyAxLFxuICAgICAgICAgICAgZmlyc3RfY29sdW1uOiB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbixcbiAgICAgICAgICAgIGxhc3RfY29sdW1uOiBsaW5lcyA/XG4gICAgICAgICAgICAgICAgICAgICAgICAgbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubGVuZ3RoIC0gbGluZXNbbGluZXMubGVuZ3RoIC0gMV0ubWF0Y2goL1xccj9cXG4/LylbMF0ubGVuZ3RoIDpcbiAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnl5bGxvYy5sYXN0X2NvbHVtbiArIG1hdGNoWzBdLmxlbmd0aFxuICAgICAgICB9O1xuICAgICAgICB0aGlzLnl5dGV4dCArPSBtYXRjaFswXTtcbiAgICAgICAgdGhpcy5tYXRjaCArPSBtYXRjaFswXTtcbiAgICAgICAgdGhpcy5tYXRjaGVzID0gbWF0Y2g7XG4gICAgICAgIHRoaXMueXlsZW5nID0gdGhpcy55eXRleHQubGVuZ3RoO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLnJhbmdlcykge1xuICAgICAgICAgICAgdGhpcy55eWxsb2MucmFuZ2UgPSBbdGhpcy5vZmZzZXQsIHRoaXMub2Zmc2V0ICs9IHRoaXMueXlsZW5nXTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9tb3JlID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX2JhY2t0cmFjayA9IGZhbHNlO1xuICAgICAgICB0aGlzLl9pbnB1dCA9IHRoaXMuX2lucHV0LnNsaWNlKG1hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgIHRoaXMubWF0Y2hlZCArPSBtYXRjaFswXTtcbiAgICAgICAgdG9rZW4gPSB0aGlzLnBlcmZvcm1BY3Rpb24uY2FsbCh0aGlzLCB0aGlzLnl5LCB0aGlzLCBpbmRleGVkX3J1bGUsIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSk7XG4gICAgICAgIGlmICh0aGlzLmRvbmUgJiYgdGhpcy5faW5wdXQpIHtcbiAgICAgICAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0b2tlbikge1xuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2JhY2t0cmFjaykge1xuICAgICAgICAgICAgLy8gcmVjb3ZlciBjb250ZXh0XG4gICAgICAgICAgICBmb3IgKHZhciBrIGluIGJhY2t1cCkge1xuICAgICAgICAgICAgICAgIHRoaXNba10gPSBiYWNrdXBba107XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7IC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyB0aGUgbmV4dCBydWxlIHNob3VsZCBiZSB0ZXN0ZWQgaW5zdGVhZC5cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSxcblxuLy8gcmV0dXJuIG5leHQgbWF0Y2ggaW4gaW5wdXRcbm5leHQ6ZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5kb25lKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF0aGlzLl9pbnB1dCkge1xuICAgICAgICAgICAgdGhpcy5kb25lID0gdHJ1ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHZhciB0b2tlbixcbiAgICAgICAgICAgIG1hdGNoLFxuICAgICAgICAgICAgdGVtcE1hdGNoLFxuICAgICAgICAgICAgaW5kZXg7XG4gICAgICAgIGlmICghdGhpcy5fbW9yZSkge1xuICAgICAgICAgICAgdGhpcy55eXRleHQgPSAnJztcbiAgICAgICAgICAgIHRoaXMubWF0Y2ggPSAnJztcbiAgICAgICAgfVxuICAgICAgICB2YXIgcnVsZXMgPSB0aGlzLl9jdXJyZW50UnVsZXMoKTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBydWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgdGVtcE1hdGNoID0gdGhpcy5faW5wdXQubWF0Y2godGhpcy5ydWxlc1tydWxlc1tpXV0pO1xuICAgICAgICAgICAgaWYgKHRlbXBNYXRjaCAmJiAoIW1hdGNoIHx8IHRlbXBNYXRjaFswXS5sZW5ndGggPiBtYXRjaFswXS5sZW5ndGgpKSB7XG4gICAgICAgICAgICAgICAgbWF0Y2ggPSB0ZW1wTWF0Y2g7XG4gICAgICAgICAgICAgICAgaW5kZXggPSBpO1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuYmFja3RyYWNrX2xleGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRva2VuID0gdGhpcy50ZXN0X21hdGNoKHRlbXBNYXRjaCwgcnVsZXNbaV0pO1xuICAgICAgICAgICAgICAgICAgICBpZiAodG9rZW4gIT09IGZhbHNlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAodGhpcy5fYmFja3RyYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7IC8vIHJ1bGUgYWN0aW9uIGNhbGxlZCByZWplY3QoKSBpbXBseWluZyBhIHJ1bGUgTUlTbWF0Y2guXG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKCF0aGlzLm9wdGlvbnMuZmxleCkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICB0b2tlbiA9IHRoaXMudGVzdF9tYXRjaChtYXRjaCwgcnVsZXNbaW5kZXhdKTtcbiAgICAgICAgICAgIGlmICh0b2tlbiAhPT0gZmFsc2UpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdG9rZW47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBlbHNlOiB0aGlzIGlzIGEgbGV4ZXIgcnVsZSB3aGljaCBjb25zdW1lcyBpbnB1dCB3aXRob3V0IHByb2R1Y2luZyBhIHRva2VuIChlLmcuIHdoaXRlc3BhY2UpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2lucHV0ID09PSBcIlwiKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5FT0Y7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJzZUVycm9yKCdMZXhpY2FsIGVycm9yIG9uIGxpbmUgJyArICh0aGlzLnl5bGluZW5vICsgMSkgKyAnLiBVbnJlY29nbml6ZWQgdGV4dC5cXG4nICsgdGhpcy5zaG93UG9zaXRpb24oKSwge1xuICAgICAgICAgICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgdG9rZW46IG51bGwsXG4gICAgICAgICAgICAgICAgbGluZTogdGhpcy55eWxpbmVub1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXR1cm4gbmV4dCBtYXRjaCB0aGF0IGhhcyBhIHRva2VuXG5sZXg6ZnVuY3Rpb24gbGV4KCkge1xuICAgICAgICB2YXIgciA9IHRoaXMubmV4dCgpO1xuICAgICAgICBpZiAocikge1xuICAgICAgICAgICAgcmV0dXJuIHI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5sZXgoKTtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIGFjdGl2YXRlcyBhIG5ldyBsZXhlciBjb25kaXRpb24gc3RhdGUgKHB1c2hlcyB0aGUgbmV3IGxleGVyIGNvbmRpdGlvbiBzdGF0ZSBvbnRvIHRoZSBjb25kaXRpb24gc3RhY2spXG5iZWdpbjpmdW5jdGlvbiBiZWdpbihjb25kaXRpb24pIHtcbiAgICAgICAgdGhpcy5jb25kaXRpb25TdGFjay5wdXNoKGNvbmRpdGlvbik7XG4gICAgfSxcblxuLy8gcG9wIHRoZSBwcmV2aW91c2x5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGUgb2ZmIHRoZSBjb25kaXRpb24gc3RhY2tcbnBvcFN0YXRlOmZ1bmN0aW9uIHBvcFN0YXRlKCkge1xuICAgICAgICB2YXIgbiA9IHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMTtcbiAgICAgICAgaWYgKG4gPiAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5wb3AoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmNvbmRpdGlvblN0YWNrWzBdO1xuICAgICAgICB9XG4gICAgfSxcblxuLy8gcHJvZHVjZSB0aGUgbGV4ZXIgcnVsZSBzZXQgd2hpY2ggaXMgYWN0aXZlIGZvciB0aGUgY3VycmVudGx5IGFjdGl2ZSBsZXhlciBjb25kaXRpb24gc3RhdGVcbl9jdXJyZW50UnVsZXM6ZnVuY3Rpb24gX2N1cnJlbnRSdWxlcygpIHtcbiAgICAgICAgaWYgKHRoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoICYmIHRoaXMuY29uZGl0aW9uU3RhY2tbdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGggLSAxXSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1t0aGlzLmNvbmRpdGlvblN0YWNrW3RoaXMuY29uZGl0aW9uU3RhY2subGVuZ3RoIC0gMV1dLnJ1bGVzO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY29uZGl0aW9uc1tcIklOSVRJQUxcIl0ucnVsZXM7XG4gICAgICAgIH1cbiAgICB9LFxuXG4vLyByZXR1cm4gdGhlIGN1cnJlbnRseSBhY3RpdmUgbGV4ZXIgY29uZGl0aW9uIHN0YXRlOyB3aGVuIGFuIGluZGV4IGFyZ3VtZW50IGlzIHByb3ZpZGVkIGl0IHByb2R1Y2VzIHRoZSBOLXRoIHByZXZpb3VzIGNvbmRpdGlvbiBzdGF0ZSwgaWYgYXZhaWxhYmxlXG50b3BTdGF0ZTpmdW5jdGlvbiB0b3BTdGF0ZShuKSB7XG4gICAgICAgIG4gPSB0aGlzLmNvbmRpdGlvblN0YWNrLmxlbmd0aCAtIDEgLSBNYXRoLmFicyhuIHx8IDApO1xuICAgICAgICBpZiAobiA+PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFja1tuXTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBcIklOSVRJQUxcIjtcbiAgICAgICAgfVxuICAgIH0sXG5cbi8vIGFsaWFzIGZvciBiZWdpbihjb25kaXRpb24pXG5wdXNoU3RhdGU6ZnVuY3Rpb24gcHVzaFN0YXRlKGNvbmRpdGlvbikge1xuICAgICAgICB0aGlzLmJlZ2luKGNvbmRpdGlvbik7XG4gICAgfSxcblxuLy8gcmV0dXJuIHRoZSBudW1iZXIgb2Ygc3RhdGVzIGN1cnJlbnRseSBvbiB0aGUgc3RhY2tcbnN0YXRlU3RhY2tTaXplOmZ1bmN0aW9uIHN0YXRlU3RhY2tTaXplKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25kaXRpb25TdGFjay5sZW5ndGg7XG4gICAgfSxcbm9wdGlvbnM6IHt9LFxucGVyZm9ybUFjdGlvbjogZnVuY3Rpb24gYW5vbnltb3VzKHl5LHl5XywkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zLFlZX1NUQVJUKSB7XG52YXIgWVlTVEFURT1ZWV9TVEFSVDtcbnN3aXRjaCgkYXZvaWRpbmdfbmFtZV9jb2xsaXNpb25zKSB7XG5jYXNlIDA6IHRoaXMuYmVnaW4oJ25vdGVzJyk7IHJldHVybiAyMjsgXG5icmVhaztcbmNhc2UgMTogdGhpcy5iZWdpbignc3RhdmVncm91cCcpOyByZXR1cm4gODsgXG5icmVhaztcbmNhc2UgMjogdGhpcy5iZWdpbignb3B0aW9ucycpOyByZXR1cm4gMTA7IFxuYnJlYWs7XG5jYXNlIDM6IHRoaXMuYmVnaW4oJ3RleHQnKTsgcmV0dXJuIDIwOyBcbmJyZWFrO1xuY2FzZSA0OiB0aGlzLmJlZ2luKCdvcHRpb25zJyk7IHJldHVybiAyNDsgXG5icmVhaztcbmNhc2UgNTogdGhpcy5iZWdpbignb3B0aW9ucycpOyByZXR1cm4gMTY7IFxuYnJlYWs7XG5jYXNlIDY6IHRoaXMuYmVnaW4oJ29wdGlvbnMnKTsgcmV0dXJuIDE3OyBcbmJyZWFrO1xuY2FzZSA3OiB0aGlzLmJlZ2luKCdvcHRpb25zJyk7IHJldHVybiAxODsgXG5icmVhaztcbmNhc2UgODpyZXR1cm4gMjVcbmJyZWFrO1xuY2FzZSA5OiB0aGlzLmJlZ2luKCdhbm5vdGF0aW9ucycpOyByZXR1cm4gXCIkXCIgO1xuYnJlYWs7XG5jYXNlIDEwOiB0aGlzLmJlZ2luKCdub3RlcycpOyByZXR1cm4gXCIkXCIgXG5icmVhaztcbmNhc2UgMTE6cmV0dXJuIDI1XG5icmVhaztcbmNhc2UgMTI6IHRoaXMuYmVnaW4oJ2NvbW1hbmQnKTsgcmV0dXJuIFwiIVwiIFxuYnJlYWs7XG5jYXNlIDEzOiB0aGlzLmJlZ2luKCdub3RlcycpOyByZXR1cm4gXCIhXCIgXG5icmVhaztcbmNhc2UgMTQ6cmV0dXJuIDc3XG5icmVhaztcbmNhc2UgMTU6cmV0dXJuIDI3XG5icmVhaztcbmNhc2UgMTY6cmV0dXJuIDQ0XG5icmVhaztcbmNhc2UgMTc6cmV0dXJuICcrJ1xuYnJlYWs7XG5jYXNlIDE4OnJldHVybiA0MVxuYnJlYWs7XG5jYXNlIDE5OnJldHVybiAyNlxuYnJlYWs7XG5jYXNlIDIwOnJldHVybiA0OFxuYnJlYWs7XG5jYXNlIDIxOnJldHVybiA0OVxuYnJlYWs7XG5jYXNlIDIyOnJldHVybiAzNFxuYnJlYWs7XG5jYXNlIDIzOnJldHVybiAzNVxuYnJlYWs7XG5jYXNlIDI0OnJldHVybiA3M1xuYnJlYWs7XG5jYXNlIDI1OnJldHVybiAyOFxuYnJlYWs7XG5jYXNlIDI2OnJldHVybiA0MFxuYnJlYWs7XG5jYXNlIDI3OnJldHVybiA0N1xuYnJlYWs7XG5jYXNlIDI4OnJldHVybiA3OFxuYnJlYWs7XG5jYXNlIDI5OnJldHVybiA4MlxuYnJlYWs7XG5jYXNlIDMwOnJldHVybiA2OFxuYnJlYWs7XG5jYXNlIDMxOnJldHVybiA2NVxuYnJlYWs7XG5jYXNlIDMyOnJldHVybiA2MFxuYnJlYWs7XG5jYXNlIDMzOnJldHVybiA2OVxuYnJlYWs7XG5jYXNlIDM0OnJldHVybiA2NlxuYnJlYWs7XG5jYXNlIDM1OnJldHVybiA2N1xuYnJlYWs7XG5jYXNlIDM2OnJldHVybiA2NFxuYnJlYWs7XG5jYXNlIDM3OnJldHVybiA1M1xuYnJlYWs7XG5jYXNlIDM4OnJldHVybiA3MFxuYnJlYWs7XG5jYXNlIDM5OnJldHVybiA3MVxuYnJlYWs7XG5jYXNlIDQwOnJldHVybiA3MlxuYnJlYWs7XG5jYXNlIDQxOnJldHVybiA2MlxuYnJlYWs7XG5jYXNlIDQyOnJldHVybiA1MVxuYnJlYWs7XG5jYXNlIDQzOnJldHVybiA2MVxuYnJlYWs7XG5jYXNlIDQ0OnJldHVybiA1OVxuYnJlYWs7XG5jYXNlIDQ1OnJldHVybiA2MFxuYnJlYWs7XG5jYXNlIDQ2OnJldHVybiA2MlxuYnJlYWs7XG5jYXNlIDQ3OnJldHVybiA2M1xuYnJlYWs7XG5jYXNlIDQ4OnJldHVybiA3OVxuYnJlYWs7XG5jYXNlIDQ5OnJldHVybiA4M1xuYnJlYWs7XG5jYXNlIDUwOnJldHVybiA4NFxuYnJlYWs7XG5jYXNlIDUxOiB0aGlzLmJlZ2luKCdJTklUSUFMJyk7IFxuYnJlYWs7XG5jYXNlIDUyOi8qIHNraXAgd2hpdGVzcGFjZSAqL1xuYnJlYWs7XG5jYXNlIDUzOnJldHVybiA1XG5icmVhaztcbmNhc2UgNTQ6cmV0dXJuICdJTlZBTElEJ1xuYnJlYWs7XG59XG59LFxucnVsZXM6IFsvXig/Om5vdGVzXFxiKS8sL14oPzpzdGF2ZWdyb3VwXFxiKS8sL14oPzpvcHRpb25zXFxiKS8sL14oPzp0ZXh0XFxiKS8sL14oPzpzbHVyXFxiKS8sL14oPzp0YWJzdGF2ZVxcYikvLC9eKD86c3RhdmVcXGIpLywvXig/OnZvaWNlXFxiKS8sL14oPzpbXlxccz1dKykvLC9eKD86WyRdKS8sL14oPzpbJF0pLywvXig/OlteLCRdKykvLC9eKD86WyFdKS8sL14oPzpbIV0pLywvXig/OlteIV0rKS8sL14oPzpbXixcXHJcXG5dKykvLC9eKD86XFwvKS8sL14oPzpcXCspLywvXig/OjopLywvXig/Oj0pLywvXig/OlxcKCkvLC9eKD86XFwpKS8sL14oPzpcXFspLywvXig/OlxcXSkvLC9eKD86XFxeKS8sL14oPzosKS8sL14oPzpcXHwpLywvXig/OlxcLikvLC9eKD86IykvLC9eKD86QCkvLC9eKD86W2JdKS8sL14oPzpbc10pLywvXig/OltoXSkvLC9eKD86W3BdKS8sL14oPzpbdF0pLywvXig/OltUXSkvLC9eKD86Wy1dKS8sL14oPzpbX10pLywvXig/Olt2XSkvLC9eKD86W1ZdKS8sL14oPzpbdV0pLywvXig/OltkXSkvLC9eKD86WzAtOV0rKS8sL14oPzpbcV0pLywvXig/Olt3XSkvLC9eKD86W2hdKS8sL14oPzpbZF0pLywvXig/OltTXSkvLC9eKD86W0EtR1hMUl0pLywvXig/OltuXSkvLC9eKD86W35dKS8sL14oPzpbXFxyXFxuXSspLywvXig/OlxccyspLywvXig/OiQpLywvXig/Oi4pL10sXG5jb25kaXRpb25zOiB7XCJub3Rlc1wiOntcInJ1bGVzXCI6WzksMTIsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksMzAsMzEsMzIsMzMsMzQsMzUsMzYsMzcsMzgsMzksNDAsNDEsNDIsNDMsNDQsNDUsNDYsNDcsNDgsNDksNTAsNTEsNTIsNTMsNTRdLFwiaW5jbHVzaXZlXCI6dHJ1ZX0sXCJ0ZXh0XCI6e1wicnVsZXNcIjpbMTUsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksNDIsNDMsNDQsNDUsNDYsNTEsNTIsNTMsNTRdLFwiaW5jbHVzaXZlXCI6dHJ1ZX0sXCJzbHVyXCI6e1wicnVsZXNcIjpbMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksNTEsNTIsNTMsNTRdLFwiaW5jbHVzaXZlXCI6dHJ1ZX0sXCJhbm5vdGF0aW9uc1wiOntcInJ1bGVzXCI6WzEwLDExLDE2LDE3LDE4LDE5LDIwLDIxLDIyLDIzLDI0LDI1LDI2LDI3LDI4LDI5LDUxLDUyLDUzLDU0XSxcImluY2x1c2l2ZVwiOnRydWV9LFwib3B0aW9uc1wiOntcInJ1bGVzXCI6WzgsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksNTEsNTIsNTMsNTRdLFwiaW5jbHVzaXZlXCI6dHJ1ZX0sXCJjb21tYW5kXCI6e1wicnVsZXNcIjpbMTMsMTQsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksNTEsNTIsNTMsNTRdLFwiaW5jbHVzaXZlXCI6dHJ1ZX0sXCJzdGF2ZWdyb3VwXCI6e1wicnVsZXNcIjpbNSw2LDcsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksNTEsNTIsNTMsNTRdLFwiaW5jbHVzaXZlXCI6dHJ1ZX0sXCJJTklUSUFMXCI6e1wicnVsZXNcIjpbMCwxLDIsMyw0LDUsNiw3LDgsMTYsMTcsMTgsMTksMjAsMjEsMjIsMjMsMjQsMjUsMjYsMjcsMjgsMjksNTEsNTIsNTMsNTRdLFwiaW5jbHVzaXZlXCI6dHJ1ZX19XG59KTtcbnJldHVybiBsZXhlcjtcbn0pKCk7XG5wYXJzZXIubGV4ZXIgPSBsZXhlcjtcbmZ1bmN0aW9uIFBhcnNlciAoKSB7XG4gIHRoaXMueXkgPSB7fTtcbn1cblBhcnNlci5wcm90b3R5cGUgPSBwYXJzZXI7cGFyc2VyLlBhcnNlciA9IFBhcnNlcjtcbnJldHVybiBuZXcgUGFyc2VyO1xufSkoKTtcblxuXG5pZiAodHlwZW9mIHJlcXVpcmUgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuZXhwb3J0cy5wYXJzZXIgPSBwYXJzZXI7XG5leHBvcnRzLlBhcnNlciA9IHBhcnNlci5QYXJzZXI7XG5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gcGFyc2VyLnBhcnNlLmFwcGx5KHBhcnNlciwgYXJndW1lbnRzKTsgfTtcbmV4cG9ydHMubWFpbiA9IGZ1bmN0aW9uIGNvbW1vbmpzTWFpbihhcmdzKSB7XG4gICAgaWYgKCFhcmdzWzFdKSB7XG4gICAgICAgIGNvbnNvbGUubG9nKCdVc2FnZTogJythcmdzWzBdKycgRklMRScpO1xuICAgICAgICBwcm9jZXNzLmV4aXQoMSk7XG4gICAgfVxuICAgIHZhciBzb3VyY2UgPSByZXF1aXJlKCdmcycpLnJlYWRGaWxlU3luYyhyZXF1aXJlKCdwYXRoJykubm9ybWFsaXplKGFyZ3NbMV0pLCBcInV0ZjhcIik7XG4gICAgcmV0dXJuIGV4cG9ydHMucGFyc2VyLnBhcnNlKHNvdXJjZSk7XG59O1xuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnICYmIHJlcXVpcmUubWFpbiA9PT0gbW9kdWxlKSB7XG4gIGV4cG9ydHMubWFpbihwcm9jZXNzLmFyZ3Yuc2xpY2UoMSkpO1xufVxufSIsbnVsbCwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG5cbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcbnZhciBxdWV1ZSA9IFtdO1xudmFyIGRyYWluaW5nID0gZmFsc2U7XG52YXIgY3VycmVudFF1ZXVlO1xudmFyIHF1ZXVlSW5kZXggPSAtMTtcblxuZnVuY3Rpb24gY2xlYW5VcE5leHRUaWNrKCkge1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgaWYgKGN1cnJlbnRRdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgcXVldWUgPSBjdXJyZW50UXVldWUuY29uY2F0KHF1ZXVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgfVxuICAgIGlmIChxdWV1ZS5sZW5ndGgpIHtcbiAgICAgICAgZHJhaW5RdWV1ZSgpO1xuICAgIH1cbn1cblxuZnVuY3Rpb24gZHJhaW5RdWV1ZSgpIHtcbiAgICBpZiAoZHJhaW5pbmcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB2YXIgdGltZW91dCA9IHNldFRpbWVvdXQoY2xlYW5VcE5leHRUaWNrKTtcbiAgICBkcmFpbmluZyA9IHRydWU7XG5cbiAgICB2YXIgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIHdoaWxlKGxlbikge1xuICAgICAgICBjdXJyZW50UXVldWUgPSBxdWV1ZTtcbiAgICAgICAgcXVldWUgPSBbXTtcbiAgICAgICAgd2hpbGUgKCsrcXVldWVJbmRleCA8IGxlbikge1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRRdWV1ZSkge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRRdWV1ZVtxdWV1ZUluZGV4XS5ydW4oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBxdWV1ZUluZGV4ID0gLTE7XG4gICAgICAgIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB9XG4gICAgY3VycmVudFF1ZXVlID0gbnVsbDtcbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbn1cblxucHJvY2Vzcy5uZXh0VGljayA9IGZ1bmN0aW9uIChmdW4pIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoIC0gMSk7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBhcmdzW2kgLSAxXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBxdWV1ZS5wdXNoKG5ldyBJdGVtKGZ1biwgYXJncykpO1xuICAgIGlmIChxdWV1ZS5sZW5ndGggPT09IDEgJiYgIWRyYWluaW5nKSB7XG4gICAgICAgIHNldFRpbWVvdXQoZHJhaW5RdWV1ZSwgMCk7XG4gICAgfVxufTtcblxuLy8gdjggbGlrZXMgcHJlZGljdGlibGUgb2JqZWN0c1xuZnVuY3Rpb24gSXRlbShmdW4sIGFycmF5KSB7XG4gICAgdGhpcy5mdW4gPSBmdW47XG4gICAgdGhpcy5hcnJheSA9IGFycmF5O1xufVxuSXRlbS5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gKCkge1xuICAgIHRoaXMuZnVuLmFwcGx5KG51bGwsIHRoaXMuYXJyYXkpO1xufTtcbnByb2Nlc3MudGl0bGUgPSAnYnJvd3Nlcic7XG5wcm9jZXNzLmJyb3dzZXIgPSB0cnVlO1xucHJvY2Vzcy5lbnYgPSB7fTtcbnByb2Nlc3MuYXJndiA9IFtdO1xucHJvY2Vzcy52ZXJzaW9uID0gJyc7IC8vIGVtcHR5IHN0cmluZyB0byBhdm9pZCByZWdleHAgaXNzdWVzXG5wcm9jZXNzLnZlcnNpb25zID0ge307XG5cbmZ1bmN0aW9uIG5vb3AoKSB7fVxuXG5wcm9jZXNzLm9uID0gbm9vcDtcbnByb2Nlc3MuYWRkTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5vbmNlID0gbm9vcDtcbnByb2Nlc3Mub2ZmID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVBbGxMaXN0ZW5lcnMgPSBub29wO1xucHJvY2Vzcy5lbWl0ID0gbm9vcDtcblxucHJvY2Vzcy5iaW5kaW5nID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuYmluZGluZyBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xuXG5wcm9jZXNzLmN3ZCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuICcvJyB9O1xucHJvY2Vzcy5jaGRpciA9IGZ1bmN0aW9uIChkaXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3Byb2Nlc3MuY2hkaXIgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcbnByb2Nlc3MudW1hc2sgPSBmdW5jdGlvbigpIHsgcmV0dXJuIDA7IH07XG4iLCIvKiFcbiAqIGpRdWVyeSBKYXZhU2NyaXB0IExpYnJhcnkgdjIuMi4wXG4gKiBodHRwOi8vanF1ZXJ5LmNvbS9cbiAqXG4gKiBJbmNsdWRlcyBTaXp6bGUuanNcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTYtMDEtMDhUMjA6MDJaXG4gKi9cblxuKGZ1bmN0aW9uKCBnbG9iYWwsIGZhY3RvcnkgKSB7XG5cblx0aWYgKCB0eXBlb2YgbW9kdWxlID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBtb2R1bGUuZXhwb3J0cyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHQvLyBGb3IgQ29tbW9uSlMgYW5kIENvbW1vbkpTLWxpa2UgZW52aXJvbm1lbnRzIHdoZXJlIGEgcHJvcGVyIGB3aW5kb3dgXG5cdFx0Ly8gaXMgcHJlc2VudCwgZXhlY3V0ZSB0aGUgZmFjdG9yeSBhbmQgZ2V0IGpRdWVyeS5cblx0XHQvLyBGb3IgZW52aXJvbm1lbnRzIHRoYXQgZG8gbm90IGhhdmUgYSBgd2luZG93YCB3aXRoIGEgYGRvY3VtZW50YFxuXHRcdC8vIChzdWNoIGFzIE5vZGUuanMpLCBleHBvc2UgYSBmYWN0b3J5IGFzIG1vZHVsZS5leHBvcnRzLlxuXHRcdC8vIFRoaXMgYWNjZW50dWF0ZXMgdGhlIG5lZWQgZm9yIHRoZSBjcmVhdGlvbiBvZiBhIHJlYWwgYHdpbmRvd2AuXG5cdFx0Ly8gZS5nLiB2YXIgalF1ZXJ5ID0gcmVxdWlyZShcImpxdWVyeVwiKSh3aW5kb3cpO1xuXHRcdC8vIFNlZSB0aWNrZXQgIzE0NTQ5IGZvciBtb3JlIGluZm8uXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBnbG9iYWwuZG9jdW1lbnQgP1xuXHRcdFx0ZmFjdG9yeSggZ2xvYmFsLCB0cnVlICkgOlxuXHRcdFx0ZnVuY3Rpb24oIHcgKSB7XG5cdFx0XHRcdGlmICggIXcuZG9jdW1lbnQgKSB7XG5cdFx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCBcImpRdWVyeSByZXF1aXJlcyBhIHdpbmRvdyB3aXRoIGEgZG9jdW1lbnRcIiApO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiBmYWN0b3J5KCB3ICk7XG5cdFx0XHR9O1xuXHR9IGVsc2Uge1xuXHRcdGZhY3RvcnkoIGdsb2JhbCApO1xuXHR9XG5cbi8vIFBhc3MgdGhpcyBpZiB3aW5kb3cgaXMgbm90IGRlZmluZWQgeWV0XG59KHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3cgOiB0aGlzLCBmdW5jdGlvbiggd2luZG93LCBub0dsb2JhbCApIHtcblxuLy8gU3VwcG9ydDogRmlyZWZveCAxOCtcbi8vIENhbid0IGJlIGluIHN0cmljdCBtb2RlLCBzZXZlcmFsIGxpYnMgaW5jbHVkaW5nIEFTUC5ORVQgdHJhY2Vcbi8vIHRoZSBzdGFjayB2aWEgYXJndW1lbnRzLmNhbGxlci5jYWxsZWUgYW5kIEZpcmVmb3ggZGllcyBpZlxuLy8geW91IHRyeSB0byB0cmFjZSB0aHJvdWdoIFwidXNlIHN0cmljdFwiIGNhbGwgY2hhaW5zLiAoIzEzMzM1KVxuLy9cInVzZSBzdHJpY3RcIjtcbnZhciBhcnIgPSBbXTtcblxudmFyIGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50O1xuXG52YXIgc2xpY2UgPSBhcnIuc2xpY2U7XG5cbnZhciBjb25jYXQgPSBhcnIuY29uY2F0O1xuXG52YXIgcHVzaCA9IGFyci5wdXNoO1xuXG52YXIgaW5kZXhPZiA9IGFyci5pbmRleE9mO1xuXG52YXIgY2xhc3MydHlwZSA9IHt9O1xuXG52YXIgdG9TdHJpbmcgPSBjbGFzczJ0eXBlLnRvU3RyaW5nO1xuXG52YXIgaGFzT3duID0gY2xhc3MydHlwZS5oYXNPd25Qcm9wZXJ0eTtcblxudmFyIHN1cHBvcnQgPSB7fTtcblxuXG5cbnZhclxuXHR2ZXJzaW9uID0gXCIyLjIuMFwiLFxuXG5cdC8vIERlZmluZSBhIGxvY2FsIGNvcHkgb2YgalF1ZXJ5XG5cdGpRdWVyeSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgY29udGV4dCApIHtcblxuXHRcdC8vIFRoZSBqUXVlcnkgb2JqZWN0IGlzIGFjdHVhbGx5IGp1c3QgdGhlIGluaXQgY29uc3RydWN0b3IgJ2VuaGFuY2VkJ1xuXHRcdC8vIE5lZWQgaW5pdCBpZiBqUXVlcnkgaXMgY2FsbGVkIChqdXN0IGFsbG93IGVycm9yIHRvIGJlIHRocm93biBpZiBub3QgaW5jbHVkZWQpXG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuZm4uaW5pdCggc2VsZWN0b3IsIGNvbnRleHQgKTtcblx0fSxcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMVxuXHQvLyBNYWtlIHN1cmUgd2UgdHJpbSBCT00gYW5kIE5CU1Bcblx0cnRyaW0gPSAvXltcXHNcXHVGRUZGXFx4QTBdK3xbXFxzXFx1RkVGRlxceEEwXSskL2csXG5cblx0Ly8gTWF0Y2hlcyBkYXNoZWQgc3RyaW5nIGZvciBjYW1lbGl6aW5nXG5cdHJtc1ByZWZpeCA9IC9eLW1zLS8sXG5cdHJkYXNoQWxwaGEgPSAvLShbXFxkYS16XSkvZ2ksXG5cblx0Ly8gVXNlZCBieSBqUXVlcnkuY2FtZWxDYXNlIGFzIGNhbGxiYWNrIHRvIHJlcGxhY2UoKVxuXHRmY2FtZWxDYXNlID0gZnVuY3Rpb24oIGFsbCwgbGV0dGVyICkge1xuXHRcdHJldHVybiBsZXR0ZXIudG9VcHBlckNhc2UoKTtcblx0fTtcblxualF1ZXJ5LmZuID0galF1ZXJ5LnByb3RvdHlwZSA9IHtcblxuXHQvLyBUaGUgY3VycmVudCB2ZXJzaW9uIG9mIGpRdWVyeSBiZWluZyB1c2VkXG5cdGpxdWVyeTogdmVyc2lvbixcblxuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LFxuXG5cdC8vIFN0YXJ0IHdpdGggYW4gZW1wdHkgc2VsZWN0b3Jcblx0c2VsZWN0b3I6IFwiXCIsXG5cblx0Ly8gVGhlIGRlZmF1bHQgbGVuZ3RoIG9mIGEgalF1ZXJ5IG9iamVjdCBpcyAwXG5cdGxlbmd0aDogMCxcblxuXHR0b0FycmF5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIEdldCB0aGUgTnRoIGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgZWxlbWVudCBzZXQgT1Jcblx0Ly8gR2V0IHRoZSB3aG9sZSBtYXRjaGVkIGVsZW1lbnQgc2V0IGFzIGEgY2xlYW4gYXJyYXlcblx0Z2V0OiBmdW5jdGlvbiggbnVtICkge1xuXHRcdHJldHVybiBudW0gIT0gbnVsbCA/XG5cblx0XHRcdC8vIFJldHVybiBqdXN0IHRoZSBvbmUgZWxlbWVudCBmcm9tIHRoZSBzZXRcblx0XHRcdCggbnVtIDwgMCA/IHRoaXNbIG51bSArIHRoaXMubGVuZ3RoIF0gOiB0aGlzWyBudW0gXSApIDpcblxuXHRcdFx0Ly8gUmV0dXJuIGFsbCB0aGUgZWxlbWVudHMgaW4gYSBjbGVhbiBhcnJheVxuXHRcdFx0c2xpY2UuY2FsbCggdGhpcyApO1xuXHR9LFxuXG5cdC8vIFRha2UgYW4gYXJyYXkgb2YgZWxlbWVudHMgYW5kIHB1c2ggaXQgb250byB0aGUgc3RhY2tcblx0Ly8gKHJldHVybmluZyB0aGUgbmV3IG1hdGNoZWQgZWxlbWVudCBzZXQpXG5cdHB1c2hTdGFjazogZnVuY3Rpb24oIGVsZW1zICkge1xuXG5cdFx0Ly8gQnVpbGQgYSBuZXcgalF1ZXJ5IG1hdGNoZWQgZWxlbWVudCBzZXRcblx0XHR2YXIgcmV0ID0galF1ZXJ5Lm1lcmdlKCB0aGlzLmNvbnN0cnVjdG9yKCksIGVsZW1zICk7XG5cblx0XHQvLyBBZGQgdGhlIG9sZCBvYmplY3Qgb250byB0aGUgc3RhY2sgKGFzIGEgcmVmZXJlbmNlKVxuXHRcdHJldC5wcmV2T2JqZWN0ID0gdGhpcztcblx0XHRyZXQuY29udGV4dCA9IHRoaXMuY29udGV4dDtcblxuXHRcdC8vIFJldHVybiB0aGUgbmV3bHktZm9ybWVkIGVsZW1lbnQgc2V0XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblxuXHQvLyBFeGVjdXRlIGEgY2FsbGJhY2sgZm9yIGV2ZXJ5IGVsZW1lbnQgaW4gdGhlIG1hdGNoZWQgc2V0LlxuXHRlYWNoOiBmdW5jdGlvbiggY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIGpRdWVyeS5lYWNoKCB0aGlzLCBjYWxsYmFjayApO1xuXHR9LFxuXG5cdG1hcDogZnVuY3Rpb24oIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggalF1ZXJ5Lm1hcCggdGhpcywgZnVuY3Rpb24oIGVsZW0sIGkgKSB7XG5cdFx0XHRyZXR1cm4gY2FsbGJhY2suY2FsbCggZWxlbSwgaSwgZWxlbSApO1xuXHRcdH0gKSApO1xuXHR9LFxuXG5cdHNsaWNlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIHNsaWNlLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSApO1xuXHR9LFxuXG5cdGZpcnN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5lcSggMCApO1xuXHR9LFxuXG5cdGxhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmVxKCAtMSApO1xuXHR9LFxuXG5cdGVxOiBmdW5jdGlvbiggaSApIHtcblx0XHR2YXIgbGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRqID0gK2kgKyAoIGkgPCAwID8gbGVuIDogMCApO1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggaiA+PSAwICYmIGogPCBsZW4gPyBbIHRoaXNbIGogXSBdIDogW10gKTtcblx0fSxcblxuXHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnByZXZPYmplY3QgfHwgdGhpcy5jb25zdHJ1Y3RvcigpO1xuXHR9LFxuXG5cdC8vIEZvciBpbnRlcm5hbCB1c2Ugb25seS5cblx0Ly8gQmVoYXZlcyBsaWtlIGFuIEFycmF5J3MgbWV0aG9kLCBub3QgbGlrZSBhIGpRdWVyeSBtZXRob2QuXG5cdHB1c2g6IHB1c2gsXG5cdHNvcnQ6IGFyci5zb3J0LFxuXHRzcGxpY2U6IGFyci5zcGxpY2Vcbn07XG5cbmpRdWVyeS5leHRlbmQgPSBqUXVlcnkuZm4uZXh0ZW5kID0gZnVuY3Rpb24oKSB7XG5cdHZhciBvcHRpb25zLCBuYW1lLCBzcmMsIGNvcHksIGNvcHlJc0FycmF5LCBjbG9uZSxcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIDAgXSB8fCB7fSxcblx0XHRpID0gMSxcblx0XHRsZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoLFxuXHRcdGRlZXAgPSBmYWxzZTtcblxuXHQvLyBIYW5kbGUgYSBkZWVwIGNvcHkgc2l0dWF0aW9uXG5cdGlmICggdHlwZW9mIHRhcmdldCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0ZGVlcCA9IHRhcmdldDtcblxuXHRcdC8vIFNraXAgdGhlIGJvb2xlYW4gYW5kIHRoZSB0YXJnZXRcblx0XHR0YXJnZXQgPSBhcmd1bWVudHNbIGkgXSB8fCB7fTtcblx0XHRpKys7XG5cdH1cblxuXHQvLyBIYW5kbGUgY2FzZSB3aGVuIHRhcmdldCBpcyBhIHN0cmluZyBvciBzb21ldGhpbmcgKHBvc3NpYmxlIGluIGRlZXAgY29weSlcblx0aWYgKCB0eXBlb2YgdGFyZ2V0ICE9PSBcIm9iamVjdFwiICYmICFqUXVlcnkuaXNGdW5jdGlvbiggdGFyZ2V0ICkgKSB7XG5cdFx0dGFyZ2V0ID0ge307XG5cdH1cblxuXHQvLyBFeHRlbmQgalF1ZXJ5IGl0c2VsZiBpZiBvbmx5IG9uZSBhcmd1bWVudCBpcyBwYXNzZWRcblx0aWYgKCBpID09PSBsZW5ndGggKSB7XG5cdFx0dGFyZ2V0ID0gdGhpcztcblx0XHRpLS07XG5cdH1cblxuXHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblxuXHRcdC8vIE9ubHkgZGVhbCB3aXRoIG5vbi1udWxsL3VuZGVmaW5lZCB2YWx1ZXNcblx0XHRpZiAoICggb3B0aW9ucyA9IGFyZ3VtZW50c1sgaSBdICkgIT0gbnVsbCApIHtcblxuXHRcdFx0Ly8gRXh0ZW5kIHRoZSBiYXNlIG9iamVjdFxuXHRcdFx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdFx0XHRzcmMgPSB0YXJnZXRbIG5hbWUgXTtcblx0XHRcdFx0Y29weSA9IG9wdGlvbnNbIG5hbWUgXTtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG5ldmVyLWVuZGluZyBsb29wXG5cdFx0XHRcdGlmICggdGFyZ2V0ID09PSBjb3B5ICkge1xuXHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gUmVjdXJzZSBpZiB3ZSdyZSBtZXJnaW5nIHBsYWluIG9iamVjdHMgb3IgYXJyYXlzXG5cdFx0XHRcdGlmICggZGVlcCAmJiBjb3B5ICYmICggalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvcHkgKSB8fFxuXHRcdFx0XHRcdCggY29weUlzQXJyYXkgPSBqUXVlcnkuaXNBcnJheSggY29weSApICkgKSApIHtcblxuXHRcdFx0XHRcdGlmICggY29weUlzQXJyYXkgKSB7XG5cdFx0XHRcdFx0XHRjb3B5SXNBcnJheSA9IGZhbHNlO1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzQXJyYXkoIHNyYyApID8gc3JjIDogW107XG5cblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0Y2xvbmUgPSBzcmMgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIHNyYyApID8gc3JjIDoge307XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTmV2ZXIgbW92ZSBvcmlnaW5hbCBvYmplY3RzLCBjbG9uZSB0aGVtXG5cdFx0XHRcdFx0dGFyZ2V0WyBuYW1lIF0gPSBqUXVlcnkuZXh0ZW5kKCBkZWVwLCBjbG9uZSwgY29weSApO1xuXG5cdFx0XHRcdC8vIERvbid0IGJyaW5nIGluIHVuZGVmaW5lZCB2YWx1ZXNcblx0XHRcdFx0fSBlbHNlIGlmICggY29weSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHRhcmdldFsgbmFtZSBdID0gY29weTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIFJldHVybiB0aGUgbW9kaWZpZWQgb2JqZWN0XG5cdHJldHVybiB0YXJnZXQ7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gVW5pcXVlIGZvciBlYWNoIGNvcHkgb2YgalF1ZXJ5IG9uIHRoZSBwYWdlXG5cdGV4cGFuZG86IFwialF1ZXJ5XCIgKyAoIHZlcnNpb24gKyBNYXRoLnJhbmRvbSgpICkucmVwbGFjZSggL1xcRC9nLCBcIlwiICksXG5cblx0Ly8gQXNzdW1lIGpRdWVyeSBpcyByZWFkeSB3aXRob3V0IHRoZSByZWFkeSBtb2R1bGVcblx0aXNSZWFkeTogdHJ1ZSxcblxuXHRlcnJvcjogZnVuY3Rpb24oIG1zZyApIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoIG1zZyApO1xuXHR9LFxuXG5cdG5vb3A6IGZ1bmN0aW9uKCkge30sXG5cblx0aXNGdW5jdGlvbjogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4galF1ZXJ5LnR5cGUoIG9iaiApID09PSBcImZ1bmN0aW9uXCI7XG5cdH0sXG5cblx0aXNBcnJheTogQXJyYXkuaXNBcnJheSxcblxuXHRpc1dpbmRvdzogZnVuY3Rpb24oIG9iaiApIHtcblx0XHRyZXR1cm4gb2JqICE9IG51bGwgJiYgb2JqID09PSBvYmoud2luZG93O1xuXHR9LFxuXG5cdGlzTnVtZXJpYzogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIHBhcnNlRmxvYXQgTmFOcyBudW1lcmljLWNhc3QgZmFsc2UgcG9zaXRpdmVzIChudWxsfHRydWV8ZmFsc2V8XCJcIilcblx0XHQvLyAuLi5idXQgbWlzaW50ZXJwcmV0cyBsZWFkaW5nLW51bWJlciBzdHJpbmdzLCBwYXJ0aWN1bGFybHkgaGV4IGxpdGVyYWxzIChcIjB4Li4uXCIpXG5cdFx0Ly8gc3VidHJhY3Rpb24gZm9yY2VzIGluZmluaXRpZXMgdG8gTmFOXG5cdFx0Ly8gYWRkaW5nIDEgY29ycmVjdHMgbG9zcyBvZiBwcmVjaXNpb24gZnJvbSBwYXJzZUZsb2F0ICgjMTUxMDApXG5cdFx0dmFyIHJlYWxTdHJpbmdPYmogPSBvYmogJiYgb2JqLnRvU3RyaW5nKCk7XG5cdFx0cmV0dXJuICFqUXVlcnkuaXNBcnJheSggb2JqICkgJiYgKCByZWFsU3RyaW5nT2JqIC0gcGFyc2VGbG9hdCggcmVhbFN0cmluZ09iaiApICsgMSApID49IDA7XG5cdH0sXG5cblx0aXNQbGFpbk9iamVjdDogZnVuY3Rpb24oIG9iaiApIHtcblxuXHRcdC8vIE5vdCBwbGFpbiBvYmplY3RzOlxuXHRcdC8vIC0gQW55IG9iamVjdCBvciB2YWx1ZSB3aG9zZSBpbnRlcm5hbCBbW0NsYXNzXV0gcHJvcGVydHkgaXMgbm90IFwiW29iamVjdCBPYmplY3RdXCJcblx0XHQvLyAtIERPTSBub2Rlc1xuXHRcdC8vIC0gd2luZG93XG5cdFx0aWYgKCBqUXVlcnkudHlwZSggb2JqICkgIT09IFwib2JqZWN0XCIgfHwgb2JqLm5vZGVUeXBlIHx8IGpRdWVyeS5pc1dpbmRvdyggb2JqICkgKSB7XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0aWYgKCBvYmouY29uc3RydWN0b3IgJiZcblx0XHRcdFx0IWhhc093bi5jYWxsKCBvYmouY29uc3RydWN0b3IucHJvdG90eXBlLCBcImlzUHJvdG90eXBlT2ZcIiApICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblxuXHRcdC8vIElmIHRoZSBmdW5jdGlvbiBoYXNuJ3QgcmV0dXJuZWQgYWxyZWFkeSwgd2UncmUgY29uZmlkZW50IHRoYXRcblx0XHQvLyB8b2JqfCBpcyBhIHBsYWluIG9iamVjdCwgY3JlYXRlZCBieSB7fSBvciBjb25zdHJ1Y3RlZCB3aXRoIG5ldyBPYmplY3Rcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRpc0VtcHR5T2JqZWN0OiBmdW5jdGlvbiggb2JqICkge1xuXHRcdHZhciBuYW1lO1xuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdH1cblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHR0eXBlOiBmdW5jdGlvbiggb2JqICkge1xuXHRcdGlmICggb2JqID09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gb2JqICsgXCJcIjtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMCwgaU9TPDYgKGZ1bmN0aW9uaXNoIFJlZ0V4cClcblx0XHRyZXR1cm4gdHlwZW9mIG9iaiA9PT0gXCJvYmplY3RcIiB8fCB0eXBlb2Ygb2JqID09PSBcImZ1bmN0aW9uXCIgP1xuXHRcdFx0Y2xhc3MydHlwZVsgdG9TdHJpbmcuY2FsbCggb2JqICkgXSB8fCBcIm9iamVjdFwiIDpcblx0XHRcdHR5cGVvZiBvYmo7XG5cdH0sXG5cblx0Ly8gRXZhbHVhdGVzIGEgc2NyaXB0IGluIGEgZ2xvYmFsIGNvbnRleHRcblx0Z2xvYmFsRXZhbDogZnVuY3Rpb24oIGNvZGUgKSB7XG5cdFx0dmFyIHNjcmlwdCxcblx0XHRcdGluZGlyZWN0ID0gZXZhbDtcblxuXHRcdGNvZGUgPSBqUXVlcnkudHJpbSggY29kZSApO1xuXG5cdFx0aWYgKCBjb2RlICkge1xuXG5cdFx0XHQvLyBJZiB0aGUgY29kZSBpbmNsdWRlcyBhIHZhbGlkLCBwcm9sb2d1ZSBwb3NpdGlvblxuXHRcdFx0Ly8gc3RyaWN0IG1vZGUgcHJhZ21hLCBleGVjdXRlIGNvZGUgYnkgaW5qZWN0aW5nIGFcblx0XHRcdC8vIHNjcmlwdCB0YWcgaW50byB0aGUgZG9jdW1lbnQuXG5cdFx0XHRpZiAoIGNvZGUuaW5kZXhPZiggXCJ1c2Ugc3RyaWN0XCIgKSA9PT0gMSApIHtcblx0XHRcdFx0c2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzY3JpcHRcIiApO1xuXHRcdFx0XHRzY3JpcHQudGV4dCA9IGNvZGU7XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdCApLnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoIHNjcmlwdCApO1xuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UsIGF2b2lkIHRoZSBET00gbm9kZSBjcmVhdGlvbiwgaW5zZXJ0aW9uXG5cdFx0XHRcdC8vIGFuZCByZW1vdmFsIGJ5IHVzaW5nIGFuIGluZGlyZWN0IGdsb2JhbCBldmFsXG5cblx0XHRcdFx0aW5kaXJlY3QoIGNvZGUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Ly8gQ29udmVydCBkYXNoZWQgdG8gY2FtZWxDYXNlOyB1c2VkIGJ5IHRoZSBjc3MgYW5kIGRhdGEgbW9kdWxlc1xuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIE1pY3Jvc29mdCBmb3Jnb3QgdG8gaHVtcCB0aGVpciB2ZW5kb3IgcHJlZml4ICgjOTU3Milcblx0Y2FtZWxDYXNlOiBmdW5jdGlvbiggc3RyaW5nICkge1xuXHRcdHJldHVybiBzdHJpbmcucmVwbGFjZSggcm1zUHJlZml4LCBcIm1zLVwiICkucmVwbGFjZSggcmRhc2hBbHBoYSwgZmNhbWVsQ2FzZSApO1xuXHR9LFxuXG5cdG5vZGVOYW1lOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRyZXR1cm4gZWxlbS5ub2RlTmFtZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0fSxcblxuXHRlYWNoOiBmdW5jdGlvbiggb2JqLCBjYWxsYmFjayApIHtcblx0XHR2YXIgbGVuZ3RoLCBpID0gMDtcblxuXHRcdGlmICggaXNBcnJheUxpa2UoIG9iaiApICkge1xuXHRcdFx0bGVuZ3RoID0gb2JqLmxlbmd0aDtcblx0XHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrLmNhbGwoIG9ialsgaSBdLCBpLCBvYmpbIGkgXSApID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIG9iaiApIHtcblx0XHRcdFx0aWYgKCBjYWxsYmFjay5jYWxsKCBvYmpbIGkgXSwgaSwgb2JqWyBpIF0gKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gb2JqO1xuXHR9LFxuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xXG5cdHRyaW06IGZ1bmN0aW9uKCB0ZXh0ICkge1xuXHRcdHJldHVybiB0ZXh0ID09IG51bGwgP1xuXHRcdFx0XCJcIiA6XG5cdFx0XHQoIHRleHQgKyBcIlwiICkucmVwbGFjZSggcnRyaW0sIFwiXCIgKTtcblx0fSxcblxuXHQvLyByZXN1bHRzIGlzIGZvciBpbnRlcm5hbCB1c2FnZSBvbmx5XG5cdG1ha2VBcnJheTogZnVuY3Rpb24oIGFyciwgcmVzdWx0cyApIHtcblx0XHR2YXIgcmV0ID0gcmVzdWx0cyB8fCBbXTtcblxuXHRcdGlmICggYXJyICE9IG51bGwgKSB7XG5cdFx0XHRpZiAoIGlzQXJyYXlMaWtlKCBPYmplY3QoIGFyciApICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggcmV0LFxuXHRcdFx0XHRcdHR5cGVvZiBhcnIgPT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFsgYXJyIF0gOiBhcnJcblx0XHRcdFx0KTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guY2FsbCggcmV0LCBhcnIgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gcmV0O1xuXHR9LFxuXG5cdGluQXJyYXk6IGZ1bmN0aW9uKCBlbGVtLCBhcnIsIGkgKSB7XG5cdFx0cmV0dXJuIGFyciA9PSBudWxsID8gLTEgOiBpbmRleE9mLmNhbGwoIGFyciwgZWxlbSwgaSApO1xuXHR9LFxuXG5cdG1lcmdlOiBmdW5jdGlvbiggZmlyc3QsIHNlY29uZCApIHtcblx0XHR2YXIgbGVuID0gK3NlY29uZC5sZW5ndGgsXG5cdFx0XHRqID0gMCxcblx0XHRcdGkgPSBmaXJzdC5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGogPCBsZW47IGorKyApIHtcblx0XHRcdGZpcnN0WyBpKysgXSA9IHNlY29uZFsgaiBdO1xuXHRcdH1cblxuXHRcdGZpcnN0Lmxlbmd0aCA9IGk7XG5cblx0XHRyZXR1cm4gZmlyc3Q7XG5cdH0sXG5cblx0Z3JlcDogZnVuY3Rpb24oIGVsZW1zLCBjYWxsYmFjaywgaW52ZXJ0ICkge1xuXHRcdHZhciBjYWxsYmFja0ludmVyc2UsXG5cdFx0XHRtYXRjaGVzID0gW10sXG5cdFx0XHRpID0gMCxcblx0XHRcdGxlbmd0aCA9IGVsZW1zLmxlbmd0aCxcblx0XHRcdGNhbGxiYWNrRXhwZWN0ID0gIWludmVydDtcblxuXHRcdC8vIEdvIHRocm91Z2ggdGhlIGFycmF5LCBvbmx5IHNhdmluZyB0aGUgaXRlbXNcblx0XHQvLyB0aGF0IHBhc3MgdGhlIHZhbGlkYXRvciBmdW5jdGlvblxuXHRcdGZvciAoIDsgaSA8IGxlbmd0aDsgaSsrICkge1xuXHRcdFx0Y2FsbGJhY2tJbnZlcnNlID0gIWNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpICk7XG5cdFx0XHRpZiAoIGNhbGxiYWNrSW52ZXJzZSAhPT0gY2FsbGJhY2tFeHBlY3QgKSB7XG5cdFx0XHRcdG1hdGNoZXMucHVzaCggZWxlbXNbIGkgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBtYXRjaGVzO1xuXHR9LFxuXG5cdC8vIGFyZyBpcyBmb3IgaW50ZXJuYWwgdXNhZ2Ugb25seVxuXHRtYXA6IGZ1bmN0aW9uKCBlbGVtcywgY2FsbGJhY2ssIGFyZyApIHtcblx0XHR2YXIgbGVuZ3RoLCB2YWx1ZSxcblx0XHRcdGkgPSAwLFxuXHRcdFx0cmV0ID0gW107XG5cblx0XHQvLyBHbyB0aHJvdWdoIHRoZSBhcnJheSwgdHJhbnNsYXRpbmcgZWFjaCBvZiB0aGUgaXRlbXMgdG8gdGhlaXIgbmV3IHZhbHVlc1xuXHRcdGlmICggaXNBcnJheUxpa2UoIGVsZW1zICkgKSB7XG5cdFx0XHRsZW5ndGggPSBlbGVtcy5sZW5ndGg7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkrKyApIHtcblx0XHRcdFx0dmFsdWUgPSBjYWxsYmFjayggZWxlbXNbIGkgXSwgaSwgYXJnICk7XG5cblx0XHRcdFx0aWYgKCB2YWx1ZSAhPSBudWxsICkge1xuXHRcdFx0XHRcdHJldC5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBHbyB0aHJvdWdoIGV2ZXJ5IGtleSBvbiB0aGUgb2JqZWN0LFxuXHRcdH0gZWxzZSB7XG5cdFx0XHRmb3IgKCBpIGluIGVsZW1zICkge1xuXHRcdFx0XHR2YWx1ZSA9IGNhbGxiYWNrKCBlbGVtc1sgaSBdLCBpLCBhcmcgKTtcblxuXHRcdFx0XHRpZiAoIHZhbHVlICE9IG51bGwgKSB7XG5cdFx0XHRcdFx0cmV0LnB1c2goIHZhbHVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdFx0cmV0dXJuIGNvbmNhdC5hcHBseSggW10sIHJldCApO1xuXHR9LFxuXG5cdC8vIEEgZ2xvYmFsIEdVSUQgY291bnRlciBmb3Igb2JqZWN0c1xuXHRndWlkOiAxLFxuXG5cdC8vIEJpbmQgYSBmdW5jdGlvbiB0byBhIGNvbnRleHQsIG9wdGlvbmFsbHkgcGFydGlhbGx5IGFwcGx5aW5nIGFueVxuXHQvLyBhcmd1bWVudHMuXG5cdHByb3h5OiBmdW5jdGlvbiggZm4sIGNvbnRleHQgKSB7XG5cdFx0dmFyIHRtcCwgYXJncywgcHJveHk7XG5cblx0XHRpZiAoIHR5cGVvZiBjb250ZXh0ID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0dG1wID0gZm5bIGNvbnRleHQgXTtcblx0XHRcdGNvbnRleHQgPSBmbjtcblx0XHRcdGZuID0gdG1wO1xuXHRcdH1cblxuXHRcdC8vIFF1aWNrIGNoZWNrIHRvIGRldGVybWluZSBpZiB0YXJnZXQgaXMgY2FsbGFibGUsIGluIHRoZSBzcGVjXG5cdFx0Ly8gdGhpcyB0aHJvd3MgYSBUeXBlRXJyb3IsIGJ1dCB3ZSB3aWxsIGp1c3QgcmV0dXJuIHVuZGVmaW5lZC5cblx0XHRpZiAoICFqUXVlcnkuaXNGdW5jdGlvbiggZm4gKSApIHtcblx0XHRcdHJldHVybiB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gU2ltdWxhdGVkIGJpbmRcblx0XHRhcmdzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzLCAyICk7XG5cdFx0cHJveHkgPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBmbi5hcHBseSggY29udGV4dCB8fCB0aGlzLCBhcmdzLmNvbmNhdCggc2xpY2UuY2FsbCggYXJndW1lbnRzICkgKSApO1xuXHRcdH07XG5cblx0XHQvLyBTZXQgdGhlIGd1aWQgb2YgdW5pcXVlIGhhbmRsZXIgdG8gdGhlIHNhbWUgb2Ygb3JpZ2luYWwgaGFuZGxlciwgc28gaXQgY2FuIGJlIHJlbW92ZWRcblx0XHRwcm94eS5ndWlkID0gZm4uZ3VpZCA9IGZuLmd1aWQgfHwgalF1ZXJ5Lmd1aWQrKztcblxuXHRcdHJldHVybiBwcm94eTtcblx0fSxcblxuXHRub3c6IERhdGUubm93LFxuXG5cdC8vIGpRdWVyeS5zdXBwb3J0IGlzIG5vdCB1c2VkIGluIENvcmUgYnV0IG90aGVyIHByb2plY3RzIGF0dGFjaCB0aGVpclxuXHQvLyBwcm9wZXJ0aWVzIHRvIGl0IHNvIGl0IG5lZWRzIHRvIGV4aXN0LlxuXHRzdXBwb3J0OiBzdXBwb3J0XG59ICk7XG5cbi8vIEpTSGludCB3b3VsZCBlcnJvciBvbiB0aGlzIGNvZGUgZHVlIHRvIHRoZSBTeW1ib2wgbm90IGJlaW5nIGRlZmluZWQgaW4gRVM1LlxuLy8gRGVmaW5pbmcgdGhpcyBnbG9iYWwgaW4gLmpzaGludHJjIHdvdWxkIGNyZWF0ZSBhIGRhbmdlciBvZiB1c2luZyB0aGUgZ2xvYmFsXG4vLyB1bmd1YXJkZWQgaW4gYW5vdGhlciBwbGFjZSwgaXQgc2VlbXMgc2FmZXIgdG8ganVzdCBkaXNhYmxlIEpTSGludCBmb3IgdGhlc2Vcbi8vIHRocmVlIGxpbmVzLlxuLyoganNoaW50IGlnbm9yZTogc3RhcnQgKi9cbmlmICggdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICkge1xuXHRqUXVlcnkuZm5bIFN5bWJvbC5pdGVyYXRvciBdID0gYXJyWyBTeW1ib2wuaXRlcmF0b3IgXTtcbn1cbi8qIGpzaGludCBpZ25vcmU6IGVuZCAqL1xuXG4vLyBQb3B1bGF0ZSB0aGUgY2xhc3MydHlwZSBtYXBcbmpRdWVyeS5lYWNoKCBcIkJvb2xlYW4gTnVtYmVyIFN0cmluZyBGdW5jdGlvbiBBcnJheSBEYXRlIFJlZ0V4cCBPYmplY3QgRXJyb3IgU3ltYm9sXCIuc3BsaXQoIFwiIFwiICksXG5mdW5jdGlvbiggaSwgbmFtZSApIHtcblx0Y2xhc3MydHlwZVsgXCJbb2JqZWN0IFwiICsgbmFtZSArIFwiXVwiIF0gPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG59ICk7XG5cbmZ1bmN0aW9uIGlzQXJyYXlMaWtlKCBvYmogKSB7XG5cblx0Ly8gU3VwcG9ydDogaU9TIDguMiAobm90IHJlcHJvZHVjaWJsZSBpbiBzaW11bGF0b3IpXG5cdC8vIGBpbmAgY2hlY2sgdXNlZCB0byBwcmV2ZW50IEpJVCBlcnJvciAoZ2gtMjE0NSlcblx0Ly8gaGFzT3duIGlzbid0IHVzZWQgaGVyZSBkdWUgdG8gZmFsc2UgbmVnYXRpdmVzXG5cdC8vIHJlZ2FyZGluZyBOb2RlbGlzdCBsZW5ndGggaW4gSUVcblx0dmFyIGxlbmd0aCA9ICEhb2JqICYmIFwibGVuZ3RoXCIgaW4gb2JqICYmIG9iai5sZW5ndGgsXG5cdFx0dHlwZSA9IGpRdWVyeS50eXBlKCBvYmogKTtcblxuXHRpZiAoIHR5cGUgPT09IFwiZnVuY3Rpb25cIiB8fCBqUXVlcnkuaXNXaW5kb3coIG9iaiApICkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB0eXBlID09PSBcImFycmF5XCIgfHwgbGVuZ3RoID09PSAwIHx8XG5cdFx0dHlwZW9mIGxlbmd0aCA9PT0gXCJudW1iZXJcIiAmJiBsZW5ndGggPiAwICYmICggbGVuZ3RoIC0gMSApIGluIG9iajtcbn1cbnZhciBTaXp6bGUgPVxuLyohXG4gKiBTaXp6bGUgQ1NTIFNlbGVjdG9yIEVuZ2luZSB2Mi4yLjFcbiAqIGh0dHA6Ly9zaXp6bGVqcy5jb20vXG4gKlxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnNcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZVxuICogaHR0cDovL2pxdWVyeS5vcmcvbGljZW5zZVxuICpcbiAqIERhdGU6IDIwMTUtMTAtMTdcbiAqL1xuKGZ1bmN0aW9uKCB3aW5kb3cgKSB7XG5cbnZhciBpLFxuXHRzdXBwb3J0LFxuXHRFeHByLFxuXHRnZXRUZXh0LFxuXHRpc1hNTCxcblx0dG9rZW5pemUsXG5cdGNvbXBpbGUsXG5cdHNlbGVjdCxcblx0b3V0ZXJtb3N0Q29udGV4dCxcblx0c29ydElucHV0LFxuXHRoYXNEdXBsaWNhdGUsXG5cblx0Ly8gTG9jYWwgZG9jdW1lbnQgdmFyc1xuXHRzZXREb2N1bWVudCxcblx0ZG9jdW1lbnQsXG5cdGRvY0VsZW0sXG5cdGRvY3VtZW50SXNIVE1MLFxuXHRyYnVnZ3lRU0EsXG5cdHJidWdneU1hdGNoZXMsXG5cdG1hdGNoZXMsXG5cdGNvbnRhaW5zLFxuXG5cdC8vIEluc3RhbmNlLXNwZWNpZmljIGRhdGFcblx0ZXhwYW5kbyA9IFwic2l6emxlXCIgKyAxICogbmV3IERhdGUoKSxcblx0cHJlZmVycmVkRG9jID0gd2luZG93LmRvY3VtZW50LFxuXHRkaXJydW5zID0gMCxcblx0ZG9uZSA9IDAsXG5cdGNsYXNzQ2FjaGUgPSBjcmVhdGVDYWNoZSgpLFxuXHR0b2tlbkNhY2hlID0gY3JlYXRlQ2FjaGUoKSxcblx0Y29tcGlsZXJDYWNoZSA9IGNyZWF0ZUNhY2hlKCksXG5cdHNvcnRPcmRlciA9IGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdGlmICggYSA9PT0gYiApIHtcblx0XHRcdGhhc0R1cGxpY2F0ZSA9IHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiAwO1xuXHR9LFxuXG5cdC8vIEdlbmVyYWwtcHVycG9zZSBjb25zdGFudHNcblx0TUFYX05FR0FUSVZFID0gMSA8PCAzMSxcblxuXHQvLyBJbnN0YW5jZSBtZXRob2RzXG5cdGhhc093biA9ICh7fSkuaGFzT3duUHJvcGVydHksXG5cdGFyciA9IFtdLFxuXHRwb3AgPSBhcnIucG9wLFxuXHRwdXNoX25hdGl2ZSA9IGFyci5wdXNoLFxuXHRwdXNoID0gYXJyLnB1c2gsXG5cdHNsaWNlID0gYXJyLnNsaWNlLFxuXHQvLyBVc2UgYSBzdHJpcHBlZC1kb3duIGluZGV4T2YgYXMgaXQncyBmYXN0ZXIgdGhhbiBuYXRpdmVcblx0Ly8gaHR0cDovL2pzcGVyZi5jb20vdGhvci1pbmRleG9mLXZzLWZvci81XG5cdGluZGV4T2YgPSBmdW5jdGlvbiggbGlzdCwgZWxlbSApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRsZW4gPSBsaXN0Lmxlbmd0aDtcblx0XHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGlmICggbGlzdFtpXSA9PT0gZWxlbSApIHtcblx0XHRcdFx0cmV0dXJuIGk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiAtMTtcblx0fSxcblxuXHRib29sZWFucyA9IFwiY2hlY2tlZHxzZWxlY3RlZHxhc3luY3xhdXRvZm9jdXN8YXV0b3BsYXl8Y29udHJvbHN8ZGVmZXJ8ZGlzYWJsZWR8aGlkZGVufGlzbWFwfGxvb3B8bXVsdGlwbGV8b3BlbnxyZWFkb25seXxyZXF1aXJlZHxzY29wZWRcIixcblxuXHQvLyBSZWd1bGFyIGV4cHJlc3Npb25zXG5cblx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvY3NzMy1zZWxlY3RvcnMvI3doaXRlc3BhY2Vcblx0d2hpdGVzcGFjZSA9IFwiW1xcXFx4MjBcXFxcdFxcXFxyXFxcXG5cXFxcZl1cIixcblxuXHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9DU1MyMS9zeW5kYXRhLmh0bWwjdmFsdWUtZGVmLWlkZW50aWZpZXJcblx0aWRlbnRpZmllciA9IFwiKD86XFxcXFxcXFwufFtcXFxcdy1dfFteXFxcXHgwMC1cXFxceGEwXSkrXCIsXG5cblx0Ly8gQXR0cmlidXRlIHNlbGVjdG9yczogaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNhdHRyaWJ1dGUtc2VsZWN0b3JzXG5cdGF0dHJpYnV0ZXMgPSBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFwiICsgaWRlbnRpZmllciArIFwiKSg/OlwiICsgd2hpdGVzcGFjZSArXG5cdFx0Ly8gT3BlcmF0b3IgKGNhcHR1cmUgMilcblx0XHRcIiooWypeJHwhfl0/PSlcIiArIHdoaXRlc3BhY2UgK1xuXHRcdC8vIFwiQXR0cmlidXRlIHZhbHVlcyBtdXN0IGJlIENTUyBpZGVudGlmaWVycyBbY2FwdHVyZSA1XSBvciBzdHJpbmdzIFtjYXB0dXJlIDMgb3IgY2FwdHVyZSA0XVwiXG5cdFx0XCIqKD86JygoPzpcXFxcXFxcXC58W15cXFxcXFxcXCddKSopJ3xcXFwiKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcXFxcIl0pKilcXFwifChcIiArIGlkZW50aWZpZXIgKyBcIikpfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFwiKlxcXFxdXCIsXG5cblx0cHNldWRvcyA9IFwiOihcIiArIGlkZW50aWZpZXIgKyBcIikoPzpcXFxcKChcIiArXG5cdFx0Ly8gVG8gcmVkdWNlIHRoZSBudW1iZXIgb2Ygc2VsZWN0b3JzIG5lZWRpbmcgdG9rZW5pemUgaW4gdGhlIHByZUZpbHRlciwgcHJlZmVyIGFyZ3VtZW50czpcblx0XHQvLyAxLiBxdW90ZWQgKGNhcHR1cmUgMzsgY2FwdHVyZSA0IG9yIGNhcHR1cmUgNSlcblx0XHRcIignKCg/OlxcXFxcXFxcLnxbXlxcXFxcXFxcJ10pKiknfFxcXCIoKD86XFxcXFxcXFwufFteXFxcXFxcXFxcXFwiXSkqKVxcXCIpfFwiICtcblx0XHQvLyAyLiBzaW1wbGUgKGNhcHR1cmUgNilcblx0XHRcIigoPzpcXFxcXFxcXC58W15cXFxcXFxcXCgpW1xcXFxdXXxcIiArIGF0dHJpYnV0ZXMgKyBcIikqKXxcIiArXG5cdFx0Ly8gMy4gYW55dGhpbmcgZWxzZSAoY2FwdHVyZSAyKVxuXHRcdFwiLipcIiArXG5cdFx0XCIpXFxcXCl8KVwiLFxuXG5cdC8vIExlYWRpbmcgYW5kIG5vbi1lc2NhcGVkIHRyYWlsaW5nIHdoaXRlc3BhY2UsIGNhcHR1cmluZyBzb21lIG5vbi13aGl0ZXNwYWNlIGNoYXJhY3RlcnMgcHJlY2VkaW5nIHRoZSBsYXR0ZXJcblx0cndoaXRlc3BhY2UgPSBuZXcgUmVnRXhwKCB3aGl0ZXNwYWNlICsgXCIrXCIsIFwiZ1wiICksXG5cdHJ0cmltID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIrfCgoPzpefFteXFxcXFxcXFxdKSg/OlxcXFxcXFxcLikqKVwiICsgd2hpdGVzcGFjZSArIFwiKyRcIiwgXCJnXCIgKSxcblxuXHRyY29tbWEgPSBuZXcgUmVnRXhwKCBcIl5cIiArIHdoaXRlc3BhY2UgKyBcIiosXCIgKyB3aGl0ZXNwYWNlICsgXCIqXCIgKSxcblx0cmNvbWJpbmF0b3JzID0gbmV3IFJlZ0V4cCggXCJeXCIgKyB3aGl0ZXNwYWNlICsgXCIqKFs+K35dfFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgd2hpdGVzcGFjZSArIFwiKlwiICksXG5cblx0cmF0dHJpYnV0ZVF1b3RlcyA9IG5ldyBSZWdFeHAoIFwiPVwiICsgd2hpdGVzcGFjZSArIFwiKihbXlxcXFxdJ1xcXCJdKj8pXCIgKyB3aGl0ZXNwYWNlICsgXCIqXFxcXF1cIiwgXCJnXCIgKSxcblxuXHRycHNldWRvID0gbmV3IFJlZ0V4cCggcHNldWRvcyApLFxuXHRyaWRlbnRpZmllciA9IG5ldyBSZWdFeHAoIFwiXlwiICsgaWRlbnRpZmllciArIFwiJFwiICksXG5cblx0bWF0Y2hFeHByID0ge1xuXHRcdFwiSURcIjogbmV3IFJlZ0V4cCggXCJeIyhcIiArIGlkZW50aWZpZXIgKyBcIilcIiApLFxuXHRcdFwiQ0xBU1NcIjogbmV3IFJlZ0V4cCggXCJeXFxcXC4oXCIgKyBpZGVudGlmaWVyICsgXCIpXCIgKSxcblx0XHRcIlRBR1wiOiBuZXcgUmVnRXhwKCBcIl4oXCIgKyBpZGVudGlmaWVyICsgXCJ8WypdKVwiICksXG5cdFx0XCJBVFRSXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgYXR0cmlidXRlcyApLFxuXHRcdFwiUFNFVURPXCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgcHNldWRvcyApLFxuXHRcdFwiQ0hJTERcIjogbmV3IFJlZ0V4cCggXCJeOihvbmx5fGZpcnN0fGxhc3R8bnRofG50aC1sYXN0KS0oY2hpbGR8b2YtdHlwZSkoPzpcXFxcKFwiICsgd2hpdGVzcGFjZSArXG5cdFx0XHRcIiooZXZlbnxvZGR8KChbKy1dfCkoXFxcXGQqKW58KVwiICsgd2hpdGVzcGFjZSArIFwiKig/OihbKy1dfClcIiArIHdoaXRlc3BhY2UgK1xuXHRcdFx0XCIqKFxcXFxkKyl8KSlcIiArIHdoaXRlc3BhY2UgKyBcIipcXFxcKXwpXCIsIFwiaVwiICksXG5cdFx0XCJib29sXCI6IG5ldyBSZWdFeHAoIFwiXig/OlwiICsgYm9vbGVhbnMgKyBcIikkXCIsIFwiaVwiICksXG5cdFx0Ly8gRm9yIHVzZSBpbiBsaWJyYXJpZXMgaW1wbGVtZW50aW5nIC5pcygpXG5cdFx0Ly8gV2UgdXNlIHRoaXMgZm9yIFBPUyBtYXRjaGluZyBpbiBgc2VsZWN0YFxuXHRcdFwibmVlZHNDb250ZXh0XCI6IG5ldyBSZWdFeHAoIFwiXlwiICsgd2hpdGVzcGFjZSArIFwiKls+K35dfDooZXZlbnxvZGR8ZXF8Z3R8bHR8bnRofGZpcnN0fGxhc3QpKD86XFxcXChcIiArXG5cdFx0XHR3aGl0ZXNwYWNlICsgXCIqKCg/Oi1cXFxcZCk/XFxcXGQqKVwiICsgd2hpdGVzcGFjZSArIFwiKlxcXFwpfCkoPz1bXi1dfCQpXCIsIFwiaVwiIClcblx0fSxcblxuXHRyaW5wdXRzID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8YnV0dG9uKSQvaSxcblx0cmhlYWRlciA9IC9eaFxcZCQvaSxcblxuXHRybmF0aXZlID0gL15bXntdK1xce1xccypcXFtuYXRpdmUgXFx3LyxcblxuXHQvLyBFYXNpbHktcGFyc2VhYmxlL3JldHJpZXZhYmxlIElEIG9yIFRBRyBvciBDTEFTUyBzZWxlY3RvcnNcblx0cnF1aWNrRXhwciA9IC9eKD86IyhbXFx3LV0rKXwoXFx3Kyl8XFwuKFtcXHctXSspKSQvLFxuXG5cdHJzaWJsaW5nID0gL1srfl0vLFxuXHRyZXNjYXBlID0gLyd8XFxcXC9nLFxuXG5cdC8vIENTUyBlc2NhcGVzIGh0dHA6Ly93d3cudzMub3JnL1RSL0NTUzIxL3N5bmRhdGEuaHRtbCNlc2NhcGVkLWNoYXJhY3RlcnNcblx0cnVuZXNjYXBlID0gbmV3IFJlZ0V4cCggXCJcXFxcXFxcXChbXFxcXGRhLWZdezEsNn1cIiArIHdoaXRlc3BhY2UgKyBcIj98KFwiICsgd2hpdGVzcGFjZSArIFwiKXwuKVwiLCBcImlnXCIgKSxcblx0ZnVuZXNjYXBlID0gZnVuY3Rpb24oIF8sIGVzY2FwZWQsIGVzY2FwZWRXaGl0ZXNwYWNlICkge1xuXHRcdHZhciBoaWdoID0gXCIweFwiICsgZXNjYXBlZCAtIDB4MTAwMDA7XG5cdFx0Ly8gTmFOIG1lYW5zIG5vbi1jb2RlcG9pbnRcblx0XHQvLyBTdXBwb3J0OiBGaXJlZm94PDI0XG5cdFx0Ly8gV29ya2Fyb3VuZCBlcnJvbmVvdXMgbnVtZXJpYyBpbnRlcnByZXRhdGlvbiBvZiArXCIweFwiXG5cdFx0cmV0dXJuIGhpZ2ggIT09IGhpZ2ggfHwgZXNjYXBlZFdoaXRlc3BhY2UgP1xuXHRcdFx0ZXNjYXBlZCA6XG5cdFx0XHRoaWdoIDwgMCA/XG5cdFx0XHRcdC8vIEJNUCBjb2RlcG9pbnRcblx0XHRcdFx0U3RyaW5nLmZyb21DaGFyQ29kZSggaGlnaCArIDB4MTAwMDAgKSA6XG5cdFx0XHRcdC8vIFN1cHBsZW1lbnRhbCBQbGFuZSBjb2RlcG9pbnQgKHN1cnJvZ2F0ZSBwYWlyKVxuXHRcdFx0XHRTdHJpbmcuZnJvbUNoYXJDb2RlKCBoaWdoID4+IDEwIHwgMHhEODAwLCBoaWdoICYgMHgzRkYgfCAweERDMDAgKTtcblx0fSxcblxuXHQvLyBVc2VkIGZvciBpZnJhbWVzXG5cdC8vIFNlZSBzZXREb2N1bWVudCgpXG5cdC8vIFJlbW92aW5nIHRoZSBmdW5jdGlvbiB3cmFwcGVyIGNhdXNlcyBhIFwiUGVybWlzc2lvbiBEZW5pZWRcIlxuXHQvLyBlcnJvciBpbiBJRVxuXHR1bmxvYWRIYW5kbGVyID0gZnVuY3Rpb24oKSB7XG5cdFx0c2V0RG9jdW1lbnQoKTtcblx0fTtcblxuLy8gT3B0aW1pemUgZm9yIHB1c2guYXBwbHkoIF8sIE5vZGVMaXN0IClcbnRyeSB7XG5cdHB1c2guYXBwbHkoXG5cdFx0KGFyciA9IHNsaWNlLmNhbGwoIHByZWZlcnJlZERvYy5jaGlsZE5vZGVzICkpLFxuXHRcdHByZWZlcnJlZERvYy5jaGlsZE5vZGVzXG5cdCk7XG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdC8vIERldGVjdCBzaWxlbnRseSBmYWlsaW5nIHB1c2guYXBwbHlcblx0YXJyWyBwcmVmZXJyZWREb2MuY2hpbGROb2Rlcy5sZW5ndGggXS5ub2RlVHlwZTtcbn0gY2F0Y2ggKCBlICkge1xuXHRwdXNoID0geyBhcHBseTogYXJyLmxlbmd0aCA/XG5cblx0XHQvLyBMZXZlcmFnZSBzbGljZSBpZiBwb3NzaWJsZVxuXHRcdGZ1bmN0aW9uKCB0YXJnZXQsIGVscyApIHtcblx0XHRcdHB1c2hfbmF0aXZlLmFwcGx5KCB0YXJnZXQsIHNsaWNlLmNhbGwoZWxzKSApO1xuXHRcdH0gOlxuXG5cdFx0Ly8gU3VwcG9ydDogSUU8OVxuXHRcdC8vIE90aGVyd2lzZSBhcHBlbmQgZGlyZWN0bHlcblx0XHRmdW5jdGlvbiggdGFyZ2V0LCBlbHMgKSB7XG5cdFx0XHR2YXIgaiA9IHRhcmdldC5sZW5ndGgsXG5cdFx0XHRcdGkgPSAwO1xuXHRcdFx0Ly8gQ2FuJ3QgdHJ1c3QgTm9kZUxpc3QubGVuZ3RoXG5cdFx0XHR3aGlsZSAoICh0YXJnZXRbaisrXSA9IGVsc1tpKytdKSApIHt9XG5cdFx0XHR0YXJnZXQubGVuZ3RoID0gaiAtIDE7XG5cdFx0fVxuXHR9O1xufVxuXG5mdW5jdGlvbiBTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICkge1xuXHR2YXIgbSwgaSwgZWxlbSwgbmlkLCBuaWRzZWxlY3QsIG1hdGNoLCBncm91cHMsIG5ld1NlbGVjdG9yLFxuXHRcdG5ld0NvbnRleHQgPSBjb250ZXh0ICYmIGNvbnRleHQub3duZXJEb2N1bWVudCxcblxuXHRcdC8vIG5vZGVUeXBlIGRlZmF1bHRzIHRvIDksIHNpbmNlIGNvbnRleHQgZGVmYXVsdHMgdG8gZG9jdW1lbnRcblx0XHRub2RlVHlwZSA9IGNvbnRleHQgPyBjb250ZXh0Lm5vZGVUeXBlIDogOTtcblxuXHRyZXN1bHRzID0gcmVzdWx0cyB8fCBbXTtcblxuXHQvLyBSZXR1cm4gZWFybHkgZnJvbSBjYWxscyB3aXRoIGludmFsaWQgc2VsZWN0b3Igb3IgY29udGV4dFxuXHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiB8fCAhc2VsZWN0b3IgfHxcblx0XHRub2RlVHlwZSAhPT0gMSAmJiBub2RlVHlwZSAhPT0gOSAmJiBub2RlVHlwZSAhPT0gMTEgKSB7XG5cblx0XHRyZXR1cm4gcmVzdWx0cztcblx0fVxuXG5cdC8vIFRyeSB0byBzaG9ydGN1dCBmaW5kIG9wZXJhdGlvbnMgKGFzIG9wcG9zZWQgdG8gZmlsdGVycykgaW4gSFRNTCBkb2N1bWVudHNcblx0aWYgKCAhc2VlZCApIHtcblxuXHRcdGlmICggKCBjb250ZXh0ID8gY29udGV4dC5vd25lckRvY3VtZW50IHx8IGNvbnRleHQgOiBwcmVmZXJyZWREb2MgKSAhPT0gZG9jdW1lbnQgKSB7XG5cdFx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHRcdH1cblx0XHRjb250ZXh0ID0gY29udGV4dCB8fCBkb2N1bWVudDtcblxuXHRcdGlmICggZG9jdW1lbnRJc0hUTUwgKSB7XG5cblx0XHRcdC8vIElmIHRoZSBzZWxlY3RvciBpcyBzdWZmaWNpZW50bHkgc2ltcGxlLCB0cnkgdXNpbmcgYSBcImdldCpCeSpcIiBET00gbWV0aG9kXG5cdFx0XHQvLyAoZXhjZXB0aW5nIERvY3VtZW50RnJhZ21lbnQgY29udGV4dCwgd2hlcmUgdGhlIG1ldGhvZHMgZG9uJ3QgZXhpc3QpXG5cdFx0XHRpZiAoIG5vZGVUeXBlICE9PSAxMSAmJiAobWF0Y2ggPSBycXVpY2tFeHByLmV4ZWMoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdC8vIElEIHNlbGVjdG9yXG5cdFx0XHRcdGlmICggKG0gPSBtYXRjaFsxXSkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb2N1bWVudCBjb250ZXh0XG5cdFx0XHRcdFx0aWYgKCBub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBtICkpICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHRcdC8vIFRPRE86IGlkZW50aWZ5IHZlcnNpb25zXG5cdFx0XHRcdFx0XHRcdC8vIGdldEVsZW1lbnRCeUlkIGNhbiBtYXRjaCBlbGVtZW50cyBieSBuYW1lIGluc3RlYWQgb2YgSURcblx0XHRcdFx0XHRcdFx0aWYgKCBlbGVtLmlkID09PSBtICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3VsdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIEVsZW1lbnQgY29udGV4dFxuXHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFLCBPcGVyYSwgV2Via2l0XG5cdFx0XHRcdFx0XHQvLyBUT0RPOiBpZGVudGlmeSB2ZXJzaW9uc1xuXHRcdFx0XHRcdFx0Ly8gZ2V0RWxlbWVudEJ5SWQgY2FuIG1hdGNoIGVsZW1lbnRzIGJ5IG5hbWUgaW5zdGVhZCBvZiBJRFxuXHRcdFx0XHRcdFx0aWYgKCBuZXdDb250ZXh0ICYmIChlbGVtID0gbmV3Q29udGV4dC5nZXRFbGVtZW50QnlJZCggbSApKSAmJlxuXHRcdFx0XHRcdFx0XHRjb250YWlucyggY29udGV4dCwgZWxlbSApICYmXG5cdFx0XHRcdFx0XHRcdGVsZW0uaWQgPT09IG0gKSB7XG5cblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBUeXBlIHNlbGVjdG9yXG5cdFx0XHRcdH0gZWxzZSBpZiAoIG1hdGNoWzJdICkge1xuXHRcdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHNlbGVjdG9yICkgKTtcblx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblxuXHRcdFx0XHQvLyBDbGFzcyBzZWxlY3RvclxuXHRcdFx0XHR9IGVsc2UgaWYgKCAobSA9IG1hdGNoWzNdKSAmJiBzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgJiZcblx0XHRcdFx0XHRjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKSB7XG5cblx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBjb250ZXh0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUoIG0gKSApO1xuXHRcdFx0XHRcdHJldHVybiByZXN1bHRzO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRha2UgYWR2YW50YWdlIG9mIHF1ZXJ5U2VsZWN0b3JBbGxcblx0XHRcdGlmICggc3VwcG9ydC5xc2EgJiZcblx0XHRcdFx0IWNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXSAmJlxuXHRcdFx0XHQoIXJidWdneVFTQSB8fCAhcmJ1Z2d5UVNBLnRlc3QoIHNlbGVjdG9yICkpICkge1xuXG5cdFx0XHRcdGlmICggbm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IGNvbnRleHQ7XG5cdFx0XHRcdFx0bmV3U2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuXHRcdFx0XHQvLyBxU0EgbG9va3Mgb3V0c2lkZSBFbGVtZW50IGNvbnRleHQsIHdoaWNoIGlzIG5vdCB3aGF0IHdlIHdhbnRcblx0XHRcdFx0Ly8gVGhhbmtzIHRvIEFuZHJldyBEdXBvbnQgZm9yIHRoaXMgd29ya2Fyb3VuZCB0ZWNobmlxdWVcblx0XHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04XG5cdFx0XHRcdC8vIEV4Y2x1ZGUgb2JqZWN0IGVsZW1lbnRzXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvbnRleHQubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHRcdC8vIENhcHR1cmUgdGhlIGNvbnRleHQgSUQsIHNldHRpbmcgaXQgZmlyc3QgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0aWYgKCAobmlkID0gY29udGV4dC5nZXRBdHRyaWJ1dGUoIFwiaWRcIiApKSApIHtcblx0XHRcdFx0XHRcdG5pZCA9IG5pZC5yZXBsYWNlKCByZXNjYXBlLCBcIlxcXFwkJlwiICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdGNvbnRleHQuc2V0QXR0cmlidXRlKCBcImlkXCIsIChuaWQgPSBleHBhbmRvKSApO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIFByZWZpeCBldmVyeSBzZWxlY3RvciBpbiB0aGUgbGlzdFxuXHRcdFx0XHRcdGdyb3VwcyA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdFx0XHRcdGkgPSBncm91cHMubGVuZ3RoO1xuXHRcdFx0XHRcdG5pZHNlbGVjdCA9IHJpZGVudGlmaWVyLnRlc3QoIG5pZCApID8gXCIjXCIgKyBuaWQgOiBcIltpZD0nXCIgKyBuaWQgKyBcIiddXCI7XG5cdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRncm91cHNbaV0gPSBuaWRzZWxlY3QgKyBcIiBcIiArIHRvU2VsZWN0b3IoIGdyb3Vwc1tpXSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRuZXdTZWxlY3RvciA9IGdyb3Vwcy5qb2luKCBcIixcIiApO1xuXG5cdFx0XHRcdFx0Ly8gRXhwYW5kIGNvbnRleHQgZm9yIHNpYmxpbmcgc2VsZWN0b3JzXG5cdFx0XHRcdFx0bmV3Q29udGV4dCA9IHJzaWJsaW5nLnRlc3QoIHNlbGVjdG9yICkgJiYgdGVzdENvbnRleHQoIGNvbnRleHQucGFyZW50Tm9kZSApIHx8XG5cdFx0XHRcdFx0XHRjb250ZXh0O1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBuZXdTZWxlY3RvciApIHtcblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0cHVzaC5hcHBseSggcmVzdWx0cyxcblx0XHRcdFx0XHRcdFx0bmV3Q29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCBuZXdTZWxlY3RvciApXG5cdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cdFx0XHRcdFx0fSBjYXRjaCAoIHFzYUVycm9yICkge1xuXHRcdFx0XHRcdH0gZmluYWxseSB7XG5cdFx0XHRcdFx0XHRpZiAoIG5pZCA9PT0gZXhwYW5kbyApIHtcblx0XHRcdFx0XHRcdFx0Y29udGV4dC5yZW1vdmVBdHRyaWJ1dGUoIFwiaWRcIiApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIEFsbCBvdGhlcnNcblx0cmV0dXJuIHNlbGVjdCggc2VsZWN0b3IucmVwbGFjZSggcnRyaW0sIFwiJDFcIiApLCBjb250ZXh0LCByZXN1bHRzLCBzZWVkICk7XG59XG5cbi8qKlxuICogQ3JlYXRlIGtleS12YWx1ZSBjYWNoZXMgb2YgbGltaXRlZCBzaXplXG4gKiBAcmV0dXJucyB7ZnVuY3Rpb24oc3RyaW5nLCBvYmplY3QpfSBSZXR1cm5zIHRoZSBPYmplY3QgZGF0YSBhZnRlciBzdG9yaW5nIGl0IG9uIGl0c2VsZiB3aXRoXG4gKlx0cHJvcGVydHkgbmFtZSB0aGUgKHNwYWNlLXN1ZmZpeGVkKSBzdHJpbmcgYW5kIChpZiB0aGUgY2FjaGUgaXMgbGFyZ2VyIHRoYW4gRXhwci5jYWNoZUxlbmd0aClcbiAqXHRkZWxldGluZyB0aGUgb2xkZXN0IGVudHJ5XG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUNhY2hlKCkge1xuXHR2YXIga2V5cyA9IFtdO1xuXG5cdGZ1bmN0aW9uIGNhY2hlKCBrZXksIHZhbHVlICkge1xuXHRcdC8vIFVzZSAoa2V5ICsgXCIgXCIpIHRvIGF2b2lkIGNvbGxpc2lvbiB3aXRoIG5hdGl2ZSBwcm90b3R5cGUgcHJvcGVydGllcyAoc2VlIElzc3VlICMxNTcpXG5cdFx0aWYgKCBrZXlzLnB1c2goIGtleSArIFwiIFwiICkgPiBFeHByLmNhY2hlTGVuZ3RoICkge1xuXHRcdFx0Ly8gT25seSBrZWVwIHRoZSBtb3N0IHJlY2VudCBlbnRyaWVzXG5cdFx0XHRkZWxldGUgY2FjaGVbIGtleXMuc2hpZnQoKSBdO1xuXHRcdH1cblx0XHRyZXR1cm4gKGNhY2hlWyBrZXkgKyBcIiBcIiBdID0gdmFsdWUpO1xuXHR9XG5cdHJldHVybiBjYWNoZTtcbn1cblxuLyoqXG4gKiBNYXJrIGEgZnVuY3Rpb24gZm9yIHNwZWNpYWwgdXNlIGJ5IFNpenpsZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGZ1bmN0aW9uIHRvIG1hcmtcbiAqL1xuZnVuY3Rpb24gbWFya0Z1bmN0aW9uKCBmbiApIHtcblx0Zm5bIGV4cGFuZG8gXSA9IHRydWU7XG5cdHJldHVybiBmbjtcbn1cblxuLyoqXG4gKiBTdXBwb3J0IHRlc3RpbmcgdXNpbmcgYW4gZWxlbWVudFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gUGFzc2VkIHRoZSBjcmVhdGVkIGRpdiBhbmQgZXhwZWN0cyBhIGJvb2xlYW4gcmVzdWx0XG4gKi9cbmZ1bmN0aW9uIGFzc2VydCggZm4gKSB7XG5cdHZhciBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuXG5cdHRyeSB7XG5cdFx0cmV0dXJuICEhZm4oIGRpdiApO1xuXHR9IGNhdGNoIChlKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9IGZpbmFsbHkge1xuXHRcdC8vIFJlbW92ZSBmcm9tIGl0cyBwYXJlbnQgYnkgZGVmYXVsdFxuXHRcdGlmICggZGl2LnBhcmVudE5vZGUgKSB7XG5cdFx0XHRkaXYucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCggZGl2ICk7XG5cdFx0fVxuXHRcdC8vIHJlbGVhc2UgbWVtb3J5IGluIElFXG5cdFx0ZGl2ID0gbnVsbDtcblx0fVxufVxuXG4vKipcbiAqIEFkZHMgdGhlIHNhbWUgaGFuZGxlciBmb3IgYWxsIG9mIHRoZSBzcGVjaWZpZWQgYXR0cnNcbiAqIEBwYXJhbSB7U3RyaW5nfSBhdHRycyBQaXBlLXNlcGFyYXRlZCBsaXN0IG9mIGF0dHJpYnV0ZXNcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGhhbmRsZXIgVGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgYXBwbGllZFxuICovXG5mdW5jdGlvbiBhZGRIYW5kbGUoIGF0dHJzLCBoYW5kbGVyICkge1xuXHR2YXIgYXJyID0gYXR0cnMuc3BsaXQoXCJ8XCIpLFxuXHRcdGkgPSBhcnIubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdEV4cHIuYXR0ckhhbmRsZVsgYXJyW2ldIF0gPSBoYW5kbGVyO1xuXHR9XG59XG5cbi8qKlxuICogQ2hlY2tzIGRvY3VtZW50IG9yZGVyIG9mIHR3byBzaWJsaW5nc1xuICogQHBhcmFtIHtFbGVtZW50fSBhXG4gKiBAcGFyYW0ge0VsZW1lbnR9IGJcbiAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgbGVzcyB0aGFuIDAgaWYgYSBwcmVjZWRlcyBiLCBncmVhdGVyIHRoYW4gMCBpZiBhIGZvbGxvd3MgYlxuICovXG5mdW5jdGlvbiBzaWJsaW5nQ2hlY2soIGEsIGIgKSB7XG5cdHZhciBjdXIgPSBiICYmIGEsXG5cdFx0ZGlmZiA9IGN1ciAmJiBhLm5vZGVUeXBlID09PSAxICYmIGIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdCggfmIuc291cmNlSW5kZXggfHwgTUFYX05FR0FUSVZFICkgLVxuXHRcdFx0KCB+YS5zb3VyY2VJbmRleCB8fCBNQVhfTkVHQVRJVkUgKTtcblxuXHQvLyBVc2UgSUUgc291cmNlSW5kZXggaWYgYXZhaWxhYmxlIG9uIGJvdGggbm9kZXNcblx0aWYgKCBkaWZmICkge1xuXHRcdHJldHVybiBkaWZmO1xuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgYiBmb2xsb3dzIGFcblx0aWYgKCBjdXIgKSB7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLm5leHRTaWJsaW5nKSApIHtcblx0XHRcdGlmICggY3VyID09PSBiICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGEgPyAxIDogLTE7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIGZ1bmN0aW9uIHRvIHVzZSBpbiBwc2V1ZG9zIGZvciBpbnB1dCB0eXBlc1xuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqL1xuZnVuY3Rpb24gY3JlYXRlSW5wdXRQc2V1ZG8oIHR5cGUgKSB7XG5cdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgbmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIGJ1dHRvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKi9cbmZ1bmN0aW9uIGNyZWF0ZUJ1dHRvblBzZXVkbyggdHlwZSApIHtcblx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHZhciBuYW1lID0gZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXHRcdHJldHVybiAobmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5hbWUgPT09IFwiYnV0dG9uXCIpICYmIGVsZW0udHlwZSA9PT0gdHlwZTtcblx0fTtcbn1cblxuLyoqXG4gKiBSZXR1cm5zIGEgZnVuY3Rpb24gdG8gdXNlIGluIHBzZXVkb3MgZm9yIHBvc2l0aW9uYWxzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuICovXG5mdW5jdGlvbiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKCBmbiApIHtcblx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggYXJndW1lbnQgKSB7XG5cdFx0YXJndW1lbnQgPSArYXJndW1lbnQ7XG5cdFx0cmV0dXJuIG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdHZhciBqLFxuXHRcdFx0XHRtYXRjaEluZGV4ZXMgPSBmbiggW10sIHNlZWQubGVuZ3RoLCBhcmd1bWVudCApLFxuXHRcdFx0XHRpID0gbWF0Y2hJbmRleGVzLmxlbmd0aDtcblxuXHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgZm91bmQgYXQgdGhlIHNwZWNpZmllZCBpbmRleGVzXG5cdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0aWYgKCBzZWVkWyAoaiA9IG1hdGNoSW5kZXhlc1tpXSkgXSApIHtcblx0XHRcdFx0XHRzZWVkW2pdID0gIShtYXRjaGVzW2pdID0gc2VlZFtqXSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9KTtcblx0fSk7XG59XG5cbi8qKlxuICogQ2hlY2tzIGEgbm9kZSBmb3IgdmFsaWRpdHkgYXMgYSBTaXp6bGUgY29udGV4dFxuICogQHBhcmFtIHtFbGVtZW50fE9iamVjdD19IGNvbnRleHRcbiAqIEByZXR1cm5zIHtFbGVtZW50fE9iamVjdHxCb29sZWFufSBUaGUgaW5wdXQgbm9kZSBpZiBhY2NlcHRhYmxlLCBvdGhlcndpc2UgYSBmYWxzeSB2YWx1ZVxuICovXG5mdW5jdGlvbiB0ZXN0Q29udGV4dCggY29udGV4dCApIHtcblx0cmV0dXJuIGNvbnRleHQgJiYgdHlwZW9mIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUgIT09IFwidW5kZWZpbmVkXCIgJiYgY29udGV4dDtcbn1cblxuLy8gRXhwb3NlIHN1cHBvcnQgdmFycyBmb3IgY29udmVuaWVuY2VcbnN1cHBvcnQgPSBTaXp6bGUuc3VwcG9ydCA9IHt9O1xuXG4vKipcbiAqIERldGVjdHMgWE1MIG5vZGVzXG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBlbGVtIEFuIGVsZW1lbnQgb3IgYSBkb2N1bWVudFxuICogQHJldHVybnMge0Jvb2xlYW59IFRydWUgaWZmIGVsZW0gaXMgYSBub24tSFRNTCBYTUwgbm9kZVxuICovXG5pc1hNTCA9IFNpenpsZS5pc1hNTCA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXHQvLyBkb2N1bWVudEVsZW1lbnQgaXMgdmVyaWZpZWQgZm9yIGNhc2VzIHdoZXJlIGl0IGRvZXNuJ3QgeWV0IGV4aXN0XG5cdC8vIChzdWNoIGFzIGxvYWRpbmcgaWZyYW1lcyBpbiBJRSAtICM0ODMzKVxuXHR2YXIgZG9jdW1lbnRFbGVtZW50ID0gZWxlbSAmJiAoZWxlbS5vd25lckRvY3VtZW50IHx8IGVsZW0pLmRvY3VtZW50RWxlbWVudDtcblx0cmV0dXJuIGRvY3VtZW50RWxlbWVudCA/IGRvY3VtZW50RWxlbWVudC5ub2RlTmFtZSAhPT0gXCJIVE1MXCIgOiBmYWxzZTtcbn07XG5cbi8qKlxuICogU2V0cyBkb2N1bWVudC1yZWxhdGVkIHZhcmlhYmxlcyBvbmNlIGJhc2VkIG9uIHRoZSBjdXJyZW50IGRvY3VtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR8T2JqZWN0fSBbZG9jXSBBbiBlbGVtZW50IG9yIGRvY3VtZW50IG9iamVjdCB0byB1c2UgdG8gc2V0IHRoZSBkb2N1bWVudFxuICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyB0aGUgY3VycmVudCBkb2N1bWVudFxuICovXG5zZXREb2N1bWVudCA9IFNpenpsZS5zZXREb2N1bWVudCA9IGZ1bmN0aW9uKCBub2RlICkge1xuXHR2YXIgaGFzQ29tcGFyZSwgcGFyZW50LFxuXHRcdGRvYyA9IG5vZGUgPyBub2RlLm93bmVyRG9jdW1lbnQgfHwgbm9kZSA6IHByZWZlcnJlZERvYztcblxuXHQvLyBSZXR1cm4gZWFybHkgaWYgZG9jIGlzIGludmFsaWQgb3IgYWxyZWFkeSBzZWxlY3RlZFxuXHRpZiAoIGRvYyA9PT0gZG9jdW1lbnQgfHwgZG9jLm5vZGVUeXBlICE9PSA5IHx8ICFkb2MuZG9jdW1lbnRFbGVtZW50ICkge1xuXHRcdHJldHVybiBkb2N1bWVudDtcblx0fVxuXG5cdC8vIFVwZGF0ZSBnbG9iYWwgdmFyaWFibGVzXG5cdGRvY3VtZW50ID0gZG9jO1xuXHRkb2NFbGVtID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuXHRkb2N1bWVudElzSFRNTCA9ICFpc1hNTCggZG9jdW1lbnQgKTtcblxuXHQvLyBTdXBwb3J0OiBJRSA5LTExLCBFZGdlXG5cdC8vIEFjY2Vzc2luZyBpZnJhbWUgZG9jdW1lbnRzIGFmdGVyIHVubG9hZCB0aHJvd3MgXCJwZXJtaXNzaW9uIGRlbmllZFwiIGVycm9ycyAoalF1ZXJ5ICMxMzkzNilcblx0aWYgKCAocGFyZW50ID0gZG9jdW1lbnQuZGVmYXVsdFZpZXcpICYmIHBhcmVudC50b3AgIT09IHBhcmVudCApIHtcblx0XHQvLyBTdXBwb3J0OiBJRSAxMVxuXHRcdGlmICggcGFyZW50LmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRwYXJlbnQuYWRkRXZlbnRMaXN0ZW5lciggXCJ1bmxvYWRcIiwgdW5sb2FkSGFuZGxlciwgZmFsc2UgKTtcblxuXHRcdC8vIFN1cHBvcnQ6IElFIDkgLSAxMCBvbmx5XG5cdFx0fSBlbHNlIGlmICggcGFyZW50LmF0dGFjaEV2ZW50ICkge1xuXHRcdFx0cGFyZW50LmF0dGFjaEV2ZW50KCBcIm9udW5sb2FkXCIsIHVubG9hZEhhbmRsZXIgKTtcblx0XHR9XG5cdH1cblxuXHQvKiBBdHRyaWJ1dGVzXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBTdXBwb3J0OiBJRTw4XG5cdC8vIFZlcmlmeSB0aGF0IGdldEF0dHJpYnV0ZSByZWFsbHkgcmV0dXJucyBhdHRyaWJ1dGVzIGFuZCBub3QgcHJvcGVydGllc1xuXHQvLyAoZXhjZXB0aW5nIElFOCBib29sZWFucylcblx0c3VwcG9ydC5hdHRyaWJ1dGVzID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmNsYXNzTmFtZSA9IFwiaVwiO1xuXHRcdHJldHVybiAhZGl2LmdldEF0dHJpYnV0ZShcImNsYXNzTmFtZVwiKTtcblx0fSk7XG5cblx0LyogZ2V0RWxlbWVudChzKUJ5KlxuXHQtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tICovXG5cblx0Ly8gQ2hlY2sgaWYgZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpIHJldHVybnMgb25seSBlbGVtZW50c1xuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYgKSB7XG5cdFx0ZGl2LmFwcGVuZENoaWxkKCBkb2N1bWVudC5jcmVhdGVDb21tZW50KFwiXCIpICk7XG5cdFx0cmV0dXJuICFkaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCIqXCIpLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gU3VwcG9ydDogSUU8OVxuXHRzdXBwb3J0LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgPSBybmF0aXZlLnRlc3QoIGRvY3VtZW50LmdldEVsZW1lbnRzQnlDbGFzc05hbWUgKTtcblxuXHQvLyBTdXBwb3J0OiBJRTwxMFxuXHQvLyBDaGVjayBpZiBnZXRFbGVtZW50QnlJZCByZXR1cm5zIGVsZW1lbnRzIGJ5IG5hbWVcblx0Ly8gVGhlIGJyb2tlbiBnZXRFbGVtZW50QnlJZCBtZXRob2RzIGRvbid0IHBpY2sgdXAgcHJvZ3JhbWF0aWNhbGx5LXNldCBuYW1lcyxcblx0Ly8gc28gdXNlIGEgcm91bmRhYm91dCBnZXRFbGVtZW50c0J5TmFtZSB0ZXN0XG5cdHN1cHBvcnQuZ2V0QnlJZCA9IGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlkID0gZXhwYW5kbztcblx0XHRyZXR1cm4gIWRvY3VtZW50LmdldEVsZW1lbnRzQnlOYW1lIHx8ICFkb2N1bWVudC5nZXRFbGVtZW50c0J5TmFtZSggZXhwYW5kbyApLmxlbmd0aDtcblx0fSk7XG5cblx0Ly8gSUQgZmluZCBhbmQgZmlsdGVyXG5cdGlmICggc3VwcG9ydC5nZXRCeUlkICkge1xuXHRcdEV4cHIuZmluZFtcIklEXCJdID0gZnVuY3Rpb24oIGlkLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50QnlJZCAhPT0gXCJ1bmRlZmluZWRcIiAmJiBkb2N1bWVudElzSFRNTCApIHtcblx0XHRcdFx0dmFyIG0gPSBjb250ZXh0LmdldEVsZW1lbnRCeUlkKCBpZCApO1xuXHRcdFx0XHRyZXR1cm4gbSA/IFsgbSBdIDogW107XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRFeHByLmZpbHRlcltcIklEXCJdID0gZnVuY3Rpb24oIGlkICkge1xuXHRcdFx0dmFyIGF0dHJJZCA9IGlkLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZShcImlkXCIpID09PSBhdHRySWQ7XG5cdFx0XHR9O1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0Ly8gU3VwcG9ydDogSUU2Lzdcblx0XHQvLyBnZXRFbGVtZW50QnlJZCBpcyBub3QgcmVsaWFibGUgYXMgYSBmaW5kIHNob3J0Y3V0XG5cdFx0ZGVsZXRlIEV4cHIuZmluZFtcIklEXCJdO1xuXG5cdFx0RXhwci5maWx0ZXJbXCJJRFwiXSA9ICBmdW5jdGlvbiggaWQgKSB7XG5cdFx0XHR2YXIgYXR0cklkID0gaWQucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIG5vZGUgPSB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGVOb2RlICE9PSBcInVuZGVmaW5lZFwiICYmXG5cdFx0XHRcdFx0ZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKFwiaWRcIik7XG5cdFx0XHRcdHJldHVybiBub2RlICYmIG5vZGUudmFsdWUgPT09IGF0dHJJZDtcblx0XHRcdH07XG5cdFx0fTtcblx0fVxuXG5cdC8vIFRhZ1xuXHRFeHByLmZpbmRbXCJUQUdcIl0gPSBzdXBwb3J0LmdldEVsZW1lbnRzQnlUYWdOYW1lID9cblx0XHRmdW5jdGlvbiggdGFnLCBjb250ZXh0ICkge1xuXHRcdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5VGFnTmFtZSAhPT0gXCJ1bmRlZmluZWRcIiApIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyApO1xuXG5cdFx0XHQvLyBEb2N1bWVudEZyYWdtZW50IG5vZGVzIGRvbid0IGhhdmUgZ0VCVE5cblx0XHRcdH0gZWxzZSBpZiAoIHN1cHBvcnQucXNhICkge1xuXHRcdFx0XHRyZXR1cm4gY29udGV4dC5xdWVyeVNlbGVjdG9yQWxsKCB0YWcgKTtcblx0XHRcdH1cblx0XHR9IDpcblxuXHRcdGZ1bmN0aW9uKCB0YWcsIGNvbnRleHQgKSB7XG5cdFx0XHR2YXIgZWxlbSxcblx0XHRcdFx0dG1wID0gW10sXG5cdFx0XHRcdGkgPSAwLFxuXHRcdFx0XHQvLyBCeSBoYXBweSBjb2luY2lkZW5jZSwgYSAoYnJva2VuKSBnRUJUTiBhcHBlYXJzIG9uIERvY3VtZW50RnJhZ21lbnQgbm9kZXMgdG9vXG5cdFx0XHRcdHJlc3VsdHMgPSBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lKCB0YWcgKTtcblxuXHRcdFx0Ly8gRmlsdGVyIG91dCBwb3NzaWJsZSBjb21tZW50c1xuXHRcdFx0aWYgKCB0YWcgPT09IFwiKlwiICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gcmVzdWx0c1tpKytdKSApIHtcblx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHR0bXAucHVzaCggZWxlbSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0bXA7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHR9O1xuXG5cdC8vIENsYXNzXG5cdEV4cHIuZmluZFtcIkNMQVNTXCJdID0gc3VwcG9ydC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICYmIGZ1bmN0aW9uKCBjbGFzc05hbWUsIGNvbnRleHQgKSB7XG5cdFx0aWYgKCB0eXBlb2YgY29udGV4dC5nZXRFbGVtZW50c0J5Q2xhc3NOYW1lICE9PSBcInVuZGVmaW5lZFwiICYmIGRvY3VtZW50SXNIVE1MICkge1xuXHRcdFx0cmV0dXJuIGNvbnRleHQuZ2V0RWxlbWVudHNCeUNsYXNzTmFtZSggY2xhc3NOYW1lICk7XG5cdFx0fVxuXHR9O1xuXG5cdC8qIFFTQS9tYXRjaGVzU2VsZWN0b3Jcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXG5cdC8vIFFTQSBhbmQgbWF0Y2hlc1NlbGVjdG9yIHN1cHBvcnRcblxuXHQvLyBtYXRjaGVzU2VsZWN0b3IoOmFjdGl2ZSkgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKElFOS9PcGVyYSAxMS41KVxuXHRyYnVnZ3lNYXRjaGVzID0gW107XG5cblx0Ly8gcVNhKDpmb2N1cykgcmVwb3J0cyBmYWxzZSB3aGVuIHRydWUgKENocm9tZSAyMSlcblx0Ly8gV2UgYWxsb3cgdGhpcyBiZWNhdXNlIG9mIGEgYnVnIGluIElFOC85IHRoYXQgdGhyb3dzIGFuIGVycm9yXG5cdC8vIHdoZW5ldmVyIGBkb2N1bWVudC5hY3RpdmVFbGVtZW50YCBpcyBhY2Nlc3NlZCBvbiBhbiBpZnJhbWVcblx0Ly8gU28sIHdlIGFsbG93IDpmb2N1cyB0byBwYXNzIHRocm91Z2ggUVNBIGFsbCB0aGUgdGltZSB0byBhdm9pZCB0aGUgSUUgZXJyb3Jcblx0Ly8gU2VlIGh0dHA6Ly9idWdzLmpxdWVyeS5jb20vdGlja2V0LzEzMzc4XG5cdHJidWdneVFTQSA9IFtdO1xuXG5cdGlmICggKHN1cHBvcnQucXNhID0gcm5hdGl2ZS50ZXN0KCBkb2N1bWVudC5xdWVyeVNlbGVjdG9yQWxsICkpICkge1xuXHRcdC8vIEJ1aWxkIFFTQSByZWdleFxuXHRcdC8vIFJlZ2V4IHN0cmF0ZWd5IGFkb3B0ZWQgZnJvbSBEaWVnbyBQZXJpbmlcblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIFNlbGVjdCBpcyBzZXQgdG8gZW1wdHkgc3RyaW5nIG9uIHB1cnBvc2Vcblx0XHRcdC8vIFRoaXMgaXMgdG8gdGVzdCBJRSdzIHRyZWF0bWVudCBvZiBub3QgZXhwbGljaXRseVxuXHRcdFx0Ly8gc2V0dGluZyBhIGJvb2xlYW4gY29udGVudCBhdHRyaWJ1dGUsXG5cdFx0XHQvLyBzaW5jZSBpdHMgcHJlc2VuY2Ugc2hvdWxkIGJlIGVub3VnaFxuXHRcdFx0Ly8gaHR0cDovL2J1Z3MuanF1ZXJ5LmNvbS90aWNrZXQvMTIzNTlcblx0XHRcdGRvY0VsZW0uYXBwZW5kQ2hpbGQoIGRpdiApLmlubmVySFRNTCA9IFwiPGEgaWQ9J1wiICsgZXhwYW5kbyArIFwiJz48L2E+XCIgK1xuXHRcdFx0XHRcIjxzZWxlY3QgaWQ9J1wiICsgZXhwYW5kbyArIFwiLVxcclxcXFwnIG1zYWxsb3djYXB0dXJlPScnPlwiICtcblx0XHRcdFx0XCI8b3B0aW9uIHNlbGVjdGVkPScnPjwvb3B0aW9uPjwvc2VsZWN0PlwiO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgsIE9wZXJhIDExLTEyLjE2XG5cdFx0XHQvLyBOb3RoaW5nIHNob3VsZCBiZSBzZWxlY3RlZCB3aGVuIGVtcHR5IHN0cmluZ3MgZm9sbG93IF49IG9yICQ9IG9yICo9XG5cdFx0XHQvLyBUaGUgdGVzdCBhdHRyaWJ1dGUgbXVzdCBiZSB1bmtub3duIGluIE9wZXJhIGJ1dCBcInNhZmVcIiBmb3IgV2luUlRcblx0XHRcdC8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9pZS9oaDQ2NTM4OC5hc3B4I2F0dHJpYnV0ZV9zZWN0aW9uXG5cdFx0XHRpZiAoIGRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW21zYWxsb3djYXB0dXJlXj0nJ11cIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCJbKl4kXT1cIiArIHdoaXRlc3BhY2UgKyBcIiooPzonJ3xcXFwiXFxcIilcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBhbmQgXCJ2YWx1ZVwiIGFyZSBub3QgdHJlYXRlZCBjb3JyZWN0bHlcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiW3NlbGVjdGVkXVwiKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKCBcIlxcXFxbXCIgKyB3aGl0ZXNwYWNlICsgXCIqKD86dmFsdWV8XCIgKyBib29sZWFucyArIFwiKVwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZTwyOSwgQW5kcm9pZDw0LjQsIFNhZmFyaTw3LjArLCBpT1M8Ny4wKywgUGhhbnRvbUpTPDEuOS44K1xuXHRcdFx0aWYgKCAhZGl2LnF1ZXJ5U2VsZWN0b3JBbGwoIFwiW2lkfj1cIiArIGV4cGFuZG8gKyBcIi1dXCIgKS5sZW5ndGggKSB7XG5cdFx0XHRcdHJidWdneVFTQS5wdXNoKFwifj1cIik7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFdlYmtpdC9PcGVyYSAtIDpjaGVja2VkIHNob3VsZCByZXR1cm4gc2VsZWN0ZWQgb3B0aW9uIGVsZW1lbnRzXG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi8yMDExL1JFQy1jc3MzLXNlbGVjdG9ycy0yMDExMDkyOS8jY2hlY2tlZFxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmNoZWNrZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaChcIjpjaGVja2VkXCIpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgOCssIGlPUyA4K1xuXHRcdFx0Ly8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNjg1MVxuXHRcdFx0Ly8gSW4tcGFnZSBgc2VsZWN0b3IjaWQgc2liaW5nLWNvbWJpbmF0b3Igc2VsZWN0b3JgIGZhaWxzXG5cdFx0XHRpZiAoICFkaXYucXVlcnlTZWxlY3RvckFsbCggXCJhI1wiICsgZXhwYW5kbyArIFwiKypcIiApLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goXCIuIy4rWyt+XVwiKTtcblx0XHRcdH1cblx0XHR9KTtcblxuXHRcdGFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRcdFx0Ly8gU3VwcG9ydDogV2luZG93cyA4IE5hdGl2ZSBBcHBzXG5cdFx0XHQvLyBUaGUgdHlwZSBhbmQgbmFtZSBhdHRyaWJ1dGVzIGFyZSByZXN0cmljdGVkIGR1cmluZyAuaW5uZXJIVE1MIGFzc2lnbm1lbnRcblx0XHRcdHZhciBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcblx0XHRcdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwiaGlkZGVuXCIgKTtcblx0XHRcdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKS5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcIkRcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRThcblx0XHRcdC8vIEVuZm9yY2UgY2FzZS1zZW5zaXRpdml0eSBvZiBuYW1lIGF0dHJpYnV0ZVxuXHRcdFx0aWYgKCBkaXYucXVlcnlTZWxlY3RvckFsbChcIltuYW1lPWRdXCIpLmxlbmd0aCApIHtcblx0XHRcdFx0cmJ1Z2d5UVNBLnB1c2goIFwibmFtZVwiICsgd2hpdGVzcGFjZSArIFwiKlsqXiR8IX5dPz1cIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBGRiAzLjUgLSA6ZW5hYmxlZC86ZGlzYWJsZWQgYW5kIGhpZGRlbiBlbGVtZW50cyAoaGlkZGVuIGVsZW1lbnRzIGFyZSBzdGlsbCBlbmFibGVkKVxuXHRcdFx0Ly8gSUU4IHRocm93cyBlcnJvciBoZXJlIGFuZCB3aWxsIG5vdCBzZWUgbGF0ZXIgdGVzdHNcblx0XHRcdGlmICggIWRpdi5xdWVyeVNlbGVjdG9yQWxsKFwiOmVuYWJsZWRcIikubGVuZ3RoICkge1xuXHRcdFx0XHRyYnVnZ3lRU0EucHVzaCggXCI6ZW5hYmxlZFwiLCBcIjpkaXNhYmxlZFwiICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9wZXJhIDEwLTExIGRvZXMgbm90IHRocm93IG9uIHBvc3QtY29tbWEgaW52YWxpZCBwc2V1ZG9zXG5cdFx0XHRkaXYucXVlcnlTZWxlY3RvckFsbChcIiosOnhcIik7XG5cdFx0XHRyYnVnZ3lRU0EucHVzaChcIiwuKjpcIik7XG5cdFx0fSk7XG5cdH1cblxuXHRpZiAoIChzdXBwb3J0Lm1hdGNoZXNTZWxlY3RvciA9IHJuYXRpdmUudGVzdCggKG1hdGNoZXMgPSBkb2NFbGVtLm1hdGNoZXMgfHxcblx0XHRkb2NFbGVtLndlYmtpdE1hdGNoZXNTZWxlY3RvciB8fFxuXHRcdGRvY0VsZW0ubW96TWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5vTWF0Y2hlc1NlbGVjdG9yIHx8XG5cdFx0ZG9jRWxlbS5tc01hdGNoZXNTZWxlY3RvcikgKSkgKSB7XG5cblx0XHRhc3NlcnQoZnVuY3Rpb24oIGRpdiApIHtcblx0XHRcdC8vIENoZWNrIHRvIHNlZSBpZiBpdCdzIHBvc3NpYmxlIHRvIGRvIG1hdGNoZXNTZWxlY3RvclxuXHRcdFx0Ly8gb24gYSBkaXNjb25uZWN0ZWQgbm9kZSAoSUUgOSlcblx0XHRcdHN1cHBvcnQuZGlzY29ubmVjdGVkTWF0Y2ggPSBtYXRjaGVzLmNhbGwoIGRpdiwgXCJkaXZcIiApO1xuXG5cdFx0XHQvLyBUaGlzIHNob3VsZCBmYWlsIHdpdGggYW4gZXhjZXB0aW9uXG5cdFx0XHQvLyBHZWNrbyBkb2VzIG5vdCBlcnJvciwgcmV0dXJucyBmYWxzZSBpbnN0ZWFkXG5cdFx0XHRtYXRjaGVzLmNhbGwoIGRpdiwgXCJbcyE9JyddOnhcIiApO1xuXHRcdFx0cmJ1Z2d5TWF0Y2hlcy5wdXNoKCBcIiE9XCIsIHBzZXVkb3MgKTtcblx0XHR9KTtcblx0fVxuXG5cdHJidWdneVFTQSA9IHJidWdneVFTQS5sZW5ndGggJiYgbmV3IFJlZ0V4cCggcmJ1Z2d5UVNBLmpvaW4oXCJ8XCIpICk7XG5cdHJidWdneU1hdGNoZXMgPSByYnVnZ3lNYXRjaGVzLmxlbmd0aCAmJiBuZXcgUmVnRXhwKCByYnVnZ3lNYXRjaGVzLmpvaW4oXCJ8XCIpICk7XG5cblx0LyogQ29udGFpbnNcblx0LS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSAqL1xuXHRoYXNDb21wYXJlID0gcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uICk7XG5cblx0Ly8gRWxlbWVudCBjb250YWlucyBhbm90aGVyXG5cdC8vIFB1cnBvc2VmdWxseSBzZWxmLWV4Y2x1c2l2ZVxuXHQvLyBBcyBpbiwgYW4gZWxlbWVudCBkb2VzIG5vdCBjb250YWluIGl0c2VsZlxuXHRjb250YWlucyA9IGhhc0NvbXBhcmUgfHwgcm5hdGl2ZS50ZXN0KCBkb2NFbGVtLmNvbnRhaW5zICkgP1xuXHRcdGZ1bmN0aW9uKCBhLCBiICkge1xuXHRcdFx0dmFyIGFkb3duID0gYS5ub2RlVHlwZSA9PT0gOSA/IGEuZG9jdW1lbnRFbGVtZW50IDogYSxcblx0XHRcdFx0YnVwID0gYiAmJiBiLnBhcmVudE5vZGU7XG5cdFx0XHRyZXR1cm4gYSA9PT0gYnVwIHx8ICEhKCBidXAgJiYgYnVwLm5vZGVUeXBlID09PSAxICYmIChcblx0XHRcdFx0YWRvd24uY29udGFpbnMgP1xuXHRcdFx0XHRcdGFkb3duLmNvbnRhaW5zKCBidXAgKSA6XG5cdFx0XHRcdFx0YS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbiAmJiBhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBidXAgKSAmIDE2XG5cdFx0XHQpKTtcblx0XHR9IDpcblx0XHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHRcdGlmICggYiApIHtcblx0XHRcdFx0d2hpbGUgKCAoYiA9IGIucGFyZW50Tm9kZSkgKSB7XG5cdFx0XHRcdFx0aWYgKCBiID09PSBhICkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fTtcblxuXHQvKiBTb3J0aW5nXG5cdC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0gKi9cblxuXHQvLyBEb2N1bWVudCBvcmRlciBzb3J0aW5nXG5cdHNvcnRPcmRlciA9IGhhc0NvbXBhcmUgP1xuXHRmdW5jdGlvbiggYSwgYiApIHtcblxuXHRcdC8vIEZsYWcgZm9yIGR1cGxpY2F0ZSByZW1vdmFsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdC8vIFNvcnQgb24gbWV0aG9kIGV4aXN0ZW5jZSBpZiBvbmx5IG9uZSBpbnB1dCBoYXMgY29tcGFyZURvY3VtZW50UG9zaXRpb25cblx0XHR2YXIgY29tcGFyZSA9ICFhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIC0gIWIuY29tcGFyZURvY3VtZW50UG9zaXRpb247XG5cdFx0aWYgKCBjb21wYXJlICkge1xuXHRcdFx0cmV0dXJuIGNvbXBhcmU7XG5cdFx0fVxuXG5cdFx0Ly8gQ2FsY3VsYXRlIHBvc2l0aW9uIGlmIGJvdGggaW5wdXRzIGJlbG9uZyB0byB0aGUgc2FtZSBkb2N1bWVudFxuXHRcdGNvbXBhcmUgPSAoIGEub3duZXJEb2N1bWVudCB8fCBhICkgPT09ICggYi5vd25lckRvY3VtZW50IHx8IGIgKSA/XG5cdFx0XHRhLmNvbXBhcmVEb2N1bWVudFBvc2l0aW9uKCBiICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugd2Uga25vdyB0aGV5IGFyZSBkaXNjb25uZWN0ZWRcblx0XHRcdDE7XG5cblx0XHQvLyBEaXNjb25uZWN0ZWQgbm9kZXNcblx0XHRpZiAoIGNvbXBhcmUgJiAxIHx8XG5cdFx0XHQoIXN1cHBvcnQuc29ydERldGFjaGVkICYmIGIuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGEgKSA9PT0gY29tcGFyZSkgKSB7XG5cblx0XHRcdC8vIENob29zZSB0aGUgZmlyc3QgZWxlbWVudCB0aGF0IGlzIHJlbGF0ZWQgdG8gb3VyIHByZWZlcnJlZCBkb2N1bWVudFxuXHRcdFx0aWYgKCBhID09PSBkb2N1bWVudCB8fCBhLm93bmVyRG9jdW1lbnQgPT09IHByZWZlcnJlZERvYyAmJiBjb250YWlucyhwcmVmZXJyZWREb2MsIGEpICkge1xuXHRcdFx0XHRyZXR1cm4gLTE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoIGIgPT09IGRvY3VtZW50IHx8IGIub3duZXJEb2N1bWVudCA9PT0gcHJlZmVycmVkRG9jICYmIGNvbnRhaW5zKHByZWZlcnJlZERvYywgYikgKSB7XG5cdFx0XHRcdHJldHVybiAxO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBNYWludGFpbiBvcmlnaW5hbCBvcmRlclxuXHRcdFx0cmV0dXJuIHNvcnRJbnB1dCA/XG5cdFx0XHRcdCggaW5kZXhPZiggc29ydElucHV0LCBhICkgLSBpbmRleE9mKCBzb3J0SW5wdXQsIGIgKSApIDpcblx0XHRcdFx0MDtcblx0XHR9XG5cblx0XHRyZXR1cm4gY29tcGFyZSAmIDQgPyAtMSA6IDE7XG5cdH0gOlxuXHRmdW5jdGlvbiggYSwgYiApIHtcblx0XHQvLyBFeGl0IGVhcmx5IGlmIHRoZSBub2RlcyBhcmUgaWRlbnRpY2FsXG5cdFx0aWYgKCBhID09PSBiICkge1xuXHRcdFx0aGFzRHVwbGljYXRlID0gdHJ1ZTtcblx0XHRcdHJldHVybiAwO1xuXHRcdH1cblxuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGF1cCA9IGEucGFyZW50Tm9kZSxcblx0XHRcdGJ1cCA9IGIucGFyZW50Tm9kZSxcblx0XHRcdGFwID0gWyBhIF0sXG5cdFx0XHRicCA9IFsgYiBdO1xuXG5cdFx0Ly8gUGFyZW50bGVzcyBub2RlcyBhcmUgZWl0aGVyIGRvY3VtZW50cyBvciBkaXNjb25uZWN0ZWRcblx0XHRpZiAoICFhdXAgfHwgIWJ1cCApIHtcblx0XHRcdHJldHVybiBhID09PSBkb2N1bWVudCA/IC0xIDpcblx0XHRcdFx0YiA9PT0gZG9jdW1lbnQgPyAxIDpcblx0XHRcdFx0YXVwID8gLTEgOlxuXHRcdFx0XHRidXAgPyAxIDpcblx0XHRcdFx0c29ydElucHV0ID9cblx0XHRcdFx0KCBpbmRleE9mKCBzb3J0SW5wdXQsIGEgKSAtIGluZGV4T2YoIHNvcnRJbnB1dCwgYiApICkgOlxuXHRcdFx0XHQwO1xuXG5cdFx0Ly8gSWYgdGhlIG5vZGVzIGFyZSBzaWJsaW5ncywgd2UgY2FuIGRvIGEgcXVpY2sgY2hlY2tcblx0XHR9IGVsc2UgaWYgKCBhdXAgPT09IGJ1cCApIHtcblx0XHRcdHJldHVybiBzaWJsaW5nQ2hlY2soIGEsIGIgKTtcblx0XHR9XG5cblx0XHQvLyBPdGhlcndpc2Ugd2UgbmVlZCBmdWxsIGxpc3RzIG9mIHRoZWlyIGFuY2VzdG9ycyBmb3IgY29tcGFyaXNvblxuXHRcdGN1ciA9IGE7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YXAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXHRcdGN1ciA9IGI7XG5cdFx0d2hpbGUgKCAoY3VyID0gY3VyLnBhcmVudE5vZGUpICkge1xuXHRcdFx0YnAudW5zaGlmdCggY3VyICk7XG5cdFx0fVxuXG5cdFx0Ly8gV2FsayBkb3duIHRoZSB0cmVlIGxvb2tpbmcgZm9yIGEgZGlzY3JlcGFuY3lcblx0XHR3aGlsZSAoIGFwW2ldID09PSBicFtpXSApIHtcblx0XHRcdGkrKztcblx0XHR9XG5cblx0XHRyZXR1cm4gaSA/XG5cdFx0XHQvLyBEbyBhIHNpYmxpbmcgY2hlY2sgaWYgdGhlIG5vZGVzIGhhdmUgYSBjb21tb24gYW5jZXN0b3Jcblx0XHRcdHNpYmxpbmdDaGVjayggYXBbaV0sIGJwW2ldICkgOlxuXG5cdFx0XHQvLyBPdGhlcndpc2Ugbm9kZXMgaW4gb3VyIGRvY3VtZW50IHNvcnQgZmlyc3Rcblx0XHRcdGFwW2ldID09PSBwcmVmZXJyZWREb2MgPyAtMSA6XG5cdFx0XHRicFtpXSA9PT0gcHJlZmVycmVkRG9jID8gMSA6XG5cdFx0XHQwO1xuXHR9O1xuXG5cdHJldHVybiBkb2N1bWVudDtcbn07XG5cblNpenpsZS5tYXRjaGVzID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1lbnRzICkge1xuXHRyZXR1cm4gU2l6emxlKCBleHByLCBudWxsLCBudWxsLCBlbGVtZW50cyApO1xufTtcblxuU2l6emxlLm1hdGNoZXNTZWxlY3RvciA9IGZ1bmN0aW9uKCBlbGVtLCBleHByICkge1xuXHQvLyBTZXQgZG9jdW1lbnQgdmFycyBpZiBuZWVkZWRcblx0aWYgKCAoIGVsZW0ub3duZXJEb2N1bWVudCB8fCBlbGVtICkgIT09IGRvY3VtZW50ICkge1xuXHRcdHNldERvY3VtZW50KCBlbGVtICk7XG5cdH1cblxuXHQvLyBNYWtlIHN1cmUgdGhhdCBhdHRyaWJ1dGUgc2VsZWN0b3JzIGFyZSBxdW90ZWRcblx0ZXhwciA9IGV4cHIucmVwbGFjZSggcmF0dHJpYnV0ZVF1b3RlcywgXCI9JyQxJ11cIiApO1xuXG5cdGlmICggc3VwcG9ydC5tYXRjaGVzU2VsZWN0b3IgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHQhY29tcGlsZXJDYWNoZVsgZXhwciArIFwiIFwiIF0gJiZcblx0XHQoICFyYnVnZ3lNYXRjaGVzIHx8ICFyYnVnZ3lNYXRjaGVzLnRlc3QoIGV4cHIgKSApICYmXG5cdFx0KCAhcmJ1Z2d5UVNBICAgICB8fCAhcmJ1Z2d5UVNBLnRlc3QoIGV4cHIgKSApICkge1xuXG5cdFx0dHJ5IHtcblx0XHRcdHZhciByZXQgPSBtYXRjaGVzLmNhbGwoIGVsZW0sIGV4cHIgKTtcblxuXHRcdFx0Ly8gSUUgOSdzIG1hdGNoZXNTZWxlY3RvciByZXR1cm5zIGZhbHNlIG9uIGRpc2Nvbm5lY3RlZCBub2Rlc1xuXHRcdFx0aWYgKCByZXQgfHwgc3VwcG9ydC5kaXNjb25uZWN0ZWRNYXRjaCB8fFxuXHRcdFx0XHRcdC8vIEFzIHdlbGwsIGRpc2Nvbm5lY3RlZCBub2RlcyBhcmUgc2FpZCB0byBiZSBpbiBhIGRvY3VtZW50XG5cdFx0XHRcdFx0Ly8gZnJhZ21lbnQgaW4gSUUgOVxuXHRcdFx0XHRcdGVsZW0uZG9jdW1lbnQgJiYgZWxlbS5kb2N1bWVudC5ub2RlVHlwZSAhPT0gMTEgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0fVxuXG5cdHJldHVybiBTaXp6bGUoIGV4cHIsIGRvY3VtZW50LCBudWxsLCBbIGVsZW0gXSApLmxlbmd0aCA+IDA7XG59O1xuXG5TaXp6bGUuY29udGFpbnMgPSBmdW5jdGlvbiggY29udGV4dCwgZWxlbSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBjb250ZXh0Lm93bmVyRG9jdW1lbnQgfHwgY29udGV4dCApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggY29udGV4dCApO1xuXHR9XG5cdHJldHVybiBjb250YWlucyggY29udGV4dCwgZWxlbSApO1xufTtcblxuU2l6emxlLmF0dHIgPSBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0Ly8gU2V0IGRvY3VtZW50IHZhcnMgaWYgbmVlZGVkXG5cdGlmICggKCBlbGVtLm93bmVyRG9jdW1lbnQgfHwgZWxlbSApICE9PSBkb2N1bWVudCApIHtcblx0XHRzZXREb2N1bWVudCggZWxlbSApO1xuXHR9XG5cblx0dmFyIGZuID0gRXhwci5hdHRySGFuZGxlWyBuYW1lLnRvTG93ZXJDYXNlKCkgXSxcblx0XHQvLyBEb24ndCBnZXQgZm9vbGVkIGJ5IE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoalF1ZXJ5ICMxMzgwNylcblx0XHR2YWwgPSBmbiAmJiBoYXNPd24uY2FsbCggRXhwci5hdHRySGFuZGxlLCBuYW1lLnRvTG93ZXJDYXNlKCkgKSA/XG5cdFx0XHRmbiggZWxlbSwgbmFtZSwgIWRvY3VtZW50SXNIVE1MICkgOlxuXHRcdFx0dW5kZWZpbmVkO1xuXG5cdHJldHVybiB2YWwgIT09IHVuZGVmaW5lZCA/XG5cdFx0dmFsIDpcblx0XHRzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWRvY3VtZW50SXNIVE1MID9cblx0XHRcdGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lICkgOlxuXHRcdFx0KHZhbCA9IGVsZW0uZ2V0QXR0cmlidXRlTm9kZShuYW1lKSkgJiYgdmFsLnNwZWNpZmllZCA/XG5cdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG59O1xuXG5TaXp6bGUuZXJyb3IgPSBmdW5jdGlvbiggbXNnICkge1xuXHR0aHJvdyBuZXcgRXJyb3IoIFwiU3ludGF4IGVycm9yLCB1bnJlY29nbml6ZWQgZXhwcmVzc2lvbjogXCIgKyBtc2cgKTtcbn07XG5cbi8qKlxuICogRG9jdW1lbnQgc29ydGluZyBhbmQgcmVtb3ZpbmcgZHVwbGljYXRlc1xuICogQHBhcmFtIHtBcnJheUxpa2V9IHJlc3VsdHNcbiAqL1xuU2l6emxlLnVuaXF1ZVNvcnQgPSBmdW5jdGlvbiggcmVzdWx0cyApIHtcblx0dmFyIGVsZW0sXG5cdFx0ZHVwbGljYXRlcyA9IFtdLFxuXHRcdGogPSAwLFxuXHRcdGkgPSAwO1xuXG5cdC8vIFVubGVzcyB3ZSAqa25vdyogd2UgY2FuIGRldGVjdCBkdXBsaWNhdGVzLCBhc3N1bWUgdGhlaXIgcHJlc2VuY2Vcblx0aGFzRHVwbGljYXRlID0gIXN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcztcblx0c29ydElucHV0ID0gIXN1cHBvcnQuc29ydFN0YWJsZSAmJiByZXN1bHRzLnNsaWNlKCAwICk7XG5cdHJlc3VsdHMuc29ydCggc29ydE9yZGVyICk7XG5cblx0aWYgKCBoYXNEdXBsaWNhdGUgKSB7XG5cdFx0d2hpbGUgKCAoZWxlbSA9IHJlc3VsdHNbaSsrXSkgKSB7XG5cdFx0XHRpZiAoIGVsZW0gPT09IHJlc3VsdHNbIGkgXSApIHtcblx0XHRcdFx0aiA9IGR1cGxpY2F0ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHR3aGlsZSAoIGotLSApIHtcblx0XHRcdHJlc3VsdHMuc3BsaWNlKCBkdXBsaWNhdGVzWyBqIF0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBDbGVhciBpbnB1dCBhZnRlciBzb3J0aW5nIHRvIHJlbGVhc2Ugb2JqZWN0c1xuXHQvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2pxdWVyeS9zaXp6bGUvcHVsbC8yMjVcblx0c29ydElucHV0ID0gbnVsbDtcblxuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8qKlxuICogVXRpbGl0eSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgdGV4dCB2YWx1ZSBvZiBhbiBhcnJheSBvZiBET00gbm9kZXNcbiAqIEBwYXJhbSB7QXJyYXl8RWxlbWVudH0gZWxlbVxuICovXG5nZXRUZXh0ID0gU2l6emxlLmdldFRleHQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0dmFyIG5vZGUsXG5cdFx0cmV0ID0gXCJcIixcblx0XHRpID0gMCxcblx0XHRub2RlVHlwZSA9IGVsZW0ubm9kZVR5cGU7XG5cblx0aWYgKCAhbm9kZVR5cGUgKSB7XG5cdFx0Ly8gSWYgbm8gbm9kZVR5cGUsIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmUgYW4gYXJyYXlcblx0XHR3aGlsZSAoIChub2RlID0gZWxlbVtpKytdKSApIHtcblx0XHRcdC8vIERvIG5vdCB0cmF2ZXJzZSBjb21tZW50IG5vZGVzXG5cdFx0XHRyZXQgKz0gZ2V0VGV4dCggbm9kZSApO1xuXHRcdH1cblx0fSBlbHNlIGlmICggbm9kZVR5cGUgPT09IDEgfHwgbm9kZVR5cGUgPT09IDkgfHwgbm9kZVR5cGUgPT09IDExICkge1xuXHRcdC8vIFVzZSB0ZXh0Q29udGVudCBmb3IgZWxlbWVudHNcblx0XHQvLyBpbm5lclRleHQgdXNhZ2UgcmVtb3ZlZCBmb3IgY29uc2lzdGVuY3kgb2YgbmV3IGxpbmVzIChqUXVlcnkgIzExMTUzKVxuXHRcdGlmICggdHlwZW9mIGVsZW0udGV4dENvbnRlbnQgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS50ZXh0Q29udGVudDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Ly8gVHJhdmVyc2UgaXRzIGNoaWxkcmVuXG5cdFx0XHRmb3IgKCBlbGVtID0gZWxlbS5maXJzdENoaWxkOyBlbGVtOyBlbGVtID0gZWxlbS5uZXh0U2libGluZyApIHtcblx0XHRcdFx0cmV0ICs9IGdldFRleHQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9XG5cdH0gZWxzZSBpZiAoIG5vZGVUeXBlID09PSAzIHx8IG5vZGVUeXBlID09PSA0ICkge1xuXHRcdHJldHVybiBlbGVtLm5vZGVWYWx1ZTtcblx0fVxuXHQvLyBEbyBub3QgaW5jbHVkZSBjb21tZW50IG9yIHByb2Nlc3NpbmcgaW5zdHJ1Y3Rpb24gbm9kZXNcblxuXHRyZXR1cm4gcmV0O1xufTtcblxuRXhwciA9IFNpenpsZS5zZWxlY3RvcnMgPSB7XG5cblx0Ly8gQ2FuIGJlIGFkanVzdGVkIGJ5IHRoZSB1c2VyXG5cdGNhY2hlTGVuZ3RoOiA1MCxcblxuXHRjcmVhdGVQc2V1ZG86IG1hcmtGdW5jdGlvbixcblxuXHRtYXRjaDogbWF0Y2hFeHByLFxuXG5cdGF0dHJIYW5kbGU6IHt9LFxuXG5cdGZpbmQ6IHt9LFxuXG5cdHJlbGF0aXZlOiB7XG5cdFx0XCI+XCI6IHsgZGlyOiBcInBhcmVudE5vZGVcIiwgZmlyc3Q6IHRydWUgfSxcblx0XHRcIiBcIjogeyBkaXI6IFwicGFyZW50Tm9kZVwiIH0sXG5cdFx0XCIrXCI6IHsgZGlyOiBcInByZXZpb3VzU2libGluZ1wiLCBmaXJzdDogdHJ1ZSB9LFxuXHRcdFwiflwiOiB7IGRpcjogXCJwcmV2aW91c1NpYmxpbmdcIiB9XG5cdH0sXG5cblx0cHJlRmlsdGVyOiB7XG5cdFx0XCJBVFRSXCI6IGZ1bmN0aW9uKCBtYXRjaCApIHtcblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0Ly8gTW92ZSB0aGUgZ2l2ZW4gdmFsdWUgdG8gbWF0Y2hbM10gd2hldGhlciBxdW90ZWQgb3IgdW5xdW90ZWRcblx0XHRcdG1hdGNoWzNdID0gKCBtYXRjaFszXSB8fCBtYXRjaFs0XSB8fCBtYXRjaFs1XSB8fCBcIlwiICkucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsyXSA9PT0gXCJ+PVwiICkge1xuXHRcdFx0XHRtYXRjaFszXSA9IFwiIFwiICsgbWF0Y2hbM10gKyBcIiBcIjtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCA0ICk7XG5cdFx0fSxcblxuXHRcdFwiQ0hJTERcIjogZnVuY3Rpb24oIG1hdGNoICkge1xuXHRcdFx0LyogbWF0Y2hlcyBmcm9tIG1hdGNoRXhwcltcIkNISUxEXCJdXG5cdFx0XHRcdDEgdHlwZSAob25seXxudGh8Li4uKVxuXHRcdFx0XHQyIHdoYXQgKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdDMgYXJndW1lbnQgKGV2ZW58b2RkfFxcZCp8XFxkKm4oWystXVxcZCspP3wuLi4pXG5cdFx0XHRcdDQgeG4tY29tcG9uZW50IG9mIHhuK3kgYXJndW1lbnQgKFsrLV0/XFxkKm58KVxuXHRcdFx0XHQ1IHNpZ24gb2YgeG4tY29tcG9uZW50XG5cdFx0XHRcdDYgeCBvZiB4bi1jb21wb25lbnRcblx0XHRcdFx0NyBzaWduIG9mIHktY29tcG9uZW50XG5cdFx0XHRcdDggeSBvZiB5LWNvbXBvbmVudFxuXHRcdFx0Ki9cblx0XHRcdG1hdGNoWzFdID0gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKTtcblxuXHRcdFx0aWYgKCBtYXRjaFsxXS5zbGljZSggMCwgMyApID09PSBcIm50aFwiICkge1xuXHRcdFx0XHQvLyBudGgtKiByZXF1aXJlcyBhcmd1bWVudFxuXHRcdFx0XHRpZiAoICFtYXRjaFszXSApIHtcblx0XHRcdFx0XHRTaXp6bGUuZXJyb3IoIG1hdGNoWzBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBudW1lcmljIHggYW5kIHkgcGFyYW1ldGVycyBmb3IgRXhwci5maWx0ZXIuQ0hJTERcblx0XHRcdFx0Ly8gcmVtZW1iZXIgdGhhdCBmYWxzZS90cnVlIGNhc3QgcmVzcGVjdGl2ZWx5IHRvIDAvMVxuXHRcdFx0XHRtYXRjaFs0XSA9ICsoIG1hdGNoWzRdID8gbWF0Y2hbNV0gKyAobWF0Y2hbNl0gfHwgMSkgOiAyICogKCBtYXRjaFszXSA9PT0gXCJldmVuXCIgfHwgbWF0Y2hbM10gPT09IFwib2RkXCIgKSApO1xuXHRcdFx0XHRtYXRjaFs1XSA9ICsoICggbWF0Y2hbN10gKyBtYXRjaFs4XSApIHx8IG1hdGNoWzNdID09PSBcIm9kZFwiICk7XG5cblx0XHRcdC8vIG90aGVyIHR5cGVzIHByb2hpYml0IGFyZ3VtZW50c1xuXHRcdFx0fSBlbHNlIGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdFNpenpsZS5lcnJvciggbWF0Y2hbMF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggbWF0Y2ggKSB7XG5cdFx0XHR2YXIgZXhjZXNzLFxuXHRcdFx0XHR1bnF1b3RlZCA9ICFtYXRjaFs2XSAmJiBtYXRjaFsyXTtcblxuXHRcdFx0aWYgKCBtYXRjaEV4cHJbXCJDSElMRFwiXS50ZXN0KCBtYXRjaFswXSApICkge1xuXHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWNjZXB0IHF1b3RlZCBhcmd1bWVudHMgYXMtaXNcblx0XHRcdGlmICggbWF0Y2hbM10gKSB7XG5cdFx0XHRcdG1hdGNoWzJdID0gbWF0Y2hbNF0gfHwgbWF0Y2hbNV0gfHwgXCJcIjtcblxuXHRcdFx0Ly8gU3RyaXAgZXhjZXNzIGNoYXJhY3RlcnMgZnJvbSB1bnF1b3RlZCBhcmd1bWVudHNcblx0XHRcdH0gZWxzZSBpZiAoIHVucXVvdGVkICYmIHJwc2V1ZG8udGVzdCggdW5xdW90ZWQgKSAmJlxuXHRcdFx0XHQvLyBHZXQgZXhjZXNzIGZyb20gdG9rZW5pemUgKHJlY3Vyc2l2ZWx5KVxuXHRcdFx0XHQoZXhjZXNzID0gdG9rZW5pemUoIHVucXVvdGVkLCB0cnVlICkpICYmXG5cdFx0XHRcdC8vIGFkdmFuY2UgdG8gdGhlIG5leHQgY2xvc2luZyBwYXJlbnRoZXNpc1xuXHRcdFx0XHQoZXhjZXNzID0gdW5xdW90ZWQuaW5kZXhPZiggXCIpXCIsIHVucXVvdGVkLmxlbmd0aCAtIGV4Y2VzcyApIC0gdW5xdW90ZWQubGVuZ3RoKSApIHtcblxuXHRcdFx0XHQvLyBleGNlc3MgaXMgYSBuZWdhdGl2ZSBpbmRleFxuXHRcdFx0XHRtYXRjaFswXSA9IG1hdGNoWzBdLnNsaWNlKCAwLCBleGNlc3MgKTtcblx0XHRcdFx0bWF0Y2hbMl0gPSB1bnF1b3RlZC5zbGljZSggMCwgZXhjZXNzICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldHVybiBvbmx5IGNhcHR1cmVzIG5lZWRlZCBieSB0aGUgcHNldWRvIGZpbHRlciBtZXRob2QgKHR5cGUgYW5kIGFyZ3VtZW50KVxuXHRcdFx0cmV0dXJuIG1hdGNoLnNsaWNlKCAwLCAzICk7XG5cdFx0fVxuXHR9LFxuXG5cdGZpbHRlcjoge1xuXG5cdFx0XCJUQUdcIjogZnVuY3Rpb24oIG5vZGVOYW1lU2VsZWN0b3IgKSB7XG5cdFx0XHR2YXIgbm9kZU5hbWUgPSBub2RlTmFtZVNlbGVjdG9yLnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICkudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiBub2RlTmFtZVNlbGVjdG9yID09PSBcIipcIiA/XG5cdFx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHJ1ZTsgfSA6XG5cdFx0XHRcdGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbm9kZU5hbWU7XG5cdFx0XHRcdH07XG5cdFx0fSxcblxuXHRcdFwiQ0xBU1NcIjogZnVuY3Rpb24oIGNsYXNzTmFtZSApIHtcblx0XHRcdHZhciBwYXR0ZXJuID0gY2xhc3NDYWNoZVsgY2xhc3NOYW1lICsgXCIgXCIgXTtcblxuXHRcdFx0cmV0dXJuIHBhdHRlcm4gfHxcblx0XHRcdFx0KHBhdHRlcm4gPSBuZXcgUmVnRXhwKCBcIihefFwiICsgd2hpdGVzcGFjZSArIFwiKVwiICsgY2xhc3NOYW1lICsgXCIoXCIgKyB3aGl0ZXNwYWNlICsgXCJ8JClcIiApKSAmJlxuXHRcdFx0XHRjbGFzc0NhY2hlKCBjbGFzc05hbWUsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHRcdHJldHVybiBwYXR0ZXJuLnRlc3QoIHR5cGVvZiBlbGVtLmNsYXNzTmFtZSA9PT0gXCJzdHJpbmdcIiAmJiBlbGVtLmNsYXNzTmFtZSB8fCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgIT09IFwidW5kZWZpbmVkXCIgJiYgZWxlbS5nZXRBdHRyaWJ1dGUoXCJjbGFzc1wiKSB8fCBcIlwiICk7XG5cdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRcIkFUVFJcIjogZnVuY3Rpb24oIG5hbWUsIG9wZXJhdG9yLCBjaGVjayApIHtcblx0XHRcdHJldHVybiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdFx0dmFyIHJlc3VsdCA9IFNpenpsZS5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHRcdFx0aWYgKCByZXN1bHQgPT0gbnVsbCApIHtcblx0XHRcdFx0XHRyZXR1cm4gb3BlcmF0b3IgPT09IFwiIT1cIjtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoICFvcGVyYXRvciApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJlc3VsdCArPSBcIlwiO1xuXG5cdFx0XHRcdHJldHVybiBvcGVyYXRvciA9PT0gXCI9XCIgPyByZXN1bHQgPT09IGNoZWNrIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIhPVwiID8gcmVzdWx0ICE9PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiXj1cIiA/IGNoZWNrICYmIHJlc3VsdC5pbmRleE9mKCBjaGVjayApID09PSAwIDpcblx0XHRcdFx0XHRvcGVyYXRvciA9PT0gXCIqPVwiID8gY2hlY2sgJiYgcmVzdWx0LmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwiJD1cIiA/IGNoZWNrICYmIHJlc3VsdC5zbGljZSggLWNoZWNrLmxlbmd0aCApID09PSBjaGVjayA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifj1cIiA/ICggXCIgXCIgKyByZXN1bHQucmVwbGFjZSggcndoaXRlc3BhY2UsIFwiIFwiICkgKyBcIiBcIiApLmluZGV4T2YoIGNoZWNrICkgPiAtMSA6XG5cdFx0XHRcdFx0b3BlcmF0b3IgPT09IFwifD1cIiA/IHJlc3VsdCA9PT0gY2hlY2sgfHwgcmVzdWx0LnNsaWNlKCAwLCBjaGVjay5sZW5ndGggKyAxICkgPT09IGNoZWNrICsgXCItXCIgOlxuXHRcdFx0XHRcdGZhbHNlO1xuXHRcdFx0fTtcblx0XHR9LFxuXG5cdFx0XCJDSElMRFwiOiBmdW5jdGlvbiggdHlwZSwgd2hhdCwgYXJndW1lbnQsIGZpcnN0LCBsYXN0ICkge1xuXHRcdFx0dmFyIHNpbXBsZSA9IHR5cGUuc2xpY2UoIDAsIDMgKSAhPT0gXCJudGhcIixcblx0XHRcdFx0Zm9yd2FyZCA9IHR5cGUuc2xpY2UoIC00ICkgIT09IFwibGFzdFwiLFxuXHRcdFx0XHRvZlR5cGUgPSB3aGF0ID09PSBcIm9mLXR5cGVcIjtcblxuXHRcdFx0cmV0dXJuIGZpcnN0ID09PSAxICYmIGxhc3QgPT09IDAgP1xuXG5cdFx0XHRcdC8vIFNob3J0Y3V0IGZvciA6bnRoLSoobilcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0cmV0dXJuICEhZWxlbS5wYXJlbnROb2RlO1xuXHRcdFx0XHR9IDpcblxuXHRcdFx0XHRmdW5jdGlvbiggZWxlbSwgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBjYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsIG5vZGUsIG5vZGVJbmRleCwgc3RhcnQsXG5cdFx0XHRcdFx0XHRkaXIgPSBzaW1wbGUgIT09IGZvcndhcmQgPyBcIm5leHRTaWJsaW5nXCIgOiBcInByZXZpb3VzU2libGluZ1wiLFxuXHRcdFx0XHRcdFx0cGFyZW50ID0gZWxlbS5wYXJlbnROb2RlLFxuXHRcdFx0XHRcdFx0bmFtZSA9IG9mVHlwZSAmJiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRcdFx0XHR1c2VDYWNoZSA9ICF4bWwgJiYgIW9mVHlwZSxcblx0XHRcdFx0XHRcdGRpZmYgPSBmYWxzZTtcblxuXHRcdFx0XHRcdGlmICggcGFyZW50ICkge1xuXG5cdFx0XHRcdFx0XHQvLyA6KGZpcnN0fGxhc3R8b25seSktKGNoaWxkfG9mLXR5cGUpXG5cdFx0XHRcdFx0XHRpZiAoIHNpbXBsZSApIHtcblx0XHRcdFx0XHRcdFx0d2hpbGUgKCBkaXIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bm9kZSA9IGVsZW07XG5cdFx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9IG5vZGVbIGRpciBdKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGlmICggb2ZUeXBlID9cblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpID09PSBuYW1lIDpcblx0XHRcdFx0XHRcdFx0XHRcdFx0bm9kZS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdC8vIFJldmVyc2UgZGlyZWN0aW9uIGZvciA6b25seS0qIChpZiB3ZSBoYXZlbid0IHlldCBkb25lIHNvKVxuXHRcdFx0XHRcdFx0XHRcdHN0YXJ0ID0gZGlyID0gdHlwZSA9PT0gXCJvbmx5XCIgJiYgIXN0YXJ0ICYmIFwibmV4dFNpYmxpbmdcIjtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0c3RhcnQgPSBbIGZvcndhcmQgPyBwYXJlbnQuZmlyc3RDaGlsZCA6IHBhcmVudC5sYXN0Q2hpbGQgXTtcblxuXHRcdFx0XHRcdFx0Ly8gbm9uLXhtbCA6bnRoLWNoaWxkKC4uLikgc3RvcmVzIGNhY2hlIGRhdGEgb24gYHBhcmVudGBcblx0XHRcdFx0XHRcdGlmICggZm9yd2FyZCAmJiB1c2VDYWNoZSApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBTZWVrIGBlbGVtYCBmcm9tIGEgcHJldmlvdXNseS1jYWNoZWQgaW5kZXhcblxuXHRcdFx0XHRcdFx0XHQvLyAuLi5pbiBhIGd6aXAtZnJpZW5kbHkgd2F5XG5cdFx0XHRcdFx0XHRcdG5vZGUgPSBwYXJlbnQ7XG5cdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdC8vIERlZmVuZCBhZ2FpbnN0IGNsb25lZCBhdHRyb3BlcnRpZXMgKGpRdWVyeSBnaC0xNzA5KVxuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0Y2FjaGUgPSB1bmlxdWVDYWNoZVsgdHlwZSBdIHx8IFtdO1xuXHRcdFx0XHRcdFx0XHRub2RlSW5kZXggPSBjYWNoZVsgMCBdID09PSBkaXJydW5zICYmIGNhY2hlWyAxIF07XG5cdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXggJiYgY2FjaGVbIDIgXTtcblx0XHRcdFx0XHRcdFx0bm9kZSA9IG5vZGVJbmRleCAmJiBwYXJlbnQuY2hpbGROb2Rlc1sgbm9kZUluZGV4IF07XG5cblx0XHRcdFx0XHRcdFx0d2hpbGUgKCAobm9kZSA9ICsrbm9kZUluZGV4ICYmIG5vZGUgJiYgbm9kZVsgZGlyIF0gfHxcblxuXHRcdFx0XHRcdFx0XHRcdC8vIEZhbGxiYWNrIHRvIHNlZWtpbmcgYGVsZW1gIGZyb20gdGhlIHN0YXJ0XG5cdFx0XHRcdFx0XHRcdFx0KGRpZmYgPSBub2RlSW5kZXggPSAwKSB8fCBzdGFydC5wb3AoKSkgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBXaGVuIGZvdW5kLCBjYWNoZSBpbmRleGVzIG9uIGBwYXJlbnRgIGFuZCBicmVha1xuXHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZS5ub2RlVHlwZSA9PT0gMSAmJiArK2RpZmYgJiYgbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIG5vZGVJbmRleCwgZGlmZiBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdC8vIFVzZSBwcmV2aW91c2x5LWNhY2hlZCBlbGVtZW50IGluZGV4IGlmIGF2YWlsYWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdC8vIC4uLmluIGEgZ3ppcC1mcmllbmRseSB3YXlcblx0XHRcdFx0XHRcdFx0XHRub2RlID0gZWxlbTtcblx0XHRcdFx0XHRcdFx0XHRvdXRlckNhY2hlID0gbm9kZVsgZXhwYW5kbyBdIHx8IChub2RlWyBleHBhbmRvIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gRGVmZW5kIGFnYWluc3QgY2xvbmVkIGF0dHJvcGVydGllcyAoalF1ZXJ5IGdoLTE3MDkpXG5cdFx0XHRcdFx0XHRcdFx0dW5pcXVlQ2FjaGUgPSBvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gfHxcblx0XHRcdFx0XHRcdFx0XHRcdChvdXRlckNhY2hlWyBub2RlLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdFx0XHRjYWNoZSA9IHVuaXF1ZUNhY2hlWyB0eXBlIF0gfHwgW107XG5cdFx0XHRcdFx0XHRcdFx0bm9kZUluZGV4ID0gY2FjaGVbIDAgXSA9PT0gZGlycnVucyAmJiBjYWNoZVsgMSBdO1xuXHRcdFx0XHRcdFx0XHRcdGRpZmYgPSBub2RlSW5kZXg7XG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHQvLyB4bWwgOm50aC1jaGlsZCguLi4pXG5cdFx0XHRcdFx0XHRcdC8vIG9yIDpudGgtbGFzdC1jaGlsZCguLi4pIG9yIDpudGgoLWxhc3QpPy1vZi10eXBlKC4uLilcblx0XHRcdFx0XHRcdFx0aWYgKCBkaWZmID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRcdFx0XHQvLyBVc2UgdGhlIHNhbWUgbG9vcCBhcyBhYm92ZSB0byBzZWVrIGBlbGVtYCBmcm9tIHRoZSBzdGFydFxuXHRcdFx0XHRcdFx0XHRcdHdoaWxlICggKG5vZGUgPSArK25vZGVJbmRleCAmJiBub2RlICYmIG5vZGVbIGRpciBdIHx8XG5cdFx0XHRcdFx0XHRcdFx0XHQoZGlmZiA9IG5vZGVJbmRleCA9IDApIHx8IHN0YXJ0LnBvcCgpKSApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0aWYgKCAoIG9mVHlwZSA/XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gbmFtZSA6XG5cdFx0XHRcdFx0XHRcdFx0XHRcdG5vZGUubm9kZVR5cGUgPT09IDEgKSAmJlxuXHRcdFx0XHRcdFx0XHRcdFx0XHQrK2RpZmYgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Ly8gQ2FjaGUgdGhlIGluZGV4IG9mIGVhY2ggZW5jb3VudGVyZWQgZWxlbWVudFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRpZiAoIHVzZUNhY2hlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdG91dGVyQ2FjaGUgPSBub2RlWyBleHBhbmRvIF0gfHwgKG5vZGVbIGV4cGFuZG8gXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFIDw5IG9ubHlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZSA9IG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdFx0KG91dGVyQ2FjaGVbIG5vZGUudW5pcXVlSUQgXSA9IHt9KTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlWyB0eXBlIF0gPSBbIGRpcnJ1bnMsIGRpZmYgXTtcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdGlmICggbm9kZSA9PT0gZWxlbSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHQvLyBJbmNvcnBvcmF0ZSB0aGUgb2Zmc2V0LCB0aGVuIGNoZWNrIGFnYWluc3QgY3ljbGUgc2l6ZVxuXHRcdFx0XHRcdFx0ZGlmZiAtPSBsYXN0O1xuXHRcdFx0XHRcdFx0cmV0dXJuIGRpZmYgPT09IGZpcnN0IHx8ICggZGlmZiAlIGZpcnN0ID09PSAwICYmIGRpZmYgLyBmaXJzdCA+PSAwICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9O1xuXHRcdH0sXG5cblx0XHRcIlBTRVVET1wiOiBmdW5jdGlvbiggcHNldWRvLCBhcmd1bWVudCApIHtcblx0XHRcdC8vIHBzZXVkby1jbGFzcyBuYW1lcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZVxuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvc2VsZWN0b3JzLyNwc2V1ZG8tY2xhc3Nlc1xuXHRcdFx0Ly8gUHJpb3JpdGl6ZSBieSBjYXNlIHNlbnNpdGl2aXR5IGluIGNhc2UgY3VzdG9tIHBzZXVkb3MgYXJlIGFkZGVkIHdpdGggdXBwZXJjYXNlIGxldHRlcnNcblx0XHRcdC8vIFJlbWVtYmVyIHRoYXQgc2V0RmlsdGVycyBpbmhlcml0cyBmcm9tIHBzZXVkb3Ncblx0XHRcdHZhciBhcmdzLFxuXHRcdFx0XHRmbiA9IEV4cHIucHNldWRvc1sgcHNldWRvIF0gfHwgRXhwci5zZXRGaWx0ZXJzWyBwc2V1ZG8udG9Mb3dlckNhc2UoKSBdIHx8XG5cdFx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIHBzZXVkbzogXCIgKyBwc2V1ZG8gKTtcblxuXHRcdFx0Ly8gVGhlIHVzZXIgbWF5IHVzZSBjcmVhdGVQc2V1ZG8gdG8gaW5kaWNhdGUgdGhhdFxuXHRcdFx0Ly8gYXJndW1lbnRzIGFyZSBuZWVkZWQgdG8gY3JlYXRlIHRoZSBmaWx0ZXIgZnVuY3Rpb25cblx0XHRcdC8vIGp1c3QgYXMgU2l6emxlIGRvZXNcblx0XHRcdGlmICggZm5bIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0cmV0dXJuIGZuKCBhcmd1bWVudCApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBCdXQgbWFpbnRhaW4gc3VwcG9ydCBmb3Igb2xkIHNpZ25hdHVyZXNcblx0XHRcdGlmICggZm4ubGVuZ3RoID4gMSApIHtcblx0XHRcdFx0YXJncyA9IFsgcHNldWRvLCBwc2V1ZG8sIFwiXCIsIGFyZ3VtZW50IF07XG5cdFx0XHRcdHJldHVybiBFeHByLnNldEZpbHRlcnMuaGFzT3duUHJvcGVydHkoIHBzZXVkby50b0xvd2VyQ2FzZSgpICkgP1xuXHRcdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcyApIHtcblx0XHRcdFx0XHRcdHZhciBpZHgsXG5cdFx0XHRcdFx0XHRcdG1hdGNoZWQgPSBmbiggc2VlZCwgYXJndW1lbnQgKSxcblx0XHRcdFx0XHRcdFx0aSA9IG1hdGNoZWQubGVuZ3RoO1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0XHRcdGlkeCA9IGluZGV4T2YoIHNlZWQsIG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdFx0c2VlZFsgaWR4IF0gPSAhKCBtYXRjaGVzWyBpZHggXSA9IG1hdGNoZWRbaV0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9KSA6XG5cdFx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZm4oIGVsZW0sIDAsIGFyZ3MgKTtcblx0XHRcdFx0XHR9O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZm47XG5cdFx0fVxuXHR9LFxuXG5cdHBzZXVkb3M6IHtcblx0XHQvLyBQb3RlbnRpYWxseSBjb21wbGV4IHBzZXVkb3Ncblx0XHRcIm5vdFwiOiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdFx0Ly8gVHJpbSB0aGUgc2VsZWN0b3IgcGFzc2VkIHRvIGNvbXBpbGVcblx0XHRcdC8vIHRvIGF2b2lkIHRyZWF0aW5nIGxlYWRpbmcgYW5kIHRyYWlsaW5nXG5cdFx0XHQvLyBzcGFjZXMgYXMgY29tYmluYXRvcnNcblx0XHRcdHZhciBpbnB1dCA9IFtdLFxuXHRcdFx0XHRyZXN1bHRzID0gW10sXG5cdFx0XHRcdG1hdGNoZXIgPSBjb21waWxlKCBzZWxlY3Rvci5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICkgKTtcblxuXHRcdFx0cmV0dXJuIG1hdGNoZXJbIGV4cGFuZG8gXSA/XG5cdFx0XHRcdG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VlZCwgbWF0Y2hlcywgY29udGV4dCwgeG1sICkge1xuXHRcdFx0XHRcdHZhciBlbGVtLFxuXHRcdFx0XHRcdFx0dW5tYXRjaGVkID0gbWF0Y2hlciggc2VlZCwgbnVsbCwgeG1sLCBbXSApLFxuXHRcdFx0XHRcdFx0aSA9IHNlZWQubGVuZ3RoO1xuXG5cdFx0XHRcdFx0Ly8gTWF0Y2ggZWxlbWVudHMgdW5tYXRjaGVkIGJ5IGBtYXRjaGVyYFxuXHRcdFx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRcdFx0aWYgKCAoZWxlbSA9IHVubWF0Y2hlZFtpXSkgKSB7XG5cdFx0XHRcdFx0XHRcdHNlZWRbaV0gPSAhKG1hdGNoZXNbaV0gPSBlbGVtKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pIDpcblx0XHRcdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdFx0XHRpbnB1dFswXSA9IGVsZW07XG5cdFx0XHRcdFx0bWF0Y2hlciggaW5wdXQsIG51bGwsIHhtbCwgcmVzdWx0cyApO1xuXHRcdFx0XHRcdC8vIERvbid0IGtlZXAgdGhlIGVsZW1lbnQgKGlzc3VlICMyOTkpXG5cdFx0XHRcdFx0aW5wdXRbMF0gPSBudWxsO1xuXHRcdFx0XHRcdHJldHVybiAhcmVzdWx0cy5wb3AoKTtcblx0XHRcdFx0fTtcblx0XHR9KSxcblxuXHRcdFwiaGFzXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiBTaXp6bGUoIHNlbGVjdG9yLCBlbGVtICkubGVuZ3RoID4gMDtcblx0XHRcdH07XG5cdFx0fSksXG5cblx0XHRcImNvbnRhaW5zXCI6IG1hcmtGdW5jdGlvbihmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdHRleHQgPSB0ZXh0LnJlcGxhY2UoIHJ1bmVzY2FwZSwgZnVuZXNjYXBlICk7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0udGV4dENvbnRlbnQgfHwgZWxlbS5pbm5lclRleHQgfHwgZ2V0VGV4dCggZWxlbSApICkuaW5kZXhPZiggdGV4dCApID4gLTE7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gXCJXaGV0aGVyIGFuIGVsZW1lbnQgaXMgcmVwcmVzZW50ZWQgYnkgYSA6bGFuZygpIHNlbGVjdG9yXG5cdFx0Ly8gaXMgYmFzZWQgc29sZWx5IG9uIHRoZSBlbGVtZW50J3MgbGFuZ3VhZ2UgdmFsdWVcblx0XHQvLyBiZWluZyBlcXVhbCB0byB0aGUgaWRlbnRpZmllciBDLFxuXHRcdC8vIG9yIGJlZ2lubmluZyB3aXRoIHRoZSBpZGVudGlmaWVyIEMgaW1tZWRpYXRlbHkgZm9sbG93ZWQgYnkgXCItXCIuXG5cdFx0Ly8gVGhlIG1hdGNoaW5nIG9mIEMgYWdhaW5zdCB0aGUgZWxlbWVudCdzIGxhbmd1YWdlIHZhbHVlIGlzIHBlcmZvcm1lZCBjYXNlLWluc2Vuc2l0aXZlbHkuXG5cdFx0Ly8gVGhlIGlkZW50aWZpZXIgQyBkb2VzIG5vdCBoYXZlIHRvIGJlIGEgdmFsaWQgbGFuZ3VhZ2UgbmFtZS5cIlxuXHRcdC8vIGh0dHA6Ly93d3cudzMub3JnL1RSL3NlbGVjdG9ycy8jbGFuZy1wc2V1ZG9cblx0XHRcImxhbmdcIjogbWFya0Z1bmN0aW9uKCBmdW5jdGlvbiggbGFuZyApIHtcblx0XHRcdC8vIGxhbmcgdmFsdWUgbXVzdCBiZSBhIHZhbGlkIGlkZW50aWZpZXJcblx0XHRcdGlmICggIXJpZGVudGlmaWVyLnRlc3QobGFuZyB8fCBcIlwiKSApIHtcblx0XHRcdFx0U2l6emxlLmVycm9yKCBcInVuc3VwcG9ydGVkIGxhbmc6IFwiICsgbGFuZyApO1xuXHRcdFx0fVxuXHRcdFx0bGFuZyA9IGxhbmcucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKS50b0xvd2VyQ2FzZSgpO1xuXHRcdFx0cmV0dXJuIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgZWxlbUxhbmc7XG5cdFx0XHRcdGRvIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtTGFuZyA9IGRvY3VtZW50SXNIVE1MID9cblx0XHRcdFx0XHRcdGVsZW0ubGFuZyA6XG5cdFx0XHRcdFx0XHRlbGVtLmdldEF0dHJpYnV0ZShcInhtbDpsYW5nXCIpIHx8IGVsZW0uZ2V0QXR0cmlidXRlKFwibGFuZ1wiKSkgKSB7XG5cblx0XHRcdFx0XHRcdGVsZW1MYW5nID0gZWxlbUxhbmcudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRcdHJldHVybiBlbGVtTGFuZyA9PT0gbGFuZyB8fCBlbGVtTGFuZy5pbmRleE9mKCBsYW5nICsgXCItXCIgKSA9PT0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gd2hpbGUgKCAoZWxlbSA9IGVsZW0ucGFyZW50Tm9kZSkgJiYgZWxlbS5ub2RlVHlwZSA9PT0gMSApO1xuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9O1xuXHRcdH0pLFxuXG5cdFx0Ly8gTWlzY2VsbGFuZW91c1xuXHRcdFwidGFyZ2V0XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIGhhc2ggPSB3aW5kb3cubG9jYXRpb24gJiYgd2luZG93LmxvY2F0aW9uLmhhc2g7XG5cdFx0XHRyZXR1cm4gaGFzaCAmJiBoYXNoLnNsaWNlKCAxICkgPT09IGVsZW0uaWQ7XG5cdFx0fSxcblxuXHRcdFwicm9vdFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBlbGVtID09PSBkb2NFbGVtO1xuXHRcdH0sXG5cblx0XHRcImZvY3VzXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0gPT09IGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQgJiYgKCFkb2N1bWVudC5oYXNGb2N1cyB8fCBkb2N1bWVudC5oYXNGb2N1cygpKSAmJiAhIShlbGVtLnR5cGUgfHwgZWxlbS5ocmVmIHx8IH5lbGVtLnRhYkluZGV4KTtcblx0XHR9LFxuXG5cdFx0Ly8gQm9vbGVhbiBwcm9wZXJ0aWVzXG5cdFx0XCJlbmFibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IGZhbHNlO1xuXHRcdH0sXG5cblx0XHRcImRpc2FibGVkXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGlzYWJsZWQgPT09IHRydWU7XG5cdFx0fSxcblxuXHRcdFwiY2hlY2tlZFwiOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdC8vIEluIENTUzMsIDpjaGVja2VkIHNob3VsZCByZXR1cm4gYm90aCBjaGVja2VkIGFuZCBzZWxlY3RlZCBlbGVtZW50c1xuXHRcdFx0Ly8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAxMS9SRUMtY3NzMy1zZWxlY3RvcnMtMjAxMTA5MjkvI2NoZWNrZWRcblx0XHRcdHZhciBub2RlTmFtZSA9IGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdHJldHVybiAobm9kZU5hbWUgPT09IFwiaW5wdXRcIiAmJiAhIWVsZW0uY2hlY2tlZCkgfHwgKG5vZGVOYW1lID09PSBcIm9wdGlvblwiICYmICEhZWxlbS5zZWxlY3RlZCk7XG5cdFx0fSxcblxuXHRcdFwic2VsZWN0ZWRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBBY2Nlc3NpbmcgdGhpcyBwcm9wZXJ0eSBtYWtlcyBzZWxlY3RlZC1ieS1kZWZhdWx0XG5cdFx0XHQvLyBvcHRpb25zIGluIFNhZmFyaSB3b3JrIHByb3Blcmx5XG5cdFx0XHRpZiAoIGVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZWxlbS5wYXJlbnROb2RlLnNlbGVjdGVkSW5kZXg7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBlbGVtLnNlbGVjdGVkID09PSB0cnVlO1xuXHRcdH0sXG5cblx0XHQvLyBDb250ZW50c1xuXHRcdFwiZW1wdHlcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHQvLyBodHRwOi8vd3d3LnczLm9yZy9UUi9zZWxlY3RvcnMvI2VtcHR5LXBzZXVkb1xuXHRcdFx0Ly8gOmVtcHR5IGlzIG5lZ2F0ZWQgYnkgZWxlbWVudCAoMSkgb3IgY29udGVudCBub2RlcyAodGV4dDogMzsgY2RhdGE6IDQ7IGVudGl0eSByZWY6IDUpLFxuXHRcdFx0Ly8gICBidXQgbm90IGJ5IG90aGVycyAoY29tbWVudDogODsgcHJvY2Vzc2luZyBpbnN0cnVjdGlvbjogNzsgZXRjLilcblx0XHRcdC8vIG5vZGVUeXBlIDwgNiB3b3JrcyBiZWNhdXNlIGF0dHJpYnV0ZXMgKDIpIGRvIG5vdCBhcHBlYXIgYXMgY2hpbGRyZW5cblx0XHRcdGZvciAoIGVsZW0gPSBlbGVtLmZpcnN0Q2hpbGQ7IGVsZW07IGVsZW0gPSBlbGVtLm5leHRTaWJsaW5nICkge1xuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPCA2ICkge1xuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fSxcblxuXHRcdFwicGFyZW50XCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuICFFeHByLnBzZXVkb3NbXCJlbXB0eVwiXSggZWxlbSApO1xuXHRcdH0sXG5cblx0XHQvLyBFbGVtZW50L2lucHV0IHR5cGVzXG5cdFx0XCJoZWFkZXJcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmhlYWRlci50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiaW5wdXRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gcmlucHV0cy50ZXN0KCBlbGVtLm5vZGVOYW1lICk7XG5cdFx0fSxcblxuXHRcdFwiYnV0dG9uXCI6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIG5hbWUgPSBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRyZXR1cm4gbmFtZSA9PT0gXCJpbnB1dFwiICYmIGVsZW0udHlwZSA9PT0gXCJidXR0b25cIiB8fCBuYW1lID09PSBcImJ1dHRvblwiO1xuXHRcdH0sXG5cblx0XHRcInRleHRcIjogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHR2YXIgYXR0cjtcblx0XHRcdHJldHVybiBlbGVtLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwiaW5wdXRcIiAmJlxuXHRcdFx0XHRlbGVtLnR5cGUgPT09IFwidGV4dFwiICYmXG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8OFxuXHRcdFx0XHQvLyBOZXcgSFRNTDUgYXR0cmlidXRlIHZhbHVlcyAoZS5nLiwgXCJzZWFyY2hcIikgYXBwZWFyIHdpdGggZWxlbS50eXBlID09PSBcInRleHRcIlxuXHRcdFx0XHQoIChhdHRyID0gZWxlbS5nZXRBdHRyaWJ1dGUoXCJ0eXBlXCIpKSA9PSBudWxsIHx8IGF0dHIudG9Mb3dlckNhc2UoKSA9PT0gXCJ0ZXh0XCIgKTtcblx0XHR9LFxuXG5cdFx0Ly8gUG9zaXRpb24taW4tY29sbGVjdGlvblxuXHRcdFwiZmlyc3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBbIDAgXTtcblx0XHR9KSxcblxuXHRcdFwibGFzdFwiOiBjcmVhdGVQb3NpdGlvbmFsUHNldWRvKGZ1bmN0aW9uKCBtYXRjaEluZGV4ZXMsIGxlbmd0aCApIHtcblx0XHRcdHJldHVybiBbIGxlbmd0aCAtIDEgXTtcblx0XHR9KSxcblxuXHRcdFwiZXFcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0cmV0dXJuIFsgYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudCBdO1xuXHRcdH0pLFxuXG5cdFx0XCJldmVuXCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoICkge1xuXHRcdFx0dmFyIGkgPSAwO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpICs9IDIgKSB7XG5cdFx0XHRcdG1hdGNoSW5kZXhlcy5wdXNoKCBpICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbWF0Y2hJbmRleGVzO1xuXHRcdH0pLFxuXG5cdFx0XCJvZGRcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGggKSB7XG5cdFx0XHR2YXIgaSA9IDE7XG5cdFx0XHRmb3IgKCA7IGkgPCBsZW5ndGg7IGkgKz0gMiApIHtcblx0XHRcdFx0bWF0Y2hJbmRleGVzLnB1c2goIGkgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBtYXRjaEluZGV4ZXM7XG5cdFx0fSksXG5cblx0XHRcImx0XCI6IGNyZWF0ZVBvc2l0aW9uYWxQc2V1ZG8oZnVuY3Rpb24oIG1hdGNoSW5kZXhlcywgbGVuZ3RoLCBhcmd1bWVudCApIHtcblx0XHRcdHZhciBpID0gYXJndW1lbnQgPCAwID8gYXJndW1lbnQgKyBsZW5ndGggOiBhcmd1bWVudDtcblx0XHRcdGZvciAoIDsgLS1pID49IDA7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KSxcblxuXHRcdFwiZ3RcIjogY3JlYXRlUG9zaXRpb25hbFBzZXVkbyhmdW5jdGlvbiggbWF0Y2hJbmRleGVzLCBsZW5ndGgsIGFyZ3VtZW50ICkge1xuXHRcdFx0dmFyIGkgPSBhcmd1bWVudCA8IDAgPyBhcmd1bWVudCArIGxlbmd0aCA6IGFyZ3VtZW50O1xuXHRcdFx0Zm9yICggOyArK2kgPCBsZW5ndGg7ICkge1xuXHRcdFx0XHRtYXRjaEluZGV4ZXMucHVzaCggaSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG1hdGNoSW5kZXhlcztcblx0XHR9KVxuXHR9XG59O1xuXG5FeHByLnBzZXVkb3NbXCJudGhcIl0gPSBFeHByLnBzZXVkb3NbXCJlcVwiXTtcblxuLy8gQWRkIGJ1dHRvbi9pbnB1dCB0eXBlIHBzZXVkb3NcbmZvciAoIGkgaW4geyByYWRpbzogdHJ1ZSwgY2hlY2tib3g6IHRydWUsIGZpbGU6IHRydWUsIHBhc3N3b3JkOiB0cnVlLCBpbWFnZTogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUlucHV0UHNldWRvKCBpICk7XG59XG5mb3IgKCBpIGluIHsgc3VibWl0OiB0cnVlLCByZXNldDogdHJ1ZSB9ICkge1xuXHRFeHByLnBzZXVkb3NbIGkgXSA9IGNyZWF0ZUJ1dHRvblBzZXVkbyggaSApO1xufVxuXG4vLyBFYXN5IEFQSSBmb3IgY3JlYXRpbmcgbmV3IHNldEZpbHRlcnNcbmZ1bmN0aW9uIHNldEZpbHRlcnMoKSB7fVxuc2V0RmlsdGVycy5wcm90b3R5cGUgPSBFeHByLmZpbHRlcnMgPSBFeHByLnBzZXVkb3M7XG5FeHByLnNldEZpbHRlcnMgPSBuZXcgc2V0RmlsdGVycygpO1xuXG50b2tlbml6ZSA9IFNpenpsZS50b2tlbml6ZSA9IGZ1bmN0aW9uKCBzZWxlY3RvciwgcGFyc2VPbmx5ICkge1xuXHR2YXIgbWF0Y2hlZCwgbWF0Y2gsIHRva2VucywgdHlwZSxcblx0XHRzb0ZhciwgZ3JvdXBzLCBwcmVGaWx0ZXJzLFxuXHRcdGNhY2hlZCA9IHRva2VuQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoIGNhY2hlZCApIHtcblx0XHRyZXR1cm4gcGFyc2VPbmx5ID8gMCA6IGNhY2hlZC5zbGljZSggMCApO1xuXHR9XG5cblx0c29GYXIgPSBzZWxlY3Rvcjtcblx0Z3JvdXBzID0gW107XG5cdHByZUZpbHRlcnMgPSBFeHByLnByZUZpbHRlcjtcblxuXHR3aGlsZSAoIHNvRmFyICkge1xuXG5cdFx0Ly8gQ29tbWEgYW5kIGZpcnN0IHJ1blxuXHRcdGlmICggIW1hdGNoZWQgfHwgKG1hdGNoID0gcmNvbW1hLmV4ZWMoIHNvRmFyICkpICkge1xuXHRcdFx0aWYgKCBtYXRjaCApIHtcblx0XHRcdFx0Ly8gRG9uJ3QgY29uc3VtZSB0cmFpbGluZyBjb21tYXMgYXMgdmFsaWRcblx0XHRcdFx0c29GYXIgPSBzb0Zhci5zbGljZSggbWF0Y2hbMF0ubGVuZ3RoICkgfHwgc29GYXI7XG5cdFx0XHR9XG5cdFx0XHRncm91cHMucHVzaCggKHRva2VucyA9IFtdKSApO1xuXHRcdH1cblxuXHRcdG1hdGNoZWQgPSBmYWxzZTtcblxuXHRcdC8vIENvbWJpbmF0b3JzXG5cdFx0aWYgKCAobWF0Y2ggPSByY29tYmluYXRvcnMuZXhlYyggc29GYXIgKSkgKSB7XG5cdFx0XHRtYXRjaGVkID0gbWF0Y2guc2hpZnQoKTtcblx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0dmFsdWU6IG1hdGNoZWQsXG5cdFx0XHRcdC8vIENhc3QgZGVzY2VuZGFudCBjb21iaW5hdG9ycyB0byBzcGFjZVxuXHRcdFx0XHR0eXBlOiBtYXRjaFswXS5yZXBsYWNlKCBydHJpbSwgXCIgXCIgKVxuXHRcdFx0fSk7XG5cdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdH1cblxuXHRcdC8vIEZpbHRlcnNcblx0XHRmb3IgKCB0eXBlIGluIEV4cHIuZmlsdGVyICkge1xuXHRcdFx0aWYgKCAobWF0Y2ggPSBtYXRjaEV4cHJbIHR5cGUgXS5leGVjKCBzb0ZhciApKSAmJiAoIXByZUZpbHRlcnNbIHR5cGUgXSB8fFxuXHRcdFx0XHQobWF0Y2ggPSBwcmVGaWx0ZXJzWyB0eXBlIF0oIG1hdGNoICkpKSApIHtcblx0XHRcdFx0bWF0Y2hlZCA9IG1hdGNoLnNoaWZ0KCk7XG5cdFx0XHRcdHRva2Vucy5wdXNoKHtcblx0XHRcdFx0XHR2YWx1ZTogbWF0Y2hlZCxcblx0XHRcdFx0XHR0eXBlOiB0eXBlLFxuXHRcdFx0XHRcdG1hdGNoZXM6IG1hdGNoXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzb0ZhciA9IHNvRmFyLnNsaWNlKCBtYXRjaGVkLmxlbmd0aCApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGlmICggIW1hdGNoZWQgKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIGxlbmd0aCBvZiB0aGUgaW52YWxpZCBleGNlc3Ncblx0Ly8gaWYgd2UncmUganVzdCBwYXJzaW5nXG5cdC8vIE90aGVyd2lzZSwgdGhyb3cgYW4gZXJyb3Igb3IgcmV0dXJuIHRva2Vuc1xuXHRyZXR1cm4gcGFyc2VPbmx5ID9cblx0XHRzb0Zhci5sZW5ndGggOlxuXHRcdHNvRmFyID9cblx0XHRcdFNpenpsZS5lcnJvciggc2VsZWN0b3IgKSA6XG5cdFx0XHQvLyBDYWNoZSB0aGUgdG9rZW5zXG5cdFx0XHR0b2tlbkNhY2hlKCBzZWxlY3RvciwgZ3JvdXBzICkuc2xpY2UoIDAgKTtcbn07XG5cbmZ1bmN0aW9uIHRvU2VsZWN0b3IoIHRva2VucyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0c2VsZWN0b3IgPSBcIlwiO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRzZWxlY3RvciArPSB0b2tlbnNbaV0udmFsdWU7XG5cdH1cblx0cmV0dXJuIHNlbGVjdG9yO1xufVxuXG5mdW5jdGlvbiBhZGRDb21iaW5hdG9yKCBtYXRjaGVyLCBjb21iaW5hdG9yLCBiYXNlICkge1xuXHR2YXIgZGlyID0gY29tYmluYXRvci5kaXIsXG5cdFx0Y2hlY2tOb25FbGVtZW50cyA9IGJhc2UgJiYgZGlyID09PSBcInBhcmVudE5vZGVcIixcblx0XHRkb25lTmFtZSA9IGRvbmUrKztcblxuXHRyZXR1cm4gY29tYmluYXRvci5maXJzdCA/XG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBjbG9zZXN0IGFuY2VzdG9yL3ByZWNlZGluZyBlbGVtZW50XG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHdoaWxlICggKGVsZW0gPSBlbGVtWyBkaXIgXSkgKSB7XG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdHJldHVybiBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gOlxuXG5cdFx0Ly8gQ2hlY2sgYWdhaW5zdCBhbGwgYW5jZXN0b3IvcHJlY2VkaW5nIGVsZW1lbnRzXG5cdFx0ZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciBvbGRDYWNoZSwgdW5pcXVlQ2FjaGUsIG91dGVyQ2FjaGUsXG5cdFx0XHRcdG5ld0NhY2hlID0gWyBkaXJydW5zLCBkb25lTmFtZSBdO1xuXG5cdFx0XHQvLyBXZSBjYW4ndCBzZXQgYXJiaXRyYXJ5IGRhdGEgb24gWE1MIG5vZGVzLCBzbyB0aGV5IGRvbid0IGJlbmVmaXQgZnJvbSBjb21iaW5hdG9yIGNhY2hpbmdcblx0XHRcdGlmICggeG1sICkge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVyKCBlbGVtLCBjb250ZXh0LCB4bWwgKSApIHtcblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aGlsZSAoIChlbGVtID0gZWxlbVsgZGlyIF0pICkge1xuXHRcdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBjaGVja05vbkVsZW1lbnRzICkge1xuXHRcdFx0XHRcdFx0b3V0ZXJDYWNoZSA9IGVsZW1bIGV4cGFuZG8gXSB8fCAoZWxlbVsgZXhwYW5kbyBdID0ge30pO1xuXG5cdFx0XHRcdFx0XHQvLyBTdXBwb3J0OiBJRSA8OSBvbmx5XG5cdFx0XHRcdFx0XHQvLyBEZWZlbmQgYWdhaW5zdCBjbG9uZWQgYXR0cm9wZXJ0aWVzIChqUXVlcnkgZ2gtMTcwOSlcblx0XHRcdFx0XHRcdHVuaXF1ZUNhY2hlID0gb3V0ZXJDYWNoZVsgZWxlbS51bmlxdWVJRCBdIHx8IChvdXRlckNhY2hlWyBlbGVtLnVuaXF1ZUlEIF0gPSB7fSk7XG5cblx0XHRcdFx0XHRcdGlmICggKG9sZENhY2hlID0gdW5pcXVlQ2FjaGVbIGRpciBdKSAmJlxuXHRcdFx0XHRcdFx0XHRvbGRDYWNoZVsgMCBdID09PSBkaXJydW5zICYmIG9sZENhY2hlWyAxIF0gPT09IGRvbmVOYW1lICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFzc2lnbiB0byBuZXdDYWNoZSBzbyByZXN1bHRzIGJhY2stcHJvcGFnYXRlIHRvIHByZXZpb3VzIGVsZW1lbnRzXG5cdFx0XHRcdFx0XHRcdHJldHVybiAobmV3Q2FjaGVbIDIgXSA9IG9sZENhY2hlWyAyIF0pO1xuXHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmV1c2UgbmV3Y2FjaGUgc28gcmVzdWx0cyBiYWNrLXByb3BhZ2F0ZSB0byBwcmV2aW91cyBlbGVtZW50c1xuXHRcdFx0XHRcdFx0XHR1bmlxdWVDYWNoZVsgZGlyIF0gPSBuZXdDYWNoZTtcblxuXHRcdFx0XHRcdFx0XHQvLyBBIG1hdGNoIG1lYW5zIHdlJ3JlIGRvbmU7IGEgZmFpbCBtZWFucyB3ZSBoYXZlIHRvIGtlZXAgY2hlY2tpbmdcblx0XHRcdFx0XHRcdFx0aWYgKCAobmV3Q2FjaGVbIDIgXSA9IG1hdGNoZXIoIGVsZW0sIGNvbnRleHQsIHhtbCApKSApIHtcblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG59XG5cbmZ1bmN0aW9uIGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApIHtcblx0cmV0dXJuIG1hdGNoZXJzLmxlbmd0aCA+IDEgP1xuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb250ZXh0LCB4bWwgKSB7XG5cdFx0XHR2YXIgaSA9IG1hdGNoZXJzLmxlbmd0aDtcblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRpZiAoICFtYXRjaGVyc1tpXSggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IDpcblx0XHRtYXRjaGVyc1swXTtcbn1cblxuZnVuY3Rpb24gbXVsdGlwbGVDb250ZXh0cyggc2VsZWN0b3IsIGNvbnRleHRzLCByZXN1bHRzICkge1xuXHR2YXIgaSA9IDAsXG5cdFx0bGVuID0gY29udGV4dHMubGVuZ3RoO1xuXHRmb3IgKCA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRTaXp6bGUoIHNlbGVjdG9yLCBjb250ZXh0c1tpXSwgcmVzdWx0cyApO1xuXHR9XG5cdHJldHVybiByZXN1bHRzO1xufVxuXG5mdW5jdGlvbiBjb25kZW5zZSggdW5tYXRjaGVkLCBtYXAsIGZpbHRlciwgY29udGV4dCwgeG1sICkge1xuXHR2YXIgZWxlbSxcblx0XHRuZXdVbm1hdGNoZWQgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsZW4gPSB1bm1hdGNoZWQubGVuZ3RoLFxuXHRcdG1hcHBlZCA9IG1hcCAhPSBudWxsO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKGVsZW0gPSB1bm1hdGNoZWRbaV0pICkge1xuXHRcdFx0aWYgKCAhZmlsdGVyIHx8IGZpbHRlciggZWxlbSwgY29udGV4dCwgeG1sICkgKSB7XG5cdFx0XHRcdG5ld1VubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdGlmICggbWFwcGVkICkge1xuXHRcdFx0XHRcdG1hcC5wdXNoKCBpICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gbmV3VW5tYXRjaGVkO1xufVxuXG5mdW5jdGlvbiBzZXRNYXRjaGVyKCBwcmVGaWx0ZXIsIHNlbGVjdG9yLCBtYXRjaGVyLCBwb3N0RmlsdGVyLCBwb3N0RmluZGVyLCBwb3N0U2VsZWN0b3IgKSB7XG5cdGlmICggcG9zdEZpbHRlciAmJiAhcG9zdEZpbHRlclsgZXhwYW5kbyBdICkge1xuXHRcdHBvc3RGaWx0ZXIgPSBzZXRNYXRjaGVyKCBwb3N0RmlsdGVyICk7XG5cdH1cblx0aWYgKCBwb3N0RmluZGVyICYmICFwb3N0RmluZGVyWyBleHBhbmRvIF0gKSB7XG5cdFx0cG9zdEZpbmRlciA9IHNldE1hdGNoZXIoIHBvc3RGaW5kZXIsIHBvc3RTZWxlY3RvciApO1xuXHR9XG5cdHJldHVybiBtYXJrRnVuY3Rpb24oZnVuY3Rpb24oIHNlZWQsIHJlc3VsdHMsIGNvbnRleHQsIHhtbCApIHtcblx0XHR2YXIgdGVtcCwgaSwgZWxlbSxcblx0XHRcdHByZU1hcCA9IFtdLFxuXHRcdFx0cG9zdE1hcCA9IFtdLFxuXHRcdFx0cHJlZXhpc3RpbmcgPSByZXN1bHRzLmxlbmd0aCxcblxuXHRcdFx0Ly8gR2V0IGluaXRpYWwgZWxlbWVudHMgZnJvbSBzZWVkIG9yIGNvbnRleHRcblx0XHRcdGVsZW1zID0gc2VlZCB8fCBtdWx0aXBsZUNvbnRleHRzKCBzZWxlY3RvciB8fCBcIipcIiwgY29udGV4dC5ub2RlVHlwZSA/IFsgY29udGV4dCBdIDogY29udGV4dCwgW10gKSxcblxuXHRcdFx0Ly8gUHJlZmlsdGVyIHRvIGdldCBtYXRjaGVyIGlucHV0LCBwcmVzZXJ2aW5nIGEgbWFwIGZvciBzZWVkLXJlc3VsdHMgc3luY2hyb25pemF0aW9uXG5cdFx0XHRtYXRjaGVySW4gPSBwcmVGaWx0ZXIgJiYgKCBzZWVkIHx8ICFzZWxlY3RvciApID9cblx0XHRcdFx0Y29uZGVuc2UoIGVsZW1zLCBwcmVNYXAsIHByZUZpbHRlciwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRlbGVtcyxcblxuXHRcdFx0bWF0Y2hlck91dCA9IG1hdGNoZXIgP1xuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGEgcG9zdEZpbmRlciwgb3IgZmlsdGVyZWQgc2VlZCwgb3Igbm9uLXNlZWQgcG9zdEZpbHRlciBvciBwcmVleGlzdGluZyByZXN1bHRzLFxuXHRcdFx0XHRwb3N0RmluZGVyIHx8ICggc2VlZCA/IHByZUZpbHRlciA6IHByZWV4aXN0aW5nIHx8IHBvc3RGaWx0ZXIgKSA/XG5cblx0XHRcdFx0XHQvLyAuLi5pbnRlcm1lZGlhdGUgcHJvY2Vzc2luZyBpcyBuZWNlc3Nhcnlcblx0XHRcdFx0XHRbXSA6XG5cblx0XHRcdFx0XHQvLyAuLi5vdGhlcndpc2UgdXNlIHJlc3VsdHMgZGlyZWN0bHlcblx0XHRcdFx0XHRyZXN1bHRzIDpcblx0XHRcdFx0bWF0Y2hlckluO1xuXG5cdFx0Ly8gRmluZCBwcmltYXJ5IG1hdGNoZXNcblx0XHRpZiAoIG1hdGNoZXIgKSB7XG5cdFx0XHRtYXRjaGVyKCBtYXRjaGVySW4sIG1hdGNoZXJPdXQsIGNvbnRleHQsIHhtbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHBvc3RGaWx0ZXJcblx0XHRpZiAoIHBvc3RGaWx0ZXIgKSB7XG5cdFx0XHR0ZW1wID0gY29uZGVuc2UoIG1hdGNoZXJPdXQsIHBvc3RNYXAgKTtcblx0XHRcdHBvc3RGaWx0ZXIoIHRlbXAsIFtdLCBjb250ZXh0LCB4bWwgKTtcblxuXHRcdFx0Ly8gVW4tbWF0Y2ggZmFpbGluZyBlbGVtZW50cyBieSBtb3ZpbmcgdGhlbSBiYWNrIHRvIG1hdGNoZXJJblxuXHRcdFx0aSA9IHRlbXAubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdGlmICggKGVsZW0gPSB0ZW1wW2ldKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyT3V0WyBwb3N0TWFwW2ldIF0gPSAhKG1hdGNoZXJJblsgcG9zdE1hcFtpXSBdID0gZWxlbSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIHNlZWQgKSB7XG5cdFx0XHRpZiAoIHBvc3RGaW5kZXIgfHwgcHJlRmlsdGVyICkge1xuXHRcdFx0XHRpZiAoIHBvc3RGaW5kZXIgKSB7XG5cdFx0XHRcdFx0Ly8gR2V0IHRoZSBmaW5hbCBtYXRjaGVyT3V0IGJ5IGNvbmRlbnNpbmcgdGhpcyBpbnRlcm1lZGlhdGUgaW50byBwb3N0RmluZGVyIGNvbnRleHRzXG5cdFx0XHRcdFx0dGVtcCA9IFtdO1xuXHRcdFx0XHRcdGkgPSBtYXRjaGVyT3V0Lmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdGlmICggKGVsZW0gPSBtYXRjaGVyT3V0W2ldKSApIHtcblx0XHRcdFx0XHRcdFx0Ly8gUmVzdG9yZSBtYXRjaGVySW4gc2luY2UgZWxlbSBpcyBub3QgeWV0IGEgZmluYWwgbWF0Y2hcblx0XHRcdFx0XHRcdFx0dGVtcC5wdXNoKCAobWF0Y2hlckluW2ldID0gZWxlbSkgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cG9zdEZpbmRlciggbnVsbCwgKG1hdGNoZXJPdXQgPSBbXSksIHRlbXAsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gTW92ZSBtYXRjaGVkIGVsZW1lbnRzIGZyb20gc2VlZCB0byByZXN1bHRzIHRvIGtlZXAgdGhlbSBzeW5jaHJvbml6ZWRcblx0XHRcdFx0aSA9IG1hdGNoZXJPdXQubGVuZ3RoO1xuXHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRpZiAoIChlbGVtID0gbWF0Y2hlck91dFtpXSkgJiZcblx0XHRcdFx0XHRcdCh0ZW1wID0gcG9zdEZpbmRlciA/IGluZGV4T2YoIHNlZWQsIGVsZW0gKSA6IHByZU1hcFtpXSkgPiAtMSApIHtcblxuXHRcdFx0XHRcdFx0c2VlZFt0ZW1wXSA9ICEocmVzdWx0c1t0ZW1wXSA9IGVsZW0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0Ly8gQWRkIGVsZW1lbnRzIHRvIHJlc3VsdHMsIHRocm91Z2ggcG9zdEZpbmRlciBpZiBkZWZpbmVkXG5cdFx0fSBlbHNlIHtcblx0XHRcdG1hdGNoZXJPdXQgPSBjb25kZW5zZShcblx0XHRcdFx0bWF0Y2hlck91dCA9PT0gcmVzdWx0cyA/XG5cdFx0XHRcdFx0bWF0Y2hlck91dC5zcGxpY2UoIHByZWV4aXN0aW5nLCBtYXRjaGVyT3V0Lmxlbmd0aCApIDpcblx0XHRcdFx0XHRtYXRjaGVyT3V0XG5cdFx0XHQpO1xuXHRcdFx0aWYgKCBwb3N0RmluZGVyICkge1xuXHRcdFx0XHRwb3N0RmluZGVyKCBudWxsLCByZXN1bHRzLCBtYXRjaGVyT3V0LCB4bWwgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIG1hdGNoZXJPdXQgKTtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufVxuXG5mdW5jdGlvbiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zICkge1xuXHR2YXIgY2hlY2tDb250ZXh0LCBtYXRjaGVyLCBqLFxuXHRcdGxlbiA9IHRva2Vucy5sZW5ndGgsXG5cdFx0bGVhZGluZ1JlbGF0aXZlID0gRXhwci5yZWxhdGl2ZVsgdG9rZW5zWzBdLnR5cGUgXSxcblx0XHRpbXBsaWNpdFJlbGF0aXZlID0gbGVhZGluZ1JlbGF0aXZlIHx8IEV4cHIucmVsYXRpdmVbXCIgXCJdLFxuXHRcdGkgPSBsZWFkaW5nUmVsYXRpdmUgPyAxIDogMCxcblxuXHRcdC8vIFRoZSBmb3VuZGF0aW9uYWwgbWF0Y2hlciBlbnN1cmVzIHRoYXQgZWxlbWVudHMgYXJlIHJlYWNoYWJsZSBmcm9tIHRvcC1sZXZlbCBjb250ZXh0KHMpXG5cdFx0bWF0Y2hDb250ZXh0ID0gYWRkQ29tYmluYXRvciggZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbSA9PT0gY2hlY2tDb250ZXh0O1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaEFueUNvbnRleHQgPSBhZGRDb21iaW5hdG9yKCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiBpbmRleE9mKCBjaGVja0NvbnRleHQsIGVsZW0gKSA+IC0xO1xuXHRcdH0sIGltcGxpY2l0UmVsYXRpdmUsIHRydWUgKSxcblx0XHRtYXRjaGVycyA9IFsgZnVuY3Rpb24oIGVsZW0sIGNvbnRleHQsIHhtbCApIHtcblx0XHRcdHZhciByZXQgPSAoICFsZWFkaW5nUmVsYXRpdmUgJiYgKCB4bWwgfHwgY29udGV4dCAhPT0gb3V0ZXJtb3N0Q29udGV4dCApICkgfHwgKFxuXHRcdFx0XHQoY2hlY2tDb250ZXh0ID0gY29udGV4dCkubm9kZVR5cGUgP1xuXHRcdFx0XHRcdG1hdGNoQ29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgOlxuXHRcdFx0XHRcdG1hdGNoQW55Q29udGV4dCggZWxlbSwgY29udGV4dCwgeG1sICkgKTtcblx0XHRcdC8vIEF2b2lkIGhhbmdpbmcgb250byBlbGVtZW50IChpc3N1ZSAjMjk5KVxuXHRcdFx0Y2hlY2tDb250ZXh0ID0gbnVsbDtcblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fSBdO1xuXG5cdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdGlmICggKG1hdGNoZXIgPSBFeHByLnJlbGF0aXZlWyB0b2tlbnNbaV0udHlwZSBdKSApIHtcblx0XHRcdG1hdGNoZXJzID0gWyBhZGRDb21iaW5hdG9yKGVsZW1lbnRNYXRjaGVyKCBtYXRjaGVycyApLCBtYXRjaGVyKSBdO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRtYXRjaGVyID0gRXhwci5maWx0ZXJbIHRva2Vuc1tpXS50eXBlIF0uYXBwbHkoIG51bGwsIHRva2Vuc1tpXS5tYXRjaGVzICk7XG5cblx0XHRcdC8vIFJldHVybiBzcGVjaWFsIHVwb24gc2VlaW5nIGEgcG9zaXRpb25hbCBtYXRjaGVyXG5cdFx0XHRpZiAoIG1hdGNoZXJbIGV4cGFuZG8gXSApIHtcblx0XHRcdFx0Ly8gRmluZCB0aGUgbmV4dCByZWxhdGl2ZSBvcGVyYXRvciAoaWYgYW55KSBmb3IgcHJvcGVyIGhhbmRsaW5nXG5cdFx0XHRcdGogPSArK2k7XG5cdFx0XHRcdGZvciAoIDsgaiA8IGxlbjsgaisrICkge1xuXHRcdFx0XHRcdGlmICggRXhwci5yZWxhdGl2ZVsgdG9rZW5zW2pdLnR5cGUgXSApIHtcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gc2V0TWF0Y2hlcihcblx0XHRcdFx0XHRpID4gMSAmJiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKSxcblx0XHRcdFx0XHRpID4gMSAmJiB0b1NlbGVjdG9yKFxuXHRcdFx0XHRcdFx0Ly8gSWYgdGhlIHByZWNlZGluZyB0b2tlbiB3YXMgYSBkZXNjZW5kYW50IGNvbWJpbmF0b3IsIGluc2VydCBhbiBpbXBsaWNpdCBhbnktZWxlbWVudCBgKmBcblx0XHRcdFx0XHRcdHRva2Vucy5zbGljZSggMCwgaSAtIDEgKS5jb25jYXQoeyB2YWx1ZTogdG9rZW5zWyBpIC0gMiBdLnR5cGUgPT09IFwiIFwiID8gXCIqXCIgOiBcIlwiIH0pXG5cdFx0XHRcdFx0KS5yZXBsYWNlKCBydHJpbSwgXCIkMVwiICksXG5cdFx0XHRcdFx0bWF0Y2hlcixcblx0XHRcdFx0XHRpIDwgaiAmJiBtYXRjaGVyRnJvbVRva2VucyggdG9rZW5zLnNsaWNlKCBpLCBqICkgKSxcblx0XHRcdFx0XHRqIDwgbGVuICYmIG1hdGNoZXJGcm9tVG9rZW5zKCAodG9rZW5zID0gdG9rZW5zLnNsaWNlKCBqICkpICksXG5cdFx0XHRcdFx0aiA8IGxlbiAmJiB0b1NlbGVjdG9yKCB0b2tlbnMgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlcnMucHVzaCggbWF0Y2hlciApO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiBlbGVtZW50TWF0Y2hlciggbWF0Y2hlcnMgKTtcbn1cblxuZnVuY3Rpb24gbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkge1xuXHR2YXIgYnlTZXQgPSBzZXRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdGJ5RWxlbWVudCA9IGVsZW1lbnRNYXRjaGVycy5sZW5ndGggPiAwLFxuXHRcdHN1cGVyTWF0Y2hlciA9IGZ1bmN0aW9uKCBzZWVkLCBjb250ZXh0LCB4bWwsIHJlc3VsdHMsIG91dGVybW9zdCApIHtcblx0XHRcdHZhciBlbGVtLCBqLCBtYXRjaGVyLFxuXHRcdFx0XHRtYXRjaGVkQ291bnQgPSAwLFxuXHRcdFx0XHRpID0gXCIwXCIsXG5cdFx0XHRcdHVubWF0Y2hlZCA9IHNlZWQgJiYgW10sXG5cdFx0XHRcdHNldE1hdGNoZWQgPSBbXSxcblx0XHRcdFx0Y29udGV4dEJhY2t1cCA9IG91dGVybW9zdENvbnRleHQsXG5cdFx0XHRcdC8vIFdlIG11c3QgYWx3YXlzIGhhdmUgZWl0aGVyIHNlZWQgZWxlbWVudHMgb3Igb3V0ZXJtb3N0IGNvbnRleHRcblx0XHRcdFx0ZWxlbXMgPSBzZWVkIHx8IGJ5RWxlbWVudCAmJiBFeHByLmZpbmRbXCJUQUdcIl0oIFwiKlwiLCBvdXRlcm1vc3QgKSxcblx0XHRcdFx0Ly8gVXNlIGludGVnZXIgZGlycnVucyBpZmYgdGhpcyBpcyB0aGUgb3V0ZXJtb3N0IG1hdGNoZXJcblx0XHRcdFx0ZGlycnVuc1VuaXF1ZSA9IChkaXJydW5zICs9IGNvbnRleHRCYWNrdXAgPT0gbnVsbCA/IDEgOiBNYXRoLnJhbmRvbSgpIHx8IDAuMSksXG5cdFx0XHRcdGxlbiA9IGVsZW1zLmxlbmd0aDtcblxuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdG91dGVybW9zdENvbnRleHQgPSBjb250ZXh0ID09PSBkb2N1bWVudCB8fCBjb250ZXh0IHx8IG91dGVybW9zdDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIGVsZW1lbnRzIHBhc3NpbmcgZWxlbWVudE1hdGNoZXJzIGRpcmVjdGx5IHRvIHJlc3VsdHNcblx0XHRcdC8vIFN1cHBvcnQ6IElFPDksIFNhZmFyaVxuXHRcdFx0Ly8gVG9sZXJhdGUgTm9kZUxpc3QgcHJvcGVydGllcyAoSUU6IFwibGVuZ3RoXCI7IFNhZmFyaTogPG51bWJlcj4pIG1hdGNoaW5nIGVsZW1lbnRzIGJ5IGlkXG5cdFx0XHRmb3IgKCA7IGkgIT09IGxlbiAmJiAoZWxlbSA9IGVsZW1zW2ldKSAhPSBudWxsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggYnlFbGVtZW50ICYmIGVsZW0gKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0aWYgKCAhY29udGV4dCAmJiBlbGVtLm93bmVyRG9jdW1lbnQgIT09IGRvY3VtZW50ICkge1xuXHRcdFx0XHRcdFx0c2V0RG9jdW1lbnQoIGVsZW0gKTtcblx0XHRcdFx0XHRcdHhtbCA9ICFkb2N1bWVudElzSFRNTDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0d2hpbGUgKCAobWF0Y2hlciA9IGVsZW1lbnRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlciggZWxlbSwgY29udGV4dCB8fCBkb2N1bWVudCwgeG1sKSApIHtcblx0XHRcdFx0XHRcdFx0cmVzdWx0cy5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRpZiAoIG91dGVybW9zdCApIHtcblx0XHRcdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFRyYWNrIHVubWF0Y2hlZCBlbGVtZW50cyBmb3Igc2V0IGZpbHRlcnNcblx0XHRcdFx0aWYgKCBieVNldCApIHtcblx0XHRcdFx0XHQvLyBUaGV5IHdpbGwgaGF2ZSBnb25lIHRocm91Z2ggYWxsIHBvc3NpYmxlIG1hdGNoZXJzXG5cdFx0XHRcdFx0aWYgKCAoZWxlbSA9ICFtYXRjaGVyICYmIGVsZW0pICkge1xuXHRcdFx0XHRcdFx0bWF0Y2hlZENvdW50LS07XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0Ly8gTGVuZ3RoZW4gdGhlIGFycmF5IGZvciBldmVyeSBlbGVtZW50LCBtYXRjaGVkIG9yIG5vdFxuXHRcdFx0XHRcdGlmICggc2VlZCApIHtcblx0XHRcdFx0XHRcdHVubWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIGBpYCBpcyBub3cgdGhlIGNvdW50IG9mIGVsZW1lbnRzIHZpc2l0ZWQgYWJvdmUsIGFuZCBhZGRpbmcgaXQgdG8gYG1hdGNoZWRDb3VudGBcblx0XHRcdC8vIG1ha2VzIHRoZSBsYXR0ZXIgbm9ubmVnYXRpdmUuXG5cdFx0XHRtYXRjaGVkQ291bnQgKz0gaTtcblxuXHRcdFx0Ly8gQXBwbHkgc2V0IGZpbHRlcnMgdG8gdW5tYXRjaGVkIGVsZW1lbnRzXG5cdFx0XHQvLyBOT1RFOiBUaGlzIGNhbiBiZSBza2lwcGVkIGlmIHRoZXJlIGFyZSBubyB1bm1hdGNoZWQgZWxlbWVudHMgKGkuZS4sIGBtYXRjaGVkQ291bnRgXG5cdFx0XHQvLyBlcXVhbHMgYGlgKSwgdW5sZXNzIHdlIGRpZG4ndCB2aXNpdCBfYW55XyBlbGVtZW50cyBpbiB0aGUgYWJvdmUgbG9vcCBiZWNhdXNlIHdlIGhhdmVcblx0XHRcdC8vIG5vIGVsZW1lbnQgbWF0Y2hlcnMgYW5kIG5vIHNlZWQuXG5cdFx0XHQvLyBJbmNyZW1lbnRpbmcgYW4gaW5pdGlhbGx5LXN0cmluZyBcIjBcIiBgaWAgYWxsb3dzIGBpYCB0byByZW1haW4gYSBzdHJpbmcgb25seSBpbiB0aGF0XG5cdFx0XHQvLyBjYXNlLCB3aGljaCB3aWxsIHJlc3VsdCBpbiBhIFwiMDBcIiBgbWF0Y2hlZENvdW50YCB0aGF0IGRpZmZlcnMgZnJvbSBgaWAgYnV0IGlzIGFsc29cblx0XHRcdC8vIG51bWVyaWNhbGx5IHplcm8uXG5cdFx0XHRpZiAoIGJ5U2V0ICYmIGkgIT09IG1hdGNoZWRDb3VudCApIHtcblx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdHdoaWxlICggKG1hdGNoZXIgPSBzZXRNYXRjaGVyc1tqKytdKSApIHtcblx0XHRcdFx0XHRtYXRjaGVyKCB1bm1hdGNoZWQsIHNldE1hdGNoZWQsIGNvbnRleHQsIHhtbCApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0aWYgKCBzZWVkICkge1xuXHRcdFx0XHRcdC8vIFJlaW50ZWdyYXRlIGVsZW1lbnQgbWF0Y2hlcyB0byBlbGltaW5hdGUgdGhlIG5lZWQgZm9yIHNvcnRpbmdcblx0XHRcdFx0XHRpZiAoIG1hdGNoZWRDb3VudCA+IDAgKSB7XG5cdFx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCAhKHVubWF0Y2hlZFtpXSB8fCBzZXRNYXRjaGVkW2ldKSApIHtcblx0XHRcdFx0XHRcdFx0XHRzZXRNYXRjaGVkW2ldID0gcG9wLmNhbGwoIHJlc3VsdHMgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIERpc2NhcmQgaW5kZXggcGxhY2Vob2xkZXIgdmFsdWVzIHRvIGdldCBvbmx5IGFjdHVhbCBtYXRjaGVzXG5cdFx0XHRcdFx0c2V0TWF0Y2hlZCA9IGNvbmRlbnNlKCBzZXRNYXRjaGVkICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBBZGQgbWF0Y2hlcyB0byByZXN1bHRzXG5cdFx0XHRcdHB1c2guYXBwbHkoIHJlc3VsdHMsIHNldE1hdGNoZWQgKTtcblxuXHRcdFx0XHQvLyBTZWVkbGVzcyBzZXQgbWF0Y2hlcyBzdWNjZWVkaW5nIG11bHRpcGxlIHN1Y2Nlc3NmdWwgbWF0Y2hlcnMgc3RpcHVsYXRlIHNvcnRpbmdcblx0XHRcdFx0aWYgKCBvdXRlcm1vc3QgJiYgIXNlZWQgJiYgc2V0TWF0Y2hlZC5sZW5ndGggPiAwICYmXG5cdFx0XHRcdFx0KCBtYXRjaGVkQ291bnQgKyBzZXRNYXRjaGVycy5sZW5ndGggKSA+IDEgKSB7XG5cblx0XHRcdFx0XHRTaXp6bGUudW5pcXVlU29ydCggcmVzdWx0cyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIE92ZXJyaWRlIG1hbmlwdWxhdGlvbiBvZiBnbG9iYWxzIGJ5IG5lc3RlZCBtYXRjaGVyc1xuXHRcdFx0aWYgKCBvdXRlcm1vc3QgKSB7XG5cdFx0XHRcdGRpcnJ1bnMgPSBkaXJydW5zVW5pcXVlO1xuXHRcdFx0XHRvdXRlcm1vc3RDb250ZXh0ID0gY29udGV4dEJhY2t1cDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIHVubWF0Y2hlZDtcblx0XHR9O1xuXG5cdHJldHVybiBieVNldCA/XG5cdFx0bWFya0Z1bmN0aW9uKCBzdXBlck1hdGNoZXIgKSA6XG5cdFx0c3VwZXJNYXRjaGVyO1xufVxuXG5jb21waWxlID0gU2l6emxlLmNvbXBpbGUgPSBmdW5jdGlvbiggc2VsZWN0b3IsIG1hdGNoIC8qIEludGVybmFsIFVzZSBPbmx5ICovICkge1xuXHR2YXIgaSxcblx0XHRzZXRNYXRjaGVycyA9IFtdLFxuXHRcdGVsZW1lbnRNYXRjaGVycyA9IFtdLFxuXHRcdGNhY2hlZCA9IGNvbXBpbGVyQ2FjaGVbIHNlbGVjdG9yICsgXCIgXCIgXTtcblxuXHRpZiAoICFjYWNoZWQgKSB7XG5cdFx0Ly8gR2VuZXJhdGUgYSBmdW5jdGlvbiBvZiByZWN1cnNpdmUgZnVuY3Rpb25zIHRoYXQgY2FuIGJlIHVzZWQgdG8gY2hlY2sgZWFjaCBlbGVtZW50XG5cdFx0aWYgKCAhbWF0Y2ggKSB7XG5cdFx0XHRtYXRjaCA9IHRva2VuaXplKCBzZWxlY3RvciApO1xuXHRcdH1cblx0XHRpID0gbWF0Y2gubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0Y2FjaGVkID0gbWF0Y2hlckZyb21Ub2tlbnMoIG1hdGNoW2ldICk7XG5cdFx0XHRpZiAoIGNhY2hlZFsgZXhwYW5kbyBdICkge1xuXHRcdFx0XHRzZXRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGVsZW1lbnRNYXRjaGVycy5wdXNoKCBjYWNoZWQgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWNoZSB0aGUgY29tcGlsZWQgZnVuY3Rpb25cblx0XHRjYWNoZWQgPSBjb21waWxlckNhY2hlKCBzZWxlY3RvciwgbWF0Y2hlckZyb21Hcm91cE1hdGNoZXJzKCBlbGVtZW50TWF0Y2hlcnMsIHNldE1hdGNoZXJzICkgKTtcblxuXHRcdC8vIFNhdmUgc2VsZWN0b3IgYW5kIHRva2VuaXphdGlvblxuXHRcdGNhY2hlZC5zZWxlY3RvciA9IHNlbGVjdG9yO1xuXHR9XG5cdHJldHVybiBjYWNoZWQ7XG59O1xuXG4vKipcbiAqIEEgbG93LWxldmVsIHNlbGVjdGlvbiBmdW5jdGlvbiB0aGF0IHdvcmtzIHdpdGggU2l6emxlJ3MgY29tcGlsZWRcbiAqICBzZWxlY3RvciBmdW5jdGlvbnNcbiAqIEBwYXJhbSB7U3RyaW5nfEZ1bmN0aW9ufSBzZWxlY3RvciBBIHNlbGVjdG9yIG9yIGEgcHJlLWNvbXBpbGVkXG4gKiAgc2VsZWN0b3IgZnVuY3Rpb24gYnVpbHQgd2l0aCBTaXp6bGUuY29tcGlsZVxuICogQHBhcmFtIHtFbGVtZW50fSBjb250ZXh0XG4gKiBAcGFyYW0ge0FycmF5fSBbcmVzdWx0c11cbiAqIEBwYXJhbSB7QXJyYXl9IFtzZWVkXSBBIHNldCBvZiBlbGVtZW50cyB0byBtYXRjaCBhZ2FpbnN0XG4gKi9cbnNlbGVjdCA9IFNpenpsZS5zZWxlY3QgPSBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQsIHJlc3VsdHMsIHNlZWQgKSB7XG5cdHZhciBpLCB0b2tlbnMsIHRva2VuLCB0eXBlLCBmaW5kLFxuXHRcdGNvbXBpbGVkID0gdHlwZW9mIHNlbGVjdG9yID09PSBcImZ1bmN0aW9uXCIgJiYgc2VsZWN0b3IsXG5cdFx0bWF0Y2ggPSAhc2VlZCAmJiB0b2tlbml6ZSggKHNlbGVjdG9yID0gY29tcGlsZWQuc2VsZWN0b3IgfHwgc2VsZWN0b3IpICk7XG5cblx0cmVzdWx0cyA9IHJlc3VsdHMgfHwgW107XG5cblx0Ly8gVHJ5IHRvIG1pbmltaXplIG9wZXJhdGlvbnMgaWYgdGhlcmUgaXMgb25seSBvbmUgc2VsZWN0b3IgaW4gdGhlIGxpc3QgYW5kIG5vIHNlZWRcblx0Ly8gKHRoZSBsYXR0ZXIgb2Ygd2hpY2ggZ3VhcmFudGVlcyB1cyBjb250ZXh0KVxuXHRpZiAoIG1hdGNoLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdC8vIFJlZHVjZSBjb250ZXh0IGlmIHRoZSBsZWFkaW5nIGNvbXBvdW5kIHNlbGVjdG9yIGlzIGFuIElEXG5cdFx0dG9rZW5zID0gbWF0Y2hbMF0gPSBtYXRjaFswXS5zbGljZSggMCApO1xuXHRcdGlmICggdG9rZW5zLmxlbmd0aCA+IDIgJiYgKHRva2VuID0gdG9rZW5zWzBdKS50eXBlID09PSBcIklEXCIgJiZcblx0XHRcdFx0c3VwcG9ydC5nZXRCeUlkICYmIGNvbnRleHQubm9kZVR5cGUgPT09IDkgJiYgZG9jdW1lbnRJc0hUTUwgJiZcblx0XHRcdFx0RXhwci5yZWxhdGl2ZVsgdG9rZW5zWzFdLnR5cGUgXSApIHtcblxuXHRcdFx0Y29udGV4dCA9ICggRXhwci5maW5kW1wiSURcIl0oIHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZShydW5lc2NhcGUsIGZ1bmVzY2FwZSksIGNvbnRleHQgKSB8fCBbXSApWzBdO1xuXHRcdFx0aWYgKCAhY29udGV4dCApIHtcblx0XHRcdFx0cmV0dXJuIHJlc3VsdHM7XG5cblx0XHRcdC8vIFByZWNvbXBpbGVkIG1hdGNoZXJzIHdpbGwgc3RpbGwgdmVyaWZ5IGFuY2VzdHJ5LCBzbyBzdGVwIHVwIGEgbGV2ZWxcblx0XHRcdH0gZWxzZSBpZiAoIGNvbXBpbGVkICkge1xuXHRcdFx0XHRjb250ZXh0ID0gY29udGV4dC5wYXJlbnROb2RlO1xuXHRcdFx0fVxuXG5cdFx0XHRzZWxlY3RvciA9IHNlbGVjdG9yLnNsaWNlKCB0b2tlbnMuc2hpZnQoKS52YWx1ZS5sZW5ndGggKTtcblx0XHR9XG5cblx0XHQvLyBGZXRjaCBhIHNlZWQgc2V0IGZvciByaWdodC10by1sZWZ0IG1hdGNoaW5nXG5cdFx0aSA9IG1hdGNoRXhwcltcIm5lZWRzQ29udGV4dFwiXS50ZXN0KCBzZWxlY3RvciApID8gMCA6IHRva2Vucy5sZW5ndGg7XG5cdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHR0b2tlbiA9IHRva2Vuc1tpXTtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgd2UgaGl0IGEgY29tYmluYXRvclxuXHRcdFx0aWYgKCBFeHByLnJlbGF0aXZlWyAodHlwZSA9IHRva2VuLnR5cGUpIF0gKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0aWYgKCAoZmluZCA9IEV4cHIuZmluZFsgdHlwZSBdKSApIHtcblx0XHRcdFx0Ly8gU2VhcmNoLCBleHBhbmRpbmcgY29udGV4dCBmb3IgbGVhZGluZyBzaWJsaW5nIGNvbWJpbmF0b3JzXG5cdFx0XHRcdGlmICggKHNlZWQgPSBmaW5kKFxuXHRcdFx0XHRcdHRva2VuLm1hdGNoZXNbMF0ucmVwbGFjZSggcnVuZXNjYXBlLCBmdW5lc2NhcGUgKSxcblx0XHRcdFx0XHRyc2libGluZy50ZXN0KCB0b2tlbnNbMF0udHlwZSApICYmIHRlc3RDb250ZXh0KCBjb250ZXh0LnBhcmVudE5vZGUgKSB8fCBjb250ZXh0XG5cdFx0XHRcdCkpICkge1xuXG5cdFx0XHRcdFx0Ly8gSWYgc2VlZCBpcyBlbXB0eSBvciBubyB0b2tlbnMgcmVtYWluLCB3ZSBjYW4gcmV0dXJuIGVhcmx5XG5cdFx0XHRcdFx0dG9rZW5zLnNwbGljZSggaSwgMSApO1xuXHRcdFx0XHRcdHNlbGVjdG9yID0gc2VlZC5sZW5ndGggJiYgdG9TZWxlY3RvciggdG9rZW5zICk7XG5cdFx0XHRcdFx0aWYgKCAhc2VsZWN0b3IgKSB7XG5cdFx0XHRcdFx0XHRwdXNoLmFwcGx5KCByZXN1bHRzLCBzZWVkICk7XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVzdWx0cztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENvbXBpbGUgYW5kIGV4ZWN1dGUgYSBmaWx0ZXJpbmcgZnVuY3Rpb24gaWYgb25lIGlzIG5vdCBwcm92aWRlZFxuXHQvLyBQcm92aWRlIGBtYXRjaGAgdG8gYXZvaWQgcmV0b2tlbml6YXRpb24gaWYgd2UgbW9kaWZpZWQgdGhlIHNlbGVjdG9yIGFib3ZlXG5cdCggY29tcGlsZWQgfHwgY29tcGlsZSggc2VsZWN0b3IsIG1hdGNoICkgKShcblx0XHRzZWVkLFxuXHRcdGNvbnRleHQsXG5cdFx0IWRvY3VtZW50SXNIVE1MLFxuXHRcdHJlc3VsdHMsXG5cdFx0IWNvbnRleHQgfHwgcnNpYmxpbmcudGVzdCggc2VsZWN0b3IgKSAmJiB0ZXN0Q29udGV4dCggY29udGV4dC5wYXJlbnROb2RlICkgfHwgY29udGV4dFxuXHQpO1xuXHRyZXR1cm4gcmVzdWx0cztcbn07XG5cbi8vIE9uZS10aW1lIGFzc2lnbm1lbnRzXG5cbi8vIFNvcnQgc3RhYmlsaXR5XG5zdXBwb3J0LnNvcnRTdGFibGUgPSBleHBhbmRvLnNwbGl0KFwiXCIpLnNvcnQoIHNvcnRPcmRlciApLmpvaW4oXCJcIikgPT09IGV4cGFuZG87XG5cbi8vIFN1cHBvcnQ6IENocm9tZSAxNC0zNStcbi8vIEFsd2F5cyBhc3N1bWUgZHVwbGljYXRlcyBpZiB0aGV5IGFyZW4ndCBwYXNzZWQgdG8gdGhlIGNvbXBhcmlzb24gZnVuY3Rpb25cbnN1cHBvcnQuZGV0ZWN0RHVwbGljYXRlcyA9ICEhaGFzRHVwbGljYXRlO1xuXG4vLyBJbml0aWFsaXplIGFnYWluc3QgdGhlIGRlZmF1bHQgZG9jdW1lbnRcbnNldERvY3VtZW50KCk7XG5cbi8vIFN1cHBvcnQ6IFdlYmtpdDw1MzcuMzIgLSBTYWZhcmkgNi4wLjMvQ2hyb21lIDI1IChmaXhlZCBpbiBDaHJvbWUgMjcpXG4vLyBEZXRhY2hlZCBub2RlcyBjb25mb3VuZGluZ2x5IGZvbGxvdyAqZWFjaCBvdGhlcipcbnN1cHBvcnQuc29ydERldGFjaGVkID0gYXNzZXJ0KGZ1bmN0aW9uKCBkaXYxICkge1xuXHQvLyBTaG91bGQgcmV0dXJuIDEsIGJ1dCByZXR1cm5zIDQgKGZvbGxvd2luZylcblx0cmV0dXJuIGRpdjEuY29tcGFyZURvY3VtZW50UG9zaXRpb24oIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIikgKSAmIDE7XG59KTtcblxuLy8gU3VwcG9ydDogSUU8OFxuLy8gUHJldmVudCBhdHRyaWJ1dGUvcHJvcGVydHkgXCJpbnRlcnBvbGF0aW9uXCJcbi8vIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS9tczUzNjQyOSUyOFZTLjg1JTI5LmFzcHhcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8YSBocmVmPScjJz48L2E+XCI7XG5cdHJldHVybiBkaXYuZmlyc3RDaGlsZC5nZXRBdHRyaWJ1dGUoXCJocmVmXCIpID09PSBcIiNcIiA7XG59KSApIHtcblx0YWRkSGFuZGxlKCBcInR5cGV8aHJlZnxoZWlnaHR8d2lkdGhcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZ2V0QXR0cmlidXRlKCBuYW1lLCBuYW1lLnRvTG93ZXJDYXNlKCkgPT09IFwidHlwZVwiID8gMSA6IDIgKTtcblx0XHR9XG5cdH0pO1xufVxuXG4vLyBTdXBwb3J0OiBJRTw5XG4vLyBVc2UgZGVmYXVsdFZhbHVlIGluIHBsYWNlIG9mIGdldEF0dHJpYnV0ZShcInZhbHVlXCIpXG5pZiAoICFzdXBwb3J0LmF0dHJpYnV0ZXMgfHwgIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRkaXYuaW5uZXJIVE1MID0gXCI8aW5wdXQvPlwiO1xuXHRkaXYuZmlyc3RDaGlsZC5zZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiwgXCJcIiApO1xuXHRyZXR1cm4gZGl2LmZpcnN0Q2hpbGQuZ2V0QXR0cmlidXRlKCBcInZhbHVlXCIgKSA9PT0gXCJcIjtcbn0pICkge1xuXHRhZGRIYW5kbGUoIFwidmFsdWVcIiwgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdGlmICggIWlzWE1MICYmIGVsZW0ubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gXCJpbnB1dFwiICkge1xuXHRcdFx0cmV0dXJuIGVsZW0uZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5cbi8vIFN1cHBvcnQ6IElFPDlcbi8vIFVzZSBnZXRBdHRyaWJ1dGVOb2RlIHRvIGZldGNoIGJvb2xlYW5zIHdoZW4gZ2V0QXR0cmlidXRlIGxpZXNcbmlmICggIWFzc2VydChmdW5jdGlvbiggZGl2ICkge1xuXHRyZXR1cm4gZGl2LmdldEF0dHJpYnV0ZShcImRpc2FibGVkXCIpID09IG51bGw7XG59KSApIHtcblx0YWRkSGFuZGxlKCBib29sZWFucywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGlzWE1MICkge1xuXHRcdHZhciB2YWw7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cdFx0XHRyZXR1cm4gZWxlbVsgbmFtZSBdID09PSB0cnVlID8gbmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0XHQodmFsID0gZWxlbS5nZXRBdHRyaWJ1dGVOb2RlKCBuYW1lICkpICYmIHZhbC5zcGVjaWZpZWQgP1xuXHRcdFx0XHRcdHZhbC52YWx1ZSA6XG5cdFx0XHRcdG51bGw7XG5cdFx0fVxuXHR9KTtcbn1cblxucmV0dXJuIFNpenpsZTtcblxufSkoIHdpbmRvdyApO1xuXG5cblxualF1ZXJ5LmZpbmQgPSBTaXp6bGU7XG5qUXVlcnkuZXhwciA9IFNpenpsZS5zZWxlY3RvcnM7XG5qUXVlcnkuZXhwclsgXCI6XCIgXSA9IGpRdWVyeS5leHByLnBzZXVkb3M7XG5qUXVlcnkudW5pcXVlU29ydCA9IGpRdWVyeS51bmlxdWUgPSBTaXp6bGUudW5pcXVlU29ydDtcbmpRdWVyeS50ZXh0ID0gU2l6emxlLmdldFRleHQ7XG5qUXVlcnkuaXNYTUxEb2MgPSBTaXp6bGUuaXNYTUw7XG5qUXVlcnkuY29udGFpbnMgPSBTaXp6bGUuY29udGFpbnM7XG5cblxuXG52YXIgZGlyID0gZnVuY3Rpb24oIGVsZW0sIGRpciwgdW50aWwgKSB7XG5cdHZhciBtYXRjaGVkID0gW10sXG5cdFx0dHJ1bmNhdGUgPSB1bnRpbCAhPT0gdW5kZWZpbmVkO1xuXG5cdHdoaWxlICggKCBlbGVtID0gZWxlbVsgZGlyIF0gKSAmJiBlbGVtLm5vZGVUeXBlICE9PSA5ICkge1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblx0XHRcdGlmICggdHJ1bmNhdGUgJiYgalF1ZXJ5KCBlbGVtICkuaXMoIHVudGlsICkgKSB7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0bWF0Y2hlZC5wdXNoKCBlbGVtICk7XG5cdFx0fVxuXHR9XG5cdHJldHVybiBtYXRjaGVkO1xufTtcblxuXG52YXIgc2libGluZ3MgPSBmdW5jdGlvbiggbiwgZWxlbSApIHtcblx0dmFyIG1hdGNoZWQgPSBbXTtcblxuXHRmb3IgKCA7IG47IG4gPSBuLm5leHRTaWJsaW5nICkge1xuXHRcdGlmICggbi5ub2RlVHlwZSA9PT0gMSAmJiBuICE9PSBlbGVtICkge1xuXHRcdFx0bWF0Y2hlZC5wdXNoKCBuICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIG1hdGNoZWQ7XG59O1xuXG5cbnZhciBybmVlZHNDb250ZXh0ID0galF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0O1xuXG52YXIgcnNpbmdsZVRhZyA9ICggL148KFtcXHctXSspXFxzKlxcLz8+KD86PFxcL1xcMT58KSQvICk7XG5cblxuXG52YXIgcmlzU2ltcGxlID0gL14uW146I1xcW1xcLixdKiQvO1xuXG4vLyBJbXBsZW1lbnQgdGhlIGlkZW50aWNhbCBmdW5jdGlvbmFsaXR5IGZvciBmaWx0ZXIgYW5kIG5vdFxuZnVuY3Rpb24gd2lubm93KCBlbGVtZW50cywgcXVhbGlmaWVyLCBub3QgKSB7XG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHF1YWxpZmllciApICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ3JlcCggZWxlbWVudHMsIGZ1bmN0aW9uKCBlbGVtLCBpICkge1xuXHRcdFx0LyoganNoaW50IC1XMDE4ICovXG5cdFx0XHRyZXR1cm4gISFxdWFsaWZpZXIuY2FsbCggZWxlbSwgaSwgZWxlbSApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHF1YWxpZmllci5ub2RlVHlwZSApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdyZXAoIGVsZW1lbnRzLCBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHJldHVybiAoIGVsZW0gPT09IHF1YWxpZmllciApICE9PSBub3Q7XG5cdFx0fSApO1xuXG5cdH1cblxuXHRpZiAoIHR5cGVvZiBxdWFsaWZpZXIgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0aWYgKCByaXNTaW1wbGUudGVzdCggcXVhbGlmaWVyICkgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cywgbm90ICk7XG5cdFx0fVxuXG5cdFx0cXVhbGlmaWVyID0galF1ZXJ5LmZpbHRlciggcXVhbGlmaWVyLCBlbGVtZW50cyApO1xuXHR9XG5cblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBlbGVtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuICggaW5kZXhPZi5jYWxsKCBxdWFsaWZpZXIsIGVsZW0gKSA+IC0xICkgIT09IG5vdDtcblx0fSApO1xufVxuXG5qUXVlcnkuZmlsdGVyID0gZnVuY3Rpb24oIGV4cHIsIGVsZW1zLCBub3QgKSB7XG5cdHZhciBlbGVtID0gZWxlbXNbIDAgXTtcblxuXHRpZiAoIG5vdCApIHtcblx0XHRleHByID0gXCI6bm90KFwiICsgZXhwciArIFwiKVwiO1xuXHR9XG5cblx0cmV0dXJuIGVsZW1zLmxlbmd0aCA9PT0gMSAmJiBlbGVtLm5vZGVUeXBlID09PSAxID9cblx0XHRqUXVlcnkuZmluZC5tYXRjaGVzU2VsZWN0b3IoIGVsZW0sIGV4cHIgKSA/IFsgZWxlbSBdIDogW10gOlxuXHRcdGpRdWVyeS5maW5kLm1hdGNoZXMoIGV4cHIsIGpRdWVyeS5ncmVwKCBlbGVtcywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5ub2RlVHlwZSA9PT0gMTtcblx0XHR9ICkgKTtcbn07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0ZmluZDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBpLFxuXHRcdFx0bGVuID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdHNlbGYgPSB0aGlzO1xuXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5wdXNoU3RhY2soIGpRdWVyeSggc2VsZWN0b3IgKS5maWx0ZXIoIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCBzZWxmWyBpIF0sIHRoaXMgKSApIHtcblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSApICk7XG5cdFx0fVxuXG5cdFx0Zm9yICggaSA9IDA7IGkgPCBsZW47IGkrKyApIHtcblx0XHRcdGpRdWVyeS5maW5kKCBzZWxlY3Rvciwgc2VsZlsgaSBdLCByZXQgKTtcblx0XHR9XG5cblx0XHQvLyBOZWVkZWQgYmVjYXVzZSAkKCBzZWxlY3RvciwgY29udGV4dCApIGJlY29tZXMgJCggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yIClcblx0XHRyZXQgPSB0aGlzLnB1c2hTdGFjayggbGVuID4gMSA/IGpRdWVyeS51bmlxdWUoIHJldCApIDogcmV0ICk7XG5cdFx0cmV0LnNlbGVjdG9yID0gdGhpcy5zZWxlY3RvciA/IHRoaXMuc2VsZWN0b3IgKyBcIiBcIiArIHNlbGVjdG9yIDogc2VsZWN0b3I7XG5cdFx0cmV0dXJuIHJldDtcblx0fSxcblx0ZmlsdGVyOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCB3aW5ub3coIHRoaXMsIHNlbGVjdG9yIHx8IFtdLCBmYWxzZSApICk7XG5cdH0sXG5cdG5vdDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggd2lubm93KCB0aGlzLCBzZWxlY3RvciB8fCBbXSwgdHJ1ZSApICk7XG5cdH0sXG5cdGlzOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuICEhd2lubm93KFxuXHRcdFx0dGhpcyxcblxuXHRcdFx0Ly8gSWYgdGhpcyBpcyBhIHBvc2l0aW9uYWwvcmVsYXRpdmUgc2VsZWN0b3IsIGNoZWNrIG1lbWJlcnNoaXAgaW4gdGhlIHJldHVybmVkIHNldFxuXHRcdFx0Ly8gc28gJChcInA6Zmlyc3RcIikuaXMoXCJwOmxhc3RcIikgd29uJ3QgcmV0dXJuIHRydWUgZm9yIGEgZG9jIHdpdGggdHdvIFwicFwiLlxuXHRcdFx0dHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICYmIHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3IgKSA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3IgKSA6XG5cdFx0XHRcdHNlbGVjdG9yIHx8IFtdLFxuXHRcdFx0ZmFsc2Vcblx0XHQpLmxlbmd0aDtcblx0fVxufSApO1xuXG5cbi8vIEluaXRpYWxpemUgYSBqUXVlcnkgb2JqZWN0XG5cblxuLy8gQSBjZW50cmFsIHJlZmVyZW5jZSB0byB0aGUgcm9vdCBqUXVlcnkoZG9jdW1lbnQpXG52YXIgcm9vdGpRdWVyeSxcblxuXHQvLyBBIHNpbXBsZSB3YXkgdG8gY2hlY2sgZm9yIEhUTUwgc3RyaW5nc1xuXHQvLyBQcmlvcml0aXplICNpZCBvdmVyIDx0YWc+IHRvIGF2b2lkIFhTUyB2aWEgbG9jYXRpb24uaGFzaCAoIzk1MjEpXG5cdC8vIFN0cmljdCBIVE1MIHJlY29nbml0aW9uICgjMTEyOTA6IG11c3Qgc3RhcnQgd2l0aCA8KVxuXHRycXVpY2tFeHByID0gL14oPzpcXHMqKDxbXFx3XFxXXSs+KVtePl0qfCMoW1xcdy1dKikpJC8sXG5cblx0aW5pdCA9IGpRdWVyeS5mbi5pbml0ID0gZnVuY3Rpb24oIHNlbGVjdG9yLCBjb250ZXh0LCByb290ICkge1xuXHRcdHZhciBtYXRjaCwgZWxlbTtcblxuXHRcdC8vIEhBTkRMRTogJChcIlwiKSwgJChudWxsKSwgJCh1bmRlZmluZWQpLCAkKGZhbHNlKVxuXHRcdGlmICggIXNlbGVjdG9yICkge1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXG5cdFx0Ly8gTWV0aG9kIGluaXQoKSBhY2NlcHRzIGFuIGFsdGVybmF0ZSByb290alF1ZXJ5XG5cdFx0Ly8gc28gbWlncmF0ZSBjYW4gc3VwcG9ydCBqUXVlcnkuc3ViIChnaC0yMTAxKVxuXHRcdHJvb3QgPSByb290IHx8IHJvb3RqUXVlcnk7XG5cblx0XHQvLyBIYW5kbGUgSFRNTCBzdHJpbmdzXG5cdFx0aWYgKCB0eXBlb2Ygc2VsZWN0b3IgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRpZiAoIHNlbGVjdG9yWyAwIF0gPT09IFwiPFwiICYmXG5cdFx0XHRcdHNlbGVjdG9yWyBzZWxlY3Rvci5sZW5ndGggLSAxIF0gPT09IFwiPlwiICYmXG5cdFx0XHRcdHNlbGVjdG9yLmxlbmd0aCA+PSAzICkge1xuXG5cdFx0XHRcdC8vIEFzc3VtZSB0aGF0IHN0cmluZ3MgdGhhdCBzdGFydCBhbmQgZW5kIHdpdGggPD4gYXJlIEhUTUwgYW5kIHNraXAgdGhlIHJlZ2V4IGNoZWNrXG5cdFx0XHRcdG1hdGNoID0gWyBudWxsLCBzZWxlY3RvciwgbnVsbCBdO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRtYXRjaCA9IHJxdWlja0V4cHIuZXhlYyggc2VsZWN0b3IgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gTWF0Y2ggaHRtbCBvciBtYWtlIHN1cmUgbm8gY29udGV4dCBpcyBzcGVjaWZpZWQgZm9yICNpZFxuXHRcdFx0aWYgKCBtYXRjaCAmJiAoIG1hdGNoWyAxIF0gfHwgIWNvbnRleHQgKSApIHtcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoaHRtbCkgLT4gJChhcnJheSlcblx0XHRcdFx0aWYgKCBtYXRjaFsgMSBdICkge1xuXHRcdFx0XHRcdGNvbnRleHQgPSBjb250ZXh0IGluc3RhbmNlb2YgalF1ZXJ5ID8gY29udGV4dFsgMCBdIDogY29udGV4dDtcblxuXHRcdFx0XHRcdC8vIE9wdGlvbiB0byBydW4gc2NyaXB0cyBpcyB0cnVlIGZvciBiYWNrLWNvbXBhdFxuXHRcdFx0XHRcdC8vIEludGVudGlvbmFsbHkgbGV0IHRoZSBlcnJvciBiZSB0aHJvd24gaWYgcGFyc2VIVE1MIGlzIG5vdCBwcmVzZW50XG5cdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCB0aGlzLCBqUXVlcnkucGFyc2VIVE1MKFxuXHRcdFx0XHRcdFx0bWF0Y2hbIDEgXSxcblx0XHRcdFx0XHRcdGNvbnRleHQgJiYgY29udGV4dC5ub2RlVHlwZSA/IGNvbnRleHQub3duZXJEb2N1bWVudCB8fCBjb250ZXh0IDogZG9jdW1lbnQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KSApO1xuXG5cdFx0XHRcdFx0Ly8gSEFORExFOiAkKGh0bWwsIHByb3BzKVxuXHRcdFx0XHRcdGlmICggcnNpbmdsZVRhZy50ZXN0KCBtYXRjaFsgMSBdICkgJiYgalF1ZXJ5LmlzUGxhaW5PYmplY3QoIGNvbnRleHQgKSApIHtcblx0XHRcdFx0XHRcdGZvciAoIG1hdGNoIGluIGNvbnRleHQgKSB7XG5cblx0XHRcdFx0XHRcdFx0Ly8gUHJvcGVydGllcyBvZiBjb250ZXh0IGFyZSBjYWxsZWQgYXMgbWV0aG9kcyBpZiBwb3NzaWJsZVxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB0aGlzWyBtYXRjaCBdICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpc1sgbWF0Y2ggXSggY29udGV4dFsgbWF0Y2ggXSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIC4uLmFuZCBvdGhlcndpc2Ugc2V0IGFzIGF0dHJpYnV0ZXNcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHR0aGlzLmF0dHIoIG1hdGNoLCBjb250ZXh0WyBtYXRjaCBdICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblxuXHRcdFx0XHQvLyBIQU5ETEU6ICQoI2lkKVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGVsZW0gPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCggbWF0Y2hbIDIgXSApO1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQmxhY2tiZXJyeSA0LjZcblx0XHRcdFx0XHQvLyBnRUJJRCByZXR1cm5zIG5vZGVzIG5vIGxvbmdlciBpbiB0aGUgZG9jdW1lbnQgKCM2OTYzKVxuXHRcdFx0XHRcdGlmICggZWxlbSAmJiBlbGVtLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEluamVjdCB0aGUgZWxlbWVudCBkaXJlY3RseSBpbnRvIHRoZSBqUXVlcnkgb2JqZWN0XG5cdFx0XHRcdFx0XHR0aGlzLmxlbmd0aCA9IDE7XG5cdFx0XHRcdFx0XHR0aGlzWyAwIF0gPSBlbGVtO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdHRoaXMuY29udGV4dCA9IGRvY3VtZW50O1xuXHRcdFx0XHRcdHRoaXMuc2VsZWN0b3IgPSBzZWxlY3Rvcjtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXG5cdFx0XHQvLyBIQU5ETEU6ICQoZXhwciwgJCguLi4pKVxuXHRcdFx0fSBlbHNlIGlmICggIWNvbnRleHQgfHwgY29udGV4dC5qcXVlcnkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGNvbnRleHQgfHwgcm9vdCApLmZpbmQoIHNlbGVjdG9yICk7XG5cblx0XHRcdC8vIEhBTkRMRTogJChleHByLCBjb250ZXh0KVxuXHRcdFx0Ly8gKHdoaWNoIGlzIGp1c3QgZXF1aXZhbGVudCB0bzogJChjb250ZXh0KS5maW5kKGV4cHIpXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5jb25zdHJ1Y3RvciggY29udGV4dCApLmZpbmQoIHNlbGVjdG9yICk7XG5cdFx0XHR9XG5cblx0XHQvLyBIQU5ETEU6ICQoRE9NRWxlbWVudClcblx0XHR9IGVsc2UgaWYgKCBzZWxlY3Rvci5ub2RlVHlwZSApIHtcblx0XHRcdHRoaXMuY29udGV4dCA9IHRoaXNbIDAgXSA9IHNlbGVjdG9yO1xuXHRcdFx0dGhpcy5sZW5ndGggPSAxO1xuXHRcdFx0cmV0dXJuIHRoaXM7XG5cblx0XHQvLyBIQU5ETEU6ICQoZnVuY3Rpb24pXG5cdFx0Ly8gU2hvcnRjdXQgZm9yIGRvY3VtZW50IHJlYWR5XG5cdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHNlbGVjdG9yICkgKSB7XG5cdFx0XHRyZXR1cm4gcm9vdC5yZWFkeSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0cm9vdC5yZWFkeSggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gRXhlY3V0ZSBpbW1lZGlhdGVseSBpZiByZWFkeSBpcyBub3QgcHJlc2VudFxuXHRcdFx0XHRzZWxlY3RvciggalF1ZXJ5ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBzZWxlY3Rvci5zZWxlY3RvciAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5zZWxlY3RvciA9IHNlbGVjdG9yLnNlbGVjdG9yO1xuXHRcdFx0dGhpcy5jb250ZXh0ID0gc2VsZWN0b3IuY29udGV4dDtcblx0XHR9XG5cblx0XHRyZXR1cm4galF1ZXJ5Lm1ha2VBcnJheSggc2VsZWN0b3IsIHRoaXMgKTtcblx0fTtcblxuLy8gR2l2ZSB0aGUgaW5pdCBmdW5jdGlvbiB0aGUgalF1ZXJ5IHByb3RvdHlwZSBmb3IgbGF0ZXIgaW5zdGFudGlhdGlvblxuaW5pdC5wcm90b3R5cGUgPSBqUXVlcnkuZm47XG5cbi8vIEluaXRpYWxpemUgY2VudHJhbCByZWZlcmVuY2VcbnJvb3RqUXVlcnkgPSBqUXVlcnkoIGRvY3VtZW50ICk7XG5cblxudmFyIHJwYXJlbnRzcHJldiA9IC9eKD86cGFyZW50c3xwcmV2KD86VW50aWx8QWxsKSkvLFxuXG5cdC8vIE1ldGhvZHMgZ3VhcmFudGVlZCB0byBwcm9kdWNlIGEgdW5pcXVlIHNldCB3aGVuIHN0YXJ0aW5nIGZyb20gYSB1bmlxdWUgc2V0XG5cdGd1YXJhbnRlZWRVbmlxdWUgPSB7XG5cdFx0Y2hpbGRyZW46IHRydWUsXG5cdFx0Y29udGVudHM6IHRydWUsXG5cdFx0bmV4dDogdHJ1ZSxcblx0XHRwcmV2OiB0cnVlXG5cdH07XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0aGFzOiBmdW5jdGlvbiggdGFyZ2V0ICkge1xuXHRcdHZhciB0YXJnZXRzID0galF1ZXJ5KCB0YXJnZXQsIHRoaXMgKSxcblx0XHRcdGwgPSB0YXJnZXRzLmxlbmd0aDtcblxuXHRcdHJldHVybiB0aGlzLmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgaSA9IDA7XG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdGlmICggalF1ZXJ5LmNvbnRhaW5zKCB0aGlzLCB0YXJnZXRzWyBpIF0gKSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRjbG9zZXN0OiBmdW5jdGlvbiggc2VsZWN0b3JzLCBjb250ZXh0ICkge1xuXHRcdHZhciBjdXIsXG5cdFx0XHRpID0gMCxcblx0XHRcdGwgPSB0aGlzLmxlbmd0aCxcblx0XHRcdG1hdGNoZWQgPSBbXSxcblx0XHRcdHBvcyA9IHJuZWVkc0NvbnRleHQudGVzdCggc2VsZWN0b3JzICkgfHwgdHlwZW9mIHNlbGVjdG9ycyAhPT0gXCJzdHJpbmdcIiA/XG5cdFx0XHRcdGpRdWVyeSggc2VsZWN0b3JzLCBjb250ZXh0IHx8IHRoaXMuY29udGV4dCApIDpcblx0XHRcdFx0MDtcblxuXHRcdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdGZvciAoIGN1ciA9IHRoaXNbIGkgXTsgY3VyICYmIGN1ciAhPT0gY29udGV4dDsgY3VyID0gY3VyLnBhcmVudE5vZGUgKSB7XG5cblx0XHRcdFx0Ly8gQWx3YXlzIHNraXAgZG9jdW1lbnQgZnJhZ21lbnRzXG5cdFx0XHRcdGlmICggY3VyLm5vZGVUeXBlIDwgMTEgJiYgKCBwb3MgP1xuXHRcdFx0XHRcdHBvcy5pbmRleCggY3VyICkgPiAtMSA6XG5cblx0XHRcdFx0XHQvLyBEb24ndCBwYXNzIG5vbi1lbGVtZW50cyB0byBTaXp6bGVcblx0XHRcdFx0XHRjdXIubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0XHRcdGpRdWVyeS5maW5kLm1hdGNoZXNTZWxlY3RvciggY3VyLCBzZWxlY3RvcnMgKSApICkge1xuXG5cdFx0XHRcdFx0bWF0Y2hlZC5wdXNoKCBjdXIgKTtcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZC5sZW5ndGggPiAxID8galF1ZXJ5LnVuaXF1ZVNvcnQoIG1hdGNoZWQgKSA6IG1hdGNoZWQgKTtcblx0fSxcblxuXHQvLyBEZXRlcm1pbmUgdGhlIHBvc2l0aW9uIG9mIGFuIGVsZW1lbnQgd2l0aGluIHRoZSBzZXRcblx0aW5kZXg6IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gTm8gYXJndW1lbnQsIHJldHVybiBpbmRleCBpbiBwYXJlbnRcblx0XHRpZiAoICFlbGVtICkge1xuXHRcdFx0cmV0dXJuICggdGhpc1sgMCBdICYmIHRoaXNbIDAgXS5wYXJlbnROb2RlICkgPyB0aGlzLmZpcnN0KCkucHJldkFsbCgpLmxlbmd0aCA6IC0xO1xuXHRcdH1cblxuXHRcdC8vIEluZGV4IGluIHNlbGVjdG9yXG5cdFx0aWYgKCB0eXBlb2YgZWxlbSA9PT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdHJldHVybiBpbmRleE9mLmNhbGwoIGpRdWVyeSggZWxlbSApLCB0aGlzWyAwIF0gKTtcblx0XHR9XG5cblx0XHQvLyBMb2NhdGUgdGhlIHBvc2l0aW9uIG9mIHRoZSBkZXNpcmVkIGVsZW1lbnRcblx0XHRyZXR1cm4gaW5kZXhPZi5jYWxsKCB0aGlzLFxuXG5cdFx0XHQvLyBJZiBpdCByZWNlaXZlcyBhIGpRdWVyeSBvYmplY3QsIHRoZSBmaXJzdCBlbGVtZW50IGlzIHVzZWRcblx0XHRcdGVsZW0uanF1ZXJ5ID8gZWxlbVsgMCBdIDogZWxlbVxuXHRcdCk7XG5cdH0sXG5cblx0YWRkOiBmdW5jdGlvbiggc2VsZWN0b3IsIGNvbnRleHQgKSB7XG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKFxuXHRcdFx0alF1ZXJ5LnVuaXF1ZVNvcnQoXG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggdGhpcy5nZXQoKSwgalF1ZXJ5KCBzZWxlY3RvciwgY29udGV4dCApIClcblx0XHRcdClcblx0XHQpO1xuXHR9LFxuXG5cdGFkZEJhY2s6IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHRyZXR1cm4gdGhpcy5hZGQoIHNlbGVjdG9yID09IG51bGwgP1xuXHRcdFx0dGhpcy5wcmV2T2JqZWN0IDogdGhpcy5wcmV2T2JqZWN0LmZpbHRlciggc2VsZWN0b3IgKVxuXHRcdCk7XG5cdH1cbn0gKTtcblxuZnVuY3Rpb24gc2libGluZyggY3VyLCBkaXIgKSB7XG5cdHdoaWxlICggKCBjdXIgPSBjdXJbIGRpciBdICkgJiYgY3VyLm5vZGVUeXBlICE9PSAxICkge31cblx0cmV0dXJuIGN1cjtcbn1cblxualF1ZXJ5LmVhY2goIHtcblx0cGFyZW50OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHR2YXIgcGFyZW50ID0gZWxlbS5wYXJlbnROb2RlO1xuXHRcdHJldHVybiBwYXJlbnQgJiYgcGFyZW50Lm5vZGVUeXBlICE9PSAxMSA/IHBhcmVudCA6IG51bGw7XG5cdH0sXG5cdHBhcmVudHM6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiICk7XG5cdH0sXG5cdHBhcmVudHNVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwicGFyZW50Tm9kZVwiLCB1bnRpbCApO1xuXHR9LFxuXHRuZXh0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZyggZWxlbSwgXCJuZXh0U2libGluZ1wiICk7XG5cdH0sXG5cdHByZXY6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5nKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRBbGw6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiApO1xuXHR9LFxuXHRwcmV2QWxsOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gZGlyKCBlbGVtLCBcInByZXZpb3VzU2libGluZ1wiICk7XG5cdH0sXG5cdG5leHRVbnRpbDogZnVuY3Rpb24oIGVsZW0sIGksIHVudGlsICkge1xuXHRcdHJldHVybiBkaXIoIGVsZW0sIFwibmV4dFNpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0cHJldlVudGlsOiBmdW5jdGlvbiggZWxlbSwgaSwgdW50aWwgKSB7XG5cdFx0cmV0dXJuIGRpciggZWxlbSwgXCJwcmV2aW91c1NpYmxpbmdcIiwgdW50aWwgKTtcblx0fSxcblx0c2libGluZ3M6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdHJldHVybiBzaWJsaW5ncyggKCBlbGVtLnBhcmVudE5vZGUgfHwge30gKS5maXJzdENoaWxkLCBlbGVtICk7XG5cdH0sXG5cdGNoaWxkcmVuOiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRyZXR1cm4gc2libGluZ3MoIGVsZW0uZmlyc3RDaGlsZCApO1xuXHR9LFxuXHRjb250ZW50czogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGVsZW0uY29udGVudERvY3VtZW50IHx8IGpRdWVyeS5tZXJnZSggW10sIGVsZW0uY2hpbGROb2RlcyApO1xuXHR9XG59LCBmdW5jdGlvbiggbmFtZSwgZm4gKSB7XG5cdGpRdWVyeS5mblsgbmFtZSBdID0gZnVuY3Rpb24oIHVudGlsLCBzZWxlY3RvciApIHtcblx0XHR2YXIgbWF0Y2hlZCA9IGpRdWVyeS5tYXAoIHRoaXMsIGZuLCB1bnRpbCApO1xuXG5cdFx0aWYgKCBuYW1lLnNsaWNlKCAtNSApICE9PSBcIlVudGlsXCIgKSB7XG5cdFx0XHRzZWxlY3RvciA9IHVudGlsO1xuXHRcdH1cblxuXHRcdGlmICggc2VsZWN0b3IgJiYgdHlwZW9mIHNlbGVjdG9yID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0bWF0Y2hlZCA9IGpRdWVyeS5maWx0ZXIoIHNlbGVjdG9yLCBtYXRjaGVkICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmxlbmd0aCA+IDEgKSB7XG5cblx0XHRcdC8vIFJlbW92ZSBkdXBsaWNhdGVzXG5cdFx0XHRpZiAoICFndWFyYW50ZWVkVW5pcXVlWyBuYW1lIF0gKSB7XG5cdFx0XHRcdGpRdWVyeS51bmlxdWVTb3J0KCBtYXRjaGVkICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFJldmVyc2Ugb3JkZXIgZm9yIHBhcmVudHMqIGFuZCBwcmV2LWRlcml2YXRpdmVzXG5cdFx0XHRpZiAoIHJwYXJlbnRzcHJldi50ZXN0KCBuYW1lICkgKSB7XG5cdFx0XHRcdG1hdGNoZWQucmV2ZXJzZSgpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzLnB1c2hTdGFjayggbWF0Y2hlZCApO1xuXHR9O1xufSApO1xudmFyIHJub3R3aGl0ZSA9ICggL1xcUysvZyApO1xuXG5cblxuLy8gQ29udmVydCBTdHJpbmctZm9ybWF0dGVkIG9wdGlvbnMgaW50byBPYmplY3QtZm9ybWF0dGVkIG9uZXNcbmZ1bmN0aW9uIGNyZWF0ZU9wdGlvbnMoIG9wdGlvbnMgKSB7XG5cdHZhciBvYmplY3QgPSB7fTtcblx0alF1ZXJ5LmVhY2goIG9wdGlvbnMubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdLCBmdW5jdGlvbiggXywgZmxhZyApIHtcblx0XHRvYmplY3RbIGZsYWcgXSA9IHRydWU7XG5cdH0gKTtcblx0cmV0dXJuIG9iamVjdDtcbn1cblxuLypcbiAqIENyZWF0ZSBhIGNhbGxiYWNrIGxpc3QgdXNpbmcgdGhlIGZvbGxvd2luZyBwYXJhbWV0ZXJzOlxuICpcbiAqXHRvcHRpb25zOiBhbiBvcHRpb25hbCBsaXN0IG9mIHNwYWNlLXNlcGFyYXRlZCBvcHRpb25zIHRoYXQgd2lsbCBjaGFuZ2UgaG93XG4gKlx0XHRcdHRoZSBjYWxsYmFjayBsaXN0IGJlaGF2ZXMgb3IgYSBtb3JlIHRyYWRpdGlvbmFsIG9wdGlvbiBvYmplY3RcbiAqXG4gKiBCeSBkZWZhdWx0IGEgY2FsbGJhY2sgbGlzdCB3aWxsIGFjdCBsaWtlIGFuIGV2ZW50IGNhbGxiYWNrIGxpc3QgYW5kIGNhbiBiZVxuICogXCJmaXJlZFwiIG11bHRpcGxlIHRpbWVzLlxuICpcbiAqIFBvc3NpYmxlIG9wdGlvbnM6XG4gKlxuICpcdG9uY2U6XHRcdFx0d2lsbCBlbnN1cmUgdGhlIGNhbGxiYWNrIGxpc3QgY2FuIG9ubHkgYmUgZmlyZWQgb25jZSAobGlrZSBhIERlZmVycmVkKVxuICpcbiAqXHRtZW1vcnk6XHRcdFx0d2lsbCBrZWVwIHRyYWNrIG9mIHByZXZpb3VzIHZhbHVlcyBhbmQgd2lsbCBjYWxsIGFueSBjYWxsYmFjayBhZGRlZFxuICpcdFx0XHRcdFx0YWZ0ZXIgdGhlIGxpc3QgaGFzIGJlZW4gZmlyZWQgcmlnaHQgYXdheSB3aXRoIHRoZSBsYXRlc3QgXCJtZW1vcml6ZWRcIlxuICpcdFx0XHRcdFx0dmFsdWVzIChsaWtlIGEgRGVmZXJyZWQpXG4gKlxuICpcdHVuaXF1ZTpcdFx0XHR3aWxsIGVuc3VyZSBhIGNhbGxiYWNrIGNhbiBvbmx5IGJlIGFkZGVkIG9uY2UgKG5vIGR1cGxpY2F0ZSBpbiB0aGUgbGlzdClcbiAqXG4gKlx0c3RvcE9uRmFsc2U6XHRpbnRlcnJ1cHQgY2FsbGluZ3Mgd2hlbiBhIGNhbGxiYWNrIHJldHVybnMgZmFsc2VcbiAqXG4gKi9cbmpRdWVyeS5DYWxsYmFja3MgPSBmdW5jdGlvbiggb3B0aW9ucyApIHtcblxuXHQvLyBDb252ZXJ0IG9wdGlvbnMgZnJvbSBTdHJpbmctZm9ybWF0dGVkIHRvIE9iamVjdC1mb3JtYXR0ZWQgaWYgbmVlZGVkXG5cdC8vICh3ZSBjaGVjayBpbiBjYWNoZSBmaXJzdClcblx0b3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiID9cblx0XHRjcmVhdGVPcHRpb25zKCBvcHRpb25zICkgOlxuXHRcdGpRdWVyeS5leHRlbmQoIHt9LCBvcHRpb25zICk7XG5cblx0dmFyIC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IGlzIGN1cnJlbnRseSBmaXJpbmdcblx0XHRmaXJpbmcsXG5cblx0XHQvLyBMYXN0IGZpcmUgdmFsdWUgZm9yIG5vbi1mb3JnZXR0YWJsZSBsaXN0c1xuXHRcdG1lbW9yeSxcblxuXHRcdC8vIEZsYWcgdG8ga25vdyBpZiBsaXN0IHdhcyBhbHJlYWR5IGZpcmVkXG5cdFx0ZmlyZWQsXG5cblx0XHQvLyBGbGFnIHRvIHByZXZlbnQgZmlyaW5nXG5cdFx0bG9ja2VkLFxuXG5cdFx0Ly8gQWN0dWFsIGNhbGxiYWNrIGxpc3Rcblx0XHRsaXN0ID0gW10sXG5cblx0XHQvLyBRdWV1ZSBvZiBleGVjdXRpb24gZGF0YSBmb3IgcmVwZWF0YWJsZSBsaXN0c1xuXHRcdHF1ZXVlID0gW10sXG5cblx0XHQvLyBJbmRleCBvZiBjdXJyZW50bHkgZmlyaW5nIGNhbGxiYWNrIChtb2RpZmllZCBieSBhZGQvcmVtb3ZlIGFzIG5lZWRlZClcblx0XHRmaXJpbmdJbmRleCA9IC0xLFxuXG5cdFx0Ly8gRmlyZSBjYWxsYmFja3Ncblx0XHRmaXJlID0gZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuZm9yY2Ugc2luZ2xlLWZpcmluZ1xuXHRcdFx0bG9ja2VkID0gb3B0aW9ucy5vbmNlO1xuXG5cdFx0XHQvLyBFeGVjdXRlIGNhbGxiYWNrcyBmb3IgYWxsIHBlbmRpbmcgZXhlY3V0aW9ucyxcblx0XHRcdC8vIHJlc3BlY3RpbmcgZmlyaW5nSW5kZXggb3ZlcnJpZGVzIGFuZCBydW50aW1lIGNoYW5nZXNcblx0XHRcdGZpcmVkID0gZmlyaW5nID0gdHJ1ZTtcblx0XHRcdGZvciAoIDsgcXVldWUubGVuZ3RoOyBmaXJpbmdJbmRleCA9IC0xICkge1xuXHRcdFx0XHRtZW1vcnkgPSBxdWV1ZS5zaGlmdCgpO1xuXHRcdFx0XHR3aGlsZSAoICsrZmlyaW5nSW5kZXggPCBsaXN0Lmxlbmd0aCApIHtcblxuXHRcdFx0XHRcdC8vIFJ1biBjYWxsYmFjayBhbmQgY2hlY2sgZm9yIGVhcmx5IHRlcm1pbmF0aW9uXG5cdFx0XHRcdFx0aWYgKCBsaXN0WyBmaXJpbmdJbmRleCBdLmFwcGx5KCBtZW1vcnlbIDAgXSwgbWVtb3J5WyAxIF0gKSA9PT0gZmFsc2UgJiZcblx0XHRcdFx0XHRcdG9wdGlvbnMuc3RvcE9uRmFsc2UgKSB7XG5cblx0XHRcdFx0XHRcdC8vIEp1bXAgdG8gZW5kIGFuZCBmb3JnZXQgdGhlIGRhdGEgc28gLmFkZCBkb2Vzbid0IHJlLWZpcmVcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRcdFx0XHRtZW1vcnkgPSBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gRm9yZ2V0IHRoZSBkYXRhIGlmIHdlJ3JlIGRvbmUgd2l0aCBpdFxuXHRcdFx0aWYgKCAhb3B0aW9ucy5tZW1vcnkgKSB7XG5cdFx0XHRcdG1lbW9yeSA9IGZhbHNlO1xuXHRcdFx0fVxuXG5cdFx0XHRmaXJpbmcgPSBmYWxzZTtcblxuXHRcdFx0Ly8gQ2xlYW4gdXAgaWYgd2UncmUgZG9uZSBmaXJpbmcgZm9yIGdvb2Rcblx0XHRcdGlmICggbG9ja2VkICkge1xuXG5cdFx0XHRcdC8vIEtlZXAgYW4gZW1wdHkgbGlzdCBpZiB3ZSBoYXZlIGRhdGEgZm9yIGZ1dHVyZSBhZGQgY2FsbHNcblx0XHRcdFx0aWYgKCBtZW1vcnkgKSB7XG5cdFx0XHRcdFx0bGlzdCA9IFtdO1xuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSwgdGhpcyBvYmplY3QgaXMgc3BlbnRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRsaXN0ID0gXCJcIjtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHQvLyBBY3R1YWwgQ2FsbGJhY2tzIG9iamVjdFxuXHRcdHNlbGYgPSB7XG5cblx0XHRcdC8vIEFkZCBhIGNhbGxiYWNrIG9yIGEgY29sbGVjdGlvbiBvZiBjYWxsYmFja3MgdG8gdGhlIGxpc3Rcblx0XHRcdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblxuXHRcdFx0XHRcdC8vIElmIHdlIGhhdmUgbWVtb3J5IGZyb20gYSBwYXN0IHJ1biwgd2Ugc2hvdWxkIGZpcmUgYWZ0ZXIgYWRkaW5nXG5cdFx0XHRcdFx0aWYgKCBtZW1vcnkgJiYgIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmluZ0luZGV4ID0gbGlzdC5sZW5ndGggLSAxO1xuXHRcdFx0XHRcdFx0cXVldWUucHVzaCggbWVtb3J5ICk7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0KCBmdW5jdGlvbiBhZGQoIGFyZ3MgKSB7XG5cdFx0XHRcdFx0XHRqUXVlcnkuZWFjaCggYXJncywgZnVuY3Rpb24oIF8sIGFyZyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYXJnICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0aWYgKCAhb3B0aW9ucy51bmlxdWUgfHwgIXNlbGYuaGFzKCBhcmcgKSApIHtcblx0XHRcdFx0XHRcdFx0XHRcdGxpc3QucHVzaCggYXJnICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBhcmcgJiYgYXJnLmxlbmd0aCAmJiBqUXVlcnkudHlwZSggYXJnICkgIT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHQvLyBJbnNwZWN0IHJlY3Vyc2l2ZWx5XG5cdFx0XHRcdFx0XHRcdFx0YWRkKCBhcmcgKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdH0gKSggYXJndW1lbnRzICk7XG5cblx0XHRcdFx0XHRpZiAoIG1lbW9yeSAmJiAhZmlyaW5nICkge1xuXHRcdFx0XHRcdFx0ZmlyZSgpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFJlbW92ZSBhIGNhbGxiYWNrIGZyb20gdGhlIGxpc3Rcblx0XHRcdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeS5lYWNoKCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBfLCBhcmcgKSB7XG5cdFx0XHRcdFx0dmFyIGluZGV4O1xuXHRcdFx0XHRcdHdoaWxlICggKCBpbmRleCA9IGpRdWVyeS5pbkFycmF5KCBhcmcsIGxpc3QsIGluZGV4ICkgKSA+IC0xICkge1xuXHRcdFx0XHRcdFx0bGlzdC5zcGxpY2UoIGluZGV4LCAxICk7XG5cblx0XHRcdFx0XHRcdC8vIEhhbmRsZSBmaXJpbmcgaW5kZXhlc1xuXHRcdFx0XHRcdFx0aWYgKCBpbmRleCA8PSBmaXJpbmdJbmRleCApIHtcblx0XHRcdFx0XHRcdFx0ZmlyaW5nSW5kZXgtLTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0gKTtcblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDaGVjayBpZiBhIGdpdmVuIGNhbGxiYWNrIGlzIGluIHRoZSBsaXN0LlxuXHRcdFx0Ly8gSWYgbm8gYXJndW1lbnQgaXMgZ2l2ZW4sIHJldHVybiB3aGV0aGVyIG9yIG5vdCBsaXN0IGhhcyBjYWxsYmFja3MgYXR0YWNoZWQuXG5cdFx0XHRoYXM6IGZ1bmN0aW9uKCBmbiApIHtcblx0XHRcdFx0cmV0dXJuIGZuID9cblx0XHRcdFx0XHRqUXVlcnkuaW5BcnJheSggZm4sIGxpc3QgKSA+IC0xIDpcblx0XHRcdFx0XHRsaXN0Lmxlbmd0aCA+IDA7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBSZW1vdmUgYWxsIGNhbGxiYWNrcyBmcm9tIHRoZSBsaXN0XG5cdFx0XHRlbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggbGlzdCApIHtcblx0XHRcdFx0XHRsaXN0ID0gW107XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBEaXNhYmxlIC5maXJlIGFuZCAuYWRkXG5cdFx0XHQvLyBBYm9ydCBhbnkgY3VycmVudC9wZW5kaW5nIGV4ZWN1dGlvbnNcblx0XHRcdC8vIENsZWFyIGFsbCBjYWxsYmFja3MgYW5kIHZhbHVlc1xuXHRcdFx0ZGlzYWJsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGxvY2tlZCA9IHF1ZXVlID0gW107XG5cdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cdFx0XHRkaXNhYmxlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhbGlzdDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIERpc2FibGUgLmZpcmVcblx0XHRcdC8vIEFsc28gZGlzYWJsZSAuYWRkIHVubGVzcyB3ZSBoYXZlIG1lbW9yeSAoc2luY2UgaXQgd291bGQgaGF2ZSBubyBlZmZlY3QpXG5cdFx0XHQvLyBBYm9ydCBhbnkgcGVuZGluZyBleGVjdXRpb25zXG5cdFx0XHRsb2NrOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0bG9ja2VkID0gcXVldWUgPSBbXTtcblx0XHRcdFx0aWYgKCAhbWVtb3J5ICkge1xuXHRcdFx0XHRcdGxpc3QgPSBtZW1vcnkgPSBcIlwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fSxcblx0XHRcdGxvY2tlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHJldHVybiAhIWxvY2tlZDtcblx0XHRcdH0sXG5cblx0XHRcdC8vIENhbGwgYWxsIGNhbGxiYWNrcyB3aXRoIHRoZSBnaXZlbiBjb250ZXh0IGFuZCBhcmd1bWVudHNcblx0XHRcdGZpcmVXaXRoOiBmdW5jdGlvbiggY29udGV4dCwgYXJncyApIHtcblx0XHRcdFx0aWYgKCAhbG9ja2VkICkge1xuXHRcdFx0XHRcdGFyZ3MgPSBhcmdzIHx8IFtdO1xuXHRcdFx0XHRcdGFyZ3MgPSBbIGNvbnRleHQsIGFyZ3Muc2xpY2UgPyBhcmdzLnNsaWNlKCkgOiBhcmdzIF07XG5cdFx0XHRcdFx0cXVldWUucHVzaCggYXJncyApO1xuXHRcdFx0XHRcdGlmICggIWZpcmluZyApIHtcblx0XHRcdFx0XHRcdGZpcmUoKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBDYWxsIGFsbCB0aGUgY2FsbGJhY2tzIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50c1xuXHRcdFx0ZmlyZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHNlbGYuZmlyZVdpdGgoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdH0sXG5cblx0XHRcdC8vIFRvIGtub3cgaWYgdGhlIGNhbGxiYWNrcyBoYXZlIGFscmVhZHkgYmVlbiBjYWxsZWQgYXQgbGVhc3Qgb25jZVxuXHRcdFx0ZmlyZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gISFmaXJlZDtcblx0XHRcdH1cblx0XHR9O1xuXG5cdHJldHVybiBzZWxmO1xufTtcblxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0RGVmZXJyZWQ6IGZ1bmN0aW9uKCBmdW5jICkge1xuXHRcdHZhciB0dXBsZXMgPSBbXG5cblx0XHRcdFx0Ly8gYWN0aW9uLCBhZGQgbGlzdGVuZXIsIGxpc3RlbmVyIGxpc3QsIGZpbmFsIHN0YXRlXG5cdFx0XHRcdFsgXCJyZXNvbHZlXCIsIFwiZG9uZVwiLCBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSwgXCJyZXNvbHZlZFwiIF0sXG5cdFx0XHRcdFsgXCJyZWplY3RcIiwgXCJmYWlsXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwib25jZSBtZW1vcnlcIiApLCBcInJlamVjdGVkXCIgXSxcblx0XHRcdFx0WyBcIm5vdGlmeVwiLCBcInByb2dyZXNzXCIsIGpRdWVyeS5DYWxsYmFja3MoIFwibWVtb3J5XCIgKSBdXG5cdFx0XHRdLFxuXHRcdFx0c3RhdGUgPSBcInBlbmRpbmdcIixcblx0XHRcdHByb21pc2UgPSB7XG5cdFx0XHRcdHN0YXRlOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRyZXR1cm4gc3RhdGU7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdGFsd2F5czogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0ZGVmZXJyZWQuZG9uZSggYXJndW1lbnRzICkuZmFpbCggYXJndW1lbnRzICk7XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cdFx0XHRcdHRoZW46IGZ1bmN0aW9uKCAvKiBmbkRvbmUsIGZuRmFpbCwgZm5Qcm9ncmVzcyAqLyApIHtcblx0XHRcdFx0XHR2YXIgZm5zID0gYXJndW1lbnRzO1xuXHRcdFx0XHRcdHJldHVybiBqUXVlcnkuRGVmZXJyZWQoIGZ1bmN0aW9uKCBuZXdEZWZlciApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5lYWNoKCB0dXBsZXMsIGZ1bmN0aW9uKCBpLCB0dXBsZSApIHtcblx0XHRcdFx0XHRcdFx0dmFyIGZuID0galF1ZXJ5LmlzRnVuY3Rpb24oIGZuc1sgaSBdICkgJiYgZm5zWyBpIF07XG5cblx0XHRcdFx0XHRcdFx0Ly8gZGVmZXJyZWRbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSBmb3IgZm9yd2FyZGluZyBhY3Rpb25zIHRvIG5ld0RlZmVyXG5cdFx0XHRcdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMSBdIF0oIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRcdHZhciByZXR1cm5lZCA9IGZuICYmIGZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIHJldHVybmVkICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXR1cm5lZC5wcm9taXNlICkgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRyZXR1cm5lZC5wcm9taXNlKClcblx0XHRcdFx0XHRcdFx0XHRcdFx0LnByb2dyZXNzKCBuZXdEZWZlci5ub3RpZnkgKVxuXHRcdFx0XHRcdFx0XHRcdFx0XHQuZG9uZSggbmV3RGVmZXIucmVzb2x2ZSApXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC5mYWlsKCBuZXdEZWZlci5yZWplY3QgKTtcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRcdFx0bmV3RGVmZXJbIHR1cGxlWyAwIF0gKyBcIldpdGhcIiBdKFxuXHRcdFx0XHRcdFx0XHRcdFx0XHR0aGlzID09PSBwcm9taXNlID8gbmV3RGVmZXIucHJvbWlzZSgpIDogdGhpcyxcblx0XHRcdFx0XHRcdFx0XHRcdFx0Zm4gPyBbIHJldHVybmVkIF0gOiBhcmd1bWVudHNcblx0XHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHR9ICk7XG5cdFx0XHRcdFx0XHRmbnMgPSBudWxsO1xuXHRcdFx0XHRcdH0gKS5wcm9taXNlKCk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gR2V0IGEgcHJvbWlzZSBmb3IgdGhpcyBkZWZlcnJlZFxuXHRcdFx0XHQvLyBJZiBvYmogaXMgcHJvdmlkZWQsIHRoZSBwcm9taXNlIGFzcGVjdCBpcyBhZGRlZCB0byB0aGUgb2JqZWN0XG5cdFx0XHRcdHByb21pc2U6IGZ1bmN0aW9uKCBvYmogKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG9iaiAhPSBudWxsID8galF1ZXJ5LmV4dGVuZCggb2JqLCBwcm9taXNlICkgOiBwcm9taXNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXHRcdFx0ZGVmZXJyZWQgPSB7fTtcblxuXHRcdC8vIEtlZXAgcGlwZSBmb3IgYmFjay1jb21wYXRcblx0XHRwcm9taXNlLnBpcGUgPSBwcm9taXNlLnRoZW47XG5cblx0XHQvLyBBZGQgbGlzdC1zcGVjaWZpYyBtZXRob2RzXG5cdFx0alF1ZXJ5LmVhY2goIHR1cGxlcywgZnVuY3Rpb24oIGksIHR1cGxlICkge1xuXHRcdFx0dmFyIGxpc3QgPSB0dXBsZVsgMiBdLFxuXHRcdFx0XHRzdGF0ZVN0cmluZyA9IHR1cGxlWyAzIF07XG5cblx0XHRcdC8vIHByb21pc2VbIGRvbmUgfCBmYWlsIHwgcHJvZ3Jlc3MgXSA9IGxpc3QuYWRkXG5cdFx0XHRwcm9taXNlWyB0dXBsZVsgMSBdIF0gPSBsaXN0LmFkZDtcblxuXHRcdFx0Ly8gSGFuZGxlIHN0YXRlXG5cdFx0XHRpZiAoIHN0YXRlU3RyaW5nICkge1xuXHRcdFx0XHRsaXN0LmFkZCggZnVuY3Rpb24oKSB7XG5cblx0XHRcdFx0XHQvLyBzdGF0ZSA9IFsgcmVzb2x2ZWQgfCByZWplY3RlZCBdXG5cdFx0XHRcdFx0c3RhdGUgPSBzdGF0ZVN0cmluZztcblxuXHRcdFx0XHQvLyBbIHJlamVjdF9saXN0IHwgcmVzb2x2ZV9saXN0IF0uZGlzYWJsZTsgcHJvZ3Jlc3NfbGlzdC5sb2NrXG5cdFx0XHRcdH0sIHR1cGxlc1sgaSBeIDEgXVsgMiBdLmRpc2FibGUsIHR1cGxlc1sgMiBdWyAyIF0ubG9jayApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBkZWZlcnJlZFsgcmVzb2x2ZSB8IHJlamVjdCB8IG5vdGlmeSBdXG5cdFx0XHRkZWZlcnJlZFsgdHVwbGVbIDAgXSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSggdGhpcyA9PT0gZGVmZXJyZWQgPyBwcm9taXNlIDogdGhpcywgYXJndW1lbnRzICk7XG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0fTtcblx0XHRcdGRlZmVycmVkWyB0dXBsZVsgMCBdICsgXCJXaXRoXCIgXSA9IGxpc3QuZmlyZVdpdGg7XG5cdFx0fSApO1xuXG5cdFx0Ly8gTWFrZSB0aGUgZGVmZXJyZWQgYSBwcm9taXNlXG5cdFx0cHJvbWlzZS5wcm9taXNlKCBkZWZlcnJlZCApO1xuXG5cdFx0Ly8gQ2FsbCBnaXZlbiBmdW5jIGlmIGFueVxuXHRcdGlmICggZnVuYyApIHtcblx0XHRcdGZ1bmMuY2FsbCggZGVmZXJyZWQsIGRlZmVycmVkICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGRvbmUhXG5cdFx0cmV0dXJuIGRlZmVycmVkO1xuXHR9LFxuXG5cdC8vIERlZmVycmVkIGhlbHBlclxuXHR3aGVuOiBmdW5jdGlvbiggc3Vib3JkaW5hdGUgLyogLCAuLi4sIHN1Ym9yZGluYXRlTiAqLyApIHtcblx0XHR2YXIgaSA9IDAsXG5cdFx0XHRyZXNvbHZlVmFsdWVzID0gc2xpY2UuY2FsbCggYXJndW1lbnRzICksXG5cdFx0XHRsZW5ndGggPSByZXNvbHZlVmFsdWVzLmxlbmd0aCxcblxuXHRcdFx0Ly8gdGhlIGNvdW50IG9mIHVuY29tcGxldGVkIHN1Ym9yZGluYXRlc1xuXHRcdFx0cmVtYWluaW5nID0gbGVuZ3RoICE9PSAxIHx8XG5cdFx0XHRcdCggc3Vib3JkaW5hdGUgJiYgalF1ZXJ5LmlzRnVuY3Rpb24oIHN1Ym9yZGluYXRlLnByb21pc2UgKSApID8gbGVuZ3RoIDogMCxcblxuXHRcdFx0Ly8gdGhlIG1hc3RlciBEZWZlcnJlZC5cblx0XHRcdC8vIElmIHJlc29sdmVWYWx1ZXMgY29uc2lzdCBvZiBvbmx5IGEgc2luZ2xlIERlZmVycmVkLCBqdXN0IHVzZSB0aGF0LlxuXHRcdFx0ZGVmZXJyZWQgPSByZW1haW5pbmcgPT09IDEgPyBzdWJvcmRpbmF0ZSA6IGpRdWVyeS5EZWZlcnJlZCgpLFxuXG5cdFx0XHQvLyBVcGRhdGUgZnVuY3Rpb24gZm9yIGJvdGggcmVzb2x2ZSBhbmQgcHJvZ3Jlc3MgdmFsdWVzXG5cdFx0XHR1cGRhdGVGdW5jID0gZnVuY3Rpb24oIGksIGNvbnRleHRzLCB2YWx1ZXMgKSB7XG5cdFx0XHRcdHJldHVybiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHRcdFx0Y29udGV4dHNbIGkgXSA9IHRoaXM7XG5cdFx0XHRcdFx0dmFsdWVzWyBpIF0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApIDogdmFsdWU7XG5cdFx0XHRcdFx0aWYgKCB2YWx1ZXMgPT09IHByb2dyZXNzVmFsdWVzICkge1xuXHRcdFx0XHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH0gZWxzZSBpZiAoICEoIC0tcmVtYWluaW5nICkgKSB7XG5cdFx0XHRcdFx0XHRkZWZlcnJlZC5yZXNvbHZlV2l0aCggY29udGV4dHMsIHZhbHVlcyApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH0sXG5cblx0XHRcdHByb2dyZXNzVmFsdWVzLCBwcm9ncmVzc0NvbnRleHRzLCByZXNvbHZlQ29udGV4dHM7XG5cblx0XHQvLyBBZGQgbGlzdGVuZXJzIHRvIERlZmVycmVkIHN1Ym9yZGluYXRlczsgdHJlYXQgb3RoZXJzIGFzIHJlc29sdmVkXG5cdFx0aWYgKCBsZW5ndGggPiAxICkge1xuXHRcdFx0cHJvZ3Jlc3NWYWx1ZXMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0cHJvZ3Jlc3NDb250ZXh0cyA9IG5ldyBBcnJheSggbGVuZ3RoICk7XG5cdFx0XHRyZXNvbHZlQ29udGV4dHMgPSBuZXcgQXJyYXkoIGxlbmd0aCApO1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuZ3RoOyBpKysgKSB7XG5cdFx0XHRcdGlmICggcmVzb2x2ZVZhbHVlc1sgaSBdICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCByZXNvbHZlVmFsdWVzWyBpIF0ucHJvbWlzZSApICkge1xuXHRcdFx0XHRcdHJlc29sdmVWYWx1ZXNbIGkgXS5wcm9taXNlKClcblx0XHRcdFx0XHRcdC5wcm9ncmVzcyggdXBkYXRlRnVuYyggaSwgcHJvZ3Jlc3NDb250ZXh0cywgcHJvZ3Jlc3NWYWx1ZXMgKSApXG5cdFx0XHRcdFx0XHQuZG9uZSggdXBkYXRlRnVuYyggaSwgcmVzb2x2ZUNvbnRleHRzLCByZXNvbHZlVmFsdWVzICkgKVxuXHRcdFx0XHRcdFx0LmZhaWwoIGRlZmVycmVkLnJlamVjdCApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdC0tcmVtYWluaW5nO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gSWYgd2UncmUgbm90IHdhaXRpbmcgb24gYW55dGhpbmcsIHJlc29sdmUgdGhlIG1hc3RlclxuXHRcdGlmICggIXJlbWFpbmluZyApIHtcblx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCByZXNvbHZlQ29udGV4dHMsIHJlc29sdmVWYWx1ZXMgKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gZGVmZXJyZWQucHJvbWlzZSgpO1xuXHR9XG59ICk7XG5cblxuLy8gVGhlIGRlZmVycmVkIHVzZWQgb24gRE9NIHJlYWR5XG52YXIgcmVhZHlMaXN0O1xuXG5qUXVlcnkuZm4ucmVhZHkgPSBmdW5jdGlvbiggZm4gKSB7XG5cblx0Ly8gQWRkIHRoZSBjYWxsYmFja1xuXHRqUXVlcnkucmVhZHkucHJvbWlzZSgpLmRvbmUoIGZuICk7XG5cblx0cmV0dXJuIHRoaXM7XG59O1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gSXMgdGhlIERPTSByZWFkeSB0byBiZSB1c2VkPyBTZXQgdG8gdHJ1ZSBvbmNlIGl0IG9jY3Vycy5cblx0aXNSZWFkeTogZmFsc2UsXG5cblx0Ly8gQSBjb3VudGVyIHRvIHRyYWNrIGhvdyBtYW55IGl0ZW1zIHRvIHdhaXQgZm9yIGJlZm9yZVxuXHQvLyB0aGUgcmVhZHkgZXZlbnQgZmlyZXMuIFNlZSAjNjc4MVxuXHRyZWFkeVdhaXQ6IDEsXG5cblx0Ly8gSG9sZCAob3IgcmVsZWFzZSkgdGhlIHJlYWR5IGV2ZW50XG5cdGhvbGRSZWFkeTogZnVuY3Rpb24oIGhvbGQgKSB7XG5cdFx0aWYgKCBob2xkICkge1xuXHRcdFx0alF1ZXJ5LnJlYWR5V2FpdCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRqUXVlcnkucmVhZHkoIHRydWUgKTtcblx0XHR9XG5cdH0sXG5cblx0Ly8gSGFuZGxlIHdoZW4gdGhlIERPTSBpcyByZWFkeVxuXHRyZWFkeTogZnVuY3Rpb24oIHdhaXQgKSB7XG5cblx0XHQvLyBBYm9ydCBpZiB0aGVyZSBhcmUgcGVuZGluZyBob2xkcyBvciB3ZSdyZSBhbHJlYWR5IHJlYWR5XG5cdFx0aWYgKCB3YWl0ID09PSB0cnVlID8gLS1qUXVlcnkucmVhZHlXYWl0IDogalF1ZXJ5LmlzUmVhZHkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gUmVtZW1iZXIgdGhhdCB0aGUgRE9NIGlzIHJlYWR5XG5cdFx0alF1ZXJ5LmlzUmVhZHkgPSB0cnVlO1xuXG5cdFx0Ly8gSWYgYSBub3JtYWwgRE9NIFJlYWR5IGV2ZW50IGZpcmVkLCBkZWNyZW1lbnQsIGFuZCB3YWl0IGlmIG5lZWQgYmVcblx0XHRpZiAoIHdhaXQgIT09IHRydWUgJiYgLS1qUXVlcnkucmVhZHlXYWl0ID4gMCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBJZiB0aGVyZSBhcmUgZnVuY3Rpb25zIGJvdW5kLCB0byBleGVjdXRlXG5cdFx0cmVhZHlMaXN0LnJlc29sdmVXaXRoKCBkb2N1bWVudCwgWyBqUXVlcnkgXSApO1xuXG5cdFx0Ly8gVHJpZ2dlciBhbnkgYm91bmQgcmVhZHkgZXZlbnRzXG5cdFx0aWYgKCBqUXVlcnkuZm4udHJpZ2dlckhhbmRsZXIgKSB7XG5cdFx0XHRqUXVlcnkoIGRvY3VtZW50ICkudHJpZ2dlckhhbmRsZXIoIFwicmVhZHlcIiApO1xuXHRcdFx0alF1ZXJ5KCBkb2N1bWVudCApLm9mZiggXCJyZWFkeVwiICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cbi8qKlxuICogVGhlIHJlYWR5IGV2ZW50IGhhbmRsZXIgYW5kIHNlbGYgY2xlYW51cCBtZXRob2RcbiAqL1xuZnVuY3Rpb24gY29tcGxldGVkKCkge1xuXHRkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cdHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKCBcImxvYWRcIiwgY29tcGxldGVkICk7XG5cdGpRdWVyeS5yZWFkeSgpO1xufVxuXG5qUXVlcnkucmVhZHkucHJvbWlzZSA9IGZ1bmN0aW9uKCBvYmogKSB7XG5cdGlmICggIXJlYWR5TGlzdCApIHtcblxuXHRcdHJlYWR5TGlzdCA9IGpRdWVyeS5EZWZlcnJlZCgpO1xuXG5cdFx0Ly8gQ2F0Y2ggY2FzZXMgd2hlcmUgJChkb2N1bWVudCkucmVhZHkoKSBpcyBjYWxsZWRcblx0XHQvLyBhZnRlciB0aGUgYnJvd3NlciBldmVudCBoYXMgYWxyZWFkeSBvY2N1cnJlZC5cblx0XHQvLyBTdXBwb3J0OiBJRTktMTAgb25seVxuXHRcdC8vIE9sZGVyIElFIHNvbWV0aW1lcyBzaWduYWxzIFwiaW50ZXJhY3RpdmVcIiB0b28gc29vblxuXHRcdGlmICggZG9jdW1lbnQucmVhZHlTdGF0ZSA9PT0gXCJjb21wbGV0ZVwiIHx8XG5cdFx0XHQoIGRvY3VtZW50LnJlYWR5U3RhdGUgIT09IFwibG9hZGluZ1wiICYmICFkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZG9TY3JvbGwgKSApIHtcblxuXHRcdFx0Ly8gSGFuZGxlIGl0IGFzeW5jaHJvbm91c2x5IHRvIGFsbG93IHNjcmlwdHMgdGhlIG9wcG9ydHVuaXR5IHRvIGRlbGF5IHJlYWR5XG5cdFx0XHR3aW5kb3cuc2V0VGltZW91dCggalF1ZXJ5LnJlYWR5ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGhhbmR5IGV2ZW50IGNhbGxiYWNrXG5cdFx0XHRkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCBcIkRPTUNvbnRlbnRMb2FkZWRcIiwgY29tcGxldGVkICk7XG5cblx0XHRcdC8vIEEgZmFsbGJhY2sgdG8gd2luZG93Lm9ubG9hZCwgdGhhdCB3aWxsIGFsd2F5cyB3b3JrXG5cdFx0XHR3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lciggXCJsb2FkXCIsIGNvbXBsZXRlZCApO1xuXHRcdH1cblx0fVxuXHRyZXR1cm4gcmVhZHlMaXN0LnByb21pc2UoIG9iaiApO1xufTtcblxuLy8gS2ljayBvZmYgdGhlIERPTSByZWFkeSBjaGVjayBldmVuIGlmIHRoZSB1c2VyIGRvZXMgbm90XG5qUXVlcnkucmVhZHkucHJvbWlzZSgpO1xuXG5cblxuXG4vLyBNdWx0aWZ1bmN0aW9uYWwgbWV0aG9kIHRvIGdldCBhbmQgc2V0IHZhbHVlcyBvZiBhIGNvbGxlY3Rpb25cbi8vIFRoZSB2YWx1ZS9zIGNhbiBvcHRpb25hbGx5IGJlIGV4ZWN1dGVkIGlmIGl0J3MgYSBmdW5jdGlvblxudmFyIGFjY2VzcyA9IGZ1bmN0aW9uKCBlbGVtcywgZm4sIGtleSwgdmFsdWUsIGNoYWluYWJsZSwgZW1wdHlHZXQsIHJhdyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGxlbiA9IGVsZW1zLmxlbmd0aCxcblx0XHRidWxrID0ga2V5ID09IG51bGw7XG5cblx0Ly8gU2V0cyBtYW55IHZhbHVlc1xuXHRpZiAoIGpRdWVyeS50eXBlKCBrZXkgKSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRjaGFpbmFibGUgPSB0cnVlO1xuXHRcdGZvciAoIGkgaW4ga2V5ICkge1xuXHRcdFx0YWNjZXNzKCBlbGVtcywgZm4sIGksIGtleVsgaSBdLCB0cnVlLCBlbXB0eUdldCwgcmF3ICk7XG5cdFx0fVxuXG5cdC8vIFNldHMgb25lIHZhbHVlXG5cdH0gZWxzZSBpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0Y2hhaW5hYmxlID0gdHJ1ZTtcblxuXHRcdGlmICggIWpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmF3ID0gdHJ1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGJ1bGsgKSB7XG5cblx0XHRcdC8vIEJ1bGsgb3BlcmF0aW9ucyBydW4gYWdhaW5zdCB0aGUgZW50aXJlIHNldFxuXHRcdFx0aWYgKCByYXcgKSB7XG5cdFx0XHRcdGZuLmNhbGwoIGVsZW1zLCB2YWx1ZSApO1xuXHRcdFx0XHRmbiA9IG51bGw7XG5cblx0XHRcdC8vIC4uLmV4Y2VwdCB3aGVuIGV4ZWN1dGluZyBmdW5jdGlvbiB2YWx1ZXNcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGJ1bGsgPSBmbjtcblx0XHRcdFx0Zm4gPSBmdW5jdGlvbiggZWxlbSwga2V5LCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gYnVsay5jYWxsKCBqUXVlcnkoIGVsZW0gKSwgdmFsdWUgKTtcblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoIGZuICkge1xuXHRcdFx0Zm9yICggOyBpIDwgbGVuOyBpKysgKSB7XG5cdFx0XHRcdGZuKFxuXHRcdFx0XHRcdGVsZW1zWyBpIF0sIGtleSwgcmF3ID9cblx0XHRcdFx0XHR2YWx1ZSA6XG5cdFx0XHRcdFx0dmFsdWUuY2FsbCggZWxlbXNbIGkgXSwgaSwgZm4oIGVsZW1zWyBpIF0sIGtleSApIClcblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gY2hhaW5hYmxlID9cblx0XHRlbGVtcyA6XG5cblx0XHQvLyBHZXRzXG5cdFx0YnVsayA/XG5cdFx0XHRmbi5jYWxsKCBlbGVtcyApIDpcblx0XHRcdGxlbiA/IGZuKCBlbGVtc1sgMCBdLCBrZXkgKSA6IGVtcHR5R2V0O1xufTtcbnZhciBhY2NlcHREYXRhID0gZnVuY3Rpb24oIG93bmVyICkge1xuXG5cdC8vIEFjY2VwdHMgb25seTpcblx0Ly8gIC0gTm9kZVxuXHQvLyAgICAtIE5vZGUuRUxFTUVOVF9OT0RFXG5cdC8vICAgIC0gTm9kZS5ET0NVTUVOVF9OT0RFXG5cdC8vICAtIE9iamVjdFxuXHQvLyAgICAtIEFueVxuXHQvKiBqc2hpbnQgLVcwMTggKi9cblx0cmV0dXJuIG93bmVyLm5vZGVUeXBlID09PSAxIHx8IG93bmVyLm5vZGVUeXBlID09PSA5IHx8ICEoICtvd25lci5ub2RlVHlwZSApO1xufTtcblxuXG5cblxuZnVuY3Rpb24gRGF0YSgpIHtcblx0dGhpcy5leHBhbmRvID0galF1ZXJ5LmV4cGFuZG8gKyBEYXRhLnVpZCsrO1xufVxuXG5EYXRhLnVpZCA9IDE7XG5cbkRhdGEucHJvdG90eXBlID0ge1xuXG5cdHJlZ2lzdGVyOiBmdW5jdGlvbiggb3duZXIsIGluaXRpYWwgKSB7XG5cdFx0dmFyIHZhbHVlID0gaW5pdGlhbCB8fCB7fTtcblxuXHRcdC8vIElmIGl0IGlzIGEgbm9kZSB1bmxpa2VseSB0byBiZSBzdHJpbmdpZnktZWQgb3IgbG9vcGVkIG92ZXJcblx0XHQvLyB1c2UgcGxhaW4gYXNzaWdubWVudFxuXHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB2YWx1ZTtcblxuXHRcdC8vIE90aGVyd2lzZSBzZWN1cmUgaXQgaW4gYSBub24tZW51bWVyYWJsZSwgbm9uLXdyaXRhYmxlIHByb3BlcnR5XG5cdFx0Ly8gY29uZmlndXJhYmlsaXR5IG11c3QgYmUgdHJ1ZSB0byBhbGxvdyB0aGUgcHJvcGVydHkgdG8gYmVcblx0XHQvLyBkZWxldGVkIHdpdGggdGhlIGRlbGV0ZSBvcGVyYXRvclxuXHRcdH0gZWxzZSB7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0dmFsdWU6IHZhbHVlLFxuXHRcdFx0XHR3cml0YWJsZTogdHJ1ZSxcblx0XHRcdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdFx0XHR9ICk7XG5cdFx0fVxuXHRcdHJldHVybiBvd25lclsgdGhpcy5leHBhbmRvIF07XG5cdH0sXG5cdGNhY2hlOiBmdW5jdGlvbiggb3duZXIgKSB7XG5cblx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHQvLyBidXQgd2Ugc2hvdWxkIG5vdCwgc2VlICM4MzM1LlxuXHRcdC8vIEFsd2F5cyByZXR1cm4gYW4gZW1wdHkgb2JqZWN0LlxuXHRcdGlmICggIWFjY2VwdERhdGEoIG93bmVyICkgKSB7XG5cdFx0XHRyZXR1cm4ge307XG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgaWYgdGhlIG93bmVyIG9iamVjdCBhbHJlYWR5IGhhcyBhIGNhY2hlXG5cdFx0dmFyIHZhbHVlID0gb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXG5cdFx0Ly8gSWYgbm90LCBjcmVhdGUgb25lXG5cdFx0aWYgKCAhdmFsdWUgKSB7XG5cdFx0XHR2YWx1ZSA9IHt9O1xuXG5cdFx0XHQvLyBXZSBjYW4gYWNjZXB0IGRhdGEgZm9yIG5vbi1lbGVtZW50IG5vZGVzIGluIG1vZGVybiBicm93c2Vycyxcblx0XHRcdC8vIGJ1dCB3ZSBzaG91bGQgbm90LCBzZWUgIzgzMzUuXG5cdFx0XHQvLyBBbHdheXMgcmV0dXJuIGFuIGVtcHR5IG9iamVjdC5cblx0XHRcdGlmICggYWNjZXB0RGF0YSggb3duZXIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBpdCBpcyBhIG5vZGUgdW5saWtlbHkgdG8gYmUgc3RyaW5naWZ5LWVkIG9yIGxvb3BlZCBvdmVyXG5cdFx0XHRcdC8vIHVzZSBwbGFpbiBhc3NpZ25tZW50XG5cdFx0XHRcdGlmICggb3duZXIubm9kZVR5cGUgKSB7XG5cdFx0XHRcdFx0b3duZXJbIHRoaXMuZXhwYW5kbyBdID0gdmFsdWU7XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHNlY3VyZSBpdCBpbiBhIG5vbi1lbnVtZXJhYmxlIHByb3BlcnR5XG5cdFx0XHRcdC8vIGNvbmZpZ3VyYWJsZSBtdXN0IGJlIHRydWUgdG8gYWxsb3cgdGhlIHByb3BlcnR5IHRvIGJlXG5cdFx0XHRcdC8vIGRlbGV0ZWQgd2hlbiBkYXRhIGlzIHJlbW92ZWRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoIG93bmVyLCB0aGlzLmV4cGFuZG8sIHtcblx0XHRcdFx0XHRcdHZhbHVlOiB2YWx1ZSxcblx0XHRcdFx0XHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHRcdFx0XHRcdH0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB2YWx1ZTtcblx0fSxcblx0c2V0OiBmdW5jdGlvbiggb3duZXIsIGRhdGEsIHZhbHVlICkge1xuXHRcdHZhciBwcm9wLFxuXHRcdFx0Y2FjaGUgPSB0aGlzLmNhY2hlKCBvd25lciApO1xuXG5cdFx0Ly8gSGFuZGxlOiBbIG93bmVyLCBrZXksIHZhbHVlIF0gYXJnc1xuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRjYWNoZVsgZGF0YSBdID0gdmFsdWU7XG5cblx0XHQvLyBIYW5kbGU6IFsgb3duZXIsIHsgcHJvcGVydGllcyB9IF0gYXJnc1xuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIENvcHkgdGhlIHByb3BlcnRpZXMgb25lLWJ5LW9uZSB0byB0aGUgY2FjaGUgb2JqZWN0XG5cdFx0XHRmb3IgKCBwcm9wIGluIGRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlWyBwcm9wIF0gPSBkYXRhWyBwcm9wIF07XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjYWNoZTtcblx0fSxcblx0Z2V0OiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHRyZXR1cm4ga2V5ID09PSB1bmRlZmluZWQgP1xuXHRcdFx0dGhpcy5jYWNoZSggb3duZXIgKSA6XG5cdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gJiYgb3duZXJbIHRoaXMuZXhwYW5kbyBdWyBrZXkgXTtcblx0fSxcblx0YWNjZXNzOiBmdW5jdGlvbiggb3duZXIsIGtleSwgdmFsdWUgKSB7XG5cdFx0dmFyIHN0b3JlZDtcblxuXHRcdC8vIEluIGNhc2VzIHdoZXJlIGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gTm8ga2V5IHdhcyBzcGVjaWZpZWRcblx0XHQvLyAgIDIuIEEgc3RyaW5nIGtleSB3YXMgc3BlY2lmaWVkLCBidXQgbm8gdmFsdWUgcHJvdmlkZWRcblx0XHQvL1xuXHRcdC8vIFRha2UgdGhlIFwicmVhZFwiIHBhdGggYW5kIGFsbG93IHRoZSBnZXQgbWV0aG9kIHRvIGRldGVybWluZVxuXHRcdC8vIHdoaWNoIHZhbHVlIHRvIHJldHVybiwgcmVzcGVjdGl2ZWx5IGVpdGhlcjpcblx0XHQvL1xuXHRcdC8vICAgMS4gVGhlIGVudGlyZSBjYWNoZSBvYmplY3Rcblx0XHQvLyAgIDIuIFRoZSBkYXRhIHN0b3JlZCBhdCB0aGUga2V5XG5cdFx0Ly9cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkIHx8XG5cdFx0XHRcdCggKCBrZXkgJiYgdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiApICYmIHZhbHVlID09PSB1bmRlZmluZWQgKSApIHtcblxuXHRcdFx0c3RvcmVkID0gdGhpcy5nZXQoIG93bmVyLCBrZXkgKTtcblxuXHRcdFx0cmV0dXJuIHN0b3JlZCAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0c3RvcmVkIDogdGhpcy5nZXQoIG93bmVyLCBqUXVlcnkuY2FtZWxDYXNlKCBrZXkgKSApO1xuXHRcdH1cblxuXHRcdC8vIFdoZW4gdGhlIGtleSBpcyBub3QgYSBzdHJpbmcsIG9yIGJvdGggYSBrZXkgYW5kIHZhbHVlXG5cdFx0Ly8gYXJlIHNwZWNpZmllZCwgc2V0IG9yIGV4dGVuZCAoZXhpc3Rpbmcgb2JqZWN0cykgd2l0aCBlaXRoZXI6XG5cdFx0Ly9cblx0XHQvLyAgIDEuIEFuIG9iamVjdCBvZiBwcm9wZXJ0aWVzXG5cdFx0Ly8gICAyLiBBIGtleSBhbmQgdmFsdWVcblx0XHQvL1xuXHRcdHRoaXMuc2V0KCBvd25lciwga2V5LCB2YWx1ZSApO1xuXG5cdFx0Ly8gU2luY2UgdGhlIFwic2V0XCIgcGF0aCBjYW4gaGF2ZSB0d28gcG9zc2libGUgZW50cnkgcG9pbnRzXG5cdFx0Ly8gcmV0dXJuIHRoZSBleHBlY3RlZCBkYXRhIGJhc2VkIG9uIHdoaWNoIHBhdGggd2FzIHRha2VuWypdXG5cdFx0cmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IGtleTtcblx0fSxcblx0cmVtb3ZlOiBmdW5jdGlvbiggb3duZXIsIGtleSApIHtcblx0XHR2YXIgaSwgbmFtZSwgY2FtZWwsXG5cdFx0XHRjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblxuXHRcdGlmICggY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dGhpcy5yZWdpc3Rlciggb3duZXIgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIFN1cHBvcnQgYXJyYXkgb3Igc3BhY2Ugc2VwYXJhdGVkIHN0cmluZyBvZiBrZXlzXG5cdFx0XHRpZiAoIGpRdWVyeS5pc0FycmF5KCBrZXkgKSApIHtcblxuXHRcdFx0XHQvLyBJZiBcIm5hbWVcIiBpcyBhbiBhcnJheSBvZiBrZXlzLi4uXG5cdFx0XHRcdC8vIFdoZW4gZGF0YSBpcyBpbml0aWFsbHkgY3JlYXRlZCwgdmlhIChcImtleVwiLCBcInZhbFwiKSBzaWduYXR1cmUsXG5cdFx0XHRcdC8vIGtleXMgd2lsbCBiZSBjb252ZXJ0ZWQgdG8gY2FtZWxDYXNlLlxuXHRcdFx0XHQvLyBTaW5jZSB0aGVyZSBpcyBubyB3YXkgdG8gdGVsbCBfaG93XyBhIGtleSB3YXMgYWRkZWQsIHJlbW92ZVxuXHRcdFx0XHQvLyBib3RoIHBsYWluIGtleSBhbmQgY2FtZWxDYXNlIGtleS4gIzEyNzg2XG5cdFx0XHRcdC8vIFRoaXMgd2lsbCBvbmx5IHBlbmFsaXplIHRoZSBhcnJheSBhcmd1bWVudCBwYXRoLlxuXHRcdFx0XHRuYW1lID0ga2V5LmNvbmNhdCgga2V5Lm1hcCggalF1ZXJ5LmNhbWVsQ2FzZSApICk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjYW1lbCA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXG5cdFx0XHRcdC8vIFRyeSB0aGUgc3RyaW5nIGFzIGEga2V5IGJlZm9yZSBhbnkgbWFuaXB1bGF0aW9uXG5cdFx0XHRcdGlmICgga2V5IGluIGNhY2hlICkge1xuXHRcdFx0XHRcdG5hbWUgPSBbIGtleSwgY2FtZWwgXTtcblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdC8vIElmIGEga2V5IHdpdGggdGhlIHNwYWNlcyBleGlzdHMsIHVzZSBpdC5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UsIGNyZWF0ZSBhbiBhcnJheSBieSBtYXRjaGluZyBub24td2hpdGVzcGFjZVxuXHRcdFx0XHRcdG5hbWUgPSBjYW1lbDtcblx0XHRcdFx0XHRuYW1lID0gbmFtZSBpbiBjYWNoZSA/XG5cdFx0XHRcdFx0XHRbIG5hbWUgXSA6ICggbmFtZS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW10gKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRpID0gbmFtZS5sZW5ndGg7XG5cblx0XHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0XHRkZWxldGUgY2FjaGVbIG5hbWVbIGkgXSBdO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFJlbW92ZSB0aGUgZXhwYW5kbyBpZiB0aGVyZSdzIG5vIG1vcmUgZGF0YVxuXHRcdGlmICgga2V5ID09PSB1bmRlZmluZWQgfHwgalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICkgKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IENocm9tZSA8PSAzNS00NStcblx0XHRcdC8vIFdlYmtpdCAmIEJsaW5rIHBlcmZvcm1hbmNlIHN1ZmZlcnMgd2hlbiBkZWxldGluZyBwcm9wZXJ0aWVzXG5cdFx0XHQvLyBmcm9tIERPTSBub2Rlcywgc28gc2V0IHRvIHVuZGVmaW5lZCBpbnN0ZWFkXG5cdFx0XHQvLyBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9Mzc4NjA3XG5cdFx0XHRpZiAoIG93bmVyLm5vZGVUeXBlICkge1xuXHRcdFx0XHRvd25lclsgdGhpcy5leHBhbmRvIF0gPSB1bmRlZmluZWQ7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRkZWxldGUgb3duZXJbIHRoaXMuZXhwYW5kbyBdO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblx0aGFzRGF0YTogZnVuY3Rpb24oIG93bmVyICkge1xuXHRcdHZhciBjYWNoZSA9IG93bmVyWyB0aGlzLmV4cGFuZG8gXTtcblx0XHRyZXR1cm4gY2FjaGUgIT09IHVuZGVmaW5lZCAmJiAhalF1ZXJ5LmlzRW1wdHlPYmplY3QoIGNhY2hlICk7XG5cdH1cbn07XG52YXIgZGF0YVByaXYgPSBuZXcgRGF0YSgpO1xuXG52YXIgZGF0YVVzZXIgPSBuZXcgRGF0YSgpO1xuXG5cblxuLy9cdEltcGxlbWVudGF0aW9uIFN1bW1hcnlcbi8vXG4vL1x0MS4gRW5mb3JjZSBBUEkgc3VyZmFjZSBhbmQgc2VtYW50aWMgY29tcGF0aWJpbGl0eSB3aXRoIDEuOS54IGJyYW5jaFxuLy9cdDIuIEltcHJvdmUgdGhlIG1vZHVsZSdzIG1haW50YWluYWJpbGl0eSBieSByZWR1Y2luZyB0aGUgc3RvcmFnZVxuLy9cdFx0cGF0aHMgdG8gYSBzaW5nbGUgbWVjaGFuaXNtLlxuLy9cdDMuIFVzZSB0aGUgc2FtZSBzaW5nbGUgbWVjaGFuaXNtIHRvIHN1cHBvcnQgXCJwcml2YXRlXCIgYW5kIFwidXNlclwiIGRhdGEuXG4vL1x0NC4gX05ldmVyXyBleHBvc2UgXCJwcml2YXRlXCIgZGF0YSB0byB1c2VyIGNvZGUgKFRPRE86IERyb3AgX2RhdGEsIF9yZW1vdmVEYXRhKVxuLy9cdDUuIEF2b2lkIGV4cG9zaW5nIGltcGxlbWVudGF0aW9uIGRldGFpbHMgb24gdXNlciBvYmplY3RzIChlZy4gZXhwYW5kbyBwcm9wZXJ0aWVzKVxuLy9cdDYuIFByb3ZpZGUgYSBjbGVhciBwYXRoIGZvciBpbXBsZW1lbnRhdGlvbiB1cGdyYWRlIHRvIFdlYWtNYXAgaW4gMjAxNFxuXG52YXIgcmJyYWNlID0gL14oPzpcXHtbXFx3XFxXXSpcXH18XFxbW1xcd1xcV10qXFxdKSQvLFxuXHRybXVsdGlEYXNoID0gL1tBLVpdL2c7XG5cbmZ1bmN0aW9uIGRhdGFBdHRyKCBlbGVtLCBrZXksIGRhdGEgKSB7XG5cdHZhciBuYW1lO1xuXG5cdC8vIElmIG5vdGhpbmcgd2FzIGZvdW5kIGludGVybmFsbHksIHRyeSB0byBmZXRjaCBhbnlcblx0Ly8gZGF0YSBmcm9tIHRoZSBIVE1MNSBkYXRhLSogYXR0cmlidXRlXG5cdGlmICggZGF0YSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0bmFtZSA9IFwiZGF0YS1cIiArIGtleS5yZXBsYWNlKCBybXVsdGlEYXNoLCBcIi0kJlwiICkudG9Mb3dlckNhc2UoKTtcblx0XHRkYXRhID0gZWxlbS5nZXRBdHRyaWJ1dGUoIG5hbWUgKTtcblxuXHRcdGlmICggdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHR0cnkge1xuXHRcdFx0XHRkYXRhID0gZGF0YSA9PT0gXCJ0cnVlXCIgPyB0cnVlIDpcblx0XHRcdFx0XHRkYXRhID09PSBcImZhbHNlXCIgPyBmYWxzZSA6XG5cdFx0XHRcdFx0ZGF0YSA9PT0gXCJudWxsXCIgPyBudWxsIDpcblxuXHRcdFx0XHRcdC8vIE9ubHkgY29udmVydCB0byBhIG51bWJlciBpZiBpdCBkb2Vzbid0IGNoYW5nZSB0aGUgc3RyaW5nXG5cdFx0XHRcdFx0K2RhdGEgKyBcIlwiID09PSBkYXRhID8gK2RhdGEgOlxuXHRcdFx0XHRcdHJicmFjZS50ZXN0KCBkYXRhICkgPyBqUXVlcnkucGFyc2VKU09OKCBkYXRhICkgOlxuXHRcdFx0XHRcdGRhdGE7XG5cdFx0XHR9IGNhdGNoICggZSApIHt9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB3ZSBzZXQgdGhlIGRhdGEgc28gaXQgaXNuJ3QgY2hhbmdlZCBsYXRlclxuXHRcdFx0ZGF0YVVzZXIuc2V0KCBlbGVtLCBrZXksIGRhdGEgKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGRhdGE7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aGFzRGF0YTogZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmhhc0RhdGEoIGVsZW0gKSB8fCBkYXRhUHJpdi5oYXNEYXRhKCBlbGVtICk7XG5cdH0sXG5cblx0ZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFVc2VyLmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lICkge1xuXHRcdGRhdGFVc2VyLnJlbW92ZSggZWxlbSwgbmFtZSApO1xuXHR9LFxuXG5cdC8vIFRPRE86IE5vdyB0aGF0IGFsbCBjYWxscyB0byBfZGF0YSBhbmQgX3JlbW92ZURhdGEgaGF2ZSBiZWVuIHJlcGxhY2VkXG5cdC8vIHdpdGggZGlyZWN0IGNhbGxzIHRvIGRhdGFQcml2IG1ldGhvZHMsIHRoZXNlIGNhbiBiZSBkZXByZWNhdGVkLlxuXHRfZGF0YTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIGRhdGEgKSB7XG5cdFx0cmV0dXJuIGRhdGFQcml2LmFjY2VzcyggZWxlbSwgbmFtZSwgZGF0YSApO1xuXHR9LFxuXG5cdF9yZW1vdmVEYXRhOiBmdW5jdGlvbiggZWxlbSwgbmFtZSApIHtcblx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIG5hbWUgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGRhdGE6IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXHRcdHZhciBpLCBuYW1lLCBkYXRhLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXSxcblx0XHRcdGF0dHJzID0gZWxlbSAmJiBlbGVtLmF0dHJpYnV0ZXM7XG5cblx0XHQvLyBHZXRzIGFsbCB2YWx1ZXNcblx0XHRpZiAoIGtleSA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0aWYgKCB0aGlzLmxlbmd0aCApIHtcblx0XHRcdFx0ZGF0YSA9IGRhdGFVc2VyLmdldCggZWxlbSApO1xuXG5cdFx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAhZGF0YVByaXYuZ2V0KCBlbGVtLCBcImhhc0RhdGFBdHRyc1wiICkgKSB7XG5cdFx0XHRcdFx0aSA9IGF0dHJzLmxlbmd0aDtcblx0XHRcdFx0XHR3aGlsZSAoIGktLSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUUxMStcblx0XHRcdFx0XHRcdC8vIFRoZSBhdHRycyBlbGVtZW50cyBjYW4gYmUgbnVsbCAoIzE0ODk0KVxuXHRcdFx0XHRcdFx0aWYgKCBhdHRyc1sgaSBdICkge1xuXHRcdFx0XHRcdFx0XHRuYW1lID0gYXR0cnNbIGkgXS5uYW1lO1xuXHRcdFx0XHRcdFx0XHRpZiAoIG5hbWUuaW5kZXhPZiggXCJkYXRhLVwiICkgPT09IDAgKSB7XG5cdFx0XHRcdFx0XHRcdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUuc2xpY2UoIDUgKSApO1xuXHRcdFx0XHRcdFx0XHRcdGRhdGFBdHRyKCBlbGVtLCBuYW1lLCBkYXRhWyBuYW1lIF0gKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIGVsZW0sIFwiaGFzRGF0YUF0dHJzXCIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gZGF0YTtcblx0XHR9XG5cblx0XHQvLyBTZXRzIG11bHRpcGxlIHZhbHVlc1xuXHRcdGlmICggdHlwZW9mIGtleSA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSApO1xuXHRcdFx0fSApO1xuXHRcdH1cblxuXHRcdHJldHVybiBhY2Nlc3MoIHRoaXMsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdHZhciBkYXRhLCBjYW1lbEtleTtcblxuXHRcdFx0Ly8gVGhlIGNhbGxpbmcgalF1ZXJ5IG9iamVjdCAoZWxlbWVudCBtYXRjaGVzKSBpcyBub3QgZW1wdHlcblx0XHRcdC8vIChhbmQgdGhlcmVmb3JlIGhhcyBhbiBlbGVtZW50IGFwcGVhcnMgYXQgdGhpc1sgMCBdKSBhbmQgdGhlXG5cdFx0XHQvLyBgdmFsdWVgIHBhcmFtZXRlciB3YXMgbm90IHVuZGVmaW5lZC4gQW4gZW1wdHkgalF1ZXJ5IG9iamVjdFxuXHRcdFx0Ly8gd2lsbCByZXN1bHQgaW4gYHVuZGVmaW5lZGAgZm9yIGVsZW0gPSB0aGlzWyAwIF0gd2hpY2ggd2lsbFxuXHRcdFx0Ly8gdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFuIGF0dGVtcHQgdG8gcmVhZCBhIGRhdGEgY2FjaGUgaXMgbWFkZS5cblx0XHRcdGlmICggZWxlbSAmJiB2YWx1ZSA9PT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdC8vIEF0dGVtcHQgdG8gZ2V0IGRhdGEgZnJvbSB0aGUgY2FjaGVcblx0XHRcdFx0Ly8gd2l0aCB0aGUga2V5IGFzLWlzXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGtleSApIHx8XG5cblx0XHRcdFx0XHQvLyBUcnkgdG8gZmluZCBkYXNoZWQga2V5IGlmIGl0IGV4aXN0cyAoZ2gtMjc3OSlcblx0XHRcdFx0XHQvLyBUaGlzIGlzIGZvciAyLjIueCBvbmx5XG5cdFx0XHRcdFx0ZGF0YVVzZXIuZ2V0KCBlbGVtLCBrZXkucmVwbGFjZSggcm11bHRpRGFzaCwgXCItJCZcIiApLnRvTG93ZXJDYXNlKCkgKTtcblxuXHRcdFx0XHRpZiAoIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gZGF0YTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbWVsS2V5ID0galF1ZXJ5LmNhbWVsQ2FzZSgga2V5ICk7XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBnZXQgZGF0YSBmcm9tIHRoZSBjYWNoZVxuXHRcdFx0XHQvLyB3aXRoIHRoZSBrZXkgY2FtZWxpemVkXG5cdFx0XHRcdGRhdGEgPSBkYXRhVXNlci5nZXQoIGVsZW0sIGNhbWVsS2V5ICk7XG5cdFx0XHRcdGlmICggZGF0YSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRcdHJldHVybiBkYXRhO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXR0ZW1wdCB0byBcImRpc2NvdmVyXCIgdGhlIGRhdGEgaW5cblx0XHRcdFx0Ly8gSFRNTDUgY3VzdG9tIGRhdGEtKiBhdHRyc1xuXHRcdFx0XHRkYXRhID0gZGF0YUF0dHIoIGVsZW0sIGNhbWVsS2V5LCB1bmRlZmluZWQgKTtcblx0XHRcdFx0aWYgKCBkYXRhICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0cmV0dXJuIGRhdGE7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBXZSB0cmllZCByZWFsbHkgaGFyZCwgYnV0IHRoZSBkYXRhIGRvZXNuJ3QgZXhpc3QuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IHRoZSBkYXRhLi4uXG5cdFx0XHRjYW1lbEtleSA9IGpRdWVyeS5jYW1lbENhc2UoIGtleSApO1xuXHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBGaXJzdCwgYXR0ZW1wdCB0byBzdG9yZSBhIGNvcHkgb3IgcmVmZXJlbmNlIG9mIGFueVxuXHRcdFx0XHQvLyBkYXRhIHRoYXQgbWlnaHQndmUgYmVlbiBzdG9yZSB3aXRoIGEgY2FtZWxDYXNlZCBrZXkuXG5cdFx0XHRcdHZhciBkYXRhID0gZGF0YVVzZXIuZ2V0KCB0aGlzLCBjYW1lbEtleSApO1xuXG5cdFx0XHRcdC8vIEZvciBIVE1MNSBkYXRhLSogYXR0cmlidXRlIGludGVyb3AsIHdlIGhhdmUgdG9cblx0XHRcdFx0Ly8gc3RvcmUgcHJvcGVydHkgbmFtZXMgd2l0aCBkYXNoZXMgaW4gYSBjYW1lbENhc2UgZm9ybS5cblx0XHRcdFx0Ly8gVGhpcyBtaWdodCBub3QgYXBwbHkgdG8gYWxsIHByb3BlcnRpZXMuLi4qXG5cdFx0XHRcdGRhdGFVc2VyLnNldCggdGhpcywgY2FtZWxLZXksIHZhbHVlICk7XG5cblx0XHRcdFx0Ly8gKi4uLiBJbiB0aGUgY2FzZSBvZiBwcm9wZXJ0aWVzIHRoYXQgbWlnaHQgX2FjdHVhbGx5X1xuXHRcdFx0XHQvLyBoYXZlIGRhc2hlcywgd2UgbmVlZCB0byBhbHNvIHN0b3JlIGEgY29weSBvZiB0aGF0XG5cdFx0XHRcdC8vIHVuY2hhbmdlZCBwcm9wZXJ0eS5cblx0XHRcdFx0aWYgKCBrZXkuaW5kZXhPZiggXCItXCIgKSA+IC0xICYmIGRhdGEgIT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRkYXRhVXNlci5zZXQoIHRoaXMsIGtleSwgdmFsdWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSwgbnVsbCwgdHJ1ZSApO1xuXHR9LFxuXG5cdHJlbW92ZURhdGE6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkYXRhVXNlci5yZW1vdmUoIHRoaXMsIGtleSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cXVldWU6IGZ1bmN0aW9uKCBlbGVtLCB0eXBlLCBkYXRhICkge1xuXHRcdHZhciBxdWV1ZTtcblxuXHRcdGlmICggZWxlbSApIHtcblx0XHRcdHR5cGUgPSAoIHR5cGUgfHwgXCJmeFwiICkgKyBcInF1ZXVlXCI7XG5cdFx0XHRxdWV1ZSA9IGRhdGFQcml2LmdldCggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHQvLyBTcGVlZCB1cCBkZXF1ZXVlIGJ5IGdldHRpbmcgb3V0IHF1aWNrbHkgaWYgdGhpcyBpcyBqdXN0IGEgbG9va3VwXG5cdFx0XHRpZiAoIGRhdGEgKSB7XG5cdFx0XHRcdGlmICggIXF1ZXVlIHx8IGpRdWVyeS5pc0FycmF5KCBkYXRhICkgKSB7XG5cdFx0XHRcdFx0cXVldWUgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIHR5cGUsIGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEgKSApO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHF1ZXVlLnB1c2goIGRhdGEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHF1ZXVlIHx8IFtdO1xuXHRcdH1cblx0fSxcblxuXHRkZXF1ZXVlOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0XHR2YXIgcXVldWUgPSBqUXVlcnkucXVldWUoIGVsZW0sIHR5cGUgKSxcblx0XHRcdHN0YXJ0TGVuZ3RoID0gcXVldWUubGVuZ3RoLFxuXHRcdFx0Zm4gPSBxdWV1ZS5zaGlmdCgpLFxuXHRcdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIHR5cGUgKSxcblx0XHRcdG5leHQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0alF1ZXJ5LmRlcXVldWUoIGVsZW0sIHR5cGUgKTtcblx0XHRcdH07XG5cblx0XHQvLyBJZiB0aGUgZnggcXVldWUgaXMgZGVxdWV1ZWQsIGFsd2F5cyByZW1vdmUgdGhlIHByb2dyZXNzIHNlbnRpbmVsXG5cdFx0aWYgKCBmbiA9PT0gXCJpbnByb2dyZXNzXCIgKSB7XG5cdFx0XHRmbiA9IHF1ZXVlLnNoaWZ0KCk7XG5cdFx0XHRzdGFydExlbmd0aC0tO1xuXHRcdH1cblxuXHRcdGlmICggZm4gKSB7XG5cblx0XHRcdC8vIEFkZCBhIHByb2dyZXNzIHNlbnRpbmVsIHRvIHByZXZlbnQgdGhlIGZ4IHF1ZXVlIGZyb20gYmVpbmdcblx0XHRcdC8vIGF1dG9tYXRpY2FsbHkgZGVxdWV1ZWRcblx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICkge1xuXHRcdFx0XHRxdWV1ZS51bnNoaWZ0KCBcImlucHJvZ3Jlc3NcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDbGVhciB1cCB0aGUgbGFzdCBxdWV1ZSBzdG9wIGZ1bmN0aW9uXG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdGZuLmNhbGwoIGVsZW0sIG5leHQsIGhvb2tzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCAhc3RhcnRMZW5ndGggJiYgaG9va3MgKSB7XG5cdFx0XHRob29rcy5lbXB0eS5maXJlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdC8vIE5vdCBwdWJsaWMgLSBnZW5lcmF0ZSBhIHF1ZXVlSG9va3Mgb2JqZWN0LCBvciByZXR1cm4gdGhlIGN1cnJlbnQgb25lXG5cdF9xdWV1ZUhvb2tzOiBmdW5jdGlvbiggZWxlbSwgdHlwZSApIHtcblx0XHR2YXIga2V5ID0gdHlwZSArIFwicXVldWVIb29rc1wiO1xuXHRcdHJldHVybiBkYXRhUHJpdi5nZXQoIGVsZW0sIGtleSApIHx8IGRhdGFQcml2LmFjY2VzcyggZWxlbSwga2V5LCB7XG5cdFx0XHRlbXB0eTogalF1ZXJ5LkNhbGxiYWNrcyggXCJvbmNlIG1lbW9yeVwiICkuYWRkKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0ZGF0YVByaXYucmVtb3ZlKCBlbGVtLCBbIHR5cGUgKyBcInF1ZXVlXCIsIGtleSBdICk7XG5cdFx0XHR9IClcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRxdWV1ZTogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIHNldHRlciA9IDI7XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0ZGF0YSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gXCJmeFwiO1xuXHRcdFx0c2V0dGVyLS07XG5cdFx0fVxuXG5cdFx0aWYgKCBhcmd1bWVudHMubGVuZ3RoIDwgc2V0dGVyICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5xdWV1ZSggdGhpc1sgMCBdLCB0eXBlICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGRhdGEgPT09IHVuZGVmaW5lZCA/XG5cdFx0XHR0aGlzIDpcblx0XHRcdHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBxdWV1ZSA9IGpRdWVyeS5xdWV1ZSggdGhpcywgdHlwZSwgZGF0YSApO1xuXG5cdFx0XHRcdC8vIEVuc3VyZSBhIGhvb2tzIGZvciB0aGlzIHF1ZXVlXG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggdGhpcywgdHlwZSApO1xuXG5cdFx0XHRcdGlmICggdHlwZSA9PT0gXCJmeFwiICYmIHF1ZXVlWyAwIF0gIT09IFwiaW5wcm9ncmVzc1wiICkge1xuXHRcdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gKTtcblx0fSxcblx0ZGVxdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZGVxdWV1ZSggdGhpcywgdHlwZSApO1xuXHRcdH0gKTtcblx0fSxcblx0Y2xlYXJRdWV1ZTogZnVuY3Rpb24oIHR5cGUgKSB7XG5cdFx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUgfHwgXCJmeFwiLCBbXSApO1xuXHR9LFxuXG5cdC8vIEdldCBhIHByb21pc2UgcmVzb2x2ZWQgd2hlbiBxdWV1ZXMgb2YgYSBjZXJ0YWluIHR5cGVcblx0Ly8gYXJlIGVtcHRpZWQgKGZ4IGlzIHRoZSB0eXBlIGJ5IGRlZmF1bHQpXG5cdHByb21pc2U6IGZ1bmN0aW9uKCB0eXBlLCBvYmogKSB7XG5cdFx0dmFyIHRtcCxcblx0XHRcdGNvdW50ID0gMSxcblx0XHRcdGRlZmVyID0galF1ZXJ5LkRlZmVycmVkKCksXG5cdFx0XHRlbGVtZW50cyA9IHRoaXMsXG5cdFx0XHRpID0gdGhpcy5sZW5ndGgsXG5cdFx0XHRyZXNvbHZlID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggISggLS1jb3VudCApICkge1xuXHRcdFx0XHRcdGRlZmVyLnJlc29sdmVXaXRoKCBlbGVtZW50cywgWyBlbGVtZW50cyBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cblx0XHRpZiAoIHR5cGVvZiB0eXBlICE9PSBcInN0cmluZ1wiICkge1xuXHRcdFx0b2JqID0gdHlwZTtcblx0XHRcdHR5cGUgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdHR5cGUgPSB0eXBlIHx8IFwiZnhcIjtcblxuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0dG1wID0gZGF0YVByaXYuZ2V0KCBlbGVtZW50c1sgaSBdLCB0eXBlICsgXCJxdWV1ZUhvb2tzXCIgKTtcblx0XHRcdGlmICggdG1wICYmIHRtcC5lbXB0eSApIHtcblx0XHRcdFx0Y291bnQrKztcblx0XHRcdFx0dG1wLmVtcHR5LmFkZCggcmVzb2x2ZSApO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXNvbHZlKCk7XG5cdFx0cmV0dXJuIGRlZmVyLnByb21pc2UoIG9iaiApO1xuXHR9XG59ICk7XG52YXIgcG51bSA9ICggL1srLV0/KD86XFxkKlxcLnwpXFxkKyg/OltlRV1bKy1dP1xcZCt8KS8gKS5zb3VyY2U7XG5cbnZhciByY3NzTnVtID0gbmV3IFJlZ0V4cCggXCJeKD86KFsrLV0pPXwpKFwiICsgcG51bSArIFwiKShbYS16JV0qKSRcIiwgXCJpXCIgKTtcblxuXG52YXIgY3NzRXhwYW5kID0gWyBcIlRvcFwiLCBcIlJpZ2h0XCIsIFwiQm90dG9tXCIsIFwiTGVmdFwiIF07XG5cbnZhciBpc0hpZGRlbiA9IGZ1bmN0aW9uKCBlbGVtLCBlbCApIHtcblxuXHRcdC8vIGlzSGlkZGVuIG1pZ2h0IGJlIGNhbGxlZCBmcm9tIGpRdWVyeSNmaWx0ZXIgZnVuY3Rpb247XG5cdFx0Ly8gaW4gdGhhdCBjYXNlLCBlbGVtZW50IHdpbGwgYmUgc2Vjb25kIGFyZ3VtZW50XG5cdFx0ZWxlbSA9IGVsIHx8IGVsZW07XG5cdFx0cmV0dXJuIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgPT09IFwibm9uZVwiIHx8XG5cdFx0XHQhalF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblx0fTtcblxuXG5cbmZ1bmN0aW9uIGFkanVzdENTUyggZWxlbSwgcHJvcCwgdmFsdWVQYXJ0cywgdHdlZW4gKSB7XG5cdHZhciBhZGp1c3RlZCxcblx0XHRzY2FsZSA9IDEsXG5cdFx0bWF4SXRlcmF0aW9ucyA9IDIwLFxuXHRcdGN1cnJlbnRWYWx1ZSA9IHR3ZWVuID9cblx0XHRcdGZ1bmN0aW9uKCkgeyByZXR1cm4gdHdlZW4uY3VyKCk7IH0gOlxuXHRcdFx0ZnVuY3Rpb24oKSB7IHJldHVybiBqUXVlcnkuY3NzKCBlbGVtLCBwcm9wLCBcIlwiICk7IH0sXG5cdFx0aW5pdGlhbCA9IGN1cnJlbnRWYWx1ZSgpLFxuXHRcdHVuaXQgPSB2YWx1ZVBhcnRzICYmIHZhbHVlUGFydHNbIDMgXSB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKSxcblxuXHRcdC8vIFN0YXJ0aW5nIHZhbHVlIGNvbXB1dGF0aW9uIGlzIHJlcXVpcmVkIGZvciBwb3RlbnRpYWwgdW5pdCBtaXNtYXRjaGVzXG5cdFx0aW5pdGlhbEluVW5pdCA9ICggalF1ZXJ5LmNzc051bWJlclsgcHJvcCBdIHx8IHVuaXQgIT09IFwicHhcIiAmJiAraW5pdGlhbCApICYmXG5cdFx0XHRyY3NzTnVtLmV4ZWMoIGpRdWVyeS5jc3MoIGVsZW0sIHByb3AgKSApO1xuXG5cdGlmICggaW5pdGlhbEluVW5pdCAmJiBpbml0aWFsSW5Vbml0WyAzIF0gIT09IHVuaXQgKSB7XG5cblx0XHQvLyBUcnVzdCB1bml0cyByZXBvcnRlZCBieSBqUXVlcnkuY3NzXG5cdFx0dW5pdCA9IHVuaXQgfHwgaW5pdGlhbEluVW5pdFsgMyBdO1xuXG5cdFx0Ly8gTWFrZSBzdXJlIHdlIHVwZGF0ZSB0aGUgdHdlZW4gcHJvcGVydGllcyBsYXRlciBvblxuXHRcdHZhbHVlUGFydHMgPSB2YWx1ZVBhcnRzIHx8IFtdO1xuXG5cdFx0Ly8gSXRlcmF0aXZlbHkgYXBwcm94aW1hdGUgZnJvbSBhIG5vbnplcm8gc3RhcnRpbmcgcG9pbnRcblx0XHRpbml0aWFsSW5Vbml0ID0gK2luaXRpYWwgfHwgMTtcblxuXHRcdGRvIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgaXRlcmF0aW9uIHplcm9lZCBvdXQsIGRvdWJsZSB1bnRpbCB3ZSBnZXQgKnNvbWV0aGluZyouXG5cdFx0XHQvLyBVc2Ugc3RyaW5nIGZvciBkb3VibGluZyBzbyB3ZSBkb24ndCBhY2NpZGVudGFsbHkgc2VlIHNjYWxlIGFzIHVuY2hhbmdlZCBiZWxvd1xuXHRcdFx0c2NhbGUgPSBzY2FsZSB8fCBcIi41XCI7XG5cblx0XHRcdC8vIEFkanVzdCBhbmQgYXBwbHlcblx0XHRcdGluaXRpYWxJblVuaXQgPSBpbml0aWFsSW5Vbml0IC8gc2NhbGU7XG5cdFx0XHRqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AsIGluaXRpYWxJblVuaXQgKyB1bml0ICk7XG5cblx0XHQvLyBVcGRhdGUgc2NhbGUsIHRvbGVyYXRpbmcgemVybyBvciBOYU4gZnJvbSB0d2Vlbi5jdXIoKVxuXHRcdC8vIEJyZWFrIHRoZSBsb29wIGlmIHNjYWxlIGlzIHVuY2hhbmdlZCBvciBwZXJmZWN0LCBvciBpZiB3ZSd2ZSBqdXN0IGhhZCBlbm91Z2guXG5cdFx0fSB3aGlsZSAoXG5cdFx0XHRzY2FsZSAhPT0gKCBzY2FsZSA9IGN1cnJlbnRWYWx1ZSgpIC8gaW5pdGlhbCApICYmIHNjYWxlICE9PSAxICYmIC0tbWF4SXRlcmF0aW9uc1xuXHRcdCk7XG5cdH1cblxuXHRpZiAoIHZhbHVlUGFydHMgKSB7XG5cdFx0aW5pdGlhbEluVW5pdCA9ICtpbml0aWFsSW5Vbml0IHx8ICtpbml0aWFsIHx8IDA7XG5cblx0XHQvLyBBcHBseSByZWxhdGl2ZSBvZmZzZXQgKCs9Ly09KSBpZiBzcGVjaWZpZWRcblx0XHRhZGp1c3RlZCA9IHZhbHVlUGFydHNbIDEgXSA/XG5cdFx0XHRpbml0aWFsSW5Vbml0ICsgKCB2YWx1ZVBhcnRzWyAxIF0gKyAxICkgKiB2YWx1ZVBhcnRzWyAyIF0gOlxuXHRcdFx0K3ZhbHVlUGFydHNbIDIgXTtcblx0XHRpZiAoIHR3ZWVuICkge1xuXHRcdFx0dHdlZW4udW5pdCA9IHVuaXQ7XG5cdFx0XHR0d2Vlbi5zdGFydCA9IGluaXRpYWxJblVuaXQ7XG5cdFx0XHR0d2Vlbi5lbmQgPSBhZGp1c3RlZDtcblx0XHR9XG5cdH1cblx0cmV0dXJuIGFkanVzdGVkO1xufVxudmFyIHJjaGVja2FibGVUeXBlID0gKCAvXig/OmNoZWNrYm94fHJhZGlvKSQvaSApO1xuXG52YXIgcnRhZ05hbWUgPSAoIC88KFtcXHc6LV0rKS8gKTtcblxudmFyIHJzY3JpcHRUeXBlID0gKCAvXiR8XFwvKD86amF2YXxlY21hKXNjcmlwdC9pICk7XG5cblxuXG4vLyBXZSBoYXZlIHRvIGNsb3NlIHRoZXNlIHRhZ3MgdG8gc3VwcG9ydCBYSFRNTCAoIzEzMjAwKVxudmFyIHdyYXBNYXAgPSB7XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdG9wdGlvbjogWyAxLCBcIjxzZWxlY3QgbXVsdGlwbGU9J211bHRpcGxlJz5cIiwgXCI8L3NlbGVjdD5cIiBdLFxuXG5cdC8vIFhIVE1MIHBhcnNlcnMgZG8gbm90IG1hZ2ljYWxseSBpbnNlcnQgZWxlbWVudHMgaW4gdGhlXG5cdC8vIHNhbWUgd2F5IHRoYXQgdGFnIHNvdXAgcGFyc2VycyBkby4gU28gd2UgY2Fubm90IHNob3J0ZW5cblx0Ly8gdGhpcyBieSBvbWl0dGluZyA8dGJvZHk+IG9yIG90aGVyIHJlcXVpcmVkIGVsZW1lbnRzLlxuXHR0aGVhZDogWyAxLCBcIjx0YWJsZT5cIiwgXCI8L3RhYmxlPlwiIF0sXG5cdGNvbDogWyAyLCBcIjx0YWJsZT48Y29sZ3JvdXA+XCIsIFwiPC9jb2xncm91cD48L3RhYmxlPlwiIF0sXG5cdHRyOiBbIDIsIFwiPHRhYmxlPjx0Ym9keT5cIiwgXCI8L3Rib2R5PjwvdGFibGU+XCIgXSxcblx0dGQ6IFsgMywgXCI8dGFibGU+PHRib2R5Pjx0cj5cIiwgXCI8L3RyPjwvdGJvZHk+PC90YWJsZT5cIiBdLFxuXG5cdF9kZWZhdWx0OiBbIDAsIFwiXCIsIFwiXCIgXVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG53cmFwTWFwLm9wdGdyb3VwID0gd3JhcE1hcC5vcHRpb247XG5cbndyYXBNYXAudGJvZHkgPSB3cmFwTWFwLnRmb290ID0gd3JhcE1hcC5jb2xncm91cCA9IHdyYXBNYXAuY2FwdGlvbiA9IHdyYXBNYXAudGhlYWQ7XG53cmFwTWFwLnRoID0gd3JhcE1hcC50ZDtcblxuXG5mdW5jdGlvbiBnZXRBbGwoIGNvbnRleHQsIHRhZyApIHtcblxuXHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdC8vIFVzZSB0eXBlb2YgdG8gYXZvaWQgemVyby1hcmd1bWVudCBtZXRob2QgaW52b2NhdGlvbiBvbiBob3N0IG9iamVjdHMgKCMxNTE1MSlcblx0dmFyIHJldCA9IHR5cGVvZiBjb250ZXh0LmdldEVsZW1lbnRzQnlUYWdOYW1lICE9PSBcInVuZGVmaW5lZFwiID9cblx0XHRcdGNvbnRleHQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdHR5cGVvZiBjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwgIT09IFwidW5kZWZpbmVkXCIgP1xuXHRcdFx0XHRjb250ZXh0LnF1ZXJ5U2VsZWN0b3JBbGwoIHRhZyB8fCBcIipcIiApIDpcblx0XHRcdFtdO1xuXG5cdHJldHVybiB0YWcgPT09IHVuZGVmaW5lZCB8fCB0YWcgJiYgalF1ZXJ5Lm5vZGVOYW1lKCBjb250ZXh0LCB0YWcgKSA/XG5cdFx0alF1ZXJ5Lm1lcmdlKCBbIGNvbnRleHQgXSwgcmV0ICkgOlxuXHRcdHJldDtcbn1cblxuXG4vLyBNYXJrIHNjcmlwdHMgYXMgaGF2aW5nIGFscmVhZHkgYmVlbiBldmFsdWF0ZWRcbmZ1bmN0aW9uIHNldEdsb2JhbEV2YWwoIGVsZW1zLCByZWZFbGVtZW50cyApIHtcblx0dmFyIGkgPSAwLFxuXHRcdGwgPSBlbGVtcy5sZW5ndGg7XG5cblx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdGRhdGFQcml2LnNldChcblx0XHRcdGVsZW1zWyBpIF0sXG5cdFx0XHRcImdsb2JhbEV2YWxcIixcblx0XHRcdCFyZWZFbGVtZW50cyB8fCBkYXRhUHJpdi5nZXQoIHJlZkVsZW1lbnRzWyBpIF0sIFwiZ2xvYmFsRXZhbFwiIClcblx0XHQpO1xuXHR9XG59XG5cblxudmFyIHJodG1sID0gLzx8JiM/XFx3KzsvO1xuXG5mdW5jdGlvbiBidWlsZEZyYWdtZW50KCBlbGVtcywgY29udGV4dCwgc2NyaXB0cywgc2VsZWN0aW9uLCBpZ25vcmVkICkge1xuXHR2YXIgZWxlbSwgdG1wLCB0YWcsIHdyYXAsIGNvbnRhaW5zLCBqLFxuXHRcdGZyYWdtZW50ID0gY29udGV4dC5jcmVhdGVEb2N1bWVudEZyYWdtZW50KCksXG5cdFx0bm9kZXMgPSBbXSxcblx0XHRpID0gMCxcblx0XHRsID0gZWxlbXMubGVuZ3RoO1xuXG5cdGZvciAoIDsgaSA8IGw7IGkrKyApIHtcblx0XHRlbGVtID0gZWxlbXNbIGkgXTtcblxuXHRcdGlmICggZWxlbSB8fCBlbGVtID09PSAwICkge1xuXG5cdFx0XHQvLyBBZGQgbm9kZXMgZGlyZWN0bHlcblx0XHRcdGlmICggalF1ZXJ5LnR5cGUoIGVsZW0gKSA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkPDQuMSwgUGhhbnRvbUpTPDJcblx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRqUXVlcnkubWVyZ2UoIG5vZGVzLCBlbGVtLm5vZGVUeXBlID8gWyBlbGVtIF0gOiBlbGVtICk7XG5cblx0XHRcdC8vIENvbnZlcnQgbm9uLWh0bWwgaW50byBhIHRleHQgbm9kZVxuXHRcdFx0fSBlbHNlIGlmICggIXJodG1sLnRlc3QoIGVsZW0gKSApIHtcblx0XHRcdFx0bm9kZXMucHVzaCggY29udGV4dC5jcmVhdGVUZXh0Tm9kZSggZWxlbSApICk7XG5cblx0XHRcdC8vIENvbnZlcnQgaHRtbCBpbnRvIERPTSBub2Rlc1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dG1wID0gdG1wIHx8IGZyYWdtZW50LmFwcGVuZENoaWxkKCBjb250ZXh0LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHRcdC8vIERlc2VyaWFsaXplIGEgc3RhbmRhcmQgcmVwcmVzZW50YXRpb25cblx0XHRcdFx0dGFnID0gKCBydGFnTmFtZS5leGVjKCBlbGVtICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdHdyYXAgPSB3cmFwTWFwWyB0YWcgXSB8fCB3cmFwTWFwLl9kZWZhdWx0O1xuXHRcdFx0XHR0bXAuaW5uZXJIVE1MID0gd3JhcFsgMSBdICsgalF1ZXJ5Lmh0bWxQcmVmaWx0ZXIoIGVsZW0gKSArIHdyYXBbIDIgXTtcblxuXHRcdFx0XHQvLyBEZXNjZW5kIHRocm91Z2ggd3JhcHBlcnMgdG8gdGhlIHJpZ2h0IGNvbnRlbnRcblx0XHRcdFx0aiA9IHdyYXBbIDAgXTtcblx0XHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdFx0dG1wID0gdG1wLmxhc3RDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHQvLyBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzIG9uIGFuY2llbnQgV2ViS2l0XG5cdFx0XHRcdGpRdWVyeS5tZXJnZSggbm9kZXMsIHRtcC5jaGlsZE5vZGVzICk7XG5cblx0XHRcdFx0Ly8gUmVtZW1iZXIgdGhlIHRvcC1sZXZlbCBjb250YWluZXJcblx0XHRcdFx0dG1wID0gZnJhZ21lbnQuZmlyc3RDaGlsZDtcblxuXHRcdFx0XHQvLyBFbnN1cmUgdGhlIGNyZWF0ZWQgbm9kZXMgYXJlIG9ycGhhbmVkICgjMTIzOTIpXG5cdFx0XHRcdHRtcC50ZXh0Q29udGVudCA9IFwiXCI7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gUmVtb3ZlIHdyYXBwZXIgZnJvbSBmcmFnbWVudFxuXHRmcmFnbWVudC50ZXh0Q29udGVudCA9IFwiXCI7XG5cblx0aSA9IDA7XG5cdHdoaWxlICggKCBlbGVtID0gbm9kZXNbIGkrKyBdICkgKSB7XG5cblx0XHQvLyBTa2lwIGVsZW1lbnRzIGFscmVhZHkgaW4gdGhlIGNvbnRleHQgY29sbGVjdGlvbiAodHJhYy00MDg3KVxuXHRcdGlmICggc2VsZWN0aW9uICYmIGpRdWVyeS5pbkFycmF5KCBlbGVtLCBzZWxlY3Rpb24gKSA+IC0xICkge1xuXHRcdFx0aWYgKCBpZ25vcmVkICkge1xuXHRcdFx0XHRpZ25vcmVkLnB1c2goIGVsZW0gKTtcblx0XHRcdH1cblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdGNvbnRhaW5zID0galF1ZXJ5LmNvbnRhaW5zKCBlbGVtLm93bmVyRG9jdW1lbnQsIGVsZW0gKTtcblxuXHRcdC8vIEFwcGVuZCB0byBmcmFnbWVudFxuXHRcdHRtcCA9IGdldEFsbCggZnJhZ21lbnQuYXBwZW5kQ2hpbGQoIGVsZW0gKSwgXCJzY3JpcHRcIiApO1xuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGlmICggY29udGFpbnMgKSB7XG5cdFx0XHRzZXRHbG9iYWxFdmFsKCB0bXAgKTtcblx0XHR9XG5cblx0XHQvLyBDYXB0dXJlIGV4ZWN1dGFibGVzXG5cdFx0aWYgKCBzY3JpcHRzICkge1xuXHRcdFx0aiA9IDA7XG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRtcFsgaisrIF0gKSApIHtcblx0XHRcdFx0aWYgKCByc2NyaXB0VHlwZS50ZXN0KCBlbGVtLnR5cGUgfHwgXCJcIiApICkge1xuXHRcdFx0XHRcdHNjcmlwdHMucHVzaCggZWxlbSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZyYWdtZW50O1xufVxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBmcmFnbWVudCA9IGRvY3VtZW50LmNyZWF0ZURvY3VtZW50RnJhZ21lbnQoKSxcblx0XHRkaXYgPSBmcmFnbWVudC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApICksXG5cdFx0aW5wdXQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImlucHV0XCIgKTtcblxuXHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMC00LjMsIFNhZmFyaTw9NS4xXG5cdC8vIENoZWNrIHN0YXRlIGxvc3QgaWYgdGhlIG5hbWUgaXMgc2V0ICgjMTEyMTcpXG5cdC8vIFN1cHBvcnQ6IFdpbmRvd3MgV2ViIEFwcHMgKFdXQSlcblx0Ly8gYG5hbWVgIGFuZCBgdHlwZWAgbXVzdCB1c2UgLnNldEF0dHJpYnV0ZSBmb3IgV1dBICgjMTQ5MDEpXG5cdGlucHV0LnNldEF0dHJpYnV0ZSggXCJ0eXBlXCIsIFwicmFkaW9cIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwiY2hlY2tlZFwiLCBcImNoZWNrZWRcIiApO1xuXHRpbnB1dC5zZXRBdHRyaWJ1dGUoIFwibmFtZVwiLCBcInRcIiApO1xuXG5cdGRpdi5hcHBlbmRDaGlsZCggaW5wdXQgKTtcblxuXHQvLyBTdXBwb3J0OiBTYWZhcmk8PTUuMSwgQW5kcm9pZDw0LjJcblx0Ly8gT2xkZXIgV2ViS2l0IGRvZXNuJ3QgY2xvbmUgY2hlY2tlZCBzdGF0ZSBjb3JyZWN0bHkgaW4gZnJhZ21lbnRzXG5cdHN1cHBvcnQuY2hlY2tDbG9uZSA9IGRpdi5jbG9uZU5vZGUoIHRydWUgKS5jbG9uZU5vZGUoIHRydWUgKS5sYXN0Q2hpbGQuY2hlY2tlZDtcblxuXHQvLyBTdXBwb3J0OiBJRTw9MTErXG5cdC8vIE1ha2Ugc3VyZSB0ZXh0YXJlYSAoYW5kIGNoZWNrYm94KSBkZWZhdWx0VmFsdWUgaXMgcHJvcGVybHkgY2xvbmVkXG5cdGRpdi5pbm5lckhUTUwgPSBcIjx0ZXh0YXJlYT54PC90ZXh0YXJlYT5cIjtcblx0c3VwcG9ydC5ub0Nsb25lQ2hlY2tlZCA9ICEhZGl2LmNsb25lTm9kZSggdHJ1ZSApLmxhc3RDaGlsZC5kZWZhdWx0VmFsdWU7XG59ICkoKTtcblxuXG52YXJcblx0cmtleUV2ZW50ID0gL15rZXkvLFxuXHRybW91c2VFdmVudCA9IC9eKD86bW91c2V8cG9pbnRlcnxjb250ZXh0bWVudXxkcmFnfGRyb3ApfGNsaWNrLyxcblx0cnR5cGVuYW1lc3BhY2UgPSAvXihbXi5dKikoPzpcXC4oLispfCkvO1xuXG5mdW5jdGlvbiByZXR1cm5UcnVlKCkge1xuXHRyZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gcmV0dXJuRmFsc2UoKSB7XG5cdHJldHVybiBmYWxzZTtcbn1cblxuLy8gU3VwcG9ydDogSUU5XG4vLyBTZWUgIzEzMzkzIGZvciBtb3JlIGluZm9cbmZ1bmN0aW9uIHNhZmVBY3RpdmVFbGVtZW50KCkge1xuXHR0cnkge1xuXHRcdHJldHVybiBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXHR9IGNhdGNoICggZXJyICkgeyB9XG59XG5cbmZ1bmN0aW9uIG9uKCBlbGVtLCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuLCBvbmUgKSB7XG5cdHZhciBvcmlnRm4sIHR5cGU7XG5cblx0Ly8gVHlwZXMgY2FuIGJlIGEgbWFwIG9mIHR5cGVzL2hhbmRsZXJzXG5cdGlmICggdHlwZW9mIHR5cGVzID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gKCB0eXBlcy1PYmplY3QsIHNlbGVjdG9yLCBkYXRhIClcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciAhPT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1PYmplY3QsIGRhdGEgKVxuXHRcdFx0ZGF0YSA9IGRhdGEgfHwgc2VsZWN0b3I7XG5cdFx0XHRzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0Zm9yICggdHlwZSBpbiB0eXBlcyApIHtcblx0XHRcdG9uKCBlbGVtLCB0eXBlLCBzZWxlY3RvciwgZGF0YSwgdHlwZXNbIHR5cGUgXSwgb25lICk7XG5cdFx0fVxuXHRcdHJldHVybiBlbGVtO1xuXHR9XG5cblx0aWYgKCBkYXRhID09IG51bGwgJiYgZm4gPT0gbnVsbCApIHtcblxuXHRcdC8vICggdHlwZXMsIGZuIClcblx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdGRhdGEgPSBzZWxlY3RvciA9IHVuZGVmaW5lZDtcblx0fSBlbHNlIGlmICggZm4gPT0gbnVsbCApIHtcblx0XHRpZiAoIHR5cGVvZiBzZWxlY3RvciA9PT0gXCJzdHJpbmdcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgc2VsZWN0b3IsIGZuIClcblx0XHRcdGZuID0gZGF0YTtcblx0XHRcdGRhdGEgPSB1bmRlZmluZWQ7XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gKCB0eXBlcywgZGF0YSwgZm4gKVxuXHRcdFx0Zm4gPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9XG5cdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdGZuID0gcmV0dXJuRmFsc2U7XG5cdH0gZWxzZSBpZiAoICFmbiApIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fVxuXG5cdGlmICggb25lID09PSAxICkge1xuXHRcdG9yaWdGbiA9IGZuO1xuXHRcdGZuID0gZnVuY3Rpb24oIGV2ZW50ICkge1xuXG5cdFx0XHQvLyBDYW4gdXNlIGFuIGVtcHR5IHNldCwgc2luY2UgZXZlbnQgY29udGFpbnMgdGhlIGluZm9cblx0XHRcdGpRdWVyeSgpLm9mZiggZXZlbnQgKTtcblx0XHRcdHJldHVybiBvcmlnRm4uYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHRcdH07XG5cblx0XHQvLyBVc2Ugc2FtZSBndWlkIHNvIGNhbGxlciBjYW4gcmVtb3ZlIHVzaW5nIG9yaWdGblxuXHRcdGZuLmd1aWQgPSBvcmlnRm4uZ3VpZCB8fCAoIG9yaWdGbi5ndWlkID0galF1ZXJ5Lmd1aWQrKyApO1xuXHR9XG5cdHJldHVybiBlbGVtLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdGpRdWVyeS5ldmVudC5hZGQoIHRoaXMsIHR5cGVzLCBmbiwgZGF0YSwgc2VsZWN0b3IgKTtcblx0fSApO1xufVxuXG4vKlxuICogSGVscGVyIGZ1bmN0aW9ucyBmb3IgbWFuYWdpbmcgZXZlbnRzIC0tIG5vdCBwYXJ0IG9mIHRoZSBwdWJsaWMgaW50ZXJmYWNlLlxuICogUHJvcHMgdG8gRGVhbiBFZHdhcmRzJyBhZGRFdmVudCBsaWJyYXJ5IGZvciBtYW55IG9mIHRoZSBpZGVhcy5cbiAqL1xualF1ZXJ5LmV2ZW50ID0ge1xuXG5cdGdsb2JhbDoge30sXG5cblx0YWRkOiBmdW5jdGlvbiggZWxlbSwgdHlwZXMsIGhhbmRsZXIsIGRhdGEsIHNlbGVjdG9yICkge1xuXG5cdFx0dmFyIGhhbmRsZU9iakluLCBldmVudEhhbmRsZSwgdG1wLFxuXHRcdFx0ZXZlbnRzLCB0LCBoYW5kbGVPYmosXG5cdFx0XHRzcGVjaWFsLCBoYW5kbGVycywgdHlwZSwgbmFtZXNwYWNlcywgb3JpZ1R5cGUsXG5cdFx0XHRlbGVtRGF0YSA9IGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0Ly8gRG9uJ3QgYXR0YWNoIGV2ZW50cyB0byBub0RhdGEgb3IgdGV4dC9jb21tZW50IG5vZGVzIChidXQgYWxsb3cgcGxhaW4gb2JqZWN0cylcblx0XHRpZiAoICFlbGVtRGF0YSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHQvLyBDYWxsZXIgY2FuIHBhc3MgaW4gYW4gb2JqZWN0IG9mIGN1c3RvbSBkYXRhIGluIGxpZXUgb2YgdGhlIGhhbmRsZXJcblx0XHRpZiAoIGhhbmRsZXIuaGFuZGxlciApIHtcblx0XHRcdGhhbmRsZU9iakluID0gaGFuZGxlcjtcblx0XHRcdGhhbmRsZXIgPSBoYW5kbGVPYmpJbi5oYW5kbGVyO1xuXHRcdFx0c2VsZWN0b3IgPSBoYW5kbGVPYmpJbi5zZWxlY3Rvcjtcblx0XHR9XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCB0aGUgaGFuZGxlciBoYXMgYSB1bmlxdWUgSUQsIHVzZWQgdG8gZmluZC9yZW1vdmUgaXQgbGF0ZXJcblx0XHRpZiAoICFoYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRoYW5kbGVyLmd1aWQgPSBqUXVlcnkuZ3VpZCsrO1xuXHRcdH1cblxuXHRcdC8vIEluaXQgdGhlIGVsZW1lbnQncyBldmVudCBzdHJ1Y3R1cmUgYW5kIG1haW4gaGFuZGxlciwgaWYgdGhpcyBpcyB0aGUgZmlyc3Rcblx0XHRpZiAoICEoIGV2ZW50cyA9IGVsZW1EYXRhLmV2ZW50cyApICkge1xuXHRcdFx0ZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzID0ge307XG5cdFx0fVxuXHRcdGlmICggISggZXZlbnRIYW5kbGUgPSBlbGVtRGF0YS5oYW5kbGUgKSApIHtcblx0XHRcdGV2ZW50SGFuZGxlID0gZWxlbURhdGEuaGFuZGxlID0gZnVuY3Rpb24oIGUgKSB7XG5cblx0XHRcdFx0Ly8gRGlzY2FyZCB0aGUgc2Vjb25kIGV2ZW50IG9mIGEgalF1ZXJ5LmV2ZW50LnRyaWdnZXIoKSBhbmRcblx0XHRcdFx0Ly8gd2hlbiBhbiBldmVudCBpcyBjYWxsZWQgYWZ0ZXIgYSBwYWdlIGhhcyB1bmxvYWRlZFxuXHRcdFx0XHRyZXR1cm4gdHlwZW9mIGpRdWVyeSAhPT0gXCJ1bmRlZmluZWRcIiAmJiBqUXVlcnkuZXZlbnQudHJpZ2dlcmVkICE9PSBlLnR5cGUgP1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC5kaXNwYXRjaC5hcHBseSggZWxlbSwgYXJndW1lbnRzICkgOiB1bmRlZmluZWQ7XG5cdFx0XHR9O1xuXHRcdH1cblxuXHRcdC8vIEhhbmRsZSBtdWx0aXBsZSBldmVudHMgc2VwYXJhdGVkIGJ5IGEgc3BhY2Vcblx0XHR0eXBlcyA9ICggdHlwZXMgfHwgXCJcIiApLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbIFwiXCIgXTtcblx0XHR0ID0gdHlwZXMubGVuZ3RoO1xuXHRcdHdoaWxlICggdC0tICkge1xuXHRcdFx0dG1wID0gcnR5cGVuYW1lc3BhY2UuZXhlYyggdHlwZXNbIHQgXSApIHx8IFtdO1xuXHRcdFx0dHlwZSA9IG9yaWdUeXBlID0gdG1wWyAxIF07XG5cdFx0XHRuYW1lc3BhY2VzID0gKCB0bXBbIDIgXSB8fCBcIlwiICkuc3BsaXQoIFwiLlwiICkuc29ydCgpO1xuXG5cdFx0XHQvLyBUaGVyZSAqbXVzdCogYmUgYSB0eXBlLCBubyBhdHRhY2hpbmcgbmFtZXNwYWNlLW9ubHkgaGFuZGxlcnNcblx0XHRcdGlmICggIXR5cGUgKSB7XG5cdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBJZiBldmVudCBjaGFuZ2VzIGl0cyB0eXBlLCB1c2UgdGhlIHNwZWNpYWwgZXZlbnQgaGFuZGxlcnMgZm9yIHRoZSBjaGFuZ2VkIHR5cGVcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXG5cdFx0XHQvLyBJZiBzZWxlY3RvciBkZWZpbmVkLCBkZXRlcm1pbmUgc3BlY2lhbCBldmVudCBhcGkgdHlwZSwgb3RoZXJ3aXNlIGdpdmVuIHR5cGVcblx0XHRcdHR5cGUgPSAoIHNlbGVjdG9yID8gc3BlY2lhbC5kZWxlZ2F0ZVR5cGUgOiBzcGVjaWFsLmJpbmRUeXBlICkgfHwgdHlwZTtcblxuXHRcdFx0Ly8gVXBkYXRlIHNwZWNpYWwgYmFzZWQgb24gbmV3bHkgcmVzZXQgdHlwZVxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsWyB0eXBlIF0gfHwge307XG5cblx0XHRcdC8vIGhhbmRsZU9iaiBpcyBwYXNzZWQgdG8gYWxsIGV2ZW50IGhhbmRsZXJzXG5cdFx0XHRoYW5kbGVPYmogPSBqUXVlcnkuZXh0ZW5kKCB7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdG9yaWdUeXBlOiBvcmlnVHlwZSxcblx0XHRcdFx0ZGF0YTogZGF0YSxcblx0XHRcdFx0aGFuZGxlcjogaGFuZGxlcixcblx0XHRcdFx0Z3VpZDogaGFuZGxlci5ndWlkLFxuXHRcdFx0XHRzZWxlY3Rvcjogc2VsZWN0b3IsXG5cdFx0XHRcdG5lZWRzQ29udGV4dDogc2VsZWN0b3IgJiYgalF1ZXJ5LmV4cHIubWF0Y2gubmVlZHNDb250ZXh0LnRlc3QoIHNlbGVjdG9yICksXG5cdFx0XHRcdG5hbWVzcGFjZTogbmFtZXNwYWNlcy5qb2luKCBcIi5cIiApXG5cdFx0XHR9LCBoYW5kbGVPYmpJbiApO1xuXG5cdFx0XHQvLyBJbml0IHRoZSBldmVudCBoYW5kbGVyIHF1ZXVlIGlmIHdlJ3JlIHRoZSBmaXJzdFxuXHRcdFx0aWYgKCAhKCBoYW5kbGVycyA9IGV2ZW50c1sgdHlwZSBdICkgKSB7XG5cdFx0XHRcdGhhbmRsZXJzID0gZXZlbnRzWyB0eXBlIF0gPSBbXTtcblx0XHRcdFx0aGFuZGxlcnMuZGVsZWdhdGVDb3VudCA9IDA7XG5cblx0XHRcdFx0Ly8gT25seSB1c2UgYWRkRXZlbnRMaXN0ZW5lciBpZiB0aGUgc3BlY2lhbCBldmVudHMgaGFuZGxlciByZXR1cm5zIGZhbHNlXG5cdFx0XHRcdGlmICggIXNwZWNpYWwuc2V0dXAgfHxcblx0XHRcdFx0XHRzcGVjaWFsLnNldHVwLmNhbGwoIGVsZW0sIGRhdGEsIG5hbWVzcGFjZXMsIGV2ZW50SGFuZGxlICkgPT09IGZhbHNlICkge1xuXG5cdFx0XHRcdFx0aWYgKCBlbGVtLmFkZEV2ZW50TGlzdGVuZXIgKSB7XG5cdFx0XHRcdFx0XHRlbGVtLmFkZEV2ZW50TGlzdGVuZXIoIHR5cGUsIGV2ZW50SGFuZGxlICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggc3BlY2lhbC5hZGQgKSB7XG5cdFx0XHRcdHNwZWNpYWwuYWRkLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXG5cdFx0XHRcdGlmICggIWhhbmRsZU9iai5oYW5kbGVyLmd1aWQgKSB7XG5cdFx0XHRcdFx0aGFuZGxlT2JqLmhhbmRsZXIuZ3VpZCA9IGhhbmRsZXIuZ3VpZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgdG8gdGhlIGVsZW1lbnQncyBoYW5kbGVyIGxpc3QsIGRlbGVnYXRlcyBpbiBmcm9udFxuXHRcdFx0aWYgKCBzZWxlY3RvciApIHtcblx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50KyssIDAsIGhhbmRsZU9iaiApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlcnMucHVzaCggaGFuZGxlT2JqICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEtlZXAgdHJhY2sgb2Ygd2hpY2ggZXZlbnRzIGhhdmUgZXZlciBiZWVuIHVzZWQsIGZvciBldmVudCBvcHRpbWl6YXRpb25cblx0XHRcdGpRdWVyeS5ldmVudC5nbG9iYWxbIHR5cGUgXSA9IHRydWU7XG5cdFx0fVxuXG5cdH0sXG5cblx0Ly8gRGV0YWNoIGFuIGV2ZW50IG9yIHNldCBvZiBldmVudHMgZnJvbSBhbiBlbGVtZW50XG5cdHJlbW92ZTogZnVuY3Rpb24oIGVsZW0sIHR5cGVzLCBoYW5kbGVyLCBzZWxlY3RvciwgbWFwcGVkVHlwZXMgKSB7XG5cblx0XHR2YXIgaiwgb3JpZ0NvdW50LCB0bXAsXG5cdFx0XHRldmVudHMsIHQsIGhhbmRsZU9iaixcblx0XHRcdHNwZWNpYWwsIGhhbmRsZXJzLCB0eXBlLCBuYW1lc3BhY2VzLCBvcmlnVHlwZSxcblx0XHRcdGVsZW1EYXRhID0gZGF0YVByaXYuaGFzRGF0YSggZWxlbSApICYmIGRhdGFQcml2LmdldCggZWxlbSApO1xuXG5cdFx0aWYgKCAhZWxlbURhdGEgfHwgISggZXZlbnRzID0gZWxlbURhdGEuZXZlbnRzICkgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gT25jZSBmb3IgZWFjaCB0eXBlLm5hbWVzcGFjZSBpbiB0eXBlczsgdHlwZSBtYXkgYmUgb21pdHRlZFxuXHRcdHR5cGVzID0gKCB0eXBlcyB8fCBcIlwiICkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXHRcdHQgPSB0eXBlcy5sZW5ndGg7XG5cdFx0d2hpbGUgKCB0LS0gKSB7XG5cdFx0XHR0bXAgPSBydHlwZW5hbWVzcGFjZS5leGVjKCB0eXBlc1sgdCBdICkgfHwgW107XG5cdFx0XHR0eXBlID0gb3JpZ1R5cGUgPSB0bXBbIDEgXTtcblx0XHRcdG5hbWVzcGFjZXMgPSAoIHRtcFsgMiBdIHx8IFwiXCIgKS5zcGxpdCggXCIuXCIgKS5zb3J0KCk7XG5cblx0XHRcdC8vIFVuYmluZCBhbGwgZXZlbnRzIChvbiB0aGlzIG5hbWVzcGFjZSwgaWYgcHJvdmlkZWQpIGZvciB0aGUgZWxlbWVudFxuXHRcdFx0aWYgKCAhdHlwZSApIHtcblx0XHRcdFx0Zm9yICggdHlwZSBpbiBldmVudHMgKSB7XG5cdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSArIHR5cGVzWyB0IF0sIGhhbmRsZXIsIHNlbGVjdG9yLCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHR9XG5cblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdFx0dHlwZSA9ICggc2VsZWN0b3IgPyBzcGVjaWFsLmRlbGVnYXRlVHlwZSA6IHNwZWNpYWwuYmluZFR5cGUgKSB8fCB0eXBlO1xuXHRcdFx0aGFuZGxlcnMgPSBldmVudHNbIHR5cGUgXSB8fCBbXTtcblx0XHRcdHRtcCA9IHRtcFsgMiBdICYmXG5cdFx0XHRcdG5ldyBSZWdFeHAoIFwiKF58XFxcXC4pXCIgKyBuYW1lc3BhY2VzLmpvaW4oIFwiXFxcXC4oPzouKlxcXFwufClcIiApICsgXCIoXFxcXC58JClcIiApO1xuXG5cdFx0XHQvLyBSZW1vdmUgbWF0Y2hpbmcgZXZlbnRzXG5cdFx0XHRvcmlnQ291bnQgPSBqID0gaGFuZGxlcnMubGVuZ3RoO1xuXHRcdFx0d2hpbGUgKCBqLS0gKSB7XG5cdFx0XHRcdGhhbmRsZU9iaiA9IGhhbmRsZXJzWyBqIF07XG5cblx0XHRcdFx0aWYgKCAoIG1hcHBlZFR5cGVzIHx8IG9yaWdUeXBlID09PSBoYW5kbGVPYmoub3JpZ1R5cGUgKSAmJlxuXHRcdFx0XHRcdCggIWhhbmRsZXIgfHwgaGFuZGxlci5ndWlkID09PSBoYW5kbGVPYmouZ3VpZCApICYmXG5cdFx0XHRcdFx0KCAhdG1wIHx8IHRtcC50ZXN0KCBoYW5kbGVPYmoubmFtZXNwYWNlICkgKSAmJlxuXHRcdFx0XHRcdCggIXNlbGVjdG9yIHx8IHNlbGVjdG9yID09PSBoYW5kbGVPYmouc2VsZWN0b3IgfHxcblx0XHRcdFx0XHRcdHNlbGVjdG9yID09PSBcIioqXCIgJiYgaGFuZGxlT2JqLnNlbGVjdG9yICkgKSB7XG5cdFx0XHRcdFx0aGFuZGxlcnMuc3BsaWNlKCBqLCAxICk7XG5cblx0XHRcdFx0XHRpZiAoIGhhbmRsZU9iai5zZWxlY3RvciApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJzLmRlbGVnYXRlQ291bnQtLTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBzcGVjaWFsLnJlbW92ZSApIHtcblx0XHRcdFx0XHRcdHNwZWNpYWwucmVtb3ZlLmNhbGwoIGVsZW0sIGhhbmRsZU9iaiApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBSZW1vdmUgZ2VuZXJpYyBldmVudCBoYW5kbGVyIGlmIHdlIHJlbW92ZWQgc29tZXRoaW5nIGFuZCBubyBtb3JlIGhhbmRsZXJzIGV4aXN0XG5cdFx0XHQvLyAoYXZvaWRzIHBvdGVudGlhbCBmb3IgZW5kbGVzcyByZWN1cnNpb24gZHVyaW5nIHJlbW92YWwgb2Ygc3BlY2lhbCBldmVudCBoYW5kbGVycylcblx0XHRcdGlmICggb3JpZ0NvdW50ICYmICFoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRcdGlmICggIXNwZWNpYWwudGVhcmRvd24gfHxcblx0XHRcdFx0XHRzcGVjaWFsLnRlYXJkb3duLmNhbGwoIGVsZW0sIG5hbWVzcGFjZXMsIGVsZW1EYXRhLmhhbmRsZSApID09PSBmYWxzZSApIHtcblxuXHRcdFx0XHRcdGpRdWVyeS5yZW1vdmVFdmVudCggZWxlbSwgdHlwZSwgZWxlbURhdGEuaGFuZGxlICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRkZWxldGUgZXZlbnRzWyB0eXBlIF07XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUmVtb3ZlIGRhdGEgYW5kIHRoZSBleHBhbmRvIGlmIGl0J3Mgbm8gbG9uZ2VyIHVzZWRcblx0XHRpZiAoIGpRdWVyeS5pc0VtcHR5T2JqZWN0KCBldmVudHMgKSApIHtcblx0XHRcdGRhdGFQcml2LnJlbW92ZSggZWxlbSwgXCJoYW5kbGUgZXZlbnRzXCIgKTtcblx0XHR9XG5cdH0sXG5cblx0ZGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdC8vIE1ha2UgYSB3cml0YWJsZSBqUXVlcnkuRXZlbnQgZnJvbSB0aGUgbmF0aXZlIGV2ZW50IG9iamVjdFxuXHRcdGV2ZW50ID0galF1ZXJ5LmV2ZW50LmZpeCggZXZlbnQgKTtcblxuXHRcdHZhciBpLCBqLCByZXQsIG1hdGNoZWQsIGhhbmRsZU9iaixcblx0XHRcdGhhbmRsZXJRdWV1ZSA9IFtdLFxuXHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoIGFyZ3VtZW50cyApLFxuXHRcdFx0aGFuZGxlcnMgPSAoIGRhdGFQcml2LmdldCggdGhpcywgXCJldmVudHNcIiApIHx8IHt9IClbIGV2ZW50LnR5cGUgXSB8fCBbXSxcblx0XHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgZXZlbnQudHlwZSBdIHx8IHt9O1xuXG5cdFx0Ly8gVXNlIHRoZSBmaXgtZWQgalF1ZXJ5LkV2ZW50IHJhdGhlciB0aGFuIHRoZSAocmVhZC1vbmx5KSBuYXRpdmUgZXZlbnRcblx0XHRhcmdzWyAwIF0gPSBldmVudDtcblx0XHRldmVudC5kZWxlZ2F0ZVRhcmdldCA9IHRoaXM7XG5cblx0XHQvLyBDYWxsIHRoZSBwcmVEaXNwYXRjaCBob29rIGZvciB0aGUgbWFwcGVkIHR5cGUsIGFuZCBsZXQgaXQgYmFpbCBpZiBkZXNpcmVkXG5cdFx0aWYgKCBzcGVjaWFsLnByZURpc3BhdGNoICYmIHNwZWNpYWwucHJlRGlzcGF0Y2guY2FsbCggdGhpcywgZXZlbnQgKSA9PT0gZmFsc2UgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0Ly8gRGV0ZXJtaW5lIGhhbmRsZXJzXG5cdFx0aGFuZGxlclF1ZXVlID0galF1ZXJ5LmV2ZW50LmhhbmRsZXJzLmNhbGwoIHRoaXMsIGV2ZW50LCBoYW5kbGVycyApO1xuXG5cdFx0Ly8gUnVuIGRlbGVnYXRlcyBmaXJzdDsgdGhleSBtYXkgd2FudCB0byBzdG9wIHByb3BhZ2F0aW9uIGJlbmVhdGggdXNcblx0XHRpID0gMDtcblx0XHR3aGlsZSAoICggbWF0Y2hlZCA9IGhhbmRsZXJRdWV1ZVsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblx0XHRcdGV2ZW50LmN1cnJlbnRUYXJnZXQgPSBtYXRjaGVkLmVsZW07XG5cblx0XHRcdGogPSAwO1xuXHRcdFx0d2hpbGUgKCAoIGhhbmRsZU9iaiA9IG1hdGNoZWQuaGFuZGxlcnNbIGorKyBdICkgJiZcblx0XHRcdFx0IWV2ZW50LmlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkKCkgKSB7XG5cblx0XHRcdFx0Ly8gVHJpZ2dlcmVkIGV2ZW50IG11c3QgZWl0aGVyIDEpIGhhdmUgbm8gbmFtZXNwYWNlLCBvciAyKSBoYXZlIG5hbWVzcGFjZShzKVxuXHRcdFx0XHQvLyBhIHN1YnNldCBvciBlcXVhbCB0byB0aG9zZSBpbiB0aGUgYm91bmQgZXZlbnQgKGJvdGggY2FuIGhhdmUgbm8gbmFtZXNwYWNlKS5cblx0XHRcdFx0aWYgKCAhZXZlbnQucm5hbWVzcGFjZSB8fCBldmVudC5ybmFtZXNwYWNlLnRlc3QoIGhhbmRsZU9iai5uYW1lc3BhY2UgKSApIHtcblxuXHRcdFx0XHRcdGV2ZW50LmhhbmRsZU9iaiA9IGhhbmRsZU9iajtcblx0XHRcdFx0XHRldmVudC5kYXRhID0gaGFuZGxlT2JqLmRhdGE7XG5cblx0XHRcdFx0XHRyZXQgPSAoICggalF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGhhbmRsZU9iai5vcmlnVHlwZSBdIHx8IHt9ICkuaGFuZGxlIHx8XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlciApLmFwcGx5KCBtYXRjaGVkLmVsZW0sIGFyZ3MgKTtcblxuXHRcdFx0XHRcdGlmICggcmV0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICggZXZlbnQucmVzdWx0ID0gcmV0ICkgPT09IGZhbHNlICkge1xuXHRcdFx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdFx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsIHRoZSBwb3N0RGlzcGF0Y2ggaG9vayBmb3IgdGhlIG1hcHBlZCB0eXBlXG5cdFx0aWYgKCBzcGVjaWFsLnBvc3REaXNwYXRjaCApIHtcblx0XHRcdHNwZWNpYWwucG9zdERpc3BhdGNoLmNhbGwoIHRoaXMsIGV2ZW50ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGV2ZW50LnJlc3VsdDtcblx0fSxcblxuXHRoYW5kbGVyczogZnVuY3Rpb24oIGV2ZW50LCBoYW5kbGVycyApIHtcblx0XHR2YXIgaSwgbWF0Y2hlcywgc2VsLCBoYW5kbGVPYmosXG5cdFx0XHRoYW5kbGVyUXVldWUgPSBbXSxcblx0XHRcdGRlbGVnYXRlQ291bnQgPSBoYW5kbGVycy5kZWxlZ2F0ZUNvdW50LFxuXHRcdFx0Y3VyID0gZXZlbnQudGFyZ2V0O1xuXG5cdFx0Ly8gU3VwcG9ydCAoYXQgbGVhc3QpOiBDaHJvbWUsIElFOVxuXHRcdC8vIEZpbmQgZGVsZWdhdGUgaGFuZGxlcnNcblx0XHQvLyBCbGFjay1ob2xlIFNWRyA8dXNlPiBpbnN0YW5jZSB0cmVlcyAoIzEzMTgwKVxuXHRcdC8vXG5cdFx0Ly8gU3VwcG9ydDogRmlyZWZveDw9NDIrXG5cdFx0Ly8gQXZvaWQgbm9uLWxlZnQtY2xpY2sgaW4gRkYgYnV0IGRvbid0IGJsb2NrIElFIHJhZGlvIGV2ZW50cyAoIzM4NjEsIGdoLTIzNDMpXG5cdFx0aWYgKCBkZWxlZ2F0ZUNvdW50ICYmIGN1ci5ub2RlVHlwZSAmJlxuXHRcdFx0KCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgfHwgaXNOYU4oIGV2ZW50LmJ1dHRvbiApIHx8IGV2ZW50LmJ1dHRvbiA8IDEgKSApIHtcblxuXHRcdFx0Zm9yICggOyBjdXIgIT09IHRoaXM7IGN1ciA9IGN1ci5wYXJlbnROb2RlIHx8IHRoaXMgKSB7XG5cblx0XHRcdFx0Ly8gRG9uJ3QgY2hlY2sgbm9uLWVsZW1lbnRzICgjMTMyMDgpXG5cdFx0XHRcdC8vIERvbid0IHByb2Nlc3MgY2xpY2tzIG9uIGRpc2FibGVkIGVsZW1lbnRzICgjNjkxMSwgIzgxNjUsICMxMTM4MiwgIzExNzY0KVxuXHRcdFx0XHRpZiAoIGN1ci5ub2RlVHlwZSA9PT0gMSAmJiAoIGN1ci5kaXNhYmxlZCAhPT0gdHJ1ZSB8fCBldmVudC50eXBlICE9PSBcImNsaWNrXCIgKSApIHtcblx0XHRcdFx0XHRtYXRjaGVzID0gW107XG5cdFx0XHRcdFx0Zm9yICggaSA9IDA7IGkgPCBkZWxlZ2F0ZUNvdW50OyBpKysgKSB7XG5cdFx0XHRcdFx0XHRoYW5kbGVPYmogPSBoYW5kbGVyc1sgaSBdO1xuXG5cdFx0XHRcdFx0XHQvLyBEb24ndCBjb25mbGljdCB3aXRoIE9iamVjdC5wcm90b3R5cGUgcHJvcGVydGllcyAoIzEzMjAzKVxuXHRcdFx0XHRcdFx0c2VsID0gaGFuZGxlT2JqLnNlbGVjdG9yICsgXCIgXCI7XG5cblx0XHRcdFx0XHRcdGlmICggbWF0Y2hlc1sgc2VsIF0gPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlc1sgc2VsIF0gPSBoYW5kbGVPYmoubmVlZHNDb250ZXh0ID9cblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkoIHNlbCwgdGhpcyApLmluZGV4KCBjdXIgKSA+IC0xIDpcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuZmluZCggc2VsLCB0aGlzLCBudWxsLCBbIGN1ciBdICkubGVuZ3RoO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKCBtYXRjaGVzWyBzZWwgXSApIHtcblx0XHRcdFx0XHRcdFx0bWF0Y2hlcy5wdXNoKCBoYW5kbGVPYmogKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aWYgKCBtYXRjaGVzLmxlbmd0aCApIHtcblx0XHRcdFx0XHRcdGhhbmRsZXJRdWV1ZS5wdXNoKCB7IGVsZW06IGN1ciwgaGFuZGxlcnM6IG1hdGNoZXMgfSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIEFkZCB0aGUgcmVtYWluaW5nIChkaXJlY3RseS1ib3VuZCkgaGFuZGxlcnNcblx0XHRpZiAoIGRlbGVnYXRlQ291bnQgPCBoYW5kbGVycy5sZW5ndGggKSB7XG5cdFx0XHRoYW5kbGVyUXVldWUucHVzaCggeyBlbGVtOiB0aGlzLCBoYW5kbGVyczogaGFuZGxlcnMuc2xpY2UoIGRlbGVnYXRlQ291bnQgKSB9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGhhbmRsZXJRdWV1ZTtcblx0fSxcblxuXHQvLyBJbmNsdWRlcyBzb21lIGV2ZW50IHByb3BzIHNoYXJlZCBieSBLZXlFdmVudCBhbmQgTW91c2VFdmVudFxuXHRwcm9wczogKCBcImFsdEtleSBidWJibGVzIGNhbmNlbGFibGUgY3RybEtleSBjdXJyZW50VGFyZ2V0IGRldGFpbCBldmVudFBoYXNlIFwiICtcblx0XHRcIm1ldGFLZXkgcmVsYXRlZFRhcmdldCBzaGlmdEtleSB0YXJnZXQgdGltZVN0YW1wIHZpZXcgd2hpY2hcIiApLnNwbGl0KCBcIiBcIiApLFxuXG5cdGZpeEhvb2tzOiB7fSxcblxuXHRrZXlIb29rczoge1xuXHRcdHByb3BzOiBcImNoYXIgY2hhckNvZGUga2V5IGtleUNvZGVcIi5zcGxpdCggXCIgXCIgKSxcblx0XHRmaWx0ZXI6IGZ1bmN0aW9uKCBldmVudCwgb3JpZ2luYWwgKSB7XG5cblx0XHRcdC8vIEFkZCB3aGljaCBmb3Iga2V5IGV2ZW50c1xuXHRcdFx0aWYgKCBldmVudC53aGljaCA9PSBudWxsICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9IG9yaWdpbmFsLmNoYXJDb2RlICE9IG51bGwgPyBvcmlnaW5hbC5jaGFyQ29kZSA6IG9yaWdpbmFsLmtleUNvZGU7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0bW91c2VIb29rczoge1xuXHRcdHByb3BzOiAoIFwiYnV0dG9uIGJ1dHRvbnMgY2xpZW50WCBjbGllbnRZIG9mZnNldFggb2Zmc2V0WSBwYWdlWCBwYWdlWSBcIiArXG5cdFx0XHRcInNjcmVlblggc2NyZWVuWSB0b0VsZW1lbnRcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRcdGZpbHRlcjogZnVuY3Rpb24oIGV2ZW50LCBvcmlnaW5hbCApIHtcblx0XHRcdHZhciBldmVudERvYywgZG9jLCBib2R5LFxuXHRcdFx0XHRidXR0b24gPSBvcmlnaW5hbC5idXR0b247XG5cblx0XHRcdC8vIENhbGN1bGF0ZSBwYWdlWC9ZIGlmIG1pc3NpbmcgYW5kIGNsaWVudFgvWSBhdmFpbGFibGVcblx0XHRcdGlmICggZXZlbnQucGFnZVggPT0gbnVsbCAmJiBvcmlnaW5hbC5jbGllbnRYICE9IG51bGwgKSB7XG5cdFx0XHRcdGV2ZW50RG9jID0gZXZlbnQudGFyZ2V0Lm93bmVyRG9jdW1lbnQgfHwgZG9jdW1lbnQ7XG5cdFx0XHRcdGRvYyA9IGV2ZW50RG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdFx0Ym9keSA9IGV2ZW50RG9jLmJvZHk7XG5cblx0XHRcdFx0ZXZlbnQucGFnZVggPSBvcmlnaW5hbC5jbGllbnRYICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsTGVmdCB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsTGVmdCB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRMZWZ0IHx8IGJvZHkgJiYgYm9keS5jbGllbnRMZWZ0IHx8IDAgKTtcblx0XHRcdFx0ZXZlbnQucGFnZVkgPSBvcmlnaW5hbC5jbGllbnRZICtcblx0XHRcdFx0XHQoIGRvYyAmJiBkb2Muc2Nyb2xsVG9wICB8fCBib2R5ICYmIGJvZHkuc2Nyb2xsVG9wICB8fCAwICkgLVxuXHRcdFx0XHRcdCggZG9jICYmIGRvYy5jbGllbnRUb3AgIHx8IGJvZHkgJiYgYm9keS5jbGllbnRUb3AgIHx8IDAgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQWRkIHdoaWNoIGZvciBjbGljazogMSA9PT0gbGVmdDsgMiA9PT0gbWlkZGxlOyAzID09PSByaWdodFxuXHRcdFx0Ly8gTm90ZTogYnV0dG9uIGlzIG5vdCBub3JtYWxpemVkLCBzbyBkb24ndCB1c2UgaXRcblx0XHRcdGlmICggIWV2ZW50LndoaWNoICYmIGJ1dHRvbiAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRldmVudC53aGljaCA9ICggYnV0dG9uICYgMSA/IDEgOiAoIGJ1dHRvbiAmIDIgPyAzIDogKCBidXR0b24gJiA0ID8gMiA6IDAgKSApICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cdH0sXG5cblx0Zml4OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0aWYgKCBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSApIHtcblx0XHRcdHJldHVybiBldmVudDtcblx0XHR9XG5cblx0XHQvLyBDcmVhdGUgYSB3cml0YWJsZSBjb3B5IG9mIHRoZSBldmVudCBvYmplY3QgYW5kIG5vcm1hbGl6ZSBzb21lIHByb3BlcnRpZXNcblx0XHR2YXIgaSwgcHJvcCwgY29weSxcblx0XHRcdHR5cGUgPSBldmVudC50eXBlLFxuXHRcdFx0b3JpZ2luYWxFdmVudCA9IGV2ZW50LFxuXHRcdFx0Zml4SG9vayA9IHRoaXMuZml4SG9va3NbIHR5cGUgXTtcblxuXHRcdGlmICggIWZpeEhvb2sgKSB7XG5cdFx0XHR0aGlzLmZpeEhvb2tzWyB0eXBlIF0gPSBmaXhIb29rID1cblx0XHRcdFx0cm1vdXNlRXZlbnQudGVzdCggdHlwZSApID8gdGhpcy5tb3VzZUhvb2tzIDpcblx0XHRcdFx0cmtleUV2ZW50LnRlc3QoIHR5cGUgKSA/IHRoaXMua2V5SG9va3MgOlxuXHRcdFx0XHR7fTtcblx0XHR9XG5cdFx0Y29weSA9IGZpeEhvb2sucHJvcHMgPyB0aGlzLnByb3BzLmNvbmNhdCggZml4SG9vay5wcm9wcyApIDogdGhpcy5wcm9wcztcblxuXHRcdGV2ZW50ID0gbmV3IGpRdWVyeS5FdmVudCggb3JpZ2luYWxFdmVudCApO1xuXG5cdFx0aSA9IGNvcHkubGVuZ3RoO1xuXHRcdHdoaWxlICggaS0tICkge1xuXHRcdFx0cHJvcCA9IGNvcHlbIGkgXTtcblx0XHRcdGV2ZW50WyBwcm9wIF0gPSBvcmlnaW5hbEV2ZW50WyBwcm9wIF07XG5cdFx0fVxuXG5cdFx0Ly8gU3VwcG9ydDogQ29yZG92YSAyLjUgKFdlYktpdCkgKCMxMzI1NSlcblx0XHQvLyBBbGwgZXZlbnRzIHNob3VsZCBoYXZlIGEgdGFyZ2V0OyBDb3Jkb3ZhIGRldmljZXJlYWR5IGRvZXNuJ3Rcblx0XHRpZiAoICFldmVudC50YXJnZXQgKSB7XG5cdFx0XHRldmVudC50YXJnZXQgPSBkb2N1bWVudDtcblx0XHR9XG5cblx0XHQvLyBTdXBwb3J0OiBTYWZhcmkgNi4wKywgQ2hyb21lPDI4XG5cdFx0Ly8gVGFyZ2V0IHNob3VsZCBub3QgYmUgYSB0ZXh0IG5vZGUgKCM1MDQsICMxMzE0Mylcblx0XHRpZiAoIGV2ZW50LnRhcmdldC5ub2RlVHlwZSA9PT0gMyApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGV2ZW50LnRhcmdldC5wYXJlbnROb2RlO1xuXHRcdH1cblxuXHRcdHJldHVybiBmaXhIb29rLmZpbHRlciA/IGZpeEhvb2suZmlsdGVyKCBldmVudCwgb3JpZ2luYWxFdmVudCApIDogZXZlbnQ7XG5cdH0sXG5cblx0c3BlY2lhbDoge1xuXHRcdGxvYWQ6IHtcblxuXHRcdFx0Ly8gUHJldmVudCB0cmlnZ2VyZWQgaW1hZ2UubG9hZCBldmVudHMgZnJvbSBidWJibGluZyB0byB3aW5kb3cubG9hZFxuXHRcdFx0bm9CdWJibGU6IHRydWVcblx0XHR9LFxuXHRcdGZvY3VzOiB7XG5cblx0XHRcdC8vIEZpcmUgbmF0aXZlIGV2ZW50IGlmIHBvc3NpYmxlIHNvIGJsdXIvZm9jdXMgc2VxdWVuY2UgaXMgY29ycmVjdFxuXHRcdFx0dHJpZ2dlcjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggdGhpcyAhPT0gc2FmZUFjdGl2ZUVsZW1lbnQoKSAmJiB0aGlzLmZvY3VzICkge1xuXHRcdFx0XHRcdHRoaXMuZm9jdXMoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNpblwiXG5cdFx0fSxcblx0XHRibHVyOiB7XG5cdFx0XHR0cmlnZ2VyOiBmdW5jdGlvbigpIHtcblx0XHRcdFx0aWYgKCB0aGlzID09PSBzYWZlQWN0aXZlRWxlbWVudCgpICYmIHRoaXMuYmx1ciApIHtcblx0XHRcdFx0XHR0aGlzLmJsdXIoKTtcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdH1cblx0XHRcdH0sXG5cdFx0XHRkZWxlZ2F0ZVR5cGU6IFwiZm9jdXNvdXRcIlxuXHRcdH0sXG5cdFx0Y2xpY2s6IHtcblxuXHRcdFx0Ly8gRm9yIGNoZWNrYm94LCBmaXJlIG5hdGl2ZSBldmVudCBzbyBjaGVja2VkIHN0YXRlIHdpbGwgYmUgcmlnaHRcblx0XHRcdHRyaWdnZXI6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIHRoaXMudHlwZSA9PT0gXCJjaGVja2JveFwiICYmIHRoaXMuY2xpY2sgJiYgalF1ZXJ5Lm5vZGVOYW1lKCB0aGlzLCBcImlucHV0XCIgKSApIHtcblx0XHRcdFx0XHR0aGlzLmNsaWNrKCk7XG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHQvLyBGb3IgY3Jvc3MtYnJvd3NlciBjb25zaXN0ZW5jeSwgZG9uJ3QgZmlyZSBuYXRpdmUgLmNsaWNrKCkgb24gbGlua3Ncblx0XHRcdF9kZWZhdWx0OiBmdW5jdGlvbiggZXZlbnQgKSB7XG5cdFx0XHRcdHJldHVybiBqUXVlcnkubm9kZU5hbWUoIGV2ZW50LnRhcmdldCwgXCJhXCIgKTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0YmVmb3JldW5sb2FkOiB7XG5cdFx0XHRwb3N0RGlzcGF0Y2g6IGZ1bmN0aW9uKCBldmVudCApIHtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBGaXJlZm94IDIwK1xuXHRcdFx0XHQvLyBGaXJlZm94IGRvZXNuJ3QgYWxlcnQgaWYgdGhlIHJldHVyblZhbHVlIGZpZWxkIGlzIG5vdCBzZXQuXG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ICE9PSB1bmRlZmluZWQgJiYgZXZlbnQub3JpZ2luYWxFdmVudCApIHtcblx0XHRcdFx0XHRldmVudC5vcmlnaW5hbEV2ZW50LnJldHVyblZhbHVlID0gZXZlbnQucmVzdWx0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG59O1xuXG5qUXVlcnkucmVtb3ZlRXZlbnQgPSBmdW5jdGlvbiggZWxlbSwgdHlwZSwgaGFuZGxlICkge1xuXG5cdC8vIFRoaXMgXCJpZlwiIGlzIG5lZWRlZCBmb3IgcGxhaW4gb2JqZWN0c1xuXHRpZiAoIGVsZW0ucmVtb3ZlRXZlbnRMaXN0ZW5lciApIHtcblx0XHRlbGVtLnJlbW92ZUV2ZW50TGlzdGVuZXIoIHR5cGUsIGhhbmRsZSApO1xuXHR9XG59O1xuXG5qUXVlcnkuRXZlbnQgPSBmdW5jdGlvbiggc3JjLCBwcm9wcyApIHtcblxuXHQvLyBBbGxvdyBpbnN0YW50aWF0aW9uIHdpdGhvdXQgdGhlICduZXcnIGtleXdvcmRcblx0aWYgKCAhKCB0aGlzIGluc3RhbmNlb2YgalF1ZXJ5LkV2ZW50ICkgKSB7XG5cdFx0cmV0dXJuIG5ldyBqUXVlcnkuRXZlbnQoIHNyYywgcHJvcHMgKTtcblx0fVxuXG5cdC8vIEV2ZW50IG9iamVjdFxuXHRpZiAoIHNyYyAmJiBzcmMudHlwZSApIHtcblx0XHR0aGlzLm9yaWdpbmFsRXZlbnQgPSBzcmM7XG5cdFx0dGhpcy50eXBlID0gc3JjLnR5cGU7XG5cblx0XHQvLyBFdmVudHMgYnViYmxpbmcgdXAgdGhlIGRvY3VtZW50IG1heSBoYXZlIGJlZW4gbWFya2VkIGFzIHByZXZlbnRlZFxuXHRcdC8vIGJ5IGEgaGFuZGxlciBsb3dlciBkb3duIHRoZSB0cmVlOyByZWZsZWN0IHRoZSBjb3JyZWN0IHZhbHVlLlxuXHRcdHRoaXMuaXNEZWZhdWx0UHJldmVudGVkID0gc3JjLmRlZmF1bHRQcmV2ZW50ZWQgfHxcblx0XHRcdFx0c3JjLmRlZmF1bHRQcmV2ZW50ZWQgPT09IHVuZGVmaW5lZCAmJlxuXG5cdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4wXG5cdFx0XHRcdHNyYy5yZXR1cm5WYWx1ZSA9PT0gZmFsc2UgP1xuXHRcdFx0cmV0dXJuVHJ1ZSA6XG5cdFx0XHRyZXR1cm5GYWxzZTtcblxuXHQvLyBFdmVudCB0eXBlXG5cdH0gZWxzZSB7XG5cdFx0dGhpcy50eXBlID0gc3JjO1xuXHR9XG5cblx0Ly8gUHV0IGV4cGxpY2l0bHkgcHJvdmlkZWQgcHJvcGVydGllcyBvbnRvIHRoZSBldmVudCBvYmplY3Rcblx0aWYgKCBwcm9wcyApIHtcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aGlzLCBwcm9wcyApO1xuXHR9XG5cblx0Ly8gQ3JlYXRlIGEgdGltZXN0YW1wIGlmIGluY29taW5nIGV2ZW50IGRvZXNuJ3QgaGF2ZSBvbmVcblx0dGhpcy50aW1lU3RhbXAgPSBzcmMgJiYgc3JjLnRpbWVTdGFtcCB8fCBqUXVlcnkubm93KCk7XG5cblx0Ly8gTWFyayBpdCBhcyBmaXhlZFxuXHR0aGlzWyBqUXVlcnkuZXhwYW5kbyBdID0gdHJ1ZTtcbn07XG5cbi8vIGpRdWVyeS5FdmVudCBpcyBiYXNlZCBvbiBET00zIEV2ZW50cyBhcyBzcGVjaWZpZWQgYnkgdGhlIEVDTUFTY3JpcHQgTGFuZ3VhZ2UgQmluZGluZ1xuLy8gaHR0cDovL3d3dy53My5vcmcvVFIvMjAwMy9XRC1ET00tTGV2ZWwtMy1FdmVudHMtMjAwMzAzMzEvZWNtYS1zY3JpcHQtYmluZGluZy5odG1sXG5qUXVlcnkuRXZlbnQucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogalF1ZXJ5LkV2ZW50LFxuXHRpc0RlZmF1bHRQcmV2ZW50ZWQ6IHJldHVybkZhbHNlLFxuXHRpc1Byb3BhZ2F0aW9uU3RvcHBlZDogcmV0dXJuRmFsc2UsXG5cdGlzSW1tZWRpYXRlUHJvcGFnYXRpb25TdG9wcGVkOiByZXR1cm5GYWxzZSxcblxuXHRwcmV2ZW50RGVmYXVsdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGUgPSB0aGlzLm9yaWdpbmFsRXZlbnQ7XG5cblx0XHR0aGlzLmlzRGVmYXVsdFByZXZlbnRlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgKSB7XG5cdFx0XHRlLnByZXZlbnREZWZhdWx0KCk7XG5cdFx0fVxuXHR9LFxuXHRzdG9wUHJvcGFnYXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlID0gdGhpcy5vcmlnaW5hbEV2ZW50O1xuXG5cdFx0dGhpcy5pc1Byb3BhZ2F0aW9uU3RvcHBlZCA9IHJldHVyblRydWU7XG5cblx0XHRpZiAoIGUgKSB7XG5cdFx0XHRlLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdH1cblx0fSxcblx0c3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgZSA9IHRoaXMub3JpZ2luYWxFdmVudDtcblxuXHRcdHRoaXMuaXNJbW1lZGlhdGVQcm9wYWdhdGlvblN0b3BwZWQgPSByZXR1cm5UcnVlO1xuXG5cdFx0aWYgKCBlICkge1xuXHRcdFx0ZS5zdG9wSW1tZWRpYXRlUHJvcGFnYXRpb24oKTtcblx0XHR9XG5cblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHR9XG59O1xuXG4vLyBDcmVhdGUgbW91c2VlbnRlci9sZWF2ZSBldmVudHMgdXNpbmcgbW91c2VvdmVyL291dCBhbmQgZXZlbnQtdGltZSBjaGVja3Ncbi8vIHNvIHRoYXQgZXZlbnQgZGVsZWdhdGlvbiB3b3JrcyBpbiBqUXVlcnkuXG4vLyBEbyB0aGUgc2FtZSBmb3IgcG9pbnRlcmVudGVyL3BvaW50ZXJsZWF2ZSBhbmQgcG9pbnRlcm92ZXIvcG9pbnRlcm91dFxuLy9cbi8vIFN1cHBvcnQ6IFNhZmFyaSA3IG9ubHlcbi8vIFNhZmFyaSBzZW5kcyBtb3VzZWVudGVyIHRvbyBvZnRlbjsgc2VlOlxuLy8gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ3MDI1OFxuLy8gZm9yIHRoZSBkZXNjcmlwdGlvbiBvZiB0aGUgYnVnIChpdCBleGlzdGVkIGluIG9sZGVyIENocm9tZSB2ZXJzaW9ucyBhcyB3ZWxsKS5cbmpRdWVyeS5lYWNoKCB7XG5cdG1vdXNlZW50ZXI6IFwibW91c2VvdmVyXCIsXG5cdG1vdXNlbGVhdmU6IFwibW91c2VvdXRcIixcblx0cG9pbnRlcmVudGVyOiBcInBvaW50ZXJvdmVyXCIsXG5cdHBvaW50ZXJsZWF2ZTogXCJwb2ludGVyb3V0XCJcbn0sIGZ1bmN0aW9uKCBvcmlnLCBmaXggKSB7XG5cdGpRdWVyeS5ldmVudC5zcGVjaWFsWyBvcmlnIF0gPSB7XG5cdFx0ZGVsZWdhdGVUeXBlOiBmaXgsXG5cdFx0YmluZFR5cGU6IGZpeCxcblxuXHRcdGhhbmRsZTogZnVuY3Rpb24oIGV2ZW50ICkge1xuXHRcdFx0dmFyIHJldCxcblx0XHRcdFx0dGFyZ2V0ID0gdGhpcyxcblx0XHRcdFx0cmVsYXRlZCA9IGV2ZW50LnJlbGF0ZWRUYXJnZXQsXG5cdFx0XHRcdGhhbmRsZU9iaiA9IGV2ZW50LmhhbmRsZU9iajtcblxuXHRcdFx0Ly8gRm9yIG1vdXNlZW50ZXIvbGVhdmUgY2FsbCB0aGUgaGFuZGxlciBpZiByZWxhdGVkIGlzIG91dHNpZGUgdGhlIHRhcmdldC5cblx0XHRcdC8vIE5COiBObyByZWxhdGVkVGFyZ2V0IGlmIHRoZSBtb3VzZSBsZWZ0L2VudGVyZWQgdGhlIGJyb3dzZXIgd2luZG93XG5cdFx0XHRpZiAoICFyZWxhdGVkIHx8ICggcmVsYXRlZCAhPT0gdGFyZ2V0ICYmICFqUXVlcnkuY29udGFpbnMoIHRhcmdldCwgcmVsYXRlZCApICkgKSB7XG5cdFx0XHRcdGV2ZW50LnR5cGUgPSBoYW5kbGVPYmoub3JpZ1R5cGU7XG5cdFx0XHRcdHJldCA9IGhhbmRsZU9iai5oYW5kbGVyLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHRcdFx0ZXZlbnQudHlwZSA9IGZpeDtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdG9uOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4gKTtcblx0fSxcblx0b25lOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gb24oIHRoaXMsIHR5cGVzLCBzZWxlY3RvciwgZGF0YSwgZm4sIDEgKTtcblx0fSxcblx0b2ZmOiBmdW5jdGlvbiggdHlwZXMsIHNlbGVjdG9yLCBmbiApIHtcblx0XHR2YXIgaGFuZGxlT2JqLCB0eXBlO1xuXHRcdGlmICggdHlwZXMgJiYgdHlwZXMucHJldmVudERlZmF1bHQgJiYgdHlwZXMuaGFuZGxlT2JqICkge1xuXG5cdFx0XHQvLyAoIGV2ZW50ICkgIGRpc3BhdGNoZWQgalF1ZXJ5LkV2ZW50XG5cdFx0XHRoYW5kbGVPYmogPSB0eXBlcy5oYW5kbGVPYmo7XG5cdFx0XHRqUXVlcnkoIHR5cGVzLmRlbGVnYXRlVGFyZ2V0ICkub2ZmKFxuXHRcdFx0XHRoYW5kbGVPYmoubmFtZXNwYWNlID9cblx0XHRcdFx0XHRoYW5kbGVPYmoub3JpZ1R5cGUgKyBcIi5cIiArIGhhbmRsZU9iai5uYW1lc3BhY2UgOlxuXHRcdFx0XHRcdGhhbmRsZU9iai5vcmlnVHlwZSxcblx0XHRcdFx0aGFuZGxlT2JqLnNlbGVjdG9yLFxuXHRcdFx0XHRoYW5kbGVPYmouaGFuZGxlclxuXHRcdFx0KTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH1cblx0XHRpZiAoIHR5cGVvZiB0eXBlcyA9PT0gXCJvYmplY3RcIiApIHtcblxuXHRcdFx0Ly8gKCB0eXBlcy1vYmplY3QgWywgc2VsZWN0b3JdIClcblx0XHRcdGZvciAoIHR5cGUgaW4gdHlwZXMgKSB7XG5cdFx0XHRcdHRoaXMub2ZmKCB0eXBlLCBzZWxlY3RvciwgdHlwZXNbIHR5cGUgXSApO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0fVxuXHRcdGlmICggc2VsZWN0b3IgPT09IGZhbHNlIHx8IHR5cGVvZiBzZWxlY3RvciA9PT0gXCJmdW5jdGlvblwiICkge1xuXG5cdFx0XHQvLyAoIHR5cGVzIFssIGZuXSApXG5cdFx0XHRmbiA9IHNlbGVjdG9yO1xuXHRcdFx0c2VsZWN0b3IgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmICggZm4gPT09IGZhbHNlICkge1xuXHRcdFx0Zm4gPSByZXR1cm5GYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQucmVtb3ZlKCB0aGlzLCB0eXBlcywgZm4sIHNlbGVjdG9yICk7XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cblxudmFyXG5cdHJ4aHRtbFRhZyA9IC88KD8hYXJlYXxicnxjb2x8ZW1iZWR8aHJ8aW1nfGlucHV0fGxpbmt8bWV0YXxwYXJhbSkoKFtcXHc6LV0rKVtePl0qKVxcLz4vZ2ksXG5cblx0Ly8gU3VwcG9ydDogSUUgMTAtMTEsIEVkZ2UgMTAyNDArXG5cdC8vIEluIElFL0VkZ2UgdXNpbmcgcmVnZXggZ3JvdXBzIGhlcmUgY2F1c2VzIHNldmVyZSBzbG93ZG93bnMuXG5cdC8vIFNlZSBodHRwczovL2Nvbm5lY3QubWljcm9zb2Z0LmNvbS9JRS9mZWVkYmFjay9kZXRhaWxzLzE3MzY1MTIvXG5cdHJub0lubmVyaHRtbCA9IC88c2NyaXB0fDxzdHlsZXw8bGluay9pLFxuXG5cdC8vIGNoZWNrZWQ9XCJjaGVja2VkXCIgb3IgY2hlY2tlZFxuXHRyY2hlY2tlZCA9IC9jaGVja2VkXFxzKig/OltePV18PVxccyouY2hlY2tlZC4pL2ksXG5cdHJzY3JpcHRUeXBlTWFza2VkID0gL150cnVlXFwvKC4qKS8sXG5cdHJjbGVhblNjcmlwdCA9IC9eXFxzKjwhKD86XFxbQ0RBVEFcXFt8LS0pfCg/OlxcXVxcXXwtLSk+XFxzKiQvZztcblxuZnVuY3Rpb24gbWFuaXB1bGF0aW9uVGFyZ2V0KCBlbGVtLCBjb250ZW50ICkge1xuXHRpZiAoIGpRdWVyeS5ub2RlTmFtZSggZWxlbSwgXCJ0YWJsZVwiICkgJiZcblx0XHRqUXVlcnkubm9kZU5hbWUoIGNvbnRlbnQubm9kZVR5cGUgIT09IDExID8gY29udGVudCA6IGNvbnRlbnQuZmlyc3RDaGlsZCwgXCJ0clwiICkgKSB7XG5cblx0XHRyZXR1cm4gZWxlbS5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJ0Ym9keVwiIClbIDAgXSB8fCBlbGVtO1xuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbi8vIFJlcGxhY2UvcmVzdG9yZSB0aGUgdHlwZSBhdHRyaWJ1dGUgb2Ygc2NyaXB0IGVsZW1lbnRzIGZvciBzYWZlIERPTSBtYW5pcHVsYXRpb25cbmZ1bmN0aW9uIGRpc2FibGVTY3JpcHQoIGVsZW0gKSB7XG5cdGVsZW0udHlwZSA9ICggZWxlbS5nZXRBdHRyaWJ1dGUoIFwidHlwZVwiICkgIT09IG51bGwgKSArIFwiL1wiICsgZWxlbS50eXBlO1xuXHRyZXR1cm4gZWxlbTtcbn1cbmZ1bmN0aW9uIHJlc3RvcmVTY3JpcHQoIGVsZW0gKSB7XG5cdHZhciBtYXRjaCA9IHJzY3JpcHRUeXBlTWFza2VkLmV4ZWMoIGVsZW0udHlwZSApO1xuXG5cdGlmICggbWF0Y2ggKSB7XG5cdFx0ZWxlbS50eXBlID0gbWF0Y2hbIDEgXTtcblx0fSBlbHNlIHtcblx0XHRlbGVtLnJlbW92ZUF0dHJpYnV0ZSggXCJ0eXBlXCIgKTtcblx0fVxuXG5cdHJldHVybiBlbGVtO1xufVxuXG5mdW5jdGlvbiBjbG9uZUNvcHlFdmVudCggc3JjLCBkZXN0ICkge1xuXHR2YXIgaSwgbCwgdHlwZSwgcGRhdGFPbGQsIHBkYXRhQ3VyLCB1ZGF0YU9sZCwgdWRhdGFDdXIsIGV2ZW50cztcblxuXHRpZiAoIGRlc3Qubm9kZVR5cGUgIT09IDEgKSB7XG5cdFx0cmV0dXJuO1xuXHR9XG5cblx0Ly8gMS4gQ29weSBwcml2YXRlIGRhdGE6IGV2ZW50cywgaGFuZGxlcnMsIGV0Yy5cblx0aWYgKCBkYXRhUHJpdi5oYXNEYXRhKCBzcmMgKSApIHtcblx0XHRwZGF0YU9sZCA9IGRhdGFQcml2LmFjY2Vzcyggc3JjICk7XG5cdFx0cGRhdGFDdXIgPSBkYXRhUHJpdi5zZXQoIGRlc3QsIHBkYXRhT2xkICk7XG5cdFx0ZXZlbnRzID0gcGRhdGFPbGQuZXZlbnRzO1xuXG5cdFx0aWYgKCBldmVudHMgKSB7XG5cdFx0XHRkZWxldGUgcGRhdGFDdXIuaGFuZGxlO1xuXHRcdFx0cGRhdGFDdXIuZXZlbnRzID0ge307XG5cblx0XHRcdGZvciAoIHR5cGUgaW4gZXZlbnRzICkge1xuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IGV2ZW50c1sgdHlwZSBdLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQuYWRkKCBkZXN0LCB0eXBlLCBldmVudHNbIHR5cGUgXVsgaSBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHQvLyAyLiBDb3B5IHVzZXIgZGF0YVxuXHRpZiAoIGRhdGFVc2VyLmhhc0RhdGEoIHNyYyApICkge1xuXHRcdHVkYXRhT2xkID0gZGF0YVVzZXIuYWNjZXNzKCBzcmMgKTtcblx0XHR1ZGF0YUN1ciA9IGpRdWVyeS5leHRlbmQoIHt9LCB1ZGF0YU9sZCApO1xuXG5cdFx0ZGF0YVVzZXIuc2V0KCBkZXN0LCB1ZGF0YUN1ciApO1xuXHR9XG59XG5cbi8vIEZpeCBJRSBidWdzLCBzZWUgc3VwcG9ydCB0ZXN0c1xuZnVuY3Rpb24gZml4SW5wdXQoIHNyYywgZGVzdCApIHtcblx0dmFyIG5vZGVOYW1lID0gZGVzdC5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpO1xuXG5cdC8vIEZhaWxzIHRvIHBlcnNpc3QgdGhlIGNoZWNrZWQgc3RhdGUgb2YgYSBjbG9uZWQgY2hlY2tib3ggb3IgcmFkaW8gYnV0dG9uLlxuXHRpZiAoIG5vZGVOYW1lID09PSBcImlucHV0XCIgJiYgcmNoZWNrYWJsZVR5cGUudGVzdCggc3JjLnR5cGUgKSApIHtcblx0XHRkZXN0LmNoZWNrZWQgPSBzcmMuY2hlY2tlZDtcblxuXHQvLyBGYWlscyB0byByZXR1cm4gdGhlIHNlbGVjdGVkIG9wdGlvbiB0byB0aGUgZGVmYXVsdCBzZWxlY3RlZCBzdGF0ZSB3aGVuIGNsb25pbmcgb3B0aW9uc1xuXHR9IGVsc2UgaWYgKCBub2RlTmFtZSA9PT0gXCJpbnB1dFwiIHx8IG5vZGVOYW1lID09PSBcInRleHRhcmVhXCIgKSB7XG5cdFx0ZGVzdC5kZWZhdWx0VmFsdWUgPSBzcmMuZGVmYXVsdFZhbHVlO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGRvbU1hbmlwKCBjb2xsZWN0aW9uLCBhcmdzLCBjYWxsYmFjaywgaWdub3JlZCApIHtcblxuXHQvLyBGbGF0dGVuIGFueSBuZXN0ZWQgYXJyYXlzXG5cdGFyZ3MgPSBjb25jYXQuYXBwbHkoIFtdLCBhcmdzICk7XG5cblx0dmFyIGZyYWdtZW50LCBmaXJzdCwgc2NyaXB0cywgaGFzU2NyaXB0cywgbm9kZSwgZG9jLFxuXHRcdGkgPSAwLFxuXHRcdGwgPSBjb2xsZWN0aW9uLmxlbmd0aCxcblx0XHRpTm9DbG9uZSA9IGwgLSAxLFxuXHRcdHZhbHVlID0gYXJnc1sgMCBdLFxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHQvLyBXZSBjYW4ndCBjbG9uZU5vZGUgZnJhZ21lbnRzIHRoYXQgY29udGFpbiBjaGVja2VkLCBpbiBXZWJLaXRcblx0aWYgKCBpc0Z1bmN0aW9uIHx8XG5cdFx0XHQoIGwgPiAxICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQhc3VwcG9ydC5jaGVja0Nsb25lICYmIHJjaGVja2VkLnRlc3QoIHZhbHVlICkgKSApIHtcblx0XHRyZXR1cm4gY29sbGVjdGlvbi5lYWNoKCBmdW5jdGlvbiggaW5kZXggKSB7XG5cdFx0XHR2YXIgc2VsZiA9IGNvbGxlY3Rpb24uZXEoIGluZGV4ICk7XG5cdFx0XHRpZiAoIGlzRnVuY3Rpb24gKSB7XG5cdFx0XHRcdGFyZ3NbIDAgXSA9IHZhbHVlLmNhbGwoIHRoaXMsIGluZGV4LCBzZWxmLmh0bWwoKSApO1xuXHRcdFx0fVxuXHRcdFx0ZG9tTWFuaXAoIHNlbGYsIGFyZ3MsIGNhbGxiYWNrLCBpZ25vcmVkICk7XG5cdFx0fSApO1xuXHR9XG5cblx0aWYgKCBsICkge1xuXHRcdGZyYWdtZW50ID0gYnVpbGRGcmFnbWVudCggYXJncywgY29sbGVjdGlvblsgMCBdLm93bmVyRG9jdW1lbnQsIGZhbHNlLCBjb2xsZWN0aW9uLCBpZ25vcmVkICk7XG5cdFx0Zmlyc3QgPSBmcmFnbWVudC5maXJzdENoaWxkO1xuXG5cdFx0aWYgKCBmcmFnbWVudC5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMSApIHtcblx0XHRcdGZyYWdtZW50ID0gZmlyc3Q7XG5cdFx0fVxuXG5cdFx0Ly8gUmVxdWlyZSBlaXRoZXIgbmV3IGNvbnRlbnQgb3IgYW4gaW50ZXJlc3QgaW4gaWdub3JlZCBlbGVtZW50cyB0byBpbnZva2UgdGhlIGNhbGxiYWNrXG5cdFx0aWYgKCBmaXJzdCB8fCBpZ25vcmVkICkge1xuXHRcdFx0c2NyaXB0cyA9IGpRdWVyeS5tYXAoIGdldEFsbCggZnJhZ21lbnQsIFwic2NyaXB0XCIgKSwgZGlzYWJsZVNjcmlwdCApO1xuXHRcdFx0aGFzU2NyaXB0cyA9IHNjcmlwdHMubGVuZ3RoO1xuXG5cdFx0XHQvLyBVc2UgdGhlIG9yaWdpbmFsIGZyYWdtZW50IGZvciB0aGUgbGFzdCBpdGVtXG5cdFx0XHQvLyBpbnN0ZWFkIG9mIHRoZSBmaXJzdCBiZWNhdXNlIGl0IGNhbiBlbmQgdXBcblx0XHRcdC8vIGJlaW5nIGVtcHRpZWQgaW5jb3JyZWN0bHkgaW4gY2VydGFpbiBzaXR1YXRpb25zICgjODA3MCkuXG5cdFx0XHRmb3IgKCA7IGkgPCBsOyBpKysgKSB7XG5cdFx0XHRcdG5vZGUgPSBmcmFnbWVudDtcblxuXHRcdFx0XHRpZiAoIGkgIT09IGlOb0Nsb25lICkge1xuXHRcdFx0XHRcdG5vZGUgPSBqUXVlcnkuY2xvbmUoIG5vZGUsIHRydWUsIHRydWUgKTtcblxuXHRcdFx0XHRcdC8vIEtlZXAgcmVmZXJlbmNlcyB0byBjbG9uZWQgc2NyaXB0cyBmb3IgbGF0ZXIgcmVzdG9yYXRpb25cblx0XHRcdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8NC4xLCBQaGFudG9tSlM8MlxuXHRcdFx0XHRcdFx0Ly8gcHVzaC5hcHBseShfLCBhcnJheWxpa2UpIHRocm93cyBvbiBhbmNpZW50IFdlYktpdFxuXHRcdFx0XHRcdFx0alF1ZXJ5Lm1lcmdlKCBzY3JpcHRzLCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhbGxiYWNrLmNhbGwoIGNvbGxlY3Rpb25bIGkgXSwgbm9kZSwgaSApO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoIGhhc1NjcmlwdHMgKSB7XG5cdFx0XHRcdGRvYyA9IHNjcmlwdHNbIHNjcmlwdHMubGVuZ3RoIC0gMSBdLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRcdFx0Ly8gUmVlbmFibGUgc2NyaXB0c1xuXHRcdFx0XHRqUXVlcnkubWFwKCBzY3JpcHRzLCByZXN0b3JlU2NyaXB0ICk7XG5cblx0XHRcdFx0Ly8gRXZhbHVhdGUgZXhlY3V0YWJsZSBzY3JpcHRzIG9uIGZpcnN0IGRvY3VtZW50IGluc2VydGlvblxuXHRcdFx0XHRmb3IgKCBpID0gMDsgaSA8IGhhc1NjcmlwdHM7IGkrKyApIHtcblx0XHRcdFx0XHRub2RlID0gc2NyaXB0c1sgaSBdO1xuXHRcdFx0XHRcdGlmICggcnNjcmlwdFR5cGUudGVzdCggbm9kZS50eXBlIHx8IFwiXCIgKSAmJlxuXHRcdFx0XHRcdFx0IWRhdGFQcml2LmFjY2Vzcyggbm9kZSwgXCJnbG9iYWxFdmFsXCIgKSAmJlxuXHRcdFx0XHRcdFx0alF1ZXJ5LmNvbnRhaW5zKCBkb2MsIG5vZGUgKSApIHtcblxuXHRcdFx0XHRcdFx0aWYgKCBub2RlLnNyYyApIHtcblxuXHRcdFx0XHRcdFx0XHQvLyBPcHRpb25hbCBBSkFYIGRlcGVuZGVuY3ksIGJ1dCB3b24ndCBydW4gc2NyaXB0cyBpZiBub3QgcHJlc2VudFxuXHRcdFx0XHRcdFx0XHRpZiAoIGpRdWVyeS5fZXZhbFVybCApIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkuX2V2YWxVcmwoIG5vZGUuc3JjICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCBub2RlLnRleHRDb250ZW50LnJlcGxhY2UoIHJjbGVhblNjcmlwdCwgXCJcIiApICk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGNvbGxlY3Rpb247XG59XG5cbmZ1bmN0aW9uIHJlbW92ZSggZWxlbSwgc2VsZWN0b3IsIGtlZXBEYXRhICkge1xuXHR2YXIgbm9kZSxcblx0XHRub2RlcyA9IHNlbGVjdG9yID8galF1ZXJ5LmZpbHRlciggc2VsZWN0b3IsIGVsZW0gKSA6IGVsZW0sXG5cdFx0aSA9IDA7XG5cblx0Zm9yICggOyAoIG5vZGUgPSBub2Rlc1sgaSBdICkgIT0gbnVsbDsgaSsrICkge1xuXHRcdGlmICggIWtlZXBEYXRhICYmIG5vZGUubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIG5vZGUgKSApO1xuXHRcdH1cblxuXHRcdGlmICggbm9kZS5wYXJlbnROb2RlICkge1xuXHRcdFx0aWYgKCBrZWVwRGF0YSAmJiBqUXVlcnkuY29udGFpbnMoIG5vZGUub3duZXJEb2N1bWVudCwgbm9kZSApICkge1xuXHRcdFx0XHRzZXRHbG9iYWxFdmFsKCBnZXRBbGwoIG5vZGUsIFwic2NyaXB0XCIgKSApO1xuXHRcdFx0fVxuXHRcdFx0bm9kZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKCBub2RlICk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGVsZW07XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0aHRtbFByZWZpbHRlcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0cmV0dXJuIGh0bWwucmVwbGFjZSggcnhodG1sVGFnLCBcIjwkMT48LyQyPlwiICk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCBlbGVtLCBkYXRhQW5kRXZlbnRzLCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHR2YXIgaSwgbCwgc3JjRWxlbWVudHMsIGRlc3RFbGVtZW50cyxcblx0XHRcdGNsb25lID0gZWxlbS5jbG9uZU5vZGUoIHRydWUgKSxcblx0XHRcdGluUGFnZSA9IGpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICk7XG5cblx0XHQvLyBGaXggSUUgY2xvbmluZyBpc3N1ZXNcblx0XHRpZiAoICFzdXBwb3J0Lm5vQ2xvbmVDaGVja2VkICYmICggZWxlbS5ub2RlVHlwZSA9PT0gMSB8fCBlbGVtLm5vZGVUeXBlID09PSAxMSApICYmXG5cdFx0XHRcdCFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblxuXHRcdFx0Ly8gV2UgZXNjaGV3IFNpenpsZSBoZXJlIGZvciBwZXJmb3JtYW5jZSByZWFzb25zOiBodHRwOi8vanNwZXJmLmNvbS9nZXRhbGwtdnMtc2l6emxlLzJcblx0XHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUgKTtcblx0XHRcdHNyY0VsZW1lbnRzID0gZ2V0QWxsKCBlbGVtICk7XG5cblx0XHRcdGZvciAoIGkgPSAwLCBsID0gc3JjRWxlbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRmaXhJbnB1dCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb3B5IHRoZSBldmVudHMgZnJvbSB0aGUgb3JpZ2luYWwgdG8gdGhlIGNsb25lXG5cdFx0aWYgKCBkYXRhQW5kRXZlbnRzICkge1xuXHRcdFx0aWYgKCBkZWVwRGF0YUFuZEV2ZW50cyApIHtcblx0XHRcdFx0c3JjRWxlbWVudHMgPSBzcmNFbGVtZW50cyB8fCBnZXRBbGwoIGVsZW0gKTtcblx0XHRcdFx0ZGVzdEVsZW1lbnRzID0gZGVzdEVsZW1lbnRzIHx8IGdldEFsbCggY2xvbmUgKTtcblxuXHRcdFx0XHRmb3IgKCBpID0gMCwgbCA9IHNyY0VsZW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKyApIHtcblx0XHRcdFx0XHRjbG9uZUNvcHlFdmVudCggc3JjRWxlbWVudHNbIGkgXSwgZGVzdEVsZW1lbnRzWyBpIF0gKTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2xvbmVDb3B5RXZlbnQoIGVsZW0sIGNsb25lICk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Ly8gUHJlc2VydmUgc2NyaXB0IGV2YWx1YXRpb24gaGlzdG9yeVxuXHRcdGRlc3RFbGVtZW50cyA9IGdldEFsbCggY2xvbmUsIFwic2NyaXB0XCIgKTtcblx0XHRpZiAoIGRlc3RFbGVtZW50cy5sZW5ndGggPiAwICkge1xuXHRcdFx0c2V0R2xvYmFsRXZhbCggZGVzdEVsZW1lbnRzLCAhaW5QYWdlICYmIGdldEFsbCggZWxlbSwgXCJzY3JpcHRcIiApICk7XG5cdFx0fVxuXG5cdFx0Ly8gUmV0dXJuIHRoZSBjbG9uZWQgc2V0XG5cdFx0cmV0dXJuIGNsb25lO1xuXHR9LFxuXG5cdGNsZWFuRGF0YTogZnVuY3Rpb24oIGVsZW1zICkge1xuXHRcdHZhciBkYXRhLCBlbGVtLCB0eXBlLFxuXHRcdFx0c3BlY2lhbCA9IGpRdWVyeS5ldmVudC5zcGVjaWFsLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IGVsZW1zWyBpIF0gKSAhPT0gdW5kZWZpbmVkOyBpKysgKSB7XG5cdFx0XHRpZiAoIGFjY2VwdERhdGEoIGVsZW0gKSApIHtcblx0XHRcdFx0aWYgKCAoIGRhdGEgPSBlbGVtWyBkYXRhUHJpdi5leHBhbmRvIF0gKSApIHtcblx0XHRcdFx0XHRpZiAoIGRhdGEuZXZlbnRzICkge1xuXHRcdFx0XHRcdFx0Zm9yICggdHlwZSBpbiBkYXRhLmV2ZW50cyApIHtcblx0XHRcdFx0XHRcdFx0aWYgKCBzcGVjaWFsWyB0eXBlIF0gKSB7XG5cdFx0XHRcdFx0XHRcdFx0alF1ZXJ5LmV2ZW50LnJlbW92ZSggZWxlbSwgdHlwZSApO1xuXG5cdFx0XHRcdFx0XHRcdC8vIFRoaXMgaXMgYSBzaG9ydGN1dCB0byBhdm9pZCBqUXVlcnkuZXZlbnQucmVtb3ZlJ3Mgb3ZlcmhlYWRcblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRqUXVlcnkucmVtb3ZlRXZlbnQoIGVsZW0sIHR5cGUsIGRhdGEuaGFuZGxlICk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBTdXBwb3J0OiBDaHJvbWUgPD0gMzUtNDUrXG5cdFx0XHRcdFx0Ly8gQXNzaWduIHVuZGVmaW5lZCBpbnN0ZWFkIG9mIHVzaW5nIGRlbGV0ZSwgc2VlIERhdGEjcmVtb3ZlXG5cdFx0XHRcdFx0ZWxlbVsgZGF0YVByaXYuZXhwYW5kbyBdID0gdW5kZWZpbmVkO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICggZWxlbVsgZGF0YVVzZXIuZXhwYW5kbyBdICkge1xuXG5cdFx0XHRcdFx0Ly8gU3VwcG9ydDogQ2hyb21lIDw9IDM1LTQ1K1xuXHRcdFx0XHRcdC8vIEFzc2lnbiB1bmRlZmluZWQgaW5zdGVhZCBvZiB1c2luZyBkZWxldGUsIHNlZSBEYXRhI3JlbW92ZVxuXHRcdFx0XHRcdGVsZW1bIGRhdGFVc2VyLmV4cGFuZG8gXSA9IHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cblx0Ly8gS2VlcCBkb21NYW5pcCBleHBvc2VkIHVudGlsIDMuMCAoZ2gtMjIyNSlcblx0ZG9tTWFuaXA6IGRvbU1hbmlwLFxuXG5cdGRldGFjaDogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHJldHVybiByZW1vdmUoIHRoaXMsIHNlbGVjdG9yLCB0cnVlICk7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbiggc2VsZWN0b3IgKSB7XG5cdFx0cmV0dXJuIHJlbW92ZSggdGhpcywgc2VsZWN0b3IgKTtcblx0fSxcblxuXHR0ZXh0OiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0cmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHRqUXVlcnkudGV4dCggdGhpcyApIDpcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdGlmICggdGhpcy5ub2RlVHlwZSA9PT0gMSB8fCB0aGlzLm5vZGVUeXBlID09PSAxMSB8fCB0aGlzLm5vZGVUeXBlID09PSA5ICkge1xuXHRcdFx0XHRcdFx0dGhpcy50ZXh0Q29udGVudCA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSApO1xuXHRcdH0sIG51bGwsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoICk7XG5cdH0sXG5cblx0YXBwZW5kOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMubm9kZVR5cGUgPT09IDEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gMTEgfHwgdGhpcy5ub2RlVHlwZSA9PT0gOSApIHtcblx0XHRcdFx0dmFyIHRhcmdldCA9IG1hbmlwdWxhdGlvblRhcmdldCggdGhpcywgZWxlbSApO1xuXHRcdFx0XHR0YXJnZXQuYXBwZW5kQ2hpbGQoIGVsZW0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0cHJlcGVuZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlID09PSAxIHx8IHRoaXMubm9kZVR5cGUgPT09IDExIHx8IHRoaXMubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdHZhciB0YXJnZXQgPSBtYW5pcHVsYXRpb25UYXJnZXQoIHRoaXMsIGVsZW0gKTtcblx0XHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZSggZWxlbSwgdGFyZ2V0LmZpcnN0Q2hpbGQgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0YmVmb3JlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZG9tTWFuaXAoIHRoaXMsIGFyZ3VtZW50cywgZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRpZiAoIHRoaXMucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0dGhpcy5wYXJlbnROb2RlLmluc2VydEJlZm9yZSggZWxlbSwgdGhpcyApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRhZnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0aWYgKCB0aGlzLnBhcmVudE5vZGUgKSB7XG5cdFx0XHRcdHRoaXMucGFyZW50Tm9kZS5pbnNlcnRCZWZvcmUoIGVsZW0sIHRoaXMubmV4dFNpYmxpbmcgKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH0sXG5cblx0ZW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBlbGVtLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRmb3IgKCA7ICggZWxlbSA9IHRoaXNbIGkgXSApICE9IG51bGw7IGkrKyApIHtcblx0XHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSApIHtcblxuXHRcdFx0XHQvLyBQcmV2ZW50IG1lbW9yeSBsZWFrc1xuXHRcdFx0XHRqUXVlcnkuY2xlYW5EYXRhKCBnZXRBbGwoIGVsZW0sIGZhbHNlICkgKTtcblxuXHRcdFx0XHQvLyBSZW1vdmUgYW55IHJlbWFpbmluZyBub2Rlc1xuXHRcdFx0XHRlbGVtLnRleHRDb250ZW50ID0gXCJcIjtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICkge1xuXHRcdGRhdGFBbmRFdmVudHMgPSBkYXRhQW5kRXZlbnRzID09IG51bGwgPyBmYWxzZSA6IGRhdGFBbmRFdmVudHM7XG5cdFx0ZGVlcERhdGFBbmRFdmVudHMgPSBkZWVwRGF0YUFuZEV2ZW50cyA9PSBudWxsID8gZGF0YUFuZEV2ZW50cyA6IGRlZXBEYXRhQW5kRXZlbnRzO1xuXG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBqUXVlcnkuY2xvbmUoIHRoaXMsIGRhdGFBbmRFdmVudHMsIGRlZXBEYXRhQW5kRXZlbnRzICk7XG5cdFx0fSApO1xuXHR9LFxuXG5cdGh0bWw6IGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0XHR2YXIgZWxlbSA9IHRoaXNbIDAgXSB8fCB7fSxcblx0XHRcdFx0aSA9IDAsXG5cdFx0XHRcdGwgPSB0aGlzLmxlbmd0aDtcblxuXHRcdFx0aWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkICYmIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdHJldHVybiBlbGVtLmlubmVySFRNTDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gU2VlIGlmIHdlIGNhbiB0YWtlIGEgc2hvcnRjdXQgYW5kIGp1c3QgdXNlIGlubmVySFRNTFxuXHRcdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgIXJub0lubmVyaHRtbC50ZXN0KCB2YWx1ZSApICYmXG5cdFx0XHRcdCF3cmFwTWFwWyAoIHJ0YWdOYW1lLmV4ZWMoIHZhbHVlICkgfHwgWyBcIlwiLCBcIlwiIF0gKVsgMSBdLnRvTG93ZXJDYXNlKCkgXSApIHtcblxuXHRcdFx0XHR2YWx1ZSA9IGpRdWVyeS5odG1sUHJlZmlsdGVyKCB2YWx1ZSApO1xuXG5cdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0Zm9yICggOyBpIDwgbDsgaSsrICkge1xuXHRcdFx0XHRcdFx0ZWxlbSA9IHRoaXNbIGkgXSB8fCB7fTtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlIGVsZW1lbnQgbm9kZXMgYW5kIHByZXZlbnQgbWVtb3J5IGxlYWtzXG5cdFx0XHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgKSB7XG5cdFx0XHRcdFx0XHRcdGpRdWVyeS5jbGVhbkRhdGEoIGdldEFsbCggZWxlbSwgZmFsc2UgKSApO1xuXHRcdFx0XHRcdFx0XHRlbGVtLmlubmVySFRNTCA9IHZhbHVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGVsZW0gPSAwO1xuXG5cdFx0XHRcdC8vIElmIHVzaW5nIGlubmVySFRNTCB0aHJvd3MgYW4gZXhjZXB0aW9uLCB1c2UgdGhlIGZhbGxiYWNrIG1ldGhvZFxuXHRcdFx0XHR9IGNhdGNoICggZSApIHt9XG5cdFx0XHR9XG5cblx0XHRcdGlmICggZWxlbSApIHtcblx0XHRcdFx0dGhpcy5lbXB0eSgpLmFwcGVuZCggdmFsdWUgKTtcblx0XHRcdH1cblx0XHR9LCBudWxsLCB2YWx1ZSwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaWdub3JlZCA9IFtdO1xuXG5cdFx0Ly8gTWFrZSB0aGUgY2hhbmdlcywgcmVwbGFjaW5nIGVhY2ggbm9uLWlnbm9yZWQgY29udGV4dCBlbGVtZW50IHdpdGggdGhlIG5ldyBjb250ZW50XG5cdFx0cmV0dXJuIGRvbU1hbmlwKCB0aGlzLCBhcmd1bWVudHMsIGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMucGFyZW50Tm9kZTtcblxuXHRcdFx0aWYgKCBqUXVlcnkuaW5BcnJheSggdGhpcywgaWdub3JlZCApIDwgMCApIHtcblx0XHRcdFx0alF1ZXJ5LmNsZWFuRGF0YSggZ2V0QWxsKCB0aGlzICkgKTtcblx0XHRcdFx0aWYgKCBwYXJlbnQgKSB7XG5cdFx0XHRcdFx0cGFyZW50LnJlcGxhY2VDaGlsZCggZWxlbSwgdGhpcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHQvLyBGb3JjZSBjYWxsYmFjayBpbnZvY2F0aW9uXG5cdFx0fSwgaWdub3JlZCApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5lYWNoKCB7XG5cdGFwcGVuZFRvOiBcImFwcGVuZFwiLFxuXHRwcmVwZW5kVG86IFwicHJlcGVuZFwiLFxuXHRpbnNlcnRCZWZvcmU6IFwiYmVmb3JlXCIsXG5cdGluc2VydEFmdGVyOiBcImFmdGVyXCIsXG5cdHJlcGxhY2VBbGw6IFwicmVwbGFjZVdpdGhcIlxufSwgZnVuY3Rpb24oIG5hbWUsIG9yaWdpbmFsICkge1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzZWxlY3RvciApIHtcblx0XHR2YXIgZWxlbXMsXG5cdFx0XHRyZXQgPSBbXSxcblx0XHRcdGluc2VydCA9IGpRdWVyeSggc2VsZWN0b3IgKSxcblx0XHRcdGxhc3QgPSBpbnNlcnQubGVuZ3RoIC0gMSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0Zm9yICggOyBpIDw9IGxhc3Q7IGkrKyApIHtcblx0XHRcdGVsZW1zID0gaSA9PT0gbGFzdCA/IHRoaXMgOiB0aGlzLmNsb25lKCB0cnVlICk7XG5cdFx0XHRqUXVlcnkoIGluc2VydFsgaSBdIClbIG9yaWdpbmFsIF0oIGVsZW1zICk7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IFF0V2ViS2l0XG5cdFx0XHQvLyAuZ2V0KCkgYmVjYXVzZSBwdXNoLmFwcGx5KF8sIGFycmF5bGlrZSkgdGhyb3dzXG5cdFx0XHRwdXNoLmFwcGx5KCByZXQsIGVsZW1zLmdldCgpICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMucHVzaFN0YWNrKCByZXQgKTtcblx0fTtcbn0gKTtcblxuXG52YXIgaWZyYW1lLFxuXHRlbGVtZGlzcGxheSA9IHtcblxuXHRcdC8vIFN1cHBvcnQ6IEZpcmVmb3hcblx0XHQvLyBXZSBoYXZlIHRvIHByZS1kZWZpbmUgdGhlc2UgdmFsdWVzIGZvciBGRiAoIzEwMjI3KVxuXHRcdEhUTUw6IFwiYmxvY2tcIixcblx0XHRCT0RZOiBcImJsb2NrXCJcblx0fTtcblxuLyoqXG4gKiBSZXRyaWV2ZSB0aGUgYWN0dWFsIGRpc3BsYXkgb2YgYSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gbmFtZSBub2RlTmFtZSBvZiB0aGUgZWxlbWVudFxuICogQHBhcmFtIHtPYmplY3R9IGRvYyBEb2N1bWVudCBvYmplY3RcbiAqL1xuXG4vLyBDYWxsZWQgb25seSBmcm9tIHdpdGhpbiBkZWZhdWx0RGlzcGxheVxuZnVuY3Rpb24gYWN0dWFsRGlzcGxheSggbmFtZSwgZG9jICkge1xuXHR2YXIgZWxlbSA9IGpRdWVyeSggZG9jLmNyZWF0ZUVsZW1lbnQoIG5hbWUgKSApLmFwcGVuZFRvKCBkb2MuYm9keSApLFxuXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW1bIDAgXSwgXCJkaXNwbGF5XCIgKTtcblxuXHQvLyBXZSBkb24ndCBoYXZlIGFueSBkYXRhIHN0b3JlZCBvbiB0aGUgZWxlbWVudCxcblx0Ly8gc28gdXNlIFwiZGV0YWNoXCIgbWV0aG9kIGFzIGZhc3Qgd2F5IHRvIGdldCByaWQgb2YgdGhlIGVsZW1lbnRcblx0ZWxlbS5kZXRhY2goKTtcblxuXHRyZXR1cm4gZGlzcGxheTtcbn1cblxuLyoqXG4gKiBUcnkgdG8gZGV0ZXJtaW5lIHRoZSBkZWZhdWx0IGRpc3BsYXkgdmFsdWUgb2YgYW4gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IG5vZGVOYW1lXG4gKi9cbmZ1bmN0aW9uIGRlZmF1bHREaXNwbGF5KCBub2RlTmFtZSApIHtcblx0dmFyIGRvYyA9IGRvY3VtZW50LFxuXHRcdGRpc3BsYXkgPSBlbGVtZGlzcGxheVsgbm9kZU5hbWUgXTtcblxuXHRpZiAoICFkaXNwbGF5ICkge1xuXHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cblx0XHQvLyBJZiB0aGUgc2ltcGxlIHdheSBmYWlscywgcmVhZCBmcm9tIGluc2lkZSBhbiBpZnJhbWVcblx0XHRpZiAoIGRpc3BsYXkgPT09IFwibm9uZVwiIHx8ICFkaXNwbGF5ICkge1xuXG5cdFx0XHQvLyBVc2UgdGhlIGFscmVhZHktY3JlYXRlZCBpZnJhbWUgaWYgcG9zc2libGVcblx0XHRcdGlmcmFtZSA9ICggaWZyYW1lIHx8IGpRdWVyeSggXCI8aWZyYW1lIGZyYW1lYm9yZGVyPScwJyB3aWR0aD0nMCcgaGVpZ2h0PScwJy8+XCIgKSApXG5cdFx0XHRcdC5hcHBlbmRUbyggZG9jLmRvY3VtZW50RWxlbWVudCApO1xuXG5cdFx0XHQvLyBBbHdheXMgd3JpdGUgYSBuZXcgSFRNTCBza2VsZXRvbiBzbyBXZWJraXQgYW5kIEZpcmVmb3ggZG9uJ3QgY2hva2Ugb24gcmV1c2Vcblx0XHRcdGRvYyA9IGlmcmFtZVsgMCBdLmNvbnRlbnREb2N1bWVudDtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUVcblx0XHRcdGRvYy53cml0ZSgpO1xuXHRcdFx0ZG9jLmNsb3NlKCk7XG5cblx0XHRcdGRpc3BsYXkgPSBhY3R1YWxEaXNwbGF5KCBub2RlTmFtZSwgZG9jICk7XG5cdFx0XHRpZnJhbWUuZGV0YWNoKCk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgdGhlIGNvcnJlY3QgZGVmYXVsdCBkaXNwbGF5XG5cdFx0ZWxlbWRpc3BsYXlbIG5vZGVOYW1lIF0gPSBkaXNwbGF5O1xuXHR9XG5cblx0cmV0dXJuIGRpc3BsYXk7XG59XG52YXIgcm1hcmdpbiA9ICggL15tYXJnaW4vICk7XG5cbnZhciBybnVtbm9ucHggPSBuZXcgUmVnRXhwKCBcIl4oXCIgKyBwbnVtICsgXCIpKD8hcHgpW2EteiVdKyRcIiwgXCJpXCIgKTtcblxudmFyIGdldFN0eWxlcyA9IGZ1bmN0aW9uKCBlbGVtICkge1xuXG5cdFx0Ly8gU3VwcG9ydDogSUU8PTExKywgRmlyZWZveDw9MzArICgjMTUwOTgsICMxNDE1MClcblx0XHQvLyBJRSB0aHJvd3Mgb24gZWxlbWVudHMgY3JlYXRlZCBpbiBwb3B1cHNcblx0XHQvLyBGRiBtZWFud2hpbGUgdGhyb3dzIG9uIGZyYW1lIGVsZW1lbnRzIHRocm91Z2ggXCJkZWZhdWx0Vmlldy5nZXRDb21wdXRlZFN0eWxlXCJcblx0XHR2YXIgdmlldyA9IGVsZW0ub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldztcblxuXHRcdGlmICggIXZpZXcub3BlbmVyICkge1xuXHRcdFx0dmlldyA9IHdpbmRvdztcblx0XHR9XG5cblx0XHRyZXR1cm4gdmlldy5nZXRDb21wdXRlZFN0eWxlKCBlbGVtICk7XG5cdH07XG5cbnZhciBzd2FwID0gZnVuY3Rpb24oIGVsZW0sIG9wdGlvbnMsIGNhbGxiYWNrLCBhcmdzICkge1xuXHR2YXIgcmV0LCBuYW1lLFxuXHRcdG9sZCA9IHt9O1xuXG5cdC8vIFJlbWVtYmVyIHRoZSBvbGQgdmFsdWVzLCBhbmQgaW5zZXJ0IHRoZSBuZXcgb25lc1xuXHRmb3IgKCBuYW1lIGluIG9wdGlvbnMgKSB7XG5cdFx0b2xkWyBuYW1lIF0gPSBlbGVtLnN0eWxlWyBuYW1lIF07XG5cdFx0ZWxlbS5zdHlsZVsgbmFtZSBdID0gb3B0aW9uc1sgbmFtZSBdO1xuXHR9XG5cblx0cmV0ID0gY2FsbGJhY2suYXBwbHkoIGVsZW0sIGFyZ3MgfHwgW10gKTtcblxuXHQvLyBSZXZlcnQgdGhlIG9sZCB2YWx1ZXNcblx0Zm9yICggbmFtZSBpbiBvcHRpb25zICkge1xuXHRcdGVsZW0uc3R5bGVbIG5hbWUgXSA9IG9sZFsgbmFtZSBdO1xuXHR9XG5cblx0cmV0dXJuIHJldDtcbn07XG5cblxudmFyIGRvY3VtZW50RWxlbWVudCA9IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcblxuXG5cbiggZnVuY3Rpb24oKSB7XG5cdHZhciBwaXhlbFBvc2l0aW9uVmFsLCBib3hTaXppbmdSZWxpYWJsZVZhbCwgcGl4ZWxNYXJnaW5SaWdodFZhbCwgcmVsaWFibGVNYXJnaW5MZWZ0VmFsLFxuXHRcdGNvbnRhaW5lciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSxcblx0XHRkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImRpdlwiICk7XG5cblx0Ly8gRmluaXNoIGVhcmx5IGluIGxpbWl0ZWQgKG5vbi1icm93c2VyKSBlbnZpcm9ubWVudHNcblx0aWYgKCAhZGl2LnN0eWxlICkge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdC8vIFN1cHBvcnQ6IElFOS0xMStcblx0Ly8gU3R5bGUgb2YgY2xvbmVkIGVsZW1lbnQgYWZmZWN0cyBzb3VyY2UgZWxlbWVudCBjbG9uZWQgKCM4OTA4KVxuXHRkaXYuc3R5bGUuYmFja2dyb3VuZENsaXAgPSBcImNvbnRlbnQtYm94XCI7XG5cdGRpdi5jbG9uZU5vZGUoIHRydWUgKS5zdHlsZS5iYWNrZ3JvdW5kQ2xpcCA9IFwiXCI7XG5cdHN1cHBvcnQuY2xlYXJDbG9uZVN0eWxlID0gZGl2LnN0eWxlLmJhY2tncm91bmRDbGlwID09PSBcImNvbnRlbnQtYm94XCI7XG5cblx0Y29udGFpbmVyLnN0eWxlLmNzc1RleHQgPSBcImJvcmRlcjowO3dpZHRoOjhweDtoZWlnaHQ6MDt0b3A6MDtsZWZ0Oi05OTk5cHg7XCIgK1xuXHRcdFwicGFkZGluZzowO21hcmdpbi10b3A6MXB4O3Bvc2l0aW9uOmFic29sdXRlXCI7XG5cdGNvbnRhaW5lci5hcHBlbmRDaGlsZCggZGl2ICk7XG5cblx0Ly8gRXhlY3V0aW5nIGJvdGggcGl4ZWxQb3NpdGlvbiAmIGJveFNpemluZ1JlbGlhYmxlIHRlc3RzIHJlcXVpcmUgb25seSBvbmUgbGF5b3V0XG5cdC8vIHNvIHRoZXkncmUgZXhlY3V0ZWQgYXQgdGhlIHNhbWUgdGltZSB0byBzYXZlIHRoZSBzZWNvbmQgY29tcHV0YXRpb24uXG5cdGZ1bmN0aW9uIGNvbXB1dGVTdHlsZVRlc3RzKCkge1xuXHRcdGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0Ly8gU3VwcG9ydDogRmlyZWZveDwyOSwgQW5kcm9pZCAyLjNcblx0XHRcdC8vIFZlbmRvci1wcmVmaXggYm94LXNpemluZ1xuXHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Ym9yZGVyLWJveDstbW96LWJveC1zaXppbmc6Ym9yZGVyLWJveDtib3gtc2l6aW5nOmJvcmRlci1ib3g7XCIgK1xuXHRcdFx0XCJwb3NpdGlvbjpyZWxhdGl2ZTtkaXNwbGF5OmJsb2NrO1wiICtcblx0XHRcdFwibWFyZ2luOmF1dG87Ym9yZGVyOjFweDtwYWRkaW5nOjFweDtcIiArXG5cdFx0XHRcInRvcDoxJTt3aWR0aDo1MCVcIjtcblx0XHRkaXYuaW5uZXJIVE1MID0gXCJcIjtcblx0XHRkb2N1bWVudEVsZW1lbnQuYXBwZW5kQ2hpbGQoIGNvbnRhaW5lciApO1xuXG5cdFx0dmFyIGRpdlN0eWxlID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoIGRpdiApO1xuXHRcdHBpeGVsUG9zaXRpb25WYWwgPSBkaXZTdHlsZS50b3AgIT09IFwiMSVcIjtcblx0XHRyZWxpYWJsZU1hcmdpbkxlZnRWYWwgPSBkaXZTdHlsZS5tYXJnaW5MZWZ0ID09PSBcIjJweFwiO1xuXHRcdGJveFNpemluZ1JlbGlhYmxlVmFsID0gZGl2U3R5bGUud2lkdGggPT09IFwiNHB4XCI7XG5cblx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDQuMCAtIDQuMyBvbmx5XG5cdFx0Ly8gU29tZSBzdHlsZXMgY29tZSBiYWNrIHdpdGggcGVyY2VudGFnZSB2YWx1ZXMsIGV2ZW4gdGhvdWdoIHRoZXkgc2hvdWxkbid0XG5cdFx0ZGl2LnN0eWxlLm1hcmdpblJpZ2h0ID0gXCI1MCVcIjtcblx0XHRwaXhlbE1hcmdpblJpZ2h0VmFsID0gZGl2U3R5bGUubWFyZ2luUmlnaHQgPT09IFwiNHB4XCI7XG5cblx0XHRkb2N1bWVudEVsZW1lbnQucmVtb3ZlQ2hpbGQoIGNvbnRhaW5lciApO1xuXHR9XG5cblx0alF1ZXJ5LmV4dGVuZCggc3VwcG9ydCwge1xuXHRcdHBpeGVsUG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXG5cdFx0XHQvLyBUaGlzIHRlc3QgaXMgZXhlY3V0ZWQgb25seSBvbmNlIGJ1dCB3ZSBzdGlsbCBkbyBtZW1vaXppbmdcblx0XHRcdC8vIHNpbmNlIHdlIGNhbiB1c2UgdGhlIGJveFNpemluZ1JlbGlhYmxlIHByZS1jb21wdXRpbmcuXG5cdFx0XHQvLyBObyBuZWVkIHRvIGNoZWNrIGlmIHRoZSB0ZXN0IHdhcyBhbHJlYWR5IHBlcmZvcm1lZCwgdGhvdWdoLlxuXHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdHJldHVybiBwaXhlbFBvc2l0aW9uVmFsO1xuXHRcdH0sXG5cdFx0Ym94U2l6aW5nUmVsaWFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCBib3hTaXppbmdSZWxpYWJsZVZhbCA9PSBudWxsICkge1xuXHRcdFx0XHRjb21wdXRlU3R5bGVUZXN0cygpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGJveFNpemluZ1JlbGlhYmxlVmFsO1xuXHRcdH0sXG5cdFx0cGl4ZWxNYXJnaW5SaWdodDogZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIFN1cHBvcnQ6IEFuZHJvaWQgNC4wLTQuM1xuXHRcdFx0Ly8gV2UncmUgY2hlY2tpbmcgZm9yIGJveFNpemluZ1JlbGlhYmxlVmFsIGhlcmUgaW5zdGVhZCBvZiBwaXhlbE1hcmdpblJpZ2h0VmFsXG5cdFx0XHQvLyBzaW5jZSB0aGF0IGNvbXByZXNzZXMgYmV0dGVyIGFuZCB0aGV5J3JlIGNvbXB1dGVkIHRvZ2V0aGVyIGFueXdheS5cblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBwaXhlbE1hcmdpblJpZ2h0VmFsO1xuXHRcdH0sXG5cdFx0cmVsaWFibGVNYXJnaW5MZWZ0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogSUUgPD04IG9ubHksIEFuZHJvaWQgNC4wIC0gNC4zIG9ubHksIEZpcmVmb3ggPD0zIC0gMzdcblx0XHRcdGlmICggYm94U2l6aW5nUmVsaWFibGVWYWwgPT0gbnVsbCApIHtcblx0XHRcdFx0Y29tcHV0ZVN0eWxlVGVzdHMoKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZWxpYWJsZU1hcmdpbkxlZnRWYWw7XG5cdFx0fSxcblx0XHRyZWxpYWJsZU1hcmdpblJpZ2h0OiBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gU3VwcG9ydDogQW5kcm9pZCAyLjNcblx0XHRcdC8vIENoZWNrIGlmIGRpdiB3aXRoIGV4cGxpY2l0IHdpZHRoIGFuZCBubyBtYXJnaW4tcmlnaHQgaW5jb3JyZWN0bHlcblx0XHRcdC8vIGdldHMgY29tcHV0ZWQgbWFyZ2luLXJpZ2h0IGJhc2VkIG9uIHdpZHRoIG9mIGNvbnRhaW5lci4gKCMzMzMzKVxuXHRcdFx0Ly8gV2ViS2l0IEJ1ZyAxMzM0MyAtIGdldENvbXB1dGVkU3R5bGUgcmV0dXJucyB3cm9uZyB2YWx1ZSBmb3IgbWFyZ2luLXJpZ2h0XG5cdFx0XHQvLyBUaGlzIHN1cHBvcnQgZnVuY3Rpb24gaXMgb25seSBleGVjdXRlZCBvbmNlIHNvIG5vIG1lbW9pemluZyBpcyBuZWVkZWQuXG5cdFx0XHR2YXIgcmV0LFxuXHRcdFx0XHRtYXJnaW5EaXYgPSBkaXYuYXBwZW5kQ2hpbGQoIGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiZGl2XCIgKSApO1xuXG5cdFx0XHQvLyBSZXNldCBDU1M6IGJveC1zaXppbmc7IGRpc3BsYXk7IG1hcmdpbjsgYm9yZGVyOyBwYWRkaW5nXG5cdFx0XHRtYXJnaW5EaXYuc3R5bGUuY3NzVGV4dCA9IGRpdi5zdHlsZS5jc3NUZXh0ID1cblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBWZW5kb3ItcHJlZml4IGJveC1zaXppbmdcblx0XHRcdFx0XCItd2Via2l0LWJveC1zaXppbmc6Y29udGVudC1ib3g7Ym94LXNpemluZzpjb250ZW50LWJveDtcIiArXG5cdFx0XHRcdFwiZGlzcGxheTpibG9jazttYXJnaW46MDtib3JkZXI6MDtwYWRkaW5nOjBcIjtcblx0XHRcdG1hcmdpbkRpdi5zdHlsZS5tYXJnaW5SaWdodCA9IG1hcmdpbkRpdi5zdHlsZS53aWR0aCA9IFwiMFwiO1xuXHRcdFx0ZGl2LnN0eWxlLndpZHRoID0gXCIxcHhcIjtcblx0XHRcdGRvY3VtZW50RWxlbWVudC5hcHBlbmRDaGlsZCggY29udGFpbmVyICk7XG5cblx0XHRcdHJldCA9ICFwYXJzZUZsb2F0KCB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSggbWFyZ2luRGl2ICkubWFyZ2luUmlnaHQgKTtcblxuXHRcdFx0ZG9jdW1lbnRFbGVtZW50LnJlbW92ZUNoaWxkKCBjb250YWluZXIgKTtcblx0XHRcdGRpdi5yZW1vdmVDaGlsZCggbWFyZ2luRGl2ICk7XG5cblx0XHRcdHJldHVybiByZXQ7XG5cdFx0fVxuXHR9ICk7XG59ICkoKTtcblxuXG5mdW5jdGlvbiBjdXJDU1MoIGVsZW0sIG5hbWUsIGNvbXB1dGVkICkge1xuXHR2YXIgd2lkdGgsIG1pbldpZHRoLCBtYXhXaWR0aCwgcmV0LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZTtcblxuXHRjb21wdXRlZCA9IGNvbXB1dGVkIHx8IGdldFN0eWxlcyggZWxlbSApO1xuXG5cdC8vIFN1cHBvcnQ6IElFOVxuXHQvLyBnZXRQcm9wZXJ0eVZhbHVlIGlzIG9ubHkgbmVlZGVkIGZvciAuY3NzKCdmaWx0ZXInKSAoIzEyNTM3KVxuXHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdHJldCA9IGNvbXB1dGVkLmdldFByb3BlcnR5VmFsdWUoIG5hbWUgKSB8fCBjb21wdXRlZFsgbmFtZSBdO1xuXG5cdFx0aWYgKCByZXQgPT09IFwiXCIgJiYgIWpRdWVyeS5jb250YWlucyggZWxlbS5vd25lckRvY3VtZW50LCBlbGVtICkgKSB7XG5cdFx0XHRyZXQgPSBqUXVlcnkuc3R5bGUoIGVsZW0sIG5hbWUgKTtcblx0XHR9XG5cblx0XHQvLyBBIHRyaWJ1dGUgdG8gdGhlIFwiYXdlc29tZSBoYWNrIGJ5IERlYW4gRWR3YXJkc1wiXG5cdFx0Ly8gQW5kcm9pZCBCcm93c2VyIHJldHVybnMgcGVyY2VudGFnZSBmb3Igc29tZSB2YWx1ZXMsXG5cdFx0Ly8gYnV0IHdpZHRoIHNlZW1zIHRvIGJlIHJlbGlhYmx5IHBpeGVscy5cblx0XHQvLyBUaGlzIGlzIGFnYWluc3QgdGhlIENTU09NIGRyYWZ0IHNwZWM6XG5cdFx0Ly8gaHR0cDovL2Rldi53My5vcmcvY3Nzd2cvY3Nzb20vI3Jlc29sdmVkLXZhbHVlc1xuXHRcdGlmICggIXN1cHBvcnQucGl4ZWxNYXJnaW5SaWdodCgpICYmIHJudW1ub25weC50ZXN0KCByZXQgKSAmJiBybWFyZ2luLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0Ly8gUmVtZW1iZXIgdGhlIG9yaWdpbmFsIHZhbHVlc1xuXHRcdFx0d2lkdGggPSBzdHlsZS53aWR0aDtcblx0XHRcdG1pbldpZHRoID0gc3R5bGUubWluV2lkdGg7XG5cdFx0XHRtYXhXaWR0aCA9IHN0eWxlLm1heFdpZHRoO1xuXG5cdFx0XHQvLyBQdXQgaW4gdGhlIG5ldyB2YWx1ZXMgdG8gZ2V0IGEgY29tcHV0ZWQgdmFsdWUgb3V0XG5cdFx0XHRzdHlsZS5taW5XaWR0aCA9IHN0eWxlLm1heFdpZHRoID0gc3R5bGUud2lkdGggPSByZXQ7XG5cdFx0XHRyZXQgPSBjb21wdXRlZC53aWR0aDtcblxuXHRcdFx0Ly8gUmV2ZXJ0IHRoZSBjaGFuZ2VkIHZhbHVlc1xuXHRcdFx0c3R5bGUud2lkdGggPSB3aWR0aDtcblx0XHRcdHN0eWxlLm1pbldpZHRoID0gbWluV2lkdGg7XG5cdFx0XHRzdHlsZS5tYXhXaWR0aCA9IG1heFdpZHRoO1xuXHRcdH1cblx0fVxuXG5cdHJldHVybiByZXQgIT09IHVuZGVmaW5lZCA/XG5cblx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0Ly8gSUUgcmV0dXJucyB6SW5kZXggdmFsdWUgYXMgYW4gaW50ZWdlci5cblx0XHRyZXQgKyBcIlwiIDpcblx0XHRyZXQ7XG59XG5cblxuZnVuY3Rpb24gYWRkR2V0SG9va0lmKCBjb25kaXRpb25GbiwgaG9va0ZuICkge1xuXG5cdC8vIERlZmluZSB0aGUgaG9vaywgd2UnbGwgY2hlY2sgb24gdGhlIGZpcnN0IHJ1biBpZiBpdCdzIHJlYWxseSBuZWVkZWQuXG5cdHJldHVybiB7XG5cdFx0Z2V0OiBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggY29uZGl0aW9uRm4oKSApIHtcblxuXHRcdFx0XHQvLyBIb29rIG5vdCBuZWVkZWQgKG9yIGl0J3Mgbm90IHBvc3NpYmxlIHRvIHVzZSBpdCBkdWVcblx0XHRcdFx0Ly8gdG8gbWlzc2luZyBkZXBlbmRlbmN5KSwgcmVtb3ZlIGl0LlxuXHRcdFx0XHRkZWxldGUgdGhpcy5nZXQ7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSG9vayBuZWVkZWQ7IHJlZGVmaW5lIGl0IHNvIHRoYXQgdGhlIHN1cHBvcnQgdGVzdCBpcyBub3QgZXhlY3V0ZWQgYWdhaW4uXG5cdFx0XHRyZXR1cm4gKCB0aGlzLmdldCA9IGhvb2tGbiApLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKTtcblx0XHR9XG5cdH07XG59XG5cblxudmFyXG5cblx0Ly8gU3dhcHBhYmxlIGlmIGRpc3BsYXkgaXMgbm9uZSBvciBzdGFydHMgd2l0aCB0YWJsZVxuXHQvLyBleGNlcHQgXCJ0YWJsZVwiLCBcInRhYmxlLWNlbGxcIiwgb3IgXCJ0YWJsZS1jYXB0aW9uXCJcblx0Ly8gU2VlIGhlcmUgZm9yIGRpc3BsYXkgdmFsdWVzOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL0NTUy9kaXNwbGF5XG5cdHJkaXNwbGF5c3dhcCA9IC9eKG5vbmV8dGFibGUoPyEtY1tlYV0pLispLyxcblxuXHRjc3NTaG93ID0geyBwb3NpdGlvbjogXCJhYnNvbHV0ZVwiLCB2aXNpYmlsaXR5OiBcImhpZGRlblwiLCBkaXNwbGF5OiBcImJsb2NrXCIgfSxcblx0Y3NzTm9ybWFsVHJhbnNmb3JtID0ge1xuXHRcdGxldHRlclNwYWNpbmc6IFwiMFwiLFxuXHRcdGZvbnRXZWlnaHQ6IFwiNDAwXCJcblx0fSxcblxuXHRjc3NQcmVmaXhlcyA9IFsgXCJXZWJraXRcIiwgXCJPXCIsIFwiTW96XCIsIFwibXNcIiBdLFxuXHRlbXB0eVN0eWxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJkaXZcIiApLnN0eWxlO1xuXG4vLyBSZXR1cm4gYSBjc3MgcHJvcGVydHkgbWFwcGVkIHRvIGEgcG90ZW50aWFsbHkgdmVuZG9yIHByZWZpeGVkIHByb3BlcnR5XG5mdW5jdGlvbiB2ZW5kb3JQcm9wTmFtZSggbmFtZSApIHtcblxuXHQvLyBTaG9ydGN1dCBmb3IgbmFtZXMgdGhhdCBhcmUgbm90IHZlbmRvciBwcmVmaXhlZFxuXHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRyZXR1cm4gbmFtZTtcblx0fVxuXG5cdC8vIENoZWNrIGZvciB2ZW5kb3IgcHJlZml4ZWQgbmFtZXNcblx0dmFyIGNhcE5hbWUgPSBuYW1lWyAwIF0udG9VcHBlckNhc2UoKSArIG5hbWUuc2xpY2UoIDEgKSxcblx0XHRpID0gY3NzUHJlZml4ZXMubGVuZ3RoO1xuXG5cdHdoaWxlICggaS0tICkge1xuXHRcdG5hbWUgPSBjc3NQcmVmaXhlc1sgaSBdICsgY2FwTmFtZTtcblx0XHRpZiAoIG5hbWUgaW4gZW1wdHlTdHlsZSApIHtcblx0XHRcdHJldHVybiBuYW1lO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICkge1xuXG5cdC8vIEFueSByZWxhdGl2ZSAoKy8tKSB2YWx1ZXMgaGF2ZSBhbHJlYWR5IGJlZW5cblx0Ly8gbm9ybWFsaXplZCBhdCB0aGlzIHBvaW50XG5cdHZhciBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApO1xuXHRyZXR1cm4gbWF0Y2hlcyA/XG5cblx0XHQvLyBHdWFyZCBhZ2FpbnN0IHVuZGVmaW5lZCBcInN1YnRyYWN0XCIsIGUuZy4sIHdoZW4gdXNlZCBhcyBpbiBjc3NIb29rc1xuXHRcdE1hdGgubWF4KCAwLCBtYXRjaGVzWyAyIF0gLSAoIHN1YnRyYWN0IHx8IDAgKSApICsgKCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgOlxuXHRcdHZhbHVlO1xufVxuXG5mdW5jdGlvbiBhdWdtZW50V2lkdGhPckhlaWdodCggZWxlbSwgbmFtZSwgZXh0cmEsIGlzQm9yZGVyQm94LCBzdHlsZXMgKSB7XG5cdHZhciBpID0gZXh0cmEgPT09ICggaXNCb3JkZXJCb3ggPyBcImJvcmRlclwiIDogXCJjb250ZW50XCIgKSA/XG5cblx0XHQvLyBJZiB3ZSBhbHJlYWR5IGhhdmUgdGhlIHJpZ2h0IG1lYXN1cmVtZW50LCBhdm9pZCBhdWdtZW50YXRpb25cblx0XHQ0IDpcblxuXHRcdC8vIE90aGVyd2lzZSBpbml0aWFsaXplIGZvciBob3Jpem9udGFsIG9yIHZlcnRpY2FsIHByb3BlcnRpZXNcblx0XHRuYW1lID09PSBcIndpZHRoXCIgPyAxIDogMCxcblxuXHRcdHZhbCA9IDA7XG5cblx0Zm9yICggOyBpIDwgNDsgaSArPSAyICkge1xuXG5cdFx0Ly8gQm90aCBib3ggbW9kZWxzIGV4Y2x1ZGUgbWFyZ2luLCBzbyBhZGQgaXQgaWYgd2Ugd2FudCBpdFxuXHRcdGlmICggZXh0cmEgPT09IFwibWFyZ2luXCIgKSB7XG5cdFx0XHR2YWwgKz0galF1ZXJ5LmNzcyggZWxlbSwgZXh0cmEgKyBjc3NFeHBhbmRbIGkgXSwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBpc0JvcmRlckJveCApIHtcblxuXHRcdFx0Ly8gYm9yZGVyLWJveCBpbmNsdWRlcyBwYWRkaW5nLCBzbyByZW1vdmUgaXQgaWYgd2Ugd2FudCBjb250ZW50XG5cdFx0XHRpZiAoIGV4dHJhID09PSBcImNvbnRlbnRcIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwicGFkZGluZ1wiICsgY3NzRXhwYW5kWyBpIF0sIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBdCB0aGlzIHBvaW50LCBleHRyYSBpc24ndCBib3JkZXIgbm9yIG1hcmdpbiwgc28gcmVtb3ZlIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJtYXJnaW5cIiApIHtcblx0XHRcdFx0dmFsIC09IGpRdWVyeS5jc3MoIGVsZW0sIFwiYm9yZGVyXCIgKyBjc3NFeHBhbmRbIGkgXSArIFwiV2lkdGhcIiwgdHJ1ZSwgc3R5bGVzICk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCwgc28gYWRkIHBhZGRpbmdcblx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBhZGRpbmdcIiArIGNzc0V4cGFuZFsgaSBdLCB0cnVlLCBzdHlsZXMgKTtcblxuXHRcdFx0Ly8gQXQgdGhpcyBwb2ludCwgZXh0cmEgaXNuJ3QgY29udGVudCBub3IgcGFkZGluZywgc28gYWRkIGJvcmRlclxuXHRcdFx0aWYgKCBleHRyYSAhPT0gXCJwYWRkaW5nXCIgKSB7XG5cdFx0XHRcdHZhbCArPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJvcmRlclwiICsgY3NzRXhwYW5kWyBpIF0gKyBcIldpZHRoXCIsIHRydWUsIHN0eWxlcyApO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdHJldHVybiB2YWw7XG59XG5cbmZ1bmN0aW9uIGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICkge1xuXG5cdC8vIFN0YXJ0IHdpdGggb2Zmc2V0IHByb3BlcnR5LCB3aGljaCBpcyBlcXVpdmFsZW50IHRvIHRoZSBib3JkZXItYm94IHZhbHVlXG5cdHZhciB2YWx1ZUlzQm9yZGVyQm94ID0gdHJ1ZSxcblx0XHR2YWwgPSBuYW1lID09PSBcIndpZHRoXCIgPyBlbGVtLm9mZnNldFdpZHRoIDogZWxlbS5vZmZzZXRIZWlnaHQsXG5cdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICksXG5cdFx0aXNCb3JkZXJCb3ggPSBqUXVlcnkuY3NzKCBlbGVtLCBcImJveFNpemluZ1wiLCBmYWxzZSwgc3R5bGVzICkgPT09IFwiYm9yZGVyLWJveFwiO1xuXG5cdC8vIFN1cHBvcnQ6IElFMTEgb25seVxuXHQvLyBJbiBJRSAxMSBmdWxsc2NyZWVuIGVsZW1lbnRzIGluc2lkZSBvZiBhbiBpZnJhbWUgaGF2ZVxuXHQvLyAxMDB4IHRvbyBzbWFsbCBkaW1lbnNpb25zIChnaC0xNzY0KS5cblx0aWYgKCBkb2N1bWVudC5tc0Z1bGxzY3JlZW5FbGVtZW50ICYmIHdpbmRvdy50b3AgIT09IHdpbmRvdyApIHtcblxuXHRcdC8vIFN1cHBvcnQ6IElFMTEgb25seVxuXHRcdC8vIFJ1bm5pbmcgZ2V0Qm91bmRpbmdDbGllbnRSZWN0IG9uIGEgZGlzY29ubmVjdGVkIG5vZGVcblx0XHQvLyBpbiBJRSB0aHJvd3MgYW4gZXJyb3IuXG5cdFx0aWYgKCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoICkge1xuXHRcdFx0dmFsID0gTWF0aC5yb3VuZCggZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKVsgbmFtZSBdICogMTAwICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gU29tZSBub24taHRtbCBlbGVtZW50cyByZXR1cm4gdW5kZWZpbmVkIGZvciBvZmZzZXRXaWR0aCwgc28gY2hlY2sgZm9yIG51bGwvdW5kZWZpbmVkXG5cdC8vIHN2ZyAtIGh0dHBzOi8vYnVnemlsbGEubW96aWxsYS5vcmcvc2hvd19idWcuY2dpP2lkPTY0OTI4NVxuXHQvLyBNYXRoTUwgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD00OTE2Njhcblx0aWYgKCB2YWwgPD0gMCB8fCB2YWwgPT0gbnVsbCApIHtcblxuXHRcdC8vIEZhbGwgYmFjayB0byBjb21wdXRlZCB0aGVuIHVuY29tcHV0ZWQgY3NzIGlmIG5lY2Vzc2FyeVxuXHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0aWYgKCB2YWwgPCAwIHx8IHZhbCA9PSBudWxsICkge1xuXHRcdFx0dmFsID0gZWxlbS5zdHlsZVsgbmFtZSBdO1xuXHRcdH1cblxuXHRcdC8vIENvbXB1dGVkIHVuaXQgaXMgbm90IHBpeGVscy4gU3RvcCBoZXJlIGFuZCByZXR1cm4uXG5cdFx0aWYgKCBybnVtbm9ucHgudGVzdCggdmFsICkgKSB7XG5cdFx0XHRyZXR1cm4gdmFsO1xuXHRcdH1cblxuXHRcdC8vIENoZWNrIGZvciBzdHlsZSBpbiBjYXNlIGEgYnJvd3NlciB3aGljaCByZXR1cm5zIHVucmVsaWFibGUgdmFsdWVzXG5cdFx0Ly8gZm9yIGdldENvbXB1dGVkU3R5bGUgc2lsZW50bHkgZmFsbHMgYmFjayB0byB0aGUgcmVsaWFibGUgZWxlbS5zdHlsZVxuXHRcdHZhbHVlSXNCb3JkZXJCb3ggPSBpc0JvcmRlckJveCAmJlxuXHRcdFx0KCBzdXBwb3J0LmJveFNpemluZ1JlbGlhYmxlKCkgfHwgdmFsID09PSBlbGVtLnN0eWxlWyBuYW1lIF0gKTtcblxuXHRcdC8vIE5vcm1hbGl6ZSBcIlwiLCBhdXRvLCBhbmQgcHJlcGFyZSBmb3IgZXh0cmFcblx0XHR2YWwgPSBwYXJzZUZsb2F0KCB2YWwgKSB8fCAwO1xuXHR9XG5cblx0Ly8gVXNlIHRoZSBhY3RpdmUgYm94LXNpemluZyBtb2RlbCB0byBhZGQvc3VidHJhY3QgaXJyZWxldmFudCBzdHlsZXNcblx0cmV0dXJuICggdmFsICtcblx0XHRhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdGVsZW0sXG5cdFx0XHRuYW1lLFxuXHRcdFx0ZXh0cmEgfHwgKCBpc0JvcmRlckJveCA/IFwiYm9yZGVyXCIgOiBcImNvbnRlbnRcIiApLFxuXHRcdFx0dmFsdWVJc0JvcmRlckJveCxcblx0XHRcdHN0eWxlc1xuXHRcdClcblx0KSArIFwicHhcIjtcbn1cblxuZnVuY3Rpb24gc2hvd0hpZGUoIGVsZW1lbnRzLCBzaG93ICkge1xuXHR2YXIgZGlzcGxheSwgZWxlbSwgaGlkZGVuLFxuXHRcdHZhbHVlcyA9IFtdLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBlbGVtZW50cy5sZW5ndGg7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRlbGVtID0gZWxlbWVudHNbIGluZGV4IF07XG5cdFx0aWYgKCAhZWxlbS5zdHlsZSApIHtcblx0XHRcdGNvbnRpbnVlO1xuXHRcdH1cblxuXHRcdHZhbHVlc1sgaW5kZXggXSA9IGRhdGFQcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKTtcblx0XHRkaXNwbGF5ID0gZWxlbS5zdHlsZS5kaXNwbGF5O1xuXHRcdGlmICggc2hvdyApIHtcblxuXHRcdFx0Ly8gUmVzZXQgdGhlIGlubGluZSBkaXNwbGF5IG9mIHRoaXMgZWxlbWVudCB0byBsZWFybiBpZiBpdCBpc1xuXHRcdFx0Ly8gYmVpbmcgaGlkZGVuIGJ5IGNhc2NhZGVkIHJ1bGVzIG9yIG5vdFxuXHRcdFx0aWYgKCAhdmFsdWVzWyBpbmRleCBdICYmIGRpc3BsYXkgPT09IFwibm9uZVwiICkge1xuXHRcdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBcIlwiO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTZXQgZWxlbWVudHMgd2hpY2ggaGF2ZSBiZWVuIG92ZXJyaWRkZW4gd2l0aCBkaXNwbGF5OiBub25lXG5cdFx0XHQvLyBpbiBhIHN0eWxlc2hlZXQgdG8gd2hhdGV2ZXIgdGhlIGRlZmF1bHQgYnJvd3NlciBzdHlsZSBpc1xuXHRcdFx0Ly8gZm9yIHN1Y2ggYW4gZWxlbWVudFxuXHRcdFx0aWYgKCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgJiYgaXNIaWRkZW4oIGVsZW0gKSApIHtcblx0XHRcdFx0dmFsdWVzWyBpbmRleCBdID0gZGF0YVByaXYuYWNjZXNzKFxuXHRcdFx0XHRcdGVsZW0sXG5cdFx0XHRcdFx0XCJvbGRkaXNwbGF5XCIsXG5cdFx0XHRcdFx0ZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKVxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHRoaWRkZW4gPSBpc0hpZGRlbiggZWxlbSApO1xuXG5cdFx0XHRpZiAoIGRpc3BsYXkgIT09IFwibm9uZVwiIHx8ICFoaWRkZW4gKSB7XG5cdFx0XHRcdGRhdGFQcml2LnNldChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdFwib2xkZGlzcGxheVwiLFxuXHRcdFx0XHRcdGhpZGRlbiA/IGRpc3BsYXkgOiBqUXVlcnkuY3NzKCBlbGVtLCBcImRpc3BsYXlcIiApXG5cdFx0XHRcdCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0Ly8gU2V0IHRoZSBkaXNwbGF5IG9mIG1vc3Qgb2YgdGhlIGVsZW1lbnRzIGluIGEgc2Vjb25kIGxvb3Bcblx0Ly8gdG8gYXZvaWQgdGhlIGNvbnN0YW50IHJlZmxvd1xuXHRmb3IgKCBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrICkge1xuXHRcdGVsZW0gPSBlbGVtZW50c1sgaW5kZXggXTtcblx0XHRpZiAoICFlbGVtLnN0eWxlICkge1xuXHRcdFx0Y29udGludWU7XG5cdFx0fVxuXHRcdGlmICggIXNob3cgfHwgZWxlbS5zdHlsZS5kaXNwbGF5ID09PSBcIm5vbmVcIiB8fCBlbGVtLnN0eWxlLmRpc3BsYXkgPT09IFwiXCIgKSB7XG5cdFx0XHRlbGVtLnN0eWxlLmRpc3BsYXkgPSBzaG93ID8gdmFsdWVzWyBpbmRleCBdIHx8IFwiXCIgOiBcIm5vbmVcIjtcblx0XHR9XG5cdH1cblxuXHRyZXR1cm4gZWxlbWVudHM7XG59XG5cbmpRdWVyeS5leHRlbmQoIHtcblxuXHQvLyBBZGQgaW4gc3R5bGUgcHJvcGVydHkgaG9va3MgZm9yIG92ZXJyaWRpbmcgdGhlIGRlZmF1bHRcblx0Ly8gYmVoYXZpb3Igb2YgZ2V0dGluZyBhbmQgc2V0dGluZyBhIHN0eWxlIHByb3BlcnR5XG5cdGNzc0hvb2tzOiB7XG5cdFx0b3BhY2l0eToge1xuXHRcdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cblx0XHRcdFx0XHQvLyBXZSBzaG91bGQgYWx3YXlzIGdldCBhIG51bWJlciBiYWNrIGZyb20gb3BhY2l0eVxuXHRcdFx0XHRcdHZhciByZXQgPSBjdXJDU1MoIGVsZW0sIFwib3BhY2l0eVwiICk7XG5cdFx0XHRcdFx0cmV0dXJuIHJldCA9PT0gXCJcIiA/IFwiMVwiIDogcmV0O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdC8vIERvbid0IGF1dG9tYXRpY2FsbHkgYWRkIFwicHhcIiB0byB0aGVzZSBwb3NzaWJseS11bml0bGVzcyBwcm9wZXJ0aWVzXG5cdGNzc051bWJlcjoge1xuXHRcdFwiYW5pbWF0aW9uSXRlcmF0aW9uQ291bnRcIjogdHJ1ZSxcblx0XHRcImNvbHVtbkNvdW50XCI6IHRydWUsXG5cdFx0XCJmaWxsT3BhY2l0eVwiOiB0cnVlLFxuXHRcdFwiZmxleEdyb3dcIjogdHJ1ZSxcblx0XHRcImZsZXhTaHJpbmtcIjogdHJ1ZSxcblx0XHRcImZvbnRXZWlnaHRcIjogdHJ1ZSxcblx0XHRcImxpbmVIZWlnaHRcIjogdHJ1ZSxcblx0XHRcIm9wYWNpdHlcIjogdHJ1ZSxcblx0XHRcIm9yZGVyXCI6IHRydWUsXG5cdFx0XCJvcnBoYW5zXCI6IHRydWUsXG5cdFx0XCJ3aWRvd3NcIjogdHJ1ZSxcblx0XHRcInpJbmRleFwiOiB0cnVlLFxuXHRcdFwiem9vbVwiOiB0cnVlXG5cdH0sXG5cblx0Ly8gQWRkIGluIHByb3BlcnRpZXMgd2hvc2UgbmFtZXMgeW91IHdpc2ggdG8gZml4IGJlZm9yZVxuXHQvLyBzZXR0aW5nIG9yIGdldHRpbmcgdGhlIHZhbHVlXG5cdGNzc1Byb3BzOiB7XG5cdFx0XCJmbG9hdFwiOiBcImNzc0Zsb2F0XCJcblx0fSxcblxuXHQvLyBHZXQgYW5kIHNldCB0aGUgc3R5bGUgcHJvcGVydHkgb24gYSBET00gTm9kZVxuXHRzdHlsZTogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlLCBleHRyYSApIHtcblxuXHRcdC8vIERvbid0IHNldCBzdHlsZXMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggIWVsZW0gfHwgZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4IHx8ICFlbGVtLnN0eWxlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdHZhciByZXQsIHR5cGUsIGhvb2tzLFxuXHRcdFx0b3JpZ05hbWUgPSBqUXVlcnkuY2FtZWxDYXNlKCBuYW1lICksXG5cdFx0XHRzdHlsZSA9IGVsZW0uc3R5bGU7XG5cblx0XHRuYW1lID0galF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdIHx8XG5cdFx0XHQoIGpRdWVyeS5jc3NQcm9wc1sgb3JpZ05hbWUgXSA9IHZlbmRvclByb3BOYW1lKCBvcmlnTmFtZSApIHx8IG9yaWdOYW1lICk7XG5cblx0XHQvLyBHZXRzIGhvb2sgZm9yIHRoZSBwcmVmaXhlZCB2ZXJzaW9uLCB0aGVuIHVucHJlZml4ZWQgdmVyc2lvblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF0gfHwgalF1ZXJ5LmNzc0hvb2tzWyBvcmlnTmFtZSBdO1xuXG5cdFx0Ly8gQ2hlY2sgaWYgd2UncmUgc2V0dGluZyBhIHZhbHVlXG5cdFx0aWYgKCB2YWx1ZSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0dHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdFx0Ly8gQ29udmVydCBcIis9XCIgb3IgXCItPVwiIHRvIHJlbGF0aXZlIG51bWJlcnMgKCM3MzQ1KVxuXHRcdFx0aWYgKCB0eXBlID09PSBcInN0cmluZ1wiICYmICggcmV0ID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiYgcmV0WyAxIF0gKSB7XG5cdFx0XHRcdHZhbHVlID0gYWRqdXN0Q1NTKCBlbGVtLCBuYW1lLCByZXQgKTtcblxuXHRcdFx0XHQvLyBGaXhlcyBidWcgIzkyMzdcblx0XHRcdFx0dHlwZSA9IFwibnVtYmVyXCI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IG51bGwgYW5kIE5hTiB2YWx1ZXMgYXJlbid0IHNldCAoIzcxMTYpXG5cdFx0XHRpZiAoIHZhbHVlID09IG51bGwgfHwgdmFsdWUgIT09IHZhbHVlICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIGEgbnVtYmVyIHdhcyBwYXNzZWQgaW4sIGFkZCB0aGUgdW5pdCAoZXhjZXB0IGZvciBjZXJ0YWluIENTUyBwcm9wZXJ0aWVzKVxuXHRcdFx0aWYgKCB0eXBlID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWx1ZSArPSByZXQgJiYgcmV0WyAzIF0gfHwgKCBqUXVlcnkuY3NzTnVtYmVyWyBvcmlnTmFtZSBdID8gXCJcIiA6IFwicHhcIiApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTktMTErXG5cdFx0XHQvLyBiYWNrZ3JvdW5kLSogcHJvcHMgYWZmZWN0IG9yaWdpbmFsIGNsb25lJ3MgdmFsdWVzXG5cdFx0XHRpZiAoICFzdXBwb3J0LmNsZWFyQ2xvbmVTdHlsZSAmJiB2YWx1ZSA9PT0gXCJcIiAmJiBuYW1lLmluZGV4T2YoIFwiYmFja2dyb3VuZFwiICkgPT09IDAgKSB7XG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSBcImluaGVyaXRcIjtcblx0XHRcdH1cblxuXHRcdFx0Ly8gSWYgYSBob29rIHdhcyBwcm92aWRlZCwgdXNlIHRoYXQgdmFsdWUsIG90aGVyd2lzZSBqdXN0IHNldCB0aGUgc3BlY2lmaWVkIHZhbHVlXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHxcblx0XHRcdFx0KCB2YWx1ZSA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIGV4dHJhICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXG5cdFx0XHRcdHN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBub24tY29tcHV0ZWQgdmFsdWUgZnJvbSB0aGVyZVxuXHRcdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICYmXG5cdFx0XHRcdCggcmV0ID0gaG9va3MuZ2V0KCBlbGVtLCBmYWxzZSwgZXh0cmEgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cblx0XHRcdFx0cmV0dXJuIHJldDtcblx0XHRcdH1cblxuXHRcdFx0Ly8gT3RoZXJ3aXNlIGp1c3QgZ2V0IHRoZSB2YWx1ZSBmcm9tIHRoZSBzdHlsZSBvYmplY3Rcblx0XHRcdHJldHVybiBzdHlsZVsgbmFtZSBdO1xuXHRcdH1cblx0fSxcblxuXHRjc3M6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBleHRyYSwgc3R5bGVzICkge1xuXHRcdHZhciB2YWwsIG51bSwgaG9va3MsXG5cdFx0XHRvcmlnTmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIG5hbWUgKTtcblxuXHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHdlJ3JlIHdvcmtpbmcgd2l0aCB0aGUgcmlnaHQgbmFtZVxuXHRcdG5hbWUgPSBqUXVlcnkuY3NzUHJvcHNbIG9yaWdOYW1lIF0gfHxcblx0XHRcdCggalF1ZXJ5LmNzc1Byb3BzWyBvcmlnTmFtZSBdID0gdmVuZG9yUHJvcE5hbWUoIG9yaWdOYW1lICkgfHwgb3JpZ05hbWUgKTtcblxuXHRcdC8vIFRyeSBwcmVmaXhlZCBuYW1lIGZvbGxvd2VkIGJ5IHRoZSB1bnByZWZpeGVkIG5hbWVcblx0XHRob29rcyA9IGpRdWVyeS5jc3NIb29rc1sgbmFtZSBdIHx8IGpRdWVyeS5jc3NIb29rc1sgb3JpZ05hbWUgXTtcblxuXHRcdC8vIElmIGEgaG9vayB3YXMgcHJvdmlkZWQgZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBmcm9tIHRoZXJlXG5cdFx0aWYgKCBob29rcyAmJiBcImdldFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsID0gaG9va3MuZ2V0KCBlbGVtLCB0cnVlLCBleHRyYSApO1xuXHRcdH1cblxuXHRcdC8vIE90aGVyd2lzZSwgaWYgYSB3YXkgdG8gZ2V0IHRoZSBjb21wdXRlZCB2YWx1ZSBleGlzdHMsIHVzZSB0aGF0XG5cdFx0aWYgKCB2YWwgPT09IHVuZGVmaW5lZCApIHtcblx0XHRcdHZhbCA9IGN1ckNTUyggZWxlbSwgbmFtZSwgc3R5bGVzICk7XG5cdFx0fVxuXG5cdFx0Ly8gQ29udmVydCBcIm5vcm1hbFwiIHRvIGNvbXB1dGVkIHZhbHVlXG5cdFx0aWYgKCB2YWwgPT09IFwibm9ybWFsXCIgJiYgbmFtZSBpbiBjc3NOb3JtYWxUcmFuc2Zvcm0gKSB7XG5cdFx0XHR2YWwgPSBjc3NOb3JtYWxUcmFuc2Zvcm1bIG5hbWUgXTtcblx0XHR9XG5cblx0XHQvLyBNYWtlIG51bWVyaWMgaWYgZm9yY2VkIG9yIGEgcXVhbGlmaWVyIHdhcyBwcm92aWRlZCBhbmQgdmFsIGxvb2tzIG51bWVyaWNcblx0XHRpZiAoIGV4dHJhID09PSBcIlwiIHx8IGV4dHJhICkge1xuXHRcdFx0bnVtID0gcGFyc2VGbG9hdCggdmFsICk7XG5cdFx0XHRyZXR1cm4gZXh0cmEgPT09IHRydWUgfHwgaXNGaW5pdGUoIG51bSApID8gbnVtIHx8IDAgOiB2YWw7XG5cdFx0fVxuXHRcdHJldHVybiB2YWw7XG5cdH1cbn0gKTtcblxualF1ZXJ5LmVhY2goIFsgXCJoZWlnaHRcIiwgXCJ3aWR0aFwiIF0sIGZ1bmN0aW9uKCBpLCBuYW1lICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIG5hbWUgXSA9IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCwgZXh0cmEgKSB7XG5cdFx0XHRpZiAoIGNvbXB1dGVkICkge1xuXG5cdFx0XHRcdC8vIENlcnRhaW4gZWxlbWVudHMgY2FuIGhhdmUgZGltZW5zaW9uIGluZm8gaWYgd2UgaW52aXNpYmx5IHNob3cgdGhlbVxuXHRcdFx0XHQvLyBidXQgaXQgbXVzdCBoYXZlIGEgY3VycmVudCBkaXNwbGF5IHN0eWxlIHRoYXQgd291bGQgYmVuZWZpdFxuXHRcdFx0XHRyZXR1cm4gcmRpc3BsYXlzd2FwLnRlc3QoIGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICkgKSAmJlxuXHRcdFx0XHRcdGVsZW0ub2Zmc2V0V2lkdGggPT09IDAgP1xuXHRcdFx0XHRcdFx0c3dhcCggZWxlbSwgY3NzU2hvdywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiBnZXRXaWR0aE9ySGVpZ2h0KCBlbGVtLCBuYW1lLCBleHRyYSApO1xuXHRcdFx0XHRcdFx0fSApIDpcblx0XHRcdFx0XHRcdGdldFdpZHRoT3JIZWlnaHQoIGVsZW0sIG5hbWUsIGV4dHJhICk7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBleHRyYSApIHtcblx0XHRcdHZhciBtYXRjaGVzLFxuXHRcdFx0XHRzdHlsZXMgPSBleHRyYSAmJiBnZXRTdHlsZXMoIGVsZW0gKSxcblx0XHRcdFx0c3VidHJhY3QgPSBleHRyYSAmJiBhdWdtZW50V2lkdGhPckhlaWdodChcblx0XHRcdFx0XHRlbGVtLFxuXHRcdFx0XHRcdG5hbWUsXG5cdFx0XHRcdFx0ZXh0cmEsXG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgXCJib3hTaXppbmdcIiwgZmFsc2UsIHN0eWxlcyApID09PSBcImJvcmRlci1ib3hcIixcblx0XHRcdFx0XHRzdHlsZXNcblx0XHRcdFx0KTtcblxuXHRcdFx0Ly8gQ29udmVydCB0byBwaXhlbHMgaWYgdmFsdWUgYWRqdXN0bWVudCBpcyBuZWVkZWRcblx0XHRcdGlmICggc3VidHJhY3QgJiYgKCBtYXRjaGVzID0gcmNzc051bS5leGVjKCB2YWx1ZSApICkgJiZcblx0XHRcdFx0KCBtYXRjaGVzWyAzIF0gfHwgXCJweFwiICkgIT09IFwicHhcIiApIHtcblxuXHRcdFx0XHRlbGVtLnN0eWxlWyBuYW1lIF0gPSB2YWx1ZTtcblx0XHRcdFx0dmFsdWUgPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBzZXRQb3NpdGl2ZU51bWJlciggZWxlbSwgdmFsdWUsIHN1YnRyYWN0ICk7XG5cdFx0fVxuXHR9O1xufSApO1xuXG5qUXVlcnkuY3NzSG9va3MubWFyZ2luTGVmdCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpbkxlZnQsXG5cdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRpZiAoIGNvbXB1dGVkICkge1xuXHRcdFx0cmV0dXJuICggcGFyc2VGbG9hdCggY3VyQ1NTKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiApICkgfHxcblx0XHRcdFx0ZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0IC1cblx0XHRcdFx0XHRzd2FwKCBlbGVtLCB7IG1hcmdpbkxlZnQ6IDAgfSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS5sZWZ0O1xuXHRcdFx0XHRcdH0gKVxuXHRcdFx0XHQpICsgXCJweFwiO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gU3VwcG9ydDogQW5kcm9pZCAyLjNcbmpRdWVyeS5jc3NIb29rcy5tYXJnaW5SaWdodCA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5yZWxpYWJsZU1hcmdpblJpZ2h0LFxuXHRmdW5jdGlvbiggZWxlbSwgY29tcHV0ZWQgKSB7XG5cdFx0aWYgKCBjb21wdXRlZCApIHtcblx0XHRcdHJldHVybiBzd2FwKCBlbGVtLCB7IFwiZGlzcGxheVwiOiBcImlubGluZS1ibG9ja1wiIH0sXG5cdFx0XHRcdGN1ckNTUywgWyBlbGVtLCBcIm1hcmdpblJpZ2h0XCIgXSApO1xuXHRcdH1cblx0fVxuKTtcblxuLy8gVGhlc2UgaG9va3MgYXJlIHVzZWQgYnkgYW5pbWF0ZSB0byBleHBhbmQgcHJvcGVydGllc1xualF1ZXJ5LmVhY2goIHtcblx0bWFyZ2luOiBcIlwiLFxuXHRwYWRkaW5nOiBcIlwiLFxuXHRib3JkZXI6IFwiV2lkdGhcIlxufSwgZnVuY3Rpb24oIHByZWZpeCwgc3VmZml4ICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdID0ge1xuXHRcdGV4cGFuZDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdFx0dmFyIGkgPSAwLFxuXHRcdFx0XHRleHBhbmRlZCA9IHt9LFxuXG5cdFx0XHRcdC8vIEFzc3VtZXMgYSBzaW5nbGUgbnVtYmVyIGlmIG5vdCBhIHN0cmluZ1xuXHRcdFx0XHRwYXJ0cyA9IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiA/IHZhbHVlLnNwbGl0KCBcIiBcIiApIDogWyB2YWx1ZSBdO1xuXG5cdFx0XHRmb3IgKCA7IGkgPCA0OyBpKysgKSB7XG5cdFx0XHRcdGV4cGFuZGVkWyBwcmVmaXggKyBjc3NFeHBhbmRbIGkgXSArIHN1ZmZpeCBdID1cblx0XHRcdFx0XHRwYXJ0c1sgaSBdIHx8IHBhcnRzWyBpIC0gMiBdIHx8IHBhcnRzWyAwIF07XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBleHBhbmRlZDtcblx0XHR9XG5cdH07XG5cblx0aWYgKCAhcm1hcmdpbi50ZXN0KCBwcmVmaXggKSApIHtcblx0XHRqUXVlcnkuY3NzSG9va3NbIHByZWZpeCArIHN1ZmZpeCBdLnNldCA9IHNldFBvc2l0aXZlTnVtYmVyO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0Y3NzOiBmdW5jdGlvbiggbmFtZSwgdmFsdWUgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0dmFyIHN0eWxlcywgbGVuLFxuXHRcdFx0XHRtYXAgPSB7fSxcblx0XHRcdFx0aSA9IDA7XG5cblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIG5hbWUgKSApIHtcblx0XHRcdFx0c3R5bGVzID0gZ2V0U3R5bGVzKCBlbGVtICk7XG5cdFx0XHRcdGxlbiA9IG5hbWUubGVuZ3RoO1xuXG5cdFx0XHRcdGZvciAoIDsgaSA8IGxlbjsgaSsrICkge1xuXHRcdFx0XHRcdG1hcFsgbmFtZVsgaSBdIF0gPSBqUXVlcnkuY3NzKCBlbGVtLCBuYW1lWyBpIF0sIGZhbHNlLCBzdHlsZXMgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBtYXA7XG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB2YWx1ZSAhPT0gdW5kZWZpbmVkID9cblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBuYW1lLCB2YWx1ZSApIDpcblx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgbmFtZSApO1xuXHRcdH0sIG5hbWUsIHZhbHVlLCBhcmd1bWVudHMubGVuZ3RoID4gMSApO1xuXHR9LFxuXHRzaG93OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gc2hvd0hpZGUoIHRoaXMsIHRydWUgKTtcblx0fSxcblx0aGlkZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHNob3dIaWRlKCB0aGlzICk7XG5cdH0sXG5cdHRvZ2dsZTogZnVuY3Rpb24oIHN0YXRlICkge1xuXHRcdGlmICggdHlwZW9mIHN0YXRlID09PSBcImJvb2xlYW5cIiApIHtcblx0XHRcdHJldHVybiBzdGF0ZSA/IHRoaXMuc2hvdygpIDogdGhpcy5oaWRlKCk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIGlzSGlkZGVuKCB0aGlzICkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnNob3coKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLmhpZGUoKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuXG5mdW5jdGlvbiBUd2VlbiggZWxlbSwgb3B0aW9ucywgcHJvcCwgZW5kLCBlYXNpbmcgKSB7XG5cdHJldHVybiBuZXcgVHdlZW4ucHJvdG90eXBlLmluaXQoIGVsZW0sIG9wdGlvbnMsIHByb3AsIGVuZCwgZWFzaW5nICk7XG59XG5qUXVlcnkuVHdlZW4gPSBUd2VlbjtcblxuVHdlZW4ucHJvdG90eXBlID0ge1xuXHRjb25zdHJ1Y3RvcjogVHdlZW4sXG5cdGluaXQ6IGZ1bmN0aW9uKCBlbGVtLCBvcHRpb25zLCBwcm9wLCBlbmQsIGVhc2luZywgdW5pdCApIHtcblx0XHR0aGlzLmVsZW0gPSBlbGVtO1xuXHRcdHRoaXMucHJvcCA9IHByb3A7XG5cdFx0dGhpcy5lYXNpbmcgPSBlYXNpbmcgfHwgalF1ZXJ5LmVhc2luZy5fZGVmYXVsdDtcblx0XHR0aGlzLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRcdHRoaXMuc3RhcnQgPSB0aGlzLm5vdyA9IHRoaXMuY3VyKCk7XG5cdFx0dGhpcy5lbmQgPSBlbmQ7XG5cdFx0dGhpcy51bml0ID0gdW5pdCB8fCAoIGpRdWVyeS5jc3NOdW1iZXJbIHByb3AgXSA/IFwiXCIgOiBcInB4XCIgKTtcblx0fSxcblx0Y3VyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0cmV0dXJuIGhvb2tzICYmIGhvb2tzLmdldCA/XG5cdFx0XHRob29rcy5nZXQoIHRoaXMgKSA6XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuZ2V0KCB0aGlzICk7XG5cdH0sXG5cdHJ1bjogZnVuY3Rpb24oIHBlcmNlbnQgKSB7XG5cdFx0dmFyIGVhc2VkLFxuXHRcdFx0aG9va3MgPSBUd2Vlbi5wcm9wSG9va3NbIHRoaXMucHJvcCBdO1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuZHVyYXRpb24gKSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0galF1ZXJ5LmVhc2luZ1sgdGhpcy5lYXNpbmcgXShcblx0XHRcdFx0cGVyY2VudCwgdGhpcy5vcHRpb25zLmR1cmF0aW9uICogcGVyY2VudCwgMCwgMSwgdGhpcy5vcHRpb25zLmR1cmF0aW9uXG5cdFx0XHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLnBvcyA9IGVhc2VkID0gcGVyY2VudDtcblx0XHR9XG5cdFx0dGhpcy5ub3cgPSAoIHRoaXMuZW5kIC0gdGhpcy5zdGFydCApICogZWFzZWQgKyB0aGlzLnN0YXJ0O1xuXG5cdFx0aWYgKCB0aGlzLm9wdGlvbnMuc3RlcCApIHtcblx0XHRcdHRoaXMub3B0aW9ucy5zdGVwLmNhbGwoIHRoaXMuZWxlbSwgdGhpcy5ub3csIHRoaXMgKTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIGhvb2tzLnNldCApIHtcblx0XHRcdGhvb2tzLnNldCggdGhpcyApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRUd2Vlbi5wcm9wSG9va3MuX2RlZmF1bHQuc2V0KCB0aGlzICk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59O1xuXG5Ud2Vlbi5wcm90b3R5cGUuaW5pdC5wcm90b3R5cGUgPSBUd2Vlbi5wcm90b3R5cGU7XG5cblR3ZWVuLnByb3BIb29rcyA9IHtcblx0X2RlZmF1bHQ6IHtcblx0XHRnZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblx0XHRcdHZhciByZXN1bHQ7XG5cblx0XHRcdC8vIFVzZSBhIHByb3BlcnR5IG9uIHRoZSBlbGVtZW50IGRpcmVjdGx5IHdoZW4gaXQgaXMgbm90IGEgRE9NIGVsZW1lbnQsXG5cdFx0XHQvLyBvciB3aGVuIHRoZXJlIGlzIG5vIG1hdGNoaW5nIHN0eWxlIHByb3BlcnR5IHRoYXQgZXhpc3RzLlxuXHRcdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICE9PSAxIHx8XG5cdFx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSAhPSBudWxsICYmIHR3ZWVuLmVsZW0uc3R5bGVbIHR3ZWVuLnByb3AgXSA9PSBudWxsICkge1xuXHRcdFx0XHRyZXR1cm4gdHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBQYXNzaW5nIGFuIGVtcHR5IHN0cmluZyBhcyBhIDNyZCBwYXJhbWV0ZXIgdG8gLmNzcyB3aWxsIGF1dG9tYXRpY2FsbHlcblx0XHRcdC8vIGF0dGVtcHQgYSBwYXJzZUZsb2F0IGFuZCBmYWxsYmFjayB0byBhIHN0cmluZyBpZiB0aGUgcGFyc2UgZmFpbHMuXG5cdFx0XHQvLyBTaW1wbGUgdmFsdWVzIHN1Y2ggYXMgXCIxMHB4XCIgYXJlIHBhcnNlZCB0byBGbG9hdDtcblx0XHRcdC8vIGNvbXBsZXggdmFsdWVzIHN1Y2ggYXMgXCJyb3RhdGUoMXJhZClcIiBhcmUgcmV0dXJuZWQgYXMtaXMuXG5cdFx0XHRyZXN1bHQgPSBqUXVlcnkuY3NzKCB0d2Vlbi5lbGVtLCB0d2Vlbi5wcm9wLCBcIlwiICk7XG5cblx0XHRcdC8vIEVtcHR5IHN0cmluZ3MsIG51bGwsIHVuZGVmaW5lZCBhbmQgXCJhdXRvXCIgYXJlIGNvbnZlcnRlZCB0byAwLlxuXHRcdFx0cmV0dXJuICFyZXN1bHQgfHwgcmVzdWx0ID09PSBcImF1dG9cIiA/IDAgOiByZXN1bHQ7XG5cdFx0fSxcblx0XHRzZXQ6IGZ1bmN0aW9uKCB0d2VlbiApIHtcblxuXHRcdFx0Ly8gVXNlIHN0ZXAgaG9vayBmb3IgYmFjayBjb21wYXQuXG5cdFx0XHQvLyBVc2UgY3NzSG9vayBpZiBpdHMgdGhlcmUuXG5cdFx0XHQvLyBVc2UgLnN0eWxlIGlmIGF2YWlsYWJsZSBhbmQgdXNlIHBsYWluIHByb3BlcnRpZXMgd2hlcmUgYXZhaWxhYmxlLlxuXHRcdFx0aWYgKCBqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdICkge1xuXHRcdFx0XHRqUXVlcnkuZnguc3RlcFsgdHdlZW4ucHJvcCBdKCB0d2VlbiApO1xuXHRcdFx0fSBlbHNlIGlmICggdHdlZW4uZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHQoIHR3ZWVuLmVsZW0uc3R5bGVbIGpRdWVyeS5jc3NQcm9wc1sgdHdlZW4ucHJvcCBdIF0gIT0gbnVsbCB8fFxuXHRcdFx0XHRcdGpRdWVyeS5jc3NIb29rc1sgdHdlZW4ucHJvcCBdICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5zdHlsZSggdHdlZW4uZWxlbSwgdHdlZW4ucHJvcCwgdHdlZW4ubm93ICsgdHdlZW4udW5pdCApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dHdlZW4uZWxlbVsgdHdlZW4ucHJvcCBdID0gdHdlZW4ubm93O1xuXHRcdFx0fVxuXHRcdH1cblx0fVxufTtcblxuLy8gU3VwcG9ydDogSUU5XG4vLyBQYW5pYyBiYXNlZCBhcHByb2FjaCB0byBzZXR0aW5nIHRoaW5ncyBvbiBkaXNjb25uZWN0ZWQgbm9kZXNcblR3ZWVuLnByb3BIb29rcy5zY3JvbGxUb3AgPSBUd2Vlbi5wcm9wSG9va3Muc2Nyb2xsTGVmdCA9IHtcblx0c2V0OiBmdW5jdGlvbiggdHdlZW4gKSB7XG5cdFx0aWYgKCB0d2Vlbi5lbGVtLm5vZGVUeXBlICYmIHR3ZWVuLmVsZW0ucGFyZW50Tm9kZSApIHtcblx0XHRcdHR3ZWVuLmVsZW1bIHR3ZWVuLnByb3AgXSA9IHR3ZWVuLm5vdztcblx0XHR9XG5cdH1cbn07XG5cbmpRdWVyeS5lYXNpbmcgPSB7XG5cdGxpbmVhcjogZnVuY3Rpb24oIHAgKSB7XG5cdFx0cmV0dXJuIHA7XG5cdH0sXG5cdHN3aW5nOiBmdW5jdGlvbiggcCApIHtcblx0XHRyZXR1cm4gMC41IC0gTWF0aC5jb3MoIHAgKiBNYXRoLlBJICkgLyAyO1xuXHR9LFxuXHRfZGVmYXVsdDogXCJzd2luZ1wiXG59O1xuXG5qUXVlcnkuZnggPSBUd2Vlbi5wcm90b3R5cGUuaW5pdDtcblxuLy8gQmFjayBDb21wYXQgPDEuOCBleHRlbnNpb24gcG9pbnRcbmpRdWVyeS5meC5zdGVwID0ge307XG5cblxuXG5cbnZhclxuXHRmeE5vdywgdGltZXJJZCxcblx0cmZ4dHlwZXMgPSAvXig/OnRvZ2dsZXxzaG93fGhpZGUpJC8sXG5cdHJydW4gPSAvcXVldWVIb29rcyQvO1xuXG4vLyBBbmltYXRpb25zIGNyZWF0ZWQgc3luY2hyb25vdXNseSB3aWxsIHJ1biBzeW5jaHJvbm91c2x5XG5mdW5jdGlvbiBjcmVhdGVGeE5vdygpIHtcblx0d2luZG93LnNldFRpbWVvdXQoIGZ1bmN0aW9uKCkge1xuXHRcdGZ4Tm93ID0gdW5kZWZpbmVkO1xuXHR9ICk7XG5cdHJldHVybiAoIGZ4Tm93ID0galF1ZXJ5Lm5vdygpICk7XG59XG5cbi8vIEdlbmVyYXRlIHBhcmFtZXRlcnMgdG8gY3JlYXRlIGEgc3RhbmRhcmQgYW5pbWF0aW9uXG5mdW5jdGlvbiBnZW5GeCggdHlwZSwgaW5jbHVkZVdpZHRoICkge1xuXHR2YXIgd2hpY2gsXG5cdFx0aSA9IDAsXG5cdFx0YXR0cnMgPSB7IGhlaWdodDogdHlwZSB9O1xuXG5cdC8vIElmIHdlIGluY2x1ZGUgd2lkdGgsIHN0ZXAgdmFsdWUgaXMgMSB0byBkbyBhbGwgY3NzRXhwYW5kIHZhbHVlcyxcblx0Ly8gb3RoZXJ3aXNlIHN0ZXAgdmFsdWUgaXMgMiB0byBza2lwIG92ZXIgTGVmdCBhbmQgUmlnaHRcblx0aW5jbHVkZVdpZHRoID0gaW5jbHVkZVdpZHRoID8gMSA6IDA7XG5cdGZvciAoIDsgaSA8IDQgOyBpICs9IDIgLSBpbmNsdWRlV2lkdGggKSB7XG5cdFx0d2hpY2ggPSBjc3NFeHBhbmRbIGkgXTtcblx0XHRhdHRyc1sgXCJtYXJnaW5cIiArIHdoaWNoIF0gPSBhdHRyc1sgXCJwYWRkaW5nXCIgKyB3aGljaCBdID0gdHlwZTtcblx0fVxuXG5cdGlmICggaW5jbHVkZVdpZHRoICkge1xuXHRcdGF0dHJzLm9wYWNpdHkgPSBhdHRycy53aWR0aCA9IHR5cGU7XG5cdH1cblxuXHRyZXR1cm4gYXR0cnM7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVR3ZWVuKCB2YWx1ZSwgcHJvcCwgYW5pbWF0aW9uICkge1xuXHR2YXIgdHdlZW4sXG5cdFx0Y29sbGVjdGlvbiA9ICggQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW10gKS5jb25jYXQoIEFuaW1hdGlvbi50d2VlbmVyc1sgXCIqXCIgXSApLFxuXHRcdGluZGV4ID0gMCxcblx0XHRsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRpZiAoICggdHdlZW4gPSBjb2xsZWN0aW9uWyBpbmRleCBdLmNhbGwoIGFuaW1hdGlvbiwgcHJvcCwgdmFsdWUgKSApICkge1xuXG5cdFx0XHQvLyBXZSdyZSBkb25lIHdpdGggdGhpcyBwcm9wZXJ0eVxuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBkZWZhdWx0UHJlZmlsdGVyKCBlbGVtLCBwcm9wcywgb3B0cyApIHtcblx0LyoganNoaW50IHZhbGlkdGhpczogdHJ1ZSAqL1xuXHR2YXIgcHJvcCwgdmFsdWUsIHRvZ2dsZSwgdHdlZW4sIGhvb2tzLCBvbGRmaXJlLCBkaXNwbGF5LCBjaGVja0Rpc3BsYXksXG5cdFx0YW5pbSA9IHRoaXMsXG5cdFx0b3JpZyA9IHt9LFxuXHRcdHN0eWxlID0gZWxlbS5zdHlsZSxcblx0XHRoaWRkZW4gPSBlbGVtLm5vZGVUeXBlICYmIGlzSGlkZGVuKCBlbGVtICksXG5cdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5nZXQoIGVsZW0sIFwiZnhzaG93XCIgKTtcblxuXHQvLyBIYW5kbGUgcXVldWU6IGZhbHNlIHByb21pc2VzXG5cdGlmICggIW9wdHMucXVldWUgKSB7XG5cdFx0aG9va3MgPSBqUXVlcnkuX3F1ZXVlSG9va3MoIGVsZW0sIFwiZnhcIiApO1xuXHRcdGlmICggaG9va3MudW5xdWV1ZWQgPT0gbnVsbCApIHtcblx0XHRcdGhvb2tzLnVucXVldWVkID0gMDtcblx0XHRcdG9sZGZpcmUgPSBob29rcy5lbXB0eS5maXJlO1xuXHRcdFx0aG9va3MuZW1wdHkuZmlyZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoICFob29rcy51bnF1ZXVlZCApIHtcblx0XHRcdFx0XHRvbGRmaXJlKCk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0fVxuXHRcdGhvb2tzLnVucXVldWVkKys7XG5cblx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cblx0XHRcdC8vIEVuc3VyZSB0aGUgY29tcGxldGUgaGFuZGxlciBpcyBjYWxsZWQgYmVmb3JlIHRoaXMgY29tcGxldGVzXG5cdFx0XHRhbmltLmFsd2F5cyggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGhvb2tzLnVucXVldWVkLS07XG5cdFx0XHRcdGlmICggIWpRdWVyeS5xdWV1ZSggZWxlbSwgXCJmeFwiICkubGVuZ3RoICkge1xuXHRcdFx0XHRcdGhvb2tzLmVtcHR5LmZpcmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0fSApO1xuXHRcdH0gKTtcblx0fVxuXG5cdC8vIEhlaWdodC93aWR0aCBvdmVyZmxvdyBwYXNzXG5cdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMSAmJiAoIFwiaGVpZ2h0XCIgaW4gcHJvcHMgfHwgXCJ3aWR0aFwiIGluIHByb3BzICkgKSB7XG5cblx0XHQvLyBNYWtlIHN1cmUgdGhhdCBub3RoaW5nIHNuZWFrcyBvdXRcblx0XHQvLyBSZWNvcmQgYWxsIDMgb3ZlcmZsb3cgYXR0cmlidXRlcyBiZWNhdXNlIElFOS0xMCBkbyBub3Rcblx0XHQvLyBjaGFuZ2UgdGhlIG92ZXJmbG93IGF0dHJpYnV0ZSB3aGVuIG92ZXJmbG93WCBhbmRcblx0XHQvLyBvdmVyZmxvd1kgYXJlIHNldCB0byB0aGUgc2FtZSB2YWx1ZVxuXHRcdG9wdHMub3ZlcmZsb3cgPSBbIHN0eWxlLm92ZXJmbG93LCBzdHlsZS5vdmVyZmxvd1gsIHN0eWxlLm92ZXJmbG93WSBdO1xuXG5cdFx0Ly8gU2V0IGRpc3BsYXkgcHJvcGVydHkgdG8gaW5saW5lLWJsb2NrIGZvciBoZWlnaHQvd2lkdGhcblx0XHQvLyBhbmltYXRpb25zIG9uIGlubGluZSBlbGVtZW50cyB0aGF0IGFyZSBoYXZpbmcgd2lkdGgvaGVpZ2h0IGFuaW1hdGVkXG5cdFx0ZGlzcGxheSA9IGpRdWVyeS5jc3MoIGVsZW0sIFwiZGlzcGxheVwiICk7XG5cblx0XHQvLyBUZXN0IGRlZmF1bHQgZGlzcGxheSBpZiBkaXNwbGF5IGlzIGN1cnJlbnRseSBcIm5vbmVcIlxuXHRcdGNoZWNrRGlzcGxheSA9IGRpc3BsYXkgPT09IFwibm9uZVwiID9cblx0XHRcdGRhdGFQcml2LmdldCggZWxlbSwgXCJvbGRkaXNwbGF5XCIgKSB8fCBkZWZhdWx0RGlzcGxheSggZWxlbS5ub2RlTmFtZSApIDogZGlzcGxheTtcblxuXHRcdGlmICggY2hlY2tEaXNwbGF5ID09PSBcImlubGluZVwiICYmIGpRdWVyeS5jc3MoIGVsZW0sIFwiZmxvYXRcIiApID09PSBcIm5vbmVcIiApIHtcblx0XHRcdHN0eWxlLmRpc3BsYXkgPSBcImlubGluZS1ibG9ja1wiO1xuXHRcdH1cblx0fVxuXG5cdGlmICggb3B0cy5vdmVyZmxvdyApIHtcblx0XHRzdHlsZS5vdmVyZmxvdyA9IFwiaGlkZGVuXCI7XG5cdFx0YW5pbS5hbHdheXMoIGZ1bmN0aW9uKCkge1xuXHRcdFx0c3R5bGUub3ZlcmZsb3cgPSBvcHRzLm92ZXJmbG93WyAwIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1ggPSBvcHRzLm92ZXJmbG93WyAxIF07XG5cdFx0XHRzdHlsZS5vdmVyZmxvd1kgPSBvcHRzLm92ZXJmbG93WyAyIF07XG5cdFx0fSApO1xuXHR9XG5cblx0Ly8gc2hvdy9oaWRlIHBhc3Ncblx0Zm9yICggcHJvcCBpbiBwcm9wcyApIHtcblx0XHR2YWx1ZSA9IHByb3BzWyBwcm9wIF07XG5cdFx0aWYgKCByZnh0eXBlcy5leGVjKCB2YWx1ZSApICkge1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBwcm9wIF07XG5cdFx0XHR0b2dnbGUgPSB0b2dnbGUgfHwgdmFsdWUgPT09IFwidG9nZ2xlXCI7XG5cdFx0XHRpZiAoIHZhbHVlID09PSAoIGhpZGRlbiA/IFwiaGlkZVwiIDogXCJzaG93XCIgKSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBkYXRhU2hvdyBsZWZ0IG92ZXIgZnJvbSBhIHN0b3BwZWQgaGlkZSBvciBzaG93XG5cdFx0XHRcdC8vIGFuZCB3ZSBhcmUgZ29pbmcgdG8gcHJvY2VlZCB3aXRoIHNob3csIHdlIHNob3VsZCBwcmV0ZW5kIHRvIGJlIGhpZGRlblxuXHRcdFx0XHRpZiAoIHZhbHVlID09PSBcInNob3dcIiAmJiBkYXRhU2hvdyAmJiBkYXRhU2hvd1sgcHJvcCBdICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0aGlkZGVuID0gdHJ1ZTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRjb250aW51ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0b3JpZ1sgcHJvcCBdID0gZGF0YVNob3cgJiYgZGF0YVNob3dbIHByb3AgXSB8fCBqUXVlcnkuc3R5bGUoIGVsZW0sIHByb3AgKTtcblxuXHRcdC8vIEFueSBub24tZnggdmFsdWUgc3RvcHMgdXMgZnJvbSByZXN0b3JpbmcgdGhlIG9yaWdpbmFsIGRpc3BsYXkgdmFsdWVcblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGlzcGxheSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH1cblxuXHRpZiAoICFqUXVlcnkuaXNFbXB0eU9iamVjdCggb3JpZyApICkge1xuXHRcdGlmICggZGF0YVNob3cgKSB7XG5cdFx0XHRpZiAoIFwiaGlkZGVuXCIgaW4gZGF0YVNob3cgKSB7XG5cdFx0XHRcdGhpZGRlbiA9IGRhdGFTaG93LmhpZGRlbjtcblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0ZGF0YVNob3cgPSBkYXRhUHJpdi5hY2Nlc3MoIGVsZW0sIFwiZnhzaG93XCIsIHt9ICk7XG5cdFx0fVxuXG5cdFx0Ly8gU3RvcmUgc3RhdGUgaWYgaXRzIHRvZ2dsZSAtIGVuYWJsZXMgLnN0b3AoKS50b2dnbGUoKSB0byBcInJldmVyc2VcIlxuXHRcdGlmICggdG9nZ2xlICkge1xuXHRcdFx0ZGF0YVNob3cuaGlkZGVuID0gIWhpZGRlbjtcblx0XHR9XG5cdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRqUXVlcnkoIGVsZW0gKS5zaG93KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGFuaW0uZG9uZSggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGpRdWVyeSggZWxlbSApLmhpZGUoKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cdFx0YW5pbS5kb25lKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwcm9wO1xuXG5cdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGVsZW0sIFwiZnhzaG93XCIgKTtcblx0XHRcdGZvciAoIHByb3AgaW4gb3JpZyApIHtcblx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCBwcm9wLCBvcmlnWyBwcm9wIF0gKTtcblx0XHRcdH1cblx0XHR9ICk7XG5cdFx0Zm9yICggcHJvcCBpbiBvcmlnICkge1xuXHRcdFx0dHdlZW4gPSBjcmVhdGVUd2VlbiggaGlkZGVuID8gZGF0YVNob3dbIHByb3AgXSA6IDAsIHByb3AsIGFuaW0gKTtcblxuXHRcdFx0aWYgKCAhKCBwcm9wIGluIGRhdGFTaG93ICkgKSB7XG5cdFx0XHRcdGRhdGFTaG93WyBwcm9wIF0gPSB0d2Vlbi5zdGFydDtcblx0XHRcdFx0aWYgKCBoaWRkZW4gKSB7XG5cdFx0XHRcdFx0dHdlZW4uZW5kID0gdHdlZW4uc3RhcnQ7XG5cdFx0XHRcdFx0dHdlZW4uc3RhcnQgPSBwcm9wID09PSBcIndpZHRoXCIgfHwgcHJvcCA9PT0gXCJoZWlnaHRcIiA/IDEgOiAwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdC8vIElmIHRoaXMgaXMgYSBub29wIGxpa2UgLmhpZGUoKS5oaWRlKCksIHJlc3RvcmUgYW4gb3ZlcndyaXR0ZW4gZGlzcGxheSB2YWx1ZVxuXHR9IGVsc2UgaWYgKCAoIGRpc3BsYXkgPT09IFwibm9uZVwiID8gZGVmYXVsdERpc3BsYXkoIGVsZW0ubm9kZU5hbWUgKSA6IGRpc3BsYXkgKSA9PT0gXCJpbmxpbmVcIiApIHtcblx0XHRzdHlsZS5kaXNwbGF5ID0gZGlzcGxheTtcblx0fVxufVxuXG5mdW5jdGlvbiBwcm9wRmlsdGVyKCBwcm9wcywgc3BlY2lhbEVhc2luZyApIHtcblx0dmFyIGluZGV4LCBuYW1lLCBlYXNpbmcsIHZhbHVlLCBob29rcztcblxuXHQvLyBjYW1lbENhc2UsIHNwZWNpYWxFYXNpbmcgYW5kIGV4cGFuZCBjc3NIb29rIHBhc3Ncblx0Zm9yICggaW5kZXggaW4gcHJvcHMgKSB7XG5cdFx0bmFtZSA9IGpRdWVyeS5jYW1lbENhc2UoIGluZGV4ICk7XG5cdFx0ZWFzaW5nID0gc3BlY2lhbEVhc2luZ1sgbmFtZSBdO1xuXHRcdHZhbHVlID0gcHJvcHNbIGluZGV4IF07XG5cdFx0aWYgKCBqUXVlcnkuaXNBcnJheSggdmFsdWUgKSApIHtcblx0XHRcdGVhc2luZyA9IHZhbHVlWyAxIF07XG5cdFx0XHR2YWx1ZSA9IHByb3BzWyBpbmRleCBdID0gdmFsdWVbIDAgXTtcblx0XHR9XG5cblx0XHRpZiAoIGluZGV4ICE9PSBuYW1lICkge1xuXHRcdFx0cHJvcHNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0ZGVsZXRlIHByb3BzWyBpbmRleCBdO1xuXHRcdH1cblxuXHRcdGhvb2tzID0galF1ZXJ5LmNzc0hvb2tzWyBuYW1lIF07XG5cdFx0aWYgKCBob29rcyAmJiBcImV4cGFuZFwiIGluIGhvb2tzICkge1xuXHRcdFx0dmFsdWUgPSBob29rcy5leHBhbmQoIHZhbHVlICk7XG5cdFx0XHRkZWxldGUgcHJvcHNbIG5hbWUgXTtcblxuXHRcdFx0Ly8gTm90IHF1aXRlICQuZXh0ZW5kLCB0aGlzIHdvbid0IG92ZXJ3cml0ZSBleGlzdGluZyBrZXlzLlxuXHRcdFx0Ly8gUmV1c2luZyAnaW5kZXgnIGJlY2F1c2Ugd2UgaGF2ZSB0aGUgY29ycmVjdCBcIm5hbWVcIlxuXHRcdFx0Zm9yICggaW5kZXggaW4gdmFsdWUgKSB7XG5cdFx0XHRcdGlmICggISggaW5kZXggaW4gcHJvcHMgKSApIHtcblx0XHRcdFx0XHRwcm9wc1sgaW5kZXggXSA9IHZhbHVlWyBpbmRleCBdO1xuXHRcdFx0XHRcdHNwZWNpYWxFYXNpbmdbIGluZGV4IF0gPSBlYXNpbmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9IGVsc2Uge1xuXHRcdFx0c3BlY2lhbEVhc2luZ1sgbmFtZSBdID0gZWFzaW5nO1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBBbmltYXRpb24oIGVsZW0sIHByb3BlcnRpZXMsIG9wdGlvbnMgKSB7XG5cdHZhciByZXN1bHQsXG5cdFx0c3RvcHBlZCxcblx0XHRpbmRleCA9IDAsXG5cdFx0bGVuZ3RoID0gQW5pbWF0aW9uLnByZWZpbHRlcnMubGVuZ3RoLFxuXHRcdGRlZmVycmVkID0galF1ZXJ5LkRlZmVycmVkKCkuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gRG9uJ3QgbWF0Y2ggZWxlbSBpbiB0aGUgOmFuaW1hdGVkIHNlbGVjdG9yXG5cdFx0XHRkZWxldGUgdGljay5lbGVtO1xuXHRcdH0gKSxcblx0XHR0aWNrID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRpZiAoIHN0b3BwZWQgKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHZhciBjdXJyZW50VGltZSA9IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRcdHJlbWFpbmluZyA9IE1hdGgubWF4KCAwLCBhbmltYXRpb24uc3RhcnRUaW1lICsgYW5pbWF0aW9uLmR1cmF0aW9uIC0gY3VycmVudFRpbWUgKSxcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuXHRcdFx0XHQvLyBBcmNoYWljIGNyYXNoIGJ1ZyB3b24ndCBhbGxvdyB1cyB0byB1c2UgYDEgLSAoIDAuNSB8fCAwIClgICgjMTI0OTcpXG5cdFx0XHRcdHRlbXAgPSByZW1haW5pbmcgLyBhbmltYXRpb24uZHVyYXRpb24gfHwgMCxcblx0XHRcdFx0cGVyY2VudCA9IDEgLSB0ZW1wLFxuXHRcdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRcdGxlbmd0aCA9IGFuaW1hdGlvbi50d2VlbnMubGVuZ3RoO1xuXG5cdFx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIHBlcmNlbnQgKTtcblx0XHRcdH1cblxuXHRcdFx0ZGVmZXJyZWQubm90aWZ5V2l0aCggZWxlbSwgWyBhbmltYXRpb24sIHBlcmNlbnQsIHJlbWFpbmluZyBdICk7XG5cblx0XHRcdGlmICggcGVyY2VudCA8IDEgJiYgbGVuZ3RoICkge1xuXHRcdFx0XHRyZXR1cm4gcmVtYWluaW5nO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uIF0gKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0YW5pbWF0aW9uID0gZGVmZXJyZWQucHJvbWlzZSgge1xuXHRcdFx0ZWxlbTogZWxlbSxcblx0XHRcdHByb3BzOiBqUXVlcnkuZXh0ZW5kKCB7fSwgcHJvcGVydGllcyApLFxuXHRcdFx0b3B0czogalF1ZXJ5LmV4dGVuZCggdHJ1ZSwge1xuXHRcdFx0XHRzcGVjaWFsRWFzaW5nOiB7fSxcblx0XHRcdFx0ZWFzaW5nOiBqUXVlcnkuZWFzaW5nLl9kZWZhdWx0XG5cdFx0XHR9LCBvcHRpb25zICksXG5cdFx0XHRvcmlnaW5hbFByb3BlcnRpZXM6IHByb3BlcnRpZXMsXG5cdFx0XHRvcmlnaW5hbE9wdGlvbnM6IG9wdGlvbnMsXG5cdFx0XHRzdGFydFRpbWU6IGZ4Tm93IHx8IGNyZWF0ZUZ4Tm93KCksXG5cdFx0XHRkdXJhdGlvbjogb3B0aW9ucy5kdXJhdGlvbixcblx0XHRcdHR3ZWVuczogW10sXG5cdFx0XHRjcmVhdGVUd2VlbjogZnVuY3Rpb24oIHByb3AsIGVuZCApIHtcblx0XHRcdFx0dmFyIHR3ZWVuID0galF1ZXJ5LlR3ZWVuKCBlbGVtLCBhbmltYXRpb24ub3B0cywgcHJvcCwgZW5kLFxuXHRcdFx0XHRcdFx0YW5pbWF0aW9uLm9wdHMuc3BlY2lhbEVhc2luZ1sgcHJvcCBdIHx8IGFuaW1hdGlvbi5vcHRzLmVhc2luZyApO1xuXHRcdFx0XHRhbmltYXRpb24udHdlZW5zLnB1c2goIHR3ZWVuICk7XG5cdFx0XHRcdHJldHVybiB0d2Vlbjtcblx0XHRcdH0sXG5cdFx0XHRzdG9wOiBmdW5jdGlvbiggZ290b0VuZCApIHtcblx0XHRcdFx0dmFyIGluZGV4ID0gMCxcblxuXHRcdFx0XHRcdC8vIElmIHdlIGFyZSBnb2luZyB0byB0aGUgZW5kLCB3ZSB3YW50IHRvIHJ1biBhbGwgdGhlIHR3ZWVuc1xuXHRcdFx0XHRcdC8vIG90aGVyd2lzZSB3ZSBza2lwIHRoaXMgcGFydFxuXHRcdFx0XHRcdGxlbmd0aCA9IGdvdG9FbmQgPyBhbmltYXRpb24udHdlZW5zLmxlbmd0aCA6IDA7XG5cdFx0XHRcdGlmICggc3RvcHBlZCApIHtcblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fVxuXHRcdFx0XHRzdG9wcGVkID0gdHJ1ZTtcblx0XHRcdFx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0XHRcdFx0YW5pbWF0aW9uLnR3ZWVuc1sgaW5kZXggXS5ydW4oIDEgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFJlc29sdmUgd2hlbiB3ZSBwbGF5ZWQgdGhlIGxhc3QgZnJhbWU7IG90aGVyd2lzZSwgcmVqZWN0XG5cdFx0XHRcdGlmICggZ290b0VuZCApIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5ub3RpZnlXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgMSwgMCBdICk7XG5cdFx0XHRcdFx0ZGVmZXJyZWQucmVzb2x2ZVdpdGgoIGVsZW0sIFsgYW5pbWF0aW9uLCBnb3RvRW5kIF0gKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWZlcnJlZC5yZWplY3RXaXRoKCBlbGVtLCBbIGFuaW1hdGlvbiwgZ290b0VuZCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHR9XG5cdFx0fSApLFxuXHRcdHByb3BzID0gYW5pbWF0aW9uLnByb3BzO1xuXG5cdHByb3BGaWx0ZXIoIHByb3BzLCBhbmltYXRpb24ub3B0cy5zcGVjaWFsRWFzaW5nICk7XG5cblx0Zm9yICggOyBpbmRleCA8IGxlbmd0aCA7IGluZGV4KysgKSB7XG5cdFx0cmVzdWx0ID0gQW5pbWF0aW9uLnByZWZpbHRlcnNbIGluZGV4IF0uY2FsbCggYW5pbWF0aW9uLCBlbGVtLCBwcm9wcywgYW5pbWF0aW9uLm9wdHMgKTtcblx0XHRpZiAoIHJlc3VsdCApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHJlc3VsdC5zdG9wICkgKSB7XG5cdFx0XHRcdGpRdWVyeS5fcXVldWVIb29rcyggYW5pbWF0aW9uLmVsZW0sIGFuaW1hdGlvbi5vcHRzLnF1ZXVlICkuc3RvcCA9XG5cdFx0XHRcdFx0alF1ZXJ5LnByb3h5KCByZXN1bHQuc3RvcCwgcmVzdWx0ICk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcmVzdWx0O1xuXHRcdH1cblx0fVxuXG5cdGpRdWVyeS5tYXAoIHByb3BzLCBjcmVhdGVUd2VlbiwgYW5pbWF0aW9uICk7XG5cblx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggYW5pbWF0aW9uLm9wdHMuc3RhcnQgKSApIHtcblx0XHRhbmltYXRpb24ub3B0cy5zdGFydC5jYWxsKCBlbGVtLCBhbmltYXRpb24gKTtcblx0fVxuXG5cdGpRdWVyeS5meC50aW1lcihcblx0XHRqUXVlcnkuZXh0ZW5kKCB0aWNrLCB7XG5cdFx0XHRlbGVtOiBlbGVtLFxuXHRcdFx0YW5pbTogYW5pbWF0aW9uLFxuXHRcdFx0cXVldWU6IGFuaW1hdGlvbi5vcHRzLnF1ZXVlXG5cdFx0fSApXG5cdCk7XG5cblx0Ly8gYXR0YWNoIGNhbGxiYWNrcyBmcm9tIG9wdGlvbnNcblx0cmV0dXJuIGFuaW1hdGlvbi5wcm9ncmVzcyggYW5pbWF0aW9uLm9wdHMucHJvZ3Jlc3MgKVxuXHRcdC5kb25lKCBhbmltYXRpb24ub3B0cy5kb25lLCBhbmltYXRpb24ub3B0cy5jb21wbGV0ZSApXG5cdFx0LmZhaWwoIGFuaW1hdGlvbi5vcHRzLmZhaWwgKVxuXHRcdC5hbHdheXMoIGFuaW1hdGlvbi5vcHRzLmFsd2F5cyApO1xufVxuXG5qUXVlcnkuQW5pbWF0aW9uID0galF1ZXJ5LmV4dGVuZCggQW5pbWF0aW9uLCB7XG5cdHR3ZWVuZXJzOiB7XG5cdFx0XCIqXCI6IFsgZnVuY3Rpb24oIHByb3AsIHZhbHVlICkge1xuXHRcdFx0dmFyIHR3ZWVuID0gdGhpcy5jcmVhdGVUd2VlbiggcHJvcCwgdmFsdWUgKTtcblx0XHRcdGFkanVzdENTUyggdHdlZW4uZWxlbSwgcHJvcCwgcmNzc051bS5leGVjKCB2YWx1ZSApLCB0d2VlbiApO1xuXHRcdFx0cmV0dXJuIHR3ZWVuO1xuXHRcdH0gXVxuXHR9LFxuXG5cdHR3ZWVuZXI6IGZ1bmN0aW9uKCBwcm9wcywgY2FsbGJhY2sgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggcHJvcHMgKSApIHtcblx0XHRcdGNhbGxiYWNrID0gcHJvcHM7XG5cdFx0XHRwcm9wcyA9IFsgXCIqXCIgXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cHJvcHMgPSBwcm9wcy5tYXRjaCggcm5vdHdoaXRlICk7XG5cdFx0fVxuXG5cdFx0dmFyIHByb3AsXG5cdFx0XHRpbmRleCA9IDAsXG5cdFx0XHRsZW5ndGggPSBwcm9wcy5sZW5ndGg7XG5cblx0XHRmb3IgKCA7IGluZGV4IDwgbGVuZ3RoIDsgaW5kZXgrKyApIHtcblx0XHRcdHByb3AgPSBwcm9wc1sgaW5kZXggXTtcblx0XHRcdEFuaW1hdGlvbi50d2VlbmVyc1sgcHJvcCBdID0gQW5pbWF0aW9uLnR3ZWVuZXJzWyBwcm9wIF0gfHwgW107XG5cdFx0XHRBbmltYXRpb24udHdlZW5lcnNbIHByb3AgXS51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH1cblx0fSxcblxuXHRwcmVmaWx0ZXJzOiBbIGRlZmF1bHRQcmVmaWx0ZXIgXSxcblxuXHRwcmVmaWx0ZXI6IGZ1bmN0aW9uKCBjYWxsYmFjaywgcHJlcGVuZCApIHtcblx0XHRpZiAoIHByZXBlbmQgKSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy51bnNoaWZ0KCBjYWxsYmFjayApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRBbmltYXRpb24ucHJlZmlsdGVycy5wdXNoKCBjYWxsYmFjayApO1xuXHRcdH1cblx0fVxufSApO1xuXG5qUXVlcnkuc3BlZWQgPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgZm4gKSB7XG5cdHZhciBvcHQgPSBzcGVlZCAmJiB0eXBlb2Ygc3BlZWQgPT09IFwib2JqZWN0XCIgPyBqUXVlcnkuZXh0ZW5kKCB7fSwgc3BlZWQgKSA6IHtcblx0XHRjb21wbGV0ZTogZm4gfHwgIWZuICYmIGVhc2luZyB8fFxuXHRcdFx0alF1ZXJ5LmlzRnVuY3Rpb24oIHNwZWVkICkgJiYgc3BlZWQsXG5cdFx0ZHVyYXRpb246IHNwZWVkLFxuXHRcdGVhc2luZzogZm4gJiYgZWFzaW5nIHx8IGVhc2luZyAmJiAhalF1ZXJ5LmlzRnVuY3Rpb24oIGVhc2luZyApICYmIGVhc2luZ1xuXHR9O1xuXG5cdG9wdC5kdXJhdGlvbiA9IGpRdWVyeS5meC5vZmYgPyAwIDogdHlwZW9mIG9wdC5kdXJhdGlvbiA9PT0gXCJudW1iZXJcIiA/XG5cdFx0b3B0LmR1cmF0aW9uIDogb3B0LmR1cmF0aW9uIGluIGpRdWVyeS5meC5zcGVlZHMgP1xuXHRcdFx0alF1ZXJ5LmZ4LnNwZWVkc1sgb3B0LmR1cmF0aW9uIF0gOiBqUXVlcnkuZnguc3BlZWRzLl9kZWZhdWx0O1xuXG5cdC8vIE5vcm1hbGl6ZSBvcHQucXVldWUgLSB0cnVlL3VuZGVmaW5lZC9udWxsIC0+IFwiZnhcIlxuXHRpZiAoIG9wdC5xdWV1ZSA9PSBudWxsIHx8IG9wdC5xdWV1ZSA9PT0gdHJ1ZSApIHtcblx0XHRvcHQucXVldWUgPSBcImZ4XCI7XG5cdH1cblxuXHQvLyBRdWV1ZWluZ1xuXHRvcHQub2xkID0gb3B0LmNvbXBsZXRlO1xuXG5cdG9wdC5jb21wbGV0ZSA9IGZ1bmN0aW9uKCkge1xuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIG9wdC5vbGQgKSApIHtcblx0XHRcdG9wdC5vbGQuY2FsbCggdGhpcyApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0LnF1ZXVlICkge1xuXHRcdFx0alF1ZXJ5LmRlcXVldWUoIHRoaXMsIG9wdC5xdWV1ZSApO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gb3B0O1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRmYWRlVG86IGZ1bmN0aW9uKCBzcGVlZCwgdG8sIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cblx0XHQvLyBTaG93IGFueSBoaWRkZW4gZWxlbWVudHMgYWZ0ZXIgc2V0dGluZyBvcGFjaXR5IHRvIDBcblx0XHRyZXR1cm4gdGhpcy5maWx0ZXIoIGlzSGlkZGVuICkuY3NzKCBcIm9wYWNpdHlcIiwgMCApLnNob3coKVxuXG5cdFx0XHQvLyBBbmltYXRlIHRvIHRoZSB2YWx1ZSBzcGVjaWZpZWRcblx0XHRcdC5lbmQoKS5hbmltYXRlKCB7IG9wYWNpdHk6IHRvIH0sIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH0sXG5cdGFuaW1hdGU6IGZ1bmN0aW9uKCBwcm9wLCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHR2YXIgZW1wdHkgPSBqUXVlcnkuaXNFbXB0eU9iamVjdCggcHJvcCApLFxuXHRcdFx0b3B0YWxsID0galF1ZXJ5LnNwZWVkKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApLFxuXHRcdFx0ZG9BbmltYXRpb24gPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHQvLyBPcGVyYXRlIG9uIGEgY29weSBvZiBwcm9wIHNvIHBlci1wcm9wZXJ0eSBlYXNpbmcgd29uJ3QgYmUgbG9zdFxuXHRcdFx0XHR2YXIgYW5pbSA9IEFuaW1hdGlvbiggdGhpcywgalF1ZXJ5LmV4dGVuZCgge30sIHByb3AgKSwgb3B0YWxsICk7XG5cblx0XHRcdFx0Ly8gRW1wdHkgYW5pbWF0aW9ucywgb3IgZmluaXNoaW5nIHJlc29sdmVzIGltbWVkaWF0ZWx5XG5cdFx0XHRcdGlmICggZW1wdHkgfHwgZGF0YVByaXYuZ2V0KCB0aGlzLCBcImZpbmlzaFwiICkgKSB7XG5cdFx0XHRcdFx0YW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdH1cblx0XHRcdH07XG5cdFx0XHRkb0FuaW1hdGlvbi5maW5pc2ggPSBkb0FuaW1hdGlvbjtcblxuXHRcdHJldHVybiBlbXB0eSB8fCBvcHRhbGwucXVldWUgPT09IGZhbHNlID9cblx0XHRcdHRoaXMuZWFjaCggZG9BbmltYXRpb24gKSA6XG5cdFx0XHR0aGlzLnF1ZXVlKCBvcHRhbGwucXVldWUsIGRvQW5pbWF0aW9uICk7XG5cdH0sXG5cdHN0b3A6IGZ1bmN0aW9uKCB0eXBlLCBjbGVhclF1ZXVlLCBnb3RvRW5kICkge1xuXHRcdHZhciBzdG9wUXVldWUgPSBmdW5jdGlvbiggaG9va3MgKSB7XG5cdFx0XHR2YXIgc3RvcCA9IGhvb2tzLnN0b3A7XG5cdFx0XHRkZWxldGUgaG9va3Muc3RvcDtcblx0XHRcdHN0b3AoIGdvdG9FbmQgKTtcblx0XHR9O1xuXG5cdFx0aWYgKCB0eXBlb2YgdHlwZSAhPT0gXCJzdHJpbmdcIiApIHtcblx0XHRcdGdvdG9FbmQgPSBjbGVhclF1ZXVlO1xuXHRcdFx0Y2xlYXJRdWV1ZSA9IHR5cGU7XG5cdFx0XHR0eXBlID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0XHRpZiAoIGNsZWFyUXVldWUgJiYgdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0aGlzLnF1ZXVlKCB0eXBlIHx8IFwiZnhcIiwgW10gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBkZXF1ZXVlID0gdHJ1ZSxcblx0XHRcdFx0aW5kZXggPSB0eXBlICE9IG51bGwgJiYgdHlwZSArIFwicXVldWVIb29rc1wiLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICk7XG5cblx0XHRcdGlmICggaW5kZXggKSB7XG5cdFx0XHRcdGlmICggZGF0YVsgaW5kZXggXSAmJiBkYXRhWyBpbmRleCBdLnN0b3AgKSB7XG5cdFx0XHRcdFx0c3RvcFF1ZXVlKCBkYXRhWyBpbmRleCBdICk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGZvciAoIGluZGV4IGluIGRhdGEgKSB7XG5cdFx0XHRcdFx0aWYgKCBkYXRhWyBpbmRleCBdICYmIGRhdGFbIGluZGV4IF0uc3RvcCAmJiBycnVuLnRlc3QoIGluZGV4ICkgKSB7XG5cdFx0XHRcdFx0XHRzdG9wUXVldWUoIGRhdGFbIGluZGV4IF0gKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Zm9yICggaW5kZXggPSB0aW1lcnMubGVuZ3RoOyBpbmRleC0tOyApIHtcblx0XHRcdFx0aWYgKCB0aW1lcnNbIGluZGV4IF0uZWxlbSA9PT0gdGhpcyAmJlxuXHRcdFx0XHRcdCggdHlwZSA9PSBudWxsIHx8IHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApICkge1xuXG5cdFx0XHRcdFx0dGltZXJzWyBpbmRleCBdLmFuaW0uc3RvcCggZ290b0VuZCApO1xuXHRcdFx0XHRcdGRlcXVldWUgPSBmYWxzZTtcblx0XHRcdFx0XHR0aW1lcnMuc3BsaWNlKCBpbmRleCwgMSApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXJ0IHRoZSBuZXh0IGluIHRoZSBxdWV1ZSBpZiB0aGUgbGFzdCBzdGVwIHdhc24ndCBmb3JjZWQuXG5cdFx0XHQvLyBUaW1lcnMgY3VycmVudGx5IHdpbGwgY2FsbCB0aGVpciBjb21wbGV0ZSBjYWxsYmFja3MsIHdoaWNoXG5cdFx0XHQvLyB3aWxsIGRlcXVldWUgYnV0IG9ubHkgaWYgdGhleSB3ZXJlIGdvdG9FbmQuXG5cdFx0XHRpZiAoIGRlcXVldWUgfHwgIWdvdG9FbmQgKSB7XG5cdFx0XHRcdGpRdWVyeS5kZXF1ZXVlKCB0aGlzLCB0eXBlICk7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9LFxuXHRmaW5pc2g6IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdGlmICggdHlwZSAhPT0gZmFsc2UgKSB7XG5cdFx0XHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGluZGV4LFxuXHRcdFx0XHRkYXRhID0gZGF0YVByaXYuZ2V0KCB0aGlzICksXG5cdFx0XHRcdHF1ZXVlID0gZGF0YVsgdHlwZSArIFwicXVldWVcIiBdLFxuXHRcdFx0XHRob29rcyA9IGRhdGFbIHR5cGUgKyBcInF1ZXVlSG9va3NcIiBdLFxuXHRcdFx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzLFxuXHRcdFx0XHRsZW5ndGggPSBxdWV1ZSA/IHF1ZXVlLmxlbmd0aCA6IDA7XG5cblx0XHRcdC8vIEVuYWJsZSBmaW5pc2hpbmcgZmxhZyBvbiBwcml2YXRlIGRhdGFcblx0XHRcdGRhdGEuZmluaXNoID0gdHJ1ZTtcblxuXHRcdFx0Ly8gRW1wdHkgdGhlIHF1ZXVlIGZpcnN0XG5cdFx0XHRqUXVlcnkucXVldWUoIHRoaXMsIHR5cGUsIFtdICk7XG5cblx0XHRcdGlmICggaG9va3MgJiYgaG9va3Muc3RvcCApIHtcblx0XHRcdFx0aG9va3Muc3RvcC5jYWxsKCB0aGlzLCB0cnVlICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIExvb2sgZm9yIGFueSBhY3RpdmUgYW5pbWF0aW9ucywgYW5kIGZpbmlzaCB0aGVtXG5cdFx0XHRmb3IgKCBpbmRleCA9IHRpbWVycy5sZW5ndGg7IGluZGV4LS07ICkge1xuXHRcdFx0XHRpZiAoIHRpbWVyc1sgaW5kZXggXS5lbGVtID09PSB0aGlzICYmIHRpbWVyc1sgaW5kZXggXS5xdWV1ZSA9PT0gdHlwZSApIHtcblx0XHRcdFx0XHR0aW1lcnNbIGluZGV4IF0uYW5pbS5zdG9wKCB0cnVlICk7XG5cdFx0XHRcdFx0dGltZXJzLnNwbGljZSggaW5kZXgsIDEgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBMb29rIGZvciBhbnkgYW5pbWF0aW9ucyBpbiB0aGUgb2xkIHF1ZXVlIGFuZCBmaW5pc2ggdGhlbVxuXHRcdFx0Zm9yICggaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKyApIHtcblx0XHRcdFx0aWYgKCBxdWV1ZVsgaW5kZXggXSAmJiBxdWV1ZVsgaW5kZXggXS5maW5pc2ggKSB7XG5cdFx0XHRcdFx0cXVldWVbIGluZGV4IF0uZmluaXNoLmNhbGwoIHRoaXMgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHQvLyBUdXJuIG9mZiBmaW5pc2hpbmcgZmxhZ1xuXHRcdFx0ZGVsZXRlIGRhdGEuZmluaXNoO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcInRvZ2dsZVwiLCBcInNob3dcIiwgXCJoaWRlXCIgXSwgZnVuY3Rpb24oIGksIG5hbWUgKSB7XG5cdHZhciBjc3NGbiA9IGpRdWVyeS5mblsgbmFtZSBdO1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBzcGVlZCwgZWFzaW5nLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4gc3BlZWQgPT0gbnVsbCB8fCB0eXBlb2Ygc3BlZWQgPT09IFwiYm9vbGVhblwiID9cblx0XHRcdGNzc0ZuLmFwcGx5KCB0aGlzLCBhcmd1bWVudHMgKSA6XG5cdFx0XHR0aGlzLmFuaW1hdGUoIGdlbkZ4KCBuYW1lLCB0cnVlICksIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbi8vIEdlbmVyYXRlIHNob3J0Y3V0cyBmb3IgY3VzdG9tIGFuaW1hdGlvbnNcbmpRdWVyeS5lYWNoKCB7XG5cdHNsaWRlRG93bjogZ2VuRngoIFwic2hvd1wiICksXG5cdHNsaWRlVXA6IGdlbkZ4KCBcImhpZGVcIiApLFxuXHRzbGlkZVRvZ2dsZTogZ2VuRngoIFwidG9nZ2xlXCIgKSxcblx0ZmFkZUluOiB7IG9wYWNpdHk6IFwic2hvd1wiIH0sXG5cdGZhZGVPdXQ6IHsgb3BhY2l0eTogXCJoaWRlXCIgfSxcblx0ZmFkZVRvZ2dsZTogeyBvcGFjaXR5OiBcInRvZ2dsZVwiIH1cbn0sIGZ1bmN0aW9uKCBuYW1lLCBwcm9wcyApIHtcblx0alF1ZXJ5LmZuWyBuYW1lIF0gPSBmdW5jdGlvbiggc3BlZWQsIGVhc2luZywgY2FsbGJhY2sgKSB7XG5cdFx0cmV0dXJuIHRoaXMuYW5pbWF0ZSggcHJvcHMsIHNwZWVkLCBlYXNpbmcsIGNhbGxiYWNrICk7XG5cdH07XG59ICk7XG5cbmpRdWVyeS50aW1lcnMgPSBbXTtcbmpRdWVyeS5meC50aWNrID0gZnVuY3Rpb24oKSB7XG5cdHZhciB0aW1lcixcblx0XHRpID0gMCxcblx0XHR0aW1lcnMgPSBqUXVlcnkudGltZXJzO1xuXG5cdGZ4Tm93ID0galF1ZXJ5Lm5vdygpO1xuXG5cdGZvciAoIDsgaSA8IHRpbWVycy5sZW5ndGg7IGkrKyApIHtcblx0XHR0aW1lciA9IHRpbWVyc1sgaSBdO1xuXG5cdFx0Ly8gQ2hlY2tzIHRoZSB0aW1lciBoYXMgbm90IGFscmVhZHkgYmVlbiByZW1vdmVkXG5cdFx0aWYgKCAhdGltZXIoKSAmJiB0aW1lcnNbIGkgXSA9PT0gdGltZXIgKSB7XG5cdFx0XHR0aW1lcnMuc3BsaWNlKCBpLS0sIDEgKTtcblx0XHR9XG5cdH1cblxuXHRpZiAoICF0aW1lcnMubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5meC5zdG9wKCk7XG5cdH1cblx0ZnhOb3cgPSB1bmRlZmluZWQ7XG59O1xuXG5qUXVlcnkuZngudGltZXIgPSBmdW5jdGlvbiggdGltZXIgKSB7XG5cdGpRdWVyeS50aW1lcnMucHVzaCggdGltZXIgKTtcblx0aWYgKCB0aW1lcigpICkge1xuXHRcdGpRdWVyeS5meC5zdGFydCgpO1xuXHR9IGVsc2Uge1xuXHRcdGpRdWVyeS50aW1lcnMucG9wKCk7XG5cdH1cbn07XG5cbmpRdWVyeS5meC5pbnRlcnZhbCA9IDEzO1xualF1ZXJ5LmZ4LnN0YXJ0ID0gZnVuY3Rpb24oKSB7XG5cdGlmICggIXRpbWVySWQgKSB7XG5cdFx0dGltZXJJZCA9IHdpbmRvdy5zZXRJbnRlcnZhbCggalF1ZXJ5LmZ4LnRpY2ssIGpRdWVyeS5meC5pbnRlcnZhbCApO1xuXHR9XG59O1xuXG5qUXVlcnkuZnguc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHR3aW5kb3cuY2xlYXJJbnRlcnZhbCggdGltZXJJZCApO1xuXG5cdHRpbWVySWQgPSBudWxsO1xufTtcblxualF1ZXJ5LmZ4LnNwZWVkcyA9IHtcblx0c2xvdzogNjAwLFxuXHRmYXN0OiAyMDAsXG5cblx0Ly8gRGVmYXVsdCBzcGVlZFxuXHRfZGVmYXVsdDogNDAwXG59O1xuXG5cbi8vIEJhc2VkIG9mZiBvZiB0aGUgcGx1Z2luIGJ5IENsaW50IEhlbGZlcnMsIHdpdGggcGVybWlzc2lvbi5cbi8vIGh0dHA6Ly93ZWIuYXJjaGl2ZS5vcmcvd2ViLzIwMTAwMzI0MDE0NzQ3L2h0dHA6Ly9ibGluZHNpZ25hbHMuY29tL2luZGV4LnBocC8yMDA5LzA3L2pxdWVyeS1kZWxheS9cbmpRdWVyeS5mbi5kZWxheSA9IGZ1bmN0aW9uKCB0aW1lLCB0eXBlICkge1xuXHR0aW1lID0galF1ZXJ5LmZ4ID8galF1ZXJ5LmZ4LnNwZWVkc1sgdGltZSBdIHx8IHRpbWUgOiB0aW1lO1xuXHR0eXBlID0gdHlwZSB8fCBcImZ4XCI7XG5cblx0cmV0dXJuIHRoaXMucXVldWUoIHR5cGUsIGZ1bmN0aW9uKCBuZXh0LCBob29rcyApIHtcblx0XHR2YXIgdGltZW91dCA9IHdpbmRvdy5zZXRUaW1lb3V0KCBuZXh0LCB0aW1lICk7XG5cdFx0aG9va3Muc3RvcCA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0d2luZG93LmNsZWFyVGltZW91dCggdGltZW91dCApO1xuXHRcdH07XG5cdH0gKTtcbn07XG5cblxuKCBmdW5jdGlvbigpIHtcblx0dmFyIGlucHV0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJpbnB1dFwiICksXG5cdFx0c2VsZWN0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJzZWxlY3RcIiApLFxuXHRcdG9wdCA9IHNlbGVjdC5hcHBlbmRDaGlsZCggZG9jdW1lbnQuY3JlYXRlRWxlbWVudCggXCJvcHRpb25cIiApICk7XG5cblx0aW5wdXQudHlwZSA9IFwiY2hlY2tib3hcIjtcblxuXHQvLyBTdXBwb3J0OiBpT1M8PTUuMSwgQW5kcm9pZDw9NC4yK1xuXHQvLyBEZWZhdWx0IHZhbHVlIGZvciBhIGNoZWNrYm94IHNob3VsZCBiZSBcIm9uXCJcblx0c3VwcG9ydC5jaGVja09uID0gaW5wdXQudmFsdWUgIT09IFwiXCI7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBNdXN0IGFjY2VzcyBzZWxlY3RlZEluZGV4IHRvIG1ha2UgZGVmYXVsdCBvcHRpb25zIHNlbGVjdFxuXHRzdXBwb3J0Lm9wdFNlbGVjdGVkID0gb3B0LnNlbGVjdGVkO1xuXG5cdC8vIFN1cHBvcnQ6IEFuZHJvaWQ8PTIuM1xuXHQvLyBPcHRpb25zIGluc2lkZSBkaXNhYmxlZCBzZWxlY3RzIGFyZSBpbmNvcnJlY3RseSBtYXJrZWQgYXMgZGlzYWJsZWRcblx0c2VsZWN0LmRpc2FibGVkID0gdHJ1ZTtcblx0c3VwcG9ydC5vcHREaXNhYmxlZCA9ICFvcHQuZGlzYWJsZWQ7XG5cblx0Ly8gU3VwcG9ydDogSUU8PTExK1xuXHQvLyBBbiBpbnB1dCBsb3NlcyBpdHMgdmFsdWUgYWZ0ZXIgYmVjb21pbmcgYSByYWRpb1xuXHRpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoIFwiaW5wdXRcIiApO1xuXHRpbnB1dC52YWx1ZSA9IFwidFwiO1xuXHRpbnB1dC50eXBlID0gXCJyYWRpb1wiO1xuXHRzdXBwb3J0LnJhZGlvVmFsdWUgPSBpbnB1dC52YWx1ZSA9PT0gXCJ0XCI7XG59ICkoKTtcblxuXG52YXIgYm9vbEhvb2ssXG5cdGF0dHJIYW5kbGUgPSBqUXVlcnkuZXhwci5hdHRySGFuZGxlO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkuYXR0ciwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlQXR0cjogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggdGhpcywgbmFtZSApO1xuXHRcdH0gKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cdGF0dHI6IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCB2YWx1ZSApIHtcblx0XHR2YXIgcmV0LCBob29rcyxcblx0XHRcdG5UeXBlID0gZWxlbS5ub2RlVHlwZTtcblxuXHRcdC8vIERvbid0IGdldC9zZXQgYXR0cmlidXRlcyBvbiB0ZXh0LCBjb21tZW50IGFuZCBhdHRyaWJ1dGUgbm9kZXNcblx0XHRpZiAoIG5UeXBlID09PSAzIHx8IG5UeXBlID09PSA4IHx8IG5UeXBlID09PSAyICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIEZhbGxiYWNrIHRvIHByb3Agd2hlbiBhdHRyaWJ1dGVzIGFyZSBub3Qgc3VwcG9ydGVkXG5cdFx0aWYgKCB0eXBlb2YgZWxlbS5nZXRBdHRyaWJ1dGUgPT09IFwidW5kZWZpbmVkXCIgKSB7XG5cdFx0XHRyZXR1cm4galF1ZXJ5LnByb3AoIGVsZW0sIG5hbWUsIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0Ly8gQWxsIGF0dHJpYnV0ZXMgYXJlIGxvd2VyY2FzZVxuXHRcdC8vIEdyYWIgbmVjZXNzYXJ5IGhvb2sgaWYgb25lIGlzIGRlZmluZWRcblx0XHRpZiAoIG5UeXBlICE9PSAxIHx8ICFqUXVlcnkuaXNYTUxEb2MoIGVsZW0gKSApIHtcblx0XHRcdG5hbWUgPSBuYW1lLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5hdHRySG9va3NbIG5hbWUgXSB8fFxuXHRcdFx0XHQoIGpRdWVyeS5leHByLm1hdGNoLmJvb2wudGVzdCggbmFtZSApID8gYm9vbEhvb2sgOiB1bmRlZmluZWQgKTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIHZhbHVlID09PSBudWxsICkge1xuXHRcdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaG9va3MgJiYgXCJzZXRcIiBpbiBob29rcyAmJlxuXHRcdFx0XHQoIHJldCA9IGhvb2tzLnNldCggZWxlbSwgdmFsdWUsIG5hbWUgKSApICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHR9XG5cblx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBuYW1lLCB2YWx1ZSArIFwiXCIgKTtcblx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHR9XG5cblx0XHRpZiAoIGhvb2tzICYmIFwiZ2V0XCIgaW4gaG9va3MgJiYgKCByZXQgPSBob29rcy5nZXQoIGVsZW0sIG5hbWUgKSApICE9PSBudWxsICkge1xuXHRcdFx0cmV0dXJuIHJldDtcblx0XHR9XG5cblx0XHRyZXQgPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBuYW1lICk7XG5cblx0XHQvLyBOb24tZXhpc3RlbnQgYXR0cmlidXRlcyByZXR1cm4gbnVsbCwgd2Ugbm9ybWFsaXplIHRvIHVuZGVmaW5lZFxuXHRcdHJldHVybiByZXQgPT0gbnVsbCA/IHVuZGVmaW5lZCA6IHJldDtcblx0fSxcblxuXHRhdHRySG9va3M6IHtcblx0XHR0eXBlOiB7XG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0aWYgKCAhc3VwcG9ydC5yYWRpb1ZhbHVlICYmIHZhbHVlID09PSBcInJhZGlvXCIgJiZcblx0XHRcdFx0XHRqUXVlcnkubm9kZU5hbWUoIGVsZW0sIFwiaW5wdXRcIiApICkge1xuXHRcdFx0XHRcdHZhciB2YWwgPSBlbGVtLnZhbHVlO1xuXHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcInR5cGVcIiwgdmFsdWUgKTtcblx0XHRcdFx0XHRpZiAoIHZhbCApIHtcblx0XHRcdFx0XHRcdGVsZW0udmFsdWUgPSB2YWw7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRyZW1vdmVBdHRyOiBmdW5jdGlvbiggZWxlbSwgdmFsdWUgKSB7XG5cdFx0dmFyIG5hbWUsIHByb3BOYW1lLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRhdHRyTmFtZXMgPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCggcm5vdHdoaXRlICk7XG5cblx0XHRpZiAoIGF0dHJOYW1lcyAmJiBlbGVtLm5vZGVUeXBlID09PSAxICkge1xuXHRcdFx0d2hpbGUgKCAoIG5hbWUgPSBhdHRyTmFtZXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdHByb3BOYW1lID0galF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lO1xuXG5cdFx0XHRcdC8vIEJvb2xlYW4gYXR0cmlidXRlcyBnZXQgc3BlY2lhbCB0cmVhdG1lbnQgKCMxMDg3MClcblx0XHRcdFx0aWYgKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnRlc3QoIG5hbWUgKSApIHtcblxuXHRcdFx0XHRcdC8vIFNldCBjb3JyZXNwb25kaW5nIHByb3BlcnR5IHRvIGZhbHNlXG5cdFx0XHRcdFx0ZWxlbVsgcHJvcE5hbWUgXSA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0ZWxlbS5yZW1vdmVBdHRyaWJ1dGUoIG5hbWUgKTtcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSG9va3MgZm9yIGJvb2xlYW4gYXR0cmlidXRlc1xuYm9vbEhvb2sgPSB7XG5cdHNldDogZnVuY3Rpb24oIGVsZW0sIHZhbHVlLCBuYW1lICkge1xuXHRcdGlmICggdmFsdWUgPT09IGZhbHNlICkge1xuXG5cdFx0XHQvLyBSZW1vdmUgYm9vbGVhbiBhdHRyaWJ1dGVzIHdoZW4gc2V0IHRvIGZhbHNlXG5cdFx0XHRqUXVlcnkucmVtb3ZlQXR0ciggZWxlbSwgbmFtZSApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRlbGVtLnNldEF0dHJpYnV0ZSggbmFtZSwgbmFtZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gbmFtZTtcblx0fVxufTtcbmpRdWVyeS5lYWNoKCBqUXVlcnkuZXhwci5tYXRjaC5ib29sLnNvdXJjZS5tYXRjaCggL1xcdysvZyApLCBmdW5jdGlvbiggaSwgbmFtZSApIHtcblx0dmFyIGdldHRlciA9IGF0dHJIYW5kbGVbIG5hbWUgXSB8fCBqUXVlcnkuZmluZC5hdHRyO1xuXG5cdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGZ1bmN0aW9uKCBlbGVtLCBuYW1lLCBpc1hNTCApIHtcblx0XHR2YXIgcmV0LCBoYW5kbGU7XG5cdFx0aWYgKCAhaXNYTUwgKSB7XG5cblx0XHRcdC8vIEF2b2lkIGFuIGluZmluaXRlIGxvb3AgYnkgdGVtcG9yYXJpbHkgcmVtb3ZpbmcgdGhpcyBmdW5jdGlvbiBmcm9tIHRoZSBnZXR0ZXJcblx0XHRcdGhhbmRsZSA9IGF0dHJIYW5kbGVbIG5hbWUgXTtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IHJldDtcblx0XHRcdHJldCA9IGdldHRlciggZWxlbSwgbmFtZSwgaXNYTUwgKSAhPSBudWxsID9cblx0XHRcdFx0bmFtZS50b0xvd2VyQ2FzZSgpIDpcblx0XHRcdFx0bnVsbDtcblx0XHRcdGF0dHJIYW5kbGVbIG5hbWUgXSA9IGhhbmRsZTtcblx0XHR9XG5cdFx0cmV0dXJuIHJldDtcblx0fTtcbn0gKTtcblxuXG5cblxudmFyIHJmb2N1c2FibGUgPSAvXig/OmlucHV0fHNlbGVjdHx0ZXh0YXJlYXxidXR0b24pJC9pLFxuXHRyY2xpY2thYmxlID0gL14oPzphfGFyZWEpJC9pO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHByb3A6IGZ1bmN0aW9uKCBuYW1lLCB2YWx1ZSApIHtcblx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBqUXVlcnkucHJvcCwgbmFtZSwgdmFsdWUsIGFyZ3VtZW50cy5sZW5ndGggPiAxICk7XG5cdH0sXG5cblx0cmVtb3ZlUHJvcDogZnVuY3Rpb24oIG5hbWUgKSB7XG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHRkZWxldGUgdGhpc1sgalF1ZXJ5LnByb3BGaXhbIG5hbWUgXSB8fCBuYW1lIF07XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0cHJvcDogZnVuY3Rpb24oIGVsZW0sIG5hbWUsIHZhbHVlICkge1xuXHRcdHZhciByZXQsIGhvb2tzLFxuXHRcdFx0blR5cGUgPSBlbGVtLm5vZGVUeXBlO1xuXG5cdFx0Ly8gRG9uJ3QgZ2V0L3NldCBwcm9wZXJ0aWVzIG9uIHRleHQsIGNvbW1lbnQgYW5kIGF0dHJpYnV0ZSBub2Rlc1xuXHRcdGlmICggblR5cGUgPT09IDMgfHwgblR5cGUgPT09IDggfHwgblR5cGUgPT09IDIgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0aWYgKCBuVHlwZSAhPT0gMSB8fCAhalF1ZXJ5LmlzWE1MRG9jKCBlbGVtICkgKSB7XG5cblx0XHRcdC8vIEZpeCBuYW1lIGFuZCBhdHRhY2ggaG9va3Ncblx0XHRcdG5hbWUgPSBqUXVlcnkucHJvcEZpeFsgbmFtZSBdIHx8IG5hbWU7XG5cdFx0XHRob29rcyA9IGpRdWVyeS5wcm9wSG9va3NbIG5hbWUgXTtcblx0XHR9XG5cblx0XHRpZiAoIHZhbHVlICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRpZiAoIGhvb2tzICYmIFwic2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0KCByZXQgPSBob29rcy5zZXQoIGVsZW0sIHZhbHVlLCBuYW1lICkgKSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gcmV0O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gKCBlbGVtWyBuYW1lIF0gPSB2YWx1ZSApO1xuXHRcdH1cblxuXHRcdGlmICggaG9va3MgJiYgXCJnZXRcIiBpbiBob29rcyAmJiAoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgbmFtZSApICkgIT09IG51bGwgKSB7XG5cdFx0XHRyZXR1cm4gcmV0O1xuXHRcdH1cblxuXHRcdHJldHVybiBlbGVtWyBuYW1lIF07XG5cdH0sXG5cblx0cHJvcEhvb2tzOiB7XG5cdFx0dGFiSW5kZXg6IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gZWxlbS50YWJJbmRleCBkb2Vzbid0IGFsd2F5cyByZXR1cm4gdGhlXG5cdFx0XHRcdC8vIGNvcnJlY3QgdmFsdWUgd2hlbiBpdCBoYXNuJ3QgYmVlbiBleHBsaWNpdGx5IHNldFxuXHRcdFx0XHQvLyBodHRwOi8vZmx1aWRwcm9qZWN0Lm9yZy9ibG9nLzIwMDgvMDEvMDkvZ2V0dGluZy1zZXR0aW5nLWFuZC1yZW1vdmluZy10YWJpbmRleC12YWx1ZXMtd2l0aC1qYXZhc2NyaXB0L1xuXHRcdFx0XHQvLyBVc2UgcHJvcGVyIGF0dHJpYnV0ZSByZXRyaWV2YWwoIzEyMDcyKVxuXHRcdFx0XHR2YXIgdGFiaW5kZXggPSBqUXVlcnkuZmluZC5hdHRyKCBlbGVtLCBcInRhYmluZGV4XCIgKTtcblxuXHRcdFx0XHRyZXR1cm4gdGFiaW5kZXggP1xuXHRcdFx0XHRcdHBhcnNlSW50KCB0YWJpbmRleCwgMTAgKSA6XG5cdFx0XHRcdFx0cmZvY3VzYWJsZS50ZXN0KCBlbGVtLm5vZGVOYW1lICkgfHxcblx0XHRcdFx0XHRcdHJjbGlja2FibGUudGVzdCggZWxlbS5ub2RlTmFtZSApICYmIGVsZW0uaHJlZiA/XG5cdFx0XHRcdFx0XHRcdDAgOlxuXHRcdFx0XHRcdFx0XHQtMTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0cHJvcEZpeDoge1xuXHRcdFwiZm9yXCI6IFwiaHRtbEZvclwiLFxuXHRcdFwiY2xhc3NcIjogXCJjbGFzc05hbWVcIlxuXHR9XG59ICk7XG5cbmlmICggIXN1cHBvcnQub3B0U2VsZWN0ZWQgKSB7XG5cdGpRdWVyeS5wcm9wSG9va3Muc2VsZWN0ZWQgPSB7XG5cdFx0Z2V0OiBmdW5jdGlvbiggZWxlbSApIHtcblx0XHRcdHZhciBwYXJlbnQgPSBlbGVtLnBhcmVudE5vZGU7XG5cdFx0XHRpZiAoIHBhcmVudCAmJiBwYXJlbnQucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0cGFyZW50LnBhcmVudE5vZGUuc2VsZWN0ZWRJbmRleDtcblx0XHRcdH1cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fTtcbn1cblxualF1ZXJ5LmVhY2goIFtcblx0XCJ0YWJJbmRleFwiLFxuXHRcInJlYWRPbmx5XCIsXG5cdFwibWF4TGVuZ3RoXCIsXG5cdFwiY2VsbFNwYWNpbmdcIixcblx0XCJjZWxsUGFkZGluZ1wiLFxuXHRcInJvd1NwYW5cIixcblx0XCJjb2xTcGFuXCIsXG5cdFwidXNlTWFwXCIsXG5cdFwiZnJhbWVCb3JkZXJcIixcblx0XCJjb250ZW50RWRpdGFibGVcIlxuXSwgZnVuY3Rpb24oKSB7XG5cdGpRdWVyeS5wcm9wRml4WyB0aGlzLnRvTG93ZXJDYXNlKCkgXSA9IHRoaXM7XG59ICk7XG5cblxuXG5cbnZhciByY2xhc3MgPSAvW1xcdFxcclxcblxcZl0vZztcblxuZnVuY3Rpb24gZ2V0Q2xhc3MoIGVsZW0gKSB7XG5cdHJldHVybiBlbGVtLmdldEF0dHJpYnV0ZSAmJiBlbGVtLmdldEF0dHJpYnV0ZSggXCJjbGFzc1wiICkgfHwgXCJcIjtcbn1cblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRhZGRDbGFzczogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBjbGFzc2VzLCBlbGVtLCBjdXIsIGN1clZhbHVlLCBjbGF6eiwgaiwgZmluYWxWYWx1ZSxcblx0XHRcdGkgPSAwO1xuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBqICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS5hZGRDbGFzcyggdmFsdWUuY2FsbCggdGhpcywgaiwgZ2V0Q2xhc3MoIHRoaXMgKSApICk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblx0XHRcdFx0Y3VyID0gZWxlbS5ub2RlVHlwZSA9PT0gMSAmJlxuXHRcdFx0XHRcdCggXCIgXCIgKyBjdXJWYWx1ZSArIFwiIFwiICkucmVwbGFjZSggcmNsYXNzLCBcIiBcIiApO1xuXG5cdFx0XHRcdGlmICggY3VyICkge1xuXHRcdFx0XHRcdGogPSAwO1xuXHRcdFx0XHRcdHdoaWxlICggKCBjbGF6eiA9IGNsYXNzZXNbIGorKyBdICkgKSB7XG5cdFx0XHRcdFx0XHRpZiAoIGN1ci5pbmRleE9mKCBcIiBcIiArIGNsYXp6ICsgXCIgXCIgKSA8IDAgKSB7XG5cdFx0XHRcdFx0XHRcdGN1ciArPSBjbGF6eiArIFwiIFwiO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdC8vIE9ubHkgYXNzaWduIGlmIGRpZmZlcmVudCB0byBhdm9pZCB1bm5lZWRlZCByZW5kZXJpbmcuXG5cdFx0XHRcdFx0ZmluYWxWYWx1ZSA9IGpRdWVyeS50cmltKCBjdXIgKTtcblx0XHRcdFx0XHRpZiAoIGN1clZhbHVlICE9PSBmaW5hbFZhbHVlICkge1xuXHRcdFx0XHRcdFx0ZWxlbS5zZXRBdHRyaWJ1dGUoIFwiY2xhc3NcIiwgZmluYWxWYWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJlbW92ZUNsYXNzOiBmdW5jdGlvbiggdmFsdWUgKSB7XG5cdFx0dmFyIGNsYXNzZXMsIGVsZW0sIGN1ciwgY3VyVmFsdWUsIGNsYXp6LCBqLCBmaW5hbFZhbHVlLFxuXHRcdFx0aSA9IDA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCB2YWx1ZSApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGogKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLnJlbW92ZUNsYXNzKCB2YWx1ZS5jYWxsKCB0aGlzLCBqLCBnZXRDbGFzcyggdGhpcyApICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoICFhcmd1bWVudHMubGVuZ3RoICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuYXR0ciggXCJjbGFzc1wiLCBcIlwiICk7XG5cdFx0fVxuXG5cdFx0aWYgKCB0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIgJiYgdmFsdWUgKSB7XG5cdFx0XHRjbGFzc2VzID0gdmFsdWUubWF0Y2goIHJub3R3aGl0ZSApIHx8IFtdO1xuXG5cdFx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRcdGN1clZhbHVlID0gZ2V0Q2xhc3MoIGVsZW0gKTtcblxuXHRcdFx0XHQvLyBUaGlzIGV4cHJlc3Npb24gaXMgaGVyZSBmb3IgYmV0dGVyIGNvbXByZXNzaWJpbGl0eSAoc2VlIGFkZENsYXNzKVxuXHRcdFx0XHRjdXIgPSBlbGVtLm5vZGVUeXBlID09PSAxICYmXG5cdFx0XHRcdFx0KCBcIiBcIiArIGN1clZhbHVlICsgXCIgXCIgKS5yZXBsYWNlKCByY2xhc3MsIFwiIFwiICk7XG5cblx0XHRcdFx0aWYgKCBjdXIgKSB7XG5cdFx0XHRcdFx0aiA9IDA7XG5cdFx0XHRcdFx0d2hpbGUgKCAoIGNsYXp6ID0gY2xhc3Nlc1sgaisrIF0gKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gUmVtb3ZlICphbGwqIGluc3RhbmNlc1xuXHRcdFx0XHRcdFx0d2hpbGUgKCBjdXIuaW5kZXhPZiggXCIgXCIgKyBjbGF6eiArIFwiIFwiICkgPiAtMSApIHtcblx0XHRcdFx0XHRcdFx0Y3VyID0gY3VyLnJlcGxhY2UoIFwiIFwiICsgY2xhenogKyBcIiBcIiwgXCIgXCIgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBPbmx5IGFzc2lnbiBpZiBkaWZmZXJlbnQgdG8gYXZvaWQgdW5uZWVkZWQgcmVuZGVyaW5nLlxuXHRcdFx0XHRcdGZpbmFsVmFsdWUgPSBqUXVlcnkudHJpbSggY3VyICk7XG5cdFx0XHRcdFx0aWYgKCBjdXJWYWx1ZSAhPT0gZmluYWxWYWx1ZSApIHtcblx0XHRcdFx0XHRcdGVsZW0uc2V0QXR0cmlidXRlKCBcImNsYXNzXCIsIGZpbmFsVmFsdWUgKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHR0b2dnbGVDbGFzczogZnVuY3Rpb24oIHZhbHVlLCBzdGF0ZVZhbCApIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcblxuXHRcdGlmICggdHlwZW9mIHN0YXRlVmFsID09PSBcImJvb2xlYW5cIiAmJiB0eXBlID09PSBcInN0cmluZ1wiICkge1xuXHRcdFx0cmV0dXJuIHN0YXRlVmFsID8gdGhpcy5hZGRDbGFzcyggdmFsdWUgKSA6IHRoaXMucmVtb3ZlQ2xhc3MoIHZhbHVlICk7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKSApIHtcblx0XHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0XHRqUXVlcnkoIHRoaXMgKS50b2dnbGVDbGFzcyhcblx0XHRcdFx0XHR2YWx1ZS5jYWxsKCB0aGlzLCBpLCBnZXRDbGFzcyggdGhpcyApLCBzdGF0ZVZhbCApLFxuXHRcdFx0XHRcdHN0YXRlVmFsXG5cdFx0XHRcdCk7XG5cdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2xhc3NOYW1lLCBpLCBzZWxmLCBjbGFzc05hbWVzO1xuXG5cdFx0XHRpZiAoIHR5cGUgPT09IFwic3RyaW5nXCIgKSB7XG5cblx0XHRcdFx0Ly8gVG9nZ2xlIGluZGl2aWR1YWwgY2xhc3MgbmFtZXNcblx0XHRcdFx0aSA9IDA7XG5cdFx0XHRcdHNlbGYgPSBqUXVlcnkoIHRoaXMgKTtcblx0XHRcdFx0Y2xhc3NOYW1lcyA9IHZhbHVlLm1hdGNoKCBybm90d2hpdGUgKSB8fCBbXTtcblxuXHRcdFx0XHR3aGlsZSAoICggY2xhc3NOYW1lID0gY2xhc3NOYW1lc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHRcdC8vIENoZWNrIGVhY2ggY2xhc3NOYW1lIGdpdmVuLCBzcGFjZSBzZXBhcmF0ZWQgbGlzdFxuXHRcdFx0XHRcdGlmICggc2VsZi5oYXNDbGFzcyggY2xhc3NOYW1lICkgKSB7XG5cdFx0XHRcdFx0XHRzZWxmLnJlbW92ZUNsYXNzKCBjbGFzc05hbWUgKTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0c2VsZi5hZGRDbGFzcyggY2xhc3NOYW1lICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdC8vIFRvZ2dsZSB3aG9sZSBjbGFzcyBuYW1lXG5cdFx0XHR9IGVsc2UgaWYgKCB2YWx1ZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGUgPT09IFwiYm9vbGVhblwiICkge1xuXHRcdFx0XHRjbGFzc05hbWUgPSBnZXRDbGFzcyggdGhpcyApO1xuXHRcdFx0XHRpZiAoIGNsYXNzTmFtZSApIHtcblxuXHRcdFx0XHRcdC8vIFN0b3JlIGNsYXNzTmFtZSBpZiBzZXRcblx0XHRcdFx0XHRkYXRhUHJpdi5zZXQoIHRoaXMsIFwiX19jbGFzc05hbWVfX1wiLCBjbGFzc05hbWUgKTtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIElmIHRoZSBlbGVtZW50IGhhcyBhIGNsYXNzIG5hbWUgb3IgaWYgd2UncmUgcGFzc2VkIGBmYWxzZWAsXG5cdFx0XHRcdC8vIHRoZW4gcmVtb3ZlIHRoZSB3aG9sZSBjbGFzc25hbWUgKGlmIHRoZXJlIHdhcyBvbmUsIHRoZSBhYm92ZSBzYXZlZCBpdCkuXG5cdFx0XHRcdC8vIE90aGVyd2lzZSBicmluZyBiYWNrIHdoYXRldmVyIHdhcyBwcmV2aW91c2x5IHNhdmVkIChpZiBhbnl0aGluZyksXG5cdFx0XHRcdC8vIGZhbGxpbmcgYmFjayB0byB0aGUgZW1wdHkgc3RyaW5nIGlmIG5vdGhpbmcgd2FzIHN0b3JlZC5cblx0XHRcdFx0aWYgKCB0aGlzLnNldEF0dHJpYnV0ZSApIHtcblx0XHRcdFx0XHR0aGlzLnNldEF0dHJpYnV0ZSggXCJjbGFzc1wiLFxuXHRcdFx0XHRcdFx0Y2xhc3NOYW1lIHx8IHZhbHVlID09PSBmYWxzZSA/XG5cdFx0XHRcdFx0XHRcIlwiIDpcblx0XHRcdFx0XHRcdGRhdGFQcml2LmdldCggdGhpcywgXCJfX2NsYXNzTmFtZV9fXCIgKSB8fCBcIlwiXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHRoYXNDbGFzczogZnVuY3Rpb24oIHNlbGVjdG9yICkge1xuXHRcdHZhciBjbGFzc05hbWUsIGVsZW0sXG5cdFx0XHRpID0gMDtcblxuXHRcdGNsYXNzTmFtZSA9IFwiIFwiICsgc2VsZWN0b3IgKyBcIiBcIjtcblx0XHR3aGlsZSAoICggZWxlbSA9IHRoaXNbIGkrKyBdICkgKSB7XG5cdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDEgJiZcblx0XHRcdFx0KCBcIiBcIiArIGdldENsYXNzKCBlbGVtICkgKyBcIiBcIiApLnJlcGxhY2UoIHJjbGFzcywgXCIgXCIgKVxuXHRcdFx0XHRcdC5pbmRleE9mKCBjbGFzc05hbWUgKSA+IC0xXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBycmV0dXJuID0gL1xcci9nO1xuXG5qUXVlcnkuZm4uZXh0ZW5kKCB7XG5cdHZhbDogZnVuY3Rpb24oIHZhbHVlICkge1xuXHRcdHZhciBob29rcywgcmV0LCBpc0Z1bmN0aW9uLFxuXHRcdFx0ZWxlbSA9IHRoaXNbIDAgXTtcblxuXHRcdGlmICggIWFyZ3VtZW50cy5sZW5ndGggKSB7XG5cdFx0XHRpZiAoIGVsZW0gKSB7XG5cdFx0XHRcdGhvb2tzID0galF1ZXJ5LnZhbEhvb2tzWyBlbGVtLnR5cGUgXSB8fFxuXHRcdFx0XHRcdGpRdWVyeS52YWxIb29rc1sgZWxlbS5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdFx0aWYgKCBob29rcyAmJlxuXHRcdFx0XHRcdFwiZ2V0XCIgaW4gaG9va3MgJiZcblx0XHRcdFx0XHQoIHJldCA9IGhvb2tzLmdldCggZWxlbSwgXCJ2YWx1ZVwiICkgKSAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdCkge1xuXHRcdFx0XHRcdHJldHVybiByZXQ7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXQgPSBlbGVtLnZhbHVlO1xuXG5cdFx0XHRcdHJldHVybiB0eXBlb2YgcmV0ID09PSBcInN0cmluZ1wiID9cblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBtb3N0IGNvbW1vbiBzdHJpbmcgY2FzZXNcblx0XHRcdFx0XHRyZXQucmVwbGFjZSggcnJldHVybiwgXCJcIiApIDpcblxuXHRcdFx0XHRcdC8vIEhhbmRsZSBjYXNlcyB3aGVyZSB2YWx1ZSBpcyBudWxsL3VuZGVmIG9yIG51bWJlclxuXHRcdFx0XHRcdHJldCA9PSBudWxsID8gXCJcIiA6IHJldDtcblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdGlzRnVuY3Rpb24gPSBqUXVlcnkuaXNGdW5jdGlvbiggdmFsdWUgKTtcblxuXHRcdHJldHVybiB0aGlzLmVhY2goIGZ1bmN0aW9uKCBpICkge1xuXHRcdFx0dmFyIHZhbDtcblxuXHRcdFx0aWYgKCB0aGlzLm5vZGVUeXBlICE9PSAxICkge1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICggaXNGdW5jdGlvbiApIHtcblx0XHRcdFx0dmFsID0gdmFsdWUuY2FsbCggdGhpcywgaSwgalF1ZXJ5KCB0aGlzICkudmFsKCkgKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhbCA9IHZhbHVlO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBUcmVhdCBudWxsL3VuZGVmaW5lZCBhcyBcIlwiOyBjb252ZXJ0IG51bWJlcnMgdG8gc3RyaW5nXG5cdFx0XHRpZiAoIHZhbCA9PSBudWxsICkge1xuXHRcdFx0XHR2YWwgPSBcIlwiO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCB0eXBlb2YgdmFsID09PSBcIm51bWJlclwiICkge1xuXHRcdFx0XHR2YWwgKz0gXCJcIjtcblxuXHRcdFx0fSBlbHNlIGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbCApICkge1xuXHRcdFx0XHR2YWwgPSBqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWx1ZSApIHtcblx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCA/IFwiXCIgOiB2YWx1ZSArIFwiXCI7XG5cdFx0XHRcdH0gKTtcblx0XHRcdH1cblxuXHRcdFx0aG9va3MgPSBqUXVlcnkudmFsSG9va3NbIHRoaXMudHlwZSBdIHx8IGpRdWVyeS52YWxIb29rc1sgdGhpcy5ub2RlTmFtZS50b0xvd2VyQ2FzZSgpIF07XG5cblx0XHRcdC8vIElmIHNldCByZXR1cm5zIHVuZGVmaW5lZCwgZmFsbCBiYWNrIHRvIG5vcm1hbCBzZXR0aW5nXG5cdFx0XHRpZiAoICFob29rcyB8fCAhKCBcInNldFwiIGluIGhvb2tzICkgfHwgaG9va3Muc2V0KCB0aGlzLCB2YWwsIFwidmFsdWVcIiApID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdHRoaXMudmFsdWUgPSB2YWw7XG5cdFx0XHR9XG5cdFx0fSApO1xuXHR9XG59ICk7XG5cbmpRdWVyeS5leHRlbmQoIHtcblx0dmFsSG9va3M6IHtcblx0XHRvcHRpb246IHtcblx0XHRcdGdldDogZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU8MTFcblx0XHRcdFx0Ly8gb3B0aW9uLnZhbHVlIG5vdCB0cmltbWVkICgjMTQ4NTgpXG5cdFx0XHRcdHJldHVybiBqUXVlcnkudHJpbSggZWxlbS52YWx1ZSApO1xuXHRcdFx0fVxuXHRcdH0sXG5cdFx0c2VsZWN0OiB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCBlbGVtICkge1xuXHRcdFx0XHR2YXIgdmFsdWUsIG9wdGlvbixcblx0XHRcdFx0XHRvcHRpb25zID0gZWxlbS5vcHRpb25zLFxuXHRcdFx0XHRcdGluZGV4ID0gZWxlbS5zZWxlY3RlZEluZGV4LFxuXHRcdFx0XHRcdG9uZSA9IGVsZW0udHlwZSA9PT0gXCJzZWxlY3Qtb25lXCIgfHwgaW5kZXggPCAwLFxuXHRcdFx0XHRcdHZhbHVlcyA9IG9uZSA/IG51bGwgOiBbXSxcblx0XHRcdFx0XHRtYXggPSBvbmUgPyBpbmRleCArIDEgOiBvcHRpb25zLmxlbmd0aCxcblx0XHRcdFx0XHRpID0gaW5kZXggPCAwID9cblx0XHRcdFx0XHRcdG1heCA6XG5cdFx0XHRcdFx0XHRvbmUgPyBpbmRleCA6IDA7XG5cblx0XHRcdFx0Ly8gTG9vcCB0aHJvdWdoIGFsbCB0aGUgc2VsZWN0ZWQgb3B0aW9uc1xuXHRcdFx0XHRmb3IgKCA7IGkgPCBtYXg7IGkrKyApIHtcblx0XHRcdFx0XHRvcHRpb24gPSBvcHRpb25zWyBpIF07XG5cblx0XHRcdFx0XHQvLyBJRTgtOSBkb2Vzbid0IHVwZGF0ZSBzZWxlY3RlZCBhZnRlciBmb3JtIHJlc2V0ICgjMjU1MSlcblx0XHRcdFx0XHRpZiAoICggb3B0aW9uLnNlbGVjdGVkIHx8IGkgPT09IGluZGV4ICkgJiZcblxuXHRcdFx0XHRcdFx0XHQvLyBEb24ndCByZXR1cm4gb3B0aW9ucyB0aGF0IGFyZSBkaXNhYmxlZCBvciBpbiBhIGRpc2FibGVkIG9wdGdyb3VwXG5cdFx0XHRcdFx0XHRcdCggc3VwcG9ydC5vcHREaXNhYmxlZCA/XG5cdFx0XHRcdFx0XHRcdFx0IW9wdGlvbi5kaXNhYmxlZCA6IG9wdGlvbi5nZXRBdHRyaWJ1dGUoIFwiZGlzYWJsZWRcIiApID09PSBudWxsICkgJiZcblx0XHRcdFx0XHRcdFx0KCAhb3B0aW9uLnBhcmVudE5vZGUuZGlzYWJsZWQgfHxcblx0XHRcdFx0XHRcdFx0XHQhalF1ZXJ5Lm5vZGVOYW1lKCBvcHRpb24ucGFyZW50Tm9kZSwgXCJvcHRncm91cFwiICkgKSApIHtcblxuXHRcdFx0XHRcdFx0Ly8gR2V0IHRoZSBzcGVjaWZpYyB2YWx1ZSBmb3IgdGhlIG9wdGlvblxuXHRcdFx0XHRcdFx0dmFsdWUgPSBqUXVlcnkoIG9wdGlvbiApLnZhbCgpO1xuXG5cdFx0XHRcdFx0XHQvLyBXZSBkb24ndCBuZWVkIGFuIGFycmF5IGZvciBvbmUgc2VsZWN0c1xuXHRcdFx0XHRcdFx0aWYgKCBvbmUgKSB7XG5cdFx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0Ly8gTXVsdGktU2VsZWN0cyByZXR1cm4gYW4gYXJyYXlcblx0XHRcdFx0XHRcdHZhbHVlcy5wdXNoKCB2YWx1ZSApO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB2YWx1ZXM7XG5cdFx0XHR9LFxuXG5cdFx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdFx0dmFyIG9wdGlvblNldCwgb3B0aW9uLFxuXHRcdFx0XHRcdG9wdGlvbnMgPSBlbGVtLm9wdGlvbnMsXG5cdFx0XHRcdFx0dmFsdWVzID0galF1ZXJ5Lm1ha2VBcnJheSggdmFsdWUgKSxcblx0XHRcdFx0XHRpID0gb3B0aW9ucy5sZW5ndGg7XG5cblx0XHRcdFx0d2hpbGUgKCBpLS0gKSB7XG5cdFx0XHRcdFx0b3B0aW9uID0gb3B0aW9uc1sgaSBdO1xuXHRcdFx0XHRcdGlmICggb3B0aW9uLnNlbGVjdGVkID1cblx0XHRcdFx0XHRcdFx0alF1ZXJ5LmluQXJyYXkoIGpRdWVyeS52YWxIb29rcy5vcHRpb24uZ2V0KCBvcHRpb24gKSwgdmFsdWVzICkgPiAtMVxuXHRcdFx0XHRcdCkge1xuXHRcdFx0XHRcdFx0b3B0aW9uU2V0ID0gdHJ1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBGb3JjZSBicm93c2VycyB0byBiZWhhdmUgY29uc2lzdGVudGx5IHdoZW4gbm9uLW1hdGNoaW5nIHZhbHVlIGlzIHNldFxuXHRcdFx0XHRpZiAoICFvcHRpb25TZXQgKSB7XG5cdFx0XHRcdFx0ZWxlbS5zZWxlY3RlZEluZGV4ID0gLTE7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlcztcblx0XHRcdH1cblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gUmFkaW9zIGFuZCBjaGVja2JveGVzIGdldHRlci9zZXR0ZXJcbmpRdWVyeS5lYWNoKCBbIFwicmFkaW9cIiwgXCJjaGVja2JveFwiIF0sIGZ1bmN0aW9uKCkge1xuXHRqUXVlcnkudmFsSG9va3NbIHRoaXMgXSA9IHtcblx0XHRzZXQ6IGZ1bmN0aW9uKCBlbGVtLCB2YWx1ZSApIHtcblx0XHRcdGlmICggalF1ZXJ5LmlzQXJyYXkoIHZhbHVlICkgKSB7XG5cdFx0XHRcdHJldHVybiAoIGVsZW0uY2hlY2tlZCA9IGpRdWVyeS5pbkFycmF5KCBqUXVlcnkoIGVsZW0gKS52YWwoKSwgdmFsdWUgKSA+IC0xICk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRpZiAoICFzdXBwb3J0LmNoZWNrT24gKSB7XG5cdFx0alF1ZXJ5LnZhbEhvb2tzWyB0aGlzIF0uZ2V0ID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdFx0XHRyZXR1cm4gZWxlbS5nZXRBdHRyaWJ1dGUoIFwidmFsdWVcIiApID09PSBudWxsID8gXCJvblwiIDogZWxlbS52YWx1ZTtcblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbi8vIFJldHVybiBqUXVlcnkgZm9yIGF0dHJpYnV0ZXMtb25seSBpbmNsdXNpb25cblxuXG52YXIgcmZvY3VzTW9ycGggPSAvXig/OmZvY3VzaW5mb2N1c3xmb2N1c291dGJsdXIpJC87XG5cbmpRdWVyeS5leHRlbmQoIGpRdWVyeS5ldmVudCwge1xuXG5cdHRyaWdnZXI6IGZ1bmN0aW9uKCBldmVudCwgZGF0YSwgZWxlbSwgb25seUhhbmRsZXJzICkge1xuXG5cdFx0dmFyIGksIGN1ciwgdG1wLCBidWJibGVUeXBlLCBvbnR5cGUsIGhhbmRsZSwgc3BlY2lhbCxcblx0XHRcdGV2ZW50UGF0aCA9IFsgZWxlbSB8fCBkb2N1bWVudCBdLFxuXHRcdFx0dHlwZSA9IGhhc093bi5jYWxsKCBldmVudCwgXCJ0eXBlXCIgKSA/IGV2ZW50LnR5cGUgOiBldmVudCxcblx0XHRcdG5hbWVzcGFjZXMgPSBoYXNPd24uY2FsbCggZXZlbnQsIFwibmFtZXNwYWNlXCIgKSA/IGV2ZW50Lm5hbWVzcGFjZS5zcGxpdCggXCIuXCIgKSA6IFtdO1xuXG5cdFx0Y3VyID0gdG1wID0gZWxlbSA9IGVsZW0gfHwgZG9jdW1lbnQ7XG5cblx0XHQvLyBEb24ndCBkbyBldmVudHMgb24gdGV4dCBhbmQgY29tbWVudCBub2Rlc1xuXHRcdGlmICggZWxlbS5ub2RlVHlwZSA9PT0gMyB8fCBlbGVtLm5vZGVUeXBlID09PSA4ICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIGZvY3VzL2JsdXIgbW9ycGhzIHRvIGZvY3VzaW4vb3V0OyBlbnN1cmUgd2UncmUgbm90IGZpcmluZyB0aGVtIHJpZ2h0IG5vd1xuXHRcdGlmICggcmZvY3VzTW9ycGgudGVzdCggdHlwZSArIGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgKSApIHtcblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAoIHR5cGUuaW5kZXhPZiggXCIuXCIgKSA+IC0xICkge1xuXG5cdFx0XHQvLyBOYW1lc3BhY2VkIHRyaWdnZXI7IGNyZWF0ZSBhIHJlZ2V4cCB0byBtYXRjaCBldmVudCB0eXBlIGluIGhhbmRsZSgpXG5cdFx0XHRuYW1lc3BhY2VzID0gdHlwZS5zcGxpdCggXCIuXCIgKTtcblx0XHRcdHR5cGUgPSBuYW1lc3BhY2VzLnNoaWZ0KCk7XG5cdFx0XHRuYW1lc3BhY2VzLnNvcnQoKTtcblx0XHR9XG5cdFx0b250eXBlID0gdHlwZS5pbmRleE9mKCBcIjpcIiApIDwgMCAmJiBcIm9uXCIgKyB0eXBlO1xuXG5cdFx0Ly8gQ2FsbGVyIGNhbiBwYXNzIGluIGEgalF1ZXJ5LkV2ZW50IG9iamVjdCwgT2JqZWN0LCBvciBqdXN0IGFuIGV2ZW50IHR5cGUgc3RyaW5nXG5cdFx0ZXZlbnQgPSBldmVudFsgalF1ZXJ5LmV4cGFuZG8gXSA/XG5cdFx0XHRldmVudCA6XG5cdFx0XHRuZXcgalF1ZXJ5LkV2ZW50KCB0eXBlLCB0eXBlb2YgZXZlbnQgPT09IFwib2JqZWN0XCIgJiYgZXZlbnQgKTtcblxuXHRcdC8vIFRyaWdnZXIgYml0bWFzazogJiAxIGZvciBuYXRpdmUgaGFuZGxlcnM7ICYgMiBmb3IgalF1ZXJ5IChhbHdheXMgdHJ1ZSlcblx0XHRldmVudC5pc1RyaWdnZXIgPSBvbmx5SGFuZGxlcnMgPyAyIDogMztcblx0XHRldmVudC5uYW1lc3BhY2UgPSBuYW1lc3BhY2VzLmpvaW4oIFwiLlwiICk7XG5cdFx0ZXZlbnQucm5hbWVzcGFjZSA9IGV2ZW50Lm5hbWVzcGFjZSA/XG5cdFx0XHRuZXcgUmVnRXhwKCBcIihefFxcXFwuKVwiICsgbmFtZXNwYWNlcy5qb2luKCBcIlxcXFwuKD86LipcXFxcLnwpXCIgKSArIFwiKFxcXFwufCQpXCIgKSA6XG5cdFx0XHRudWxsO1xuXG5cdFx0Ly8gQ2xlYW4gdXAgdGhlIGV2ZW50IGluIGNhc2UgaXQgaXMgYmVpbmcgcmV1c2VkXG5cdFx0ZXZlbnQucmVzdWx0ID0gdW5kZWZpbmVkO1xuXHRcdGlmICggIWV2ZW50LnRhcmdldCApIHtcblx0XHRcdGV2ZW50LnRhcmdldCA9IGVsZW07XG5cdFx0fVxuXG5cdFx0Ly8gQ2xvbmUgYW55IGluY29taW5nIGRhdGEgYW5kIHByZXBlbmQgdGhlIGV2ZW50LCBjcmVhdGluZyB0aGUgaGFuZGxlciBhcmcgbGlzdFxuXHRcdGRhdGEgPSBkYXRhID09IG51bGwgP1xuXHRcdFx0WyBldmVudCBdIDpcblx0XHRcdGpRdWVyeS5tYWtlQXJyYXkoIGRhdGEsIFsgZXZlbnQgXSApO1xuXG5cdFx0Ly8gQWxsb3cgc3BlY2lhbCBldmVudHMgdG8gZHJhdyBvdXRzaWRlIHRoZSBsaW5lc1xuXHRcdHNwZWNpYWwgPSBqUXVlcnkuZXZlbnQuc3BlY2lhbFsgdHlwZSBdIHx8IHt9O1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiBzcGVjaWFsLnRyaWdnZXIgJiYgc3BlY2lhbC50cmlnZ2VyLmFwcGx5KCBlbGVtLCBkYXRhICkgPT09IGZhbHNlICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIERldGVybWluZSBldmVudCBwcm9wYWdhdGlvbiBwYXRoIGluIGFkdmFuY2UsIHBlciBXM0MgZXZlbnRzIHNwZWMgKCM5OTUxKVxuXHRcdC8vIEJ1YmJsZSB1cCB0byBkb2N1bWVudCwgdGhlbiB0byB3aW5kb3c7IHdhdGNoIGZvciBhIGdsb2JhbCBvd25lckRvY3VtZW50IHZhciAoIzk3MjQpXG5cdFx0aWYgKCAhb25seUhhbmRsZXJzICYmICFzcGVjaWFsLm5vQnViYmxlICYmICFqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0YnViYmxlVHlwZSA9IHNwZWNpYWwuZGVsZWdhdGVUeXBlIHx8IHR5cGU7XG5cdFx0XHRpZiAoICFyZm9jdXNNb3JwaC50ZXN0KCBidWJibGVUeXBlICsgdHlwZSApICkge1xuXHRcdFx0XHRjdXIgPSBjdXIucGFyZW50Tm9kZTtcblx0XHRcdH1cblx0XHRcdGZvciAoIDsgY3VyOyBjdXIgPSBjdXIucGFyZW50Tm9kZSApIHtcblx0XHRcdFx0ZXZlbnRQYXRoLnB1c2goIGN1ciApO1xuXHRcdFx0XHR0bXAgPSBjdXI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIE9ubHkgYWRkIHdpbmRvdyBpZiB3ZSBnb3QgdG8gZG9jdW1lbnQgKGUuZy4sIG5vdCBwbGFpbiBvYmogb3IgZGV0YWNoZWQgRE9NKVxuXHRcdFx0aWYgKCB0bXAgPT09ICggZWxlbS5vd25lckRvY3VtZW50IHx8IGRvY3VtZW50ICkgKSB7XG5cdFx0XHRcdGV2ZW50UGF0aC5wdXNoKCB0bXAuZGVmYXVsdFZpZXcgfHwgdG1wLnBhcmVudFdpbmRvdyB8fCB3aW5kb3cgKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBGaXJlIGhhbmRsZXJzIG9uIHRoZSBldmVudCBwYXRoXG5cdFx0aSA9IDA7XG5cdFx0d2hpbGUgKCAoIGN1ciA9IGV2ZW50UGF0aFsgaSsrIF0gKSAmJiAhZXZlbnQuaXNQcm9wYWdhdGlvblN0b3BwZWQoKSApIHtcblxuXHRcdFx0ZXZlbnQudHlwZSA9IGkgPiAxID9cblx0XHRcdFx0YnViYmxlVHlwZSA6XG5cdFx0XHRcdHNwZWNpYWwuYmluZFR5cGUgfHwgdHlwZTtcblxuXHRcdFx0Ly8galF1ZXJ5IGhhbmRsZXJcblx0XHRcdGhhbmRsZSA9ICggZGF0YVByaXYuZ2V0KCBjdXIsIFwiZXZlbnRzXCIgKSB8fCB7fSApWyBldmVudC50eXBlIF0gJiZcblx0XHRcdFx0ZGF0YVByaXYuZ2V0KCBjdXIsIFwiaGFuZGxlXCIgKTtcblx0XHRcdGlmICggaGFuZGxlICkge1xuXHRcdFx0XHRoYW5kbGUuYXBwbHkoIGN1ciwgZGF0YSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBOYXRpdmUgaGFuZGxlclxuXHRcdFx0aGFuZGxlID0gb250eXBlICYmIGN1clsgb250eXBlIF07XG5cdFx0XHRpZiAoIGhhbmRsZSAmJiBoYW5kbGUuYXBwbHkgJiYgYWNjZXB0RGF0YSggY3VyICkgKSB7XG5cdFx0XHRcdGV2ZW50LnJlc3VsdCA9IGhhbmRsZS5hcHBseSggY3VyLCBkYXRhICk7XG5cdFx0XHRcdGlmICggZXZlbnQucmVzdWx0ID09PSBmYWxzZSApIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV2ZW50LnR5cGUgPSB0eXBlO1xuXG5cdFx0Ly8gSWYgbm9ib2R5IHByZXZlbnRlZCB0aGUgZGVmYXVsdCBhY3Rpb24sIGRvIGl0IG5vd1xuXHRcdGlmICggIW9ubHlIYW5kbGVycyAmJiAhZXZlbnQuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cblx0XHRcdGlmICggKCAhc3BlY2lhbC5fZGVmYXVsdCB8fFxuXHRcdFx0XHRzcGVjaWFsLl9kZWZhdWx0LmFwcGx5KCBldmVudFBhdGgucG9wKCksIGRhdGEgKSA9PT0gZmFsc2UgKSAmJlxuXHRcdFx0XHRhY2NlcHREYXRhKCBlbGVtICkgKSB7XG5cblx0XHRcdFx0Ly8gQ2FsbCBhIG5hdGl2ZSBET00gbWV0aG9kIG9uIHRoZSB0YXJnZXQgd2l0aCB0aGUgc2FtZSBuYW1lIG5hbWUgYXMgdGhlIGV2ZW50LlxuXHRcdFx0XHQvLyBEb24ndCBkbyBkZWZhdWx0IGFjdGlvbnMgb24gd2luZG93LCB0aGF0J3Mgd2hlcmUgZ2xvYmFsIHZhcmlhYmxlcyBiZSAoIzYxNzApXG5cdFx0XHRcdGlmICggb250eXBlICYmIGpRdWVyeS5pc0Z1bmN0aW9uKCBlbGVtWyB0eXBlIF0gKSAmJiAhalF1ZXJ5LmlzV2luZG93KCBlbGVtICkgKSB7XG5cblx0XHRcdFx0XHQvLyBEb24ndCByZS10cmlnZ2VyIGFuIG9uRk9PIGV2ZW50IHdoZW4gd2UgY2FsbCBpdHMgRk9PKCkgbWV0aG9kXG5cdFx0XHRcdFx0dG1wID0gZWxlbVsgb250eXBlIF07XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gbnVsbDtcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHQvLyBQcmV2ZW50IHJlLXRyaWdnZXJpbmcgb2YgdGhlIHNhbWUgZXZlbnQsIHNpbmNlIHdlIGFscmVhZHkgYnViYmxlZCBpdCBhYm92ZVxuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB0eXBlO1xuXHRcdFx0XHRcdGVsZW1bIHR5cGUgXSgpO1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyZWQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdFx0XHRpZiAoIHRtcCApIHtcblx0XHRcdFx0XHRcdGVsZW1bIG9udHlwZSBdID0gdG1wO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBldmVudC5yZXN1bHQ7XG5cdH0sXG5cblx0Ly8gUGlnZ3liYWNrIG9uIGEgZG9ub3IgZXZlbnQgdG8gc2ltdWxhdGUgYSBkaWZmZXJlbnQgb25lXG5cdHNpbXVsYXRlOiBmdW5jdGlvbiggdHlwZSwgZWxlbSwgZXZlbnQgKSB7XG5cdFx0dmFyIGUgPSBqUXVlcnkuZXh0ZW5kKFxuXHRcdFx0bmV3IGpRdWVyeS5FdmVudCgpLFxuXHRcdFx0ZXZlbnQsXG5cdFx0XHR7XG5cdFx0XHRcdHR5cGU6IHR5cGUsXG5cdFx0XHRcdGlzU2ltdWxhdGVkOiB0cnVlXG5cblx0XHRcdFx0Ly8gUHJldmlvdXNseSwgYG9yaWdpbmFsRXZlbnQ6IHt9YCB3YXMgc2V0IGhlcmUsIHNvIHN0b3BQcm9wYWdhdGlvbiBjYWxsXG5cdFx0XHRcdC8vIHdvdWxkIG5vdCBiZSB0cmlnZ2VyZWQgb24gZG9ub3IgZXZlbnQsIHNpbmNlIGluIG91ciBvd25cblx0XHRcdFx0Ly8galF1ZXJ5LmV2ZW50LnN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvbiB3ZSBoYWQgYSBjaGVjayBmb3IgZXhpc3RlbmNlIG9mXG5cdFx0XHRcdC8vIG9yaWdpbmFsRXZlbnQuc3RvcFByb3BhZ2F0aW9uIG1ldGhvZCwgc28sIGNvbnNlcXVlbnRseSBpdCB3b3VsZCBiZSBhIG5vb3AuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIEJ1dCBub3csIHRoaXMgXCJzaW11bGF0ZVwiIGZ1bmN0aW9uIGlzIHVzZWQgb25seSBmb3IgZXZlbnRzXG5cdFx0XHRcdC8vIGZvciB3aGljaCBzdG9wUHJvcGFnYXRpb24oKSBpcyBub29wLCBzbyB0aGVyZSBpcyBubyBuZWVkIGZvciB0aGF0IGFueW1vcmUuXG5cdFx0XHRcdC8vXG5cdFx0XHRcdC8vIEZvciB0aGUgY29tcGF0IGJyYW5jaCB0aG91Z2gsIGd1YXJkIGZvciBcImNsaWNrXCIgYW5kIFwic3VibWl0XCJcblx0XHRcdFx0Ly8gZXZlbnRzIGlzIHN0aWxsIHVzZWQsIGJ1dCB3YXMgbW92ZWQgdG8galF1ZXJ5LmV2ZW50LnN0b3BQcm9wYWdhdGlvbiBmdW5jdGlvblxuXHRcdFx0XHQvLyBiZWNhdXNlIGBvcmlnaW5hbEV2ZW50YCBzaG91bGQgcG9pbnQgdG8gdGhlIG9yaWdpbmFsIGV2ZW50IGZvciB0aGUgY29uc3RhbmN5XG5cdFx0XHRcdC8vIHdpdGggb3RoZXIgZXZlbnRzIGFuZCBmb3IgbW9yZSBmb2N1c2VkIGxvZ2ljXG5cdFx0XHR9XG5cdFx0KTtcblxuXHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBlLCBudWxsLCBlbGVtICk7XG5cblx0XHRpZiAoIGUuaXNEZWZhdWx0UHJldmVudGVkKCkgKSB7XG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fVxuXG59ICk7XG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHR0cmlnZ2VyOiBmdW5jdGlvbiggdHlwZSwgZGF0YSApIHtcblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCB0aGlzICk7XG5cdFx0fSApO1xuXHR9LFxuXHR0cmlnZ2VySGFuZGxlcjogZnVuY3Rpb24oIHR5cGUsIGRhdGEgKSB7XG5cdFx0dmFyIGVsZW0gPSB0aGlzWyAwIF07XG5cdFx0aWYgKCBlbGVtICkge1xuXHRcdFx0cmV0dXJuIGpRdWVyeS5ldmVudC50cmlnZ2VyKCB0eXBlLCBkYXRhLCBlbGVtLCB0cnVlICk7XG5cdFx0fVxuXHR9XG59ICk7XG5cblxualF1ZXJ5LmVhY2goICggXCJibHVyIGZvY3VzIGZvY3VzaW4gZm9jdXNvdXQgbG9hZCByZXNpemUgc2Nyb2xsIHVubG9hZCBjbGljayBkYmxjbGljayBcIiArXG5cdFwibW91c2Vkb3duIG1vdXNldXAgbW91c2Vtb3ZlIG1vdXNlb3ZlciBtb3VzZW91dCBtb3VzZWVudGVyIG1vdXNlbGVhdmUgXCIgK1xuXHRcImNoYW5nZSBzZWxlY3Qgc3VibWl0IGtleWRvd24ga2V5cHJlc3Mga2V5dXAgZXJyb3IgY29udGV4dG1lbnVcIiApLnNwbGl0KCBcIiBcIiApLFxuXHRmdW5jdGlvbiggaSwgbmFtZSApIHtcblxuXHQvLyBIYW5kbGUgZXZlbnQgYmluZGluZ1xuXHRqUXVlcnkuZm5bIG5hbWUgXSA9IGZ1bmN0aW9uKCBkYXRhLCBmbiApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDAgP1xuXHRcdFx0dGhpcy5vbiggbmFtZSwgbnVsbCwgZGF0YSwgZm4gKSA6XG5cdFx0XHR0aGlzLnRyaWdnZXIoIG5hbWUgKTtcblx0fTtcbn0gKTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRob3ZlcjogZnVuY3Rpb24oIGZuT3ZlciwgZm5PdXQgKSB7XG5cdFx0cmV0dXJuIHRoaXMubW91c2VlbnRlciggZm5PdmVyICkubW91c2VsZWF2ZSggZm5PdXQgfHwgZm5PdmVyICk7XG5cdH1cbn0gKTtcblxuXG5cblxuc3VwcG9ydC5mb2N1c2luID0gXCJvbmZvY3VzaW5cIiBpbiB3aW5kb3c7XG5cblxuLy8gU3VwcG9ydDogRmlyZWZveFxuLy8gRmlyZWZveCBkb2Vzbid0IGhhdmUgZm9jdXMoaW4gfCBvdXQpIGV2ZW50c1xuLy8gUmVsYXRlZCB0aWNrZXQgLSBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD02ODc3ODdcbi8vXG4vLyBTdXBwb3J0OiBDaHJvbWUsIFNhZmFyaVxuLy8gZm9jdXMoaW4gfCBvdXQpIGV2ZW50cyBmaXJlIGFmdGVyIGZvY3VzICYgYmx1ciBldmVudHMsXG4vLyB3aGljaCBpcyBzcGVjIHZpb2xhdGlvbiAtIGh0dHA6Ly93d3cudzMub3JnL1RSL0RPTS1MZXZlbC0zLUV2ZW50cy8jZXZlbnRzLWZvY3VzZXZlbnQtZXZlbnQtb3JkZXJcbi8vIFJlbGF0ZWQgdGlja2V0IC0gaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTQ0OTg1N1xuaWYgKCAhc3VwcG9ydC5mb2N1c2luICkge1xuXHRqUXVlcnkuZWFjaCggeyBmb2N1czogXCJmb2N1c2luXCIsIGJsdXI6IFwiZm9jdXNvdXRcIiB9LCBmdW5jdGlvbiggb3JpZywgZml4ICkge1xuXG5cdFx0Ly8gQXR0YWNoIGEgc2luZ2xlIGNhcHR1cmluZyBoYW5kbGVyIG9uIHRoZSBkb2N1bWVudCB3aGlsZSBzb21lb25lIHdhbnRzIGZvY3VzaW4vZm9jdXNvdXRcblx0XHR2YXIgaGFuZGxlciA9IGZ1bmN0aW9uKCBldmVudCApIHtcblx0XHRcdGpRdWVyeS5ldmVudC5zaW11bGF0ZSggZml4LCBldmVudC50YXJnZXQsIGpRdWVyeS5ldmVudC5maXgoIGV2ZW50ICkgKTtcblx0XHR9O1xuXG5cdFx0alF1ZXJ5LmV2ZW50LnNwZWNpYWxbIGZpeCBdID0ge1xuXHRcdFx0c2V0dXA6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgZG9jID0gdGhpcy5vd25lckRvY3VtZW50IHx8IHRoaXMsXG5cdFx0XHRcdFx0YXR0YWNoZXMgPSBkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLmFkZEV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCAoIGF0dGFjaGVzIHx8IDAgKSArIDEgKTtcblx0XHRcdH0sXG5cdFx0XHR0ZWFyZG93bjogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBkb2MgPSB0aGlzLm93bmVyRG9jdW1lbnQgfHwgdGhpcyxcblx0XHRcdFx0XHRhdHRhY2hlcyA9IGRhdGFQcml2LmFjY2VzcyggZG9jLCBmaXggKSAtIDE7XG5cblx0XHRcdFx0aWYgKCAhYXR0YWNoZXMgKSB7XG5cdFx0XHRcdFx0ZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoIG9yaWcsIGhhbmRsZXIsIHRydWUgKTtcblx0XHRcdFx0XHRkYXRhUHJpdi5yZW1vdmUoIGRvYywgZml4ICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkYXRhUHJpdi5hY2Nlc3MoIGRvYywgZml4LCBhdHRhY2hlcyApO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0fSApO1xufVxudmFyIGxvY2F0aW9uID0gd2luZG93LmxvY2F0aW9uO1xuXG52YXIgbm9uY2UgPSBqUXVlcnkubm93KCk7XG5cbnZhciBycXVlcnkgPSAoIC9cXD8vICk7XG5cblxuXG4vLyBTdXBwb3J0OiBBbmRyb2lkIDIuM1xuLy8gV29ya2Fyb3VuZCBmYWlsdXJlIHRvIHN0cmluZy1jYXN0IG51bGwgaW5wdXRcbmpRdWVyeS5wYXJzZUpTT04gPSBmdW5jdGlvbiggZGF0YSApIHtcblx0cmV0dXJuIEpTT04ucGFyc2UoIGRhdGEgKyBcIlwiICk7XG59O1xuXG5cbi8vIENyb3NzLWJyb3dzZXIgeG1sIHBhcnNpbmdcbmpRdWVyeS5wYXJzZVhNTCA9IGZ1bmN0aW9uKCBkYXRhICkge1xuXHR2YXIgeG1sO1xuXHRpZiAoICFkYXRhIHx8IHR5cGVvZiBkYXRhICE9PSBcInN0cmluZ1wiICkge1xuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0Ly8gU3VwcG9ydDogSUU5XG5cdHRyeSB7XG5cdFx0eG1sID0gKCBuZXcgd2luZG93LkRPTVBhcnNlcigpICkucGFyc2VGcm9tU3RyaW5nKCBkYXRhLCBcInRleHQveG1sXCIgKTtcblx0fSBjYXRjaCAoIGUgKSB7XG5cdFx0eG1sID0gdW5kZWZpbmVkO1xuXHR9XG5cblx0aWYgKCAheG1sIHx8IHhtbC5nZXRFbGVtZW50c0J5VGFnTmFtZSggXCJwYXJzZXJlcnJvclwiICkubGVuZ3RoICkge1xuXHRcdGpRdWVyeS5lcnJvciggXCJJbnZhbGlkIFhNTDogXCIgKyBkYXRhICk7XG5cdH1cblx0cmV0dXJuIHhtbDtcbn07XG5cblxudmFyXG5cdHJoYXNoID0gLyMuKiQvLFxuXHRydHMgPSAvKFs/Jl0pXz1bXiZdKi8sXG5cdHJoZWFkZXJzID0gL14oLio/KTpbIFxcdF0qKFteXFxyXFxuXSopJC9tZyxcblxuXHQvLyAjNzY1MywgIzgxMjUsICM4MTUyOiBsb2NhbCBwcm90b2NvbCBkZXRlY3Rpb25cblx0cmxvY2FsUHJvdG9jb2wgPSAvXig/OmFib3V0fGFwcHxhcHAtc3RvcmFnZXwuKy1leHRlbnNpb258ZmlsZXxyZXN8d2lkZ2V0KTokLyxcblx0cm5vQ29udGVudCA9IC9eKD86R0VUfEhFQUQpJC8sXG5cdHJwcm90b2NvbCA9IC9eXFwvXFwvLyxcblxuXHQvKiBQcmVmaWx0ZXJzXG5cdCAqIDEpIFRoZXkgYXJlIHVzZWZ1bCB0byBpbnRyb2R1Y2UgY3VzdG9tIGRhdGFUeXBlcyAoc2VlIGFqYXgvanNvbnAuanMgZm9yIGFuIGV4YW1wbGUpXG5cdCAqIDIpIFRoZXNlIGFyZSBjYWxsZWQ6XG5cdCAqICAgIC0gQkVGT1JFIGFza2luZyBmb3IgYSB0cmFuc3BvcnRcblx0ICogICAgLSBBRlRFUiBwYXJhbSBzZXJpYWxpemF0aW9uIChzLmRhdGEgaXMgYSBzdHJpbmcgaWYgcy5wcm9jZXNzRGF0YSBpcyB0cnVlKVxuXHQgKiAzKSBrZXkgaXMgdGhlIGRhdGFUeXBlXG5cdCAqIDQpIHRoZSBjYXRjaGFsbCBzeW1ib2wgXCIqXCIgY2FuIGJlIHVzZWRcblx0ICogNSkgZXhlY3V0aW9uIHdpbGwgc3RhcnQgd2l0aCB0cmFuc3BvcnQgZGF0YVR5cGUgYW5kIFRIRU4gY29udGludWUgZG93biB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHByZWZpbHRlcnMgPSB7fSxcblxuXHQvKiBUcmFuc3BvcnRzIGJpbmRpbmdzXG5cdCAqIDEpIGtleSBpcyB0aGUgZGF0YVR5cGVcblx0ICogMikgdGhlIGNhdGNoYWxsIHN5bWJvbCBcIipcIiBjYW4gYmUgdXNlZFxuXHQgKiAzKSBzZWxlY3Rpb24gd2lsbCBzdGFydCB3aXRoIHRyYW5zcG9ydCBkYXRhVHlwZSBhbmQgVEhFTiBnbyB0byBcIipcIiBpZiBuZWVkZWRcblx0ICovXG5cdHRyYW5zcG9ydHMgPSB7fSxcblxuXHQvLyBBdm9pZCBjb21tZW50LXByb2xvZyBjaGFyIHNlcXVlbmNlICgjMTAwOTgpOyBtdXN0IGFwcGVhc2UgbGludCBhbmQgZXZhZGUgY29tcHJlc3Npb25cblx0YWxsVHlwZXMgPSBcIiovXCIuY29uY2F0KCBcIipcIiApLFxuXG5cdC8vIEFuY2hvciB0YWcgZm9yIHBhcnNpbmcgdGhlIGRvY3VtZW50IG9yaWdpblxuXHRvcmlnaW5BbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXHRvcmlnaW5BbmNob3IuaHJlZiA9IGxvY2F0aW9uLmhyZWY7XG5cbi8vIEJhc2UgXCJjb25zdHJ1Y3RvclwiIGZvciBqUXVlcnkuYWpheFByZWZpbHRlciBhbmQgalF1ZXJ5LmFqYXhUcmFuc3BvcnRcbmZ1bmN0aW9uIGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggc3RydWN0dXJlICkge1xuXG5cdC8vIGRhdGFUeXBlRXhwcmVzc2lvbiBpcyBvcHRpb25hbCBhbmQgZGVmYXVsdHMgdG8gXCIqXCJcblx0cmV0dXJuIGZ1bmN0aW9uKCBkYXRhVHlwZUV4cHJlc3Npb24sIGZ1bmMgKSB7XG5cblx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZUV4cHJlc3Npb24gIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRmdW5jID0gZGF0YVR5cGVFeHByZXNzaW9uO1xuXHRcdFx0ZGF0YVR5cGVFeHByZXNzaW9uID0gXCIqXCI7XG5cdFx0fVxuXG5cdFx0dmFyIGRhdGFUeXBlLFxuXHRcdFx0aSA9IDAsXG5cdFx0XHRkYXRhVHlwZXMgPSBkYXRhVHlwZUV4cHJlc3Npb24udG9Mb3dlckNhc2UoKS5tYXRjaCggcm5vdHdoaXRlICkgfHwgW107XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBmdW5jICkgKSB7XG5cblx0XHRcdC8vIEZvciBlYWNoIGRhdGFUeXBlIGluIHRoZSBkYXRhVHlwZUV4cHJlc3Npb25cblx0XHRcdHdoaWxlICggKCBkYXRhVHlwZSA9IGRhdGFUeXBlc1sgaSsrIF0gKSApIHtcblxuXHRcdFx0XHQvLyBQcmVwZW5kIGlmIHJlcXVlc3RlZFxuXHRcdFx0XHRpZiAoIGRhdGFUeXBlWyAwIF0gPT09IFwiK1wiICkge1xuXHRcdFx0XHRcdGRhdGFUeXBlID0gZGF0YVR5cGUuc2xpY2UoIDEgKSB8fCBcIipcIjtcblx0XHRcdFx0XHQoIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSA9IHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSApLnVuc2hpZnQoIGZ1bmMgKTtcblxuXHRcdFx0XHQvLyBPdGhlcndpc2UgYXBwZW5kXG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0KCBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gPSBzdHJ1Y3R1cmVbIGRhdGFUeXBlIF0gfHwgW10gKS5wdXNoKCBmdW5jICk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH07XG59XG5cbi8vIEJhc2UgaW5zcGVjdGlvbiBmdW5jdGlvbiBmb3IgcHJlZmlsdGVycyBhbmQgdHJhbnNwb3J0c1xuZnVuY3Rpb24gaW5zcGVjdFByZWZpbHRlcnNPclRyYW5zcG9ydHMoIHN0cnVjdHVyZSwgb3B0aW9ucywgb3JpZ2luYWxPcHRpb25zLCBqcVhIUiApIHtcblxuXHR2YXIgaW5zcGVjdGVkID0ge30sXG5cdFx0c2Vla2luZ1RyYW5zcG9ydCA9ICggc3RydWN0dXJlID09PSB0cmFuc3BvcnRzICk7XG5cblx0ZnVuY3Rpb24gaW5zcGVjdCggZGF0YVR5cGUgKSB7XG5cdFx0dmFyIHNlbGVjdGVkO1xuXHRcdGluc3BlY3RlZFsgZGF0YVR5cGUgXSA9IHRydWU7XG5cdFx0alF1ZXJ5LmVhY2goIHN0cnVjdHVyZVsgZGF0YVR5cGUgXSB8fCBbXSwgZnVuY3Rpb24oIF8sIHByZWZpbHRlck9yRmFjdG9yeSApIHtcblx0XHRcdHZhciBkYXRhVHlwZU9yVHJhbnNwb3J0ID0gcHJlZmlsdGVyT3JGYWN0b3J5KCBvcHRpb25zLCBvcmlnaW5hbE9wdGlvbnMsIGpxWEhSICk7XG5cdFx0XHRpZiAoIHR5cGVvZiBkYXRhVHlwZU9yVHJhbnNwb3J0ID09PSBcInN0cmluZ1wiICYmXG5cdFx0XHRcdCFzZWVraW5nVHJhbnNwb3J0ICYmICFpbnNwZWN0ZWRbIGRhdGFUeXBlT3JUcmFuc3BvcnQgXSApIHtcblxuXHRcdFx0XHRvcHRpb25zLmRhdGFUeXBlcy51bnNoaWZ0KCBkYXRhVHlwZU9yVHJhbnNwb3J0ICk7XG5cdFx0XHRcdGluc3BlY3QoIGRhdGFUeXBlT3JUcmFuc3BvcnQgKTtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICggc2Vla2luZ1RyYW5zcG9ydCApIHtcblx0XHRcdFx0cmV0dXJuICEoIHNlbGVjdGVkID0gZGF0YVR5cGVPclRyYW5zcG9ydCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0XHRyZXR1cm4gc2VsZWN0ZWQ7XG5cdH1cblxuXHRyZXR1cm4gaW5zcGVjdCggb3B0aW9ucy5kYXRhVHlwZXNbIDAgXSApIHx8ICFpbnNwZWN0ZWRbIFwiKlwiIF0gJiYgaW5zcGVjdCggXCIqXCIgKTtcbn1cblxuLy8gQSBzcGVjaWFsIGV4dGVuZCBmb3IgYWpheCBvcHRpb25zXG4vLyB0aGF0IHRha2VzIFwiZmxhdFwiIG9wdGlvbnMgKG5vdCB0byBiZSBkZWVwIGV4dGVuZGVkKVxuLy8gRml4ZXMgIzk4ODdcbmZ1bmN0aW9uIGFqYXhFeHRlbmQoIHRhcmdldCwgc3JjICkge1xuXHR2YXIga2V5LCBkZWVwLFxuXHRcdGZsYXRPcHRpb25zID0galF1ZXJ5LmFqYXhTZXR0aW5ncy5mbGF0T3B0aW9ucyB8fCB7fTtcblxuXHRmb3IgKCBrZXkgaW4gc3JjICkge1xuXHRcdGlmICggc3JjWyBrZXkgXSAhPT0gdW5kZWZpbmVkICkge1xuXHRcdFx0KCBmbGF0T3B0aW9uc1sga2V5IF0gPyB0YXJnZXQgOiAoIGRlZXAgfHwgKCBkZWVwID0ge30gKSApIClbIGtleSBdID0gc3JjWyBrZXkgXTtcblx0XHR9XG5cdH1cblx0aWYgKCBkZWVwICkge1xuXHRcdGpRdWVyeS5leHRlbmQoIHRydWUsIHRhcmdldCwgZGVlcCApO1xuXHR9XG5cblx0cmV0dXJuIHRhcmdldDtcbn1cblxuLyogSGFuZGxlcyByZXNwb25zZXMgdG8gYW4gYWpheCByZXF1ZXN0OlxuICogLSBmaW5kcyB0aGUgcmlnaHQgZGF0YVR5cGUgKG1lZGlhdGVzIGJldHdlZW4gY29udGVudC10eXBlIGFuZCBleHBlY3RlZCBkYXRhVHlwZSlcbiAqIC0gcmV0dXJucyB0aGUgY29ycmVzcG9uZGluZyByZXNwb25zZVxuICovXG5mdW5jdGlvbiBhamF4SGFuZGxlUmVzcG9uc2VzKCBzLCBqcVhIUiwgcmVzcG9uc2VzICkge1xuXG5cdHZhciBjdCwgdHlwZSwgZmluYWxEYXRhVHlwZSwgZmlyc3REYXRhVHlwZSxcblx0XHRjb250ZW50cyA9IHMuY29udGVudHMsXG5cdFx0ZGF0YVR5cGVzID0gcy5kYXRhVHlwZXM7XG5cblx0Ly8gUmVtb3ZlIGF1dG8gZGF0YVR5cGUgYW5kIGdldCBjb250ZW50LXR5cGUgaW4gdGhlIHByb2Nlc3Ncblx0d2hpbGUgKCBkYXRhVHlwZXNbIDAgXSA9PT0gXCIqXCIgKSB7XG5cdFx0ZGF0YVR5cGVzLnNoaWZ0KCk7XG5cdFx0aWYgKCBjdCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0Y3QgPSBzLm1pbWVUeXBlIHx8IGpxWEhSLmdldFJlc3BvbnNlSGVhZGVyKCBcIkNvbnRlbnQtVHlwZVwiICk7XG5cdFx0fVxuXHR9XG5cblx0Ly8gQ2hlY2sgaWYgd2UncmUgZGVhbGluZyB3aXRoIGEga25vd24gY29udGVudC10eXBlXG5cdGlmICggY3QgKSB7XG5cdFx0Zm9yICggdHlwZSBpbiBjb250ZW50cyApIHtcblx0XHRcdGlmICggY29udGVudHNbIHR5cGUgXSAmJiBjb250ZW50c1sgdHlwZSBdLnRlc3QoIGN0ICkgKSB7XG5cdFx0XHRcdGRhdGFUeXBlcy51bnNoaWZ0KCB0eXBlICk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8vIENoZWNrIHRvIHNlZSBpZiB3ZSBoYXZlIGEgcmVzcG9uc2UgZm9yIHRoZSBleHBlY3RlZCBkYXRhVHlwZVxuXHRpZiAoIGRhdGFUeXBlc1sgMCBdIGluIHJlc3BvbnNlcyApIHtcblx0XHRmaW5hbERhdGFUeXBlID0gZGF0YVR5cGVzWyAwIF07XG5cdH0gZWxzZSB7XG5cblx0XHQvLyBUcnkgY29udmVydGlibGUgZGF0YVR5cGVzXG5cdFx0Zm9yICggdHlwZSBpbiByZXNwb25zZXMgKSB7XG5cdFx0XHRpZiAoICFkYXRhVHlwZXNbIDAgXSB8fCBzLmNvbnZlcnRlcnNbIHR5cGUgKyBcIiBcIiArIGRhdGFUeXBlc1sgMCBdIF0gKSB7XG5cdFx0XHRcdGZpbmFsRGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHRcdGlmICggIWZpcnN0RGF0YVR5cGUgKSB7XG5cdFx0XHRcdGZpcnN0RGF0YVR5cGUgPSB0eXBlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIE9yIGp1c3QgdXNlIGZpcnN0IG9uZVxuXHRcdGZpbmFsRGF0YVR5cGUgPSBmaW5hbERhdGFUeXBlIHx8IGZpcnN0RGF0YVR5cGU7XG5cdH1cblxuXHQvLyBJZiB3ZSBmb3VuZCBhIGRhdGFUeXBlXG5cdC8vIFdlIGFkZCB0aGUgZGF0YVR5cGUgdG8gdGhlIGxpc3QgaWYgbmVlZGVkXG5cdC8vIGFuZCByZXR1cm4gdGhlIGNvcnJlc3BvbmRpbmcgcmVzcG9uc2Vcblx0aWYgKCBmaW5hbERhdGFUeXBlICkge1xuXHRcdGlmICggZmluYWxEYXRhVHlwZSAhPT0gZGF0YVR5cGVzWyAwIF0gKSB7XG5cdFx0XHRkYXRhVHlwZXMudW5zaGlmdCggZmluYWxEYXRhVHlwZSApO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVzcG9uc2VzWyBmaW5hbERhdGFUeXBlIF07XG5cdH1cbn1cblxuLyogQ2hhaW4gY29udmVyc2lvbnMgZ2l2ZW4gdGhlIHJlcXVlc3QgYW5kIHRoZSBvcmlnaW5hbCByZXNwb25zZVxuICogQWxzbyBzZXRzIHRoZSByZXNwb25zZVhYWCBmaWVsZHMgb24gdGhlIGpxWEhSIGluc3RhbmNlXG4gKi9cbmZ1bmN0aW9uIGFqYXhDb252ZXJ0KCBzLCByZXNwb25zZSwganFYSFIsIGlzU3VjY2VzcyApIHtcblx0dmFyIGNvbnYyLCBjdXJyZW50LCBjb252LCB0bXAsIHByZXYsXG5cdFx0Y29udmVydGVycyA9IHt9LFxuXG5cdFx0Ly8gV29yayB3aXRoIGEgY29weSBvZiBkYXRhVHlwZXMgaW4gY2FzZSB3ZSBuZWVkIHRvIG1vZGlmeSBpdCBmb3IgY29udmVyc2lvblxuXHRcdGRhdGFUeXBlcyA9IHMuZGF0YVR5cGVzLnNsaWNlKCk7XG5cblx0Ly8gQ3JlYXRlIGNvbnZlcnRlcnMgbWFwIHdpdGggbG93ZXJjYXNlZCBrZXlzXG5cdGlmICggZGF0YVR5cGVzWyAxIF0gKSB7XG5cdFx0Zm9yICggY29udiBpbiBzLmNvbnZlcnRlcnMgKSB7XG5cdFx0XHRjb252ZXJ0ZXJzWyBjb252LnRvTG93ZXJDYXNlKCkgXSA9IHMuY29udmVydGVyc1sgY29udiBdO1xuXHRcdH1cblx0fVxuXG5cdGN1cnJlbnQgPSBkYXRhVHlwZXMuc2hpZnQoKTtcblxuXHQvLyBDb252ZXJ0IHRvIGVhY2ggc2VxdWVudGlhbCBkYXRhVHlwZVxuXHR3aGlsZSAoIGN1cnJlbnQgKSB7XG5cblx0XHRpZiAoIHMucmVzcG9uc2VGaWVsZHNbIGN1cnJlbnQgXSApIHtcblx0XHRcdGpxWEhSWyBzLnJlc3BvbnNlRmllbGRzWyBjdXJyZW50IF0gXSA9IHJlc3BvbnNlO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHRoZSBkYXRhRmlsdGVyIGlmIHByb3ZpZGVkXG5cdFx0aWYgKCAhcHJldiAmJiBpc1N1Y2Nlc3MgJiYgcy5kYXRhRmlsdGVyICkge1xuXHRcdFx0cmVzcG9uc2UgPSBzLmRhdGFGaWx0ZXIoIHJlc3BvbnNlLCBzLmRhdGFUeXBlICk7XG5cdFx0fVxuXG5cdFx0cHJldiA9IGN1cnJlbnQ7XG5cdFx0Y3VycmVudCA9IGRhdGFUeXBlcy5zaGlmdCgpO1xuXG5cdFx0aWYgKCBjdXJyZW50ICkge1xuXG5cdFx0Ly8gVGhlcmUncyBvbmx5IHdvcmsgdG8gZG8gaWYgY3VycmVudCBkYXRhVHlwZSBpcyBub24tYXV0b1xuXHRcdFx0aWYgKCBjdXJyZW50ID09PSBcIipcIiApIHtcblxuXHRcdFx0XHRjdXJyZW50ID0gcHJldjtcblxuXHRcdFx0Ly8gQ29udmVydCByZXNwb25zZSBpZiBwcmV2IGRhdGFUeXBlIGlzIG5vbi1hdXRvIGFuZCBkaWZmZXJzIGZyb20gY3VycmVudFxuXHRcdFx0fSBlbHNlIGlmICggcHJldiAhPT0gXCIqXCIgJiYgcHJldiAhPT0gY3VycmVudCApIHtcblxuXHRcdFx0XHQvLyBTZWVrIGEgZGlyZWN0IGNvbnZlcnRlclxuXHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgY3VycmVudCBdIHx8IGNvbnZlcnRlcnNbIFwiKiBcIiArIGN1cnJlbnQgXTtcblxuXHRcdFx0XHQvLyBJZiBub25lIGZvdW5kLCBzZWVrIGEgcGFpclxuXHRcdFx0XHRpZiAoICFjb252ICkge1xuXHRcdFx0XHRcdGZvciAoIGNvbnYyIGluIGNvbnZlcnRlcnMgKSB7XG5cblx0XHRcdFx0XHRcdC8vIElmIGNvbnYyIG91dHB1dHMgY3VycmVudFxuXHRcdFx0XHRcdFx0dG1wID0gY29udjIuc3BsaXQoIFwiIFwiICk7XG5cdFx0XHRcdFx0XHRpZiAoIHRtcFsgMSBdID09PSBjdXJyZW50ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIElmIHByZXYgY2FuIGJlIGNvbnZlcnRlZCB0byBhY2NlcHRlZCBpbnB1dFxuXHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgcHJldiArIFwiIFwiICsgdG1wWyAwIF0gXSB8fFxuXHRcdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbIFwiKiBcIiArIHRtcFsgMCBdIF07XG5cdFx0XHRcdFx0XHRcdGlmICggY29udiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIENvbmRlbnNlIGVxdWl2YWxlbmNlIGNvbnZlcnRlcnNcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNvbnYgPT09IHRydWUgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb252ID0gY29udmVydGVyc1sgY29udjIgXTtcblxuXHRcdFx0XHRcdFx0XHRcdC8vIE90aGVyd2lzZSwgaW5zZXJ0IHRoZSBpbnRlcm1lZGlhdGUgZGF0YVR5cGVcblx0XHRcdFx0XHRcdFx0XHR9IGVsc2UgaWYgKCBjb252ZXJ0ZXJzWyBjb252MiBdICE9PSB0cnVlICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IHRtcFsgMCBdO1xuXHRcdFx0XHRcdFx0XHRcdFx0ZGF0YVR5cGVzLnVuc2hpZnQoIHRtcFsgMSBdICk7XG5cdFx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gQXBwbHkgY29udmVydGVyIChpZiBub3QgYW4gZXF1aXZhbGVuY2UpXG5cdFx0XHRcdGlmICggY29udiAhPT0gdHJ1ZSApIHtcblxuXHRcdFx0XHRcdC8vIFVubGVzcyBlcnJvcnMgYXJlIGFsbG93ZWQgdG8gYnViYmxlLCBjYXRjaCBhbmQgcmV0dXJuIHRoZW1cblx0XHRcdFx0XHRpZiAoIGNvbnYgJiYgcy50aHJvd3MgKSB7XG5cdFx0XHRcdFx0XHRyZXNwb25zZSA9IGNvbnYoIHJlc3BvbnNlICk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlID0gY29udiggcmVzcG9uc2UgKTtcblx0XHRcdFx0XHRcdH0gY2F0Y2ggKCBlICkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdFx0XHRcdHN0YXRlOiBcInBhcnNlcmVycm9yXCIsXG5cdFx0XHRcdFx0XHRcdFx0ZXJyb3I6IGNvbnYgPyBlIDogXCJObyBjb252ZXJzaW9uIGZyb20gXCIgKyBwcmV2ICsgXCIgdG8gXCIgKyBjdXJyZW50XG5cdFx0XHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGU6IFwic3VjY2Vzc1wiLCBkYXRhOiByZXNwb25zZSB9O1xufVxuXG5qUXVlcnkuZXh0ZW5kKCB7XG5cblx0Ly8gQ291bnRlciBmb3IgaG9sZGluZyB0aGUgbnVtYmVyIG9mIGFjdGl2ZSBxdWVyaWVzXG5cdGFjdGl2ZTogMCxcblxuXHQvLyBMYXN0LU1vZGlmaWVkIGhlYWRlciBjYWNoZSBmb3IgbmV4dCByZXF1ZXN0XG5cdGxhc3RNb2RpZmllZDoge30sXG5cdGV0YWc6IHt9LFxuXG5cdGFqYXhTZXR0aW5nczoge1xuXHRcdHVybDogbG9jYXRpb24uaHJlZixcblx0XHR0eXBlOiBcIkdFVFwiLFxuXHRcdGlzTG9jYWw6IHJsb2NhbFByb3RvY29sLnRlc3QoIGxvY2F0aW9uLnByb3RvY29sICksXG5cdFx0Z2xvYmFsOiB0cnVlLFxuXHRcdHByb2Nlc3NEYXRhOiB0cnVlLFxuXHRcdGFzeW5jOiB0cnVlLFxuXHRcdGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZDsgY2hhcnNldD1VVEYtOFwiLFxuXHRcdC8qXG5cdFx0dGltZW91dDogMCxcblx0XHRkYXRhOiBudWxsLFxuXHRcdGRhdGFUeXBlOiBudWxsLFxuXHRcdHVzZXJuYW1lOiBudWxsLFxuXHRcdHBhc3N3b3JkOiBudWxsLFxuXHRcdGNhY2hlOiBudWxsLFxuXHRcdHRocm93czogZmFsc2UsXG5cdFx0dHJhZGl0aW9uYWw6IGZhbHNlLFxuXHRcdGhlYWRlcnM6IHt9LFxuXHRcdCovXG5cblx0XHRhY2NlcHRzOiB7XG5cdFx0XHRcIipcIjogYWxsVHlwZXMsXG5cdFx0XHR0ZXh0OiBcInRleHQvcGxhaW5cIixcblx0XHRcdGh0bWw6IFwidGV4dC9odG1sXCIsXG5cdFx0XHR4bWw6IFwiYXBwbGljYXRpb24veG1sLCB0ZXh0L3htbFwiLFxuXHRcdFx0anNvbjogXCJhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L2phdmFzY3JpcHRcIlxuXHRcdH0sXG5cblx0XHRjb250ZW50czoge1xuXHRcdFx0eG1sOiAvXFxieG1sXFxiLyxcblx0XHRcdGh0bWw6IC9cXGJodG1sLyxcblx0XHRcdGpzb246IC9cXGJqc29uXFxiL1xuXHRcdH0sXG5cblx0XHRyZXNwb25zZUZpZWxkczoge1xuXHRcdFx0eG1sOiBcInJlc3BvbnNlWE1MXCIsXG5cdFx0XHR0ZXh0OiBcInJlc3BvbnNlVGV4dFwiLFxuXHRcdFx0anNvbjogXCJyZXNwb25zZUpTT05cIlxuXHRcdH0sXG5cblx0XHQvLyBEYXRhIGNvbnZlcnRlcnNcblx0XHQvLyBLZXlzIHNlcGFyYXRlIHNvdXJjZSAob3IgY2F0Y2hhbGwgXCIqXCIpIGFuZCBkZXN0aW5hdGlvbiB0eXBlcyB3aXRoIGEgc2luZ2xlIHNwYWNlXG5cdFx0Y29udmVydGVyczoge1xuXG5cdFx0XHQvLyBDb252ZXJ0IGFueXRoaW5nIHRvIHRleHRcblx0XHRcdFwiKiB0ZXh0XCI6IFN0cmluZyxcblxuXHRcdFx0Ly8gVGV4dCB0byBodG1sICh0cnVlID0gbm8gdHJhbnNmb3JtYXRpb24pXG5cdFx0XHRcInRleHQgaHRtbFwiOiB0cnVlLFxuXG5cdFx0XHQvLyBFdmFsdWF0ZSB0ZXh0IGFzIGEganNvbiBleHByZXNzaW9uXG5cdFx0XHRcInRleHQganNvblwiOiBqUXVlcnkucGFyc2VKU09OLFxuXG5cdFx0XHQvLyBQYXJzZSB0ZXh0IGFzIHhtbFxuXHRcdFx0XCJ0ZXh0IHhtbFwiOiBqUXVlcnkucGFyc2VYTUxcblx0XHR9LFxuXG5cdFx0Ly8gRm9yIG9wdGlvbnMgdGhhdCBzaG91bGRuJ3QgYmUgZGVlcCBleHRlbmRlZDpcblx0XHQvLyB5b3UgY2FuIGFkZCB5b3VyIG93biBjdXN0b20gb3B0aW9ucyBoZXJlIGlmXG5cdFx0Ly8gYW5kIHdoZW4geW91IGNyZWF0ZSBvbmUgdGhhdCBzaG91bGRuJ3QgYmVcblx0XHQvLyBkZWVwIGV4dGVuZGVkIChzZWUgYWpheEV4dGVuZClcblx0XHRmbGF0T3B0aW9uczoge1xuXHRcdFx0dXJsOiB0cnVlLFxuXHRcdFx0Y29udGV4dDogdHJ1ZVxuXHRcdH1cblx0fSxcblxuXHQvLyBDcmVhdGVzIGEgZnVsbCBmbGVkZ2VkIHNldHRpbmdzIG9iamVjdCBpbnRvIHRhcmdldFxuXHQvLyB3aXRoIGJvdGggYWpheFNldHRpbmdzIGFuZCBzZXR0aW5ncyBmaWVsZHMuXG5cdC8vIElmIHRhcmdldCBpcyBvbWl0dGVkLCB3cml0ZXMgaW50byBhamF4U2V0dGluZ3MuXG5cdGFqYXhTZXR1cDogZnVuY3Rpb24oIHRhcmdldCwgc2V0dGluZ3MgKSB7XG5cdFx0cmV0dXJuIHNldHRpbmdzID9cblxuXHRcdFx0Ly8gQnVpbGRpbmcgYSBzZXR0aW5ncyBvYmplY3Rcblx0XHRcdGFqYXhFeHRlbmQoIGFqYXhFeHRlbmQoIHRhcmdldCwgalF1ZXJ5LmFqYXhTZXR0aW5ncyApLCBzZXR0aW5ncyApIDpcblxuXHRcdFx0Ly8gRXh0ZW5kaW5nIGFqYXhTZXR0aW5nc1xuXHRcdFx0YWpheEV4dGVuZCggalF1ZXJ5LmFqYXhTZXR0aW5ncywgdGFyZ2V0ICk7XG5cdH0sXG5cblx0YWpheFByZWZpbHRlcjogYWRkVG9QcmVmaWx0ZXJzT3JUcmFuc3BvcnRzKCBwcmVmaWx0ZXJzICksXG5cdGFqYXhUcmFuc3BvcnQ6IGFkZFRvUHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cyApLFxuXG5cdC8vIE1haW4gbWV0aG9kXG5cdGFqYXg6IGZ1bmN0aW9uKCB1cmwsIG9wdGlvbnMgKSB7XG5cblx0XHQvLyBJZiB1cmwgaXMgYW4gb2JqZWN0LCBzaW11bGF0ZSBwcmUtMS41IHNpZ25hdHVyZVxuXHRcdGlmICggdHlwZW9mIHVybCA9PT0gXCJvYmplY3RcIiApIHtcblx0XHRcdG9wdGlvbnMgPSB1cmw7XG5cdFx0XHR1cmwgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXG5cdFx0Ly8gRm9yY2Ugb3B0aW9ucyB0byBiZSBhbiBvYmplY3Rcblx0XHRvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcblxuXHRcdHZhciB0cmFuc3BvcnQsXG5cblx0XHRcdC8vIFVSTCB3aXRob3V0IGFudGktY2FjaGUgcGFyYW1cblx0XHRcdGNhY2hlVVJMLFxuXG5cdFx0XHQvLyBSZXNwb25zZSBoZWFkZXJzXG5cdFx0XHRyZXNwb25zZUhlYWRlcnNTdHJpbmcsXG5cdFx0XHRyZXNwb25zZUhlYWRlcnMsXG5cblx0XHRcdC8vIHRpbWVvdXQgaGFuZGxlXG5cdFx0XHR0aW1lb3V0VGltZXIsXG5cblx0XHRcdC8vIFVybCBjbGVhbnVwIHZhclxuXHRcdFx0dXJsQW5jaG9yLFxuXG5cdFx0XHQvLyBUbyBrbm93IGlmIGdsb2JhbCBldmVudHMgYXJlIHRvIGJlIGRpc3BhdGNoZWRcblx0XHRcdGZpcmVHbG9iYWxzLFxuXG5cdFx0XHQvLyBMb29wIHZhcmlhYmxlXG5cdFx0XHRpLFxuXG5cdFx0XHQvLyBDcmVhdGUgdGhlIGZpbmFsIG9wdGlvbnMgb2JqZWN0XG5cdFx0XHRzID0galF1ZXJ5LmFqYXhTZXR1cCgge30sIG9wdGlvbnMgKSxcblxuXHRcdFx0Ly8gQ2FsbGJhY2tzIGNvbnRleHRcblx0XHRcdGNhbGxiYWNrQ29udGV4dCA9IHMuY29udGV4dCB8fCBzLFxuXG5cdFx0XHQvLyBDb250ZXh0IGZvciBnbG9iYWwgZXZlbnRzIGlzIGNhbGxiYWNrQ29udGV4dCBpZiBpdCBpcyBhIERPTSBub2RlIG9yIGpRdWVyeSBjb2xsZWN0aW9uXG5cdFx0XHRnbG9iYWxFdmVudENvbnRleHQgPSBzLmNvbnRleHQgJiZcblx0XHRcdFx0KCBjYWxsYmFja0NvbnRleHQubm9kZVR5cGUgfHwgY2FsbGJhY2tDb250ZXh0LmpxdWVyeSApID9cblx0XHRcdFx0XHRqUXVlcnkoIGNhbGxiYWNrQ29udGV4dCApIDpcblx0XHRcdFx0XHRqUXVlcnkuZXZlbnQsXG5cblx0XHRcdC8vIERlZmVycmVkc1xuXHRcdFx0ZGVmZXJyZWQgPSBqUXVlcnkuRGVmZXJyZWQoKSxcblx0XHRcdGNvbXBsZXRlRGVmZXJyZWQgPSBqUXVlcnkuQ2FsbGJhY2tzKCBcIm9uY2UgbWVtb3J5XCIgKSxcblxuXHRcdFx0Ly8gU3RhdHVzLWRlcGVuZGVudCBjYWxsYmFja3Ncblx0XHRcdHN0YXR1c0NvZGUgPSBzLnN0YXR1c0NvZGUgfHwge30sXG5cblx0XHRcdC8vIEhlYWRlcnMgKHRoZXkgYXJlIHNlbnQgYWxsIGF0IG9uY2UpXG5cdFx0XHRyZXF1ZXN0SGVhZGVycyA9IHt9LFxuXHRcdFx0cmVxdWVzdEhlYWRlcnNOYW1lcyA9IHt9LFxuXG5cdFx0XHQvLyBUaGUganFYSFIgc3RhdGVcblx0XHRcdHN0YXRlID0gMCxcblxuXHRcdFx0Ly8gRGVmYXVsdCBhYm9ydCBtZXNzYWdlXG5cdFx0XHRzdHJBYm9ydCA9IFwiY2FuY2VsZWRcIixcblxuXHRcdFx0Ly8gRmFrZSB4aHJcblx0XHRcdGpxWEhSID0ge1xuXHRcdFx0XHRyZWFkeVN0YXRlOiAwLFxuXG5cdFx0XHRcdC8vIEJ1aWxkcyBoZWFkZXJzIGhhc2h0YWJsZSBpZiBuZWVkZWRcblx0XHRcdFx0Z2V0UmVzcG9uc2VIZWFkZXI6IGZ1bmN0aW9uKCBrZXkgKSB7XG5cdFx0XHRcdFx0dmFyIG1hdGNoO1xuXHRcdFx0XHRcdGlmICggc3RhdGUgPT09IDIgKSB7XG5cdFx0XHRcdFx0XHRpZiAoICFyZXNwb25zZUhlYWRlcnMgKSB7XG5cdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVycyA9IHt9O1xuXHRcdFx0XHRcdFx0XHR3aGlsZSAoICggbWF0Y2ggPSByaGVhZGVycy5leGVjKCByZXNwb25zZUhlYWRlcnNTdHJpbmcgKSApICkge1xuXHRcdFx0XHRcdFx0XHRcdHJlc3BvbnNlSGVhZGVyc1sgbWF0Y2hbIDEgXS50b0xvd2VyQ2FzZSgpIF0gPSBtYXRjaFsgMiBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRtYXRjaCA9IHJlc3BvbnNlSGVhZGVyc1sga2V5LnRvTG93ZXJDYXNlKCkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIG1hdGNoID09IG51bGwgPyBudWxsIDogbWF0Y2g7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gUmF3IHN0cmluZ1xuXHRcdFx0XHRnZXRBbGxSZXNwb25zZUhlYWRlcnM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHJldHVybiBzdGF0ZSA9PT0gMiA/IHJlc3BvbnNlSGVhZGVyc1N0cmluZyA6IG51bGw7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FjaGVzIHRoZSBoZWFkZXJcblx0XHRcdFx0c2V0UmVxdWVzdEhlYWRlcjogZnVuY3Rpb24oIG5hbWUsIHZhbHVlICkge1xuXHRcdFx0XHRcdHZhciBsbmFtZSA9IG5hbWUudG9Mb3dlckNhc2UoKTtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdG5hbWUgPSByZXF1ZXN0SGVhZGVyc05hbWVzWyBsbmFtZSBdID0gcmVxdWVzdEhlYWRlcnNOYW1lc1sgbG5hbWUgXSB8fCBuYW1lO1xuXHRcdFx0XHRcdFx0cmVxdWVzdEhlYWRlcnNbIG5hbWUgXSA9IHZhbHVlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBPdmVycmlkZXMgcmVzcG9uc2UgY29udGVudC10eXBlIGhlYWRlclxuXHRcdFx0XHRvdmVycmlkZU1pbWVUeXBlOiBmdW5jdGlvbiggdHlwZSApIHtcblx0XHRcdFx0XHRpZiAoICFzdGF0ZSApIHtcblx0XHRcdFx0XHRcdHMubWltZVR5cGUgPSB0eXBlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gdGhpcztcblx0XHRcdFx0fSxcblxuXHRcdFx0XHQvLyBTdGF0dXMtZGVwZW5kZW50IGNhbGxiYWNrc1xuXHRcdFx0XHRzdGF0dXNDb2RlOiBmdW5jdGlvbiggbWFwICkge1xuXHRcdFx0XHRcdHZhciBjb2RlO1xuXHRcdFx0XHRcdGlmICggbWFwICkge1xuXHRcdFx0XHRcdFx0aWYgKCBzdGF0ZSA8IDIgKSB7XG5cdFx0XHRcdFx0XHRcdGZvciAoIGNvZGUgaW4gbWFwICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gTGF6eS1hZGQgdGhlIG5ldyBjYWxsYmFjayBpbiBhIHdheSB0aGF0IHByZXNlcnZlcyBvbGQgb25lc1xuXHRcdFx0XHRcdFx0XHRcdHN0YXR1c0NvZGVbIGNvZGUgXSA9IFsgc3RhdHVzQ29kZVsgY29kZSBdLCBtYXBbIGNvZGUgXSBdO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEV4ZWN1dGUgdGhlIGFwcHJvcHJpYXRlIGNhbGxiYWNrc1xuXHRcdFx0XHRcdFx0XHRqcVhIUi5hbHdheXMoIG1hcFsganFYSFIuc3RhdHVzIF0gKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIHRoaXM7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0Ly8gQ2FuY2VsIHRoZSByZXF1ZXN0XG5cdFx0XHRcdGFib3J0OiBmdW5jdGlvbiggc3RhdHVzVGV4dCApIHtcblx0XHRcdFx0XHR2YXIgZmluYWxUZXh0ID0gc3RhdHVzVGV4dCB8fCBzdHJBYm9ydDtcblx0XHRcdFx0XHRpZiAoIHRyYW5zcG9ydCApIHtcblx0XHRcdFx0XHRcdHRyYW5zcG9ydC5hYm9ydCggZmluYWxUZXh0ICk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRvbmUoIDAsIGZpbmFsVGV4dCApO1xuXHRcdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0Ly8gQXR0YWNoIGRlZmVycmVkc1xuXHRcdGRlZmVycmVkLnByb21pc2UoIGpxWEhSICkuY29tcGxldGUgPSBjb21wbGV0ZURlZmVycmVkLmFkZDtcblx0XHRqcVhIUi5zdWNjZXNzID0ganFYSFIuZG9uZTtcblx0XHRqcVhIUi5lcnJvciA9IGpxWEhSLmZhaWw7XG5cblx0XHQvLyBSZW1vdmUgaGFzaCBjaGFyYWN0ZXIgKCM3NTMxOiBhbmQgc3RyaW5nIHByb21vdGlvbilcblx0XHQvLyBBZGQgcHJvdG9jb2wgaWYgbm90IHByb3ZpZGVkIChwcmVmaWx0ZXJzIG1pZ2h0IGV4cGVjdCBpdClcblx0XHQvLyBIYW5kbGUgZmFsc3kgdXJsIGluIHRoZSBzZXR0aW5ncyBvYmplY3QgKCMxMDA5MzogY29uc2lzdGVuY3kgd2l0aCBvbGQgc2lnbmF0dXJlKVxuXHRcdC8vIFdlIGFsc28gdXNlIHRoZSB1cmwgcGFyYW1ldGVyIGlmIGF2YWlsYWJsZVxuXHRcdHMudXJsID0gKCAoIHVybCB8fCBzLnVybCB8fCBsb2NhdGlvbi5ocmVmICkgKyBcIlwiICkucmVwbGFjZSggcmhhc2gsIFwiXCIgKVxuXHRcdFx0LnJlcGxhY2UoIHJwcm90b2NvbCwgbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKTtcblxuXHRcdC8vIEFsaWFzIG1ldGhvZCBvcHRpb24gdG8gdHlwZSBhcyBwZXIgdGlja2V0ICMxMjAwNFxuXHRcdHMudHlwZSA9IG9wdGlvbnMubWV0aG9kIHx8IG9wdGlvbnMudHlwZSB8fCBzLm1ldGhvZCB8fCBzLnR5cGU7XG5cblx0XHQvLyBFeHRyYWN0IGRhdGFUeXBlcyBsaXN0XG5cdFx0cy5kYXRhVHlwZXMgPSBqUXVlcnkudHJpbSggcy5kYXRhVHlwZSB8fCBcIipcIiApLnRvTG93ZXJDYXNlKCkubWF0Y2goIHJub3R3aGl0ZSApIHx8IFsgXCJcIiBdO1xuXG5cdFx0Ly8gQSBjcm9zcy1kb21haW4gcmVxdWVzdCBpcyBpbiBvcmRlciB3aGVuIHRoZSBvcmlnaW4gZG9lc24ndCBtYXRjaCB0aGUgY3VycmVudCBvcmlnaW4uXG5cdFx0aWYgKCBzLmNyb3NzRG9tYWluID09IG51bGwgKSB7XG5cdFx0XHR1cmxBbmNob3IgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCBcImFcIiApO1xuXG5cdFx0XHQvLyBTdXBwb3J0OiBJRTgtMTErXG5cdFx0XHQvLyBJRSB0aHJvd3MgZXhjZXB0aW9uIGlmIHVybCBpcyBtYWxmb3JtZWQsIGUuZy4gaHR0cDovL2V4YW1wbGUuY29tOjgweC9cblx0XHRcdHRyeSB7XG5cdFx0XHRcdHVybEFuY2hvci5ocmVmID0gcy51cmw7XG5cblx0XHRcdFx0Ly8gU3VwcG9ydDogSUU4LTExK1xuXHRcdFx0XHQvLyBBbmNob3IncyBob3N0IHByb3BlcnR5IGlzbid0IGNvcnJlY3RseSBzZXQgd2hlbiBzLnVybCBpcyByZWxhdGl2ZVxuXHRcdFx0XHR1cmxBbmNob3IuaHJlZiA9IHVybEFuY2hvci5ocmVmO1xuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gb3JpZ2luQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgb3JpZ2luQW5jaG9yLmhvc3QgIT09XG5cdFx0XHRcdFx0dXJsQW5jaG9yLnByb3RvY29sICsgXCIvL1wiICsgdXJsQW5jaG9yLmhvc3Q7XG5cdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHQvLyBJZiB0aGVyZSBpcyBhbiBlcnJvciBwYXJzaW5nIHRoZSBVUkwsIGFzc3VtZSBpdCBpcyBjcm9zc0RvbWFpbixcblx0XHRcdFx0Ly8gaXQgY2FuIGJlIHJlamVjdGVkIGJ5IHRoZSB0cmFuc3BvcnQgaWYgaXQgaXMgaW52YWxpZFxuXHRcdFx0XHRzLmNyb3NzRG9tYWluID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDb252ZXJ0IGRhdGEgaWYgbm90IGFscmVhZHkgYSBzdHJpbmdcblx0XHRpZiAoIHMuZGF0YSAmJiBzLnByb2Nlc3NEYXRhICYmIHR5cGVvZiBzLmRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0XHRzLmRhdGEgPSBqUXVlcnkucGFyYW0oIHMuZGF0YSwgcy50cmFkaXRpb25hbCApO1xuXHRcdH1cblxuXHRcdC8vIEFwcGx5IHByZWZpbHRlcnNcblx0XHRpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggcHJlZmlsdGVycywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGEgcHJlZmlsdGVyLCBzdG9wIHRoZXJlXG5cdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdHJldHVybiBqcVhIUjtcblx0XHR9XG5cblx0XHQvLyBXZSBjYW4gZmlyZSBnbG9iYWwgZXZlbnRzIGFzIG9mIG5vdyBpZiBhc2tlZCB0b1xuXHRcdC8vIERvbid0IGZpcmUgZXZlbnRzIGlmIGpRdWVyeS5ldmVudCBpcyB1bmRlZmluZWQgaW4gYW4gQU1ELXVzYWdlIHNjZW5hcmlvICgjMTUxMTgpXG5cdFx0ZmlyZUdsb2JhbHMgPSBqUXVlcnkuZXZlbnQgJiYgcy5nbG9iYWw7XG5cblx0XHQvLyBXYXRjaCBmb3IgYSBuZXcgc2V0IG9mIHJlcXVlc3RzXG5cdFx0aWYgKCBmaXJlR2xvYmFscyAmJiBqUXVlcnkuYWN0aXZlKysgPT09IDAgKSB7XG5cdFx0XHRqUXVlcnkuZXZlbnQudHJpZ2dlciggXCJhamF4U3RhcnRcIiApO1xuXHRcdH1cblxuXHRcdC8vIFVwcGVyY2FzZSB0aGUgdHlwZVxuXHRcdHMudHlwZSA9IHMudHlwZS50b1VwcGVyQ2FzZSgpO1xuXG5cdFx0Ly8gRGV0ZXJtaW5lIGlmIHJlcXVlc3QgaGFzIGNvbnRlbnRcblx0XHRzLmhhc0NvbnRlbnQgPSAhcm5vQ29udGVudC50ZXN0KCBzLnR5cGUgKTtcblxuXHRcdC8vIFNhdmUgdGhlIFVSTCBpbiBjYXNlIHdlJ3JlIHRveWluZyB3aXRoIHRoZSBJZi1Nb2RpZmllZC1TaW5jZVxuXHRcdC8vIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciBsYXRlciBvblxuXHRcdGNhY2hlVVJMID0gcy51cmw7XG5cblx0XHQvLyBNb3JlIG9wdGlvbnMgaGFuZGxpbmcgZm9yIHJlcXVlc3RzIHdpdGggbm8gY29udGVudFxuXHRcdGlmICggIXMuaGFzQ29udGVudCApIHtcblxuXHRcdFx0Ly8gSWYgZGF0YSBpcyBhdmFpbGFibGUsIGFwcGVuZCBkYXRhIHRvIHVybFxuXHRcdFx0aWYgKCBzLmRhdGEgKSB7XG5cdFx0XHRcdGNhY2hlVVJMID0gKCBzLnVybCArPSAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgcy5kYXRhICk7XG5cblx0XHRcdFx0Ly8gIzk2ODI6IHJlbW92ZSBkYXRhIHNvIHRoYXQgaXQncyBub3QgdXNlZCBpbiBhbiBldmVudHVhbCByZXRyeVxuXHRcdFx0XHRkZWxldGUgcy5kYXRhO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgYW50aS1jYWNoZSBpbiB1cmwgaWYgbmVlZGVkXG5cdFx0XHRpZiAoIHMuY2FjaGUgPT09IGZhbHNlICkge1xuXHRcdFx0XHRzLnVybCA9IHJ0cy50ZXN0KCBjYWNoZVVSTCApID9cblxuXHRcdFx0XHRcdC8vIElmIHRoZXJlIGlzIGFscmVhZHkgYSAnXycgcGFyYW1ldGVyLCBzZXQgaXRzIHZhbHVlXG5cdFx0XHRcdFx0Y2FjaGVVUkwucmVwbGFjZSggcnRzLCBcIiQxXz1cIiArIG5vbmNlKysgKSA6XG5cblx0XHRcdFx0XHQvLyBPdGhlcndpc2UgYWRkIG9uZSB0byB0aGUgZW5kXG5cdFx0XHRcdFx0Y2FjaGVVUkwgKyAoIHJxdWVyeS50ZXN0KCBjYWNoZVVSTCApID8gXCImXCIgOiBcIj9cIiApICsgXCJfPVwiICsgbm9uY2UrKztcblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBTZXQgdGhlIElmLU1vZGlmaWVkLVNpbmNlIGFuZC9vciBJZi1Ob25lLU1hdGNoIGhlYWRlciwgaWYgaW4gaWZNb2RpZmllZCBtb2RlLlxuXHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0aWYgKCBqUXVlcnkubGFzdE1vZGlmaWVkWyBjYWNoZVVSTCBdICkge1xuXHRcdFx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKCBcIklmLU1vZGlmaWVkLVNpbmNlXCIsIGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gKTtcblx0XHRcdH1cblx0XHRcdGlmICggalF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gKSB7XG5cdFx0XHRcdGpxWEhSLnNldFJlcXVlc3RIZWFkZXIoIFwiSWYtTm9uZS1NYXRjaFwiLCBqUXVlcnkuZXRhZ1sgY2FjaGVVUkwgXSApO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgY29ycmVjdCBoZWFkZXIsIGlmIGRhdGEgaXMgYmVpbmcgc2VudFxuXHRcdGlmICggcy5kYXRhICYmIHMuaGFzQ29udGVudCAmJiBzLmNvbnRlbnRUeXBlICE9PSBmYWxzZSB8fCBvcHRpb25zLmNvbnRlbnRUeXBlICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggXCJDb250ZW50LVR5cGVcIiwgcy5jb250ZW50VHlwZSApO1xuXHRcdH1cblxuXHRcdC8vIFNldCB0aGUgQWNjZXB0cyBoZWFkZXIgZm9yIHRoZSBzZXJ2ZXIsIGRlcGVuZGluZyBvbiB0aGUgZGF0YVR5cGVcblx0XHRqcVhIUi5zZXRSZXF1ZXN0SGVhZGVyKFxuXHRcdFx0XCJBY2NlcHRcIixcblx0XHRcdHMuZGF0YVR5cGVzWyAwIF0gJiYgcy5hY2NlcHRzWyBzLmRhdGFUeXBlc1sgMCBdIF0gP1xuXHRcdFx0XHRzLmFjY2VwdHNbIHMuZGF0YVR5cGVzWyAwIF0gXSArXG5cdFx0XHRcdFx0KCBzLmRhdGFUeXBlc1sgMCBdICE9PSBcIipcIiA/IFwiLCBcIiArIGFsbFR5cGVzICsgXCI7IHE9MC4wMVwiIDogXCJcIiApIDpcblx0XHRcdFx0cy5hY2NlcHRzWyBcIipcIiBdXG5cdFx0KTtcblxuXHRcdC8vIENoZWNrIGZvciBoZWFkZXJzIG9wdGlvblxuXHRcdGZvciAoIGkgaW4gcy5oZWFkZXJzICkge1xuXHRcdFx0anFYSFIuc2V0UmVxdWVzdEhlYWRlciggaSwgcy5oZWFkZXJzWyBpIF0gKTtcblx0XHR9XG5cblx0XHQvLyBBbGxvdyBjdXN0b20gaGVhZGVycy9taW1ldHlwZXMgYW5kIGVhcmx5IGFib3J0XG5cdFx0aWYgKCBzLmJlZm9yZVNlbmQgJiZcblx0XHRcdCggcy5iZWZvcmVTZW5kLmNhbGwoIGNhbGxiYWNrQ29udGV4dCwganFYSFIsIHMgKSA9PT0gZmFsc2UgfHwgc3RhdGUgPT09IDIgKSApIHtcblxuXHRcdFx0Ly8gQWJvcnQgaWYgbm90IGRvbmUgYWxyZWFkeSBhbmQgcmV0dXJuXG5cdFx0XHRyZXR1cm4ganFYSFIuYWJvcnQoKTtcblx0XHR9XG5cblx0XHQvLyBBYm9ydGluZyBpcyBubyBsb25nZXIgYSBjYW5jZWxsYXRpb25cblx0XHRzdHJBYm9ydCA9IFwiYWJvcnRcIjtcblxuXHRcdC8vIEluc3RhbGwgY2FsbGJhY2tzIG9uIGRlZmVycmVkc1xuXHRcdGZvciAoIGkgaW4geyBzdWNjZXNzOiAxLCBlcnJvcjogMSwgY29tcGxldGU6IDEgfSApIHtcblx0XHRcdGpxWEhSWyBpIF0oIHNbIGkgXSApO1xuXHRcdH1cblxuXHRcdC8vIEdldCB0cmFuc3BvcnRcblx0XHR0cmFuc3BvcnQgPSBpbnNwZWN0UHJlZmlsdGVyc09yVHJhbnNwb3J0cyggdHJhbnNwb3J0cywgcywgb3B0aW9ucywganFYSFIgKTtcblxuXHRcdC8vIElmIG5vIHRyYW5zcG9ydCwgd2UgYXV0by1hYm9ydFxuXHRcdGlmICggIXRyYW5zcG9ydCApIHtcblx0XHRcdGRvbmUoIC0xLCBcIk5vIFRyYW5zcG9ydFwiICk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSAxO1xuXG5cdFx0XHQvLyBTZW5kIGdsb2JhbCBldmVudFxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheFNlbmRcIiwgWyBqcVhIUiwgcyBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIElmIHJlcXVlc3Qgd2FzIGFib3J0ZWQgaW5zaWRlIGFqYXhTZW5kLCBzdG9wIHRoZXJlXG5cdFx0XHRpZiAoIHN0YXRlID09PSAyICkge1xuXHRcdFx0XHRyZXR1cm4ganFYSFI7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFRpbWVvdXRcblx0XHRcdGlmICggcy5hc3luYyAmJiBzLnRpbWVvdXQgPiAwICkge1xuXHRcdFx0XHR0aW1lb3V0VGltZXIgPSB3aW5kb3cuc2V0VGltZW91dCggZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0anFYSFIuYWJvcnQoIFwidGltZW91dFwiICk7XG5cdFx0XHRcdH0sIHMudGltZW91dCApO1xuXHRcdFx0fVxuXG5cdFx0XHR0cnkge1xuXHRcdFx0XHRzdGF0ZSA9IDE7XG5cdFx0XHRcdHRyYW5zcG9ydC5zZW5kKCByZXF1ZXN0SGVhZGVycywgZG9uZSApO1xuXHRcdFx0fSBjYXRjaCAoIGUgKSB7XG5cblx0XHRcdFx0Ly8gUHJvcGFnYXRlIGV4Y2VwdGlvbiBhcyBlcnJvciBpZiBub3QgZG9uZVxuXHRcdFx0XHRpZiAoIHN0YXRlIDwgMiApIHtcblx0XHRcdFx0XHRkb25lKCAtMSwgZSApO1xuXG5cdFx0XHRcdC8vIFNpbXBseSByZXRocm93IG90aGVyd2lzZVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBDYWxsYmFjayBmb3Igd2hlbiBldmVyeXRoaW5nIGlzIGRvbmVcblx0XHRmdW5jdGlvbiBkb25lKCBzdGF0dXMsIG5hdGl2ZVN0YXR1c1RleHQsIHJlc3BvbnNlcywgaGVhZGVycyApIHtcblx0XHRcdHZhciBpc1N1Y2Nlc3MsIHN1Y2Nlc3MsIGVycm9yLCByZXNwb25zZSwgbW9kaWZpZWQsXG5cdFx0XHRcdHN0YXR1c1RleHQgPSBuYXRpdmVTdGF0dXNUZXh0O1xuXG5cdFx0XHQvLyBDYWxsZWQgb25jZVxuXHRcdFx0aWYgKCBzdGF0ZSA9PT0gMiApIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBTdGF0ZSBpcyBcImRvbmVcIiBub3dcblx0XHRcdHN0YXRlID0gMjtcblxuXHRcdFx0Ly8gQ2xlYXIgdGltZW91dCBpZiBpdCBleGlzdHNcblx0XHRcdGlmICggdGltZW91dFRpbWVyICkge1xuXHRcdFx0XHR3aW5kb3cuY2xlYXJUaW1lb3V0KCB0aW1lb3V0VGltZXIgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gRGVyZWZlcmVuY2UgdHJhbnNwb3J0IGZvciBlYXJseSBnYXJiYWdlIGNvbGxlY3Rpb25cblx0XHRcdC8vIChubyBtYXR0ZXIgaG93IGxvbmcgdGhlIGpxWEhSIG9iamVjdCB3aWxsIGJlIHVzZWQpXG5cdFx0XHR0cmFuc3BvcnQgPSB1bmRlZmluZWQ7XG5cblx0XHRcdC8vIENhY2hlIHJlc3BvbnNlIGhlYWRlcnNcblx0XHRcdHJlc3BvbnNlSGVhZGVyc1N0cmluZyA9IGhlYWRlcnMgfHwgXCJcIjtcblxuXHRcdFx0Ly8gU2V0IHJlYWR5U3RhdGVcblx0XHRcdGpxWEhSLnJlYWR5U3RhdGUgPSBzdGF0dXMgPiAwID8gNCA6IDA7XG5cblx0XHRcdC8vIERldGVybWluZSBpZiBzdWNjZXNzZnVsXG5cdFx0XHRpc1N1Y2Nlc3MgPSBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMCB8fCBzdGF0dXMgPT09IDMwNDtcblxuXHRcdFx0Ly8gR2V0IHJlc3BvbnNlIGRhdGFcblx0XHRcdGlmICggcmVzcG9uc2VzICkge1xuXHRcdFx0XHRyZXNwb25zZSA9IGFqYXhIYW5kbGVSZXNwb25zZXMoIHMsIGpxWEhSLCByZXNwb25zZXMgKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQ29udmVydCBubyBtYXR0ZXIgd2hhdCAodGhhdCB3YXkgcmVzcG9uc2VYWFggZmllbGRzIGFyZSBhbHdheXMgc2V0KVxuXHRcdFx0cmVzcG9uc2UgPSBhamF4Q29udmVydCggcywgcmVzcG9uc2UsIGpxWEhSLCBpc1N1Y2Nlc3MgKTtcblxuXHRcdFx0Ly8gSWYgc3VjY2Vzc2Z1bCwgaGFuZGxlIHR5cGUgY2hhaW5pbmdcblx0XHRcdGlmICggaXNTdWNjZXNzICkge1xuXG5cdFx0XHRcdC8vIFNldCB0aGUgSWYtTW9kaWZpZWQtU2luY2UgYW5kL29yIElmLU5vbmUtTWF0Y2ggaGVhZGVyLCBpZiBpbiBpZk1vZGlmaWVkIG1vZGUuXG5cdFx0XHRcdGlmICggcy5pZk1vZGlmaWVkICkge1xuXHRcdFx0XHRcdG1vZGlmaWVkID0ganFYSFIuZ2V0UmVzcG9uc2VIZWFkZXIoIFwiTGFzdC1Nb2RpZmllZFwiICk7XG5cdFx0XHRcdFx0aWYgKCBtb2RpZmllZCApIHtcblx0XHRcdFx0XHRcdGpRdWVyeS5sYXN0TW9kaWZpZWRbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0bW9kaWZpZWQgPSBqcVhIUi5nZXRSZXNwb25zZUhlYWRlciggXCJldGFnXCIgKTtcblx0XHRcdFx0XHRpZiAoIG1vZGlmaWVkICkge1xuXHRcdFx0XHRcdFx0alF1ZXJ5LmV0YWdbIGNhY2hlVVJMIF0gPSBtb2RpZmllZDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBpZiBubyBjb250ZW50XG5cdFx0XHRcdGlmICggc3RhdHVzID09PSAyMDQgfHwgcy50eXBlID09PSBcIkhFQURcIiApIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gXCJub2NvbnRlbnRcIjtcblxuXHRcdFx0XHQvLyBpZiBub3QgbW9kaWZpZWRcblx0XHRcdFx0fSBlbHNlIGlmICggc3RhdHVzID09PSAzMDQgKSB7XG5cdFx0XHRcdFx0c3RhdHVzVGV4dCA9IFwibm90bW9kaWZpZWRcIjtcblxuXHRcdFx0XHQvLyBJZiB3ZSBoYXZlIGRhdGEsIGxldCdzIGNvbnZlcnQgaXRcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRzdGF0dXNUZXh0ID0gcmVzcG9uc2Uuc3RhdGU7XG5cdFx0XHRcdFx0c3VjY2VzcyA9IHJlc3BvbnNlLmRhdGE7XG5cdFx0XHRcdFx0ZXJyb3IgPSByZXNwb25zZS5lcnJvcjtcblx0XHRcdFx0XHRpc1N1Y2Nlc3MgPSAhZXJyb3I7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gRXh0cmFjdCBlcnJvciBmcm9tIHN0YXR1c1RleHQgYW5kIG5vcm1hbGl6ZSBmb3Igbm9uLWFib3J0c1xuXHRcdFx0XHRlcnJvciA9IHN0YXR1c1RleHQ7XG5cdFx0XHRcdGlmICggc3RhdHVzIHx8ICFzdGF0dXNUZXh0ICkge1xuXHRcdFx0XHRcdHN0YXR1c1RleHQgPSBcImVycm9yXCI7XG5cdFx0XHRcdFx0aWYgKCBzdGF0dXMgPCAwICkge1xuXHRcdFx0XHRcdFx0c3RhdHVzID0gMDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblxuXHRcdFx0Ly8gU2V0IGRhdGEgZm9yIHRoZSBmYWtlIHhociBvYmplY3Rcblx0XHRcdGpxWEhSLnN0YXR1cyA9IHN0YXR1cztcblx0XHRcdGpxWEhSLnN0YXR1c1RleHQgPSAoIG5hdGl2ZVN0YXR1c1RleHQgfHwgc3RhdHVzVGV4dCApICsgXCJcIjtcblxuXHRcdFx0Ly8gU3VjY2Vzcy9FcnJvclxuXHRcdFx0aWYgKCBpc1N1Y2Nlc3MgKSB7XG5cdFx0XHRcdGRlZmVycmVkLnJlc29sdmVXaXRoKCBjYWxsYmFja0NvbnRleHQsIFsgc3VjY2Vzcywgc3RhdHVzVGV4dCwganFYSFIgXSApO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZGVmZXJyZWQucmVqZWN0V2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0LCBlcnJvciBdICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIFN0YXR1cy1kZXBlbmRlbnQgY2FsbGJhY2tzXG5cdFx0XHRqcVhIUi5zdGF0dXNDb2RlKCBzdGF0dXNDb2RlICk7XG5cdFx0XHRzdGF0dXNDb2RlID0gdW5kZWZpbmVkO1xuXG5cdFx0XHRpZiAoIGZpcmVHbG9iYWxzICkge1xuXHRcdFx0XHRnbG9iYWxFdmVudENvbnRleHQudHJpZ2dlciggaXNTdWNjZXNzID8gXCJhamF4U3VjY2Vzc1wiIDogXCJhamF4RXJyb3JcIixcblx0XHRcdFx0XHRbIGpxWEhSLCBzLCBpc1N1Y2Nlc3MgPyBzdWNjZXNzIDogZXJyb3IgXSApO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBDb21wbGV0ZVxuXHRcdFx0Y29tcGxldGVEZWZlcnJlZC5maXJlV2l0aCggY2FsbGJhY2tDb250ZXh0LCBbIGpxWEhSLCBzdGF0dXNUZXh0IF0gKTtcblxuXHRcdFx0aWYgKCBmaXJlR2xvYmFscyApIHtcblx0XHRcdFx0Z2xvYmFsRXZlbnRDb250ZXh0LnRyaWdnZXIoIFwiYWpheENvbXBsZXRlXCIsIFsganFYSFIsIHMgXSApO1xuXG5cdFx0XHRcdC8vIEhhbmRsZSB0aGUgZ2xvYmFsIEFKQVggY291bnRlclxuXHRcdFx0XHRpZiAoICEoIC0talF1ZXJ5LmFjdGl2ZSApICkge1xuXHRcdFx0XHRcdGpRdWVyeS5ldmVudC50cmlnZ2VyKCBcImFqYXhTdG9wXCIgKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHJldHVybiBqcVhIUjtcblx0fSxcblxuXHRnZXRKU09OOiBmdW5jdGlvbiggdXJsLCBkYXRhLCBjYWxsYmFjayApIHtcblx0XHRyZXR1cm4galF1ZXJ5LmdldCggdXJsLCBkYXRhLCBjYWxsYmFjaywgXCJqc29uXCIgKTtcblx0fSxcblxuXHRnZXRTY3JpcHQ6IGZ1bmN0aW9uKCB1cmwsIGNhbGxiYWNrICkge1xuXHRcdHJldHVybiBqUXVlcnkuZ2V0KCB1cmwsIHVuZGVmaW5lZCwgY2FsbGJhY2ssIFwic2NyaXB0XCIgKTtcblx0fVxufSApO1xuXG5qUXVlcnkuZWFjaCggWyBcImdldFwiLCBcInBvc3RcIiBdLCBmdW5jdGlvbiggaSwgbWV0aG9kICkge1xuXHRqUXVlcnlbIG1ldGhvZCBdID0gZnVuY3Rpb24oIHVybCwgZGF0YSwgY2FsbGJhY2ssIHR5cGUgKSB7XG5cblx0XHQvLyBTaGlmdCBhcmd1bWVudHMgaWYgZGF0YSBhcmd1bWVudCB3YXMgb21pdHRlZFxuXHRcdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIGRhdGEgKSApIHtcblx0XHRcdHR5cGUgPSB0eXBlIHx8IGNhbGxiYWNrO1xuXHRcdFx0Y2FsbGJhY2sgPSBkYXRhO1xuXHRcdFx0ZGF0YSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cblx0XHQvLyBUaGUgdXJsIGNhbiBiZSBhbiBvcHRpb25zIG9iamVjdCAod2hpY2ggdGhlbiBtdXN0IGhhdmUgLnVybClcblx0XHRyZXR1cm4galF1ZXJ5LmFqYXgoIGpRdWVyeS5leHRlbmQoIHtcblx0XHRcdHVybDogdXJsLFxuXHRcdFx0dHlwZTogbWV0aG9kLFxuXHRcdFx0ZGF0YVR5cGU6IHR5cGUsXG5cdFx0XHRkYXRhOiBkYXRhLFxuXHRcdFx0c3VjY2VzczogY2FsbGJhY2tcblx0XHR9LCBqUXVlcnkuaXNQbGFpbk9iamVjdCggdXJsICkgJiYgdXJsICkgKTtcblx0fTtcbn0gKTtcblxuXG5qUXVlcnkuX2V2YWxVcmwgPSBmdW5jdGlvbiggdXJsICkge1xuXHRyZXR1cm4galF1ZXJ5LmFqYXgoIHtcblx0XHR1cmw6IHVybCxcblxuXHRcdC8vIE1ha2UgdGhpcyBleHBsaWNpdCwgc2luY2UgdXNlciBjYW4gb3ZlcnJpZGUgdGhpcyB0aHJvdWdoIGFqYXhTZXR1cCAoIzExMjY0KVxuXHRcdHR5cGU6IFwiR0VUXCIsXG5cdFx0ZGF0YVR5cGU6IFwic2NyaXB0XCIsXG5cdFx0YXN5bmM6IGZhbHNlLFxuXHRcdGdsb2JhbDogZmFsc2UsXG5cdFx0XCJ0aHJvd3NcIjogdHJ1ZVxuXHR9ICk7XG59O1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblx0d3JhcEFsbDogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0dmFyIHdyYXA7XG5cblx0XHRpZiAoIGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICkgKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkud3JhcEFsbCggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRpZiAoIHRoaXNbIDAgXSApIHtcblxuXHRcdFx0Ly8gVGhlIGVsZW1lbnRzIHRvIHdyYXAgdGhlIHRhcmdldCBhcm91bmRcblx0XHRcdHdyYXAgPSBqUXVlcnkoIGh0bWwsIHRoaXNbIDAgXS5vd25lckRvY3VtZW50ICkuZXEoIDAgKS5jbG9uZSggdHJ1ZSApO1xuXG5cdFx0XHRpZiAoIHRoaXNbIDAgXS5wYXJlbnROb2RlICkge1xuXHRcdFx0XHR3cmFwLmluc2VydEJlZm9yZSggdGhpc1sgMCBdICk7XG5cdFx0XHR9XG5cblx0XHRcdHdyYXAubWFwKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0dmFyIGVsZW0gPSB0aGlzO1xuXG5cdFx0XHRcdHdoaWxlICggZWxlbS5maXJzdEVsZW1lbnRDaGlsZCApIHtcblx0XHRcdFx0XHRlbGVtID0gZWxlbS5maXJzdEVsZW1lbnRDaGlsZDtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBlbGVtO1xuXHRcdFx0fSApLmFwcGVuZCggdGhpcyApO1xuXHRcdH1cblxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHdyYXBJbm5lcjogZnVuY3Rpb24oIGh0bWwgKSB7XG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggaHRtbCApICkge1xuXHRcdFx0cmV0dXJuIHRoaXMuZWFjaCggZnVuY3Rpb24oIGkgKSB7XG5cdFx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBJbm5lciggaHRtbC5jYWxsKCB0aGlzLCBpICkgKTtcblx0XHRcdH0gKTtcblx0XHR9XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWxmID0galF1ZXJ5KCB0aGlzICksXG5cdFx0XHRcdGNvbnRlbnRzID0gc2VsZi5jb250ZW50cygpO1xuXG5cdFx0XHRpZiAoIGNvbnRlbnRzLmxlbmd0aCApIHtcblx0XHRcdFx0Y29udGVudHMud3JhcEFsbCggaHRtbCApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWxmLmFwcGVuZCggaHRtbCApO1xuXHRcdFx0fVxuXHRcdH0gKTtcblx0fSxcblxuXHR3cmFwOiBmdW5jdGlvbiggaHRtbCApIHtcblx0XHR2YXIgaXNGdW5jdGlvbiA9IGpRdWVyeS5pc0Z1bmN0aW9uKCBodG1sICk7XG5cblx0XHRyZXR1cm4gdGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdGpRdWVyeSggdGhpcyApLndyYXBBbGwoIGlzRnVuY3Rpb24gPyBodG1sLmNhbGwoIHRoaXMsIGkgKSA6IGh0bWwgKTtcblx0XHR9ICk7XG5cdH0sXG5cblx0dW53cmFwOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5wYXJlbnQoKS5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIWpRdWVyeS5ub2RlTmFtZSggdGhpcywgXCJib2R5XCIgKSApIHtcblx0XHRcdFx0alF1ZXJ5KCB0aGlzICkucmVwbGFjZVdpdGgoIHRoaXMuY2hpbGROb2RlcyApO1xuXHRcdFx0fVxuXHRcdH0gKS5lbmQoKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuaGlkZGVuID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cdHJldHVybiAhalF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlKCBlbGVtICk7XG59O1xualF1ZXJ5LmV4cHIuZmlsdGVycy52aXNpYmxlID0gZnVuY3Rpb24oIGVsZW0gKSB7XG5cblx0Ly8gU3VwcG9ydDogT3BlcmEgPD0gMTIuMTJcblx0Ly8gT3BlcmEgcmVwb3J0cyBvZmZzZXRXaWR0aHMgYW5kIG9mZnNldEhlaWdodHMgbGVzcyB0aGFuIHplcm8gb24gc29tZSBlbGVtZW50c1xuXHQvLyBVc2UgT1IgaW5zdGVhZCBvZiBBTkQgYXMgdGhlIGVsZW1lbnQgaXMgbm90IHZpc2libGUgaWYgZWl0aGVyIGlzIHRydWVcblx0Ly8gU2VlIHRpY2tldHMgIzEwNDA2IGFuZCAjMTMxMzJcblx0cmV0dXJuIGVsZW0ub2Zmc2V0V2lkdGggPiAwIHx8IGVsZW0ub2Zmc2V0SGVpZ2h0ID4gMCB8fCBlbGVtLmdldENsaWVudFJlY3RzKCkubGVuZ3RoID4gMDtcbn07XG5cblxuXG5cbnZhciByMjAgPSAvJTIwL2csXG5cdHJicmFja2V0ID0gL1xcW1xcXSQvLFxuXHRyQ1JMRiA9IC9cXHI/XFxuL2csXG5cdHJzdWJtaXR0ZXJUeXBlcyA9IC9eKD86c3VibWl0fGJ1dHRvbnxpbWFnZXxyZXNldHxmaWxlKSQvaSxcblx0cnN1Ym1pdHRhYmxlID0gL14oPzppbnB1dHxzZWxlY3R8dGV4dGFyZWF8a2V5Z2VuKS9pO1xuXG5mdW5jdGlvbiBidWlsZFBhcmFtcyggcHJlZml4LCBvYmosIHRyYWRpdGlvbmFsLCBhZGQgKSB7XG5cdHZhciBuYW1lO1xuXG5cdGlmICggalF1ZXJ5LmlzQXJyYXkoIG9iaiApICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIGFycmF5IGl0ZW0uXG5cdFx0alF1ZXJ5LmVhY2goIG9iaiwgZnVuY3Rpb24oIGksIHYgKSB7XG5cdFx0XHRpZiAoIHRyYWRpdGlvbmFsIHx8IHJicmFja2V0LnRlc3QoIHByZWZpeCApICkge1xuXG5cdFx0XHRcdC8vIFRyZWF0IGVhY2ggYXJyYXkgaXRlbSBhcyBhIHNjYWxhci5cblx0XHRcdFx0YWRkKCBwcmVmaXgsIHYgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBJdGVtIGlzIG5vbi1zY2FsYXIgKGFycmF5IG9yIG9iamVjdCksIGVuY29kZSBpdHMgbnVtZXJpYyBpbmRleC5cblx0XHRcdFx0YnVpbGRQYXJhbXMoXG5cdFx0XHRcdFx0cHJlZml4ICsgXCJbXCIgKyAoIHR5cGVvZiB2ID09PSBcIm9iamVjdFwiICYmIHYgIT0gbnVsbCA/IGkgOiBcIlwiICkgKyBcIl1cIixcblx0XHRcdFx0XHR2LFxuXHRcdFx0XHRcdHRyYWRpdGlvbmFsLFxuXHRcdFx0XHRcdGFkZFxuXHRcdFx0XHQpO1xuXHRcdFx0fVxuXHRcdH0gKTtcblxuXHR9IGVsc2UgaWYgKCAhdHJhZGl0aW9uYWwgJiYgalF1ZXJ5LnR5cGUoIG9iaiApID09PSBcIm9iamVjdFwiICkge1xuXG5cdFx0Ly8gU2VyaWFsaXplIG9iamVjdCBpdGVtLlxuXHRcdGZvciAoIG5hbWUgaW4gb2JqICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCArIFwiW1wiICsgbmFtZSArIFwiXVwiLCBvYmpbIG5hbWUgXSwgdHJhZGl0aW9uYWwsIGFkZCApO1xuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gU2VyaWFsaXplIHNjYWxhciBpdGVtLlxuXHRcdGFkZCggcHJlZml4LCBvYmogKTtcblx0fVxufVxuXG4vLyBTZXJpYWxpemUgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cyBvciBhIHNldCBvZlxuLy8ga2V5L3ZhbHVlcyBpbnRvIGEgcXVlcnkgc3RyaW5nXG5qUXVlcnkucGFyYW0gPSBmdW5jdGlvbiggYSwgdHJhZGl0aW9uYWwgKSB7XG5cdHZhciBwcmVmaXgsXG5cdFx0cyA9IFtdLFxuXHRcdGFkZCA9IGZ1bmN0aW9uKCBrZXksIHZhbHVlICkge1xuXG5cdFx0XHQvLyBJZiB2YWx1ZSBpcyBhIGZ1bmN0aW9uLCBpbnZva2UgaXQgYW5kIHJldHVybiBpdHMgdmFsdWVcblx0XHRcdHZhbHVlID0galF1ZXJ5LmlzRnVuY3Rpb24oIHZhbHVlICkgPyB2YWx1ZSgpIDogKCB2YWx1ZSA9PSBudWxsID8gXCJcIiA6IHZhbHVlICk7XG5cdFx0XHRzWyBzLmxlbmd0aCBdID0gZW5jb2RlVVJJQ29tcG9uZW50KCBrZXkgKSArIFwiPVwiICsgZW5jb2RlVVJJQ29tcG9uZW50KCB2YWx1ZSApO1xuXHRcdH07XG5cblx0Ly8gU2V0IHRyYWRpdGlvbmFsIHRvIHRydWUgZm9yIGpRdWVyeSA8PSAxLjMuMiBiZWhhdmlvci5cblx0aWYgKCB0cmFkaXRpb25hbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdHRyYWRpdGlvbmFsID0galF1ZXJ5LmFqYXhTZXR0aW5ncyAmJiBqUXVlcnkuYWpheFNldHRpbmdzLnRyYWRpdGlvbmFsO1xuXHR9XG5cblx0Ly8gSWYgYW4gYXJyYXkgd2FzIHBhc3NlZCBpbiwgYXNzdW1lIHRoYXQgaXQgaXMgYW4gYXJyYXkgb2YgZm9ybSBlbGVtZW50cy5cblx0aWYgKCBqUXVlcnkuaXNBcnJheSggYSApIHx8ICggYS5qcXVlcnkgJiYgIWpRdWVyeS5pc1BsYWluT2JqZWN0KCBhICkgKSApIHtcblxuXHRcdC8vIFNlcmlhbGl6ZSB0aGUgZm9ybSBlbGVtZW50c1xuXHRcdGpRdWVyeS5lYWNoKCBhLCBmdW5jdGlvbigpIHtcblx0XHRcdGFkZCggdGhpcy5uYW1lLCB0aGlzLnZhbHVlICk7XG5cdFx0fSApO1xuXG5cdH0gZWxzZSB7XG5cblx0XHQvLyBJZiB0cmFkaXRpb25hbCwgZW5jb2RlIHRoZSBcIm9sZFwiIHdheSAodGhlIHdheSAxLjMuMiBvciBvbGRlclxuXHRcdC8vIGRpZCBpdCksIG90aGVyd2lzZSBlbmNvZGUgcGFyYW1zIHJlY3Vyc2l2ZWx5LlxuXHRcdGZvciAoIHByZWZpeCBpbiBhICkge1xuXHRcdFx0YnVpbGRQYXJhbXMoIHByZWZpeCwgYVsgcHJlZml4IF0sIHRyYWRpdGlvbmFsLCBhZGQgKTtcblx0XHR9XG5cdH1cblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBzZXJpYWxpemF0aW9uXG5cdHJldHVybiBzLmpvaW4oIFwiJlwiICkucmVwbGFjZSggcjIwLCBcIitcIiApO1xufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRzZXJpYWxpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnkucGFyYW0oIHRoaXMuc2VyaWFsaXplQXJyYXkoKSApO1xuXHR9LFxuXHRzZXJpYWxpemVBcnJheTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gQ2FuIGFkZCBwcm9wSG9vayBmb3IgXCJlbGVtZW50c1wiIHRvIGZpbHRlciBvciBhZGQgZm9ybSBlbGVtZW50c1xuXHRcdFx0dmFyIGVsZW1lbnRzID0galF1ZXJ5LnByb3AoIHRoaXMsIFwiZWxlbWVudHNcIiApO1xuXHRcdFx0cmV0dXJuIGVsZW1lbnRzID8galF1ZXJ5Lm1ha2VBcnJheSggZWxlbWVudHMgKSA6IHRoaXM7XG5cdFx0fSApXG5cdFx0LmZpbHRlciggZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdHlwZSA9IHRoaXMudHlwZTtcblxuXHRcdFx0Ly8gVXNlIC5pcyggXCI6ZGlzYWJsZWRcIiApIHNvIHRoYXQgZmllbGRzZXRbZGlzYWJsZWRdIHdvcmtzXG5cdFx0XHRyZXR1cm4gdGhpcy5uYW1lICYmICFqUXVlcnkoIHRoaXMgKS5pcyggXCI6ZGlzYWJsZWRcIiApICYmXG5cdFx0XHRcdHJzdWJtaXR0YWJsZS50ZXN0KCB0aGlzLm5vZGVOYW1lICkgJiYgIXJzdWJtaXR0ZXJUeXBlcy50ZXN0KCB0eXBlICkgJiZcblx0XHRcdFx0KCB0aGlzLmNoZWNrZWQgfHwgIXJjaGVja2FibGVUeXBlLnRlc3QoIHR5cGUgKSApO1xuXHRcdH0gKVxuXHRcdC5tYXAoIGZ1bmN0aW9uKCBpLCBlbGVtICkge1xuXHRcdFx0dmFyIHZhbCA9IGpRdWVyeSggdGhpcyApLnZhbCgpO1xuXG5cdFx0XHRyZXR1cm4gdmFsID09IG51bGwgP1xuXHRcdFx0XHRudWxsIDpcblx0XHRcdFx0alF1ZXJ5LmlzQXJyYXkoIHZhbCApID9cblx0XHRcdFx0XHRqUXVlcnkubWFwKCB2YWwsIGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0XHRcdFx0XHRyZXR1cm4geyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdFx0XHRcdH0gKSA6XG5cdFx0XHRcdFx0eyBuYW1lOiBlbGVtLm5hbWUsIHZhbHVlOiB2YWwucmVwbGFjZSggckNSTEYsIFwiXFxyXFxuXCIgKSB9O1xuXHRcdH0gKS5nZXQoKTtcblx0fVxufSApO1xuXG5cbmpRdWVyeS5hamF4U2V0dGluZ3MueGhyID0gZnVuY3Rpb24oKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIG5ldyB3aW5kb3cuWE1MSHR0cFJlcXVlc3QoKTtcblx0fSBjYXRjaCAoIGUgKSB7fVxufTtcblxudmFyIHhoclN1Y2Nlc3NTdGF0dXMgPSB7XG5cblx0XHQvLyBGaWxlIHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIGNvZGUgMCwgYXNzdW1lIDIwMFxuXHRcdDA6IDIwMCxcblxuXHRcdC8vIFN1cHBvcnQ6IElFOVxuXHRcdC8vICMxNDUwOiBzb21ldGltZXMgSUUgcmV0dXJucyAxMjIzIHdoZW4gaXQgc2hvdWxkIGJlIDIwNFxuXHRcdDEyMjM6IDIwNFxuXHR9LFxuXHR4aHJTdXBwb3J0ZWQgPSBqUXVlcnkuYWpheFNldHRpbmdzLnhocigpO1xuXG5zdXBwb3J0LmNvcnMgPSAhIXhoclN1cHBvcnRlZCAmJiAoIFwid2l0aENyZWRlbnRpYWxzXCIgaW4geGhyU3VwcG9ydGVkICk7XG5zdXBwb3J0LmFqYXggPSB4aHJTdXBwb3J0ZWQgPSAhIXhoclN1cHBvcnRlZDtcblxualF1ZXJ5LmFqYXhUcmFuc3BvcnQoIGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHR2YXIgY2FsbGJhY2ssIGVycm9yQ2FsbGJhY2s7XG5cblx0Ly8gQ3Jvc3MgZG9tYWluIG9ubHkgYWxsb3dlZCBpZiBzdXBwb3J0ZWQgdGhyb3VnaCBYTUxIdHRwUmVxdWVzdFxuXHRpZiAoIHN1cHBvcnQuY29ycyB8fCB4aHJTdXBwb3J0ZWQgJiYgIW9wdGlvbnMuY3Jvc3NEb21haW4gKSB7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBoZWFkZXJzLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0dmFyIGksXG5cdFx0XHRcdFx0eGhyID0gb3B0aW9ucy54aHIoKTtcblxuXHRcdFx0XHR4aHIub3Blbihcblx0XHRcdFx0XHRvcHRpb25zLnR5cGUsXG5cdFx0XHRcdFx0b3B0aW9ucy51cmwsXG5cdFx0XHRcdFx0b3B0aW9ucy5hc3luYyxcblx0XHRcdFx0XHRvcHRpb25zLnVzZXJuYW1lLFxuXHRcdFx0XHRcdG9wdGlvbnMucGFzc3dvcmRcblx0XHRcdFx0KTtcblxuXHRcdFx0XHQvLyBBcHBseSBjdXN0b20gZmllbGRzIGlmIHByb3ZpZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy54aHJGaWVsZHMgKSB7XG5cdFx0XHRcdFx0Zm9yICggaSBpbiBvcHRpb25zLnhockZpZWxkcyApIHtcblx0XHRcdFx0XHRcdHhoclsgaSBdID0gb3B0aW9ucy54aHJGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBPdmVycmlkZSBtaW1lIHR5cGUgaWYgbmVlZGVkXG5cdFx0XHRcdGlmICggb3B0aW9ucy5taW1lVHlwZSAmJiB4aHIub3ZlcnJpZGVNaW1lVHlwZSApIHtcblx0XHRcdFx0XHR4aHIub3ZlcnJpZGVNaW1lVHlwZSggb3B0aW9ucy5taW1lVHlwZSApO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gWC1SZXF1ZXN0ZWQtV2l0aCBoZWFkZXJcblx0XHRcdFx0Ly8gRm9yIGNyb3NzLWRvbWFpbiByZXF1ZXN0cywgc2VlaW5nIGFzIGNvbmRpdGlvbnMgZm9yIGEgcHJlZmxpZ2h0IGFyZVxuXHRcdFx0XHQvLyBha2luIHRvIGEgamlnc2F3IHB1enpsZSwgd2Ugc2ltcGx5IG5ldmVyIHNldCBpdCB0byBiZSBzdXJlLlxuXHRcdFx0XHQvLyAoaXQgY2FuIGFsd2F5cyBiZSBzZXQgb24gYSBwZXItcmVxdWVzdCBiYXNpcyBvciBldmVuIHVzaW5nIGFqYXhTZXR1cClcblx0XHRcdFx0Ly8gRm9yIHNhbWUtZG9tYWluIHJlcXVlc3RzLCB3b24ndCBjaGFuZ2UgaGVhZGVyIGlmIGFscmVhZHkgcHJvdmlkZWQuXG5cdFx0XHRcdGlmICggIW9wdGlvbnMuY3Jvc3NEb21haW4gJiYgIWhlYWRlcnNbIFwiWC1SZXF1ZXN0ZWQtV2l0aFwiIF0gKSB7XG5cdFx0XHRcdFx0aGVhZGVyc1sgXCJYLVJlcXVlc3RlZC1XaXRoXCIgXSA9IFwiWE1MSHR0cFJlcXVlc3RcIjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIFNldCBoZWFkZXJzXG5cdFx0XHRcdGZvciAoIGkgaW4gaGVhZGVycyApIHtcblx0XHRcdFx0XHR4aHIuc2V0UmVxdWVzdEhlYWRlciggaSwgaGVhZGVyc1sgaSBdICk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDYWxsYmFja1xuXHRcdFx0XHRjYWxsYmFjayA9IGZ1bmN0aW9uKCB0eXBlICkge1xuXHRcdFx0XHRcdHJldHVybiBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0XHRcdGNhbGxiYWNrID0gZXJyb3JDYWxsYmFjayA9IHhoci5vbmxvYWQgPVxuXHRcdFx0XHRcdFx0XHRcdHhoci5vbmVycm9yID0geGhyLm9uYWJvcnQgPSB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gbnVsbDtcblxuXHRcdFx0XHRcdFx0XHRpZiAoIHR5cGUgPT09IFwiYWJvcnRcIiApIHtcblx0XHRcdFx0XHRcdFx0XHR4aHIuYWJvcnQoKTtcblx0XHRcdFx0XHRcdFx0fSBlbHNlIGlmICggdHlwZSA9PT0gXCJlcnJvclwiICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0Ly8gU3VwcG9ydDogSUU5XG5cdFx0XHRcdFx0XHRcdFx0Ly8gT24gYSBtYW51YWwgbmF0aXZlIGFib3J0LCBJRTkgdGhyb3dzXG5cdFx0XHRcdFx0XHRcdFx0Ly8gZXJyb3JzIG9uIGFueSBwcm9wZXJ0eSBhY2Nlc3MgdGhhdCBpcyBub3QgcmVhZHlTdGF0ZVxuXHRcdFx0XHRcdFx0XHRcdGlmICggdHlwZW9mIHhoci5zdGF0dXMgIT09IFwibnVtYmVyXCIgKSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggMCwgXCJlcnJvclwiICk7XG5cdFx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRcdGNvbXBsZXRlKFxuXG5cdFx0XHRcdFx0XHRcdFx0XHRcdC8vIEZpbGU6IHByb3RvY29sIGFsd2F5cyB5aWVsZHMgc3RhdHVzIDA7IHNlZSAjODYwNSwgIzE0MjA3XG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXMsXG5cdFx0XHRcdFx0XHRcdFx0XHRcdHhoci5zdGF0dXNUZXh0XG5cdFx0XHRcdFx0XHRcdFx0XHQpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdFx0XHRjb21wbGV0ZShcblx0XHRcdFx0XHRcdFx0XHRcdHhoclN1Y2Nlc3NTdGF0dXNbIHhoci5zdGF0dXMgXSB8fCB4aHIuc3RhdHVzLFxuXHRcdFx0XHRcdFx0XHRcdFx0eGhyLnN0YXR1c1RleHQsXG5cblx0XHRcdFx0XHRcdFx0XHRcdC8vIFN1cHBvcnQ6IElFOSBvbmx5XG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBJRTkgaGFzIG5vIFhIUjIgYnV0IHRocm93cyBvbiBiaW5hcnkgKHRyYWMtMTE0MjYpXG5cdFx0XHRcdFx0XHRcdFx0XHQvLyBGb3IgWEhSMiBub24tdGV4dCwgbGV0IHRoZSBjYWxsZXIgaGFuZGxlIGl0IChnaC0yNDk4KVxuXHRcdFx0XHRcdFx0XHRcdFx0KCB4aHIucmVzcG9uc2VUeXBlIHx8IFwidGV4dFwiICkgIT09IFwidGV4dFwiICB8fFxuXHRcdFx0XHRcdFx0XHRcdFx0dHlwZW9mIHhoci5yZXNwb25zZVRleHQgIT09IFwic3RyaW5nXCIgP1xuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IGJpbmFyeTogeGhyLnJlc3BvbnNlIH0gOlxuXHRcdFx0XHRcdFx0XHRcdFx0XHR7IHRleHQ6IHhoci5yZXNwb25zZVRleHQgfSxcblx0XHRcdFx0XHRcdFx0XHRcdHhoci5nZXRBbGxSZXNwb25zZUhlYWRlcnMoKVxuXHRcdFx0XHRcdFx0XHRcdCk7XG5cdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9O1xuXHRcdFx0XHR9O1xuXG5cdFx0XHRcdC8vIExpc3RlbiB0byBldmVudHNcblx0XHRcdFx0eGhyLm9ubG9hZCA9IGNhbGxiYWNrKCk7XG5cdFx0XHRcdGVycm9yQ2FsbGJhY2sgPSB4aHIub25lcnJvciA9IGNhbGxiYWNrKCBcImVycm9yXCIgKTtcblxuXHRcdFx0XHQvLyBTdXBwb3J0OiBJRTlcblx0XHRcdFx0Ly8gVXNlIG9ucmVhZHlzdGF0ZWNoYW5nZSB0byByZXBsYWNlIG9uYWJvcnRcblx0XHRcdFx0Ly8gdG8gaGFuZGxlIHVuY2F1Z2h0IGFib3J0c1xuXHRcdFx0XHRpZiAoIHhoci5vbmFib3J0ICE9PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdFx0eGhyLm9uYWJvcnQgPSBlcnJvckNhbGxiYWNrO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHhoci5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbigpIHtcblxuXHRcdFx0XHRcdFx0Ly8gQ2hlY2sgcmVhZHlTdGF0ZSBiZWZvcmUgdGltZW91dCBhcyBpdCBjaGFuZ2VzXG5cdFx0XHRcdFx0XHRpZiAoIHhoci5yZWFkeVN0YXRlID09PSA0ICkge1xuXG5cdFx0XHRcdFx0XHRcdC8vIEFsbG93IG9uZXJyb3IgdG8gYmUgY2FsbGVkIGZpcnN0LFxuXHRcdFx0XHRcdFx0XHQvLyBidXQgdGhhdCB3aWxsIG5vdCBoYW5kbGUgYSBuYXRpdmUgYWJvcnRcblx0XHRcdFx0XHRcdFx0Ly8gQWxzbywgc2F2ZSBlcnJvckNhbGxiYWNrIHRvIGEgdmFyaWFibGVcblx0XHRcdFx0XHRcdFx0Ly8gYXMgeGhyLm9uZXJyb3IgY2Fubm90IGJlIGFjY2Vzc2VkXG5cdFx0XHRcdFx0XHRcdHdpbmRvdy5zZXRUaW1lb3V0KCBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdFx0XHRcdFx0ZXJyb3JDYWxsYmFjaygpO1xuXHRcdFx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdFx0fSApO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBDcmVhdGUgdGhlIGFib3J0IGNhbGxiYWNrXG5cdFx0XHRcdGNhbGxiYWNrID0gY2FsbGJhY2soIFwiYWJvcnRcIiApO1xuXG5cdFx0XHRcdHRyeSB7XG5cblx0XHRcdFx0XHQvLyBEbyBzZW5kIHRoZSByZXF1ZXN0ICh0aGlzIG1heSByYWlzZSBhbiBleGNlcHRpb24pXG5cdFx0XHRcdFx0eGhyLnNlbmQoIG9wdGlvbnMuaGFzQ29udGVudCAmJiBvcHRpb25zLmRhdGEgfHwgbnVsbCApO1xuXHRcdFx0XHR9IGNhdGNoICggZSApIHtcblxuXHRcdFx0XHRcdC8vICMxNDY4MzogT25seSByZXRocm93IGlmIHRoaXMgaGFzbid0IGJlZW4gbm90aWZpZWQgYXMgYW4gZXJyb3IgeWV0XG5cdFx0XHRcdFx0aWYgKCBjYWxsYmFjayApIHtcblx0XHRcdFx0XHRcdHRocm93IGU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9LFxuXG5cdFx0XHRhYm9ydDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdGlmICggY2FsbGJhY2sgKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2soKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cdH1cbn0gKTtcblxuXG5cblxuLy8gSW5zdGFsbCBzY3JpcHQgZGF0YVR5cGVcbmpRdWVyeS5hamF4U2V0dXAoIHtcblx0YWNjZXB0czoge1xuXHRcdHNjcmlwdDogXCJ0ZXh0L2phdmFzY3JpcHQsIGFwcGxpY2F0aW9uL2phdmFzY3JpcHQsIFwiICtcblx0XHRcdFwiYXBwbGljYXRpb24vZWNtYXNjcmlwdCwgYXBwbGljYXRpb24veC1lY21hc2NyaXB0XCJcblx0fSxcblx0Y29udGVudHM6IHtcblx0XHRzY3JpcHQ6IC9cXGIoPzpqYXZhfGVjbWEpc2NyaXB0XFxiL1xuXHR9LFxuXHRjb252ZXJ0ZXJzOiB7XG5cdFx0XCJ0ZXh0IHNjcmlwdFwiOiBmdW5jdGlvbiggdGV4dCApIHtcblx0XHRcdGpRdWVyeS5nbG9iYWxFdmFsKCB0ZXh0ICk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH1cbn0gKTtcblxuLy8gSGFuZGxlIGNhY2hlJ3Mgc3BlY2lhbCBjYXNlIGFuZCBjcm9zc0RvbWFpblxualF1ZXJ5LmFqYXhQcmVmaWx0ZXIoIFwic2NyaXB0XCIsIGZ1bmN0aW9uKCBzICkge1xuXHRpZiAoIHMuY2FjaGUgPT09IHVuZGVmaW5lZCApIHtcblx0XHRzLmNhY2hlID0gZmFsc2U7XG5cdH1cblx0aWYgKCBzLmNyb3NzRG9tYWluICkge1xuXHRcdHMudHlwZSA9IFwiR0VUXCI7XG5cdH1cbn0gKTtcblxuLy8gQmluZCBzY3JpcHQgdGFnIGhhY2sgdHJhbnNwb3J0XG5qUXVlcnkuYWpheFRyYW5zcG9ydCggXCJzY3JpcHRcIiwgZnVuY3Rpb24oIHMgKSB7XG5cblx0Ly8gVGhpcyB0cmFuc3BvcnQgb25seSBkZWFscyB3aXRoIGNyb3NzIGRvbWFpbiByZXF1ZXN0c1xuXHRpZiAoIHMuY3Jvc3NEb21haW4gKSB7XG5cdFx0dmFyIHNjcmlwdCwgY2FsbGJhY2s7XG5cdFx0cmV0dXJuIHtcblx0XHRcdHNlbmQ6IGZ1bmN0aW9uKCBfLCBjb21wbGV0ZSApIHtcblx0XHRcdFx0c2NyaXB0ID0galF1ZXJ5KCBcIjxzY3JpcHQ+XCIgKS5wcm9wKCB7XG5cdFx0XHRcdFx0Y2hhcnNldDogcy5zY3JpcHRDaGFyc2V0LFxuXHRcdFx0XHRcdHNyYzogcy51cmxcblx0XHRcdFx0fSApLm9uKFxuXHRcdFx0XHRcdFwibG9hZCBlcnJvclwiLFxuXHRcdFx0XHRcdGNhbGxiYWNrID0gZnVuY3Rpb24oIGV2dCApIHtcblx0XHRcdFx0XHRcdHNjcmlwdC5yZW1vdmUoKTtcblx0XHRcdFx0XHRcdGNhbGxiYWNrID0gbnVsbDtcblx0XHRcdFx0XHRcdGlmICggZXZ0ICkge1xuXHRcdFx0XHRcdFx0XHRjb21wbGV0ZSggZXZ0LnR5cGUgPT09IFwiZXJyb3JcIiA/IDQwNCA6IDIwMCwgZXZ0LnR5cGUgKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0Ly8gVXNlIG5hdGl2ZSBET00gbWFuaXB1bGF0aW9uIHRvIGF2b2lkIG91ciBkb21NYW5pcCBBSkFYIHRyaWNrZXJ5XG5cdFx0XHRcdGRvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQoIHNjcmlwdFsgMCBdICk7XG5cdFx0XHR9LFxuXHRcdFx0YWJvcnQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRpZiAoIGNhbGxiYWNrICkge1xuXHRcdFx0XHRcdGNhbGxiYWNrKCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9O1xuXHR9XG59ICk7XG5cblxuXG5cbnZhciBvbGRDYWxsYmFja3MgPSBbXSxcblx0cmpzb25wID0gLyg9KVxcPyg/PSZ8JCl8XFw/XFw/LztcblxuLy8gRGVmYXVsdCBqc29ucCBzZXR0aW5nc1xualF1ZXJ5LmFqYXhTZXR1cCgge1xuXHRqc29ucDogXCJjYWxsYmFja1wiLFxuXHRqc29ucENhbGxiYWNrOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2FsbGJhY2sgPSBvbGRDYWxsYmFja3MucG9wKCkgfHwgKCBqUXVlcnkuZXhwYW5kbyArIFwiX1wiICsgKCBub25jZSsrICkgKTtcblx0XHR0aGlzWyBjYWxsYmFjayBdID0gdHJ1ZTtcblx0XHRyZXR1cm4gY2FsbGJhY2s7XG5cdH1cbn0gKTtcblxuLy8gRGV0ZWN0LCBub3JtYWxpemUgb3B0aW9ucyBhbmQgaW5zdGFsbCBjYWxsYmFja3MgZm9yIGpzb25wIHJlcXVlc3RzXG5qUXVlcnkuYWpheFByZWZpbHRlciggXCJqc29uIGpzb25wXCIsIGZ1bmN0aW9uKCBzLCBvcmlnaW5hbFNldHRpbmdzLCBqcVhIUiApIHtcblxuXHR2YXIgY2FsbGJhY2tOYW1lLCBvdmVyd3JpdHRlbiwgcmVzcG9uc2VDb250YWluZXIsXG5cdFx0anNvblByb3AgPSBzLmpzb25wICE9PSBmYWxzZSAmJiAoIHJqc29ucC50ZXN0KCBzLnVybCApID9cblx0XHRcdFwidXJsXCIgOlxuXHRcdFx0dHlwZW9mIHMuZGF0YSA9PT0gXCJzdHJpbmdcIiAmJlxuXHRcdFx0XHQoIHMuY29udGVudFR5cGUgfHwgXCJcIiApXG5cdFx0XHRcdFx0LmluZGV4T2YoIFwiYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkXCIgKSA9PT0gMCAmJlxuXHRcdFx0XHRyanNvbnAudGVzdCggcy5kYXRhICkgJiYgXCJkYXRhXCJcblx0XHQpO1xuXG5cdC8vIEhhbmRsZSBpZmYgdGhlIGV4cGVjdGVkIGRhdGEgdHlwZSBpcyBcImpzb25wXCIgb3Igd2UgaGF2ZSBhIHBhcmFtZXRlciB0byBzZXRcblx0aWYgKCBqc29uUHJvcCB8fCBzLmRhdGFUeXBlc1sgMCBdID09PSBcImpzb25wXCIgKSB7XG5cblx0XHQvLyBHZXQgY2FsbGJhY2sgbmFtZSwgcmVtZW1iZXJpbmcgcHJlZXhpc3RpbmcgdmFsdWUgYXNzb2NpYXRlZCB3aXRoIGl0XG5cdFx0Y2FsbGJhY2tOYW1lID0gcy5qc29ucENhbGxiYWNrID0galF1ZXJ5LmlzRnVuY3Rpb24oIHMuanNvbnBDYWxsYmFjayApID9cblx0XHRcdHMuanNvbnBDYWxsYmFjaygpIDpcblx0XHRcdHMuanNvbnBDYWxsYmFjaztcblxuXHRcdC8vIEluc2VydCBjYWxsYmFjayBpbnRvIHVybCBvciBmb3JtIGRhdGFcblx0XHRpZiAoIGpzb25Qcm9wICkge1xuXHRcdFx0c1sganNvblByb3AgXSA9IHNbIGpzb25Qcm9wIF0ucmVwbGFjZSggcmpzb25wLCBcIiQxXCIgKyBjYWxsYmFja05hbWUgKTtcblx0XHR9IGVsc2UgaWYgKCBzLmpzb25wICE9PSBmYWxzZSApIHtcblx0XHRcdHMudXJsICs9ICggcnF1ZXJ5LnRlc3QoIHMudXJsICkgPyBcIiZcIiA6IFwiP1wiICkgKyBzLmpzb25wICsgXCI9XCIgKyBjYWxsYmFja05hbWU7XG5cdFx0fVxuXG5cdFx0Ly8gVXNlIGRhdGEgY29udmVydGVyIHRvIHJldHJpZXZlIGpzb24gYWZ0ZXIgc2NyaXB0IGV4ZWN1dGlvblxuXHRcdHMuY29udmVydGVyc1sgXCJzY3JpcHQganNvblwiIF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdGlmICggIXJlc3BvbnNlQ29udGFpbmVyICkge1xuXHRcdFx0XHRqUXVlcnkuZXJyb3IoIGNhbGxiYWNrTmFtZSArIFwiIHdhcyBub3QgY2FsbGVkXCIgKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiByZXNwb25zZUNvbnRhaW5lclsgMCBdO1xuXHRcdH07XG5cblx0XHQvLyBGb3JjZSBqc29uIGRhdGFUeXBlXG5cdFx0cy5kYXRhVHlwZXNbIDAgXSA9IFwianNvblwiO1xuXG5cdFx0Ly8gSW5zdGFsbCBjYWxsYmFja1xuXHRcdG92ZXJ3cml0dGVuID0gd2luZG93WyBjYWxsYmFja05hbWUgXTtcblx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXNwb25zZUNvbnRhaW5lciA9IGFyZ3VtZW50cztcblx0XHR9O1xuXG5cdFx0Ly8gQ2xlYW4tdXAgZnVuY3Rpb24gKGZpcmVzIGFmdGVyIGNvbnZlcnRlcnMpXG5cdFx0anFYSFIuYWx3YXlzKCBmdW5jdGlvbigpIHtcblxuXHRcdFx0Ly8gSWYgcHJldmlvdXMgdmFsdWUgZGlkbid0IGV4aXN0IC0gcmVtb3ZlIGl0XG5cdFx0XHRpZiAoIG92ZXJ3cml0dGVuID09PSB1bmRlZmluZWQgKSB7XG5cdFx0XHRcdGpRdWVyeSggd2luZG93ICkucmVtb3ZlUHJvcCggY2FsbGJhY2tOYW1lICk7XG5cblx0XHRcdC8vIE90aGVyd2lzZSByZXN0b3JlIHByZWV4aXN0aW5nIHZhbHVlXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR3aW5kb3dbIGNhbGxiYWNrTmFtZSBdID0gb3ZlcndyaXR0ZW47XG5cdFx0XHR9XG5cblx0XHRcdC8vIFNhdmUgYmFjayBhcyBmcmVlXG5cdFx0XHRpZiAoIHNbIGNhbGxiYWNrTmFtZSBdICkge1xuXG5cdFx0XHRcdC8vIE1ha2Ugc3VyZSB0aGF0IHJlLXVzaW5nIHRoZSBvcHRpb25zIGRvZXNuJ3Qgc2NyZXcgdGhpbmdzIGFyb3VuZFxuXHRcdFx0XHRzLmpzb25wQ2FsbGJhY2sgPSBvcmlnaW5hbFNldHRpbmdzLmpzb25wQ2FsbGJhY2s7XG5cblx0XHRcdFx0Ly8gU2F2ZSB0aGUgY2FsbGJhY2sgbmFtZSBmb3IgZnV0dXJlIHVzZVxuXHRcdFx0XHRvbGRDYWxsYmFja3MucHVzaCggY2FsbGJhY2tOYW1lICk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENhbGwgaWYgaXQgd2FzIGEgZnVuY3Rpb24gYW5kIHdlIGhhdmUgYSByZXNwb25zZVxuXHRcdFx0aWYgKCByZXNwb25zZUNvbnRhaW5lciAmJiBqUXVlcnkuaXNGdW5jdGlvbiggb3ZlcndyaXR0ZW4gKSApIHtcblx0XHRcdFx0b3ZlcndyaXR0ZW4oIHJlc3BvbnNlQ29udGFpbmVyWyAwIF0gKTtcblx0XHRcdH1cblxuXHRcdFx0cmVzcG9uc2VDb250YWluZXIgPSBvdmVyd3JpdHRlbiA9IHVuZGVmaW5lZDtcblx0XHR9ICk7XG5cblx0XHQvLyBEZWxlZ2F0ZSB0byBzY3JpcHRcblx0XHRyZXR1cm4gXCJzY3JpcHRcIjtcblx0fVxufSApO1xuXG5cblxuXG4vLyBTdXBwb3J0OiBTYWZhcmkgOCtcbi8vIEluIFNhZmFyaSA4IGRvY3VtZW50cyBjcmVhdGVkIHZpYSBkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnRcbi8vIGNvbGxhcHNlIHNpYmxpbmcgZm9ybXM6IHRoZSBzZWNvbmQgb25lIGJlY29tZXMgYSBjaGlsZCBvZiB0aGUgZmlyc3Qgb25lLlxuLy8gQmVjYXVzZSBvZiB0aGF0LCB0aGlzIHNlY3VyaXR5IG1lYXN1cmUgaGFzIHRvIGJlIGRpc2FibGVkIGluIFNhZmFyaSA4LlxuLy8gaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTEzNzMzN1xuc3VwcG9ydC5jcmVhdGVIVE1MRG9jdW1lbnQgPSAoIGZ1bmN0aW9uKCkge1xuXHR2YXIgYm9keSA9IGRvY3VtZW50LmltcGxlbWVudGF0aW9uLmNyZWF0ZUhUTUxEb2N1bWVudCggXCJcIiApLmJvZHk7XG5cdGJvZHkuaW5uZXJIVE1MID0gXCI8Zm9ybT48L2Zvcm0+PGZvcm0+PC9mb3JtPlwiO1xuXHRyZXR1cm4gYm9keS5jaGlsZE5vZGVzLmxlbmd0aCA9PT0gMjtcbn0gKSgpO1xuXG5cbi8vIEFyZ3VtZW50IFwiZGF0YVwiIHNob3VsZCBiZSBzdHJpbmcgb2YgaHRtbFxuLy8gY29udGV4dCAob3B0aW9uYWwpOiBJZiBzcGVjaWZpZWQsIHRoZSBmcmFnbWVudCB3aWxsIGJlIGNyZWF0ZWQgaW4gdGhpcyBjb250ZXh0LFxuLy8gZGVmYXVsdHMgdG8gZG9jdW1lbnRcbi8vIGtlZXBTY3JpcHRzIChvcHRpb25hbCk6IElmIHRydWUsIHdpbGwgaW5jbHVkZSBzY3JpcHRzIHBhc3NlZCBpbiB0aGUgaHRtbCBzdHJpbmdcbmpRdWVyeS5wYXJzZUhUTUwgPSBmdW5jdGlvbiggZGF0YSwgY29udGV4dCwga2VlcFNjcmlwdHMgKSB7XG5cdGlmICggIWRhdGEgfHwgdHlwZW9mIGRhdGEgIT09IFwic3RyaW5nXCIgKSB7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblx0aWYgKCB0eXBlb2YgY29udGV4dCA9PT0gXCJib29sZWFuXCIgKSB7XG5cdFx0a2VlcFNjcmlwdHMgPSBjb250ZXh0O1xuXHRcdGNvbnRleHQgPSBmYWxzZTtcblx0fVxuXG5cdC8vIFN0b3Agc2NyaXB0cyBvciBpbmxpbmUgZXZlbnQgaGFuZGxlcnMgZnJvbSBiZWluZyBleGVjdXRlZCBpbW1lZGlhdGVseVxuXHQvLyBieSB1c2luZyBkb2N1bWVudC5pbXBsZW1lbnRhdGlvblxuXHRjb250ZXh0ID0gY29udGV4dCB8fCAoIHN1cHBvcnQuY3JlYXRlSFRNTERvY3VtZW50ID9cblx0XHRkb2N1bWVudC5pbXBsZW1lbnRhdGlvbi5jcmVhdGVIVE1MRG9jdW1lbnQoIFwiXCIgKSA6XG5cdFx0ZG9jdW1lbnQgKTtcblxuXHR2YXIgcGFyc2VkID0gcnNpbmdsZVRhZy5leGVjKCBkYXRhICksXG5cdFx0c2NyaXB0cyA9ICFrZWVwU2NyaXB0cyAmJiBbXTtcblxuXHQvLyBTaW5nbGUgdGFnXG5cdGlmICggcGFyc2VkICkge1xuXHRcdHJldHVybiBbIGNvbnRleHQuY3JlYXRlRWxlbWVudCggcGFyc2VkWyAxIF0gKSBdO1xuXHR9XG5cblx0cGFyc2VkID0gYnVpbGRGcmFnbWVudCggWyBkYXRhIF0sIGNvbnRleHQsIHNjcmlwdHMgKTtcblxuXHRpZiAoIHNjcmlwdHMgJiYgc2NyaXB0cy5sZW5ndGggKSB7XG5cdFx0alF1ZXJ5KCBzY3JpcHRzICkucmVtb3ZlKCk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5Lm1lcmdlKCBbXSwgcGFyc2VkLmNoaWxkTm9kZXMgKTtcbn07XG5cblxuLy8gS2VlcCBhIGNvcHkgb2YgdGhlIG9sZCBsb2FkIG1ldGhvZFxudmFyIF9sb2FkID0galF1ZXJ5LmZuLmxvYWQ7XG5cbi8qKlxuICogTG9hZCBhIHVybCBpbnRvIGEgcGFnZVxuICovXG5qUXVlcnkuZm4ubG9hZCA9IGZ1bmN0aW9uKCB1cmwsIHBhcmFtcywgY2FsbGJhY2sgKSB7XG5cdGlmICggdHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIiAmJiBfbG9hZCApIHtcblx0XHRyZXR1cm4gX2xvYWQuYXBwbHkoIHRoaXMsIGFyZ3VtZW50cyApO1xuXHR9XG5cblx0dmFyIHNlbGVjdG9yLCB0eXBlLCByZXNwb25zZSxcblx0XHRzZWxmID0gdGhpcyxcblx0XHRvZmYgPSB1cmwuaW5kZXhPZiggXCIgXCIgKTtcblxuXHRpZiAoIG9mZiA+IC0xICkge1xuXHRcdHNlbGVjdG9yID0galF1ZXJ5LnRyaW0oIHVybC5zbGljZSggb2ZmICkgKTtcblx0XHR1cmwgPSB1cmwuc2xpY2UoIDAsIG9mZiApO1xuXHR9XG5cblx0Ly8gSWYgaXQncyBhIGZ1bmN0aW9uXG5cdGlmICggalF1ZXJ5LmlzRnVuY3Rpb24oIHBhcmFtcyApICkge1xuXG5cdFx0Ly8gV2UgYXNzdW1lIHRoYXQgaXQncyB0aGUgY2FsbGJhY2tcblx0XHRjYWxsYmFjayA9IHBhcmFtcztcblx0XHRwYXJhbXMgPSB1bmRlZmluZWQ7XG5cblx0Ly8gT3RoZXJ3aXNlLCBidWlsZCBhIHBhcmFtIHN0cmluZ1xuXHR9IGVsc2UgaWYgKCBwYXJhbXMgJiYgdHlwZW9mIHBhcmFtcyA9PT0gXCJvYmplY3RcIiApIHtcblx0XHR0eXBlID0gXCJQT1NUXCI7XG5cdH1cblxuXHQvLyBJZiB3ZSBoYXZlIGVsZW1lbnRzIHRvIG1vZGlmeSwgbWFrZSB0aGUgcmVxdWVzdFxuXHRpZiAoIHNlbGYubGVuZ3RoID4gMCApIHtcblx0XHRqUXVlcnkuYWpheCgge1xuXHRcdFx0dXJsOiB1cmwsXG5cblx0XHRcdC8vIElmIFwidHlwZVwiIHZhcmlhYmxlIGlzIHVuZGVmaW5lZCwgdGhlbiBcIkdFVFwiIG1ldGhvZCB3aWxsIGJlIHVzZWQuXG5cdFx0XHQvLyBNYWtlIHZhbHVlIG9mIHRoaXMgZmllbGQgZXhwbGljaXQgc2luY2Vcblx0XHRcdC8vIHVzZXIgY2FuIG92ZXJyaWRlIGl0IHRocm91Z2ggYWpheFNldHVwIG1ldGhvZFxuXHRcdFx0dHlwZTogdHlwZSB8fCBcIkdFVFwiLFxuXHRcdFx0ZGF0YVR5cGU6IFwiaHRtbFwiLFxuXHRcdFx0ZGF0YTogcGFyYW1zXG5cdFx0fSApLmRvbmUoIGZ1bmN0aW9uKCByZXNwb25zZVRleHQgKSB7XG5cblx0XHRcdC8vIFNhdmUgcmVzcG9uc2UgZm9yIHVzZSBpbiBjb21wbGV0ZSBjYWxsYmFja1xuXHRcdFx0cmVzcG9uc2UgPSBhcmd1bWVudHM7XG5cblx0XHRcdHNlbGYuaHRtbCggc2VsZWN0b3IgP1xuXG5cdFx0XHRcdC8vIElmIGEgc2VsZWN0b3Igd2FzIHNwZWNpZmllZCwgbG9jYXRlIHRoZSByaWdodCBlbGVtZW50cyBpbiBhIGR1bW15IGRpdlxuXHRcdFx0XHQvLyBFeGNsdWRlIHNjcmlwdHMgdG8gYXZvaWQgSUUgJ1Blcm1pc3Npb24gRGVuaWVkJyBlcnJvcnNcblx0XHRcdFx0alF1ZXJ5KCBcIjxkaXY+XCIgKS5hcHBlbmQoIGpRdWVyeS5wYXJzZUhUTUwoIHJlc3BvbnNlVGV4dCApICkuZmluZCggc2VsZWN0b3IgKSA6XG5cblx0XHRcdFx0Ly8gT3RoZXJ3aXNlIHVzZSB0aGUgZnVsbCByZXN1bHRcblx0XHRcdFx0cmVzcG9uc2VUZXh0ICk7XG5cblx0XHQvLyBJZiB0aGUgcmVxdWVzdCBzdWNjZWVkcywgdGhpcyBmdW5jdGlvbiBnZXRzIFwiZGF0YVwiLCBcInN0YXR1c1wiLCBcImpxWEhSXCJcblx0XHQvLyBidXQgdGhleSBhcmUgaWdub3JlZCBiZWNhdXNlIHJlc3BvbnNlIHdhcyBzZXQgYWJvdmUuXG5cdFx0Ly8gSWYgaXQgZmFpbHMsIHRoaXMgZnVuY3Rpb24gZ2V0cyBcImpxWEhSXCIsIFwic3RhdHVzXCIsIFwiZXJyb3JcIlxuXHRcdH0gKS5hbHdheXMoIGNhbGxiYWNrICYmIGZ1bmN0aW9uKCBqcVhIUiwgc3RhdHVzICkge1xuXHRcdFx0c2VsZi5lYWNoKCBmdW5jdGlvbigpIHtcblx0XHRcdFx0Y2FsbGJhY2suYXBwbHkoIHNlbGYsIHJlc3BvbnNlIHx8IFsganFYSFIucmVzcG9uc2VUZXh0LCBzdGF0dXMsIGpxWEhSIF0gKTtcblx0XHRcdH0gKTtcblx0XHR9ICk7XG5cdH1cblxuXHRyZXR1cm4gdGhpcztcbn07XG5cblxuXG5cbi8vIEF0dGFjaCBhIGJ1bmNoIG9mIGZ1bmN0aW9ucyBmb3IgaGFuZGxpbmcgY29tbW9uIEFKQVggZXZlbnRzXG5qUXVlcnkuZWFjaCggW1xuXHRcImFqYXhTdGFydFwiLFxuXHRcImFqYXhTdG9wXCIsXG5cdFwiYWpheENvbXBsZXRlXCIsXG5cdFwiYWpheEVycm9yXCIsXG5cdFwiYWpheFN1Y2Nlc3NcIixcblx0XCJhamF4U2VuZFwiXG5dLCBmdW5jdGlvbiggaSwgdHlwZSApIHtcblx0alF1ZXJ5LmZuWyB0eXBlIF0gPSBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIHRoaXMub24oIHR5cGUsIGZuICk7XG5cdH07XG59ICk7XG5cblxuXG5cbmpRdWVyeS5leHByLmZpbHRlcnMuYW5pbWF0ZWQgPSBmdW5jdGlvbiggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5ncmVwKCBqUXVlcnkudGltZXJzLCBmdW5jdGlvbiggZm4gKSB7XG5cdFx0cmV0dXJuIGVsZW0gPT09IGZuLmVsZW07XG5cdH0gKS5sZW5ndGg7XG59O1xuXG5cblxuXG4vKipcbiAqIEdldHMgYSB3aW5kb3cgZnJvbSBhbiBlbGVtZW50XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyggZWxlbSApIHtcblx0cmV0dXJuIGpRdWVyeS5pc1dpbmRvdyggZWxlbSApID8gZWxlbSA6IGVsZW0ubm9kZVR5cGUgPT09IDkgJiYgZWxlbS5kZWZhdWx0Vmlldztcbn1cblxualF1ZXJ5Lm9mZnNldCA9IHtcblx0c2V0T2Zmc2V0OiBmdW5jdGlvbiggZWxlbSwgb3B0aW9ucywgaSApIHtcblx0XHR2YXIgY3VyUG9zaXRpb24sIGN1ckxlZnQsIGN1ckNTU1RvcCwgY3VyVG9wLCBjdXJPZmZzZXQsIGN1ckNTU0xlZnQsIGNhbGN1bGF0ZVBvc2l0aW9uLFxuXHRcdFx0cG9zaXRpb24gPSBqUXVlcnkuY3NzKCBlbGVtLCBcInBvc2l0aW9uXCIgKSxcblx0XHRcdGN1ckVsZW0gPSBqUXVlcnkoIGVsZW0gKSxcblx0XHRcdHByb3BzID0ge307XG5cblx0XHQvLyBTZXQgcG9zaXRpb24gZmlyc3QsIGluLWNhc2UgdG9wL2xlZnQgYXJlIHNldCBldmVuIG9uIHN0YXRpYyBlbGVtXG5cdFx0aWYgKCBwb3NpdGlvbiA9PT0gXCJzdGF0aWNcIiApIHtcblx0XHRcdGVsZW0uc3R5bGUucG9zaXRpb24gPSBcInJlbGF0aXZlXCI7XG5cdFx0fVxuXG5cdFx0Y3VyT2Zmc2V0ID0gY3VyRWxlbS5vZmZzZXQoKTtcblx0XHRjdXJDU1NUb3AgPSBqUXVlcnkuY3NzKCBlbGVtLCBcInRvcFwiICk7XG5cdFx0Y3VyQ1NTTGVmdCA9IGpRdWVyeS5jc3MoIGVsZW0sIFwibGVmdFwiICk7XG5cdFx0Y2FsY3VsYXRlUG9zaXRpb24gPSAoIHBvc2l0aW9uID09PSBcImFic29sdXRlXCIgfHwgcG9zaXRpb24gPT09IFwiZml4ZWRcIiApICYmXG5cdFx0XHQoIGN1ckNTU1RvcCArIGN1ckNTU0xlZnQgKS5pbmRleE9mKCBcImF1dG9cIiApID4gLTE7XG5cblx0XHQvLyBOZWVkIHRvIGJlIGFibGUgdG8gY2FsY3VsYXRlIHBvc2l0aW9uIGlmIGVpdGhlclxuXHRcdC8vIHRvcCBvciBsZWZ0IGlzIGF1dG8gYW5kIHBvc2l0aW9uIGlzIGVpdGhlciBhYnNvbHV0ZSBvciBmaXhlZFxuXHRcdGlmICggY2FsY3VsYXRlUG9zaXRpb24gKSB7XG5cdFx0XHRjdXJQb3NpdGlvbiA9IGN1ckVsZW0ucG9zaXRpb24oKTtcblx0XHRcdGN1clRvcCA9IGN1clBvc2l0aW9uLnRvcDtcblx0XHRcdGN1ckxlZnQgPSBjdXJQb3NpdGlvbi5sZWZ0O1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1clRvcCA9IHBhcnNlRmxvYXQoIGN1ckNTU1RvcCApIHx8IDA7XG5cdFx0XHRjdXJMZWZ0ID0gcGFyc2VGbG9hdCggY3VyQ1NTTGVmdCApIHx8IDA7XG5cdFx0fVxuXG5cdFx0aWYgKCBqUXVlcnkuaXNGdW5jdGlvbiggb3B0aW9ucyApICkge1xuXG5cdFx0XHQvLyBVc2UgalF1ZXJ5LmV4dGVuZCBoZXJlIHRvIGFsbG93IG1vZGlmaWNhdGlvbiBvZiBjb29yZGluYXRlcyBhcmd1bWVudCAoZ2gtMTg0OClcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zLmNhbGwoIGVsZW0sIGksIGpRdWVyeS5leHRlbmQoIHt9LCBjdXJPZmZzZXQgKSApO1xuXHRcdH1cblxuXHRcdGlmICggb3B0aW9ucy50b3AgIT0gbnVsbCApIHtcblx0XHRcdHByb3BzLnRvcCA9ICggb3B0aW9ucy50b3AgLSBjdXJPZmZzZXQudG9wICkgKyBjdXJUb3A7XG5cdFx0fVxuXHRcdGlmICggb3B0aW9ucy5sZWZ0ICE9IG51bGwgKSB7XG5cdFx0XHRwcm9wcy5sZWZ0ID0gKCBvcHRpb25zLmxlZnQgLSBjdXJPZmZzZXQubGVmdCApICsgY3VyTGVmdDtcblx0XHR9XG5cblx0XHRpZiAoIFwidXNpbmdcIiBpbiBvcHRpb25zICkge1xuXHRcdFx0b3B0aW9ucy51c2luZy5jYWxsKCBlbGVtLCBwcm9wcyApO1xuXG5cdFx0fSBlbHNlIHtcblx0XHRcdGN1ckVsZW0uY3NzKCBwcm9wcyApO1xuXHRcdH1cblx0fVxufTtcblxualF1ZXJ5LmZuLmV4dGVuZCgge1xuXHRvZmZzZXQ6IGZ1bmN0aW9uKCBvcHRpb25zICkge1xuXHRcdGlmICggYXJndW1lbnRzLmxlbmd0aCApIHtcblx0XHRcdHJldHVybiBvcHRpb25zID09PSB1bmRlZmluZWQgP1xuXHRcdFx0XHR0aGlzIDpcblx0XHRcdFx0dGhpcy5lYWNoKCBmdW5jdGlvbiggaSApIHtcblx0XHRcdFx0XHRqUXVlcnkub2Zmc2V0LnNldE9mZnNldCggdGhpcywgb3B0aW9ucywgaSApO1xuXHRcdFx0XHR9ICk7XG5cdFx0fVxuXG5cdFx0dmFyIGRvY0VsZW0sIHdpbixcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRib3ggPSB7IHRvcDogMCwgbGVmdDogMCB9LFxuXHRcdFx0ZG9jID0gZWxlbSAmJiBlbGVtLm93bmVyRG9jdW1lbnQ7XG5cblx0XHRpZiAoICFkb2MgKSB7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0ZG9jRWxlbSA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHQvLyBNYWtlIHN1cmUgaXQncyBub3QgYSBkaXNjb25uZWN0ZWQgRE9NIG5vZGVcblx0XHRpZiAoICFqUXVlcnkuY29udGFpbnMoIGRvY0VsZW0sIGVsZW0gKSApIHtcblx0XHRcdHJldHVybiBib3g7XG5cdFx0fVxuXG5cdFx0Ym94ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHR3aW4gPSBnZXRXaW5kb3coIGRvYyApO1xuXHRcdHJldHVybiB7XG5cdFx0XHR0b3A6IGJveC50b3AgKyB3aW4ucGFnZVlPZmZzZXQgLSBkb2NFbGVtLmNsaWVudFRvcCxcblx0XHRcdGxlZnQ6IGJveC5sZWZ0ICsgd2luLnBhZ2VYT2Zmc2V0IC0gZG9jRWxlbS5jbGllbnRMZWZ0XG5cdFx0fTtcblx0fSxcblxuXHRwb3NpdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCAhdGhpc1sgMCBdICkge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdHZhciBvZmZzZXRQYXJlbnQsIG9mZnNldCxcblx0XHRcdGVsZW0gPSB0aGlzWyAwIF0sXG5cdFx0XHRwYXJlbnRPZmZzZXQgPSB7IHRvcDogMCwgbGVmdDogMCB9O1xuXG5cdFx0Ly8gRml4ZWQgZWxlbWVudHMgYXJlIG9mZnNldCBmcm9tIHdpbmRvdyAocGFyZW50T2Zmc2V0ID0ge3RvcDowLCBsZWZ0OiAwfSxcblx0XHQvLyBiZWNhdXNlIGl0IGlzIGl0cyBvbmx5IG9mZnNldCBwYXJlbnRcblx0XHRpZiAoIGpRdWVyeS5jc3MoIGVsZW0sIFwicG9zaXRpb25cIiApID09PSBcImZpeGVkXCIgKSB7XG5cblx0XHRcdC8vIEFzc3VtZSBnZXRCb3VuZGluZ0NsaWVudFJlY3QgaXMgdGhlcmUgd2hlbiBjb21wdXRlZCBwb3NpdGlvbiBpcyBmaXhlZFxuXHRcdFx0b2Zmc2V0ID0gZWxlbS5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIEdldCAqcmVhbCogb2Zmc2V0UGFyZW50XG5cdFx0XHRvZmZzZXRQYXJlbnQgPSB0aGlzLm9mZnNldFBhcmVudCgpO1xuXG5cdFx0XHQvLyBHZXQgY29ycmVjdCBvZmZzZXRzXG5cdFx0XHRvZmZzZXQgPSB0aGlzLm9mZnNldCgpO1xuXHRcdFx0aWYgKCAhalF1ZXJ5Lm5vZGVOYW1lKCBvZmZzZXRQYXJlbnRbIDAgXSwgXCJodG1sXCIgKSApIHtcblx0XHRcdFx0cGFyZW50T2Zmc2V0ID0gb2Zmc2V0UGFyZW50Lm9mZnNldCgpO1xuXHRcdFx0fVxuXG5cdFx0XHQvLyBBZGQgb2Zmc2V0UGFyZW50IGJvcmRlcnNcblx0XHRcdC8vIFN1YnRyYWN0IG9mZnNldFBhcmVudCBzY3JvbGwgcG9zaXRpb25zXG5cdFx0XHRwYXJlbnRPZmZzZXQudG9wICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlclRvcFdpZHRoXCIsIHRydWUgKSAtXG5cdFx0XHRcdG9mZnNldFBhcmVudC5zY3JvbGxUb3AoKTtcblx0XHRcdHBhcmVudE9mZnNldC5sZWZ0ICs9IGpRdWVyeS5jc3MoIG9mZnNldFBhcmVudFsgMCBdLCBcImJvcmRlckxlZnRXaWR0aFwiLCB0cnVlICkgLVxuXHRcdFx0XHRvZmZzZXRQYXJlbnQuc2Nyb2xsTGVmdCgpO1xuXHRcdH1cblxuXHRcdC8vIFN1YnRyYWN0IHBhcmVudCBvZmZzZXRzIGFuZCBlbGVtZW50IG1hcmdpbnNcblx0XHRyZXR1cm4ge1xuXHRcdFx0dG9wOiBvZmZzZXQudG9wIC0gcGFyZW50T2Zmc2V0LnRvcCAtIGpRdWVyeS5jc3MoIGVsZW0sIFwibWFyZ2luVG9wXCIsIHRydWUgKSxcblx0XHRcdGxlZnQ6IG9mZnNldC5sZWZ0IC0gcGFyZW50T2Zmc2V0LmxlZnQgLSBqUXVlcnkuY3NzKCBlbGVtLCBcIm1hcmdpbkxlZnRcIiwgdHJ1ZSApXG5cdFx0fTtcblx0fSxcblxuXHQvLyBUaGlzIG1ldGhvZCB3aWxsIHJldHVybiBkb2N1bWVudEVsZW1lbnQgaW4gdGhlIGZvbGxvd2luZyBjYXNlczpcblx0Ly8gMSkgRm9yIHRoZSBlbGVtZW50IGluc2lkZSB0aGUgaWZyYW1lIHdpdGhvdXQgb2Zmc2V0UGFyZW50LCB0aGlzIG1ldGhvZCB3aWxsIHJldHVyblxuXHQvLyAgICBkb2N1bWVudEVsZW1lbnQgb2YgdGhlIHBhcmVudCB3aW5kb3dcblx0Ly8gMikgRm9yIHRoZSBoaWRkZW4gb3IgZGV0YWNoZWQgZWxlbWVudFxuXHQvLyAzKSBGb3IgYm9keSBvciBodG1sIGVsZW1lbnQsIGkuZS4gaW4gY2FzZSBvZiB0aGUgaHRtbCBub2RlIC0gaXQgd2lsbCByZXR1cm4gaXRzZWxmXG5cdC8vXG5cdC8vIGJ1dCB0aG9zZSBleGNlcHRpb25zIHdlcmUgbmV2ZXIgcHJlc2VudGVkIGFzIGEgcmVhbCBsaWZlIHVzZS1jYXNlc1xuXHQvLyBhbmQgbWlnaHQgYmUgY29uc2lkZXJlZCBhcyBtb3JlIHByZWZlcmFibGUgcmVzdWx0cy5cblx0Ly9cblx0Ly8gVGhpcyBsb2dpYywgaG93ZXZlciwgaXMgbm90IGd1YXJhbnRlZWQgYW5kIGNhbiBjaGFuZ2UgYXQgYW55IHBvaW50IGluIHRoZSBmdXR1cmVcblx0b2Zmc2V0UGFyZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5tYXAoIGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIG9mZnNldFBhcmVudCA9IHRoaXMub2Zmc2V0UGFyZW50O1xuXG5cdFx0XHR3aGlsZSAoIG9mZnNldFBhcmVudCAmJiBqUXVlcnkuY3NzKCBvZmZzZXRQYXJlbnQsIFwicG9zaXRpb25cIiApID09PSBcInN0YXRpY1wiICkge1xuXHRcdFx0XHRvZmZzZXRQYXJlbnQgPSBvZmZzZXRQYXJlbnQub2Zmc2V0UGFyZW50O1xuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gb2Zmc2V0UGFyZW50IHx8IGRvY3VtZW50RWxlbWVudDtcblx0XHR9ICk7XG5cdH1cbn0gKTtcblxuLy8gQ3JlYXRlIHNjcm9sbExlZnQgYW5kIHNjcm9sbFRvcCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBzY3JvbGxMZWZ0OiBcInBhZ2VYT2Zmc2V0XCIsIHNjcm9sbFRvcDogXCJwYWdlWU9mZnNldFwiIH0sIGZ1bmN0aW9uKCBtZXRob2QsIHByb3AgKSB7XG5cdHZhciB0b3AgPSBcInBhZ2VZT2Zmc2V0XCIgPT09IHByb3A7XG5cblx0alF1ZXJ5LmZuWyBtZXRob2QgXSA9IGZ1bmN0aW9uKCB2YWwgKSB7XG5cdFx0cmV0dXJuIGFjY2VzcyggdGhpcywgZnVuY3Rpb24oIGVsZW0sIG1ldGhvZCwgdmFsICkge1xuXHRcdFx0dmFyIHdpbiA9IGdldFdpbmRvdyggZWxlbSApO1xuXG5cdFx0XHRpZiAoIHZhbCA9PT0gdW5kZWZpbmVkICkge1xuXHRcdFx0XHRyZXR1cm4gd2luID8gd2luWyBwcm9wIF0gOiBlbGVtWyBtZXRob2QgXTtcblx0XHRcdH1cblxuXHRcdFx0aWYgKCB3aW4gKSB7XG5cdFx0XHRcdHdpbi5zY3JvbGxUbyhcblx0XHRcdFx0XHQhdG9wID8gdmFsIDogd2luLnBhZ2VYT2Zmc2V0LFxuXHRcdFx0XHRcdHRvcCA/IHZhbCA6IHdpbi5wYWdlWU9mZnNldFxuXHRcdFx0XHQpO1xuXG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRlbGVtWyBtZXRob2QgXSA9IHZhbDtcblx0XHRcdH1cblx0XHR9LCBtZXRob2QsIHZhbCwgYXJndW1lbnRzLmxlbmd0aCApO1xuXHR9O1xufSApO1xuXG4vLyBTdXBwb3J0OiBTYWZhcmk8Ny04KywgQ2hyb21lPDM3LTQ0K1xuLy8gQWRkIHRoZSB0b3AvbGVmdCBjc3NIb29rcyB1c2luZyBqUXVlcnkuZm4ucG9zaXRpb25cbi8vIFdlYmtpdCBidWc6IGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0yOTA4NFxuLy8gQmxpbmsgYnVnOiBodHRwczovL2NvZGUuZ29vZ2xlLmNvbS9wL2Nocm9taXVtL2lzc3Vlcy9kZXRhaWw/aWQ9MjI5MjgwXG4vLyBnZXRDb21wdXRlZFN0eWxlIHJldHVybnMgcGVyY2VudCB3aGVuIHNwZWNpZmllZCBmb3IgdG9wL2xlZnQvYm90dG9tL3JpZ2h0O1xuLy8gcmF0aGVyIHRoYW4gbWFrZSB0aGUgY3NzIG1vZHVsZSBkZXBlbmQgb24gdGhlIG9mZnNldCBtb2R1bGUsIGp1c3QgY2hlY2sgZm9yIGl0IGhlcmVcbmpRdWVyeS5lYWNoKCBbIFwidG9wXCIsIFwibGVmdFwiIF0sIGZ1bmN0aW9uKCBpLCBwcm9wICkge1xuXHRqUXVlcnkuY3NzSG9va3NbIHByb3AgXSA9IGFkZEdldEhvb2tJZiggc3VwcG9ydC5waXhlbFBvc2l0aW9uLFxuXHRcdGZ1bmN0aW9uKCBlbGVtLCBjb21wdXRlZCApIHtcblx0XHRcdGlmICggY29tcHV0ZWQgKSB7XG5cdFx0XHRcdGNvbXB1dGVkID0gY3VyQ1NTKCBlbGVtLCBwcm9wICk7XG5cblx0XHRcdFx0Ly8gSWYgY3VyQ1NTIHJldHVybnMgcGVyY2VudGFnZSwgZmFsbGJhY2sgdG8gb2Zmc2V0XG5cdFx0XHRcdHJldHVybiBybnVtbm9ucHgudGVzdCggY29tcHV0ZWQgKSA/XG5cdFx0XHRcdFx0alF1ZXJ5KCBlbGVtICkucG9zaXRpb24oKVsgcHJvcCBdICsgXCJweFwiIDpcblx0XHRcdFx0XHRjb21wdXRlZDtcblx0XHRcdH1cblx0XHR9XG5cdCk7XG59ICk7XG5cblxuLy8gQ3JlYXRlIGlubmVySGVpZ2h0LCBpbm5lcldpZHRoLCBoZWlnaHQsIHdpZHRoLCBvdXRlckhlaWdodCBhbmQgb3V0ZXJXaWR0aCBtZXRob2RzXG5qUXVlcnkuZWFjaCggeyBIZWlnaHQ6IFwiaGVpZ2h0XCIsIFdpZHRoOiBcIndpZHRoXCIgfSwgZnVuY3Rpb24oIG5hbWUsIHR5cGUgKSB7XG5cdGpRdWVyeS5lYWNoKCB7IHBhZGRpbmc6IFwiaW5uZXJcIiArIG5hbWUsIGNvbnRlbnQ6IHR5cGUsIFwiXCI6IFwib3V0ZXJcIiArIG5hbWUgfSxcblx0XHRmdW5jdGlvbiggZGVmYXVsdEV4dHJhLCBmdW5jTmFtZSApIHtcblxuXHRcdC8vIE1hcmdpbiBpcyBvbmx5IGZvciBvdXRlckhlaWdodCwgb3V0ZXJXaWR0aFxuXHRcdGpRdWVyeS5mblsgZnVuY05hbWUgXSA9IGZ1bmN0aW9uKCBtYXJnaW4sIHZhbHVlICkge1xuXHRcdFx0dmFyIGNoYWluYWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggJiYgKCBkZWZhdWx0RXh0cmEgfHwgdHlwZW9mIG1hcmdpbiAhPT0gXCJib29sZWFuXCIgKSxcblx0XHRcdFx0ZXh0cmEgPSBkZWZhdWx0RXh0cmEgfHwgKCBtYXJnaW4gPT09IHRydWUgfHwgdmFsdWUgPT09IHRydWUgPyBcIm1hcmdpblwiIDogXCJib3JkZXJcIiApO1xuXG5cdFx0XHRyZXR1cm4gYWNjZXNzKCB0aGlzLCBmdW5jdGlvbiggZWxlbSwgdHlwZSwgdmFsdWUgKSB7XG5cdFx0XHRcdHZhciBkb2M7XG5cblx0XHRcdFx0aWYgKCBqUXVlcnkuaXNXaW5kb3coIGVsZW0gKSApIHtcblxuXHRcdFx0XHRcdC8vIEFzIG9mIDUvOC8yMDEyIHRoaXMgd2lsbCB5aWVsZCBpbmNvcnJlY3QgcmVzdWx0cyBmb3IgTW9iaWxlIFNhZmFyaSwgYnV0IHRoZXJlXG5cdFx0XHRcdFx0Ly8gaXNuJ3QgYSB3aG9sZSBsb3Qgd2UgY2FuIGRvLiBTZWUgcHVsbCByZXF1ZXN0IGF0IHRoaXMgVVJMIGZvciBkaXNjdXNzaW9uOlxuXHRcdFx0XHRcdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qcXVlcnkvanF1ZXJ5L3B1bGwvNzY0XG5cdFx0XHRcdFx0cmV0dXJuIGVsZW0uZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50WyBcImNsaWVudFwiICsgbmFtZSBdO1xuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gR2V0IGRvY3VtZW50IHdpZHRoIG9yIGhlaWdodFxuXHRcdFx0XHRpZiAoIGVsZW0ubm9kZVR5cGUgPT09IDkgKSB7XG5cdFx0XHRcdFx0ZG9jID0gZWxlbS5kb2N1bWVudEVsZW1lbnQ7XG5cblx0XHRcdFx0XHQvLyBFaXRoZXIgc2Nyb2xsW1dpZHRoL0hlaWdodF0gb3Igb2Zmc2V0W1dpZHRoL0hlaWdodF0gb3IgY2xpZW50W1dpZHRoL0hlaWdodF0sXG5cdFx0XHRcdFx0Ly8gd2hpY2hldmVyIGlzIGdyZWF0ZXN0XG5cdFx0XHRcdFx0cmV0dXJuIE1hdGgubWF4KFxuXHRcdFx0XHRcdFx0ZWxlbS5ib2R5WyBcInNjcm9sbFwiICsgbmFtZSBdLCBkb2NbIFwic2Nyb2xsXCIgKyBuYW1lIF0sXG5cdFx0XHRcdFx0XHRlbGVtLmJvZHlbIFwib2Zmc2V0XCIgKyBuYW1lIF0sIGRvY1sgXCJvZmZzZXRcIiArIG5hbWUgXSxcblx0XHRcdFx0XHRcdGRvY1sgXCJjbGllbnRcIiArIG5hbWUgXVxuXHRcdFx0XHRcdCk7XG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdmFsdWUgPT09IHVuZGVmaW5lZCA/XG5cblx0XHRcdFx0XHQvLyBHZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50LCByZXF1ZXN0aW5nIGJ1dCBub3QgZm9yY2luZyBwYXJzZUZsb2F0XG5cdFx0XHRcdFx0alF1ZXJ5LmNzcyggZWxlbSwgdHlwZSwgZXh0cmEgKSA6XG5cblx0XHRcdFx0XHQvLyBTZXQgd2lkdGggb3IgaGVpZ2h0IG9uIHRoZSBlbGVtZW50XG5cdFx0XHRcdFx0alF1ZXJ5LnN0eWxlKCBlbGVtLCB0eXBlLCB2YWx1ZSwgZXh0cmEgKTtcblx0XHRcdH0sIHR5cGUsIGNoYWluYWJsZSA/IG1hcmdpbiA6IHVuZGVmaW5lZCwgY2hhaW5hYmxlLCBudWxsICk7XG5cdFx0fTtcblx0fSApO1xufSApO1xuXG5cbmpRdWVyeS5mbi5leHRlbmQoIHtcblxuXHRiaW5kOiBmdW5jdGlvbiggdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgbnVsbCwgZGF0YSwgZm4gKTtcblx0fSxcblx0dW5iaW5kOiBmdW5jdGlvbiggdHlwZXMsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9mZiggdHlwZXMsIG51bGwsIGZuICk7XG5cdH0sXG5cblx0ZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGRhdGEsIGZuICkge1xuXHRcdHJldHVybiB0aGlzLm9uKCB0eXBlcywgc2VsZWN0b3IsIGRhdGEsIGZuICk7XG5cdH0sXG5cdHVuZGVsZWdhdGU6IGZ1bmN0aW9uKCBzZWxlY3RvciwgdHlwZXMsIGZuICkge1xuXG5cdFx0Ly8gKCBuYW1lc3BhY2UgKSBvciAoIHNlbGVjdG9yLCB0eXBlcyBbLCBmbl0gKVxuXHRcdHJldHVybiBhcmd1bWVudHMubGVuZ3RoID09PSAxID9cblx0XHRcdHRoaXMub2ZmKCBzZWxlY3RvciwgXCIqKlwiICkgOlxuXHRcdFx0dGhpcy5vZmYoIHR5cGVzLCBzZWxlY3RvciB8fCBcIioqXCIsIGZuICk7XG5cdH0sXG5cdHNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmxlbmd0aDtcblx0fVxufSApO1xuXG5qUXVlcnkuZm4uYW5kU2VsZiA9IGpRdWVyeS5mbi5hZGRCYWNrO1xuXG5cblxuXG4vLyBSZWdpc3RlciBhcyBhIG5hbWVkIEFNRCBtb2R1bGUsIHNpbmNlIGpRdWVyeSBjYW4gYmUgY29uY2F0ZW5hdGVkIHdpdGggb3RoZXJcbi8vIGZpbGVzIHRoYXQgbWF5IHVzZSBkZWZpbmUsIGJ1dCBub3QgdmlhIGEgcHJvcGVyIGNvbmNhdGVuYXRpb24gc2NyaXB0IHRoYXRcbi8vIHVuZGVyc3RhbmRzIGFub255bW91cyBBTUQgbW9kdWxlcy4gQSBuYW1lZCBBTUQgaXMgc2FmZXN0IGFuZCBtb3N0IHJvYnVzdFxuLy8gd2F5IHRvIHJlZ2lzdGVyLiBMb3dlcmNhc2UganF1ZXJ5IGlzIHVzZWQgYmVjYXVzZSBBTUQgbW9kdWxlIG5hbWVzIGFyZVxuLy8gZGVyaXZlZCBmcm9tIGZpbGUgbmFtZXMsIGFuZCBqUXVlcnkgaXMgbm9ybWFsbHkgZGVsaXZlcmVkIGluIGEgbG93ZXJjYXNlXG4vLyBmaWxlIG5hbWUuIERvIHRoaXMgYWZ0ZXIgY3JlYXRpbmcgdGhlIGdsb2JhbCBzbyB0aGF0IGlmIGFuIEFNRCBtb2R1bGUgd2FudHNcbi8vIHRvIGNhbGwgbm9Db25mbGljdCB0byBoaWRlIHRoaXMgdmVyc2lvbiBvZiBqUXVlcnksIGl0IHdpbGwgd29yay5cblxuLy8gTm90ZSB0aGF0IGZvciBtYXhpbXVtIHBvcnRhYmlsaXR5LCBsaWJyYXJpZXMgdGhhdCBhcmUgbm90IGpRdWVyeSBzaG91bGRcbi8vIGRlY2xhcmUgdGhlbXNlbHZlcyBhcyBhbm9ueW1vdXMgbW9kdWxlcywgYW5kIGF2b2lkIHNldHRpbmcgYSBnbG9iYWwgaWYgYW5cbi8vIEFNRCBsb2FkZXIgaXMgcHJlc2VudC4galF1ZXJ5IGlzIGEgc3BlY2lhbCBjYXNlLiBGb3IgbW9yZSBpbmZvcm1hdGlvbiwgc2VlXG4vLyBodHRwczovL2dpdGh1Yi5jb20vanJidXJrZS9yZXF1aXJlanMvd2lraS9VcGRhdGluZy1leGlzdGluZy1saWJyYXJpZXMjd2lraS1hbm9uXG5cbmlmICggdHlwZW9mIGRlZmluZSA9PT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQgKSB7XG5cdGRlZmluZSggXCJqcXVlcnlcIiwgW10sIGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBqUXVlcnk7XG5cdH0gKTtcbn1cblxuXG5cbnZhclxuXG5cdC8vIE1hcCBvdmVyIGpRdWVyeSBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfalF1ZXJ5ID0gd2luZG93LmpRdWVyeSxcblxuXHQvLyBNYXAgb3ZlciB0aGUgJCBpbiBjYXNlIG9mIG92ZXJ3cml0ZVxuXHRfJCA9IHdpbmRvdy4kO1xuXG5qUXVlcnkubm9Db25mbGljdCA9IGZ1bmN0aW9uKCBkZWVwICkge1xuXHRpZiAoIHdpbmRvdy4kID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LiQgPSBfJDtcblx0fVxuXG5cdGlmICggZGVlcCAmJiB3aW5kb3cualF1ZXJ5ID09PSBqUXVlcnkgKSB7XG5cdFx0d2luZG93LmpRdWVyeSA9IF9qUXVlcnk7XG5cdH1cblxuXHRyZXR1cm4galF1ZXJ5O1xufTtcblxuLy8gRXhwb3NlIGpRdWVyeSBhbmQgJCBpZGVudGlmaWVycywgZXZlbiBpbiBBTURcbi8vICgjNzEwMiNjb21tZW50OjEwLCBodHRwczovL2dpdGh1Yi5jb20vanF1ZXJ5L2pxdWVyeS9wdWxsLzU1Nylcbi8vIGFuZCBDb21tb25KUyBmb3IgYnJvd3NlciBlbXVsYXRvcnMgKCMxMzU2NilcbmlmICggIW5vR2xvYmFsICkge1xuXHR3aW5kb3cualF1ZXJ5ID0gd2luZG93LiQgPSBqUXVlcnk7XG59XG5cbnJldHVybiBqUXVlcnk7XG59KSk7XG4iLCIvKiFcbiAqIExvLURhc2ggdjAuOS4yIDxodHRwOi8vbG9kYXNoLmNvbT5cbiAqIChjKSAyMDEyIEpvaG4tRGF2aWQgRGFsdG9uIDxodHRwOi8vYWxseW91Y2FubGVldC5jb20vPlxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjQuMiA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmc+XG4gKiAoYykgMjAwOS0yMDEyIEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBJbmMuXG4gKiBBdmFpbGFibGUgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHA6Ly9sb2Rhc2guY29tL2xpY2Vuc2U+XG4gKi9cbjsoZnVuY3Rpb24od2luZG93LCB1bmRlZmluZWQpIHtcblxuICAvKiogRGV0ZWN0IGZyZWUgdmFyaWFibGUgYGV4cG9ydHNgICovXG4gIHZhciBmcmVlRXhwb3J0cyA9IHR5cGVvZiBleHBvcnRzID09ICdvYmplY3QnICYmIGV4cG9ydHM7XG5cbiAgLyoqIERldGVjdCBmcmVlIHZhcmlhYmxlIGBnbG9iYWxgIGFuZCB1c2UgaXQgYXMgYHdpbmRvd2AgKi9cbiAgdmFyIGZyZWVHbG9iYWwgPSB0eXBlb2YgZ2xvYmFsID09ICdvYmplY3QnICYmIGdsb2JhbDtcbiAgaWYgKGZyZWVHbG9iYWwuZ2xvYmFsID09PSBmcmVlR2xvYmFsKSB7XG4gICAgd2luZG93ID0gZnJlZUdsb2JhbDtcbiAgfVxuXG4gIC8qKiBVc2VkIGZvciBhcnJheSBhbmQgb2JqZWN0IG1ldGhvZCByZWZlcmVuY2VzICovXG4gIHZhciBhcnJheVJlZiA9IFtdLFxuICAgICAgLy8gYXZvaWQgYSBDbG9zdXJlIENvbXBpbGVyIGJ1ZyBieSBjcmVhdGl2ZWx5IGNyZWF0aW5nIGFuIG9iamVjdFxuICAgICAgb2JqZWN0UmVmID0gbmV3IGZ1bmN0aW9uKCl7fTtcblxuICAvKiogVXNlZCB0byBnZW5lcmF0ZSB1bmlxdWUgSURzICovXG4gIHZhciBpZENvdW50ZXIgPSAwO1xuXG4gIC8qKiBVc2VkIGludGVybmFsbHkgdG8gaW5kaWNhdGUgdmFyaW91cyB0aGluZ3MgKi9cbiAgdmFyIGluZGljYXRvck9iamVjdCA9IG9iamVjdFJlZjtcblxuICAvKiogVXNlZCBieSBgY2FjaGVkQ29udGFpbnNgIGFzIHRoZSBkZWZhdWx0IHNpemUgd2hlbiBvcHRpbWl6YXRpb25zIGFyZSBlbmFibGVkIGZvciBsYXJnZSBhcnJheXMgKi9cbiAgdmFyIGxhcmdlQXJyYXlTaXplID0gMzA7XG5cbiAgLyoqIFVzZWQgdG8gcmVzdG9yZSB0aGUgb3JpZ2luYWwgYF9gIHJlZmVyZW5jZSBpbiBgbm9Db25mbGljdGAgKi9cbiAgdmFyIG9sZERhc2ggPSB3aW5kb3cuXztcblxuICAvKiogVXNlZCB0byBkZXRlY3QgdGVtcGxhdGUgZGVsaW1pdGVyIHZhbHVlcyB0aGF0IHJlcXVpcmUgYSB3aXRoLXN0YXRlbWVudCAqL1xuICB2YXIgcmVDb21wbGV4RGVsaW1pdGVyID0gL1stPys9IX4qJSZePD58eyhcXC9dfFxcW1xcRHxcXGIoPzpkZWxldGV8aW58aW5zdGFuY2VvZnxuZXd8dHlwZW9mfHZvaWQpXFxiLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGVudGl0aWVzICovXG4gIHZhciByZUVzY2FwZWRIdG1sID0gLyYoPzphbXB8bHR8Z3R8cXVvdHwjeDI3KTsvZztcblxuICAvKiogVXNlZCB0byBtYXRjaCBlbXB0eSBzdHJpbmcgbGl0ZXJhbHMgaW4gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlICovXG4gIHZhciByZUVtcHR5U3RyaW5nTGVhZGluZyA9IC9cXGJfX3AgXFwrPSAnJzsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdNaWRkbGUgPSAvXFxiKF9fcCBcXCs9KSAnJyBcXCsvZyxcbiAgICAgIHJlRW1wdHlTdHJpbmdUcmFpbGluZyA9IC8oX19lXFwoLio/XFwpfFxcYl9fdFxcKSkgXFwrXFxuJyc7L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggcmVnZXhwIGZsYWdzIGZyb20gdGhlaXIgY29lcmNlZCBzdHJpbmcgdmFsdWVzICovXG4gIHZhciByZUZsYWdzID0gL1xcdyokLztcblxuICAvKiogVXNlZCB0byBpbnNlcnQgdGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIGludG8gY29tcGlsZWQgdGVtcGxhdGUgc291cmNlICovXG4gIHZhciByZUluc2VydFZhcmlhYmxlID0gLyg/Ol9fZXxfX3QgPSApXFwoXFxzKig/IVtcXGRcXHNcIiddfHRoaXNcXC4pL2c7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZWN0IGlmIGEgbWV0aG9kIGlzIG5hdGl2ZSAqL1xuICB2YXIgcmVOYXRpdmUgPSBSZWdFeHAoJ14nICtcbiAgICAob2JqZWN0UmVmLnZhbHVlT2YgKyAnJylcbiAgICAgIC5yZXBsYWNlKC9bLiorP149IToke30oKXxbXFxdXFwvXFxcXF0vZywgJ1xcXFwkJicpXG4gICAgICAucmVwbGFjZSgvdmFsdWVPZnxmb3IgW15cXF1dKy9nLCAnLis/JykgKyAnJCdcbiAgKTtcblxuICAvKipcbiAgICogVXNlZCB0byBtYXRjaCBFUzYgdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgKiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy03LjguNlxuICAgKi9cbiAgdmFyIHJlRXNUZW1wbGF0ZSA9IC9cXCRcXHsoKD86KD89XFxcXD8pXFxcXD9bXFxzXFxTXSkqPyl9L2c7XG5cbiAgLyoqIFVzZWQgdG8gbWF0Y2ggXCJpbnRlcnBvbGF0ZVwiIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlSW50ZXJwb2xhdGUgPSAvPCU9KFtcXHNcXFNdKz8pJT4vZztcblxuICAvKiogVXNlZCB0byBlbnN1cmUgY2FwdHVyaW5nIG9yZGVyIG9mIHRlbXBsYXRlIGRlbGltaXRlcnMgKi9cbiAgdmFyIHJlTm9NYXRjaCA9IC8oJF4pLztcblxuICAvKiogVXNlZCB0byBtYXRjaCBIVE1MIGNoYXJhY3RlcnMgKi9cbiAgdmFyIHJlVW5lc2NhcGVkSHRtbCA9IC9bJjw+XCInXS9nO1xuXG4gIC8qKiBVc2VkIHRvIG1hdGNoIHVuZXNjYXBlZCBjaGFyYWN0ZXJzIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscyAqL1xuICB2YXIgcmVVbmVzY2FwZWRTdHJpbmcgPSAvWydcXG5cXHJcXHRcXHUyMDI4XFx1MjAyOVxcXFxdL2c7XG5cbiAgLyoqIFVzZWQgdG8gZml4IHRoZSBKU2NyaXB0IFtbRG9udEVudW1dXSBidWcgKi9cbiAgdmFyIHNoYWRvd2VkID0gW1xuICAgICdjb25zdHJ1Y3RvcicsICdoYXNPd25Qcm9wZXJ0eScsICdpc1Byb3RvdHlwZU9mJywgJ3Byb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAndG9Mb2NhbGVTdHJpbmcnLCAndG9TdHJpbmcnLCAndmFsdWVPZidcbiAgXTtcblxuICAvKiogVXNlZCB0byBtYWtlIHRlbXBsYXRlIHNvdXJjZVVSTHMgZWFzaWVyIHRvIGlkZW50aWZ5ICovXG4gIHZhciB0ZW1wbGF0ZUNvdW50ZXIgPSAwO1xuXG4gIC8qKiBOYXRpdmUgbWV0aG9kIHNob3J0Y3V0cyAqL1xuICB2YXIgY2VpbCA9IE1hdGguY2VpbCxcbiAgICAgIGNvbmNhdCA9IGFycmF5UmVmLmNvbmNhdCxcbiAgICAgIGZsb29yID0gTWF0aC5mbG9vcixcbiAgICAgIGdldFByb3RvdHlwZU9mID0gcmVOYXRpdmUudGVzdChnZXRQcm90b3R5cGVPZiA9IE9iamVjdC5nZXRQcm90b3R5cGVPZikgJiYgZ2V0UHJvdG90eXBlT2YsXG4gICAgICBoYXNPd25Qcm9wZXJ0eSA9IG9iamVjdFJlZi5oYXNPd25Qcm9wZXJ0eSxcbiAgICAgIHB1c2ggPSBhcnJheVJlZi5wdXNoLFxuICAgICAgcHJvcGVydHlJc0VudW1lcmFibGUgPSBvYmplY3RSZWYucHJvcGVydHlJc0VudW1lcmFibGUsXG4gICAgICBzbGljZSA9IGFycmF5UmVmLnNsaWNlLFxuICAgICAgdG9TdHJpbmcgPSBvYmplY3RSZWYudG9TdHJpbmc7XG5cbiAgLyogTmF0aXZlIG1ldGhvZCBzaG9ydGN1dHMgZm9yIG1ldGhvZHMgd2l0aCB0aGUgc2FtZSBuYW1lIGFzIG90aGVyIGBsb2Rhc2hgIG1ldGhvZHMgKi9cbiAgdmFyIG5hdGl2ZUJpbmQgPSByZU5hdGl2ZS50ZXN0KG5hdGl2ZUJpbmQgPSBzbGljZS5iaW5kKSAmJiBuYXRpdmVCaW5kLFxuICAgICAgbmF0aXZlSXNBcnJheSA9IHJlTmF0aXZlLnRlc3QobmF0aXZlSXNBcnJheSA9IEFycmF5LmlzQXJyYXkpICYmIG5hdGl2ZUlzQXJyYXksXG4gICAgICBuYXRpdmVJc0Zpbml0ZSA9IHdpbmRvdy5pc0Zpbml0ZSxcbiAgICAgIG5hdGl2ZUlzTmFOID0gd2luZG93LmlzTmFOLFxuICAgICAgbmF0aXZlS2V5cyA9IHJlTmF0aXZlLnRlc3QobmF0aXZlS2V5cyA9IE9iamVjdC5rZXlzKSAmJiBuYXRpdmVLZXlzLFxuICAgICAgbmF0aXZlTWF4ID0gTWF0aC5tYXgsXG4gICAgICBuYXRpdmVNaW4gPSBNYXRoLm1pbixcbiAgICAgIG5hdGl2ZVJhbmRvbSA9IE1hdGgucmFuZG9tO1xuXG4gIC8qKiBgT2JqZWN0I3RvU3RyaW5nYCByZXN1bHQgc2hvcnRjdXRzICovXG4gIHZhciBhcmdzQ2xhc3MgPSAnW29iamVjdCBBcmd1bWVudHNdJyxcbiAgICAgIGFycmF5Q2xhc3MgPSAnW29iamVjdCBBcnJheV0nLFxuICAgICAgYm9vbENsYXNzID0gJ1tvYmplY3QgQm9vbGVhbl0nLFxuICAgICAgZGF0ZUNsYXNzID0gJ1tvYmplY3QgRGF0ZV0nLFxuICAgICAgZnVuY0NsYXNzID0gJ1tvYmplY3QgRnVuY3Rpb25dJyxcbiAgICAgIG51bWJlckNsYXNzID0gJ1tvYmplY3QgTnVtYmVyXScsXG4gICAgICBvYmplY3RDbGFzcyA9ICdbb2JqZWN0IE9iamVjdF0nLFxuICAgICAgcmVnZXhwQ2xhc3MgPSAnW29iamVjdCBSZWdFeHBdJyxcbiAgICAgIHN0cmluZ0NsYXNzID0gJ1tvYmplY3QgU3RyaW5nXSc7XG5cbiAgLyoqXG4gICAqIERldGVjdCB0aGUgSlNjcmlwdCBbW0RvbnRFbnVtXV0gYnVnOlxuICAgKlxuICAgKiBJbiBJRSA8IDkgYW4gb2JqZWN0cyBvd24gcHJvcGVydGllcywgc2hhZG93aW5nIG5vbi1lbnVtZXJhYmxlIG9uZXMsIGFyZVxuICAgKiBtYWRlIG5vbi1lbnVtZXJhYmxlIGFzIHdlbGwuXG4gICAqL1xuICB2YXIgaGFzRG9udEVudW1CdWc7XG5cbiAgLyoqIERldGVjdCBpZiBvd24gcHJvcGVydGllcyBhcmUgaXRlcmF0ZWQgYWZ0ZXIgaW5oZXJpdGVkIHByb3BlcnRpZXMgKElFIDwgOSkgKi9cbiAgdmFyIGl0ZXJhdGVzT3duTGFzdDtcblxuICAvKipcbiAgICogRGV0ZWN0IGlmIGBBcnJheSNzaGlmdGAgYW5kIGBBcnJheSNzcGxpY2VgIGF1Z21lbnQgYXJyYXktbGlrZSBvYmplY3RzXG4gICAqIGluY29ycmVjdGx5OlxuICAgKlxuICAgKiBGaXJlZm94IDwgMTAsIElFIGNvbXBhdGliaWxpdHkgbW9kZSwgYW5kIElFIDwgOSBoYXZlIGJ1Z2d5IEFycmF5IGBzaGlmdCgpYFxuICAgKiBhbmQgYHNwbGljZSgpYCBmdW5jdGlvbnMgdGhhdCBmYWlsIHRvIHJlbW92ZSB0aGUgbGFzdCBlbGVtZW50LCBgdmFsdWVbMF1gLFxuICAgKiBvZiBhcnJheS1saWtlIG9iamVjdHMgZXZlbiB0aG91Z2ggdGhlIGBsZW5ndGhgIHByb3BlcnR5IGlzIHNldCB0byBgMGAuXG4gICAqIFRoZSBgc2hpZnQoKWAgbWV0aG9kIGlzIGJ1Z2d5IGluIElFIDggY29tcGF0aWJpbGl0eSBtb2RlLCB3aGlsZSBgc3BsaWNlKClgXG4gICAqIGlzIGJ1Z2d5IHJlZ2FyZGxlc3Mgb2YgbW9kZSBpbiBJRSA8IDkgYW5kIGJ1Z2d5IGluIGNvbXBhdGliaWxpdHkgbW9kZSBpbiBJRSA5LlxuICAgKi9cbiAgdmFyIGhhc09iamVjdFNwbGljZUJ1ZyA9IChoYXNPYmplY3RTcGxpY2VCdWcgPSB7ICcwJzogMSwgJ2xlbmd0aCc6IDEgfSxcbiAgICBhcnJheVJlZi5zcGxpY2UuY2FsbChoYXNPYmplY3RTcGxpY2VCdWcsIDAsIDEpLCBoYXNPYmplY3RTcGxpY2VCdWdbMF0pO1xuXG4gIC8qKiBEZXRlY3QgaWYgYW4gYGFyZ3VtZW50c2Agb2JqZWN0J3MgaW5kZXhlcyBhcmUgbm9uLWVudW1lcmFibGUgKElFIDwgOSkgKi9cbiAgdmFyIG5vQXJnc0VudW0gPSB0cnVlO1xuXG4gIChmdW5jdGlvbigpIHtcbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICBmdW5jdGlvbiBjdG9yKCkgeyB0aGlzLnggPSAxOyB9XG4gICAgY3Rvci5wcm90b3R5cGUgPSB7ICd2YWx1ZU9mJzogMSwgJ3knOiAxIH07XG4gICAgZm9yICh2YXIgcHJvcCBpbiBuZXcgY3RvcikgeyBwcm9wcy5wdXNoKHByb3ApOyB9XG4gICAgZm9yIChwcm9wIGluIGFyZ3VtZW50cykgeyBub0FyZ3NFbnVtID0gIXByb3A7IH1cblxuICAgIGhhc0RvbnRFbnVtQnVnID0gIS92YWx1ZU9mLy50ZXN0KHByb3BzKTtcbiAgICBpdGVyYXRlc093bkxhc3QgPSBwcm9wc1swXSAhPSAneCc7XG4gIH0oMSkpO1xuXG4gIC8qKiBEZXRlY3QgaWYgYW4gYGFyZ3VtZW50c2Agb2JqZWN0J3MgW1tDbGFzc11dIGlzIHVucmVzb2x2YWJsZSAoRmlyZWZveCA8IDQsIElFIDwgOSkgKi9cbiAgdmFyIG5vQXJnc0NsYXNzID0gIWlzQXJndW1lbnRzKGFyZ3VtZW50cyk7XG5cbiAgLyoqIERldGVjdCBpZiBgQXJyYXkjc2xpY2VgIGNhbm5vdCBiZSB1c2VkIHRvIGNvbnZlcnQgc3RyaW5ncyB0byBhcnJheXMgKE9wZXJhIDwgMTAuNTIpICovXG4gIHZhciBub0FycmF5U2xpY2VPblN0cmluZ3MgPSBzbGljZS5jYWxsKCd4JylbMF0gIT0gJ3gnO1xuXG4gIC8qKlxuICAgKiBEZXRlY3QgbGFjayBvZiBzdXBwb3J0IGZvciBhY2Nlc3Npbmcgc3RyaW5nIGNoYXJhY3RlcnMgYnkgaW5kZXg6XG4gICAqXG4gICAqIElFIDwgOCBjYW4ndCBhY2Nlc3MgY2hhcmFjdGVycyBieSBpbmRleCBhbmQgSUUgOCBjYW4gb25seSBhY2Nlc3NcbiAgICogY2hhcmFjdGVycyBieSBpbmRleCBvbiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqL1xuICB2YXIgbm9DaGFyQnlJbmRleCA9ICgneCdbMF0gKyBPYmplY3QoJ3gnKVswXSkgIT0gJ3h4JztcblxuICAvKipcbiAgICogRGV0ZWN0IGlmIGEgbm9kZSdzIFtbQ2xhc3NdXSBpcyB1bnJlc29sdmFibGUgKElFIDwgOSlcbiAgICogYW5kIHRoYXQgdGhlIEpTIGVuZ2luZSB3b24ndCBlcnJvciB3aGVuIGF0dGVtcHRpbmcgdG8gY29lcmNlIGFuIG9iamVjdCB0b1xuICAgKiBhIHN0cmluZyB3aXRob3V0IGEgYHRvU3RyaW5nYCBwcm9wZXJ0eSB2YWx1ZSBvZiBgdHlwZW9mYCBcImZ1bmN0aW9uXCIuXG4gICAqL1xuICB0cnkge1xuICAgIHZhciBub05vZGVDbGFzcyA9ICh7ICd0b1N0cmluZyc6IDAgfSArICcnLCB0b1N0cmluZy5jYWxsKHdpbmRvdy5kb2N1bWVudCB8fCAwKSA9PSBvYmplY3RDbGFzcyk7XG4gIH0gY2F0Y2goZSkgeyB9XG5cbiAgLyogRGV0ZWN0IGlmIGBGdW5jdGlvbiNiaW5kYCBleGlzdHMgYW5kIGlzIGluZmVycmVkIHRvIGJlIGZhc3QgKGFsbCBidXQgVjgpICovXG4gIHZhciBpc0JpbmRGYXN0ID0gbmF0aXZlQmluZCAmJiAvXFxufE9wZXJhLy50ZXN0KG5hdGl2ZUJpbmQgKyB0b1N0cmluZy5jYWxsKHdpbmRvdy5vcGVyYSkpO1xuXG4gIC8qIERldGVjdCBpZiBgT2JqZWN0LmtleXNgIGV4aXN0cyBhbmQgaXMgaW5mZXJyZWQgdG8gYmUgZmFzdCAoSUUsIE9wZXJhLCBWOCkgKi9cbiAgdmFyIGlzS2V5c0Zhc3QgPSBuYXRpdmVLZXlzICYmIC9eLiskfHRydWUvLnRlc3QobmF0aXZlS2V5cyArICEhd2luZG93LmF0dGFjaEV2ZW50KTtcblxuICAvKipcbiAgICogRGV0ZWN0IGlmIHNvdXJjZVVSTCBzeW50YXggaXMgdXNhYmxlIHdpdGhvdXQgZXJyb3Jpbmc6XG4gICAqXG4gICAqIFRoZSBKUyBlbmdpbmUgaW4gQWRvYmUgcHJvZHVjdHMsIGxpa2UgSW5EZXNpZ24sIHdpbGwgdGhyb3cgYSBzeW50YXggZXJyb3JcbiAgICogd2hlbiBpdCBlbmNvdW50ZXJzIGEgc2luZ2xlIGxpbmUgY29tbWVudCBiZWdpbm5pbmcgd2l0aCB0aGUgYEBgIHN5bWJvbC5cbiAgICpcbiAgICogVGhlIEpTIGVuZ2luZSBpbiBOYXJ3aGFsIHdpbGwgZ2VuZXJhdGUgdGhlIGZ1bmN0aW9uIGBmdW5jdGlvbiBhbm9ueW1vdXMoKXsvL31gXG4gICAqIGFuZCB0aHJvdyBhIHN5bnRheCBlcnJvci5cbiAgICpcbiAgICogQXZvaWQgY29tbWVudHMgYmVnaW5uaW5nIGBAYCBzeW1ib2xzIGluIElFIGJlY2F1c2UgdGhleSBhcmUgcGFydCBvZiBpdHNcbiAgICogbm9uLXN0YW5kYXJkIGNvbmRpdGlvbmFsIGNvbXBpbGF0aW9uIHN1cHBvcnQuXG4gICAqIGh0dHA6Ly9tc2RuLm1pY3Jvc29mdC5jb20vZW4tdXMvbGlicmFyeS8xMjFoenRrMyh2PXZzLjk0KS5hc3B4XG4gICAqL1xuICB0cnkge1xuICAgIHZhciB1c2VTb3VyY2VVUkwgPSAoRnVuY3Rpb24oJy8vQCcpKCksICF3aW5kb3cuYXR0YWNoRXZlbnQpO1xuICB9IGNhdGNoKGUpIHsgfVxuXG4gIC8qKiBVc2VkIHRvIGlkZW50aWZ5IG9iamVjdCBjbGFzc2lmaWNhdGlvbnMgdGhhdCBgXy5jbG9uZWAgc3VwcG9ydHMgKi9cbiAgdmFyIGNsb25lYWJsZUNsYXNzZXMgPSB7fTtcbiAgY2xvbmVhYmxlQ2xhc3Nlc1thcmdzQ2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tmdW5jQ2xhc3NdID0gZmFsc2U7XG4gIGNsb25lYWJsZUNsYXNzZXNbYXJyYXlDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW2Jvb2xDbGFzc10gPSBjbG9uZWFibGVDbGFzc2VzW2RhdGVDbGFzc10gPVxuICBjbG9uZWFibGVDbGFzc2VzW251bWJlckNsYXNzXSA9IGNsb25lYWJsZUNsYXNzZXNbb2JqZWN0Q2xhc3NdID0gY2xvbmVhYmxlQ2xhc3Nlc1tyZWdleHBDbGFzc10gPVxuICBjbG9uZWFibGVDbGFzc2VzW3N0cmluZ0NsYXNzXSA9IHRydWU7XG5cbiAgLyoqIFVzZWQgdG8gZGV0ZXJtaW5lIGlmIHZhbHVlcyBhcmUgb2YgdGhlIGxhbmd1YWdlIHR5cGUgT2JqZWN0ICovXG4gIHZhciBvYmplY3RUeXBlcyA9IHtcbiAgICAnYm9vbGVhbic6IGZhbHNlLFxuICAgICdmdW5jdGlvbic6IHRydWUsXG4gICAgJ29iamVjdCc6IHRydWUsXG4gICAgJ251bWJlcic6IGZhbHNlLFxuICAgICdzdHJpbmcnOiBmYWxzZSxcbiAgICAndW5kZWZpbmVkJzogZmFsc2VcbiAgfTtcblxuICAvKiogVXNlZCB0byBlc2NhcGUgY2hhcmFjdGVycyBmb3IgaW5jbHVzaW9uIGluIGNvbXBpbGVkIHN0cmluZyBsaXRlcmFscyAqL1xuICB2YXIgc3RyaW5nRXNjYXBlcyA9IHtcbiAgICAnXFxcXCc6ICdcXFxcJyxcbiAgICBcIidcIjogXCInXCIsXG4gICAgJ1xcbic6ICduJyxcbiAgICAnXFxyJzogJ3InLFxuICAgICdcXHQnOiAndCcsXG4gICAgJ1xcdTIwMjgnOiAndTIwMjgnLFxuICAgICdcXHUyMDI5JzogJ3UyMDI5J1xuICB9O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBuYW1lIF9cbiAgICogQGNvbnN0cnVjdG9yXG4gICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcCBpbiBhIGBsb2Rhc2hgIGluc3RhbmNlLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGEgYGxvZGFzaGAgaW5zdGFuY2UuXG4gICAqL1xuICBmdW5jdGlvbiBsb2Rhc2godmFsdWUpIHtcbiAgICAvLyBleGl0IGVhcmx5IGlmIGFscmVhZHkgd3JhcHBlZFxuICAgIGlmICh2YWx1ZSAmJiB2YWx1ZS5fX3dyYXBwZWRfXykge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvLyBhbGxvdyBpbnZva2luZyBgbG9kYXNoYCB3aXRob3V0IHRoZSBgbmV3YCBvcGVyYXRvclxuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBsb2Rhc2gpKSB7XG4gICAgICByZXR1cm4gbmV3IGxvZGFzaCh2YWx1ZSk7XG4gICAgfVxuICAgIHRoaXMuX193cmFwcGVkX18gPSB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBCeSBkZWZhdWx0LCB0aGUgdGVtcGxhdGUgZGVsaW1pdGVycyB1c2VkIGJ5IExvLURhc2ggYXJlIHNpbWlsYXIgdG8gdGhvc2UgaW5cbiAgICogZW1iZWRkZWQgUnVieSAoRVJCKS4gQ2hhbmdlIHRoZSBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlXG4gICAqIGRlbGltaXRlcnMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQHR5cGUgT2JqZWN0XG4gICAqL1xuICBsb2Rhc2gudGVtcGxhdGVTZXR0aW5ncyA9IHtcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gYmUgSFRNTC1lc2NhcGVkLlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgKi9cbiAgICAnZXNjYXBlJzogLzwlLShbXFxzXFxTXSs/KSU+L2csXG5cbiAgICAvKipcbiAgICAgKiBVc2VkIHRvIGRldGVjdCBjb2RlIHRvIGJlIGV2YWx1YXRlZC5cbiAgICAgKlxuICAgICAqIEBzdGF0aWNcbiAgICAgKiBAbWVtYmVyT2YgXy50ZW1wbGF0ZVNldHRpbmdzXG4gICAgICogQHR5cGUgUmVnRXhwXG4gICAgICovXG4gICAgJ2V2YWx1YXRlJzogLzwlKFtcXHNcXFNdKz8pJT4vZyxcblxuICAgIC8qKlxuICAgICAqIFVzZWQgdG8gZGV0ZWN0IGBkYXRhYCBwcm9wZXJ0eSB2YWx1ZXMgdG8gaW5qZWN0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgKiBAdHlwZSBSZWdFeHBcbiAgICAgKi9cbiAgICAnaW50ZXJwb2xhdGUnOiByZUludGVycG9sYXRlLFxuXG4gICAgLyoqXG4gICAgICogVXNlZCB0byByZWZlcmVuY2UgdGhlIGRhdGEgb2JqZWN0IGluIHRoZSB0ZW1wbGF0ZSB0ZXh0LlxuICAgICAqXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBtZW1iZXJPZiBfLnRlbXBsYXRlU2V0dGluZ3NcbiAgICAgKiBAdHlwZSBTdHJpbmdcbiAgICAgKi9cbiAgICAndmFyaWFibGUnOiAnJ1xuICB9O1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBUaGUgdGVtcGxhdGUgdXNlZCB0byBjcmVhdGUgaXRlcmF0b3IgZnVuY3Rpb25zLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge09iZWN0fSBkYXRhIFRoZSBkYXRhIG9iamVjdCB1c2VkIHRvIHBvcHVsYXRlIHRoZSB0ZXh0LlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm5zIHRoZSBpbnRlcnBvbGF0ZWQgdGV4dC5cbiAgICovXG4gIHZhciBpdGVyYXRvclRlbXBsYXRlID0gdGVtcGxhdGUoXG4gICAgLy8gY29uZGl0aW9uYWwgc3RyaWN0IG1vZGVcbiAgICAnPCUgaWYgKG9iai51c2VTdHJpY3QpIHsgJT5cXCd1c2Ugc3RyaWN0XFwnO1xcbjwlIH0gJT4nICtcblxuICAgIC8vIHRoZSBgaXRlcmF0ZWVgIG1heSBiZSByZWFzc2lnbmVkIGJ5IHRoZSBgdG9wYCBzbmlwcGV0XG4gICAgJ3ZhciBpbmRleCwgdmFsdWUsIGl0ZXJhdGVlID0gPCU9IGZpcnN0QXJnICU+LCAnICtcbiAgICAvLyBhc3NpZ24gdGhlIGByZXN1bHRgIHZhcmlhYmxlIGFuIGluaXRpYWwgdmFsdWVcbiAgICAncmVzdWx0ID0gPCU9IGZpcnN0QXJnICU+O1xcbicgK1xuICAgIC8vIGV4aXQgZWFybHkgaWYgdGhlIGZpcnN0IGFyZ3VtZW50IGlzIGZhbHNleVxuICAgICdpZiAoITwlPSBmaXJzdEFyZyAlPikgcmV0dXJuIHJlc3VsdDtcXG4nICtcbiAgICAvLyBhZGQgY29kZSBiZWZvcmUgdGhlIGl0ZXJhdGlvbiBicmFuY2hlc1xuICAgICc8JT0gdG9wICU+O1xcbicgK1xuXG4gICAgLy8gYXJyYXktbGlrZSBpdGVyYXRpb246XG4gICAgJzwlIGlmIChhcnJheUxvb3ApIHsgJT4nICtcbiAgICAndmFyIGxlbmd0aCA9IGl0ZXJhdGVlLmxlbmd0aDsgaW5kZXggPSAtMTtcXG4nICtcbiAgICAnaWYgKHR5cGVvZiBsZW5ndGggPT0gXFwnbnVtYmVyXFwnKSB7JyArXG5cbiAgICAvLyBhZGQgc3VwcG9ydCBmb3IgYWNjZXNzaW5nIHN0cmluZyBjaGFyYWN0ZXJzIGJ5IGluZGV4IGlmIG5lZWRlZFxuICAgICcgIDwlIGlmIChub0NoYXJCeUluZGV4KSB7ICU+XFxuJyArXG4gICAgJyAgaWYgKGlzU3RyaW5nKGl0ZXJhdGVlKSkge1xcbicgK1xuICAgICcgICAgaXRlcmF0ZWUgPSBpdGVyYXRlZS5zcGxpdChcXCdcXCcpXFxuJyArXG4gICAgJyAgfScgK1xuICAgICcgIDwlIH0gJT5cXG4nICtcblxuICAgIC8vIGl0ZXJhdGUgb3ZlciB0aGUgYXJyYXktbGlrZSB2YWx1ZVxuICAgICcgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XFxuJyArXG4gICAgJyAgICB2YWx1ZSA9IGl0ZXJhdGVlW2luZGV4XTtcXG4nICtcbiAgICAnICAgIDwlPSBhcnJheUxvb3AgJT5cXG4nICtcbiAgICAnICB9XFxuJyArXG4gICAgJ31cXG4nICtcbiAgICAnZWxzZSB7JyArXG5cbiAgICAvLyBvYmplY3QgaXRlcmF0aW9uOlxuICAgIC8vIGFkZCBzdXBwb3J0IGZvciBpdGVyYXRpbmcgb3ZlciBgYXJndW1lbnRzYCBvYmplY3RzIGlmIG5lZWRlZFxuICAgICcgIDwlICB9IGVsc2UgaWYgKG5vQXJnc0VudW0pIHsgJT5cXG4nICtcbiAgICAnICB2YXIgbGVuZ3RoID0gaXRlcmF0ZWUubGVuZ3RoOyBpbmRleCA9IC0xO1xcbicgK1xuICAgICcgIGlmIChsZW5ndGggJiYgaXNBcmd1bWVudHMoaXRlcmF0ZWUpKSB7XFxuJyArXG4gICAgJyAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xcbicgK1xuICAgICcgICAgICB2YWx1ZSA9IGl0ZXJhdGVlW2luZGV4ICs9IFxcJ1xcJ107XFxuJyArXG4gICAgJyAgICAgIDwlPSBvYmplY3RMb29wICU+XFxuJyArXG4gICAgJyAgICB9XFxuJyArXG4gICAgJyAgfSBlbHNlIHsnICtcbiAgICAnICA8JSB9ICU+JyArXG5cbiAgICAvLyBGaXJlZm94IDwgMy42LCBPcGVyYSA+IDkuNTAgLSBPcGVyYSA8IDExLjYwLCBhbmQgU2FmYXJpIDwgNS4xXG4gICAgLy8gKGlmIHRoZSBwcm90b3R5cGUgb3IgYSBwcm9wZXJ0eSBvbiB0aGUgcHJvdG90eXBlIGhhcyBiZWVuIHNldClcbiAgICAvLyBpbmNvcnJlY3RseSBzZXRzIGEgZnVuY3Rpb24ncyBgcHJvdG90eXBlYCBwcm9wZXJ0eSBbW0VudW1lcmFibGVdXVxuICAgIC8vIHZhbHVlIHRvIGB0cnVlYC4gQmVjYXVzZSBvZiB0aGlzIExvLURhc2ggc3RhbmRhcmRpemVzIG9uIHNraXBwaW5nXG4gICAgLy8gdGhlIHRoZSBgcHJvdG90eXBlYCBwcm9wZXJ0eSBvZiBmdW5jdGlvbnMgcmVnYXJkbGVzcyBvZiBpdHNcbiAgICAvLyBbW0VudW1lcmFibGVdXSB2YWx1ZS5cbiAgICAnICA8JSBpZiAoIWhhc0RvbnRFbnVtQnVnKSB7ICU+XFxuJyArXG4gICAgJyAgdmFyIHNraXBQcm90byA9IHR5cGVvZiBpdGVyYXRlZSA9PSBcXCdmdW5jdGlvblxcJyAmJiBcXG4nICtcbiAgICAnICAgIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoaXRlcmF0ZWUsIFxcJ3Byb3RvdHlwZVxcJyk7XFxuJyArXG4gICAgJyAgPCUgfSAlPicgK1xuXG4gICAgLy8gaXRlcmF0ZSBvd24gcHJvcGVydGllcyB1c2luZyBgT2JqZWN0LmtleXNgIGlmIGl0J3MgZmFzdFxuICAgICcgIDwlIGlmIChpc0tleXNGYXN0ICYmIHVzZUhhcykgeyAlPlxcbicgK1xuICAgICcgIHZhciBvd25JbmRleCA9IC0xLFxcbicgK1xuICAgICcgICAgICBvd25Qcm9wcyA9IG9iamVjdFR5cGVzW3R5cGVvZiBpdGVyYXRlZV0gPyBuYXRpdmVLZXlzKGl0ZXJhdGVlKSA6IFtdLFxcbicgK1xuICAgICcgICAgICBsZW5ndGggPSBvd25Qcm9wcy5sZW5ndGg7XFxuXFxuJyArXG4gICAgJyAgd2hpbGUgKCsrb3duSW5kZXggPCBsZW5ndGgpIHtcXG4nICtcbiAgICAnICAgIGluZGV4ID0gb3duUHJvcHNbb3duSW5kZXhdO1xcbicgK1xuICAgICcgICAgPCUgaWYgKCFoYXNEb250RW51bUJ1ZykgeyAlPmlmICghKHNraXBQcm90byAmJiBpbmRleCA9PSBcXCdwcm90b3R5cGVcXCcpKSB7XFxuICA8JSB9ICU+JyArXG4gICAgJyAgICB2YWx1ZSA9IGl0ZXJhdGVlW2luZGV4XTtcXG4nICtcbiAgICAnICAgIDwlPSBvYmplY3RMb29wICU+XFxuJyArXG4gICAgJyAgICA8JSBpZiAoIWhhc0RvbnRFbnVtQnVnKSB7ICU+fVxcbjwlIH0gJT4nICtcbiAgICAnICB9JyArXG5cbiAgICAvLyBlbHNlIHVzaW5nIGEgZm9yLWluIGxvb3BcbiAgICAnICA8JSB9IGVsc2UgeyAlPlxcbicgK1xuICAgICcgIGZvciAoaW5kZXggaW4gaXRlcmF0ZWUpIHs8JScgK1xuICAgICcgICAgaWYgKCFoYXNEb250RW51bUJ1ZyB8fCB1c2VIYXMpIHsgJT5cXG4gICAgaWYgKDwlJyArXG4gICAgJyAgICAgIGlmICghaGFzRG9udEVudW1CdWcpIHsgJT4hKHNraXBQcm90byAmJiBpbmRleCA9PSBcXCdwcm90b3R5cGVcXCcpPCUgfScgK1xuICAgICcgICAgICBpZiAoIWhhc0RvbnRFbnVtQnVnICYmIHVzZUhhcykgeyAlPiAmJiA8JSB9JyArXG4gICAgJyAgICAgIGlmICh1c2VIYXMpIHsgJT5oYXNPd25Qcm9wZXJ0eS5jYWxsKGl0ZXJhdGVlLCBpbmRleCk8JSB9JyArXG4gICAgJyAgICAlPikgeycgK1xuICAgICcgICAgPCUgfSAlPlxcbicgK1xuICAgICcgICAgdmFsdWUgPSBpdGVyYXRlZVtpbmRleF07XFxuJyArXG4gICAgJyAgICA8JT0gb2JqZWN0TG9vcCAlPjsnICtcbiAgICAnICAgIDwlIGlmICghaGFzRG9udEVudW1CdWcgfHwgdXNlSGFzKSB7ICU+XFxuICAgIH08JSB9ICU+XFxuJyArXG4gICAgJyAgfScgK1xuICAgICcgIDwlIH0gJT4nICtcblxuICAgIC8vIEJlY2F1c2UgSUUgPCA5IGNhbid0IHNldCB0aGUgYFtbRW51bWVyYWJsZV1dYCBhdHRyaWJ1dGUgb2YgYW5cbiAgICAvLyBleGlzdGluZyBwcm9wZXJ0eSBhbmQgdGhlIGBjb25zdHJ1Y3RvcmAgcHJvcGVydHkgb2YgYSBwcm90b3R5cGVcbiAgICAvLyBkZWZhdWx0cyB0byBub24tZW51bWVyYWJsZSwgTG8tRGFzaCBza2lwcyB0aGUgYGNvbnN0cnVjdG9yYFxuICAgIC8vIHByb3BlcnR5IHdoZW4gaXQgaW5mZXJzIGl0J3MgaXRlcmF0aW5nIG92ZXIgYSBgcHJvdG90eXBlYCBvYmplY3QuXG4gICAgJyAgPCUgaWYgKGhhc0RvbnRFbnVtQnVnKSB7ICU+XFxuXFxuJyArXG4gICAgJyAgdmFyIGN0b3IgPSBpdGVyYXRlZS5jb25zdHJ1Y3RvcjtcXG4nICtcbiAgICAnICAgIDwlIGZvciAodmFyIGsgPSAwOyBrIDwgNzsgaysrKSB7ICU+XFxuJyArXG4gICAgJyAgaW5kZXggPSBcXCc8JT0gc2hhZG93ZWRba10gJT5cXCc7XFxuJyArXG4gICAgJyAgaWYgKDwlJyArXG4gICAgJyAgICAgIGlmIChzaGFkb3dlZFtrXSA9PSBcXCdjb25zdHJ1Y3RvclxcJykgeycgK1xuICAgICcgICAgICAgICU+IShjdG9yICYmIGN0b3IucHJvdG90eXBlID09PSBpdGVyYXRlZSkgJiYgPCUnICtcbiAgICAnICAgICAgfSAlPmhhc093blByb3BlcnR5LmNhbGwoaXRlcmF0ZWUsIGluZGV4KSkge1xcbicgK1xuICAgICcgICAgdmFsdWUgPSBpdGVyYXRlZVtpbmRleF07XFxuJyArXG4gICAgJyAgICA8JT0gb2JqZWN0TG9vcCAlPlxcbicgK1xuICAgICcgIH0nICtcbiAgICAnICAgIDwlIH0gJT4nICtcbiAgICAnICA8JSB9ICU+JyArXG4gICAgJyAgPCUgaWYgKGFycmF5TG9vcCB8fCBub0FyZ3NFbnVtKSB7ICU+XFxufTwlIH0gJT5cXG4nICtcblxuICAgIC8vIGFkZCBjb2RlIHRvIHRoZSBib3R0b20gb2YgdGhlIGl0ZXJhdGlvbiBmdW5jdGlvblxuICAgICc8JT0gYm90dG9tICU+O1xcbicgK1xuICAgIC8vIGZpbmFsbHksIHJldHVybiB0aGUgYHJlc3VsdGBcbiAgICAncmV0dXJuIHJlc3VsdCdcbiAgKTtcblxuICAvKipcbiAgICogUmV1c2FibGUgaXRlcmF0b3Igb3B0aW9ucyBzaGFyZWQgYnkgYGZvckVhY2hgLCBgZm9ySW5gLCBhbmQgYGZvck93bmAuXG4gICAqL1xuICB2YXIgZm9yRWFjaEl0ZXJhdG9yT3B0aW9ucyA9IHtcbiAgICAnYXJncyc6ICdjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZycsXG4gICAgJ3RvcCc6ICdjYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKScsXG4gICAgJ2FycmF5TG9vcCc6ICdpZiAoY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSA9PT0gZmFsc2UpIHJldHVybiByZXN1bHQnLFxuICAgICdvYmplY3RMb29wJzogJ2lmIChjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pID09PSBmYWxzZSkgcmV0dXJuIHJlc3VsdCdcbiAgfTtcblxuICAvKiogUmV1c2FibGUgaXRlcmF0b3Igb3B0aW9ucyBmb3IgYGRlZmF1bHRzYCwgYW5kIGBleHRlbmRgICovXG4gIHZhciBleHRlbmRJdGVyYXRvck9wdGlvbnMgPSB7XG4gICAgJ3VzZUhhcyc6IGZhbHNlLFxuICAgICdhcmdzJzogJ29iamVjdCcsXG4gICAgJ3RvcCc6XG4gICAgICAnZm9yICh2YXIgYXJnc0luZGV4ID0gMSwgYXJnc0xlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7IGFyZ3NJbmRleCA8IGFyZ3NMZW5ndGg7IGFyZ3NJbmRleCsrKSB7XFxuJyArXG4gICAgICAnICBpZiAoaXRlcmF0ZWUgPSBhcmd1bWVudHNbYXJnc0luZGV4XSkgeycsXG4gICAgJ29iamVjdExvb3AnOiAncmVzdWx0W2luZGV4XSA9IHZhbHVlJyxcbiAgICAnYm90dG9tJzogJyAgfVxcbn0nXG4gIH07XG5cbiAgLyoqIFJldXNhYmxlIGl0ZXJhdG9yIG9wdGlvbnMgZm9yIGBmb3JJbmAgYW5kIGBmb3JPd25gICovXG4gIHZhciBmb3JPd25JdGVyYXRvck9wdGlvbnMgPSB7XG4gICAgJ2FycmF5TG9vcCc6IG51bGxcbiAgfTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIG9wdGltaXplZCB0byBzZWFyY2ggbGFyZ2UgYXJyYXlzIGZvciBhIGdpdmVuIGB2YWx1ZWAsXG4gICAqIHN0YXJ0aW5nIGF0IGBmcm9tSW5kZXhgLCB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXg9MF0gVGhlIGluZGV4IHRvIHNlYXJjaCBmcm9tLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW2xhcmdlU2l6ZT0zMF0gVGhlIGxlbmd0aCBhdCB3aGljaCBhbiBhcnJheSBpcyBjb25zaWRlcmVkIGxhcmdlLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBmb3VuZCwgZWxzZSBgZmFsc2VgLlxuICAgKi9cbiAgZnVuY3Rpb24gY2FjaGVkQ29udGFpbnMoYXJyYXksIGZyb21JbmRleCwgbGFyZ2VTaXplKSB7XG4gICAgZnJvbUluZGV4IHx8IChmcm9tSW5kZXggPSAwKTtcblxuICAgIHZhciBsZW5ndGggPSBhcnJheS5sZW5ndGgsXG4gICAgICAgIGlzTGFyZ2UgPSAobGVuZ3RoIC0gZnJvbUluZGV4KSA+PSAobGFyZ2VTaXplIHx8IGxhcmdlQXJyYXlTaXplKTtcblxuICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICB2YXIgY2FjaGUgPSB7fSxcbiAgICAgICAgICBpbmRleCA9IGZyb21JbmRleCAtIDE7XG5cbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIC8vIG1hbnVhbGx5IGNvZXJjZSBgdmFsdWVgIHRvIGEgc3RyaW5nIGJlY2F1c2UgYGhhc093blByb3BlcnR5YCwgaW4gc29tZVxuICAgICAgICAvLyBvbGRlciB2ZXJzaW9ucyBvZiBGaXJlZm94LCBjb2VyY2VzIG9iamVjdHMgaW5jb3JyZWN0bHlcbiAgICAgICAgdmFyIGtleSA9IGFycmF5W2luZGV4XSArICcnO1xuICAgICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChjYWNoZSwga2V5KSA/IGNhY2hlW2tleV0gOiAoY2FjaGVba2V5XSA9IFtdKSkucHVzaChhcnJheVtpbmRleF0pO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICAgIHZhciBrZXkgPSB2YWx1ZSArICcnO1xuICAgICAgICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChjYWNoZSwga2V5KSAmJiBpbmRleE9mKGNhY2hlW2tleV0sIHZhbHVlKSA+IC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpID4gLTE7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYF8ubWF4YCBhbmQgYF8ubWluYCBhcyB0aGUgZGVmYXVsdCBgY2FsbGJhY2tgIHdoZW4gYSBnaXZlblxuICAgKiBgY29sbGVjdGlvbmAgaXMgYSBzdHJpbmcgdmFsdWUuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSB2YWx1ZSBUaGUgY2hhcmFjdGVyIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgdGhlIGNvZGUgdW5pdCBvZiBnaXZlbiBjaGFyYWN0ZXIuXG4gICAqL1xuICBmdW5jdGlvbiBjaGFyQXRDYWxsYmFjayh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZS5jaGFyQ29kZUF0KDApO1xuICB9XG5cbiAgLyoqXG4gICAqIFVzZWQgYnkgYHNvcnRCeWAgdG8gY29tcGFyZSB0cmFuc2Zvcm1lZCBgY29sbGVjdGlvbmAgdmFsdWVzLCBzdGFibGUgc29ydGluZ1xuICAgKiB0aGVtIGluIGFzY2VuZGluZyBvcmRlci5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IGEgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBiYC5cbiAgICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb21wYXJlIHRvIGBhYC5cbiAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyB0aGUgc29ydCBvcmRlciBpbmRpY2F0b3Igb2YgYDFgIG9yIGAtMWAuXG4gICAqL1xuICBmdW5jdGlvbiBjb21wYXJlQXNjZW5kaW5nKGEsIGIpIHtcbiAgICB2YXIgYWkgPSBhLmluZGV4LFxuICAgICAgICBiaSA9IGIuaW5kZXg7XG5cbiAgICBhID0gYS5jcml0ZXJpYTtcbiAgICBiID0gYi5jcml0ZXJpYTtcblxuICAgIC8vIGVuc3VyZSBhIHN0YWJsZSBzb3J0IGluIFY4IGFuZCBvdGhlciBlbmdpbmVzXG4gICAgLy8gaHR0cDovL2NvZGUuZ29vZ2xlLmNvbS9wL3Y4L2lzc3Vlcy9kZXRhaWw/aWQ9OTBcbiAgICBpZiAoYSAhPT0gYikge1xuICAgICAgaWYgKGEgPiBiIHx8IGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICByZXR1cm4gMTtcbiAgICAgIH1cbiAgICAgIGlmIChhIDwgYiB8fCBiID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gYWkgPCBiaSA/IC0xIDogMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYFxuICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgcHJlcGVuZHMgYW55IGBwYXJ0YWlsQXJnc2AgdG8gdGhlIGFyZ3VtZW50cyBwYXNzZWRcbiAgICogdG8gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZCBvciB0aGUgbWV0aG9kIG5hbWUuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGZ1bmNgLlxuICAgKiBAcGFyYW0ge0FycmF5fSBwYXJ0aWFsQXJncyBBbiBhcnJheSBvZiBhcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgKi9cbiAgZnVuY3Rpb24gY3JlYXRlQm91bmQoZnVuYywgdGhpc0FyZywgcGFydGlhbEFyZ3MpIHtcbiAgICB2YXIgaXNGdW5jID0gaXNGdW5jdGlvbihmdW5jKSxcbiAgICAgICAgaXNQYXJ0aWFsID0gIXBhcnRpYWxBcmdzLFxuICAgICAgICBtZXRob2ROYW1lID0gZnVuYztcblxuICAgIC8vIGp1Z2dsZSBhcmd1bWVudHNcbiAgICBpZiAoaXNQYXJ0aWFsKSB7XG4gICAgICBwYXJ0aWFsQXJncyA9IHRoaXNBcmc7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYm91bmQoKSB7XG4gICAgICAvLyBgRnVuY3Rpb24jYmluZGAgc3BlY1xuICAgICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMy40LjVcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIHRoaXNCaW5kaW5nID0gaXNQYXJ0aWFsID8gdGhpcyA6IHRoaXNBcmc7XG5cbiAgICAgIGlmICghaXNGdW5jKSB7XG4gICAgICAgIGZ1bmMgPSB0aGlzQXJnW21ldGhvZE5hbWVdO1xuICAgICAgfVxuICAgICAgaWYgKHBhcnRpYWxBcmdzLmxlbmd0aCkge1xuICAgICAgICBhcmdzID0gYXJncy5sZW5ndGhcbiAgICAgICAgICA/IHBhcnRpYWxBcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3MpKVxuICAgICAgICAgIDogcGFydGlhbEFyZ3M7XG4gICAgICB9XG4gICAgICBpZiAodGhpcyBpbnN0YW5jZW9mIGJvdW5kKSB7XG4gICAgICAgIC8vIGdldCBgZnVuY2AgaW5zdGFuY2UgaWYgYGJvdW5kYCBpcyBpbnZva2VkIGluIGEgYG5ld2AgZXhwcmVzc2lvblxuICAgICAgICBub29wLnByb3RvdHlwZSA9IGZ1bmMucHJvdG90eXBlO1xuICAgICAgICB0aGlzQmluZGluZyA9IG5ldyBub29wO1xuXG4gICAgICAgIC8vIG1pbWljIHRoZSBjb25zdHJ1Y3RvcidzIGByZXR1cm5gIGJlaGF2aW9yXG4gICAgICAgIC8vIGh0dHA6Ly9lczUuZ2l0aHViLmNvbS8jeDEzLjIuMlxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgICAgIHJldHVybiBpc09iamVjdChyZXN1bHQpXG4gICAgICAgICAgPyByZXN1bHRcbiAgICAgICAgICA6IHRoaXNCaW5kaW5nXG4gICAgICB9XG4gICAgICByZXR1cm4gZnVuYy5hcHBseSh0aGlzQmluZGluZywgYXJncyk7XG4gICAgfVxuICAgIHJldHVybiBib3VuZDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhbiBpdGVyYXRpb24gY2FsbGJhY2sgYm91bmQgdG8gYW4gb3B0aW9uYWwgYHRoaXNBcmdgLiBJZiBgZnVuY2AgaXNcbiAgICogYSBwcm9wZXJ0eSBuYW1lLCB0aGUgY2FsbGJhY2sgd2lsbCByZXR1cm4gdGhlIHByb3BlcnR5IHZhbHVlIGZvciBhIGdpdmVuIGVsZW1lbnQuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBbZnVuYz1pZGVudGl0eXxwcm9wZXJ0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXJcbiAgICogaXRlcmF0aW9uIG9yIHByb3BlcnR5IG5hbWUgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIGEgY2FsbGJhY2sgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVDYWxsYmFjayhmdW5jLCB0aGlzQXJnKSB7XG4gICAgaWYgKCFmdW5jKSB7XG4gICAgICByZXR1cm4gaWRlbnRpdHk7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgZnVuYyAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24ob2JqZWN0KSB7XG4gICAgICAgIHJldHVybiBvYmplY3RbZnVuY107XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpc0FyZyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gZnVuY3Rpb24odmFsdWUsIGluZGV4LCBvYmplY3QpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbCh0aGlzQXJnLCB2YWx1ZSwgaW5kZXgsIG9iamVjdCk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gZnVuYztcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGNvbXBpbGVkIGl0ZXJhdGlvbiBmdW5jdGlvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uczEsIG9wdGlvbnMyLCAuLi5dIFRoZSBjb21waWxlIG9wdGlvbnMgb2JqZWN0KHMpLlxuICAgKiAgdXNlSGFzIC0gQSBib29sZWFuIHRvIHNwZWNpZnkgdXNpbmcgYGhhc093blByb3BlcnR5YCBjaGVja3MgaW4gdGhlIG9iamVjdCBsb29wLlxuICAgKiAgYXJncyAtIEEgc3RyaW5nIG9mIGNvbW1hIHNlcGFyYXRlZCBhcmd1bWVudHMgdGhlIGl0ZXJhdGlvbiBmdW5jdGlvbiB3aWxsIGFjY2VwdC5cbiAgICogIHRvcCAtIEEgc3RyaW5nIG9mIGNvZGUgdG8gZXhlY3V0ZSBiZWZvcmUgdGhlIGl0ZXJhdGlvbiBicmFuY2hlcy5cbiAgICogIGFycmF5TG9vcCAtIEEgc3RyaW5nIG9mIGNvZGUgdG8gZXhlY3V0ZSBpbiB0aGUgYXJyYXkgbG9vcC5cbiAgICogIG9iamVjdExvb3AgLSBBIHN0cmluZyBvZiBjb2RlIHRvIGV4ZWN1dGUgaW4gdGhlIG9iamVjdCBsb29wLlxuICAgKiAgYm90dG9tIC0gQSBzdHJpbmcgb2YgY29kZSB0byBleGVjdXRlIGFmdGVyIHRoZSBpdGVyYXRpb24gYnJhbmNoZXMuXG4gICAqXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgY29tcGlsZWQgZnVuY3Rpb24uXG4gICAqL1xuICBmdW5jdGlvbiBjcmVhdGVJdGVyYXRvcigpIHtcbiAgICB2YXIgZGF0YSA9IHtcbiAgICAgICdhcnJheUxvb3AnOiAnJyxcbiAgICAgICdib3R0b20nOiAnJyxcbiAgICAgICdoYXNEb250RW51bUJ1Zyc6IGhhc0RvbnRFbnVtQnVnLFxuICAgICAgJ2lzS2V5c0Zhc3QnOiBpc0tleXNGYXN0LFxuICAgICAgJ29iamVjdExvb3AnOiAnJyxcbiAgICAgICdub0FyZ3NFbnVtJzogbm9BcmdzRW51bSxcbiAgICAgICdub0NoYXJCeUluZGV4Jzogbm9DaGFyQnlJbmRleCxcbiAgICAgICdzaGFkb3dlZCc6IHNoYWRvd2VkLFxuICAgICAgJ3RvcCc6ICcnLFxuICAgICAgJ3VzZUhhcyc6IHRydWVcbiAgICB9O1xuXG4gICAgLy8gbWVyZ2Ugb3B0aW9ucyBpbnRvIGEgdGVtcGxhdGUgZGF0YSBvYmplY3RcbiAgICBmb3IgKHZhciBvYmplY3QsIGluZGV4ID0gMDsgb2JqZWN0ID0gYXJndW1lbnRzW2luZGV4XTsgaW5kZXgrKykge1xuICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xuICAgICAgICBkYXRhW2tleV0gPSBvYmplY3Rba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGFyZ3MgPSBkYXRhLmFyZ3M7XG4gICAgZGF0YS5maXJzdEFyZyA9IC9eW14sXSsvLmV4ZWMoYXJncylbMF07XG5cbiAgICAvLyBjcmVhdGUgdGhlIGZ1bmN0aW9uIGZhY3RvcnlcbiAgICB2YXIgZmFjdG9yeSA9IEZ1bmN0aW9uKFxuICAgICAgICAnY3JlYXRlQ2FsbGJhY2ssIGhhc093blByb3BlcnR5LCBpc0FyZ3VtZW50cywgaXNTdHJpbmcsIG9iamVjdFR5cGVzLCAnICtcbiAgICAgICAgJ25hdGl2ZUtleXMsIHByb3BlcnR5SXNFbnVtZXJhYmxlJyxcbiAgICAgICdyZXR1cm4gZnVuY3Rpb24oJyArIGFyZ3MgKyAnKSB7XFxuJyArIGl0ZXJhdG9yVGVtcGxhdGUoZGF0YSkgKyAnXFxufSdcbiAgICApO1xuICAgIC8vIHJldHVybiB0aGUgY29tcGlsZWQgZnVuY3Rpb25cbiAgICByZXR1cm4gZmFjdG9yeShcbiAgICAgIGNyZWF0ZUNhbGxiYWNrLCBoYXNPd25Qcm9wZXJ0eSwgaXNBcmd1bWVudHMsIGlzU3RyaW5nLCBvYmplY3RUeXBlcyxcbiAgICAgIG5hdGl2ZUtleXMsIHByb3BlcnR5SXNFbnVtZXJhYmxlXG4gICAgKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBVc2VkIGJ5IGB0ZW1wbGF0ZWAgdG8gZXNjYXBlIGNoYXJhY3RlcnMgZm9yIGluY2x1c2lvbiBpbiBjb21waWxlZFxuICAgKiBzdHJpbmcgbGl0ZXJhbHMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBtYXRjaCBUaGUgbWF0Y2hlZCBjaGFyYWN0ZXIgdG8gZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm5zIHRoZSBlc2NhcGVkIGNoYXJhY3Rlci5cbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZVN0cmluZ0NoYXIobWF0Y2gpIHtcbiAgICByZXR1cm4gJ1xcXFwnICsgc3RyaW5nRXNjYXBlc1ttYXRjaF07XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgZXNjYXBlYCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtTdHJpbmd9IG1hdGNoIFRoZSBtYXRjaGVkIGNoYXJhY3RlciB0byBlc2NhcGUuXG4gICAqIEByZXR1cm5zIHtTdHJpbmd9IFJldHVybnMgdGhlIGVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gZXNjYXBlSHRtbENoYXIobWF0Y2gpIHtcbiAgICByZXR1cm4gaHRtbEVzY2FwZXNbbWF0Y2hdO1xuICB9XG5cbiAgLyoqXG4gICAqIEEgbm8tb3BlcmF0aW9uIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKi9cbiAgZnVuY3Rpb24gbm9vcCgpIHtcbiAgICAvLyBubyBvcGVyYXRpb24gcGVyZm9ybWVkXG4gIH1cblxuICAvKipcbiAgICogVXNlZCBieSBgdW5lc2NhcGVgIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAcHJpdmF0ZVxuICAgKiBAcGFyYW0ge1N0cmluZ30gbWF0Y2ggVGhlIG1hdGNoZWQgY2hhcmFjdGVyIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgY2hhcmFjdGVyLlxuICAgKi9cbiAgZnVuY3Rpb24gdW5lc2NhcGVIdG1sQ2hhcihtYXRjaCkge1xuICAgIHJldHVybiBodG1sVW5lc2NhcGVzW21hdGNoXTtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhbiBgYXJndW1lbnRzYCBvYmplY3QuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gYGFyZ3VtZW50c2Agb2JqZWN0LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIChmdW5jdGlvbigpIHsgcmV0dXJuIF8uaXNBcmd1bWVudHMoYXJndW1lbnRzKTsgfSkoMSwgMiwgMyk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0FyZ3VtZW50cyhbMSwgMiwgM10pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNBcmd1bWVudHModmFsdWUpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJnc0NsYXNzO1xuICB9XG4gIC8vIGZhbGxiYWNrIGZvciBicm93c2VycyB0aGF0IGNhbid0IGRldGVjdCBgYXJndW1lbnRzYCBvYmplY3RzIGJ5IFtbQ2xhc3NdXVxuICBpZiAobm9BcmdzQ2xhc3MpIHtcbiAgICBpc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWUgPyBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCAnY2FsbGVlJykgOiBmYWxzZTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgYG9iamVjdGAncyBvd24gYW5kIGluaGVyaXRlZCBlbnVtZXJhYmxlIHByb3BlcnRpZXMsIGV4ZWN1dGluZ1xuICAgKiB0aGUgYGNhbGxiYWNrYCBmb3IgZWFjaCBwcm9wZXJ0eS4gVGhlIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZFxuICAgKiBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS4gQ2FsbGJhY2tzIG1heSBleGl0IGl0ZXJhdGlvblxuICAgKiBlYXJseSBieSBleHBsaWNpdGx5IHJldHVybmluZyBgZmFsc2VgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIGBvYmplY3RgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBmdW5jdGlvbiBEb2cobmFtZSkge1xuICAgKiAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAqIH1cbiAgICpcbiAgICogRG9nLnByb3RvdHlwZS5iYXJrID0gZnVuY3Rpb24oKSB7XG4gICAqICAgYWxlcnQoJ1dvb2YsIHdvb2YhJyk7XG4gICAqIH07XG4gICAqXG4gICAqIF8uZm9ySW4obmV3IERvZygnRGFnbnknKSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgKiAgIGFsZXJ0KGtleSk7XG4gICAqIH0pO1xuICAgKiAvLyA9PiBhbGVydHMgJ25hbWUnIGFuZCAnYmFyaycgKG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgKi9cbiAgdmFyIGZvckluID0gY3JlYXRlSXRlcmF0b3IoZm9yRWFjaEl0ZXJhdG9yT3B0aW9ucywgZm9yT3duSXRlcmF0b3JPcHRpb25zLCB7XG4gICAgJ3VzZUhhcyc6IGZhbHNlXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBJdGVyYXRlcyBvdmVyIGBvYmplY3RgJ3Mgb3duIGVudW1lcmFibGUgcHJvcGVydGllcywgZXhlY3V0aW5nIHRoZSBgY2FsbGJhY2tgXG4gICAqIGZvciBlYWNoIHByb3BlcnR5LiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwga2V5LCBvYmplY3QpLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5IGJ5IGV4cGxpY2l0bHlcbiAgICogcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgYG9iamVjdGAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uZm9yT3duKHsgJzAnOiAnemVybycsICcxJzogJ29uZScsICdsZW5ndGgnOiAyIH0sIGZ1bmN0aW9uKG51bSwga2V5KSB7XG4gICAqICAgYWxlcnQoa2V5KTtcbiAgICogfSk7XG4gICAqIC8vID0+IGFsZXJ0cyAnMCcsICcxJywgYW5kICdsZW5ndGgnIChvcmRlciBpcyBub3QgZ3VhcmFudGVlZClcbiAgICovXG4gIHZhciBmb3JPd24gPSBjcmVhdGVJdGVyYXRvcihmb3JFYWNoSXRlcmF0b3JPcHRpb25zLCBmb3JPd25JdGVyYXRvck9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBBIGZhbGxiYWNrIGltcGxlbWVudGF0aW9uIG9mIGBpc1BsYWluT2JqZWN0YCB0aGF0IGNoZWNrcyBpZiBhIGdpdmVuIGB2YWx1ZWBcbiAgICogaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLCBhc3N1bWluZyBvYmplY3RzIGNyZWF0ZWRcbiAgICogYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yIGhhdmUgbm8gaW5oZXJpdGVkIGVudW1lcmFibGUgcHJvcGVydGllcyBhbmQgdGhhdFxuICAgKiB0aGVyZSBhcmUgbm8gYE9iamVjdC5wcm90b3R5cGVgIGV4dGVuc2lvbnMuXG4gICAqXG4gICAqIEBwcml2YXRlXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICovXG4gIGZ1bmN0aW9uIHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKSB7XG4gICAgLy8gYXZvaWQgbm9uLW9iamVjdHMgYW5kIGZhbHNlIHBvc2l0aXZlcyBmb3IgYGFyZ3VtZW50c2Agb2JqZWN0c1xuICAgIHZhciByZXN1bHQgPSBmYWxzZTtcbiAgICBpZiAoISh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCcpIHx8IGlzQXJndW1lbnRzKHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgLy8gSUUgPCA5IHByZXNlbnRzIERPTSBub2RlcyBhcyBgT2JqZWN0YCBvYmplY3RzIGV4Y2VwdCB0aGV5IGhhdmUgYHRvU3RyaW5nYFxuICAgIC8vIG1ldGhvZHMgdGhhdCBhcmUgYHR5cGVvZmAgXCJzdHJpbmdcIiBhbmQgc3RpbGwgY2FuIGNvZXJjZSBub2RlcyB0byBzdHJpbmdzLlxuICAgIC8vIEFsc28gY2hlY2sgdGhhdCB0aGUgY29uc3RydWN0b3IgaXMgYE9iamVjdGAgKGkuZS4gYE9iamVjdCBpbnN0YW5jZW9mIE9iamVjdGApXG4gICAgdmFyIGN0b3IgPSB2YWx1ZS5jb25zdHJ1Y3RvcjtcbiAgICBpZiAoKCFub05vZGVDbGFzcyB8fCAhKHR5cGVvZiB2YWx1ZS50b1N0cmluZyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiAodmFsdWUgKyAnJykgPT0gJ3N0cmluZycpKSAmJlxuICAgICAgICAoIWlzRnVuY3Rpb24oY3RvcikgfHwgY3RvciBpbnN0YW5jZW9mIGN0b3IpKSB7XG4gICAgICAvLyBJRSA8IDkgaXRlcmF0ZXMgaW5oZXJpdGVkIHByb3BlcnRpZXMgYmVmb3JlIG93biBwcm9wZXJ0aWVzLiBJZiB0aGUgZmlyc3RcbiAgICAgIC8vIGl0ZXJhdGVkIHByb3BlcnR5IGlzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWRcbiAgICAgIC8vIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICAgIGlmIChpdGVyYXRlc093bkxhc3QpIHtcbiAgICAgICAgZm9ySW4odmFsdWUsIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iamVjdCkge1xuICAgICAgICAgIHJlc3VsdCA9ICFoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KTtcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0ID09PSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIC8vIEluIG1vc3QgZW52aXJvbm1lbnRzIGFuIG9iamVjdCdzIG93biBwcm9wZXJ0aWVzIGFyZSBpdGVyYXRlZCBiZWZvcmVcbiAgICAgIC8vIGl0cyBpbmhlcml0ZWQgcHJvcGVydGllcy4gSWYgdGhlIGxhc3QgaXRlcmF0ZWQgcHJvcGVydHkgaXMgYW4gb2JqZWN0J3NcbiAgICAgIC8vIG93biBwcm9wZXJ0eSB0aGVuIHRoZXJlIGFyZSBubyBpbmhlcml0ZWQgZW51bWVyYWJsZSBwcm9wZXJ0aWVzLlxuICAgICAgZm9ySW4odmFsdWUsIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmVzdWx0ID0ga2V5O1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0ID09PSBmYWxzZSB8fCBoYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlLCByZXN1bHQpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEEgZmFsbGJhY2sgaW1wbGVtZW50YXRpb24gb2YgYE9iamVjdC5rZXlzYCB0aGF0IHByb2R1Y2VzIGFuIGFycmF5IG9mIHRoZVxuICAgKiBnaXZlbiBvYmplY3QncyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSBuYW1lcy5cbiAgICpcbiAgICogQHByaXZhdGVcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICovXG4gIGZ1bmN0aW9uIHNoaW1LZXlzKG9iamVjdCkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHQucHVzaChrZXkpO1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCB0byBjb252ZXJ0IGNoYXJhY3RlcnMgdG8gSFRNTCBlbnRpdGllczpcbiAgICpcbiAgICogVGhvdWdoIHRoZSBgPmAgY2hhcmFjdGVyIGlzIGVzY2FwZWQgZm9yIHN5bW1ldHJ5LCBjaGFyYWN0ZXJzIGxpa2UgYD5gIGFuZCBgL2BcbiAgICogZG9uJ3QgcmVxdWlyZSBlc2NhcGluZyBpbiBIVE1MIGFuZCBoYXZlIG5vIHNwZWNpYWwgbWVhbmluZyB1bmxlc3MgdGhleSdyZSBwYXJ0XG4gICAqIG9mIGEgdGFnIG9yIGFuIHVucXVvdGVkIGF0dHJpYnV0ZSB2YWx1ZS5cbiAgICogaHR0cDovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvYW1iaWd1b3VzLWFtcGVyc2FuZHMgKHVuZGVyIFwic2VtaS1yZWxhdGVkIGZ1biBmYWN0XCIpXG4gICAqL1xuICB2YXIgaHRtbEVzY2FwZXMgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7J1xuICB9O1xuXG4gIC8qKiBVc2VkIHRvIGNvbnZlcnQgSFRNTCBlbnRpdGllcyB0byBjaGFyYWN0ZXJzICovXG4gIHZhciBodG1sVW5lc2NhcGVzID0gaW52ZXJ0KGh0bWxFc2NhcGVzKTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGNsb25lIG9mIGB2YWx1ZWAuIElmIGBkZWVwYCBpcyBgdHJ1ZWAsIGFsbCBuZXN0ZWQgb2JqZWN0cyB3aWxsXG4gICAqIGFsc28gYmUgY2xvbmVkIG90aGVyd2lzZSB0aGV5IHdpbGwgYmUgYXNzaWduZWQgYnkgcmVmZXJlbmNlLiBGdW5jdGlvbnMsIERPTVxuICAgKiBub2RlcywgYGFyZ3VtZW50c2Agb2JqZWN0cywgYW5kIG9iamVjdHMgY3JlYXRlZCBieSBjb25zdHJ1Y3RvcnMgb3RoZXIgdGhhblxuICAgKiBgT2JqZWN0YCBhcmUgKipub3QqKiBjbG9uZWQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNsb25lLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW59IGRlZXAgQSBmbGFnIHRvIGluZGljYXRlIGEgZGVlcCBjbG9uZS5cbiAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEludGVybmFsbHkgdXNlZCB0byBhbGxvdyB0aGlzIG1ldGhvZCB0byB3b3JrIHdpdGhcbiAgICogIG90aGVycyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZyB0aGVpciBjYWxsYmFjayBgaW5kZXhgIGFyZ3VtZW50IGZvciBgZGVlcGAuXG4gICAqIEBwYXJhbS0ge0FycmF5fSBbc3RhY2tBPVtdXSBJbnRlcm5hbGx5IHVzZWQgdG8gdHJhY2sgdHJhdmVyc2VkIHNvdXJjZSBvYmplY3RzLlxuICAgKiBAcGFyYW0tIHtBcnJheX0gW3N0YWNrQj1bXV0gSW50ZXJuYWxseSB1c2VkIHRvIGFzc29jaWF0ZSBjbG9uZXMgd2l0aCB0aGVpclxuICAgKiAgc291cmNlIGNvdW50ZXJwYXJ0cy5cbiAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSBjbG9uZWQgYHZhbHVlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHN0b29nZXMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAgfSxcbiAgICogICB7ICduYW1lJzogJ2xhcnJ5JywgJ2FnZSc6IDUwIH0sXG4gICAqICAgeyAnbmFtZSc6ICdjdXJseScsICdhZ2UnOiA2MCB9XG4gICAqIF07XG4gICAqXG4gICAqIF8uY2xvbmUoeyAnbmFtZSc6ICdtb2UnIH0pO1xuICAgKiAvLyA9PiB7ICduYW1lJzogJ21vZScgfVxuICAgKlxuICAgKiB2YXIgc2hhbGxvdyA9IF8uY2xvbmUoc3Rvb2dlcyk7XG4gICAqIHNoYWxsb3dbMF0gPT09IHN0b29nZXNbMF07XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogdmFyIGRlZXAgPSBfLmNsb25lKHN0b29nZXMsIHRydWUpO1xuICAgKiBzaGFsbG93WzBdID09PSBzdG9vZ2VzWzBdO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gY2xvbmUodmFsdWUsIGRlZXAsIGd1YXJkLCBzdGFja0EsIHN0YWNrQikge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGlmIChndWFyZCkge1xuICAgICAgZGVlcCA9IGZhbHNlO1xuICAgIH1cbiAgICAvLyBpbnNwZWN0IFtbQ2xhc3NdXVxuICAgIHZhciBpc09iaiA9IGlzT2JqZWN0KHZhbHVlKTtcbiAgICBpZiAoaXNPYmopIHtcbiAgICAgIC8vIGRvbid0IGNsb25lIGBhcmd1bWVudHNgIG9iamVjdHMsIGZ1bmN0aW9ucywgb3Igbm9uLW9iamVjdCBPYmplY3RzXG4gICAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG4gICAgICBpZiAoIWNsb25lYWJsZUNsYXNzZXNbY2xhc3NOYW1lXSB8fCAobm9BcmdzQ2xhc3MgJiYgaXNBcmd1bWVudHModmFsdWUpKSkge1xuICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICB9XG4gICAgICB2YXIgaXNBcnIgPSBjbGFzc05hbWUgPT0gYXJyYXlDbGFzcztcbiAgICAgIGlzT2JqID0gaXNBcnIgfHwgKGNsYXNzTmFtZSA9PSBvYmplY3RDbGFzcyA/IGlzUGxhaW5PYmplY3QodmFsdWUpIDogaXNPYmopO1xuICAgIH1cbiAgICAvLyBzaGFsbG93IGNsb25lXG4gICAgaWYgKCFpc09iaiB8fCAhZGVlcCkge1xuICAgICAgLy8gZG9uJ3QgY2xvbmUgZnVuY3Rpb25zXG4gICAgICByZXR1cm4gaXNPYmpcbiAgICAgICAgPyAoaXNBcnIgPyBzbGljZS5jYWxsKHZhbHVlKSA6IGV4dGVuZCh7fSwgdmFsdWUpKVxuICAgICAgICA6IHZhbHVlO1xuICAgIH1cblxuICAgIHZhciBjdG9yID0gdmFsdWUuY29uc3RydWN0b3I7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIGNhc2UgYm9vbENsYXNzOlxuICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgIHJldHVybiBuZXcgY3RvcigrdmFsdWUpO1xuXG4gICAgICBjYXNlIG51bWJlckNsYXNzOlxuICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgcmV0dXJuIG5ldyBjdG9yKHZhbHVlKTtcblxuICAgICAgY2FzZSByZWdleHBDbGFzczpcbiAgICAgICAgcmV0dXJuIGN0b3IodmFsdWUuc291cmNlLCByZUZsYWdzLmV4ZWModmFsdWUpKTtcbiAgICB9XG4gICAgLy8gY2hlY2sgZm9yIGNpcmN1bGFyIHJlZmVyZW5jZXMgYW5kIHJldHVybiBjb3JyZXNwb25kaW5nIGNsb25lXG4gICAgc3RhY2tBIHx8IChzdGFja0EgPSBbXSk7XG4gICAgc3RhY2tCIHx8IChzdGFja0IgPSBbXSk7XG5cbiAgICB2YXIgbGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgIGlmIChzdGFja0FbbGVuZ3RoXSA9PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gc3RhY2tCW2xlbmd0aF07XG4gICAgICB9XG4gICAgfVxuICAgIC8vIGluaXQgY2xvbmVkIG9iamVjdFxuICAgIHZhciByZXN1bHQgPSBpc0FyciA/IGN0b3IodmFsdWUubGVuZ3RoKSA6IHt9O1xuXG4gICAgLy8gYWRkIHRoZSBzb3VyY2UgdmFsdWUgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgLy8gYW5kIGFzc29jaWF0ZSBpdCB3aXRoIGl0cyBjbG9uZVxuICAgIHN0YWNrQS5wdXNoKHZhbHVlKTtcbiAgICBzdGFja0IucHVzaChyZXN1bHQpO1xuXG4gICAgLy8gcmVjdXJzaXZlbHkgcG9wdWxhdGUgY2xvbmUgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgIChpc0FyciA/IGZvckVhY2ggOiBmb3JPd24pKHZhbHVlLCBmdW5jdGlvbihvYmpWYWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRba2V5XSA9IGNsb25lKG9ialZhbHVlLCBkZWVwLCBudWxsLCBzdGFja0EsIHN0YWNrQik7XG4gICAgfSk7XG5cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEFzc2lnbnMgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIG9mIHRoZSBkZWZhdWx0IG9iamVjdChzKSB0byB0aGUgYGRlc3RpbmF0aW9uYFxuICAgKiBvYmplY3QgZm9yIGFsbCBgZGVzdGluYXRpb25gIHByb3BlcnRpZXMgdGhhdCByZXNvbHZlIHRvIGBudWxsYC9gdW5kZWZpbmVkYC5cbiAgICogT25jZSBhIHByb3BlcnR5IGlzIHNldCwgYWRkaXRpb25hbCBkZWZhdWx0cyBvZiB0aGUgc2FtZSBwcm9wZXJ0eSB3aWxsIGJlXG4gICAqIGlnbm9yZWQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW2RlZmF1bHQxLCBkZWZhdWx0MiwgLi4uXSBUaGUgZGVmYXVsdCBvYmplY3RzLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBpY2VDcmVhbSA9IHsgJ2ZsYXZvcic6ICdjaG9jb2xhdGUnIH07XG4gICAqIF8uZGVmYXVsdHMoaWNlQ3JlYW0sIHsgJ2ZsYXZvcic6ICd2YW5pbGxhJywgJ3Nwcmlua2xlcyc6ICdyYWluYm93JyB9KTtcbiAgICogLy8gPT4geyAnZmxhdm9yJzogJ2Nob2NvbGF0ZScsICdzcHJpbmtsZXMnOiAncmFpbmJvdycgfVxuICAgKi9cbiAgdmFyIGRlZmF1bHRzID0gY3JlYXRlSXRlcmF0b3IoZXh0ZW5kSXRlcmF0b3JPcHRpb25zLCB7XG4gICAgJ29iamVjdExvb3AnOiAnaWYgKHJlc3VsdFtpbmRleF0gPT0gbnVsbCkgJyArIGV4dGVuZEl0ZXJhdG9yT3B0aW9ucy5vYmplY3RMb29wXG4gIH0pO1xuXG4gIC8qKlxuICAgKiBBc3NpZ25zIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdChzKSB0byB0aGUgYGRlc3RpbmF0aW9uYFxuICAgKiBvYmplY3QuIFN1YnNlcXVlbnQgc291cmNlcyB3aWxsIG92ZXJ3cml0ZSBwcm9wZXJ5IGFzc2lnbm1lbnRzIG9mIHByZXZpb3VzXG4gICAqIHNvdXJjZXMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgZGVzdGluYXRpb24gb2JqZWN0LlxuICAgKiBAcGFyYW0ge09iamVjdH0gW3NvdXJjZTEsIHNvdXJjZTIsIC4uLl0gVGhlIHNvdXJjZSBvYmplY3RzLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uZXh0ZW5kKHsgJ25hbWUnOiAnbW9lJyB9LCB7ICdhZ2UnOiA0MCB9KTtcbiAgICogLy8gPT4geyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAgfVxuICAgKi9cbiAgdmFyIGV4dGVuZCA9IGNyZWF0ZUl0ZXJhdG9yKGV4dGVuZEl0ZXJhdG9yT3B0aW9ucyk7XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzb3J0ZWQgYXJyYXkgb2YgYWxsIGVudW1lcmFibGUgcHJvcGVydGllcywgb3duIGFuZCBpbmhlcml0ZWQsXG4gICAqIG9mIGBvYmplY3RgIHRoYXQgaGF2ZSBmdW5jdGlvbiB2YWx1ZXMuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGFsaWFzIG1ldGhvZHNcbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcyB0aGF0IGhhdmUgZnVuY3Rpb24gdmFsdWVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmZ1bmN0aW9ucyhfKTtcbiAgICogLy8gPT4gWydhbGwnLCAnYW55JywgJ2JpbmQnLCAnYmluZEFsbCcsICdjbG9uZScsICdjb21wYWN0JywgJ2NvbXBvc2UnLCAuLi5dXG4gICAqL1xuICBmdW5jdGlvbiBmdW5jdGlvbnMob2JqZWN0KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgaWYgKGlzRnVuY3Rpb24odmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdC5zb3J0KCk7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIHRoZSBzcGVjaWZpZWQgb2JqZWN0IGBwcm9wZXJ0eWAgZXhpc3RzIGFuZCBpcyBhIGRpcmVjdCBwcm9wZXJ0eSxcbiAgICogaW5zdGVhZCBvZiBhbiBpbmhlcml0ZWQgcHJvcGVydHkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGNoZWNrLlxuICAgKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHkgVGhlIHByb3BlcnR5IHRvIGNoZWNrIGZvci5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGtleSBpcyBhIGRpcmVjdCBwcm9wZXJ0eSwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmhhcyh7ICdhJzogMSwgJ2InOiAyLCAnYyc6IDMgfSwgJ2InKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gaGFzKG9iamVjdCwgcHJvcGVydHkpIHtcbiAgICByZXR1cm4gb2JqZWN0ID8gaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gb2JqZWN0IGNvbXBvc2VkIG9mIHRoZSBpbnZlcnRlZCBrZXlzIGFuZCB2YWx1ZXMgb2YgdGhlIGdpdmVuIGBvYmplY3RgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvYmplY3QgVGhlIG9iamVjdCB0byBpbnZlcnQuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGNyZWF0ZWQgaW52ZXJ0ZWQgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAgXy5pbnZlcnQoeyAnZmlyc3QnOiAnTW9lJywgJ3NlY29uZCc6ICdMYXJyeScsICd0aGlyZCc6ICdDdXJseScgfSk7XG4gICAqIC8vID0+IHsgJ01vZSc6ICdmaXJzdCcsICdMYXJyeSc6ICdzZWNvbmQnLCAnQ3VybHknOiAndGhpcmQnIH0gKG9yZGVyIGlzIG5vdCBndWFyYW50ZWVkKVxuICAgKi9cbiAgZnVuY3Rpb24gaW52ZXJ0KG9iamVjdCkge1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBmb3JPd24ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG4gICAgICByZXN1bHRbdmFsdWVdID0ga2V5O1xuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYW4gYXJyYXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYW4gYXJyYXksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogKGZ1bmN0aW9uKCkgeyByZXR1cm4gXy5pc0FycmF5KGFyZ3VtZW50cyk7IH0pKCk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNBcnJheShbMSwgMiwgM10pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICB2YXIgaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gYXJyYXlDbGFzcztcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBib29sZWFuIChgdHJ1ZWAgb3IgYGZhbHNlYCkgdmFsdWUuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBib29sZWFuIHZhbHVlLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNCb29sZWFuKG51bGwpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNCb29sZWFuKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB0cnVlIHx8IHZhbHVlID09PSBmYWxzZSB8fCB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBib29sQ2xhc3M7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBkYXRlLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgZGF0ZSwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzRGF0ZShuZXcgRGF0ZSk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlzRGF0ZSh2YWx1ZSkge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBkYXRlQ2xhc3M7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSBET00gZWxlbWVudC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIERPTSBlbGVtZW50LCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNFbGVtZW50KGRvY3VtZW50LmJvZHkpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBpc0VsZW1lbnQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgPyB2YWx1ZS5ub2RlVHlwZSA9PT0gMSA6IGZhbHNlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGVtcHR5LiBBcnJheXMsIHN0cmluZ3MsIG9yIGBhcmd1bWVudHNgIG9iamVjdHMgd2l0aCBhXG4gICAqIGxlbmd0aCBvZiBgMGAgYW5kIG9iamVjdHMgd2l0aCBubyBvd24gZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZSBjb25zaWRlcmVkXG4gICAqIFwiZW1wdHlcIi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IHZhbHVlIFRoZSB2YWx1ZSB0byBpbnNwZWN0LlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgZW1wdHksIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0VtcHR5KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNFbXB0eSh7fSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc0VtcHR5KCcnKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNFbXB0eSh2YWx1ZSkge1xuICAgIHZhciByZXN1bHQgPSB0cnVlO1xuICAgIGlmICghdmFsdWUpIHtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIHZhciBjbGFzc05hbWUgPSB0b1N0cmluZy5jYWxsKHZhbHVlKSxcbiAgICAgICAgbGVuZ3RoID0gdmFsdWUubGVuZ3RoO1xuXG4gICAgaWYgKChjbGFzc05hbWUgPT0gYXJyYXlDbGFzcyB8fCBjbGFzc05hbWUgPT0gc3RyaW5nQ2xhc3MgfHxcbiAgICAgICAgY2xhc3NOYW1lID09IGFyZ3NDbGFzcyB8fCAobm9BcmdzQ2xhc3MgJiYgaXNBcmd1bWVudHModmFsdWUpKSkgfHxcbiAgICAgICAgKGNsYXNzTmFtZSA9PSBvYmplY3RDbGFzcyAmJiB0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInICYmIGlzRnVuY3Rpb24odmFsdWUuc3BsaWNlKSkpIHtcbiAgICAgIHJldHVybiAhbGVuZ3RoO1xuICAgIH1cbiAgICBmb3JPd24odmFsdWUsIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIChyZXN1bHQgPSBmYWxzZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBQZXJmb3JtcyBhIGRlZXAgY29tcGFyaXNvbiBiZXR3ZWVuIHR3byB2YWx1ZXMgdG8gZGV0ZXJtaW5lIGlmIHRoZXkgYXJlXG4gICAqIGVxdWl2YWxlbnQgdG8gZWFjaCBvdGhlci5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge01peGVkfSBhIFRoZSB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0ge01peGVkfSBiIFRoZSBvdGhlciB2YWx1ZSB0byBjb21wYXJlLlxuICAgKiBAcGFyYW0tIHtPYmplY3R9IFtzdGFja0E9W11dIEludGVybmFsbHkgdXNlZCB0cmFjayB0cmF2ZXJzZWQgYGFgIG9iamVjdHMuXG4gICAqIEBwYXJhbS0ge09iamVjdH0gW3N0YWNrQj1bXV0gSW50ZXJuYWxseSB1c2VkIHRyYWNrIHRyYXZlcnNlZCBgYmAgb2JqZWN0cy5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSB2YWx1ZXMgYXJlIGVxdXZhbGVudCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgbW9lID0geyAnbmFtZSc6ICdtb2UnLCAnbHVja3lOdW1iZXJzJzogWzEzLCAyNywgMzRdIH07XG4gICAqIHZhciBjbG9uZSA9IHsgJ25hbWUnOiAnbW9lJywgJ2x1Y2t5TnVtYmVycyc6IFsxMywgMjcsIDM0XSB9O1xuICAgKlxuICAgKiBtb2UgPT0gY2xvbmU7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNFcXVhbChtb2UsIGNsb25lKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNFcXVhbChhLCBiLCBzdGFja0EsIHN0YWNrQikge1xuICAgIC8vIGV4aXQgZWFybHkgZm9yIGlkZW50aWNhbCB2YWx1ZXNcbiAgICBpZiAoYSA9PT0gYikge1xuICAgICAgLy8gdHJlYXQgYCswYCB2cy4gYC0wYCBhcyBub3QgZXF1YWxcbiAgICAgIHJldHVybiBhICE9PSAwIHx8ICgxIC8gYSA9PSAxIC8gYik7XG4gICAgfVxuICAgIC8vIGEgc3RyaWN0IGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5IGJlY2F1c2UgYG51bGwgPT0gdW5kZWZpbmVkYFxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSB7XG4gICAgICByZXR1cm4gYSA9PT0gYjtcbiAgICB9XG4gICAgLy8gY29tcGFyZSBbW0NsYXNzXV0gbmFtZXNcbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9IHRvU3RyaW5nLmNhbGwoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIGNhc2UgYm9vbENsYXNzOlxuICAgICAgY2FzZSBkYXRlQ2xhc3M6XG4gICAgICAgIC8vIGNvZXJjZSBkYXRlcyBhbmQgYm9vbGVhbnMgdG8gbnVtYmVycywgZGF0ZXMgdG8gbWlsbGlzZWNvbmRzIGFuZCBib29sZWFuc1xuICAgICAgICAvLyB0byBgMWAgb3IgYDBgLCB0cmVhdGluZyBpbnZhbGlkIGRhdGVzIGNvZXJjZWQgdG8gYE5hTmAgYXMgbm90IGVxdWFsXG4gICAgICAgIHJldHVybiArYSA9PSArYjtcblxuICAgICAgY2FzZSBudW1iZXJDbGFzczpcbiAgICAgICAgLy8gdHJlYXQgYE5hTmAgdnMuIGBOYU5gIGFzIGVxdWFsXG4gICAgICAgIHJldHVybiBhICE9ICthXG4gICAgICAgICAgPyBiICE9ICtiXG4gICAgICAgICAgLy8gYnV0IHRyZWF0IGArMGAgdnMuIGAtMGAgYXMgbm90IGVxdWFsXG4gICAgICAgICAgOiAoYSA9PSAwID8gKDEgLyBhID09IDEgLyBiKSA6IGEgPT0gK2IpO1xuXG4gICAgICBjYXNlIHJlZ2V4cENsYXNzOlxuICAgICAgY2FzZSBzdHJpbmdDbGFzczpcbiAgICAgICAgLy8gY29lcmNlIHJlZ2V4ZXMgdG8gc3RyaW5ncyAoaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMTAuNi40KVxuICAgICAgICAvLyB0cmVhdCBzdHJpbmcgcHJpbWl0aXZlcyBhbmQgdGhlaXIgY29ycmVzcG9uZGluZyBvYmplY3QgaW5zdGFuY2VzIGFzIGVxdWFsXG4gICAgICAgIHJldHVybiBhID09IGIgKyAnJztcbiAgICB9XG4gICAgLy8gZXhpdCBlYXJseSwgaW4gb2xkZXIgYnJvd3NlcnMsIGlmIGBhYCBpcyBhcnJheS1saWtlIGJ1dCBub3QgYGJgXG4gICAgdmFyIGlzQXJyID0gY2xhc3NOYW1lID09IGFycmF5Q2xhc3MgfHwgY2xhc3NOYW1lID09IGFyZ3NDbGFzcztcbiAgICBpZiAobm9BcmdzQ2xhc3MgJiYgIWlzQXJyICYmIChpc0FyciA9IGlzQXJndW1lbnRzKGEpKSAmJiAhaXNBcmd1bWVudHMoYikpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFpc0Fycikge1xuICAgICAgLy8gdW53cmFwIGFueSBgbG9kYXNoYCB3cmFwcGVkIHZhbHVlc1xuICAgICAgaWYgKGEuX193cmFwcGVkX18gfHwgYi5fX3dyYXBwZWRfXykge1xuICAgICAgICByZXR1cm4gaXNFcXVhbChhLl9fd3JhcHBlZF9fIHx8IGEsIGIuX193cmFwcGVkX18gfHwgYik7XG4gICAgICB9XG4gICAgICAvLyBleGl0IGZvciBmdW5jdGlvbnMgYW5kIERPTSBub2Rlc1xuICAgICAgaWYgKGNsYXNzTmFtZSAhPSBvYmplY3RDbGFzcyB8fCAobm9Ob2RlQ2xhc3MgJiYgKFxuICAgICAgICAgICh0eXBlb2YgYS50b1N0cmluZyAhPSAnZnVuY3Rpb24nICYmIHR5cGVvZiAoYSArICcnKSA9PSAnc3RyaW5nJykgfHxcbiAgICAgICAgICAodHlwZW9mIGIudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgKGIgKyAnJykgPT0gJ3N0cmluZycpKSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgdmFyIGN0b3JBID0gYS5jb25zdHJ1Y3RvcixcbiAgICAgICAgICBjdG9yQiA9IGIuY29uc3RydWN0b3I7XG5cbiAgICAgIC8vIG5vbiBgT2JqZWN0YCBvYmplY3QgaW5zdGFuY2VzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWFsXG4gICAgICBpZiAoY3RvckEgIT0gY3RvckIgJiYgIShcbiAgICAgICAgICAgIGlzRnVuY3Rpb24oY3RvckEpICYmIGN0b3JBIGluc3RhbmNlb2YgY3RvckEgJiZcbiAgICAgICAgICAgIGlzRnVuY3Rpb24oY3RvckIpICYmIGN0b3JCIGluc3RhbmNlb2YgY3RvckJcbiAgICAgICAgICApKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gYXNzdW1lIGN5Y2xpYyBzdHJ1Y3R1cmVzIGFyZSBlcXVhbFxuICAgIC8vIHRoZSBhbGdvcml0aG0gZm9yIGRldGVjdGluZyBjeWNsaWMgc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xXG4gICAgLy8gc2VjdGlvbiAxNS4xMi4zLCBhYnN0cmFjdCBvcGVyYXRpb24gYEpPYCAoaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMTIuMylcbiAgICBzdGFja0EgfHwgKHN0YWNrQSA9IFtdKTtcbiAgICBzdGFja0IgfHwgKHN0YWNrQiA9IFtdKTtcblxuICAgIHZhciBsZW5ndGggPSBzdGFja0EubGVuZ3RoO1xuICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgaWYgKHN0YWNrQVtsZW5ndGhdID09IGEpIHtcbiAgICAgICAgcmV0dXJuIHN0YWNrQltsZW5ndGhdID09IGI7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIHJlc3VsdCA9IHRydWUsXG4gICAgICAgIHNpemUgPSAwO1xuXG4gICAgLy8gYWRkIGBhYCBhbmQgYGJgIHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0c1xuICAgIHN0YWNrQS5wdXNoKGEpO1xuICAgIHN0YWNrQi5wdXNoKGIpO1xuXG4gICAgLy8gcmVjdXJzaXZlbHkgY29tcGFyZSBvYmplY3RzIGFuZCBhcnJheXMgKHN1c2NlcHRpYmxlIHRvIGNhbGwgc3RhY2sgbGltaXRzKVxuICAgIGlmIChpc0Fycikge1xuICAgICAgLy8gY29tcGFyZSBsZW5ndGhzIHRvIGRldGVybWluZSBpZiBhIGRlZXAgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnlcbiAgICAgIHNpemUgPSBhLmxlbmd0aDtcbiAgICAgIHJlc3VsdCA9IHNpemUgPT0gYi5sZW5ndGg7XG5cbiAgICAgIGlmIChyZXN1bHQpIHtcbiAgICAgICAgLy8gZGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllc1xuICAgICAgICB3aGlsZSAoc2l6ZS0tKSB7XG4gICAgICAgICAgaWYgKCEocmVzdWx0ID0gaXNFcXVhbChhW3NpemVdLCBiW3NpemVdLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfVxuICAgIC8vIGRlZXAgY29tcGFyZSBvYmplY3RzXG4gICAgZm9yICh2YXIga2V5IGluIGEpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGEsIGtleSkpIHtcbiAgICAgICAgLy8gY291bnQgdGhlIG51bWJlciBvZiBwcm9wZXJ0aWVzLlxuICAgICAgICBzaXplKys7XG4gICAgICAgIC8vIGRlZXAgY29tcGFyZSBlYWNoIHByb3BlcnR5IHZhbHVlLlxuICAgICAgICBpZiAoIShoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleSkgJiYgaXNFcXVhbChhW2tleV0sIGJba2V5XSwgc3RhY2tBLCBzdGFja0IpKSkge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICAvLyBlbnN1cmUgYm90aCBvYmplY3RzIGhhdmUgdGhlIHNhbWUgbnVtYmVyIG9mIHByb3BlcnRpZXNcbiAgICBmb3IgKGtleSBpbiBiKSB7XG4gICAgICAvLyBUaGUgSlMgZW5naW5lIGluIEFkb2JlIHByb2R1Y3RzLCBsaWtlIEluRGVzaWduLCBoYXMgYSBidWcgdGhhdCBjYXVzZXNcbiAgICAgIC8vIGAhc2l6ZS0tYCB0byB0aHJvdyBhbiBlcnJvciBzbyBpdCBtdXN0IGJlIHdyYXBwZWQgaW4gcGFyZW50aGVzZXMuXG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZG9jdW1lbnRjbG91ZC91bmRlcnNjb3JlL2lzc3Vlcy8zNTVcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGIsIGtleSkgJiYgIShzaXplLS0pKSB7XG4gICAgICAgIC8vIGBzaXplYCB3aWxsIGJlIGAtMWAgaWYgYGJgIGhhcyBtb3JlIHByb3BlcnRpZXMgdGhhbiBgYWBcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBoYW5kbGUgSlNjcmlwdCBbW0RvbnRFbnVtXV0gYnVnXG4gICAgaWYgKGhhc0RvbnRFbnVtQnVnKSB7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IDcpIHtcbiAgICAgICAga2V5ID0gc2hhZG93ZWRbaW5kZXhdO1xuICAgICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChhLCBrZXkpICYmXG4gICAgICAgICAgICAhKGhhc093blByb3BlcnR5LmNhbGwoYiwga2V5KSAmJiBpc0VxdWFsKGFba2V5XSwgYltrZXldLCBzdGFja0EsIHN0YWNrQikpKSB7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0cnVlO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzLCBvciBjYW4gYmUgY29lcmNlZCB0bywgYSBmaW5pdGUgbnVtYmVyLlxuICAgKlxuICAgKiBOb3RlOiBUaGlzIGlzIG5vdCB0aGUgc2FtZSBhcyBuYXRpdmUgYGlzRmluaXRlYCwgd2hpY2ggd2lsbCByZXR1cm4gdHJ1ZSBmb3JcbiAgICogYm9vbGVhbnMgYW5kIGVtcHR5IHN0cmluZ3MuIFNlZSBodHRwOi8vZXM1LmdpdGh1Yi5jb20vI3gxNS4xLjIuNS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBhIGZpbml0ZSBudW1iZXIsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc0Zpbml0ZSgtMTAxKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzRmluaXRlKCcxMCcpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNGaW5pdGUodHJ1ZSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNGaW5pdGUoJycpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzRmluaXRlKEluZmluaXR5KTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzRmluaXRlKHZhbHVlKSB7XG4gICAgcmV0dXJuIG5hdGl2ZUlzRmluaXRlKHZhbHVlKSAmJiAhbmF0aXZlSXNOYU4ocGFyc2VGbG9hdCh2YWx1ZSkpO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSBmdW5jdGlvbiwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzRnVuY3Rpb24oXyk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdmdW5jdGlvbic7XG4gIH1cbiAgLy8gZmFsbGJhY2sgZm9yIG9sZGVyIHZlcnNpb25zIG9mIENocm9tZSBhbmQgU2FmYXJpXG4gIGlmIChpc0Z1bmN0aW9uKC94LykpIHtcbiAgICBpc0Z1bmN0aW9uID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBmdW5jQ2xhc3M7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyB0aGUgbGFuZ3VhZ2UgdHlwZSBvZiBPYmplY3QuXG4gICAqIChlLmcuIGFycmF5cywgZnVuY3Rpb25zLCBvYmplY3RzLCByZWdleGVzLCBgbmV3IE51bWJlcigwKWAsIGFuZCBgbmV3IFN0cmluZygnJylgKVxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGFuIG9iamVjdCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KHt9KTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzT2JqZWN0KFsxLCAyLCAzXSk7XG4gICAqIC8vID0+IHRydWVcbiAgICpcbiAgICogXy5pc09iamVjdCgxKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzT2JqZWN0KHZhbHVlKSB7XG4gICAgLy8gY2hlY2sgaWYgdGhlIHZhbHVlIGlzIHRoZSBFQ01BU2NyaXB0IGxhbmd1YWdlIHR5cGUgb2YgT2JqZWN0XG4gICAgLy8gaHR0cDovL2VzNS5naXRodWIuY29tLyN4OFxuICAgIC8vIGFuZCBhdm9pZCBhIFY4IGJ1Z1xuICAgIC8vIGh0dHA6Ly9jb2RlLmdvb2dsZS5jb20vcC92OC9pc3N1ZXMvZGV0YWlsP2lkPTIyOTFcbiAgICByZXR1cm4gdmFsdWUgPyBvYmplY3RUeXBlc1t0eXBlb2YgdmFsdWVdIDogZmFsc2U7XG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYE5hTmAuXG4gICAqXG4gICAqIE5vdGU6IFRoaXMgaXMgbm90IHRoZSBzYW1lIGFzIG5hdGl2ZSBgaXNOYU5gLCB3aGljaCB3aWxsIHJldHVybiB0cnVlIGZvclxuICAgKiBgdW5kZWZpbmVkYCBhbmQgb3RoZXIgdmFsdWVzLiBTZWUgaHR0cDovL2VzNS5naXRodWIuY29tLyN4MTUuMS4yLjQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYE5hTmAsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc05hTihOYU4pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNOYU4obmV3IE51bWJlcihOYU4pKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBpc05hTih1bmRlZmluZWQpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uaXNOYU4odW5kZWZpbmVkKTtcbiAgICogLy8gPT4gZmFsc2VcbiAgICovXG4gIGZ1bmN0aW9uIGlzTmFOKHZhbHVlKSB7XG4gICAgLy8gYE5hTmAgYXMgYSBwcmltaXRpdmUgaXMgdGhlIG9ubHkgdmFsdWUgdGhhdCBpcyBub3QgZXF1YWwgdG8gaXRzZWxmXG4gICAgLy8gKHBlcmZvcm0gdGhlIFtbQ2xhc3NdXSBjaGVjayBmaXJzdCB0byBhdm9pZCBlcnJvcnMgd2l0aCBzb21lIGhvc3Qgb2JqZWN0cyBpbiBJRSlcbiAgICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gbnVtYmVyQ2xhc3MgJiYgdmFsdWUgIT0gK3ZhbHVlXG4gIH1cblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYG51bGxgLlxuICAgKlxuICAgKiBAZGVwcmVjYXRlZFxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGBudWxsYCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzTnVsbChudWxsKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmlzTnVsbCh1bmRlZmluZWQpO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gaXNOdWxsKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSBudWxsO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgbnVtYmVyLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgbnVtYmVyLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNOdW1iZXIoOC40ICogNSk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlzTnVtYmVyKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IG51bWJlckNsYXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGdpdmVuIGB2YWx1ZWAgaXMgYW4gb2JqZWN0IGNyZWF0ZWQgYnkgdGhlIGBPYmplY3RgIGNvbnN0cnVjdG9yLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBwbGFpbiBvYmplY3QsIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogZnVuY3Rpb24gU3Rvb2dlKG5hbWUsIGFnZSkge1xuICAgKiAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAqICAgdGhpcy5hZ2UgPSBhZ2U7XG4gICAqIH1cbiAgICpcbiAgICogXy5pc1BsYWluT2JqZWN0KG5ldyBTdG9vZ2UoJ21vZScsIDQwKSk7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uaXNQbGFpbk9iamVjdChbMSwgMiwgM10pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKlxuICAgKiBfLmlzUGxhaW5PYmplY3QoeyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAgfSk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIHZhciBpc1BsYWluT2JqZWN0ID0gIWdldFByb3RvdHlwZU9mID8gc2hpbUlzUGxhaW5PYmplY3QgOiBmdW5jdGlvbih2YWx1ZSkge1xuICAgIGlmICghKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PSAnb2JqZWN0JykpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIHZhbHVlT2YgPSB2YWx1ZS52YWx1ZU9mLFxuICAgICAgICBvYmpQcm90byA9IHR5cGVvZiB2YWx1ZU9mID09ICdmdW5jdGlvbicgJiYgKG9ialByb3RvID0gZ2V0UHJvdG90eXBlT2YodmFsdWVPZikpICYmIGdldFByb3RvdHlwZU9mKG9ialByb3RvKTtcblxuICAgIHJldHVybiBvYmpQcm90b1xuICAgICAgPyB2YWx1ZSA9PSBvYmpQcm90byB8fCAoZ2V0UHJvdG90eXBlT2YodmFsdWUpID09IG9ialByb3RvICYmICFpc0FyZ3VtZW50cyh2YWx1ZSkpXG4gICAgICA6IHNoaW1Jc1BsYWluT2JqZWN0KHZhbHVlKTtcbiAgfTtcblxuICAvKipcbiAgICogQ2hlY2tzIGlmIGB2YWx1ZWAgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgdGhlIGB2YWx1ZWAgaXMgYSByZWd1bGFyIGV4cHJlc3Npb24sIGVsc2UgYGZhbHNlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5pc1JlZ0V4cCgvbW9lLyk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlzUmVnRXhwKHZhbHVlKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsdWUpID09IHJlZ2V4cENsYXNzO1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgc3RyaW5nLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBPYmplY3RzXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdmFsdWVgIGlzIGEgc3RyaW5nLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaXNTdHJpbmcoJ21vZScpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBpc1N0cmluZyh2YWx1ZSkge1xuICAgIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdDbGFzcztcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYC5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWRcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiB0aGUgYHZhbHVlYCBpcyBgdW5kZWZpbmVkYCwgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmlzVW5kZWZpbmVkKHZvaWQgMCk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBjb21wb3NlZCBvZiB0aGUgb3duIGVudW1lcmFibGUgcHJvcGVydHkgbmFtZXMgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBwcm9wZXJ0eSBuYW1lcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5rZXlzKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgKiAvLyA9PiBbJ29uZScsICd0d28nLCAndGhyZWUnXSAob3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAqL1xuICB2YXIga2V5cyA9ICFuYXRpdmVLZXlzID8gc2hpbUtleXMgOiBmdW5jdGlvbihvYmplY3QpIHtcbiAgICAvLyBhdm9pZCBpdGVyYXRpbmcgb3ZlciB0aGUgYHByb3RvdHlwZWAgcHJvcGVydHlcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PSAnZnVuY3Rpb24nICYmIHByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqZWN0LCAncHJvdG90eXBlJylcbiAgICAgID8gc2hpbUtleXMob2JqZWN0KVxuICAgICAgOiAoaXNPYmplY3Qob2JqZWN0KSA/IG5hdGl2ZUtleXMob2JqZWN0KSA6IFtdKTtcbiAgfTtcblxuICAvKipcbiAgICogTWVyZ2VzIGVudW1lcmFibGUgcHJvcGVydGllcyBvZiB0aGUgc291cmNlIG9iamVjdChzKSBpbnRvIHRoZSBgZGVzdGluYXRpb25gXG4gICAqIG9iamVjdC4gU3Vic2VxdWVudCBzb3VyY2VzIHdpbGwgb3ZlcndyaXRlIHByb3BlcnkgYXNzaWdubWVudHMgb2YgcHJldmlvdXNcbiAgICogc291cmNlcy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBkZXN0aW5hdGlvbiBvYmplY3QuXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbc291cmNlMSwgc291cmNlMiwgLi4uXSBUaGUgc291cmNlIG9iamVjdHMuXG4gICAqIEBwYXJhbS0ge09iamVjdH0gW2luZGljYXRvcl0gSW50ZXJuYWxseSB1c2VkIHRvIGluZGljYXRlIHRoYXQgdGhlIGBzdGFja2BcbiAgICogIGFyZ3VtZW50IGlzIGFuIGFycmF5IG9mIHRyYXZlcnNlZCBvYmplY3RzIGluc3RlYWQgb2YgYW5vdGhlciBzb3VyY2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0tIHtBcnJheX0gW3N0YWNrQT1bXV0gSW50ZXJuYWxseSB1c2VkIHRvIHRyYWNrIHRyYXZlcnNlZCBzb3VyY2Ugb2JqZWN0cy5cbiAgICogQHBhcmFtLSB7QXJyYXl9IFtzdGFja0I9W11dIEludGVybmFsbHkgdXNlZCB0byBhc3NvY2lhdGUgdmFsdWVzIHdpdGggdGhlaXJcbiAgICogIHNvdXJjZSBjb3VudGVycGFydHMuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIGRlc3RpbmF0aW9uIG9iamVjdC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHN0b29nZXMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdtb2UnIH0sXG4gICAqICAgeyAnbmFtZSc6ICdsYXJyeScgfVxuICAgKiBdO1xuICAgKlxuICAgKiB2YXIgYWdlcyA9IFtcbiAgICogICB7ICdhZ2UnOiA0MCB9LFxuICAgKiAgIHsgJ2FnZSc6IDUwIH1cbiAgICogXTtcbiAgICpcbiAgICogXy5tZXJnZShzdG9vZ2VzLCBhZ2VzKTtcbiAgICogLy8gPT4gW3sgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sIHsgJ25hbWUnOiAnbGFycnknLCAnYWdlJzogNTAgfV1cbiAgICovXG4gIGZ1bmN0aW9uIG1lcmdlKG9iamVjdCwgc291cmNlLCBpbmRpY2F0b3IpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgaW5kZXggPSAwLFxuICAgICAgICBsZW5ndGggPSAyLFxuICAgICAgICBzdGFja0EgPSBhcmdzWzNdLFxuICAgICAgICBzdGFja0IgPSBhcmdzWzRdO1xuXG4gICAgaWYgKGluZGljYXRvciAhPT0gb2JqZWN0UmVmKSB7XG4gICAgICBzdGFja0EgPSBbXTtcbiAgICAgIHN0YWNrQiA9IFtdO1xuICAgICAgbGVuZ3RoID0gYXJncy5sZW5ndGg7XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBmb3JPd24oYXJnc1tpbmRleF0sIGZ1bmN0aW9uKHNvdXJjZSwga2V5KSB7XG4gICAgICAgIHZhciBmb3VuZCwgaXNBcnIsIHZhbHVlO1xuICAgICAgICBpZiAoc291cmNlICYmICgoaXNBcnIgPSBpc0FycmF5KHNvdXJjZSkpIHx8IGlzUGxhaW5PYmplY3Qoc291cmNlKSkpIHtcbiAgICAgICAgICAvLyBhdm9pZCBtZXJnaW5nIHByZXZpb3VzbHkgbWVyZ2VkIGN5Y2xpYyBzb3VyY2VzXG4gICAgICAgICAgdmFyIHN0YWNrTGVuZ3RoID0gc3RhY2tBLmxlbmd0aDtcbiAgICAgICAgICB3aGlsZSAoc3RhY2tMZW5ndGgtLSkge1xuICAgICAgICAgICAgZm91bmQgPSBzdGFja0Fbc3RhY2tMZW5ndGhdID09IHNvdXJjZTtcbiAgICAgICAgICAgIGlmIChmb3VuZCkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGZvdW5kKSB7XG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IHN0YWNrQltzdGFja0xlbmd0aF07XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gYWRkIGBzb3VyY2VgIGFuZCBhc3NvY2lhdGVkIGB2YWx1ZWAgdG8gdGhlIHN0YWNrIG9mIHRyYXZlcnNlZCBvYmplY3RzXG4gICAgICAgICAgICBzdGFja0EucHVzaChzb3VyY2UpO1xuICAgICAgICAgICAgc3RhY2tCLnB1c2godmFsdWUgPSAodmFsdWUgPSBvYmplY3Rba2V5XSwgaXNBcnIpXG4gICAgICAgICAgICAgID8gKGlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbXSlcbiAgICAgICAgICAgICAgOiAoaXNQbGFpbk9iamVjdCh2YWx1ZSkgPyB2YWx1ZSA6IHt9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIC8vIHJlY3Vyc2l2ZWx5IG1lcmdlIG9iamVjdHMgYW5kIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICAgICAgICBvYmplY3Rba2V5XSA9IG1lcmdlKHZhbHVlLCBzb3VyY2UsIG9iamVjdFJlZiwgc3RhY2tBLCBzdGFja0IpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIGlmIChzb3VyY2UgIT0gbnVsbCkge1xuICAgICAgICAgIG9iamVjdFtrZXldID0gc291cmNlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgc2hhbGxvdyBjbG9uZSBvZiBgb2JqZWN0YCBleGNsdWRpbmcgdGhlIHNwZWNpZmllZCBwcm9wZXJ0aWVzLlxuICAgKiBQcm9wZXJ0eSBuYW1lcyBtYXkgYmUgc3BlY2lmaWVkIGFzIGluZGl2aWR1YWwgYXJndW1lbnRzIG9yIGFzIGFycmF5cyBvZlxuICAgKiBwcm9wZXJ0eSBuYW1lcy4gSWYgYGNhbGxiYWNrYCBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2ggcHJvcGVydHlcbiAgICogaW4gdGhlIGBvYmplY3RgLCBvbWl0dGluZyB0aGUgcHJvcGVydGllcyBgY2FsbGJhY2tgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlXG4gICAqIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gY2FsbGJhY2t8W3Byb3AxLCBwcm9wMiwgLi4uXSBUaGUgcHJvcGVydGllcyB0byBvbWl0XG4gICAqICBvciB0aGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3Qgd2l0aG91dCB0aGUgb21pdHRlZCBwcm9wZXJ0aWVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm9taXQoeyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAsICd1c2VyaWQnOiAnbW9lMScgfSwgJ3VzZXJpZCcpO1xuICAgKiAvLyA9PiB7ICduYW1lJzogJ21vZScsICdhZ2UnOiA0MCB9XG4gICAqXG4gICAqIF8ub21pdCh7ICduYW1lJzogJ21vZScsICdfaGludCc6ICdrbnVja2xlaGVhZCcsICdfc2VlZCc6ICc5NmM0ZWInIH0sIGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICogICByZXR1cm4ga2V5LmNoYXJBdCgwKSA9PSAnXyc7XG4gICAqIH0pO1xuICAgKiAvLyA9PiB7ICduYW1lJzogJ21vZScgfVxuICAgKi9cbiAgZnVuY3Rpb24gb21pdChvYmplY3QsIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIGlzRnVuYyA9IHR5cGVvZiBjYWxsYmFjayA9PSAnZnVuY3Rpb24nLFxuICAgICAgICByZXN1bHQgPSB7fTtcblxuICAgIGlmIChpc0Z1bmMpIHtcbiAgICAgIGNhbGxiYWNrID0gY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgcHJvcHMgPSBjb25jYXQuYXBwbHkoYXJyYXlSZWYsIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIGZvckluKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSwgb2JqZWN0KSB7XG4gICAgICBpZiAoaXNGdW5jXG4gICAgICAgICAgICA/ICFjYWxsYmFjayh2YWx1ZSwga2V5LCBvYmplY3QpXG4gICAgICAgICAgICA6IGluZGV4T2YocHJvcHMsIGtleSwgMSkgPCAwXG4gICAgICAgICAgKSB7XG4gICAgICAgIHJlc3VsdFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgdHdvIGRpbWVuc2lvbmFsIGFycmF5IG9mIHRoZSBnaXZlbiBvYmplY3QncyBrZXktdmFsdWUgcGFpcnMsXG4gICAqIGkuZS4gYFtba2V5MSwgdmFsdWUxXSwgW2tleTIsIHZhbHVlMl1dYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIG5ldyBhcnJheSBvZiBrZXktdmFsdWUgcGFpcnMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ucGFpcnMoeyAnbW9lJzogMzAsICdsYXJyeSc6IDQwLCAnY3VybHknOiA1MCB9KTtcbiAgICogLy8gPT4gW1snbW9lJywgMzBdLCBbJ2xhcnJ5JywgNDBdLCBbJ2N1cmx5JywgNTBdXSAob3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAqL1xuICBmdW5jdGlvbiBwYWlycyhvYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgICAgcmVzdWx0LnB1c2goW2tleSwgdmFsdWVdKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBzaGFsbG93IGNsb25lIG9mIGBvYmplY3RgIGNvbXBvc2VkIG9mIHRoZSBzcGVjaWZpZWQgcHJvcGVydGllcy5cbiAgICogUHJvcGVydHkgbmFtZXMgbWF5IGJlIHNwZWNpZmllZCBhcyBpbmRpdmlkdWFsIGFyZ3VtZW50cyBvciBhcyBhcnJheXMgb2ZcbiAgICogcHJvcGVydHkgbmFtZXMuIElmIGBjYWxsYmFja2AgaXMgcGFzc2VkLCBpdCB3aWxsIGJlIGV4ZWN1dGVkIGZvciBlYWNoIHByb3BlcnR5XG4gICAqIGluIHRoZSBgb2JqZWN0YCwgcGlja2luZyB0aGUgcHJvcGVydGllcyBgY2FsbGJhY2tgIHJldHVybnMgdHJ1dGh5IGZvci4gVGhlXG4gICAqIGBjYWxsYmFja2AgaXMgYm91bmQgdG8gYHRoaXNBcmdgIGFuZCBpbnZva2VkIHdpdGggdGhyZWUgYXJndW1lbnRzOyAodmFsdWUsIGtleSwgb2JqZWN0KS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgT2JqZWN0c1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBzb3VyY2Ugb2JqZWN0LlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufFN0cmluZ30gY2FsbGJhY2t8W3Byb3AxLCBwcm9wMiwgLi4uXSBUaGUgcHJvcGVydGllcyB0byBwaWNrXG4gICAqICBvciB0aGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIHBpY2tlZCBwcm9wZXJ0aWVzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnBpY2soeyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAsICd1c2VyaWQnOiAnbW9lMScgfSwgJ25hbWUnLCAnYWdlJyk7XG4gICAqIC8vID0+IHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH1cbiAgICpcbiAgICogXy5waWNrKHsgJ25hbWUnOiAnbW9lJywgJ19oaW50JzogJ2tudWNrbGVoZWFkJywgJ19zZWVkJzogJzk2YzRlYicgfSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuICAgKiAgIHJldHVybiBrZXkuY2hhckF0KDApICE9ICdfJztcbiAgICogfSk7XG4gICAqIC8vID0+IHsgJ25hbWUnOiAnbW9lJyB9XG4gICAqL1xuICBmdW5jdGlvbiBwaWNrKG9iamVjdCwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPSAnZnVuY3Rpb24nKSB7XG4gICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIHByb3BzID0gY29uY2F0LmFwcGx5KGFycmF5UmVmLCBhcmd1bWVudHMpLFxuICAgICAgICAgIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgdmFyIGtleSA9IHByb3BzW2luZGV4XTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IG9iamVjdFtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbGxiYWNrID0gY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgICAgZm9ySW4ob2JqZWN0LCBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmplY3QpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBrZXksIG9iamVjdCkpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IGNvbXBvc2VkIG9mIHRoZSBvd24gZW51bWVyYWJsZSBwcm9wZXJ0eSB2YWx1ZXMgb2YgYG9iamVjdGAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IE9iamVjdHNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBwcm9wZXJ0eSB2YWx1ZXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8udmFsdWVzKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICovXG4gIGZ1bmN0aW9uIHZhbHVlcyhvYmplY3QpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yT3duKG9iamVjdCwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiBhIGdpdmVuIGB0YXJnZXRgIGVsZW1lbnQgaXMgcHJlc2VudCBpbiBhIGBjb2xsZWN0aW9uYCB1c2luZyBzdHJpY3RcbiAgICogZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiBgZnJvbUluZGV4YCBpcyBuZWdhdGl2ZSwgaXQgaXMgdXNlZFxuICAgKiBhcyB0aGUgb2Zmc2V0IGZyb20gdGhlIGVuZCBvZiB0aGUgY29sbGVjdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgaW5jbHVkZVxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtNaXhlZH0gdGFyZ2V0IFRoZSB2YWx1ZSB0byBjaGVjayBmb3IuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge0Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIHRoZSBgdGFyZ2V0YCBlbGVtZW50IGlzIGZvdW5kLCBlbHNlIGBmYWxzZWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uY29udGFpbnMoWzEsIDIsIDNdLCAxKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKlxuICAgKiBfLmNvbnRhaW5zKFsxLCAyLCAzXSwgMSwgMik7XG4gICAqIC8vID0+IGZhbHNlXG4gICAqXG4gICAqIF8uY29udGFpbnMoeyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAgfSwgJ21vZScpO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqXG4gICAqIF8uY29udGFpbnMoJ2N1cmx5JywgJ3VyJyk7XG4gICAqIC8vID0+IHRydWVcbiAgICovXG4gIGZ1bmN0aW9uIGNvbnRhaW5zKGNvbGxlY3Rpb24sIHRhcmdldCwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG5cbiAgICBmcm9tSW5kZXggPSAoZnJvbUluZGV4IDwgMCA/IG5hdGl2ZU1heCgwLCBsZW5ndGggKyBmcm9tSW5kZXgpIDogZnJvbUluZGV4KSB8fCAwO1xuICAgIGlmICh0eXBlb2YgbGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gKGlzU3RyaW5nKGNvbGxlY3Rpb24pXG4gICAgICAgID8gY29sbGVjdGlvbi5pbmRleE9mKHRhcmdldCwgZnJvbUluZGV4KVxuICAgICAgICA6IGluZGV4T2YoY29sbGVjdGlvbiwgdGFyZ2V0LCBmcm9tSW5kZXgpXG4gICAgICApID4gLTE7XG4gICAgfVxuICAgIHJldHVybiBzb21lKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICByZXR1cm4gKytpbmRleCA+PSBmcm9tSW5kZXggJiYgdmFsdWUgPT09IHRhcmdldDtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIHJldHVybmVkIGZyb20gcnVubmluZyBlYWNoIGVsZW1lbnQgb2ZcbiAgICogYGNvbGxlY3Rpb25gIHRocm91Z2ggYSBgY2FsbGJhY2tgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZiBlYWNoIGtleSBpc1xuICAgKiB0aGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBrZXkgd2FzIHJldHVybmVkIGJ5IGBjYWxsYmFja2AuIFRoZSBgY2FsbGJhY2tgIGlzXG4gICAqIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgKiBUaGUgYGNhbGxiYWNrYCBhcmd1bWVudCBtYXkgYWxzbyBiZSB0aGUgbmFtZSBvZiBhIHByb3BlcnR5IHRvIGNvdW50IGJ5IChlLmcuICdsZW5ndGgnKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGNhbGxiYWNrfHByb3BlcnR5IFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvblxuICAgKiAgb3IgcHJvcGVydHkgbmFtZSB0byBjb3VudCBieS5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguZmxvb3IobnVtKTsgfSk7XG4gICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgKlxuICAgKiBfLmNvdW50QnkoWzQuMywgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIHRoaXMuZmxvb3IobnVtKTsgfSwgTWF0aCk7XG4gICAqIC8vID0+IHsgJzQnOiAxLCAnNic6IDIgfVxuICAgKlxuICAgKiBfLmNvdW50QnkoWydvbmUnLCAndHdvJywgJ3RocmVlJ10sICdsZW5ndGgnKTtcbiAgICogLy8gPT4geyAnMyc6IDIsICc1JzogMSB9XG4gICAqL1xuICBmdW5jdGlvbiBjb3VudEJ5KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGNhbGxiYWNrID0gY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGtleSwgY29sbGVjdGlvbikge1xuICAgICAga2V5ID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICAoaGFzT3duUHJvcGVydHkuY2FsbChyZXN1bHQsIGtleSkgPyByZXN1bHRba2V5XSsrIDogcmVzdWx0W2tleV0gPSAxKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgYGNhbGxiYWNrYCByZXR1cm5zIGEgdHJ1dGh5IHZhbHVlIGZvciAqKmFsbCoqIGVsZW1lbnRzIG9mIGFcbiAgICogYGNvbGxlY3Rpb25gLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZVxuICAgKiBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgYWxsXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7Qm9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYWxsIGVsZW1lbnRzIHBhc3MgdGhlIGNhbGxiYWNrIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmV2ZXJ5KFt0cnVlLCAxLCBudWxsLCAneWVzJ10sIEJvb2xlYW4pO1xuICAgKiAvLyA9PiBmYWxzZVxuICAgKi9cbiAgZnVuY3Rpb24gZXZlcnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgcmVzdWx0ID0gdHJ1ZTtcbiAgICBjYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcblxuICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKCEocmVzdWx0ID0gISFjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pKSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKSB7XG4gICAgICAgIHJldHVybiAocmVzdWx0ID0gISFjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4YW1pbmVzIGVhY2ggZWxlbWVudCBpbiBhIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgKiB0aGUgYGNhbGxiYWNrYCByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmRcbiAgICogaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyBzZWxlY3RcbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBlbGVtZW50cyB0aGF0IHBhc3NlZCB0aGUgY2FsbGJhY2sgY2hlY2suXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBldmVucyA9IF8uZmlsdGVyKFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgKiAvLyA9PiBbMiwgNCwgNl1cbiAgICovXG4gIGZ1bmN0aW9uIGZpbHRlcihjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBjYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogRXhhbWluZXMgZWFjaCBlbGVtZW50IGluIGEgYGNvbGxlY3Rpb25gLCByZXR1cm5pbmcgdGhlIGZpcnN0IG9uZSB0aGUgYGNhbGxiYWNrYFxuICAgKiByZXR1cm5zIHRydXRoeSBmb3IuIFRoZSBmdW5jdGlvbiByZXR1cm5zIGFzIHNvb24gYXMgaXQgZmluZHMgYW4gYWNjZXB0YWJsZVxuICAgKiBlbGVtZW50LCBhbmQgZG9lcyBub3QgaXRlcmF0ZSBvdmVyIHRoZSBlbnRpcmUgYGNvbGxlY3Rpb25gLiBUaGUgYGNhbGxiYWNrYCBpc1xuICAgKiBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgZGV0ZWN0XG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSBlbGVtZW50IHRoYXQgcGFzc2VkIHRoZSBjYWxsYmFjayBjaGVjayxcbiAgICogIGVsc2UgYHVuZGVmaW5lZGAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBldmVuID0gXy5maW5kKFsxLCAyLCAzLCA0LCA1LCA2XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pO1xuICAgKiAvLyA9PiAyXG4gICAqL1xuICBmdW5jdGlvbiBmaW5kKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBjYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgaWYgKGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEl0ZXJhdGVzIG92ZXIgYSBgY29sbGVjdGlvbmAsIGV4ZWN1dGluZyB0aGUgYGNhbGxiYWNrYCBmb3IgZWFjaCBlbGVtZW50IGluXG4gICAqIHRoZSBgY29sbGVjdGlvbmAuIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlXG4gICAqIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLiBDYWxsYmFja3MgbWF5IGV4aXQgaXRlcmF0aW9uIGVhcmx5XG4gICAqIGJ5IGV4cGxpY2l0bHkgcmV0dXJuaW5nIGBmYWxzZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGFsaWFzIGVhY2hcbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl8T2JqZWN0fFN0cmluZ30gUmV0dXJucyBgY29sbGVjdGlvbmAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8oWzEsIDIsIDNdKS5mb3JFYWNoKGFsZXJ0KS5qb2luKCcsJyk7XG4gICAqIC8vID0+IGFsZXJ0cyBlYWNoIG51bWJlciBhbmQgcmV0dXJucyAnMSwyLDMnXG4gICAqXG4gICAqIF8uZm9yRWFjaCh7ICdvbmUnOiAxLCAndHdvJzogMiwgJ3RocmVlJzogMyB9LCBhbGVydCk7XG4gICAqIC8vID0+IGFsZXJ0cyBlYWNoIG51bWJlciAob3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAqL1xuICB2YXIgZm9yRWFjaCA9IGNyZWF0ZUl0ZXJhdG9yKGZvckVhY2hJdGVyYXRvck9wdGlvbnMpO1xuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIG9iamVjdCBjb21wb3NlZCBvZiBrZXlzIHJldHVybmVkIGZyb20gcnVubmluZyBlYWNoIGVsZW1lbnQgb2ZcbiAgICogYGNvbGxlY3Rpb25gIHRocm91Z2ggYSBgY2FsbGJhY2tgLiBUaGUgY29ycmVzcG9uZGluZyB2YWx1ZSBvZiBlYWNoIGtleSBpcyBhblxuICAgKiBhcnJheSBvZiBlbGVtZW50cyBwYXNzZWQgdG8gYGNhbGxiYWNrYCB0aGF0IHJldHVybmVkIHRoZSBrZXkuIFRoZSBgY2FsbGJhY2tgXG4gICAqIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgKiBUaGUgYGNhbGxiYWNrYCBhcmd1bWVudCBtYXkgYWxzbyBiZSB0aGUgbmFtZSBvZiBhIHByb3BlcnR5IHRvIGdyb3VwIGJ5IChlLmcuICdsZW5ndGgnKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGNhbGxiYWNrfHByb3BlcnR5IFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvblxuICAgKiAgb3IgcHJvcGVydHkgbmFtZSB0byBncm91cCBieS5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7T2JqZWN0fSBSZXR1cm5zIHRoZSBjb21wb3NlZCBhZ2dyZWdhdGUgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmdyb3VwQnkoWzQuMiwgNi4xLCA2LjRdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguZmxvb3IobnVtKTsgfSk7XG4gICAqIC8vID0+IHsgJzQnOiBbNC4yXSwgJzYnOiBbNi4xLCA2LjRdIH1cbiAgICpcbiAgICogXy5ncm91cEJ5KFs0LjIsIDYuMSwgNi40XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgKiAvLyA9PiB7ICc0JzogWzQuMl0sICc2JzogWzYuMSwgNi40XSB9XG4gICAqXG4gICAqIF8uZ3JvdXBCeShbJ29uZScsICd0d28nLCAndGhyZWUnXSwgJ2xlbmd0aCcpO1xuICAgKiAvLyA9PiB7ICczJzogWydvbmUnLCAndHdvJ10sICc1JzogWyd0aHJlZSddIH1cbiAgICovXG4gIGZ1bmN0aW9uIGdyb3VwQnkoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgY2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKSB7XG4gICAgICBrZXkgPSBjYWxsYmFjayh2YWx1ZSwga2V5LCBjb2xsZWN0aW9uKTtcbiAgICAgIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHJlc3VsdCwga2V5KSA/IHJlc3VsdFtrZXldIDogcmVzdWx0W2tleV0gPSBbXSkucHVzaCh2YWx1ZSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnZva2VzIHRoZSBtZXRob2QgbmFtZWQgYnkgYG1ldGhvZE5hbWVgIG9uIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gLFxuICAgKiByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBpbnZva2VkIG1ldGhvZC4gQWRkaXRpb25hbCBhcmd1bWVudHNcbiAgICogd2lsbCBiZSBwYXNzZWQgdG8gZWFjaCBpbnZva2VkIG1ldGhvZC4gSWYgYG1ldGhvZE5hbWVgIGlzIGEgZnVuY3Rpb24gaXQgd2lsbFxuICAgKiBiZSBpbnZva2VkIGZvciwgYW5kIGB0aGlzYCBib3VuZCB0bywgZWFjaCBlbGVtZW50IGluIHRoZSBgY29sbGVjdGlvbmAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBtZXRob2ROYW1lIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdG8gaW52b2tlIG9yXG4gICAqICB0aGUgZnVuY3Rpb24gaW52b2tlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBbYXJnMSwgYXJnMiwgLi4uXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBtZXRob2Qgd2l0aC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggaW52b2tlZCBtZXRob2QuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaW52b2tlKFtbNSwgMSwgN10sIFszLCAyLCAxXV0sICdzb3J0Jyk7XG4gICAqIC8vID0+IFtbMSwgNSwgN10sIFsxLCAyLCAzXV1cbiAgICpcbiAgICogXy5pbnZva2UoWzEyMywgNDU2XSwgU3RyaW5nLnByb3RvdHlwZS5zcGxpdCwgJycpO1xuICAgKiAvLyA9PiBbWycxJywgJzInLCAnMyddLCBbJzQnLCAnNScsICc2J11dXG4gICAqL1xuICBmdW5jdGlvbiBpbnZva2UoY29sbGVjdGlvbiwgbWV0aG9kTmFtZSkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpLFxuICAgICAgICBpc0Z1bmMgPSB0eXBlb2YgbWV0aG9kTmFtZSA9PSAnZnVuY3Rpb24nLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIGZvckVhY2goY29sbGVjdGlvbiwgZnVuY3Rpb24odmFsdWUpIHtcbiAgICAgIHJlc3VsdC5wdXNoKChpc0Z1bmMgPyBtZXRob2ROYW1lIDogdmFsdWVbbWV0aG9kTmFtZV0pLmFwcGx5KHZhbHVlLCBhcmdzKSk7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHZhbHVlcyBieSBydW5uaW5nIGVhY2ggZWxlbWVudCBpbiB0aGUgYGNvbGxlY3Rpb25gXG4gICAqIHRocm91Z2ggYSBgY2FsbGJhY2tgLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aFxuICAgKiB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAYWxpYXMgY29sbGVjdFxuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2NhbGxiYWNrPWlkZW50aXR5XSBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHRoZSByZXN1bHRzIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ubWFwKFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gKiAzOyB9KTtcbiAgICogLy8gPT4gWzMsIDYsIDldXG4gICAqXG4gICAqIF8ubWFwKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0sIGZ1bmN0aW9uKG51bSkgeyByZXR1cm4gbnVtICogMzsgfSk7XG4gICAqIC8vID0+IFszLCA2LCA5XSAob3JkZXIgaXMgbm90IGd1YXJhbnRlZWQpXG4gICAqL1xuICBmdW5jdGlvbiBtYXAoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkodHlwZW9mIGxlbmd0aCA9PSAnbnVtYmVyJyA/IGxlbmd0aCA6IDApO1xuXG4gICAgY2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgaWYgKGlzQXJyYXkoY29sbGVjdGlvbikpIHtcbiAgICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjayhjb2xsZWN0aW9uW2luZGV4XSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBrZXksIGNvbGxlY3Rpb24pIHtcbiAgICAgICAgcmVzdWx0WysraW5kZXhdID0gY2FsbGJhY2sodmFsdWUsIGtleSwgY29sbGVjdGlvbik7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXRyaWV2ZXMgdGhlIG1heGltdW0gdmFsdWUgb2YgYW4gYGFycmF5YC4gSWYgYGNhbGxiYWNrYCBpcyBwYXNzZWQsXG4gICAqIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGVhY2ggdmFsdWUgaW4gdGhlIGBhcnJheWAgdG8gZ2VuZXJhdGUgdGhlXG4gICAqIGNyaXRlcmlvbiBieSB3aGljaCB0aGUgdmFsdWUgaXMgcmFua2VkLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0b1xuICAgKiBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2tdIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7TWl4ZWR9IFJldHVybnMgdGhlIG1heGltdW0gdmFsdWUuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBzdG9vZ2VzID0gW1xuICAgKiAgIHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sXG4gICAqICAgeyAnbmFtZSc6ICdsYXJyeScsICdhZ2UnOiA1MCB9LFxuICAgKiAgIHsgJ25hbWUnOiAnY3VybHknLCAnYWdlJzogNjAgfVxuICAgKiBdO1xuICAgKlxuICAgKiBfLm1heChzdG9vZ2VzLCBmdW5jdGlvbihzdG9vZ2UpIHsgcmV0dXJuIHN0b29nZS5hZ2U7IH0pO1xuICAgKiAvLyA9PiB7ICduYW1lJzogJ2N1cmx5JywgJ2FnZSc6IDYwIH07XG4gICAqL1xuICBmdW5jdGlvbiBtYXgoY29sbGVjdGlvbiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICB2YXIgY29tcHV0ZWQgPSAtSW5maW5pdHksXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgaWYgKGNhbGxiYWNrIHx8ICFpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICBjYWxsYmFjayA9ICFjYWxsYmFjayAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKVxuICAgICAgICA/IGNoYXJBdENhbGxiYWNrXG4gICAgICAgIDogY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3VycmVudCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIGlmIChjdXJyZW50ID4gY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY29sbGVjdGlvbltpbmRleF0gPiByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgbWluaW11bSB2YWx1ZSBvZiBhbiBgYXJyYXlgLiBJZiBgY2FsbGJhY2tgIGlzIHBhc3NlZCxcbiAgICogaXQgd2lsbCBiZSBleGVjdXRlZCBmb3IgZWFjaCB2YWx1ZSBpbiB0aGUgYGFycmF5YCB0byBnZW5lcmF0ZSB0aGVcbiAgICogY3JpdGVyaW9uIGJ5IHdoaWNoIHRoZSB2YWx1ZSBpcyByYW5rZWQuIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYFxuICAgKiBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFja10gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgbWluaW11bSB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5taW4oWzEwLCA1LCAxMDAsIDIsIDEwMDBdKTtcbiAgICogLy8gPT4gMlxuICAgKi9cbiAgZnVuY3Rpb24gbWluKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIGNvbXB1dGVkID0gSW5maW5pdHksXG4gICAgICAgIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgIHJlc3VsdCA9IGNvbXB1dGVkO1xuXG4gICAgaWYgKGNhbGxiYWNrIHx8ICFpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICBjYWxsYmFjayA9ICFjYWxsYmFjayAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKVxuICAgICAgICA/IGNoYXJBdENhbGxiYWNrXG4gICAgICAgIDogY3JlYXRlQ2FsbGJhY2soY2FsbGJhY2ssIHRoaXNBcmcpO1xuXG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICB2YXIgY3VycmVudCA9IGNhbGxiYWNrKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICAgIGlmIChjdXJyZW50IDwgY29tcHV0ZWQpIHtcbiAgICAgICAgICBjb21wdXRlZCA9IGN1cnJlbnQ7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBpZiAoY29sbGVjdGlvbltpbmRleF0gPCByZXN1bHQpIHtcbiAgICAgICAgICByZXN1bHQgPSBjb2xsZWN0aW9uW2luZGV4XTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIFJldHJpZXZlcyB0aGUgdmFsdWUgb2YgYSBzcGVjaWZpZWQgcHJvcGVydHkgZnJvbSBhbGwgZWxlbWVudHMgaW5cbiAgICogdGhlIGBjb2xsZWN0aW9uYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBwbHVjay5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIHByb3BlcnR5IHZhbHVlcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHN0b29nZXMgPSBbXG4gICAqICAgeyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAgfSxcbiAgICogICB7ICduYW1lJzogJ2xhcnJ5JywgJ2FnZSc6IDUwIH0sXG4gICAqICAgeyAnbmFtZSc6ICdjdXJseScsICdhZ2UnOiA2MCB9XG4gICAqIF07XG4gICAqXG4gICAqIF8ucGx1Y2soc3Rvb2dlcywgJ25hbWUnKTtcbiAgICogLy8gPT4gWydtb2UnLCAnbGFycnknLCAnY3VybHknXVxuICAgKi9cbiAgZnVuY3Rpb24gcGx1Y2soY29sbGVjdGlvbiwgcHJvcGVydHkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgcmVzdWx0LnB1c2godmFsdWVbcHJvcGVydHldKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEJvaWxzIGRvd24gYSBgY29sbGVjdGlvbmAgdG8gYSBzaW5nbGUgdmFsdWUuIFRoZSBpbml0aWFsIHN0YXRlIG9mIHRoZVxuICAgKiByZWR1Y3Rpb24gaXMgYGFjY3VtdWxhdG9yYCBhbmQgZWFjaCBzdWNjZXNzaXZlIHN0ZXAgb2YgaXQgc2hvdWxkIGJlIHJldHVybmVkXG4gICAqIGJ5IHRoZSBgY2FsbGJhY2tgLiBUaGUgYGNhbGxiYWNrYCBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCA0XG4gICAqIGFyZ3VtZW50czsgZm9yIGFycmF5cyB0aGV5IGFyZSAoYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyBmb2xkbCwgaW5qZWN0XG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFthY2N1bXVsYXRvcl0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHN1bSA9IF8ucmVkdWNlKFsxLCAyLCAzXSwgZnVuY3Rpb24obWVtbywgbnVtKSB7IHJldHVybiBtZW1vICsgbnVtOyB9KTtcbiAgICogLy8gPT4gNlxuICAgKi9cbiAgZnVuY3Rpb24gcmVkdWNlKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgIHZhciBub2FjY3VtID0gYXJndW1lbnRzLmxlbmd0aCA8IDM7XG4gICAgY2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGFjY3VtdWxhdG9yID0gbm9hY2N1bVxuICAgICAgICA/IChub2FjY3VtID0gZmFsc2UsIHZhbHVlKVxuICAgICAgICA6IGNhbGxiYWNrKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pXG4gICAgfSk7XG4gICAgcmV0dXJuIGFjY3VtdWxhdG9yO1xuICB9XG5cbiAgLyoqXG4gICAqIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIGBfLnJlZHVjZWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGFsaWFzIGZvbGRyXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayBUaGUgZnVuY3Rpb24gY2FsbGVkIHBlciBpdGVyYXRpb24uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFthY2N1bXVsYXRvcl0gSW5pdGlhbCB2YWx1ZSBvZiB0aGUgYWNjdW11bGF0b3IuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFt0aGlzQXJnXSBUaGUgYHRoaXNgIGJpbmRpbmcgb2YgYGNhbGxiYWNrYC5cbiAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSBhY2N1bXVsYXRlZCB2YWx1ZS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGxpc3QgPSBbWzAsIDFdLCBbMiwgM10sIFs0LCA1XV07XG4gICAqIHZhciBmbGF0ID0gXy5yZWR1Y2VSaWdodChsaXN0LCBmdW5jdGlvbihhLCBiKSB7IHJldHVybiBhLmNvbmNhdChiKTsgfSwgW10pO1xuICAgKiAvLyA9PiBbNCwgNSwgMiwgMywgMCwgMV1cbiAgICovXG4gIGZ1bmN0aW9uIHJlZHVjZVJpZ2h0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCBhY2N1bXVsYXRvciwgdGhpc0FyZykge1xuICAgIHZhciBpdGVyYXRlZSA9IGNvbGxlY3Rpb24sXG4gICAgICAgIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDAsXG4gICAgICAgIG5vYWNjdW0gPSBhcmd1bWVudHMubGVuZ3RoIDwgMztcblxuICAgIGlmICh0eXBlb2YgbGVuZ3RoICE9ICdudW1iZXInKSB7XG4gICAgICB2YXIgcHJvcHMgPSBrZXlzKGNvbGxlY3Rpb24pO1xuICAgICAgbGVuZ3RoID0gcHJvcHMubGVuZ3RoO1xuICAgIH0gZWxzZSBpZiAobm9DaGFyQnlJbmRleCAmJiBpc1N0cmluZyhjb2xsZWN0aW9uKSkge1xuICAgICAgaXRlcmF0ZWUgPSBjb2xsZWN0aW9uLnNwbGl0KCcnKTtcbiAgICB9XG4gICAgZm9yRWFjaChjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIGluZGV4ID0gcHJvcHMgPyBwcm9wc1stLWxlbmd0aF0gOiAtLWxlbmd0aDtcbiAgICAgIGFjY3VtdWxhdG9yID0gbm9hY2N1bVxuICAgICAgICA/IChub2FjY3VtID0gZmFsc2UsIGl0ZXJhdGVlW2luZGV4XSlcbiAgICAgICAgOiBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGFjY3VtdWxhdG9yLCBpdGVyYXRlZVtpbmRleF0sIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgICByZXR1cm4gYWNjdW11bGF0b3I7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmZpbHRlcmAsIHRoaXMgbWV0aG9kIHJldHVybnMgdGhlIHZhbHVlcyBvZiBhXG4gICAqIGBjb2xsZWN0aW9uYCB0aGF0IGBjYWxsYmFja2AgZG9lcyAqKm5vdCoqIHJldHVybiB0cnV0aHkgZm9yLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBkaWQgKipub3QqKiBwYXNzIHRoZVxuICAgKiAgY2FsbGJhY2sgY2hlY2suXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBvZGRzID0gXy5yZWplY3QoWzEsIDIsIDMsIDQsIDUsIDZdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAlIDIgPT0gMDsgfSk7XG4gICAqIC8vID0+IFsxLCAzLCA1XVxuICAgKi9cbiAgZnVuY3Rpb24gcmVqZWN0KGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgY2FsbGJhY2sgPSBjcmVhdGVDYWxsYmFjayhjYWxsYmFjaywgdGhpc0FyZyk7XG4gICAgcmV0dXJuIGZpbHRlcihjb2xsZWN0aW9uLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pIHtcbiAgICAgIHJldHVybiAhY2FsbGJhY2sodmFsdWUsIGluZGV4LCBjb2xsZWN0aW9uKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGFuIGFycmF5IG9mIHNodWZmbGVkIGBhcnJheWAgdmFsdWVzLCB1c2luZyBhIHZlcnNpb24gb2YgdGhlXG4gICAqIEZpc2hlci1ZYXRlcyBzaHVmZmxlLiBTZWUgaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9GaXNoZXItWWF0ZXNfc2h1ZmZsZS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIHNodWZmbGUuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBzaHVmZmxlZCBjb2xsZWN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnNodWZmbGUoWzEsIDIsIDMsIDQsIDUsIDZdKTtcbiAgICogLy8gPT4gWzQsIDEsIDYsIDMsIDUsIDJdXG4gICAqL1xuICBmdW5jdGlvbiBzaHVmZmxlKGNvbGxlY3Rpb24pIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkoY29sbGVjdGlvbiA/IGNvbGxlY3Rpb24ubGVuZ3RoIDogMCk7XG5cbiAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICB2YXIgcmFuZCA9IGZsb29yKG5hdGl2ZVJhbmRvbSgpICogKCsraW5kZXggKyAxKSk7XG4gICAgICByZXN1bHRbaW5kZXhdID0gcmVzdWx0W3JhbmRdO1xuICAgICAgcmVzdWx0W3JhbmRdID0gdmFsdWU7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBzaXplIG9mIHRoZSBgY29sbGVjdGlvbmAgYnkgcmV0dXJuaW5nIGBjb2xsZWN0aW9uLmxlbmd0aGAgZm9yIGFycmF5c1xuICAgKiBhbmQgYXJyYXktbGlrZSBvYmplY3RzIG9yIHRoZSBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcyBmb3Igb2JqZWN0cy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGluc3BlY3QuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgYGNvbGxlY3Rpb24ubGVuZ3RoYCBvciBudW1iZXIgb2Ygb3duIGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5zaXplKFsxLCAyXSk7XG4gICAqIC8vID0+IDJcbiAgICpcbiAgICogXy5zaXplKHsgJ29uZSc6IDEsICd0d28nOiAyLCAndGhyZWUnOiAzIH0pO1xuICAgKiAvLyA9PiAzXG4gICAqXG4gICAqIF8uc2l6ZSgnY3VybHknKTtcbiAgICogLy8gPT4gNVxuICAgKi9cbiAgZnVuY3Rpb24gc2l6ZShjb2xsZWN0aW9uKSB7XG4gICAgdmFyIGxlbmd0aCA9IGNvbGxlY3Rpb24gPyBjb2xsZWN0aW9uLmxlbmd0aCA6IDA7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgPyBsZW5ndGggOiBrZXlzKGNvbGxlY3Rpb24pLmxlbmd0aDtcbiAgfVxuXG4gIC8qKlxuICAgKiBDaGVja3MgaWYgdGhlIGBjYWxsYmFja2AgcmV0dXJucyBhIHRydXRoeSB2YWx1ZSBmb3IgKiphbnkqKiBlbGVtZW50IG9mIGFcbiAgICogYGNvbGxlY3Rpb25gLiBUaGUgZnVuY3Rpb24gcmV0dXJucyBhcyBzb29uIGFzIGl0IGZpbmRzIHBhc3NpbmcgdmFsdWUsIGFuZFxuICAgKiBkb2VzIG5vdCBpdGVyYXRlIG92ZXIgdGhlIGVudGlyZSBgY29sbGVjdGlvbmAuIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvXG4gICAqIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleHxrZXksIGNvbGxlY3Rpb24pLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyBhbnlcbiAgICogQGNhdGVnb3J5IENvbGxlY3Rpb25zXG4gICAqIEBwYXJhbSB7QXJyYXl8T2JqZWN0fFN0cmluZ30gY29sbGVjdGlvbiBUaGUgY29sbGVjdGlvbiB0byBpdGVyYXRlIG92ZXIuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtjYWxsYmFjaz1pZGVudGl0eV0gVGhlIGZ1bmN0aW9uIGNhbGxlZCBwZXIgaXRlcmF0aW9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtCb29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBhbnkgZWxlbWVudCBwYXNzZXMgdGhlIGNhbGxiYWNrIGNoZWNrLFxuICAgKiAgZWxzZSBgZmFsc2VgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnNvbWUoW251bGwsIDAsICd5ZXMnLCBmYWxzZV0pO1xuICAgKiAvLyA9PiB0cnVlXG4gICAqL1xuICBmdW5jdGlvbiBzb21lKGNvbGxlY3Rpb24sIGNhbGxiYWNrLCB0aGlzQXJnKSB7XG4gICAgdmFyIHJlc3VsdDtcbiAgICBjYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcblxuICAgIGlmIChpc0FycmF5KGNvbGxlY3Rpb24pKSB7XG4gICAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgICBsZW5ndGggPSBjb2xsZWN0aW9uLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgaWYgKHJlc3VsdCA9IGNhbGxiYWNrKGNvbGxlY3Rpb25baW5kZXhdLCBpbmRleCwgY29sbGVjdGlvbikpIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gIShyZXN1bHQgPSBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gISFyZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSwgc3RhYmxlIHNvcnRlZCBpbiBhc2NlbmRpbmcgb3JkZXIgYnkgdGhlIHJlc3VsdHMgb2ZcbiAgICogcnVubmluZyBlYWNoIGVsZW1lbnQgb2YgYGNvbGxlY3Rpb25gIHRocm91Z2ggYSBgY2FsbGJhY2tgLiBUaGUgYGNhbGxiYWNrYFxuICAgKiBpcyBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCB0aHJlZSBhcmd1bWVudHM7ICh2YWx1ZSwgaW5kZXh8a2V5LCBjb2xsZWN0aW9uKS5cbiAgICogVGhlIGBjYWxsYmFja2AgYXJndW1lbnQgbWF5IGFsc28gYmUgdGhlIG5hbWUgb2YgYSBwcm9wZXJ0eSB0byBzb3J0IGJ5IChlLmcuICdsZW5ndGgnKS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtGdW5jdGlvbnxTdHJpbmd9IGNhbGxiYWNrfHByb3BlcnR5IFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvblxuICAgKiAgb3IgcHJvcGVydHkgbmFtZSB0byBzb3J0IGJ5LlxuICAgKiBAcGFyYW0ge01peGVkfSBbdGhpc0FyZ10gVGhlIGB0aGlzYCBiaW5kaW5nIG9mIGBjYWxsYmFja2AuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBhcnJheSBvZiBzb3J0ZWQgZWxlbWVudHMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiBNYXRoLnNpbihudW0pOyB9KTtcbiAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAqXG4gICAqIF8uc29ydEJ5KFsxLCAyLCAzXSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLnNpbihudW0pOyB9LCBNYXRoKTtcbiAgICogLy8gPT4gWzMsIDEsIDJdXG4gICAqXG4gICAqIF8uc29ydEJ5KFsnbGFycnknLCAnYnJlbmRhbicsICdtb2UnXSwgJ2xlbmd0aCcpO1xuICAgKiAvLyA9PiBbJ21vZScsICdsYXJyeScsICdicmVuZGFuJ11cbiAgICovXG4gIGZ1bmN0aW9uIHNvcnRCeShjb2xsZWN0aW9uLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBjYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICBmb3JFYWNoKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgcmVzdWx0LnB1c2goe1xuICAgICAgICAnY3JpdGVyaWEnOiBjYWxsYmFjayh2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pLFxuICAgICAgICAnaW5kZXgnOiBpbmRleCxcbiAgICAgICAgJ3ZhbHVlJzogdmFsdWVcbiAgICAgIH0pO1xuICAgIH0pO1xuXG4gICAgdmFyIGxlbmd0aCA9IHJlc3VsdC5sZW5ndGg7XG4gICAgcmVzdWx0LnNvcnQoY29tcGFyZUFzY2VuZGluZyk7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICByZXN1bHRbbGVuZ3RoXSA9IHJlc3VsdFtsZW5ndGhdLnZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBgY29sbGVjdGlvbmAsIHRvIGFuIGFycmF5LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBDb2xsZWN0aW9uc1xuICAgKiBAcGFyYW0ge0FycmF5fE9iamVjdHxTdHJpbmd9IGNvbGxlY3Rpb24gVGhlIGNvbGxlY3Rpb24gdG8gY29udmVydC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIHRoZSBuZXcgY29udmVydGVkIGFycmF5LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAoZnVuY3Rpb24oKSB7IHJldHVybiBfLnRvQXJyYXkoYXJndW1lbnRzKS5zbGljZSgxKTsgfSkoMSwgMiwgMywgNCk7XG4gICAqIC8vID0+IFsyLCAzLCA0XVxuICAgKi9cbiAgZnVuY3Rpb24gdG9BcnJheShjb2xsZWN0aW9uKSB7XG4gICAgaWYgKGNvbGxlY3Rpb24gJiYgdHlwZW9mIGNvbGxlY3Rpb24ubGVuZ3RoID09ICdudW1iZXInKSB7XG4gICAgICByZXR1cm4gKG5vQXJyYXlTbGljZU9uU3RyaW5ncyA/IGlzU3RyaW5nKGNvbGxlY3Rpb24pIDogdHlwZW9mIGNvbGxlY3Rpb24gPT0gJ3N0cmluZycpXG4gICAgICAgID8gY29sbGVjdGlvbi5zcGxpdCgnJylcbiAgICAgICAgOiBzbGljZS5jYWxsKGNvbGxlY3Rpb24pO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzKGNvbGxlY3Rpb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4YW1pbmVzIGVhY2ggZWxlbWVudCBpbiBhIGBjb2xsZWN0aW9uYCwgcmV0dXJuaW5nIGFuIGFycmF5IG9mIGFsbCBlbGVtZW50c1xuICAgKiB0aGF0IGNvbnRhaW4gdGhlIGdpdmVuIGBwcm9wZXJ0aWVzYC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ29sbGVjdGlvbnNcbiAgICogQHBhcmFtIHtBcnJheXxPYmplY3R8U3RyaW5nfSBjb2xsZWN0aW9uIFRoZSBjb2xsZWN0aW9uIHRvIGl0ZXJhdGUgb3Zlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnRpZXMgVGhlIG9iamVjdCBvZiBwcm9wZXJ0eSB2YWx1ZXMgdG8gZmlsdGVyIGJ5LlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZWxlbWVudHMgdGhhdCBjb250YWluIHRoZSBnaXZlbiBgcHJvcGVydGllc2AuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBzdG9vZ2VzID0gW1xuICAgKiAgIHsgJ25hbWUnOiAnbW9lJywgJ2FnZSc6IDQwIH0sXG4gICAqICAgeyAnbmFtZSc6ICdsYXJyeScsICdhZ2UnOiA1MCB9LFxuICAgKiAgIHsgJ25hbWUnOiAnY3VybHknLCAnYWdlJzogNjAgfVxuICAgKiBdO1xuICAgKlxuICAgKiBfLndoZXJlKHN0b29nZXMsIHsgJ2FnZSc6IDQwIH0pO1xuICAgKiAvLyA9PiBbeyAnbmFtZSc6ICdtb2UnLCAnYWdlJzogNDAgfV1cbiAgICovXG4gIGZ1bmN0aW9uIHdoZXJlKGNvbGxlY3Rpb24sIHByb3BlcnRpZXMpIHtcbiAgICB2YXIgcHJvcHMgPSBbXTtcbiAgICBmb3JJbihwcm9wZXJ0aWVzLCBmdW5jdGlvbih2YWx1ZSwgcHJvcCkge1xuICAgICAgcHJvcHMucHVzaChwcm9wKTtcbiAgICB9KTtcbiAgICByZXR1cm4gZmlsdGVyKGNvbGxlY3Rpb24sIGZ1bmN0aW9uKG9iamVjdCkge1xuICAgICAgdmFyIGxlbmd0aCA9IHByb3BzLmxlbmd0aDtcbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gb2JqZWN0W3Byb3BzW2xlbmd0aF1dID09PSBwcm9wZXJ0aWVzW3Byb3BzW2xlbmd0aF1dO1xuICAgICAgICBpZiAoIXJlc3VsdCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gISFyZXN1bHQ7XG4gICAgfSk7XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSB3aXRoIGFsbCBmYWxzZXkgdmFsdWVzIG9mIGBhcnJheWAgcmVtb3ZlZC4gVGhlIHZhbHVlc1xuICAgKiBgZmFsc2VgLCBgbnVsbGAsIGAwYCwgYFwiXCJgLCBgdW5kZWZpbmVkYCBhbmQgYE5hTmAgYXJlIGFsbCBmYWxzZXkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gY29tcGFjdC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGZpbHRlcmVkIGFycmF5LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmNvbXBhY3QoWzAsIDEsIGZhbHNlLCAyLCAnJywgM10pO1xuICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBhY3QoYXJyYXkpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgb2YgYGFycmF5YCBlbGVtZW50cyBub3QgcHJlc2VudCBpbiB0aGUgb3RoZXIgYXJyYXlzXG4gICAqIHVzaW5nIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5MSwgYXJyYXkyLCAuLi5dIEFycmF5cyB0byBjaGVjay5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGEgbmV3IGFycmF5IG9mIGBhcnJheWAgZWxlbWVudHMgbm90IHByZXNlbnQgaW4gdGhlXG4gICAqICBvdGhlciBhcnJheXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uZGlmZmVyZW5jZShbMSwgMiwgMywgNCwgNV0sIFs1LCAyLCAxMF0pO1xuICAgKiAvLyA9PiBbMSwgMywgNF1cbiAgICovXG4gIGZ1bmN0aW9uIGRpZmZlcmVuY2UoYXJyYXkpIHtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgbGVuZ3RoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiAwLFxuICAgICAgICBmbGF0dGVuZWQgPSBjb25jYXQuYXBwbHkoYXJyYXlSZWYsIGFyZ3VtZW50cyksXG4gICAgICAgIGNvbnRhaW5zID0gY2FjaGVkQ29udGFpbnMoZmxhdHRlbmVkLCBsZW5ndGgpLFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICB2YXIgdmFsdWUgPSBhcnJheVtpbmRleF07XG4gICAgICBpZiAoIWNvbnRhaW5zKHZhbHVlKSkge1xuICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgZmlyc3QgZWxlbWVudCBvZiB0aGUgYGFycmF5YC4gUGFzcyBgbmAgdG8gcmV0dXJuIHRoZSBmaXJzdCBgbmBcbiAgICogZWxlbWVudHMgb2YgdGhlIGBhcnJheWAuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGFsaWFzIGhlYWQsIHRha2VcbiAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbl0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byByZXR1cm4uXG4gICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBJbnRlcm5hbGx5IHVzZWQgdG8gYWxsb3cgdGhpcyBtZXRob2QgdG8gd29yayB3aXRoXG4gICAqICBvdGhlcnMgbGlrZSBgXy5tYXBgIHdpdGhvdXQgdXNpbmcgdGhlaXIgY2FsbGJhY2sgYGluZGV4YCBhcmd1bWVudCBmb3IgYG5gLlxuICAgKiBAcmV0dXJucyB7TWl4ZWR9IFJldHVybnMgdGhlIGZpcnN0IGVsZW1lbnQgb3IgYW4gYXJyYXkgb2YgdGhlIGZpcnN0IGBuYFxuICAgKiAgZWxlbWVudHMgb2YgYGFycmF5YC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5maXJzdChbNSwgNCwgMywgMiwgMV0pO1xuICAgKiAvLyA9PiA1XG4gICAqL1xuICBmdW5jdGlvbiBmaXJzdChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgIHJldHVybiAobiA9PSBudWxsIHx8IGd1YXJkKSA/IGFycmF5WzBdIDogc2xpY2UuY2FsbChhcnJheSwgMCwgbik7XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEZsYXR0ZW5zIGEgbmVzdGVkIGFycmF5ICh0aGUgbmVzdGluZyBjYW4gYmUgdG8gYW55IGRlcHRoKS4gSWYgYHNoYWxsb3dgIGlzXG4gICAqIHRydXRoeSwgYGFycmF5YCB3aWxsIG9ubHkgYmUgZmxhdHRlbmVkIGEgc2luZ2xlIGxldmVsLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGNvbXBhY3QuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gc2hhbGxvdyBBIGZsYWcgdG8gaW5kaWNhdGUgb25seSBmbGF0dGVuaW5nIGEgc2luZ2xlIGxldmVsLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgZmxhdHRlbmVkIGFycmF5LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmZsYXR0ZW4oWzEsIFsyXSwgWzMsIFtbNF1dXV0pO1xuICAgKiAvLyA9PiBbMSwgMiwgMywgNF07XG4gICAqXG4gICAqIF8uZmxhdHRlbihbMSwgWzJdLCBbMywgW1s0XV1dXSwgdHJ1ZSk7XG4gICAqIC8vID0+IFsxLCAyLCAzLCBbWzRdXV07XG4gICAqL1xuICBmdW5jdGlvbiBmbGF0dGVuKGFycmF5LCBzaGFsbG93KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMCxcbiAgICAgICAgcmVzdWx0ID0gW107XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaW5kZXhdO1xuXG4gICAgICAvLyByZWN1cnNpdmVseSBmbGF0dGVuIGFycmF5cyAoc3VzY2VwdGlibGUgdG8gY2FsbCBzdGFjayBsaW1pdHMpXG4gICAgICBpZiAoaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgcHVzaC5hcHBseShyZXN1bHQsIHNoYWxsb3cgPyB2YWx1ZSA6IGZsYXR0ZW4odmFsdWUpKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgZmlyc3Qgb2NjdXJyZW5jZSBvZiBgdmFsdWVgIGlzIGZvdW5kIHVzaW5nXG4gICAqIHN0cmljdCBlcXVhbGl0eSBmb3IgY29tcGFyaXNvbnMsIGkuZS4gYD09PWAuIElmIHRoZSBgYXJyYXlgIGlzIGFscmVhZHlcbiAgICogc29ydGVkLCBwYXNzaW5nIGB0cnVlYCBmb3IgYGZyb21JbmRleGAgd2lsbCBydW4gYSBmYXN0ZXIgYmluYXJ5IHNlYXJjaC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBzZWFyY2guXG4gICAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlIFRoZSB2YWx1ZSB0byBzZWFyY2ggZm9yLlxuICAgKiBAcGFyYW0ge0Jvb2xlYW58TnVtYmVyfSBbZnJvbUluZGV4PTBdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbSBvciBgdHJ1ZWAgdG9cbiAgICogIHBlcmZvcm0gYSBiaW5hcnkgc2VhcmNoIG9uIGEgc29ydGVkIGBhcnJheWAuXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgdGhlIGluZGV4IG9mIHRoZSBtYXRjaGVkIHZhbHVlIG9yIGAtMWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgKiAvLyA9PiAxXG4gICAqXG4gICAqIF8uaW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIsIDMpO1xuICAgKiAvLyA9PiA0XG4gICAqXG4gICAqIF8uaW5kZXhPZihbMSwgMSwgMiwgMiwgMywgM10sIDIsIHRydWUpO1xuICAgKiAvLyA9PiAyXG4gICAqL1xuICBmdW5jdGlvbiBpbmRleE9mKGFycmF5LCB2YWx1ZSwgZnJvbUluZGV4KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gYXJyYXkubGVuZ3RoIDogMDtcblxuICAgIGlmICh0eXBlb2YgZnJvbUluZGV4ID09ICdudW1iZXInKSB7XG4gICAgICBpbmRleCA9IChmcm9tSW5kZXggPCAwID8gbmF0aXZlTWF4KDAsIGxlbmd0aCArIGZyb21JbmRleCkgOiBmcm9tSW5kZXggfHwgMCkgLSAxO1xuICAgIH0gZWxzZSBpZiAoZnJvbUluZGV4KSB7XG4gICAgICBpbmRleCA9IHNvcnRlZEluZGV4KGFycmF5LCB2YWx1ZSk7XG4gICAgICByZXR1cm4gYXJyYXlbaW5kZXhdID09PSB2YWx1ZSA/IGluZGV4IDogLTE7XG4gICAgfVxuICAgIHdoaWxlICgrK2luZGV4IDwgbGVuZ3RoKSB7XG4gICAgICBpZiAoYXJyYXlbaW5kZXhdID09PSB2YWx1ZSkge1xuICAgICAgICByZXR1cm4gaW5kZXg7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiAtMTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIGFsbCBidXQgdGhlIGxhc3QgZWxlbWVudCBvZiBgYXJyYXlgLiBQYXNzIGBuYCB0byBleGNsdWRlIHRoZSBsYXN0IGBuYFxuICAgKiBlbGVtZW50cyBmcm9tIHRoZSByZXN1bHQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcXVlcnkuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbj0xXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIGV4Y2x1ZGUuXG4gICAqIEBwYXJhbS0ge09iamVjdH0gW2d1YXJkXSBJbnRlcm5hbGx5IHVzZWQgdG8gYWxsb3cgdGhpcyBtZXRob2QgdG8gd29yayB3aXRoXG4gICAqICBvdGhlcnMgbGlrZSBgXy5tYXBgIHdpdGhvdXQgdXNpbmcgdGhlaXIgY2FsbGJhY2sgYGluZGV4YCBhcmd1bWVudCBmb3IgYG5gLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYWxsIGJ1dCB0aGUgbGFzdCBlbGVtZW50IG9yIGBuYCBlbGVtZW50cyBvZiBgYXJyYXlgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmluaXRpYWwoWzMsIDIsIDFdKTtcbiAgICogLy8gPT4gWzMsIDJdXG4gICAqL1xuICBmdW5jdGlvbiBpbml0aWFsKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBhcnJheVxuICAgICAgPyBzbGljZS5jYWxsKGFycmF5LCAwLCAtKChuID09IG51bGwgfHwgZ3VhcmQpID8gMSA6IG4pKVxuICAgICAgOiBbXTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDb21wdXRlcyB0aGUgaW50ZXJzZWN0aW9uIG9mIGFsbCB0aGUgcGFzc2VkLWluIGFycmF5cyB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICogZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5MSwgYXJyYXkyLCAuLi5dIEFycmF5cyB0byBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgdW5pcXVlIGVsZW1lbnRzLCBpbiBvcmRlciwgdGhhdCBhcmVcbiAgICogIHByZXNlbnQgaW4gKiphbGwqKiBvZiB0aGUgYXJyYXlzLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmludGVyc2VjdGlvbihbMSwgMiwgM10sIFsxMDEsIDIsIDEsIDEwXSwgWzIsIDFdKTtcbiAgICogLy8gPT4gWzEsIDJdXG4gICAqL1xuICBmdW5jdGlvbiBpbnRlcnNlY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgYXJncyA9IGFyZ3VtZW50cyxcbiAgICAgICAgYXJnc0xlbmd0aCA9IGFyZ3MubGVuZ3RoLFxuICAgICAgICBjYWNoZSA9IHt9LFxuICAgICAgICByZXN1bHQgPSBbXTtcblxuICAgIGZvckVhY2goYXJyYXksIGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgICBpZiAoaW5kZXhPZihyZXN1bHQsIHZhbHVlKSA8IDApIHtcbiAgICAgICAgdmFyIGxlbmd0aCA9IGFyZ3NMZW5ndGg7XG4gICAgICAgIHdoaWxlICgtLWxlbmd0aCkge1xuICAgICAgICAgIGlmICghKGNhY2hlW2xlbmd0aF0gfHwgKGNhY2hlW2xlbmd0aF0gPSBjYWNoZWRDb250YWlucyhhcmdzW2xlbmd0aF0pKSkodmFsdWUpKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEdldHMgdGhlIGxhc3QgZWxlbWVudCBvZiB0aGUgYGFycmF5YC4gUGFzcyBgbmAgdG8gcmV0dXJuIHRoZSBsYXN0IGBuYFxuICAgKiBlbGVtZW50cyBvZiB0aGUgYGFycmF5YC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQXJyYXlzXG4gICAqIEBwYXJhbSB7QXJyYXl9IGFycmF5IFRoZSBhcnJheSB0byBxdWVyeS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtuXSBUaGUgbnVtYmVyIG9mIGVsZW1lbnRzIHRvIHJldHVybi5cbiAgICogQHBhcmFtLSB7T2JqZWN0fSBbZ3VhcmRdIEludGVybmFsbHkgdXNlZCB0byBhbGxvdyB0aGlzIG1ldGhvZCB0byB3b3JrIHdpdGhcbiAgICogIG90aGVycyBsaWtlIGBfLm1hcGAgd2l0aG91dCB1c2luZyB0aGVpciBjYWxsYmFjayBgaW5kZXhgIGFyZ3VtZW50IGZvciBgbmAuXG4gICAqIEByZXR1cm5zIHtNaXhlZH0gUmV0dXJucyB0aGUgbGFzdCBlbGVtZW50IG9yIGFuIGFycmF5IG9mIHRoZSBsYXN0IGBuYFxuICAgKiAgZWxlbWVudHMgb2YgYGFycmF5YC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5sYXN0KFszLCAyLCAxXSk7XG4gICAqIC8vID0+IDFcbiAgICovXG4gIGZ1bmN0aW9uIGxhc3QoYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgaWYgKGFycmF5KSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJyYXkubGVuZ3RoO1xuICAgICAgcmV0dXJuIChuID09IG51bGwgfHwgZ3VhcmQpID8gYXJyYXlbbGVuZ3RoIC0gMV0gOiBzbGljZS5jYWxsKGFycmF5LCAtbiB8fCBsZW5ndGgpO1xuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBHZXRzIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgbGFzdCBvY2N1cnJlbmNlIG9mIGB2YWx1ZWAgaXMgZm91bmQgdXNpbmcgc3RyaWN0XG4gICAqIGVxdWFsaXR5IGZvciBjb21wYXJpc29ucywgaS5lLiBgPT09YC4gSWYgYGZyb21JbmRleGAgaXMgbmVnYXRpdmUsIGl0IGlzIHVzZWRcbiAgICogYXMgdGhlIG9mZnNldCBmcm9tIHRoZSBlbmQgb2YgdGhlIGNvbGxlY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gc2VhcmNoLlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gc2VhcmNoIGZvci5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IFtmcm9tSW5kZXg9YXJyYXkubGVuZ3RoLTFdIFRoZSBpbmRleCB0byBzZWFyY2ggZnJvbS5cbiAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyB0aGUgaW5kZXggb2YgdGhlIG1hdGNoZWQgdmFsdWUgb3IgYC0xYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5sYXN0SW5kZXhPZihbMSwgMiwgMywgMSwgMiwgM10sIDIpO1xuICAgKiAvLyA9PiA0XG4gICAqXG4gICAqIF8ubGFzdEluZGV4T2YoWzEsIDIsIDMsIDEsIDIsIDNdLCAyLCAzKTtcbiAgICogLy8gPT4gMVxuICAgKi9cbiAgZnVuY3Rpb24gbGFzdEluZGV4T2YoYXJyYXksIHZhbHVlLCBmcm9tSW5kZXgpIHtcbiAgICB2YXIgaW5kZXggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDA7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggPT0gJ251bWJlcicpIHtcbiAgICAgIGluZGV4ID0gKGZyb21JbmRleCA8IDAgPyBuYXRpdmVNYXgoMCwgaW5kZXggKyBmcm9tSW5kZXgpIDogbmF0aXZlTWluKGZyb21JbmRleCwgaW5kZXggLSAxKSkgKyAxO1xuICAgIH1cbiAgICB3aGlsZSAoaW5kZXgtLSkge1xuICAgICAgaWYgKGFycmF5W2luZGV4XSA9PT0gdmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gLTE7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBvYmplY3QgY29tcG9zZWQgZnJvbSBhcnJheXMgb2YgYGtleXNgIGFuZCBgdmFsdWVzYC4gUGFzcyBlaXRoZXJcbiAgICogYSBzaW5nbGUgdHdvIGRpbWVuc2lvbmFsIGFycmF5LCBpLmUuIGBbW2tleTEsIHZhbHVlMV0sIFtrZXkyLCB2YWx1ZTJdXWAsIG9yXG4gICAqIHR3byBhcnJheXMsIG9uZSBvZiBga2V5c2AgYW5kIG9uZSBvZiBjb3JyZXNwb25kaW5nIGB2YWx1ZXNgLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0ga2V5cyBUaGUgYXJyYXkgb2Yga2V5cy5cbiAgICogQHBhcmFtIHtBcnJheX0gW3ZhbHVlcz1bXV0gVGhlIGFycmF5IG9mIHZhbHVlcy5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBhbiBvYmplY3QgY29tcG9zZWQgb2YgdGhlIGdpdmVuIGtleXMgYW5kXG4gICAqICBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5vYmplY3QoWydtb2UnLCAnbGFycnknLCAnY3VybHknXSwgWzMwLCA0MCwgNTBdKTtcbiAgICogLy8gPT4geyAnbW9lJzogMzAsICdsYXJyeSc6IDQwLCAnY3VybHknOiA1MCB9XG4gICAqL1xuICBmdW5jdGlvbiBvYmplY3Qoa2V5cywgdmFsdWVzKSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGtleXMgPyBrZXlzLmxlbmd0aCA6IDAsXG4gICAgICAgIHJlc3VsdCA9IHt9O1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2luZGV4XTtcbiAgICAgIGlmICh2YWx1ZXMpIHtcbiAgICAgICAgcmVzdWx0W2tleV0gPSB2YWx1ZXNbaW5kZXhdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcmVzdWx0W2tleVswXV0gPSBrZXlbMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhbiBhcnJheSBvZiBudW1iZXJzIChwb3NpdGl2ZSBhbmQvb3IgbmVnYXRpdmUpIHByb2dyZXNzaW5nIGZyb21cbiAgICogYHN0YXJ0YCB1cCB0byBidXQgbm90IGluY2x1ZGluZyBgc3RvcGAuIFRoaXMgbWV0aG9kIGlzIGEgcG9ydCBvZiBQeXRob24nc1xuICAgKiBgcmFuZ2UoKWAgZnVuY3Rpb24uIFNlZSBodHRwOi8vZG9jcy5weXRob24ub3JnL2xpYnJhcnkvZnVuY3Rpb25zLmh0bWwjcmFuZ2UuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgKiBAcGFyYW0ge051bWJlcn0gW3N0YXJ0PTBdIFRoZSBzdGFydCBvZiB0aGUgcmFuZ2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBlbmQgVGhlIGVuZCBvZiB0aGUgcmFuZ2UuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbc3RlcD0xXSBUaGUgdmFsdWUgdG8gaW5jcmVtZW50IG9yIGRlc2NyZW1lbnQgYnkuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyByYW5nZSBhcnJheS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5yYW5nZSgxMCk7XG4gICAqIC8vID0+IFswLCAxLCAyLCAzLCA0LCA1LCA2LCA3LCA4LCA5XVxuICAgKlxuICAgKiBfLnJhbmdlKDEsIDExKTtcbiAgICogLy8gPT4gWzEsIDIsIDMsIDQsIDUsIDYsIDcsIDgsIDksIDEwXVxuICAgKlxuICAgKiBfLnJhbmdlKDAsIDMwLCA1KTtcbiAgICogLy8gPT4gWzAsIDUsIDEwLCAxNSwgMjAsIDI1XVxuICAgKlxuICAgKiBfLnJhbmdlKDAsIC0xMCwgLTEpO1xuICAgKiAvLyA9PiBbMCwgLTEsIC0yLCAtMywgLTQsIC01LCAtNiwgLTcsIC04LCAtOV1cbiAgICpcbiAgICogXy5yYW5nZSgwKTtcbiAgICogLy8gPT4gW11cbiAgICovXG4gIGZ1bmN0aW9uIHJhbmdlKHN0YXJ0LCBlbmQsIHN0ZXApIHtcbiAgICBzdGFydCA9ICtzdGFydCB8fCAwO1xuICAgIHN0ZXAgPSArc3RlcCB8fCAxO1xuXG4gICAgaWYgKGVuZCA9PSBudWxsKSB7XG4gICAgICBlbmQgPSBzdGFydDtcbiAgICAgIHN0YXJ0ID0gMDtcbiAgICB9XG4gICAgLy8gdXNlIGBBcnJheShsZW5ndGgpYCBzbyBWOCB3aWxsIGF2b2lkIHRoZSBzbG93ZXIgXCJkaWN0aW9uYXJ5XCIgbW9kZVxuICAgIC8vIGh0dHA6Ly93d3cueW91dHViZS5jb20vd2F0Y2g/dj1YQXFJcEdVOFpaayN0PTE2bTI3c1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBuYXRpdmVNYXgoMCwgY2VpbCgoZW5kIC0gc3RhcnQpIC8gc3RlcCkpLFxuICAgICAgICByZXN1bHQgPSBBcnJheShsZW5ndGgpO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBzdGFydDtcbiAgICAgIHN0YXJ0ICs9IHN0ZXA7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICogVGhlIG9wcG9zaXRlIG9mIGBfLmluaXRpYWxgLCB0aGlzIG1ldGhvZCBnZXRzIGFsbCBidXQgdGhlIGZpcnN0IHZhbHVlIG9mXG4gICAqIGBhcnJheWAuIFBhc3MgYG5gIHRvIGV4Y2x1ZGUgdGhlIGZpcnN0IGBuYCB2YWx1ZXMgZnJvbSB0aGUgcmVzdWx0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyBkcm9wLCB0YWlsXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIHF1ZXJ5LlxuICAgKiBAcGFyYW0ge051bWJlcn0gW249MV0gVGhlIG51bWJlciBvZiBlbGVtZW50cyB0byBleGNsdWRlLlxuICAgKiBAcGFyYW0tIHtPYmplY3R9IFtndWFyZF0gSW50ZXJuYWxseSB1c2VkIHRvIGFsbG93IHRoaXMgbWV0aG9kIHRvIHdvcmsgd2l0aFxuICAgKiAgb3RoZXJzIGxpa2UgYF8ubWFwYCB3aXRob3V0IHVzaW5nIHRoZWlyIGNhbGxiYWNrIGBpbmRleGAgYXJndW1lbnQgZm9yIGBuYC5cbiAgICogQHJldHVybnMge0FycmF5fSBSZXR1cm5zIGFsbCBidXQgdGhlIGZpcnN0IHZhbHVlIG9yIGBuYCB2YWx1ZXMgb2YgYGFycmF5YC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5yZXN0KFszLCAyLCAxXSk7XG4gICAqIC8vID0+IFsyLCAxXVxuICAgKi9cbiAgZnVuY3Rpb24gcmVzdChhcnJheSwgbiwgZ3VhcmQpIHtcbiAgICByZXR1cm4gYXJyYXlcbiAgICAgID8gc2xpY2UuY2FsbChhcnJheSwgKG4gPT0gbnVsbCB8fCBndWFyZCkgPyAxIDogbilcbiAgICAgIDogW107XG4gIH1cblxuICAvKipcbiAgICogVXNlcyBhIGJpbmFyeSBzZWFyY2ggdG8gZGV0ZXJtaW5lIHRoZSBzbWFsbGVzdCBpbmRleCBhdCB3aGljaCB0aGUgYHZhbHVlYFxuICAgKiBzaG91bGQgYmUgaW5zZXJ0ZWQgaW50byBgYXJyYXlgIGluIG9yZGVyIHRvIG1haW50YWluIHRoZSBzb3J0IG9yZGVyIG9mIHRoZVxuICAgKiBzb3J0ZWQgYGFycmF5YC4gSWYgYGNhbGxiYWNrYCBpcyBwYXNzZWQsIGl0IHdpbGwgYmUgZXhlY3V0ZWQgZm9yIGB2YWx1ZWAgYW5kXG4gICAqIGVhY2ggZWxlbWVudCBpbiBgYXJyYXlgIHRvIGNvbXB1dGUgdGhlaXIgc29ydCByYW5raW5nLiBUaGUgYGNhbGxiYWNrYCBpc1xuICAgKiBib3VuZCB0byBgdGhpc0FyZ2AgYW5kIGludm9rZWQgd2l0aCBvbmUgYXJndW1lbnQ7ICh2YWx1ZSkuIFRoZSBgY2FsbGJhY2tgXG4gICAqIGFyZ3VtZW50IG1heSBhbHNvIGJlIHRoZSBuYW1lIG9mIGEgcHJvcGVydHkgdG8gb3JkZXIgYnkuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gaXRlcmF0ZSBvdmVyLlxuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gZXZhbHVhdGUuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb258U3RyaW5nfSBbY2FsbGJhY2s9aWRlbnRpdHl8cHJvcGVydHldIFRoZSBmdW5jdGlvbiBjYWxsZWRcbiAgICogIHBlciBpdGVyYXRpb24gb3IgcHJvcGVydHkgbmFtZSB0byBvcmRlciBieS5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIHRoZSBpbmRleCBhdCB3aGljaCB0aGUgdmFsdWUgc2hvdWxkIGJlIGluc2VydGVkXG4gICAqICBpbnRvIGBhcnJheWAuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uc29ydGVkSW5kZXgoWzIwLCAzMCwgNTBdLCA0MCk7XG4gICAqIC8vID0+IDJcbiAgICpcbiAgICogXy5zb3J0ZWRJbmRleChbeyAneCc6IDIwIH0sIHsgJ3gnOiAzMCB9LCB7ICd4JzogNTAgfV0sIHsgJ3gnOiA0MCB9LCAneCcpO1xuICAgKiAvLyA9PiAyXG4gICAqXG4gICAqIHZhciBkaWN0ID0ge1xuICAgKiAgICd3b3JkVG9OdW1iZXInOiB7ICd0d2VudHknOiAyMCwgJ3RoaXJ0eSc6IDMwLCAnZm91cnR5JzogNDAsICdmaWZ0eSc6IDUwIH1cbiAgICogfTtcbiAgICpcbiAgICogXy5zb3J0ZWRJbmRleChbJ3R3ZW50eScsICd0aGlydHknLCAnZmlmdHknXSwgJ2ZvdXJ0eScsIGZ1bmN0aW9uKHdvcmQpIHtcbiAgICogICByZXR1cm4gZGljdC53b3JkVG9OdW1iZXJbd29yZF07XG4gICAqIH0pO1xuICAgKiAvLyA9PiAyXG4gICAqXG4gICAqIF8uc29ydGVkSW5kZXgoWyd0d2VudHknLCAndGhpcnR5JywgJ2ZpZnR5J10sICdmb3VydHknLCBmdW5jdGlvbih3b3JkKSB7XG4gICAqICAgcmV0dXJuIHRoaXMud29yZFRvTnVtYmVyW3dvcmRdO1xuICAgKiB9LCBkaWN0KTtcbiAgICogLy8gPT4gMlxuICAgKi9cbiAgZnVuY3Rpb24gc29ydGVkSW5kZXgoYXJyYXksIHZhbHVlLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciBsb3cgPSAwLFxuICAgICAgICBoaWdoID0gYXJyYXkgPyBhcnJheS5sZW5ndGggOiBsb3c7XG5cbiAgICAvLyBleHBsaWNpdGx5IHJlZmVyZW5jZSBgaWRlbnRpdHlgIGZvciBiZXR0ZXIgZW5naW5lIGlubGluaW5nXG4gICAgY2FsbGJhY2sgPSBjYWxsYmFjayA/IGNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKSA6IGlkZW50aXR5O1xuICAgIHZhbHVlID0gY2FsbGJhY2sodmFsdWUpO1xuICAgIHdoaWxlIChsb3cgPCBoaWdoKSB7XG4gICAgICB2YXIgbWlkID0gKGxvdyArIGhpZ2gpID4+PiAxO1xuICAgICAgY2FsbGJhY2soYXJyYXlbbWlkXSkgPCB2YWx1ZVxuICAgICAgICA/IGxvdyA9IG1pZCArIDFcbiAgICAgICAgOiBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9XG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSB1bmlvbiBvZiB0aGUgcGFzc2VkLWluIGFycmF5cyB1c2luZyBzdHJpY3QgZXF1YWxpdHkgZm9yXG4gICAqIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5MSwgYXJyYXkyLCAuLi5dIEFycmF5cyB0byBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgdW5pcXVlIHZhbHVlcywgaW4gb3JkZXIsIHRoYXQgYXJlXG4gICAqICBwcmVzZW50IGluIG9uZSBvciBtb3JlIG9mIHRoZSBhcnJheXMuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8udW5pb24oWzEsIDIsIDNdLCBbMTAxLCAyLCAxLCAxMF0sIFsyLCAxXSk7XG4gICAqIC8vID0+IFsxLCAyLCAzLCAxMDEsIDEwXVxuICAgKi9cbiAgZnVuY3Rpb24gdW5pb24oKSB7XG4gICAgcmV0dXJuIHVuaXEoY29uY2F0LmFwcGx5KGFycmF5UmVmLCBhcmd1bWVudHMpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZHVwbGljYXRlLXZhbHVlLWZyZWUgdmVyc2lvbiBvZiB0aGUgYGFycmF5YCB1c2luZyBzdHJpY3QgZXF1YWxpdHlcbiAgICogZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLiBJZiB0aGUgYGFycmF5YCBpcyBhbHJlYWR5IHNvcnRlZCwgcGFzc2luZyBgdHJ1ZWBcbiAgICogZm9yIGBpc1NvcnRlZGAgd2lsbCBydW4gYSBmYXN0ZXIgYWxnb3JpdGhtLiBJZiBgY2FsbGJhY2tgIGlzIHBhc3NlZCwgZWFjaFxuICAgKiBlbGVtZW50IG9mIGBhcnJheWAgaXMgcGFzc2VkIHRocm91Z2ggYSBjYWxsYmFja2AgYmVmb3JlIHVuaXF1ZW5lc3MgaXMgY29tcHV0ZWQuXG4gICAqIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZCB3aXRoIHRocmVlIGFyZ3VtZW50czsgKHZhbHVlLCBpbmRleCwgYXJyYXkpLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBhbGlhcyB1bmlxdWVcbiAgICogQGNhdGVnb3J5IEFycmF5c1xuICAgKiBAcGFyYW0ge0FycmF5fSBhcnJheSBUaGUgYXJyYXkgdG8gcHJvY2Vzcy5cbiAgICogQHBhcmFtIHtCb29sZWFufSBbaXNTb3J0ZWQ9ZmFsc2VdIEEgZmxhZyB0byBpbmRpY2F0ZSB0aGF0IHRoZSBgYXJyYXlgIGlzIGFscmVhZHkgc29ydGVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbY2FsbGJhY2s9aWRlbnRpdHldIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBkdXBsaWNhdGUtdmFsdWUtZnJlZSBhcnJheS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy51bmlxKFsxLCAyLCAxLCAzLCAxXSk7XG4gICAqIC8vID0+IFsxLCAyLCAzXVxuICAgKlxuICAgKiBfLnVuaXEoWzEsIDEsIDIsIDIsIDNdLCB0cnVlKTtcbiAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAqXG4gICAqIF8udW5pcShbMSwgMiwgMS41LCAzLCAyLjVdLCBmdW5jdGlvbihudW0pIHsgcmV0dXJuIE1hdGguZmxvb3IobnVtKTsgfSk7XG4gICAqIC8vID0+IFsxLCAyLCAzXVxuICAgKlxuICAgKiBfLnVuaXEoWzEsIDIsIDEuNSwgMywgMi41XSwgZnVuY3Rpb24obnVtKSB7IHJldHVybiB0aGlzLmZsb29yKG51bSk7IH0sIE1hdGgpO1xuICAgKiAvLyA9PiBbMSwgMiwgM11cbiAgICovXG4gIGZ1bmN0aW9uIHVuaXEoYXJyYXksIGlzU29ydGVkLCBjYWxsYmFjaywgdGhpc0FyZykge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgIHJlc3VsdCA9IFtdLFxuICAgICAgICBzZWVuID0gcmVzdWx0O1xuXG4gICAgLy8ganVnZ2xlIGFyZ3VtZW50c1xuICAgIGlmICh0eXBlb2YgaXNTb3J0ZWQgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgdGhpc0FyZyA9IGNhbGxiYWNrO1xuICAgICAgY2FsbGJhY2sgPSBpc1NvcnRlZDtcbiAgICAgIGlzU29ydGVkID0gZmFsc2U7XG4gICAgfVxuICAgIC8vIGluaXQgdmFsdWUgY2FjaGUgZm9yIGxhcmdlIGFycmF5c1xuICAgIHZhciBpc0xhcmdlID0gIWlzU29ydGVkICYmIGxlbmd0aCA+IDc0O1xuICAgIGlmIChpc0xhcmdlKSB7XG4gICAgICB2YXIgY2FjaGUgPSB7fTtcbiAgICB9XG4gICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICBzZWVuID0gW107XG4gICAgICBjYWxsYmFjayA9IGNyZWF0ZUNhbGxiYWNrKGNhbGxiYWNrLCB0aGlzQXJnKTtcbiAgICB9XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XSxcbiAgICAgICAgICBjb21wdXRlZCA9IGNhbGxiYWNrID8gY2FsbGJhY2sodmFsdWUsIGluZGV4LCBhcnJheSkgOiB2YWx1ZTtcblxuICAgICAgaWYgKGlzTGFyZ2UpIHtcbiAgICAgICAgLy8gbWFudWFsbHkgY29lcmNlIGBjb21wdXRlZGAgdG8gYSBzdHJpbmcgYmVjYXVzZSBgaGFzT3duUHJvcGVydHlgLCBpblxuICAgICAgICAvLyBzb21lIG9sZGVyIHZlcnNpb25zIG9mIEZpcmVmb3gsIGNvZXJjZXMgb2JqZWN0cyBpbmNvcnJlY3RseVxuICAgICAgICBzZWVuID0gaGFzT3duUHJvcGVydHkuY2FsbChjYWNoZSwgY29tcHV0ZWQgKyAnJykgPyBjYWNoZVtjb21wdXRlZF0gOiAoY2FjaGVbY29tcHV0ZWRdID0gW10pO1xuICAgICAgfVxuICAgICAgaWYgKGlzU29ydGVkXG4gICAgICAgICAgICA/ICFpbmRleCB8fCBzZWVuW3NlZW4ubGVuZ3RoIC0gMV0gIT09IGNvbXB1dGVkXG4gICAgICAgICAgICA6IGluZGV4T2Yoc2VlbiwgY29tcHV0ZWQpIDwgMFxuICAgICAgICAgICkge1xuICAgICAgICBpZiAoY2FsbGJhY2sgfHwgaXNMYXJnZSkge1xuICAgICAgICAgIHNlZW4ucHVzaChjb21wdXRlZCk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gYXJyYXkgd2l0aCBhbGwgb2NjdXJyZW5jZXMgb2YgdGhlIHBhc3NlZCB2YWx1ZXMgcmVtb3ZlZCB1c2luZ1xuICAgKiBzdHJpY3QgZXF1YWxpdHkgZm9yIGNvbXBhcmlzb25zLCBpLmUuIGA9PT1gLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gYXJyYXkgVGhlIGFycmF5IHRvIGZpbHRlci5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3ZhbHVlMSwgdmFsdWUyLCAuLi5dIFZhbHVlcyB0byByZW1vdmUuXG4gICAqIEByZXR1cm5zIHtBcnJheX0gUmV0dXJucyBhIG5ldyBmaWx0ZXJlZCBhcnJheS5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy53aXRob3V0KFsxLCAyLCAxLCAwLCAzLCAxLCA0XSwgMCwgMSk7XG4gICAqIC8vID0+IFsyLCAzLCA0XVxuICAgKi9cbiAgZnVuY3Rpb24gd2l0aG91dChhcnJheSkge1xuICAgIHZhciBpbmRleCA9IC0xLFxuICAgICAgICBsZW5ndGggPSBhcnJheSA/IGFycmF5Lmxlbmd0aCA6IDAsXG4gICAgICAgIGNvbnRhaW5zID0gY2FjaGVkQ29udGFpbnMoYXJndW1lbnRzLCAxLCAyMCksXG4gICAgICAgIHJlc3VsdCA9IFtdO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGFycmF5W2luZGV4XTtcbiAgICAgIGlmICghY29udGFpbnModmFsdWUpKSB7XG4gICAgICAgIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBHcm91cHMgdGhlIGVsZW1lbnRzIG9mIGVhY2ggYXJyYXkgYXQgdGhlaXIgY29ycmVzcG9uZGluZyBpbmRleGVzLiBVc2VmdWwgZm9yXG4gICAqIHNlcGFyYXRlIGRhdGEgc291cmNlcyB0aGF0IGFyZSBjb29yZGluYXRlZCB0aHJvdWdoIG1hdGNoaW5nIGFycmF5IGluZGV4ZXMuXG4gICAqIEZvciBhIG1hdHJpeCBvZiBuZXN0ZWQgYXJyYXlzLCBgXy56aXAuYXBwbHkoLi4uKWAgY2FuIHRyYW5zcG9zZSB0aGUgbWF0cml4XG4gICAqIGluIGEgc2ltaWxhciBmYXNoaW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBBcnJheXNcbiAgICogQHBhcmFtIHtBcnJheX0gW2FycmF5MSwgYXJyYXkyLCAuLi5dIEFycmF5cyB0byBwcm9jZXNzLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgZ3JvdXBlZCBlbGVtZW50cy5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy56aXAoWydtb2UnLCAnbGFycnknLCAnY3VybHknXSwgWzMwLCA0MCwgNTBdLCBbdHJ1ZSwgZmFsc2UsIGZhbHNlXSk7XG4gICAqIC8vID0+IFtbJ21vZScsIDMwLCB0cnVlXSwgWydsYXJyeScsIDQwLCBmYWxzZV0sIFsnY3VybHknLCA1MCwgZmFsc2VdXVxuICAgKi9cbiAgZnVuY3Rpb24gemlwKGFycmF5KSB7XG4gICAgdmFyIGluZGV4ID0gLTEsXG4gICAgICAgIGxlbmd0aCA9IGFycmF5ID8gbWF4KHBsdWNrKGFyZ3VtZW50cywgJ2xlbmd0aCcpKSA6IDAsXG4gICAgICAgIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IGxlbmd0aCkge1xuICAgICAgcmVzdWx0W2luZGV4XSA9IHBsdWNrKGFyZ3VtZW50cywgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IGlzIHJlc3RyaWN0ZWQgdG8gZXhlY3V0aW5nIGBmdW5jYCBvbmx5IGFmdGVyIGl0IGlzXG4gICAqIGNhbGxlZCBgbmAgdGltZXMuIFRoZSBgZnVuY2AgaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlXG4gICAqIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgKiBAcGFyYW0ge051bWJlcn0gbiBUaGUgbnVtYmVyIG9mIHRpbWVzIHRoZSBmdW5jdGlvbiBtdXN0IGJlIGNhbGxlZCBiZWZvcmVcbiAgICogaXQgaXMgZXhlY3V0ZWQuXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgcmVuZGVyTm90ZXMgPSBfLmFmdGVyKG5vdGVzLmxlbmd0aCwgcmVuZGVyKTtcbiAgICogXy5mb3JFYWNoKG5vdGVzLCBmdW5jdGlvbihub3RlKSB7XG4gICAqICAgbm90ZS5hc3luY1NhdmUoeyAnc3VjY2Vzcyc6IHJlbmRlck5vdGVzIH0pO1xuICAgKiB9KTtcbiAgICogLy8gYHJlbmRlck5vdGVzYCBpcyBydW4gb25jZSwgYWZ0ZXIgYWxsIG5vdGVzIGhhdmUgc2F2ZWRcbiAgICovXG4gIGZ1bmN0aW9uIGFmdGVyKG4sIGZ1bmMpIHtcbiAgICBpZiAobiA8IDEpIHtcbiAgICAgIHJldHVybiBmdW5jKCk7XG4gICAgfVxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLW4gPCAxKSB7XG4gICAgICAgIHJldHVybiBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgICB9XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggdGhlIGB0aGlzYFxuICAgKiBiaW5kaW5nIG9mIGB0aGlzQXJnYCBhbmQgcHJlcGVuZHMgYW55IGFkZGl0aW9uYWwgYGJpbmRgIGFyZ3VtZW50cyB0byB0aG9zZVxuICAgKiBwYXNzZWQgdG8gdGhlIGJvdW5kIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gYmluZC5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgZnVuY2AuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFthcmcxLCBhcmcyLCAuLi5dIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgYm91bmQgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBmdW5jID0gZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICogICByZXR1cm4gZ3JlZXRpbmcgKyAnICcgKyB0aGlzLm5hbWU7XG4gICAqIH07XG4gICAqXG4gICAqIGZ1bmMgPSBfLmJpbmQoZnVuYywgeyAnbmFtZSc6ICdtb2UnIH0sICdoaScpO1xuICAgKiBmdW5jKCk7XG4gICAqIC8vID0+ICdoaSBtb2UnXG4gICAqL1xuICBmdW5jdGlvbiBiaW5kKGZ1bmMsIHRoaXNBcmcpIHtcbiAgICAvLyB1c2UgYEZ1bmN0aW9uI2JpbmRgIGlmIGl0IGV4aXN0cyBhbmQgaXMgZmFzdFxuICAgIC8vIChpbiBWOCBgRnVuY3Rpb24jYmluZGAgaXMgc2xvd2VyIGV4Y2VwdCB3aGVuIHBhcnRpYWxseSBhcHBsaWVkKVxuICAgIHJldHVybiBpc0JpbmRGYXN0IHx8IChuYXRpdmVCaW5kICYmIGFyZ3VtZW50cy5sZW5ndGggPiAyKVxuICAgICAgPyBuYXRpdmVCaW5kLmNhbGwuYXBwbHkobmF0aXZlQmluZCwgYXJndW1lbnRzKVxuICAgICAgOiBjcmVhdGVCb3VuZChmdW5jLCB0aGlzQXJnLCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICB9XG5cbiAgLyoqXG4gICAqIEJpbmRzIG1ldGhvZHMgb24gYG9iamVjdGAgdG8gYG9iamVjdGAsIG92ZXJ3cml0aW5nIHRoZSBleGlzdGluZyBtZXRob2QuXG4gICAqIElmIG5vIG1ldGhvZCBuYW1lcyBhcmUgcHJvdmlkZWQsIGFsbCB0aGUgZnVuY3Rpb24gcHJvcGVydGllcyBvZiBgb2JqZWN0YFxuICAgKiB3aWxsIGJlIGJvdW5kLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRvIGJpbmQgYW5kIGFzc2lnbiB0aGUgYm91bmQgbWV0aG9kcyB0by5cbiAgICogQHBhcmFtIHtTdHJpbmd9IFttZXRob2ROYW1lMSwgbWV0aG9kTmFtZTIsIC4uLl0gTWV0aG9kIG5hbWVzIG9uIHRoZSBvYmplY3QgdG8gYmluZC5cbiAgICogQHJldHVybnMge09iamVjdH0gUmV0dXJucyBgb2JqZWN0YC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGJ1dHRvblZpZXcgPSB7XG4gICAqICAnbGFiZWwnOiAnbG9kYXNoJyxcbiAgICogICdvbkNsaWNrJzogZnVuY3Rpb24oKSB7IGFsZXJ0KCdjbGlja2VkOiAnICsgdGhpcy5sYWJlbCk7IH1cbiAgICogfTtcbiAgICpcbiAgICogXy5iaW5kQWxsKGJ1dHRvblZpZXcpO1xuICAgKiBqUXVlcnkoJyNsb2Rhc2hfYnV0dG9uJykub24oJ2NsaWNrJywgYnV0dG9uVmlldy5vbkNsaWNrKTtcbiAgICogLy8gPT4gV2hlbiB0aGUgYnV0dG9uIGlzIGNsaWNrZWQsIGB0aGlzLmxhYmVsYCB3aWxsIGhhdmUgdGhlIGNvcnJlY3QgdmFsdWVcbiAgICovXG4gIGZ1bmN0aW9uIGJpbmRBbGwob2JqZWN0KSB7XG4gICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzLFxuICAgICAgICBpbmRleCA9IGZ1bmNzLmxlbmd0aCA+IDEgPyAwIDogKGZ1bmNzID0gZnVuY3Rpb25zKG9iamVjdCksIC0xKSxcbiAgICAgICAgbGVuZ3RoID0gZnVuY3MubGVuZ3RoO1xuXG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgIHZhciBrZXkgPSBmdW5jc1tpbmRleF07XG4gICAgICBvYmplY3Rba2V5XSA9IGJpbmQob2JqZWN0W2tleV0sIG9iamVjdCk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIHRoZSBwYXNzZWQgZnVuY3Rpb25zLFxuICAgKiB3aGVyZSBlYWNoIGZ1bmN0aW9uIGNvbnN1bWVzIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgICogSW4gbWF0aCB0ZXJtcywgY29tcG9zaW5nIHRoZSBmdW5jdGlvbnMgYGYoKWAsIGBnKClgLCBhbmQgYGgoKWAgcHJvZHVjZXMgYGYoZyhoKCkpKWAuXG4gICAqIEVhY2ggZnVuY3Rpb24gaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNvbXBvc2VkIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gW2Z1bmMxLCBmdW5jMiwgLi4uXSBGdW5jdGlvbnMgdG8gY29tcG9zZS5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgY29tcG9zZWQgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuICdoaTogJyArIG5hbWU7IH07XG4gICAqIHZhciBleGNsYWltID0gZnVuY3Rpb24oc3RhdGVtZW50KSB7IHJldHVybiBzdGF0ZW1lbnQgKyAnISc7IH07XG4gICAqIHZhciB3ZWxjb21lID0gXy5jb21wb3NlKGV4Y2xhaW0sIGdyZWV0KTtcbiAgICogd2VsY29tZSgnbW9lJyk7XG4gICAqIC8vID0+ICdoaTogbW9lISdcbiAgICovXG4gIGZ1bmN0aW9uIGNvbXBvc2UoKSB7XG4gICAgdmFyIGZ1bmNzID0gYXJndW1lbnRzO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBhcmdzID0gYXJndW1lbnRzLFxuICAgICAgICAgIGxlbmd0aCA9IGZ1bmNzLmxlbmd0aDtcblxuICAgICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAgIGFyZ3MgPSBbZnVuY3NbbGVuZ3RoXS5hcHBseSh0aGlzLCBhcmdzKV07XG4gICAgICB9XG4gICAgICByZXR1cm4gYXJnc1swXTtcbiAgICB9O1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgZGVsYXkgdGhlIGV4ZWN1dGlvbiBvZiBgZnVuY2AgdW50aWwgYWZ0ZXJcbiAgICogYHdhaXRgIG1pbGxpc2Vjb25kcyBoYXZlIGVsYXBzZWQgc2luY2UgdGhlIGxhc3QgdGltZSBpdCB3YXMgaW52b2tlZC4gUGFzc1xuICAgKiBgdHJ1ZWAgZm9yIGBpbW1lZGlhdGVgIHRvIGNhdXNlIGRlYm91bmNlIHRvIGludm9rZSBgZnVuY2Agb24gdGhlIGxlYWRpbmcsXG4gICAqIGluc3RlYWQgb2YgdGhlIHRyYWlsaW5nLCBlZGdlIG9mIHRoZSBgd2FpdGAgdGltZW91dC4gU3Vic2VxdWVudCBjYWxscyB0b1xuICAgKiB0aGUgZGVib3VuY2VkIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSByZXN1bHQgb2YgdGhlIGxhc3QgYGZ1bmNgIGNhbGwuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWJvdW5jZS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkuXG4gICAqIEBwYXJhbSB7Qm9vbGVhbn0gaW1tZWRpYXRlIEEgZmxhZyB0byBpbmRpY2F0ZSBleGVjdXRpb24gaXMgb24gdGhlIGxlYWRpbmdcbiAgICogIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGRlYm91bmNlZCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGxhenlMYXlvdXQgPSBfLmRlYm91bmNlKGNhbGN1bGF0ZUxheW91dCwgMzAwKTtcbiAgICogalF1ZXJ5KHdpbmRvdykub24oJ3Jlc2l6ZScsIGxhenlMYXlvdXQpO1xuICAgKi9cbiAgZnVuY3Rpb24gZGVib3VuY2UoZnVuYywgd2FpdCwgaW1tZWRpYXRlKSB7XG4gICAgdmFyIGFyZ3MsXG4gICAgICAgIHJlc3VsdCxcbiAgICAgICAgdGhpc0FyZyxcbiAgICAgICAgdGltZW91dElkO1xuXG4gICAgZnVuY3Rpb24gZGVsYXllZCgpIHtcbiAgICAgIHRpbWVvdXRJZCA9IG51bGw7XG4gICAgICBpZiAoIWltbWVkaWF0ZSkge1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgaXNJbW1lZGlhdGUgPSBpbW1lZGlhdGUgJiYgIXRpbWVvdXRJZDtcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzQXJnID0gdGhpcztcblxuICAgICAgY2xlYXJUaW1lb3V0KHRpbWVvdXRJZCk7XG4gICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KGRlbGF5ZWQsIHdhaXQpO1xuXG4gICAgICBpZiAoaXNJbW1lZGlhdGUpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyB0aGUgYGZ1bmNgIGZ1bmN0aW9uIGFmdGVyIGB3YWl0YCBtaWxsaXNlY29uZHMuIEFkZGl0aW9uYWwgYXJndW1lbnRzXG4gICAqIHdpbGwgYmUgcGFzc2VkIHRvIGBmdW5jYCB3aGVuIGl0IGlzIGludm9rZWQuXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdW5jIFRoZSBmdW5jdGlvbiB0byBkZWxheS5cbiAgICogQHBhcmFtIHtOdW1iZXJ9IHdhaXQgVGhlIG51bWJlciBvZiBtaWxsaXNlY29uZHMgdG8gZGVsYXkgZXhlY3V0aW9uLlxuICAgKiBAcGFyYW0ge01peGVkfSBbYXJnMSwgYXJnMiwgLi4uXSBBcmd1bWVudHMgdG8gaW52b2tlIHRoZSBmdW5jdGlvbiB3aXRoLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfSBSZXR1cm5zIHRoZSBgc2V0VGltZW91dGAgdGltZW91dCBpZC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGxvZyA9IF8uYmluZChjb25zb2xlLmxvZywgY29uc29sZSk7XG4gICAqIF8uZGVsYXkobG9nLCAxMDAwLCAnbG9nZ2VkIGxhdGVyJyk7XG4gICAqIC8vID0+ICdsb2dnZWQgbGF0ZXInIChBcHBlYXJzIGFmdGVyIG9uZSBzZWNvbmQuKVxuICAgKi9cbiAgZnVuY3Rpb24gZGVsYXkoZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkgeyBmdW5jLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7IH0sIHdhaXQpO1xuICB9XG5cbiAgLyoqXG4gICAqIERlZmVycyBleGVjdXRpbmcgdGhlIGBmdW5jYCBmdW5jdGlvbiB1bnRpbCB0aGUgY3VycmVudCBjYWxsIHN0YWNrIGhhcyBjbGVhcmVkLlxuICAgKiBBZGRpdGlvbmFsIGFyZ3VtZW50cyB3aWxsIGJlIHBhc3NlZCB0byBgZnVuY2Agd2hlbiBpdCBpcyBpbnZva2VkLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gZGVmZXIuXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFthcmcxLCBhcmcyLCAuLi5dIEFyZ3VtZW50cyB0byBpbnZva2UgdGhlIGZ1bmN0aW9uIHdpdGguXG4gICAqIEByZXR1cm5zIHtOdW1iZXJ9IFJldHVybnMgdGhlIGBzZXRUaW1lb3V0YCB0aW1lb3V0IGlkLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLmRlZmVyKGZ1bmN0aW9uKCkgeyBhbGVydCgnZGVmZXJyZWQnKTsgfSk7XG4gICAqIC8vIHJldHVybnMgZnJvbSB0aGUgZnVuY3Rpb24gYmVmb3JlIGBhbGVydGAgaXMgY2FsbGVkXG4gICAqL1xuICBmdW5jdGlvbiBkZWZlcihmdW5jKSB7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7IGZ1bmMuYXBwbHkodW5kZWZpbmVkLCBhcmdzKTsgfSwgMSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLCBpbnZva2VzIGBvYmplY3RbbWV0aG9kTmFtZV1gIGFuZFxuICAgKiBwcmVwZW5kcyBhbnkgYWRkaXRpb25hbCBgbGF0ZUJpbmRgIGFyZ3VtZW50cyB0byB0aG9zZSBwYXNzZWQgdG8gdGhlIGJvdW5kXG4gICAqIGZ1bmN0aW9uLiBUaGlzIG1ldGhvZCBkaWZmZXJzIGZyb20gYF8uYmluZGAgYnkgYWxsb3dpbmcgYm91bmQgZnVuY3Rpb25zIHRvXG4gICAqIHJlZmVyZW5jZSBtZXRob2RzIHRoYXQgd2lsbCBiZSByZWRlZmluZWQgb3IgZG9uJ3QgeWV0IGV4aXN0LlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IHRoZSBtZXRob2QgYmVsb25ncyB0by5cbiAgICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZE5hbWUgVGhlIG1ldGhvZCBuYW1lLlxuICAgKiBAcGFyYW0ge01peGVkfSBbYXJnMSwgYXJnMiwgLi4uXSBBcmd1bWVudHMgdG8gYmUgcGFydGlhbGx5IGFwcGxpZWQuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IGJvdW5kIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgKiAgICduYW1lJzogJ21vZScsXG4gICAqICAgJ2dyZWV0JzogZnVuY3Rpb24oZ3JlZXRpbmcpIHtcbiAgICogICAgIHJldHVybiBncmVldGluZyArICcgJyArIHRoaXMubmFtZTtcbiAgICogICB9XG4gICAqIH07XG4gICAqXG4gICAqIHZhciBmdW5jID0gXy5sYXRlQmluZChvYmplY3QsICdncmVldCcsICdoaScpO1xuICAgKiBmdW5jKCk7XG4gICAqIC8vID0+ICdoaSBtb2UnXG4gICAqXG4gICAqIG9iamVjdC5ncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nKSB7XG4gICAqICAgcmV0dXJuIGdyZWV0aW5nICsgJywgJyArIHRoaXMubmFtZSArICchJztcbiAgICogfTtcbiAgICpcbiAgICogZnVuYygpO1xuICAgKiAvLyA9PiAnaGksIG1vZSEnXG4gICAqL1xuICBmdW5jdGlvbiBsYXRlQmluZChvYmplY3QsIG1ldGhvZE5hbWUpIHtcbiAgICByZXR1cm4gY3JlYXRlQm91bmQobWV0aG9kTmFtZSwgb2JqZWN0LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMikpO1xuICB9XG5cbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBmdW5jdGlvbiB0aGF0IG1lbW9pemVzIHRoZSByZXN1bHQgb2YgYGZ1bmNgLiBJZiBgcmVzb2x2ZXJgIGlzXG4gICAqIHBhc3NlZCwgaXQgd2lsbCBiZSB1c2VkIHRvIGRldGVybWluZSB0aGUgY2FjaGUga2V5IGZvciBzdG9yaW5nIHRoZSByZXN1bHRcbiAgICogYmFzZWQgb24gdGhlIGFyZ3VtZW50cyBwYXNzZWQgdG8gdGhlIG1lbW9pemVkIGZ1bmN0aW9uLiBCeSBkZWZhdWx0LCB0aGUgZmlyc3RcbiAgICogYXJndW1lbnQgcGFzc2VkIHRvIHRoZSBtZW1vaXplZCBmdW5jdGlvbiBpcyB1c2VkIGFzIHRoZSBjYWNoZSBrZXkuIFRoZSBgZnVuY2BcbiAgICogaXMgZXhlY3V0ZWQgd2l0aCB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIG1lbW9pemVkIGZ1bmN0aW9uLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gaGF2ZSBpdHMgb3V0cHV0IG1lbW9pemVkLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbcmVzb2x2ZXJdIEEgZnVuY3Rpb24gdXNlZCB0byByZXNvbHZlIHRoZSBjYWNoZSBrZXkuXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IG1lbW9pemluZyBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGZpYm9uYWNjaSA9IF8ubWVtb2l6ZShmdW5jdGlvbihuKSB7XG4gICAqICAgcmV0dXJuIG4gPCAyID8gbiA6IGZpYm9uYWNjaShuIC0gMSkgKyBmaWJvbmFjY2kobiAtIDIpO1xuICAgKiB9KTtcbiAgICovXG4gIGZ1bmN0aW9uIG1lbW9pemUoZnVuYywgcmVzb2x2ZXIpIHtcbiAgICB2YXIgY2FjaGUgPSB7fTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIga2V5ID0gcmVzb2x2ZXIgPyByZXNvbHZlci5hcHBseSh0aGlzLCBhcmd1bWVudHMpIDogYXJndW1lbnRzWzBdO1xuICAgICAgcmV0dXJuIGhhc093blByb3BlcnR5LmNhbGwoY2FjaGUsIGtleSlcbiAgICAgICAgPyBjYWNoZVtrZXldXG4gICAgICAgIDogKGNhY2hlW2tleV0gPSBmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykpO1xuICAgIH07XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQgaXMgcmVzdHJpY3RlZCB0byBleGVjdXRlIGBmdW5jYCBvbmNlLiBSZXBlYXQgY2FsbHMgdG9cbiAgICogdGhlIGZ1bmN0aW9uIHdpbGwgcmV0dXJuIHRoZSB2YWx1ZSBvZiB0aGUgZmlyc3QgY2FsbC4gVGhlIGBmdW5jYCBpcyBleGVjdXRlZFxuICAgKiB3aXRoIHRoZSBgdGhpc2AgYmluZGluZyBvZiB0aGUgY3JlYXRlZCBmdW5jdGlvbi5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHJlc3RyaWN0LlxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIG5ldyByZXN0cmljdGVkIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgaW5pdGlhbGl6ZSA9IF8ub25jZShjcmVhdGVBcHBsaWNhdGlvbik7XG4gICAqIGluaXRpYWxpemUoKTtcbiAgICogaW5pdGlhbGl6ZSgpO1xuICAgKiAvLyBBcHBsaWNhdGlvbiBpcyBvbmx5IGNyZWF0ZWQgb25jZS5cbiAgICovXG4gIGZ1bmN0aW9uIG9uY2UoZnVuYykge1xuICAgIHZhciByZXN1bHQsXG4gICAgICAgIHJhbiA9IGZhbHNlO1xuXG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgaWYgKHJhbikge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgcmFuID0gdHJ1ZTtcbiAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblxuICAgICAgLy8gY2xlYXIgdGhlIGBmdW5jYCB2YXJpYWJsZSBzbyB0aGUgZnVuY3Rpb24gbWF5IGJlIGdhcmJhZ2UgY29sbGVjdGVkXG4gICAgICBmdW5jID0gbnVsbDtcbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsIGludm9rZXMgYGZ1bmNgIHdpdGggYW55IGFkZGl0aW9uYWxcbiAgICogYHBhcnRpYWxgIGFyZ3VtZW50cyBwcmVwZW5kZWQgdG8gdGhvc2UgcGFzc2VkIHRvIHRoZSBuZXcgZnVuY3Rpb24uIFRoaXNcbiAgICogbWV0aG9kIGlzIHNpbWlsYXIgdG8gYGJpbmRgLCBleGNlcHQgaXQgZG9lcyAqKm5vdCoqIGFsdGVyIHRoZSBgdGhpc2AgYmluZGluZy5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgRnVuY3Rpb25zXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHBhcnRpYWxseSBhcHBseSBhcmd1bWVudHMgdG8uXG4gICAqIEBwYXJhbSB7TWl4ZWR9IFthcmcxLCBhcmcyLCAuLi5dIEFyZ3VtZW50cyB0byBiZSBwYXJ0aWFsbHkgYXBwbGllZC5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgcGFydGlhbGx5IGFwcGxpZWQgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBncmVldCA9IGZ1bmN0aW9uKGdyZWV0aW5nLCBuYW1lKSB7IHJldHVybiBncmVldGluZyArICc6ICcgKyBuYW1lOyB9O1xuICAgKiB2YXIgaGkgPSBfLnBhcnRpYWwoZ3JlZXQsICdoaScpO1xuICAgKiBoaSgnbW9lJyk7XG4gICAqIC8vID0+ICdoaTogbW9lJ1xuICAgKi9cbiAgZnVuY3Rpb24gcGFydGlhbChmdW5jKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUJvdW5kKGZ1bmMsIHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG4gIH1cblxuICAvKipcbiAgICogQ3JlYXRlcyBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gZXhlY3V0ZWQsIHdpbGwgb25seSBjYWxsIHRoZSBgZnVuY2BcbiAgICogZnVuY3Rpb24gYXQgbW9zdCBvbmNlIHBlciBldmVyeSBgd2FpdGAgbWlsbGlzZWNvbmRzLiBJZiB0aGUgdGhyb3R0bGVkXG4gICAqIGZ1bmN0aW9uIGlzIGludm9rZWQgbW9yZSB0aGFuIG9uY2UgZHVyaW5nIHRoZSBgd2FpdGAgdGltZW91dCwgYGZ1bmNgIHdpbGxcbiAgICogYWxzbyBiZSBjYWxsZWQgb24gdGhlIHRyYWlsaW5nIGVkZ2Ugb2YgdGhlIHRpbWVvdXQuIFN1YnNlcXVlbnQgY2FsbHMgdG8gdGhlXG4gICAqIHRocm90dGxlZCBmdW5jdGlvbiB3aWxsIHJldHVybiB0aGUgcmVzdWx0IG9mIHRoZSBsYXN0IGBmdW5jYCBjYWxsLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBGdW5jdGlvbnNcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZnVuYyBUaGUgZnVuY3Rpb24gdG8gdGhyb3R0bGUuXG4gICAqIEBwYXJhbSB7TnVtYmVyfSB3YWl0IFRoZSBudW1iZXIgb2YgbWlsbGlzZWNvbmRzIHRvIHRocm90dGxlIGV4ZWN1dGlvbnMgdG8uXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbn0gUmV0dXJucyB0aGUgbmV3IHRocm90dGxlZCBmdW5jdGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIHRocm90dGxlZCA9IF8udGhyb3R0bGUodXBkYXRlUG9zaXRpb24sIDEwMCk7XG4gICAqIGpRdWVyeSh3aW5kb3cpLm9uKCdzY3JvbGwnLCB0aHJvdHRsZWQpO1xuICAgKi9cbiAgZnVuY3Rpb24gdGhyb3R0bGUoZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHRoaXNBcmcsXG4gICAgICAgIHRpbWVvdXRJZCxcbiAgICAgICAgbGFzdENhbGxlZCA9IDA7XG5cbiAgICBmdW5jdGlvbiB0cmFpbGluZ0NhbGwoKSB7XG4gICAgICBsYXN0Q2FsbGVkID0gbmV3IERhdGU7XG4gICAgICB0aW1lb3V0SWQgPSBudWxsO1xuICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIG5vdyA9IG5ldyBEYXRlLFxuICAgICAgICAgIHJlbWFpbmluZyA9IHdhaXQgLSAobm93IC0gbGFzdENhbGxlZCk7XG5cbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICB0aGlzQXJnID0gdGhpcztcblxuICAgICAgaWYgKHJlbWFpbmluZyA8PSAwKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0SWQpO1xuICAgICAgICBsYXN0Q2FsbGVkID0gbm93O1xuICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KHRoaXNBcmcsIGFyZ3MpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoIXRpbWVvdXRJZCkge1xuICAgICAgICB0aW1lb3V0SWQgPSBzZXRUaW1lb3V0KHRyYWlsaW5nQ2FsbCwgcmVtYWluaW5nKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBDcmVhdGVzIGEgZnVuY3Rpb24gdGhhdCBwYXNzZXMgYHZhbHVlYCB0byB0aGUgYHdyYXBwZXJgIGZ1bmN0aW9uIGFzIGl0c1xuICAgKiBmaXJzdCBhcmd1bWVudC4gQWRkaXRpb25hbCBhcmd1bWVudHMgcGFzc2VkIHRvIHRoZSBmdW5jdGlvbiBhcmUgYXBwZW5kZWRcbiAgICogdG8gdGhvc2UgcGFzc2VkIHRvIHRoZSBgd3JhcHBlcmAgZnVuY3Rpb24uIFRoZSBgd3JhcHBlcmAgaXMgZXhlY3V0ZWQgd2l0aFxuICAgKiB0aGUgYHRoaXNgIGJpbmRpbmcgb2YgdGhlIGNyZWF0ZWQgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IEZ1bmN0aW9uc1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gd3JhcC5cbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gd3JhcHBlciBUaGUgd3JhcHBlciBmdW5jdGlvbi5cbiAgICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIHZhciBoZWxsbyA9IGZ1bmN0aW9uKG5hbWUpIHsgcmV0dXJuICdoZWxsbyAnICsgbmFtZTsgfTtcbiAgICogaGVsbG8gPSBfLndyYXAoaGVsbG8sIGZ1bmN0aW9uKGZ1bmMpIHtcbiAgICogICByZXR1cm4gJ2JlZm9yZSwgJyArIGZ1bmMoJ21vZScpICsgJywgYWZ0ZXInO1xuICAgKiB9KTtcbiAgICogaGVsbG8oKTtcbiAgICogLy8gPT4gJ2JlZm9yZSwgaGVsbG8gbW9lLCBhZnRlcidcbiAgICovXG4gIGZ1bmN0aW9uIHdyYXAodmFsdWUsIHdyYXBwZXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgYXJncyA9IFt2YWx1ZV07XG4gICAgICBwdXNoLmFwcGx5KGFyZ3MsIGFyZ3VtZW50cyk7XG4gICAgICByZXR1cm4gd3JhcHBlci5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICB9XG5cbiAgLyotLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLSovXG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoZSBjaGFyYWN0ZXJzIGAmYCwgYDxgLCBgPmAsIGBcImAsIGFuZCBgJ2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICogY29ycmVzcG9uZGluZyBIVE1MIGVudGl0aWVzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIGVzY2FwZS5cbiAgICogQHJldHVybnMge1N0cmluZ30gUmV0dXJucyB0aGUgZXNjYXBlZCBzdHJpbmcuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8uZXNjYXBlKCdNb2UsIExhcnJ5ICYgQ3VybHknKTtcbiAgICogLy8gPT4gXCJNb2UsIExhcnJ5ICZhbXA7IEN1cmx5XCJcbiAgICovXG4gIGZ1bmN0aW9uIGVzY2FwZShzdHJpbmcpIHtcbiAgICByZXR1cm4gc3RyaW5nID09IG51bGwgPyAnJyA6IChzdHJpbmcgKyAnJykucmVwbGFjZShyZVVuZXNjYXBlZEh0bWwsIGVzY2FwZUh0bWxDaGFyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIGZpcnN0IGFyZ3VtZW50IHBhc3NlZCB0byBpdC5cbiAgICpcbiAgICogTm90ZTogSXQgaXMgdXNlZCB0aHJvdWdob3V0IExvLURhc2ggYXMgYSBkZWZhdWx0IGNhbGxiYWNrLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgQW55IHZhbHVlLlxuICAgKiBAcmV0dXJucyB7TWl4ZWR9IFJldHVybnMgYHZhbHVlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIG1vZSA9IHsgJ25hbWUnOiAnbW9lJyB9O1xuICAgKiBtb2UgPT09IF8uaWRlbnRpdHkobW9lKTtcbiAgICogLy8gPT4gdHJ1ZVxuICAgKi9cbiAgZnVuY3Rpb24gaWRlbnRpdHkodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBmdW5jdGlvbnMgcHJvcGVydGllcyBvZiBgb2JqZWN0YCB0byB0aGUgYGxvZGFzaGAgZnVuY3Rpb24gYW5kIGNoYWluYWJsZVxuICAgKiB3cmFwcGVyLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQHBhcmFtIHtPYmplY3R9IG9iamVjdCBUaGUgb2JqZWN0IG9mIGZ1bmN0aW9uIHByb3BlcnRpZXMgdG8gYWRkIHRvIGBsb2Rhc2hgLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLm1peGluKHtcbiAgICogICAnY2FwaXRhbGl6ZSc6IGZ1bmN0aW9uKHN0cmluZykge1xuICAgKiAgICAgcmV0dXJuIHN0cmluZy5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0cmluZy5zbGljZSgxKS50b0xvd2VyQ2FzZSgpO1xuICAgKiAgIH1cbiAgICogfSk7XG4gICAqXG4gICAqIF8uY2FwaXRhbGl6ZSgnbGFycnknKTtcbiAgICogLy8gPT4gJ0xhcnJ5J1xuICAgKlxuICAgKiBfKCdjdXJseScpLmNhcGl0YWxpemUoKTtcbiAgICogLy8gPT4gJ0N1cmx5J1xuICAgKi9cbiAgZnVuY3Rpb24gbWl4aW4ob2JqZWN0KSB7XG4gICAgZm9yRWFjaChmdW5jdGlvbnMob2JqZWN0KSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBsb2Rhc2hbbWV0aG9kTmFtZV0gPSBvYmplY3RbbWV0aG9kTmFtZV07XG5cbiAgICAgIGxvZGFzaC5wcm90b3R5cGVbbWV0aG9kTmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fX3dyYXBwZWRfX107XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcblxuICAgICAgICB2YXIgcmVzdWx0ID0gZnVuYy5hcHBseShsb2Rhc2gsIGFyZ3MpO1xuICAgICAgICBpZiAodGhpcy5fX2NoYWluX18pIHtcbiAgICAgICAgICByZXN1bHQgPSBuZXcgbG9kYXNoKHJlc3VsdCk7XG4gICAgICAgICAgcmVzdWx0Ll9fY2hhaW5fXyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cblxuICAvKipcbiAgICogUmV2ZXJ0cyB0aGUgJ18nIHZhcmlhYmxlIHRvIGl0cyBwcmV2aW91cyB2YWx1ZSBhbmQgcmV0dXJucyBhIHJlZmVyZW5jZSB0b1xuICAgKiB0aGUgYGxvZGFzaGAgZnVuY3Rpb24uXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259IFJldHVybnMgdGhlIGBsb2Rhc2hgIGZ1bmN0aW9uLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgbG9kYXNoID0gXy5ub0NvbmZsaWN0KCk7XG4gICAqL1xuICBmdW5jdGlvbiBub0NvbmZsaWN0KCkge1xuICAgIHdpbmRvdy5fID0gb2xkRGFzaDtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8qKlxuICAgKiBQcm9kdWNlcyBhIHJhbmRvbSBudW1iZXIgYmV0d2VlbiBgbWluYCBhbmQgYG1heGAgKGluY2x1c2l2ZSkuIElmIG9ubHkgb25lXG4gICAqIGFyZ3VtZW50IGlzIHBhc3NlZCwgYSBudW1iZXIgYmV0d2VlbiBgMGAgYW5kIHRoZSBnaXZlbiBudW1iZXIgd2lsbCBiZSByZXR1cm5lZC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBbbWluPTBdIFRoZSBtaW5pbXVtIHBvc3NpYmxlIHZhbHVlLlxuICAgKiBAcGFyYW0ge051bWJlcn0gW21heD0xXSBUaGUgbWF4aW11bSBwb3NzaWJsZSB2YWx1ZS5cbiAgICogQHJldHVybnMge051bWJlcn0gUmV0dXJucyBhIHJhbmRvbSBudW1iZXIuXG4gICAqIEBleGFtcGxlXG4gICAqXG4gICAqIF8ucmFuZG9tKDAsIDUpO1xuICAgKiAvLyA9PiBhIG51bWJlciBiZXR3ZWVuIDEgYW5kIDVcbiAgICpcbiAgICogXy5yYW5kb20oNSk7XG4gICAqIC8vID0+IGFsc28gYSBudW1iZXIgYmV0d2VlbiAxIGFuZCA1XG4gICAqL1xuICBmdW5jdGlvbiByYW5kb20obWluLCBtYXgpIHtcbiAgICBpZiAobWluID09IG51bGwgJiYgbWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IDE7XG4gICAgfVxuICAgIG1pbiA9ICttaW4gfHwgMDtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBmbG9vcihuYXRpdmVSYW5kb20oKSAqICgoK21heCB8fCAwKSAtIG1pbiArIDEpKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBSZXNvbHZlcyB0aGUgdmFsdWUgb2YgYHByb3BlcnR5YCBvbiBgb2JqZWN0YC4gSWYgYHByb3BlcnR5YCBpcyBhIGZ1bmN0aW9uXG4gICAqIGl0IHdpbGwgYmUgaW52b2tlZCBhbmQgaXRzIHJlc3VsdCByZXR1cm5lZCwgZWxzZSB0aGUgcHJvcGVydHkgdmFsdWUgaXNcbiAgICogcmV0dXJuZWQuIElmIGBvYmplY3RgIGlzIGZhbHNleSwgdGhlbiBgbnVsbGAgaXMgcmV0dXJuZWQuXG4gICAqXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAcGFyYW0ge09iamVjdH0gb2JqZWN0IFRoZSBvYmplY3QgdG8gaW5zcGVjdC5cbiAgICogQHBhcmFtIHtTdHJpbmd9IHByb3BlcnR5IFRoZSBwcm9wZXJ0eSB0byBnZXQgdGhlIHZhbHVlIG9mLlxuICAgKiBAcmV0dXJucyB7TWl4ZWR9IFJldHVybnMgdGhlIHJlc29sdmVkIHZhbHVlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgb2JqZWN0ID0ge1xuICAgKiAgICdjaGVlc2UnOiAnY3J1bXBldHMnLFxuICAgKiAgICdzdHVmZic6IGZ1bmN0aW9uKCkge1xuICAgKiAgICAgcmV0dXJuICdub25zZW5zZSc7XG4gICAqICAgfVxuICAgKiB9O1xuICAgKlxuICAgKiBfLnJlc3VsdChvYmplY3QsICdjaGVlc2UnKTtcbiAgICogLy8gPT4gJ2NydW1wZXRzJ1xuICAgKlxuICAgKiBfLnJlc3VsdChvYmplY3QsICdzdHVmZicpO1xuICAgKiAvLyA9PiAnbm9uc2Vuc2UnXG4gICAqL1xuICBmdW5jdGlvbiByZXN1bHQob2JqZWN0LCBwcm9wZXJ0eSkge1xuICAgIC8vIGJhc2VkIG9uIEJhY2tib25lJ3MgcHJpdmF0ZSBgZ2V0VmFsdWVgIGZ1bmN0aW9uXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2RvY3VtZW50Y2xvdWQvYmFja2JvbmUvYmxvYi8wLjkuMi9iYWNrYm9uZS5qcyNMMTQxOS0xNDI0XG4gICAgdmFyIHZhbHVlID0gb2JqZWN0ID8gb2JqZWN0W3Byb3BlcnR5XSA6IG51bGw7XG4gICAgcmV0dXJuIGlzRnVuY3Rpb24odmFsdWUpID8gb2JqZWN0W3Byb3BlcnR5XSgpIDogdmFsdWU7XG4gIH1cblxuICAvKipcbiAgICogQSBtaWNyby10ZW1wbGF0aW5nIG1ldGhvZCB0aGF0IGhhbmRsZXMgYXJiaXRyYXJ5IGRlbGltaXRlcnMsIHByZXNlcnZlc1xuICAgKiB3aGl0ZXNwYWNlLCBhbmQgY29ycmVjdGx5IGVzY2FwZXMgcXVvdGVzIHdpdGhpbiBpbnRlcnBvbGF0ZWQgY29kZS5cbiAgICpcbiAgICogTm90ZTogSW4gdGhlIGRldmVsb3BtZW50IGJ1aWxkIGBfLnRlbXBsYXRlYCB1dGlsaXplcyBzb3VyY2VVUkxzIGZvciBlYXNpZXJcbiAgICogZGVidWdnaW5nLiBTZWUgaHR0cDovL3d3dy5odG1sNXJvY2tzLmNvbS9lbi90dXRvcmlhbHMvZGV2ZWxvcGVydG9vbHMvc291cmNlbWFwcy8jdG9jLXNvdXJjZXVybFxuICAgKlxuICAgKiBOb3RlOiBMby1EYXNoIG1heSBiZSB1c2VkIGluIENocm9tZSBleHRlbnNpb25zIGJ5IGVpdGhlciBjcmVhdGluZyBhIGBsb2Rhc2ggY3NwYFxuICAgKiBidWlsZCBhbmQgYXZvaWRpbmcgYF8udGVtcGxhdGVgIHVzZSwgb3IgbG9hZGluZyBMby1EYXNoIGluIGEgc2FuZGJveGVkIHBhZ2UuXG4gICAqIFNlZSBodHRwOi8vZGV2ZWxvcGVyLmNocm9tZS5jb20vdHJ1bmsvZXh0ZW5zaW9ucy9zYW5kYm94aW5nRXZhbC5odG1sXG4gICAqXG4gICAqIEBzdGF0aWNcbiAgICogQG1lbWJlck9mIF9cbiAgICogQGNhdGVnb3J5IFV0aWxpdGllc1xuICAgKiBAcGFyYW0ge1N0cmluZ30gdGV4dCBUaGUgdGVtcGxhdGUgdGV4dC5cbiAgICogQHBhcmFtIHtPYmVjdH0gZGF0YSBUaGUgZGF0YSBvYmplY3QgdXNlZCB0byBwb3B1bGF0ZSB0aGUgdGV4dC5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgVGhlIG9wdGlvbnMgb2JqZWN0LlxuICAgKiAgZXNjYXBlIC0gVGhlIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHJlZ2V4cC5cbiAgICogIGV2YWx1YXRlIC0gVGhlIFwiZXZhbHVhdGVcIiBkZWxpbWl0ZXIgcmVnZXhwLlxuICAgKiAgaW50ZXJwb2xhdGUgLSBUaGUgXCJpbnRlcnBvbGF0ZVwiIGRlbGltaXRlciByZWdleHAuXG4gICAqICBzb3VyY2VVUkwgLSBUaGUgc291cmNlVVJMIG9mIHRoZSB0ZW1wbGF0ZSdzIGNvbXBpbGVkIHNvdXJjZS5cbiAgICogIHZhcmlhYmxlIC0gVGhlIGRhdGEgb2JqZWN0IHZhcmlhYmxlIG5hbWUuXG4gICAqXG4gICAqIEByZXR1cm5zIHtGdW5jdGlvbnxTdHJpbmd9IFJldHVybnMgYSBjb21waWxlZCBmdW5jdGlvbiB3aGVuIG5vIGBkYXRhYCBvYmplY3RcbiAgICogIGlzIGdpdmVuLCBlbHNlIGl0IHJldHVybnMgdGhlIGludGVycG9sYXRlZCB0ZXh0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiAvLyB1c2luZyBhIGNvbXBpbGVkIHRlbXBsYXRlXG4gICAqIHZhciBjb21waWxlZCA9IF8udGVtcGxhdGUoJ2hlbGxvIDwlPSBuYW1lICU+Jyk7XG4gICAqIGNvbXBpbGVkKHsgJ25hbWUnOiAnbW9lJyB9KTtcbiAgICogLy8gPT4gJ2hlbGxvIG1vZSdcbiAgICpcbiAgICogdmFyIGxpc3QgPSAnPCUgXy5mb3JFYWNoKHBlb3BsZSwgZnVuY3Rpb24obmFtZSkgeyAlPjxsaT48JT0gbmFtZSAlPjwvbGk+PCUgfSk7ICU+JztcbiAgICogXy50ZW1wbGF0ZShsaXN0LCB7ICdwZW9wbGUnOiBbJ21vZScsICdsYXJyeScsICdjdXJseSddIH0pO1xuICAgKiAvLyA9PiAnPGxpPm1vZTwvbGk+PGxpPmxhcnJ5PC9saT48bGk+Y3VybHk8L2xpPidcbiAgICpcbiAgICogLy8gdXNpbmcgdGhlIFwiZXNjYXBlXCIgZGVsaW1pdGVyIHRvIGVzY2FwZSBIVE1MIGluIGRhdGEgcHJvcGVydHkgdmFsdWVzXG4gICAqIF8udGVtcGxhdGUoJzxiPjwlLSB2YWx1ZSAlPjwvYj4nLCB7ICd2YWx1ZSc6ICc8c2NyaXB0PicgfSk7XG4gICAqIC8vID0+ICc8Yj4mbHQ7c2NyaXB0Jmd0OzwvYj4nXG4gICAqXG4gICAqIC8vIHVzaW5nIHRoZSBFUzYgZGVsaW1pdGVyIGFzIGFuIGFsdGVybmF0aXZlIHRvIHRoZSBkZWZhdWx0IFwiaW50ZXJwb2xhdGVcIiBkZWxpbWl0ZXJcbiAgICogXy50ZW1wbGF0ZSgnaGVsbG8gJHsgbmFtZSB9JywgeyAnbmFtZSc6ICdjdXJseScgfSk7XG4gICAqIC8vID0+ICdoZWxsbyBjdXJseSdcbiAgICpcbiAgICogLy8gdXNpbmcgdGhlIGludGVybmFsIGBwcmludGAgZnVuY3Rpb24gaW4gXCJldmFsdWF0ZVwiIGRlbGltaXRlcnNcbiAgICogXy50ZW1wbGF0ZSgnPCUgcHJpbnQoXCJoZWxsbyBcIiArIGVwaXRoZXQpOyAlPiEnLCB7ICdlcGl0aGV0JzogJ3N0b29nZScgfSk7XG4gICAqIC8vID0+ICdoZWxsbyBzdG9vZ2UhJ1xuICAgKlxuICAgKiAvLyB1c2luZyBjdXN0b20gdGVtcGxhdGUgZGVsaW1pdGVyc1xuICAgKiBfLnRlbXBsYXRlU2V0dGluZ3MgPSB7XG4gICAqICAgJ2ludGVycG9sYXRlJzogL3t7KFtcXHNcXFNdKz8pfX0vZ1xuICAgKiB9O1xuICAgKlxuICAgKiBfLnRlbXBsYXRlKCdoZWxsbyB7eyBuYW1lIH19IScsIHsgJ25hbWUnOiAnbXVzdGFjaGUnIH0pO1xuICAgKiAvLyA9PiAnaGVsbG8gbXVzdGFjaGUhJ1xuICAgKlxuICAgKiAvLyB1c2luZyB0aGUgYHNvdXJjZVVSTGAgb3B0aW9uIHRvIHNwZWNpZnkgYSBjdXN0b20gc291cmNlVVJMIGZvciB0aGUgdGVtcGxhdGVcbiAgICogdmFyIGNvbXBpbGVkID0gXy50ZW1wbGF0ZSgnaGVsbG8gPCU9IG5hbWUgJT4nLCBudWxsLCB7ICdzb3VyY2VVUkwnOiAnL2Jhc2ljL2dyZWV0aW5nLmpzdCcgfSk7XG4gICAqIGNvbXBpbGVkKGRhdGEpO1xuICAgKiAvLyA9PiBmaW5kIHRoZSBzb3VyY2Ugb2YgXCJncmVldGluZy5qc3RcIiB1bmRlciB0aGUgU291cmNlcyB0YWIgb3IgUmVzb3VyY2VzIHBhbmVsIG9mIHRoZSB3ZWIgaW5zcGVjdG9yXG4gICAqXG4gICAqIC8vIHVzaW5nIHRoZSBgdmFyaWFibGVgIG9wdGlvbiB0byBlbnN1cmUgYSB3aXRoLXN0YXRlbWVudCBpc24ndCB1c2VkIGluIHRoZSBjb21waWxlZCB0ZW1wbGF0ZVxuICAgKiB2YXIgY29tcGlsZWQgPSBfLnRlbXBsYXRlKCdoZWxsbyA8JT0gZGF0YS5uYW1lICU+IScsIG51bGwsIHsgJ3ZhcmlhYmxlJzogJ2RhdGEnIH0pO1xuICAgKiBjb21waWxlZC5zb3VyY2U7XG4gICAqIC8vID0+IGZ1bmN0aW9uKGRhdGEpIHtcbiAgICogICB2YXIgX190LCBfX3AgPSAnJywgX19lID0gXy5lc2NhcGU7XG4gICAqICAgX19wICs9ICdoZWxsbyAnICsgKChfX3QgPSAoIGRhdGEubmFtZSApKSA9PSBudWxsID8gJycgOiBfX3QpICsgJyEnO1xuICAgKiAgIHJldHVybiBfX3A7XG4gICAqIH1cbiAgICpcbiAgICogLy8gdXNpbmcgdGhlIGBzb3VyY2VgIHByb3BlcnR5IHRvIGlubGluZSBjb21waWxlZCB0ZW1wbGF0ZXMgZm9yIG1lYW5pbmdmdWxcbiAgICogLy8gbGluZSBudW1iZXJzIGluIGVycm9yIG1lc3NhZ2VzIGFuZCBhIHN0YWNrIHRyYWNlXG4gICAqIGZzLndyaXRlRmlsZVN5bmMocGF0aC5qb2luKGN3ZCwgJ2pzdC5qcycpLCAnXFxcbiAgICogICB2YXIgSlNUID0ge1xcXG4gICAqICAgICBcIm1haW5cIjogJyArIF8udGVtcGxhdGUobWFpblRleHQpLnNvdXJjZSArICdcXFxuICAgKiAgIH07XFxcbiAgICogJyk7XG4gICAqL1xuICBmdW5jdGlvbiB0ZW1wbGF0ZSh0ZXh0LCBkYXRhLCBvcHRpb25zKSB7XG4gICAgLy8gYmFzZWQgb24gSm9obiBSZXNpZydzIGB0bXBsYCBpbXBsZW1lbnRhdGlvblxuICAgIC8vIGh0dHA6Ly9lam9obi5vcmcvYmxvZy9qYXZhc2NyaXB0LW1pY3JvLXRlbXBsYXRpbmcvXG4gICAgLy8gYW5kIExhdXJhIERva3Rvcm92YSdzIGRvVC5qc1xuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9vbGFkby9kb1RcbiAgICB0ZXh0IHx8ICh0ZXh0ID0gJycpO1xuICAgIG9wdGlvbnMgfHwgKG9wdGlvbnMgPSB7fSk7XG5cbiAgICB2YXIgaXNFdmFsdWF0aW5nLFxuICAgICAgICByZXN1bHQsXG4gICAgICAgIHNldHRpbmdzID0gbG9kYXNoLnRlbXBsYXRlU2V0dGluZ3MsXG4gICAgICAgIGluZGV4ID0gMCxcbiAgICAgICAgaW50ZXJwb2xhdGUgPSBvcHRpb25zLmludGVycG9sYXRlIHx8IHNldHRpbmdzLmludGVycG9sYXRlIHx8IHJlTm9NYXRjaCxcbiAgICAgICAgc291cmNlID0gXCJfX3AgKz0gJ1wiLFxuICAgICAgICB2YXJpYWJsZSA9IG9wdGlvbnMudmFyaWFibGUgfHwgc2V0dGluZ3MudmFyaWFibGUsXG4gICAgICAgIGhhc1ZhcmlhYmxlID0gdmFyaWFibGU7XG5cbiAgICAvLyBjb21waWxlIHJlZ2V4cCB0byBtYXRjaCBlYWNoIGRlbGltaXRlclxuICAgIHZhciByZURlbGltaXRlcnMgPSBSZWdFeHAoXG4gICAgICAob3B0aW9ucy5lc2NhcGUgfHwgc2V0dGluZ3MuZXNjYXBlIHx8IHJlTm9NYXRjaCkuc291cmNlICsgJ3wnICtcbiAgICAgIGludGVycG9sYXRlLnNvdXJjZSArICd8JyArXG4gICAgICAoaW50ZXJwb2xhdGUgPT09IHJlSW50ZXJwb2xhdGUgPyByZUVzVGVtcGxhdGUgOiByZU5vTWF0Y2gpLnNvdXJjZSArICd8JyArXG4gICAgICAob3B0aW9ucy5ldmFsdWF0ZSB8fCBzZXR0aW5ncy5ldmFsdWF0ZSB8fCByZU5vTWF0Y2gpLnNvdXJjZSArICd8JCdcbiAgICAsICdnJyk7XG5cbiAgICB0ZXh0LnJlcGxhY2UocmVEZWxpbWl0ZXJzLCBmdW5jdGlvbihtYXRjaCwgZXNjYXBlVmFsdWUsIGludGVycG9sYXRlVmFsdWUsIGVzVGVtcGxhdGVWYWx1ZSwgZXZhbHVhdGVWYWx1ZSwgb2Zmc2V0KSB7XG4gICAgICBpbnRlcnBvbGF0ZVZhbHVlIHx8IChpbnRlcnBvbGF0ZVZhbHVlID0gZXNUZW1wbGF0ZVZhbHVlKTtcblxuICAgICAgLy8gZXNjYXBlIGNoYXJhY3RlcnMgdGhhdCBjYW5ub3QgYmUgaW5jbHVkZWQgaW4gc3RyaW5nIGxpdGVyYWxzXG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKHJlVW5lc2NhcGVkU3RyaW5nLCBlc2NhcGVTdHJpbmdDaGFyKTtcblxuICAgICAgLy8gcmVwbGFjZSBkZWxpbWl0ZXJzIHdpdGggc25pcHBldHNcbiAgICAgIHNvdXJjZSArPVxuICAgICAgICBlc2NhcGVWYWx1ZSA/IFwiJyArXFxuX19lKFwiICsgZXNjYXBlVmFsdWUgKyBcIikgK1xcbidcIiA6XG4gICAgICAgIGV2YWx1YXRlVmFsdWUgPyBcIic7XFxuXCIgKyBldmFsdWF0ZVZhbHVlICsgXCI7XFxuX19wICs9ICdcIiA6XG4gICAgICAgIGludGVycG9sYXRlVmFsdWUgPyBcIicgK1xcbigoX190ID0gKFwiICsgaW50ZXJwb2xhdGVWYWx1ZSArIFwiKSkgPT0gbnVsbCA/ICcnIDogX190KSArXFxuJ1wiIDogJyc7XG5cbiAgICAgIGlzRXZhbHVhdGluZyB8fCAoaXNFdmFsdWF0aW5nID0gZXZhbHVhdGVWYWx1ZSB8fCByZUNvbXBsZXhEZWxpbWl0ZXIudGVzdChlc2NhcGVWYWx1ZSB8fCBpbnRlcnBvbGF0ZVZhbHVlKSk7XG4gICAgICBpbmRleCA9IG9mZnNldCArIG1hdGNoLmxlbmd0aDtcbiAgICB9KTtcblxuICAgIHNvdXJjZSArPSBcIic7XFxuXCI7XG5cbiAgICAvLyBpZiBgdmFyaWFibGVgIGlzIG5vdCBzcGVjaWZpZWQgYW5kIHRoZSB0ZW1wbGF0ZSBjb250YWlucyBcImV2YWx1YXRlXCJcbiAgICAvLyBkZWxpbWl0ZXJzLCB3cmFwIGEgd2l0aC1zdGF0ZW1lbnQgYXJvdW5kIHRoZSBnZW5lcmF0ZWQgY29kZSB0byBhZGQgdGhlXG4gICAgLy8gZGF0YSBvYmplY3QgdG8gdGhlIHRvcCBvZiB0aGUgc2NvcGUgY2hhaW5cbiAgICBpZiAoIWhhc1ZhcmlhYmxlKSB7XG4gICAgICB2YXJpYWJsZSA9ICdvYmonO1xuICAgICAgaWYgKGlzRXZhbHVhdGluZykge1xuICAgICAgICBzb3VyY2UgPSAnd2l0aCAoJyArIHZhcmlhYmxlICsgJykge1xcbicgKyBzb3VyY2UgKyAnXFxufVxcbic7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gYXZvaWQgYSB3aXRoLXN0YXRlbWVudCBieSBwcmVwZW5kaW5nIGRhdGEgb2JqZWN0IHJlZmVyZW5jZXMgdG8gcHJvcGVydHkgbmFtZXNcbiAgICAgICAgdmFyIHJlRG91YmxlVmFyaWFibGUgPSBSZWdFeHAoJyhcXFxcKFxcXFxzKiknICsgdmFyaWFibGUgKyAnXFxcXC4nICsgdmFyaWFibGUgKyAnXFxcXGInLCAnZycpO1xuICAgICAgICBzb3VyY2UgPSBzb3VyY2VcbiAgICAgICAgICAucmVwbGFjZShyZUluc2VydFZhcmlhYmxlLCAnJCYnICsgdmFyaWFibGUgKyAnLicpXG4gICAgICAgICAgLnJlcGxhY2UocmVEb3VibGVWYXJpYWJsZSwgJyQxX19kJyk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gY2xlYW51cCBjb2RlIGJ5IHN0cmlwcGluZyBlbXB0eSBzdHJpbmdzXG4gICAgc291cmNlID0gKGlzRXZhbHVhdGluZyA/IHNvdXJjZS5yZXBsYWNlKHJlRW1wdHlTdHJpbmdMZWFkaW5nLCAnJykgOiBzb3VyY2UpXG4gICAgICAucmVwbGFjZShyZUVtcHR5U3RyaW5nTWlkZGxlLCAnJDEnKVxuICAgICAgLnJlcGxhY2UocmVFbXB0eVN0cmluZ1RyYWlsaW5nLCAnJDE7Jyk7XG5cbiAgICAvLyBmcmFtZSBjb2RlIGFzIHRoZSBmdW5jdGlvbiBib2R5XG4gICAgc291cmNlID0gJ2Z1bmN0aW9uKCcgKyB2YXJpYWJsZSArICcpIHtcXG4nICtcbiAgICAgIChoYXNWYXJpYWJsZSA/ICcnIDogdmFyaWFibGUgKyAnIHx8ICgnICsgdmFyaWFibGUgKyAnID0ge30pO1xcbicpICtcbiAgICAgICd2YXIgX190LCBfX3AgPSBcXCdcXCcsIF9fZSA9IF8uZXNjYXBlJyArXG4gICAgICAoaXNFdmFsdWF0aW5nXG4gICAgICAgID8gJywgX19qID0gQXJyYXkucHJvdG90eXBlLmpvaW47XFxuJyArXG4gICAgICAgICAgJ2Z1bmN0aW9uIHByaW50KCkgeyBfX3AgKz0gX19qLmNhbGwoYXJndW1lbnRzLCBcXCdcXCcpIH1cXG4nXG4gICAgICAgIDogKGhhc1ZhcmlhYmxlID8gJycgOiAnLCBfX2QgPSAnICsgdmFyaWFibGUgKyAnLicgKyB2YXJpYWJsZSArICcgfHwgJyArIHZhcmlhYmxlKSArICc7XFxuJ1xuICAgICAgKSArXG4gICAgICBzb3VyY2UgK1xuICAgICAgJ3JldHVybiBfX3BcXG59JztcblxuICAgIC8vIHVzZSBhIHNvdXJjZVVSTCBmb3IgZWFzaWVyIGRlYnVnZ2luZ1xuICAgIC8vIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL2RldmVsb3BlcnRvb2xzL3NvdXJjZW1hcHMvI3RvYy1zb3VyY2V1cmxcbiAgICB2YXIgc291cmNlVVJMID0gdXNlU291cmNlVVJMXG4gICAgICA/ICdcXG4vL0Agc291cmNlVVJMPScgKyAob3B0aW9ucy5zb3VyY2VVUkwgfHwgJy9sb2Rhc2gvdGVtcGxhdGUvc291cmNlWycgKyAodGVtcGxhdGVDb3VudGVyKyspICsgJ10nKVxuICAgICAgOiAnJztcblxuICAgIHRyeSB7XG4gICAgICByZXN1bHQgPSBGdW5jdGlvbignXycsICdyZXR1cm4gJyArIHNvdXJjZSArIHNvdXJjZVVSTCkobG9kYXNoKTtcbiAgICB9IGNhdGNoKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICBpZiAoZGF0YSkge1xuICAgICAgcmV0dXJuIHJlc3VsdChkYXRhKTtcbiAgICB9XG4gICAgLy8gcHJvdmlkZSB0aGUgY29tcGlsZWQgZnVuY3Rpb24ncyBzb3VyY2UgdmlhIGl0cyBgdG9TdHJpbmdgIG1ldGhvZCwgaW5cbiAgICAvLyBzdXBwb3J0ZWQgZW52aXJvbm1lbnRzLCBvciB0aGUgYHNvdXJjZWAgcHJvcGVydHkgYXMgYSBjb252ZW5pZW5jZSBmb3JcbiAgICAvLyBpbmxpbmluZyBjb21waWxlZCB0ZW1wbGF0ZXMgZHVyaW5nIHRoZSBidWlsZCBwcm9jZXNzXG4gICAgcmVzdWx0LnNvdXJjZSA9IHNvdXJjZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG5cbiAgLyoqXG4gICAqIEV4ZWN1dGVzIHRoZSBgY2FsbGJhY2tgIGZ1bmN0aW9uIGBuYCB0aW1lcywgcmV0dXJuaW5nIGFuIGFycmF5IG9mIHRoZSByZXN1bHRzXG4gICAqIG9mIGVhY2ggYGNhbGxiYWNrYCBleGVjdXRpb24uIFRoZSBgY2FsbGJhY2tgIGlzIGJvdW5kIHRvIGB0aGlzQXJnYCBhbmQgaW52b2tlZFxuICAgKiB3aXRoIG9uZSBhcmd1bWVudDsgKGluZGV4KS5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7TnVtYmVyfSBuIFRoZSBudW1iZXIgb2YgdGltZXMgdG8gZXhlY3V0ZSB0aGUgY2FsbGJhY2suXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIFRoZSBmdW5jdGlvbiBjYWxsZWQgcGVyIGl0ZXJhdGlvbi5cbiAgICogQHBhcmFtIHtNaXhlZH0gW3RoaXNBcmddIFRoZSBgdGhpc2AgYmluZGluZyBvZiBgY2FsbGJhY2tgLlxuICAgKiBAcmV0dXJucyB7QXJyYXl9IFJldHVybnMgYSBuZXcgYXJyYXkgb2YgdGhlIHJlc3VsdHMgb2YgZWFjaCBgY2FsbGJhY2tgIGV4ZWN1dGlvbi5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogdmFyIGRpY2VSb2xscyA9IF8udGltZXMoMywgXy5wYXJ0aWFsKF8ucmFuZG9tLCAxLCA2KSk7XG4gICAqIC8vID0+IFszLCA2LCA0XVxuICAgKlxuICAgKiBfLnRpbWVzKDMsIGZ1bmN0aW9uKG4pIHsgbWFnZS5jYXN0U3BlbGwobik7IH0pO1xuICAgKiAvLyA9PiBjYWxscyBgbWFnZS5jYXN0U3BlbGwobilgIHRocmVlIHRpbWVzLCBwYXNzaW5nIGBuYCBvZiBgMGAsIGAxYCwgYW5kIGAyYCByZXNwZWN0aXZlbHlcbiAgICpcbiAgICogXy50aW1lcygzLCBmdW5jdGlvbihuKSB7IHRoaXMuY2FzdChuKTsgfSwgbWFnZSk7XG4gICAqIC8vID0+IGFsc28gY2FsbHMgYG1hZ2UuY2FzdFNwZWxsKG4pYCB0aHJlZSB0aW1lc1xuICAgKi9cbiAgZnVuY3Rpb24gdGltZXMobiwgY2FsbGJhY2ssIHRoaXNBcmcpIHtcbiAgICBuID0gK24gfHwgMDtcbiAgICB2YXIgaW5kZXggPSAtMSxcbiAgICAgICAgcmVzdWx0ID0gQXJyYXkobik7XG5cbiAgICB3aGlsZSAoKytpbmRleCA8IG4pIHtcbiAgICAgIHJlc3VsdFtpbmRleF0gPSBjYWxsYmFjay5jYWxsKHRoaXNBcmcsIGluZGV4KTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBUaGUgb3Bwb3NpdGUgb2YgYF8uZXNjYXBlYCwgdGhpcyBtZXRob2QgY29udmVydHMgdGhlIEhUTUwgZW50aXRpZXNcbiAgICogYCZhbXA7YCwgYCZsdDtgLCBgJmd0O2AsIGAmcXVvdDtgLCBhbmQgYCYjeDI3O2AgaW4gYHN0cmluZ2AgdG8gdGhlaXJcbiAgICogY29ycmVzcG9uZGluZyBjaGFyYWN0ZXJzLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBVdGlsaXRpZXNcbiAgICogQHBhcmFtIHtTdHJpbmd9IHN0cmluZyBUaGUgc3RyaW5nIHRvIHVuZXNjYXBlLlxuICAgKiBAcmV0dXJucyB7U3RyaW5nfSBSZXR1cm5zIHRoZSB1bmVzY2FwZWQgc3RyaW5nLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnVuZXNjYXBlKCdNb2UsIExhcnJ5ICZhbXA7IEN1cmx5Jyk7XG4gICAqIC8vID0+IFwiTW9lLCBMYXJyeSAmIEN1cmx5XCJcbiAgICovXG4gIGZ1bmN0aW9uIHVuZXNjYXBlKHN0cmluZykge1xuICAgIHJldHVybiBzdHJpbmcgPT0gbnVsbCA/ICcnIDogKHN0cmluZyArICcnKS5yZXBsYWNlKHJlRXNjYXBlZEh0bWwsIHVuZXNjYXBlSHRtbENoYXIpO1xuICB9XG5cbiAgLyoqXG4gICAqIEdlbmVyYXRlcyBhIHVuaXF1ZSBpZC4gSWYgYHByZWZpeGAgaXMgcGFzc2VkLCB0aGUgaWQgd2lsbCBiZSBhcHBlbmRlZCB0byBpdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgVXRpbGl0aWVzXG4gICAqIEBwYXJhbSB7U3RyaW5nfSBbcHJlZml4XSBUaGUgdmFsdWUgdG8gcHJlZml4IHRoZSBpZCB3aXRoLlxuICAgKiBAcmV0dXJucyB7TnVtYmVyfFN0cmluZ30gUmV0dXJucyBhIG51bWVyaWMgaWQgaWYgbm8gcHJlZml4IGlzIHBhc3NlZCwgZWxzZVxuICAgKiAgYSBzdHJpbmcgaWQgbWF5IGJlIHJldHVybmVkLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfLnVuaXF1ZUlkKCdjb250YWN0XycpO1xuICAgKiAvLyA9PiAnY29udGFjdF8xMDQnXG4gICAqL1xuICBmdW5jdGlvbiB1bmlxdWVJZChwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSBpZENvdW50ZXIrKztcbiAgICByZXR1cm4gcHJlZml4ID8gcHJlZml4ICsgaWQgOiBpZDtcbiAgfVxuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8qKlxuICAgKiBXcmFwcyB0aGUgdmFsdWUgaW4gYSBgbG9kYXNoYCB3cmFwcGVyIG9iamVjdC5cbiAgICpcbiAgICogQHN0YXRpY1xuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICogQHBhcmFtIHtNaXhlZH0gdmFsdWUgVGhlIHZhbHVlIHRvIHdyYXAuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiB2YXIgc3Rvb2dlcyA9IFtcbiAgICogICB7ICduYW1lJzogJ21vZScsICdhZ2UnOiA0MCB9LFxuICAgKiAgIHsgJ25hbWUnOiAnbGFycnknLCAnYWdlJzogNTAgfSxcbiAgICogICB7ICduYW1lJzogJ2N1cmx5JywgJ2FnZSc6IDYwIH1cbiAgICogXTtcbiAgICpcbiAgICogdmFyIHlvdW5nZXN0ID0gXy5jaGFpbihzdG9vZ2VzKVxuICAgKiAgICAgLnNvcnRCeShmdW5jdGlvbihzdG9vZ2UpIHsgcmV0dXJuIHN0b29nZS5hZ2U7IH0pXG4gICAqICAgICAubWFwKGZ1bmN0aW9uKHN0b29nZSkgeyByZXR1cm4gc3Rvb2dlLm5hbWUgKyAnIGlzICcgKyBzdG9vZ2UuYWdlOyB9KVxuICAgKiAgICAgLmZpcnN0KClcbiAgICogICAgIC52YWx1ZSgpO1xuICAgKiAvLyA9PiAnbW9lIGlzIDQwJ1xuICAgKi9cbiAgZnVuY3Rpb24gY2hhaW4odmFsdWUpIHtcbiAgICB2YWx1ZSA9IG5ldyBsb2Rhc2godmFsdWUpO1xuICAgIHZhbHVlLl9fY2hhaW5fXyA9IHRydWU7XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG5cbiAgLyoqXG4gICAqIEludm9rZXMgYGludGVyY2VwdG9yYCB3aXRoIHRoZSBgdmFsdWVgIGFzIHRoZSBmaXJzdCBhcmd1bWVudCwgYW5kIHRoZW5cbiAgICogcmV0dXJucyBgdmFsdWVgLiBUaGUgcHVycG9zZSBvZiB0aGlzIG1ldGhvZCBpcyB0byBcInRhcCBpbnRvXCIgYSBtZXRob2QgY2hhaW4sXG4gICAqIGluIG9yZGVyIHRvIHBlcmZvcm0gb3BlcmF0aW9ucyBvbiBpbnRlcm1lZGlhdGUgcmVzdWx0cyB3aXRoaW4gdGhlIGNoYWluLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgKiBAcGFyYW0ge01peGVkfSB2YWx1ZSBUaGUgdmFsdWUgdG8gcGFzcyB0byBgaW50ZXJjZXB0b3JgLlxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBpbnRlcmNlcHRvciBUaGUgZnVuY3Rpb24gdG8gaW52b2tlLlxuICAgKiBAcmV0dXJucyB7TWl4ZWR9IFJldHVybnMgYHZhbHVlYC5cbiAgICogQGV4YW1wbGVcbiAgICpcbiAgICogXy5jaGFpbihbMSwgMiwgMywgMjAwXSlcbiAgICogIC5maWx0ZXIoZnVuY3Rpb24obnVtKSB7IHJldHVybiBudW0gJSAyID09IDA7IH0pXG4gICAqICAudGFwKGFsZXJ0KVxuICAgKiAgLm1hcChmdW5jdGlvbihudW0pIHsgcmV0dXJuIG51bSAqIG51bSB9KVxuICAgKiAgLnZhbHVlKCk7XG4gICAqIC8vID0+IC8vIFsyLCAyMDBdIChhbGVydGVkKVxuICAgKiAvLyA9PiBbNCwgNDAwMDBdXG4gICAqL1xuICBmdW5jdGlvbiB0YXAodmFsdWUsIGludGVyY2VwdG9yKSB7XG4gICAgaW50ZXJjZXB0b3IodmFsdWUpO1xuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFbmFibGVzIG1ldGhvZCBjaGFpbmluZyBvbiB0aGUgd3JhcHBlciBvYmplY3QuXG4gICAqXG4gICAqIEBuYW1lIGNoYWluXG4gICAqIEBkZXByZWNhdGVkXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEBjYXRlZ29yeSBDaGFpbmluZ1xuICAgKiBAcmV0dXJucyB7TWl4ZWR9IFJldHVybnMgdGhlIHdyYXBwZXIgb2JqZWN0LlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwcGVyQ2hhaW4oKSB7XG4gICAgdGhpcy5fX2NoYWluX18gPSB0cnVlO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLyoqXG4gICAqIEV4dHJhY3RzIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgKlxuICAgKiBAbmFtZSB2YWx1ZVxuICAgKiBAbWVtYmVyT2YgX1xuICAgKiBAY2F0ZWdvcnkgQ2hhaW5pbmdcbiAgICogQHJldHVybnMge01peGVkfSBSZXR1cm5zIHRoZSB3cmFwcGVkIHZhbHVlLlxuICAgKiBAZXhhbXBsZVxuICAgKlxuICAgKiBfKFsxLCAyLCAzXSkudmFsdWUoKTtcbiAgICogLy8gPT4gWzEsIDIsIDNdXG4gICAqL1xuICBmdW5jdGlvbiB3cmFwcGVyVmFsdWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX193cmFwcGVkX187XG4gIH1cblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvKipcbiAgICogVGhlIHNlbWFudGljIHZlcnNpb24gbnVtYmVyLlxuICAgKlxuICAgKiBAc3RhdGljXG4gICAqIEBtZW1iZXJPZiBfXG4gICAqIEB0eXBlIFN0cmluZ1xuICAgKi9cbiAgbG9kYXNoLlZFUlNJT04gPSAnMC45LjInO1xuXG4gIC8vIGFzc2lnbiBzdGF0aWMgbWV0aG9kc1xuICBsb2Rhc2guYWZ0ZXIgPSBhZnRlcjtcbiAgbG9kYXNoLmJpbmQgPSBiaW5kO1xuICBsb2Rhc2guYmluZEFsbCA9IGJpbmRBbGw7XG4gIGxvZGFzaC5jaGFpbiA9IGNoYWluO1xuICBsb2Rhc2guY2xvbmUgPSBjbG9uZTtcbiAgbG9kYXNoLmNvbXBhY3QgPSBjb21wYWN0O1xuICBsb2Rhc2guY29tcG9zZSA9IGNvbXBvc2U7XG4gIGxvZGFzaC5jb250YWlucyA9IGNvbnRhaW5zO1xuICBsb2Rhc2guY291bnRCeSA9IGNvdW50Qnk7XG4gIGxvZGFzaC5kZWJvdW5jZSA9IGRlYm91bmNlO1xuICBsb2Rhc2guZGVmYXVsdHMgPSBkZWZhdWx0cztcbiAgbG9kYXNoLmRlZmVyID0gZGVmZXI7XG4gIGxvZGFzaC5kZWxheSA9IGRlbGF5O1xuICBsb2Rhc2guZGlmZmVyZW5jZSA9IGRpZmZlcmVuY2U7XG4gIGxvZGFzaC5lc2NhcGUgPSBlc2NhcGU7XG4gIGxvZGFzaC5ldmVyeSA9IGV2ZXJ5O1xuICBsb2Rhc2guZXh0ZW5kID0gZXh0ZW5kO1xuICBsb2Rhc2guZmlsdGVyID0gZmlsdGVyO1xuICBsb2Rhc2guZmluZCA9IGZpbmQ7XG4gIGxvZGFzaC5maXJzdCA9IGZpcnN0O1xuICBsb2Rhc2guZmxhdHRlbiA9IGZsYXR0ZW47XG4gIGxvZGFzaC5mb3JFYWNoID0gZm9yRWFjaDtcbiAgbG9kYXNoLmZvckluID0gZm9ySW47XG4gIGxvZGFzaC5mb3JPd24gPSBmb3JPd247XG4gIGxvZGFzaC5mdW5jdGlvbnMgPSBmdW5jdGlvbnM7XG4gIGxvZGFzaC5ncm91cEJ5ID0gZ3JvdXBCeTtcbiAgbG9kYXNoLmhhcyA9IGhhcztcbiAgbG9kYXNoLmlkZW50aXR5ID0gaWRlbnRpdHk7XG4gIGxvZGFzaC5pbmRleE9mID0gaW5kZXhPZjtcbiAgbG9kYXNoLmluaXRpYWwgPSBpbml0aWFsO1xuICBsb2Rhc2guaW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0aW9uO1xuICBsb2Rhc2guaW52ZXJ0ID0gaW52ZXJ0O1xuICBsb2Rhc2guaW52b2tlID0gaW52b2tlO1xuICBsb2Rhc2guaXNBcmd1bWVudHMgPSBpc0FyZ3VtZW50cztcbiAgbG9kYXNoLmlzQXJyYXkgPSBpc0FycmF5O1xuICBsb2Rhc2guaXNCb29sZWFuID0gaXNCb29sZWFuO1xuICBsb2Rhc2guaXNEYXRlID0gaXNEYXRlO1xuICBsb2Rhc2guaXNFbGVtZW50ID0gaXNFbGVtZW50O1xuICBsb2Rhc2guaXNFbXB0eSA9IGlzRW1wdHk7XG4gIGxvZGFzaC5pc0VxdWFsID0gaXNFcXVhbDtcbiAgbG9kYXNoLmlzRmluaXRlID0gaXNGaW5pdGU7XG4gIGxvZGFzaC5pc0Z1bmN0aW9uID0gaXNGdW5jdGlvbjtcbiAgbG9kYXNoLmlzTmFOID0gaXNOYU47XG4gIGxvZGFzaC5pc051bGwgPSBpc051bGw7XG4gIGxvZGFzaC5pc051bWJlciA9IGlzTnVtYmVyO1xuICBsb2Rhc2guaXNPYmplY3QgPSBpc09iamVjdDtcbiAgbG9kYXNoLmlzUGxhaW5PYmplY3QgPSBpc1BsYWluT2JqZWN0O1xuICBsb2Rhc2guaXNSZWdFeHAgPSBpc1JlZ0V4cDtcbiAgbG9kYXNoLmlzU3RyaW5nID0gaXNTdHJpbmc7XG4gIGxvZGFzaC5pc1VuZGVmaW5lZCA9IGlzVW5kZWZpbmVkO1xuICBsb2Rhc2gua2V5cyA9IGtleXM7XG4gIGxvZGFzaC5sYXN0ID0gbGFzdDtcbiAgbG9kYXNoLmxhc3RJbmRleE9mID0gbGFzdEluZGV4T2Y7XG4gIGxvZGFzaC5sYXRlQmluZCA9IGxhdGVCaW5kO1xuICBsb2Rhc2gubWFwID0gbWFwO1xuICBsb2Rhc2gubWF4ID0gbWF4O1xuICBsb2Rhc2gubWVtb2l6ZSA9IG1lbW9pemU7XG4gIGxvZGFzaC5tZXJnZSA9IG1lcmdlO1xuICBsb2Rhc2gubWluID0gbWluO1xuICBsb2Rhc2gubWl4aW4gPSBtaXhpbjtcbiAgbG9kYXNoLm5vQ29uZmxpY3QgPSBub0NvbmZsaWN0O1xuICBsb2Rhc2gub2JqZWN0ID0gb2JqZWN0O1xuICBsb2Rhc2gub21pdCA9IG9taXQ7XG4gIGxvZGFzaC5vbmNlID0gb25jZTtcbiAgbG9kYXNoLnBhaXJzID0gcGFpcnM7XG4gIGxvZGFzaC5wYXJ0aWFsID0gcGFydGlhbDtcbiAgbG9kYXNoLnBpY2sgPSBwaWNrO1xuICBsb2Rhc2gucGx1Y2sgPSBwbHVjaztcbiAgbG9kYXNoLnJhbmRvbSA9IHJhbmRvbTtcbiAgbG9kYXNoLnJhbmdlID0gcmFuZ2U7XG4gIGxvZGFzaC5yZWR1Y2UgPSByZWR1Y2U7XG4gIGxvZGFzaC5yZWR1Y2VSaWdodCA9IHJlZHVjZVJpZ2h0O1xuICBsb2Rhc2gucmVqZWN0ID0gcmVqZWN0O1xuICBsb2Rhc2gucmVzdCA9IHJlc3Q7XG4gIGxvZGFzaC5yZXN1bHQgPSByZXN1bHQ7XG4gIGxvZGFzaC5zaHVmZmxlID0gc2h1ZmZsZTtcbiAgbG9kYXNoLnNpemUgPSBzaXplO1xuICBsb2Rhc2guc29tZSA9IHNvbWU7XG4gIGxvZGFzaC5zb3J0QnkgPSBzb3J0Qnk7XG4gIGxvZGFzaC5zb3J0ZWRJbmRleCA9IHNvcnRlZEluZGV4O1xuICBsb2Rhc2gudGFwID0gdGFwO1xuICBsb2Rhc2gudGVtcGxhdGUgPSB0ZW1wbGF0ZTtcbiAgbG9kYXNoLnRocm90dGxlID0gdGhyb3R0bGU7XG4gIGxvZGFzaC50aW1lcyA9IHRpbWVzO1xuICBsb2Rhc2gudG9BcnJheSA9IHRvQXJyYXk7XG4gIGxvZGFzaC51bmVzY2FwZSA9IHVuZXNjYXBlO1xuICBsb2Rhc2gudW5pb24gPSB1bmlvbjtcbiAgbG9kYXNoLnVuaXEgPSB1bmlxO1xuICBsb2Rhc2gudW5pcXVlSWQgPSB1bmlxdWVJZDtcbiAgbG9kYXNoLnZhbHVlcyA9IHZhbHVlcztcbiAgbG9kYXNoLndoZXJlID0gd2hlcmU7XG4gIGxvZGFzaC53aXRob3V0ID0gd2l0aG91dDtcbiAgbG9kYXNoLndyYXAgPSB3cmFwO1xuICBsb2Rhc2guemlwID0gemlwO1xuXG4gIC8vIGFzc2lnbiBhbGlhc2VzXG4gIGxvZGFzaC5hbGwgPSBldmVyeTtcbiAgbG9kYXNoLmFueSA9IHNvbWU7XG4gIGxvZGFzaC5jb2xsZWN0ID0gbWFwO1xuICBsb2Rhc2guZGV0ZWN0ID0gZmluZDtcbiAgbG9kYXNoLmRyb3AgPSByZXN0O1xuICBsb2Rhc2guZWFjaCA9IGZvckVhY2g7XG4gIGxvZGFzaC5mb2xkbCA9IHJlZHVjZTtcbiAgbG9kYXNoLmZvbGRyID0gcmVkdWNlUmlnaHQ7XG4gIGxvZGFzaC5oZWFkID0gZmlyc3Q7XG4gIGxvZGFzaC5pbmNsdWRlID0gY29udGFpbnM7XG4gIGxvZGFzaC5pbmplY3QgPSByZWR1Y2U7XG4gIGxvZGFzaC5tZXRob2RzID0gZnVuY3Rpb25zO1xuICBsb2Rhc2guc2VsZWN0ID0gZmlsdGVyO1xuICBsb2Rhc2gudGFpbCA9IHJlc3Q7XG4gIGxvZGFzaC50YWtlID0gZmlyc3Q7XG4gIGxvZGFzaC51bmlxdWUgPSB1bmlxO1xuXG4gIC8vIGFkZCBwc2V1ZG8gcHJpdmF0ZSBwcm9wZXJ0eSB0byBiZSB1c2VkIGFuZCByZW1vdmVkIGR1cmluZyB0aGUgYnVpbGQgcHJvY2Vzc1xuICBsb2Rhc2guX2l0ZXJhdG9yVGVtcGxhdGUgPSBpdGVyYXRvclRlbXBsYXRlO1xuXG4gIC8qLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0qL1xuXG4gIC8vIGFkZCBhbGwgc3RhdGljIGZ1bmN0aW9ucyB0byBgbG9kYXNoLnByb3RvdHlwZWBcbiAgbWl4aW4obG9kYXNoKTtcblxuICAvLyBhZGQgYGxvZGFzaC5wcm90b3R5cGUuY2hhaW5gIGFmdGVyIGNhbGxpbmcgYG1peGluKClgIHRvIGF2b2lkIG92ZXJ3cml0aW5nXG4gIC8vIGl0IHdpdGggdGhlIHdyYXBwZWQgYGxvZGFzaC5jaGFpbmBcbiAgbG9kYXNoLnByb3RvdHlwZS5jaGFpbiA9IHdyYXBwZXJDaGFpbjtcbiAgbG9kYXNoLnByb3RvdHlwZS52YWx1ZSA9IHdyYXBwZXJWYWx1ZTtcblxuICAvLyBhZGQgYWxsIG11dGF0b3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBmb3JFYWNoKFsncG9wJywgJ3B1c2gnLCAncmV2ZXJzZScsICdzaGlmdCcsICdzb3J0JywgJ3NwbGljZScsICd1bnNoaWZ0J10sIGZ1bmN0aW9uKG1ldGhvZE5hbWUpIHtcbiAgICB2YXIgZnVuYyA9IGFycmF5UmVmW21ldGhvZE5hbWVdO1xuXG4gICAgbG9kYXNoLnByb3RvdHlwZVttZXRob2ROYW1lXSA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIHZhbHVlID0gdGhpcy5fX3dyYXBwZWRfXztcbiAgICAgIGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3VtZW50cyk7XG5cbiAgICAgIC8vIGF2b2lkIGFycmF5LWxpa2Ugb2JqZWN0IGJ1Z3Mgd2l0aCBgQXJyYXkjc2hpZnRgIGFuZCBgQXJyYXkjc3BsaWNlYCBpblxuICAgICAgLy8gRmlyZWZveCA8IDEwIGFuZCBJRSA8IDlcbiAgICAgIGlmIChoYXNPYmplY3RTcGxpY2VCdWcgJiYgdmFsdWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGRlbGV0ZSB2YWx1ZVswXTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLl9fY2hhaW5fXykge1xuICAgICAgICB2YWx1ZSA9IG5ldyBsb2Rhc2godmFsdWUpO1xuICAgICAgICB2YWx1ZS5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH07XG4gIH0pO1xuXG4gIC8vIGFkZCBhbGwgYWNjZXNzb3IgQXJyYXkgZnVuY3Rpb25zIHRvIHRoZSB3cmFwcGVyLlxuICBmb3JFYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obWV0aG9kTmFtZSkge1xuICAgIHZhciBmdW5jID0gYXJyYXlSZWZbbWV0aG9kTmFtZV07XG5cbiAgICBsb2Rhc2gucHJvdG90eXBlW21ldGhvZE5hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgdmFsdWUgPSB0aGlzLl9fd3JhcHBlZF9fLFxuICAgICAgICAgIHJlc3VsdCA9IGZ1bmMuYXBwbHkodmFsdWUsIGFyZ3VtZW50cyk7XG5cbiAgICAgIGlmICh0aGlzLl9fY2hhaW5fXykge1xuICAgICAgICByZXN1bHQgPSBuZXcgbG9kYXNoKHJlc3VsdCk7XG4gICAgICAgIHJlc3VsdC5fX2NoYWluX18gPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9KTtcblxuICAvKi0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tKi9cblxuICAvLyBleHBvc2UgTG8tRGFzaFxuICAvLyBzb21lIEFNRCBidWlsZCBvcHRpbWl6ZXJzLCBsaWtlIHIuanMsIGNoZWNrIGZvciBzcGVjaWZpYyBjb25kaXRpb24gcGF0dGVybnMgbGlrZSB0aGUgZm9sbG93aW5nOlxuICBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnICYmIGRlZmluZS5hbWQpIHtcbiAgICAvLyBFeHBvc2UgTG8tRGFzaCB0byB0aGUgZ2xvYmFsIG9iamVjdCBldmVuIHdoZW4gYW4gQU1EIGxvYWRlciBpcyBwcmVzZW50IGluXG4gICAgLy8gY2FzZSBMby1EYXNoIHdhcyBpbmplY3RlZCBieSBhIHRoaXJkLXBhcnR5IHNjcmlwdCBhbmQgbm90IGludGVuZGVkIHRvIGJlXG4gICAgLy8gbG9hZGVkIGFzIGEgbW9kdWxlLiBUaGUgZ2xvYmFsIGFzc2lnbm1lbnQgY2FuIGJlIHJldmVydGVkIGluIHRoZSBMby1EYXNoXG4gICAgLy8gbW9kdWxlIHZpYSBpdHMgYG5vQ29uZmxpY3QoKWAgbWV0aG9kLlxuICAgIHdpbmRvdy5fID0gbG9kYXNoO1xuXG4gICAgLy8gZGVmaW5lIGFzIGFuIGFub255bW91cyBtb2R1bGUgc28sIHRocm91Z2ggcGF0aCBtYXBwaW5nLCBpdCBjYW4gYmVcbiAgICAvLyByZWZlcmVuY2VkIGFzIHRoZSBcInVuZGVyc2NvcmVcIiBtb2R1bGVcbiAgICBkZWZpbmUoZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gbG9kYXNoO1xuICAgIH0pO1xuICB9XG4gIC8vIGNoZWNrIGZvciBgZXhwb3J0c2AgYWZ0ZXIgYGRlZmluZWAgaW4gY2FzZSBhIGJ1aWxkIG9wdGltaXplciBhZGRzIGFuIGBleHBvcnRzYCBvYmplY3RcbiAgZWxzZSBpZiAoZnJlZUV4cG9ydHMpIHtcbiAgICAvLyBpbiBOb2RlLmpzIG9yIFJpbmdvSlMgdjAuOC4wK1xuICAgIGlmICh0eXBlb2YgbW9kdWxlID09ICdvYmplY3QnICYmIG1vZHVsZSAmJiBtb2R1bGUuZXhwb3J0cyA9PSBmcmVlRXhwb3J0cykge1xuICAgICAgKG1vZHVsZS5leHBvcnRzID0gbG9kYXNoKS5fID0gbG9kYXNoO1xuICAgIH1cbiAgICAvLyBpbiBOYXJ3aGFsIG9yIFJpbmdvSlMgdjAuNy4wLVxuICAgIGVsc2Uge1xuICAgICAgZnJlZUV4cG9ydHMuXyA9IGxvZGFzaDtcbiAgICB9XG4gIH1cbiAgZWxzZSB7XG4gICAgLy8gaW4gYSBicm93c2VyIG9yIFJoaW5vXG4gICAgd2luZG93Ll8gPSBsb2Rhc2g7XG4gIH1cbn0odGhpcykpO1xuIiwiLyohXG4gKiBQYXBlci5qcyB2MC45LjI1IC0gVGhlIFN3aXNzIEFybXkgS25pZmUgb2YgVmVjdG9yIEdyYXBoaWNzIFNjcmlwdGluZy5cbiAqIGh0dHA6Ly9wYXBlcmpzLm9yZy9cbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTEgLSAyMDE0LCBKdWVyZyBMZWhuaSAmIEpvbmF0aGFuIFB1Y2tleVxuICogaHR0cDovL3NjcmF0Y2hkaXNrLmNvbS8gJiBodHRwOi8vam9uYXRoYW5wdWNrZXkuY29tL1xuICpcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS4gU2VlIExJQ0VOU0UgZmlsZSBmb3IgZGV0YWlscy5cbiAqXG4gKiBBbGwgcmlnaHRzIHJlc2VydmVkLlxuICpcbiAqIERhdGU6IFN1biBPY3QgMjUgMTE6MjM6MzggMjAxNSArMDEwMFxuICpcbiAqKipcbiAqXG4gKiBTdHJhcHMuanMgLSBDbGFzcyBpbmhlcml0YW5jZSBsaWJyYXJ5IHdpdGggc3VwcG9ydCBmb3IgYmVhbi1zdHlsZSBhY2Nlc3NvcnNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIDIwMDYgLSAyMDEzIEp1ZXJnIExlaG5pXG4gKiBodHRwOi8vc2NyYXRjaGRpc2suY29tL1xuICpcbiAqIERpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cbiAqXG4gKioqXG4gKlxuICogQWNvcm4uanNcbiAqIGh0dHA6Ly9tYXJpam5oYXZlcmJla2UubmwvYWNvcm4vXG4gKlxuICogQWNvcm4gaXMgYSB0aW55LCBmYXN0IEphdmFTY3JpcHQgcGFyc2VyIHdyaXR0ZW4gaW4gSmF2YVNjcmlwdCxcbiAqIGNyZWF0ZWQgYnkgTWFyaWpuIEhhdmVyYmVrZSBhbmQgcmVsZWFzZWQgdW5kZXIgYW4gTUlUIGxpY2Vuc2UuXG4gKlxuICovXG5cbnZhciBwYXBlciA9IG5ldyBmdW5jdGlvbih1bmRlZmluZWQpIHtcblxudmFyIEJhc2UgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBoaWRkZW4gPSAvXihzdGF0aWNzfGVudW1lcmFibGV8YmVhbnN8cHJlc2VydmUpJC8sXG5cblx0XHRmb3JFYWNoID0gW10uZm9yRWFjaCB8fCBmdW5jdGlvbihpdGVyLCBiaW5kKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpdGVyLmNhbGwoYmluZCwgdGhpc1tpXSwgaSwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdGZvckluID0gZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0Zm9yICh2YXIgaSBpbiB0aGlzKVxuXHRcdFx0XHRpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShpKSlcblx0XHRcdFx0XHRpdGVyLmNhbGwoYmluZCwgdGhpc1tpXSwgaSwgdGhpcyk7XG5cdFx0fSxcblxuXHRcdGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgZnVuY3Rpb24ocHJvdG8pIHtcblx0XHRcdHJldHVybiB7IF9fcHJvdG9fXzogcHJvdG8gfTtcblx0XHR9LFxuXG5cdFx0ZGVzY3JpYmUgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIHx8IGZ1bmN0aW9uKG9iaiwgbmFtZSkge1xuXHRcdFx0dmFyIGdldCA9IG9iai5fX2xvb2t1cEdldHRlcl9fICYmIG9iai5fX2xvb2t1cEdldHRlcl9fKG5hbWUpO1xuXHRcdFx0cmV0dXJuIGdldFxuXHRcdFx0XHRcdD8geyBnZXQ6IGdldCwgc2V0OiBvYmouX19sb29rdXBTZXR0ZXJfXyhuYW1lKSxcblx0XHRcdFx0XHRcdGVudW1lcmFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9XG5cdFx0XHRcdFx0OiBvYmouaGFzT3duUHJvcGVydHkobmFtZSlcblx0XHRcdFx0XHRcdD8geyB2YWx1ZTogb2JqW25hbWVdLCBlbnVtZXJhYmxlOiB0cnVlLFxuXHRcdFx0XHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsIHdyaXRhYmxlOiB0cnVlIH1cblx0XHRcdFx0XHRcdDogbnVsbDtcblx0XHR9LFxuXG5cdFx0X2RlZmluZSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eSB8fCBmdW5jdGlvbihvYmosIG5hbWUsIGRlc2MpIHtcblx0XHRcdGlmICgoZGVzYy5nZXQgfHwgZGVzYy5zZXQpICYmIG9iai5fX2RlZmluZUdldHRlcl9fKSB7XG5cdFx0XHRcdGlmIChkZXNjLmdldClcblx0XHRcdFx0XHRvYmouX19kZWZpbmVHZXR0ZXJfXyhuYW1lLCBkZXNjLmdldCk7XG5cdFx0XHRcdGlmIChkZXNjLnNldClcblx0XHRcdFx0XHRvYmouX19kZWZpbmVTZXR0ZXJfXyhuYW1lLCBkZXNjLnNldCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvYmpbbmFtZV0gPSBkZXNjLnZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG9iajtcblx0XHR9LFxuXG5cdFx0ZGVmaW5lID0gZnVuY3Rpb24ob2JqLCBuYW1lLCBkZXNjKSB7XG5cdFx0XHRkZWxldGUgb2JqW25hbWVdO1xuXHRcdFx0cmV0dXJuIF9kZWZpbmUob2JqLCBuYW1lLCBkZXNjKTtcblx0XHR9O1xuXG5cdGZ1bmN0aW9uIGluamVjdChkZXN0LCBzcmMsIGVudW1lcmFibGUsIGJlYW5zLCBwcmVzZXJ2ZSkge1xuXHRcdHZhciBiZWFuc05hbWVzID0ge307XG5cblx0XHRmdW5jdGlvbiBmaWVsZChuYW1lLCB2YWwpIHtcblx0XHRcdHZhbCA9IHZhbCB8fCAodmFsID0gZGVzY3JpYmUoc3JjLCBuYW1lKSlcblx0XHRcdFx0XHQmJiAodmFsLmdldCA/IHZhbCA6IHZhbC52YWx1ZSk7XG5cdFx0XHRpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycgJiYgdmFsWzBdID09PSAnIycpXG5cdFx0XHRcdHZhbCA9IGRlc3RbdmFsLnN1YnN0cmluZygxKV0gfHwgdmFsO1xuXHRcdFx0dmFyIGlzRnVuYyA9IHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicsXG5cdFx0XHRcdHJlcyA9IHZhbCxcblx0XHRcdFx0cHJldiA9IHByZXNlcnZlIHx8IGlzRnVuYyAmJiAhdmFsLmJhc2Vcblx0XHRcdFx0XHRcdD8gKHZhbCAmJiB2YWwuZ2V0ID8gbmFtZSBpbiBkZXN0IDogZGVzdFtuYW1lXSlcblx0XHRcdFx0XHRcdDogbnVsbCxcblx0XHRcdFx0YmVhbjtcblx0XHRcdGlmICghcHJlc2VydmUgfHwgIXByZXYpIHtcblx0XHRcdFx0aWYgKGlzRnVuYyAmJiBwcmV2KVxuXHRcdFx0XHRcdHZhbC5iYXNlID0gcHJldjtcblx0XHRcdFx0aWYgKGlzRnVuYyAmJiBiZWFucyAhPT0gZmFsc2Vcblx0XHRcdFx0XHRcdCYmIChiZWFuID0gbmFtZS5tYXRjaCgvXihbZ3NdZXR8aXMpKChbQS1aXSkoLiopKSQvKSkpXG5cdFx0XHRcdFx0YmVhbnNOYW1lc1tiZWFuWzNdLnRvTG93ZXJDYXNlKCkgKyBiZWFuWzRdXSA9IGJlYW5bMl07XG5cdFx0XHRcdGlmICghcmVzIHx8IGlzRnVuYyB8fCAhcmVzLmdldCB8fCB0eXBlb2YgcmVzLmdldCAhPT0gJ2Z1bmN0aW9uJ1xuXHRcdFx0XHRcdFx0fHwgIUJhc2UuaXNQbGFpbk9iamVjdChyZXMpKVxuXHRcdFx0XHRcdHJlcyA9IHsgdmFsdWU6IHJlcywgd3JpdGFibGU6IHRydWUgfTtcblx0XHRcdFx0aWYgKChkZXNjcmliZShkZXN0LCBuYW1lKVxuXHRcdFx0XHRcdFx0fHwgeyBjb25maWd1cmFibGU6IHRydWUgfSkuY29uZmlndXJhYmxlKSB7XG5cdFx0XHRcdFx0cmVzLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG5cdFx0XHRcdFx0cmVzLmVudW1lcmFibGUgPSBlbnVtZXJhYmxlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZmluZShkZXN0LCBuYW1lLCByZXMpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc3JjKSB7XG5cdFx0XHRmb3IgKHZhciBuYW1lIGluIHNyYykge1xuXHRcdFx0XHRpZiAoc3JjLmhhc093blByb3BlcnR5KG5hbWUpICYmICFoaWRkZW4udGVzdChuYW1lKSlcblx0XHRcdFx0XHRmaWVsZChuYW1lKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIG5hbWUgaW4gYmVhbnNOYW1lcykge1xuXHRcdFx0XHR2YXIgcGFydCA9IGJlYW5zTmFtZXNbbmFtZV0sXG5cdFx0XHRcdFx0c2V0ID0gZGVzdFsnc2V0JyArIHBhcnRdLFxuXHRcdFx0XHRcdGdldCA9IGRlc3RbJ2dldCcgKyBwYXJ0XSB8fCBzZXQgJiYgZGVzdFsnaXMnICsgcGFydF07XG5cdFx0XHRcdGlmIChnZXQgJiYgKGJlYW5zID09PSB0cnVlIHx8IGdldC5sZW5ndGggPT09IDApKVxuXHRcdFx0XHRcdGZpZWxkKG5hbWUsIHsgZ2V0OiBnZXQsIHNldDogc2V0IH0pO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gZGVzdDtcblx0fVxuXG5cdGZ1bmN0aW9uIGVhY2gob2JqLCBpdGVyLCBiaW5kKSB7XG5cdFx0aWYgKG9iailcblx0XHRcdCgnbGVuZ3RoJyBpbiBvYmogJiYgIW9iai5nZXRMZW5ndGhcblx0XHRcdFx0XHQmJiB0eXBlb2Ygb2JqLmxlbmd0aCA9PT0gJ251bWJlcidcblx0XHRcdFx0PyBmb3JFYWNoXG5cdFx0XHRcdDogZm9ySW4pLmNhbGwob2JqLCBpdGVyLCBiaW5kID0gYmluZCB8fCBvYmopO1xuXHRcdHJldHVybiBiaW5kO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0KG9iaiwgcHJvcHMsIGV4Y2x1ZGUpIHtcblx0XHRmb3IgKHZhciBrZXkgaW4gcHJvcHMpXG5cdFx0XHRpZiAocHJvcHMuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhKGV4Y2x1ZGUgJiYgZXhjbHVkZVtrZXldKSlcblx0XHRcdFx0b2JqW2tleV0gPSBwcm9wc1trZXldO1xuXHRcdHJldHVybiBvYmo7XG5cdH1cblxuXHRyZXR1cm4gaW5qZWN0KGZ1bmN0aW9uIEJhc2UoKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c2V0KHRoaXMsIGFyZ3VtZW50c1tpXSk7XG5cdH0sIHtcblx0XHRpbmplY3Q6IGZ1bmN0aW9uKHNyYykge1xuXHRcdFx0aWYgKHNyYykge1xuXHRcdFx0XHR2YXIgc3RhdGljcyA9IHNyYy5zdGF0aWNzID09PSB0cnVlID8gc3JjIDogc3JjLnN0YXRpY3MsXG5cdFx0XHRcdFx0YmVhbnMgPSBzcmMuYmVhbnMsXG5cdFx0XHRcdFx0cHJlc2VydmUgPSBzcmMucHJlc2VydmU7XG5cdFx0XHRcdGlmIChzdGF0aWNzICE9PSBzcmMpXG5cdFx0XHRcdFx0aW5qZWN0KHRoaXMucHJvdG90eXBlLCBzcmMsIHNyYy5lbnVtZXJhYmxlLCBiZWFucywgcHJlc2VydmUpO1xuXHRcdFx0XHRpbmplY3QodGhpcywgc3RhdGljcywgdHJ1ZSwgYmVhbnMsIHByZXNlcnZlKTtcblx0XHRcdH1cblx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0dGhpcy5pbmplY3QoYXJndW1lbnRzW2ldKTtcblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGJhc2UgPSB0aGlzLFxuXHRcdFx0XHRjdG9yLFxuXHRcdFx0XHRwcm90bztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aWYgKGN0b3IgPSBhcmd1bWVudHNbaV0uaW5pdGlhbGl6ZSlcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdGN0b3IgPSBjdG9yIHx8IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRiYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR9O1xuXHRcdFx0cHJvdG8gPSBjdG9yLnByb3RvdHlwZSA9IGNyZWF0ZSh0aGlzLnByb3RvdHlwZSk7XG5cdFx0XHRkZWZpbmUocHJvdG8sICdjb25zdHJ1Y3RvcicsXG5cdFx0XHRcdFx0eyB2YWx1ZTogY3Rvciwgd3JpdGFibGU6IHRydWUsIGNvbmZpZ3VyYWJsZTogdHJ1ZSB9KTtcblx0XHRcdGluamVjdChjdG9yLCB0aGlzLCB0cnVlKTtcblx0XHRcdGlmIChhcmd1bWVudHMubGVuZ3RoKVxuXHRcdFx0XHR0aGlzLmluamVjdC5hcHBseShjdG9yLCBhcmd1bWVudHMpO1xuXHRcdFx0Y3Rvci5iYXNlID0gYmFzZTtcblx0XHRcdHJldHVybiBjdG9yO1xuXHRcdH1cblx0fSwgdHJ1ZSkuaW5qZWN0KHtcblx0XHRpbmplY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzcmMgPSBhcmd1bWVudHNbaV07XG5cdFx0XHRcdGlmIChzcmMpXG5cdFx0XHRcdFx0aW5qZWN0KHRoaXMsIHNyYywgc3JjLmVudW1lcmFibGUsIHNyYy5iZWFucywgc3JjLnByZXNlcnZlKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzO1xuXHRcdH0sXG5cblx0XHRleHRlbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHJlcyA9IGNyZWF0ZSh0aGlzKTtcblx0XHRcdHJldHVybiByZXMuaW5qZWN0LmFwcGx5KHJlcywgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0ZWFjaDogZnVuY3Rpb24oaXRlciwgYmluZCkge1xuXHRcdFx0cmV0dXJuIGVhY2godGhpcywgaXRlciwgYmluZCk7XG5cdFx0fSxcblxuXHRcdHNldDogZnVuY3Rpb24ocHJvcHMpIHtcblx0XHRcdHJldHVybiBzZXQodGhpcywgcHJvcHMpO1xuXHRcdH0sXG5cblx0XHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gbmV3IHRoaXMuY29uc3RydWN0b3IodGhpcyk7XG5cdFx0fSxcblxuXHRcdHN0YXRpY3M6IHtcblx0XHRcdGVhY2g6IGVhY2gsXG5cdFx0XHRjcmVhdGU6IGNyZWF0ZSxcblx0XHRcdGRlZmluZTogZGVmaW5lLFxuXHRcdFx0ZGVzY3JpYmU6IGRlc2NyaWJlLFxuXHRcdFx0c2V0OiBzZXQsXG5cblx0XHRcdGNsb25lOiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0cmV0dXJuIHNldChuZXcgb2JqLmNvbnN0cnVjdG9yKCksIG9iaik7XG5cdFx0XHR9LFxuXG5cdFx0XHRpc1BsYWluT2JqZWN0OiBmdW5jdGlvbihvYmopIHtcblx0XHRcdFx0dmFyIGN0b3IgPSBvYmogIT0gbnVsbCAmJiBvYmouY29uc3RydWN0b3I7XG5cdFx0XHRcdHJldHVybiBjdG9yICYmIChjdG9yID09PSBPYmplY3QgfHwgY3RvciA9PT0gQmFzZVxuXHRcdFx0XHRcdFx0fHwgY3Rvci5uYW1lID09PSAnT2JqZWN0Jyk7XG5cdFx0XHR9LFxuXG5cdFx0XHRwaWNrOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRcdHJldHVybiBhICE9PSB1bmRlZmluZWQgPyBhIDogYjtcblx0XHRcdH1cblx0XHR9XG5cdH0pO1xufTtcblxuaWYgKHR5cGVvZiBtb2R1bGUgIT09ICd1bmRlZmluZWQnKVxuXHRtb2R1bGUuZXhwb3J0cyA9IEJhc2U7XG5cbkJhc2UuaW5qZWN0KHtcblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pZCAhPSBudWxsXG5cdFx0XHQ/ICAodGhpcy5fY2xhc3MgfHwgJ09iamVjdCcpICsgKHRoaXMuX25hbWVcblx0XHRcdFx0PyBcIiAnXCIgKyB0aGlzLl9uYW1lICsgXCInXCJcblx0XHRcdFx0OiAnIEAnICsgdGhpcy5faWQpXG5cdFx0XHQ6ICd7ICcgKyBCYXNlLmVhY2godGhpcywgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHRpZiAoIS9eXy8udGVzdChrZXkpKSB7XG5cdFx0XHRcdFx0dmFyIHR5cGUgPSB0eXBlb2YgdmFsdWU7XG5cdFx0XHRcdFx0dGhpcy5wdXNoKGtleSArICc6ICcgKyAodHlwZSA9PT0gJ251bWJlcidcblx0XHRcdFx0XHRcdFx0PyBGb3JtYXR0ZXIuaW5zdGFuY2UubnVtYmVyKHZhbHVlKVxuXHRcdFx0XHRcdFx0XHQ6IHR5cGUgPT09ICdzdHJpbmcnID8gXCInXCIgKyB2YWx1ZSArIFwiJ1wiIDogdmFsdWUpKTtcblx0XHRcdFx0fVxuXHRcdFx0fSwgW10pLmpvaW4oJywgJykgKyAnIH0nO1xuXHR9LFxuXG5cdGdldENsYXNzTmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NsYXNzIHx8ICcnO1xuXHR9LFxuXG5cdGV4cG9ydEpTT046IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gQmFzZS5leHBvcnRKU09OKHRoaXMsIG9wdGlvbnMpO1xuXHR9LFxuXG5cdHRvSlNPTjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMpO1xuXHR9LFxuXG5cdF9zZXQ6IGZ1bmN0aW9uKHByb3BzLCBleGNsdWRlLCBkb250Q2hlY2spIHtcblx0XHRpZiAocHJvcHMgJiYgKGRvbnRDaGVjayB8fCBCYXNlLmlzUGxhaW5PYmplY3QocHJvcHMpKSkge1xuXHRcdFx0dmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcy5fZmlsdGVyaW5nIHx8IHByb3BzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGtleSA9IGtleXNbaV07XG5cdFx0XHRcdGlmICghKGV4Y2x1ZGUgJiYgZXhjbHVkZVtrZXldKSkge1xuXHRcdFx0XHRcdHZhciB2YWx1ZSA9IHByb3BzW2tleV07XG5cdFx0XHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdFx0XHR0aGlzW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblxuXHRcdGV4cG9ydHM6IHtcblx0XHRcdGVudW1lcmFibGU6IHRydWVcblx0XHR9LFxuXG5cdFx0ZXh0ZW5kOiBmdW5jdGlvbiBleHRlbmQoKSB7XG5cdFx0XHR2YXIgcmVzID0gZXh0ZW5kLmJhc2UuYXBwbHkodGhpcywgYXJndW1lbnRzKSxcblx0XHRcdFx0bmFtZSA9IHJlcy5wcm90b3R5cGUuX2NsYXNzO1xuXHRcdFx0aWYgKG5hbWUgJiYgIUJhc2UuZXhwb3J0c1tuYW1lXSlcblx0XHRcdFx0QmFzZS5leHBvcnRzW25hbWVdID0gcmVzO1xuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9LFxuXG5cdFx0ZXF1YWxzOiBmdW5jdGlvbihvYmoxLCBvYmoyKSB7XG5cdFx0XHRpZiAob2JqMSA9PT0gb2JqMilcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRpZiAob2JqMSAmJiBvYmoxLmVxdWFscylcblx0XHRcdFx0cmV0dXJuIG9iajEuZXF1YWxzKG9iajIpO1xuXHRcdFx0aWYgKG9iajIgJiYgb2JqMi5lcXVhbHMpXG5cdFx0XHRcdHJldHVybiBvYmoyLmVxdWFscyhvYmoxKTtcblx0XHRcdGlmIChvYmoxICYmIG9iajJcblx0XHRcdFx0XHQmJiB0eXBlb2Ygb2JqMSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG9iajIgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGlmIChBcnJheS5pc0FycmF5KG9iajEpICYmIEFycmF5LmlzQXJyYXkob2JqMikpIHtcblx0XHRcdFx0XHR2YXIgbGVuZ3RoID0gb2JqMS5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKGxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpXG5cdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0d2hpbGUgKGxlbmd0aC0tKSB7XG5cdFx0XHRcdFx0XHRpZiAoIUJhc2UuZXF1YWxzKG9iajFbbGVuZ3RoXSwgb2JqMltsZW5ndGhdKSlcblx0XHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iajEpLFxuXHRcdFx0XHRcdFx0bGVuZ3RoID0ga2V5cy5sZW5ndGg7XG5cdFx0XHRcdFx0aWYgKGxlbmd0aCAhPT0gT2JqZWN0LmtleXMob2JqMikubGVuZ3RoKVxuXHRcdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRcdHdoaWxlIChsZW5ndGgtLSkge1xuXHRcdFx0XHRcdFx0dmFyIGtleSA9IGtleXNbbGVuZ3RoXTtcblx0XHRcdFx0XHRcdGlmICghKG9iajIuaGFzT3duUHJvcGVydHkoa2V5KVxuXHRcdFx0XHRcdFx0XHRcdCYmIEJhc2UuZXF1YWxzKG9iajFba2V5XSwgb2JqMltrZXldKSkpXG5cdFx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fSxcblxuXHRcdHJlYWQ6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0LCBvcHRpb25zLCBsZW5ndGgpIHtcblx0XHRcdGlmICh0aGlzID09PSBCYXNlKSB7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IHRoaXMucGVlayhsaXN0LCBzdGFydCk7XG5cdFx0XHRcdGxpc3QuX19pbmRleCsrO1xuXHRcdFx0XHRyZXR1cm4gdmFsdWU7XG5cdFx0XHR9XG5cdFx0XHR2YXIgcHJvdG8gPSB0aGlzLnByb3RvdHlwZSxcblx0XHRcdFx0cmVhZEluZGV4ID0gcHJvdG8uX3JlYWRJbmRleCxcblx0XHRcdFx0aW5kZXggPSBzdGFydCB8fCByZWFkSW5kZXggJiYgbGlzdC5fX2luZGV4IHx8IDA7XG5cdFx0XHRpZiAoIWxlbmd0aClcblx0XHRcdFx0bGVuZ3RoID0gbGlzdC5sZW5ndGggLSBpbmRleDtcblx0XHRcdHZhciBvYmogPSBsaXN0W2luZGV4XTtcblx0XHRcdGlmIChvYmogaW5zdGFuY2VvZiB0aGlzXG5cdFx0XHRcdHx8IG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFkTnVsbCAmJiBvYmogPT0gbnVsbCAmJiBsZW5ndGggPD0gMSkge1xuXHRcdFx0XHRpZiAocmVhZEluZGV4KVxuXHRcdFx0XHRcdGxpc3QuX19pbmRleCA9IGluZGV4ICsgMTtcblx0XHRcdFx0cmV0dXJuIG9iaiAmJiBvcHRpb25zICYmIG9wdGlvbnMuY2xvbmUgPyBvYmouY2xvbmUoKSA6IG9iajtcblx0XHRcdH1cblx0XHRcdG9iaiA9IEJhc2UuY3JlYXRlKHRoaXMucHJvdG90eXBlKTtcblx0XHRcdGlmIChyZWFkSW5kZXgpXG5cdFx0XHRcdG9iai5fX3JlYWQgPSB0cnVlO1xuXHRcdFx0b2JqID0gb2JqLmluaXRpYWxpemUuYXBwbHkob2JqLCBpbmRleCA+IDAgfHwgbGVuZ3RoIDwgbGlzdC5sZW5ndGhcblx0XHRcdFx0PyBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChsaXN0LCBpbmRleCwgaW5kZXggKyBsZW5ndGgpXG5cdFx0XHRcdDogbGlzdCkgfHwgb2JqO1xuXHRcdFx0aWYgKHJlYWRJbmRleCkge1xuXHRcdFx0XHRsaXN0Ll9faW5kZXggPSBpbmRleCArIG9iai5fX3JlYWQ7XG5cdFx0XHRcdG9iai5fX3JlYWQgPSB1bmRlZmluZWQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gb2JqO1xuXHRcdH0sXG5cblx0XHRwZWVrOiBmdW5jdGlvbihsaXN0LCBzdGFydCkge1xuXHRcdFx0cmV0dXJuIGxpc3RbbGlzdC5fX2luZGV4ID0gc3RhcnQgfHwgbGlzdC5fX2luZGV4IHx8IDBdO1xuXHRcdH0sXG5cblx0XHRyZW1haW46IGZ1bmN0aW9uKGxpc3QpIHtcblx0XHRcdHJldHVybiBsaXN0Lmxlbmd0aCAtIChsaXN0Ll9faW5kZXggfHwgMCk7XG5cdFx0fSxcblxuXHRcdHJlYWRBbGw6IGZ1bmN0aW9uKGxpc3QsIHN0YXJ0LCBvcHRpb25zKSB7XG5cdFx0XHR2YXIgcmVzID0gW10sXG5cdFx0XHRcdGVudHJ5O1xuXHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0IHx8IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRyZXMucHVzaChBcnJheS5pc0FycmF5KGVudHJ5ID0gbGlzdFtpXSlcblx0XHRcdFx0XHRcdD8gdGhpcy5yZWFkKGVudHJ5LCAwLCBvcHRpb25zKVxuXHRcdFx0XHRcdFx0OiB0aGlzLnJlYWQobGlzdCwgaSwgb3B0aW9ucywgMSkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHJlcztcblx0XHR9LFxuXG5cdFx0cmVhZE5hbWVkOiBmdW5jdGlvbihsaXN0LCBuYW1lLCBzdGFydCwgb3B0aW9ucywgbGVuZ3RoKSB7XG5cdFx0XHR2YXIgdmFsdWUgPSB0aGlzLmdldE5hbWVkKGxpc3QsIG5hbWUpLFxuXHRcdFx0XHRoYXNPYmplY3QgPSB2YWx1ZSAhPT0gdW5kZWZpbmVkO1xuXHRcdFx0aWYgKGhhc09iamVjdCkge1xuXHRcdFx0XHR2YXIgZmlsdGVyZWQgPSBsaXN0Ll9maWx0ZXJlZDtcblx0XHRcdFx0aWYgKCFmaWx0ZXJlZCkge1xuXHRcdFx0XHRcdGZpbHRlcmVkID0gbGlzdC5fZmlsdGVyZWQgPSBCYXNlLmNyZWF0ZShsaXN0WzBdKTtcblx0XHRcdFx0XHRmaWx0ZXJlZC5fZmlsdGVyaW5nID0gbGlzdFswXTtcblx0XHRcdFx0fVxuXHRcdFx0XHRmaWx0ZXJlZFtuYW1lXSA9IHVuZGVmaW5lZDtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLnJlYWQoaGFzT2JqZWN0ID8gW3ZhbHVlXSA6IGxpc3QsIHN0YXJ0LCBvcHRpb25zLCBsZW5ndGgpO1xuXHRcdH0sXG5cblx0XHRnZXROYW1lZDogZnVuY3Rpb24obGlzdCwgbmFtZSkge1xuXHRcdFx0dmFyIGFyZyA9IGxpc3RbMF07XG5cdFx0XHRpZiAobGlzdC5faGFzT2JqZWN0ID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGxpc3QuX2hhc09iamVjdCA9IGxpc3QubGVuZ3RoID09PSAxICYmIEJhc2UuaXNQbGFpbk9iamVjdChhcmcpO1xuXHRcdFx0aWYgKGxpc3QuX2hhc09iamVjdClcblx0XHRcdFx0cmV0dXJuIG5hbWUgPyBhcmdbbmFtZV0gOiBsaXN0Ll9maWx0ZXJlZCB8fCBhcmc7XG5cdFx0fSxcblxuXHRcdGhhc05hbWVkOiBmdW5jdGlvbihsaXN0LCBuYW1lKSB7XG5cdFx0XHRyZXR1cm4gISF0aGlzLmdldE5hbWVkKGxpc3QsIG5hbWUpO1xuXHRcdH0sXG5cblx0XHRpc1BsYWluVmFsdWU6IGZ1bmN0aW9uKG9iaiwgYXNTdHJpbmcpIHtcblx0XHRcdHJldHVybiB0aGlzLmlzUGxhaW5PYmplY3Qob2JqKSB8fCBBcnJheS5pc0FycmF5KG9iailcblx0XHRcdFx0XHR8fCBhc1N0cmluZyAmJiB0eXBlb2Ygb2JqID09PSAnc3RyaW5nJztcblx0XHR9LFxuXG5cdFx0c2VyaWFsaXplOiBmdW5jdGlvbihvYmosIG9wdGlvbnMsIGNvbXBhY3QsIGRpY3Rpb25hcnkpIHtcblx0XHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXG5cdFx0XHR2YXIgcm9vdCA9ICFkaWN0aW9uYXJ5LFxuXHRcdFx0XHRyZXM7XG5cdFx0XHRpZiAocm9vdCkge1xuXHRcdFx0XHRvcHRpb25zLmZvcm1hdHRlciA9IG5ldyBGb3JtYXR0ZXIob3B0aW9ucy5wcmVjaXNpb24pO1xuXHRcdFx0XHRkaWN0aW9uYXJ5ID0ge1xuXHRcdFx0XHRcdGxlbmd0aDogMCxcblx0XHRcdFx0XHRkZWZpbml0aW9uczoge30sXG5cdFx0XHRcdFx0cmVmZXJlbmNlczoge30sXG5cdFx0XHRcdFx0YWRkOiBmdW5jdGlvbihpdGVtLCBjcmVhdGUpIHtcblx0XHRcdFx0XHRcdHZhciBpZCA9ICcjJyArIGl0ZW0uX2lkLFxuXHRcdFx0XHRcdFx0XHRyZWYgPSB0aGlzLnJlZmVyZW5jZXNbaWRdO1xuXHRcdFx0XHRcdFx0aWYgKCFyZWYpIHtcblx0XHRcdFx0XHRcdFx0dGhpcy5sZW5ndGgrKztcblx0XHRcdFx0XHRcdFx0dmFyIHJlcyA9IGNyZWF0ZS5jYWxsKGl0ZW0pLFxuXHRcdFx0XHRcdFx0XHRcdG5hbWUgPSBpdGVtLl9jbGFzcztcblx0XHRcdFx0XHRcdFx0aWYgKG5hbWUgJiYgcmVzWzBdICE9PSBuYW1lKVxuXHRcdFx0XHRcdFx0XHRcdHJlcy51bnNoaWZ0KG5hbWUpO1xuXHRcdFx0XHRcdFx0XHR0aGlzLmRlZmluaXRpb25zW2lkXSA9IHJlcztcblx0XHRcdFx0XHRcdFx0cmVmID0gdGhpcy5yZWZlcmVuY2VzW2lkXSA9IFtpZF07XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXR1cm4gcmVmO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fTtcblx0XHRcdH1cblx0XHRcdGlmIChvYmogJiYgb2JqLl9zZXJpYWxpemUpIHtcblx0XHRcdFx0cmVzID0gb2JqLl9zZXJpYWxpemUob3B0aW9ucywgZGljdGlvbmFyeSk7XG5cdFx0XHRcdHZhciBuYW1lID0gb2JqLl9jbGFzcztcblx0XHRcdFx0aWYgKG5hbWUgJiYgIWNvbXBhY3QgJiYgIXJlcy5fY29tcGFjdCAmJiByZXNbMF0gIT09IG5hbWUpXG5cdFx0XHRcdFx0cmVzLnVuc2hpZnQobmFtZSk7XG5cdFx0XHR9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkob2JqKSkge1xuXHRcdFx0XHRyZXMgPSBbXTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHJlc1tpXSA9IEJhc2Uuc2VyaWFsaXplKG9ialtpXSwgb3B0aW9ucywgY29tcGFjdCxcblx0XHRcdFx0XHRcdFx0ZGljdGlvbmFyeSk7XG5cdFx0XHRcdGlmIChjb21wYWN0KVxuXHRcdFx0XHRcdHJlcy5fY29tcGFjdCA9IHRydWU7XG5cdFx0XHR9IGVsc2UgaWYgKEJhc2UuaXNQbGFpbk9iamVjdChvYmopKSB7XG5cdFx0XHRcdHJlcyA9IHt9O1xuXHRcdFx0XHR2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIga2V5ID0ga2V5c1tpXTtcblx0XHRcdFx0XHRyZXNba2V5XSA9IEJhc2Uuc2VyaWFsaXplKG9ialtrZXldLCBvcHRpb25zLCBjb21wYWN0LFxuXHRcdFx0XHRcdFx0XHRkaWN0aW9uYXJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIGlmICh0eXBlb2Ygb2JqID09PSAnbnVtYmVyJykge1xuXHRcdFx0XHRyZXMgPSBvcHRpb25zLmZvcm1hdHRlci5udW1iZXIob2JqLCBvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRyZXMgPSBvYmo7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gcm9vdCAmJiBkaWN0aW9uYXJ5Lmxlbmd0aCA+IDBcblx0XHRcdFx0XHQ/IFtbJ2RpY3Rpb25hcnknLCBkaWN0aW9uYXJ5LmRlZmluaXRpb25zXSwgcmVzXVxuXHRcdFx0XHRcdDogcmVzO1xuXHRcdH0sXG5cblx0XHRkZXNlcmlhbGl6ZTogZnVuY3Rpb24oanNvbiwgY3JlYXRlLCBfZGF0YSwgX2lzRGljdGlvbmFyeSkge1xuXHRcdFx0dmFyIHJlcyA9IGpzb24sXG5cdFx0XHRcdGlzUm9vdCA9ICFfZGF0YTtcblx0XHRcdF9kYXRhID0gX2RhdGEgfHwge307XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShqc29uKSkge1xuXHRcdFx0XHR2YXIgdHlwZSA9IGpzb25bMF0sXG5cdFx0XHRcdFx0aXNEaWN0aW9uYXJ5ID0gdHlwZSA9PT0gJ2RpY3Rpb25hcnknO1xuXHRcdFx0XHRpZiAoanNvbi5sZW5ndGggPT0gMSAmJiAvXiMvLnRlc3QodHlwZSkpXG5cdFx0XHRcdFx0cmV0dXJuIF9kYXRhLmRpY3Rpb25hcnlbdHlwZV07XG5cdFx0XHRcdHR5cGUgPSBCYXNlLmV4cG9ydHNbdHlwZV07XG5cdFx0XHRcdHJlcyA9IFtdO1xuXHRcdFx0XHRpZiAoX2lzRGljdGlvbmFyeSlcblx0XHRcdFx0XHRfZGF0YS5kaWN0aW9uYXJ5ID0gcmVzO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gdHlwZSA/IDEgOiAwLCBsID0ganNvbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0cmVzLnB1c2goQmFzZS5kZXNlcmlhbGl6ZShqc29uW2ldLCBjcmVhdGUsIF9kYXRhLFxuXHRcdFx0XHRcdFx0XHRpc0RpY3Rpb25hcnkpKTtcblx0XHRcdFx0aWYgKHR5cGUpIHtcblx0XHRcdFx0XHR2YXIgYXJncyA9IHJlcztcblx0XHRcdFx0XHRpZiAoY3JlYXRlKSB7XG5cdFx0XHRcdFx0XHRyZXMgPSBjcmVhdGUodHlwZSwgYXJncyk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdHJlcyA9IEJhc2UuY3JlYXRlKHR5cGUucHJvdG90eXBlKTtcblx0XHRcdFx0XHRcdHR5cGUuYXBwbHkocmVzLCBhcmdzKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAoQmFzZS5pc1BsYWluT2JqZWN0KGpzb24pKSB7XG5cdFx0XHRcdHJlcyA9IHt9O1xuXHRcdFx0XHRpZiAoX2lzRGljdGlvbmFyeSlcblx0XHRcdFx0XHRfZGF0YS5kaWN0aW9uYXJ5ID0gcmVzO1xuXHRcdFx0XHRmb3IgKHZhciBrZXkgaW4ganNvbilcblx0XHRcdFx0XHRyZXNba2V5XSA9IEJhc2UuZGVzZXJpYWxpemUoanNvbltrZXldLCBjcmVhdGUsIF9kYXRhKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBpc1Jvb3QgJiYganNvbiAmJiBqc29uLmxlbmd0aCAmJiBqc29uWzBdWzBdID09PSAnZGljdGlvbmFyeSdcblx0XHRcdFx0XHQ/IHJlc1sxXVxuXHRcdFx0XHRcdDogcmVzO1xuXHRcdH0sXG5cblx0XHRleHBvcnRKU09OOiBmdW5jdGlvbihvYmosIG9wdGlvbnMpIHtcblx0XHRcdHZhciBqc29uID0gQmFzZS5zZXJpYWxpemUob2JqLCBvcHRpb25zKTtcblx0XHRcdHJldHVybiBvcHRpb25zICYmIG9wdGlvbnMuYXNTdHJpbmcgPT09IGZhbHNlXG5cdFx0XHRcdFx0PyBqc29uXG5cdFx0XHRcdFx0OiBKU09OLnN0cmluZ2lmeShqc29uKTtcblx0XHR9LFxuXG5cdFx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbiwgdGFyZ2V0KSB7XG5cdFx0XHRyZXR1cm4gQmFzZS5kZXNlcmlhbGl6ZShcblx0XHRcdFx0XHR0eXBlb2YganNvbiA9PT0gJ3N0cmluZycgPyBKU09OLnBhcnNlKGpzb24pIDoganNvbixcblx0XHRcdFx0XHRmdW5jdGlvbih0eXBlLCBhcmdzKSB7XG5cdFx0XHRcdFx0XHR2YXIgb2JqID0gdGFyZ2V0ICYmIHRhcmdldC5jb25zdHJ1Y3RvciA9PT0gdHlwZVxuXHRcdFx0XHRcdFx0XHRcdD8gdGFyZ2V0XG5cdFx0XHRcdFx0XHRcdFx0OiBCYXNlLmNyZWF0ZSh0eXBlLnByb3RvdHlwZSksXG5cdFx0XHRcdFx0XHRcdGlzVGFyZ2V0ID0gb2JqID09PSB0YXJnZXQ7XG5cdFx0XHRcdFx0XHRpZiAoYXJncy5sZW5ndGggPT09IDEgJiYgb2JqIGluc3RhbmNlb2YgSXRlbVxuXHRcdFx0XHRcdFx0XHRcdCYmIChpc1RhcmdldCB8fCAhKG9iaiBpbnN0YW5jZW9mIExheWVyKSkpIHtcblx0XHRcdFx0XHRcdFx0dmFyIGFyZyA9IGFyZ3NbMF07XG5cdFx0XHRcdFx0XHRcdGlmIChCYXNlLmlzUGxhaW5PYmplY3QoYXJnKSlcblx0XHRcdFx0XHRcdFx0XHRhcmcuaW5zZXJ0ID0gZmFsc2U7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR0eXBlLmFwcGx5KG9iaiwgYXJncyk7XG5cdFx0XHRcdFx0XHRpZiAoaXNUYXJnZXQpXG5cdFx0XHRcdFx0XHRcdHRhcmdldCA9IG51bGw7XG5cdFx0XHRcdFx0XHRyZXR1cm4gb2JqO1xuXHRcdFx0XHRcdH0pO1xuXHRcdH0sXG5cblx0XHRzcGxpY2U6IGZ1bmN0aW9uKGxpc3QsIGl0ZW1zLCBpbmRleCwgcmVtb3ZlKSB7XG5cdFx0XHR2YXIgYW1vdW50ID0gaXRlbXMgJiYgaXRlbXMubGVuZ3RoLFxuXHRcdFx0XHRhcHBlbmQgPSBpbmRleCA9PT0gdW5kZWZpbmVkO1xuXHRcdFx0aW5kZXggPSBhcHBlbmQgPyBsaXN0Lmxlbmd0aCA6IGluZGV4O1xuXHRcdFx0aWYgKGluZGV4ID4gbGlzdC5sZW5ndGgpXG5cdFx0XHRcdGluZGV4ID0gbGlzdC5sZW5ndGg7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKVxuXHRcdFx0XHRpdGVtc1tpXS5faW5kZXggPSBpbmRleCArIGk7XG5cdFx0XHRpZiAoYXBwZW5kKSB7XG5cdFx0XHRcdGxpc3QucHVzaC5hcHBseShsaXN0LCBpdGVtcyk7XG5cdFx0XHRcdHJldHVybiBbXTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBhcmdzID0gW2luZGV4LCByZW1vdmVdO1xuXHRcdFx0XHRpZiAoaXRlbXMpXG5cdFx0XHRcdFx0YXJncy5wdXNoLmFwcGx5KGFyZ3MsIGl0ZW1zKTtcblx0XHRcdFx0dmFyIHJlbW92ZWQgPSBsaXN0LnNwbGljZS5hcHBseShsaXN0LCBhcmdzKTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSByZW1vdmVkLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRyZW1vdmVkW2ldLl9pbmRleCA9IHVuZGVmaW5lZDtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IGluZGV4ICsgYW1vdW50LCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0bGlzdFtpXS5faW5kZXggPSBpO1xuXHRcdFx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0Y2FwaXRhbGl6ZTogZnVuY3Rpb24oc3RyKSB7XG5cdFx0XHRyZXR1cm4gc3RyLnJlcGxhY2UoL1xcYlthLXpdL2csIGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0XHRcdHJldHVybiBtYXRjaC50b1VwcGVyQ2FzZSgpO1xuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdGNhbWVsaXplOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvLSguKS9nLCBmdW5jdGlvbihhbGwsIGNocikge1xuXHRcdFx0XHRyZXR1cm4gY2hyLnRvVXBwZXJDYXNlKCk7XG5cdFx0XHR9KTtcblx0XHR9LFxuXG5cdFx0aHlwaGVuYXRlOiBmdW5jdGlvbihzdHIpIHtcblx0XHRcdHJldHVybiBzdHIucmVwbGFjZSgvKFthLXpdKShbQS1aXSkvZywgJyQxLSQyJykudG9Mb3dlckNhc2UoKTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgRW1pdHRlciA9IHtcblx0b246IGZ1bmN0aW9uKHR5cGUsIGZ1bmMpIHtcblx0XHRpZiAodHlwZW9mIHR5cGUgIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRCYXNlLmVhY2godHlwZSwgZnVuY3Rpb24odmFsdWUsIGtleSkge1xuXHRcdFx0XHR0aGlzLm9uKGtleSwgdmFsdWUpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciB0eXBlcyA9IHRoaXMuX2V2ZW50VHlwZXMsXG5cdFx0XHRcdGVudHJ5ID0gdHlwZXMgJiYgdHlwZXNbdHlwZV0sXG5cdFx0XHRcdGhhbmRsZXJzID0gdGhpcy5fY2FsbGJhY2tzID0gdGhpcy5fY2FsbGJhY2tzIHx8IHt9O1xuXHRcdFx0aGFuZGxlcnMgPSBoYW5kbGVyc1t0eXBlXSA9IGhhbmRsZXJzW3R5cGVdIHx8IFtdO1xuXHRcdFx0aWYgKGhhbmRsZXJzLmluZGV4T2YoZnVuYykgPT09IC0xKSB7XG5cdFx0XHRcdGhhbmRsZXJzLnB1c2goZnVuYyk7XG5cdFx0XHRcdGlmIChlbnRyeSAmJiBlbnRyeS5pbnN0YWxsICYmIGhhbmRsZXJzLmxlbmd0aCA9PT0gMSlcblx0XHRcdFx0XHRlbnRyeS5pbnN0YWxsLmNhbGwodGhpcywgdHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdG9mZjogZnVuY3Rpb24odHlwZSwgZnVuYykge1xuXHRcdGlmICh0eXBlb2YgdHlwZSAhPT0gJ3N0cmluZycpIHtcblx0XHRcdEJhc2UuZWFjaCh0eXBlLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0XHRcdHRoaXMub2ZmKGtleSwgdmFsdWUpO1xuXHRcdFx0fSwgdGhpcyk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciB0eXBlcyA9IHRoaXMuX2V2ZW50VHlwZXMsXG5cdFx0XHRlbnRyeSA9IHR5cGVzICYmIHR5cGVzW3R5cGVdLFxuXHRcdFx0aGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MgJiYgdGhpcy5fY2FsbGJhY2tzW3R5cGVdLFxuXHRcdFx0aW5kZXg7XG5cdFx0aWYgKGhhbmRsZXJzKSB7XG5cdFx0XHRpZiAoIWZ1bmMgfHwgKGluZGV4ID0gaGFuZGxlcnMuaW5kZXhPZihmdW5jKSkgIT09IC0xXG5cdFx0XHRcdFx0JiYgaGFuZGxlcnMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRcdGlmIChlbnRyeSAmJiBlbnRyeS51bmluc3RhbGwpXG5cdFx0XHRcdFx0ZW50cnkudW5pbnN0YWxsLmNhbGwodGhpcywgdHlwZSk7XG5cdFx0XHRcdGRlbGV0ZSB0aGlzLl9jYWxsYmFja3NbdHlwZV07XG5cdFx0XHR9IGVsc2UgaWYgKGluZGV4ICE9PSAtMSkge1xuXHRcdFx0XHRoYW5kbGVycy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRvbmNlOiBmdW5jdGlvbih0eXBlLCBmdW5jKSB7XG5cdFx0cmV0dXJuIHRoaXMub24odHlwZSwgZnVuY3Rpb24oKSB7XG5cdFx0XHRmdW5jLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0XHR0aGlzLm9mZih0eXBlLCBmdW5jKTtcblx0XHR9KTtcblx0fSxcblxuXHRlbWl0OiBmdW5jdGlvbih0eXBlLCBldmVudCkge1xuXHRcdHZhciBoYW5kbGVycyA9IHRoaXMuX2NhbGxiYWNrcyAmJiB0aGlzLl9jYWxsYmFja3NbdHlwZV07XG5cdFx0aWYgKCFoYW5kbGVycylcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcblx0XHRoYW5kbGVycyA9IGhhbmRsZXJzLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChoYW5kbGVyc1tpXS5hcHBseSh0aGlzLCBhcmdzKSA9PT0gZmFsc2UpIHtcblx0XHRcdFx0aWYgKGV2ZW50ICYmIGV2ZW50LnN0b3ApXG5cdFx0XHRcdFx0ZXZlbnQuc3RvcCgpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0cmVzcG9uZHM6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRyZXR1cm4gISEodGhpcy5fY2FsbGJhY2tzICYmIHRoaXMuX2NhbGxiYWNrc1t0eXBlXSk7XG5cdH0sXG5cblx0YXR0YWNoOiAnI29uJyxcblx0ZGV0YWNoOiAnI29mZicsXG5cdGZpcmU6ICcjZW1pdCcsXG5cblx0X2luc3RhbGxFdmVudHM6IGZ1bmN0aW9uKGluc3RhbGwpIHtcblx0XHR2YXIgaGFuZGxlcnMgPSB0aGlzLl9jYWxsYmFja3MsXG5cdFx0XHRrZXkgPSBpbnN0YWxsID8gJ2luc3RhbGwnIDogJ3VuaW5zdGFsbCc7XG5cdFx0Zm9yICh2YXIgdHlwZSBpbiBoYW5kbGVycykge1xuXHRcdFx0aWYgKGhhbmRsZXJzW3R5cGVdLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dmFyIHR5cGVzID0gdGhpcy5fZXZlbnRUeXBlcyxcblx0XHRcdFx0XHRlbnRyeSA9IHR5cGVzICYmIHR5cGVzW3R5cGVdLFxuXHRcdFx0XHRcdGZ1bmMgPSBlbnRyeSAmJiBlbnRyeVtrZXldO1xuXHRcdFx0XHRpZiAoZnVuYylcblx0XHRcdFx0XHRmdW5jLmNhbGwodGhpcywgdHlwZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRpbmplY3Q6IGZ1bmN0aW9uIGluamVjdChzcmMpIHtcblx0XHRcdHZhciBldmVudHMgPSBzcmMuX2V2ZW50cztcblx0XHRcdGlmIChldmVudHMpIHtcblx0XHRcdFx0dmFyIHR5cGVzID0ge307XG5cdFx0XHRcdEJhc2UuZWFjaChldmVudHMsIGZ1bmN0aW9uKGVudHJ5LCBrZXkpIHtcblx0XHRcdFx0XHR2YXIgaXNTdHJpbmcgPSB0eXBlb2YgZW50cnkgPT09ICdzdHJpbmcnLFxuXHRcdFx0XHRcdFx0bmFtZSA9IGlzU3RyaW5nID8gZW50cnkgOiBrZXksXG5cdFx0XHRcdFx0XHRwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdFx0XHRcdFx0dHlwZSA9IG5hbWUuc3Vic3RyaW5nKDIpLnRvTG93ZXJDYXNlKCk7XG5cdFx0XHRcdFx0dHlwZXNbdHlwZV0gPSBpc1N0cmluZyA/IHt9IDogZW50cnk7XG5cdFx0XHRcdFx0bmFtZSA9ICdfJyArIG5hbWU7XG5cdFx0XHRcdFx0c3JjWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0c3JjWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbihmdW5jKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHJldiA9IHRoaXNbbmFtZV07XG5cdFx0XHRcdFx0XHRpZiAocHJldilcblx0XHRcdFx0XHRcdFx0dGhpcy5vZmYodHlwZSwgcHJldik7XG5cdFx0XHRcdFx0XHRpZiAoZnVuYylcblx0XHRcdFx0XHRcdFx0dGhpcy5vbih0eXBlLCBmdW5jKTtcblx0XHRcdFx0XHRcdHRoaXNbbmFtZV0gPSBmdW5jO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRzcmMuX2V2ZW50VHlwZXMgPSB0eXBlcztcblx0XHRcdH1cblx0XHRcdHJldHVybiBpbmplY3QuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fVxufTtcblxudmFyIFBhcGVyU2NvcGUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhcGVyU2NvcGUnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhcGVyU2NvcGUoKSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHRcdHRoaXMuc2V0dGluZ3MgPSBuZXcgQmFzZSh7XG5cdFx0XHRhcHBseU1hdHJpeDogdHJ1ZSxcblx0XHRcdGhhbmRsZVNpemU6IDQsXG5cdFx0XHRoaXRUb2xlcmFuY2U6IDBcblx0XHR9KTtcblx0XHR0aGlzLnByb2plY3QgPSBudWxsO1xuXHRcdHRoaXMucHJvamVjdHMgPSBbXTtcblx0XHR0aGlzLnRvb2xzID0gW107XG5cdFx0dGhpcy5wYWxldHRlcyA9IFtdO1xuXHRcdHRoaXMuX2lkID0gUGFwZXJTY29wZS5faWQrKztcblx0XHRQYXBlclNjb3BlLl9zY29wZXNbdGhpcy5faWRdID0gdGhpcztcblx0XHR2YXIgcHJvdG8gPSBQYXBlclNjb3BlLnByb3RvdHlwZTtcblx0XHRpZiAoIXRoaXMuc3VwcG9ydCkge1xuXHRcdFx0dmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG5cdFx0XHRwcm90by5zdXBwb3J0ID0ge1xuXHRcdFx0XHRuYXRpdmVEYXNoOiAnc2V0TGluZURhc2gnIGluIGN0eCB8fCAnbW96RGFzaCcgaW4gY3R4LFxuXHRcdFx0XHRuYXRpdmVCbGVuZE1vZGVzOiBCbGVuZE1vZGUubmF0aXZlTW9kZXNcblx0XHRcdH07XG5cdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0fVxuXG5cdFx0aWYgKCF0aGlzLmJyb3dzZXIpIHtcblx0XHRcdHZhciBhZ2VudCA9IG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKSxcblx0XHRcdFx0cGxhdGZvcm0gPSAoLyh3aW4pLy5leGVjKGFnZW50KVxuXHRcdFx0XHRcdFx0fHwgLyhtYWMpLy5leGVjKGFnZW50KVxuXHRcdFx0XHRcdFx0fHwgLyhsaW51eCkvLmV4ZWMoYWdlbnQpXG5cdFx0XHRcdFx0XHR8fCBbXSlbMF0sXG5cdFx0XHRcdGJyb3dzZXIgPSBwcm90by5icm93c2VyID0geyBwbGF0Zm9ybTogcGxhdGZvcm0gfTtcblx0XHRcdGlmIChwbGF0Zm9ybSlcblx0XHRcdFx0YnJvd3NlcltwbGF0Zm9ybV0gPSB0cnVlO1xuXHRcdFx0YWdlbnQucmVwbGFjZShcblx0XHRcdFx0LyhvcGVyYXxjaHJvbWV8c2FmYXJpfHdlYmtpdHxmaXJlZm94fG1zaWV8dHJpZGVudHxhdG9tKVxcLz9cXHMqKFsuXFxkXSspKD86Lip2ZXJzaW9uXFwvKFsuXFxkXSspKT8oPzouKnJ2XFw6KFsuXFxkXSspKT8vZyxcblx0XHRcdFx0ZnVuY3Rpb24oYWxsLCBuLCB2MSwgdjIsIHJ2KSB7XG5cdFx0XHRcdFx0aWYgKCFicm93c2VyLmNocm9tZSkge1xuXHRcdFx0XHRcdFx0dmFyIHYgPSBuID09PSAnb3BlcmEnID8gdjIgOiB2MTtcblx0XHRcdFx0XHRcdGlmIChuID09PSAndHJpZGVudCcpIHtcblx0XHRcdFx0XHRcdFx0diA9IHJ2O1xuXHRcdFx0XHRcdFx0XHRuID0gJ21zaWUnO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0YnJvd3Nlci52ZXJzaW9uID0gdjtcblx0XHRcdFx0XHRcdGJyb3dzZXIudmVyc2lvbk51bWJlciA9IHBhcnNlRmxvYXQodik7XG5cdFx0XHRcdFx0XHRicm93c2VyLm5hbWUgPSBuO1xuXHRcdFx0XHRcdFx0YnJvd3NlcltuXSA9IHRydWU7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHQpO1xuXHRcdFx0aWYgKGJyb3dzZXIuY2hyb21lKVxuXHRcdFx0XHRkZWxldGUgYnJvd3Nlci53ZWJraXQ7XG5cdFx0XHRpZiAoYnJvd3Nlci5hdG9tKVxuXHRcdFx0XHRkZWxldGUgYnJvd3Nlci5jaHJvbWU7XG5cdFx0fVxuXHR9LFxuXG5cdHZlcnNpb246IFwiMC45LjI1XCIsXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMucHJvamVjdCAmJiB0aGlzLnByb2plY3QuZ2V0VmlldygpO1xuXHR9LFxuXG5cdGdldFBhcGVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRleGVjdXRlOiBmdW5jdGlvbihjb2RlLCB1cmwsIG9wdGlvbnMpIHtcblx0XHRwYXBlci5QYXBlclNjcmlwdC5leGVjdXRlKGNvZGUsIHRoaXMsIHVybCwgb3B0aW9ucyk7XG5cdFx0Vmlldy51cGRhdGVGb2N1cygpO1xuXHR9LFxuXG5cdGluc3RhbGw6IGZ1bmN0aW9uKHNjb3BlKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdEJhc2UuZWFjaChbJ3Byb2plY3QnLCAndmlldycsICd0b29sJ10sIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0QmFzZS5kZWZpbmUoc2NvcGUsIGtleSwge1xuXHRcdFx0XHRjb25maWd1cmFibGU6IHRydWUsXG5cdFx0XHRcdGdldDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHRoYXRba2V5XTtcblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fSk7XG5cdFx0Zm9yICh2YXIga2V5IGluIHRoaXMpXG5cdFx0XHRpZiAoIS9eXy8udGVzdChrZXkpICYmIHRoaXNba2V5XSlcblx0XHRcdFx0c2NvcGVba2V5XSA9IHRoaXNba2V5XTtcblx0fSxcblxuXHRzZXR1cDogZnVuY3Rpb24oZWxlbWVudCkge1xuXHRcdHBhcGVyID0gdGhpcztcblx0XHR0aGlzLnByb2plY3QgPSBuZXcgUHJvamVjdChlbGVtZW50KTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cGFwZXIgPSB0aGlzO1xuXHR9LFxuXG5cdGNsZWFyOiBmdW5jdGlvbigpIHtcblx0XHRmb3IgKHZhciBpID0gdGhpcy5wcm9qZWN0cy5sZW5ndGggLSAxOyBpID49IDA7IGktLSlcblx0XHRcdHRoaXMucHJvamVjdHNbaV0ucmVtb3ZlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMudG9vbHMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pXG5cdFx0XHR0aGlzLnRvb2xzW2ldLnJlbW92ZSgpO1xuXHRcdGZvciAodmFyIGkgPSB0aGlzLnBhbGV0dGVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dGhpcy5wYWxldHRlc1tpXS5yZW1vdmUoKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuY2xlYXIoKTtcblx0XHRkZWxldGUgUGFwZXJTY29wZS5fc2NvcGVzW3RoaXMuX2lkXTtcblx0fSxcblxuXHRzdGF0aWNzOiBuZXcgZnVuY3Rpb24oKSB7XG5cdFx0ZnVuY3Rpb24gaGFuZGxlQXR0cmlidXRlKG5hbWUpIHtcblx0XHRcdG5hbWUgKz0gJ0F0dHJpYnV0ZSc7XG5cdFx0XHRyZXR1cm4gZnVuY3Rpb24oZWwsIGF0dHIpIHtcblx0XHRcdFx0cmV0dXJuIGVsW25hbWVdKGF0dHIpIHx8IGVsW25hbWVdKCdkYXRhLXBhcGVyLScgKyBhdHRyKTtcblx0XHRcdH07XG5cdFx0fVxuXG5cdFx0cmV0dXJuIHtcblx0XHRcdF9zY29wZXM6IHt9LFxuXHRcdFx0X2lkOiAwLFxuXG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKGlkKSB7XG5cdFx0XHRcdHJldHVybiB0aGlzLl9zY29wZXNbaWRdIHx8IG51bGw7XG5cdFx0XHR9LFxuXG5cdFx0XHRnZXRBdHRyaWJ1dGU6IGhhbmRsZUF0dHJpYnV0ZSgnZ2V0JyksXG5cdFx0XHRoYXNBdHRyaWJ1dGU6IGhhbmRsZUF0dHJpYnV0ZSgnaGFzJylcblx0XHR9O1xuXHR9XG59KTtcblxudmFyIFBhcGVyU2NvcGVJdGVtID0gQmFzZS5leHRlbmQoRW1pdHRlciwge1xuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uKGFjdGl2YXRlKSB7XG5cdFx0dGhpcy5fc2NvcGUgPSBwYXBlcjtcblx0XHR0aGlzLl9pbmRleCA9IHRoaXMuX3Njb3BlW3RoaXMuX2xpc3RdLnB1c2godGhpcykgLSAxO1xuXHRcdGlmIChhY3RpdmF0ZSB8fCAhdGhpcy5fc2NvcGVbdGhpcy5fcmVmZXJlbmNlXSlcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0fSxcblxuXHRhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9zY29wZSlcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgcHJldiA9IHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV07XG5cdFx0aWYgKHByZXYgJiYgcHJldiAhPT0gdGhpcylcblx0XHRcdHByZXYuZW1pdCgnZGVhY3RpdmF0ZScpO1xuXHRcdHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPSB0aGlzO1xuXHRcdHRoaXMuZW1pdCgnYWN0aXZhdGUnLCBwcmV2KTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRpc0FjdGl2ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3BlW3RoaXMuX3JlZmVyZW5jZV0gPT09IHRoaXM7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5faW5kZXggPT0gbnVsbClcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRCYXNlLnNwbGljZSh0aGlzLl9zY29wZVt0aGlzLl9saXN0XSwgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuXHRcdGlmICh0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID09IHRoaXMpXG5cdFx0XHR0aGlzLl9zY29wZVt0aGlzLl9yZWZlcmVuY2VdID0gbnVsbDtcblx0XHR0aGlzLl9zY29wZSA9IG51bGw7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0pO1xuXG52YXIgRm9ybWF0dGVyID0gQmFzZS5leHRlbmQoe1xuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwcmVjaXNpb24pIHtcblx0XHR0aGlzLnByZWNpc2lvbiA9IHByZWNpc2lvbiB8fCA1O1xuXHRcdHRoaXMubXVsdGlwbGllciA9IE1hdGgucG93KDEwLCB0aGlzLnByZWNpc2lvbik7XG5cdH0sXG5cblx0bnVtYmVyOiBmdW5jdGlvbih2YWwpIHtcblx0XHRyZXR1cm4gTWF0aC5yb3VuZCh2YWwgKiB0aGlzLm11bHRpcGxpZXIpIC8gdGhpcy5tdWx0aXBsaWVyO1xuXHR9LFxuXG5cdHBhaXI6IGZ1bmN0aW9uKHZhbDEsIHZhbDIsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwxKSArIChzZXBhcmF0b3IgfHwgJywnKSArIHRoaXMubnVtYmVyKHZhbDIpO1xuXHR9LFxuXG5cdHBvaW50OiBmdW5jdGlvbih2YWwsIHNlcGFyYXRvcikge1xuXHRcdHJldHVybiB0aGlzLm51bWJlcih2YWwueCkgKyAoc2VwYXJhdG9yIHx8ICcsJykgKyB0aGlzLm51bWJlcih2YWwueSk7XG5cdH0sXG5cblx0c2l6ZTogZnVuY3Rpb24odmFsLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5udW1iZXIodmFsLndpZHRoKSArIChzZXBhcmF0b3IgfHwgJywnKVxuXHRcdFx0XHQrIHRoaXMubnVtYmVyKHZhbC5oZWlnaHQpO1xuXHR9LFxuXG5cdHJlY3RhbmdsZTogZnVuY3Rpb24odmFsLCBzZXBhcmF0b3IpIHtcblx0XHRyZXR1cm4gdGhpcy5wb2ludCh2YWwsIHNlcGFyYXRvcikgKyAoc2VwYXJhdG9yIHx8ICcsJylcblx0XHRcdFx0KyB0aGlzLnNpemUodmFsLCBzZXBhcmF0b3IpO1xuXHR9XG59KTtcblxuRm9ybWF0dGVyLmluc3RhbmNlID0gbmV3IEZvcm1hdHRlcigpO1xuXG52YXIgTnVtZXJpY2FsID0gbmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBhYnNjaXNzYXMgPSBbXG5cdFx0WyAgMC41NzczNTAyNjkxODk2MjU3NjQ1MDkxNDg4XSxcblx0XHRbMCwwLjc3NDU5NjY2OTI0MTQ4MzM3NzAzNTg1MzFdLFxuXHRcdFsgIDAuMzM5OTgxMDQzNTg0ODU2MjY0ODAyNjY1OCwwLjg2MTEzNjMxMTU5NDA1MjU3NTIyMzk0NjVdLFxuXHRcdFswLDAuNTM4NDY5MzEwMTA1NjgzMDkxMDM2MzE0NCwwLjkwNjE3OTg0NTkzODY2Mzk5Mjc5NzYyNjldLFxuXHRcdFsgIDAuMjM4NjE5MTg2MDgzMTk2OTA4NjMwNTAxNywwLjY2MTIwOTM4NjQ2NjI2NDUxMzY2MTM5OTYsMC45MzI0Njk1MTQyMDMxNTIwMjc4MTIzMDE2XSxcblx0XHRbMCwwLjQwNTg0NTE1MTM3NzM5NzE2NjkwNjYwNjQsMC43NDE1MzExODU1OTkzOTQ0Mzk4NjM4NjQ4LDAuOTQ5MTA3OTEyMzQyNzU4NTI0NTI2MTg5N10sXG5cdFx0WyAgMC4xODM0MzQ2NDI0OTU2NDk4MDQ5Mzk0NzYxLDAuNTI1NTMyNDA5OTE2MzI4OTg1ODE3NzM5MCwwLjc5NjY2NjQ3NzQxMzYyNjczOTU5MTU1MzksMC45NjAyODk4NTY0OTc1MzYyMzE2ODM1NjA5XSxcblx0XHRbMCwwLjMyNDI1MzQyMzQwMzgwODkyOTAzODUzODAsMC42MTMzNzE0MzI3MDA1OTAzOTczMDg3MDIwLDAuODM2MDMxMTA3MzI2NjM1Nzk0Mjk5NDI5OCwwLjk2ODE2MDIzOTUwNzYyNjA4OTgzNTU3NjJdLFxuXHRcdFsgIDAuMTQ4ODc0MzM4OTgxNjMxMjEwODg0ODI2MCwwLjQzMzM5NTM5NDEyOTI0NzE5MDc5OTI2NTksMC42Nzk0MDk1NjgyOTkwMjQ0MDYyMzQzMjc0LDAuODY1MDYzMzY2Njg4OTg0NTEwNzMyMDk2NywwLjk3MzkwNjUyODUxNzE3MTcyMDA3Nzk2NDBdLFxuXHRcdFswLDAuMjY5NTQzMTU1OTUyMzQ0OTcyMzMxNTMyMCwwLjUxOTA5NjEyOTIwNjgxMTgxNTkyNTcyNTcsMC43MzAxNTIwMDU1NzQwNDkzMjQwOTM0MTYzLDAuODg3MDYyNTk5NzY4MDk1Mjk5MDc1MTU3OCwwLjk3ODIyODY1ODE0NjA1Njk5MjgwMzkzODBdLFxuXHRcdFsgIDAuMTI1MjMzNDA4NTExNDY4OTE1NDcyNDQxNCwwLjM2NzgzMTQ5ODk5ODE4MDE5Mzc1MjY5MTUsMC41ODczMTc5NTQyODY2MTc0NDcyOTY3MDI0LDAuNzY5OTAyNjc0MTk0MzA0Njg3MDM2ODkzOCwwLjkwNDExNzI1NjM3MDQ3NDg1NjY3ODQ2NTksMC45ODE1NjA2MzQyNDY3MTkyNTA2OTA1NDkxXSxcblx0XHRbMCwwLjIzMDQ1ODMxNTk1NTEzNDc5NDA2NTUyODEsMC40NDg0OTI3NTEwMzY0NDY4NTI4Nzc5MTI5LDAuNjQyMzQ5MzM5NDQwMzQwMjIwNjQzOTg0NiwwLjgwMTU3ODA5MDczMzMwOTkxMjc5NDIwNjUsMC45MTc1OTgzOTkyMjI5Nzc5NjUyMDY1NDc4LDAuOTg0MTgzMDU0NzE4NTg4MTQ5NDcyODI5NF0sXG5cdFx0WyAgMC4xMDgwNTQ5NDg3MDczNDM2NjIwNjYyNDQ3LDAuMzE5MTEyMzY4OTI3ODg5NzYwNDM1NjcxOCwwLjUxNTI0ODYzNjM1ODE1NDA5MTk2NTI5MDcsMC42ODcyOTI5MDQ4MTE2ODU0NzAxNDgwMTk4LDAuODI3MjAxMzE1MDY5NzY0OTkzMTg5Nzk0NywwLjkyODQzNDg4MzY2MzU3MzUxNzMzNjM5MTEsMC45ODYyODM4MDg2OTY4MTIzMzg4NDE1OTczXSxcblx0XHRbMCwwLjIwMTE5NDA5Mzk5NzQzNDUyMjMwMDYyODMsMC4zOTQxNTEzNDcwNzc1NjMzNjk4OTcyMDc0LDAuNTcwOTcyMTcyNjA4NTM4ODQ3NTM3MjI2NywwLjcyNDQxNzczMTM2MDE3MDA0NzQxNjE4NjEsMC44NDgyMDY1ODM0MTA0MjcyMTYyMDA2NDgzLDAuOTM3MjczMzkyNDAwNzA1OTA0MzA3NzU4OSwwLjk4Nzk5MjUxODAyMDQ4NTQyODQ4OTU2NTddLFxuXHRcdFsgIDAuMDk1MDEyNTA5ODM3NjM3NDQwMTg1MzE5MywwLjI4MTYwMzU1MDc3OTI1ODkxMzIzMDQ2MDUsMC40NTgwMTY3Nzc2NTcyMjczODYzNDI0MTk0LDAuNjE3ODc2MjQ0NDAyNjQzNzQ4NDQ2NjcxOCwwLjc1NTQwNDQwODM1NTAwMzAzMzg5NTEwMTIsMC44NjU2MzEyMDIzODc4MzE3NDM4ODA0Njc5LDAuOTQ0NTc1MDIzMDczMjMyNTc2MDc3OTg4NCwwLjk4OTQwMDkzNDk5MTY0OTkzMjU5NjE1NDJdXG5cdF07XG5cblx0dmFyIHdlaWdodHMgPSBbXG5cdFx0WzFdLFxuXHRcdFswLjg4ODg4ODg4ODg4ODg4ODg4ODg4ODg4ODksMC41NTU1NTU1NTU1NTU1NTU1NTU1NTU1NTU2XSxcblx0XHRbMC42NTIxNDUxNTQ4NjI1NDYxNDI2MjY5MzYxLDAuMzQ3ODU0ODQ1MTM3NDUzODU3MzczMDYzOV0sXG5cdFx0WzAuNTY4ODg4ODg4ODg4ODg4ODg4ODg4ODg4OSwwLjQ3ODYyODY3MDQ5OTM2NjQ2ODA0MTI5MTUsMC4yMzY5MjY4ODUwNTYxODkwODc1MTQyNjQwXSxcblx0XHRbMC40Njc5MTM5MzQ1NzI2OTEwNDczODk4NzAzLDAuMzYwNzYxNTczMDQ4MTM4NjA3NTY5ODMzNSwwLjE3MTMyNDQ5MjM3OTE3MDM0NTA0MDI5NjFdLFxuXHRcdFswLjQxNzk1OTE4MzY3MzQ2OTM4Nzc1NTEwMjAsMC4zODE4MzAwNTA1MDUxMTg5NDQ5NTAzNjk4LDAuMjc5NzA1MzkxNDg5Mjc2NjY3OTAxNDY3OCwwLjEyOTQ4NDk2NjE2ODg2OTY5MzI3MDYxMTRdLFxuXHRcdFswLjM2MjY4Mzc4MzM3ODM2MTk4Mjk2NTE1MDQsMC4zMTM3MDY2NDU4Nzc4ODcyODczMzc5NjIyLDAuMjIyMzgxMDM0NDUzMzc0NDcwNTQ0MzU2MCwwLjEwMTIyODUzNjI5MDM3NjI1OTE1MjUzMTRdLFxuXHRcdFswLjMzMDIzOTM1NTAwMTI1OTc2MzE2NDUyNTEsMC4zMTIzNDcwNzcwNDAwMDI4NDAwNjg2MzA0LDAuMjYwNjEwNjk2NDAyOTM1NDYyMzE4NzQyOSwwLjE4MDY0ODE2MDY5NDg1NzQwNDA1ODQ3MjAsMC4wODEyNzQzODgzNjE1NzQ0MTE5NzE4OTIyXSxcblx0XHRbMC4yOTU1MjQyMjQ3MTQ3NTI4NzAxNzM4OTMwLDAuMjY5MjY2NzE5MzA5OTk2MzU1MDkxMjI2OSwwLjIxOTA4NjM2MjUxNTk4MjA0Mzk5NTUzNDksMC4xNDk0NTEzNDkxNTA1ODA1OTMxNDU3NzYzLDAuMDY2NjcxMzQ0MzA4Njg4MTM3NTkzNTY4OF0sXG5cdFx0WzAuMjcyOTI1MDg2Nzc3OTAwNjMwNzE0NDgzNSwwLjI2MjgwNDU0NDUxMDI0NjY2MjE4MDY4ODksMC4yMzMxOTM3NjQ1OTE5OTA0Nzk5MTg1MjM3LDAuMTg2MjkwMjEwOTI3NzM0MjUxNDI2MDk3NiwwLjEyNTU4MDM2OTQ2NDkwNDYyNDYzNDY5NDMsMC4wNTU2Njg1NjcxMTYxNzM2NjY0ODI3NTM3XSxcblx0XHRbMC4yNDkxNDcwNDU4MTM0MDI3ODUwMDA1NjI0LDAuMjMzNDkyNTM2NTM4MzU0ODA4NzYwODQ5OSwwLjIwMzE2NzQyNjcyMzA2NTkyMTc0OTA2NDUsMC4xNjAwNzgzMjg1NDMzNDYyMjYzMzQ2NTI1LDAuMTA2OTM5MzI1OTk1MzE4NDMwOTYwMjU0NywwLjA0NzE3NTMzNjM4NjUxMTgyNzE5NDYxNjBdLFxuXHRcdFswLjIzMjU1MTU1MzIzMDg3MzkxMDE5NDU4OTUsMC4yMjYyODMxODAyNjI4OTcyMzg0MTIwOTAyLDAuMjA3ODE2MDQ3NTM2ODg4NTAyMzEyNTIzMiwwLjE3ODE0NTk4MDc2MTk0NTczODI4MDA0NjcsMC4xMzg4NzM1MTAyMTk3ODcyMzg0NjM2MDE4LDAuMDkyMTIxNDk5ODM3NzI4NDQ3OTE0NDIxOCwwLjA0MDQ4NDAwNDc2NTMxNTg3OTUyMDAyMTZdLFxuXHRcdFswLjIxNTI2Mzg1MzQ2MzE1Nzc5MDE5NTg3NjQsMC4yMDUxOTg0NjM3MjEyOTU2MDM5NjU5MjQxLDAuMTg1NTM4Mzk3NDc3OTM3ODEzNzQxNzE2NiwwLjE1NzIwMzE2NzE1ODE5MzUzNDU2OTYwMTksMC4xMjE1MTg1NzA2ODc5MDMxODQ2ODk0MTQ4LDAuMDgwMTU4MDg3MTU5NzYwMjA5ODA1NjMzMywwLjAzNTExOTQ2MDMzMTc1MTg2MzAzMTgzMjldLFxuXHRcdFswLjIwMjU3ODI0MTkyNTU2MTI3Mjg4MDYyMDIsMC4xOTg0MzE0ODUzMjcxMTE1NzY0NTYxMTgzLDAuMTg2MTYxMDAwMDE1NTYyMjExMDI2ODAwNiwwLjE2NjI2OTIwNTgxNjk5MzkzMzU1MzIwMDksMC4xMzk1NzA2Nzc5MjYxNTQzMTQ0NDc4MDQ4LDAuMTA3MTU5MjIwNDY3MTcxOTM1MDExODY5NSwwLjA3MDM2NjA0NzQ4ODEwODEyNDcwOTI2NzQsMC4wMzA3NTMyNDE5OTYxMTcyNjgzNTQ2Mjg0XSxcblx0XHRbMC4xODk0NTA2MTA0NTUwNjg0OTYyODUzOTY3LDAuMTgyNjAzNDE1MDQ0OTIzNTg4ODY2NzYzNywwLjE2OTE1NjUxOTM5NTAwMjUzODE4OTMxMjEsMC4xNDk1OTU5ODg4MTY1NzY3MzIwODE1MDE3LDAuMTI0NjI4OTcxMjU1NTMzODcyMDUyNDc2MywwLjA5NTE1ODUxMTY4MjQ5Mjc4NDgwOTkyNTEsMC4wNjIyNTM1MjM5Mzg2NDc4OTI4NjI4NDM4LDAuMDI3MTUyNDU5NDExNzU0MDk0ODUxNzgwNl1cblx0XTtcblxuXHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0c3FydCA9IE1hdGguc3FydCxcblx0XHRwb3cgPSBNYXRoLnBvdyxcblx0XHRFUFNJTE9OID0gMWUtMTIsXG5cdFx0TUFDSElORV9FUFNJTE9OID0gMS4xMmUtMTY7XG5cblx0ZnVuY3Rpb24gY2xpcCh2YWx1ZSwgbWluLCBtYXgpIHtcblx0XHRyZXR1cm4gdmFsdWUgPCBtaW4gPyBtaW4gOiB2YWx1ZSA+IG1heCA/IG1heCA6IHZhbHVlO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRUT0xFUkFOQ0U6IDFlLTYsXG5cdFx0RVBTSUxPTjogRVBTSUxPTixcblx0XHRNQUNISU5FX0VQU0lMT046IE1BQ0hJTkVfRVBTSUxPTixcblx0XHRDVVJWRVRJTUVfRVBTSUxPTjogNGUtNyxcblx0XHRHRU9NRVRSSUNfRVBTSUxPTjogMmUtNyxcblx0XHRXSU5ESU5HX0VQU0lMT046IDJlLTcsXG5cdFx0VFJJR09OT01FVFJJQ19FUFNJTE9OOiAxZS03LFxuXHRcdENMSVBQSU5HX0VQU0lMT046IDFlLTcsXG5cdFx0S0FQUEE6IDQgKiAoc3FydCgyKSAtIDEpIC8gMyxcblxuXHRcdGlzWmVybzogZnVuY3Rpb24odmFsKSB7XG5cdFx0XHRyZXR1cm4gdmFsID49IC1FUFNJTE9OICYmIHZhbCA8PSBFUFNJTE9OO1xuXHRcdH0sXG5cblx0XHRpbnRlZ3JhdGU6IGZ1bmN0aW9uKGYsIGEsIGIsIG4pIHtcblx0XHRcdHZhciB4ID0gYWJzY2lzc2FzW24gLSAyXSxcblx0XHRcdFx0dyA9IHdlaWdodHNbbiAtIDJdLFxuXHRcdFx0XHRBID0gKGIgLSBhKSAqIDAuNSxcblx0XHRcdFx0QiA9IEEgKyBhLFxuXHRcdFx0XHRpID0gMCxcblx0XHRcdFx0bSA9IChuICsgMSkgPj4gMSxcblx0XHRcdFx0c3VtID0gbiAmIDEgPyB3W2krK10gKiBmKEIpIDogMDtcblx0XHRcdHdoaWxlIChpIDwgbSkge1xuXHRcdFx0XHR2YXIgQXggPSBBICogeFtpXTtcblx0XHRcdFx0c3VtICs9IHdbaSsrXSAqIChmKEIgKyBBeCkgKyBmKEIgLSBBeCkpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIEEgKiBzdW07XG5cdFx0fSxcblxuXHRcdGZpbmRSb290OiBmdW5jdGlvbihmLCBkZiwgeCwgYSwgYiwgbiwgdG9sZXJhbmNlKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG47IGkrKykge1xuXHRcdFx0XHR2YXIgZnggPSBmKHgpLFxuXHRcdFx0XHRcdGR4ID0gZnggLyBkZih4KSxcblx0XHRcdFx0XHRueCA9IHggLSBkeDtcblx0XHRcdFx0aWYgKGFicyhkeCkgPCB0b2xlcmFuY2UpXG5cdFx0XHRcdFx0cmV0dXJuIG54O1xuXHRcdFx0XHRpZiAoZnggPiAwKSB7XG5cdFx0XHRcdFx0YiA9IHg7XG5cdFx0XHRcdFx0eCA9IG54IDw9IGEgPyAoYSArIGIpICogMC41IDogbng7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0YSA9IHg7XG5cdFx0XHRcdFx0eCA9IG54ID49IGIgPyAoYSArIGIpICogMC41IDogbng7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB4O1xuXHRcdH0sXG5cblx0XHRzb2x2ZVF1YWRyYXRpYzogZnVuY3Rpb24oYSwgYiwgYywgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0XHR2YXIgY291bnQgPSAwLFxuXHRcdFx0XHRlTWluID0gbWluIC0gRVBTSUxPTixcblx0XHRcdFx0ZU1heCA9IG1heCArIEVQU0lMT04sXG5cdFx0XHRcdHgxLCB4MiA9IEluZmluaXR5LFxuXHRcdFx0XHRCID0gYixcblx0XHRcdFx0RDtcblx0XHRcdGIgLz0gLTI7XG5cdFx0XHREID0gYiAqIGIgLSBhICogYztcblx0XHRcdGlmIChEICE9PSAwICYmIGFicyhEKSA8IE1BQ0hJTkVfRVBTSUxPTikge1xuXHRcdFx0XHR2YXIgZ21DID0gcG93KGFicyhhICogYiAqIGMpLCAxIC8gMyk7XG5cdFx0XHRcdGlmIChnbUMgPCAxZS04KSB7XG5cdFx0XHRcdFx0dmFyIG11bHQgPSBwb3coMTAsXG5cdFx0XHRcdFx0XHRcdGFicyhNYXRoLmZsb29yKE1hdGgubG9nKGdtQykgKiBNYXRoLkxPRzEwRSkpKTtcblx0XHRcdFx0XHRpZiAoIWlzRmluaXRlKG11bHQpKVxuXHRcdFx0XHRcdFx0bXVsdCA9IDA7XG5cdFx0XHRcdFx0YSAqPSBtdWx0O1xuXHRcdFx0XHRcdGIgKj0gbXVsdDtcblx0XHRcdFx0XHRjICo9IG11bHQ7XG5cdFx0XHRcdFx0RCA9IGIgKiBiIC0gYSAqIGM7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChhYnMoYSkgPCBFUFNJTE9OKSB7XG5cdFx0XHRcdGlmIChhYnMoQikgPCBFUFNJTE9OKVxuXHRcdFx0XHRcdHJldHVybiBhYnMoYykgPCBFUFNJTE9OID8gLTEgOiAwO1xuXHRcdFx0XHR4MSA9IC1jIC8gQjtcblx0XHRcdH0gZWxzZSBpZiAoRCA+PSAtTUFDSElORV9FUFNJTE9OKSB7XG5cdFx0XHRcdHZhciBRID0gRCA8IDAgPyAwIDogc3FydChEKSxcblx0XHRcdFx0XHRSID0gYiArIChiIDwgMCA/IC1RIDogUSk7XG5cdFx0XHRcdGlmIChSID09PSAwKSB7XG5cdFx0XHRcdFx0eDEgPSBjIC8gYTtcblx0XHRcdFx0XHR4MiA9IC14MTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR4MSA9IFIgLyBhO1xuXHRcdFx0XHRcdHgyID0gYyAvIFI7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChpc0Zpbml0ZSh4MSkgJiYgKG1pbiA9PSBudWxsIHx8IHgxID4gZU1pbiAmJiB4MSA8IGVNYXgpKVxuXHRcdFx0XHRyb290c1tjb3VudCsrXSA9IG1pbiA9PSBudWxsID8geDEgOiBjbGlwKHgxLCBtaW4sIG1heCk7XG5cdFx0XHRpZiAoeDIgIT09IHgxXG5cdFx0XHRcdFx0JiYgaXNGaW5pdGUoeDIpICYmIChtaW4gPT0gbnVsbCB8fCB4MiA+IGVNaW4gJiYgeDIgPCBlTWF4KSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSBtaW4gPT0gbnVsbCA/IHgyIDogY2xpcCh4MiwgbWluLCBtYXgpO1xuXHRcdFx0cmV0dXJuIGNvdW50O1xuXHRcdH0sXG5cblx0XHRzb2x2ZUN1YmljOiBmdW5jdGlvbihhLCBiLCBjLCBkLCByb290cywgbWluLCBtYXgpIHtcblx0XHRcdHZhciBjb3VudCA9IDAsXG5cdFx0XHRcdHgsIGIxLCBjMjtcblx0XHRcdGlmIChhYnMoYSkgPCBFUFNJTE9OKSB7XG5cdFx0XHRcdGEgPSBiO1xuXHRcdFx0XHRiMSA9IGM7XG5cdFx0XHRcdGMyID0gZDtcblx0XHRcdFx0eCA9IEluZmluaXR5O1xuXHRcdFx0fSBlbHNlIGlmIChhYnMoZCkgPCBFUFNJTE9OKSB7XG5cdFx0XHRcdGIxID0gYjtcblx0XHRcdFx0YzIgPSBjO1xuXHRcdFx0XHR4ID0gMDtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBlYyA9IDEgKyBNQUNISU5FX0VQU0lMT04sXG5cdFx0XHRcdFx0eDAsIHEsIHFkLCB0LCByLCBzLCB0bXA7XG5cdFx0XHRcdHggPSAtKGIgLyBhKSAvIDM7XG5cdFx0XHRcdHRtcCA9IGEgKiB4LFxuXHRcdFx0XHRiMSA9IHRtcCArIGIsXG5cdFx0XHRcdGMyID0gYjEgKiB4ICsgYyxcblx0XHRcdFx0cWQgPSAodG1wICsgYjEpICogeCArIGMyLFxuXHRcdFx0XHRxID0gYzIgKiB4ICsgZDtcblx0XHRcdFx0dCA9IHEgL2E7XG5cdFx0XHRcdHIgPSBwb3coYWJzKHQpLCAxLzMpO1xuXHRcdFx0XHRzID0gdCA8IDAgPyAtMSA6IDE7XG5cdFx0XHRcdHQgPSAtcWQgLyBhO1xuXHRcdFx0XHRyID0gdCA+IDAgPyAxLjMyNDcxNzk1NzIgKiBNYXRoLm1heChyLCBzcXJ0KHQpKSA6IHI7XG5cdFx0XHRcdHgwID0geCAtIHMgKiByO1xuXHRcdFx0XHRpZiAoeDAgIT09IHgpIHtcblx0XHRcdFx0XHRkbyB7XG5cdFx0XHRcdFx0XHR4ID0geDA7XG5cdFx0XHRcdFx0XHR0bXAgPSBhICogeCxcblx0XHRcdFx0XHRcdGIxID0gdG1wICsgYixcblx0XHRcdFx0XHRcdGMyID0gYjEgKiB4ICsgYyxcblx0XHRcdFx0XHRcdHFkID0gKHRtcCArIGIxKSAqIHggKyBjMixcblx0XHRcdFx0XHRcdHEgPSBjMiAqIHggKyBkO1xuXHRcdFx0XHRcdFx0eDAgPSBxZCA9PT0gMCA/IHggOiB4IC0gcSAvIHFkIC8gZWM7XG5cdFx0XHRcdFx0XHRpZiAoeDAgPT09IHgpIHtcblx0XHRcdFx0XHRcdFx0eCA9IHgwO1xuXHRcdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9IHdoaWxlIChzICogeDAgPiBzICogeCk7XG5cdFx0XHRcdFx0aWYgKGFicyhhKSAqIHggKiB4ID4gYWJzKGQgLyB4KSkge1xuXHRcdFx0XHRcdFx0YzIgPSAtZCAvIHg7XG5cdFx0XHRcdFx0XHRiMSA9IChjMiAtIGMpIC8geDtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHZhciBjb3VudCA9IE51bWVyaWNhbC5zb2x2ZVF1YWRyYXRpYyhhLCBiMSwgYzIsIHJvb3RzLCBtaW4sIG1heCk7XG5cdFx0XHRpZiAoaXNGaW5pdGUoeCkgJiYgKGNvdW50ID09PSAwIHx8IHggIT09IHJvb3RzW2NvdW50IC0gMV0pXG5cdFx0XHRcdFx0JiYgKG1pbiA9PSBudWxsIHx8IHggPiBtaW4gLSBFUFNJTE9OICYmIHggPCBtYXggKyBFUFNJTE9OKSlcblx0XHRcdFx0cm9vdHNbY291bnQrK10gPSBtaW4gPT0gbnVsbCA/IHggOiBjbGlwKHgsIG1pbiwgbWF4KTtcblx0XHRcdHJldHVybiBjb3VudDtcblx0XHR9XG5cdH07XG59O1xuXG52YXIgVUlEID0ge1xuXHRfaWQ6IDEsXG5cdF9wb29sczoge30sXG5cblx0Z2V0OiBmdW5jdGlvbihjdG9yKSB7XG5cdFx0aWYgKGN0b3IpIHtcblx0XHRcdHZhciBuYW1lID0gY3Rvci5fY2xhc3MsXG5cdFx0XHRcdHBvb2wgPSB0aGlzLl9wb29sc1tuYW1lXTtcblx0XHRcdGlmICghcG9vbClcblx0XHRcdFx0cG9vbCA9IHRoaXMuX3Bvb2xzW25hbWVdID0geyBfaWQ6IDEgfTtcblx0XHRcdHJldHVybiBwb29sLl9pZCsrO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5faWQrKztcblx0XHR9XG5cdH1cbn07XG5cbnZhciBQb2ludCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUG9pbnQnLFxuXHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50KGFyZzAsIGFyZzEpIHtcblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBhcmcwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dmFyIGhhc1kgPSB0eXBlb2YgYXJnMSA9PT0gJ251bWJlcic7XG5cdFx0XHR0aGlzLnggPSBhcmcwO1xuXHRcdFx0dGhpcy55ID0gaGFzWSA/IGFyZzEgOiBhcmcwO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IGhhc1kgPyAyIDogMTtcblx0XHR9IGVsc2UgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnIHx8IGFyZzAgPT09IG51bGwpIHtcblx0XHRcdHRoaXMueCA9IHRoaXMueSA9IDA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gYXJnMCA9PT0gbnVsbCA/IDEgOiAwO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwWzBdO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLmxlbmd0aCA+IDEgPyBhcmcwWzFdIDogYXJnMFswXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC54ICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy54ID0gYXJnMC54O1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLnk7XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAud2lkdGggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwLndpZHRoO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLmhlaWdodDtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC5hbmdsZSAhPSBudWxsKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzAubGVuZ3RoO1xuXHRcdFx0XHR0aGlzLnkgPSAwO1xuXHRcdFx0XHR0aGlzLnNldEFuZ2xlKGFyZzAuYW5nbGUpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy54ID0gdGhpcy55ID0gMDtcblx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdHRoaXMuX19yZWFkID0gMDtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSAxO1xuXHRcdH1cblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHkpIHtcblx0XHR0aGlzLnggPSB4O1xuXHRcdHRoaXMueSA9IHk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHJldHVybiB0aGlzID09PSBwb2ludCB8fCBwb2ludFxuXHRcdFx0XHQmJiAodGhpcy54ID09PSBwb2ludC54ICYmIHRoaXMueSA9PT0gcG9pbnQueVxuXHRcdFx0XHRcdHx8IEFycmF5LmlzQXJyYXkocG9pbnQpXG5cdFx0XHRcdFx0XHQmJiB0aGlzLnggPT09IHBvaW50WzBdICYmIHRoaXMueSA9PT0gcG9pbnRbMV0pXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCwgdGhpcy55KTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHg6ICcgKyBmLm51bWJlcih0aGlzLngpICsgJywgeTogJyArIGYubnVtYmVyKHRoaXMueSkgKyAnIH0nO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyO1xuXHRcdHJldHVybiBbZi5udW1iZXIodGhpcy54KSwgZi5udW1iZXIodGhpcy55KV07XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gTWF0aC5zcXJ0KHRoaXMueCAqIHRoaXMueCArIHRoaXMueSAqIHRoaXMueSk7XG5cdH0sXG5cblx0c2V0TGVuZ3RoOiBmdW5jdGlvbihsZW5ndGgpIHtcblx0XHRpZiAodGhpcy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGFuZ2xlID0gdGhpcy5fYW5nbGUgfHwgMDtcblx0XHRcdHRoaXMuc2V0KFxuXHRcdFx0XHRNYXRoLmNvcyhhbmdsZSkgKiBsZW5ndGgsXG5cdFx0XHRcdE1hdGguc2luKGFuZ2xlKSAqIGxlbmd0aFxuXHRcdFx0KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHNjYWxlID0gbGVuZ3RoIC8gdGhpcy5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKHNjYWxlKSlcblx0XHRcdFx0dGhpcy5nZXRBbmdsZSgpO1xuXHRcdFx0dGhpcy5zZXQoXG5cdFx0XHRcdHRoaXMueCAqIHNjYWxlLFxuXHRcdFx0XHR0aGlzLnkgKiBzY2FsZVxuXHRcdFx0KTtcblx0XHR9XG5cdH0sXG5cdGdldEFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRBbmdsZUluUmFkaWFucy5hcHBseSh0aGlzLCBhcmd1bWVudHMpICogMTgwIC8gTWF0aC5QSTtcblx0fSxcblxuXHRzZXRBbmdsZTogZnVuY3Rpb24oYW5nbGUpIHtcblx0XHR0aGlzLnNldEFuZ2xlSW5SYWRpYW5zLmNhbGwodGhpcywgYW5nbGUgKiBNYXRoLlBJIC8gMTgwKTtcblx0fSxcblxuXHRnZXRBbmdsZUluRGVncmVlczogJyNnZXRBbmdsZScsXG5cdHNldEFuZ2xlSW5EZWdyZWVzOiAnI3NldEFuZ2xlJyxcblxuXHRnZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCFhcmd1bWVudHMubGVuZ3RoKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5pc1plcm8oKVxuXHRcdFx0XHRcdD8gdGhpcy5fYW5nbGUgfHwgMFxuXHRcdFx0XHRcdDogdGhpcy5fYW5nbGUgPSBNYXRoLmF0YW4yKHRoaXMueSwgdGhpcy54KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRkaXYgPSB0aGlzLmdldExlbmd0aCgpICogcG9pbnQuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhkaXYpKSB7XG5cdFx0XHRcdHJldHVybiBOYU47XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYSA9IHRoaXMuZG90KHBvaW50KSAvIGRpdjtcblx0XHRcdFx0cmV0dXJuIE1hdGguYWNvcyhhIDwgLTEgPyAtMSA6IGEgPiAxID8gMSA6IGEpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRzZXRBbmdsZUluUmFkaWFuczogZnVuY3Rpb24oYW5nbGUpIHtcblx0XHR0aGlzLl9hbmdsZSA9IGFuZ2xlO1xuXHRcdGlmICghdGhpcy5pc1plcm8oKSkge1xuXHRcdFx0dmFyIGxlbmd0aCA9IHRoaXMuZ2V0TGVuZ3RoKCk7XG5cdFx0XHR0aGlzLnNldChcblx0XHRcdFx0TWF0aC5jb3MoYW5nbGUpICogbGVuZ3RoLFxuXHRcdFx0XHRNYXRoLnNpbihhbmdsZSkgKiBsZW5ndGhcblx0XHRcdCk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldFF1YWRyYW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54ID49IDAgPyB0aGlzLnkgPj0gMCA/IDEgOiA0IDogdGhpcy55ID49IDAgPyAyIDogMztcblx0fVxufSwge1xuXHRiZWFuczogZmFsc2UsXG5cblx0Z2V0RGlyZWN0ZWRBbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBNYXRoLmF0YW4yKHRoaXMuY3Jvc3MocG9pbnQpLCB0aGlzLmRvdChwb2ludCkpICogMTgwIC8gTWF0aC5QSTtcblx0fSxcblxuXHRnZXREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eCA9IHBvaW50LnggLSB0aGlzLngsXG5cdFx0XHR5ID0gcG9pbnQueSAtIHRoaXMueSxcblx0XHRcdGQgPSB4ICogeCArIHkgKiB5LFxuXHRcdFx0c3F1YXJlZCA9IEJhc2UucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBzcXVhcmVkID8gZCA6IE1hdGguc3FydChkKTtcblx0fSxcblxuXHRub3JtYWxpemU6IGZ1bmN0aW9uKGxlbmd0aCkge1xuXHRcdGlmIChsZW5ndGggPT09IHVuZGVmaW5lZClcblx0XHRcdGxlbmd0aCA9IDE7XG5cdFx0dmFyIGN1cnJlbnQgPSB0aGlzLmdldExlbmd0aCgpLFxuXHRcdFx0c2NhbGUgPSBjdXJyZW50ICE9PSAwID8gbGVuZ3RoIC8gY3VycmVudCA6IDAsXG5cdFx0XHRwb2ludCA9IG5ldyBQb2ludCh0aGlzLnggKiBzY2FsZSwgdGhpcy55ICogc2NhbGUpO1xuXHRcdGlmIChzY2FsZSA+PSAwKVxuXHRcdFx0cG9pbnQuX2FuZ2xlID0gdGhpcy5fYW5nbGU7XG5cdFx0cmV0dXJuIHBvaW50O1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUsIGNlbnRlcikge1xuXHRcdGlmIChhbmdsZSA9PT0gMClcblx0XHRcdHJldHVybiB0aGlzLmNsb25lKCk7XG5cdFx0YW5nbGUgPSBhbmdsZSAqIE1hdGguUEkgLyAxODA7XG5cdFx0dmFyIHBvaW50ID0gY2VudGVyID8gdGhpcy5zdWJ0cmFjdChjZW50ZXIpIDogdGhpcyxcblx0XHRcdHNpbiA9IE1hdGguc2luKGFuZ2xlKSxcblx0XHRcdGNvcyA9IE1hdGguY29zKGFuZ2xlKTtcblx0XHRwb2ludCA9IG5ldyBQb2ludChcblx0XHRcdHBvaW50LnggKiBjb3MgLSBwb2ludC55ICogc2luLFxuXHRcdFx0cG9pbnQueCAqIHNpbiArIHBvaW50LnkgKiBjb3Ncblx0XHQpO1xuXHRcdHJldHVybiBjZW50ZXIgPyBwb2ludC5hZGQoY2VudGVyKSA6IHBvaW50O1xuXHR9LFxuXG5cdHRyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodGhpcykgOiB0aGlzO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICsgcG9pbnQueCwgdGhpcy55ICsgcG9pbnQueSk7XG5cdH0sXG5cblx0c3VidHJhY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAtIHBvaW50LngsIHRoaXMueSAtIHBvaW50LnkpO1xuXHR9LFxuXG5cdG11bHRpcGx5OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLnggKiBwb2ludC54LCB0aGlzLnkgKiBwb2ludC55KTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KHRoaXMueCAvIHBvaW50LngsIHRoaXMueSAvIHBvaW50LnkpO1xuXHR9LFxuXG5cdG1vZHVsbzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy54ICUgcG9pbnQueCwgdGhpcy55ICUgcG9pbnQueSk7XG5cdH0sXG5cblx0bmVnYXRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBvaW50KC10aGlzLngsIC10aGlzLnkpO1xuXHR9LFxuXG5cdGlzSW5zaWRlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKS5jb250YWlucyh0aGlzKTtcblx0fSxcblxuXHRpc0Nsb3NlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHR0b2xlcmFuY2UgPSBCYXNlLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gdGhpcy5nZXREaXN0YW5jZShwb2ludCkgPCB0b2xlcmFuY2U7XG5cdH0sXG5cblx0aXNDb2xsaW5lYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gUG9pbnQuaXNDb2xsaW5lYXIodGhpcy54LCB0aGlzLnksIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGlzQ29saW5lYXI6ICcjaXNDb2xsaW5lYXInLFxuXG5cdGlzT3J0aG9nb25hbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBQb2ludC5pc09ydGhvZ29uYWwodGhpcy54LCB0aGlzLnksIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy54KSAmJiBOdW1lcmljYWwuaXNaZXJvKHRoaXMueSk7XG5cdH0sXG5cblx0aXNOYU46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBpc05hTih0aGlzLngpIHx8IGlzTmFOKHRoaXMueSk7XG5cdH0sXG5cblx0ZG90OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHBvaW50LnggKyB0aGlzLnkgKiBwb2ludC55O1xuXHR9LFxuXG5cdGNyb3NzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMueCAqIHBvaW50LnkgLSB0aGlzLnkgKiBwb2ludC54O1xuXHR9LFxuXG5cdHByb2plY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHNjYWxlID0gcG9pbnQuaXNaZXJvKCkgPyAwIDogdGhpcy5kb3QocG9pbnQpIC8gcG9pbnQuZG90KHBvaW50KTtcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0cG9pbnQueCAqIHNjYWxlLFxuXHRcdFx0cG9pbnQueSAqIHNjYWxlXG5cdFx0KTtcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0bWluOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBwb2ludDEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHBvaW50MiA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdE1hdGgubWluKHBvaW50MS54LCBwb2ludDIueCksXG5cdFx0XHRcdE1hdGgubWluKHBvaW50MS55LCBwb2ludDIueSlcblx0XHRcdCk7XG5cdFx0fSxcblxuXHRcdG1heDogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcG9pbnQxID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwb2ludDIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRNYXRoLm1heChwb2ludDEueCwgcG9pbnQyLngpLFxuXHRcdFx0XHRNYXRoLm1heChwb2ludDEueSwgcG9pbnQyLnkpXG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRyYW5kb206IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBQb2ludChNYXRoLnJhbmRvbSgpLCBNYXRoLnJhbmRvbSgpKTtcblx0XHR9LFxuXG5cdFx0aXNDb2xsaW5lYXI6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoeDEgKiB5MiAtIHkxICogeDIpXG5cdFx0XHRcdFx0PD0gTWF0aC5zcXJ0KCh4MSAqIHgxICsgeTEgKiB5MSkgKiAoeDIgKiB4MiArIHkyICogeTIpKVxuXHRcdFx0XHRcdFx0KiAxZS03O1xuXHRcdH0sXG5cblx0XHRpc09ydGhvZ29uYWw6IGZ1bmN0aW9uKHgxLCB5MSwgeDIsIHkyKSB7XG5cdFx0XHRyZXR1cm4gTWF0aC5hYnMoeDEgKiB4MiArIHkxICogeTIpXG5cdFx0XHRcdFx0PD0gTWF0aC5zcXJ0KCh4MSAqIHgxICsgeTEgKiB5MSkgKiAoeDIgKiB4MiArIHkyICogeTIpKVxuXHRcdFx0XHRcdFx0KiAxZS03O1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKFsncm91bmQnLCAnY2VpbCcsICdmbG9vcicsICdhYnMnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR2YXIgb3AgPSBNYXRoW25hbWVdO1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludChvcCh0aGlzLngpLCBvcCh0aGlzLnkpKTtcblx0fTtcbn0sIHt9KSk7XG5cbnZhciBMaW5rZWRQb2ludCA9IFBvaW50LmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBvaW50KHgsIHksIG93bmVyLCBzZXR0ZXIpIHtcblx0XHR0aGlzLl94ID0geDtcblx0XHR0aGlzLl95ID0geTtcblx0XHR0aGlzLl9vd25lciA9IG93bmVyO1xuXHRcdHRoaXMuX3NldHRlciA9IHNldHRlcjtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHgsIHksIF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0WDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3g7XG5cdH0sXG5cblx0c2V0WDogZnVuY3Rpb24oeCkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH0sXG5cblx0Z2V0WTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24oeSkge1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdH1cbn0pO1xuXG52YXIgU2l6ZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnU2l6ZScsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2l6ZShhcmcwLCBhcmcxKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgYXJnMDtcblx0XHRpZiAodHlwZSA9PT0gJ251bWJlcicpIHtcblx0XHRcdHZhciBoYXNIZWlnaHQgPSB0eXBlb2YgYXJnMSA9PT0gJ251bWJlcic7XG5cdFx0XHR0aGlzLndpZHRoID0gYXJnMDtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gaGFzSGVpZ2h0ID8gYXJnMSA6IGFyZzA7XG5cdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdHRoaXMuX19yZWFkID0gaGFzSGVpZ2h0ID8gMiA6IDE7XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAndW5kZWZpbmVkJyB8fCBhcmcwID09PSBudWxsKSB7XG5cdFx0XHR0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IGFyZzAgPT09IG51bGwgPyAxIDogMDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnMCkpIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGFyZzBbMF07XG5cdFx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMC5sZW5ndGggPiAxID8gYXJnMFsxXSA6IGFyZzBbMF07XG5cdFx0XHR9IGVsc2UgaWYgKGFyZzAud2lkdGggIT0gbnVsbCkge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMC53aWR0aDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLmhlaWdodDtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC54ICE9IG51bGwpIHtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGFyZzAueDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLnk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0aGlzLndpZHRoID0gdGhpcy5oZWlnaHQgPSAwO1xuXHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0dGhpcy5fX3JlYWQgPSAwO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHR0aGlzLl9fcmVhZCA9IDE7XG5cdFx0fVxuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHNpemUpIHtcblx0XHRyZXR1cm4gc2l6ZSA9PT0gdGhpcyB8fCBzaXplICYmICh0aGlzLndpZHRoID09PSBzaXplLndpZHRoXG5cdFx0XHRcdCYmIHRoaXMuaGVpZ2h0ID09PSBzaXplLmhlaWdodFxuXHRcdFx0XHR8fCBBcnJheS5pc0FycmF5KHNpemUpICYmIHRoaXMud2lkdGggPT09IHNpemVbMF1cblx0XHRcdFx0XHQmJiB0aGlzLmhlaWdodCA9PT0gc2l6ZVsxXSkgfHwgZmFsc2U7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoLCB0aGlzLmhlaWdodCk7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAneyB3aWR0aDogJyArIGYubnVtYmVyKHRoaXMud2lkdGgpXG5cdFx0XHRcdCsgJywgaGVpZ2h0OiAnICsgZi5udW1iZXIodGhpcy5oZWlnaHQpICsgJyB9Jztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcblx0XHRyZXR1cm4gW2YubnVtYmVyKHRoaXMud2lkdGgpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLmhlaWdodCldO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbmV3IFNpemUodGhpcy53aWR0aCArIHNpemUud2lkdGgsIHRoaXMuaGVpZ2h0ICsgc2l6ZS5oZWlnaHQpO1xuXHR9LFxuXG5cdHN1YnRyYWN0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdHJldHVybiBuZXcgU2l6ZSh0aGlzLndpZHRoIC0gc2l6ZS53aWR0aCwgdGhpcy5oZWlnaHQgLSBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggKiBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAqIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRkaXZpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggLyBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAvIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRtb2R1bG86IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKHRoaXMud2lkdGggJSBzaXplLndpZHRoLCB0aGlzLmhlaWdodCAlIHNpemUuaGVpZ2h0KTtcblx0fSxcblxuXHRuZWdhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2l6ZSgtdGhpcy53aWR0aCwgLXRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRpc1plcm86IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBOdW1lcmljYWwuaXNaZXJvKHRoaXMud2lkdGgpICYmIE51bWVyaWNhbC5pc1plcm8odGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdGlzTmFOOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gaXNOYU4odGhpcy53aWR0aCkgfHwgaXNOYU4odGhpcy5oZWlnaHQpO1xuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRtaW46IGZ1bmN0aW9uKHNpemUxLCBzaXplMikge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0XHRNYXRoLm1pbihzaXplMS53aWR0aCwgc2l6ZTIud2lkdGgpLFxuXHRcdFx0XHRNYXRoLm1pbihzaXplMS5oZWlnaHQsIHNpemUyLmhlaWdodCkpO1xuXHRcdH0sXG5cblx0XHRtYXg6IGZ1bmN0aW9uKHNpemUxLCBzaXplMikge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0XHRNYXRoLm1heChzaXplMS53aWR0aCwgc2l6ZTIud2lkdGgpLFxuXHRcdFx0XHRNYXRoLm1heChzaXplMS5oZWlnaHQsIHNpemUyLmhlaWdodCkpO1xuXHRcdH0sXG5cblx0XHRyYW5kb206IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaXplKE1hdGgucmFuZG9tKCksIE1hdGgucmFuZG9tKCkpO1xuXHRcdH1cblx0fVxufSwgQmFzZS5lYWNoKFsncm91bmQnLCAnY2VpbCcsICdmbG9vcicsICdhYnMnXSwgZnVuY3Rpb24obmFtZSkge1xuXHR2YXIgb3AgPSBNYXRoW25hbWVdO1xuXHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTaXplKG9wKHRoaXMud2lkdGgpLCBvcCh0aGlzLmhlaWdodCkpO1xuXHR9O1xufSwge30pKTtcblxudmFyIExpbmtlZFNpemUgPSBTaXplLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFNpemUod2lkdGgsIGhlaWdodCwgb3duZXIsIHNldHRlcikge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdHRoaXMuX293bmVyID0gb3duZXI7XG5cdFx0dGhpcy5fc2V0dGVyID0gc2V0dGVyO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24od2lkdGgsIGhlaWdodCwgX2RvbnROb3RpZnkpIHtcblx0XHR0aGlzLl93aWR0aCA9IHdpZHRoO1xuXHRcdHRoaXMuX2hlaWdodCA9IGhlaWdodDtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRnZXRXaWR0aDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3dpZHRoO1xuXHR9LFxuXG5cdHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fSxcblxuXHRnZXRIZWlnaHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oZWlnaHQ7XG5cdH0sXG5cblx0c2V0SGVpZ2h0OiBmdW5jdGlvbihoZWlnaHQpIHtcblx0XHR0aGlzLl9oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0fVxufSk7XG5cbnZhciBSZWN0YW5nbGUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1JlY3RhbmdsZScsXG5cdF9yZWFkSW5kZXg6IHRydWUsXG5cdGJlYW5zOiB0cnVlLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJlY3RhbmdsZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczKSB7XG5cdFx0dmFyIHR5cGUgPSB0eXBlb2YgYXJnMCxcblx0XHRcdHJlYWQgPSAwO1xuXHRcdGlmICh0eXBlID09PSAnbnVtYmVyJykge1xuXHRcdFx0dGhpcy54ID0gYXJnMDtcblx0XHRcdHRoaXMueSA9IGFyZzE7XG5cdFx0XHR0aGlzLndpZHRoID0gYXJnMjtcblx0XHRcdHRoaXMuaGVpZ2h0ID0gYXJnMztcblx0XHRcdHJlYWQgPSA0O1xuXHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ3VuZGVmaW5lZCcgfHwgYXJnMCA9PT0gbnVsbCkge1xuXHRcdFx0dGhpcy54ID0gdGhpcy55ID0gdGhpcy53aWR0aCA9IHRoaXMuaGVpZ2h0ID0gMDtcblx0XHRcdHJlYWQgPSBhcmcwID09PSBudWxsID8gMSA6IDA7XG5cdFx0fSBlbHNlIGlmIChhcmd1bWVudHMubGVuZ3RoID09PSAxKSB7XG5cdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHR0aGlzLnggPSBhcmcwWzBdO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwWzFdO1xuXHRcdFx0XHR0aGlzLndpZHRoID0gYXJnMFsyXTtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwWzNdO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC54ICE9PSB1bmRlZmluZWQgfHwgYXJnMC53aWR0aCAhPT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMueCA9IGFyZzAueCB8fCAwO1xuXHRcdFx0XHR0aGlzLnkgPSBhcmcwLnkgfHwgMDtcblx0XHRcdFx0dGhpcy53aWR0aCA9IGFyZzAud2lkdGggfHwgMDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSBhcmcwLmhlaWdodCB8fCAwO1xuXHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC5mcm9tID09PSB1bmRlZmluZWQgJiYgYXJnMC50byA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHRoaXMueCA9IHRoaXMueSA9IHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IDA7XG5cdFx0XHRcdHRoaXMuX3NldChhcmcwKTtcblx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghcmVhZCkge1xuXHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2Zyb20nKSxcblx0XHRcdFx0bmV4dCA9IEJhc2UucGVlayhhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy54ID0gcG9pbnQueDtcblx0XHRcdHRoaXMueSA9IHBvaW50Lnk7XG5cdFx0XHRpZiAobmV4dCAmJiBuZXh0LnggIT09IHVuZGVmaW5lZCB8fCBCYXNlLmhhc05hbWVkKGFyZ3VtZW50cywgJ3RvJykpIHtcblx0XHRcdFx0dmFyIHRvID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3RvJyk7XG5cdFx0XHRcdHRoaXMud2lkdGggPSB0by54IC0gcG9pbnQueDtcblx0XHRcdFx0dGhpcy5oZWlnaHQgPSB0by55IC0gcG9pbnQueTtcblx0XHRcdFx0aWYgKHRoaXMud2lkdGggPCAwKSB7XG5cdFx0XHRcdFx0dGhpcy54ID0gdG8ueDtcblx0XHRcdFx0XHR0aGlzLndpZHRoID0gLXRoaXMud2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKHRoaXMuaGVpZ2h0IDwgMCkge1xuXHRcdFx0XHRcdHRoaXMueSA9IHRvLnk7XG5cdFx0XHRcdFx0dGhpcy5oZWlnaHQgPSAtdGhpcy5oZWlnaHQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0XHRcdHRoaXMud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdFx0XHR0aGlzLmhlaWdodCA9IHNpemUuaGVpZ2h0O1xuXHRcdFx0fVxuXHRcdFx0cmVhZCA9IGFyZ3VtZW50cy5fX2luZGV4O1xuXHRcdH1cblx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHR0aGlzLl9fcmVhZCA9IHJlYWQ7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0dGhpcy54ID0geDtcblx0XHR0aGlzLnkgPSB5O1xuXHRcdHRoaXMud2lkdGggPSB3aWR0aDtcblx0XHR0aGlzLmhlaWdodCA9IGhlaWdodDtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54LCB0aGlzLnksIHRoaXMud2lkdGgsIHRoaXMuaGVpZ2h0KTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgcnQgPSBCYXNlLmlzUGxhaW5WYWx1ZShyZWN0KVxuXHRcdFx0XHQ/IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cylcblx0XHRcdFx0OiByZWN0O1xuXHRcdHJldHVybiBydCA9PT0gdGhpc1xuXHRcdFx0XHR8fCBydCAmJiB0aGlzLnggPT09IHJ0LnggJiYgdGhpcy55ID09PSBydC55XG5cdFx0XHRcdFx0JiYgdGhpcy53aWR0aCA9PT0gcnQud2lkdGggJiYgdGhpcy5oZWlnaHQgPT09IHJ0LmhlaWdodFxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0cmV0dXJuICd7IHg6ICcgKyBmLm51bWJlcih0aGlzLngpXG5cdFx0XHRcdCsgJywgeTogJyArIGYubnVtYmVyKHRoaXMueSlcblx0XHRcdFx0KyAnLCB3aWR0aDogJyArIGYubnVtYmVyKHRoaXMud2lkdGgpXG5cdFx0XHRcdCsgJywgaGVpZ2h0OiAnICsgZi5udW1iZXIodGhpcy5oZWlnaHQpXG5cdFx0XHRcdCsgJyB9Jztcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0dmFyIGYgPSBvcHRpb25zLmZvcm1hdHRlcjtcblx0XHRyZXR1cm4gW2YubnVtYmVyKHRoaXMueCksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMueSksXG5cdFx0XHRcdGYubnVtYmVyKHRoaXMud2lkdGgpLFxuXHRcdFx0XHRmLm51bWJlcih0aGlzLmhlaWdodCldO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMueCwgdGhpcy55LCB0aGlzLCAnc2V0UG9pbnQnKTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMueCA9IHBvaW50Lng7XG5cdFx0dGhpcy55ID0gcG9pbnQueTtcblx0fSxcblxuXHRnZXRTaXplOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFNpemUgOiBMaW5rZWRTaXplO1xuXHRcdHJldHVybiBuZXcgY3Rvcih0aGlzLndpZHRoLCB0aGlzLmhlaWdodCwgdGhpcywgJ3NldFNpemUnKTtcblx0fSxcblxuXHRzZXRTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICh0aGlzLl9maXhYKVxuXHRcdFx0dGhpcy54ICs9ICh0aGlzLndpZHRoIC0gc2l6ZS53aWR0aCkgKiB0aGlzLl9maXhYO1xuXHRcdGlmICh0aGlzLl9maXhZKVxuXHRcdFx0dGhpcy55ICs9ICh0aGlzLmhlaWdodCAtIHNpemUuaGVpZ2h0KSAqIHRoaXMuX2ZpeFk7XG5cdFx0dGhpcy53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0dGhpcy5oZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHR0aGlzLl9maXhXID0gMTtcblx0XHR0aGlzLl9maXhIID0gMTtcblx0fSxcblxuXHRnZXRMZWZ0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54O1xuXHR9LFxuXG5cdHNldExlZnQ6IGZ1bmN0aW9uKGxlZnQpIHtcblx0XHRpZiAoIXRoaXMuX2ZpeFcpXG5cdFx0XHR0aGlzLndpZHRoIC09IGxlZnQgLSB0aGlzLng7XG5cdFx0dGhpcy54ID0gbGVmdDtcblx0XHR0aGlzLl9maXhYID0gMDtcblx0fSxcblxuXHRnZXRUb3A6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnk7XG5cdH0sXG5cblx0c2V0VG9wOiBmdW5jdGlvbih0b3ApIHtcblx0XHRpZiAoIXRoaXMuX2ZpeEgpXG5cdFx0XHR0aGlzLmhlaWdodCAtPSB0b3AgLSB0aGlzLnk7XG5cdFx0dGhpcy55ID0gdG9wO1xuXHRcdHRoaXMuX2ZpeFkgPSAwO1xuXHR9LFxuXG5cdGdldFJpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy54ICsgdGhpcy53aWR0aDtcblx0fSxcblxuXHRzZXRSaWdodDogZnVuY3Rpb24ocmlnaHQpIHtcblx0XHRpZiAodGhpcy5fZml4WCAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2ZpeFggIT09IDEpXG5cdFx0XHR0aGlzLl9maXhXID0gMDtcblx0XHRpZiAodGhpcy5fZml4Vylcblx0XHRcdHRoaXMueCA9IHJpZ2h0IC0gdGhpcy53aWR0aDtcblx0XHRlbHNlXG5cdFx0XHR0aGlzLndpZHRoID0gcmlnaHQgLSB0aGlzLng7XG5cdFx0dGhpcy5fZml4WCA9IDE7XG5cdH0sXG5cblx0Z2V0Qm90dG9tOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy55ICsgdGhpcy5oZWlnaHQ7XG5cdH0sXG5cblx0c2V0Qm90dG9tOiBmdW5jdGlvbihib3R0b20pIHtcblx0XHRpZiAodGhpcy5fZml4WSAhPT0gdW5kZWZpbmVkICYmIHRoaXMuX2ZpeFkgIT09IDEpXG5cdFx0XHR0aGlzLl9maXhIID0gMDtcblx0XHRpZiAodGhpcy5fZml4SClcblx0XHRcdHRoaXMueSA9IGJvdHRvbSAtIHRoaXMuaGVpZ2h0O1xuXHRcdGVsc2Vcblx0XHRcdHRoaXMuaGVpZ2h0ID0gYm90dG9tIC0gdGhpcy55O1xuXHRcdHRoaXMuX2ZpeFkgPSAxO1xuXHR9LFxuXG5cdGdldENlbnRlclg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnggKyB0aGlzLndpZHRoICogMC41O1xuXHR9LFxuXG5cdHNldENlbnRlclg6IGZ1bmN0aW9uKHgpIHtcblx0XHR0aGlzLnggPSB4IC0gdGhpcy53aWR0aCAqIDAuNTtcblx0XHR0aGlzLl9maXhYID0gMC41O1xuXHR9LFxuXG5cdGdldENlbnRlclk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLnkgKyB0aGlzLmhlaWdodCAqIDAuNTtcblx0fSxcblxuXHRzZXRDZW50ZXJZOiBmdW5jdGlvbih5KSB7XG5cdFx0dGhpcy55ID0geSAtIHRoaXMuaGVpZ2h0ICogMC41O1xuXHRcdHRoaXMuX2ZpeFkgPSAwLjU7XG5cdH0sXG5cblx0Z2V0Q2VudGVyOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgY3RvciA9IF9kb250TGluayA/IFBvaW50IDogTGlua2VkUG9pbnQ7XG5cdFx0cmV0dXJuIG5ldyBjdG9yKHRoaXMuZ2V0Q2VudGVyWCgpLCB0aGlzLmdldENlbnRlclkoKSwgdGhpcywgJ3NldENlbnRlcicpO1xuXHR9LFxuXG5cdHNldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuc2V0Q2VudGVyWChwb2ludC54KTtcblx0XHR0aGlzLnNldENlbnRlclkocG9pbnQueSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0QXJlYTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMud2lkdGggKiB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy53aWR0aCA9PT0gMCB8fCB0aGlzLmhlaWdodCA9PT0gMDtcblx0fSxcblxuXHRjb250YWluczogZnVuY3Rpb24oYXJnKSB7XG5cdFx0cmV0dXJuIGFyZyAmJiBhcmcud2lkdGggIT09IHVuZGVmaW5lZFxuXHRcdFx0XHR8fCAoQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzKS5sZW5ndGggPT0gNFxuXHRcdFx0XHQ/IHRoaXMuX2NvbnRhaW5zUmVjdGFuZ2xlKFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cykpXG5cdFx0XHRcdDogdGhpcy5fY29udGFpbnNQb2ludChQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdF9jb250YWluc1BvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciB4ID0gcG9pbnQueCxcblx0XHRcdHkgPSBwb2ludC55O1xuXHRcdHJldHVybiB4ID49IHRoaXMueCAmJiB5ID49IHRoaXMueVxuXHRcdFx0XHQmJiB4IDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgeSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRfY29udGFpbnNSZWN0YW5nbGU6IGZ1bmN0aW9uKHJlY3QpIHtcblx0XHR2YXIgeCA9IHJlY3QueCxcblx0XHRcdHkgPSByZWN0Lnk7XG5cdFx0cmV0dXJuIHggPj0gdGhpcy54ICYmIHkgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHggKyByZWN0LndpZHRoIDw9IHRoaXMueCArIHRoaXMud2lkdGhcblx0XHRcdFx0JiYgeSArIHJlY3QuaGVpZ2h0IDw9IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gcmVjdC54ICsgcmVjdC53aWR0aCA+IHRoaXMueFxuXHRcdFx0XHQmJiByZWN0LnkgKyByZWN0LmhlaWdodCA+IHRoaXMueVxuXHRcdFx0XHQmJiByZWN0LnggPCB0aGlzLnggKyB0aGlzLndpZHRoXG5cdFx0XHRcdCYmIHJlY3QueSA8IHRoaXMueSArIHRoaXMuaGVpZ2h0O1xuXHR9LFxuXG5cdHRvdWNoZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gcmVjdC54ICsgcmVjdC53aWR0aCA+PSB0aGlzLnhcblx0XHRcdFx0JiYgcmVjdC55ICsgcmVjdC5oZWlnaHQgPj0gdGhpcy55XG5cdFx0XHRcdCYmIHJlY3QueCA8PSB0aGlzLnggKyB0aGlzLndpZHRoXG5cdFx0XHRcdCYmIHJlY3QueSA8PSB0aGlzLnkgKyB0aGlzLmhlaWdodDtcblx0fSxcblxuXHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHgxID0gTWF0aC5tYXgodGhpcy54LCByZWN0LngpLFxuXHRcdFx0eTEgPSBNYXRoLm1heCh0aGlzLnksIHJlY3QueSksXG5cdFx0XHR4MiA9IE1hdGgubWluKHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3QueCArIHJlY3Qud2lkdGgpLFxuXHRcdFx0eTIgPSBNYXRoLm1pbih0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0dW5pdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdHgxID0gTWF0aC5taW4odGhpcy54LCByZWN0LngpLFxuXHRcdFx0eTEgPSBNYXRoLm1pbih0aGlzLnksIHJlY3QueSksXG5cdFx0XHR4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHJlY3QueCArIHJlY3Qud2lkdGgpLFxuXHRcdFx0eTIgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgcmVjdC55ICsgcmVjdC5oZWlnaHQpO1xuXHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKHgxLCB5MSwgeDIgLSB4MSwgeTIgLSB5MSk7XG5cdH0sXG5cblx0aW5jbHVkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHZhciB4MSA9IE1hdGgubWluKHRoaXMueCwgcG9pbnQueCksXG5cdFx0XHR5MSA9IE1hdGgubWluKHRoaXMueSwgcG9pbnQueSksXG5cdFx0XHR4MiA9IE1hdGgubWF4KHRoaXMueCArIHRoaXMud2lkdGgsIHBvaW50LngpLFxuXHRcdFx0eTIgPSBNYXRoLm1heCh0aGlzLnkgKyB0aGlzLmhlaWdodCwgcG9pbnQueSk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHRleHBhbmQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBhbW91bnQgPSBTaXplLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGhvciA9IGFtb3VudC53aWR0aCxcblx0XHRcdHZlciA9IGFtb3VudC5oZWlnaHQ7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUodGhpcy54IC0gaG9yIC8gMiwgdGhpcy55IC0gdmVyIC8gMixcblx0XHRcdFx0dGhpcy53aWR0aCArIGhvciwgdGhpcy5oZWlnaHQgKyB2ZXIpO1xuXHR9LFxuXG5cdHNjYWxlOiBmdW5jdGlvbihob3IsIHZlcikge1xuXHRcdHJldHVybiB0aGlzLmV4cGFuZCh0aGlzLndpZHRoICogaG9yIC0gdGhpcy53aWR0aCxcblx0XHRcdFx0dGhpcy5oZWlnaHQgKiAodmVyID09PSB1bmRlZmluZWQgPyBob3IgOiB2ZXIpIC0gdGhpcy5oZWlnaHQpO1xuXHR9XG59LCBCYXNlLmVhY2goW1xuXHRcdFsnVG9wJywgJ0xlZnQnXSwgWydUb3AnLCAnUmlnaHQnXSxcblx0XHRbJ0JvdHRvbScsICdMZWZ0J10sIFsnQm90dG9tJywgJ1JpZ2h0J10sXG5cdFx0WydMZWZ0JywgJ0NlbnRlciddLCBbJ1RvcCcsICdDZW50ZXInXSxcblx0XHRbJ1JpZ2h0JywgJ0NlbnRlciddLCBbJ0JvdHRvbScsICdDZW50ZXInXVxuXHRdLFxuXHRmdW5jdGlvbihwYXJ0cywgaW5kZXgpIHtcblx0XHR2YXIgcGFydCA9IHBhcnRzLmpvaW4oJycpO1xuXHRcdHZhciB4Rmlyc3QgPSAvXltSTF0vLnRlc3QocGFydCk7XG5cdFx0aWYgKGluZGV4ID49IDQpXG5cdFx0XHRwYXJ0c1sxXSArPSB4Rmlyc3QgPyAnWScgOiAnWCc7XG5cdFx0dmFyIHggPSBwYXJ0c1t4Rmlyc3QgPyAwIDogMV0sXG5cdFx0XHR5ID0gcGFydHNbeEZpcnN0ID8gMSA6IDBdLFxuXHRcdFx0Z2V0WCA9ICdnZXQnICsgeCxcblx0XHRcdGdldFkgPSAnZ2V0JyArIHksXG5cdFx0XHRzZXRYID0gJ3NldCcgKyB4LFxuXHRcdFx0c2V0WSA9ICdzZXQnICsgeSxcblx0XHRcdGdldCA9ICdnZXQnICsgcGFydCxcblx0XHRcdHNldCA9ICdzZXQnICsgcGFydDtcblx0XHR0aGlzW2dldF0gPSBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHRcdHZhciBjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRcdHJldHVybiBuZXcgY3Rvcih0aGlzW2dldFhdKCksIHRoaXNbZ2V0WV0oKSwgdGhpcywgc2V0KTtcblx0XHR9O1xuXHRcdHRoaXNbc2V0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0dGhpc1tzZXRYXShwb2ludC54KTtcblx0XHRcdHRoaXNbc2V0WV0ocG9pbnQueSk7XG5cdFx0fTtcblx0fSwge1xuXHRcdGJlYW5zOiB0cnVlXG5cdH1cbikpO1xuXG52YXIgTGlua2VkUmVjdGFuZ2xlID0gUmVjdGFuZ2xlLmV4dGVuZCh7XG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFJlY3RhbmdsZSh4LCB5LCB3aWR0aCwgaGVpZ2h0LCBvd25lciwgc2V0dGVyKSB7XG5cdFx0dGhpcy5zZXQoeCwgeSwgd2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHR0aGlzLl9zZXR0ZXIgPSBzZXR0ZXI7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbih4LCB5LCB3aWR0aCwgaGVpZ2h0LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX3dpZHRoID0gd2lkdGg7XG5cdFx0dGhpcy5faGVpZ2h0ID0gaGVpZ2h0O1xuXHRcdGlmICghX2RvbnROb3RpZnkpXG5cdFx0XHR0aGlzLl9vd25lclt0aGlzLl9zZXR0ZXJdKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgcHJvdG8gPSBSZWN0YW5nbGUucHJvdG90eXBlO1xuXG5cdHJldHVybiBCYXNlLmVhY2goWyd4JywgJ3knLCAnd2lkdGgnLCAnaGVpZ2h0J10sIGZ1bmN0aW9uKGtleSkge1xuXHRcdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKGtleSk7XG5cdFx0dmFyIGludGVybmFsID0gJ18nICsga2V5O1xuXHRcdHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXNbaW50ZXJuYWxdO1xuXHRcdH07XG5cblx0XHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dGhpc1tpbnRlcm5hbF0gPSB2YWx1ZTtcblx0XHRcdGlmICghdGhpcy5fZG9udE5vdGlmeSlcblx0XHRcdFx0dGhpcy5fb3duZXJbdGhpcy5fc2V0dGVyXSh0aGlzKTtcblx0XHR9O1xuXHR9LCBCYXNlLmVhY2goWydQb2ludCcsICdTaXplJywgJ0NlbnRlcicsXG5cdFx0XHQnTGVmdCcsICdUb3AnLCAnUmlnaHQnLCAnQm90dG9tJywgJ0NlbnRlclgnLCAnQ2VudGVyWScsXG5cdFx0XHQnVG9wTGVmdCcsICdUb3BSaWdodCcsICdCb3R0b21MZWZ0JywgJ0JvdHRvbVJpZ2h0Jyxcblx0XHRcdCdMZWZ0Q2VudGVyJywgJ1RvcENlbnRlcicsICdSaWdodENlbnRlcicsICdCb3R0b21DZW50ZXInXSxcblx0XHRmdW5jdGlvbihrZXkpIHtcblx0XHRcdHZhciBuYW1lID0gJ3NldCcgKyBrZXk7XG5cdFx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHRoaXMuX2RvbnROb3RpZnkgPSB0cnVlO1xuXHRcdFx0XHRwcm90b1tuYW1lXS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdFx0XHR0aGlzLl9kb250Tm90aWZ5ID0gZmFsc2U7XG5cdFx0XHRcdHRoaXMuX293bmVyW3RoaXMuX3NldHRlcl0odGhpcyk7XG5cdFx0XHR9O1xuXHRcdH0sIHtcblx0XHRcdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRyZXR1cm4gdGhpcy5fb3duZXIuX2JvdW5kc1NlbGVjdGVkO1xuXHRcdFx0fSxcblxuXHRcdFx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0XHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXHRcdFx0XHRpZiAob3duZXIuc2V0U2VsZWN0ZWQpIHtcblx0XHRcdFx0XHRvd25lci5fYm91bmRzU2VsZWN0ZWQgPSBzZWxlY3RlZDtcblx0XHRcdFx0XHRvd25lci5zZXRTZWxlY3RlZChzZWxlY3RlZCB8fCBvd25lci5fc2VsZWN0ZWRTZWdtZW50U3RhdGUgPiAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pXG5cdCk7XG59KTtcblxudmFyIE1hdHJpeCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTWF0cml4JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBNYXRyaXgoYXJnKSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdG9rID0gdHJ1ZTtcblx0XHRpZiAoY291bnQgPT09IDYpIHtcblx0XHRcdHRoaXMuc2V0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMSkge1xuXHRcdFx0aWYgKGFyZyBpbnN0YW5jZW9mIE1hdHJpeCkge1xuXHRcdFx0XHR0aGlzLnNldChhcmcuX2EsIGFyZy5fYywgYXJnLl9iLCBhcmcuX2QsIGFyZy5fdHgsIGFyZy5fdHkpO1xuXHRcdFx0fSBlbHNlIGlmIChBcnJheS5pc0FycmF5KGFyZykpIHtcblx0XHRcdFx0dGhpcy5zZXQuYXBwbHkodGhpcywgYXJnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG9rID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMCkge1xuXHRcdFx0dGhpcy5yZXNldCgpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRvayA9IGZhbHNlO1xuXHRcdH1cblx0XHRpZiAoIW9rKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbnN1cHBvcnRlZCBtYXRyaXggcGFyYW1ldGVycycpO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oYSwgYywgYiwgZCwgdHgsIHR5LCBfZG9udE5vdGlmeSkge1xuXHRcdHRoaXMuX2EgPSBhO1xuXHRcdHRoaXMuX2MgPSBjO1xuXHRcdHRoaXMuX2IgPSBiO1xuXHRcdHRoaXMuX2QgPSBkO1xuXHRcdHRoaXMuX3R4ID0gdHg7XG5cdFx0dGhpcy5fdHkgPSB0eTtcblx0XHRpZiAoIV9kb250Tm90aWZ5KVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5nZXRWYWx1ZXMoKSwgb3B0aW9ucyk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXHRcdGlmIChvd25lcikge1xuXHRcdFx0aWYgKG93bmVyLl9hcHBseU1hdHJpeCkge1xuXHRcdFx0XHRvd25lci50cmFuc2Zvcm0obnVsbCwgdHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRvd25lci5fY2hhbmdlZCg5KTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgTWF0cml4KHRoaXMuX2EsIHRoaXMuX2MsIHRoaXMuX2IsIHRoaXMuX2QsXG5cdFx0XHRcdHRoaXMuX3R4LCB0aGlzLl90eSk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihteCkge1xuXHRcdHJldHVybiBteCA9PT0gdGhpcyB8fCBteCAmJiB0aGlzLl9hID09PSBteC5fYSAmJiB0aGlzLl9iID09PSBteC5fYlxuXHRcdFx0XHQmJiB0aGlzLl9jID09PSBteC5fYyAmJiB0aGlzLl9kID09PSBteC5fZFxuXHRcdFx0XHQmJiB0aGlzLl90eCA9PT0gbXguX3R4ICYmIHRoaXMuX3R5ID09PSBteC5fdHlcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBmID0gRm9ybWF0dGVyLmluc3RhbmNlO1xuXHRcdHJldHVybiAnW1snICsgW2YubnVtYmVyKHRoaXMuX2EpLCBmLm51bWJlcih0aGlzLl9iKSxcblx0XHRcdFx0XHRmLm51bWJlcih0aGlzLl90eCldLmpvaW4oJywgJykgKyAnXSwgWydcblx0XHRcdFx0KyBbZi5udW1iZXIodGhpcy5fYyksIGYubnVtYmVyKHRoaXMuX2QpLFxuXHRcdFx0XHRcdGYubnVtYmVyKHRoaXMuX3R5KV0uam9pbignLCAnKSArICddXSc7XG5cdH0sXG5cblx0cmVzZXQ6IGZ1bmN0aW9uKF9kb250Tm90aWZ5KSB7XG5cdFx0dGhpcy5fYSA9IHRoaXMuX2QgPSAxO1xuXHRcdHRoaXMuX2MgPSB0aGlzLl9iID0gdGhpcy5fdHggPSB0aGlzLl90eSA9IDA7XG5cdFx0aWYgKCFfZG9udE5vdGlmeSlcblx0XHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRhcHBseTogZnVuY3Rpb24ocmVjdXJzaXZlbHksIF9zZXRBcHBseU1hdHJpeCkge1xuXHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyO1xuXHRcdGlmIChvd25lcikge1xuXHRcdFx0b3duZXIudHJhbnNmb3JtKG51bGwsIHRydWUsIEJhc2UucGljayhyZWN1cnNpdmVseSwgdHJ1ZSksXG5cdFx0XHRcdFx0X3NldEFwcGx5TWF0cml4KTtcblx0XHRcdHJldHVybiB0aGlzLmlzSWRlbnRpdHkoKTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdHRyYW5zbGF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0eCA9IHBvaW50LngsXG5cdFx0XHR5ID0gcG9pbnQueTtcblx0XHR0aGlzLl90eCArPSB4ICogdGhpcy5fYSArIHkgKiB0aGlzLl9iO1xuXHRcdHRoaXMuX3R5ICs9IHggKiB0aGlzLl9jICsgeSAqIHRoaXMuX2Q7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNjYWxlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2NhbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHR0aGlzLl9hICo9IHNjYWxlLng7XG5cdFx0dGhpcy5fYyAqPSBzY2FsZS54O1xuXHRcdHRoaXMuX2IgKj0gc2NhbGUueTtcblx0XHR0aGlzLl9kICo9IHNjYWxlLnk7XG5cdFx0aWYgKGNlbnRlcilcblx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlci5uZWdhdGUoKSk7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHJvdGF0ZTogZnVuY3Rpb24oYW5nbGUgKSB7XG5cdFx0YW5nbGUgKj0gTWF0aC5QSSAvIDE4MDtcblx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpLFxuXHRcdFx0eCA9IGNlbnRlci54LFxuXHRcdFx0eSA9IGNlbnRlci55LFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0dHggPSB4IC0geCAqIGNvcyArIHkgKiBzaW4sXG5cdFx0XHR0eSA9IHkgLSB4ICogc2luIC0geSAqIGNvcyxcblx0XHRcdGEgPSB0aGlzLl9hLFxuXHRcdFx0YiA9IHRoaXMuX2IsXG5cdFx0XHRjID0gdGhpcy5fYyxcblx0XHRcdGQgPSB0aGlzLl9kO1xuXHRcdHRoaXMuX2EgPSBjb3MgKiBhICsgc2luICogYjtcblx0XHR0aGlzLl9iID0gLXNpbiAqIGEgKyBjb3MgKiBiO1xuXHRcdHRoaXMuX2MgPSBjb3MgKiBjICsgc2luICogZDtcblx0XHR0aGlzLl9kID0gLXNpbiAqIGMgKyBjb3MgKiBkO1xuXHRcdHRoaXMuX3R4ICs9IHR4ICogYSArIHR5ICogYjtcblx0XHR0aGlzLl90eSArPSB0eCAqIGMgKyB0eSAqIGQ7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHNoZWFyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2hlYXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRpZiAoY2VudGVyKVxuXHRcdFx0dGhpcy50cmFuc2xhdGUoY2VudGVyKTtcblx0XHR2YXIgYSA9IHRoaXMuX2EsXG5cdFx0XHRjID0gdGhpcy5fYztcblx0XHR0aGlzLl9hICs9IHNoZWFyLnkgKiB0aGlzLl9iO1xuXHRcdHRoaXMuX2MgKz0gc2hlYXIueSAqIHRoaXMuX2Q7XG5cdFx0dGhpcy5fYiArPSBzaGVhci54ICogYTtcblx0XHR0aGlzLl9kICs9IHNoZWFyLnggKiBjO1xuXHRcdGlmIChjZW50ZXIpXG5cdFx0XHR0aGlzLnRyYW5zbGF0ZShjZW50ZXIubmVnYXRlKCkpO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRza2V3OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2tldyA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IHJlYWROdWxsOiB0cnVlIH0pLFxuXHRcdFx0dG9SYWRpYW5zID0gTWF0aC5QSSAvIDE4MCxcblx0XHRcdHNoZWFyID0gbmV3IFBvaW50KE1hdGgudGFuKHNrZXcueCAqIHRvUmFkaWFucyksXG5cdFx0XHRcdE1hdGgudGFuKHNrZXcueSAqIHRvUmFkaWFucykpO1xuXHRcdHJldHVybiB0aGlzLnNoZWFyKHNoZWFyLCBjZW50ZXIpO1xuXHR9LFxuXG5cdGNvbmNhdGVuYXRlOiBmdW5jdGlvbihteCkge1xuXHRcdHZhciBhMSA9IHRoaXMuX2EsXG5cdFx0XHRiMSA9IHRoaXMuX2IsXG5cdFx0XHRjMSA9IHRoaXMuX2MsXG5cdFx0XHRkMSA9IHRoaXMuX2QsXG5cdFx0XHRhMiA9IG14Ll9hLFxuXHRcdFx0YjIgPSBteC5fYixcblx0XHRcdGMyID0gbXguX2MsXG5cdFx0XHRkMiA9IG14Ll9kLFxuXHRcdFx0dHgyID0gbXguX3R4LFxuXHRcdFx0dHkyID0gbXguX3R5O1xuXHRcdHRoaXMuX2EgPSBhMiAqIGExICsgYzIgKiBiMTtcblx0XHR0aGlzLl9iID0gYjIgKiBhMSArIGQyICogYjE7XG5cdFx0dGhpcy5fYyA9IGEyICogYzEgKyBjMiAqIGQxO1xuXHRcdHRoaXMuX2QgPSBiMiAqIGMxICsgZDIgKiBkMTtcblx0XHR0aGlzLl90eCArPSB0eDIgKiBhMSArIHR5MiAqIGIxO1xuXHRcdHRoaXMuX3R5ICs9IHR4MiAqIGMxICsgdHkyICogZDE7XG5cdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdHByZUNvbmNhdGVuYXRlOiBmdW5jdGlvbihteCkge1xuXHRcdHZhciBhMSA9IHRoaXMuX2EsXG5cdFx0XHRiMSA9IHRoaXMuX2IsXG5cdFx0XHRjMSA9IHRoaXMuX2MsXG5cdFx0XHRkMSA9IHRoaXMuX2QsXG5cdFx0XHR0eDEgPSB0aGlzLl90eCxcblx0XHRcdHR5MSA9IHRoaXMuX3R5LFxuXHRcdFx0YTIgPSBteC5fYSxcblx0XHRcdGIyID0gbXguX2IsXG5cdFx0XHRjMiA9IG14Ll9jLFxuXHRcdFx0ZDIgPSBteC5fZCxcblx0XHRcdHR4MiA9IG14Ll90eCxcblx0XHRcdHR5MiA9IG14Ll90eTtcblx0XHR0aGlzLl9hID0gYTIgKiBhMSArIGIyICogYzE7XG5cdFx0dGhpcy5fYiA9IGEyICogYjEgKyBiMiAqIGQxO1xuXHRcdHRoaXMuX2MgPSBjMiAqIGExICsgZDIgKiBjMTtcblx0XHR0aGlzLl9kID0gYzIgKiBiMSArIGQyICogZDE7XG5cdFx0dGhpcy5fdHggPSBhMiAqIHR4MSArIGIyICogdHkxICsgdHgyO1xuXHRcdHRoaXMuX3R5ID0gYzIgKiB0eDEgKyBkMiAqIHR5MSArIHR5Mjtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Y2hhaW46IGZ1bmN0aW9uKG14KSB7XG5cdFx0dmFyIGExID0gdGhpcy5fYSxcblx0XHRcdGIxID0gdGhpcy5fYixcblx0XHRcdGMxID0gdGhpcy5fYyxcblx0XHRcdGQxID0gdGhpcy5fZCxcblx0XHRcdHR4MSA9IHRoaXMuX3R4LFxuXHRcdFx0dHkxID0gdGhpcy5fdHksXG5cdFx0XHRhMiA9IG14Ll9hLFxuXHRcdFx0YjIgPSBteC5fYixcblx0XHRcdGMyID0gbXguX2MsXG5cdFx0XHRkMiA9IG14Ll9kLFxuXHRcdFx0dHgyID0gbXguX3R4LFxuXHRcdFx0dHkyID0gbXguX3R5O1xuXHRcdHJldHVybiBuZXcgTWF0cml4KFxuXHRcdFx0XHRhMiAqIGExICsgYzIgKiBiMSxcblx0XHRcdFx0YTIgKiBjMSArIGMyICogZDEsXG5cdFx0XHRcdGIyICogYTEgKyBkMiAqIGIxLFxuXHRcdFx0XHRiMiAqIGMxICsgZDIgKiBkMSxcblx0XHRcdFx0dHgxICsgdHgyICogYTEgKyB0eTIgKiBiMSxcblx0XHRcdFx0dHkxICsgdHgyICogYzEgKyB0eTIgKiBkMSk7XG5cdH0sXG5cblx0aXNJZGVudGl0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2EgPT09IDEgJiYgdGhpcy5fYyA9PT0gMCAmJiB0aGlzLl9iID09PSAwICYmIHRoaXMuX2QgPT09IDFcblx0XHRcdFx0JiYgdGhpcy5fdHggPT09IDAgJiYgdGhpcy5fdHkgPT09IDA7XG5cdH0sXG5cblx0b3JOdWxsSWZJZGVudGl0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuaXNJZGVudGl0eSgpID8gbnVsbCA6IHRoaXM7XG5cdH0sXG5cblx0aXNJbnZlcnRpYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9nZXREZXRlcm1pbmFudCgpO1xuXHR9LFxuXG5cdGlzU2luZ3VsYXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fZ2V0RGV0ZXJtaW5hbnQoKTtcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKCBzcmMsIGRzdCwgY291bnQpIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA8IDNcblx0XHRcdD8gdGhpcy5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKVxuXHRcdFx0OiB0aGlzLl90cmFuc2Zvcm1Db29yZGluYXRlcyhzcmMsIGRzdCwgY291bnQpO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Qb2ludDogZnVuY3Rpb24ocG9pbnQsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIHggPSBwb2ludC54LFxuXHRcdFx0eSA9IHBvaW50Lnk7XG5cdFx0aWYgKCFkZXN0KVxuXHRcdFx0ZGVzdCA9IG5ldyBQb2ludCgpO1xuXHRcdHJldHVybiBkZXN0LnNldChcblx0XHRcdHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2IgKyB0aGlzLl90eCxcblx0XHRcdHggKiB0aGlzLl9jICsgeSAqIHRoaXMuX2QgKyB0aGlzLl90eSxcblx0XHRcdF9kb250Tm90aWZ5XG5cdFx0KTtcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29vcmRpbmF0ZXM6IGZ1bmN0aW9uKHNyYywgZHN0LCBjb3VudCkge1xuXHRcdHZhciBpID0gMCxcblx0XHRcdGogPSAwLFxuXHRcdFx0bWF4ID0gMiAqIGNvdW50O1xuXHRcdHdoaWxlIChpIDwgbWF4KSB7XG5cdFx0XHR2YXIgeCA9IHNyY1tpKytdLFxuXHRcdFx0XHR5ID0gc3JjW2krK107XG5cdFx0XHRkc3RbaisrXSA9IHggKiB0aGlzLl9hICsgeSAqIHRoaXMuX2IgKyB0aGlzLl90eDtcblx0XHRcdGRzdFtqKytdID0geCAqIHRoaXMuX2MgKyB5ICogdGhpcy5fZCArIHRoaXMuX3R5O1xuXHRcdH1cblx0XHRyZXR1cm4gZHN0O1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db3JuZXJzOiBmdW5jdGlvbihyZWN0KSB7XG5cdFx0dmFyIHgxID0gcmVjdC54LFxuXHRcdFx0eTEgPSByZWN0LnksXG5cdFx0XHR4MiA9IHgxICsgcmVjdC53aWR0aCxcblx0XHRcdHkyID0geTEgKyByZWN0LmhlaWdodCxcblx0XHRcdGNvb3JkcyA9IFsgeDEsIHkxLCB4MiwgeTEsIHgyLCB5MiwgeDEsIHkyIF07XG5cdFx0cmV0dXJuIHRoaXMuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKGNvb3JkcywgY29vcmRzLCA0KTtcblx0fSxcblxuXHRfdHJhbnNmb3JtQm91bmRzOiBmdW5jdGlvbihib3VuZHMsIGRlc3QsIF9kb250Tm90aWZ5KSB7XG5cdFx0dmFyIGNvb3JkcyA9IHRoaXMuX3RyYW5zZm9ybUNvcm5lcnMoYm91bmRzKSxcblx0XHRcdG1pbiA9IGNvb3Jkcy5zbGljZSgwLCAyKSxcblx0XHRcdG1heCA9IG1pbi5zbGljZSgpO1xuXHRcdGZvciAodmFyIGkgPSAyOyBpIDwgODsgaSsrKSB7XG5cdFx0XHR2YXIgdmFsID0gY29vcmRzW2ldLFxuXHRcdFx0XHRqID0gaSAmIDE7XG5cdFx0XHRpZiAodmFsIDwgbWluW2pdKVxuXHRcdFx0XHRtaW5bal0gPSB2YWw7XG5cdFx0XHRlbHNlIGlmICh2YWwgPiBtYXhbal0pXG5cdFx0XHRcdG1heFtqXSA9IHZhbDtcblx0XHR9XG5cdFx0aWYgKCFkZXN0KVxuXHRcdFx0ZGVzdCA9IG5ldyBSZWN0YW5nbGUoKTtcblx0XHRyZXR1cm4gZGVzdC5zZXQobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdLFxuXHRcdFx0XHRfZG9udE5vdGlmeSk7XG5cdH0sXG5cblx0aW52ZXJzZVRyYW5zZm9ybTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ludmVyc2VUcmFuc2Zvcm0oUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHRfZ2V0RGV0ZXJtaW5hbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZXQgPSB0aGlzLl9hICogdGhpcy5fZCAtIHRoaXMuX2IgKiB0aGlzLl9jO1xuXHRcdHJldHVybiBpc0Zpbml0ZShkZXQpICYmICFOdW1lcmljYWwuaXNaZXJvKGRldClcblx0XHRcdFx0JiYgaXNGaW5pdGUodGhpcy5fdHgpICYmIGlzRmluaXRlKHRoaXMuX3R5KVxuXHRcdFx0XHQ/IGRldCA6IG51bGw7XG5cdH0sXG5cblx0X2ludmVyc2VUcmFuc2Zvcm06IGZ1bmN0aW9uKHBvaW50LCBkZXN0LCBfZG9udE5vdGlmeSkge1xuXHRcdHZhciBkZXQgPSB0aGlzLl9nZXREZXRlcm1pbmFudCgpO1xuXHRcdGlmICghZGV0KVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIHggPSBwb2ludC54IC0gdGhpcy5fdHgsXG5cdFx0XHR5ID0gcG9pbnQueSAtIHRoaXMuX3R5O1xuXHRcdGlmICghZGVzdClcblx0XHRcdGRlc3QgPSBuZXcgUG9pbnQoKTtcblx0XHRyZXR1cm4gZGVzdC5zZXQoXG5cdFx0XHQoeCAqIHRoaXMuX2QgLSB5ICogdGhpcy5fYikgLyBkZXQsXG5cdFx0XHQoeSAqIHRoaXMuX2EgLSB4ICogdGhpcy5fYykgLyBkZXQsXG5cdFx0XHRfZG9udE5vdGlmeVxuXHRcdCk7XG5cdH0sXG5cblx0ZGVjb21wb3NlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYSA9IHRoaXMuX2EsIGIgPSB0aGlzLl9iLCBjID0gdGhpcy5fYywgZCA9IHRoaXMuX2Q7XG5cdFx0aWYgKE51bWVyaWNhbC5pc1plcm8oYSAqIGQgLSBiICogYykpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdHZhciBzY2FsZVggPSBNYXRoLnNxcnQoYSAqIGEgKyBiICogYik7XG5cdFx0YSAvPSBzY2FsZVg7XG5cdFx0YiAvPSBzY2FsZVg7XG5cblx0XHR2YXIgc2hlYXIgPSBhICogYyArIGIgKiBkO1xuXHRcdGMgLT0gYSAqIHNoZWFyO1xuXHRcdGQgLT0gYiAqIHNoZWFyO1xuXG5cdFx0dmFyIHNjYWxlWSA9IE1hdGguc3FydChjICogYyArIGQgKiBkKTtcblx0XHRjIC89IHNjYWxlWTtcblx0XHRkIC89IHNjYWxlWTtcblx0XHRzaGVhciAvPSBzY2FsZVk7XG5cblx0XHRpZiAoYSAqIGQgPCBiICogYykge1xuXHRcdFx0YSA9IC1hO1xuXHRcdFx0YiA9IC1iO1xuXHRcdFx0c2hlYXIgPSAtc2hlYXI7XG5cdFx0XHRzY2FsZVggPSAtc2NhbGVYO1xuXHRcdH1cblxuXHRcdHJldHVybiB7XG5cdFx0XHRzY2FsaW5nOiBuZXcgUG9pbnQoc2NhbGVYLCBzY2FsZVkpLFxuXHRcdFx0cm90YXRpb246IC1NYXRoLmF0YW4yKGIsIGEpICogMTgwIC8gTWF0aC5QSSxcblx0XHRcdHNoZWFyaW5nOiBzaGVhclxuXHRcdH07XG5cdH0sXG5cblx0Z2V0VmFsdWVzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gWyB0aGlzLl9hLCB0aGlzLl9jLCB0aGlzLl9iLCB0aGlzLl9kLCB0aGlzLl90eCwgdGhpcy5fdHkgXTtcblx0fSxcblxuXHRnZXRUcmFuc2xhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBQb2ludCh0aGlzLl90eCwgdGhpcy5fdHkpO1xuXHR9LFxuXG5cdGdldFNjYWxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5kZWNvbXBvc2UoKSB8fCB7fSkuc2NhbGluZztcblx0fSxcblxuXHRnZXRSb3RhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLmRlY29tcG9zZSgpIHx8IHt9KS5yb3RhdGlvbjtcblx0fSxcblxuXHRpbnZlcnRlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGRldCA9IHRoaXMuX2dldERldGVybWluYW50KCk7XG5cdFx0cmV0dXJuIGRldCAmJiBuZXcgTWF0cml4KFxuXHRcdFx0XHR0aGlzLl9kIC8gZGV0LFxuXHRcdFx0XHQtdGhpcy5fYyAvIGRldCxcblx0XHRcdFx0LXRoaXMuX2IgLyBkZXQsXG5cdFx0XHRcdHRoaXMuX2EgLyBkZXQsXG5cdFx0XHRcdCh0aGlzLl9iICogdGhpcy5fdHkgLSB0aGlzLl9kICogdGhpcy5fdHgpIC8gZGV0LFxuXHRcdFx0XHQodGhpcy5fYyAqIHRoaXMuX3R4IC0gdGhpcy5fYSAqIHRoaXMuX3R5KSAvIGRldCk7XG5cdH0sXG5cblx0c2hpZnRsZXNzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IE1hdHJpeCh0aGlzLl9hLCB0aGlzLl9jLCB0aGlzLl9iLCB0aGlzLl9kLCAwLCAwKTtcblx0fSxcblxuXHRhcHBseVRvQ29udGV4dDogZnVuY3Rpb24oY3R4KSB7XG5cdFx0Y3R4LnRyYW5zZm9ybSh0aGlzLl9hLCB0aGlzLl9jLCB0aGlzLl9iLCB0aGlzLl9kLCB0aGlzLl90eCwgdGhpcy5fdHkpO1xuXHR9XG59LCBCYXNlLmVhY2goWydhJywgJ2MnLCAnYicsICdkJywgJ3R4JywgJ3R5J10sIGZ1bmN0aW9uKG5hbWUpIHtcblx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0cHJvcCA9ICdfJyArIG5hbWU7XG5cdHRoaXNbJ2dldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzW3Byb3BdO1xuXHR9O1xuXHR0aGlzWydzZXQnICsgcGFydF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdHRoaXNbcHJvcF0gPSB2YWx1ZTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH07XG59LCB7fSkpO1xuXG52YXIgTGluZSA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnTGluZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTGluZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0KSB7XG5cdFx0dmFyIGFzVmVjdG9yID0gZmFsc2U7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPj0gNCkge1xuXHRcdFx0dGhpcy5fcHggPSBhcmcwO1xuXHRcdFx0dGhpcy5fcHkgPSBhcmcxO1xuXHRcdFx0dGhpcy5fdnggPSBhcmcyO1xuXHRcdFx0dGhpcy5fdnkgPSBhcmczO1xuXHRcdFx0YXNWZWN0b3IgPSBhcmc0O1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9weCA9IGFyZzAueDtcblx0XHRcdHRoaXMuX3B5ID0gYXJnMC55O1xuXHRcdFx0dGhpcy5fdnggPSBhcmcxLng7XG5cdFx0XHR0aGlzLl92eSA9IGFyZzEueTtcblx0XHRcdGFzVmVjdG9yID0gYXJnMjtcblx0XHR9XG5cdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0dGhpcy5fdnggLT0gdGhpcy5fcHg7XG5cdFx0XHR0aGlzLl92eSAtPSB0aGlzLl9weTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5fcHgsIHRoaXMuX3B5KTtcblx0fSxcblxuXHRnZXRWZWN0b3I6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgUG9pbnQodGhpcy5fdngsIHRoaXMuX3Z5KTtcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFZlY3RvcigpLmdldExlbmd0aCgpO1xuXHR9LFxuXG5cdGludGVyc2VjdDogZnVuY3Rpb24obGluZSwgaXNJbmZpbml0ZSkge1xuXHRcdHJldHVybiBMaW5lLmludGVyc2VjdChcblx0XHRcdFx0dGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksXG5cdFx0XHRcdGxpbmUuX3B4LCBsaW5lLl9weSwgbGluZS5fdngsIGxpbmUuX3Z5LFxuXHRcdFx0XHR0cnVlLCBpc0luZmluaXRlKTtcblx0fSxcblxuXHRnZXRTaWRlOiBmdW5jdGlvbihwb2ludCwgaXNJbmZpbml0ZSkge1xuXHRcdHJldHVybiBMaW5lLmdldFNpZGUoXG5cdFx0XHRcdHRoaXMuX3B4LCB0aGlzLl9weSwgdGhpcy5fdngsIHRoaXMuX3Z5LFxuXHRcdFx0XHRwb2ludC54LCBwb2ludC55LCB0cnVlLCBpc0luZmluaXRlKTtcblx0fSxcblxuXHRnZXREaXN0YW5jZTogZnVuY3Rpb24ocG9pbnQpIHtcblx0XHRyZXR1cm4gTWF0aC5hYnMoTGluZS5nZXRTaWduZWREaXN0YW5jZShcblx0XHRcdFx0dGhpcy5fcHgsIHRoaXMuX3B5LCB0aGlzLl92eCwgdGhpcy5fdnksXG5cdFx0XHRcdHBvaW50LngsIHBvaW50LnksIHRydWUpKTtcblx0fSxcblxuXHRpc0NvbGxpbmVhcjogZnVuY3Rpb24obGluZSkge1xuXHRcdHJldHVybiBQb2ludC5pc0NvbGxpbmVhcih0aGlzLl92eCwgdGhpcy5fdnksIGxpbmUuX3Z4LCBsaW5lLl92eSk7XG5cdH0sXG5cblx0aXNPcnRob2dvbmFsOiBmdW5jdGlvbihsaW5lKSB7XG5cdFx0cmV0dXJuIFBvaW50LmlzT3J0aG9nb25hbCh0aGlzLl92eCwgdGhpcy5fdnksIGxpbmUuX3Z4LCBsaW5lLl92eSk7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdGludGVyc2VjdDogZnVuY3Rpb24ocDF4LCBwMXksIHYxeCwgdjF5LCBwMngsIHAyeSwgdjJ4LCB2MnksIGFzVmVjdG9yLFxuXHRcdFx0XHRpc0luZmluaXRlKSB7XG5cdFx0XHRpZiAoIWFzVmVjdG9yKSB7XG5cdFx0XHRcdHYxeCAtPSBwMXg7XG5cdFx0XHRcdHYxeSAtPSBwMXk7XG5cdFx0XHRcdHYyeCAtPSBwMng7XG5cdFx0XHRcdHYyeSAtPSBwMnk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgY3Jvc3MgPSB2MXggKiB2MnkgLSB2MXkgKiB2Mng7XG5cdFx0XHRpZiAoIU51bWVyaWNhbC5pc1plcm8oY3Jvc3MpKSB7XG5cdFx0XHRcdHZhciBkeCA9IHAxeCAtIHAyeCxcblx0XHRcdFx0XHRkeSA9IHAxeSAtIHAyeSxcblx0XHRcdFx0XHR1MSA9ICh2MnggKiBkeSAtIHYyeSAqIGR4KSAvIGNyb3NzLFxuXHRcdFx0XHRcdHUyID0gKHYxeCAqIGR5IC0gdjF5ICogZHgpIC8gY3Jvc3MsXG5cdFx0XHRcdFx0ZXBzaWxvbiA9IDFlLTEyLFxuXHRcdFx0XHRcdHVNaW4gPSAtZXBzaWxvbixcblx0XHRcdFx0XHR1TWF4ID0gMSArIGVwc2lsb247XG5cdFx0XHRcdGlmIChpc0luZmluaXRlXG5cdFx0XHRcdFx0XHR8fCB1TWluIDwgdTEgJiYgdTEgPCB1TWF4ICYmIHVNaW4gPCB1MiAmJiB1MiA8IHVNYXgpIHtcblx0XHRcdFx0XHRpZiAoIWlzSW5maW5pdGUpIHtcblx0XHRcdFx0XHRcdHUxID0gdTEgPD0gMCA/IDAgOiB1MSA+PSAxID8gMSA6IHUxO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0XHRcdFx0XHRwMXggKyB1MSAqIHYxeCxcblx0XHRcdFx0XHRcdFx0cDF5ICsgdTEgKiB2MXkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdldFNpZGU6IGZ1bmN0aW9uKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3RvciwgaXNJbmZpbml0ZSkge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2eCAtPSBweDtcblx0XHRcdFx0dnkgLT0gcHk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgdjJ4ID0geCAtIHB4LFxuXHRcdFx0XHR2MnkgPSB5IC0gcHksXG5cdFx0XHRcdGNjdyA9IHYyeCAqIHZ5IC0gdjJ5ICogdng7XG5cdFx0XHRpZiAoY2N3ID09PSAwICYmICFpc0luZmluaXRlKSB7XG5cdFx0XHRcdGNjdyA9ICh2MnggKiB2eCArIHYyeCAqIHZ4KSAvICh2eCAqIHZ4ICsgdnkgKiB2eSk7XG5cdFx0XHRcdGlmIChjY3cgPj0gMCAmJiBjY3cgPD0gMSlcblx0XHRcdFx0XHRjY3cgPSAwO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNjdyA8IDAgPyAtMSA6IGNjdyA+IDAgPyAxIDogMDtcblx0XHR9LFxuXG5cdFx0Z2V0U2lnbmVkRGlzdGFuY2U6IGZ1bmN0aW9uKHB4LCBweSwgdngsIHZ5LCB4LCB5LCBhc1ZlY3Rvcikge1xuXHRcdFx0aWYgKCFhc1ZlY3Rvcikge1xuXHRcdFx0XHR2eCAtPSBweDtcblx0XHRcdFx0dnkgLT0gcHk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdnggPT09IDAgPyB2eSA+IDAgPyB4IC0gcHggOiBweCAtIHhcblx0XHRcdFx0IDogdnkgPT09IDAgPyB2eCA8IDAgPyB5IC0gcHkgOiBweSAtIHlcblx0XHRcdFx0IDogKCh4LXB4KSAqIHZ5IC0gKHktcHkpICogdngpIC8gTWF0aC5zcXJ0KHZ4ICogdnggKyB2eSAqIHZ5KTtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgUHJvamVjdCA9IFBhcGVyU2NvcGVJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1Byb2plY3QnLFxuXHRfbGlzdDogJ3Byb2plY3RzJyxcblx0X3JlZmVyZW5jZTogJ3Byb2plY3QnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFByb2plY3QoZWxlbWVudCkge1xuXHRcdFBhcGVyU2NvcGVJdGVtLmNhbGwodGhpcywgdHJ1ZSk7XG5cdFx0dGhpcy5sYXllcnMgPSBbXTtcblx0XHR0aGlzLl9hY3RpdmVMYXllciA9IG51bGw7XG5cdFx0dGhpcy5zeW1ib2xzID0gW107XG5cdFx0dGhpcy5fY3VycmVudFN0eWxlID0gbmV3IFN0eWxlKG51bGwsIG51bGwsIHRoaXMpO1xuXHRcdHRoaXMuX3ZpZXcgPSBWaWV3LmNyZWF0ZSh0aGlzLFxuXHRcdFx0XHRlbGVtZW50IHx8IENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcygxLCAxKSk7XG5cdFx0dGhpcy5fc2VsZWN0ZWRJdGVtcyA9IHt9O1xuXHRcdHRoaXMuX3NlbGVjdGVkSXRlbUNvdW50ID0gMDtcblx0XHR0aGlzLl91cGRhdGVWZXJzaW9uID0gMDtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKHRoaXMubGF5ZXJzLCBvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0fSxcblxuXHRjbGVhcjogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IHRoaXMubGF5ZXJzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKVxuXHRcdFx0dGhpcy5sYXllcnNbaV0ucmVtb3ZlKCk7XG5cdFx0dGhpcy5zeW1ib2xzID0gW107XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMubGF5ZXJzLmxlbmd0aCA9PT0gMDtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHtcblx0XHRpZiAoIXJlbW92ZS5iYXNlLmNhbGwodGhpcykpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0aWYgKHRoaXMuX3ZpZXcpXG5cdFx0XHR0aGlzLl92aWV3LnJlbW92ZSgpO1xuXHRcdHJldHVybiB0cnVlO1xuXHR9LFxuXG5cdGdldFZpZXc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl92aWV3O1xuXHR9LFxuXG5cdGdldEN1cnJlbnRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2N1cnJlbnRTdHlsZTtcblx0fSxcblxuXHRzZXRDdXJyZW50U3R5bGU6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dGhpcy5fY3VycmVudFN0eWxlLmluaXRpYWxpemUoc3R5bGUpO1xuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXg7XG5cdH0sXG5cblx0Z2V0T3B0aW9uczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Njb3BlLnNldHRpbmdzO1xuXHR9LFxuXG5cdGdldEFjdGl2ZUxheWVyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYWN0aXZlTGF5ZXIgfHwgbmV3IExheWVyKHsgcHJvamVjdDogdGhpcyB9KTtcblx0fSxcblxuXHRnZXRTZWxlY3RlZEl0ZW1zOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaXRlbXMgPSBbXTtcblx0XHRmb3IgKHZhciBpZCBpbiB0aGlzLl9zZWxlY3RlZEl0ZW1zKSB7XG5cdFx0XHR2YXIgaXRlbSA9IHRoaXMuX3NlbGVjdGVkSXRlbXNbaWRdO1xuXHRcdFx0aWYgKGl0ZW0uaXNJbnNlcnRlZCgpKVxuXHRcdFx0XHRpdGVtcy5wdXNoKGl0ZW0pO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbXM7XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGQ6IGZ1bmN0aW9uKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpIHtcblx0XHRpZiAoaXRlbSBpbnN0YW5jZW9mIExheWVyKSB7XG5cdFx0XHRpdGVtLl9yZW1vdmUoZmFsc2UsIHRydWUpO1xuXHRcdFx0QmFzZS5zcGxpY2UodGhpcy5sYXllcnMsIFtpdGVtXSwgaW5kZXgsIDApO1xuXHRcdFx0aXRlbS5fc2V0UHJvamVjdCh0aGlzLCB0cnVlKTtcblx0XHRcdGlmICh0aGlzLl9jaGFuZ2VzKVxuXHRcdFx0XHRpdGVtLl9jaGFuZ2VkKDUpO1xuXHRcdFx0aWYgKCF0aGlzLl9hY3RpdmVMYXllcilcblx0XHRcdFx0dGhpcy5fYWN0aXZlTGF5ZXIgPSBpdGVtO1xuXHRcdH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIEl0ZW0pIHtcblx0XHRcdCh0aGlzLl9hY3RpdmVMYXllclxuXHRcdFx0XHR8fCB0aGlzLmluc2VydENoaWxkKGluZGV4LCBuZXcgTGF5ZXIoSXRlbS5OT19JTlNFUlQpKSlcblx0XHRcdFx0XHQuaW5zZXJ0Q2hpbGQoaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGl0ZW0gPSBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbTtcblx0fSxcblxuXHRhZGRDaGlsZDogZnVuY3Rpb24oaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIHRoaXMuaW5zZXJ0Q2hpbGQodW5kZWZpbmVkLCBpdGVtLCBfcHJlc2VydmUpO1xuXHR9LFxuXG5cdF91cGRhdGVTZWxlY3Rpb246IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgaWQgPSBpdGVtLl9pZCxcblx0XHRcdHNlbGVjdGVkSXRlbXMgPSB0aGlzLl9zZWxlY3RlZEl0ZW1zO1xuXHRcdGlmIChpdGVtLl9zZWxlY3RlZCkge1xuXHRcdFx0aWYgKHNlbGVjdGVkSXRlbXNbaWRdICE9PSBpdGVtKSB7XG5cdFx0XHRcdHRoaXMuX3NlbGVjdGVkSXRlbUNvdW50Kys7XG5cdFx0XHRcdHNlbGVjdGVkSXRlbXNbaWRdID0gaXRlbTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKHNlbGVjdGVkSXRlbXNbaWRdID09PSBpdGVtKSB7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZEl0ZW1Db3VudC0tO1xuXHRcdFx0ZGVsZXRlIHNlbGVjdGVkSXRlbXNbaWRdO1xuXHRcdH1cblx0fSxcblxuXHRzZWxlY3RBbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXllcnMgPSB0aGlzLmxheWVycztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxheWVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRsYXllcnNbaV0uc2V0RnVsbHlTZWxlY3RlZCh0cnVlKTtcblx0fSxcblxuXHRkZXNlbGVjdEFsbDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlbGVjdGVkSXRlbXMgPSB0aGlzLl9zZWxlY3RlZEl0ZW1zO1xuXHRcdGZvciAodmFyIGkgaW4gc2VsZWN0ZWRJdGVtcylcblx0XHRcdHNlbGVjdGVkSXRlbXNbaV0uc2V0RnVsbHlTZWxlY3RlZChmYWxzZSk7XG5cdH0sXG5cblx0aGl0VGVzdDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0b3B0aW9ucyA9IEhpdFJlc3VsdC5nZXRPcHRpb25zKEJhc2UucmVhZChhcmd1bWVudHMpKTtcblx0XHRmb3IgKHZhciBpID0gdGhpcy5sYXllcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciByZXMgPSB0aGlzLmxheWVyc1tpXS5faGl0VGVzdChwb2ludCwgb3B0aW9ucyk7XG5cdFx0XHRpZiAocmVzKSByZXR1cm4gcmVzO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRJdGVtczogZnVuY3Rpb24obWF0Y2gpIHtcblx0XHRyZXR1cm4gSXRlbS5fZ2V0SXRlbXModGhpcy5sYXllcnMsIG1hdGNoKTtcblx0fSxcblxuXHRnZXRJdGVtOiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLmxheWVycywgbWF0Y2gsIG51bGwsIG51bGwsIHRydWUpWzBdIHx8IG51bGw7XG5cdH0sXG5cblx0aW1wb3J0SlNPTjogZnVuY3Rpb24oanNvbikge1xuXHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0XHR2YXIgbGF5ZXIgPSB0aGlzLl9hY3RpdmVMYXllcjtcblx0XHRyZXR1cm4gQmFzZS5pbXBvcnRKU09OKGpzb24sIGxheWVyICYmIGxheWVyLmlzRW1wdHkoKSAmJiBsYXllcik7XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY3R4LCBtYXRyaXgsIHBpeGVsUmF0aW8pIHtcblx0XHR0aGlzLl91cGRhdGVWZXJzaW9uKys7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHR2YXIgcGFyYW0gPSBuZXcgQmFzZSh7XG5cdFx0XHRvZmZzZXQ6IG5ldyBQb2ludCgwLCAwKSxcblx0XHRcdHBpeGVsUmF0aW86IHBpeGVsUmF0aW8sXG5cdFx0XHR2aWV3TWF0cml4OiBtYXRyaXguaXNJZGVudGl0eSgpID8gbnVsbCA6IG1hdHJpeCxcblx0XHRcdG1hdHJpY2VzOiBbbmV3IE1hdHJpeCgpXSxcblx0XHRcdHVwZGF0ZU1hdHJpeDogdHJ1ZVxuXHRcdH0pO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsYXllcnMgPSB0aGlzLmxheWVycywgbCA9IGxheWVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRsYXllcnNbaV0uZHJhdyhjdHgsIHBhcmFtKTtcblx0XHRjdHgucmVzdG9yZSgpO1xuXG5cdFx0aWYgKHRoaXMuX3NlbGVjdGVkSXRlbUNvdW50ID4gMCkge1xuXHRcdFx0Y3R4LnNhdmUoKTtcblx0XHRcdGN0eC5zdHJva2VXaWR0aCA9IDE7XG5cdFx0XHR2YXIgaXRlbXMgPSB0aGlzLl9zZWxlY3RlZEl0ZW1zLFxuXHRcdFx0XHRzaXplID0gdGhpcy5fc2NvcGUuc2V0dGluZ3MuaGFuZGxlU2l6ZSxcblx0XHRcdFx0dmVyc2lvbiA9IHRoaXMuX3VwZGF0ZVZlcnNpb247XG5cdFx0XHRmb3IgKHZhciBpZCBpbiBpdGVtcylcblx0XHRcdFx0aXRlbXNbaWRdLl9kcmF3U2VsZWN0aW9uKGN0eCwgbWF0cml4LCBzaXplLCBpdGVtcywgdmVyc2lvbik7XG5cdFx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBTeW1ib2wgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ1N5bWJvbCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU3ltYm9sKGl0ZW0sIGRvbnRDZW50ZXIpIHtcblx0XHR0aGlzLl9pZCA9IFVJRC5nZXQoKTtcblx0XHR0aGlzLnByb2plY3QgPSBwYXBlci5wcm9qZWN0O1xuXHRcdHRoaXMucHJvamVjdC5zeW1ib2xzLnB1c2godGhpcyk7XG5cdFx0aWYgKGl0ZW0pXG5cdFx0XHR0aGlzLnNldERlZmluaXRpb24oaXRlbSwgZG9udENlbnRlcik7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucywgZGljdGlvbmFyeSkge1xuXHRcdHJldHVybiBkaWN0aW9uYXJ5LmFkZCh0aGlzLCBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZShbdGhpcy5fY2xhc3MsIHRoaXMuX2RlZmluaXRpb25dLFxuXHRcdFx0XHRcdG9wdGlvbnMsIGZhbHNlLCBkaWN0aW9uYXJ5KTtcblx0XHR9KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oZmxhZ3MpIHtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKHRoaXMpO1xuXHRcdH1cblx0XHRpZiAoZmxhZ3MgJiAxKSB7XG5cdFx0XHR0aGlzLnByb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0RGVmaW5pdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RlZmluaXRpb247XG5cdH0sXG5cblx0c2V0RGVmaW5pdGlvbjogZnVuY3Rpb24oaXRlbSwgX2RvbnRDZW50ZXIpIHtcblx0XHRpZiAoaXRlbS5fcGFyZW50U3ltYm9sKVxuXHRcdFx0aXRlbSA9IGl0ZW0uY2xvbmUoKTtcblx0XHRpZiAodGhpcy5fZGVmaW5pdGlvbilcblx0XHRcdHRoaXMuX2RlZmluaXRpb24uX3BhcmVudFN5bWJvbCA9IG51bGw7XG5cdFx0dGhpcy5fZGVmaW5pdGlvbiA9IGl0ZW07XG5cdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRpdGVtLnNldFNlbGVjdGVkKGZhbHNlKTtcblx0XHRpZiAoIV9kb250Q2VudGVyKVxuXHRcdFx0aXRlbS5zZXRQb3NpdGlvbihuZXcgUG9pbnQoKSk7XG5cdFx0aXRlbS5fcGFyZW50U3ltYm9sID0gdGhpcztcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdHBsYWNlOiBmdW5jdGlvbihwb3NpdGlvbikge1xuXHRcdHJldHVybiBuZXcgUGxhY2VkU3ltYm9sKHRoaXMsIHBvc2l0aW9uKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTeW1ib2wodGhpcy5fZGVmaW5pdGlvbi5jbG9uZShmYWxzZSkpO1xuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3ltYm9sKSB7XG5cdFx0cmV0dXJuIHN5bWJvbCA9PT0gdGhpc1xuXHRcdFx0XHR8fCBzeW1ib2wgJiYgdGhpcy5kZWZpbml0aW9uLmVxdWFscyhzeW1ib2wuZGVmaW5pdGlvbilcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH1cbn0pO1xuXG52YXIgSXRlbSA9IEJhc2UuZXh0ZW5kKEVtaXR0ZXIsIHtcblx0c3RhdGljczoge1xuXHRcdGV4dGVuZDogZnVuY3Rpb24gZXh0ZW5kKHNyYykge1xuXHRcdFx0aWYgKHNyYy5fc2VyaWFsaXplRmllbGRzKVxuXHRcdFx0XHRzcmMuX3NlcmlhbGl6ZUZpZWxkcyA9IG5ldyBCYXNlKFxuXHRcdFx0XHRcdFx0dGhpcy5wcm90b3R5cGUuX3NlcmlhbGl6ZUZpZWxkcywgc3JjLl9zZXJpYWxpemVGaWVsZHMpO1xuXHRcdFx0cmV0dXJuIGV4dGVuZC5iYXNlLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdE5PX0lOU0VSVDogeyBpbnNlcnQ6IGZhbHNlIH1cblx0fSxcblxuXHRfY2xhc3M6ICdJdGVtJyxcblx0X2FwcGx5TWF0cml4OiB0cnVlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IHRydWUsXG5cdF9ib3VuZHNTZWxlY3RlZDogZmFsc2UsXG5cdF9zZWxlY3RDaGlsZHJlbjogZmFsc2UsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRuYW1lOiBudWxsLFxuXHRcdGFwcGx5TWF0cml4OiBudWxsLFxuXHRcdG1hdHJpeDogbmV3IE1hdHJpeCgpLFxuXHRcdHBpdm90OiBudWxsLFxuXHRcdGxvY2tlZDogZmFsc2UsXG5cdFx0dmlzaWJsZTogdHJ1ZSxcblx0XHRibGVuZE1vZGU6ICdub3JtYWwnLFxuXHRcdG9wYWNpdHk6IDEsXG5cdFx0Z3VpZGU6IGZhbHNlLFxuXHRcdHNlbGVjdGVkOiBmYWxzZSxcblx0XHRjbGlwTWFzazogZmFsc2UsXG5cdFx0ZGF0YToge31cblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBJdGVtKCkge1xuXHR9LFxuXG5cdF9pbml0aWFsaXplOiBmdW5jdGlvbihwcm9wcywgcG9pbnQpIHtcblx0XHR2YXIgaGFzUHJvcHMgPSBwcm9wcyAmJiBCYXNlLmlzUGxhaW5PYmplY3QocHJvcHMpLFxuXHRcdFx0aW50ZXJuYWwgPSBoYXNQcm9wcyAmJiBwcm9wcy5pbnRlcm5hbCA9PT0gdHJ1ZSxcblx0XHRcdG1hdHJpeCA9IHRoaXMuX21hdHJpeCA9IG5ldyBNYXRyaXgoKSxcblx0XHRcdHByb2plY3QgPSBoYXNQcm9wcyAmJiBwcm9wcy5wcm9qZWN0IHx8IHBhcGVyLnByb2plY3Q7XG5cdFx0aWYgKCFpbnRlcm5hbClcblx0XHRcdHRoaXMuX2lkID0gVUlELmdldCgpO1xuXHRcdHRoaXMuX2FwcGx5TWF0cml4ID0gdGhpcy5fY2FuQXBwbHlNYXRyaXggJiYgcGFwZXIuc2V0dGluZ3MuYXBwbHlNYXRyaXg7XG5cdFx0aWYgKHBvaW50KVxuXHRcdFx0bWF0cml4LnRyYW5zbGF0ZShwb2ludCk7XG5cdFx0bWF0cml4Ll9vd25lciA9IHRoaXM7XG5cdFx0dGhpcy5fc3R5bGUgPSBuZXcgU3R5bGUocHJvamVjdC5fY3VycmVudFN0eWxlLCB0aGlzLCBwcm9qZWN0KTtcblx0XHRpZiAoIXRoaXMuX3Byb2plY3QpIHtcblx0XHRcdGlmIChpbnRlcm5hbCB8fCBoYXNQcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT09IGZhbHNlKSB7XG5cdFx0XHRcdHRoaXMuX3NldFByb2plY3QocHJvamVjdCk7XG5cdFx0XHR9IGVsc2UgaWYgKGhhc1Byb3BzICYmIHByb3BzLnBhcmVudCkge1xuXHRcdFx0XHR0aGlzLnNldFBhcmVudChwcm9wcy5wYXJlbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0KHByb2plY3QuX2FjdGl2ZUxheWVyIHx8IG5ldyBMYXllcigpKS5hZGRDaGlsZCh0aGlzKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKGhhc1Byb3BzICYmIHByb3BzICE9PSBJdGVtLk5PX0lOU0VSVClcblx0XHRcdHRoaXMuX3NldChwcm9wcywgeyBpbnNlcnQ6IHRydWUsIHByb2plY3Q6IHRydWUsIHBhcmVudDogdHJ1ZSB9LFxuXHRcdFx0XHRcdHRydWUpO1xuXHRcdHJldHVybiBoYXNQcm9wcztcblx0fSxcblxuXHRfZXZlbnRzOiBCYXNlLmVhY2goWydvbk1vdXNlRG93bicsICdvbk1vdXNlVXAnLCAnb25Nb3VzZURyYWcnLCAnb25DbGljaycsXG5cdFx0XHQnb25Eb3VibGVDbGljaycsICdvbk1vdXNlTW92ZScsICdvbk1vdXNlRW50ZXInLCAnb25Nb3VzZUxlYXZlJ10sXG5cdFx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dGhpc1tuYW1lXSA9IHtcblx0XHRcdFx0aW5zdGFsbDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHRcdHRoaXMuZ2V0VmlldygpLl9pbnN0YWxsRXZlbnQodHlwZSk7XG5cdFx0XHRcdH0sXG5cblx0XHRcdFx0dW5pbnN0YWxsOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHRcdFx0dGhpcy5nZXRWaWV3KCkuX3VuaW5zdGFsbEV2ZW50KHR5cGUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXHRcdH0sIHtcblx0XHRcdG9uRnJhbWU6IHtcblx0XHRcdFx0aW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5nZXRWaWV3KCkuX2FuaW1hdGVJdGVtKHRoaXMsIHRydWUpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5nZXRWaWV3KCkuX2FuaW1hdGVJdGVtKHRoaXMsIGZhbHNlKTtcblx0XHRcdFx0fVxuXHRcdFx0fSxcblxuXHRcdFx0b25Mb2FkOiB7fVxuXHRcdH1cblx0KSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0dmFyIHByb3BzID0ge30sXG5cdFx0XHR0aGF0ID0gdGhpcztcblxuXHRcdGZ1bmN0aW9uIHNlcmlhbGl6ZShmaWVsZHMpIHtcblx0XHRcdGZvciAodmFyIGtleSBpbiBmaWVsZHMpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhhdFtrZXldO1xuXHRcdFx0XHRpZiAoIUJhc2UuZXF1YWxzKHZhbHVlLCBrZXkgPT09ICdsZWFkaW5nJ1xuXHRcdFx0XHRcdFx0PyBmaWVsZHMuZm9udFNpemUgKiAxLjIgOiBmaWVsZHNba2V5XSkpIHtcblx0XHRcdFx0XHRwcm9wc1trZXldID0gQmFzZS5zZXJpYWxpemUodmFsdWUsIG9wdGlvbnMsXG5cdFx0XHRcdFx0XHRcdGtleSAhPT0gJ2RhdGEnLCBkaWN0aW9uYXJ5KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHNlcmlhbGl6ZSh0aGlzLl9zZXJpYWxpemVGaWVsZHMpO1xuXHRcdGlmICghKHRoaXMgaW5zdGFuY2VvZiBHcm91cCkpXG5cdFx0XHRzZXJpYWxpemUodGhpcy5fc3R5bGUuX2RlZmF1bHRzKTtcblx0XHRyZXR1cm4gWyB0aGlzLl9jbGFzcywgcHJvcHMgXTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oZmxhZ3MpIHtcblx0XHR2YXIgc3ltYm9sID0gdGhpcy5fcGFyZW50U3ltYm9sLFxuXHRcdFx0Y2FjaGVQYXJlbnQgPSB0aGlzLl9wYXJlbnQgfHwgc3ltYm9sLFxuXHRcdFx0cHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0aWYgKGZsYWdzICYgOCkge1xuXHRcdFx0dGhpcy5fYm91bmRzID0gdGhpcy5fcG9zaXRpb24gPSB0aGlzLl9kZWNvbXBvc2VkID1cblx0XHRcdFx0XHR0aGlzLl9nbG9iYWxNYXRyaXggPSB0aGlzLl9jdXJyZW50UGF0aCA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdFx0aWYgKGNhY2hlUGFyZW50XG5cdFx0XHRcdCYmIChmbGFncyAmIDQwKSkge1xuXHRcdFx0SXRlbS5fY2xlYXJCb3VuZHNDYWNoZShjYWNoZVBhcmVudCk7XG5cdFx0fVxuXHRcdGlmIChmbGFncyAmIDIpIHtcblx0XHRcdEl0ZW0uX2NsZWFyQm91bmRzQ2FjaGUodGhpcyk7XG5cdFx0fVxuXHRcdGlmIChwcm9qZWN0KSB7XG5cdFx0XHRpZiAoZmxhZ3MgJiAxKSB7XG5cdFx0XHRcdHByb2plY3QuX25lZWRzVXBkYXRlID0gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdGlmIChwcm9qZWN0Ll9jaGFuZ2VzKSB7XG5cdFx0XHRcdHZhciBlbnRyeSA9IHByb2plY3QuX2NoYW5nZXNCeUlkW3RoaXMuX2lkXTtcblx0XHRcdFx0aWYgKGVudHJ5KSB7XG5cdFx0XHRcdFx0ZW50cnkuZmxhZ3MgfD0gZmxhZ3M7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0ZW50cnkgPSB7IGl0ZW06IHRoaXMsIGZsYWdzOiBmbGFncyB9O1xuXHRcdFx0XHRcdHByb2plY3QuX2NoYW5nZXNCeUlkW3RoaXMuX2lkXSA9IGVudHJ5O1xuXHRcdFx0XHRcdHByb2plY3QuX2NoYW5nZXMucHVzaChlbnRyeSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKHN5bWJvbClcblx0XHRcdHN5bWJvbC5fY2hhbmdlZChmbGFncyk7XG5cdH0sXG5cblx0c2V0OiBmdW5jdGlvbihwcm9wcykge1xuXHRcdGlmIChwcm9wcylcblx0XHRcdHRoaXMuX3NldChwcm9wcyk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0Z2V0SWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pZDtcblx0fSxcblxuXHRnZXROYW1lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbmFtZTtcblx0fSxcblxuXHRzZXROYW1lOiBmdW5jdGlvbihuYW1lLCB1bmlxdWUpIHtcblxuXHRcdGlmICh0aGlzLl9uYW1lKVxuXHRcdFx0dGhpcy5fcmVtb3ZlTmFtZWQoKTtcblx0XHRpZiAobmFtZSA9PT0gKCtuYW1lKSArICcnKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdOYW1lcyBjb25zaXN0aW5nIG9ubHkgb2YgbnVtYmVycyBhcmUgbm90IHN1cHBvcnRlZC4nKTtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChuYW1lICYmIHBhcmVudCkge1xuXHRcdFx0dmFyIGNoaWxkcmVuID0gcGFyZW50Ll9jaGlsZHJlbixcblx0XHRcdFx0bmFtZWRDaGlsZHJlbiA9IHBhcmVudC5fbmFtZWRDaGlsZHJlbixcblx0XHRcdFx0b3JpZyA9IG5hbWUsXG5cdFx0XHRcdGkgPSAxO1xuXHRcdFx0d2hpbGUgKHVuaXF1ZSAmJiBjaGlsZHJlbltuYW1lXSlcblx0XHRcdFx0bmFtZSA9IG9yaWcgKyAnICcgKyAoaSsrKTtcblx0XHRcdChuYW1lZENoaWxkcmVuW25hbWVdID0gbmFtZWRDaGlsZHJlbltuYW1lXSB8fCBbXSkucHVzaCh0aGlzKTtcblx0XHRcdGNoaWxkcmVuW25hbWVdID0gdGhpcztcblx0XHR9XG5cdFx0dGhpcy5fbmFtZSA9IG5hbWUgfHwgdW5kZWZpbmVkO1xuXHRcdHRoaXMuX2NoYW5nZWQoMTI4KTtcblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N0eWxlO1xuXHR9LFxuXG5cdHNldFN0eWxlOiBmdW5jdGlvbihzdHlsZSkge1xuXHRcdHRoaXMuZ2V0U3R5bGUoKS5zZXQoc3R5bGUpO1xuXHR9XG59LCBCYXNlLmVhY2goWydsb2NrZWQnLCAndmlzaWJsZScsICdibGVuZE1vZGUnLCAnb3BhY2l0eScsICdndWlkZSddLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUobmFtZSksXG5cdFx0XHRuYW1lID0gJ18nICsgbmFtZTtcblx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzW25hbWVdO1xuXHRcdH07XG5cdFx0dGhpc1snc2V0JyArIHBhcnRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdGlmICh2YWx1ZSAhPSB0aGlzW25hbWVdKSB7XG5cdFx0XHRcdHRoaXNbbmFtZV0gPSB2YWx1ZTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlZChuYW1lID09PSAnX2xvY2tlZCdcblx0XHRcdFx0XHRcdD8gMTI4IDogMTI5KTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LFxue30pLCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9sb2NrZWQ6IGZhbHNlLFxuXG5cdF92aXNpYmxlOiB0cnVlLFxuXG5cdF9ibGVuZE1vZGU6ICdub3JtYWwnLFxuXG5cdF9vcGFjaXR5OiAxLFxuXG5cdF9ndWlkZTogZmFsc2UsXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRpZiAoY2hpbGRyZW5baV0uaXNTZWxlY3RlZCgpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWQ7XG5cdH0sXG5cblx0c2V0U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkLCBub0NoaWxkcmVuKSB7XG5cdFx0aWYgKCFub0NoaWxkcmVuICYmIHRoaXMuX3NlbGVjdENoaWxkcmVuKSB7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdGlmICgoc2VsZWN0ZWQgPSAhIXNlbGVjdGVkKSBeIHRoaXMuX3NlbGVjdGVkKSB7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZCA9IHNlbGVjdGVkO1xuXHRcdFx0dGhpcy5fcHJvamVjdC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMjkpO1xuXHRcdH1cblx0fSxcblxuXHRfc2VsZWN0ZWQ6IGZhbHNlLFxuXG5cdGlzRnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuICYmIHRoaXMuX3NlbGVjdGVkKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0aWYgKCFjaGlsZHJlbltpXS5pc0Z1bGx5U2VsZWN0ZWQoKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX3NlbGVjdGVkO1xuXHR9LFxuXG5cdHNldEZ1bGx5U2VsZWN0ZWQ6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0aWYgKGNoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uc2V0RnVsbHlTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0fVxuXHRcdHRoaXMuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQsIHRydWUpO1xuXHR9LFxuXG5cdGlzQ2xpcE1hc2s6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jbGlwTWFzaztcblx0fSxcblxuXHRzZXRDbGlwTWFzazogZnVuY3Rpb24oY2xpcE1hc2spIHtcblx0XHRpZiAodGhpcy5fY2xpcE1hc2sgIT0gKGNsaXBNYXNrID0gISFjbGlwTWFzaykpIHtcblx0XHRcdHRoaXMuX2NsaXBNYXNrID0gY2xpcE1hc2s7XG5cdFx0XHRpZiAoY2xpcE1hc2spIHtcblx0XHRcdFx0dGhpcy5zZXRGaWxsQ29sb3IobnVsbCk7XG5cdFx0XHRcdHRoaXMuc2V0U3Ryb2tlQ29sb3IobnVsbCk7XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDEyOSk7XG5cdFx0XHRpZiAodGhpcy5fcGFyZW50KVxuXHRcdFx0XHR0aGlzLl9wYXJlbnQuX2NoYW5nZWQoMTAyNCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jbGlwTWFzazogZmFsc2UsXG5cblx0Z2V0RGF0YTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9kYXRhKVxuXHRcdFx0dGhpcy5fZGF0YSA9IHt9O1xuXHRcdHJldHVybiB0aGlzLl9kYXRhO1xuXHR9LFxuXG5cdHNldERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblx0XHR0aGlzLl9kYXRhID0gZGF0YTtcblx0fSxcblxuXHRnZXRQb3NpdGlvbjogZnVuY3Rpb24oX2RvbnRMaW5rKSB7XG5cdFx0dmFyIHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24sXG5cdFx0XHRjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRpZiAoIXBvc2l0aW9uKSB7XG5cdFx0XHR2YXIgcGl2b3QgPSB0aGlzLl9waXZvdDtcblx0XHRcdHBvc2l0aW9uID0gdGhpcy5fcG9zaXRpb24gPSBwaXZvdFxuXHRcdFx0XHRcdD8gdGhpcy5fbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwaXZvdClcblx0XHRcdFx0XHQ6IHRoaXMuZ2V0Qm91bmRzKCkuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gbmV3IGN0b3IocG9zaXRpb24ueCwgcG9zaXRpb24ueSwgdGhpcywgJ3NldFBvc2l0aW9uJyk7XG5cdH0sXG5cblx0c2V0UG9zaXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudHJhbnNsYXRlKFBvaW50LnJlYWQoYXJndW1lbnRzKS5zdWJ0cmFjdCh0aGlzLmdldFBvc2l0aW9uKHRydWUpKSk7XG5cdH0sXG5cblx0Z2V0UGl2b3Q6IGZ1bmN0aW9uKF9kb250TGluaykge1xuXHRcdHZhciBwaXZvdCA9IHRoaXMuX3Bpdm90O1xuXHRcdGlmIChwaXZvdCkge1xuXHRcdFx0dmFyIGN0b3IgPSBfZG9udExpbmsgPyBQb2ludCA6IExpbmtlZFBvaW50O1xuXHRcdFx0cGl2b3QgPSBuZXcgY3RvcihwaXZvdC54LCBwaXZvdC55LCB0aGlzLCAnc2V0UGl2b3QnKTtcblx0XHR9XG5cdFx0cmV0dXJuIHBpdm90O1xuXHR9LFxuXG5cdHNldFBpdm90OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9waXZvdCA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IGNsb25lOiB0cnVlLCByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHR0aGlzLl9wb3NpdGlvbiA9IHVuZGVmaW5lZDtcblx0fSxcblxuXHRfcGl2b3Q6IG51bGwsXG59LCBCYXNlLmVhY2goWydib3VuZHMnLCAnc3Ryb2tlQm91bmRzJywgJ2hhbmRsZUJvdW5kcycsICdyb3VnaEJvdW5kcycsXG5cdFx0J2ludGVybmFsQm91bmRzJywgJ2ludGVybmFsUm91Z2hCb3VuZHMnXSxcblx0ZnVuY3Rpb24oa2V5KSB7XG5cdFx0dmFyIGdldHRlciA9ICdnZXQnICsgQmFzZS5jYXBpdGFsaXplKGtleSksXG5cdFx0XHRtYXRjaCA9IGtleS5tYXRjaCgvXmludGVybmFsKC4qKSQvKSxcblx0XHRcdGludGVybmFsR2V0dGVyID0gbWF0Y2ggPyAnZ2V0JyArIG1hdGNoWzFdIDogbnVsbDtcblx0XHR0aGlzW2dldHRlcl0gPSBmdW5jdGlvbihfbWF0cml4KSB7XG5cdFx0XHR2YXIgYm91bmRzR2V0dGVyID0gdGhpcy5fYm91bmRzR2V0dGVyLFxuXHRcdFx0XHRuYW1lID0gIWludGVybmFsR2V0dGVyICYmICh0eXBlb2YgYm91bmRzR2V0dGVyID09PSAnc3RyaW5nJ1xuXHRcdFx0XHRcdFx0PyBib3VuZHNHZXR0ZXIgOiBib3VuZHNHZXR0ZXIgJiYgYm91bmRzR2V0dGVyW2dldHRlcl0pXG5cdFx0XHRcdFx0XHR8fCBnZXR0ZXIsXG5cdFx0XHRcdGJvdW5kcyA9IHRoaXMuX2dldENhY2hlZEJvdW5kcyhuYW1lLCBfbWF0cml4LCB0aGlzLFxuXHRcdFx0XHRcdFx0aW50ZXJuYWxHZXR0ZXIpO1xuXHRcdFx0cmV0dXJuIGtleSA9PT0gJ2JvdW5kcydcblx0XHRcdFx0XHQ/IG5ldyBMaW5rZWRSZWN0YW5nbGUoYm91bmRzLngsIGJvdW5kcy55LCBib3VuZHMud2lkdGgsXG5cdFx0XHRcdFx0XHRcdGJvdW5kcy5oZWlnaHQsIHRoaXMsICdzZXRCb3VuZHMnKVxuXHRcdFx0XHRcdDogYm91bmRzO1xuXHRcdH07XG5cdH0sXG57XG5cdGJlYW5zOiB0cnVlLFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoIWNoaWxkcmVuIHx8IGNoaWxkcmVuLmxlbmd0aCA9PSAwKVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoKTtcblx0XHRJdGVtLl91cGRhdGVCb3VuZHNDYWNoZSh0aGlzLCBjYWNoZUl0ZW0pO1xuXHRcdHZhciB4MSA9IEluZmluaXR5LFxuXHRcdFx0eDIgPSAteDEsXG5cdFx0XHR5MSA9IHgxLFxuXHRcdFx0eTIgPSB4Mjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG5cdFx0XHRpZiAoY2hpbGQuX3Zpc2libGUgJiYgIWNoaWxkLmlzRW1wdHkoKSkge1xuXHRcdFx0XHR2YXIgcmVjdCA9IGNoaWxkLl9nZXRDYWNoZWRCb3VuZHMoZ2V0dGVyLFxuXHRcdFx0XHRcdFx0bWF0cml4ICYmIG1hdHJpeC5jaGFpbihjaGlsZC5fbWF0cml4KSwgY2FjaGVJdGVtKTtcblx0XHRcdFx0eDEgPSBNYXRoLm1pbihyZWN0LngsIHgxKTtcblx0XHRcdFx0eTEgPSBNYXRoLm1pbihyZWN0LnksIHkxKTtcblx0XHRcdFx0eDIgPSBNYXRoLm1heChyZWN0LnggKyByZWN0LndpZHRoLCB4Mik7XG5cdFx0XHRcdHkyID0gTWF0aC5tYXgocmVjdC55ICsgcmVjdC5oZWlnaHQsIHkyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGlzRmluaXRlKHgxKVxuXHRcdFx0XHQ/IG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKVxuXHRcdFx0XHQ6IG5ldyBSZWN0YW5nbGUoKTtcblx0fSxcblxuXHRzZXRCb3VuZHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGJvdW5kcyA9IHRoaXMuZ2V0Qm91bmRzKCksXG5cdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCksXG5cdFx0XHRjZW50ZXIgPSByZWN0LmdldENlbnRlcigpO1xuXHRcdG1hdHJpeC50cmFuc2xhdGUoY2VudGVyKTtcblx0XHRpZiAocmVjdC53aWR0aCAhPSBib3VuZHMud2lkdGggfHwgcmVjdC5oZWlnaHQgIT0gYm91bmRzLmhlaWdodCkge1xuXHRcdFx0bWF0cml4LnNjYWxlKFxuXHRcdFx0XHRcdGJvdW5kcy53aWR0aCAhPSAwID8gcmVjdC53aWR0aCAvIGJvdW5kcy53aWR0aCA6IDEsXG5cdFx0XHRcdFx0Ym91bmRzLmhlaWdodCAhPSAwID8gcmVjdC5oZWlnaHQgLyBib3VuZHMuaGVpZ2h0IDogMSk7XG5cdFx0fVxuXHRcdGNlbnRlciA9IGJvdW5kcy5nZXRDZW50ZXIoKTtcblx0XHRtYXRyaXgudHJhbnNsYXRlKC1jZW50ZXIueCwgLWNlbnRlci55KTtcblx0XHR0aGlzLnRyYW5zZm9ybShtYXRyaXgpO1xuXHR9LFxuXG5cdF9nZXRDYWNoZWRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4LCBjYWNoZUl0ZW0sIGludGVybmFsR2V0dGVyKSB7XG5cdFx0bWF0cml4ID0gbWF0cml4ICYmIG1hdHJpeC5vck51bGxJZklkZW50aXR5KCk7XG5cdFx0dmFyIF9tYXRyaXggPSBpbnRlcm5hbEdldHRlciA/IG51bGwgOiB0aGlzLl9tYXRyaXgub3JOdWxsSWZJZGVudGl0eSgpLFxuXHRcdFx0Y2FjaGUgPSAoIW1hdHJpeCB8fCBtYXRyaXguZXF1YWxzKF9tYXRyaXgpKSAmJiBnZXR0ZXI7XG5cdFx0SXRlbS5fdXBkYXRlQm91bmRzQ2FjaGUodGhpcy5fcGFyZW50IHx8IHRoaXMuX3BhcmVudFN5bWJvbCwgY2FjaGVJdGVtKTtcblx0XHRpZiAoY2FjaGUgJiYgdGhpcy5fYm91bmRzICYmIHRoaXMuX2JvdW5kc1tjYWNoZV0pXG5cdFx0XHRyZXR1cm4gdGhpcy5fYm91bmRzW2NhY2hlXS5jbG9uZSgpO1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9nZXRCb3VuZHMoaW50ZXJuYWxHZXR0ZXIgfHwgZ2V0dGVyLFxuXHRcdFx0XHRtYXRyaXggfHwgX21hdHJpeCwgY2FjaGVJdGVtKTtcblx0XHRpZiAoY2FjaGUpIHtcblx0XHRcdGlmICghdGhpcy5fYm91bmRzKVxuXHRcdFx0XHR0aGlzLl9ib3VuZHMgPSB7fTtcblx0XHRcdHZhciBjYWNoZWQgPSB0aGlzLl9ib3VuZHNbY2FjaGVdID0gYm91bmRzLmNsb25lKCk7XG5cdFx0XHRjYWNoZWQuX2ludGVybmFsID0gISFpbnRlcm5hbEdldHRlcjtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblxuXHRzdGF0aWNzOiB7XG5cdFx0X3VwZGF0ZUJvdW5kc0NhY2hlOiBmdW5jdGlvbihwYXJlbnQsIGl0ZW0pIHtcblx0XHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdFx0dmFyIGlkID0gaXRlbS5faWQsXG5cdFx0XHRcdFx0cmVmID0gcGFyZW50Ll9ib3VuZHNDYWNoZSA9IHBhcmVudC5fYm91bmRzQ2FjaGUgfHwge1xuXHRcdFx0XHRcdFx0aWRzOiB7fSxcblx0XHRcdFx0XHRcdGxpc3Q6IFtdXG5cdFx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKCFyZWYuaWRzW2lkXSkge1xuXHRcdFx0XHRcdHJlZi5saXN0LnB1c2goaXRlbSk7XG5cdFx0XHRcdFx0cmVmLmlkc1tpZF0gPSBpdGVtO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdF9jbGVhckJvdW5kc0NhY2hlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0XHR2YXIgY2FjaGUgPSBpdGVtLl9ib3VuZHNDYWNoZTtcblx0XHRcdGlmIChjYWNoZSkge1xuXHRcdFx0XHRpdGVtLl9ib3VuZHMgPSBpdGVtLl9wb3NpdGlvbiA9IGl0ZW0uX2JvdW5kc0NhY2hlID0gdW5kZWZpbmVkO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbGlzdCA9IGNhY2hlLmxpc3QsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKyl7XG5cdFx0XHRcdFx0dmFyIG90aGVyID0gbGlzdFtpXTtcblx0XHRcdFx0XHRpZiAob3RoZXIgIT09IGl0ZW0pIHtcblx0XHRcdFx0XHRcdG90aGVyLl9ib3VuZHMgPSBvdGhlci5fcG9zaXRpb24gPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRpZiAob3RoZXIuX2JvdW5kc0NhY2hlKVxuXHRcdFx0XHRcdFx0XHRJdGVtLl9jbGVhckJvdW5kc0NhY2hlKG90aGVyKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH1cblxufSksIHtcblx0YmVhbnM6IHRydWUsXG5cblx0X2RlY29tcG9zZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2RlY29tcG9zZWQgPSB0aGlzLl9tYXRyaXguZGVjb21wb3NlKCk7XG5cdH0sXG5cblx0Z2V0Um90YXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZCB8fCB0aGlzLl9kZWNvbXBvc2UoKTtcblx0XHRyZXR1cm4gZGVjb21wb3NlZCAmJiBkZWNvbXBvc2VkLnJvdGF0aW9uO1xuXHR9LFxuXG5cdHNldFJvdGF0aW9uOiBmdW5jdGlvbihyb3RhdGlvbikge1xuXHRcdHZhciBjdXJyZW50ID0gdGhpcy5nZXRSb3RhdGlvbigpO1xuXHRcdGlmIChjdXJyZW50ICE9IG51bGwgJiYgcm90YXRpb24gIT0gbnVsbCkge1xuXHRcdFx0dmFyIGRlY29tcG9zZWQgPSB0aGlzLl9kZWNvbXBvc2VkO1xuXHRcdFx0dGhpcy5yb3RhdGUocm90YXRpb24gLSBjdXJyZW50KTtcblx0XHRcdGRlY29tcG9zZWQucm90YXRpb24gPSByb3RhdGlvbjtcblx0XHRcdHRoaXMuX2RlY29tcG9zZWQgPSBkZWNvbXBvc2VkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRTY2FsaW5nOiBmdW5jdGlvbihfZG9udExpbmspIHtcblx0XHR2YXIgZGVjb21wb3NlZCA9IHRoaXMuX2RlY29tcG9zZWQgfHwgdGhpcy5fZGVjb21wb3NlKCksXG5cdFx0XHRzY2FsaW5nID0gZGVjb21wb3NlZCAmJiBkZWNvbXBvc2VkLnNjYWxpbmcsXG5cdFx0XHRjdG9yID0gX2RvbnRMaW5rID8gUG9pbnQgOiBMaW5rZWRQb2ludDtcblx0XHRyZXR1cm4gc2NhbGluZyAmJiBuZXcgY3RvcihzY2FsaW5nLngsIHNjYWxpbmcueSwgdGhpcywgJ3NldFNjYWxpbmcnKTtcblx0fSxcblxuXHRzZXRTY2FsaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VycmVudCA9IHRoaXMuZ2V0U2NhbGluZygpO1xuXHRcdGlmIChjdXJyZW50KSB7XG5cdFx0XHR2YXIgc2NhbGluZyA9IFBvaW50LnJlYWQoYXJndW1lbnRzLCAwLCB7IGNsb25lOiB0cnVlIH0pLFxuXHRcdFx0XHRkZWNvbXBvc2VkID0gdGhpcy5fZGVjb21wb3NlZDtcblx0XHRcdHRoaXMuc2NhbGUoc2NhbGluZy54IC8gY3VycmVudC54LCBzY2FsaW5nLnkgLyBjdXJyZW50LnkpO1xuXHRcdFx0ZGVjb21wb3NlZC5zY2FsaW5nID0gc2NhbGluZztcblx0XHRcdHRoaXMuX2RlY29tcG9zZWQgPSBkZWNvbXBvc2VkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRNYXRyaXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXg7XG5cdH0sXG5cblx0c2V0TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fbWF0cml4O1xuXHRcdG1hdHJpeC5pbml0aWFsaXplLmFwcGx5KG1hdHJpeCwgYXJndW1lbnRzKTtcblx0XHRpZiAodGhpcy5fYXBwbHlNYXRyaXgpIHtcblx0XHRcdHRoaXMudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRHbG9iYWxNYXRyaXg6IGZ1bmN0aW9uKF9kb250Q2xvbmUpIHtcblx0XHR2YXIgbWF0cml4ID0gdGhpcy5fZ2xvYmFsTWF0cml4LFxuXHRcdFx0dXBkYXRlVmVyc2lvbiA9IHRoaXMuX3Byb2plY3QuX3VwZGF0ZVZlcnNpb247XG5cdFx0aWYgKG1hdHJpeCAmJiBtYXRyaXguX3VwZGF0ZVZlcnNpb24gIT09IHVwZGF0ZVZlcnNpb24pXG5cdFx0XHRtYXRyaXggPSBudWxsO1xuXHRcdGlmICghbWF0cml4KSB7XG5cdFx0XHRtYXRyaXggPSB0aGlzLl9nbG9iYWxNYXRyaXggPSB0aGlzLl9tYXRyaXguY2xvbmUoKTtcblx0XHRcdHZhciBwYXJlbnQgPSB0aGlzLl9wYXJlbnQ7XG5cdFx0XHRpZiAocGFyZW50KVxuXHRcdFx0XHRtYXRyaXgucHJlQ29uY2F0ZW5hdGUocGFyZW50LmdldEdsb2JhbE1hdHJpeCh0cnVlKSk7XG5cdFx0XHRtYXRyaXguX3VwZGF0ZVZlcnNpb24gPSB1cGRhdGVWZXJzaW9uO1xuXHRcdH1cblx0XHRyZXR1cm4gX2RvbnRDbG9uZSA/IG1hdHJpeCA6IG1hdHJpeC5jbG9uZSgpO1xuXHR9LFxuXG5cdGdldEFwcGx5TWF0cml4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fYXBwbHlNYXRyaXg7XG5cdH0sXG5cblx0c2V0QXBwbHlNYXRyaXg6IGZ1bmN0aW9uKGFwcGx5KSB7XG5cdFx0aWYgKHRoaXMuX2FwcGx5TWF0cml4ID0gdGhpcy5fY2FuQXBwbHlNYXRyaXggJiYgISFhcHBseSlcblx0XHRcdHRoaXMudHJhbnNmb3JtKG51bGwsIHRydWUpO1xuXHR9LFxuXG5cdGdldFRyYW5zZm9ybUNvbnRlbnQ6ICcjZ2V0QXBwbHlNYXRyaXgnLFxuXHRzZXRUcmFuc2Zvcm1Db250ZW50OiAnI3NldEFwcGx5TWF0cml4Jyxcbn0sIHtcblx0Z2V0UHJvamVjdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3Q7XG5cdH0sXG5cblx0X3NldFByb2plY3Q6IGZ1bmN0aW9uKHByb2plY3QsIGluc3RhbGxFdmVudHMpIHtcblx0XHRpZiAodGhpcy5fcHJvamVjdCAhPT0gcHJvamVjdCkge1xuXHRcdFx0aWYgKHRoaXMuX3Byb2plY3QpXG5cdFx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuXHRcdFx0dGhpcy5fcHJvamVjdCA9IHByb2plY3Q7XG5cdFx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRjaGlsZHJlbltpXS5fc2V0UHJvamVjdChwcm9qZWN0KTtcblx0XHRcdGluc3RhbGxFdmVudHMgPSB0cnVlO1xuXHRcdH1cblx0XHRpZiAoaW5zdGFsbEV2ZW50cylcblx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHModHJ1ZSk7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3QuZ2V0VmlldygpO1xuXHR9LFxuXG5cdF9pbnN0YWxsRXZlbnRzOiBmdW5jdGlvbiBfaW5zdGFsbEV2ZW50cyhpbnN0YWxsKSB7XG5cdFx0X2luc3RhbGxFdmVudHMuYmFzZS5jYWxsKHRoaXMsIGluc3RhbGwpO1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0Y2hpbGRyZW5baV0uX2luc3RhbGxFdmVudHMoaW5zdGFsbCk7XG5cdH0sXG5cblx0Z2V0TGF5ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzO1xuXHRcdHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudCBpbnN0YW5jZW9mIExheWVyKVxuXHRcdFx0XHRyZXR1cm4gcGFyZW50O1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRQYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQ7XG5cdH0sXG5cblx0c2V0UGFyZW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0uYWRkQ2hpbGQodGhpcyk7XG5cdH0sXG5cblx0Z2V0Q2hpbGRyZW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jaGlsZHJlbjtcblx0fSxcblxuXHRzZXRDaGlsZHJlbjogZnVuY3Rpb24oaXRlbXMpIHtcblx0XHR0aGlzLnJlbW92ZUNoaWxkcmVuKCk7XG5cdFx0dGhpcy5hZGRDaGlsZHJlbihpdGVtcyk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDaGlsZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuWzBdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0TGFzdENoaWxkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW5bdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMV1cblx0XHRcdFx0fHwgbnVsbDtcblx0fSxcblxuXHRnZXROZXh0U2libGluZzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCAmJiB0aGlzLl9wYXJlbnQuX2NoaWxkcmVuW3RoaXMuX2luZGV4ICsgMV0gfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91c1NpYmxpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgJiYgdGhpcy5fcGFyZW50Ll9jaGlsZHJlblt0aGlzLl9pbmRleCAtIDFdIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleDtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSA9PT0gdGhpcyB8fCBpdGVtICYmIHRoaXMuX2NsYXNzID09PSBpdGVtLl9jbGFzc1xuXHRcdFx0XHQmJiB0aGlzLl9zdHlsZS5lcXVhbHMoaXRlbS5fc3R5bGUpXG5cdFx0XHRcdCYmIHRoaXMuX21hdHJpeC5lcXVhbHMoaXRlbS5fbWF0cml4KVxuXHRcdFx0XHQmJiB0aGlzLl9sb2NrZWQgPT09IGl0ZW0uX2xvY2tlZFxuXHRcdFx0XHQmJiB0aGlzLl92aXNpYmxlID09PSBpdGVtLl92aXNpYmxlXG5cdFx0XHRcdCYmIHRoaXMuX2JsZW5kTW9kZSA9PT0gaXRlbS5fYmxlbmRNb2RlXG5cdFx0XHRcdCYmIHRoaXMuX29wYWNpdHkgPT09IGl0ZW0uX29wYWNpdHlcblx0XHRcdFx0JiYgdGhpcy5fY2xpcE1hc2sgPT09IGl0ZW0uX2NsaXBNYXNrXG5cdFx0XHRcdCYmIHRoaXMuX2d1aWRlID09PSBpdGVtLl9ndWlkZVxuXHRcdFx0XHQmJiB0aGlzLl9lcXVhbHMoaXRlbSlcblx0XHRcdFx0fHwgZmFsc2U7XG5cdH0sXG5cblx0X2VxdWFsczogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHJldHVybiBCYXNlLmVxdWFscyh0aGlzLl9jaGlsZHJlbiwgaXRlbS5fY2hpbGRyZW4pO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUobmV3IHRoaXMuY29uc3RydWN0b3IoSXRlbS5OT19JTlNFUlQpLCBpbnNlcnQpO1xuXHR9LFxuXG5cdF9jbG9uZTogZnVuY3Rpb24oY29weSwgaW5zZXJ0LCBpbmNsdWRlTWF0cml4KSB7XG5cdFx0dmFyIGtleXMgPSBbJ19sb2NrZWQnLCAnX3Zpc2libGUnLCAnX2JsZW5kTW9kZScsICdfb3BhY2l0eScsXG5cdFx0XHRcdCdfY2xpcE1hc2snLCAnX2d1aWRlJ10sXG5cdFx0XHRjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGNvcHkuc2V0U3R5bGUodGhpcy5fc3R5bGUpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4gJiYgY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjb3B5LmFkZENoaWxkKGNoaWxkcmVuW2ldLmNsb25lKGZhbHNlKSwgdHJ1ZSk7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBrZXkgPSBrZXlzW2ldO1xuXHRcdFx0aWYgKHRoaXMuaGFzT3duUHJvcGVydHkoa2V5KSlcblx0XHRcdFx0Y29weVtrZXldID0gdGhpc1trZXldO1xuXHRcdH1cblx0XHRpZiAoaW5jbHVkZU1hdHJpeCAhPT0gZmFsc2UpXG5cdFx0XHRjb3B5Ll9tYXRyaXguaW5pdGlhbGl6ZSh0aGlzLl9tYXRyaXgpO1xuXHRcdGNvcHkuc2V0QXBwbHlNYXRyaXgodGhpcy5fYXBwbHlNYXRyaXgpO1xuXHRcdGNvcHkuc2V0UGl2b3QodGhpcy5fcGl2b3QpO1xuXHRcdGNvcHkuc2V0U2VsZWN0ZWQodGhpcy5fc2VsZWN0ZWQpO1xuXHRcdGNvcHkuX2RhdGEgPSB0aGlzLl9kYXRhID8gQmFzZS5jbG9uZSh0aGlzLl9kYXRhKSA6IG51bGw7XG5cdFx0aWYgKGluc2VydCB8fCBpbnNlcnQgPT09IHVuZGVmaW5lZClcblx0XHRcdGNvcHkuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0aWYgKHRoaXMuX25hbWUpXG5cdFx0XHRjb3B5LnNldE5hbWUodGhpcy5fbmFtZSwgdHJ1ZSk7XG5cdFx0cmV0dXJuIGNvcHk7XG5cdH0sXG5cblx0Y29weVRvOiBmdW5jdGlvbihpdGVtT3JQcm9qZWN0KSB7XG5cdFx0cmV0dXJuIGl0ZW1PclByb2plY3QuYWRkQ2hpbGQodGhpcy5jbG9uZShmYWxzZSkpO1xuXHR9LFxuXG5cdHJhc3Rlcml6ZTogZnVuY3Rpb24ocmVzb2x1dGlvbikge1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldFN0cm9rZUJvdW5kcygpLFxuXHRcdFx0c2NhbGUgPSAocmVzb2x1dGlvbiB8fCB0aGlzLmdldFZpZXcoKS5nZXRSZXNvbHV0aW9uKCkpIC8gNzIsXG5cdFx0XHR0b3BMZWZ0ID0gYm91bmRzLmdldFRvcExlZnQoKS5mbG9vcigpLFxuXHRcdFx0Ym90dG9tUmlnaHQgPSBib3VuZHMuZ2V0Qm90dG9tUmlnaHQoKS5jZWlsKCksXG5cdFx0XHRzaXplID0gbmV3IFNpemUoYm90dG9tUmlnaHQuc3VidHJhY3QodG9wTGVmdCkpLFxuXHRcdFx0Y2FudmFzID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q2FudmFzKHNpemUubXVsdGlwbHkoc2NhbGUpKSxcblx0XHRcdGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLFxuXHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnNjYWxlKHNjYWxlKS50cmFuc2xhdGUodG9wTGVmdC5uZWdhdGUoKSk7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHRtYXRyaXguYXBwbHlUb0NvbnRleHQoY3R4KTtcblx0XHR0aGlzLmRyYXcoY3R4LCBuZXcgQmFzZSh7IG1hdHJpY2VzOiBbbWF0cml4XSB9KSk7XG5cdFx0Y3R4LnJlc3RvcmUoKTtcblx0XHR2YXIgcmFzdGVyID0gbmV3IFJhc3RlcihJdGVtLk5PX0lOU0VSVCk7XG5cdFx0cmFzdGVyLnNldENhbnZhcyhjYW52YXMpO1xuXHRcdHJhc3Rlci50cmFuc2Zvcm0obmV3IE1hdHJpeCgpLnRyYW5zbGF0ZSh0b3BMZWZ0LmFkZChzaXplLmRpdmlkZSgyKSkpXG5cdFx0XHRcdC5zY2FsZSgxIC8gc2NhbGUpKTtcblx0XHRyYXN0ZXIuaW5zZXJ0QWJvdmUodGhpcyk7XG5cdFx0cmV0dXJuIHJhc3Rlcjtcblx0fSxcblxuXHRjb250YWluczogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fY29udGFpbnMoXG5cdFx0XHRcdHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpKTtcblx0fSxcblxuXHRfY29udGFpbnM6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0aWYgKHRoaXMuX2NoaWxkcmVuKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKHRoaXMuX2NoaWxkcmVuW2ldLmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHBvaW50LmlzSW5zaWRlKHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKSk7XG5cdH0sXG5cblx0aXNJbnNpZGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpLmNvbnRhaW5zKHRoaXMuZ2V0Qm91bmRzKCkpO1xuXHR9LFxuXG5cdF9hc1BhdGhJdGVtOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IFBhdGguUmVjdGFuZ2xlKHtcblx0XHRcdHJlY3RhbmdsZTogdGhpcy5nZXRJbnRlcm5hbEJvdW5kcygpLFxuXHRcdFx0bWF0cml4OiB0aGlzLl9tYXRyaXgsXG5cdFx0XHRpbnNlcnQ6IGZhbHNlLFxuXHRcdH0pO1xuXHR9LFxuXG5cdGludGVyc2VjdHM6IGZ1bmN0aW9uKGl0ZW0sIF9tYXRyaXgpIHtcblx0XHRpZiAoIShpdGVtIGluc3RhbmNlb2YgSXRlbSkpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0cmV0dXJuIHRoaXMuX2FzUGF0aEl0ZW0oKS5nZXRJbnRlcnNlY3Rpb25zKGl0ZW0uX2FzUGF0aEl0ZW0oKSwgbnVsbCxcblx0XHRcdFx0X21hdHJpeCB8fCBpdGVtLl9tYXRyaXgsIHRydWUpLmxlbmd0aCA+IDA7XG5cdH0sXG5cblx0aGl0VGVzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2hpdFRlc3QoXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0SGl0UmVzdWx0LmdldE9wdGlvbnMoQmFzZS5yZWFkKGFyZ3VtZW50cykpKTtcblx0fSxcblxuXHRfaGl0VGVzdDogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMpIHtcblx0XHRpZiAodGhpcy5fbG9ja2VkIHx8ICF0aGlzLl92aXNpYmxlIHx8IHRoaXMuX2d1aWRlICYmICFvcHRpb25zLmd1aWRlc1xuXHRcdFx0XHR8fCB0aGlzLmlzRW1wdHkoKSlcblx0XHRcdHJldHVybiBudWxsO1xuXG5cdFx0dmFyIG1hdHJpeCA9IHRoaXMuX21hdHJpeCxcblx0XHRcdHBhcmVudFRvdGFsTWF0cml4ID0gb3B0aW9ucy5fdG90YWxNYXRyaXgsXG5cdFx0XHR2aWV3ID0gdGhpcy5nZXRWaWV3KCksXG5cdFx0XHR0b3RhbE1hdHJpeCA9IG9wdGlvbnMuX3RvdGFsTWF0cml4ID0gcGFyZW50VG90YWxNYXRyaXhcblx0XHRcdFx0XHQ/IHBhcmVudFRvdGFsTWF0cml4LmNoYWluKG1hdHJpeClcblx0XHRcdFx0XHQ6IHRoaXMuZ2V0R2xvYmFsTWF0cml4KCkucHJlQ29uY2F0ZW5hdGUodmlldy5fbWF0cml4KSxcblx0XHRcdHRvbGVyYW5jZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nID0gbmV3IFNpemUoXG5cdFx0XHRcdFx0XHRQYXRoLl9nZXRQZW5QYWRkaW5nKDEsIHRvdGFsTWF0cml4LmludmVydGVkKCkpXG5cdFx0XHRcdFx0KS5tdWx0aXBseShcblx0XHRcdFx0XHRcdE1hdGgubWF4KG9wdGlvbnMudG9sZXJhbmNlLCAxZS02KVxuXHRcdFx0XHRcdCk7XG5cdFx0cG9pbnQgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0ocG9pbnQpO1xuXG5cdFx0aWYgKCF0aGlzLl9jaGlsZHJlbiAmJiAhdGhpcy5nZXRJbnRlcm5hbFJvdWdoQm91bmRzKClcblx0XHRcdFx0LmV4cGFuZCh0b2xlcmFuY2VQYWRkaW5nLm11bHRpcGx5KDIpKS5fY29udGFpbnNQb2ludChwb2ludCkpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHR2YXIgY2hlY2tTZWxmID0gIShvcHRpb25zLmd1aWRlcyAmJiAhdGhpcy5fZ3VpZGVcblx0XHRcdFx0fHwgb3B0aW9ucy5zZWxlY3RlZCAmJiAhdGhpcy5fc2VsZWN0ZWRcblx0XHRcdFx0fHwgb3B0aW9ucy50eXBlICYmIG9wdGlvbnMudHlwZSAhPT0gQmFzZS5oeXBoZW5hdGUodGhpcy5fY2xhc3MpXG5cdFx0XHRcdHx8IG9wdGlvbnMuY2xhc3MgJiYgISh0aGlzIGluc3RhbmNlb2Ygb3B0aW9ucy5jbGFzcykpLFxuXHRcdFx0dGhhdCA9IHRoaXMsXG5cdFx0XHRyZXM7XG5cblx0XHRmdW5jdGlvbiBjaGVja0JvdW5kcyh0eXBlLCBwYXJ0KSB7XG5cdFx0XHR2YXIgcHQgPSBib3VuZHNbJ2dldCcgKyBwYXJ0XSgpO1xuXHRcdFx0aWYgKHBvaW50LnN1YnRyYWN0KHB0KS5kaXZpZGUodG9sZXJhbmNlUGFkZGluZykubGVuZ3RoIDw9IDEpXG5cdFx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KHR5cGUsIHRoYXQsXG5cdFx0XHRcdFx0XHR7IG5hbWU6IEJhc2UuaHlwaGVuYXRlKHBhcnQpLCBwb2ludDogcHQgfSk7XG5cdFx0fVxuXG5cdFx0aWYgKGNoZWNrU2VsZiAmJiAob3B0aW9ucy5jZW50ZXIgfHwgb3B0aW9ucy5ib3VuZHMpICYmIHRoaXMuX3BhcmVudCkge1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuZ2V0SW50ZXJuYWxCb3VuZHMoKTtcblx0XHRcdGlmIChvcHRpb25zLmNlbnRlcilcblx0XHRcdFx0cmVzID0gY2hlY2tCb3VuZHMoJ2NlbnRlcicsICdDZW50ZXInKTtcblx0XHRcdGlmICghcmVzICYmIG9wdGlvbnMuYm91bmRzKSB7XG5cdFx0XHRcdHZhciBwb2ludHMgPSBbXG5cdFx0XHRcdFx0J1RvcExlZnQnLCAnVG9wUmlnaHQnLCAnQm90dG9tTGVmdCcsICdCb3R0b21SaWdodCcsXG5cdFx0XHRcdFx0J0xlZnRDZW50ZXInLCAnVG9wQ2VudGVyJywgJ1JpZ2h0Q2VudGVyJywgJ0JvdHRvbUNlbnRlcidcblx0XHRcdFx0XTtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4ICYmICFyZXM7IGkrKylcblx0XHRcdFx0XHRyZXMgPSBjaGVja0JvdW5kcygnYm91bmRzJywgcG9pbnRzW2ldKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHR2YXIgY2hpbGRyZW4gPSAhcmVzICYmIHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbikge1xuXHRcdFx0dmFyIG9wdHMgPSB0aGlzLl9nZXRDaGlsZEhpdFRlc3RPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMCAmJiAhcmVzOyBpLS0pXG5cdFx0XHRcdHJlcyA9IGNoaWxkcmVuW2ldLl9oaXRUZXN0KHBvaW50LCBvcHRzKTtcblx0XHR9XG5cdFx0aWYgKCFyZXMgJiYgY2hlY2tTZWxmKVxuXHRcdFx0cmVzID0gdGhpcy5faGl0VGVzdFNlbGYocG9pbnQsIG9wdGlvbnMpO1xuXHRcdGlmIChyZXMgJiYgcmVzLnBvaW50KVxuXHRcdFx0cmVzLnBvaW50ID0gbWF0cml4LnRyYW5zZm9ybShyZXMucG9pbnQpO1xuXHRcdG9wdGlvbnMuX3RvdGFsTWF0cml4ID0gcGFyZW50VG90YWxNYXRyaXg7XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRfZ2V0Q2hpbGRIaXRUZXN0T3B0aW9uczogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBvcHRpb25zO1xuXHR9LFxuXG5cdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMpIHtcblx0XHRpZiAob3B0aW9ucy5maWxsICYmIHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuX2NvbnRhaW5zKHBvaW50KSlcblx0XHRcdHJldHVybiBuZXcgSGl0UmVzdWx0KCdmaWxsJywgdGhpcyk7XG5cdH0sXG5cblx0bWF0Y2hlczogZnVuY3Rpb24obmFtZSwgY29tcGFyZSkge1xuXHRcdGZ1bmN0aW9uIG1hdGNoT2JqZWN0KG9iajEsIG9iajIpIHtcblx0XHRcdGZvciAodmFyIGkgaW4gb2JqMSkge1xuXHRcdFx0XHRpZiAob2JqMS5oYXNPd25Qcm9wZXJ0eShpKSkge1xuXHRcdFx0XHRcdHZhciB2YWwxID0gb2JqMVtpXSxcblx0XHRcdFx0XHRcdHZhbDIgPSBvYmoyW2ldO1xuXHRcdFx0XHRcdGlmIChCYXNlLmlzUGxhaW5PYmplY3QodmFsMSkgJiYgQmFzZS5pc1BsYWluT2JqZWN0KHZhbDIpKSB7XG5cdFx0XHRcdFx0XHRpZiAoIW1hdGNoT2JqZWN0KHZhbDEsIHZhbDIpKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHRcdFx0fSBlbHNlIGlmICghQmFzZS5lcXVhbHModmFsMSwgdmFsMikpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHR2YXIgdHlwZSA9IHR5cGVvZiBuYW1lO1xuXHRcdGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIG5hbWUpIHtcblx0XHRcdFx0aWYgKG5hbWUuaGFzT3duUHJvcGVydHkoa2V5KSAmJiAhdGhpcy5tYXRjaGVzKGtleSwgbmFtZVtrZXldKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRyZXR1cm4gbmFtZSh0aGlzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHZhbHVlID0gL14oZW1wdHl8ZWRpdGFibGUpJC8udGVzdChuYW1lKVxuXHRcdFx0XHRcdD8gdGhpc1snaXMnICsgQmFzZS5jYXBpdGFsaXplKG5hbWUpXSgpXG5cdFx0XHRcdFx0OiBuYW1lID09PSAndHlwZSdcblx0XHRcdFx0XHRcdD8gQmFzZS5oeXBoZW5hdGUodGhpcy5fY2xhc3MpXG5cdFx0XHRcdFx0XHQ6IHRoaXNbbmFtZV07XG5cdFx0XHRpZiAoL14oY29uc3RydWN0b3J8Y2xhc3MpJC8udGVzdChuYW1lKSkge1xuXHRcdFx0XHRpZiAoISh0aGlzIGluc3RhbmNlb2YgY29tcGFyZSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmIChjb21wYXJlIGluc3RhbmNlb2YgUmVnRXhwKSB7XG5cdFx0XHRcdGlmICghY29tcGFyZS50ZXN0KHZhbHVlKSlcblx0XHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0XHR9IGVsc2UgaWYgKHR5cGVvZiBjb21wYXJlID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRcdGlmICghY29tcGFyZSh2YWx1ZSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmIChCYXNlLmlzUGxhaW5PYmplY3QoY29tcGFyZSkpIHtcblx0XHRcdFx0aWYgKCFtYXRjaE9iamVjdChjb21wYXJlLCB2YWx1ZSkpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fSBlbHNlIGlmICghQmFzZS5lcXVhbHModmFsdWUsIGNvbXBhcmUpKSB7XG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0Z2V0SXRlbXM6IGZ1bmN0aW9uKG1hdGNoKSB7XG5cdFx0cmV0dXJuIEl0ZW0uX2dldEl0ZW1zKHRoaXMuX2NoaWxkcmVuLCBtYXRjaCwgdGhpcy5fbWF0cml4KTtcblx0fSxcblxuXHRnZXRJdGVtOiBmdW5jdGlvbihtYXRjaCkge1xuXHRcdHJldHVybiBJdGVtLl9nZXRJdGVtcyh0aGlzLl9jaGlsZHJlbiwgbWF0Y2gsIHRoaXMuX21hdHJpeCwgbnVsbCwgdHJ1ZSlcblx0XHRcdFx0WzBdIHx8IG51bGw7XG5cdH0sXG5cblx0c3RhdGljczoge1xuXHRcdF9nZXRJdGVtczogZnVuY3Rpb24gX2dldEl0ZW1zKGNoaWxkcmVuLCBtYXRjaCwgbWF0cml4LCBwYXJhbSxcblx0XHRcdFx0Zmlyc3RPbmx5KSB7XG5cdFx0XHRpZiAoIXBhcmFtICYmIHR5cGVvZiBtYXRjaCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdFx0dmFyIG92ZXJsYXBwaW5nID0gbWF0Y2gub3ZlcmxhcHBpbmcsXG5cdFx0XHRcdFx0aW5zaWRlID0gbWF0Y2guaW5zaWRlLFxuXHRcdFx0XHRcdGJvdW5kcyA9IG92ZXJsYXBwaW5nIHx8IGluc2lkZSxcblx0XHRcdFx0XHRyZWN0ID0gYm91bmRzICYmIFJlY3RhbmdsZS5yZWFkKFtib3VuZHNdKTtcblx0XHRcdFx0cGFyYW0gPSB7XG5cdFx0XHRcdFx0aXRlbXM6IFtdLFxuXHRcdFx0XHRcdGluc2lkZTogISFpbnNpZGUsXG5cdFx0XHRcdFx0b3ZlcmxhcHBpbmc6ICEhb3ZlcmxhcHBpbmcsXG5cdFx0XHRcdFx0cmVjdDogcmVjdCxcblx0XHRcdFx0XHRwYXRoOiBvdmVybGFwcGluZyAmJiBuZXcgUGF0aC5SZWN0YW5nbGUoe1xuXHRcdFx0XHRcdFx0cmVjdGFuZ2xlOiByZWN0LFxuXHRcdFx0XHRcdFx0aW5zZXJ0OiBmYWxzZVxuXHRcdFx0XHRcdH0pXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmIChib3VuZHMpXG5cdFx0XHRcdFx0bWF0Y2ggPSBCYXNlLnNldCh7fSwgbWF0Y2gsXG5cdFx0XHRcdFx0XHRcdHsgaW5zaWRlOiB0cnVlLCBvdmVybGFwcGluZzogdHJ1ZSB9KTtcblx0XHRcdH1cblx0XHRcdHZhciBpdGVtcyA9IHBhcmFtICYmIHBhcmFtLml0ZW1zLFxuXHRcdFx0XHRyZWN0ID0gcGFyYW0gJiYgcGFyYW0ucmVjdDtcblx0XHRcdG1hdHJpeCA9IHJlY3QgJiYgKG1hdHJpeCB8fCBuZXcgTWF0cml4KCkpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbiAmJiBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gY2hpbGRyZW5baV0sXG5cdFx0XHRcdFx0Y2hpbGRNYXRyaXggPSBtYXRyaXggJiYgbWF0cml4LmNoYWluKGNoaWxkLl9tYXRyaXgpLFxuXHRcdFx0XHRcdGFkZCA9IHRydWU7XG5cdFx0XHRcdGlmIChyZWN0KSB7XG5cdFx0XHRcdFx0dmFyIGJvdW5kcyA9IGNoaWxkLmdldEJvdW5kcyhjaGlsZE1hdHJpeCk7XG5cdFx0XHRcdFx0aWYgKCFyZWN0LmludGVyc2VjdHMoYm91bmRzKSlcblx0XHRcdFx0XHRcdGNvbnRpbnVlO1xuXHRcdFx0XHRcdGlmICghKHBhcmFtLmluc2lkZSAmJiByZWN0LmNvbnRhaW5zKGJvdW5kcykpXG5cdFx0XHRcdFx0XHRcdCYmICEocGFyYW0ub3ZlcmxhcHBpbmcgJiYgKGJvdW5kcy5jb250YWlucyhyZWN0KVxuXHRcdFx0XHRcdFx0XHRcdHx8IHBhcmFtLnBhdGguaW50ZXJzZWN0cyhjaGlsZCwgY2hpbGRNYXRyaXgpKSkpXG5cdFx0XHRcdFx0XHRhZGQgPSBmYWxzZTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoYWRkICYmIGNoaWxkLm1hdGNoZXMobWF0Y2gpKSB7XG5cdFx0XHRcdFx0aXRlbXMucHVzaChjaGlsZCk7XG5cdFx0XHRcdFx0aWYgKGZpcnN0T25seSlcblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdF9nZXRJdGVtcyhjaGlsZC5fY2hpbGRyZW4sIG1hdGNoLFxuXHRcdFx0XHRcdFx0Y2hpbGRNYXRyaXgsIHBhcmFtLFxuXHRcdFx0XHRcdFx0Zmlyc3RPbmx5KTtcblx0XHRcdFx0aWYgKGZpcnN0T25seSAmJiBpdGVtcy5sZW5ndGggPiAwKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGl0ZW1zO1xuXHRcdH1cblx0fVxufSwge1xuXG5cdGltcG9ydEpTT046IGZ1bmN0aW9uKGpzb24pIHtcblx0XHR2YXIgcmVzID0gQmFzZS5pbXBvcnRKU09OKGpzb24sIHRoaXMpO1xuXHRcdHJldHVybiByZXMgIT09IHRoaXNcblx0XHRcdFx0PyB0aGlzLmFkZENoaWxkKHJlcylcblx0XHRcdFx0OiByZXM7XG5cdH0sXG5cblx0YWRkQ2hpbGQ6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkKHVuZGVmaW5lZCwgaXRlbSwgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRpbnNlcnRDaGlsZDogZnVuY3Rpb24oaW5kZXgsIGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHZhciByZXMgPSBpdGVtID8gdGhpcy5pbnNlcnRDaGlsZHJlbihpbmRleCwgW2l0ZW1dLCBfcHJlc2VydmUpIDogbnVsbDtcblx0XHRyZXR1cm4gcmVzICYmIHJlc1swXTtcblx0fSxcblxuXHRhZGRDaGlsZHJlbjogZnVuY3Rpb24oaXRlbXMsIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiB0aGlzLmluc2VydENoaWxkcmVuKHRoaXMuX2NoaWxkcmVuLmxlbmd0aCwgaXRlbXMsIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0aW5zZXJ0Q2hpbGRyZW46IGZ1bmN0aW9uKGluZGV4LCBpdGVtcywgX3ByZXNlcnZlLCBfcHJvdG8pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4gJiYgaXRlbXMgJiYgaXRlbXMubGVuZ3RoID4gMCkge1xuXHRcdFx0aXRlbXMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuYXBwbHkoaXRlbXMpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGl0ZW1zLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRcdGlmIChfcHJvdG8gJiYgIShpdGVtIGluc3RhbmNlb2YgX3Byb3RvKSkge1xuXHRcdFx0XHRcdGl0ZW1zLnNwbGljZShpLCAxKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgc2hpZnQgPSBpdGVtLl9wYXJlbnQgPT09IHRoaXMgJiYgaXRlbS5faW5kZXggPCBpbmRleDtcblx0XHRcdFx0XHRpZiAoaXRlbS5fcmVtb3ZlKGZhbHNlLCB0cnVlKSAmJiBzaGlmdClcblx0XHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdEJhc2Uuc3BsaWNlKGNoaWxkcmVuLCBpdGVtcywgaW5kZXgsIDApO1xuXHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRub3RpZnlTZWxmID0gcHJvamVjdCAmJiBwcm9qZWN0Ll9jaGFuZ2VzO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBpdGVtcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGl0ZW0gPSBpdGVtc1tpXTtcblx0XHRcdFx0aXRlbS5fcGFyZW50ID0gdGhpcztcblx0XHRcdFx0aXRlbS5fc2V0UHJvamVjdCh0aGlzLl9wcm9qZWN0LCB0cnVlKTtcblx0XHRcdFx0aWYgKGl0ZW0uX25hbWUpXG5cdFx0XHRcdFx0aXRlbS5zZXROYW1lKGl0ZW0uX25hbWUpO1xuXHRcdFx0XHRpZiAobm90aWZ5U2VsZilcblx0XHRcdFx0XHR0aGlzLl9jaGFuZ2VkKDUpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGl0ZW1zID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW1zO1xuXHR9LFxuXG5cdF9pbnNlcnRTaWJsaW5nOiBmdW5jdGlvbihpbmRleCwgaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudFxuXHRcdFx0XHQ/IHRoaXMuX3BhcmVudC5pbnNlcnRDaGlsZChpbmRleCwgaXRlbSwgX3ByZXNlcnZlKVxuXHRcdFx0XHQ6IG51bGw7XG5cdH0sXG5cblx0aW5zZXJ0QWJvdmU6IGZ1bmN0aW9uKGl0ZW0sIF9wcmVzZXJ2ZSkge1xuXHRcdHJldHVybiBpdGVtLl9pbnNlcnRTaWJsaW5nKGl0ZW0uX2luZGV4ICsgMSwgdGhpcywgX3ByZXNlcnZlKTtcblx0fSxcblxuXHRpbnNlcnRCZWxvdzogZnVuY3Rpb24oaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuIGl0ZW0uX2luc2VydFNpYmxpbmcoaXRlbS5faW5kZXgsIHRoaXMsIF9wcmVzZXJ2ZSk7XG5cdH0sXG5cblx0c2VuZFRvQmFjazogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICh0aGlzLl9wYXJlbnQgfHwgdGhpcyBpbnN0YW5jZW9mIExheWVyICYmIHRoaXMuX3Byb2plY3QpXG5cdFx0XHRcdC5pbnNlcnRDaGlsZCgwLCB0aGlzKTtcblx0fSxcblxuXHRicmluZ1RvRnJvbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAodGhpcy5fcGFyZW50IHx8IHRoaXMgaW5zdGFuY2VvZiBMYXllciAmJiB0aGlzLl9wcm9qZWN0KVxuXHRcdFx0XHQuYWRkQ2hpbGQodGhpcyk7XG5cdH0sXG5cblx0YXBwZW5kVG9wOiAnI2FkZENoaWxkJyxcblxuXHRhcHBlbmRCb3R0b206IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5pbnNlcnRDaGlsZCgwLCBpdGVtKTtcblx0fSxcblxuXHRtb3ZlQWJvdmU6ICcjaW5zZXJ0QWJvdmUnLFxuXG5cdG1vdmVCZWxvdzogJyNpbnNlcnRCZWxvdycsXG5cblx0cmVkdWNlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fY2hpbGRyZW4gJiYgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID09PSAxKSB7XG5cdFx0XHR2YXIgY2hpbGQgPSB0aGlzLl9jaGlsZHJlblswXS5yZWR1Y2UoKTtcblx0XHRcdGNoaWxkLmluc2VydEFib3ZlKHRoaXMpO1xuXHRcdFx0Y2hpbGQuc2V0U3R5bGUodGhpcy5fc3R5bGUpO1xuXHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHRcdHJldHVybiBjaGlsZDtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0X3JlbW92ZU5hbWVkOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdHZhciBjaGlsZHJlbiA9IHBhcmVudC5fY2hpbGRyZW4sXG5cdFx0XHRcdG5hbWVkQ2hpbGRyZW4gPSBwYXJlbnQuX25hbWVkQ2hpbGRyZW4sXG5cdFx0XHRcdG5hbWUgPSB0aGlzLl9uYW1lLFxuXHRcdFx0XHRuYW1lZEFycmF5ID0gbmFtZWRDaGlsZHJlbltuYW1lXSxcblx0XHRcdFx0aW5kZXggPSBuYW1lZEFycmF5ID8gbmFtZWRBcnJheS5pbmRleE9mKHRoaXMpIDogLTE7XG5cdFx0XHRpZiAoaW5kZXggIT09IC0xKSB7XG5cdFx0XHRcdGlmIChjaGlsZHJlbltuYW1lXSA9PSB0aGlzKVxuXHRcdFx0XHRcdGRlbGV0ZSBjaGlsZHJlbltuYW1lXTtcblx0XHRcdFx0bmFtZWRBcnJheS5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRpZiAobmFtZWRBcnJheS5sZW5ndGgpIHtcblx0XHRcdFx0XHRjaGlsZHJlbltuYW1lXSA9IG5hbWVkQXJyYXlbbmFtZWRBcnJheS5sZW5ndGggLSAxXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRkZWxldGUgbmFtZWRDaGlsZHJlbltuYW1lXTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRfcmVtb3ZlOiBmdW5jdGlvbihub3RpZnlTZWxmLCBub3RpZnlQYXJlbnQpIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChwYXJlbnQpIHtcblx0XHRcdGlmICh0aGlzLl9uYW1lKVxuXHRcdFx0XHR0aGlzLl9yZW1vdmVOYW1lZCgpO1xuXHRcdFx0aWYgKHRoaXMuX2luZGV4ICE9IG51bGwpXG5cdFx0XHRcdEJhc2Uuc3BsaWNlKHBhcmVudC5fY2hpbGRyZW4sIG51bGwsIHRoaXMuX2luZGV4LCAxKTtcblx0XHRcdHRoaXMuX2luc3RhbGxFdmVudHMoZmFsc2UpO1xuXHRcdFx0aWYgKG5vdGlmeVNlbGYpIHtcblx0XHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0O1xuXHRcdFx0XHRpZiAocHJvamVjdCAmJiBwcm9qZWN0Ll9jaGFuZ2VzKVxuXHRcdFx0XHRcdHRoaXMuX2NoYW5nZWQoNSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAobm90aWZ5UGFyZW50KVxuXHRcdFx0XHRwYXJlbnQuX2NoYW5nZWQoMTEpO1xuXHRcdFx0dGhpcy5fcGFyZW50ID0gbnVsbDtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0cmVtb3ZlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmVtb3ZlKHRydWUsIHRydWUpO1xuXHR9LFxuXG5cdHJlcGxhY2VXaXRoOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dmFyIG9rID0gaXRlbSAmJiBpdGVtLmluc2VydEJlbG93KHRoaXMpO1xuXHRcdGlmIChvaylcblx0XHRcdHRoaXMucmVtb3ZlKCk7XG5cdFx0cmV0dXJuIG9rO1xuXHR9LFxuXG5cdHJlbW92ZUNoaWxkcmVuOiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdGlmICghdGhpcy5fY2hpbGRyZW4pXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRmcm9tID0gZnJvbSB8fCAwO1xuXHRcdHRvID0gQmFzZS5waWNrKHRvLCB0aGlzLl9jaGlsZHJlbi5sZW5ndGgpO1xuXHRcdHZhciByZW1vdmVkID0gQmFzZS5zcGxpY2UodGhpcy5fY2hpbGRyZW4sIG51bGwsIGZyb20sIHRvIC0gZnJvbSk7XG5cdFx0Zm9yICh2YXIgaSA9IHJlbW92ZWQubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHJlbW92ZWRbaV0uX3JlbW92ZSh0cnVlLCBmYWxzZSk7XG5cdFx0fVxuXHRcdGlmIChyZW1vdmVkLmxlbmd0aCA+IDApXG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDExKTtcblx0XHRyZXR1cm4gcmVtb3ZlZDtcblx0fSxcblxuXHRjbGVhcjogJyNyZW1vdmVDaGlsZHJlbicsXG5cblx0cmV2ZXJzZUNoaWxkcmVuOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fY2hpbGRyZW4pIHtcblx0XHRcdHRoaXMuX2NoaWxkcmVuLnJldmVyc2UoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLl9jaGlsZHJlbltpXS5faW5kZXggPSBpO1xuXHRcdFx0dGhpcy5fY2hhbmdlZCgxMSk7XG5cdFx0fVxuXHR9LFxuXG5cdGlzRW1wdHk6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fY2hpbGRyZW4gfHwgdGhpcy5fY2hpbGRyZW4ubGVuZ3RoID09PSAwO1xuXHR9LFxuXG5cdGlzRWRpdGFibGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBpdGVtID0gdGhpcztcblx0XHR3aGlsZSAoaXRlbSkge1xuXHRcdFx0aWYgKCFpdGVtLl92aXNpYmxlIHx8IGl0ZW0uX2xvY2tlZClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0aXRlbSA9IGl0ZW0uX3BhcmVudDtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0aGFzRmlsbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNGaWxsKCk7XG5cdH0sXG5cblx0aGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTdHlsZSgpLmhhc1N0cm9rZSgpO1xuXHR9LFxuXG5cdGhhc1NoYWRvdzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0U3R5bGUoKS5oYXNTaGFkb3coKTtcblx0fSxcblxuXHRfZ2V0T3JkZXI6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRmdW5jdGlvbiBnZXRMaXN0KGl0ZW0pIHtcblx0XHRcdHZhciBsaXN0ID0gW107XG5cdFx0XHRkbyB7XG5cdFx0XHRcdGxpc3QudW5zaGlmdChpdGVtKTtcblx0XHRcdH0gd2hpbGUgKGl0ZW0gPSBpdGVtLl9wYXJlbnQpO1xuXHRcdFx0cmV0dXJuIGxpc3Q7XG5cdFx0fVxuXHRcdHZhciBsaXN0MSA9IGdldExpc3QodGhpcyksXG5cdFx0XHRsaXN0MiA9IGdldExpc3QoaXRlbSk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBNYXRoLm1pbihsaXN0MS5sZW5ndGgsIGxpc3QyLmxlbmd0aCk7IGkgPCBsOyBpKyspIHtcblx0XHRcdGlmIChsaXN0MVtpXSAhPSBsaXN0MltpXSkge1xuXHRcdFx0XHRyZXR1cm4gbGlzdDFbaV0uX2luZGV4IDwgbGlzdDJbaV0uX2luZGV4ID8gMSA6IC0xO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gMDtcblx0fSxcblxuXHRoYXNDaGlsZHJlbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NoaWxkcmVuICYmIHRoaXMuX2NoaWxkcmVuLmxlbmd0aCA+IDA7XG5cdH0sXG5cblx0aXNJbnNlcnRlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IHRoaXMuX3BhcmVudC5pc0luc2VydGVkKCkgOiBmYWxzZTtcblx0fSxcblxuXHRpc0Fib3ZlOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE9yZGVyKGl0ZW0pID09PSAtMTtcblx0fSxcblxuXHRpc0JlbG93OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2dldE9yZGVyKGl0ZW0pID09PSAxO1xuXHR9LFxuXG5cdGlzUGFyZW50OiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA9PT0gaXRlbTtcblx0fSxcblxuXHRpc0NoaWxkOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIGl0ZW0gJiYgaXRlbS5fcGFyZW50ID09PSB0aGlzO1xuXHR9LFxuXG5cdGlzRGVzY2VuZGFudDogZnVuY3Rpb24oaXRlbSkge1xuXHRcdHZhciBwYXJlbnQgPSB0aGlzO1xuXHRcdHdoaWxlIChwYXJlbnQgPSBwYXJlbnQuX3BhcmVudCkge1xuXHRcdFx0aWYgKHBhcmVudCA9PSBpdGVtKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGlzQW5jZXN0b3I6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gaXRlbSA/IGl0ZW0uaXNEZXNjZW5kYW50KHRoaXMpIDogZmFsc2U7XG5cdH0sXG5cblx0aXNTaWJsaW5nOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA9PT0gaXRlbS5fcGFyZW50O1xuXHR9LFxuXG5cdGlzR3JvdXBlZFdpdGg6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdHdoaWxlIChwYXJlbnQpIHtcblx0XHRcdGlmIChwYXJlbnQuX3BhcmVudFxuXHRcdFx0XHQmJiAvXihHcm91cHxMYXllcnxDb21wb3VuZFBhdGgpJC8udGVzdChwYXJlbnQuX2NsYXNzKVxuXHRcdFx0XHQmJiBpdGVtLmlzRGVzY2VuZGFudChwYXJlbnQpKVxuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0cGFyZW50ID0gcGFyZW50Ll9wYXJlbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHR0cmFuc2xhdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBteCA9IG5ldyBNYXRyaXgoKTtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obXgudHJhbnNsYXRlLmFwcGx5KG14LCBhcmd1bWVudHMpKTtcblx0fSxcblxuXHRyb3RhdGU6IGZ1bmN0aW9uKGFuZ2xlICkge1xuXHRcdHJldHVybiB0aGlzLnRyYW5zZm9ybShuZXcgTWF0cml4KCkucm90YXRlKGFuZ2xlLFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cywgMSwgeyByZWFkTnVsbDogdHJ1ZSB9KVxuXHRcdFx0XHRcdHx8IHRoaXMuZ2V0UG9zaXRpb24odHJ1ZSkpKTtcblx0fVxufSwgQmFzZS5lYWNoKFsnc2NhbGUnLCAnc2hlYXInLCAnc2tldyddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjZW50ZXIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRyZXR1cm4gdGhpcy50cmFuc2Zvcm0obmV3IE1hdHJpeCgpW25hbWVdKHBvaW50LFxuXHRcdFx0XHRjZW50ZXIgfHwgdGhpcy5nZXRQb3NpdGlvbih0cnVlKSkpO1xuXHR9O1xufSwge1xuXG59KSwge1xuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCwgX2FwcGx5TWF0cml4LCBfYXBwbHlSZWN1cnNpdmVseSxcblx0XHRcdF9zZXRBcHBseU1hdHJpeCkge1xuXHRcdGlmIChtYXRyaXggJiYgbWF0cml4LmlzSWRlbnRpdHkoKSlcblx0XHRcdG1hdHJpeCA9IG51bGw7XG5cdFx0dmFyIF9tYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRhcHBseU1hdHJpeCA9IChfYXBwbHlNYXRyaXggfHwgdGhpcy5fYXBwbHlNYXRyaXgpXG5cdFx0XHRcdFx0JiYgKCghX21hdHJpeC5pc0lkZW50aXR5KCkgfHwgbWF0cml4KVxuXHRcdFx0XHRcdFx0fHwgX2FwcGx5TWF0cml4ICYmIF9hcHBseVJlY3Vyc2l2ZWx5ICYmIHRoaXMuX2NoaWxkcmVuKTtcblx0XHRpZiAoIW1hdHJpeCAmJiAhYXBwbHlNYXRyaXgpXG5cdFx0XHRyZXR1cm4gdGhpcztcblx0XHRpZiAobWF0cml4KVxuXHRcdFx0X21hdHJpeC5wcmVDb25jYXRlbmF0ZShtYXRyaXgpO1xuXHRcdGlmIChhcHBseU1hdHJpeCA9IGFwcGx5TWF0cml4ICYmIHRoaXMuX3RyYW5zZm9ybUNvbnRlbnQoX21hdHJpeCxcblx0XHRcdFx0XHRfYXBwbHlSZWN1cnNpdmVseSwgX3NldEFwcGx5TWF0cml4KSkge1xuXHRcdFx0dmFyIHBpdm90ID0gdGhpcy5fcGl2b3QsXG5cdFx0XHRcdHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRcdGZpbGxDb2xvciA9IHN0eWxlLmdldEZpbGxDb2xvcih0cnVlKSxcblx0XHRcdFx0c3Ryb2tlQ29sb3IgPSBzdHlsZS5nZXRTdHJva2VDb2xvcih0cnVlKTtcblx0XHRcdGlmIChwaXZvdClcblx0XHRcdFx0X21hdHJpeC5fdHJhbnNmb3JtUG9pbnQocGl2b3QsIHBpdm90LCB0cnVlKTtcblx0XHRcdGlmIChmaWxsQ29sb3IpXG5cdFx0XHRcdGZpbGxDb2xvci50cmFuc2Zvcm0oX21hdHJpeCk7XG5cdFx0XHRpZiAoc3Ryb2tlQ29sb3IpXG5cdFx0XHRcdHN0cm9rZUNvbG9yLnRyYW5zZm9ybShfbWF0cml4KTtcblx0XHRcdF9tYXRyaXgucmVzZXQodHJ1ZSk7XG5cdFx0XHRpZiAoX3NldEFwcGx5TWF0cml4ICYmIHRoaXMuX2NhbkFwcGx5TWF0cml4KVxuXHRcdFx0XHR0aGlzLl9hcHBseU1hdHJpeCA9IHRydWU7XG5cdFx0fVxuXHRcdHZhciBib3VuZHMgPSB0aGlzLl9ib3VuZHMsXG5cdFx0XHRwb3NpdGlvbiA9IHRoaXMuX3Bvc2l0aW9uO1xuXHRcdHRoaXMuX2NoYW5nZWQoOSk7XG5cdFx0dmFyIGRlY29tcCA9IGJvdW5kcyAmJiBtYXRyaXggJiYgbWF0cml4LmRlY29tcG9zZSgpO1xuXHRcdGlmIChkZWNvbXAgJiYgIWRlY29tcC5zaGVhcmluZyAmJiBkZWNvbXAucm90YXRpb24gJSA5MCA9PT0gMCkge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIGJvdW5kcykge1xuXHRcdFx0XHR2YXIgcmVjdCA9IGJvdW5kc1trZXldO1xuXHRcdFx0XHRpZiAoYXBwbHlNYXRyaXggfHwgIXJlY3QuX2ludGVybmFsKVxuXHRcdFx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QsIHJlY3QpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGdldHRlciA9IHRoaXMuX2JvdW5kc0dldHRlcixcblx0XHRcdFx0cmVjdCA9IGJvdW5kc1tnZXR0ZXIgJiYgZ2V0dGVyLmdldEJvdW5kcyB8fCBnZXR0ZXIgfHwgJ2dldEJvdW5kcyddO1xuXHRcdFx0aWYgKHJlY3QpXG5cdFx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gcmVjdC5nZXRDZW50ZXIodHJ1ZSk7XG5cdFx0XHR0aGlzLl9ib3VuZHMgPSBib3VuZHM7XG5cdFx0fSBlbHNlIGlmIChtYXRyaXggJiYgcG9zaXRpb24pIHtcblx0XHRcdHRoaXMuX3Bvc2l0aW9uID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb3NpdGlvbiwgcG9zaXRpb24pO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRfdHJhbnNmb3JtQ29udGVudDogZnVuY3Rpb24obWF0cml4LCBhcHBseVJlY3Vyc2l2ZWx5LCBzZXRBcHBseU1hdHJpeCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuO1xuXHRcdGlmIChjaGlsZHJlbikge1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGNoaWxkcmVuW2ldLnRyYW5zZm9ybShtYXRyaXgsIHRydWUsIGFwcGx5UmVjdXJzaXZlbHksXG5cdFx0XHRcdFx0XHRzZXRBcHBseU1hdHJpeCk7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdH0sXG5cblx0Z2xvYmFsVG9Mb2NhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0R2xvYmFsTWF0cml4KHRydWUpLl9pbnZlcnNlVHJhbnNmb3JtKFxuXHRcdFx0XHRQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGxvY2FsVG9HbG9iYWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEdsb2JhbE1hdHJpeCh0cnVlKS5fdHJhbnNmb3JtUG9pbnQoXG5cdFx0XHRcdFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0cGFyZW50VG9Mb2NhbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5faW52ZXJzZVRyYW5zZm9ybShQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdGxvY2FsVG9QYXJlbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXRyaXguX3RyYW5zZm9ybVBvaW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Zml0Qm91bmRzOiBmdW5jdGlvbihyZWN0YW5nbGUsIGZpbGwpIHtcblx0XHRyZWN0YW5nbGUgPSBSZWN0YW5nbGUucmVhZChhcmd1bWVudHMpO1xuXHRcdHZhciBib3VuZHMgPSB0aGlzLmdldEJvdW5kcygpLFxuXHRcdFx0aXRlbVJhdGlvID0gYm91bmRzLmhlaWdodCAvIGJvdW5kcy53aWR0aCxcblx0XHRcdHJlY3RSYXRpbyA9IHJlY3RhbmdsZS5oZWlnaHQgLyByZWN0YW5nbGUud2lkdGgsXG5cdFx0XHRzY2FsZSA9IChmaWxsID8gaXRlbVJhdGlvID4gcmVjdFJhdGlvIDogaXRlbVJhdGlvIDwgcmVjdFJhdGlvKVxuXHRcdFx0XHRcdD8gcmVjdGFuZ2xlLndpZHRoIC8gYm91bmRzLndpZHRoXG5cdFx0XHRcdFx0OiByZWN0YW5nbGUuaGVpZ2h0IC8gYm91bmRzLmhlaWdodCxcblx0XHRcdG5ld0JvdW5kcyA9IG5ldyBSZWN0YW5nbGUobmV3IFBvaW50KCksXG5cdFx0XHRcdFx0bmV3IFNpemUoYm91bmRzLndpZHRoICogc2NhbGUsIGJvdW5kcy5oZWlnaHQgKiBzY2FsZSkpO1xuXHRcdG5ld0JvdW5kcy5zZXRDZW50ZXIocmVjdGFuZ2xlLmdldENlbnRlcigpKTtcblx0XHR0aGlzLnNldEJvdW5kcyhuZXdCb3VuZHMpO1xuXHR9LFxuXG5cdF9zZXRTdHlsZXM6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlLFxuXHRcdFx0ZmlsbENvbG9yID0gc3R5bGUuZ2V0RmlsbENvbG9yKCksXG5cdFx0XHRzdHJva2VDb2xvciA9IHN0eWxlLmdldFN0cm9rZUNvbG9yKCksXG5cdFx0XHRzaGFkb3dDb2xvciA9IHN0eWxlLmdldFNoYWRvd0NvbG9yKCk7XG5cdFx0aWYgKGZpbGxDb2xvcilcblx0XHRcdGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3IudG9DYW52YXNTdHlsZShjdHgpO1xuXHRcdGlmIChzdHJva2VDb2xvcikge1xuXHRcdFx0dmFyIHN0cm9rZVdpZHRoID0gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKTtcblx0XHRcdGlmIChzdHJva2VXaWR0aCA+IDApIHtcblx0XHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gc3Ryb2tlQ29sb3IudG9DYW52YXNTdHlsZShjdHgpO1xuXHRcdFx0XHRjdHgubGluZVdpZHRoID0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdHZhciBzdHJva2VKb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpLFxuXHRcdFx0XHRcdHN0cm9rZUNhcCA9IHN0eWxlLmdldFN0cm9rZUNhcCgpLFxuXHRcdFx0XHRcdG1pdGVyTGltaXQgPSBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG5cdFx0XHRcdGlmIChzdHJva2VKb2luKVxuXHRcdFx0XHRcdGN0eC5saW5lSm9pbiA9IHN0cm9rZUpvaW47XG5cdFx0XHRcdGlmIChzdHJva2VDYXApXG5cdFx0XHRcdFx0Y3R4LmxpbmVDYXAgPSBzdHJva2VDYXA7XG5cdFx0XHRcdGlmIChtaXRlckxpbWl0KVxuXHRcdFx0XHRcdGN0eC5taXRlckxpbWl0ID0gbWl0ZXJMaW1pdDtcblx0XHRcdFx0aWYgKHBhcGVyLnN1cHBvcnQubmF0aXZlRGFzaCkge1xuXHRcdFx0XHRcdHZhciBkYXNoQXJyYXkgPSBzdHlsZS5nZXREYXNoQXJyYXkoKSxcblx0XHRcdFx0XHRcdGRhc2hPZmZzZXQgPSBzdHlsZS5nZXREYXNoT2Zmc2V0KCk7XG5cdFx0XHRcdFx0aWYgKGRhc2hBcnJheSAmJiBkYXNoQXJyYXkubGVuZ3RoKSB7XG5cdFx0XHRcdFx0XHRpZiAoJ3NldExpbmVEYXNoJyBpbiBjdHgpIHtcblx0XHRcdFx0XHRcdFx0Y3R4LnNldExpbmVEYXNoKGRhc2hBcnJheSk7XG5cdFx0XHRcdFx0XHRcdGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hPZmZzZXQ7XG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0XHRjdHgubW96RGFzaCA9IGRhc2hBcnJheTtcblx0XHRcdFx0XHRcdFx0Y3R4Lm1vekRhc2hPZmZzZXQgPSBkYXNoT2Zmc2V0O1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoc2hhZG93Q29sb3IpIHtcblx0XHRcdHZhciBzaGFkb3dCbHVyID0gc3R5bGUuZ2V0U2hhZG93Qmx1cigpO1xuXHRcdFx0aWYgKHNoYWRvd0JsdXIgPiAwKSB7XG5cdFx0XHRcdGN0eC5zaGFkb3dDb2xvciA9IHNoYWRvd0NvbG9yLnRvQ2FudmFzU3R5bGUoY3R4KTtcblx0XHRcdFx0Y3R4LnNoYWRvd0JsdXIgPSBzaGFkb3dCbHVyO1xuXHRcdFx0XHR2YXIgb2Zmc2V0ID0gdGhpcy5nZXRTaGFkb3dPZmZzZXQoKTtcblx0XHRcdFx0Y3R4LnNoYWRvd09mZnNldFggPSBvZmZzZXQueDtcblx0XHRcdFx0Y3R4LnNoYWRvd09mZnNldFkgPSBvZmZzZXQueTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0ZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSwgcGFyZW50U3Ryb2tlTWF0cml4KSB7XG5cdFx0dmFyIHVwZGF0ZVZlcnNpb24gPSB0aGlzLl91cGRhdGVWZXJzaW9uID0gdGhpcy5fcHJvamVjdC5fdXBkYXRlVmVyc2lvbjtcblx0XHRpZiAoIXRoaXMuX3Zpc2libGUgfHwgdGhpcy5fb3BhY2l0eSA9PT0gMClcblx0XHRcdHJldHVybjtcblx0XHR2YXIgbWF0cmljZXMgPSBwYXJhbS5tYXRyaWNlcyxcblx0XHRcdHZpZXdNYXRyaXggPSBwYXJhbS52aWV3TWF0cml4LFxuXHRcdFx0bWF0cml4ID0gdGhpcy5fbWF0cml4LFxuXHRcdFx0Z2xvYmFsTWF0cml4ID0gbWF0cmljZXNbbWF0cmljZXMubGVuZ3RoIC0gMV0uY2hhaW4obWF0cml4KTtcblx0XHRpZiAoIWdsb2JhbE1hdHJpeC5pc0ludmVydGlibGUoKSlcblx0XHRcdHJldHVybjtcblxuXHRcdGZ1bmN0aW9uIGdldFZpZXdNYXRyaXgobWF0cml4KSB7XG5cdFx0XHRyZXR1cm4gdmlld01hdHJpeCA/IHZpZXdNYXRyaXguY2hhaW4obWF0cml4KSA6IG1hdHJpeDtcblx0XHR9XG5cblx0XHRtYXRyaWNlcy5wdXNoKGdsb2JhbE1hdHJpeCk7XG5cdFx0aWYgKHBhcmFtLnVwZGF0ZU1hdHJpeCkge1xuXHRcdFx0Z2xvYmFsTWF0cml4Ll91cGRhdGVWZXJzaW9uID0gdXBkYXRlVmVyc2lvbjtcblx0XHRcdHRoaXMuX2dsb2JhbE1hdHJpeCA9IGdsb2JhbE1hdHJpeDtcblx0XHR9XG5cblx0XHR2YXIgYmxlbmRNb2RlID0gdGhpcy5fYmxlbmRNb2RlLFxuXHRcdFx0b3BhY2l0eSA9IHRoaXMuX29wYWNpdHksXG5cdFx0XHRub3JtYWxCbGVuZCA9IGJsZW5kTW9kZSA9PT0gJ25vcm1hbCcsXG5cdFx0XHRuYXRpdmVCbGVuZCA9IEJsZW5kTW9kZS5uYXRpdmVNb2Rlc1tibGVuZE1vZGVdLFxuXHRcdFx0ZGlyZWN0ID0gbm9ybWFsQmxlbmQgJiYgb3BhY2l0eSA9PT0gMVxuXHRcdFx0XHRcdHx8IHBhcmFtLmRvbnRTdGFydFxuXHRcdFx0XHRcdHx8IHBhcmFtLmNsaXBcblx0XHRcdFx0XHR8fCAobmF0aXZlQmxlbmQgfHwgbm9ybWFsQmxlbmQgJiYgb3BhY2l0eSA8IDEpXG5cdFx0XHRcdFx0XHQmJiB0aGlzLl9jYW5Db21wb3NpdGUoKSxcblx0XHRcdHBpeGVsUmF0aW8gPSBwYXJhbS5waXhlbFJhdGlvIHx8IDEsXG5cdFx0XHRtYWluQ3R4LCBpdGVtT2Zmc2V0LCBwcmV2T2Zmc2V0O1xuXHRcdGlmICghZGlyZWN0KSB7XG5cdFx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRTdHJva2VCb3VuZHMoZ2V0Vmlld01hdHJpeChnbG9iYWxNYXRyaXgpKTtcblx0XHRcdGlmICghYm91bmRzLndpZHRoIHx8ICFib3VuZHMuaGVpZ2h0KVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRwcmV2T2Zmc2V0ID0gcGFyYW0ub2Zmc2V0O1xuXHRcdFx0aXRlbU9mZnNldCA9IHBhcmFtLm9mZnNldCA9IGJvdW5kcy5nZXRUb3BMZWZ0KCkuZmxvb3IoKTtcblx0XHRcdG1haW5DdHggPSBjdHg7XG5cdFx0XHRjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KGJvdW5kcy5nZXRTaXplKCkuY2VpbCgpLmFkZCgxKVxuXHRcdFx0XHRcdC5tdWx0aXBseShwaXhlbFJhdGlvKSk7XG5cdFx0XHRpZiAocGl4ZWxSYXRpbyAhPT0gMSlcblx0XHRcdFx0Y3R4LnNjYWxlKHBpeGVsUmF0aW8sIHBpeGVsUmF0aW8pO1xuXHRcdH1cblx0XHRjdHguc2F2ZSgpO1xuXHRcdHZhciBzdHJva2VNYXRyaXggPSBwYXJlbnRTdHJva2VNYXRyaXhcblx0XHRcdFx0PyBwYXJlbnRTdHJva2VNYXRyaXguY2hhaW4obWF0cml4KVxuXHRcdFx0XHQ6ICF0aGlzLmdldFN0cm9rZVNjYWxpbmcodHJ1ZSkgJiYgZ2V0Vmlld01hdHJpeChnbG9iYWxNYXRyaXgpLFxuXHRcdFx0Y2xpcCA9ICFkaXJlY3QgJiYgcGFyYW0uY2xpcEl0ZW0sXG5cdFx0XHR0cmFuc2Zvcm0gPSAhc3Ryb2tlTWF0cml4IHx8IGNsaXA7XG5cdFx0aWYgKGRpcmVjdCkge1xuXHRcdFx0Y3R4Lmdsb2JhbEFscGhhID0gb3BhY2l0eTtcblx0XHRcdGlmIChuYXRpdmVCbGVuZClcblx0XHRcdFx0Y3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9IGJsZW5kTW9kZTtcblx0XHR9IGVsc2UgaWYgKHRyYW5zZm9ybSkge1xuXHRcdFx0Y3R4LnRyYW5zbGF0ZSgtaXRlbU9mZnNldC54LCAtaXRlbU9mZnNldC55KTtcblx0XHR9XG5cdFx0aWYgKHRyYW5zZm9ybSlcblx0XHRcdChkaXJlY3QgPyBtYXRyaXggOiBnZXRWaWV3TWF0cml4KGdsb2JhbE1hdHJpeCkpLmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0aWYgKGNsaXApXG5cdFx0XHRwYXJhbS5jbGlwSXRlbS5kcmF3KGN0eCwgcGFyYW0uZXh0ZW5kKHsgY2xpcDogdHJ1ZSB9KSk7XG5cdFx0aWYgKHN0cm9rZU1hdHJpeCkge1xuXHRcdFx0Y3R4LnNldFRyYW5zZm9ybShwaXhlbFJhdGlvLCAwLCAwLCBwaXhlbFJhdGlvLCAwLCAwKTtcblx0XHRcdHZhciBvZmZzZXQgPSBwYXJhbS5vZmZzZXQ7XG5cdFx0XHRpZiAob2Zmc2V0KVxuXHRcdFx0XHRjdHgudHJhbnNsYXRlKC1vZmZzZXQueCwgLW9mZnNldC55KTtcblx0XHR9XG5cdFx0dGhpcy5fZHJhdyhjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0bWF0cmljZXMucG9wKCk7XG5cdFx0aWYgKHBhcmFtLmNsaXAgJiYgIXBhcmFtLmRvbnRGaW5pc2gpXG5cdFx0XHRjdHguY2xpcCgpO1xuXHRcdGlmICghZGlyZWN0KSB7XG5cdFx0XHRCbGVuZE1vZGUucHJvY2VzcyhibGVuZE1vZGUsIGN0eCwgbWFpbkN0eCwgb3BhY2l0eSxcblx0XHRcdFx0XHRpdGVtT2Zmc2V0LnN1YnRyYWN0KHByZXZPZmZzZXQpLm11bHRpcGx5KHBpeGVsUmF0aW8pKTtcblx0XHRcdENhbnZhc1Byb3ZpZGVyLnJlbGVhc2UoY3R4KTtcblx0XHRcdHBhcmFtLm9mZnNldCA9IHByZXZPZmZzZXQ7XG5cdFx0fVxuXHR9LFxuXG5cdF9pc1VwZGF0ZWQ6IGZ1bmN0aW9uKHVwZGF0ZVZlcnNpb24pIHtcblx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdGlmIChwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpXG5cdFx0XHRyZXR1cm4gcGFyZW50Ll9pc1VwZGF0ZWQodXBkYXRlVmVyc2lvbik7XG5cdFx0dmFyIHVwZGF0ZWQgPSB0aGlzLl91cGRhdGVWZXJzaW9uID09PSB1cGRhdGVWZXJzaW9uO1xuXHRcdGlmICghdXBkYXRlZCAmJiBwYXJlbnQgJiYgcGFyZW50Ll92aXNpYmxlXG5cdFx0XHRcdCYmIHBhcmVudC5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pKSB7XG5cdFx0XHR0aGlzLl91cGRhdGVWZXJzaW9uID0gdXBkYXRlVmVyc2lvbjtcblx0XHRcdHVwZGF0ZWQgPSB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gdXBkYXRlZDtcblx0fSxcblxuXHRfZHJhd1NlbGVjdGlvbjogZnVuY3Rpb24oY3R4LCBtYXRyaXgsIHNpemUsIHNlbGVjdGVkSXRlbXMsIHVwZGF0ZVZlcnNpb24pIHtcblx0XHRpZiAoKHRoaXMuX2RyYXdTZWxlY3RlZCB8fCB0aGlzLl9ib3VuZHNTZWxlY3RlZClcblx0XHRcdFx0JiYgdGhpcy5faXNVcGRhdGVkKHVwZGF0ZVZlcnNpb24pKSB7XG5cdFx0XHR2YXIgY29sb3IgPSB0aGlzLmdldFNlbGVjdGVkQ29sb3IodHJ1ZSlcblx0XHRcdFx0XHR8fCB0aGlzLmdldExheWVyKCkuZ2V0U2VsZWN0ZWRDb2xvcih0cnVlKSxcblx0XHRcdFx0bXggPSBtYXRyaXguY2hhaW4odGhpcy5nZXRHbG9iYWxNYXRyaXgodHJ1ZSkpO1xuXHRcdFx0Y3R4LnN0cm9rZVN0eWxlID0gY3R4LmZpbGxTdHlsZSA9IGNvbG9yXG5cdFx0XHRcdFx0PyBjb2xvci50b0NhbnZhc1N0eWxlKGN0eCkgOiAnIzAwOWRlYyc7XG5cdFx0XHRpZiAodGhpcy5fZHJhd1NlbGVjdGVkKVxuXHRcdFx0XHR0aGlzLl9kcmF3U2VsZWN0ZWQoY3R4LCBteCwgc2VsZWN0ZWRJdGVtcyk7XG5cdFx0XHRpZiAodGhpcy5fYm91bmRzU2VsZWN0ZWQpIHtcblx0XHRcdFx0dmFyIGhhbGYgPSBzaXplIC8gMixcblx0XHRcdFx0XHRjb29yZHMgPSBteC5fdHJhbnNmb3JtQ29ybmVycyh0aGlzLmdldEludGVybmFsQm91bmRzKCkpO1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgODsgaSsrKVxuXHRcdFx0XHRcdGN0eFtpID09PSAwID8gJ21vdmVUbycgOiAnbGluZVRvJ10oY29vcmRzW2ldLCBjb29yZHNbKytpXSk7XG5cdFx0XHRcdGN0eC5jbG9zZVBhdGgoKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDg7IGkrKylcblx0XHRcdFx0XHRjdHguZmlsbFJlY3QoY29vcmRzW2ldIC0gaGFsZiwgY29vcmRzWysraV0gLSBoYWxmLFxuXHRcdFx0XHRcdFx0XHRzaXplLCBzaXplKTtcblx0XHRcdH1cblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG59LCBCYXNlLmVhY2goWydkb3duJywgJ2RyYWcnLCAndXAnLCAnbW92ZSddLCBmdW5jdGlvbihuYW1lKSB7XG5cdHRoaXNbJ3JlbW92ZU9uJyArIEJhc2UuY2FwaXRhbGl6ZShuYW1lKV0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFzaCA9IHt9O1xuXHRcdGhhc2hbbmFtZV0gPSB0cnVlO1xuXHRcdHJldHVybiB0aGlzLnJlbW92ZU9uKGhhc2gpO1xuXHR9O1xufSwge1xuXG5cdHJlbW92ZU9uOiBmdW5jdGlvbihvYmopIHtcblx0XHRmb3IgKHZhciBuYW1lIGluIG9iaikge1xuXHRcdFx0aWYgKG9ialtuYW1lXSkge1xuXHRcdFx0XHR2YXIga2V5ID0gJ21vdXNlJyArIG5hbWUsXG5cdFx0XHRcdFx0cHJvamVjdCA9IHRoaXMuX3Byb2plY3QsXG5cdFx0XHRcdFx0c2V0cyA9IHByb2plY3QuX3JlbW92ZVNldHMgPSBwcm9qZWN0Ll9yZW1vdmVTZXRzIHx8IHt9O1xuXHRcdFx0XHRzZXRzW2tleV0gPSBzZXRzW2tleV0gfHwge307XG5cdFx0XHRcdHNldHNba2V5XVt0aGlzLl9pZF0gPSB0aGlzO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fVxufSkpO1xuXG52YXIgR3JvdXAgPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyb3VwJyxcblx0X3NlbGVjdENoaWxkcmVuOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y2hpbGRyZW46IFtdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gR3JvdXAoYXJnKSB7XG5cdFx0dGhpcy5fY2hpbGRyZW4gPSBbXTtcblx0XHR0aGlzLl9uYW1lZENoaWxkcmVuID0ge307XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZykpXG5cdFx0XHR0aGlzLmFkZENoaWxkcmVuKEFycmF5LmlzQXJyYXkoYXJnKSA/IGFyZyA6IGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiAxMDI2KSB7XG5cdFx0XHR0aGlzLl9jbGlwSXRlbSA9IHVuZGVmaW5lZDtcblx0XHR9XG5cdH0sXG5cblx0X2dldENsaXBJdGVtOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2xpcEl0ZW0gPSB0aGlzLl9jbGlwSXRlbTtcblx0XHRpZiAoY2xpcEl0ZW0gPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0Y2xpcEl0ZW0gPSBudWxsO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkID0gdGhpcy5fY2hpbGRyZW5baV07XG5cdFx0XHRcdGlmIChjaGlsZC5fY2xpcE1hc2spIHtcblx0XHRcdFx0XHRjbGlwSXRlbSA9IGNoaWxkO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR0aGlzLl9jbGlwSXRlbSA9IGNsaXBJdGVtO1xuXHRcdH1cblx0XHRyZXR1cm4gY2xpcEl0ZW07XG5cdH0sXG5cblx0aXNDbGlwcGVkOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLl9nZXRDbGlwSXRlbSgpO1xuXHR9LFxuXG5cdHNldENsaXBwZWQ6IGZ1bmN0aW9uKGNsaXBwZWQpIHtcblx0XHR2YXIgY2hpbGQgPSB0aGlzLmdldEZpcnN0Q2hpbGQoKTtcblx0XHRpZiAoY2hpbGQpXG5cdFx0XHRjaGlsZC5zZXRDbGlwTWFzayhjbGlwcGVkKTtcblx0fSxcblxuXHRfZHJhdzogZnVuY3Rpb24oY3R4LCBwYXJhbSkge1xuXHRcdHZhciBjbGlwID0gcGFyYW0uY2xpcCxcblx0XHRcdGNsaXBJdGVtID0gIWNsaXAgJiYgdGhpcy5fZ2V0Q2xpcEl0ZW0oKSxcblx0XHRcdGRyYXcgPSB0cnVlO1xuXHRcdHBhcmFtID0gcGFyYW0uZXh0ZW5kKHsgY2xpcEl0ZW06IGNsaXBJdGVtLCBjbGlwOiBmYWxzZSB9KTtcblx0XHRpZiAoY2xpcCkge1xuXHRcdFx0aWYgKHRoaXMuX2N1cnJlbnRQYXRoKSB7XG5cdFx0XHRcdGN0eC5jdXJyZW50UGF0aCA9IHRoaXMuX2N1cnJlbnRQYXRoO1xuXHRcdFx0XHRkcmF3ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdHBhcmFtLmRvbnRTdGFydCA9IHBhcmFtLmRvbnRGaW5pc2ggPSB0cnVlO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY2xpcEl0ZW0pIHtcblx0XHRcdGNsaXBJdGVtLmRyYXcoY3R4LCBwYXJhbS5leHRlbmQoeyBjbGlwOiB0cnVlIH0pKTtcblx0XHR9XG5cdFx0aWYgKGRyYXcpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpdGVtID0gdGhpcy5fY2hpbGRyZW5baV07XG5cdFx0XHRcdGlmIChpdGVtICE9PSBjbGlwSXRlbSlcblx0XHRcdFx0XHRpdGVtLmRyYXcoY3R4LCBwYXJhbSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmIChjbGlwKSB7XG5cdFx0XHR0aGlzLl9jdXJyZW50UGF0aCA9IGN0eC5jdXJyZW50UGF0aDtcblx0XHR9XG5cdH1cbn0pO1xuXG52YXIgTGF5ZXIgPSBHcm91cC5leHRlbmQoe1xuXHRfY2xhc3M6ICdMYXllcicsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gTGF5ZXIoYXJnKSB7XG5cdFx0dmFyIHByb3BzID0gQmFzZS5pc1BsYWluT2JqZWN0KGFyZylcblx0XHRcdFx0PyBuZXcgQmFzZShhcmcpXG5cdFx0XHRcdDogeyBjaGlsZHJlbjogQXJyYXkuaXNBcnJheShhcmcpID8gYXJnIDogYXJndW1lbnRzIH0sXG5cdFx0XHRpbnNlcnQgPSBwcm9wcy5pbnNlcnQ7XG5cdFx0cHJvcHMuaW5zZXJ0ID0gZmFsc2U7XG5cdFx0R3JvdXAuY2FsbCh0aGlzLCBwcm9wcyk7XG5cdFx0aWYgKGluc2VydCB8fCBpbnNlcnQgPT09IHVuZGVmaW5lZCkge1xuXHRcdFx0dGhpcy5fcHJvamVjdC5hZGRDaGlsZCh0aGlzKTtcblx0XHRcdHRoaXMuYWN0aXZhdGUoKTtcblx0XHR9XG5cdH0sXG5cblx0X3JlbW92ZTogZnVuY3Rpb24gX3JlbW92ZShub3RpZnlTZWxmLCBub3RpZnlQYXJlbnQpIHtcblx0XHRpZiAodGhpcy5fcGFyZW50KVxuXHRcdFx0cmV0dXJuIF9yZW1vdmUuYmFzZS5jYWxsKHRoaXMsIG5vdGlmeVNlbGYsIG5vdGlmeVBhcmVudCk7XG5cdFx0aWYgKHRoaXMuX2luZGV4ICE9IG51bGwpIHtcblx0XHRcdHZhciBwcm9qZWN0ID0gdGhpcy5fcHJvamVjdDtcblx0XHRcdGlmIChwcm9qZWN0Ll9hY3RpdmVMYXllciA9PT0gdGhpcylcblx0XHRcdFx0cHJvamVjdC5fYWN0aXZlTGF5ZXIgPSB0aGlzLmdldE5leHRTaWJsaW5nKClcblx0XHRcdFx0XHRcdHx8IHRoaXMuZ2V0UHJldmlvdXNTaWJsaW5nKCk7XG5cdFx0XHRCYXNlLnNwbGljZShwcm9qZWN0LmxheWVycywgbnVsbCwgdGhpcy5faW5kZXgsIDEpO1xuXHRcdFx0dGhpcy5faW5zdGFsbEV2ZW50cyhmYWxzZSk7XG5cdFx0XHRpZiAobm90aWZ5U2VsZiAmJiBwcm9qZWN0Ll9jaGFuZ2VzKVxuXHRcdFx0XHR0aGlzLl9jaGFuZ2VkKDUpO1xuXHRcdFx0aWYgKG5vdGlmeVBhcmVudCkge1xuXHRcdFx0XHRwcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGdldE5leHRTaWJsaW5nOiBmdW5jdGlvbiBnZXROZXh0U2libGluZygpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGFyZW50ID8gZ2V0TmV4dFNpYmxpbmcuYmFzZS5jYWxsKHRoaXMpXG5cdFx0XHRcdDogdGhpcy5fcHJvamVjdC5sYXllcnNbdGhpcy5faW5kZXggKyAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGdldFByZXZpb3VzU2libGluZzogZnVuY3Rpb24gZ2V0UHJldmlvdXNTaWJsaW5nKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXJlbnQgPyBnZXRQcmV2aW91c1NpYmxpbmcuYmFzZS5jYWxsKHRoaXMpXG5cdFx0XHRcdDogdGhpcy5fcHJvamVjdC5sYXllcnNbdGhpcy5faW5kZXggLSAxXSB8fCBudWxsO1xuXHR9LFxuXG5cdGlzSW5zZXJ0ZWQ6IGZ1bmN0aW9uIGlzSW5zZXJ0ZWQoKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BhcmVudCA/IGlzSW5zZXJ0ZWQuYmFzZS5jYWxsKHRoaXMpIDogdGhpcy5faW5kZXggIT0gbnVsbDtcblx0fSxcblxuXHRhY3RpdmF0ZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fcHJvamVjdC5fYWN0aXZlTGF5ZXIgPSB0aGlzO1xuXHR9LFxuXG5cdF9pbnNlcnRTaWJsaW5nOiBmdW5jdGlvbiBfaW5zZXJ0U2libGluZyhpbmRleCwgaXRlbSwgX3ByZXNlcnZlKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9wYXJlbnRcblx0XHRcdFx0PyB0aGlzLl9wcm9qZWN0Lmluc2VydENoaWxkKGluZGV4LCBpdGVtLCBfcHJlc2VydmUpXG5cdFx0XHRcdDogX2luc2VydFNpYmxpbmcuYmFzZS5jYWxsKHRoaXMsIGluZGV4LCBpdGVtLCBfcHJlc2VydmUpO1xuXHR9XG59KTtcblxudmFyIFNoYXBlID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTaGFwZScsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9ib3VuZHNTZWxlY3RlZDogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHR5cGU6IG51bGwsXG5cdFx0c2l6ZTogbnVsbCxcblx0XHRyYWRpdXM6IG51bGxcblx0fSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBTaGFwZShwcm9wcykge1xuXHRcdHRoaXMuX2luaXRpYWxpemUocHJvcHMpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gaXRlbS5fdHlwZVxuXHRcdFx0JiYgdGhpcy5fc2l6ZS5lcXVhbHMoaXRlbS5fc2l6ZSlcblx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3JhZGl1cywgaXRlbS5fcmFkaXVzKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgU2hhcGUoSXRlbS5OT19JTlNFUlQpO1xuXHRcdGNvcHkuc2V0VHlwZSh0aGlzLl90eXBlKTtcblx0XHRjb3B5LnNldFNpemUodGhpcy5fc2l6ZSk7XG5cdFx0Y29weS5zZXRSYWRpdXModGhpcy5fcmFkaXVzKTtcblx0XHRyZXR1cm4gdGhpcy5fY2xvbmUoY29weSwgaW5zZXJ0KTtcblx0fSxcblxuXHRnZXRUeXBlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fdHlwZTtcblx0fSxcblxuXHRzZXRUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0dGhpcy5fdHlwZSA9IHR5cGU7XG5cdH0sXG5cblx0Z2V0U2hhcGU6ICcjZ2V0VHlwZScsXG5cdHNldFNoYXBlOiAnI3NldFR5cGUnLFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHRoaXMsICdzZXRTaXplJyk7XG5cdH0sXG5cblx0c2V0U2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRpZiAoIXRoaXMuX3NpemUpIHtcblx0XHRcdHRoaXMuX3NpemUgPSBzaXplLmNsb25lKCk7XG5cdFx0fSBlbHNlIGlmICghdGhpcy5fc2l6ZS5lcXVhbHMoc2l6ZSkpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0XHRoZWlnaHQgPSBzaXplLmhlaWdodDtcblx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHR2YXIgcmFkaXVzID0gU2l6ZS5taW4odGhpcy5fcmFkaXVzLCBzaXplLmRpdmlkZSgyKSk7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5zZXQocmFkaXVzLndpZHRoLCByYWRpdXMuaGVpZ2h0KTtcblx0XHRcdH0gZWxzZSBpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdFx0d2lkdGggPSBoZWlnaHQgPSAod2lkdGggKyBoZWlnaHQpIC8gMjtcblx0XHRcdFx0dGhpcy5fcmFkaXVzID0gd2lkdGggLyAyO1xuXHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZWxsaXBzZScpIHtcblx0XHRcdFx0dGhpcy5fcmFkaXVzLnNldCh3aWR0aCAvIDIsIGhlaWdodCAvIDIpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2l6ZS5zZXQod2lkdGgsIGhlaWdodCk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHRcdH1cblx0fSxcblxuXHRnZXRSYWRpdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByYWQgPSB0aGlzLl9yYWRpdXM7XG5cdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09ICdjaXJjbGUnXG5cdFx0XHRcdD8gcmFkXG5cdFx0XHRcdDogbmV3IExpbmtlZFNpemUocmFkLndpZHRoLCByYWQuaGVpZ2h0LCB0aGlzLCAnc2V0UmFkaXVzJyk7XG5cdH0sXG5cblx0c2V0UmFkaXVzOiBmdW5jdGlvbihyYWRpdXMpIHtcblx0XHR2YXIgdHlwZSA9IHRoaXMuX3R5cGU7XG5cdFx0aWYgKHR5cGUgPT09ICdjaXJjbGUnKSB7XG5cdFx0XHRpZiAocmFkaXVzID09PSB0aGlzLl9yYWRpdXMpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBzaXplID0gcmFkaXVzICogMjtcblx0XHRcdHRoaXMuX3JhZGl1cyA9IHJhZGl1cztcblx0XHRcdHRoaXMuX3NpemUuc2V0KHNpemUsIHNpemUpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRyYWRpdXMgPSBTaXplLnJlYWQoYXJndW1lbnRzKTtcblx0XHRcdGlmICghdGhpcy5fcmFkaXVzKSB7XG5cdFx0XHRcdHRoaXMuX3JhZGl1cyA9IHJhZGl1cy5jbG9uZSgpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX3JhZGl1cy5lcXVhbHMocmFkaXVzKSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdHRoaXMuX3JhZGl1cy5zZXQocmFkaXVzLndpZHRoLCByYWRpdXMuaGVpZ2h0KTtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdyZWN0YW5nbGUnKSB7XG5cdFx0XHRcdFx0dmFyIHNpemUgPSBTaXplLm1heCh0aGlzLl9zaXplLCByYWRpdXMubXVsdGlwbHkoMikpO1xuXHRcdFx0XHRcdHRoaXMuX3NpemUuc2V0KHNpemUud2lkdGgsIHNpemUuaGVpZ2h0KTtcblx0XHRcdFx0fSBlbHNlIGlmICh0eXBlID09PSAnZWxsaXBzZScpIHtcblx0XHRcdFx0XHR0aGlzLl9zaXplLnNldChyYWRpdXMud2lkdGggKiAyLCByYWRpdXMuaGVpZ2h0ICogMik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCg5KTtcblx0fSxcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gZmFsc2U7XG5cdH0sXG5cblx0dG9QYXRoOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX2Nsb25lKG5ldyBQYXRoW0Jhc2UuY2FwaXRhbGl6ZSh0aGlzLl90eXBlKV0oe1xuXHRcdFx0Y2VudGVyOiBuZXcgUG9pbnQoKSxcblx0XHRcdHNpemU6IHRoaXMuX3NpemUsXG5cdFx0XHRyYWRpdXM6IHRoaXMuX3JhZGl1cyxcblx0XHRcdGluc2VydDogZmFsc2Vcblx0XHR9KSwgaW5zZXJ0KTtcblx0XHRpZiAocGFwZXIuc2V0dGluZ3MuYXBwbHlNYXRyaXgpXG5cdFx0XHRwYXRoLnNldEFwcGx5TWF0cml4KHRydWUpO1xuXHRcdHJldHVybiBwYXRoO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpIHtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGhhc0ZpbGwgPSBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRoYXNTdHJva2UgPSBzdHlsZS5oYXNTdHJva2UoKSxcblx0XHRcdGRvbnRQYWludCA9IHBhcmFtLmRvbnRGaW5pc2ggfHwgcGFyYW0uY2xpcCxcblx0XHRcdHVudHJhbnNmb3JtZWQgPSAhc3Ryb2tlTWF0cml4O1xuXHRcdGlmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSB8fCBkb250UGFpbnQpIHtcblx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0cmFkaXVzID0gdGhpcy5fcmFkaXVzLFxuXHRcdFx0XHRpc0NpcmNsZSA9IHR5cGUgPT09ICdjaXJjbGUnO1xuXHRcdFx0aWYgKCFwYXJhbS5kb250U3RhcnQpXG5cdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdGlmICh1bnRyYW5zZm9ybWVkICYmIGlzQ2lyY2xlKSB7XG5cdFx0XHRcdGN0eC5hcmMoMCwgMCwgcmFkaXVzLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcnggPSBpc0NpcmNsZSA/IHJhZGl1cyA6IHJhZGl1cy53aWR0aCxcblx0XHRcdFx0XHRyeSA9IGlzQ2lyY2xlID8gcmFkaXVzIDogcmFkaXVzLmhlaWdodCxcblx0XHRcdFx0XHRzaXplID0gdGhpcy5fc2l6ZSxcblx0XHRcdFx0XHR3aWR0aCA9IHNpemUud2lkdGgsXG5cdFx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRcdGlmICh1bnRyYW5zZm9ybWVkICYmIHR5cGUgPT09ICdyZWN0YW5nbGUnICYmIHJ4ID09PSAwICYmIHJ5ID09PSAwKSB7XG5cdFx0XHRcdFx0Y3R4LnJlY3QoLXdpZHRoIC8gMiwgLWhlaWdodCAvIDIsIHdpZHRoLCBoZWlnaHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHZhciB4ID0gd2lkdGggLyAyLFxuXHRcdFx0XHRcdFx0eSA9IGhlaWdodCAvIDIsXG5cdFx0XHRcdFx0XHRrYXBwYSA9IDEgLSAwLjU1MjI4NDc0OTgzMDc5MzYsXG5cdFx0XHRcdFx0XHRjeCA9IHJ4ICoga2FwcGEsXG5cdFx0XHRcdFx0XHRjeSA9IHJ5ICoga2FwcGEsXG5cdFx0XHRcdFx0XHRjID0gW1xuXHRcdFx0XHRcdFx0XHQteCwgLXkgKyByeSxcblx0XHRcdFx0XHRcdFx0LXgsIC15ICsgY3ksXG5cdFx0XHRcdFx0XHRcdC14ICsgY3gsIC15LFxuXHRcdFx0XHRcdFx0XHQteCArIHJ4LCAteSxcblx0XHRcdFx0XHRcdFx0eCAtIHJ4LCAteSxcblx0XHRcdFx0XHRcdFx0eCAtIGN4LCAteSxcblx0XHRcdFx0XHRcdFx0eCwgLXkgKyBjeSxcblx0XHRcdFx0XHRcdFx0eCwgLXkgKyByeSxcblx0XHRcdFx0XHRcdFx0eCwgeSAtIHJ5LFxuXHRcdFx0XHRcdFx0XHR4LCB5IC0gY3ksXG5cdFx0XHRcdFx0XHRcdHggLSBjeCwgeSxcblx0XHRcdFx0XHRcdFx0eCAtIHJ4LCB5LFxuXHRcdFx0XHRcdFx0XHQteCArIHJ4LCB5LFxuXHRcdFx0XHRcdFx0XHQteCArIGN4LCB5LFxuXHRcdFx0XHRcdFx0XHQteCwgeSAtIGN5LFxuXHRcdFx0XHRcdFx0XHQteCwgeSAtIHJ5XG5cdFx0XHRcdFx0XHRdO1xuXHRcdFx0XHRcdGlmIChzdHJva2VNYXRyaXgpXG5cdFx0XHRcdFx0XHRzdHJva2VNYXRyaXgudHJhbnNmb3JtKGMsIGMsIDMyKTtcblx0XHRcdFx0XHRjdHgubW92ZVRvKGNbMF0sIGNbMV0pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMl0sIGNbM10sIGNbNF0sIGNbNV0sIGNbNl0sIGNbN10pO1xuXHRcdFx0XHRcdGlmICh4ICE9PSByeClcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oY1s4XSwgY1s5XSk7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8oY1sxMF0sIGNbMTFdLCBjWzEyXSwgY1sxM10sIGNbMTRdLCBjWzE1XSk7XG5cdFx0XHRcdFx0aWYgKHkgIT09IHJ5KVxuXHRcdFx0XHRcdFx0Y3R4LmxpbmVUbyhjWzE2XSwgY1sxN10pO1xuXHRcdFx0XHRcdGN0eC5iZXppZXJDdXJ2ZVRvKGNbMThdLCBjWzE5XSwgY1syMF0sIGNbMjFdLCBjWzIyXSwgY1syM10pO1xuXHRcdFx0XHRcdGlmICh4ICE9PSByeClcblx0XHRcdFx0XHRcdGN0eC5saW5lVG8oY1syNF0sIGNbMjVdKTtcblx0XHRcdFx0XHRjdHguYmV6aWVyQ3VydmVUbyhjWzI2XSwgY1syN10sIGNbMjhdLCBjWzI5XSwgY1szMF0sIGNbMzFdKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdH1cblx0XHRpZiAoIWRvbnRQYWludCAmJiAoaGFzRmlsbCB8fCBoYXNTdHJva2UpKSB7XG5cdFx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4KTtcblx0XHRcdGlmIChoYXNGaWxsKSB7XG5cdFx0XHRcdGN0eC5maWxsKHN0eWxlLmdldFdpbmRpbmdSdWxlKCkpO1xuXHRcdFx0XHRjdHguc2hhZG93Q29sb3IgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHR9XG5cdFx0XHRpZiAoaGFzU3Ryb2tlKVxuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhKHRoaXMuaGFzRmlsbCgpICYmIHRoaXMuaGFzU3Ryb2tlKCkpO1xuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4KSB7XG5cdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKTtcblx0XHRpZiAoZ2V0dGVyICE9PSAnZ2V0Qm91bmRzJyAmJiB0aGlzLmhhc1N0cm9rZSgpKVxuXHRcdFx0cmVjdCA9IHJlY3QuZXhwYW5kKHRoaXMuZ2V0U3Ryb2tlV2lkdGgoKSk7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QpIDogcmVjdDtcblx0fVxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gZ2V0Q29ybmVyQ2VudGVyKHRoYXQsIHBvaW50LCBleHBhbmQpIHtcblx0XHR2YXIgcmFkaXVzID0gdGhhdC5fcmFkaXVzO1xuXHRcdGlmICghcmFkaXVzLmlzWmVybygpKSB7XG5cdFx0XHR2YXIgaGFsZlNpemUgPSB0aGF0Ll9zaXplLmRpdmlkZSgyKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNDsgaSsrKSB7XG5cdFx0XHRcdHZhciBkaXIgPSBuZXcgUG9pbnQoaSAmIDEgPyAxIDogLTEsIGkgPiAxID8gMSA6IC0xKSxcblx0XHRcdFx0XHRjb3JuZXIgPSBkaXIubXVsdGlwbHkoaGFsZlNpemUpLFxuXHRcdFx0XHRcdGNlbnRlciA9IGNvcm5lci5zdWJ0cmFjdChkaXIubXVsdGlwbHkocmFkaXVzKSksXG5cdFx0XHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUoY29ybmVyLCBjZW50ZXIpO1xuXHRcdFx0XHRpZiAoKGV4cGFuZCA/IHJlY3QuZXhwYW5kKGV4cGFuZCkgOiByZWN0KS5jb250YWlucyhwb2ludCkpXG5cdFx0XHRcdFx0cmV0dXJuIGNlbnRlcjtcblx0XHRcdH1cblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRFbGxpcHNlUmFkaXVzKHBvaW50LCByYWRpdXMpIHtcblx0XHR2YXIgYW5nbGUgPSBwb2ludC5nZXRBbmdsZUluUmFkaWFucygpLFxuXHRcdFx0d2lkdGggPSByYWRpdXMud2lkdGggKiAyLFxuXHRcdFx0aGVpZ2h0ID0gcmFkaXVzLmhlaWdodCAqIDIsXG5cdFx0XHR4ID0gd2lkdGggKiBNYXRoLnNpbihhbmdsZSksXG5cdFx0XHR5ID0gaGVpZ2h0ICogTWF0aC5jb3MoYW5nbGUpO1xuXHRcdHJldHVybiB3aWR0aCAqIGhlaWdodCAvICgyICogTWF0aC5zcXJ0KHggKiB4ICsgeSAqIHkpKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2NvbnRhaW5zOiBmdW5jdGlvbiBfY29udGFpbnMocG9pbnQpIHtcblx0XHRcdGlmICh0aGlzLl90eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHR2YXIgY2VudGVyID0gZ2V0Q29ybmVyQ2VudGVyKHRoaXMsIHBvaW50KTtcblx0XHRcdFx0cmV0dXJuIGNlbnRlclxuXHRcdFx0XHRcdFx0PyBwb2ludC5zdWJ0cmFjdChjZW50ZXIpLmRpdmlkZSh0aGlzLl9yYWRpdXMpXG5cdFx0XHRcdFx0XHRcdC5nZXRMZW5ndGgoKSA8PSAxXG5cdFx0XHRcdFx0XHQ6IF9jb250YWlucy5iYXNlLmNhbGwodGhpcywgcG9pbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIHBvaW50LmRpdmlkZSh0aGlzLnNpemUpLmdldExlbmd0aCgpIDw9IDAuNTtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0X2hpdFRlc3RTZWxmOiBmdW5jdGlvbiBfaGl0VGVzdFNlbGYocG9pbnQsIG9wdGlvbnMpIHtcblx0XHRcdHZhciBoaXQgPSBmYWxzZTtcblx0XHRcdGlmICh0aGlzLmhhc1N0cm9rZSgpKSB7XG5cdFx0XHRcdHZhciB0eXBlID0gdGhpcy5fdHlwZSxcblx0XHRcdFx0XHRyYWRpdXMgPSB0aGlzLl9yYWRpdXMsXG5cdFx0XHRcdFx0c3Ryb2tlV2lkdGggPSB0aGlzLmdldFN0cm9rZVdpZHRoKCkgKyAyICogb3B0aW9ucy50b2xlcmFuY2U7XG5cdFx0XHRcdGlmICh0eXBlID09PSAncmVjdGFuZ2xlJykge1xuXHRcdFx0XHRcdHZhciBjZW50ZXIgPSBnZXRDb3JuZXJDZW50ZXIodGhpcywgcG9pbnQsIHN0cm9rZVdpZHRoKTtcblx0XHRcdFx0XHRpZiAoY2VudGVyKSB7XG5cdFx0XHRcdFx0XHR2YXIgcHQgPSBwb2ludC5zdWJ0cmFjdChjZW50ZXIpO1xuXHRcdFx0XHRcdFx0aGl0ID0gMiAqIE1hdGguYWJzKHB0LmdldExlbmd0aCgpXG5cdFx0XHRcdFx0XHRcdFx0LSBnZXRFbGxpcHNlUmFkaXVzKHB0LCByYWRpdXMpKSA8PSBzdHJva2VXaWR0aDtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKHRoaXMuX3NpemUpLnNldENlbnRlcigwLCAwKSxcblx0XHRcdFx0XHRcdFx0b3V0ZXIgPSByZWN0LmV4cGFuZChzdHJva2VXaWR0aCksXG5cdFx0XHRcdFx0XHRcdGlubmVyID0gcmVjdC5leHBhbmQoLXN0cm9rZVdpZHRoKTtcblx0XHRcdFx0XHRcdGhpdCA9IG91dGVyLl9jb250YWluc1BvaW50KHBvaW50KVxuXHRcdFx0XHRcdFx0XHRcdCYmICFpbm5lci5fY29udGFpbnNQb2ludChwb2ludCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdGlmICh0eXBlID09PSAnZWxsaXBzZScpXG5cdFx0XHRcdFx0XHRyYWRpdXMgPSBnZXRFbGxpcHNlUmFkaXVzKHBvaW50LCByYWRpdXMpO1xuXHRcdFx0XHRcdGhpdCA9IDIgKiBNYXRoLmFicyhwb2ludC5nZXRMZW5ndGgoKSAtIHJhZGl1cylcblx0XHRcdFx0XHRcdFx0PD0gc3Ryb2tlV2lkdGg7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBoaXRcblx0XHRcdFx0XHQ/IG5ldyBIaXRSZXN1bHQoJ3N0cm9rZScsIHRoaXMpXG5cdFx0XHRcdFx0OiBfaGl0VGVzdFNlbGYuYmFzZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdH1cblx0fTtcbn0sIHtcblxuc3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBjcmVhdGVTaGFwZSh0eXBlLCBwb2ludCwgc2l6ZSwgcmFkaXVzLCBhcmdzKSB7XG5cdFx0dmFyIGl0ZW0gPSBuZXcgU2hhcGUoQmFzZS5nZXROYW1lZChhcmdzKSk7XG5cdFx0aXRlbS5fdHlwZSA9IHR5cGU7XG5cdFx0aXRlbS5fc2l6ZSA9IHNpemU7XG5cdFx0aXRlbS5fcmFkaXVzID0gcmFkaXVzO1xuXHRcdHJldHVybiBpdGVtLnRyYW5zbGF0ZShwb2ludCk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdENpcmNsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKTtcblx0XHRcdHJldHVybiBjcmVhdGVTaGFwZSgnY2lyY2xlJywgY2VudGVyLCBuZXcgU2l6ZShyYWRpdXMgKiAyKSwgcmFkaXVzLFxuXHRcdFx0XHRcdGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFJlY3RhbmdsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmVjdGFuZ2xlJyksXG5cdFx0XHRcdHJhZGl1cyA9IFNpemUubWluKFNpemUucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1cycpLFxuXHRcdFx0XHRcdFx0cmVjdC5nZXRTaXplKHRydWUpLmRpdmlkZSgyKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlU2hhcGUoJ3JlY3RhbmdsZScsIHJlY3QuZ2V0Q2VudGVyKHRydWUpLFxuXHRcdFx0XHRcdHJlY3QuZ2V0U2l6ZSh0cnVlKSwgcmFkaXVzLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRFbGxpcHNlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlbGxpcHNlID0gU2hhcGUuX3JlYWRFbGxpcHNlKGFyZ3VtZW50cyksXG5cdFx0XHRcdHJhZGl1cyA9IGVsbGlwc2UucmFkaXVzO1xuXHRcdFx0cmV0dXJuIGNyZWF0ZVNoYXBlKCdlbGxpcHNlJywgZWxsaXBzZS5jZW50ZXIsIHJhZGl1cy5tdWx0aXBseSgyKSxcblx0XHRcdFx0XHRyYWRpdXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdF9yZWFkRWxsaXBzZTogZnVuY3Rpb24oYXJncykge1xuXHRcdFx0dmFyIGNlbnRlcixcblx0XHRcdFx0cmFkaXVzO1xuXHRcdFx0aWYgKEJhc2UuaGFzTmFtZWQoYXJncywgJ3JhZGl1cycpKSB7XG5cdFx0XHRcdGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmdzLCAnY2VudGVyJyk7XG5cdFx0XHRcdHJhZGl1cyA9IFNpemUucmVhZE5hbWVkKGFyZ3MsICdyYWRpdXMnKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmdzLCAncmVjdGFuZ2xlJyk7XG5cdFx0XHRcdGNlbnRlciA9IHJlY3QuZ2V0Q2VudGVyKHRydWUpO1xuXHRcdFx0XHRyYWRpdXMgPSByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHsgY2VudGVyOiBjZW50ZXIsIHJhZGl1czogcmFkaXVzIH07XG5cdFx0fVxuXHR9O1xufX0pO1xuXG52YXIgUmFzdGVyID0gSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdSYXN0ZXInLFxuXHRfYXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfY2FuQXBwbHlNYXRyaXg6IGZhbHNlLFxuXHRfYm91bmRzR2V0dGVyOiAnZ2V0Qm91bmRzJyxcblx0X2JvdW5kc1NlbGVjdGVkOiB0cnVlLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y3Jvc3NPcmlnaW46IG51bGwsXG5cdFx0c291cmNlOiBudWxsXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUmFzdGVyKG9iamVjdCwgcG9zaXRpb24pIHtcblx0XHRpZiAoIXRoaXMuX2luaXRpYWxpemUob2JqZWN0LFxuXHRcdFx0XHRwb3NpdGlvbiAhPT0gdW5kZWZpbmVkICYmIFBvaW50LnJlYWQoYXJndW1lbnRzLCAxKSkpIHtcblx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0ID09PSAnc3RyaW5nJykge1xuXHRcdFx0XHR0aGlzLnNldFNvdXJjZShvYmplY3QpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5zZXRJbWFnZShvYmplY3QpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoIXRoaXMuX3NpemUpIHtcblx0XHRcdHRoaXMuX3NpemUgPSBuZXcgU2l6ZSgpO1xuXHRcdFx0dGhpcy5fbG9hZGVkID0gZmFsc2U7XG5cdFx0fVxuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5nZXRTb3VyY2UoKSA9PT0gaXRlbS5nZXRTb3VyY2UoKTtcblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0dmFyIGNvcHkgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKSxcblx0XHRcdGltYWdlID0gdGhpcy5faW1hZ2UsXG5cdFx0XHRjYW52YXMgPSB0aGlzLl9jYW52YXM7XG5cdFx0aWYgKGltYWdlKSB7XG5cdFx0XHRjb3B5LnNldEltYWdlKGltYWdlKTtcblx0XHR9IGVsc2UgaWYgKGNhbnZhcykge1xuXHRcdFx0dmFyIGNvcHlDYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXModGhpcy5fc2l6ZSk7XG5cdFx0XHRjb3B5Q2FudmFzLmdldENvbnRleHQoJzJkJykuZHJhd0ltYWdlKGNhbnZhcywgMCwgMCk7XG5cdFx0XHRjb3B5LnNldEltYWdlKGNvcHlDYW52YXMpO1xuXHRcdH1cblx0XHRjb3B5Ll9jcm9zc09yaWdpbiA9IHRoaXMuX2Nyb3NzT3JpZ2luO1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShjb3B5LCBpbnNlcnQpO1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gdGhpcy5fc2l6ZTtcblx0XHRyZXR1cm4gbmV3IExpbmtlZFNpemUoc2l6ZSA/IHNpemUud2lkdGggOiAwLCBzaXplID8gc2l6ZS5oZWlnaHQgOiAwLFxuXHRcdFx0XHR0aGlzLCAnc2V0U2l6ZScpO1xuXHR9LFxuXG5cdHNldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKCFzaXplLmVxdWFscyh0aGlzLl9zaXplKSkge1xuXHRcdFx0aWYgKHNpemUud2lkdGggPiAwICYmIHNpemUuaGVpZ2h0ID4gMCkge1xuXHRcdFx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXHRcdFx0XHR0aGlzLnNldEltYWdlKENhbnZhc1Byb3ZpZGVyLmdldENhbnZhcyhzaXplKSk7XG5cdFx0XHRcdGlmIChlbGVtZW50KVxuXHRcdFx0XHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoZWxlbWVudCwgMCwgMCxcblx0XHRcdFx0XHRcdFx0c2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHRoaXMuX2NhbnZhcylcblx0XHRcdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKHRoaXMuX2NhbnZhcyk7XG5cdFx0XHRcdHRoaXMuX3NpemUgPSBzaXplLmNsb25lKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGdldFdpZHRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUud2lkdGggOiAwO1xuXHR9LFxuXG5cdHNldFdpZHRoOiBmdW5jdGlvbih3aWR0aCkge1xuXHRcdHRoaXMuc2V0U2l6ZSh3aWR0aCwgdGhpcy5nZXRIZWlnaHQoKSk7XG5cdH0sXG5cblx0Z2V0SGVpZ2h0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2l6ZSA/IHRoaXMuX3NpemUuaGVpZ2h0IDogMDtcblx0fSxcblxuXHRzZXRIZWlnaHQ6IGZ1bmN0aW9uKGhlaWdodCkge1xuXHRcdHRoaXMuc2V0U2l6ZSh0aGlzLmdldFdpZHRoKCksIGhlaWdodCk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdHJldHVybiAhc2l6ZSB8fCBzaXplLndpZHRoID09PSAwICYmIHNpemUuaGVpZ2h0ID09PSAwO1xuXHR9LFxuXG5cdGdldFJlc29sdXRpb246IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBtYXRyaXggPSB0aGlzLl9tYXRyaXgsXG5cdFx0XHRvcmlnID0gbmV3IFBvaW50KDAsIDApLnRyYW5zZm9ybShtYXRyaXgpLFxuXHRcdFx0dSA9IG5ldyBQb2ludCgxLCAwKS50cmFuc2Zvcm0obWF0cml4KS5zdWJ0cmFjdChvcmlnKSxcblx0XHRcdHYgPSBuZXcgUG9pbnQoMCwgMSkudHJhbnNmb3JtKG1hdHJpeCkuc3VidHJhY3Qob3JpZyk7XG5cdFx0cmV0dXJuIG5ldyBTaXplKFxuXHRcdFx0NzIgLyB1LmdldExlbmd0aCgpLFxuXHRcdFx0NzIgLyB2LmdldExlbmd0aCgpXG5cdFx0KTtcblx0fSxcblxuXHRnZXRQcGk6ICcjZ2V0UmVzb2x1dGlvbicsXG5cblx0Z2V0SW1hZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbWFnZTtcblx0fSxcblxuXHRzZXRJbWFnZTogZnVuY3Rpb24oaW1hZ2UpIHtcblx0XHRpZiAodGhpcy5fY2FudmFzKVxuXHRcdFx0Q2FudmFzUHJvdmlkZXIucmVsZWFzZSh0aGlzLl9jYW52YXMpO1xuXHRcdGlmIChpbWFnZSAmJiBpbWFnZS5nZXRDb250ZXh0KSB7XG5cdFx0XHR0aGlzLl9pbWFnZSA9IG51bGw7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBpbWFnZTtcblx0XHRcdHRoaXMuX2xvYWRlZCA9IHRydWU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gaW1hZ2U7XG5cdFx0XHR0aGlzLl9jYW52YXMgPSBudWxsO1xuXHRcdFx0dGhpcy5fbG9hZGVkID0gaW1hZ2UgJiYgaW1hZ2UuY29tcGxldGU7XG5cdFx0fVxuXHRcdHRoaXMuX3NpemUgPSBuZXcgU2l6ZShcblx0XHRcdFx0aW1hZ2UgPyBpbWFnZS5uYXR1cmFsV2lkdGggfHwgaW1hZ2Uud2lkdGggOiAwLFxuXHRcdFx0XHRpbWFnZSA/IGltYWdlLm5hdHVyYWxIZWlnaHQgfHwgaW1hZ2UuaGVpZ2h0IDogMCk7XG5cdFx0dGhpcy5fY29udGV4dCA9IG51bGw7XG5cdFx0dGhpcy5fY2hhbmdlZCg1MjEpO1xuXHR9LFxuXG5cdGdldENhbnZhczogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9jYW52YXMpIHtcblx0XHRcdHZhciBjdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KHRoaXMuX3NpemUpO1xuXHRcdFx0dHJ5IHtcblx0XHRcdFx0aWYgKHRoaXMuX2ltYWdlKVxuXHRcdFx0XHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5faW1hZ2UsIDAsIDApO1xuXHRcdFx0XHR0aGlzLl9jYW52YXMgPSBjdHguY2FudmFzO1xuXHRcdFx0fSBjYXRjaCAoZSkge1xuXHRcdFx0XHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9jYW52YXM7XG5cdH0sXG5cblx0c2V0Q2FudmFzOiAnI3NldEltYWdlJyxcblxuXHRnZXRDb250ZXh0OiBmdW5jdGlvbihtb2RpZnkpIHtcblx0XHRpZiAoIXRoaXMuX2NvbnRleHQpXG5cdFx0XHR0aGlzLl9jb250ZXh0ID0gdGhpcy5nZXRDYW52YXMoKS5nZXRDb250ZXh0KCcyZCcpO1xuXHRcdGlmIChtb2RpZnkpIHtcblx0XHRcdHRoaXMuX2ltYWdlID0gbnVsbDtcblx0XHRcdHRoaXMuX2NoYW5nZWQoNTEzKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMuX2NvbnRleHQ7XG5cdH0sXG5cblx0c2V0Q29udGV4dDogZnVuY3Rpb24oY29udGV4dCkge1xuXHRcdHRoaXMuX2NvbnRleHQgPSBjb250ZXh0O1xuXHR9LFxuXG5cdGdldFNvdXJjZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLnNyYyB8fCB0aGlzLnRvRGF0YVVSTCgpO1xuXHR9LFxuXG5cdHNldFNvdXJjZTogZnVuY3Rpb24oc3JjKSB7XG5cdFx0dmFyIHRoYXQgPSB0aGlzLFxuXHRcdFx0Y3Jvc3NPcmlnaW4gPSB0aGlzLl9jcm9zc09yaWdpbixcblx0XHRcdGltYWdlO1xuXG5cdFx0ZnVuY3Rpb24gbG9hZGVkKCkge1xuXHRcdFx0dmFyIHZpZXcgPSB0aGF0LmdldFZpZXcoKTtcblx0XHRcdGlmICh2aWV3KSB7XG5cdFx0XHRcdHBhcGVyID0gdmlldy5fc2NvcGU7XG5cdFx0XHRcdHRoYXQuc2V0SW1hZ2UoaW1hZ2UpO1xuXHRcdFx0XHR0aGF0LmVtaXQoJ2xvYWQnKTtcblx0XHRcdFx0dmlldy51cGRhdGUoKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpbWFnZSA9IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKHNyYykgfHwgbmV3IEltYWdlKCk7XG5cdFx0aWYgKGNyb3NzT3JpZ2luKVxuXHRcdFx0aW1hZ2UuY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHRpZiAoaW1hZ2UubmF0dXJhbFdpZHRoICYmIGltYWdlLm5hdHVyYWxIZWlnaHQpIHtcblx0XHRcdHNldFRpbWVvdXQobG9hZGVkLCAwKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0RG9tRXZlbnQuYWRkKGltYWdlLCB7IGxvYWQ6IGxvYWRlZCB9KTtcblx0XHRcdGlmICghaW1hZ2Uuc3JjKVxuXHRcdFx0XHRpbWFnZS5zcmMgPSBzcmM7XG5cdFx0fVxuXHRcdHRoaXMuc2V0SW1hZ2UoaW1hZ2UpO1xuXHR9LFxuXG5cdGdldENyb3NzT3JpZ2luOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW1hZ2UgJiYgdGhpcy5faW1hZ2UuY3Jvc3NPcmlnaW4gfHwgdGhpcy5fY3Jvc3NPcmlnaW4gfHwgJyc7XG5cdH0sXG5cblx0c2V0Q3Jvc3NPcmlnaW46IGZ1bmN0aW9uKGNyb3NzT3JpZ2luKSB7XG5cdFx0dGhpcy5fY3Jvc3NPcmlnaW4gPSBjcm9zc09yaWdpbjtcblx0XHRpZiAodGhpcy5faW1hZ2UpXG5cdFx0XHR0aGlzLl9pbWFnZS5jcm9zc09yaWdpbiA9IGNyb3NzT3JpZ2luO1xuXHR9LFxuXG5cdGdldEVsZW1lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9jYW52YXMgfHwgdGhpcy5fbG9hZGVkICYmIHRoaXMuX2ltYWdlO1xuXHR9XG59LCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRTdWJDYW52YXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQocmVjdC5nZXRTaXplKCkpO1xuXHRcdGN0eC5kcmF3SW1hZ2UodGhpcy5nZXRDYW52YXMoKSwgcmVjdC54LCByZWN0LnksXG5cdFx0XHRcdHJlY3Qud2lkdGgsIHJlY3QuaGVpZ2h0LCAwLCAwLCByZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG5cdFx0cmV0dXJuIGN0eC5jYW52YXM7XG5cdH0sXG5cblx0Z2V0U3ViUmFzdGVyOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRyYXN0ZXIgPSBuZXcgUmFzdGVyKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRyYXN0ZXIuc2V0SW1hZ2UodGhpcy5nZXRTdWJDYW52YXMocmVjdCkpO1xuXHRcdHJhc3Rlci50cmFuc2xhdGUocmVjdC5nZXRDZW50ZXIoKS5zdWJ0cmFjdCh0aGlzLmdldFNpemUoKS5kaXZpZGUoMikpKTtcblx0XHRyYXN0ZXIuX21hdHJpeC5wcmVDb25jYXRlbmF0ZSh0aGlzLl9tYXRyaXgpO1xuXHRcdHJhc3Rlci5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRyZXR1cm4gcmFzdGVyO1xuXHR9LFxuXG5cdHRvRGF0YVVSTDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNyYyA9IHRoaXMuX2ltYWdlICYmIHRoaXMuX2ltYWdlLnNyYztcblx0XHRpZiAoL15kYXRhOi8udGVzdChzcmMpKVxuXHRcdFx0cmV0dXJuIHNyYztcblx0XHR2YXIgY2FudmFzID0gdGhpcy5nZXRDYW52YXMoKTtcblx0XHRyZXR1cm4gY2FudmFzID8gY2FudmFzLnRvRGF0YVVSTC5hcHBseShjYW52YXMsIGFyZ3VtZW50cykgOiBudWxsO1xuXHR9LFxuXG5cdGRyYXdJbWFnZTogZnVuY3Rpb24oaW1hZ2UgKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMsIDEpO1xuXHRcdHRoaXMuZ2V0Q29udGV4dCh0cnVlKS5kcmF3SW1hZ2UoaW1hZ2UsIHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEF2ZXJhZ2VDb2xvcjogZnVuY3Rpb24ob2JqZWN0KSB7XG5cdFx0dmFyIGJvdW5kcywgcGF0aDtcblx0XHRpZiAoIW9iamVjdCkge1xuXHRcdFx0Ym91bmRzID0gdGhpcy5nZXRCb3VuZHMoKTtcblx0XHR9IGVsc2UgaWYgKG9iamVjdCBpbnN0YW5jZW9mIFBhdGhJdGVtKSB7XG5cdFx0XHRwYXRoID0gb2JqZWN0O1xuXHRcdFx0Ym91bmRzID0gb2JqZWN0LmdldEJvdW5kcygpO1xuXHRcdH0gZWxzZSBpZiAob2JqZWN0LndpZHRoKSB7XG5cdFx0XHRib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG9iamVjdCk7XG5cdFx0fSBlbHNlIGlmIChvYmplY3QueCkge1xuXHRcdFx0Ym91bmRzID0gbmV3IFJlY3RhbmdsZShvYmplY3QueCAtIDAuNSwgb2JqZWN0LnkgLSAwLjUsIDEsIDEpO1xuXHRcdH1cblx0XHR2YXIgc2FtcGxlU2l6ZSA9IDMyLFxuXHRcdFx0d2lkdGggPSBNYXRoLm1pbihib3VuZHMud2lkdGgsIHNhbXBsZVNpemUpLFxuXHRcdFx0aGVpZ2h0ID0gTWF0aC5taW4oYm91bmRzLmhlaWdodCwgc2FtcGxlU2l6ZSk7XG5cdFx0dmFyIGN0eCA9IFJhc3Rlci5fc2FtcGxlQ29udGV4dDtcblx0XHRpZiAoIWN0eCkge1xuXHRcdFx0Y3R4ID0gUmFzdGVyLl9zYW1wbGVDb250ZXh0ID0gQ2FudmFzUHJvdmlkZXIuZ2V0Q29udGV4dChcblx0XHRcdFx0XHRuZXcgU2l6ZShzYW1wbGVTaXplKSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGN0eC5jbGVhclJlY3QoMCwgMCwgc2FtcGxlU2l6ZSArIDEsIHNhbXBsZVNpemUgKyAxKTtcblx0XHR9XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR2YXIgbWF0cml4ID0gbmV3IE1hdHJpeCgpXG5cdFx0XHRcdC5zY2FsZSh3aWR0aCAvIGJvdW5kcy53aWR0aCwgaGVpZ2h0IC8gYm91bmRzLmhlaWdodClcblx0XHRcdFx0LnRyYW5zbGF0ZSgtYm91bmRzLngsIC1ib3VuZHMueSk7XG5cdFx0bWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0aWYgKHBhdGgpXG5cdFx0XHRwYXRoLmRyYXcoY3R4LCBuZXcgQmFzZSh7IGNsaXA6IHRydWUsIG1hdHJpY2VzOiBbbWF0cml4XSB9KSk7XG5cdFx0dGhpcy5fbWF0cml4LmFwcGx5VG9Db250ZXh0KGN0eCk7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLmdldEVsZW1lbnQoKSxcblx0XHRcdHNpemUgPSB0aGlzLl9zaXplO1xuXHRcdGlmIChlbGVtZW50KVxuXHRcdFx0Y3R4LmRyYXdJbWFnZShlbGVtZW50LCAtc2l6ZS53aWR0aCAvIDIsIC1zaXplLmhlaWdodCAvIDIpO1xuXHRcdGN0eC5yZXN0b3JlKCk7XG5cdFx0dmFyIHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMC41LCAwLjUsIE1hdGguY2VpbCh3aWR0aCksXG5cdFx0XHRcdE1hdGguY2VpbChoZWlnaHQpKS5kYXRhLFxuXHRcdFx0Y2hhbm5lbHMgPSBbMCwgMCwgMF0sXG5cdFx0XHR0b3RhbCA9IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwaXhlbHMubGVuZ3RoOyBpIDwgbDsgaSArPSA0KSB7XG5cdFx0XHR2YXIgYWxwaGEgPSBwaXhlbHNbaSArIDNdO1xuXHRcdFx0dG90YWwgKz0gYWxwaGE7XG5cdFx0XHRhbHBoYSAvPSAyNTU7XG5cdFx0XHRjaGFubmVsc1swXSArPSBwaXhlbHNbaV0gKiBhbHBoYTtcblx0XHRcdGNoYW5uZWxzWzFdICs9IHBpeGVsc1tpICsgMV0gKiBhbHBoYTtcblx0XHRcdGNoYW5uZWxzWzJdICs9IHBpeGVsc1tpICsgMl0gKiBhbHBoYTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspXG5cdFx0XHRjaGFubmVsc1tpXSAvPSB0b3RhbDtcblx0XHRyZXR1cm4gdG90YWwgPyBDb2xvci5yZWFkKGNoYW5uZWxzKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0UGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR2YXIgZGF0YSA9IHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShwb2ludC54LCBwb2ludC55LCAxLCAxKS5kYXRhO1xuXHRcdHJldHVybiBuZXcgQ29sb3IoJ3JnYicsIFtkYXRhWzBdIC8gMjU1LCBkYXRhWzFdIC8gMjU1LCBkYXRhWzJdIC8gMjU1XSxcblx0XHRcdFx0ZGF0YVszXSAvIDI1NSk7XG5cdH0sXG5cblx0c2V0UGl4ZWw6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdGNvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0Y29tcG9uZW50cyA9IGNvbG9yLl9jb252ZXJ0KCdyZ2InKSxcblx0XHRcdGFscGhhID0gY29sb3IuX2FscGhhLFxuXHRcdFx0Y3R4ID0gdGhpcy5nZXRDb250ZXh0KHRydWUpLFxuXHRcdFx0aW1hZ2VEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSgxLCAxKSxcblx0XHRcdGRhdGEgPSBpbWFnZURhdGEuZGF0YTtcblx0XHRkYXRhWzBdID0gY29tcG9uZW50c1swXSAqIDI1NTtcblx0XHRkYXRhWzFdID0gY29tcG9uZW50c1sxXSAqIDI1NTtcblx0XHRkYXRhWzJdID0gY29tcG9uZW50c1syXSAqIDI1NTtcblx0XHRkYXRhWzNdID0gYWxwaGEgIT0gbnVsbCA/IGFscGhhICogMjU1IDogMjU1O1xuXHRcdGN0eC5wdXRJbWFnZURhdGEoaW1hZ2VEYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRjcmVhdGVJbWFnZURhdGE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmNyZWF0ZUltYWdlRGF0YShzaXplLndpZHRoLCBzaXplLmhlaWdodCk7XG5cdH0sXG5cblx0Z2V0SW1hZ2VEYXRhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcmVjdCA9IFJlY3RhbmdsZS5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0aWYgKHJlY3QuaXNFbXB0eSgpKVxuXHRcdFx0cmVjdCA9IG5ldyBSZWN0YW5nbGUodGhpcy5fc2l6ZSk7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q29udGV4dCgpLmdldEltYWdlRGF0YShyZWN0LngsIHJlY3QueSxcblx0XHRcdFx0cmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHR9LFxuXG5cdHNldEltYWdlRGF0YTogZnVuY3Rpb24oZGF0YSApIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSk7XG5cdFx0dGhpcy5nZXRDb250ZXh0KHRydWUpLnB1dEltYWdlRGF0YShkYXRhLCBwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHZhciByZWN0ID0gbmV3IFJlY3RhbmdsZSh0aGlzLl9zaXplKS5zZXRDZW50ZXIoMCwgMCk7XG5cdFx0cmV0dXJuIG1hdHJpeCA/IG1hdHJpeC5fdHJhbnNmb3JtQm91bmRzKHJlY3QpIDogcmVjdDtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0aWYgKHRoaXMuX2NvbnRhaW5zKHBvaW50KSkge1xuXHRcdFx0dmFyIHRoYXQgPSB0aGlzO1xuXHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQoJ3BpeGVsJywgdGhhdCwge1xuXHRcdFx0XHRvZmZzZXQ6IHBvaW50LmFkZCh0aGF0Ll9zaXplLmRpdmlkZSgyKSkucm91bmQoKSxcblx0XHRcdFx0Y29sb3I6IHtcblx0XHRcdFx0XHRnZXQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0cmV0dXJuIHRoYXQuZ2V0UGl4ZWwodGhpcy5vZmZzZXQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0fSk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgpIHtcblx0XHR2YXIgZWxlbWVudCA9IHRoaXMuZ2V0RWxlbWVudCgpO1xuXHRcdGlmIChlbGVtZW50KSB7XG5cdFx0XHRjdHguZ2xvYmFsQWxwaGEgPSB0aGlzLl9vcGFjaXR5O1xuXHRcdFx0Y3R4LmRyYXdJbWFnZShlbGVtZW50LFxuXHRcdFx0XHRcdC10aGlzLl9zaXplLndpZHRoIC8gMiwgLXRoaXMuX3NpemUuaGVpZ2h0IC8gMik7XG5cdFx0fVxuXHR9LFxuXG5cdF9jYW5Db21wb3NpdGU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0cnVlO1xuXHR9XG59KTtcblxudmFyIFBsYWNlZFN5bWJvbCA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGxhY2VkU3ltYm9sJyxcblx0X2FwcGx5TWF0cml4OiBmYWxzZSxcblx0X2NhbkFwcGx5TWF0cml4OiBmYWxzZSxcblx0X2JvdW5kc0dldHRlcjogeyBnZXRCb3VuZHM6ICdnZXRTdHJva2VCb3VuZHMnIH0sXG5cdF9ib3VuZHNTZWxlY3RlZDogdHJ1ZSxcblx0X3NlcmlhbGl6ZUZpZWxkczoge1xuXHRcdHN5bWJvbDogbnVsbFxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBsYWNlZFN5bWJvbChhcmcwLCBhcmcxKSB7XG5cdFx0aWYgKCF0aGlzLl9pbml0aWFsaXplKGFyZzAsXG5cdFx0XHRcdGFyZzEgIT09IHVuZGVmaW5lZCAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cywgMSkpKVxuXHRcdFx0dGhpcy5zZXRTeW1ib2woYXJnMCBpbnN0YW5jZW9mIFN5bWJvbCA/IGFyZzAgOiBuZXcgU3ltYm9sKGFyZzApKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbCA9PT0gaXRlbS5fc3ltYm9sO1xuXHR9LFxuXG5cdGdldFN5bWJvbDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbDtcblx0fSxcblxuXHRzZXRTeW1ib2w6IGZ1bmN0aW9uKHN5bWJvbCkge1xuXHRcdHRoaXMuX3N5bWJvbCA9IHN5bWJvbDtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbihpbnNlcnQpIHtcblx0XHR2YXIgY29weSA9IG5ldyBQbGFjZWRTeW1ib2woSXRlbS5OT19JTlNFUlQpO1xuXHRcdGNvcHkuc2V0U3ltYm9sKHRoaXMuX3N5bWJvbCk7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3N5bWJvbC5fZGVmaW5pdGlvbi5pc0VtcHR5KCk7XG5cdH0sXG5cblx0X2dldEJvdW5kczogZnVuY3Rpb24oZ2V0dGVyLCBtYXRyaXgsIGNhY2hlSXRlbSkge1xuXHRcdHZhciBkZWZpbml0aW9uID0gdGhpcy5zeW1ib2wuX2RlZmluaXRpb247XG5cdFx0cmV0dXJuIGRlZmluaXRpb24uX2dldENhY2hlZEJvdW5kcyhnZXR0ZXIsXG5cdFx0XHRcdG1hdHJpeCAmJiBtYXRyaXguY2hhaW4oZGVmaW5pdGlvbi5fbWF0cml4KSwgY2FjaGVJdGVtKTtcblx0fSxcblxuXHRfaGl0VGVzdFNlbGY6IGZ1bmN0aW9uKHBvaW50LCBvcHRpb25zKSB7XG5cdFx0dmFyIHJlcyA9IHRoaXMuX3N5bWJvbC5fZGVmaW5pdGlvbi5faGl0VGVzdChwb2ludCwgb3B0aW9ucyk7XG5cdFx0aWYgKHJlcylcblx0XHRcdHJlcy5pdGVtID0gdGhpcztcblx0XHRyZXR1cm4gcmVzO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtKSB7XG5cdFx0dGhpcy5zeW1ib2wuX2RlZmluaXRpb24uZHJhdyhjdHgsIHBhcmFtKTtcblx0fVxuXG59KTtcblxudmFyIEhpdFJlc3VsdCA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnSGl0UmVzdWx0JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBIaXRSZXN1bHQodHlwZSwgaXRlbSwgdmFsdWVzKSB7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLml0ZW0gPSBpdGVtO1xuXHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdHZhbHVlcy5lbnVtZXJhYmxlID0gdHJ1ZTtcblx0XHRcdHRoaXMuaW5qZWN0KHZhbHVlcyk7XG5cdFx0fVxuXHR9LFxuXG5cdHN0YXRpY3M6IHtcblx0XHRnZXRPcHRpb25zOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRyZXR1cm4gbmV3IEJhc2Uoe1xuXHRcdFx0XHR0eXBlOiBudWxsLFxuXHRcdFx0XHR0b2xlcmFuY2U6IHBhcGVyLnNldHRpbmdzLmhpdFRvbGVyYW5jZSxcblx0XHRcdFx0ZmlsbDogIW9wdGlvbnMsXG5cdFx0XHRcdHN0cm9rZTogIW9wdGlvbnMsXG5cdFx0XHRcdHNlZ21lbnRzOiAhb3B0aW9ucyxcblx0XHRcdFx0aGFuZGxlczogZmFsc2UsXG5cdFx0XHRcdGVuZHM6IGZhbHNlLFxuXHRcdFx0XHRjZW50ZXI6IGZhbHNlLFxuXHRcdFx0XHRib3VuZHM6IGZhbHNlLFxuXHRcdFx0XHRndWlkZXM6IGZhbHNlLFxuXHRcdFx0XHRzZWxlY3RlZDogZmFsc2Vcblx0XHRcdH0sIG9wdGlvbnMpO1xuXHRcdH1cblx0fVxufSk7XG5cbnZhciBTZWdtZW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdTZWdtZW50Jyxcblx0YmVhbnM6IHRydWUsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2VnbWVudChhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1KSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdHBvaW50LCBoYW5kbGVJbiwgaGFuZGxlT3V0O1xuXHRcdGlmIChjb3VudCA9PT0gMCkge1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDEpIHtcblx0XHRcdGlmICgncG9pbnQnIGluIGFyZzApIHtcblx0XHRcdFx0cG9pbnQgPSBhcmcwLnBvaW50O1xuXHRcdFx0XHRoYW5kbGVJbiA9IGFyZzAuaGFuZGxlSW47XG5cdFx0XHRcdGhhbmRsZU91dCA9IGFyZzAuaGFuZGxlT3V0O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cG9pbnQgPSBhcmcwO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDIgJiYgdHlwZW9mIGFyZzAgPT09ICdudW1iZXInKSB7XG5cdFx0XHRwb2ludCA9IGFyZ3VtZW50cztcblx0XHR9IGVsc2UgaWYgKGNvdW50IDw9IDMpIHtcblx0XHRcdHBvaW50ID0gYXJnMDtcblx0XHRcdGhhbmRsZUluID0gYXJnMTtcblx0XHRcdGhhbmRsZU91dCA9IGFyZzI7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBvaW50ID0gYXJnMCAhPT0gdW5kZWZpbmVkID8gWyBhcmcwLCBhcmcxIF0gOiBudWxsO1xuXHRcdFx0aGFuZGxlSW4gPSBhcmcyICE9PSB1bmRlZmluZWQgPyBbIGFyZzIsIGFyZzMgXSA6IG51bGw7XG5cdFx0XHRoYW5kbGVPdXQgPSBhcmc0ICE9PSB1bmRlZmluZWQgPyBbIGFyZzQsIGFyZzUgXSA6IG51bGw7XG5cdFx0fVxuXHRcdG5ldyBTZWdtZW50UG9pbnQocG9pbnQsIHRoaXMsICdfcG9pbnQnKTtcblx0XHRuZXcgU2VnbWVudFBvaW50KGhhbmRsZUluLCB0aGlzLCAnX2hhbmRsZUluJyk7XG5cdFx0bmV3IFNlZ21lbnRQb2ludChoYW5kbGVPdXQsIHRoaXMsICdfaGFuZGxlT3V0Jyk7XG5cdH0sXG5cblx0X3NlcmlhbGl6ZTogZnVuY3Rpb24ob3B0aW9ucykge1xuXHRcdHJldHVybiBCYXNlLnNlcmlhbGl6ZSh0aGlzLmhhc0hhbmRsZXMoKVxuXHRcdFx0XHQ/IFt0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlSW4sIHRoaXMuX2hhbmRsZU91dF1cblx0XHRcdFx0OiB0aGlzLl9wb2ludCxcblx0XHRcdFx0b3B0aW9ucywgdHJ1ZSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKHBvaW50KSB7XG5cdFx0dmFyIHBhdGggPSB0aGlzLl9wYXRoO1xuXHRcdGlmICghcGF0aClcblx0XHRcdHJldHVybjtcblx0XHR2YXIgY3VydmVzID0gcGF0aC5fY3VydmVzLFxuXHRcdFx0aW5kZXggPSB0aGlzLl9pbmRleCxcblx0XHRcdGN1cnZlO1xuXHRcdGlmIChjdXJ2ZXMpIHtcblx0XHRcdGlmICgoIXBvaW50IHx8IHBvaW50ID09PSB0aGlzLl9wb2ludCB8fCBwb2ludCA9PT0gdGhpcy5faGFuZGxlSW4pXG5cdFx0XHRcdFx0JiYgKGN1cnZlID0gaW5kZXggPiAwID8gY3VydmVzW2luZGV4IC0gMV0gOiBwYXRoLl9jbG9zZWRcblx0XHRcdFx0XHRcdD8gY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSA6IG51bGwpKVxuXHRcdFx0XHRjdXJ2ZS5fY2hhbmdlZCgpO1xuXHRcdFx0aWYgKCghcG9pbnQgfHwgcG9pbnQgPT09IHRoaXMuX3BvaW50IHx8IHBvaW50ID09PSB0aGlzLl9oYW5kbGVPdXQpXG5cdFx0XHRcdFx0JiYgKGN1cnZlID0gY3VydmVzW2luZGV4XSkpXG5cdFx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdHBhdGguX2NoYW5nZWQoMjUpO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcG9pbnQ7XG5cdH0sXG5cblx0c2V0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9wb2ludC5zZXQocG9pbnQueCwgcG9pbnQueSk7XG5cdH0sXG5cblx0Z2V0SGFuZGxlSW46IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVJbjtcblx0fSxcblxuXHRzZXRIYW5kbGVJbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMuX2hhbmRsZUluLnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGVPdXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9oYW5kbGVPdXQ7XG5cdH0sXG5cblx0c2V0SGFuZGxlT3V0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyk7XG5cdFx0dGhpcy5faGFuZGxlT3V0LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRoYXNIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gIXRoaXMuX2hhbmRsZUluLmlzWmVybygpIHx8ICF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKCk7XG5cdH0sXG5cblx0Y2xlYXJIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9oYW5kbGVJbi5zZXQoMCwgMCk7XG5cdFx0dGhpcy5faGFuZGxlT3V0LnNldCgwLCAwKTtcblx0fSxcblxuXHRfc2VsZWN0aW9uU3RhdGU6IDAsXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oX3BvaW50KSB7XG5cdFx0dmFyIHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGU7XG5cdFx0cmV0dXJuICFfcG9pbnQgPyAhIShzdGF0ZSAmIDcpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5fcG9pbnQgPyAhIShzdGF0ZSAmIDQpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlSW4gPyAhIShzdGF0ZSAmIDEpXG5cdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gISEoc3RhdGUgJiAyKVxuXHRcdFx0OiBmYWxzZTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQsIF9wb2ludCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aCxcblx0XHRcdHNlbGVjdGVkID0gISFzZWxlY3RlZCxcblx0XHRcdHN0YXRlID0gdGhpcy5fc2VsZWN0aW9uU3RhdGUsXG5cdFx0XHRvbGRTdGF0ZSA9IHN0YXRlLFxuXHRcdFx0ZmxhZyA9ICFfcG9pbnQgPyA3XG5cdFx0XHRcdFx0OiBfcG9pbnQgPT09IHRoaXMuX3BvaW50ID8gNFxuXHRcdFx0XHRcdDogX3BvaW50ID09PSB0aGlzLl9oYW5kbGVJbiA/IDFcblx0XHRcdFx0XHQ6IF9wb2ludCA9PT0gdGhpcy5faGFuZGxlT3V0ID8gMlxuXHRcdFx0XHRcdDogMDtcblx0XHRpZiAoc2VsZWN0ZWQpIHtcblx0XHRcdHN0YXRlIHw9IGZsYWc7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHN0YXRlICY9IH5mbGFnO1xuXHRcdH1cblx0XHR0aGlzLl9zZWxlY3Rpb25TdGF0ZSA9IHN0YXRlO1xuXHRcdGlmIChwYXRoICYmIHN0YXRlICE9PSBvbGRTdGF0ZSkge1xuXHRcdFx0cGF0aC5fdXBkYXRlU2VsZWN0aW9uKHRoaXMsIG9sZFN0YXRlLCBzdGF0ZSk7XG5cdFx0XHRwYXRoLl9jaGFuZ2VkKDEyOSk7XG5cdFx0fVxuXHR9LFxuXG5cdGdldEluZGV4OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5faW5kZXggIT09IHVuZGVmaW5lZCA/IHRoaXMuX2luZGV4IDogbnVsbDtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aCB8fCBudWxsO1xuXHR9LFxuXG5cdGdldEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGF0aCA9IHRoaXMuX3BhdGgsXG5cdFx0XHRpbmRleCA9IHRoaXMuX2luZGV4O1xuXHRcdGlmIChwYXRoKSB7XG5cdFx0XHRpZiAoaW5kZXggPiAwICYmICFwYXRoLl9jbG9zZWRcblx0XHRcdFx0XHQmJiBpbmRleCA9PT0gcGF0aC5fc2VnbWVudHMubGVuZ3RoIC0gMSlcblx0XHRcdFx0aW5kZXgtLTtcblx0XHRcdHJldHVybiBwYXRoLmdldEN1cnZlcygpW2luZGV4XSB8fCBudWxsO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRnZXRMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBjdXJ2ZVxuXHRcdFx0XHQ/IG5ldyBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCB0aGlzID09PSBjdXJ2ZS5fc2VnbWVudDEgPyAwIDogMSlcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGdldE5leHQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3BhdGggJiYgdGhpcy5fcGF0aC5fc2VnbWVudHM7XG5cdFx0cmV0dXJuIHNlZ21lbnRzICYmIChzZWdtZW50c1t0aGlzLl9pbmRleCArIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBzZWdtZW50c1swXSkgfHwgbnVsbDtcblx0fSxcblxuXHRnZXRQcmV2aW91czogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9zZWdtZW50cztcblx0XHRyZXR1cm4gc2VnbWVudHMgJiYgKHNlZ21lbnRzW3RoaXMuX2luZGV4IC0gMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdKSB8fCBudWxsO1xuXHR9LFxuXG5cdGlzRmlyc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9pbmRleCA9PT0gMDtcblx0fSxcblxuXHRpc0xhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aDtcblx0XHRyZXR1cm4gcGF0aCAmJiB0aGlzLl9pbmRleCA9PT0gcGF0aC5fc2VnbWVudHMubGVuZ3RoIC0gMSB8fCBmYWxzZTtcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaGFuZGxlSW4gPSB0aGlzLl9oYW5kbGVJbixcblx0XHRcdGhhbmRsZU91dCA9IHRoaXMuX2hhbmRsZU91dCxcblx0XHRcdGluWCA9IGhhbmRsZUluLl94LFxuXHRcdFx0aW5ZID0gaGFuZGxlSW4uX3k7XG5cdFx0aGFuZGxlSW4uc2V0KGhhbmRsZU91dC5feCwgaGFuZGxlT3V0Ll95KTtcblx0XHRoYW5kbGVPdXQuc2V0KGluWCwgaW5ZKTtcblx0fSxcblxuXHRyZXZlcnNlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBTZWdtZW50KHRoaXMuX3BvaW50LCB0aGlzLl9oYW5kbGVPdXQsIHRoaXMuX2hhbmRsZUluKTtcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoID8gISF0aGlzLl9wYXRoLnJlbW92ZVNlZ21lbnQodGhpcy5faW5kZXgpIDogZmFsc2U7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgU2VnbWVudCh0aGlzLl9wb2ludCwgdGhpcy5faGFuZGxlSW4sIHRoaXMuX2hhbmRsZU91dCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzZWdtZW50KSB7XG5cdFx0cmV0dXJuIHNlZ21lbnQgPT09IHRoaXMgfHwgc2VnbWVudCAmJiB0aGlzLl9jbGFzcyA9PT0gc2VnbWVudC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fcG9pbnQuZXF1YWxzKHNlZ21lbnQuX3BvaW50KVxuXHRcdFx0XHQmJiB0aGlzLl9oYW5kbGVJbi5lcXVhbHMoc2VnbWVudC5faGFuZGxlSW4pXG5cdFx0XHRcdCYmIHRoaXMuX2hhbmRsZU91dC5lcXVhbHMoc2VnbWVudC5faGFuZGxlT3V0KVxuXHRcdFx0XHR8fCBmYWxzZTtcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcnRzID0gWyAncG9pbnQ6ICcgKyB0aGlzLl9wb2ludCBdO1xuXHRcdGlmICghdGhpcy5faGFuZGxlSW4uaXNaZXJvKCkpXG5cdFx0XHRwYXJ0cy5wdXNoKCdoYW5kbGVJbjogJyArIHRoaXMuX2hhbmRsZUluKTtcblx0XHRpZiAoIXRoaXMuX2hhbmRsZU91dC5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZU91dDogJyArIHRoaXMuX2hhbmRsZU91dCk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdHRoaXMuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgbmV3IEFycmF5KDYpLCB0cnVlKTtcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0X3RyYW5zZm9ybUNvb3JkaW5hdGVzOiBmdW5jdGlvbihtYXRyaXgsIGNvb3JkcywgY2hhbmdlKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fcG9pbnQsXG5cdFx0XHRoYW5kbGVJbiA9ICFjaGFuZ2UgfHwgIXRoaXMuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0PyB0aGlzLl9oYW5kbGVJbiA6IG51bGwsXG5cdFx0XHRoYW5kbGVPdXQgPSAhY2hhbmdlIHx8ICF0aGlzLl9oYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0XHQ/IHRoaXMuX2hhbmRsZU91dCA6IG51bGwsXG5cdFx0XHR4ID0gcG9pbnQuX3gsXG5cdFx0XHR5ID0gcG9pbnQuX3ksXG5cdFx0XHRpID0gMjtcblx0XHRjb29yZHNbMF0gPSB4O1xuXHRcdGNvb3Jkc1sxXSA9IHk7XG5cdFx0aWYgKGhhbmRsZUluKSB7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZUluLl94ICsgeDtcblx0XHRcdGNvb3Jkc1tpKytdID0gaGFuZGxlSW4uX3kgKyB5O1xuXHRcdH1cblx0XHRpZiAoaGFuZGxlT3V0KSB7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZU91dC5feCArIHg7XG5cdFx0XHRjb29yZHNbaSsrXSA9IGhhbmRsZU91dC5feSArIHk7XG5cdFx0fVxuXHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdG1hdHJpeC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoY29vcmRzLCBjb29yZHMsIGkgLyAyKTtcblx0XHRcdHggPSBjb29yZHNbMF07XG5cdFx0XHR5ID0gY29vcmRzWzFdO1xuXHRcdFx0aWYgKGNoYW5nZSkge1xuXHRcdFx0XHRwb2ludC5feCA9IHg7XG5cdFx0XHRcdHBvaW50Ll95ID0geTtcblx0XHRcdFx0aSAgPSAyO1xuXHRcdFx0XHRpZiAoaGFuZGxlSW4pIHtcblx0XHRcdFx0XHRoYW5kbGVJbi5feCA9IGNvb3Jkc1tpKytdIC0geDtcblx0XHRcdFx0XHRoYW5kbGVJbi5feSA9IGNvb3Jkc1tpKytdIC0geTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaGFuZGxlT3V0KSB7XG5cdFx0XHRcdFx0aGFuZGxlT3V0Ll94ID0gY29vcmRzW2krK10gLSB4O1xuXHRcdFx0XHRcdGhhbmRsZU91dC5feSA9IGNvb3Jkc1tpKytdIC0geTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKCFoYW5kbGVJbikge1xuXHRcdFx0XHRcdGNvb3Jkc1tpKytdID0geDtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFoYW5kbGVPdXQpIHtcblx0XHRcdFx0XHRjb29yZHNbaSsrXSA9IHg7XG5cdFx0XHRcdFx0Y29vcmRzW2krK10gPSB5O1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjb29yZHM7XG5cdH1cbn0pO1xuXG52YXIgU2VnbWVudFBvaW50ID0gUG9pbnQuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU2VnbWVudFBvaW50KHBvaW50LCBvd25lciwga2V5KSB7XG5cdFx0dmFyIHgsIHksIHNlbGVjdGVkO1xuXHRcdGlmICghcG9pbnQpIHtcblx0XHRcdHggPSB5ID0gMDtcblx0XHR9IGVsc2UgaWYgKCh4ID0gcG9pbnRbMF0pICE9PSB1bmRlZmluZWQpIHtcblx0XHRcdHkgPSBwb2ludFsxXTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIHB0ID0gcG9pbnQ7XG5cdFx0XHRpZiAoKHggPSBwdC54KSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdHB0ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHR4ID0gcHQueDtcblx0XHRcdH1cblx0XHRcdHkgPSBwdC55O1xuXHRcdFx0c2VsZWN0ZWQgPSBwdC5zZWxlY3RlZDtcblx0XHR9XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5feSA9IHk7XG5cdFx0dGhpcy5fb3duZXIgPSBvd25lcjtcblx0XHRvd25lcltrZXldID0gdGhpcztcblx0XHRpZiAoc2VsZWN0ZWQpXG5cdFx0XHR0aGlzLnNldFNlbGVjdGVkKHRydWUpO1xuXHR9LFxuXG5cdHNldDogZnVuY3Rpb24oeCwgeSkge1xuXHRcdHRoaXMuX3ggPSB4O1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHR2YXIgZiA9IG9wdGlvbnMuZm9ybWF0dGVyLFxuXHRcdFx0eCA9IGYubnVtYmVyKHRoaXMuX3gpLFxuXHRcdFx0eSA9IGYubnVtYmVyKHRoaXMuX3kpO1xuXHRcdHJldHVybiB0aGlzLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQ/IHsgeDogeCwgeTogeSwgc2VsZWN0ZWQ6IHRydWUgfVxuXHRcdFx0XHQ6IFt4LCB5XTtcblx0fSxcblxuXHRnZXRYOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5feDtcblx0fSxcblxuXHRzZXRYOiBmdW5jdGlvbih4KSB7XG5cdFx0dGhpcy5feCA9IHg7XG5cdFx0dGhpcy5fb3duZXIuX2NoYW5nZWQodGhpcyk7XG5cdH0sXG5cblx0Z2V0WTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3k7XG5cdH0sXG5cblx0c2V0WTogZnVuY3Rpb24oeSkge1xuXHRcdHRoaXMuX3kgPSB5O1xuXHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKHRoaXMpO1xuXHR9LFxuXG5cdGlzWmVybzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5pc1plcm8odGhpcy5feCkgJiYgTnVtZXJpY2FsLmlzWmVybyh0aGlzLl95KTtcblx0fSxcblxuXHRzZXRTZWxlY3RlZDogZnVuY3Rpb24oc2VsZWN0ZWQpIHtcblx0XHR0aGlzLl9vd25lci5zZXRTZWxlY3RlZChzZWxlY3RlZCwgdGhpcyk7XG5cdH0sXG5cblx0aXNTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX293bmVyLmlzU2VsZWN0ZWQodGhpcyk7XG5cdH1cbn0pO1xuXG52YXIgQ3VydmUgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0N1cnZlJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDdXJ2ZShhcmcwLCBhcmcxLCBhcmcyLCBhcmczLCBhcmc0LCBhcmc1LCBhcmc2LCBhcmc3KSB7XG5cdFx0dmFyIGNvdW50ID0gYXJndW1lbnRzLmxlbmd0aCxcblx0XHRcdHNlZzEsIHNlZzIsXG5cdFx0XHRwb2ludDEsIHBvaW50Mixcblx0XHRcdGhhbmRsZTEsIGhhbmRsZTI7XG5cdFx0aWYgKGNvdW50ID09PSAzKSB7XG5cdFx0XHR0aGlzLl9wYXRoID0gYXJnMDtcblx0XHRcdHNlZzEgPSBhcmcxO1xuXHRcdFx0c2VnMiA9IGFyZzI7XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMCkge1xuXHRcdFx0c2VnMSA9IG5ldyBTZWdtZW50KCk7XG5cdFx0XHRzZWcyID0gbmV3IFNlZ21lbnQoKTtcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSAxKSB7XG5cdFx0XHRpZiAoJ3NlZ21lbnQxJyBpbiBhcmcwKSB7XG5cdFx0XHRcdHNlZzEgPSBuZXcgU2VnbWVudChhcmcwLnNlZ21lbnQxKTtcblx0XHRcdFx0c2VnMiA9IG5ldyBTZWdtZW50KGFyZzAuc2VnbWVudDIpO1xuXHRcdFx0fSBlbHNlIGlmICgncG9pbnQxJyBpbiBhcmcwKSB7XG5cdFx0XHRcdHBvaW50MSA9IGFyZzAucG9pbnQxO1xuXHRcdFx0XHRoYW5kbGUxID0gYXJnMC5oYW5kbGUxO1xuXHRcdFx0XHRoYW5kbGUyID0gYXJnMC5oYW5kbGUyO1xuXHRcdFx0XHRwb2ludDIgPSBhcmcwLnBvaW50Mjtcblx0XHRcdH0gZWxzZSBpZiAoQXJyYXkuaXNBcnJheShhcmcwKSkge1xuXHRcdFx0XHRwb2ludDEgPSBbYXJnMFswXSwgYXJnMFsxXV07XG5cdFx0XHRcdHBvaW50MiA9IFthcmcwWzZdLCBhcmcwWzddXTtcblx0XHRcdFx0aGFuZGxlMSA9IFthcmcwWzJdIC0gYXJnMFswXSwgYXJnMFszXSAtIGFyZzBbMV1dO1xuXHRcdFx0XHRoYW5kbGUyID0gW2FyZzBbNF0gLSBhcmcwWzZdLCBhcmcwWzVdIC0gYXJnMFs3XV07XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChjb3VudCA9PT0gMikge1xuXHRcdFx0c2VnMSA9IG5ldyBTZWdtZW50KGFyZzApO1xuXHRcdFx0c2VnMiA9IG5ldyBTZWdtZW50KGFyZzEpO1xuXHRcdH0gZWxzZSBpZiAoY291bnQgPT09IDQpIHtcblx0XHRcdHBvaW50MSA9IGFyZzA7XG5cdFx0XHRoYW5kbGUxID0gYXJnMTtcblx0XHRcdGhhbmRsZTIgPSBhcmcyO1xuXHRcdFx0cG9pbnQyID0gYXJnMztcblx0XHR9IGVsc2UgaWYgKGNvdW50ID09PSA4KSB7XG5cdFx0XHRwb2ludDEgPSBbYXJnMCwgYXJnMV07XG5cdFx0XHRwb2ludDIgPSBbYXJnNiwgYXJnN107XG5cdFx0XHRoYW5kbGUxID0gW2FyZzIgLSBhcmcwLCBhcmczIC0gYXJnMV07XG5cdFx0XHRoYW5kbGUyID0gW2FyZzQgLSBhcmc2LCBhcmc1IC0gYXJnN107XG5cdFx0fVxuXHRcdHRoaXMuX3NlZ21lbnQxID0gc2VnMSB8fCBuZXcgU2VnbWVudChwb2ludDEsIG51bGwsIGhhbmRsZTEpO1xuXHRcdHRoaXMuX3NlZ21lbnQyID0gc2VnMiB8fCBuZXcgU2VnbWVudChwb2ludDIsIGhhbmRsZTIsIG51bGwpO1xuXHR9LFxuXG5cdF9zZXJpYWxpemU6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gQmFzZS5zZXJpYWxpemUodGhpcy5oYXNIYW5kbGVzKClcblx0XHRcdFx0PyBbdGhpcy5nZXRQb2ludDEoKSwgdGhpcy5nZXRIYW5kbGUxKCksIHRoaXMuZ2V0SGFuZGxlMigpLFxuXHRcdFx0XHRcdHRoaXMuZ2V0UG9pbnQyKCldXG5cdFx0XHRcdDogW3RoaXMuZ2V0UG9pbnQxKCksIHRoaXMuZ2V0UG9pbnQyKCldLFxuXHRcdFx0XHRvcHRpb25zLCB0cnVlKTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fbGVuZ3RoID0gdGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50Mik7XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXJ0cyA9IFsgJ3BvaW50MTogJyArIHRoaXMuX3NlZ21lbnQxLl9wb2ludCBdO1xuXHRcdGlmICghdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTE6ICcgKyB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0KTtcblx0XHRpZiAoIXRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5pc1plcm8oKSlcblx0XHRcdHBhcnRzLnB1c2goJ2hhbmRsZTI6ICcgKyB0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4pO1xuXHRcdHBhcnRzLnB1c2goJ3BvaW50MjogJyArIHRoaXMuX3NlZ21lbnQyLl9wb2ludCk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHRyZW1vdmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciByZW1vdmVkID0gZmFsc2U7XG5cdFx0aWYgKHRoaXMuX3BhdGgpIHtcblx0XHRcdHZhciBzZWdtZW50MiA9IHRoaXMuX3NlZ21lbnQyLFxuXHRcdFx0XHRoYW5kbGVPdXQgPSBzZWdtZW50Mi5faGFuZGxlT3V0O1xuXHRcdFx0cmVtb3ZlZCA9IHNlZ21lbnQyLnJlbW92ZSgpO1xuXHRcdFx0aWYgKHJlbW92ZWQpXG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KGhhbmRsZU91dC54LCBoYW5kbGVPdXQueSk7XG5cdFx0fVxuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGdldFBvaW50MTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9zZWdtZW50MS5fcG9pbnQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldFBvaW50MjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQyLl9wb2ludDtcblx0fSxcblxuXHRzZXRQb2ludDI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9zZWdtZW50Mi5fcG9pbnQuc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZTE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0O1xuXHR9LFxuXG5cdHNldEhhbmRsZTE6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9zZWdtZW50MS5faGFuZGxlT3V0LnNldChwb2ludC54LCBwb2ludC55KTtcblx0fSxcblxuXHRnZXRIYW5kbGUyOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluO1xuXHR9LFxuXG5cdHNldEhhbmRsZTI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLl9zZWdtZW50Mi5faGFuZGxlSW4uc2V0KHBvaW50LngsIHBvaW50LnkpO1xuXHR9LFxuXG5cdGdldFNlZ21lbnQxOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudDE7XG5cdH0sXG5cblx0Z2V0U2VnbWVudDI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50Mjtcblx0fSxcblxuXHRnZXRQYXRoOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGF0aDtcblx0fSxcblxuXHRnZXRJbmRleDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9pbmRleDtcblx0fSxcblxuXHRnZXROZXh0OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5fcGF0aCAmJiB0aGlzLl9wYXRoLl9jdXJ2ZXM7XG5cdFx0cmV0dXJuIGN1cnZlcyAmJiAoY3VydmVzW3RoaXMuX3NlZ21lbnQxLl9pbmRleCArIDFdXG5cdFx0XHRcdHx8IHRoaXMuX3BhdGguX2Nsb3NlZCAmJiBjdXJ2ZXNbMF0pIHx8IG51bGw7XG5cdH0sXG5cblx0Z2V0UHJldmlvdXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9wYXRoICYmIHRoaXMuX3BhdGguX2N1cnZlcztcblx0XHRyZXR1cm4gY3VydmVzICYmIChjdXJ2ZXNbdGhpcy5fc2VnbWVudDEuX2luZGV4IC0gMV1cblx0XHRcdFx0fHwgdGhpcy5fcGF0aC5fY2xvc2VkICYmIGN1cnZlc1tjdXJ2ZXMubGVuZ3RoIC0gMV0pIHx8IG51bGw7XG5cdH0sXG5cblx0aXNGaXJzdDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnQxLl9pbmRleCA9PT0gMDtcblx0fSxcblxuXHRpc0xhc3Q6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aDtcblx0XHRyZXR1cm4gcGF0aCAmJiB0aGlzLl9zZWdtZW50MS5faW5kZXggPT09IHBhdGguX2N1cnZlcy5sZW5ndGggLSAxXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdGlzU2VsZWN0ZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldFBvaW50MSgpLmlzU2VsZWN0ZWQoKVxuXHRcdFx0XHQmJiB0aGlzLmdldEhhbmRsZTIoKS5pc1NlbGVjdGVkKClcblx0XHRcdFx0JiYgdGhpcy5nZXRIYW5kbGUyKCkuaXNTZWxlY3RlZCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0UG9pbnQyKCkuaXNTZWxlY3RlZCgpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdHRoaXMuZ2V0UG9pbnQxKCkuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHRcdHRoaXMuZ2V0SGFuZGxlMSgpLnNldFNlbGVjdGVkKHNlbGVjdGVkKTtcblx0XHR0aGlzLmdldEhhbmRsZTIoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdFx0dGhpcy5nZXRQb2ludDIoKS5zZXRTZWxlY3RlZChzZWxlY3RlZCk7XG5cdH0sXG5cblx0Z2V0VmFsdWVzOiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHRyZXR1cm4gQ3VydmUuZ2V0VmFsdWVzKHRoaXMuX3NlZ21lbnQxLCB0aGlzLl9zZWdtZW50MiwgbWF0cml4KTtcblx0fSxcblxuXHRnZXRQb2ludHM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjb29yZHMgPSB0aGlzLmdldFZhbHVlcygpLFxuXHRcdFx0cG9pbnRzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCA4OyBpICs9IDIpXG5cdFx0XHRwb2ludHMucHVzaChuZXcgUG9pbnQoY29vcmRzW2ldLCBjb29yZHNbaSArIDFdKSk7XG5cdFx0cmV0dXJuIHBvaW50cztcblx0fSxcblxuXHRnZXRMZW5ndGg6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9sZW5ndGggPT0gbnVsbClcblx0XHRcdHRoaXMuX2xlbmd0aCA9IEN1cnZlLmdldExlbmd0aCh0aGlzLmdldFZhbHVlcygpLCAwLCAxKTtcblx0XHRyZXR1cm4gdGhpcy5fbGVuZ3RoO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRBcmVhKHRoaXMuZ2V0VmFsdWVzKCkpO1xuXHR9LFxuXG5cdGdldExpbmU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBuZXcgTGluZSh0aGlzLl9zZWdtZW50MS5fcG9pbnQsIHRoaXMuX3NlZ21lbnQyLl9wb2ludCk7XG5cdH0sXG5cblx0Z2V0UGFydDogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHRyZXR1cm4gbmV3IEN1cnZlKEN1cnZlLmdldFBhcnQodGhpcy5nZXRWYWx1ZXMoKSwgZnJvbSwgdG8pKTtcblx0fSxcblxuXHRnZXRQYXJ0TGVuZ3RoOiBmdW5jdGlvbihmcm9tLCB0bykge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRMZW5ndGgodGhpcy5nZXRWYWx1ZXMoKSwgZnJvbSwgdG8pO1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbnM6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0cmV0dXJuIEN1cnZlLl9nZXRJbnRlcnNlY3Rpb25zKHRoaXMuZ2V0VmFsdWVzKCksXG5cdFx0XHRcdGN1cnZlICYmIGN1cnZlICE9PSB0aGlzID8gY3VydmUuZ2V0VmFsdWVzKCkgOiBudWxsLFxuXHRcdFx0XHR0aGlzLCBjdXJ2ZSwgW10sIHt9KTtcblx0fSxcblxuXHRfZ2V0UGFyYW1ldGVyOiBmdW5jdGlvbihvZmZzZXQsIGlzUGFyYW1ldGVyKSB7XG5cdFx0cmV0dXJuIGlzUGFyYW1ldGVyXG5cdFx0XHRcdD8gb2Zmc2V0XG5cdFx0XHRcdDogb2Zmc2V0ICYmIG9mZnNldC5jdXJ2ZSA9PT0gdGhpc1xuXHRcdFx0XHRcdD8gb2Zmc2V0LnBhcmFtZXRlclxuXHRcdFx0XHRcdDogb2Zmc2V0ID09PSB1bmRlZmluZWQgJiYgaXNQYXJhbWV0ZXIgPT09IHVuZGVmaW5lZFxuXHRcdFx0XHRcdFx0PyAwLjVcblx0XHRcdFx0XHRcdDogdGhpcy5nZXRQYXJhbWV0ZXJBdChvZmZzZXQsIDApO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlciwgX3NldEhhbmRsZXMpIHtcblx0XHR2YXIgcGFyYW1ldGVyID0gdGhpcy5fZ2V0UGFyYW1ldGVyKG9mZnNldCwgaXNQYXJhbWV0ZXIpLFxuXHRcdFx0dE1pbiA9IDRlLTcsXG5cdFx0XHR0TWF4ID0gMSAtIHRNaW4sXG5cdFx0XHRyZXMgPSBudWxsO1xuXHRcdGlmIChwYXJhbWV0ZXIgPj0gdE1pbiAmJiBwYXJhbWV0ZXIgPD0gdE1heCkge1xuXHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHRoaXMuZ2V0VmFsdWVzKCksIHBhcmFtZXRlciksXG5cdFx0XHRcdGxlZnQgPSBwYXJ0c1swXSxcblx0XHRcdFx0cmlnaHQgPSBwYXJ0c1sxXSxcblx0XHRcdFx0c2V0SGFuZGxlcyA9IF9zZXRIYW5kbGVzIHx8IHRoaXMuaGFzSGFuZGxlcygpLFxuXHRcdFx0XHRzZWdtZW50MSA9IHRoaXMuX3NlZ21lbnQxLFxuXHRcdFx0XHRzZWdtZW50MiA9IHRoaXMuX3NlZ21lbnQyLFxuXHRcdFx0XHRwYXRoID0gdGhpcy5fcGF0aDtcblx0XHRcdGlmIChzZXRIYW5kbGVzKSB7XG5cdFx0XHRcdHNlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KGxlZnRbMl0gLSBsZWZ0WzBdLFxuXHRcdFx0XHRcdFx0bGVmdFszXSAtIGxlZnRbMV0pO1xuXHRcdFx0XHRzZWdtZW50Mi5faGFuZGxlSW4uc2V0KHJpZ2h0WzRdIC0gcmlnaHRbNl0sXG5cdFx0XHRcdFx0XHRyaWdodFs1XSAtIHJpZ2h0WzddKTtcblx0XHRcdH1cblx0XHRcdHZhciB4ID0gbGVmdFs2XSwgeSA9IGxlZnRbN10sXG5cdFx0XHRcdHNlZ21lbnQgPSBuZXcgU2VnbWVudChuZXcgUG9pbnQoeCwgeSksXG5cdFx0XHRcdFx0XHRzZXRIYW5kbGVzICYmIG5ldyBQb2ludChsZWZ0WzRdIC0geCwgbGVmdFs1XSAtIHkpLFxuXHRcdFx0XHRcdFx0c2V0SGFuZGxlcyAmJiBuZXcgUG9pbnQocmlnaHRbMl0gLSB4LCByaWdodFszXSAtIHkpKTtcblx0XHRcdGlmIChwYXRoKSB7XG5cdFx0XHRcdHBhdGguaW5zZXJ0KHNlZ21lbnQxLl9pbmRleCArIDEsIHNlZ21lbnQpO1xuXHRcdFx0XHRyZXMgPSB0aGlzLmdldE5leHQoKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuX3NlZ21lbnQyID0gc2VnbWVudDtcblx0XHRcdFx0cmVzID0gbmV3IEN1cnZlKHNlZ21lbnQsIHNlZ21lbnQyKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHRzcGxpdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHJldHVybiB0aGlzLl9wYXRoXG5cdFx0XHQ/IHRoaXMuX3BhdGguc3BsaXQodGhpcy5fc2VnbWVudDEuX2luZGV4LFxuXHRcdFx0XHRcdHRoaXMuX2dldFBhcmFtZXRlcihvZmZzZXQsIGlzUGFyYW1ldGVyKSlcblx0XHRcdDogbnVsbDtcblx0fSxcblxuXHRyZXZlcnNlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBDdXJ2ZSh0aGlzLl9zZWdtZW50Mi5yZXZlcnNlZCgpLCB0aGlzLl9zZWdtZW50MS5yZXZlcnNlZCgpKTtcblx0fSxcblxuXHRjbGVhckhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMuX3NlZ21lbnQxLl9oYW5kbGVPdXQuc2V0KDAsIDApO1xuXHRcdHRoaXMuX3NlZ21lbnQyLl9oYW5kbGVJbi5zZXQoMCwgMCk7XG5cdH0sXG5cbnN0YXRpY3M6IHtcblx0Z2V0VmFsdWVzOiBmdW5jdGlvbihzZWdtZW50MSwgc2VnbWVudDIsIG1hdHJpeCkge1xuXHRcdHZhciBwMSA9IHNlZ21lbnQxLl9wb2ludCxcblx0XHRcdGgxID0gc2VnbWVudDEuX2hhbmRsZU91dCxcblx0XHRcdGgyID0gc2VnbWVudDIuX2hhbmRsZUluLFxuXHRcdFx0cDIgPSBzZWdtZW50Mi5fcG9pbnQsXG5cdFx0XHR2YWx1ZXMgPSBbXG5cdFx0XHRcdHAxLl94LCBwMS5feSxcblx0XHRcdFx0cDEuX3ggKyBoMS5feCwgcDEuX3kgKyBoMS5feSxcblx0XHRcdFx0cDIuX3ggKyBoMi5feCwgcDIuX3kgKyBoMi5feSxcblx0XHRcdFx0cDIuX3gsIHAyLl95XG5cdFx0XHRdO1xuXHRcdGlmIChtYXRyaXgpXG5cdFx0XHRtYXRyaXguX3RyYW5zZm9ybUNvb3JkaW5hdGVzKHZhbHVlcywgdmFsdWVzLCA0KTtcblx0XHRyZXR1cm4gdmFsdWVzO1xuXHR9LFxuXG5cdHN1YmRpdmlkZTogZnVuY3Rpb24odiwgdCkge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddO1xuXHRcdGlmICh0ID09PSB1bmRlZmluZWQpXG5cdFx0XHR0ID0gMC41O1xuXHRcdHZhciB1ID0gMSAtIHQsXG5cdFx0XHRwM3ggPSB1ICogcDF4ICsgdCAqIGMxeCwgcDN5ID0gdSAqIHAxeSArIHQgKiBjMXksXG5cdFx0XHRwNHggPSB1ICogYzF4ICsgdCAqIGMyeCwgcDR5ID0gdSAqIGMxeSArIHQgKiBjMnksXG5cdFx0XHRwNXggPSB1ICogYzJ4ICsgdCAqIHAyeCwgcDV5ID0gdSAqIGMyeSArIHQgKiBwMnksXG5cdFx0XHRwNnggPSB1ICogcDN4ICsgdCAqIHA0eCwgcDZ5ID0gdSAqIHAzeSArIHQgKiBwNHksXG5cdFx0XHRwN3ggPSB1ICogcDR4ICsgdCAqIHA1eCwgcDd5ID0gdSAqIHA0eSArIHQgKiBwNXksXG5cdFx0XHRwOHggPSB1ICogcDZ4ICsgdCAqIHA3eCwgcDh5ID0gdSAqIHA2eSArIHQgKiBwN3k7XG5cdFx0cmV0dXJuIFtcblx0XHRcdFtwMXgsIHAxeSwgcDN4LCBwM3ksIHA2eCwgcDZ5LCBwOHgsIHA4eV0sXG5cdFx0XHRbcDh4LCBwOHksIHA3eCwgcDd5LCBwNXgsIHA1eSwgcDJ4LCBwMnldXG5cdFx0XTtcblx0fSxcblxuXHRzb2x2ZUN1YmljOiBmdW5jdGlvbiAodiwgY29vcmQsIHZhbCwgcm9vdHMsIG1pbiwgbWF4KSB7XG5cdFx0dmFyIHAxID0gdltjb29yZF0sXG5cdFx0XHRjMSA9IHZbY29vcmQgKyAyXSxcblx0XHRcdGMyID0gdltjb29yZCArIDRdLFxuXHRcdFx0cDIgPSB2W2Nvb3JkICsgNl0sXG5cdFx0XHRjID0gMyAqIChjMSAtIHAxKSxcblx0XHRcdGIgPSAzICogKGMyIC0gYzEpIC0gYyxcblx0XHRcdGEgPSBwMiAtIHAxIC0gYyAtIGI7XG5cdFx0cmV0dXJuIE51bWVyaWNhbC5zb2x2ZUN1YmljKGEsIGIsIGMsIHAxIC0gdmFsLCByb290cywgbWluLCBtYXgpO1xuXHR9LFxuXG5cdGdldFBhcmFtZXRlck9mOiBmdW5jdGlvbih2LCBwb2ludCkge1xuXHRcdHZhciBwMSA9IG5ldyBQb2ludCh2WzBdLCB2WzFdKSxcblx0XHRcdHAyID0gbmV3IFBvaW50KHZbNl0sIHZbN10pLFxuXHRcdFx0ZXBzaWxvbiA9IDFlLTEyLFxuXHRcdFx0dCA9IHBvaW50LmlzQ2xvc2UocDEsIGVwc2lsb24pID8gMFxuXHRcdFx0ICA6IHBvaW50LmlzQ2xvc2UocDIsIGVwc2lsb24pID8gMVxuXHRcdFx0ICA6IG51bGw7XG5cdFx0aWYgKHQgIT09IG51bGwpXG5cdFx0XHRyZXR1cm4gdDtcblx0XHR2YXIgY29vcmRzID0gW3BvaW50LngsIHBvaW50LnldLFxuXHRcdFx0cm9vdHMgPSBbXSxcblx0XHRcdGdlb21FcHNpbG9uID0gMmUtNztcblx0XHRmb3IgKHZhciBjID0gMDsgYyA8IDI7IGMrKykge1xuXHRcdFx0dmFyIGNvdW50ID0gQ3VydmUuc29sdmVDdWJpYyh2LCBjLCBjb29yZHNbY10sIHJvb3RzLCAwLCAxKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKykge1xuXHRcdFx0XHR0ID0gcm9vdHNbaV07XG5cdFx0XHRcdGlmIChwb2ludC5pc0Nsb3NlKEN1cnZlLmdldFBvaW50KHYsIHQpLCBnZW9tRXBzaWxvbikpXG5cdFx0XHRcdFx0cmV0dXJuIHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludC5pc0Nsb3NlKHAxLCBnZW9tRXBzaWxvbikgPyAwXG5cdFx0XHQgOiBwb2ludC5pc0Nsb3NlKHAyLCBnZW9tRXBzaWxvbikgPyAxXG5cdFx0XHQgOiBudWxsO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RQYXJhbWV0ZXI6IGZ1bmN0aW9uKHYsIHBvaW50KSB7XG5cdFx0aWYgKEN1cnZlLmlzU3RyYWlnaHQodikpIHtcblx0XHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddLFxuXHRcdFx0XHR2eCA9IHAyeCAtIHAxeCwgdnkgPSBwMnkgLSBwMXksXG5cdFx0XHRcdGRldCA9IHZ4ICogdnggKyB2eSAqIHZ5O1xuXHRcdFx0aWYgKGRldCA9PT0gMClcblx0XHRcdFx0cmV0dXJuIDA7XG5cdFx0XHR2YXIgdSA9ICgocG9pbnQueCAtIHAxeCkgKiB2eCArIChwb2ludC55IC0gcDF5KSAqIHZ5KSAvIGRldDtcblx0XHRcdHJldHVybiB1IDwgMWUtMTIgPyAwXG5cdFx0XHRcdCA6IHUgPiAwLjk5OTk5OTk5OTk5OSA/IDFcblx0XHRcdFx0IDogQ3VydmUuZ2V0UGFyYW1ldGVyT2Yodixcblx0XHRcdFx0XHRuZXcgUG9pbnQocDF4ICsgdSAqIHZ4LCBwMXkgKyB1ICogdnkpKTtcblx0XHR9XG5cblx0XHR2YXIgY291bnQgPSAxMDAsXG5cdFx0XHRtaW5EaXN0ID0gSW5maW5pdHksXG5cdFx0XHRtaW5UID0gMDtcblxuXHRcdGZ1bmN0aW9uIHJlZmluZSh0KSB7XG5cdFx0XHRpZiAodCA+PSAwICYmIHQgPD0gMSkge1xuXHRcdFx0XHR2YXIgZGlzdCA9IHBvaW50LmdldERpc3RhbmNlKEN1cnZlLmdldFBvaW50KHYsIHQpLCB0cnVlKTtcblx0XHRcdFx0aWYgKGRpc3QgPCBtaW5EaXN0KSB7XG5cdFx0XHRcdFx0bWluRGlzdCA9IGRpc3Q7XG5cdFx0XHRcdFx0bWluVCA9IHQ7XG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8PSBjb3VudDsgaSsrKVxuXHRcdFx0cmVmaW5lKGkgLyBjb3VudCk7XG5cblx0XHR2YXIgc3RlcCA9IDEgLyAoY291bnQgKiAyKTtcblx0XHR3aGlsZSAoc3RlcCA+IDRlLTcpIHtcblx0XHRcdGlmICghcmVmaW5lKG1pblQgLSBzdGVwKSAmJiAhcmVmaW5lKG1pblQgKyBzdGVwKSlcblx0XHRcdFx0c3RlcCAvPSAyO1xuXHRcdH1cblx0XHRyZXR1cm4gbWluVDtcblx0fSxcblxuXHRnZXRQYXJ0OiBmdW5jdGlvbih2LCBmcm9tLCB0bykge1xuXHRcdHZhciBmbGlwID0gZnJvbSA+IHRvO1xuXHRcdGlmIChmbGlwKSB7XG5cdFx0XHR2YXIgdG1wID0gZnJvbTtcblx0XHRcdGZyb20gPSB0bztcblx0XHRcdHRvID0gdG1wO1xuXHRcdH1cblx0XHRpZiAoZnJvbSA+IDApXG5cdFx0XHR2ID0gQ3VydmUuc3ViZGl2aWRlKHYsIGZyb20pWzFdO1xuXHRcdGlmICh0byA8IDEpXG5cdFx0XHR2ID0gQ3VydmUuc3ViZGl2aWRlKHYsICh0byAtIGZyb20pIC8gKDEgLSBmcm9tKSlbMF07XG5cdFx0cmV0dXJuIGZsaXBcblx0XHRcdFx0PyBbdls2XSwgdls3XSwgdls0XSwgdls1XSwgdlsyXSwgdlszXSwgdlswXSwgdlsxXV1cblx0XHRcdFx0OiB2O1xuXHR9LFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgaXNaZXJvID0gTnVtZXJpY2FsLmlzWmVybztcblx0XHRyZXR1cm4gIShpc1plcm8odlswXSAtIHZbMl0pICYmIGlzWmVybyh2WzFdIC0gdlszXSlcblx0XHRcdFx0JiYgaXNaZXJvKHZbNF0gLSB2WzZdKSAmJiBpc1plcm8odls1XSAtIHZbN10pKTtcblx0fSxcblxuXHRpc0ZsYXRFbm91Z2g6IGZ1bmN0aW9uKHYsIHRvbGVyYW5jZSkge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0YzF4ID0gdlsyXSwgYzF5ID0gdlszXSxcblx0XHRcdGMyeCA9IHZbNF0sIGMyeSA9IHZbNV0sXG5cdFx0XHRwMnggPSB2WzZdLCBwMnkgPSB2WzddLFxuXHRcdFx0dXggPSAzICogYzF4IC0gMiAqIHAxeCAtIHAyeCxcblx0XHRcdHV5ID0gMyAqIGMxeSAtIDIgKiBwMXkgLSBwMnksXG5cdFx0XHR2eCA9IDMgKiBjMnggLSAyICogcDJ4IC0gcDF4LFxuXHRcdFx0dnkgPSAzICogYzJ5IC0gMiAqIHAyeSAtIHAxeTtcblx0XHRyZXR1cm4gTWF0aC5tYXgodXggKiB1eCwgdnggKiB2eCkgKyBNYXRoLm1heCh1eSAqIHV5LCB2eSAqIHZ5KVxuXHRcdFx0XHQ8IDEwICogdG9sZXJhbmNlICogdG9sZXJhbmNlO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cdFx0XHRoMXggPSAodlsyXSArIHAxeCkgLyAyLFxuXHRcdFx0aDF5ID0gKHZbM10gKyBwMXkpIC8gMixcblx0XHRcdGgyeCA9ICh2WzRdICsgdls2XSkgLyAyLFxuXHRcdFx0aDJ5ID0gKHZbNV0gKyB2WzddKSAvIDI7XG5cdFx0cmV0dXJuIDYgKiAoKHAxeCAtIGgxeCkgKiAoaDF5ICsgcDF5KVxuXHRcdFx0XHQgICsgKGgxeCAtIGgyeCkgKiAoaDJ5ICsgaDF5KVxuXHRcdFx0XHQgICsgKGgyeCAtIHAyeCkgKiAocDJ5ICsgaDJ5KSkgLyAxMDtcblx0fSxcblxuXHRnZXRCb3VuZHM6IGZ1bmN0aW9uKHYpIHtcblx0XHR2YXIgbWluID0gdi5zbGljZSgwLCAyKSxcblx0XHRcdG1heCA9IG1pbi5zbGljZSgpLFxuXHRcdFx0cm9vdHMgPSBbMCwgMF07XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAyOyBpKyspXG5cdFx0XHRDdXJ2ZS5fYWRkQm91bmRzKHZbaV0sIHZbaSArIDJdLCB2W2kgKyA0XSwgdltpICsgNl0sXG5cdFx0XHRcdFx0aSwgMCwgbWluLCBtYXgsIHJvb3RzKTtcblx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZShtaW5bMF0sIG1pblsxXSwgbWF4WzBdIC0gbWluWzBdLCBtYXhbMV0gLSBtaW5bMV0pO1xuXHR9LFxuXG5cdF9hZGRCb3VuZHM6IGZ1bmN0aW9uKHYwLCB2MSwgdjIsIHYzLCBjb29yZCwgcGFkZGluZywgbWluLCBtYXgsIHJvb3RzKSB7XG5cdFx0ZnVuY3Rpb24gYWRkKHZhbHVlLCBwYWRkaW5nKSB7XG5cdFx0XHR2YXIgbGVmdCA9IHZhbHVlIC0gcGFkZGluZyxcblx0XHRcdFx0cmlnaHQgPSB2YWx1ZSArIHBhZGRpbmc7XG5cdFx0XHRpZiAobGVmdCA8IG1pbltjb29yZF0pXG5cdFx0XHRcdG1pbltjb29yZF0gPSBsZWZ0O1xuXHRcdFx0aWYgKHJpZ2h0ID4gbWF4W2Nvb3JkXSlcblx0XHRcdFx0bWF4W2Nvb3JkXSA9IHJpZ2h0O1xuXHRcdH1cblx0XHR2YXIgYSA9IDMgKiAodjEgLSB2MikgLSB2MCArIHYzLFxuXHRcdFx0YiA9IDIgKiAodjAgKyB2MikgLSA0ICogdjEsXG5cdFx0XHRjID0gdjEgLSB2MCxcblx0XHRcdGNvdW50ID0gTnVtZXJpY2FsLnNvbHZlUXVhZHJhdGljKGEsIGIsIGMsIHJvb3RzKSxcblx0XHRcdHRNaW4gPSA0ZS03LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdGFkZCh2MywgMCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBjb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgdCA9IHJvb3RzW2ldLFxuXHRcdFx0XHR1ID0gMSAtIHQ7XG5cdFx0XHRpZiAodE1pbiA8IHQgJiYgdCA8IHRNYXgpXG5cdFx0XHRcdGFkZCh1ICogdSAqIHUgKiB2MFxuXHRcdFx0XHRcdCsgMyAqIHUgKiB1ICogdCAqIHYxXG5cdFx0XHRcdFx0KyAzICogdSAqIHQgKiB0ICogdjJcblx0XHRcdFx0XHQrIHQgKiB0ICogdCAqIHYzLFxuXHRcdFx0XHRcdHBhZGRpbmcpO1xuXHRcdH1cblx0fVxufX0sIEJhc2UuZWFjaChcblx0WydnZXRCb3VuZHMnLCAnZ2V0U3Ryb2tlQm91bmRzJywgJ2dldEhhbmRsZUJvdW5kcycsICdnZXRSb3VnaEJvdW5kcyddLFxuXHRmdW5jdGlvbihuYW1lKSB7XG5cdFx0dGhpc1tuYW1lXSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKCF0aGlzLl9ib3VuZHMpXG5cdFx0XHRcdHRoaXMuX2JvdW5kcyA9IHt9O1xuXHRcdFx0dmFyIGJvdW5kcyA9IHRoaXMuX2JvdW5kc1tuYW1lXTtcblx0XHRcdGlmICghYm91bmRzKSB7XG5cdFx0XHRcdHZhciBwYXRoID0gdGhpcy5fcGF0aDtcblx0XHRcdFx0Ym91bmRzID0gdGhpcy5fYm91bmRzW25hbWVdID0gUGF0aFtuYW1lXShcblx0XHRcdFx0XHRcdFt0aGlzLl9zZWdtZW50MSwgdGhpcy5fc2VnbWVudDJdLCBmYWxzZSxcblx0XHRcdFx0XHRcdHBhdGggJiYgcGF0aC5nZXRTdHlsZSgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBib3VuZHMuY2xvbmUoKTtcblx0XHR9O1xuXHR9LFxue1xuXG59KSwgQmFzZS5lYWNoKHtcblx0aXNTdHJhaWdodDogZnVuY3Rpb24obCwgaDEsIGgyKSB7XG5cdFx0aWYgKGgxLmlzWmVybygpICYmIGgyLmlzWmVybygpKSB7XG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHR9IGVsc2UgaWYgKGwuaXNaZXJvKCkpIHtcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9IGVsc2UgaWYgKGgxLmlzQ29sbGluZWFyKGwpICYmIGgyLmlzQ29sbGluZWFyKGwpKSB7XG5cdFx0XHR2YXIgZGl2ID0gbC5kb3QobCksXG5cdFx0XHRcdHAxID0gbC5kb3QoaDEpIC8gZGl2LFxuXHRcdFx0XHRwMiA9IGwuZG90KGgyKSAvIGRpdjtcblx0XHRcdHJldHVybiBwMSA+PSAwICYmIHAxIDw9IDEgJiYgcDIgPD0gMCAmJiBwMiA+PSAtMTtcblx0XHR9XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9LFxuXG5cdGlzTGluZWFyOiBmdW5jdGlvbihsLCBoMSwgaDIpIHtcblx0XHR2YXIgdGhpcmQgPSBsLmRpdmlkZSgzKTtcblx0XHRyZXR1cm4gaDEuZXF1YWxzKHRoaXJkKSAmJiBoMi5uZWdhdGUoKS5lcXVhbHModGhpcmQpO1xuXHR9XG59LCBmdW5jdGlvbih0ZXN0LCBuYW1lKSB7XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnMSA9IHRoaXMuX3NlZ21lbnQxLFxuXHRcdFx0c2VnMiA9IHRoaXMuX3NlZ21lbnQyO1xuXHRcdHJldHVybiB0ZXN0KHNlZzIuX3BvaW50LnN1YnRyYWN0KHNlZzEuX3BvaW50KSxcblx0XHRcdFx0c2VnMS5faGFuZGxlT3V0LCBzZWcyLl9oYW5kbGVJbik7XG5cdH07XG5cblx0dGhpcy5zdGF0aWNzW25hbWVdID0gZnVuY3Rpb24odikge1xuXHRcdHZhciBwMXggPSB2WzBdLCBwMXkgPSB2WzFdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XTtcblx0XHRyZXR1cm4gdGVzdChuZXcgUG9pbnQocDJ4IC0gcDF4LCBwMnkgLSBwMXkpLFxuXHRcdFx0XHRuZXcgUG9pbnQodlsyXSAtIHAxeCwgdlszXSAtIHAxeSksXG5cdFx0XHRcdG5ldyBQb2ludCh2WzRdIC0gcDJ4LCB2WzVdIC0gcDJ5KSk7XG5cdH07XG59LCB7XG5cdHN0YXRpY3M6IHt9LFxuXG5cdGhhc0hhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhdGhpcy5fc2VnbWVudDEuX2hhbmRsZU91dC5pc1plcm8oKVxuXHRcdFx0XHR8fCAhdGhpcy5fc2VnbWVudDIuX2hhbmRsZUluLmlzWmVybygpO1xuXHR9LFxuXG5cdGlzQ29sbGluZWFyOiBmdW5jdGlvbihjdXJ2ZSkge1xuXHRcdHJldHVybiBjdXJ2ZSAmJiB0aGlzLmlzU3RyYWlnaHQoKSAmJiBjdXJ2ZS5pc1N0cmFpZ2h0KClcblx0XHRcdFx0JiYgdGhpcy5nZXRMaW5lKCkuaXNDb2xsaW5lYXIoY3VydmUuZ2V0TGluZSgpKTtcblx0fSxcblxuXHRpc0hvcml6b250YWw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmlzU3RyYWlnaHQoKSAmJiBNYXRoLmFicyh0aGlzLmdldFRhbmdlbnRBdCgwLjUsIHRydWUpLnkpXG5cdFx0XHRcdDwgMWUtNztcblx0fSxcblxuXHRpc1ZlcnRpY2FsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5pc1N0cmFpZ2h0KCkgJiYgTWF0aC5hYnModGhpcy5nZXRUYW5nZW50QXQoMC41LCB0cnVlKS54KVxuXHRcdFx0XHQ8IDFlLTc7XG5cdH1cbn0pLCB7XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRQYXJhbWV0ZXJBdDogZnVuY3Rpb24ob2Zmc2V0LCBzdGFydCkge1xuXHRcdHJldHVybiBDdXJ2ZS5nZXRQYXJhbWV0ZXJBdCh0aGlzLmdldFZhbHVlcygpLCBvZmZzZXQsIHN0YXJ0KTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXJPZjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIEN1cnZlLmdldFBhcmFtZXRlck9mKHRoaXMuZ2V0VmFsdWVzKCksIFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25BdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHZhciB0ID0gaXNQYXJhbWV0ZXIgPyBvZmZzZXQgOiB0aGlzLmdldFBhcmFtZXRlckF0KG9mZnNldCk7XG5cdFx0cmV0dXJuIHQgIT0gbnVsbCAmJiB0ID49IDAgJiYgdCA8PSAxXG5cdFx0XHRcdD8gbmV3IEN1cnZlTG9jYXRpb24odGhpcywgdClcblx0XHRcdFx0OiBudWxsO1xuXHR9LFxuXG5cdGdldExvY2F0aW9uT2Y6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldExvY2F0aW9uQXQodGhpcy5nZXRQYXJhbWV0ZXJPZihQb2ludC5yZWFkKGFyZ3VtZW50cykpLFxuXHRcdFx0XHR0cnVlKTtcblx0fSxcblxuXHRnZXRPZmZzZXRPZjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxvYyA9IHRoaXMuZ2V0TG9jYXRpb25PZi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHRcdHJldHVybiBsb2MgPyBsb2MuZ2V0T2Zmc2V0KCkgOiBudWxsO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RMb2NhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0dmFsdWVzID0gdGhpcy5nZXRWYWx1ZXMoKSxcblx0XHRcdHQgPSBDdXJ2ZS5nZXROZWFyZXN0UGFyYW1ldGVyKHZhbHVlcywgcG9pbnQpLFxuXHRcdFx0cHQgPSBDdXJ2ZS5nZXRQb2ludCh2YWx1ZXMsIHQpO1xuXHRcdHJldHVybiBuZXcgQ3VydmVMb2NhdGlvbih0aGlzLCB0LCBwdCwgbnVsbCwgcG9pbnQuZ2V0RGlzdGFuY2UocHQpKTtcblx0fSxcblxuXHRnZXROZWFyZXN0UG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldE5lYXJlc3RMb2NhdGlvbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpLmdldFBvaW50KCk7XG5cdH1cblxufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG1ldGhvZHMgPSBbJ2dldFBvaW50JywgJ2dldFRhbmdlbnQnLCAnZ2V0Tm9ybWFsJywgJ2dldFdlaWdodGVkVGFuZ2VudCcsXG5cdFx0J2dldFdlaWdodGVkTm9ybWFsJywgJ2dldEN1cnZhdHVyZSddO1xuXHRyZXR1cm4gQmFzZS5lYWNoKG1ldGhvZHMsXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHRcdHZhciB2YWx1ZXMgPSB0aGlzLmdldFZhbHVlcygpO1xuXHRcdFx0cmV0dXJuIEN1cnZlW25hbWVdKHZhbHVlcywgaXNQYXJhbWV0ZXIgPyBvZmZzZXRcblx0XHRcdFx0XHQ6IEN1cnZlLmdldFBhcmFtZXRlckF0KHZhbHVlcywgb2Zmc2V0LCAwKSk7XG5cdFx0fTtcblx0fSwge1xuXHRcdHN0YXRpY3M6IHtcblx0XHRcdGV2YWx1YXRlTWV0aG9kczogbWV0aG9kc1xuXHRcdH1cblx0fSlcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZ2V0TGVuZ3RoSW50ZWdyYW5kKHYpIHtcblx0XHR2YXIgcDF4ID0gdlswXSwgcDF5ID0gdlsxXSxcblx0XHRcdGMxeCA9IHZbMl0sIGMxeSA9IHZbM10sXG5cdFx0XHRjMnggPSB2WzRdLCBjMnkgPSB2WzVdLFxuXHRcdFx0cDJ4ID0gdls2XSwgcDJ5ID0gdls3XSxcblxuXHRcdFx0YXggPSA5ICogKGMxeCAtIGMyeCkgKyAzICogKHAyeCAtIHAxeCksXG5cdFx0XHRieCA9IDYgKiAocDF4ICsgYzJ4KSAtIDEyICogYzF4LFxuXHRcdFx0Y3ggPSAzICogKGMxeCAtIHAxeCksXG5cblx0XHRcdGF5ID0gOSAqIChjMXkgLSBjMnkpICsgMyAqIChwMnkgLSBwMXkpLFxuXHRcdFx0YnkgPSA2ICogKHAxeSArIGMyeSkgLSAxMiAqIGMxeSxcblx0XHRcdGN5ID0gMyAqIChjMXkgLSBwMXkpO1xuXG5cdFx0cmV0dXJuIGZ1bmN0aW9uKHQpIHtcblx0XHRcdHZhciBkeCA9IChheCAqIHQgKyBieCkgKiB0ICsgY3gsXG5cdFx0XHRcdGR5ID0gKGF5ICogdCArIGJ5KSAqIHQgKyBjeTtcblx0XHRcdHJldHVybiBNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpO1xuXHRcdH07XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRJdGVyYXRpb25zKGEsIGIpIHtcblx0XHRyZXR1cm4gTWF0aC5tYXgoMiwgTWF0aC5taW4oMTYsIE1hdGguY2VpbChNYXRoLmFicyhiIC0gYSkgKiAzMikpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV2YWx1YXRlKHYsIHQsIHR5cGUsIG5vcm1hbGl6ZWQpIHtcblx0XHRpZiAodCA9PSBudWxsIHx8IHQgPCAwIHx8IHQgPiAxKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIHAxeCA9IHZbMF0sIHAxeSA9IHZbMV0sXG5cdFx0XHRjMXggPSB2WzJdLCBjMXkgPSB2WzNdLFxuXHRcdFx0YzJ4ID0gdls0XSwgYzJ5ID0gdls1XSxcblx0XHRcdHAyeCA9IHZbNl0sIHAyeSA9IHZbN10sXG5cdFx0XHR0TWluID0gNGUtNyxcblx0XHRcdHRNYXggPSAxIC0gdE1pbixcblx0XHRcdHgsIHk7XG5cblx0XHRpZiAodHlwZSA9PT0gMCAmJiAodCA8IHRNaW4gfHwgdCA+IHRNYXgpKSB7XG5cdFx0XHR2YXIgaXNaZXJvID0gdCA8IHRNaW47XG5cdFx0XHR4ID0gaXNaZXJvID8gcDF4IDogcDJ4O1xuXHRcdFx0eSA9IGlzWmVybyA/IHAxeSA6IHAyeTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGN4ID0gMyAqIChjMXggLSBwMXgpLFxuXHRcdFx0XHRieCA9IDMgKiAoYzJ4IC0gYzF4KSAtIGN4LFxuXHRcdFx0XHRheCA9IHAyeCAtIHAxeCAtIGN4IC0gYngsXG5cblx0XHRcdFx0Y3kgPSAzICogKGMxeSAtIHAxeSksXG5cdFx0XHRcdGJ5ID0gMyAqIChjMnkgLSBjMXkpIC0gY3ksXG5cdFx0XHRcdGF5ID0gcDJ5IC0gcDF5IC0gY3kgLSBieTtcblx0XHRcdGlmICh0eXBlID09PSAwKSB7XG5cdFx0XHRcdHggPSAoKGF4ICogdCArIGJ4KSAqIHQgKyBjeCkgKiB0ICsgcDF4O1xuXHRcdFx0XHR5ID0gKChheSAqIHQgKyBieSkgKiB0ICsgY3kpICogdCArIHAxeTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGlmICh0IDwgdE1pbikge1xuXHRcdFx0XHRcdHggPSBjeDtcblx0XHRcdFx0XHR5ID0gY3k7XG5cdFx0XHRcdH0gZWxzZSBpZiAodCA+IHRNYXgpIHtcblx0XHRcdFx0XHR4ID0gMyAqIChwMnggLSBjMngpO1xuXHRcdFx0XHRcdHkgPSAzICogKHAyeSAtIGMyeSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0eCA9ICgzICogYXggKiB0ICsgMiAqIGJ4KSAqIHQgKyBjeDtcblx0XHRcdFx0XHR5ID0gKDMgKiBheSAqIHQgKyAyICogYnkpICogdCArIGN5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChub3JtYWxpemVkKSB7XG5cdFx0XHRcdFx0aWYgKHggPT09IDAgJiYgeSA9PT0gMCAmJiAodCA8IHRNaW4gfHwgdCA+IHRNYXgpKSB7XG5cdFx0XHRcdFx0XHR4ID0gYzJ4IC0gYzF4O1xuXHRcdFx0XHRcdFx0eSA9IGMyeSAtIGMxeTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dmFyIGxlbiA9IE1hdGguc3FydCh4ICogeCArIHkgKiB5KTtcblx0XHRcdFx0XHRpZiAobGVuKSB7XG5cdFx0XHRcdFx0XHR4IC89IGxlbjtcblx0XHRcdFx0XHRcdHkgLz0gbGVuO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodHlwZSA9PT0gMykge1xuXHRcdFx0XHRcdHZhciB4MiA9IDYgKiBheCAqIHQgKyAyICogYngsXG5cdFx0XHRcdFx0XHR5MiA9IDYgKiBheSAqIHQgKyAyICogYnksXG5cdFx0XHRcdFx0XHRkID0gTWF0aC5wb3coeCAqIHggKyB5ICogeSwgMyAvIDIpO1xuXHRcdFx0XHRcdHggPSBkICE9PSAwID8gKHggKiB5MiAtIHkgKiB4MikgLyBkIDogMDtcblx0XHRcdFx0XHR5ID0gMDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdHlwZSA9PT0gMiA/IG5ldyBQb2ludCh5LCAteCkgOiBuZXcgUG9pbnQoeCwgeSk7XG5cdH1cblxuXHRyZXR1cm4geyBzdGF0aWNzOiB7XG5cblx0XHRnZXRMZW5ndGg6IGZ1bmN0aW9uKHYsIGEsIGIpIHtcblx0XHRcdGlmIChhID09PSB1bmRlZmluZWQpXG5cdFx0XHRcdGEgPSAwO1xuXHRcdFx0aWYgKGIgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0YiA9IDE7XG5cdFx0XHRpZiAoYSA9PT0gMCAmJiBiID09PSAxICYmIEN1cnZlLmlzU3RyYWlnaHQodikpIHtcblx0XHRcdFx0dmFyIGR4ID0gdls2XSAtIHZbMF0sXG5cdFx0XHRcdFx0ZHkgPSB2WzddIC0gdlsxXTtcblx0XHRcdFx0cmV0dXJuIE1hdGguc3FydChkeCAqIGR4ICsgZHkgKiBkeSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgZHMgPSBnZXRMZW5ndGhJbnRlZ3JhbmQodik7XG5cdFx0XHRyZXR1cm4gTnVtZXJpY2FsLmludGVncmF0ZShkcywgYSwgYiwgZ2V0SXRlcmF0aW9ucyhhLCBiKSk7XG5cdFx0fSxcblxuXHRcdGdldFBhcmFtZXRlckF0OiBmdW5jdGlvbih2LCBvZmZzZXQsIHN0YXJ0KSB7XG5cdFx0XHRpZiAoc3RhcnQgPT09IHVuZGVmaW5lZClcblx0XHRcdFx0c3RhcnQgPSBvZmZzZXQgPCAwID8gMSA6IDBcblx0XHRcdGlmIChvZmZzZXQgPT09IDApXG5cdFx0XHRcdHJldHVybiBzdGFydDtcblx0XHRcdHZhciBhYnMgPSBNYXRoLmFicyxcblx0XHRcdFx0Zm9yd2FyZCA9IG9mZnNldCA+IDAsXG5cdFx0XHRcdGEgPSBmb3J3YXJkID8gc3RhcnQgOiAwLFxuXHRcdFx0XHRiID0gZm9yd2FyZCA/IDEgOiBzdGFydCxcblx0XHRcdFx0ZHMgPSBnZXRMZW5ndGhJbnRlZ3JhbmQodiksXG5cdFx0XHRcdHJhbmdlTGVuZ3RoID0gTnVtZXJpY2FsLmludGVncmF0ZShkcywgYSwgYixcblx0XHRcdFx0XHRcdGdldEl0ZXJhdGlvbnMoYSwgYikpO1xuXHRcdFx0aWYgKGFicyhvZmZzZXQgLSByYW5nZUxlbmd0aCkgPCAxZS0xMikge1xuXHRcdFx0XHRyZXR1cm4gZm9yd2FyZCA/IGIgOiBhO1xuXHRcdFx0fSBlbHNlIGlmIChhYnMob2Zmc2V0KSA+IHJhbmdlTGVuZ3RoKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGd1ZXNzID0gb2Zmc2V0IC8gcmFuZ2VMZW5ndGgsXG5cdFx0XHRcdGxlbmd0aCA9IDA7XG5cdFx0XHRmdW5jdGlvbiBmKHQpIHtcblx0XHRcdFx0bGVuZ3RoICs9IE51bWVyaWNhbC5pbnRlZ3JhdGUoZHMsIHN0YXJ0LCB0LFxuXHRcdFx0XHRcdFx0Z2V0SXRlcmF0aW9ucyhzdGFydCwgdCkpO1xuXHRcdFx0XHRzdGFydCA9IHQ7XG5cdFx0XHRcdHJldHVybiBsZW5ndGggLSBvZmZzZXQ7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gTnVtZXJpY2FsLmZpbmRSb290KGYsIGRzLCBzdGFydCArIGd1ZXNzLCBhLCBiLCAzMixcblx0XHRcdFx0XHQxZS0xMik7XG5cdFx0fSxcblxuXHRcdGdldFBvaW50OiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0XHRyZXR1cm4gZXZhbHVhdGUodiwgdCwgMCwgZmFsc2UpO1xuXHRcdH0sXG5cblx0XHRnZXRUYW5nZW50OiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0XHRyZXR1cm4gZXZhbHVhdGUodiwgdCwgMSwgdHJ1ZSk7XG5cdFx0fSxcblxuXHRcdGdldFdlaWdodGVkVGFuZ2VudDogZnVuY3Rpb24odiwgdCkge1xuXHRcdFx0cmV0dXJuIGV2YWx1YXRlKHYsIHQsIDEsIGZhbHNlKTtcblx0XHR9LFxuXG5cdFx0Z2V0Tm9ybWFsOiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0XHRyZXR1cm4gZXZhbHVhdGUodiwgdCwgMiwgdHJ1ZSk7XG5cdFx0fSxcblxuXHRcdGdldFdlaWdodGVkTm9ybWFsOiBmdW5jdGlvbih2LCB0KSB7XG5cdFx0XHRyZXR1cm4gZXZhbHVhdGUodiwgdCwgMiwgZmFsc2UpO1xuXHRcdH0sXG5cblx0XHRnZXRDdXJ2YXR1cmU6IGZ1bmN0aW9uKHYsIHQpIHtcblx0XHRcdHJldHVybiBldmFsdWF0ZSh2LCB0LCAzLCBmYWxzZSkueDtcblx0XHR9XG5cdH19O1xufSxcbm5ldyBmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBhZGRMb2NhdGlvbihsb2NhdGlvbnMsIHBhcmFtLCB2MSwgYzEsIHQxLCBwMSwgdjIsIGMyLCB0MiwgcDIsXG5cdFx0XHRvdmVybGFwKSB7XG5cdFx0dmFyIHN0YXJ0Q29ubmVjdGVkID0gcGFyYW0uc3RhcnRDb25uZWN0ZWQsXG5cdFx0XHRlbmRDb25uZWN0ZWQgPSBwYXJhbS5lbmRDb25uZWN0ZWQsXG5cdFx0XHR0TWluID0gNGUtNyxcblx0XHRcdHRNYXggPSAxIC0gdE1pbjtcblx0XHRpZiAodDEgPT0gbnVsbClcblx0XHRcdHQxID0gQ3VydmUuZ2V0UGFyYW1ldGVyT2YodjEsIHAxKTtcblx0XHRpZiAodDEgIT09IG51bGwgJiYgdDEgPj0gKHN0YXJ0Q29ubmVjdGVkID8gdE1pbiA6IDApICYmXG5cdFx0XHR0MSA8PSAoZW5kQ29ubmVjdGVkID8gdE1heCA6IDEpKSB7XG5cdFx0XHRpZiAodDIgPT0gbnVsbClcblx0XHRcdFx0dDIgPSBDdXJ2ZS5nZXRQYXJhbWV0ZXJPZih2MiwgcDIpO1xuXHRcdFx0aWYgKHQyICE9PSBudWxsICYmIHQyID49IChlbmRDb25uZWN0ZWQgPyB0TWluIDogMCkgJiZcblx0XHRcdFx0dDIgPD0gKHN0YXJ0Q29ubmVjdGVkID8gdE1heCA6IDEpKSB7XG5cdFx0XHRcdHZhciByZW5vcm1hbGl6ZSA9IHBhcmFtLnJlbm9ybWFsaXplO1xuXHRcdFx0XHRpZiAocmVub3JtYWxpemUpIHtcblx0XHRcdFx0XHR2YXIgcmVzID0gcmVub3JtYWxpemUodDEsIHQyKTtcblx0XHRcdFx0XHR0MSA9IHJlc1swXTtcblx0XHRcdFx0XHR0MiA9IHJlc1sxXTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgbG9jMSA9IG5ldyBDdXJ2ZUxvY2F0aW9uKGMxLCB0MSxcblx0XHRcdFx0XHRcdHAxIHx8IEN1cnZlLmdldFBvaW50KHYxLCB0MSksIG92ZXJsYXApLFxuXHRcdFx0XHRcdGxvYzIgPSBuZXcgQ3VydmVMb2NhdGlvbihjMiwgdDIsXG5cdFx0XHRcdFx0XHRwMiB8fCBDdXJ2ZS5nZXRQb2ludCh2MiwgdDIpLCBvdmVybGFwKSxcblx0XHRcdFx0XHRmbGlwID0gbG9jMS5nZXRQYXRoKCkgPT09IGxvYzIuZ2V0UGF0aCgpXG5cdFx0XHRcdFx0XHQmJiBsb2MxLmdldEluZGV4KCkgPiBsb2MyLmdldEluZGV4KCksXG5cdFx0XHRcdFx0bG9jID0gZmxpcCA/IGxvYzIgOiBsb2MxLFxuXHRcdFx0XHRcdGluY2x1ZGUgPSBwYXJhbS5pbmNsdWRlO1xuXHRcdFx0XHRsb2MxLl9pbnRlcnNlY3Rpb24gPSBsb2MyO1xuXHRcdFx0XHRsb2MyLl9pbnRlcnNlY3Rpb24gPSBsb2MxO1xuXHRcdFx0XHRpZiAoIWluY2x1ZGUgfHwgaW5jbHVkZShsb2MpKSB7XG5cdFx0XHRcdFx0Q3VydmVMb2NhdGlvbi5pbnNlcnQobG9jYXRpb25zLCBsb2MsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQ3VydmVJbnRlcnNlY3Rpb25zKHYxLCB2MiwgYzEsIGMyLCBsb2NhdGlvbnMsIHBhcmFtLFxuXHRcdFx0dE1pbiwgdE1heCwgdU1pbiwgdU1heCwgb2xkVERpZmYsIHJldmVyc2UsIHJlY3Vyc2lvbikge1xuXHRcdGlmICgrK3JlY3Vyc2lvbiA+PSAyNClcblx0XHRcdHJldHVybjtcblx0XHR2YXIgcTB4ID0gdjJbMF0sIHEweSA9IHYyWzFdLCBxM3ggPSB2Mls2XSwgcTN5ID0gdjJbN10sXG5cdFx0XHRnZXRTaWduZWREaXN0YW5jZSA9IExpbmUuZ2V0U2lnbmVkRGlzdGFuY2UsXG5cdFx0XHRkMSA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjJbMl0sIHYyWzNdKSxcblx0XHRcdGQyID0gZ2V0U2lnbmVkRGlzdGFuY2UocTB4LCBxMHksIHEzeCwgcTN5LCB2Mls0XSwgdjJbNV0pLFxuXHRcdFx0ZmFjdG9yID0gZDEgKiBkMiA+IDAgPyAzIC8gNCA6IDQgLyA5LFxuXHRcdFx0ZE1pbiA9IGZhY3RvciAqIE1hdGgubWluKDAsIGQxLCBkMiksXG5cdFx0XHRkTWF4ID0gZmFjdG9yICogTWF0aC5tYXgoMCwgZDEsIGQyKSxcblx0XHRcdGRwMCA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbMF0sIHYxWzFdKSxcblx0XHRcdGRwMSA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbMl0sIHYxWzNdKSxcblx0XHRcdGRwMiA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbNF0sIHYxWzVdKSxcblx0XHRcdGRwMyA9IGdldFNpZ25lZERpc3RhbmNlKHEweCwgcTB5LCBxM3gsIHEzeSwgdjFbNl0sIHYxWzddKSxcblx0XHRcdGh1bGwgPSBnZXRDb252ZXhIdWxsKGRwMCwgZHAxLCBkcDIsIGRwMyksXG5cdFx0XHR0b3AgPSBodWxsWzBdLFxuXHRcdFx0Ym90dG9tID0gaHVsbFsxXSxcblx0XHRcdHRNaW5DbGlwLFxuXHRcdFx0dE1heENsaXA7XG5cdFx0aWYgKCh0TWluQ2xpcCA9IGNsaXBDb252ZXhIdWxsKHRvcCwgYm90dG9tLCBkTWluLCBkTWF4KSkgPT0gbnVsbCB8fFxuXHRcdFx0KHRNYXhDbGlwID0gY2xpcENvbnZleEh1bGwodG9wLnJldmVyc2UoKSwgYm90dG9tLnJldmVyc2UoKSxcblx0XHRcdFx0ZE1pbiwgZE1heCkpID09IG51bGwpXG5cdFx0XHRyZXR1cm47XG5cdFx0djEgPSBDdXJ2ZS5nZXRQYXJ0KHYxLCB0TWluQ2xpcCwgdE1heENsaXApO1xuXHRcdHZhciB0RGlmZiA9IHRNYXhDbGlwIC0gdE1pbkNsaXAsXG5cdFx0XHR0TWluTmV3ID0gdE1pbiArICh0TWF4IC0gdE1pbikgKiB0TWluQ2xpcCxcblx0XHRcdHRNYXhOZXcgPSB0TWluICsgKHRNYXggLSB0TWluKSAqIHRNYXhDbGlwO1xuXHRcdGlmIChvbGRURGlmZiA+IDAuNSAmJiB0RGlmZiA+IDAuNSkge1xuXHRcdFx0aWYgKHRNYXhOZXcgLSB0TWluTmV3ID4gdU1heCAtIHVNaW4pIHtcblx0XHRcdFx0dmFyIHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHYxLCAwLjUpLFxuXHRcdFx0XHRcdHQgPSB0TWluTmV3ICsgKHRNYXhOZXcgLSB0TWluTmV3KSAvIDI7XG5cdFx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHR2MiwgcGFydHNbMF0sIGMyLCBjMSwgbG9jYXRpb25zLCBwYXJhbSxcblx0XHRcdFx0XHR1TWluLCB1TWF4LCB0TWluTmV3LCB0LCB0RGlmZiwgIXJldmVyc2UsIHJlY3Vyc2lvbik7XG5cdFx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHR2MiwgcGFydHNbMV0sIGMyLCBjMSwgbG9jYXRpb25zLCBwYXJhbSxcblx0XHRcdFx0XHR1TWluLCB1TWF4LCB0LCB0TWF4TmV3LCB0RGlmZiwgIXJldmVyc2UsIHJlY3Vyc2lvbik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodjIsIDAuNSksXG5cdFx0XHRcdFx0dCA9IHVNaW4gKyAodU1heCAtIHVNaW4pIC8gMjtcblx0XHRcdFx0YWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdHBhcnRzWzBdLCB2MSwgYzIsIGMxLCBsb2NhdGlvbnMsIHBhcmFtLFxuXHRcdFx0XHRcdHVNaW4sIHQsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcblx0XHRcdFx0YWRkQ3VydmVJbnRlcnNlY3Rpb25zKFxuXHRcdFx0XHRcdHBhcnRzWzFdLCB2MSwgYzIsIGMxLCBsb2NhdGlvbnMsIHBhcmFtLFxuXHRcdFx0XHRcdHQsIHVNYXgsIHRNaW5OZXcsIHRNYXhOZXcsIHREaWZmLCAhcmV2ZXJzZSwgcmVjdXJzaW9uKTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKE1hdGgubWF4KHVNYXggLSB1TWluLCB0TWF4TmV3IC0gdE1pbk5ldylcblx0XHRcdFx0PCAxZS03KSB7XG5cdFx0XHR2YXIgdDEgPSB0TWluTmV3ICsgKHRNYXhOZXcgLSB0TWluTmV3KSAvIDIsXG5cdFx0XHRcdHQyID0gdU1pbiArICh1TWF4IC0gdU1pbikgLyAyO1xuXHRcdFx0djEgPSBjMS5nZXRWYWx1ZXMoKTtcblx0XHRcdHYyID0gYzIuZ2V0VmFsdWVzKCk7XG5cdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIHBhcmFtLFxuXHRcdFx0XHRyZXZlcnNlID8gdjIgOiB2MSwgcmV2ZXJzZSA/IGMyIDogYzEsIHJldmVyc2UgPyB0MiA6IHQxLCBudWxsLFxuXHRcdFx0XHRyZXZlcnNlID8gdjEgOiB2MiwgcmV2ZXJzZSA/IGMxIDogYzIsIHJldmVyc2UgPyB0MSA6IHQyLCBudWxsKTtcblx0XHR9IGVsc2UgaWYgKHREaWZmID4gMWUtMTIpIHtcblx0XHRcdGFkZEN1cnZlSW50ZXJzZWN0aW9ucyh2MiwgdjEsIGMyLCBjMSwgbG9jYXRpb25zLCBwYXJhbSxcblx0XHRcdFx0XHR1TWluLCB1TWF4LCB0TWluTmV3LCB0TWF4TmV3LCB0RGlmZiwgIXJldmVyc2UsIHJlY3Vyc2lvbik7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0Q29udmV4SHVsbChkcTAsIGRxMSwgZHEyLCBkcTMpIHtcblx0XHR2YXIgcDAgPSBbIDAsIGRxMCBdLFxuXHRcdFx0cDEgPSBbIDEgLyAzLCBkcTEgXSxcblx0XHRcdHAyID0gWyAyIC8gMywgZHEyIF0sXG5cdFx0XHRwMyA9IFsgMSwgZHEzIF0sXG5cdFx0XHRkaXN0MSA9IGRxMSAtICgyICogZHEwICsgZHEzKSAvIDMsXG5cdFx0XHRkaXN0MiA9IGRxMiAtIChkcTAgKyAyICogZHEzKSAvIDMsXG5cdFx0XHRodWxsO1xuXHRcdGlmIChkaXN0MSAqIGRpc3QyIDwgMCkge1xuXHRcdFx0aHVsbCA9IFtbcDAsIHAxLCBwM10sIFtwMCwgcDIsIHAzXV07XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBkaXN0UmF0aW8gPSBkaXN0MSAvIGRpc3QyO1xuXHRcdFx0aHVsbCA9IFtcblx0XHRcdFx0ZGlzdFJhdGlvID49IDIgPyBbcDAsIHAxLCBwM11cblx0XHRcdFx0OiBkaXN0UmF0aW8gPD0gLjUgPyBbcDAsIHAyLCBwM11cblx0XHRcdFx0OiBbcDAsIHAxLCBwMiwgcDNdLFxuXHRcdFx0XHRbcDAsIHAzXVxuXHRcdFx0XTtcblx0XHR9XG5cdFx0cmV0dXJuIChkaXN0MSB8fCBkaXN0MikgPCAwID8gaHVsbC5yZXZlcnNlKCkgOiBodWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gY2xpcENvbnZleEh1bGwoaHVsbFRvcCwgaHVsbEJvdHRvbSwgZE1pbiwgZE1heCkge1xuXHRcdGlmIChodWxsVG9wWzBdWzFdIDwgZE1pbikge1xuXHRcdFx0cmV0dXJuIGNsaXBDb252ZXhIdWxsUGFydChodWxsVG9wLCB0cnVlLCBkTWluKTtcblx0XHR9IGVsc2UgaWYgKGh1bGxCb3R0b21bMF1bMV0gPiBkTWF4KSB7XG5cdFx0XHRyZXR1cm4gY2xpcENvbnZleEh1bGxQYXJ0KGh1bGxCb3R0b20sIGZhbHNlLCBkTWF4KTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmV0dXJuIGh1bGxUb3BbMF1bMF07XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gY2xpcENvbnZleEh1bGxQYXJ0KHBhcnQsIHRvcCwgdGhyZXNob2xkKSB7XG5cdFx0dmFyIHB4ID0gcGFydFswXVswXSxcblx0XHRcdHB5ID0gcGFydFswXVsxXTtcblx0XHRmb3IgKHZhciBpID0gMSwgbCA9IHBhcnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcXggPSBwYXJ0W2ldWzBdLFxuXHRcdFx0XHRxeSA9IHBhcnRbaV1bMV07XG5cdFx0XHRpZiAodG9wID8gcXkgPj0gdGhyZXNob2xkIDogcXkgPD0gdGhyZXNob2xkKSB7XG5cdFx0XHRcdHJldHVybiBxeSA9PT0gdGhyZXNob2xkID8gcXhcblx0XHRcdFx0XHRcdDogcHggKyAodGhyZXNob2xkIC0gcHkpICogKHF4IC0gcHgpIC8gKHF5IC0gcHkpO1xuXHRcdFx0fVxuXHRcdFx0cHggPSBxeDtcblx0XHRcdHB5ID0gcXk7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9XG5cblx0ZnVuY3Rpb24gYWRkQ3VydmVMaW5lSW50ZXJzZWN0aW9ucyh2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBwYXJhbSkge1xuXHRcdHZhciBmbGlwID0gQ3VydmUuaXNTdHJhaWdodCh2MSksXG5cdFx0XHR2YyA9IGZsaXAgPyB2MiA6IHYxLFxuXHRcdFx0dmwgPSBmbGlwID8gdjEgOiB2Mixcblx0XHRcdGx4MSA9IHZsWzBdLCBseTEgPSB2bFsxXSxcblx0XHRcdGx4MiA9IHZsWzZdLCBseTIgPSB2bFs3XSxcblx0XHRcdGxkeCA9IGx4MiAtIGx4MSxcblx0XHRcdGxkeSA9IGx5MiAtIGx5MSxcblx0XHRcdGFuZ2xlID0gTWF0aC5hdGFuMigtbGR5LCBsZHgpLFxuXHRcdFx0c2luID0gTWF0aC5zaW4oYW5nbGUpLFxuXHRcdFx0Y29zID0gTWF0aC5jb3MoYW5nbGUpLFxuXHRcdFx0cnZjID0gW107XG5cdFx0Zm9yKHZhciBpID0gMDsgaSA8IDg7IGkgKz0gMikge1xuXHRcdFx0dmFyIHggPSB2Y1tpXSAtIGx4MSxcblx0XHRcdFx0eSA9IHZjW2kgKyAxXSAtIGx5MTtcblx0XHRcdHJ2Yy5wdXNoKFxuXHRcdFx0XHR4ICogY29zIC0geSAqIHNpbixcblx0XHRcdFx0eCAqIHNpbiArIHkgKiBjb3MpO1xuXHRcdH1cblx0XHR2YXIgcm9vdHMgPSBbXSxcblx0XHRcdGNvdW50ID0gQ3VydmUuc29sdmVDdWJpYyhydmMsIDEsIDAsIHJvb3RzLCAwLCAxKTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdHZhciB0YyA9IHJvb3RzW2ldLFxuXHRcdFx0XHRwYyA9IEN1cnZlLmdldFBvaW50KHZjLCB0YyksXG5cdFx0XHRcdHRsID0gQ3VydmUuZ2V0UGFyYW1ldGVyT2YodmwsIHBjKTtcblx0XHRcdGlmICh0bCAhPT0gbnVsbCkge1xuXHRcdFx0XHR2YXIgcGwgPSBDdXJ2ZS5nZXRQb2ludCh2bCwgdGwpLFxuXHRcdFx0XHRcdHQxID0gZmxpcCA/IHRsIDogdGMsXG5cdFx0XHRcdFx0dDIgPSBmbGlwID8gdGMgOiB0bDtcblx0XHRcdFx0aWYgKCFwYXJhbS5lbmRDb25uZWN0ZWQgfHwgdDIgPiBOdW1lcmljYWwuQ1VSVkVUSU1FX0VQU0lMT04pIHtcblx0XHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIHBhcmFtLFxuXHRcdFx0XHRcdFx0XHR2MSwgYzEsIHQxLCBmbGlwID8gcGwgOiBwYyxcblx0XHRcdFx0XHRcdFx0djIsIGMyLCB0MiwgZmxpcCA/IHBjIDogcGwpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gYWRkTGluZUludGVyc2VjdGlvbih2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBwYXJhbSkge1xuXHRcdHZhciBwdCA9IExpbmUuaW50ZXJzZWN0KFxuXHRcdFx0XHR2MVswXSwgdjFbMV0sIHYxWzZdLCB2MVs3XSxcblx0XHRcdFx0djJbMF0sIHYyWzFdLCB2Mls2XSwgdjJbN10pO1xuXHRcdGlmIChwdCkge1xuXHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBwYXJhbSwgdjEsIGMxLCBudWxsLCBwdCwgdjIsIGMyLCBudWxsLCBwdCk7XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHsgc3RhdGljczoge1xuXHRcdF9nZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbih2MSwgdjIsIGMxLCBjMiwgbG9jYXRpb25zLCBwYXJhbSkge1xuXHRcdFx0aWYgKCF2Mikge1xuXHRcdFx0XHRyZXR1cm4gQ3VydmUuX2dldFNlbGZJbnRlcnNlY3Rpb24odjEsIGMxLCBsb2NhdGlvbnMsIHBhcmFtKTtcblx0XHRcdH1cblx0XHRcdHZhciBjMXAxeCA9IHYxWzBdLCBjMXAxeSA9IHYxWzFdLFxuXHRcdFx0XHRjMXAyeCA9IHYxWzZdLCBjMXAyeSA9IHYxWzddLFxuXHRcdFx0XHRjMnAxeCA9IHYyWzBdLCBjMnAxeSA9IHYyWzFdLFxuXHRcdFx0XHRjMnAyeCA9IHYyWzZdLCBjMnAyeSA9IHYyWzddLFxuXHRcdFx0XHRjMXMxeCA9ICgzICogdjFbMl0gKyBjMXAxeCkgLyA0LFxuXHRcdFx0XHRjMXMxeSA9ICgzICogdjFbM10gKyBjMXAxeSkgLyA0LFxuXHRcdFx0XHRjMXMyeCA9ICgzICogdjFbNF0gKyBjMXAyeCkgLyA0LFxuXHRcdFx0XHRjMXMyeSA9ICgzICogdjFbNV0gKyBjMXAyeSkgLyA0LFxuXHRcdFx0XHRjMnMxeCA9ICgzICogdjJbMl0gKyBjMnAxeCkgLyA0LFxuXHRcdFx0XHRjMnMxeSA9ICgzICogdjJbM10gKyBjMnAxeSkgLyA0LFxuXHRcdFx0XHRjMnMyeCA9ICgzICogdjJbNF0gKyBjMnAyeCkgLyA0LFxuXHRcdFx0XHRjMnMyeSA9ICgzICogdjJbNV0gKyBjMnAyeSkgLyA0LFxuXHRcdFx0XHRtaW4gPSBNYXRoLm1pbixcblx0XHRcdFx0bWF4ID0gTWF0aC5tYXg7XG5cdFx0XHRpZiAoIShcdG1heChjMXAxeCwgYzFzMXgsIGMxczJ4LCBjMXAyeCkgPj1cblx0XHRcdFx0XHRtaW4oYzJwMXgsIGMyczF4LCBjMnMyeCwgYzJwMngpICYmXG5cdFx0XHRcdFx0bWluKGMxcDF4LCBjMXMxeCwgYzFzMngsIGMxcDJ4KSA8PVxuXHRcdFx0XHRcdG1heChjMnAxeCwgYzJzMXgsIGMyczJ4LCBjMnAyeCkgJiZcblx0XHRcdFx0XHRtYXgoYzFwMXksIGMxczF5LCBjMXMyeSwgYzFwMnkpID49XG5cdFx0XHRcdFx0bWluKGMycDF5LCBjMnMxeSwgYzJzMnksIGMycDJ5KSAmJlxuXHRcdFx0XHRcdG1pbihjMXAxeSwgYzFzMXksIGMxczJ5LCBjMXAyeSkgPD1cblx0XHRcdFx0XHRtYXgoYzJwMXksIGMyczF5LCBjMnMyeSwgYzJwMnkpKSlcblx0XHRcdFx0cmV0dXJuIGxvY2F0aW9ucztcblx0XHRcdGlmICghcGFyYW0uc3RhcnRDb25uZWN0ZWQgJiYgIXBhcmFtLmVuZENvbm5lY3RlZCkge1xuXHRcdFx0XHR2YXIgb3ZlcmxhcHMgPSBDdXJ2ZS5nZXRPdmVybGFwcyh2MSwgdjIpO1xuXHRcdFx0XHRpZiAob3ZlcmxhcHMpIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuXHRcdFx0XHRcdFx0dmFyIG92ZXJsYXAgPSBvdmVybGFwc1tpXTtcblx0XHRcdFx0XHRcdGFkZExvY2F0aW9uKGxvY2F0aW9ucywgcGFyYW0sXG5cdFx0XHRcdFx0XHRcdHYxLCBjMSwgb3ZlcmxhcFswXSwgbnVsbCxcblx0XHRcdFx0XHRcdFx0djIsIGMyLCBvdmVybGFwWzFdLCBudWxsLCB0cnVlKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0cmV0dXJuIGxvY2F0aW9ucztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXG5cdFx0XHR2YXIgc3RyYWlnaHQxID0gQ3VydmUuaXNTdHJhaWdodCh2MSksXG5cdFx0XHRcdHN0cmFpZ2h0MiA9IEN1cnZlLmlzU3RyYWlnaHQodjIpLFxuXHRcdFx0XHRzdHJhaWdodCA9IHN0cmFpZ2h0MSAmJiBzdHJhaWdodDIsXG5cdFx0XHRcdGVwc2lsb24gPSAxZS0xMixcblx0XHRcdFx0YmVmb3JlID0gbG9jYXRpb25zLmxlbmd0aDtcblx0XHRcdChzdHJhaWdodFxuXHRcdFx0XHQ/IGFkZExpbmVJbnRlcnNlY3Rpb25cblx0XHRcdFx0OiBzdHJhaWdodDEgfHwgc3RyYWlnaHQyXG5cdFx0XHRcdFx0PyBhZGRDdXJ2ZUxpbmVJbnRlcnNlY3Rpb25zXG5cdFx0XHRcdFx0OiBhZGRDdXJ2ZUludGVyc2VjdGlvbnMpKFxuXHRcdFx0XHRcdFx0djEsIHYyLCBjMSwgYzIsIGxvY2F0aW9ucywgcGFyYW0sXG5cdFx0XHRcdFx0XHQwLCAxLCAwLCAxLCAwLCBmYWxzZSwgMCk7XG5cdFx0XHRpZiAoc3RyYWlnaHQgJiYgbG9jYXRpb25zLmxlbmd0aCA+IGJlZm9yZSlcblx0XHRcdFx0cmV0dXJuIGxvY2F0aW9ucztcblx0XHRcdHZhciBjMXAxID0gbmV3IFBvaW50KGMxcDF4LCBjMXAxeSksXG5cdFx0XHRcdGMxcDIgPSBuZXcgUG9pbnQoYzFwMngsIGMxcDJ5KSxcblx0XHRcdFx0YzJwMSA9IG5ldyBQb2ludChjMnAxeCwgYzJwMXkpLFxuXHRcdFx0XHRjMnAyID0gbmV3IFBvaW50KGMycDJ4LCBjMnAyeSk7XG5cdFx0XHRpZiAoYzFwMS5pc0Nsb3NlKGMycDEsIGVwc2lsb24pKVxuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIHBhcmFtLCB2MSwgYzEsIDAsIGMxcDEsIHYyLCBjMiwgMCwgYzJwMSk7XG5cdFx0XHRpZiAoIXBhcmFtLnN0YXJ0Q29ubmVjdGVkICYmIGMxcDEuaXNDbG9zZShjMnAyLCBlcHNpbG9uKSlcblx0XHRcdFx0YWRkTG9jYXRpb24obG9jYXRpb25zLCBwYXJhbSwgdjEsIGMxLCAwLCBjMXAxLCB2MiwgYzIsIDEsIGMycDIpO1xuXHRcdFx0aWYgKCFwYXJhbS5lbmRDb25uZWN0ZWQgJiYgYzFwMi5pc0Nsb3NlKGMycDEsIGVwc2lsb24pKVxuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIHBhcmFtLCB2MSwgYzEsIDEsIGMxcDIsIHYyLCBjMiwgMCwgYzJwMSk7XG5cdFx0XHRpZiAoYzFwMi5pc0Nsb3NlKGMycDIsIGVwc2lsb24pKVxuXHRcdFx0XHRhZGRMb2NhdGlvbihsb2NhdGlvbnMsIHBhcmFtLCB2MSwgYzEsIDEsIGMxcDIsIHYyLCBjMiwgMSwgYzJwMik7XG5cdFx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHRcdH0sXG5cblx0XHRfZ2V0U2VsZkludGVyc2VjdGlvbjogZnVuY3Rpb24odjEsIGMxLCBsb2NhdGlvbnMsIHBhcmFtKSB7XG5cdFx0XHR2YXIgcDF4ID0gdjFbMF0sIHAxeSA9IHYxWzFdLFxuXHRcdFx0XHRoMXggPSB2MVsyXSwgaDF5ID0gdjFbM10sXG5cdFx0XHRcdGgyeCA9IHYxWzRdLCBoMnkgPSB2MVs1XSxcblx0XHRcdFx0cDJ4ID0gdjFbNl0sIHAyeSA9IHYxWzddO1xuXHRcdFx0dmFyIGxpbmUgPSBuZXcgTGluZShwMXgsIHAxeSwgcDJ4LCBwMnksIGZhbHNlKSxcblx0XHRcdFx0c2lkZTEgPSBsaW5lLmdldFNpZGUobmV3IFBvaW50KGgxeCwgaDF5KSwgdHJ1ZSksXG5cdFx0XHRcdHNpZGUyID0gbGluZS5nZXRTaWRlKG5ldyBQb2ludChoMngsIGgyeSksIHRydWUpO1xuXHRcdFx0aWYgKHNpZGUxID09PSBzaWRlMikge1xuXHRcdFx0XHR2YXIgZWRnZVN1bSA9IChwMXggLSBoMngpICogKGgxeSAtIHAyeSlcblx0XHRcdFx0XHRcdFx0KyAoaDF4IC0gcDJ4KSAqIChoMnkgLSBwMXkpO1xuXHRcdFx0XHRpZiAoZWRnZVN1bSAqIHNpZGUxID4gMClcblx0XHRcdFx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGF4ID0gcDJ4IC0gMyAqIGgyeCArIDMgKiBoMXggLSBwMXgsXG5cdFx0XHRcdGJ4ID0gaDJ4IC0gMiAqIGgxeCArIHAxeCxcblx0XHRcdFx0Y3ggPSBoMXggLSBwMXgsXG5cdFx0XHRcdGF5ID0gcDJ5IC0gMyAqIGgyeSArIDMgKiBoMXkgLSBwMXksXG5cdFx0XHRcdGJ5ID0gaDJ5IC0gMiAqIGgxeSArIHAxeSxcblx0XHRcdFx0Y3kgPSBoMXkgLSBwMXksXG5cdFx0XHRcdGFjID0gYXkgKiBjeCAtIGF4ICogY3ksXG5cdFx0XHRcdGFiID0gYXkgKiBieCAtIGF4ICogYnksXG5cdFx0XHRcdGJjID0gYnkgKiBjeCAtIGJ4ICogY3k7XG5cdFx0XHRpZiAoYWMgKiBhYyAtIDQgKiBhYiAqIGJjIDwgMCkge1xuXHRcdFx0XHR2YXIgcm9vdHMgPSBbXSxcblx0XHRcdFx0XHR0U3BsaXQsXG5cdFx0XHRcdFx0Y291bnQgPSBOdW1lcmljYWwuc29sdmVDdWJpYyhcblx0XHRcdFx0XHRcdFx0YXggKiBheFx0ICsgYXkgKiBheSxcblx0XHRcdFx0XHRcdFx0MyAqIChheCAqIGJ4ICsgYXkgKiBieSksXG5cdFx0XHRcdFx0XHRcdDIgKiAoYnggKiBieCArIGJ5ICogYnkpICsgYXggKiBjeCArIGF5ICogY3ksXG5cdFx0XHRcdFx0XHRcdGJ4ICogY3ggKyBieSAqIGN5LFxuXHRcdFx0XHRcdFx0XHRyb290cywgMCwgMSk7XG5cdFx0XHRcdGlmIChjb3VudCA+IDApIHtcblx0XHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbWF4Q3VydmF0dXJlID0gMDsgaSA8IGNvdW50OyBpKyspIHtcblx0XHRcdFx0XHRcdHZhciBjdXJ2YXR1cmUgPSBNYXRoLmFicyhcblx0XHRcdFx0XHRcdFx0XHRjMS5nZXRDdXJ2YXR1cmVBdChyb290c1tpXSwgdHJ1ZSkpO1xuXHRcdFx0XHRcdFx0aWYgKGN1cnZhdHVyZSA+IG1heEN1cnZhdHVyZSkge1xuXHRcdFx0XHRcdFx0XHRtYXhDdXJ2YXR1cmUgPSBjdXJ2YXR1cmU7XG5cdFx0XHRcdFx0XHRcdHRTcGxpdCA9IHJvb3RzW2ldO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHR2YXIgcGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodjEsIHRTcGxpdCk7XG5cdFx0XHRcdFx0cGFyYW0uZW5kQ29ubmVjdGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRwYXJhbS5yZW5vcm1hbGl6ZSA9IGZ1bmN0aW9uKHQxLCB0Mikge1xuXHRcdFx0XHRcdFx0cmV0dXJuIFt0MSAqIHRTcGxpdCwgdDIgKiAoMSAtIHRTcGxpdCkgKyB0U3BsaXRdO1xuXHRcdFx0XHRcdH07XG5cdFx0XHRcdFx0Q3VydmUuX2dldEludGVyc2VjdGlvbnMocGFydHNbMF0sIHBhcnRzWzFdLCBjMSwgYzEsXG5cdFx0XHRcdFx0XHRcdGxvY2F0aW9ucywgcGFyYW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gbG9jYXRpb25zO1xuXHRcdH0sXG5cblx0XHRnZXRPdmVybGFwczogZnVuY3Rpb24odjEsIHYyKSB7XG5cdFx0XHR2YXIgYWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdHRpbWVFcHNpbG9uID0gNGUtNyxcblx0XHRcdFx0Z2VvbUVwc2lsb24gPSAyZS03LFxuXHRcdFx0XHRzdHJhaWdodDEgPSBDdXJ2ZS5pc1N0cmFpZ2h0KHYxKSxcblx0XHRcdFx0c3RyYWlnaHQyID0gQ3VydmUuaXNTdHJhaWdodCh2MiksXG5cdFx0XHRcdHN0cmFpZ2h0ID1cdHN0cmFpZ2h0MSAmJiBzdHJhaWdodDI7XG5cblx0XHRcdGZ1bmN0aW9uIGdldExpbmVMZW5ndGhTcXVhcmVkKHYpIHtcblx0XHRcdFx0dmFyIHggPSB2WzZdIC0gdlswXSxcblx0XHRcdFx0XHR5ID0gdls3XSAtIHZbMV07XG5cdFx0XHRcdHJldHVybiB4ICogeCArIHkgKiB5O1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAoc3RyYWlnaHQpIHtcblx0XHRcdFx0dmFyIGZsaXAgPSBnZXRMaW5lTGVuZ3RoU3F1YXJlZCh2MSkgPCBnZXRMaW5lTGVuZ3RoU3F1YXJlZCh2MiksXG5cdFx0XHRcdFx0bDEgPSBmbGlwID8gdjIgOiB2MSxcblx0XHRcdFx0XHRsMiA9IGZsaXAgPyB2MSA6IHYyLFxuXHRcdFx0XHRcdGxpbmUgPSBuZXcgTGluZShsMVswXSwgbDFbMV0sIGwxWzZdLCBsMVs3XSk7XG5cdFx0XHRcdGlmIChsaW5lLmdldERpc3RhbmNlKG5ldyBQb2ludChsMlswXSwgbDJbMV0pKSA+IGdlb21FcHNpbG9uIHx8XG5cdFx0XHRcdFx0bGluZS5nZXREaXN0YW5jZShuZXcgUG9pbnQobDJbNl0sIGwyWzddKSkgPiBnZW9tRXBzaWxvbilcblx0XHRcdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRcdH0gZWxzZSBpZiAoc3RyYWlnaHQxIF4gc3RyYWlnaHQyKSB7XG5cdFx0XHRcdHJldHVybiBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHR2YXIgdiA9IFt2MSwgdjJdLFxuXHRcdFx0XHRwYWlycyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIHQxID0gMDtcblx0XHRcdFx0XHRpIDwgMiAmJiBwYWlycy5sZW5ndGggPCAyO1xuXHRcdFx0XHRcdGkgKz0gdDEgPT09IDAgPyAwIDogMSwgdDEgPSB0MSBeIDEpIHtcblx0XHRcdFx0dmFyIHQyID0gQ3VydmUuZ2V0UGFyYW1ldGVyT2YodltpIF4gMV0sIG5ldyBQb2ludChcblx0XHRcdFx0XHRcdHZbaV1bdDEgPT09IDAgPyAwIDogNl0sXG5cdFx0XHRcdFx0XHR2W2ldW3QxID09PSAwID8gMSA6IDddKSk7XG5cdFx0XHRcdGlmICh0MiAhPSBudWxsKSB7XG5cdFx0XHRcdFx0dmFyIHBhaXIgPSBpID09PSAwID8gW3QxLCB0Ml0gOiBbdDIsIHQxXTtcblx0XHRcdFx0XHRpZiAocGFpcnMubGVuZ3RoID09PSAwIHx8XG5cdFx0XHRcdFx0XHRhYnMocGFpclswXSAtIHBhaXJzWzBdWzBdKSA+IHRpbWVFcHNpbG9uICYmXG5cdFx0XHRcdFx0XHRhYnMocGFpclsxXSAtIHBhaXJzWzBdWzFdKSA+IHRpbWVFcHNpbG9uKVxuXHRcdFx0XHRcdFx0cGFpcnMucHVzaChwYWlyKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoaSA9PT0gMSAmJiBwYWlycy5sZW5ndGggPT09IDApXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRpZiAocGFpcnMubGVuZ3RoICE9PSAyKSB7XG5cdFx0XHRcdHBhaXJzID0gbnVsbDtcblx0XHRcdH0gZWxzZSBpZiAoIXN0cmFpZ2h0KSB7XG5cdFx0XHRcdHZhciBvMSA9IEN1cnZlLmdldFBhcnQodjEsIHBhaXJzWzBdWzBdLCBwYWlyc1sxXVswXSksXG5cdFx0XHRcdFx0bzIgPSBDdXJ2ZS5nZXRQYXJ0KHYyLCBwYWlyc1swXVsxXSwgcGFpcnNbMV1bMV0pO1xuXHRcdFx0XHRpZiAoYWJzKG8yWzJdIC0gbzFbMl0pID4gZ2VvbUVwc2lsb24gfHxcblx0XHRcdFx0XHRhYnMobzJbM10gLSBvMVszXSkgPiBnZW9tRXBzaWxvbiB8fFxuXHRcdFx0XHRcdGFicyhvMls0XSAtIG8xWzRdKSA+IGdlb21FcHNpbG9uIHx8XG5cdFx0XHRcdFx0YWJzKG8yWzVdIC0gbzFbNV0pID4gZ2VvbUVwc2lsb24pXG5cdFx0XHRcdFx0cGFpcnMgPSBudWxsO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBhaXJzO1xuXHRcdH1cblx0fX07XG59KTtcblxudmFyIEN1cnZlTG9jYXRpb24gPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0N1cnZlTG9jYXRpb24nLFxuXHRiZWFuczogdHJ1ZSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDdXJ2ZUxvY2F0aW9uKGN1cnZlLCBwYXJhbWV0ZXIsIHBvaW50LFxuXHRcdFx0X292ZXJsYXAsIF9kaXN0YW5jZSkge1xuXHRcdGlmIChwYXJhbWV0ZXIgPiAwLjk5OTk5OTYpIHtcblx0XHRcdHZhciBuZXh0ID0gY3VydmUuZ2V0TmV4dCgpO1xuXHRcdFx0aWYgKG5leHQpIHtcblx0XHRcdFx0cGFyYW1ldGVyID0gMDtcblx0XHRcdFx0Y3VydmUgPSBuZXh0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHR0aGlzLl9pZCA9IFVJRC5nZXQoQ3VydmVMb2NhdGlvbik7XG5cdFx0dGhpcy5fc2V0Q3VydmUoY3VydmUpO1xuXHRcdHRoaXMuX3BhcmFtZXRlciA9IHBhcmFtZXRlcjtcblx0XHR0aGlzLl9wb2ludCA9IHBvaW50IHx8IGN1cnZlLmdldFBvaW50QXQocGFyYW1ldGVyLCB0cnVlKTtcblx0XHR0aGlzLl9vdmVybGFwID0gX292ZXJsYXA7XG5cdFx0dGhpcy5fZGlzdGFuY2UgPSBfZGlzdGFuY2U7XG5cdFx0dGhpcy5faW50ZXJzZWN0aW9uID0gdGhpcy5fbmV4dCA9IHRoaXMuX3ByZXYgPSBudWxsO1xuXHR9LFxuXG5cdF9zZXRDdXJ2ZTogZnVuY3Rpb24oY3VydmUpIHtcblx0XHR2YXIgcGF0aCA9IGN1cnZlLl9wYXRoO1xuXHRcdHRoaXMuX3ZlcnNpb24gPSBwYXRoID8gcGF0aC5fdmVyc2lvbiA6IDA7XG5cdFx0dGhpcy5fY3VydmUgPSBjdXJ2ZTtcblx0XHR0aGlzLl9zZWdtZW50ID0gbnVsbDtcblx0XHR0aGlzLl9zZWdtZW50MSA9IGN1cnZlLl9zZWdtZW50MTtcblx0XHR0aGlzLl9zZWdtZW50MiA9IGN1cnZlLl9zZWdtZW50Mjtcblx0fSxcblxuXHRfc2V0U2VnbWVudDogZnVuY3Rpb24oc2VnbWVudCkge1xuXHRcdHRoaXMuX3NldEN1cnZlKHNlZ21lbnQuZ2V0Q3VydmUoKSk7XG5cdFx0dGhpcy5fc2VnbWVudCA9IHNlZ21lbnQ7XG5cdFx0dGhpcy5fcGFyYW1ldGVyID0gc2VnbWVudCA9PT0gdGhpcy5fc2VnbWVudDEgPyAwIDogMTtcblx0XHR0aGlzLl9wb2ludCA9IHNlZ21lbnQuX3BvaW50LmNsb25lKCk7XG5cdH0sXG5cblx0Z2V0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0c2VnbWVudCA9IHRoaXMuX3NlZ21lbnQ7XG5cdFx0aWYgKCFzZWdtZW50KSB7XG5cdFx0XHR2YXIgcGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXIoKTtcblx0XHRcdGlmIChwYXJhbWV0ZXIgPT09IDApIHtcblx0XHRcdFx0c2VnbWVudCA9IGN1cnZlLl9zZWdtZW50MTtcblx0XHRcdH0gZWxzZSBpZiAocGFyYW1ldGVyID09PSAxKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9IGVsc2UgaWYgKHBhcmFtZXRlciAhPSBudWxsKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5nZXRQYXJ0TGVuZ3RoKDAsIHBhcmFtZXRlcilcblx0XHRcdFx0XHQ8IGN1cnZlLmdldFBhcnRMZW5ndGgocGFyYW1ldGVyLCAxKVxuXHRcdFx0XHRcdFx0PyBjdXJ2ZS5fc2VnbWVudDFcblx0XHRcdFx0XHRcdDogY3VydmUuX3NlZ21lbnQyO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fc2VnbWVudCA9IHNlZ21lbnQ7XG5cdFx0fVxuXHRcdHJldHVybiBzZWdtZW50O1xuXHR9LFxuXG5cdGdldEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmUgPSB0aGlzLl9jdXJ2ZSxcblx0XHRcdHBhdGggPSBjdXJ2ZSAmJiBjdXJ2ZS5fcGF0aCxcblx0XHRcdHRoYXQgPSB0aGlzO1xuXHRcdGlmIChwYXRoICYmIHBhdGguX3ZlcnNpb24gIT09IHRoaXMuX3ZlcnNpb24pIHtcblx0XHRcdGN1cnZlID0gdGhpcy5fcGFyYW1ldGVyID0gdGhpcy5fY3VydmUgPSB0aGlzLl9vZmZzZXQgPSBudWxsO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIHRyeVNlZ21lbnQoc2VnbWVudCkge1xuXHRcdFx0dmFyIGN1cnZlID0gc2VnbWVudCAmJiBzZWdtZW50LmdldEN1cnZlKCk7XG5cdFx0XHRpZiAoY3VydmUgJiYgKHRoYXQuX3BhcmFtZXRlciA9IGN1cnZlLmdldFBhcmFtZXRlck9mKHRoYXQuX3BvaW50KSlcblx0XHRcdFx0XHQhPSBudWxsKSB7XG5cdFx0XHRcdHRoYXQuX3NldEN1cnZlKGN1cnZlKTtcblx0XHRcdFx0dGhhdC5fc2VnbWVudCA9IHNlZ21lbnQ7XG5cdFx0XHRcdHJldHVybiBjdXJ2ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gY3VydmVcblx0XHRcdHx8IHRyeVNlZ21lbnQodGhpcy5fc2VnbWVudClcblx0XHRcdHx8IHRyeVNlZ21lbnQodGhpcy5fc2VnbWVudDEpXG5cdFx0XHR8fCB0cnlTZWdtZW50KHRoaXMuX3NlZ21lbnQyLmdldFByZXZpb3VzKCkpO1xuXHR9LFxuXG5cdGdldFBhdGg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuX3BhdGg7XG5cdH0sXG5cblx0Z2V0SW5kZXg6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmUgJiYgY3VydmUuZ2V0SW5kZXgoKTtcblx0fSxcblxuXHRnZXRQYXJhbWV0ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKSxcblx0XHRcdHBhcmFtZXRlciA9IHRoaXMuX3BhcmFtZXRlcjtcblx0XHRyZXR1cm4gY3VydmUgJiYgcGFyYW1ldGVyID09IG51bGxcblx0XHRcdD8gdGhpcy5fcGFyYW1ldGVyID0gY3VydmUuZ2V0UGFyYW1ldGVyT2YodGhpcy5fcG9pbnQpXG5cdFx0XHQ6IHBhcmFtZXRlcjtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3BvaW50O1xuXHR9LFxuXG5cdGdldE9mZnNldDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIG9mZnNldCA9IHRoaXMuX29mZnNldDtcblx0XHRpZiAob2Zmc2V0ID09IG51bGwpIHtcblx0XHRcdG9mZnNldCA9IDA7XG5cdFx0XHR2YXIgcGF0aCA9IHRoaXMuZ2V0UGF0aCgpLFxuXHRcdFx0XHRpbmRleCA9IHRoaXMuZ2V0SW5kZXgoKTtcblx0XHRcdGlmIChwYXRoICYmIGluZGV4ICE9IG51bGwpIHtcblx0XHRcdFx0dmFyIGN1cnZlcyA9IHBhdGguZ2V0Q3VydmVzKCk7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgaW5kZXg7IGkrKylcblx0XHRcdFx0XHRvZmZzZXQgKz0gY3VydmVzW2ldLmdldExlbmd0aCgpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fb2Zmc2V0ID0gb2Zmc2V0ICs9IHRoaXMuZ2V0Q3VydmVPZmZzZXQoKTtcblx0XHR9XG5cdFx0cmV0dXJuIG9mZnNldDtcblx0fSxcblxuXHRnZXRDdXJ2ZU9mZnNldDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0cGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXIoKTtcblx0XHRyZXR1cm4gcGFyYW1ldGVyICE9IG51bGwgJiYgY3VydmUgJiYgY3VydmUuZ2V0UGFydExlbmd0aCgwLCBwYXJhbWV0ZXIpO1xuXHR9LFxuXG5cdGdldEludGVyc2VjdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2ludGVyc2VjdGlvbjtcblx0fSxcblxuXHRnZXREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Rpc3RhbmNlO1xuXHR9LFxuXG5cdGRpdmlkZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0cmVzID0gbnVsbDtcblx0XHRpZiAoY3VydmUpIHtcblx0XHRcdHJlcyA9IGN1cnZlLmRpdmlkZSh0aGlzLmdldFBhcmFtZXRlcigpLCB0cnVlKTtcblx0XHRcdGlmIChyZXMpXG5cdFx0XHRcdHRoaXMuX3NldFNlZ21lbnQocmVzLl9zZWdtZW50MSk7XG5cdFx0fVxuXHRcdHJldHVybiByZXM7XG5cdH0sXG5cblx0c3BsaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZSA9IHRoaXMuZ2V0Q3VydmUoKTtcblx0XHRyZXR1cm4gY3VydmUgPyBjdXJ2ZS5zcGxpdCh0aGlzLmdldFBhcmFtZXRlcigpLCB0cnVlKSA6IG51bGw7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihsb2MsIF9pZ25vcmVPdGhlcikge1xuXHRcdHZhciByZXMgPSB0aGlzID09PSBsb2MsXG5cdFx0XHRlcHNpbG9uID0gMmUtNztcblx0XHRpZiAoIXJlcyAmJiBsb2MgaW5zdGFuY2VvZiBDdXJ2ZUxvY2F0aW9uXG5cdFx0XHRcdCYmIHRoaXMuZ2V0UGF0aCgpID09PSBsb2MuZ2V0UGF0aCgpXG5cdFx0XHRcdCYmIHRoaXMuZ2V0UG9pbnQoKS5pc0Nsb3NlKGxvYy5nZXRQb2ludCgpLCBlcHNpbG9uKSkge1xuXHRcdFx0dmFyIGMxID0gdGhpcy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRjMiA9IGxvYy5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRhYnMgPSBNYXRoLmFicyxcblx0XHRcdFx0ZGlmZiA9IGFicyhcblx0XHRcdFx0XHQoKGMxLmlzTGFzdCgpICYmIGMyLmlzRmlyc3QoKSA/IC0xIDogYzEuZ2V0SW5kZXgoKSlcblx0XHRcdFx0XHRcdFx0KyB0aGlzLmdldFBhcmFtZXRlcigpKSAtXG5cdFx0XHRcdFx0KChjMi5pc0xhc3QoKSAmJiBjMS5pc0ZpcnN0KCkgPyAtMSA6IGMyLmdldEluZGV4KCkpXG5cdFx0XHRcdFx0XHRcdCsgbG9jLmdldFBhcmFtZXRlcigpKSk7XG5cdFx0XHRyZXMgPSAoZGlmZiA8IDRlLTdcblx0XHRcdFx0fHwgKChkaWZmID0gYWJzKHRoaXMuZ2V0T2Zmc2V0KCkgLSBsb2MuZ2V0T2Zmc2V0KCkpKSA8IGVwc2lsb25cblx0XHRcdFx0XHR8fCBhYnModGhpcy5nZXRQYXRoKCkuZ2V0TGVuZ3RoKCkgLSBkaWZmKSA8IGVwc2lsb24pKVxuXHRcdFx0XHQmJiAoX2lnbm9yZU90aGVyXG5cdFx0XHRcdFx0fHwgKCF0aGlzLl9pbnRlcnNlY3Rpb24gJiYgIWxvYy5faW50ZXJzZWN0aW9uXG5cdFx0XHRcdFx0XHR8fCB0aGlzLl9pbnRlcnNlY3Rpb24gJiYgdGhpcy5faW50ZXJzZWN0aW9uLmVxdWFscyhcblx0XHRcdFx0XHRcdFx0XHRsb2MuX2ludGVyc2VjdGlvbiwgdHJ1ZSkpKTtcblx0XHR9XG5cdFx0cmV0dXJuIHJlcztcblx0fSxcblxuXHR0b1N0cmluZzogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcnRzID0gW10sXG5cdFx0XHRwb2ludCA9IHRoaXMuZ2V0UG9pbnQoKSxcblx0XHRcdGYgPSBGb3JtYXR0ZXIuaW5zdGFuY2U7XG5cdFx0aWYgKHBvaW50KVxuXHRcdFx0cGFydHMucHVzaCgncG9pbnQ6ICcgKyBwb2ludCk7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5nZXRJbmRleCgpO1xuXHRcdGlmIChpbmRleCAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgnaW5kZXg6ICcgKyBpbmRleCk7XG5cdFx0dmFyIHBhcmFtZXRlciA9IHRoaXMuZ2V0UGFyYW1ldGVyKCk7XG5cdFx0aWYgKHBhcmFtZXRlciAhPSBudWxsKVxuXHRcdFx0cGFydHMucHVzaCgncGFyYW1ldGVyOiAnICsgZi5udW1iZXIocGFyYW1ldGVyKSk7XG5cdFx0aWYgKHRoaXMuX2Rpc3RhbmNlICE9IG51bGwpXG5cdFx0XHRwYXJ0cy5wdXNoKCdkaXN0YW5jZTogJyArIGYubnVtYmVyKHRoaXMuX2Rpc3RhbmNlKSk7XG5cdFx0cmV0dXJuICd7ICcgKyBwYXJ0cy5qb2luKCcsICcpICsgJyB9Jztcblx0fSxcblxuXHRpc1RvdWNoaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW50ZXIgPSB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdFx0aWYgKGludGVyICYmIHRoaXMuZ2V0VGFuZ2VudCgpLmlzQ29sbGluZWFyKGludGVyLmdldFRhbmdlbnQoKSkpIHtcblx0XHRcdHZhciBjdXJ2ZTEgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRcdGN1cnZlMiA9IGludGVyLmdldEN1cnZlKCk7XG5cdFx0XHRyZXR1cm4gIShjdXJ2ZTEuaXNTdHJhaWdodCgpICYmIGN1cnZlMi5pc1N0cmFpZ2h0KClcblx0XHRcdFx0XHQmJiBjdXJ2ZTEuZ2V0TGluZSgpLmludGVyc2VjdChjdXJ2ZTIuZ2V0TGluZSgpKSk7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRpc0Nyb3NzaW5nOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgaW50ZXIgPSB0aGlzLl9pbnRlcnNlY3Rpb247XG5cdFx0aWYgKCFpbnRlcilcblx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR2YXIgdDEgPSB0aGlzLmdldFBhcmFtZXRlcigpLFxuXHRcdFx0dDIgPSBpbnRlci5nZXRQYXJhbWV0ZXIoKSxcblx0XHRcdHRNaW4gPSA0ZS03LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdGlmICh0MSA+PSB0TWluICYmIHQxIDw9IHRNYXggfHwgdDIgPj0gdE1pbiAmJiB0MiA8PSB0TWF4KVxuXHRcdFx0cmV0dXJuICF0aGlzLmlzVG91Y2hpbmcoKTtcblx0XHR2YXIgYzIgPSB0aGlzLmdldEN1cnZlKCksXG5cdFx0XHRjMSA9IGMyLmdldFByZXZpb3VzKCksXG5cdFx0XHRjNCA9IGludGVyLmdldEN1cnZlKCksXG5cdFx0XHRjMyA9IGM0LmdldFByZXZpb3VzKCksXG5cdFx0XHRQSSA9IE1hdGguUEk7XG5cdFx0aWYgKCFjMSB8fCAhYzMpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRmdW5jdGlvbiBpc0luUmFuZ2UoYW5nbGUsIG1pbiwgbWF4KSB7XG5cdFx0XHRyZXR1cm4gbWluIDwgbWF4XG5cdFx0XHRcdD8gYW5nbGUgPiBtaW4gJiYgYW5nbGUgPCBtYXhcblx0XHRcdFx0OiBhbmdsZSA+IG1pbiAmJiBhbmdsZSA8PSBQSSB8fCBhbmdsZSA+PSAtUEkgJiYgYW5nbGUgPCBtYXg7XG5cdFx0fVxuXG5cdFx0dmFyIGExID0gYzEuZ2V0VGFuZ2VudEF0KHRNYXgsIHRydWUpLm5lZ2F0ZSgpLmdldEFuZ2xlSW5SYWRpYW5zKCksXG5cdFx0XHRhMiA9IGMyLmdldFRhbmdlbnRBdCh0TWluLCB0cnVlKS5nZXRBbmdsZUluUmFkaWFucygpLFxuXHRcdFx0YTMgPSBjMy5nZXRUYW5nZW50QXQodE1heCwgdHJ1ZSkubmVnYXRlKCkuZ2V0QW5nbGVJblJhZGlhbnMoKSxcblx0XHRcdGE0ID0gYzQuZ2V0VGFuZ2VudEF0KHRNaW4sIHRydWUpLmdldEFuZ2xlSW5SYWRpYW5zKCk7XG5cblx0XHRyZXR1cm4gKGlzSW5SYW5nZShhMywgYTEsIGEyKSBeIGlzSW5SYW5nZShhNCwgYTEsIGEyKSlcblx0XHRcdCYmIChpc0luUmFuZ2UoYTMsIGEyLCBhMSkgXiBpc0luUmFuZ2UoYTQsIGEyLCBhMSkpO1xuXHR9LFxuXG5cdGlzT3ZlcmxhcDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEhdGhpcy5fb3ZlcmxhcDtcblx0fVxufSwgQmFzZS5lYWNoKEN1cnZlLmV2YWx1YXRlTWV0aG9kcywgZnVuY3Rpb24obmFtZSkge1xuXHR2YXIgZ2V0ID0gbmFtZSArICdBdCc7XG5cdHRoaXNbbmFtZV0gPSBmdW5jdGlvbigpIHtcblx0XHR2YXIgcGFyYW1ldGVyID0gdGhpcy5nZXRQYXJhbWV0ZXIoKSxcblx0XHRcdGN1cnZlID0gdGhpcy5nZXRDdXJ2ZSgpO1xuXHRcdHJldHVybiBwYXJhbWV0ZXIgIT0gbnVsbCAmJiBjdXJ2ZSAmJiBjdXJ2ZVtnZXRdKHBhcmFtZXRlciwgdHJ1ZSk7XG5cdH07XG59LCB7XG5cdHByZXNlcnZlOiB0cnVlXG59KSxcbm5ldyBmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBpbnNlcnQobG9jYXRpb25zLCBsb2MsIG1lcmdlKSB7XG5cdFx0dmFyIGxlbmd0aCA9IGxvY2F0aW9ucy5sZW5ndGgsXG5cdFx0XHRsID0gMCxcblx0XHRcdHIgPSBsZW5ndGggLSAxO1xuXG5cdFx0ZnVuY3Rpb24gc2VhcmNoKGluZGV4LCBkaXIpIHtcblx0XHRcdGZvciAodmFyIGkgPSBpbmRleCArIGRpcjsgaSA+PSAtMSAmJiBpIDw9IGxlbmd0aDsgaSArPSBkaXIpIHtcblx0XHRcdFx0dmFyIGxvYzIgPSBsb2NhdGlvbnNbKChpICUgbGVuZ3RoKSArIGxlbmd0aCkgJSBsZW5ndGhdO1xuXHRcdFx0XHRpZiAoIWxvYy5nZXRQb2ludCgpLmlzQ2xvc2UobG9jMi5nZXRQb2ludCgpLFxuXHRcdFx0XHRcdFx0MmUtNykpXG5cdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdGlmIChsb2MuZXF1YWxzKGxvYzIpKVxuXHRcdFx0XHRcdHJldHVybiBsb2MyO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0d2hpbGUgKGwgPD0gcikge1xuXHRcdFx0dmFyIG0gPSAobCArIHIpID4+PiAxLFxuXHRcdFx0XHRsb2MyID0gbG9jYXRpb25zW21dLFxuXHRcdFx0XHRmb3VuZDtcblx0XHRcdGlmIChtZXJnZSAmJiAoZm91bmQgPSBsb2MuZXF1YWxzKGxvYzIpID8gbG9jMlxuXHRcdFx0XHRcdDogKHNlYXJjaChtLCAtMSkgfHwgc2VhcmNoKG0sIDEpKSkpIHtcblx0XHRcdFx0aWYgKGxvYy5fb3ZlcmxhcCkge1xuXHRcdFx0XHRcdGZvdW5kLl9vdmVybGFwID0gZm91bmQuX2ludGVyc2VjdGlvbi5fb3ZlcmxhcCA9IHRydWU7XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIGZvdW5kO1xuXHRcdFx0fVxuXHRcdHZhciBwYXRoMSA9IGxvYy5nZXRQYXRoKCksXG5cdFx0XHRwYXRoMiA9IGxvYzIuZ2V0UGF0aCgpLFxuXHRcdFx0ZGlmZiA9IHBhdGgxID09PSBwYXRoMlxuXHRcdFx0XHQ/IChsb2MuZ2V0SW5kZXgoKSArIGxvYy5nZXRQYXJhbWV0ZXIoKSlcblx0XHRcdFx0LSAobG9jMi5nZXRJbmRleCgpICsgbG9jMi5nZXRQYXJhbWV0ZXIoKSlcblx0XHRcdFx0OiBwYXRoMS5faWQgLSBwYXRoMi5faWQ7XG5cdFx0XHRpZiAoZGlmZiA8IDApIHtcblx0XHRcdFx0ciA9IG0gLSAxO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0bCA9IG0gKyAxO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRsb2NhdGlvbnMuc3BsaWNlKGwsIDAsIGxvYyk7XG5cdFx0cmV0dXJuIGxvYztcblx0fVxuXG5cdHJldHVybiB7IHN0YXRpY3M6IHtcblx0XHRpbnNlcnQ6IGluc2VydCxcblxuXHRcdGV4cGFuZDogZnVuY3Rpb24obG9jYXRpb25zKSB7XG5cdFx0XHR2YXIgZXhwYW5kZWQgPSBsb2NhdGlvbnMuc2xpY2UoKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbG9jYXRpb25zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpbnNlcnQoZXhwYW5kZWQsIGxvY2F0aW9uc1tpXS5faW50ZXJzZWN0aW9uLCBmYWxzZSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZXhwYW5kZWQ7XG5cdFx0fVxuXHR9fTtcbn0pO1xuXG52YXIgUGF0aEl0ZW0gPSBJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BhdGhJdGVtJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBQYXRoSXRlbSgpIHtcblx0fSxcblxuXHRnZXRJbnRlcnNlY3Rpb25zOiBmdW5jdGlvbihwYXRoLCBpbmNsdWRlLCBfbWF0cml4LCBfcmV0dXJuRmlyc3QpIHtcblx0XHR2YXIgc2VsZiA9IHRoaXMgPT09IHBhdGggfHwgIXBhdGgsXG5cdFx0XHRtYXRyaXgxID0gdGhpcy5fbWF0cml4Lm9yTnVsbElmSWRlbnRpdHkoKSxcblx0XHRcdG1hdHJpeDIgPSBzZWxmID8gbWF0cml4MVxuXHRcdFx0XHQ6IChfbWF0cml4IHx8IHBhdGguX21hdHJpeCkub3JOdWxsSWZJZGVudGl0eSgpO1xuXHRcdGlmICghc2VsZiAmJiAhdGhpcy5nZXRCb3VuZHMobWF0cml4MSkudG91Y2hlcyhwYXRoLmdldEJvdW5kcyhtYXRyaXgyKSkpXG5cdFx0XHRyZXR1cm4gW107XG5cdFx0dmFyIGN1cnZlczEgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0Y3VydmVzMiA9IHNlbGYgPyBjdXJ2ZXMxIDogcGF0aC5nZXRDdXJ2ZXMoKSxcblx0XHRcdGxlbmd0aDEgPSBjdXJ2ZXMxLmxlbmd0aCxcblx0XHRcdGxlbmd0aDIgPSBzZWxmID8gbGVuZ3RoMSA6IGN1cnZlczIubGVuZ3RoLFxuXHRcdFx0dmFsdWVzMiA9IFtdLFxuXHRcdFx0YXJyYXlzID0gW10sXG5cdFx0XHRsb2NhdGlvbnMsXG5cdFx0XHRwYXRoO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMjsgaSsrKVxuXHRcdFx0dmFsdWVzMltpXSA9IGN1cnZlczJbaV0uZ2V0VmFsdWVzKG1hdHJpeDIpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoMTsgaSsrKSB7XG5cdFx0XHR2YXIgY3VydmUxID0gY3VydmVzMVtpXSxcblx0XHRcdFx0dmFsdWVzMSA9IHNlbGYgPyB2YWx1ZXMyW2ldIDogY3VydmUxLmdldFZhbHVlcyhtYXRyaXgxKSxcblx0XHRcdFx0cGF0aDEgPSBjdXJ2ZTEuZ2V0UGF0aCgpO1xuXHRcdFx0aWYgKHBhdGgxICE9PSBwYXRoKSB7XG5cdFx0XHRcdHBhdGggPSBwYXRoMTtcblx0XHRcdFx0bG9jYXRpb25zID0gW107XG5cdFx0XHRcdGFycmF5cy5wdXNoKGxvY2F0aW9ucyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoc2VsZikge1xuXHRcdFx0XHRDdXJ2ZS5fZ2V0U2VsZkludGVyc2VjdGlvbih2YWx1ZXMxLCBjdXJ2ZTEsIGxvY2F0aW9ucywge1xuXHRcdFx0XHRcdGluY2x1ZGU6IGluY2x1ZGUsXG5cdFx0XHRcdFx0c3RhcnRDb25uZWN0ZWQ6IGxlbmd0aDEgPT09IDEgJiZcblx0XHRcdFx0XHRcdFx0Y3VydmUxLmdldFBvaW50MSgpLmVxdWFscyhjdXJ2ZTEuZ2V0UG9pbnQyKCkpXG5cdFx0XHRcdH0pO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaiA9IHNlbGYgPyBpICsgMSA6IDA7IGogPCBsZW5ndGgyOyBqKyspIHtcblx0XHRcdFx0aWYgKF9yZXR1cm5GaXJzdCAmJiBsb2NhdGlvbnMubGVuZ3RoKVxuXHRcdFx0XHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdFx0XHRcdHZhciBjdXJ2ZTIgPSBjdXJ2ZXMyW2pdO1xuXHRcdFx0XHRDdXJ2ZS5fZ2V0SW50ZXJzZWN0aW9ucyhcblx0XHRcdFx0XHR2YWx1ZXMxLCB2YWx1ZXMyW2pdLCBjdXJ2ZTEsIGN1cnZlMiwgbG9jYXRpb25zLFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGluY2x1ZGU6IGluY2x1ZGUsXG5cdFx0XHRcdFx0XHRzdGFydENvbm5lY3RlZDogc2VsZiAmJiBjdXJ2ZTEuZ2V0UHJldmlvdXMoKSA9PT0gY3VydmUyLFxuXHRcdFx0XHRcdFx0ZW5kQ29ubmVjdGVkOiBzZWxmICYmIGN1cnZlMS5nZXROZXh0KCkgPT09IGN1cnZlMlxuXHRcdFx0XHRcdH1cblx0XHRcdFx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0bG9jYXRpb25zID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBhcnJheXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRsb2NhdGlvbnMucHVzaC5hcHBseShsb2NhdGlvbnMsIGFycmF5c1tpXSk7XG5cdFx0fVxuXHRcdHJldHVybiBsb2NhdGlvbnM7XG5cdH0sXG5cblx0Z2V0Q3Jvc3NpbmdzOiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0SW50ZXJzZWN0aW9ucyhwYXRoLCBmdW5jdGlvbihpbnRlcikge1xuXHRcdFx0cmV0dXJuIGludGVyLmlzQ3Jvc3NpbmcoKTtcblx0XHR9KTtcblx0fSxcblxuXHRfYXNQYXRoSXRlbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0c2V0UGF0aERhdGE6IGZ1bmN0aW9uKGRhdGEpIHtcblxuXHRcdHZhciBwYXJ0cyA9IGRhdGEubWF0Y2goL1ttbGh2Y3NxdGF6XVtebWxodmNzcXRhel0qL2lnKSxcblx0XHRcdGNvb3Jkcyxcblx0XHRcdHJlbGF0aXZlID0gZmFsc2UsXG5cdFx0XHRwcmV2aW91cyxcblx0XHRcdGNvbnRyb2wsXG5cdFx0XHRjdXJyZW50ID0gbmV3IFBvaW50KCksXG5cdFx0XHRzdGFydCA9IG5ldyBQb2ludCgpO1xuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29vcmQoaW5kZXgsIGNvb3JkKSB7XG5cdFx0XHR2YXIgdmFsID0gK2Nvb3Jkc1tpbmRleF07XG5cdFx0XHRpZiAocmVsYXRpdmUpXG5cdFx0XHRcdHZhbCArPSBjdXJyZW50W2Nvb3JkXTtcblx0XHRcdHJldHVybiB2YWw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0UG9pbnQoaW5kZXgpIHtcblx0XHRcdHJldHVybiBuZXcgUG9pbnQoXG5cdFx0XHRcdGdldENvb3JkKGluZGV4LCAneCcpLFxuXHRcdFx0XHRnZXRDb29yZChpbmRleCArIDEsICd5Jylcblx0XHRcdCk7XG5cdFx0fVxuXG5cdFx0dGhpcy5jbGVhcigpO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cyAmJiBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBwYXJ0ID0gcGFydHNbaV0sXG5cdFx0XHRcdGNvbW1hbmQgPSBwYXJ0WzBdLFxuXHRcdFx0XHRsb3dlciA9IGNvbW1hbmQudG9Mb3dlckNhc2UoKTtcblx0XHRcdGNvb3JkcyA9IHBhcnQubWF0Y2goL1srLV0/KD86XFxkKlxcLlxcZCt8XFxkK1xcLj8pKD86W2VFXVsrLV0/XFxkKyk/L2cpO1xuXHRcdFx0dmFyIGxlbmd0aCA9IGNvb3JkcyAmJiBjb29yZHMubGVuZ3RoO1xuXHRcdFx0cmVsYXRpdmUgPSBjb21tYW5kID09PSBsb3dlcjtcblx0XHRcdGlmIChwcmV2aW91cyA9PT0gJ3onICYmICEvW216XS8udGVzdChsb3dlcikpXG5cdFx0XHRcdHRoaXMubW92ZVRvKGN1cnJlbnQgPSBzdGFydCk7XG5cdFx0XHRzd2l0Y2ggKGxvd2VyKSB7XG5cdFx0XHRjYXNlICdtJzpcblx0XHRcdGNhc2UgJ2wnOlxuXHRcdFx0XHR2YXIgbW92ZSA9IGxvd2VyID09PSAnbSc7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDIpXG5cdFx0XHRcdFx0dGhpc1tqID09PSAwICYmIG1vdmUgPyAnbW92ZVRvJyA6ICdsaW5lVG8nXShcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0Y29udHJvbCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGlmIChtb3ZlKVxuXHRcdFx0XHRcdHN0YXJ0ID0gY3VycmVudDtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICdoJzpcblx0XHRcdGNhc2UgJ3YnOlxuXHRcdFx0XHR2YXIgY29vcmQgPSBsb3dlciA9PT0gJ2gnID8gJ3gnIDogJ3knO1xuXHRcdFx0XHRmb3IgKHZhciBqID0gMDsgaiA8IGxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdFx0Y3VycmVudFtjb29yZF0gPSBnZXRDb29yZChqLCBjb29yZCk7XG5cdFx0XHRcdFx0dGhpcy5saW5lVG8oY3VycmVudCk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y29udHJvbCA9IGN1cnJlbnQ7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDYpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Z2V0UG9pbnQoaiksXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqICsgMiksXG5cdFx0XHRcdFx0XHRcdGN1cnJlbnQgPSBnZXRQb2ludChqICsgNCkpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncyc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLmN1YmljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0L1tjc10vLnRlc3QocHJldmlvdXMpXG5cdFx0XHRcdFx0XHRcdFx0XHQ/IGN1cnJlbnQubXVsdGlwbHkoMikuc3VidHJhY3QoY29udHJvbClcblx0XHRcdFx0XHRcdFx0XHRcdDogY3VycmVudCxcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9IGdldFBvaW50KGopLFxuXHRcdFx0XHRcdFx0XHRjdXJyZW50ID0gZ2V0UG9pbnQoaiArIDIpKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDQpIHtcblx0XHRcdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oXG5cdFx0XHRcdFx0XHRcdGNvbnRyb2wgPSBnZXRQb2ludChqKSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGogKyAyKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0Jzpcblx0XHRcdFx0Zm9yICh2YXIgaiA9IDA7IGogPCBsZW5ndGg7IGogKz0gMikge1xuXHRcdFx0XHRcdHRoaXMucXVhZHJhdGljQ3VydmVUbyhcblx0XHRcdFx0XHRcdFx0Y29udHJvbCA9ICgvW3F0XS8udGVzdChwcmV2aW91cylcblx0XHRcdFx0XHRcdFx0XHRcdD8gY3VycmVudC5tdWx0aXBseSgyKS5zdWJ0cmFjdChjb250cm9sKVxuXHRcdFx0XHRcdFx0XHRcdFx0OiBjdXJyZW50KSxcblx0XHRcdFx0XHRcdFx0Y3VycmVudCA9IGdldFBvaW50KGopKTtcblx0XHRcdFx0XHRwcmV2aW91cyA9IGxvd2VyO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnYSc6XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgbGVuZ3RoOyBqICs9IDcpIHtcblx0XHRcdFx0XHR0aGlzLmFyY1RvKGN1cnJlbnQgPSBnZXRQb2ludChqICsgNSksXG5cdFx0XHRcdFx0XHRcdG5ldyBTaXplKCtjb29yZHNbal0sICtjb29yZHNbaiArIDFdKSxcblx0XHRcdFx0XHRcdFx0K2Nvb3Jkc1tqICsgMl0sICtjb29yZHNbaiArIDRdLCArY29vcmRzW2ogKyAzXSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd6Jzpcblx0XHRcdFx0dGhpcy5jbG9zZVBhdGgodHJ1ZSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cHJldmlvdXMgPSBsb3dlcjtcblx0XHR9XG5cdH0sXG5cblx0X2NhbkNvbXBvc2l0ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICEodGhpcy5oYXNGaWxsKCkgJiYgdGhpcy5oYXNTdHJva2UoKSk7XG5cdH0sXG5cblx0X2NvbnRhaW5zOiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHZhciB3aW5kaW5nID0gdGhpcy5fZ2V0V2luZGluZyhwb2ludCwgZmFsc2UsIHRydWUpO1xuXHRcdHJldHVybiAhISh0aGlzLmdldFdpbmRpbmdSdWxlKCkgPT09ICdldmVub2RkJyA/IHdpbmRpbmcgJiAxIDogd2luZGluZyk7XG5cdH1cblxufSk7XG5cbnZhciBQYXRoID0gUGF0aEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aCcsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRzZWdtZW50czogW10sXG5cdFx0Y2xvc2VkOiBmYWxzZVxuXHR9LFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFBhdGgoYXJnKSB7XG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2U7XG5cdFx0dGhpcy5fc2VnbWVudHMgPSBbXTtcblx0XHR0aGlzLl92ZXJzaW9uID0gMDtcblx0XHR2YXIgc2VnbWVudHMgPSBBcnJheS5pc0FycmF5KGFyZylcblx0XHRcdD8gdHlwZW9mIGFyZ1swXSA9PT0gJ29iamVjdCdcblx0XHRcdFx0PyBhcmdcblx0XHRcdFx0OiBhcmd1bWVudHNcblx0XHRcdDogYXJnICYmIChhcmcuc2l6ZSA9PT0gdW5kZWZpbmVkICYmIChhcmcueCAhPT0gdW5kZWZpbmVkXG5cdFx0XHRcdFx0fHwgYXJnLnBvaW50ICE9PSB1bmRlZmluZWQpKVxuXHRcdFx0XHQ/IGFyZ3VtZW50c1xuXHRcdFx0XHQ6IG51bGw7XG5cdFx0aWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApIHtcblx0XHRcdHRoaXMuc2V0U2VnbWVudHMoc2VnbWVudHMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0XHR0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA9IDA7XG5cdFx0XHRpZiAoIXNlZ21lbnRzICYmIHR5cGVvZiBhcmcgPT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdHRoaXMuc2V0UGF0aERhdGEoYXJnKTtcblx0XHRcdFx0YXJnID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dGhpcy5faW5pdGlhbGl6ZSghc2VnbWVudHMgJiYgYXJnKTtcblx0fSxcblxuXHRfZXF1YWxzOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZCA9PT0gaXRlbS5fY2xvc2VkXG5cdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX3NlZ21lbnRzLCBpdGVtLl9zZWdtZW50cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHZhciBjb3B5ID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdGNvcHkuc2V0U2VnbWVudHModGhpcy5fc2VnbWVudHMpO1xuXHRcdGNvcHkuX2Nsb3NlZCA9IHRoaXMuX2Nsb3NlZDtcblx0XHRpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRjb3B5Ll9jbG9ja3dpc2UgPSB0aGlzLl9jbG9ja3dpc2U7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb25lKGNvcHksIGluc2VydCk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uIF9jaGFuZ2VkKGZsYWdzKSB7XG5cdFx0X2NoYW5nZWQuYmFzZS5jYWxsKHRoaXMsIGZsYWdzKTtcblx0XHRpZiAoZmxhZ3MgJiA4KSB7XG5cdFx0XHR2YXIgcGFyZW50ID0gdGhpcy5fcGFyZW50O1xuXHRcdFx0aWYgKHBhcmVudClcblx0XHRcdFx0cGFyZW50Ll9jdXJyZW50UGF0aCA9IHVuZGVmaW5lZDtcblx0XHRcdHRoaXMuX2xlbmd0aCA9IHRoaXMuX2FyZWEgPSB0aGlzLl9jbG9ja3dpc2UgPSB0aGlzLl9tb25vQ3VydmVzID1cblx0XHRcdFx0XHR1bmRlZmluZWQ7XG5cdFx0XHRpZiAoZmxhZ3MgJiAxNikge1xuXHRcdFx0XHR0aGlzLl92ZXJzaW9uKys7XG5cdFx0XHR9IGVsc2UgaWYgKHRoaXMuX2N1cnZlcykge1xuXHRcdFx0ICAgZm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9jdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHRoaXMuX2N1cnZlc1tpXS5fY2hhbmdlZCgpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSBpZiAoZmxhZ3MgJiAzMikge1xuXHRcdFx0dGhpcy5fYm91bmRzID0gdW5kZWZpbmVkO1xuXHRcdH1cblx0fSxcblxuXHRnZXRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBhcmVudCA9IHRoaXMuX3BhcmVudDtcblx0XHRyZXR1cm4gKHBhcmVudCBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCA/IHBhcmVudCA6IHRoaXMpLl9zdHlsZTtcblx0fSxcblxuXHRnZXRTZWdtZW50czogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3NlZ21lbnRzO1xuXHR9LFxuXG5cdHNldFNlZ21lbnRzOiBmdW5jdGlvbihzZWdtZW50cykge1xuXHRcdHZhciBmdWxseVNlbGVjdGVkID0gdGhpcy5pc0Z1bGx5U2VsZWN0ZWQoKTtcblx0XHR0aGlzLl9zZWdtZW50cy5sZW5ndGggPSAwO1xuXHRcdHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlID0gMDtcblx0XHR0aGlzLl9jdXJ2ZXMgPSB1bmRlZmluZWQ7XG5cdFx0aWYgKHNlZ21lbnRzICYmIHNlZ21lbnRzLmxlbmd0aCA+IDApXG5cdFx0XHR0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKHNlZ21lbnRzKSk7XG5cdFx0aWYgKGZ1bGx5U2VsZWN0ZWQpXG5cdFx0XHR0aGlzLnNldEZ1bGx5U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0Z2V0Rmlyc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHNbMF07XG5cdH0sXG5cblx0Z2V0TGFzdFNlZ21lbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9zZWdtZW50c1t0aGlzLl9zZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRnZXRDdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLl9jdXJ2ZXMsXG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGlmICghY3VydmVzKSB7XG5cdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY291bnRDdXJ2ZXMoKTtcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyA9IG5ldyBBcnJheShsZW5ndGgpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdFx0Y3VydmVzW2ldID0gbmV3IEN1cnZlKHRoaXMsIHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRcdHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXSk7XG5cdFx0fVxuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q3VydmVzKClbMF07XG5cdH0sXG5cblx0Z2V0TGFzdEN1cnZlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRyZXR1cm4gY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXTtcblx0fSxcblxuXHRpc0Nsb3NlZDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZDtcblx0fSxcblxuXHRzZXRDbG9zZWQ6IGZ1bmN0aW9uKGNsb3NlZCkge1xuXHRcdGlmICh0aGlzLl9jbG9zZWQgIT0gKGNsb3NlZCA9ICEhY2xvc2VkKSkge1xuXHRcdFx0dGhpcy5fY2xvc2VkID0gY2xvc2VkO1xuXHRcdFx0aWYgKHRoaXMuX2N1cnZlcykge1xuXHRcdFx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fY3VydmVzLmxlbmd0aCA9IHRoaXMuX2NvdW50Q3VydmVzKCk7XG5cdFx0XHRcdGlmIChjbG9zZWQpXG5cdFx0XHRcdFx0dGhpcy5fY3VydmVzW2xlbmd0aCAtIDFdID0gbmV3IEN1cnZlKHRoaXMsXG5cdFx0XHRcdFx0XHR0aGlzLl9zZWdtZW50c1tsZW5ndGggLSAxXSwgdGhpcy5fc2VnbWVudHNbMF0pO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY2hhbmdlZCgyNSk7XG5cdFx0fVxuXHR9XG59LCB7XG5cdGJlYW5zOiB0cnVlLFxuXG5cdGdldFBhdGhEYXRhOiBmdW5jdGlvbihfbWF0cml4LCBfcHJlY2lzaW9uKSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRmID0gbmV3IEZvcm1hdHRlcihfcHJlY2lzaW9uKSxcblx0XHRcdGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdGZpcnN0ID0gdHJ1ZSxcblx0XHRcdGN1clgsIGN1clksXG5cdFx0XHRwcmV2WCwgcHJldlksXG5cdFx0XHRpblgsIGluWSxcblx0XHRcdG91dFgsIG91dFksXG5cdFx0XHRwYXJ0cyA9IFtdO1xuXG5cdFx0ZnVuY3Rpb24gYWRkU2VnbWVudChzZWdtZW50LCBza2lwTGluZSkge1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMoX21hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRjdXJYID0gY29vcmRzWzBdO1xuXHRcdFx0Y3VyWSA9IGNvb3Jkc1sxXTtcblx0XHRcdGlmIChmaXJzdCkge1xuXHRcdFx0XHRwYXJ0cy5wdXNoKCdNJyArIGYucGFpcihjdXJYLCBjdXJZKSk7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpblggPSBjb29yZHNbMl07XG5cdFx0XHRcdGluWSA9IGNvb3Jkc1szXTtcblx0XHRcdFx0aWYgKGluWCA9PT0gY3VyWCAmJiBpblkgPT09IGN1cllcblx0XHRcdFx0XHRcdCYmIG91dFggPT09IHByZXZYICYmIG91dFkgPT09IHByZXZZKSB7XG5cdFx0XHRcdFx0aWYgKCFza2lwTGluZSlcblx0XHRcdFx0XHRcdHBhcnRzLnB1c2goJ2wnICsgZi5wYWlyKGN1clggLSBwcmV2WCwgY3VyWSAtIHByZXZZKSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cGFydHMucHVzaCgnYycgKyBmLnBhaXIob3V0WCAtIHByZXZYLCBvdXRZIC0gcHJldlkpXG5cdFx0XHRcdFx0XHRcdCsgJyAnICsgZi5wYWlyKGluWCAtIHByZXZYLCBpblkgLSBwcmV2WSlcblx0XHRcdFx0XHRcdFx0KyAnICcgKyBmLnBhaXIoY3VyWCAtIHByZXZYLCBjdXJZIC0gcHJldlkpKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cHJldlggPSBjdXJYO1xuXHRcdFx0cHJldlkgPSBjdXJZO1xuXHRcdFx0b3V0WCA9IGNvb3Jkc1s0XTtcblx0XHRcdG91dFkgPSBjb29yZHNbNV07XG5cdFx0fVxuXG5cdFx0aWYgKGxlbmd0aCA9PT0gMClcblx0XHRcdHJldHVybiAnJztcblxuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRhZGRTZWdtZW50KHNlZ21lbnRzW2ldKTtcblx0XHRpZiAodGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDApIHtcblx0XHRcdGFkZFNlZ21lbnQoc2VnbWVudHNbMF0sIHRydWUpO1xuXHRcdFx0cGFydHMucHVzaCgneicpO1xuXHRcdH1cblx0XHRyZXR1cm4gcGFydHMuam9pbignJyk7XG5cdH1cbn0sIHtcblxuXHRpc0VtcHR5OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc2VnbWVudHMubGVuZ3RoID09PSAwO1xuXHR9LFxuXG5cdF90cmFuc2Zvcm1Db250ZW50OiBmdW5jdGlvbihtYXRyaXgpIHtcblx0XHR2YXIgY29vcmRzID0gbmV3IEFycmF5KDYpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0dGhpcy5fc2VnbWVudHNbaV0uX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCB0cnVlKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfYWRkOiBmdW5jdGlvbihzZWdzLCBpbmRleCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0YW1vdW50ID0gc2Vncy5sZW5ndGgsXG5cdFx0XHRhcHBlbmQgPSBpbmRleCA9PSBudWxsLFxuXHRcdFx0aW5kZXggPSBhcHBlbmQgPyBzZWdtZW50cy5sZW5ndGggOiBpbmRleDtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGFtb3VudDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ3NbaV07XG5cdFx0XHRpZiAoc2VnbWVudC5fcGF0aClcblx0XHRcdFx0c2VnbWVudCA9IHNlZ3NbaV0gPSBzZWdtZW50LmNsb25lKCk7XG5cdFx0XHRzZWdtZW50Ll9wYXRoID0gdGhpcztcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gaW5kZXggKyBpO1xuXHRcdFx0aWYgKHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlKVxuXHRcdFx0XHR0aGlzLl91cGRhdGVTZWxlY3Rpb24oc2VnbWVudCwgMCwgc2VnbWVudC5fc2VsZWN0aW9uU3RhdGUpO1xuXHRcdH1cblx0XHRpZiAoYXBwZW5kKSB7XG5cdFx0XHRzZWdtZW50cy5wdXNoLmFwcGx5KHNlZ21lbnRzLCBzZWdzKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0c2VnbWVudHMuc3BsaWNlLmFwcGx5KHNlZ21lbnRzLCBbaW5kZXgsIDBdLmNvbmNhdChzZWdzKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gaW5kZXggKyBhbW91bnQsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldLl9pbmRleCA9IGk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZXMpIHtcblx0XHRcdHZhciB0b3RhbCA9IHRoaXMuX2NvdW50Q3VydmVzKCksXG5cdFx0XHRcdGZyb20gPSBpbmRleCArIGFtb3VudCAtIDEgPT09IHRvdGFsID8gaW5kZXggLSAxIDogaW5kZXgsXG5cdFx0XHRcdHN0YXJ0ID0gZnJvbSxcblx0XHRcdFx0dG8gPSBNYXRoLm1pbihmcm9tICsgYW1vdW50LCB0b3RhbCk7XG5cdFx0XHRpZiAoc2Vncy5fY3VydmVzKSB7XG5cdFx0XHRcdGN1cnZlcy5zcGxpY2UuYXBwbHkoY3VydmVzLCBbZnJvbSwgMF0uY29uY2F0KHNlZ3MuX2N1cnZlcykpO1xuXHRcdFx0XHRzdGFydCArPSBzZWdzLl9jdXJ2ZXMubGVuZ3RoO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IHN0YXJ0OyBpIDwgdG87IGkrKylcblx0XHRcdFx0Y3VydmVzLnNwbGljZShpLCAwLCBuZXcgQ3VydmUodGhpcywgbnVsbCwgbnVsbCkpO1xuXHRcdFx0dGhpcy5fYWRqdXN0Q3VydmVzKGZyb20sIHRvKTtcblx0XHR9XG5cdFx0dGhpcy5fY2hhbmdlZCgyNSk7XG5cdFx0cmV0dXJuIHNlZ3M7XG5cdH0sXG5cblx0X2FkanVzdEN1cnZlczogZnVuY3Rpb24oZnJvbSwgdG8pIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cyxcblx0XHRcdGN1cnZlcyA9IHRoaXMuX2N1cnZlcyxcblx0XHRcdGN1cnZlO1xuXHRcdGZvciAodmFyIGkgPSBmcm9tOyBpIDwgdG87IGkrKykge1xuXHRcdFx0Y3VydmUgPSBjdXJ2ZXNbaV07XG5cdFx0XHRjdXJ2ZS5fcGF0aCA9IHRoaXM7XG5cdFx0XHRjdXJ2ZS5fc2VnbWVudDEgPSBzZWdtZW50c1tpXTtcblx0XHRcdGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW2kgKyAxXSB8fCBzZWdtZW50c1swXTtcblx0XHRcdGN1cnZlLl9jaGFuZ2VkKCk7XG5cdFx0fVxuXHRcdGlmIChjdXJ2ZSA9IGN1cnZlc1t0aGlzLl9jbG9zZWQgJiYgZnJvbSA9PT0gMCA/IHNlZ21lbnRzLmxlbmd0aCAtIDFcblx0XHRcdFx0OiBmcm9tIC0gMV0pIHtcblx0XHRcdGN1cnZlLl9zZWdtZW50MiA9IHNlZ21lbnRzW2Zyb21dIHx8IHNlZ21lbnRzWzBdO1xuXHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdFx0aWYgKGN1cnZlID0gY3VydmVzW3RvXSkge1xuXHRcdFx0Y3VydmUuX3NlZ21lbnQxID0gc2VnbWVudHNbdG9dO1xuXHRcdFx0Y3VydmUuX2NoYW5nZWQoKTtcblx0XHR9XG5cdH0sXG5cblx0X2NvdW50Q3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGVuZ3RoID0gdGhpcy5fc2VnbWVudHMubGVuZ3RoO1xuXHRcdHJldHVybiAhdGhpcy5fY2xvc2VkICYmIGxlbmd0aCA+IDAgPyBsZW5ndGggLSAxIDogbGVuZ3RoO1xuXHR9LFxuXG5cdGFkZDogZnVuY3Rpb24oc2VnbWVudDEgKSB7XG5cdFx0cmV0dXJuIGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBzZWdtZW50MSAhPT0gJ251bWJlcidcblx0XHRcdD8gdGhpcy5fYWRkKFNlZ21lbnQucmVhZEFsbChhcmd1bWVudHMpKVxuXHRcdFx0OiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzKSBdKVswXTtcblx0fSxcblxuXHRpbnNlcnQ6IGZ1bmN0aW9uKGluZGV4LCBzZWdtZW50MSApIHtcblx0XHRyZXR1cm4gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgdHlwZW9mIHNlZ21lbnQxICE9PSAnbnVtYmVyJ1xuXHRcdFx0PyB0aGlzLl9hZGQoU2VnbWVudC5yZWFkQWxsKGFyZ3VtZW50cywgMSksIGluZGV4KVxuXHRcdFx0OiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzLCAxKSBdLCBpbmRleClbMF07XG5cdH0sXG5cblx0YWRkU2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChbIFNlZ21lbnQucmVhZChhcmd1bWVudHMpIF0pWzBdO1xuXHR9LFxuXG5cdGluc2VydFNlZ21lbnQ6IGZ1bmN0aW9uKGluZGV4ICkge1xuXHRcdHJldHVybiB0aGlzLl9hZGQoWyBTZWdtZW50LnJlYWQoYXJndW1lbnRzLCAxKSBdLCBpbmRleClbMF07XG5cdH0sXG5cblx0YWRkU2VnbWVudHM6IGZ1bmN0aW9uKHNlZ21lbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoc2VnbWVudHMpKTtcblx0fSxcblxuXHRpbnNlcnRTZWdtZW50czogZnVuY3Rpb24oaW5kZXgsIHNlZ21lbnRzKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2FkZChTZWdtZW50LnJlYWRBbGwoc2VnbWVudHMpLCBpbmRleCk7XG5cdH0sXG5cblx0cmVtb3ZlU2VnbWVudDogZnVuY3Rpb24oaW5kZXgpIHtcblx0XHRyZXR1cm4gdGhpcy5yZW1vdmVTZWdtZW50cyhpbmRleCwgaW5kZXggKyAxKVswXSB8fCBudWxsO1xuXHR9LFxuXG5cdHJlbW92ZVNlZ21lbnRzOiBmdW5jdGlvbihmcm9tLCB0bywgX2luY2x1ZGVDdXJ2ZXMpIHtcblx0XHRmcm9tID0gZnJvbSB8fCAwO1xuXHRcdHRvID0gQmFzZS5waWNrKHRvLCB0aGlzLl9zZWdtZW50cy5sZW5ndGgpO1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0Y3VydmVzID0gdGhpcy5fY3VydmVzLFxuXHRcdFx0Y291bnQgPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRyZW1vdmVkID0gc2VnbWVudHMuc3BsaWNlKGZyb20sIHRvIC0gZnJvbSksXG5cdFx0XHRhbW91bnQgPSByZW1vdmVkLmxlbmd0aDtcblx0XHRpZiAoIWFtb3VudClcblx0XHRcdHJldHVybiByZW1vdmVkO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgYW1vdW50OyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gcmVtb3ZlZFtpXTtcblx0XHRcdGlmIChzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSlcblx0XHRcdFx0dGhpcy5fdXBkYXRlU2VsZWN0aW9uKHNlZ21lbnQsIHNlZ21lbnQuX3NlbGVjdGlvblN0YXRlLCAwKTtcblx0XHRcdHNlZ21lbnQuX2luZGV4ID0gc2VnbWVudC5fcGF0aCA9IG51bGw7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSBmcm9tLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c2VnbWVudHNbaV0uX2luZGV4ID0gaTtcblx0XHRpZiAoY3VydmVzKSB7XG5cdFx0XHR2YXIgaW5kZXggPSBmcm9tID4gMCAmJiB0byA9PT0gY291bnQgKyAodGhpcy5fY2xvc2VkID8gMSA6IDApXG5cdFx0XHRcdFx0PyBmcm9tIC0gMVxuXHRcdFx0XHRcdDogZnJvbSxcblx0XHRcdFx0Y3VydmVzID0gY3VydmVzLnNwbGljZShpbmRleCwgYW1vdW50KTtcblx0XHRcdGlmIChfaW5jbHVkZUN1cnZlcylcblx0XHRcdFx0cmVtb3ZlZC5fY3VydmVzID0gY3VydmVzLnNsaWNlKDEpO1xuXHRcdFx0dGhpcy5fYWRqdXN0Q3VydmVzKGluZGV4LCBpbmRleCk7XG5cdFx0fVxuXHRcdHRoaXMuX2NoYW5nZWQoMjUpO1xuXHRcdHJldHVybiByZW1vdmVkO1xuXHR9LFxuXG5cdGNsZWFyOiAnI3JlbW92ZVNlZ21lbnRzJyxcblxuXHRoYXNIYW5kbGVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2VnbWVudHMgPSB0aGlzLl9zZWdtZW50cztcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKHNlZ21lbnRzW2ldLmhhc0hhbmRsZXMoKSlcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0fVxuXHRcdHJldHVybiBmYWxzZTtcblx0fSxcblxuXHRjbGVhckhhbmRsZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0c2VnbWVudHNbaV0uY2xlYXJIYW5kbGVzKCk7XG5cdH0sXG5cblx0Z2V0TGVuZ3RoOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fbGVuZ3RoID09IG51bGwpIHtcblx0XHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0XHRsZW5ndGggPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRsZW5ndGggKz0gY3VydmVzW2ldLmdldExlbmd0aCgpO1xuXHRcdFx0dGhpcy5fbGVuZ3RoID0gbGVuZ3RoO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbGVuZ3RoO1xuXHR9LFxuXG5cdGdldEFyZWE6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9hcmVhID09IG51bGwpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0XHRjb3VudCA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdFx0bGFzdCA9IGNvdW50IC0gMSxcblx0XHRcdFx0YXJlYSA9IDA7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX2Nsb3NlZCA/IGNvdW50IDogbGFzdDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRhcmVhICs9IEN1cnZlLmdldEFyZWEoQ3VydmUuZ2V0VmFsdWVzKFxuXHRcdFx0XHRcdFx0c2VnbWVudHNbaV0sIHNlZ21lbnRzW2kgPCBsYXN0ID8gaSArIDEgOiAwXSkpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYXJlYSA9IGFyZWE7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9hcmVhO1xuXHR9LFxuXG5cdGlzQ2xvY2t3aXNlOiBmdW5jdGlvbigpIHtcblx0XHRpZiAodGhpcy5fY2xvY2t3aXNlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRyZXR1cm4gdGhpcy5fY2xvY2t3aXNlO1xuXHRcdHJldHVybiB0aGlzLmdldEFyZWEoKSA+PSAwO1xuXHR9LFxuXG5cdHNldENsb2Nrd2lzZTogZnVuY3Rpb24oY2xvY2t3aXNlKSB7XG5cdFx0aWYgKHRoaXMuaXNDbG9ja3dpc2UoKSAhPSAoY2xvY2t3aXNlID0gISFjbG9ja3dpc2UpKVxuXHRcdFx0dGhpcy5yZXZlcnNlKCk7XG5cdFx0dGhpcy5fY2xvY2t3aXNlID0gY2xvY2t3aXNlO1xuXHR9LFxuXG5cdGlzRnVsbHlTZWxlY3RlZDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0XHRyZXR1cm4gdGhpcy5fc2VsZWN0ZWQgJiYgbGVuZ3RoID4gMCAmJiB0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZVxuXHRcdFx0XHQ9PT0gbGVuZ3RoICogNztcblx0fSxcblxuXHRzZXRGdWxseVNlbGVjdGVkOiBmdW5jdGlvbihzZWxlY3RlZCkge1xuXHRcdGlmIChzZWxlY3RlZClcblx0XHRcdHRoaXMuX3NlbGVjdFNlZ21lbnRzKHRydWUpO1xuXHRcdHRoaXMuc2V0U2VsZWN0ZWQoc2VsZWN0ZWQpO1xuXHR9LFxuXG5cdHNldFNlbGVjdGVkOiBmdW5jdGlvbiBzZXRTZWxlY3RlZChzZWxlY3RlZCkge1xuXHRcdGlmICghc2VsZWN0ZWQpXG5cdFx0XHR0aGlzLl9zZWxlY3RTZWdtZW50cyhmYWxzZSk7XG5cdFx0c2V0U2VsZWN0ZWQuYmFzZS5jYWxsKHRoaXMsIHNlbGVjdGVkKTtcblx0fSxcblxuXHRfc2VsZWN0U2VnbWVudHM6IGZ1bmN0aW9uKHNlbGVjdGVkKSB7XG5cdFx0dmFyIGxlbmd0aCA9IHRoaXMuX3NlZ21lbnRzLmxlbmd0aDtcblx0XHR0aGlzLl9zZWxlY3RlZFNlZ21lbnRTdGF0ZSA9IHNlbGVjdGVkXG5cdFx0XHRcdD8gbGVuZ3RoICogNyA6IDA7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKylcblx0XHRcdHRoaXMuX3NlZ21lbnRzW2ldLl9zZWxlY3Rpb25TdGF0ZSA9IHNlbGVjdGVkXG5cdFx0XHRcdFx0PyA3IDogMDtcblx0fSxcblxuXHRfdXBkYXRlU2VsZWN0aW9uOiBmdW5jdGlvbihzZWdtZW50LCBvbGRTdGF0ZSwgbmV3U3RhdGUpIHtcblx0XHRzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSA9IG5ld1N0YXRlO1xuXHRcdHZhciB0b3RhbCA9IHRoaXMuX3NlbGVjdGVkU2VnbWVudFN0YXRlICs9IG5ld1N0YXRlIC0gb2xkU3RhdGU7XG5cdFx0aWYgKHRvdGFsID4gMClcblx0XHRcdHRoaXMuc2V0U2VsZWN0ZWQodHJ1ZSk7XG5cdH0sXG5cblx0ZmxhdHRlbjogZnVuY3Rpb24obWF4RGlzdGFuY2UpIHtcblx0XHR2YXIgaXRlcmF0b3IgPSBuZXcgUGF0aEl0ZXJhdG9yKHRoaXMsIDY0LCAwLjEpLFxuXHRcdFx0cG9zID0gMCxcblx0XHRcdHN0ZXAgPSBpdGVyYXRvci5sZW5ndGggLyBNYXRoLmNlaWwoaXRlcmF0b3IubGVuZ3RoIC8gbWF4RGlzdGFuY2UpLFxuXHRcdFx0ZW5kID0gaXRlcmF0b3IubGVuZ3RoICsgKHRoaXMuX2Nsb3NlZCA/IC1zdGVwIDogc3RlcCkgLyAyO1xuXHRcdHZhciBzZWdtZW50cyA9IFtdO1xuXHRcdHdoaWxlIChwb3MgPD0gZW5kKSB7XG5cdFx0XHRzZWdtZW50cy5wdXNoKG5ldyBTZWdtZW50KGl0ZXJhdG9yLmdldFBvaW50QXQocG9zKSkpO1xuXHRcdFx0cG9zICs9IHN0ZXA7XG5cdFx0fVxuXHRcdHRoaXMuc2V0U2VnbWVudHMoc2VnbWVudHMpO1xuXHR9LFxuXG5cdHJlZHVjZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCk7XG5cdFx0Zm9yICh2YXIgaSA9IGN1cnZlcy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIGN1cnZlID0gY3VydmVzW2ldO1xuXHRcdFx0aWYgKCFjdXJ2ZS5oYXNIYW5kbGVzKCkgJiYgKGN1cnZlLmdldExlbmd0aCgpID09PSAwXG5cdFx0XHRcdFx0fHwgY3VydmUuaXNDb2xsaW5lYXIoY3VydmUuZ2V0TmV4dCgpKSkpXG5cdFx0XHRcdGN1cnZlLnJlbW92ZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcztcblx0fSxcblxuXHRzaW1wbGlmeTogZnVuY3Rpb24odG9sZXJhbmNlKSB7XG5cdFx0aWYgKHRoaXMuX3NlZ21lbnRzLmxlbmd0aCA+IDIpIHtcblx0XHRcdHZhciBmaXR0ZXIgPSBuZXcgUGF0aEZpdHRlcih0aGlzLCB0b2xlcmFuY2UgfHwgMi41KTtcblx0XHRcdHRoaXMuc2V0U2VnbWVudHMoZml0dGVyLmZpdCgpKTtcblx0XHR9XG5cdH0sXG5cblx0c3BsaXQ6IGZ1bmN0aW9uKGluZGV4LCBwYXJhbWV0ZXIpIHtcblx0XHRpZiAocGFyYW1ldGVyID09PSBudWxsKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDEpIHtcblx0XHRcdHZhciBhcmcgPSBpbmRleDtcblx0XHRcdGlmICh0eXBlb2YgYXJnID09PSAnbnVtYmVyJylcblx0XHRcdFx0YXJnID0gdGhpcy5nZXRMb2NhdGlvbkF0KGFyZyk7XG5cdFx0XHRpZiAoIWFyZylcblx0XHRcdFx0cmV0dXJuIG51bGxcblx0XHRcdGluZGV4ID0gYXJnLmluZGV4O1xuXHRcdFx0cGFyYW1ldGVyID0gYXJnLnBhcmFtZXRlcjtcblx0XHR9XG5cdFx0dmFyIHRNaW4gPSA0ZS03LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluO1xuXHRcdGlmIChwYXJhbWV0ZXIgPj0gdE1heCkge1xuXHRcdFx0aW5kZXgrKztcblx0XHRcdHBhcmFtZXRlci0tO1xuXHRcdH1cblx0XHR2YXIgY3VydmVzID0gdGhpcy5nZXRDdXJ2ZXMoKTtcblx0XHRpZiAoaW5kZXggPj0gMCAmJiBpbmRleCA8IGN1cnZlcy5sZW5ndGgpIHtcblx0XHRcdGlmIChwYXJhbWV0ZXIgPj0gdE1pbikge1xuXHRcdFx0XHRjdXJ2ZXNbaW5kZXgrK10uZGl2aWRlKHBhcmFtZXRlciwgdHJ1ZSk7XG5cdFx0XHR9XG5cdFx0XHR2YXIgc2VncyA9IHRoaXMucmVtb3ZlU2VnbWVudHMoaW5kZXgsIHRoaXMuX3NlZ21lbnRzLmxlbmd0aCwgdHJ1ZSksXG5cdFx0XHRcdHBhdGg7XG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkKSB7XG5cdFx0XHRcdHRoaXMuc2V0Q2xvc2VkKGZhbHNlKTtcblx0XHRcdFx0cGF0aCA9IHRoaXM7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRwYXRoID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0XHRwYXRoLmluc2VydEFib3ZlKHRoaXMsIHRydWUpO1xuXHRcdFx0XHR0aGlzLl9jbG9uZShwYXRoKTtcblx0XHRcdH1cblx0XHRcdHBhdGguX2FkZChzZWdzLCAwKTtcblx0XHRcdHRoaXMuYWRkU2VnbWVudChzZWdzWzBdKTtcblx0XHRcdHJldHVybiBwYXRoO1xuXHRcdH1cblx0XHRyZXR1cm4gbnVsbDtcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9zZWdtZW50cy5yZXZlcnNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9zZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWdtZW50ID0gdGhpcy5fc2VnbWVudHNbaV07XG5cdFx0XHR2YXIgaGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVJbjtcblx0XHRcdHNlZ21lbnQuX2hhbmRsZUluID0gc2VnbWVudC5faGFuZGxlT3V0O1xuXHRcdFx0c2VnbWVudC5faGFuZGxlT3V0ID0gaGFuZGxlSW47XG5cdFx0XHRzZWdtZW50Ll9pbmRleCA9IGk7XG5cdFx0fVxuXHRcdHRoaXMuX2N1cnZlcyA9IG51bGw7XG5cdFx0aWYgKHRoaXMuX2Nsb2Nrd2lzZSAhPT0gdW5kZWZpbmVkKVxuXHRcdFx0dGhpcy5fY2xvY2t3aXNlID0gIXRoaXMuX2Nsb2Nrd2lzZTtcblx0XHR0aGlzLl9jaGFuZ2VkKDkpO1xuXHR9LFxuXG5cdGpvaW46IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRpZiAocGF0aCkge1xuXHRcdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRcdGxhc3QxID0gdGhpcy5nZXRMYXN0U2VnbWVudCgpLFxuXHRcdFx0XHRsYXN0MiA9IHBhdGguZ2V0TGFzdFNlZ21lbnQoKTtcblx0XHRcdGlmICghbGFzdDIpXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0aWYgKGxhc3QxICYmIGxhc3QxLl9wb2ludC5lcXVhbHMobGFzdDIuX3BvaW50KSlcblx0XHRcdFx0cGF0aC5yZXZlcnNlKCk7XG5cdFx0XHR2YXIgZmlyc3QyID0gcGF0aC5nZXRGaXJzdFNlZ21lbnQoKTtcblx0XHRcdGlmIChsYXN0MSAmJiBsYXN0MS5fcG9pbnQuZXF1YWxzKGZpcnN0Mi5fcG9pbnQpKSB7XG5cdFx0XHRcdGxhc3QxLnNldEhhbmRsZU91dChmaXJzdDIuX2hhbmRsZU91dCk7XG5cdFx0XHRcdHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgxKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgZmlyc3QxID0gdGhpcy5nZXRGaXJzdFNlZ21lbnQoKTtcblx0XHRcdFx0aWYgKGZpcnN0MSAmJiBmaXJzdDEuX3BvaW50LmVxdWFscyhmaXJzdDIuX3BvaW50KSlcblx0XHRcdFx0XHRwYXRoLnJldmVyc2UoKTtcblx0XHRcdFx0bGFzdDIgPSBwYXRoLmdldExhc3RTZWdtZW50KCk7XG5cdFx0XHRcdGlmIChmaXJzdDEgJiYgZmlyc3QxLl9wb2ludC5lcXVhbHMobGFzdDIuX3BvaW50KSkge1xuXHRcdFx0XHRcdGZpcnN0MS5zZXRIYW5kbGVJbihsYXN0Mi5faGFuZGxlSW4pO1xuXHRcdFx0XHRcdHRoaXMuX2FkZChzZWdtZW50cy5zbGljZSgwLCBzZWdtZW50cy5sZW5ndGggLSAxKSwgMCk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzLnNsaWNlKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAocGF0aC5fY2xvc2VkKVxuXHRcdFx0XHR0aGlzLl9hZGQoW3NlZ21lbnRzWzBdXSk7XG5cdFx0XHRwYXRoLnJlbW92ZSgpO1xuXHRcdH1cblx0XHR2YXIgZmlyc3QgPSB0aGlzLmdldEZpcnN0U2VnbWVudCgpLFxuXHRcdFx0bGFzdCA9IHRoaXMuZ2V0TGFzdFNlZ21lbnQoKTtcblx0XHRpZiAoZmlyc3QgIT09IGxhc3QgJiYgZmlyc3QuX3BvaW50LmVxdWFscyhsYXN0Ll9wb2ludCkpIHtcblx0XHRcdGZpcnN0LnNldEhhbmRsZUluKGxhc3QuX2hhbmRsZUluKTtcblx0XHRcdGxhc3QucmVtb3ZlKCk7XG5cdFx0XHR0aGlzLnNldENsb3NlZCh0cnVlKTtcblx0XHR9XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH0sXG5cblx0dG9TaGFwZTogZnVuY3Rpb24oaW5zZXJ0KSB7XG5cdFx0aWYgKCF0aGlzLl9jbG9zZWQpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblxuXHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0dHlwZSxcblx0XHRcdHNpemUsXG5cdFx0XHRyYWRpdXMsXG5cdFx0XHR0b3BDZW50ZXI7XG5cblx0XHRmdW5jdGlvbiBpc0NvbGxpbmVhcihpLCBqKSB7XG5cdFx0XHR2YXIgc2VnMSA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRzZWcyID0gc2VnMS5nZXROZXh0KCksXG5cdFx0XHRcdHNlZzMgPSBzZWdtZW50c1tqXSxcblx0XHRcdFx0c2VnNCA9IHNlZzMuZ2V0TmV4dCgpO1xuXHRcdFx0cmV0dXJuIHNlZzEuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWcyLl9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdCYmIHNlZzMuX2hhbmRsZU91dC5pc1plcm8oKSAmJiBzZWc0Ll9oYW5kbGVJbi5pc1plcm8oKVxuXHRcdFx0XHRcdCYmIHNlZzIuX3BvaW50LnN1YnRyYWN0KHNlZzEuX3BvaW50KS5pc0NvbGxpbmVhcihcblx0XHRcdFx0XHRcdHNlZzQuX3BvaW50LnN1YnRyYWN0KHNlZzMuX3BvaW50KSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNPcnRob2dvbmFsKGkpIHtcblx0XHRcdHZhciBzZWcyID0gc2VnbWVudHNbaV0sXG5cdFx0XHRcdHNlZzEgPSBzZWcyLmdldFByZXZpb3VzKCksXG5cdFx0XHRcdHNlZzMgPSBzZWcyLmdldE5leHQoKTtcblx0XHRcdHJldHVybiBzZWcxLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnMi5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQmJiBzZWcyLl9oYW5kbGVPdXQuaXNaZXJvKCkgJiYgc2VnMy5faGFuZGxlSW4uaXNaZXJvKClcblx0XHRcdFx0XHQmJiBzZWcyLl9wb2ludC5zdWJ0cmFjdChzZWcxLl9wb2ludCkuaXNPcnRob2dvbmFsKFxuXHRcdFx0XHRcdFx0c2VnMy5fcG9pbnQuc3VidHJhY3Qoc2VnMi5fcG9pbnQpKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBpc0FyYyhpKSB7XG5cdFx0XHR2YXIgc2VnMSA9IHNlZ21lbnRzW2ldLFxuXHRcdFx0XHRzZWcyID0gc2VnMS5nZXROZXh0KCksXG5cdFx0XHRcdGhhbmRsZTEgPSBzZWcxLl9oYW5kbGVPdXQsXG5cdFx0XHRcdGhhbmRsZTIgPSBzZWcyLl9oYW5kbGVJbixcblx0XHRcdFx0a2FwcGEgPSAwLjU1MjI4NDc0OTgzMDc5MzY7XG5cdFx0XHRpZiAoaGFuZGxlMS5pc09ydGhvZ29uYWwoaGFuZGxlMikpIHtcblx0XHRcdFx0dmFyIHB0MSA9IHNlZzEuX3BvaW50LFxuXHRcdFx0XHRcdHB0MiA9IHNlZzIuX3BvaW50LFxuXHRcdFx0XHRcdGNvcm5lciA9IG5ldyBMaW5lKHB0MSwgaGFuZGxlMSwgdHJ1ZSkuaW50ZXJzZWN0KFxuXHRcdFx0XHRcdFx0XHRuZXcgTGluZShwdDIsIGhhbmRsZTIsIHRydWUpLCB0cnVlKTtcblx0XHRcdFx0cmV0dXJuIGNvcm5lciAmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTEuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdFx0Y29ybmVyLnN1YnRyYWN0KHB0MSkuZ2V0TGVuZ3RoKCkgLSBrYXBwYSlcblx0XHRcdFx0XHQmJiBOdW1lcmljYWwuaXNaZXJvKGhhbmRsZTIuZ2V0TGVuZ3RoKCkgL1xuXHRcdFx0XHRcdFx0Y29ybmVyLnN1YnRyYWN0KHB0MikuZ2V0TGVuZ3RoKCkgLSBrYXBwYSk7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0RGlzdGFuY2UoaSwgaikge1xuXHRcdFx0cmV0dXJuIHNlZ21lbnRzW2ldLl9wb2ludC5nZXREaXN0YW5jZShzZWdtZW50c1tqXS5fcG9pbnQpO1xuXHRcdH1cblxuXHRcdGlmICghdGhpcy5oYXNIYW5kbGVzKCkgJiYgc2VnbWVudHMubGVuZ3RoID09PSA0XG5cdFx0XHRcdCYmIGlzQ29sbGluZWFyKDAsIDIpICYmIGlzQ29sbGluZWFyKDEsIDMpICYmIGlzT3J0aG9nb25hbCgxKSkge1xuXHRcdFx0dHlwZSA9IFNoYXBlLlJlY3RhbmdsZTtcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgwLCAzKSwgZ2V0RGlzdGFuY2UoMCwgMSkpO1xuXHRcdFx0dG9wQ2VudGVyID0gc2VnbWVudHNbMV0uX3BvaW50LmFkZChzZWdtZW50c1syXS5fcG9pbnQpLmRpdmlkZSgyKTtcblx0XHR9IGVsc2UgaWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gOCAmJiBpc0FyYygwKSAmJiBpc0FyYygyKSAmJiBpc0FyYyg0KVxuXHRcdFx0XHQmJiBpc0FyYyg2KSAmJiBpc0NvbGxpbmVhcigxLCA1KSAmJiBpc0NvbGxpbmVhcigzLCA3KSkge1xuXHRcdFx0dHlwZSA9IFNoYXBlLlJlY3RhbmdsZTtcblx0XHRcdHNpemUgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgxLCA2KSwgZ2V0RGlzdGFuY2UoMCwgMykpO1xuXHRcdFx0cmFkaXVzID0gc2l6ZS5zdWJ0cmFjdChuZXcgU2l6ZShnZXREaXN0YW5jZSgwLCA3KSxcblx0XHRcdFx0XHRnZXREaXN0YW5jZSgxLCAyKSkpLmRpdmlkZSgyKTtcblx0XHRcdHRvcENlbnRlciA9IHNlZ21lbnRzWzNdLl9wb2ludC5hZGQoc2VnbWVudHNbNF0uX3BvaW50KS5kaXZpZGUoMik7XG5cdFx0fSBlbHNlIGlmIChzZWdtZW50cy5sZW5ndGggPT09IDRcblx0XHRcdFx0JiYgaXNBcmMoMCkgJiYgaXNBcmMoMSkgJiYgaXNBcmMoMikgJiYgaXNBcmMoMykpIHtcblx0XHRcdGlmIChOdW1lcmljYWwuaXNaZXJvKGdldERpc3RhbmNlKDAsIDIpIC0gZ2V0RGlzdGFuY2UoMSwgMykpKSB7XG5cdFx0XHRcdHR5cGUgPSBTaGFwZS5DaXJjbGU7XG5cdFx0XHRcdHJhZGl1cyA9IGdldERpc3RhbmNlKDAsIDIpIC8gMjtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHR5cGUgPSBTaGFwZS5FbGxpcHNlO1xuXHRcdFx0XHRyYWRpdXMgPSBuZXcgU2l6ZShnZXREaXN0YW5jZSgyLCAwKSAvIDIsIGdldERpc3RhbmNlKDMsIDEpIC8gMik7XG5cdFx0XHR9XG5cdFx0XHR0b3BDZW50ZXIgPSBzZWdtZW50c1sxXS5fcG9pbnQ7XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGUpIHtcblx0XHRcdHZhciBjZW50ZXIgPSB0aGlzLmdldFBvc2l0aW9uKHRydWUpLFxuXHRcdFx0XHRzaGFwZSA9IHRoaXMuX2Nsb25lKG5ldyB0eXBlKHtcblx0XHRcdFx0XHRjZW50ZXI6IGNlbnRlcixcblx0XHRcdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0XHRcdHJhZGl1czogcmFkaXVzLFxuXHRcdFx0XHRcdGluc2VydDogZmFsc2Vcblx0XHRcdFx0fSksIGluc2VydCwgZmFsc2UpO1xuXHRcdFx0c2hhcGUucm90YXRlKHRvcENlbnRlci5zdWJ0cmFjdChjZW50ZXIpLmdldEFuZ2xlKCkgKyA5MCk7XG5cdFx0XHRyZXR1cm4gc2hhcGU7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdF9oaXRUZXN0U2VsZjogZnVuY3Rpb24ocG9pbnQsIG9wdGlvbnMpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXMsXG5cdFx0XHRzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKSxcblx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHMsXG5cdFx0XHRudW1TZWdtZW50cyA9IHNlZ21lbnRzLmxlbmd0aCxcblx0XHRcdGNsb3NlZCA9IHRoaXMuX2Nsb3NlZCxcblx0XHRcdHRvbGVyYW5jZVBhZGRpbmcgPSBvcHRpb25zLl90b2xlcmFuY2VQYWRkaW5nLFxuXHRcdFx0c3Ryb2tlUGFkZGluZyA9IHRvbGVyYW5jZVBhZGRpbmcsXG5cdFx0XHRqb2luLCBjYXAsIG1pdGVyTGltaXQsXG5cdFx0XHRhcmVhLCBsb2MsIHJlcyxcblx0XHRcdGhpdFN0cm9rZSA9IG9wdGlvbnMuc3Ryb2tlICYmIHN0eWxlLmhhc1N0cm9rZSgpLFxuXHRcdFx0aGl0RmlsbCA9IG9wdGlvbnMuZmlsbCAmJiBzdHlsZS5oYXNGaWxsKCksXG5cdFx0XHRoaXRDdXJ2ZXMgPSBvcHRpb25zLmN1cnZlcyxcblx0XHRcdHJhZGl1cyA9IGhpdFN0cm9rZVxuXHRcdFx0XHRcdD8gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDJcblx0XHRcdFx0XHQ6IGhpdEZpbGwgJiYgb3B0aW9ucy50b2xlcmFuY2UgPiAwIHx8IGhpdEN1cnZlc1xuXHRcdFx0XHRcdFx0PyAwIDogbnVsbDtcblx0XHRpZiAocmFkaXVzICE9PSBudWxsKSB7XG5cdFx0XHRpZiAocmFkaXVzID4gMCkge1xuXHRcdFx0XHRqb2luID0gc3R5bGUuZ2V0U3Ryb2tlSm9pbigpO1xuXHRcdFx0XHRjYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKTtcblx0XHRcdFx0bWl0ZXJMaW1pdCA9IHJhZGl1cyAqIHN0eWxlLmdldE1pdGVyTGltaXQoKTtcblx0XHRcdFx0c3Ryb2tlUGFkZGluZyA9IHRvbGVyYW5jZVBhZGRpbmcuYWRkKG5ldyBQb2ludChyYWRpdXMsIHJhZGl1cykpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0am9pbiA9IGNhcCA9ICdyb3VuZCc7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNDbG9zZUVub3VnaChwdCwgcGFkZGluZykge1xuXHRcdFx0cmV0dXJuIHBvaW50LnN1YnRyYWN0KHB0KS5kaXZpZGUocGFkZGluZykubGVuZ3RoIDw9IDE7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBwdCwgbmFtZSkge1xuXHRcdFx0aWYgKCFvcHRpb25zLnNlbGVjdGVkIHx8IHB0LmlzU2VsZWN0ZWQoKSkge1xuXHRcdFx0XHR2YXIgYW5jaG9yID0gc2VnLl9wb2ludDtcblx0XHRcdFx0aWYgKHB0ICE9PSBhbmNob3IpXG5cdFx0XHRcdFx0cHQgPSBwdC5hZGQoYW5jaG9yKTtcblx0XHRcdFx0aWYgKGlzQ2xvc2VFbm91Z2gocHQsIHN0cm9rZVBhZGRpbmcpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIG5ldyBIaXRSZXN1bHQobmFtZSwgdGhhdCwge1xuXHRcdFx0XHRcdFx0c2VnbWVudDogc2VnLFxuXHRcdFx0XHRcdFx0cG9pbnQ6IHB0XG5cdFx0XHRcdFx0fSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjaGVja1NlZ21lbnRQb2ludHMoc2VnLCBlbmRzKSB7XG5cdFx0XHRyZXR1cm4gKGVuZHMgfHwgb3B0aW9ucy5zZWdtZW50cylcblx0XHRcdFx0JiYgY2hlY2tTZWdtZW50UG9pbnQoc2VnLCBzZWcuX3BvaW50LCAnc2VnbWVudCcpXG5cdFx0XHRcdHx8ICghZW5kcyAmJiBvcHRpb25zLmhhbmRsZXMpICYmIChcblx0XHRcdFx0XHRjaGVja1NlZ21lbnRQb2ludChzZWcsIHNlZy5faGFuZGxlSW4sICdoYW5kbGUtaW4nKSB8fFxuXHRcdFx0XHRcdGNoZWNrU2VnbWVudFBvaW50KHNlZywgc2VnLl9oYW5kbGVPdXQsICdoYW5kbGUtb3V0JykpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZFRvQXJlYShwb2ludCkge1xuXHRcdFx0YXJlYS5hZGQocG9pbnQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGNoZWNrU2VnbWVudFN0cm9rZShzZWdtZW50KSB7XG5cdFx0XHRpZiAoam9pbiAhPT0gJ3JvdW5kJyB8fCBjYXAgIT09ICdyb3VuZCcpIHtcblx0XHRcdFx0YXJlYSA9IG5ldyBQYXRoKHsgaW50ZXJuYWw6IHRydWUsIGNsb3NlZDogdHJ1ZSB9KTtcblx0XHRcdFx0aWYgKGNsb3NlZCB8fCBzZWdtZW50Ll9pbmRleCA+IDBcblx0XHRcdFx0XHRcdCYmIHNlZ21lbnQuX2luZGV4IDwgbnVtU2VnbWVudHMgLSAxKSB7XG5cdFx0XHRcdFx0aWYgKGpvaW4gIT09ICdyb3VuZCcgJiYgKHNlZ21lbnQuX2hhbmRsZUluLmlzWmVybygpXG5cdFx0XHRcdFx0XHRcdHx8IHNlZ21lbnQuX2hhbmRsZU91dC5pc1plcm8oKSkpXG5cdFx0XHRcdFx0XHRQYXRoLl9hZGRCZXZlbEpvaW4oc2VnbWVudCwgam9pbiwgcmFkaXVzLCBtaXRlckxpbWl0LFxuXHRcdFx0XHRcdFx0XHRcdGFkZFRvQXJlYSwgdHJ1ZSk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoY2FwICE9PSAncm91bmQnKSB7XG5cdFx0XHRcdFx0UGF0aC5fYWRkU3F1YXJlQ2FwKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBhZGRUb0FyZWEsIHRydWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICghYXJlYS5pc0VtcHR5KCkpIHtcblx0XHRcdFx0XHR2YXIgbG9jO1xuXHRcdFx0XHRcdHJldHVybiBhcmVhLmNvbnRhaW5zKHBvaW50KVxuXHRcdFx0XHRcdFx0fHwgKGxvYyA9IGFyZWEuZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KSlcblx0XHRcdFx0XHRcdFx0JiYgaXNDbG9zZUVub3VnaChsb2MuZ2V0UG9pbnQoKSwgdG9sZXJhbmNlUGFkZGluZyk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHJldHVybiBpc0Nsb3NlRW5vdWdoKHNlZ21lbnQuX3BvaW50LCBzdHJva2VQYWRkaW5nKTtcblx0XHR9XG5cblx0XHRpZiAob3B0aW9ucy5lbmRzICYmICFvcHRpb25zLnNlZ21lbnRzICYmICFjbG9zZWQpIHtcblx0XHRcdGlmIChyZXMgPSBjaGVja1NlZ21lbnRQb2ludHMoc2VnbWVudHNbMF0sIHRydWUpXG5cdFx0XHRcdFx0fHwgY2hlY2tTZWdtZW50UG9pbnRzKHNlZ21lbnRzW251bVNlZ21lbnRzIC0gMV0sIHRydWUpKVxuXHRcdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0gZWxzZSBpZiAob3B0aW9ucy5zZWdtZW50cyB8fCBvcHRpb25zLmhhbmRsZXMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgbnVtU2VnbWVudHM7IGkrKylcblx0XHRcdFx0aWYgKHJlcyA9IGNoZWNrU2VnbWVudFBvaW50cyhzZWdtZW50c1tpXSkpXG5cdFx0XHRcdFx0cmV0dXJuIHJlcztcblx0XHR9XG5cdFx0aWYgKHJhZGl1cyAhPT0gbnVsbCkge1xuXHRcdFx0bG9jID0gdGhpcy5nZXROZWFyZXN0TG9jYXRpb24ocG9pbnQpO1xuXHRcdFx0aWYgKGxvYykge1xuXHRcdFx0XHR2YXIgcGFyYW1ldGVyID0gbG9jLmdldFBhcmFtZXRlcigpO1xuXHRcdFx0XHRpZiAocGFyYW1ldGVyID09PSAwIHx8IHBhcmFtZXRlciA9PT0gMSAmJiBudW1TZWdtZW50cyA+IDEpIHtcblx0XHRcdFx0XHRpZiAoIWNoZWNrU2VnbWVudFN0cm9rZShsb2MuZ2V0U2VnbWVudCgpKSlcblx0XHRcdFx0XHRcdGxvYyA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSBpZiAoIWlzQ2xvc2VFbm91Z2gobG9jLmdldFBvaW50KCksIHN0cm9rZVBhZGRpbmcpKSB7XG5cdFx0XHRcdFx0bG9jID0gbnVsbDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0aWYgKCFsb2MgJiYgam9pbiA9PT0gJ21pdGVyJyAmJiBudW1TZWdtZW50cyA+IDEpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBudW1TZWdtZW50czsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdFx0XHRpZiAocG9pbnQuZ2V0RGlzdGFuY2Uoc2VnbWVudC5fcG9pbnQpIDw9IG1pdGVyTGltaXRcblx0XHRcdFx0XHRcdFx0JiYgY2hlY2tTZWdtZW50U3Ryb2tlKHNlZ21lbnQpKSB7XG5cdFx0XHRcdFx0XHRsb2MgPSBzZWdtZW50LmdldExvY2F0aW9uKCk7XG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuICFsb2MgJiYgaGl0RmlsbCAmJiB0aGlzLl9jb250YWlucyhwb2ludClcblx0XHRcdFx0fHwgbG9jICYmICFoaXRTdHJva2UgJiYgIWhpdEN1cnZlc1xuXHRcdFx0XHRcdD8gbmV3IEhpdFJlc3VsdCgnZmlsbCcsIHRoaXMpXG5cdFx0XHRcdFx0OiBsb2Ncblx0XHRcdFx0XHRcdD8gbmV3IEhpdFJlc3VsdChoaXRTdHJva2UgPyAnc3Ryb2tlJyA6ICdjdXJ2ZScsIHRoaXMsIHtcblx0XHRcdFx0XHRcdFx0bG9jYXRpb246IGxvYyxcblx0XHRcdFx0XHRcdFx0cG9pbnQ6IGxvYy5nZXRQb2ludCgpXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0OiBudWxsO1xuXHR9XG5cbn0sIEJhc2UuZWFjaChDdXJ2ZS5ldmFsdWF0ZU1ldGhvZHMsXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uKG9mZnNldCwgaXNQYXJhbWV0ZXIpIHtcblx0XHRcdHZhciBsb2MgPSB0aGlzLmdldExvY2F0aW9uQXQob2Zmc2V0LCBpc1BhcmFtZXRlcik7XG5cdFx0XHRyZXR1cm4gbG9jICYmIGxvY1tuYW1lXSgpO1xuXHRcdH07XG5cdH0sXG57XG5cdGJlYW5zOiBmYWxzZSxcblxuXHRnZXRMb2NhdGlvbk9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGxvYyA9IGN1cnZlc1tpXS5nZXRMb2NhdGlvbk9mKHBvaW50KTtcblx0XHRcdGlmIChsb2MpXG5cdFx0XHRcdHJldHVybiBsb2M7XG5cdFx0fVxuXHRcdHJldHVybiBudWxsO1xuXHR9LFxuXG5cdGdldE9mZnNldE9mOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbG9jID0gdGhpcy5nZXRMb2NhdGlvbk9mLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdFx0cmV0dXJuIGxvYyA/IGxvYy5nZXRPZmZzZXQoKSA6IG51bGw7XG5cdH0sXG5cblx0Z2V0TG9jYXRpb25BdDogZnVuY3Rpb24ob2Zmc2V0LCBpc1BhcmFtZXRlcikge1xuXHRcdHZhciBjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0bGVuZ3RoID0gMDtcblx0XHRpZiAoaXNQYXJhbWV0ZXIpIHtcblx0XHRcdHZhciBpbmRleCA9IH5+b2Zmc2V0LFxuXHRcdFx0XHRjdXJ2ZSA9IGN1cnZlc1tpbmRleF07XG5cdFx0XHRyZXR1cm4gY3VydmUgPyBjdXJ2ZS5nZXRMb2NhdGlvbkF0KG9mZnNldCAtIGluZGV4LCB0cnVlKSA6IG51bGw7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHN0YXJ0ID0gbGVuZ3RoLFxuXHRcdFx0XHRjdXJ2ZSA9IGN1cnZlc1tpXTtcblx0XHRcdGxlbmd0aCArPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcblx0XHRcdGlmIChsZW5ndGggPiBvZmZzZXQpIHtcblx0XHRcdFx0cmV0dXJuIGN1cnZlLmdldExvY2F0aW9uQXQob2Zmc2V0IC0gc3RhcnQpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAoY3VydmVzLmxlbmd0aCA+IDAgJiYgb2Zmc2V0IDw9IHRoaXMuZ2V0TGVuZ3RoKCkpXG5cdFx0XHRyZXR1cm4gbmV3IEN1cnZlTG9jYXRpb24oY3VydmVzW2N1cnZlcy5sZW5ndGggLSAxXSwgMSk7XG5cdFx0cmV0dXJuIG51bGw7XG5cdH0sXG5cblx0Z2V0TmVhcmVzdExvY2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgcG9pbnQgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRjdXJ2ZXMgPSB0aGlzLmdldEN1cnZlcygpLFxuXHRcdFx0bWluRGlzdCA9IEluZmluaXR5LFxuXHRcdFx0bWluTG9jID0gbnVsbDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBsb2MgPSBjdXJ2ZXNbaV0uZ2V0TmVhcmVzdExvY2F0aW9uKHBvaW50KTtcblx0XHRcdGlmIChsb2MuX2Rpc3RhbmNlIDwgbWluRGlzdCkge1xuXHRcdFx0XHRtaW5EaXN0ID0gbG9jLl9kaXN0YW5jZTtcblx0XHRcdFx0bWluTG9jID0gbG9jO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbWluTG9jO1xuXHR9LFxuXG5cdGdldE5lYXJlc3RQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0TmVhcmVzdExvY2F0aW9uLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykuZ2V0UG9pbnQoKTtcblx0fVxufSksXG5uZXcgZnVuY3Rpb24oKSB7XG5cblx0ZnVuY3Rpb24gZHJhd0hhbmRsZXMoY3R4LCBzZWdtZW50cywgbWF0cml4LCBzaXplKSB7XG5cdFx0dmFyIGhhbGYgPSBzaXplIC8gMjtcblxuXHRcdGZ1bmN0aW9uIGRyYXdIYW5kbGUoaW5kZXgpIHtcblx0XHRcdHZhciBoWCA9IGNvb3Jkc1tpbmRleF0sXG5cdFx0XHRcdGhZID0gY29vcmRzW2luZGV4ICsgMV07XG5cdFx0XHRpZiAocFggIT0gaFggfHwgcFkgIT0gaFkpIHtcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0XHRjdHgubW92ZVRvKHBYLCBwWSk7XG5cdFx0XHRcdGN0eC5saW5lVG8oaFgsIGhZKTtcblx0XHRcdFx0Y3R4LnN0cm9rZSgpO1xuXHRcdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRcdGN0eC5hcmMoaFgsIGhZLCBoYWxmLCAwLCBNYXRoLlBJICogMiwgdHJ1ZSk7XG5cdFx0XHRcdGN0eC5maWxsKCk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpXTtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHR2YXIgc3RhdGUgPSBzZWdtZW50Ll9zZWxlY3Rpb25TdGF0ZSxcblx0XHRcdFx0cFggPSBjb29yZHNbMF0sXG5cdFx0XHRcdHBZID0gY29vcmRzWzFdO1xuXHRcdFx0aWYgKHN0YXRlICYgMSlcblx0XHRcdFx0ZHJhd0hhbmRsZSgyKTtcblx0XHRcdGlmIChzdGF0ZSAmIDIpXG5cdFx0XHRcdGRyYXdIYW5kbGUoNCk7XG5cdFx0XHRjdHguZmlsbFJlY3QocFggLSBoYWxmLCBwWSAtIGhhbGYsIHNpemUsIHNpemUpO1xuXHRcdFx0aWYgKCEoc3RhdGUgJiA0KSkge1xuXHRcdFx0XHR2YXIgZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9ICcjZmZmZmZmJztcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KHBYIC0gaGFsZiArIDEsIHBZIC0gaGFsZiArIDEsIHNpemUgLSAyLCBzaXplIC0gMik7XG5cdFx0XHRcdGN0eC5maWxsU3R5bGUgPSBmaWxsU3R5bGU7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gZHJhd1NlZ21lbnRzKGN0eCwgcGF0aCwgbWF0cml4KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRsZW5ndGggPSBzZWdtZW50cy5sZW5ndGgsXG5cdFx0XHRjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRmaXJzdCA9IHRydWUsXG5cdFx0XHRjdXJYLCBjdXJZLFxuXHRcdFx0cHJldlgsIHByZXZZLFxuXHRcdFx0aW5YLCBpblksXG5cdFx0XHRvdXRYLCBvdXRZO1xuXG5cdFx0ZnVuY3Rpb24gZHJhd1NlZ21lbnQoc2VnbWVudCkge1xuXHRcdFx0aWYgKG1hdHJpeCkge1xuXHRcdFx0XHRzZWdtZW50Ll90cmFuc2Zvcm1Db29yZGluYXRlcyhtYXRyaXgsIGNvb3JkcywgZmFsc2UpO1xuXHRcdFx0XHRjdXJYID0gY29vcmRzWzBdO1xuXHRcdFx0XHRjdXJZID0gY29vcmRzWzFdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHBvaW50ID0gc2VnbWVudC5fcG9pbnQ7XG5cdFx0XHRcdGN1clggPSBwb2ludC5feDtcblx0XHRcdFx0Y3VyWSA9IHBvaW50Ll95O1xuXHRcdFx0fVxuXHRcdFx0aWYgKGZpcnN0KSB7XG5cdFx0XHRcdGN0eC5tb3ZlVG8oY3VyWCwgY3VyWSk7XG5cdFx0XHRcdGZpcnN0ID0gZmFsc2U7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdFx0aW5YID0gY29vcmRzWzJdO1xuXHRcdFx0XHRcdGluWSA9IGNvb3Jkc1szXTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgaGFuZGxlID0gc2VnbWVudC5faGFuZGxlSW47XG5cdFx0XHRcdFx0aW5YID0gY3VyWCArIGhhbmRsZS5feDtcblx0XHRcdFx0XHRpblkgPSBjdXJZICsgaGFuZGxlLl95O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpblggPT09IGN1clggJiYgaW5ZID09PSBjdXJZXG5cdFx0XHRcdFx0XHQmJiBvdXRYID09PSBwcmV2WCAmJiBvdXRZID09PSBwcmV2WSkge1xuXHRcdFx0XHRcdGN0eC5saW5lVG8oY3VyWCwgY3VyWSk7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Y3R4LmJlemllckN1cnZlVG8ob3V0WCwgb3V0WSwgaW5YLCBpblksIGN1clgsIGN1clkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRwcmV2WCA9IGN1clg7XG5cdFx0XHRwcmV2WSA9IGN1clk7XG5cdFx0XHRpZiAobWF0cml4KSB7XG5cdFx0XHRcdG91dFggPSBjb29yZHNbNF07XG5cdFx0XHRcdG91dFkgPSBjb29yZHNbNV07XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgaGFuZGxlID0gc2VnbWVudC5faGFuZGxlT3V0O1xuXHRcdFx0XHRvdXRYID0gcHJldlggKyBoYW5kbGUuX3g7XG5cdFx0XHRcdG91dFkgPSBwcmV2WSArIGhhbmRsZS5feTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKVxuXHRcdFx0ZHJhd1NlZ21lbnQoc2VnbWVudHNbaV0pO1xuXHRcdGlmIChwYXRoLl9jbG9zZWQgJiYgbGVuZ3RoID4gMClcblx0XHRcdGRyYXdTZWdtZW50KHNlZ21lbnRzWzBdKTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2RyYXc6IGZ1bmN0aW9uKGN0eCwgcGFyYW0sIHN0cm9rZU1hdHJpeCkge1xuXHRcdFx0dmFyIGRvbnRTdGFydCA9IHBhcmFtLmRvbnRTdGFydCxcblx0XHRcdFx0ZG9udFBhaW50ID0gcGFyYW0uZG9udEZpbmlzaCB8fCBwYXJhbS5jbGlwLFxuXHRcdFx0XHRzdHlsZSA9IHRoaXMuZ2V0U3R5bGUoKSxcblx0XHRcdFx0aGFzRmlsbCA9IHN0eWxlLmhhc0ZpbGwoKSxcblx0XHRcdFx0aGFzU3Ryb2tlID0gc3R5bGUuaGFzU3Ryb2tlKCksXG5cdFx0XHRcdGRhc2hBcnJheSA9IHN0eWxlLmdldERhc2hBcnJheSgpLFxuXHRcdFx0XHRkYXNoTGVuZ3RoID0gIXBhcGVyLnN1cHBvcnQubmF0aXZlRGFzaCAmJiBoYXNTdHJva2Vcblx0XHRcdFx0XHRcdCYmIGRhc2hBcnJheSAmJiBkYXNoQXJyYXkubGVuZ3RoO1xuXG5cdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXG5cdFx0XHRpZiAoIWRvbnRTdGFydCAmJiB0aGlzLl9jdXJyZW50UGF0aCkge1xuXHRcdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHRcdH0gZWxzZSBpZiAoaGFzRmlsbCB8fCBoYXNTdHJva2UgJiYgIWRhc2hMZW5ndGggfHwgZG9udFBhaW50KSB7XG5cdFx0XHRcdGRyYXdTZWdtZW50cyhjdHgsIHRoaXMsIHN0cm9rZU1hdHJpeCk7XG5cdFx0XHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRcdFx0Y3R4LmNsb3NlUGF0aCgpO1xuXHRcdFx0XHRpZiAoIWRvbnRTdGFydClcblx0XHRcdFx0XHR0aGlzLl9jdXJyZW50UGF0aCA9IGN0eC5jdXJyZW50UGF0aDtcblx0XHRcdH1cblxuXHRcdFx0ZnVuY3Rpb24gZ2V0T2Zmc2V0KGkpIHtcblx0XHRcdFx0cmV0dXJuIGRhc2hBcnJheVsoKGkgJSBkYXNoTGVuZ3RoKSArIGRhc2hMZW5ndGgpICUgZGFzaExlbmd0aF07XG5cdFx0XHR9XG5cblx0XHRcdGlmICghZG9udFBhaW50ICYmIChoYXNGaWxsIHx8IGhhc1N0cm9rZSkpIHtcblx0XHRcdFx0dGhpcy5fc2V0U3R5bGVzKGN0eCk7XG5cdFx0XHRcdGlmIChoYXNGaWxsKSB7XG5cdFx0XHRcdFx0Y3R4LmZpbGwoc3R5bGUuZ2V0V2luZGluZ1J1bGUoKSk7XG5cdFx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChoYXNTdHJva2UpIHtcblx0XHRcdFx0XHRpZiAoZGFzaExlbmd0aCkge1xuXHRcdFx0XHRcdFx0aWYgKCFkb250U3RhcnQpXG5cdFx0XHRcdFx0XHRcdGN0eC5iZWdpblBhdGgoKTtcblx0XHRcdFx0XHRcdHZhciBpdGVyYXRvciA9IG5ldyBQYXRoSXRlcmF0b3IodGhpcywgMzIsIDAuMjUsXG5cdFx0XHRcdFx0XHRcdFx0c3Ryb2tlTWF0cml4KSxcblx0XHRcdFx0XHRcdFx0bGVuZ3RoID0gaXRlcmF0b3IubGVuZ3RoLFxuXHRcdFx0XHRcdFx0XHRmcm9tID0gLXN0eWxlLmdldERhc2hPZmZzZXQoKSwgdG8sXG5cdFx0XHRcdFx0XHRcdGkgPSAwO1xuXHRcdFx0XHRcdFx0ZnJvbSA9IGZyb20gJSBsZW5ndGg7XG5cdFx0XHRcdFx0XHR3aGlsZSAoZnJvbSA+IDApIHtcblx0XHRcdFx0XHRcdFx0ZnJvbSAtPSBnZXRPZmZzZXQoaS0tKSArIGdldE9mZnNldChpLS0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0d2hpbGUgKGZyb20gPCBsZW5ndGgpIHtcblx0XHRcdFx0XHRcdFx0dG8gPSBmcm9tICsgZ2V0T2Zmc2V0KGkrKyk7XG5cdFx0XHRcdFx0XHRcdGlmIChmcm9tID4gMCB8fCB0byA+IDApXG5cdFx0XHRcdFx0XHRcdFx0aXRlcmF0b3IuZHJhd1BhcnQoY3R4LFxuXHRcdFx0XHRcdFx0XHRcdFx0XHRNYXRoLm1heChmcm9tLCAwKSwgTWF0aC5tYXgodG8sIDApKTtcblx0XHRcdFx0XHRcdFx0ZnJvbSA9IHRvICsgZ2V0T2Zmc2V0KGkrKyk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfZHJhd1NlbGVjdGVkOiBmdW5jdGlvbihjdHgsIG1hdHJpeCkge1xuXHRcdFx0Y3R4LmJlZ2luUGF0aCgpO1xuXHRcdFx0ZHJhd1NlZ21lbnRzKGN0eCwgdGhpcywgbWF0cml4KTtcblx0XHRcdGN0eC5zdHJva2UoKTtcblx0XHRcdGRyYXdIYW5kbGVzKGN0eCwgdGhpcy5fc2VnbWVudHMsIG1hdHJpeCwgcGFwZXIuc2V0dGluZ3MuaGFuZGxlU2l6ZSk7XG5cdFx0fVxuXHR9O1xufSxcbm5ldyBmdW5jdGlvbigpIHtcblx0ZnVuY3Rpb24gZ2V0Rmlyc3RDb250cm9sUG9pbnRzKHJocykge1xuXHRcdHZhciBuID0gcmhzLmxlbmd0aCxcblx0XHRcdHggPSBbXSxcblx0XHRcdHRtcCA9IFtdLFxuXHRcdFx0YiA9IDI7XG5cdFx0eFswXSA9IHJoc1swXSAvIGI7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBuOyBpKyspIHtcblx0XHRcdHRtcFtpXSA9IDEgLyBiO1xuXHRcdFx0YiA9IChpIDwgbiAtIDEgPyA0IDogMikgLSB0bXBbaV07XG5cdFx0XHR4W2ldID0gKHJoc1tpXSAtIHhbaSAtIDFdKSAvIGI7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbjsgaSsrKSB7XG5cdFx0XHR4W24gLSBpIC0gMV0gLT0gdG1wW24gLSBpXSAqIHhbbiAtIGldO1xuXHRcdH1cblx0XHRyZXR1cm4geDtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0c21vb3RoOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzLFxuXHRcdFx0XHRzaXplID0gc2VnbWVudHMubGVuZ3RoLFxuXHRcdFx0XHRjbG9zZWQgPSB0aGlzLl9jbG9zZWQsXG5cdFx0XHRcdG4gPSBzaXplLFxuXHRcdFx0XHRvdmVybGFwID0gMDtcblx0XHRcdGlmIChzaXplIDw9IDIpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0b3ZlcmxhcCA9IE1hdGgubWluKHNpemUsIDQpO1xuXHRcdFx0XHRuICs9IE1hdGgubWluKHNpemUsIG92ZXJsYXApICogMjtcblx0XHRcdH1cblx0XHRcdHZhciBrbm90cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzaXplOyBpKyspXG5cdFx0XHRcdGtub3RzW2kgKyBvdmVybGFwXSA9IHNlZ21lbnRzW2ldLl9wb2ludDtcblx0XHRcdGlmIChjbG9zZWQpIHtcblx0XHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBvdmVybGFwOyBpKyspIHtcblx0XHRcdFx0XHRrbm90c1tpXSA9IHNlZ21lbnRzW2kgKyBzaXplIC0gb3ZlcmxhcF0uX3BvaW50O1xuXHRcdFx0XHRcdGtub3RzW2kgKyBzaXplICsgb3ZlcmxhcF0gPSBzZWdtZW50c1tpXS5fcG9pbnQ7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdG4tLTtcblx0XHRcdH1cblx0XHRcdHZhciByaHMgPSBbXTtcblxuXHRcdFx0Zm9yICh2YXIgaSA9IDE7IGkgPCBuIC0gMTsgaSsrKVxuXHRcdFx0XHRyaHNbaV0gPSA0ICoga25vdHNbaV0uX3ggKyAyICoga25vdHNbaSArIDFdLl94O1xuXHRcdFx0cmhzWzBdID0ga25vdHNbMF0uX3ggKyAyICoga25vdHNbMV0uX3g7XG5cdFx0XHRyaHNbbiAtIDFdID0gMyAqIGtub3RzW24gLSAxXS5feDtcblx0XHRcdHZhciB4ID0gZ2V0Rmlyc3RDb250cm9sUG9pbnRzKHJocyk7XG5cblx0XHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbiAtIDE7IGkrKylcblx0XHRcdFx0cmhzW2ldID0gNCAqIGtub3RzW2ldLl95ICsgMiAqIGtub3RzW2kgKyAxXS5feTtcblx0XHRcdHJoc1swXSA9IGtub3RzWzBdLl95ICsgMiAqIGtub3RzWzFdLl95O1xuXHRcdFx0cmhzW24gLSAxXSA9IDMgKiBrbm90c1tuIC0gMV0uX3k7XG5cdFx0XHR2YXIgeSA9IGdldEZpcnN0Q29udHJvbFBvaW50cyhyaHMpO1xuXG5cdFx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBqID0gc2l6ZTsgaSA8IG92ZXJsYXA7IGkrKywgaisrKSB7XG5cdFx0XHRcdFx0dmFyIGYxID0gaSAvIG92ZXJsYXAsXG5cdFx0XHRcdFx0XHRmMiA9IDEgLSBmMSxcblx0XHRcdFx0XHRcdGllID0gaSArIG92ZXJsYXAsXG5cdFx0XHRcdFx0XHRqZSA9IGogKyBvdmVybGFwO1xuXHRcdFx0XHRcdHhbal0gPSB4W2ldICogZjEgKyB4W2pdICogZjI7XG5cdFx0XHRcdFx0eVtqXSA9IHlbaV0gKiBmMSArIHlbal0gKiBmMjtcblx0XHRcdFx0XHR4W2plXSA9IHhbaWVdICogZjIgKyB4W2plXSAqIGYxO1xuXHRcdFx0XHRcdHlbamVdID0geVtpZV0gKiBmMiArIHlbamVdICogZjE7XG5cdFx0XHRcdH1cblx0XHRcdFx0bi0tO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGhhbmRsZUluID0gbnVsbDtcblx0XHRcdGZvciAodmFyIGkgPSBvdmVybGFwOyBpIDw9IG4gLSBvdmVybGFwOyBpKyspIHtcblx0XHRcdFx0dmFyIHNlZ21lbnQgPSBzZWdtZW50c1tpIC0gb3ZlcmxhcF07XG5cdFx0XHRcdGlmIChoYW5kbGVJbilcblx0XHRcdFx0XHRzZWdtZW50LnNldEhhbmRsZUluKGhhbmRsZUluLnN1YnRyYWN0KHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0XHRcdGlmIChpIDwgbikge1xuXHRcdFx0XHRcdHNlZ21lbnQuc2V0SGFuZGxlT3V0KFxuXHRcdFx0XHRcdFx0XHRuZXcgUG9pbnQoeFtpXSwgeVtpXSkuc3VidHJhY3Qoc2VnbWVudC5fcG9pbnQpKTtcblx0XHRcdFx0XHRoYW5kbGVJbiA9IGkgPCBuIC0gMVxuXHRcdFx0XHRcdFx0XHQ/IG5ldyBQb2ludChcblx0XHRcdFx0XHRcdFx0XHQyICoga25vdHNbaSArIDFdLl94IC0geFtpICsgMV0sXG5cdFx0XHRcdFx0XHRcdFx0MiAqIGtub3RzW2kgKyAxXS5feSAtIHlbaSArIDFdKVxuXHRcdFx0XHRcdFx0XHQ6IG5ldyBQb2ludChcblx0XHRcdFx0XHRcdFx0XHQoa25vdHNbbl0uX3ggKyB4W24gLSAxXSkgLyAyLFxuXHRcdFx0XHRcdFx0XHRcdChrbm90c1tuXS5feSArIHlbbiAtIDFdKSAvIDIpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpZiAoY2xvc2VkICYmIGhhbmRsZUluKSB7XG5cdFx0XHRcdHZhciBzZWdtZW50ID0gdGhpcy5fc2VnbWVudHNbMF07XG5cdFx0XHRcdHNlZ21lbnQuc2V0SGFuZGxlSW4oaGFuZGxlSW4uc3VidHJhY3Qoc2VnbWVudC5fcG9pbnQpKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59LFxubmV3IGZ1bmN0aW9uKCkge1xuXHRmdW5jdGlvbiBnZXRDdXJyZW50U2VnbWVudCh0aGF0KSB7XG5cdFx0dmFyIHNlZ21lbnRzID0gdGhhdC5fc2VnbWVudHM7XG5cdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBzZWdtZW50cyA9IHRoaXMuX3NlZ21lbnRzO1xuXHRcdFx0aWYgKHNlZ21lbnRzLmxlbmd0aCA9PT0gMSlcblx0XHRcdFx0dGhpcy5yZW1vdmVTZWdtZW50KDApO1xuXHRcdFx0aWYgKCFzZWdtZW50cy5sZW5ndGgpXG5cdFx0XHRcdHRoaXMuX2FkZChbIG5ldyBTZWdtZW50KFBvaW50LnJlYWQoYXJndW1lbnRzKSkgXSk7XG5cdFx0fSxcblxuXHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ21vdmVCeSgpIGlzIHVuc3VwcG9ydGVkIG9uIFBhdGggaXRlbXMuJyk7XG5cdFx0fSxcblxuXHRcdGxpbmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudChQb2ludC5yZWFkKGFyZ3VtZW50cykpIF0pO1xuXHRcdH0sXG5cblx0XHRjdWJpY0N1cnZlVG86IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcyk7XG5cdFx0XHRjdXJyZW50LnNldEhhbmRsZU91dChoYW5kbGUxLnN1YnRyYWN0KGN1cnJlbnQuX3BvaW50KSk7XG5cdFx0XHR0aGlzLl9hZGQoWyBuZXcgU2VnbWVudCh0bywgaGFuZGxlMi5zdWJ0cmFjdCh0bykpIF0pO1xuXHRcdH0sXG5cblx0XHRxdWFkcmF0aWNDdXJ2ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBoYW5kbGUgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oXG5cdFx0XHRcdGhhbmRsZS5hZGQoY3VycmVudC5zdWJ0cmFjdChoYW5kbGUpLm11bHRpcGx5KDEgLyAzKSksXG5cdFx0XHRcdGhhbmRsZS5hZGQodG8uc3VidHJhY3QoaGFuZGxlKS5tdWx0aXBseSgxIC8gMykpLFxuXHRcdFx0XHR0b1xuXHRcdFx0KTtcblx0XHR9LFxuXG5cdFx0Y3VydmVUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgdGhyb3VnaCA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHQgPSBCYXNlLnBpY2soQmFzZS5yZWFkKGFyZ3VtZW50cyksIDAuNSksXG5cdFx0XHRcdHQxID0gMSAtIHQsXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG5cdFx0XHRcdGhhbmRsZSA9IHRocm91Z2guc3VidHJhY3QoY3VycmVudC5tdWx0aXBseSh0MSAqIHQxKSlcblx0XHRcdFx0XHQuc3VidHJhY3QodG8ubXVsdGlwbHkodCAqIHQpKS5kaXZpZGUoMiAqIHQgKiB0MSk7XG5cdFx0XHRpZiAoaGFuZGxlLmlzTmFOKCkpXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHQnQ2Fubm90IHB1dCBhIGN1cnZlIHRocm91Z2ggcG9pbnRzIHdpdGggcGFyYW1ldGVyID0gJyArIHQpO1xuXHRcdFx0dGhpcy5xdWFkcmF0aWNDdXJ2ZVRvKGhhbmRsZSwgdG8pO1xuXHRcdH0sXG5cblx0XHRhcmNUbzogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLFxuXHRcdFx0XHRmcm9tID0gY3VycmVudC5fcG9pbnQsXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHR0aHJvdWdoLFxuXHRcdFx0XHRwZWVrID0gQmFzZS5wZWVrKGFyZ3VtZW50cyksXG5cdFx0XHRcdGNsb2Nrd2lzZSA9IEJhc2UucGljayhwZWVrLCB0cnVlKSxcblx0XHRcdFx0Y2VudGVyLCBleHRlbnQsIHZlY3RvciwgbWF0cml4O1xuXHRcdFx0aWYgKHR5cGVvZiBjbG9ja3dpc2UgPT09ICdib29sZWFuJykge1xuXHRcdFx0XHR2YXIgbWlkZGxlID0gZnJvbS5hZGQodG8pLmRpdmlkZSgyKSxcblx0XHRcdFx0dGhyb3VnaCA9IG1pZGRsZS5hZGQobWlkZGxlLnN1YnRyYWN0KGZyb20pLnJvdGF0ZShcblx0XHRcdFx0XHRcdGNsb2Nrd2lzZSA/IC05MCA6IDkwKSk7XG5cdFx0XHR9IGVsc2UgaWYgKEJhc2UucmVtYWluKGFyZ3VtZW50cykgPD0gMikge1xuXHRcdFx0XHR0aHJvdWdoID0gdG87XG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHJhZGl1cyA9IFNpemUucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0XHRpZiAocmFkaXVzLmlzWmVybygpKVxuXHRcdFx0XHRcdHJldHVybiB0aGlzLmxpbmVUbyh0byk7XG5cdFx0XHRcdHZhciByb3RhdGlvbiA9IEJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdGNsb2Nrd2lzZSA9ICEhQmFzZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdFx0bGFyZ2UgPSAhIUJhc2UucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRcdG1pZGRsZSA9IGZyb20uYWRkKHRvKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0cHQgPSBmcm9tLnN1YnRyYWN0KG1pZGRsZSkucm90YXRlKC1yb3RhdGlvbiksXG5cdFx0XHRcdFx0eCA9IHB0LngsXG5cdFx0XHRcdFx0eSA9IHB0LnksXG5cdFx0XHRcdFx0YWJzID0gTWF0aC5hYnMsXG5cdFx0XHRcdFx0cnggPSBhYnMocmFkaXVzLndpZHRoKSxcblx0XHRcdFx0XHRyeSA9IGFicyhyYWRpdXMuaGVpZ2h0KSxcblx0XHRcdFx0XHRyeFNxID0gcnggKiByeCxcblx0XHRcdFx0XHRyeVNxID0gcnkgKiByeSxcblx0XHRcdFx0XHR4U3EgPSAgeCAqIHgsXG5cdFx0XHRcdFx0eVNxID0gIHkgKiB5O1xuXHRcdFx0XHR2YXIgZmFjdG9yID0gTWF0aC5zcXJ0KHhTcSAvIHJ4U3EgKyB5U3EgLyByeVNxKTtcblx0XHRcdFx0aWYgKGZhY3RvciA+IDEpIHtcblx0XHRcdFx0XHRyeCAqPSBmYWN0b3I7XG5cdFx0XHRcdFx0cnkgKj0gZmFjdG9yO1xuXHRcdFx0XHRcdHJ4U3EgPSByeCAqIHJ4O1xuXHRcdFx0XHRcdHJ5U3EgPSByeSAqIHJ5O1xuXHRcdFx0XHR9XG5cdFx0XHRcdGZhY3RvciA9IChyeFNxICogcnlTcSAtIHJ4U3EgKiB5U3EgLSByeVNxICogeFNxKSAvXG5cdFx0XHRcdFx0XHQocnhTcSAqIHlTcSArIHJ5U3EgKiB4U3EpO1xuXHRcdFx0XHRpZiAoYWJzKGZhY3RvcikgPCAxZS0xMilcblx0XHRcdFx0XHRmYWN0b3IgPSAwO1xuXHRcdFx0XHRpZiAoZmFjdG9yIDwgMClcblx0XHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHRcdCdDYW5ub3QgY3JlYXRlIGFuIGFyYyB3aXRoIHRoZSBnaXZlbiBhcmd1bWVudHMnKTtcblx0XHRcdFx0Y2VudGVyID0gbmV3IFBvaW50KHJ4ICogeSAvIHJ5LCAtcnkgKiB4IC8gcngpXG5cdFx0XHRcdFx0XHQubXVsdGlwbHkoKGxhcmdlID09PSBjbG9ja3dpc2UgPyAtMSA6IDEpXG5cdFx0XHRcdFx0XHRcdCogTWF0aC5zcXJ0KGZhY3RvcikpXG5cdFx0XHRcdFx0XHQucm90YXRlKHJvdGF0aW9uKS5hZGQobWlkZGxlKTtcblx0XHRcdFx0bWF0cml4ID0gbmV3IE1hdHJpeCgpLnRyYW5zbGF0ZShjZW50ZXIpLnJvdGF0ZShyb3RhdGlvbilcblx0XHRcdFx0XHRcdC5zY2FsZShyeCwgcnkpO1xuXHRcdFx0XHR2ZWN0b3IgPSBtYXRyaXguX2ludmVyc2VUcmFuc2Zvcm0oZnJvbSk7XG5cdFx0XHRcdGV4dGVudCA9IHZlY3Rvci5nZXREaXJlY3RlZEFuZ2xlKG1hdHJpeC5faW52ZXJzZVRyYW5zZm9ybSh0bykpO1xuXHRcdFx0XHRpZiAoIWNsb2Nrd2lzZSAmJiBleHRlbnQgPiAwKVxuXHRcdFx0XHRcdGV4dGVudCAtPSAzNjA7XG5cdFx0XHRcdGVsc2UgaWYgKGNsb2Nrd2lzZSAmJiBleHRlbnQgPCAwKVxuXHRcdFx0XHRcdGV4dGVudCArPSAzNjA7XG5cdFx0XHR9XG5cdFx0XHRpZiAodGhyb3VnaCkge1xuXHRcdFx0XHR2YXIgbDEgPSBuZXcgTGluZShmcm9tLmFkZCh0aHJvdWdoKS5kaXZpZGUoMiksXG5cdFx0XHRcdFx0XHRcdHRocm91Z2guc3VidHJhY3QoZnJvbSkucm90YXRlKDkwKSwgdHJ1ZSksXG5cdFx0XHRcdFx0bDIgPSBuZXcgTGluZSh0aHJvdWdoLmFkZCh0bykuZGl2aWRlKDIpLFxuXHRcdFx0XHRcdFx0XHR0by5zdWJ0cmFjdCh0aHJvdWdoKS5yb3RhdGUoOTApLCB0cnVlKSxcblx0XHRcdFx0XHRsaW5lID0gbmV3IExpbmUoZnJvbSwgdG8pLFxuXHRcdFx0XHRcdHRocm91Z2hTaWRlID0gbGluZS5nZXRTaWRlKHRocm91Z2gpO1xuXHRcdFx0XHRjZW50ZXIgPSBsMS5pbnRlcnNlY3QobDIsIHRydWUpO1xuXHRcdFx0XHRpZiAoIWNlbnRlcikge1xuXHRcdFx0XHRcdGlmICghdGhyb3VnaFNpZGUpXG5cdFx0XHRcdFx0XHRyZXR1cm4gdGhpcy5saW5lVG8odG8pO1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcihcblx0XHRcdFx0XHRcdFx0J0Nhbm5vdCBjcmVhdGUgYW4gYXJjIHdpdGggdGhlIGdpdmVuIGFyZ3VtZW50cycpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdHZlY3RvciA9IGZyb20uc3VidHJhY3QoY2VudGVyKTtcblx0XHRcdFx0ZXh0ZW50ID0gdmVjdG9yLmdldERpcmVjdGVkQW5nbGUodG8uc3VidHJhY3QoY2VudGVyKSk7XG5cdFx0XHRcdHZhciBjZW50ZXJTaWRlID0gbGluZS5nZXRTaWRlKGNlbnRlcik7XG5cdFx0XHRcdGlmIChjZW50ZXJTaWRlID09PSAwKSB7XG5cdFx0XHRcdFx0ZXh0ZW50ID0gdGhyb3VnaFNpZGUgKiBNYXRoLmFicyhleHRlbnQpO1xuXHRcdFx0XHR9IGVsc2UgaWYgKHRocm91Z2hTaWRlID09PSBjZW50ZXJTaWRlKSB7XG5cdFx0XHRcdFx0ZXh0ZW50ICs9IGV4dGVudCA8IDAgPyAzNjAgOiAtMzYwO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR2YXIgZXh0ID0gTWF0aC5hYnMoZXh0ZW50KSxcblx0XHRcdFx0Y291bnQgPSBleHQgPj0gMzYwID8gNCA6IE1hdGguY2VpbChleHQgLyA5MCksXG5cdFx0XHRcdGluYyA9IGV4dGVudCAvIGNvdW50LFxuXHRcdFx0XHRoYWxmID0gaW5jICogTWF0aC5QSSAvIDM2MCxcblx0XHRcdFx0eiA9IDQgLyAzICogTWF0aC5zaW4oaGFsZikgLyAoMSArIE1hdGguY29zKGhhbGYpKSxcblx0XHRcdFx0c2VnbWVudHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IGNvdW50OyBpKyspIHtcblx0XHRcdFx0dmFyIHB0ID0gdG8sXG5cdFx0XHRcdFx0b3V0ID0gbnVsbDtcblx0XHRcdFx0aWYgKGkgPCBjb3VudCkge1xuXHRcdFx0XHRcdG91dCA9IHZlY3Rvci5yb3RhdGUoOTApLm11bHRpcGx5KHopO1xuXHRcdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRcdHB0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IpO1xuXHRcdFx0XHRcdFx0b3V0ID0gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludCh2ZWN0b3IuYWRkKG91dCkpXG5cdFx0XHRcdFx0XHRcdFx0LnN1YnRyYWN0KHB0KTtcblx0XHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdFx0cHQgPSBjZW50ZXIuYWRkKHZlY3Rvcik7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChpID09PSAwKSB7XG5cdFx0XHRcdFx0Y3VycmVudC5zZXRIYW5kbGVPdXQob3V0KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgX2luID0gdmVjdG9yLnJvdGF0ZSgtOTApLm11bHRpcGx5KHopO1xuXHRcdFx0XHRcdGlmIChtYXRyaXgpIHtcblx0XHRcdFx0XHRcdF9pbiA9IG1hdHJpeC5fdHJhbnNmb3JtUG9pbnQodmVjdG9yLmFkZChfaW4pKVxuXHRcdFx0XHRcdFx0XHRcdC5zdWJ0cmFjdChwdCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdHNlZ21lbnRzLnB1c2gobmV3IFNlZ21lbnQocHQsIF9pbiwgb3V0KSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dmVjdG9yID0gdmVjdG9yLnJvdGF0ZShpbmMpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fYWRkKHNlZ21lbnRzKTtcblx0XHR9LFxuXG5cdFx0bGluZUJ5OiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0byA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMubGluZVRvKGN1cnJlbnQuYWRkKHRvKSk7XG5cdFx0fSxcblxuXHRcdGN1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHRocm91Z2ggPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRwYXJhbWV0ZXIgPSBCYXNlLnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0Y3VycmVudCA9IGdldEN1cnJlbnRTZWdtZW50KHRoaXMpLl9wb2ludDtcblx0XHRcdHRoaXMuY3VydmVUbyhjdXJyZW50LmFkZCh0aHJvdWdoKSwgY3VycmVudC5hZGQodG8pLCBwYXJhbWV0ZXIpO1xuXHRcdH0sXG5cblx0XHRjdWJpY0N1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZTEgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGhhbmRsZTIgPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHRvID0gUG9pbnQucmVhZChhcmd1bWVudHMpLFxuXHRcdFx0XHRjdXJyZW50ID0gZ2V0Q3VycmVudFNlZ21lbnQodGhpcykuX3BvaW50O1xuXHRcdFx0dGhpcy5jdWJpY0N1cnZlVG8oY3VycmVudC5hZGQoaGFuZGxlMSksIGN1cnJlbnQuYWRkKGhhbmRsZTIpLFxuXHRcdFx0XHRcdGN1cnJlbnQuYWRkKHRvKSk7XG5cdFx0fSxcblxuXHRcdHF1YWRyYXRpY0N1cnZlQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGhhbmRsZSA9IFBvaW50LnJlYWQoYXJndW1lbnRzKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRcdGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQ7XG5cdFx0XHR0aGlzLnF1YWRyYXRpY0N1cnZlVG8oY3VycmVudC5hZGQoaGFuZGxlKSwgY3VycmVudC5hZGQodG8pKTtcblx0XHR9LFxuXG5cdFx0YXJjQnk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGN1cnJlbnQgPSBnZXRDdXJyZW50U2VnbWVudCh0aGlzKS5fcG9pbnQsXG5cdFx0XHRcdHBvaW50ID0gY3VycmVudC5hZGQoUG9pbnQucmVhZChhcmd1bWVudHMpKSxcblx0XHRcdFx0Y2xvY2t3aXNlID0gQmFzZS5waWNrKEJhc2UucGVlayhhcmd1bWVudHMpLCB0cnVlKTtcblx0XHRcdGlmICh0eXBlb2YgY2xvY2t3aXNlID09PSAnYm9vbGVhbicpIHtcblx0XHRcdFx0dGhpcy5hcmNUbyhwb2ludCwgY2xvY2t3aXNlKTtcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdHRoaXMuYXJjVG8ocG9pbnQsIGN1cnJlbnQuYWRkKFBvaW50LnJlYWQoYXJndW1lbnRzKSkpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRjbG9zZVBhdGg6IGZ1bmN0aW9uKGpvaW4pIHtcblx0XHRcdHRoaXMuc2V0Q2xvc2VkKHRydWUpO1xuXHRcdFx0aWYgKGpvaW4pXG5cdFx0XHRcdHRoaXMuam9pbigpO1xuXHRcdH1cblx0fTtcbn0sIHtcblxuXHRfZ2V0Qm91bmRzOiBmdW5jdGlvbihnZXR0ZXIsIG1hdHJpeCkge1xuXHRcdHJldHVybiBQYXRoW2dldHRlcl0odGhpcy5fc2VnbWVudHMsIHRoaXMuX2Nsb3NlZCwgdGhpcy5nZXRTdHlsZSgpLFxuXHRcdFx0XHRtYXRyaXgpO1xuXHR9LFxuXG5zdGF0aWNzOiB7XG5cdGdldEJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCwgc3Ryb2tlUGFkZGluZykge1xuXHRcdHZhciBmaXJzdCA9IHNlZ21lbnRzWzBdO1xuXHRcdGlmICghZmlyc3QpXG5cdFx0XHRyZXR1cm4gbmV3IFJlY3RhbmdsZSgpO1xuXHRcdHZhciBjb29yZHMgPSBuZXcgQXJyYXkoNiksXG5cdFx0XHRwcmV2Q29vcmRzID0gZmlyc3QuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgbmV3IEFycmF5KDYpLCBmYWxzZSksXG5cdFx0XHRtaW4gPSBwcmV2Q29vcmRzLnNsaWNlKDAsIDIpLFxuXHRcdFx0bWF4ID0gbWluLnNsaWNlKCksXG5cdFx0XHRyb290cyA9IG5ldyBBcnJheSgyKTtcblxuXHRcdGZ1bmN0aW9uIHByb2Nlc3NTZWdtZW50KHNlZ21lbnQpIHtcblx0XHRcdHNlZ21lbnQuX3RyYW5zZm9ybUNvb3JkaW5hdGVzKG1hdHJpeCwgY29vcmRzLCBmYWxzZSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDI7IGkrKykge1xuXHRcdFx0XHRDdXJ2ZS5fYWRkQm91bmRzKFxuXHRcdFx0XHRcdHByZXZDb29yZHNbaV0sXG5cdFx0XHRcdFx0cHJldkNvb3Jkc1tpICsgNF0sXG5cdFx0XHRcdFx0Y29vcmRzW2kgKyAyXSxcblx0XHRcdFx0XHRjb29yZHNbaV0sXG5cdFx0XHRcdFx0aSwgc3Ryb2tlUGFkZGluZyA/IHN0cm9rZVBhZGRpbmdbaV0gOiAwLCBtaW4sIG1heCwgcm9vdHMpO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHRtcCA9IHByZXZDb29yZHM7XG5cdFx0XHRwcmV2Q29vcmRzID0gY29vcmRzO1xuXHRcdFx0Y29vcmRzID0gdG1wO1xuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAxLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0cHJvY2Vzc1NlZ21lbnQoc2VnbWVudHNbaV0pO1xuXHRcdGlmIChjbG9zZWQpXG5cdFx0XHRwcm9jZXNzU2VnbWVudChmaXJzdCk7XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUobWluWzBdLCBtaW5bMV0sIG1heFswXSAtIG1pblswXSwgbWF4WzFdIC0gbWluWzFdKTtcblx0fSxcblxuXHRnZXRTdHJva2VCb3VuZHM6IGZ1bmN0aW9uKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgpIHtcblx0XHRpZiAoIXN0eWxlLmhhc1N0cm9rZSgpKVxuXHRcdFx0cmV0dXJuIFBhdGguZ2V0Qm91bmRzKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgpO1xuXHRcdHZhciBsZW5ndGggPSBzZWdtZW50cy5sZW5ndGggLSAoY2xvc2VkID8gMCA6IDEpLFxuXHRcdFx0cmFkaXVzID0gc3R5bGUuZ2V0U3Ryb2tlV2lkdGgoKSAvIDIsXG5cdFx0XHRwYWRkaW5nID0gUGF0aC5fZ2V0UGVuUGFkZGluZyhyYWRpdXMsIG1hdHJpeCksXG5cdFx0XHRib3VuZHMgPSBQYXRoLmdldEJvdW5kcyhzZWdtZW50cywgY2xvc2VkLCBzdHlsZSwgbWF0cml4LCBwYWRkaW5nKSxcblx0XHRcdGpvaW4gPSBzdHlsZS5nZXRTdHJva2VKb2luKCksXG5cdFx0XHRjYXAgPSBzdHlsZS5nZXRTdHJva2VDYXAoKSxcblx0XHRcdG1pdGVyTGltaXQgPSByYWRpdXMgKiBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG5cdFx0dmFyIGpvaW5Cb3VuZHMgPSBuZXcgUmVjdGFuZ2xlKG5ldyBTaXplKHBhZGRpbmcpLm11bHRpcGx5KDIpKTtcblxuXHRcdGZ1bmN0aW9uIGFkZChwb2ludCkge1xuXHRcdFx0Ym91bmRzID0gYm91bmRzLmluY2x1ZGUobWF0cml4XG5cdFx0XHRcdD8gbWF0cml4Ll90cmFuc2Zvcm1Qb2ludChwb2ludCwgcG9pbnQpIDogcG9pbnQpO1xuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGFkZFJvdW5kKHNlZ21lbnQpIHtcblx0XHRcdGJvdW5kcyA9IGJvdW5kcy51bml0ZShqb2luQm91bmRzLnNldENlbnRlcihtYXRyaXhcblx0XHRcdFx0PyBtYXRyaXguX3RyYW5zZm9ybVBvaW50KHNlZ21lbnQuX3BvaW50KSA6IHNlZ21lbnQuX3BvaW50KSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gYWRkSm9pbihzZWdtZW50LCBqb2luKSB7XG5cdFx0XHR2YXIgaGFuZGxlSW4gPSBzZWdtZW50Ll9oYW5kbGVJbixcblx0XHRcdFx0aGFuZGxlT3V0ID0gc2VnbWVudC5faGFuZGxlT3V0O1xuXHRcdFx0aWYgKGpvaW4gPT09ICdyb3VuZCcgfHwgIWhhbmRsZUluLmlzWmVybygpICYmICFoYW5kbGVPdXQuaXNaZXJvKClcblx0XHRcdFx0XHQmJiBoYW5kbGVJbi5pc0NvbGxpbmVhcihoYW5kbGVPdXQpKSB7XG5cdFx0XHRcdGFkZFJvdW5kKHNlZ21lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UGF0aC5fYWRkQmV2ZWxKb2luKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCwgYWRkKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmdW5jdGlvbiBhZGRDYXAoc2VnbWVudCwgY2FwKSB7XG5cdFx0XHRpZiAoY2FwID09PSAncm91bmQnKSB7XG5cdFx0XHRcdGFkZFJvdW5kKHNlZ21lbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0UGF0aC5fYWRkU3F1YXJlQ2FwKHNlZ21lbnQsIGNhcCwgcmFkaXVzLCBhZGQpO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAodmFyIGkgPSAxOyBpIDwgbGVuZ3RoOyBpKyspXG5cdFx0XHRhZGRKb2luKHNlZ21lbnRzW2ldLCBqb2luKTtcblx0XHRpZiAoY2xvc2VkKSB7XG5cdFx0XHRhZGRKb2luKHNlZ21lbnRzWzBdLCBqb2luKTtcblx0XHR9IGVsc2UgaWYgKGxlbmd0aCA+IDApIHtcblx0XHRcdGFkZENhcChzZWdtZW50c1swXSwgY2FwKTtcblx0XHRcdGFkZENhcChzZWdtZW50c1tzZWdtZW50cy5sZW5ndGggLSAxXSwgY2FwKTtcblx0XHR9XG5cdFx0cmV0dXJuIGJvdW5kcztcblx0fSxcblxuXHRfZ2V0UGVuUGFkZGluZzogZnVuY3Rpb24ocmFkaXVzLCBtYXRyaXgpIHtcblx0XHRpZiAoIW1hdHJpeClcblx0XHRcdHJldHVybiBbcmFkaXVzLCByYWRpdXNdO1xuXHRcdHZhciBteCA9IG1hdHJpeC5zaGlmdGxlc3MoKSxcblx0XHRcdGhvciA9IG14LnRyYW5zZm9ybShuZXcgUG9pbnQocmFkaXVzLCAwKSksXG5cdFx0XHR2ZXIgPSBteC50cmFuc2Zvcm0obmV3IFBvaW50KDAsIHJhZGl1cykpLFxuXHRcdFx0cGhpID0gaG9yLmdldEFuZ2xlSW5SYWRpYW5zKCksXG5cdFx0XHRhID0gaG9yLmdldExlbmd0aCgpLFxuXHRcdFx0YiA9IHZlci5nZXRMZW5ndGgoKTtcblx0XHR2YXIgc2luID0gTWF0aC5zaW4ocGhpKSxcblx0XHRcdGNvcyA9IE1hdGguY29zKHBoaSksXG5cdFx0XHR0YW4gPSBNYXRoLnRhbihwaGkpLFxuXHRcdFx0dHggPSAtTWF0aC5hdGFuKGIgKiB0YW4gLyBhKSxcblx0XHRcdHR5ID0gTWF0aC5hdGFuKGIgLyAodGFuICogYSkpO1xuXHRcdHJldHVybiBbTWF0aC5hYnMoYSAqIE1hdGguY29zKHR4KSAqIGNvcyAtIGIgKiBNYXRoLnNpbih0eCkgKiBzaW4pLFxuXHRcdFx0XHRNYXRoLmFicyhiICogTWF0aC5zaW4odHkpICogY29zICsgYSAqIE1hdGguY29zKHR5KSAqIHNpbildO1xuXHR9LFxuXG5cdF9hZGRCZXZlbEpvaW46IGZ1bmN0aW9uKHNlZ21lbnQsIGpvaW4sIHJhZGl1cywgbWl0ZXJMaW1pdCwgYWRkUG9pbnQsIGFyZWEpIHtcblx0XHR2YXIgY3VydmUyID0gc2VnbWVudC5nZXRDdXJ2ZSgpLFxuXHRcdFx0Y3VydmUxID0gY3VydmUyLmdldFByZXZpb3VzKCksXG5cdFx0XHRwb2ludCA9IGN1cnZlMi5nZXRQb2ludEF0KDAsIHRydWUpLFxuXHRcdFx0bm9ybWFsMSA9IGN1cnZlMS5nZXROb3JtYWxBdCgxLCB0cnVlKSxcblx0XHRcdG5vcm1hbDIgPSBjdXJ2ZTIuZ2V0Tm9ybWFsQXQoMCwgdHJ1ZSksXG5cdFx0XHRzdGVwID0gbm9ybWFsMS5nZXREaXJlY3RlZEFuZ2xlKG5vcm1hbDIpIDwgMCA/IC1yYWRpdXMgOiByYWRpdXM7XG5cdFx0bm9ybWFsMS5zZXRMZW5ndGgoc3RlcCk7XG5cdFx0bm9ybWFsMi5zZXRMZW5ndGgoc3RlcCk7XG5cdFx0aWYgKGFyZWEpIHtcblx0XHRcdGFkZFBvaW50KHBvaW50KTtcblx0XHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwxKSk7XG5cdFx0fVxuXHRcdGlmIChqb2luID09PSAnbWl0ZXInKSB7XG5cdFx0XHR2YXIgY29ybmVyID0gbmV3IExpbmUoXG5cdFx0XHRcdFx0cG9pbnQuYWRkKG5vcm1hbDEpLFxuXHRcdFx0XHRcdG5ldyBQb2ludCgtbm9ybWFsMS55LCBub3JtYWwxLngpLCB0cnVlXG5cdFx0XHRcdCkuaW50ZXJzZWN0KG5ldyBMaW5lKFxuXHRcdFx0XHRcdHBvaW50LmFkZChub3JtYWwyKSxcblx0XHRcdFx0XHRuZXcgUG9pbnQoLW5vcm1hbDIueSwgbm9ybWFsMi54KSwgdHJ1ZVxuXHRcdFx0XHQpLCB0cnVlKTtcblx0XHRcdGlmIChjb3JuZXIgJiYgcG9pbnQuZ2V0RGlzdGFuY2UoY29ybmVyKSA8PSBtaXRlckxpbWl0KSB7XG5cdFx0XHRcdGFkZFBvaW50KGNvcm5lcik7XG5cdFx0XHRcdGlmICghYXJlYSlcblx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghYXJlYSlcblx0XHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwxKSk7XG5cdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbDIpKTtcblx0fSxcblxuXHRfYWRkU3F1YXJlQ2FwOiBmdW5jdGlvbihzZWdtZW50LCBjYXAsIHJhZGl1cywgYWRkUG9pbnQsIGFyZWEpIHtcblx0XHR2YXIgcG9pbnQgPSBzZWdtZW50Ll9wb2ludCxcblx0XHRcdGxvYyA9IHNlZ21lbnQuZ2V0TG9jYXRpb24oKSxcblx0XHRcdG5vcm1hbCA9IGxvYy5nZXROb3JtYWwoKS5tdWx0aXBseShyYWRpdXMpO1xuXHRcdGlmIChhcmVhKSB7XG5cdFx0XHRhZGRQb2ludChwb2ludC5zdWJ0cmFjdChub3JtYWwpKTtcblx0XHRcdGFkZFBvaW50KHBvaW50LmFkZChub3JtYWwpKTtcblx0XHR9XG5cdFx0aWYgKGNhcCA9PT0gJ3NxdWFyZScpXG5cdFx0XHRwb2ludCA9IHBvaW50LmFkZChub3JtYWwucm90YXRlKGxvYy5nZXRQYXJhbWV0ZXIoKSA9PT0gMCA/IC05MCA6IDkwKSk7XG5cdFx0YWRkUG9pbnQocG9pbnQuYWRkKG5vcm1hbCkpO1xuXHRcdGFkZFBvaW50KHBvaW50LnN1YnRyYWN0KG5vcm1hbCkpO1xuXHR9LFxuXG5cdGdldEhhbmRsZUJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCwgc3Ryb2tlUGFkZGluZyxcblx0XHRcdGpvaW5QYWRkaW5nKSB7XG5cdFx0dmFyIGNvb3JkcyA9IG5ldyBBcnJheSg2KSxcblx0XHRcdHgxID0gSW5maW5pdHksXG5cdFx0XHR4MiA9IC14MSxcblx0XHRcdHkxID0geDEsXG5cdFx0XHR5MiA9IHgyO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0c2VnbWVudC5fdHJhbnNmb3JtQ29vcmRpbmF0ZXMobWF0cml4LCBjb29yZHMsIGZhbHNlKTtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgNjsgaiArPSAyKSB7XG5cdFx0XHRcdHZhciBwYWRkaW5nID0gaiA9PT0gMCA/IGpvaW5QYWRkaW5nIDogc3Ryb2tlUGFkZGluZyxcblx0XHRcdFx0XHRwYWRkaW5nWCA9IHBhZGRpbmcgPyBwYWRkaW5nWzBdIDogMCxcblx0XHRcdFx0XHRwYWRkaW5nWSA9IHBhZGRpbmcgPyBwYWRkaW5nWzFdIDogMCxcblx0XHRcdFx0XHR4ID0gY29vcmRzW2pdLFxuXHRcdFx0XHRcdHkgPSBjb29yZHNbaiArIDFdLFxuXHRcdFx0XHRcdHhuID0geCAtIHBhZGRpbmdYLFxuXHRcdFx0XHRcdHh4ID0geCArIHBhZGRpbmdYLFxuXHRcdFx0XHRcdHluID0geSAtIHBhZGRpbmdZLFxuXHRcdFx0XHRcdHl4ID0geSArIHBhZGRpbmdZO1xuXHRcdFx0XHRpZiAoeG4gPCB4MSkgeDEgPSB4bjtcblx0XHRcdFx0aWYgKHh4ID4geDIpIHgyID0geHg7XG5cdFx0XHRcdGlmICh5biA8IHkxKSB5MSA9IHluO1xuXHRcdFx0XHRpZiAoeXggPiB5MikgeTIgPSB5eDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeDEsIHkxLCB4MiAtIHgxLCB5MiAtIHkxKTtcblx0fSxcblxuXHRnZXRSb3VnaEJvdW5kczogZnVuY3Rpb24oc2VnbWVudHMsIGNsb3NlZCwgc3R5bGUsIG1hdHJpeCkge1xuXHRcdHZhciBzdHJva2VSYWRpdXMgPSBzdHlsZS5oYXNTdHJva2UoKSA/IHN0eWxlLmdldFN0cm9rZVdpZHRoKCkgLyAyIDogMCxcblx0XHRcdGpvaW5SYWRpdXMgPSBzdHJva2VSYWRpdXM7XG5cdFx0aWYgKHN0cm9rZVJhZGl1cyA+IDApIHtcblx0XHRcdGlmIChzdHlsZS5nZXRTdHJva2VKb2luKCkgPT09ICdtaXRlcicpXG5cdFx0XHRcdGpvaW5SYWRpdXMgPSBzdHJva2VSYWRpdXMgKiBzdHlsZS5nZXRNaXRlckxpbWl0KCk7XG5cdFx0XHRpZiAoc3R5bGUuZ2V0U3Ryb2tlQ2FwKCkgPT09ICdzcXVhcmUnKVxuXHRcdFx0XHRqb2luUmFkaXVzID0gTWF0aC5tYXgoam9pblJhZGl1cywgc3Ryb2tlUmFkaXVzICogTWF0aC5zcXJ0KDIpKTtcblx0XHR9XG5cdFx0cmV0dXJuIFBhdGguZ2V0SGFuZGxlQm91bmRzKHNlZ21lbnRzLCBjbG9zZWQsIHN0eWxlLCBtYXRyaXgsXG5cdFx0XHRcdFBhdGguX2dldFBlblBhZGRpbmcoc3Ryb2tlUmFkaXVzLCBtYXRyaXgpLFxuXHRcdFx0XHRQYXRoLl9nZXRQZW5QYWRkaW5nKGpvaW5SYWRpdXMsIG1hdHJpeCkpO1xuXHR9XG59fSk7XG5cblBhdGguaW5qZWN0KHsgc3RhdGljczogbmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBrYXBwYSA9IDAuNTUyMjg0NzQ5ODMwNzkzNixcblx0XHRlbGxpcHNlU2VnbWVudHMgPSBbXG5cdFx0XHRuZXcgU2VnbWVudChbLTEsIDBdLCBbMCwga2FwcGEgXSwgWzAsIC1rYXBwYV0pLFxuXHRcdFx0bmV3IFNlZ21lbnQoWzAsIC0xXSwgWy1rYXBwYSwgMF0sIFtrYXBwYSwgMCBdKSxcblx0XHRcdG5ldyBTZWdtZW50KFsxLCAwXSwgWzAsIC1rYXBwYV0sIFswLCBrYXBwYSBdKSxcblx0XHRcdG5ldyBTZWdtZW50KFswLCAxXSwgW2thcHBhLCAwIF0sIFsta2FwcGEsIDBdKVxuXHRcdF07XG5cblx0ZnVuY3Rpb24gY3JlYXRlUGF0aChzZWdtZW50cywgY2xvc2VkLCBhcmdzKSB7XG5cdFx0dmFyIHByb3BzID0gQmFzZS5nZXROYW1lZChhcmdzKSxcblx0XHRcdHBhdGggPSBuZXcgUGF0aChwcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT09IGZhbHNlICYmIEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRwYXRoLl9hZGQoc2VnbWVudHMpO1xuXHRcdHBhdGguX2Nsb3NlZCA9IGNsb3NlZDtcblx0XHRyZXR1cm4gcGF0aC5zZXQocHJvcHMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlRWxsaXBzZShjZW50ZXIsIHJhZGl1cywgYXJncykge1xuXHRcdHZhciBzZWdtZW50cyA9IG5ldyBBcnJheSg0KTtcblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDQ7IGkrKykge1xuXHRcdFx0dmFyIHNlZ21lbnQgPSBlbGxpcHNlU2VnbWVudHNbaV07XG5cdFx0XHRzZWdtZW50c1tpXSA9IG5ldyBTZWdtZW50KFxuXHRcdFx0XHRzZWdtZW50Ll9wb2ludC5tdWx0aXBseShyYWRpdXMpLmFkZChjZW50ZXIpLFxuXHRcdFx0XHRzZWdtZW50Ll9oYW5kbGVJbi5tdWx0aXBseShyYWRpdXMpLFxuXHRcdFx0XHRzZWdtZW50Ll9oYW5kbGVPdXQubXVsdGlwbHkocmFkaXVzKVxuXHRcdFx0KTtcblx0XHR9XG5cdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3MpO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRMaW5lOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKFtcblx0XHRcdFx0bmV3IFNlZ21lbnQoUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2Zyb20nKSksXG5cdFx0XHRcdG5ldyBTZWdtZW50KFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICd0bycpKVxuXHRcdFx0XSwgZmFsc2UsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdENpcmNsZTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY2VudGVyID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ2NlbnRlcicpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKTtcblx0XHRcdHJldHVybiBjcmVhdGVFbGxpcHNlKGNlbnRlciwgbmV3IFNpemUocmFkaXVzKSwgYXJndW1lbnRzKTtcblx0XHR9LFxuXG5cdFx0UmVjdGFuZ2xlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciByZWN0ID0gUmVjdGFuZ2xlLnJlYWROYW1lZChhcmd1bWVudHMsICdyZWN0YW5nbGUnKSxcblx0XHRcdFx0cmFkaXVzID0gU2l6ZS5yZWFkTmFtZWQoYXJndW1lbnRzLCAncmFkaXVzJywgMCxcblx0XHRcdFx0XHRcdHsgcmVhZE51bGw6IHRydWUgfSksXG5cdFx0XHRcdGJsID0gcmVjdC5nZXRCb3R0b21MZWZ0KHRydWUpLFxuXHRcdFx0XHR0bCA9IHJlY3QuZ2V0VG9wTGVmdCh0cnVlKSxcblx0XHRcdFx0dHIgPSByZWN0LmdldFRvcFJpZ2h0KHRydWUpLFxuXHRcdFx0XHRiciA9IHJlY3QuZ2V0Qm90dG9tUmlnaHQodHJ1ZSksXG5cdFx0XHRcdHNlZ21lbnRzO1xuXHRcdFx0aWYgKCFyYWRpdXMgfHwgcmFkaXVzLmlzWmVybygpKSB7XG5cdFx0XHRcdHNlZ21lbnRzID0gW1xuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJsKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0bCksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodHIpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJyKVxuXHRcdFx0XHRdO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmFkaXVzID0gU2l6ZS5taW4ocmFkaXVzLCByZWN0LmdldFNpemUodHJ1ZSkuZGl2aWRlKDIpKTtcblx0XHRcdFx0dmFyIHJ4ID0gcmFkaXVzLndpZHRoLFxuXHRcdFx0XHRcdHJ5ID0gcmFkaXVzLmhlaWdodCxcblx0XHRcdFx0XHRoeCA9IHJ4ICoga2FwcGEsXG5cdFx0XHRcdFx0aHkgPSByeSAqIGthcHBhO1xuXHRcdFx0XHRzZWdtZW50cyA9IFtcblx0XHRcdFx0XHRuZXcgU2VnbWVudChibC5hZGQocngsIDApLCBudWxsLCBbLWh4LCAwXSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYmwuc3VidHJhY3QoMCwgcnkpLCBbMCwgaHldKSxcblx0XHRcdFx0XHRuZXcgU2VnbWVudCh0bC5hZGQoMCwgcnkpLCBudWxsLCBbMCwgLWh5XSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodGwuYWRkKHJ4LCAwKSwgWy1oeCwgMF0sIG51bGwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KHRyLnN1YnRyYWN0KHJ4LCAwKSwgbnVsbCwgW2h4LCAwXSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQodHIuYWRkKDAsIHJ5KSwgWzAsIC1oeV0sIG51bGwpLFxuXHRcdFx0XHRcdG5ldyBTZWdtZW50KGJyLnN1YnRyYWN0KDAsIHJ5KSwgbnVsbCwgWzAsIGh5XSksXG5cdFx0XHRcdFx0bmV3IFNlZ21lbnQoYnIuc3VidHJhY3QocngsIDApLCBbaHgsIDBdKVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIGNyZWF0ZVBhdGgoc2VnbWVudHMsIHRydWUsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdFJvdW5kUmVjdGFuZ2xlOiAnI1JlY3RhbmdsZScsXG5cblx0XHRFbGxpcHNlOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBlbGxpcHNlID0gU2hhcGUuX3JlYWRFbGxpcHNlKGFyZ3VtZW50cyk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlRWxsaXBzZShlbGxpcHNlLmNlbnRlciwgZWxsaXBzZS5yYWRpdXMsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdE92YWw6ICcjRWxsaXBzZScsXG5cblx0XHRBcmM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGZyb20gPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnZnJvbScpLFxuXHRcdFx0XHR0aHJvdWdoID0gUG9pbnQucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3Rocm91Z2gnKSxcblx0XHRcdFx0dG8gPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAndG8nKSxcblx0XHRcdFx0cHJvcHMgPSBCYXNlLmdldE5hbWVkKGFyZ3VtZW50cyksXG5cdFx0XHRcdHBhdGggPSBuZXcgUGF0aChwcm9wcyAmJiBwcm9wcy5pbnNlcnQgPT09IGZhbHNlXG5cdFx0XHRcdFx0XHQmJiBJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRwYXRoLm1vdmVUbyhmcm9tKTtcblx0XHRcdHBhdGguYXJjVG8odGhyb3VnaCwgdG8pO1xuXHRcdFx0cmV0dXJuIHBhdGguc2V0KHByb3BzKTtcblx0XHR9LFxuXG5cdFx0UmVndWxhclBvbHlnb246IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWROYW1lZChhcmd1bWVudHMsICdjZW50ZXInKSxcblx0XHRcdFx0c2lkZXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdzaWRlcycpLFxuXHRcdFx0XHRyYWRpdXMgPSBCYXNlLnJlYWROYW1lZChhcmd1bWVudHMsICdyYWRpdXMnKSxcblx0XHRcdFx0c3RlcCA9IDM2MCAvIHNpZGVzLFxuXHRcdFx0XHR0aHJlZSA9ICEoc2lkZXMgJSAzKSxcblx0XHRcdFx0dmVjdG9yID0gbmV3IFBvaW50KDAsIHRocmVlID8gLXJhZGl1cyA6IHJhZGl1cyksXG5cdFx0XHRcdG9mZnNldCA9IHRocmVlID8gLTEgOiAwLjUsXG5cdFx0XHRcdHNlZ21lbnRzID0gbmV3IEFycmF5KHNpZGVzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgc2lkZXM7IGkrKylcblx0XHRcdFx0c2VnbWVudHNbaV0gPSBuZXcgU2VnbWVudChjZW50ZXIuYWRkKFxuXHRcdFx0XHRcdHZlY3Rvci5yb3RhdGUoKGkgKyBvZmZzZXQpICogc3RlcCkpKTtcblx0XHRcdHJldHVybiBjcmVhdGVQYXRoKHNlZ21lbnRzLCB0cnVlLCBhcmd1bWVudHMpO1xuXHRcdH0sXG5cblx0XHRTdGFyOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjZW50ZXIgPSBQb2ludC5yZWFkTmFtZWQoYXJndW1lbnRzLCAnY2VudGVyJyksXG5cdFx0XHRcdHBvaW50cyA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3BvaW50cycpICogMixcblx0XHRcdFx0cmFkaXVzMSA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1czEnKSxcblx0XHRcdFx0cmFkaXVzMiA9IEJhc2UucmVhZE5hbWVkKGFyZ3VtZW50cywgJ3JhZGl1czInKSxcblx0XHRcdFx0c3RlcCA9IDM2MCAvIHBvaW50cyxcblx0XHRcdFx0dmVjdG9yID0gbmV3IFBvaW50KDAsIC0xKSxcblx0XHRcdFx0c2VnbWVudHMgPSBuZXcgQXJyYXkocG9pbnRzKTtcblx0XHRcdGZvciAodmFyIGkgPSAwOyBpIDwgcG9pbnRzOyBpKyspXG5cdFx0XHRcdHNlZ21lbnRzW2ldID0gbmV3IFNlZ21lbnQoY2VudGVyLmFkZCh2ZWN0b3Iucm90YXRlKHN0ZXAgKiBpKVxuXHRcdFx0XHRcdFx0Lm11bHRpcGx5KGkgJSAyID8gcmFkaXVzMiA6IHJhZGl1czEpKSk7XG5cdFx0XHRyZXR1cm4gY3JlYXRlUGF0aChzZWdtZW50cywgdHJ1ZSwgYXJndW1lbnRzKTtcblx0XHR9XG5cdH07XG59fSk7XG5cbnZhciBDb21wb3VuZFBhdGggPSBQYXRoSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdDb21wb3VuZFBhdGgnLFxuXHRfc2VyaWFsaXplRmllbGRzOiB7XG5cdFx0Y2hpbGRyZW46IFtdXG5cdH0sXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29tcG91bmRQYXRoKGFyZykge1xuXHRcdHRoaXMuX2NoaWxkcmVuID0gW107XG5cdFx0dGhpcy5fbmFtZWRDaGlsZHJlbiA9IHt9O1xuXHRcdGlmICghdGhpcy5faW5pdGlhbGl6ZShhcmcpKSB7XG5cdFx0XHRpZiAodHlwZW9mIGFyZyA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0dGhpcy5zZXRQYXRoRGF0YShhcmcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dGhpcy5hZGRDaGlsZHJlbihBcnJheS5pc0FycmF5KGFyZykgPyBhcmcgOiBhcmd1bWVudHMpO1xuXHRcdFx0fVxuXHRcdH1cblx0fSxcblxuXHRpbnNlcnRDaGlsZHJlbjogZnVuY3Rpb24gaW5zZXJ0Q2hpbGRyZW4oaW5kZXgsIGl0ZW1zLCBfcHJlc2VydmUpIHtcblx0XHRmb3IgKHZhciBpID0gaXRlbXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBpdGVtID0gaXRlbXNbaV07XG5cdFx0XHRpZiAoaXRlbSBpbnN0YW5jZW9mIENvbXBvdW5kUGF0aCkge1xuXHRcdFx0XHRpdGVtcy5zcGxpY2UuYXBwbHkoaXRlbXMsIFtpLCAxXS5jb25jYXQoaXRlbS5yZW1vdmVDaGlsZHJlbigpKSk7XG5cdFx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGl0ZW1zID0gaW5zZXJ0Q2hpbGRyZW4uYmFzZS5jYWxsKHRoaXMsIGluZGV4LCBpdGVtcywgX3ByZXNlcnZlLCBQYXRoKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9ICFfcHJlc2VydmUgJiYgaXRlbXMgJiYgaXRlbXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IGl0ZW1zW2ldO1xuXHRcdFx0aWYgKGl0ZW0uX2Nsb2Nrd2lzZSA9PT0gdW5kZWZpbmVkKVxuXHRcdFx0XHRpdGVtLnNldENsb2Nrd2lzZShpdGVtLl9pbmRleCA9PT0gMCk7XG5cdFx0fVxuXHRcdHJldHVybiBpdGVtcztcblx0fSxcblxuXHRyZXZlcnNlOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGNoaWxkcmVuW2ldLnJldmVyc2UoKTtcblx0fSxcblxuXHRzbW9vdGg6IGZ1bmN0aW9uKCkge1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0dGhpcy5fY2hpbGRyZW5baV0uc21vb3RoKCk7XG5cdH0sXG5cblx0cmVkdWNlOiBmdW5jdGlvbiByZWR1Y2UoKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgcGF0aCA9IGNoaWxkcmVuW2ldLnJlZHVjZSgpO1xuXHRcdFx0aWYgKHBhdGguaXNFbXB0eSgpKVxuXHRcdFx0XHRjaGlsZHJlbi5zcGxpY2UoaSwgMSk7XG5cdFx0fVxuXHRcdGlmIChjaGlsZHJlbi5sZW5ndGggPT09IDApIHtcblx0XHRcdHZhciBwYXRoID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0cGF0aC5pbnNlcnRBYm92ZSh0aGlzKTtcblx0XHRcdHBhdGguc2V0U3R5bGUodGhpcy5fc3R5bGUpO1xuXHRcdFx0dGhpcy5yZW1vdmUoKTtcblx0XHRcdHJldHVybiBwYXRoO1xuXHRcdH1cblx0XHRyZXR1cm4gcmVkdWNlLmJhc2UuY2FsbCh0aGlzKTtcblx0fSxcblxuXHRpc0Nsb2Nrd2lzZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGNoaWxkICYmIGNoaWxkLmlzQ2xvY2t3aXNlKCk7XG5cdH0sXG5cblx0c2V0Q2xvY2t3aXNlOiBmdW5jdGlvbihjbG9ja3dpc2UpIHtcblx0XHRpZiAodGhpcy5pc0Nsb2Nrd2lzZSgpICE9PSAhIWNsb2Nrd2lzZSlcblx0XHRcdHRoaXMucmV2ZXJzZSgpO1xuXHR9LFxuXG5cdGdldEZpcnN0U2VnbWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0U2VnbWVudCgpO1xuXHR9LFxuXG5cdGdldExhc3RTZWdtZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbGFzdCA9IHRoaXMuZ2V0TGFzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGxhc3QgJiYgbGFzdC5nZXRMYXN0U2VnbWVudCgpO1xuXHR9LFxuXG5cdGdldEN1cnZlczogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW4sXG5cdFx0XHRjdXJ2ZXMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdGN1cnZlcy5wdXNoLmFwcGx5KGN1cnZlcywgY2hpbGRyZW5baV0uZ2V0Q3VydmVzKCkpO1xuXHRcdHJldHVybiBjdXJ2ZXM7XG5cdH0sXG5cblx0Z2V0Rmlyc3RDdXJ2ZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZpcnN0ID0gdGhpcy5nZXRGaXJzdENoaWxkKCk7XG5cdFx0cmV0dXJuIGZpcnN0ICYmIGZpcnN0LmdldEZpcnN0Q3VydmUoKTtcblx0fSxcblxuXHRnZXRMYXN0Q3VydmU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBsYXN0ID0gdGhpcy5nZXRMYXN0Q2hpbGQoKTtcblx0XHRyZXR1cm4gbGFzdCAmJiBsYXN0LmdldEZpcnN0Q3VydmUoKTtcblx0fSxcblxuXHRnZXRBcmVhOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdGFyZWEgPSAwO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0YXJlYSArPSBjaGlsZHJlbltpXS5nZXRBcmVhKCk7XG5cdFx0cmV0dXJuIGFyZWE7XG5cdH1cbn0sIHtcblx0YmVhbnM6IHRydWUsXG5cblx0Z2V0UGF0aERhdGE6IGZ1bmN0aW9uKF9tYXRyaXgsIF9wcmVjaXNpb24pIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbixcblx0XHRcdHBhdGhzID0gW107XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuXHRcdFx0XHRteCA9IGNoaWxkLl9tYXRyaXg7XG5cdFx0XHRwYXRocy5wdXNoKGNoaWxkLmdldFBhdGhEYXRhKF9tYXRyaXggJiYgIW14LmlzSWRlbnRpdHkoKVxuXHRcdFx0XHRcdD8gX21hdHJpeC5jaGFpbihteCkgOiBfbWF0cml4LCBfcHJlY2lzaW9uKSk7XG5cdFx0fVxuXHRcdHJldHVybiBwYXRocy5qb2luKCcgJyk7XG5cdH1cbn0sIHtcblx0X2dldENoaWxkSGl0VGVzdE9wdGlvbnM6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRyZXR1cm4gb3B0aW9ucy5jbGFzcyA9PT0gUGF0aCB8fCBvcHRpb25zLnR5cGUgPT09ICdwYXRoJ1xuXHRcdFx0XHQ/IG9wdGlvbnNcblx0XHRcdFx0OiBuZXcgQmFzZShvcHRpb25zLCB7IGZpbGw6IGZhbHNlIH0pO1xuXHR9LFxuXG5cdF9kcmF3OiBmdW5jdGlvbihjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLl9jaGlsZHJlbjtcblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAwKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0aWYgKHRoaXMuX2N1cnJlbnRQYXRoKSB7XG5cdFx0XHRjdHguY3VycmVudFBhdGggPSB0aGlzLl9jdXJyZW50UGF0aDtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cGFyYW0gPSBwYXJhbS5leHRlbmQoeyBkb250U3RhcnQ6IHRydWUsIGRvbnRGaW5pc2g6IHRydWUgfSk7XG5cdFx0XHRjdHguYmVnaW5QYXRoKCk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y2hpbGRyZW5baV0uZHJhdyhjdHgsIHBhcmFtLCBzdHJva2VNYXRyaXgpO1xuXHRcdFx0dGhpcy5fY3VycmVudFBhdGggPSBjdHguY3VycmVudFBhdGg7XG5cdFx0fVxuXG5cdFx0aWYgKCFwYXJhbS5jbGlwKSB7XG5cdFx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4KTtcblx0XHRcdHZhciBzdHlsZSA9IHRoaXMuX3N0eWxlO1xuXHRcdFx0aWYgKHN0eWxlLmhhc0ZpbGwoKSkge1xuXHRcdFx0XHRjdHguZmlsbChzdHlsZS5nZXRXaW5kaW5nUnVsZSgpKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0eWxlLmhhc1N0cm9rZSgpKVxuXHRcdFx0XHRjdHguc3Ryb2tlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9kcmF3U2VsZWN0ZWQ6IGZ1bmN0aW9uKGN0eCwgbWF0cml4LCBzZWxlY3RlZEl0ZW1zKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhpcy5fY2hpbGRyZW47XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldLFxuXHRcdFx0XHRteCA9IGNoaWxkLl9tYXRyaXg7XG5cdFx0XHRpZiAoIXNlbGVjdGVkSXRlbXNbY2hpbGQuX2lkXSlcblx0XHRcdFx0Y2hpbGQuX2RyYXdTZWxlY3RlZChjdHgsIG14LmlzSWRlbnRpdHkoKSA/IG1hdHJpeFxuXHRcdFx0XHRcdFx0OiBtYXRyaXguY2hhaW4obXgpKTtcblx0XHR9XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGdldEN1cnJlbnRQYXRoKHRoYXQsIGNoZWNrKSB7XG5cdFx0dmFyIGNoaWxkcmVuID0gdGhhdC5fY2hpbGRyZW47XG5cdFx0aWYgKGNoZWNrICYmIGNoaWxkcmVuLmxlbmd0aCA9PT0gMClcblx0XHRcdHRocm93IG5ldyBFcnJvcignVXNlIGEgbW92ZVRvKCkgY29tbWFuZCBmaXJzdCcpO1xuXHRcdHJldHVybiBjaGlsZHJlbltjaGlsZHJlbi5sZW5ndGggLSAxXTtcblx0fVxuXG5cdHZhciBmaWVsZHMgPSB7XG5cdFx0bW92ZVRvOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjdXJyZW50ID0gZ2V0Q3VycmVudFBhdGgodGhpcyksXG5cdFx0XHRcdHBhdGggPSBjdXJyZW50ICYmIGN1cnJlbnQuaXNFbXB0eSgpID8gY3VycmVudFxuXHRcdFx0XHRcdFx0OiBuZXcgUGF0aChJdGVtLk5PX0lOU0VSVCk7XG5cdFx0XHRpZiAocGF0aCAhPT0gY3VycmVudClcblx0XHRcdFx0dGhpcy5hZGRDaGlsZChwYXRoKTtcblx0XHRcdHBhdGgubW92ZVRvLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG5cdFx0fSxcblxuXHRcdG1vdmVCeTogZnVuY3Rpb24oKSB7XG5cdFx0XHR2YXIgY3VycmVudCA9IGdldEN1cnJlbnRQYXRoKHRoaXMsIHRydWUpLFxuXHRcdFx0XHRsYXN0ID0gY3VycmVudCAmJiBjdXJyZW50LmdldExhc3RTZWdtZW50KCksXG5cdFx0XHRcdHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0dGhpcy5tb3ZlVG8obGFzdCA/IHBvaW50LmFkZChsYXN0Ll9wb2ludCkgOiBwb2ludCk7XG5cdFx0fSxcblxuXHRcdGNsb3NlUGF0aDogZnVuY3Rpb24oam9pbikge1xuXHRcdFx0Z2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSkuY2xvc2VQYXRoKGpvaW4pO1xuXHRcdH1cblx0fTtcblxuXHRCYXNlLmVhY2goWydsaW5lVG8nLCAnY3ViaWNDdXJ2ZVRvJywgJ3F1YWRyYXRpY0N1cnZlVG8nLCAnY3VydmVUbycsICdhcmNUbycsXG5cdFx0XHQnbGluZUJ5JywgJ2N1YmljQ3VydmVCeScsICdxdWFkcmF0aWNDdXJ2ZUJ5JywgJ2N1cnZlQnknLCAnYXJjQnknXSxcblx0XHRcdGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0XHRmaWVsZHNba2V5XSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHZhciBwYXRoID0gZ2V0Q3VycmVudFBhdGgodGhpcywgdHJ1ZSk7XG5cdFx0XHRcdFx0cGF0aFtrZXldLmFwcGx5KHBhdGgsIGFyZ3VtZW50cyk7XG5cdFx0XHRcdH07XG5cdFx0XHR9XG5cdCk7XG5cblx0cmV0dXJuIGZpZWxkcztcbn0pO1xuXG5QYXRoSXRlbS5pbmplY3QobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgb3BlcmF0b3JzID0ge1xuXHRcdHVuaXRlOiBmdW5jdGlvbih3KSB7XG5cdFx0XHRyZXR1cm4gdyA9PT0gMSB8fCB3ID09PSAwO1xuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKHcpIHtcblx0XHRcdHJldHVybiB3ID09PSAyO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24odykge1xuXHRcdFx0cmV0dXJuIHcgPT09IDE7XG5cdFx0fSxcblxuXHRcdGV4Y2x1ZGU6IGZ1bmN0aW9uKHcpIHtcblx0XHRcdHJldHVybiB3ID09PSAxO1xuXHRcdH1cblx0fTtcblxuXHRmdW5jdGlvbiBwcmVwYXJlUGF0aChwYXRoLCByZXNvbHZlKSB7XG5cdFx0dmFyIHJlcyA9IHBhdGguY2xvbmUoZmFsc2UpLnJlZHVjZSgpLnRyYW5zZm9ybShudWxsLCB0cnVlLCB0cnVlKTtcblx0XHRyZXR1cm4gcmVzb2x2ZSA/IHJlcy5yZXNvbHZlQ3Jvc3NpbmdzKCkucmVvcmllbnQoKSA6IHJlcztcblx0fVxuXG5cdGZ1bmN0aW9uIGZpbmlzaEJvb2xlYW4oY3RvciwgcGF0aHMsIHBhdGgxLCBwYXRoMiwgcmVkdWNlKSB7XG5cdFx0dmFyIHJlc3VsdCA9IG5ldyBjdG9yKEl0ZW0uTk9fSU5TRVJUKTtcblx0XHRyZXN1bHQuYWRkQ2hpbGRyZW4ocGF0aHMsIHRydWUpO1xuXHRcdGlmIChyZWR1Y2UpXG5cdFx0XHRyZXN1bHQgPSByZXN1bHQucmVkdWNlKCk7XG5cdFx0cmVzdWx0Lmluc2VydEFib3ZlKHBhdGgyICYmIHBhdGgxLmlzU2libGluZyhwYXRoMilcblx0XHRcdFx0JiYgcGF0aDEuZ2V0SW5kZXgoKSA8IHBhdGgyLmdldEluZGV4KClcblx0XHRcdFx0XHQ/IHBhdGgyIDogcGF0aDEpO1xuXHRcdHJlc3VsdC5zZXRTdHlsZShwYXRoMS5fc3R5bGUpO1xuXHRcdHJldHVybiByZXN1bHQ7XG5cdH1cblxuXHRmdW5jdGlvbiBjb21wdXRlQm9vbGVhbihwYXRoMSwgcGF0aDIsIG9wZXJhdGlvbikge1xuXHRcdGlmICghcGF0aDEuX2NoaWxkcmVuICYmICFwYXRoMS5fY2xvc2VkKVxuXHRcdFx0cmV0dXJuIGNvbXB1dGVPcGVuQm9vbGVhbihwYXRoMSwgcGF0aDIsIG9wZXJhdGlvbik7XG5cdFx0dmFyIF9wYXRoMSA9IHByZXBhcmVQYXRoKHBhdGgxLCB0cnVlKSxcblx0XHRcdF9wYXRoMiA9IHBhdGgyICYmIHBhdGgxICE9PSBwYXRoMiAmJiBwcmVwYXJlUGF0aChwYXRoMiwgdHJ1ZSk7XG5cdFx0aWYgKF9wYXRoMiAmJiAvXihzdWJ0cmFjdHxleGNsdWRlKSQvLnRlc3Qob3BlcmF0aW9uKVxuXHRcdFx0XHReIChfcGF0aDIuaXNDbG9ja3dpc2UoKSAhPT0gX3BhdGgxLmlzQ2xvY2t3aXNlKCkpKVxuXHRcdFx0X3BhdGgyLnJldmVyc2UoKTtcblx0XHR2YXIgaW50ZXJzZWN0aW9ucyA9IEN1cnZlTG9jYXRpb24uZXhwYW5kKFxuXHRcdFx0X3BhdGgxLmdldEludGVyc2VjdGlvbnMoX3BhdGgyLCBmdW5jdGlvbihpbnRlcikge1xuXHRcdFx0XHRyZXR1cm4gX3BhdGgyICYmIGludGVyLmlzT3ZlcmxhcCgpIHx8IGludGVyLmlzQ3Jvc3NpbmcoKTtcblx0XHRcdH0pXG5cdFx0KTtcblx0XHRkaXZpZGVMb2NhdGlvbnMoaW50ZXJzZWN0aW9ucyk7XG5cblx0XHR2YXIgc2VnbWVudHMgPSBbXSxcblx0XHRcdG1vbm9DdXJ2ZXMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGNvbGxlY3QocGF0aHMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGF0aHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwYXRoID0gcGF0aHNbaV07XG5cdFx0XHRcdHNlZ21lbnRzLnB1c2guYXBwbHkoc2VnbWVudHMsIHBhdGguX3NlZ21lbnRzKTtcblx0XHRcdFx0bW9ub0N1cnZlcy5wdXNoLmFwcGx5KG1vbm9DdXJ2ZXMsIHBhdGguX2dldE1vbm9DdXJ2ZXMoKSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Y29sbGVjdChfcGF0aDEuX2NoaWxkcmVuIHx8IFtfcGF0aDFdKTtcblx0XHRpZiAoX3BhdGgyKVxuXHRcdFx0Y29sbGVjdChfcGF0aDIuX2NoaWxkcmVuIHx8IFtfcGF0aDJdKTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGludGVyc2VjdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRwcm9wYWdhdGVXaW5kaW5nKGludGVyc2VjdGlvbnNbaV0uX3NlZ21lbnQsIF9wYXRoMSwgX3BhdGgyLFxuXHRcdFx0XHRcdG1vbm9DdXJ2ZXMsIG9wZXJhdGlvbik7XG5cdFx0fVxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuXHRcdFx0aWYgKHNlZ21lbnQuX3dpbmRpbmcgPT0gbnVsbCkge1xuXHRcdFx0XHRwcm9wYWdhdGVXaW5kaW5nKHNlZ21lbnQsIF9wYXRoMSwgX3BhdGgyLCBtb25vQ3VydmVzLFxuXHRcdFx0XHRcdFx0b3BlcmF0aW9uKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGZpbmlzaEJvb2xlYW4oQ29tcG91bmRQYXRoLCB0cmFjZVBhdGhzKHNlZ21lbnRzLCBvcGVyYXRpb24pLFxuXHRcdFx0XHRwYXRoMSwgcGF0aDIsIHRydWUpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29tcHV0ZU9wZW5Cb29sZWFuKHBhdGgxLCBwYXRoMiwgb3BlcmF0aW9uKSB7XG5cdFx0aWYgKCFwYXRoMiB8fCAhcGF0aDIuX2NoaWxkcmVuICYmICFwYXRoMi5fY2xvc2VkXG5cdFx0XHRcdHx8ICEvXihzdWJ0cmFjdHxpbnRlcnNlY3QpJC8udGVzdChvcGVyYXRpb24pKVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0dmFyIF9wYXRoMSA9IHByZXBhcmVQYXRoKHBhdGgxLCBmYWxzZSksXG5cdFx0XHRfcGF0aDIgPSBwcmVwYXJlUGF0aChwYXRoMiwgZmFsc2UpLFxuXHRcdFx0aW50ZXJzZWN0aW9ucyA9IF9wYXRoMS5nZXRJbnRlcnNlY3Rpb25zKF9wYXRoMiwgZnVuY3Rpb24oaW50ZXIpIHtcblx0XHRcdFx0cmV0dXJuIGludGVyLmlzT3ZlcmxhcCgpIHx8IGludGVyLmlzQ3Jvc3NpbmcoKTtcblx0XHRcdH0pLFxuXHRcdFx0c3ViID0gb3BlcmF0aW9uID09PSAnc3VidHJhY3QnLFxuXHRcdFx0cGF0aHMgPSBbXTtcblxuXHRcdGZ1bmN0aW9uIGFkZFBhdGgocGF0aCkge1xuXHRcdFx0aWYgKF9wYXRoMi5jb250YWlucyhwYXRoLmdldFBvaW50QXQocGF0aC5nZXRMZW5ndGgoKSAvIDIpKSBeIHN1Yikge1xuXHRcdFx0XHRwYXRocy51bnNoaWZ0KHBhdGgpO1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gaW50ZXJzZWN0aW9ucy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuXHRcdFx0dmFyIHBhdGggPSBpbnRlcnNlY3Rpb25zW2ldLnNwbGl0KCk7XG5cdFx0XHRpZiAocGF0aCkge1xuXHRcdFx0XHRpZiAoYWRkUGF0aChwYXRoKSlcblx0XHRcdFx0XHRwYXRoLmdldEZpcnN0U2VnbWVudCgpLnNldEhhbmRsZUluKDAsIDApO1xuXHRcdFx0XHRfcGF0aDEuZ2V0TGFzdFNlZ21lbnQoKS5zZXRIYW5kbGVPdXQoMCwgMCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGFkZFBhdGgoX3BhdGgxKTtcblx0XHRyZXR1cm4gZmluaXNoQm9vbGVhbihHcm91cCwgcGF0aHMsIHBhdGgxLCBwYXRoMik7XG5cdH1cblxuXHRmdW5jdGlvbiBsaW5rSW50ZXJzZWN0aW9ucyhmcm9tLCB0bykge1xuXHRcdHZhciBwcmV2ID0gZnJvbTtcblx0XHR3aGlsZSAocHJldikge1xuXHRcdFx0aWYgKHByZXYgPT09IHRvKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRwcmV2ID0gcHJldi5fcHJldjtcblx0XHR9XG5cdFx0d2hpbGUgKGZyb20uX25leHQgJiYgZnJvbS5fbmV4dCAhPT0gdG8pXG5cdFx0XHRmcm9tID0gZnJvbS5fbmV4dDtcblx0XHRpZiAoIWZyb20uX25leHQpIHtcblx0XHRcdHdoaWxlICh0by5fcHJldilcblx0XHRcdFx0dG8gPSB0by5fcHJldjtcblx0XHRcdGZyb20uX25leHQgPSB0bztcblx0XHRcdHRvLl9wcmV2ID0gZnJvbTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBkaXZpZGVMb2NhdGlvbnMobG9jYXRpb25zKSB7XG5cdFx0dmFyIHRNaW4gPSA0ZS03LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluLFxuXHRcdFx0bm9IYW5kbGVzID0gZmFsc2UsXG5cdFx0XHRjbGVhclNlZ21lbnRzID0gW10sXG5cdFx0XHRwcmV2Q3VydmUsXG5cdFx0XHRwcmV2VDtcblxuXHRcdGZvciAodmFyIGkgPSBsb2NhdGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdHZhciBsb2MgPSBsb2NhdGlvbnNbaV0sXG5cdFx0XHRcdGN1cnZlID0gbG9jLl9jdXJ2ZSxcblx0XHRcdFx0dCA9IGxvYy5fcGFyYW1ldGVyLFxuXHRcdFx0XHRvcmlnVCA9IHQ7XG5cdFx0XHRpZiAoY3VydmUgIT09IHByZXZDdXJ2ZSkge1xuXHRcdFx0XHRub0hhbmRsZXMgPSAhY3VydmUuaGFzSGFuZGxlcygpO1xuXHRcdFx0fSBlbHNlIGlmIChwcmV2VCA+IDApIHtcblx0XHRcdFx0dCAvPSBwcmV2VDtcblx0XHRcdH1cblx0XHRcdHZhciBzZWdtZW50O1xuXHRcdFx0aWYgKHQgPCB0TWluKSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDE7XG5cdFx0XHR9IGVsc2UgaWYgKHQgPiB0TWF4KSB7XG5cdFx0XHRcdHNlZ21lbnQgPSBjdXJ2ZS5fc2VnbWVudDI7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRzZWdtZW50ID0gY3VydmUuZGl2aWRlKHQsIHRydWUsIHRydWUpLl9zZWdtZW50MTtcblx0XHRcdFx0aWYgKG5vSGFuZGxlcylcblx0XHRcdFx0XHRjbGVhclNlZ21lbnRzLnB1c2goc2VnbWVudCk7XG5cdFx0XHR9XG5cdFx0XHRsb2MuX3NldFNlZ21lbnQoc2VnbWVudCk7XG5cdFx0XHR2YXIgaW50ZXIgPSBzZWdtZW50Ll9pbnRlcnNlY3Rpb24sXG5cdFx0XHRcdGRlc3QgPSBsb2MuX2ludGVyc2VjdGlvbjtcblx0XHRcdGlmIChpbnRlcikge1xuXHRcdFx0XHRsaW5rSW50ZXJzZWN0aW9ucyhpbnRlciwgZGVzdCk7XG5cdFx0XHRcdHZhciBvdGhlciA9IGludGVyO1xuXHRcdFx0XHR3aGlsZSAob3RoZXIpIHtcblx0XHRcdFx0XHRsaW5rSW50ZXJzZWN0aW9ucyhvdGhlci5faW50ZXJzZWN0aW9uLCBpbnRlcik7XG5cdFx0XHRcdFx0b3RoZXIgPSBvdGhlci5fbmV4dDtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0c2VnbWVudC5faW50ZXJzZWN0aW9uID0gZGVzdDtcblx0XHRcdH1cblx0XHRcdHByZXZDdXJ2ZSA9IGN1cnZlO1xuXHRcdFx0cHJldlQgPSBvcmlnVDtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjbGVhclNlZ21lbnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0Y2xlYXJTZWdtZW50c1tpXS5jbGVhckhhbmRsZXMoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRXaW5kaW5nKHBvaW50LCBjdXJ2ZXMsIGhvcml6b250YWwsIHRlc3RDb250YWlucykge1xuXHRcdHZhciBlcHNpbG9uID0gMmUtNyxcblx0XHRcdHRNaW4gPSA0ZS03LFxuXHRcdFx0dE1heCA9IDEgLSB0TWluLFxuXHRcdFx0cHggPSBwb2ludC54LFxuXHRcdFx0cHkgPSBwb2ludC55LFxuXHRcdFx0d2luZExlZnQgPSAwLFxuXHRcdFx0d2luZFJpZ2h0ID0gMCxcblx0XHRcdHJvb3RzID0gW10sXG5cdFx0XHRhYnMgPSBNYXRoLmFicztcblx0XHRpZiAoaG9yaXpvbnRhbCkge1xuXHRcdFx0dmFyIHlUb3AgPSAtSW5maW5pdHksXG5cdFx0XHRcdHlCb3R0b20gPSBJbmZpbml0eSxcblx0XHRcdFx0eUJlZm9yZSA9IHB5IC0gZXBzaWxvbixcblx0XHRcdFx0eUFmdGVyID0gcHkgKyBlcHNpbG9uO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2YWx1ZXMgPSBjdXJ2ZXNbaV0udmFsdWVzO1xuXHRcdFx0XHRpZiAoQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDAsIHB4LCByb290cywgMCwgMSkgPiAwKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaiA9IHJvb3RzLmxlbmd0aCAtIDE7IGogPj0gMDsgai0tKSB7XG5cdFx0XHRcdFx0XHR2YXIgeSA9IEN1cnZlLmdldFBvaW50KHZhbHVlcywgcm9vdHNbal0pLnk7XG5cdFx0XHRcdFx0XHRpZiAoeSA8IHlCZWZvcmUgJiYgeSA+IHlUb3ApIHtcblx0XHRcdFx0XHRcdFx0eVRvcCA9IHk7XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHkgPiB5QWZ0ZXIgJiYgeSA8IHlCb3R0b20pIHtcblx0XHRcdFx0XHRcdFx0eUJvdHRvbSA9IHk7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHR5VG9wID0gKHlUb3AgKyBweSkgLyAyO1xuXHRcdFx0eUJvdHRvbSA9ICh5Qm90dG9tICsgcHkpIC8gMjtcblx0XHRcdGlmICh5VG9wID4gLUluZmluaXR5KVxuXHRcdFx0XHR3aW5kTGVmdCA9IGdldFdpbmRpbmcobmV3IFBvaW50KHB4LCB5VG9wKSwgY3VydmVzLCBmYWxzZSxcblx0XHRcdFx0XHRcdHRlc3RDb250YWlucyk7XG5cdFx0XHRpZiAoeUJvdHRvbSA8IEluZmluaXR5KVxuXHRcdFx0XHR3aW5kUmlnaHQgPSBnZXRXaW5kaW5nKG5ldyBQb2ludChweCwgeUJvdHRvbSksIGN1cnZlcywgZmFsc2UsXG5cdFx0XHRcdFx0XHR0ZXN0Q29udGFpbnMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgeEJlZm9yZSA9IHB4IC0gZXBzaWxvbixcblx0XHRcdFx0eEFmdGVyID0gcHggKyBlcHNpbG9uO1xuXHRcdFx0dmFyIHN0YXJ0Q291bnRlZCA9IGZhbHNlLFxuXHRcdFx0XHRwcmV2Q3VydmUsXG5cdFx0XHRcdHByZXZUO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjdXJ2ZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjdXJ2ZSA9IGN1cnZlc1tpXSxcblx0XHRcdFx0XHR2YWx1ZXMgPSBjdXJ2ZS52YWx1ZXMsXG5cdFx0XHRcdFx0d2luZGluZyA9IGN1cnZlLndpbmRpbmc7XG5cdFx0XHRcdGlmICh3aW5kaW5nICYmICh3aW5kaW5nID09PSAxXG5cdFx0XHRcdFx0XHQmJiBweSA+PSB2YWx1ZXNbMV0gJiYgcHkgPD0gdmFsdWVzWzddXG5cdFx0XHRcdFx0XHR8fCBweSA+PSB2YWx1ZXNbN10gJiYgcHkgPD0gdmFsdWVzWzFdKVxuXHRcdFx0XHRcdCYmIEN1cnZlLnNvbHZlQ3ViaWModmFsdWVzLCAxLCBweSwgcm9vdHMsIDAsIDEpID09PSAxKSB7XG5cdFx0XHRcdFx0dmFyIHQgPSByb290c1swXTtcblx0XHRcdFx0XHRpZiAoIShcblx0XHRcdFx0XHRcdHQgPiB0TWF4ICYmIHN0YXJ0Q291bnRlZCAmJiBjdXJ2ZS5uZXh0ICE9PSBjdXJ2ZXNbaSArIDFdXG5cdFx0XHRcdFx0XHR8fCB0IDwgdE1pbiAmJiBwcmV2VCA+IHRNYXhcblx0XHRcdFx0XHRcdFx0JiYgY3VydmUucHJldmlvdXMgPT09IHByZXZDdXJ2ZSkpIHtcblx0XHRcdFx0XHRcdHZhciB4ID0gQ3VydmUuZ2V0UG9pbnQodmFsdWVzLCB0KS54LFxuXHRcdFx0XHRcdFx0XHRzbG9wZSA9IEN1cnZlLmdldFRhbmdlbnQodmFsdWVzLCB0KS55LFxuXHRcdFx0XHRcdFx0XHRjb3VudGVkID0gZmFsc2U7XG5cdFx0XHRcdFx0XHRpZiAoTnVtZXJpY2FsLmlzWmVybyhzbG9wZSkgJiYgIUN1cnZlLmlzU3RyYWlnaHQodmFsdWVzKVxuXHRcdFx0XHRcdFx0XHRcdHx8IHQgPCB0TWluICYmIHNsb3BlICogQ3VydmUuZ2V0VGFuZ2VudChcblx0XHRcdFx0XHRcdFx0XHRcdGN1cnZlLnByZXZpb3VzLnZhbHVlcywgMSkueSA8IDBcblx0XHRcdFx0XHRcdFx0XHR8fCB0ID4gdE1heCAmJiBzbG9wZSAqIEN1cnZlLmdldFRhbmdlbnQoXG5cdFx0XHRcdFx0XHRcdFx0XHRjdXJ2ZS5uZXh0LnZhbHVlcywgMCkueSA8IDApIHtcblx0XHRcdFx0XHRcdFx0aWYgKHRlc3RDb250YWlucyAmJiB4ID49IHhCZWZvcmUgJiYgeCA8PSB4QWZ0ZXIpIHtcblx0XHRcdFx0XHRcdFx0XHQrK3dpbmRMZWZ0O1xuXHRcdFx0XHRcdFx0XHRcdCsrd2luZFJpZ2h0O1xuXHRcdFx0XHRcdFx0XHRcdGNvdW50ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHR9IGVsc2UgaWYgKHggPD0geEJlZm9yZSkge1xuXHRcdFx0XHRcdFx0XHR3aW5kTGVmdCArPSB3aW5kaW5nO1xuXHRcdFx0XHRcdFx0XHRjb3VudGVkID0gdHJ1ZTtcblx0XHRcdFx0XHRcdH0gZWxzZSBpZiAoeCA+PSB4QWZ0ZXIpIHtcblx0XHRcdFx0XHRcdFx0d2luZFJpZ2h0ICs9IHdpbmRpbmc7XG5cdFx0XHRcdFx0XHRcdGNvdW50ZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0aWYgKGN1cnZlLnByZXZpb3VzICE9PSBjdXJ2ZXNbaSAtIDFdKVxuXHRcdFx0XHRcdFx0XHRzdGFydENvdW50ZWQgPSB0IDwgdE1pbiAmJiBjb3VudGVkO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRwcmV2Q3VydmUgPSBjdXJ2ZTtcblx0XHRcdFx0XHRwcmV2VCA9IHQ7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIE1hdGgubWF4KGFicyh3aW5kTGVmdCksIGFicyh3aW5kUmlnaHQpKTtcblx0fVxuXG5cdGZ1bmN0aW9uIHByb3BhZ2F0ZVdpbmRpbmcoc2VnbWVudCwgcGF0aDEsIHBhdGgyLCBtb25vQ3VydmVzLCBvcGVyYXRpb24pIHtcblx0XHR2YXIgZXBzaWxvbiA9IDJlLTcsXG5cdFx0XHRjaGFpbiA9IFtdLFxuXHRcdFx0c3RhcnQgPSBzZWdtZW50LFxuXHRcdFx0dG90YWxMZW5ndGggPSAwLFxuXHRcdFx0d2luZGluZ1N1bSA9IDA7XG5cdFx0ZG8ge1xuXHRcdFx0dmFyIGN1cnZlID0gc2VnbWVudC5nZXRDdXJ2ZSgpLFxuXHRcdFx0XHRsZW5ndGggPSBjdXJ2ZS5nZXRMZW5ndGgoKTtcblx0XHRcdGNoYWluLnB1c2goeyBzZWdtZW50OiBzZWdtZW50LCBjdXJ2ZTogY3VydmUsIGxlbmd0aDogbGVuZ3RoIH0pO1xuXHRcdFx0dG90YWxMZW5ndGggKz0gbGVuZ3RoO1xuXHRcdFx0c2VnbWVudCA9IHNlZ21lbnQuZ2V0TmV4dCgpO1xuXHRcdH0gd2hpbGUgKHNlZ21lbnQgJiYgIXNlZ21lbnQuX2ludGVyc2VjdGlvbiAmJiBzZWdtZW50ICE9PSBzdGFydCk7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdHZhciBsZW5ndGggPSB0b3RhbExlbmd0aCAqIChpICsgMSkgLyA0O1xuXHRcdFx0Zm9yICh2YXIgayA9IDAsIG0gPSBjaGFpbi5sZW5ndGg7IGsgPCBtOyBrKyspIHtcblx0XHRcdFx0dmFyIG5vZGUgPSBjaGFpbltrXSxcblx0XHRcdFx0XHRjdXJ2ZUxlbmd0aCA9IG5vZGUubGVuZ3RoO1xuXHRcdFx0XHRpZiAobGVuZ3RoIDw9IGN1cnZlTGVuZ3RoKSB7XG5cdFx0XHRcdFx0aWYgKGxlbmd0aCA8IGVwc2lsb24gfHwgY3VydmVMZW5ndGggLSBsZW5ndGggPCBlcHNpbG9uKVxuXHRcdFx0XHRcdFx0bGVuZ3RoID0gY3VydmVMZW5ndGggLyAyO1xuXHRcdFx0XHRcdHZhciBjdXJ2ZSA9IG5vZGUuY3VydmUsXG5cdFx0XHRcdFx0XHRwYXRoID0gY3VydmUuX3BhdGgsXG5cdFx0XHRcdFx0XHRwYXJlbnQgPSBwYXRoLl9wYXJlbnQsXG5cdFx0XHRcdFx0XHRwdCA9IGN1cnZlLmdldFBvaW50QXQobGVuZ3RoKSxcblx0XHRcdFx0XHRcdGhvciA9IGN1cnZlLmlzSG9yaXpvbnRhbCgpO1xuXHRcdFx0XHRcdGlmIChwYXJlbnQgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpXG5cdFx0XHRcdFx0XHRwYXRoID0gcGFyZW50O1xuXHRcdFx0XHRcdHdpbmRpbmdTdW0gKz0gb3BlcmF0aW9uID09PSAnc3VidHJhY3QnICYmIHBhdGgyXG5cdFx0XHRcdFx0XHQmJiAocGF0aCA9PT0gcGF0aDEgJiYgcGF0aDIuX2dldFdpbmRpbmcocHQsIGhvcilcblx0XHRcdFx0XHRcdHx8IHBhdGggPT09IHBhdGgyICYmICFwYXRoMS5fZ2V0V2luZGluZyhwdCwgaG9yKSlcblx0XHRcdFx0XHRcdD8gMFxuXHRcdFx0XHRcdFx0OiBnZXRXaW5kaW5nKHB0LCBtb25vQ3VydmVzLCBob3IpO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxlbmd0aCAtPSBjdXJ2ZUxlbmd0aDtcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIHdpbmRpbmcgPSBNYXRoLnJvdW5kKHdpbmRpbmdTdW0gLyAzKTtcblx0XHRmb3IgKHZhciBqID0gY2hhaW4ubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG5cdFx0XHRjaGFpbltqXS5zZWdtZW50Ll93aW5kaW5nID0gd2luZGluZztcblx0fVxuXG5cdGZ1bmN0aW9uIHRyYWNlUGF0aHMoc2VnbWVudHMsIG9wZXJhdGlvbikge1xuXHRcdHZhciBwYXRocyA9IFtdLFxuXHRcdFx0c3RhcnQsXG5cdFx0XHRvdGhlclN0YXJ0LFxuXHRcdFx0b3BlcmF0b3IgPSBvcGVyYXRvcnNbb3BlcmF0aW9uXSxcblx0XHRcdG92ZXJsYXBXaW5kaW5nID0ge1xuXHRcdFx0XHR1bml0ZTogeyAxOiAyIH0sXG5cdFx0XHRcdGludGVyc2VjdDogeyAyOiAxIH1cblx0XHRcdH1bb3BlcmF0aW9uXTtcblxuXHRcdGZ1bmN0aW9uIGlzVmFsaWQoc2VnLCBhZGp1c3RlZCkge1xuXHRcdFx0aWYgKHNlZy5fdmlzaXRlZClcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0aWYgKCFvcGVyYXRvcilcblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0XHR2YXIgd2luZGluZyA9IHNlZy5fd2luZGluZyxcblx0XHRcdFx0aW50ZXIgPSBzZWcuX2ludGVyc2VjdGlvbjtcblx0XHRcdGlmIChpbnRlciAmJiBhZGp1c3RlZCAmJiBvdmVybGFwV2luZGluZyAmJiBpbnRlci5pc092ZXJsYXAoKSlcblx0XHRcdFx0d2luZGluZyA9IG92ZXJsYXBXaW5kaW5nW3dpbmRpbmddIHx8IHdpbmRpbmc7XG5cdFx0XHRyZXR1cm4gb3BlcmF0b3Iod2luZGluZyk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gaXNTdGFydChzZWcpIHtcblx0XHRcdHJldHVybiBzZWcgPT09IHN0YXJ0IHx8IHNlZyA9PT0gb3RoZXJTdGFydDtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBmaW5kQmVzdEludGVyc2VjdGlvbihpbnRlciwgc3RyaWN0KSB7XG5cdFx0XHRpZiAoIWludGVyLl9uZXh0KVxuXHRcdFx0XHRyZXR1cm4gaW50ZXI7XG5cdFx0XHR3aGlsZSAoaW50ZXIpIHtcblx0XHRcdFx0dmFyIHNlZyA9IGludGVyLl9zZWdtZW50LFxuXHRcdFx0XHRcdG5leHRTZWcgPSBzZWcuZ2V0TmV4dCgpLFxuXHRcdFx0XHRcdG5leHRJbnRlciA9IG5leHRTZWcuX2ludGVyc2VjdGlvbjtcblx0XHRcdFx0aWYgKGlzU3RhcnQobmV4dFNlZylcblx0XHRcdFx0XHR8fCAhc2VnLl92aXNpdGVkICYmICFuZXh0U2VnLl92aXNpdGVkXG5cdFx0XHRcdFx0JiYgKCFvcGVyYXRvclxuXHRcdFx0XHRcdFx0fHwgKCFzdHJpY3QgfHwgaXNWYWxpZChzZWcpKVxuXHRcdFx0XHRcdFx0JiYgKCEoc3RyaWN0ICYmIG5leHRJbnRlciAmJiBuZXh0SW50ZXIuaXNPdmVybGFwKCkpXG5cdFx0XHRcdFx0XHRcdCYmIGlzVmFsaWQobmV4dFNlZylcblx0XHRcdFx0XHRcdFx0fHwgIXN0cmljdCAmJiBuZXh0SW50ZXJcblx0XHRcdFx0XHRcdFx0JiYgaXNWYWxpZChuZXh0SW50ZXIuX3NlZ21lbnQpKVxuXHRcdFx0XHRcdCkpXG5cdFx0XHRcdFx0cmV0dXJuIGludGVyO1xuXHRcdFx0XHRpbnRlciA9IGludGVyLl9uZXh0O1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZmluZFN0YXJ0U2VnbWVudChpbnRlciwgbmV4dCkge1xuXHRcdFx0d2hpbGUgKGludGVyKSB7XG5cdFx0XHRcdHZhciBzZWcgPSBpbnRlci5fc2VnbWVudDtcblx0XHRcdFx0aWYgKGlzU3RhcnQoc2VnKSlcblx0XHRcdFx0XHRyZXR1cm4gc2VnO1xuXHRcdFx0XHRpbnRlciA9IGludGVyW25leHQgPyAnX25leHQnIDogJ19wcmV2J107XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBzZWcgPSBzZWdtZW50c1tpXSxcblx0XHRcdFx0cGF0aCA9IG51bGwsXG5cdFx0XHRcdGZpbmlzaGVkID0gZmFsc2U7XG5cdFx0XHRpZiAoIWlzVmFsaWQoc2VnLCB0cnVlKSlcblx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRzdGFydCA9IG90aGVyU3RhcnQgPSBudWxsO1xuXHRcdFx0d2hpbGUgKCFmaW5pc2hlZCkge1xuXHRcdFx0XHR2YXIgaW50ZXIgPSBzZWcuX2ludGVyc2VjdGlvbixcblx0XHRcdFx0XHRoYW5kbGVJbiA9IHBhdGggJiYgc2VnLl9oYW5kbGVJbjtcblx0XHRcdFx0aW50ZXIgPSBpbnRlciAmJiAoZmluZEJlc3RJbnRlcnNlY3Rpb24oaW50ZXIsIHRydWUpXG5cdFx0XHRcdFx0XHR8fCBmaW5kQmVzdEludGVyc2VjdGlvbihpbnRlciwgZmFsc2UpKSB8fCBpbnRlcjtcblx0XHRcdFx0dmFyIG90aGVyID0gaW50ZXIgJiYgaW50ZXIuX3NlZ21lbnQ7XG5cdFx0XHRcdGlmIChvdGhlciAmJiBpc1ZhbGlkKG90aGVyKSlcblx0XHRcdFx0XHRzZWcgPSBvdGhlcjtcblx0XHRcdFx0aWYgKHNlZy5fdmlzaXRlZCkge1xuXHRcdFx0XHRcdGZpbmlzaGVkID0gaXNTdGFydChzZWcpO1xuXHRcdFx0XHRcdGlmICghZmluaXNoZWQgJiYgaW50ZXIpIHtcblx0XHRcdFx0XHRcdHZhciBmb3VuZCA9IGZpbmRTdGFydFNlZ21lbnQoaW50ZXIsIHRydWUpXG5cdFx0XHRcdFx0XHRcdHx8IGZpbmRTdGFydFNlZ21lbnQoaW50ZXIsIGZhbHNlKTtcblx0XHRcdFx0XHRcdGlmIChmb3VuZCkge1xuXHRcdFx0XHRcdFx0XHRzZWcgPSBmb3VuZDtcblx0XHRcdFx0XHRcdFx0ZmluaXNoZWQgPSB0cnVlO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAoIXBhdGgpIHtcblx0XHRcdFx0XHRwYXRoID0gbmV3IFBhdGgoSXRlbS5OT19JTlNFUlQpO1xuXHRcdFx0XHRcdHN0YXJ0ID0gc2VnO1xuXHRcdFx0XHRcdG90aGVyU3RhcnQgPSBvdGhlcjtcblx0XHRcdFx0fVxuXHRcdFx0XHRwYXRoLmFkZChuZXcgU2VnbWVudChzZWcuX3BvaW50LCBoYW5kbGVJbiwgc2VnLl9oYW5kbGVPdXQpKTtcblx0XHRcdFx0c2VnLl92aXNpdGVkID0gdHJ1ZTtcblx0XHRcdFx0c2VnID0gc2VnLmdldE5leHQoKTtcblx0XHRcdFx0ZmluaXNoZWQgPSBpc1N0YXJ0KHNlZyk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoZmluaXNoZWQpIHtcblx0XHRcdFx0cGF0aC5maXJzdFNlZ21lbnQuc2V0SGFuZGxlSW4oc2VnLl9oYW5kbGVJbik7XG5cdFx0XHRcdHBhdGguc2V0Q2xvc2VkKHRydWUpO1xuXHRcdFx0fSBlbHNlIGlmIChwYXRoKSB7XG5cdFx0XHRcdGNvbnNvbGUuZXJyb3IoJ0Jvb2xlYW4gb3BlcmF0aW9uIHJlc3VsdGVkIGluIG9wZW4gcGF0aCcsXG5cdFx0XHRcdFx0XHQnc2VnbWVudHMgPScsIHBhdGguX3NlZ21lbnRzLmxlbmd0aCxcblx0XHRcdFx0XHRcdCdsZW5ndGggPScsIHBhdGguZ2V0TGVuZ3RoKCkpO1xuXHRcdFx0XHRwYXRoID0gbnVsbDtcblx0XHRcdH1cblx0XHRcdGlmIChwYXRoICYmIChwYXRoLl9zZWdtZW50cy5sZW5ndGggPiA4XG5cdFx0XHRcdFx0fHwgIU51bWVyaWNhbC5pc1plcm8ocGF0aC5nZXRBcmVhKCkpKSkge1xuXHRcdFx0XHRwYXRocy5wdXNoKHBhdGgpO1xuXHRcdFx0XHRwYXRoID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHBhdGhzO1xuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRfZ2V0V2luZGluZzogZnVuY3Rpb24ocG9pbnQsIGhvcml6b250YWwsIHRlc3RDb250YWlucykge1xuXHRcdFx0cmV0dXJuIGdldFdpbmRpbmcocG9pbnQsIHRoaXMuX2dldE1vbm9DdXJ2ZXMoKSxcblx0XHRcdFx0XHRob3Jpem9udGFsLCB0ZXN0Q29udGFpbnMpO1xuXHRcdH0sXG5cblx0XHR1bml0ZTogZnVuY3Rpb24ocGF0aCkge1xuXHRcdFx0cmV0dXJuIGNvbXB1dGVCb29sZWFuKHRoaXMsIHBhdGgsICd1bml0ZScpO1xuXHRcdH0sXG5cblx0XHRpbnRlcnNlY3Q6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCAnaW50ZXJzZWN0Jyk7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbihwYXRoKSB7XG5cdFx0XHRyZXR1cm4gY29tcHV0ZUJvb2xlYW4odGhpcywgcGF0aCwgJ3N1YnRyYWN0Jyk7XG5cdFx0fSxcblxuXHRcdGV4Y2x1ZGU6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBjb21wdXRlQm9vbGVhbih0aGlzLCBwYXRoLCAnZXhjbHVkZScpO1xuXHRcdH0sXG5cblx0XHRkaXZpZGU6IGZ1bmN0aW9uKHBhdGgpIHtcblx0XHRcdHJldHVybiBmaW5pc2hCb29sZWFuKEdyb3VwLFxuXHRcdFx0XHRcdFt0aGlzLnN1YnRyYWN0KHBhdGgpLCB0aGlzLmludGVyc2VjdChwYXRoKV0sXG5cdFx0XHRcdFx0dGhpcywgcGF0aCwgdHJ1ZSk7XG5cdFx0fSxcblxuXHRcdHJlc29sdmVDcm9zc2luZ3M6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIGNyb3NzaW5ncyA9IHRoaXMuZ2V0Q3Jvc3NpbmdzKCk7XG5cdFx0XHRpZiAoIWNyb3NzaW5ncy5sZW5ndGgpXG5cdFx0XHRcdHJldHVybiB0aGlzO1xuXHRcdFx0ZGl2aWRlTG9jYXRpb25zKEN1cnZlTG9jYXRpb24uZXhwYW5kKGNyb3NzaW5ncykpO1xuXHRcdFx0dmFyIHBhdGhzID0gdGhpcy5fY2hpbGRyZW4gfHwgW3RoaXNdLFxuXHRcdFx0XHRzZWdtZW50cyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXRocy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0c2VnbWVudHMucHVzaC5hcHBseShzZWdtZW50cywgcGF0aHNbaV0uX3NlZ21lbnRzKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBmaW5pc2hCb29sZWFuKENvbXBvdW5kUGF0aCwgdHJhY2VQYXRocyhzZWdtZW50cyksXG5cdFx0XHRcdFx0dGhpcywgbnVsbCwgZmFsc2UpO1xuXHRcdH1cblx0fTtcbn0pO1xuXG5QYXRoLmluamVjdCh7XG5cdF9nZXRNb25vQ3VydmVzOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgbW9ub0N1cnZlcyA9IHRoaXMuX21vbm9DdXJ2ZXMsXG5cdFx0XHRwcmV2Q3VydmU7XG5cblx0XHRmdW5jdGlvbiBpbnNlcnRDdXJ2ZSh2KSB7XG5cdFx0XHR2YXIgeTAgPSB2WzFdLFxuXHRcdFx0XHR5MSA9IHZbN10sXG5cdFx0XHRcdGN1cnZlID0ge1xuXHRcdFx0XHRcdHZhbHVlczogdixcblx0XHRcdFx0XHR3aW5kaW5nOiB5MCA9PT0geTFcblx0XHRcdFx0XHRcdD8gMFxuXHRcdFx0XHRcdFx0OiB5MCA+IHkxXG5cdFx0XHRcdFx0XHRcdD8gLTFcblx0XHRcdFx0XHRcdFx0OiAxLFxuXHRcdFx0XHRcdHByZXZpb3VzOiBwcmV2Q3VydmUsXG5cdFx0XHRcdFx0bmV4dDogbnVsbFxuXHRcdFx0XHR9O1xuXHRcdFx0aWYgKHByZXZDdXJ2ZSlcblx0XHRcdFx0cHJldkN1cnZlLm5leHQgPSBjdXJ2ZTtcblx0XHRcdG1vbm9DdXJ2ZXMucHVzaChjdXJ2ZSk7XG5cdFx0XHRwcmV2Q3VydmUgPSBjdXJ2ZTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBoYW5kbGVDdXJ2ZSh2KSB7XG5cdFx0XHRpZiAoQ3VydmUuZ2V0TGVuZ3RoKHYpID09PSAwKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR2YXIgeTAgPSB2WzFdLFxuXHRcdFx0XHR5MSA9IHZbM10sXG5cdFx0XHRcdHkyID0gdls1XSxcblx0XHRcdFx0eTMgPSB2WzddO1xuXHRcdFx0aWYgKEN1cnZlLmlzU3RyYWlnaHQodikpIHtcblx0XHRcdFx0aW5zZXJ0Q3VydmUodik7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgYSA9IDMgKiAoeTEgLSB5MikgLSB5MCArIHkzLFxuXHRcdFx0XHRcdGIgPSAyICogKHkwICsgeTIpIC0gNCAqIHkxLFxuXHRcdFx0XHRcdGMgPSB5MSAtIHkwLFxuXHRcdFx0XHRcdHRNaW4gPSA0ZS03LFxuXHRcdFx0XHRcdHRNYXggPSAxIC0gdE1pbixcblx0XHRcdFx0XHRyb290cyA9IFtdLFxuXHRcdFx0XHRcdG4gPSBOdW1lcmljYWwuc29sdmVRdWFkcmF0aWMoYSwgYiwgYywgcm9vdHMsIHRNaW4sIHRNYXgpO1xuXHRcdFx0XHRpZiAobiA9PT0gMCkge1xuXHRcdFx0XHRcdGluc2VydEN1cnZlKHYpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHJvb3RzLnNvcnQoKTtcblx0XHRcdFx0XHR2YXIgdCA9IHJvb3RzWzBdLFxuXHRcdFx0XHRcdFx0cGFydHMgPSBDdXJ2ZS5zdWJkaXZpZGUodiwgdCk7XG5cdFx0XHRcdFx0aW5zZXJ0Q3VydmUocGFydHNbMF0pO1xuXHRcdFx0XHRcdGlmIChuID4gMSkge1xuXHRcdFx0XHRcdFx0dCA9IChyb290c1sxXSAtIHQpIC8gKDEgLSB0KTtcblx0XHRcdFx0XHRcdHBhcnRzID0gQ3VydmUuc3ViZGl2aWRlKHBhcnRzWzFdLCB0KTtcblx0XHRcdFx0XHRcdGluc2VydEN1cnZlKHBhcnRzWzBdKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aW5zZXJ0Q3VydmUocGFydHNbMV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKCFtb25vQ3VydmVzKSB7XG5cdFx0XHRtb25vQ3VydmVzID0gdGhpcy5fbW9ub0N1cnZlcyA9IFtdO1xuXHRcdFx0dmFyIGN1cnZlcyA9IHRoaXMuZ2V0Q3VydmVzKCksXG5cdFx0XHRcdHNlZ21lbnRzID0gdGhpcy5fc2VnbWVudHM7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGN1cnZlcy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGhhbmRsZUN1cnZlKGN1cnZlc1tpXS5nZXRWYWx1ZXMoKSk7XG5cdFx0XHRpZiAoIXRoaXMuX2Nsb3NlZCAmJiBzZWdtZW50cy5sZW5ndGggPiAxKSB7XG5cdFx0XHRcdHZhciBwMSA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLl9wb2ludCxcblx0XHRcdFx0XHRwMiA9IHNlZ21lbnRzWzBdLl9wb2ludCxcblx0XHRcdFx0XHRwMXggPSBwMS5feCwgcDF5ID0gcDEuX3ksXG5cdFx0XHRcdFx0cDJ4ID0gcDIuX3gsIHAyeSA9IHAyLl95O1xuXHRcdFx0XHRoYW5kbGVDdXJ2ZShbcDF4LCBwMXksIHAxeCwgcDF5LCBwMngsIHAyeSwgcDJ4LCBwMnldKTtcblx0XHRcdH1cblx0XHRcdGlmIChtb25vQ3VydmVzLmxlbmd0aCA+IDApIHtcblx0XHRcdFx0dmFyIGZpcnN0ID0gbW9ub0N1cnZlc1swXSxcblx0XHRcdFx0XHRsYXN0ID0gbW9ub0N1cnZlc1ttb25vQ3VydmVzLmxlbmd0aCAtIDFdO1xuXHRcdFx0XHRmaXJzdC5wcmV2aW91cyA9IGxhc3Q7XG5cdFx0XHRcdGxhc3QubmV4dCA9IGZpcnN0O1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gbW9ub0N1cnZlcztcblx0fSxcblxuXHRnZXRJbnRlcmlvclBvaW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgYm91bmRzID0gdGhpcy5nZXRCb3VuZHMoKSxcblx0XHRcdHBvaW50ID0gYm91bmRzLmdldENlbnRlcih0cnVlKTtcblx0XHRpZiAoIXRoaXMuY29udGFpbnMocG9pbnQpKSB7XG5cdFx0XHR2YXIgY3VydmVzID0gdGhpcy5fZ2V0TW9ub0N1cnZlcygpLFxuXHRcdFx0XHRyb290cyA9IFtdLFxuXHRcdFx0XHR5ID0gcG9pbnQueSxcblx0XHRcdFx0eEludGVyY2VwdHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY3VydmVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWVzID0gY3VydmVzW2ldLnZhbHVlcztcblx0XHRcdFx0aWYgKChjdXJ2ZXNbaV0ud2luZGluZyA9PT0gMVxuXHRcdFx0XHRcdFx0JiYgeSA+PSB2YWx1ZXNbMV0gJiYgeSA8PSB2YWx1ZXNbN11cblx0XHRcdFx0XHRcdHx8IHkgPj0gdmFsdWVzWzddICYmIHkgPD0gdmFsdWVzWzFdKVxuXHRcdFx0XHRcdFx0JiYgQ3VydmUuc29sdmVDdWJpYyh2YWx1ZXMsIDEsIHksIHJvb3RzLCAwLCAxKSA+IDApIHtcblx0XHRcdFx0XHRmb3IgKHZhciBqID0gcm9vdHMubGVuZ3RoIC0gMTsgaiA+PSAwOyBqLS0pXG5cdFx0XHRcdFx0XHR4SW50ZXJjZXB0cy5wdXNoKEN1cnZlLmdldFBvaW50KHZhbHVlcywgcm9vdHNbal0pLngpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmICh4SW50ZXJjZXB0cy5sZW5ndGggPiAxKVxuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0fVxuXHRcdFx0cG9pbnQueCA9ICh4SW50ZXJjZXB0c1swXSArIHhJbnRlcmNlcHRzWzFdKSAvIDI7XG5cdFx0fVxuXHRcdHJldHVybiBwb2ludDtcblx0fSxcblxuXHRyZW9yaWVudDogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5zZXRDbG9ja3dpc2UodHJ1ZSk7XG5cdFx0cmV0dXJuIHRoaXM7XG5cdH1cbn0pO1xuXG5Db21wb3VuZFBhdGguaW5qZWN0KHtcblx0X2dldE1vbm9DdXJ2ZXM6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBjaGlsZHJlbiA9IHRoaXMuX2NoaWxkcmVuLFxuXHRcdFx0bW9ub0N1cnZlcyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0bW9ub0N1cnZlcy5wdXNoLmFwcGx5KG1vbm9DdXJ2ZXMsIGNoaWxkcmVuW2ldLl9nZXRNb25vQ3VydmVzKCkpO1xuXHRcdHJldHVybiBtb25vQ3VydmVzO1xuXHR9LFxuXG5cdHJlb3JpZW50OiBmdW5jdGlvbigpIHtcblx0XHR2YXIgY2hpbGRyZW4gPSB0aGlzLnJlbW92ZUNoaWxkcmVuKCkuc29ydChmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYi5nZXRCb3VuZHMoKS5nZXRBcmVhKCkgLSBhLmdldEJvdW5kcygpLmdldEFyZWEoKTtcblx0XHR9KTtcblx0XHRpZiAoY2hpbGRyZW4ubGVuZ3RoID4gMCkge1xuXHRcdFx0dGhpcy5hZGRDaGlsZHJlbihjaGlsZHJlbik7XG5cdFx0XHR2YXIgY2xvY2t3aXNlID0gY2hpbGRyZW5bMF0uaXNDbG9ja3dpc2UoKTtcblx0XHRcdGZvciAodmFyIGkgPSAxLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBwb2ludCA9IGNoaWxkcmVuW2ldLmdldEludGVyaW9yUG9pbnQoKSxcblx0XHRcdFx0XHRjb3VudGVycyA9IDA7XG5cdFx0XHRcdGZvciAodmFyIGogPSBpIC0gMTsgaiA+PSAwOyBqLS0pIHtcblx0XHRcdFx0XHRpZiAoY2hpbGRyZW5bal0uY29udGFpbnMocG9pbnQpKVxuXHRcdFx0XHRcdFx0Y291bnRlcnMrKztcblx0XHRcdFx0fVxuXHRcdFx0XHRjaGlsZHJlbltpXS5zZXRDbG9ja3dpc2UoY291bnRlcnMgJSAyID09PSAwICYmIGNsb2Nrd2lzZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG59KTtcblxudmFyIFBhdGhJdGVyYXRvciA9IEJhc2UuZXh0ZW5kKHtcblx0X2NsYXNzOiAnUGF0aEl0ZXJhdG9yJyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbihwYXRoLCBtYXhSZWN1cnNpb24sIHRvbGVyYW5jZSwgbWF0cml4KSB7XG5cdFx0dmFyIGN1cnZlcyA9IFtdLFxuXHRcdFx0cGFydHMgPSBbXSxcblx0XHRcdGxlbmd0aCA9IDAsXG5cdFx0XHRtaW5EaWZmZXJlbmNlID0gMSAvIChtYXhSZWN1cnNpb24gfHwgMzIpLFxuXHRcdFx0c2VnbWVudHMgPSBwYXRoLl9zZWdtZW50cyxcblx0XHRcdHNlZ21lbnQxID0gc2VnbWVudHNbMF0sXG5cdFx0XHRzZWdtZW50MjtcblxuXHRcdGZ1bmN0aW9uIGFkZEN1cnZlKHNlZ21lbnQxLCBzZWdtZW50Mikge1xuXHRcdFx0dmFyIGN1cnZlID0gQ3VydmUuZ2V0VmFsdWVzKHNlZ21lbnQxLCBzZWdtZW50MiwgbWF0cml4KTtcblx0XHRcdGN1cnZlcy5wdXNoKGN1cnZlKTtcblx0XHRcdGNvbXB1dGVQYXJ0cyhjdXJ2ZSwgc2VnbWVudDEuX2luZGV4LCAwLCAxKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiBjb21wdXRlUGFydHMoY3VydmUsIGluZGV4LCBtaW5ULCBtYXhUKSB7XG5cdFx0XHRpZiAoKG1heFQgLSBtaW5UKSA+IG1pbkRpZmZlcmVuY2Vcblx0XHRcdFx0XHQmJiAhQ3VydmUuaXNGbGF0RW5vdWdoKGN1cnZlLCB0b2xlcmFuY2UgfHwgMC4yNSkpIHtcblx0XHRcdFx0dmFyIHNwbGl0ID0gQ3VydmUuc3ViZGl2aWRlKGN1cnZlLCAwLjUpLFxuXHRcdFx0XHRcdGhhbGZUID0gKG1pblQgKyBtYXhUKSAvIDI7XG5cdFx0XHRcdGNvbXB1dGVQYXJ0cyhzcGxpdFswXSwgaW5kZXgsIG1pblQsIGhhbGZUKTtcblx0XHRcdFx0Y29tcHV0ZVBhcnRzKHNwbGl0WzFdLCBpbmRleCwgaGFsZlQsIG1heFQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0dmFyIHggPSBjdXJ2ZVs2XSAtIGN1cnZlWzBdLFxuXHRcdFx0XHRcdHkgPSBjdXJ2ZVs3XSAtIGN1cnZlWzFdLFxuXHRcdFx0XHRcdGRpc3QgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XG5cdFx0XHRcdGlmIChkaXN0ID4gMWUtNikge1xuXHRcdFx0XHRcdGxlbmd0aCArPSBkaXN0O1xuXHRcdFx0XHRcdHBhcnRzLnB1c2goe1xuXHRcdFx0XHRcdFx0b2Zmc2V0OiBsZW5ndGgsXG5cdFx0XHRcdFx0XHR2YWx1ZTogbWF4VCxcblx0XHRcdFx0XHRcdGluZGV4OiBpbmRleFxuXHRcdFx0XHRcdH0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHNlZ21lbnQyID0gc2VnbWVudHNbaV07XG5cdFx0XHRhZGRDdXJ2ZShzZWdtZW50MSwgc2VnbWVudDIpO1xuXHRcdFx0c2VnbWVudDEgPSBzZWdtZW50Mjtcblx0XHR9XG5cdFx0aWYgKHBhdGguX2Nsb3NlZClcblx0XHRcdGFkZEN1cnZlKHNlZ21lbnQyLCBzZWdtZW50c1swXSk7XG5cblx0XHR0aGlzLmN1cnZlcyA9IGN1cnZlcztcblx0XHR0aGlzLnBhcnRzID0gcGFydHM7XG5cdFx0dGhpcy5sZW5ndGggPSBsZW5ndGg7XG5cdFx0dGhpcy5pbmRleCA9IDA7XG5cdH0sXG5cblx0Z2V0UGFyYW1ldGVyQXQ6IGZ1bmN0aW9uKG9mZnNldCkge1xuXHRcdHZhciBpLCBqID0gdGhpcy5pbmRleDtcblx0XHRmb3IgKDs7KSB7XG5cdFx0XHRpID0gajtcblx0XHRcdGlmIChqID09IDAgfHwgdGhpcy5wYXJ0c1stLWpdLm9mZnNldCA8IG9mZnNldClcblx0XHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGZvciAodmFyIGwgPSB0aGlzLnBhcnRzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHBhcnQgPSB0aGlzLnBhcnRzW2ldO1xuXHRcdFx0aWYgKHBhcnQub2Zmc2V0ID49IG9mZnNldCkge1xuXHRcdFx0XHR0aGlzLmluZGV4ID0gaTtcblx0XHRcdFx0dmFyIHByZXYgPSB0aGlzLnBhcnRzW2kgLSAxXTtcblx0XHRcdFx0dmFyIHByZXZWYWwgPSBwcmV2ICYmIHByZXYuaW5kZXggPT0gcGFydC5pbmRleCA/IHByZXYudmFsdWUgOiAwLFxuXHRcdFx0XHRcdHByZXZMZW4gPSBwcmV2ID8gcHJldi5vZmZzZXQgOiAwO1xuXHRcdFx0XHRyZXR1cm4ge1xuXHRcdFx0XHRcdHZhbHVlOiBwcmV2VmFsICsgKHBhcnQudmFsdWUgLSBwcmV2VmFsKVxuXHRcdFx0XHRcdFx0KiAob2Zmc2V0IC0gcHJldkxlbikgLyAocGFydC5vZmZzZXQgLSBwcmV2TGVuKSxcblx0XHRcdFx0XHRpbmRleDogcGFydC5pbmRleFxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdH1cblx0XHR2YXIgcGFydCA9IHRoaXMucGFydHNbdGhpcy5wYXJ0cy5sZW5ndGggLSAxXTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0dmFsdWU6IDEsXG5cdFx0XHRpbmRleDogcGFydC5pbmRleFxuXHRcdH07XG5cdH0sXG5cblx0ZHJhd1BhcnQ6IGZ1bmN0aW9uKGN0eCwgZnJvbSwgdG8pIHtcblx0XHRmcm9tID0gdGhpcy5nZXRQYXJhbWV0ZXJBdChmcm9tKTtcblx0XHR0byA9IHRoaXMuZ2V0UGFyYW1ldGVyQXQodG8pO1xuXHRcdGZvciAodmFyIGkgPSBmcm9tLmluZGV4OyBpIDw9IHRvLmluZGV4OyBpKyspIHtcblx0XHRcdHZhciBjdXJ2ZSA9IEN1cnZlLmdldFBhcnQodGhpcy5jdXJ2ZXNbaV0sXG5cdFx0XHRcdFx0aSA9PSBmcm9tLmluZGV4ID8gZnJvbS52YWx1ZSA6IDAsXG5cdFx0XHRcdFx0aSA9PSB0by5pbmRleCA/IHRvLnZhbHVlIDogMSk7XG5cdFx0XHRpZiAoaSA9PSBmcm9tLmluZGV4KVxuXHRcdFx0XHRjdHgubW92ZVRvKGN1cnZlWzBdLCBjdXJ2ZVsxXSk7XG5cdFx0XHRjdHguYmV6aWVyQ3VydmVUby5hcHBseShjdHgsIGN1cnZlLnNsaWNlKDIpKTtcblx0XHR9XG5cdH1cbn0sIEJhc2UuZWFjaChDdXJ2ZS5ldmFsdWF0ZU1ldGhvZHMsXG5cdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHR0aGlzW25hbWUgKyAnQXQnXSA9IGZ1bmN0aW9uKG9mZnNldCwgd2VpZ2h0ZWQpIHtcblx0XHRcdHZhciBwYXJhbSA9IHRoaXMuZ2V0UGFyYW1ldGVyQXQob2Zmc2V0KTtcblx0XHRcdHJldHVybiBDdXJ2ZVtuYW1lXSh0aGlzLmN1cnZlc1twYXJhbS5pbmRleF0sIHBhcmFtLnZhbHVlLCB3ZWlnaHRlZCk7XG5cdFx0fTtcblx0fSwge30pXG4pO1xuXG52YXIgUGF0aEZpdHRlciA9IEJhc2UuZXh0ZW5kKHtcblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24ocGF0aCwgZXJyb3IpIHtcblx0XHR2YXIgcG9pbnRzID0gdGhpcy5wb2ludHMgPSBbXSxcblx0XHRcdHNlZ21lbnRzID0gcGF0aC5fc2VnbWVudHMsXG5cdFx0XHRwcmV2O1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHR2YXIgcG9pbnQgPSBzZWdtZW50c1tpXS5wb2ludC5jbG9uZSgpO1xuXHRcdFx0aWYgKCFwcmV2IHx8ICFwcmV2LmVxdWFscyhwb2ludCkpIHtcblx0XHRcdFx0cG9pbnRzLnB1c2gocG9pbnQpO1xuXHRcdFx0XHRwcmV2ID0gcG9pbnQ7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHBhdGguX2Nsb3NlZCkge1xuXHRcdFx0dGhpcy5jbG9zZWQgPSB0cnVlO1xuXHRcdFx0cG9pbnRzLnVuc2hpZnQocG9pbnRzW3BvaW50cy5sZW5ndGggLSAxXSk7XG5cdFx0XHRwb2ludHMucHVzaChwb2ludHNbMV0pO1xuXHRcdH1cblxuXHRcdHRoaXMuZXJyb3IgPSBlcnJvcjtcblx0fSxcblxuXHRmaXQ6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBwb2ludHMgPSB0aGlzLnBvaW50cyxcblx0XHRcdGxlbmd0aCA9IHBvaW50cy5sZW5ndGgsXG5cdFx0XHRzZWdtZW50cyA9IHRoaXMuc2VnbWVudHMgPSBsZW5ndGggPiAwXG5cdFx0XHRcdFx0PyBbbmV3IFNlZ21lbnQocG9pbnRzWzBdKV0gOiBbXTtcblx0XHRpZiAobGVuZ3RoID4gMSlcblx0XHRcdHRoaXMuZml0Q3ViaWMoMCwgbGVuZ3RoIC0gMSxcblx0XHRcdFx0cG9pbnRzWzFdLnN1YnRyYWN0KHBvaW50c1swXSkubm9ybWFsaXplKCksXG5cdFx0XHRcdHBvaW50c1tsZW5ndGggLSAyXS5zdWJ0cmFjdChwb2ludHNbbGVuZ3RoIC0gMV0pLm5vcm1hbGl6ZSgpKTtcblxuXHRcdGlmICh0aGlzLmNsb3NlZCkge1xuXHRcdFx0c2VnbWVudHMuc2hpZnQoKTtcblx0XHRcdHNlZ21lbnRzLnBvcCgpO1xuXHRcdH1cblxuXHRcdHJldHVybiBzZWdtZW50cztcblx0fSxcblxuXHRmaXRDdWJpYzogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIHRhbjEsIHRhbjIpIHtcblx0XHRpZiAobGFzdCAtIGZpcnN0ID09IDEpIHtcblx0XHRcdHZhciBwdDEgPSB0aGlzLnBvaW50c1tmaXJzdF0sXG5cdFx0XHRcdHB0MiA9IHRoaXMucG9pbnRzW2xhc3RdLFxuXHRcdFx0XHRkaXN0ID0gcHQxLmdldERpc3RhbmNlKHB0MikgLyAzO1xuXHRcdFx0dGhpcy5hZGRDdXJ2ZShbcHQxLCBwdDEuYWRkKHRhbjEubm9ybWFsaXplKGRpc3QpKSxcblx0XHRcdFx0XHRwdDIuYWRkKHRhbjIubm9ybWFsaXplKGRpc3QpKSwgcHQyXSk7XG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXHRcdHZhciB1UHJpbWUgPSB0aGlzLmNob3JkTGVuZ3RoUGFyYW1ldGVyaXplKGZpcnN0LCBsYXN0KSxcblx0XHRcdG1heEVycm9yID0gTWF0aC5tYXgodGhpcy5lcnJvciwgdGhpcy5lcnJvciAqIHRoaXMuZXJyb3IpLFxuXHRcdFx0c3BsaXQsXG5cdFx0XHRwYXJhbWV0ZXJzSW5PcmRlciA9IHRydWU7XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gNDsgaSsrKSB7XG5cdFx0XHR2YXIgY3VydmUgPSB0aGlzLmdlbmVyYXRlQmV6aWVyKGZpcnN0LCBsYXN0LCB1UHJpbWUsIHRhbjEsIHRhbjIpO1xuXHRcdFx0dmFyIG1heCA9IHRoaXMuZmluZE1heEVycm9yKGZpcnN0LCBsYXN0LCBjdXJ2ZSwgdVByaW1lKTtcblx0XHRcdGlmIChtYXguZXJyb3IgPCB0aGlzLmVycm9yICYmIHBhcmFtZXRlcnNJbk9yZGVyKSB7XG5cdFx0XHRcdHRoaXMuYWRkQ3VydmUoY3VydmUpO1xuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cdFx0XHRzcGxpdCA9IG1heC5pbmRleDtcblx0XHRcdGlmIChtYXguZXJyb3IgPj0gbWF4RXJyb3IpXG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0cGFyYW1ldGVyc0luT3JkZXIgPSB0aGlzLnJlcGFyYW1ldGVyaXplKGZpcnN0LCBsYXN0LCB1UHJpbWUsIGN1cnZlKTtcblx0XHRcdG1heEVycm9yID0gbWF4LmVycm9yO1xuXHRcdH1cblx0XHR2YXIgVjEgPSB0aGlzLnBvaW50c1tzcGxpdCAtIDFdLnN1YnRyYWN0KHRoaXMucG9pbnRzW3NwbGl0XSksXG5cdFx0XHRWMiA9IHRoaXMucG9pbnRzW3NwbGl0XS5zdWJ0cmFjdCh0aGlzLnBvaW50c1tzcGxpdCArIDFdKSxcblx0XHRcdHRhbkNlbnRlciA9IFYxLmFkZChWMikuZGl2aWRlKDIpLm5vcm1hbGl6ZSgpO1xuXHRcdHRoaXMuZml0Q3ViaWMoZmlyc3QsIHNwbGl0LCB0YW4xLCB0YW5DZW50ZXIpO1xuXHRcdHRoaXMuZml0Q3ViaWMoc3BsaXQsIGxhc3QsIHRhbkNlbnRlci5uZWdhdGUoKSwgdGFuMik7XG5cdH0sXG5cblx0YWRkQ3VydmU6IGZ1bmN0aW9uKGN1cnZlKSB7XG5cdFx0dmFyIHByZXYgPSB0aGlzLnNlZ21lbnRzW3RoaXMuc2VnbWVudHMubGVuZ3RoIC0gMV07XG5cdFx0cHJldi5zZXRIYW5kbGVPdXQoY3VydmVbMV0uc3VidHJhY3QoY3VydmVbMF0pKTtcblx0XHR0aGlzLnNlZ21lbnRzLnB1c2goXG5cdFx0XHRcdG5ldyBTZWdtZW50KGN1cnZlWzNdLCBjdXJ2ZVsyXS5zdWJ0cmFjdChjdXJ2ZVszXSkpKTtcblx0fSxcblxuXHRnZW5lcmF0ZUJlemllcjogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIHVQcmltZSwgdGFuMSwgdGFuMikge1xuXHRcdHZhciBlcHNpbG9uID0gMWUtMTIsXG5cdFx0XHRwdDEgPSB0aGlzLnBvaW50c1tmaXJzdF0sXG5cdFx0XHRwdDIgPSB0aGlzLnBvaW50c1tsYXN0XSxcblx0XHRcdEMgPSBbWzAsIDBdLCBbMCwgMF1dLFxuXHRcdFx0WCA9IFswLCAwXTtcblxuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGFzdCAtIGZpcnN0ICsgMTsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHUgPSB1UHJpbWVbaV0sXG5cdFx0XHRcdHQgPSAxIC0gdSxcblx0XHRcdFx0YiA9IDMgKiB1ICogdCxcblx0XHRcdFx0YjAgPSB0ICogdCAqIHQsXG5cdFx0XHRcdGIxID0gYiAqIHQsXG5cdFx0XHRcdGIyID0gYiAqIHUsXG5cdFx0XHRcdGIzID0gdSAqIHUgKiB1LFxuXHRcdFx0XHRhMSA9IHRhbjEubm9ybWFsaXplKGIxKSxcblx0XHRcdFx0YTIgPSB0YW4yLm5vcm1hbGl6ZShiMiksXG5cdFx0XHRcdHRtcCA9IHRoaXMucG9pbnRzW2ZpcnN0ICsgaV1cblx0XHRcdFx0XHQuc3VidHJhY3QocHQxLm11bHRpcGx5KGIwICsgYjEpKVxuXHRcdFx0XHRcdC5zdWJ0cmFjdChwdDIubXVsdGlwbHkoYjIgKyBiMykpO1xuXHRcdFx0Q1swXVswXSArPSBhMS5kb3QoYTEpO1xuXHRcdFx0Q1swXVsxXSArPSBhMS5kb3QoYTIpO1xuXHRcdFx0Q1sxXVswXSA9IENbMF1bMV07XG5cdFx0XHRDWzFdWzFdICs9IGEyLmRvdChhMik7XG5cdFx0XHRYWzBdICs9IGExLmRvdCh0bXApO1xuXHRcdFx0WFsxXSArPSBhMi5kb3QodG1wKTtcblx0XHR9XG5cblx0XHR2YXIgZGV0QzBDMSA9IENbMF1bMF0gKiBDWzFdWzFdIC0gQ1sxXVswXSAqIENbMF1bMV0sXG5cdFx0XHRhbHBoYTEsIGFscGhhMjtcblx0XHRpZiAoTWF0aC5hYnMoZGV0QzBDMSkgPiBlcHNpbG9uKSB7XG5cdFx0XHR2YXIgZGV0QzBYXHQ9IENbMF1bMF0gKiBYWzFdXHQtIENbMV1bMF0gKiBYWzBdLFxuXHRcdFx0XHRkZXRYQzFcdD0gWFswXVx0ICAqIENbMV1bMV0gLSBYWzFdXHQgICogQ1swXVsxXTtcblx0XHRcdGFscGhhMSA9IGRldFhDMSAvIGRldEMwQzE7XG5cdFx0XHRhbHBoYTIgPSBkZXRDMFggLyBkZXRDMEMxO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgYzAgPSBDWzBdWzBdICsgQ1swXVsxXSxcblx0XHRcdFx0YzEgPSBDWzFdWzBdICsgQ1sxXVsxXTtcblx0XHRcdGlmIChNYXRoLmFicyhjMCkgPiBlcHNpbG9uKSB7XG5cdFx0XHRcdGFscGhhMSA9IGFscGhhMiA9IFhbMF0gLyBjMDtcblx0XHRcdH0gZWxzZSBpZiAoTWF0aC5hYnMoYzEpID4gZXBzaWxvbikge1xuXHRcdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBYWzFdIC8gYzE7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSAwO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdHZhciBzZWdMZW5ndGggPSBwdDIuZ2V0RGlzdGFuY2UocHQxKSxcblx0XHRcdGVwcyA9IGVwc2lsb24gKiBzZWdMZW5ndGgsXG5cdFx0XHRoYW5kbGUxLFxuXHRcdFx0aGFuZGxlMjtcblx0XHRpZiAoYWxwaGExIDwgZXBzIHx8IGFscGhhMiA8IGVwcykge1xuXHRcdFx0YWxwaGExID0gYWxwaGEyID0gc2VnTGVuZ3RoIC8gMztcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGxpbmUgPSBwdDIuc3VidHJhY3QocHQxKTtcblx0XHRcdGhhbmRsZTEgPSB0YW4xLm5vcm1hbGl6ZShhbHBoYTEpO1xuXHRcdFx0aGFuZGxlMiA9IHRhbjIubm9ybWFsaXplKGFscGhhMik7XG5cdFx0XHRpZiAoaGFuZGxlMS5kb3QobGluZSkgLSBoYW5kbGUyLmRvdChsaW5lKSA+IHNlZ0xlbmd0aCAqIHNlZ0xlbmd0aCkge1xuXHRcdFx0XHRhbHBoYTEgPSBhbHBoYTIgPSBzZWdMZW5ndGggLyAzO1xuXHRcdFx0XHRoYW5kbGUxID0gaGFuZGxlMiA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0cmV0dXJuIFtwdDEsIHB0MS5hZGQoaGFuZGxlMSB8fCB0YW4xLm5vcm1hbGl6ZShhbHBoYTEpKSxcblx0XHRcdFx0cHQyLmFkZChoYW5kbGUyIHx8IHRhbjIubm9ybWFsaXplKGFscGhhMikpLCBwdDJdO1xuXHR9LFxuXG5cdHJlcGFyYW1ldGVyaXplOiBmdW5jdGlvbihmaXJzdCwgbGFzdCwgdSwgY3VydmUpIHtcblx0XHRmb3IgKHZhciBpID0gZmlyc3Q7IGkgPD0gbGFzdDsgaSsrKSB7XG5cdFx0XHR1W2kgLSBmaXJzdF0gPSB0aGlzLmZpbmRSb290KGN1cnZlLCB0aGlzLnBvaW50c1tpXSwgdVtpIC0gZmlyc3RdKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDEsIGwgPSB1Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0aWYgKHVbaV0gPD0gdVtpIC0gMV0pXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHR9XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0ZmluZFJvb3Q6IGZ1bmN0aW9uKGN1cnZlLCBwb2ludCwgdSkge1xuXHRcdHZhciBjdXJ2ZTEgPSBbXSxcblx0XHRcdGN1cnZlMiA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDw9IDI7IGkrKykge1xuXHRcdFx0Y3VydmUxW2ldID0gY3VydmVbaSArIDFdLnN1YnRyYWN0KGN1cnZlW2ldKS5tdWx0aXBseSgzKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPD0gMTsgaSsrKSB7XG5cdFx0XHRjdXJ2ZTJbaV0gPSBjdXJ2ZTFbaSArIDFdLnN1YnRyYWN0KGN1cnZlMVtpXSkubXVsdGlwbHkoMik7XG5cdFx0fVxuXHRcdHZhciBwdCA9IHRoaXMuZXZhbHVhdGUoMywgY3VydmUsIHUpLFxuXHRcdFx0cHQxID0gdGhpcy5ldmFsdWF0ZSgyLCBjdXJ2ZTEsIHUpLFxuXHRcdFx0cHQyID0gdGhpcy5ldmFsdWF0ZSgxLCBjdXJ2ZTIsIHUpLFxuXHRcdFx0ZGlmZiA9IHB0LnN1YnRyYWN0KHBvaW50KSxcblx0XHRcdGRmID0gcHQxLmRvdChwdDEpICsgZGlmZi5kb3QocHQyKTtcblx0XHRpZiAoTWF0aC5hYnMoZGYpIDwgMWUtNilcblx0XHRcdHJldHVybiB1O1xuXHRcdHJldHVybiB1IC0gZGlmZi5kb3QocHQxKSAvIGRmO1xuXHR9LFxuXG5cdGV2YWx1YXRlOiBmdW5jdGlvbihkZWdyZWUsIGN1cnZlLCB0KSB7XG5cdFx0dmFyIHRtcCA9IGN1cnZlLnNsaWNlKCk7XG5cdFx0Zm9yICh2YXIgaSA9IDE7IGkgPD0gZGVncmVlOyBpKyspIHtcblx0XHRcdGZvciAodmFyIGogPSAwOyBqIDw9IGRlZ3JlZSAtIGk7IGorKykge1xuXHRcdFx0XHR0bXBbal0gPSB0bXBbal0ubXVsdGlwbHkoMSAtIHQpLmFkZCh0bXBbaiArIDFdLm11bHRpcGx5KHQpKTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRtcFswXTtcblx0fSxcblxuXHRjaG9yZExlbmd0aFBhcmFtZXRlcml6ZTogZnVuY3Rpb24oZmlyc3QsIGxhc3QpIHtcblx0XHR2YXIgdSA9IFswXTtcblx0XHRmb3IgKHZhciBpID0gZmlyc3QgKyAxOyBpIDw9IGxhc3Q7IGkrKykge1xuXHRcdFx0dVtpIC0gZmlyc3RdID0gdVtpIC0gZmlyc3QgLSAxXVxuXHRcdFx0XHRcdCsgdGhpcy5wb2ludHNbaV0uZ2V0RGlzdGFuY2UodGhpcy5wb2ludHNbaSAtIDFdKTtcblx0XHR9XG5cdFx0Zm9yICh2YXIgaSA9IDEsIG0gPSBsYXN0IC0gZmlyc3Q7IGkgPD0gbTsgaSsrKSB7XG5cdFx0XHR1W2ldIC89IHVbbV07XG5cdFx0fVxuXHRcdHJldHVybiB1O1xuXHR9LFxuXG5cdGZpbmRNYXhFcnJvcjogZnVuY3Rpb24oZmlyc3QsIGxhc3QsIGN1cnZlLCB1KSB7XG5cdFx0dmFyIGluZGV4ID0gTWF0aC5mbG9vcigobGFzdCAtIGZpcnN0ICsgMSkgLyAyKSxcblx0XHRcdG1heERpc3QgPSAwO1xuXHRcdGZvciAodmFyIGkgPSBmaXJzdCArIDE7IGkgPCBsYXN0OyBpKyspIHtcblx0XHRcdHZhciBQID0gdGhpcy5ldmFsdWF0ZSgzLCBjdXJ2ZSwgdVtpIC0gZmlyc3RdKTtcblx0XHRcdHZhciB2ID0gUC5zdWJ0cmFjdCh0aGlzLnBvaW50c1tpXSk7XG5cdFx0XHR2YXIgZGlzdCA9IHYueCAqIHYueCArIHYueSAqIHYueTtcblx0XHRcdGlmIChkaXN0ID49IG1heERpc3QpIHtcblx0XHRcdFx0bWF4RGlzdCA9IGRpc3Q7XG5cdFx0XHRcdGluZGV4ID0gaTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdGVycm9yOiBtYXhEaXN0LFxuXHRcdFx0aW5kZXg6IGluZGV4XG5cdFx0fTtcblx0fVxufSk7XG5cbnZhciBUZXh0SXRlbSA9IEl0ZW0uZXh0ZW5kKHtcblx0X2NsYXNzOiAnVGV4dEl0ZW0nLFxuXHRfYm91bmRzU2VsZWN0ZWQ6IHRydWUsXG5cdF9hcHBseU1hdHJpeDogZmFsc2UsXG5cdF9jYW5BcHBseU1hdHJpeDogZmFsc2UsXG5cdF9zZXJpYWxpemVGaWVsZHM6IHtcblx0XHRjb250ZW50OiBudWxsXG5cdH0sXG5cdF9ib3VuZHNHZXR0ZXI6ICdnZXRCb3VuZHMnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFRleHRJdGVtKGFyZykge1xuXHRcdHRoaXMuX2NvbnRlbnQgPSAnJztcblx0XHR0aGlzLl9saW5lcyA9IFtdO1xuXHRcdHZhciBoYXNQcm9wcyA9IGFyZyAmJiBCYXNlLmlzUGxhaW5PYmplY3QoYXJnKVxuXHRcdFx0XHQmJiBhcmcueCA9PT0gdW5kZWZpbmVkICYmIGFyZy55ID09PSB1bmRlZmluZWQ7XG5cdFx0dGhpcy5faW5pdGlhbGl6ZShoYXNQcm9wcyAmJiBhcmcsICFoYXNQcm9wcyAmJiBQb2ludC5yZWFkKGFyZ3VtZW50cykpO1xuXHR9LFxuXG5cdF9lcXVhbHM6IGZ1bmN0aW9uKGl0ZW0pIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudCA9PT0gaXRlbS5fY29udGVudDtcblx0fSxcblxuXHRfY2xvbmU6IGZ1bmN0aW9uIF9jbG9uZShjb3B5LCBpbnNlcnQsIGluY2x1ZGVNYXRyaXgpIHtcblx0XHRjb3B5LnNldENvbnRlbnQodGhpcy5fY29udGVudCk7XG5cdFx0cmV0dXJuIF9jbG9uZS5iYXNlLmNhbGwodGhpcywgY29weSwgaW5zZXJ0LCBpbmNsdWRlTWF0cml4KTtcblx0fSxcblxuXHRnZXRDb250ZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY29udGVudDtcblx0fSxcblxuXHRzZXRDb250ZW50OiBmdW5jdGlvbihjb250ZW50KSB7XG5cdFx0dGhpcy5fY29udGVudCA9ICcnICsgY29udGVudDtcblx0XHR0aGlzLl9saW5lcyA9IHRoaXMuX2NvbnRlbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL21nKTtcblx0XHR0aGlzLl9jaGFuZ2VkKDI2NSk7XG5cdH0sXG5cblx0aXNFbXB0eTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9jb250ZW50O1xuXHR9LFxuXG5cdGdldENoYXJhY3RlclN0eWxlOiAnI2dldFN0eWxlJyxcblx0c2V0Q2hhcmFjdGVyU3R5bGU6ICcjc2V0U3R5bGUnLFxuXG5cdGdldFBhcmFncmFwaFN0eWxlOiAnI2dldFN0eWxlJyxcblx0c2V0UGFyYWdyYXBoU3R5bGU6ICcjc2V0U3R5bGUnXG59KTtcblxudmFyIFBvaW50VGV4dCA9IFRleHRJdGVtLmV4dGVuZCh7XG5cdF9jbGFzczogJ1BvaW50VGV4dCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gUG9pbnRUZXh0KCkge1xuXHRcdFRleHRJdGVtLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdH0sXG5cblx0Y2xvbmU6IGZ1bmN0aW9uKGluc2VydCkge1xuXHRcdHJldHVybiB0aGlzLl9jbG9uZShuZXcgUG9pbnRUZXh0KEl0ZW0uTk9fSU5TRVJUKSwgaW5zZXJ0KTtcblx0fSxcblxuXHRnZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gdGhpcy5fbWF0cml4LmdldFRyYW5zbGF0aW9uKCk7XG5cdFx0cmV0dXJuIG5ldyBMaW5rZWRQb2ludChwb2ludC54LCBwb2ludC55LCB0aGlzLCAnc2V0UG9pbnQnKTtcblx0fSxcblxuXHRzZXRQb2ludDogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIHBvaW50ID0gUG9pbnQucmVhZChhcmd1bWVudHMpO1xuXHRcdHRoaXMudHJhbnNsYXRlKHBvaW50LnN1YnRyYWN0KHRoaXMuX21hdHJpeC5nZXRUcmFuc2xhdGlvbigpKSk7XG5cdH0sXG5cblx0X2RyYXc6IGZ1bmN0aW9uKGN0eCkge1xuXHRcdGlmICghdGhpcy5fY29udGVudClcblx0XHRcdHJldHVybjtcblx0XHR0aGlzLl9zZXRTdHlsZXMoY3R4KTtcblx0XHR2YXIgc3R5bGUgPSB0aGlzLl9zdHlsZSxcblx0XHRcdGxpbmVzID0gdGhpcy5fbGluZXMsXG5cdFx0XHRsZWFkaW5nID0gc3R5bGUuZ2V0TGVhZGluZygpLFxuXHRcdFx0c2hhZG93Q29sb3IgPSBjdHguc2hhZG93Q29sb3I7XG5cdFx0Y3R4LmZvbnQgPSBzdHlsZS5nZXRGb250U3R5bGUoKTtcblx0XHRjdHgudGV4dEFsaWduID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gbGluZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRjdHguc2hhZG93Q29sb3IgPSBzaGFkb3dDb2xvcjtcblx0XHRcdHZhciBsaW5lID0gbGluZXNbaV07XG5cdFx0XHRpZiAoc3R5bGUuaGFzRmlsbCgpKSB7XG5cdFx0XHRcdGN0eC5maWxsVGV4dChsaW5lLCAwLCAwKTtcblx0XHRcdFx0Y3R4LnNoYWRvd0NvbG9yID0gJ3JnYmEoMCwwLDAsMCknO1xuXHRcdFx0fVxuXHRcdFx0aWYgKHN0eWxlLmhhc1N0cm9rZSgpKVxuXHRcdFx0XHRjdHguc3Ryb2tlVGV4dChsaW5lLCAwLCAwKTtcblx0XHRcdGN0eC50cmFuc2xhdGUoMCwgbGVhZGluZyk7XG5cdFx0fVxuXHR9LFxuXG5cdF9nZXRCb3VuZHM6IGZ1bmN0aW9uKGdldHRlciwgbWF0cml4KSB7XG5cdFx0dmFyIHN0eWxlID0gdGhpcy5fc3R5bGUsXG5cdFx0XHRsaW5lcyA9IHRoaXMuX2xpbmVzLFxuXHRcdFx0bnVtTGluZXMgPSBsaW5lcy5sZW5ndGgsXG5cdFx0XHRqdXN0aWZpY2F0aW9uID0gc3R5bGUuZ2V0SnVzdGlmaWNhdGlvbigpLFxuXHRcdFx0bGVhZGluZyA9IHN0eWxlLmdldExlYWRpbmcoKSxcblx0XHRcdHdpZHRoID0gdGhpcy5nZXRWaWV3KCkuZ2V0VGV4dFdpZHRoKHN0eWxlLmdldEZvbnRTdHlsZSgpLCBsaW5lcyksXG5cdFx0XHR4ID0gMDtcblx0XHRpZiAoanVzdGlmaWNhdGlvbiAhPT0gJ2xlZnQnKVxuXHRcdFx0eCAtPSB3aWR0aCAvIChqdXN0aWZpY2F0aW9uID09PSAnY2VudGVyJyA/IDI6IDEpO1xuXHRcdHZhciBib3VuZHMgPSBuZXcgUmVjdGFuZ2xlKHgsXG5cdFx0XHRcdFx0bnVtTGluZXMgPyAtIDAuNzUgKiBsZWFkaW5nIDogMCxcblx0XHRcdFx0XHR3aWR0aCwgbnVtTGluZXMgKiBsZWFkaW5nKTtcblx0XHRyZXR1cm4gbWF0cml4ID8gbWF0cml4Ll90cmFuc2Zvcm1Cb3VuZHMoYm91bmRzLCBib3VuZHMpIDogYm91bmRzO1xuXHR9XG59KTtcblxudmFyIENvbG9yID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgdHlwZXMgPSB7XG5cdFx0Z3JheTogWydncmF5J10sXG5cdFx0cmdiOiBbJ3JlZCcsICdncmVlbicsICdibHVlJ10sXG5cdFx0aHNiOiBbJ2h1ZScsICdzYXR1cmF0aW9uJywgJ2JyaWdodG5lc3MnXSxcblx0XHRoc2w6IFsnaHVlJywgJ3NhdHVyYXRpb24nLCAnbGlnaHRuZXNzJ10sXG5cdFx0Z3JhZGllbnQ6IFsnZ3JhZGllbnQnLCAnb3JpZ2luJywgJ2Rlc3RpbmF0aW9uJywgJ2hpZ2hsaWdodCddXG5cdH07XG5cblx0dmFyIGNvbXBvbmVudFBhcnNlcnMgPSB7fSxcblx0XHRjb2xvckNhY2hlID0ge30sXG5cdFx0Y29sb3JDdHg7XG5cblx0ZnVuY3Rpb24gZnJvbUNTUyhzdHJpbmcpIHtcblx0XHR2YXIgbWF0Y2ggPSBzdHJpbmcubWF0Y2goL14jKFxcd3sxLDJ9KShcXHd7MSwyfSkoXFx3ezEsMn0pJC8pLFxuXHRcdFx0Y29tcG9uZW50cztcblx0XHRpZiAobWF0Y2gpIHtcblx0XHRcdGNvbXBvbmVudHMgPSBbMCwgMCwgMF07XG5cdFx0XHRmb3IgKHZhciBpID0gMDsgaSA8IDM7IGkrKykge1xuXHRcdFx0XHR2YXIgdmFsdWUgPSBtYXRjaFtpICsgMV07XG5cdFx0XHRcdGNvbXBvbmVudHNbaV0gPSBwYXJzZUludCh2YWx1ZS5sZW5ndGggPT0gMVxuXHRcdFx0XHRcdFx0PyB2YWx1ZSArIHZhbHVlIDogdmFsdWUsIDE2KSAvIDI1NTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKG1hdGNoID0gc3RyaW5nLm1hdGNoKC9ecmdiYT9cXCgoLiopXFwpJC8pKSB7XG5cdFx0XHRjb21wb25lbnRzID0gbWF0Y2hbMV0uc3BsaXQoJywnKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gY29tcG9uZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gK2NvbXBvbmVudHNbaV07XG5cdFx0XHRcdGNvbXBvbmVudHNbaV0gPSBpIDwgMyA/IHZhbHVlIC8gMjU1IDogdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBjYWNoZWQgPSBjb2xvckNhY2hlW3N0cmluZ107XG5cdFx0XHRpZiAoIWNhY2hlZCkge1xuXHRcdFx0XHRpZiAoIWNvbG9yQ3R4KSB7XG5cdFx0XHRcdFx0Y29sb3JDdHggPSBDYW52YXNQcm92aWRlci5nZXRDb250ZXh0KDEsIDEpO1xuXHRcdFx0XHRcdGNvbG9yQ3R4Lmdsb2JhbENvbXBvc2l0ZU9wZXJhdGlvbiA9ICdjb3B5Jztcblx0XHRcdFx0fVxuXHRcdFx0XHRjb2xvckN0eC5maWxsU3R5bGUgPSAncmdiYSgwLDAsMCwwKSc7XG5cdFx0XHRcdGNvbG9yQ3R4LmZpbGxTdHlsZSA9IHN0cmluZztcblx0XHRcdFx0Y29sb3JDdHguZmlsbFJlY3QoMCwgMCwgMSwgMSk7XG5cdFx0XHRcdHZhciBkYXRhID0gY29sb3JDdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpLmRhdGE7XG5cdFx0XHRcdGNhY2hlZCA9IGNvbG9yQ2FjaGVbc3RyaW5nXSA9IFtcblx0XHRcdFx0XHRkYXRhWzBdIC8gMjU1LFxuXHRcdFx0XHRcdGRhdGFbMV0gLyAyNTUsXG5cdFx0XHRcdFx0ZGF0YVsyXSAvIDI1NVxuXHRcdFx0XHRdO1xuXHRcdFx0fVxuXHRcdFx0Y29tcG9uZW50cyA9IGNhY2hlZC5zbGljZSgpO1xuXHRcdH1cblx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0fVxuXG5cdHZhciBoc2JJbmRpY2VzID0gW1xuXHRcdFswLCAzLCAxXSxcblx0XHRbMiwgMCwgMV0sXG5cdFx0WzEsIDAsIDNdLFxuXHRcdFsxLCAyLCAwXSxcblx0XHRbMywgMSwgMF0sXG5cdFx0WzAsIDEsIDJdXG5cdF07XG5cblx0dmFyIGNvbnZlcnRlcnMgPSB7XG5cdFx0J3JnYi1oc2InOiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG5cdFx0XHRcdG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuXHRcdFx0XHRkZWx0YSA9IG1heCAtIG1pbixcblx0XHRcdFx0aCA9IGRlbHRhID09PSAwID8gMFxuXHRcdFx0XHRcdDpcdCggbWF4ID09IHIgPyAoZyAtIGIpIC8gZGVsdGEgKyAoZyA8IGIgPyA2IDogMClcblx0XHRcdFx0XHRcdDogbWF4ID09IGcgPyAoYiAtIHIpIC8gZGVsdGEgKyAyXG5cdFx0XHRcdFx0XHQ6XHRcdFx0IChyIC0gZykgLyBkZWx0YSArIDQpICogNjA7XG5cdFx0XHRyZXR1cm4gW2gsIG1heCA9PT0gMCA/IDAgOiBkZWx0YSAvIG1heCwgbWF4XTtcblx0XHR9LFxuXG5cdFx0J2hzYi1yZ2InOiBmdW5jdGlvbihoLCBzLCBiKSB7XG5cdFx0XHRoID0gKCgoaCAvIDYwKSAlIDYpICsgNikgJSA2O1xuXHRcdFx0dmFyIGkgPSBNYXRoLmZsb29yKGgpLFxuXHRcdFx0XHRmID0gaCAtIGksXG5cdFx0XHRcdGkgPSBoc2JJbmRpY2VzW2ldLFxuXHRcdFx0XHR2ID0gW1xuXHRcdFx0XHRcdGIsXG5cdFx0XHRcdFx0YiAqICgxIC0gcyksXG5cdFx0XHRcdFx0YiAqICgxIC0gcyAqIGYpLFxuXHRcdFx0XHRcdGIgKiAoMSAtIHMgKiAoMSAtIGYpKVxuXHRcdFx0XHRdO1xuXHRcdFx0cmV0dXJuIFt2W2lbMF1dLCB2W2lbMV1dLCB2W2lbMl1dXTtcblx0XHR9LFxuXG5cdFx0J3JnYi1oc2wnOiBmdW5jdGlvbihyLCBnLCBiKSB7XG5cdFx0XHR2YXIgbWF4ID0gTWF0aC5tYXgociwgZywgYiksXG5cdFx0XHRcdG1pbiA9IE1hdGgubWluKHIsIGcsIGIpLFxuXHRcdFx0XHRkZWx0YSA9IG1heCAtIG1pbixcblx0XHRcdFx0YWNocm9tYXRpYyA9IGRlbHRhID09PSAwLFxuXHRcdFx0XHRoID0gYWNocm9tYXRpYyA/IDBcblx0XHRcdFx0XHQ6XHQoIG1heCA9PSByID8gKGcgLSBiKSAvIGRlbHRhICsgKGcgPCBiID8gNiA6IDApXG5cdFx0XHRcdFx0XHQ6IG1heCA9PSBnID8gKGIgLSByKSAvIGRlbHRhICsgMlxuXHRcdFx0XHRcdFx0Olx0XHRcdCAociAtIGcpIC8gZGVsdGEgKyA0KSAqIDYwLFxuXHRcdFx0XHRsID0gKG1heCArIG1pbikgLyAyLFxuXHRcdFx0XHRzID0gYWNocm9tYXRpYyA/IDAgOiBsIDwgMC41XG5cdFx0XHRcdFx0XHQ/IGRlbHRhIC8gKG1heCArIG1pbilcblx0XHRcdFx0XHRcdDogZGVsdGEgLyAoMiAtIG1heCAtIG1pbik7XG5cdFx0XHRyZXR1cm4gW2gsIHMsIGxdO1xuXHRcdH0sXG5cblx0XHQnaHNsLXJnYic6IGZ1bmN0aW9uKGgsIHMsIGwpIHtcblx0XHRcdGggPSAoKChoIC8gMzYwKSAlIDEpICsgMSkgJSAxO1xuXHRcdFx0aWYgKHMgPT09IDApXG5cdFx0XHRcdHJldHVybiBbbCwgbCwgbF07XG5cdFx0XHR2YXIgdDNzID0gWyBoICsgMSAvIDMsIGgsIGggLSAxIC8gMyBdLFxuXHRcdFx0XHR0MiA9IGwgPCAwLjUgPyBsICogKDEgKyBzKSA6IGwgKyBzIC0gbCAqIHMsXG5cdFx0XHRcdHQxID0gMiAqIGwgLSB0Mixcblx0XHRcdFx0YyA9IFtdO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCAzOyBpKyspIHtcblx0XHRcdFx0dmFyIHQzID0gdDNzW2ldO1xuXHRcdFx0XHRpZiAodDMgPCAwKSB0MyArPSAxO1xuXHRcdFx0XHRpZiAodDMgPiAxKSB0MyAtPSAxO1xuXHRcdFx0XHRjW2ldID0gNiAqIHQzIDwgMVxuXHRcdFx0XHRcdD8gdDEgKyAodDIgLSB0MSkgKiA2ICogdDNcblx0XHRcdFx0XHQ6IDIgKiB0MyA8IDFcblx0XHRcdFx0XHRcdD8gdDJcblx0XHRcdFx0XHRcdDogMyAqIHQzIDwgMlxuXHRcdFx0XHRcdFx0XHQ/IHQxICsgKHQyIC0gdDEpICogKCgyIC8gMykgLSB0MykgKiA2XG5cdFx0XHRcdFx0XHRcdDogdDE7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYztcblx0XHR9LFxuXG5cdFx0J3JnYi1ncmF5JzogZnVuY3Rpb24ociwgZywgYikge1xuXHRcdFx0cmV0dXJuIFtyICogMC4yOTg5ICsgZyAqIDAuNTg3ICsgYiAqIDAuMTE0XTtcblx0XHR9LFxuXG5cdFx0J2dyYXktcmdiJzogZnVuY3Rpb24oZykge1xuXHRcdFx0cmV0dXJuIFtnLCBnLCBnXTtcblx0XHR9LFxuXG5cdFx0J2dyYXktaHNiJzogZnVuY3Rpb24oZykge1xuXHRcdFx0cmV0dXJuIFswLCAwLCBnXTtcblx0XHR9LFxuXG5cdFx0J2dyYXktaHNsJzogZnVuY3Rpb24oZykge1xuXHRcdFx0cmV0dXJuIFswLCAwLCBnXTtcblx0XHR9LFxuXG5cdFx0J2dyYWRpZW50LXJnYic6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIFtdO1xuXHRcdH0sXG5cblx0XHQncmdiLWdyYWRpZW50JzogZnVuY3Rpb24oKSB7XG5cdFx0XHRyZXR1cm4gW107XG5cdFx0fVxuXG5cdH07XG5cblx0cmV0dXJuIEJhc2UuZWFjaCh0eXBlcywgZnVuY3Rpb24ocHJvcGVydGllcywgdHlwZSkge1xuXHRcdGNvbXBvbmVudFBhcnNlcnNbdHlwZV0gPSBbXTtcblx0XHRCYXNlLmVhY2gocHJvcGVydGllcywgZnVuY3Rpb24obmFtZSwgaW5kZXgpIHtcblx0XHRcdHZhciBwYXJ0ID0gQmFzZS5jYXBpdGFsaXplKG5hbWUpLFxuXHRcdFx0XHRoYXNPdmVybGFwID0gL14oaHVlfHNhdHVyYXRpb24pJC8udGVzdChuYW1lKSxcblx0XHRcdFx0cGFyc2VyID0gY29tcG9uZW50UGFyc2Vyc1t0eXBlXVtpbmRleF0gPSBuYW1lID09PSAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0PyBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdFx0dmFyIGN1cnJlbnQgPSB0aGlzLl9jb21wb25lbnRzWzBdO1xuXHRcdFx0XHRcdFx0dmFsdWUgPSBHcmFkaWVudC5yZWFkKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWVcblx0XHRcdFx0XHRcdFx0XHQ6IGFyZ3VtZW50cywgMCwgeyByZWFkTnVsbDogdHJ1ZSB9KTtcblx0XHRcdFx0XHRcdGlmIChjdXJyZW50ICE9PSB2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRpZiAoY3VycmVudClcblx0XHRcdFx0XHRcdFx0XHRjdXJyZW50Ll9yZW1vdmVPd25lcih0aGlzKTtcblx0XHRcdFx0XHRcdFx0aWYgKHZhbHVlKVxuXHRcdFx0XHRcdFx0XHRcdHZhbHVlLl9hZGRPd25lcih0aGlzKTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdHJldHVybiB2YWx1ZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0OiB0eXBlID09PSAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHQ/IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gUG9pbnQucmVhZChhcmd1bWVudHMsIDAsIHtcblx0XHRcdFx0XHRcdFx0XHRcdHJlYWROdWxsOiBuYW1lID09PSAnaGlnaGxpZ2h0Jyxcblx0XHRcdFx0XHRcdFx0XHRcdGNsb25lOiB0cnVlXG5cdFx0XHRcdFx0XHRcdH0pO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0OiBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0XHRcdFx0XHRyZXR1cm4gdmFsdWUgPT0gbnVsbCB8fCBpc05hTih2YWx1ZSkgPyAwIDogdmFsdWU7XG5cdFx0XHRcdFx0XHR9O1xuXG5cdFx0XHR0aGlzWydnZXQnICsgcGFydF0gPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0cmV0dXJuIHRoaXMuX3R5cGUgPT09IHR5cGVcblx0XHRcdFx0XHR8fCBoYXNPdmVybGFwICYmIC9eaHNbYmxdJC8udGVzdCh0aGlzLl90eXBlKVxuXHRcdFx0XHRcdFx0PyB0aGlzLl9jb21wb25lbnRzW2luZGV4XVxuXHRcdFx0XHRcdFx0OiB0aGlzLl9jb252ZXJ0KHR5cGUpW2luZGV4XTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXNbJ3NldCcgKyBwYXJ0XSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG5cdFx0XHRcdGlmICh0aGlzLl90eXBlICE9PSB0eXBlXG5cdFx0XHRcdFx0XHQmJiAhKGhhc092ZXJsYXAgJiYgL15oc1tibF0kLy50ZXN0KHRoaXMuX3R5cGUpKSkge1xuXHRcdFx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSB0aGlzLl9jb252ZXJ0KHR5cGUpO1xuXHRcdFx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcblx0XHRcdFx0XHR0aGlzLl90eXBlID0gdHlwZTtcblx0XHRcdFx0fVxuXHRcdFx0XHR0aGlzLl9jb21wb25lbnRzW2luZGV4XSA9IHBhcnNlci5jYWxsKHRoaXMsIHZhbHVlKTtcblx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdFx0fTtcblx0XHR9LCB0aGlzKTtcblx0fSwge1xuXHRcdF9jbGFzczogJ0NvbG9yJyxcblx0XHRfcmVhZEluZGV4OiB0cnVlLFxuXG5cdFx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gQ29sb3IoYXJnKSB7XG5cdFx0XHR2YXIgc2xpY2UgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UsXG5cdFx0XHRcdGFyZ3MgPSBhcmd1bWVudHMsXG5cdFx0XHRcdHJlYWQgPSAwLFxuXHRcdFx0XHR0eXBlLFxuXHRcdFx0XHRjb21wb25lbnRzLFxuXHRcdFx0XHRhbHBoYSxcblx0XHRcdFx0dmFsdWVzO1xuXHRcdFx0aWYgKEFycmF5LmlzQXJyYXkoYXJnKSkge1xuXHRcdFx0XHRhcmdzID0gYXJnO1xuXHRcdFx0XHRhcmcgPSBhcmdzWzBdO1xuXHRcdFx0fVxuXHRcdFx0dmFyIGFyZ1R5cGUgPSBhcmcgIT0gbnVsbCAmJiB0eXBlb2YgYXJnO1xuXHRcdFx0aWYgKGFyZ1R5cGUgPT09ICdzdHJpbmcnICYmIGFyZyBpbiB0eXBlcykge1xuXHRcdFx0XHR0eXBlID0gYXJnO1xuXHRcdFx0XHRhcmcgPSBhcmdzWzFdO1xuXHRcdFx0XHRpZiAoQXJyYXkuaXNBcnJheShhcmcpKSB7XG5cdFx0XHRcdFx0Y29tcG9uZW50cyA9IGFyZztcblx0XHRcdFx0XHRhbHBoYSA9IGFyZ3NbMl07XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHRoaXMuX19yZWFkKVxuXHRcdFx0XHRcdFx0cmVhZCA9IDE7XG5cdFx0XHRcdFx0YXJncyA9IHNsaWNlLmNhbGwoYXJncywgMSk7XG5cdFx0XHRcdFx0YXJnVHlwZSA9IHR5cGVvZiBhcmc7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmICghY29tcG9uZW50cykge1xuXHRcdFx0XHR2YWx1ZXMgPSBhcmdUeXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdFx0PyBhcmdzXG5cdFx0XHRcdFx0XHQ6IGFyZ1R5cGUgPT09ICdvYmplY3QnICYmIGFyZy5sZW5ndGggIT0gbnVsbFxuXHRcdFx0XHRcdFx0XHQ/IGFyZ1xuXHRcdFx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0XHRcdGlmICh2YWx1ZXMpIHtcblx0XHRcdFx0XHRpZiAoIXR5cGUpXG5cdFx0XHRcdFx0XHR0eXBlID0gdmFsdWVzLmxlbmd0aCA+PSAzXG5cdFx0XHRcdFx0XHRcdFx0PyAncmdiJ1xuXHRcdFx0XHRcdFx0XHRcdDogJ2dyYXknO1xuXHRcdFx0XHRcdHZhciBsZW5ndGggPSB0eXBlc1t0eXBlXS5sZW5ndGg7XG5cdFx0XHRcdFx0YWxwaGEgPSB2YWx1ZXNbbGVuZ3RoXTtcblx0XHRcdFx0XHRpZiAodGhpcy5fX3JlYWQpXG5cdFx0XHRcdFx0XHRyZWFkICs9IHZhbHVlcyA9PT0gYXJndW1lbnRzXG5cdFx0XHRcdFx0XHRcdD8gbGVuZ3RoICsgKGFscGhhICE9IG51bGwgPyAxIDogMClcblx0XHRcdFx0XHRcdFx0OiAxO1xuXHRcdFx0XHRcdGlmICh2YWx1ZXMubGVuZ3RoID4gbGVuZ3RoKVxuXHRcdFx0XHRcdFx0dmFsdWVzID0gc2xpY2UuY2FsbCh2YWx1ZXMsIDAsIGxlbmd0aCk7XG5cdFx0XHRcdH0gZWxzZSBpZiAoYXJnVHlwZSA9PT0gJ3N0cmluZycpIHtcblx0XHRcdFx0XHR0eXBlID0gJ3JnYic7XG5cdFx0XHRcdFx0Y29tcG9uZW50cyA9IGZyb21DU1MoYXJnKTtcblx0XHRcdFx0XHRpZiAoY29tcG9uZW50cy5sZW5ndGggPT09IDQpIHtcblx0XHRcdFx0XHRcdGFscGhhID0gY29tcG9uZW50c1szXTtcblx0XHRcdFx0XHRcdGNvbXBvbmVudHMubGVuZ3RoLS07XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9IGVsc2UgaWYgKGFyZ1R5cGUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0aWYgKGFyZy5jb25zdHJ1Y3RvciA9PT0gQ29sb3IpIHtcblx0XHRcdFx0XHRcdHR5cGUgPSBhcmcuX3R5cGU7XG5cdFx0XHRcdFx0XHRjb21wb25lbnRzID0gYXJnLl9jb21wb25lbnRzLnNsaWNlKCk7XG5cdFx0XHRcdFx0XHRhbHBoYSA9IGFyZy5fYWxwaGE7XG5cdFx0XHRcdFx0XHRpZiAodHlwZSA9PT0gJ2dyYWRpZW50Jykge1xuXHRcdFx0XHRcdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFyIHBvaW50ID0gY29tcG9uZW50c1tpXTtcblx0XHRcdFx0XHRcdFx0XHRpZiAocG9pbnQpXG5cdFx0XHRcdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gcG9pbnQuY2xvbmUoKTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH0gZWxzZSBpZiAoYXJnLmNvbnN0cnVjdG9yID09PSBHcmFkaWVudCkge1xuXHRcdFx0XHRcdFx0dHlwZSA9ICdncmFkaWVudCc7XG5cdFx0XHRcdFx0XHR2YWx1ZXMgPSBhcmdzO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHR0eXBlID0gJ2h1ZScgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdD8gJ2xpZ2h0bmVzcycgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0PyAnaHNsJ1xuXHRcdFx0XHRcdFx0XHRcdDogJ2hzYidcblx0XHRcdFx0XHRcdFx0OiAnZ3JhZGllbnQnIGluIGFyZyB8fCAnc3RvcHMnIGluIGFyZ1xuXHRcdFx0XHRcdFx0XHRcdFx0fHwgJ3JhZGlhbCcgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0PyAnZ3JhZGllbnQnXG5cdFx0XHRcdFx0XHRcdFx0OiAnZ3JheScgaW4gYXJnXG5cdFx0XHRcdFx0XHRcdFx0XHQ/ICdncmF5J1xuXHRcdFx0XHRcdFx0XHRcdFx0OiAncmdiJztcblx0XHRcdFx0XHRcdHZhciBwcm9wZXJ0aWVzID0gdHlwZXNbdHlwZV0sXG5cdFx0XHRcdFx0XHRcdHBhcnNlcnMgPSBjb21wb25lbnRQYXJzZXJzW3R5cGVdO1xuXHRcdFx0XHRcdFx0dGhpcy5fY29tcG9uZW50cyA9IGNvbXBvbmVudHMgPSBbXTtcblx0XHRcdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHRcdFx0dmFyIHZhbHVlID0gYXJnW3Byb3BlcnRpZXNbaV1dO1xuXHRcdFx0XHRcdFx0XHRpZiAodmFsdWUgPT0gbnVsbCAmJiBpID09PSAwICYmIHR5cGUgPT09ICdncmFkaWVudCdcblx0XHRcdFx0XHRcdFx0XHRcdCYmICdzdG9wcycgaW4gYXJnKSB7XG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSB7XG5cdFx0XHRcdFx0XHRcdFx0XHRzdG9wczogYXJnLnN0b3BzLFxuXHRcdFx0XHRcdFx0XHRcdFx0cmFkaWFsOiBhcmcucmFkaWFsXG5cdFx0XHRcdFx0XHRcdFx0fTtcblx0XHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0XHR2YWx1ZSA9IHBhcnNlcnNbaV0uY2FsbCh0aGlzLCB2YWx1ZSk7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZSAhPSBudWxsKVxuXHRcdFx0XHRcdFx0XHRcdGNvbXBvbmVudHNbaV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHRcdGFscGhhID0gYXJnLmFscGhhO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAodGhpcy5fX3JlYWQgJiYgdHlwZSlcblx0XHRcdFx0XHRyZWFkID0gMTtcblx0XHRcdH1cblx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlIHx8ICdyZ2InO1xuXHRcdFx0dGhpcy5faWQgPSBVSUQuZ2V0KENvbG9yKTtcblx0XHRcdGlmICghY29tcG9uZW50cykge1xuXHRcdFx0XHR0aGlzLl9jb21wb25lbnRzID0gY29tcG9uZW50cyA9IFtdO1xuXHRcdFx0XHR2YXIgcGFyc2VycyA9IGNvbXBvbmVudFBhcnNlcnNbdGhpcy5fdHlwZV07XG5cdFx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFyc2Vycy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSBwYXJzZXJzW2ldLmNhbGwodGhpcywgdmFsdWVzICYmIHZhbHVlc1tpXSk7XG5cdFx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0XHRjb21wb25lbnRzW2ldID0gdmFsdWU7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHRoaXMuX2NvbXBvbmVudHMgPSBjb21wb25lbnRzO1xuXHRcdFx0dGhpcy5fcHJvcGVydGllcyA9IHR5cGVzW3RoaXMuX3R5cGVdO1xuXHRcdFx0dGhpcy5fYWxwaGEgPSBhbHBoYTtcblx0XHRcdGlmICh0aGlzLl9fcmVhZClcblx0XHRcdFx0dGhpcy5fX3JlYWQgPSByZWFkO1xuXHRcdH0sXG5cblx0XHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuZ2V0Q29tcG9uZW50cygpO1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFxuXHRcdFx0XHRcdC9eKGdyYXl8cmdiKSQvLnRlc3QodGhpcy5fdHlwZSlcblx0XHRcdFx0XHRcdD8gY29tcG9uZW50c1xuXHRcdFx0XHRcdFx0OiBbdGhpcy5fdHlwZV0uY29uY2F0KGNvbXBvbmVudHMpLFxuXHRcdFx0XHRcdG9wdGlvbnMsIHRydWUsIGRpY3Rpb25hcnkpO1xuXHRcdH0sXG5cblx0XHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0XHR0aGlzLl9jYW52YXNTdHlsZSA9IG51bGw7XG5cdFx0XHRpZiAodGhpcy5fb3duZXIpXG5cdFx0XHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKDY1KTtcblx0XHR9LFxuXG5cdFx0X2NvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBjb252ZXJ0ZXI7XG5cdFx0XHRyZXR1cm4gdGhpcy5fdHlwZSA9PT0gdHlwZVxuXHRcdFx0XHRcdD8gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpXG5cdFx0XHRcdFx0OiAoY29udmVydGVyID0gY29udmVydGVyc1t0aGlzLl90eXBlICsgJy0nICsgdHlwZV0pXG5cdFx0XHRcdFx0XHQ/IGNvbnZlcnRlci5hcHBseSh0aGlzLCB0aGlzLl9jb21wb25lbnRzKVxuXHRcdFx0XHRcdFx0OiBjb252ZXJ0ZXJzWydyZ2ItJyArIHR5cGVdLmFwcGx5KHRoaXMsXG5cdFx0XHRcdFx0XHRcdGNvbnZlcnRlcnNbdGhpcy5fdHlwZSArICctcmdiJ10uYXBwbHkodGhpcyxcblx0XHRcdFx0XHRcdFx0XHR0aGlzLl9jb21wb25lbnRzKSk7XG5cdFx0fSxcblxuXHRcdGNvbnZlcnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHJldHVybiBuZXcgQ29sb3IodHlwZSwgdGhpcy5fY29udmVydCh0eXBlKSwgdGhpcy5fYWxwaGEpO1xuXHRcdH0sXG5cblx0XHRnZXRUeXBlOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl90eXBlO1xuXHRcdH0sXG5cblx0XHRzZXRUeXBlOiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR0aGlzLl9jb21wb25lbnRzID0gdGhpcy5fY29udmVydCh0eXBlKTtcblx0XHRcdHRoaXMuX3Byb3BlcnRpZXMgPSB0eXBlc1t0eXBlXTtcblx0XHRcdHRoaXMuX3R5cGUgPSB0eXBlO1xuXHRcdH0sXG5cblx0XHRnZXRDb21wb25lbnRzOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cy5zbGljZSgpO1xuXHRcdFx0aWYgKHRoaXMuX2FscGhhICE9IG51bGwpXG5cdFx0XHRcdGNvbXBvbmVudHMucHVzaCh0aGlzLl9hbHBoYSk7XG5cdFx0XHRyZXR1cm4gY29tcG9uZW50cztcblx0XHR9LFxuXG5cdFx0Z2V0QWxwaGE6IGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIHRoaXMuX2FscGhhICE9IG51bGwgPyB0aGlzLl9hbHBoYSA6IDE7XG5cdFx0fSxcblxuXHRcdHNldEFscGhhOiBmdW5jdGlvbihhbHBoYSkge1xuXHRcdFx0dGhpcy5fYWxwaGEgPSBhbHBoYSA9PSBudWxsID8gbnVsbCA6IE1hdGgubWluKE1hdGgubWF4KGFscGhhLCAwKSwgMSk7XG5cdFx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdFx0fSxcblxuXHRcdGhhc0FscGhhOiBmdW5jdGlvbigpIHtcblx0XHRcdHJldHVybiB0aGlzLl9hbHBoYSAhPSBudWxsO1xuXHRcdH0sXG5cblx0XHRlcXVhbHM6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0XHR2YXIgY29sID0gQmFzZS5pc1BsYWluVmFsdWUoY29sb3IsIHRydWUpXG5cdFx0XHRcdFx0PyBDb2xvci5yZWFkKGFyZ3VtZW50cylcblx0XHRcdFx0XHQ6IGNvbG9yO1xuXHRcdFx0cmV0dXJuIGNvbCA9PT0gdGhpcyB8fCBjb2wgJiYgdGhpcy5fY2xhc3MgPT09IGNvbC5fY2xhc3Ncblx0XHRcdFx0XHQmJiB0aGlzLl90eXBlID09PSBjb2wuX3R5cGVcblx0XHRcdFx0XHQmJiB0aGlzLl9hbHBoYSA9PT0gY29sLl9hbHBoYVxuXHRcdFx0XHRcdCYmIEJhc2UuZXF1YWxzKHRoaXMuX2NvbXBvbmVudHMsIGNvbC5fY29tcG9uZW50cylcblx0XHRcdFx0XHR8fCBmYWxzZTtcblx0XHR9LFxuXG5cdFx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0dmFyIHByb3BlcnRpZXMgPSB0aGlzLl9wcm9wZXJ0aWVzLFxuXHRcdFx0XHRwYXJ0cyA9IFtdLFxuXHRcdFx0XHRpc0dyYWRpZW50ID0gdGhpcy5fdHlwZSA9PT0gJ2dyYWRpZW50Jyxcblx0XHRcdFx0ZiA9IEZvcm1hdHRlci5pbnN0YW5jZTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcHJvcGVydGllcy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5fY29tcG9uZW50c1tpXTtcblx0XHRcdFx0aWYgKHZhbHVlICE9IG51bGwpXG5cdFx0XHRcdFx0cGFydHMucHVzaChwcm9wZXJ0aWVzW2ldICsgJzogJ1xuXHRcdFx0XHRcdFx0XHQrIChpc0dyYWRpZW50ID8gdmFsdWUgOiBmLm51bWJlcih2YWx1ZSkpKTtcblx0XHRcdH1cblx0XHRcdGlmICh0aGlzLl9hbHBoYSAhPSBudWxsKVxuXHRcdFx0XHRwYXJ0cy5wdXNoKCdhbHBoYTogJyArIGYubnVtYmVyKHRoaXMuX2FscGhhKSk7XG5cdFx0XHRyZXR1cm4gJ3sgJyArIHBhcnRzLmpvaW4oJywgJykgKyAnIH0nO1xuXHRcdH0sXG5cblx0XHR0b0NTUzogZnVuY3Rpb24oaGV4KSB7XG5cdFx0XHR2YXIgY29tcG9uZW50cyA9IHRoaXMuX2NvbnZlcnQoJ3JnYicpLFxuXHRcdFx0XHRhbHBoYSA9IGhleCB8fCB0aGlzLl9hbHBoYSA9PSBudWxsID8gMSA6IHRoaXMuX2FscGhhO1xuXHRcdFx0ZnVuY3Rpb24gY29udmVydCh2YWwpIHtcblx0XHRcdFx0cmV0dXJuIE1hdGgucm91bmQoKHZhbCA8IDAgPyAwIDogdmFsID4gMSA/IDEgOiB2YWwpICogMjU1KTtcblx0XHRcdH1cblx0XHRcdGNvbXBvbmVudHMgPSBbXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1swXSksXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1sxXSksXG5cdFx0XHRcdGNvbnZlcnQoY29tcG9uZW50c1syXSlcblx0XHRcdF07XG5cdFx0XHRpZiAoYWxwaGEgPCAxKVxuXHRcdFx0XHRjb21wb25lbnRzLnB1c2goYWxwaGEgPCAwID8gMCA6IGFscGhhKTtcblx0XHRcdHJldHVybiBoZXhcblx0XHRcdFx0XHQ/ICcjJyArICgoMSA8PCAyNCkgKyAoY29tcG9uZW50c1swXSA8PCAxNilcblx0XHRcdFx0XHRcdCsgKGNvbXBvbmVudHNbMV0gPDwgOClcblx0XHRcdFx0XHRcdCsgY29tcG9uZW50c1syXSkudG9TdHJpbmcoMTYpLnNsaWNlKDEpXG5cdFx0XHRcdFx0OiAoY29tcG9uZW50cy5sZW5ndGggPT0gNCA/ICdyZ2JhKCcgOiAncmdiKCcpXG5cdFx0XHRcdFx0XHQrIGNvbXBvbmVudHMuam9pbignLCcpICsgJyknO1xuXHRcdH0sXG5cblx0XHR0b0NhbnZhc1N0eWxlOiBmdW5jdGlvbihjdHgpIHtcblx0XHRcdGlmICh0aGlzLl9jYW52YXNTdHlsZSlcblx0XHRcdFx0cmV0dXJuIHRoaXMuX2NhbnZhc1N0eWxlO1xuXHRcdFx0aWYgKHRoaXMuX3R5cGUgIT09ICdncmFkaWVudCcpXG5cdFx0XHRcdHJldHVybiB0aGlzLl9jYW52YXNTdHlsZSA9IHRoaXMudG9DU1MoKTtcblx0XHRcdHZhciBjb21wb25lbnRzID0gdGhpcy5fY29tcG9uZW50cyxcblx0XHRcdFx0Z3JhZGllbnQgPSBjb21wb25lbnRzWzBdLFxuXHRcdFx0XHRzdG9wcyA9IGdyYWRpZW50Ll9zdG9wcyxcblx0XHRcdFx0b3JpZ2luID0gY29tcG9uZW50c1sxXSxcblx0XHRcdFx0ZGVzdGluYXRpb24gPSBjb21wb25lbnRzWzJdLFxuXHRcdFx0XHRjYW52YXNHcmFkaWVudDtcblx0XHRcdGlmIChncmFkaWVudC5fcmFkaWFsKSB7XG5cdFx0XHRcdHZhciByYWRpdXMgPSBkZXN0aW5hdGlvbi5nZXREaXN0YW5jZShvcmlnaW4pLFxuXHRcdFx0XHRcdGhpZ2hsaWdodCA9IGNvbXBvbmVudHNbM107XG5cdFx0XHRcdGlmIChoaWdobGlnaHQpIHtcblx0XHRcdFx0XHR2YXIgdmVjdG9yID0gaGlnaGxpZ2h0LnN1YnRyYWN0KG9yaWdpbik7XG5cdFx0XHRcdFx0aWYgKHZlY3Rvci5nZXRMZW5ndGgoKSA+IHJhZGl1cylcblx0XHRcdFx0XHRcdGhpZ2hsaWdodCA9IG9yaWdpbi5hZGQodmVjdG9yLm5vcm1hbGl6ZShyYWRpdXMgLSAwLjEpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHR2YXIgc3RhcnQgPSBoaWdobGlnaHQgfHwgb3JpZ2luO1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudCA9IGN0eC5jcmVhdGVSYWRpYWxHcmFkaWVudChzdGFydC54LCBzdGFydC55LFxuXHRcdFx0XHRcdFx0MCwgb3JpZ2luLngsIG9yaWdpbi55LCByYWRpdXMpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y2FudmFzR3JhZGllbnQgPSBjdHguY3JlYXRlTGluZWFyR3JhZGllbnQob3JpZ2luLngsIG9yaWdpbi55LFxuXHRcdFx0XHRcdFx0ZGVzdGluYXRpb24ueCwgZGVzdGluYXRpb24ueSk7XG5cdFx0XHR9XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHN0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHR2YXIgc3RvcCA9IHN0b3BzW2ldO1xuXHRcdFx0XHRjYW52YXNHcmFkaWVudC5hZGRDb2xvclN0b3Aoc3RvcC5fcmFtcFBvaW50LFxuXHRcdFx0XHRcdFx0c3RvcC5fY29sb3IudG9DYW52YXNTdHlsZSgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0aGlzLl9jYW52YXNTdHlsZSA9IGNhbnZhc0dyYWRpZW50O1xuXHRcdH0sXG5cblx0XHR0cmFuc2Zvcm06IGZ1bmN0aW9uKG1hdHJpeCkge1xuXHRcdFx0aWYgKHRoaXMuX3R5cGUgPT09ICdncmFkaWVudCcpIHtcblx0XHRcdFx0dmFyIGNvbXBvbmVudHMgPSB0aGlzLl9jb21wb25lbnRzO1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMSwgbCA9IGNvbXBvbmVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdFx0dmFyIHBvaW50ID0gY29tcG9uZW50c1tpXTtcblx0XHRcdFx0XHRtYXRyaXguX3RyYW5zZm9ybVBvaW50KHBvaW50LCBwb2ludCwgdHJ1ZSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0dGhpcy5fY2hhbmdlZCgpO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRzdGF0aWNzOiB7XG5cdFx0XHRfdHlwZXM6IHR5cGVzLFxuXG5cdFx0XHRyYW5kb206IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHR2YXIgcmFuZG9tID0gTWF0aC5yYW5kb207XG5cdFx0XHRcdHJldHVybiBuZXcgQ29sb3IocmFuZG9tKCksIHJhbmRvbSgpLCByYW5kb20oKSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9KTtcbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBvcGVyYXRvcnMgPSB7XG5cdFx0YWRkOiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSArIGI7XG5cdFx0fSxcblxuXHRcdHN1YnRyYWN0OiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSAtIGI7XG5cdFx0fSxcblxuXHRcdG11bHRpcGx5OiBmdW5jdGlvbihhLCBiKSB7XG5cdFx0XHRyZXR1cm4gYSAqIGI7XG5cdFx0fSxcblxuXHRcdGRpdmlkZTogZnVuY3Rpb24oYSwgYikge1xuXHRcdFx0cmV0dXJuIGEgLyBiO1xuXHRcdH1cblx0fTtcblxuXHRyZXR1cm4gQmFzZS5lYWNoKG9wZXJhdG9ycywgZnVuY3Rpb24ob3BlcmF0b3IsIG5hbWUpIHtcblx0XHR0aGlzW25hbWVdID0gZnVuY3Rpb24oY29sb3IpIHtcblx0XHRcdGNvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpO1xuXHRcdFx0dmFyIHR5cGUgPSB0aGlzLl90eXBlLFxuXHRcdFx0XHRjb21wb25lbnRzMSA9IHRoaXMuX2NvbXBvbmVudHMsXG5cdFx0XHRcdGNvbXBvbmVudHMyID0gY29sb3IuX2NvbnZlcnQodHlwZSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNvbXBvbmVudHMxLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0Y29tcG9uZW50czJbaV0gPSBvcGVyYXRvcihjb21wb25lbnRzMVtpXSwgY29tcG9uZW50czJbaV0pO1xuXHRcdFx0cmV0dXJuIG5ldyBDb2xvcih0eXBlLCBjb21wb25lbnRzMixcblx0XHRcdFx0XHR0aGlzLl9hbHBoYSAhPSBudWxsXG5cdFx0XHRcdFx0XHRcdD8gb3BlcmF0b3IodGhpcy5fYWxwaGEsIGNvbG9yLmdldEFscGhhKCkpXG5cdFx0XHRcdFx0XHRcdDogbnVsbCk7XG5cdFx0fTtcblx0fSwge1xuXHR9KTtcbn0pO1xuXG52YXIgR3JhZGllbnQgPSBCYXNlLmV4dGVuZCh7XG5cdF9jbGFzczogJ0dyYWRpZW50JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBHcmFkaWVudChzdG9wcywgcmFkaWFsKSB7XG5cdFx0dGhpcy5faWQgPSBVSUQuZ2V0KCk7XG5cdFx0aWYgKHN0b3BzICYmIHRoaXMuX3NldChzdG9wcykpXG5cdFx0XHRzdG9wcyA9IHJhZGlhbCA9IG51bGw7XG5cdFx0aWYgKCF0aGlzLl9zdG9wcylcblx0XHRcdHRoaXMuc2V0U3RvcHMoc3RvcHMgfHwgWyd3aGl0ZScsICdibGFjayddKTtcblx0XHRpZiAodGhpcy5fcmFkaWFsID09IG51bGwpXG5cdFx0XHR0aGlzLnNldFJhZGlhbCh0eXBlb2YgcmFkaWFsID09PSAnc3RyaW5nJyAmJiByYWRpYWwgPT09ICdyYWRpYWwnXG5cdFx0XHRcdFx0fHwgcmFkaWFsIHx8IGZhbHNlKTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIGRpY3Rpb25hcnkuYWRkKHRoaXMsIGZ1bmN0aW9uKCkge1xuXHRcdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9zdG9wcywgdGhpcy5fcmFkaWFsXSxcblx0XHRcdFx0XHRvcHRpb25zLCB0cnVlLCBkaWN0aW9uYXJ5KTtcblx0XHR9KTtcblx0fSxcblxuXHRfY2hhbmdlZDogZnVuY3Rpb24oKSB7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0aGlzLl9vd25lcnMgJiYgdGhpcy5fb3duZXJzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHRoaXMuX293bmVyc1tpXS5fY2hhbmdlZCgpO1xuXHR9LFxuXG5cdF9hZGRPd25lcjogZnVuY3Rpb24oY29sb3IpIHtcblx0XHRpZiAoIXRoaXMuX293bmVycylcblx0XHRcdHRoaXMuX293bmVycyA9IFtdO1xuXHRcdHRoaXMuX293bmVycy5wdXNoKGNvbG9yKTtcblx0fSxcblxuXHRfcmVtb3ZlT3duZXI6IGZ1bmN0aW9uKGNvbG9yKSB7XG5cdFx0dmFyIGluZGV4ID0gdGhpcy5fb3duZXJzID8gdGhpcy5fb3duZXJzLmluZGV4T2YoY29sb3IpIDogLTE7XG5cdFx0aWYgKGluZGV4ICE9IC0xKSB7XG5cdFx0XHR0aGlzLl9vd25lcnMuc3BsaWNlKGluZGV4LCAxKTtcblx0XHRcdGlmICh0aGlzLl9vd25lcnMubGVuZ3RoID09PSAwKVxuXHRcdFx0XHR0aGlzLl9vd25lcnMgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHR9LFxuXG5cdGNsb25lOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc3RvcHMgPSBbXTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHN0b3BzW2ldID0gdGhpcy5fc3RvcHNbaV0uY2xvbmUoKTtcblx0XHRyZXR1cm4gbmV3IEdyYWRpZW50KHN0b3BzLCB0aGlzLl9yYWRpYWwpO1xuXHR9LFxuXG5cdGdldFN0b3BzOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fc3RvcHM7XG5cdH0sXG5cblx0c2V0U3RvcHM6IGZ1bmN0aW9uKHN0b3BzKSB7XG5cdFx0aWYgKHRoaXMuc3RvcHMpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gdGhpcy5fc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHR0aGlzLl9zdG9wc1tpXS5fb3duZXIgPSB1bmRlZmluZWQ7XG5cdFx0fVxuXHRcdGlmIChzdG9wcy5sZW5ndGggPCAyKVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFxuXHRcdFx0XHRcdCdHcmFkaWVudCBzdG9wIGxpc3QgbmVlZHMgdG8gY29udGFpbiBhdCBsZWFzdCB0d28gc3RvcHMuJyk7XG5cdFx0dGhpcy5fc3RvcHMgPSBHcmFkaWVudFN0b3AucmVhZEFsbChzdG9wcywgMCwgeyBjbG9uZTogdHJ1ZSB9KTtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHN0b3AgPSB0aGlzLl9zdG9wc1tpXTtcblx0XHRcdHN0b3AuX293bmVyID0gdGhpcztcblx0XHRcdGlmIChzdG9wLl9kZWZhdWx0UmFtcClcblx0XHRcdFx0c3RvcC5zZXRSYW1wUG9pbnQoaSAvIChsIC0gMSkpO1xuXHRcdH1cblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0Z2V0UmFkaWFsOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcmFkaWFsO1xuXHR9LFxuXG5cdHNldFJhZGlhbDogZnVuY3Rpb24ocmFkaWFsKSB7XG5cdFx0dGhpcy5fcmFkaWFsID0gcmFkaWFsO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRlcXVhbHM6IGZ1bmN0aW9uKGdyYWRpZW50KSB7XG5cdFx0aWYgKGdyYWRpZW50ID09PSB0aGlzKVxuXHRcdFx0cmV0dXJuIHRydWU7XG5cdFx0aWYgKGdyYWRpZW50ICYmIHRoaXMuX2NsYXNzID09PSBncmFkaWVudC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fc3RvcHMubGVuZ3RoID09PSBncmFkaWVudC5fc3RvcHMubGVuZ3RoKSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IHRoaXMuX3N0b3BzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpZiAoIXRoaXMuX3N0b3BzW2ldLmVxdWFscyhncmFkaWVudC5fc3RvcHNbaV0pKVxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdH1cblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cbn0pO1xuXG52YXIgR3JhZGllbnRTdG9wID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdHcmFkaWVudFN0b3AnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEdyYWRpZW50U3RvcChhcmcwLCBhcmcxKSB7XG5cdFx0aWYgKGFyZzApIHtcblx0XHRcdHZhciBjb2xvciwgcmFtcFBvaW50O1xuXHRcdFx0aWYgKGFyZzEgPT09IHVuZGVmaW5lZCAmJiBBcnJheS5pc0FycmF5KGFyZzApKSB7XG5cdFx0XHRcdGNvbG9yID0gYXJnMFswXTtcblx0XHRcdFx0cmFtcFBvaW50ID0gYXJnMFsxXTtcblx0XHRcdH0gZWxzZSBpZiAoYXJnMC5jb2xvcikge1xuXHRcdFx0XHRjb2xvciA9IGFyZzAuY29sb3I7XG5cdFx0XHRcdHJhbXBQb2ludCA9IGFyZzAucmFtcFBvaW50O1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0Y29sb3IgPSBhcmcwO1xuXHRcdFx0XHRyYW1wUG9pbnQgPSBhcmcxO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5zZXRDb2xvcihjb2xvcik7XG5cdFx0XHR0aGlzLnNldFJhbXBQb2ludChyYW1wUG9pbnQpO1xuXHRcdH1cblx0fSxcblxuXHRjbG9uZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIG5ldyBHcmFkaWVudFN0b3AodGhpcy5fY29sb3IuY2xvbmUoKSwgdGhpcy5fcmFtcFBvaW50KTtcblx0fSxcblxuXHRfc2VyaWFsaXplOiBmdW5jdGlvbihvcHRpb25zLCBkaWN0aW9uYXJ5KSB7XG5cdFx0cmV0dXJuIEJhc2Uuc2VyaWFsaXplKFt0aGlzLl9jb2xvciwgdGhpcy5fcmFtcFBvaW50XSwgb3B0aW9ucywgdHJ1ZSxcblx0XHRcdFx0ZGljdGlvbmFyeSk7XG5cdH0sXG5cblx0X2NoYW5nZWQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICh0aGlzLl9vd25lcilcblx0XHRcdHRoaXMuX293bmVyLl9jaGFuZ2VkKDY1KTtcblx0fSxcblxuXHRnZXRSYW1wUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9yYW1wUG9pbnQ7XG5cdH0sXG5cblx0c2V0UmFtcFBvaW50OiBmdW5jdGlvbihyYW1wUG9pbnQpIHtcblx0XHR0aGlzLl9kZWZhdWx0UmFtcCA9IHJhbXBQb2ludCA9PSBudWxsO1xuXHRcdHRoaXMuX3JhbXBQb2ludCA9IHJhbXBQb2ludCB8fCAwO1xuXHRcdHRoaXMuX2NoYW5nZWQoKTtcblx0fSxcblxuXHRnZXRDb2xvcjogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX2NvbG9yO1xuXHR9LFxuXG5cdHNldENvbG9yOiBmdW5jdGlvbihjb2xvcikge1xuXHRcdHRoaXMuX2NvbG9yID0gQ29sb3IucmVhZChhcmd1bWVudHMpO1xuXHRcdGlmICh0aGlzLl9jb2xvciA9PT0gY29sb3IpXG5cdFx0XHR0aGlzLl9jb2xvciA9IGNvbG9yLmNsb25lKCk7XG5cdFx0dGhpcy5fY29sb3IuX293bmVyID0gdGhpcztcblx0XHR0aGlzLl9jaGFuZ2VkKCk7XG5cdH0sXG5cblx0ZXF1YWxzOiBmdW5jdGlvbihzdG9wKSB7XG5cdFx0cmV0dXJuIHN0b3AgPT09IHRoaXMgfHwgc3RvcCAmJiB0aGlzLl9jbGFzcyA9PT0gc3RvcC5fY2xhc3Ncblx0XHRcdFx0JiYgdGhpcy5fY29sb3IuZXF1YWxzKHN0b3AuX2NvbG9yKVxuXHRcdFx0XHQmJiB0aGlzLl9yYW1wUG9pbnQgPT0gc3RvcC5fcmFtcFBvaW50XG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9XG59KTtcblxudmFyIFN0eWxlID0gQmFzZS5leHRlbmQobmV3IGZ1bmN0aW9uKCkge1xuXHR2YXIgZGVmYXVsdHMgPSB7XG5cdFx0ZmlsbENvbG9yOiB1bmRlZmluZWQsXG5cdFx0c3Ryb2tlQ29sb3I6IHVuZGVmaW5lZCxcblx0XHRzdHJva2VXaWR0aDogMSxcblx0XHRzdHJva2VDYXA6ICdidXR0Jyxcblx0XHRzdHJva2VKb2luOiAnbWl0ZXInLFxuXHRcdHN0cm9rZVNjYWxpbmc6IHRydWUsXG5cdFx0bWl0ZXJMaW1pdDogMTAsXG5cdFx0ZGFzaE9mZnNldDogMCxcblx0XHRkYXNoQXJyYXk6IFtdLFxuXHRcdHdpbmRpbmdSdWxlOiAnbm9uemVybycsXG5cdFx0c2hhZG93Q29sb3I6IHVuZGVmaW5lZCxcblx0XHRzaGFkb3dCbHVyOiAwLFxuXHRcdHNoYWRvd09mZnNldDogbmV3IFBvaW50KCksXG5cdFx0c2VsZWN0ZWRDb2xvcjogdW5kZWZpbmVkLFxuXHRcdGZvbnRGYW1pbHk6ICdzYW5zLXNlcmlmJyxcblx0XHRmb250V2VpZ2h0OiAnbm9ybWFsJyxcblx0XHRmb250U2l6ZTogMTIsXG5cdFx0Zm9udDogJ3NhbnMtc2VyaWYnLFxuXHRcdGxlYWRpbmc6IG51bGwsXG5cdFx0anVzdGlmaWNhdGlvbjogJ2xlZnQnXG5cdH07XG5cblx0dmFyIGZsYWdzID0ge1xuXHRcdHN0cm9rZVdpZHRoOiA5Nyxcblx0XHRzdHJva2VDYXA6IDk3LFxuXHRcdHN0cm9rZUpvaW46IDk3LFxuXHRcdHN0cm9rZVNjYWxpbmc6IDEwNSxcblx0XHRtaXRlckxpbWl0OiA5Nyxcblx0XHRmb250RmFtaWx5OiA5LFxuXHRcdGZvbnRXZWlnaHQ6IDksXG5cdFx0Zm9udFNpemU6IDksXG5cdFx0Zm9udDogOSxcblx0XHRsZWFkaW5nOiA5LFxuXHRcdGp1c3RpZmljYXRpb246IDlcblx0fTtcblxuXHR2YXIgaXRlbSA9IHsgYmVhbnM6IHRydWUgfSxcblx0XHRmaWVsZHMgPSB7XG5cdFx0XHRfZGVmYXVsdHM6IGRlZmF1bHRzLFxuXHRcdFx0X3RleHREZWZhdWx0czogbmV3IEJhc2UoZGVmYXVsdHMsIHtcblx0XHRcdFx0ZmlsbENvbG9yOiBuZXcgQ29sb3IoKVxuXHRcdFx0fSksXG5cdFx0XHRiZWFuczogdHJ1ZVxuXHRcdH07XG5cblx0QmFzZS5lYWNoKGRlZmF1bHRzLCBmdW5jdGlvbih2YWx1ZSwga2V5KSB7XG5cdFx0dmFyIGlzQ29sb3IgPSAvQ29sb3IkLy50ZXN0KGtleSksXG5cdFx0XHRpc1BvaW50ID0ga2V5ID09PSAnc2hhZG93T2Zmc2V0Jyxcblx0XHRcdHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRcdGZsYWcgPSBmbGFnc1trZXldLFxuXHRcdFx0c2V0ID0gJ3NldCcgKyBwYXJ0LFxuXHRcdFx0Z2V0ID0gJ2dldCcgKyBwYXJ0O1xuXG5cdFx0ZmllbGRzW3NldF0gPSBmdW5jdGlvbih2YWx1ZSkge1xuXHRcdFx0dmFyIG93bmVyID0gdGhpcy5fb3duZXIsXG5cdFx0XHRcdGNoaWxkcmVuID0gb3duZXIgJiYgb3duZXIuX2NoaWxkcmVuO1xuXHRcdFx0aWYgKGNoaWxkcmVuICYmIGNoaWxkcmVuLmxlbmd0aCA+IDBcblx0XHRcdFx0XHQmJiAhKG93bmVyIGluc3RhbmNlb2YgQ29tcG91bmRQYXRoKSkge1xuXHRcdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdFx0XHRjaGlsZHJlbltpXS5fc3R5bGVbc2V0XSh2YWx1ZSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR2YXIgb2xkID0gdGhpcy5fdmFsdWVzW2tleV07XG5cdFx0XHRcdGlmIChvbGQgIT09IHZhbHVlKSB7XG5cdFx0XHRcdFx0aWYgKGlzQ29sb3IpIHtcblx0XHRcdFx0XHRcdGlmIChvbGQpXG5cdFx0XHRcdFx0XHRcdG9sZC5fb3duZXIgPSB1bmRlZmluZWQ7XG5cdFx0XHRcdFx0XHRpZiAodmFsdWUgJiYgdmFsdWUuY29uc3RydWN0b3IgPT09IENvbG9yKSB7XG5cdFx0XHRcdFx0XHRcdGlmICh2YWx1ZS5fb3duZXIpXG5cdFx0XHRcdFx0XHRcdFx0dmFsdWUgPSB2YWx1ZS5jbG9uZSgpO1xuXHRcdFx0XHRcdFx0XHR2YWx1ZS5fb3duZXIgPSBvd25lcjtcblx0XHRcdFx0XHRcdH1cblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0dGhpcy5fdmFsdWVzW2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0XHRpZiAob3duZXIpXG5cdFx0XHRcdFx0XHRvd25lci5fY2hhbmdlZChmbGFnIHx8IDY1KTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH07XG5cblx0XHRmaWVsZHNbZ2V0XSA9IGZ1bmN0aW9uKF9kb250TWVyZ2UpIHtcblx0XHRcdHZhciBvd25lciA9IHRoaXMuX293bmVyLFxuXHRcdFx0XHRjaGlsZHJlbiA9IG93bmVyICYmIG93bmVyLl9jaGlsZHJlbixcblx0XHRcdFx0dmFsdWU7XG5cdFx0XHRpZiAoIWNoaWxkcmVuIHx8IGNoaWxkcmVuLmxlbmd0aCA9PT0gMCB8fCBfZG9udE1lcmdlXG5cdFx0XHRcdFx0fHwgb3duZXIgaW5zdGFuY2VvZiBDb21wb3VuZFBhdGgpIHtcblx0XHRcdFx0dmFyIHZhbHVlID0gdGhpcy5fdmFsdWVzW2tleV07XG5cdFx0XHRcdGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG5cdFx0XHRcdFx0dmFsdWUgPSB0aGlzLl9kZWZhdWx0c1trZXldO1xuXHRcdFx0XHRcdGlmICh2YWx1ZSAmJiB2YWx1ZS5jbG9uZSlcblx0XHRcdFx0XHRcdHZhbHVlID0gdmFsdWUuY2xvbmUoKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHR2YXIgY3RvciA9IGlzQ29sb3IgPyBDb2xvciA6IGlzUG9pbnQgPyBQb2ludCA6IG51bGw7XG5cdFx0XHRcdFx0aWYgKGN0b3IgJiYgISh2YWx1ZSAmJiB2YWx1ZS5jb25zdHJ1Y3RvciA9PT0gY3RvcikpIHtcblx0XHRcdFx0XHRcdHRoaXMuX3ZhbHVlc1trZXldID0gdmFsdWUgPSBjdG9yLnJlYWQoW3ZhbHVlXSwgMCxcblx0XHRcdFx0XHRcdFx0XHR7IHJlYWROdWxsOiB0cnVlLCBjbG9uZTogdHJ1ZSB9KTtcblx0XHRcdFx0XHRcdGlmICh2YWx1ZSAmJiBpc0NvbG9yKVxuXHRcdFx0XHRcdFx0XHR2YWx1ZS5fb3duZXIgPSBvd25lcjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdFx0dmFyIGNoaWxkVmFsdWUgPSBjaGlsZHJlbltpXS5fc3R5bGVbZ2V0XSgpO1xuXHRcdFx0XHRpZiAoaSA9PT0gMCkge1xuXHRcdFx0XHRcdHZhbHVlID0gY2hpbGRWYWx1ZTtcblx0XHRcdFx0fSBlbHNlIGlmICghQmFzZS5lcXVhbHModmFsdWUsIGNoaWxkVmFsdWUpKSB7XG5cdFx0XHRcdFx0cmV0dXJuIHVuZGVmaW5lZDtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH07XG5cblx0XHRpdGVtW2dldF0gPSBmdW5jdGlvbihfZG9udE1lcmdlKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy5fc3R5bGVbZ2V0XShfZG9udE1lcmdlKTtcblx0XHR9O1xuXG5cdFx0aXRlbVtzZXRdID0gZnVuY3Rpb24odmFsdWUpIHtcblx0XHRcdHRoaXMuX3N0eWxlW3NldF0odmFsdWUpO1xuXHRcdH07XG5cdH0pO1xuXG5cdEl0ZW0uaW5qZWN0KGl0ZW0pO1xuXHRyZXR1cm4gZmllbGRzO1xufSwge1xuXHRfY2xhc3M6ICdTdHlsZScsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gU3R5bGUoc3R5bGUsIF9vd25lciwgX3Byb2plY3QpIHtcblx0XHR0aGlzLl92YWx1ZXMgPSB7fTtcblx0XHR0aGlzLl9vd25lciA9IF9vd25lcjtcblx0XHR0aGlzLl9wcm9qZWN0ID0gX293bmVyICYmIF9vd25lci5fcHJvamVjdCB8fCBfcHJvamVjdCB8fCBwYXBlci5wcm9qZWN0O1xuXHRcdGlmIChfb3duZXIgaW5zdGFuY2VvZiBUZXh0SXRlbSlcblx0XHRcdHRoaXMuX2RlZmF1bHRzID0gdGhpcy5fdGV4dERlZmF1bHRzO1xuXHRcdGlmIChzdHlsZSlcblx0XHRcdHRoaXMuc2V0KHN0eWxlKTtcblx0fSxcblxuXHRzZXQ6IGZ1bmN0aW9uKHN0eWxlKSB7XG5cdFx0dmFyIGlzU3R5bGUgPSBzdHlsZSBpbnN0YW5jZW9mIFN0eWxlLFxuXHRcdFx0dmFsdWVzID0gaXNTdHlsZSA/IHN0eWxlLl92YWx1ZXMgOiBzdHlsZTtcblx0XHRpZiAodmFsdWVzKSB7XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gdmFsdWVzKSB7XG5cdFx0XHRcdGlmIChrZXkgaW4gdGhpcy5fZGVmYXVsdHMpIHtcblx0XHRcdFx0XHR2YXIgdmFsdWUgPSB2YWx1ZXNba2V5XTtcblx0XHRcdFx0XHR0aGlzW2tleV0gPSB2YWx1ZSAmJiBpc1N0eWxlICYmIHZhbHVlLmNsb25lXG5cdFx0XHRcdFx0XHRcdD8gdmFsdWUuY2xvbmUoKSA6IHZhbHVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdGVxdWFsczogZnVuY3Rpb24oc3R5bGUpIHtcblx0XHRyZXR1cm4gc3R5bGUgPT09IHRoaXMgfHwgc3R5bGUgJiYgdGhpcy5fY2xhc3MgPT09IHN0eWxlLl9jbGFzc1xuXHRcdFx0XHQmJiBCYXNlLmVxdWFscyh0aGlzLl92YWx1ZXMsIHN0eWxlLl92YWx1ZXMpXG5cdFx0XHRcdHx8IGZhbHNlO1xuXHR9LFxuXG5cdGhhc0ZpbGw6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0RmlsbENvbG9yKCk7XG5cdH0sXG5cblx0aGFzU3Ryb2tlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gISF0aGlzLmdldFN0cm9rZUNvbG9yKCkgJiYgdGhpcy5nZXRTdHJva2VXaWR0aCgpID4gMDtcblx0fSxcblxuXHRoYXNTaGFkb3c6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAhIXRoaXMuZ2V0U2hhZG93Q29sb3IoKSAmJiB0aGlzLmdldFNoYWRvd0JsdXIoKSA+IDA7XG5cdH0sXG5cblx0Z2V0VmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3Byb2plY3QuZ2V0VmlldygpO1xuXHR9LFxuXG5cdGdldEZvbnRTdHlsZTogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuXHRcdHJldHVybiB0aGlzLmdldEZvbnRXZWlnaHQoKVxuXHRcdFx0XHQrICcgJyArIGZvbnRTaXplICsgKC9bYS16XS9pLnRlc3QoZm9udFNpemUgKyAnJykgPyAnICcgOiAncHggJylcblx0XHRcdFx0KyB0aGlzLmdldEZvbnRGYW1pbHkoKTtcblx0fSxcblxuXHRnZXRGb250OiAnI2dldEZvbnRGYW1pbHknLFxuXHRzZXRGb250OiAnI3NldEZvbnRGYW1pbHknLFxuXG5cdGdldExlYWRpbmc6IGZ1bmN0aW9uIGdldExlYWRpbmcoKSB7XG5cdFx0dmFyIGxlYWRpbmcgPSBnZXRMZWFkaW5nLmJhc2UuY2FsbCh0aGlzKSxcblx0XHRcdGZvbnRTaXplID0gdGhpcy5nZXRGb250U2l6ZSgpO1xuXHRcdGlmICgvcHR8ZW18JXxweC8udGVzdChmb250U2l6ZSkpXG5cdFx0XHRmb250U2l6ZSA9IHRoaXMuZ2V0VmlldygpLmdldFBpeGVsU2l6ZShmb250U2l6ZSk7XG5cdFx0cmV0dXJuIGxlYWRpbmcgIT0gbnVsbCA/IGxlYWRpbmcgOiBmb250U2l6ZSAqIDEuMjtcblx0fVxuXG59KTtcblxudmFyIERvbUVsZW1lbnQgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdGZ1bmN0aW9uIGhhbmRsZVByZWZpeChlbCwgbmFtZSwgc2V0LCB2YWx1ZSkge1xuXHRcdHZhciBwcmVmaXhlcyA9IFsnJywgJ3dlYmtpdCcsICdtb3onLCAnTW96JywgJ21zJywgJ28nXSxcblx0XHRcdHN1ZmZpeCA9IG5hbWVbMF0udG9VcHBlckNhc2UoKSArIG5hbWUuc3Vic3RyaW5nKDEpO1xuXHRcdGZvciAodmFyIGkgPSAwOyBpIDwgNjsgaSsrKSB7XG5cdFx0XHR2YXIgcHJlZml4ID0gcHJlZml4ZXNbaV0sXG5cdFx0XHRcdGtleSA9IHByZWZpeCA/IHByZWZpeCArIHN1ZmZpeCA6IG5hbWU7XG5cdFx0XHRpZiAoa2V5IGluIGVsKSB7XG5cdFx0XHRcdGlmIChzZXQpIHtcblx0XHRcdFx0XHRlbFtrZXldID0gdmFsdWU7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIGVsW2tleV07XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIHtcblx0XHRnZXRTdHlsZXM6IGZ1bmN0aW9uKGVsKSB7XG5cdFx0XHR2YXIgZG9jID0gZWwgJiYgZWwubm9kZVR5cGUgIT09IDkgPyBlbC5vd25lckRvY3VtZW50IDogZWwsXG5cdFx0XHRcdHZpZXcgPSBkb2MgJiYgZG9jLmRlZmF1bHRWaWV3O1xuXHRcdFx0cmV0dXJuIHZpZXcgJiYgdmlldy5nZXRDb21wdXRlZFN0eWxlKGVsLCAnJyk7XG5cdFx0fSxcblxuXHRcdGdldEJvdW5kczogZnVuY3Rpb24oZWwsIHZpZXdwb3J0KSB7XG5cdFx0XHR2YXIgZG9jID0gZWwub3duZXJEb2N1bWVudCxcblx0XHRcdFx0Ym9keSA9IGRvYy5ib2R5LFxuXHRcdFx0XHRodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudCxcblx0XHRcdFx0cmVjdDtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblx0XHRcdH0gY2F0Y2ggKGUpIHtcblx0XHRcdFx0cmVjdCA9IHsgbGVmdDogMCwgdG9wOiAwLCB3aWR0aDogMCwgaGVpZ2h0OiAwIH07XG5cdFx0XHR9XG5cdFx0XHR2YXIgeCA9IHJlY3QubGVmdCAtIChodG1sLmNsaWVudExlZnQgfHwgYm9keS5jbGllbnRMZWZ0IHx8IDApLFxuXHRcdFx0XHR5ID0gcmVjdC50b3AgLSAoaHRtbC5jbGllbnRUb3AgfHwgYm9keS5jbGllbnRUb3AgfHwgMCk7XG5cdFx0XHRpZiAoIXZpZXdwb3J0KSB7XG5cdFx0XHRcdHZhciB2aWV3ID0gZG9jLmRlZmF1bHRWaWV3O1xuXHRcdFx0XHR4ICs9IHZpZXcucGFnZVhPZmZzZXQgfHwgaHRtbC5zY3JvbGxMZWZ0IHx8IGJvZHkuc2Nyb2xsTGVmdDtcblx0XHRcdFx0eSArPSB2aWV3LnBhZ2VZT2Zmc2V0IHx8IGh0bWwuc2Nyb2xsVG9wIHx8IGJvZHkuc2Nyb2xsVG9wO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIG5ldyBSZWN0YW5nbGUoeCwgeSwgcmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuXHRcdH0sXG5cblx0XHRnZXRWaWV3cG9ydEJvdW5kczogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHZhciBkb2MgPSBlbC5vd25lckRvY3VtZW50LFxuXHRcdFx0XHR2aWV3ID0gZG9jLmRlZmF1bHRWaWV3LFxuXHRcdFx0XHRodG1sID0gZG9jLmRvY3VtZW50RWxlbWVudDtcblx0XHRcdHJldHVybiBuZXcgUmVjdGFuZ2xlKDAsIDAsXG5cdFx0XHRcdHZpZXcuaW5uZXJXaWR0aCB8fCBodG1sLmNsaWVudFdpZHRoLFxuXHRcdFx0XHR2aWV3LmlubmVySGVpZ2h0IHx8IGh0bWwuY2xpZW50SGVpZ2h0XG5cdFx0XHQpO1xuXHRcdH0sXG5cblx0XHRnZXRPZmZzZXQ6IGZ1bmN0aW9uKGVsLCB2aWV3cG9ydCkge1xuXHRcdFx0cmV0dXJuIERvbUVsZW1lbnQuZ2V0Qm91bmRzKGVsLCB2aWV3cG9ydCkuZ2V0UG9pbnQoKTtcblx0XHR9LFxuXG5cdFx0Z2V0U2l6ZTogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiBEb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdHJ1ZSkuZ2V0U2l6ZSgpO1xuXHRcdH0sXG5cblx0XHRpc0ludmlzaWJsZTogZnVuY3Rpb24oZWwpIHtcblx0XHRcdHJldHVybiBEb21FbGVtZW50LmdldFNpemUoZWwpLmVxdWFscyhuZXcgU2l6ZSgwLCAwKSk7XG5cdFx0fSxcblxuXHRcdGlzSW5WaWV3OiBmdW5jdGlvbihlbCkge1xuXHRcdFx0cmV0dXJuICFEb21FbGVtZW50LmlzSW52aXNpYmxlKGVsKVxuXHRcdFx0XHRcdCYmIERvbUVsZW1lbnQuZ2V0Vmlld3BvcnRCb3VuZHMoZWwpLmludGVyc2VjdHMoXG5cdFx0XHRcdFx0XHREb21FbGVtZW50LmdldEJvdW5kcyhlbCwgdHJ1ZSkpO1xuXHRcdH0sXG5cblx0XHRnZXRQcmVmaXhlZDogZnVuY3Rpb24oZWwsIG5hbWUpIHtcblx0XHRcdHJldHVybiBoYW5kbGVQcmVmaXgoZWwsIG5hbWUpO1xuXHRcdH0sXG5cblx0XHRzZXRQcmVmaXhlZDogZnVuY3Rpb24oZWwsIG5hbWUsIHZhbHVlKSB7XG5cdFx0XHRpZiAodHlwZW9mIG5hbWUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBuYW1lKVxuXHRcdFx0XHRcdGhhbmRsZVByZWZpeChlbCwga2V5LCB0cnVlLCBuYW1lW2tleV0pO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aGFuZGxlUHJlZml4KGVsLCBuYW1lLCB0cnVlLCB2YWx1ZSk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIERvbUV2ZW50ID0ge1xuXHRhZGQ6IGZ1bmN0aW9uKGVsLCBldmVudHMpIHtcblx0XHRmb3IgKHZhciB0eXBlIGluIGV2ZW50cykge1xuXHRcdFx0dmFyIGZ1bmMgPSBldmVudHNbdHlwZV0sXG5cdFx0XHRcdHBhcnRzID0gdHlwZS5zcGxpdCgvW1xccyxdKy9nKTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gcGFydHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRlbC5hZGRFdmVudExpc3RlbmVyKHBhcnRzW2ldLCBmdW5jLCBmYWxzZSk7XG5cdFx0fVxuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oZWwsIGV2ZW50cykge1xuXHRcdGZvciAodmFyIHR5cGUgaW4gZXZlbnRzKSB7XG5cdFx0XHR2YXIgZnVuYyA9IGV2ZW50c1t0eXBlXSxcblx0XHRcdFx0cGFydHMgPSB0eXBlLnNwbGl0KC9bXFxzLF0rL2cpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBwYXJ0cy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdGVsLnJlbW92ZUV2ZW50TGlzdGVuZXIocGFydHNbaV0sIGZ1bmMsIGZhbHNlKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UG9pbnQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHBvcyA9IGV2ZW50LnRhcmdldFRvdWNoZXNcblx0XHRcdFx0PyBldmVudC50YXJnZXRUb3VjaGVzLmxlbmd0aFxuXHRcdFx0XHRcdD8gZXZlbnQudGFyZ2V0VG91Y2hlc1swXVxuXHRcdFx0XHRcdDogZXZlbnQuY2hhbmdlZFRvdWNoZXNbMF1cblx0XHRcdFx0OiBldmVudDtcblx0XHRyZXR1cm4gbmV3IFBvaW50KFxuXHRcdFx0cG9zLnBhZ2VYIHx8IHBvcy5jbGllbnRYICsgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbExlZnQsXG5cdFx0XHRwb3MucGFnZVkgfHwgcG9zLmNsaWVudFkgKyBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc2Nyb2xsVG9wXG5cdFx0KTtcblx0fSxcblxuXHRnZXRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnRhcmdldCB8fCBldmVudC5zcmNFbGVtZW50O1xuXHR9LFxuXG5cdGdldFJlbGF0ZWRUYXJnZXQ6IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0cmV0dXJuIGV2ZW50LnJlbGF0ZWRUYXJnZXQgfHwgZXZlbnQudG9FbGVtZW50O1xuXHR9LFxuXG5cdGdldE9mZnNldDogZnVuY3Rpb24oZXZlbnQsIHRhcmdldCkge1xuXHRcdHJldHVybiBEb21FdmVudC5nZXRQb2ludChldmVudCkuc3VidHJhY3QoRG9tRWxlbWVudC5nZXRPZmZzZXQoXG5cdFx0XHRcdHRhcmdldCB8fCBEb21FdmVudC5nZXRUYXJnZXQoZXZlbnQpKSk7XG5cdH0sXG5cblx0c3RvcDogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHR9XG59O1xuXG5Eb21FdmVudC5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBuZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBuYXRpdmVSZXF1ZXN0ID0gRG9tRWxlbWVudC5nZXRQcmVmaXhlZCh3aW5kb3csICdyZXF1ZXN0QW5pbWF0aW9uRnJhbWUnKSxcblx0XHRyZXF1ZXN0ZWQgPSBmYWxzZSxcblx0XHRjYWxsYmFja3MgPSBbXSxcblx0XHRmb2N1c2VkID0gdHJ1ZSxcblx0XHR0aW1lcjtcblxuXHREb21FdmVudC5hZGQod2luZG93LCB7XG5cdFx0Zm9jdXM6IGZ1bmN0aW9uKCkge1xuXHRcdFx0Zm9jdXNlZCA9IHRydWU7XG5cdFx0fSxcblx0XHRibHVyOiBmdW5jdGlvbigpIHtcblx0XHRcdGZvY3VzZWQgPSBmYWxzZTtcblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGhhbmRsZUNhbGxiYWNrcygpIHtcblx0XHRmb3IgKHZhciBpID0gY2FsbGJhY2tzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG5cdFx0XHR2YXIgZW50cnkgPSBjYWxsYmFja3NbaV0sXG5cdFx0XHRcdGZ1bmMgPSBlbnRyeVswXSxcblx0XHRcdFx0ZWwgPSBlbnRyeVsxXTtcblx0XHRcdGlmICghZWwgfHwgKFBhcGVyU2NvcGUuZ2V0QXR0cmlidXRlKGVsLCAna2VlcGFsaXZlJykgPT0gJ3RydWUnXG5cdFx0XHRcdFx0fHwgZm9jdXNlZCkgJiYgRG9tRWxlbWVudC5pc0luVmlldyhlbCkpIHtcblx0XHRcdFx0Y2FsbGJhY2tzLnNwbGljZShpLCAxKTtcblx0XHRcdFx0ZnVuYygpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRpZiAobmF0aXZlUmVxdWVzdCkge1xuXHRcdFx0aWYgKGNhbGxiYWNrcy5sZW5ndGgpIHtcblx0XHRcdFx0bmF0aXZlUmVxdWVzdChoYW5kbGVDYWxsYmFja3MpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmVxdWVzdGVkID0gZmFsc2U7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0cmV0dXJuIGZ1bmN0aW9uKGNhbGxiYWNrLCBlbGVtZW50KSB7XG5cdFx0Y2FsbGJhY2tzLnB1c2goW2NhbGxiYWNrLCBlbGVtZW50XSk7XG5cdFx0aWYgKG5hdGl2ZVJlcXVlc3QpIHtcblx0XHRcdGlmICghcmVxdWVzdGVkKSB7XG5cdFx0XHRcdG5hdGl2ZVJlcXVlc3QoaGFuZGxlQ2FsbGJhY2tzKTtcblx0XHRcdFx0cmVxdWVzdGVkID0gdHJ1ZTtcblx0XHRcdH1cblx0XHR9IGVsc2UgaWYgKCF0aW1lcikge1xuXHRcdFx0dGltZXIgPSBzZXRJbnRlcnZhbChoYW5kbGVDYWxsYmFja3MsIDEwMDAgLyA2MCk7XG5cdFx0fVxuXHR9O1xufTtcblxudmFyIFZpZXcgPSBCYXNlLmV4dGVuZChFbWl0dGVyLCB7XG5cdF9jbGFzczogJ1ZpZXcnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIFZpZXcocHJvamVjdCwgZWxlbWVudCkge1xuXHRcdHRoaXMuX3Byb2plY3QgPSBwcm9qZWN0O1xuXHRcdHRoaXMuX3Njb3BlID0gcHJvamVjdC5fc2NvcGU7XG5cdFx0dGhpcy5fZWxlbWVudCA9IGVsZW1lbnQ7XG5cdFx0dmFyIHNpemU7XG5cdFx0aWYgKCF0aGlzLl9waXhlbFJhdGlvKVxuXHRcdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDE7XG5cdFx0dGhpcy5faWQgPSBlbGVtZW50LmdldEF0dHJpYnV0ZSgnaWQnKTtcblx0XHRpZiAodGhpcy5faWQgPT0gbnVsbClcblx0XHRcdGVsZW1lbnQuc2V0QXR0cmlidXRlKCdpZCcsIHRoaXMuX2lkID0gJ3ZpZXctJyArIFZpZXcuX2lkKyspO1xuXHRcdERvbUV2ZW50LmFkZChlbGVtZW50LCB0aGlzLl92aWV3RXZlbnRzKTtcblx0XHR2YXIgbm9uZSA9ICdub25lJztcblx0XHREb21FbGVtZW50LnNldFByZWZpeGVkKGVsZW1lbnQuc3R5bGUsIHtcblx0XHRcdHVzZXJTZWxlY3Q6IG5vbmUsXG5cdFx0XHR0b3VjaEFjdGlvbjogbm9uZSxcblx0XHRcdHRvdWNoQ2FsbG91dDogbm9uZSxcblx0XHRcdGNvbnRlbnRab29taW5nOiBub25lLFxuXHRcdFx0dXNlckRyYWc6IG5vbmUsXG5cdFx0XHR0YXBIaWdobGlnaHRDb2xvcjogJ3JnYmEoMCwwLDAsMCknXG5cdFx0fSk7XG5cblx0XHRmdW5jdGlvbiBnZXRTaXplKG5hbWUpIHtcblx0XHRcdHJldHVybiBlbGVtZW50W25hbWVdIHx8IHBhcnNlSW50KGVsZW1lbnQuZ2V0QXR0cmlidXRlKG5hbWUpLCAxMCk7XG5cdFx0fTtcblxuXHRcdGZ1bmN0aW9uIGdldENhbnZhc1NpemUoKSB7XG5cdFx0XHR2YXIgc2l6ZSA9IERvbUVsZW1lbnQuZ2V0U2l6ZShlbGVtZW50KTtcblx0XHRcdHJldHVybiBzaXplLmlzTmFOKCkgfHwgc2l6ZS5pc1plcm8oKVxuXHRcdFx0XHRcdD8gbmV3IFNpemUoZ2V0U2l6ZSgnd2lkdGgnKSwgZ2V0U2l6ZSgnaGVpZ2h0JykpXG5cdFx0XHRcdFx0OiBzaXplO1xuXHRcdH07XG5cblx0XHRpZiAoUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3Jlc2l6ZScpKSB7XG5cdFx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0XHREb21FdmVudC5hZGQod2luZG93LCB0aGlzLl93aW5kb3dFdmVudHMgPSB7XG5cdFx0XHRcdHJlc2l6ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhhdC5zZXRWaWV3U2l6ZShnZXRDYW52YXNTaXplKCkpO1xuXHRcdFx0XHR9XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0dGhpcy5fc2V0Vmlld1NpemUoc2l6ZSA9IGdldENhbnZhc1NpemUoKSk7XG5cdFx0aWYgKFBhcGVyU2NvcGUuaGFzQXR0cmlidXRlKGVsZW1lbnQsICdzdGF0cycpXG5cdFx0XHRcdCYmIHR5cGVvZiBTdGF0cyAhPT0gJ3VuZGVmaW5lZCcpIHtcblx0XHRcdHRoaXMuX3N0YXRzID0gbmV3IFN0YXRzKCk7XG5cdFx0XHR2YXIgc3RhdHMgPSB0aGlzLl9zdGF0cy5kb21FbGVtZW50LFxuXHRcdFx0XHRzdHlsZSA9IHN0YXRzLnN0eWxlLFxuXHRcdFx0XHRvZmZzZXQgPSBEb21FbGVtZW50LmdldE9mZnNldChlbGVtZW50KTtcblx0XHRcdHN0eWxlLnBvc2l0aW9uID0gJ2Fic29sdXRlJztcblx0XHRcdHN0eWxlLmxlZnQgPSBvZmZzZXQueCArICdweCc7XG5cdFx0XHRzdHlsZS50b3AgPSBvZmZzZXQueSArICdweCc7XG5cdFx0XHRkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKHN0YXRzKTtcblx0XHR9XG5cdFx0Vmlldy5fdmlld3MucHVzaCh0aGlzKTtcblx0XHRWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdID0gdGhpcztcblx0XHR0aGlzLl92aWV3U2l6ZSA9IHNpemU7XG5cdFx0KHRoaXMuX21hdHJpeCA9IG5ldyBNYXRyaXgoKSkuX293bmVyID0gdGhpcztcblx0XHR0aGlzLl96b29tID0gMTtcblx0XHRpZiAoIVZpZXcuX2ZvY3VzZWQpXG5cdFx0XHRWaWV3Ll9mb2N1c2VkID0gdGhpcztcblx0XHR0aGlzLl9mcmFtZUl0ZW1zID0ge307XG5cdFx0dGhpcy5fZnJhbWVJdGVtQ291bnQgPSAwO1xuXHR9LFxuXG5cdHJlbW92ZTogZnVuY3Rpb24oKSB7XG5cdFx0aWYgKCF0aGlzLl9wcm9qZWN0KVxuXHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdGlmIChWaWV3Ll9mb2N1c2VkID09PSB0aGlzKVxuXHRcdFx0Vmlldy5fZm9jdXNlZCA9IG51bGw7XG5cdFx0Vmlldy5fdmlld3Muc3BsaWNlKFZpZXcuX3ZpZXdzLmluZGV4T2YodGhpcyksIDEpO1xuXHRcdGRlbGV0ZSBWaWV3Ll92aWV3c0J5SWRbdGhpcy5faWRdO1xuXHRcdGlmICh0aGlzLl9wcm9qZWN0Ll92aWV3ID09PSB0aGlzKVxuXHRcdFx0dGhpcy5fcHJvamVjdC5fdmlldyA9IG51bGw7XG5cdFx0RG9tRXZlbnQucmVtb3ZlKHRoaXMuX2VsZW1lbnQsIHRoaXMuX3ZpZXdFdmVudHMpO1xuXHRcdERvbUV2ZW50LnJlbW92ZSh3aW5kb3csIHRoaXMuX3dpbmRvd0V2ZW50cyk7XG5cdFx0dGhpcy5fZWxlbWVudCA9IHRoaXMuX3Byb2plY3QgPSBudWxsO1xuXHRcdHRoaXMub2ZmKCdmcmFtZScpO1xuXHRcdHRoaXMuX2FuaW1hdGUgPSBmYWxzZTtcblx0XHR0aGlzLl9mcmFtZUl0ZW1zID0ge307XG5cdFx0cmV0dXJuIHRydWU7XG5cdH0sXG5cblx0X2V2ZW50czogQmFzZS5lYWNoKFsnb25SZXNpemUnLCAnb25Nb3VzZURvd24nLCAnb25Nb3VzZVVwJywgJ29uTW91c2VNb3ZlJ10sXG5cdFx0ZnVuY3Rpb24obmFtZSkge1xuXHRcdFx0dGhpc1tuYW1lXSA9IHtcblx0XHRcdFx0aW5zdGFsbDogZnVuY3Rpb24odHlwZSkge1xuXHRcdFx0XHRcdHRoaXMuX2luc3RhbGxFdmVudCh0eXBlKTtcblx0XHRcdFx0fSxcblxuXHRcdFx0XHR1bmluc3RhbGw6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdFx0XHR0aGlzLl91bmluc3RhbGxFdmVudCh0eXBlKTtcblx0XHRcdFx0fVxuXHRcdFx0fTtcblx0XHR9LCB7XG5cdFx0XHRvbkZyYW1lOiB7XG5cdFx0XHRcdGluc3RhbGw6IGZ1bmN0aW9uKCkge1xuXHRcdFx0XHRcdHRoaXMucGxheSgpO1xuXHRcdFx0XHR9LFxuXG5cdFx0XHRcdHVuaW5zdGFsbDogZnVuY3Rpb24oKSB7XG5cdFx0XHRcdFx0dGhpcy5wYXVzZSgpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHQpLFxuXG5cdF9hbmltYXRlOiBmYWxzZSxcblx0X3RpbWU6IDAsXG5cdF9jb3VudDogMCxcblxuXHRfcmVxdWVzdEZyYW1lOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgdGhhdCA9IHRoaXM7XG5cdFx0RG9tRXZlbnQucmVxdWVzdEFuaW1hdGlvbkZyYW1lKGZ1bmN0aW9uKCkge1xuXHRcdFx0dGhhdC5fcmVxdWVzdGVkID0gZmFsc2U7XG5cdFx0XHRpZiAoIXRoYXQuX2FuaW1hdGUpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHRoYXQuX3JlcXVlc3RGcmFtZSgpO1xuXHRcdFx0dGhhdC5faGFuZGxlRnJhbWUoKTtcblx0XHR9LCB0aGlzLl9lbGVtZW50KTtcblx0XHR0aGlzLl9yZXF1ZXN0ZWQgPSB0cnVlO1xuXHR9LFxuXG5cdF9oYW5kbGVGcmFtZTogZnVuY3Rpb24oKSB7XG5cdFx0cGFwZXIgPSB0aGlzLl9zY29wZTtcblx0XHR2YXIgbm93ID0gRGF0ZS5ub3coKSAvIDEwMDAsXG5cdFx0XHRkZWx0YSA9IHRoaXMuX2JlZm9yZSA/IG5vdyAtIHRoaXMuX2JlZm9yZSA6IDA7XG5cdFx0dGhpcy5fYmVmb3JlID0gbm93O1xuXHRcdHRoaXMuX2hhbmRsaW5nRnJhbWUgPSB0cnVlO1xuXHRcdHRoaXMuZW1pdCgnZnJhbWUnLCBuZXcgQmFzZSh7XG5cdFx0XHRkZWx0YTogZGVsdGEsXG5cdFx0XHR0aW1lOiB0aGlzLl90aW1lICs9IGRlbHRhLFxuXHRcdFx0Y291bnQ6IHRoaXMuX2NvdW50Kytcblx0XHR9KSk7XG5cdFx0aWYgKHRoaXMuX3N0YXRzKVxuXHRcdFx0dGhpcy5fc3RhdHMudXBkYXRlKCk7XG5cdFx0dGhpcy5faGFuZGxpbmdGcmFtZSA9IGZhbHNlO1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH0sXG5cblx0X2FuaW1hdGVJdGVtOiBmdW5jdGlvbihpdGVtLCBhbmltYXRlKSB7XG5cdFx0dmFyIGl0ZW1zID0gdGhpcy5fZnJhbWVJdGVtcztcblx0XHRpZiAoYW5pbWF0ZSkge1xuXHRcdFx0aXRlbXNbaXRlbS5faWRdID0ge1xuXHRcdFx0XHRpdGVtOiBpdGVtLFxuXHRcdFx0XHR0aW1lOiAwLFxuXHRcdFx0XHRjb3VudDogMFxuXHRcdFx0fTtcblx0XHRcdGlmICgrK3RoaXMuX2ZyYW1lSXRlbUNvdW50ID09PSAxKVxuXHRcdFx0XHR0aGlzLm9uKCdmcmFtZScsIHRoaXMuX2hhbmRsZUZyYW1lSXRlbXMpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRkZWxldGUgaXRlbXNbaXRlbS5faWRdO1xuXHRcdFx0aWYgKC0tdGhpcy5fZnJhbWVJdGVtQ291bnQgPT09IDApIHtcblx0XHRcdFx0dGhpcy5vZmYoJ2ZyYW1lJywgdGhpcy5faGFuZGxlRnJhbWVJdGVtcyk7XG5cdFx0XHR9XG5cdFx0fVxuXHR9LFxuXG5cdF9oYW5kbGVGcmFtZUl0ZW1zOiBmdW5jdGlvbihldmVudCkge1xuXHRcdGZvciAodmFyIGkgaW4gdGhpcy5fZnJhbWVJdGVtcykge1xuXHRcdFx0dmFyIGVudHJ5ID0gdGhpcy5fZnJhbWVJdGVtc1tpXTtcblx0XHRcdGVudHJ5Lml0ZW0uZW1pdCgnZnJhbWUnLCBuZXcgQmFzZShldmVudCwge1xuXHRcdFx0XHR0aW1lOiBlbnRyeS50aW1lICs9IGV2ZW50LmRlbHRhLFxuXHRcdFx0XHRjb3VudDogZW50cnkuY291bnQrK1xuXHRcdFx0fSkpO1xuXHRcdH1cblx0fSxcblxuXHRfdXBkYXRlOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLl9wcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0aWYgKHRoaXMuX2hhbmRsaW5nRnJhbWUpXG5cdFx0XHRyZXR1cm47XG5cdFx0aWYgKHRoaXMuX2FuaW1hdGUpIHtcblx0XHRcdHRoaXMuX2hhbmRsZUZyYW1lKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHRoaXMudXBkYXRlKCk7XG5cdFx0fVxuXHR9LFxuXG5cdF9jaGFuZ2VkOiBmdW5jdGlvbihmbGFncykge1xuXHRcdGlmIChmbGFncyAmIDEpXG5cdFx0XHR0aGlzLl9wcm9qZWN0Ll9uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdH0sXG5cblx0X3RyYW5zZm9ybTogZnVuY3Rpb24obWF0cml4KSB7XG5cdFx0dGhpcy5fbWF0cml4LmNvbmNhdGVuYXRlKG1hdHJpeCk7XG5cdFx0dGhpcy5fYm91bmRzID0gbnVsbDtcblx0XHR0aGlzLl91cGRhdGUoKTtcblx0fSxcblxuXHRnZXRFbGVtZW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fZWxlbWVudDtcblx0fSxcblxuXHRnZXRQaXhlbFJhdGlvOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbztcblx0fSxcblxuXHRnZXRSZXNvbHV0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fcGl4ZWxSYXRpbyAqIDcyO1xuXHR9LFxuXG5cdGdldFZpZXdTaXplOiBmdW5jdGlvbigpIHtcblx0XHR2YXIgc2l6ZSA9IHRoaXMuX3ZpZXdTaXplO1xuXHRcdHJldHVybiBuZXcgTGlua2VkU2l6ZShzaXplLndpZHRoLCBzaXplLmhlaWdodCwgdGhpcywgJ3NldFZpZXdTaXplJyk7XG5cdH0sXG5cblx0c2V0Vmlld1NpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHZhciBzaXplID0gU2l6ZS5yZWFkKGFyZ3VtZW50cyksXG5cdFx0XHRkZWx0YSA9IHNpemUuc3VidHJhY3QodGhpcy5fdmlld1NpemUpO1xuXHRcdGlmIChkZWx0YS5pc1plcm8oKSlcblx0XHRcdHJldHVybjtcblx0XHR0aGlzLl92aWV3U2l6ZS5zZXQoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQpO1xuXHRcdHRoaXMuX3NldFZpZXdTaXplKHNpemUpO1xuXHRcdHRoaXMuX2JvdW5kcyA9IG51bGw7XG5cdFx0dGhpcy5lbWl0KCdyZXNpemUnLCB7XG5cdFx0XHRzaXplOiBzaXplLFxuXHRcdFx0ZGVsdGE6IGRlbHRhXG5cdFx0fSk7XG5cdFx0dGhpcy5fdXBkYXRlKCk7XG5cdH0sXG5cblx0X3NldFZpZXdTaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0dmFyIGVsZW1lbnQgPSB0aGlzLl9lbGVtZW50O1xuXHRcdGVsZW1lbnQud2lkdGggPSBzaXplLndpZHRoO1xuXHRcdGVsZW1lbnQuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdH0sXG5cblx0Z2V0Qm91bmRzOiBmdW5jdGlvbigpIHtcblx0XHRpZiAoIXRoaXMuX2JvdW5kcylcblx0XHRcdHRoaXMuX2JvdW5kcyA9IHRoaXMuX21hdHJpeC5pbnZlcnRlZCgpLl90cmFuc2Zvcm1Cb3VuZHMoXG5cdFx0XHRcdFx0bmV3IFJlY3RhbmdsZShuZXcgUG9pbnQoKSwgdGhpcy5fdmlld1NpemUpKTtcblx0XHRyZXR1cm4gdGhpcy5fYm91bmRzO1xuXHR9LFxuXG5cdGdldFNpemU6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEJvdW5kcygpLmdldFNpemUoKTtcblx0fSxcblxuXHRnZXRDZW50ZXI6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLmdldEJvdW5kcygpLmdldENlbnRlcigpO1xuXHR9LFxuXG5cdHNldENlbnRlcjogZnVuY3Rpb24oKSB7XG5cdFx0dmFyIGNlbnRlciA9IFBvaW50LnJlYWQoYXJndW1lbnRzKTtcblx0XHR0aGlzLnNjcm9sbEJ5KGNlbnRlci5zdWJ0cmFjdCh0aGlzLmdldENlbnRlcigpKSk7XG5cdH0sXG5cblx0Z2V0Wm9vbTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX3pvb207XG5cdH0sXG5cblx0c2V0Wm9vbTogZnVuY3Rpb24oem9vbSkge1xuXHRcdHRoaXMuX3RyYW5zZm9ybShuZXcgTWF0cml4KCkuc2NhbGUoem9vbSAvIHRoaXMuX3pvb20sXG5cdFx0XHR0aGlzLmdldENlbnRlcigpKSk7XG5cdFx0dGhpcy5fem9vbSA9IHpvb207XG5cdH0sXG5cblx0aXNWaXNpYmxlOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gRG9tRWxlbWVudC5pc0luVmlldyh0aGlzLl9lbGVtZW50KTtcblx0fSxcblxuXHRzY3JvbGxCeTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fdHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoUG9pbnQucmVhZChhcmd1bWVudHMpLm5lZ2F0ZSgpKSk7XG5cdH0sXG5cblx0cGxheTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IHRydWU7XG5cdFx0aWYgKCF0aGlzLl9yZXF1ZXN0ZWQpXG5cdFx0XHR0aGlzLl9yZXF1ZXN0RnJhbWUoKTtcblx0fSxcblxuXHRwYXVzZTogZnVuY3Rpb24oKSB7XG5cdFx0dGhpcy5fYW5pbWF0ZSA9IGZhbHNlO1xuXHR9LFxuXG5cdGRyYXc6IGZ1bmN0aW9uKCkge1xuXHRcdHRoaXMudXBkYXRlKCk7XG5cdH0sXG5cblx0cHJvamVjdFRvVmlldzogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoUG9pbnQucmVhZChhcmd1bWVudHMpKTtcblx0fSxcblxuXHR2aWV3VG9Qcm9qZWN0OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKFBvaW50LnJlYWQoYXJndW1lbnRzKSk7XG5cdH1cblxufSwge1xuXHRzdGF0aWNzOiB7XG5cdFx0X3ZpZXdzOiBbXSxcblx0XHRfdmlld3NCeUlkOiB7fSxcblx0XHRfaWQ6IDAsXG5cblx0XHRjcmVhdGU6IGZ1bmN0aW9uKHByb2plY3QsIGVsZW1lbnQpIHtcblx0XHRcdGlmICh0eXBlb2YgZWxlbWVudCA9PT0gJ3N0cmluZycpXG5cdFx0XHRcdGVsZW1lbnQgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChlbGVtZW50KTtcblx0XHRcdHJldHVybiBuZXcgQ2FudmFzVmlldyhwcm9qZWN0LCBlbGVtZW50KTtcblx0XHR9XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciB0b29sLFxuXHRcdHByZXZGb2N1cyxcblx0XHR0ZW1wRm9jdXMsXG5cdFx0ZHJhZ2dpbmcgPSBmYWxzZTtcblxuXHRmdW5jdGlvbiBnZXRWaWV3KGV2ZW50KSB7XG5cdFx0dmFyIHRhcmdldCA9IERvbUV2ZW50LmdldFRhcmdldChldmVudCk7XG5cdFx0cmV0dXJuIHRhcmdldC5nZXRBdHRyaWJ1dGUgJiYgVmlldy5fdmlld3NCeUlkW3RhcmdldC5nZXRBdHRyaWJ1dGUoJ2lkJyldO1xuXHR9XG5cblx0ZnVuY3Rpb24gdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCkge1xuXHRcdHJldHVybiB2aWV3LnZpZXdUb1Byb2plY3QoRG9tRXZlbnQuZ2V0T2Zmc2V0KGV2ZW50LCB2aWV3Ll9lbGVtZW50KSk7XG5cdH1cblxuXHRmdW5jdGlvbiB1cGRhdGVGb2N1cygpIHtcblx0XHRpZiAoIVZpZXcuX2ZvY3VzZWQgfHwgIVZpZXcuX2ZvY3VzZWQuaXNWaXNpYmxlKCkpIHtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gVmlldy5fdmlld3MubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciB2aWV3ID0gVmlldy5fdmlld3NbaV07XG5cdFx0XHRcdGlmICh2aWV3ICYmIHZpZXcuaXNWaXNpYmxlKCkpIHtcblx0XHRcdFx0XHRWaWV3Ll9mb2N1c2VkID0gdGVtcEZvY3VzID0gdmlldztcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdGZ1bmN0aW9uIGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBwb2ludCwgZXZlbnQpIHtcblx0XHR2aWV3Ll9oYW5kbGVFdmVudCgnbW91c2Vtb3ZlJywgcG9pbnQsIGV2ZW50KTtcblx0XHR2YXIgdG9vbCA9IHZpZXcuX3Njb3BlLnRvb2w7XG5cdFx0aWYgKHRvb2wpIHtcblx0XHRcdHRvb2wuX2hhbmRsZUV2ZW50KGRyYWdnaW5nICYmIHRvb2wucmVzcG9uZHMoJ21vdXNlZHJhZycpXG5cdFx0XHRcdFx0PyAnbW91c2VkcmFnJyA6ICdtb3VzZW1vdmUnLCBwb2ludCwgZXZlbnQpO1xuXHRcdH1cblx0XHR2aWV3LnVwZGF0ZSgpO1xuXHRcdHJldHVybiB0b29sO1xuXHR9XG5cblx0dmFyIG5hdmlnYXRvciA9IHdpbmRvdy5uYXZpZ2F0b3IsXG5cdFx0bW91c2Vkb3duLCBtb3VzZW1vdmUsIG1vdXNldXA7XG5cdGlmIChuYXZpZ2F0b3IucG9pbnRlckVuYWJsZWQgfHwgbmF2aWdhdG9yLm1zUG9pbnRlckVuYWJsZWQpIHtcblx0XHRtb3VzZWRvd24gPSAncG9pbnRlcmRvd24gTVNQb2ludGVyRG93bic7XG5cdFx0bW91c2Vtb3ZlID0gJ3BvaW50ZXJtb3ZlIE1TUG9pbnRlck1vdmUnO1xuXHRcdG1vdXNldXAgPSAncG9pbnRlcnVwIHBvaW50ZXJjYW5jZWwgTVNQb2ludGVyVXAgTVNQb2ludGVyQ2FuY2VsJztcblx0fSBlbHNlIHtcblx0XHRtb3VzZWRvd24gPSAndG91Y2hzdGFydCc7XG5cdFx0bW91c2Vtb3ZlID0gJ3RvdWNobW92ZSc7XG5cdFx0bW91c2V1cCA9ICd0b3VjaGVuZCB0b3VjaGNhbmNlbCc7XG5cdFx0aWYgKCEoJ29udG91Y2hzdGFydCcgaW4gd2luZG93ICYmIG5hdmlnYXRvci51c2VyQWdlbnQubWF0Y2goXG5cdFx0XHRcdC9tb2JpbGV8dGFibGV0fGlwKGFkfGhvbmV8b2QpfGFuZHJvaWR8c2lsay9pKSkpIHtcblx0XHRcdG1vdXNlZG93biArPSAnIG1vdXNlZG93bic7XG5cdFx0XHRtb3VzZW1vdmUgKz0gJyBtb3VzZW1vdmUnO1xuXHRcdFx0bW91c2V1cCArPSAnIG1vdXNldXAnO1xuXHRcdH1cblx0fVxuXG5cdHZhciB2aWV3RXZlbnRzID0ge1xuXHRcdCdzZWxlY3RzdGFydCBkcmFnc3RhcnQnOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0aWYgKGRyYWdnaW5nKVxuXHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdH1cblx0fTtcblxuXHR2YXIgZG9jRXZlbnRzID0ge1xuXHRcdG1vdXNlb3V0OiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkLFxuXHRcdFx0XHR0YXJnZXQgPSBEb21FdmVudC5nZXRSZWxhdGVkVGFyZ2V0KGV2ZW50KTtcblx0XHRcdGlmICh2aWV3ICYmICghdGFyZ2V0IHx8IHRhcmdldC5ub2RlTmFtZSA9PT0gJ0hUTUwnKSlcblx0XHRcdFx0aGFuZGxlTW91c2VNb3ZlKHZpZXcsIHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpLCBldmVudCk7XG5cdFx0fSxcblxuXHRcdHNjcm9sbDogdXBkYXRlRm9jdXNcblx0fTtcblxuXHR2aWV3RXZlbnRzW21vdXNlZG93bl0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZCA9IGdldFZpZXcoZXZlbnQpLFxuXHRcdFx0cG9pbnQgPSB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KTtcblx0XHRkcmFnZ2luZyA9IHRydWU7XG5cdFx0dmlldy5faGFuZGxlRXZlbnQoJ21vdXNlZG93bicsIHBvaW50LCBldmVudCk7XG5cdFx0aWYgKHRvb2wgPSB2aWV3Ll9zY29wZS50b29sKVxuXHRcdFx0dG9vbC5faGFuZGxlRXZlbnQoJ21vdXNlZG93bicsIHBvaW50LCBldmVudCk7XG5cdFx0dmlldy51cGRhdGUoKTtcblx0fTtcblxuXHRkb2NFdmVudHNbbW91c2Vtb3ZlXSA9IGZ1bmN0aW9uKGV2ZW50KSB7XG5cdFx0dmFyIHZpZXcgPSBWaWV3Ll9mb2N1c2VkO1xuXHRcdGlmICghZHJhZ2dpbmcpIHtcblx0XHRcdHZhciB0YXJnZXQgPSBnZXRWaWV3KGV2ZW50KTtcblx0XHRcdGlmICh0YXJnZXQpIHtcblx0XHRcdFx0aWYgKHZpZXcgIT09IHRhcmdldClcblx0XHRcdFx0XHRoYW5kbGVNb3VzZU1vdmUodmlldywgdmlld1RvUHJvamVjdCh2aWV3LCBldmVudCksIGV2ZW50KTtcblx0XHRcdFx0cHJldkZvY3VzID0gdmlldztcblx0XHRcdFx0dmlldyA9IFZpZXcuX2ZvY3VzZWQgPSB0ZW1wRm9jdXMgPSB0YXJnZXQ7XG5cdFx0XHR9IGVsc2UgaWYgKHRlbXBGb2N1cyAmJiB0ZW1wRm9jdXMgPT09IHZpZXcpIHtcblx0XHRcdFx0dmlldyA9IFZpZXcuX2ZvY3VzZWQgPSBwcmV2Rm9jdXM7XG5cdFx0XHRcdHVwZGF0ZUZvY3VzKCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICh2aWV3KSB7XG5cdFx0XHR2YXIgcG9pbnQgPSB2aWV3VG9Qcm9qZWN0KHZpZXcsIGV2ZW50KTtcblx0XHRcdGlmIChkcmFnZ2luZyB8fCB2aWV3LmdldEJvdW5kcygpLmNvbnRhaW5zKHBvaW50KSlcblx0XHRcdFx0dG9vbCA9IGhhbmRsZU1vdXNlTW92ZSh2aWV3LCBwb2ludCwgZXZlbnQpO1xuXHRcdH1cblx0fTtcblxuXHRkb2NFdmVudHNbbW91c2V1cF0gPSBmdW5jdGlvbihldmVudCkge1xuXHRcdHZhciB2aWV3ID0gVmlldy5fZm9jdXNlZDtcblx0XHRpZiAoIXZpZXcgfHwgIWRyYWdnaW5nKVxuXHRcdFx0cmV0dXJuO1xuXHRcdHZhciBwb2ludCA9IHZpZXdUb1Byb2plY3QodmlldywgZXZlbnQpO1xuXHRcdGRyYWdnaW5nID0gZmFsc2U7XG5cdFx0dmlldy5faGFuZGxlRXZlbnQoJ21vdXNldXAnLCBwb2ludCwgZXZlbnQpO1xuXHRcdGlmICh0b29sKVxuXHRcdFx0dG9vbC5faGFuZGxlRXZlbnQoJ21vdXNldXAnLCBwb2ludCwgZXZlbnQpO1xuXHRcdHZpZXcudXBkYXRlKCk7XG5cdH07XG5cblx0RG9tRXZlbnQuYWRkKGRvY3VtZW50LCBkb2NFdmVudHMpO1xuXG5cdERvbUV2ZW50LmFkZCh3aW5kb3csIHtcblx0XHRsb2FkOiB1cGRhdGVGb2N1c1xuXHR9KTtcblxuXHR2YXIgbW91c2VGbGFncyA9IHtcblx0XHRtb3VzZWRvd246IHtcblx0XHRcdG1vdXNlZG93bjogMSxcblx0XHRcdG1vdXNlZHJhZzogMSxcblx0XHRcdGNsaWNrOiAxLFxuXHRcdFx0ZG91YmxlY2xpY2s6IDFcblx0XHR9LFxuXHRcdG1vdXNldXA6IHtcblx0XHRcdG1vdXNldXA6IDEsXG5cdFx0XHRtb3VzZWRyYWc6IDEsXG5cdFx0XHRjbGljazogMSxcblx0XHRcdGRvdWJsZWNsaWNrOiAxXG5cdFx0fSxcblx0XHRtb3VzZW1vdmU6IHtcblx0XHRcdG1vdXNlZHJhZzogMSxcblx0XHRcdG1vdXNlbW92ZTogMSxcblx0XHRcdG1vdXNlZW50ZXI6IDEsXG5cdFx0XHRtb3VzZWxlYXZlOiAxXG5cdFx0fVxuXHR9O1xuXG5cdHJldHVybiB7XG5cdFx0X3ZpZXdFdmVudHM6IHZpZXdFdmVudHMsXG5cblx0XHRfaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKCkge30sXG5cblx0XHRfaW5zdGFsbEV2ZW50OiBmdW5jdGlvbih0eXBlKSB7XG5cdFx0XHR2YXIgY291bnRlcnMgPSB0aGlzLl9ldmVudENvdW50ZXJzO1xuXHRcdFx0aWYgKGNvdW50ZXJzKSB7XG5cdFx0XHRcdGZvciAodmFyIGtleSBpbiBtb3VzZUZsYWdzKSB7XG5cdFx0XHRcdFx0Y291bnRlcnNba2V5XSA9IChjb3VudGVyc1trZXldIHx8IDApXG5cdFx0XHRcdFx0XHRcdCsgKG1vdXNlRmxhZ3Nba2V5XVt0eXBlXSB8fCAwKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRfdW5pbnN0YWxsRXZlbnQ6IGZ1bmN0aW9uKHR5cGUpIHtcblx0XHRcdHZhciBjb3VudGVycyA9IHRoaXMuX2V2ZW50Q291bnRlcnM7XG5cdFx0XHRpZiAoY291bnRlcnMpIHtcblx0XHRcdFx0Zm9yICh2YXIga2V5IGluIG1vdXNlRmxhZ3MpXG5cdFx0XHRcdFx0Y291bnRlcnNba2V5XSAtPSBtb3VzZUZsYWdzW2tleV1bdHlwZV0gfHwgMDtcblx0XHRcdH1cblx0XHR9LFxuXG5cdFx0c3RhdGljczoge1xuXHRcdFx0dXBkYXRlRm9jdXM6IHVwZGF0ZUZvY3VzXG5cdFx0fVxuXHR9O1xufSk7XG5cbnZhciBDYW52YXNWaWV3ID0gVmlldy5leHRlbmQoe1xuXHRfY2xhc3M6ICdDYW52YXNWaWV3JyxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBDYW52YXNWaWV3KHByb2plY3QsIGNhbnZhcykge1xuXHRcdGlmICghKGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50KSkge1xuXHRcdFx0dmFyIHNpemUgPSBTaXplLnJlYWQoYXJndW1lbnRzLCAxKTtcblx0XHRcdGlmIChzaXplLmlzWmVybygpKVxuXHRcdFx0XHR0aHJvdyBuZXcgRXJyb3IoXG5cdFx0XHRcdFx0XHQnQ2Fubm90IGNyZWF0ZSBDYW52YXNWaWV3IHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50OiAnXG5cdFx0XHRcdFx0XHQrIFtdLnNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKSk7XG5cdFx0XHRjYW52YXMgPSBDYW52YXNQcm92aWRlci5nZXRDYW52YXMoc2l6ZSk7XG5cdFx0fVxuXHRcdHRoaXMuX2NvbnRleHQgPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHR0aGlzLl9ldmVudENvdW50ZXJzID0ge307XG5cdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IDE7XG5cdFx0aWYgKCEvXm9mZnxmYWxzZSQvLnRlc3QoUGFwZXJTY29wZS5nZXRBdHRyaWJ1dGUoY2FudmFzLCAnaGlkcGknKSkpIHtcblx0XHRcdHZhciBkZXZpY2VSYXRpbyA9IHdpbmRvdy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEsXG5cdFx0XHRcdGJhY2tpbmdTdG9yZVJhdGlvID0gRG9tRWxlbWVudC5nZXRQcmVmaXhlZCh0aGlzLl9jb250ZXh0LFxuXHRcdFx0XHRcdFx0J2JhY2tpbmdTdG9yZVBpeGVsUmF0aW8nKSB8fCAxO1xuXHRcdFx0dGhpcy5fcGl4ZWxSYXRpbyA9IGRldmljZVJhdGlvIC8gYmFja2luZ1N0b3JlUmF0aW87XG5cdFx0fVxuXHRcdFZpZXcuY2FsbCh0aGlzLCBwcm9qZWN0LCBjYW52YXMpO1xuXHR9LFxuXG5cdF9zZXRWaWV3U2l6ZTogZnVuY3Rpb24oc2l6ZSkge1xuXHRcdHZhciBlbGVtZW50ID0gdGhpcy5fZWxlbWVudCxcblx0XHRcdHBpeGVsUmF0aW8gPSB0aGlzLl9waXhlbFJhdGlvLFxuXHRcdFx0d2lkdGggPSBzaXplLndpZHRoLFxuXHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0ZWxlbWVudC53aWR0aCA9IHdpZHRoICogcGl4ZWxSYXRpbztcblx0XHRlbGVtZW50LmhlaWdodCA9IGhlaWdodCAqIHBpeGVsUmF0aW87XG5cdFx0aWYgKHBpeGVsUmF0aW8gIT09IDEpIHtcblx0XHRcdGlmICghUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoZWxlbWVudCwgJ3Jlc2l6ZScpKSB7XG5cdFx0XHRcdHZhciBzdHlsZSA9IGVsZW1lbnQuc3R5bGU7XG5cdFx0XHRcdHN0eWxlLndpZHRoID0gd2lkdGggKyAncHgnO1xuXHRcdFx0XHRzdHlsZS5oZWlnaHQgPSBoZWlnaHQgKyAncHgnO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fY29udGV4dC5zY2FsZShwaXhlbFJhdGlvLCBwaXhlbFJhdGlvKTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0UGl4ZWxTaXplOiBmdW5jdGlvbihzaXplKSB7XG5cdFx0dmFyIGJyb3dzZXIgPSBwYXBlci5icm93c2VyLFxuXHRcdFx0cGl4ZWxzO1xuXHRcdGlmIChicm93c2VyICYmIGJyb3dzZXIuZmlyZWZveCkge1xuXHRcdFx0dmFyIHBhcmVudCA9IHRoaXMuX2VsZW1lbnQucGFyZW50Tm9kZSxcblx0XHRcdFx0dGVtcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuXHRcdFx0dGVtcC5zdHlsZS5mb250U2l6ZSA9IHNpemU7XG5cdFx0XHRwYXJlbnQuYXBwZW5kQ2hpbGQodGVtcCk7XG5cdFx0XHRwaXhlbHMgPSBwYXJzZUZsb2F0KERvbUVsZW1lbnQuZ2V0U3R5bGVzKHRlbXApLmZvbnRTaXplKTtcblx0XHRcdHBhcmVudC5yZW1vdmVDaGlsZCh0ZW1wKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dmFyIGN0eCA9IHRoaXMuX2NvbnRleHQsXG5cdFx0XHRcdHByZXZGb250ID0gY3R4LmZvbnQ7XG5cdFx0XHRjdHguZm9udCA9IHNpemUgKyAnIHNlcmlmJztcblx0XHRcdHBpeGVscyA9IHBhcnNlRmxvYXQoY3R4LmZvbnQpO1xuXHRcdFx0Y3R4LmZvbnQgPSBwcmV2Rm9udDtcblx0XHR9XG5cdFx0cmV0dXJuIHBpeGVscztcblx0fSxcblxuXHRnZXRUZXh0V2lkdGg6IGZ1bmN0aW9uKGZvbnQsIGxpbmVzKSB7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NvbnRleHQsXG5cdFx0XHRwcmV2Rm9udCA9IGN0eC5mb250LFxuXHRcdFx0d2lkdGggPSAwO1xuXHRcdGN0eC5mb250ID0gZm9udDtcblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxpbmVzLmxlbmd0aDsgaSA8IGw7IGkrKylcblx0XHRcdHdpZHRoID0gTWF0aC5tYXgod2lkdGgsIGN0eC5tZWFzdXJlVGV4dChsaW5lc1tpXSkud2lkdGgpO1xuXHRcdGN0eC5mb250ID0gcHJldkZvbnQ7XG5cdFx0cmV0dXJuIHdpZHRoO1xuXHR9LFxuXG5cdHVwZGF0ZTogZnVuY3Rpb24oZm9yY2UpIHtcblx0XHR2YXIgcHJvamVjdCA9IHRoaXMuX3Byb2plY3Q7XG5cdFx0aWYgKCFwcm9qZWN0IHx8ICFmb3JjZSAmJiAhcHJvamVjdC5fbmVlZHNVcGRhdGUpXG5cdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0dmFyIGN0eCA9IHRoaXMuX2NvbnRleHQsXG5cdFx0XHRzaXplID0gdGhpcy5fdmlld1NpemU7XG5cdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCBzaXplLndpZHRoICsgMSwgc2l6ZS5oZWlnaHQgKyAxKTtcblx0XHRwcm9qZWN0LmRyYXcoY3R4LCB0aGlzLl9tYXRyaXgsIHRoaXMuX3BpeGVsUmF0aW8pO1xuXHRcdHByb2plY3QuX25lZWRzVXBkYXRlID0gZmFsc2U7XG5cdFx0cmV0dXJuIHRydWU7XG5cdH1cbn0sXG5uZXcgZnVuY3Rpb24oKSB7XG5cdHZhciBkb3duUG9pbnQsXG5cdFx0bGFzdFBvaW50LFxuXHRcdG92ZXJQb2ludCxcblx0XHRkb3duSXRlbSxcblx0XHRsYXN0SXRlbSxcblx0XHRvdmVySXRlbSxcblx0XHRkcmFnSXRlbSxcblx0XHRkYmxDbGljayxcblx0XHRjbGlja1RpbWU7XG5cblx0ZnVuY3Rpb24gY2FsbEV2ZW50KHZpZXcsIHR5cGUsIGV2ZW50LCBwb2ludCwgdGFyZ2V0LCBsYXN0UG9pbnQpIHtcblx0XHR2YXIgaXRlbSA9IHRhcmdldCxcblx0XHRcdG1vdXNlRXZlbnQ7XG5cblx0XHRmdW5jdGlvbiBjYWxsKG9iaikge1xuXHRcdFx0aWYgKG9iai5yZXNwb25kcyh0eXBlKSkge1xuXHRcdFx0XHRpZiAoIW1vdXNlRXZlbnQpIHtcblx0XHRcdFx0XHRtb3VzZUV2ZW50ID0gbmV3IE1vdXNlRXZlbnQodHlwZSwgZXZlbnQsIHBvaW50LCB0YXJnZXQsXG5cdFx0XHRcdFx0XHRcdGxhc3RQb2ludCA/IHBvaW50LnN1YnRyYWN0KGxhc3RQb2ludCkgOiBudWxsKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZiAob2JqLmVtaXQodHlwZSwgbW91c2VFdmVudCkgJiYgbW91c2VFdmVudC5pc1N0b3BwZWQpIHtcblx0XHRcdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0d2hpbGUgKGl0ZW0pIHtcblx0XHRcdGlmIChjYWxsKGl0ZW0pKVxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdGl0ZW0gPSBpdGVtLmdldFBhcmVudCgpO1xuXHRcdH1cblx0XHRpZiAoY2FsbCh2aWV3KSlcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxuXG5cdHJldHVybiB7XG5cdFx0X2hhbmRsZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBwb2ludCwgZXZlbnQpIHtcblx0XHRcdGlmICghdGhpcy5fZXZlbnRDb3VudGVyc1t0eXBlXSlcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0dmFyIHByb2plY3QgPSB0aGlzLl9wcm9qZWN0LFxuXHRcdFx0XHRoaXQgPSBwcm9qZWN0LmhpdFRlc3QocG9pbnQsIHtcblx0XHRcdFx0XHR0b2xlcmFuY2U6IDAsXG5cdFx0XHRcdFx0ZmlsbDogdHJ1ZSxcblx0XHRcdFx0XHRzdHJva2U6IHRydWVcblx0XHRcdFx0fSksXG5cdFx0XHRcdGl0ZW0gPSBoaXQgJiYgaGl0Lml0ZW0sXG5cdFx0XHRcdHN0b3BwZWQgPSBmYWxzZTtcblx0XHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdFx0c3RvcHBlZCA9IGNhbGxFdmVudCh0aGlzLCB0eXBlLCBldmVudCwgcG9pbnQsIGl0ZW0pO1xuXHRcdFx0XHRkYmxDbGljayA9IGxhc3RJdGVtID09IGl0ZW0gJiYgKERhdGUubm93KCkgLSBjbGlja1RpbWUgPCAzMDApO1xuXHRcdFx0XHRkb3duSXRlbSA9IGxhc3RJdGVtID0gaXRlbTtcblx0XHRcdFx0ZG93blBvaW50ID0gbGFzdFBvaW50ID0gb3ZlclBvaW50ID0gcG9pbnQ7XG5cdFx0XHRcdGRyYWdJdGVtID0gIXN0b3BwZWQgJiYgaXRlbTtcblx0XHRcdFx0d2hpbGUgKGRyYWdJdGVtICYmICFkcmFnSXRlbS5yZXNwb25kcygnbW91c2VkcmFnJykpXG5cdFx0XHRcdFx0ZHJhZ0l0ZW0gPSBkcmFnSXRlbS5fcGFyZW50O1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ21vdXNldXAnOlxuXHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50LCBwb2ludCwgaXRlbSwgZG93blBvaW50KTtcblx0XHRcdFx0aWYgKGRyYWdJdGVtKSB7XG5cdFx0XHRcdFx0aWYgKGxhc3RQb2ludCAmJiAhbGFzdFBvaW50LmVxdWFscyhwb2ludCkpXG5cdFx0XHRcdFx0XHRjYWxsRXZlbnQodGhpcywgJ21vdXNlZHJhZycsIGV2ZW50LCBwb2ludCwgZHJhZ0l0ZW0sXG5cdFx0XHRcdFx0XHRcdFx0bGFzdFBvaW50KTtcblx0XHRcdFx0XHRpZiAoaXRlbSAhPT0gZHJhZ0l0ZW0pIHtcblx0XHRcdFx0XHRcdG92ZXJQb2ludCA9IHBvaW50O1xuXHRcdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZW1vdmUnLCBldmVudCwgcG9pbnQsIGl0ZW0sXG5cdFx0XHRcdFx0XHRcdFx0b3ZlclBvaW50KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYgKCFzdG9wcGVkICYmIGl0ZW0gJiYgaXRlbSA9PT0gZG93bkl0ZW0pIHtcblx0XHRcdFx0XHRjbGlja1RpbWUgPSBEYXRlLm5vdygpO1xuXHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCBkYmxDbGljayAmJiBkb3duSXRlbS5yZXNwb25kcygnZG91YmxlY2xpY2snKVxuXHRcdFx0XHRcdFx0XHQ/ICdkb3VibGVjbGljaycgOiAnY2xpY2snLCBldmVudCwgZG93blBvaW50LCBpdGVtKTtcblx0XHRcdFx0XHRkYmxDbGljayA9IGZhbHNlO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRvd25JdGVtID0gZHJhZ0l0ZW0gPSBudWxsO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ21vdXNlbW92ZSc6XG5cdFx0XHRcdGlmIChkcmFnSXRlbSlcblx0XHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsICdtb3VzZWRyYWcnLCBldmVudCwgcG9pbnQsXG5cdFx0XHRcdFx0XHRcdGRyYWdJdGVtLCBsYXN0UG9pbnQpO1xuXHRcdFx0XHRpZiAoIXN0b3BwZWQpIHtcblx0XHRcdFx0XHRpZiAoaXRlbSAhPT0gb3Zlckl0ZW0pXG5cdFx0XHRcdFx0XHRvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0XHRzdG9wcGVkID0gY2FsbEV2ZW50KHRoaXMsIHR5cGUsIGV2ZW50LCBwb2ludCwgaXRlbSxcblx0XHRcdFx0XHRcdFx0b3ZlclBvaW50KTtcblx0XHRcdFx0fVxuXHRcdFx0XHRsYXN0UG9pbnQgPSBvdmVyUG9pbnQgPSBwb2ludDtcblx0XHRcdFx0aWYgKGl0ZW0gIT09IG92ZXJJdGVtKSB7XG5cdFx0XHRcdFx0Y2FsbEV2ZW50KHRoaXMsICdtb3VzZWxlYXZlJywgZXZlbnQsIHBvaW50LCBvdmVySXRlbSk7XG5cdFx0XHRcdFx0b3Zlckl0ZW0gPSBpdGVtO1xuXHRcdFx0XHRcdGNhbGxFdmVudCh0aGlzLCAnbW91c2VlbnRlcicsIGV2ZW50LCBwb2ludCwgaXRlbSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gc3RvcHBlZDtcblx0XHR9XG5cdH07XG59KTtcblxudmFyIEV2ZW50ID0gQmFzZS5leHRlbmQoe1xuXHRfY2xhc3M6ICdFdmVudCcsXG5cblx0aW5pdGlhbGl6ZTogZnVuY3Rpb24gRXZlbnQoZXZlbnQpIHtcblx0XHR0aGlzLmV2ZW50ID0gZXZlbnQ7XG5cdH0sXG5cblx0aXNQcmV2ZW50ZWQ6IGZhbHNlLFxuXHRpc1N0b3BwZWQ6IGZhbHNlLFxuXG5cdHByZXZlbnREZWZhdWx0OiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzUHJldmVudGVkID0gdHJ1ZTtcblx0XHR0aGlzLmV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG5cdH0sXG5cblx0c3RvcFByb3BhZ2F0aW9uOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLmlzU3RvcHBlZCA9IHRydWU7XG5cdFx0dGhpcy5ldmVudC5zdG9wUHJvcGFnYXRpb24oKTtcblx0fSxcblxuXHRzdG9wOiBmdW5jdGlvbigpIHtcblx0XHR0aGlzLnN0b3BQcm9wYWdhdGlvbigpO1xuXHRcdHRoaXMucHJldmVudERlZmF1bHQoKTtcblx0fSxcblxuXHRnZXRNb2RpZmllcnM6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiBLZXkubW9kaWZpZXJzO1xuXHR9XG59KTtcblxudmFyIEtleUV2ZW50ID0gRXZlbnQuZXh0ZW5kKHtcblx0X2NsYXNzOiAnS2V5RXZlbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIEtleUV2ZW50KGRvd24sIGtleSwgY2hhcmFjdGVyLCBldmVudCkge1xuXHRcdEV2ZW50LmNhbGwodGhpcywgZXZlbnQpO1xuXHRcdHRoaXMudHlwZSA9IGRvd24gPyAna2V5ZG93bicgOiAna2V5dXAnO1xuXHRcdHRoaXMua2V5ID0ga2V5O1xuXHRcdHRoaXMuY2hhcmFjdGVyID0gY2hhcmFjdGVyO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJ7IHR5cGU6ICdcIiArIHRoaXMudHlwZVxuXHRcdFx0XHQrIFwiJywga2V5OiAnXCIgKyB0aGlzLmtleVxuXHRcdFx0XHQrIFwiJywgY2hhcmFjdGVyOiAnXCIgKyB0aGlzLmNoYXJhY3RlclxuXHRcdFx0XHQrIFwiJywgbW9kaWZpZXJzOiBcIiArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyBcIiB9XCI7XG5cdH1cbn0pO1xuXG52YXIgS2V5ID0gbmV3IGZ1bmN0aW9uKCkge1xuXG5cdHZhciBzcGVjaWFsS2V5cyA9IHtcblx0XHQ4OiAnYmFja3NwYWNlJyxcblx0XHQ5OiAndGFiJyxcblx0XHQxMzogJ2VudGVyJyxcblx0XHQxNjogJ3NoaWZ0Jyxcblx0XHQxNzogJ2NvbnRyb2wnLFxuXHRcdDE4OiAnb3B0aW9uJyxcblx0XHQxOTogJ3BhdXNlJyxcblx0XHQyMDogJ2NhcHMtbG9jaycsXG5cdFx0Mjc6ICdlc2NhcGUnLFxuXHRcdDMyOiAnc3BhY2UnLFxuXHRcdDM1OiAnZW5kJyxcblx0XHQzNjogJ2hvbWUnLFxuXHRcdDM3OiAnbGVmdCcsXG5cdFx0Mzg6ICd1cCcsXG5cdFx0Mzk6ICdyaWdodCcsXG5cdFx0NDA6ICdkb3duJyxcblx0XHQ0NjogJ2RlbGV0ZScsXG5cdFx0OTE6ICdjb21tYW5kJyxcblx0XHQ5MzogJ2NvbW1hbmQnLFxuXHRcdDIyNDogJ2NvbW1hbmQnXG5cdH0sXG5cblx0c3BlY2lhbENoYXJzID0ge1xuXHRcdDk6IHRydWUsXG5cdFx0MTM6IHRydWUsXG5cdFx0MzI6IHRydWVcblx0fSxcblxuXHRtb2RpZmllcnMgPSBuZXcgQmFzZSh7XG5cdFx0c2hpZnQ6IGZhbHNlLFxuXHRcdGNvbnRyb2w6IGZhbHNlLFxuXHRcdG9wdGlvbjogZmFsc2UsXG5cdFx0Y29tbWFuZDogZmFsc2UsXG5cdFx0Y2Fwc0xvY2s6IGZhbHNlLFxuXHRcdHNwYWNlOiBmYWxzZVxuXHR9KSxcblxuXHRjaGFyQ29kZU1hcCA9IHt9LFxuXHRrZXlNYXAgPSB7fSxcblx0Y29tbWFuZEZpeE1hcCxcblx0ZG93bkNvZGU7XG5cblx0ZnVuY3Rpb24gaGFuZGxlS2V5KGRvd24sIGtleUNvZGUsIGNoYXJDb2RlLCBldmVudCkge1xuXHRcdHZhciBjaGFyYWN0ZXIgPSBjaGFyQ29kZSA/IFN0cmluZy5mcm9tQ2hhckNvZGUoY2hhckNvZGUpIDogJycsXG5cdFx0XHRzcGVjaWFsS2V5ID0gc3BlY2lhbEtleXNba2V5Q29kZV0sXG5cdFx0XHRrZXkgPSBzcGVjaWFsS2V5IHx8IGNoYXJhY3Rlci50b0xvd2VyQ2FzZSgpLFxuXHRcdFx0dHlwZSA9IGRvd24gPyAna2V5ZG93bicgOiAna2V5dXAnLFxuXHRcdFx0dmlldyA9IFZpZXcuX2ZvY3VzZWQsXG5cdFx0XHRzY29wZSA9IHZpZXcgJiYgdmlldy5pc1Zpc2libGUoKSAmJiB2aWV3Ll9zY29wZSxcblx0XHRcdHRvb2wgPSBzY29wZSAmJiBzY29wZS50b29sLFxuXHRcdFx0bmFtZTtcblx0XHRrZXlNYXBba2V5XSA9IGRvd247XG5cdFx0aWYgKGRvd24pIHtcblx0XHRcdGNoYXJDb2RlTWFwW2tleUNvZGVdID0gY2hhckNvZGU7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGRlbGV0ZSBjaGFyQ29kZU1hcFtrZXlDb2RlXTtcblx0XHR9XG5cdFx0aWYgKHNwZWNpYWxLZXkgJiYgKG5hbWUgPSBCYXNlLmNhbWVsaXplKHNwZWNpYWxLZXkpKSBpbiBtb2RpZmllcnMpIHtcblx0XHRcdG1vZGlmaWVyc1tuYW1lXSA9IGRvd247XG5cdFx0XHR2YXIgYnJvd3NlciA9IHBhcGVyLmJyb3dzZXI7XG5cdFx0XHRpZiAobmFtZSA9PT0gJ2NvbW1hbmQnICYmIGJyb3dzZXIgJiYgYnJvd3Nlci5tYWMpIHtcblx0XHRcdFx0aWYgKGRvd24pIHtcblx0XHRcdFx0XHRjb21tYW5kRml4TWFwID0ge307XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgY29kZSBpbiBjb21tYW5kRml4TWFwKSB7XG5cdFx0XHRcdFx0XHRpZiAoY29kZSBpbiBjaGFyQ29kZU1hcClcblx0XHRcdFx0XHRcdFx0aGFuZGxlS2V5KGZhbHNlLCBjb2RlLCBjb21tYW5kRml4TWFwW2NvZGVdLCBldmVudCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGNvbW1hbmRGaXhNYXAgPSBudWxsO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSBlbHNlIGlmIChkb3duICYmIGNvbW1hbmRGaXhNYXApIHtcblx0XHRcdGNvbW1hbmRGaXhNYXBba2V5Q29kZV0gPSBjaGFyQ29kZTtcblx0XHR9XG5cdFx0aWYgKHRvb2wgJiYgdG9vbC5yZXNwb25kcyh0eXBlKSkge1xuXHRcdFx0cGFwZXIgPSBzY29wZTtcblx0XHRcdHRvb2wuZW1pdCh0eXBlLCBuZXcgS2V5RXZlbnQoZG93biwga2V5LCBjaGFyYWN0ZXIsIGV2ZW50KSk7XG5cdFx0XHRpZiAodmlldylcblx0XHRcdFx0dmlldy51cGRhdGUoKTtcblx0XHR9XG5cdH1cblxuXHREb21FdmVudC5hZGQoZG9jdW1lbnQsIHtcblx0XHRrZXlkb3duOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIGNvZGUgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlO1xuXHRcdFx0aWYgKGNvZGUgaW4gc3BlY2lhbEtleXMgfHwgbW9kaWZpZXJzLmNvbW1hbmQpIHtcblx0XHRcdFx0aGFuZGxlS2V5KHRydWUsIGNvZGUsXG5cdFx0XHRcdFx0XHRjb2RlIGluIHNwZWNpYWxDaGFycyB8fCBtb2RpZmllcnMuY29tbWFuZCA/IGNvZGUgOiAwLFxuXHRcdFx0XHRcdFx0ZXZlbnQpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0ZG93bkNvZGUgPSBjb2RlO1xuXHRcdFx0fVxuXHRcdH0sXG5cblx0XHRrZXlwcmVzczogZnVuY3Rpb24oZXZlbnQpIHtcblx0XHRcdGlmIChkb3duQ29kZSAhPSBudWxsKSB7XG5cdFx0XHRcdGhhbmRsZUtleSh0cnVlLCBkb3duQ29kZSwgZXZlbnQud2hpY2ggfHwgZXZlbnQua2V5Q29kZSwgZXZlbnQpO1xuXHRcdFx0XHRkb3duQ29kZSA9IG51bGw7XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGtleXVwOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0dmFyIGNvZGUgPSBldmVudC53aGljaCB8fCBldmVudC5rZXlDb2RlO1xuXHRcdFx0aWYgKGNvZGUgaW4gY2hhckNvZGVNYXApXG5cdFx0XHRcdGhhbmRsZUtleShmYWxzZSwgY29kZSwgY2hhckNvZGVNYXBbY29kZV0sIGV2ZW50KTtcblx0XHR9XG5cdH0pO1xuXG5cdERvbUV2ZW50LmFkZCh3aW5kb3csIHtcblx0XHRibHVyOiBmdW5jdGlvbihldmVudCkge1xuXHRcdFx0Zm9yICh2YXIgY29kZSBpbiBjaGFyQ29kZU1hcClcblx0XHRcdFx0aGFuZGxlS2V5KGZhbHNlLCBjb2RlLCBjaGFyQ29kZU1hcFtjb2RlXSwgZXZlbnQpO1xuXHRcdH1cblx0fSk7XG5cblx0cmV0dXJuIHtcblx0XHRtb2RpZmllcnM6IG1vZGlmaWVycyxcblxuXHRcdGlzRG93bjogZnVuY3Rpb24oa2V5KSB7XG5cdFx0XHRyZXR1cm4gISFrZXlNYXBba2V5XTtcblx0XHR9XG5cdH07XG59O1xuXG52YXIgTW91c2VFdmVudCA9IEV2ZW50LmV4dGVuZCh7XG5cdF9jbGFzczogJ01vdXNlRXZlbnQnLFxuXG5cdGluaXRpYWxpemU6IGZ1bmN0aW9uIE1vdXNlRXZlbnQodHlwZSwgZXZlbnQsIHBvaW50LCB0YXJnZXQsIGRlbHRhKSB7XG5cdFx0RXZlbnQuY2FsbCh0aGlzLCBldmVudCk7XG5cdFx0dGhpcy50eXBlID0gdHlwZTtcblx0XHR0aGlzLnBvaW50ID0gcG9pbnQ7XG5cdFx0dGhpcy50YXJnZXQgPSB0YXJnZXQ7XG5cdFx0dGhpcy5kZWx0YSA9IGRlbHRhO1xuXHR9LFxuXG5cdHRvU3RyaW5nOiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gXCJ7IHR5cGU6ICdcIiArIHRoaXMudHlwZVxuXHRcdFx0XHQrIFwiJywgcG9pbnQ6IFwiICsgdGhpcy5wb2ludFxuXHRcdFx0XHQrICcsIHRhcmdldDogJyArIHRoaXMudGFyZ2V0XG5cdFx0XHRcdCsgKHRoaXMuZGVsdGEgPyAnLCBkZWx0YTogJyArIHRoaXMuZGVsdGEgOiAnJylcblx0XHRcdFx0KyAnLCBtb2RpZmllcnM6ICcgKyB0aGlzLmdldE1vZGlmaWVycygpXG5cdFx0XHRcdCsgJyB9Jztcblx0fVxufSk7XG5cbnZhciBUb29sRXZlbnQgPSBFdmVudC5leHRlbmQoe1xuXHRfY2xhc3M6ICdUb29sRXZlbnQnLFxuXHRfaXRlbTogbnVsbCxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBUb29sRXZlbnQodG9vbCwgdHlwZSwgZXZlbnQpIHtcblx0XHR0aGlzLnRvb2wgPSB0b29sO1xuXHRcdHRoaXMudHlwZSA9IHR5cGU7XG5cdFx0dGhpcy5ldmVudCA9IGV2ZW50O1xuXHR9LFxuXG5cdF9jaG9vc2VQb2ludDogZnVuY3Rpb24ocG9pbnQsIHRvb2xQb2ludCkge1xuXHRcdHJldHVybiBwb2ludCA/IHBvaW50IDogdG9vbFBvaW50ID8gdG9vbFBvaW50LmNsb25lKCkgOiBudWxsO1xuXHR9LFxuXG5cdGdldFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hvb3NlUG9pbnQodGhpcy5fcG9pbnQsIHRoaXMudG9vbC5fcG9pbnQpO1xuXHR9LFxuXG5cdHNldFBvaW50OiBmdW5jdGlvbihwb2ludCkge1xuXHRcdHRoaXMuX3BvaW50ID0gcG9pbnQ7XG5cdH0sXG5cblx0Z2V0TGFzdFBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hvb3NlUG9pbnQodGhpcy5fbGFzdFBvaW50LCB0aGlzLnRvb2wuX2xhc3RQb2ludCk7XG5cdH0sXG5cblx0c2V0TGFzdFBvaW50OiBmdW5jdGlvbihsYXN0UG9pbnQpIHtcblx0XHR0aGlzLl9sYXN0UG9pbnQgPSBsYXN0UG9pbnQ7XG5cdH0sXG5cblx0Z2V0RG93blBvaW50OiBmdW5jdGlvbigpIHtcblx0XHRyZXR1cm4gdGhpcy5fY2hvb3NlUG9pbnQodGhpcy5fZG93blBvaW50LCB0aGlzLnRvb2wuX2Rvd25Qb2ludCk7XG5cdH0sXG5cblx0c2V0RG93blBvaW50OiBmdW5jdGlvbihkb3duUG9pbnQpIHtcblx0XHR0aGlzLl9kb3duUG9pbnQgPSBkb3duUG9pbnQ7XG5cdH0sXG5cblx0Z2V0TWlkZGxlUG9pbnQ6IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5fbWlkZGxlUG9pbnQgJiYgdGhpcy50b29sLl9sYXN0UG9pbnQpIHtcblx0XHRcdHJldHVybiB0aGlzLnRvb2wuX3BvaW50LmFkZCh0aGlzLnRvb2wuX2xhc3RQb2ludCkuZGl2aWRlKDIpO1xuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5fbWlkZGxlUG9pbnQ7XG5cdH0sXG5cblx0c2V0TWlkZGxlUG9pbnQ6IGZ1bmN0aW9uKG1pZGRsZVBvaW50KSB7XG5cdFx0dGhpcy5fbWlkZGxlUG9pbnQgPSBtaWRkbGVQb2ludDtcblx0fSxcblxuXHRnZXREZWx0YTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuICF0aGlzLl9kZWx0YSAmJiB0aGlzLnRvb2wuX2xhc3RQb2ludFxuXHRcdFx0XHQ/IHRoaXMudG9vbC5fcG9pbnQuc3VidHJhY3QodGhpcy50b29sLl9sYXN0UG9pbnQpXG5cdFx0XHRcdDogdGhpcy5fZGVsdGE7XG5cdH0sXG5cblx0c2V0RGVsdGE6IGZ1bmN0aW9uKGRlbHRhKSB7XG5cdFx0dGhpcy5fZGVsdGEgPSBkZWx0YTtcblx0fSxcblxuXHRnZXRDb3VudDogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIC9ebW91c2UoZG93bnx1cCkkLy50ZXN0KHRoaXMudHlwZSlcblx0XHRcdFx0PyB0aGlzLnRvb2wuX2Rvd25Db3VudFxuXHRcdFx0XHQ6IHRoaXMudG9vbC5fY291bnQ7XG5cdH0sXG5cblx0c2V0Q291bnQ6IGZ1bmN0aW9uKGNvdW50KSB7XG5cdFx0dGhpcy50b29sWy9ebW91c2UoZG93bnx1cCkkLy50ZXN0KHRoaXMudHlwZSkgPyAnZG93bkNvdW50JyA6ICdjb3VudCddXG5cdFx0XHQ9IGNvdW50O1xuXHR9LFxuXG5cdGdldEl0ZW06IGZ1bmN0aW9uKCkge1xuXHRcdGlmICghdGhpcy5faXRlbSkge1xuXHRcdFx0dmFyIHJlc3VsdCA9IHRoaXMudG9vbC5fc2NvcGUucHJvamVjdC5oaXRUZXN0KHRoaXMuZ2V0UG9pbnQoKSk7XG5cdFx0XHRpZiAocmVzdWx0KSB7XG5cdFx0XHRcdHZhciBpdGVtID0gcmVzdWx0Lml0ZW0sXG5cdFx0XHRcdFx0cGFyZW50ID0gaXRlbS5fcGFyZW50O1xuXHRcdFx0XHR3aGlsZSAoL14oR3JvdXB8Q29tcG91bmRQYXRoKSQvLnRlc3QocGFyZW50Ll9jbGFzcykpIHtcblx0XHRcdFx0XHRpdGVtID0gcGFyZW50O1xuXHRcdFx0XHRcdHBhcmVudCA9IHBhcmVudC5fcGFyZW50O1xuXHRcdFx0XHR9XG5cdFx0XHRcdHRoaXMuX2l0ZW0gPSBpdGVtO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRyZXR1cm4gdGhpcy5faXRlbTtcblx0fSxcblxuXHRzZXRJdGVtOiBmdW5jdGlvbihpdGVtKSB7XG5cdFx0dGhpcy5faXRlbSA9IGl0ZW07XG5cdH0sXG5cblx0dG9TdHJpbmc6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiAneyB0eXBlOiAnICsgdGhpcy50eXBlXG5cdFx0XHRcdCsgJywgcG9pbnQ6ICcgKyB0aGlzLmdldFBvaW50KClcblx0XHRcdFx0KyAnLCBjb3VudDogJyArIHRoaXMuZ2V0Q291bnQoKVxuXHRcdFx0XHQrICcsIG1vZGlmaWVyczogJyArIHRoaXMuZ2V0TW9kaWZpZXJzKClcblx0XHRcdFx0KyAnIH0nO1xuXHR9XG59KTtcblxudmFyIFRvb2wgPSBQYXBlclNjb3BlSXRlbS5leHRlbmQoe1xuXHRfY2xhc3M6ICdUb29sJyxcblx0X2xpc3Q6ICd0b29scycsXG5cdF9yZWZlcmVuY2U6ICd0b29sJyxcblx0X2V2ZW50czogWyAnb25BY3RpdmF0ZScsICdvbkRlYWN0aXZhdGUnLCAnb25FZGl0T3B0aW9ucycsXG5cdFx0XHQnb25Nb3VzZURvd24nLCAnb25Nb3VzZVVwJywgJ29uTW91c2VEcmFnJywgJ29uTW91c2VNb3ZlJyxcblx0XHRcdCdvbktleURvd24nLCAnb25LZXlVcCcgXSxcblxuXHRpbml0aWFsaXplOiBmdW5jdGlvbiBUb29sKHByb3BzKSB7XG5cdFx0UGFwZXJTY29wZUl0ZW0uY2FsbCh0aGlzKTtcblx0XHR0aGlzLl9maXJzdE1vdmUgPSB0cnVlO1xuXHRcdHRoaXMuX2NvdW50ID0gMDtcblx0XHR0aGlzLl9kb3duQ291bnQgPSAwO1xuXHRcdHRoaXMuX3NldChwcm9wcyk7XG5cdH0sXG5cblx0Z2V0TWluRGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9taW5EaXN0YW5jZTtcblx0fSxcblxuXHRzZXRNaW5EaXN0YW5jZTogZnVuY3Rpb24obWluRGlzdGFuY2UpIHtcblx0XHR0aGlzLl9taW5EaXN0YW5jZSA9IG1pbkRpc3RhbmNlO1xuXHRcdGlmIChtaW5EaXN0YW5jZSAhPSBudWxsICYmIHRoaXMuX21heERpc3RhbmNlICE9IG51bGxcblx0XHRcdFx0JiYgbWluRGlzdGFuY2UgPiB0aGlzLl9tYXhEaXN0YW5jZSkge1xuXHRcdFx0dGhpcy5fbWF4RGlzdGFuY2UgPSBtaW5EaXN0YW5jZTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0TWF4RGlzdGFuY2U6IGZ1bmN0aW9uKCkge1xuXHRcdHJldHVybiB0aGlzLl9tYXhEaXN0YW5jZTtcblx0fSxcblxuXHRzZXRNYXhEaXN0YW5jZTogZnVuY3Rpb24obWF4RGlzdGFuY2UpIHtcblx0XHR0aGlzLl9tYXhEaXN0YW5jZSA9IG1heERpc3RhbmNlO1xuXHRcdGlmICh0aGlzLl9taW5EaXN0YW5jZSAhPSBudWxsICYmIG1heERpc3RhbmNlICE9IG51bGxcblx0XHRcdFx0JiYgbWF4RGlzdGFuY2UgPCB0aGlzLl9taW5EaXN0YW5jZSkge1xuXHRcdFx0dGhpcy5fbWluRGlzdGFuY2UgPSBtYXhEaXN0YW5jZTtcblx0XHR9XG5cdH0sXG5cblx0Z2V0Rml4ZWREaXN0YW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0cmV0dXJuIHRoaXMuX21pbkRpc3RhbmNlID09IHRoaXMuX21heERpc3RhbmNlXG5cdFx0XHQ/IHRoaXMuX21pbkRpc3RhbmNlIDogbnVsbDtcblx0fSxcblxuXHRzZXRGaXhlZERpc3RhbmNlOiBmdW5jdGlvbihkaXN0YW5jZSkge1xuXHRcdHRoaXMuX21pbkRpc3RhbmNlID0gdGhpcy5fbWF4RGlzdGFuY2UgPSBkaXN0YW5jZTtcblx0fSxcblxuXHRfdXBkYXRlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHBvaW50LCBtaW5EaXN0YW5jZSwgbWF4RGlzdGFuY2UsIHN0YXJ0LFxuXHRcdFx0bmVlZHNDaGFuZ2UsIG1hdGNoTWF4RGlzdGFuY2UpIHtcblx0XHRpZiAoIXN0YXJ0KSB7XG5cdFx0XHRpZiAobWluRGlzdGFuY2UgIT0gbnVsbCB8fCBtYXhEaXN0YW5jZSAhPSBudWxsKSB7XG5cdFx0XHRcdHZhciBtaW5EaXN0ID0gbWluRGlzdGFuY2UgIT0gbnVsbCA/IG1pbkRpc3RhbmNlIDogMCxcblx0XHRcdFx0XHR2ZWN0b3IgPSBwb2ludC5zdWJ0cmFjdCh0aGlzLl9wb2ludCksXG5cdFx0XHRcdFx0ZGlzdGFuY2UgPSB2ZWN0b3IuZ2V0TGVuZ3RoKCk7XG5cdFx0XHRcdGlmIChkaXN0YW5jZSA8IG1pbkRpc3QpXG5cdFx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0XHRpZiAobWF4RGlzdGFuY2UgIT0gbnVsbCAmJiBtYXhEaXN0YW5jZSAhPSAwKSB7XG5cdFx0XHRcdFx0aWYgKGRpc3RhbmNlID4gbWF4RGlzdGFuY2UpIHtcblx0XHRcdFx0XHRcdHBvaW50ID0gdGhpcy5fcG9pbnQuYWRkKHZlY3Rvci5ub3JtYWxpemUobWF4RGlzdGFuY2UpKTtcblx0XHRcdFx0XHR9IGVsc2UgaWYgKG1hdGNoTWF4RGlzdGFuY2UpIHtcblx0XHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChuZWVkc0NoYW5nZSAmJiBwb2ludC5lcXVhbHModGhpcy5fcG9pbnQpKVxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cdFx0fVxuXHRcdHRoaXMuX2xhc3RQb2ludCA9IHN0YXJ0ICYmIHR5cGUgPT0gJ21vdXNlbW92ZScgPyBwb2ludCA6IHRoaXMuX3BvaW50O1xuXHRcdHRoaXMuX3BvaW50ID0gcG9pbnQ7XG5cdFx0c3dpdGNoICh0eXBlKSB7XG5cdFx0Y2FzZSAnbW91c2Vkb3duJzpcblx0XHRcdHRoaXMuX2xhc3RQb2ludCA9IHRoaXMuX2Rvd25Qb2ludDtcblx0XHRcdHRoaXMuX2Rvd25Qb2ludCA9IHRoaXMuX3BvaW50O1xuXHRcdFx0dGhpcy5fZG93bkNvdW50Kys7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdtb3VzZXVwJzpcblx0XHRcdHRoaXMuX2xhc3RQb2ludCA9IHRoaXMuX2Rvd25Qb2ludDtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHR0aGlzLl9jb3VudCA9IHN0YXJ0ID8gMCA6IHRoaXMuX2NvdW50ICsgMTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSxcblxuXHRfZmlyZUV2ZW50OiBmdW5jdGlvbih0eXBlLCBldmVudCkge1xuXHRcdHZhciBzZXRzID0gcGFwZXIucHJvamVjdC5fcmVtb3ZlU2V0cztcblx0XHRpZiAoc2V0cykge1xuXHRcdFx0aWYgKHR5cGUgPT09ICdtb3VzZXVwJylcblx0XHRcdFx0c2V0cy5tb3VzZWRyYWcgPSBudWxsO1xuXHRcdFx0dmFyIHNldCA9IHNldHNbdHlwZV07XG5cdFx0XHRpZiAoc2V0KSB7XG5cdFx0XHRcdGZvciAodmFyIGlkIGluIHNldCkge1xuXHRcdFx0XHRcdHZhciBpdGVtID0gc2V0W2lkXTtcblx0XHRcdFx0XHRmb3IgKHZhciBrZXkgaW4gc2V0cykge1xuXHRcdFx0XHRcdFx0dmFyIG90aGVyID0gc2V0c1trZXldO1xuXHRcdFx0XHRcdFx0aWYgKG90aGVyICYmIG90aGVyICE9IHNldClcblx0XHRcdFx0XHRcdFx0ZGVsZXRlIG90aGVyW2l0ZW0uX2lkXTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0aXRlbS5yZW1vdmUoKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRzZXRzW3R5cGVdID0gbnVsbDtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHRoaXMucmVzcG9uZHModHlwZSlcblx0XHRcdFx0JiYgdGhpcy5lbWl0KHR5cGUsIG5ldyBUb29sRXZlbnQodGhpcywgdHlwZSwgZXZlbnQpKTtcblx0fSxcblxuXHRfaGFuZGxlRXZlbnQ6IGZ1bmN0aW9uKHR5cGUsIHBvaW50LCBldmVudCkge1xuXHRcdHBhcGVyID0gdGhpcy5fc2NvcGU7XG5cdFx0dmFyIGNhbGxlZCA9IGZhbHNlO1xuXHRcdHN3aXRjaCAodHlwZSkge1xuXHRcdGNhc2UgJ21vdXNlZG93bic6XG5cdFx0XHR0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgbnVsbCwgbnVsbCwgdHJ1ZSwgZmFsc2UsIGZhbHNlKTtcblx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCh0eXBlLCBldmVudCk7XG5cdFx0XHRicmVhaztcblx0XHRjYXNlICdtb3VzZWRyYWcnOlxuXHRcdFx0dmFyIG5lZWRzQ2hhbmdlID0gZmFsc2UsXG5cdFx0XHRcdG1hdGNoTWF4RGlzdGFuY2UgPSBmYWxzZTtcblx0XHRcdHdoaWxlICh0aGlzLl91cGRhdGVFdmVudCh0eXBlLCBwb2ludCwgdGhpcy5taW5EaXN0YW5jZSxcblx0XHRcdFx0XHR0aGlzLm1heERpc3RhbmNlLCBmYWxzZSwgbmVlZHNDaGFuZ2UsIG1hdGNoTWF4RGlzdGFuY2UpKSB7XG5cdFx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCh0eXBlLCBldmVudCkgfHwgY2FsbGVkO1xuXHRcdFx0XHRuZWVkc0NoYW5nZSA9IHRydWU7XG5cdFx0XHRcdG1hdGNoTWF4RGlzdGFuY2UgPSB0cnVlO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0Y2FzZSAnbW91c2V1cCc6XG5cdFx0XHRpZiAoIXBvaW50LmVxdWFscyh0aGlzLl9wb2ludClcblx0XHRcdFx0XHQmJiB0aGlzLl91cGRhdGVFdmVudCgnbW91c2VkcmFnJywgcG9pbnQsIHRoaXMubWluRGlzdGFuY2UsXG5cdFx0XHRcdFx0XHRcdHRoaXMubWF4RGlzdGFuY2UsIGZhbHNlLCBmYWxzZSwgZmFsc2UpKSB7XG5cdFx0XHRcdGNhbGxlZCA9IHRoaXMuX2ZpcmVFdmVudCgnbW91c2VkcmFnJywgZXZlbnQpO1xuXHRcdFx0fVxuXHRcdFx0dGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIG51bGwsIHRoaXMubWF4RGlzdGFuY2UsIGZhbHNlLFxuXHRcdFx0XHRcdGZhbHNlLCBmYWxzZSk7XG5cdFx0XHRjYWxsZWQgPSB0aGlzLl9maXJlRXZlbnQodHlwZSwgZXZlbnQpIHx8IGNhbGxlZDtcblx0XHRcdHRoaXMuX3VwZGF0ZUV2ZW50KHR5cGUsIHBvaW50LCBudWxsLCBudWxsLCB0cnVlLCBmYWxzZSwgZmFsc2UpO1xuXHRcdFx0dGhpcy5fZmlyc3RNb3ZlID0gdHJ1ZTtcblx0XHRcdGJyZWFrO1xuXHRcdGNhc2UgJ21vdXNlbW92ZSc6XG5cdFx0XHR3aGlsZSAodGhpcy5fdXBkYXRlRXZlbnQodHlwZSwgcG9pbnQsIHRoaXMubWluRGlzdGFuY2UsXG5cdFx0XHRcdFx0dGhpcy5tYXhEaXN0YW5jZSwgdGhpcy5fZmlyc3RNb3ZlLCB0cnVlLCBmYWxzZSkpIHtcblx0XHRcdFx0Y2FsbGVkID0gdGhpcy5fZmlyZUV2ZW50KHR5cGUsIGV2ZW50KSB8fCBjYWxsZWQ7XG5cdFx0XHRcdHRoaXMuX2ZpcnN0TW92ZSA9IGZhbHNlO1xuXHRcdFx0fVxuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGlmIChjYWxsZWQpXG5cdFx0XHRldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuXHRcdHJldHVybiBjYWxsZWQ7XG5cdH1cblxufSk7XG5cbnZhciBIdHRwID0ge1xuXHRyZXF1ZXN0OiBmdW5jdGlvbihtZXRob2QsIHVybCwgY2FsbGJhY2ssIGFzeW5jKSB7XG5cdFx0YXN5bmMgPSAoYXN5bmMgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogYXN5bmM7XG5cdFx0dmFyIHhociA9IG5ldyAod2luZG93LkFjdGl2ZVhPYmplY3QgfHwgWE1MSHR0cFJlcXVlc3QpKFxuXHRcdFx0XHRcdCdNaWNyb3NvZnQuWE1MSFRUUCcpO1xuXHRcdHhoci5vcGVuKG1ldGhvZC50b1VwcGVyQ2FzZSgpLCB1cmwsIGFzeW5jKTtcblx0XHRpZiAoJ292ZXJyaWRlTWltZVR5cGUnIGluIHhocilcblx0XHRcdHhoci5vdmVycmlkZU1pbWVUeXBlKCd0ZXh0L3BsYWluJyk7XG5cdFx0eGhyLm9ucmVhZHlzdGF0ZWNoYW5nZSA9IGZ1bmN0aW9uKCkge1xuXHRcdFx0aWYgKHhoci5yZWFkeVN0YXRlID09PSA0KSB7XG5cdFx0XHRcdHZhciBzdGF0dXMgPSB4aHIuc3RhdHVzO1xuXHRcdFx0XHRpZiAoc3RhdHVzID09PSAwIHx8IHN0YXR1cyA9PT0gMjAwKSB7XG5cdFx0XHRcdFx0Y2FsbGJhY2suY2FsbCh4aHIsIHhoci5yZXNwb25zZVRleHQpO1xuXHRcdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRcdHRocm93IG5ldyBFcnJvcignQ291bGQgbm90IGxvYWQgJyArIHVybCArICcgKEVycm9yICdcblx0XHRcdFx0XHRcdFx0KyBzdGF0dXMgKyAnKScpO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fTtcblx0XHRyZXR1cm4geGhyLnNlbmQobnVsbCk7XG5cdH1cbn07XG5cbnZhciBDYW52YXNQcm92aWRlciA9IHtcblx0Y2FudmFzZXM6IFtdLFxuXG5cdGdldENhbnZhczogZnVuY3Rpb24od2lkdGgsIGhlaWdodCkge1xuXHRcdHZhciBjYW52YXMsXG5cdFx0XHRjbGVhciA9IHRydWU7XG5cdFx0aWYgKHR5cGVvZiB3aWR0aCA9PT0gJ29iamVjdCcpIHtcblx0XHRcdGhlaWdodCA9IHdpZHRoLmhlaWdodDtcblx0XHRcdHdpZHRoID0gd2lkdGgud2lkdGg7XG5cdFx0fVxuXHRcdGlmICh0aGlzLmNhbnZhc2VzLmxlbmd0aCkge1xuXHRcdFx0Y2FudmFzID0gdGhpcy5jYW52YXNlcy5wb3AoKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0Y2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnY2FudmFzJyk7XG5cdFx0fVxuXHRcdHZhciBjdHggPSBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcblx0XHRpZiAoY2FudmFzLndpZHRoID09PSB3aWR0aCAmJiBjYW52YXMuaGVpZ2h0ID09PSBoZWlnaHQpIHtcblx0XHRcdGlmIChjbGVhcilcblx0XHRcdFx0Y3R4LmNsZWFyUmVjdCgwLCAwLCB3aWR0aCArIDEsIGhlaWdodCArIDEpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjYW52YXMud2lkdGggPSB3aWR0aDtcblx0XHRcdGNhbnZhcy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0fVxuXHRcdGN0eC5zYXZlKCk7XG5cdFx0cmV0dXJuIGNhbnZhcztcblx0fSxcblxuXHRnZXRDb250ZXh0OiBmdW5jdGlvbih3aWR0aCwgaGVpZ2h0KSB7XG5cdFx0cmV0dXJuIHRoaXMuZ2V0Q2FudmFzKHdpZHRoLCBoZWlnaHQpLmdldENvbnRleHQoJzJkJyk7XG5cdH0sXG5cblx0cmVsZWFzZTogZnVuY3Rpb24ob2JqKSB7XG5cdFx0dmFyIGNhbnZhcyA9IG9iai5jYW52YXMgPyBvYmouY2FudmFzIDogb2JqO1xuXHRcdGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpLnJlc3RvcmUoKTtcblx0XHR0aGlzLmNhbnZhc2VzLnB1c2goY2FudmFzKTtcblx0fVxufTtcblxudmFyIEJsZW5kTW9kZSA9IG5ldyBmdW5jdGlvbigpIHtcblx0dmFyIG1pbiA9IE1hdGgubWluLFxuXHRcdG1heCA9IE1hdGgubWF4LFxuXHRcdGFicyA9IE1hdGguYWJzLFxuXHRcdHNyLCBzZywgc2IsIHNhLFxuXHRcdGJyLCBiZywgYmIsIGJhLFxuXHRcdGRyLCBkZywgZGI7XG5cblx0ZnVuY3Rpb24gZ2V0THVtKHIsIGcsIGIpIHtcblx0XHRyZXR1cm4gMC4yOTg5ICogciArIDAuNTg3ICogZyArIDAuMTE0ICogYjtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldEx1bShyLCBnLCBiLCBsKSB7XG5cdFx0dmFyIGQgPSBsIC0gZ2V0THVtKHIsIGcsIGIpO1xuXHRcdGRyID0gciArIGQ7XG5cdFx0ZGcgPSBnICsgZDtcblx0XHRkYiA9IGIgKyBkO1xuXHRcdHZhciBsID0gZ2V0THVtKGRyLCBkZywgZGIpLFxuXHRcdFx0bW4gPSBtaW4oZHIsIGRnLCBkYiksXG5cdFx0XHRteCA9IG1heChkciwgZGcsIGRiKTtcblx0XHRpZiAobW4gPCAwKSB7XG5cdFx0XHR2YXIgbG1uID0gbCAtIG1uO1xuXHRcdFx0ZHIgPSBsICsgKGRyIC0gbCkgKiBsIC8gbG1uO1xuXHRcdFx0ZGcgPSBsICsgKGRnIC0gbCkgKiBsIC8gbG1uO1xuXHRcdFx0ZGIgPSBsICsgKGRiIC0gbCkgKiBsIC8gbG1uO1xuXHRcdH1cblx0XHRpZiAobXggPiAyNTUpIHtcblx0XHRcdHZhciBsbiA9IDI1NSAtIGwsXG5cdFx0XHRcdG14bCA9IG14IC0gbDtcblx0XHRcdGRyID0gbCArIChkciAtIGwpICogbG4gLyBteGw7XG5cdFx0XHRkZyA9IGwgKyAoZGcgLSBsKSAqIGxuIC8gbXhsO1xuXHRcdFx0ZGIgPSBsICsgKGRiIC0gbCkgKiBsbiAvIG14bDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBnZXRTYXQociwgZywgYikge1xuXHRcdHJldHVybiBtYXgociwgZywgYikgLSBtaW4ociwgZywgYik7XG5cdH1cblxuXHRmdW5jdGlvbiBzZXRTYXQociwgZywgYiwgcykge1xuXHRcdHZhciBjb2wgPSBbciwgZywgYl0sXG5cdFx0XHRteCA9IG1heChyLCBnLCBiKSxcblx0XHRcdG1uID0gbWluKHIsIGcsIGIpLFxuXHRcdFx0bWQ7XG5cdFx0bW4gPSBtbiA9PT0gciA/IDAgOiBtbiA9PT0gZyA/IDEgOiAyO1xuXHRcdG14ID0gbXggPT09IHIgPyAwIDogbXggPT09IGcgPyAxIDogMjtcblx0XHRtZCA9IG1pbihtbiwgbXgpID09PSAwID8gbWF4KG1uLCBteCkgPT09IDEgPyAyIDogMSA6IDA7XG5cdFx0aWYgKGNvbFtteF0gPiBjb2xbbW5dKSB7XG5cdFx0XHRjb2xbbWRdID0gKGNvbFttZF0gLSBjb2xbbW5dKSAqIHMgLyAoY29sW214XSAtIGNvbFttbl0pO1xuXHRcdFx0Y29sW214XSA9IHM7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGNvbFttZF0gPSBjb2xbbXhdID0gMDtcblx0XHR9XG5cdFx0Y29sW21uXSA9IDA7XG5cdFx0ZHIgPSBjb2xbMF07XG5cdFx0ZGcgPSBjb2xbMV07XG5cdFx0ZGIgPSBjb2xbMl07XG5cdH1cblxuXHR2YXIgbW9kZXMgPSB7XG5cdFx0bXVsdGlwbHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciAqIHNyIC8gMjU1O1xuXHRcdFx0ZGcgPSBiZyAqIHNnIC8gMjU1O1xuXHRcdFx0ZGIgPSBiYiAqIHNiIC8gMjU1O1xuXHRcdH0sXG5cblx0XHRzY3JlZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciArIHNyIC0gKGJyICogc3IgLyAyNTUpO1xuXHRcdFx0ZGcgPSBiZyArIHNnIC0gKGJnICogc2cgLyAyNTUpO1xuXHRcdFx0ZGIgPSBiYiArIHNiIC0gKGJiICogc2IgLyAyNTUpO1xuXHRcdH0sXG5cblx0XHRvdmVybGF5OiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPCAxMjggPyAyICogYnIgKiBzciAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYnIpICogKDI1NSAtIHNyKSAvIDI1NTtcblx0XHRcdGRnID0gYmcgPCAxMjggPyAyICogYmcgKiBzZyAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmcpICogKDI1NSAtIHNnKSAvIDI1NTtcblx0XHRcdGRiID0gYmIgPCAxMjggPyAyICogYmIgKiBzYiAvIDI1NSA6IDI1NSAtIDIgKiAoMjU1IC0gYmIpICogKDI1NSAtIHNiKSAvIDI1NTtcblx0XHR9LFxuXG5cdFx0J3NvZnQtbGlnaHQnOiBmdW5jdGlvbigpIHtcblx0XHRcdHZhciB0ID0gc3IgKiBiciAvIDI1NTtcblx0XHRcdGRyID0gdCArIGJyICogKDI1NSAtICgyNTUgLSBicikgKiAoMjU1IC0gc3IpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0XHR0ID0gc2cgKiBiZyAvIDI1NTtcblx0XHRcdGRnID0gdCArIGJnICogKDI1NSAtICgyNTUgLSBiZykgKiAoMjU1IC0gc2cpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0XHR0ID0gc2IgKiBiYiAvIDI1NTtcblx0XHRcdGRiID0gdCArIGJiICogKDI1NSAtICgyNTUgLSBiYikgKiAoMjU1IC0gc2IpIC8gMjU1IC0gdCkgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdoYXJkLWxpZ2h0JzogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IHNyIDwgMTI4ID8gMiAqIHNyICogYnIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNyKSAqICgyNTUgLSBicikgLyAyNTU7XG5cdFx0XHRkZyA9IHNnIDwgMTI4ID8gMiAqIHNnICogYmcgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNnKSAqICgyNTUgLSBiZykgLyAyNTU7XG5cdFx0XHRkYiA9IHNiIDwgMTI4ID8gMiAqIHNiICogYmIgLyAyNTUgOiAyNTUgLSAyICogKDI1NSAtIHNiKSAqICgyNTUgLSBiYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdCdjb2xvci1kb2RnZSc6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA9PT0gMCA/IDAgOiBzciA9PT0gMjU1ID8gMjU1IDogbWluKDI1NSwgMjU1ICogYnIgLyAoMjU1IC0gc3IpKTtcblx0XHRcdGRnID0gYmcgPT09IDAgPyAwIDogc2cgPT09IDI1NSA/IDI1NSA6IG1pbigyNTUsIDI1NSAqIGJnIC8gKDI1NSAtIHNnKSk7XG5cdFx0XHRkYiA9IGJiID09PSAwID8gMCA6IHNiID09PSAyNTUgPyAyNTUgOiBtaW4oMjU1LCAyNTUgKiBiYiAvICgyNTUgLSBzYikpO1xuXHRcdH0sXG5cblx0XHQnY29sb3ItYnVybic6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA9PT0gMjU1ID8gMjU1IDogc3IgPT09IDAgPyAwIDogbWF4KDAsIDI1NSAtICgyNTUgLSBicikgKiAyNTUgLyBzcik7XG5cdFx0XHRkZyA9IGJnID09PSAyNTUgPyAyNTUgOiBzZyA9PT0gMCA/IDAgOiBtYXgoMCwgMjU1IC0gKDI1NSAtIGJnKSAqIDI1NSAvIHNnKTtcblx0XHRcdGRiID0gYmIgPT09IDI1NSA/IDI1NSA6IHNiID09PSAwID8gMCA6IG1heCgwLCAyNTUgLSAoMjU1IC0gYmIpICogMjU1IC8gc2IpO1xuXHRcdH0sXG5cblx0XHRkYXJrZW46IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBiciA8IHNyID8gYnIgOiBzcjtcblx0XHRcdGRnID0gYmcgPCBzZyA/IGJnIDogc2c7XG5cdFx0XHRkYiA9IGJiIDwgc2IgPyBiYiA6IHNiO1xuXHRcdH0sXG5cblx0XHRsaWdodGVuOiBmdW5jdGlvbigpIHtcblx0XHRcdGRyID0gYnIgPiBzciA/IGJyIDogc3I7XG5cdFx0XHRkZyA9IGJnID4gc2cgPyBiZyA6IHNnO1xuXHRcdFx0ZGIgPSBiYiA+IHNiID8gYmIgOiBzYjtcblx0XHR9LFxuXG5cdFx0ZGlmZmVyZW5jZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyIC0gc3I7XG5cdFx0XHRpZiAoZHIgPCAwKVxuXHRcdFx0XHRkciA9IC1kcjtcblx0XHRcdGRnID0gYmcgLSBzZztcblx0XHRcdGlmIChkZyA8IDApXG5cdFx0XHRcdGRnID0gLWRnO1xuXHRcdFx0ZGIgPSBiYiAtIHNiO1xuXHRcdFx0aWYgKGRiIDwgMClcblx0XHRcdFx0ZGIgPSAtZGI7XG5cdFx0fSxcblxuXHRcdGV4Y2x1c2lvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IGJyICsgc3IgKiAoMjU1IC0gYnIgLSBicikgLyAyNTU7XG5cdFx0XHRkZyA9IGJnICsgc2cgKiAoMjU1IC0gYmcgLSBiZykgLyAyNTU7XG5cdFx0XHRkYiA9IGJiICsgc2IgKiAoMjU1IC0gYmIgLSBiYikgLyAyNTU7XG5cdFx0fSxcblxuXHRcdGh1ZTogZnVuY3Rpb24oKSB7XG5cdFx0XHRzZXRTYXQoc3IsIHNnLCBzYiwgZ2V0U2F0KGJyLCBiZywgYmIpKTtcblx0XHRcdHNldEx1bShkciwgZGcsIGRiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRzYXR1cmF0aW9uOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldFNhdChiciwgYmcsIGJiLCBnZXRTYXQoc3IsIHNnLCBzYikpO1xuXHRcdFx0c2V0THVtKGRyLCBkZywgZGIsIGdldEx1bShiciwgYmcsIGJiKSk7XG5cdFx0fSxcblxuXHRcdGx1bWlub3NpdHk6IGZ1bmN0aW9uKCkge1xuXHRcdFx0c2V0THVtKGJyLCBiZywgYmIsIGdldEx1bShzciwgc2csIHNiKSk7XG5cdFx0fSxcblxuXHRcdGNvbG9yOiBmdW5jdGlvbigpIHtcblx0XHRcdHNldEx1bShzciwgc2csIHNiLCBnZXRMdW0oYnIsIGJnLCBiYikpO1xuXHRcdH0sXG5cblx0XHRhZGQ6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSBtaW4oYnIgKyBzciwgMjU1KTtcblx0XHRcdGRnID0gbWluKGJnICsgc2csIDI1NSk7XG5cdFx0XHRkYiA9IG1pbihiYiArIHNiLCAyNTUpO1xuXHRcdH0sXG5cblx0XHRzdWJ0cmFjdDogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IG1heChiciAtIHNyLCAwKTtcblx0XHRcdGRnID0gbWF4KGJnIC0gc2csIDApO1xuXHRcdFx0ZGIgPSBtYXgoYmIgLSBzYiwgMCk7XG5cdFx0fSxcblxuXHRcdGF2ZXJhZ2U6IGZ1bmN0aW9uKCkge1xuXHRcdFx0ZHIgPSAoYnIgKyBzcikgLyAyO1xuXHRcdFx0ZGcgPSAoYmcgKyBzZykgLyAyO1xuXHRcdFx0ZGIgPSAoYmIgKyBzYikgLyAyO1xuXHRcdH0sXG5cblx0XHRuZWdhdGlvbjogZnVuY3Rpb24oKSB7XG5cdFx0XHRkciA9IDI1NSAtIGFicygyNTUgLSBzciAtIGJyKTtcblx0XHRcdGRnID0gMjU1IC0gYWJzKDI1NSAtIHNnIC0gYmcpO1xuXHRcdFx0ZGIgPSAyNTUgLSBhYnMoMjU1IC0gc2IgLSBiYik7XG5cdFx0fVxuXHR9O1xuXG5cdHZhciBuYXRpdmVNb2RlcyA9IHRoaXMubmF0aXZlTW9kZXMgPSBCYXNlLmVhY2goW1xuXHRcdCdzb3VyY2Utb3ZlcicsICdzb3VyY2UtaW4nLCAnc291cmNlLW91dCcsICdzb3VyY2UtYXRvcCcsXG5cdFx0J2Rlc3RpbmF0aW9uLW92ZXInLCAnZGVzdGluYXRpb24taW4nLCAnZGVzdGluYXRpb24tb3V0Jyxcblx0XHQnZGVzdGluYXRpb24tYXRvcCcsICdsaWdodGVyJywgJ2RhcmtlcicsICdjb3B5JywgJ3hvcidcblx0XSwgZnVuY3Rpb24obW9kZSkge1xuXHRcdHRoaXNbbW9kZV0gPSB0cnVlO1xuXHR9LCB7fSk7XG5cblx0dmFyIGN0eCA9IENhbnZhc1Byb3ZpZGVyLmdldENvbnRleHQoMSwgMSk7XG5cdEJhc2UuZWFjaChtb2RlcywgZnVuY3Rpb24oZnVuYywgbW9kZSkge1xuXHRcdHZhciBkYXJrZW4gPSBtb2RlID09PSAnZGFya2VuJyxcblx0XHRcdG9rID0gZmFsc2U7XG5cdFx0Y3R4LnNhdmUoKTtcblx0XHR0cnkge1xuXHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGRhcmtlbiA/ICcjMzAwJyA6ICcjYTAwJztcblx0XHRcdGN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcblx0XHRcdGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBtb2RlO1xuXHRcdFx0aWYgKGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPT09IG1vZGUpIHtcblx0XHRcdFx0Y3R4LmZpbGxTdHlsZSA9IGRhcmtlbiA/ICcjYTAwJyA6ICcjMzAwJztcblx0XHRcdFx0Y3R4LmZpbGxSZWN0KDAsIDAsIDEsIDEpO1xuXHRcdFx0XHRvayA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YVswXSAhPT0gZGFya2VuID8gMTcwIDogNTE7XG5cdFx0XHR9XG5cdFx0fSBjYXRjaCAoZSkge31cblx0XHRjdHgucmVzdG9yZSgpO1xuXHRcdG5hdGl2ZU1vZGVzW21vZGVdID0gb2s7XG5cdH0pO1xuXHRDYW52YXNQcm92aWRlci5yZWxlYXNlKGN0eCk7XG5cblx0dGhpcy5wcm9jZXNzID0gZnVuY3Rpb24obW9kZSwgc3JjQ29udGV4dCwgZHN0Q29udGV4dCwgYWxwaGEsIG9mZnNldCkge1xuXHRcdHZhciBzcmNDYW52YXMgPSBzcmNDb250ZXh0LmNhbnZhcyxcblx0XHRcdG5vcm1hbCA9IG1vZGUgPT09ICdub3JtYWwnO1xuXHRcdGlmIChub3JtYWwgfHwgbmF0aXZlTW9kZXNbbW9kZV0pIHtcblx0XHRcdGRzdENvbnRleHQuc2F2ZSgpO1xuXHRcdFx0ZHN0Q29udGV4dC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG5cdFx0XHRkc3RDb250ZXh0Lmdsb2JhbEFscGhhID0gYWxwaGE7XG5cdFx0XHRpZiAoIW5vcm1hbClcblx0XHRcdFx0ZHN0Q29udGV4dC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBtb2RlO1xuXHRcdFx0ZHN0Q29udGV4dC5kcmF3SW1hZ2Uoc3JjQ2FudmFzLCBvZmZzZXQueCwgb2Zmc2V0LnkpO1xuXHRcdFx0ZHN0Q29udGV4dC5yZXN0b3JlKCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBwcm9jZXNzID0gbW9kZXNbbW9kZV07XG5cdFx0XHRpZiAoIXByb2Nlc3MpXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdHZhciBkc3REYXRhID0gZHN0Q29udGV4dC5nZXRJbWFnZURhdGEob2Zmc2V0LngsIG9mZnNldC55LFxuXHRcdFx0XHRcdHNyY0NhbnZhcy53aWR0aCwgc3JjQ2FudmFzLmhlaWdodCksXG5cdFx0XHRcdGRzdCA9IGRzdERhdGEuZGF0YSxcblx0XHRcdFx0c3JjID0gc3JjQ29udGV4dC5nZXRJbWFnZURhdGEoMCwgMCxcblx0XHRcdFx0XHRzcmNDYW52YXMud2lkdGgsIHNyY0NhbnZhcy5oZWlnaHQpLmRhdGE7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGRzdC5sZW5ndGg7IGkgPCBsOyBpICs9IDQpIHtcblx0XHRcdFx0c3IgPSBzcmNbaV07XG5cdFx0XHRcdGJyID0gZHN0W2ldO1xuXHRcdFx0XHRzZyA9IHNyY1tpICsgMV07XG5cdFx0XHRcdGJnID0gZHN0W2kgKyAxXTtcblx0XHRcdFx0c2IgPSBzcmNbaSArIDJdO1xuXHRcdFx0XHRiYiA9IGRzdFtpICsgMl07XG5cdFx0XHRcdHNhID0gc3JjW2kgKyAzXTtcblx0XHRcdFx0YmEgPSBkc3RbaSArIDNdO1xuXHRcdFx0XHRwcm9jZXNzKCk7XG5cdFx0XHRcdHZhciBhMSA9IHNhICogYWxwaGEgLyAyNTUsXG5cdFx0XHRcdFx0YTIgPSAxIC0gYTE7XG5cdFx0XHRcdGRzdFtpXSA9IGExICogZHIgKyBhMiAqIGJyO1xuXHRcdFx0XHRkc3RbaSArIDFdID0gYTEgKiBkZyArIGEyICogYmc7XG5cdFx0XHRcdGRzdFtpICsgMl0gPSBhMSAqIGRiICsgYTIgKiBiYjtcblx0XHRcdFx0ZHN0W2kgKyAzXSA9IHNhICogYWxwaGEgKyBhMiAqIGJhO1xuXHRcdFx0fVxuXHRcdFx0ZHN0Q29udGV4dC5wdXRJbWFnZURhdGEoZHN0RGF0YSwgb2Zmc2V0LngsIG9mZnNldC55KTtcblx0XHR9XG5cdH07XG59O1xuXG52YXIgU1ZHU3R5bGVzID0gQmFzZS5lYWNoKHtcblx0ZmlsbENvbG9yOiBbJ2ZpbGwnLCAnY29sb3InXSxcblx0c3Ryb2tlQ29sb3I6IFsnc3Ryb2tlJywgJ2NvbG9yJ10sXG5cdHN0cm9rZVdpZHRoOiBbJ3N0cm9rZS13aWR0aCcsICdudW1iZXInXSxcblx0c3Ryb2tlQ2FwOiBbJ3N0cm9rZS1saW5lY2FwJywgJ3N0cmluZyddLFxuXHRzdHJva2VKb2luOiBbJ3N0cm9rZS1saW5lam9pbicsICdzdHJpbmcnXSxcblx0c3Ryb2tlU2NhbGluZzogWyd2ZWN0b3ItZWZmZWN0JywgJ2xvb2t1cCcsIHtcblx0XHR0cnVlOiAnbm9uZScsXG5cdFx0ZmFsc2U6ICdub24tc2NhbGluZy1zdHJva2UnXG5cdH0sIGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0cmV0dXJuICF2YWx1ZVxuXHRcdFx0XHQmJiAoaXRlbSBpbnN0YW5jZW9mIFBhdGhJdGVtXG5cdFx0XHRcdFx0fHwgaXRlbSBpbnN0YW5jZW9mIFNoYXBlXG5cdFx0XHRcdFx0fHwgaXRlbSBpbnN0YW5jZW9mIFRleHRJdGVtKTtcblx0fV0sXG5cdG1pdGVyTGltaXQ6IFsnc3Ryb2tlLW1pdGVybGltaXQnLCAnbnVtYmVyJ10sXG5cdGRhc2hBcnJheTogWydzdHJva2UtZGFzaGFycmF5JywgJ2FycmF5J10sXG5cdGRhc2hPZmZzZXQ6IFsnc3Ryb2tlLWRhc2hvZmZzZXQnLCAnbnVtYmVyJ10sXG5cdGZvbnRGYW1pbHk6IFsnZm9udC1mYW1pbHknLCAnc3RyaW5nJ10sXG5cdGZvbnRXZWlnaHQ6IFsnZm9udC13ZWlnaHQnLCAnc3RyaW5nJ10sXG5cdGZvbnRTaXplOiBbJ2ZvbnQtc2l6ZScsICdudW1iZXInXSxcblx0anVzdGlmaWNhdGlvbjogWyd0ZXh0LWFuY2hvcicsICdsb29rdXAnLCB7XG5cdFx0bGVmdDogJ3N0YXJ0Jyxcblx0XHRjZW50ZXI6ICdtaWRkbGUnLFxuXHRcdHJpZ2h0OiAnZW5kJ1xuXHR9XSxcblx0b3BhY2l0eTogWydvcGFjaXR5JywgJ251bWJlciddLFxuXHRibGVuZE1vZGU6IFsnbWl4LWJsZW5kLW1vZGUnLCAnc3RyaW5nJ11cbn0sIGZ1bmN0aW9uKGVudHJ5LCBrZXkpIHtcblx0dmFyIHBhcnQgPSBCYXNlLmNhcGl0YWxpemUoa2V5KSxcblx0XHRsb29rdXAgPSBlbnRyeVsyXTtcblx0dGhpc1trZXldID0ge1xuXHRcdHR5cGU6IGVudHJ5WzFdLFxuXHRcdHByb3BlcnR5OiBrZXksXG5cdFx0YXR0cmlidXRlOiBlbnRyeVswXSxcblx0XHR0b1NWRzogbG9va3VwLFxuXHRcdGZyb21TVkc6IGxvb2t1cCAmJiBCYXNlLmVhY2gobG9va3VwLCBmdW5jdGlvbih2YWx1ZSwgbmFtZSkge1xuXHRcdFx0dGhpc1t2YWx1ZV0gPSBuYW1lO1xuXHRcdH0sIHt9KSxcblx0XHRleHBvcnRGaWx0ZXI6IGVudHJ5WzNdLFxuXHRcdGdldDogJ2dldCcgKyBwYXJ0LFxuXHRcdHNldDogJ3NldCcgKyBwYXJ0XG5cdH07XG59LCB7fSk7XG5cbnZhciBTVkdOYW1lc3BhY2VzID0ge1xuXHRocmVmOiAnaHR0cDovL3d3dy53My5vcmcvMTk5OS94bGluaycsXG5cdHhsaW5rOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC94bWxucydcbn07XG5cbm5ldyBmdW5jdGlvbigpIHtcblx0dmFyIGZvcm1hdHRlcjtcblxuXHRmdW5jdGlvbiBzZXRBdHRyaWJ1dGVzKG5vZGUsIGF0dHJzKSB7XG5cdFx0Zm9yICh2YXIga2V5IGluIGF0dHJzKSB7XG5cdFx0XHR2YXIgdmFsID0gYXR0cnNba2V5XSxcblx0XHRcdFx0bmFtZXNwYWNlID0gU1ZHTmFtZXNwYWNlc1trZXldO1xuXHRcdFx0aWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKVxuXHRcdFx0XHR2YWwgPSBmb3JtYXR0ZXIubnVtYmVyKHZhbCk7XG5cdFx0XHRpZiAobmFtZXNwYWNlKSB7XG5cdFx0XHRcdG5vZGUuc2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBrZXksIHZhbCk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZShrZXksIHZhbCk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBub2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gY3JlYXRlRWxlbWVudCh0YWcsIGF0dHJzKSB7XG5cdFx0cmV0dXJuIHNldEF0dHJpYnV0ZXMoXG5cdFx0XHRkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJywgdGFnKSwgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0VHJhbnNmb3JtKG1hdHJpeCwgY29vcmRpbmF0ZXMsIGNlbnRlcikge1xuXHRcdHZhciBhdHRycyA9IG5ldyBCYXNlKCksXG5cdFx0XHR0cmFucyA9IG1hdHJpeC5nZXRUcmFuc2xhdGlvbigpO1xuXHRcdGlmIChjb29yZGluYXRlcykge1xuXHRcdFx0bWF0cml4ID0gbWF0cml4LnNoaWZ0bGVzcygpO1xuXHRcdFx0dmFyIHBvaW50ID0gbWF0cml4Ll9pbnZlcnNlVHJhbnNmb3JtKHRyYW5zKTtcblx0XHRcdGF0dHJzW2NlbnRlciA/ICdjeCcgOiAneCddID0gcG9pbnQueDtcblx0XHRcdGF0dHJzW2NlbnRlciA/ICdjeScgOiAneSddID0gcG9pbnQueTtcblx0XHRcdHRyYW5zID0gbnVsbDtcblx0XHR9XG5cdFx0aWYgKCFtYXRyaXguaXNJZGVudGl0eSgpKSB7XG5cdFx0XHR2YXIgZGVjb21wb3NlZCA9IG1hdHJpeC5kZWNvbXBvc2UoKTtcblx0XHRcdGlmIChkZWNvbXBvc2VkICYmICFkZWNvbXBvc2VkLnNoZWFyaW5nKSB7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IFtdLFxuXHRcdFx0XHRcdGFuZ2xlID0gZGVjb21wb3NlZC5yb3RhdGlvbixcblx0XHRcdFx0XHRzY2FsZSA9IGRlY29tcG9zZWQuc2NhbGluZztcblx0XHRcdFx0aWYgKHRyYW5zICYmICF0cmFucy5pc1plcm8oKSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCd0cmFuc2xhdGUoJyArIGZvcm1hdHRlci5wb2ludCh0cmFucykgKyAnKScpO1xuXHRcdFx0XHRpZiAoIU51bWVyaWNhbC5pc1plcm8oc2NhbGUueCAtIDEpXG5cdFx0XHRcdFx0XHR8fCAhTnVtZXJpY2FsLmlzWmVybyhzY2FsZS55IC0gMSkpXG5cdFx0XHRcdFx0cGFydHMucHVzaCgnc2NhbGUoJyArIGZvcm1hdHRlci5wb2ludChzY2FsZSkgKycpJyk7XG5cdFx0XHRcdGlmIChhbmdsZSlcblx0XHRcdFx0XHRwYXJ0cy5wdXNoKCdyb3RhdGUoJyArIGZvcm1hdHRlci5udW1iZXIoYW5nbGUpICsgJyknKTtcblx0XHRcdFx0YXR0cnMudHJhbnNmb3JtID0gcGFydHMuam9pbignICcpO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMudHJhbnNmb3JtID0gJ21hdHJpeCgnICsgbWF0cml4LmdldFZhbHVlcygpLmpvaW4oJywnKSArICcpJztcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIGF0dHJzO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0R3JvdXAoaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpLFxuXHRcdFx0Y2hpbGRyZW4gPSBpdGVtLl9jaGlsZHJlbjtcblx0XHR2YXIgbm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ2cnLCBhdHRycyk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcblx0XHRcdHZhciBjaGlsZCA9IGNoaWxkcmVuW2ldO1xuXHRcdFx0dmFyIGNoaWxkTm9kZSA9IGV4cG9ydFNWRyhjaGlsZCwgb3B0aW9ucyk7XG5cdFx0XHRpZiAoY2hpbGROb2RlKSB7XG5cdFx0XHRcdGlmIChjaGlsZC5pc0NsaXBNYXNrKCkpIHtcblx0XHRcdFx0XHR2YXIgY2xpcCA9IGNyZWF0ZUVsZW1lbnQoJ2NsaXBQYXRoJyk7XG5cdFx0XHRcdFx0Y2xpcC5hcHBlbmRDaGlsZChjaGlsZE5vZGUpO1xuXHRcdFx0XHRcdHNldERlZmluaXRpb24oY2hpbGQsIGNsaXAsICdjbGlwJyk7XG5cdFx0XHRcdFx0c2V0QXR0cmlidXRlcyhub2RlLCB7XG5cdFx0XHRcdFx0XHQnY2xpcC1wYXRoJzogJ3VybCgjJyArIGNsaXAuaWQgKyAnKSdcblx0XHRcdFx0XHR9KTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRub2RlLmFwcGVuZENoaWxkKGNoaWxkTm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRSYXN0ZXIoaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUpLFxuXHRcdFx0c2l6ZSA9IGl0ZW0uZ2V0U2l6ZSgpLFxuXHRcdFx0aW1hZ2UgPSBpdGVtLmdldEltYWdlKCk7XG5cdFx0YXR0cnMueCAtPSBzaXplLndpZHRoIC8gMjtcblx0XHRhdHRycy55IC09IHNpemUuaGVpZ2h0IC8gMjtcblx0XHRhdHRycy53aWR0aCA9IHNpemUud2lkdGg7XG5cdFx0YXR0cnMuaGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0YXR0cnMuaHJlZiA9IG9wdGlvbnMuZW1iZWRJbWFnZXMgPT09IGZhbHNlICYmIGltYWdlICYmIGltYWdlLnNyY1xuXHRcdFx0XHR8fCBpdGVtLnRvRGF0YVVSTCgpO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KCdpbWFnZScsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFBhdGgoaXRlbSwgb3B0aW9ucykge1xuXHRcdHZhciBtYXRjaFNoYXBlcyA9IG9wdGlvbnMubWF0Y2hTaGFwZXM7XG5cdFx0aWYgKG1hdGNoU2hhcGVzKSB7XG5cdFx0XHR2YXIgc2hhcGUgPSBpdGVtLnRvU2hhcGUoZmFsc2UpO1xuXHRcdFx0aWYgKHNoYXBlKVxuXHRcdFx0XHRyZXR1cm4gZXhwb3J0U2hhcGUoc2hhcGUsIG9wdGlvbnMpO1xuXHRcdH1cblx0XHR2YXIgc2VnbWVudHMgPSBpdGVtLl9zZWdtZW50cyxcblx0XHRcdHR5cGUsXG5cdFx0XHRhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgpO1xuXHRcdGlmIChzZWdtZW50cy5sZW5ndGggPT09IDApXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRpZiAobWF0Y2hTaGFwZXMgJiYgIWl0ZW0uaGFzSGFuZGxlcygpKSB7XG5cdFx0XHRpZiAoc2VnbWVudHMubGVuZ3RoID49IDMpIHtcblx0XHRcdFx0dHlwZSA9IGl0ZW0uX2Nsb3NlZCA/ICdwb2x5Z29uJyA6ICdwb2x5bGluZSc7XG5cdFx0XHRcdHZhciBwYXJ0cyA9IFtdO1xuXHRcdFx0XHRmb3IodmFyIGkgPSAwLCBsID0gc2VnbWVudHMubGVuZ3RoOyBpIDwgbDsgaSsrKVxuXHRcdFx0XHRcdHBhcnRzLnB1c2goZm9ybWF0dGVyLnBvaW50KHNlZ21lbnRzW2ldLl9wb2ludCkpO1xuXHRcdFx0XHRhdHRycy5wb2ludHMgPSBwYXJ0cy5qb2luKCcgJyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHR0eXBlID0gJ2xpbmUnO1xuXHRcdFx0XHR2YXIgZmlyc3QgPSBzZWdtZW50c1swXS5fcG9pbnQsXG5cdFx0XHRcdFx0bGFzdCA9IHNlZ21lbnRzW3NlZ21lbnRzLmxlbmd0aCAtIDFdLl9wb2ludDtcblx0XHRcdFx0YXR0cnMuc2V0KHtcblx0XHRcdFx0XHR4MTogZmlyc3QueCxcblx0XHRcdFx0XHR5MTogZmlyc3QueSxcblx0XHRcdFx0XHR4MjogbGFzdC54LFxuXHRcdFx0XHRcdHkyOiBsYXN0Lnlcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cdFx0fSBlbHNlIHtcblx0XHRcdHR5cGUgPSAncGF0aCc7XG5cdFx0XHRhdHRycy5kID0gaXRlbS5nZXRQYXRoRGF0YShudWxsLCBvcHRpb25zLnByZWNpc2lvbik7XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KHR5cGUsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydFNoYXBlKGl0ZW0pIHtcblx0XHR2YXIgdHlwZSA9IGl0ZW0uX3R5cGUsXG5cdFx0XHRyYWRpdXMgPSBpdGVtLl9yYWRpdXMsXG5cdFx0XHRhdHRycyA9IGdldFRyYW5zZm9ybShpdGVtLl9tYXRyaXgsIHRydWUsIHR5cGUgIT09ICdyZWN0YW5nbGUnKTtcblx0XHRpZiAodHlwZSA9PT0gJ3JlY3RhbmdsZScpIHtcblx0XHRcdHR5cGUgPSAncmVjdCc7XG5cdFx0XHR2YXIgc2l6ZSA9IGl0ZW0uX3NpemUsXG5cdFx0XHRcdHdpZHRoID0gc2l6ZS53aWR0aCxcblx0XHRcdFx0aGVpZ2h0ID0gc2l6ZS5oZWlnaHQ7XG5cdFx0XHRhdHRycy54IC09IHdpZHRoIC8gMjtcblx0XHRcdGF0dHJzLnkgLT0gaGVpZ2h0IC8gMjtcblx0XHRcdGF0dHJzLndpZHRoID0gd2lkdGg7XG5cdFx0XHRhdHRycy5oZWlnaHQgPSBoZWlnaHQ7XG5cdFx0XHRpZiAocmFkaXVzLmlzWmVybygpKVxuXHRcdFx0XHRyYWRpdXMgPSBudWxsO1xuXHRcdH1cblx0XHRpZiAocmFkaXVzKSB7XG5cdFx0XHRpZiAodHlwZSA9PT0gJ2NpcmNsZScpIHtcblx0XHRcdFx0YXR0cnMuciA9IHJhZGl1cztcblx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdGF0dHJzLnJ4ID0gcmFkaXVzLndpZHRoO1xuXHRcdFx0XHRhdHRycy5yeSA9IHJhZGl1cy5oZWlnaHQ7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KHR5cGUsIGF0dHJzKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGV4cG9ydENvbXBvdW5kUGF0aChpdGVtLCBvcHRpb25zKSB7XG5cdFx0dmFyIGF0dHJzID0gZ2V0VHJhbnNmb3JtKGl0ZW0uX21hdHJpeCk7XG5cdFx0dmFyIGRhdGEgPSBpdGVtLmdldFBhdGhEYXRhKG51bGwsIG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRpZiAoZGF0YSlcblx0XHRcdGF0dHJzLmQgPSBkYXRhO1xuXHRcdHJldHVybiBjcmVhdGVFbGVtZW50KCdwYXRoJywgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0UGxhY2VkU3ltYm9sKGl0ZW0sIG9wdGlvbnMpIHtcblx0XHR2YXIgYXR0cnMgPSBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSxcblx0XHRcdHN5bWJvbCA9IGl0ZW0uZ2V0U3ltYm9sKCksXG5cdFx0XHRzeW1ib2xOb2RlID0gZ2V0RGVmaW5pdGlvbihzeW1ib2wsICdzeW1ib2wnKSxcblx0XHRcdGRlZmluaXRpb24gPSBzeW1ib2wuZ2V0RGVmaW5pdGlvbigpLFxuXHRcdFx0Ym91bmRzID0gZGVmaW5pdGlvbi5nZXRCb3VuZHMoKTtcblx0XHRpZiAoIXN5bWJvbE5vZGUpIHtcblx0XHRcdHN5bWJvbE5vZGUgPSBjcmVhdGVFbGVtZW50KCdzeW1ib2wnLCB7XG5cdFx0XHRcdHZpZXdCb3g6IGZvcm1hdHRlci5yZWN0YW5nbGUoYm91bmRzKVxuXHRcdFx0fSk7XG5cdFx0XHRzeW1ib2xOb2RlLmFwcGVuZENoaWxkKGV4cG9ydFNWRyhkZWZpbml0aW9uLCBvcHRpb25zKSk7XG5cdFx0XHRzZXREZWZpbml0aW9uKHN5bWJvbCwgc3ltYm9sTm9kZSwgJ3N5bWJvbCcpO1xuXHRcdH1cblx0XHRhdHRycy5ocmVmID0gJyMnICsgc3ltYm9sTm9kZS5pZDtcblx0XHRhdHRycy54ICs9IGJvdW5kcy54O1xuXHRcdGF0dHJzLnkgKz0gYm91bmRzLnk7XG5cdFx0YXR0cnMud2lkdGggPSBmb3JtYXR0ZXIubnVtYmVyKGJvdW5kcy53aWR0aCk7XG5cdFx0YXR0cnMuaGVpZ2h0ID0gZm9ybWF0dGVyLm51bWJlcihib3VuZHMuaGVpZ2h0KTtcblx0XHRhdHRycy5vdmVyZmxvdyA9ICd2aXNpYmxlJztcblx0XHRyZXR1cm4gY3JlYXRlRWxlbWVudCgndXNlJywgYXR0cnMpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0R3JhZGllbnQoY29sb3IpIHtcblx0XHR2YXIgZ3JhZGllbnROb2RlID0gZ2V0RGVmaW5pdGlvbihjb2xvciwgJ2NvbG9yJyk7XG5cdFx0aWYgKCFncmFkaWVudE5vZGUpIHtcblx0XHRcdHZhciBncmFkaWVudCA9IGNvbG9yLmdldEdyYWRpZW50KCksXG5cdFx0XHRcdHJhZGlhbCA9IGdyYWRpZW50Ll9yYWRpYWwsXG5cdFx0XHRcdG9yaWdpbiA9IGNvbG9yLmdldE9yaWdpbigpLnRyYW5zZm9ybSgpLFxuXHRcdFx0XHRkZXN0aW5hdGlvbiA9IGNvbG9yLmdldERlc3RpbmF0aW9uKCkudHJhbnNmb3JtKCksXG5cdFx0XHRcdGF0dHJzO1xuXHRcdFx0aWYgKHJhZGlhbCkge1xuXHRcdFx0XHRhdHRycyA9IHtcblx0XHRcdFx0XHRjeDogb3JpZ2luLngsXG5cdFx0XHRcdFx0Y3k6IG9yaWdpbi55LFxuXHRcdFx0XHRcdHI6IG9yaWdpbi5nZXREaXN0YW5jZShkZXN0aW5hdGlvbilcblx0XHRcdFx0fTtcblx0XHRcdFx0dmFyIGhpZ2hsaWdodCA9IGNvbG9yLmdldEhpZ2hsaWdodCgpO1xuXHRcdFx0XHRpZiAoaGlnaGxpZ2h0KSB7XG5cdFx0XHRcdFx0aGlnaGxpZ2h0ID0gaGlnaGxpZ2h0LnRyYW5zZm9ybSgpO1xuXHRcdFx0XHRcdGF0dHJzLmZ4ID0gaGlnaGxpZ2h0Lng7XG5cdFx0XHRcdFx0YXR0cnMuZnkgPSBoaWdobGlnaHQueTtcblx0XHRcdFx0fVxuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0eDE6IG9yaWdpbi54LFxuXHRcdFx0XHRcdHkxOiBvcmlnaW4ueSxcblx0XHRcdFx0XHR4MjogZGVzdGluYXRpb24ueCxcblx0XHRcdFx0XHR5MjogZGVzdGluYXRpb24ueVxuXHRcdFx0XHR9O1xuXHRcdFx0fVxuXHRcdFx0YXR0cnMuZ3JhZGllbnRVbml0cyA9ICd1c2VyU3BhY2VPblVzZSc7XG5cdFx0XHRncmFkaWVudE5vZGUgPSBjcmVhdGVFbGVtZW50KFxuXHRcdFx0XHRcdChyYWRpYWwgPyAncmFkaWFsJyA6ICdsaW5lYXInKSArICdHcmFkaWVudCcsIGF0dHJzKTtcblx0XHRcdHZhciBzdG9wcyA9IGdyYWRpZW50Ll9zdG9wcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gc3RvcHMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBzdG9wID0gc3RvcHNbaV0sXG5cdFx0XHRcdFx0c3RvcENvbG9yID0gc3RvcC5fY29sb3IsXG5cdFx0XHRcdFx0YWxwaGEgPSBzdG9wQ29sb3IuZ2V0QWxwaGEoKTtcblx0XHRcdFx0YXR0cnMgPSB7XG5cdFx0XHRcdFx0b2Zmc2V0OiBzdG9wLl9yYW1wUG9pbnQsXG5cdFx0XHRcdFx0J3N0b3AtY29sb3InOiBzdG9wQ29sb3IudG9DU1ModHJ1ZSlcblx0XHRcdFx0fTtcblx0XHRcdFx0aWYgKGFscGhhIDwgMSlcblx0XHRcdFx0XHRhdHRyc1snc3RvcC1vcGFjaXR5J10gPSBhbHBoYTtcblx0XHRcdFx0Z3JhZGllbnROb2RlLmFwcGVuZENoaWxkKGNyZWF0ZUVsZW1lbnQoJ3N0b3AnLCBhdHRycykpO1xuXHRcdFx0fVxuXHRcdFx0c2V0RGVmaW5pdGlvbihjb2xvciwgZ3JhZGllbnROb2RlLCAnY29sb3InKTtcblx0XHR9XG5cdFx0cmV0dXJuICd1cmwoIycgKyBncmFkaWVudE5vZGUuaWQgKyAnKSc7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnRUZXh0KGl0ZW0pIHtcblx0XHR2YXIgbm9kZSA9IGNyZWF0ZUVsZW1lbnQoJ3RleHQnLCBnZXRUcmFuc2Zvcm0oaXRlbS5fbWF0cml4LCB0cnVlKSk7XG5cdFx0bm9kZS50ZXh0Q29udGVudCA9IGl0ZW0uX2NvbnRlbnQ7XG5cdFx0cmV0dXJuIG5vZGU7XG5cdH1cblxuXHR2YXIgZXhwb3J0ZXJzID0ge1xuXHRcdEdyb3VwOiBleHBvcnRHcm91cCxcblx0XHRMYXllcjogZXhwb3J0R3JvdXAsXG5cdFx0UmFzdGVyOiBleHBvcnRSYXN0ZXIsXG5cdFx0UGF0aDogZXhwb3J0UGF0aCxcblx0XHRTaGFwZTogZXhwb3J0U2hhcGUsXG5cdFx0Q29tcG91bmRQYXRoOiBleHBvcnRDb21wb3VuZFBhdGgsXG5cdFx0UGxhY2VkU3ltYm9sOiBleHBvcnRQbGFjZWRTeW1ib2wsXG5cdFx0UG9pbnRUZXh0OiBleHBvcnRUZXh0XG5cdH07XG5cblx0ZnVuY3Rpb24gYXBwbHlTdHlsZShpdGVtLCBub2RlLCBpc1Jvb3QpIHtcblx0XHR2YXIgYXR0cnMgPSB7fSxcblx0XHRcdHBhcmVudCA9ICFpc1Jvb3QgJiYgaXRlbS5nZXRQYXJlbnQoKTtcblxuXHRcdGlmIChpdGVtLl9uYW1lICE9IG51bGwpXG5cdFx0XHRhdHRycy5pZCA9IGl0ZW0uX25hbWU7XG5cblx0XHRCYXNlLmVhY2goU1ZHU3R5bGVzLCBmdW5jdGlvbihlbnRyeSkge1xuXHRcdFx0dmFyIGdldCA9IGVudHJ5LmdldCxcblx0XHRcdFx0dHlwZSA9IGVudHJ5LnR5cGUsXG5cdFx0XHRcdHZhbHVlID0gaXRlbVtnZXRdKCk7XG5cdFx0XHRpZiAoZW50cnkuZXhwb3J0RmlsdGVyXG5cdFx0XHRcdFx0PyBlbnRyeS5leHBvcnRGaWx0ZXIoaXRlbSwgdmFsdWUpXG5cdFx0XHRcdFx0OiAhcGFyZW50IHx8ICFCYXNlLmVxdWFscyhwYXJlbnRbZ2V0XSgpLCB2YWx1ZSkpIHtcblx0XHRcdFx0aWYgKHR5cGUgPT09ICdjb2xvcicgJiYgdmFsdWUgIT0gbnVsbCkge1xuXHRcdFx0XHRcdHZhciBhbHBoYSA9IHZhbHVlLmdldEFscGhhKCk7XG5cdFx0XHRcdFx0aWYgKGFscGhhIDwgMSlcblx0XHRcdFx0XHRcdGF0dHJzW2VudHJ5LmF0dHJpYnV0ZSArICctb3BhY2l0eSddID0gYWxwaGE7XG5cdFx0XHRcdH1cblx0XHRcdFx0YXR0cnNbZW50cnkuYXR0cmlidXRlXSA9IHZhbHVlID09IG51bGxcblx0XHRcdFx0XHQ/ICdub25lJ1xuXHRcdFx0XHRcdDogdHlwZSA9PT0gJ251bWJlcidcblx0XHRcdFx0XHRcdD8gZm9ybWF0dGVyLm51bWJlcih2YWx1ZSlcblx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2NvbG9yJ1xuXHRcdFx0XHRcdFx0XHQ/IHZhbHVlLmdyYWRpZW50XG5cdFx0XHRcdFx0XHRcdFx0PyBleHBvcnRHcmFkaWVudCh2YWx1ZSwgaXRlbSlcblx0XHRcdFx0XHRcdFx0XHQ6IHZhbHVlLnRvQ1NTKHRydWUpXG5cdFx0XHRcdFx0XHRcdDogdHlwZSA9PT0gJ2FycmF5J1xuXHRcdFx0XHRcdFx0XHRcdD8gdmFsdWUuam9pbignLCcpXG5cdFx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnbG9va3VwJ1xuXHRcdFx0XHRcdFx0XHRcdFx0PyBlbnRyeS50b1NWR1t2YWx1ZV1cblx0XHRcdFx0XHRcdFx0XHRcdDogdmFsdWU7XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHRpZiAoYXR0cnMub3BhY2l0eSA9PT0gMSlcblx0XHRcdGRlbGV0ZSBhdHRycy5vcGFjaXR5O1xuXG5cdFx0aWYgKCFpdGVtLl92aXNpYmxlKVxuXHRcdFx0YXR0cnMudmlzaWJpbGl0eSA9ICdoaWRkZW4nO1xuXG5cdFx0cmV0dXJuIHNldEF0dHJpYnV0ZXMobm9kZSwgYXR0cnMpO1xuXHR9XG5cblx0dmFyIGRlZmluaXRpb25zO1xuXHRmdW5jdGlvbiBnZXREZWZpbml0aW9uKGl0ZW0sIHR5cGUpIHtcblx0XHRpZiAoIWRlZmluaXRpb25zKVxuXHRcdFx0ZGVmaW5pdGlvbnMgPSB7IGlkczoge30sIHN2Z3M6IHt9IH07XG5cdFx0cmV0dXJuIGl0ZW0gJiYgZGVmaW5pdGlvbnMuc3Znc1t0eXBlICsgJy0nICsgaXRlbS5faWRdO1xuXHR9XG5cblx0ZnVuY3Rpb24gc2V0RGVmaW5pdGlvbihpdGVtLCBub2RlLCB0eXBlKSB7XG5cdFx0aWYgKCFkZWZpbml0aW9ucylcblx0XHRcdGdldERlZmluaXRpb24oKTtcblx0XHR2YXIgaWQgPSBkZWZpbml0aW9ucy5pZHNbdHlwZV0gPSAoZGVmaW5pdGlvbnMuaWRzW3R5cGVdIHx8IDApICsgMTtcblx0XHRub2RlLmlkID0gdHlwZSArICctJyArIGlkO1xuXHRcdGRlZmluaXRpb25zLnN2Z3NbdHlwZSArICctJyArIGl0ZW0uX2lkXSA9IG5vZGU7XG5cdH1cblxuXHRmdW5jdGlvbiBleHBvcnREZWZpbml0aW9ucyhub2RlLCBvcHRpb25zKSB7XG5cdFx0dmFyIHN2ZyA9IG5vZGUsXG5cdFx0XHRkZWZzID0gbnVsbDtcblx0XHRpZiAoZGVmaW5pdGlvbnMpIHtcblx0XHRcdHN2ZyA9IG5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSA9PT0gJ3N2ZycgJiYgbm9kZTtcblx0XHRcdGZvciAodmFyIGkgaW4gZGVmaW5pdGlvbnMuc3Zncykge1xuXHRcdFx0XHRpZiAoIWRlZnMpIHtcblx0XHRcdFx0XHRpZiAoIXN2Zykge1xuXHRcdFx0XHRcdFx0c3ZnID0gY3JlYXRlRWxlbWVudCgnc3ZnJyk7XG5cdFx0XHRcdFx0XHRzdmcuYXBwZW5kQ2hpbGQobm9kZSk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGRlZnMgPSBzdmcuaW5zZXJ0QmVmb3JlKGNyZWF0ZUVsZW1lbnQoJ2RlZnMnKSxcblx0XHRcdFx0XHRcdFx0c3ZnLmZpcnN0Q2hpbGQpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGRlZnMuYXBwZW5kQ2hpbGQoZGVmaW5pdGlvbnMuc3Znc1tpXSk7XG5cdFx0XHR9XG5cdFx0XHRkZWZpbml0aW9ucyA9IG51bGw7XG5cdFx0fVxuXHRcdHJldHVybiBvcHRpb25zLmFzU3RyaW5nXG5cdFx0XHRcdD8gbmV3IFhNTFNlcmlhbGl6ZXIoKS5zZXJpYWxpemVUb1N0cmluZyhzdmcpXG5cdFx0XHRcdDogc3ZnO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhwb3J0U1ZHKGl0ZW0sIG9wdGlvbnMsIGlzUm9vdCkge1xuXHRcdHZhciBleHBvcnRlciA9IGV4cG9ydGVyc1tpdGVtLl9jbGFzc10sXG5cdFx0XHRub2RlID0gZXhwb3J0ZXIgJiYgZXhwb3J0ZXIoaXRlbSwgb3B0aW9ucyk7XG5cdFx0aWYgKG5vZGUpIHtcblx0XHRcdHZhciBvbkV4cG9ydCA9IG9wdGlvbnMub25FeHBvcnQ7XG5cdFx0XHRpZiAob25FeHBvcnQpXG5cdFx0XHRcdG5vZGUgPSBvbkV4cG9ydChpdGVtLCBub2RlLCBvcHRpb25zKSB8fCBub2RlO1xuXHRcdFx0dmFyIGRhdGEgPSBKU09OLnN0cmluZ2lmeShpdGVtLl9kYXRhKTtcblx0XHRcdGlmIChkYXRhICYmIGRhdGEgIT09ICd7fScgJiYgZGF0YSAhPT0gJ251bGwnKVxuXHRcdFx0XHRub2RlLnNldEF0dHJpYnV0ZSgnZGF0YS1wYXBlci1kYXRhJywgZGF0YSk7XG5cdFx0fVxuXHRcdHJldHVybiBub2RlICYmIGFwcGx5U3R5bGUoaXRlbSwgbm9kZSwgaXNSb290KTtcblx0fVxuXG5cdGZ1bmN0aW9uIHNldE9wdGlvbnMob3B0aW9ucykge1xuXHRcdGlmICghb3B0aW9ucylcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHRmb3JtYXR0ZXIgPSBuZXcgRm9ybWF0dGVyKG9wdGlvbnMucHJlY2lzaW9uKTtcblx0XHRyZXR1cm4gb3B0aW9ucztcblx0fVxuXG5cdEl0ZW0uaW5qZWN0KHtcblx0XHRleHBvcnRTVkc6IGZ1bmN0aW9uKG9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSBzZXRPcHRpb25zKG9wdGlvbnMpO1xuXHRcdFx0cmV0dXJuIGV4cG9ydERlZmluaXRpb25zKGV4cG9ydFNWRyh0aGlzLCBvcHRpb25zLCB0cnVlKSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcblxuXHRQcm9qZWN0LmluamVjdCh7XG5cdFx0ZXhwb3J0U1ZHOiBmdW5jdGlvbihvcHRpb25zKSB7XG5cdFx0XHRvcHRpb25zID0gc2V0T3B0aW9ucyhvcHRpb25zKTtcblx0XHRcdHZhciBsYXllcnMgPSB0aGlzLmxheWVycyxcblx0XHRcdFx0dmlldyA9IHRoaXMuZ2V0VmlldygpLFxuXHRcdFx0XHRzaXplID0gdmlldy5nZXRWaWV3U2l6ZSgpLFxuXHRcdFx0XHRub2RlID0gY3JlYXRlRWxlbWVudCgnc3ZnJywge1xuXHRcdFx0XHRcdHg6IDAsXG5cdFx0XHRcdFx0eTogMCxcblx0XHRcdFx0XHR3aWR0aDogc2l6ZS53aWR0aCxcblx0XHRcdFx0XHRoZWlnaHQ6IHNpemUuaGVpZ2h0LFxuXHRcdFx0XHRcdHZlcnNpb246ICcxLjEnLFxuXHRcdFx0XHRcdHhtbG5zOiAnaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmcnLFxuXHRcdFx0XHRcdCd4bWxuczp4bGluayc6ICdodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hsaW5rJ1xuXHRcdFx0XHR9KSxcblx0XHRcdFx0cGFyZW50ID0gbm9kZSxcblx0XHRcdFx0bWF0cml4ID0gdmlldy5fbWF0cml4O1xuXHRcdFx0aWYgKCFtYXRyaXguaXNJZGVudGl0eSgpKVxuXHRcdFx0XHRwYXJlbnQgPSBub2RlLmFwcGVuZENoaWxkKFxuXHRcdFx0XHRcdFx0Y3JlYXRlRWxlbWVudCgnZycsIGdldFRyYW5zZm9ybShtYXRyaXgpKSk7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGxheWVycy5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdHBhcmVudC5hcHBlbmRDaGlsZChleHBvcnRTVkcobGF5ZXJzW2ldLCBvcHRpb25zLCB0cnVlKSk7XG5cdFx0XHRyZXR1cm4gZXhwb3J0RGVmaW5pdGlvbnMobm9kZSwgb3B0aW9ucyk7XG5cdFx0fVxuXHR9KTtcbn07XG5cbm5ldyBmdW5jdGlvbigpIHtcblxuXHRmdW5jdGlvbiBnZXRWYWx1ZShub2RlLCBuYW1lLCBpc1N0cmluZywgYWxsb3dOdWxsKSB7XG5cdFx0dmFyIG5hbWVzcGFjZSA9IFNWR05hbWVzcGFjZXNbbmFtZV0sXG5cdFx0XHR2YWx1ZSA9IG5hbWVzcGFjZVxuXHRcdFx0XHQ/IG5vZGUuZ2V0QXR0cmlidXRlTlMobmFtZXNwYWNlLCBuYW1lKVxuXHRcdFx0XHQ6IG5vZGUuZ2V0QXR0cmlidXRlKG5hbWUpO1xuXHRcdGlmICh2YWx1ZSA9PT0gJ251bGwnKVxuXHRcdFx0dmFsdWUgPSBudWxsO1xuXHRcdHJldHVybiB2YWx1ZSA9PSBudWxsXG5cdFx0XHRcdD8gYWxsb3dOdWxsXG5cdFx0XHRcdFx0PyBudWxsXG5cdFx0XHRcdFx0OiBpc1N0cmluZ1xuXHRcdFx0XHRcdFx0PyAnJ1xuXHRcdFx0XHRcdFx0OiAwXG5cdFx0XHRcdDogaXNTdHJpbmdcblx0XHRcdFx0XHQ/IHZhbHVlXG5cdFx0XHRcdFx0OiBwYXJzZUZsb2F0KHZhbHVlKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGdldFBvaW50KG5vZGUsIHgsIHksIGFsbG93TnVsbCkge1xuXHRcdHggPSBnZXRWYWx1ZShub2RlLCB4LCBmYWxzZSwgYWxsb3dOdWxsKTtcblx0XHR5ID0gZ2V0VmFsdWUobm9kZSwgeSwgZmFsc2UsIGFsbG93TnVsbCk7XG5cdFx0cmV0dXJuIGFsbG93TnVsbCAmJiAoeCA9PSBudWxsIHx8IHkgPT0gbnVsbCkgPyBudWxsXG5cdFx0XHRcdDogbmV3IFBvaW50KHgsIHkpO1xuXHR9XG5cblx0ZnVuY3Rpb24gZ2V0U2l6ZShub2RlLCB3LCBoLCBhbGxvd051bGwpIHtcblx0XHR3ID0gZ2V0VmFsdWUobm9kZSwgdywgZmFsc2UsIGFsbG93TnVsbCk7XG5cdFx0aCA9IGdldFZhbHVlKG5vZGUsIGgsIGZhbHNlLCBhbGxvd051bGwpO1xuXHRcdHJldHVybiBhbGxvd051bGwgJiYgKHcgPT0gbnVsbCB8fCBoID09IG51bGwpID8gbnVsbFxuXHRcdFx0XHQ6IG5ldyBTaXplKHcsIGgpO1xuXHR9XG5cblx0ZnVuY3Rpb24gY29udmVydFZhbHVlKHZhbHVlLCB0eXBlLCBsb29rdXApIHtcblx0XHRyZXR1cm4gdmFsdWUgPT09ICdub25lJ1xuXHRcdFx0XHQ/IG51bGxcblx0XHRcdFx0OiB0eXBlID09PSAnbnVtYmVyJ1xuXHRcdFx0XHRcdD8gcGFyc2VGbG9hdCh2YWx1ZSlcblx0XHRcdFx0XHQ6IHR5cGUgPT09ICdhcnJheSdcblx0XHRcdFx0XHRcdD8gdmFsdWUgPyB2YWx1ZS5zcGxpdCgvW1xccyxdKy9nKS5tYXAocGFyc2VGbG9hdCkgOiBbXVxuXHRcdFx0XHRcdFx0OiB0eXBlID09PSAnY29sb3InXG5cdFx0XHRcdFx0XHRcdD8gZ2V0RGVmaW5pdGlvbih2YWx1ZSkgfHwgdmFsdWVcblx0XHRcdFx0XHRcdFx0OiB0eXBlID09PSAnbG9va3VwJ1xuXHRcdFx0XHRcdFx0XHRcdD8gbG9va3VwW3ZhbHVlXVxuXHRcdFx0XHRcdFx0XHRcdDogdmFsdWU7XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRHcm91cChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHR2YXIgbm9kZXMgPSBub2RlLmNoaWxkTm9kZXMsXG5cdFx0XHRpc0NsaXAgPSB0eXBlID09PSAnY2xpcHBhdGgnLFxuXHRcdFx0aXRlbSA9IG5ldyBHcm91cCgpLFxuXHRcdFx0cHJvamVjdCA9IGl0ZW0uX3Byb2plY3QsXG5cdFx0XHRjdXJyZW50U3R5bGUgPSBwcm9qZWN0Ll9jdXJyZW50U3R5bGUsXG5cdFx0XHRjaGlsZHJlbiA9IFtdO1xuXHRcdGlmICghaXNDbGlwKSB7XG5cdFx0XHRpdGVtID0gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCk7XG5cdFx0XHRwcm9qZWN0Ll9jdXJyZW50U3R5bGUgPSBpdGVtLl9zdHlsZS5jbG9uZSgpO1xuXHRcdH1cblx0XHRpZiAoaXNSb290KSB7XG5cdFx0XHR2YXIgZGVmcyA9IG5vZGUucXVlcnlTZWxlY3RvckFsbCgnZGVmcycpO1xuXHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSBkZWZzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0XHRpbXBvcnRTVkcoZGVmc1tpXSwgb3B0aW9ucywgZmFsc2UpO1xuXHRcdFx0fVxuXHRcdH1cblx0XHRmb3IgKHZhciBpID0gMCwgbCA9IG5vZGVzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIGNoaWxkTm9kZSA9IG5vZGVzW2ldLFxuXHRcdFx0XHRjaGlsZDtcblx0XHRcdGlmIChjaGlsZE5vZGUubm9kZVR5cGUgPT09IDFcblx0XHRcdFx0XHQmJiBjaGlsZE5vZGUubm9kZU5hbWUudG9Mb3dlckNhc2UoKSAhPT0gJ2RlZnMnXG5cdFx0XHRcdFx0JiYgKGNoaWxkID0gaW1wb3J0U1ZHKGNoaWxkTm9kZSwgb3B0aW9ucywgZmFsc2UpKVxuXHRcdFx0XHRcdCYmICEoY2hpbGQgaW5zdGFuY2VvZiBTeW1ib2wpKVxuXHRcdFx0XHRjaGlsZHJlbi5wdXNoKGNoaWxkKTtcblx0XHR9XG5cdFx0aXRlbS5hZGRDaGlsZHJlbihjaGlsZHJlbik7XG5cdFx0aWYgKGlzQ2xpcClcblx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbS5yZWR1Y2UoKSwgbm9kZSwgaXNSb290KTtcblx0XHRwcm9qZWN0Ll9jdXJyZW50U3R5bGUgPSBjdXJyZW50U3R5bGU7XG5cdFx0aWYgKGlzQ2xpcCB8fCB0eXBlID09PSAnZGVmcycpIHtcblx0XHRcdGl0ZW0ucmVtb3ZlKCk7XG5cdFx0XHRpdGVtID0gbnVsbDtcblx0XHR9XG5cdFx0cmV0dXJuIGl0ZW07XG5cdH1cblxuXHRmdW5jdGlvbiBpbXBvcnRQb2x5KG5vZGUsIHR5cGUpIHtcblx0XHR2YXIgY29vcmRzID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ3BvaW50cycpLm1hdGNoKFxuXHRcdFx0XHRcdC9bKy1dPyg/OlxcZCpcXC5cXGQrfFxcZCtcXC4/KSg/OltlRV1bKy1dP1xcZCspPy9nKSxcblx0XHRcdHBvaW50cyA9IFtdO1xuXHRcdGZvciAodmFyIGkgPSAwLCBsID0gY29vcmRzLmxlbmd0aDsgaSA8IGw7IGkgKz0gMilcblx0XHRcdHBvaW50cy5wdXNoKG5ldyBQb2ludChcblx0XHRcdFx0XHRwYXJzZUZsb2F0KGNvb3Jkc1tpXSksXG5cdFx0XHRcdFx0cGFyc2VGbG9hdChjb29yZHNbaSArIDFdKSkpO1xuXHRcdHZhciBwYXRoID0gbmV3IFBhdGgocG9pbnRzKTtcblx0XHRpZiAodHlwZSA9PT0gJ3BvbHlnb24nKVxuXHRcdFx0cGF0aC5jbG9zZVBhdGgoKTtcblx0XHRyZXR1cm4gcGF0aDtcblx0fVxuXG5cdGZ1bmN0aW9uIGltcG9ydFBhdGgobm9kZSkge1xuXHRcdHZhciBkYXRhID0gbm9kZS5nZXRBdHRyaWJ1dGUoJ2QnKSxcblx0XHRcdHBhcmFtID0geyBwYXRoRGF0YTogZGF0YSB9O1xuXHRcdHJldHVybiAoZGF0YS5tYXRjaCgvbS9naSkgfHwgW10pLmxlbmd0aCA+IDEgfHwgL3pcXFMrL2kudGVzdChkYXRhKVxuXHRcdFx0XHQ/IG5ldyBDb21wb3VuZFBhdGgocGFyYW0pXG5cdFx0XHRcdDogbmV3IFBhdGgocGFyYW0pO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0R3JhZGllbnQobm9kZSwgdHlwZSkge1xuXHRcdHZhciBpZCA9IChnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpIHx8ICcnKS5zdWJzdHJpbmcoMSksXG5cdFx0XHRpc1JhZGlhbCA9IHR5cGUgPT09ICdyYWRpYWxncmFkaWVudCcsXG5cdFx0XHRncmFkaWVudDtcblx0XHRpZiAoaWQpIHtcblx0XHRcdGdyYWRpZW50ID0gZGVmaW5pdGlvbnNbaWRdLmdldEdyYWRpZW50KCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcyxcblx0XHRcdFx0c3RvcHMgPSBbXTtcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IG5vZGVzW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpXG5cdFx0XHRcdFx0c3RvcHMucHVzaChhcHBseUF0dHJpYnV0ZXMobmV3IEdyYWRpZW50U3RvcCgpLCBjaGlsZCkpO1xuXHRcdFx0fVxuXHRcdFx0Z3JhZGllbnQgPSBuZXcgR3JhZGllbnQoc3RvcHMsIGlzUmFkaWFsKTtcblx0XHR9XG5cdFx0dmFyIG9yaWdpbiwgZGVzdGluYXRpb24sIGhpZ2hsaWdodDtcblx0XHRpZiAoaXNSYWRpYWwpIHtcblx0XHRcdG9yaWdpbiA9IGdldFBvaW50KG5vZGUsICdjeCcsICdjeScpO1xuXHRcdFx0ZGVzdGluYXRpb24gPSBvcmlnaW4uYWRkKGdldFZhbHVlKG5vZGUsICdyJyksIDApO1xuXHRcdFx0aGlnaGxpZ2h0ID0gZ2V0UG9pbnQobm9kZSwgJ2Z4JywgJ2Z5JywgdHJ1ZSk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdG9yaWdpbiA9IGdldFBvaW50KG5vZGUsICd4MScsICd5MScpO1xuXHRcdFx0ZGVzdGluYXRpb24gPSBnZXRQb2ludChub2RlLCAneDInLCAneTInKTtcblx0XHR9XG5cdFx0YXBwbHlBdHRyaWJ1dGVzKFxuXHRcdFx0bmV3IENvbG9yKGdyYWRpZW50LCBvcmlnaW4sIGRlc3RpbmF0aW9uLCBoaWdobGlnaHQpLCBub2RlKTtcblx0XHRyZXR1cm4gbnVsbDtcblx0fVxuXG5cdHZhciBpbXBvcnRlcnMgPSB7XG5cdFx0JyNkb2N1bWVudCc6IGZ1bmN0aW9uIChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpIHtcblx0XHRcdHZhciBub2RlcyA9IG5vZGUuY2hpbGROb2Rlcztcblx0XHRcdGZvciAodmFyIGkgPSAwLCBsID0gbm9kZXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBjaGlsZCA9IG5vZGVzW2ldO1xuXHRcdFx0XHRpZiAoY2hpbGQubm9kZVR5cGUgPT09IDEpIHtcblx0XHRcdFx0XHR2YXIgbmV4dCA9IGNoaWxkLm5leHRTaWJsaW5nO1xuXHRcdFx0XHRcdGRvY3VtZW50LmJvZHkuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHRcdHZhciBpdGVtID0gaW1wb3J0U1ZHKGNoaWxkLCBvcHRpb25zLCBpc1Jvb3QpO1xuXHRcdFx0XHRcdGlmIChuZXh0KSB7XG5cdFx0XHRcdFx0XHRub2RlLmluc2VydEJlZm9yZShjaGlsZCwgbmV4dCk7XG5cdFx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRcdG5vZGUuYXBwZW5kQ2hpbGQoY2hpbGQpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRyZXR1cm4gaXRlbTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0sXG5cdFx0ZzogaW1wb3J0R3JvdXAsXG5cdFx0c3ZnOiBpbXBvcnRHcm91cCxcblx0XHRjbGlwcGF0aDogaW1wb3J0R3JvdXAsXG5cdFx0cG9seWdvbjogaW1wb3J0UG9seSxcblx0XHRwb2x5bGluZTogaW1wb3J0UG9seSxcblx0XHRwYXRoOiBpbXBvcnRQYXRoLFxuXHRcdGxpbmVhcmdyYWRpZW50OiBpbXBvcnRHcmFkaWVudCxcblx0XHRyYWRpYWxncmFkaWVudDogaW1wb3J0R3JhZGllbnQsXG5cblx0XHRpbWFnZTogZnVuY3Rpb24gKG5vZGUpIHtcblx0XHRcdHZhciByYXN0ZXIgPSBuZXcgUmFzdGVyKGdldFZhbHVlKG5vZGUsICdocmVmJywgdHJ1ZSkpO1xuXHRcdFx0cmFzdGVyLm9uKCdsb2FkJywgZnVuY3Rpb24oKSB7XG5cdFx0XHRcdHZhciBzaXplID0gZ2V0U2l6ZShub2RlLCAnd2lkdGgnLCAnaGVpZ2h0Jyk7XG5cdFx0XHRcdHRoaXMuc2V0U2l6ZShzaXplKTtcblx0XHRcdFx0dmFyIGNlbnRlciA9IHRoaXMuX21hdHJpeC5fdHJhbnNmb3JtUG9pbnQoXG5cdFx0XHRcdFx0XHRnZXRQb2ludChub2RlLCAneCcsICd5JykuYWRkKHNpemUuZGl2aWRlKDIpKSk7XG5cdFx0XHRcdHRoaXMudHJhbnNsYXRlKGNlbnRlcik7XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiByYXN0ZXI7XG5cdFx0fSxcblxuXHRcdHN5bWJvbDogZnVuY3Rpb24obm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0XHRyZXR1cm4gbmV3IFN5bWJvbChpbXBvcnRHcm91cChub2RlLCB0eXBlLCBvcHRpb25zLCBpc1Jvb3QpLCB0cnVlKTtcblx0XHR9LFxuXG5cdFx0ZGVmczogaW1wb3J0R3JvdXAsXG5cblx0XHR1c2U6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBpZCA9IChnZXRWYWx1ZShub2RlLCAnaHJlZicsIHRydWUpIHx8ICcnKS5zdWJzdHJpbmcoMSksXG5cdFx0XHRcdGRlZmluaXRpb24gPSBkZWZpbml0aW9uc1tpZF0sXG5cdFx0XHRcdHBvaW50ID0gZ2V0UG9pbnQobm9kZSwgJ3gnLCAneScpO1xuXHRcdFx0cmV0dXJuIGRlZmluaXRpb25cblx0XHRcdFx0XHQ/IGRlZmluaXRpb24gaW5zdGFuY2VvZiBTeW1ib2xcblx0XHRcdFx0XHRcdD8gZGVmaW5pdGlvbi5wbGFjZShwb2ludClcblx0XHRcdFx0XHRcdDogZGVmaW5pdGlvbi5jbG9uZSgpLnRyYW5zbGF0ZShwb2ludClcblx0XHRcdFx0XHQ6IG51bGw7XG5cdFx0fSxcblxuXHRcdGNpcmNsZTogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5DaXJjbGUoZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG5cdFx0XHRcdFx0Z2V0VmFsdWUobm9kZSwgJ3InKSk7XG5cdFx0fSxcblxuXHRcdGVsbGlwc2U6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgU2hhcGUuRWxsaXBzZSh7XG5cdFx0XHRcdGNlbnRlcjogZ2V0UG9pbnQobm9kZSwgJ2N4JywgJ2N5JyksXG5cdFx0XHRcdHJhZGl1czogZ2V0U2l6ZShub2RlLCAncngnLCAncnknKVxuXHRcdFx0fSk7XG5cdFx0fSxcblxuXHRcdHJlY3Q6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHZhciBwb2ludCA9IGdldFBvaW50KG5vZGUsICd4JywgJ3knKSxcblx0XHRcdFx0c2l6ZSA9IGdldFNpemUobm9kZSwgJ3dpZHRoJywgJ2hlaWdodCcpLFxuXHRcdFx0XHRyYWRpdXMgPSBnZXRTaXplKG5vZGUsICdyeCcsICdyeScpO1xuXHRcdFx0cmV0dXJuIG5ldyBTaGFwZS5SZWN0YW5nbGUobmV3IFJlY3RhbmdsZShwb2ludCwgc2l6ZSksIHJhZGl1cyk7XG5cdFx0fSxcblxuXHRcdGxpbmU6IGZ1bmN0aW9uKG5vZGUpIHtcblx0XHRcdHJldHVybiBuZXcgUGF0aC5MaW5lKGdldFBvaW50KG5vZGUsICd4MScsICd5MScpLFxuXHRcdFx0XHRcdGdldFBvaW50KG5vZGUsICd4MicsICd5MicpKTtcblx0XHR9LFxuXG5cdFx0dGV4dDogZnVuY3Rpb24obm9kZSkge1xuXHRcdFx0dmFyIHRleHQgPSBuZXcgUG9pbnRUZXh0KGdldFBvaW50KG5vZGUsICd4JywgJ3knKVxuXHRcdFx0XHRcdC5hZGQoZ2V0UG9pbnQobm9kZSwgJ2R4JywgJ2R5JykpKTtcblx0XHRcdHRleHQuc2V0Q29udGVudChub2RlLnRleHRDb250ZW50LnRyaW0oKSB8fCAnJyk7XG5cdFx0XHRyZXR1cm4gdGV4dDtcblx0XHR9XG5cdH07XG5cblx0ZnVuY3Rpb24gYXBwbHlUcmFuc2Zvcm0oaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUpIHtcblx0XHR2YXIgdHJhbnNmb3JtcyA9IChub2RlLmdldEF0dHJpYnV0ZShuYW1lKSB8fCAnJykuc3BsaXQoL1xcKVxccyovZyksXG5cdFx0XHRtYXRyaXggPSBuZXcgTWF0cml4KCk7XG5cdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB0cmFuc2Zvcm1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuXHRcdFx0dmFyIHRyYW5zZm9ybSA9IHRyYW5zZm9ybXNbaV07XG5cdFx0XHRpZiAoIXRyYW5zZm9ybSlcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR2YXIgcGFydHMgPSB0cmFuc2Zvcm0uc3BsaXQoL1xcKFxccyovKSxcblx0XHRcdFx0Y29tbWFuZCA9IHBhcnRzWzBdLFxuXHRcdFx0XHR2ID0gcGFydHNbMV0uc3BsaXQoL1tcXHMsXSsvZyk7XG5cdFx0XHRmb3IgKHZhciBqID0gMCwgbSA9IHYubGVuZ3RoOyBqIDwgbTsgaisrKVxuXHRcdFx0XHR2W2pdID0gcGFyc2VGbG9hdCh2W2pdKTtcblx0XHRcdHN3aXRjaCAoY29tbWFuZCkge1xuXHRcdFx0Y2FzZSAnbWF0cml4Jzpcblx0XHRcdFx0bWF0cml4LmNvbmNhdGVuYXRlKFxuXHRcdFx0XHRcdFx0bmV3IE1hdHJpeCh2WzBdLCB2WzFdLCB2WzJdLCB2WzNdLCB2WzRdLCB2WzVdKSk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAncm90YXRlJzpcblx0XHRcdFx0bWF0cml4LnJvdGF0ZSh2WzBdLCB2WzFdLCB2WzJdKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRjYXNlICd0cmFuc2xhdGUnOlxuXHRcdFx0XHRtYXRyaXgudHJhbnNsYXRlKHZbMF0sIHZbMV0pO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3NjYWxlJzpcblx0XHRcdFx0bWF0cml4LnNjYWxlKHYpO1xuXHRcdFx0XHRicmVhaztcblx0XHRcdGNhc2UgJ3NrZXdYJzpcblx0XHRcdFx0bWF0cml4LnNrZXcodlswXSwgMCk7XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnc2tld1knOlxuXHRcdFx0XHRtYXRyaXguc2tldygwLCB2WzBdKTtcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGl0ZW0udHJhbnNmb3JtKG1hdHJpeCk7XG5cdH1cblxuXHRmdW5jdGlvbiBhcHBseU9wYWNpdHkoaXRlbSwgdmFsdWUsIG5hbWUpIHtcblx0XHR2YXIgY29sb3IgPSBpdGVtW25hbWUgPT09ICdmaWxsLW9wYWNpdHknID8gJ2dldEZpbGxDb2xvcidcblx0XHRcdFx0OiAnZ2V0U3Ryb2tlQ29sb3InXSgpO1xuXHRcdGlmIChjb2xvcilcblx0XHRcdGNvbG9yLnNldEFscGhhKHBhcnNlRmxvYXQodmFsdWUpKTtcblx0fVxuXG5cdHZhciBhdHRyaWJ1dGVzID0gQmFzZS5zZXQoQmFzZS5lYWNoKFNWR1N0eWxlcywgZnVuY3Rpb24oZW50cnkpIHtcblx0XHR0aGlzW2VudHJ5LmF0dHJpYnV0ZV0gPSBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aXRlbVtlbnRyeS5zZXRdKGNvbnZlcnRWYWx1ZSh2YWx1ZSwgZW50cnkudHlwZSwgZW50cnkuZnJvbVNWRykpO1xuXHRcdFx0aWYgKGVudHJ5LnR5cGUgPT09ICdjb2xvcicgJiYgaXRlbSBpbnN0YW5jZW9mIFNoYXBlKSB7XG5cdFx0XHRcdHZhciBjb2xvciA9IGl0ZW1bZW50cnkuZ2V0XSgpO1xuXHRcdFx0XHRpZiAoY29sb3IpXG5cdFx0XHRcdFx0Y29sb3IudHJhbnNmb3JtKG5ldyBNYXRyaXgoKS50cmFuc2xhdGUoXG5cdFx0XHRcdFx0XHRcdGl0ZW0uZ2V0UG9zaXRpb24odHJ1ZSkubmVnYXRlKCkpKTtcblx0XHRcdH1cblx0XHR9O1xuXHR9LCB7fSksIHtcblx0XHRpZDogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGRlZmluaXRpb25zW3ZhbHVlXSA9IGl0ZW07XG5cdFx0XHRpZiAoaXRlbS5zZXROYW1lKVxuXHRcdFx0XHRpdGVtLnNldE5hbWUodmFsdWUpO1xuXHRcdH0sXG5cblx0XHQnY2xpcC1wYXRoJzogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdHZhciBjbGlwID0gZ2V0RGVmaW5pdGlvbih2YWx1ZSk7XG5cdFx0XHRpZiAoY2xpcCkge1xuXHRcdFx0XHRjbGlwID0gY2xpcC5jbG9uZSgpO1xuXHRcdFx0XHRjbGlwLnNldENsaXBNYXNrKHRydWUpO1xuXHRcdFx0XHRpZiAoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG5cdFx0XHRcdFx0aXRlbS5pbnNlcnRDaGlsZCgwLCBjbGlwKTtcblx0XHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0XHRyZXR1cm4gbmV3IEdyb3VwKGNsaXAsIGl0ZW0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSxcblxuXHRcdGdyYWRpZW50VHJhbnNmb3JtOiBhcHBseVRyYW5zZm9ybSxcblx0XHR0cmFuc2Zvcm06IGFwcGx5VHJhbnNmb3JtLFxuXG5cdFx0J2ZpbGwtb3BhY2l0eSc6IGFwcGx5T3BhY2l0eSxcblx0XHQnc3Ryb2tlLW9wYWNpdHknOiBhcHBseU9wYWNpdHksXG5cblx0XHR2aXNpYmlsaXR5OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aXRlbS5zZXRWaXNpYmxlKHZhbHVlID09PSAndmlzaWJsZScpO1xuXHRcdH0sXG5cblx0XHRkaXNwbGF5OiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aXRlbS5zZXRWaXNpYmxlKHZhbHVlICE9PSBudWxsKTtcblx0XHR9LFxuXG5cdFx0J3N0b3AtY29sb3InOiBmdW5jdGlvbihpdGVtLCB2YWx1ZSkge1xuXHRcdFx0aWYgKGl0ZW0uc2V0Q29sb3IpXG5cdFx0XHRcdGl0ZW0uc2V0Q29sb3IodmFsdWUpO1xuXHRcdH0sXG5cblx0XHQnc3RvcC1vcGFjaXR5JzogZnVuY3Rpb24oaXRlbSwgdmFsdWUpIHtcblx0XHRcdGlmIChpdGVtLl9jb2xvcilcblx0XHRcdFx0aXRlbS5fY29sb3Iuc2V0QWxwaGEocGFyc2VGbG9hdCh2YWx1ZSkpO1xuXHRcdH0sXG5cblx0XHRvZmZzZXQ6IGZ1bmN0aW9uKGl0ZW0sIHZhbHVlKSB7XG5cdFx0XHR2YXIgcGVyY2VudGFnZSA9IHZhbHVlLm1hdGNoKC8oLiopJSQvKTtcblx0XHRcdGl0ZW0uc2V0UmFtcFBvaW50KHBlcmNlbnRhZ2Vcblx0XHRcdFx0XHQ/IHBlcmNlbnRhZ2VbMV0gLyAxMDBcblx0XHRcdFx0XHQ6IHBhcnNlRmxvYXQodmFsdWUpKTtcblx0XHR9LFxuXG5cdFx0dmlld0JveDogZnVuY3Rpb24oaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUsIHN0eWxlcykge1xuXHRcdFx0dmFyIHJlY3QgPSBuZXcgUmVjdGFuZ2xlKGNvbnZlcnRWYWx1ZSh2YWx1ZSwgJ2FycmF5JykpLFxuXHRcdFx0XHRzaXplID0gZ2V0U2l6ZShub2RlLCAnd2lkdGgnLCAnaGVpZ2h0JywgdHJ1ZSk7XG5cdFx0XHRpZiAoaXRlbSBpbnN0YW5jZW9mIEdyb3VwKSB7XG5cdFx0XHRcdHZhciBzY2FsZSA9IHNpemUgPyByZWN0LmdldFNpemUoKS5kaXZpZGUoc2l6ZSkgOiAxLFxuXHRcdFx0XHRcdG1hdHJpeCA9IG5ldyBNYXRyaXgoKS50cmFuc2xhdGUocmVjdC5nZXRQb2ludCgpKS5zY2FsZShzY2FsZSk7XG5cdFx0XHRcdGl0ZW0udHJhbnNmb3JtKG1hdHJpeC5pbnZlcnRlZCgpKTtcblx0XHRcdH0gZWxzZSBpZiAoaXRlbSBpbnN0YW5jZW9mIFN5bWJvbCkge1xuXHRcdFx0XHRpZiAoc2l6ZSlcblx0XHRcdFx0XHRyZWN0LnNldFNpemUoc2l6ZSk7XG5cdFx0XHRcdHZhciBjbGlwID0gZ2V0QXR0cmlidXRlKG5vZGUsICdvdmVyZmxvdycsIHN0eWxlcykgIT0gJ3Zpc2libGUnLFxuXHRcdFx0XHRcdGdyb3VwID0gaXRlbS5fZGVmaW5pdGlvbjtcblx0XHRcdFx0aWYgKGNsaXAgJiYgIXJlY3QuY29udGFpbnMoZ3JvdXAuZ2V0Qm91bmRzKCkpKSB7XG5cdFx0XHRcdFx0Y2xpcCA9IG5ldyBTaGFwZS5SZWN0YW5nbGUocmVjdCkudHJhbnNmb3JtKGdyb3VwLl9tYXRyaXgpO1xuXHRcdFx0XHRcdGNsaXAuc2V0Q2xpcE1hc2sodHJ1ZSk7XG5cdFx0XHRcdFx0Z3JvdXAuYWRkQ2hpbGQoY2xpcCk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cdH0pO1xuXG5cdGZ1bmN0aW9uIGdldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBzdHlsZXMpIHtcblx0XHR2YXIgYXR0ciA9IG5vZGUuYXR0cmlidXRlc1tuYW1lXSxcblx0XHRcdHZhbHVlID0gYXR0ciAmJiBhdHRyLnZhbHVlO1xuXHRcdGlmICghdmFsdWUpIHtcblx0XHRcdHZhciBzdHlsZSA9IEJhc2UuY2FtZWxpemUobmFtZSk7XG5cdFx0XHR2YWx1ZSA9IG5vZGUuc3R5bGVbc3R5bGVdO1xuXHRcdFx0aWYgKCF2YWx1ZSAmJiBzdHlsZXMubm9kZVtzdHlsZV0gIT09IHN0eWxlcy5wYXJlbnRbc3R5bGVdKVxuXHRcdFx0XHR2YWx1ZSA9IHN0eWxlcy5ub2RlW3N0eWxlXTtcblx0XHR9XG5cdFx0cmV0dXJuICF2YWx1ZVxuXHRcdFx0XHQ/IHVuZGVmaW5lZFxuXHRcdFx0XHQ6IHZhbHVlID09PSAnbm9uZSdcblx0XHRcdFx0XHQ/IG51bGxcblx0XHRcdFx0XHQ6IHZhbHVlO1xuXHR9XG5cblx0ZnVuY3Rpb24gYXBwbHlBdHRyaWJ1dGVzKGl0ZW0sIG5vZGUsIGlzUm9vdCkge1xuXHRcdHZhciBzdHlsZXMgPSB7XG5cdFx0XHRub2RlOiBEb21FbGVtZW50LmdldFN0eWxlcyhub2RlKSB8fCB7fSxcblx0XHRcdHBhcmVudDogIWlzUm9vdCAmJiBEb21FbGVtZW50LmdldFN0eWxlcyhub2RlLnBhcmVudE5vZGUpIHx8IHt9XG5cdFx0fTtcblx0XHRCYXNlLmVhY2goYXR0cmlidXRlcywgZnVuY3Rpb24oYXBwbHksIG5hbWUpIHtcblx0XHRcdHZhciB2YWx1ZSA9IGdldEF0dHJpYnV0ZShub2RlLCBuYW1lLCBzdHlsZXMpO1xuXHRcdFx0aWYgKHZhbHVlICE9PSB1bmRlZmluZWQpXG5cdFx0XHRcdGl0ZW0gPSBCYXNlLnBpY2soYXBwbHkoaXRlbSwgdmFsdWUsIG5hbWUsIG5vZGUsIHN0eWxlcyksIGl0ZW0pO1xuXHRcdH0pO1xuXHRcdHJldHVybiBpdGVtO1xuXHR9XG5cblx0dmFyIGRlZmluaXRpb25zID0ge307XG5cdGZ1bmN0aW9uIGdldERlZmluaXRpb24odmFsdWUpIHtcblx0XHR2YXIgbWF0Y2ggPSB2YWx1ZSAmJiB2YWx1ZS5tYXRjaCgvXFwoKD86I3wpKFteKSddKykvKTtcblx0XHRyZXR1cm4gbWF0Y2ggJiYgZGVmaW5pdGlvbnNbbWF0Y2hbMV1dO1xuXHR9XG5cblx0ZnVuY3Rpb24gaW1wb3J0U1ZHKHNvdXJjZSwgb3B0aW9ucywgaXNSb290KSB7XG5cdFx0aWYgKCFzb3VyY2UpXG5cdFx0XHRyZXR1cm4gbnVsbDtcblx0XHRpZiAoIW9wdGlvbnMpIHtcblx0XHRcdG9wdGlvbnMgPSB7fTtcblx0XHR9IGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKSB7XG5cdFx0XHRvcHRpb25zID0geyBvbkxvYWQ6IG9wdGlvbnMgfTtcblx0XHR9XG5cblx0XHR2YXIgbm9kZSA9IHNvdXJjZSxcblx0XHRcdHNjb3BlID0gcGFwZXI7XG5cblx0XHRmdW5jdGlvbiBvbkxvYWRDYWxsYmFjayhzdmcpIHtcblx0XHRcdHBhcGVyID0gc2NvcGU7XG5cdFx0XHR2YXIgaXRlbSA9IGltcG9ydFNWRyhzdmcsIG9wdGlvbnMsIGlzUm9vdCksXG5cdFx0XHRcdG9uTG9hZCA9IG9wdGlvbnMub25Mb2FkLFxuXHRcdFx0XHR2aWV3ID0gc2NvcGUucHJvamVjdCAmJiBzY29wZS5nZXRWaWV3KCk7XG5cdFx0XHRpZiAob25Mb2FkKVxuXHRcdFx0XHRvbkxvYWQuY2FsbCh0aGlzLCBpdGVtKTtcblx0XHRcdHZpZXcudXBkYXRlKCk7XG5cdFx0fVxuXG5cdFx0aWYgKGlzUm9vdCkge1xuXHRcdFx0aWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnICYmICEvXi4qPC8udGVzdChzb3VyY2UpKSB7XG5cdFx0XHRcdG5vZGUgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChzb3VyY2UpO1xuXHRcdFx0XHRpZiAobm9kZSkge1xuXHRcdFx0XHRcdHNvdXJjZSA9IG51bGw7XG5cdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0cmV0dXJuIEh0dHAucmVxdWVzdCgnZ2V0Jywgc291cmNlLCBvbkxvYWRDYWxsYmFjayk7XG5cdFx0XHRcdH1cblx0XHRcdH0gZWxzZSBpZiAodHlwZW9mIEZpbGUgIT09ICd1bmRlZmluZWQnICYmIHNvdXJjZSBpbnN0YW5jZW9mIEZpbGUpIHtcblx0XHRcdFx0dmFyIHJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG5cdFx0XHRcdHJlYWRlci5vbmxvYWQgPSBmdW5jdGlvbigpIHtcblx0XHRcdFx0XHRvbkxvYWRDYWxsYmFjayhyZWFkZXIucmVzdWx0KTtcblx0XHRcdFx0fTtcblx0XHRcdFx0cmV0dXJuIHJlYWRlci5yZWFkQXNUZXh0KHNvdXJjZSk7XG5cdFx0XHR9XG5cdFx0fVxuXG5cdFx0aWYgKHR5cGVvZiBzb3VyY2UgPT09ICdzdHJpbmcnKVxuXHRcdFx0bm9kZSA9IG5ldyBET01QYXJzZXIoKS5wYXJzZUZyb21TdHJpbmcoc291cmNlLCAnaW1hZ2Uvc3ZnK3htbCcpO1xuXHRcdGlmICghbm9kZS5ub2RlTmFtZSlcblx0XHRcdHRocm93IG5ldyBFcnJvcignVW5zdXBwb3J0ZWQgU1ZHIHNvdXJjZTogJyArIHNvdXJjZSk7XG5cdFx0dmFyIHR5cGUgPSBub2RlLm5vZGVOYW1lLnRvTG93ZXJDYXNlKCksXG5cdFx0XHRpbXBvcnRlciA9IGltcG9ydGVyc1t0eXBlXSxcblx0XHRcdGl0ZW0sXG5cdFx0XHRkYXRhID0gbm9kZS5nZXRBdHRyaWJ1dGUgJiYgbm9kZS5nZXRBdHRyaWJ1dGUoJ2RhdGEtcGFwZXItZGF0YScpLFxuXHRcdFx0c2V0dGluZ3MgPSBzY29wZS5zZXR0aW5ncyxcblx0XHRcdGFwcGx5TWF0cml4ID0gc2V0dGluZ3MuYXBwbHlNYXRyaXg7XG5cdFx0c2V0dGluZ3MuYXBwbHlNYXRyaXggPSBmYWxzZTtcblx0XHRpdGVtID0gaW1wb3J0ZXIgJiYgaW1wb3J0ZXIobm9kZSwgdHlwZSwgb3B0aW9ucywgaXNSb290KSB8fCBudWxsO1xuXHRcdHNldHRpbmdzLmFwcGx5TWF0cml4ID0gYXBwbHlNYXRyaXg7XG5cdFx0aWYgKGl0ZW0pIHtcblx0XHRcdGlmICh0eXBlICE9PSAnI2RvY3VtZW50JyAmJiAhKGl0ZW0gaW5zdGFuY2VvZiBHcm91cCkpXG5cdFx0XHRcdGl0ZW0gPSBhcHBseUF0dHJpYnV0ZXMoaXRlbSwgbm9kZSwgaXNSb290KTtcblx0XHRcdHZhciBvbkltcG9ydCA9IG9wdGlvbnMub25JbXBvcnQ7XG5cdFx0XHRpZiAob25JbXBvcnQpXG5cdFx0XHRcdGl0ZW0gPSBvbkltcG9ydChub2RlLCBpdGVtLCBvcHRpb25zKSB8fCBpdGVtO1xuXHRcdFx0aWYgKG9wdGlvbnMuZXhwYW5kU2hhcGVzICYmIGl0ZW0gaW5zdGFuY2VvZiBTaGFwZSkge1xuXHRcdFx0XHRpdGVtLnJlbW92ZSgpO1xuXHRcdFx0XHRpdGVtID0gaXRlbS50b1BhdGgoKTtcblx0XHRcdH1cblx0XHRcdGlmIChkYXRhKVxuXHRcdFx0XHRpdGVtLl9kYXRhID0gSlNPTi5wYXJzZShkYXRhKTtcblx0XHR9XG5cdFx0aWYgKGlzUm9vdCkge1xuXHRcdFx0ZGVmaW5pdGlvbnMgPSB7fTtcblx0XHRcdGlmIChpdGVtICYmIEJhc2UucGljayhvcHRpb25zLmFwcGx5TWF0cml4LCBhcHBseU1hdHJpeCkpXG5cdFx0XHRcdGl0ZW0ubWF0cml4LmFwcGx5KHRydWUsIHRydWUpO1xuXHRcdH1cblx0XHRyZXR1cm4gaXRlbTtcblx0fVxuXG5cdEl0ZW0uaW5qZWN0KHtcblx0XHRpbXBvcnRTVkc6IGZ1bmN0aW9uKG5vZGUsIG9wdGlvbnMpIHtcblx0XHRcdHJldHVybiB0aGlzLmFkZENoaWxkKGltcG9ydFNWRyhub2RlLCBvcHRpb25zLCB0cnVlKSk7XG5cdFx0fVxuXHR9KTtcblxuXHRQcm9qZWN0LmluamVjdCh7XG5cdFx0aW1wb3J0U1ZHOiBmdW5jdGlvbihub2RlLCBvcHRpb25zKSB7XG5cdFx0XHR0aGlzLmFjdGl2YXRlKCk7XG5cdFx0XHRyZXR1cm4gaW1wb3J0U1ZHKG5vZGUsIG9wdGlvbnMsIHRydWUpO1xuXHRcdH1cblx0fSk7XG59O1xuXG5CYXNlLmV4cG9ydHMuUGFwZXJTY3JpcHQgPSAoZnVuY3Rpb24oKSB7XG5cdHZhciBleHBvcnRzLCBkZWZpbmUsXG5cdFx0c2NvcGUgPSB0aGlzO1xuIWZ1bmN0aW9uKGUscil7cmV0dXJuXCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/cihleHBvcnRzKTpcImZ1bmN0aW9uXCI9PXR5cGVvZiBkZWZpbmUmJmRlZmluZS5hbWQ/ZGVmaW5lKFtcImV4cG9ydHNcIl0scik6KHIoZS5hY29ybnx8KGUuYWNvcm49e30pKSx2b2lkIDApfSh0aGlzLGZ1bmN0aW9uKGUpe1widXNlIHN0cmljdFwiO2Z1bmN0aW9uIHIoZSl7ZnI9ZXx8e307Zm9yKHZhciByIGluIG1yKU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChmcixyKXx8KGZyW3JdPW1yW3JdKTtocj1mci5zb3VyY2VGaWxlfHxudWxsfWZ1bmN0aW9uIHQoZSxyKXt2YXIgdD12cihkcixlKTtyKz1cIiAoXCIrdC5saW5lK1wiOlwiK3QuY29sdW1uK1wiKVwiO3ZhciBuPW5ldyBTeW50YXhFcnJvcihyKTt0aHJvdyBuLnBvcz1lLG4ubG9jPXQsbi5yYWlzZWRBdD1icixufWZ1bmN0aW9uIG4oZSl7ZnVuY3Rpb24gcihlKXtpZigxPT1lLmxlbmd0aClyZXR1cm4gdCs9XCJyZXR1cm4gc3RyID09PSBcIitKU09OLnN0cmluZ2lmeShlWzBdKStcIjtcIjt0Kz1cInN3aXRjaChzdHIpe1wiO2Zvcih2YXIgcj0wO3I8ZS5sZW5ndGg7KytyKXQrPVwiY2FzZSBcIitKU09OLnN0cmluZ2lmeShlW3JdKStcIjpcIjt0Kz1cInJldHVybiB0cnVlfXJldHVybiBmYWxzZTtcIn1lPWUuc3BsaXQoXCIgXCIpO3ZhciB0PVwiXCIsbj1bXTtlOmZvcih2YXIgYT0wO2E8ZS5sZW5ndGg7KythKXtmb3IodmFyIG89MDtvPG4ubGVuZ3RoOysrbylpZihuW29dWzBdLmxlbmd0aD09ZVthXS5sZW5ndGgpe25bb10ucHVzaChlW2FdKTtjb250aW51ZSBlfW4ucHVzaChbZVthXV0pfWlmKG4ubGVuZ3RoPjMpe24uc29ydChmdW5jdGlvbihlLHIpe3JldHVybiByLmxlbmd0aC1lLmxlbmd0aH0pLHQrPVwic3dpdGNoKHN0ci5sZW5ndGgpe1wiO2Zvcih2YXIgYT0wO2E8bi5sZW5ndGg7KythKXt2YXIgaT1uW2FdO3QrPVwiY2FzZSBcIitpWzBdLmxlbmd0aCtcIjpcIixyKGkpfXQrPVwifVwifWVsc2UgcihlKTtyZXR1cm4gbmV3IEZ1bmN0aW9uKFwic3RyXCIsdCl9ZnVuY3Rpb24gYSgpe3RoaXMubGluZT1Bcix0aGlzLmNvbHVtbj1ici1Tcn1mdW5jdGlvbiBvKCl7QXI9MSxicj1Tcj0wLEVyPSEwLHUoKX1mdW5jdGlvbiBpKGUscil7Z3I9YnIsZnIubG9jYXRpb25zJiYoa3I9bmV3IGEpLHdyPWUsdSgpLENyPXIsRXI9ZS5iZWZvcmVFeHByfWZ1bmN0aW9uIHMoKXt2YXIgZT1mci5vbkNvbW1lbnQmJmZyLmxvY2F0aW9ucyYmbmV3IGEscj1icixuPWRyLmluZGV4T2YoXCIqL1wiLGJyKz0yKTtpZigtMT09PW4mJnQoYnItMixcIlVudGVybWluYXRlZCBjb21tZW50XCIpLGJyPW4rMixmci5sb2NhdGlvbnMpe0t0Lmxhc3RJbmRleD1yO2Zvcih2YXIgbzsobz1LdC5leGVjKGRyKSkmJm8uaW5kZXg8YnI7KSsrQXIsU3I9by5pbmRleCtvWzBdLmxlbmd0aH1mci5vbkNvbW1lbnQmJmZyLm9uQ29tbWVudCghMCxkci5zbGljZShyKzIsbikscixicixlLGZyLmxvY2F0aW9ucyYmbmV3IGEpfWZ1bmN0aW9uIGMoKXtmb3IodmFyIGU9YnIscj1mci5vbkNvbW1lbnQmJmZyLmxvY2F0aW9ucyYmbmV3IGEsdD1kci5jaGFyQ29kZUF0KGJyKz0yKTtwcj5iciYmMTAhPT10JiYxMyE9PXQmJjgyMzIhPT10JiY4MjMzIT09dDspKyticix0PWRyLmNoYXJDb2RlQXQoYnIpO2ZyLm9uQ29tbWVudCYmZnIub25Db21tZW50KCExLGRyLnNsaWNlKGUrMixiciksZSxicixyLGZyLmxvY2F0aW9ucyYmbmV3IGEpfWZ1bmN0aW9uIHUoKXtmb3IoO3ByPmJyOyl7dmFyIGU9ZHIuY2hhckNvZGVBdChicik7aWYoMzI9PT1lKSsrYnI7ZWxzZSBpZigxMz09PWUpeysrYnI7dmFyIHI9ZHIuY2hhckNvZGVBdChicik7MTA9PT1yJiYrK2JyLGZyLmxvY2F0aW9ucyYmKCsrQXIsU3I9YnIpfWVsc2UgaWYoMTA9PT1lfHw4MjMyPT09ZXx8ODIzMz09PWUpKyticixmci5sb2NhdGlvbnMmJigrK0FyLFNyPWJyKTtlbHNlIGlmKGU+OCYmMTQ+ZSkrK2JyO2Vsc2UgaWYoNDc9PT1lKXt2YXIgcj1kci5jaGFyQ29kZUF0KGJyKzEpO2lmKDQyPT09cilzKCk7ZWxzZXtpZig0NyE9PXIpYnJlYWs7YygpfX1lbHNlIGlmKDE2MD09PWUpKyticjtlbHNle2lmKCEoZT49NTc2MCYmSnQudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKSkpYnJlYWs7Kyticn19fWZ1bmN0aW9uIGwoKXt2YXIgZT1kci5jaGFyQ29kZUF0KGJyKzEpO3JldHVybiBlPj00OCYmNTc+PWU/RSghMCk6KCsrYnIsaSh4dCkpfWZ1bmN0aW9uIGYoKXt2YXIgZT1kci5jaGFyQ29kZUF0KGJyKzEpO3JldHVybiBFcj8oKyticixrKCkpOjYxPT09ZT94KEV0LDIpOngod3QsMSl9ZnVuY3Rpb24gZCgpe3ZhciBlPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIDYxPT09ZT94KEV0LDIpOngoRHQsMSl9ZnVuY3Rpb24gcChlKXt2YXIgcj1kci5jaGFyQ29kZUF0KGJyKzEpO3JldHVybiByPT09ZT94KDEyND09PWU/THQ6VXQsMik6NjE9PT1yP3goRXQsMik6eCgxMjQ9PT1lP1J0OlR0LDEpfWZ1bmN0aW9uIGgoKXt2YXIgZT1kci5jaGFyQ29kZUF0KGJyKzEpO3JldHVybiA2MT09PWU/eChFdCwyKTp4KFZ0LDEpfWZ1bmN0aW9uIG0oZSl7dmFyIHI9ZHIuY2hhckNvZGVBdChicisxKTtyZXR1cm4gcj09PWU/NDU9PXImJjYyPT1kci5jaGFyQ29kZUF0KGJyKzIpJiZHdC50ZXN0KGRyLnNsaWNlKExyLGJyKSk/KGJyKz0zLGMoKSx1KCksZygpKTp4KFN0LDIpOjYxPT09cj94KEV0LDIpOngoQXQsMSl9ZnVuY3Rpb24gdihlKXt2YXIgcj1kci5jaGFyQ29kZUF0KGJyKzEpLHQ9MTtyZXR1cm4gcj09PWU/KHQ9NjI9PT1lJiY2Mj09PWRyLmNoYXJDb2RlQXQoYnIrMik/MzoyLDYxPT09ZHIuY2hhckNvZGVBdChicit0KT94KEV0LHQrMSk6eChqdCx0KSk6MzM9PXImJjYwPT1lJiY0NT09ZHIuY2hhckNvZGVBdChicisyKSYmNDU9PWRyLmNoYXJDb2RlQXQoYnIrMyk/KGJyKz00LGMoKSx1KCksZygpKTooNjE9PT1yJiYodD02MT09PWRyLmNoYXJDb2RlQXQoYnIrMik/MzoyKSx4KE90LHQpKX1mdW5jdGlvbiBiKGUpe3ZhciByPWRyLmNoYXJDb2RlQXQoYnIrMSk7cmV0dXJuIDYxPT09cj94KHF0LDYxPT09ZHIuY2hhckNvZGVBdChicisyKT8zOjIpOngoNjE9PT1lP0N0Okl0LDEpfWZ1bmN0aW9uIHkoZSl7c3dpdGNoKGUpe2Nhc2UgNDY6cmV0dXJuIGwoKTtjYXNlIDQwOnJldHVybisrYnIsaShtdCk7Y2FzZSA0MTpyZXR1cm4rK2JyLGkodnQpO2Nhc2UgNTk6cmV0dXJuKyticixpKHl0KTtjYXNlIDQ0OnJldHVybisrYnIsaShidCk7Y2FzZSA5MTpyZXR1cm4rK2JyLGkoZnQpO2Nhc2UgOTM6cmV0dXJuKyticixpKGR0KTtjYXNlIDEyMzpyZXR1cm4rK2JyLGkocHQpO2Nhc2UgMTI1OnJldHVybisrYnIsaShodCk7Y2FzZSA1ODpyZXR1cm4rK2JyLGkoZ3QpO2Nhc2UgNjM6cmV0dXJuKyticixpKGt0KTtjYXNlIDQ4OnZhciByPWRyLmNoYXJDb2RlQXQoYnIrMSk7aWYoMTIwPT09cnx8ODg9PT1yKXJldHVybiBDKCk7Y2FzZSA0OTpjYXNlIDUwOmNhc2UgNTE6Y2FzZSA1MjpjYXNlIDUzOmNhc2UgNTQ6Y2FzZSA1NTpjYXNlIDU2OmNhc2UgNTc6cmV0dXJuIEUoITEpO2Nhc2UgMzQ6Y2FzZSAzOTpyZXR1cm4gQShlKTtjYXNlIDQ3OnJldHVybiBmKGUpO2Nhc2UgMzc6Y2FzZSA0MjpyZXR1cm4gZCgpO2Nhc2UgMTI0OmNhc2UgMzg6cmV0dXJuIHAoZSk7Y2FzZSA5NDpyZXR1cm4gaCgpO2Nhc2UgNDM6Y2FzZSA0NTpyZXR1cm4gbShlKTtjYXNlIDYwOmNhc2UgNjI6cmV0dXJuIHYoZSk7Y2FzZSA2MTpjYXNlIDMzOnJldHVybiBiKGUpO2Nhc2UgMTI2OnJldHVybiB4KEl0LDEpfXJldHVybiExfWZ1bmN0aW9uIGcoZSl7aWYoZT9icj15cisxOnlyPWJyLGZyLmxvY2F0aW9ucyYmKHhyPW5ldyBhKSxlKXJldHVybiBrKCk7aWYoYnI+PXByKXJldHVybiBpKEJyKTt2YXIgcj1kci5jaGFyQ29kZUF0KGJyKTtpZihRdChyKXx8OTI9PT1yKXJldHVybiBMKCk7dmFyIG49eShyKTtpZihuPT09ITEpe3ZhciBvPVN0cmluZy5mcm9tQ2hhckNvZGUocik7aWYoXCJcXFxcXCI9PT1vfHwkdC50ZXN0KG8pKXJldHVybiBMKCk7dChicixcIlVuZXhwZWN0ZWQgY2hhcmFjdGVyICdcIitvK1wiJ1wiKX1yZXR1cm4gbn1mdW5jdGlvbiB4KGUscil7dmFyIHQ9ZHIuc2xpY2UoYnIsYnIrcik7YnIrPXIsaShlLHQpfWZ1bmN0aW9uIGsoKXtmb3IodmFyIGUscixuPVwiXCIsYT1icjs7KXticj49cHImJnQoYSxcIlVudGVybWluYXRlZCByZWd1bGFyIGV4cHJlc3Npb25cIik7dmFyIG89ZHIuY2hhckF0KGJyKTtpZihHdC50ZXN0KG8pJiZ0KGEsXCJVbnRlcm1pbmF0ZWQgcmVndWxhciBleHByZXNzaW9uXCIpLGUpZT0hMTtlbHNle2lmKFwiW1wiPT09bylyPSEwO2Vsc2UgaWYoXCJdXCI9PT1vJiZyKXI9ITE7ZWxzZSBpZihcIi9cIj09PW8mJiFyKWJyZWFrO2U9XCJcXFxcXCI9PT1vfSsrYnJ9dmFyIG49ZHIuc2xpY2UoYSxicik7Kyticjt2YXIgcz1JKCk7cmV0dXJuIHMmJiEvXltnbXNpeV0qJC8udGVzdChzKSYmdChhLFwiSW52YWxpZCByZWdleHAgZmxhZ1wiKSxpKGpyLG5ldyBSZWdFeHAobixzKSl9ZnVuY3Rpb24gdyhlLHIpe2Zvcih2YXIgdD1icixuPTAsYT0wLG89bnVsbD09cj8xLzA6cjtvPmE7KythKXt2YXIgaSxzPWRyLmNoYXJDb2RlQXQoYnIpO2lmKGk9cz49OTc/cy05NysxMDpzPj02NT9zLTY1KzEwOnM+PTQ4JiY1Nz49cz9zLTQ4OjEvMCxpPj1lKWJyZWFrOysrYnIsbj1uKmUraX1yZXR1cm4gYnI9PT10fHxudWxsIT1yJiZici10IT09cj9udWxsOm59ZnVuY3Rpb24gQygpe2JyKz0yO3ZhciBlPXcoMTYpO3JldHVybiBudWxsPT1lJiZ0KHlyKzIsXCJFeHBlY3RlZCBoZXhhZGVjaW1hbCBudW1iZXJcIiksUXQoZHIuY2hhckNvZGVBdChicikpJiZ0KGJyLFwiSWRlbnRpZmllciBkaXJlY3RseSBhZnRlciBudW1iZXJcIiksaShPcixlKX1mdW5jdGlvbiBFKGUpe3ZhciByPWJyLG49ITEsYT00OD09PWRyLmNoYXJDb2RlQXQoYnIpO2V8fG51bGwhPT13KDEwKXx8dChyLFwiSW52YWxpZCBudW1iZXJcIiksNDY9PT1kci5jaGFyQ29kZUF0KGJyKSYmKCsrYnIsdygxMCksbj0hMCk7dmFyIG89ZHIuY2hhckNvZGVBdChicik7KDY5PT09b3x8MTAxPT09bykmJihvPWRyLmNoYXJDb2RlQXQoKyticiksKDQzPT09b3x8NDU9PT1vKSYmKyticixudWxsPT09dygxMCkmJnQocixcIkludmFsaWQgbnVtYmVyXCIpLG49ITApLFF0KGRyLmNoYXJDb2RlQXQoYnIpKSYmdChicixcIklkZW50aWZpZXIgZGlyZWN0bHkgYWZ0ZXIgbnVtYmVyXCIpO3ZhciBzLGM9ZHIuc2xpY2Uocixicik7cmV0dXJuIG4/cz1wYXJzZUZsb2F0KGMpOmEmJjEhPT1jLmxlbmd0aD8vWzg5XS8udGVzdChjKXx8VHI/dChyLFwiSW52YWxpZCBudW1iZXJcIik6cz1wYXJzZUludChjLDgpOnM9cGFyc2VJbnQoYywxMCksaShPcixzKX1mdW5jdGlvbiBBKGUpe2JyKys7Zm9yKHZhciByPVwiXCI7Oyl7YnI+PXByJiZ0KHlyLFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKTt2YXIgbj1kci5jaGFyQ29kZUF0KGJyKTtpZihuPT09ZSlyZXR1cm4rK2JyLGkoRHIscik7aWYoOTI9PT1uKXtuPWRyLmNoYXJDb2RlQXQoKyticik7dmFyIGE9L15bMC03XSsvLmV4ZWMoZHIuc2xpY2UoYnIsYnIrMykpO2ZvcihhJiYoYT1hWzBdKTthJiZwYXJzZUludChhLDgpPjI1NTspYT1hLnNsaWNlKDAsYS5sZW5ndGgtMSk7aWYoXCIwXCI9PT1hJiYoYT1udWxsKSwrK2JyLGEpVHImJnQoYnItMixcIk9jdGFsIGxpdGVyYWwgaW4gc3RyaWN0IG1vZGVcIikscis9U3RyaW5nLmZyb21DaGFyQ29kZShwYXJzZUludChhLDgpKSxicis9YS5sZW5ndGgtMTtlbHNlIHN3aXRjaChuKXtjYXNlIDExMDpyKz1cIlxcblwiO2JyZWFrO2Nhc2UgMTE0OnIrPVwiXFxyXCI7YnJlYWs7Y2FzZSAxMjA6cis9U3RyaW5nLmZyb21DaGFyQ29kZShTKDIpKTticmVhaztjYXNlIDExNzpyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKFMoNCkpO2JyZWFrO2Nhc2UgODU6cis9U3RyaW5nLmZyb21DaGFyQ29kZShTKDgpKTticmVhaztjYXNlIDExNjpyKz1cIlx0XCI7YnJlYWs7Y2FzZSA5ODpyKz1cIlxcYlwiO2JyZWFrO2Nhc2UgMTE4OnIrPVwiXHUwMDBiXCI7YnJlYWs7Y2FzZSAxMDI6cis9XCJcXGZcIjticmVhaztjYXNlIDQ4OnIrPVwiXFwwXCI7YnJlYWs7Y2FzZSAxMzoxMD09PWRyLmNoYXJDb2RlQXQoYnIpJiYrK2JyO2Nhc2UgMTA6ZnIubG9jYXRpb25zJiYoU3I9YnIsKytBcik7YnJlYWs7ZGVmYXVsdDpyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG4pfX1lbHNlKDEzPT09bnx8MTA9PT1ufHw4MjMyPT09bnx8ODIzMz09PW4pJiZ0KHlyLFwiVW50ZXJtaW5hdGVkIHN0cmluZyBjb25zdGFudFwiKSxyKz1TdHJpbmcuZnJvbUNoYXJDb2RlKG4pLCsrYnJ9fWZ1bmN0aW9uIFMoZSl7dmFyIHI9dygxNixlKTtyZXR1cm4gbnVsbD09PXImJnQoeXIsXCJCYWQgY2hhcmFjdGVyIGVzY2FwZSBzZXF1ZW5jZVwiKSxyfWZ1bmN0aW9uIEkoKXtCdD0hMTtmb3IodmFyIGUscj0hMCxuPWJyOzspe3ZhciBhPWRyLmNoYXJDb2RlQXQoYnIpO2lmKFl0KGEpKUJ0JiYoZSs9ZHIuY2hhckF0KGJyKSksKyticjtlbHNle2lmKDkyIT09YSlicmVhaztCdHx8KGU9ZHIuc2xpY2UobixicikpLEJ0PSEwLDExNyE9ZHIuY2hhckNvZGVBdCgrK2JyKSYmdChicixcIkV4cGVjdGluZyBVbmljb2RlIGVzY2FwZSBzZXF1ZW5jZSBcXFxcdVhYWFhcIiksKyticjt2YXIgbz1TKDQpLGk9U3RyaW5nLmZyb21DaGFyQ29kZShvKTtpfHx0KGJyLTEsXCJJbnZhbGlkIFVuaWNvZGUgZXNjYXBlXCIpLChyP1F0KG8pOll0KG8pKXx8dChici00LFwiSW52YWxpZCBVbmljb2RlIGVzY2FwZVwiKSxlKz1pfXI9ITF9cmV0dXJuIEJ0P2U6ZHIuc2xpY2Uobixicil9ZnVuY3Rpb24gTCgpe3ZhciBlPUkoKSxyPUZyO3JldHVybiBCdHx8KFd0KGUpP3I9bHRbZV06KGZyLmZvcmJpZFJlc2VydmVkJiYoMz09PWZyLmVjbWFWZXJzaW9uP010Onp0KShlKXx8VHImJlh0KGUpKSYmdCh5cixcIlRoZSBrZXl3b3JkICdcIitlK1wiJyBpcyByZXNlcnZlZFwiKSksaShyLGUpfWZ1bmN0aW9uIFUoKXtJcj15cixMcj1ncixVcj1rcixnKCl9ZnVuY3Rpb24gUihlKXtpZihUcj1lLGJyPUxyLGZyLmxvY2F0aW9ucylmb3IoO1NyPmJyOylTcj1kci5sYXN0SW5kZXhPZihcIlxcblwiLFNyLTIpKzEsLS1Bcjt1KCksZygpfWZ1bmN0aW9uIFYoKXt0aGlzLnR5cGU9bnVsbCx0aGlzLnN0YXJ0PXlyLHRoaXMuZW5kPW51bGx9ZnVuY3Rpb24gVCgpe3RoaXMuc3RhcnQ9eHIsdGhpcy5lbmQ9bnVsbCxudWxsIT09aHImJih0aGlzLnNvdXJjZT1ocil9ZnVuY3Rpb24gcSgpe3ZhciBlPW5ldyBWO3JldHVybiBmci5sb2NhdGlvbnMmJihlLmxvYz1uZXcgVCksZnIucmFuZ2VzJiYoZS5yYW5nZT1beXIsMF0pLGV9ZnVuY3Rpb24gTyhlKXt2YXIgcj1uZXcgVjtyZXR1cm4gci5zdGFydD1lLnN0YXJ0LGZyLmxvY2F0aW9ucyYmKHIubG9jPW5ldyBULHIubG9jLnN0YXJ0PWUubG9jLnN0YXJ0KSxmci5yYW5nZXMmJihyLnJhbmdlPVtlLnJhbmdlWzBdLDBdKSxyfWZ1bmN0aW9uIGooZSxyKXtyZXR1cm4gZS50eXBlPXIsZS5lbmQ9THIsZnIubG9jYXRpb25zJiYoZS5sb2MuZW5kPVVyKSxmci5yYW5nZXMmJihlLnJhbmdlWzFdPUxyKSxlfWZ1bmN0aW9uIEQoZSl7cmV0dXJuIGZyLmVjbWFWZXJzaW9uPj01JiZcIkV4cHJlc3Npb25TdGF0ZW1lbnRcIj09PWUudHlwZSYmXCJMaXRlcmFsXCI9PT1lLmV4cHJlc3Npb24udHlwZSYmXCJ1c2Ugc3RyaWN0XCI9PT1lLmV4cHJlc3Npb24udmFsdWV9ZnVuY3Rpb24gRihlKXtyZXR1cm4gd3I9PT1lPyhVKCksITApOnZvaWQgMH1mdW5jdGlvbiBCKCl7cmV0dXJuIWZyLnN0cmljdFNlbWljb2xvbnMmJih3cj09PUJyfHx3cj09PWh0fHxHdC50ZXN0KGRyLnNsaWNlKExyLHlyKSkpfWZ1bmN0aW9uIE0oKXtGKHl0KXx8QigpfHxYKCl9ZnVuY3Rpb24geihlKXt3cj09PWU/VSgpOlgoKX1mdW5jdGlvbiBYKCl7dCh5cixcIlVuZXhwZWN0ZWQgdG9rZW5cIil9ZnVuY3Rpb24gTihlKXtcIklkZW50aWZpZXJcIiE9PWUudHlwZSYmXCJNZW1iZXJFeHByZXNzaW9uXCIhPT1lLnR5cGUmJnQoZS5zdGFydCxcIkFzc2lnbmluZyB0byBydmFsdWVcIiksVHImJlwiSWRlbnRpZmllclwiPT09ZS50eXBlJiZOdChlLm5hbWUpJiZ0KGUuc3RhcnQsXCJBc3NpZ25pbmcgdG8gXCIrZS5uYW1lK1wiIGluIHN0cmljdCBtb2RlXCIpfWZ1bmN0aW9uIFcoZSl7SXI9THI9YnIsZnIubG9jYXRpb25zJiYoVXI9bmV3IGEpLFJyPVRyPW51bGwsVnI9W10sZygpO3ZhciByPWV8fHEoKSx0PSEwO2ZvcihlfHwoci5ib2R5PVtdKTt3ciE9PUJyOyl7dmFyIG49SigpO3IuYm9keS5wdXNoKG4pLHQmJkQobikmJlIoITApLHQ9ITF9cmV0dXJuIGoocixcIlByb2dyYW1cIil9ZnVuY3Rpb24gSigpeyh3cj09PXd0fHx3cj09PUV0JiZcIi89XCI9PUNyKSYmZyghMCk7dmFyIGU9d3Iscj1xKCk7c3dpdGNoKGUpe2Nhc2UgTXI6Y2FzZSBOcjpVKCk7dmFyIG49ZT09PU1yO0YoeXQpfHxCKCk/ci5sYWJlbD1udWxsOndyIT09RnI/WCgpOihyLmxhYmVsPWxyKCksTSgpKTtmb3IodmFyIGE9MDthPFZyLmxlbmd0aDsrK2Epe3ZhciBvPVZyW2FdO2lmKG51bGw9PXIubGFiZWx8fG8ubmFtZT09PXIubGFiZWwubmFtZSl7aWYobnVsbCE9by5raW5kJiYobnx8XCJsb29wXCI9PT1vLmtpbmQpKWJyZWFrO2lmKHIubGFiZWwmJm4pYnJlYWt9fXJldHVybiBhPT09VnIubGVuZ3RoJiZ0KHIuc3RhcnQsXCJVbnN5bnRhY3RpYyBcIitlLmtleXdvcmQpLGoocixuP1wiQnJlYWtTdGF0ZW1lbnRcIjpcIkNvbnRpbnVlU3RhdGVtZW50XCIpO2Nhc2UgV3I6cmV0dXJuIFUoKSxNKCksaihyLFwiRGVidWdnZXJTdGF0ZW1lbnRcIik7Y2FzZSBQcjpyZXR1cm4gVSgpLFZyLnB1c2goWnQpLHIuYm9keT1KKCksVnIucG9wKCkseih0dCksci50ZXN0PVAoKSxNKCksaihyLFwiRG9XaGlsZVN0YXRlbWVudFwiKTtjYXNlIF9yOmlmKFUoKSxWci5wdXNoKFp0KSx6KG10KSx3cj09PXl0KXJldHVybiAkKHIsbnVsbCk7aWYod3I9PT1ydCl7dmFyIGk9cSgpO3JldHVybiBVKCksRyhpLCEwKSxqKGksXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpLDE9PT1pLmRlY2xhcmF0aW9ucy5sZW5ndGgmJkYodXQpP18ocixpKTokKHIsaSl9dmFyIGk9SyghMSwhMCk7cmV0dXJuIEYodXQpPyhOKGkpLF8ocixpKSk6JChyLGkpO2Nhc2UgR3I6cmV0dXJuIFUoKSxjcihyLCEwKTtjYXNlIEtyOnJldHVybiBVKCksci50ZXN0PVAoKSxyLmNvbnNlcXVlbnQ9SigpLHIuYWx0ZXJuYXRlPUYoSHIpP0ooKTpudWxsLGoocixcIklmU3RhdGVtZW50XCIpO2Nhc2UgUXI6cmV0dXJuIFJyfHx0KHlyLFwiJ3JldHVybicgb3V0c2lkZSBvZiBmdW5jdGlvblwiKSxVKCksRih5dCl8fEIoKT9yLmFyZ3VtZW50PW51bGw6KHIuYXJndW1lbnQ9SygpLE0oKSksaihyLFwiUmV0dXJuU3RhdGVtZW50XCIpO2Nhc2UgWXI6VSgpLHIuZGlzY3JpbWluYW50PVAoKSxyLmNhc2VzPVtdLHoocHQpLFZyLnB1c2goZW4pO2Zvcih2YXIgcyxjO3dyIT1odDspaWYod3I9PT16cnx8d3I9PT1Kcil7dmFyIHU9d3I9PT16cjtzJiZqKHMsXCJTd2l0Y2hDYXNlXCIpLHIuY2FzZXMucHVzaChzPXEoKSkscy5jb25zZXF1ZW50PVtdLFUoKSx1P3MudGVzdD1LKCk6KGMmJnQoSXIsXCJNdWx0aXBsZSBkZWZhdWx0IGNsYXVzZXNcIiksYz0hMCxzLnRlc3Q9bnVsbCkseihndCl9ZWxzZSBzfHxYKCkscy5jb25zZXF1ZW50LnB1c2goSigpKTtyZXR1cm4gcyYmaihzLFwiU3dpdGNoQ2FzZVwiKSxVKCksVnIucG9wKCksaihyLFwiU3dpdGNoU3RhdGVtZW50XCIpO2Nhc2UgWnI6cmV0dXJuIFUoKSxHdC50ZXN0KGRyLnNsaWNlKExyLHlyKSkmJnQoTHIsXCJJbGxlZ2FsIG5ld2xpbmUgYWZ0ZXIgdGhyb3dcIiksci5hcmd1bWVudD1LKCksTSgpLGoocixcIlRocm93U3RhdGVtZW50XCIpO2Nhc2UgZXQ6aWYoVSgpLHIuYmxvY2s9SCgpLHIuaGFuZGxlcj1udWxsLHdyPT09WHIpe3ZhciBsPXEoKTtVKCkseihtdCksbC5wYXJhbT1scigpLFRyJiZOdChsLnBhcmFtLm5hbWUpJiZ0KGwucGFyYW0uc3RhcnQsXCJCaW5kaW5nIFwiK2wucGFyYW0ubmFtZStcIiBpbiBzdHJpY3QgbW9kZVwiKSx6KHZ0KSxsLmd1YXJkPW51bGwsbC5ib2R5PUgoKSxyLmhhbmRsZXI9aihsLFwiQ2F0Y2hDbGF1c2VcIil9cmV0dXJuIHIuZ3VhcmRlZEhhbmRsZXJzPXFyLHIuZmluYWxpemVyPUYoJHIpP0goKTpudWxsLHIuaGFuZGxlcnx8ci5maW5hbGl6ZXJ8fHQoci5zdGFydCxcIk1pc3NpbmcgY2F0Y2ggb3IgZmluYWxseSBjbGF1c2VcIiksaihyLFwiVHJ5U3RhdGVtZW50XCIpO2Nhc2UgcnQ6cmV0dXJuIFUoKSxHKHIpLE0oKSxqKHIsXCJWYXJpYWJsZURlY2xhcmF0aW9uXCIpO2Nhc2UgdHQ6cmV0dXJuIFUoKSxyLnRlc3Q9UCgpLFZyLnB1c2goWnQpLHIuYm9keT1KKCksVnIucG9wKCksaihyLFwiV2hpbGVTdGF0ZW1lbnRcIik7Y2FzZSBudDpyZXR1cm4gVHImJnQoeXIsXCInd2l0aCcgaW4gc3RyaWN0IG1vZGVcIiksVSgpLHIub2JqZWN0PVAoKSxyLmJvZHk9SigpLGoocixcIldpdGhTdGF0ZW1lbnRcIik7Y2FzZSBwdDpyZXR1cm4gSCgpO2Nhc2UgeXQ6cmV0dXJuIFUoKSxqKHIsXCJFbXB0eVN0YXRlbWVudFwiKTtkZWZhdWx0OnZhciBmPUNyLGQ9SygpO2lmKGU9PT1GciYmXCJJZGVudGlmaWVyXCI9PT1kLnR5cGUmJkYoZ3QpKXtmb3IodmFyIGE9MDthPFZyLmxlbmd0aDsrK2EpVnJbYV0ubmFtZT09PWYmJnQoZC5zdGFydCxcIkxhYmVsICdcIitmK1wiJyBpcyBhbHJlYWR5IGRlY2xhcmVkXCIpO3ZhciBwPXdyLmlzTG9vcD9cImxvb3BcIjp3cj09PVlyP1wic3dpdGNoXCI6bnVsbDtyZXR1cm4gVnIucHVzaCh7bmFtZTpmLGtpbmQ6cH0pLHIuYm9keT1KKCksVnIucG9wKCksci5sYWJlbD1kLGoocixcIkxhYmVsZWRTdGF0ZW1lbnRcIil9cmV0dXJuIHIuZXhwcmVzc2lvbj1kLE0oKSxqKHIsXCJFeHByZXNzaW9uU3RhdGVtZW50XCIpfX1mdW5jdGlvbiBQKCl7eihtdCk7dmFyIGU9SygpO3JldHVybiB6KHZ0KSxlfWZ1bmN0aW9uIEgoZSl7dmFyIHIsdD1xKCksbj0hMCxhPSExO2Zvcih0LmJvZHk9W10seihwdCk7IUYoaHQpOyl7dmFyIG89SigpO3QuYm9keS5wdXNoKG8pLG4mJmUmJkQobykmJihyPWEsUihhPSEwKSksbj0hMX1yZXR1cm4gYSYmIXImJlIoITEpLGoodCxcIkJsb2NrU3RhdGVtZW50XCIpfWZ1bmN0aW9uICQoZSxyKXtyZXR1cm4gZS5pbml0PXIseih5dCksZS50ZXN0PXdyPT09eXQ/bnVsbDpLKCkseih5dCksZS51cGRhdGU9d3I9PT12dD9udWxsOksoKSx6KHZ0KSxlLmJvZHk9SigpLFZyLnBvcCgpLGooZSxcIkZvclN0YXRlbWVudFwiKX1mdW5jdGlvbiBfKGUscil7cmV0dXJuIGUubGVmdD1yLGUucmlnaHQ9SygpLHoodnQpLGUuYm9keT1KKCksVnIucG9wKCksaihlLFwiRm9ySW5TdGF0ZW1lbnRcIil9ZnVuY3Rpb24gRyhlLHIpe2ZvcihlLmRlY2xhcmF0aW9ucz1bXSxlLmtpbmQ9XCJ2YXJcIjs7KXt2YXIgbj1xKCk7aWYobi5pZD1scigpLFRyJiZOdChuLmlkLm5hbWUpJiZ0KG4uaWQuc3RhcnQsXCJCaW5kaW5nIFwiK24uaWQubmFtZStcIiBpbiBzdHJpY3QgbW9kZVwiKSxuLmluaXQ9RihDdCk/SyghMCxyKTpudWxsLGUuZGVjbGFyYXRpb25zLnB1c2goaihuLFwiVmFyaWFibGVEZWNsYXJhdG9yXCIpKSwhRihidCkpYnJlYWt9cmV0dXJuIGV9ZnVuY3Rpb24gSyhlLHIpe3ZhciB0PVEocik7aWYoIWUmJndyPT09YnQpe3ZhciBuPU8odCk7Zm9yKG4uZXhwcmVzc2lvbnM9W3RdO0YoYnQpOyluLmV4cHJlc3Npb25zLnB1c2goUShyKSk7cmV0dXJuIGoobixcIlNlcXVlbmNlRXhwcmVzc2lvblwiKX1yZXR1cm4gdH1mdW5jdGlvbiBRKGUpe3ZhciByPVkoZSk7aWYod3IuaXNBc3NpZ24pe3ZhciB0PU8ocik7cmV0dXJuIHQub3BlcmF0b3I9Q3IsdC5sZWZ0PXIsVSgpLHQucmlnaHQ9UShlKSxOKHIpLGoodCxcIkFzc2lnbm1lbnRFeHByZXNzaW9uXCIpfXJldHVybiByfWZ1bmN0aW9uIFkoZSl7dmFyIHI9WihlKTtpZihGKGt0KSl7dmFyIHQ9TyhyKTtyZXR1cm4gdC50ZXN0PXIsdC5jb25zZXF1ZW50PUsoITApLHooZ3QpLHQuYWx0ZXJuYXRlPUsoITAsZSksaih0LFwiQ29uZGl0aW9uYWxFeHByZXNzaW9uXCIpfXJldHVybiByfWZ1bmN0aW9uIFooZSl7cmV0dXJuIGVyKHJyKCksLTEsZSl9ZnVuY3Rpb24gZXIoZSxyLHQpe3ZhciBuPXdyLmJpbm9wO2lmKG51bGwhPW4mJighdHx8d3IhPT11dCkmJm4+cil7dmFyIGE9TyhlKTthLmxlZnQ9ZSxhLm9wZXJhdG9yPUNyLFUoKSxhLnJpZ2h0PWVyKHJyKCksbix0KTt2YXIgbz1qKGEsLyYmfFxcfFxcfC8udGVzdChhLm9wZXJhdG9yKT9cIkxvZ2ljYWxFeHByZXNzaW9uXCI6XCJCaW5hcnlFeHByZXNzaW9uXCIpO3JldHVybiBlcihvLHIsdCl9cmV0dXJuIGV9ZnVuY3Rpb24gcnIoKXtpZih3ci5wcmVmaXgpe3ZhciBlPXEoKSxyPXdyLmlzVXBkYXRlO3JldHVybiBlLm9wZXJhdG9yPUNyLGUucHJlZml4PSEwLEVyPSEwLFUoKSxlLmFyZ3VtZW50PXJyKCkscj9OKGUuYXJndW1lbnQpOlRyJiZcImRlbGV0ZVwiPT09ZS5vcGVyYXRvciYmXCJJZGVudGlmaWVyXCI9PT1lLmFyZ3VtZW50LnR5cGUmJnQoZS5zdGFydCxcIkRlbGV0aW5nIGxvY2FsIHZhcmlhYmxlIGluIHN0cmljdCBtb2RlXCIpLGooZSxyP1wiVXBkYXRlRXhwcmVzc2lvblwiOlwiVW5hcnlFeHByZXNzaW9uXCIpfWZvcih2YXIgbj10cigpO3dyLnBvc3RmaXgmJiFCKCk7KXt2YXIgZT1PKG4pO2Uub3BlcmF0b3I9Q3IsZS5wcmVmaXg9ITEsZS5hcmd1bWVudD1uLE4obiksVSgpLG49aihlLFwiVXBkYXRlRXhwcmVzc2lvblwiKX1yZXR1cm4gbn1mdW5jdGlvbiB0cigpe3JldHVybiBucihhcigpKX1mdW5jdGlvbiBucihlLHIpe2lmKEYoeHQpKXt2YXIgdD1PKGUpO3JldHVybiB0Lm9iamVjdD1lLHQucHJvcGVydHk9bHIoITApLHQuY29tcHV0ZWQ9ITEsbnIoaih0LFwiTWVtYmVyRXhwcmVzc2lvblwiKSxyKX1pZihGKGZ0KSl7dmFyIHQ9TyhlKTtyZXR1cm4gdC5vYmplY3Q9ZSx0LnByb3BlcnR5PUsoKSx0LmNvbXB1dGVkPSEwLHooZHQpLG5yKGoodCxcIk1lbWJlckV4cHJlc3Npb25cIikscil9aWYoIXImJkYobXQpKXt2YXIgdD1PKGUpO3JldHVybiB0LmNhbGxlZT1lLHQuYXJndW1lbnRzPXVyKHZ0LCExKSxucihqKHQsXCJDYWxsRXhwcmVzc2lvblwiKSxyKX1yZXR1cm4gZX1mdW5jdGlvbiBhcigpe3N3aXRjaCh3cil7Y2FzZSBvdDp2YXIgZT1xKCk7cmV0dXJuIFUoKSxqKGUsXCJUaGlzRXhwcmVzc2lvblwiKTtjYXNlIEZyOnJldHVybiBscigpO2Nhc2UgT3I6Y2FzZSBEcjpjYXNlIGpyOnZhciBlPXEoKTtyZXR1cm4gZS52YWx1ZT1DcixlLnJhdz1kci5zbGljZSh5cixnciksVSgpLGooZSxcIkxpdGVyYWxcIik7Y2FzZSBpdDpjYXNlIHN0OmNhc2UgY3Q6dmFyIGU9cSgpO3JldHVybiBlLnZhbHVlPXdyLmF0b21WYWx1ZSxlLnJhdz13ci5rZXl3b3JkLFUoKSxqKGUsXCJMaXRlcmFsXCIpO2Nhc2UgbXQ6dmFyIHI9eHIsdD15cjtVKCk7dmFyIG49SygpO3JldHVybiBuLnN0YXJ0PXQsbi5lbmQ9Z3IsZnIubG9jYXRpb25zJiYobi5sb2Muc3RhcnQ9cixuLmxvYy5lbmQ9a3IpLGZyLnJhbmdlcyYmKG4ucmFuZ2U9W3QsZ3JdKSx6KHZ0KSxuO2Nhc2UgZnQ6dmFyIGU9cSgpO3JldHVybiBVKCksZS5lbGVtZW50cz11cihkdCwhMCwhMCksaihlLFwiQXJyYXlFeHByZXNzaW9uXCIpO2Nhc2UgcHQ6cmV0dXJuIGlyKCk7Y2FzZSBHcjp2YXIgZT1xKCk7cmV0dXJuIFUoKSxjcihlLCExKTtjYXNlIGF0OnJldHVybiBvcigpO2RlZmF1bHQ6WCgpfX1mdW5jdGlvbiBvcigpe3ZhciBlPXEoKTtyZXR1cm4gVSgpLGUuY2FsbGVlPW5yKGFyKCksITApLGUuYXJndW1lbnRzPUYobXQpP3VyKHZ0LCExKTpxcixqKGUsXCJOZXdFeHByZXNzaW9uXCIpfWZ1bmN0aW9uIGlyKCl7dmFyIGU9cSgpLHI9ITAsbj0hMTtmb3IoZS5wcm9wZXJ0aWVzPVtdLFUoKTshRihodCk7KXtpZihyKXI9ITE7ZWxzZSBpZih6KGJ0KSxmci5hbGxvd1RyYWlsaW5nQ29tbWFzJiZGKGh0KSlicmVhazt2YXIgYSxvPXtrZXk6c3IoKX0saT0hMTtpZihGKGd0KT8oby52YWx1ZT1LKCEwKSxhPW8ua2luZD1cImluaXRcIik6ZnIuZWNtYVZlcnNpb24+PTUmJlwiSWRlbnRpZmllclwiPT09by5rZXkudHlwZSYmKFwiZ2V0XCI9PT1vLmtleS5uYW1lfHxcInNldFwiPT09by5rZXkubmFtZSk/KGk9bj0hMCxhPW8ua2luZD1vLmtleS5uYW1lLG8ua2V5PXNyKCksd3IhPT1tdCYmWCgpLG8udmFsdWU9Y3IocSgpLCExKSk6WCgpLFwiSWRlbnRpZmllclwiPT09by5rZXkudHlwZSYmKFRyfHxuKSlmb3IodmFyIHM9MDtzPGUucHJvcGVydGllcy5sZW5ndGg7KytzKXt2YXIgYz1lLnByb3BlcnRpZXNbc107aWYoYy5rZXkubmFtZT09PW8ua2V5Lm5hbWUpe3ZhciB1PWE9PWMua2luZHx8aSYmXCJpbml0XCI9PT1jLmtpbmR8fFwiaW5pdFwiPT09YSYmKFwiZ2V0XCI9PT1jLmtpbmR8fFwic2V0XCI9PT1jLmtpbmQpO3UmJiFUciYmXCJpbml0XCI9PT1hJiZcImluaXRcIj09PWMua2luZCYmKHU9ITEpLHUmJnQoby5rZXkuc3RhcnQsXCJSZWRlZmluaXRpb24gb2YgcHJvcGVydHlcIil9fWUucHJvcGVydGllcy5wdXNoKG8pfXJldHVybiBqKGUsXCJPYmplY3RFeHByZXNzaW9uXCIpfWZ1bmN0aW9uIHNyKCl7cmV0dXJuIHdyPT09T3J8fHdyPT09RHI/YXIoKTpscighMCl9ZnVuY3Rpb24gY3IoZSxyKXt3cj09PUZyP2UuaWQ9bHIoKTpyP1goKTplLmlkPW51bGwsZS5wYXJhbXM9W107dmFyIG49ITA7Zm9yKHoobXQpOyFGKHZ0KTspbj9uPSExOnooYnQpLGUucGFyYW1zLnB1c2gobHIoKSk7dmFyIGE9UnIsbz1WcjtpZihScj0hMCxWcj1bXSxlLmJvZHk9SCghMCksUnI9YSxWcj1vLFRyfHxlLmJvZHkuYm9keS5sZW5ndGgmJkQoZS5ib2R5LmJvZHlbMF0pKWZvcih2YXIgaT1lLmlkPy0xOjA7aTxlLnBhcmFtcy5sZW5ndGg7KytpKXt2YXIgcz0wPmk/ZS5pZDplLnBhcmFtc1tpXTtpZigoWHQocy5uYW1lKXx8TnQocy5uYW1lKSkmJnQocy5zdGFydCxcIkRlZmluaW5nICdcIitzLm5hbWUrXCInIGluIHN0cmljdCBtb2RlXCIpLGk+PTApZm9yKHZhciBjPTA7aT5jOysrYylzLm5hbWU9PT1lLnBhcmFtc1tjXS5uYW1lJiZ0KHMuc3RhcnQsXCJBcmd1bWVudCBuYW1lIGNsYXNoIGluIHN0cmljdCBtb2RlXCIpfXJldHVybiBqKGUscj9cIkZ1bmN0aW9uRGVjbGFyYXRpb25cIjpcIkZ1bmN0aW9uRXhwcmVzc2lvblwiKX1mdW5jdGlvbiB1cihlLHIsdCl7Zm9yKHZhciBuPVtdLGE9ITA7IUYoZSk7KXtpZihhKWE9ITE7ZWxzZSBpZih6KGJ0KSxyJiZmci5hbGxvd1RyYWlsaW5nQ29tbWFzJiZGKGUpKWJyZWFrO3QmJndyPT09YnQ/bi5wdXNoKG51bGwpOm4ucHVzaChLKCEwKSl9cmV0dXJuIG59ZnVuY3Rpb24gbHIoZSl7dmFyIHI9cSgpO3JldHVybiByLm5hbWU9d3I9PT1Gcj9DcjplJiYhZnIuZm9yYmlkUmVzZXJ2ZWQmJndyLmtleXdvcmR8fFgoKSxFcj0hMSxVKCksaihyLFwiSWRlbnRpZmllclwiKX1lLnZlcnNpb249XCIwLjQuMFwiO3ZhciBmcixkcixwcixocjtlLnBhcnNlPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIGRyPVN0cmluZyhlKSxwcj1kci5sZW5ndGgscih0KSxvKCksVyhmci5wcm9ncmFtKX07dmFyIG1yPWUuZGVmYXVsdE9wdGlvbnM9e2VjbWFWZXJzaW9uOjUsc3RyaWN0U2VtaWNvbG9uczohMSxhbGxvd1RyYWlsaW5nQ29tbWFzOiEwLGZvcmJpZFJlc2VydmVkOiExLGxvY2F0aW9uczohMSxvbkNvbW1lbnQ6bnVsbCxyYW5nZXM6ITEscHJvZ3JhbTpudWxsLHNvdXJjZUZpbGU6bnVsbH0sdnI9ZS5nZXRMaW5lSW5mbz1mdW5jdGlvbihlLHIpe2Zvcih2YXIgdD0xLG49MDs7KXtLdC5sYXN0SW5kZXg9bjt2YXIgYT1LdC5leGVjKGUpO2lmKCEoYSYmYS5pbmRleDxyKSlicmVhazsrK3Qsbj1hLmluZGV4K2FbMF0ubGVuZ3RofXJldHVybntsaW5lOnQsY29sdW1uOnItbn19O2UudG9rZW5pemU9ZnVuY3Rpb24oZSx0KXtmdW5jdGlvbiBuKGUpe3JldHVybiBnKGUpLGEuc3RhcnQ9eXIsYS5lbmQ9Z3IsYS5zdGFydExvYz14cixhLmVuZExvYz1rcixhLnR5cGU9d3IsYS52YWx1ZT1DcixhfWRyPVN0cmluZyhlKSxwcj1kci5sZW5ndGgscih0KSxvKCk7dmFyIGE9e307cmV0dXJuIG4uanVtcFRvPWZ1bmN0aW9uKGUscil7aWYoYnI9ZSxmci5sb2NhdGlvbnMpe0FyPTEsU3I9S3QubGFzdEluZGV4PTA7Zm9yKHZhciB0Oyh0PUt0LmV4ZWMoZHIpKSYmdC5pbmRleDxlOykrK0FyLFNyPXQuaW5kZXgrdFswXS5sZW5ndGh9RXI9cix1KCl9LG59O3ZhciBicix5cixncix4cixrcix3cixDcixFcixBcixTcixJcixMcixVcixScixWcixUcixxcj1bXSxPcj17dHlwZTpcIm51bVwifSxqcj17dHlwZTpcInJlZ2V4cFwifSxEcj17dHlwZTpcInN0cmluZ1wifSxGcj17dHlwZTpcIm5hbWVcIn0sQnI9e3R5cGU6XCJlb2ZcIn0sTXI9e2tleXdvcmQ6XCJicmVha1wifSx6cj17a2V5d29yZDpcImNhc2VcIixiZWZvcmVFeHByOiEwfSxYcj17a2V5d29yZDpcImNhdGNoXCJ9LE5yPXtrZXl3b3JkOlwiY29udGludWVcIn0sV3I9e2tleXdvcmQ6XCJkZWJ1Z2dlclwifSxKcj17a2V5d29yZDpcImRlZmF1bHRcIn0sUHI9e2tleXdvcmQ6XCJkb1wiLGlzTG9vcDohMH0sSHI9e2tleXdvcmQ6XCJlbHNlXCIsYmVmb3JlRXhwcjohMH0sJHI9e2tleXdvcmQ6XCJmaW5hbGx5XCJ9LF9yPXtrZXl3b3JkOlwiZm9yXCIsaXNMb29wOiEwfSxHcj17a2V5d29yZDpcImZ1bmN0aW9uXCJ9LEtyPXtrZXl3b3JkOlwiaWZcIn0sUXI9e2tleXdvcmQ6XCJyZXR1cm5cIixiZWZvcmVFeHByOiEwfSxZcj17a2V5d29yZDpcInN3aXRjaFwifSxacj17a2V5d29yZDpcInRocm93XCIsYmVmb3JlRXhwcjohMH0sZXQ9e2tleXdvcmQ6XCJ0cnlcIn0scnQ9e2tleXdvcmQ6XCJ2YXJcIn0sdHQ9e2tleXdvcmQ6XCJ3aGlsZVwiLGlzTG9vcDohMH0sbnQ9e2tleXdvcmQ6XCJ3aXRoXCJ9LGF0PXtrZXl3b3JkOlwibmV3XCIsYmVmb3JlRXhwcjohMH0sb3Q9e2tleXdvcmQ6XCJ0aGlzXCJ9LGl0PXtrZXl3b3JkOlwibnVsbFwiLGF0b21WYWx1ZTpudWxsfSxzdD17a2V5d29yZDpcInRydWVcIixhdG9tVmFsdWU6ITB9LGN0PXtrZXl3b3JkOlwiZmFsc2VcIixhdG9tVmFsdWU6ITF9LHV0PXtrZXl3b3JkOlwiaW5cIixiaW5vcDo3LGJlZm9yZUV4cHI6ITB9LGx0PXtcImJyZWFrXCI6TXIsXCJjYXNlXCI6enIsXCJjYXRjaFwiOlhyLFwiY29udGludWVcIjpOcixcImRlYnVnZ2VyXCI6V3IsXCJkZWZhdWx0XCI6SnIsXCJkb1wiOlByLFwiZWxzZVwiOkhyLFwiZmluYWxseVwiOiRyLFwiZm9yXCI6X3IsXCJmdW5jdGlvblwiOkdyLFwiaWZcIjpLcixcInJldHVyblwiOlFyLFwic3dpdGNoXCI6WXIsXCJ0aHJvd1wiOlpyLFwidHJ5XCI6ZXQsXCJ2YXJcIjpydCxcIndoaWxlXCI6dHQsXCJ3aXRoXCI6bnQsXCJudWxsXCI6aXQsXCJ0cnVlXCI6c3QsXCJmYWxzZVwiOmN0LFwibmV3XCI6YXQsXCJpblwiOnV0LFwiaW5zdGFuY2VvZlwiOntrZXl3b3JkOlwiaW5zdGFuY2VvZlwiLGJpbm9wOjcsYmVmb3JlRXhwcjohMH0sXCJ0aGlzXCI6b3QsXCJ0eXBlb2ZcIjp7a2V5d29yZDpcInR5cGVvZlwiLHByZWZpeDohMCxiZWZvcmVFeHByOiEwfSxcInZvaWRcIjp7a2V5d29yZDpcInZvaWRcIixwcmVmaXg6ITAsYmVmb3JlRXhwcjohMH0sXCJkZWxldGVcIjp7a2V5d29yZDpcImRlbGV0ZVwiLHByZWZpeDohMCxiZWZvcmVFeHByOiEwfX0sZnQ9e3R5cGU6XCJbXCIsYmVmb3JlRXhwcjohMH0sZHQ9e3R5cGU6XCJdXCJ9LHB0PXt0eXBlOlwie1wiLGJlZm9yZUV4cHI6ITB9LGh0PXt0eXBlOlwifVwifSxtdD17dHlwZTpcIihcIixiZWZvcmVFeHByOiEwfSx2dD17dHlwZTpcIilcIn0sYnQ9e3R5cGU6XCIsXCIsYmVmb3JlRXhwcjohMH0seXQ9e3R5cGU6XCI7XCIsYmVmb3JlRXhwcjohMH0sZ3Q9e3R5cGU6XCI6XCIsYmVmb3JlRXhwcjohMH0seHQ9e3R5cGU6XCIuXCJ9LGt0PXt0eXBlOlwiP1wiLGJlZm9yZUV4cHI6ITB9LHd0PXtiaW5vcDoxMCxiZWZvcmVFeHByOiEwfSxDdD17aXNBc3NpZ246ITAsYmVmb3JlRXhwcjohMH0sRXQ9e2lzQXNzaWduOiEwLGJlZm9yZUV4cHI6ITB9LEF0PXtiaW5vcDo5LHByZWZpeDohMCxiZWZvcmVFeHByOiEwfSxTdD17cG9zdGZpeDohMCxwcmVmaXg6ITAsaXNVcGRhdGU6ITB9LEl0PXtwcmVmaXg6ITAsYmVmb3JlRXhwcjohMH0sTHQ9e2Jpbm9wOjEsYmVmb3JlRXhwcjohMH0sVXQ9e2Jpbm9wOjIsYmVmb3JlRXhwcjohMH0sUnQ9e2Jpbm9wOjMsYmVmb3JlRXhwcjohMH0sVnQ9e2Jpbm9wOjQsYmVmb3JlRXhwcjohMH0sVHQ9e2Jpbm9wOjUsYmVmb3JlRXhwcjohMH0scXQ9e2Jpbm9wOjYsYmVmb3JlRXhwcjohMH0sT3Q9e2Jpbm9wOjcsYmVmb3JlRXhwcjohMH0sanQ9e2Jpbm9wOjgsYmVmb3JlRXhwcjohMH0sRHQ9e2Jpbm9wOjEwLGJlZm9yZUV4cHI6ITB9O2UudG9rVHlwZXM9e2JyYWNrZXRMOmZ0LGJyYWNrZXRSOmR0LGJyYWNlTDpwdCxicmFjZVI6aHQscGFyZW5MOm10LHBhcmVuUjp2dCxjb21tYTpidCxzZW1pOnl0LGNvbG9uOmd0LGRvdDp4dCxxdWVzdGlvbjprdCxzbGFzaDp3dCxlcTpDdCxuYW1lOkZyLGVvZjpCcixudW06T3IscmVnZXhwOmpyLHN0cmluZzpEcn07Zm9yKHZhciBGdCBpbiBsdCllLnRva1R5cGVzW1wiX1wiK0Z0XT1sdFtGdF07dmFyIEJ0LE10PW4oXCJhYnN0cmFjdCBib29sZWFuIGJ5dGUgY2hhciBjbGFzcyBkb3VibGUgZW51bSBleHBvcnQgZXh0ZW5kcyBmaW5hbCBmbG9hdCBnb3RvIGltcGxlbWVudHMgaW1wb3J0IGludCBpbnRlcmZhY2UgbG9uZyBuYXRpdmUgcGFja2FnZSBwcml2YXRlIHByb3RlY3RlZCBwdWJsaWMgc2hvcnQgc3RhdGljIHN1cGVyIHN5bmNocm9uaXplZCB0aHJvd3MgdHJhbnNpZW50IHZvbGF0aWxlXCIpLHp0PW4oXCJjbGFzcyBlbnVtIGV4dGVuZHMgc3VwZXIgY29uc3QgZXhwb3J0IGltcG9ydFwiKSxYdD1uKFwiaW1wbGVtZW50cyBpbnRlcmZhY2UgbGV0IHBhY2thZ2UgcHJpdmF0ZSBwcm90ZWN0ZWQgcHVibGljIHN0YXRpYyB5aWVsZFwiKSxOdD1uKFwiZXZhbCBhcmd1bWVudHNcIiksV3Q9bihcImJyZWFrIGNhc2UgY2F0Y2ggY29udGludWUgZGVidWdnZXIgZGVmYXVsdCBkbyBlbHNlIGZpbmFsbHkgZm9yIGZ1bmN0aW9uIGlmIHJldHVybiBzd2l0Y2ggdGhyb3cgdHJ5IHZhciB3aGlsZSB3aXRoIG51bGwgdHJ1ZSBmYWxzZSBpbnN0YW5jZW9mIHR5cGVvZiB2b2lkIGRlbGV0ZSBuZXcgaW4gdGhpc1wiKSxKdD0vW1xcdTE2ODBcXHUxODBlXFx1MjAwMC1cXHUyMDBhXFx1MjAyZlxcdTIwNWZcXHUzMDAwXFx1ZmVmZl0vLFB0PVwiXFx4YWFcXHhiNVxceGJhXFx4YzAtXFx4ZDZcXHhkOC1cXHhmNlxceGY4LVxcdTAyYzFcXHUwMmM2LVxcdTAyZDFcXHUwMmUwLVxcdTAyZTRcXHUwMmVjXFx1MDJlZVxcdTAzNzAtXFx1MDM3NFxcdTAzNzZcXHUwMzc3XFx1MDM3YS1cXHUwMzdkXFx1MDM4NlxcdTAzODgtXFx1MDM4YVxcdTAzOGNcXHUwMzhlLVxcdTAzYTFcXHUwM2EzLVxcdTAzZjVcXHUwM2Y3LVxcdTA0ODFcXHUwNDhhLVxcdTA1MjdcXHUwNTMxLVxcdTA1NTZcXHUwNTU5XFx1MDU2MS1cXHUwNTg3XFx1MDVkMC1cXHUwNWVhXFx1MDVmMC1cXHUwNWYyXFx1MDYyMC1cXHUwNjRhXFx1MDY2ZVxcdTA2NmZcXHUwNjcxLVxcdTA2ZDNcXHUwNmQ1XFx1MDZlNVxcdTA2ZTZcXHUwNmVlXFx1MDZlZlxcdTA2ZmEtXFx1MDZmY1xcdTA2ZmZcXHUwNzEwXFx1MDcxMi1cXHUwNzJmXFx1MDc0ZC1cXHUwN2E1XFx1MDdiMVxcdTA3Y2EtXFx1MDdlYVxcdTA3ZjRcXHUwN2Y1XFx1MDdmYVxcdTA4MDAtXFx1MDgxNVxcdTA4MWFcXHUwODI0XFx1MDgyOFxcdTA4NDAtXFx1MDg1OFxcdTA4YTBcXHUwOGEyLVxcdTA4YWNcXHUwOTA0LVxcdTA5MzlcXHUwOTNkXFx1MDk1MFxcdTA5NTgtXFx1MDk2MVxcdTA5NzEtXFx1MDk3N1xcdTA5NzktXFx1MDk3ZlxcdTA5ODUtXFx1MDk4Y1xcdTA5OGZcXHUwOTkwXFx1MDk5My1cXHUwOWE4XFx1MDlhYS1cXHUwOWIwXFx1MDliMlxcdTA5YjYtXFx1MDliOVxcdTA5YmRcXHUwOWNlXFx1MDlkY1xcdTA5ZGRcXHUwOWRmLVxcdTA5ZTFcXHUwOWYwXFx1MDlmMVxcdTBhMDUtXFx1MGEwYVxcdTBhMGZcXHUwYTEwXFx1MGExMy1cXHUwYTI4XFx1MGEyYS1cXHUwYTMwXFx1MGEzMlxcdTBhMzNcXHUwYTM1XFx1MGEzNlxcdTBhMzhcXHUwYTM5XFx1MGE1OS1cXHUwYTVjXFx1MGE1ZVxcdTBhNzItXFx1MGE3NFxcdTBhODUtXFx1MGE4ZFxcdTBhOGYtXFx1MGE5MVxcdTBhOTMtXFx1MGFhOFxcdTBhYWEtXFx1MGFiMFxcdTBhYjJcXHUwYWIzXFx1MGFiNS1cXHUwYWI5XFx1MGFiZFxcdTBhZDBcXHUwYWUwXFx1MGFlMVxcdTBiMDUtXFx1MGIwY1xcdTBiMGZcXHUwYjEwXFx1MGIxMy1cXHUwYjI4XFx1MGIyYS1cXHUwYjMwXFx1MGIzMlxcdTBiMzNcXHUwYjM1LVxcdTBiMzlcXHUwYjNkXFx1MGI1Y1xcdTBiNWRcXHUwYjVmLVxcdTBiNjFcXHUwYjcxXFx1MGI4M1xcdTBiODUtXFx1MGI4YVxcdTBiOGUtXFx1MGI5MFxcdTBiOTItXFx1MGI5NVxcdTBiOTlcXHUwYjlhXFx1MGI5Y1xcdTBiOWVcXHUwYjlmXFx1MGJhM1xcdTBiYTRcXHUwYmE4LVxcdTBiYWFcXHUwYmFlLVxcdTBiYjlcXHUwYmQwXFx1MGMwNS1cXHUwYzBjXFx1MGMwZS1cXHUwYzEwXFx1MGMxMi1cXHUwYzI4XFx1MGMyYS1cXHUwYzMzXFx1MGMzNS1cXHUwYzM5XFx1MGMzZFxcdTBjNThcXHUwYzU5XFx1MGM2MFxcdTBjNjFcXHUwYzg1LVxcdTBjOGNcXHUwYzhlLVxcdTBjOTBcXHUwYzkyLVxcdTBjYThcXHUwY2FhLVxcdTBjYjNcXHUwY2I1LVxcdTBjYjlcXHUwY2JkXFx1MGNkZVxcdTBjZTBcXHUwY2UxXFx1MGNmMVxcdTBjZjJcXHUwZDA1LVxcdTBkMGNcXHUwZDBlLVxcdTBkMTBcXHUwZDEyLVxcdTBkM2FcXHUwZDNkXFx1MGQ0ZVxcdTBkNjBcXHUwZDYxXFx1MGQ3YS1cXHUwZDdmXFx1MGQ4NS1cXHUwZDk2XFx1MGQ5YS1cXHUwZGIxXFx1MGRiMy1cXHUwZGJiXFx1MGRiZFxcdTBkYzAtXFx1MGRjNlxcdTBlMDEtXFx1MGUzMFxcdTBlMzJcXHUwZTMzXFx1MGU0MC1cXHUwZTQ2XFx1MGU4MVxcdTBlODJcXHUwZTg0XFx1MGU4N1xcdTBlODhcXHUwZThhXFx1MGU4ZFxcdTBlOTQtXFx1MGU5N1xcdTBlOTktXFx1MGU5ZlxcdTBlYTEtXFx1MGVhM1xcdTBlYTVcXHUwZWE3XFx1MGVhYVxcdTBlYWJcXHUwZWFkLVxcdTBlYjBcXHUwZWIyXFx1MGViM1xcdTBlYmRcXHUwZWMwLVxcdTBlYzRcXHUwZWM2XFx1MGVkYy1cXHUwZWRmXFx1MGYwMFxcdTBmNDAtXFx1MGY0N1xcdTBmNDktXFx1MGY2Y1xcdTBmODgtXFx1MGY4Y1xcdTEwMDAtXFx1MTAyYVxcdTEwM2ZcXHUxMDUwLVxcdTEwNTVcXHUxMDVhLVxcdTEwNWRcXHUxMDYxXFx1MTA2NVxcdTEwNjZcXHUxMDZlLVxcdTEwNzBcXHUxMDc1LVxcdTEwODFcXHUxMDhlXFx1MTBhMC1cXHUxMGM1XFx1MTBjN1xcdTEwY2RcXHUxMGQwLVxcdTEwZmFcXHUxMGZjLVxcdTEyNDhcXHUxMjRhLVxcdTEyNGRcXHUxMjUwLVxcdTEyNTZcXHUxMjU4XFx1MTI1YS1cXHUxMjVkXFx1MTI2MC1cXHUxMjg4XFx1MTI4YS1cXHUxMjhkXFx1MTI5MC1cXHUxMmIwXFx1MTJiMi1cXHUxMmI1XFx1MTJiOC1cXHUxMmJlXFx1MTJjMFxcdTEyYzItXFx1MTJjNVxcdTEyYzgtXFx1MTJkNlxcdTEyZDgtXFx1MTMxMFxcdTEzMTItXFx1MTMxNVxcdTEzMTgtXFx1MTM1YVxcdTEzODAtXFx1MTM4ZlxcdTEzYTAtXFx1MTNmNFxcdTE0MDEtXFx1MTY2Y1xcdTE2NmYtXFx1MTY3ZlxcdTE2ODEtXFx1MTY5YVxcdTE2YTAtXFx1MTZlYVxcdTE2ZWUtXFx1MTZmMFxcdTE3MDAtXFx1MTcwY1xcdTE3MGUtXFx1MTcxMVxcdTE3MjAtXFx1MTczMVxcdTE3NDAtXFx1MTc1MVxcdTE3NjAtXFx1MTc2Y1xcdTE3NmUtXFx1MTc3MFxcdTE3ODAtXFx1MTdiM1xcdTE3ZDdcXHUxN2RjXFx1MTgyMC1cXHUxODc3XFx1MTg4MC1cXHUxOGE4XFx1MThhYVxcdTE4YjAtXFx1MThmNVxcdTE5MDAtXFx1MTkxY1xcdTE5NTAtXFx1MTk2ZFxcdTE5NzAtXFx1MTk3NFxcdTE5ODAtXFx1MTlhYlxcdTE5YzEtXFx1MTljN1xcdTFhMDAtXFx1MWExNlxcdTFhMjAtXFx1MWE1NFxcdTFhYTdcXHUxYjA1LVxcdTFiMzNcXHUxYjQ1LVxcdTFiNGJcXHUxYjgzLVxcdTFiYTBcXHUxYmFlXFx1MWJhZlxcdTFiYmEtXFx1MWJlNVxcdTFjMDAtXFx1MWMyM1xcdTFjNGQtXFx1MWM0ZlxcdTFjNWEtXFx1MWM3ZFxcdTFjZTktXFx1MWNlY1xcdTFjZWUtXFx1MWNmMVxcdTFjZjVcXHUxY2Y2XFx1MWQwMC1cXHUxZGJmXFx1MWUwMC1cXHUxZjE1XFx1MWYxOC1cXHUxZjFkXFx1MWYyMC1cXHUxZjQ1XFx1MWY0OC1cXHUxZjRkXFx1MWY1MC1cXHUxZjU3XFx1MWY1OVxcdTFmNWJcXHUxZjVkXFx1MWY1Zi1cXHUxZjdkXFx1MWY4MC1cXHUxZmI0XFx1MWZiNi1cXHUxZmJjXFx1MWZiZVxcdTFmYzItXFx1MWZjNFxcdTFmYzYtXFx1MWZjY1xcdTFmZDAtXFx1MWZkM1xcdTFmZDYtXFx1MWZkYlxcdTFmZTAtXFx1MWZlY1xcdTFmZjItXFx1MWZmNFxcdTFmZjYtXFx1MWZmY1xcdTIwNzFcXHUyMDdmXFx1MjA5MC1cXHUyMDljXFx1MjEwMlxcdTIxMDdcXHUyMTBhLVxcdTIxMTNcXHUyMTE1XFx1MjExOS1cXHUyMTFkXFx1MjEyNFxcdTIxMjZcXHUyMTI4XFx1MjEyYS1cXHUyMTJkXFx1MjEyZi1cXHUyMTM5XFx1MjEzYy1cXHUyMTNmXFx1MjE0NS1cXHUyMTQ5XFx1MjE0ZVxcdTIxNjAtXFx1MjE4OFxcdTJjMDAtXFx1MmMyZVxcdTJjMzAtXFx1MmM1ZVxcdTJjNjAtXFx1MmNlNFxcdTJjZWItXFx1MmNlZVxcdTJjZjJcXHUyY2YzXFx1MmQwMC1cXHUyZDI1XFx1MmQyN1xcdTJkMmRcXHUyZDMwLVxcdTJkNjdcXHUyZDZmXFx1MmQ4MC1cXHUyZDk2XFx1MmRhMC1cXHUyZGE2XFx1MmRhOC1cXHUyZGFlXFx1MmRiMC1cXHUyZGI2XFx1MmRiOC1cXHUyZGJlXFx1MmRjMC1cXHUyZGM2XFx1MmRjOC1cXHUyZGNlXFx1MmRkMC1cXHUyZGQ2XFx1MmRkOC1cXHUyZGRlXFx1MmUyZlxcdTMwMDUtXFx1MzAwN1xcdTMwMjEtXFx1MzAyOVxcdTMwMzEtXFx1MzAzNVxcdTMwMzgtXFx1MzAzY1xcdTMwNDEtXFx1MzA5NlxcdTMwOWQtXFx1MzA5ZlxcdTMwYTEtXFx1MzBmYVxcdTMwZmMtXFx1MzBmZlxcdTMxMDUtXFx1MzEyZFxcdTMxMzEtXFx1MzE4ZVxcdTMxYTAtXFx1MzFiYVxcdTMxZjAtXFx1MzFmZlxcdTM0MDAtXFx1NGRiNVxcdTRlMDAtXFx1OWZjY1xcdWEwMDAtXFx1YTQ4Y1xcdWE0ZDAtXFx1YTRmZFxcdWE1MDAtXFx1YTYwY1xcdWE2MTAtXFx1YTYxZlxcdWE2MmFcXHVhNjJiXFx1YTY0MC1cXHVhNjZlXFx1YTY3Zi1cXHVhNjk3XFx1YTZhMC1cXHVhNmVmXFx1YTcxNy1cXHVhNzFmXFx1YTcyMi1cXHVhNzg4XFx1YTc4Yi1cXHVhNzhlXFx1YTc5MC1cXHVhNzkzXFx1YTdhMC1cXHVhN2FhXFx1YTdmOC1cXHVhODAxXFx1YTgwMy1cXHVhODA1XFx1YTgwNy1cXHVhODBhXFx1YTgwYy1cXHVhODIyXFx1YTg0MC1cXHVhODczXFx1YTg4Mi1cXHVhOGIzXFx1YThmMi1cXHVhOGY3XFx1YThmYlxcdWE5MGEtXFx1YTkyNVxcdWE5MzAtXFx1YTk0NlxcdWE5NjAtXFx1YTk3Y1xcdWE5ODQtXFx1YTliMlxcdWE5Y2ZcXHVhYTAwLVxcdWFhMjhcXHVhYTQwLVxcdWFhNDJcXHVhYTQ0LVxcdWFhNGJcXHVhYTYwLVxcdWFhNzZcXHVhYTdhXFx1YWE4MC1cXHVhYWFmXFx1YWFiMVxcdWFhYjVcXHVhYWI2XFx1YWFiOS1cXHVhYWJkXFx1YWFjMFxcdWFhYzJcXHVhYWRiLVxcdWFhZGRcXHVhYWUwLVxcdWFhZWFcXHVhYWYyLVxcdWFhZjRcXHVhYjAxLVxcdWFiMDZcXHVhYjA5LVxcdWFiMGVcXHVhYjExLVxcdWFiMTZcXHVhYjIwLVxcdWFiMjZcXHVhYjI4LVxcdWFiMmVcXHVhYmMwLVxcdWFiZTJcXHVhYzAwLVxcdWQ3YTNcXHVkN2IwLVxcdWQ3YzZcXHVkN2NiLVxcdWQ3ZmJcXHVmOTAwLVxcdWZhNmRcXHVmYTcwLVxcdWZhZDlcXHVmYjAwLVxcdWZiMDZcXHVmYjEzLVxcdWZiMTdcXHVmYjFkXFx1ZmIxZi1cXHVmYjI4XFx1ZmIyYS1cXHVmYjM2XFx1ZmIzOC1cXHVmYjNjXFx1ZmIzZVxcdWZiNDBcXHVmYjQxXFx1ZmI0M1xcdWZiNDRcXHVmYjQ2LVxcdWZiYjFcXHVmYmQzLVxcdWZkM2RcXHVmZDUwLVxcdWZkOGZcXHVmZDkyLVxcdWZkYzdcXHVmZGYwLVxcdWZkZmJcXHVmZTcwLVxcdWZlNzRcXHVmZTc2LVxcdWZlZmNcXHVmZjIxLVxcdWZmM2FcXHVmZjQxLVxcdWZmNWFcXHVmZjY2LVxcdWZmYmVcXHVmZmMyLVxcdWZmYzdcXHVmZmNhLVxcdWZmY2ZcXHVmZmQyLVxcdWZmZDdcXHVmZmRhLVxcdWZmZGNcIixIdD1cIlxcdTAzMDAtXFx1MDM2ZlxcdTA0ODMtXFx1MDQ4N1xcdTA1OTEtXFx1MDViZFxcdTA1YmZcXHUwNWMxXFx1MDVjMlxcdTA1YzRcXHUwNWM1XFx1MDVjN1xcdTA2MTAtXFx1MDYxYVxcdTA2MjAtXFx1MDY0OVxcdTA2NzItXFx1MDZkM1xcdTA2ZTctXFx1MDZlOFxcdTA2ZmItXFx1MDZmY1xcdTA3MzAtXFx1MDc0YVxcdTA4MDAtXFx1MDgxNFxcdTA4MWItXFx1MDgyM1xcdTA4MjUtXFx1MDgyN1xcdTA4MjktXFx1MDgyZFxcdTA4NDAtXFx1MDg1N1xcdTA4ZTQtXFx1MDhmZVxcdTA5MDAtXFx1MDkwM1xcdTA5M2EtXFx1MDkzY1xcdTA5M2UtXFx1MDk0ZlxcdTA5NTEtXFx1MDk1N1xcdTA5NjItXFx1MDk2M1xcdTA5NjYtXFx1MDk2ZlxcdTA5ODEtXFx1MDk4M1xcdTA5YmNcXHUwOWJlLVxcdTA5YzRcXHUwOWM3XFx1MDljOFxcdTA5ZDdcXHUwOWRmLVxcdTA5ZTBcXHUwYTAxLVxcdTBhMDNcXHUwYTNjXFx1MGEzZS1cXHUwYTQyXFx1MGE0N1xcdTBhNDhcXHUwYTRiLVxcdTBhNGRcXHUwYTUxXFx1MGE2Ni1cXHUwYTcxXFx1MGE3NVxcdTBhODEtXFx1MGE4M1xcdTBhYmNcXHUwYWJlLVxcdTBhYzVcXHUwYWM3LVxcdTBhYzlcXHUwYWNiLVxcdTBhY2RcXHUwYWUyLVxcdTBhZTNcXHUwYWU2LVxcdTBhZWZcXHUwYjAxLVxcdTBiMDNcXHUwYjNjXFx1MGIzZS1cXHUwYjQ0XFx1MGI0N1xcdTBiNDhcXHUwYjRiLVxcdTBiNGRcXHUwYjU2XFx1MGI1N1xcdTBiNWYtXFx1MGI2MFxcdTBiNjYtXFx1MGI2ZlxcdTBiODJcXHUwYmJlLVxcdTBiYzJcXHUwYmM2LVxcdTBiYzhcXHUwYmNhLVxcdTBiY2RcXHUwYmQ3XFx1MGJlNi1cXHUwYmVmXFx1MGMwMS1cXHUwYzAzXFx1MGM0Ni1cXHUwYzQ4XFx1MGM0YS1cXHUwYzRkXFx1MGM1NVxcdTBjNTZcXHUwYzYyLVxcdTBjNjNcXHUwYzY2LVxcdTBjNmZcXHUwYzgyXFx1MGM4M1xcdTBjYmNcXHUwY2JlLVxcdTBjYzRcXHUwY2M2LVxcdTBjYzhcXHUwY2NhLVxcdTBjY2RcXHUwY2Q1XFx1MGNkNlxcdTBjZTItXFx1MGNlM1xcdTBjZTYtXFx1MGNlZlxcdTBkMDJcXHUwZDAzXFx1MGQ0Ni1cXHUwZDQ4XFx1MGQ1N1xcdTBkNjItXFx1MGQ2M1xcdTBkNjYtXFx1MGQ2ZlxcdTBkODJcXHUwZDgzXFx1MGRjYVxcdTBkY2YtXFx1MGRkNFxcdTBkZDZcXHUwZGQ4LVxcdTBkZGZcXHUwZGYyXFx1MGRmM1xcdTBlMzQtXFx1MGUzYVxcdTBlNDAtXFx1MGU0NVxcdTBlNTAtXFx1MGU1OVxcdTBlYjQtXFx1MGViOVxcdTBlYzgtXFx1MGVjZFxcdTBlZDAtXFx1MGVkOVxcdTBmMThcXHUwZjE5XFx1MGYyMC1cXHUwZjI5XFx1MGYzNVxcdTBmMzdcXHUwZjM5XFx1MGY0MS1cXHUwZjQ3XFx1MGY3MS1cXHUwZjg0XFx1MGY4Ni1cXHUwZjg3XFx1MGY4ZC1cXHUwZjk3XFx1MGY5OS1cXHUwZmJjXFx1MGZjNlxcdTEwMDAtXFx1MTAyOVxcdTEwNDAtXFx1MTA0OVxcdTEwNjctXFx1MTA2ZFxcdTEwNzEtXFx1MTA3NFxcdTEwODItXFx1MTA4ZFxcdTEwOGYtXFx1MTA5ZFxcdTEzNWQtXFx1MTM1ZlxcdTE3MGUtXFx1MTcxMFxcdTE3MjAtXFx1MTczMFxcdTE3NDAtXFx1MTc1MFxcdTE3NzJcXHUxNzczXFx1MTc4MC1cXHUxN2IyXFx1MTdkZFxcdTE3ZTAtXFx1MTdlOVxcdTE4MGItXFx1MTgwZFxcdTE4MTAtXFx1MTgxOVxcdTE5MjAtXFx1MTkyYlxcdTE5MzAtXFx1MTkzYlxcdTE5NTEtXFx1MTk2ZFxcdTE5YjAtXFx1MTljMFxcdTE5YzgtXFx1MTljOVxcdTE5ZDAtXFx1MTlkOVxcdTFhMDAtXFx1MWExNVxcdTFhMjAtXFx1MWE1M1xcdTFhNjAtXFx1MWE3Y1xcdTFhN2YtXFx1MWE4OVxcdTFhOTAtXFx1MWE5OVxcdTFiNDYtXFx1MWI0YlxcdTFiNTAtXFx1MWI1OVxcdTFiNmItXFx1MWI3M1xcdTFiYjAtXFx1MWJiOVxcdTFiZTYtXFx1MWJmM1xcdTFjMDAtXFx1MWMyMlxcdTFjNDAtXFx1MWM0OVxcdTFjNWItXFx1MWM3ZFxcdTFjZDAtXFx1MWNkMlxcdTFkMDAtXFx1MWRiZVxcdTFlMDEtXFx1MWYxNVxcdTIwMGNcXHUyMDBkXFx1MjAzZlxcdTIwNDBcXHUyMDU0XFx1MjBkMC1cXHUyMGRjXFx1MjBlMVxcdTIwZTUtXFx1MjBmMFxcdTJkODEtXFx1MmQ5NlxcdTJkZTAtXFx1MmRmZlxcdTMwMjEtXFx1MzAyOFxcdTMwOTlcXHUzMDlhXFx1YTY0MC1cXHVhNjZkXFx1YTY3NC1cXHVhNjdkXFx1YTY5ZlxcdWE2ZjAtXFx1YTZmMVxcdWE3ZjgtXFx1YTgwMFxcdWE4MDZcXHVhODBiXFx1YTgyMy1cXHVhODI3XFx1YTg4MC1cXHVhODgxXFx1YThiNC1cXHVhOGM0XFx1YThkMC1cXHVhOGQ5XFx1YThmMy1cXHVhOGY3XFx1YTkwMC1cXHVhOTA5XFx1YTkyNi1cXHVhOTJkXFx1YTkzMC1cXHVhOTQ1XFx1YTk4MC1cXHVhOTgzXFx1YTliMy1cXHVhOWMwXFx1YWEwMC1cXHVhYTI3XFx1YWE0MC1cXHVhYTQxXFx1YWE0Yy1cXHVhYTRkXFx1YWE1MC1cXHVhYTU5XFx1YWE3YlxcdWFhZTAtXFx1YWFlOVxcdWFhZjItXFx1YWFmM1xcdWFiYzAtXFx1YWJlMVxcdWFiZWNcXHVhYmVkXFx1YWJmMC1cXHVhYmY5XFx1ZmIyMC1cXHVmYjI4XFx1ZmUwMC1cXHVmZTBmXFx1ZmUyMC1cXHVmZTI2XFx1ZmUzM1xcdWZlMzRcXHVmZTRkLVxcdWZlNGZcXHVmZjEwLVxcdWZmMTlcXHVmZjNmXCIsJHQ9bmV3IFJlZ0V4cChcIltcIitQdCtcIl1cIiksX3Q9bmV3IFJlZ0V4cChcIltcIitQdCtIdCtcIl1cIiksR3Q9L1tcXG5cXHJcXHUyMDI4XFx1MjAyOV0vLEt0PS9cXHJcXG58W1xcblxcclxcdTIwMjhcXHUyMDI5XS9nLFF0PWUuaXNJZGVudGlmaWVyU3RhcnQ9ZnVuY3Rpb24oZSl7cmV0dXJuIDY1PmU/MzY9PT1lOjkxPmU/ITA6OTc+ZT85NT09PWU6MTIzPmU/ITA6ZT49MTcwJiYkdC50ZXN0KFN0cmluZy5mcm9tQ2hhckNvZGUoZSkpfSxZdD1lLmlzSWRlbnRpZmllckNoYXI9ZnVuY3Rpb24oZSl7cmV0dXJuIDQ4PmU/MzY9PT1lOjU4PmU/ITA6NjU+ZT8hMTo5MT5lPyEwOjk3PmU/OTU9PT1lOjEyMz5lPyEwOmU+PTE3MCYmX3QudGVzdChTdHJpbmcuZnJvbUNoYXJDb2RlKGUpKX0sWnQ9e2tpbmQ6XCJsb29wXCJ9LGVuPXtraW5kOlwic3dpdGNoXCJ9fSk7XG5cblx0dmFyIGJpbmFyeU9wZXJhdG9ycyA9IHtcblx0XHQnKyc6ICdfX2FkZCcsXG5cdFx0Jy0nOiAnX19zdWJ0cmFjdCcsXG5cdFx0JyonOiAnX19tdWx0aXBseScsXG5cdFx0Jy8nOiAnX19kaXZpZGUnLFxuXHRcdCclJzogJ19fbW9kdWxvJyxcblx0XHQnPT0nOiAnZXF1YWxzJyxcblx0XHQnIT0nOiAnZXF1YWxzJ1xuXHR9O1xuXG5cdHZhciB1bmFyeU9wZXJhdG9ycyA9IHtcblx0XHQnLSc6ICdfX25lZ2F0ZScsXG5cdFx0JysnOiBudWxsXG5cdH07XG5cblx0dmFyIGZpZWxkcyA9IEJhc2UuZWFjaChcblx0XHRbJ2FkZCcsICdzdWJ0cmFjdCcsICdtdWx0aXBseScsICdkaXZpZGUnLCAnbW9kdWxvJywgJ25lZ2F0ZSddLFxuXHRcdGZ1bmN0aW9uKG5hbWUpIHtcblx0XHRcdHRoaXNbJ19fJyArIG5hbWVdID0gJyMnICsgbmFtZTtcblx0XHR9LFxuXHRcdHt9XG5cdCk7XG5cdFBvaW50LmluamVjdChmaWVsZHMpO1xuXHRTaXplLmluamVjdChmaWVsZHMpO1xuXHRDb2xvci5pbmplY3QoZmllbGRzKTtcblxuXHRmdW5jdGlvbiBfXyRfXyhsZWZ0LCBvcGVyYXRvciwgcmlnaHQpIHtcblx0XHR2YXIgaGFuZGxlciA9IGJpbmFyeU9wZXJhdG9yc1tvcGVyYXRvcl07XG5cdFx0aWYgKGxlZnQgJiYgbGVmdFtoYW5kbGVyXSkge1xuXHRcdFx0dmFyIHJlcyA9IGxlZnRbaGFuZGxlcl0ocmlnaHQpO1xuXHRcdFx0cmV0dXJuIG9wZXJhdG9yID09PSAnIT0nID8gIXJlcyA6IHJlcztcblx0XHR9XG5cdFx0c3dpdGNoIChvcGVyYXRvcikge1xuXHRcdGNhc2UgJysnOiByZXR1cm4gbGVmdCArIHJpZ2h0O1xuXHRcdGNhc2UgJy0nOiByZXR1cm4gbGVmdCAtIHJpZ2h0O1xuXHRcdGNhc2UgJyonOiByZXR1cm4gbGVmdCAqIHJpZ2h0O1xuXHRcdGNhc2UgJy8nOiByZXR1cm4gbGVmdCAvIHJpZ2h0O1xuXHRcdGNhc2UgJyUnOiByZXR1cm4gbGVmdCAlIHJpZ2h0O1xuXHRcdGNhc2UgJz09JzogcmV0dXJuIGxlZnQgPT0gcmlnaHQ7XG5cdFx0Y2FzZSAnIT0nOiByZXR1cm4gbGVmdCAhPSByaWdodDtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiAkX18ob3BlcmF0b3IsIHZhbHVlKSB7XG5cdFx0dmFyIGhhbmRsZXIgPSB1bmFyeU9wZXJhdG9yc1tvcGVyYXRvcl07XG5cdFx0aWYgKGhhbmRsZXIgJiYgdmFsdWUgJiYgdmFsdWVbaGFuZGxlcl0pXG5cdFx0XHRyZXR1cm4gdmFsdWVbaGFuZGxlcl0oKTtcblx0XHRzd2l0Y2ggKG9wZXJhdG9yKSB7XG5cdFx0Y2FzZSAnKyc6IHJldHVybiArdmFsdWU7XG5cdFx0Y2FzZSAnLSc6IHJldHVybiAtdmFsdWU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gcGFyc2UoY29kZSwgb3B0aW9ucykge1xuXHRcdHJldHVybiBzY29wZS5hY29ybi5wYXJzZShjb2RlLCBvcHRpb25zKTtcblx0fVxuXG5cdGZ1bmN0aW9uIGNvbXBpbGUoY29kZSwgdXJsLCBvcHRpb25zKSB7XG5cdFx0aWYgKCFjb2RlKVxuXHRcdFx0cmV0dXJuICcnO1xuXHRcdG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuXHRcdHVybCA9IHVybCB8fCAnJztcblxuXHRcdHZhciBpbnNlcnRpb25zID0gW107XG5cblx0XHRmdW5jdGlvbiBnZXRPZmZzZXQob2Zmc2V0KSB7XG5cdFx0XHRmb3IgKHZhciBpID0gMCwgbCA9IGluc2VydGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG5cdFx0XHRcdHZhciBpbnNlcnRpb24gPSBpbnNlcnRpb25zW2ldO1xuXHRcdFx0XHRpZiAoaW5zZXJ0aW9uWzBdID49IG9mZnNldClcblx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0b2Zmc2V0ICs9IGluc2VydGlvblsxXTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBvZmZzZXQ7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0Q29kZShub2RlKSB7XG5cdFx0XHRyZXR1cm4gY29kZS5zdWJzdHJpbmcoZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMF0pLFxuXHRcdFx0XHRcdGdldE9mZnNldChub2RlLnJhbmdlWzFdKSk7XG5cdFx0fVxuXG5cdFx0ZnVuY3Rpb24gZ2V0QmV0d2VlbihsZWZ0LCByaWdodCkge1xuXHRcdFx0cmV0dXJuIGNvZGUuc3Vic3RyaW5nKGdldE9mZnNldChsZWZ0LnJhbmdlWzFdKSxcblx0XHRcdFx0XHRnZXRPZmZzZXQocmlnaHQucmFuZ2VbMF0pKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiByZXBsYWNlQ29kZShub2RlLCBzdHIpIHtcblx0XHRcdHZhciBzdGFydCA9IGdldE9mZnNldChub2RlLnJhbmdlWzBdKSxcblx0XHRcdFx0ZW5kID0gZ2V0T2Zmc2V0KG5vZGUucmFuZ2VbMV0pLFxuXHRcdFx0XHRpbnNlcnQgPSAwO1xuXHRcdFx0Zm9yICh2YXIgaSA9IGluc2VydGlvbnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcblx0XHRcdFx0aWYgKHN0YXJ0ID4gaW5zZXJ0aW9uc1tpXVswXSkge1xuXHRcdFx0XHRcdGluc2VydCA9IGkgKyAxO1xuXHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0XHRpbnNlcnRpb25zLnNwbGljZShpbnNlcnQsIDAsIFtzdGFydCwgc3RyLmxlbmd0aCAtIGVuZCArIHN0YXJ0XSk7XG5cdFx0XHRjb2RlID0gY29kZS5zdWJzdHJpbmcoMCwgc3RhcnQpICsgc3RyICsgY29kZS5zdWJzdHJpbmcoZW5kKTtcblx0XHR9XG5cblx0XHRmdW5jdGlvbiB3YWxrQVNUKG5vZGUsIHBhcmVudCkge1xuXHRcdFx0aWYgKCFub2RlKVxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHRmb3IgKHZhciBrZXkgaW4gbm9kZSkge1xuXHRcdFx0XHRpZiAoa2V5ID09PSAncmFuZ2UnIHx8IGtleSA9PT0gJ2xvYycpXG5cdFx0XHRcdFx0Y29udGludWU7XG5cdFx0XHRcdHZhciB2YWx1ZSA9IG5vZGVba2V5XTtcblx0XHRcdFx0aWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG5cdFx0XHRcdFx0Zm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspXG5cdFx0XHRcdFx0XHR3YWxrQVNUKHZhbHVlW2ldLCBub2RlKTtcblx0XHRcdFx0fSBlbHNlIGlmICh2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG5cdFx0XHRcdFx0d2Fsa0FTVCh2YWx1ZSwgbm9kZSk7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdHN3aXRjaCAobm9kZS50eXBlKSB7XG5cdFx0XHRjYXNlICdVbmFyeUV4cHJlc3Npb24nOlxuXHRcdFx0XHRpZiAobm9kZS5vcGVyYXRvciBpbiB1bmFyeU9wZXJhdG9yc1xuXHRcdFx0XHRcdFx0JiYgbm9kZS5hcmd1bWVudC50eXBlICE9PSAnTGl0ZXJhbCcpIHtcblx0XHRcdFx0XHR2YXIgYXJnID0gZ2V0Q29kZShub2RlLmFyZ3VtZW50KTtcblx0XHRcdFx0XHRyZXBsYWNlQ29kZShub2RlLCAnJF9fKFwiJyArIG5vZGUub3BlcmF0b3IgKyAnXCIsICdcblx0XHRcdFx0XHRcdFx0KyBhcmcgKyAnKScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnQmluYXJ5RXhwcmVzc2lvbic6XG5cdFx0XHRcdGlmIChub2RlLm9wZXJhdG9yIGluIGJpbmFyeU9wZXJhdG9yc1xuXHRcdFx0XHRcdFx0JiYgbm9kZS5sZWZ0LnR5cGUgIT09ICdMaXRlcmFsJykge1xuXHRcdFx0XHRcdHZhciBsZWZ0ID0gZ2V0Q29kZShub2RlLmxlZnQpLFxuXHRcdFx0XHRcdFx0cmlnaHQgPSBnZXRDb2RlKG5vZGUucmlnaHQpLFxuXHRcdFx0XHRcdFx0YmV0d2VlbiA9IGdldEJldHdlZW4obm9kZS5sZWZ0LCBub2RlLnJpZ2h0KSxcblx0XHRcdFx0XHRcdG9wZXJhdG9yID0gbm9kZS5vcGVyYXRvcjtcblx0XHRcdFx0XHRyZXBsYWNlQ29kZShub2RlLCAnX18kX18oJyArIGxlZnQgKyAnLCdcblx0XHRcdFx0XHRcdFx0KyBiZXR3ZWVuLnJlcGxhY2UobmV3IFJlZ0V4cCgnXFxcXCcgKyBvcGVyYXRvciksXG5cdFx0XHRcdFx0XHRcdFx0J1wiJyArIG9wZXJhdG9yICsgJ1wiJylcblx0XHRcdFx0XHRcdFx0KyAnLCAnICsgcmlnaHQgKyAnKScpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGJyZWFrO1xuXHRcdFx0Y2FzZSAnVXBkYXRlRXhwcmVzc2lvbic6XG5cdFx0XHRjYXNlICdBc3NpZ25tZW50RXhwcmVzc2lvbic6XG5cdFx0XHRcdHZhciBwYXJlbnRUeXBlID0gcGFyZW50ICYmIHBhcmVudC50eXBlO1xuXHRcdFx0XHRpZiAoIShcblx0XHRcdFx0XHRcdHBhcmVudFR5cGUgPT09ICdGb3JTdGF0ZW1lbnQnXG5cdFx0XHRcdFx0XHR8fCBwYXJlbnRUeXBlID09PSAnQmluYXJ5RXhwcmVzc2lvbidcblx0XHRcdFx0XHRcdFx0JiYgL15bPSE8Pl0vLnRlc3QocGFyZW50Lm9wZXJhdG9yKVxuXHRcdFx0XHRcdFx0fHwgcGFyZW50VHlwZSA9PT0gJ01lbWJlckV4cHJlc3Npb24nICYmIHBhcmVudC5jb21wdXRlZFxuXHRcdFx0XHQpKSB7XG5cdFx0XHRcdFx0aWYgKG5vZGUudHlwZSA9PT0gJ1VwZGF0ZUV4cHJlc3Npb24nKSB7XG5cdFx0XHRcdFx0XHR2YXIgYXJnID0gZ2V0Q29kZShub2RlLmFyZ3VtZW50KSxcblx0XHRcdFx0XHRcdFx0ZXhwID0gJ19fJF9fKCcgKyBhcmcgKyAnLCBcIicgKyBub2RlLm9wZXJhdG9yWzBdXG5cdFx0XHRcdFx0XHRcdFx0XHQrICdcIiwgMSknLFxuXHRcdFx0XHRcdFx0XHRzdHIgPSBhcmcgKyAnID0gJyArIGV4cDtcblx0XHRcdFx0XHRcdGlmICghbm9kZS5wcmVmaXhcblx0XHRcdFx0XHRcdFx0XHQmJiAocGFyZW50VHlwZSA9PT0gJ0Fzc2lnbm1lbnRFeHByZXNzaW9uJ1xuXHRcdFx0XHRcdFx0XHRcdFx0fHwgcGFyZW50VHlwZSA9PT0gJ1ZhcmlhYmxlRGVjbGFyYXRvcicpKSB7XG5cdFx0XHRcdFx0XHRcdGlmIChnZXRDb2RlKHBhcmVudC5sZWZ0IHx8IHBhcmVudC5pZCkgPT09IGFyZylcblx0XHRcdFx0XHRcdFx0XHRzdHIgPSBleHA7XG5cdFx0XHRcdFx0XHRcdHN0ciA9IGFyZyArICc7ICcgKyBzdHI7XG5cdFx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0XHRyZXBsYWNlQ29kZShub2RlLCBzdHIpO1xuXHRcdFx0XHRcdH0gZWxzZSB7XG5cdFx0XHRcdFx0XHRpZiAoL14uPSQvLnRlc3Qobm9kZS5vcGVyYXRvcilcblx0XHRcdFx0XHRcdFx0XHQmJiBub2RlLmxlZnQudHlwZSAhPT0gJ0xpdGVyYWwnKSB7XG5cdFx0XHRcdFx0XHRcdHZhciBsZWZ0ID0gZ2V0Q29kZShub2RlLmxlZnQpLFxuXHRcdFx0XHRcdFx0XHRcdHJpZ2h0ID0gZ2V0Q29kZShub2RlLnJpZ2h0KTtcblx0XHRcdFx0XHRcdFx0cmVwbGFjZUNvZGUobm9kZSwgbGVmdCArICcgPSBfXyRfXygnICsgbGVmdCArICcsIFwiJ1xuXHRcdFx0XHRcdFx0XHRcdFx0KyBub2RlLm9wZXJhdG9yWzBdICsgJ1wiLCAnICsgcmlnaHQgKyAnKScpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdH1cblx0XHRcdFx0fVxuXHRcdFx0XHRicmVhaztcblx0XHRcdH1cblx0XHR9XG5cdFx0dmFyIHNvdXJjZU1hcCA9IG51bGwsXG5cdFx0XHRicm93c2VyID0gcGFwZXIuYnJvd3Nlcixcblx0XHRcdHZlcnNpb24gPSBicm93c2VyLnZlcnNpb25OdW1iZXIsXG5cdFx0XHRsaW5lQnJlYWtzID0gL1xcclxcbnxcXG58XFxyL21nO1xuXHRcdGlmIChicm93c2VyLmNocm9tZSAmJiB2ZXJzaW9uID49IDMwXG5cdFx0XHRcdHx8IGJyb3dzZXIud2Via2l0ICYmIHZlcnNpb24gPj0gNTM3Ljc2XG5cdFx0XHRcdHx8IGJyb3dzZXIuZmlyZWZveCAmJiB2ZXJzaW9uID49IDIzKSB7XG5cdFx0XHR2YXIgb2Zmc2V0ID0gMDtcblx0XHRcdGlmICh3aW5kb3cubG9jYXRpb24uaHJlZi5pbmRleE9mKHVybCkgPT09IDApIHtcblx0XHRcdFx0dmFyIGh0bWwgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaHRtbCcpWzBdLmlubmVySFRNTDtcblx0XHRcdFx0b2Zmc2V0ID0gaHRtbC5zdWJzdHIoMCwgaHRtbC5pbmRleE9mKGNvZGUpICsgMSkubWF0Y2goXG5cdFx0XHRcdFx0XHRsaW5lQnJlYWtzKS5sZW5ndGggKyAxO1xuXHRcdFx0fVxuXHRcdFx0dmFyIG1hcHBpbmdzID0gWydBQUFBJ107XG5cdFx0XHRtYXBwaW5ncy5sZW5ndGggPSAoY29kZS5tYXRjaChsaW5lQnJlYWtzKSB8fCBbXSkubGVuZ3RoICsgMSArIG9mZnNldDtcblx0XHRcdHNvdXJjZU1hcCA9IHtcblx0XHRcdFx0dmVyc2lvbjogMyxcblx0XHRcdFx0ZmlsZTogdXJsLFxuXHRcdFx0XHRuYW1lczpbXSxcblx0XHRcdFx0bWFwcGluZ3M6IG1hcHBpbmdzLmpvaW4oJztBQUNBJyksXG5cdFx0XHRcdHNvdXJjZVJvb3Q6ICcnLFxuXHRcdFx0XHRzb3VyY2VzOiBbdXJsXVxuXHRcdFx0fTtcblx0XHRcdHZhciBzb3VyY2UgPSBvcHRpb25zLnNvdXJjZSB8fCAhdXJsICYmIGNvZGU7XG5cdFx0XHRpZiAoc291cmNlKVxuXHRcdFx0XHRzb3VyY2VNYXAuc291cmNlc0NvbnRlbnQgPSBbc291cmNlXTtcblx0XHR9XG5cdFx0d2Fsa0FTVChwYXJzZShjb2RlLCB7IHJhbmdlczogdHJ1ZSB9KSk7XG5cdFx0aWYgKHNvdXJjZU1hcCkge1xuXHRcdFx0Y29kZSA9IG5ldyBBcnJheShvZmZzZXQgKyAxKS5qb2luKCdcXG4nKSArIGNvZGVcblx0XHRcdFx0XHQrIFwiXFxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIlxuXHRcdFx0XHRcdCsgKGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KFxuXHRcdFx0XHRcdFx0SlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKSlcblx0XHRcdFx0XHQrIFwiXFxuLy8jIHNvdXJjZVVSTD1cIiArICh1cmwgfHwgJ3BhcGVyc2NyaXB0Jyk7XG5cdFx0fVxuXHRcdHJldHVybiBjb2RlO1xuXHR9XG5cblx0ZnVuY3Rpb24gZXhlY3V0ZShjb2RlLCBzY29wZSwgdXJsLCBvcHRpb25zKSB7XG5cdFx0cGFwZXIgPSBzY29wZTtcblx0XHR2YXIgdmlldyA9IHNjb3BlLmdldFZpZXcoKSxcblx0XHRcdHRvb2wgPSAvXFxzK29uKD86S2V5fE1vdXNlKSg/OlVwfERvd258TW92ZXxEcmFnKVxcYi8udGVzdChjb2RlKVxuXHRcdFx0XHRcdD8gbmV3IFRvb2woKVxuXHRcdFx0XHRcdDogbnVsbCxcblx0XHRcdHRvb2xIYW5kbGVycyA9IHRvb2wgPyB0b29sLl9ldmVudHMgOiBbXSxcblx0XHRcdGhhbmRsZXJzID0gWydvbkZyYW1lJywgJ29uUmVzaXplJ10uY29uY2F0KHRvb2xIYW5kbGVycyksXG5cdFx0XHRwYXJhbXMgPSBbXSxcblx0XHRcdGFyZ3MgPSBbXSxcblx0XHRcdGZ1bmM7XG5cdFx0Y29kZSA9IGNvbXBpbGUoY29kZSwgdXJsLCBvcHRpb25zKTtcblx0XHRmdW5jdGlvbiBleHBvc2Uoc2NvcGUsIGhpZGRlbikge1xuXHRcdFx0Zm9yICh2YXIga2V5IGluIHNjb3BlKSB7XG5cdFx0XHRcdGlmICgoaGlkZGVuIHx8ICEvXl8vLnRlc3Qoa2V5KSkgJiYgbmV3IFJlZ0V4cCgnKFtcXFxcYlxcXFxzXFxcXFddfF4pJ1xuXHRcdFx0XHRcdFx0KyBrZXkucmVwbGFjZSgvXFwkL2csICdcXFxcJCcpICsgJ1xcXFxiJykudGVzdChjb2RlKSkge1xuXHRcdFx0XHRcdHBhcmFtcy5wdXNoKGtleSk7XG5cdFx0XHRcdFx0YXJncy5wdXNoKHNjb3BlW2tleV0pO1xuXHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGV4cG9zZSh7IF9fJF9fOiBfXyRfXywgJF9fOiAkX18sIHBhcGVyOiBzY29wZSwgdmlldzogdmlldywgdG9vbDogdG9vbCB9LFxuXHRcdFx0XHR0cnVlKTtcblx0XHRleHBvc2Uoc2NvcGUpO1xuXHRcdGhhbmRsZXJzID0gQmFzZS5lYWNoKGhhbmRsZXJzLCBmdW5jdGlvbihrZXkpIHtcblx0XHRcdGlmIChuZXcgUmVnRXhwKCdcXFxccysnICsga2V5ICsgJ1xcXFxiJykudGVzdChjb2RlKSkge1xuXHRcdFx0XHRwYXJhbXMucHVzaChrZXkpO1xuXHRcdFx0XHR0aGlzLnB1c2goa2V5ICsgJzogJyArIGtleSk7XG5cdFx0XHR9XG5cdFx0fSwgW10pLmpvaW4oJywgJyk7XG5cdFx0aWYgKGhhbmRsZXJzKVxuXHRcdFx0Y29kZSArPSAnXFxucmV0dXJuIHsgJyArIGhhbmRsZXJzICsgJyB9Oyc7XG5cdFx0dmFyIGJyb3dzZXIgPSBwYXBlci5icm93c2VyO1xuXHRcdGlmIChicm93c2VyLmNocm9tZSB8fCBicm93c2VyLmZpcmVmb3gpIHtcblx0XHRcdHZhciBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdzY3JpcHQnKSxcblx0XHRcdFx0aGVhZCA9IGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ2hlYWQnKVswXTtcblx0XHRcdGlmIChicm93c2VyLmZpcmVmb3gpXG5cdFx0XHRcdGNvZGUgPSAnXFxuJyArIGNvZGU7XG5cdFx0XHRzY3JpcHQuYXBwZW5kQ2hpbGQoZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoXG5cdFx0XHRcdCdwYXBlci5fZXhlY3V0ZSA9IGZ1bmN0aW9uKCcgKyBwYXJhbXMgKyAnKSB7JyArIGNvZGUgKyAnXFxufSdcblx0XHRcdCkpO1xuXHRcdFx0aGVhZC5hcHBlbmRDaGlsZChzY3JpcHQpO1xuXHRcdFx0ZnVuYyA9IHBhcGVyLl9leGVjdXRlO1xuXHRcdFx0ZGVsZXRlIHBhcGVyLl9leGVjdXRlO1xuXHRcdFx0aGVhZC5yZW1vdmVDaGlsZChzY3JpcHQpO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRmdW5jID0gRnVuY3Rpb24ocGFyYW1zLCBjb2RlKTtcblx0XHR9XG5cdFx0dmFyIHJlcyA9IGZ1bmMuYXBwbHkoc2NvcGUsIGFyZ3MpIHx8IHt9O1xuXHRcdEJhc2UuZWFjaCh0b29sSGFuZGxlcnMsIGZ1bmN0aW9uKGtleSkge1xuXHRcdFx0dmFyIHZhbHVlID0gcmVzW2tleV07XG5cdFx0XHRpZiAodmFsdWUpXG5cdFx0XHRcdHRvb2xba2V5XSA9IHZhbHVlO1xuXHRcdH0pO1xuXHRcdGlmICh2aWV3KSB7XG5cdFx0XHRpZiAocmVzLm9uUmVzaXplKVxuXHRcdFx0XHR2aWV3LnNldE9uUmVzaXplKHJlcy5vblJlc2l6ZSk7XG5cdFx0XHR2aWV3LmVtaXQoJ3Jlc2l6ZScsIHtcblx0XHRcdFx0c2l6ZTogdmlldy5zaXplLFxuXHRcdFx0XHRkZWx0YTogbmV3IFBvaW50KClcblx0XHRcdH0pO1xuXHRcdFx0aWYgKHJlcy5vbkZyYW1lKVxuXHRcdFx0XHR2aWV3LnNldE9uRnJhbWUocmVzLm9uRnJhbWUpO1xuXHRcdFx0dmlldy51cGRhdGUoKTtcblx0XHR9XG5cdH1cblxuXHRmdW5jdGlvbiBsb2FkU2NyaXB0KHNjcmlwdCkge1xuXHRcdGlmICgvXnRleHRcXC8oPzp4LXwpcGFwZXJzY3JpcHQkLy50ZXN0KHNjcmlwdC50eXBlKVxuXHRcdFx0XHQmJiBQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShzY3JpcHQsICdpZ25vcmUnKSAhPT0gJ3RydWUnKSB7XG5cdFx0XHR2YXIgY2FudmFzSWQgPSBQYXBlclNjb3BlLmdldEF0dHJpYnV0ZShzY3JpcHQsICdjYW52YXMnKSxcblx0XHRcdFx0Y2FudmFzID0gZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoY2FudmFzSWQpLFxuXHRcdFx0XHRzcmMgPSBzY3JpcHQuc3JjIHx8IHNjcmlwdC5nZXRBdHRyaWJ1dGUoJ2RhdGEtc3JjJyksXG5cdFx0XHRcdGFzeW5jID0gUGFwZXJTY29wZS5oYXNBdHRyaWJ1dGUoc2NyaXB0LCAnYXN5bmMnKSxcblx0XHRcdFx0c2NvcGVBdHRyaWJ1dGUgPSAnZGF0YS1wYXBlci1zY29wZSc7XG5cdFx0XHRpZiAoIWNhbnZhcylcblx0XHRcdFx0dGhyb3cgbmV3IEVycm9yKCdVbmFibGUgdG8gZmluZCBjYW52YXMgd2l0aCBpZCBcIidcblx0XHRcdFx0XHRcdCsgY2FudmFzSWQgKyAnXCInKTtcblx0XHRcdHZhciBzY29wZSA9IFBhcGVyU2NvcGUuZ2V0KGNhbnZhcy5nZXRBdHRyaWJ1dGUoc2NvcGVBdHRyaWJ1dGUpKVxuXHRcdFx0XHRcdFx0fHwgbmV3IFBhcGVyU2NvcGUoKS5zZXR1cChjYW52YXMpO1xuXHRcdFx0Y2FudmFzLnNldEF0dHJpYnV0ZShzY29wZUF0dHJpYnV0ZSwgc2NvcGUuX2lkKTtcblx0XHRcdGlmIChzcmMpIHtcblx0XHRcdFx0SHR0cC5yZXF1ZXN0KCdnZXQnLCBzcmMsIGZ1bmN0aW9uKGNvZGUpIHtcblx0XHRcdFx0XHRleGVjdXRlKGNvZGUsIHNjb3BlLCBzcmMpO1xuXHRcdFx0XHR9LCBhc3luYyk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRleGVjdXRlKHNjcmlwdC5pbm5lckhUTUwsIHNjb3BlLCBzY3JpcHQuYmFzZVVSSSk7XG5cdFx0XHR9XG5cdFx0XHRzY3JpcHQuc2V0QXR0cmlidXRlKCdkYXRhLXBhcGVyLWlnbm9yZScsICd0cnVlJyk7XG5cdFx0XHRyZXR1cm4gc2NvcGU7XG5cdFx0fVxuXHR9XG5cblx0ZnVuY3Rpb24gbG9hZEFsbCgpIHtcblx0XHRCYXNlLmVhY2goZG9jdW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoJ3NjcmlwdCcpLCBsb2FkU2NyaXB0KTtcblx0fVxuXG5cdGZ1bmN0aW9uIGxvYWQoc2NyaXB0KSB7XG5cdFx0cmV0dXJuIHNjcmlwdCA/IGxvYWRTY3JpcHQoc2NyaXB0KSA6IGxvYWRBbGwoKTtcblx0fVxuXG5cdGlmIChkb2N1bWVudC5yZWFkeVN0YXRlID09PSAnY29tcGxldGUnKSB7XG5cdFx0c2V0VGltZW91dChsb2FkQWxsKTtcblx0fSBlbHNlIHtcblx0XHREb21FdmVudC5hZGQod2luZG93LCB7IGxvYWQ6IGxvYWRBbGwgfSk7XG5cdH1cblxuXHRyZXR1cm4ge1xuXHRcdGNvbXBpbGU6IGNvbXBpbGUsXG5cdFx0ZXhlY3V0ZTogZXhlY3V0ZSxcblx0XHRsb2FkOiBsb2FkLFxuXHRcdHBhcnNlOiBwYXJzZVxuXHR9O1xuXG59KS5jYWxsKHRoaXMpO1xuXG5wYXBlciA9IG5ldyAoUGFwZXJTY29wZS5pbmplY3QoQmFzZS5leHBvcnRzLCB7XG5cdGVudW1lcmFibGU6IHRydWUsXG5cdEJhc2U6IEJhc2UsXG5cdE51bWVyaWNhbDogTnVtZXJpY2FsLFxuXHRLZXk6IEtleVxufSkpKCk7XG5cbmlmICh0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpIHtcblx0ZGVmaW5lKCdwYXBlcicsIHBhcGVyKTtcbn0gZWxzZSBpZiAodHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcgJiYgbW9kdWxlKSB7XG5cdG1vZHVsZS5leHBvcnRzID0gcGFwZXI7XG59XG5cbnJldHVybiBwYXBlcjtcbn07XG4iLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxuLy8gcmVzb2x2ZXMgLiBhbmQgLi4gZWxlbWVudHMgaW4gYSBwYXRoIGFycmF5IHdpdGggZGlyZWN0b3J5IG5hbWVzIHRoZXJlXG4vLyBtdXN0IGJlIG5vIHNsYXNoZXMsIGVtcHR5IGVsZW1lbnRzLCBvciBkZXZpY2UgbmFtZXMgKGM6XFwpIGluIHRoZSBhcnJheVxuLy8gKHNvIGFsc28gbm8gbGVhZGluZyBhbmQgdHJhaWxpbmcgc2xhc2hlcyAtIGl0IGRvZXMgbm90IGRpc3Rpbmd1aXNoXG4vLyByZWxhdGl2ZSBhbmQgYWJzb2x1dGUgcGF0aHMpXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheShwYXJ0cywgYWxsb3dBYm92ZVJvb3QpIHtcbiAgLy8gaWYgdGhlIHBhdGggdHJpZXMgdG8gZ28gYWJvdmUgdGhlIHJvb3QsIGB1cGAgZW5kcyB1cCA+IDBcbiAgdmFyIHVwID0gMDtcbiAgZm9yICh2YXIgaSA9IHBhcnRzLmxlbmd0aCAtIDE7IGkgPj0gMDsgaS0tKSB7XG4gICAgdmFyIGxhc3QgPSBwYXJ0c1tpXTtcbiAgICBpZiAobGFzdCA9PT0gJy4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgfSBlbHNlIGlmIChsYXN0ID09PSAnLi4nKSB7XG4gICAgICBwYXJ0cy5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIHBhcnRzLnNwbGljZShpLCAxKTtcbiAgICAgIHVwLS07XG4gICAgfVxuICB9XG5cbiAgLy8gaWYgdGhlIHBhdGggaXMgYWxsb3dlZCB0byBnbyBhYm92ZSB0aGUgcm9vdCwgcmVzdG9yZSBsZWFkaW5nIC4uc1xuICBpZiAoYWxsb3dBYm92ZVJvb3QpIHtcbiAgICBmb3IgKDsgdXAtLTsgdXApIHtcbiAgICAgIHBhcnRzLnVuc2hpZnQoJy4uJyk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBTcGxpdCBhIGZpbGVuYW1lIGludG8gW3Jvb3QsIGRpciwgYmFzZW5hbWUsIGV4dF0sIHVuaXggdmVyc2lvblxuLy8gJ3Jvb3QnIGlzIGp1c3QgYSBzbGFzaCwgb3Igbm90aGluZy5cbnZhciBzcGxpdFBhdGhSZSA9XG4gICAgL14oXFwvP3wpKFtcXHNcXFNdKj8pKCg/OlxcLnsxLDJ9fFteXFwvXSs/fCkoXFwuW14uXFwvXSp8KSkoPzpbXFwvXSopJC87XG52YXIgc3BsaXRQYXRoID0gZnVuY3Rpb24oZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aFJlLmV4ZWMoZmlsZW5hbWUpLnNsaWNlKDEpO1xufTtcblxuLy8gcGF0aC5yZXNvbHZlKFtmcm9tIC4uLl0sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZXNvbHZlID0gZnVuY3Rpb24oKSB7XG4gIHZhciByZXNvbHZlZFBhdGggPSAnJyxcbiAgICAgIHJlc29sdmVkQWJzb2x1dGUgPSBmYWxzZTtcblxuICBmb3IgKHZhciBpID0gYXJndW1lbnRzLmxlbmd0aCAtIDE7IGkgPj0gLTEgJiYgIXJlc29sdmVkQWJzb2x1dGU7IGktLSkge1xuICAgIHZhciBwYXRoID0gKGkgPj0gMCkgPyBhcmd1bWVudHNbaV0gOiBwcm9jZXNzLmN3ZCgpO1xuXG4gICAgLy8gU2tpcCBlbXB0eSBhbmQgaW52YWxpZCBlbnRyaWVzXG4gICAgaWYgKHR5cGVvZiBwYXRoICE9PSAnc3RyaW5nJykge1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJndW1lbnRzIHRvIHBhdGgucmVzb2x2ZSBtdXN0IGJlIHN0cmluZ3MnKTtcbiAgICB9IGVsc2UgaWYgKCFwYXRoKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG5cbiAgICByZXNvbHZlZFBhdGggPSBwYXRoICsgJy8nICsgcmVzb2x2ZWRQYXRoO1xuICAgIHJlc29sdmVkQWJzb2x1dGUgPSBwYXRoLmNoYXJBdCgwKSA9PT0gJy8nO1xuICB9XG5cbiAgLy8gQXQgdGhpcyBwb2ludCB0aGUgcGF0aCBzaG91bGQgYmUgcmVzb2x2ZWQgdG8gYSBmdWxsIGFic29sdXRlIHBhdGgsIGJ1dFxuICAvLyBoYW5kbGUgcmVsYXRpdmUgcGF0aHMgdG8gYmUgc2FmZSAobWlnaHQgaGFwcGVuIHdoZW4gcHJvY2Vzcy5jd2QoKSBmYWlscylcblxuICAvLyBOb3JtYWxpemUgdGhlIHBhdGhcbiAgcmVzb2x2ZWRQYXRoID0gbm9ybWFsaXplQXJyYXkoZmlsdGVyKHJlc29sdmVkUGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFyZXNvbHZlZEFic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgcmV0dXJuICgocmVzb2x2ZWRBYnNvbHV0ZSA/ICcvJyA6ICcnKSArIHJlc29sdmVkUGF0aCkgfHwgJy4nO1xufTtcblxuLy8gcGF0aC5ub3JtYWxpemUocGF0aClcbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMubm9ybWFsaXplID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgaXNBYnNvbHV0ZSA9IGV4cG9ydHMuaXNBYnNvbHV0ZShwYXRoKSxcbiAgICAgIHRyYWlsaW5nU2xhc2ggPSBzdWJzdHIocGF0aCwgLTEpID09PSAnLyc7XG5cbiAgLy8gTm9ybWFsaXplIHRoZSBwYXRoXG4gIHBhdGggPSBub3JtYWxpemVBcnJheShmaWx0ZXIocGF0aC5zcGxpdCgnLycpLCBmdW5jdGlvbihwKSB7XG4gICAgcmV0dXJuICEhcDtcbiAgfSksICFpc0Fic29sdXRlKS5qb2luKCcvJyk7XG5cbiAgaWYgKCFwYXRoICYmICFpc0Fic29sdXRlKSB7XG4gICAgcGF0aCA9ICcuJztcbiAgfVxuICBpZiAocGF0aCAmJiB0cmFpbGluZ1NsYXNoKSB7XG4gICAgcGF0aCArPSAnLyc7XG4gIH1cblxuICByZXR1cm4gKGlzQWJzb2x1dGUgPyAnLycgOiAnJykgKyBwYXRoO1xufTtcblxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5pc0Fic29sdXRlID0gZnVuY3Rpb24ocGF0aCkge1xuICByZXR1cm4gcGF0aC5jaGFyQXQoMCkgPT09ICcvJztcbn07XG5cbi8vIHBvc2l4IHZlcnNpb25cbmV4cG9ydHMuam9pbiA9IGZ1bmN0aW9uKCkge1xuICB2YXIgcGF0aHMgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChhcmd1bWVudHMsIDApO1xuICByZXR1cm4gZXhwb3J0cy5ub3JtYWxpemUoZmlsdGVyKHBhdGhzLCBmdW5jdGlvbihwLCBpbmRleCkge1xuICAgIGlmICh0eXBlb2YgcCAhPT0gJ3N0cmluZycpIHtcbiAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ0FyZ3VtZW50cyB0byBwYXRoLmpvaW4gbXVzdCBiZSBzdHJpbmdzJyk7XG4gICAgfVxuICAgIHJldHVybiBwO1xuICB9KS5qb2luKCcvJykpO1xufTtcblxuXG4vLyBwYXRoLnJlbGF0aXZlKGZyb20sIHRvKVxuLy8gcG9zaXggdmVyc2lvblxuZXhwb3J0cy5yZWxhdGl2ZSA9IGZ1bmN0aW9uKGZyb20sIHRvKSB7XG4gIGZyb20gPSBleHBvcnRzLnJlc29sdmUoZnJvbSkuc3Vic3RyKDEpO1xuICB0byA9IGV4cG9ydHMucmVzb2x2ZSh0bykuc3Vic3RyKDEpO1xuXG4gIGZ1bmN0aW9uIHRyaW0oYXJyKSB7XG4gICAgdmFyIHN0YXJ0ID0gMDtcbiAgICBmb3IgKDsgc3RhcnQgPCBhcnIubGVuZ3RoOyBzdGFydCsrKSB7XG4gICAgICBpZiAoYXJyW3N0YXJ0XSAhPT0gJycpIGJyZWFrO1xuICAgIH1cblxuICAgIHZhciBlbmQgPSBhcnIubGVuZ3RoIC0gMTtcbiAgICBmb3IgKDsgZW5kID49IDA7IGVuZC0tKSB7XG4gICAgICBpZiAoYXJyW2VuZF0gIT09ICcnKSBicmVhaztcbiAgICB9XG5cbiAgICBpZiAoc3RhcnQgPiBlbmQpIHJldHVybiBbXTtcbiAgICByZXR1cm4gYXJyLnNsaWNlKHN0YXJ0LCBlbmQgLSBzdGFydCArIDEpO1xuICB9XG5cbiAgdmFyIGZyb21QYXJ0cyA9IHRyaW0oZnJvbS5zcGxpdCgnLycpKTtcbiAgdmFyIHRvUGFydHMgPSB0cmltKHRvLnNwbGl0KCcvJykpO1xuXG4gIHZhciBsZW5ndGggPSBNYXRoLm1pbihmcm9tUGFydHMubGVuZ3RoLCB0b1BhcnRzLmxlbmd0aCk7XG4gIHZhciBzYW1lUGFydHNMZW5ndGggPSBsZW5ndGg7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICBpZiAoZnJvbVBhcnRzW2ldICE9PSB0b1BhcnRzW2ldKSB7XG4gICAgICBzYW1lUGFydHNMZW5ndGggPSBpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG5cbiAgdmFyIG91dHB1dFBhcnRzID0gW107XG4gIGZvciAodmFyIGkgPSBzYW1lUGFydHNMZW5ndGg7IGkgPCBmcm9tUGFydHMubGVuZ3RoOyBpKyspIHtcbiAgICBvdXRwdXRQYXJ0cy5wdXNoKCcuLicpO1xuICB9XG5cbiAgb3V0cHV0UGFydHMgPSBvdXRwdXRQYXJ0cy5jb25jYXQodG9QYXJ0cy5zbGljZShzYW1lUGFydHNMZW5ndGgpKTtcblxuICByZXR1cm4gb3V0cHV0UGFydHMuam9pbignLycpO1xufTtcblxuZXhwb3J0cy5zZXAgPSAnLyc7XG5leHBvcnRzLmRlbGltaXRlciA9ICc6JztcblxuZXhwb3J0cy5kaXJuYW1lID0gZnVuY3Rpb24ocGF0aCkge1xuICB2YXIgcmVzdWx0ID0gc3BsaXRQYXRoKHBhdGgpLFxuICAgICAgcm9vdCA9IHJlc3VsdFswXSxcbiAgICAgIGRpciA9IHJlc3VsdFsxXTtcblxuICBpZiAoIXJvb3QgJiYgIWRpcikge1xuICAgIC8vIE5vIGRpcm5hbWUgd2hhdHNvZXZlclxuICAgIHJldHVybiAnLic7XG4gIH1cblxuICBpZiAoZGlyKSB7XG4gICAgLy8gSXQgaGFzIGEgZGlybmFtZSwgc3RyaXAgdHJhaWxpbmcgc2xhc2hcbiAgICBkaXIgPSBkaXIuc3Vic3RyKDAsIGRpci5sZW5ndGggLSAxKTtcbiAgfVxuXG4gIHJldHVybiByb290ICsgZGlyO1xufTtcblxuXG5leHBvcnRzLmJhc2VuYW1lID0gZnVuY3Rpb24ocGF0aCwgZXh0KSB7XG4gIHZhciBmID0gc3BsaXRQYXRoKHBhdGgpWzJdO1xuICAvLyBUT0RPOiBtYWtlIHRoaXMgY29tcGFyaXNvbiBjYXNlLWluc2Vuc2l0aXZlIG9uIHdpbmRvd3M/XG4gIGlmIChleHQgJiYgZi5zdWJzdHIoLTEgKiBleHQubGVuZ3RoKSA9PT0gZXh0KSB7XG4gICAgZiA9IGYuc3Vic3RyKDAsIGYubGVuZ3RoIC0gZXh0Lmxlbmd0aCk7XG4gIH1cbiAgcmV0dXJuIGY7XG59O1xuXG5cbmV4cG9ydHMuZXh0bmFtZSA9IGZ1bmN0aW9uKHBhdGgpIHtcbiAgcmV0dXJuIHNwbGl0UGF0aChwYXRoKVszXTtcbn07XG5cbmZ1bmN0aW9uIGZpbHRlciAoeHMsIGYpIHtcbiAgICBpZiAoeHMuZmlsdGVyKSByZXR1cm4geHMuZmlsdGVyKGYpO1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChmKHhzW2ldLCBpLCB4cykpIHJlcy5wdXNoKHhzW2ldKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlcztcbn1cblxuLy8gU3RyaW5nLnByb3RvdHlwZS5zdWJzdHIgLSBuZWdhdGl2ZSBpbmRleCBkb24ndCB3b3JrIGluIElFOFxudmFyIHN1YnN0ciA9ICdhYicuc3Vic3RyKC0xKSA9PT0gJ2InXG4gICAgPyBmdW5jdGlvbiAoc3RyLCBzdGFydCwgbGVuKSB7IHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pIH1cbiAgICA6IGZ1bmN0aW9uIChzdHIsIHN0YXJ0LCBsZW4pIHtcbiAgICAgICAgaWYgKHN0YXJ0IDwgMCkgc3RhcnQgPSBzdHIubGVuZ3RoICsgc3RhcnQ7XG4gICAgICAgIHJldHVybiBzdHIuc3Vic3RyKHN0YXJ0LCBsZW4pO1xuICAgIH1cbjtcbiIsIi8vICAgICBVbmRlcnNjb3JlLmpzIDEuOC4zXG4vLyAgICAgaHR0cDovL3VuZGVyc2NvcmVqcy5vcmdcbi8vICAgICAoYykgMjAwOS0yMDE1IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXG4vLyAgICAgVW5kZXJzY29yZSBtYXkgYmUgZnJlZWx5IGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBNSVQgbGljZW5zZS5cblxuKGZ1bmN0aW9uKCkge1xuXG4gIC8vIEJhc2VsaW5lIHNldHVwXG4gIC8vIC0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRXN0YWJsaXNoIHRoZSByb290IG9iamVjdCwgYHdpbmRvd2AgaW4gdGhlIGJyb3dzZXIsIG9yIGBleHBvcnRzYCBvbiB0aGUgc2VydmVyLlxuICB2YXIgcm9vdCA9IHRoaXM7XG5cbiAgLy8gU2F2ZSB0aGUgcHJldmlvdXMgdmFsdWUgb2YgdGhlIGBfYCB2YXJpYWJsZS5cbiAgdmFyIHByZXZpb3VzVW5kZXJzY29yZSA9IHJvb3QuXztcblxuICAvLyBTYXZlIGJ5dGVzIGluIHRoZSBtaW5pZmllZCAoYnV0IG5vdCBnemlwcGVkKSB2ZXJzaW9uOlxuICB2YXIgQXJyYXlQcm90byA9IEFycmF5LnByb3RvdHlwZSwgT2JqUHJvdG8gPSBPYmplY3QucHJvdG90eXBlLCBGdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGU7XG5cbiAgLy8gQ3JlYXRlIHF1aWNrIHJlZmVyZW5jZSB2YXJpYWJsZXMgZm9yIHNwZWVkIGFjY2VzcyB0byBjb3JlIHByb3RvdHlwZXMuXG4gIHZhclxuICAgIHB1c2ggICAgICAgICAgICAgPSBBcnJheVByb3RvLnB1c2gsXG4gICAgc2xpY2UgICAgICAgICAgICA9IEFycmF5UHJvdG8uc2xpY2UsXG4gICAgdG9TdHJpbmcgICAgICAgICA9IE9ialByb3RvLnRvU3RyaW5nLFxuICAgIGhhc093blByb3BlcnR5ICAgPSBPYmpQcm90by5oYXNPd25Qcm9wZXJ0eTtcblxuICAvLyBBbGwgKipFQ01BU2NyaXB0IDUqKiBuYXRpdmUgZnVuY3Rpb24gaW1wbGVtZW50YXRpb25zIHRoYXQgd2UgaG9wZSB0byB1c2VcbiAgLy8gYXJlIGRlY2xhcmVkIGhlcmUuXG4gIHZhclxuICAgIG5hdGl2ZUlzQXJyYXkgICAgICA9IEFycmF5LmlzQXJyYXksXG4gICAgbmF0aXZlS2V5cyAgICAgICAgID0gT2JqZWN0LmtleXMsXG4gICAgbmF0aXZlQmluZCAgICAgICAgID0gRnVuY1Byb3RvLmJpbmQsXG4gICAgbmF0aXZlQ3JlYXRlICAgICAgID0gT2JqZWN0LmNyZWF0ZTtcblxuICAvLyBOYWtlZCBmdW5jdGlvbiByZWZlcmVuY2UgZm9yIHN1cnJvZ2F0ZS1wcm90b3R5cGUtc3dhcHBpbmcuXG4gIHZhciBDdG9yID0gZnVuY3Rpb24oKXt9O1xuXG4gIC8vIENyZWF0ZSBhIHNhZmUgcmVmZXJlbmNlIHRvIHRoZSBVbmRlcnNjb3JlIG9iamVjdCBmb3IgdXNlIGJlbG93LlxuICB2YXIgXyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmIChvYmogaW5zdGFuY2VvZiBfKSByZXR1cm4gb2JqO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBfKSkgcmV0dXJuIG5ldyBfKG9iaik7XG4gICAgdGhpcy5fd3JhcHBlZCA9IG9iajtcbiAgfTtcblxuICAvLyBFeHBvcnQgdGhlIFVuZGVyc2NvcmUgb2JqZWN0IGZvciAqKk5vZGUuanMqKiwgd2l0aFxuICAvLyBiYWNrd2FyZHMtY29tcGF0aWJpbGl0eSBmb3IgdGhlIG9sZCBgcmVxdWlyZSgpYCBBUEkuIElmIHdlJ3JlIGluXG4gIC8vIHRoZSBicm93c2VyLCBhZGQgYF9gIGFzIGEgZ2xvYmFsIG9iamVjdC5cbiAgaWYgKHR5cGVvZiBleHBvcnRzICE9PSAndW5kZWZpbmVkJykge1xuICAgIGlmICh0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyAmJiBtb2R1bGUuZXhwb3J0cykge1xuICAgICAgZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gXztcbiAgICB9XG4gICAgZXhwb3J0cy5fID0gXztcbiAgfSBlbHNlIHtcbiAgICByb290Ll8gPSBfO1xuICB9XG5cbiAgLy8gQ3VycmVudCB2ZXJzaW9uLlxuICBfLlZFUlNJT04gPSAnMS44LjMnO1xuXG4gIC8vIEludGVybmFsIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhbiBlZmZpY2llbnQgKGZvciBjdXJyZW50IGVuZ2luZXMpIHZlcnNpb25cbiAgLy8gb2YgdGhlIHBhc3NlZC1pbiBjYWxsYmFjaywgdG8gYmUgcmVwZWF0ZWRseSBhcHBsaWVkIGluIG90aGVyIFVuZGVyc2NvcmVcbiAgLy8gZnVuY3Rpb25zLlxuICB2YXIgb3B0aW1pemVDYiA9IGZ1bmN0aW9uKGZ1bmMsIGNvbnRleHQsIGFyZ0NvdW50KSB7XG4gICAgaWYgKGNvbnRleHQgPT09IHZvaWQgMCkgcmV0dXJuIGZ1bmM7XG4gICAgc3dpdGNoIChhcmdDb3VudCA9PSBudWxsID8gMyA6IGFyZ0NvdW50KSB7XG4gICAgICBjYXNlIDE6IHJldHVybiBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlKTtcbiAgICAgIH07XG4gICAgICBjYXNlIDI6IHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuY2FsbChjb250ZXh0LCB2YWx1ZSwgb3RoZXIpO1xuICAgICAgfTtcbiAgICAgIGNhc2UgMzogcmV0dXJuIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbik7XG4gICAgICB9O1xuICAgICAgY2FzZSA0OiByZXR1cm4gZnVuY3Rpb24oYWNjdW11bGF0b3IsIHZhbHVlLCBpbmRleCwgY29sbGVjdGlvbikge1xuICAgICAgICByZXR1cm4gZnVuYy5jYWxsKGNvbnRleHQsIGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgsIGNvbGxlY3Rpb24pO1xuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGZ1bmN0aW9uKCkge1xuICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkoY29udGV4dCwgYXJndW1lbnRzKTtcbiAgICB9O1xuICB9O1xuXG4gIC8vIEEgbW9zdGx5LWludGVybmFsIGZ1bmN0aW9uIHRvIGdlbmVyYXRlIGNhbGxiYWNrcyB0aGF0IGNhbiBiZSBhcHBsaWVkXG4gIC8vIHRvIGVhY2ggZWxlbWVudCBpbiBhIGNvbGxlY3Rpb24sIHJldHVybmluZyB0aGUgZGVzaXJlZCByZXN1bHQg4oCUIGVpdGhlclxuICAvLyBpZGVudGl0eSwgYW4gYXJiaXRyYXJ5IGNhbGxiYWNrLCBhIHByb3BlcnR5IG1hdGNoZXIsIG9yIGEgcHJvcGVydHkgYWNjZXNzb3IuXG4gIHZhciBjYiA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0LCBhcmdDb3VudCkge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gXy5pZGVudGl0eTtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKHZhbHVlKSkgcmV0dXJuIG9wdGltaXplQ2IodmFsdWUsIGNvbnRleHQsIGFyZ0NvdW50KTtcbiAgICBpZiAoXy5pc09iamVjdCh2YWx1ZSkpIHJldHVybiBfLm1hdGNoZXIodmFsdWUpO1xuICAgIHJldHVybiBfLnByb3BlcnR5KHZhbHVlKTtcbiAgfTtcbiAgXy5pdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIGNiKHZhbHVlLCBjb250ZXh0LCBJbmZpbml0eSk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGFzc2lnbmVyIGZ1bmN0aW9ucy5cbiAgdmFyIGNyZWF0ZUFzc2lnbmVyID0gZnVuY3Rpb24oa2V5c0Z1bmMsIHVuZGVmaW5lZE9ubHkpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqKSB7XG4gICAgICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICAgIGlmIChsZW5ndGggPCAyIHx8IG9iaiA9PSBudWxsKSByZXR1cm4gb2JqO1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAxOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2luZGV4XSxcbiAgICAgICAgICAgIGtleXMgPSBrZXlzRnVuYyhzb3VyY2UpLFxuICAgICAgICAgICAgbCA9IGtleXMubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgIGlmICghdW5kZWZpbmVkT25seSB8fCBvYmpba2V5XSA9PT0gdm9pZCAwKSBvYmpba2V5XSA9IHNvdXJjZVtrZXldO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gb2JqO1xuICAgIH07XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gZm9yIGNyZWF0aW5nIGEgbmV3IG9iamVjdCB0aGF0IGluaGVyaXRzIGZyb20gYW5vdGhlci5cbiAgdmFyIGJhc2VDcmVhdGUgPSBmdW5jdGlvbihwcm90b3R5cGUpIHtcbiAgICBpZiAoIV8uaXNPYmplY3QocHJvdG90eXBlKSkgcmV0dXJuIHt9O1xuICAgIGlmIChuYXRpdmVDcmVhdGUpIHJldHVybiBuYXRpdmVDcmVhdGUocHJvdG90eXBlKTtcbiAgICBDdG9yLnByb3RvdHlwZSA9IHByb3RvdHlwZTtcbiAgICB2YXIgcmVzdWx0ID0gbmV3IEN0b3I7XG4gICAgQ3Rvci5wcm90b3R5cGUgPSBudWxsO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgdmFyIHByb3BlcnR5ID0gZnVuY3Rpb24oa2V5KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiA9PSBudWxsID8gdm9pZCAwIDogb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBIZWxwZXIgZm9yIGNvbGxlY3Rpb24gbWV0aG9kcyB0byBkZXRlcm1pbmUgd2hldGhlciBhIGNvbGxlY3Rpb25cbiAgLy8gc2hvdWxkIGJlIGl0ZXJhdGVkIGFzIGFuIGFycmF5IG9yIGFzIGFuIG9iamVjdFxuICAvLyBSZWxhdGVkOiBodHRwOi8vcGVvcGxlLm1vemlsbGEub3JnL35qb3JlbmRvcmZmL2VzNi1kcmFmdC5odG1sI3NlYy10b2xlbmd0aFxuICAvLyBBdm9pZHMgYSB2ZXJ5IG5hc3R5IGlPUyA4IEpJVCBidWcgb24gQVJNLTY0LiAjMjA5NFxuICB2YXIgTUFYX0FSUkFZX0lOREVYID0gTWF0aC5wb3coMiwgNTMpIC0gMTtcbiAgdmFyIGdldExlbmd0aCA9IHByb3BlcnR5KCdsZW5ndGgnKTtcbiAgdmFyIGlzQXJyYXlMaWtlID0gZnVuY3Rpb24oY29sbGVjdGlvbikge1xuICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoY29sbGVjdGlvbik7XG4gICAgcmV0dXJuIHR5cGVvZiBsZW5ndGggPT0gJ251bWJlcicgJiYgbGVuZ3RoID49IDAgJiYgbGVuZ3RoIDw9IE1BWF9BUlJBWV9JTkRFWDtcbiAgfTtcblxuICAvLyBDb2xsZWN0aW9uIEZ1bmN0aW9uc1xuICAvLyAtLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIFRoZSBjb3JuZXJzdG9uZSwgYW4gYGVhY2hgIGltcGxlbWVudGF0aW9uLCBha2EgYGZvckVhY2hgLlxuICAvLyBIYW5kbGVzIHJhdyBvYmplY3RzIGluIGFkZGl0aW9uIHRvIGFycmF5LWxpa2VzLiBUcmVhdHMgYWxsXG4gIC8vIHNwYXJzZSBhcnJheS1saWtlcyBhcyBpZiB0aGV5IHdlcmUgZGVuc2UuXG4gIF8uZWFjaCA9IF8uZm9yRWFjaCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBpLCBsZW5ndGg7XG4gICAgaWYgKGlzQXJyYXlMaWtlKG9iaikpIHtcbiAgICAgIGZvciAoaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICBpdGVyYXRlZShvYmpbaV0sIGksIG9iaik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgICBmb3IgKGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGl0ZXJhdGVlKG9ialtrZXlzW2ldXSwga2V5c1tpXSwgb2JqKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudC5cbiAgXy5tYXAgPSBfLmNvbGxlY3QgPSBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgIHJlc3VsdHMgPSBBcnJheShsZW5ndGgpO1xuICAgIGZvciAodmFyIGluZGV4ID0gMDsgaW5kZXggPCBsZW5ndGg7IGluZGV4KyspIHtcbiAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICByZXN1bHRzW2luZGV4XSA9IGl0ZXJhdGVlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdHM7XG4gIH07XG5cbiAgLy8gQ3JlYXRlIGEgcmVkdWNpbmcgZnVuY3Rpb24gaXRlcmF0aW5nIGxlZnQgb3IgcmlnaHQuXG4gIGZ1bmN0aW9uIGNyZWF0ZVJlZHVjZShkaXIpIHtcbiAgICAvLyBPcHRpbWl6ZWQgaXRlcmF0b3IgZnVuY3Rpb24gYXMgdXNpbmcgYXJndW1lbnRzLmxlbmd0aFxuICAgIC8vIGluIHRoZSBtYWluIGZ1bmN0aW9uIHdpbGwgZGVvcHRpbWl6ZSB0aGUsIHNlZSAjMTk5MS5cbiAgICBmdW5jdGlvbiBpdGVyYXRvcihvYmosIGl0ZXJhdGVlLCBtZW1vLCBrZXlzLCBpbmRleCwgbGVuZ3RoKSB7XG4gICAgICBmb3IgKDsgaW5kZXggPj0gMCAmJiBpbmRleCA8IGxlbmd0aDsgaW5kZXggKz0gZGlyKSB7XG4gICAgICAgIHZhciBjdXJyZW50S2V5ID0ga2V5cyA/IGtleXNbaW5kZXhdIDogaW5kZXg7XG4gICAgICAgIG1lbW8gPSBpdGVyYXRlZShtZW1vLCBvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbWVtbztcbiAgICB9XG5cbiAgICByZXR1cm4gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgbWVtbywgY29udGV4dCkge1xuICAgICAgaXRlcmF0ZWUgPSBvcHRpbWl6ZUNiKGl0ZXJhdGVlLCBjb250ZXh0LCA0KTtcbiAgICAgIHZhciBrZXlzID0gIWlzQXJyYXlMaWtlKG9iaikgJiYgXy5rZXlzKG9iaiksXG4gICAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGgsXG4gICAgICAgICAgaW5kZXggPSBkaXIgPiAwID8gMCA6IGxlbmd0aCAtIDE7XG4gICAgICAvLyBEZXRlcm1pbmUgdGhlIGluaXRpYWwgdmFsdWUgaWYgbm9uZSBpcyBwcm92aWRlZC5cbiAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoIDwgMykge1xuICAgICAgICBtZW1vID0gb2JqW2tleXMgPyBrZXlzW2luZGV4XSA6IGluZGV4XTtcbiAgICAgICAgaW5kZXggKz0gZGlyO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGl0ZXJhdG9yKG9iaiwgaXRlcmF0ZWUsIG1lbW8sIGtleXMsIGluZGV4LCBsZW5ndGgpO1xuICAgIH07XG4gIH1cblxuICAvLyAqKlJlZHVjZSoqIGJ1aWxkcyB1cCBhIHNpbmdsZSByZXN1bHQgZnJvbSBhIGxpc3Qgb2YgdmFsdWVzLCBha2EgYGluamVjdGAsXG4gIC8vIG9yIGBmb2xkbGAuXG4gIF8ucmVkdWNlID0gXy5mb2xkbCA9IF8uaW5qZWN0ID0gY3JlYXRlUmVkdWNlKDEpO1xuXG4gIC8vIFRoZSByaWdodC1hc3NvY2lhdGl2ZSB2ZXJzaW9uIG9mIHJlZHVjZSwgYWxzbyBrbm93biBhcyBgZm9sZHJgLlxuICBfLnJlZHVjZVJpZ2h0ID0gXy5mb2xkciA9IGNyZWF0ZVJlZHVjZSgtMSk7XG5cbiAgLy8gUmV0dXJuIHRoZSBmaXJzdCB2YWx1ZSB3aGljaCBwYXNzZXMgYSB0cnV0aCB0ZXN0LiBBbGlhc2VkIGFzIGBkZXRlY3RgLlxuICBfLmZpbmQgPSBfLmRldGVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIGtleTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkge1xuICAgICAga2V5ID0gXy5maW5kSW5kZXgob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBrZXkgPSBfLmZpbmRLZXkob2JqLCBwcmVkaWNhdGUsIGNvbnRleHQpO1xuICAgIH1cbiAgICBpZiAoa2V5ICE9PSB2b2lkIDAgJiYga2V5ICE9PSAtMSkgcmV0dXJuIG9ialtrZXldO1xuICB9O1xuXG4gIC8vIFJldHVybiBhbGwgdGhlIGVsZW1lbnRzIHRoYXQgcGFzcyBhIHRydXRoIHRlc3QuXG4gIC8vIEFsaWFzZWQgYXMgYHNlbGVjdGAuXG4gIF8uZmlsdGVyID0gXy5zZWxlY3QgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHRzID0gW107XG4gICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgIGlmIChwcmVkaWNhdGUodmFsdWUsIGluZGV4LCBsaXN0KSkgcmVzdWx0cy5wdXNoKHZhbHVlKTtcbiAgICB9KTtcbiAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBSZXR1cm4gYWxsIHRoZSBlbGVtZW50cyBmb3Igd2hpY2ggYSB0cnV0aCB0ZXN0IGZhaWxzLlxuICBfLnJlamVjdCA9IGZ1bmN0aW9uKG9iaiwgcHJlZGljYXRlLCBjb250ZXh0KSB7XG4gICAgcmV0dXJuIF8uZmlsdGVyKG9iaiwgXy5uZWdhdGUoY2IocHJlZGljYXRlKSksIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIERldGVybWluZSB3aGV0aGVyIGFsbCBvZiB0aGUgZWxlbWVudHMgbWF0Y2ggYSB0cnV0aCB0ZXN0LlxuICAvLyBBbGlhc2VkIGFzIGBhbGxgLlxuICBfLmV2ZXJ5ID0gXy5hbGwgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmICghcHJlZGljYXRlKG9ialtjdXJyZW50S2V5XSwgY3VycmVudEtleSwgb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuICAvLyBEZXRlcm1pbmUgaWYgYXQgbGVhc3Qgb25lIGVsZW1lbnQgaW4gdGhlIG9iamVjdCBtYXRjaGVzIGEgdHJ1dGggdGVzdC5cbiAgLy8gQWxpYXNlZCBhcyBgYW55YC5cbiAgXy5zb21lID0gXy5hbnkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSAhaXNBcnJheUxpa2Uob2JqKSAmJiBfLmtleXMob2JqKSxcbiAgICAgICAgbGVuZ3RoID0gKGtleXMgfHwgb2JqKS5sZW5ndGg7XG4gICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgdmFyIGN1cnJlbnRLZXkgPSBrZXlzID8ga2V5c1tpbmRleF0gOiBpbmRleDtcbiAgICAgIGlmIChwcmVkaWNhdGUob2JqW2N1cnJlbnRLZXldLCBjdXJyZW50S2V5LCBvYmopKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9O1xuXG4gIC8vIERldGVybWluZSBpZiB0aGUgYXJyYXkgb3Igb2JqZWN0IGNvbnRhaW5zIGEgZ2l2ZW4gaXRlbSAodXNpbmcgYD09PWApLlxuICAvLyBBbGlhc2VkIGFzIGBpbmNsdWRlc2AgYW5kIGBpbmNsdWRlYC5cbiAgXy5jb250YWlucyA9IF8uaW5jbHVkZXMgPSBfLmluY2x1ZGUgPSBmdW5jdGlvbihvYmosIGl0ZW0sIGZyb21JbmRleCwgZ3VhcmQpIHtcbiAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgaWYgKHR5cGVvZiBmcm9tSW5kZXggIT0gJ251bWJlcicgfHwgZ3VhcmQpIGZyb21JbmRleCA9IDA7XG4gICAgcmV0dXJuIF8uaW5kZXhPZihvYmosIGl0ZW0sIGZyb21JbmRleCkgPj0gMDtcbiAgfTtcblxuICAvLyBJbnZva2UgYSBtZXRob2QgKHdpdGggYXJndW1lbnRzKSBvbiBldmVyeSBpdGVtIGluIGEgY29sbGVjdGlvbi5cbiAgXy5pbnZva2UgPSBmdW5jdGlvbihvYmosIG1ldGhvZCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHZhciBpc0Z1bmMgPSBfLmlzRnVuY3Rpb24obWV0aG9kKTtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgdmFyIGZ1bmMgPSBpc0Z1bmMgPyBtZXRob2QgOiB2YWx1ZVttZXRob2RdO1xuICAgICAgcmV0dXJuIGZ1bmMgPT0gbnVsbCA/IGZ1bmMgOiBmdW5jLmFwcGx5KHZhbHVlLCBhcmdzKTtcbiAgICB9KTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBtYXBgOiBmZXRjaGluZyBhIHByb3BlcnR5LlxuICBfLnBsdWNrID0gZnVuY3Rpb24ob2JqLCBrZXkpIHtcbiAgICByZXR1cm4gXy5tYXAob2JqLCBfLnByb3BlcnR5KGtleSkpO1xuICB9O1xuXG4gIC8vIENvbnZlbmllbmNlIHZlcnNpb24gb2YgYSBjb21tb24gdXNlIGNhc2Ugb2YgYGZpbHRlcmA6IHNlbGVjdGluZyBvbmx5IG9iamVjdHNcbiAgLy8gY29udGFpbmluZyBzcGVjaWZpYyBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy53aGVyZSA9IGZ1bmN0aW9uKG9iaiwgYXR0cnMpIHtcbiAgICByZXR1cm4gXy5maWx0ZXIob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBDb252ZW5pZW5jZSB2ZXJzaW9uIG9mIGEgY29tbW9uIHVzZSBjYXNlIG9mIGBmaW5kYDogZ2V0dGluZyB0aGUgZmlyc3Qgb2JqZWN0XG4gIC8vIGNvbnRhaW5pbmcgc3BlY2lmaWMgYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8uZmluZFdoZXJlID0gZnVuY3Rpb24ob2JqLCBhdHRycykge1xuICAgIHJldHVybiBfLmZpbmQob2JqLCBfLm1hdGNoZXIoYXR0cnMpKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gdGhlIG1heGltdW0gZWxlbWVudCAob3IgZWxlbWVudC1iYXNlZCBjb21wdXRhdGlvbikuXG4gIF8ubWF4ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSAtSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IC1JbmZpbml0eSxcbiAgICAgICAgdmFsdWUsIGNvbXB1dGVkO1xuICAgIGlmIChpdGVyYXRlZSA9PSBudWxsICYmIG9iaiAhPSBudWxsKSB7XG4gICAgICBvYmogPSBpc0FycmF5TGlrZShvYmopID8gb2JqIDogXy52YWx1ZXMob2JqKTtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBvYmoubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFsdWUgPSBvYmpbaV07XG4gICAgICAgIGlmICh2YWx1ZSA+IHJlc3VsdCkge1xuICAgICAgICAgIHJlc3VsdCA9IHZhbHVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgICAgXy5lYWNoKG9iaiwgZnVuY3Rpb24odmFsdWUsIGluZGV4LCBsaXN0KSB7XG4gICAgICAgIGNvbXB1dGVkID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBsaXN0KTtcbiAgICAgICAgaWYgKGNvbXB1dGVkID4gbGFzdENvbXB1dGVkIHx8IGNvbXB1dGVkID09PSAtSW5maW5pdHkgJiYgcmVzdWx0ID09PSAtSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBtaW5pbXVtIGVsZW1lbnQgKG9yIGVsZW1lbnQtYmFzZWQgY29tcHV0YXRpb24pLlxuICBfLm1pbiA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICB2YXIgcmVzdWx0ID0gSW5maW5pdHksIGxhc3RDb21wdXRlZCA9IEluZmluaXR5LFxuICAgICAgICB2YWx1ZSwgY29tcHV0ZWQ7XG4gICAgaWYgKGl0ZXJhdGVlID09IG51bGwgJiYgb2JqICE9IG51bGwpIHtcbiAgICAgIG9iaiA9IGlzQXJyYXlMaWtlKG9iaikgPyBvYmogOiBfLnZhbHVlcyhvYmopO1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IG9iai5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICB2YWx1ZSA9IG9ialtpXTtcbiAgICAgICAgaWYgKHZhbHVlIDwgcmVzdWx0KSB7XG4gICAgICAgICAgcmVzdWx0ID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgICBfLmVhY2gob2JqLCBmdW5jdGlvbih2YWx1ZSwgaW5kZXgsIGxpc3QpIHtcbiAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpO1xuICAgICAgICBpZiAoY29tcHV0ZWQgPCBsYXN0Q29tcHV0ZWQgfHwgY29tcHV0ZWQgPT09IEluZmluaXR5ICYmIHJlc3VsdCA9PT0gSW5maW5pdHkpIHtcbiAgICAgICAgICByZXN1bHQgPSB2YWx1ZTtcbiAgICAgICAgICBsYXN0Q29tcHV0ZWQgPSBjb21wdXRlZDtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gU2h1ZmZsZSBhIGNvbGxlY3Rpb24sIHVzaW5nIHRoZSBtb2Rlcm4gdmVyc2lvbiBvZiB0aGVcbiAgLy8gW0Zpc2hlci1ZYXRlcyBzaHVmZmxlXShodHRwOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL0Zpc2hlcuKAk1lhdGVzX3NodWZmbGUpLlxuICBfLnNodWZmbGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgc2V0ID0gaXNBcnJheUxpa2Uob2JqKSA/IG9iaiA6IF8udmFsdWVzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IHNldC5sZW5ndGg7XG4gICAgdmFyIHNodWZmbGVkID0gQXJyYXkobGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpbmRleCA9IDAsIHJhbmQ7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByYW5kID0gXy5yYW5kb20oMCwgaW5kZXgpO1xuICAgICAgaWYgKHJhbmQgIT09IGluZGV4KSBzaHVmZmxlZFtpbmRleF0gPSBzaHVmZmxlZFtyYW5kXTtcbiAgICAgIHNodWZmbGVkW3JhbmRdID0gc2V0W2luZGV4XTtcbiAgICB9XG4gICAgcmV0dXJuIHNodWZmbGVkO1xuICB9O1xuXG4gIC8vIFNhbXBsZSAqKm4qKiByYW5kb20gdmFsdWVzIGZyb20gYSBjb2xsZWN0aW9uLlxuICAvLyBJZiAqKm4qKiBpcyBub3Qgc3BlY2lmaWVkLCByZXR1cm5zIGEgc2luZ2xlIHJhbmRvbSBlbGVtZW50LlxuICAvLyBUaGUgaW50ZXJuYWwgYGd1YXJkYCBhcmd1bWVudCBhbGxvd3MgaXQgdG8gd29yayB3aXRoIGBtYXBgLlxuICBfLnNhbXBsZSA9IGZ1bmN0aW9uKG9iaiwgbiwgZ3VhcmQpIHtcbiAgICBpZiAobiA9PSBudWxsIHx8IGd1YXJkKSB7XG4gICAgICBpZiAoIWlzQXJyYXlMaWtlKG9iaikpIG9iaiA9IF8udmFsdWVzKG9iaik7XG4gICAgICByZXR1cm4gb2JqW18ucmFuZG9tKG9iai5sZW5ndGggLSAxKV07XG4gICAgfVxuICAgIHJldHVybiBfLnNodWZmbGUob2JqKS5zbGljZSgwLCBNYXRoLm1heCgwLCBuKSk7XG4gIH07XG5cbiAgLy8gU29ydCB0aGUgb2JqZWN0J3MgdmFsdWVzIGJ5IGEgY3JpdGVyaW9uIHByb2R1Y2VkIGJ5IGFuIGl0ZXJhdGVlLlxuICBfLnNvcnRCeSA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICByZXR1cm4gXy5wbHVjayhfLm1hcChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCwgbGlzdCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICBpbmRleDogaW5kZXgsXG4gICAgICAgIGNyaXRlcmlhOiBpdGVyYXRlZSh2YWx1ZSwgaW5kZXgsIGxpc3QpXG4gICAgICB9O1xuICAgIH0pLnNvcnQoZnVuY3Rpb24obGVmdCwgcmlnaHQpIHtcbiAgICAgIHZhciBhID0gbGVmdC5jcml0ZXJpYTtcbiAgICAgIHZhciBiID0gcmlnaHQuY3JpdGVyaWE7XG4gICAgICBpZiAoYSAhPT0gYikge1xuICAgICAgICBpZiAoYSA+IGIgfHwgYSA9PT0gdm9pZCAwKSByZXR1cm4gMTtcbiAgICAgICAgaWYgKGEgPCBiIHx8IGIgPT09IHZvaWQgMCkgcmV0dXJuIC0xO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGxlZnQuaW5kZXggLSByaWdodC5pbmRleDtcbiAgICB9KSwgJ3ZhbHVlJyk7XG4gIH07XG5cbiAgLy8gQW4gaW50ZXJuYWwgZnVuY3Rpb24gdXNlZCBmb3IgYWdncmVnYXRlIFwiZ3JvdXAgYnlcIiBvcGVyYXRpb25zLlxuICB2YXIgZ3JvdXAgPSBmdW5jdGlvbihiZWhhdmlvcikge1xuICAgIHJldHVybiBmdW5jdGlvbihvYmosIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBpbmRleCkge1xuICAgICAgICB2YXIga2V5ID0gaXRlcmF0ZWUodmFsdWUsIGluZGV4LCBvYmopO1xuICAgICAgICBiZWhhdmlvcihyZXN1bHQsIHZhbHVlLCBrZXkpO1xuICAgICAgfSk7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gR3JvdXBzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24uIFBhc3MgZWl0aGVyIGEgc3RyaW5nIGF0dHJpYnV0ZVxuICAvLyB0byBncm91cCBieSwgb3IgYSBmdW5jdGlvbiB0aGF0IHJldHVybnMgdGhlIGNyaXRlcmlvbi5cbiAgXy5ncm91cEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgaWYgKF8uaGFzKHJlc3VsdCwga2V5KSkgcmVzdWx0W2tleV0ucHVzaCh2YWx1ZSk7IGVsc2UgcmVzdWx0W2tleV0gPSBbdmFsdWVdO1xuICB9KTtcblxuICAvLyBJbmRleGVzIHRoZSBvYmplY3QncyB2YWx1ZXMgYnkgYSBjcml0ZXJpb24sIHNpbWlsYXIgdG8gYGdyb3VwQnlgLCBidXQgZm9yXG4gIC8vIHdoZW4geW91IGtub3cgdGhhdCB5b3VyIGluZGV4IHZhbHVlcyB3aWxsIGJlIHVuaXF1ZS5cbiAgXy5pbmRleEJ5ID0gZ3JvdXAoZnVuY3Rpb24ocmVzdWx0LCB2YWx1ZSwga2V5KSB7XG4gICAgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgfSk7XG5cbiAgLy8gQ291bnRzIGluc3RhbmNlcyBvZiBhbiBvYmplY3QgdGhhdCBncm91cCBieSBhIGNlcnRhaW4gY3JpdGVyaW9uLiBQYXNzXG4gIC8vIGVpdGhlciBhIHN0cmluZyBhdHRyaWJ1dGUgdG8gY291bnQgYnksIG9yIGEgZnVuY3Rpb24gdGhhdCByZXR1cm5zIHRoZVxuICAvLyBjcml0ZXJpb24uXG4gIF8uY291bnRCeSA9IGdyb3VwKGZ1bmN0aW9uKHJlc3VsdCwgdmFsdWUsIGtleSkge1xuICAgIGlmIChfLmhhcyhyZXN1bHQsIGtleSkpIHJlc3VsdFtrZXldKys7IGVsc2UgcmVzdWx0W2tleV0gPSAxO1xuICB9KTtcblxuICAvLyBTYWZlbHkgY3JlYXRlIGEgcmVhbCwgbGl2ZSBhcnJheSBmcm9tIGFueXRoaW5nIGl0ZXJhYmxlLlxuICBfLnRvQXJyYXkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIW9iaikgcmV0dXJuIFtdO1xuICAgIGlmIChfLmlzQXJyYXkob2JqKSkgcmV0dXJuIHNsaWNlLmNhbGwob2JqKTtcbiAgICBpZiAoaXNBcnJheUxpa2Uob2JqKSkgcmV0dXJuIF8ubWFwKG9iaiwgXy5pZGVudGl0eSk7XG4gICAgcmV0dXJuIF8udmFsdWVzKG9iaik7XG4gIH07XG5cbiAgLy8gUmV0dXJuIHRoZSBudW1iZXIgb2YgZWxlbWVudHMgaW4gYW4gb2JqZWN0LlxuICBfLnNpemUgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiAwO1xuICAgIHJldHVybiBpc0FycmF5TGlrZShvYmopID8gb2JqLmxlbmd0aCA6IF8ua2V5cyhvYmopLmxlbmd0aDtcbiAgfTtcblxuICAvLyBTcGxpdCBhIGNvbGxlY3Rpb24gaW50byB0d28gYXJyYXlzOiBvbmUgd2hvc2UgZWxlbWVudHMgYWxsIHNhdGlzZnkgdGhlIGdpdmVuXG4gIC8vIHByZWRpY2F0ZSwgYW5kIG9uZSB3aG9zZSBlbGVtZW50cyBhbGwgZG8gbm90IHNhdGlzZnkgdGhlIHByZWRpY2F0ZS5cbiAgXy5wYXJ0aXRpb24gPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIHBhc3MgPSBbXSwgZmFpbCA9IFtdO1xuICAgIF8uZWFjaChvYmosIGZ1bmN0aW9uKHZhbHVlLCBrZXksIG9iaikge1xuICAgICAgKHByZWRpY2F0ZSh2YWx1ZSwga2V5LCBvYmopID8gcGFzcyA6IGZhaWwpLnB1c2godmFsdWUpO1xuICAgIH0pO1xuICAgIHJldHVybiBbcGFzcywgZmFpbF07XG4gIH07XG5cbiAgLy8gQXJyYXkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLVxuXG4gIC8vIEdldCB0aGUgZmlyc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgZmlyc3QgTlxuICAvLyB2YWx1ZXMgaW4gdGhlIGFycmF5LiBBbGlhc2VkIGFzIGBoZWFkYCBhbmQgYHRha2VgLiBUaGUgKipndWFyZCoqIGNoZWNrXG4gIC8vIGFsbG93cyBpdCB0byB3b3JrIHdpdGggYF8ubWFwYC5cbiAgXy5maXJzdCA9IF8uaGVhZCA9IF8udGFrZSA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVswXTtcbiAgICByZXR1cm4gXy5pbml0aWFsKGFycmF5LCBhcnJheS5sZW5ndGggLSBuKTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGV2ZXJ5dGhpbmcgYnV0IHRoZSBsYXN0IGVudHJ5IG9mIHRoZSBhcnJheS4gRXNwZWNpYWxseSB1c2VmdWwgb25cbiAgLy8gdGhlIGFyZ3VtZW50cyBvYmplY3QuIFBhc3NpbmcgKipuKiogd2lsbCByZXR1cm4gYWxsIHRoZSB2YWx1ZXMgaW5cbiAgLy8gdGhlIGFycmF5LCBleGNsdWRpbmcgdGhlIGxhc3QgTi5cbiAgXy5pbml0aWFsID0gZnVuY3Rpb24oYXJyYXksIG4sIGd1YXJkKSB7XG4gICAgcmV0dXJuIHNsaWNlLmNhbGwoYXJyYXksIDAsIE1hdGgubWF4KDAsIGFycmF5Lmxlbmd0aCAtIChuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbikpKTtcbiAgfTtcblxuICAvLyBHZXQgdGhlIGxhc3QgZWxlbWVudCBvZiBhbiBhcnJheS4gUGFzc2luZyAqKm4qKiB3aWxsIHJldHVybiB0aGUgbGFzdCBOXG4gIC8vIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ubGFzdCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIGlmIChhcnJheSA9PSBudWxsKSByZXR1cm4gdm9pZCAwO1xuICAgIGlmIChuID09IG51bGwgfHwgZ3VhcmQpIHJldHVybiBhcnJheVthcnJheS5sZW5ndGggLSAxXTtcbiAgICByZXR1cm4gXy5yZXN0KGFycmF5LCBNYXRoLm1heCgwLCBhcnJheS5sZW5ndGggLSBuKSk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBldmVyeXRoaW5nIGJ1dCB0aGUgZmlyc3QgZW50cnkgb2YgdGhlIGFycmF5LiBBbGlhc2VkIGFzIGB0YWlsYCBhbmQgYGRyb3BgLlxuICAvLyBFc3BlY2lhbGx5IHVzZWZ1bCBvbiB0aGUgYXJndW1lbnRzIG9iamVjdC4gUGFzc2luZyBhbiAqKm4qKiB3aWxsIHJldHVyblxuICAvLyB0aGUgcmVzdCBOIHZhbHVlcyBpbiB0aGUgYXJyYXkuXG4gIF8ucmVzdCA9IF8udGFpbCA9IF8uZHJvcCA9IGZ1bmN0aW9uKGFycmF5LCBuLCBndWFyZCkge1xuICAgIHJldHVybiBzbGljZS5jYWxsKGFycmF5LCBuID09IG51bGwgfHwgZ3VhcmQgPyAxIDogbik7XG4gIH07XG5cbiAgLy8gVHJpbSBvdXQgYWxsIGZhbHN5IHZhbHVlcyBmcm9tIGFuIGFycmF5LlxuICBfLmNvbXBhY3QgPSBmdW5jdGlvbihhcnJheSkge1xuICAgIHJldHVybiBfLmZpbHRlcihhcnJheSwgXy5pZGVudGl0eSk7XG4gIH07XG5cbiAgLy8gSW50ZXJuYWwgaW1wbGVtZW50YXRpb24gb2YgYSByZWN1cnNpdmUgYGZsYXR0ZW5gIGZ1bmN0aW9uLlxuICB2YXIgZmxhdHRlbiA9IGZ1bmN0aW9uKGlucHV0LCBzaGFsbG93LCBzdHJpY3QsIHN0YXJ0SW5kZXgpIHtcbiAgICB2YXIgb3V0cHV0ID0gW10sIGlkeCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IHN0YXJ0SW5kZXggfHwgMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGlucHV0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgdmFsdWUgPSBpbnB1dFtpXTtcbiAgICAgIGlmIChpc0FycmF5TGlrZSh2YWx1ZSkgJiYgKF8uaXNBcnJheSh2YWx1ZSkgfHwgXy5pc0FyZ3VtZW50cyh2YWx1ZSkpKSB7XG4gICAgICAgIC8vZmxhdHRlbiBjdXJyZW50IGxldmVsIG9mIGFycmF5IG9yIGFyZ3VtZW50cyBvYmplY3RcbiAgICAgICAgaWYgKCFzaGFsbG93KSB2YWx1ZSA9IGZsYXR0ZW4odmFsdWUsIHNoYWxsb3csIHN0cmljdCk7XG4gICAgICAgIHZhciBqID0gMCwgbGVuID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICBvdXRwdXQubGVuZ3RoICs9IGxlbjtcbiAgICAgICAgd2hpbGUgKGogPCBsZW4pIHtcbiAgICAgICAgICBvdXRwdXRbaWR4KytdID0gdmFsdWVbaisrXTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICghc3RyaWN0KSB7XG4gICAgICAgIG91dHB1dFtpZHgrK10gPSB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG91dHB1dDtcbiAgfTtcblxuICAvLyBGbGF0dGVuIG91dCBhbiBhcnJheSwgZWl0aGVyIHJlY3Vyc2l2ZWx5IChieSBkZWZhdWx0KSwgb3IganVzdCBvbmUgbGV2ZWwuXG4gIF8uZmxhdHRlbiA9IGZ1bmN0aW9uKGFycmF5LCBzaGFsbG93KSB7XG4gICAgcmV0dXJuIGZsYXR0ZW4oYXJyYXksIHNoYWxsb3csIGZhbHNlKTtcbiAgfTtcblxuICAvLyBSZXR1cm4gYSB2ZXJzaW9uIG9mIHRoZSBhcnJheSB0aGF0IGRvZXMgbm90IGNvbnRhaW4gdGhlIHNwZWNpZmllZCB2YWx1ZShzKS5cbiAgXy53aXRob3V0ID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICByZXR1cm4gXy5kaWZmZXJlbmNlKGFycmF5LCBzbGljZS5jYWxsKGFyZ3VtZW50cywgMSkpO1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYSBkdXBsaWNhdGUtZnJlZSB2ZXJzaW9uIG9mIHRoZSBhcnJheS4gSWYgdGhlIGFycmF5IGhhcyBhbHJlYWR5XG4gIC8vIGJlZW4gc29ydGVkLCB5b3UgaGF2ZSB0aGUgb3B0aW9uIG9mIHVzaW5nIGEgZmFzdGVyIGFsZ29yaXRobS5cbiAgLy8gQWxpYXNlZCBhcyBgdW5pcXVlYC5cbiAgXy51bmlxID0gXy51bmlxdWUgPSBmdW5jdGlvbihhcnJheSwgaXNTb3J0ZWQsIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgaWYgKCFfLmlzQm9vbGVhbihpc1NvcnRlZCkpIHtcbiAgICAgIGNvbnRleHQgPSBpdGVyYXRlZTtcbiAgICAgIGl0ZXJhdGVlID0gaXNTb3J0ZWQ7XG4gICAgICBpc1NvcnRlZCA9IGZhbHNlO1xuICAgIH1cbiAgICBpZiAoaXRlcmF0ZWUgIT0gbnVsbCkgaXRlcmF0ZWUgPSBjYihpdGVyYXRlZSwgY29udGV4dCk7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIHZhciBzZWVuID0gW107XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChhcnJheSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIHZhbHVlID0gYXJyYXlbaV0sXG4gICAgICAgICAgY29tcHV0ZWQgPSBpdGVyYXRlZSA/IGl0ZXJhdGVlKHZhbHVlLCBpLCBhcnJheSkgOiB2YWx1ZTtcbiAgICAgIGlmIChpc1NvcnRlZCkge1xuICAgICAgICBpZiAoIWkgfHwgc2VlbiAhPT0gY29tcHV0ZWQpIHJlc3VsdC5wdXNoKHZhbHVlKTtcbiAgICAgICAgc2VlbiA9IGNvbXB1dGVkO1xuICAgICAgfSBlbHNlIGlmIChpdGVyYXRlZSkge1xuICAgICAgICBpZiAoIV8uY29udGFpbnMoc2VlbiwgY29tcHV0ZWQpKSB7XG4gICAgICAgICAgc2Vlbi5wdXNoKGNvbXB1dGVkKTtcbiAgICAgICAgICByZXN1bHQucHVzaCh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoIV8uY29udGFpbnMocmVzdWx0LCB2YWx1ZSkpIHtcbiAgICAgICAgcmVzdWx0LnB1c2godmFsdWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFByb2R1Y2UgYW4gYXJyYXkgdGhhdCBjb250YWlucyB0aGUgdW5pb246IGVhY2ggZGlzdGluY3QgZWxlbWVudCBmcm9tIGFsbCBvZlxuICAvLyB0aGUgcGFzc2VkLWluIGFycmF5cy5cbiAgXy51bmlvbiA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBfLnVuaXEoZmxhdHRlbihhcmd1bWVudHMsIHRydWUsIHRydWUpKTtcbiAgfTtcblxuICAvLyBQcm9kdWNlIGFuIGFycmF5IHRoYXQgY29udGFpbnMgZXZlcnkgaXRlbSBzaGFyZWQgYmV0d2VlbiBhbGwgdGhlXG4gIC8vIHBhc3NlZC1pbiBhcnJheXMuXG4gIF8uaW50ZXJzZWN0aW9uID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgdmFyIGFyZ3NMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBpdGVtID0gYXJyYXlbaV07XG4gICAgICBpZiAoXy5jb250YWlucyhyZXN1bHQsIGl0ZW0pKSBjb250aW51ZTtcbiAgICAgIGZvciAodmFyIGogPSAxOyBqIDwgYXJnc0xlbmd0aDsgaisrKSB7XG4gICAgICAgIGlmICghXy5jb250YWlucyhhcmd1bWVudHNbal0sIGl0ZW0pKSBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChqID09PSBhcmdzTGVuZ3RoKSByZXN1bHQucHVzaChpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAvLyBUYWtlIHRoZSBkaWZmZXJlbmNlIGJldHdlZW4gb25lIGFycmF5IGFuZCBhIG51bWJlciBvZiBvdGhlciBhcnJheXMuXG4gIC8vIE9ubHkgdGhlIGVsZW1lbnRzIHByZXNlbnQgaW4ganVzdCB0aGUgZmlyc3QgYXJyYXkgd2lsbCByZW1haW4uXG4gIF8uZGlmZmVyZW5jZSA9IGZ1bmN0aW9uKGFycmF5KSB7XG4gICAgdmFyIHJlc3QgPSBmbGF0dGVuKGFyZ3VtZW50cywgdHJ1ZSwgdHJ1ZSwgMSk7XG4gICAgcmV0dXJuIF8uZmlsdGVyKGFycmF5LCBmdW5jdGlvbih2YWx1ZSl7XG4gICAgICByZXR1cm4gIV8uY29udGFpbnMocmVzdCwgdmFsdWUpO1xuICAgIH0pO1xuICB9O1xuXG4gIC8vIFppcCB0b2dldGhlciBtdWx0aXBsZSBsaXN0cyBpbnRvIGEgc2luZ2xlIGFycmF5IC0tIGVsZW1lbnRzIHRoYXQgc2hhcmVcbiAgLy8gYW4gaW5kZXggZ28gdG9nZXRoZXIuXG4gIF8uemlwID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIF8udW56aXAoYXJndW1lbnRzKTtcbiAgfTtcblxuICAvLyBDb21wbGVtZW50IG9mIF8uemlwLiBVbnppcCBhY2NlcHRzIGFuIGFycmF5IG9mIGFycmF5cyBhbmQgZ3JvdXBzXG4gIC8vIGVhY2ggYXJyYXkncyBlbGVtZW50cyBvbiBzaGFyZWQgaW5kaWNlc1xuICBfLnVuemlwID0gZnVuY3Rpb24oYXJyYXkpIHtcbiAgICB2YXIgbGVuZ3RoID0gYXJyYXkgJiYgXy5tYXgoYXJyYXksIGdldExlbmd0aCkubGVuZ3RoIHx8IDA7XG4gICAgdmFyIHJlc3VsdCA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpbmRleCA9IDA7IGluZGV4IDwgbGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgICByZXN1bHRbaW5kZXhdID0gXy5wbHVjayhhcnJheSwgaW5kZXgpO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENvbnZlcnRzIGxpc3RzIGludG8gb2JqZWN0cy4gUGFzcyBlaXRoZXIgYSBzaW5nbGUgYXJyYXkgb2YgYFtrZXksIHZhbHVlXWBcbiAgLy8gcGFpcnMsIG9yIHR3byBwYXJhbGxlbCBhcnJheXMgb2YgdGhlIHNhbWUgbGVuZ3RoIC0tIG9uZSBvZiBrZXlzLCBhbmQgb25lIG9mXG4gIC8vIHRoZSBjb3JyZXNwb25kaW5nIHZhbHVlcy5cbiAgXy5vYmplY3QgPSBmdW5jdGlvbihsaXN0LCB2YWx1ZXMpIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGdldExlbmd0aChsaXN0KTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAodmFsdWVzKSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldXSA9IHZhbHVlc1tpXTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc3VsdFtsaXN0W2ldWzBdXSA9IGxpc3RbaV1bMV07XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH07XG5cbiAgLy8gR2VuZXJhdG9yIGZ1bmN0aW9uIHRvIGNyZWF0ZSB0aGUgZmluZEluZGV4IGFuZCBmaW5kTGFzdEluZGV4IGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcihkaXIpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oYXJyYXksIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgICAgcHJlZGljYXRlID0gY2IocHJlZGljYXRlLCBjb250ZXh0KTtcbiAgICAgIHZhciBsZW5ndGggPSBnZXRMZW5ndGgoYXJyYXkpO1xuICAgICAgdmFyIGluZGV4ID0gZGlyID4gMCA/IDAgOiBsZW5ndGggLSAxO1xuICAgICAgZm9yICg7IGluZGV4ID49IDAgJiYgaW5kZXggPCBsZW5ndGg7IGluZGV4ICs9IGRpcikge1xuICAgICAgICBpZiAocHJlZGljYXRlKGFycmF5W2luZGV4XSwgaW5kZXgsIGFycmF5KSkgcmV0dXJuIGluZGV4O1xuICAgICAgfVxuICAgICAgcmV0dXJuIC0xO1xuICAgIH07XG4gIH1cblxuICAvLyBSZXR1cm5zIHRoZSBmaXJzdCBpbmRleCBvbiBhbiBhcnJheS1saWtlIHRoYXQgcGFzc2VzIGEgcHJlZGljYXRlIHRlc3RcbiAgXy5maW5kSW5kZXggPSBjcmVhdGVQcmVkaWNhdGVJbmRleEZpbmRlcigxKTtcbiAgXy5maW5kTGFzdEluZGV4ID0gY3JlYXRlUHJlZGljYXRlSW5kZXhGaW5kZXIoLTEpO1xuXG4gIC8vIFVzZSBhIGNvbXBhcmF0b3IgZnVuY3Rpb24gdG8gZmlndXJlIG91dCB0aGUgc21hbGxlc3QgaW5kZXggYXQgd2hpY2hcbiAgLy8gYW4gb2JqZWN0IHNob3VsZCBiZSBpbnNlcnRlZCBzbyBhcyB0byBtYWludGFpbiBvcmRlci4gVXNlcyBiaW5hcnkgc2VhcmNoLlxuICBfLnNvcnRlZEluZGV4ID0gZnVuY3Rpb24oYXJyYXksIG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpdGVyYXRlZSA9IGNiKGl0ZXJhdGVlLCBjb250ZXh0LCAxKTtcbiAgICB2YXIgdmFsdWUgPSBpdGVyYXRlZShvYmopO1xuICAgIHZhciBsb3cgPSAwLCBoaWdoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICB3aGlsZSAobG93IDwgaGlnaCkge1xuICAgICAgdmFyIG1pZCA9IE1hdGguZmxvb3IoKGxvdyArIGhpZ2gpIC8gMik7XG4gICAgICBpZiAoaXRlcmF0ZWUoYXJyYXlbbWlkXSkgPCB2YWx1ZSkgbG93ID0gbWlkICsgMTsgZWxzZSBoaWdoID0gbWlkO1xuICAgIH1cbiAgICByZXR1cm4gbG93O1xuICB9O1xuXG4gIC8vIEdlbmVyYXRvciBmdW5jdGlvbiB0byBjcmVhdGUgdGhlIGluZGV4T2YgYW5kIGxhc3RJbmRleE9mIGZ1bmN0aW9uc1xuICBmdW5jdGlvbiBjcmVhdGVJbmRleEZpbmRlcihkaXIsIHByZWRpY2F0ZUZpbmQsIHNvcnRlZEluZGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGFycmF5LCBpdGVtLCBpZHgpIHtcbiAgICAgIHZhciBpID0gMCwgbGVuZ3RoID0gZ2V0TGVuZ3RoKGFycmF5KTtcbiAgICAgIGlmICh0eXBlb2YgaWR4ID09ICdudW1iZXInKSB7XG4gICAgICAgIGlmIChkaXIgPiAwKSB7XG4gICAgICAgICAgICBpID0gaWR4ID49IDAgPyBpZHggOiBNYXRoLm1heChpZHggKyBsZW5ndGgsIGkpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgbGVuZ3RoID0gaWR4ID49IDAgPyBNYXRoLm1pbihpZHggKyAxLCBsZW5ndGgpIDogaWR4ICsgbGVuZ3RoICsgMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChzb3J0ZWRJbmRleCAmJiBpZHggJiYgbGVuZ3RoKSB7XG4gICAgICAgIGlkeCA9IHNvcnRlZEluZGV4KGFycmF5LCBpdGVtKTtcbiAgICAgICAgcmV0dXJuIGFycmF5W2lkeF0gPT09IGl0ZW0gPyBpZHggOiAtMTtcbiAgICAgIH1cbiAgICAgIGlmIChpdGVtICE9PSBpdGVtKSB7XG4gICAgICAgIGlkeCA9IHByZWRpY2F0ZUZpbmQoc2xpY2UuY2FsbChhcnJheSwgaSwgbGVuZ3RoKSwgXy5pc05hTik7XG4gICAgICAgIHJldHVybiBpZHggPj0gMCA/IGlkeCArIGkgOiAtMTtcbiAgICAgIH1cbiAgICAgIGZvciAoaWR4ID0gZGlyID4gMCA/IGkgOiBsZW5ndGggLSAxOyBpZHggPj0gMCAmJiBpZHggPCBsZW5ndGg7IGlkeCArPSBkaXIpIHtcbiAgICAgICAgaWYgKGFycmF5W2lkeF0gPT09IGl0ZW0pIHJldHVybiBpZHg7XG4gICAgICB9XG4gICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgfVxuXG4gIC8vIFJldHVybiB0aGUgcG9zaXRpb24gb2YgdGhlIGZpcnN0IG9jY3VycmVuY2Ugb2YgYW4gaXRlbSBpbiBhbiBhcnJheSxcbiAgLy8gb3IgLTEgaWYgdGhlIGl0ZW0gaXMgbm90IGluY2x1ZGVkIGluIHRoZSBhcnJheS5cbiAgLy8gSWYgdGhlIGFycmF5IGlzIGxhcmdlIGFuZCBhbHJlYWR5IGluIHNvcnQgb3JkZXIsIHBhc3MgYHRydWVgXG4gIC8vIGZvciAqKmlzU29ydGVkKiogdG8gdXNlIGJpbmFyeSBzZWFyY2guXG4gIF8uaW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKDEsIF8uZmluZEluZGV4LCBfLnNvcnRlZEluZGV4KTtcbiAgXy5sYXN0SW5kZXhPZiA9IGNyZWF0ZUluZGV4RmluZGVyKC0xLCBfLmZpbmRMYXN0SW5kZXgpO1xuXG4gIC8vIEdlbmVyYXRlIGFuIGludGVnZXIgQXJyYXkgY29udGFpbmluZyBhbiBhcml0aG1ldGljIHByb2dyZXNzaW9uLiBBIHBvcnQgb2ZcbiAgLy8gdGhlIG5hdGl2ZSBQeXRob24gYHJhbmdlKClgIGZ1bmN0aW9uLiBTZWVcbiAgLy8gW3RoZSBQeXRob24gZG9jdW1lbnRhdGlvbl0oaHR0cDovL2RvY3MucHl0aG9uLm9yZy9saWJyYXJ5L2Z1bmN0aW9ucy5odG1sI3JhbmdlKS5cbiAgXy5yYW5nZSA9IGZ1bmN0aW9uKHN0YXJ0LCBzdG9wLCBzdGVwKSB7XG4gICAgaWYgKHN0b3AgPT0gbnVsbCkge1xuICAgICAgc3RvcCA9IHN0YXJ0IHx8IDA7XG4gICAgICBzdGFydCA9IDA7XG4gICAgfVxuICAgIHN0ZXAgPSBzdGVwIHx8IDE7XG5cbiAgICB2YXIgbGVuZ3RoID0gTWF0aC5tYXgoTWF0aC5jZWlsKChzdG9wIC0gc3RhcnQpIC8gc3RlcCksIDApO1xuICAgIHZhciByYW5nZSA9IEFycmF5KGxlbmd0aCk7XG5cbiAgICBmb3IgKHZhciBpZHggPSAwOyBpZHggPCBsZW5ndGg7IGlkeCsrLCBzdGFydCArPSBzdGVwKSB7XG4gICAgICByYW5nZVtpZHhdID0gc3RhcnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIHJhbmdlO1xuICB9O1xuXG4gIC8vIEZ1bmN0aW9uIChhaGVtKSBGdW5jdGlvbnNcbiAgLy8gLS0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gRGV0ZXJtaW5lcyB3aGV0aGVyIHRvIGV4ZWN1dGUgYSBmdW5jdGlvbiBhcyBhIGNvbnN0cnVjdG9yXG4gIC8vIG9yIGEgbm9ybWFsIGZ1bmN0aW9uIHdpdGggdGhlIHByb3ZpZGVkIGFyZ3VtZW50c1xuICB2YXIgZXhlY3V0ZUJvdW5kID0gZnVuY3Rpb24oc291cmNlRnVuYywgYm91bmRGdW5jLCBjb250ZXh0LCBjYWxsaW5nQ29udGV4dCwgYXJncykge1xuICAgIGlmICghKGNhbGxpbmdDb250ZXh0IGluc3RhbmNlb2YgYm91bmRGdW5jKSkgcmV0dXJuIHNvdXJjZUZ1bmMuYXBwbHkoY29udGV4dCwgYXJncyk7XG4gICAgdmFyIHNlbGYgPSBiYXNlQ3JlYXRlKHNvdXJjZUZ1bmMucHJvdG90eXBlKTtcbiAgICB2YXIgcmVzdWx0ID0gc291cmNlRnVuYy5hcHBseShzZWxmLCBhcmdzKTtcbiAgICBpZiAoXy5pc09iamVjdChyZXN1bHQpKSByZXR1cm4gcmVzdWx0O1xuICAgIHJldHVybiBzZWxmO1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIGZ1bmN0aW9uIGJvdW5kIHRvIGEgZ2l2ZW4gb2JqZWN0IChhc3NpZ25pbmcgYHRoaXNgLCBhbmQgYXJndW1lbnRzLFxuICAvLyBvcHRpb25hbGx5KS4gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYEZ1bmN0aW9uLmJpbmRgIGlmXG4gIC8vIGF2YWlsYWJsZS5cbiAgXy5iaW5kID0gZnVuY3Rpb24oZnVuYywgY29udGV4dCkge1xuICAgIGlmIChuYXRpdmVCaW5kICYmIGZ1bmMuYmluZCA9PT0gbmF0aXZlQmluZCkgcmV0dXJuIG5hdGl2ZUJpbmQuYXBwbHkoZnVuYywgc2xpY2UuY2FsbChhcmd1bWVudHMsIDEpKTtcbiAgICBpZiAoIV8uaXNGdW5jdGlvbihmdW5jKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignQmluZCBtdXN0IGJlIGNhbGxlZCBvbiBhIGZ1bmN0aW9uJyk7XG4gICAgdmFyIGFyZ3MgPSBzbGljZS5jYWxsKGFyZ3VtZW50cywgMik7XG4gICAgdmFyIGJvdW5kID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gZXhlY3V0ZUJvdW5kKGZ1bmMsIGJvdW5kLCBjb250ZXh0LCB0aGlzLCBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpKTtcbiAgICB9O1xuICAgIHJldHVybiBib3VuZDtcbiAgfTtcblxuICAvLyBQYXJ0aWFsbHkgYXBwbHkgYSBmdW5jdGlvbiBieSBjcmVhdGluZyBhIHZlcnNpb24gdGhhdCBoYXMgaGFkIHNvbWUgb2YgaXRzXG4gIC8vIGFyZ3VtZW50cyBwcmUtZmlsbGVkLCB3aXRob3V0IGNoYW5naW5nIGl0cyBkeW5hbWljIGB0aGlzYCBjb250ZXh0LiBfIGFjdHNcbiAgLy8gYXMgYSBwbGFjZWhvbGRlciwgYWxsb3dpbmcgYW55IGNvbWJpbmF0aW9uIG9mIGFyZ3VtZW50cyB0byBiZSBwcmUtZmlsbGVkLlxuICBfLnBhcnRpYWwgPSBmdW5jdGlvbihmdW5jKSB7XG4gICAgdmFyIGJvdW5kQXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcbiAgICB2YXIgYm91bmQgPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBwb3NpdGlvbiA9IDAsIGxlbmd0aCA9IGJvdW5kQXJncy5sZW5ndGg7XG4gICAgICB2YXIgYXJncyA9IEFycmF5KGxlbmd0aCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGFyZ3NbaV0gPSBib3VuZEFyZ3NbaV0gPT09IF8gPyBhcmd1bWVudHNbcG9zaXRpb24rK10gOiBib3VuZEFyZ3NbaV07XG4gICAgICB9XG4gICAgICB3aGlsZSAocG9zaXRpb24gPCBhcmd1bWVudHMubGVuZ3RoKSBhcmdzLnB1c2goYXJndW1lbnRzW3Bvc2l0aW9uKytdKTtcbiAgICAgIHJldHVybiBleGVjdXRlQm91bmQoZnVuYywgYm91bmQsIHRoaXMsIHRoaXMsIGFyZ3MpO1xuICAgIH07XG4gICAgcmV0dXJuIGJvdW5kO1xuICB9O1xuXG4gIC8vIEJpbmQgYSBudW1iZXIgb2YgYW4gb2JqZWN0J3MgbWV0aG9kcyB0byB0aGF0IG9iamVjdC4gUmVtYWluaW5nIGFyZ3VtZW50c1xuICAvLyBhcmUgdGhlIG1ldGhvZCBuYW1lcyB0byBiZSBib3VuZC4gVXNlZnVsIGZvciBlbnN1cmluZyB0aGF0IGFsbCBjYWxsYmFja3NcbiAgLy8gZGVmaW5lZCBvbiBhbiBvYmplY3QgYmVsb25nIHRvIGl0LlxuICBfLmJpbmRBbGwgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgaSwgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aCwga2V5O1xuICAgIGlmIChsZW5ndGggPD0gMSkgdGhyb3cgbmV3IEVycm9yKCdiaW5kQWxsIG11c3QgYmUgcGFzc2VkIGZ1bmN0aW9uIG5hbWVzJyk7XG4gICAgZm9yIChpID0gMTsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBhcmd1bWVudHNbaV07XG4gICAgICBvYmpba2V5XSA9IF8uYmluZChvYmpba2V5XSwgb2JqKTtcbiAgICB9XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBNZW1vaXplIGFuIGV4cGVuc2l2ZSBmdW5jdGlvbiBieSBzdG9yaW5nIGl0cyByZXN1bHRzLlxuICBfLm1lbW9pemUgPSBmdW5jdGlvbihmdW5jLCBoYXNoZXIpIHtcbiAgICB2YXIgbWVtb2l6ZSA9IGZ1bmN0aW9uKGtleSkge1xuICAgICAgdmFyIGNhY2hlID0gbWVtb2l6ZS5jYWNoZTtcbiAgICAgIHZhciBhZGRyZXNzID0gJycgKyAoaGFzaGVyID8gaGFzaGVyLmFwcGx5KHRoaXMsIGFyZ3VtZW50cykgOiBrZXkpO1xuICAgICAgaWYgKCFfLmhhcyhjYWNoZSwgYWRkcmVzcykpIGNhY2hlW2FkZHJlc3NdID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgcmV0dXJuIGNhY2hlW2FkZHJlc3NdO1xuICAgIH07XG4gICAgbWVtb2l6ZS5jYWNoZSA9IHt9O1xuICAgIHJldHVybiBtZW1vaXplO1xuICB9O1xuXG4gIC8vIERlbGF5cyBhIGZ1bmN0aW9uIGZvciB0aGUgZ2l2ZW4gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcywgYW5kIHRoZW4gY2FsbHNcbiAgLy8gaXQgd2l0aCB0aGUgYXJndW1lbnRzIHN1cHBsaWVkLlxuICBfLmRlbGF5ID0gZnVuY3Rpb24oZnVuYywgd2FpdCkge1xuICAgIHZhciBhcmdzID0gc2xpY2UuY2FsbChhcmd1bWVudHMsIDIpO1xuICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1bmN0aW9uKCl7XG4gICAgICByZXR1cm4gZnVuYy5hcHBseShudWxsLCBhcmdzKTtcbiAgICB9LCB3YWl0KTtcbiAgfTtcblxuICAvLyBEZWZlcnMgYSBmdW5jdGlvbiwgc2NoZWR1bGluZyBpdCB0byBydW4gYWZ0ZXIgdGhlIGN1cnJlbnQgY2FsbCBzdGFjayBoYXNcbiAgLy8gY2xlYXJlZC5cbiAgXy5kZWZlciA9IF8ucGFydGlhbChfLmRlbGF5LCBfLCAxKTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24sIHRoYXQsIHdoZW4gaW52b2tlZCwgd2lsbCBvbmx5IGJlIHRyaWdnZXJlZCBhdCBtb3N0IG9uY2VcbiAgLy8gZHVyaW5nIGEgZ2l2ZW4gd2luZG93IG9mIHRpbWUuIE5vcm1hbGx5LCB0aGUgdGhyb3R0bGVkIGZ1bmN0aW9uIHdpbGwgcnVuXG4gIC8vIGFzIG11Y2ggYXMgaXQgY2FuLCB3aXRob3V0IGV2ZXIgZ29pbmcgbW9yZSB0aGFuIG9uY2UgcGVyIGB3YWl0YCBkdXJhdGlvbjtcbiAgLy8gYnV0IGlmIHlvdSdkIGxpa2UgdG8gZGlzYWJsZSB0aGUgZXhlY3V0aW9uIG9uIHRoZSBsZWFkaW5nIGVkZ2UsIHBhc3NcbiAgLy8gYHtsZWFkaW5nOiBmYWxzZX1gLiBUbyBkaXNhYmxlIGV4ZWN1dGlvbiBvbiB0aGUgdHJhaWxpbmcgZWRnZSwgZGl0dG8uXG4gIF8udGhyb3R0bGUgPSBmdW5jdGlvbihmdW5jLCB3YWl0LCBvcHRpb25zKSB7XG4gICAgdmFyIGNvbnRleHQsIGFyZ3MsIHJlc3VsdDtcbiAgICB2YXIgdGltZW91dCA9IG51bGw7XG4gICAgdmFyIHByZXZpb3VzID0gMDtcbiAgICBpZiAoIW9wdGlvbnMpIG9wdGlvbnMgPSB7fTtcbiAgICB2YXIgbGF0ZXIgPSBmdW5jdGlvbigpIHtcbiAgICAgIHByZXZpb3VzID0gb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSA/IDAgOiBfLm5vdygpO1xuICAgICAgdGltZW91dCA9IG51bGw7XG4gICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgfTtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICB2YXIgbm93ID0gXy5ub3coKTtcbiAgICAgIGlmICghcHJldmlvdXMgJiYgb3B0aW9ucy5sZWFkaW5nID09PSBmYWxzZSkgcHJldmlvdXMgPSBub3c7XG4gICAgICB2YXIgcmVtYWluaW5nID0gd2FpdCAtIChub3cgLSBwcmV2aW91cyk7XG4gICAgICBjb250ZXh0ID0gdGhpcztcbiAgICAgIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgICBpZiAocmVtYWluaW5nIDw9IDAgfHwgcmVtYWluaW5nID4gd2FpdCkge1xuICAgICAgICBpZiAodGltZW91dCkge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBwcmV2aW91cyA9IG5vdztcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgaWYgKCF0aW1lb3V0KSBjb250ZXh0ID0gYXJncyA9IG51bGw7XG4gICAgICB9IGVsc2UgaWYgKCF0aW1lb3V0ICYmIG9wdGlvbnMudHJhaWxpbmcgIT09IGZhbHNlKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCByZW1haW5pbmcpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiwgdGhhdCwgYXMgbG9uZyBhcyBpdCBjb250aW51ZXMgdG8gYmUgaW52b2tlZCwgd2lsbCBub3RcbiAgLy8gYmUgdHJpZ2dlcmVkLiBUaGUgZnVuY3Rpb24gd2lsbCBiZSBjYWxsZWQgYWZ0ZXIgaXQgc3RvcHMgYmVpbmcgY2FsbGVkIGZvclxuICAvLyBOIG1pbGxpc2Vjb25kcy4gSWYgYGltbWVkaWF0ZWAgaXMgcGFzc2VkLCB0cmlnZ2VyIHRoZSBmdW5jdGlvbiBvbiB0aGVcbiAgLy8gbGVhZGluZyBlZGdlLCBpbnN0ZWFkIG9mIHRoZSB0cmFpbGluZy5cbiAgXy5kZWJvdW5jZSA9IGZ1bmN0aW9uKGZ1bmMsIHdhaXQsIGltbWVkaWF0ZSkge1xuICAgIHZhciB0aW1lb3V0LCBhcmdzLCBjb250ZXh0LCB0aW1lc3RhbXAsIHJlc3VsdDtcblxuICAgIHZhciBsYXRlciA9IGZ1bmN0aW9uKCkge1xuICAgICAgdmFyIGxhc3QgPSBfLm5vdygpIC0gdGltZXN0YW1wO1xuXG4gICAgICBpZiAobGFzdCA8IHdhaXQgJiYgbGFzdCA+PSAwKSB7XG4gICAgICAgIHRpbWVvdXQgPSBzZXRUaW1lb3V0KGxhdGVyLCB3YWl0IC0gbGFzdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aW1lb3V0ID0gbnVsbDtcbiAgICAgICAgaWYgKCFpbW1lZGlhdGUpIHtcbiAgICAgICAgICByZXN1bHQgPSBmdW5jLmFwcGx5KGNvbnRleHQsIGFyZ3MpO1xuICAgICAgICAgIGlmICghdGltZW91dCkgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcblxuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGNvbnRleHQgPSB0aGlzO1xuICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICAgIHRpbWVzdGFtcCA9IF8ubm93KCk7XG4gICAgICB2YXIgY2FsbE5vdyA9IGltbWVkaWF0ZSAmJiAhdGltZW91dDtcbiAgICAgIGlmICghdGltZW91dCkgdGltZW91dCA9IHNldFRpbWVvdXQobGF0ZXIsIHdhaXQpO1xuICAgICAgaWYgKGNhbGxOb3cpIHtcbiAgICAgICAgcmVzdWx0ID0gZnVuYy5hcHBseShjb250ZXh0LCBhcmdzKTtcbiAgICAgICAgY29udGV4dCA9IGFyZ3MgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyB0aGUgZmlyc3QgZnVuY3Rpb24gcGFzc2VkIGFzIGFuIGFyZ3VtZW50IHRvIHRoZSBzZWNvbmQsXG4gIC8vIGFsbG93aW5nIHlvdSB0byBhZGp1c3QgYXJndW1lbnRzLCBydW4gY29kZSBiZWZvcmUgYW5kIGFmdGVyLCBhbmRcbiAgLy8gY29uZGl0aW9uYWxseSBleGVjdXRlIHRoZSBvcmlnaW5hbCBmdW5jdGlvbi5cbiAgXy53cmFwID0gZnVuY3Rpb24oZnVuYywgd3JhcHBlcikge1xuICAgIHJldHVybiBfLnBhcnRpYWwod3JhcHBlciwgZnVuYyk7XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIG5lZ2F0ZWQgdmVyc2lvbiBvZiB0aGUgcGFzc2VkLWluIHByZWRpY2F0ZS5cbiAgXy5uZWdhdGUgPSBmdW5jdGlvbihwcmVkaWNhdGUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gIXByZWRpY2F0ZS5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH07XG4gIH07XG5cbiAgLy8gUmV0dXJucyBhIGZ1bmN0aW9uIHRoYXQgaXMgdGhlIGNvbXBvc2l0aW9uIG9mIGEgbGlzdCBvZiBmdW5jdGlvbnMsIGVhY2hcbiAgLy8gY29uc3VtaW5nIHRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGZ1bmN0aW9uIHRoYXQgZm9sbG93cy5cbiAgXy5jb21wb3NlID0gZnVuY3Rpb24oKSB7XG4gICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XG4gICAgdmFyIHN0YXJ0ID0gYXJncy5sZW5ndGggLSAxO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBpID0gc3RhcnQ7XG4gICAgICB2YXIgcmVzdWx0ID0gYXJnc1tzdGFydF0uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIHdoaWxlIChpLS0pIHJlc3VsdCA9IGFyZ3NbaV0uY2FsbCh0aGlzLCByZXN1bHQpO1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCBvbiBhbmQgYWZ0ZXIgdGhlIE50aCBjYWxsLlxuICBfLmFmdGVyID0gZnVuY3Rpb24odGltZXMsIGZ1bmMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICBpZiAoLS10aW1lcyA8IDEpIHtcbiAgICAgICAgcmV0dXJuIGZ1bmMuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9O1xuXG4gIC8vIFJldHVybnMgYSBmdW5jdGlvbiB0aGF0IHdpbGwgb25seSBiZSBleGVjdXRlZCB1cCB0byAoYnV0IG5vdCBpbmNsdWRpbmcpIHRoZSBOdGggY2FsbC5cbiAgXy5iZWZvcmUgPSBmdW5jdGlvbih0aW1lcywgZnVuYykge1xuICAgIHZhciBtZW1vO1xuICAgIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICAgIGlmICgtLXRpbWVzID4gMCkge1xuICAgICAgICBtZW1vID0gZnVuYy5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfVxuICAgICAgaWYgKHRpbWVzIDw9IDEpIGZ1bmMgPSBudWxsO1xuICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIGF0IG1vc3Qgb25lIHRpbWUsIG5vIG1hdHRlciBob3dcbiAgLy8gb2Z0ZW4geW91IGNhbGwgaXQuIFVzZWZ1bCBmb3IgbGF6eSBpbml0aWFsaXphdGlvbi5cbiAgXy5vbmNlID0gXy5wYXJ0aWFsKF8uYmVmb3JlLCAyKTtcblxuICAvLyBPYmplY3QgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS1cblxuICAvLyBLZXlzIGluIElFIDwgOSB0aGF0IHdvbid0IGJlIGl0ZXJhdGVkIGJ5IGBmb3Iga2V5IGluIC4uLmAgYW5kIHRodXMgbWlzc2VkLlxuICB2YXIgaGFzRW51bUJ1ZyA9ICF7dG9TdHJpbmc6IG51bGx9LnByb3BlcnR5SXNFbnVtZXJhYmxlKCd0b1N0cmluZycpO1xuICB2YXIgbm9uRW51bWVyYWJsZVByb3BzID0gWyd2YWx1ZU9mJywgJ2lzUHJvdG90eXBlT2YnLCAndG9TdHJpbmcnLFxuICAgICAgICAgICAgICAgICAgICAgICdwcm9wZXJ0eUlzRW51bWVyYWJsZScsICdoYXNPd25Qcm9wZXJ0eScsICd0b0xvY2FsZVN0cmluZyddO1xuXG4gIGZ1bmN0aW9uIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKSB7XG4gICAgdmFyIG5vbkVudW1JZHggPSBub25FbnVtZXJhYmxlUHJvcHMubGVuZ3RoO1xuICAgIHZhciBjb25zdHJ1Y3RvciA9IG9iai5jb25zdHJ1Y3RvcjtcbiAgICB2YXIgcHJvdG8gPSAoXy5pc0Z1bmN0aW9uKGNvbnN0cnVjdG9yKSAmJiBjb25zdHJ1Y3Rvci5wcm90b3R5cGUpIHx8IE9ialByb3RvO1xuXG4gICAgLy8gQ29uc3RydWN0b3IgaXMgYSBzcGVjaWFsIGNhc2UuXG4gICAgdmFyIHByb3AgPSAnY29uc3RydWN0b3InO1xuICAgIGlmIChfLmhhcyhvYmosIHByb3ApICYmICFfLmNvbnRhaW5zKGtleXMsIHByb3ApKSBrZXlzLnB1c2gocHJvcCk7XG5cbiAgICB3aGlsZSAobm9uRW51bUlkeC0tKSB7XG4gICAgICBwcm9wID0gbm9uRW51bWVyYWJsZVByb3BzW25vbkVudW1JZHhdO1xuICAgICAgaWYgKHByb3AgaW4gb2JqICYmIG9ialtwcm9wXSAhPT0gcHJvdG9bcHJvcF0gJiYgIV8uY29udGFpbnMoa2V5cywgcHJvcCkpIHtcbiAgICAgICAga2V5cy5wdXNoKHByb3ApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIFJldHJpZXZlIHRoZSBuYW1lcyBvZiBhbiBvYmplY3QncyBvd24gcHJvcGVydGllcy5cbiAgLy8gRGVsZWdhdGVzIHRvICoqRUNNQVNjcmlwdCA1KioncyBuYXRpdmUgYE9iamVjdC5rZXlzYFxuICBfLmtleXMgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAoIV8uaXNPYmplY3Qob2JqKSkgcmV0dXJuIFtdO1xuICAgIGlmIChuYXRpdmVLZXlzKSByZXR1cm4gbmF0aXZlS2V5cyhvYmopO1xuICAgIHZhciBrZXlzID0gW107XG4gICAgZm9yICh2YXIga2V5IGluIG9iaikgaWYgKF8uaGFzKG9iaiwga2V5KSkga2V5cy5wdXNoKGtleSk7XG4gICAgLy8gQWhlbSwgSUUgPCA5LlxuICAgIGlmIChoYXNFbnVtQnVnKSBjb2xsZWN0Tm9uRW51bVByb3BzKG9iaiwga2V5cyk7XG4gICAgcmV0dXJuIGtleXM7XG4gIH07XG5cbiAgLy8gUmV0cmlldmUgYWxsIHRoZSBwcm9wZXJ0eSBuYW1lcyBvZiBhbiBvYmplY3QuXG4gIF8uYWxsS2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gW107XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSBrZXlzLnB1c2goa2V5KTtcbiAgICAvLyBBaGVtLCBJRSA8IDkuXG4gICAgaWYgKGhhc0VudW1CdWcpIGNvbGxlY3ROb25FbnVtUHJvcHMob2JqLCBrZXlzKTtcbiAgICByZXR1cm4ga2V5cztcbiAgfTtcblxuICAvLyBSZXRyaWV2ZSB0aGUgdmFsdWVzIG9mIGFuIG9iamVjdCdzIHByb3BlcnRpZXMuXG4gIF8udmFsdWVzID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICB2YXIgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgdmFyIHZhbHVlcyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFsdWVzW2ldID0gb2JqW2tleXNbaV1dO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWVzO1xuICB9O1xuXG4gIC8vIFJldHVybnMgdGhlIHJlc3VsdHMgb2YgYXBwbHlpbmcgdGhlIGl0ZXJhdGVlIHRvIGVhY2ggZWxlbWVudCBvZiB0aGUgb2JqZWN0XG4gIC8vIEluIGNvbnRyYXN0IHRvIF8ubWFwIGl0IHJldHVybnMgYW4gb2JqZWN0XG4gIF8ubWFwT2JqZWN0ID0gZnVuY3Rpb24ob2JqLCBpdGVyYXRlZSwgY29udGV4dCkge1xuICAgIGl0ZXJhdGVlID0gY2IoaXRlcmF0ZWUsIGNvbnRleHQpO1xuICAgIHZhciBrZXlzID0gIF8ua2V5cyhvYmopLFxuICAgICAgICAgIGxlbmd0aCA9IGtleXMubGVuZ3RoLFxuICAgICAgICAgIHJlc3VsdHMgPSB7fSxcbiAgICAgICAgICBjdXJyZW50S2V5O1xuICAgICAgZm9yICh2YXIgaW5kZXggPSAwOyBpbmRleCA8IGxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICBjdXJyZW50S2V5ID0ga2V5c1tpbmRleF07XG4gICAgICAgIHJlc3VsdHNbY3VycmVudEtleV0gPSBpdGVyYXRlZShvYmpbY3VycmVudEtleV0sIGN1cnJlbnRLZXksIG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gcmVzdWx0cztcbiAgfTtcblxuICAvLyBDb252ZXJ0IGFuIG9iamVjdCBpbnRvIGEgbGlzdCBvZiBgW2tleSwgdmFsdWVdYCBwYWlycy5cbiAgXy5wYWlycyA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKG9iaik7XG4gICAgdmFyIGxlbmd0aCA9IGtleXMubGVuZ3RoO1xuICAgIHZhciBwYWlycyA9IEFycmF5KGxlbmd0aCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcGFpcnNbaV0gPSBba2V5c1tpXSwgb2JqW2tleXNbaV1dXTtcbiAgICB9XG4gICAgcmV0dXJuIHBhaXJzO1xuICB9O1xuXG4gIC8vIEludmVydCB0aGUga2V5cyBhbmQgdmFsdWVzIG9mIGFuIG9iamVjdC4gVGhlIHZhbHVlcyBtdXN0IGJlIHNlcmlhbGl6YWJsZS5cbiAgXy5pbnZlcnQgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKTtcbiAgICBmb3IgKHZhciBpID0gMCwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgcmVzdWx0W29ialtrZXlzW2ldXV0gPSBrZXlzW2ldO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHNvcnRlZCBsaXN0IG9mIHRoZSBmdW5jdGlvbiBuYW1lcyBhdmFpbGFibGUgb24gdGhlIG9iamVjdC5cbiAgLy8gQWxpYXNlZCBhcyBgbWV0aG9kc2BcbiAgXy5mdW5jdGlvbnMgPSBfLm1ldGhvZHMgPSBmdW5jdGlvbihvYmopIHtcbiAgICB2YXIgbmFtZXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgICBpZiAoXy5pc0Z1bmN0aW9uKG9ialtrZXldKSkgbmFtZXMucHVzaChrZXkpO1xuICAgIH1cbiAgICByZXR1cm4gbmFtZXMuc29ydCgpO1xuICB9O1xuXG4gIC8vIEV4dGVuZCBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgcHJvcGVydGllcyBpbiBwYXNzZWQtaW4gb2JqZWN0KHMpLlxuICBfLmV4dGVuZCA9IGNyZWF0ZUFzc2lnbmVyKF8uYWxsS2V5cyk7XG5cbiAgLy8gQXNzaWducyBhIGdpdmVuIG9iamVjdCB3aXRoIGFsbCB0aGUgb3duIHByb3BlcnRpZXMgaW4gdGhlIHBhc3NlZC1pbiBvYmplY3QocylcbiAgLy8gKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0phdmFTY3JpcHQvUmVmZXJlbmNlL0dsb2JhbF9PYmplY3RzL09iamVjdC9hc3NpZ24pXG4gIF8uZXh0ZW5kT3duID0gXy5hc3NpZ24gPSBjcmVhdGVBc3NpZ25lcihfLmtleXMpO1xuXG4gIC8vIFJldHVybnMgdGhlIGZpcnN0IGtleSBvbiBhbiBvYmplY3QgdGhhdCBwYXNzZXMgYSBwcmVkaWNhdGUgdGVzdFxuICBfLmZpbmRLZXkgPSBmdW5jdGlvbihvYmosIHByZWRpY2F0ZSwgY29udGV4dCkge1xuICAgIHByZWRpY2F0ZSA9IGNiKHByZWRpY2F0ZSwgY29udGV4dCk7XG4gICAgdmFyIGtleXMgPSBfLmtleXMob2JqKSwga2V5O1xuICAgIGZvciAodmFyIGkgPSAwLCBsZW5ndGggPSBrZXlzLmxlbmd0aDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICBrZXkgPSBrZXlzW2ldO1xuICAgICAgaWYgKHByZWRpY2F0ZShvYmpba2V5XSwga2V5LCBvYmopKSByZXR1cm4ga2V5O1xuICAgIH1cbiAgfTtcblxuICAvLyBSZXR1cm4gYSBjb3B5IG9mIHRoZSBvYmplY3Qgb25seSBjb250YWluaW5nIHRoZSB3aGl0ZWxpc3RlZCBwcm9wZXJ0aWVzLlxuICBfLnBpY2sgPSBmdW5jdGlvbihvYmplY3QsIG9pdGVyYXRlZSwgY29udGV4dCkge1xuICAgIHZhciByZXN1bHQgPSB7fSwgb2JqID0gb2JqZWN0LCBpdGVyYXRlZSwga2V5cztcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gICAgaWYgKF8uaXNGdW5jdGlvbihvaXRlcmF0ZWUpKSB7XG4gICAgICBrZXlzID0gXy5hbGxLZXlzKG9iaik7XG4gICAgICBpdGVyYXRlZSA9IG9wdGltaXplQ2Iob2l0ZXJhdGVlLCBjb250ZXh0KTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5cyA9IGZsYXR0ZW4oYXJndW1lbnRzLCBmYWxzZSwgZmFsc2UsIDEpO1xuICAgICAgaXRlcmF0ZWUgPSBmdW5jdGlvbih2YWx1ZSwga2V5LCBvYmopIHsgcmV0dXJuIGtleSBpbiBvYmo7IH07XG4gICAgICBvYmogPSBPYmplY3Qob2JqKTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDAsIGxlbmd0aCA9IGtleXMubGVuZ3RoOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHZhbHVlID0gb2JqW2tleV07XG4gICAgICBpZiAoaXRlcmF0ZWUodmFsdWUsIGtleSwgb2JqKSkgcmVzdWx0W2tleV0gPSB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfTtcblxuICAgLy8gUmV0dXJuIGEgY29weSBvZiB0aGUgb2JqZWN0IHdpdGhvdXQgdGhlIGJsYWNrbGlzdGVkIHByb3BlcnRpZXMuXG4gIF8ub21pdCA9IGZ1bmN0aW9uKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpIHtcbiAgICBpZiAoXy5pc0Z1bmN0aW9uKGl0ZXJhdGVlKSkge1xuICAgICAgaXRlcmF0ZWUgPSBfLm5lZ2F0ZShpdGVyYXRlZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBrZXlzID0gXy5tYXAoZmxhdHRlbihhcmd1bWVudHMsIGZhbHNlLCBmYWxzZSwgMSksIFN0cmluZyk7XG4gICAgICBpdGVyYXRlZSA9IGZ1bmN0aW9uKHZhbHVlLCBrZXkpIHtcbiAgICAgICAgcmV0dXJuICFfLmNvbnRhaW5zKGtleXMsIGtleSk7XG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4gXy5waWNrKG9iaiwgaXRlcmF0ZWUsIGNvbnRleHQpO1xuICB9O1xuXG4gIC8vIEZpbGwgaW4gYSBnaXZlbiBvYmplY3Qgd2l0aCBkZWZhdWx0IHByb3BlcnRpZXMuXG4gIF8uZGVmYXVsdHMgPSBjcmVhdGVBc3NpZ25lcihfLmFsbEtleXMsIHRydWUpO1xuXG4gIC8vIENyZWF0ZXMgYW4gb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGUgZ2l2ZW4gcHJvdG90eXBlIG9iamVjdC5cbiAgLy8gSWYgYWRkaXRpb25hbCBwcm9wZXJ0aWVzIGFyZSBwcm92aWRlZCB0aGVuIHRoZXkgd2lsbCBiZSBhZGRlZCB0byB0aGVcbiAgLy8gY3JlYXRlZCBvYmplY3QuXG4gIF8uY3JlYXRlID0gZnVuY3Rpb24ocHJvdG90eXBlLCBwcm9wcykge1xuICAgIHZhciByZXN1bHQgPSBiYXNlQ3JlYXRlKHByb3RvdHlwZSk7XG4gICAgaWYgKHByb3BzKSBfLmV4dGVuZE93bihyZXN1bHQsIHByb3BzKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9O1xuXG4gIC8vIENyZWF0ZSBhIChzaGFsbG93LWNsb25lZCkgZHVwbGljYXRlIG9mIGFuIG9iamVjdC5cbiAgXy5jbG9uZSA9IGZ1bmN0aW9uKG9iaikge1xuICAgIGlmICghXy5pc09iamVjdChvYmopKSByZXR1cm4gb2JqO1xuICAgIHJldHVybiBfLmlzQXJyYXkob2JqKSA/IG9iai5zbGljZSgpIDogXy5leHRlbmQoe30sIG9iaik7XG4gIH07XG5cbiAgLy8gSW52b2tlcyBpbnRlcmNlcHRvciB3aXRoIHRoZSBvYmosIGFuZCB0aGVuIHJldHVybnMgb2JqLlxuICAvLyBUaGUgcHJpbWFyeSBwdXJwb3NlIG9mIHRoaXMgbWV0aG9kIGlzIHRvIFwidGFwIGludG9cIiBhIG1ldGhvZCBjaGFpbiwgaW5cbiAgLy8gb3JkZXIgdG8gcGVyZm9ybSBvcGVyYXRpb25zIG9uIGludGVybWVkaWF0ZSByZXN1bHRzIHdpdGhpbiB0aGUgY2hhaW4uXG4gIF8udGFwID0gZnVuY3Rpb24ob2JqLCBpbnRlcmNlcHRvcikge1xuICAgIGludGVyY2VwdG9yKG9iaik7XG4gICAgcmV0dXJuIG9iajtcbiAgfTtcblxuICAvLyBSZXR1cm5zIHdoZXRoZXIgYW4gb2JqZWN0IGhhcyBhIGdpdmVuIHNldCBvZiBga2V5OnZhbHVlYCBwYWlycy5cbiAgXy5pc01hdGNoID0gZnVuY3Rpb24ob2JqZWN0LCBhdHRycykge1xuICAgIHZhciBrZXlzID0gXy5rZXlzKGF0dHJzKSwgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgaWYgKG9iamVjdCA9PSBudWxsKSByZXR1cm4gIWxlbmd0aDtcbiAgICB2YXIgb2JqID0gT2JqZWN0KG9iamVjdCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgICBpZiAoYXR0cnNba2V5XSAhPT0gb2JqW2tleV0gfHwgIShrZXkgaW4gb2JqKSkgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfTtcblxuXG4gIC8vIEludGVybmFsIHJlY3Vyc2l2ZSBjb21wYXJpc29uIGZ1bmN0aW9uIGZvciBgaXNFcXVhbGAuXG4gIHZhciBlcSA9IGZ1bmN0aW9uKGEsIGIsIGFTdGFjaywgYlN0YWNrKSB7XG4gICAgLy8gSWRlbnRpY2FsIG9iamVjdHMgYXJlIGVxdWFsLiBgMCA9PT0gLTBgLCBidXQgdGhleSBhcmVuJ3QgaWRlbnRpY2FsLlxuICAgIC8vIFNlZSB0aGUgW0hhcm1vbnkgYGVnYWxgIHByb3Bvc2FsXShodHRwOi8vd2lraS5lY21hc2NyaXB0Lm9yZy9kb2t1LnBocD9pZD1oYXJtb255OmVnYWwpLlxuICAgIGlmIChhID09PSBiKSByZXR1cm4gYSAhPT0gMCB8fCAxIC8gYSA9PT0gMSAvIGI7XG4gICAgLy8gQSBzdHJpY3QgY29tcGFyaXNvbiBpcyBuZWNlc3NhcnkgYmVjYXVzZSBgbnVsbCA9PSB1bmRlZmluZWRgLlxuICAgIGlmIChhID09IG51bGwgfHwgYiA9PSBudWxsKSByZXR1cm4gYSA9PT0gYjtcbiAgICAvLyBVbndyYXAgYW55IHdyYXBwZWQgb2JqZWN0cy5cbiAgICBpZiAoYSBpbnN0YW5jZW9mIF8pIGEgPSBhLl93cmFwcGVkO1xuICAgIGlmIChiIGluc3RhbmNlb2YgXykgYiA9IGIuX3dyYXBwZWQ7XG4gICAgLy8gQ29tcGFyZSBgW1tDbGFzc11dYCBuYW1lcy5cbiAgICB2YXIgY2xhc3NOYW1lID0gdG9TdHJpbmcuY2FsbChhKTtcbiAgICBpZiAoY2xhc3NOYW1lICE9PSB0b1N0cmluZy5jYWxsKGIpKSByZXR1cm4gZmFsc2U7XG4gICAgc3dpdGNoIChjbGFzc05hbWUpIHtcbiAgICAgIC8vIFN0cmluZ3MsIG51bWJlcnMsIHJlZ3VsYXIgZXhwcmVzc2lvbnMsIGRhdGVzLCBhbmQgYm9vbGVhbnMgYXJlIGNvbXBhcmVkIGJ5IHZhbHVlLlxuICAgICAgY2FzZSAnW29iamVjdCBSZWdFeHBdJzpcbiAgICAgIC8vIFJlZ0V4cHMgYXJlIGNvZXJjZWQgdG8gc3RyaW5ncyBmb3IgY29tcGFyaXNvbiAoTm90ZTogJycgKyAvYS9pID09PSAnL2EvaScpXG4gICAgICBjYXNlICdbb2JqZWN0IFN0cmluZ10nOlxuICAgICAgICAvLyBQcmltaXRpdmVzIGFuZCB0aGVpciBjb3JyZXNwb25kaW5nIG9iamVjdCB3cmFwcGVycyBhcmUgZXF1aXZhbGVudDsgdGh1cywgYFwiNVwiYCBpc1xuICAgICAgICAvLyBlcXVpdmFsZW50IHRvIGBuZXcgU3RyaW5nKFwiNVwiKWAuXG4gICAgICAgIHJldHVybiAnJyArIGEgPT09ICcnICsgYjtcbiAgICAgIGNhc2UgJ1tvYmplY3QgTnVtYmVyXSc6XG4gICAgICAgIC8vIGBOYU5gcyBhcmUgZXF1aXZhbGVudCwgYnV0IG5vbi1yZWZsZXhpdmUuXG4gICAgICAgIC8vIE9iamVjdChOYU4pIGlzIGVxdWl2YWxlbnQgdG8gTmFOXG4gICAgICAgIGlmICgrYSAhPT0gK2EpIHJldHVybiArYiAhPT0gK2I7XG4gICAgICAgIC8vIEFuIGBlZ2FsYCBjb21wYXJpc29uIGlzIHBlcmZvcm1lZCBmb3Igb3RoZXIgbnVtZXJpYyB2YWx1ZXMuXG4gICAgICAgIHJldHVybiArYSA9PT0gMCA/IDEgLyArYSA9PT0gMSAvIGIgOiArYSA9PT0gK2I7XG4gICAgICBjYXNlICdbb2JqZWN0IERhdGVdJzpcbiAgICAgIGNhc2UgJ1tvYmplY3QgQm9vbGVhbl0nOlxuICAgICAgICAvLyBDb2VyY2UgZGF0ZXMgYW5kIGJvb2xlYW5zIHRvIG51bWVyaWMgcHJpbWl0aXZlIHZhbHVlcy4gRGF0ZXMgYXJlIGNvbXBhcmVkIGJ5IHRoZWlyXG4gICAgICAgIC8vIG1pbGxpc2Vjb25kIHJlcHJlc2VudGF0aW9ucy4gTm90ZSB0aGF0IGludmFsaWQgZGF0ZXMgd2l0aCBtaWxsaXNlY29uZCByZXByZXNlbnRhdGlvbnNcbiAgICAgICAgLy8gb2YgYE5hTmAgYXJlIG5vdCBlcXVpdmFsZW50LlxuICAgICAgICByZXR1cm4gK2EgPT09ICtiO1xuICAgIH1cblxuICAgIHZhciBhcmVBcnJheXMgPSBjbGFzc05hbWUgPT09ICdbb2JqZWN0IEFycmF5XSc7XG4gICAgaWYgKCFhcmVBcnJheXMpIHtcbiAgICAgIGlmICh0eXBlb2YgYSAhPSAnb2JqZWN0JyB8fCB0eXBlb2YgYiAhPSAnb2JqZWN0JykgcmV0dXJuIGZhbHNlO1xuXG4gICAgICAvLyBPYmplY3RzIHdpdGggZGlmZmVyZW50IGNvbnN0cnVjdG9ycyBhcmUgbm90IGVxdWl2YWxlbnQsIGJ1dCBgT2JqZWN0YHMgb3IgYEFycmF5YHNcbiAgICAgIC8vIGZyb20gZGlmZmVyZW50IGZyYW1lcyBhcmUuXG4gICAgICB2YXIgYUN0b3IgPSBhLmNvbnN0cnVjdG9yLCBiQ3RvciA9IGIuY29uc3RydWN0b3I7XG4gICAgICBpZiAoYUN0b3IgIT09IGJDdG9yICYmICEoXy5pc0Z1bmN0aW9uKGFDdG9yKSAmJiBhQ3RvciBpbnN0YW5jZW9mIGFDdG9yICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXy5pc0Z1bmN0aW9uKGJDdG9yKSAmJiBiQ3RvciBpbnN0YW5jZW9mIGJDdG9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAmJiAoJ2NvbnN0cnVjdG9yJyBpbiBhICYmICdjb25zdHJ1Y3RvcicgaW4gYikpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBBc3N1bWUgZXF1YWxpdHkgZm9yIGN5Y2xpYyBzdHJ1Y3R1cmVzLiBUaGUgYWxnb3JpdGhtIGZvciBkZXRlY3RpbmcgY3ljbGljXG4gICAgLy8gc3RydWN0dXJlcyBpcyBhZGFwdGVkIGZyb20gRVMgNS4xIHNlY3Rpb24gMTUuMTIuMywgYWJzdHJhY3Qgb3BlcmF0aW9uIGBKT2AuXG5cbiAgICAvLyBJbml0aWFsaXppbmcgc3RhY2sgb2YgdHJhdmVyc2VkIG9iamVjdHMuXG4gICAgLy8gSXQncyBkb25lIGhlcmUgc2luY2Ugd2Ugb25seSBuZWVkIHRoZW0gZm9yIG9iamVjdHMgYW5kIGFycmF5cyBjb21wYXJpc29uLlxuICAgIGFTdGFjayA9IGFTdGFjayB8fCBbXTtcbiAgICBiU3RhY2sgPSBiU3RhY2sgfHwgW107XG4gICAgdmFyIGxlbmd0aCA9IGFTdGFjay5sZW5ndGg7XG4gICAgd2hpbGUgKGxlbmd0aC0tKSB7XG4gICAgICAvLyBMaW5lYXIgc2VhcmNoLiBQZXJmb3JtYW5jZSBpcyBpbnZlcnNlbHkgcHJvcG9ydGlvbmFsIHRvIHRoZSBudW1iZXIgb2ZcbiAgICAgIC8vIHVuaXF1ZSBuZXN0ZWQgc3RydWN0dXJlcy5cbiAgICAgIGlmIChhU3RhY2tbbGVuZ3RoXSA9PT0gYSkgcmV0dXJuIGJTdGFja1tsZW5ndGhdID09PSBiO1xuICAgIH1cblxuICAgIC8vIEFkZCB0aGUgZmlyc3Qgb2JqZWN0IHRvIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucHVzaChhKTtcbiAgICBiU3RhY2sucHVzaChiKTtcblxuICAgIC8vIFJlY3Vyc2l2ZWx5IGNvbXBhcmUgb2JqZWN0cyBhbmQgYXJyYXlzLlxuICAgIGlmIChhcmVBcnJheXMpIHtcbiAgICAgIC8vIENvbXBhcmUgYXJyYXkgbGVuZ3RocyB0byBkZXRlcm1pbmUgaWYgYSBkZWVwIGNvbXBhcmlzb24gaXMgbmVjZXNzYXJ5LlxuICAgICAgbGVuZ3RoID0gYS5sZW5ndGg7XG4gICAgICBpZiAobGVuZ3RoICE9PSBiLmxlbmd0aCkgcmV0dXJuIGZhbHNlO1xuICAgICAgLy8gRGVlcCBjb21wYXJlIHRoZSBjb250ZW50cywgaWdub3Jpbmcgbm9uLW51bWVyaWMgcHJvcGVydGllcy5cbiAgICAgIHdoaWxlIChsZW5ndGgtLSkge1xuICAgICAgICBpZiAoIWVxKGFbbGVuZ3RoXSwgYltsZW5ndGhdLCBhU3RhY2ssIGJTdGFjaykpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgLy8gRGVlcCBjb21wYXJlIG9iamVjdHMuXG4gICAgICB2YXIga2V5cyA9IF8ua2V5cyhhKSwga2V5O1xuICAgICAgbGVuZ3RoID0ga2V5cy5sZW5ndGg7XG4gICAgICAvLyBFbnN1cmUgdGhhdCBib3RoIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBudW1iZXIgb2YgcHJvcGVydGllcyBiZWZvcmUgY29tcGFyaW5nIGRlZXAgZXF1YWxpdHkuXG4gICAgICBpZiAoXy5rZXlzKGIpLmxlbmd0aCAhPT0gbGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgICB3aGlsZSAobGVuZ3RoLS0pIHtcbiAgICAgICAgLy8gRGVlcCBjb21wYXJlIGVhY2ggbWVtYmVyXG4gICAgICAgIGtleSA9IGtleXNbbGVuZ3RoXTtcbiAgICAgICAgaWYgKCEoXy5oYXMoYiwga2V5KSAmJiBlcShhW2tleV0sIGJba2V5XSwgYVN0YWNrLCBiU3RhY2spKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IG9iamVjdCBmcm9tIHRoZSBzdGFjayBvZiB0cmF2ZXJzZWQgb2JqZWN0cy5cbiAgICBhU3RhY2sucG9wKCk7XG4gICAgYlN0YWNrLnBvcCgpO1xuICAgIHJldHVybiB0cnVlO1xuICB9O1xuXG4gIC8vIFBlcmZvcm0gYSBkZWVwIGNvbXBhcmlzb24gdG8gY2hlY2sgaWYgdHdvIG9iamVjdHMgYXJlIGVxdWFsLlxuICBfLmlzRXF1YWwgPSBmdW5jdGlvbihhLCBiKSB7XG4gICAgcmV0dXJuIGVxKGEsIGIpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gYXJyYXksIHN0cmluZywgb3Igb2JqZWN0IGVtcHR5P1xuICAvLyBBbiBcImVtcHR5XCIgb2JqZWN0IGhhcyBubyBlbnVtZXJhYmxlIG93bi1wcm9wZXJ0aWVzLlxuICBfLmlzRW1wdHkgPSBmdW5jdGlvbihvYmopIHtcbiAgICBpZiAob2JqID09IG51bGwpIHJldHVybiB0cnVlO1xuICAgIGlmIChpc0FycmF5TGlrZShvYmopICYmIChfLmlzQXJyYXkob2JqKSB8fCBfLmlzU3RyaW5nKG9iaikgfHwgXy5pc0FyZ3VtZW50cyhvYmopKSkgcmV0dXJuIG9iai5sZW5ndGggPT09IDA7XG4gICAgcmV0dXJuIF8ua2V5cyhvYmopLmxlbmd0aCA9PT0gMDtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgRE9NIGVsZW1lbnQ/XG4gIF8uaXNFbGVtZW50ID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuICEhKG9iaiAmJiBvYmoubm9kZVR5cGUgPT09IDEpO1xuICB9O1xuXG4gIC8vIElzIGEgZ2l2ZW4gdmFsdWUgYW4gYXJyYXk/XG4gIC8vIERlbGVnYXRlcyB0byBFQ01BNSdzIG5hdGl2ZSBBcnJheS5pc0FycmF5XG4gIF8uaXNBcnJheSA9IG5hdGl2ZUlzQXJyYXkgfHwgZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIHRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhcmlhYmxlIGFuIG9iamVjdD9cbiAgXy5pc09iamVjdCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIG9iajtcbiAgICByZXR1cm4gdHlwZSA9PT0gJ2Z1bmN0aW9uJyB8fCB0eXBlID09PSAnb2JqZWN0JyAmJiAhIW9iajtcbiAgfTtcblxuICAvLyBBZGQgc29tZSBpc1R5cGUgbWV0aG9kczogaXNBcmd1bWVudHMsIGlzRnVuY3Rpb24sIGlzU3RyaW5nLCBpc051bWJlciwgaXNEYXRlLCBpc1JlZ0V4cCwgaXNFcnJvci5cbiAgXy5lYWNoKFsnQXJndW1lbnRzJywgJ0Z1bmN0aW9uJywgJ1N0cmluZycsICdOdW1iZXInLCAnRGF0ZScsICdSZWdFeHAnLCAnRXJyb3InXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIF9bJ2lzJyArIG5hbWVdID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCAnICsgbmFtZSArICddJztcbiAgICB9O1xuICB9KTtcblxuICAvLyBEZWZpbmUgYSBmYWxsYmFjayB2ZXJzaW9uIG9mIHRoZSBtZXRob2QgaW4gYnJvd3NlcnMgKGFoZW0sIElFIDwgOSksIHdoZXJlXG4gIC8vIHRoZXJlIGlzbid0IGFueSBpbnNwZWN0YWJsZSBcIkFyZ3VtZW50c1wiIHR5cGUuXG4gIGlmICghXy5pc0FyZ3VtZW50cyhhcmd1bWVudHMpKSB7XG4gICAgXy5pc0FyZ3VtZW50cyA9IGZ1bmN0aW9uKG9iaikge1xuICAgICAgcmV0dXJuIF8uaGFzKG9iaiwgJ2NhbGxlZScpO1xuICAgIH07XG4gIH1cblxuICAvLyBPcHRpbWl6ZSBgaXNGdW5jdGlvbmAgaWYgYXBwcm9wcmlhdGUuIFdvcmsgYXJvdW5kIHNvbWUgdHlwZW9mIGJ1Z3MgaW4gb2xkIHY4LFxuICAvLyBJRSAxMSAoIzE2MjEpLCBhbmQgaW4gU2FmYXJpIDggKCMxOTI5KS5cbiAgaWYgKHR5cGVvZiAvLi8gIT0gJ2Z1bmN0aW9uJyAmJiB0eXBlb2YgSW50OEFycmF5ICE9ICdvYmplY3QnKSB7XG4gICAgXy5pc0Z1bmN0aW9uID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PSAnZnVuY3Rpb24nIHx8IGZhbHNlO1xuICAgIH07XG4gIH1cblxuICAvLyBJcyBhIGdpdmVuIG9iamVjdCBhIGZpbml0ZSBudW1iZXI/XG4gIF8uaXNGaW5pdGUgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gaXNGaW5pdGUob2JqKSAmJiAhaXNOYU4ocGFyc2VGbG9hdChvYmopKTtcbiAgfTtcblxuICAvLyBJcyB0aGUgZ2l2ZW4gdmFsdWUgYE5hTmA/IChOYU4gaXMgdGhlIG9ubHkgbnVtYmVyIHdoaWNoIGRvZXMgbm90IGVxdWFsIGl0c2VsZikuXG4gIF8uaXNOYU4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gXy5pc051bWJlcihvYmopICYmIG9iaiAhPT0gK29iajtcbiAgfTtcblxuICAvLyBJcyBhIGdpdmVuIHZhbHVlIGEgYm9vbGVhbj9cbiAgXy5pc0Jvb2xlYW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB0cnVlIHx8IG9iaiA9PT0gZmFsc2UgfHwgdG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBCb29sZWFuXSc7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YWx1ZSBlcXVhbCB0byBudWxsP1xuICBfLmlzTnVsbCA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHJldHVybiBvYmogPT09IG51bGw7XG4gIH07XG5cbiAgLy8gSXMgYSBnaXZlbiB2YXJpYWJsZSB1bmRlZmluZWQ/XG4gIF8uaXNVbmRlZmluZWQgPSBmdW5jdGlvbihvYmopIHtcbiAgICByZXR1cm4gb2JqID09PSB2b2lkIDA7XG4gIH07XG5cbiAgLy8gU2hvcnRjdXQgZnVuY3Rpb24gZm9yIGNoZWNraW5nIGlmIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBwcm9wZXJ0eSBkaXJlY3RseVxuICAvLyBvbiBpdHNlbGYgKGluIG90aGVyIHdvcmRzLCBub3Qgb24gYSBwcm90b3R5cGUpLlxuICBfLmhhcyA9IGZ1bmN0aW9uKG9iaiwga2V5KSB7XG4gICAgcmV0dXJuIG9iaiAhPSBudWxsICYmIGhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xuICB9O1xuXG4gIC8vIFV0aWxpdHkgRnVuY3Rpb25zXG4gIC8vIC0tLS0tLS0tLS0tLS0tLS0tXG5cbiAgLy8gUnVuIFVuZGVyc2NvcmUuanMgaW4gKm5vQ29uZmxpY3QqIG1vZGUsIHJldHVybmluZyB0aGUgYF9gIHZhcmlhYmxlIHRvIGl0c1xuICAvLyBwcmV2aW91cyBvd25lci4gUmV0dXJucyBhIHJlZmVyZW5jZSB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubm9Db25mbGljdCA9IGZ1bmN0aW9uKCkge1xuICAgIHJvb3QuXyA9IHByZXZpb3VzVW5kZXJzY29yZTtcbiAgICByZXR1cm4gdGhpcztcbiAgfTtcblxuICAvLyBLZWVwIHRoZSBpZGVudGl0eSBmdW5jdGlvbiBhcm91bmQgZm9yIGRlZmF1bHQgaXRlcmF0ZWVzLlxuICBfLmlkZW50aXR5ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH07XG5cbiAgLy8gUHJlZGljYXRlLWdlbmVyYXRpbmcgZnVuY3Rpb25zLiBPZnRlbiB1c2VmdWwgb3V0c2lkZSBvZiBVbmRlcnNjb3JlLlxuICBfLmNvbnN0YW50ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfTtcbiAgfTtcblxuICBfLm5vb3AgPSBmdW5jdGlvbigpe307XG5cbiAgXy5wcm9wZXJ0eSA9IHByb3BlcnR5O1xuXG4gIC8vIEdlbmVyYXRlcyBhIGZ1bmN0aW9uIGZvciBhIGdpdmVuIG9iamVjdCB0aGF0IHJldHVybnMgYSBnaXZlbiBwcm9wZXJ0eS5cbiAgXy5wcm9wZXJ0eU9mID0gZnVuY3Rpb24ob2JqKSB7XG4gICAgcmV0dXJuIG9iaiA9PSBudWxsID8gZnVuY3Rpb24oKXt9IDogZnVuY3Rpb24oa2V5KSB7XG4gICAgICByZXR1cm4gb2JqW2tleV07XG4gICAgfTtcbiAgfTtcblxuICAvLyBSZXR1cm5zIGEgcHJlZGljYXRlIGZvciBjaGVja2luZyB3aGV0aGVyIGFuIG9iamVjdCBoYXMgYSBnaXZlbiBzZXQgb2ZcbiAgLy8gYGtleTp2YWx1ZWAgcGFpcnMuXG4gIF8ubWF0Y2hlciA9IF8ubWF0Y2hlcyA9IGZ1bmN0aW9uKGF0dHJzKSB7XG4gICAgYXR0cnMgPSBfLmV4dGVuZE93bih7fSwgYXR0cnMpO1xuICAgIHJldHVybiBmdW5jdGlvbihvYmopIHtcbiAgICAgIHJldHVybiBfLmlzTWF0Y2gob2JqLCBhdHRycyk7XG4gICAgfTtcbiAgfTtcblxuICAvLyBSdW4gYSBmdW5jdGlvbiAqKm4qKiB0aW1lcy5cbiAgXy50aW1lcyA9IGZ1bmN0aW9uKG4sIGl0ZXJhdGVlLCBjb250ZXh0KSB7XG4gICAgdmFyIGFjY3VtID0gQXJyYXkoTWF0aC5tYXgoMCwgbikpO1xuICAgIGl0ZXJhdGVlID0gb3B0aW1pemVDYihpdGVyYXRlZSwgY29udGV4dCwgMSk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBuOyBpKyspIGFjY3VtW2ldID0gaXRlcmF0ZWUoaSk7XG4gICAgcmV0dXJuIGFjY3VtO1xuICB9O1xuXG4gIC8vIFJldHVybiBhIHJhbmRvbSBpbnRlZ2VyIGJldHdlZW4gbWluIGFuZCBtYXggKGluY2x1c2l2ZSkuXG4gIF8ucmFuZG9tID0gZnVuY3Rpb24obWluLCBtYXgpIHtcbiAgICBpZiAobWF4ID09IG51bGwpIHtcbiAgICAgIG1heCA9IG1pbjtcbiAgICAgIG1pbiA9IDA7XG4gICAgfVxuICAgIHJldHVybiBtaW4gKyBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluICsgMSkpO1xuICB9O1xuXG4gIC8vIEEgKHBvc3NpYmx5IGZhc3Rlcikgd2F5IHRvIGdldCB0aGUgY3VycmVudCB0aW1lc3RhbXAgYXMgYW4gaW50ZWdlci5cbiAgXy5ub3cgPSBEYXRlLm5vdyB8fCBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gbmV3IERhdGUoKS5nZXRUaW1lKCk7XG4gIH07XG5cbiAgIC8vIExpc3Qgb2YgSFRNTCBlbnRpdGllcyBmb3IgZXNjYXBpbmcuXG4gIHZhciBlc2NhcGVNYXAgPSB7XG4gICAgJyYnOiAnJmFtcDsnLFxuICAgICc8JzogJyZsdDsnLFxuICAgICc+JzogJyZndDsnLFxuICAgICdcIic6ICcmcXVvdDsnLFxuICAgIFwiJ1wiOiAnJiN4Mjc7JyxcbiAgICAnYCc6ICcmI3g2MDsnXG4gIH07XG4gIHZhciB1bmVzY2FwZU1hcCA9IF8uaW52ZXJ0KGVzY2FwZU1hcCk7XG5cbiAgLy8gRnVuY3Rpb25zIGZvciBlc2NhcGluZyBhbmQgdW5lc2NhcGluZyBzdHJpbmdzIHRvL2Zyb20gSFRNTCBpbnRlcnBvbGF0aW9uLlxuICB2YXIgY3JlYXRlRXNjYXBlciA9IGZ1bmN0aW9uKG1hcCkge1xuICAgIHZhciBlc2NhcGVyID0gZnVuY3Rpb24obWF0Y2gpIHtcbiAgICAgIHJldHVybiBtYXBbbWF0Y2hdO1xuICAgIH07XG4gICAgLy8gUmVnZXhlcyBmb3IgaWRlbnRpZnlpbmcgYSBrZXkgdGhhdCBuZWVkcyB0byBiZSBlc2NhcGVkXG4gICAgdmFyIHNvdXJjZSA9ICcoPzonICsgXy5rZXlzKG1hcCkuam9pbignfCcpICsgJyknO1xuICAgIHZhciB0ZXN0UmVnZXhwID0gUmVnRXhwKHNvdXJjZSk7XG4gICAgdmFyIHJlcGxhY2VSZWdleHAgPSBSZWdFeHAoc291cmNlLCAnZycpO1xuICAgIHJldHVybiBmdW5jdGlvbihzdHJpbmcpIHtcbiAgICAgIHN0cmluZyA9IHN0cmluZyA9PSBudWxsID8gJycgOiAnJyArIHN0cmluZztcbiAgICAgIHJldHVybiB0ZXN0UmVnZXhwLnRlc3Qoc3RyaW5nKSA/IHN0cmluZy5yZXBsYWNlKHJlcGxhY2VSZWdleHAsIGVzY2FwZXIpIDogc3RyaW5nO1xuICAgIH07XG4gIH07XG4gIF8uZXNjYXBlID0gY3JlYXRlRXNjYXBlcihlc2NhcGVNYXApO1xuICBfLnVuZXNjYXBlID0gY3JlYXRlRXNjYXBlcih1bmVzY2FwZU1hcCk7XG5cbiAgLy8gSWYgdGhlIHZhbHVlIG9mIHRoZSBuYW1lZCBgcHJvcGVydHlgIGlzIGEgZnVuY3Rpb24gdGhlbiBpbnZva2UgaXQgd2l0aCB0aGVcbiAgLy8gYG9iamVjdGAgYXMgY29udGV4dDsgb3RoZXJ3aXNlLCByZXR1cm4gaXQuXG4gIF8ucmVzdWx0ID0gZnVuY3Rpb24ob2JqZWN0LCBwcm9wZXJ0eSwgZmFsbGJhY2spIHtcbiAgICB2YXIgdmFsdWUgPSBvYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IG9iamVjdFtwcm9wZXJ0eV07XG4gICAgaWYgKHZhbHVlID09PSB2b2lkIDApIHtcbiAgICAgIHZhbHVlID0gZmFsbGJhY2s7XG4gICAgfVxuICAgIHJldHVybiBfLmlzRnVuY3Rpb24odmFsdWUpID8gdmFsdWUuY2FsbChvYmplY3QpIDogdmFsdWU7XG4gIH07XG5cbiAgLy8gR2VuZXJhdGUgYSB1bmlxdWUgaW50ZWdlciBpZCAodW5pcXVlIHdpdGhpbiB0aGUgZW50aXJlIGNsaWVudCBzZXNzaW9uKS5cbiAgLy8gVXNlZnVsIGZvciB0ZW1wb3JhcnkgRE9NIGlkcy5cbiAgdmFyIGlkQ291bnRlciA9IDA7XG4gIF8udW5pcXVlSWQgPSBmdW5jdGlvbihwcmVmaXgpIHtcbiAgICB2YXIgaWQgPSArK2lkQ291bnRlciArICcnO1xuICAgIHJldHVybiBwcmVmaXggPyBwcmVmaXggKyBpZCA6IGlkO1xuICB9O1xuXG4gIC8vIEJ5IGRlZmF1bHQsIFVuZGVyc2NvcmUgdXNlcyBFUkItc3R5bGUgdGVtcGxhdGUgZGVsaW1pdGVycywgY2hhbmdlIHRoZVxuICAvLyBmb2xsb3dpbmcgdGVtcGxhdGUgc2V0dGluZ3MgdG8gdXNlIGFsdGVybmF0aXZlIGRlbGltaXRlcnMuXG4gIF8udGVtcGxhdGVTZXR0aW5ncyA9IHtcbiAgICBldmFsdWF0ZSAgICA6IC88JShbXFxzXFxTXSs/KSU+L2csXG4gICAgaW50ZXJwb2xhdGUgOiAvPCU9KFtcXHNcXFNdKz8pJT4vZyxcbiAgICBlc2NhcGUgICAgICA6IC88JS0oW1xcc1xcU10rPyklPi9nXG4gIH07XG5cbiAgLy8gV2hlbiBjdXN0b21pemluZyBgdGVtcGxhdGVTZXR0aW5nc2AsIGlmIHlvdSBkb24ndCB3YW50IHRvIGRlZmluZSBhblxuICAvLyBpbnRlcnBvbGF0aW9uLCBldmFsdWF0aW9uIG9yIGVzY2FwaW5nIHJlZ2V4LCB3ZSBuZWVkIG9uZSB0aGF0IGlzXG4gIC8vIGd1YXJhbnRlZWQgbm90IHRvIG1hdGNoLlxuICB2YXIgbm9NYXRjaCA9IC8oLileLztcblxuICAvLyBDZXJ0YWluIGNoYXJhY3RlcnMgbmVlZCB0byBiZSBlc2NhcGVkIHNvIHRoYXQgdGhleSBjYW4gYmUgcHV0IGludG8gYVxuICAvLyBzdHJpbmcgbGl0ZXJhbC5cbiAgdmFyIGVzY2FwZXMgPSB7XG4gICAgXCInXCI6ICAgICAgXCInXCIsXG4gICAgJ1xcXFwnOiAgICAgJ1xcXFwnLFxuICAgICdcXHInOiAgICAgJ3InLFxuICAgICdcXG4nOiAgICAgJ24nLFxuICAgICdcXHUyMDI4JzogJ3UyMDI4JyxcbiAgICAnXFx1MjAyOSc6ICd1MjAyOSdcbiAgfTtcblxuICB2YXIgZXNjYXBlciA9IC9cXFxcfCd8XFxyfFxcbnxcXHUyMDI4fFxcdTIwMjkvZztcblxuICB2YXIgZXNjYXBlQ2hhciA9IGZ1bmN0aW9uKG1hdGNoKSB7XG4gICAgcmV0dXJuICdcXFxcJyArIGVzY2FwZXNbbWF0Y2hdO1xuICB9O1xuXG4gIC8vIEphdmFTY3JpcHQgbWljcm8tdGVtcGxhdGluZywgc2ltaWxhciB0byBKb2huIFJlc2lnJ3MgaW1wbGVtZW50YXRpb24uXG4gIC8vIFVuZGVyc2NvcmUgdGVtcGxhdGluZyBoYW5kbGVzIGFyYml0cmFyeSBkZWxpbWl0ZXJzLCBwcmVzZXJ2ZXMgd2hpdGVzcGFjZSxcbiAgLy8gYW5kIGNvcnJlY3RseSBlc2NhcGVzIHF1b3RlcyB3aXRoaW4gaW50ZXJwb2xhdGVkIGNvZGUuXG4gIC8vIE5COiBgb2xkU2V0dGluZ3NgIG9ubHkgZXhpc3RzIGZvciBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eS5cbiAgXy50ZW1wbGF0ZSA9IGZ1bmN0aW9uKHRleHQsIHNldHRpbmdzLCBvbGRTZXR0aW5ncykge1xuICAgIGlmICghc2V0dGluZ3MgJiYgb2xkU2V0dGluZ3MpIHNldHRpbmdzID0gb2xkU2V0dGluZ3M7XG4gICAgc2V0dGluZ3MgPSBfLmRlZmF1bHRzKHt9LCBzZXR0aW5ncywgXy50ZW1wbGF0ZVNldHRpbmdzKTtcblxuICAgIC8vIENvbWJpbmUgZGVsaW1pdGVycyBpbnRvIG9uZSByZWd1bGFyIGV4cHJlc3Npb24gdmlhIGFsdGVybmF0aW9uLlxuICAgIHZhciBtYXRjaGVyID0gUmVnRXhwKFtcbiAgICAgIChzZXR0aW5ncy5lc2NhcGUgfHwgbm9NYXRjaCkuc291cmNlLFxuICAgICAgKHNldHRpbmdzLmludGVycG9sYXRlIHx8IG5vTWF0Y2gpLnNvdXJjZSxcbiAgICAgIChzZXR0aW5ncy5ldmFsdWF0ZSB8fCBub01hdGNoKS5zb3VyY2VcbiAgICBdLmpvaW4oJ3wnKSArICd8JCcsICdnJyk7XG5cbiAgICAvLyBDb21waWxlIHRoZSB0ZW1wbGF0ZSBzb3VyY2UsIGVzY2FwaW5nIHN0cmluZyBsaXRlcmFscyBhcHByb3ByaWF0ZWx5LlxuICAgIHZhciBpbmRleCA9IDA7XG4gICAgdmFyIHNvdXJjZSA9IFwiX19wKz0nXCI7XG4gICAgdGV4dC5yZXBsYWNlKG1hdGNoZXIsIGZ1bmN0aW9uKG1hdGNoLCBlc2NhcGUsIGludGVycG9sYXRlLCBldmFsdWF0ZSwgb2Zmc2V0KSB7XG4gICAgICBzb3VyY2UgKz0gdGV4dC5zbGljZShpbmRleCwgb2Zmc2V0KS5yZXBsYWNlKGVzY2FwZXIsIGVzY2FwZUNoYXIpO1xuICAgICAgaW5kZXggPSBvZmZzZXQgKyBtYXRjaC5sZW5ndGg7XG5cbiAgICAgIGlmIChlc2NhcGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBlc2NhcGUgKyBcIikpPT1udWxsPycnOl8uZXNjYXBlKF9fdCkpK1xcbidcIjtcbiAgICAgIH0gZWxzZSBpZiAoaW50ZXJwb2xhdGUpIHtcbiAgICAgICAgc291cmNlICs9IFwiJytcXG4oKF9fdD0oXCIgKyBpbnRlcnBvbGF0ZSArIFwiKSk9PW51bGw/Jyc6X190KStcXG4nXCI7XG4gICAgICB9IGVsc2UgaWYgKGV2YWx1YXRlKSB7XG4gICAgICAgIHNvdXJjZSArPSBcIic7XFxuXCIgKyBldmFsdWF0ZSArIFwiXFxuX19wKz0nXCI7XG4gICAgICB9XG5cbiAgICAgIC8vIEFkb2JlIFZNcyBuZWVkIHRoZSBtYXRjaCByZXR1cm5lZCB0byBwcm9kdWNlIHRoZSBjb3JyZWN0IG9mZmVzdC5cbiAgICAgIHJldHVybiBtYXRjaDtcbiAgICB9KTtcbiAgICBzb3VyY2UgKz0gXCInO1xcblwiO1xuXG4gICAgLy8gSWYgYSB2YXJpYWJsZSBpcyBub3Qgc3BlY2lmaWVkLCBwbGFjZSBkYXRhIHZhbHVlcyBpbiBsb2NhbCBzY29wZS5cbiAgICBpZiAoIXNldHRpbmdzLnZhcmlhYmxlKSBzb3VyY2UgPSAnd2l0aChvYmp8fHt9KXtcXG4nICsgc291cmNlICsgJ31cXG4nO1xuXG4gICAgc291cmNlID0gXCJ2YXIgX190LF9fcD0nJyxfX2o9QXJyYXkucHJvdG90eXBlLmpvaW4sXCIgK1xuICAgICAgXCJwcmludD1mdW5jdGlvbigpe19fcCs9X19qLmNhbGwoYXJndW1lbnRzLCcnKTt9O1xcblwiICtcbiAgICAgIHNvdXJjZSArICdyZXR1cm4gX19wO1xcbic7XG5cbiAgICB0cnkge1xuICAgICAgdmFyIHJlbmRlciA9IG5ldyBGdW5jdGlvbihzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJywgJ18nLCBzb3VyY2UpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGUuc291cmNlID0gc291cmNlO1xuICAgICAgdGhyb3cgZTtcbiAgICB9XG5cbiAgICB2YXIgdGVtcGxhdGUgPSBmdW5jdGlvbihkYXRhKSB7XG4gICAgICByZXR1cm4gcmVuZGVyLmNhbGwodGhpcywgZGF0YSwgXyk7XG4gICAgfTtcblxuICAgIC8vIFByb3ZpZGUgdGhlIGNvbXBpbGVkIHNvdXJjZSBhcyBhIGNvbnZlbmllbmNlIGZvciBwcmVjb21waWxhdGlvbi5cbiAgICB2YXIgYXJndW1lbnQgPSBzZXR0aW5ncy52YXJpYWJsZSB8fCAnb2JqJztcbiAgICB0ZW1wbGF0ZS5zb3VyY2UgPSAnZnVuY3Rpb24oJyArIGFyZ3VtZW50ICsgJyl7XFxuJyArIHNvdXJjZSArICd9JztcblxuICAgIHJldHVybiB0ZW1wbGF0ZTtcbiAgfTtcblxuICAvLyBBZGQgYSBcImNoYWluXCIgZnVuY3Rpb24uIFN0YXJ0IGNoYWluaW5nIGEgd3JhcHBlZCBVbmRlcnNjb3JlIG9iamVjdC5cbiAgXy5jaGFpbiA9IGZ1bmN0aW9uKG9iaikge1xuICAgIHZhciBpbnN0YW5jZSA9IF8ob2JqKTtcbiAgICBpbnN0YW5jZS5fY2hhaW4gPSB0cnVlO1xuICAgIHJldHVybiBpbnN0YW5jZTtcbiAgfTtcblxuICAvLyBPT1BcbiAgLy8gLS0tLS0tLS0tLS0tLS0tXG4gIC8vIElmIFVuZGVyc2NvcmUgaXMgY2FsbGVkIGFzIGEgZnVuY3Rpb24sIGl0IHJldHVybnMgYSB3cmFwcGVkIG9iamVjdCB0aGF0XG4gIC8vIGNhbiBiZSB1c2VkIE9PLXN0eWxlLiBUaGlzIHdyYXBwZXIgaG9sZHMgYWx0ZXJlZCB2ZXJzaW9ucyBvZiBhbGwgdGhlXG4gIC8vIHVuZGVyc2NvcmUgZnVuY3Rpb25zLiBXcmFwcGVkIG9iamVjdHMgbWF5IGJlIGNoYWluZWQuXG5cbiAgLy8gSGVscGVyIGZ1bmN0aW9uIHRvIGNvbnRpbnVlIGNoYWluaW5nIGludGVybWVkaWF0ZSByZXN1bHRzLlxuICB2YXIgcmVzdWx0ID0gZnVuY3Rpb24oaW5zdGFuY2UsIG9iaikge1xuICAgIHJldHVybiBpbnN0YW5jZS5fY2hhaW4gPyBfKG9iaikuY2hhaW4oKSA6IG9iajtcbiAgfTtcblxuICAvLyBBZGQgeW91ciBvd24gY3VzdG9tIGZ1bmN0aW9ucyB0byB0aGUgVW5kZXJzY29yZSBvYmplY3QuXG4gIF8ubWl4aW4gPSBmdW5jdGlvbihvYmopIHtcbiAgICBfLmVhY2goXy5mdW5jdGlvbnMob2JqKSwgZnVuY3Rpb24obmFtZSkge1xuICAgICAgdmFyIGZ1bmMgPSBfW25hbWVdID0gb2JqW25hbWVdO1xuICAgICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbdGhpcy5fd3JhcHBlZF07XG4gICAgICAgIHB1c2guYXBwbHkoYXJncywgYXJndW1lbnRzKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdCh0aGlzLCBmdW5jLmFwcGx5KF8sIGFyZ3MpKTtcbiAgICAgIH07XG4gICAgfSk7XG4gIH07XG5cbiAgLy8gQWRkIGFsbCBvZiB0aGUgVW5kZXJzY29yZSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIgb2JqZWN0LlxuICBfLm1peGluKF8pO1xuXG4gIC8vIEFkZCBhbGwgbXV0YXRvciBBcnJheSBmdW5jdGlvbnMgdG8gdGhlIHdyYXBwZXIuXG4gIF8uZWFjaChbJ3BvcCcsICdwdXNoJywgJ3JldmVyc2UnLCAnc2hpZnQnLCAnc29ydCcsICdzcGxpY2UnLCAndW5zaGlmdCddLCBmdW5jdGlvbihuYW1lKSB7XG4gICAgdmFyIG1ldGhvZCA9IEFycmF5UHJvdG9bbmFtZV07XG4gICAgXy5wcm90b3R5cGVbbmFtZV0gPSBmdW5jdGlvbigpIHtcbiAgICAgIHZhciBvYmogPSB0aGlzLl93cmFwcGVkO1xuICAgICAgbWV0aG9kLmFwcGx5KG9iaiwgYXJndW1lbnRzKTtcbiAgICAgIGlmICgobmFtZSA9PT0gJ3NoaWZ0JyB8fCBuYW1lID09PSAnc3BsaWNlJykgJiYgb2JqLmxlbmd0aCA9PT0gMCkgZGVsZXRlIG9ialswXTtcbiAgICAgIHJldHVybiByZXN1bHQodGhpcywgb2JqKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBBZGQgYWxsIGFjY2Vzc29yIEFycmF5IGZ1bmN0aW9ucyB0byB0aGUgd3JhcHBlci5cbiAgXy5lYWNoKFsnY29uY2F0JywgJ2pvaW4nLCAnc2xpY2UnXSwgZnVuY3Rpb24obmFtZSkge1xuICAgIHZhciBtZXRob2QgPSBBcnJheVByb3RvW25hbWVdO1xuICAgIF8ucHJvdG90eXBlW25hbWVdID0gZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gcmVzdWx0KHRoaXMsIG1ldGhvZC5hcHBseSh0aGlzLl93cmFwcGVkLCBhcmd1bWVudHMpKTtcbiAgICB9O1xuICB9KTtcblxuICAvLyBFeHRyYWN0cyB0aGUgcmVzdWx0IGZyb20gYSB3cmFwcGVkIGFuZCBjaGFpbmVkIG9iamVjdC5cbiAgXy5wcm90b3R5cGUudmFsdWUgPSBmdW5jdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fd3JhcHBlZDtcbiAgfTtcblxuICAvLyBQcm92aWRlIHVud3JhcHBpbmcgcHJveHkgZm9yIHNvbWUgbWV0aG9kcyB1c2VkIGluIGVuZ2luZSBvcGVyYXRpb25zXG4gIC8vIHN1Y2ggYXMgYXJpdGhtZXRpYyBhbmQgSlNPTiBzdHJpbmdpZmljYXRpb24uXG4gIF8ucHJvdG90eXBlLnZhbHVlT2YgPSBfLnByb3RvdHlwZS50b0pTT04gPSBfLnByb3RvdHlwZS52YWx1ZTtcblxuICBfLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiAnJyArIHRoaXMuX3dyYXBwZWQ7XG4gIH07XG5cbiAgLy8gQU1EIHJlZ2lzdHJhdGlvbiBoYXBwZW5zIGF0IHRoZSBlbmQgZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBBTUQgbG9hZGVyc1xuICAvLyB0aGF0IG1heSBub3QgZW5mb3JjZSBuZXh0LXR1cm4gc2VtYW50aWNzIG9uIG1vZHVsZXMuIEV2ZW4gdGhvdWdoIGdlbmVyYWxcbiAgLy8gcHJhY3RpY2UgZm9yIEFNRCByZWdpc3RyYXRpb24gaXMgdG8gYmUgYW5vbnltb3VzLCB1bmRlcnNjb3JlIHJlZ2lzdGVyc1xuICAvLyBhcyBhIG5hbWVkIG1vZHVsZSBiZWNhdXNlLCBsaWtlIGpRdWVyeSwgaXQgaXMgYSBiYXNlIGxpYnJhcnkgdGhhdCBpc1xuICAvLyBwb3B1bGFyIGVub3VnaCB0byBiZSBidW5kbGVkIGluIGEgdGhpcmQgcGFydHkgbGliLCBidXQgbm90IGJlIHBhcnQgb2ZcbiAgLy8gYW4gQU1EIGxvYWQgcmVxdWVzdC4gVGhvc2UgY2FzZXMgY291bGQgZ2VuZXJhdGUgYW4gZXJyb3Igd2hlbiBhblxuICAvLyBhbm9ueW1vdXMgZGVmaW5lKCkgaXMgY2FsbGVkIG91dHNpZGUgb2YgYSBsb2FkZXIgcmVxdWVzdC5cbiAgaWYgKHR5cGVvZiBkZWZpbmUgPT09ICdmdW5jdGlvbicgJiYgZGVmaW5lLmFtZCkge1xuICAgIGRlZmluZSgndW5kZXJzY29yZScsIFtdLCBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBfO1xuICAgIH0pO1xuICB9XG59LmNhbGwodGhpcykpO1xuIiwiIyBWZXhUYWIgQXJ0aXN0XG4jIENvcHlyaWdodCAyMDEyIE1vaGl0IENoZXBwdWRpcmEgPG1vaGl0QG11dGhhbm5hLmNvbT5cbiNcbiMgVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIHRoZSBlbGVtZW50c1xuIyBwYXJzZWQgYnkgVmV4LkZsb3cuVmV4VGFiLlxuXG5cblZleCA9IHJlcXVpcmUgJ3ZleGZsb3cnXG5fID0gcmVxdWlyZSAndW5kZXJzY29yZSdcblxuY2xhc3MgQXJ0aXN0XG4gIEBERUJVRyA9IGZhbHNlXG4gIEwgPSAoYXJncy4uLikgLT4gY29uc29sZT8ubG9nKFwiKFZleC5GbG93LkFydGlzdClcIiwgYXJncy4uLikgaWYgQXJ0aXN0LkRFQlVHXG5cbiAgQE5PTE9HTyA9IGZhbHNlXG5cbiAgY29uc3RydWN0b3I6IChAeCwgQHksIEB3aWR0aCwgb3B0aW9ucykgLT5cbiAgICBAb3B0aW9ucyA9XG4gICAgICBmb250X2ZhY2U6IFwiQXJpYWxcIlxuICAgICAgZm9udF9zaXplOiAxMFxuICAgICAgZm9udF9zdHlsZTogbnVsbFxuICAgICAgYm90dG9tX3NwYWNpbmc6IDIwICsgKGlmIEFydGlzdC5OT0xPR08gdGhlbiAwIGVsc2UgMTApXG4gICAgICB0YWJfc3RhdmVfbG93ZXJfc3BhY2luZzogMTBcbiAgICAgIG5vdGVfc3RhdmVfbG93ZXJfc3BhY2luZzogMFxuICAgICAgc2NhbGU6IDEuMFxuICAgIF8uZXh0ZW5kKEBvcHRpb25zLCBvcHRpb25zKSBpZiBvcHRpb25zP1xuICAgIEByZXNldCgpXG5cbiAgcmVzZXQ6IC0+XG4gICAgQHR1bmluZyA9IG5ldyBWZXguRmxvdy5UdW5pbmcoKVxuICAgIEBrZXlfbWFuYWdlciA9IG5ldyBWZXguRmxvdy5LZXlNYW5hZ2VyKFwiQ1wiKVxuICAgIEBtdXNpY19hcGkgPSBuZXcgVmV4LkZsb3cuTXVzaWMoKVxuXG4gICAgIyBVc2VyIGN1c3RvbWl6YXRpb25zXG4gICAgQGN1c3RvbWl6YXRpb25zID1cbiAgICAgIFwiZm9udC1zaXplXCI6IEBvcHRpb25zLmZvbnRfc2l6ZVxuICAgICAgXCJmb250LWZhY2VcIjogQG9wdGlvbnMuZm9udF9mYWNlXG4gICAgICBcImZvbnQtc3R5bGVcIjogQG9wdGlvbnMuZm9udF9zdHlsZVxuICAgICAgXCJhbm5vdGF0aW9uLXBvc2l0aW9uXCI6IFwiYm90dG9tXCJcbiAgICAgIFwic2NhbGVcIjogQG9wdGlvbnMuc2NhbGVcbiAgICAgIFwid2lkdGhcIjogQHdpZHRoXG4gICAgICBcInN0YXZlLWRpc3RhbmNlXCI6IDBcbiAgICAgIFwic3BhY2VcIjogMFxuICAgICAgXCJwbGF5ZXJcIjogXCJmYWxzZVwiXG4gICAgICBcInRlbXBvXCI6IDEyMFxuICAgICAgXCJpbnN0cnVtZW50XCI6IFwiYWNvdXN0aWNfZ3JhbmRfcGlhbm9cIlxuICAgICAgXCJhY2NpZGVudGFsc1wiOiBcInN0YW5kYXJkXCIgICMgc3RhbmRhcmQgLyBjYXV0aW9uYXJ5XG4gICAgICBcInRhYi1zdGVtc1wiOiBcImZhbHNlXCJcbiAgICAgIFwidGFiLXN0ZW0tZGlyZWN0aW9uXCI6IFwidXBcIlxuICAgICAgXCJiZWFtLXJlc3RzXCI6IFwidHJ1ZVwiXG4gICAgICBcImJlYW0tc3RlbWxldHNcIjogXCJ0cnVlXCJcbiAgICAgIFwiYmVhbS1taWRkbGUtb25seVwiOiBcImZhbHNlXCJcbiAgICAgIFwiY29ubmVjdG9yLXNwYWNlXCI6IDBcblxuICAgICMgR2VuZXJhdGVkIGVsZW1lbnRzXG4gICAgQHN0YXZlZ3JvdXBzID0gW11cbiMgICAgQHN0YXZlcyA9IFtdXG4gICAgQHRhYl9hcnRpY3VsYXRpb25zID0gW11cbiAgICBAc3RhdmVfYXJ0aWN1bGF0aW9ucyA9IFtdXG5cbiAgICAjIFN0YXZlcyBmb3IgcGxheWVyXG4gICAgQHBsYXllcl9zdGF2ZXMgPSBbXVxuXG4gICAgIyBDdXJyZW50IHN0YXRlXG4gICAgQGxhc3RfeSA9IEB5XG4gICAgQGN1cnJlbnRfZHVyYXRpb24gPSBcInFcIlxuICAgIEBjdXJyZW50X2NsZWYgPSBcInRyZWJsZVwiXG4gICAgQGN1cnJlbnRfYmVuZHMgPSB7fVxuICAgIEBjdXJyZW50X29jdGF2ZV9zaGlmdCA9IDBcbiAgICBAYmVuZF9zdGFydF9pbmRleCA9IG51bGxcbiAgICBAYmVuZF9zdGFydF9zdHJpbmdzID0gbnVsbFxuICAgIEByZW5kZXJlZCA9IGZhbHNlXG4gICAgQHJlbmRlcmVyX2NvbnRleHQgPSBudWxsXG5cbiAgYXR0YWNoUGxheWVyOiAocGxheWVyKSAtPlxuICAgIGlmICFAcGxheWVyXG4gICAgICBAcGxheWVyID0gcGxheWVyXG5cbiAgc2V0T3B0aW9uczogKG9wdGlvbnMpIC0+XG4gICAgTCBcInNldE9wdGlvbnM6IFwiLCBvcHRpb25zXG4gICAgIyBTZXQgQGN1c3RvbWl6YXRpb25zXG4gICAgdmFsaWRfb3B0aW9ucyA9IF8ua2V5cyhAY3VzdG9taXphdGlvbnMpXG4gICAgZm9yIGssIHYgb2Ygb3B0aW9uc1xuICAgICAgaWYgayBpbiB2YWxpZF9vcHRpb25zXG4gICAgICAgIEBjdXN0b21pemF0aW9uc1trXSA9IHZcbiAgICAgIGVsc2VcbiAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQXJ0aXN0RXJyb3JcIiwgXCJJbnZhbGlkIG9wdGlvbiAnI3trfSdcIilcblxuICAgIEBsYXN0X3kgKz0gcGFyc2VJbnQoQGN1c3RvbWl6YXRpb25zLnNwYWNlLCAxMClcbiAgICBAbGFzdF95ICs9IDEgaWYgQGN1c3RvbWl6YXRpb25zLnBsYXllciBpcyBcInRydWVcIlxuXG4gIGdldFBsYXllckRhdGE6IC0+XG4gICAgc3RhdmVzOiBAcGxheWVyX3N0YXZlc1xuICAgIGNvbnRleHQ6IEByZW5kZXJlcl9jb250ZXh0XG4gICAgc2NhbGU6IEBjdXN0b21pemF0aW9ucy5zY2FsZVxuXG4gIHBhcnNlQm9vbCA9IChzdHIpIC0+XG4gICAgcmV0dXJuIChzdHIgPT0gXCJ0cnVlXCIpXG5cbiAgZm9ybWF0QW5kUmVuZGVyID0gKGN0eCwgdGFiLCBzY29yZSwgdGV4dF9ub3RlcywgY3VzdG9taXphdGlvbnMsIG9wdGlvbnMpIC0+XG4gICAgdGFiX3N0YXZlID0gdGFiLnN0YXZlIGlmIHRhYj9cbiAgICBzY29yZV9zdGF2ZSA9IHNjb3JlLnN0YXZlIGlmIHNjb3JlP1xuXG4gICAgdGFiX3ZvaWNlcyA9IFtdXG4gICAgc2NvcmVfdm9pY2VzID0gW11cbiAgICB0ZXh0X3ZvaWNlcyA9IFtdXG4gICAgYmVhbXMgPSBbXVxuICAgIGZvcm1hdF9zdGF2ZSA9IG51bGxcbiAgICB0ZXh0X3N0YXZlID0gbnVsbFxuXG4gICAgYmVhbV9jb25maWcgPVxuICAgICAgYmVhbV9yZXN0czogcGFyc2VCb29sKGN1c3RvbWl6YXRpb25zW1wiYmVhbS1yZXN0c1wiXSlcbiAgICAgIHNob3dfc3RlbWxldHM6IHBhcnNlQm9vbChjdXN0b21pemF0aW9uc1tcImJlYW0tc3RlbWxldHNcIl0pXG4gICAgICBiZWFtX21pZGRsZV9vbmx5OiBwYXJzZUJvb2woY3VzdG9taXphdGlvbnNbXCJiZWFtLW1pZGRsZS1vbmx5XCJdKVxuICAgICAgZ3JvdXBzOiBvcHRpb25zLmJlYW1fZ3JvdXBzXG5cbiAgICBpZiB0YWI/XG4gICAgICBtdWx0aV92b2ljZSA9IGlmICh0YWIudm9pY2VzLmxlbmd0aCA+IDEpIHRoZW4gdHJ1ZSBlbHNlIGZhbHNlXG4gICAgICBmb3Igbm90ZXMsIGkgaW4gdGFiLnZvaWNlc1xuICAgICAgICBjb250aW51ZSBpZiBfLmlzRW1wdHkobm90ZXMpXG4gICAgICAgIF8uZWFjaChub3RlcywgKG5vdGUpIC0+IG5vdGUuc2V0U3RhdmUodGFiX3N0YXZlKSlcbiAgICAgICAgdm9pY2UgPSBuZXcgVmV4LkZsb3cuVm9pY2UoVmV4LkZsb3cuVElNRTRfNCkuXG4gICAgICAgICAgc2V0TW9kZShWZXguRmxvdy5Wb2ljZS5Nb2RlLlNPRlQpXG4gICAgICAgIHZvaWNlLmFkZFRpY2thYmxlcyBub3Rlc1xuICAgICAgICB0YWJfdm9pY2VzLnB1c2ggdm9pY2VcblxuICAgICAgICBpZiBjdXN0b21pemF0aW9uc1tcInRhYi1zdGVtc1wiXSA9PSBcInRydWVcIlxuICAgICAgICAgIGlmIG11bHRpX3ZvaWNlXG4gICAgICAgICAgICBiZWFtX2NvbmZpZy5zdGVtX2RpcmVjdGlvbiA9IGlmIGkgPT0gMCB0aGVuIDEgZWxzZSAtMVxuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGJlYW1fY29uZmlnLnN0ZW1fZGlyZWN0aW9uID0gaWYgY3VzdG9taXphdGlvbnNbXCJ0YWItc3RlbS1kaXJlY3Rpb25cIl0gPT0gXCJkb3duXCIgdGhlbiAtMSBlbHNlIDFcblxuICAgICAgICAgIGJlYW1fY29uZmlnLmJlYW1fcmVzdHMgPSBmYWxzZVxuICAgICAgICAgIGJlYW1zID0gYmVhbXMuY29uY2F0KFZleC5GbG93LkJlYW0uZ2VuZXJhdGVCZWFtcyh2b2ljZS5nZXRUaWNrYWJsZXMoKSwgYmVhbV9jb25maWcpKVxuXG4gICAgICBmb3JtYXRfc3RhdmUgPSB0YWJfc3RhdmVcbiAgICAgIHRleHRfc3RhdmUgPSB0YWJfc3RhdmVcblxuICAgIGJlYW1fY29uZmlnLmJlYW1fcmVzdHMgPSBwYXJzZUJvb2woY3VzdG9taXphdGlvbnNbXCJiZWFtLXJlc3RzXCJdKVxuXG4gICAgaWYgc2NvcmU/XG4gICAgICBtdWx0aV92b2ljZSA9IGlmIChzY29yZS52b2ljZXMubGVuZ3RoID4gMSkgdGhlbiB0cnVlIGVsc2UgZmFsc2VcbiAgICAgIGZvciBub3RlcywgaSBpbiBzY29yZS52b2ljZXNcbiAgICAgICAgY29udGludWUgaWYgXy5pc0VtcHR5KG5vdGVzKVxuICAgICAgICBzdGVtX2RpcmVjdGlvbiA9IGlmIGkgPT0gMCB0aGVuIDEgZWxzZSAtMVxuICAgICAgICBfLmVhY2gobm90ZXMsIChub3RlKSAtPiBub3RlLnNldFN0YXZlKHNjb3JlX3N0YXZlKSlcblxuICAgICAgICB2b2ljZSA9IG5ldyBWZXguRmxvdy5Wb2ljZShWZXguRmxvdy5USU1FNF80KS5cbiAgICAgICAgICBzZXRNb2RlKFZleC5GbG93LlZvaWNlLk1vZGUuU09GVClcbiAgICAgICAgdm9pY2UuYWRkVGlja2FibGVzIG5vdGVzXG4gICAgICAgIHNjb3JlX3ZvaWNlcy5wdXNoIHZvaWNlXG4gICAgICAgIGlmIG11bHRpX3ZvaWNlXG4gICAgICAgICAgYmVhbV9jb25maWcuc3RlbV9kaXJlY3Rpb24gPSBzdGVtX2RpcmVjdGlvblxuICAgICAgICAgIGJlYW1zID0gYmVhbXMuY29uY2F0KFZleC5GbG93LkJlYW0uZ2VuZXJhdGVCZWFtcyhub3RlcywgYmVhbV9jb25maWcpKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYmVhbV9jb25maWcuc3RlbV9kaXJlY3Rpb24gPSBudWxsXG4gICAgICAgICAgYmVhbXMgPSBiZWFtcy5jb25jYXQoVmV4LkZsb3cuQmVhbS5nZW5lcmF0ZUJlYW1zKG5vdGVzLCBiZWFtX2NvbmZpZykpXG5cbiAgICAgIGZvcm1hdF9zdGF2ZSA9IHNjb3JlX3N0YXZlXG4gICAgICB0ZXh0X3N0YXZlID0gc2NvcmVfc3RhdmVcblxuICAgIGZvciBub3RlcyBpbiB0ZXh0X25vdGVzXG4gICAgICBjb250aW51ZSBpZiBfLmlzRW1wdHkobm90ZXMpXG4gICAgICBfLmVhY2gobm90ZXMsICh2b2ljZSkgLT4gdm9pY2Uuc2V0U3RhdmUodGV4dF9zdGF2ZSkpXG4gICAgICB2b2ljZSA9IG5ldyBWZXguRmxvdy5Wb2ljZShWZXguRmxvdy5USU1FNF80KS5cbiAgICAgICAgICBzZXRNb2RlKFZleC5GbG93LlZvaWNlLk1vZGUuU09GVClcbiAgICAgIHZvaWNlLmFkZFRpY2thYmxlcyBub3Rlc1xuICAgICAgdGV4dF92b2ljZXMucHVzaCB2b2ljZVxuXG4gICAgaWYgZm9ybWF0X3N0YXZlP1xuICAgICAgZm9ybWF0X3ZvaWNlcyA9IFtdXG4gICAgICBmb3JtYXR0ZXIgPSBuZXcgVmV4LkZsb3cuRm9ybWF0dGVyKClcbiAgICAgIGFsaWduX3Jlc3RzID0gZmFsc2VcblxuICAgICAgaWYgdGFiP1xuICAgICAgICBmb3JtYXR0ZXIuam9pblZvaWNlcyh0YWJfdm9pY2VzKSB1bmxlc3MgXy5pc0VtcHR5KHRhYl92b2ljZXMpXG4gICAgICAgIGZvcm1hdF92b2ljZXMgPSB0YWJfdm9pY2VzXG5cbiAgICAgIGlmIHNjb3JlP1xuICAgICAgICBmb3JtYXR0ZXIuam9pblZvaWNlcyhzY29yZV92b2ljZXMpIHVubGVzcyBfLmlzRW1wdHkoc2NvcmVfdm9pY2VzKVxuICAgICAgICBmb3JtYXRfdm9pY2VzID0gZm9ybWF0X3ZvaWNlcy5jb25jYXQoc2NvcmVfdm9pY2VzKVxuICAgICAgICBhbGlnbl9yZXN0cyA9IHRydWUgaWYgc2NvcmVfdm9pY2VzLmxlbmd0aCA+IDFcblxuICAgICAgaWYgbm90IF8uaXNFbXB0eSh0ZXh0X25vdGVzKSBhbmQgbm90IF8uaXNFbXB0eSh0ZXh0X3ZvaWNlcylcbiAgICAgICAgZm9ybWF0dGVyLmpvaW5Wb2ljZXModGV4dF92b2ljZXMpXG4gICAgICAgIGZvcm1hdF92b2ljZXMgPSBmb3JtYXRfdm9pY2VzLmNvbmNhdCh0ZXh0X3ZvaWNlcylcblxuICAgICAgZm9ybWF0dGVyLmZvcm1hdFRvU3RhdmUoZm9ybWF0X3ZvaWNlcywgZm9ybWF0X3N0YXZlLCB7YWxpZ25fcmVzdHM6IGFsaWduX3Jlc3RzfSkgdW5sZXNzIF8uaXNFbXB0eShmb3JtYXRfdm9pY2VzKVxuXG4gICAgICBfLmVhY2godGFiX3ZvaWNlcywgKHZvaWNlKSAtPiB2b2ljZS5kcmF3KGN0eCwgdGFiX3N0YXZlKSkgaWYgdGFiP1xuICAgICAgXy5lYWNoKHNjb3JlX3ZvaWNlcywgKHZvaWNlKSAtPiB2b2ljZS5kcmF3KGN0eCwgc2NvcmVfc3RhdmUpKSBpZiBzY29yZT9cbiAgICAgIF8uZWFjaChiZWFtcywgKGJlYW0pIC0+IGJlYW0uc2V0Q29udGV4dChjdHgpLmRyYXcoKSlcbiAgICAgIF8uZWFjaCh0ZXh0X3ZvaWNlcywgKHZvaWNlKSAtPiB2b2ljZS5kcmF3KGN0eCwgdGV4dF9zdGF2ZSkpIGlmIG5vdCBfLmlzRW1wdHkodGV4dF9ub3RlcylcblxuICAgICAgaWYgdGFiPyBhbmQgc2NvcmU/XG4gICAgICAgIChuZXcgVmV4LkZsb3cuU3RhdmVDb25uZWN0b3Ioc2NvcmUuc3RhdmUsIHRhYi5zdGF2ZSkpLnNldENvbnRleHQoY3R4KS5kcmF3KClcblxuICAgICAgaWYgc2NvcmU/IHRoZW4gc2NvcmVfdm9pY2VzIGVsc2UgdGFiX3ZvaWNlc1xuXG4gIHJlbmRlcjogKHJlbmRlcmVyKSAtPlxuICAgIEwgXCJSZW5kZXI6IFwiLCBAb3B0aW9uc1xuICAgIEBjbG9zZUJlbmRzKClcbiAgICByZW5kZXJlci5yZXNpemUoQGN1c3RvbWl6YXRpb25zLndpZHRoICogQGN1c3RvbWl6YXRpb25zLnNjYWxlLFxuICAgICAgICAoQGxhc3RfeSArIEBvcHRpb25zLmJvdHRvbV9zcGFjaW5nKSAqIEBjdXN0b21pemF0aW9ucy5zY2FsZSlcbiAgICBjdHggPSByZW5kZXJlci5nZXRDb250ZXh0KClcbiAgICBjdHguc2NhbGUoQGN1c3RvbWl6YXRpb25zLnNjYWxlLCBAY3VzdG9taXphdGlvbnMuc2NhbGUpXG4gICAgY3R4LmNsZWFyKClcbiAgICBjdHguc2V0Rm9udChAb3B0aW9ucy5mb250X2ZhY2UsIEBvcHRpb25zLmZvbnRfc2l6ZSwgXCJcIilcblxuICAgIEByZW5kZXJlcl9jb250ZXh0ID0gY3R4XG5cbiAgICBzZXRCYXIgPSAoc3RhdmUsIG5vdGVzKSAtPlxuICAgICAgbGFzdF9ub3RlID0gXy5sYXN0KG5vdGVzKVxuICAgICAgaWYgbGFzdF9ub3RlIGluc3RhbmNlb2YgVmV4LkZsb3cuQmFyTm90ZVxuICAgICAgICBub3Rlcy5wb3AoKVxuICAgICAgICBzdGF2ZS5zZXRFbmRCYXJUeXBlKGxhc3Rfbm90ZS5nZXRUeXBlKCkpXG5cbiAgICBmb3Igc3RhdmVncm91cCBpbiBAc3RhdmVncm91cHNcbiAgICAgIEwgXCJSZW5kZXJpbmcgc3RhdmVncm91cHMuXCJcblxuICAgICAgc3RhdmVzID0gW11cblxuICAgICAgZm9yIHN0YXZlIGluIHN0YXZlZ3JvdXAuc3RhdmVzXG4gICAgICAgIEwgXCJSZW5kZXJpbmcgc3RhdmVzLlwiXG4gICAgICAgICMgSWYgdGhlIGxhc3Qgbm90ZSBpcyBhIGJhciwgdGhlbiByZW1vdmUgaXQgYW5kIHJlbmRlciBpdCBhcyBhIHN0YXZlIG1vZGlmaWVyLlxuICAgICAgICBzZXRCYXIoc3RhdmUudGFiLCBzdGF2ZS50YWJfbm90ZXMpIGlmIHN0YXZlLnRhYj9cbiAgICAgICAgc2V0QmFyKHN0YXZlLm5vdGUsIHN0YXZlLm5vdGVfbm90ZXMpIGlmIHN0YXZlLm5vdGU/XG4gIFxuICAgICAgICBzdGF2ZS50YWIuc2V0Q29udGV4dChjdHgpLmRyYXcoKSBpZiBzdGF2ZS50YWI/XG4gICAgICAgIHN0YXZlLm5vdGUuc2V0Q29udGV4dChjdHgpLmRyYXcoKSBpZiBzdGF2ZS5ub3RlP1xuICBcbiAgICAgICAgc3RhdmUudGFiX3ZvaWNlcy5wdXNoKHN0YXZlLnRhYl9ub3RlcylcbiAgICAgICAgc3RhdmUubm90ZV92b2ljZXMucHVzaChzdGF2ZS5ub3RlX25vdGVzKVxuICBcbiAgICAgICAgdm9pY2VzID0gZm9ybWF0QW5kUmVuZGVyKGN0eCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIHN0YXZlLnRhYj8gdGhlbiB7c3RhdmU6IHN0YXZlLnRhYiwgdm9pY2VzOiBzdGF2ZS50YWJfdm9pY2VzfSBlbHNlIG51bGwsXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiBzdGF2ZS5ub3RlPyB0aGVuIHtzdGF2ZTogc3RhdmUubm90ZSwgdm9pY2VzOiBzdGF2ZS5ub3RlX3ZvaWNlc30gZWxzZSBudWxsLFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdmUudGV4dF92b2ljZXMsXG4gICAgICAgICAgICAgICAgICAgICAgICBAY3VzdG9taXphdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB7YmVhbV9ncm91cHM6IHN0YXZlLmJlYW1fZ3JvdXBzfSlcbiAgXG4gICAgICAgIHN0YXZlcy5wdXNoKHZvaWNlcylcbiAgICBAcGxheWVyX3N0YXZlcy5wdXNoKHN0YXZlcylcblxuICAgIEwgXCJSZW5kZXJpbmcgdGFiIGFydGljdWxhdGlvbnMuXCJcbiAgICBmb3IgYXJ0aWN1bGF0aW9uIGluIEB0YWJfYXJ0aWN1bGF0aW9uc1xuICAgICAgYXJ0aWN1bGF0aW9uLnNldENvbnRleHQoY3R4KS5kcmF3KClcblxuICAgIEwgXCJSZW5kZXJpbmcgbm90ZSBhcnRpY3VsYXRpb25zLlwiXG4gICAgZm9yIGFydGljdWxhdGlvbiBpbiBAc3RhdmVfYXJ0aWN1bGF0aW9uc1xuICAgICAgYXJ0aWN1bGF0aW9uLnNldENvbnRleHQoY3R4KS5kcmF3KClcblxuICAgIGlmIEBwbGF5ZXI/XG4gICAgICBpZiBAY3VzdG9taXphdGlvbnMucGxheWVyIGlzIFwidHJ1ZVwiXG4gICAgICAgIEBwbGF5ZXIuc2V0VGVtcG8ocGFyc2VJbnQoQGN1c3RvbWl6YXRpb25zLnRlbXBvLCAxMCkpXG4gICAgICAgIEBwbGF5ZXIuc2V0SW5zdHJ1bWVudChAY3VzdG9taXphdGlvbnMuaW5zdHJ1bWVudClcbiAgICAgICAgQHBsYXllci5yZW5kZXIoKVxuICAgICAgZWxzZVxuICAgICAgICBAcGxheWVyLnJlbW92ZUNvbnRyb2xzKClcbiAgICBAcmVuZGVyZWQgPSB0cnVlXG5cbiAgICB1bmxlc3MgQXJ0aXN0Lk5PTE9HT1xuICAgICAgTE9HTyA9IFwidmV4Zmxvdy5jb21cIlxuICAgICAgd2lkdGggPSBjdHgubWVhc3VyZVRleHQoTE9HTykud2lkdGhcbiAgICAgIGN0eC5zYXZlKClcbiAgICAgIGN0eC5zZXRGb250KFwiVGltZXNcIiwgMTAsIFwiaXRhbGljXCIpXG4gICAgICBjdHguZmlsbFRleHQoTE9HTywgKEBjdXN0b21pemF0aW9ucy53aWR0aCAtIHdpZHRoKSAvIDIsIEBsYXN0X3kgKyAyNSlcbiAgICAgIGN0eC5yZXN0b3JlKClcblxuICBpc1JlbmRlcmVkOiAtPiBAcmVuZGVyZWRcblxuICBkcmF3OiAocmVuZGVyZXIpIC0+IEByZW5kZXIgcmVuZGVyZXJcblxuICAjIEdpdmVuIGEgZnJldC9zdHJpbmcgcGFpciwgcmV0dXJucyBhIG5vdGUsIG9jdGF2ZSwgYW5kIHJlcXVpcmVkIGFjY2lkZW50YWxzXG4gICMgYmFzZWQgb24gY3VycmVudCBndWl0YXIgdHVuaW5nIGFuZCBzdGF2ZSBrZXkuIFRoZSBhY2NpZGVudGFscyBtYXkgYmUgZGlmZmVyZW50XG4gICMgZm9yIHJlcGVhdHMgb2YgdGhlIHNhbWUgbm90ZXMgYmVjYXVzZSB0aGV5IGdldCBzZXQgKG9yIGNhbmNlbGxlZCkgYnkgdGhlIEtleVxuICAjIE1hbmFnZXIuXG4gIGdldE5vdGVGb3JGcmV0OiAoZnJldCwgc3RyaW5nKSAtPlxuICAgIHNwZWMgPSBAdHVuaW5nLmdldE5vdGVGb3JGcmV0KGZyZXQsIHN0cmluZylcbiAgICBzcGVjX3Byb3BzID0gVmV4LkZsb3cua2V5UHJvcGVydGllcyhzcGVjKVxuXG4gICAgc2VsZWN0ZWRfbm90ZSA9IEBrZXlfbWFuYWdlci5zZWxlY3ROb3RlKHNwZWNfcHJvcHMua2V5KVxuICAgIGFjY2lkZW50YWwgPSBudWxsXG5cbiAgICAjIERvIHdlIG5lZWQgdG8gc3BlY2lmeSBhbiBleHBsaWNpdCBhY2NpZGVudGFsP1xuICAgIHN3aXRjaCBAY3VzdG9taXphdGlvbnMuYWNjaWRlbnRhbHNcbiAgICAgIHdoZW4gXCJzdGFuZGFyZFwiXG4gICAgICAgIGlmIHNlbGVjdGVkX25vdGUuY2hhbmdlXG4gICAgICAgICAgYWNjaWRlbnRhbCA9IGlmIHNlbGVjdGVkX25vdGUuYWNjaWRlbnRhbD8gdGhlbiBzZWxlY3RlZF9ub3RlLmFjY2lkZW50YWwgZWxzZSBcIm5cIlxuICAgICAgd2hlbiBcImNhdXRpb25hcnlcIlxuICAgICAgICBpZiBzZWxlY3RlZF9ub3RlLmNoYW5nZVxuICAgICAgICAgIGFjY2lkZW50YWwgPSBpZiBzZWxlY3RlZF9ub3RlLmFjY2lkZW50YWw/IHRoZW4gc2VsZWN0ZWRfbm90ZS5hY2NpZGVudGFsIGVsc2UgXCJuXCJcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGFjY2lkZW50YWwgPSBpZiBzZWxlY3RlZF9ub3RlLmFjY2lkZW50YWw/IHRoZW4gc2VsZWN0ZWRfbm90ZS5hY2NpZGVudGFsICsgXCJfY1wiXG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkFydGlzdEVycm9yXCIsIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uICdhY2NpZGVudGFscyc6ICN7QGN1c3RvbWl6YXRpb25zLmFjY2lkZW50YWxzfVwiKVxuXG4gICAgbmV3X25vdGUgPSBzZWxlY3RlZF9ub3RlLm5vdGVcbiAgICBuZXdfb2N0YXZlID0gc3BlY19wcm9wcy5vY3RhdmVcblxuICAgICMgVE9ETygweGZlKTogVGhpcyBsb2dpYyBzaG91bGQgcHJvYmFibHkgYmUgaW4gdGhlIEtleU1hbmFnZXIgY29kZVxuICAgIG9sZF9yb290ID0gQG11c2ljX2FwaS5nZXROb3RlUGFydHMoc3BlY19wcm9wcy5rZXkpLnJvb3RcbiAgICBuZXdfcm9vdCA9IEBtdXNpY19hcGkuZ2V0Tm90ZVBhcnRzKHNlbGVjdGVkX25vdGUubm90ZSkucm9vdFxuXG4gICAgIyBGaWd1cmUgb3V0IGlmIHRoZXJlJ3MgYW4gb2N0YXZlIHNoaWZ0IGJhc2VkIG9uIHdoYXQgdGhlIEtleVxuICAgICMgTWFuYWdlciBqdXN0IHRvbGQgdXMgYWJvdXQgdGhlIG5vdGUuXG4gICAgaWYgbmV3X3Jvb3QgPT0gXCJiXCIgYW5kIG9sZF9yb290ID09IFwiY1wiXG4gICAgICBuZXdfb2N0YXZlLS1cbiAgICBlbHNlIGlmIG5ld19yb290ID09IFwiY1wiIGFuZCBvbGRfcm9vdCA9PSBcImJcIlxuICAgICAgbmV3X29jdGF2ZSsrXG5cbiAgICByZXR1cm4gW25ld19ub3RlLCBuZXdfb2N0YXZlLCBhY2NpZGVudGFsXVxuXG4gIGdldE5vdGVGb3JBQkM6IChhYmMsIHN0cmluZykgLT5cbiAgICBrZXkgPSBhYmMua2V5XG4gICAgb2N0YXZlID0gc3RyaW5nXG4gICAgYWNjaWRlbnRhbCA9IGFiYy5hY2NpZGVudGFsXG4gICAgYWNjaWRlbnRhbCArPSBcIl8je2FiYy5hY2NpZGVudGFsX3R5cGV9XCIgaWYgYWJjLmFjY2lkZW50YWxfdHlwZT9cbiAgICByZXR1cm4gW2tleSwgb2N0YXZlLCBhY2NpZGVudGFsXVxuXG4gIGFkZFN0YXZlTm90ZTogKG5vdGVfcGFyYW1zKSAtPlxuICAgIHBhcmFtcyA9XG4gICAgICBpc19yZXN0OiBmYWxzZVxuICAgICAgcGxheV9ub3RlOiBudWxsXG5cbiAgICBfLmV4dGVuZChwYXJhbXMsIG5vdGVfcGFyYW1zKVxuICAgIHN0YXZlX25vdGVzID0gXy5sYXN0KF8ubGFzdChAc3RhdmVncm91cHMpLnN0YXZlcykubm90ZV9ub3Rlc1xuICAgIHN0YXZlX25vdGUgPSBuZXcgVmV4LkZsb3cuU3RhdmVOb3RlKHtcbiAgICAgIGtleXM6IHBhcmFtcy5zcGVjXG4gICAgICBkdXJhdGlvbjogQGN1cnJlbnRfZHVyYXRpb24gKyAoaWYgcGFyYW1zLmlzX3Jlc3QgdGhlbiBcInJcIiBlbHNlIFwiXCIpXG4gICAgICBjbGVmOiBpZiBwYXJhbXMuaXNfcmVzdCB0aGVuIFwidHJlYmxlXCIgZWxzZSBAY3VycmVudF9jbGVmXG4gICAgICBhdXRvX3N0ZW06IGlmIHBhcmFtcy5pc19yZXN0IHRoZW4gZmFsc2UgZWxzZSB0cnVlXG4gICAgfSlcbiAgICBmb3IgYWNjLCBpbmRleCBpbiBwYXJhbXMuYWNjaWRlbnRhbHNcbiAgICAgIGlmIGFjYz9cbiAgICAgICAgcGFydHMgPSBhY2Muc3BsaXQoXCJfXCIpXG4gICAgICAgIG5ld19hY2NpZGVudGFsID0gbmV3IFZleC5GbG93LkFjY2lkZW50YWwocGFydHNbMF0pXG5cbiAgICAgICAgaWYgcGFydHMubGVuZ3RoID4gMSBhbmQgcGFydHNbMV0gPT0gXCJjXCJcbiAgICAgICAgICBuZXdfYWNjaWRlbnRhbC5zZXRBc0NhdXRpb25hcnkoKVxuXG4gICAgICAgIHN0YXZlX25vdGUuYWRkQWNjaWRlbnRhbChpbmRleCwgbmV3X2FjY2lkZW50YWwpXG5cbiAgICBpZiBAY3VycmVudF9kdXJhdGlvbltAY3VycmVudF9kdXJhdGlvbi5sZW5ndGggLSAxXSA9PSBcImRcIlxuICAgICAgc3RhdmVfbm90ZS5hZGREb3RUb0FsbCgpXG5cbiAgICBzdGF2ZV9ub3RlLnNldFBsYXlOb3RlKHBhcmFtcy5wbGF5X25vdGUpIGlmIHBhcmFtcy5wbGF5X25vdGU/XG4gICAgc3RhdmVfbm90ZXMucHVzaCBzdGF2ZV9ub3RlXG5cbiAgYWRkVGFiTm90ZTogKHNwZWMsIHBsYXlfbm90ZT1udWxsKSAtPlxuICAgIHRhYl9ub3RlcyA9IF8ubGFzdChfLmxhc3QoQHN0YXZlZ3JvdXBzKS5zdGF2ZXMpLnRhYl9ub3Rlc1xuICAgIG5ld190YWJfbm90ZSA9IG5ldyBWZXguRmxvdy5UYWJOb3RlKHtcbiAgICAgIHBvc2l0aW9uczogc3BlYyxcbiAgICAgIGR1cmF0aW9uOiBAY3VycmVudF9kdXJhdGlvblxuICAgICAgfSwgKEBjdXN0b21pemF0aW9uc1tcInRhYi1zdGVtc1wiXSA9PSBcInRydWVcIilcbiAgICApXG4gICAgbmV3X3RhYl9ub3RlLnNldFBsYXlOb3RlKHBsYXlfbm90ZSkgaWYgcGxheV9ub3RlP1xuICAgIHRhYl9ub3Rlcy5wdXNoIG5ld190YWJfbm90ZVxuXG4gICAgaWYgQGN1cnJlbnRfZHVyYXRpb25bQGN1cnJlbnRfZHVyYXRpb24ubGVuZ3RoIC0gMV0gPT0gXCJkXCJcbiAgICAgIG5ld190YWJfbm90ZS5hZGREb3QoKVxuXG4gIG1ha2VEdXJhdGlvbiA9ICh0aW1lLCBkb3QpIC0+IHRpbWUgKyAoaWYgZG90IHRoZW4gXCJkXCIgZWxzZSBcIlwiKVxuICBzZXREdXJhdGlvbjogKHRpbWUsIGRvdD1mYWxzZSkgLT5cbiAgICB0ID0gdGltZS5zcGxpdCgvXFxzKy8pXG4gICAgTCBcInNldER1cmF0aW9uOiBcIiwgdFswXSwgZG90XG4gICAgQGN1cnJlbnRfZHVyYXRpb24gPSBtYWtlRHVyYXRpb24odFswXSwgZG90KVxuXG4gIGFkZEJhcjogKHR5cGUpIC0+XG4gICAgTCBcImFkZEJhcjogXCIsIHR5cGVcbiAgICBAY2xvc2VCZW5kcygpXG4gICAgQGtleV9tYW5hZ2VyLnJlc2V0KClcbiAgICBzdGF2ZSA9IF8ubGFzdChfLmxhc3QoQHN0YXZlZ3JvdXBzKS5zdGF2ZXMpXG5cbiAgICBUWVBFID0gVmV4LkZsb3cuQmFybGluZS50eXBlXG4gICAgdHlwZSA9IHN3aXRjaCB0eXBlXG4gICAgICB3aGVuIFwic2luZ2xlXCJcbiAgICAgICAgVFlQRS5TSU5HTEVcbiAgICAgIHdoZW4gXCJkb3VibGVcIlxuICAgICAgICBUWVBFLkRPVUJMRVxuICAgICAgd2hlbiBcImVuZFwiXG4gICAgICAgIFRZUEUuRU5EXG4gICAgICB3aGVuIFwicmVwZWF0LWJlZ2luXCJcbiAgICAgICAgVFlQRS5SRVBFQVRfQkVHSU5cbiAgICAgIHdoZW4gXCJyZXBlYXQtZW5kXCJcbiAgICAgICAgVFlQRS5SRVBFQVRfRU5EXG4gICAgICB3aGVuIFwicmVwZWF0LWJvdGhcIlxuICAgICAgICBUWVBFLlJFUEVBVF9CT1RIXG4gICAgICBlbHNlXG4gICAgICAgIFRZUEUuU0lOR0xFXG5cbiAgICBiYXJfbm90ZSA9IG5ldyBWZXguRmxvdy5CYXJOb3RlKCkuc2V0VHlwZSh0eXBlKVxuICAgIHN0YXZlLnRhYl9ub3Rlcy5wdXNoKGJhcl9ub3RlKVxuICAgIHN0YXZlLm5vdGVfbm90ZXMucHVzaChiYXJfbm90ZSkgaWYgc3RhdmUubm90ZT9cblxuICBtYWtlQmVuZCA9IChmcm9tX2ZyZXQsIHRvX2ZyZXQpIC0+XG4gICAgZGlyZWN0aW9uID0gVmV4LkZsb3cuQmVuZC5VUFxuICAgIHRleHQgPSBcIlwiXG5cbiAgICBpZiBwYXJzZUludChmcm9tX2ZyZXQsIDEwKSA+IHBhcnNlSW50KHRvX2ZyZXQsIDEwKVxuICAgICAgZGlyZWN0aW9uID0gVmV4LkZsb3cuQmVuZC5ET1dOXG4gICAgZWxzZVxuICAgICAgdGV4dCA9IHN3aXRjaCBNYXRoLmFicyh0b19mcmV0IC0gZnJvbV9mcmV0KVxuICAgICAgICB3aGVuIDEgdGhlbiBcIjEvMlwiXG4gICAgICAgIHdoZW4gMiB0aGVuIFwiRnVsbFwiXG4gICAgICAgIHdoZW4gMyB0aGVuIFwiMSAxLzJcIlxuICAgICAgICBlbHNlIFwiQmVuZCB0byAje3RvX2ZyZXR9XCJcblxuICAgIHJldHVybiB7dHlwZTogZGlyZWN0aW9uLCB0ZXh0OiB0ZXh0fVxuXG4gIG9wZW5CZW5kczogKGZpcnN0X25vdGUsIGxhc3Rfbm90ZSwgZmlyc3RfaW5kaWNlcywgbGFzdF9pbmRpY2VzKSAtPlxuICAgIEwgXCJvcGVuQmVuZHNcIiwgZmlyc3Rfbm90ZSwgbGFzdF9ub3RlLCBmaXJzdF9pbmRpY2VzLCBsYXN0X2luZGljZXNcbiAgICB0YWJfbm90ZXMgPSBfLmxhc3QoXy5sYXN0KEBzdGF2ZWdyb3Vwcykuc3RhdmVzKS50YWJfbm90ZXNcblxuICAgIHN0YXJ0X25vdGUgPSBmaXJzdF9ub3RlXG4gICAgc3RhcnRfaW5kaWNlcyA9IGZpcnN0X2luZGljZXNcbiAgICBpZiBfLmlzRW1wdHkoQGN1cnJlbnRfYmVuZHMpXG4gICAgICBAYmVuZF9zdGFydF9pbmRleCA9IHRhYl9ub3Rlcy5sZW5ndGggLSAyXG4gICAgICBAYmVuZF9zdGFydF9zdHJpbmdzID0gZmlyc3RfaW5kaWNlc1xuICAgIGVsc2VcbiAgICAgIHN0YXJ0X25vdGUgPSB0YWJfbm90ZXNbQGJlbmRfc3RhcnRfaW5kZXhdXG4gICAgICBzdGFydF9pbmRpY2VzID0gQGJlbmRfc3RhcnRfc3RyaW5nc1xuXG4gICAgZmlyc3RfZnJldHMgPSBzdGFydF9ub3RlLmdldFBvc2l0aW9ucygpXG4gICAgbGFzdF9mcmV0cyA9IGxhc3Rfbm90ZS5nZXRQb3NpdGlvbnMoKVxuICAgIGZvciBpbmRleCwgaSBpbiBzdGFydF9pbmRpY2VzXG4gICAgICBsYXN0X2luZGV4ID0gbGFzdF9pbmRpY2VzW2ldXG4gICAgICBmcm9tX2ZyZXQgPSBmaXJzdF9ub3RlLmdldFBvc2l0aW9ucygpW2ZpcnN0X2luZGljZXNbaV1dXG4gICAgICB0b19mcmV0ID0gbGFzdF9mcmV0c1tsYXN0X2luZGV4XVxuICAgICAgQGN1cnJlbnRfYmVuZHNbaW5kZXhdID89IFtdXG4gICAgICBAY3VycmVudF9iZW5kc1tpbmRleF0ucHVzaCBtYWtlQmVuZChmcm9tX2ZyZXQuZnJldCwgdG9fZnJldC5mcmV0KVxuXG4gICMgQ2xvc2UgYW5kIGFwcGx5IGFsbCB0aGUgYmVuZHMgdG8gdGhlIGxhc3QgTiBub3Rlcy5cbiAgY2xvc2VCZW5kczogKG9mZnNldD0xKSAtPlxuICAgIHJldHVybiB1bmxlc3MgQGJlbmRfc3RhcnRfaW5kZXg/XG4gICAgTCBcImNsb3NlQmVuZHMoI3tvZmZzZXR9KVwiXG4gICAgdGFiX25vdGVzID0gXy5sYXN0KF8ubGFzdChAc3RhdmVncm91cHMpLnN0YXZlcykudGFiX25vdGVzXG4gICAgZm9yIGssIHYgb2YgQGN1cnJlbnRfYmVuZHNcbiAgICAgIHBocmFzZSA9IFtdXG4gICAgICBmb3IgYmVuZCBpbiB2XG4gICAgICAgIHBocmFzZS5wdXNoIGJlbmRcbiAgICAgIHRhYl9ub3Rlc1tAYmVuZF9zdGFydF9pbmRleF0uYWRkTW9kaWZpZXIoXG4gICAgICAgIG5ldyBWZXguRmxvdy5CZW5kKG51bGwsIG51bGwsIHBocmFzZSksIGspXG5cbiAgICAjIFJlcGxhY2UgYmVudCBub3RlcyB3aXRoIGdob3N0cyAobWFrZSB0aGVtIGludmlzaWJsZSlcbiAgICBmb3IgdGFiX25vdGUgaW4gdGFiX25vdGVzW0BiZW5kX3N0YXJ0X2luZGV4KzEuLigodGFiX25vdGVzLmxlbmd0aCAtIDIpICsgb2Zmc2V0KV1cbiAgICAgIHRhYl9ub3RlLnNldEdob3N0KHRydWUpXG5cbiAgICBAY3VycmVudF9iZW5kcyA9IHt9XG4gICAgQGJlbmRfc3RhcnRfaW5kZXggPSBudWxsXG5cbiAgbWFrZVR1cGxldHM6ICh0dXBsZXRzLCBub3RlcykgLT5cbiAgICBMIFwibWFrZVR1cGxldHNcIiwgdHVwbGV0cywgbm90ZXNcbiAgICBub3RlcyA/PSB0dXBsZXRzXG4gICAgcmV0dXJuIHVubGVzcyBfLmxhc3QoXy5sYXN0KEBzdGF2ZWdyb3Vwcykuc3RhdmVzKS5ub3RlXG4gICAgc3RhdmVfbm90ZXMgPSBfLmxhc3QoXy5sYXN0KEBzdGF2ZWdyb3Vwcykuc3RhdmVzKS5ub3RlX25vdGVzXG4gICAgdGFiX25vdGVzID0gXy5sYXN0KF8ubGFzdChAc3RhdmVncm91cHMpLnN0YXZlcykudGFiX25vdGVzXG5cbiAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJBcnRpc3RFcnJvclwiLCBcIk5vdCBlbm91Z2ggbm90ZXMgZm9yIHR1cGxldFwiKSBpZiBzdGF2ZV9ub3Rlcy5sZW5ndGggPCBub3Rlc1xuICAgIG1vZGlmaWVyID0gbmV3IFZleC5GbG93LlR1cGxldChzdGF2ZV9ub3Rlc1tzdGF2ZV9ub3Rlcy5sZW5ndGggLSBub3Rlcy4uXSwge251bV9ub3RlczogdHVwbGV0c30pXG4gICAgQHN0YXZlX2FydGljdWxhdGlvbnMucHVzaCBtb2RpZmllclxuXG4gICAgIyBDcmVhdGluZyBhIFZleC5GbG93LlR1cGxldCBjb3JyZWN0cyB0aGUgdGlja3MgZm9yIHRoZSBub3Rlcywgc28gaXQgbmVlZHMgdG9cbiAgICAjIGJlIGNyZWF0ZWQgd2hldGhlciBvciBub3QgaXQgZ2V0cyByZW5kZXJlZC4gQmVsb3csIGlmIHRhYiBzdGVtcyBhcmUgbm90IHJlcXVpcmVkXG4gICAgIyB0aGUgY3JlYXRlZCB0dXBsZXQgaXMgc2ltcGx5IHRocm93biBhd2F5LlxuICAgIHRhYl9tb2RpZmllciA9IG5ldyBWZXguRmxvdy5UdXBsZXQodGFiX25vdGVzW3RhYl9ub3Rlcy5sZW5ndGggLSBub3Rlcy4uXSwge251bV9ub3RlczogdHVwbGV0c30pXG4gICAgaWYgQGN1c3RvbWl6YXRpb25zW1widGFiLXN0ZW1zXCJdID09IFwidHJ1ZVwiXG4gICAgICBAdGFiX2FydGljdWxhdGlvbnMucHVzaCB0YWJfbW9kaWZpZXJcblxuICBnZXRGaW5nZXJpbmcgPSAodGV4dCkgLT4gdGV4dC5tYXRjaCgvXlxcLmZpbmdlcmluZ1xcLyhbXi5dKylcXC4vKVxuICBtYWtlRmluZ2VyaW5nOiAodGV4dCkgLT5cbiAgICBwYXJ0cyA9IGdldEZpbmdlcmluZyh0ZXh0KVxuICAgIFBPUyA9IFZleC5GbG93Lk1vZGlmaWVyLlBvc2l0aW9uXG4gICAgZmluZ2VycyA9IFtdXG4gICAgZmluZ2VyaW5nID0gW11cblxuICAgIGlmIHBhcnRzP1xuICAgICAgZmluZ2VycyA9IChwLnRyaW0oKSBmb3IgcCBpbiBwYXJ0c1sxXS5zcGxpdCgvLS8pKVxuICAgIGVsc2VcbiAgICAgIHJldHVybiBudWxsXG5cbiAgICBiYWRGaW5nZXJpbmcgPSAtPiBuZXcgVmV4LlJFUlIoXCJBcnRpc3RFcnJvclwiLCBcIkJhZCBmaW5nZXJpbmc6ICN7cGFydHNbMV19XCIpXG5cbiAgICBmb3IgZmluZ2VyIGluIGZpbmdlcnNcbiAgICAgIHBpZWNlcyA9IGZpbmdlci5tYXRjaCgvKFxcZCspOihbYWJscl0pOihbZnNdKTooW14tLl0rKS8pXG4gICAgICB0aHJvdyBiYWRGaW5nZXJpbmcoKSB1bmxlc3MgcGllY2VzP1xuXG4gICAgICBub3RlX251bWJlciA9IHBhcnNlSW50KHBpZWNlc1sxXSwgMTApIC0gMVxuICAgICAgcG9zaXRpb24gPSBQT1MuUklHSFRcbiAgICAgIHN3aXRjaCBwaWVjZXNbMl1cbiAgICAgICAgd2hlbiBcImxcIlxuICAgICAgICAgIHBvc2l0aW9uID0gUE9TLkxFRlRcbiAgICAgICAgd2hlbiBcInJcIlxuICAgICAgICAgIHBvc2l0aW9uID0gUE9TLlJJR0hUXG4gICAgICAgIHdoZW4gXCJhXCJcbiAgICAgICAgICBwb3NpdGlvbiA9IFBPUy5BQk9WRVxuICAgICAgICB3aGVuIFwiYlwiXG4gICAgICAgICAgcG9zaXRpb24gPSBQT1MuQkVMT1dcblxuICAgICAgbW9kaWZpZXIgPSBudWxsXG4gICAgICBudW1iZXIgPSBwaWVjZXNbNF1cbiAgICAgIHN3aXRjaCBwaWVjZXNbM11cbiAgICAgICAgd2hlbiBcInNcIlxuICAgICAgICAgIG1vZGlmaWVyID0gbmV3IFZleC5GbG93LlN0cmluZ051bWJlcihudW1iZXIpLnNldFBvc2l0aW9uKHBvc2l0aW9uKVxuICAgICAgICB3aGVuIFwiZlwiXG4gICAgICAgICAgbW9kaWZpZXIgPSBuZXcgVmV4LkZsb3cuRnJldEhhbmRGaW5nZXIobnVtYmVyKS5zZXRQb3NpdGlvbihwb3NpdGlvbilcblxuICAgICAgZmluZ2VyaW5nLnB1c2goe251bTogbm90ZV9udW1iZXIsIG1vZGlmaWVyOiBtb2RpZmllcn0pXG5cbiAgICByZXR1cm4gZmluZ2VyaW5nXG5cbiAgZ2V0U3Ryb2tlUGFydHMgPSAodGV4dCkgLT4gdGV4dC5tYXRjaCgvXlxcLnN0cm9rZVxcLyhbXi5dKylcXC4vKVxuICBtYWtlU3Ryb2tlOiAodGV4dCkgLT5cbiAgICBwYXJ0cyA9IGdldFN0cm9rZVBhcnRzKHRleHQpXG4gICAgVFlQRSA9IFZleC5GbG93LlN0cm9rZS5UeXBlXG4gICAgdHlwZSA9IG51bGxcblxuICAgIGlmIHBhcnRzP1xuICAgICAgc3dpdGNoIHBhcnRzWzFdXG4gICAgICAgIHdoZW4gXCJidVwiXG4gICAgICAgICAgdHlwZSA9IFRZUEUuQlJVU0hfVVBcbiAgICAgICAgd2hlbiBcImJkXCJcbiAgICAgICAgICB0eXBlID0gVFlQRS5CUlVTSF9ET1dOXG4gICAgICAgIHdoZW4gXCJydVwiXG4gICAgICAgICAgdHlwZSA9IFRZUEUuUk9MTF9VUFxuICAgICAgICB3aGVuIFwicmRcIlxuICAgICAgICAgIHR5cGUgPSBUWVBFLlJPTExfRE9XTlxuICAgICAgICB3aGVuIFwicXVcIlxuICAgICAgICAgIHR5cGUgPSBUWVBFLlJBU1FVRURPX1VQXG4gICAgICAgIHdoZW4gXCJxZFwiXG4gICAgICAgICAgdHlwZSA9IFRZUEUuUkFTUVVFRE9fRE9XTlxuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQXJ0aXN0RXJyb3JcIiwgXCJJbnZhbGlkIHN0cm9rZSB0eXBlOiAje3BhcnRzWzFdfVwiKVxuICAgICAgcmV0dXJuIG5ldyBWZXguRmxvdy5TdHJva2UodHlwZSlcbiAgICBlbHNlXG4gICAgICByZXR1cm4gbnVsbFxuXG4gIGdldFNjb3JlQXJ0aWN1bGF0aW9uUGFydHMgPSAodGV4dCkgLT4gdGV4dC5tYXRjaCgvXlxcLihhW15cXC9dKilcXC8odHxiKVteLl0qXFwuLylcbiAgbWFrZVNjb3JlQXJ0aWN1bGF0aW9uOiAodGV4dCkgLT5cbiAgICBwYXJ0cyA9IGdldFNjb3JlQXJ0aWN1bGF0aW9uUGFydHModGV4dClcbiAgICBpZiBwYXJ0cz9cbiAgICAgIHR5cGUgPSBwYXJ0c1sxXVxuICAgICAgcG9zaXRpb24gPSBwYXJ0c1syXVxuXG4gICAgICBQT1NUWVBFID0gVmV4LkZsb3cuTW9kaWZpZXIuUG9zaXRpb25cbiAgICAgIHBvcyA9IGlmIHBvc2l0aW9uIGlzIFwidFwiIHRoZW4gUE9TVFlQRS5BQk9WRSBlbHNlIFBPU1RZUEUuQkVMT1dcbiAgICAgIHJldHVybiBuZXcgVmV4LkZsb3cuQXJ0aWN1bGF0aW9uKHR5cGUpLnNldFBvc2l0aW9uKHBvcylcbiAgICBlbHNlIHJldHVybiBudWxsXG5cbiAgbWFrZUFubm90YXRpb246ICh0ZXh0KSAtPlxuICAgIGZvbnRfZmFjZSA9IEBjdXN0b21pemF0aW9uc1tcImZvbnQtZmFjZVwiXVxuICAgIGZvbnRfc2l6ZSA9IEBjdXN0b21pemF0aW9uc1tcImZvbnQtc2l6ZVwiXVxuICAgIGZvbnRfc3R5bGUgPSBAY3VzdG9taXphdGlvbnNbXCJmb250LXN0eWxlXCJdXG4gICAgYXBvc2l0aW9uID0gQGN1c3RvbWl6YXRpb25zW1wiYW5ub3RhdGlvbi1wb3NpdGlvblwiXVxuXG4gICAgVkpVU1QgPSBWZXguRmxvdy5Bbm5vdGF0aW9uLlZlcnRpY2FsSnVzdGlmeVxuICAgIGRlZmF1bHRfdmp1c3QgPSBpZiBhcG9zaXRpb24gaXMgXCJ0b3BcIiB0aGVuIFZKVVNULlRPUCBlbHNlIFZKVVNULkJPVFRPTVxuXG4gICAgbWFrZUl0ID0gKHRleHQsIGp1c3Q9ZGVmYXVsdF92anVzdCkgLT5cbiAgICAgIG5ldyBWZXguRmxvdy5Bbm5vdGF0aW9uKHRleHQpLlxuICAgICAgICBzZXRGb250KGZvbnRfZmFjZSwgZm9udF9zaXplLCBmb250X3N0eWxlKS5cbiAgICAgICAgc2V0VmVydGljYWxKdXN0aWZpY2F0aW9uKGp1c3QpXG5cbiAgICBwYXJ0cyA9IHRleHQubWF0Y2goL15cXC4oW14tXSopLShbXi1dKiktKFteLl0qKVxcLiguKikvKVxuICAgIGlmIHBhcnRzP1xuICAgICAgZm9udF9mYWNlID0gcGFydHNbMV1cbiAgICAgIGZvbnRfc2l6ZSA9IHBhcnRzWzJdXG4gICAgICBmb250X3N0eWxlID0gcGFydHNbM11cbiAgICAgIHRleHQgPSBwYXJ0c1s0XVxuICAgICAgcmV0dXJuIGlmIHRleHQgdGhlbiBtYWtlSXQodGV4dCkgZWxzZSBudWxsXG5cbiAgICBwYXJ0cyA9IHRleHQubWF0Y2goL15cXC4oW14uXSopXFwuKC4qKS8pXG4gICAgaWYgcGFydHM/XG4gICAgICBqdXN0ID0gZGVmYXVsdF92anVzdFxuICAgICAgdGV4dCA9IHBhcnRzWzJdXG4gICAgICBzd2l0Y2ggcGFydHNbMV1cbiAgICAgICAgd2hlbiBcImJpZ1wiXG4gICAgICAgICAgZm9udF9zdHlsZSA9IFwiYm9sZFwiXG4gICAgICAgICAgZm9udF9zaXplID0gXCIxNFwiXG4gICAgICAgIHdoZW4gXCJpdGFsaWNcIiwgXCJpdGFsaWNzXCJcbiAgICAgICAgICBmb250X2ZhY2UgPSBcIlRpbWVzXCJcbiAgICAgICAgICBmb250X3N0eWxlID0gXCJpdGFsaWNcIlxuICAgICAgICB3aGVuIFwibWVkaXVtXCJcbiAgICAgICAgICBmb250X3NpemUgPSBcIjEyXCJcbiAgICAgICAgd2hlbiBcInRvcFwiXG4gICAgICAgICAganVzdCA9IFZKVVNULlRPUFxuICAgICAgICAgIEBjdXN0b21pemF0aW9uc1tcImFubm90YXRpb24tcG9zaXRpb25cIl0gPSBcInRvcFwiXG4gICAgICAgIHdoZW4gXCJib3R0b21cIlxuICAgICAgICAgIGp1c3QgPSBWSlVTVC5CT1RUT01cbiAgICAgICAgICBAY3VzdG9taXphdGlvbnNbXCJhbm5vdGF0aW9uLXBvc2l0aW9uXCJdID0gXCJib3R0b21cIlxuICAgICAgcmV0dXJuIGlmIHRleHQgdGhlbiBtYWtlSXQodGV4dCwganVzdCkgZWxzZSBudWxsXG5cbiAgICByZXR1cm4gbWFrZUl0KHRleHQpXG5cbiAgYWRkQW5ub3RhdGlvbnM6IChhbm5vdGF0aW9ucykgLT5cbiAgICBzdGF2ZSA9IF8ubGFzdChfLmxhc3QoQHN0YXZlZ3JvdXBzKS5zdGF2ZXMpXG4gICAgc3RhdmVfbm90ZXMgPSBzdGF2ZS5ub3RlX25vdGVzXG4gICAgdGFiX25vdGVzID0gc3RhdmUudGFiX25vdGVzXG5cbiAgICBpZiBhbm5vdGF0aW9ucy5sZW5ndGggPiB0YWJfbm90ZXMubGVuZ3RoXG4gICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJBcnRpc3RFcnJvclwiLCBcIk1vcmUgYW5ub3RhdGlvbnMgdGhhbiBub3RlIGVsZW1lbnRzXCIpXG5cbiAgICAjIEFkZCB0ZXh0IGFubm90YXRpb25zXG4gICAgaWYgc3RhdmUudGFiXG4gICAgICBmb3IgdGFiX25vdGUsIGkgaW4gdGFiX25vdGVzW3RhYl9ub3Rlcy5sZW5ndGggLSBhbm5vdGF0aW9ucy5sZW5ndGguLl1cbiAgICAgICAgaWYgZ2V0U2NvcmVBcnRpY3VsYXRpb25QYXJ0cyhhbm5vdGF0aW9uc1tpXSlcbiAgICAgICAgICBzY29yZV9hcnRpY3VsYXRpb24gPSBAbWFrZVNjb3JlQXJ0aWN1bGF0aW9uKGFubm90YXRpb25zW2ldKVxuICAgICAgICAgIHRhYl9ub3RlLmFkZE1vZGlmaWVyKHNjb3JlX2FydGljdWxhdGlvbiwgMClcbiAgICAgICAgZWxzZSBpZiBnZXRTdHJva2VQYXJ0cyhhbm5vdGF0aW9uc1tpXSlcbiAgICAgICAgICBzdHJva2UgPSBAbWFrZVN0cm9rZShhbm5vdGF0aW9uc1tpXSlcbiAgICAgICAgICB0YWJfbm90ZS5hZGRNb2RpZmllcihzdHJva2UsIDApXG4gICAgICAgIGVsc2VcbiAgICAgICAgICBhbm5vdGF0aW9uID0gQG1ha2VBbm5vdGF0aW9uKGFubm90YXRpb25zW2ldKVxuICAgICAgICAgIHRhYl9ub3RlLmFkZE1vZGlmaWVyKEBtYWtlQW5ub3RhdGlvbihhbm5vdGF0aW9uc1tpXSksIDApIGlmIGFubm90YXRpb25cbiAgICBlbHNlXG4gICAgICBmb3Igbm90ZSwgaSBpbiBzdGF2ZV9ub3Rlc1tzdGF2ZV9ub3Rlcy5sZW5ndGggLSBhbm5vdGF0aW9ucy5sZW5ndGguLl1cbiAgICAgICAgdW5sZXNzIGdldFNjb3JlQXJ0aWN1bGF0aW9uUGFydHMoYW5ub3RhdGlvbnNbaV0pXG4gICAgICAgICAgYW5ub3RhdGlvbiA9IEBtYWtlQW5ub3RhdGlvbihhbm5vdGF0aW9uc1tpXSlcbiAgICAgICAgICBub3RlLmFkZEFubm90YXRpb24oMCwgQG1ha2VBbm5vdGF0aW9uKGFubm90YXRpb25zW2ldKSkgaWYgYW5ub3RhdGlvblxuXG4gICAgIyBBZGQgZ2x5cGggYXJ0aWN1bGF0aW9ucywgc3Ryb2tlcywgb3IgZmluZ2VyaW5ncyBvbiBzY29yZVxuICAgIGlmIHN0YXZlLm5vdGVcbiAgICAgIGZvciBub3RlLCBpIGluIHN0YXZlX25vdGVzW3N0YXZlX25vdGVzLmxlbmd0aCAtIGFubm90YXRpb25zLmxlbmd0aC4uXVxuICAgICAgICBzY29yZV9hcnRpY3VsYXRpb24gPSBAbWFrZVNjb3JlQXJ0aWN1bGF0aW9uKGFubm90YXRpb25zW2ldKVxuICAgICAgICBub3RlLmFkZEFydGljdWxhdGlvbigwLCBzY29yZV9hcnRpY3VsYXRpb24pIGlmIHNjb3JlX2FydGljdWxhdGlvbj9cblxuICAgICAgICBzdHJva2UgPSBAbWFrZVN0cm9rZShhbm5vdGF0aW9uc1tpXSlcbiAgICAgICAgbm90ZS5hZGRTdHJva2UoMCwgc3Ryb2tlKSBpZiBzdHJva2U/XG5cbiAgICAgICAgZmluZ2VyaW5ncyA9IEBtYWtlRmluZ2VyaW5nKGFubm90YXRpb25zW2ldKVxuICAgICAgICBpZiBmaW5nZXJpbmdzP1xuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgKG5vdGUuYWRkTW9kaWZpZXIoZmluZ2VyaW5nLm51bSwgZmluZ2VyaW5nLm1vZGlmaWVyKSBmb3IgZmluZ2VyaW5nIGluIGZpbmdlcmluZ3MpXG4gICAgICAgICAgY2F0Y2ggZVxuICAgICAgICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiQXJ0aXN0RXJyb3JcIiwgXCJCYWQgbm90ZSBudW1iZXIgaW4gZmluZ2VyaW5nOiAje2Fubm90YXRpb25zW2ldfVwiKVxuXG4gIGFkZFRhYkFydGljdWxhdGlvbjogKHR5cGUsIGZpcnN0X25vdGUsIGxhc3Rfbm90ZSwgZmlyc3RfaW5kaWNlcywgbGFzdF9pbmRpY2VzKSAtPlxuICAgIEwgXCJhZGRUYWJBcnRpY3VsYXRpb25zOiBcIiwgdHlwZSwgZmlyc3Rfbm90ZSwgbGFzdF9ub3RlLCBmaXJzdF9pbmRpY2VzLCBsYXN0X2luZGljZXNcblxuICAgIGlmIHR5cGUgPT0gXCJ0XCJcbiAgICAgIGxhc3Rfbm90ZS5hZGRNb2RpZmllcihcbiAgICAgICAgbmV3IFZleC5GbG93LkFubm90YXRpb24oXCJUXCIpLlxuICAgICAgICAgIHNldFZlcnRpY2FsSnVzdGlmaWNhdGlvbihWZXguRmxvdy5Bbm5vdGF0aW9uLlZlcnRpY2FsSnVzdGlmeS5CT1RUT00pKVxuXG4gICAgaWYgXy5pc0VtcHR5KGZpcnN0X2luZGljZXMpIGFuZCBfLmlzRW1wdHkobGFzdF9pbmRpY2VzKSB0aGVuIHJldHVyblxuXG4gICAgYXJ0aWN1bGF0aW9uID0gbnVsbFxuXG4gICAgaWYgdHlwZSA9PSBcInNcIlxuICAgICAgYXJ0aWN1bGF0aW9uID0gbmV3IFZleC5GbG93LlRhYlNsaWRlKHtcbiAgICAgICAgZmlyc3Rfbm90ZTogZmlyc3Rfbm90ZVxuICAgICAgICBsYXN0X25vdGU6IGxhc3Rfbm90ZVxuICAgICAgICBmaXJzdF9pbmRpY2VzOiBmaXJzdF9pbmRpY2VzXG4gICAgICAgIGxhc3RfaW5kaWNlczogbGFzdF9pbmRpY2VzXG4gICAgICAgIH0pXG5cbiAgICBpZiB0eXBlIGluIFtcImhcIiwgXCJwXCJdXG4gICAgICBhcnRpY3VsYXRpb24gPSBuZXcgVmV4LkZsb3cuVGFiVGllKHtcbiAgICAgICAgZmlyc3Rfbm90ZTogZmlyc3Rfbm90ZVxuICAgICAgICBsYXN0X25vdGU6IGxhc3Rfbm90ZVxuICAgICAgICBmaXJzdF9pbmRpY2VzOiBmaXJzdF9pbmRpY2VzXG4gICAgICAgIGxhc3RfaW5kaWNlczogbGFzdF9pbmRpY2VzXG4gICAgICAgIH0sIHR5cGUudG9VcHBlckNhc2UoKSlcblxuICAgIGlmIHR5cGUgaW4gW1wiVFwiLCBcInRcIl1cbiAgICAgIGFydGljdWxhdGlvbiA9IG5ldyBWZXguRmxvdy5UYWJUaWUoe1xuICAgICAgICBmaXJzdF9ub3RlOiBmaXJzdF9ub3RlXG4gICAgICAgIGxhc3Rfbm90ZTogbGFzdF9ub3RlXG4gICAgICAgIGZpcnN0X2luZGljZXM6IGZpcnN0X2luZGljZXNcbiAgICAgICAgbGFzdF9pbmRpY2VzOiBsYXN0X2luZGljZXNcbiAgICAgICAgfSwgXCIgXCIpXG5cbiAgICBpZiB0eXBlID09IFwiYlwiXG4gICAgICBAb3BlbkJlbmRzKGZpcnN0X25vdGUsIGxhc3Rfbm90ZSwgZmlyc3RfaW5kaWNlcywgbGFzdF9pbmRpY2VzKVxuXG4gICAgQHRhYl9hcnRpY3VsYXRpb25zLnB1c2ggYXJ0aWN1bGF0aW9uIGlmIGFydGljdWxhdGlvbj9cblxuICBhZGRTdGF2ZUFydGljdWxhdGlvbjogKHR5cGUsIGZpcnN0X25vdGUsIGxhc3Rfbm90ZSwgZmlyc3RfaW5kaWNlcywgbGFzdF9pbmRpY2VzKSAtPlxuICAgIEwgXCJhZGRTdGF2ZUFydGljdWxhdGlvbnM6IFwiLCB0eXBlLCBmaXJzdF9ub3RlLCBsYXN0X25vdGUsIGZpcnN0X2luZGljZXMsIGxhc3RfaW5kaWNlc1xuICAgIGFydGljdWxhdGlvbiA9IG51bGxcbiAgICBpZiB0eXBlIGluIFtcImJcIiwgXCJzXCIsIFwiaFwiLCBcInBcIiwgXCJ0XCIsIFwiVFwiXVxuICAgICAgYXJ0aWN1bGF0aW9uID0gbmV3IFZleC5GbG93LlN0YXZlVGllKHtcbiAgICAgICAgZmlyc3Rfbm90ZTogZmlyc3Rfbm90ZVxuICAgICAgICBsYXN0X25vdGU6IGxhc3Rfbm90ZVxuICAgICAgICBmaXJzdF9pbmRpY2VzOiBmaXJzdF9pbmRpY2VzXG4gICAgICAgIGxhc3RfaW5kaWNlczogbGFzdF9pbmRpY2VzXG4gICAgICAgIH0pXG5cbiAgICBAc3RhdmVfYXJ0aWN1bGF0aW9ucy5wdXNoIGFydGljdWxhdGlvbiBpZiBhcnRpY3VsYXRpb24/XG5cbiAgIyBUaGlzIGdldHMgdGhlIHByZXZpb3VzIChzZWNvbmQtdG8tbGFzdCkgbm9uLWJhciBub24tZ2hvc3Qgbm90ZS5cbiAgZ2V0UHJldmlvdXNOb3RlSW5kZXg6IC0+XG4gICAgdGFiX25vdGVzID0gXy5sYXN0KF8ubGFzdChAc3RhdmVncm91cHMpLnN0YXZlcykudGFiX25vdGVzXG4gICAgaW5kZXggPSAyXG4gICAgd2hpbGUgaW5kZXggPD0gdGFiX25vdGVzLmxlbmd0aFxuICAgICAgbm90ZSA9IHRhYl9ub3Rlc1t0YWJfbm90ZXMubGVuZ3RoIC0gaW5kZXhdXG4gICAgICByZXR1cm4gKHRhYl9ub3Rlcy5sZW5ndGggLSBpbmRleCkgaWYgbm90ZSBpbnN0YW5jZW9mIFZleC5GbG93LlRhYk5vdGVcbiAgICAgIGluZGV4KytcblxuICAgIHJldHVybiAtMVxuXG4gIGFkZERlY29yYXRvcjogKGRlY29yYXRvcikgLT5cbiAgICBMIFwiYWRkRGVjb3JhdG9yOiBcIiwgZGVjb3JhdG9yXG4gICAgcmV0dXJuIHVubGVzcyBkZWNvcmF0b3I/XG5cbiAgICBzdGF2ZSA9IF8ubGFzdChfLmxhc3QoQHN0YXZlZ3JvdXBzKS5zdGF2ZXMpXG4gICAgdGFiX25vdGVzID0gc3RhdmUudGFiX25vdGVzXG4gICAgc2NvcmVfbm90ZXMgPSBzdGF2ZS5ub3RlX25vdGVzXG4gICAgbW9kaWZpZXIgPSBudWxsXG4gICAgc2NvcmVfbW9kaWZpZXIgPSBudWxsXG5cbiAgICBpZiBkZWNvcmF0b3IgPT0gXCJ2XCJcbiAgICAgIG1vZGlmaWVyID0gbmV3IFZleC5GbG93LlZpYnJhdG8oKVxuICAgIGlmIGRlY29yYXRvciA9PSBcIlZcIlxuICAgICAgbW9kaWZpZXIgPSBuZXcgVmV4LkZsb3cuVmlicmF0bygpLnNldEhhcnNoKHRydWUpXG4gICAgaWYgZGVjb3JhdG9yID09IFwidVwiXG4gICAgICBtb2RpZmllciA9IG5ldyBWZXguRmxvdy5BcnRpY3VsYXRpb24oXCJhfFwiKS5zZXRQb3NpdGlvbihWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5CT1RUT00pXG4gICAgICBzY29yZV9tb2RpZmllciA9IG5ldyBWZXguRmxvdy5BcnRpY3VsYXRpb24oXCJhfFwiKS5zZXRQb3NpdGlvbihWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5CT1RUT00pXG4gICAgaWYgZGVjb3JhdG9yID09IFwiZFwiXG4gICAgICBtb2RpZmllciA9IG5ldyBWZXguRmxvdy5BcnRpY3VsYXRpb24oXCJhbVwiKS5zZXRQb3NpdGlvbihWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5CT1RUT00pXG4gICAgICBzY29yZV9tb2RpZmllciA9IG5ldyBWZXguRmxvdy5BcnRpY3VsYXRpb24oXCJhbVwiKS5zZXRQb3NpdGlvbihWZXguRmxvdy5Nb2RpZmllci5Qb3NpdGlvbi5CT1RUT00pXG5cbiAgICBfLmxhc3QodGFiX25vdGVzKS5hZGRNb2RpZmllcihtb2RpZmllciwgMCkgaWYgbW9kaWZpZXI/XG4gICAgXy5sYXN0KHNjb3JlX25vdGVzKT8uYWRkQXJ0aWN1bGF0aW9uKDAsIHNjb3JlX21vZGlmaWVyKSBpZiBzY29yZV9tb2RpZmllcj9cblxuXG4gIGFkZEFydGljdWxhdGlvbnM6IChhcnRpY3VsYXRpb25zKSAtPlxuICAgIEwgXCJhZGRBcnRpY3VsYXRpb25zOiBcIiwgYXJ0aWN1bGF0aW9uc1xuICAgIHN0YXZlID0gXy5sYXN0KF8ubGFzdChAc3RhdmVncm91cHMpLnN0YXZlcylcbiAgICB0YWJfbm90ZXMgPSBzdGF2ZS50YWJfbm90ZXNcbiAgICBzdGF2ZV9ub3RlcyA9IHN0YXZlLm5vdGVfbm90ZXNcbiAgICBpZiBfLmlzRW1wdHkodGFiX25vdGVzKSBvciBfLmlzRW1wdHkoYXJ0aWN1bGF0aW9ucylcbiAgICAgIEBjbG9zZUJlbmRzKDApXG4gICAgICByZXR1cm5cblxuICAgIGN1cnJlbnRfdGFiX25vdGUgPSBfLmxhc3QodGFiX25vdGVzKVxuXG4gICAgaGFzX2JlbmRzID0gZmFsc2VcbiAgICBmb3IgdmFsaWRfYXJ0aWN1bGF0aW9uIGluIFtcImJcIiwgXCJzXCIsIFwiaFwiLCBcInBcIiwgXCJ0XCIsIFwiVFwiLCBcInZcIiwgXCJWXCJdXG4gICAgICBpbmRpY2VzID0gKGkgZm9yIGFydCwgaSBpbiBhcnRpY3VsYXRpb25zIHdoZW4gYXJ0PyBhbmQgYXJ0ID09IHZhbGlkX2FydGljdWxhdGlvbilcbiAgICAgIGlmIF8uaXNFbXB0eShpbmRpY2VzKSB0aGVuIGNvbnRpbnVlXG5cbiAgICAgIGlmIHZhbGlkX2FydGljdWxhdGlvbiBpcyBcImJcIiB0aGVuIGhhc19iZW5kcyA9IHRydWVcbiAgICAgIHByZXZfaW5kZXggPSBAZ2V0UHJldmlvdXNOb3RlSW5kZXgoKVxuICAgICAgaWYgcHJldl9pbmRleCBpcyAtMVxuICAgICAgICBwcmV2X3RhYl9ub3RlID0gbnVsbFxuICAgICAgICBwcmV2X2luZGljZXMgPSBudWxsXG4gICAgICBlbHNlXG4gICAgICAgIHByZXZfdGFiX25vdGUgPSB0YWJfbm90ZXNbcHJldl9pbmRleF1cbiAgICAgICAgIyBGaWd1cmUgb3V0IHdoaWNoIHN0cmluZ3MgdGhlIGFydGljdWxhdGlvbnMgYXJlIG9uXG4gICAgICAgIHRoaXNfc3RyaW5ncyA9IChuLnN0ciBmb3IgbiwgaSBpbiBjdXJyZW50X3RhYl9ub3RlLmdldFBvc2l0aW9ucygpIHdoZW4gaSBpbiBpbmRpY2VzKVxuXG4gICAgICAgICMgT25seSBhbGxvd3MgYXJ0aWN1bGF0aW9ucyB3aGVyZSBib3RoIG5vdGVzIGFyZSBvbiB0aGUgc2FtZSBzdHJpbmdzXG4gICAgICAgIHZhbGlkX3N0cmluZ3MgPSAocG9zLnN0ciBmb3IgcG9zLCBpIGluIHByZXZfdGFiX25vdGUuZ2V0UG9zaXRpb25zKCkgd2hlbiBwb3Muc3RyIGluIHRoaXNfc3RyaW5ncylcblxuICAgICAgICAjIEdldCBpbmRpY2VzIG9mIGFydGljdWxhdGVkIG5vdGVzIG9uIHByZXZpb3VzIGNob3JkXG4gICAgICAgIHByZXZfaW5kaWNlcyA9IChpIGZvciBuLCBpIGluIHByZXZfdGFiX25vdGUuZ2V0UG9zaXRpb25zKCkgd2hlbiBuLnN0ciBpbiB2YWxpZF9zdHJpbmdzKVxuXG4gICAgICAgICMgR2V0IGluZGljZXMgb2YgYXJ0aWN1bGF0ZWQgbm90ZXMgb24gY3VycmVudCBjaG9yZFxuICAgICAgICBjdXJyZW50X2luZGljZXMgPSAoaSBmb3IgbiwgaSBpbiBjdXJyZW50X3RhYl9ub3RlLmdldFBvc2l0aW9ucygpIHdoZW4gbi5zdHIgaW4gdmFsaWRfc3RyaW5ncylcblxuICAgICAgaWYgc3RhdmUudGFiP1xuICAgICAgICBAYWRkVGFiQXJ0aWN1bGF0aW9uKHZhbGlkX2FydGljdWxhdGlvbixcbiAgICAgICAgICBwcmV2X3RhYl9ub3RlLCBjdXJyZW50X3RhYl9ub3RlLCBwcmV2X2luZGljZXMsIGN1cnJlbnRfaW5kaWNlcylcblxuICAgICAgaWYgc3RhdmUubm90ZT9cbiAgICAgICAgQGFkZFN0YXZlQXJ0aWN1bGF0aW9uKHZhbGlkX2FydGljdWxhdGlvbixcbiAgICAgICAgICBzdGF2ZV9ub3Rlc1twcmV2X2luZGV4XSwgXy5sYXN0KHN0YXZlX25vdGVzKSxcbiAgICAgICAgICBwcmV2X2luZGljZXMsIGN1cnJlbnRfaW5kaWNlcylcblxuICAgIEBjbG9zZUJlbmRzKDApIHVubGVzcyBoYXNfYmVuZHNcblxuICBhZGRSZXN0OiAocGFyYW1zKSAtPlxuICAgIEwgXCJhZGRSZXN0OiBcIiwgcGFyYW1zXG4gICAgQGNsb3NlQmVuZHMoKVxuXG4gICAgaWYgcGFyYW1zW1wicG9zaXRpb25cIl0gPT0gMFxuICAgICAgQGFkZFN0YXZlTm90ZVxuICAgICAgICBzcGVjOiBbXCJyLzRcIl1cbiAgICAgICAgYWNjaWRlbnRhbHM6IFtdXG4gICAgICAgIGlzX3Jlc3Q6IHRydWVcbiAgICBlbHNlXG4gICAgICBwb3NpdGlvbiA9IEB0dW5pbmcuZ2V0Tm90ZUZvckZyZXQoKHBhcnNlSW50KHBhcmFtc1tcInBvc2l0aW9uXCJdLCAxMCkgKyA1KSAqIDIsIDYpXG4gICAgICBAYWRkU3RhdmVOb3RlXG4gICAgICAgIHNwZWM6IFtwb3NpdGlvbl1cbiAgICAgICAgYWNjaWRlbnRhbHM6IFtdXG4gICAgICAgIGlzX3Jlc3Q6IHRydWVcblxuICAgIHRhYl9ub3RlcyA9IF8ubGFzdChfLmxhc3QoQHN0YXZlZ3JvdXBzKS5zdGF2ZXMpLnRhYl9ub3Rlc1xuICAgIGlmIEBjdXN0b21pemF0aW9uc1tcInRhYi1zdGVtc1wiXSA9PSBcInRydWVcIlxuICAgICAgdGFiX25vdGUgPSBuZXcgVmV4LkZsb3cuU3RhdmVOb3RlKHtcbiAgICAgICAga2V5czogW3Bvc2l0aW9uIHx8IFwici80XCJdXG4gICAgICAgIGR1cmF0aW9uOiBAY3VycmVudF9kdXJhdGlvbiArIFwiclwiXG4gICAgICAgIGNsZWY6IFwidHJlYmxlXCJcbiAgICAgICAgYXV0b19zdGVtOiBmYWxzZVxuICAgICAgfSlcbiAgICAgIGlmIEBjdXJyZW50X2R1cmF0aW9uW0BjdXJyZW50X2R1cmF0aW9uLmxlbmd0aCAtIDFdID09IFwiZFwiXG4gICAgICAgIHRhYl9ub3RlLmFkZERvdCgwKVxuICAgICAgdGFiX25vdGVzLnB1c2ggdGFiX25vdGVcbiAgICBlbHNlXG4gICAgICB0YWJfbm90ZXMucHVzaCBuZXcgVmV4LkZsb3cuR2hvc3ROb3RlKEBjdXJyZW50X2R1cmF0aW9uKVxuXG4gIGFkZENob3JkOiAoY2hvcmQsIGNob3JkX2FydGljdWxhdGlvbiwgY2hvcmRfZGVjb3JhdG9yKSAtPlxuICAgIHJldHVybiBpZiBfLmlzRW1wdHkoY2hvcmQpXG4gICAgTCBcImFkZENob3JkOiBcIiwgY2hvcmRcbiAgICBzdGF2ZSA9IF8ubGFzdChfLmxhc3QoQHN0YXZlZ3JvdXBzKS5zdGF2ZXMpXG4gICAgTCBcInN0YXZlIGluIGFkZENob3JkLlwiLCBzdGF2ZVxuXG4gICAgc3BlY3MgPSBbXSAgICAgICAgICAjIFRoZSBzdGF2ZSBub3RlIHNwZWNzXG4gICAgcGxheV9ub3RlcyA9IFtdICAgICAjIE5vdGVzIHRvIGJlIHBsYXllZCBieSBhdWRpbyBwbGF5ZXJzXG4gICAgYWNjaWRlbnRhbHMgPSBbXSAgICAjIFRoZSBzdGF2ZSBhY2NpZGVudGFsc1xuICAgIGFydGljdWxhdGlvbnMgPSBbXSAgIyBBcnRpY3VsYXRpb25zICh0aWVzLCBiZW5kcywgdGFwcylcbiAgICBkZWNvcmF0b3JzID0gW10gICAgICMgRGVjb3JhdG9ycyAodmlicmF0b3MsIGhhcm1vbmljcylcbiAgICB0YWJfc3BlY3MgPSBbXSAgICAgICMgVGhlIHRhYiBub3Rlc1xuICAgIGR1cmF0aW9ucyA9IFtdICAgICAgIyBUaGUgZHVyYXRpb24gb2YgZWFjaCBwb3NpdGlvblxuICAgIG51bV9ub3RlcyA9IDBcblxuICAgICMgQ2hvcmRzIGFyZSBjb21wbGljYXRlZCwgYmVjYXVzZSB0aGV5IGNhbiBjb250YWluIGxpdHRsZVxuICAgICMgbGluZXMgb25lIGVhY2ggc3RyaW5nLiBXZSBuZWVkIHRvIGtlZXAgdHJhY2sgb2YgdGhlIG1vdGlvblxuICAgICMgb2YgZWFjaCBsaW5lIHNvIHdlIGtub3cgd2hpY2ggdGljayB0aGV5IGJlbG9uZyBpbi5cbiAgICBjdXJyZW50X3N0cmluZyA9IF8uZmlyc3QoY2hvcmQpLnN0cmluZ1xuICAgIGN1cnJlbnRfcG9zaXRpb24gPSAwXG5cbiAgICBmb3Igbm90ZSBpbiBjaG9yZFxuICAgICAgbnVtX25vdGVzKytcbiAgICAgIGlmIG5vdGUuYWJjPyBvciBub3RlLnN0cmluZyAhPSBjdXJyZW50X3N0cmluZ1xuICAgICAgICBjdXJyZW50X3Bvc2l0aW9uID0gMFxuICAgICAgICBjdXJyZW50X3N0cmluZyA9IG5vdGUuc3RyaW5nXG5cbiAgICAgIHVubGVzcyBzcGVjc1tjdXJyZW50X3Bvc2l0aW9uXT9cbiAgICAgICAgIyBOZXcgcG9zaXRpb24uIENyZWF0ZSBuZXcgZWxlbWVudCBhcnJheXMgZm9yIHRoaXNcbiAgICAgICAgIyBwb3NpdGlvbi5cbiAgICAgICAgc3BlY3NbY3VycmVudF9wb3NpdGlvbl0gPSBbXVxuICAgICAgICBwbGF5X25vdGVzW2N1cnJlbnRfcG9zaXRpb25dID0gW11cbiAgICAgICAgYWNjaWRlbnRhbHNbY3VycmVudF9wb3NpdGlvbl0gPSBbXVxuICAgICAgICB0YWJfc3BlY3NbY3VycmVudF9wb3NpdGlvbl0gPSBbXVxuICAgICAgICBhcnRpY3VsYXRpb25zW2N1cnJlbnRfcG9zaXRpb25dID0gW11cbiAgICAgICAgZGVjb3JhdG9yc1tjdXJyZW50X3Bvc2l0aW9uXSA9IFtdXG5cbiAgICAgIFtuZXdfbm90ZSwgbmV3X29jdGF2ZSwgYWNjaWRlbnRhbF0gPSBbbnVsbCwgbnVsbCwgbnVsbF1cblxuICAgICAgcGxheV9ub3RlID0gbnVsbFxuXG4gICAgICBpZiBub3RlLmFiYz9cbiAgICAgICAgb2N0YXZlID0gaWYgbm90ZS5vY3RhdmU/IHRoZW4gbm90ZS5vY3RhdmUgZWxzZSBub3RlLnN0cmluZ1xuICAgICAgICBbbmV3X25vdGUsIG5ld19vY3RhdmUsIGFjY2lkZW50YWxdID0gQGdldE5vdGVGb3JBQkMobm90ZS5hYmMsIG9jdGF2ZSlcbiAgICAgICAgaWYgYWNjaWRlbnRhbD9cbiAgICAgICAgICBhY2MgPSBhY2NpZGVudGFsLnNwbGl0KFwiX1wiKVswXVxuICAgICAgICBlbHNlXG4gICAgICAgICAgYWNjID0gXCJcIlxuXG4gICAgICAgIHBsYXlfbm90ZSA9IFwiI3tuZXdfbm90ZX0je2FjY31cIlxuICAgICAgICBub3RlLmZyZXQgPSAnWCcgdW5sZXNzIG5vdGUuZnJldD9cbiAgICAgIGVsc2UgaWYgbm90ZS5mcmV0P1xuICAgICAgICBbbmV3X25vdGUsIG5ld19vY3RhdmUsIGFjY2lkZW50YWxdID0gQGdldE5vdGVGb3JGcmV0KG5vdGUuZnJldCwgbm90ZS5zdHJpbmcpXG4gICAgICAgIHBsYXlfbm90ZSA9IEB0dW5pbmcuZ2V0Tm90ZUZvckZyZXQobm90ZS5mcmV0LCBub3RlLnN0cmluZykuc3BsaXQoXCIvXCIpWzBdXG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkFydGlzdEVycm9yXCIsIFwiTm8gbm90ZSBzcGVjaWZpZWRcIilcblxuICAgICAgcGxheV9vY3RhdmUgPSBwYXJzZUludChuZXdfb2N0YXZlLCAxMCkgKyBAY3VycmVudF9vY3RhdmVfc2hpZnRcblxuICAgICAgY3VycmVudF9kdXJhdGlvbiA9IGlmIG5vdGUudGltZT8gdGhlbiB7dGltZTogbm90ZS50aW1lLCBkb3Q6IG5vdGUuZG90fSBlbHNlIG51bGxcbiAgICAgIHNwZWNzW2N1cnJlbnRfcG9zaXRpb25dLnB1c2ggXCIje25ld19ub3RlfS8je25ld19vY3RhdmV9XCJcbiAgICAgIHBsYXlfbm90ZXNbY3VycmVudF9wb3NpdGlvbl0ucHVzaCBcIiN7cGxheV9ub3RlfS8je3BsYXlfb2N0YXZlfVwiXG4gICAgICBhY2NpZGVudGFsc1tjdXJyZW50X3Bvc2l0aW9uXS5wdXNoIGFjY2lkZW50YWxcbiAgICAgIHRhYl9zcGVjc1tjdXJyZW50X3Bvc2l0aW9uXS5wdXNoIHtmcmV0OiBub3RlLmZyZXQsIHN0cjogbm90ZS5zdHJpbmd9XG4gICAgICBhcnRpY3VsYXRpb25zW2N1cnJlbnRfcG9zaXRpb25dLnB1c2ggbm90ZS5hcnRpY3VsYXRpb24gaWYgbm90ZS5hcnRpY3VsYXRpb24/XG4gICAgICBkdXJhdGlvbnNbY3VycmVudF9wb3NpdGlvbl0gPSBjdXJyZW50X2R1cmF0aW9uXG4gICAgICBkZWNvcmF0b3JzW2N1cnJlbnRfcG9zaXRpb25dID0gbm90ZS5kZWNvcmF0b3IgaWYgbm90ZS5kZWNvcmF0b3I/XG5cbiAgICAgIGN1cnJlbnRfcG9zaXRpb24rK1xuICAgIGZvciBzcGVjLCBpIGluIHNwZWNzXG4gICAgICBzYXZlZF9kdXJhdGlvbiA9IEBjdXJyZW50X2R1cmF0aW9uXG4gICAgICBAc2V0RHVyYXRpb24oZHVyYXRpb25zW2ldLnRpbWUsIGR1cmF0aW9uc1tpXS5kb3QpIGlmIGR1cmF0aW9uc1tpXT9cbiAgICAgIEBhZGRUYWJOb3RlIHRhYl9zcGVjc1tpXSwgcGxheV9ub3Rlc1tpXVxuICAgICAgQGFkZFN0YXZlTm90ZSB7c3BlYzogc3BlYywgYWNjaWRlbnRhbHM6IGFjY2lkZW50YWxzW2ldLCBwbGF5X25vdGU6IHBsYXlfbm90ZXNbaV19IGlmIHN0YXZlLm5vdGU/XG4gICAgICBAYWRkQXJ0aWN1bGF0aW9ucyBhcnRpY3VsYXRpb25zW2ldXG4gICAgICBAYWRkRGVjb3JhdG9yIGRlY29yYXRvcnNbaV0gaWYgZGVjb3JhdG9yc1tpXT9cblxuICAgIGlmIGNob3JkX2FydGljdWxhdGlvbj9cbiAgICAgIGFydCA9IFtdXG4gICAgICBhcnQucHVzaCBjaG9yZF9hcnRpY3VsYXRpb24gZm9yIG51bSBpbiBbMS4ubnVtX25vdGVzXVxuICAgICAgQGFkZEFydGljdWxhdGlvbnMgYXJ0XG5cbiAgICBAYWRkRGVjb3JhdG9yIGNob3JkX2RlY29yYXRvciBpZiBjaG9yZF9kZWNvcmF0b3I/XG5cbiAgYWRkTm90ZTogKG5vdGUpIC0+XG4gICAgQGFkZENob3JkKFtub3RlXSlcblxuICBhZGRUZXh0Vm9pY2U6IC0+XG4gICAgXy5sYXN0KF8ubGFzdChAc3RhdmVncm91cHMpLnN0YXZlcykudGV4dF92b2ljZXMucHVzaCBbXVxuXG4gIHNldFRleHRGb250OiAoZm9udCkgLT5cbiAgICBpZiBmb250P1xuICAgICAgcGFydHMgPSBmb250Lm1hdGNoKC8oW14tXSopLShbXi1dKiktKFteLl0qKS8pXG4gICAgICBpZiBwYXJ0cz9cbiAgICAgICAgQGN1c3RvbWl6YXRpb25zW1wiZm9udC1mYWNlXCJdID0gcGFydHNbMV1cbiAgICAgICAgQGN1c3RvbWl6YXRpb25zW1wiZm9udC1zaXplXCJdID0gcGFyc2VJbnQocGFydHNbMl0sIDEwKVxuICAgICAgICBAY3VzdG9taXphdGlvbnNbXCJmb250LXN0eWxlXCJdID0gcGFydHNbM11cblxuICBhZGRUZXh0Tm90ZTogKHRleHQsIHBvc2l0aW9uPTAsIGp1c3RpZmljYXRpb249XCJjZW50ZXJcIiwgc21vb3RoPXRydWUsIGlnbm9yZV90aWNrcz1mYWxzZSkgLT5cbiAgICB2b2ljZXMgPSBfLmxhc3QoXy5sYXN0KEBzdGF2ZWdyb3Vwcykuc3RhdmVzKS50ZXh0X3ZvaWNlc1xuICAgIHRocm93IG5ldyBWZXguUkVSUihcIkFydGlzdEVycm9yXCIsIFwiQ2FuJ3QgYWRkIHRleHQgbm90ZSB3aXRob3V0IHRleHQgdm9pY2VcIikgaWYgXy5pc0VtcHR5KHZvaWNlcylcblxuICAgIGZvbnRfZmFjZSA9IEBjdXN0b21pemF0aW9uc1tcImZvbnQtZmFjZVwiXVxuICAgIGZvbnRfc2l6ZSA9IEBjdXN0b21pemF0aW9uc1tcImZvbnQtc2l6ZVwiXVxuICAgIGZvbnRfc3R5bGUgPSBAY3VzdG9taXphdGlvbnNbXCJmb250LXN0eWxlXCJdXG5cbiAgICBqdXN0ID0gc3dpdGNoIGp1c3RpZmljYXRpb25cbiAgICAgIHdoZW4gXCJjZW50ZXJcIlxuICAgICAgICBWZXguRmxvdy5UZXh0Tm90ZS5KdXN0aWZpY2F0aW9uLkNFTlRFUlxuICAgICAgd2hlbiBcImxlZnRcIlxuICAgICAgICBWZXguRmxvdy5UZXh0Tm90ZS5KdXN0aWZpY2F0aW9uLkxFRlRcbiAgICAgIHdoZW4gXCJyaWdodFwiXG4gICAgICAgIFZleC5GbG93LlRleHROb3RlLkp1c3RpZmljYXRpb24uUklHSFRcbiAgICAgIGVsc2VcbiAgICAgICAgVmV4LkZsb3cuVGV4dE5vdGUuSnVzdGlmaWNhdGlvbi5DRU5URVJcblxuICAgIGR1cmF0aW9uID0gaWYgaWdub3JlX3RpY2tzIHRoZW4gXCJiXCIgZWxzZSBAY3VycmVudF9kdXJhdGlvblxuXG4gICAgc3RydWN0ID1cbiAgICAgIHRleHQ6IHRleHRcbiAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgICAgc21vb3RoOiBzbW9vdGhcbiAgICAgIGlnbm9yZV90aWNrczogaWdub3JlX3RpY2tzXG4gICAgICBmb250OlxuICAgICAgICBmYW1pbHk6IGZvbnRfZmFjZVxuICAgICAgICBzaXplOiBmb250X3NpemVcbiAgICAgICAgd2VpZ2h0OiBmb250X3N0eWxlXG5cbiAgICBpZiB0ZXh0WzBdID09IFwiI1wiXG4gICAgICBzdHJ1Y3QuZ2x5cGggPSB0ZXh0WzEuLl1cblxuICAgIG5vdGUgPSBuZXcgVmV4LkZsb3cuVGV4dE5vdGUoc3RydWN0KS5cbiAgICAgIHNldExpbmUocG9zaXRpb24pLnNldEp1c3RpZmljYXRpb24oanVzdClcblxuICAgIF8ubGFzdCh2b2ljZXMpLnB1c2gobm90ZSlcblxuICBhZGRWb2ljZTogKG9wdGlvbnMpIC0+XG4gICAgQGNsb3NlQmVuZHMoKVxuICAgIHN0YXZlID0gXy5sYXN0KF8ubGFzdChAc3RhdmVncm91cHMpLnN0YXZlcylcbiAgICByZXR1cm4gQGFkZFN0YXZlKG9wdGlvbnMpIHVubGVzcyBzdGF2ZT9cblxuICAgIHVubGVzcyBfLmlzRW1wdHkoc3RhdmUudGFiX25vdGVzKVxuICAgICAgc3RhdmUudGFiX3ZvaWNlcy5wdXNoKHN0YXZlLnRhYl9ub3RlcylcbiAgICAgIHN0YXZlLnRhYl9ub3RlcyA9IFtdXG5cbiAgICB1bmxlc3MgXy5pc0VtcHR5KHN0YXZlLm5vdGVfbm90ZXMpXG4gICAgICBzdGF2ZS5ub3RlX3ZvaWNlcy5wdXNoKHN0YXZlLm5vdGVfbm90ZXMpXG4gICAgICBzdGF2ZS5ub3RlX25vdGVzID0gW11cblxuICBhZGRTdGF2ZUdyb3VwOiAoKSAtPlxuICAgIEBzdGF2ZWdyb3Vwcy5wdXNoKHtzdGF2ZXM6W119KVxuICAgIEwgXCJhZGRTdGF2ZUdyb3VwXCJcbiAgICByZXR1cm5cblxuICBzdGF2ZUdyb3Vwc0xlbmd0aDogKCkgLT5cbiAgICByZXR1cm4gQHN0YXZlZ3JvdXBzLmxlbmd0aFxuXG4gIGdldFN0YXZlR3JvdXA6IChpKSAtPlxuICAgIHJldHVybiBAc3RhdmVncm91cHNbaV1cblxuICBhZGRTdGF2ZTogKHN0YXZlZ3JvdXBfaW5kZXgsIGVsZW1lbnQsIG9wdGlvbnMpIC0+XG4gICAgb3B0cyA9XG4gICAgICB0dW5pbmc6IFwic3RhbmRhcmRcIlxuICAgICAgY2xlZjogXCJ0cmVibGVcIlxuICAgICAga2V5OiBcIkNcIlxuICAgICAgbm90YXRpb246IGlmIGVsZW1lbnQgPT0gXCJ0YWJzdGF2ZVwiIHRoZW4gXCJmYWxzZVwiIGVsc2UgXCJ0cnVlXCJcbiAgICAgIHRhYmxhdHVyZTogaWYgZWxlbWVudCA9PSBcInN0YXZlXCIgdGhlbiBcImZhbHNlXCIgZWxzZSBcInRydWVcIlxuICAgICAgc3RyaW5nczogNlxuXG4gICAgXy5leHRlbmQob3B0cywgb3B0aW9ucylcbiAgICBMIFwiYWRkU3RhdmU6IFwiLCBlbGVtZW50LCBvcHRzXG5cbiAgICB0YWJfc3RhdmUgPSBudWxsXG4gICAgbm90ZV9zdGF2ZSA9IG51bGxcblxuICAgICMgVGhpcyBpcyB1c2VkIHRvIGxpbmUgdXAgdGFibGF0dXJlIGFuZCBub3RhdGlvbi5cbiAgICBzdGFydF94ID0gQHggKyBAY3VzdG9taXphdGlvbnNbXCJjb25uZWN0b3Itc3BhY2VcIl1cbiAgICB0YWJzdGF2ZV9zdGFydF94ID0gNDBcblxuICAgIGlmIG9wdHMubm90YXRpb24gaXMgXCJ0cnVlXCJcbiAgICAgIG5vdGVfc3RhdmUgPSBuZXcgVmV4LkZsb3cuU3RhdmUoc3RhcnRfeCwgQGxhc3RfeSwgQGN1c3RvbWl6YXRpb25zLndpZHRoIC0gMjApXG4gICAgICBub3RlX3N0YXZlLmFkZENsZWYob3B0cy5jbGVmKSBpZiBvcHRzLmNsZWYgaXNudCBcIm5vbmVcIlxuICAgICAgbm90ZV9zdGF2ZS5hZGRLZXlTaWduYXR1cmUob3B0cy5rZXkpXG4gICAgICBub3RlX3N0YXZlLmFkZFRpbWVTaWduYXR1cmUob3B0cy50aW1lKSBpZiBvcHRzLnRpbWU/XG5cbiAgICAgIEBsYXN0X3kgKz0gbm90ZV9zdGF2ZS5nZXRIZWlnaHQoKSArXG4gICAgICAgICAgICAgICAgIEBvcHRpb25zLm5vdGVfc3RhdmVfbG93ZXJfc3BhY2luZyArXG4gICAgICAgICAgICAgICAgIHBhcnNlSW50KEBjdXN0b21pemF0aW9uc1tcInN0YXZlLWRpc3RhbmNlXCJdLCAxMClcbiAgICAgIHRhYnN0YXZlX3N0YXJ0X3ggPSBub3RlX3N0YXZlLmdldE5vdGVTdGFydFgoKVxuICAgICAgQGN1cnJlbnRfY2xlZiA9IGlmIG9wdHMuY2xlZiBpcyBcIm5vbmVcIiB0aGVuIFwidHJlYmxlXCIgZWxzZSBvcHRzLmNsZWZcblxuICAgIGlmIG9wdHMudGFibGF0dXJlIGlzIFwidHJ1ZVwiXG4gICAgICB0YWJfc3RhdmUgPSBuZXcgVmV4LkZsb3cuVGFiU3RhdmUoc3RhcnRfeCwgQGxhc3RfeSwgQGN1c3RvbWl6YXRpb25zLndpZHRoIC0gMjApXG4gICAgICAgIC5zZXROdW1MaW5lcyhvcHRzLnN0cmluZ3MpXG4gICAgICB0YWJfc3RhdmUuYWRkVGFiR2x5cGgoKSBpZiBvcHRzLmNsZWYgaXNudCBcIm5vbmVcIlxuICAgICAgdGFiX3N0YXZlLnNldE5vdGVTdGFydFgodGFic3RhdmVfc3RhcnRfeClcbiAgICAgIEBsYXN0X3kgKz0gdGFiX3N0YXZlLmdldEhlaWdodCgpICsgQG9wdGlvbnMudGFiX3N0YXZlX2xvd2VyX3NwYWNpbmdcblxuICAgIEBjbG9zZUJlbmRzKClcbiAgICBiZWFtX2dyb3VwcyA9IFZleC5GbG93LkJlYW0uZ2V0RGVmYXVsdEJlYW1Hcm91cHMob3B0cy50aW1lKVxuICAgIEBnZXRTdGF2ZUdyb3VwKHN0YXZlZ3JvdXBfaW5kZXgpLnN0YXZlcy5wdXNoIHtcbiAgICAgIHRhYjogdGFiX3N0YXZlLFxuICAgICAgbm90ZTogbm90ZV9zdGF2ZSxcbiAgICAgIHRhYl92b2ljZXM6IFtdLFxuICAgICAgbm90ZV92b2ljZXM6IFtdLFxuICAgICAgdGFiX25vdGVzOiBbXSxcbiAgICAgIG5vdGVfbm90ZXM6IFtdLFxuICAgICAgdGV4dF92b2ljZXM6IFtdLFxuICAgICAgYmVhbV9ncm91cHM6IGJlYW1fZ3JvdXBzXG4gICAgfVxuXG4gICAgQHR1bmluZy5zZXRUdW5pbmcob3B0cy50dW5pbmcpXG4gICAgQGtleV9tYW5hZ2VyLnNldEtleShvcHRzLmtleSlcblxuICAgIHJldHVyblxuXG4gIHJ1bkNvbW1hbmQ6IChsaW5lLCBfbD0wLCBfYz0wKSAtPlxuICAgIEwgXCJydW5Db21tYW5kOiBcIiwgbGluZVxuICAgIHdvcmRzID0gbGluZS5zcGxpdCgvXFxzKy8pXG4gICAgc3dpdGNoIHdvcmRzWzBdXG4gICAgICB3aGVuIFwib2N0YXZlLXNoaWZ0XCJcbiAgICAgICAgQGN1cnJlbnRfb2N0YXZlX3NoaWZ0ID0gcGFyc2VJbnQod29yZHNbMV0sIDEwKVxuICAgICAgICBMIFwiT2N0YXZlIHNoaWZ0OiBcIiwgQGN1cnJlbnRfb2N0YXZlX3NoaWZ0XG4gICAgICBlbHNlXG4gICAgICAgIHRocm93IG5ldyBWZXguUkVSUihcIkFydGlzdEVycm9yXCIsIFwiSW52YWxpZCBjb21tYW5kICcje3dvcmRzWzBdfScgYXQgbGluZSAje19sfSBjb2x1bW4gI3tfY31cIilcblxubW9kdWxlLmV4cG9ydHMgPSBBcnRpc3RcbiIsIlZleCA9IHJlcXVpcmUgJ3ZleGZsb3cnXG5BcnRpc3QgPSByZXF1aXJlICcuL2FydGlzdC5jb2ZmZWUnXG5WZXhUYWIgPSByZXF1aXJlICcuL3ZleHRhYi5jb2ZmZWUnXG5QbGF5ZXIgPSByZXF1aXJlICcuL3BsYXllci5jb2ZmZWUnXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBBcnRpc3Q6IEFydGlzdFxuICBWZXhUYWI6IFZleFRhYlxuICBWZXg6IFZleFxuICBQbGF5ZXI6IFBsYXllclxufVxuIiwiIyBWZXhUYWIgUGxheWVyXG4jIENvcHlyaWdodCAyMDEyIE1vaGl0IENoZXBwdWRpcmEgPG1vaGl0QG11dGhhbm5hLmNvbT5cbiNcbiMgVGhpcyBjbGFzcyBpcyByZXNwb25zaWJsZSBmb3IgcmVuZGVyaW5nIHRoZSBlbGVtZW50c1xuIyBwYXJzZWQgYnkgVmV4LkZsb3cuVmV4VGFiLlxuXG5WZXggPSByZXF1aXJlICd2ZXhmbG93J1xuXyA9IHJlcXVpcmUgJ3VuZGVyc2NvcmUnXG4kID0gcmVxdWlyZSAnanF1ZXJ5J1xucGFwZXIgPSByZXF1aXJlICdwYXBlcidcblxuY2xhc3MgVmV4LkZsb3cuUGxheWVyXG4gIEBERUJVRyA9IGZhbHNlXG4gIEBJTlNUUlVNRU5UU19MT0FERUQgPSB7fVxuICBMID0gKGFyZ3MuLi4pIC0+IGNvbnNvbGU/LmxvZyhcIihWZXguRmxvdy5QbGF5ZXIpXCIsIGFyZ3MuLi4pIGlmIFZleC5GbG93LlBsYXllci5ERUJVR1xuXG4gIEZyYWN0aW9uID0gVmV4LkZsb3cuRnJhY3Rpb25cbiAgUkVTT0xVVElPTiA9IFZleC5GbG93LlJFU09MVVRJT05cbiAgbm90ZVZhbHVlcyA9IFZleC5GbG93Lk11c2ljLm5vdGVWYWx1ZXNcbiAgZHJhd0RvdCA9IFZleC5kcmF3RG90XG5cbiAgSU5TVFJVTUVOVFMgPSB7XG4gICAgXCJhY291c3RpY19ncmFuZF9waWFub1wiOiAwLFxuICAgIFwiYWNvdXN0aWNfZ3VpdGFyX255bG9uXCI6IDI0LFxuICAgIFwiYWNvdXN0aWNfZ3VpdGFyX3N0ZWVsXCI6IDI1LFxuICAgIFwiZWxlY3RyaWNfZ3VpdGFyX2phenpcIjogMjYsXG4gICAgXCJkaXN0b3J0aW9uX2d1aXRhclwiOiAzMCxcbiAgICBcImVsZWN0cmljX2Jhc3NfZmluZ2VyXCI6IDMzLFxuICAgIFwiZWxlY3RyaWNfYmFzc19waWNrXCI6IDM0LFxuICAgIFwidHJ1bXBldFwiOiA1NixcbiAgICBcImJyYXNzX3NlY3Rpb25cIjogNjEsXG4gICAgXCJzb3ByYW5vX3NheFwiOiA2NCxcbiAgICBcImFsdG9fc2F4XCI6IDY1LFxuICAgIFwidGVub3Jfc2F4XCI6IDY2LFxuICAgIFwiYmFyaXRvbmVfc2F4XCI6IDY3LFxuICAgIFwiZmx1dGVcIjogNzMsXG4gICAgXCJzeW50aF9kcnVtXCI6IDExOFxuICB9XG5cbiAgY29uc3RydWN0b3I6IChAYXJ0aXN0LCBvcHRpb25zKSAtPlxuICAgIEwgXCJJbml0aWFsaXppbmcgcGxheWVyOiBcIiwgb3B0aW9uc1xuICAgIEBvcHRpb25zID1cbiAgICAgIGluc3RydW1lbnQ6IFwiYWNvdXN0aWNfZ3JhbmRfcGlhbm9cIlxuICAgICAgdGVtcG86IDEyMFxuICAgICAgc2hvd19jb250cm9sczogdHJ1ZVxuICAgICAgc291bmRmb250X3VybDogXCIuLi9zb3VuZGZvbnQvXCJcbiAgICAgIG92ZXJsYXlfY2xhc3M6IFwidmV4dGFiLXBsYXllclwiXG5cbiAgICBfLmV4dGVuZChAb3B0aW9ucywgb3B0aW9ucykgaWYgb3B0aW9ucz9cbiAgICBMIFwiVXNpbmcgc291bmRmb250cyBpbjogI3tAb3B0aW9ucy5zb3VuZGZvbnRfdXJsfVwiXG4gICAgQGludGVydmFsX2lkID0gbnVsbFxuICAgIEBwYXBlciA9IG51bGxcbiAgICBAcmVzZXQoKVxuXG4gIHNldEFydGlzdDogKGFydGlzdCkgLT5cbiAgICBAYXJ0aXN0ID0gYXJ0aXN0XG4gICAgQHJlc2V0KClcblxuICBzZXRUZW1wbzogKHRlbXBvKSAtPlxuICAgIEwgXCJOZXcgdGVtcG86IFwiLCB0ZW1wb1xuICAgIEBvcHRpb25zLnRlbXBvID0gdGVtcG9cbiAgICBAcmVzZXQoKVxuXG4gIHNldEluc3RydW1lbnQ6IChpbnN0cnVtZW50KSAtPlxuICAgIEwgXCJOZXcgaW5zdHJ1bWVudDogXCIsIGluc3RydW1lbnRcbiAgICBpZiBpbnN0cnVtZW50IG5vdCBpbiBfLmtleXMoSU5TVFJVTUVOVFMpXG4gICAgICB0aHJvdyBuZXcgVmV4LlJFUlIoXCJQbGF5ZXJFcnJvclwiLCBcIkludmFsaWQgaW5zdHJ1bWVudDogXCIgKyBpbnN0cnVtZW50KVxuICAgIEBvcHRpb25zLmluc3RydW1lbnQgPSBpbnN0cnVtZW50XG4gICAgQHJlc2V0KClcblxuICByZXNldDogLT5cbiAgICBAYXJ0aXN0LmF0dGFjaFBsYXllcih0aGlzKVxuICAgIEB0aWNrX25vdGVzID0ge31cbiAgICBAYWxsX3RpY2tzID0gW11cbiAgICBAdHBtID0gQG9wdGlvbnMudGVtcG8gKiAoUkVTT0xVVElPTiAvIDQpXG4gICAgQHJlZnJlc2hfcmF0ZSA9IDI1ICNtczogNTAgPSAyMGh6XG4gICAgQHRpY2tzX3Blcl9yZWZyZXNoID0gQHRwbSAvICg2MCAqICgxMDAwL0ByZWZyZXNoX3JhdGUpKVxuICAgIEB0b3RhbF90aWNrcyA9IDBcbiAgICBpZiBAbWFya2VyP1xuICAgICAgQG1hcmtlci5yZW1vdmUoKVxuICAgICAgQG1hcmtlciA9IG51bGxcbiAgICBAc3RvcCgpXG5cbiAgZ2V0T3ZlcmxheSA9IChjb250ZXh0LCBzY2FsZSwgb3ZlcmxheV9jbGFzcykgLT5cbiAgICBjYW52YXMgPSBjb250ZXh0LmNhbnZhc1xuICAgIGhlaWdodCA9IGNhbnZhcy5oZWlnaHRcbiAgICB3aWR0aCA9IGNhbnZhcy53aWR0aFxuXG4gICAgb3ZlcmxheSA9ICQoJzxjYW52YXM+JylcbiAgICBvdmVybGF5LmNzcyhcInBvc2l0aW9uXCIsIFwiYWJzb2x1dGVcIilcbiAgICBvdmVybGF5LmNzcyhcImxlZnRcIiwgMClcbiAgICBvdmVybGF5LmNzcyhcInRvcFwiLCAwKVxuICAgIG92ZXJsYXkuYWRkQ2xhc3Mob3ZlcmxheV9jbGFzcylcblxuICAgICQoY2FudmFzKS5hZnRlcihvdmVybGF5KVxuICAgIGN0eCA9IFZleC5GbG93LlJlbmRlcmVyLmdldENhbnZhc0NvbnRleHQob3ZlcmxheS5nZXQoMCksIHdpZHRoLCBoZWlnaHQpXG4gICAgY3R4LnNjYWxlKHNjYWxlLCBzY2FsZSlcblxuICAgIHBzID0gbmV3IHBhcGVyLlBhcGVyU2NvcGUoKVxuICAgIHBzLnNldHVwKG92ZXJsYXkuZ2V0KDApKVxuXG4gICAgcmV0dXJuIHtcbiAgICAgIHBhcGVyOiBwc1xuICAgICAgY2FudmFzOiBvdmVybGF5LmdldCgwKVxuICAgIH1cblxuICByZW1vdmVDb250cm9sczogLT5cbiAgICBAcGxheV9idXR0b24ucmVtb3ZlKCkgaWYgQHBsYXlfYnV0dG9uP1xuICAgIEBzdG9wX2J1dHRvbi5yZW1vdmUoKSBpZiBAc3RvcF9idXR0b24/XG4gICAgQHBhcGVyLnZpZXcuZHJhdygpIGlmIEBwYXBlcj9cblxuICByZW5kZXI6IC0+XG4gICAgQHJlc2V0KClcbiAgICBkYXRhID0gQGFydGlzdC5nZXRQbGF5ZXJEYXRhKClcbiAgICBAc2NhbGUgPSBkYXRhLnNjYWxlXG5cbiAgICBpZiBub3QgQHBhcGVyXG4gICAgICBvdmVybGF5ID0gZ2V0T3ZlcmxheShkYXRhLmNvbnRleHQsIGRhdGEuc2NhbGUsIEBvcHRpb25zLm92ZXJsYXlfY2xhc3MpXG4gICAgICBAcGFwZXIgPSBvdmVybGF5LnBhcGVyXG5cbiAgICBAbWFya2VyID0gbmV3IEBwYXBlci5QYXRoLlJlY3RhbmdsZSgwLDAsMTMsODUpXG4gICAgQGxvYWRpbmdfbWVzc2FnZSA9IG5ldyBAcGFwZXIuUG9pbnRUZXh0KDM1LCAxMilcblxuICAgIGlmIEBvcHRpb25zLnNob3dfY29udHJvbHNcbiAgICAgIEBwbGF5X2J1dHRvbiA9IG5ldyBAcGFwZXIuUGF0aC5SZWd1bGFyUG9seWdvbihuZXcgQHBhcGVyLlBvaW50KDI1LDEwKSwgMywgNywgNylcbiAgICAgIEBwbGF5X2J1dHRvbi5maWxsQ29sb3IgPSAnIzM5NidcbiAgICAgIEBwbGF5X2J1dHRvbi5vcGFjaXR5ID0gMC44XG4gICAgICBAcGxheV9idXR0b24ucm90YXRlKDkwKVxuICAgICAgQHBsYXlfYnV0dG9uLm9uTW91c2VVcCA9IChldmVudCkgPT5cbiAgICAgICAgQHBsYXkoKVxuXG4gICAgICBAc3RvcF9idXR0b24gPSBuZXcgQHBhcGVyLlBhdGguUmVjdGFuZ2xlKDMsMywxMCwxMClcbiAgICAgIEBzdG9wX2J1dHRvbi5maWxsQ29sb3IgPSAnIzM5NidcbiAgICAgIEBzdG9wX2J1dHRvbi5vcGFjaXR5ID0gMC44XG4gICAgICBAc3RvcF9idXR0b24ub25Nb3VzZVVwID0gKGV2ZW50KSA9PlxuICAgICAgICBAc3RvcCgpXG5cbiAgICBAcGFwZXIudmlldy5kcmF3KClcbiAgICBzdGF2ZXMgPSBkYXRhLnN0YXZlc1xuXG4gICAgdG90YWxfdGlja3MgPSBuZXcgRnJhY3Rpb24oMCwgMSlcbiAgICBmb3Igc3RhdmUgaW4gc3RhdmVzXG4gICAgICBtYXhfdm9pY2VfdGljayA9IG5ldyBGcmFjdGlvbigwLCAxKVxuICAgICAgZm9yIHZvaWNlX2dyb3VwIGluIHN0YXZlXG4gICAgICAgIHRvdGFsX3ZvaWNlX3RpY2tzID0gbmV3IEZyYWN0aW9uKDAsIDEpXG4gICAgICAgIGZvciB2b2ljZSwgaSBpbiB2b2ljZV9ncm91cFxuXG4gICAgICAgICAgZm9yIG5vdGUgaW4gdm9pY2UuZ2V0VGlja2FibGVzKClcbiAgICAgICAgICAgIHVubGVzcyBub3RlLnNob3VsZElnbm9yZVRpY2tzKClcbiAgICAgICAgICAgICAgYWJzX3RpY2sgPSB0b3RhbF90aWNrcy5jbG9uZSgpXG4gICAgICAgICAgICAgIGFic190aWNrLmFkZCh0b3RhbF92b2ljZV90aWNrcylcbiAgICAgICAgICAgICAgYWJzX3RpY2suc2ltcGxpZnkoKVxuICAgICAgICAgICAgICBrZXkgPSBhYnNfdGljay50b1N0cmluZygpXG5cbiAgICAgICAgICAgICAgaWYgXy5oYXMoQHRpY2tfbm90ZXMsIGtleSlcbiAgICAgICAgICAgICAgICBAdGlja19ub3Rlc1trZXldLm5vdGVzLnB1c2gobm90ZSlcbiAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIEB0aWNrX25vdGVzW2tleV0gPVxuICAgICAgICAgICAgICAgICAgdGljazogYWJzX3RpY2tcbiAgICAgICAgICAgICAgICAgIHZhbHVlOiBhYnNfdGljay52YWx1ZSgpXG4gICAgICAgICAgICAgICAgICBub3RlczogW25vdGVdXG5cbiAgICAgICAgICAgICAgdG90YWxfdm9pY2VfdGlja3MuYWRkKG5vdGUuZ2V0VGlja3MoKSlcblxuICAgICAgICBpZiB0b3RhbF92b2ljZV90aWNrcy52YWx1ZSgpID4gbWF4X3ZvaWNlX3RpY2sudmFsdWUoKVxuICAgICAgICAgIG1heF92b2ljZV90aWNrLmNvcHkodG90YWxfdm9pY2VfdGlja3MpXG5cbiAgICAgIHRvdGFsX3RpY2tzLmFkZChtYXhfdm9pY2VfdGljaylcblxuICAgIEBhbGxfdGlja3MgPSBfLnNvcnRCeShfLnZhbHVlcyhAdGlja19ub3RlcyksICh0aWNrKSAtPiB0aWNrLnZhbHVlKVxuICAgIEB0b3RhbF90aWNrcyA9IF8ubGFzdChAYWxsX3RpY2tzKVxuICAgIEwgQGFsbF90aWNrc1xuXG4gIHVwZGF0ZU1hcmtlcjogKHgsIHkpIC0+XG4gICAgQG1hcmtlci5maWxsQ29sb3IgPSAnIzM2OSdcbiAgICBAbWFya2VyLm9wYWNpdHkgPSAwLjJcbiAgICBAbWFya2VyLnNldFBvc2l0aW9uKG5ldyBAcGFwZXIuUG9pbnQoeCAqIEBzY2FsZSwgeSAqIEBzY2FsZSkpXG4gICAgQHBhcGVyLnZpZXcuZHJhdygpXG5cbiAgcGxheU5vdGU6IChub3RlcykgLT5cbiAgICBMIFwiKCN7QGN1cnJlbnRfdGlja3N9KSBwbGF5Tm90ZTogXCIsIG5vdGVzXG5cbiAgICBmb3Igbm90ZSBpbiBub3Rlc1xuICAgICAgeCA9IG5vdGUuZ2V0QWJzb2x1dGVYKCkgKyA0XG4gICAgICB5ID0gbm90ZS5nZXRTdGF2ZSgpLmdldFlGb3JMaW5lKDIpXG4gICAgICBAdXBkYXRlTWFya2VyKHgsIHkpIGlmIEBwYXBlcj9cbiAgICAgIGNvbnRpbnVlIGlmIG5vdGUuaXNSZXN0KClcblxuICAgICAga2V5cyA9IG5vdGUuZ2V0UGxheU5vdGUoKVxuICAgICAgZHVyYXRpb24gPSBub3RlLmdldFRpY2tzKCkudmFsdWUoKSAvIChAdHBtLzYwKVxuICAgICAgZm9yIGtleSBpbiBrZXlzXG4gICAgICAgIFtub3RlLCBvY3RhdmVdID0ga2V5LnNwbGl0KFwiL1wiKVxuICAgICAgICBub3RlID0gbm90ZS50cmltKCkudG9Mb3dlckNhc2UoKVxuICAgICAgICBub3RlX3ZhbHVlID0gbm90ZVZhbHVlc1tub3RlXVxuICAgICAgICBjb250aW51ZSB1bmxlc3Mgbm90ZV92YWx1ZT9cblxuICAgICAgICBtaWRpX25vdGUgPSAoMjQgKyAob2N0YXZlICogMTIpKSArIG5vdGVWYWx1ZXNbbm90ZV0uaW50X3ZhbFxuICAgICAgICBNSURJLm5vdGVPbigwLCBtaWRpX25vdGUsIDEyNywgMClcbiAgICAgICAgTUlESS5ub3RlT2ZmKDAsIG1pZGlfbm90ZSwgZHVyYXRpb24pXG5cbiAgcmVmcmVzaDogLT5cbiAgICBpZiBAZG9uZVxuICAgICAgQHN0b3AoKVxuICAgICAgcmV0dXJuXG5cbiAgICBAY3VycmVudF90aWNrcyArPSBAdGlja3NfcGVyX3JlZnJlc2hcblxuICAgIGlmIEBjdXJyZW50X3RpY2tzID49IEBuZXh0X2V2ZW50X3RpY2sgYW5kIEBhbGxfdGlja3MubGVuZ3RoID4gMFxuICAgICAgQHBsYXlOb3RlIEBhbGxfdGlja3NbQG5leHRfaW5kZXhdLm5vdGVzXG4gICAgICBAbmV4dF9pbmRleCsrXG4gICAgICBpZiBAbmV4dF9pbmRleCA+PSBAYWxsX3RpY2tzLmxlbmd0aFxuICAgICAgICBAZG9uZSA9IHRydWVcbiAgICAgIGVsc2VcbiAgICAgICAgQG5leHRfZXZlbnRfdGljayA9IEBhbGxfdGlja3NbQG5leHRfaW5kZXhdLnRpY2sudmFsdWUoKVxuXG4gIHN0b3A6IC0+XG4gICAgTCBcIlN0b3BcIlxuICAgIHdpbmRvdy5jbGVhckludGVydmFsKEBpbnRlcnZhbF9pZCkgaWYgQGludGVydmFsX2lkP1xuICAgIEBwbGF5X2J1dHRvbi5maWxsQ29sb3IgPSAnIzM5NicgaWYgQHBsYXlfYnV0dG9uP1xuICAgIEBwYXBlci52aWV3LmRyYXcoKSBpZiBAcGFwZXI/XG4gICAgQGludGVydmFsX2lkID0gbnVsbFxuICAgIEBjdXJyZW50X3RpY2tzID0gMFxuICAgIEBuZXh0X2V2ZW50X3RpY2sgPSAwXG4gICAgQG5leHRfaW5kZXggPSAwXG4gICAgQGRvbmUgPSBmYWxzZVxuXG4gIHN0YXJ0OiAtPlxuICAgIEBzdG9wKClcbiAgICBMIFwiU3RhcnRcIlxuICAgIEBwbGF5X2J1dHRvbi5maWxsQ29sb3IgPSAnI2EzNicgaWYgQHBsYXlfYnV0dG9uP1xuICAgIE1JREkucHJvZ3JhbUNoYW5nZSgwLCBJTlNUUlVNRU5UU1tAb3B0aW9ucy5pbnN0cnVtZW50XSlcbiAgICBAcmVuZGVyKCkgIyB0cnkgdG8gdXBkYXRlLCBtYXliZSBub3RlcyB3ZXJlIGNoYW5nZWQgZHluYW1pY2FsbHlcbiAgICBAaW50ZXJ2YWxfaWQgPSB3aW5kb3cuc2V0SW50ZXJ2YWwoKCgpID0+IEByZWZyZXNoKCkpLCBAcmVmcmVzaF9yYXRlKVxuXG4gIHBsYXk6IC0+XG4gICAgTCBcIlBsYXk6IFwiLCBAcmVmcmVzaF9yYXRlLCBAdGlja3NfcGVyX3JlZnJlc2hcbiAgICBpZiBWZXguRmxvdy5QbGF5ZXIuSU5TVFJVTUVOVFNfTE9BREVEW0BvcHRpb25zLmluc3RydW1lbnRdIGFuZCBub3QgQGxvYWRpbmdcbiAgICAgIEBzdGFydCgpXG4gICAgZWxzZVxuICAgICAgTCBcIkxvYWRpbmcgaW5zdHJ1bWVudHMuLi5cIlxuICAgICAgQGxvYWRpbmdfbWVzc2FnZS5jb250ZW50ID0gXCJMb2FkaW5nIGluc3RydW1lbnRzLi4uXCJcbiAgICAgIEBsb2FkaW5nX21lc3NhZ2UuZmlsbENvbG9yID0gXCJncmVlblwiXG4gICAgICBAbG9hZGluZyA9IHRydWVcbiAgICAgIEBwYXBlci52aWV3LmRyYXcoKVxuXG4gICAgICBNSURJLmxvYWRQbHVnaW5cbiAgICAgICAgc291bmRmb250VXJsOiBAb3B0aW9ucy5zb3VuZGZvbnRfdXJsXG4gICAgICAgIGluc3RydW1lbnRzOiBbQG9wdGlvbnMuaW5zdHJ1bWVudF1cbiAgICAgICAgY2FsbGJhY2s6ICgpID0+XG4gICAgICAgICAgY29uc29sZS5sb2coXCJsb2FkUGx1Z2luIGlzIHN1Y2NjZXNmdWxseSBjYWxsaW5nIGJhY2suXCIpXG4gICAgICAgICAgVmV4LkZsb3cuUGxheWVyLklOU1RSVU1FTlRTX0xPQURFRFtAb3B0aW9ucy5pbnN0cnVtZW50XSA9IHRydWVcbiAgICAgICAgICBAbG9hZGluZyA9IGZhbHNlXG4gICAgICAgICAgQGxvYWRpbmdfbWVzc2FnZS5jb250ZW50ID0gXCJcIlxuICAgICAgICAgIEBzdGFydCgpXG5cbm1vZHVsZS5leHBvcnRzID0gVmV4LkZsb3cuUGxheWVyXG5cbiIsIiMgVmV4LkZsb3cuVmV4VGFiXG4jIENvcHlyaWdodCAyMDEyIE1vaGl0IENoZXBwdWRpcmEgPG1vaGl0QG11dGhhbm5hLmNvbT5cbiNcbiMgVGhpcyBjbGFzcyBpbXBsZW1lbnRzIHRoZSBzZW1hbnRpYyBhbmFseXNpcyBvZiB0aGUgSmlzb25cbiMgb3V0cHV0LCBhbmQgZ2VuZXJhdGVzIGVsZW1lbnRzIHRoYXQgY2FuIGJlIHVzZWQgYnlcbiMgVmV4LkZsb3cuQXJ0aXN0IHRvIHJlbmRlciB0aGUgbm90YXRpb24uXG4jIHBhcnNlZCBieSBWZXguRmxvdy5WZXhUYWIuXG5cblZleCA9IHJlcXVpcmUgJ3ZleGZsb3cnXG5fID0gcmVxdWlyZSAndW5kZXJzY29yZSdcbnBhcnNlciA9IHJlcXVpcmUgJy4uL2J1aWxkL3ZleHRhYi1qaXNvbi5qcydcblxuY2xhc3MgVmV4VGFiXG4gIEBERUJVRyA9IGZhbHNlXG4gIEwgPSAoYXJncy4uLikgLT4gY29uc29sZT8ubG9nKFwiKFZleC5GbG93LlZleFRhYilcIiwgYXJncy4uLikgaWYgVmV4VGFiLkRFQlVHXG5cbiAgIyBQcml2YXRlIG1ldGhvZHNcbiAgbmV3RXJyb3IgPSAob2JqZWN0LCBtc2cpIC0+XG4gICAgbmV3IFZleC5SRVJSKFwiUGFyc2VFcnJvclwiLFxuICAgICAgICAgICAgICAgICBcIiN7bXNnfSBpbiBsaW5lICN7b2JqZWN0Ll9sfSBjb2x1bW4gI3tvYmplY3QuX2N9XCIpXG5cbiAgIyBQdWJsaWMgbWV0aG9kc1xuICBjb25zdHJ1Y3RvcjogKEBhcnRpc3QpIC0+XG4gICAgQHJlc2V0KClcblxuICByZXNldDogLT5cbiAgICBAdmFsaWQgPSBmYWxzZVxuICAgIEBlbGVtZW50cyA9IGZhbHNlXG5cbiAgaXNWYWxpZDogLT4gQHZhbGlkXG5cbiAgZ2V0QXJ0aXN0OiAtPiByZXR1cm4gQGFydGlzdFxuXG4gIHBhcnNlU3RhdmVPcHRpb25zOiAob3B0aW9ucykgLT5cbiAgICBwYXJhbXMgPSB7fVxuICAgIHJldHVybiBwYXJhbXMgdW5sZXNzIG9wdGlvbnM/XG5cbiAgICBub3RhdGlvbl9vcHRpb24gPSBudWxsXG4gICAgZm9yIG9wdGlvbiBpbiBvcHRpb25zXG4gICAgICBlcnJvciA9IChtc2cpIC0+IG5ld0Vycm9yKG9wdGlvbiwgbXNnKVxuICAgICAgcGFyYW1zW29wdGlvbi5rZXldID0gb3B0aW9uLnZhbHVlXG4gICAgICBzd2l0Y2ggb3B0aW9uLmtleVxuICAgICAgICB3aGVuIFwibm90YXRpb25cIiwgXCJ0YWJsYXR1cmVcIlxuICAgICAgICAgIG5vdGF0aW9uX29wdGlvbiA9IG9wdGlvblxuICAgICAgICAgIHRocm93IGVycm9yKFwiJyN7b3B0aW9uLmtleX0nIG11c3QgYmUgJ3RydWUnIG9yICdmYWxzZSdcIikgaWYgb3B0aW9uLnZhbHVlIG5vdCBpbiBbXCJ0cnVlXCIsIFwiZmFsc2VcIl1cbiAgICAgICAgd2hlbiBcImtleVwiXG4gICAgICAgICAgdGhyb3cgZXJyb3IoXCJJbnZhbGlkIGtleSBzaWduYXR1cmUgJyN7b3B0aW9uLnZhbHVlfSdcIikgdW5sZXNzIF8uaGFzKFZleC5GbG93LmtleVNpZ25hdHVyZS5rZXlTcGVjcywgb3B0aW9uLnZhbHVlKVxuICAgICAgICB3aGVuIFwiY2xlZlwiXG4gICAgICAgICAgY2xlZnMgPSBbXCJ0cmVibGVcIiwgXCJiYXNzXCIsIFwidGVub3JcIiwgXCJhbHRvXCIsIFwicGVyY3Vzc2lvblwiLCBcIm5vbmVcIl1cbiAgICAgICAgICB0aHJvdyBlcnJvcihcIidjbGVmJyBtdXN0IGJlIG9uZSBvZiAje2NsZWZzLmpvaW4oJywgJyl9XCIpIGlmIG9wdGlvbi52YWx1ZSBub3QgaW4gY2xlZnNcbiAgICAgICAgd2hlbiBcInZvaWNlXCJcbiAgICAgICAgICB2b2ljZXMgPSBbXCJ0b3BcIiwgXCJib3R0b21cIiwgXCJuZXdcIl1cbiAgICAgICAgICB0aHJvdyBlcnJvcihcIid2b2ljZScgbXVzdCBiZSBvbmUgb2YgI3t2b2ljZXMuam9pbignLCAnKX1cIikgaWYgb3B0aW9uLnZhbHVlIG5vdCBpbiB2b2ljZXNcbiAgICAgICAgd2hlbiBcInRpbWVcIlxuICAgICAgICAgIHRyeVxuICAgICAgICAgICAgbmV3IFZleC5GbG93LlRpbWVTaWduYXR1cmUob3B0aW9uLnZhbHVlKVxuICAgICAgICAgIGNhdGNoIGVcbiAgICAgICAgICAgIHRocm93IGVycm9yKFwiSW52YWxpZCB0aW1lIHNpZ25hdHVyZTogJyN7b3B0aW9uLnZhbHVlfSdcIilcbiAgICAgICAgd2hlbiBcInR1bmluZ1wiXG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBuZXcgVmV4LkZsb3cuVHVuaW5nKG9wdGlvbi52YWx1ZSlcbiAgICAgICAgICBjYXRjaCBlXG4gICAgICAgICAgICB0aHJvdyBlcnJvcihcIkludmFsaWQgdHVuaW5nOiAnI3tvcHRpb24udmFsdWV9J1wiKVxuICAgICAgICB3aGVuIFwic3RyaW5nc1wiXG4gICAgICAgICAgbnVtX3N0cmluZ3MgPSBwYXJzZUludChvcHRpb24udmFsdWUpXG4gICAgICAgICAgdGhyb3cgZXJyb3IoXCJJbnZhbGlkIG51bWJlciBvZiBzdHJpbmdzOiAje251bV9zdHJpbmdzfVwiKSBpZiAobnVtX3N0cmluZ3MgPCA0IG9yIG51bV9zdHJpbmdzID4gOClcbiAgICAgICAgZWxzZVxuICAgICAgICAgIHRocm93IGVycm9yKFwiSW52YWxpZCBvcHRpb24gJyN7b3B0aW9uLmtleX0nXCIpXG5cbiAgICBpZiBwYXJhbXMubm90YXRpb24gPT0gXCJmYWxzZVwiIGFuZCBwYXJhbXMudGFibGF0dXJlID09IFwiZmFsc2VcIlxuICAgICAgdGhyb3cgbmV3RXJyb3Iobm90YXRpb25fb3B0aW9uLCBcIkJvdGggJ25vdGF0aW9uJyBhbmQgJ3RhYmxhdHVyZScgY2FuJ3QgYmUgaW52aXNpYmxlXCIpXG5cbiAgICByZXR1cm4gcGFyYW1zXG5cbiAgcGFyc2VDb21tYW5kOiAoZWxlbWVudCkgLT5cbiAgICBpZiBlbGVtZW50LmNvbW1hbmQgaXMgXCJiYXJcIlxuICAgICAgQGFydGlzdC5hZGRCYXIoZWxlbWVudC50eXBlKVxuXG4gICAgaWYgZWxlbWVudC5jb21tYW5kIGlzIFwidHVwbGV0XCJcbiAgICAgIEBhcnRpc3QubWFrZVR1cGxldHMoZWxlbWVudC5wYXJhbXMudHVwbGV0LCBlbGVtZW50LnBhcmFtcy5ub3RlcylcblxuICAgIGlmIGVsZW1lbnQuY29tbWFuZCBpcyBcImFubm90YXRpb25zXCJcbiAgICAgIEBhcnRpc3QuYWRkQW5ub3RhdGlvbnMoZWxlbWVudC5wYXJhbXMpXG5cbiAgICBpZiBlbGVtZW50LmNvbW1hbmQgaXMgXCJyZXN0XCJcbiAgICAgIEBhcnRpc3QuYWRkUmVzdChlbGVtZW50LnBhcmFtcylcblxuICAgIGlmIGVsZW1lbnQuY29tbWFuZCBpcyBcImNvbW1hbmRcIlxuICAgICAgQGFydGlzdC5ydW5Db21tYW5kKGVsZW1lbnQucGFyYW1zLCBlbGVtZW50Ll9sLCBlbGVtZW50Ll9jKVxuXG4gIHBhcnNlQ2hvcmQ6IChlbGVtZW50KSAtPlxuICAgIEwgXCJwYXJzZUNob3JkOlwiLCBlbGVtZW50XG4gICAgQGFydGlzdC5hZGRDaG9yZChcbiAgICAgIF8ubWFwKGVsZW1lbnQuY2hvcmQsXG4gICAgICAgICAgICAobm90ZSktPiBfLnBpY2sobm90ZSwgJ3RpbWUnLCAnZG90JywgJ2ZyZXQnLCAnYWJjJywgJ29jdGF2ZScsICdzdHJpbmcnLCAnYXJ0aWN1bGF0aW9uJywgJ2RlY29yYXRvcicpKSxcbiAgICAgIGVsZW1lbnQuYXJ0aWN1bGF0aW9uLCBlbGVtZW50LmRlY29yYXRvcilcblxuICBwYXJzZUZyZXQ6IChub3RlKSAtPlxuICAgIEBhcnRpc3QuYWRkTm90ZShfLnBpY2soXG4gICAgICBub3RlLCAndGltZScsICdkb3QnLCAnZnJldCcsICdzdHJpbmcnLCAnYXJ0aWN1bGF0aW9uJywgJ2RlY29yYXRvcicpKVxuXG4gIHBhcnNlQUJDOiAobm90ZSkgLT5cbiAgICBAYXJ0aXN0LmFkZE5vdGUoXy5waWNrKFxuICAgICAgbm90ZSwgJ3RpbWUnLCAnZG90JywgJ2ZyZXQnLCAnYWJjJywgJ29jdGF2ZScsICdzdHJpbmcnLCAnYXJ0aWN1bGF0aW9uJywgJ2RlY29yYXRvcicpKVxuXG4gIHBhcnNlU3RhdmVFbGVtZW50czogKG5vdGVzKSAtPlxuICAgIEwgXCJwYXJzZVN0YXZlRWxlbWVudHM6XCIsIG5vdGVzXG4gICAgZm9yIGVsZW1lbnQgaW4gbm90ZXNcbiAgICAgIGlmIGVsZW1lbnQudGltZVxuICAgICAgICBAYXJ0aXN0LnNldER1cmF0aW9uKGVsZW1lbnQudGltZSwgZWxlbWVudC5kb3QpXG5cbiAgICAgIGlmIGVsZW1lbnQuY29tbWFuZFxuICAgICAgICBAcGFyc2VDb21tYW5kKGVsZW1lbnQpXG5cbiAgICAgIGlmIGVsZW1lbnQuY2hvcmRcbiAgICAgICAgQHBhcnNlQ2hvcmQoZWxlbWVudClcblxuICAgICAgaWYgZWxlbWVudC5hYmNcbiAgICAgICAgQHBhcnNlQUJDKGVsZW1lbnQpXG4gICAgICBlbHNlIGlmIGVsZW1lbnQuZnJldFxuICAgICAgICBAcGFyc2VGcmV0KGVsZW1lbnQpXG5cbiAgcGFyc2VTdGF2ZVRleHQ6ICh0ZXh0X2xpbmUpIC0+XG4gICAgQGFydGlzdC5hZGRUZXh0Vm9pY2UoKSB1bmxlc3MgXy5pc0VtcHR5KHRleHRfbGluZSlcblxuICAgIHBvc2l0aW9uID0gMFxuICAgIGp1c3RpZmljYXRpb24gPSBcImNlbnRlclwiXG4gICAgc21vb3RoID0gdHJ1ZVxuICAgIGZvbnQgPSBudWxsXG5cbiAgICBiYXJ0ZXh0ID0gPT4gQGFydGlzdC5hZGRUZXh0Tm90ZShcIlwiLCAwLCBqdXN0aWZpY2F0aW9uLCBmYWxzZSwgdHJ1ZSlcbiAgICBjcmVhdGVOb3RlID0gKHRleHQpID0+XG4gICAgICBpZ25vcmVfdGlja3MgPSBmYWxzZVxuICAgICAgaWYgdGV4dFswXSA9PSBcInxcIlxuICAgICAgICBpZ25vcmVfdGlja3MgPSB0cnVlXG4gICAgICAgIHRleHQgPSB0ZXh0WzEuLl1cblxuICAgICAgdHJ5XG4gICAgICAgIEBhcnRpc3QuYWRkVGV4dE5vdGUodGV4dCwgcG9zaXRpb24sIGp1c3RpZmljYXRpb24sIHNtb290aCwgaWdub3JlX3RpY2tzKVxuICAgICAgY2F0Y2ggZVxuICAgICAgICB0aHJvdyBuZXdFcnJvcihzdHIsIFwiQmFkIHRleHQgb3IgZHVyYXRpb24uIERpZCB5b3UgZm9yZ2V0IGEgY29tbWE/XCIgKyBlKVxuXG4gICAgZm9yIHN0ciBpbiB0ZXh0X2xpbmVcbiAgICAgIHRleHQgPSBzdHIudGV4dC50cmltKClcbiAgICAgIGlmIHRleHQubWF0Y2goL1xcLmZvbnQ9LiovKVxuICAgICAgICBmb250ID0gdGV4dFs2Li5dXG4gICAgICAgIEBhcnRpc3Quc2V0VGV4dEZvbnQoZm9udClcbiAgICAgIGVsc2UgaWYgdGV4dFswXSA9PSBcIjpcIlxuICAgICAgICBAYXJ0aXN0LnNldER1cmF0aW9uKHRleHQpXG4gICAgICBlbHNlIGlmIHRleHRbMF0gPT0gXCIuXCJcbiAgICAgICAgY29tbWFuZCA9IHRleHRbMS4uXVxuICAgICAgICBzd2l0Y2ggY29tbWFuZFxuICAgICAgICAgIHdoZW4gXCJjZW50ZXJcIiwgXCJsZWZ0XCIsIFwicmlnaHRcIlxuICAgICAgICAgICAganVzdGlmaWNhdGlvbiA9IGNvbW1hbmRcbiAgICAgICAgICB3aGVuIFwic3RyaWN0XCJcbiAgICAgICAgICAgIHNtb290aCA9IGZhbHNlXG4gICAgICAgICAgd2hlbiBcInNtb290aFwiXG4gICAgICAgICAgICBzbW9vdGggPSB0cnVlXG4gICAgICAgICAgd2hlbiBcImJhclwiLCBcInxcIlxuICAgICAgICAgICAgYmFydGV4dCgpXG4gICAgICAgICAgZWxzZVxuICAgICAgICAgICAgcG9zaXRpb24gPSBwYXJzZUludCh0ZXh0WzEuLl0sIDEwKVxuICAgICAgZWxzZSBpZiB0ZXh0ID09IFwifFwiXG4gICAgICAgIGJhcnRleHQoKVxuICAgICAgZWxzZSBpZiB0ZXh0WzAuLjFdID09IFwiKytcIlxuICAgICAgICBAYXJ0aXN0LmFkZFRleHRWb2ljZSgpXG4gICAgICBlbHNlXG4gICAgICAgIGNyZWF0ZU5vdGUodGV4dClcblxuICBnZW5lcmF0ZTogLT5cbiAgICBmb3Igc3RhdmUgaW4gQGVsZW1lbnRzXG4gICAgICBzd2l0Y2ggc3RhdmUuZWxlbWVudFxuICAgICAgICB3aGVuIFwic3RhdmVncm91cFwiXG4gICAgICAgICAgbmV3U3RhdmVHcm91cEluZGV4ID0gQGFydGlzdC5zdGF2ZUdyb3Vwc0xlbmd0aCgpXG4gICAgICAgICAgQGFydGlzdC5hZGRTdGF2ZUdyb3VwKClcbiAgICAgICAgICBmb3IgcyBpbiBzdGF2ZS5zdGF2ZWxpc3RcbiAgICAgICAgICAgIEwgXCJzdGF2ZSBpbiBnZW5lcmF0ZVwiLCBzXG4gICAgICAgICAgICBAYXJ0aXN0LmFkZFN0YXZlKFxuICAgICAgICAgICAgICBuZXdTdGF2ZUdyb3VwSW5kZXgsXG4gICAgICAgICAgICAgIHMuZWxlbWVudCxcbiAgICAgICAgICAgICAgQHBhcnNlU3RhdmVPcHRpb25zKHMub3B0aW9ucylcbiAgICAgICAgICAgIClcbiAgICAgICAgICAgIEBwYXJzZVN0YXZlRWxlbWVudHMocy5ub3RlcykgaWYgcy5ub3Rlcz9cbiAgICAgICAgICAgIEBwYXJzZVN0YXZlVGV4dChzLnRleHQpIGlmIHMudGV4dD9cbiAgICAgICAgICBMIFwiU3RhdmVncm91cCBnZW5lcmF0ZWRcIiwgQGFydGlzdC5zdGF2ZWdyb3Vwc1tuZXdTdGF2ZUdyb3VwSW5kZXhdXG4gICAgICAgIHdoZW4gXCJ2b2ljZVwiXG4gICAgICAgICAgTCBcInNraXBwaW5nIHZvaWNlIGZvciBub3cuXCJcbiMgICAgICAgICAgQGFydGlzdC5hZGRWb2ljZShAcGFyc2VTdGF2ZU9wdGlvbnMoc3RhdmUub3B0aW9ucykpXG4jICAgICAgICAgIEBwYXJzZVN0YXZlRWxlbWVudHMoc3RhdmUubm90ZXMpIGlmIHN0YXZlLm5vdGVzP1xuIyAgICAgICAgICBAcGFyc2VTdGF2ZVRleHQoc3RhdmUudGV4dCkgaWYgc3RhdmUudGV4dD9cbiAgICAgICAgd2hlbiBcIm9wdGlvbnNcIlxuICAgICAgICAgIG9wdGlvbnMgPSB7fVxuICAgICAgICAgIGZvciBvcHRpb24gaW4gc3RhdmUucGFyYW1zXG4gICAgICAgICAgICBvcHRpb25zW29wdGlvbi5rZXldID0gb3B0aW9uLnZhbHVlXG4gICAgICAgICAgdHJ5XG4gICAgICAgICAgICBAYXJ0aXN0LnNldE9wdGlvbnMob3B0aW9ucylcbiAgICAgICAgICBjYXRjaCBlXG4gICAgICAgICAgICB0aHJvdyBuZXdFcnJvcihzdGF2ZSwgZS5tZXNzYWdlKVxuICAgICAgICBlbHNlXG4gICAgICAgICAgdGhyb3cgbmV3RXJyb3Ioc3RhdmUsIFwiSW52YWxpZCBrZXl3b3JkICcje3N0YXZlLmVsZW1lbnR9J1wiKVxuXG4gIHBhcnNlOiAoY29kZSkgLT5cbiAgICBwYXJzZXIucGFyc2VFcnJvciA9IChtZXNzYWdlLCBoYXNoKSAtPlxuICAgICAgTCBcIlZleFRhYiBwYXJzZSBlcnJvcjogXCIsIG1lc3NhZ2UsIGhhc2hcbiAgICAgIG1lc3NhZ2UgPSBcIlVuZXhwZWN0ZWQgdGV4dCAnI3toYXNoLnRleHR9JyBhdCBsaW5lICN7aGFzaC5sb2MuZmlyc3RfbGluZX0gY29sdW1uICN7aGFzaC5sb2MuZmlyc3RfY29sdW1ufS5cIlxuICAgICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiUGFyc2VFcnJvclwiLCBtZXNzYWdlKVxuXG4gICAgdGhyb3cgbmV3IFZleC5SRVJSKFwiUGFyc2VFcnJvclwiLCBcIk5vIGNvZGVcIikgdW5sZXNzIGNvZGU/XG5cbiAgICBMIFwiUGFyc2luZzpcXG4je2NvZGV9XCJcblxuICAgICMgU3RyaXAgbGluZXNcbiAgICBzdHJpcHBlZF9jb2RlID0gKGxpbmUudHJpbSgpIGZvciBsaW5lIGluIGNvZGUuc3BsaXQoL1xcclxcbnxcXHJ8XFxuLykpXG4gICAgQGVsZW1lbnRzID0gcGFyc2VyLnBhcnNlKHN0cmlwcGVkX2NvZGUuam9pbihcIlxcblwiKSlcbiAgICBpZiBAZWxlbWVudHNcbiAgICAgIEBnZW5lcmF0ZSgpXG4gICAgICBAdmFsaWQgPSB0cnVlXG5cbiAgICByZXR1cm4gQGVsZW1lbnRzXG5cbm1vZHVsZS5leHBvcnRzID0gVmV4VGFiXG4iLCIvLyBMb2FkIFZleFRhYiBtb2R1bGUuXG52ZXh0YWIgPSByZXF1aXJlKFwidmV4dGFiXCIpO1xuJCA9IHJlcXVpcmUoXCJqcXVlcnlcIik7XG5fID0gcmVxdWlyZShcInVuZGVyc2NvcmVcIik7XG5cbiQoZnVuY3Rpb24oKSB7XG4gIFZleFRhYiA9IHZleHRhYi5WZXhUYWI7XG4gIEFydGlzdCA9IHZleHRhYi5BcnRpc3Q7XG4gIFJlbmRlcmVyID0gdmV4dGFiLlZleC5GbG93LlJlbmRlcmVyO1xuICBQbGF5ZXIgPSB2ZXh0YWIuUGxheWVyO1xuXG4gIEFydGlzdC5ERUJVRyA9IHRydWU7XG4gIFZleFRhYi5ERUJVRyA9IHRydWU7XG4gIFBsYXllci5ERUJVRyA9IGZhbHNlO1xuXG4gIC8vIENyZWF0ZSBWZXhGbG93IFJlbmRlcmVyIGZyb20gY2FudmFzIGVsZW1lbnQgd2l0aCBpZCAjYm9vXG4gIHJlbmRlcmVyID0gbmV3IFJlbmRlcmVyKCQoJyNib28nKVswXSwgUmVuZGVyZXIuQmFja2VuZHMuQ0FOVkFTKTtcblxuICAvLyBJbml0aWFsaXplIFZleFRhYiBhcnRpc3QgYW5kIHBhcnNlci5cbiAgYXJ0aXN0ID0gbmV3IEFydGlzdCgxMCwgMTAsIDYwMCwge3NjYWxlOiAwLjh9KTtcbiAgcGxheWVyID0gbmV3IFBsYXllcihhcnRpc3QpO1xuICB2ZXh0YWIgPSBuZXcgVmV4VGFiKGFydGlzdCk7XG5cbiAgZnVuY3Rpb24gcmVuZGVyKCkge1xuICAgIHRyeSB7XG4gICAgICB2ZXh0YWIucmVzZXQoKTtcbiAgICAgIGFydGlzdC5yZXNldCgpO1xuICAgICAgdmV4dGFiLnBhcnNlKCQoXCIjYmxhaFwiKS52YWwoKSk7XG4gICAgICBhcnRpc3QucmVuZGVyKHJlbmRlcmVyKTtcbiAgICAgICQoXCIjZXJyb3JcIikudGV4dChcIlwiKTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBjb25zb2xlLmxvZyhlKTtcbiAgICAgICQoXCIjZXJyb3JcIikuaHRtbChlLm1lc3NhZ2UucmVwbGFjZSgvW1xcbl0vZywgJzxici8+JykpO1xuICAgIH1cbiAgfVxuXG4gICQoXCIjYmxhaFwiKS5rZXl1cChfLnRocm90dGxlKHJlbmRlciwgMjUwKSk7XG4gIHJlbmRlcigpO1xufSk7XG4iXX0=
